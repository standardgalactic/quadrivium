
Developing Software for 
the OUALCOMM BREW Platform 
.. 
RAYRISCHPATER 
APress Media, LLC 

Developing Software for the QUALCOMM BREW Platform 
Copyright Â©2003 by Ray Rischpater 
Originally published by Apress in 2003 
All rights reserved. No part of this work may be reproduced or transmitted in any form or by any 
means, electronic or mechanical, including photocopying, recording, or by any information 
storage or retrieval system, without the prior written permission of the copyright owner and the 
publisher. 
ISBN 978-1-59059-116-1 
ISBN 978-1-4302-0802-0 (eBook) 
DOI 10.1007/978-1-4302-0802-0 
Trademarked names may appear in this book. Rather than use a trademark symbol with every 
occurrence of a trademarked name, we use the names only in an editorial fashion and to the 
benefit of the trademark owner, with no intention of infringement of the trademark. 
Technical Reviewer: Shane Conder 
Editorial Board: Dan Appleman, Craig Berry, Gary Cornell, Tony Davis, Steven Rycroft, Julian 
Skinner, Martin Streicher, Jim Sumser, Karen Watterson, Gavin Wray, John Zukowski 
Assistant Publisher: Grace Wong 
Project Manager: Nate McFadden 
Copy Editor: KimWimpsett 
Production Manager: Kari Brooks 
Production Editor: Janet Vail 
Proofreader: KimCofer 
Compositor: Argosy Publishing 
Indexer: Carol Burbo 
Artist: Cara Brunk 
Cover Designer: Kurt Krames 
Manufacturing Manager: Tom Debolski 
Distributed to the book trade in the United States by Springer-Verlag New York, Inc., 175 Fifth 
Avenue, New York, NY, 10010 and outside the United States by Springer-Verlag GmbH & Co. KG, 
Tiergartenstr. 17,69112 Heidelberg, Germany. 
In the United States, phone 1-800-SPRINGER, email orders@springer-ny. com, or visit 
http: //www. springer-ny.com. Outside the United States, fax +49 6221345229, email 
ordersgspringer. de, or visit http: //www, springer. de. 
For information on translations, please contact Apress directly at 2560 Ninth Street, Suite 219, 
Berkeley, CA 94710. Phone 510-549-5930, fax 510-549-5939, email inf Ogapress. com, or visit 
http://www.apress.com. 
The information in this book is distributed on an "as is" basis, without warranty. Although every 
precaution has been taken in the preparation of this work, neither the author(s) nor Apress shall 
have any liability to any person or entity with respect to any loss or damage caused or alleged to 
be caused directly or indirectly by the information contained in this work. 
The source code for this book is available to readers at http: //www. apress. com in the 
Downloads section. 

Contents at a Glance 
About the Author ................................................................................................. ix 
About the Technical Reviewer ...................................................................... xi 
Acknowledgments ................................................................................................... xiii 
Introduction 
Chapter 1 
Chapter 2 
Chapter 3 
Chapter 4 
Chapter 5 
Chapter 6 
Chapter 7 
Chapter 8 
Chapter 9 
Chapter 10 
Chapter 11 
Chapter 12 
......................................................................................................... xv 
Introducing the QUALCOMM BREW Platform .................... 1 
Designing for the QUALCOMM BREW Platform ............. 21 
Developing for the QUALCOMM BREW Platform ........... 33 
Handling Events .................................................................... 63 
Interacting with the User- ............................................. 107 
Streaming Data .................................................................... 159 
Storing Data ........................................................................ 173 
Drawing Graphics ................................................................ 203 
Playing with Sounds ......................................................... 237 
Networking Your Data ....................................................... 253 
Controlling the Handset ................................................ 267 
Certifying Your Application ........................................ 287 
Index ........................................................................................................................ 297 
iii 

Contents 
About the Author .......................................................................... ix 
About the Technical Reviewer ................................................ xi 
Acknowledgments ............................................................................ xiii 
Introduction .................................................................................. xv 
Chapter 1 
Introducing the QUALCQMM BREW 
Platform .......................................................... 1 
Seeing the QUALCOMM BREW Platform for 
the First Time ........................................................................ 1 
Choosing the QUALCOMM BREW Platform ................................. 3 
Understanding the QUALCOMM BREW Platform ...................... 6 
Creating Your First Application .......................................... 8 
Summary ............................................................................................. 20 
Chapter 2 
Designing for the 
QUALCQMM BREW Platform .................... 21 
Starting with a Design ............................................................ 21 
Understanding the User ............................................................ 23 
Understanding the RocketMileage Application .............. 25 
Summary ............................................................................................. 32 
Chapter 3 
Developing for the 
QUALCOMM BREW Platform .................... 33 
Getting Started with Development ...................................... 33 
Using the QUALCOMM BREW Developer Tools ...................... .46 
Summary ............................................................................................. 61 
Chapter 4 
Handling Events ...................................... 63 
Understanding the Event Model ............................................ 63 
Building an Application Framework .................................... 68 
Presenting a Prototype User Interface ........................... 80 
Summary ........................................................................................... 106 
v 

Contents 
Chapter 5 
Interacting with the User ......... 107 
Understanding Modes of User Interaction .................... 107 
Using the QUALCOMM BREW Controls ................................... 110 
Integrating Controls with Your Application 
Framework .............................................................................. 136 
Tying It All Together ........................................................... 152 
Summary .......................................................................................... 158 
Chapter 6 
Streaming Data ...................................... 159 
Understanding the Stream Interface ............................... 159 
Understanding the Implementations of IAStream ....... 160 
Using the Stream Interface ................................................ 163 
Summary .......................................................................................... 171 
Chapter 7 
Storing Data ........................................... 173 
Choosing to Use a Database ................................................ 173 
Interfacing with a Database .............................................. 175 
Overcoming Issues with the Database Interface ....... 184 
Using a Database in a Real Application ...................... 186 
Summary .......................................................................................... 201 
Chapter 8 
Drawing Graphics ................................ 203 
Understanding QUALCOMM BREW Graphics 
Capabilities ........................................................................ 203 
Using the IGraphics Interface .......................................... 210 
Using the ISprite Interface .............................................. 219 
Summary .......................................................................................... 235 
Chapter 9 
Playing with Sounds ......................... 237 
Representing Sound .................................................................. 237 
Understanding How to Play Sounds ................................... 239 
Using the ISoundPlayer Interface in 
an Application .................................................................... 245 
Summary .......................................................................................... 250 
vi 

Contents 
Chapter 1.0 Networking Your Data ...................... 253 
Choosing Wireless Network Options ................................. 253 
Understanding the Network Interfaces ........................... 257 
Summary .......................................................................................... 265 
Chapter 1.1. Controlling the Handset .............. 267 
Accessing the Built-in Address Book ............................. 267 
Sharing Code Between Applications ................................. 277 
Summary .......................................................................................... 285 
Chapter 1.2 Certifying Your Application .... 287 
Validating Your Application .............................................. 287 
Submitting Your Application for Certification ....... 290 
Failing Certification: 
The Top Five Ways to Fail ............................................ 292 
Pricing and Promoting Your Application ...................... 294 
Summary .......................................................................................... 295 
Index ................................................................................................ 297 
vii 

About the Author 
Ray Rischpater is a software engineer and writer who has focused on mobile com-
puting since 1995. During that time, he has developed countless applications for 
Fortune 500 companies using handheld computers and wireless interfaces for 
enterprise and commercial deployment. This includes the first handheld Web 
server on a commercially available platform and the development of several of the 
first handheld Web browsers available, including those for the Apple Newton and 
Palm Powered platforms. He's the author of seven books and 48 articles on mobile 
and wireless computing. 
When not aggressively pursuing his avocation as a full-time geek and evan-
gelist of the geek lifestyle, Ray spends time with his family hiking, camping, and 
providing public service using amateur radio. 
Ray is a member of the IEEE and is currently employed as a staff engineer at 
Rocket Mobile, where he develops Web-based applications and services for the 
QUALCOMM BREW platform and other mobile wireless platforms. 
ix 

About the 
Technical Reviewer 
Shane Conder is a software engineering professional specializing in wireless 
BREW applications. He spends his precious free time road tripping and traveling, 
and he's an avid amateur radio hobbyist. He lives in Santa Cruz, California, with his 
fiancee, Lauren, and six rabbits named Bit, Nibble, Heap, Qubit, Stack, and Null. 
xi 

Acknowledgments 
IT SEEMS THAT with each passing book I write, I widen my debt to others. Writing 
any book is a collaborative effort, but the input and feedback I've received in 
developing this one far surpasses any other I've had the pleasure of attempting. 
Primarily, I'm indebted to my family, Rachel and Jarod, for their ongoing 
support as I continue to juggle writing, work, and my responsibilities as a husband 
and father. For you, Rachel, my soul mate, lowe you the world. And Jarod, my son, 
thank you for your 1Uesdays and Thursdays of infinite patience as your daddy sat 
hunched beside you on the couch, typing away and pausing occasionally to read 
you another page (often of what he was writing and not what you were reading!). 
Of course, I am again indebted to the staff at Apress for their contribution 
throughout this book. As always, Kim WlDlpsett was there with excellent editorial 
input and an eye for consistency and detail that I only wish I could have. Simon 
Hayes, Jim Sumser, and Nate McFadden shepherded the book along the course 
from idea to manuscript to the tome you now hold, patiently enduring my notion 
of a schedule as a mere skeleton on which to hang the occasional delivery. Of 
course, there were countless others at Apress who gave their support; most unfor-
tunately go thankless and unacknowledged. Rest assured that I'm well aware of 
your efforts, and I'm deeply grateful to your contributions in making this book 
what it is today. 
Shane Conder, my technical editor, is both a first-rate developer and a true 
friend. lowe him tremendous thanks in prOviding his input and wisdom per-
taining to the QUALCOMM BREW platform and in carefully scrutinizing each page 
and testing each application before errors slipped through. His deep knowledge of 
QUALCOMM BREW is reflected in this book through a number of well-crafted 
points and corrections, and in many cases his suggestions paved the way for a 
better discussion of some of the more challenging aspects of learning the 
QUALCOMM BREW platform. Of course, any errors that remain rest on my 
shoulders, not his. 
In many ways, this book didn't just have one technical editor but rather six. 
From the early drafts of the first chapter, my colleagues at Rocket Mobile-most of 
whom were either actively developing applications for the QUALCOMM BREW 
platform or anxious to learn the platform-harangued me for draft chapters and 
were more than willing to offer input and corrections in return. These are people 
with whom I've shared offices, projects, and time, often for many years, and I'm 
thankful not just for the time they invested in this work but my ongoing profes-
sional and personal relationships with them. For Erik Browne, Graham Darcey, 
Konstantin Kraz, Spencer Nassar, and Charles Stearns, my thanks go to you as con-
tributors second and as friends first. I'd also like to take a moment and thank 
xiii 

Acknowledgments 
xiv 
Dr. William Confer of Auburn University, who provided valuable feedback and 
positive encouragement during the final editing phases of the project. 
A special thanks is also due to my manager at Rocket Mobile, Wayne Yurtin, 
who openly supported this book with corporate contacts, frequent comments, 
and the opportunity to include large segments of RocketMileage as a sample 
application accompanying this book. It's rare to have the opportunity to offer the 
source code to a conunercially available application (outside of open source) to 
the public, and his open-mindedness and respect for the greater QUALCOMM 
BREW development community is worthy of note. 

Introduction 
ANALYSTS AND PUNDITS alike have been pointing to the promise of a revolution in 
wireless telephony for several years. The increasing number of so-called "con-
vergent" devices-smart phones with keyboards, Personal Digital Assistants 
(PDAs) with cellular radios, or hybrid PDA phones-clearly heralds the onset of a 
new way of viewing computing and communication. 
QUALCOMM, the inventor and leading manufacturer of Code Division 
Multiple Access (CDMA) technology, has introduced the QUALCOMM BREW 
platform to permit software developers like you and me to deliver high-quality 
applications to wireless subscribers everywhere. QUALCOMM BREW consists 
of the client layer, which is a thin layer of Application Programming Interfaces 
(APIs) that resides atop the chip set in many of to day's wireless handsets, and 
a back-end delivery system for carriers, which consolidates software deployment, 
delivery, and payment with the handset and subscriber's billing system. The 
QUALCOMM BREW platform is available on more than two million handsets 
today. Furthermore, more than 50 percent of handset users regularly purchase 
applications with their QUALCOMM BREW-enabled handsets, and the platform is 
available from major carriers in several countries, includingVerizon WIreless, 
AlITel, and U.S. Cellular in the United States, China Unicom in China, Vivo in 
Brazil, KDDI in Japan, Telstra in Australia, and KTF in South Korea. 
With mobile handsets expected to surpass other kinds of data connectivity by 
2005, and with QUALCOMM BREW leading the pack for mobile wireless appli-
cation development and deployment, now is the time for you to begin developing 
applications for the QUALCOMM BREW platform. 
Who Needs to Read This Book 
If you're a software developer interested in bringing your application to the latest 
crop of smart phones running QUALCOMM BREw, this book is for you. Because of 
the wide variety of application developers and possible applications for the 
QUALCOMM BREW platform, I make only a few assumptions about your expe-
rience. You should be familiar with programming in C and comfortable with the 
basics of application development on at least one platform. I don't, however, 
expect that you have previous experience developing applications for wireless ter-
minals. If you do-or if you've already used the QUALCOMM BREW platform to 
develop and deploy applications-you still have much to gain because I present 
many advanced concepts about application development for the platform. 
Although you can write applications for QUALCOMM BREW using C++, I've 
chosen to use only C throughout this book, both because the vast majority of 
BREW applications are written in C and because many C++ features don't mesh 
well with the paradigms of programming for the platform. Consequently, you don't 
xv 

Introduction 
xvi 
need to know c++ to read this book, but some concepts may be familiar to you if 
you've used it in the past. 
If you're responsible for other aspects of software deployment for the 
QUALCOMM BREW platform, such as project management or quality assurance, 
several chapters of this book, especially the first two chapters and the last chapter, 
will be of interest to you. 
What You Will Find in This Book 
I wrote this book with the assumption that you've never written applications for 
the QUALCOMM BREW platform. Consequently, the book tells a story, starting 
with the how, why, and wherefore of the QUALCOMM BREW platform, and then 
builds from there to show you how to construct user interfaces, an application 
framework, storage, and network subsystems when building your application. 
Chapter 1, "Introducing the QUALCOMM BREW Platform," does just that, 
showing you why you should be developing applications for the platform if you're 
not already. In addition, it compares the platform with other platforms such as 
Sun's Java 2 Micro Edition and shows the strengths and weaknesses of each. 
Chapter 2, "Designing for the QUALCOMM BREW Platform," takes a step back 
from the platform itself and helps you understand how applications for the 
platform are likely to be different from those you've designed and built before. 
Chapter 3, "Developing for the QUALCOMM BREW Platform," provides an 
overview of the various tools you use when constructing your application. 
Although it doesn't replace the excellent QUALCOMM BREW Software Developer's 
Kit (SDK) User's Guide that accompanies the QUALCOMM BREW SDK, it presents 
enough information that, after reading it, you'll be ready to follow along with the 
sample code throughout the book. 
Chapter 4, "Handling Events," describes the fundamental event -driven model 
that powers the QUALCOMM BREW platform and presents the underpinnings of a 
state machine framework that you can use to build your own applications. As you 
learn how to construct and use the state machine, you'll also see your first useful 
sample application. This application, SlideShow, lets you present prototype user 
interfaces for your application to stakeholders during your application design. 
Chapter 5, "Interacting with the User," presents an overview of the various 
user interface controls you can use when developing for the QUALCOMM BREW 
platform. As you read this chapter, you'll learn how each of these controls fits into 
the event model of your application and see how to add support for controls to the 
state machine framework introduced in the previous chapter to make managing 
user interface controls easy. 
Chapter 6, "Streaming Data," shows you how the QUALCOMM BREW 
platform uses streams to carry data from memory, the embedded file system, and 

remote servers and conserve memory while enabling the presentation of rich mul-
timedia such as pictures and sounds. 
Chapter 7, "Storing Data," shows you the other means for data storage on the 
platform: databases. The QUALCOMM BREW platform provides a robust interface 
for storing records of associated fields in flash memory, letting you save data sets 
on the embedded file system within your application. 
Chapter 8, "Drawing Graphics," presents the various graphics interfaces 
and presents the enhancements that have been added as the platform has 
matured. You'll learn how to use the display interface for simple graphics, the 
more advanced graphics interface for complex graphics, and the sprite engine for 
sprite-based animations and games. 'IWo sample applications demonstrate these 
interfaces, giving you ample code with which to experiment as you learn about 
the interfaces at your disposal. 
Chapter 9, "Playing with Sounds," lets you add sound support to the applica-
tions presented in the previous chapter, showing you the three different interfaces 
you can use to add sound to your application. Because the QUALCOMM BREW 
platform is designed to provide rich support for multimedia, this chapter also pre-
sents the latest interfaces that will support not just audio playback but other kinds 
ofreal-time media, such as video and audio capture. 
Chapter 10, "Networking Your Data," introduces the various interfaces 
available to you to utilize the wireless network in your application. The platform 
includes support for the Transmission Control Protocol/Internet Protocol 
(TCP/IP) that powers the Internet, as well as an interface that implements the 
Hypertext Transfer Protocol (HTTP), so your applications can move data between 
the handset and remote servers anywhere on the Web. 
Chapter 11, "Controlling the Handset," introduces a bevy of interfaces that lets 
you integrate various handset functions such as position determination, tele-
phony, ringer tones, and the built-in address book. These interfaces distinguish 
the platform from virtually every other mobile platform on the market, giving you 
unprecedented control of the wireless handset. 
Chapter 12, "Certifying Your Application," goes over the last crucial part of 
developing your application: third-party certification and distribution to wireless 
carriers. This chapter looks at what you can do ahead of time to increase the 
chances that your application will pass third-party certification on your first 
attempt and examines how you distribute your application once it receives 
certification. 
If you're already familiar with the QUALCOMM BREW platform, feel free to 
skip around. You may want to start by skimming bits in Chapters 4 and 5, where I 
present the application framework on which all of the sample applications in this 
book are built. In fact, the same framework is available in the source code that 
accompanies this book (available from the Downloads section of the Apress Web 
site at http://WvlW.apress.com/) , and you're welcome to use this framework in 
Introduction 
xvii 

Introduction 
xviii 
developing your own applications. Throughout this book, I've taken pains to point 
out when QUALCOMM BREW interfaces are different between versions of the 
platform so you'll be up to speed with the latest developments on the platform. 
Finally, if you want to see the QUALCOMM BREW platform in action within a 
shipping application, you may want to start with the source code available from 
the book's Web site and have a look at the source code to RocketMileage, an auto-
motive expense tracking application that's commercially available. 
A Word on Presentation 
As with other technical books, it helps to distinguish between what's meant for 
people to read and what's meant for computers to read. 
Any text in this book that looks like this is either a fragment of code or a 
variable name. Whole listings of code are set in the same style, with line numbers: 
1: typedef struct _Node 
2: { 
3: 
III Next node 
4: 
struct _Node *m_pNextj 
5: 
III Pointer to data for this node 
6: 
void *m_pDataj 
7: 
III Pointer to any additional data for this node. 
8: 
void *m_pMetaDataj 
9: }j 
Most of the sample code uses comments that conform to the doc++ syntax, 
available from http://docpp.sourceforge â¢ net/. Because doc++ provides a great 
way to mark up your source code and to automatically generate documentation 
about its interfaces and use, I highly recommend you investigate it. Moreover, 
because a great deal of the code I present is meant for you to use immediately in 
your applications, you can download the doc++ application from the aforemen-
tioned site and immediately build an online reference to the source code you find 
in this book. 
The saying goes that a picture is worth a thousand words. I've tried to use illus-
trations in this book for two purposes: to show you the screen of the various 
sample applications I present throughout the book and to describe relationships 
between the interfaces provided by the QUALCOMM BREW platform. To do the 
latter, I use the Unified Modeling Language (UML). UML provides a powerful way 
to represent different aspects of systems in a compact notation clearly and 
intuitively. 

Getting the Latest Resources 
Throughout the book, you'll be using developer tools and resources for the 
QUALCOMM BREW platform. After reading this introduction, your first stop 
should be the QUALCOMM BREWWeb site at http://WrItI.qualcOfllll.com/brew/ to 
download the SDK, and your second stop should be the Apress Web site at 
http://WrItI.apress.com/to download the sample applications that accompany 
this book. 
Looking Ahead 
QUALCOMM BREW mixes the best of tried-and-true development technologies 
with a revolutionary method of real-time application deployment to wireless 
handsets. In January 2003, QUALCOMM announced that the combined royalties 
paid out to all developers had exceeded a million dollars per month, and adoption 
of the platform continues. It's time to sit down, dig in, and begin planning how 
you can bring your application to the QUALCOMM BREW platform and share in 
its success! 
Introduction 
xix 

CHAPTER 1 
Introducing the 
OUALCOMM BREW Platform 
.. 
THE QUALCOMM BINARY Runtime Environment for Wireless (BREW) platform is 
an exciting step forward in mobile application development. Within the 
QUALCOMM BREW platform there's a powerful set of Application Programming 
Interfaces (APIs) that you use with C or c++ to build your application for wireless 
handsets. Once you complete your application, you can submit it to QUALCOMM 
for external validation and from there to wireless carriers around the world for 
your customers to purchase and enjoy. 
This chapter gives you a quick overview of the QUALCOMM BREW platform, 
including what it can and can't do and why carriers, handset manufacturers, and 
developers have been keen to adopt the platform. After examining the platform 
from a marketing perspective, the chapter sketches the architecture of the 
QUALCOMM BREW application, as well as gives you a thumbnail view of how to 
organize a QUALCOMM BREW application. Finally, the chapter closes with your 
first sample application written for QUALCOMM BREW-the now-famous 
HelloWorld program. 
Seeing the QUALCOMM BREW Platform for the First Time 
If you've never used a QUALCOMM BREW-enabled handset, the first thing you 
should do is go get one and play with it. Books such as this one can't fully capture 
the experience of using a QUALCOMM BREW-enabled handset, but it'll try. 
Most QUALCOMM BREW-enabled handsets look like regular cell phones and 
have the following features in common: 
â¢ A multiline color, grayscale, or monochrome display used by the handset for 
both telephony operations and QUALCOMM BREW applications 
â¢ A directional keypad or arrow keys to navigate a selection cursor up, down, 
left, and right 
â¢ A selection key 
1 

Chapter 1 
2 
â¢ Alphanumeric entry support through either multitap (where you press a 
number key one or more times to navigate through successive letters) or 
other mechanisms such as Tegic's 19 predictive keyboard 
â¢ A means to launch QUALCOMM BREW applications, either via a configu-
ration menu or a dedicated key on the handset 
In addition, most newer QUALCOMM BREW-enabled handsets support the 
third-generation wireless networks (often called express networks) and on-handset 
global positioning for emergency response and location applications. 
What differentiates these handsets from most other programmable 
handsets-including those running the Palm Powered and Microsoft Pocket PC for 
Smartphone platforms-is that they are priced to be competitive with today's 
wireless handsets rather than with handheld computers. This helps ensure the 
rapid adoption of QUALCOMM BREW-enabled handsets by consumers-even 
consumers who may not immediately want to run an application on their handset. 
You can launch a QUALCOMM BREW application (called an applet) using a 
phone control to bring up the application menu, which looks something like 
Figure 1-1. 
Hello 
NOTE Both the mechanism for launching the QUALCOMM BREW 
application menu and the appearance o/the BREW application menu 
can differ from handset to handset. Many QUALCOMM BREW-enabled 
handsets offer a button labeled with a carrier-dependent logo, such as 
the Verizon Wireless Get It Now logo, and others use a menu option or 
sequence of keys. Similarly, the appearance of the QUALCOMM BREW 
application menu may differ slightly from what you see in Figure 1-1. 
Figure 1-1. The QUALCOMM BREW application menu in action 

Introducing the QUALCOMM BREW Platform 
You can obtain new QUALCOMM BREW-enabled applications by using the 
Mobile Shop application, which wirelessly obtains a list of the latest applications 
and lets you purchase them for immediate use on the phone. When you launch an 
application such as RocketMileage, the application consumes the entire screen (as 
shown in Figure 1-2), and you can freely interact with the application. If you 
receive a telephone call or Short Message Service (SMS) message while you're 
using the application, the handset pauses your application and shows a dialog box 
that lets you choose to accept the call or message or continue using the 
application. 
MPG: 21.2 
Gas 
#'; Service 
Parkino 
Mileage 
Report 
Figure 1-2. The RocketMileage application 
Choosing the QUAlCOMM BREW Platform 
Making the decision to develop applications for the QUALCOMM BREW platform 
hinges on three factors: the wireless carriers your application targets, the market 
your application targets, and the flexibility QUALCOMM BREW provides you with 
as a developer. Equally important, you should understand why you might notwant 
to use QUALCOMM BREW to develop your application. The following sections 
take a closer look at each of these issues. 
Why Carriers Choose QUALCOMM BREW 
Wrreless carriers face two challenges directly affecting their profits: decreasing 
Average Revenue Per User (ARPU) and increasing subscriber demand. Compe-
tition between wireless carriers (and legislation in some countries) continues 
driving down what carriers can charge their customers, even as carriers must con-
tinue to invest to upgrade their infrastructures to support increasing demand. 
Paradoxically, however, the increased revenue from new customers doesn't fully 
offset the costs carriers incur when upgrading their networks to handle the addi-
tional customer demand. 
3 

Chapter 1 
4 
Consequently, carriers are in the awkward position of needing to drive addi-
tional demand for existing services in the hopes of raising ARPU and increasing 
profits. By opening the wireless network to third-party applications, carriers want 
software developers to provide value-added applications that increase subscriber 
network use and raise ARPU. 
Initial attempts to spur demand by offering third-party applications have met 
with limited success for several reasons. First, few handsets are available for any 
one carrier that can run third-party applications. These handsets, often called 
smart phones or wireless terminals, are a hybrid handheld computer (often 
running Palm OS, Wmdows Pocket PC, or Symbian OS) and wireless handset that 
typically costs several times more than a phone. Second, these smart phones are 
difficult to use, often with limitations on battery life and with user interfaces more 
similar to computers than phones. Third, installing third-party applications on 
these devices is an arcane process generally requiring a computer and separate 
cable (even the first generation ofJava-enabled handsets suffer this drawback) so 
that out of the small fraction of subscribers that use one of these handsets, even 
fewer actually use them more than they use a traditional wireless handset 
QUALCOMM BREW has features that meet each of these drawbacks. First, 
QUALCOMM BREW is lightweight; it's essentially a thin veneer over a telephone's 
native operating system, and it often provides interfaces to hardware features of 
today's handsets (such as media decoding) that are implemented in silicon on the 
device. Consequently, QUALCOMM BREW is available on even the least expensive 
wireless handsets, making it easy for carriers to offer QUALCOMM BREW to 
subscribers with little or no added cost. Second, both QUALCOMM BREW itself 
and the handsets on which it's available are primarily wireless handsets. These 
devices bear little resemblance to traditional computing devices, making them 
comfortable to nearly all users. Finally, QUALCOMM BREW provides an end-to-
end software distribution platform for carriers and consumers. As you'll see in the 
next section, you have access to third-party applications when using a 
QUALCOMM BREW-enabled handset. When you purchase an application, the 
application is wirelessly transferred to your phone, and the cost of the application 
is added to your phone bill. The QUALCOMM BREW platform handles the nec-
essary billing, maintains a secure transaction between handset and server, and 
even provides developers with royalty checks from carriers on a regular basis from 
application sales. 
Why Developers Choose QUALCOMM BREW 
So why should you choose QUALCOMM BREW? If you're looking to develop and 
deploy applications for wireless handsets, QUALCOMM BREW provides several 
advantages. 

Introducing the QUAlCOMM BREW Platform 
First, QUALCOMM BREW is likely the most widely distributed platform for 
handset software development in the world. Within the first year of QUALCOMM 
BREW's introduction to the market, QUALCOMM BREW was in the hands of more 
than a million users. Moreover, it's seeing rapid and widespread adoption in the 
United States and abroad, often replacing older smart phones in the process. This 
is largely because when carriers offer QUALCOMM BREW handsets, they generally 
do so across all price points, making QUALCOMM BREW available on all handsets. 
Consequently, the applications you write are likely to be available to all sub-
scribers for a wireless carrier as soon as a carrier adopts QUALCOMM BREw. 
Second, QUALCOMM BREW uses concepts and programming languages 
familiar to the experienced software developer. You write your applications in C or 
C++ using the BREW APls, test them in a simulator on your desktop computer, and 
download them directly to the handset for testing. Although this is similar to 
development for other platforms including Sun's Java 2 Micro Edition (J2ME) for 
handsets and the Palm Powered platform for handsets, there are fewer hurdles 
because the APls and tool chain remain largely unchanged for QUALCOMM 
BREw. 
Third, QUALCOMM BREW is truly a write-once, run-anywhere platform 
because the APls have been established by QUALCOMM and are available on all 
platforms. In other words, it's not a community process with different manufac-
turers providing various extensions, as is common with J2ME, the Palm Powered 
platform, and Microsoft Pocket PC Smartphone edition. Most of the QUALCOMM 
BREW APls are available on all handsets, and few handset vendors extend the 
QUALCOMM BREW APls in unconventional ways. 
Why Developers Choose Other Platforms 
Before closing this section, you should understand why you might not want to 
choose QUALCOMM BREW for your application. Obviously, if your customers use 
a cellular network that doesn't support QUALCOMM BREW; it makes little sense to 
write your applications using QUALCOMM BREw. If you're porting business logic 
from another application-say, one in Java or one running the Palm Powered 
platform for a handheld computer-it may make sense for you to use a super 
phone running the same platform, rather than trying to port your entire appli-
cation to QUALCOMM BREw. This is especially true if you're writing a vertical 
application (an application targeted to a particular market), where you can control 
your customers' hardware configuration and require a specific wireless carrier and 
wireless handset. 
5 

Chapter 1 
6 
NOTE At the time of this book's publication, vendors including Insignia 
and IBM have demonstrated J2MB Mobile Information Device Profile 
(MIDP) runtimes for the QUALCOMM BREW platform. By the time you 
read this, it's quite likely that the J2MB MIDP will be available for 
QUALCOMM BREW on at least some handsets and you'll be able to run 
your J2MB MIDP applications on QUALCOMM BREW~nabled handsets 
with no difficulty. If this comes to pass, you'll have yet another alterna-
tive for deploying applications on QUALCOMM BREW: either native 
applications in C or C++ using the QUALCOMM BREW APIs or tradi-
tional J2MB MIDP midlets running atop a third-party Java virtual 
machine that uses QUALCOMM BREW 
Understanding the QUALCOMM BREW Platform 
When you first open the QUALCOMM BREW Software Development Kit (SDK), 
you may be daunted by all of the new terms, APls, and conventions. Although it's 
easy to get confused-especially if you're the type who dives into something 
without looking at the documentation-it's not as difficult as it looks to grasp the 
fundamentals. 
Confusion usually centers around three aspects of QUALCOMM 
BREW: understanding the relationship between modules. applications. and 
classes; understanding Module Information File (MIF) and resource files; 
and understanding the application delivery process. Learning about each of 
these topics now makes it far easier for you to understand other aspects of the 
QUALCOMM BREW platform later. 
Understanding the Relationship Between Modules, 
Applications, and Classes 
A module is a chunk of executable code in QUALCOMM BREw, much like a shared 
library on other platforms. Modules contain definitions of classes, or the imple-
mentations of interfaces you use to build applications. Many of these classes are 
loaded from the handset's Read-Only Memory (ROM) on demand when your 
application needs to use them; however, you can define your own classes to use in 
your application. When you do so, you can also choose to share these classes with 
other developers; in this case, the module is called an extension because the 
handset obtains it online when the classes are required. 
As on most other object-oriented platforms, your applet (QUALCOMM 
BREW's name for applications) itself is a class-specifically, a subclass of the 

Introducing the QUALCOMM BREW Platform 
IApplet class. It must implement the interface defined by the IApplet class to 
process events the system sends in response to system and user interface events. 
Note, too, that because an application is simply a class, a module can contain 
more than one applet. 
Every class-be it a system class, one of your classes, or an applet-must have 
a unique class identifier (or class ID). A class 10 is a 32-bit integer and is allocated 
by QUALCOMM as a service to registered developers at the QUALCOMM BREW 
extranet (available from http://W.tIW.qualcOlMl.com/brew/). When obtaining an 
interface to a class, you must use its class 10 to request the interface from the 
system shell, the only interface loaded when your applet first runs. (An exception 
to this is the IShell, IModule, and IDisplay interfaces; your application will receive 
instances of these interfaces when it executes.) 
NOTE 
When you create your unique class ID using the extranet, the 
extranet will offer to let you download a BREW ID (BID) file, which con-
tains a C-style definition of your class ID. You'll need to use this BID file 
when creating your application, so be sure to set it aside in your project 
directory. 
You build modules in two ways when developing your applet. During most of 
your development, you use Microsoft Visual Studio to build Dynamically Linked 
Libraries (Dlls) you invoke through the QUALCOMM BREW handset simulator. 
Periodically you build your modules using the ARM compiler and QUALCOMM 
tool chain, resulting in module files (which end in .mod and are sometimes called 
MOD files) that you transfer to your handset for on-device testing. 
Understanding MIF and Resource Files 
In addition to your applet's module file, your applet needs an MIF to describe the 
applet to the handset's runtime. As the handset starts up, it reads each applet's MIF 
to determine the applet's name, icons, and class 10. The MIF also contains addi-
tional information, such as the author of the application and a set of flags 
delineating various kinds of behaviors the application performs (such as file 
system access or network transactions). You build MIFs using the BREW MIF 
Editor, a component of the QUALCOMM BREW SDK. 
In many of your applets, you want to include strings, icons, and dialog boxes. 
You can include these items in your application using the BREW Resource Editor, 
which lets you add items to your application. Once you use the BREW Resource 
7 

Chapter 1 
8 
Editor to add items to your application, it will create a C header file and a resource 
file (called a bar file, short for BREW Application Resource file) for your application. 
Chapter 3, "Developing for the QUALCOMM BREW Platform," discusses both 
of these tools in greater detail. 
Understanding the Application Delivery Process 
Deploying your QUALCOMM BREW application is quite different from deploying 
traditional shrink-wrapped applications for existing desktop and handheld 
platforms. Because your application will run on wireless handsets that are 
expected to never fail, your application must meet a high standard of qUality. 
Moreover, the deployment process must be different to accommodate the 
over-the-air application download features of QUALCOMM BREw. 
To meet these goals, you must submit your completed application 
to QUALCOMM for validation. To do this, you must first become a registered 
QUALCOMM BREW developer (discussed fully in the "Becoming an 
Authenticated QUALCOMM BREW Developer" section). Next, you need to 
use the QUALCOMM BREW tools to cryptographically sign a snapshot of the 
module, resource file, and MIE You electronically submit these, along with your 
user manual and test plan, to QUALCOMM for verification. 
In turn, QUALCOMM validates your application and provides you with the 
validation results. If your application passes the testing, QUALCOMM assigns your 
application a unique part number and certifies it as a TRUE BREW application. 
You may then offer your application-by referring to its part number, not by sub-
mitting new binaries!-to wireless carriers such as Verizon Wireless to offer to its 
customers. 
As customers purchase your application, your carrier's BREW Mobile Shop 
tracks customer purchases, charging customers' regular wireless service bills 
accordingly. Quarterly you receive payments aggregated by QUALCOMM for your 
application sales, and you can check your sales by part number using the 
QUALCOMM extranet at any time. 
Creating Your First Application 
By now, you're probably wondering exactly what a QUALCOMM BREW appli-
cation looks like from the inside out or at least how you can get started writing 
applications for QUALCOMM BREw. So let's stop the chatter about what 
QUALCOMM BREW is about and see a QUALCOMM BREW application in action! 

Introducing the QUALCOMM BREW Platform 
Becoming an Authenticated QUALCOMM BREW Developer 
Although it's not imperative that you do so immediately, it's helpful to become an 
authenticated QUALCOMM BREW developer as soon as you start developing for 
QUALCOMM BREw. By doing so, you receive a number of advantages, including 
the ability to run applications on test handsets and obtain unique class IDs for 
your applications. 
To become an authenticated developer, visit http://WVM.qualcomm.com/brew/ 
and follow the links through the developer support section to the Become an 
Authenticated Developer page. You'll need to apply for a VeriSign certificate, com-
plete the BREW Independent Solutions Vendor (lSV) development form, and 
register with National Software Testing Labs (NSTL), which is the validation firm 
QUALCOMM uses to test your applications prior to giving them TRUE BREW 
certification. 
Installing the QUALCOMM BREW SDK 
Although you don't need to be authenticated to begin QUALCOMM BREW 
development, you do need the QUALCOMM BREW SDK. It's available from the 
QUALCOMM BREWWeb site at http://WVM.qualcomm. com/brew/ . You need to install 
MicrosoftVisual Studio first and then download and install the QUALCOMM 
BREW SDK. 
Installing the SDK is easy; it's packaged as an installer for Microsoft Windows. 
It includes the headers and libraries you'll need as well as the documentation, 
sample applications, and the BREW Emulator for Microsoft Windows, which you 
need to test your application on your desktop computer. 
NOTE 
Throughout this book, I refer to the BREW 2.0 SDK, including the 
BREW 2.0 SDK tool chain, even though many of the examples operate 
correctly on QUALCOMM BREW 1.0and 1.1. Where a specijic version of 
QUALCOMM BREW is required, I note it in the text that accompanies the 
example. 
If you've become an authenticated QUALCOMM BREW developer, 
you should also go to the QUALCOMM BREW extranet (available from 
http://Wi/W.qualcollll1.com/brew/) and download the tools available to authenticated 
developers. These tools include the applications you need to install, test, and 
execute your application on a wireless handset. 
9 

Chapter 1 
10 
Writing Your First Application 
With the tools installed, it's time to write your first application. Let's start with the 
simple HelloWorld application that launches and draws the words Hello World on 
the display. 
CAUTION Although you can build applications with Microsoft Vzsual 
Studio .NET or Microsoft Visual Studio 6.0, the following instructions are 
for Microsoft Developer Studio 6.0. Be sure to check the documentation 
included with Microsoft Visual Studio .NET for further details. 
To create the Hello World program, follow these steps: 
1. Go to the QUALCOMM BREW developer extranet and create a class ID 
named HELWWORLD for your application. If you haven't created a 
developer account yet, you can borrow the class ID from the QUALCOMM 
HelloWorld example by copying the file helloworld.bid to your project 
directory and naming it hello. bid. 
2. Use Microsoft Paint or another paint application to create an icon for your 
application. Icons should be no more than 26-by-26 pixels and should be 
saved as uncompressed bitmaps (MicrosoftWmdows BMP). Be sure that 
the icons you create are black and white for black-and-white phones and 
8-bit color for color phones. Of course, you can also borrow one of the 
sample icons from the QUALCOMM BREW SDK during this step. In either 
case, save the icon in your project directory. 
3. Launch Microsoft Visual Studio. 
4. Launch the BREWWlZard by selecting File> New> Projects> BREW 
Application WlZard. 
5. Choose a destination for your project and name it hello. 
6. ClickOK. 
7. Because your application only draws to the screen, leave all of the options 
under What Support Would You Like to Include? unchecked and click 
Next. 

Introducing the QUALCOMM BREW Platform 
8. Launch the MIF Editor by clicking the MIF Editor option to create an MIF 
for your application. 
9. Within the MIF Editor, select the BID file you created in the first step by 
clicking Browse for BID File. 
10. By Name, enter Hello as the application name. 
11. By Applet lYPe, select Tools. 
12. Select the icon you created in the second step by clicking Browse. 
13. Save the MIF using File> Save As and naming it hello. mif. (If you're only 
going to run this in the emulator, you don't need to worry about selecting 
an MIF type option.) 
14. Exit the MIF Editor using File> Exit. 
15. Return to Microsoft Visual Studio and click Finish. Then click OK. 
16. Under the File View, open the Hello.c file and replace its contents with the 
contents of listing 1-1. 
NOTE 
The source code for this applet (and all of the sample 
applications from this book) is available at the Apress Web site 
(http://www.apress.com!) in the Downloads section, so you can 
simply use Microsoft Visual Studio to load the Hello.dsw project. 
Listing 1-1. The HelloWorldApplet 
1: 1** 
2: * @name He110.c 
3: * 
4: * @author Ray Rischpater 
5: * Copyright (c) 2001 - 2002 Ray Rischpater. 
6: * Portions copyright (c) 2001 - 2002 QUALCOMM, Inc. 
7: * @doc 
8: * A sample application that draws Hello World 
9: 
*1 
10: #include "AEEModGen.h" II Module interface definitions 
11: #include "AEEAppGen.h" II Applet interface definitions 
12 : #include "AEEDisp.h" 
II Display interface definitions 
11 

Chapterl 
12 
13: #include "hello. bid" 
/I Applet class ID 
14: 
15: 
16: 1* 
17: * Private function prototypes 
18: 
*1 
19: static boolean HelloWorld_HandleEvent( IApplet * pi, 
20: 
21: 
22: 
23: 
24: 1** 
AEEEvent eCode, 
uint16 wParam, 
uint32 dwParam )j 
25: * Create an instance of this class. This constructor is 
26: * invoked by the BREW shell when the applet is launched. 
27: * 
28: * @param AEECLSIO cIslO: class 10 of the class being requested 
29: * @param IShell *pIShell: a pointer to the BREW shell 
30: * @param IModule *po: a pointer to the current module 
31: * @param void **ppObj: a pointer to the created applet 
32: * @return AEE_SUCCESS on success, with the applet in *pobj. 
33: 
*1 
34: int AEEClsCreatelnstance( AEECLSIO cIslO, 
35: 
IShell * pIShell, 
36: 
37: 
38: { 
IModu1e * po, 
void ** ppObj 
39: 
boolean resultj 
40: 
*ppObj = NULLj 
41: 
42: 
II If it's this class being requested .â¢â¢ 
43: 
if( cIslO == AEECLSIO_HELLOWORLO) 
44: 
{ 
45: 
II Use the BREW helper function to 
46: 
II create an instance of this class 
47: 
result= AEEApplet_New( sizeof(AEEApplet), 
48: 
cIsID, 
49: 
pIShell, 
~: 
~, 
51: 
(IApplet**)ppObj, 
52: 
(AEEHANOLER)HelloWorld_HandleEvent, 
53: 
NULL) j 
54: 
} 
55: 
return result? AEE_SUCCESS : EFAILEOj 
56: } 
57: 

Introducing the QUALCOMM BREW Platform 
58: 1** 
59: * Handles incoming events from the shell. 
60: * 
61: * @param IApplet *pi: pointer to this applet. 
62: * @param AEEEvent eCode: event to handle 
63: * @param int wParam: word argument associated with event 
64: * @param uint32 dwParam: double word arg associated with event 
65: * @return TRUE if the event was handled, FALSE otherwise. 
66: 
*1 
67: static boolean HelloWorld_HandleEvent( IApplet *pi, 
68: 
AEEEvent eCode, 
69: 
uint16 wParam, 
70: 
uint32 dwParam ) 
71: { 
72: 
AECHAR szBuf[] = {'H','e','l','l','o',' " 
73: 
'W','o','r','l','d','\o'}; 
74: 
AEEAppiet * pMe = (AEEApplet*)pi; 
75: 
boolean handled = FALSE; 
76: 
77: 
/1 Decide what to do with the incoming event. 
78: 
switch (eCode) 
79: 
{ 
80: 
II The application is launching. 
81: 
case EVT_APP_START: 
82: 
II Clear the display. 
83: 
IDISPLAY_ClearScreen( pMe->m-pIDisplay ); 
84: 
// Display string on the screen 
85: 
IDISPLAY_DrawText( pMe->m_pIDisplay, // What 
86: 
AEE_FONT_BOLD, 
// What font 
87: 
szBuf, 
// How many chars 
88: 
-1, 0, 0, 0, 
// Where & clip 
89: 
IDF_ALIGN_CENTER 
IDF_ALIGN_MIDDLE); 
90: 
// Redraw the display to show the drawn text 
91: 
IDISPLAY_Update (pMe->m_pIDisplay); 
92: 
handled = TRUE; 
93: 
94: 
1/ Application is closing 
95: 
case EVT_APP_STOP: 
96: 
handled = TRUE; 
97: 
98: 
default: 
99: 
break; 
100: 
} 
101: 
return handled; 
102: } 
13 

Chapter 1 
14 
As you can see from Listing I-I, the code is pretty straightforward. Hello.c con-
sists of two functions: the applet constructor AEEClsCreatelnstance and the event 
handler HelloWor Id _HandleEvent. 
Invoked by the QUALCOMM BREW shell, AEEClsCreatelnstance is the entry 
point of your application. It uses the helper function AEEApplet_New (found in 
AEEAppGen.c) to create an instance of your applet. This function creates an 
instance of the !Applet class that references your application, registering your 
event handler so that the QUALCOMM BREW shell can send your application 
system events as they occur. This function also stashes aside several important 
object instances in your application instance, such as a reference to the 
QUALCOMM BREW shell and a reference to the display. 
NOTE 
The AEEAppGen. c file contains a set of utility functions and the 
necessary wrapper to enclose your application inside an instance 
of the IApplet class, which is the root class for all applications. Similarly, 
theAEEModGen.c file contains a set of utility functions and the necessary 
wrapper to enclose a module inside an instance of the IModule class. 
Under normal circumstances, you won't need to change either of these 
files; however, as you learn more about QUALCOMM BREw, it's instruc-
tive to take a look at them. 
The application's event handler, HelloWorld_HandleEvent, needs to handle only 
two events: EVT_APP _START, which the shell sends when the application first 
launches, and EVT_APP _STOP, which the shell sends when the application ends. The 
event handler accepts the shell's event and arguments of the event, as well as a ref-
erence to your applet instance. In turn, the event handler handles events 
appropriate to the application and returns TRUE if the application has handled the 
event or FALSE otherwise, giving the system an opportunity to manage events that 
your application ignores. 
Although the event handler passes a pointer to your application instance, it's 
of type IApplet, not the more specific AEEApplet that describes your applet. In fact, 
as you'll see in later chapters, you often add fields to your applet structure to carry 
application globals (because QUALCOMM BREW doesn't support global vari-
ables), so it's more convenient to cast the IApplet reference as a pointer to your 
application, as on line 74. 
The EVT _ APP _START event gives your application an opportunity to perform any 
launch-time initialization, such as creating instances of other classes, displaying 
the initial copyright screen, and so on. This sample application simply draws the 
welcome message on lines 83-92. First, it clears the display using the 

Introducing the QUALCOMM BREW Platform 
IDISPLAY _ ClearScreen method of IDisplay, the class that encapsulates display-
related functions. It extracts a reference to the handset's display from the 
application instance, where the BREW function AEEApplet_New previously saved it. 
Next, it uses the IDisplay method IDISPLAY _DrawText to draw the message on the 
screen. This function lets you specify not just what text it should draw, but where it 
should be drawn and the bounds of the clipping rectangle that surrounds the text. 
It also uses two flags, IDF _ALIGN_CENTER and IDF _ALIGN_MIDDLE, to tell the display to 
ignore the coordinates specified and instead draw the text displayed on the center 
of the display. After drawing the text, it calls IDISPLAY_Update to flush the display 
changes to the display and mark that the application has handled the 
EVT_APP _START event by setting the function's return value to TRUE. 
Handling application termination-which the shell indicates by sending the 
EVT _ APP _STOP event- is much easier. Because you don't have any variables or ini-
tialized objects, you simply mark that you've handled the event and pass the result 
back to the system. 
That's all there is to it! Of course, this is a somewhat artificial example-not 
only did it make minimal use of QUALCOMM BREW's capabilities, but it didn't 
even breakup the event handler into separate functions by event, which you'll 
want to do in most applications. Nonetheless, this applet gives you a good idea of 
what goes into a simple BREW applet. 
Testing Your First Application 
For at least half your software development cycle, you build and test your applet 
using the QUALCOMM BREW Emulator, a Microsoft Windows-hosted application 
that lets you run your QUALCOMM BREW applets with Microsoft Visual Studio. 
When you build your applet with Microsoft Visual Studio, it creates a DLL that 
the emulator loads when you run your application. Building your application with 
Microsoft Visual Studio is easy; simply select Build ~ Set Active Configuration, 
choose either the Debug or Release version, and then build your application using 
the Build ~ Build menu item (or pressing the F7 key). 
TIP 
You can use the debug and release settings to conditionally include 
debugging code within your code by testing the _DEBUG compiler 
macro. Doing this is a great way to provide debugging scaffolding within 
the QUALCOMM BREW Emulator while still creating relatively clean 
versions of your applet for demonstration purposes. 
15 

Chapter 1 
16 
Once you build your application, you need to configure the emulator to find 
both your applet's DLL and your applet's MIE Unfortunately, this is trickier than it 
sounds because the emulator expects your file system to be organized in the same 
way that a QUALCOMM BREW-enabled handset is. This places some rather 
bizarre restrictions on your filenames and directory structure. For best results, you 
should always do the following: 
â¢ Name your applet's project directory-or the target directory where you'll 
be placing your built DLLs-the same as your DLL name. In this chapter's 
example, the hello.dll file resides in the project directory, which is named 
hello. 
â¢ Place your MIF file in the same directory as your applet DLL. 
â¢ If you're testing multiple applets, you'll need to either keep all of the project 
directories in one directory or copy each applet's DLL to the same directory. 
â¢ If you're testing multiple applets at once, place all of your MIFs in the same 
directory. 
If you follow these steps, you'll find that using the emulator is far easier. 
To run the applet in the emulator, follow these steps: 
1. Launch the application using the Build ~ Start Debug ~ Go menu item in 
Microsoft Visual Studio. 
2. When Microsoft Visual Studio asks what application to run the DLL in, 
select the QUALCOMM BREW Emulator. 
3. Within the emulator, choose the Tools ~ Settings item. 
4. On the Initial Applet Directory line, choose the directory above your 
project directory. 
5. Within the emulator, choose the Tools ~ Settings item. 
6. Check the Specify MIF Directory line. 
7. On the Initial MIF Directory line, select the directory that contains your 
application's MIF-in this example, your project directory itself. 

Introducing the QUALCOMM BREW Platform 
8. ClickOK. 
9. Use the emulator's arrow and Select keys to choose your application. 
Once you follow these steps, you'll see the screen shown in Figure 1-3. 
Hello World 
Figure 1-3. The Hello World application running in the emulator 
Running Your Application on Your Handset 
Getting your application running on a QUALCOMM BREW-enabled handset ini-
tially seems more time consuming than useful, but it's important for you to do so 
as soon as you can because nothing beats running your applet on its target 
hardware. Testing your applets on the real hardware often and thoroughly helps 
you uncover implementation problems that you don't find in the emulator and 
helps keep you from using Microsoft Windows-specific functions in your 
application. 
Unfortunately, getting your application to run on a handset isn't a trivial task 
because you need to work with the QUALCOMM staff to obtain developer access 
to your wireless handset. Before you can run any applications that aren't available 
through Mobile Shop on your wireless handset, you must do the following: 
1. Sign up as a QUALCOMM BREW-authenticated developer, as described 
in the previous "Becoming an Authenticated QUALCOMM BREW 
Developer" section. 
2. Be sure you've obtained a unique class ID for your applet, as discussed in 
the section "Writing Your First Application." 
3. Buy a QUALCOMM BREW-enabled wireless handset. Although you don't 
need to activate the handset with a wireless carrier if your application 
doesn't need to access the wireless network, you should do so anyway so 
you can explore the other applications available through Mobile Shop. 
When you buy your handset, be sure to buy a serial data cable if one isn't 
included; you'll need one to download your application to the handset. 
17 

Chapter 1 
18 
4. Follow the instructions on the QUALCOMM BREW extranet from the link 
at http://www.qualcORlll.com/brew/ and send your handset to QUALCOMM 
to enable developer testing support. QUALCOMM uses a proprietary 
in-house tool to configure your handset so that you can download your 
application to the handset via the data cable. 
5. While you're waiting for QUALCOMM to return your handset (this 
typically takes a few business days), download the QUALCOMM BREW 
application loader from the QUALCOMM BREW extranet. This appli-
cation includes support for both downloading files to your handset and 
running a console-style debugging log that you can use to monitor your 
application as it runs on the handset. 
6. Use the QUALCOMM extranet to create a signature file (also called a SIG 
file) for your handset. The SIG file is a unique, cryptographically signed 
file that contains information from QUALCOMM and your handset's 
unique Electronic Serial Number (ESN). 
Although all of this may sound like a needless headache-especially in com-
parison with competing smart phone platforms-these obstacles serve a 
necessary purpose. By restricting handsets so that only QUALCOMM-authenti-
cated developers can run applications and requiring a SIG file for each handset, 
QUALCOMM maintains the integrity of the BREW download mechanism. Fur-
thermore, it's nearly impossible for consumers to pirate applications, defeat 
network security, or tamper with the flash file systems on their handset. This 
insurance both increases the overall security of the wireless network (crucial to 
maintaining the trust of wireless carriers) and improves the consumer experience 
because consumers don't have easy access to tools that could render their handset 
inoperable if misused. Fortunately, you need to complete these steps only once for 
each handset you use when testing your application. 
While you wait for QUALCOMM to return your handset, you can obtain one of 
the available tool chains to compile applications for QUALCOMM BREW-enabled 
handsets. Currently, you have several choices, all well documented on the 
QUALCOMM BREWWeb site. These tool chains include a version of ARM's C and 
C++ compiler for the ARM chipset, which is at the core of the QUALCOMM BREW 
platform. !fyou're only dabbling with BREw, ARM offers a free, time-limited trial 
of its ARM compiler chain, or you can purchase a full tool chain from ARM. For 
more information about either, see http://www.qualcomm.com/brew/ developer / 
developing/armbrewpack.html. 

Introducing the QUALCOMM BREW Platform 
NOTE At the time of this book's publication, QUALCOMM has promised 
to document and deliver support for using the GNU C Compiler (GeC) to 
compile modules for QUALCOMM BREW-enabled handsets. As you 
explore tool chain products for QUALCOMM BREw, be sure to check with 
QUALCOMM's Web site for the latest details about using Gee. 
Once you download and install your tool chain, you use a make file such 
as the one Microsoft Visual Studio creates when you choose AddIn Toolbar .. 
GenerateARMMakeFile. The make file uses the ARM tools to compile your sources, 
link them together, and convert the resulting binary file to a QUALCOMM BREW 
module. 
TIP If GenerateARMMakeFile doesn't work for you, close your project 
and open it once. 
Once you build your application for the handset, you should have three files: 
hello.mod, which contains your applet's object code; hello.mif, your applet's MIF 
file; and your SIG file. To transfer your applet to your handset, follow these steps: 
1. Rename a copy of your SIG file to hello.sig. (You can keep the original SIG 
file to reuse with other applets.) 
2. Create an empty folder and name it after the application, Hello. 
3. Copy the SIG, MIF, and module files to the directory you created in the 
previous step. 
4. Connect your handset to your computer using its data cable. 
5. Launch the QUALCOMM BREW Application Loader application. 
6. In response to the OEM Layer DLL Lookup dialog box, select the port to 
which you connected your handset and click OK. 
7. Choose Module .. New and click Browse to select the folder you created in 
the second step. Enter the application name Hello in the lower line. 
8. Click OK to transfer your applet to your phone. 
19 

Chapter 1 
20 
That's all there is to it! After you transfer these files to your handset, you need 
only transfer the MOD file on subsequent builds (unless, of course, you change 
yourMIF). 
Once you transfer your applet's files to your handset, you may run the applet 
just as if you had downloaded it from Mobile Shop by using your phone's interface 
to bring up the QUALCOMM BREW application menu and select it using the 
direction pad. 
Summary 
In this chapter, you learned the following key points: 
â¢ From the developer perspective, the QUALCOMM BREW platform is a 
lightweight set of APIs that sits atop QUALCOMM's hardware for wireless 
handsets, letting you write applications in C or c++ that take advantage of 
the handset's features. 
â¢ Carriers are choosing the QUALCOMM BREW platform because it enables 
them to provide third-party applications easily and securely. 
â¢ Developers are choosing the QUALCOMM BREW platform because it lets 
them write applications for consumer wireless handsets. 
â¢ The QUALCOMM BREW platform includes Mobile Shop, a carrier-side 
application that lets consumers download your application and pay for it on 
their existing wireless service bill. In turn, you can monitor sales using 
QUALCOMM's extranet and receive regular payments for the copies of your 
application that consumers purchase. 
â¢ Within QUALCOMM BREW; your application is an applet that inherits an 
interface from the IApplet class. You can also write extensions-software 
libraries encapsulated as classes for applications that you and others write. 
â¢ You can begin writing your applet using a Microsoft Wmdows-hosted SDK 
consisting of Microsoft Visual Studio and the QUALCOMM SDK. 
â¢ To develop and deploy applets on wireless handsets via Mobile Shop, you 
must become a QUALCOMM BREW-authenticated developer via 
QUALCOMM's extranet at http://www.qualcomm.com/brew/ . Becoming an 
authenticated developer enables you to obtain a copy of the ARM compiler 
necessary to build your application for the handset and enable handsets to 
run your application. 

CHAPTER 2 
Designing for the 
OUALCOMM BREW Platform 
.. 
ALL GOOD PROGRAMS start with a design. Moreover, the best programs start with 
a good design. By starting with a good design for your QUALCOMM BREW 
applications, you can streamline both your software development and your 
software deployment. 
The design phase of your development cycle for QUALCOMM BREW 
applications is especially important given the high reliability that wireless 
carriers require of any QUALCOMM BREW application. As part of your application 
deployment, you must submit your application for third-party testing and include 
several pieces of your design documentation, as you'll see in this and subsequent 
chapters. By starting your development with a good design, you provide a firm 
foundation for your application. 
Starting with a Design 
Design is a crucial part of software development. Even when you don't set aside a 
specific period of time for design, you inevitably spend time during your appli-
cation development performing tasks that constitute design. Determining how an 
application's interface should look; selecting individual components, algorithms, 
and data structures; and defining external interfaces are all part of what you do as 
you design your application. 
Understanding the Importance of Design 
When this chapter refers to design, it means all of these tasks, as well as the process 
of actually capturing your design decisions as you make them. For large software 
projects, this is crucial because often an application's implementation remains 
available far longer than the individual developers who built the application. 
Thus, documenting an application's design is essential because often only the 
application's source code and design decisions are available when others must 
change the application. 
21 

Chapter2 
22 
What is not as obvious is that capturing design decisions for small 
applications-especially those for wireless systems including QUALCOMM 
BREW-is as important as for larger applications. This is because of two 
key factors. 
First, documenting your design decisions is a proven way to help improve the 
quality of your application by enhancing team communication and ensuring a 
shared vision for your application's appearance and implementation. Making the 
time to record your documentation decisions in advance helps you set them down 
while they're fresh in your mind and gives you time to update them and share 
them with others as you work. In fact, many studies have shown that even for small 
projects, making the time for an explicit design phase is not only cost effective but 
can actually reduce the cost of applications vis-a-vis developing similar applica-
tions with no clearly demarcated design phase. 
Second, your wireless application will be rigorously examined and tested by a 
variety of third parties, including QUALCOMM's external certification agency and 
each wireless carrier that resells your application. As part of this verification, 
you're expected to submit documentation detailing your application's user 
interface flow, external dependencies, and other information in the form of a test 
plan that explains to others what your application does, how it does it, and under 
what conditions it might not work correctly. All of these are questions you must 
answer as you develop your application; thus, you should capture the information 
before you set out and then revise it to match the changes you make as you go 
along. (Chapter 12, "Certifying Your Application," discusses the certification 
process in detail.) 
Capturing the Design 
To a large extent, how you capture your design decisions is less important than 
capturing them. In general, if you or your organization has a system that meets 
simple criteria, you're probably in good shape when you start writing applications 
for QUALCOMM BREW.: You can capture your decisions in formal design docu-
mentation, marketing requirements documentation, user interface specifications, 
functional specifications, test plans, and the like or in a more informal series of 
documents and living examples such as user interface prototypes in PowerPoint or 
on the handset itself using mock-up screen shots, Unified Modeling Language 
(UML) diagrams, and the like. 

Designing/or the QUALCOMM BREW Platform 
At a minimum, your design should capture the following information: 
â¢ How your application will interact with the user, including screen layouts, 
valid data inputs, and invalid data inputs 
â¢ How your application will interact with other components, including exten-
sions and back-end network resources 
â¢ How your application will store persistent data 
â¢ The fundamental components of your application, such as modules or 
classes for data storage, network InputlOutput (1/0), computation, and 
rendering 
â¢ How these fundamental components will interact with each other 
Making the decisions you must record in your design requires a combination 
of experience, experimentation, and trial and error. It's not uncommon to write 
small prototype applications when you design your application to test parts of 
your implementation. For example, you could write a prototype to mock up parts 
of your user interface to show potential customers or write a bit of code to 
determine whether specific computations are feasible on the phone. 
A key ingredient to your design is your application's user interface: what the 
user expects from your application, how your user will use your application, and 
how your application presents itself to the user. To do this, you need to see your 
application from the users' perspective, a difficult prospect at best. 
Understanding the User 
You face unique challenges when designing and developing the interface for 
mobile applications. Not only are wireless handsets grossly different from desktop 
(or even handheld!) computers, but when you use a wireless handset, you have dif-
ferent expectations as to how it should behave than when you use a desktop or 
handheld computer. 
Understanding the Mobile Paradigm 
As you develop your mobile applications, you must always keep in mind that your 
users are in motion. When you use a wireless handset, you're seldom sitting still 
with all of your attention focused on a single task. You may be walking around, 
talking with others, or riding in a vehicle. 
23 

Chapter2 
24 
Being mobile when you use a handset directly impacts both an application's 
appearance and its use. Obviously, input must be simple: Not only are phone 
keypads tedious to use for long entries, but it's difficult to hit numerous keys with 
one finger while moving. Similarly, application output must be clear and concise 
because you can't spare attention reading a complex user interface while mobile. 
Because of these specific factors, your application must be simple and easy to 
use. Moreover, your application must accommodate the device itself, using 
high-contrast colors visible in all lighting for color handsets, using sharp black-
and-white text on grayscale displays, and requiring a minimum of alphanumeric 
input. Use menus-with numeric shortcuts-whenever possible to give users an 
easy way to make choices and selections rather than having to enter text. 
Your application must meet specific interface criteria set out by QUALCOMM, 
too. Every application must begin with a descriptive splash screen that uniquely 
identifies the application. This splash screen should automatically disappear after 
a few seconds or as soon as the user presses any key. Similarly, QUALCOMM has 
specific interface requirements for specific keys; for example, the Clear key should 
always take you to the previous screen, and the Select key should always accept an 
entry, bringing you to the next screen or feature in the application. 
Capturing the User Interface 
A key part of your design is your application's user interface. An application rich in 
features with a poor user interface typically fares far worse on the market than a 
simple application with an easy-to-use interface. Designing a user interface takes 
patience, organization, and a good understanding of your customers' needs. 
A good way to start the design and capture your application's user interface is 
through use case analysis, in which you use UML to diagram what uses indi-
viduals-called actors-will have for your application. Each actor is a set of users, 
such as consumer, network administrator, or the like, with common character-
istics. Each use encapsulates a specific operation, such as "enter purchase" or 
"determine average fuel consumption." 
A benefit to creating use cases is that once you note each use case, you can 
begin identifying common parts of each use case and flesh out the components of 
the user interface that each use case shares. From there, it becomes relatively easy 
to establish the components of your application, guiding you to the application's 
overall composition. With these use cases, your design can turn to two separate 
tasks: determining the appearance of the user interface and documenting the 
application's individual components. 

Designingfor the QUALCOMM BREW Platform 
Determining the actual appearance of the user interface is a matter of 
common sense, experience, trial and error, and user testing. At the least you 
should plan to show sketches of your interface ideas to potential users and other 
shareholders; if you can, be prepared to construct mock-up demonstrations that 
either run on the handset or on the desktop. You can keep the prototypes and 
sketches throughout the process to help document your user interface as you 
develop your application. 
Understanding the RocketMileage Application 
RocketMileage, the sample application referred to throughout this book, is a car 
mileage and service tracking applet for QUALCOMM BREw. Certified by National 
Software Testing Labs (NSTL), it's available on the Verizon WIreless network for 
the Motorola T720 and other handsets. The following sections show how to use the 
techniques described in this chapter to design RocketMileage. 
Applying Use Cases to RocketMileage~s Design 
It's easy to go overboard planning the feature set for an application, especially a 
relatively small one such as a mileage calculator. As you begin planning your 
application, you may find yourself adding features that seem interesting to use 
and implement willy-nilly. Ifleft unchecked, this can spell disaster, yielding an 
application that's confusing to use and difficult to maintain. For that reason, 
I created use cases during the initial design of RocketMileage to determine what 
features of RocketMileage were truly necessary. 
As I fleshed out the application, I realized that Verizon Wireless was targeting 
specific markets for QUALCOMM BREW using its Get It Now advertising cam-
paign. Consequently, my application focuses around two actors that mesh well 
with the markets Verizon targets. By doing this, I hope to leverage Verizon 
WIreless's marketing campaign, as well as provide an application useful to the 
customers Verizon WIreless has attracted with its campaign. My first actor is 
the quintessential consumer, interested in tracking mileage and automotive 
service details. My other actor is a mobile professional who finds their phone 
indispensable and uses the application more to track automotive expenses related 
to their profession. Figure 2-1 shows a use case diagram outlining all the possible 
features that came to mind for the application during a brainstorming session. 
25 

Chapter 2 
26 
Obviously, implementing all of these use cases for an application on a cell 
phone would be absurd. Not only would the resulting application be almost 
impossible to use, but some of these features would be expensive and time con-
suming to implement. Instead, I eliminated many use cases, choosing to 
implement only those of use to both actors or those with clear market value to one 
of the actors. Figure 2-2 shows the use cases actually implemented. 
Motorist w;:::::+ _ _________ --\ 
Dealer 
Service 
Representative 
Figure 2-1. Possible use cases for RocketMileage 
Provided 
through 
online 
Web services 

Designingfor the QUALCOMM BREW Platform 
Motorist 
Steering Alignment 
Oil Change 
Tire Rotation 
Tire Replacement 
Dealer Service 
Figure 2-2. Selected use cases for RocketMileage 
Once I identified the use cases RocketMileage should implement, I easily 
identified common components. For example, almost all of the use cases require 
an actor to enter the current odometer reading; so, clearly implementing a single 
input dialog box to accept an odometer entry for all points in the user interface 
makes far more sense than writing ones for each use case. Figure 2-3 shows a more 
detailed use case analysis, detailing many of the operations in common between 
the different use cases. 
27 

Chapter 2 
28 
Motorist 
Track gas mileage 
Application shows mileage 
at all times. 
1. To update mileage, user: 
la. Choose Gas from menu. 
lb. Enter the odometer reading. 
lc. Enter the volume purchased. 
ld. Enter the cost. 
Â«usesÂ» 
Enter decimal value 
Shared by all numeric entry 
"ATM-style" numeric entry. 
1. To enter number: 
la. Enter most significant 
digit first. 
lb. Continue entering digits. 
lC. Decimal point positioned 
at the left of the last digit 
entered. 
Figure 2-3. Operations common to multiple use cases for RocketMileage 
Describing the RocketMileage Interface 
With a better understanding of how people will use RocketMileage, it's time to step 
back and describe how the application works. You can do this in two steps: 
sketching sample screen shots and preparing an application description doc-
ument, which you can include with your application submission to NSTL (see 
Chapter 12, "Certifying Your Application"). 
It's easy to mock up screen shots for your QUALCOMM BREW application. You 
can start by using the QUALCOMM BREW Emulator and sample applications. 
Simply take several screen shots of the sample applications and use the compo-
nents as starting points to build the interface of your application. For example, 
I have a Microsoft Paint file that contains snippets of menus, input lines, and 
icons, and I can quickly assemble them in bitmap files to get an idea of what my 

Designing/or the QUALCOMM BREW Platform 
application will look like. Create small bitmap images of your application 
screens-120-by-130 pixels for a color screen such as the one on the Motorola 
T720 or 88-by-99 pixels for a monochrome screen such as the screen on the 
Kyocera QCP-3035. You can also use snippets of BREW interface components and 
text (lO-pointArial closely resembles the fonts on many screen phones in both size 
and appearance). Figure 2-4 shows several representative screen shots from the 
prototyping phase of RocketMileage's development. 
GIS 
Galbns p.ichaSed 
Lol, Floor, or Sireet 
OK 
C.reel 
Gas 
Service 
ParlcinQ 
Mlleaoe 
Report 
G .. 
Oo:Iorr'Ieter Readno 
p~ 
SlaG 
Report 
OK' 
(;n:el 
Figure 2-4. Screen concepts from the early design phase of RocketMileage 
You can show these screen shots to potential customers, arranging them in the 
order they will appear to implement a specific use case. Another thing that helps is 
to put them in a Microsoft PowerPoint presentation, so you can flip through them 
as if they were an application running on your computer. 
In fact, you can do one better-Chapter 4, "Handling Events," shows an appli-
cation you can use to navigate between bitmaps on your handset. By using this 
application with your screen concepts, you can give potential users first-hand 
experience with how your application will appear. In turn, they can give you 
valuable feedback, helping you tune your interface to meet their needs before you 
start writing your application. 
To refine your application, you can also write an application description. This 
description is similar to a functional specification in that it describes the features 
your application must implement, but not how it implements them. The appli-
cation description is a required documentation component you must include 
29 

Chapter 2 
30 
when you submit your application for validation and distribution, so it helps to get 
this out of the way as soon as possible. 
At this point, your application description should contain the following 
information: 
â¢ Application purpose: In a single paragraph, this should state what your 
application does, who your anticipated users are, and how your users will 
use your application. It should also provide an end-user marketing feature 
list. 
â¢ Catalog information: This section states your application's name, your 
application's tag line, and your anticipated application pricing. 
â¢ System-level information: This section states your application's title on the 
phone and shows its icons, your company name, your application copy-
right, and the privileges your application will require. 
â¢ Application user-level architecture diagram: This section shows a state 
machine diagram of your application, documenting the flow between each 
application screen. You can begin this diagram by organizing your use case 
diagrams and fill it out using your screen prototypes. 
Decomposing RocketMileage into Components 
In examining RocketMileage's use cases, several obvious points of decomposition 
are clear: 
â¢ Odometer entry 
â¢ Dollar amount entry 
â¢ Service detail information 
You can generalize these even further, for example, noting that the odometer 
and amount entry screens are both simply numeric entry screens with different 
prompt text. 
On larger projects, identifying common components gives you a handle on 
the dependencies between components. Once you identify which components 
rely on other components, you can assign independent components to different 
developers, letting your team do some development in parallel. 

Designing/or the QUALCOMM BREW Platform 
One thing I'm still missing is some notion of the data that RocketMileage must 
store. Fortunately, a look at the various input screens suggests two separate data 
sets, one for mileage and service and one for parking. 
Most records you enter are gas mileage records or service records, and they all 
have five common components: 
â¢ Date and time of event. Although the user doesn't need to enter this infor-
mation, the application should still store it. 
â¢ The next time and odometer reading at which the event should occur. 
â¢ Odometer reading at the time of event. 
â¢ Dollar cost of event. 
â¢ Both gas mileage and service records have an additional component-a 
number. Gas mileage records must store the number of gallons consumed, 
and service records must store the odometer reading for the next service. 
Merging this infonnation, you have a record consisting of a type identifier 
(kind of service including gas mileage, oil, tune up, tire rotation, or other service), 
a date and time, an initial odometer reading, a next date and time and odometer 
reading, a cost, and a second number that's either the amount of gas purchased 
or the odometer reading for the next service. To accommodate the description 
field in services falling into the Other category, you can simply tack on a null-
terminated C string. In fact, with a bit of tweaking, the same fields can store the 
cost of parking (simply by ignoring the additional numeric field) and trip mileage 
(by ignoring the cost field). So, the actual data structure looks like listing 2-1. 
Listing 2-1. RocketMileage Data Structure 
1: typedef enum _EMi1eageEntryType 
2: { 
3: 
ME_Gas, 
4: 
ME_Oil, 
5: 
ME_Tire, 
6: 
ME_Tuneup, 
7: 
ME_otherService, 
8: 
ME_Parking, 
9 : 
ME_Mileage 
10: } EMi1eageEntryType; 
11: 
12: typedef struct _TMi1eageEntry 
31 

Chapter2 
32 
13: { 
14: 
EMileageEntryType m_typej 
15: 
uint32 m_nTimej 
16: 
uint32 m_nDueTimej 
17: 
uint32 m_nMilesj 
18: 
uint32 m_nDueMilesj 
19: 
uint32 m_nOtherj 
20: 
uint32 m_fCostj II dollar cost for event 
21: } TMileageEntryj 
As you'll see in Chapter 7, "Storing Data," you can use a series of functions and 
macros to abstract access to each of the fields in TMileageEntry, making it easy to 
change the data structure if the need arises. 
Because the remaining data are all singletons (for example, the application 
needs to store only one miles-per-gallon calculation), the remaining data can be 
stored in the application preferences. 
Summary 
With all of these details taken care of, you can begin the process of actually coding 
your application. Before you see how to do that, however, it's time to dive more 
deeply into the QUALCOMM BREW platform itself. 
In the next chapter, you get the 30,OOO-foot view of QUALCOMM BREW so that 
you can begin writing your own applications as well as understand the internals of 
RocketMileage as you look at each of the major QUALCOMM BREW interfaces in 
upcoming chapters. 

CHAPTER 3 
Developing for the 
OUALCOMM BREW Platform 
-
My PARENTS WERE fond of giving me obscure advice when I was young. Working on 
the house, my father would lavish me with instructions such as "Always use the 
right tool for the job." In the kitchen, my mother frequently reminded me that 
sharpened knives were both easier to use and safer in the kitchen than dull ones. 
Thirty years later, this advice remains as relevant in front of the keyboard as it 
is around the house. Fortunately, QUALCOMM provides a suite of tools that makes 
developing your application easier. Equally important, the QUALCOMM BREW 
environment contains the interfaces you need to quickly develop your appli-
cation. In this chapter, you'll see an overview of the interfaces available to your 
application, as well as learn more about the desktop tools you can use to develop 
your applications. 
Getting Started with Development 
Developing applications for QUALCOMM BREW requires you to have a firm grasp 
of two ftmdamental concepts: application flow in QUALCOMM BREW and the 
class interfaces that QUALCOMM BREW makes available to your application. 
Because these themes are crucial to the QUALCOMM BREW application devel-
opment, the following sections explore these themes, and later chapters return to 
them throughout this book. 
Understanding Application Flow 
As you first saw in Chapter 1, "Introducing the QUALCOMM BREW Platform," your 
QUALCOMM BREW application is event driven; that is, your application is invoked 
by and responds to events sent by the platform. These events include not just user 
interface events from controls but also events indicating that your application 
should start and stop in response to external actions such as a received Short 
Message Service (SMS) message or the user launching the application. 
33 

Chapter 3 
34 
Consequently, the center of your application is a single function called an 
event handler that receives events from the system's event pump, which monitors 
system activity and converts relevant incidents (such as key presses, application 
launches, and so forth) into events. In tum, your application examines the 
incoming event, determines if it's relevant to your application, and does some-
thing if it finds the event relevant. If your application doesn't do anything with the 
event, it should share it with any system interfaces it's using, such as controls, 
before returning it. 
Before your application can receive events from the system, it must register 
your event handler with the system. Because your application is actually an 
instance of a class and your event handler is actually a method of your appli-
cation's class, you must add a reference to your class's dispatch table that points to 
your event handler. Although this isn't difficult, it's one of several setup actions 
every application must take, so QUALCOMM has provided a helper function that 
does all of your class setup, including registering a pointer to your event handler. 
All of this magic happens when your application launches. As the shell 
attempts to launch an application, it executes each class's AEEClsCreatelnstance 
function. Your application's AEEClsCreatelnstance function should test the 
incoming class ID and, if it matches your class ID, create an instance of itself. Typ-
ically, you do this simply by calling the QUALCOMM BREW helper function called 
AEEApplet _New, which does the behind-the-scenes magic of allocating memory for 
your class, setting up its dispatch table, and returning an instance of your class. 
Listing 3-1 shows a simple AEEClsCreatelnstance function. 
Listing 3-1. The AEEClsCreatelnstance Function 
1: int AEEClsCreatelnstance( AEECLSIO cIslO, 
2: 
lShell * pIShell, 
3: 
IModule * po, 
4: 
void ** ppObj ) 
5: { 
6: 
boolean result; 
7: 
*ppObj = NULL; 
8: 
9: 
II If it's this class being requested â¢â¢â¢ 
10: 
if( cIslO == AEECLSIO_MYCLASSIO ) 
11: 
{ 
12: 
II Use the BREW helper function to 
13: 
II create an instance of this class 
14: 
result = AEEApplet_New( sizeof( AEEApplet ), 
15: 
clsID, 
16: 
pIShell, 
17: 
po, 

Delleloping/or the QUALCOMM BREW PlIltform 
18: 
19: 
20: 
21: 
22: 
23: } 
} 
(IApplet**)ppObj, 
(AEEHANDLER) HandleEvent, 
NULL ); 
return result ? AEE SUCCESS : EFAILED; 
In object -oriented terms, you can think of the aggregate of all of the 
AEEClsCreatelnstance functions as an object factory, responsible for creating 
a specific instance of a class. Your application's implementation of 
AEEClsCreatelnstance is a class method, invoked by the system when a new 
class instance is requested by another application such as the shell application 
launcher. 
NOTE 
Whether you're writing an application or an extension (an imple-
mentation of a class to share with other applications), the startup 
process is the same (although extensions don't have event handlers). As 
you gain experience with the platform, it's instructive to skim the 
AEEAppGen.c and AEEModGen.c files that contain the helper [unctions 
described in this chapter. By doing so, you significantly increase your 
understanding of the QUALCOMM BREW platform. 
Once your event handler is registered in your application's dispatch table, the 
system's event pump calls your event handler once for each event in its queue. 
Typically, your event handler must respond to at least four events: 
â¢ The EVT _APP _START event, which your application receives after registering 
its event handler to instruct it to begin executing. Your application should 
allocate memory and objects necessary for its execution and begin running 
in response to this event. 
â¢ The EVT _ APP _STOP event, which your application receives when it must quit, 
either in response to a specific keystroke such as the handset's End Call key 
or another action. Your application should free all allocated resources 
(memory and object instances) in response to this event. 
â¢ The EVT _ APP _SUSPEND event, which your application receives when it must 
suspend execution because of an incoming telephone call, SMS message, or 
other handset activity. Your application should save its current context and 
free any unnecessary resources in response to this event. 
35 

Chapter 3 
36 
â¢ The EVT~PP _RESUME event, which your application receives when it may 
resume operation after an incoming telephone call, SMS message, or other 
handset activity. Your application should resume execution from the point 
saved when the EVT _ APP _SUSPEND event was received, re-creating any freed 
resources in the process. 
There are at least 28 other events (see Table 3-1 for a list of the most common 
events), and you can define your own events as well. Each event comes with two 
arguments, a IS-bit integer and a 32-bit integer. Events use these arguments to 
communicate specific details about the event, such as the control the event relates 
to, a pointer to a string containing more information about the event, and so forth. 
The event handler accepts the event, its arguments, and a pointer to the appli-
cation receiving the event and returns TRUE if it handles the event and FALSE if it 
doesn't. 
Table 3-1. Commonly Used QUALCOMM BREW Events 
EVENT DEFINITION 
EVT APP START 
EVT APP STOP 
EVT APP SUSPEND 
EVT APP CONFIG 
EVT APP BROWSE URL 
-
-
-
EVT APP BROWSE FILE 
-
-
-
wParam 
dwParam 
const AECHAR 
*szURL 
const AECHAR 
*szName 
const char 
*szMsg 
MEANING 
Application started 
Application stopped 
Application suspended 
Alternate application 
launch: show configuration 
screen 
Alternate application 
launch: show hidden 
configuration screen 
Called after EVT APP STARTto 
show Uniform Resource 
Locator (URL) indicated at 
szURL 
Called after EVT_APP _STARTto 
browse the file indicated at 
szFile 
Application-directed SMS 
message received; contents 
at szMsg as null-terminated 
ASCII string 

Developing/or the QUALCOMM BREW Platform 
Table 3-1. Commonly Used QUALCOMM BREW Events (Continued) 
EVENT DEFINITION 
EVT KEY 
EVT KEY PRESS 
EVT KEY RELEASE 
EVT_KEY_HELD 
EVT COMMAND 
EVT_CTL_TAB 
EVT ALARM 
EVT NOTIFY 
wParam 
Key code 
Key code 
Key code 
Key code 
Custom 
dir 
uCode 
dwParam 
Custom 
IControl *pCtl 
AEENotify 
*pNotice 
listing 3-2 shows an application's event handler. 
Listing 3-2. A Sample Event Handler 
1: static boolean HandleEvent{ IApplet *pi, 
2: 
AEEEvent eCode, 
3: 
uint16 wParam, 
4: 
uint32 dwParam ) 
5: { 
6: 
AEEApplet * pMe = {AEEApplet*)pi; 
7: 
boolean handled = FALSE; 
8: 
9: 
II Decide what to do with the incoming event 
10: 
switch (eCode) 
11: 
{ 
12: 
II The application is launching 
13: 
case EVT_APP_START: 
14: 
II Do whatever startup is necessary 
15: 
handled = TRUE; 
16: 
break; 
MEANING 
Application key (key pressed 
and released) 
Application key down 
Application key released 
Application key held 
Application custom control 
code 
Application Tab; 
dir == 0 left tab, 
dir == 1 right tab, in control 
atpCtl 
Shell alarm corresponding to 
uCode 
Shell notification 
37 

Chapter 3 
38 
17: 
18: 
II Shell needs to interrupt application 
19: 
case EVT_APP_SUSPEND: 
20 : 
II Relinquish all resources possible, suspend any callbacks 
21 : 
handled = TRUE; 
22 : 
break; 
23 : 
24 : 
II Shell returns control to application 
25 : 
case EVT_APP_RESUME: 
26: 
II Redraw ur, resume any timers or callbacks 
27: 
handled = TRUE; 
28: 
break; 
29: 
30 : 
II Application is closing 
31: 
case EVT_APP_STOP: 
32: 
II Free any used memory, release any instances, exit 
33: 
handled = TRUE; 
34: 
break; 
35: 
36: 
default: 
37: 
break; 
38: 
} 
39: 
return handled; 
40: } 
NOTE Not all QUALCOMM BREW-enabled handsets return all events in 
all circumstances. For example, early Kyocera handsets don't return 
EVT _KEY_HE LD events when you hold down a key. 
Thus, the simplest application consists of two functions: the entry point 
AEEClsCreatelnstance and an associated event handler. Together, these functions 
comprise an application's executable, but what about its data? 
The QUALCOMM BREW platform, like many lightweight application plat-
forms, doesn't support global variables. This is both a blessing and a curse. 
Without global variables, your application is easier to debug and maintain; 
however, you're left with the uncomfortable question of where to stash 
application-specific data that you don't want to pass around on the stack between 
functions. (Respecting the stack is especially important on small platforms, too, 
where a device's stack may be only a few kilobytes.) 

Developingfor the QUALCOMM BREW Pilltform 
NOTE 
The inability to support global variables can have some peculiar 
effects on your application implementation! Because the C compiler 
stores static module-scope and function-scope variables in the same 
manner as global variables, there's no support for them either. Conse-
quently, you should be careful to avoid defining static variables in either 
modules or functions. Failure to do so won't impair your application's 
execution within the QUALCOMM BREW Emulator, but it'll cause 
bizarre problems when your application executes on a wireless handset. 
Instead, you should plan on defining an application structure, which contains 
your application's variables, such as the application state and pointers to 
QUALCOMM BREW interfaces your application uses while it's running. Your appli-
cation structure should begin with a member of the type AEEApplet, which 
contains the basic information every class descending from the IApplet interface 
must contain. After the AEEApplet member, you're free to declare any other 
member variables you want. In turn, a pointer to your application structure is 
created in AEEApplet_New, where the function initializes the AEEApplet fields 
(including the reference to your event handler). Once AEEApplet_New returns, 
memory for your application structure has been allocated, and you're free to use it 
as you want. Similarly, your event handler receives a pointer to your application 
structure (even though the prototype for the event handler treats the incoming 
application structure as an AEEApplet pointer), which you can then cast to the 
appropriate type to access your application structure. 
NOTE 
AEEApplet_New initializes the contents of the AEEApplet structure 
in your application structure by casting the freshly created application 
pointer to an AEEApplet pointer and accessing the necessary fields. Con-
sequently, you must be sure your application structure has as its first 
element an AEEApplet member (and not a pointer to an AEEApplet struc-
ture!) or your application will fail in mysterious and inexplicable ways. 
Listing 3-3 unifies the AEEClsCreatelnstance and HandleEvent functions with a 
simple application structure that contains only anAEEApplet member and a couple 
of integers. 
39 

Chapter 3 
40 
Listing 3-3. The AEEClsCreatelnstance Function 
1: typedef struct _CApp 
2: { 
3: 
AEEApplet aj 
II this applet's class info 
4: 
uint32 m_IaunchTime, m_nEventsj 
5: } CApp, *CAppPtrj 
II some application-specific data 
6 
7: int AEEClsCreatelnstance( AEECLSID clslD, 
8: 
IShe11 * plShell, 
9: 
IModule * po, 
10: 
void ** ppObj ) 
11: { 
12: 
boolean resultj 
13: 
*ppObj = NULLj 
14: 
15: 
II If it's this class being requested .â¢â¢ 
16: 
if( clslD == AEECLSID_MYCLASSID ) 
17: 
{ 
18: 
II Use the BREW helper function to 
19: 
II create an instance of this class 
20: 
result = AEEApplet_New( sizeof(CApp), 
21: 
c!SID, 
22: 
plShell, 
23: 
po, 
24: 
(IApplet**)ppObj, 
2S: 
(AEEHANDLER) HandleEvent, 
26: 
NULL )j 
27: 
} 
28: 
return result ? AEE_SUCCESS : EFAILEDj 
29: } 
30: 
31: static boolean HandleEvent( IApplet *pi, 
32: 
AEEEvent eCode, 
33: 
uint16 wParam, 
34: 
uint32 dwParam ) 
35: { 
36: 
CAppPtr 
pMe = (CAppPtr )pij 
37: 
boolean handled = FALSEj 
38: 
39: 
II Decide what to do with the incoming event 
40: 
switch (eCode) 
41: 
{ 
42: 
II The application is launching 

Developingfor the QUALCOMM BREW Platform 
43: 
case EVT_APP_START: 
44: 
pMe->m_IaunchTime = GETTIMESECONDS(); 
45: 
pMe->m_nEvents = 1; 
46: 
handled = TRUE; 
47: 
break; 
48: 
49: 
II Shell needs to interrupt application 
50: 
case EVT APP SUSPEND: 
51: 
handled = TRUE; 
52: 
break; 
53: 
54: 
II Shell returns control to application 
55: 
case EVT_APP_RESUME: 
56: 
handled = TRUE; 
57: 
break; 
58: 
59: 
II Application is closing 
60: 
case EVT_APP_STOP: 
61: 
DBGPRINTF( "Application ran for %ld seconds.", 
62: 
GETTIMESECONDS() - pMe->m_IaunchTime ); 
63: 
DBGPRINTF( "Application received %ld events.", 
64: 
pMe->m_nEvents ); 
65: 
handled = TRUE; 
66: 
break; 
67: 
68: 
default: 
69: 
break; 
70: 
} 
71: 
pMe->m_nEvents++; 
72: 
return handled; 
73: } 
The sample application simply times how long the application runs and 
counts the number of events it receives during its lifetime, storing the interme-
diate results in a simple application structure named CAppo There are two key 
changes from the previous listings in this chapter. First, instead of initializing an 
AEEApplet when calling AE EApplet _New on lines 20-26, the application now creates a 
CApp structure. Because AE E _ AppletNew takes the size of a region to allocate and pre-
sumes the first element in the region is an AEEApplet, AEEApplet_New correctly 
initializes the IApplet specific variables within the CApp it creates. In a similar vein, 
the HandleEvent function now receives a pointer to the application structure, dis-
guised as a pointer to an IApplet. To make reading the code easier, the first thing to 
41 

Chapter 3 
42 
do is cast the incoming application instance to a pointer in the application's 
structure so that you can easily access your application variables. 
The meat of this sample application is in three places: lines 44-45, line 71, and 
lines 61--64. The first segment, lines 44-45, simply initialize the application's vari-
ables, storing the current time in seconds and counting the first event. This 
operation is analogous to an instance member initializing its member variables 
and in larger applications is often written as a separate application. line 71 simply 
increments the variable responsible for counting the number of events. Finally, 
lines 61--64 use the DBGPRINTF function (which prints debug messages to either 
the Microsoft Wmdows output window or to a debugging console shown using the 
QUALCOMM BREW Logger) to display both the number of seconds the appli-
cation was running and the number of events the application received. In a larger 
application, this functionality-along with the destruction of dynamically allo-
cated resources created during the application's execution-occurs here, often as 
an invocation to a separate function. This function is in essence the application 
class destructor, which is the last function the application executes before it 
terminates. 
Understanding QUALCOMM BREW Interfaces 
Like most object-oriented platforms, the interfaces in QUALCOMM BREW 
descend from a common parent. As you see in Figure 3-1, the inheritance tree is 
quite flat, reflecting the specific nature of each BREW interface. 
All interfaces descend from IBase, the base class responsible for supplying the 
object reference counting mechanism that all objects use for managing memory. 
The IBase interface defines two methods, IBASE_AddRef and IBASE_Release. 
IBASE_AddRef merely increments an object's reference count, indicating that it's in 
use and shouldn't be freed, and IBASE_Release decrements an object's reference 
count, freeing an object and its associated resources when the reference count is 
equal to zero. 
A key interface you'll use a lot is the IShell interface, which provides a grab 
bag of miscellaneous system functions, including a factory to create instances 
of other classes. You use the ISHELL_Createlnstance method to obtain instances of 
other classes, providing it with the ID of the desired class and a pointer to a pointer 
that will contain the result. For example, deep in the bowels of AEEApplet _New, you 
can find this line: 
1: ISHELL_Createlnstance( pIShell, 
2: 
AEECLSID_DISPLAY, 
3: 
(void **) &pme->m_pIDisplay); 

Developing/or the QUALCOMM BREW Platform 
Figure 3-1. The QUALCOMM BREW class hierarchy 
If you take the time to nose around the various header files, you'll find that 
pIShell is a pointer to an IShell instance and that pme->m_pIDisplay is defined as a 
pointer to an IDisplay instance. Thus, this call to ISHELL_Createlnstance creates an 
instance of IDisplay, placing the result at &pme- >m _pIDisplay. In turn, the caller can 
use this display interface to access the screen to determine its dimensions, to draw 
bitmaps, and so forth. 
43 

Chapter 3 
44 
TIP ISHELL_Createlnstance signals success or failure in two ways. On 
success, it returns TRUE and a pointer to the desired object as the third 
argument; onfailure, it returns FALSE and places NULL in the specified 
pointer. You can test either return value to determine whether your 
request has succeeded or failed. 
Other methods of IShell include methods to load text and binary resources 
from resource files, set timers and alarms, determine device characteristics, and 
manipulate times and dates. Throughout the coming chapters, you'll see many 
applications of the IShell interfaces, and chances are that if you don't see a par-
ticular interface that does what you want, you can find a method or two in IShell 
that does what you want. 
In addition to the IShell interfaces, QUALCOMM BREW provides a number of 
helper functions. Under the hood, a few are macros, and most are methods of a 
module that provide these helper functions. Fortunately, you don't have to worry 
about the details-you have immediate access to functions such as ANSI C library 
string functions, wide string manipulation functions, memory management, and 
so forth. Most of these are named the same as their C library functions, but their 
names are in all-capital letters. See Table 3-2 for a list of the most commonly used 
ones. 
NOTE 
When writing your application, be sure to use the QUALCOMM 
BREW helper functions and not the C standard library variants, unless 
you're certain that the code you're writing will only execute in the emula-
tor. The tools you use for building applications for the handset don't have 
provisions for the standard C library, so you can't call them from your 
application on the handset. 

Developing/or the QUALCOMM BREW Platform 
Table 3-2. QUALCOMM BREW Helper Functions 
HELPER FUNCTION 
C STANDARD LIBRARY EQUIVALENT 
ATOI 
atoi 
DBGPRINTF 
printf 
FREE 
free 
INET ATON 
inet at on 
INET NTOA 
inet ntoa 
MALLOC 
malloe 
MEMCMP 
mememp 
MEMCPY 
memepy 
MEMMOVE 
memmove 
MEMSET 
memset 
REALLOC 
realloe 
SPRINTF 
sprintf 
STRCAT 
streat 
STRCHR 
strehr 
STRCMP 
stremp 
STRCPY 
strepy 
STRDUP 
strdup 
STRLEN 
strlen 
STRNCPY 
strnepy 
STRSTR 
strstr 
There is also a slew of BREW-specific helper functions, such as ones that 
let you initialize and cancel callbacks, convert color values, and manipulate 
BREW-specific data structures. As with the various IShell interfaces and the 
classes themselves, you'll encounter them throughout this book (after all, that's 
what this book is about!). 
45 

Chapter 3 
46 
NOTE If you're anxious to get a head start and look at the utility func-
tions (perhaps you're looking at porting an existing application or are 
just plain curious), refer to the relevant sections of the QUALCOMM 
BREW API Reference, part of the QUALCOMM BREW Software Develop-
ment Kit (SDK). 
Pundits will note-quite rightly-that QUALCOMM BREW lacks several 
aspects of true object -oriented environments such as Smalltalk or even mixed 
environments such as C++ or Java. For example, all of the fundamental types and 
most of the BREW data types are data types, not objects. Take character strings, for 
instance: QUALCOMM BREW lets you manipulate character strings using the tra-
ditional C char data type, as well as the QUALCOMM BREW-specific AECHAR type to 
support multiple-byte character strings. Moreover, the functions you use to 
manipulate these strings are just that: helper functions, not methods you can 
apply to a particular object. In fact, the platform includes data types for many 
kinds of data, including points, rectangles, function callbacks, and the results of 
many functions. Most of these data types are transparent; that is, you can directly 
access members without using functions or macros. A few, however, include 
helper functions, and you should be in the habit of using these functions in the 
event that the data type's representation changes in a future version of 
QUALCOMM BREW 
Another key difference between the QUALCOMM BREW platform and other 
object-oriented environments, such as Java 2 Enterprise Edition (J2EE) or 
Microsoft Foundation Classes (MFC) is that you can't readily create derived classes 
from the QUALCOMM BREW interfaces. These interfaces are best seen as final in 
the Java sense: An interface's member variables and implementation are private to 
QUALCOMM BREW; but not for external modification. In most cases, this doesn't 
cause trouble as long as you approach your application's design and implemen-
tation with that in mind. 
Using the QUALCOMM BREW Developer Tools 
As you develop your application, you rely on QUALCOMM's developer tools to 
package your application for testing and distributing on the handset. 

Developingfor the QUALCOMM BREW Platform 
Using the QUALCOMM BREW MIF Editor 
Every application-in fact, every module-requires a Module Information File 
(MIF) that describes the module's name, icon, class ID, corporate author, exported 
classes (if any), and dependencies on other classes. 
Most of the time, you'll only need to use the first two tabs of the editor to 
identify your application. In the Applets tab, shown in Figure 3-2, you describe 
your application, setting your applications class ID, name, application type, 
and icon. 
Applets I General I Extensions I Dependencies I 
Apple! Informabon 
ClasslD 
l""OxO-l009-F-F-O--~-
"'''' 
Browse for BID File ... 
Name IHelio 
Apple! Type 
II'""T-o-ol-s ----~--, 
IconÂ· I<use image wrttlln MIF> 
Browse 
Extract 
New Apple 
Delete Apple! 
Advanced 
String Format 
IUmcode 
iJ 
Figure 3-2. The QUALCOMM BREW MIF Editor, the Applets tab 
You can either manually enter your application's class ID or select the Brew ID 
(BID) file you downloaded from the QUALCOMM developer extranet. Because a 
module can contain more than one applet, the classID entry is a pull-down menu; 
you can add additional applet class IDs by clicking the New Applet button. Below 
the ID, you enter the application name, which the handset displays in the appli-
cation launcher along with the icon that you choose using the Icon entry line and 
the Browse button. The Applet Type menu lets you specify what kind of application 
your applet is; although it's not currently used, carriers or the handset can cate-
gorize applications based on the type you specify here. 
47 

Chapter 3 
48 
Under the General tab, shown in Figure 3-3, you enter your company's name 
and the copyright string, which the handset shows when you enter the handset's 
application management screen, such as the Get it Now application on 
QUALCOMM BREW-enabled handsets on the Verizon Wireless network. You must 
also specify what (if any) privileges your application requires, such as privileges to 
access raw TCP/IP sockets or the local flash file system. 
Re 
Help 
Applets General I Extensions I Dependencies I 
Company Name 
IAPress. LP 
COPYright Stnng 
ICOPynght 2002Â·200~ 
Pnvllege Level 
r File r Net .... ork r Poslbon Locabon r TAPI r Web Access 
r Wnte Access To Shared Directory r Wn e Access To Ringer Directory 
r Access To Address Book r Access 
0 Sector Informa on 
Advanced 
Figure 3-3. The QUALCOMM BREW MIF Editor, the General tab 
The privileges you can give your application are as follows: 
â¢ File: Permits your application to read from and write to the local file system 
in its local directory using the I FileMgr and IFile interfaces. 
â¢ Network: Permits your application to use rawTCP lIP sockets via the INetMgr 
and ISocket interfaces. 
â¢ Position Location: Permits your application to determine the handset's 
position (if known) using the ISHELL_GetPosition method. 
â¢ TAPI: Permits your application to access the Telephony Application 
Programming Interface via the ITAPI interface. 

Developing/or the QUALCOMM BREW Platform 
â¢ Web Access: Permits your application to access the Web via Hypertext 
'Iransfer Protocol (HTTP) using the IWeb interface. 
â¢ Write Access to Shared Directory: Permits your application to use the 
IFileMgr and IFile interfaces to write to the handset's shared directory. 
â¢ Write Access to Ringer Directory: Permits your application to use the 
I FileMgr and IFile interfaces to write to the handset's ringer directory. 
â¢ Access to Address Book: Permits your application to use the IAddrBook 
interface to manipulate the handset's built-in address book. 
â¢ Access to Sector Information: Permits your application to determine the 
cellular sector information via the IPositionDet interface. 
Note that you should be sure to maintain the principle of least privilege when 
selecting privileges in your application's MIE This principle states that your appli-
cation should assert only those privileges it needs to operate correctly. By 
following the principle of least privilege, you ensure that in case of an application 
error your application doesn't violate the system's integrity by performing poten-
tially dangerous actions. 
The third and fourth tabs describe how your module interacts with other 
modules. In the Extensions tab, shown in Figure 3-4, you list the class IDs of any 
interfaces your module exports; other applications can use these interfaces by 
making a call to IShell_ Createlnstance and passing the desired class ID. (If your 
module is an application, you should not export its class ID, however.) You can also 
list MIME types so that other applications can use the ISHELL methods to invoke 
media viewers based on the MIME types you support. In the Dependencies tab, 
shown in Figure 3-5, you list the class IDs of external modules-not those internal 
to BREW; but extensions you license from other developers-so that the handset 
can ensure that all of the components your application requires are available 
when it executes. 
An MIF aggregates all ofits contents. For example, when you add an icon (or 
an image or thumbnail image, through the dialog box you access by clicking the 
Advanced button on the first tab), the images are added to the MIE Thus, if you 
want to use the information in another file, you need to use the corresponding 
Extract button to recover the information in a separate file. 
As you'll see in subsequent sections, what you name your MIF is very 
important. Your MIF must be named the same as your module-the Dynamic 
linked Library (DLL) and Module (MOD) files-so that the system can correctly 
associate the module information with the module. 
49 

Chapter 3 
fie 
Help 
Applets I General Extensions I Dependencies I 
Exported Classes 
Exported MI E Types 
New 
I 
MIME Type 
Handler ClasslD 
Browse J 
Delet.: 
< 
) 
Figure 3-4. The QUALCOMM BREW MIF Editor, the Extensions tab 
fie 
H~ 
Applets I General I Extensions Dependencies I 
External Classes Used By This Module 
Oxi 
Add 
Delete 
Figure 3-5. The QUALCOMM BREW MIF Editor, the Dependencies tab 
50 

Developingfor the QUALCOMM BREW Platform 
Using the QUALCOMM BREW Resource Editor 
Although applications don't need resources, all but the simplest of applications 
(such as the one you created in Chapter 1, "Introducing the QUALCOMM BREW 
Platform") use them to store text, images, and occasionally even user interface 
dialog boxes. Figure 3-6 shows the QUALCOMM BREW Resource Editor. 
Ready 
Figure 3-6. The QUALCOMM BREW Resource Editor 
Most often you simply will be adding or editing an existing resource. To edit a 
resource, you can double-click it in the right pane; to add a new resource, either 
choose the appropriate action from the Resource menu or click the appropriate 
button along the top of both panes. You'll see a panel like that shown in Figure 3-7 
(the appearance is slightly different depending on whether you're editing text, an 
image, or a dialog box resource). You'll enter both the resource and a name for the 
resource; the name you enter identifies the resource in the corresponding header 
file the editor creates when you build the resource file. 
Once you enter (or edit) the application's resources, you need to build the 
resource file and the associated header file. The resource editor really doesn't edit 
these files in place; rather, it edits a file that describes the contents of the resource 
file. The resource editor maintains the list of contents in the file you edit, the BREW 
Resource Information file (BRI file), and produces the BREW Archive file (BAR file) 
and the resource header that contains the IDs and names of each of the resources. 
In turn, you include the resulting header file in your application and Microsoft 
Visual Studio project, and then you include the BAR file with the module file when 
you run the application on the handset or in the emulator. 
51 

Chapter 3 
52 
FIe 
Resource 
Buld 
VieW 
Help 
D~
1iiiI 
oI..~;) Q 
r----------------------------------------------I 
- In Resources 
1D 
arne 
Type 
value 
""" .. 
Image 
~ Dialog 
Ready 
Figure 3-7. Editing a resource 
UnICode 
USIIlg SideSho\v 
Unlike MIFs, you can create more than one resource (BAR) file and name 
these files anything you like. In most cases, it makes the most sense to create a 
single file that contains all of your resources; however, you may find other 
reasons-as in the next chapter-to break your resources into multiple files. 
Using the QUALCOMM BREW Emulator 
The QUALCOMM BREW Emulator is your workhorse when you're debugging. It 
emulates the handset on your workstation, letting you debug your application as a 
Windows DLL using the MicrosoftVisual Studio environment. Figure 3-8 shows 
the QUALCOMM BREW Emulator. 
As you see in Figure 3-8, the emulator gives you a graphic presentation of the 
handset it's emulating. You can use your mouse to interact with the handset's 
control by moving the cursor over a button and clicking, or you can interact with 
the emulator's control by moving the cursor up to the menu bar and choosing a 
menu item. 
You can control the basic appearance and operation of the emulator via the 
Tools menu. lYPically, you'll use the Settings dialog box-shown in Figure 3-9 and 
available by selecting Tools ~ Settings-to choose which phone the emulator 
should emulate and indicate the specific directory for your application and MIE 

Developing/or the QUALCOMM BREW Platform 
Figure 3-8. The QUALCOMM BREW Resource Editor 
53 

Chapter 3 
54 
;~-.-------------~-
-
- -
-
~ 
Initial Device 
Imtlol Applet Directory 
IC\RM\BREWBOOk 
~ Specify MIF Directory 
Initial MIF Directory 
rC\RM\BREWBOOk\MIFS 
conc~ 
Figure 3-9. The emulator's Settings dialog box 
The emulator represents different handsets using skins, which are similar to 
but not the same as the notion of skins for popular media player applications. 
QUALCOMM provides skins for commercially available handsets, and you can 
create your own for specific purposes using the QUALCOMM BREW Device Con-
figuration Editor (see the next section). You can load a different skin using the 
ellipsis (. .. ) button next to the Initial Device field in the Settings dialog box. Skins 
from QUALCOMM come in two flavors: those that emulate the phone's user 
interface and those that emulate both the phone's user interface and performance, 
using software delays to simulate the slower processing on the handset. 
You also use the Settings dialog box to specify the location of your application 
and your application's MIR Setting these directories is tricky-not because of the 
user interface but because the emulator accurately emulates how the phone's flash 
file system works. When selecting the directory for your application, you must 
choose the directory above the directory that contains your application's module 
(as a DLL, of course). Moreover, the directory containing your module mustbe 
named the same as the module itself. Your MIF can be anywhere you like, but typ-
ically you'll keep it close to your project directory. 
For example, when developing the examples for this book, I created a BREW 
Book root directory for all of the examples. Inside this directory, I created a 
directory for each example application, such as Hello, RocketMileage, and so 
forth. Inside each of these directories was the module for each application: The 
Hello directory contains the source code and Hello.DLL, the RocketMileage 
directory contains RocketMileage.DLL, and so forth. The BREW Book directory 
also has another directory, MIFs, that contains each of the MIFs for the applica-
tions in the book: Hello.MIF, RocketMileage.MIF, and all of the other MIFs. This 
parallels the directory structure on the handset, where each application has its 

Developingfor the QUALCOMM BREW Platform 
own directory named after that applicatio'n's module, and the MIFs reside in the 
root directory of the handset. 
Using the emulator, you can also adjust the emulator's network performance 
speed, which is handy if you want to see how your application is likely to perform 
on a real handset. You can also simulate telephone events, such as an incoming 
telephone call or BREW-directed SMS message, to test how your application 
handles suspend and resume events or SMS reception. You can also simulate posi-
tioning input by either connecting an external Global Positioning System (GPS) 
receiver or by taking the captured output of a GPS receiver in a file and directing 
the emulator to load the file. In tum, the emulator uses this positioning infor-
mation to provide data for the IPositionDet interface and ISHELL_GetPosition 
method. 
Despite all of these features, it's important to recognize that the emulator is 
just that: an emulator. It's not the handset, and it's impossible to do all of your 
testing in the emulator. Be prepared to do frequent builds for the handset using 
the ARM QUALCOMM BREW Builder, and exercise your application on handsets 
as often as you can. Not only will you get a better feel for how your application 
appears and behaves, but you can find and correct defects on the handset more 
quickly this away. 
TIP 
Don't leave handset testing to the end of your project, especially 
when you're first learning how to develop for the QUALCOMM BREW 
platform. You can easily make mistakes- such as using Windows Appli-
cation Programming Interfaces (APIs)-in the emulator that you won't 
catch until you run your application on the handset. If you wait until the 
last minute to test your application on the handset, it may be too late to 
fix these problems without delaying your application's launch. 
Using the QUALCOMM BREW Device Configuration Editor 
At times, you may need to alter how a particular emulator skin behaves. Perhaps 
you've received confidential information about a soon-to-be-announced handset 
and need to test your application for that device before you can get one to use. Or, 
perhaps you want to force a particular kind of failure, such as a low memory con-
dition, while using the Microsoft Developer Studio debugger. To do this, you can 
use the QUALCOMM Device Configuration Editor, shown in Figure 3-10. 
55 

Chapter 3 
56 
fie 
Ed 
D~ 
Ready 
OB\llC8 Attnbutes 
Model fo-cx1 
Selected OB\llC8 ObJedAttnbutes 
Type IKey 
COordinateS (WIndows Pi>cels) 
Left r 
Top 
f537 
Width 
~ 
Heigh ~ 
Avedable V,l1UeJ Codes 
AVK...BREAK 
AVK...CAPLK 
AVK_RJNCTION 
AVK_RJNCTIONI 
AVK RJNCTION2 
AVI(RJNCTION3 
AVK INFO 
AVK:LALT 
,.. 
I .... 
Pn_m_aIY""'CO,---de ___ 
_ 
--l IAVK...OOWN 
<- Dell 
<-Mrillmmri .. I 
Figure 3-10. The QUALCOMM BREW Device Configuration Editor 
Because it's unlikely that you'll need to make major changes to a device con-
figuration without needing to consult QUALCOMM's documentation, the 
following sections only hit the highlights of using the editor. 
The editor lets you specify a bitmap that models the appearance of the 
handset you want to emulate. On the bitmap, you must mark both where the emu-
lator should draw the screen and the location of each button, along with specifying 
the key code for each key. For each region of the bitmap you mark, you specify 
whether it is a display or a key and then describe the other characteristics of the 
object, such as its aspect ratio or key code. 
Using the QUALCOMM BREW Application Loader 
You use the QUALCOMM BREW Application Loader to install your application on 
a developer handset for testing (see Figure 3-11). The QUALCOMM BREW Appli-
cation Loader provides an Explorer-style window that lets you browse the 
QUALCOMM BREW section of the handset's file system, letting you copy files to 
and from the handset. (You can't copy some files, such as the files for applications 
you purchase using your carrier's download application, from the handset.) 

Developing/or the QUALCOMM BREW Platform 
Seled OEM Lays, DLL 
Seled DOMce Id 
laCOMOEMdll 
Supported DeVIces 
Kycce'!I Phone 
LG Phone 
S!lmsung Phone 
Sh!IfP Phone 
Supported API. 
OK 
DIsconnected 
QlpyFileF,omDeVlce 
QlpyFile ToDOMce 
Cre!lleOOMceD" 
DeVlceO"ExIsts 
DOMceFileExlsts 
nOI l'I1"ol"'lffl .... Co 
Cronce I 
Figure 3-11. The QUALCOMM BREW Application Loader 
NOTE 
You can only load your application on handsets that have been 
enabled for developer use with the QUALCOMM BREW Application 
Loader. Because different handsets have different ways of enabling devel-
oper access, you should check the QUALCOMM BREW extranet before 
trying to use the QUALCOMM BREW Application Loader with your 
handset and application, as discussed in the previous chapter. 
To use the QUALCOMM BREW Application Loader, you first need to obtain a 
signature file-commonly called a SIG file because its filename ends in .sig-from 
http://www.qualconvn.com/. When you install your application, you'll copy your 
application's module, signature, resource, and module information files to the 
handset. To do this, follow these steps: 
1. Connect your handset to an unused port on your workstation using the 
handset vendor's data cable. (You may need to install the driver that 
comes with the cable to use it.) 
2. Launch the QUALCOMM BREW Application Loader. 
57 

Chapter 3 
58 
3. Select the serial port you connected your handset to in step 1. 
4. Click OK in the dialog box you see in Figure 3-11. 
Your workstation and handset will communicate via a proprietary protocol, 
and you'll see the browser window in Figure 3-12. You can use the explorer to open 
directories, create new directories, and copy files to or from the handset. To install 
your application, simply copy its MIF to the root of the file system (either by using 
the right-click menu commands or by dragging and dropping the file to the 
window's right pane). Then create a folder with the same name as the module, and 
copy the module and any other required files into that folder. (You may need to 
tum the handset off and then on again so that the handset can detect the newly 
installed application.) Note that the folders with numeric names are applications 
you've purchased using your wireless service's BREW Delivery Service such as Get 
it Now on Verizon Wireless, and you shouldn't change those directories or their 
contents or you'll render the applications within them useless. 
02 14(03. 15: 1 â¢ 
Ready 
Figure 3-12. Exploring with the application loader 

Developing/or the QUALCOMM BREW Platform 
TIP Many developers have reported problems with the QUALCOMM 
BREW Application Loader when disconnecting the handset while the 
application is loading. It's best to disconnect from your handset using 
the application loader's leftmost button in the button bar or by 
quitting the application loader before you unplug or reset the handset. 
Using the QUALCOMM BREW Logger 
The QUALCOMM BREW Logger lets you monitor the output of debug print state-
ments on the handset. This is just like how the Microsoft Visual Studio output 
window (or the output window of the emulator) lets you view information printed 
by the DBGPRINTF function in your application. Although not as useful as a source-
level or assembly-level debugger, it's the only on-device debugging tool you have. 
Figure 3-13 shows the QUALCOMM BREW Logger and the options you can set. 
Severity Levels 
r. All Messages (Level 0) 
r Medium and Above (Levell) 
Log Masks .. 
r High and Above (Level 2) 
File OpUons ... 
r Error and Above (Level 3) 
OK 
r BREW App I Fatal Only (Level 4) 
Cancel 
r No Messages 
~ ShowGUI 
Log to File 
p
BrewLoggec 2724 log ---
Brow.:::.J 
Figure 3-13. The QUALCOMM BREW Logger 
59 

Chapter 3 
60 
You connect your handset to the logger the same way you do to the appli-
cation loader-in fact, once you connect the handset to one application, it's 
connected to the other, so you can easily build your application, install it, test it, 
review the log, make a change, and rebuild and install it again for another run. 
Once you've connected your handset, you connect to the handset's logger by 
clicking the cell phone icon, start logging by clicking the start! stop logging button, 
and then view the log by clicking the icon with an eye. (You can also perform these 
operations by using the applications menus, but the button bar is easier.) 
When you view the log, you'll see the window shown in Figure 3-14. This 
window includes the first characters of each log message, along with the time 
at which each log message occurred. You can use this information with 
debugging scaffolding in your application to trace application flow, perform 
rudimentary profiling of application performance, and examine variables during 
a program run. 
..... AEE_DISPATOiÂ·IÂ·Â· 
~TlJ B "-
OEMDISP _UPOATEÂ·19069780.29.0 
â¢â¢ .. Â·AEE D SPAT'l-IÂ·O .. 
Figure 3-14. Sample output from the logger 
UlhSI9 c 
Â·1 go ott' 
OEMDlspc 
Ulh.,gc 
une Number Level 
2119 
C 
2119 
o 
2119 
o 
2119 
o o 
136 
o o 
136 
o o o o o o o 
136 
533 
136 
o 
533 
136 
4 
3 
4 
3 
4 
4 
3 
4. 
4 
4. 
3 
3 

Developing/or the QUALCOMM BREW Platform 
Summary 
TIP As with the application loader, developers have reported problems 
with the QUALCOMM BREW Logger when disconnecting the handset 
while the application is loading. It's best to disconnect from your 
handset using the application loader's leftmost button in the button bar 
or by quitting the application loader before you unplug or reset the 
handset. Moreover, the QUALCOMM BREW Logger only shows the first 
67 bytes of a string logged with DBGPRINTF. 
In this chapter, you learned the following: 
â¢ QUALCOMM BREW provides an object-oriented toolkit for developing 
applications on the handset. 
â¢ Your application must register itself with the system to receive events gen-
erated by the system's event pump. These applications signal your 
application's launch, user and system interaction with your application, and 
your applications termination. 
â¢ The IShell interface offers a bevy of functions for managing system inter-
faces (including timers), managing resources, and obtaining device 
characteristics. 
â¢ You use the ISHELL Create Instance method to create instances of other 
system interfaces within your application. 
â¢ The QUALCOMM BREW platform includes many of the standard C library 
functions, along with QUALCOMM BREW-specific data types to represent 
characters and other data. 
â¢ You use the QUALCOMM BREW MIF Editor to create the MIF that describes 
your application, specifying its class 10, icon, name, and other details such 
as the privileges it requires to execute correctly. 
â¢ You use the QUALCOMM BREW Resource Editor to collect and package 
string, image, and dialog box resources for your application . 
â¢ You use the QUALCOMM BREW Emulator to demonstrate your application 
on your workstation or to debug your application using the Microsoft Visual 
Studio debugger. 
61 

Chapter 3 
62 
â¢ You use the QUALCOMM BREW Application Loader to install your appli-
cation on a developer handset for testing using the handset, the 
QUALCOMM extranet-provided SIG file, and a data cable. 
â¢ You use the QUALCOMM BREW Logger to view the output of DBGPRINTF 
statements on your workstation from the handset via a serial cable. 

CHAPTER 4 
Handling Events 
AT THE CORE of every QUALCOMM BREW application is its event loop, which 
accepts incoming user and system events, dispatches them to the application's 
user interface controls, and does whatever the application needs to do. Conse-
quently, your understanding of QUALCOMM BREW's event model is a 
fundamental step in being able to write your application. 
In this chapter, you'll learn about QUALCOMM BREW's events and how your 
application should handle them. It discusses the structure of events, the kinds of 
events your application must be prepared to handle, and how your application 
should share events with user interface elements. It then offers an application 
framework that helps you manage events; you can use this framework to build 
your own applications. The chapter also details how you can use the framework 
construct SlideShow, an application that presents bitmaps for user interface 
prototypes. 
Understanding the Event Model 
As described in the previous chapter, the system sends your application events by 
calling your application's event handler, which receives each event, processes it, 
and returns control to the system. 
Unlike most systems, your application doesn't poll for events; instead, the 
system invokes your application in response to events. This difference is crucial 
because your application must do its background processing as it handles each 
event. Unlike larger computing platforms, such as Microsoft Wmdows CE and the 
real-time operating systems used by many embedded devices, QUALCOMM 
BREW is a single-threaded environment. Consequently, you must do your pro-
cessing as you receive events and be sure to yield as much time to the underlying 
system by keeping the work you do when handling events as brief as possible. In 
that manner, QUALCOMM BREW resembles simpler handheld operating systems, 
such as Palm OS. 
63 

Chapter 4 
64 
Processing an Event 
The shell sends your application events by invoking its event handler method, a 
method of IApplet that you override during your application's instantiation. If 
you're using the QUALCOMM -supplied AEEAppGen.c file, the AE EApplet _New 
function does this on your behalf. 
NOTE 
The AEEAppGen.c file actually registers its own method as the 
event handler for your applet and then invokes your event handling 
function as part of its execution. 
Your application's event handler is a function that must match the following 
prototype: 
1: boolean HandleEvent( lApp let * pi, 
2: 
3 : 
4: 
AEEEvent eCode, 
uint16 wParam, 
uint32 dwParam); 
The first argument, pi, is a pointer to your application's instance. In all but the 
simplest of cases, you'll need to cast this pointer to a structure that carries your 
application's data because QUALCOMM BREW applications can't have global vari-
ables. Instead, as shown in the previous chapter, it's easy to emulate this behavior 
by using members in an application structure that matches the shell's expectation 
of the contents of an lApplet structure. 
The second argument, eCode, is the event your application can process. Your 
HandleEvent function will be called once for each event it receives and has the 
choice of processing the event for its own purpose or ignoring the event. If your 
event handler processes the event, it should return TRUE; this signals to the shell 
that the event has been managed. If it returns FALSE, the shell will attempt to 
process it on your application's behalf. 
The remaining arguments, wParam and dwParam, can contain additional infor-
mation about the event. For example, when you press a key on the handset, the 
shell passes a code identifying the key in the argument wParam. Similarly, when 
your application receives a Short Message Service (SMS) message, your event 
handler will receive a pointer to the message's contents in a buffer at the address 
specified in dwParam. 
Typically, your event handler becomes a massive switch statement, testing the 
incoming event code against the kinds of events you want to handle. If you're not 
careful, this can tum into a bunch of nested switch statements or, worse yet, a 

Handling Events 
massive switch statement with scores of if statements within each case. This can 
quicldy render a well-written application unmanageable as your logic grows more 
complex. (The next section shows you one way to better organize the structure of 
an event handler.) 
Handling System Events 
At a minimum, your application must handle four system events that pertain to 
the following: 
â¢ The shell sends your application the EVT_APP _START event after registering 
your application. 
â¢ The shell sends your application the EVT _SUSPEND event when it must 
suspend your application to perform another operation, such as presenting 
an incoming SMS message or phone call. You should free as many system 
resources as you can before returning control to the system, including 
memory and object instances. 
â¢ The shell sends your application the EVT_RESUME event when your appli-
cation can continue executing after receiving an EVT _SUSPEND event. 
â¢ The shell sends your application the EVT_APP _STOP event when your appli-
cation should quit, such as when you press the End Call button or when you 
call ISHELL_CloseApplet to tell the shell to close your application. 
Your application may also need to manage other system events, such as the 
following: 
â¢ The EVT _APP _ CONFIG event, sent by the shell when you invoke an application's 
configuration options from the application launcher 
â¢ The EVT _ APP _MESSAGE event, sent by the shell when the handset receives an 
SMS message directed at your application 
â¢ The EVT _ALARM event, sent by the shell when an alarm set by your application 
fires 
â¢ The EVT _NOTIFY event, sent by other classes when you register your appli-
cation as wanting notifications for class-specific events such as network 
activity 
65 

Chapter 4 
66 
You can also define your own events by using event codes with values greater 
than EVT _USER. You can then post events to your application using the function 
ISHELL_PostEvent, like this: 
1: b = ISHELL_PostEvent( pIShell, classid, eCode, wParam, dwParam ); 
where pIShell is a valid pointer to the shell, classid is the class ID of your applica-
tion, and the arguments eCode, wParam, and dwParam represent the event to post. 
After the call executes, b will be TRUE if the event was successfully posted. 
CAUTION 
As with all other return values, don't be in the habit of assum-
ing that a system call will succeed. The handset is a constrained device, 
and there's a real chance that a system call will fail for lack of memory or 
other resources. Neglecting to test return values for success or failure can 
lead to subtle failures that are difficult to find and reproduce in your 
application. 
Handling User Interface Events 
Many of the events your application must process are user interface events that 
indicate keystrokes and menu selections. These events are at the heart of your 
application because the shell uses events to signal all user input. 
The simplest form of user input is a keystroke-when you press and release a 
single key on the handset. In response to a keystroke, the system sends your appli-
cation three events in succession. First, the system sends an EVT_KEY_PRESS event, 
indicating that you pressed a key. Next, when you release the key, the system sends 
an EVT JEY event, followed by an EVT _KEY _RE LEASE event.JYpically, your application 
needs to respond only to the EVT _KEY event, rather than looking for individual press 
and release events. The system can also send the EVT _ KEY_HE LD event to signal that 
you're pressing and holding a key; this event is handy when implementing special 
controls such as game buttons. 
With each keystroke event, the system indicates the key you pressed in the 
16-bit parameter that accompanies the event (traditionally named wParam). This 
parameter encodes the key as a key code, matching one of the manifest constants 
in AEEVCodes.h, the include file that specifies event codes for keystrokes, display, 
and indicator interaction. Table 4-1 describes common keys and their corre-
sponding key codes. 

Handling Events 
Table 4-1. Common Keys and Their Corresponding Key Codes 
KEY 
KEY CODE 
0 
AVK 0 
1 
AVK 1 
2 
AVK 2 
3 
AVK_3 
4 
AVK_4 
5 
AVK_5 
6 
AVK 6 
7 
AVK_7 
8 
AVK 8 
9 
AVK_9 
* 
AVK STAR 
# 
AVK POUND 
Clear (the Back key) 
AVK CLR 
Uparrow 
AVK UP 
Down arrow 
AVK DOWN 
Left arrow 
AVK LEFT 
Right arrow 
AVK_RIGHT 
Select 
AVK SELECT 
Send 
AVK SEND 
End Call 
AVK END 
A close look at Table 4-1 shows that something is missing when you compare 
QUALCOMM BREW to other platforms: keys representing individual letters. 
Because QUALCOMM BREW handsets only offer numeric keys, text input occurs 
through the IText control. This control handles the mapping of individual key-
strokes, letting the user select different input methods such as numeric only, 
multitap, and platform-specific entry mechanisms such as Tegic's T9 or Motorola's 
iTAP method. To do this-in fact, to work with any of the QUALCOMM BREW user 
interface controls-you need to also pass user interface events to the user 
interface controls. Other controls, notably the IMenu control, use additional events 
to indicate user interaction. These controls use the EVT _COMMAND event to signal 
67 

Chapter 4 
68 
control-specific interaction, such as the selection of a menu event. As with the 
IText control, you must share incoming events with the control for it to operate 
correctly; you do this using the control's HandleEvent method. (You'll see how to do 
this later in the section "Presenting a Prototype User Interface" when you see 
SlideShow, a user interface prototyping tool that displays bitmaps.) 
One final event you must give special attention is when the user presses the 
Clear key-sending your application the EVT _KEY event with a wParam attribute of 
AVK _ CLR. By convention, the Clear key has two purposes: to backspace in a text line, 
rubbing out a single character, and to return to the previous screen in a multi-
screen application. Although the IText control handles the backspace facility, it's 
up to your application to manage navigation between screens and return to the 
previous screen when you press the Clear key. 
Building an Application Framework 
Because so many of the event handling requirements are similar between different 
applications, it makes sense to build an application framework that assumes this 
responsibility, which you can reuse as you write new applications. The section that 
follows sketches out a lightweight application framework that handles common 
events such as EVT _SUSPEND and EVT _RESUME, and it handles navigation between 
screens. 
This framework is the basis for the applications throughout this book, starting 
in this chapter with SlideShow (a program that displays a succession of bitmap 
images) and continuing through RocketMileage. 
Representing Application Flow with Application States 
A good model for representing your application is to divide it into individual 
states, with each state capturing one screen of interaction with the user. Your 
application then becomes a succession of states-a state machine, in computer 
science parlance. 
Structuring your application as a state machine has several advantages. First, 
it's easy to build your application in pieces, adding states as you need to add incre-
mental features to your application. Moreover, most states are fairly small and 
have limited interaction with other states in the application. It's also easy to 
manage navigation within the application using a state machine. 
By keeping successive states in a stack, your application can easily handle 
both forward and backward flow through the user interface. Using a stack, the 
current application state is the topmost state in a stack of states. As you progress 
forward through your application's interface-say, by entering a display of results 
after selecting a choice from a menu-the application can push new states on the 

Handling Events 
stack. When you press Clear to return to a previous screen, the application simply 
pops the topmost state, presenting the previous state on the stack to the user. 
Figure 4-1 illustrates this concept. 
Application State St 
You press SelECT to select the (jas menu item: The applicationD 
pushes the first input state (which lets you input your 
odometer readin9) on the stack, pushin9 the main menu do 
the stack. 
You enter purchase information: The application pushes each i 
state on the stack in turn.D 
D 
\er~ 
urrentu 
n onD 
<III'I<n1I~ 
--'K 
.c.nru 
~ 
r ..... ' 
You complete the information entry: The application pops eachD ~;:!!===l 
input state off the stack in turn, returnin9 the same me 
~ 
servICe 
D 
Pn~ 
D 
Mileage 
Re$Ia1 
Figure 4-1. Representing application interface flow with a stack of states 
69 

Chapter 4 
70 
The framework's core responsibility is to maintain the stack of states, allocate 
new states when requested, and dispatch events from the event pump to the 
current state. As the framework operates, it manages suspend and resume events, 
treating them as exits and entries to the current state. A state itself is a simple 
structure representing a tuple of functions and an associated memory region 
the state can use to share data between each of the function invocations (see 
listing 4-1). 
Listing 4-1. The Application State Structure CState 
1: II State function type declarations 
2: typedef void (PFNSTATEENTRY)( void *pApp, EStateChange change ); 
3: typedef void 
(PFNSTATEEXIT)( void *pApp, EStateChange change ); 
4: typedef boolean (PFNSTATEEVENT)( void *pApp, 
5: 
AEEEvent eCode, 
6: 
uint16 wParam, uint32 dwParam); 
7: typedef struct _CState 
8: { 
9: 
struct _CState *m_pPrevState; 
10: 
PFNSTATEENTRY *m_pfEntry; 
11: 
PFNSTATEEXIT 
*m_pfExit; 
12: 
PFNSTATEEVENT *m_pfEvent; 
13: void 
*m_pData; 
14: } eState, *eStatePtrj 
The application framework maintains the stack as a singly linked list; the head 
of the list is the top state on the stack. The first member of the CSt ate structure, 
m_pPrevState (on line 9), points to the previous state in the stack to maintain this 
list (thus, the head of the list is the current state, the last state is the state pointed to 
by the first m_pPrevState, and so on). The three functions m_pfEntry, m_pfExit, and 
m _pfEvent are the state's entry function, exit function, and event handler, respec-
tively. The entry and exit functions each take a pointer to the application structure 
and the reason for the function's execution: an enumerated value indicating that 
the specific state is being pushed deeper on to the stack, that the specific state is 
being popped from the stack, or that the application has received a suspend or 
resume event. The event handler, by comparison, takes the same arguments as the 
application's event handler: a pointer to the application structure, the event code, 
and the word and long word arguments of the event. Hence, the three typedef 
statements on lines 2-4 define each of the state function interfaces. Finally, each 
state may allocate variables for its internal use, such as storing intermediate values 
between events. This information, a single pointer to a state-specific structure, is 
stored in the m _pData field of the CState structure. 

Handling Events 
Managing the Application's State Machine 
To manage the application's state machine, the framework must provide several 
interfaces: 
â¢ An event handler, called each time your application receives an event. This 
handler is responsible for both dispatching events to the current state (the 
state at the top of the stack) and handling special events, such as a suspend 
or resume event or a Clear key press. 
â¢ The stack manipulation's push and pop, which pushes a new state and pops 
the current state from the stack, respectively. These interfaces are public, 
used by the various states of the application when moving from state to 
state. 
â¢ State manipulation functions representing the system suspend and resume 
events. These are separate interfaces apart from the push and pop interfaces 
because they're called only by the framework's event handler in response to 
system events. 
â¢ Accessor and mutator interfaces for a state's private data (the m_pData) 
pointer. Although not absolutely required, isolating this field from direct 
access makes it easy to change the implementation of the framework 
without changing the code that uses it. 
â¢ An interface to obtain the application's current state, used predominately by 
the application framework itself. As with the aforementioned m_pData 
accessor and mutator interfaces, this isn't required, but it's a good idea in 
case you want to change the framework's implementation later. 
By convention-closely following QUALCOMM BREW's function naming con-
vention-each of the application framework function names begins with a 
common keyword, State. Thus, you have the interfaces shown in Listing 4-2. 
Listing 4-2. The State Management Interfaces 
1: // Application Framework interfaces 
2: #define State_GetState( p ) ( Â«CStateAppptr)(pÂ»->m_pState ) 
3: 
4: // Macros that could be functions â¢.â¢ 
s: #define State_GetStateData( s ) ( s->m_pData ) 
6: #define State_SetStateData( 5, d ) ( 5->m_pData = d ); 
7: 
8 :// There is no SetCurrentState to keep the user from 
71 

Chapter 4 
72 
9: II corrupting the stack by mistake ... 
10: #define State_GetCurrentState( app ) \ 
11: 
Â«(CStateAppptr)(appÂ»->m_pState) 
12: #define State_GetCurrentStateData( app ) \ 
13: 
Â«Â«CStateAppPtr)(appÂ»->m_pState)->m_pData); 
14: #define State_SetCurrentStateData( app, data ) \ 
15: 
Â«Â«CStateAppPtr)(appÂ»->m_pState)->m_pData = ( data) ); 
16: 
17: II Prototypes 
18: 
19: boolean State_Push( void *p, 
20: 
PFNSTATEENTRY pfEntry, 
21: 
22: 
PFNSTATEEXlT pfExit, 
PFNSTATEEVENT pfEvent ); 
23: boolean State_Pope void *p ); 
24: void State_Suspend( void *p ); 
25: void State_Resume( void *p ); 
26: boolean State_HandleEvent( void *pApp, 
27: 
28: 
29: 
AEEEvent eCode, 
uint16 wParam, 
uint32 dwParam ); 
In the interests of efficiency, the simplest interfaces are implemented as 
macros. 
You'll note that there's no initialization interface per se. In the interest of sim-
plicity, the framework initializes the application framework on the first call to 
State_Push. Moreover, the implementation of the other functions contains guards 
against uninitialized framework data. This is a good idea not only because you 
might aCcidentally make a call to one of the interfaces before the framework is ini-
tialized, but also because an error in your program might overwrite part of the 
state stack, invalidating the *m_pPrevState field and corrupting the application and 
its behavior. 
A key problem is where to store the base of the state stack. An obvious place is 
within the application structure; however, blithely placing it as a member within 
the application structure forces the implementation of the framework to know 
something about the rest of the application. Although not necessarily bad when 
constructing a single application, this is cumbersome when using the framework 
within multiple applications because each applications implementation of the 
framework needs to have knowledge of the applications state structure, and you 
need to revise the implementation to include this for each application. 
Rather, you can use some of the same skullduggery that the QUALCOMM 
BREW system uses with the lApp let and AE EApplet structures: You can require that 
the beginning of the application structure follow a prescribed format. Just as the 

Handling Events 
AE EAppGen functions require that the first element of the application structure be an 
AEEApplet structure, the state machine framework requires that the second 
element of the application structure be a pointer to a structure that represents 
the application framework, which will contain the top of the state stack. Thus, any 
application that uses the framework must define its first members of the appli-
cation structure: 
1: typedef struct _CApp 
2: { 
3: 
AEEApplet 
aj 
4: 
CStateFrameworkptr m_pFrameworkj 
5: 
II Other members here ... 
6: } CApp, *CAppPtrj 
For now, CStateFrameworkptr is simply a type definition equivalent to 
CStatePtr, pointing to the top of the state stack. (In later chapters, as you enhance 
the framework, CStateFrameworkPtr will point to an entire structure that contains 
other information about the application framework itself, including the state of 
the user interface controls.) In turn, the state machine views an application 
structure simply as a CStateApp structure: 
1: typedef struct _CStateApp 
2: { 
3: 
EEApplet 
aj II Must always be first 
4: 
CStatePtr 
m_pStatej II The current state 
5: } CStateApp, *C5tateAppPtrj 
Because currently the CStateFrameworkptr is simply a CStatePtr, you treat the 
second element as a CStatePtr in this type definition and throughout the following 
discussion. 
So, how does all of this work in practice? Let's take a close look at each of the 
functions that implement the application framework's interface. 
The state_Push and State]op interfaces are integral to the application 
framework because they provide the means by which user navigation in the 
interface controls the succession of application states. The operation of these is 
straightforward. Listing 4-3 shows State_Push. 
Listing 4-3. The State ]ush Function 
1: 1** 
2: * Pushes indicated state on stackj 
3: * Transitions to that state. 
4: * @param void *p: pointer to app 
73 

Chapter 4 
74 
5: * @param PFNSTATEENTRY pfnEntry: call on function entry 
6: * @param PFNSTATEEXIT pfnExit: call on function exit 
7: * @param PFNSTATEEVENT pfnEvent: call on each event 
8: * return TRUE if transition succeeds, FALSE if not 
9: *1 
10: boolean State_Push( void *p, 
11: 
PFNSTATEENTRY pfEntry, 
12: 
13: 
14: { 
PFN5TATEEXIT pfExit, 
PFN5TATEEVENT pfEvent ) 
15: CStateAppPtr pThis = ( CStateAppPtr )pj 
16: CStatePtr pCurState, pNewStatej 
17: 
18: 
ASSERT( pfEntry I I pfExit I I pfEvent )j 
19: 
20: 
pCurState = State_GetCurrentState( pThis )j 
21: 
pNewState = State_Create( p, pfEntry, pfExit, pfEvent )j 
22: 
23: 
ASSERT( pNewState )j 
24: if ( !pNewState ) return FALSEj 
25: 
26: 
II Call the present state's exit function 
27: if ( pCurState && pCurState->m_pfExit ) 
28: 
pCurState->m_pfExit( p, 
29: 
StateChange_push )j 
30: 
31: II Push this state on to the stack. 
32: 
pNewState->m_pPrevState = pCurStatej 
33: 
pThis->m_pState = pNewStatej 
34: 
35: II Call new state's entry function 
36: if ( pNewState->m_pfEntry ) 
37: 
pNewState->m_pfEntry( p, 
38: 
StateChange_push )j 
39: 
40: 
II No errors! 
41: 
return TRUEj 
42: } 
State_Push begins with a bit of debug housekeeping, ensuring that it's called 
with valid arguments (line 18). Assuming it is, it creates a new state using the 
function State_Create (which you can see later in this section), specifying a state's 
members as arguments (line 21). Assuming a valid state is created (lines 23-24), it 
notifies the current state that it's being exited because the application is pushing a 

Handling Events 
new state on the stack (lines 27-29). The initial comparison on line 27 ensures that 
the current state's exit function will be called only if there's both a current state-
that is, if the framework is already initialized-and if the state has an exit function. 
NOTE 
The ASSERT macro actually isn't available in QUALCOMM BREW; 
but I define it in the include file utils.h. It does the same thing as the 
standard C assert macro: It tests its argument and, if the argument is 
false, prints an e"or and terminates execution. The _DEBUG compile-time 
constant ensures that the ASSERT macro occurs only in preproduction 
code; by building production releases with no _DEBUG flag set, you can be 
sure these assertions don't appear in shipping applications. 
Next, State_Push pushes the new state on the stack by linking it to the current 
state and then setting the application's notion of the current state to the new state. 
Note here you're using the application structure, referring to it as a CStateApp 
rather than the application's native application structure, so that any application 
following this convention can use the framework without modification (lines 15 
and 31). 
Finally, the function calls the new state's entry function, giving it a chance to 
allocate its state variables, manipulate the user interface, or do whatever it needs 
to do when it's entered (lines 36-38). As with the previous state's exit function, this 
tests the current state's entry function to be sure it exists (line 36), in case a par-
ticular state doesn't need an entry function. This small performance penalty 
reduces the need for empty handler functions, which lowers the application's 
overall memory footprint. 
State_Pop operates in an analogous fashion, first calling the state's exit 
function, popping the state from the state stack and freeing its contents, and then 
calling the previous state's entry function (see Listing 4-4). 
Listing 4-4. Manipulating the State Stack 
1: 1** 
2: * Pushes i ndicated state on stack; 
3: * Transitions to that state. 
4: * @param void *p: pointer to app 
5: * @param PFNSTATEENTRY pfnEntry: calIon function entry 
6: * @param PFNSTATEEXIT pfnExit: calIon function exit 
7: * @param PFNSTATEEVENT pfnEvent : calIon each event 
8: * return TRUE if transition succeeds, FALSE if not 
9: *1 
75 

Chapter 4 
76 
10: boolean State_Pop( void *p ) 
11: { 
12: CStateAppptr pThis = ( CStateAppPtr )pj 
13: CStatePtr pCurState, pOldStatej 
14: 
15: pCurState = State_GetCurrentState( pThis )j 
16: pOldState = pCurState->m_pPrevStatej 
17: 
18: ASSERT( pCurState )j 
19: if ( !pCurState ) return FALSEj 
20: 
21: II Call the present state's exit function 
22: if ( pCurState->m_pfExit ) 
23: 
pCurState->m_pfExit( p, 
24: 
StateChange_pop )j 
25: 
26: II Pop the old state off of the stack. 
27: 
pThis->m_pState = pOldStatej 
28: pCurState->m_pPrevState = NULLj 
29: 
30: II Call new state's entry function 
31: if ( pOldState && pOldState->m_pfEntry ) 
32: 
pOldState->m_pfEntry( p, 
33: 
34: 
StateChange_pop ); 
35: II Release the popped state 
36: State_Release( p, pCurState )j 
37: 
38: II No errors! 
39: return TRUEj 
40: } 
As you can see, the logic is essentially the same but in reverse; after 
obtaining the current state and previous state (lines 15-16), the function calls 
the current state's exit function, if any (lines 22-24). Then, the function calls the 
previous state's entry function if there's a previous state that has an entry function 
Uines 31-33). Finally, the function releases the memory associated with the state 
that was popped Gine 36). 
Suspending and resuming the current state is a special case of popping and 
pushing states from the stack. In many cases, what an application must do when 
it's suspended is essentially the same as what it must do when it exits: Save its state 
and free any allocated resources. In the case of application suspension, of course, 
there's a tradeoff between what can be freed and what should persist because the 

Handling Events 
user expects the application to resume in the same state it was in after being sus-
pended, such as when a phone call occurs. Consequently, State_Suspend and 
State_Resume simply call the appropriate state's exit or entry function, respectively 
(see Listing 4-5). 
Listing 4-5. Suspending the Current State 
1: 1** 
2: * Issues suspend to current state. 
3: * @param void *p: pointer to app 
4: * @return nothing 
5: *1 
6: void State_Suspend( void *p ) 
7: { 
8: CStateAppPtr pThis = ( CStateAppptr )p; 
9: CStatePtr pCurState; 
10: 
11: pCurState = State_GetCurrentState( pThis ); 
12: 
13: if ( pCurState && pCurState->m_pfExit ) 
14: 
pCurState->m_pfExit( p, 
15: 
StateChange_suspend ); 
16: } 
17: 
18: 1** 
19: * Issues resume to current state. 
20: * @param void *p: pointer to app 
21: * @return nothing 
22: *1 
23: void State_Resume( void *p ) 
24: { 
25: CStateAppptr pThis = ( CStateAppptr )p; 
26: CStatePtr pCurState; 
27: 
28: pCurState = State_GetCurrentState( pThis ); 
29: 
30: if ( pCurState && pCurState->m_pfEntry ) 
31: 
pCurState->m_pfEntry( p, 
32: 
StateChange_resume ); 
33: } 
These functions are both pretty simple; they call the current state's appro-
priate function with the special flag indicating whether the state is being 
suspended or resumed. 
77 

Chapter 4 
78 
The event handler performs most of the work on behalf of the framework, 
handling several application-wide events, including when the user presses the 
Clear key, when the event sends a suspend or resume, and application termination 
when the state stack has been emptied. All of this is done by the function 
State _ HandleEvent, which the applications event handler must call for each event 
(see Listing 4-6). 
Listing 4-6. Handling Events Within the State Framework 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
1** 
* Handles incoming events. 
* Dispatches suspend and resume to current state. 
* Pops state on AVK_CLR 
* Pops all states on EVT_APP_5TOP 
* @param void *p: pointer to app 
* @param AEEEvent eCode: event code 
* @param uint16 wParam: event parameter 
* @param uint32 dwParan: event parameter 
* @return boolean FALSE if app framework should continue handling event 
*1 
boolean State_HandleEvent{ void *p, 
AEEEvent eCode, 
uint16 wParam, 
uint32 dwParam ) 
{ 
boolean result = FALSE; 
CStatePtr pCurState; 
CStateAppptr pThis = ( C5tateAppPtr )p; 
A55ERT{ pThis ); 
pCurState = State_GetCurrentState{ pThis ); 
if ( !pCurState ) return FALSE; 
II We always give the state first dibs. 
if ( pCurState->m_pfEvent ) 
result = pCurState->m_pfEvent{ p, eCode, wParam, dwParam ); 
II If the state didn't do anything with it, we will. 
if ( !result ) switch{ eCode ) 
{ 
II Tell the current state to suspend operations 
case EVT APP SUSPEND: 
State_Suspend{ p ); 

Handling Events 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: } 
} 
result = TRUEj 
breakj 
II Tell the current state to resume operations 
case EVT_APP_RESUME: 
State_Resume( p )j 
result = TRUEj 
breakj 
II Pop ALL states from the stack -- we're exiting 
case EVT APP STOP: 
while( State_GetCurrentState( pThis ) 
State_Pope p )j 
result = TRUEj 
breakj 
II If the user hits Clr, pop 
case EVT KEY: 
if ( wParam == AVK_CLR && 
State_GetCurrentState( pThis ) 
{ 
} 
State_Pope p )j 
II If there are no more states, we exit by saying the event 
II isn't completely handled. The shell will send us an 
II EVT_APP_STOP after this. 
result = State_GetCurrentState( pThis ) ? TRUE : FALSEj 
break; 
return resultj 
This is a long function, but its operation is quite straightforward. After first 
ensuring there's a state on the stack that might want to handle the function (if 
there isn't one, there's no work for the framework to do!), the function offers the 
event to the current state's event handler (lines 22-28). Then, if the state didn't 
handle the event, the framework examines the event Gines 31-64). By giving the 
current state first crack at the event and having the framework's event handler 
ignore events already handled by specific states, a particular state can override the 
default behavior of the application framework, such as when a state must handle 
the Clear key differently (say, during user input). 
79 

Chapter 4 
80 
Handling the EVT _ APP _SUSPEND and EVT _ APP _RESUME events is quite simple 
Gines 34-43), merely calling either State_Suspend or State_Resume, respectively. The 
other cases-application termination and the Clear key-are a little more 
complex. 
When the shell wants to terminate the application, it sends the EVT_APP _STOP 
event. The application framework must then perform an orderly shutdown of each 
state, popping it from the stack to ensure that each state has the opportunity to 
release any system resources it has consumed. The while loop on lines 47-48 of 
the EVT _ APP _STOP case Gines 46-50) accomplishes this, popping each state from the 
stack in tum until none are left. 
Handling a Clear key press is a little simpler although the logic is more 
complex because the system uses an EVT_KEY event with a value of AVK_CLR to 
indicate that you have pressed the Clear key and the application should return to 
the previous screen. Consequently, the event handler first tests the wParam of the 
event Gine 54) and then checks to ensure that there's a valid state (line 55) before 
popping the current state Gine 57). Unlike other events that use TRUE to signal that 
they've been completely handled by the system, this case returns TRUE only if the 
application should continue to run because the shell will send an EVT_STOP event 
to the application if it doesn't fully handle a Clear key press. By returning FALSE 
when the last state has been popped from the stack and the stack is now empty, the 
framework ensures that the system will request that the application terminate, 
rather than the framework forcibly needing to close the application. 
The implementation of the State_Create and State_Release functions are 
straightforward, performing the minimum initialization and destruction required 
by a specific state. If you like, you can examine them in the State.c file that accom-
panies this chapter's examples (available in the Downloads section of the Apress 
Web site at http://www.apress.com/). 
Presenting a Prototype User Interface 
Previous chapters discussed the importance of prototyping in user interface 
design. Prototyping is often overlooked, especially on nascent platforms such as 
QUALCOMM BREW because there's a paucity of rapid development tools 
available. Unlike a desktop environment where tools including PowerPoint, Visual 
Basic, and Flash can create compelling prototypes, it seems difficult at best to 
develop a prototype for a cell phone. 
It need not be that way, however. In practice, something as simple as a suc-
cession of bitmaps presented to potential users can often communicate far more 
about how an application might operate than dozens of use cases and flow dia-
grams. Consequently, a slide show renderer-a simple "bitmap flipper," if you 
will-becomes a powerful tool in any developer's arsenal. With a few hours in a 
simple program such as Microsoft Paint, you can create dozens of user scenarios 

Handling Events 
to present to your potential customers and other shareholders. When you're 
through, you can keep a stack of family photos to show your friends. 
The SlideShow application does just that, letting you assemble a sequence of 
bitmap images in a QUALCOMM BREW Application Resource (BAR) file (see 
Figure 4-2). You can place multiple BAR files in SlideShow's main directory using 
the QUALCOMM BREW Application Loader and then choose a specific file's 
bitmaps to display. 
Figure 4-2. The SlideShow application 
Once you choose a BAR file, you can flip backward and forward through each 
image using the left and right keys of the directional pad, or you can play them as 
an animated movie using the Select key and using the up and down arrows to 
control the playback speed. 
In addition to leveraging the application framework presented earlier in this 
chapter, the application demonstrates several key instances of the QUALCOMM 
BREW interfaces, including loading dynamic resources, interacting with the 
handset's flash file system, and even accepting user input through the IMenuCtl 
interface (covered in the next chapter). 
Using the Application Framework 
On the surface, using the application framework is simple: You merely need to 
create state entry, exit, and event handling functions for each of your applications 
states. Then, during application startup, simply push your first state on the 
framework's stack and then let each state's event handler manage transitions to 
subsequent states. 
In the case of SlideS how, little more needs to be done. The application consists 
of two states: one to show a list of BAR files-slide shows-so you can pick a spe-
cific show and another state that shows the bitmaps in the BAR file you select. 
To keep things simple, the SlideShow application has three separate imple-
mentation files and associated header files that define the public interfaces to 
81 

Chapter 4 
82 
each implementation file. The application framework, which you've already seen, 
is in State.c and State.h. SlideShow's application-specific startup code and appli-
cation structure are in SlideShow.c and SlideShow.h, and SlideShow's application 
states are defined in AppStates.c and AppStates.h. To keep from creating a rat's 
nest of includes, you can create a single file, inc.h, which includes both the appli-
cation includes and the QUALCOMM BREW interface declarations. Every file 
(including State. c) includes this global include file. 
Examining the SlideShow Startup Code 
Broadly speaking, you can divide SlideShow's implementation into two parts: the 
first being application startup and data management and the second being state 
machine flow. 
The SlideShow application structure contains not just the application's 
AEEApplet instance and application framework data but a bevy of other infor-
mation (see listing 4-7). 
Listing 4-7. The Application Structure 
1: typedef struct _CApp 
2: { 
3: 
AEEApplet a; 
4: 
CStatePtr m_state; 
5: 
6: 
II screen and font dimensions 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
int 
int 
int 
boolean 
boolean 
AEERect 
m cx' 
-
, 
m_cy; 
m_nFontHeight; 
m_bColor; 
m_bCopydght; 
m rC' 
- , 
14: 
II BREW controls 
15: 
IMenuCtl *m_pIMenu; 
16: 
17: 
II Application globals 
18: 
char 
m_szFile[ MAX_FILE_NAME + 1 ]; 
19: 
int 
m_frameDelay; 
20: } CApp, *CAppPtr; 

Handling Events 
SlideShow uses only some of these variables, such as the m _ rc rectangle that 
denotes the screen size; because applications later in the book will need more of 
this information, you're learning how to fetch the data here as the application 
starts up. 
SlideShow's application startup code is similar to what you've seen in previous 
chapters. The system starts the application by calling its AEEClsCreatelnstance 
function, which tests the class 10 against the class 10 used by SlideShow and 
invokes the QUALCOMM Application Execution Environment (AEE) helper 
function AEEApplet_New if the class 10 the system seeks matches the SlideShow 
application 10. (Because you've seen previous examples of this in Chapters 1 
and 3, the listing of AEEClsCreatelnstance has been omitted here.) In turn, 
AEEClsCreatelnstance calls the function SlideShow_Init, where SlideShow has its 
opportunity to initialize its application structure (see listing 4-8). 
Listing 4-8. Initalizing the SlideShow Application 
1: /** 
2: * Initializes application structure, creating 
3: * necessary UI components. 
4: * @param CAppptr pThis: pointer to application structure 
5: * @return AEE_SUCCE5S on success, or else EFAILED 
6: */ 
7: static int SlideShow_Init( CAppPtr pThis ) 
8: { 
9: 
int result = AEE_SUCCESSj 
10: 
AEEDevicelnfo dmj 
11: 
12: 
if (pThis->a.m_pIDisplay && pThis->a.m_pIShell) 
13: 
{ 
14: 
ISHELL_GetDeviceInfo( pThis->a.m_pIShell, &dm )j 
15: 
pThis->m_cx = dm.cxScreenj 
16: 
pThis->m_cy = dm.cyScreenj 
17: 
18: 
pThis->m_bColor = dm.nColorDepth > 2j 
19: 
pThis->m_rc.x = OJ 
20: 
pThis->m_rc.y = OJ 
21: 
pThis->m_rc.dx = (short)(dm.cxScreen)j 
22: 
pThis->m_rc.dy = (short)(dm.cyScreen)j 
23: 
24: 
pThis->m_nFontHeight = 
25: 
IDISPLAY_GetFontMetrics( pThis->a.m_pIDisplay, 
26: 
AEE_FONT_BOLD, NULL, NULL)j 
27: 
} 
83 

Chapter 4 
84 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: } 
else 
{ 
result = EFAILEDj 
} 
if ( result == AEE_SUCCESS ) 
result = ISHELL_Createlnstanee( pThis->a.m_pIShell, 
AEECLSID_MENUCTL, 
(void **)&pThis->m_pIMenu )j 
return resultj 
Always the optimist, I seed SlideShow_Init's return valuewithAEE_SuCCESS on 
line 9. Then, assuming that the application has both a pointer to the IDisplay and 
IShell instances (line 12), the function interrogates the display to find both its 
dimensions and color depth Uines 14-22). In the unlikely event that the appli-
cation was launched without a shell or display, it's unable to continue, and it 
indicates this by setting its return value to EFAILED. 
Given a pointer to a device infonnation structure-an 
AEEDevieelnfo_IDISPLAY-GetDevieelnfo populates its members. The AEEDevieelnfo 
structure, defined in AEEShell.h, contains lots of infonnation about the target 
handset, including its screen size, character set encoding, available random access 
memory, and availability of specific features such as position detennination and 
Music Industry Digital Interface (MIDI) support. SlideShow _ Ini t simply copies the 
most commonly used fields of this structure-the screen's bit depth and dimen-
sions-so that the application can use them later when sizing the menu control 
without needing to call AEEDevieelnfo again. For the sake of convenience, 
I store the screen size as both a rectangle using the AEEReet structure, which stores 
rectangles as (top, left, height, width) tuples, and the maximum x and y offsets. 
Although this wastes 4 bytes of space, it's convenient in many applications 
because you don't have to constantly reference the individual members of the 
AEEReet m re. 
Once the function caches the device infonnation, it needs only create an 
instance of the IMenuCtl that the menu state will use when presenting the list of 
BAR files. Although it's certainly reasonable in theory to allocate this control in the 
menu display state itself, it's a good idea in most applications to instantiate all of 
your user interface elements during application startup because your application 
won't run correctly if it can't allocate a user interface element. Consequently, by 
allocating these elements and caching them at application startup, you can be 
sure they're around when you need them. Moreover, if they're not, you can ter-
minate your application gracefully, at launch, rather than being forced to include 
code to handle abnonnal operation in the event that a control creation fails during 
a specific state. 

Handling Events 
Handling Application Events 
The event handler takes care of the remainder of the application startup, so let's 
take a look to see what's there (see Listing 4-9). 
Listing 4-9. The SlideShow Application Main Event Handler 
1: 1** 
2: * Handles all events for the application 
3: * @param IApplet *p: pointer to application structure 
4: * @param AEEEvent eCode: event code 
5: * @param uint16 wParam: event parameter 
6: * @param uint32 dwParam: event parameter 
7: * @return TRUE if application handled event 
8: 
*1 
9: static boolean SlideShow_HandleEvent( IApplet *p, 
10: 
AEEEvent eCode, 
11: 
uint16 wParam, 
12: 
uint32 dwParam ) 
13: { 
14: 
boolean result = FALSEj 
15: 
CAppPtr pThis = (CAppPtr)pj 
16: 
17: 
II App Startup --- dismiss the copyright screen on 
18: 
II any keystroke 
19: 
if ( pThis->m_bCopyright && eCode == EVT_KEY ) 
20: 
{ 
21: 
HideCopyright( pThis )j 
22: 
pThis->m_bCopyright = FALSEj 
23: 
} 
24: 
25: 
result = State_HandleEvent( (void *)p, eCode, wParam, dwParam )j 
26: 
27: 
if ( !result ) switch (eCode) 
28: 
{ 
29: 
case EVT_APP_START: 
30: 
II Show the splash screen 
31: 
ShowCopyright( pThis )j 
32: 
result = TRUEj 
33: 
breakj 
34: 
35: 
case EVT_COPYRIGHT_END: 
36: 
II Enter the menu state as the first state 
37: 
result = State_Push( p, 
85 

Chapter 4 
86 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
57: } 
break; 
default: 
break; 
} 
return result; 
AS_MenuEntry, 
AS_Menu Exit, 
AS_MenuHandleEvent ); 
After checking to see if the splash screen is still showing (lines 17-23), the 
event handler begins by offering application events-once the application is ini-
tialized-to the framework on line 25. 
Showing the Application Splash Screen 
The application-level event handler must handle events that occur before the 
application framework is initialized and after it's tom down just before the appli-
cation exits. On lines 17-23 and again on lines 29-40, SlideShow_HandleEvent does 
just this, managing keystroke and startup events and displaying the application's 
splash screen. 
When the application first launches, it shows its splash screen that describes 
the application name, purpose, and vendor. By convention, all QUALCOMM 
BREW applications must show an application-specific splash screen for 10 
seconds or until any key is pressed to dismiss the splash screen. Although 
QUALCOMM BREW provides an interface to do this-ISHELL_ShowCopyright-the 
interface doesn't give the flexibility of showing a graphical splash screen. Instead, 
you can use the ShowCopyright function to do this (line 31) when the application 
first receives the EVT _ APP _START event. Then, if the user presses any key while the 
splash screen is visible (recorded by the application member variable 
m _ bCopyright), the event handler hides the splash screen (lines 19-23) using the 
function HideCopyright. 
Regardless of how users dismiss the copyright screen-either via a key press or 
the splash screen timer-the application receives an EVT _COPYRIGHT_END event, 
indicating that it should show its first screen. (The ISHELL_ShowCopyright interface 
sends the EVT _COPYRIGHT_END event, so mimicking this behavior in this function 
makes it easier to substitute one for the other). The event handler manages this 
event on lines 35-41, where it pushes the application's first state on the stack. 

Handling Events 
Subsequent events will be managed by the current state, which receives events 
through the application framework via the call to State_HandleEvent on line 25. 
Note that the application doesn't need to explicitly handle the EVT _ APP _STOP 
event because the current state will handle its own cleanup, and the system will 
call the application destructor (registered by the original call to AE EApplet _New) 
when the application terminates. The application destructor, SlideShow_Free, 
simply frees the previously created menu control using a call to IMENUCTL _Release 
(see Listing 4-10). 
Listing 4-10. Freeing Resources Used by the SlideShow Application 
1: 1** 
2: * Frees application structure, releasing 
3: * necessary UI components. 
4: * @param IApplet *p: pointer to application structure 
5: * @return nothing 
6: 
*1 
7: static void SlideShow_Free( IApplet *p ) 
8: { 
9: 
CAppPtr pThis = (CAppPtr)pj 
10: 
11: 
if ( pThis->m-pIMenu ) IMENUCTL_Release( pThis->m_pIMenu )j 
12: } 
At the first glance, it may seem odd that the splash screen display is handled by 
the application directly, rather than being an application state. The reason for this 
is simple: When running the application, you should only see the splash screen 
once, when the application first starts. (You certainly don't want to see the 
splash screen again when the user exits the application by pressing Clear from the 
main screen!) Although it's possible to craft clever entry and exit functions for 
a splash screen state to make sure the splash screen isn't displayed as a result of a 
pop operation on the state stack, in practice things need not be so complicated. 
Displaying the splash screen requires several steps. First, it must load the 
bitmap for the splash screen. Next, it must draw the bitmap on the display. Then, it 
must set a timer, indicating when the application should dismiss the splash screen 
if no key is pressed while it's showing. Finally, it must set the application structure 
member m _ bCopyright to TRUE to indicate that the splash screen is showing. 
ShowCopyright does all of this (see Listing 4-11). 
87 

Chapter 4 
88 
Listing 4-11. ShowCopyright 
1: 1** 
2: * Shows the copyright screen. 
3: * @param IApplet *p: pointer to application structure 
4: 
*1 
5: static void ShowCopyright(CAppPtr pThis ) 
6: { 
7: 
IImage *pImage; 
8: 
9: 
II Fetch the copyright image 
10: 
pImage = ISHELL_LoadResImage( pThis->a.m-pIShell, 
11: 
APP _RES_FILE, 
12: 
IDI_COPYRIGHT ); 
13: 
if (pImage) 
14: 
{ 
15: 
IIMAGE_Draw( pImage, 0, 0 ) ; 
16: 
17: 
II Free the image 
18: 
IIMAGE_Release( pImage ); 
19: 
pImage = NULLj 
20: 
} 
21: 
22: 
II Update the display 
23: 
IDISPLAY_Update( pThis->a.m_pIDisplay )j 
24: 
25: 
II Dismiss the splash screen automatically after a while 
26: 
ISHELL_SetTimer( pThis->a.m_pIShell, 
27: 
APP_COPYRIGHT_CLOSE, 
28: 
(PFNNOTIFY)HideCopyright, 
29: 
pThis ); 
30: 
31: 
II Let everybody know we're showing this. 
32: 
pThis->m_bCopyright = TRUEj 
33: } 
ShowCopyright contains the largest number of QUALCOMM BREW interface 
invocations in a function that you've seen so far, so let's look at it line by line. To 
begin, the function uses the ISHELL_LoadImage interface on lines 10-12 to load the 
splash screen from the application's resource. ISHE LL_LoadImage is one of a family of 
functions that loads resource data. Others include ISHELL_LoadResString, which 
you use to load strings from a resource file, and ISHELL_LoadResData, which loads 
opaque binary data from the resource file. These functions take a reference to the 
application shell as well as the resource filename and the desired resource 

Handling Events 
identifier-typically a compile-time constant generated by the QUALCOMM 
BREW Resource Editor when building a resource file. The compile-time constant 
APP _RES_FILE is defined by the QUALCOMM BREW Resource Editor, along with all 
of the resource identifiers in the resource file, and placed in the file ending in 
_res. h when you build the application resource. 
Assuming the splash screen exists-which it should, unless it's not in the 
resource file or there's not enough memory to load the image-the function draws 
the image and then frees the memory used by the image on lines 13-20. Because 
ISHELl_LoadImage returns a pointer to an IImage instance containing the bitmap to 
draw, drawing the image itself is as easy as invoking the I IMAGE _Draw method on the 
image and specifying the position of the upper-left comer of the drawing rect-
angle. Similarly, to release the resources used by the image, you need only call 
IIMAGE Release. 
NOTE Releasing the image doesn't clear it from the screen, as you can see 
from this example. Once the image is drawn to the screen, the bits in the 
image are effectively copied to the screen memory, so releasing the image 
doesn't clear the drawn image. 
The function then ensures that the drawn image appears on the screen by 
calling IDISPLAY _Update on the application's screen instance (line 23). Your applica-
tions should do this anytime they've updated the screen and they want to be sure 
that the screen is redrawn, such as after a series of drawing instructions or when 
clearing the screen. Whether the display update occurs immediately when your 
application invokes IDISPLAY_Update or slightly later-say, before the system 
delivers the next event to your application-depends on the vendor's handset 
implementation, so you shouldn't make assumptions about precisely when the 
redraw occurs. 
Next, the function uses a system timer to ensure that the splash screen disap-
pears after 10 seconds using the ISHELl_SetTimer interface on lines 26-29. The 
system calls a timer's callback function when the timer elapses, passing it the pre-
scribed argument. The ISHELL_SetTimer function takes four arguments: an 
instance of the shell, the duration before the timer elapses in milliseconds, the 
function to invoke when the timer elapses, and a pointer to pass to the function 
when it's called. Thus, this call tells the system to call the function HideCopyright 
after APP _COPYRIGHT_CLOSE milliseconds, passing it a pointer to the application 
structure pThis. APP _COPYRIGHT_CLOSE is defined in SlideShow.h to be 10 seconds on 
the handset (and a significantly shorter time on the emulator to help the patience 
impaired when debugging). 
89 

Chapter 4 
90 
Finally, the function sets the flag m _ bCopyright so the event handler knows that 
the splash screen is showing. 
HideCopyright is simpler because it needs to only clear m _ bCopyright, cancel 
the timer if the user pressed a key, and post an event to the application saying that 
the splash screen has been dismissed (see Listing 4-12). 
Listing 4-12. Hiding the Copyright Screen 
1: 1** 
2: * Hides the copyright screen. 
3: * @param IApplet *p: pointer to application structure 
4: 
*1 
5: static void HideCopyright(CAppPtr pThis) 
6: { 
7: 
II We're done with the copyright screen. 
8: 
pThis->m_bCopyright = FALSE; 
9: 
10: 
II Cancel the timer, in case we got here on a keypress. 
11: 
ISHELL_CancelTimer( pThis->a.m_pIShell, 
12: 
(PFNNOTIFY)HideCopyright, 
13: 
pThis ); 
14: 
15: 
II Tell the app that the copyright screen was over. 
16: 
ISHELL_PostEvent( pThis->a.m_pIShell, 
17: 
AEECLSID_SLIDESHOW, 
18: 
EVT_COPYRIGHT_END, 0, 0 ); 
19: } 
Clearing the m_bCopyright flag occurs on line 8. On lines 11-13, the function 
clears the timer set by ShowCopyright. The system keeps a list of timers indexed by 
the timer function and timer argument pointer, so canceling a timer is simply a 
matter of specifying these to the ISHELL _ CancelTimer function. It's okay to cancel 
a timer that has already elapsed: The system simply ignores the request because 
there's no timer to cancel. 
TIP When your application exits and is released, all of your applica-
tion's timers and callbacks will be cancelled. 

Handling Events 
Finally, the function needs to let the application's event handler know that the 
splash screen has been dismissed; it does this on lines 16-18 by sending an 
EVT _COPYRIGHT _END event to the application. Posting an event is an asynchronous 
operation: The event is posted to the system's event queue, and the system will call 
the application's event handler at the next time it deems appropriate. (This is in 
contrast to ISHE LL _ Send Event, which invokes the application's event handler imme-
diately, returning control to the calling function only after the event has been 
handled by the application and the system.) When posting-or sending-an 
event, you must specify the application class ID to receive the event, as well as the 
event code and event arguments. 
Examining the Menu State in SlideShow 
The first state the application enters is the menu state, presenting you with the list 
of files from which to choose. The application enters this state when it first 
launches or after it receives a resume event when being suspended in the menu 
state. In each case, the setup is the same because when the state is exited or sus-
pended, the menu is tom down to release as much of the phone's resources as 
possible. 
Entering the Menu State 
As the application enters the menu state, it invokes the AS_MenuEntry function to 
initialize and show the menu of resource files (see listing 4-13). 
Listing 4-13. Presenting the Menu o/Slide Shows 
1: 1** 
2: * Prepares user interface for menu state. 
3: * Initializes menu, sets menu rectangle to screen, 
4: * iparam void *p: this applicaton 
5: * iparam EStateChange change: why we entered this state 
6: * ireturn nothing 
7: 
*1 
8: void AS_MenuEntry( void *p, 
9: 
EStatechange change) 
10: { 
11: 
CAppptr pThis = (CAppPtr)p; 
12: 
13: 
UNUSED( change ); 
14: 
ASSERT( pThis && pThis->m-pIMenu ); 
91 

Chapter 4 
92 
15: 
16: 
II Clear the display 
17: 
IDISPLAY_ClearScreen( pThis->a.m_pIDisplay ); 
18: 
19: 
II Reset the menu 
20: 
IMENUCTL_Reset( pThis->m_pIMenu ); 
21: 
22: 
II Set the menu's bounds 
23: 
IMENUCTL_SetRect( pThis->m_pIMenu, &pThis->m_rc ); 
24: 
25: 
II Populate the menu 
26: 
FillMenu( pThis ); 
27: 
28: 
II Activate the menu & update screen 
29: 
IMENUCTL_SetActive( pThis->m_pIMenu, TRUE ); 
30: 
IDISPLAY_Update( pThis->a.m_pIDisplay ); 
31: } 
Line 13 simply dismisses compiler warnings regarding unused variables with 
the UNUSED macro defined in utils.h. This macro works with both the Microsoft 
Visual Studio C compiler and the ARM C compiler, unlike more conventional 
#pragma instructions that are less portable. In a similar vein, line 14 tests the 
incoming variables in debug builds to ensure that both the application structure 
and the menu control are available. 
Line 15 clears the display, which until now was showing the application splash 
screen. 
Line 20 resets the menu control, ensuring that it contains no elements and 
default parameters at the outset. Resetting interface controls before using them is 
a good idea because otherwise they may contain values from their last invocation, 
especially if your application shares one control among multiple states. After 
resetting the menu, line 23 sets the menu's bounds to match the screen's bounds 
using IMENUCTL_SetRect and the screen dimensions obtained in SlideShow_Init so 
that the menu fills the entire display. 
Next, the application populates the menu with the list of available files by 
calling the function FillMenu, which you'll learn about shortly (line 26). Finally, the 
function activates the menu control, so it knows it should process system events, 
and then updates the display to show the menu on lines 29-30. 
The" FillMenu function demonstrates one of QUALCOMM BREW's great 
strengths: Objects familiar to software developers from other platforms have 
familiar interfaces. In this case, the object in question is the file system because 
F illMenu must walk the list of file entries in the application's directory to find any 
resource files. Not surprisingly, QUALCOMM BREW provides you with both a file 
manager interface (IFileMgr) and a corresponding enumeration method for doing 
this (see Listing 4-14). 

Listing 4-14. Obtaining a List of Files in a Directory 
1: 1** 
2: * Populates the menu with the list of slide shows. 
3: * @param CAppptr pThis: the application 
4: * @return nothing 
5: 
*1 
6: static void FillMenu( CAppptr pThis ) 
7: { 
8: 
IFileMgr *pIFileMgrj 
9: 
FileInfo infoj 
10: 
AECHAR wszBuff[ MAX_FILE_NAME + 1 ]j 
11: 
uint16 nItem = 1j 
12: 
int resultj 
13: 
14: 
II Setup the file manager instance 
15: 
result = ISHELL_CreateInstance( pThis->a.m_pIShell, 
16: 
AEECLSID JILEMGR, 
17: 
(void **)&pIFileMgr )j 
18: 
19: 
II Enumerate the list of .bar files 
20: 
if ( pIFileMgr ) 
21: 
{ 
22: 
II Begin enumeration 
23: 
if ( SUCCESS == IFILEMGR_EnumInit( pIFileMgr, "", FALSE) ) 
24: 
{ 
25: 
while ( IFILEMGR_EnumNext( pIFileMgr, &info ) 
26: 
{ 
27: 
II We're interested in files that end in .bar 
28: 
if ( STRENDS( 
n .bar", info.szName ) ) 
29: 
{ 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
II None was loaded, so create our own 
II Drop the .bar --- it looks hokey. 
info.szName[ STRLEN( info.szName ) - 4 ] = '\OOO'j 
II convert to a wide string 
STRTOWSTR( info.szName, wszBuff, MAX_FILE_NAME + 1 )j 
II Add it to the menu 
IMENUCTL_AddItem( pThis->m_pIMenu, 
NULL, II Resource file for item 
0, 
II Don't use the resource file 
nItem++, 
wszBuff, 
Handling Events 
93 

Chapter 4 
94 
43: 
(uint32)0)j II Item data 
44: 
} II add file name to menu 
45: 
} II file name enumeration 
46: 
} II enumeration guard 
47: 
48: 
II Clean up 
49: 
IFIlEMGR_Release( pIFileMgr )j 
50: 
} II pIFileMgr guard 
51: 
52: if ( nItem == 1 ) 
53: { 
54: 
II Menu addition failed. 
55: 
II But we always have our .bar, so add it manually. 
56: 
II convert to a wide string 
57: 
STRTOWSTR( ISlideShow", wszBuff, MAXJIlE_NAME + 1 ) j 
58: 
59: 
II Add it to the menu 
60: 
IMENUCTl-AddItem( pThis->m_pIMenu, 
61: 
NUll, II Resource file for item 
62: 
0, 
II Don't use the resource file 
63: 
nItem++, 
64: 
wszBuff, 
65: 
(uint32)0)j II Item data 
66: 
67: 
} II Add what is always there 
68: } 
Because you'll see more than you probably ever wanted to know about 
IMenuCtl in the following chapter, let's look closely only at the other functions in 
FillMenu. FillMenu begins by creating an instance of IF ileMgr (line 20), which it 
uses to iterate over the directory entries in the application directory. It's okay if this 
creation fails, however, because you can be confident that if the application 
reaches this point, there's at least one resource file available: the application's 
(lines 52-67). 
Assuming the shell can provide a file manager instance, line 23 initializes the 
file system enumerator. IFIlEMGR_EnumInit takes three arguments: the I FileMgr to 
use, the directory over which to enumerate, and whether it should include 
directory names in its iteration. Thus, line 23 instructs pIFileMgr to iterate over the 
application's home directory, ignoring any subdirectories that might exist. 
Assuming this is successful-which it should always be, unless your appli-
cation's Module Information File (MIF) file is incorrect-the function enters the 
while loop spanning lines 25-45. For each filename the enumerator returns, 
the function tests it to see if it ends in the string .bar, and ifit does, adds the 

Handling Events 
filename to the menu. Each pass through the loop, the call to IFILEMGR_EnumNext 
fills the FileInfo structure info with a copy of the information about the next file in 
the directory, returning TRUE as long as a file is found. 
Testing the filename is easy; the function simply uses the STRENDS helper 
function to test the filename, found in the szName member of the FileInfo structure 
Oine 28). If the filename ends in .bar, line 32 pretties up the filename, removing the 
filename suffix. 
Next, the function converts the string to a multibyte character using STRTOWSTR 
on line 35 because all of the interface controls require text in multibyte character 
strings (AEECHAR) to provide support for multiple languages. Finally, the function 
adds the filename in multibyte format to the menu on lines 38-43, specifying the 
item's text and numeric identifier. 
The function invokes the failure case-lines 52-67-ifthe IFileMgr can't be 
created or if the application directory can't be enumerated. The application logic 
is the same as within the confines of the while loop on lines 25-45, first converting 
the filename (the application's resource file) to a wide string and then adding it 
to the menu. 
Handling Events in the Menu State 
The menu state's event handler must do two things: share incoming events with 
the IMenuCtl and transition to the slide state to show the bitmaps in the selected 
resource file when you select a specific menu item (see Listing 4-15). 
Listing 4-15. Handling Events for the Menu State 
1: 1** 
2: * Handles events for the menu state 
3: * @param void *p: this applicaton 
4: * @param AEEEvent eCode: event code 
5: * @param uint16 wParam: event parameter 
6: * @param uint32 dwParam: event parameter 
7: * @return TRUE if application handled event 
8: *1 
9: boolean AS_MenuHandleEvent( void *p, 
10: 
AEEEvent eCode, 
11: 
uint16 wParam, uint32 dwParam) 
12: { 
13: 
CAppPtr pThis = (CAppptr)pj 
14: 
boolean result = FALSEj 
15: 
CtlAddltem menultemj 
16: 
95 

Chapter 4 
96 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
ASSERT( pThis && pThis->m_pIMenu ); 
II Give the control the first crack at it 
result = IMENUCTl_HandleEvent( pThis->m_pIMenu, 
eCode, 
wParam, 
dwParam ); 
if ( !result ) switch ( eCode ) 
{ 
} 
case EVT_COMMAND: 
II Find the filename of the selected resource 
IMENUCTl_GetItem( pThis->m_pIMenu, 
wParam, 
&menuItem ); 
WSTRTOSTR( menuItem.pText, pThis->m_szFile, MAX_FILE_NAME + 1); 
STRCAT( pThis->m_szFile, ".bar" ); 
II Start the slide show 
result = State_Push( p, 
break; 
AS_SlideEntry, 
AS_SlideExit, 
AS_SlideHandleEvent ); 
44: 
return result; 
45: } 
Lines 20-23 share incoming events with the menu event, calling 
IMENUCTL_HandleEvent to pass the event to the menu control. If the menu control 
handles the event, the following switch statement is ignored, and the event 
handler simply returns. 
The switch statement, on lines 25-42, is admittedly overkill because it tests 
only a single case, EVT _COMMAND. The menu control generates this event when you 
press the Select key on a menu item. Line 29 extracts the contents of the selected 
menu item-corresponding to a specific resource file's name-from the menu. 
Line 32 then converts this string from a multibyte string to a conventional C string, 
stashing the results in the application structure's m_szFile member so that the 
slide state will know which resource file you chose when it started. Finally, on 
lines 36-39, the event handler uses the application framework to transition to the 
slide state. 

Handling Events 
Exiting the Menu State 
Once you select an item on the menu and the menu state's event handler has pro-
cessed the EVT_COMMAND event and called State_Push to transition to the slide state, 
the menu state's exit function AS _ MenuExi t is invoked. This function simply 
clears the menu and disables it, releasing memory for the next state (see 
listing 4-16). 
Listing 4-16. Exiting the Menu State 
1: 1** 
2: * Exits the user interface for menu state. 
3: * Removes all menu entries and deactivates the menu 
4: * iparam void *p: this applicaton 
5: * @param EStateChange change: why we exited this state 
6: * ireturn nothing 
7: 
*1 
8: void AS_MenuExit( void *p, 
9: 
EStateChange change ) 
10: { 
11: 
CAppptr pThis = (CAppPtr)p; 
12: 
13: 
UNUSED( change ); 
14: 
15: 
ASSERT( pThis && pThis->m-p1Menu ); 
16: 
17: 
II Reset the menu 
18: 
IMENUCTL_Reset( pThis->m_plMenu ); 
19: 
20: 
II Deactivate this menu 
21: 
IMENUCTL_SetActive( pThis->m_plMenu, FALSE ); 
22: } 
The only interesting work this function does is on lines 18 and 21, where the 
function first resets the menu control and then deactivates it. 
Examining the Slide State in SlideShow 
The slide state is slightly more complex than the menu state because it must keep 
information about the next slide to show and the status of animation between 
calls to the state's event handler. Although QUALCOMM BREW provides image 
animation features that you'll encounter in later chapters, SlideShow won't use 
these features because the animation support assumes that an animated image is 
97 

Chapter 4 
98 
a series of animation frames residing as adjacent rectangles on a long bitmap, 
much like a roll of film (but turned on its side). Consequently, SlideShowuses the 
memory reserved for state variables and timers to provide animation. 
Central to the slide state is the CSlideShow structure: 
1: typedef struct _CSlideShow 
2: { 
3: 
char 
*m szFile' 
-
, 
4: 
uint16 m_nextj 
5: 
uint16 m_timerj 
6: 
int8 
m_dirj 
7: 
boolean m_bAnimatej 
8: } CSlideShow, *CSlideShowPtrj 
This structure keeps a copy of the pointer to the slide show's resource file, an 
integer indicating the next slide that should be shown, the animation delay, the 
direction of animation, and whether the slide show is animating, respectively. 
The ShowNextSlide function extensively uses this structure because it deter-
mines what needs to be done as the animation timer elapses or a key is pressed. 
This function is invoked both during entry into the slide state and by the slide 
state's event handler (see Listing 4-17). 
Listing 4-17. Showing the Next Slide 
1: 1** 
2: * Shows the next slide. 
3: * Sets a timer for animation if necessary. 
4: * @param void *p: this applicaton 
5: * @return nothing 
6: *1 
7: static void ShowNextSlide( void *p ) 
8: { 
9: 
CAppPtr pThis = (CAppptr)pj 
10: 
CStatePtr pStatej 
11: 
CSlideShowPtr plnfoj 
12: 
13: 
ASSERT( pThis )j 
14: 
pState = State_GetCurrentState( pThis )j 
15: 
ASSERT( pState )j 
16: 
17: 
II Clear the display 
18: 
IDISPLAY_ClearScreen( pThis->a.m_pIDisplay )j 
19: 

Handling Events 
20: 
if ( ( pinfo = State_GetStateData( pState ) ) != NULL ) 
21: 
{ 
22: 
IImage *plmage; 
23: 
24: 
II Point to the current image 
25: 
plnfo->m_next += plnfo->m_dir; 
26: 
if ( plnfo->m_next == 0 ) 
27: 
{ 
28: 
plnfo->m_next = 1; 
29: 
plnfo->m_dir = 1; 
30: 
} 
31: 
32: 
II Load the bitmap 
33: 
plmage = ISHELL_LoadReslmage( pThis->a.m_pIShell, 
34: 
plnfo->m_szFile, 
35: 
plnfo->m_next ); 
36: 
37: 
II Wrap back around to first image if nothing is shown 
38: 
if ( !plmage ) 
39: 
{ 
40: 
plnfo->m_next = 1; 
41: 
plmage = ISHELL_LoadReslmage( pThis->a.m_pIShell, 
42: 
plnfo->m_szFile, 
43: 
plnfo->m_next ); 
44: 
} II Do we have an image? no? then wrap around 
45: 
46: 
II Display the bitmap 
47: 
if (plmage) 
48: 
{ 
49: 
lIMAGE_Draw( plmage, 0, 0 ) 
50: 
51: 
II Free the image 
52: 
lIMAGE_Release( plmage ); 
53: 
plmage = NULL; 
54: 
} II Do we have an image 
55: 
56: 
II Update the screen 
57: 
IDISPLAY_Update( pThis->a.m-pIDisplay ); 
58: 
59: 
II Set the timer to do it again if necessary 
60: 
if ( plnfo->m_bAnimate 1= 0 ) 
61: 
ISHELL_SetTimer( pThis->a.m_pIShell, 
62: 
plnfo->m_timer, 
63: 
(PFNNOTIFY) ShowNextSlide, 
99 

Chapter 4 
100 
64: 
pThis ); 
65: 
} II Do we have valid slide info? 
66: 
} II Do we have valid state data? 
67: } 
This function gets interesting on line 20, where it obtains a pointer to the 
state's CSlideShow information in plnfo. It then calculates the resource 10 of 
the next bitmap to load by incrementing or decrementing plnfo->m_next based 
on the value of plnfo- >m _ dir. Lines 26-30 guard against trying to wrap below the 
first bitmap in the resource by switching playback to the forward direction when 
the first slide is reached (plnfo- >m _next is equal to zero). Lines 33-35 try to load the 
image-this time from the specified resource file, not the application resource-
using the current image's 10. If this fails, the function assumes it has reached the 
end of the bitmaps to show, resets the image counter, and loads the first image on 
lines 38-44. 
With the image to draw now in plmage, the function draws the image (line 48) 
and releases the resources used by the image (lines 52-53). It then updates the 
screen (line 57) and sets a timer to draw the next image if the animation flag 
plnfo->m_bAnimate is TRUE. 
As with the menu state before it, the slide state doesn't differentiate between 
entry and exit operations because of the manipulation of the state stack or 
between suspend and resume events. State operation is identical in either state, 
reflecting the fact that on exiting the state for any reason, the slide state frees all 
resources and cancels the animation timer, waiting for the next state entry to 
begin showing slides again. 
NOTE 
This behavior works well for an application such as this for view-
ing developer prototypes, but it might not be what an end user expects 
when viewing an animation of, say, personal slides when she receives a 
phone call. After the phone call, she might well expect her slide show to 
pick up where it left offbefore the call. This is precisely the kind of ques-
tion you can answer with prototypes, where you can gauge your user's 
response. 
Entering the Slide State 
When the menu state pushes the slide state onto the application framework's 
stack, the framework calls AS _ SlideEntry, which allocates space for the CSlideShow 
structure (see Listing 4-18). 

Handling Events 
Listing 4-18. Entering the Slide Show State 
1: 1** 
2: * Prepares user interface for slide show state 
3: * Shows the first slide. 
4: * @param void *p: this applicaton 
5: * @param EStateChange change: why we entered this state 
6: * @return nothing 
7: 
*1 
8: void AS_SlideEntry( void *p, 
9: 
EStateChange change ) 
10: 
{ 
11: 
CAppPtr pThis = (CAppPtr)p; 
12: 
CStatePtr pState; 
13: 
CSlideShowPtr pInfo; 
13: 
UNUSED( change ); 
14: 
15: 
pState = State_GetCurrentState( pThis ); 
16: 
ASSERT( pThis && pState); 
17: 
18: 
II Allocate memory for the state info 
19: 
pInfo = MALLOC{ sizeof( CSlideShow ) ); 
20: 
if ( pInfo ) 
21: 
{ 
22: 
SetStateData( pState, pInfo ); 
23: 
pInfo->m_szFile = pThis->m_szFile; 
24: 
plnfo->m_next = 0; 
25: 
pInfo->m_timer = pThis->m_frameDelay ? 
26: 
pThis->m_frameDelay : TIMER_DEFAULT; 
27: 
pInfo->m_dir = 1; 
28: 
pInfo->m_bAnimate = FALSE; 
29: 
II Show this slide 
30: 
ShowNextSlide( p ); 
31: 
} 
32: } 
This function is primarily bookkeeping. First, it uses MALLOC to allocate space 
for the CSlideShow structure on line 19 and then (assuming the memory allocation 
succeeds) initializes the state's data member and the fields of the CSlideShow 
structure to reasonable defaults on lines 22-28. Note especially that the m_szFile 
member of the state's CSlideShow structure is a copy of the pointer to the appli-
cation's storage for the resource filename-not a copy of the filename itself. 
Because the state doesn't need to change the filename at any point, doing this is 
101 

Chapter 4 
102 
memory efficient while also ensuring readability in ShowNextSlide when it must 
access the resource file. Finally, the function updates the screen by drawing the 
first slide in the sequence by calling ShowNextSlide. 
Handling Events in the Slide State 
The slide state's event handler must handle keystroke events for the Select key to 
start and stop animation, as well as the directional pad to select the previous or 
next slide and control the animation speed. AS_Hand1eEvent is one of the longer 
functions in AppStates. c, but it really doesn't do much besides manipulate the 
contents of the state variables (see listing 4-19). 
Listing 4-19. Handling Events in the Slide Show State 
1: 1** 
2: * Handles events for the menu state 
3: * @param void *p: this applicaton 
4: * @param AEEEvent eCode: event code 
5: * @param uint16 wParam: event parameter 
6: * @param uint32 dwParam: event parameter 
7: * @return TRUE if application handled event 
8: 
*1 
9: boolean AS_SlideHandleEvent( void *P. 
10: 
AEEEvent eCode. 
11: 
uint16 wParam. uint32 dwParam) 
12: { 
13: 
CAppPtr pThis = (CAppPtr)pi 
14: 
CStatePtr pStatei 
15: 
CSlideShowptr pInfoi 
16: 
boolean result = FALSEi 
17: 
18: 
ASSERT( pThis )i 
19: 
20: 
pState = State_GetCurrentState( pThis )i 
21: 
ASSERT( pState )i 
22: 
23: 
pInfo = GetStateData( pState )i 
24: 
25: 
if ( pInfo ) switch ( eCode ) 
26: 
{ 
27: 
case EVT_KEY: 
28: 
switch( wParam ) 
29: 
{ 

30: 
case AVK_SELECT: 
31: 
pInfo->m_bAnimate = IpInfo->m_bAnimate; 
32: 
ShowNextSlide( p ); 
33: 
result = TRUE; 
34: 
break; 
35: 
36: 
case AVK_UP: 
37: 
if ( pInfo->m_timer > TIMER_MINIMUM ) 
38: 
{ 
39: 
pInfo->m_timer 1= 2; 
40: 
ISHELL_CancelTimer( pThis->a.m_pIShell, 
41: 
(PFNNOTIFY) ShowNextSlide, 
42: 
pThis ); 
43: 
ShowNextSlide( p ); 
44: 
result = TRUE; 
45: 
} 
46: 
break; 
47: 
48: 
case AVK_OOWN: 
49: 
if ( pInfo->m_timer a& pInfo->m_timer < TIMER_DEFAULT) 
50: 
{ 
51: 
pInfo->m_timer *= 2; 
52: 
ISHELL_CancelTimer( pThis->a.m-pIShell, 
53: 
(PFNNOTIFY) ShowNextSlide, 
54: 
pThis ); 
55: 
ShowNextSlide( p ); 
56: 
57: 
58: 
59: 
result = TRUE; 
} 
break; 
60: 
case AVK_LEFT: 
61: 
ISHELL_CancelTimer( pThis->a.m-pIShell, 
62: 
(PFNNOTIFY) ShowNextSlide, 
63: 
pThis ); 
64: 
II Point to the currently displayed frame 
65: 
pInfo->m_dir = -1; 
66: 
ShowNextSlide( p ); 
67: 
result = TRUE; 
68: 
break; 
69: 
70: 
case AVK_RIGHT: 
71: 
ISHELL_CancelTimer( pThis->a.m_pIShell, 
72: 
(PFNNOTIFY) ShowNextSlide, 
73: 
pThis ); 
Handling Events 
103 

Chapter 4 
104 
74: 
75: 
76: 
pInfo->m_dir = 1; 
ShowNextSlide( p ); 
result = TRUE; 
77: 
break; 
78: 
} 
79: 
break; 
80: 
} 
81: return result; 
82: } 
Rather than examine this function on a case-by-case basis, this section hits the 
highlights because by now you have the general idea of how it works. For a given 
keystroke, the handler must mutate the pInfo structure to represent the behavior 
desired by the user. The Select key (lines 30-34) toggles the m _ bAnimate flag in plnfo, 
letting the timer expire of its own accord after displaying an additional frame. The 
up and down keys (lines 36-58) adjust the delay between successive frames by 
factors of 2, pinning the resulting values between the compile-time constants 
TIMER_MINIMUM and TIMER_DEFAULT (one-eighth of a second and a trifle more than 
two seconds, respectively). After adjusting the frame rate, these cases cancel the 
timer and immediately display the next frame, ensuring that you receive prompt 
feedback regarding the animation speed change you requested. Finally, the left 
and right keys (lines 60-77) cancel the animation timer and toggle the value of 
m_ dir in plnfo. selecting between reverse and forward play (or the previous or next 
slide if no animation is taking place). 
One thing the event handler doesn't have to do is handle navigation back to 
the menu state: It gets that for free from the application framework's event 
handler, State_HandleEvent, described previously. 
Exiting the Slide State 
Exiting the slide state is an exercise in resource reclamation, as you can see in 
AS_SlideExit (see listing 4-20). 
Listing 4-20. AS _ SlideExi t 
1: 1** 
2: * Tears down the UI for the slide show. 
3: * Cancels the animation timer. 
4: * @param void *p: this applicaton 
5: * @param EStateChange change: why we exited this state 
6: * @return nothing 
7: 
*1 

Handling Events 
8: void AS_SlideExit( void *p, 
9: 
EStateChange change ) 
10: { 
11: 
CAppptr pThis = (CAppPtr)pj 
12: 
CStatePtr pStatej 
13: 
CSlideShowptr pInfoj 
14: 
15: 
UNUSED( change )j 
16: 
17: 
pState = State_GetCurrentState( pThis )j 
18: 
ASSERT( pThis && pState)j 
19: 
pInfo = GetStateData( pState )j 
20: 
21: 
II Free the state data 
22: 
if ( pInfo ) 
23: 
{ 
24: 
II Save the current playback frame rate 
25: 
pThis->m_frameDelay = pInfo->m_timerj 
26: 
27: 
FREE( pInfo )j 
28: 
SetStateData( pState, NULL )i 
29: 
} 
30: 
31: 
II Cancel the animation timer 
32: 
ISHELL_CancelTimer( pThis->a.m_pIShell, 
33: 
(PFNNOTIFY) ShowNextSlide, 
34: 
pThis ); 
35: } 
The function begins by getting a pointer to the current state Oine 17) and its 
state variables (line 19). Assuming the state has a state variable-it should, but it 
never hurts to be sure, and it definitely hurts to dereference a null pointer!-it 
stashes the currently selected animation speed in the application's structure on 
line 25 and then frees the state's variable space on line 27. line 28 nulls out the 
state's variable pointer, ensuring that the debugging scaffolding in State. c doesn't 
complain about potential memory leaks. Finally, on lines 32-34, the function 
cancels the animation timer. 
105 

Chapter 4 
106 
Summary 
This chapter covered the following key points: 
â¢ Your application must provide an event handler to respond to events that 
the system delivers from the event pump. 
â¢ Because the QUALCOMM BREW environment is single-threaded, all of your 
application's operation (save initialization and termination> centers on 
managing the events your application receives. 
â¢ System events consist of an event code and two arguments, one a single 
word and one a double word. 
â¢ Your application must be able to handle the EVT_APP _START, EVT_APP _STOP, 
EVT_SUSPENO, and EVT_RESUME events. 
â¢ Representing your application as a sequence of states, with one state for 
each application screen, gives you a good structure in which to develop your 
application and provide predictable application flow to your users. 
â¢ Using an application framework that encapsulates the state machine 
encourages reuse and raises the likelihood that subsequent applications 
using the same state machine will pass external verification because you use 
a minimum of new code in each application. 

CHAPTER 5 
Interacting 
with the User 
INTERACTING WITH THE user is a primary responsibility for any application. 
QUALCOMM BREW provides the usual gamut of user input/output controls, 
including static and mutable text controls, a versatile menu control, custom con-
trols for entering the time and date, and even a simple Hypertext Markup 
Language (HTML) viewer you can use to present documents formatted in simple 
HTML. This chapter shows you the most common controls you'll encounter in 
QUALCOMM BREW; as well as how to extend the previous chapter's framework to 
simplify handling your application's controls. 
Understanding Modes of User Interaction 
Applications running under QUALCOMM BREW can interact with the user in 
three primary means: visually, aurally, and tactilely. Each has specific strengths 
and weaknesses. More important, users expect certain kinds of interaction from 
their phone to have specific meanings-for example, a vibration may be appro-
priate to notify the user of an incoming message or to add excitement to a game 
but isn't appropriate in other settings, such as when reporting the successful com-
pletion of a network transaction. 
Using the Display and Keyboard to Interact with the 
User 
The handset display and keypad are the primary mediums by which your appli-
cation will interact with the user. Your application will display text and graphics, 
and it will accept user input via the keys and direction pad. 
When designing applications for wireless handsets, you need to keep several 
things in mind. First, wireless handsets are small. A handset's display isn't suited to 
presenting a great deal of information at once, and the keypad constrains your 
ability to enter a great deal of text information. Consequently, it's best to set up the 
107 

ChapterS 
108 
interface of your application to use icons rather than text, wherever possible, and 
rely on menus and canned text to speed text input. 
NOTE Even with today's rapid-entry systems such as Motorola's iTap 
and Tegic's 1'9, text input can still be a frustrating and time-consuming 
experience, especially for applications that rely on text, such as messag-
ing and chat applications. Applications requiring a great deal of text 
input should provide menus with customizable qUick-text entries for 
common phrases. 
There are few user interface conventions for QUALCOMM BREW applications, 
but those that exist are largely immutable: 
â¢ All applications should begin with a full-screen splash screen that identifies 
the application. This splash screen should appear for 10 seconds or until the 
user presses a key. 
â¢ From any screen, the Clear key should bring the user to the logical previous 
screen. If you're viewing the applications main screen, Clear should exit the 
application. 
â¢ In virtually all applications, there should be only one input control (such as 
an input line or full-screen menu) on the display at once. (Notable excep-
tions include the text control with a soft key menu discussed in the section 
"Using the ITextCtl Control" and applications with a browser-like interface 
that can show more than one selectable hyperlink at once.) 
â¢ From any screen, the Select key should accept a current action, such as 
selecting a menu choice or completing text input, and it should bring the 
user to the next logical screen. 
In a sense, the Clear and Select keys are analogous to the Back and Next 
buttons on a Web browser: The Clear key brings you back to the item you've just 
seen, and the Select key brings you to the next screen, as if you selected a link in a 
browser. 
A notable exception to this user flow that you must keep in mind is how 
network activity and other status dialog boxes change application flow. For 
example, consider a stock quote application, where you enter a stock ticker 
symbol and then the application makes a network request to obtain the current 
value of the stock. When viewing the results of a query, pressing Clear should show 
you the stock ticker input screen, not the network status display. This is generally 

Interacting with the User 
true for any application that includes status annunciators or screens; pressing 
Clear should bring you to the step prior to the action that requires a status display. 
You have two choices for generating text and images for the display: using the 
QUALCOMM BREW display controls (discussed in this chapter) or using the raw 
graphics interfaces, which are implemented in classes such as IDisplay and 
IGraphics and are covered in Chapter 8, "Drawing Graphics." 
Some controls, such as the IStatic control, only display text and don't accept 
user input. Most, however, such as the IMenuCtl control, both display things on the 
screen and accept input from the user. When using these controls, your appli-
cation's event handler shares incoming events with the control and looks for 
EVT _COMMAND events that signal events from the control that your application must 
process, such as a menu selection or the completion of text input. 
In addition to these controls, the IShell interface provides the ISHELl_Message 
and I SHE ll_ Mes sageBox functions to display a simple text dialog box with a title and 
text message on the screen. In practice, these functions are good when writing test 
programs or when debugging. 
Using Audio to Interact with the User 
QUALCOMM BREW provides support for rich audio, including playing files in 
MP3, MIDI, and QCP formats, as well as playing individual tones, including the 
Dual-Tone Multi-Frequency (DTMF) tones you hear when dialing a touch-tone 
phone. 
NOTE 
MP3 stands for Moving Pictures Expert Group Audio Layer 3, and 
MIDI stands for Music Industry Digital Interface. 
Most users expect sound support for specific purposes, including providing 
additional feedback for an alert or alarm (perhaps for an appointment or an 
incoming message), setting the mood in a game, and providing status in a game. 
Using QUALCOMM BREW's support forWAY, MP3, and QCP, you can provide 
sampled sounds, such as those you hear on a computer, including the ability to 
play back voice samples for simple vocal feedback. The MIDI format, on the other 
hand, is best used to play simple songs or to provide additional ring tones to 
handsets. Of course, you can also use simple tones to provide audio feedback 
when selecting menu items and the like. 
Because wireless handsets are often used in public settings, it's important 
your application provides users with the ability to quickly silence sounds when 
109 

ChapterS 
110 
using your application. Not all handsets map a user's sound settings in the Original 
Equipment Manufacturer's (OEM) settings panels to applications running under 
QUALCOMM BREW; so it's important you let users silence your application when 
using it in some situations, such as while in a meeting or in a movie theater. 
QUALCOMM BREW provides two interfaces to the handset to support sound, 
aptly named the ISound and ISoundPlayer interfaces. You use the ISound interface to 
perform system management functions such as setting the sound wlume and 
playing single or DTMF tones, and you use the ISoundPlayer interface to play more 
complex sounds asynchronously, such as MP3 or MIDI sound files. Because OEMs 
make the decision as to which sound formats a specific handset can support, it's 
important you architect your application to support sound files of the appropriate 
format for specific handsets. Chapter 9, "Playing with Sounds," discusses the 
ISound and ISoundPlayer controls in detail. 
Using Tactile Feedback to Interact with the User 
QUALCOMM BREW provides two tactile (touch) interfaces. The first is immedi-
ately obvious: the keypad. Your application can use the keypad in conjunction 
with the input controls to accept input, or you can look for specific key presses in 
your application's event handler by waiting for and intercepting EVT _KEY events, as 
you saw in the SlideShow program in the previous chapter. Input controls are best 
used for specific kinds of user input, and managing mw keyboard events is 
best when writing custom input controls or in a game, where a single key press 
maps to a distinct change in application flow. 
In addition to being able to accept these tactile events, QUALCOMM BREW 
also provides the ability to activate the built -in vibration device found in most 
wireless handsets today. Using the ISOUND _Vibrate method, you can have the 
handset vibrate for a specific amount of time; using the ISOUND _ StopVibrate 
method, you can cancel a current vibration. Vibration alerts can provide extra 
feedback in games or provide notification of exceptional events (such as a 
message receipt) when the user has silenced audio from your application. 
Using the QUALCOMM BREW Controls 
Within the QUALCOMM BREW inheritance hierarchy, all of the QUALCOMM 
BREW user interface controls inherit from the IControl interface. The IControl 
interface is abstract; that is, you can't instantiate an IControl interface for your 
own use. Instead, you use the IControl interfaces to invoke methods on an arbi-
trary control, such as when you have an array containing different kinds of 
controls. 

Interacting with the User 
The IControl interface provides the following methods, which all controls 
implement: 
You use the ICONTROL_HandleEvent method to send an event to the 
control. You should use this method to forward all incoming events to 
controls before you handle them and only handle events that aren't 
handled by the control. ICONTROL_HandleEvent returns TRUE if the 
control handled the event and FALSE if the application or another control 
should handle the event. 
You use the ICONTROL _Redraw method to force a control to redraw itself on 
the display, such as after setting its contents. 
You use the lCONTROL _ SetActi ve method to give focus to a control. Only the 
active control will process the events you pass it when calling 
ICONTROL_HandleEvent. 
You use the ICONTROL_IsActive method to determine whether the specified 
control is active-that is, whether it will process the events handed to it by 
calling ICONTROL _ HandleEvent. 
You use the ICONTROL _ SetRect method to set the display rectangle for the 
specified control. 
You use the ICONTROL_ GetRect method to get the display rectangle for the 
specified control. 
You use the lCONTROL_SetProperties method to set a control's properties. 
Every control has up to 32 control-specific properties, each represented 
by a bit in a 4-byte bitfield. When you first create a control using 
ISHELL_Createlnstance, all ofits properties are set to o. Properties indicate 
specific attributes of a control, such as whether a text control is single-line 
or multiline. 
You use the ICONTROL_GetProperties method to determine the settings of 
the properties for the indicated control. 
You use the ICONTROL_Reset method to instruct a control to free its under-
lying resources and clear its active flag so that it will no longer process any 
events it receives. 
Of course, if you know the type of a specific control, you may invoke that 
control's method directly. For example, if you're working with the IMenuCtl 
instance pIMenu, the following two lines of code are equivalent: 
1: ICONTROL_Reset( pIMenu ); 
2: IMENUCTL_Reset( plMenu ); 
III 

ChapterS 
112 
A common use for the IControl interface is when managing an array of con-
trols, anyone of which may be active, without your application needing to track 
the currently active control. 
The following discussion uses snippets of code, rather than entire applica-
tions, to demonstrate the use of each control. For the purposes of the discussion, 
this chapter continues to use the application structure introduced in the previous 
chapter to contain an application's global data, with a single modification: 
1: typedef struct _CApp 
2: { 
3: 
AEEApplet 
4: 
CStatePtr 
5: 
boolean 
6: 
a' , 
m_statej 
m_bSplashingj 
7: 
8: 
II screen and font dimensions 
int 
9: 
int 
10: 
int 
11: 
12: 
13: 
14: 
int 
Boolean 
Boolean 
AEERect 
m cx' 
- , 
m_cyj 
m_colorDepthj 
m_nFontHeightj 
m_bInitj 
m_bColorj 
m_rcj 
15: 
II Application controls 
16: 
IControl 
*m_apControl[ MAX_NUM_CONTROLS ]j 
17: } CApp, *CAppPtrj 
The field m _ apControl provides a central repository for the application's con-
trols. The slots in this array are initialized as the application starts and accessed 
throughout the application, such as during the application's event handler. 
To create a control, you simply use ISHELL_CreateInstance, passing it the class 
ID of the desired control. For example, to create an IStatic control, use the fol-
lowing code: 
1: 1* 
2: * In your application's initialization routine 
3: *1 
4: 
5: II Create an instance of an IStatic text control 
6: if ( ISHELL_CreateInstance( pThis->a.m_piShell, 
7: 
AEECLSID_STATIC, 
8: 
(void **)&(pThis->m_apControl[o]Â» 
!= SUCCESS) 
9: 
returnj 

Interacting with the User 
When creating a control, it's best to do so when the application launches to 
ensure that there's enough memory for the application to execute correctly. Once 
created, your control can remain inactive and invisible, and you need only set its 
contents and properties when you use the control. 
TIP Preallocation is a good defensive programming strategy. By preal-
locating objects and memory that your application simply can't do 
without while it starts, you minimize the likelihood offailure due to 
out-of-memory e"ors during execution because you simply can't start if 
you can't obtain the necessary resources. This makes your application 
easier to implement, test, and debug. 
Because each control tracks for itself whether it needs to process events 
(based on its active flag, which you can set and examine using lCONTROl_IsActive 
and lCONTROl_SetActive), it's easy to pass events to the currently active control in 
your application's event handler: 
1: 
2: 1* 
3: * in your HandleEvent() 
4: *1 
5: boolean result = FALSEj 
6: int ij 
7: 
8: II The controls always get first dibs 
9: for ( i = OJ i < MAX_NUM_CONTROLSj i++ ) 
10: { 
11: 
if ( pThis->m_apControl[i] && 
12: 
ICONTROL_IsActive( pThis->m_apControl[i] ) ) 
13: 
result = ICONTROL_HandleEvent( pThis->m_apControl[i], 
14: 
eCode, wParam, dwParam )j 
15: 
if ( result ) breakj 
16: } 
17: if ( !result ) switch( eCode ) 
18: { 
19: 
II handle other events here ... 
20: } 
21: return resultj 
The loop on lines 9-16 simply walks each slot in the list of controls 
p This- >m _ apControl. If a given slot contains a pointer to a control and the control is 
113 

ChapterS 
114 
active (lines 11-12), the event passes to the control (line 13). If the control handles 
the event and no further processing is necessary, lCONTROl_HandleEvent returns 
TRUE, and the loop exits on line 15. Otherwise, the loop continues until it has 
exhausted all controls in the list, and your code will get a chance to process the 
event starting on line 17. 
CAUTION 
As you'll see in subsequent sections of this chapter, this can 
be a little tric1cy when you're mixing a lot of different controls in the 
m _ apControl array, such as text input and soft key menu controls. For 
an example of a full general-purpose HandleEvent function that you'd 
want to use in your application, see the "Integrating Controls with Your 
Application Framework" section. 
Finally, as with any other QUALCOMM BREW interface, you must release 
objects to prevent memory leaks when you're finished with the object. In general, 
it's best to free the objects created at application launch when the application ter-
minates. Releasing the application's controls is a simple loop: 
1: 1* 
2: * When the application exits 
3: *1 
4: II Free the control 
5 : 
6: for ( i = OJ i < MAX_NUM_CONTROlSj i++ ) 
7: { 
8: 
if ( pThis->m_apControl[i] ) 
9: 
ICONTROL_Release( pThis->m_apControl[ 0 ] )j 
10: } 
This loop is straightforward; it simply calls ICONTROl_Release on any allocated 
controls. 
Using the IStatic Control 
The IStatic control is the simplest to understand and use. This control simply pre-
sents a title and scrollable text message, just like the one you see in Figure 5-1. 

Interacting with the User 
Welcome! 
Hello world! 
Figure 5-1. The IStatic control in action 
Using the IStatic control is easy: Simply create it by passing the class ID 
AEEClASSID _STATIC, set its options and content, and then redraw it to have it draw 
on the display. Periodically-every pass through your event loop-you should 
pass incoming events to the IStatic instance using IStatic_HandleEvent (or its 
superclass method, IControl_HandleEvent). listing 5-1 shows how you can use an 
IStatic control in your application, assuming that the first entry (at index 0) of the 
application's m_apControl is set to a valid IStatic instance. 
Listing 5-1. Using IStatic 
1: 1* 
2: * Populating and showing a text control 
3: 
*1 
4: AECHAR pszTitle[ 64 ]; 
5: AECHAR pszText[ 256 ]; 
6: 
7: II Read in the title and text string from the resource file 
8: nCharCount = ISHELL_LoadResString( pThis->a.m_pIShell, 
9: 
APP _RES_FILE, 
10: 
11: 
pszTitle, 
12: 
sizeof(pszTitleÂ»; 
13: nCharCount = ISHELL_LoadResString( pThis->a.m-pIShell, 
14: 
APP _RESJILE, 
15: 
16: 
17: 
18: 
pszText, 
sizeof( pszText ) ); 
19: II Set the dimensions of the control to fill the screen. 
20: ISTATIC_SetRect( pThis->m_apControl[O], 
21: 
&pThis->m_rc ); 
22: 
23: II Set the properties that specify 
115 

ChapterS 
116 
24: II centering of control text lines and title 
25: ISTATIC_SetProperties( pThis->m_apControl[O], 
26: 
ST_CENTERTEXT I ST_CENTERTITlE ); 
27: 
28: II Set the values of the title and 
29: II text strings for this control 
30: ISTATIC_SetText( pThis->m_apControl[O], 
31: 
32: 
33: 
34: 
pszTitle, 
pszText, 
AEE_FONT_BOLD, AEE_FONT_NORMAL ); 
35: II Make the text control active 
36: ISTATIC_SetActive( pThis->m_apControl[O], TRUE ); 
37: II Display the text control 
38: ISTATIC_Redraw( pThis->m_apControl[o] ); 
This code is straightforward and representative of how you'll use almost any 
control in QUALCOMM BREW. The first lines-from line I until line IS-are 
housekeeping, loading some preset text from a resource. (You could just as easily 
use programmatically generated text-say, from SPRINTF-and convert the 
resulting text to BREW multibyte strings using STR _ TO ).JSTR for dynamic content. 
When using STR _ TO )oJSTR, it's important to remember that you must provide a des-
tination buffer large enough to hold the resulting string.) 
TIP As with other platforms, it's best to put as many o/your strings in 
the resource file rather than scattering strings around your code. By 
doing so, you make it easier when you find you need to localize your code 
or change text contents to meet requirements for specific customers or 
handsets. 
Next, set the control's bounds using the ISTATIC_SetRect Application Pro-
gramming Interface (API) on lines 20-21. This call takes an AEERect structure, 
which has four slots: x, y, dx, and dy. These specify the comers of a rectangle: x and 
yare the coordinates of the rectangle's upper-left comer, and dx and dy are the rect-
angle's width and height, respectively. QUALCOMM BREW follows the popular 
convention of numbering pixels from left to right along the x axis and from top to 
bottom along the y axis. Line 20 simply sets the control's bounds to the full extent 
of the screen, previously calculated in the application initialization routine 
described in the previous chapter. You should always set your control's bounds 
before drawing it because there are no preset defaults for a control's bounds. 

Interacting with the User 
The IStatic control has several options, two of which are on lines 25-26. The 
ST _ CENTERTEXT option tells the control that the text should be centered within the 
control, and the ST _ CENTERTITlE option tells the control that the title should be cen-
tered within the title bounds. Table 5-1 describes the other properties of the 
IStatic control. 
TableS-l. IStatic Options 
OPTION 
PURPOSE 
ST _ CENTERTEXT 
Centers text along the x axis of the bounding rectangle. 
ST _ CENTERTITLE 
Centers title along the x axis of the bounding rectangle. 
ST _ NOSCROL L 
Does not scroll text. 
ST _ TEXTAL LOC 
Text string was allocated on heap; caller must take responsibility 
for freeing it. 
ST _ TITlEAL LOC 
Title string was allocated on heap; caller must take 
responsibility of freeing it. 
ST _ MIDDLETEXT 
Centers title along the y axis of the bounding rectangle. 
ST_UNDERLINE 
Underlines the title. 
ST _ASCII 
Text is a single-byte string. 
ST _ ENAB LETAB 
Generates EVT _ CTL _TAB when scrolling reaches the top or 
bottom. 
ST_ENABLE_HLGHT 
Highlights the control if it has focus (ISTATIC_IsActive is TRUE). 
Most of the IStatic properties pertain to a text control's appearance-whether 
the title should be underlined or centered; whether the contents should be cen-
tered horizontally, vertically, or both in the bounding rectangle; and so forth. 
Most of the time, you simply pass the IStatic instance pointers to the content 
it should display, and the control makes copies of the contents so that you don't 
have to worry about the memory used by the control's contents. At times, however, 
you may want to avoid the additional memory overhead, especially when dis-
playing a large amount of information or when you want your control to provide a 
view of dynamically changing data. To do this, you assert either the ST _ TEXTALLOC or 
ST _ TITLEALLOC properties to indicate that your application is responsible for 
freeing the content's text or title (or both, if you assert both properties) buffers. 
By default, the IStatic control will scroll its contents marquee-style down the 
display if the contents are larger than the bounding rectangle. You can prevent this 
behavior by setting the ST _ NOSCROLL property; however, if you do so, you won't be 
117 

ChapterS 
118 
able to see the control's entire contents if the contents don't tit in the bounding 
box. (At present, QUALCOMM BREW doesn't provide user or programmatic 
control of the IStatic control's scrolling behavior.) You can also assert 
the ST_ENABLE_TAB property so that the text control sends your application the 
EVT _ CTL _TAB event when scrolling has reached the top or bottom of the control 
contents. 
NOTE In cu"ent implementations ofQUALCOMM BREw, the IStatic 
control doesn't use events in its operation. However, to ensure full com-
patibility with later releases of QUALCOMM BREw, your application 
should use one of the two _ HandleEvent methods to pass events to your 
application's active IStatic controls. 
Using the IMenuCtl Control 
The IMenuCtl is actually the interface to four separate classes: 
â¢ The menu control provides an array of menu elements organized with one 
menu item per each row of the control and lets you choose and select 
another item using the directional pad (see Figure 5-2). 
â¢ The list control shows the currently selected menu item on the display and 
lets you choose and select another item using the directional pad (see 
Figure 5-3). 
â¢ The soft key menu control shows menu items side by side along the bottom 
line of the screen and lets you choose an item using the left and right keys on 
the directional pad (see Figure 5-4). 
â¢ The icon view menu control shows an array of bitmaps singularly or in a grid 
and lets you choose one using the directional pad (see Figure 5-5). 
Table 5-2 provides the class ID for each kind of control. 

Interacting with the User 
o mmeOi 
Figure 5-2. The standard menu control 
Figure 5-3. The list control 
Message? 
f"ielloworld 
1 
OK 
Figure 5-4. The soft key menu control 
Figure 5-5. The icon view menu control 
119 

ChapterS 
120 
Table 5-2. Class IDs for Menu Controls 
MENU CONTROL 
Standard menu control 
List menu control 
Soft key menu control 
Icon view menu control 
CLASS ID 
AEECLSID_MENUCTL 
AEECLSID_LISTCTL 
AEECLSID_SOFTKEYCTL 
AEECLSID_ICONVIEWCTL 
When using any kind of menu, the general sequence of operations your appli-
cation must perform is as follows: 
1. Create the appropriate kind of menu control using ISHELL_Createlnstance. 
2. Set the bounds of the menu control using IMENUCTL_SetRect. 
3. Set any desired menu options using IMENUCTL_SetOpt. 
4. Construct the menu's contents using the IMENUCTL _ Add Item, 
IMENUCTL_AddltemEx, and IMENUCTL_Deleteltem methods. 
5. Mark the currently selected item (if any) using the IMENUCTL_SetSel 
method. 
6. Set the menu to process events using the IMENUCTL_SetActive method. 
7. Redraw the menu using IMENUCTL_Redraw. 
8. Send events to the menu control using IMENUCTL_HandleEvent. 
9. When you're done with the menu, release it using IMENUCTL_Release or 
ICONTROL_Release. 
You first saw a menu control in action in the previous chapter in the SlideShow 
application. Let's take another look at it now. The application creates the menu 
when the application first launches in the application's SlideShow_Init function, 
called within AEEClsCreatelnstance (see Listing 5-2). 

Interacting with th$ User 
Listing 5-2. Application Initialization 
1: 1** 
2: * Initializes application structure, creating 
3: * necessary UI components. 
4: * @param CAppPtr pThis: pointer to application structure 
5: * @return AEE_SUCCESS on success, or else EFAIlED 
6: 
*1 
7: static int SlideShow_Init( CAppPtr pThis ) 
8: { 
9: 
int result = AEE_SUCCESS; 
10: 
AEEDevicelnfo dm; 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: } 
if (pThis->a.m_pIDisplay && pThis->a.m_pIShell) 
{ 
} 
II Get the screen's bounds, color support 
II and font info here â¢â¢â¢ 
I! 
else 
{ 
result = EFAIlED; 
} 
if ( result == AEE_SUCCESS ) 
result = 
ISHELL_Createlnstance( pThis->a.m_pIShell, 
AEEClSID_MENUCTl, 
(void **)&pThis->m-pIMenu ); 
return result; 
For brevity, I've removed the statements that were inIines 13-16 to determine 
the device's display capabilities. lines 25-27 create a menu, storing it in the 
SlideShowapplication's application pointer slot m _pIMenu. 
121 

ChapterS 
122 
Once you create the menu, you initialize it by clearing the display, setting its 
bounds, and adding its menu items: 
1: II Clear the display 
2: IDISPlAY_ClearScreen( pThis->a.m_pIDisplay )j 
3: II Reset the menu 
4: IMENUCTl_Reset( pThis->m_pIMenu )j 
5: II Set the menu's bounds 
6: IMENUCTl_SetRect( pThis->m_pIMenu, &pThis->m_rc )j 
7: II Populate the menu 
8: FillMenu( pThis )j 
FillMenu builds the menu using the names of BREW Archive (BAR) files in the 
application's directory, as shown in listing 5-3. 
Listing 5-3. Building the Menu 
1: 1* 
2: * Populates the menu with the list of slide shows. 
3: * @param CAppptr pThis: the application 
4: * @return nothing 
5: 
*1 
6: static void FillMenu( CAppPtr pThis ) 
7: { 
8: 
IFileMgr *pIFileMgrj 
9: 
FileInfo infoj 
10: 
AECHAR wszBuff[ MAX_FILE_NAME + 1 ]j 
11: 
uint16 nItem = 1j 
12: 
int result; 
13: 
14: 
II Setup the file manager instance 
15: 
result = ISHEll_CreateInstance( pThis->a.m_pIShell, 
16: 
AEECLSIDJILEMGR, 
17: 
(void **)&pIFileMgr )j 
18: 
19: 
II Enumerate the list of .bar files 
20: 
if ( pIFileMgr ) 
21: 
{ 
22: 
II Begin enumeration 
23: 
if ( SUCCESS == IFIlEMGR_Enumlnit( pIFileMgr, "", FALSE) ) 
24: 
{ 
25: 
while ( IFIlEMGR_EnumNext( pIFileMgr, &info ) ) 
26: 
{ 
27: 
II We're interested in files that end in .bar 

Interacting with the User 
28: 
if (STRENDS( ".bar", info.szName) ) 
29: 
{ 
30: 
II Create our own name for the menu item 
31: 
info.szName[ STRlEN( info.szName ) - 4 ] = '\000'; 
32: 
33: 
II convert to a wide string 
34: 
STR_TO_WSTR( info.szName, wszBuff, 2 * MAX_FILE_NAME + 2 ); 
35: 
36: 
II Add it to the menu 
37: 
IMENUCTl_AddItem( pThis->m_pIMenu, 
38: 
NUll, II Resource file for item 
39: 
0, 
II Don't use the resource file 
40: 
nItem++, 
41: 
wszBuff, 
42: 
(uint32)0); II Item data 
43: 
} II add file name to menu 
44: 
} II file name enumeration 
45: 
} II enumeration guard 
46: 
47: 
II Clean up 
48: 
IFIlEMGR_Release( pIFileMgr ); 
49: 
} II pIFileMgr guard 
50: 
51: 
if ( nItem == 1 ) 
52: 
{ 
53: 
II Menu addition failed. 
54: 
II But we always have our .bar, so add it manually. 
55: 
STRTOWSTR( "SlideShow", wszBuff, MAX_FILE_NAME + 1 ); 
56: 
57: 
II Add it to the menu 
58: 
IMENUCTl_AddItem( pThis->m-pIMenu, 
59: 
NULL, II Resource file for item 
60: 
0, 
II Don't use the resource file 
61: 
nItem++, 
62: 
wszBuff, 
63: 
(uint32)0); II Item data 
64: 
65: 
} II Add what is always there 
66: } 
Although a lengthy routine, the logic behind FillMenu is simple: For each file 
(lines 1-25) ending in the characters .bar, line 28 uses the name of the file. As with 
most other QUALCOMM BREW interfaces, the IMENUCTl interface looks for char-
acter strings in multibyte format. Thus, line 34 converts the name of the menu 
123 

ChapterS 
124 
item to add from a C-style null-terminated character string to a QUALCOMM 
BREW multibyte null-terminated AECHAR string using STR _TO _ WSTR. lines 37-42 add 
the menu item to the menu using IMENUCTL_AddItem. 
IMENUCTL_AddItem lets you add menu items to a menu either as multibyte 
strings from the heap or as resource strings from a resource file, such as the appli-
cation's resource file. In either case, the menu control copies the strings, taking 
responsibility for deleting the contents when the application releases menu 
control structures using IMENUCTL_Reset or releases them using IMENUCTL_Release. 
This method takes a reference to the menu control to accept the new item along 
with the item number and takes information about the item to add. When adding 
a resource item to a menu, the second and third. arguments should be the name of 
the resource file and the resource ID of the item, respectively. When adding a 
string, the second and third arguments are zero, and you pass a pointer to the 
multibyte string as the fifth argument. Regardless of which way you add an 
item, you also provide a unique integer that the event handler will receive as 
an argument to the EVT _COMMAND message when you select the event as the fourth 
argument, and you can pass a long integer or pointer to be kept with the menu 
item as the last argument. 
The event handler for your menu control is straightforward, at least until it 
needs to determine what item you selected from the menu. Menu controls signal 
menu selections using the EVT _COMMAND event, passing the selected item's identifier 
(which you set when you called one of the AddItemAPIs) as the wParam to your event 
handler (see Listing 5-4). 
Listing 5-4. Handling a Menu Selection 
1: 1* 
2: * In HandleEvent() 
3: 
*1 
4: 
result: IMENUCTL_HandleEvent( pThis->m_pIMenu, 
5: 
eCode, 
6: 
wParam, 
7: 
dwParam ) j 
8: 
if ( !result ) switch ( eCode ) 
9: 
{ 
10: 
case EVT_COMMAND: 
11: 
II Find the filename of the selected resource 
12: 
IMENUCTL_GetItem( pThis->m_pIMenu, 
13: 
wParam, 
14: 
&menuItem )j 
15: 
WSTR_TO_STR( menuItem.pText, pThis->m_szFile, MAX_FILE_NAME + l)j 
16: 
STRCAT( pThis->m_szFile, ".bar" )j 
17: ... /I HandleEvent continues ... 

Interacting with the User 
The HandleEvent function first shares incoming events with the menu control 
so that it can process key events from the navigation pad and the Select key. 
Because menu controls can also have images-in fact, even ordinary textual 
menus can include images as icons-there's also an IMENUCTL_AddItemEx function. 
Unlike IMENUCTL _ Add Item, which takes a veritable horde of arguments, 
IMENUCTL_AddItemEx takes a pointer to a structure describing what you want to add 
to the menu. This structure, a CtlAddItem structure, looks like this: 
1: typedef struct _CtlAddltem 
2: { 
3: 
const AECHAR *pTextj 
4: 
IImage 
*plmagej 
5: 
const char 
*pszReslmagej 
6: 
const char 
*pszResTextj 
7: 
uint16 
wTextj 
8: 
uint16 
wFontj 
9: 
uint16 
wlmagej 
10: 
uint16 
wItemIDj 
11: 
uint32 
dwOataj 
12: } CtlAddItemj 
When calling IMENUCTL_AddItemEx, you can fill any or some of the fields in this 
structure. If the pText slot is valid, the contents are added to the menu's text label. 
If not, the method uses the resource indicated by wText in the resource file you 
specify in pszResText. If pImage is valid, the control will increment the image's ref-
erence count (so you can release your reference to the image using IIMAGE _Release) 
and add the image to the menu item. If you'd rather use an image from a resource 
file, that's okay, too-simply place the ID of the image in the wI mage slot and the 
name of the resource file in pszResImage. For example, the following snippet ini-
tializes a menu item with an icon and a string from the application's resource file: 
1: 
CAppPtr pThis = (CAppptr)pj 
2: 
CtlAddltem addltemlnfo = { 0 }j 
3: 
int itemID = OJ 
4: 
5: 
6: 
II Build a menu of choices for controls. 
7: 
addltemlnfo.wltemID = itemID++j 
8: 
addltemlnfo.dwOata = (uint32)AS_StaticHandleEventj 
9: 
addltemlnfo.pszResText = APP_RES_FILEj 
10: 
addltemlnfo.pszReslmage = APP_RES_FILEj 
11: 
addltemlnfo.wText = IDS_STATICj 
12: 
addltemlnfo.wlmage = IDI_STATICj 
125 

ChapterS 
126 
13: 
IMENUCTL_AddItemEx( (IMenuCt1 *) 
14: 
pThis->m_app.m_apContro1[ Ctl_NavMenu ], 
15: 
&addItemInfo ); 
As you might imagine, using IMENU _ AddItemEx is really just a matter of initial-
izing a CtlAddItem structure with the description of the item and then making 
the API call. Here, line 7 sets the menu item's specific 10, and then the code 
uses the menu item's double-word storage to hold a pointer to the next state's 
event handler. The icon and text data are both in the application's resource file, so 
lines 9-10 set the pszResText and pszResImage slots to the pointer containing the 
application resource filename (defined by the QUALCOMM BREW Resource 
Builder in the _res.h file). Lines 11 and 12 set the wText and wImage slots to contain 
the resource 10 of the text and image for the item, respectively. Finally, lines 13-15 
add the menu item to the menu control. (Note that because the m_apControl array 
is an array of IControl pointers, you must cast the pointer to an IMenuCtl pointer to 
avoid compile-time warnings on line 13.) 
A special kind of menu is the soft key menu, discussed in the next section. 
Using the ITextCtl Control 
Your application accepts input using the IT extCtl control, which lets you enter text 
using multitap or OEM-provided text input methods, such as Motorola's iTap or 
Tegic's T9. You have control over the text control being single-line or multiline, 
the title of the control, and the input method the control provides to the user. 
Figure 5-6 shows two ITextCtl instances: one spanning the entire screen and 
another with an accompanying soft key menu. 
Message? 
f-iello world. 
Messaqe? 
II-Iello world. 
1 
OK 
â¢ 
Figure 5-6. A plain-text control (left) and a text control with a soft key menu (right) 
Using a text control is just like using any of the other controls: You create it, 
set the options, set its size, and show it. Of course, you'll also want to set its title 
and the text it should contain when it's first shown (see Listing 5-5). 

Interacting with the User 
Listing 5-5. Using ITextCtl 
1: 
CAppPtr pThis = {CAppptr)pj 
2: 
AECHAR pszTitle[32]j 
3: 
AECHAR pszText[256]j 
4: 
ITextCtl *pITextCtl = 
5: 
(ITextCtl *)pThis->m_app.m_apControl[ Ctl_Textlnput ]j 
6: 
7: 
II Clear the display 
8: 
IDISPLAY_ClearScreen{ GetDisplay{ pThis ) )j 
9: 
10: 
II Set the control's options 
11: 
ITEXT_SetProperties{ pITextCtl, 
12: 
TP_MULTILINE I TP_FRAME I TP_T9_MOOE )j 
13: 
14: 
II Set the control's contents 
15: 
STR_TO_WSTR{ "Message?", pszTitle, sizeof{ pszTitle ) )j 
16: 
STR_TO_WSTR{ "Hello world.", pszText, sizeof{ pszText ) )j 
17: 
18: 
ITEXTCTL_SetTitle{ pITextCtl, NULL, 0, pszTitle )j 
19: 
ITEXTCTL_SetText{ pITextCtl, pszText, -1 )j 
20: 
21: 
II Size the control. 
22: 
ITEXT_SetRect{ pITextCtl, &pThis->m_rc )j 
23: 
ITEXT_SetActive{ pITextCtl, TRUE )j 
24: 
ITEXT_Redraw{ pITextCtl )j 
25: 
26: 
II Update the display 
27: 
IDISPLAY_Update{ GetDisplay( pThis ) )j 
28: 
29: 
return TRUEj 
By now, this should look familiar to the point of boring. Assuming that the text 
control instance has been stored in the Ctl_TextInput slot of the control array 
(lines 4-5), the code begins by clearing the display (line 8) and selecting a 
framed multiline input line that will use the OEM text input method by default 
(lines 11-12). 
Lines 14-19 set the text control's title and default input text using compile-
time strings. Although not portable, this serves to show how you can convert a 
standard C string to a multibyte string (line 15) for use with the text control's title. 
You also have the choice of using a resource file entry by passing the name of the 
file as the second argument to ITEXTCTL_SetTitle. If you do this, be sure to pass 
127 

ChapterS 
128 
the ID of the desired text resource as the third item and pass NUll instead of a 
multibyte zero-terminated string buffer. 
Unlike the title, you must provide default text using ITEXTCTl_SetText in its 
own buffer, but the control will copy the contents of the buffer rather than keep a 
reference to it. The final argument to ITEXTCTl_SetText is simply the number of 
characters in the string you provide that should be used to seed the text control's 
default input text. If you want to use all of the text in the buffer, simply pass -1 (or 
use the WSTRlEN function to compute the length of the string in the buffer, which is 
what ITEXTCTl_ SetText probably does anyway). 
lines 21-24 perform the usual control initialization: They set the size of 
the control, activate the control so it'll accept events, and redraw the control 
on the display. There's nothing special about using the ITextCtl methods here 
instead of the more generic IControl interfaces. Because you need explicit ITextCtl 
pointers to set the title and text, it's easier to use the ITextCtl interfaces every-
where and save time and space casting. 
When using ITextCtl, your event handler must pass all incoming events to the 
control using ITEXTCTl_ HandleEvent before processing any events. When you finish 
entering text, you press the Select key, so your application will receive an EVT _KEY 
with a key code of AVK_SElECT to indicate that text input is complete (see 
listing 5-6). 
Listing 5-6. Handling Events with ITextCtl 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
boolean result = FALSE; 
char pszText[512]; 
AECHAR *psz; 
ITextCtl *pITextCtl = 
(ITextCtl *)pThis->m_apControl[ Ctl_Textlnput ]; 
result = ITEXTCTl_HandleEvent( pITextCtl, 
eCode, wParam, dwParam ); 
if ( !result && 
{ 
eCode == EVT_KEY && 
ITEXTCTL_IsActive( pITextCtl ) 
if ( wParam == AVK_SElECT ) 
{ 
psz = ITEXTCTL_GetTextPtr{ pITextCtl ); 
if ( psz ) 
{ 
WSTR_TO_STR{ psz, pszText, sizeof{ pszText ) ); 

Interacting with the User 
21: 
DSGPRINTF (" entered %s", pszText ); 
22: 
result = TRUE; 
23: 
} 
24: 
} 
25 : 
else if ( wParam == AVK_CLR ) 
26: 
{ 
27: 
II The user cancelled text input by pressing CLR 
28: 
DSGPRINTF("hit CLR" ); 
29: 
result = TRUE; 
30: 
} 
31: 
/I Handle other events â¢â¢â¢ 
lines 7-8 share all incoming events with the text control. The text control con-
sumes keystroke events (including when you press Clear to rub out the last letter 
you typed). You'll want to watch for two specific keystrokes that the text control 
doesn't handle on your behalf: AVK_SELECT, indicating that text input is complete, 
and AVK _ CLR, indicating that you pressed Clear in the text field when there's no text 
to rub out, which your application should treat as a request to navigate to the pre-
vious screen. 
CAUTION Some handsets may handle AVK _ CLR in a text control differ-
ently, so this is an area where you should be sure to test your application 
on the actual hardware as you develop. 
lines 11-30 do exactly this, first confirming that the text control did nothing 
with the event (line 11), that the event code is a keystroke (EVT_KEY, line 12), and 
that the text control is active (line 13). 
CAUTION Don't mistake the EVT _KEY event for the EVT _KEY ]RESS, 
EVT _KEY_RELEASE, or EVT _KEY_HELD events, which correspond to the key 
moving downward, the key moving upward, and the user holding their 
key down, respectively. 
Next, the code simply checks to see if the unhandled keystroke is from the 
Select key (line 15) or the Clear key (line 25), and it prints either the input text or a 
diagnostic message indicating that you cancelled text input. In a real application, 
129 

ChapterS 
130 
these would be cues to update an application's state variables and transition to a 
new state. 
Things are a little more complex-but a lot more interesting-when you 
combine a soft key menu with an input text line. By doing so, you can create all 
kinds of custom user interfaces, including simply spicing up the look of text entry, 
adding menu items to select specific input methods, using quick-text to save 
typing, and so forth. The general steps for combining a text control with an input 
line are as follows: 
1. Create an instance of ITextCtl using its ID AEECLSID _ TEXTCTL and an 
instance of a soft key IMenuCtl using the ID AEECLSID _ SOFTKEYCTL. 
2. Set the text control's title and default text. 
3. Set the text control's properties. 
4. Add menu items to the soft key menu using IMENUCTL _ Addltem or 
IMENUCTL_AddltemEx. 
5. Size the text control to fill the screen, leaving room for the menu control, 
which will appear directly under the text control at the bottom of the 
screen. 
6. Attach the soft key menu control to the text control using 
ITEXTCTL_SetSoftKeyMenu. 
7. Activate and redraw the text control. 
By doing this, your text control will be adorned with an accompanying soft 
key menu, and the soft key menu will include both the items you add and the 
OEM -specific menu items to control the input method (such as picking multitap 
or Tegic's T9 text input). Listing 5-7 shows the code. 
Listing 5-7. Adorning an ITextCtl Control with a Soft Key Menu 
1: 
CAppptr pThis = (CAppPtr)p; 
2: 
AECHAR pszTitle[32]; 
3: 
AECHAR pszText[256]; 
4: 
AEERect rc; 
5: 
CtlAddltem addltemlnfo = { 0 }; 
6: 
ITextCtl *pITextCtl = 
7: 
(ITextCtl *)pThis->m_app.m_apControl[ Ctl_Textlnput ]; 
8: 
IMenuCtl *pIMenuCtl = 

9: 
(lMenuCtl *)pThis->m_app.m_apControl[ Ctl_SoftKeyMenu ]; 
10: 
11: 
II Clear the display 
12: 
lDISPLAY_ClearScreen( GetDisplay( pThis ) ); 
13: 
14: 
II Set the text control's options 
15: 
ITEXTCTL_SetProperties( pITextCtl, 
16: 
TP_MULTlLINE I TP_FRAME I TP_T9_MODE); 
17: 
18: 
II Set the text control's contents 
19: 
STR_TO_WSTR( "Message?", pszTitle, sizeof( pszTitle ) ); 
20: 
STR_TO_WSTR( "Hello world.", pszText, sizeof( pszText ) ); 
21: 
22: 
ITEXTCTL_SetTitle( pITextCtl, NULL, 0, pszTitle ); 
23: 
ITEXTCTL_SetText( pITextCtl, pszText, -1 ); 
24: 
25: 
II Set the menu control's contents 
26: 
addltemlnfo.wltemID = 0; 
27: 
addltemlnfo.dwData = 0; 
28: 
addltemlnfo.pszResText = APP_RES_FILE; 
29: 
addltemlnfo.pszReslmage = APP_RES_FILE; 
30: 
addltemlnfo.wText = IDS_OK; 
31: 
addltemlnfo.wlmage = lDl_OK; 
32: 
IMENUCTL_AddltemEx( pIMenuCtl, &addltemlnfo ); 
33: 
34: 
addltemlnfo.wltemlD = 1; 
35: 
addltemlnfo.dwData = OJ 
36: 
addltemlnfo.pszResText = APP_RES_FlLEj 
37: 
addltemlnfo.pszReslmage = NULLj 
38: 
addltemlnfo.wText = IDS_CANCELj 
39: 
addltemlnfo.wlmage = lDI_CANCEL; 
40: 
lMENUCTL_AddltemEx( plMenuCtl, &addltemlnfo ); 
41: 
42: 
II Size the control. 
43: 
IMENUCTL_GetRect( pIMenuCtl, arc ); 
44: 
SETAEERECT( arc, 0, 0, pThis->m_cx, pThis->m_cy - rc.dy ); 
45: 
ITEXTCTL_SetRect( pITextCtl, arc ); 
46: 
47: 
II Attach the soft key menu to the control 
48: 
lTEXTCTL_SetSoftKeyMenu( pITextCtl, pIMenuCtl); 
49: 
50: 
ITEXTCTL_SetActive( plTextCtl, TRUE ); 
51: 
52: 
lTEXTCTL_Redraw( plTextCtl ); 
Interacting with the User 
131 

ChapterS 
132 
53: 
54: 
II Update the display 
55: 
IDISPLAY_Update( GetDisplay( pThis ) ); 
Things progress as you'd expect until lines 26-40, which use the 
IMENUCTL _ AddltemEx method to initialize two menu items: one to confirm text input 
and one to cancel text input. Each of these includes an icon and a text label. 
TIP Always be sure that a soft key menu accompanying an input line 
includes a way to accept the text you enter because the Select key moves 
focus from the text control to the soft key menu. Without a choice on the 
menu to accept input, you can't move to the next screen in your applica-
tion because the Select key moves between the input line and the soft key 
menu. 
Lines 42-45 resize the text control to leave room for the soft key menu. Finally, 
line 48 ties the soft key menu to the text control, and line 50 activates the text 
control. 
When using a soft key menu with a text control, you need to share events with 
both controls, as in listing 5-8. 
Listing 5-8. Sharing Events with an IMenuCtl Soft Key Menu and an ITextCtl 
1: 
ITextCtl *pITextCtl = 
2: 
(ITextCtl *)pThis->m_app.m_apControl[ Ctl_Textlnput ]; 
3: 
IMenuCtl *pIMenuCtl = 
4: 
(IMenuCtl *)pThis->m_app.m_apControl[ Ctl_SoftKeyMenu ]; 
5: 
6: 
result = ITEXTCTL_HandleEvent( pITextCtl, 
7: 
eCode, wParam, dwParam ); 
8: 
if (!result) IMENUCTL_HandleEvent( pIMenuCtl, 
9: 
eCode, wParam, dwParam ); 
10: 
11: 
II Key up in text control with soft key menu 
12: 
II activates text control 
13: 
if ( !result && 
14: 
eCode == EVT_KEY && wParam == AVK_UP && 
15: 
!ITEXTCTL_IsActive( pITextCtl ) && 
16: 
IMENUCTL_IsActive( pIMenuCtl ) ) 
17: 
{ 
18: 
IMENUCTL_SetActive( pIMenuCtl, FALSE ); 

Interacting with the User 
19: 
ITEXTCTL_SetActive( pITextCtl, TRUE ); 
20: 
result = TRUE; 
21: 
} 
22: 
23: 
II Key up in text control with soft key menu 
24: 
II activates text control 
25: 
if ( Iresult && 
26: 
eCode == EVT_KEY && wParam == AVK_DDWN && 
27: 
ITEXTCTL_IsActive( pITextCtl ) && 
28: 
!IMENUCTL_IsActive( pIMenuCtl ) ) 
29: 
{ 
30: 
IMENUCTL_SetActive( pIMenuCtl, TRUE ); 
31: 
ITEXTCTL_SetActive( pITextCtl, FALSE ); 
32: 
result = TRUE; 
33: 
} 
34: 
35: 
II Menu selection navigates to new state 
36: 
if ( ! result && eCode == EVT _COMMAND ) 
37: 
{ 
38: 
switch( wParam ) 
39: 
{ 
40: 
II wParam contains the id of the item selected 
41: 
} 
42: 
} 
43: 
44: 
II Handle other events â¢â¢â¢ 
The event handler is pretty simple, but handling the up and down keystrokes 
between the text control and the menu is a little tricky, so let's take a closer look. 
After giving both controls an opportunity to handle the event (lines 6-9), the event 
handler checks the incoming event to see if it's a keystroke and, if so, checks 
which item has focus. Then it changes focus accordingly (lines 11-33). For 
example, lines 13-16 test the incoming event to see if it hasn't already been 
handled (line 13), if it's an up arrow keystroke (line 14), and if the menu currently 
has focus (lines 15-16). It assigns focus to the text control alone and marks the 
event as handled (lines 18-20). 
133 

ChapterS 
134 
CAUTION 
QUALCOMM BREW doesn't support the notion of exclusive 
focus. That is, you can include multiple calls to ICONTROL _ SetActi ve to 
activate several controls. In almost all cases, this works but can result in 
user interface bugs in your application. Consequently, it's best to clear 
the active flags of other controls when activating a specific control. 
Using Other Controls 
Most of the time, you'll work with the menu control, soft key menu control, static 
control, and text control. But there are several other controls, as shown in 
Table 5-3. 
Table 5-3. QUALCOMM BREW Control Interface and Class ID 
Summary 
CONTROL PURPOSE 
INTERFACE NAME 
CLASS ID 
NOTES 
Static item 
display 
Clock 
IStatic 
ITimeCtl 
Countdown timer ITimeCtl 
Stopwatch timer ITimeCtl 
Date entry 
Day of month 
entry 
IDateCtl 
IDateCtl 
AEECLASSID_STATIC 
AEECLSID_CLOCKCTL 
Displays static text or 
image 
Displays time with 
A.M.lP.M. indication 
AEECLSID COUNTDOWNCTL 
Displays countdown 
clock in hours, 
minutes, and 
seconds 
AEECLSID STOPWATCHCTL 
Displays 
incrementing clock 
in hours, minutes, 
and seconds 
AEECLSID _DATECTL 
Permits input of 
month, day, and year 
AEECLSID _DATEPICKCTL 
Permits input of 
day of month or 
selection of month 
on monthly calendar 

Interacting with the User 
Table 5-3. QUALCOMM BREW Control Interface and Class ID 
Summary (Continued) 
CONTROL PURPOSE 
INTERFACE NAME 
CLASS ID 
NOTES 
Image viewer 
IImageCtl 
AEECLSID lMAGECTL 
Lets user scroll 
around an image 
larger than the 
viewable rectangle 
Menu 
IMenuCtl 
AEECLSID_MENUCTL 
Displays one menu 
item per screen row 
and permits selection 
and scrolling 
List 
IMenuCtl 
AEECLSID_LISTCTL 
Displays current 
selection of the menu 
item on a single line 
and permits selection 
and scrolling 
Soft key menu 
IMenuCtl 
AEECLSID_SOFTKEYCTL 
Displays soft key 
menu items along the 
bottom of the screen 
and permits selection 
and left/right 
scrolling 
Icon menu 
IMenuCtl 
AEECLSID_ICONVIEWCTL 
Displays a table of 
bitmap icons and 
permits selection of 
an item with 
accompanying name 
display 
Text input 
ITextCtl 
AEECLSID_TEXTCTL 
Permits single-line or 
multiline text input 
HTML display 
IHTMLViewer 
AEECLSID _ HTML 
Permits display of 
simpleHTML 
Most of these controls use the EVT _COMMAND event to notify your application 
when you finish entering data. Some controls-notably those that implement the 
ITimeCtl or the IMenuCtl interface-also send your application an EVT_CTL_TAB 
135 

ChapterS 
136 
event when the user changes from one part of the control (such as a menu item) to 
another part of the same control. 
One control, the IHTMLViewer control, also uses a notification function that it 
invokes in response to specific actions, such as when you select a link. This 
function takes a pointer to a structure that describes the reason for the call, along 
with a pointer you can use to pass additional data to the function. Chapter 6, 
"Streaming Data," shows you how to use the IHTMLViewer control. 
Integrating Controls with Your Application Framework 
Although managing a group of controls isn't hard, doing so in a uniform way across 
a larger application requires you to be organized because it's easy to create con-
trols and forget to free them or to construct event handlers that don't pass events 
to controls in the right sequence. 
If you're coding an application from scratch, you can do the following to make 
your life a little easier: 
Preallocate all of your controls and free them only when your application 
exits. limiting where you allocate and free items makes it easier to find 
sources ofleaks and simplifies your error handling code when your appli-
cation can't allocate a resource. 
Consolidate your event handling by control. If needed, break your event 
handler into multiple functions. In a large application, your event handler 
is likely to be one of the most complex sections of code (outside of 
proprietary algorithms such as image manipulation or game artificial 
intelligence), and by keeping it simple, it's easier to debug. 
Keep your user interface simple. Keeping, at most, one input item active 
at a time (two in the case of a text control with a soft key menu) makes it 
easy for you to track which control should receive events at different 
points in your application. Not only that, but it'll make your application 
easier to use for your customers! 
A better idea, as discussed in general terms in the previous chapter, is to build 
a framework that does the bookkeeping for your application behind the scenes so 
you can worry about getting the rest of your program done. Because QUALCOMM 
BREW applications generally have several points in common-such as tracking 
state, managing preferences, and handling events-if you can encapsulate these 
features in modules of tried-and-true code, you won't have to reinvent the wheel 
each time you start to write a new application. 

Interacting with the User 
Let's take a closer look at how you can add support for controls to the 
framework presented in the previous chapter. 
Simplifying the State Machine Structure 
The previous chapter's framework defined a state as the following structure: 
1: II State function type declarations 
2: typedef void (PFNSTATEENTRY)( void *pApp, EStateChange change ); 
3: typedef void 
(PFNSTATEEXIT)( void *pApp, EStateChange change ); 
4: typedef boolean (PFNSTATEEVENT)( void *pApp, 
5: 
AEEEvent eCode, 
6: 
uint16 wParam, uint32 dwParam); 
7: typedef struct _CState 
8: { 
9: struct _CState *m_pPrevState; 
10: 
PFNSTATEENTRY *m_pfEntry; 
11: 
PFNSTATEEXIT 
*m-pfExit; 
12: 
PFNSTATEEVENT *m_pfEvent; 
13: void 
*m_pData; 
14: } CState, *CStatePtr; 
The CState structure is simple, dividing a state into three functions: one 
responsible for entry, one responsible for exit, and one responsible for handling 
events while the state is active. This is simple and easy to maintain, but it has the 
detraction that to refer to a state, you need to refer to it as a tuple of function 
pointers: pfnEntry, pfnExit, and pfnEvent. If you're constructing applications with 
many states, it can be tedious to keep track of all the pointers. 
It would be better to use only one state function to uniquely identify a state. 
Fortunately, there's an easy way to do this: You can use some of the QUALCOMM 
BREW events that are pertinent only to the application to capture the purpose of 
the entry and exit functions. Recall that the framework calls a state's entry function 
when a state is entered or the application is resumed, and recall that the 
framework calls the state's exit function when the state is exited or the application 
is suspended. You can do the same by using events to indicate these conditions to 
the state's event handler. 
You could either define new event codes or use existing QUALCOMM 
BREW events and overload them so that the events have their QUALCOMM BREW 
meaning when the system delivers them to the framework application handler. 
You can then use them for another purpose for each state's event handler because 
137 

ChapterS 
138 
the state event handler doesn't normally see them. Intuitively, it makes sense to 
use existing events. Thus, I have four to use for this purpose: 
â¢ The EVT _ APP _START event, indicating that the application-or a state-is 
being started. 
â¢ The EVT _ APP _STOP event, indicating that the application-or a state-is being 
exited. 
â¢ The EVT _ APP _RESUME event, indicating that the system has resumed your 
application's execution. 
â¢ The EVT _ APP _SUSPEND event, indicating that the system has suspended your 
application's execution. 
By extending the state machine's event handler to handle these four events 
(calling separate functions if needed), you can simplify the notion of a state to a 
simple linked list containing two pointers: one to a region holding the state's state 
variable and the other to the state's function pointer (see listing 5-9). 
Listing 5-9. Managing the List o/States 
1: 1** 
2: * @name _Node 
3: * @memo Singly linked list. 
4: * @doc Provides the implementation for a simple 
5: * singly-linked list with weak typing. 
6: * The head of the list is denoted with the 
7: * data fields set to NULL. 
8: 
*1 
9: typedef struct _Node 
10: { 
11: 
III Next node 
12: 
struct _Node *m_pNext; 
13: 
III Pointer to data for this node 
14: 
void *m_pData; 
15: 
III Pointer to any additional data for this node. 
16: 
void *m_pMetaData; 
17: }; 
18: 
19: 1** 
20: * @name NodeLinkNext 
21: * @memo Inserts one node after another. 
22: * @doc Inserts new node n2 after existing 

23: * node n1-
24: * Returns the second node. 
25: 
*1 
26: #define NodelinkNext( nl, n2 ) \ 
27: 
{n2->m_pNext = n1->m-pNext; n1->m-pNext = n2; } 
28: 
29: 1** 
30: * @name NodeUnlinkNext 
31: * @memo Unlinks the next node from the list. 
32: * @doc Unlinks the next node after the indicated node. 
33: * Frees the unlinked node. 
34: *1 
35: #define NodeUnlinkNext( nl ) \ 
36: 
{struct _Node *_p; -p = nl->m_pNext; \ 
37: 
nl->m-pNext = -p->m-pNext; FREE( _p ); } 
38: 
39: 1** 
40: * @name NodeNext 
41: * @memo Returns the next node after the current node. 
42: * @doc Returns the next node after the current node. 
43: *1 
44: #define NodeNext( n ) \ 
45: 
(n->m-pNext) 
46: 
47: II Returning true indicates event was handled. 
48: typedef boolean (PFNSTATEEVENT)( void *pApp, 
49: 
AEEEvent eCode, 
50: 
uint16 wParam, uint32 dwParam); 
51: typedef struct _Node CState; 
52: typedef struct _Node *CStatePtr; 
53: 
54: 1** 
55: * @name State_GetStateData 
56: * @memo Returns the indicated state's data. 
57: * @doc Returns the state data for the indicated state. 
58: *1 
59: #define State_GetStateData( s ) ( s->m_pData ) 
60: 
61: 1** 
62: * @name State_SetStateData 
63: * @memo Sets the indicated state's data. 
64: * @doc Assigns the state data for the indicated state 
65: * to the given pointer. 
66: *1 
Interacting with the User 
139 

ChapterS 
140 
67: #define State_SetStateData( S, d ) ( (s)->m_pData = ( d ) ) 
68: 
69: 1** 
70: * @name State_GetStateEventHandler 
71: * @memo Returns the indicated state's event handler. 
72: * @doc Returns the state event handler 
73: * for the indicated state. 
74: 
*/ 
75: #define State_GetStateEventHandler( s ) \ 
76: 
Â«PFNSTATEEVENT *)Â«s)->m-pMetaData) ) 
77: 
78: 1** 
79: * @name State_SetStateEventHandler 
80: * @memo Sets the indicated state's event handler 
81: * @doc Assigns the state event handler for the 
82: * indicated state to the given pointer. 
83: 
*/ 
84: #define State_SetStateEventHandler( S, d ) \ 
85: 
Â«s)->m_pMetaData = d ) 
Most of this code is bookkeeping for the link list, and the remaining lines are 
macros to implement the state machine interface on top of the linked list imple-
mentation. lines 1-17 define the linked list node; each node has a pointer to the 
next node (line 12), along with two slots for data: one pointing to the node's data 
and the other pointing to metadata about the node. This approach simplifies 
memory management pertaining to states, rather than allocating a structure that 
contains a state's data and event handler, and links that to a single slot in the node. 
Lines 19-45 provide simple macros to link an element into the list 
(lines 20-27), unlink the last node of a list (lines 29-37), and return the next 
node of a list given a specific node (lines 39-45). All of these rely on the notion 
that the head of a list is a placeholder and that subsequent nodes are linked using 
only the m -"Next slot of the _Node structure. There's no special reason for making 
these macros other than simplicity: It's easier to fix. a logic error in how the linked 
list is managed by fixing one macro instead of fumbling through an entire module. 
For a newcomer to the code, it's also easier to understand a line like this: 
pNewNode = NodeNext( pCurrentNode ); 

Interacting with the User 
instead of the equally functional but slightly more cryptic line: 
pNewNode = p(urrentNode->m_pNextj 
In a similar vein, the framework has macros that wrap the notion of the _Node 
structure as a (State structure, beginning with the type definitions on lines 47-52. 
After defining the state event handler function type on lines 48-50, the code 
defines a (State and a (StatePtr to be a struct _Node and a struct _Node pointer, 
respectively. Doing this hides the implementation of a state from its users, as do 
the definitions in the remainder of the listing, which simply provide accessors and 
mutators for a state's data (lines 54-67) and state event handling (lines 69-85). 
With these changes to the notion of a state structure, there are small changes 
to the implementation of State_Push and State_Pop. The key change is for state 
changes to invoke the state's single function rather than calling different functions 
depending on whether the state change is an entry or an exit. Because a state 
function might want to know the reason for the state change, the state change 
functions include a cause code as the wParam to the event handler. 
The old implementation had an additional weakness. There was no way for a 
state to indicate that it couldn't be entered. For simple Graphical User Interface 
(Gll)-only applications, this isn't a major flaw, but for applications that involve 
data communication, this makes error handling difficult because if a state has an 
internal error, it must manage the error and shift to another state after it has been 
entered. To remedy this problem, the altered framework can now refuse a state 
transition and either force the application to remain in the same state or offer a 
state that it should enter instead. 
For example, consider a simple Web-based application that downloads 
financial data. The application might have four states: one to prompt for a ticker 
symbol, one to perform the network transaction and receive the ticker's funda-
mentals, one to display the results, and one to display an error if the handset 
doesn't have wireless service. Using the new framework, the network state can 
attempt to start the network transition as it's entered. If it fails, instead of entering, 
the network state can direct the framework to transition instead to the error 
display state. Moreover, from the error state, pressing Clear would bring you back 
to the ticker prompt state because the network state was never kept on the appli-
cation's state stack. 
To do this, a state function needs a way to communicate a state change failure 
and a desired new state to the framework. You can do this using the event handler's 
return code and the dwParam argument to the state handler, which points to a 
region that can contain a reference to a new state handler. If the state function 
returns TRUE to an EVT .fiPP _START event (indicating that the application should 
141 

ChapterS 
142 
enter that state), the state is placed on the state stack. Otherwise, the application's 
behavior depends on the following: 
â¢ If *dwParam is NULL, don't push or pop. Stay in the same state and return FALSE. 
â¢ If *dwParam is 1 NULL and a state is being pushed, push the state indicated by 
*dwParam instead. 
â¢ If *dwParam == State _ RewindState, pop the current state instead of pushing 
anything. 
â¢ If *dwParam is ! NULL and a state is being popped, pop the state and push 
*dwParam instead. 
â¢ If *dwParam == State _RewindState and a state was being popped, pop both 
the current state and the previous state. 
The constant State _ RewindState is merely defined as (uint32) ( -1), and it lets 
the application indicate that a state should be popped rather than providing a new 
state. 
Although somewhat more complicated to implement in State ]ush and 
State_Pop, the results are far more flexible because now a state can decide if the 
handset and application is in a position to perform a state's actions and can 
suggest another course of action in the event of an error. Because the changes are 
fairly simple-spanning only logic changes and order of operation within 
State_Push and State _Pop-refer to the sample code that accompanies this chapter 
if you're interested in the details. 
Initializing Controls and States 
All of the changes discussed so far make managing states easier and more flexible, 
but they don't directly pertain to managing controls. For the framework to provide 
a good basis for managing controls, it should do at least the following: 
â¢ Provide controls for the most common operations: menu selection and text 
entry. 
â¢ Give the application states an opportunity to initialize their controls when 
the application launches. 
â¢ Track the application's use of controls through all states. 

Interacting with the User 
â¢ Automatically free controls on application exit. 
â¢ Dispatch events to controls on behalf of each state. 
The changes to do all of this are far simpler than the refactoring of the state 
management itself. You've already seen the first change: modifications to the CApp 
structure that represents an application, as shown in Usting 5-10. 
Listing 5-1 o. Framework Extensions to Support Controls 
1: 1** 
2: * @name MAX_NUM_CONTROlS 
3: * @memo number of controls. 
4: * @doc This tells the framework how many controls 
5: * it must manage when handling events. 
6: 
*1 
7: #define MAX_NUM_CONTROlS ( 10 ) 
8: 
9: typedef struct _CStateApp 
10: { 
11: 
III The application context. 
12: 
III This must always be the first field. 
13: 
AEEApplet a; 
14: 
15: 
III The state stack 
16: 
CStatePtr 
m_pState; 
17: 
18: 
III The application preferences 
19: 
void 
20: 
21: 
22: 
23: 
24: 
25: 
III The application global data 
void 
*m_pAppData; 
III The pool of controls that the framework will manage. 
IControl 
*m_apControl[ MAX_NUM_CONTROlS ]; 
26: 
uint8 
m_nControl; 
27: } CStateApp, *CStateAppptr; 
28: 
29: 1** 
30: * @name CApp 
31: * @memo Application context. 
32: * @doc This stores the application's current 
33: * context and state information. 
34: *1 
143 

ChapterS 
144 
35: typedef struct _CApp 
36: { 
37: 
III Stores the application framework information. 
38: 
CStateApp 
m_appj 
39: 
40: 
III Screen width 
41: 
int 
m_cxj 
42: 
III Screen height 
43: 
int 
m_cyj 
44: 
III Color depth 
45: 
int 
m_colorDepthj 
46: 
III Font height in pixels 
47: 
int 
m_nFontHeightj 
48: 
III Does the screen support color? 
49: 
boolean 
m_bColorj 
50: 
III A rectangle with the drawable bounds 
51: 
AEERect 
m_rcj 
52: 
III True if the splash screen is showing. 
53: 
boolean 
m_bSplashingj 
54: } CApp, *CAppPtrj 
In addition to tracking the current state and the state stack, the framework 
now maintains a pool of controls, stored in the m _ apControl array of the CStateApp 
structure, and an associated count of initialized controls, m_nControl, declared 
on lines 25-26. (You can disregard the myAppPrefs and myAppData slots in 
this structure for now; you'll see what they're for in the next chapter.) The appli-
cation structure, CApp, no longer needs to store controls, as it did in the previous 
chapter's SlideShow application (lines 35-54). 
This uses a static array of controls-the m_apControl slot ofCStateApp-to store 
the application's controls rather than using a linked list, as for states, because 
unlike the depth of the state stack in the application, it's easy to predict how many 
controls a particular application will preallocate. If, for a specific application, it's 
better to let states create and destroy their own controls, then it's fairly simple to 
replace m _ apControl with a list of _Node structures or simply size the array to be the 
upper bound on the number of controls. 
The framework must allocate common controls on launch and provide access 
to these common controls. It does this using an enumeration of defined controls 
and the application's initialization function, as shown in Listing 5-11. 

Listing 5-11. Allocating Common Controls in the Control Pool 
1: 1** 
2: * @name EStateControl 
3: * @memo Delineates framework controls. 
4: 
*1 
5: typedef enum 
6: { 
7: 
III Navigation menu. 
8: 
Ctl_NavMenu = 0, 
9: 
III Soft Key menu. 
10: 
Ctl_SoftKeyMenu, 
11: 
III Text input control. 
12: 
Ctl_Textlnput, 
13: 
14: 
II End of the list â¢â¢â¢ don't mess with this one I 
15: 
Ctl_lastFrameworkControl 
16: } EStateControlj 
17: 
18: 
19: 1* 
20: * In the application's initialization function 
21: * invoked by AEEClsCreateInstance 
22: *1 
23: 
24: II Create the UI elements for the framework. 
25: pThis->m_app.m_nControl = MAX_NUM_CONTROlS; 
26: for ( i = OJ i < MAX_NUM_CONTROlSj i++ ) 
27: 
pThis->m_app.m_apControl[ i ] = NUllj 
28: 
29: ISHEll_CreateInstance( GetShell( pThis ), 
30: 
AEEClSID_MENUCTl, 
31: 
(void **)&pThis->m_app.m_apControl[ Ctl_NavMenu ])j 
32: 
33: ISHEll_CreateInstance( GetShell( pThis ), 
34: 
AEEClSID_SOFTKEYCTl, 
35: 
(void **)&pThis->m_app.m_apControl[ Ctl_SoftKeyMenu ])j 
36: ISHEll_CreateInstance( GetShell( pThis ), 
37: 
AEEClSID_TEXTCTl, 
38: 
(void **)&pThis->m_app.m_apControl[ Ctl_TextInput ])j 
39: 
40: result = pThis->m_app.m_apControl[ Ctl_NavMenu ] && 
41: 
pThis->m_app.m_apControl[ Ctl_SoftKeyMenu ] && 
42: 
pThis->m_app.m_apControl[ Ctl_TextInput ] ? 
Interacting with the User 
145 

ChapterS 
146 
43: 
SUCCESS : EFAIlED; 
44: 
45: if ( result == EFAIlED ) 
46: { 
47: 
for ( i = 0; i < MAX_NUM_CONTROlS; i++ ) 
{ 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
} 
if ( pThis->m_app.m_apControl[ i ] ) 
{ 
} 
ICONTROl_Release( pThis->m_app.m_apControl[ i ] ); 
pThis->m_app.m_apControl[ i ] = NUll; 
55: 
return result; 
56: } 
57: 
58: 1* 
59: * Reset all framework controls to begin with. 
60: 
*1 
61: for ( i = 0; i < Ctl_lastFrameworkControl; i++ ) 
62: 
ICONTROl_Reset( pThis->m_app.m_apControl[ i ] ); 
63: 
64: result = AS_Init( pThis ); 
65: 
66: 1* 
67: * In the application's termination function 
68: * invoked when the application exits 
69: 
*1 
70: II Release all controls 
71: for ( i = OJ i < MAX_NUM_CONTROl5; i++ ) 
72: { 
73: 
if ( pThis->m_app.m_apControl[ i ] ) 
74: 
{ 
75: 
ICONTROl_Release( pThis->m_app.m_apControl[ i ] ); 
76: 
pThis->m_app.m_apControl[ i ] = NUll; 
77: 
} 
78: } 
79: 
80: II Release any application state stuff 
81: AS_Free( pThis ); 

Interacting with the User 
The EStateControl enumeration on lines 1-16 provides you with an easy way 
to access a specific control in the application's m _ apControl array. (By the way, you 
could have just as easily used the C preprocessor to define macros to do the same 
thing.) 
The application's entry function-invoked by AEEClsCreatelnstance when the 
application launches-should preallocate each of these controls, just as the appli-
cation's termination function should destroy them when the application exits. 
lines 24-62, taken from the application's entry function, does just that. First, for 
housekeeping, on lines 26-27 all of the control instances are set to NULL so that the 
array will point to either valid controls or NULL. Next,lines 29-31 create the main 
menu control, and lines 33-38 create the soft key menu control and the associated 
text control. The conditional expression on lines 40-43 simply assures the appli-
cation that the three controls were created; it's a critical error if the application 
can't obtain the controls it needs to function. Thus, lines 45-56 clean up by 
destroying any allocated controls in the event of an error and return the error to 
AEEClsCreatelnstance. Assuming success,lines 61-62 reset all controls, ensuring 
that none of them will have focus or occupy screen space once they're created. 
(Although not required, this is a good idea, just like initializing newly created stack 
variables before you use them!) Finally, line 64 gives you an opportunity to create 
other controls or do anyone-time initialization during application launch. Just as 
you create state functions, you define the function AS _ Ini t in your code, which can 
create controls, allocate memory, and so on. 
Application termination is the inverse of application initialization: The 
destructor must release all allocated controls and then invoke your termination 
function to let you do any final cleanup. The loop on lines 71-78 simply walks the 
list of controls, releasing any control in the array and setting its slot to NULL to keep 
the remainder of the application from attempting to release it again, which would 
result in an application failure. Finally, on line 81, the framework calls your AS Jree 
function, which can undo any initialization it performed in AS_Init. 
Handling Events 
The last thing the framework must do is share incoming events with active con-
trols before sending them to application states. You've already seen bits and pieces 
of this code scattered around this chapter. The framework now has two event han-
dlers: one to pass events either to controls or the current state and the other to 
handle events sent to the framework controls. The event handler for the state 
framework itself is unchanged, save that it now invokes a separate function for 
passing events to each of the controls. Let's see how the controls receive their 
events (see Listing 5-12). 
147 

ChapterS 
Listing 5-12. Dispatching Events to Controls 
1: 1** 
2: * Handles incoming events sent to framework controls. 
3: * @param void *p: pointer to app 
4: * @param AEEEvent eCode: event code 
5: * @param uint16 wParam: event parameter 
6: * @param uint32 dwParan: event parameter 
7: * @return boolean FALSE if app framework should 
8: * continue handling event 
9: 
*1 
10: static boolean 
11: _controlHandleEvent( CStateAppPtr pThis, 
12: 
AEEEvent eCode, 
13: 
uint16 wParam, 
14: 
uint32 dwParam ) 
15: { 
16: 
boolean result = FALSE; 
17: 
boolean bTextControlOnscreen = 
18: 
ITEXTCTL_GetTextPtr( (ITextCtl *) 
19: 
pThis->m_apControl[ Ctl_Textlnput ] ) 
20: 
1= NULL? TRUE : FALSE; 
21: 
boolean bSoftMenuOnscreen = 
22: 
IMENUCTL_GetltemCount( (IMenuCtl *) 
23: 
pThis->m_apControl[ Ctl_SoftKeyMenu ] 
24: 
!= 0 ? TRUE : FALSE; 
25: 
int wCurrCtl; 
26: 
27: 
II Dispatch the event to any of the active controls 
28: 
for ( wCurrCtl = 0; 
29: 
wCurrCtl < pThis->m_nControl; 
30: 
wCurrCtl++ ) 
31: 
{ 
32: 
if ( pThis->m_apControl[ wCurrCtl ] && 
33: 
ICONTROL_IsActive( pThis->m_apControl[ wCurrCtl ] ) ) 
34: 
{ 
35: 
result = 
36: 
ICONTROL_HandleEvent( 
37: 
pThis->m_apControl[ wCurrCtl ], 
38: 
eCode, wParam, dwParam ); 
39: 
if ( result ) break; 
40: 
} 
41: 
} 
42: 
148 

43: 
II Select on a text field with no soft key pops state 
44: 
if ( eCode == EVT_KEY && wParam == AVK_SELECT && 
45: 
ICONTROL_IsActive( pThis->m_apControl[ Ctl_Textlnput ] ) && 
46: 
!b50ftMenuOnscreen ) 
47: 
{ 
48: 
State_PopEx( pThis, StateChangelnfo_SELECT ); 
49: 
result = TRUE; 
50: 
} 
51: 
52: 
II Key up in text control with soft key menu 
53: 
II activates text control 
54: 
if ( bSoftMenuOnscreen && bTextControlOnscreen && 
55: 
eCode == EVT_KEY && wParam == AVK_UP && 
56: 
IICONTROL_IsActive( pThis->m_apControl[ Ctl_Textlnput ] ) && 
57: 
ICONTROL_IsActive( pThis->m_apControl[ Ctl_SoftKeyMenu ] ) ) 
58: 
{ 
59: 
ICONTROL_SetActive( 
60: 
pThis->m_apControl[ Ctl_SoftKeyMenu ], 
61: 
FALSE ); 
62: 
ICONTROL_SetActive( 
63: 
pThis->m_apControl[ Ctl_Textlnput ], 
64: 
TRUE ); 
65: 
result = TRUE; 
66: 
} 
67: 
68: 
II Key down in text control with soft key menu 
69: 
II activates menu control 
70: 
if ( bSoftMenuOnscreen && bTextControlOnscreen && 
71: 
eCode == EVT_KEY && wParam == AVK_OOWN && 
72: 
ICONTROL_IsActive( pThis->m_apControl[ Ctl_Textlnput ] ) && 
73: 
!ICONTROL_IsActive( pThis->m_apControl[ Ctl_SoftKeyMenu ] ) ) 
74: 
{ 
75: 
ICONTROL_SetActive( 
76: 
pThis->m_apControl[ Ctl_SoftKeyMenu ], 
77: 
TRUE ); 
78: 
ICONTROL_SetActive( 
79: 
pThis->m_apControl[ Ctl_Textlnput ], 
80: 
FALSE ); 
81: 
result = TRUE; 
82: 
} 
83: 
II Menu selection navigates to new state 
84: 
if ( Iresult && eCode == EVT_COMMAND ) 
85: 
{ 
86: 
if ( ICONTROL_IsActive( pThis->m_apControl[ Ctl_NavMenu ] ) I I 
Interacting with the User 
149 

ChapterS 
150 
87: 
88: 
89: 
90: 
91: 
92: 
93: 
94: 
95: 
96: 
97: 
98: 
99: 
100: 
101: 
102: 
103: 
104: 
105: 
106: 
107: 
108: 
109: 
110: 
111: 
112: } 
} 
ICONTROL_IsActive( pThis->m_apControl[ Ctl_SoftKeyMenu ] ) ) 
{ 
} 
PFNSTATEEVENT *pStatej 
IMenuCtl *pIMenuj 
pIMenu = ICONTROL_IsActive( 
pThis->m_apControl[ Ctl_NavMenu ] ) ? 
(IMenuCtl *)( pThis->m_apControl[ Ctl_NavMenu ] ) : 
(IMenuCtl *)( pThis->m_apControl[ Ctl_SoftKeyMenu ] )j 
IMENUCTL_GetltemData( pIMenu, 
wParam, (uint32 *)(&pState) )j 
if ( pState 1= NULL) 
{ 
} 
State_PushEx( pThis, pState, 
(unsigned char)(wParam & oxFFÂ»j 
result = TRUEj 
else 
{ 
DBGPRINTF("Error? Menu state null")j 
} 
return resultj 
listing 5-12 is the longest function in the chapter, so let's take it one 
logical block at a time. lines 16-25 define four variables: result, which 
indicates if a control consumed the event; bTextControlOnscreen, which deter-
mines if the text control is on-screen by seeing if it has a valid pointer to input text; 
bSoftMenuOnscreen, which determines if the soft key menu is on-screen; and 
wCurrCtl, which iterates through the list of controls. 
You need to perform the skullduggery on lines 18-24 to determine whether 
these controls are actually on-screen and active because there's no method for 
either ITextCtl or IMenuCtl to determine whether they're on-screen and active. 
This is especially true of IMenuCtl, where a count of the number of menu items 
determines whether it's visible. 
lines 27-41 simply iterate across all of the controls in the framework, offering 
the event to each control using ICONTROL_HandleEvent (lines 36-38) and exiting the 
loop if a specific control consumes the event (line 39). 

Interacting with the User 
The remainder of the function handles specific activities common to all 
controls: 
1. A Select keystroke in a text control with no soft key menu signifies the end 
of text input and pops the state from the state stack (lines 43-50). 
2. An Up keystroke in a soft key menu with a text control gives the text 
control focus (lines 52-66). 
3. A Down keystroke in a text control with a soft key menu gives the soft key 
menu focus (lines 68-82). 
4. Selecting a menu-either a soft key menu item or a navigation menu 
item-causes a transition to a new state. 
lines 43-50 are straightforward. If the event is a Select keystroke (line 44), the 
text control is active (line 45), and the menu control isn't on-screen (line 46), pop 
the current state, which indicates to the state function that the user pressed the 
Select key to cause the state change (line 48). 
The second two cases-where a text control is connected to a menu control-
are a little more tricky because you want the framework to support a state using 
the text control or the soft key menu in isolation, and there's no good way to 
determine that from either of the control's settings. Instead, you can use the flags 
bTextControlOnscreen and bSoftMenuOnscreen to ensure that both controls are on-
screen (even though only one can be active at a time) on lines 54 and 70 to handle 
Up and Down keystrokes. (In other cases, these keystrokes should be passed to the 
state.) If these are both on-screen and the event is the appropriate keystroke, 
the code on lines 52-66 and 68-82 swaps focus from one control to the other. 
Finally, the framework automates changing to new states when a menu item is 
selected if the menu stores a reference to the new state function in its dwData 
pointer. lines 84-87 tests to see if the event is a menu selection on an active menu, 
and if so, lines 91-94 determine which menu accepted the selection by seeing 
which currently is active. lines 96-97 use IMENUCTL_ GetItemOata to find the dwData 
field of the current menu item, which may be a state function. If it is, lines 99-104 
push the new state on the stack, passing the lower byte of the selected menu item 
so the state knows which menu item invoked the state change. Otherwise, a 
debugging message is generated indicating that there may be an error in using the 
framework, and the framework passes the menu event to the current state's event 
handler. 
151 

Chapter 5 
152 
Tying It All Together 
To create the illustrations in this chapter, I needed a quick way to programmati-
cally create and display the controls. Rather than using a separate application for 
each control, I used the framework I've described to build an application with a 
menu that shows a list of controls to select and then enters a state for each control. 
The following sections show how to use the framework to accomplish this by 
looking at a couple of the states in the application. (You can see the source code for 
the entire application in the ControlSample application that accompanies this 
book). 
Initializing the Framework 
Begin by extending the list of controls to include the controls in the example: 
1: typedef enum 
2: { 
3: 
III IStatic used for demonstrating IStatic. 
4: 
Ctl_Static = Ctl_lastFrameworkControl + 1, 
5: 
Ctl_Time, 
6: 
7: 
III Used to mark 
8: 
Ctl_lastControl 
9: } EStateCtlPoolIdxj 
You could just as easily use preprocessor definitions or even keep track of 
them in your head, but it's easier this way. Throughout each of the states, you can 
now refer to a specific control by looking at the appropriate slot in the m _ apControl 
array, just as you can with the framework's controls. 
Next, you need to add the code to initialize the IStatic and ITime controls. 
Rather than modifying the main startup code in Main.c, you simply do it in the 
AS_Init function (see Listing 5-13). 
Listing 5-13. Initializing the Application's Variables 
1: 1** 
2: * Initialize the application-specific data. 
3: * @param void *pThis: application 
4: * @return: EFAIlED or ESUCCESS 
5: *1 
6: int AS_Init( CAppPtr pThis ) 
7: { 

Interacting with the User 
8: 
int result = SUCCESS; 
9: 
10: 
ASSERT( pThis ); 
11: 
II Create the application controls here. 
12: 
result = ISHEll_Createlnstance( GetShell( pThis ), 
13: 
AEEClSID_STATIC, 
14: 
(void **)&pThis->m_app.m_apControl[ Ctl_Static ]); 
15: 
16: 
if ( result == SUCCESS ) 
17: 
result = ISHEll_Createlnstance( GetShell( pThis ), 
18: 
AEEClSID_ClOCKCTl, 
19: 
(void **)&pThis->m_app.m_apControl[ Ctl_Time ]); 
20: 
21: 
return result; 
22: } 
Pretty dull stuff here-just create two controls and return the result code of 
either SUCCESS or any failure ISHEll_Createlnstance returns. 
While on the topic of startup and teardown, it's worthwhile to note that you 
don't have any specific teardown to do in AS Jree because the framework will 
destroy these controls on your behalf: 
1: 1** 
2: * Free allocated resources. 
3: * We don't have to release the controls in the 
4: * control pool --- the framework does this for 
5: * us. 
6: * @param void *pThis: application 
7: * @return nothing 
8: 
*1 
9: void AS_Free( CAppptr pThis ) 
10: { 
11: 
UNUSED( pThis ); 
12: } 
With application startup and teardown complete, let's take a look at two 
states: the main menu state and a state that demonstrates a time control. 
Managing the Main Menu State 
The main menu state simply delegates state initialization and teardown to sep-
arate private functions (see Listing 5-14). 
153 

ChapterS 
154 
Listing 5-14. Starting Up and Tearing Down the Main State 
1: /** 
2: * Handles events for the first state 
3: * @param void *p: this applicaton 
4: * @param AEEEvent eCode: event code 
5: * @param uint16 wParam: event parameter 
6: * @param uint32 dwParam: event parameter 
7: * @return TRUE if application handled event 
8: */ 
9: boolean AS_MainHandleEvent( void *p, 
10: 
AEEEvent eCode, 
11: 
uint16 wParam, uint32 dwParam) 
12: { 
13: 
CAppptr pThis = (CAppPtr)p; 
14: 
boolean result = FALSE; 
15: 
16: 
ASSERT( pThis ); 
17: 
18: 
if ( Iresult ) switch ( eCode ) 
19: 
{ 
20: 
case EVT_APP_START: 
21: 
case EVT_APP_RESUME: 
22: 
result = mainEntry( p, wParam ); 
23: 
break; 
24: 
25: 
case EVT_APP_STOP: 
26: 
case EVT-APP_SUSPEND: 
27: 
result = mainExit( p, wParam ); 
28: 
break; 
29: 
30: 
default: 
31: 
break; 
32: 
} 
33: 
34: 
return result; 
35: } 
When this state is entered-either as a result of a state change or application 
resumption-it calls the function mainEnter to set up the main menu. Similarly, 
when the state exits, it calls mainExi t to free the resources used by the menu. The 
mainEnter function is long but simple at heart (see Listing 5-15). 

Listing 5-15. Entering the Main State 
1: 1** 
2: * Prepares user interface for the first state 
3: * @param void *p: this applicaton 
4: * @param EStateChangeCause change: why we entered this state 
5: * @return nothing 
6: 
*1 
7: static boolean mainEntry{ void *p, 
8: 
EStateChangeCause change ) 
9: { 
10: 
CAppptr pThis = {CAppptr)pj 
11: 
CtlAddltem addltemlnfo = { 0 }j 
12: 
int itemIO = 1j 
13: 
UNUSEO{ change )j 
14: 
15: 
ASSERT{ pThis )j 
16: 
17: 
II Clear the display 
18: 
IOISPLAY_ClearScreen{ GetOisplay{ pThis ) )j 
19: 
20: 
IMENUCTL_SetTitle{ (IMenuCtl *) 
21: 
pThis->m_app.m_apControl[ Ctl_NavMenu ], 
22: 
APP_RES_FILE, 
23: 
IOS_MAINMENUTITLE, 
24: 
NULL ) j 
25: 
26: 
II Build a menu of choices for controls. 
27: 
addltemlnfo.wltemIO = itemIO++j 
28: 
addltemlnfo.dwOata = {uint32)AS_StaticHandleEventj 
29: 
addltemlnfo.pszResText = APP_RES_FILEj 
30: 
addltemlnfo.pszReslmage = APP_RES_FILEj 
31: 
addltemlnfo.wText = IOS_STATICj 
32: 
addltemlnfo.wlmage = lOl_STATICj 
33: 
lMENUCTL_AddltemEx{ (IMenuCtl *) 
34: 
pThis->m_app.m_apControl[ Ctl_NavMenu ], 
35: 
&addltemlnfo )j 
36: 
37: 
addltemlnfo.wltemIO = itemIO++j 
38: 
addltemlnfo.dwOata = {uint32)AS_TextHandleEventj 
39: 
addltemlnfo.pszResText = APP_RES_FILEj 
40: 
addltemlnfo.pszReslmage = APP_RES_FILEj 
41: 
addltemlnfo.wText = IOS_TEXTj 
42: 
addltemlnfo.wlmage = IOI_TEXTj 
Interacting with the User 
155 

ChapterS 
43: 
IMENUCTl_AddltemEx( (IMenuCtl *) 
44: 
pThis->m_app.m_apControl[ Ctl_NavMenu ], 
45: 
&addItemlnfo ); 
46: 
47: 
addltemlnfo.wltemIO = itemIO++; 
48: 
addltemlnfo.dwOata = (uint32)AS_TextWithMenuHandleEvent; 
49: 
addltemlnfo.pszResText = APP_RES_FIlEj 
50: 
addltemlnfo.pszReslmage = APP_RES_FIlE; 
51: 
addltemlnfo.wText = IOS_TEXTWITHMENUj 
52: 
addltemlnfo.wlmage = IOI_OK; 
53: 
IMENUCTl_AddltemEx( (IMenuCtl *) 
54: 
pThis->m_app.m_apControl[ Ctl_NavMenu ], 
55: 
&addItemlnfo ) j 
56: 
57: 
addltemlnfo.wltemIO = itemIO++j 
58: 
addltemlnfo.dwOata = (uint32)AS_TimeHandleEventj 
59: 
addltemlnfo.pszResText = APP_RES_FIlEj 
60: 
addltemlnfo.pszReslmage = APP_RES_FIlEj 
61: 
addltemlnfo.wText = lOS_TIME; 
62: 
addltemlnfo.wlmage = IOI_TIMEj 
63: 
IMENUCTl_AddltemEx( (IMenuCtl *) 
64: 
pThis->m_app.m_apControl[ Ctl_NavMenu ], 
65: 
&addItemlnfo ) j 
66: 
67: 
addltemlnfo.wltemIO = itemIO++j 
68: 
addltemlnfo.dwData = (uint32)AS_MenuHandleEventj 
69: 
addltemlnfo.pszResText = APP_RES_FIlEj 
70: 
addltemlnfo.pszReslmage = APP_RES_FIlEj 
71: 
addltemlnfo.wText = IOS_MENUj 
72: 
addltemlnfo.wlmage = IOI_MENUj 
73: 
IMENUCTl_AddltemEx( (IMenuCtl *) 
74: 
pThis->m_app.m_apControl[ Ctl_NavMenu ], 
75: 
&addItemlnfo ) j 
76: 
77: 
ICONTROl_SetProperties( 
78: 
pThis->m_app.m_apControl[ Ctl_NavMenu ], 
79: 
MP_UNOERlINE_TITlE )j 
80: 
81: 
II Size the menu. 
82: 
ICONTROl_SetRect( pThis->m_app.m_apControl[ Ctl_NavMenu ], 
83: 
&pThis->m_rc )j 
84: 
ICONTROl_SetActive( pThis->m_app.m_apControl[ Ctl_NavMenu ], 
85: 
TRUE )j 
86: 
ICONTROl_Redraw( pThis->m_app.m_apControl[ Ctl_NavMenu ] )j 
156 

Interacting with the User 
87: 
88: 
IDISPlAY_Update( GetDisplay( pThis ) )j 
89: 
90: 
return TRUEj 
91: } 
This function is a straightforward application of the interface to IMenuCtl. It 
begins by clearing the display (line 18) and then setting the title of the menu to a 
string defined in the resource file (lines 20-24). (Recall that when using a resource 
entry to set a menu title, you provide the name of the resource file and the ID of 
the resource, and don't pass a buffer as the last argument.) Next, on lines 26-75, the 
function adds each item to the menu using IMENUCTL _ AddItemEx. The only clever 
bits of code here are the first two lines of each item addition, such as lines 27-28. 
Here, the variable i temID stores a unique ID for each menu item, incrementing it 
after each assignment. On the following line, the menu's dwData pointer stores 
the state function for the state corresponding to the menu choice so that the 
framework will automatically push that state when you select a menu item. 
The remainder of the function completes the menu initialization by selecting 
an underlined title (lines 77-79), sizing the menu to fill the display (lines 82-83), 
activating the menu (lines 84-85), and redrawing the menu (line 86). Finally, the 
function updates the display (line 88) and exits. 
By contrast, mainExit is a simple function (see listing 5-16). 
Listing 5-16. Exiting the Main State 
1: 1** 
2: * Exits the user interface for the first state. 
3: * @param void *p: this application 
4: * @param EStateChangeCause change: why we exited this state 
5: * @return nothing 
6: 
*1 
7: static boolean mainExit( void *p, 
8: 
EStateChangeCause change ) 
9: { 
10: 
CAppptr pThis = (CAppPtr)pj 
11: 
12: 
UNUSED( change )j 
13: 
14: 
ASSERT( pThis )j 
15: 
16: 
ICONTROl_Reset( pThis->m_app.m_apControl[ Ctl_NavMenu ] )j 
17: 
18: 
return TRUEj 
19: } 
157 

ChapterS 
158 
The mainExi t function needs only to reset the navigation menu so that it's 
ready for use the next time it's needed. 
How the application handles the entry and exit of other states is the same. 
Summary 
This chapter covered the following key points: 
â¢ The IControl interface is the base interface from which all user interface 
controls are derived. 
â¢ QUALCOMM BREW provides user interfaces for static text and image 
display, text input, time display (clock, countdown, and count up timers), 
calendars, menus, and a simple HTML viewer. 
â¢ You create control instances as you would instances of other interfaces, 
using ISHELL_Createlnstance, passing the desired class ID for the class 
instance you want. 
â¢ When using a control, the sequence of events is to set its properties, set its 
rectangles, activate it, and update the display. While the control is active, 
you must share application events with the control for it to function cor-
rectly. When you're finished, you must reset the control and release it when 
you're done using it. 
â¢ It's best to preallocate resources crucial to your application's execution such 
as controls when the application starts so that you don't need to deal with 
failures associated with not having them when you need them. 

CHAPTER 6 
Streaming Data 
DEVICES RUNNING QUALCOMM BREW have stringent memory, embedded file 
system, and processor constraints. At the same time, users demand increasing 
functionality, including access to rich multimedia streams such as polyphonic 
MIDI or sophisticated animations. This kind of content often occupies a great deal 
of memory. To mitigate memory constraints, QUALCOMM BREW provides stream 
interfaces to access content from network sockets and the file system, as well as a 
memory buffer. With the stream interface, your application uses a fraction of the 
total memory required by content when passing data from its source to your appli-
cation. Moreover, the stream interface is asynchronous; in other words, your 
application can continue executingwbile waiting for data from the file system or a 
network resource. 
This chapter introduces you to the abstract stream interface IAStream as well 
as the interfaces that implement it: IFile, ISocket, IMemAStream, and IUnzipAStream. 
After reading this chapter, you'll understand how to use streams, as well as how to 
convert a stream interface to its cousin, an ISource, which you can use to process 
data in chunks such as lines. Because RocketMileage doesn't use streams, this 
chapter shows how to use streams with a simple application that plays multimedia 
data from files. 
Understanding the Stream Interface 
If you've ever used the low-level socket file Application Programming Interfaces 
(APIs) under Unix, Wmdows, Mac OS X. or another operating system, you're 
already familiar with the notion of a stream of data. Put simply, a stream of data is 
one where you can read each datum in tum as it's available, starting with the 
beginning of a stream. 
To use a stream, you need to open it, call its read method to read data, set a 
callback if the read doesn't have data, and continue doing this until you've read all 
the data you need. The process is quite simple: 
1. Begin by obtaining an instance of the concrete interface of a stream, such 
as IFile or ISocket. 
2. Call the interface's Read method (such as IFILE_Read to read from a file) to 
begin reading data from the stream. 
159 

Chapter 6 
160 
3. If the Read method returns the error AEE_STREAM_WOULDBLOCK, you'll need to 
defer reading until more data is available. In this case, you should register 
a callback function using the Readable function (such as lFILE_Readable). 
4. The stream will invoke your callback function when more data is 
available. At that point, you can call the interface's Read method again, 
scheduling a callback if necessary using Readable. 
5. If Read ever returns fewer bytes than you request, simply call it again 
(scheduling a callback if necessary). 
6. When you're done, release the interface using its Release method. 
From an application design perspective, it's generally best to place all of your 
reading activities within callback functions so that your application can proceed 
normally while the stream operations take place. By doing this, it makes it easy for 
your application to report progress during the stream activities as well as to tran-
sition to an error state in the event of an error. 
Understanding the Implementations of IAStream 
The lFile, lSocket, lMemAStream, and IUnzipAStream interfaces all inherit the 
lAStream interface (see Figure 6-1). Moreover, other interfaces, such as the lWeb 
interface (explained in detail in Chapter 10, "Networking Your Data"), provide an 
lSource object, which you can convert to a stream and then read from as you 
would any other stream. 
IFile 
ISocket 
IMemAStream 
IUnzipAStream 
Figure 6-1. The inheritance relationship between lASt ream and its child classes 

Streaming Data 
Understanding the IFile Interface 
All QUALCOMM BREW-enabled handsets include a flash memory resident file 
system that you can access using the IFile interface. Most handsets have a 
megabyte or more of flash memory, which all installed applications on the handset 
share. You can use the file system to store persistent data in text or binary files or to 
store database information created with the QUALCOMM BREW database inter-
faces discussed in the next chapter. 
The file system is divided into directories, with one directory for each installed 
application and a shared directory that all applications can access. However, you 
must assert the appropriate privileges in your application's Module Information 
File (MIF) before you can access either your own directory or the shared directory 
(see Chapter 2, "Designing for the QUALCOMM BREW Platform"). 
You can't just create an instance of the IF ile interface using 
lSHELL_Createlnstance. Instead, you need to use the IFileMgr interface, which pro-
vides the base functionality for manipulating items on the file system, including 
getting the names of files in a current directory, removing files, making new direc-
tories, removing directories, and opening files for reading and writing. (You'll 
recall that Chapter 4, "Handling Events," used the IFileMgr interface when enu-
merating the available slide show resource files for the SlideShow application.) 
To create an lFile instance, then, you must first create an IFileMgr 
instance and use its lFlLE_OpenFile method to open a named file with the 
desired read/write attributes. This, in turn, returns an IFile interface, which 
you can read from using the lASt ream interfaces. If you've opened your file for 
writing, you can also write to the file using the lFlLE _Write command, which lets 
you specify a buffer containing data and the size of the buffer to write to the file. 
The IF ile interface closely parallels the POSIX style file system APls, so you can 
also seek to an arbitrary location in a file or truncate a file at a specific length. 
Understanding the ISocket Interface 
The lSocket interface provides a low-level network socket interface similar in 
appearance to the Berkeley socket interface found in most flavors of Unix, the 
Wmsock interfaces found on Microsoft Windows, and the socket implementation 
on the Palm Powered platform. 
Chapter 10, "Networking Your Data," discusses the lSocket interface in more 
detail. 
161 

Chapter 6 
162 
Understanding the IMemAStream Interface 
The IMemAStream interface provides a streaming interface to a memory buffer. At 
first, this seems counterintuitive. After all, why would you want to load a poten-
tially memory-hungry item into Random-Access Memory (RAM) just to turn it into 
a stream so you can save memory by reading it? 
In practice, that's actually notwhyyou'd use the IMemAStream interface. Instead, 
if you have something in RAM for another purpose a1ready-say, as part of its 
normal operation, your application caches an item in RAM-you can use the 
interfaces in media viewers such as IImage to read data directly from the stream 
and display the image contained in the stream. 
You do this using the IMEMASTREAM_ Set interface, which sets the stream to begin 
reading from a specific memory region. The actual call looks like this: 
1: void IMEMASTREAM_Set( 
2: 
3: 
4: 
5: 
6: 
7: 
IMemAStream *pIMemAStream, 
byte *pBuff, 
uint32 dwSize, 
uint32 dwOffset, 
boolean bSysMem 
); 
The IMEMASTREAM_Set call takes the stream to initialize and the beginning of 
the memory region from which to read. Because the stream will release the 
memory region when it's released, you must pass not only the beginning of the 
allocated region (in pBuff) but also where the stream should actually start reading 
(as dwOffset, the number of bytes after pBuff). You must also specify the region's 
size (dwSize) and whether the stream should free the region using FREE-the usual 
case, where you've created the memory region using MALLOC-or SYSFREE. (SYSFREE 
is an API that lets you free memory allocated by the handset's underlying real-time 
operating system from the system heap rather than the application heap.) 
Thus, the purpose of the IMemAStream interface isn't so much to preserve 
memory as it is to make it easy to render content from data already in memory. 
Understanding the IUnzipAStream Interface 
The IUnzipAStream interface gives you a slick way to preserve memory with your 
data-by compressing it first. Rather than devising your own compression scheme 
and then implementing a decompression algorithm on QUALCOMM BREW; you 
can simply use the IUnzipAStream interface to decompress Lempel-Ziv 77 (IZ77) 
compressed data as a stream while you read from the stream. 

Streaming Data 
In practice, this is mind-numbingly easy. First, establish a stream-either use 
a real stream such as an !File or ISocket stream or use IMemAStream to decompress 
1277 data in memory. Next, create an instance of IUnzipAStream. Finally, point the 
IUnzipAStream instance at the target stream using the IUNZIPASTREAM_SetStream 
method. As you'll see shortly, this simply takes the IUnzipAStream instance and the 
stream from which the IUnzipAStream should read: 
1: IUNZIPASTREAM_SetStream( pIUnzipAStream, pIAStream )j 
The easiest way to generate compressed data that the IUnz ipAS tream utility can 
manage is via the open-source gzip utility available under Unix, Linux, Mac OS, 
and Wmdows. In addition to being available as a command-line utility-handy 
when you're packaging specific resources for file system or Web distribution for 
your application-it's also available as a source code and library on most devel-
opment platforms. 
NOTE 
The IUnzipAStream interface is available in QUALCOMM BREW 
1.1 and above. You can't instantiate an IUnzipAStream interface in 
QUALCOMM BREW 1.0. 
Using the Stream Interface 
The StreamSample application accompanying this chapter shows how to use 
streams. Built using the example framework, it's a simple application that lets you 
select a BMP image or an 1277 -compressed bitmap image-which reduces an 
image size by up to a factor of four-from the file system and display it 
(see Figure 6-2). 
1('1 
.... 
I~
;i 
Copynghlhmp 
Figure 6-2. The StreamSample application 
163 

Chapter 6 
164 
To use the StreamSample application, simply place BMP files or 
U77 -compressed BMP files (with suffixes .bmp and .gz, appropriately) in 
the StreamSample directory and run the application. Once the application is 
running, select the bitmap you want to see, and the application displays it on the 
screen. Obviously, seeing how the application works is more interesting than 
the application itselt1 
Using the Framework in StreamSample 
The StreamSample application consists of two states. The first state, managed by 
AS _MainHand1eEvent, is responsible for generating a list of BMP and U77 files (files 
ending in .gz) using code similar to the FillMenu function in Chapter 4, "Handling 
Events," for SlideShow. The second state, managed by AS_ShowBitmapHand1eEvent, 
loads the selected item from the file system as a stream and uses the IImage 
interface to display the image. 
Because only the second state uses streams, let's skip a discussion of the 
framework-which you can review in the previous two chapters-and instead see 
how the application actually uses streams. 
Using Streams in StreamSample 
In the show bitmap state-managed by AS _ ShowBi tmapHand1eEvent-the state entry 
code does all of the work. Specifically, it must do the following: 
1. Open the selected file. 
2. Determine if the file is compressed and, if it is, create an IUnzipAStream 
interface to unzip the data. 
3. Create an IImage instance to display the image. 
4. Set the IImage instance to accept data from the stream. 
5. Draw the image. 
In addition, for the morbidly curious, the state entry code also prints memory 
usage at several points to the debugging console so you can see the difference in 
memory consumption between using U77 -compressed streams. (In practice, 
U77 -compressed streams generally cost around 2 kilobytes.) 
The routine that does all of this is showBitmapEntry (see listing 6-1). 

Listing 6-1. Entering the Bitmap State 
1: 1** 
2: * Enters the ShowBitmap state. 
3: * @param void *p: this applicaton 
4: * @param EStateChange change: why we entered this state 
5: * @return TRUE on successj FALSE if state should not be entered. 
6: 
*1 
7: static boolean showBitmapEntry( void *p, 
8: 
EStateChangeCause change ) 
9: { 
10: 
CAppptr pThis = (CAppPtr)pj 
11: 
IImage *pIImage = NUllj 
12: 
CAppDataptr pAppData = NUllj 
13: 
IAStream *pIAStream = NUllj 
14: 
int resultj 
15: 
16: 
UNUSED( change )j 
17: 
ASSERT( pThis )j 
18: 
19: 
pAppData = GetAppData(pThis)j 
20: 
21: 
II Clear the display 
22: 
IDISPlAV_ClearScreen( GetDisplay( pThis) )j 
23: 
24: 
II Note how much heap we start with â¢â¢. 
25: 
DBGPRINT_HeapUsed( pThis )j 
26: 
27: 
II Get the stream for the file. 
28: 
pIAStream = GetStreamFromFile( pThis, pAppData->szName )j 
29: 
30: 
if ( pIAStream == NUll ) return NUllj 
31: 
32: 
II If the steam is compressed, 
33: 
if ( STRENDS( ".gz", pAppData->szName ) ) 
34: 
{ 
35: 
II we need to get a stream to uncompress it 
36: 
pIAStream = GetUnzipStreamFromStream( pThis, pIAStream )j 
37: 
} 
38: 
39: 
II Create an IImage control to display the bitmap. 
40: 
result = ISHEll_Createlnstance( GetShell( pThis ), 
41: 
AEEClSID_WINBMP, 
42: 
(void **)&pIImage )j 
Streaming Data 
165 

Chapter 6 
166 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
pThis->m_app.m_apControl[ Ctl_Image ] = (IControl *)pIImage; 
if ( result != SUCCESS I I IpIImage ) 
{ 
} 
IASTREAM_Release( pIAStream ); 
return FALSE; 
II Set the image to the stream 
IIMAGE_SetStream( pIImage, pIAStream ); 
II Draw the image 
DrawCentered( pThis, pI Image ); 
DBGPRINT_HeapUsed( pThis ); 
II We no longer need this interface. 
if ( pIAStream ) IASTREAM_Release( pIAStream ); 
62: 
II Update the display 
63: 
IDISPLAY_Update( GetDisplay( pThis ) ); 
64: 
return TRUE; 
65: } 
The state entry begins by validating its preconditions Oine 17) and getting the 
application's global variables using the macro GetAppData, which fetches the appli-
cation's globals from the state machine structure. (This is essentially the same as 
what you did in prior chapters-stashing application globals in the application's 
structure. However, by providing the GetAppData and SetAppData macros, it's 
easier to maintain applications apart from the state machine framework.) In 
StreamSample, there's only one global variable: szName, the filename of the image 
you selected in the previous state. 
Next, it calls the macro DBGPRINT _ HeapUsed, a little utility that uses BREW's IHeap 
interface to get the amount of heap currently in use (see listing 6-2). 
Listing 6-2. Showing the Amount of Heap Consumed by the Application 
1: 1** 
2: * @name DBGPRINT_HeapUsed 
3: * @memo Prints amount of heap used to log. 
4: * @doc Prints the amount of heap used to the debug console. 
5: 
*1 
6: #define DBGPRINT_HeapUsed( pThis ) \ 

Streaming Data 
7: {\ 
8: 
9: 
10: 
11: 
12: 
IHeap *pIHeapj\ 
ISHELL_Createlnstance( GetShell( pThis ), \ 
AEECLSID_HEAP, 
\ 
(void **)&pIHeap)j\ 
if ( pIHeap )\ 
13: 
{\ 
14: 
uint32 nMemoryUsed = IHEAP_GetMemStats(pIHeap)j\ 
15: 
DBGPRINTF("%s(%d) : %d bytes used", \ 
16: 
__ FILE __ , __ LINE __ , nMemoryUsed )j\ 
17: 
IHEAP_Release( pIHeap )j\ 
18: 
}\ 
19: } 
This bit of code simply creates an instance of IHeap on lines 9-11 and then calls 
its IHEAP _ GetMemStats method to detennine how many bytes of the heap are being 
used. Of course, the actual value is slightly more than is actually used by the appli-
cation because it doesn't take into account the amount of space being consumed 
by the IHeap instance if its implementation allocates memory on the heap. 
However, it suffices for this purpose. 
By calling DBGPRINT _ HeapUsed on line 25, you establish the baseline amount of 
the heap consumed by the application to this point. (In practice, this number is 
around 46 kilobytes.) Once you know this, the routine gets a stream for the 
selected file using GetStreamFromFile on line 28. 
This function is a simple utility function that hides from the caller the need to 
use an IFileMgr instance to obtain a stream to a file (see Listing 6-3). 
Listing 6-3. Getting a Stream from a Filename 
1: 1** 
2: * Gets a stream for a file. 
3: * @param CAppPtr *p: this applicaton 
4: * @param char *szName: file name 
5: * @return pointer to lASt ream instance or NULL on failure. 
6: 
*1 
7: static IAStream *GetStreamFromFile( CAppPtr pThis, 
8: 
char *szName ) 
9: { 
10: 
IFileMgr *pIFileMgr = NULLj 
11: 
IFile *pIFile = NULL; 
12: 
int result; 
13: 
14: 
II Setup the file manager instance 
167 

Chapter 6 
168 
15: 
result = I5HELL_CreateInstance( GetShell( pThis ), 
16: 
AEECLSID JILEMGR, 
17: 
(void **)&pIFileMgr ); 
18: 
19: 
if ( result != SUCCESS I I !pIFileMgr ) return NULL; 
20: 
21: 
II Open the specific file to get a stream to the image. 
22: 
pI File = IFILEMGR_OpenFile( pIFileMgr, 
szName, _OFM_READ ); 
23: 
IFILEMGR_Release( pIFileMgr ); 
24: 
25: 
return (IAStream *)pIFile; 
26: } 
There's no reason to separate this code into a separate function other than 
that it makes the tediously long showBitmapEntry a little shorter. It creates an 
IFileMgr instance (on lines 15-17) and returns if it fails to obtain one (line 19). On 
line 22, the real magic happens: The routine obtains an IFile stream from the file 
by opening it. Next, the routine frees the previously allocated IFileMgr instance 
and returns the opened file-as an abstract stream-on line 25. 
NOTE 
This routine can open files for reading only as streams for two 
reasons. First, call I FIL EMGR _ OpenF ile with the flag _ OFM _READ, which 
marks a file for read-only access. Second, the resultingfile instance is 
explicitly recast to an lAS tream instance. If you want to use the full 
gamut of I File methods to read and write from a file, open it with 
_OFM_READWRITE instead and be sure to keep its type as an IFile instance. 
Next, if the stream is compressed-that is, if the filename indicates com-
pression using the .gz suffix found on gzipped files-the routine creates an 
IUnzipAStream instance on line 36 using GetUnzipStreamFromStream. This function is 
simply another short helper function that you might find handy to keep around 
and use elsewhere (see listing 6-4). 
Listing 6-4. Replacing a Stream with an IUnzipAStream 
1: 1** 
2: 
* Replaces a stream with a IUnzipAStream to the same stream. 
3: 
* @param CAppptr *pThis: this applicaton 
4: 
* @param lASt ream *pStream 
5: 
* @return pointer to lASt ream instance or NULL on failure. 
6: 
*1 

Streaming Data 
7: static lAStream *GetUnzipStreamFromStream( CAppPtr pThis, 
8: 
lASt ream *plAStream ) 
9: { 
10: 
lUnzipAStream *plUnzipAStream = NULLj 
11: 
int result; 
12: 
13: 
II Setup the file manager instance 
14: 
result = lSHELL_Createlnstance( GetShell( pThis ), 
15: 
AEECLSlD_UNZlPSTREAM, 
16: 
(void **)&plUnzipAStream ); 
17: 
if ( result 1= SUCCESS I I plUnzipAStream == NULL) 
18: 
{ 
19: 
return NULLj 
20: 
} 
21: 
II Set the zip's source stream 
22: 
lUNZlPASTREAM_SetStream( plUnzipAStream, plAStream ); 
23: 
24: 
II Release our reference to the original stream 
25: 
lASTREAM_Release( plAStream )j 
26: 
27: 
return (lAStream *)plUnzipAStreamj 
28: } 
There aren't any real surprises here: It begins by creating an instance of 
IUnzipAStream on lines 14-16 and, if it's successful, sets the new stream's source 
as the indicated stream. Next, on line 25, it releases the application's reference to 
the original stream because once linked to the IUnzipAStream instance, the 
IUnzipAStream will increment its reference count and take responsibility for freeing 
the source stream when it's released. 
Macros, Functions, and You: Making the Choice 
You may wonder, given how short this function is, why I chose to make this func-
tion a function and the DBGPRlNT _ HeapUsed macro a macro. The answer is one 
largely based on style. For short routines such as this that I use only in debugging 
code, I tend to make them macros to avoid the function call overhead at the cost 
of making my compiled code size larger. In contrast, for routines such as this that 
exist in production versions of an application, it's probably better to conserve 
space. Really, there's little practical difference-I've simply established a habit 
that makes sense with the way I work. 
169 

Chapter 6 
170 
Returning to showBi tmapEntry, the next thing it does is create the IImage 
interface it uses to show the loaded image on lines 39-42, saving the image in the 
Ctl_ Image slot of the application's control pool on line 43. Assuming this operation 
succeeds-something tested for on lines 45-49-the stream is assigned to the 
image on line 52 using IIMAGE_Setstream. This is functionally equivalent to the 
more lengthy and memory-expensive approach ofloading the image into RAM 
and drawing it using IDISPLAY_BitBlt, which is discussed in Chapter 8, "Drawing 
Graphics." Moreover, by using the IImage interface, you can select an appropriate 
IImage instance by the data's type so that if you had other image types (such as 
PNG, JIE or JPEG) on handsets that support these image types you could select the 
appropriate image decoder and display the image. 
The DrawCentered routine simply draws the image centered on the display. 
There's little difference between this routine and the showNextslide routine dis-
cussed in Chapter 4, "Handling Events," so there's no need to show it in this 
chapter. 
Finally, the routine shows the total heap consumed by the operation (line 47) 
and then releases the stream interface (line 60) because it is now owned by the 
IImage interface. Mer that, it updates the display (line 63) and exits (line 64). 
It's important to remember when using QUALCOMM BREw. most of the 
media interfaces use a Set Stream style interface to present their content. Although 
this isn't clearly delineated through a specific inheritance chain, quicldy skimming 
the header files shows that many viewers use it, including the IHTMLViewer control 
(used to display simple HTML files), the ISoundPlayer interface (used to play 
sounds, including MIDI and MP3 streams, as well as QUALCOMM's PureVoice 
format used by the network protocols), and the IMedia interface, which encapsu-
lates the management of arbitrary rich media types supported by specific handset 
vendors. 
NOTE MIDI stands for Music Industry Digital Interface, and MP3 stands 
for Moving Pictures Expert Group Audio Layer 3. 

Streaming Data 
Summary 
This chapter covered the following key points: 
â¢ The stream interface in QUALCOMM BREW gives you a memory-efficient 
way of obtaining data from a large object in small segments. 
â¢ QUALCOMM BREW provides a stream interface to files on the handset's 
flash memory file system as well as network sockets, memory regions, and 
data compressed using the popular LZ77 algorithm. 
â¢ QUALCOMM BREW's mediaAPIs-inc1uding those that display HTML, 
images, and play sounds-accept data from streams, rather than a fully allo-
cated memory buffer containing all of the data, so it's easy to render 
multimedia content in a minimum of memory. 
171 

CHAPTER 7 
Storing Data 
ALTHOUGH A SMALL platform, QUALCOMM BREW often provides more than one 
way to accomplish a specific task such as storing data. In the previous chapter, you 
saw how you could use streams to your advantage to store data on a handset's file 
system or remote server. This chapter shows you another way to store your appli-
cation's data: in a database . 
. QUALCOMM BREW provides a general-purpose database interface that lets 
you create databases-collections of records-stored in a file on the handset's file 
system. Using the database interfaces, you can easily create, store, and recall 
application-specific records without worrying about developing an underlying 
database implementation. As you read this chapter, you'll see how the 
QUALCOMM BREW database implementation works, learn when you should use 
a database instead of files to store your application's data, and see how to address 
some issues you may encounter when using databases. Finally, the chapter shows 
how you can use databases in the RocketMileage application to store vehicle 
events, such as purchasing gas or service. 
Choosing to Use a Database 
Because QUALCOMM BREW provides two ways to store persistent data-files and 
databases-it's important to understand how they're different so you can make the 
right architecture decision when designing your application. As you saw in the 
previous chapter, files allow you to store data for access in a stream. Databases, on 
the other hand, provide a record -oriented mechanism for storing data. 
Understanding the Database Implementation 
The database implementation on QUALCOMM BREW lets you create records con-
sisting of one or more fields, each of which has a fundamental data type such as 
integer, string, or binary data. Unlike other mobile platforms such as the Palm 
Powered platform, there's no direct correspondence between a database record 
and a structure in C, so you're free to devise an arbitrarily simple (or complex) 
schema for your database. 
173 

Chapter 7 
174 
You begin by creating or opening a database using the IDBMgr interface, which 
provides methods for opening a database, initializing a database with a specific 
number of records and reserved size, and removing a database. When you create a 
database, you give it a unique name, which the system uses when creating the 
underlying files to store your database records. After opening a database with 
IDBMgr, the system provides your application with an IDatabase instance, which 
you use to access records in your database. 
With the IDatabase instance, you can access individual records in your 
database, create new records by defining a list of fields for the record, and iterate 
over all records in the database. Each of these operations provides your appli-
cation with an IDBRecord instance, which you use to access fields within a specific 
record. 
The IDBRecord interface provides methods for accessing each field in a 
database record. Like the IDatabase interface, the IDBRecord interface provides an 
enumerative interface to record fields. The record interface begins by providing 
information about the first field, and as you fetch data for the current field, it auto-
matically steps forward and returns information about the next field of the record. 
Using the IDBRecord interface, you can access and change the fields in a record, as 
well as delete a record and get the specific database ID of the record being 
manipulated. 
Under the hood, QUALCOMM BREW uses two files for each database you 
create. One file, the index file, has the name you provide when opening the 
database with the suffix. idx and contains a set of offsets to each record in 
your database. The other file bears only the name you use when opening the 
database and contains the records in a proprietary format bearing each field, 
the application-specific identification for each field, and the field data. 
TIP 
You shouldn't rely on the format or names of database files because 
QUALCOMM has made no assurances that these won't change in the 
future. Instead, be sure to always use the methods provided by the IDBMgr, 
IDatabase, and IDBRecord interfaces when interacting with database 
files. 

Understanding Database Requirements 
For your application to use the database interfaces, it must satisfy two simple 
requirements: 
It must have either the File privilege or the All privilege asserted in your 
application's Module Information File (MIF). 
It must be willing to allocate two files out of the total number of files the 
application will use (a carrier-dependent figure made to ensure that mul-
tiple applications can coexist on handsets) for each database. These files 
can exist in your application's directory or in the shared directory if the 
database contents will be shared with another application. (Note, 
however, that if you use the shared directory, you'll also need to assert the 
Write Access to Shared Directory privilege in your application's MIR) 
Because databases use files, you must be able to read from and write to files to 
use databases. Moreover, if you're storing a database in a shared directory, you 
must be sure you can also access the shared directory. To do this, be sure you set 
the correct privileges in your application's MIR 
To encourage cooperative resource sharing between installed applications, 
some carriers may require that applications use fewer than some set number of 
files to prevent one application from hoarding the lion's share of file system 
resources. Consequently, you should be aware that each database you use requires 
two files: one for the index and one for the records themselves. Depending on your 
application's design and purpose, you may need to limit the number of 
databases you use or apply for a waiver when submitting your application to a 
specific carrier and describe your need for files in excess of the number mandated 
by the carrier. 
Interfacing with a Database 
Given the power and flexibility of the QUALCOMM BREW database implemen-
tation, the interfaces are surprisingly simple. The interfaces to databases span 
three separate classes: the IDBMgr class, responsible for managing databases; the 
IDatabase class, responsible for interfacing to a specific database; and the 
IDBRecord class, responsible for managing a specific record within an already-
open database. 
Storing Data 
175 

Chapter 7 
176 
Using the IDBMgr Interface 
The IDBMgr interface is analogous to the I FileMgr interface you encountered in the 
previous chapter. Instead of managing files and directories, however, the IDBMgr 
interface manages databases. 
Besides the obligatory IDBMGRJ\ddRef and IDBMGR_Re1ease methods, which let 
you adjust the reference count for an instance of IDBMgr, this class has three other 
methods.1\vo, IDBMGR_OpenDatabase and IDBMGR_OpenDatabaseEx, let you open a spe-
cific database, returning an IDatabase interface for the database you specify. The 
third, IDBMGR_Remove, deletes the files that correspond to a specific database. 
Normally, you'll open a database using IDBMGR_OpenDatabase, which takes as 
arguments a reference to an IDBMgr interface, the name of the database, and 
whether the database should be created if it doesn't already exist: 
1: IDBMgr *pIDBMgr; 
2: IDatabase *pIDatabase; 
3: if ( ISHELL_Createlnstance( GetShell( pThis ), 
4: 
AEECLSID_DBMGR, (void **)&pIDBMgr 
5: 
) ! = SUCCESS ) return; 
6: pIDatabase = IDBMGR_OpenDatabase( pIDBMgr, 
7: 
APP _DATABASE_NAME, TRUE ); 
8: 
IDBMGR_Release( pIDBMgr ); 
9: if ( IpIDatabase ) return; 
Some applications-such as those written by Original Equipment Manufac-
turers (OEMs)-may need to reserve a specific amount of space for their 
databases. To do this, you can use the IDBMGR _ OpenDatabaseEx function, which takes 
as additional arguments the minimum size of a database record and the minimum 
number of records the database will contain. In turn, when creating the database, 
QUALCOMM BREW will reserve that many records' worth of space on the file 
system for the database. listing 7-1 shows how to open a database. 
Listing 7-1. Opening a Database 
1: #define MIN_RECORD_COUNT ( 100 ) 
2: #define MIN_RECORD_SIZE ( 8 * sizeof( uint32 ) 
3: 
IDBMgr *pIDBMgr; 
4: IDatabase *pIDatabase; 
5: if ( ISHELL_Createlnstance( GetShell( pThis ), 
6: 
AEECLSID_DBMGR, (void **)&pIDBMgr 
7: 
) != SUCCESS) return; 

8: pIDatabase = IDBMGR_OpenDatabaseEx( pIDBMgr, 
9: 
APP _DATABASE_NAME, TRUE, 
10: 
MIN_RECORD_SIZE, 
11: 
MIN_RECORD_COUNT ); 
12: IDBMGR_Re1ease( pIDBMgr ); 
13: if ( IpIDatabase ) return; 
Generally, your application's success shouldn't be predicated on the use of 
IDBMGR_OpenDatabaseEx. If all developers use this function to stake out the likely 
resource needs for their applications in advance, it's quite possible that most 
handsets won't have enough room to store application data because the handset is 
a cooperative environment. Instead, it's generally better to use the minimum 
amount of space when your application first runs and specifically handle the pos-
sibility that there will be no room to store additional records. 
When your application needs to delete a database, it should use the 
IDBMGR _Remove function to do this. This function removes both the data file and the 
index file. This function takes the name of the database as well as an instance of 
the IDBMgr class: 
1: 
IDBMgr *pIDBMgr; 
2: if ( ISHELL_CreateInstance( GetShe11( pThis ), 
3: 
AEECLSID_DBMGR, (void **)&pIDBMgr 
4: 
) != SUCCESS ) return; 
5: 
IDBMGR_Remove( pIDBMgr, APP_DATABASE_NAME ); 
6: 
IDBMGR_Re1ease( pIDBMgr ); 
With IDBMGR_Remove, there's no need to remove each record of the database. 
Because the function removes the underlying data files, the data is destroyed and 
space on the file system is reclaimed automatically. 
Using the IDatabase Interface 
Once you open a database using IDBMGR_OpenDatabase (or its counterpart 
IDBMGR _ OpenDatabaseEx), you can perform operations to create and obtain indi-
vidual records in the database using the IDatabase interface for that database. This 
interface provides two basic ways to access a database: by using a record's unique 
10 and by using an iterative interface that lets you walk through every record in the 
database. 
The easiest way to obtain a specific record is using its unique 10, assigned 
when a database record is first created. To fetch a record by 10, you use 
Storing Data 
177 

Chapter 7 
178 
IDATABASE_GetRecordByID, which returns the IDRecord interface to the record (or 
NULL if the record doesn't exist): 
1: IDBRecord *pIDBRecord; 
2: pI DB Record = IDATABASE_GetRecordByID( pIDatabase, (uint16)nRecordID ); 
3: II Do something with pIDBRecord here 
4: IDBRECORD_Re1ease( pIDBRecord ); 
Many times, of course, you won't know the ID of the record you want to access. 
When this is the case, you use the functions IDATABASE_Reset and 
IDATABASE_GetNextRecord to iterate over all of the records in the database, like this: 
1: IDBRecord *pIDBRecord; 
2: IDATABASE_Reset( pIDatabase ); 
3: while ( pIDBRecord = IDATABASE_GetNextRecord( pIDatabase ) 
4: { 
5: 
/I Do something with pIDBRecord here â¢â¢â¢ 
6: 
IDBRECORD_Release( pIDBRecord ); 
7: } 
8: II IDATABASE_Reset( pIDatabase ) before iterating again! 
Because IDATABASE_GetNextRecord returns NULL, this loop visits each record 
exactly once. If you'd rather use a for loop, you can either use a similar tennination 
case or use IDATABASE_GetRecordCount, which returns the number ofrecords in the 
database, like this: 
1: IDBRecord *pIDBRecord; 
2: int i, nCount; 
3: nCount = IDATABASE_GetRecordCount( pIDatabase ); 
4: IDATABASE_Reset( pIDatabase ); 
5: for ( i = 0; i < nCount; i++ ) 
6: { 
7: 
IDATABASE_GetNextRecord( pIDatabase ); 
8: 
/I Do something with pIDBRecord here .â¢â¢ 
9: 
IDBRECORD_Release( pIDBRecord ); 
10: } 
11: II IDATABASE_Reset( pIDatabase ) before iterating again! 
As you'll see in the next section, you must release the database record inter-
faces returned by both IDATABASE _ GetRecordByID and IDATABASE _ GetNextRecord 
before you can close the database by releasing it using IDATABASE_Release. 

CAUTION 
There's no documented evidence that a record's ID is immuta-
ble across the lifespan of a database, so it's best not to treat this ID as a 
means to identify a unique database entry except when a database is 
open. As such, the record's ID is more of an index to the record in the 
database, rather than a record in the traditional sense. 
Of course, all of this does little good until after you've placed something into 
your database in the first place. To do this, you define an array of database fields of 
type AEEDBField for a single record and then create that record in the database 
using the IDATABASE_CreateRecord function. Each entry in the array of AEEDBFields 
defines the properties and contents of a specific field in your database. 
The AEEDBField structure has four fields to describe a database record field: 
â¢ The fType field stores the database field's type as a specific value of the 
AEEDBFieldType enumeration. Table 7-1 describes the valid type fields sup-
ported by the interface. 
â¢ The fName field stores the database field's name as an integer. You can either 
use the AEEDBFieldName enumeration to name your database fields or create 
your own enumeration that assigns a unique integer to each record field. 
â¢ The wData Len field stores the size of the current field's data. 
â¢ The pBuffer field stores a pointer to the data for the current field. 
Table 7-1. AEEDBFieldType Definitions 
AEEDBFieldType VALUE 
AEEDB FT BYTE 
AEEDB FT WORD 
AEEDB FT DWORD 
AEEDBJT_STRING 
AEEDB FT BINARY 
AEEDB FT BITMAP 
FUNDAMENTAL DATA TYPE 
byte 
int16 or uint16 
int32 or uint32 
Null-terminated array of AECHAR 
Binary blob of bytes 
Windows bitmap 
Storing Data 
179 

Chapter 7 
180 
Creating a record can be a time-consuming task because you need to fill out 
an AEEDBField structure for each field. This process-serializing a memory 
structure for database storage-looks something like the code in listing 7 -2. 
Listing 7-2. Serializing a Memory Structure 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
typedef enum 
{ 
Fld_EntryType = 1, 
Fld_Time, 
Fld_Miles, 
Fld_Other, 
FldJost, 
Fld_DueTime, 
Fld _DueMiles, 
Fld LastField 
} EAppRecordFieldName; 
IDBRecord *StoreRecord{ IDatabase *pIDatabase, 
CAppRecordptr pRecord ) 
{ 
AEEDBField arFields[ Fld_LastField ]; 
uint16 iFieldName = 1; 
ASSERT{ pIDatabase && pRecord ); 
arFields[iFieldName-l].fType = AEEDB_FT_WORD; 
arFields[iFieldName-l].fName = iFieldName; 
arFields[iFieldName-l].wDataLen = sizeof{ uint16 ); 
arFields[iFieldName-l].pBuffer = (void*)&{pRecord->m_type); 
iFieldName++; 
arFields[iFieldName-l].fType = AEEDB_FT_DWORD; 
arFields[iFieldName-l].fName = iFieldName; 
arFields[iFieldName-l].wDataLen = sizeof{ uint32 ); 
arFields[iFieldName-l].pBuffer = (void*)&{pRecord->m_nTime); 
iFieldName++; 
arFields[iFieldName-l].fType = AEEDB_FT_DWORD; 
arFields[iFieldName-l].fName = iFieldName; 
arFields[iFieldName-l].wDataLen = sizeof{ uint32 ); 
arFields[iFieldName-l].pBuffer = {void*)&{pRecord->m_nMiles; 
iFieldName++; 

39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: } 
arFields[iFieldName-1].fType = AEEDB_FT_DWORDj 
arFields[iFieldName-1].fName = iFieldNamej 
arFields[iFieldName-1].wDatalen = sizeof( uint32 )j 
arFields[iFieldName-1].pBuffer = (void*)&(pRecord->m_nOther)j 
iFieldName++j 
arFields[iFieldName-1].fType = AEEDB_FT_DWORDj 
arFields[iFieldName-1].fName = iFieldNamej 
arFields[iFieldName-1].wDatalen = sizeof( uint32 )j 
arFields[iFieldName-1].pBuffer = (void*)&(pRecord->m_nCost)j 
iFieldName++j 
arFields[iFieldName-1].fType = AEEDB_FT_DWORDj 
arFields[iFieldName-1].fName = iFieldNamej 
arFields[iFieldName-1].wDatalen = sizeof( uint32 )j 
arFields[iFieldName-1].pBuffer = (void*)&(pRecord->m_nDueTime)j 
iF ieldName++ j 
arFields[iFieldName-1].fType = AEEDB_FT_DWORDj 
arFields[iFieldName-1].fName = iFieldNamej 
arFields[iFieldName-1].wDatalen = sizeof( uint32 )j 
arFields[iFieldName-1].pBuffer = (void*)&(pRecord->m_nDueMiles)j 
iFieldName++j 
return IDATABASE_CreateRecord( pIDatabase, 
arFields, 
Fld_LastField ); 
This is pretty boring stuff. Lines 1-11 define an enumeration of the fields in a 
record for RocketMileage, and the Save Record function on lines 13-66 creates and 
populates the fields of a database record Oines 21-61) and creates a new record 
with the fields. 
CAUTION Some QUALCOMM BREW handset implementations-
typically those prior to BREW 2.O-have a bug and can't read or write 
AEEDB_FT_DWORD database fields. To work around this issue, if you experi-
ence crashes in your database code manipulating AEEDB _FT _DWORD fields, 
use the typeAEEDB_FT_BlNARY instead and treat your DWORD data asa 
four-byte binary blob of data. 
Storing Data 
181 

Chapter 7 
182 
Using the IDBRecord Interface 
Once you have a record-from IDATABASE_CreateRecord, IDATABASE_GetRecordBylD, 
or IDATABASE _ GetRecordNext-you can access individual fields using the IDBRecord 
interface. 
If you want to obtain the record number of a specific record, you can do so 
using the IDBRECORD _ GetlD method, like this: 
1: uint16 id = lDBRECORD_GetlD( plDBRecord )j 
You can then use the resulting ID in later calls to IDATABASE_GetRecordBylD. 
You can remove a specific record by calling IDBRECORD _Remove: 
1: lDBRECORD_Remove( plDBRecord )j 
You can also update a record's fields using IDBRECORD _Update, which takes the 
same arguments as IDATABASE_CreateRecord. Unlike IDATABASE_CreateRecord, 
however, IDBRECORD _Update returns a BREW error code: SUCCESS if the operation 
completed successfully or an error code in the event of an error. 
Most of the time, however, you use the IDBRecord interface to access specific 
fields of a single database record. To do this, you use the IDBRECORD _Reset and 
IDBRECORD_NextField functions to iterate over all the fields in a record, such as the 
function shown in Listing 7-3. 
Listing 7-3. Iterating Over All o/the Fields in a Database Record 
1: lOB Record *plDBRecordj 
2: AEEDBFieldType iFieldTypej 
3: AEEDBFieldName iFieldNamej 
4: uint32 iFieldLengthj 
5: byte *pDataj 
6: II Do something to initialize pRecord. 
7: 
8: lDBRECORD_Reset(plDBRecord)j 
9: 
10: II While there are fields to examine â¢.â¢ 
11: while( lDBRECORD_NextField(plDBRecord, 
12: 
13: 
14: { 
15: 
16: 
17: 
18: 
&iFieldName, &iFieldLength 
) != AEEDB_FT_NONE ) 
II Get the contents of this field 
pData = lDBRECORD_GetField(plDBRecord, &iFieldName, 
&iFieldType, &iFieldLength )j 
if (lpData) breakj 

19: 
II Cast *pData based on iFieldType and use it here. 
20: } 
21: IDBRECORD_Release( pRecord )j 
Mer resetting the record to point to the first field (line 8), this code iterates 
through each field of the current record using IDBRecordNextField, which returns 
the data type of the next field or returns AEEDB _FT _NONE if there are no more fields to 
examine. 
You'll use this kind of a loop when you need to decode the serialized format of 
a database record, too. In that case, you'll use the field name in a switch statement 
to set each field of a C structure, such as the LoadRecord function shown in 
Listing 7 -4. 
Listing 7-4. Decoding a Serialized Record 
1: CAppRecordPtr *LoadRecord( IDBRecord *pIDBRecord ) 
2: { 
3: 
AEEDBFieldType iFieldTypej 
4: 
AEEDBFieldName iFieldNamej 
5: 
CAppRecordPtr *pResultj 
6: 
uint32 iFieldLengthj 
7: 
byte *pDataj 
8: 
9: 
ASSERT( pIDBRecord )j 
10: 
11: 
pResult = MALlOC( sizeof( CAppRecord ) )j 
12: 
if ( !pResult ) return NULL; 
13: 
14: 
MEMSET( pResult, 0, sizeof( CAppRecord ) )j 
15: 
16: 
II Begin at the beginning 
17: 
IDBRECORD_Reset( pIDBRecord )j 
18: 
19: 
II While there are fields to examine â¢.â¢ 
20: 
while( IDBRECORD_NextField( pRecord, 
21: 
&iFieldName, 
22: 
&iFieldlength 
23: 
) != AEEDB_FT_NONE ) 
24: 
{ 
25: 
II Get the contents of this field 
26: 
pData = IDBRECORD_GetField( pRecord, &iFieldName, 
27: 
&iFieldType, &iFieldlength )j 
28: 
if (!pData) breakj 
29: 
Storing Data 
183 

Chapter 7 
184 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: } 
} 
switch( iFieldName ) 
{ 
} 
case Fld_EntryType: 
pResult->m_type = *Â«int16 *)(pDataÂ»; 
break; 
case Fld_Time: 
pResult->m_nTime = *Â«uint32 *)(pDataÂ»; 
break; 
case Fld_Miles: 
pResult->m_nMiles = *Â«uint32 *)(pDataÂ»; 
break; 
case Fld_Other: 
pResult->m_nOther = *Â«uint32 *)(pDataÂ»; 
break; 
case Fld_Cost: 
pResult->m_nCost = *Â«uint32 *)(pDataÂ»; 
break; 
case Fld_DueTime: 
pResult->m_nDueTime = *Â«uint32 *)(pDataÂ»; 
break; 
case Fld_DueMiles: 
pResult->m_nDueMiles = *Â«uint32 *)(pDataÂ»; 
break; 
default: 
break; 
return pResult; 
There's nothing exciting here, either. The foundation of load Record is the same 
while loop you saw in Listing 7 -3, followed by a switch statement that uses each 
of the field names in turn to decide which element of the structure to fill 
(lines 30-55). 
Overcoming Issues with the Database Interface 
Using a database in your application isn't without challenges. Although it's conve-
nient to be able to design a simple schema and store data without worrying about 
the representation of your data on the phone's file system, you must be aware of 
other issues that can arise. 

The two most common issues when using the database interface are perfor-
mance and data sorting. The first, performance, is an issue you can't do much 
about, but you need to be aware of its ramifications as you use databases. The 
second, data sorting, can cause problems for you when porting an application 
from another mobile platform or when designing an application that needs to 
present data you enter in a specific order. 
Addressing Performance Issues 
Today's handsets store files-including database files-on a file system stored in 
flash memory. Flash memory has many outstanding qualities including low cost, 
relatively low power consumption, and the ability to retain its contents once 
power is turned off. Unfortunately, it has two significant drawbacks: slow perfor-
mance when writing data and a limited number of write operations on each 
memory cycle. 
Because of how flash memory stores each bit of information, it's orders of 
magnitude slower to write to flash memory than it is to read from flash memory. 
Worse, because of how flash memory operates, you can write to each location only 
a set number of times-typically tens or hundreds of thousands of times-before a 
given memory location fails permanently and can no longer store a datum. Conse-
quently, the drivers that provide the file system support on handsets work to 
ensure that, when making changes to files on the file system, the operations are 
spread evenly over the entire flash memory region so no specific memory location 
fails before any other. Of course, scattering bits on the file system to ensure that all 
memory locations receive on average the same number of write operations makes 
the file system implementation more complex-and thus slower. 
There's little you can do directly to compensate for this performance issue in 
your implementation because the limitation is fundamentally a hardware and 
operating system one. That said, you can minimize the impact write performance 
has on your application by keeping records in memory for as long as they're likely 
to change and only writing them to the database when modifications are 
complete. 
Sorting Database Entries 
The QUALCOMM BREW database interface doesn't provide any mechanisms 
for ordering records, and there's no documented guarantee regarding the specific 
ordering of records or fields within a database. Consequently, if your application 
needs to provide sorted views of data in its database, it's up to you to manage how 
you sort records. This is at stark odds with other platforms such as the Palm 
Storing Data 
185 

Chapter 7 
186 
Powered platform, where you have access to a secondary database region that you 
can use to store record IDs sorted in a specific order. 
Instead, you must do one of two things: either sort records on demand or keep 
a separate file of record IDs sorted in a specific order. Because of the hassles of 
keeping a file of record IDs in order-and the need to insert new record IDs in the 
middle of the list as you continue to keep the records sorted-I'm a big fan of 
sorting on demand. 
One good way to do this is to create a sorted list of record IDs when you need 
to sort the database. As you'll learn in the next section where you see how Rocket-
Mileage does this, it's really quite simple. Although it's not the most efficient way to 
sort a set of records, I'm partial to using an insertion sort: You simply iterate over 
the records in the database and create a linked list of record IDs sorted by whatever 
criteria you like as you iterate. Although not as efficient as more sophisticated 
algorithms such as a heap sort or Quicksort, it lets you load and sort database 
entries in one pass. Once you have a list of sorted record IDs, you can quickly 
obtain fields from a specific record using the IDatabase and IDBRecord interfaces 
because reading from the database is only marginally slower than reading infor-
mation from main memory. Equally important, by sorting only the list of record 
IDs (rather than the records themselves), you use significantly less memory than if 
you loaded all of your records into main memory simply to create a sorted list. 
Using a Database in a Real Application 
Using a database in your application is almost as easy as you might expect from 
the material presented in this chapter. To help you with your efforts, this section 
shows you how you can use the database interfaces to store the mileage infor-
mation you enter in RocketMileage. 
Understanding the Schema 
RocketMileage uses a database to store each vehicle maintenance event. Unlike a 
traditional desktop application, however, RocketMileage doesn't store all events; it 
stores only the most recent events for a specific kind of service. Doing this mini-
mizes the amount of data storage the application uses and simplifies data 
management for application users. The database consists of records with the fields 
in Listing 7 -5. 

Listing 7-5. The Database Schema 
1: typedef enum _EMileageEntryType 
2: { 
3: 
ME_Gas = 1, 
4: ME_Oil, 
5: ME_Tire, 
6: ME_Tuneup, 
7: ME_OtherService, 
8: ME_Parking, 
9: ME_Mileage, 
10: ME_Undefined 
11: } EMileageEntryType; 
12: 
13: typedef struct 
14: { 
15: 
EMileageEntryType m_type; 
16: 
uint32 m_nTime; 
17: 
uint32 m_nMiles; 
18: 
uint32 m_nOther; 
19: 
uint32 m_nCost; 
20: 
uint32 m_nDueTime; 
21: 
uint32 m_nDueMiles; 
22: } CAppRecord, *CAppRecordptr; 
To track mileage, you don't need to keep every mileage event in a database; 
instead, you simply use the fact that the average mileage is simply the sum of the 
number of miles driven divided by the sum of the number of gallons of fuel con-
sumed. You can keep these in the application's preferences, a special place each 
application can access that stores information not suited to either databases or 
files. The shell maintains a file of all the application's preferences, and when you 
delete an application on the handset, you also delete the preferences information 
for that application. 
Accessing Application Preferences 
Accessing the preferences is easy-far easier than using a database. To load your 
application's preferences, simply use the IShell method ISHELL_GetPrefs, which 
loads the preferences structure you provide for a specific class 10: 
Storing Data 
187 

Chapter 7 
188 
1: result = ISHELL_GetPrefs( GetShell( pThis ), 
2: 
3 : 
4: 
5: 
AEECLSID_OURS, 
APP_PREFS_VERSION, 
&appPrefs, 
sizeof(CAppPrefs) )j 
ISHELL_GetPrefs takes as arguments an IShell interface, the class ID of the 
application whose preferences to fetch, the version number of the preferences to 
fetch, a region into which to copy the preferences, and the size of the preferences. 
The shell knows nothing about what's in the preferences structure, so you can put 
just about anything in there that makes sense for your application. It will return 
either SUCCESS if the application preferences were successfully copied to your 
structure or an error code in the event of a failure. 
To set your application preferences, you simply use the corresponding 
method ISHELL_SetPrefs, which takes the same arguments: 
1: result = ISHELL_SetPrefs( GetShell( pThis ), 
2: 
AEECLSID_OURS, 
3: 
APP_PREFS_VERSION, 
4: 
5: 
&appPrefs, 
sizeof(CAppPrefs) )j 
In RocketMileage, each time you enter a mileage record, the program updates 
the database with the information you've just entered, updates the sums of the 
miles traveled, and updates the fuel used in the application preferences. When you 
need to display mileage, you take the ratio of the two and then manually insert the 
decimal point at the right spot (because everything is stored as integers.) 
TIP Be sure to increment your application's preferences version every 
time you change your application preferences structure. QUALCOMM 
BREW uses that to replace and upgrade preference structures as they 
change. [fyou don't, your application can crash on handsets or the emu-
lator because the data QUALCOMM BREW gives you won't be what you 
expect in your preferences structure! 
Serializing Records for the Database 
The previous section showed you how you can load a record from the database 
into a C structure as well as how to save C structures as records in your 

database using StoreRecord and LoadRecord. These methods are completely 
functional but lack generality. For example, if you want to write another appli-
cation, you have to completely rewrite them, even though the basic algorithm 
(iterating over record fields) remains the same. 
In RocketMileage-and in the framework that accompanies the book-you 
can find two other ways to do the same thing. The first way is using macros that 
make it easy to initialize the contents of an AEEDBField structure for common data 
types, shown in Listing 7 -6. 
Listing 7-6. Macros to Initialize the Contents of an AEEDBField Structure 
1: #define DBStringField( pf, p, f ) \ 
2: 
(pf) ->fType = AEEDB_FT_STRINGj \ 
3: 
(pf)->fName = (f)j \ 
4: 
pf->wDataLen = (uint16)WSTRSIZE(wszString)j \ 
5: 
pf->pBuffer = (void*)(p)j 
6: 
7: #define DBBlobField( pf, p, 1, f ) \ 
8: 
pf->fType = AEEDB_FT_BlNARYj \ 
9: 
pf->fName = fj \ 
10: 
pf->wDataLen = (uint16)lj \ 
11: 
pf->pBuffer = (void*)(p)j 
12: 
13: #define DBWordField( pf, p, f ) \ 
14: 
pf->fType = AEEDB_FT_WORDj \ 
15: 
pf->fName = fj \ 
16: 
pf->wDataLen = sizeof(uint16)j \ 
17: 
pf->pBuffer = (void*)(p)j 
18: 
19: #define DBDWordField( pf, p, f ) \ 
20: 
pf->fType = AEEDB_FT_BlNARY 1* AEEDB_FT_DWORD */j \ 
21: 
pf->fName = fj \ 
22: 
pf->wDataLen = sizeof(uint32)j \ 
23: 
pf->pBuffer = (void*)(p)j 
24: 
25: #define DBByteField( pf, p, f ) \ 
26: 
pf->fType = AEEDB_FT_BYTEj \ 
27: 
pf->fName = fj \ 
28: 
pf->wOataLen = sizeof(byte)j \ 
29: 
pf->pBuffer = (void*)(p)j 
Storing Data 
189 

Chapter 7 
190 
These macros make it easier to write routines such as SaveRecord, but they 
don't really go far in making things any easier to reuse. Consequently, the func-
tions DBFreezeRecord, DBThawRecord, and DBRecordField let you serialize database 
records or access all the fields or a specific field of a serialized record. These 
rely on two functions provided as part of a specific application (the 
AS_DBFieldFromDatabase and AS_DBFieldToDatabase functions), which provide 
access to each specific field in a record's C structure. listing 7 -7 shows the 
DBFreezeRecord function. 
Listing 7-7. The DBFreezeRecord Function 
1: int DBFreezeRecord( CAppRecordPtr pRecord. 
2: 
AEEDBField **ppResult ) 
3: { 
4: 
AEEDBField *arFields; 
5: 
AEEDBFieldName i; 
6: 
AEEDBFieldType iFieldType; 
7: 
uint16 iFieldLength; 
8: 
byte *pData; 
9: 
int sz; 
10: 
int result = SUCCESS; 
11: 
12: 
ASSERT( pRecord && ppResult ); 
13: 
14: 
II Allocate our result buffer 
15: 
sz = Fld_LastField * sizeof( AEEDBField ); 
16: 
arFields = (AEEDBField *)MALLOC(Sl); 
17: 
if ( larFields ) return ENOMEMORY; 
18: 
*ppResult = arFields; 
19: 
20: 
II For each field. get the database representation 
21: 
for ( i = 1; i < Fld_LastField; i++ ) 
22: 
{ 
23: 
result = AS_DBFieldToDatabase( pRecord. 
24: 
i. 
25: 
&iFieldType. 
26: 
&pData. 
27: 
&iFieldLength ); 
28: 
if ( result 1= SUCCESS) break; 
29: 
arFields[i-1].fType = iFieldType; 
30: 
arFields[i-1].fName = i; 
31: 
arFields[i-1].wDataLen = iFieldLength; 
32: 
arFields[i-1].pBuffer = (void*)(pData); 
33: 
} 

34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: } 
if ( result != SUCCESS) 
{ 
} 
II Free the field array before exiting 
FREE( arFields )j 
*ppResult = NULLj 
return resultj 
This routine simply breaks apart the monolithic StoreRecord routine into two 
pieces: one in this routine that's responsible for iterating across all of the fields in 
the database record and the other piece, implemented in AS_DBFieldToDatabase, 
which converts a named field in the application's record into its representation 
for the database. The function returns a fully populated AEEDBField array 
describing the record, first created on lines 14-18, which you can use in calls to 
IDATABASE_CreateRecord or IDBRECORD_Update. Next, the routine simply iterates 
across all named fields in the database, converting each field from the record 
structure to a database field with the help of AS_DBFieldToDatabase. 
For RocketMileage, the AS_DBFieldToDatabase function is just a big switch 
statement, as shown in Listing 7-8. 
Listing 7-8. The AS _DBFieldToDatabase Function 
1: int AS_DBFieldToDatabase( CAppRecordPtr pRecord, 
2: 
AEEDBFieldName iFieldName, 
3: 
AEEDBFieldType *piFieldType, 
4: 
byte **ppData, uint16 *piFieldLength ) 
5: { 
6: 
int result = SUCCESSj 
7: 
8: 
switch (iFieldName) 
9: 
{ 
10: 
II For each field, set the field to the contents 
11: 
case Fld_EntryType: 
12: 
*ppData = (byte *)&(pRecord->m_type)j 
13: 
*piFieldType = AEEDB_FT_WORDj 
14: 
*piFieldLength = sizeof( uint16 )j 
15: 
breakj 
16: 
case Fld_Time: 
17: 
*ppData = (byte *)&(pRecord->m_nTime)j 
18: 
*piFieldType = AEEDB_FT_DWORDj 
19: 
*piFieldLength = sizeof( uint32 )j 
Staring Data 
191 

Chapter 7 
192 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: } 
} 
breakj 
case Fld_Miles: 
*ppData = (byte *)&(pRecord->m_nMiles)j 
*piFieldType = AEEDB_FT_DWORDj 
*piFieldlength = sizeof( uint32 )j 
breakj 
case Fld_Other: 
*ppData = (byte *)&(pRecord->m_nOther)j 
*piFieldType = AEEDB_FT_DWORDj 
*piFieldlength = sizeof( uint32 )j 
breakj 
case Fld_Cost: 
*ppData = (byte *)&(pRecord->m_nCost)j 
*piFieldType = AEEDB_FT_DWORDj 
*piFieldlength = sizeof( uint32 )j 
breakj 
case Fld_DueTime: 
*ppData = (byte *)&(pRecord->m_nDueTime)j 
*piFieldType = AEEDB_FT_DWORDj 
*piFieldlength = sizeof( uint32 )j 
breakj 
case Fld_DueMiles: 
*ppData = (byte *)&(pRecord->m_nDueMiles)j 
*piFie1dType = AEEDB_FT_DWORDj 
*piFieldlength = sizeof( uint32 )j 
breakj 
II We probably shouldn't be here. 
default: 
result = EBADPARMj 
breakj 
return resultj 
The DBThawRecord function does simply the opposite, as shown in listing 7 -9. 
Listing 7-9. Restoring a Serialized Record to Memory in DBThawRecord 
1: int DBThawRecord( IDBRecord *pRecord, 
2: 
CAppRecordPtr *ppResult ) 
3: { 
4: 
AEEDBFieldName iFieldNamej 
5: 
AEEDBFieldType iFieldTypej 

6: 
uint16 iFieldlength; 
7: 
uint16 iRecordID; 
8: 
CAppRecordPtr pResult; 
9: 
byte *pData; 
10: 
int result = SUCCESS; 
11: 
12: 
ASSERT( pRecord && ppResult ); 
13: 
14: 
II Allocate our result 
15: 
pResult = MAlLOC( sizeof( CAppRecord ) ); 
16: 
if ( !pResult ) return ENOMEMORY; 
17: 
*ppResult = pResult; 
18: 
MEMSET( pResult, 0, sizeof( CAppRecord ) ); 
19: 
20: 
II Begin at the beginning 
21: 
iRecordID = IDBRECORD_GetID( pRe cord ); 
22: 
IDBRECORD_Reset( pRecord ); 
23: 
24: 
II Get the first field 
25: 
iFieldType = IDBRECORD_NextField( pRecord, 
26: 
&iFieldName, &iFieldlength); 
27: 
28: 
II While there are fields to examine â¢â¢. 
29: 
while( result == SUCCESS && 
30: 
iFieldType != AEEDB_FT_NONE ) 
31: 
{ 
32: 
II Get the contents of this field 
33: 
pData = IDBRECORD_GetField( pRecord, &iFieldName, 
34: 
&iFieldType, &iFieldlength ); 
35: 
if (!pData) break; 
36: 
37: 
II Copy variable-length fields for storage 
38: 
if ( iFieldType == AEEDB_FT_BITMAP I I 
39: 
iFieldType == AEEDB_FT_BlNARY I I 
40: 
iFieldType == AEEDB_FT_STRING ) 
41: 
{ 
42: 
byte *pTemp = (byte *)MALLOC( iFieldLength ); 
43: 
44: 
if ( !pTemp ) return ENOMEMORY; 
45: 
MEMCPY( pTemp, pData, iFieldlength ); 
46: 
pData = pTemp; 
47: 
} 
48: 
result = AS_DBFieldFromDatabase( pResult, 
49: 
iFieldName, iFieldType, 
SmringDa~ 
193 

Chapter 7 
194 
50: 
pData, iFieldLength )j 
51: 
iFieldType = IDBRECORD_NextField( pRecord, 
52: 
&iFieldName, &iFieldLength)j 
53: 
} 
54: 
55: 
return resultj 
56: } 
After allocating space for the new record on lines 14-18, the routine 
iterates across each field of the database record using IDBRECORD _Reset and 
IDBRECORD _ NextField. For each field, the function copies database records that take 
a variable amount of space (lines 38-47) and then calls AS_DBFieldFromDatabase to 
convert those database fields and store them in the appropriate field of the appli-
cation's C structure representation of the database. 
Not surprisingly, AS_DBFieldFromDatabase is another switch statement, as 
shown in listing 7 -10. 
Listing 7-10. The AS_DBFieldFromDatabase Function 
1: int AS_DBFieldFromDatabase( CAppRecordPtr pRecord, 
2: 
AEEDBFieldName iFieldName, 
3: 
AEEDBFieldType iFieldType, 
4: 
byte *pData, uint16 iFieldLength ) 
5: { 
6: 
int result = SUCCESSj 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: } 
switch (iFieldName) 
{ 
} 
II For each field, set the field to the contents 
case Fld_unused: 
pRecord->unused = (uint16)*pDataj 
breakj 
II We probably shouldn't be here. 
default: 
result = EBADPARMj 
breakj 
return resultj 
These four functions are handy when you need to examine the contents of an 
entire record, but in many cases that's overkill. For example, if all you want to do is 

to sort records by the time a next service is due, all you really need to access is the 
Fld_DueTime for each record. Later, you can use the sorted list of record IDs to 
determine the order in which to display information to the user. (The next section 
discusses exactly how to perform this sort.) Although you could certainly load 
each record from the database, extract all of the fields, find the value of the 
Fld _DueTime field, and then destroy the record, this is rather expensive. Instead, you 
can use the utility function DBRecordField to get a copy of the value of a specific 
field (see Listing 7-11). 
Listing 7-11. Fetching a Specific Field from a Record 
1: int DBRecordField( IDBRecord *pRecord, 
2: 
3: 
4: 
5: { 
AEEDBFieldName iFieldName, 
AEEDBFieldType *piFieldType, 
void **ppResult, uint16 *piFieldlength ) 
6: 
AEEDBFieldType iFieldTypej 
7: 
AEEDBFieldName iThisFieldNamej 
8: 
byte *pDataj 
9: 
10: 
ASSERT( pRecord && piFieldType && piFieldType && 
11: 
ppResult && piFieldlength ) j 
12: 
13: 
II Begin at the beginning 
14: 
IDBRECORD_Reset( pRecord )j 
15: 
16: 
II Get the first field 
17: 
iFieldType = IDBRECORD_NextField( pRecord, 
18: 
&iThisFieldName, 
19: 
piFieldlength)j 
20: 
21: 
II While there are fields to examine â¢â¢â¢ 
22: 
while( iFieldType 1= AEEDB_FT_NONE ) 
23: 
{ 
24: 
II Is this the field we want? 
25: 
if ( iThisFieldName == iFieldName ) 
26: 
{ 
27: 
II Get the contents of this field 
28: 
pData = IDBRECORD_GetField( pRecord, &iFieldName, 
29: 
piFieldType, piFieldlength ) j 
30: 
if (!pData) break; 
31: 
32: 
II Copy the contents to a new buffer 
Storing Data 
195 

Chapter 7 
196 
33: 
*ppResult = (byte *)MALLOC( *piFieldLength )j 
34: 
if ( l*ppResult ) return ENOMEMORYj 
35: 
MEMCPY( *ppResult, pData, *piFieldLength ); 
36: 
return SUCCESS; 
37: 
} 
38: 
iFieldType = IDBRECORD_NextField( pRecord, 
39: 
&i This FieldName, 
40: 
piFieldLength)j 
41: 
} 
42: 
43: 
return EBADPARMj 
44: } 
This routine iterates over all fields in the specified database record 
(lines 22-41), searching for a specific field (lines 25-37). If the routine finds 
it (lines 28-36), it extracts the field's value (lines 28-29) and makes a copy of the 
value (lines 32-35), which you can use as you see fit and free when you're finished. 
Sorting Records for Display 
As mentioned previously in the chapter, there's no support for keeping database 
records sorted in a specific order. Instead, it's up to your application to sort records 
on demand, such as when presenting a list of items to the user. 
It's easy to keep a linked list of database record IDs and values of a specific 
field for use when sorting records. You can do this using a singly linked list and an 
insertion sort function that manages the linked list nodes (see listing 7-12). 
Listing 7-12. The Linked List Nodes and an Insertion Sort That Sorts Linked List 
Entries 
1: typedef struct _Node 
2: { 
3: 
struct _Node *m_pNextj 
4: 
void *m_pDataj 
5: 
void *m_pMetaDataj 
6: } Node; 
7: 
8: typedef struct _NumericNode 
9: { 
10: 
struct _NumericNode *m_pNextj 
11: 
uint32 m_nData; 
12: 
uint32 m_nMetaData; 

13: } NumericNodej 
14: 
15: typedef int32 (PFNNODEORDER)( void *pThis, 
16: 
Node *nl, 
17: 
Node *n2 )j 
18: typedef int32 (PFNNUMERICNODEORDER)( void *pThis, 
19: 
20: 
21: 
NumericNode *nl, 
NumericNode *n2 )j 
22: #define NodeLinkSorted ( pThis, head, n, fnSort, kind) \ 
23: { \ 
24: 
kind *_p = headj \ 
25: 
while( _p->m_pNext && fnSort( pThis, n, _p ) > 0 ) \ 
26: 
_p = _p->m-pNextj \ 
27: 
n->m_pNext = -p->m-pNextj \ 
28: 
_p->m_pNext = nj \ 
29: } 
This listing defines two kinds of nodes for linked lists: Node, which stores 
pointers to list items (used, among other things, by the framework's state machine 
management code), and NumericNode, which stores unsigned long integers. The 
nodes have the same structure and field names, which is important because by 
doing it that way you can use the macro NodeLinkSorted to sort Node and 
NumericNode lists. 
NodeLinkSorted takes five arguments: a pointer to your application's structure, 
the head of the list in which to insert a specific node, the node to insert, the 
function that provides comparison for nodes, and the type of node being used 
(either NumericNode or Node). The macro itself is about as close to making a C++ tem-
plate using C and the preprocessor as you can get; it uses the incoming type to 
define a temporary variable used to iterate across the linked list (lines 25-26) until 
it finds the right place to insert the new node (lines 27-28) as indicated by the com-
parison function. 
The comparison function is the same sort of comparison function you 
implement when using standard library utilities such as qsort on other platforms. 
For example, Listing 7 -13 is a simple test routine used to reverse-sort by time 
entries in the database and dump them to the debugging log. 
Listing 7-13. Testing the Sort Operation 
1: typedef NumericNode DBRecordCachej 
2: typedef NumericNode *DBRecordCachePtrj 
3: 
4: static int32 orderRecordsByTime( void *p, 
Storing Data 
197 

Chapter 7 
198 
5: 
DBRecordCacheptr nl, 
6: 
DBRecordCachePtr n2 ) 
7: { 
8: 
int32 result = OJ 
9: 
UNUSED( p )j 
10: 
II Compare the two 
11: 
return n2->m nMetaData - nl->m_nMetaDataj 
12: } 
13: 
14: static void sort( void *p ) 
15: { 
16: 
CAppPtr pThis = (CAppPtr)pj 
17: 
1DBMgr *p1DBMgrj 
18: 
1Database *p1Databasej 
19: 
1DBRecord *p1DBRecordj 
20: 
DBRecordCacheptr pNode, pHeadj 
21: 
AEEDBFieldType iFieldTypej 
22: 
uint16 iFieldLengthj 
23: 
uint32 *ptj 
24: 
CAppRecordPtr pRecordj 
25: 
26: 
pHead = MALLOC( sizeof( DBRecordCache ) )j 
27: 
if ( pHead ) 
28: 
{ 
29: 
MEMSET( pHead, 0, sizeof( DBRecordCache ) )j 
30: 
} 
31: 
else returnj 
32: 
33: 
II Open the database 
34: 
if ( 1SHELL_Create1nstance( GetShell( pThis ), 
35: 
AEECLS1D_DBMGR, (void **)&p1DBMgr ) != SUCCESS) 
36: 
returnj 
37: 
1DBMGR_Release( p1DBMgr )j 
38: 
if ( !p1Database ) returnj 
39: 
40: 
II Add each record's 1D to a list in the right order 
41: 
1DATABASE_Reset( p1Database )j 
42: 
p1DBRecord = 1DATABASE_GetNextRecord( p1Database )j 
43: 
44: 
while( p1DBRecord != NULL) 
45: 
{ 
46: 
pNode = (DBRecordCacheptr) 
47: 
MALLOC( sizeof( DBRecordCache ) )j 
48: 
if ( !pNode ) 

49: 
{ 
50: 
DBRecordCacheptr pTemp; 
51: 
pNode = pHead->m-pNext; 
52: 
while( pNode ) 
53: 
{ 
54: 
pTemp = pNode; 
55: 
pNode = pTemp->m-pNext; 
56: 
FREE( pTemp ); 
57: 
} 
58: 
return; 
59: 
} 
60: 
pNode->m_nData = IDBRECORD_GetID( pIDBRecord ); 
61: 
62: 
DBRecordField( pIDBRecord, Fldf_Time, 
63: 
&iFieldType, &pt, &iFieldLength ); 
64: 
pNode->m_nMetaData = *pt; 
65: 
FREE( pt ); 
66: 
67: 
NodeLinkSorted( pThis, pHead, pNode, 
68: 
orderRecordsByTime, DBRecordCache ); 
69: 
70: 
IDBRECORD_Release( pIDBRecord ); 
71: 
pI DB Record = IDATABASE_GetNextRecord( pIDatabase ); 
72: 
} 
73: 
II Iterate across all the nodes. 
74: 
II Dump their contents to the debug log 
75: 
pNode = pHead->m_pNext; 
76: 
77: 
while( pNode ) 
78: 
{ 
79: 
pRecord = NULL; 
80: 
pIDBRecord = IDATABASE_GetRecordByID( pIDatabase, 
81: 
(uint16)pNode->m_nData ); 
82: 
if ( pIDBRecord ) DBThawRecord( pIDBRecord, &pRecord ); 
83: 
if ( pRecord ) 
84: 
{ 
85: 
DBGPRINTF(nType : %d", pRecord->m_type ); 
86: 
DBGPRINTF("Time : %dR, pRecord->m_nTime ); 
87: 
DBGPRINTF("Miles: %dn, pRecord->m_nMiles ); 
88: 
DBGPRINTF("Cost : %do, pRecord->m_nCost ); 
89: 
DBGPRINTF("Other: %d", pRecord->m_nOther ); 
90: 
DBGPRINTF("Next (time) : %d", pRecord->m_nDueTime ); 
91: 
DBGPRINTF("Next (miles): %d", pRecord->m_nDueMiles ); 
92: 
} 
Storing Data 
199 

Chapter 7 
200 
93: 
if ( pIDBRecord ) IDBRECORD_Release( pIDBRecord ); 
94: 
if ( pRe cord ) FREE( pRecord ); 
95: 
pNode = pNode->m_pNext; 
96: 
} 
97: 
IDATABASE_Release( pIDatabase ); 
98: 
99: 
if ( pHead ) 
100: 
{ 
101: 
DBRecordCachePtr pTemp, pNode; 
102: 
pNode = pHead; 
103: 
while( pNode ) 
104: 
{ 
105: 
pTemp = pNode; 
106: 
pNode = pTemp->m_pNext; 
107: 
FREE( pTemp ); 
108: 
} 
109: 
} 
110: } 
The comparison function (lines 4-12) simply establishes the order of two 
nodes by subtracting their values. As you can see from this function, you use the 
node's m _ nData field to store a record's ID and the m _ MetaOata field to store the 
Fld _Time field of each record when ordering the records. 
The sort routine sort begins Gines 26-31) by allocating the head of the linked 
list, which will be a dummy element that refers to the first node in the list. Next, it 
opens the database using the IDBMgr interface Gines 34-38). Then, for each record 
in the database aines 44-72), the function creates a new node to hold that record's 
ID and Fld_Time information Oines 46-59, includingtbe cleanup code if there's an 
out-of-memory error), gets the record's database ID Oine 60) and Fld_Time datum 
aines 62-65), and uses NodelinkSorted to link the node into the list at the right 
location Oine 67-68). 
Once it has created the list, the remainder of the function walks across the 
linked list (starting with the first node, which is the node after the head, selected 
on line 75) with the while loop on lines 77-97. This code fetches the record 
interface for the node's database record by ID Oines 80-81) using 
IDATABASE_GetRecordByID, then gets the C structure representation of the record 
using the OBThawRecord function provided by the framework Oine 82), and then 
dumps each field of the record to the debugging console Oines 83-92). Once it does 
this, it releases the record Oine 93), frees the memory-resident representation of 
the record Oine 94), and moves to the next node (line 95). 
Finally, the routine releases the database Oine 97) and the memory used by the 
sort list aines 99-109) one node at a time. 

Summary 
You should remember the following key points after reading this chapter: 
â¢ QUALCOMM BREW provides a database interface that lets you store records 
consisting of multiple fields. 
â¢ The database implementation is best suited for storing multiple records of 
similarly structured data, and files are better for storing streams of data. 
â¢ There are three interfaces at your disposal for managing databases: IDBMgr, 
which lets you manipulate databases; IDatabase, which lets you manipulate 
a specific database; and IDBRecord, which gives you control over the contents 
of a specific record. 
â¢ When saving and loading records in a database, you must convert your 
memory-resident representation to and from an array of fields of type 
AEEDBField for the database interfaces. 
Storing Data 
201 

CHAPTER 8 
Drawing Graphics 
THE QUALCOMM BREW platform provides you with a rich set of graphics Appli-
cation Programming Interfaces (APIs) that you can use in your application. 
In previous chapters, you've seen just the tip of the iceberg: drawing text and 
simple bitmap graphics. It's time to delve deeper now and learn how you can 
use QUALCOMM BREW's graphics APIs to provide innovative user interfaces and 
vivid games. 
This chapter reviews the three kinds of graphics QUALCOMM BREW supports: 
bitmaps, basic graphics primitives, and sprites. You've already learned a bit about 
using bitmaps in the SlideShowapplication, but there's a lot more you can do with 
them. With QUALCOMM BREW's graphics primitives, your applications can draw 
text, lines, and shapes in various colors, creating both static images and anima-
tions for applications such as games. For game developers, later versions of 
QUALCOMM BREW provide an interface to a simple sprite and tile engine, freeing 
you of much of the tedium when developing games. Because RocketMileage does 
little with graphics, this chapter illustrates these interfaces using a variety of code 
snippets and small sample applications. 
Understanding QUALCOMM BREW Graphics Capabilities 
A key feature of QUALCOMM BREW since its inception has been its graphics APIs. 
Initial market research by QUALCOMM and many wireless carriers revealed a 
huge market opportunity for games, and providing first-class support for graphics 
to help game developers was an obvious step in realizing QUALCOMM BREW's 
potential. Moreover, these same graphics APIs enable a host of other applications, 
such as location-based services, with maps and other diagrams. 
The graphics APIs span several classes yet group functionality into three basic 
areas. The first, bitmap graphics, let you manipulate a bitmap image in a format 
such as the Wmdows BMP format, letting you copy the image to a region of the 
screen, transform the image, and so on. The second, graphics primitives, provides 
a vector-based approach to graphics, letting you construct a complex image using 
primitive graphics objects such as points, lines, arcs, circles, and ellipses. Finally, 
the third group of interfaces, implemented through the ISpri te interface, provides 
a tile map for creating backgrounds and sprites to represent individual items in 
front of that background. Using the ISprite class, you can create scrolling maps 
203 

Chapter 8 
204 
and side-scrolling, two-dimensional graphics games, or you can use the same 
class to create innovative user interfaces for your application. 
Over time, QUALCOMM has continued to improve its support for graphics, 
making QUALCOMM BREW arguably the best-of-breed platform for mobile 
graphics development. As a result, there are significant improvements in 
the graphics interfaces between the QUALCOMM BREW 1.0, 1.1, and 2.0 software 
releases; as a developer, you must recognize these differences when writing appli-
cations for specific handsets. It makes little sense, for example, for you to plan a 
game relying on the ISpri te interfaces in QUALCOMM BREW 2.0 only to find that 
you're expected to release the game on the Motorola T720 handset running 
QUALCOMM BREW 1.1. Table a-lUsts the graphics interfaces and in what version 
of QUALCOMM BREW you can find them. 
Table 8-1. QUALCOMM BREW Graphics APIs and BREWVersion 
INTERFACE 
PURPOSE 
QUALCOMM BREW VERSION 
IBitmap 
Bitmap management 
2.0 
lOIB 
Device-independent bitmaps 
2.0 
lOisplay 
Simple display-based graphics 
1.0, 1.1, 2.0 
functions 
IFont 
Font management (used by lOisplay) 
2.0 
IGraphics 
'!\vo-dimensional graphics primitives 
1.0, 1.1, 2.0 
ISprite 
Sprite and tile management 
2.0 
ITransform 
Bitmap transformations 
2.0 
Understanding QUALCOMM BREW Bitmaps 
QUALCOMM BREW provides you with an interface to blit-copy-bitmaps to 
various parts of the screen. In QUALCOMM BREW 1.0, the bitmap interface was 
rudimentary. It consisted only of the single interface: lOISPLAY_BitBlt. You could 
use lOISPLAY _ Bi tBlt to blit a Wmdows BMP file to the display using one of several 
copy modes, such as copying pixels from the source to the destination, binary-
ORing the pixels from the source and destination to determine the new value of 
each pixel, binary-XORing the pixels from the source and destination to determine 
the new value of each pixel, and so on. (The various bit blit options are defined 
by the AEERasterOp enumeration, which you can find in the file AEEDisp.h.) 

Drawing Graphics 
Using this bit blit operation requires two steps: converting an image into the 
handset's device-specific bitmap format from a Wmdows bitmap and then 
actually blitting the image to the display (see listing 8-1). 
Listing 8-1. BUtting to the Display 
1: void *pBitmap, *pDeviceBitmapi 
2: int xDest, yDest, cxDest, cyDest, xSource, ySourcei 
3: AEEImageInfo image Info = { 0 }i 
4: boolean bRealloci 
5: 
6: II Assemble the bits as a Windows BMP for pBitmap 
7: 
8: 
9: pImage = CONVERTBMP( pBitmap, &imageInfo, &bRealloc )i 
10: if ( pImage ) 
11: { 
12: 
IDISPLAY_BitBlt( GetDisplay(pThis), 
13: 
xDest, yDest, 
14: 
cxDest, cyDest, 
15: 
pImage, 
16: 
xSource, ySource, 
17: 
AEE_RO_COPY )i 
18: 
IDISPLAY_Update( this->m_pIDisplay ); 
19: } 
20: else 
21: { 
22: 
DBGPRINTF("CONVERTBMP failed!! ''')i 
23: } 
24: 
25: if ( bRealloc ) SYSFREE( pImage )i 
Starting with a bitmap in the Wmdows BMP format in the memory pointed to 
by plmage, the routine first converts the bitmap to the handset's native bitmap 
format using the function CONVERTBMP on line 9. This call is necessary because each 
handset manufacturer can choose to represent bitmaps in whatever format is best 
suited for its device. Because your application and QUALCOMM BREW don't have 
any knowledge about the format of the resulting bitmap, CONVERTBMP provides both 
with information about the resulting bitmap (in the AEElmagelnfo structure 
imageInfo) and about whether you must free the resulting bitmap using the flag 
bRealloc. CONVERTBMP will first try to perform the bitmap conversion in place and, if 
that fails, will allocate memory from the system heap to store the converted 
bitmap. 
205 

Chapter 8 
206 
If the conversion succeeds, CONVERTBMP returns a pointer to the device-specific 
bitmap, which you can use to blitto the screen using IDISPLAY_BitBlt (lines 12-17). 
This method takes a reference to the display, the rectangle on the screen that 
the bitmap will be copied to (defined by xDest, yDest, cxDest, and cyDest), the 
source bitmap (pImage), the top-right comer in the source bitmap (xSource, 
ySource) from which to blit, and the kind of bit blit operation to perform. 
Once the bit blit is complete, the code must free the device-specific bitmap if 
it was allocated by CONVERTBMP. Because CONVERTBMP uses the system heap rather 
than the application heap to store the device-specific bitmap, you must use the 
SYSFREE function to free the bitmap aine 25). 
Although the IDISPLAY _ Bi tBl t function is simple, there's a lot you can do with 
it, as you can see from the plethora of successful games available on handsets 
running QUALCOMM BREW 1.0 and 1.1. A common trick to save memory is to 
store an application's icons, images, and tiles in a single large bitmap and then use 
IDISPLAY _Bi tBl t to extract specific images from the bitmap. Although more 
complex than keeping a slew of bitmaps within your application, it has the 
advantage of saving a tremendous amount of Random-Access Memory (RAM) 
because you eliminate the overhead of the image header for each of the separate 
images. 
QUALCOMM BREW 2.0 has greatly enhanced bitmap capabilities by adding 
support for off-screen bitmaps in both handset-native and device-independent 
formats. Using the new IDisplay methods IDISPLAY_GetDeviceBitmap, 
IDISPLAY_GetDestination, and IDISPLAY_SetDestination, you can obtain or set a 
handle to the display's bitmap using the new IBi tmap interface. The IBi tmap 
interface provides you with methods to change the color value of a specific pixel, 
blit images into and out of the specified IBitmap instance, fill a rectangle in the 
bitmap with a particular color, and perform color conversions between the Red-
Green-Blue (RGB) color space and the color space of the bitmap itself. 
This off-screen bitmap support is best used for animations in which your 
application may need to perform a number of bit blit operations to update the 
position of several items between redrawing frames. When using a single bitmap-
such as the one provided in QUALCOMM BREW 1.0 using IDisplay-you must 
take great pains to ensure that the drawing and bit blit operations happen quickly 
enough to prevent flickering. This is a challenge for developers on all platforms but 
can quickly become insurmountable on limited hardware such as wireless 
handsets. To prevent flickering, you use a technique known as double-buffering in 
which you use two separate buffers. For each frame update, you first do all of the 
drawing and blitting to an off-screen bitmap, and once the frame update is com-
plete, blit the off-screen bitmap onto the on-screen bitmap. Doing this keeps 
updates to the screen to a minimum, avoiding flickering. (Double-buffering is 
available in QUALCOMM BREW 1.0 but only with the IGraphics interface.) 

Drawing Graphics 
Another new interface in QUALCOMM BREW 2.0 is the ITransform 
interface. This interface provides two bitmap-specific methods: 
ITRANSFORM _ TransformBi tSimple and ITRANSFORM _ TransformBi tComplex. 
ITRANSFORM_ TransformBi tSimple lets you perform simple transformations on a 
bitmap, including rotation by 90-degree intervals, flipping around the x axis, and 
scaling by powers of2 (changing the size of an image by2, by 4, orby8, or changing 
the size by 112,114, or 118). ITRANSFORM_TransformBitComplex lets you pass a matrix 
defining a specific transformation, including arbitrary rotation and scaling. 
Understanding QUALCOMM BREW Graphics Primitives 
QUALCOMM BREW provides two interfaces for creating graphics primitives: 
IDisplay and IGraphics. The IDisplay interface, which you first encountered in the 
HelloWorld example at the beginning of this book, is available in all versions of 
QUALCOMM BREW and gives you the ability to draw text, filled and hollow rect-
angles, and horizontal and vertical lines to the display. Using this interface you can 
create many simple diagrams and user interface primitives such as buttons, but 
it's not really suited for more advanced tasks such as games, maps, or charts. 
For more advanced graphics, you can use the IGraphics interface, available 
since QUALCOMM BREW 1.0. The IGraphics interface gives you more complex 
drawing operations than the simple ones provided by the IDisplay interface. In 
addition to the same basic features provided by IDisplay, the IGraphics interface 
provides additional shape-drawing capabilities, including the ability to draw 
points, ellipses, circles, arcs, triangles, rectangles, polygons, lines at any angle, and 
polylines (lines connecting multiple points). You can draw all of these as empty or 
filled regions in any color supported by the wireless handset. Unlike the simpler 
IDisplay interface, the IGraphics interface supports the notion of a view port. In 
other words, the handset's display is a movable window that shows a segment of a 
larger canvas. You can imagine the view port to be like a camera, showing just one 
segment of a larger screen. You can also control how each pixel is drawn to the 
canvas, setting a paint mode such as copy (pixel values are copied to the canvas), 
binary-OR or binary-exclusive-OR (pixel values are ORed or XORed with canvas 
pixel values to determine the drawn value), and so forth. 
Understandably, using an IGraphics instance is a little more complicated than 
using an IDisplay instance. Generally, you should follow these steps: 
1. Create an instance ofIGraphics using ISHELL_Createlnstance. 
2. Set the background color using IGRAPHICS_SetBackground. 
3. Set the view port using IGRAPHICS _ Setviewport. 
207 

Chapter 8 
208 
4. Set the foreground color using IGRAPHICS_SetColor. 
5. Set the fill color and fill mode if you're going to draw filled shapes using 
IGRAPHICS_SetFillColor and IGRAPHICS_SetFillMode. Uke 
IGRAPHICS_SetColor, you may want to repeat this step more than once for 
each shape. 
6. Set the paint mode using IGRAPHICS _SetPaintMode. Uke the previous two 
steps, you can change the paint mode between drawing shapes. 
7. Begin drawing using the functions IGRAPHICS _DrawPoint, 
IGRAPHICS_DrawLine, IGRAPHICS_DrawRect,IGRAPHICS_DrawArc, 
IGRAPHICS_DrawPie,IGRAPHICS_DrawPolygon,IGRAPHICS_DrawPolyline, 
and IGRAPHICS_DrawText. 
S. Update the display to show the drawn shapes periodically as your 
program requires by calling IGRAPHICS _Update. 
The sample code later in this chapter shows how to use the IGraphics interface 
in greater detail (see "Using the IGraphics Interface"). 
Understanding QUALCOMM BREW Sprite Operations 
The final interface for graphics in QUALCOMM BREW; ISprite, lets you use 
sprite-based graphics for fast animation. Available only on handsets running 
QUALCOMM BREW 2.0 or beyond, this new addition is bound to enable game 
developers to create new and interesting games for the platform. 
A sprite is a small bitmap with associated properties such as location, 
transparency, and an associated transformation to the bitmap that should be 
performed before the sprite is drawn. A sprite engine-such as the one imple-
mented by the ISpri te interface-manages drawing sprites in layers, giving the 
illusion of depth between sprites (often called two-and-a-half dimensions because 
an image composed with sprites has more depth than a traditional image) and the 
background, which is composed of tiles of individual, stationary bitmaps. You can 
have different -sized tiles and sprites, but all of your tiles and sprites for a given ani-
mation must be the same size. The ISpri te interface supports sprites and tiles that 
are SXS, 16X 16, 32X32, and 64X64 pixels in size and that are color with or without 
transparent pixels. For each ISpri te instance, your application can provide one set 
of background tiles and sprites to draw on four different layers, one on top of the 
other. 

Drawing Graphics 
Designing an application that uses sprites requires you take the time to create 
three kinds of graphic resources: 
â¢ A set of tile bitmaps that portrays the background for your animation 
â¢ A set of sprite bitmaps that portrays each of the objects in your animation 
â¢ One or more tile maps that specify which tiles should be drawn in what posi-
tions on your animation's background 
You store your tile and sprite images in independent bitmaps with the images 
for each sprite or tile ranging down in one long column in the bitmap, one image 
after the next. (For example, if you were using tiles of 8X8 pixels, your tile bitmap 
would be 8-pixels wide, with each tile following the other down the y axis.) You 
provide these bitmaps to the ISprite interface and refer to each tile or sprite by an 
index into the bitmap containing the item. For the first tile in your tile bitmap, for 
example, the index is 0; for the second, the index is I, and so forth. 
Your tile map is a little trickier. The tile map itself is a two-dimensional array of 
indexes into your tile bitmap. There's no standard BREW mechanism for storing a 
two-dimensional array of integers, so you have a number of choices depending on 
your application. If your background is random, you can create it on the fly in a 
memory region when your application starts. Otherwise, you can create tile maps 
as files-perhaps with a simple header that describes the x and y extents of the tile 
map and the specific tile bitmap to use-that contain a run of tile indexes. If the 
tile maps are sufficiently small, you might want to define them programmatically 
in your source code, perhaps as a structure in a header file that your application 
source code includes. 
CAUTION Beware, however, the temptation to store your tile map in a 
global variable. Although this will work in the emulator, it will fail hor-
riblyon the handset because QUALCOMM BREW applications can't have 
global variables. Instead, you need to define your tile map as a series of 
instructions in source code that allocates a region of memory for the tile 
map and then fills each integer memory location in the region with a 
tile index. 
209 

ChapterB 
210 
Once you design your sprites, tiles, and tile map to use the ISpri te instance in 
your application, you must do the following: 
1. Create an ISprite interface instance using ISHEll_CreateInstance. 
2. Create a target bitmap onto which the ISpri te interface will render the 
tiles and sprites. (You can do this using the IDisplay interface.) 
3. Use the ISPRITE_SetDestination method to bind the bitmap to the ISprite 
interface. 
4. Initialize the ISpri te interface's tile buffer using the ISPRITE _ SetTileBuffer 
method, passing it your bitmap of tiles. 
5. Initialize the ISprite interface's sprite buffer using the 
ISPRITE_SetSpriteBuffer method, passing it your bitmap of sprites. 
6. Draw your tile map using the ISprite interface's ISPRITE_DrawTiles 
method. 
7. Draw your sprites using the ISprite interface's ISPRITE_DrawSprites 
method. 
8. Blit the bitmap you created in step 2 to the display. 
9. Perform whatever computations are necessary to update the locations of 
each sprite. 
10. Redraw your sprites starting at step 7 and continue until you're done with 
your animation. 
You'll see an example of using the ISpri te method later in this chapter (see 
"Using the ISprite Interface"). 
Using the IGraphics Interface 
The GraphicsSample application that accompanies this book shows you how to 
use the IGraphics interface to draw various shapes, as well as pan the view port 
around a drawing. This application is simple; all it does is draw a handful of 
random shapes to a canvas and let you scroll around the canvas. Figure 8-1 shows 
the GraphicsSample application in action. 

Drawing Graphics 
Figure 8-1. The GraphicsSample application 
The GraphicsSample application demonstrates the three key parts of using 
the IGraphics interface: initializing the interface and its view port, drawing to its 
canvas, and positioning the view port after drawing. Let's look at each of these 
in tum. 
Initializing the IGraphics Interface 
Using the GraphicsSample framework, the GraphicsSample interface uses a single 
state and keeps all of its data in its application data pointer (see Listing 8-2). 
Listing 8-2. The GraphicsSample Application Data 
1: typedef struct 
2: { 
3: 
IGraphics *pIGraphics; 
4: 
uint16 cxCanvas, cyCanvas; 
5: 
uint16 x, y; 
6: 
uint16 arRandom[ NUMSHAPES * POINTSPERSHAPE ]; 
7: } CAppData, *CAppDataptr; 
You store the application's IGraphics instance-allocated in the AS_Init 
function, which you'll see next-along with the extents and center point on the 
canvas view port being displayed in this structure. You also keep a record of 
the shapes the application chooses to draw in arRandom, which you fill with random 
numbers to determine the kind, position, and size of each shape. 
The AS_Init function creates the CAppData structure using MALLOC, creates an 
IGraphics instance, and initializes the extents and center points of the drawing 
canvas (see Listing 8-3). 
211 

ChapterB 
212 
Listing 8-3. Initializing the GraphicsSample Application 
1: int AS_Init( CAppPtr pThis ) 
2: { 
3: 
CAppDataptr pAppData; 
4: 
int result = EFAILED; 
5: 
6: 
AS5ERT( pThis ); 
7: 
8: 
II Create the application's global data here. 
9: 
pAppData = MALLOC( sizeof( CAppData ) ); 
10: 
11: 
if ( pAppData ) 
12: 
{ 
13: 
MEMSET( pAppData, 0, sizeof( CAppData ) ); 
14: 
15: 
II Set our canvas size 
16: 
pAppData->cxCanvas = VIEW_EXTENTS; 
17: 
pAppData->cyCanvas = VIEW_EXTENTS; 
18: 
19: 
II Set the default view port position to 
20: 
II the center of the extents 
21: 
pAppData->x = pAppData->cxCanvas I 2; 
22: 
pAppData->y = pAppData->cyCanvas I 2; 
23: 
24: 
SetAppData( pThis, pAppData ); 
25: 
result = ISHELL_CreateInstance( GetShell( pThis ), 
26: 
AEECLSID_GRAPHICS, 
27: 
(void **) &(pAppData->pIGraphics) ); 
28: 
} 
29: 
30: 
return result; 
31: } 
The VIEW_EXTENTS constant is defined elsewhere and merely sets the size of the 
drawing canvas that you use with IGraphics. You use the cxCanvas and cyCanvas 
members of the application data structure to set the clipping region for the 
IGraphics instance. 
The actual shape creation occurs when you first enter the main state in 
mainEntry (see Listing 8-4). 

Drawing Graphics 
Listing 8-4. Creating Shapes 
1: static boolean mainEntry( void *p, 
2: 
EStateChangeCause change) 
3: { 
4: 
CAppPtr pThis = (CAppPtr)p; 
5: 
CAppDataPtr pData; 
6: 
7: 
UNUSED( change ); 
8: 
9: 
ASSERT( pThis ); 
10: 
11: 
pData = GetAppData( pThis ); 
12: 
13: 
II Clear the display 
14: 
IDISPLAY_ClearScreen( GetDisplay( pThis ) ); 
15: 
16: 
II Decide what to draw. 
17: 
II We're going to get a shape, colors, and three coordinates 
18: 
II for each shape 
19: 
20: 
II Get a buffer filled with random numbers 
21: 
GETRAND( (byte *)pData->arRandom, 
22: 
NUMSHAPES * 5 * sizeof( uint16 ) ); 
23: 
24: 
IGRAPHICS_Pan( pData->pIGraphics, x, y ); 
25: 
26: 
II Do some drawing 
27: 
mainDraw( pThis ); 
28: 
29: 
return TRUE; 
30: } 
After clearing the display (line 14), the routine fills the array member arRandom 
of the application's data pointer with random bytes using the GETRAND helper 
function (lines 21-22). This function, a replacementto the ISHE LL _ Get Rand function 
available in early QUALCOMM BREW-enabled handsets, uses the system clock 
and other handset components to generate a sequence of pseudorandom bytes. 
Because it relies on the system clock, you shouldn't call this function more than 
once every few hundred milliseconds, or the results may not be sufficiently 
random. These random bytes will be used by mainDraw to determine what shapes 
will be drawn, as well as the shapes' positions, fills, and colors. 
213 

Chapter 8 
214 
Next, on line 24, the routine centers the IGraphics view port in the middle 
of the drawing canvas. After that, the routine invokes the function mainDraw to draw 
the shapes specified in arRandom. 
Drawing on the IGraphics Canvas 
With the IGraphics context initialized and the shapes determined, it's time to draw 
the shapes on the canvas. The application invokes mainDraw in two places: initially 
in mainEntry and again whenever you move the view port with the directional pad 
(discussed in the next section). 
Listing 8-5 shows the mainDraw function. 
Listing 8-5. mainDraw 
1: static void mainDraw( CAppPtr pThis ) 
2: { 
3: 
CAppDataPtr pData = GetAppData( pThis ); 
4: 
uint16 iShape, i; 
5: 
IGraphics *pIGraphics = pData->pIGraphics; 
6: 
AEEClip clip = { 0 }; 
7: 
AEETriangle triangle; 
8: 
AEERect rectangle; 
9: 
AEEEllipse ellipse; 
10: 
byte r, g, b, shape; 
11: 
boolean fill; 
12: 
uint16 *arRandom = pData->arRandom; 
13: 
14: 
i = OJ 
15: 
16: 
II Clear our canvas 
17: 
IGRAPHICS_SetBackground( pIGraphics, 255, 255, 255 ); 
18: 
IGRAPHICS_ClearViewport( pIGraphics ); 
19: 
20: 
II Set our clipping region 
21: 
clip. type = ClIPPING_RECTj 
22: 
clip.shape.rect.x = OJ 
23: 
clip.shape.rect.y = OJ 
24: 
clip.shape.rect.dx = pData->cxCanvasj 
25: 
clip.shape.rect.dy = pData->cyCanvasj 
26: 
IGRAPHICS_SetClip( pIGraphics, &clip, 0 )j 
27: 
28: 
for ( iShape = OJ i5hape < NUMSHAPESj iShape++ ) 

Drawing Graphics 
29: 
{ 
30: 
shape = (byte)(arRandom[ i++ ] % 3); 
31: 
r = (byte)(arRandom[ i++ ] % 255 ); 
32: 
g = (byte)(arRandom[ i++ ] % 255 ); 
33: 
b = (byte)(arRandom[ i++ ] % 255 ); 
34: 
fill = (boolean)( ( arRandom[ i ] Â» 8 ) && OXl ); 
35: 
36: 
II Set the fill eolor and mode for this shape 
37: 
IGRAPHICS_SetFiIIColor( pIGraphies, r, g, b, 0 ); 
38: 
IGRAPHICS_5etFiIIMode( pIGraphies, fill ); 
39: 
40: 
II Add a random shape 
41: 
switeh( arRandom[i] % 3 ) 
42: 
{ 
43: 
ease 0: 
44: 
II Draw a triangle 
45: 
triangle.xO = arRandom[ i++ ] % VIEW_EXTENTS; 
46: 
triangle.yo = arRandom[ i++ ] % VIEW_EXTENTS; 
47: 
triangle.xl = arRandom[ i++ ] % VIEW_EXTENTS; 
48: 
triangle.yl = arRandom[ i++ ] % VIEW_EXTENTS; 
49: 
triangle.x2 = arRandom[ i++ ] % VIEW_EXTENTS; 
50: 
triangle.y2 = arRandom[ i++ ] % VIEW_EXTENTS; 
51: 
IGRAPHICS_DrawTriangle( pIGraphies, &triangle ); 
52: 
break; 
53: 
54: 
ease 1: 
55: 
II Draw a square 
56: 
reetangle.x = arRandom[ i++ ] % VIEW_EXTENTS; 
57: 
reetangle.y = arRandom[ i++ ] % VIEW_EXTENTS; 
58: 
reetangle.dx = arRandom[ i++ ] % VIEW_EXTENTS I 4; 
59: 
reetangle.dy = arRandom[ i++ ] % VIEW_EXTENTS I 4; 
60: 
IGRAPHICS_DrawReet( pIGraphies, &reetangle ); 
61: 
break; 
62: 
63: 
ease 2: 
64: 
II Draw an ellipse 
65: 
ellipse. ex = arRandom[ i++ ] % VIEW_EXTENTS; 
66: 
ellipse.ey = arRandom[ i++ ] % VIEW_EXTENTS; 
67: 
ellipse.wx = arRandom[ i++ ] % VIEW_EXTENTS I 4; 
68: 
ellipse.wy = arRandom[ i++ ] % VIEW_EXTENTS I 4; 
69: 
IGRAPHICS_DrawEllipse( pIGraphies, &ellipse ); 
70: 
break; 
71: 
} 
72: 
} 
215 

Chapter 8 
216 
73 : 
74: 
II Update the display 
75: 
IGRAPHICS_Update( pIGraphics ); 
76: } 
Functionally, this routine has four separate sections. In the first, it allocates all 
of its temporary variables (for clarity, there are a lot!) on lines 3-14. In the second, 
on lines 16-26, the routine initializes the IGraphics instance. In the third, on 
lines 30-38, the routine sets the drawing attributes for a specific shape. Finally, the 
swi tch statement on lines 41- 72 determines whether to draw a triangle, rectangle, 
or ellipse, and then it sets the coordinates for the selected shape before drawing 
the shape. 
The routine begins manipulating the IGraphics interface on line 16, where it 
first sets the background to white (with the values for red, green, and blue 
each 255), and then clears that portion of the canvas. Next, on lines 20-26, the 
routine sets the canvas's clipping region to the bounds defined in the applications 
data structure. The IGRAPHICS_SetClip method lets you select a variety of clipping 
shapes, including triangles and polygons. When you invoke IGRAPHICS _ SetClip, you 
pass an AEEClip structure that contains a type field that describes the shape of the 
region to clip and a union shape that contains the coordinates of the clipping 
shape. 
TIP Not all versions ofQUALCOMM BREW support all clipping shapes, 
so it's best to check theAP! documentation when designing your graphics 
code to ensure that there's support for the clipping regions you desire on 
the handsets you're targeting. 
Next, for each shape to draw (line 28), the routine selects a shape using a 
random number in arRandom, followed by the red, green, and blue color values for 
the shape on lines 29-31. Finally, the routine uses a single random bit to determine 
whether the shape should be filled or empty. 
The switch statement on lines 41-72 simply chooses a shape to draw, fills the 
structure for that shape with the shape's coordinates, and then draws the shape 
using the appropriate method of pIGraphics. Note, however, that different shapes 
denote their coordinates in different ways. For example, an AE ERect structure 
denotes a rectangle by its upper-left comer, width, and height, and an AEEEllipse 
structure denotes an ellipse by its center coordinate and its major and semimajor 
axes. 
The routine concludes on line 75 by updating the display with the call to 
IGRAPHICS_Update. 

Drawing Graphics 
Positioning the View Port 
The GraphicsSample routine lets you pan around the canvas to see the various 
shapes that it draws. You do this using the directional pad on the handset, pressing 
and holding the key in the direction you want to pan. In turn, the shell sends 
the application EVT_KEY_PRESS, EVT_KEY_HELD, and EVT_KEYevents, which the 
application uses to determine when to start and stop panning. The event 
handler ASj1ainHandleEvent invokes the function mainHandleKey to process the 
EVT _KEY _PRESS and EVT _KEY _HELD events and pan the view port around the canvas 
(see listing 8-6). 
Listing 8-6. Handling Key Events for Scrolling 
1: static boolean mainHandleKey( CAppptr pThis, uint16 wParam ) 
2: { 
3: 
boolean result = FALSE; 
4: 
int dx, dy; 
5: 
int32 newX, newY; 
6: 
CAppDataPtr pAppData = GetAppData( pThis ); 
7: 
8: 
dx = dy = 0; 
9: 
10: 
switch( wParam ) 
11: 
{ 
12: 
case AVK_UP: 
13: 
dy = -( pThis->m_cy / 4 ); 
14: 
result = TRUE; 
15: 
break; 
16: 
case AVK_DOWN: 
17: 
dy = ( pThis->m_cy / 4 ); 
18: 
result = TRUE; 
19: 
break; 
20: 
case AVK_LEFT: 
21: 
dx = -( pThis->m_cx / 4 ); 
22: 
result = TRUE; 
23: 
break; 
24: 
case AVK_RIGHT: 
25: 
dx = ( pThis->m_cx / 4 ); 
26: 
result = TRUE; 
27: 
break; 
28: 
} 
29: 
30: 
if ( result ) 
217 

Chapter 8 
218 
31: 
{ 
32: 
II Adjust the view port in the correct direction 
33: 
newX = pAppData->x + dx; 
34: 
newY = pAppData->y + dy; 
35: 
36: 
II Pin scrolling within our canvas 
37: 
if ( newX < 0 ) newX = 0; 
38: 
if ( newY < 0 ) newY = 0; 
39: 
if ( newX > VIEW_EXTENTS ) newX = VIEW_EXTENTS; 
40: 
if ( newY > VIEW_EXTENTS ) newY = VIEW_EXTENTS; 
41: 
42: 
pAppData->x = (uint16)newX; 
43: 
pAppData->y = (uint16)newY; 
44: 
IGRAPHICS_Pan( pAppData->pIGraphics, 
45: 
pAppData->x, pAppData->y ); 
46: 
mainDraw( pThis ); 
47: 
} 
48: 
49: 
return result; 
50: } 
The initial switch statement (lines 10-28) simply determine what key you're 
holding down and sets the variables dx and dy to one-quarter the view port's size to 
determine how far to scroll. Next, if one of the four directional keys is held down 
(line 30), the routine calculates a new center point on the canvas and stores it in 
the variables newX and newY. 
Next, the code tests the new coordinates to ensure that the center point is on 
the canvas using the four comparisons on lines 37-40 and setting out-of-bound 
points to the canvas extents as necessary. Then, it updates the application 
structure's notion of the center point on lines 42-43 and pans the view port to the 
new center point. Finally, it redraws the shapes on the canvas on line 46 by 
invoking mainDraw. 
Invoking mainDraw is crucial because IGraphics doesn't store a record of the 
shapes you draw to its canvas, and it doesn't use a bitmap to represent its canvas. 
Because of the limited memory size of most wireless handsets, it'd be prohibitively 
expensive in many cases to do this, so you must track the shapes on your canvas 
that you might want to redraw later. Typically, using an array of shape selections, 
attributes, and points-much like in this example-is sufficient for many applica-
tions. Of course, you can store this data wherever it's most appropriate, either in 
memory or on the local file system. 

Drawing Graphics 
Using Coordinates vs. Points 
With QUALCOMM BREW providing an AEEPoint structure to represent points, 
you might wonder why all of the code in this section refers to points using raw 
integer coordinates, such as newX and newY, rather than a single AEEPoint struc-
ture newPoint. 
To be honest, there's really no reason to pick one method over the other. 
Because I find it easier to follow code that uses explicit variables for each coordi-
nate, I chose to write this code in that style as well. However, if you find it easier 
to think of points in terms of AEEPoint structures, go right ahead! 
Using the ISprite Interface 
To demonstrate the ISprite interface, you'll look at a simple game called Neko to 
Nonezumi (cat and mouse), which you can see in Figure 8-2. 
Figure 8-2. The Neko to Nonezumi game 
The game itself is quite simple-too simple for all but toddlers probably, but 
that's okay because it's supposed to show you how to use the ISpri te interface, not 
how to write a game! When the game starts, you use the directional pad to move 
the cat toward the mouse, catching the mouse by cornering it on the screen and 
hovering over it. 
The application uses the ISprite interface to manage everything visible on the 
display: the cat and mouse, the two butterflies, and the grassy field dotted with 
flowers. Let's see how it works. 
219 

ChapterB 
220 
Defining the Tiles and Sprites 
The application has four sprites (one cat, one mouse, and two different -colored 
butterflies) and three tiles. You can see all of them in Figure 8-3, where they're 
drawn by the application when you enable the DEBUG_SPRITES definition in 
AppStates.c. 
Figure 8-3. The sprite images (on the left) and tile images (on the right) 
Each tile and sprite image is a separate bitmap in the application's BREW 
Archive (BAR) file. For consistency, you can number the sprite images starting 
from resource ID 5,000 and the tile images starting from resource 6,000. 
As the application initializes, the AS _ Ini t function loads each of the sprite and 
tile bitmaps and creates the sprite and tile buffers used by the ISprite interface 
with help from several helper functions (see Listing 8-7). 
Listing 8-7. Loading Sprite and Tile Maps 
1: int AS_Init( CAppPtr pThis ) 
2: { 
3: 
CAppDataPtr pAppDataj 
4: 
int result = EFAILEDj 
5: 
uint16 arRandom[ 256 
]j 
6: 
int width, heightj 
7: 
IBitmap *pIBitmapj 
8: 
ISprite *pISpritej 
9: 
10: 
width = 8j 
11: 
height = 8j 
12: 
13: 
ASSERT( pThis )j 
14: 
15: 
II Create the application's global data here. 
16: 
pAppData = MALLOC( sizeof( CAppData ) )j 

17: 
18: 
if ( pAppData ) 
19: 
{ 
20: 
MEMSET( pAppData, 0, sizeof( CAppData ) )j 
21: 
22: 
II Get our sprite interface 
23: 
result = ISHELL_CreateInstance( GetShell( pThis ), 
24: 
AEECLSID_SPRITE, 
25: 
(void **) &(pAppData->pISprite) )j 
26: 
pI5prite = pAppData->pISpritej 
27: 
28: 
if ( result == SUCCESS ) 
29: 
{ 
30: 
II Get a bag of random numbers 
31: 
GETRAND( (byte *)arRandom, 
32: 
256 * sizeof( uint16 ) )j 
34: 
35: 
II Initialize our sprites 
36: 
initSprites( pAppData->arSprites )j 
37: 
result = loadSprites( pThis, &pIBitmap )j 
38: 
if ( result 1= SUCCESS) 
39: 
{ 
40: 
if ( pIBitmap ) IBITMAP_Release( pIBitmap )j 
41: 
ISPRITE_Release( pISprite )j 
42: 
return resultj 
43: 
} 
44: 
ISPRITE_SetSpriteBuffer( pISprite, 
45: 
TILE_SIZE_16X16, 
46: 
pIBitmap )j 
47: 
IBITMAP_Release( pI Bitmap )j 
48: 
49: 
pIBitmap = NULLj 
50: 
51: 
II Initialize our tile map 
52: 
result = initTiles( pThis, 
53: 
pAppData->arTileMap, 
54: 
width, height, 
55: 
arRandom )j 
56: 
if ( result 1= SUCCESS) 
57: 
{ 
58: 
if ( pI Bitmap ) IBITMAP_Release( pIBitmap )j 
59: 
ISPRITE_Release( pISprite )j 
60: 
return resultj 
61: 
} 
Drawing Graphics 
221 

ChapterB 
222 
62: 
result = loadTiles( pThis, &pIBitmap )j 
63: 
if ( result != SUCCESS) 
64: 
{ 
65: 
if ( pIBitmap ) IBITMAP_Release( pIBitmap )j 
66: 
ISPRITE_Release( pI Sprite )j 
67: 
return resultj 
68: 
} 
69: 
ISPRITE_SetTileBuffer( pISprite, 
70: 
TILE_SIZE_16X16, 
71: 
pI Bitmap ) j 
72: 
IBITMAP_Release( pIBitmap )j 
73: 
74: 
II Set the destination 
75: 
result = createBitmap( pThis, 
76: 
pThis->m_cx, pThis->m_cy, 
77: 
&pIBitmap ) j 
78: 
if ( result != SUCCESS) 
79: 
{ 
80: 
ISPRITE_Release( pISprite )j 
81: 
return resultj 
82: 
} 
83: 
ISPRITE_SetDestination( pAppData->pISprite, pIBitmap )j 
84: 
pAppData->pIBitmap = pIBitmapj 
85: 
86: 
II Stash aside our application globals 
87: 
SetAppData( pThis, pAppData )j 
88: 
} 
89: 
} 
90: 
91: 
return resultj 
92: } 
The interesting bits start at line 23, where you create an instance of ISpri teo If 
this succeeds, you stash a copy away in the local pISprite variable (to save typing 
and improve legibility in the printed listing) and proceed to get 256 random 
numbers using GETRAND. The routine then calls ini tSpri tes on line 36 (described 
next), which sets the position and other information for each sprite. After that, it 
calls loadSprites on line 37, which loads each of the sprite images and composites 
them on one big bitmap. After setting the sprite buffer using 
ISPRITE_SetSpriteBuffer on line 44, you release the sprite buffer's bitmap because 
it's now owned by the ISpri te interface and will be freed when the interface is 
released. Lines 51-72 do the same for the tile map: They create an array of tiles in 
initTiles, load each of the tile images, composite them into a bitmap using 

Drawing Graphics 
loadTiles, and set the tile buffer using ISPRITE_SetTileBuffer. Next, you create the 
destination bitmap-where the ISprite instance blits all of the tiles and sprites-
using the utility function createBi tmap and set the destination bitmap for the 
interface using its ISPRITE_SetDestination method. 
Initializing Sprites and Tiles 
Each sprite is described by an instance of the structure AEESpriteCmd (see 
listing 8-8). 
Listing 8-8. Sprite and Tile Structures 
1: typedef struct { 
2: 
int16 Xj 
3: 
int16 Yj 
4: 
uint16 unTransformj 
5: 
uint8 unMatrixTransformj 
6: 
uint8 unSpritelndexj 
7: 
uint8 unSpriteSizej 
8: 
uint8 unCompositej 
9: 
uint8 unLayerj 
10: 
uint8 reserved[5]j 
11: } AEESpriteCmdj 
This structure stores the sprite's current position in the destination bitmap 
(lines 2 and 3), the transform to apply to the sprite image when blitting it to the 
bitmap Oines 4-5), the index into the sprite buffer to the image for the sprite 
(line 6), the size of the sprite (line 7), whether the sprite is opaque or has trans-
parency data Oine 8), and the layer into which the sprite should be placed. Several 
of these fields-unTransform, unSpriteSize, and unComposite---should be set using 
constants defined inAEESprite.h. The initSprites function called by AS_Init does 
what's shown in listing 8-9. 
Listing 8-9. Initializing the Sprites 
1: static void initSprites( AEESpriteCmd *pSprites ) 
2: { 
3: 
pSprites[Sprite_Mouse].x = 32j 
4: 
pSprites[Sprite_Mouse].y = 32j 
5: 
6: 
7: 
pSprites[Sprite_Mouse].unTransform = OJ 
pSprites[Sprite_Mouse].unSpriteSize = SPRITE_SIZE_16X16j 
pSprites[Sprite_Mouse].unSpritelndex = Sprite_Mousej 
223 

ChapterB 
224 
8: 
pSprites[Sprite_Mouse].unlayer = 1; 
9: 
pSprites[Sprite_Mouse].unComposite = COMPOSITE_KEYCOlOR; 
10: 
11: 
pSprites[Sprite_Cat].x = 128 - 32; 
12: 
pSprites[Sprite_Cat].y = 128 - 32; 
13: 
pSprites[Sprite_Cat].unTransform = TRANSFORM_SCAlE_2; 
14: 
pSprites[Sprite_Cat].unSpriteSize = SPRITE_SIZE_16X16; 
15: 
pSprites[Sprite_Cat].unSpritelndex = Sprite_Cat; 
16: 
pSprites[Sprite_Cat].unlayer = 1; 
17: 
pSprites[Sprite_Cat].unComposite = COMPOSITE_KEYCOlOR; 
18: 
19: 
pSprites[Sprite_Butterfly_Red].x = 32; 
20: 
pSprites[Sprite_Butterfly_Red].y = 128 - 32; 
21: 
pSprites[Sprite_Butterfly_Red].unTransform = 0; 
22: 
pSprites[Sprite_Butterfly_Red].unSpriteSize = 
23: 
SPRITE_SIZE_16X16; 
24: 
pSprites[Sprite_Butterfly_Red].unSpritelndex = 
25: 
Sprite_Butterfly_Red; 
26: 
pSprites[Sprite_Butterfly_Red].unlayer = 3; 
27: 
pSprites[Sprite_Butterfly_Red].unComposite = 
28: 
COMPOSITE_KEYCOlOR; 
29: 
30: 
pSprites[Sprite_Butterfly_Blue].x = 128 - 32; 
31: 
pSprites[Sprite_Butterfly_Blue].y = 32; 
32: 
pSprites[Sprite_Butterfly_Blue].unTransform = 0; 
33: 
pSprites[Sprite_Butterfly_Blue].unSpriteSize = 
34: 
SPRITE_SIZE_16X16; 
35: 
pSprites[Sprite_Butterfly_Blue].unSpritelndex = 
36: 
Sprite_Butterfly_Blue; 
37: 
pSprites[Sprite_Butterfly_Blue].unlayer = 3; 
38: 
pSprites[Sprite_Butterfly_Blue].unComposite = 
39: 
COMPOSITE_KEYCOlOR; 
40: 
41: 
pSprites[Sprite_last].x = 0; 
42: 
pSprites[Sprite_last].y = 0; 
43: 
pSprites[Sprite_last].unTransform = 0; 
44: 
pSprites[Sprite_last].unSpriteSize = SPRITE_SIZE_END; 
45: 
pSprites[Sprite_last].unSpritelndex = 0; 
46: 
pSprites[Sprite_last].unlayer = 0; 
47: 
pSprites[Sprite_Butterfly_Blue].unComposite = 0; 
48: } 

Drawing Graphics 
The sprite array-stored within the application's data structure-consists of 
an AEESpri teCmd for each of the four sprites and a final entry with the unSpri teSize 
field set to the special constant SPRITE_SIZE_END, indicating the end of the sprite 
array. For all of the sprites except the cat's sprite, there are no transformations at 
first. However, the cat (because he's bigger than the mouse or the butterflies) has 
its unTransform field set to TRANSFORM_SCAlE_2 so that the cat's bitmap is scaled to 
twice the size of the preset bitmap. All of the sprites are 16X 16 pixels, as you can 
see from the unSpri teSize values of SPRITE _SIZE _16X16. (You could've used a sprite 
ofsize SPRITE_SIZE _32X32 and created a cat sprite that's 32 pixels on a side, but then 
you would've needed another sprite buffer bitmap to store it for the ISpri te 
instance.) 
Tiles, on the other hand, are represented using the AEETileMap structure (see 
listing 8-10). 
Listing 8-1 O. Initializing the Tiles 
1: typedef struct { 
2: 
uint16 *pMapArraYj 
3: 
uint32 unFlagsj 
4: 
uint32 reserved[4]j 
5: 
int32 Xj 
6: 
int32 Yj 
7: 
uint16 Wj 
8: 
uint16 hj 
9: 
uint8 unTileSizej 
10: 
uint8 reserved2[3]j 
11: } AEETileMapj 
The first element of the structure, pMapArray (line 4), points to a memory 
region of unsigned words with each word containing information about a specific 
tile in a bit field, including: 
â¢ Its offset in the tile buffer 
â¢ Whether to rotate or flip the tile 
â¢ Whether the tile has transparency data 
The x and y members (lines 5-6) specify the upper-left comer of the tile map 
on the destination bitmap. The w and h members (lines 7-8) specify the size of the 
bitmap, not in pixels or tiles, but using one of the MAP_SIZE constants defined in 
AEESprite.h. Tile maps can be any square whose side is a power of 2 between 20 (1) 
and 210 (1,024). 
225 

Chapter 8 
226 
CAUTION Unpredictable things can happen if you specify sizes using 
these members without using these constants. In debugging this sample, 
[ had a host of odd errors-from random crashes to peculiar-looking tile 
maps as the ISprite instance read off the ends of the pMapArray array. 
Another source of unpredictability are the reserved and the reserved2 
fields. [fyou don't set them to 0, strange and terrible things can happen to 
your application. 
The AS_Init function calls the function initTiles to initialize the tile map (see 
Listing 8-11). 
Listing 8-11. Filling the Tile Map 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11 : 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
static int initTiles( CAppPtr pThis, 
AEETileMap *pTileMap, 
{ 
int width, int height, 
uint16 *pRandom ) 
int i ; 
uint16 *pTile; 
int flower = 0; 
II Create the tile map array 
pTileMap->pMapArray = (uint16 *) 
MAllOC( width * height * sizeof( uint16 ) ); 
if ( !pTileMap->pMapArray ) return ENOMEMORY; 
I I Now fill it 
pTile = pTileMap->pMapArray; 
for ( i = 0; 
{ 
i < ( width * height ); 
i++ ) 
*pTile = *pRandom % 24; 
II Only 1 in 24 tiles has a flower (statistically speaking) 
if ( *pTile == 0 ) 
{ 
II Get another random bit to choose the tile 
if ( flower % 2 ) 
{ 

29: 
} 
30: 
else 
31: 
{ 
32: 
*pTile = Tile_Purple; 
33: 
} 
34: 
flower++; 
35: 
} 
36: 
else 
37: 
{ 
38: 
*pTile = Tile_Grass; 
39: 
} 
40: 
pRandom++; 
41: 
pTile++; 
42: 
} 
43: 
44: 
II Position the tile map on the destination bitmap 
45: 
pTileMap->x = 0; 
46: 
pTileMap->y = 0; 
47: 
pTileMap->w = MAP_SIZE_8; 
48: 
pTileMap->h = MAP_SIZE_8; 
49: 
50: 
II The tiles are 16x16 pixels 
51: 
pTileMap->unTileSize = TILE_SIZE_16X16; 
52: 
53: 
II No flags 
54: 
pTileMap->unFlags = 0; 
55: 
56: 
II You MUST set these to zero, or bad things happen 
57: 
pTileMap->reserved[ 0 ] = 
58: 
pTileMap->reserved[ 1 ] = 
59: 
pTileMap->reserved[ 2 ] = 
60: 
pTileMap->reserved[ 3 ] = 0; 
61: 
62: 
pTileMap->reserved2[ 0 ] = 
63: 
pTileMap->reserved2[ 1 ] = 
64: 
pTileMap->reserved2[ 2 ] = 0; 
65: 
66: 
II Initialize the end-of-tile-map structure 
67: 
pTileMap++; 
68: 
69: 
pTileMap->pMapArray = NUll; 
70: 
71: 
return SUCCESS; 
72: } 
Drawing Graphics 
227 

Chapter 8 
228 
Whether you create your own tile map randomly or use a tile editor to create a 
tile resource that you load from a file in your application's download distribution 
or a Web server, the process is the same. This routine begins by allocating memory 
for the tile map Oines 11-12) and fails if the allocation fails Oine 14). With the tile 
map in hand, you then walk across the tile map, randomly selecting a tile bitmap 
for each tile in the tile map aines 17-42). Aesthetically the screen looks best with 
about one in 24 tiles showing a flower, so you use the random number allocated for 
each tile and the modulo function % Oine 21) to determine whether the tile will 
contain grass (lines 37-39, if*pTile is 0) or a flower Oines 2~35). (Originally, I used 
another bit of the current tile's random number to choose the flower color, but 
I liked the idea of alternating colors better.) 
The rest of the routine is straightforward bookkeeping. First, set the position 
and size of the tile map aines 44-48), then set the size of each tile Oine 51), don't 
wrap the tiles aine 54), and zero the reserved fields Oines 57--64). Next, on 
lines 67--69, you mark the end of the tile map array by setting the second tile map's 
pMapArray field to NULL. 
Loading Sprites and Tiles 
The loadSpri tes and loadTiles functions are responsible for creating the sprite and 
tile buffers used by the ISpri te instance throughout the application. These func-
tions make heavy use of the IBi tmap interface. Because both functions are so 
similar, for brevity only loadSprites is discussed (see Listing 8-12). 
Listing 8-12. Loading the Sprite Bitmaps 
1: static int loadSprites( CAppPtr pThis, IBitmap **ppBitmap ) 
2: { 
3: 
IBitmap *pISpriteBitmapj 
4: 
int16 x, y, ij 
5: 
IBitmap *pBitmapj 
6: 
int resultj 
7: 
8: 
x = y = i = OJ 
9: 
10: 
result = createBitmap( pThis, 
11: 
16, 16 * Sprite_Last, 
12: 
&pISpriteBitmap )j 
13: 
if ( result != SUCCESS) 
14: 
return ENOMEMORYj 
15: 
16: 
II Blit each of the sprites on to the bitmap buffer 

Drawing Graphics 
17: 
for ( i = Sprite_Mousej i < Sprite_Lastj i++ ) 
18: 
{ 
19: 
pBitmap = lSHELL_LoadResBitmap( GetShell( pThis ), 
20: 
APP _RESJlLE, 
21: 
RESlD_SPRITE_BASE + i ) j 
22: 
if ( IpBitmap ) 
23: 
{ 
24: 
lBlTMAP_Release( plSpriteBitmap )j 
25: 
return ENOMEMORYj 
26: 
} 
27: 
28: 
lBITMAP_Bltln( pISpriteBitmap, x, y, 16, 16, 
29: 
pBitmap, 0, 0, AEE_RO_COPY )j 
30: 
y+=16j 
31: 
lBlTMAP_Release( pBitmap )j 
32: 
} 
33: 
34: 
*ppBitmap = pISpriteBitmapj 
35: 
return SUCCESSj 
36: } 
The function begins by creating the bitmap that will become the sprite buffer 
for the lSprite interface on lines 10-12 using createBitmap, which is discussed 
next. The bitmap created is 16-pixels wide and long enough to hold each of the 
sprite images one after the other down the bitmap. 
Beginning with line 19, the function loads each sprite bitmap (via the loop that 
begins on line 17) using ISHELL_LoadResBitmap. This function returns a freshly 
instantiated lBi tmap interface with a bitmap containing the desired image. With 
the sprite image for the current sprite stored in the bitmap instance pBitmap, the 
I BITMAP _ Bl tIn method bUts the image to the correct location in the sprite bitmap 
plSpriteBitmap on lines 28-29. This function takes the destination bitmap, the 
position (upper-left comer, width, and height) on the destination bitmap to place 
the image, the source bitmap, and the beginning point on the source bitmap. It 
also takes the mode to use when copying the source mode-in this case, 
AEE_RO_COPY-to do apixel-by-pixel copy of the source bitmaps. With the current 
sprite's image copied to the sprite buffer, you bump the y coordinate to point to the 
location of the next image on line 30 and release the current sprite's lBi tmap 
instance. 
Once all of the bitmaps have been copied to the plSpri teBi tmap, its pointer is 
copied to the result pointer *ppBitmap and the function returns. 
At this point, it's worth taking a minute to look at the implementation of 
createBi tmap. It's easy to create a new bitmap by using an IDisplay instance as a 
229 

ChapterB 
230 
template, but because it's several lines of code, a utility function can do it for you 
(see listing 8-13). 
Listing 8-13. Loading the Tile Bitmaps 
1: static int createBitmap( CAppPtr pThis, 
2: int16 w, int16 h, 
3: IBitmap **ppIBitmap ) 
4: { 
5: 
IBitmap *pIDeviceBitmap; 
6: 
IBitmap *pIBitmap; 
7: 
AEERect recti 
8: 
int result; 
9: 
10: 
result = IDISPLAY_GetDeviceBitmap( GetDisplay( pThis ), 
11: 
&pIDeviceBitmap )i 
12: 
if ( result != SUCCESS) 
13: 
{ 
14: 
return result; 
15: 
} 
16: 
17: 
result = IBITMAP_CreateCompatibleBitmap( pIDeviceBitmap, 
18: 
&pIBitmap, w, h ); 
19: 
IBITMAP_Release( pIDeviceBitmap ); 
20: 
if (result != SUCCESS ) 
21: 
{ 
22: 
return result; 
23: 
} 
24: 
25: 
SETAEERECT( &rect, 0, 0, w, h ); 
26: 
IBITMAP_FillRect( pIBitmap, &rect, 
27: 
IBITMAP_RGBToNative( pIBitmap, RGB_WHITE ), 
28: 
AEE_RO_COPY ); 
29: 
30: 
*ppIBitmap = pIBitmap; 
31: 
32: 
return SUCCESS; 
33: } 
This function begins by getting the display's device bitmap using the 
function IDISPLAY_GetDeviceBitmap and storing it in the pointer pIDeviceBitmap 
on lines 10-11. This bitmap is the bitmap used by the screen, so you make a 
new bitmap with the same color depth and new bounds using the method 
I BITMAP _ CreateCompatibleBi tmap on lines 17-18. This creates another bitmap using 

Drawing Graphics 
its interface as a template and the indicated width and height as the dimensions 
for the bitmap. You then release the display's device bitmap because you no longer 
need it and use IBITMAP _FillRect to fill the newly created bitmap with the color 
white, essentially erasing the bitmap (lines 25-28). Finally, you return the newly 
created bitmap in the pointer *ppIBitmap. 
Drawing the Background and Sprites 
The application first draws the background tile map and the sprite map when it 
enters the main state in mainEntry by calling mainDraw. The mainDraw function 
redraws the screen, updates the position of each of the sprites, and sets a timer to 
redraw the display a few milliseconds later (see listing 8-14). 
Listing 8-14. Drawing the Tiles and Sprites 
1: static void mainDraw{ void *p ) 
2: { 
3: 
CAppPtr pThis = {CAppptr)pj 
4: 
CAppDataPtr pData = GetAppData{ pThis )j 
5: 
ISprite *pISprite = pData->pISpritej 
6: 
uint16 arRandom[ 3 ]j 
7: 
8: 
II Get a bag of random numbers 
9: 
GETRAND{ {byte *)arRandom, 
10: 
( 2 + 1 ) * sizeof{ uint16 ) )j 
11: 
12: 
II Update the display 
13: 
mainDrawUpdate{ pThis )j 
14: 
15: 
1* 
16: 
Figure out where things are going to move. 
17: 
Butterflies move every turn 
18: 
The mouse moves every two turns 
19: 
*1 
20: 
21: 
II Move the butterflies 
22: 
moveButterflies{ pThis, arRandom )j 
23: 
24: 
II Move the mouse 
25: 
if ( pData->nTurn % 2 ) 
26: 
{ 
27: 
moveMouse{ pThis, arRandom + 2 )j 
28: 
} 
231 

Chapter 8 
232 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: } 
II And do it again! 
pData->nTurn++j 
ISHELL_SetTimer( GetShell( pThis ), 
FRAME_DELAY_MSECS, 
mainDraw, p ) j 
This routine begins by allocating a pool of random numbers to determine 
where the various sprites should move on lines 9-10. Next, it redraws the tile 
map and sprites using mainDrawUpdate. Next, it determines where the butterflies 
(line 22) and mouse Uines 25-28) should move, and it updates the turn counter 
pData->nTurn. By using the tum counter, you can easily keep the mouse moving at 
a slower rate than the butterflies, giving all of the sprites a little extra character. 
Finally, it posts a timer with the shell to call the draw routine mainDraw again in 
FRAME_DELAY_MSECS. 
The mainDrawUpdate function shows just how easy it is to use the ISpri te 
interface once you set everything up (see listing 8-15). 
Listing 8-15. Updating the Screen Sprites 
1: static void mainDrawUpdate( CAppPtr pThis ) 
2: { 
3: 
CAppDataPtr pData = GetAppData( pThis )j 
4: 
ISprite *pISprite = pData->pISpritej 
5: 
IBitmap *pIDisplayBitmap = NULL; 
6: 
int result; 
7: 
8: 
II Draw the tiles 
9: 
ISPRITE_DrawTiles( pISprite, pData->arTileMap); 
10: 
11: 
II Draw the sprites 
12: 
ISPRITE_DrawSprites( pISprite, pData->arSprites )j 
13: 
14: 
II Update the display 
15: 
result = IDISPLAY_GetDeviceBitmap( GetDisplay( pThis ), 
16: 
&pIDisplayBitmap ); 
17: 
if ( result == SUCCESS ) 
18: 
{ 
19: 
IBITMAP_Bltln( pIDisplayBitmap, 
20: 
0, 0, 
21: 
pThis->m_cx, pThis->m_cy, 
22: 
pData->pIBitmap, 0, 0, AEE_RO_COPY ); 

Drawing Graphics 
23: 
24: 
IDISPLAY_Update( GetDisplay( pThis ) ); 
25: 
IBITMAP_Release( pIDisplayBitmap ); 
26: 
} 
27: } 
This function does three things: draws the tile map, draws the sprites, and 
then blits the ISprite instance's bitmap to the display. It redraws the tile map on 
line 9 using the method ISPRITE _DrawTiles. Next, it redraws the sprites on line 12 
using the method ISPRITE_DrawSprites. (Obviously, you don't want to reverse the 
order of these function calls, or your tile map will overwrite your sprites.) Finally, it 
updates the display by getting the display's bitmap (lines lS-16) and invokes its 
I BITMAP _BltIn method to blit the ISprite instance's bitmap on to the device 
bitmap. Then it updates the display and releases the device bitmap (lines 24-25). 
Moving Sprites 
The various functions moveMouse, moveButterflies, and mainHandleKey are respon-
sible for moving the mouse sprite, the butterfly sprites, and the cat sprite, 
respectively. In a more polished game, the moveMouse and moveButterflies routines 
could be quite complicated because they're the entry points for whatever game 
play artificial intelligence these characters require. In fact, for this application, 
they're quite simplistic and not particularly interesting. 
The mainHandleKey routine, invoked by the main state's event handler when the 
EVT_KEY_PRESS and EVT_KEY_OOWN events occur, illustrates both sprite movement 
and handling user input (see Listing 8-16). 
Listing 8-16. Moving Sprites While Handling Key Events 
1: static boolean mainHandleKey( CAppptr pThis, uint16 wParam ) 
2: { 
3: 
boolean result = FALSE; 
4: 
int dx = 0, dy = 0; 
5: 
int32 newX, newY; 
6: 
CAppDataptr pData = GetAppData( pThis ); 
7: 
uint32 now = GETTIMEMS(); 
8: 
9: 
II The user can only move every so often 
10: 
if ( now> ( pData->nTime + PLAYER_DELAY_MSECS ) ) 
11: 
switch( wParam ) 
12: 
{ 
13: 
case AVK_UP: 
14: 
dy = -CAT_DELTA; 
233 

Chapter 8 
234 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: } 
} 
result = TRUEj 
breakj 
case AVK_DOWN: 
dy = CAT_DELTAj 
result = TRUEj 
breakj 
case AVK_LEFT: 
dx = -CAT_DELTAj 
result = TRUEj 
breakj 
case AVK_RIGHT: 
dx = CAT_DELTAj 
result = TRUEj 
breakj 
if ( result ) 
{ 
} 
II First determine the new position 
newX = pData->arSprites[ Sprite_Cat ].x + dXj 
newY = pData->arSprites[ Sprite_Cat ].y + dyj 
PIN_X_COORD( pThis, newX )j 
PIN_Y_COORD( pThis, newY )j 
pData->arSprites[ Sprite_Cat ].x = (uint16)newXj 
pData->arSprites[ Sprite_Cat ].y = (uint16)newYj 
II Update the display 
II don't wait until the next pass 
pData->nTime = nOWj 
mainDrawUpdate( pThis )j 
return resultj 
The cat, being the largest animal on the playing field, also moves the slowest. 
To control how often the cat can move, this routine begins by checking the current 
system time in milliseconds (obtained on line 7 using the function GETTIMEMS, 
which is the QUALCOMM BREW function that replaces the method 
ISHELL_GetTimeMS available in early versions of QUALCOMM BREW) with the last 
time the player moved the cat (line 10), which is stored in the application data's 
n Time field. 

Drawing Graphics 
If enough time has elapsed, a switch statement on lines 11-29 determines 
which coordinate of the cat's position should be adjusted based on what key you 
press by setting the dx and dy variables. Then, just as with the mainHandleKey 
function in GraphicsSample (discussed earlier in this chapter), you calculate the 
new coordinates for the cat sprite (lines 34-35) and ensure that the cat sprite will 
reside on the screen using the PIN_X_CooRD and PIN_V_COORD macros. After adjusting 
the cat's position so it remains on screen, you update the nTime field of the appli-
cation data structure with the current time and invoke mainDrawUpdate to 
immediately redraw the screen. 
The PIN_X_CooRD and PIN_V_COORD macros simply wrap the if statements you 
saw in GraphicsSample: 
1: #define PIN_X_CooRD( pThis, x ) \ 
2: 
if ( x < 8 ) x = 8i else if ( x > 100 ) x = 100i 
3: #define PIN_V_CooRD( pThis, y ) \ 
4: 
if ( y < 8 ) y = 8i else if ( y > 100 ) y = 100i 
These routines are a little overengineered because they take references to the 
application as well as the coordinate to pin, but with this interface, you can easily 
modify the code to pin objects to various coordinates without modifying the 
dependent functions. 
Summary 
The following are the key points you learned in this chapter: 
â¢ QUALCOMM BREW provides three kinds of graphics interfaces: bitmapped 
graphics, vector graphics through primitives, and sprite graphics. 
â¢ You use the IDisplay interface when you need to perform simple bitmap 
operations (such as bit blitting an image to the display) or simple vector-
based graphics drawing. 
â¢ You can use the more advanced bitmap interfaces IDIB, IBitmap, and 
ITransform to perform other manipulations on bitmaps such as scaling. 
â¢ You can use the IGraphics interface to perform advanced vector graphics 
functions, including setting a viewport to view the vector graphics you draw 
on the handset's canvas. 
â¢ You use the ISprite interface to manipulate a virtual world with a back-
ground of tiles and animated sprites. 
235 

CHAPTER 9 
Playing with Sounds 
As A MULTIMEDIA platform, QUALCOMM BREW wouldn't be complete without 
interfaces to play sounds. As with its graphics support, QUALCOMM BREW pro-
vides a handful of interfaces of increasing sophistication. These interfaces let your 
application play everything from simple tones to highly compressed yet rich 
sound samples encoded using technologies such as QUALCOMM PureVoice 
and MP3. 
NOTE MP3 stands for Moving Pictures Expert Group Audio Layer 3. 
This chapter shows QUALCOMM BREW's sound interfaces-everything from 
the simplest, provided by the IShell interface, to the most advanced, provided 
by the ISoundPlayer interface. It also touches on the new IMedia interface, available 
in QUALCOMM BREW 2.0 and beyond, which unifies the presentation of multi-
media data including sound and video content. To reinforce what you learn, the 
chapter uses the ISoundPlayer interface to add a background soundtrack and addi-
tional sounds to the sample game you saw in Chapter 8, "Drawing Graphics." 
Representing Sound 
As with other computing platforms, QUALCOMM BREW can manage sound data 
in a variety of formats. The simplest sounds-beeps, clicks, and the like-are 
available using the ISound interface directly from the handset's Read-Only Memory 
(ROM). In addition, handset vendors have the option of including support for 
additional sound formats, including the Music Industry Digital Interface (MIDD, 
Motion Picture Experts Group (MPEG), and QUALCOMM PureVoice (also known 
as QUALCOMM Code Excited Linear Predictive Coding, or QCELP). 
237 

Chapter 9 
238 
Representing Sounds with MIDI 
The MIDI file format has its beginnings in the MIDI standards of the mid-1980s, 
which allowed vendors of different kinds of electronic music instruments to inter-
connect instruments. The data formats quicldy evolved to a file format that 
represents music as a series of notes played by musical instruments. Systems 
playing MIDI files use their own hardware and software to perform a best-effort 
emulation of the musical instruments and notes within the file, so although the 
MIDI format guarantees some fidelity regarding tempo and melo~y, a MIDI file 
played on two different instruments may sound different. VIrtually all wireless 
handsets today ship with the ability to play MIDI files; in fact, most custom ring 
tones for handsets come as MIDI files. 
MIDI is best used for representing fragments of songs with little memory, 
when the actual instrument sounds are less important than the tempo and 
melody. Because the file format supports representing specific instruments, 
tempo, notes, and rests, you can't use it for arbitrary sounds, such as speech or 
sound effects. 
Representing Sounds with MP3 
The German company Fraunhofer liS developed the MP3 format to significantly 
j 
decrease the amount of storage required for high-fidelity audio. The MP3 format 
uses lossy compression, which means the resulting compressed data contains less 
information than the original source. By discarding some information that's 
imperceptible to most listeners, MP3 files can compress audio data by up to a 
factor of 10 or 12 before you can hear a noticeable degradation in quality. Unlike 
MIDI, MP3 files represent the actual sound of the original source rather than just 
encoding the musical content, making it an exceptional choice for representing 
music, speech, and other audio data. 
The exceptional compression characteristics ofMP3 come with a computa-
tional cost, however. Most handsets today lack the hardware or processing power 
and software to be able to decompress MP3 files. Consequently, when selecting to 
encode the audio for your application with MP3, you should first check to be sure 
that your target hardware supports MP3. 
Representing Sounds with QCELP 
The Code Division Multiple Access (COMA) wireless networks on which 
QUALCOMM BREW-enabled handsets operate use the QCELP format to carry the 
voice content of telephone calls. It's exceptionally well suited to compressing 

Playing with Sounds 
speech data and can represent telephone-quality voice data with a high degree of 
compression. 
Unlike MIDI or MP3 files, which can be created using a myriad of music com-
position and recording applications, creating QCELP files requires a little-known 
tool. You use the QUALCOMM PureVoice converter to convert between Microsoft 
Wmdows WAY sound files and QCELP files. 
Because QCELP is integral to the performance of a wireless handset, virtually 
every QUALCOMM BREW-enabled handset can play QCELP files. It's also a good 
choice for small sound samples, such as sound effects for games or small clips of 
music on handsets lacking MP3 support. 
Understanding How to Play Sounds 
The QUALCOMM BREW platform provides four interfaces to manage sounds, 
each offering increasing flexibility (and therefore complexity). Although for most 
applications you'll use either the ISoundP1ayer interface or the IMedia interface, 
you'll see all four interfaces in this chapter so that you can make an educated 
decision when designing your application. 
TIP 
The IRinger interface (introduced in Chapter 12, "CertifyingYour 
Application") can also play sounds, but its interface for sound playback 
is identical to that offered by the ISoundP1ayer interface. 
An important thing to remember as you read this chapter is that all sound 
playback is asynchronous-that is, playback begins after you invoke the appro-
priate method and continues in the background while your application executes. 
As a result, interfaces include methods to start, stop, and pause sound playback. 
Using the Shell 
The IShell interface, as you've seen throughout this book, is the grab bag of inter-
faces with methods that do a little of everything. This is true even of sound 
support. Using the ISHE LL _Beep method, your application can playa number of dif-
ferent sounds. When you invoke this function, you pass a constant that indicates 
the type oftone the handset should play (see Table 9-1). Typically, the tones played 
are the same tones used by manufacturers within their on-board firmware 
applications. 
239 

Chapter 9 
240 
Table 9-1. Sound Constants/or Use with ISHELL_Beep 
CONSTANT 
PURPOSE 
BEEP_OFF 
Terminates a playing beep 
BEEP_ALERT 
Beep to alert the user 
BEEP REMINDER 
Beep to remind the user 
BE E P _ MSG 
Beep to indicate the arrival of a Short Message Service (SMS) 
BEEP_ERROR 
Beep to indicate an error condition 
BEEP _VIBRATE_ALERT 
Silent alert (vibration, indicator blinking, or the like) to 
notify the user 
BE E P _VI BRATE_ REMIND 
Silent alert (vibration, indicator blinking, or the like) to 
remind the user 
The ISHELL_Beep method is best used in two cases. In debugging your appli-
cation, you can use various beep sounds to let you know when a particular 
segment of code is executing. It's not as robust as using the debugging log, but it 
has the advantage that you don't need to be tethered to your workstation to obtain 
debugging information when debugging on the handset. The second case is when 
your application provides functionality similar to the built-in applications and 
you want to mirror their user interfaces, especially the sounds they make. 
Playing Tones 
The ISound interface lets you adjust the handset volume, trigger the silent alert, 
and playa tone or a series of tones using the handset's speaker. Using the ISound 
interface, you access a handset manufacturer-specific database of sounds and 
play the sounds for an application-determined duration. 
The interface includes the ISOUND_GetVolume and ISOUND_SetVolume methods, 
which let you set the sound playback volume on the handset. The volume returned 
is part of an AEESoundCmdData structure, which looks like this: 
1: typedef union 
2: 
{ 
3: 
uint16 wVolume; 
4: 
uint16 wPlayIndex; 
5: 
} AEESoundCmdData 

Playing with Sounds 
The ISOUND ]layTone method plays a single tone, specified by an 
AEESoundToneData structure, which looks like this: 
1: typedef structure 
2: 
3: 
AEESoundTone eTonei 
4: 
uint16 wDurationi 
5: } AEESoundToneDatai 
You specify the tone as a tone ID in the eTone field, and you specify the 
duration in milliseconds in the wDuration field. The eTone field can contain 
values from the AEESoundTone enumeration, which includes constants to 
specify tones such as those you hear when dialing a traditional phone, simple 
musical tones, and so on. 
If you want to playa set of AEESoundTone tones in a series, you use 
ISound]layToneList. This function takes a pointer to a memory region filled with 
AEESoundToneData structures and the number of structures in the memory region. It 
plays each tone in turn as your application continues to execute. 
While a sound is playing, you can stop the playback at any time by calling 
ISOUND _ StopTone, which immediately stops any pending tone or tone list playback. 
Your application may need to know the state of the ISound interface-say, to 
see if a specific tone is being played. To do this, you can register for notifications of 
the status from the ISound interface using ISOUND_RegisterNotify. This function 
takes a pointer to a function that the ISound interface periodically invokes with the 
status of the sound playback and takes a pointer to a block of data where you can 
store the application context or other function-specific data. The callback 
function must look like this: 
1: typedef void (* PFNSOUNDSTATUS) 
2: 
( 
3: 
4: 
5: 
void * pUser, 
AEESoundCmd eCBType, 
AEESoundStatus eSPStatus, 
6: 
uint32 dwParam 
7: 
) i 
The first argument your callback receives is the user data you pass to 
ISOUND_RegisterNotify. The second argument tells you the nature of the function 
call that triggered your notification function. The third argument indicates the 
status of the sound player and indicates whether the current operation is con-
tinuing, is finished, or has failed. Finally, the dwParam value is a pointer to an 
241 

Chapter 9 
242 
AEESoundCmdOata structure that tells your application the current volume (if the 
volume is being changed) or an index into the tone list that's currently playing. 
Despite the flexibility of the ISound interface, it's not well suited to producing 
much besides the simplest of sound sequences because of the handset-specific 
nature of the AE E SoundToneOata lists. Unless you're in a position to write an 
authoring tool that lets you easily convert your sound data to AEESoundToneOata 
structures, you're forced to compose these lists by hand. This, in turn, can be a 
laborious and error-prone process, and the results aren't even as flexible as a 
MIDI file. 
Playing MIDI, MP3, and QCELP Sounds 
Most of the time, you'll want to play your sound data using the ISoundPlayer 
interface, which lets you play sounds directly from a stream and monitor the 
playback process. 
You can create an ISoundPlayer instance using one of two methods: in the tra-
ditional way using ISHELL _ Createlnstance or by asking the shell for a handler of the 
sound file's MIME type using ISHELL_GetHandler. Once you create an instance of 
the interface, you can play sound in a memory region or a file, or you can point the 
player at a stream to play the sound. Note that if you use a stream, the interface 
doesn't perform streamed audio playback; instead, it reads the entire contents of 
the sound file into a buffer and then plays the buffer. (Thus, you can't use the 
ISoundPlayer interface to build a streaming audio player.) 
You set the ISoundPlayer interface to the source of your sound data 
using either ISOUNOPLAYER_Setlnfo or ISOUNOPLAYER_SetStream. When you use 
ISOUNOPLAYER, you pass a AEESOUNOPLAYERINFO structure with its elnput field set 
to either SOT_BUFFER or SOT_FILE and the pOata field pointing to the buffer 
containing either the memory region or the filename. If you use 
ISOUNOPLAYER_SetStream, you simply pass the interface of the IAStream subclass 
with the audio data. 
As with the ISound interface, you can register a function callback with 
ISOUNOPLAYER_RegisterNotify. This callback lets you know whether the sound is 
playing or paused, the nature of the requests made of the ISoundPlayer interface, 
and other information. You can also determine the duration of a sound by using 
the method ISOUNOPLAYER_GetTotalTime. 
To actually play your sound, you call ISOUNOPLAYER_Play. Some sound types, 
such as MP3 and MIDI sounds, let you fast forward or rewind through the sound 
data programmatically, so you can select specific segments of a sound file or let 
users pick which segments of a sound file they want to hear. Similarly, with MIDI 

Playing with Sounds 
sounds, you can control the tempo and pitch of the playback. The ISoundPlayer 
interface includes these methods for controlling playback: 
â¢ ISOUNDPlAYER_Play: Begins or restarts the playback of the sound. 
â¢ ISOUNDPlAYER_Stop: Stops the playback of the sound. 
â¢ ISOUNDPlAYER_Rewind: Rewinds the playback by a specific number ofmilli-
seconds. (QCELP sound data doesn't support this.) 
â¢ ISOUNDPlAYER_FastForward: Fast forwards the playback by a specific number 
of milliseconds. (QCELP sound data doesn't support this.) 
â¢ ISOUNDPlAYER_Pause: Pauses the playback. (QCELP sound data doesn't 
support this.) 
â¢ ISOUNDPlAYER_Resume: Resumes the playback after you've paused it. (QCELP 
sound data doesn't support this.) 
â¢ ISOUNDPlAYER_SetTempo: Sets the tempo of a MIDI sound. 
â¢ ISOUNDPlAYER _ SetTune: Sets the pitch level (in musical half-step instruments) 
of a MIDI sound. 
Because of the computationally intensive nature of sound playback, you 
can have only one ISoundPlayer interface actually playing sound at once. You can, 
however, have more than one ISoundPlayer interface instantiated and prepared to 
play (within memory constraints), and switch between them at will. 
The "Using the ISoundPlayer Interface in an Application" section of this 
chapter shows how you can use the ISoundPlayer interface to easily add sound to 
your application's user interface. 
Playing Multimedia 
Available in QUALCOMM BREW 2.0, the IMedia interface promises to unify multi-
media management for both presentation and recording. This interface provides a 
simple way to present sound, animation, and even (if the hardware supports it) the 
playback of video or other content. Moreover, the interface has been designed so 
that you can also use it for recording content, such as operating a voice recorder or 
a camera on a camera-enabled handset. 
243 

Chapter 9 
244 
NOTE 
As this book goes to print, it's not clear which handset manufac-
turers will provide implementations to render specific kinds of media, 
such as animated images, MPEG video, and what have you. It's quite 
likely that the first uses ofIMedia interfaces in your application will 
be to replace the ISoundPlayer interface or perhaps to use a developer 
extension that plays a specific kind of media, such as Mobile Scalable 
Vector Graphics (MSVG) or Synchronized Multimedia Integration 
Language (SMIL). 
After instantiating an IMedia interface-typically a subclass of IMedia that 
understands a specific media format-you must set its media using the 
IMEDIA _ SetMediaData method, which can take data from a file, a memory region, or 
an ISource subclass (which you can create from an IStream subclass). 
Once you've set the IMedia interface's media, you should set a status callback 
using the IMEDIA _ RegisterNoti fy function. Your status callback function will 
receive regular invocations notifying it of status changes within the IMedia 
interface, including playback start, playback stop, and configuration changes 
(such as setting the size of the screen rectangle and the destination audio device or 
volume). Next, you configure the interface with multiple calls to 
IMEDIA_SetMediaParms, which lets you set the interface's screen bounds, volume, 
playback tempo, and playback pitch. 
Once you configure the IMedia interface, you can begin playing the media 
using the following methods: 
â¢ IMEDIA_Play: Starts the media playback 
â¢ IMEDIA_Stop: Stops the media playback 
â¢ IMEDIA]ause: Pauses the media playback 
â¢ IMEDIA_Resume: Resumes the media playback 
â¢ IMEDIA _Rewind: Rewinds the playback by the number of milliseconds you 
indicate 
â¢ IMEDIA_FastForward: Advances the playback by the number of milliseconds 
you indicate 
The QUALCOMM BREW MediaPlayer sample that accompanies the Software 
Developer's Kit (SDK) provides an excellent introduction to using the IMedia 
interface. 

Playing with Sounds 
Using the ISoundPlayer Interface in an Application 
No game is complete without sound effects. To demonstrate the ISound and 
ISoundPlayer interfaces, the following sections show you how to add sound effects 
to the cat-and-mouse game you saw in the previous chapter. 
The game uses sounds for two purposes: to provide a background MIDI track 
that plays throughout the game and to playa specific sound and vibrate the 
handset when the cat catches the mouse. 
Adding Sound Interfaces to the Application 
To start, add two fields to the application data structure to carry the ISound and 
ISoundPlayer interfaces, as shown in listing 9-1. 
Listing 9-1. The Application Structure 
1: typedef .struct 
2: { 
3: 
ISoundPlayer *pISoundPlayerj 
4: 
ISound *pISoundj 
5: 
6: 
ISprite *pISpritej 
7: 
IBitmap *pIBitmapj 
8: 
AEETileMap arTileMap[ TileMap_last + 1 ]j 
9: 
AEE5priteCmd arSprites[ Sprite_last + 1 ]j 
10: 
11: 
int nTurnj 
12: 
uint32 nTimej 
13: } CAppData, *CAppDataPtrj 
These fields, pISoundPlayer and pI Sound (lines 3-4), store the interface to an 
ISoundPlayer instance and an ISound instance, respectively. You allocate these 
while the main state begins by making a call to the new function in listing 9-2. 
Listing 9-2. Allocating the ISoundPlayer and ISound Instances 
1: static void mainMusicStart( CAppptr pThis ) 
2: { 
3: 
CAppDataPtr pData = GetAppData( pThis )j 
4: 
5: 
II If these fail, it's OK. 
6: 
ISHEll_CreateInstance( GetShell( pThis ), 
245 

Chapter 9 
246 
7: 
AEECLSID_SOUND, (void **)&pData->pISound ); 
8: 
9: 
ISHELL_CreateInstance( GetShell( pThis ), 
10: 
AEECLSID_SOUNDPLAYER, (void **)(&pData->pISoundPlayer Â»; 
11: 
12: 
II Start the music playback 
13: 
mainMusicPlay( pThis ); 
14: } 
lines 6-10 in listing 9-2 create instances of the ISound and ISoundPlayer inter-
faces. Because sound playback isn't crucial to game play, don't worry if these calls 
fail; instead, you can test for the existence of the desired interface before you use it. 
line 13 calls the new function mainMusicPlay to begin playing the background 
MIDI music. 
Playing Background Music During Game Play 
Playing music in the background is easy. You simply initialize an ISoundPlayer 
instance, tell it to play, and then restart the playback when it's done playing. You 
can do this with mainMusicPlay and mainSoundNoti fyCallback. The playback begins 
in mainMusicPlay, as shown in listing 9-3. 
Listing 9-3. Starting the Playback 
1: static void mainMusicPlay( CAppPtr pThis ) 
2: { 
3: 
CAppDataptr pData = GetAppData( pThis ); 
4: 
5: 
II It's OK if there's no sound player 
6: 
if ( pData->pISoundPlayer ) 
7: 
{ 
8: 
ISoundPlayer *pISoundPlayer = pData->pISoundPlayer; 
9: 
AEESoundPlayerInfo info = { 0 }; 
10: 
int result; 
11: 
12: 
II Set our data source 
13: 
info.eInput = SDT_FILE; 
14: 
info.pData = MUSIC_FILE; 
15: 
16: 
result = ISOUNDPLAYER_SetInfo( pISoundPlayer, &info ); 
17: 
1* 
18: 
or 

Playing with Sounds 
19: 
result = 
20: 
ISOUNOPLAYER_Set( pISoundPlayer, SOT_FILE, MUSIC_FILE ); 
21: 
on earlier platforms such as 1.0. 
22: 
*1 
23: 
24: 
if ( result == SUCCESS ) 
25: 
{ 
26: 
II Set the notification callback 
27: 
ISOUNOPLAYER_RegisterNotify( pISoundPlayer, 
28: 
mainSoundNotifyCallback, pThis ); 
29: 
30: 
II Start the playback 
31: 
ISOUNOPLAYER_Play( pISoundPlayer ); 
32: 
} 
33: 
} 
34: } 
As you can see, this is simple stuff. If the application has a valid interface to 
play the background MIDI (line 6), you first initialize the interface using 
ISOUNOPLAYER_SetInfo (lines 12-16) to playa sound file with the name MUSIC_FILE. 
MUSIC_FILE, defined in frameworkopts.h, points to a simple MIDI file. 
NOTE 
On QUALCOMM BREW 1.0, the co"ect Application Program-
ming Interface (API) to use is ISOUNOPLAYER_Set. See lines 19-20 of 
Listing 9-3 for an example. 
Next, the code registers a callback to receive notifications from the 
ISoundPlayer instance on lines 27-28. The instance will call 
mainSoundNoti fyCallback at regular intervals, including when the MIDI finishes 
playing so you can restart the playback. Finally, if the initial ISOUNOPLAYER_SetInfo 
call succeeds, you begin the playback on line 31. 
TIP On most versions of the QUALCOMM BREW Emulator, the sounds 
you play with the ISoundPlayer interface will only be heard if you play 
them from the file system. If you're playing your sounds from memory 
using IMemAStream and don't hear anything, don't panic. Instead, either 
store the sound in a file and play from the file or begin testing on the 
handset. 
247 

Chapter 9 
248 
The mainSoundNoti fyCallback function looks for notifications that the playback 
has completed and calls mainMusicPlay to restart the playback in listing 9-4. 
Listing 9-4. Restarting the Playback 
1: static void mainSoundNotifyCallback( void *p, 
2: 
AEESoundPlayerCmd eType, 
3: 
AEESoundPlayerStatus eStatus, 
4: 
uint32 dwParam) 
5: { 
6: 
CAppPtr pThis = (CAppptr)pj 
7: 
CAppDataPtr pDataj 
8: 
9: 
if ( !pThis ) returnj 
10: 
pData = GetAppData( pThis )j 
11: 
if ( !pData ) returnj 
12: 
if ( !pData->pISound && !pData->pISoundPlayer ) returnj 
13: 
14: 
if ( eStatus == AEE_SOUNDPLAYER_DONE ) 
15: 
{ 
16: 
mainMusicPlay( pThis )j 
17: 
} 
18: } 
This routine begins with a number of guards (lines 9-12) to ensure that if the 
system invokes callback while the application is shutting down, the callback exits 
before accessing invalid data. After the guards, the function simply tests to see if 
the playback has completed (line 14) and restarts the playback with mainMusicPlay 
online 16. 
Eventually, all good things must come to an end. This is true for the back-
ground music, which stops playing when the main state exits. listing 9-5 shows 
that the mainMusicStop function accomplishes this by releasing both of the sound 
interfaces. 
Listing 9-5. Stopping the Background Music Playback 
1: static void mainMusicStop( CAppPtr pThis ) 
2: { 
3: 
CAppDataPtr pData = GetAppData( pThis )j 
4: 
5: 
if ( pData->pISoundPlayer ) 
6: 
ISOUNDPLAYER_Release( pData->pISoundPlayer )j 

Playing with Sounds 
7: 
8: 
9: 
10: 
11: } 
if ( pData->pISound ) 
ISOUND_Release( pData->pISound )j 
Mer releasing the sound interface on line 6, the playback stops, so there's no 
need for the application to use the ISOUNDPLAYER_Stop method. 
Playing Sounds for Game Events 
The mouse's movement is controlled by some simple logic in mouseMove (see 
listing 9-6). To add sound, you simply add a segment of code that uses the mouse's 
distance from the cat to determine if the ISound instance should playa sound. 
Listing 9-6. Controlling the Mouse's Movement 
1: static void moveMouse( CAppptr pThis, uint16 *pRandom ) 
2: { 
3: 
CAppDataptr pData = GetAppData( pThis )j 
4: 
int transform = OJ 
5: 
int16 newX, newYj 
6: 
int dx, dy, dXl, dylj 
7: 
int sY, sYj 
8: 
9: 
II if the cat gets close to the mouse, we move. 
10: 
dx = pData->arSprites[ Sprite_Cat l.x -
11: 
pData->arSprites[ Sprite_Mouse l.xj 
12: 
dy = pData->arSprites[ Sprite_Cat l.y -
13: 
pData->arSprites[ Sprite_Mouse l.yj 
14: 
dXl = dx > 0 ? dx : -dxj 
15: 
dyl = dy > 0 ? dy : -dyj 
16: 
17: 
II If we're really close, playa squeaky sound. 
18: 
if ( pData->pISound && 
19: 
dXl < MOUSE_TOO_CLOSE && dyl < MOUSE_TOO_CLOSE ) 
20: 
{ 
21: 
AEESoundToneData tone = { 0 }j 
22: 
23: 
tone.eTone = AEE_TONE_REORDER_TONEj 
24: 
tone.wDuration = 500j 
249 

Chapter 9 
250 
25: 
26: 
ISOUND_PlayTone( pData->pISound, tone ); 
27: 
ISOUND_Vibrate( pData->pISound, tone.wDuration ); 
28: 
} 
30: 
31: 
â¢â¢â¢ continue with mouse movement logic 
32: } 
In this code, lines 10-13 calculate the arithmetic distance between the cat and 
the mouse. Unlike the distance formula-the square root of the sum of the 
squares-you learned in high-school math, this formula isn't as accurate, but it 
requires far less mathematical processing. This is an important point on 
QUALCOMM BREW-enabled handsets, both because this computation happens 
often and because QUALCOMM BREW has limited support for floating-point 
mathematics (addition, subtraction, multiplication, and division to be precise). 
lines 14 and 15 calculate the absolute value of these distances. 
lines 18-19 verify that the application has a valid ISound instance and that the 
cat is sufficiently close to the mouse to warrant a sound. line 21 allocates the tone 
variable that you'll use with ISOUND ]layTone, and the following two lines select the 
AEE_ TONE_REORDER _TONE (which sounds a little like a fast busy signal to play for one 
half of one second). Finally, the routine starts playing the sound and vibrating the 
handset using ISOUND _PlayTone and ISOUND _Vibrate on lines 26 and 27 before con-
tinuing with the mouse movement logic. 
Summary 
You should remember the following key points about playing sound and other 
multimedia with the QUALCOMM BREW interfaces: 
â¢ QUALCOMM BREW-enabled handsets can support sound media such as 
MIDI, QCELP, and MP3. However, not all handsets support all audio 
formats. 
â¢ All sound playback is asynchronous. If you need to monitor the status of 
sound playback, you must implement a function that the sound interface 
calls periodically to notify your application of the playback status. 
â¢ For simple sounds to alert the user or for sounds to debug application flow, 
you can use ISHElL_Beep or ISOUND_PlayTone to playa single tone. 
â¢ To play sound media such as MIDI, QCELP, and MP3, you can use the 
ISoundPlayer interface or, using BREW 2.0, the IMedia interface. 

Playing with Sounds 
â¢ Using either the ISoundPlayer interface or the IMedia interface, you can fast 
forward, rewind, pause, and resume the playback when playing sounds if 
the sound format supports it. 
â¢ The IMedia interface, available in QUALCOMM BREW 2.0, lets you play mul-
timedia including animated images, sounds, and other rich multimedia 
such as MP4 video if the handset supports those data types. 
251 

CHAPTER 10 
Networking Your Data 
THE QUALCOMM BREW platform is a "connected" platform. In other words, it 
includes interfaces for performing Transmission Control Protocol/Internet Pro-
tocol (TCP/IP) networking, receiving Short Message Service (SMS), and, starting 
with QUALCOMM BREW 1.1, making Hypertext Transport Protocol (HTTP) 
requests-all over wireless networks. Moreover, the newest versions of the 
QUALCOMM BREW platform include support for Bluetooth, the popular personal 
area network standard. QUALCOMM BREW lets your application use Bluetooth to 
connect to nearby computing devices including wireless audio devices and 
handheld computers. 
In this chapter, you'llleam about the most commonly used network inter-
faces, including the ISocket interface and the IWeb interface, and you'll see how to 
accept incoming SMS messages to trigger actions within your application. The 
chapter also touches on the new Bluetooth interfaces. 
Choosing Wireless Network Options 
With the QUALCOMM BREW platform's plethora of wireless connectivity options, 
it can be a challenge to pick which network and interfaces to use for transferring 
data to and from your application. The QUALCOMM BREW platform gives you 
several choices: 
â¢ Implementing TCP/IP networking via the INetMgr, ISocket, and IDNS inter-
faces, which lets you write client -side TCP lIP applications 
â¢ Implementing HTTP networking via the IWeb and IWebOpts interfaces, which 
lets you transfer data with Web servers using HTTP 
â¢ Receiving SMS messages to trigger actions within your application 
â¢ Implementing Bluetooth connectivity to audio devices and other com-
puting devices 
253 

Chapter 10 
254 
Choosing the ISocket Interface for TCPIIP Networks 
Using the ISocket interface, you can implement virtually any client-side rcp 
network protocol, such as the Simple Mail Transport Protocol (SMTP) for deliv-
ering mail or the Post Office Protocol (POP) for downloading email. 
The ISocket interface presents a streaming interface (see Chapter 6, 
"Streaming Data") to network sockets. The ISocket interface lets you open client-
side sockets-that is, you can only create sockets that initiate outbound requests; 
you can't create a socket, listen on a port, and await client socket connections. 
Once the socket is open, you use it to read and write data from and to the remote 
host asynchronously by using callbacks when the interface is ready to receive or 
send data. 
Working with raw sockets gives you great flexibility as an application 
developer, but it has some obvious drawbacks. For instance, your application must 
implement an entire Internet protocol, including all of the necessary error han-
dling. In many cases, the reference implementations of these protocols are on 
platforms that have additional features, such as blocking sockets and multi-
threading. As a result, implementing an Internet protocol takes a significant 
engineering investment. Worse still, if you choose to implement a protocol of your 
own design, you need to invest time in developing the server side of the protocol, 
including dealing with loading issues and the other intricacies of server 
development. 
As a result, for most client-server applications that don't involve a legacy pro-
tocol, it's best to look elsewhere for network support. Specifically, look to the IWeb 
interface, which provides a robust HTrP client layer for applications that rely on 
remote Web servers to provide application-specific data. 
Choosing the IWeb Interface for HTTP Transactions 
Over the past several years, HTTP has grown from being a successful but 
single-purpose protocol that delivers text and multimedia data to clients to being 
a protocol that bears all kinds of data, from traditional Web content to back-end 
business-to-business and embedded-device data transactions using the Exten-
sible Markup Language (XML) and other proprietary data payloads. Using an 
off-the-shelf Web server, such as the Apache Web server or Microsoft Internet 
Information Server (lIS), applications can use HTTP to transfer data across the 
Internet. 
To facilitate interoperatingwith Web-based services, beginning in version 1.1, 
the QUALCOMM BREW platform includes a module that implements the client 
half ofHITP, including the ability to both send {using HTrP POSD and fetch {using 
HTrP GED data, as well as examine the headers associated with a data transaction. 

Networking Your Data 
The IWeb interface provides a comprehensive interface to HTI'P (including 
support for proxy servers, optional keep-alive connections, and other 
optional HTTP-related behavior) while remaining simple for the majority of 
transactions. To use the interface in its simplest form, you need only instantiate 
an interface and then provide the source Uniform Resource Locator (URL), a 
callback function for the result, and some simple options describing the request. 
The request proceeds asynchronously, and the interface invokes your callback 
with a structure containing status information about the request and an ISource 
instance, which gives you an interface to your data. In tum, you can read directly 
from this source or convert to a stream using the ISourceUtil interface's 
ISOURCEUTIL_AStreamFromSource method. Once you have a stream, you can pass the 
stream to interfaces such as IImage (see Chapter 5, "Interacting with the User") and 
ISoundPlayer (see Chapter 9, "Playing with Sounds"). You can also provide addi-
tional callbacks to receive notification of the network status and each of the 
incoming HTTP headers, but that's not required. 
Beginning with version 2.0 of the QUALCOMM BREW platform, QUALCOMM 
has added support for Transport Layer Security (TLS), which is the new name for 
what was formerly Secure Socket Layer (SSL), with the ISSL interface. You can 
activate TLS support for your IWeb requests by asserting additional flags, but there's 
a hitch: Most handsets currently shipping don't yet support TLS. Moreover, the 
latest releases of the Software Developer's Kit (SDK) documentation indicate that 
the interface is defined and documented but not implemented, so it may be some 
time before you can take advantage ofTLS in your application. 
Choosing QUALCOMM BREW-Directed SMS for Application 
Notification 
Because QUALCOMM BREW-enabled handsets can't listen on sockets for 
incoming connections, at first glance it seems that there's no way to have your 
application respond to outside requests. Fortunately, that's not true; by using SMS 
messages directed at your application (commonly called a BREW-directed SMS 
message, or just BDSMS), your application can receive an SMS message addressed 
to it and act on its contents, whether or not the application is running. For 
example, a BDSMS can awake your application and cause it to make a network 
transaction to download breaking news, or it can update your application's config-
uration in the event of back-end infrastructure changes. Some companies, such as 
M7 Networks, are developing products and services that incorporate BDSMS with 
games so that you can invite multiple players to play in a single game from your 
handset by launching an application that then uses a central server and BDSMS. 
255 

Chapter 10 
256 
As you'll see in the section "Understanding BDSMS," using BDSMS is easy-in 
fact, any application can receive a BDSMS with little effort. It's more difficult, 
however, to incorporate BDSMS in your application from a business perspective 
because most wireless carriers don't let just anyone originate SMS messages on 
their network. Instead, they give only certain partners, commonly called aggre-
gators, access to the servers that send SMS messages over their networks. As a 
result, when developing your application, you must work closely with the carriers 
that will distribute your application and obtain their help in identifying an aggre-
gator you can use to access their networks when you need to send BDSMS 
messages. 
Choosing Bluetooth for Personal Area Networking 
The Bluetooth standard defines a multiple-node wireless network for replacing 
cables between closely coupled devices, such as laptop computers, cell phones, 
printers, user interface devices, and the like. Using Bluetooth-enabled devices, for 
example, you can use your handheld computer to place phone calls on your 
mobile phone and even access the Internet to read mail or browse the Web-all 
without making a physical connection between your mobile phone and your 
handheld computer. 
The Bluetooth standard defines a set of profiles, each with specific capabil-
ities. These capabilities include the ability to carry audio content between a 
remote audio device and a wireless handset, the ability to carry serial data 
between two devices, and the ability to share a Local Area Network (LAN) con-
nection between a handheld computing device and a wireless access point. 
Although no QUALCOMM BREW-enabled handsets yet include Bluetooth, 
starting with version 2.0, QUALCOMM BREW includes several interfaces for 
Bluetooth: 
â¢ You use the IBTSDP interface to perform device discovery and determine the 
names and capabilities of the other devices within range on the network. 
â¢ You use the IBTAG interface to interface with Bluetooth audio devices, such 
as headsets, activating or deactivating the audio channel that carries audio 
from the wireless terminal to the audio device. 
â¢ You use the BTSIOPORT interface to establish a connection to a remote 
Bluetooth serial port, such as one on a handheld computer, to 
exchange data. 

Networking Your Data 
Bluetooth is an excellent choice when you're creating an application that 
lets the mobile terminal talk with another device, such as to exchange 
contact I calendar information or pictures taken by a camera-enabled handset. 
Understanding the Network Interfaces 
Once you select the appropriate network interface for your application, you need 
to use the interface in your application. The following sections show in more detail 
how you can use each of the three kinds of network interfaces in your application. 
Understanding the ISocket Interface 
Of the three network interfaces, the Isocket interface (and its companion class, the 
INetMgr interface) is the most complex because it offers the greatest flexibility. At a 
superficial level, the Isocket interface resembles the Berkeley socket interface 
found under Unix, Linux, Mac OS X, and the Winsock interface in that the socket 
provides an entity to which you can write data and from which you can read data. 
However, it has a fundamental difference: All network input/output is asyn-
chronous. As a result, you can't issue a request to read or write data unless the 
socket is in a state to do so. 
This leads to a more complex, yet more flexible, application architecture. 
Because Isocket operations are asynchronous, you can perform additional opera-
tions while your socket is open, giving the impression that the networking occurs 
in the background. Moreover, by structuring your application as a state machine-
with individual states for establishing the connection, reading data, and writing 
data-you can eliminate most of the added complexity. 
Before you can use an Isocket instance, you must create it. Unlike most other 
classes, you can't use ISHE ll_ Createlnstance to create an Isocket instance; instead, 
you use the INetMgr class, which provides a set of interfaces to manage network 
interfaces. This interface includes methods to obtain a host's IP address given its 
host name using INETMGR_GetHostByName, obtaining the status of the network 
support on the handset using INETMGR_Netstatus, and obtaining an ISocket 
instance using INETMGR_Opensocket. Using either the INETMGR_GetHostByName or 
INETMGR _ Open Soc ket calls results in the handset connecting to the network by estab-
lishing a wireless network connection and starting the handset's network stack. 
In most applications, you'll want to establish a connection to a remote host 
using its host name, rather than its IP address, because you can change hosts on 
the server side while retaining the host name, but it's more difficult to do so and 
retain the IP address. Thus, when establishing an Internet connection, you should 
first obtain the IP address of the remote host using its host name. You do this using 
the INETMGR _ GetHostByName function, which takes an INetMgr instance, a pointer to a 
257 

Chapter 10 
258 
structure that will store the resulting IP address, the remote host name, and a 
callback. The invocation looks like this: 
1: void INETMGR_GetHostByName(INetMgr *pINetMgr, 
2: 
3: 
4: 
AEEDNSResult *pres, 
const char *psz, 
AEECallback *pcb ); 
Unlike the other functions that require callbacks you've seen, this function 
requires an AEECallback structure, which is simply a structure that wraps both the 
callback function and application data in one structure: 
1: typedef struct -AEECallback 
2: { 
3: 
AEECallback *pNext; 
4: 
void *pmc; 
5: 
PFNCBCANCEL pfnCancel; 
6: 
void *pCancelData; 
7: 
PFNNOTIFY pfnNotify; 
8: 
void *pNotifyData; 
9: 
void *pReserved; 
10: } AEECallback; 
Rather than accessing the fields of this structure directly, it's best to use the 
CALLBACK_Init macro, like this: 
1: CALLBACK_Init( cb, callbackFunction, pThis ); 
The macro CALLBACK_Init ensures that the callback function (callback-
Function) will be called with the argument pThis, and the macro also initializes the 
parts of the structure responsible for managing cancelled callbacks. 
The AEEDNSResul t structure you pass to INETMGR _ GetHostByName should be allo-
cated in your application context because it must exist throughout the lifetime of 
the Domain Name Service (DNS) request. When your callback is invoked, the 
AEEDNSResul t structure will contain the number of addresses obtained for the spe-
cific host in its nResul t field and an array of nResul t IP addresses for the desired 
host in its addrs field. 
With the IP address of the remote host in hand, you can create a socket to 
make your connection using the INETMGR _ Open Socket method: 
1: pThis->m_pISocket = INETMGR_OpenSocket( pThis->m_pINetMgr, AEE_SOCK_STREAM ); 
This creates a TCP socket. 

Networking Your Data 
This method returns an unconnected ISocket instance, which you connect to 
a remote host: 
1: ISOCKET_Connect( pThis->m_pISocket, 
2: 
3: 
4: 
nIPAddress, 
HTONS(nPort), 
(PFNCONNECTCB)callbackFunction, pThis ); 
This method takes the ISocket interface to connect, the remote network 
address, the remote port, the callback to invoke when the connection is complete, 
and a pointer to the data to pass the callback. 
TIP 
You should be sure to use the HTONS macro to convert the port 
address to network byte order. 
Once the connection establishment is complete, the socket invokes your 
network callback, and you can begin reading and writing data. To do this, use 
the ISOCKET _Read and ISOCKET _Write methods, which take the socket, a pointer 
to the buffer of bytes to write, and the number of bytes to read or write. In return, 
these two functions provide the number of bytes actually read or written, or they 
provide an error code. Most errors indicate a communications error, and you 
should shut down the socket and perform whatever error handling your 
application requires (such as notifying the user and storing the data for a 
later transaction). If, however, one of these calls returns the error code 
AEE_NET_WOULDBLOCK, this indicates the operation can't proceed without blocking 
application flow, and you should retry later. To know when to retry the read or 
write, schedule a callback using either ISOCKET _Readable or ISOCKET _ Writable, and 
the socket will invoke your callback when it can accept another ISOCKET_Read or 
ISOCKET _Write invocation. If at any time you need to cancel the callbacks, you can 
do so using ISOCKET_Cancel, which cancels both callbacks. 
Once you're finished using the socket, you should close it using 
ISOCKET _Release. The handset's network stack will keep the underlying 
physical connection to the Internet via the wireless network for a short time 
so that multiple socket invocations don't require repeated connections to the 
network. If you will be performing operations with multiple sockets in sequence, 
you can adjust this time (called the linger time) using INETMGR_SetLinger, which 
takes the desired linger time as a time in milliseconds and returns the previously 
set linger time. In practice, you want to experiment to find the optimum linger 
time for your application, but a typical delay is around 30 seconds, which spans 
259 

Chapter 10 
260 
enough time for a user to perform another action that leads to initiating another 
network transaction without leaving the connection open unduly long. 
To manage the asynchronous cycle of obtaining a remote IP address, reading and 
writing data, and managing errors, you can use multiple states within your appli-
cation. Generally, you can create a state for each of the phases of a socket's life cycle: 
â¢ Creating the INetMgr instance, setting the linger time with INETMGR _Set Linger, 
and starting the IP address resolution using INETMGR _ GetHostByName. 
â¢ Handling the resulting callback from INETMGR _ GetHostByName, creating the 
socket using INETMGR_OpenSocket, and connecting the socket to the remote 
host using ISOCKET _Connect. This state can also release the INetMgr instance 
using INETMGR_Release. 
â¢ Reading data, invoked by ISOCKET _Readable. 
â¢ Writing data, invoked by ISOCKET_Writable. 
â¢ Closing the socket with ISOCKET _Release. 
â¢ Handling errors at any point with a specific error state that releases the 
socket and network manager and handles the specific error. You can 
determine the nature of the error using INETMGR _ GeUastError and 
ISOCKET_GetLastError. 
In conjunction with these states, you can maintain two buffers-one for 
output to the remote host and one for input from the remote host-and update 
application state based on the flow of your protocol as your application moves 
between its reading and writing states. 
In a few circumstances, your network protocol may require that you use data-
grams via the Unconnected Datagram Protocol (UDP), rather than TCP sockets, as 
described here. To do this, simply pass the AEE _DGRAM option to INETMGR _ OpenSocket, 
and instead of using ISOCKET_Read and ISOCKET_Write, use ISOCKET_SendTo and 
ISOCKET_RecvFrom. Like ISOCKET_Read and ISOCKET_Write, when these interfaces 
block application execution, they return AEE_NETWOULDBLOCK, and you can schedule 
a callback using ISOCKET_Readable or ISOCKET_Writable. 
Understanding the IWeb Interface 
In principle, the IWeb interface is simple to use: You instantiate it, give it a URL and 
a callback, and await the response. In practice, however, using the interface can be 
significantly more complex depending on the options you want to include with 
the request. 

Networking Your Data 
The key to mastering the IWeb interface is understanding the options available 
to you when using the interface. Table 10-1 shows the various options, each of type 
WebOpt. 
Table 10-1. IWeb Interface Options 
OPTION 
ARGUMENT 
PURPOSE 
WEBOPT_ACTIVEXACTIONS 
uint32 
This is the maximum number of 
allowed transactions; the interface 
handles overflow by enforcing 
queuing. 
WEBOPT CONNECTTIMEOUT 
uint32 
This is the connection timeout in 
milliseconds to pass to the underlying 
network socket. 
WEBOPT_CONTENTLENGTH 
uint32 
This is the content length of object 
body in request or response. 
WEBOPT HANDLERDATA 
void * 
This is the pointer to application-
specific data for the transaction 
callback. 
WEBOPT_HEADER 
char * 
This is the pointer to a character string 
containing carriage retum-separated 
and linefeed-separated H1TP headers. 
WEBOPT_HEADERHANDLER 
PFNWEBHEADER 
This is the pointer to a callback to 
invoke with each H1TP header in the 
response. 
WEBOPT IDLECONNTIMEOUT 
uint32 
This is the idle timeout in 
milliseconds. 
WEBOPT METHOD 
char * 
This is the pointer to a character string 
containing the H1TP request type. The 
default is "GET". 
WEBOPT_PROXYSPEC 
char * 
This is the pointer to a URL to a host to 
use as an HTTP proxy. 
WEBOPT STATUSHANDLER 
PFNWEBSTATUS 
This is the pointer to a callback to 
invoke periodically with transaction 
status. 
WEBOPT USERAGENT 
char * 
This is the pointer to a character string 
containing the user-agent string. 
261 

Chapter 10 
262 
In most cases, the only header you're likely to want to change is the 
WEBOPT _METHOD header, which lets you specify the type of HTTP request. (For 
an in-depth overview of HTTp, see the World Wide Web Consortium's Request for 
Comment 2616.) The default value is "GET", which fetches a document from a 
remote server, but often you want to use" POST", which sends a block of remote 
data to the server instead. When doing so, you should also use 
WE BOPT _ CONTENTLENGTH to indicate how large the block of data your application is 
sending to the server. 
Perhaps more important, you can supply pointers to two additional callbacks: 
one invoked with each header the IWeb interface receives and one invoked period-
ically to provide your application with status notifications. You use the 
WEBOPT _ HEADERHANDLER to supply a pointer to a callback function with this signature: 
1: typedef void (*PFNWEBHEADER)(void *pNotifyData, 
2: 
3: 
const char *pszName, 
GetLine *pglVal)j 
The first argument is the data you set using WEBOPT _ HANDLERDATA; more than 
likely, it's your application pointer. The second argument is the name of the header 
(such as "Content-Type" or "Content-Encoding"). The last argument is a pointer to a 
GetLine structure, with the header's value stored in its psz field. (Your callback 
doesn't need to free either pszName or pglVal before it exits.) 
Similarly, you can provide a status callback with the following signature: 
1: typedef void (*PFNWEBSTATUS)(void *pNotifyData, 
2: 
3: 
WebStatus ws, 
void *pData)j 
The IWeb interface invokes this callback periodically throughout a transaction, 
including status about the transaction in the ws argument. The WebStatus field is an 
enumeration, with the values shown in Table 10-2. 

Networking Your Data 
Table 10-2. The WebS tat us Enumeration and Meanings 
VALUE 
MEANING 
WEBS STARTING 
The connection is starting. 
WEBS CANCELLED 
The connection has been cancelled. 
WEBS GETHOSTBYNAME 
The IWeb interface is determining the IP address of the remote 
host. 
WEBS CONNECT 
The IWeb interface has connected. 
WEBS_SENDREQUEST 
The IWeb interface is sending the request. 
WEBS_READRESPONSE 
The IWeb interface is reading the response. 
WEBS GOTREDIRECT 
The IWeb interface received a redirect to another URL. 
WEBS CACHEHIT 
The IWeb interface found the desired content in its cache. 
After creating an IWeb instance with ISHELL_Createlnstance, you use the 
IWEB_GetResponse method to start a Web transaction. 
It takes the following arguments: 
1: 
IWEB_GetResponse( pIWeb, 
2: 
(pIWeb, piWResp, pcbFunc, pszUrl, 
3: 
WEBOPT_END)) ; 
TIP 
The extra set o/parentheses when invoking IWEB _ GetResponse is 
crucial because the function is actually a macro that condenses the 
options you specify. 
IWeb places the results of the request in the piWResp structure, which is a 
pointer to an IWebResp interface. Because of this, it's important you don't allocate 
this structure on your stack but instead place it somewhere in your application 
context. Otherwise, when the IWeb request finishes, it'll write to a variable that's 
263 

Chapter 10 
264 
now out of scope, corrupting the call stack. The callback function, pcbFunc, has this 
signature: 
1: void WebAction_GotResp( void *p ) 
where p points to the callback data you set using WEBOPT _ HANDLERDATA. The 
pszURL argument points to the URL that the IWeb interface should fetch, and after 
that argument comes a comma-delimited list of Web Opt options and their 
arguments. 
Once your callback returns, you can obtain the results of the transaction by 
calling the IWebResp interface's IWEBRESP _ Getlnfo method, which returns a 
WebResplnfo structure. It has the following fields: 
1: typedef struct 
2: 
{ 
3: 
int nCodej 
4: 
ISource *pisMessagej 
5: 
long lContentLengthj 
6: 
const char *cpszContentTypej 
7: 
const char *cpszCharsetj 
8: 
int32 tExpiresj 
9: 
int32 tModifiedj 
10: } WebResplnfoj 
The result data is available through the pisMessage field, which is an ISource 
instance you can use or convert to an IStream using the 
ISOURCEUTIL_AStreamFromSource method. The nCode field stores the HTIP result 
code (such as 200 for a valid response), and the lContentLength contains the 
number of bytes (ifknown) in the response. You can obtain the content type using 
the cpszContentType field and the character set using the cpszCharset field. Finally, 
you can determine the data's expiry (for caching) and last-modified date using the 
tExpires and tModi fied fields. 
Understanding BDSMS 
Using BDSMS is strikingly easy. By addressing an SMS message to a specific class 
10, the application receives an EVT_APP _MESSAGE event when the SMSmessage is 
received. Thus, all you need to do is format an SMS message correctly, and your 
application will receive the message. A BDSMS message looks like this: 
1: IIBREW:classid:message 

Networking Your Data 
where classid is the class ID of the class to receive the message, and message is 
the message that QUALCOMM BREW will deliver to your application. Once 
QUALCOMM BREW detects the incoming BDSMS, it'll strip the leading part of the 
message and deliver message as a pointer to the memory region with its contents as 
the event handler's dwParam argument. Thus, all your application needs to do is 
include an event handler for EVT _APP _MESSAGE in its event handler and then access 
the contents of*dwParam to obtain the contents of the message. 
Your application can receive BDSMS messages whether or not it's running. If 
your application isn't running, the shell will first invoke your AEEClsCreatelnstance 
function to create an instance of your application and then send it the 
EVT _ APP _MESSAGE event. You can either handle the message at that time (bearing in 
mind that your application is closed, and you can't perform any user interface 
interaction) or invoke ISHELL_StartApplet to launch your application to handle the 
message. If, on the other hand, your application is already running, it simply 
receives the EVT_APP _MESSAGE message as just another event to handle. 
In the next chapter, you'll learn about other ways to handle SMS messages in 
general using the QUALCOMM BREW notification mechanism, such as how you 
can view the text of any incoming message. 
Summary 
The following are the key points you learned in this chapter: 
â¢ You can access raw sockets for client -side applications through the INetMgr 
and the ISocket interfaces. 
â¢ You use the IWeb interface to make HTTP requests of remote Web servers, 
including retrieving and posting data. 
â¢ You use BDSMS messages to send application-specific data. Your appli-
cation receives this data packaged with an event, regardless of whether it's 
running. 
265 

CHAPTER 11 
Controlling the Handset 
DESIGNED TO MEET the needs of Original Equipment Manufacturers (OEMs) as well 
as application developers, the QUALCOMM BREW platform offers a bevy of inter-
faces you can use to control the handset directly or to access features traditionally 
controlled by handset OEMs, such as the built -in address book and ring tones. 
This chapter presents a survey of these interfaces, including how to send and 
receive a Short Message Service (SMS) message, determine the handset's position, 
access the built-in address book and ringer control applications, manage your 
application's licensing, and initiate a voice call. Next, the chapter shows you how 
to package a segment of code as an extension, a component that presents the same 
kind of interface as a QUALCOMM BREW interface but that you can share between 
applications or sell to other developers. After reading this chapter, you'll have a 
good understanding of how to control the handset's native telephony functions 
and use them to create novel applications or add features to your existing 
application. 
Understanding How You Can Control the Handset 
You can control many aspects of handset operation, including sharing data 
between applications and sharing data between your application and specific 
OEM applications such as the address book and ringer application. This is a 
powerful feature of QUALCOMM BREw. With features and interfaces similar to 
high-end wireless handsets running the Palm Powered or Microsoft Pocket PC 
Smartphone platforms, you can create applications with unprecedented integra-
tion on handsets affordable to the majority of consumers today. 
Accessing the Built-in Address Book 
Wireless handsets include a built-in address book application that lets you store 
the names, phone numbers, and email addresses of contacts, which you can then 
use to make phone calls or to send an SMS. 
267 

Chapter 11 
268 
The OEM address book is organized as a set of address book records. Each 
address book record is a set of address book record fields, a category designation, 
and an associated ID. Each field contains the data associated with that field, as 
well as an ID and a type. A record can only hold a single datum-if a record has two 
home phone numbers, for example, it will have two fields, one for each home 
phone number. The IAddrBook interface contains methods to access the address 
book itself, and the IAddrRec interface contains the methods to manipulate a spe-
cific record. Using these classes, you can create new records in the OEM address 
book, delete records, and modify individual fields in a specific record. You do this 
using an interface similar to the database interfaces you saw in Chapter 7, "Storing 
Data." 
After creating an IAddrBook instance using ISHELL_CreateInstance, you iterate 
either across the categories of address book records using 
IADDRBOOK_EnumCategoryInit and IADDRBOOK_EnumNextCategory or across the records 
in the address book using IADDRBOOK_EnumRecInit and IADDRBOOK_EnumNextRec. The 
record iterator lets you iterate across all records in the database or search for a spe-
cific record that contains a specific field, a specific substring in one of its fields, or 
a specific record that belongs in a specific address book category. Once you begin 
the search using IADDRBOOK_EnumRecInit, you call IADDRBOOK_EnumNextRec repeatedly 
to obtain the records that match your search criteria. This method returns an 
instance of IAddrRec for each matching record or NULL if no more records match the 
search criteria you specified when calling IADDRBOOK_EnumRecInit. 
With an IAddrRec instance in hand, you can obtain or change its category using 
IADDRREC _ GetCategory and IADDRREC _ Set Category . To obtain a specific field, first use 
IADDRREC_GetFieldCount to obtain the number of fields in the record and then 
iterate across all of the fields using IADDRREC_GetField, which takes the IAddrRec 
instance and the index of the field to fetch, returning an AEEAddrField structure: 
1: typedef struct 
2: { 
3: 
AEEAddrFieldlD flDj 
4: 
AEEAddrFieldType fTypej 
5: 
void *pBufferj 
6: 
uint16 wDataLenj 
7: } AEEAddrFieldj 
The first member, fID, is simply the field ID as an enumeration (with values 
such as WORK_PHONE or URL). The fType field is the data type used to store the string 
and is a constant, such as FT _STRING, that matches the data types defined by the 
database Application Programming Interfaces (APls). The value of the field is 
stored in the memory region at pBuffer, and the size of the record's data is stored in 
wDataLen. 

Controlling the Handset 
You can also add new fields by filling out an AEEAddrField structure and 
calling IADDRREC_AddField, or you can remove a field by specifying its index 
and calling IADDRREC_RemoveField. Once you change a field's contents, you should 
call either IADDRREC_UpdateField (to update a single field in a record) or 
IADDRREC_UpdateAllFields (to update an entire record). 
Uyou want to add a field, you create an IAddrRec instance using the 
IADDRBOOK _ CreateRec instance. This method lets you create a new address book 
entry in a specific category with the fields you specify. Once you create it, you can 
manipulate it just like any other IAddrRec instance or simply release it because the 
process of creating the record automatically adds it to the address book. Uyou 
need to remove a record, you can do so using the IADDRREC _ RemoveRec method. To 
remove all records in the address book, use IADDRBOOK_RemoveAllRecs. 
TIP These interfaces are only available in handsets running versions of 
the QUALCOMM BREW platform 1.1 and beyond and may not be avail-
able on all handsets. When creating an IAddrBook instance, be sure to 
check the return value and handle creation failures accordingly. More-
over, your application must have the Access to Address Book privilege set 
in its Module Information File (MIF) to be able to use these interfaces. 
Managing an Application's Licensing 
A feature unique to the QUALCOMM BREW platform is its integrated support for 
managing application licensing-under what circumstances the application is 
allowed to run on the handset. The original licensing terms are set at the appli-
cation's time of purchase and are automatically maintained by the platform on 
behalf of the application. 
There are times, however, when you may want your application to assume 
responsibility for adjusting its licensing characteristics. A game, for example, 
might award additional free play beyond the number of plays purchased, or you 
may want to limit the features accessible in a demo release of the application. 
You can perform operations such as these using the ILicense interface, which 
lets you adjust an application's license count on the handset. 
269 

Chapter 11 
270 
An application can have one of the following kinds of licenses: 
â¢ No expiration at all, indicated by AEELicenseType ofLT_NONE 
â¢ A per-use license, indicated by AEELicenseType of LT_USES 
â¢ Application expiration on a specific date, indicated by AEELicenseType of 
LT DATE 
â¢ Application expiration after a certain number of days of downloading, 
indicated by AEELicenseType of LT_DAYS 
â¢ Application expiration after a certain number of minutes of use, indicated 
by AEELicenseType of LT_MINUTES_OF _USE 
You can determine which kind of license was purchased with the application 
using the method I LICENSE _ GetInfo. If the application is licensed on a per-use 
basis, QUALCOMM BREW doesn't perform any license verification, and you 
should use ILICENSE_DecrementUsesRemaining and ILICENSE_IncrementUsesRemaining 
at appropriate times in your application to deduct or increase the number of times 
your application can be used (such as after completing a game, completing a game 
level, or downloading a Web resource). You can also set the number of uses using 
ILICENSE_SetUsesRemaining if you need to set it to a specific value. 
Your application can also test to see under what terms the application was 
purchased and when it'll expire if it's using one of the other license mechanisms 
such as I LICENSE _ GetPurchaseInfo, which returns not just the kind oflicense but 
the time (in seconds according to the handset's internal clock) at which the license 
will expire. 
Using Telephony Features 
Although this book has treated QUALCOMM BREW-enabled handsets as well-
connected handheld computers, they're of course wireless handsets, complete 
with voice telephony features. The QUALCOMM BREW platform includes the 
IT API interface, which gives you access to a simple Telephony Application Pro-
gramming Interface (TAPI) that lets you initiate a voice call, send an SMS message, 
obtain the text of an SMS message, get the handset's calling status, and get the 
caller ID information of an incoming call if it's available. 
After creating an instance of ITA PI using ISHELL_CreateInstance, you can get 
the current state of the handset's telephony interface using the ITAPI_GetStatus 
method to which you pass the ITAPI instance and an empty TAPIStatus structure. 

Controlling the Handset 
Upon return, this structure will be filled with information about the handset. The 
structure has the following fields: 
1: typedef struct 
2: { 
3: 
char szMobileID[MOBILE_ID_LEN +1]; 
4: 
PhoneState state; 
5: 
flg bData:1; 
6: 
flg bDigital:1; 
7: 
flg bRoaming:1; 
8: 
fIg bCaIIEnded:1; 
9: 
fIg bE911CaIIbackMode:1; 
10: 
fIg bRestricted:1; 
11: } TAPIStatus; 
The szMobileID field provides the handset's mobile number, typically (but not 
always) the Mobile Directory Number (MDN) registered with the wireless carrier. 
The state field provides an indication of the handset's current state via an enumer-
ation, indicating such things as whether the handset is offline, idle, originating a 
call, receiving a call, or in the middle of a call. The remaining flags indicate capa-
bilities or handset states, as follows: 
â¢ The bData flag indicates whether the handset is making a data call. 
â¢ The bDigital flag indicates whether the handset is receiving digital 
coverage. 
â¢ The bRoaming flag indicates whether the handset is currently roaming on 
another network. 
â¢ The bCallEnded flag indicates if a call has just ended and is only set when 
your application receives this structure as part of a notification (discussed in 
the following section). 
â¢ The bE911CallbackMode flag indicates if the handset is in emergency 911 
callback mode. 
If a call is in place, you can obtain the telephone number of the remote side of 
the call using the ITAPI_GetCallerID field, which returns the corresponding tele-
phone number as a string in an AECHAR buffer you provide. Typically, you can only 
do this when immediately originating a call (on suspend or resume) because your 
application can't run while a voice call is in operation. 
271 

Chapter 11 
272 
You can also initiate a voice call using ITAPI_MakeVoiceCall, which suspends 
your application to make the voice call. When you invoke this method, the handset 
performs the following steps: 
1. The handset displays a confirmation dialog box to the user. 
2. When the user dismisses the dialog box, the shell sends the event 
EVT _DIALOG_END to your application. 
3. Your application should redraw the screen with the contents visible prior 
to calling ITAPI_MakeVoiceCall. 
4. If the user confirmed placing the call, the shell sends the event 
EVT _ APP _SUSPEND to your application. Once your application handles the 
event, the handset will place the call. 
5. When the call is complete, the shell sends the event EVT_APP _RESUME to 
your application. 
6. Your application must resume and redraw the screen. 
When you place a voice call, you can monitor its status using the 
ITAPI_OnCallStatus method, which registers a callback in your application that will 
be invoked when there are changes in call status, such as when the remote side has 
answered or disconnected. This method is the same as the ITAPI_OnCallEnd 
method. 
To send an SMS message, use the ITAPI _ SendSMS method, passing the contents 
of the SMS message and a callback that the shell will invoke periodically 
throughout the transmission of the SMS message. When you invoke this method, 
the handset does the following: 
1. The handset begins the process of sending the SMS message. 
2. The shell sends your application the EVT_APP _SUSPEND event. 
3. The shell invokes the notification function you registered when calling 
ITAPI_SendSMS with the status of the message delivery. 
4. The shell sends your application the EVT_APP _RESUME event. 
Although your application's callback is invoked while your application is sus-
pended, it's best to simply cache aside the status from the transaction and display 
it once your application resumes. 

Controlling the Handset 
Finally, using !TAPI you can intercept any SMS message sent to the handset. 
Doing this requires that you register for notifications from the lTAPI class, either in 
your MIF or by calling ISHE LL_RegisterNoti fy. Once you do so, each incoming SMS 
message generates an EVT _NOTIFY event to your application. This event includes an 
AEENotify structure, pointed to by the event's dwParam: 
1: typedef struct 
2: { 
3: 
AEECLSID cIs; 
4: 
INotifier * pNotifier; 
5: 
uint32 dwMask; 
6: 
void * pDataj 
7: 
AEENotifyStatus st; 
8: } AEENotify; 
The contents of the incoming SMS message are at the location indicated by 
pData. You can get at it using this (rather ugly) bit of casting code: 
1: 
AEESMSMsg *pSMS = (AEESM5Msg *)Â«AEENotify *)(dwParamÂ»->pData; 
The resulting structure AEESMSMsg isn't formally documented by QUALCOMM, 
so you probably shouldn't rely on its contents. A quick peek at the AEETAPI.h file 
shows its contents, which includes the sender's mobile number, the priority of the 
message, and the time at which the message arrived. 
With the SMS message in hand, you can obtain its text representation using 
!TAPI_ExtractSMSText, which returns AEESMSTextMsg with the following members: 
1: typedef struct 
2: { 
3: 
uint16 nChars; 
4: 
char szText[l]; 
5: } AEESMSTextMsg; 
Because the SMS message may contain both text and binary data on some 
networks, AEESMSTextMsg contains both the length of the SMS message as well as 
the data itself. (Note that szText isn't really a I-byte array, but rather the message 
begins at &szText and continues past the end of the structure.) 
The !TAPI interface can also send your application notifications of other tele-
phony occurrences via status changes (which send your application a TAPIStatus 
structure at the notification's pData). 
273 

Chapter 11 
274 
TIP 
The ITAPI interface may not be available on some early handset 
models. When creating an IT AP I instance, be sure to check the return 
value and handle creation failures accordingly. Moreover, your applica-
tion must have the TAPI privilege set in its MIF to be able to use this 
interface. Finally, not all versions of the QUALCOMM BREW platform 
support all methods, so check the AEETAPl.h file for the version of 
QUALCOMM BREW for which you're developing. 
Determining the HandsetJs Position 
In the late 1990s, the Federal Communications Commission (FCC) passed a ruling 
(later known as the E911 initiative) that required all cell phones be able to provide 
their locations to emergency dispatch centers when calling 911 in order to help 
emergency response workers reach the scene of an emergency. Handsets shipping 
today all include this technology, called gpsOne; it uses a combination of Global 
Positioning System (GPS) and cellular network information to determine the 
wireless handset's position to within a few meters anywhere the handset has 
digital coverage. 
The QUALCOMM BREW platform includes the IPosDet interface to obtain the 
handset's location, either by identifying the wireless carrier's sector (which can be 
used in carrier-specific applications) or by obtaining the handset's latitude, lon-
gitude, and elevation, along with its speed and direction if the handset is moving. 
(There's also the simpler-to-use ISHELL_GetPosition API, which returns a simple 
data structure to a callback method.) When integrated with Web-based services, 
this opens a new market for location-aware applications, such as those providing 
navigation, directory services, messaging, and gaming. 
Using the IPosDet interface to obtain the handset's position is easy: You simply 
create an IPosDet interface using ISHELL_CreateInstance and call 
IPOSDET _ GetGPSInfo. It'll return either SUCCESS or an error code, and then it'll invoke 
a callback you pass with the requested information. You must also pass a valid 
AEEGPSInfo structure, which will remain in scope until the shell calls your appli-
cation callback (so don't allocate it on the stack). The AEEGPSInfo structure has the 
following fields you can examine in your callback function: 
1: typedef struct _AEEGPSInfo 
2: { 
3: 
uint32 dwTimeStamp; 
4: 
uint32 status; 
5: 
int32 dwLat; 

Controlling the Handset 
6: 
int32 dwLonj 
7: 
int16 wA1titudej 
8: 
uint16 wHeadingj 
9: 
uint16 wVe1ocityHorj 
10: 
intB wVe10cityVerj 
11: 
AEEGPSAccuracy accuracyj 
12: 
uint16 fValidj 
13: 
uint8 bHorUncj 
14: 
uint8 bHorUncAng1ej 
15: 
uint8 bHorUncPerpj 
16: 
uint16 wVerUncj 
17: } AEEGPSlnfoj 
The dwTimestamp field contains the time in seconds in GPS time 
(since 116/1980) obtained. The status field indicates whether the request 
succeeded or failed. The dwLat and dwLon fields indicate the handset's position 
in degrees, with dwLat being in units of 180/2/\25 degrees and dwLon being in units 
of 360/2/\26 degrees. The wAltitude field specifies the altitude in meters, and the 
wVe10cityHor and wVe10cityVer indicate the velocity in quarter-meter units. The 
wHeading field indicates the current heading in 360/2/\ 10 degrees, and the 
remaining fields indicate the uncertainty associated with the measurement. The 
most important field is the fValid field, which contains a union of flags indicating 
which of the fields (latitude, longitude, elevation, heading, and velocity) were 
actually measured. The data is returned as World Geodetic System 1984 (WGS-84) 
datum, so it's compatible with the most recent topographic data available. 
TIP 
The IPosDet interface may not be available on some early handset 
models. When creating an I PosDet instance, be sure to check the return 
value and handle creation failures accordingly. Moreover, your applica-
tion must have the Access to Sector Information privilege set in its MIF to 
be able to use this interface. Finally, some carriers may not expose the 
handset's location information to the QUALCOMM BREW platform, and 
on these platforms, either the IPosDet interface can't be created or its 
methods will return obviously incorrect values. 
Managing Ringer Tones 
The rich audio capabilities of the QUALCOMM BREW platform (see Chapter 9, 
"Playing with Sounds") aren't features of the QUALCOMM BREW platform itself 
but rather the underlying chipset provided by QUALCOMM. As a result, most 
275 

Chapter 11 
276 
handsets can play ring tones when receiving calls using the same audio types. To 
facilitate installing custom ring tones, the QUALCOMM BREW platform includes 
the IRingerMgr interface, which lets you install new ring tones on the handset. 
Using the IRinger interface, you can do the following: 
â¢ Enumerate the various categories of ring tones on the handset. 
â¢ Enumerate the ring tones on the handset. 
â¢ Set the current ring tone. 
â¢ Create a new ring tone for use by the handset. 
â¢ Get a list of supported ringer types on the handset. 
â¢ Fetch information about a specific ringer. 
â¢ Playa specific ring tone. 
To install a ring tone, you first want to make sure that the same ring tone isn't 
installed. To do this, you iterate over all the ring tones on the handset using the pair 
of functions IRINGERMGR_EnumRingerlnit and IRINGERMGR_EnumNextRinger. The 
IRINGERMGR_EnumNextRinger returns a structure that describes the ringer: 
1: typedef struct _AEERingerInfo 
2: { 
3: 
AEERingerID idj 
4: 
AEESoundPlayerFile formatj 
5: 
char szFile[MAX_FILE_NAME]j 
6: 
AECHAR sZName[MAX_RINGER_NAME]j 
7: } AEERingerInfoj 
This structure includes the ringer's unique 10 (id), the ringer's 
data format (format)-which is one of AEE_SOUNDPLAYERJILE_MIDI or 
AEE_SOUNDPLAYER_FILE_MP3-the name of the file in which the ringer data is 
stored (szFile), and the human-readable name of the ringer (szName). 
You can set the active ring tone by using IRINGERMGR_ SetRinger or by passing 
the ring tone's 10. You can preview a specific ringer by using the IRINGERMGR_Play 
and IRINGERMGR_Stop methods. (There's also a more advanced playback interface, 
which resembles the ISoundPlayer interface you learned about in Chapter 8, 
"Drawing Graphics.") 

Controlling the Handset 
Before installing a new ringer, you should check that the handset supports the 
format of the ringer. To do this, you can use the IRINGERMGR_GetFormats method, 
which provides an array of the formats that the handset supports. Once you're sure 
that the handset supports the format of the ring tone you want to install, simply 
call IRINGERMGR_Create with the data for the ring tone as a stream, its human-
readable name, and its format. Of course, you can always remove a ring tone, too, 
using IRINGERMGR _Remove and passing the ID of the ring tone to remove. 
TIP 
To use the IRingerMgr interface, your application must have the 
Write access to Ringer directory privilege set in its MIE 
Sharing Code Between Applications 
The QUALCOMM BREW platform provides developers with the ability to create 
extensions, which are similar in concept to shared libraries that can be used across 
multiple applications. An extension provides the same kind of interface as a native 
QUALCOMM BREW interface. It can be kept private to an application or shared 
among developers by being sold via the QUALCOMM BREW Delivery System, 
allowing developers to make money by selling value-added modules to other 
QUALCOMM BREW developers. For example, you might choose to offer an 
extension that implements a player for a specific media type or a new kind of user 
interface control. Your applications can use this extension, and, at your discretion, 
other developers can license your application, letting you make money when sub-
scribers download their applications that use your extension. Most important, the 
entire extension model is hidden from wireless subscribers because extensions are 
transparently downloaded when they're needed by an application. Equally 
important, when you download several applications that require an extension, the 
extension itself only downloads once. 
An extension is a module, just like an application. As such, it must inherit from 
the IBase interface, implementing the AddRef and Release methods, which are 
responsible for tracking and releasing the resources used by the extension. Coding 
an extension isn't much more difficult than writing an application, but it takes a 
little more time and a bit of a deeper understanding of the QUALCOMM BREW 
platform because you must implement the module's setup, teardown, and method 
dispatch table by hand. 
277 

Chapter 11 
278 
Understanding the Life Cycle of a Module 
When your application calls ISHELL _ Createlnstance, the shell queries each module 
with the desired class ID by calling its AEEClsCreatelnstance function. This function 
is a module's entry point, just as main is a traditional C program's entry point. In 
previous chapters, you've seen the sample AEEClsCreatelnstance, which typically 
looks something like Listing 11-1. 
Listing 11-1. The Genesis of a Module Such As an Application or an Extension 
1: int AEEClsCreatelnstance( AEEClSID clsld, 
2: 
IShell *pIShell, 
3 : 
IModule *po, 
4: 
void **ppObj ) 
5: { 
6: 
int result = EFAllED; 
7: 
*ppObj = NUll; 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: } 
if (AEEClSID_THEEXTENSION == clsld) 
{ 
result = ExtensionCls_New( sizeof(Extension), 
pIShell, 
po, 
(IModule **)ppObj); 
if ( result == SUCCESS ) 
{ 
} 
} 
result = Extension_Init( (void *) *ppObj ); 
if ( result != SUCCESS) 
{ 
Release( (IExtensionCls *)*ppObj ); 
} 
return result; 
II Wrong class, _New or _Init failed 
return result; 
This routine simply checks the incoming class ID against the module's ID 
(line 9) and, if they match, creates a new instance of the module (lines 11-14) and 
initializes its member variables (lines 15-23). Because all extensions are modules, 
a module has the same entry point, too. 

Controlling the Handset 
Defining the Extension Interface 
For the applications you've seen throughout this book, the QUALCOMM -provided 
AEEAppGen.c file handles setting up your application's interface. This isn't so with 
an extension, where you must define the extension's interface by hand. 
A module's interface is stored in a virtual function table (called a utable), much 
like the virtual function tables used by C++. The first element of a module is a 
pointer that points to the module's vtable, which typically resides at the end of 
a structure defining the module. You can see this by looking at any of the interface 
definitions in the QUALCOMM BREW include files. For an extension, it looks 
like this: 
1: struct IExtensionCls 
2: { 
3: 
struct _IExtensionClsVtbl *pvt; 
4: }; 
5: typedef struct _lExtensionClsVtbl lExtensionClsVtbl; 
6: struct _lExtensionClsVtbl 
7: 
8: 
9: 
10: 
{ 
uint32 
uint32 
(*AddRef)(lExtensionCls *); 
(*Release)(lExtensionCls *); 
11: 
II Put your methods here. 
12: }; 
13: 
14: typedef struct _lExtensionCls lExtensionCls; 
15: typedef struct _lExtensionCls lExtension; 
This defines an extension with two methods, AddRef and Release. All 
extensions should implement these methods (in this order) to correctly 
implement the lBase interface. The lExtensionClsVtbl structure defines the 
extension's interface with two functions, and the extension itself consists of a 
pointer to lExtensionClsVtbl, which contains the addresses of those two functions. 
This is a public definition of the extension interface. It's information you must 
share with other users of the extension because it describes how to call the 
methods provided by your extension. However, because dereferencing the func-
tions in your extension's vtable using these structures is a messy and error-prone 
279 

Chapter 11 
280 
operation, it's best to provide macros to do this for users of your extension. For 
example: 
1: #define IEXTENSION_AddRef(p) \ 
2: 
GET_PVTBL(p, IExtension)->AddRef(p) 
3: 
4: #define IEXTENSION_Release(p) \ 
5: 
GET_PVTBL(p, IExtensionCls)->Release(p) 
The QUALCOMM-supplied GET _PVTBL macro performs just the necessary 
skullduggery to obtain the address of the appropriate function in the extension's 
vtable: 
1: #define GET_PVTBL{p,iname) 
Â«iname*)p)->pvt 
Of course, your extension probably needs its own member variables and other 
such things, too. You do this by defining a private version of your extension 
structure, which has as its first element a pointer to the extension's vtable and, as 
its last element, the vtable itself. The extension member variables are sandwiched 
between the following: 
1: struct _Extension 
2: { 
3: 
II note: this needs to be the first item in this structure 
4: 
III Virtual function table 
5: 
IExtensionCls vtExtensionClsj 
6: 
7: 
III @name Member variables 
8: 
//@{ 
9: 
III References to us 
10: 
uint32 
m_nRefsj 
11: 
III copy of Shell pointer 
12: 
IShe11 
*m-pIShellj 
13: 
III IModule interface pointer 
14: 
IModule 
*m_pIModulej 
15: 
//@} 
16: }j 
17: typedef struct _Extension Extensionj 
18: typedef struct _Extension *ExtensionPtrj 
Within this extension's implementation, the extension itself is referred to as 
the structure Extension. It contains the extension's vtable (line 5), its reference 
count (line 10) used by AddRef and Release to track usage, the shell it's given on 

Controlling the Handset 
initialization (line 12), and its module (line 14). Because Extension's fields are a 
superset ofIExtensionCls, the implementation of the extension can take a valid 
pointer to IExtensionCls and cast it to an Extension to obtain its private data. 
Moreover, because the format of the extension structure is kept private within 
the implementation of the extension, its members won't be available to users 
of the extension. 
Initializing the Extension 
At some point during initialization, you need to set up the extension's vtable 
as well as its private data. Typically, you do this during the invocation of 
AEEClsCreateInstance. I like to do this right away using a separate function, such 
as Extension_New, which performs roughly the same things as a C++ constructor 
does (see listing 11-2). 
Listing 11-2. Creating an Extension and Its vtable 
1: int ExtensionCls_New( int16 nSize, 
2: 
IShell *pIShell, 
3: 
IModule *pIModule, 
4: 
IModule **ppMod) 
5: { 
6: 
Extensionptr pThis = NULLj 
7: 
VTBL(IExtensionCls) *modFuncsj 
8: 
9: 
II validate parameter(s) 
10: 
if(!ppMod I I IpIShell I I !pIModule) 
11: 
{ 
12: 
return EFAILEDj 
13: 
} 
14: 
15: 
*ppMod = NULLj 
16: 
17: 
II Allocate memory for the object 
18: 
if(nSize < sizeof(ExtensionÂ» nSize += sizeof(Extension)j 
19: 
20: 
pThis = (ExtensionPtr) 
21: 
MALLOC(nSize + sizeof(IExtensionClsVtblÂ»j 
22: 
23: 
if (NULL == pThis) 
24: 
{ 
25: 
return ENOMEMORYj 
281 

Chapter 11 
282 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
58: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
} 
1* Allocate the vtbl and initialize it. 
Note that the modules and apps must not 
have any static data. 
Hence, we need to allocate the vtbl as well. 
*1 
modFuncs = (IExtensionClsVtbl *)Â«byte *)pThis + nSize)j 
II Initialize individual entries in the VTBL 
modFuncs->AddRef 
= AddRefj 
modFuncs->Release 
= Releasej 
II ... Add your vtable here. 
II initialize the vtable 
INIT_VTBL(pThis, IModule, *modFuncs)j 
II initialize the data members 
pThis->m_nRefs 
= 1j 
pThis->m_pIShell 
= pIShellj 
pThis->m_pIModule 
= pIModulej 
II Add References 
ISHELL_AddRef(pIShell)j 
IMODULE_AddRef(pIModule)j 
II Set the pointer in the parameter 
*ppMod = (IModule*)pThisj 
return AEE_SUCCESSj 
} 
This function shows a lot about how an extension-or even your appli-
cation-is initialized behind the scenes, so let's take it a line at a time and see what 
it does. It begins with the size of the extension, a reference to the instantiating 
shell, a valid module pointer, and a pointer into which to place the newly allocated 
module that will be the extension. line 7 uses the QUALCOMM-supplied macro 
VTB L to declare a pointer to the extension's vtable, which you later fill with pointers 
to the extension's public methods. 
lines 10-13 do the usual validation of arguments because if any of these 
pointers are invalid for any reason, the handset will crash trying to create the 

Controlling the Handset 
extension-a very bad thing. Next, you determine how much space to allocate 
(lines 18-21) and allocate it. You need enough space for the extension structure 
itself (including its private variables on line 18), along with the extension's vtable 
(line 21), which will piggyback on the end of the allocated Extension structure. 
lines 23-26 perform more error checking and return with an error code signaling 
an out-of-memory condition if necessary. 
Next, on line 33, you calculate the location of the vtable by finding the end of 
the Extension structure you just allocated and storing the value in modFuncs. On the 
subsequent lines 34-38, you assign each of the vtable's members to a pointer to a 
public function, such as AddRef or Release. A real extension would probably have 
several more functions, all of which would be assigned to the vtable here. Once the 
vtable has been populated, you use the QUALCOMM -provided macro INIT _ VTBL 
on line 41 to finish initializing the vtable and then initialize the data members 
common to all extensions (the reference count, shell pointer, and module pointer, 
on lines 44-46). After that, you increment the reference counts for the incoming 
IShell and IModule interfaces on lines 50-52 in case your caller frees them while 
the extension still needs them. Finally, you return the newly created extension on 
lines 54-56. 
Implementing the Extension's Methods 
Because all extensions must implement the IBase interface, the AddRef and Release 
methods are a good example of how to implement the methods for an extension. 
You've already seen how to create the public interface functions and initialize the 
entries for these methods in the extension's vtable in the preceding sections; 
Listing 11-3 shows the implementation of the extension's Add Ref method. 
Listing 11-3. The Extension's AddRef Method 
1: static uint32 AddRef( IExtensionCls *p) 
2: { 
3: 
Extensionptr pThis = (ExtensionPtr)pj 
4: 
II validate parameter{s) 
5: 
if (!pThis) 
6: 
{ 
7: 
return OJ 
8: 
} 
9: 
return {++{pThis->m_nRefsÂ»j 
10: } 
283 

Chapter 11 
284 
On line 3, you cross-cast the public version of the extension-which consists 
of only the pointer to the vtable and the vtable-to the private version of the 
extension, which has all of its member variables. Next, on lines 5-8, you validate 
the incoming pointer and then on line 9 you return the updated reference count. 
The Release method, shown in Listing 11-4, is a little trickier because it must 
undo all of the allocations performed by the Ini t method you saw in Listing 11-2. 
Listing 11-4. The Extension's Release Method 
1: static uint32 Release(IExtensionCls *p) 
2: { 
3: 
Extensionptr pThis = (ExtensionPtr)p; 
4: 
5: 
II validate parameter(s) 
6: 
if (!pThis) 
7: 
{ 
8: 
return 0; 
9: 
} 
10: 
11: 
II Manage our reference count. 
12: 
pThis->m_nRefs--; 
13: 
14: 
if (pThis->m_nRefs 1= 0) 
15: 
{ 
16: 
return pThis->m_nRefs; 
17: 
} 
18: 
19: 
II Ref count is zero. Release memory. 
20: 
Extension_Free(pThis); 
21: 
22: 
II Release interfaces 
23: 
if (pThis->m_pIShell) 
24: 
{ 
25: 
ISHELL_Release(pThis->m_pIShell); 
26: 
} 
27: 
28: 
if (pThis->m_pIModule) 
29: 
{ 
30: 
IMODULE_Release(pThis->m_pIModule); 
31: 
} 
32: 
33: 
FREE_VTBL(pThis, IModule); 
34: 
35: 
II Free the object itself 

Controlling the Handset 
36: 
FREE( pThis )j 
37: 
38: 
return OJ 
39: } 
The Release method should only free the extension if the reference count 
reaches zero, so lines 12-17 decrement the reference count and return if there are 
still other objects using the extension. Next, on line 20, you call the Extension Jree 
function, which would free any member variables allocated in the extension's 
Extension_Init function. After that, lines 23-31 release the IShell and IModule 
instances, respectively. Line 33 frees the extension's vtable using the QUALCOMM-
provided macro FREE _ VTBL, and line 36 frees the object itself. Finally, on line 38, you 
return the object's reference count-which is now O. 
Summary 
In this chapter, you learned several ways to control the handset, including the 
following: 
â¢ Using the IAddrBook and IAddrRec interfaces to access the OEM address book 
â¢ Using the ILicense interface to manage an application's per-use license 
count 
â¢ Using the handset's !TAPI interface to place voice calls, determine the 
handset's phone number, and receive and send SMS messages 
â¢ Using the IPosDet interface to determine the handset's position 
â¢ Using the IRingerMgr interface to install a new ring tone, enumerate the ring 
tones on the handset, and remove a ring tone 
â¢ Sharing code you write in extensions with other applications or other appli-
cation developers 
285 

CHAPTER 12 
Certifying Your 
Application 
THE MOST IMPORTANT part of your application's development is its distribution: If it 
never makes it to market, you'll never have the opportunity to recoup the devel-
opment costs, let alone revel in the knowledge that others are using your 
application. (Or perhaps it's the other way around .... ) Unlike most other plat-
forms, where once you finish an application it's up to you to test, package, and 
distribute it, the QUALCOMM BREW platform has a stringent validation process 
known as TRUE BREW certification to ensure your application is of the highest 
quality before it reaches the hands of consumers. Once your application receives 
TRUE BREW certification, QUALCOMM works with you to establish a pricing plan 
and make your applications available to carriers. It then distributes royalties for 
application sales to you. 
This chapter shows why you need to validate your application, as well as the 
process by which you obtain certification prior to distributing your application. 
You'll see how to package your application for certification, as well as the most 
common reasons why applications don't pass certification on the first attempt. 
Finally, the chapter closes with a brief discussion on pricing your application and 
working with carriers to distribute your application. 
Validating Your Application 
Testing is a crucial part of the development cycle of any QUALCOMM BREW appli-
cation. Not only does QUALCOMM require a high standard of quality-validated 
by the third-party certification program maintained by National Software Testing 
Labs (NSTL)-but carriers insist upon it. Consumers have high expectations 
regarding the stability and quality of their wireless handsets, and fielding support 
calls from customers is an expensive prospect for wireless carriers. Consequently, 
you must ensure that your application is of the highest quality and then submit it 
to NSTL for third-party testing before making it available to consumers. 
287 

Chapter 12 
288 
Performing Functional Tests 
The TRUE BREW certification process provided by NSTL is to ensure software 
validity, not functionality. As NSTL validates your application, it doesn't directly 
test application functionality, except to ensure that if you claim a feature is 
available then it's actually available. Although NSTL notifies you if it finds an 
obvious functional flaw, it doesn't specifically test for functional defects. Conse-
quently, you're still responsible for providing basic quality assurance for your 
application. 
Thus, an obvious part of your software development cycle should be ensuring 
that your application functions in the manner that it's designed to perform. In 
many ways, this is really the standard software quality testing that you'd perform 
on any application, and it includes several types of testing: 
â¢ Inspection-either via formal code reviews, peer reviews, or team-style pro-
gramming such as eXtreme Programming (xp)-helps catch defects at their 
source before they turn into application defects. 
â¢ Unit testing by developers ensures that each component of the application 
is high quality and doesn't bring defects into the completed application. 
â¢ Integration testing ensures that no defects arise when integrating individual 
components of the application. 
â¢ Executing test suites with your application ensures that regular operations 
perform as expected. Ideally, test suites are designed by individuals 
removed from the development process, and they're executed in com-
pletion several times throughout the application development. 
â¢ Regression testing ensures that once a bug is fixed, it stays fixed. Your orga-
nization should track software failures and their causes and periodically 
retest the application with test cases drawn from the database of defects to 
ensure that no problems re-emerge. 
â¢ Ad-hoc testing by engineers, testers, and other stakeholders helps you 
evaluate your application's stability in real-world scenarios prior to 
deployment. 
â¢ Automated testing through the QUALCOMM BREW Grinder and Shaker 
tools lets you simulate heavy (if random) application use on both the emu-
lator and handset, helping track down difficult-to-find defects pertaining to 
boundary conditions such as missed events, overfilled text input fields, and 
the like. 

Certifying Your Application 
Of course, it's up to you and your organization to determine how best to meet 
the challenge of functional testing. There's a wealth of good literature about 
software testing, and most of it draws the same conclusion: There's no silver bullet 
to creating defect-free code. Instead, you should rely on a bevy of different testing 
methodologies and tests to validate the functionality of your application. 
Performing Validation Tests 
What NSTL does provide, however, is software validation testing-that is, checking 
that your application doesn't violate the integrity of the wireless handset or the 
wireless network. This is a crucial part of application verification, not just to 
meet wireless carrier requirements and uphold consumer expectations but 
because most developers simply don't have the necessary experience at the outset 
to adequately validate their own applications. 
The testing that NSTL performs isn't a secret; in fact, you can see the 
list of tests it performs in Application Developer's TRUE BREW Test Guide: 
Requirements and Test Cases, available at the QUALCOMM BREW extranet 
(http://'IrttW.qualcormn â¢ com/brew/). Broadly speaking, these tests are divided into 
the following categories: 
â¢ AppHcation packaging: The application includes the necessary files and 
documentation to execute correctly. The application has the necessary priv-
ileges and class dependencies set in its Module Information Files (MIFs), 
and only those privileges necessary to run are asserted. 
â¢ AppHcation functionality: The application performs the basic operations 
described in the documentation without disruption or loss of data. 
â¢ AppHcation Hcensing: If the application uses the Ilicense interface, it does 
so in accordance with the documentation for changing its license count. 
Similarly, if the application uses the I License interface to determine whether 
the application is in a demonstration mode, both the licensed and demon-
stration modes operate as described in the documentation. 
â¢ AppHcation storage: The application correctly handles its storage require-
ments, including boundary conditions such as a lack of sufficient dynamic 
or persistent storage. 
â¢ AppHcation stability: The application doesn't reset or interfere with the sta-
bility of the wireless handset. 
289 

Chapter 12 
290 
â¢ User Interface: The application meets the user interface requirements set 
by QUALCOMM. 
â¢ Verification testing: The application can be successfully installed and 
removed via the over-the-air distribution system and by the user. The appli-
cation meets the requirements regarding the number of files in use and 
correctly handles boundary conditions when being installed or removed. 
The best way to ensure that your application passes TRUE BREW certification 
by NSTL on the first pass is to thoroughly read Application Developer's TRUE 
BREW Test Guide: Requirements and Test Cases and add its tests to the suite of tests 
you use to verify your application. In conjunction with defensive programming-
to catch errors on the handset when they occur-and regular peer reviews of your 
code, you'll be on a good footing to pass certification the first time. 
Documenting Your Application 
Although the QUALCOMM BREW platform doesn't provide a mechanism for 
obtaining end user manuals for QUALCOMM BREW applications, most carriers 
require user manuals to help their support staff in fielding questions about your 
application. (Most wireless carriers will handle first -tier support for your appli-
cation, escalating only more difficult questions to your organization for 
clarification or rectification.) 
At a minimum, your user manual should include a summary of your appli-
cation's purpose, a section showing a typical use case walking the reader through 
how to use your application, and sections detailing each of your application's 
major features. You may not need to hire a technical writer to create the documen-
tation because QUALCOMM BREW applications are typically small. Often an 
engineer with help from someone skilled in marketing can do the first pass at the 
user manual. Moreover, screen shots can often clarify awkward prose, so consider 
using an ample number of screen shots to substitute for lengthy procedural 
listings and awkward prose. 
Submitting Your Application for Certification 
Once you're confident your application is ready for certification-you've per-
formed adequate functional testing and exercised the application using the 
validation test suites-it's time to package and submit your application for certifi-
cation. In a sense, this is the point of no return: Once you submit your application 
to NSTL, you can no longer make changes to it. After being certified by NSTL, 

Certifying Your Application 
QUALCOMM works with you to provide the files to wireless carriers. If you need to 
make a change, you must start the certification process again. 
To submit your application for certification, you must package your appli-
cation, sign it using the QUALCOMM BREW AppSigner, and submit it via the Web 
to NSTL. Once NSTL completes certifying the application, it'll contact you with the 
results of the testing, indicating that you've passed, or it'll provide you with a 
description of the tests that the application failed. 
For more information on signing the application and determining the testing 
tier (and the corresponding price) that applies for your application, see the 
QUALCOMM BREW extranet for more information. 
NSTL uses both the handset build and the emulator build of your application 
to perform its testing. Consequently, when submitting your application, you must 
include the application as both a Dynamically Linked Library (DLL) for the 
QUALCOMM BREW Emulator under MicrosoftWmdows as well as the Module 
(MOD) file for the emulator. You must also include your user documentation and 
an application specification, available from the QUALCOMM BREW extranet. 
To package your application, follow these steps: 
1. Create an empty directory. Within this directory, create three directories, 
named WIN, ARM, and DOC. 
2. In the WIN directory, place the release build of your application's DLL, the 
MIE an optional BAR file, and any other required data files. 
3. In the ARM directory, place the release build of your application's MOD 
file, the MIE an optional BAR file, and any other required data. 
4. In the DOC directory, place the application specification, along with any 
other required documentation, such as the user guide required by many 
carriers. You should name the application specification 
appname_spec.doc, where appname is the name of your application. 
Similarly, name the user manual appname_mnl.doc. For other naming 
conventions, see the QUALCOMM BREW extranet. 
5. Launch the QUALCOMM BREW AppSigner application. 
6. From the main window, click Select Application. The Browse for Folder 
window appears. 
7. Select the folder containing the MOD file you want to sign. You'll be 
prompted with a list of files in that directory. 
291 

Chapter 12 
292 
8. Choose the BAR, MOD, and MIF files in the ARM directory by checking the 
box in the Include in Signing column of the list. 
9. For each file in the list, if it's changed after the application is installed on 
the device, check the box in the Gets Modified column of the list. Note 
that files that change after installation on the handset are automatically 
signed as well. 
10. Click the Add Signature button. 
11. Enter your developer name in the dialog box that appears. 
12. The VeriSign Personal Trust Agent dialog box appears. Enter your 
username and password for your VeriSign profile, and click Next. The 
VeriSign notarization server will process your request over the Internet, 
which may take a few moments. 
13. The QUALCOMM BREW AppSigner application compresses your appli-
cation directory. 
14. Go to https:/ Iwww.nstl.com/nstl/index . htm and fill out the form to submit 
your application for certification. 
TIP Be sure to check the latest documentation on the QUALCOMM 
BREW extranet when signing your application to be sure that none of 
these steps have changed since the book's publication. 
Failing Certification: The Top Five Ways to Fail 
It's easy to pass certification-if you follow the instructions carefully and perform 
adequate testing of your application before you submit your application for certi-
fication. Unfortunately, because it's easy to miss a step, the following are some of 
the common mistakes developers make. 
Mispackaging Your Files 
The initial steps in NSTL certification are automated, and if you don't follow the 
steps in preparing your submission package, fail to sign your application, omit a 

Certifying Your Application 
file, or include debug instead of release versions of your application, your appli-
cation will fail certification almost immediately. 
A related problem that often occurs, especially to first-time developers, is to 
forget to place a human-readable version number somewhere in your application, 
such as on the splash screen or from an About screen available from the main 
menu or a configuration menu. 
Including Undocumented Functions or Documented 
Functions That Don't Work 
Applications with undocumented Easter eggs-functionality that's hidden from 
the user and not documented-or functionality described in the user documen-
tation that doesn't exist will guarantee failure. 
One of NSTI:s primary responsibilities is to help protect carriers from 
deploying applications that could potentially cause problems with their network. 
Obviously, one way to deploy a malicious application is to make a Trojan horse-
an application that pretends to be useful but in fact does something quite the con-
trary. To eliminate this possibility, NSTL and carriers have a firm policy that all 
features must be documented. 
In a similar vein, carriers want to ensure that your application does what you 
claim it'll do. Although NSTL doesn't do functional testing per se, it will fail an 
application that claims to perform a function that isn't actually implemented. 
Failing to Handle Suspend and Resume Operations 
QUALCOMM BREW-enabled handsets aren't just a computing platform; they're a 
wireless communications tool. Voice and data communications are the platform's 
top priority, and your application must gracefully yield to their needs. The 
suspend and resume feature of the QUALCOMM BREW platform is one way that 
the platform ensures that the telephony and data features are available anytime 
they're needed. 
If your application can't successfully handle the EVT _ APP _SUSPEND and 
EVT _ APP _RESUME events or crashes the handset when these events occur, your appli-
cation will fail certification. 
Incorrectly Using the Clear Key 
By convention, the Clear key provides the user with a way to back up to the pre-
vious step in an application-in any application. This is the firmest user interface 
293 

Chapter 12 
294 
guideline mandated by QUALCOMM, and it's rigorously enforced by 
QUALCOMM, NSTL, and the carriers. Be sure your application uses the Clear key 
for this single purpose, and you're more likely to pass on your first submission. 
Failing to Handle File System Errors 
If your application uses files on the file system, be sure your application handles 
cases where either the file system is full or the maximum number of files on the file 
system has been exceeded. NSTL provides a test application (available at the 
QUALCOMM BREW extranet) to help you ensure your application correctly meets 
these boundary conditions. 
Pricing and Promoting Your Application 
Once your application receives TRUE BREW certification, you can supply a pricing 
plan via the QUALCOMM BREW extranet. This pricing plan should take into 
account not just your business model but the following as well: 
â¢ The relative prices and availability (subscription, one-time fee, or limited 
number of uses) of competing applications 
â¢ The price range of other similarly featured applications available 
â¢ The pricing guidelines set by the carriers that will distribute your 
application 
Most carriers-and vendors-obviously prefer a subscription model because 
it meshes well with consumers' expectations as a line item for a service on their 
cellular phone bill and provides your company with recurring revenue. 
Once you set a pricing plan for your application, QUALCOMM makes your 
application available to individual carriers. Most carriers have an additional certi-
fication program, but the carrier certification program is generally far easier to 
pass than the TRUE BREW certification program. 
Although QUALCOMM makes your application available to carriers, it 
behooves you to make contacts with the marketing and product managers respon-
sible for QUALCOMM BREW applications at the wireless carrier companies that 
will distribute your application. Most are happy to help promote your application 
because they share in the revenue your application generates on their network. 

Certifying Your Application 
Summary 
In this chapter, you learned the following: 
â¢ The importance of functionally verifying your application because although 
TRUE BREW certification ensures that an application correctly interop-
erates with the wireless handset and wireless network, it doesn't test the 
functionality of your application per se 
â¢ How to package your application for submission to NSTL for TRUE BREW 
certification prior to delivery to QUALCOMM for distribution 
â¢ How to avoid the most common failures when submitting your application 
for certification 
295 

Index 
Numbers and Symbols 
... (ellipses) button 
in emulator Setting dialog box, 54 
A 
actors 
using UML to diagram their uses for 
your application, 24-25 
AddRef method 
implementing for extensions, 283-284 
address book 
accessing the built-in, 267-277 
organization of, 268 
privileges for manipulating the 
liandset's built-in, 49 
ad-hoc testing 
for your QUALCOMM BREW 
applications, 288 
AEDB_Ff_DWORD 
bug in handset implementations prior 
to BREW 2.0, 181 
AEDBFieldType definitions 
table of, 179 
AEEAddrField structure 
code for, 268 
AEEAppGen.c 
AEEAppleCNew helper function in, 14 
file supplied by QUALCOMM, 64-65 
AEEApplet type 
starting your application structure with, 
39 
AEEAppleCNew helper function 
inAEEAppGen.c file, 14,64-65 
initializing contents of AEEApplet 
application structure with, 39 
invoking in SlideShow application, 
83-84 
AEECallbackstructure 
code example for, 258 
AEEClsCreateInstance constructor 
in Hello.c applet, 11-14 
AEEClsCreateInstance function 
code example, 40-42 
function of, 34-35 
as module entry point, 278 
AEEDB_FT_BINARY 
fundamental data type, 179 
AEEDB_Ff_BITMAP 
fundamental data type, 179 
AEEDB_FT_BYI'E 
fundamental data type, 179 
AEEDB_Ff_DWORD 
fundamental data type, 179 
AEEDB_Ff_STRING 
fundamental data type, 179 
AEEDB_FT_WORD 
fundamental data type, 179 
AEEDBField structure 
code macros to initialize the contents 
of, 189 
AEEDBField type 
defining an array of database fields of, 
179 
AEEDisp.h file 
AEERasterOP enumeration in, 204 
AEEDNSResult structure 
using, 258 
AEEGPSInfostructure 
fields you can examine in your callback 
function, 274-275 
AEENotify structure 
included in an EVCNOTIFY event, 273 
AEEPoint structures 
using instead of raw integer 
coordinates, 219 
AEERasterOp enumeration 
bit blit options defined in, 204 
AEESoundCmdData structure 
code example for, 240 
AEETAPl.h file 
contents of, 273 
AEETileMap structure 
for initializing tiles, 225 
Apache Web server 
using to transfer data across the 
Internet, 254 
Applet Type menu 
in MIF Editor, 47 
applets (QUALCOMM BREW applications), 
6 
launching, 2 
297 

Index 
298 
restrictions on filenames and directory 
structures, 16 
running in the QUALCOMM Emulator, 
16-17 
transferring to your handset, 19-20 
Appletstab 
QUALCOMM BREWMIF Editor, 47 
application controls 
code for releasing, 114 
application deSCription document 
creating for your application, 29-30 
information it should contain, 30 
preparing for rour RocketMileage 
application, 28-30 
application events 
handling, 85-86 
application flow 
representing with application states, 
68-70 
understanding, 33-42 
application framework 
building, 68-80 
function naming convention, 71 
handling events in, 147-150 
initializing, 152-153 
integrating controls with, 136-151 
requirements for providing a good 
basis for managing controls, 
142-143 
using when creating the SlideShow 
application, 81-82 
application functionality 
testing for, 289 
application interface flow 
representing with a stack of states, 69 
application licensing 
managing, 269-270 
testing for, 289 
Application Loader 
downloading from the QUALCOMM 
BREWemanet, 18 
using, 56-59 
application menu 
QUALCOMM BREW platform, 2 
application notification 
choosing QUALCOMM BREW-directed 
SMS for, 255-256 
application packaging 
testing for, 289 
application preferences 
accessing,187-188 
application splash screen 
showing for the SlideShow application, 
86-91 
application stability 
testing for, 289 
application states 
representing application flow with, 
68-70 
application state stack 
example of, 69 
application state structure 
for CState structure, 70 
application storage 
testing for, 289 
application structure 
code for the SlideShow application, 
82-83 
defining first members of, 73 
importance of defining in QUALCOMM 
BREW applications, 39 
applications 
adding sound interfaces to, 245-246 
capturing the user interface, 24-25 
certifying, 287-294 
creating an icon for, 10 
creating builds for handset testing, 55 
creating your first QUALCOMM BREw, 
8-20 
debugging with the QUALCOMM 
BREW Emulator, 52-55 
designing one that uses sprites, 209 
developing with the QUALCOMM 
BREW platform, 3-6 
documenting for carriers, 290 
initializing the variables, 152-153 
installing on a developer handset, 
56-59 
performing functional test on, 288-289 
pricing and promoting, 294 
privileges you can give them, 48-49 
sharing code between, 277-285 
simulating telephone events for testing, 
55 
steps for installing on a developer 
handset, 57-58 
steps for packaging for certification, 
291-292 
submitting for certification, 290-292 
top five ways to fail certification, 
292-294 
validating, 287-290 
Apress Web site address, 11 
for downloading code for book, 80 

arithmetic distance 
calculating between the cat and mouse, 
249-250 
ARM make file 
creating, 19 
ARM QUALCOMM BREW Builder 
for creatin~ handset builds for testing 
applications, 55 
ARPU. See Average Revenue Per User 
(ARPU) 
AS_DBFieldFromDatabase function 
using, 190-191 
AS_DBFieldToDatabase function 
using, 190-191 
AS_Init function 
for callin~ the initTiles function to 
initialize the tile map, 226-227 
function of, 211 
AS_MainHandleEvent 
using, 164 
AS_MenuEntry function 
invoking in SlideShowapplication, 
91-92 
AS_ShowBitmapHandleEvent 
using, 164 
AS_SlideEntry 
calling to allocate space for the 
CSlideShowstructure,100-102 
AS_SlideExit 
code example for, 104-105 
ASSERT macro 
function of, 75 
ATOI helper function 
for QUALCOMM BREW; 45 
audio 
using to interact with the user, 109-110 
Average Revenue Per User (ARPU), 3-4 
AVK_CLR 
handling of on different handsets, 129 
B 
background and sprites 
drawing, 231-232 
background music 
playing during game play, 246-249 
BAR file. See BREW Archive file (BAR file) 
bar file (BREW Application Resource file) 
creation of, 8 
placing in SlideShow's main directory, 
81 
bCallEnded flag 
function of, 271 
bDataflag 
function of, 271 
bDigital flag 
function of, 271 
BDSMS. See BREW-directed SMS messages 
bE911CallbackMode flag 
function of, 271 
BEEP_ALERT 
for alerting the user, 240 
BEEP_ERROR 
for indicating an error condition, 240 
BEEP_MSG 
for indicating the arrival of a SMS, 240 
BEEP_OFF 
terminating a playing beep with, 240 
BEEP_REMINDER 
beep to remind the user, 240 
BEEP_V1BRATE~RT 
silent alert to notify the user, 240 
BEEP _ V1BRATE_REMIND 
silent alert to remind the user, 240 
BID file. See BREW ID (BID) file 
binary-ORing 
of pixels from the source to the 
destination, 204 
binary-XORing 
of pixels from the source to the 
destination, 204 
bitmap graphics 
function of, 203 
bitmap images 
creating for your application screens, 
29-30 
bitmaps 
interface for blit copying to screens, 
204-207 
Bluetooth 
choosing for personal area networking, 
256-257 
implementing connectivity to audio 
devices and other computing 
devices with, 253 
standard defined, 256-257 
.bmpsuffix 
for bitmap files, 164 
BREW Application Loader. See Application 
Loaoer 
BREW Archive file (BAR file), 51-52 
BREW Device Configuration Editor. See 
Device Configuration Editor 
BREWID (BID) file 
using when creating your application, 7 
Index 
299 

Index 
300 
BREW Independent Solutions Vendor (lSV) 
development form 
on the Become an Authenticated 
Developer page, 9 
BREW Logger 
option settings in, 59 
sample output from, 60 
using, 59-61 
BREW MIF Editor 
building MIFs with, 7-8 
BREW Mobile Shop 
exploring applications available 
through,17 
tracking of your application sales by, 8 
BREW Resource Editor 
adding items to your applications with, 
7-8 
BREW Resource Information file (BRI fileÂ», 
51-52 
BREWWlZard 
launching, 10 
BREW-directed SMS (BDSMS) messages 
choosing for application notification, 
255-256 
example of, 264 
understanding, 264-265 
BRI file. See BREW Resource Information 
file (BRI file) 
bRoaming flag 
function of, 271 
BTSIOPORT interface 
using to establish a connection to a 
remote Bluetooth serial port, 256 
Build -> Build menu item 
shortcut key for, 15 
Build -> Set Active Configuration 
Debug or Release version, 15 
c 
C standard library 
equivalents for QUALCOMM BREW 
helper functions, 45 
callback function 
for the ISound interface, 241-242 
CALLBACK_Init macro 
code for, 258 
cat and mouse game. See Neko to 
Nonezumi game 
categories 
getting and changing, 268 
CDMA (Code Division Multiple Access) 
format used to carry voice content of 
telephone calls, 238-239 
cell phones 
features in common with QUALCOMM 
BREW-enabled handsets, 1-3 
certification 
submitting your application for, 
290-292 
top five ways to fail, 292-294 
class identifier (class 10) 
entering into the MIF Editor, 47 
in QUALCOMM BREW platform, 7 
Clear key 
function of, 68 
using in QUALCOMM BREW 
applications, 108-109 
Clear key press 
handling within the state framework, 
79-80 
clock control 
interface name, class ID, and function 
of,134 
code 
making it easier to read by casting to a 
pointer, 42 
code example 
for accessing database records by ID, 
178 
for adding items to a menu, 125 
for adorning an ITextCtl control with a 
soft key menu, 130-132 
for AEECallback structure, 258 
of the AEEClsCreateInstance function, 
40-42 
of AEENotify structure, 273 
for AEESoundCmdData structure, 240 
for allocating common controls in the 
control pool, 145-147 
for allocating the ISoundPlayer and 
ISound instances, 245-246 
of the application state structure 
CState,70 
of the AS_DBFieldFromDatabase 
function, 194 
of the AS_DB Field To Database function, 
191-192 
for AS_SlideExit, 104-105 
for blitting images to the handset 
display, 205-206 
of the callback function for the ISound 
interface, 241-242 
for CALLBACK_Init macro, 258 

of casting code for pData, 273 
for connecting an ISocket instance to a 
remote nost, 259 
for controlling mouse movements, 
249-250 
for creating an extension and its vtable, 
281-283 
for creating shapes in GrapbicsSample 
application, 213 
for creating the IStatic control, 112 
for CSlideShow structure, 98 
for DBFreezeRecord function, 190-191 
for defining a state, 137 
for defining CStateApp structure, 73 
for defining first members of 
application structure, 73 
for deleting a database, 177 
demonstating the use of controls, 112 
for dispatching events to controls, 
148-150 
for drawing tiles and sprites, 231-232 
for entering bitmap state, 165-166 
for entering main state, 155-157 
for entering slide show state, 101 
for exiting main state, 157-158 
for exiting menu state, 97 
for extending the list of controls, 152 
for the extension's AddRef method, 
283-285 
for the extension's Release method, 
284-285 
for fetching a field from a record, 
195-196 
of filled TAPIStatus structure, 271 
for filling the tile map, 226-227 
of framework extensions to support 
controls, 143-144 
for freeing allocated resources, 153 
for freeing resources used by the 
SlideShowapplication, 87 
of the genesis of a module, 278 
for getting a stream from a filename, 
167-168 
for getting the number of records in a 
database, 178 
of the GraphicsSample application 
data, 211 
for handling menu state events, 95-96 
for handling slide show state events, 
102-104 
for handling events within the state 
framework, 78-80 
for handling events with ITextCtl, 
128-130 
for handling key events for scrolling, 
217-218 
for handling menu selections, 124-125 
for hiding the copyright screen, 90 
for IMEMASTREAM_Set interface call 
162 
' 
for initializing, clearing the display, 
setting bounds, and addiiig menu 
items, 122 
for initializing application variables, 
152-153 
for initializing the GraphicsSample 
application, 212 
for initializing the SlideShow 
application, 83-84 
for initializing sprites, 223-225 
for initializing tiles, 225 
for invoking 
INETMGR_GetHostByName 
method, 258 
of the ISound and ISoundPlayer 
interfaces added to the 
application structure, 245 
for ISOUND_PlayTone method, 241 
for iterating over all of the fields in a 
database record, 182-183 
for iterating over all records in a 
database, 178 
of the linked list nodes and an insertion 
sort, 196-197 
for loading sprite and tile maps, 
220-223 
for loading sprite bitmaps, 228-229 
for loading tile bitmaps, 230-231 
of macros to initialize the contents of 
an AEEDBField structure, 189 
for mainDraw function, 214-216 
for managing the list of states, 138-140 
for manipulating the state stack, 75-76 
for moving sprites while handling key 
events, 233-235 
for obtaining a list of files in a directory, 
93-95 
for opening a database, 176-177 
for passing events to the active event 
handler control, 113-114 
for presenting the menu of slide shows 
91-92 
' 
for providing a status callback, 262 
for releasing an application's controls, 
114 
for restarting the music playback, 248 
for restoring a serialized record to 
memory, 192-194 
Index 
301 

Index 
302 
code example, continued 
of the RocketMileage database schema, 
187 
of the RocketMileage data structure, 
31-32 
of a sample event handler, 37-38 
for serializing a memory structure, 
180-181 
for sharing events with an IMenuCtl 
soft key menu and an ITextCtl, 
132-133 
for ShowCopyright function, 88 
showing extension member variables, 
280 
showing fields in the WebRespInfo 
structure, 264 
showing how an extension interface 
looks, 279 
showing members of AEESMSTextMsg, 
273 
for showing the amount of heap 
consumed by an application, 
166-167 
showing use of ITextCtl control, 
127-128 
of a simple AEEClsCreateInstance 
fuiJ.ction, 34-35 
for SlideShow application initialization, 
121 
for the SlideShow application main 
event handler, 85-86 
for the SlideShow application structure, 
82-83 
of sprite and tile structures, 223 
for starting a Web transaction, 263 
for starting MIDI music playback, 
246-247 
for starting up and tearing down the 
main state, 154 
for the state management interfaces, 
71-72 
for the State_Push function, 73-75 
for stopping background music 
playback, 248-249 
for supplying a pointer to a callback 
function, 262 
for suspending the current state, 77 
for the HelloWorld applet, 11-13 
for updating screen sprites, 232-233 
for using ISHELL_GetPrefs method, 188 
for using IStatic control in your 
application, 115-116 
control bounds 
using ISTATIC_SetRect API to set, 116 
controls. See also QUALCOMM BREW 
controls 
code for allocating common in the 
control pool, 145-147 
code for dispatching events to, 148-150 
code for extending the list of, 152 
code for framework extensions to 
support, 143-144 
initi~ng,142-147 
integrating with your application 
framework, 136-151 
coordinates vs. points 
using, 219 
countdown time control 
interface name, class ID, and function 
of, 134 
CSlideShow structure 
central to the slide state, 98 
CState application state structure 
code example for, 70 
CState structure 
simplifying, 137-142 
CStateApp structure 
code for defining, 73 
pool of controls stored in m_apControl 
array of, 143-144 
CStateFrameworkPtr 
type definition pointing to top of state 
stack, 73 
CtlAddItem structure 
code for adding items to a menu, 125 
D 
data 
chOOSing to store in a database, 
173-175 
networking yours, 253-265 
storing, 173-201 
data type 
for database record fields, 173-174 
database 
choosing for storing data, 173-175 
interfacing with, 175-184 
naming, 174 
seri~ng records for, 188-196 
storing data in, 173-201 
understanding requirements for, 175 
using in a real application, 186-200 
database entries 
sorting, 185-186 

database fields 
defining an array of, 179 
database implementation 
understanding on QUALCOMM BREw, 
173-174 
database interface 
overcomingissues~th,184-186 
sorting database records, 185-186 
database records 
accessing by ID, 177-178 
code for decoding a serialized, 183-184 
code for fetching a specific field from, 
195-196 
code for iterating over all the fields in, 
182-183 
creating, 179-181 
sorting, 185-186 
sorting for display, 196-200 
database requirements 
understanding, 175 
datagrams 
handling any required by your network 
protocol, 260 
date entry control 
interface name, class ID, and function 
of, 134 
day of month entry control 
interface name, class ID, and function 
of, 134 
DBFreezeRecord function 
code for, 190-191 
DBGPRINT_HeapUsed macro 
getting the amount of heap currently in 
use ~th, 166-167 
DBGPRlNTF helper function 
for QUALCOMM BREW, 45 
DBThawRecord function 
code for restoring a serialized record to 
memory in, 192-194 
_DEBUG flag 
assuring that it is not set, 75 
debugging code 
using debug and release setting to 
include, 15 
Dependencies tab 
in QUALCOMM BREW MIF Editor, 
49-50 
design 
as a crucial part of software 
development, 21-23 
minimum information to be captured, 
23 
design decisions 
capturing before starting to write 
applications, 22-23 
understanding the importance of, 
21-22 
developer testing support 
send handset to QUALCOMM for 
enabling, 18 
developers tools 
using the QUALCOMM BREw; 46-61 
Device Configuration Editor, 54 
using, 55-56 
display. See handset display 
documentation 
importance of for your applications, 
290 
double-buffering technique 
using to prevent flickering, 206 
Down keystroke 
function of in a text control, 151 
DrawCentered routine 
function of, 170 
drawing graphics 
using IDisplay interface, 207-208 
using the IGraphics interface, 207-208 
dwParam argument 
function of, 64 
Dynamically Linked libraries (Oils) 
using Microsoft Visual Studio to build, 
7 
E 
E911 initiative 
function of, 274 
ecode argument, 64 
Electronic Serial Number (ESN) 
for your QUALCOMM BREW-enabled 
handset, 18 
ellipses ( ... ) button 
in emulator Settings dialog box, 54 
ESN. See Electronic Serial Number (ESN) 
event driven applications, 33-42 
event handler 
code example of a sample, 37-38 
events received for the system event 
pump, 34 
as a massive s~tch statement, 64-65 
prototype it must match, 64 
registering for receiving events from 
the system, 34-35 
Index 
303 

Index 
304 
event model 
understanding, 63-68 
event pump 
messages sent to event handler from, 
34 
events 
code for dispatching to controls, 
148-150 
code for handling in the slide show 
state, 102-104 
code for passing to the currently active 
control, 113 
handling, 63-106 
handling for the menu state, 95-96 
processing, 64-65 
EVT_ALARM event 
managing, 65 
meaning of, 37 
EVT_APP _BROWSE_FILE event 
meaning of, 36 
EVT_APP _BROWSE_URL event 
meaning of, 36 
EVT_APP _CONFIG event 
managing, 65 
meaning of, 36 
EVT_APP _HIDDEN_CONFIG event 
meaning of, 36 
EVT_APP _MESSAGE event 
managing, 65 
meaning of, 36 
EVTflP _RESUME event 
event handler response to, 36 
extending the state machine's event 
handler to handle, 138-142 
handling within the state framework, 
78-80 
EVCAPP _START event 
event handler response to, 35 
handled by HelloWorld_HandleEvent, 
14 
handling, 65 
EVT_APP _STOP event 
event handler response to, 35 
extending the state machine's event 
handler to handle, 138-142 
handled by HelloWorld_HandleEvent, 
14 
handling, 65 
sending to terminate an application, 
79-80 
EVT_APP _SUSPEND event 
event handler response to, 35 
extending the state machine's event 
handler to handle, 138-142 
handling within the state framework, 
78-80 
EVT_COMMAND event 
function of, 67-68 
meaning of, 37 
signaling menu selections with, 
124-125 
EVT_CTL_TAB event 
meaning of, 37 
EVT_KEY event 
function of, 66 
meaning of, 37 
using for positioning the view port, 
217-218 
EVT_KEY_HELD event 
function of, 66 
meaning of, 37 
using for positioning the view port, 
217-218 
EVT_KEY_PRESSevent 
function of, 66 
meaning of, 37 
using for positioning the view port, 
217-218 
EVT_KEY_RELEASE event 
function of. 66 
meaning of. 37 
EVCNOTIFY event 
AEENotify structure included in. 273 
managing, 65 
meaning of, 37 
EVT_RESUME event 
handling, 65 
EVT_SUSPEND event 
handling, 65 
EVT-APP _START event 
extending the state machine's event 
handler to handle, 138-142 
exiting 
the menu state, 97 
exiting events 
extending the state machine's event 
handler to handle, 138-142 
express networks 
supported by newer QUALCOMM 
BREW-enabled handsets. 2 
extension interface 
defining, 279-281 
macro for dereferencing extensions 
vtable, 280 

extensions 
code for creating them and their vtable, 
281-283 
creating to share code between 
applications, 277-285 
implementing the methods for, 
283-285 
initializing, 281-283 
Extensions tab 
in QUALCOMM BREW MIF Editor, 
49-50 
F 
F7key 
for Build -> Build menu item, 15 
fields 
adding to or removing from address 
book, 269 
in database records, 173-174 
obtaining number of and iterating 
across in a record, 268 
file privileges 
you can give your applications, 48 
filename 
code for getting a stream from, 167-168 
filenames and directory structures 
restrictions on, 16 
files 
code for obtaining a list of in a 
directory, 93-95 
FillMenu function 
calling to populate the SlideShow 
menu, 92 
code for building the menu, 122-124 
flash memory 
drawbacks of, 185 
Fld_DueTime field 
finding the value of, 195-196 
tNamefield 
function of, 179 
foreground color 
using IGRAPHlCS_SetColor for setting, 
208 
framework extensions 
code example to support controls, 
143-144 
FREE helper function 
for QUALCOMM BREW, 45 
fI'ype field 
function of, 179 
functions 
vs. macros, 169 
function-scope variables 
G 
unsupported in QUALCOMM BREW 
platform, 39 
game events 
playing sounds for, 249-250 
game play 
playing background music during, 
246-249 
GCC. See GNU C Compiler (GCC) 
GenerateARMMakeFile 
using, 19 
GET_PVTBL macro 
obtaining address of a function in an 
extention vtable with, 280 
GetAppData macro 
getting the application globals from the 
state machine structure with, 166 
GETRAND helper function 
using to fill arRandom with random 
bytes, 213 
GetStreamFromFile function 
using, 167 
GETTIMEMS function 
using, 233-234 
GetUnzipStreamFromStream 
using, 168-169 
global positioning applications 
supported by newer QUALCOMM 
BREW-enabled handsets, 2 
global variables 
unsupported in QUALCOMM BREW 
platform, 38-39 
GNU C Compiler (GCC) 
QUALCOMM support for, 19 
gpsOne 
for determining the handset's position, 
274-275 
graphics 
drawing, 203-235 
graphics APls 
and BREW version available in, 204 
understanding capabilities of, 203-210 
graphics primitives 
function of, 203 
understanding, 207-208 
Index 
305 

Index 
306 
GraphicsSample application 
function of, 210-211 
GraphicsSample application data 
code example, 211 
Grinder and Shaker tools 
for automated testing of your 
applications, 288 
.gzsuffix 
for U77 -compressed bitmap files, 164 
gzip utility 
using to generate compressed data, 163 
H 
HandleEvent function 
calling, 64 
handset display 
blitting images to, 205-206 
using to interact with the user, 107-109 
handset keyboard 
using to interact with the user, 107-109 
handsets. See also wireless handsets 
controlling, 267-285 
Hello.c applet 
functions in, 11-14 
HelloWorld applet 
code for, 11-13 
testing, 15-17 
HelloWorld program 
steps for creating in Microsoft 
Developer Studio 6.0,10-11 
HelloWorld_HandleEvent event handler 
in Hello.c applet, 11-14 
helper functions 
provided by QUALCOMM BREw, 44-45 
HideCopyrightfunction 
code for hiding the copyright screen, 90 
H1ML display control 
interface name, class ID, and function 
of, 135 
HTONSmacro 
for converting a port address to 
networK byte order, 259 
HITP networking 
implementing, 253, 254-255 
Hypertext Transfer Protocol (HTTP) 
permitting your application to access 
the Web via, 49 
resource for an in-depth overview of 
262 
' 
I 
IAddrBook instance 
creating, 268 
IAddrBook interface 
function of, 268 
for manipulating the handset's built-in 
address book, 49 
IADDRBOOK_EnumCategoryInit 
for iterating across address book 
categories, 268 
IADDRBOOK_EnumNextCategory 
for iterating across address book 
categories, 268 
IADDRBOOK_EnumNextRec 
for iterating across address book 
records, 268 
IADDRBOOK_EnumRecInit 
for iterating across address book 
records, 268 
D\ddrRecinterface 
methods for manipulating specific 
records, 268 
D\DDRREC_AddField 
calling to add a field, 269 
IADDRREC_GetCategory 
obtaing a category with, 268 
IADDRREC_GetFieldCount 
obtaining number of fields in a record 
with, 268 
IADDRREC_RemoveAllRec method 
removing all address book records with 
269 
' 
IADDRREC_RemoveField 
removing fields with, 269 
IADDRREC_RemoveRec method 
using to remove a record, 269 
IADDRREC_SetCategory 
changing a category with, 268 
IADDRREC_SetField 
using to iterate across fields, 268 
!Applet class 
BREW applet as subclass of, 6-7 
D\Stream interface 
inheritance relationship between it and 
its child classes, 160 
and the interfaces that implement it, 
159 
understanding the implementations of 
160-163 
' 
IBase interface 
methods defined by, 42 

IBASE_AddRef method 
defined by IBase interface, 42 
IBASE_Release method 
defined by IBase interface, 42 
IBitmap interface 
available in BREW version 2.0, 204 
IBITMAP _BltIn method 
using, 229 
IBITMAP _CreatCompatibleBitmap method 
using, 230-231 
IBITMAP _FillRect 
using, 230-231 
IBITMAP _Release( plBitmap ) 
using, 222 
IBTAG interface 
for interfacing with Bluetooth audio 
devices, 256 
IBTSDP interface 
using to perform device discovery, 256 
icon menu control 
interface name, class ID, and function 
of, 135 
icon view menu control, llB-1l9 
IControl interface 
methods provided by, III 
user interface controls inherited from, 
110-111 
ICONTROL_GetProperties method 
for determining properties for a 
control, III 
ICONTROL_GetRect method 
for getting the display rectangle for a 
specified control, III 
ICONTROL_HandleEvent method 
for sending an event to the control, III 
ICONTROL_lsActive method 
for determining if the specified control 
is active, III 
ICONTROL_Redraw method 
for forcing a control to redraw itself on 
the oisplay, III 
ICONTROL_Reset method 
for freeing resources and clearing the 
active flag, III 
ICONTROL_SetActive method 
for giving focus to a control, III 
ICONTROL_SetProperties method 
for setting a control's properties, III 
ICONTROL_SetRect method 
for setting the display rectangle for a 
specified control, III 
IDatabase instance 
using to access database records, 174 
IDatabase interface 
using, 177-181 
IDATABASE_CreateRecord function 
using, 179 
IDATABASE_GetNextRecord function 
for iterating over all records in a 
dataoase, 178 
IDATABASE_GetRecordCount function 
using, 178 
IDATABASE_Release function 
using before closing a database, 178 
IDATABASE_Reset function 
using, 178 
IDBMgr interface 
managing databases with, 176-177 
using to create or open a database, 174 
IDBMGR_AddRef method, 176-177 
IDBMGR_OpenDatabase method 
opening a database with, 176-177 
IDBMGR_OpenDatabaseEX method 
opening a database with, 176-177 
IDBMGR_Release method 
uSing, 176-177 
IDBMGR_Remove function 
deleting files from a database with, 
176-177 
IDBRecord interface 
using, 182-184 
using to access fields within a record, 
174 
IDBRECORD_GetID method 
obtaining the record number of a 
specific record with, 182 
IDBRECORD_Remove method 
removing a specific record with, 182 
IDBRECORD_Update method 
updating a record's fields with, 182 
IDF _ALIGN_CENTER flag 
using, 15 
IDF _ALIGN_MIDDLE flag 
using, 15 
IDIB interface 
available in BREW version 2.0, 204 
IDisplay interface 
available in BREW versions 1.0, 1.1,2.0, 
204 
for creating graphics primatives, 
207-208 
Index 
307 

Index 
308 
IDISPlAY_BitBlit function 
function of, 206 
IDISPLAY_ClearScreen method 
used by the EVT_APP _START event, 
14-15 
IDISPLAY_GetDestination method 
function of, 206 
IDISPlAY_GetDeviceBitmap function 
using, 230 
IDISPLAY_GetDeviceBitmap method 
function of, 206 
IDISPLAY_SetDestination method 
function of, 206 
IDNS interface 
implementing TCP lIP networking via, 
253-254 
.idx filename extension 
for database index files, 174 
IFile interface, 159 
understanding, 160 
using to read from and write to the 
local file system, 48 
for writing to the handset's ringer 
directory, 49 
for writing to the handset's shared 
directories, 49 
IFileMgr interface 
using, 161 
using to read from and write to the 
local file system, 48 
for writing to the handset's ringer 
directory, 49 
for writing to the handset's shared 
directories, 49 
IFlLEMGR_Enumlnit 
arguments taken by, 94 
IFont interface 
available in BREW version 2.0, 204 
IGraphics canvas 
drawing on, 214-216 
IGraphics instance. See IGraphics interface 
IGraphics interface 
available in BREW versions 1.0, 1.1,2.0, 
204 
for creating graphics primatives, 
207-208 
initializing, 211-214 
steps for using, 207-208 
using, 210-219 
IGRAPHICS_DrawArc function 
drawing graphics with, 208 
IGRAPHlCS_DrawLine function 
drawing graphics with, 208 
IGRAPHICS_DrawPie function 
drawing graphics with, 208 
IGRAPHICS_DrawPoint function 
drawing graphics with, 208 
IGRAPHICS_DrawPolygon function 
drawing graphics with, 208 
IGRAPHICS_DrawPolyline function 
drawing graphics with, 208 
IGRAPHICS_DrawRect function 
drawing graphics with, 208 
IGRAPHICS_DrawText function 
drawing graphics with, 208 
IGRAPHICS_SetBackground 
setting the background color with, 207 
IGRAPHICS_SetClip method 
using, 216 
IGRAPHICS_SetColor 
setting foreground color with, 208 
IGRAPHICS_SetFillColor 
setting the fill color with, 208 
IGRAPHICS_SetFillMode 
setting fill mode with, 208 
IGRAPHICS_SetPaintMode 
setting the paint mode with, 208 
IGRAPHlCS_SetViewport 
setting the view port with, 207 
IGRAPHICS_Update 
calling to update the display, 208 
lIS (Internet Information Server). See 
Microsoft Internet Information 
Server (lIS) 
IUcense interface 
adjusting an application's license 
count With, 269-270 
IUCENSE_DecrementUsesRemaining 
method 
for deducting the number of times 
application can be used, 270 
IUCENSE_GetInfo method 
for determining ty{>e of license 
purchase<l With an application, 
270 
IIlCENSE_GetPurchaseInfo method 
for gettin~ the kind of license and when 
it will expire, 270 

IUCENSE_IncrementUsesRemaining 
method 
increasing the number of times 
application can be used, 270 
IUCENSE_SetUsesRemaining method 
for setting number of uses to a specific 
value, 270 
image viewer control 
interface name, class ID, and function 
of, 135 
IMedia interface 
configuring, 244 
QUALCOMM BREW MediaPlayer 
sample as introduction to, 244 
for unifying multimedia management, 
243-244 
IMEDIA-FastForward method 
for advancing the playback by a 
number of niilhseconds, 244 
!MEDIA_Pause method 
pausing media playback with, 244 
IMEDIA_Play method 
starting media playback with, 244 
IMEDIA_RegisterNotify function 
setting a status callback with, 244 
lMEDIA_Resume method 
resuming media playback with, 244 
lMEDIA_Rewind method 
rewinding the playback by a number of 
milliseconds, 244 
lMEDIA_SetMediaData method 
setting IMedia interface's media with, 
244 
IMEDIA_SetMediaParms 
setting screen bounds, valume, 
playback tempo, and playback 
pitch with, 244 
IMEDIA_Stop method 
stopping media playback with, 244 
IMemAStream interface, 159 
understanding, 162 
lMEMASTREAM_Set interface 
call code, 162 
IMenu control 
events to indicate user interaction, 
67-68 
IMenuCtl control 
classes, 118 
code for sharing events with an ITextCtl 
and, 132-133 
function of, 109 
using, 118-126 
IMENUCTL_AddItem 
adding menu items to menus with, 124 
IMENUCTL_AddItemEx 
function of, 125 
IMENUCTL_HandleEvent 
calling to pass an event to the menu 
control, 96 
index file 
for QUALCOMM BREW database, 174 
INET.....ATON helper function 
for QUALCOMM BREW, 45 
INELNTOA helper function 
for QUALCOMM BREw, 45 
INetMgr class 
creating an ISocket instance with, 
257-260 
INetMgr interface 
implementing TCP lIP networking via, 
253-254 
permitting applications to use raw 
TCP lIP sockets via, 48 
INETMGR_GetHostByName method 
using to obtain a host's IP address, 
257-258 
INETMGR_NetStatus method 
for obtaining status of handset network 
support, 257 
INETMGR_OpenSocket method 
creating a TCP socket with, 258 
obtaining an ISocket instance with, 257 
lNETMGR_SetLinger 
adjusting linger time with, 259-260 
inheritance relationship 
between the IAStream interface and its 
child classes, 160 
initializing 
controls and states, 142-147 
initSprites function 
code for initializing sprites, 223-225 
input line 
steps for combining with a text control, 
130 
input text line 
combining with a soft key menu, 130 
integration testing 
for your QUALCOMM BREW 
applications, 288 
interface controls 
importance of resetting before using, 
92 
Index 
309 

Index 
310 
IPosDet interface 
for obtaining the handset's position, 
274-275 
IPOSDET_GetGPSInfo 
calling to get a handset's position, 
274-275 
IPositionDet interface 
determining the cellular sector 
information via, 49 
lRingerMgr interface 
installing new ringer tones on the 
handset with, 276-277 
IRINGERMGR_EnumNextRinger function 
structure that describes the ringer 
returned by, 276 
IRINGERMGR_EnumRingerInit function 
using, 276-277 
IRINGERMGR_GetFormats method 
checking handset support for ringer 
format with, 277 
IRINGERMGR_Play method 
using to preview a specific ringer, 276 
IRINGERMGR_Remove method 
removing a ringer with, 277 
IRINGERMGR_SetRinger function 
setting the active ring tone with, 276 
IRINGERMGR_Stop method 
using, 276 
IShell interface 
ISHELL_Message and 
ISHELL_MessageBox functions 
provided by, 109 
methods included in, 44 
system functions provided by, 42 
using to play sounds, 239-240 
ISHELL_Beep method 
sound constants for use with, 240 
using to play sounds, 239-240 
ISHELL_CreateInstance method 
creating an instance of IGraphics with, 
207 
creatin~ an ISoundPlayer instance 
Wlth,242 
obtaining instances of other classes 
with, 42 
ISHELL_GetHandler 
using to get the handler of a sound files 
MIME type, 242 
ISHELL_GetPosition API 
returning a simple data structure to a 
callback method with, 274-275 
ISHELL_GetPosition method 
using to determine a handset's 
position, 48 
ISHELL_GetPrefs method 
for loading the preferences structure, 
187-188 
ISHELL_LoadImage interface 
loading the splash screen from an 
application resource with, 88 
ISHELL_LoadResBitmap function 
using, 228-229 
ISHELL_LoadResData interface 
loading opaque binary data from the 
resource file with, 88 
ISHELL_LoadResString interface 
loading strings from a resource file 
with, 88 
ISHELL_Message function 
provided by IShell interface, 109 
ISHELL_MessageBox function 
provided by IShell interface, 109 
ISHELL_PostEvent function 
for posting events to your application, 
66 
ISHELL_SetPrefs method 
setting application preferences with, 
188 
ISHELL_SetTimer interface 
using to ensure the splash screen 
disappears, 88 
ISocket instance 
code for connecting to a remote host, 
259 
using INETMGR_OpenSocket method 
to obtain, 257 
ISocket interface, 159 
choosing for TCP lIP networks, 254 
implementing TCP lIP networking via, 
253-254 
permitting applications to use raw 
TCP lIP sockets via, 48 
understanding, 161,257-260 
ISOCKET_Cancel method 
cancelling callbacks with, 259 
ISOCKET_Read method 
function of, 259 
ISOCKET_Readable method 
scheduling a callback with, 259 
ISOCKET_Release method 
closing a socket with, 259 

ISOCKET_ Write method 
function of, 259 
ISOCKET_ Writeable method 
scheduling a callback with, 259 
ISound interface 
playing tones with, 240-242 
sound available in, 237-239 
for supporting sound in QUALCOMM 
BREW applications, 110 
ISOUND_GetVolume method 
setting handset sound playback 
volume with, 240-242 
ISOUND_PlayTone method 
code example for, 241 
ISound_PlayToneUst method 
playing a set of AEESoundTone tones 
with, 241 
ISOUND _RegisterNotify method 
registering for notifications of status of 
the ISound interface, 241 
ISOUND_SetVolume method 
setting the handset sound playback 
volume with, 240-242 
ISOUND_StopTone method 
calling to stop sound playback, 241 
ISOUND_StopVibrate method 
for cancelling a current vibration, 110 
ISOUND_ Vibrate method 
for interacting with the user, 110 
ISoundPlayer interface 
methods for controlling playback, 243 
playing MIDI, MP3, and QCELP sounds 
with, 242-243 
for supporting sound in QUALCOMM 
BREW applications, 110 
using in an application, 245-250 
ISOUNDPIAYER_FastForward 
fast forwarding the playback with, 243 
ISOUNDPIAYER_GetTotalTime method 
determining the duration of a sound 
with, 242 
ISOUNDPIAYER_Pause 
pausing the playback with, 243 
ISOUNDPIAYER_Play 
playing sounds with, 242-243 
ISOUNDPIAYER_RegisterNotify 
registering a function callback with, 
242 
ISOUNDPIAYER_Resume 
resuming playback with, 243 
ISOUNDPIAYER_Rewind 
for rewinding the playback, 243 
ISOUNDPIAYER_SetInfo 
setting the ISoundPlayer interface to 
the sound data source with, 242 
ISOUNDPIAYER_SetStream 
setting the ISoundPlayer interface to 
the sound data source with, 242 
ISOUNDPIAYER_SetTempo 
setting the tempo of a MIDI sound 
with, 243 
ISOUNDPIAYER_SetThne 
setting the pitch level of a MIDI sound 
with, 243 
ISource object, 159 
ISourceUtil interface 
ISOURCEUTIL_AStreamFromSource 
method of, 255 
ISOURCEUTIL_AStreamFromSource 
method 
using, 255 
using to convert pisMessage field to 
and IStream, 264 
ISprite class 
creating graphics and innovative user 
interfaces with, 203-204 
ISprite graphics 
understanding, 208-210 
ISprite instance 
steps for using in your application, 210 
ISprite interface 
available in BREW version 2.0,204 
sprite and tile sizes supported by, 208 
using, 219-235 
ISPRITE_Release( pISprite ) 
using, 222 
ISPRITE_SetDestination method 
using, 222-223 
ISPRITE_SetSpriteBuffer method 
using, 221-222 
ISPRITE_SetTileBuffer method 
using, 222-223 
IStatic control 
in action, 115 
code for creating, 112 
function of, 109 
list of options, 117 
using, 114-118 
ITAPI interface 
creating, 270 
Index 
311 

Index 
312 
ITAPI interface, continued 
for permitting your application to 
access TAPI, 48 
ITAPCGetCallerID field 
getting the number of the remote side 
ofa call with, 271 
ITAPCGetStatus method 
getting current state of handset 
telephony interface with, 270 
ITAPCMakeVoiceCall method 
instantiating a voice call with, 272 
ITAPCOnCallEnd method 
function of, 272 
ITAPCOnCallStatus method 
monitoring the status of a voice call 
with, 272 
ITAPCSendSMS method 
using to send SMS messages, 272 
IText control 
function of, 68 
text input occurring through, 67 
ITextCtl control 
code example of using, 127-128 
code for adorning with a soft key menu, 
130-132 
code for sharing events with an 
IMenuCtl soft key menu and, 
132-133 
example of plain vs. a soft key menu, 
126 
handling events with, 128-130 
using, 126-134 
ffiansform interface 
available in BREW version 2.0,204 
function of, 207 
ITRANSFORM_TransformBitComplex 
method 
function of, 207 
ITRANSFORM_TransformBitSimple 
method 
function of, 207 
IUnzipAStream 
replacing a stream with, 168-169 
IUnzipAStream interface, 159 
understanding, 162-163 
IWeb interface 
accessing the Web with, 49 
choosing for HTTP transactions, 
254-255 
implementing HTTP networking via, 
253 
table of options, 261 
understanding, 260-264 
IWEB_GetResponse method 
using to start a Web transaction, 263 
IWebOpts interface 
implementing HTTP networking via, 
254-255 
IWEBRESP _GetInfor method 
calling to obtain the results of a 
transaction, 264 
J 
J2ME MIDP runtimes 
vendors writing for the QUALCOMM 
BREW platform, 6 
Java 2 Micro Edition (J2ME) 
vs. QUALCOMM BREw, 5 
K 
key codes 
list of common keys and, 67 
key events 
moving sprites while handling, 233-235 
keyboard. See handset keyboard 
keypad. See handset keyboard 
keys 
list of common and their key codes, 67 
L 
least privilege principle 
maintaining when selecting privileges 
in application's MIF, 49 
Lempel-Ziv 77 (lZ77) compressed data 
decompressing with the 
IUnzipAStream interface, 
162-163 
license types 
for QUALCOMM BREW applications, 
270 
licensing. See application licensing 
linger time 
adjusting, 259-260 
linked list nodes 
code with an insertion sort that sorts 
entries, 196-197 
list control, 119 
IMenuCtl control, 118 
interface name, class ID, and function 
of, 135 
LoadRecord function 
decoding a serialized record with, 
183-184 

10adSprites function 
using, 228-229 
10adTiles function 
using, 230 
Logger. See BREW Logger 
M 
m_rc variable 
denoting the SlideShow screen size 
with, 83 
M7Networks 
products and service that incorporate 
BDSMS with games by, 255 
macros 
vs. functions, 169 
main menu state 
managing, 153-158 
main state 
code for entering, 155-157 
code for exiting, 157-158 
mainDraw function 
code example for, 214-216 
mainDrawUpdate function 
using to update the screen sprites, 
232-233 
mainEnter function 
for entering the main state, 155-157 
mainExit function 
for exiting the main state, 157-158 
mainMusicPlay function 
calling to l?lay the background MIDI 
musIc, 246 
restarting the music playback with, 248 
mainMusicStop function 
stopping the background music 
playback with, 248-249 
mainSoundNotifyCallback function 
function of, 248 
MALLOC helper function 
for QUALCOMM BREW; 45 
using to allocate space for the 
CSlideShow structure, 101 
media format 
setting with the IMEDIA_SetMediaData 
method, 244 
MEMCMP helper function 
for QUALCOMM BREW; 45 
MEMCPYheiper function 
for QUALCOMM BREW; 45 
MEMMOVE helper function 
for QUALCOMM BREW; 45 
memory structure 
code for serializing, 180-181 
MEMSET helper function 
for QUALCOMM BREW; 45 
menu controls, 119 
class IDs for, 120 
IMenuCtl control, 118 
interface name, class ID, and function 
of, 135 
operations application must perform 
when using, 120 
menu items 
initializing with an icon and string from 
a resource file, 125-126 
menu selections 
code for handling, 124-125 
menu state 
code for starting up and tearing down, 
154 
examining in the SlideShow 
application, 91-95 
exiting, 97 
handling events for, 95-96 
menus 
populating with the list of slide shows, 
122-124 
selecting to cause a transition to a new 
state, 151 
Microsoft Internet Information Server (lIS) 
using to transfer data across the 
Internet, 254 
Microsoft Paint 
creating an application icon in, 10 
Microsoft Pocket PC Smartphone edition 
vs. QUALCOMM BREw; 5 
Microsoft PowerPoint presentation 
for preliminary RocketMileage bitmap 
screenshots, 29 
Microsoft Visual Studio 
installing before the QUALCOMM 
BREW SDK, 9 
testing your first application with, 
15-17 
using to build Dynamically Linked 
Libraries (DLLs), 7 
MIDI (Music Industry Digital Interface) 
format 
defined, 170 
representing sounds with, 238 
Index 
313 

Index 
314 
MIDI format, continued 
support for by QUALCOMM BREW; 
109-110,237 
MIFEditor 
Applets tab, 47 
General tab in, 48 
launching, 11 
specifying the application type in, 47 
using, 47-50 
MIFfiles,6 
understanding, 7-8 
milage calculator. See RocketMilage 
application 
mobile applications 
understanding the mobile paradigm, 
23-24 
understanding the user, 23-25 
Mobile Directory Number (MDN) 
provided in the szMobileID field of th 
11tPIStatusstructure,271 
Mobile Shop. See BREW Mobile Shop 
MOD (module) files 
building, 7 
module 
in QUALCOMM BREW platform, 6 
Module Information File (MIF). See MIF 
files 
modules 
understanding the life cycle of, 278 
Motorola iTAP method 
platform-specific entry mechanism, 67 
mouse movements 
controlling, 249-250 
MP3format 
defined, 170 
representing sounds with, 238 
support for by QUALCOMM BREw, 
109-110 
MPEG (Motion Picture Experts Group) 
support for by QUALCOMM BREw, 237 
multimedia 
playing, 243-244 
N 
naming convention 
for application framework functions, 
71 
National Software Testing Labs (NSTL) 
registering with, 9 
RocketMilage application certified by, 
25 
third -Carty testing of your application 
y,287-290 
Web site for list oftests it performs, 289 
Neko to Nonezumi (cat and mouse) game 
demonstrating the ISprite interface 
with, 219-235 
network interfaces 
understanding, 257-265 
network performance speed 
adjusting the emulator's, 55 
network privileges 
you can give your applications, 48 
networking your data, 253-265 
NodeLinkSorted macro 
using to sort Node and NumericNode 
lists, 197-200 
nodes 
types offor linked lists, 196-197 
p 
paint mode 
setting, 207 
Palm Powered platform 
vs. QUALCOMM BREW; 5 
pBuffer field 
function of, 179 
pcbFunccallbackftwnction 
signature, 264 
pData 
casting code for, 273 
performance issues 
addressing, 185 
personal area networking 
choosing Bluetooth for, 256-257 
pi argument 
as pointer to your application's 
instance, 64 
PIN.JCCOORD macro 
using, 235 
PIN_Y_COORD macro 
using, 235 
points vs. coordinates 
using, 219 
position location privileges 
you can give your applications, 48 
preallocation 
as a defensive strategy when creating 
applications, 113 

preferences. See also application 
preferences 
keeping average milage information in, 
187 
principle ofleast privilege 
Q 
maintaining when selecting privileges 
in application's MIF, 49 
QCELP (QUALCOMM Code Excited linear 
Predictive Coding) 
representing sounds with, 238-239 
support for by QUALCOMM BREW, 237 
QCPformat 
support for by QUALCOMM BREW, 
109-110 
QUALCOMM Binary Runtime 
Environment forWrreless (BREW) 
platform. See QUALCOMM BREW 
platform 
QUALCOMM BREW 2.0 
Bluetooth interfaces included in, 
256-257 
QUALCOMM BREW API Reference 
finding utility functions in, 46 
QUALCOMM BREW Application Loader. 
See Application Loader 
QUALCOMM BREW Application Resource 
(BAR) file. See BAR file 
QUALCOMM BREW applications. See also 
applets; applications 
helper function for class setup, 34 
pricing and promoting, 294 
top five ways to fail certification of, 
292-294 
understanding the delivery process, 8 
understanding the flow of, 33-42 
user interface conventions, 108-109 
using audio to interact with the user, 
109-110 
QUALCOMM BREW AppSigner 
signing your application with, 291 
QUALCOMM BREW bitmaps 
understanding, 204-207 
QUALCOMM BREW class hierarchy, 43 
QUALCOMM BREW controls 
using, 110-136 
QUALCOMM BREW Delivery System 
selling extensions through, 277 
QUALCOMM BREW developer 
becoming a registered, 8-9 
developers tools, 46-61 
downloading tools available to, 9 
QUALCOMM BREW Device Configuration 
Editor. See Device Configuration 
Editor 
QUALCOMM BREW Emulator 
building and testing your applet with, 
15-17 
configuring to find applet DLL and MIF, 
16-17 
using, 52-55 
QUALCOMM BREW-enabled handsets. See 
also wireless handsets 
ease of adding applications to, 4 
features in common with regular cell 
phones, 1-3 
RocketMilage application for, 3 
running your application on, 17-20 
steps required before running any 
applications on, 17-19 
transferring your applet to, 19-20 
QUALCOMM BREW events 
commonly used, 36-37 
QUALCOMM BREW extranet 
Web site address, 7, 289 
QUALCOMM BREW ~aphics primatives. 
See graphics pnmatives 
QUALCOMM BREW helper functions 
list of commonly used, 45 
QUALCOMM BREW interfaces 
understanding, 42-46 
QUALCOMM BREW Logger. See BREW 
Logger 
QUALCOMM BREW MediaPlayer sample 
as introduction to using the IMedia 
interface, 244 
QUALCOMM BREWMIF Editor 
Applets tab, 47 
Dependencies tab in, 49-50 
Extensions tab in, 49-50 
General tab in, 48 
specifying the application type in, 47 
using, 47-50 
QUALCOMM BREW platform 
application license types, 270 
application menu in action, 2 
certifying your application, 287-294 
Index 
315 

Index 
316 
QUALCOMM BREW platform, continued 
choosing, 3-6 
class identifier (class 10) in, 7 
vs. competitors, 5 
control interface and class 10 
summary, 134-136 
creating your first application, 8-20 
deciding to develop applications for, 
3-6 
designing for, 21-32 
developing applications for, 33-62 
drawing graphics, 203-235 
getting started with development, 
33-42 
graphics APls and BREW version 
available in, 204 
interacting with the user, 107-158 
interfacing with a database, 175-184 
introduction to, 1-20 
managing application licensing, 
269-270 
managing ringer tones in, 275-277 
modules and applets, 6-7 
playing with sounds, 237-250 
seeing for the first time, 1-3 
sharing code between applications, 
277-285 
storing data, 173-201 
support for Bluetooth in newest 
versions, 253 
vs. true object-oriented environments, 
46 
understanding, 6-8 
understanding graphics capabilities of, 
203-210 
using telephony features, 270-274 
why carriers choose it, 3-4 
why developers choose it, 4-5 
writing your first application, 10-15 
QUALCOMM BREW Resource Editor. See 
Resource Editor 
QUALCOMM BREW SDK 
downloading and installing, 9 
QUALCOMM BREW Sprite operations. See 
ISprite graphics 
QUALCOMM BREWWeb site 
acquiring available tool chains from, 18 
QUALCOMM Code Excited linear 
Predictive Coding (QCELP) 
support for by QUALCOMM BREW; 237 
QUALCOMM PureVoice 
support for by QUALCOMM BREW; 237 
QUALCOMM PureVoice converter 
R 
using to convert between Wmdows 
WAY files and QCELP files, 239 
REALLOC helper function 
for QUALCOMM BREW; 45 
record iterator 
function of for the address book, 268 
records 
creating on database implementation, 
173-174 
removing from address book, 269 
regression testing 
for your QUALCOMM BREW 
applications, 288 
Release method 
implementing for extensions, 284-285 
Resource Editor 
using, 51-52 
resource files 
building, 51-52 
understanding, 7-8 
resources 
code for freeing allocated, 153 
editing, 51-52 
ringer directory 
privileges for writing to, 49 
ringer tones 
installing, 276-277 
managing, 275-277 
RocketMilage application 
using AS_DBFieldFromDatabase 
function in, 190-191, 194 
using AS_DBFieldToDatabase function 
in, 190-191 
using DBThawRecord function in, 
192-194 
RocketMileage application 
applying use cases to deSign, 25-28 
code for the database schema, 187 
code for the data structure, 31-32 
creating preliminary bitmap 
screenshot images for, 29-30 
decomposing into components, 30-32 

describing the interface, 28-30 
operations common to multiple use 
cases for, 28 
for QUALCOMM BREW-enabled 
handsets, 3 
understanding, 25-32 
understanding the schema, 186-187 
RocketMileage interface 
describing, 28-30 
s 
SaveRecord function 
using, 180-181 
sector information privileges 
for determinin~ cellular sector 
information, 49 
Secure Socket Layer (SSL). See1tansport 
Layer Security (TLS) 
Select key 
using in QUALCOMM BREW 
applications, 108-109 
Select keystroke 
function of in a text control, 151 
serialized records 
code for decoding, 183-184 
SetAppData macro 
using, 166 
Settings dialog box 
controlling basic operation of the 
emulator via, 52-55 
specifying location of your application 
and its MIF settings in, 54 
shapes 
code for creating in GraphicsSample 
application, 213 
shared directories 
privileges for writing to, 49 
Short Message Service (SMS) messages, 33 
pausing of applications when 
receiVIng, 3 
receiving to trigger actions within your 
application,253,255-256 
sending, 272 
ShowBitmapEntry 
for entering the bitmap state, 165-166 
ShowCopyrightfunction 
code example for, 88 
for showing the application splash 
screen, 86 
ShowNextSlide function 
code for invoking, 98-100 
SIG (signature) file 
using the QUALCOMM extranet to 
create, 18 
skins 
use ofto represent different handsets 
54 
' 
slide shows 
presenting the menu of, 91-92 
slide show state 
entering, 100-102 
examining in the SlideShow, 97-105 
exiting, 104-105 
handling events in, 101 
SlideShow application 
building an application framework for 
68-80 
' 
code example for initialization, 83-84 
121 
' 
code for main event handler, 85-86 
code for showing the next slide, 98-100 
examining the menu state in, 91-97 
examining the slide state in, 97-105 
examining the startup code, 82-91 
example of, 81 
freeing resources used by, 87 
showing the application splash screen 
for, 86-91 
using the application framework, 81-82 
SlideShow_Free application destructor 
freeing resources used by the 
SlideShow application with, 87 
SlideShow_Initfunction 
for initializing the SlideShow 
application, 83-84 
smart phones 
limitations, availability, and cost of, 4 
SMS messages. See Short Message Service 
(SMS) messages 
socket life cycle 
creating a state for each phase of, 260 
soft key menu 
combining with an input text line, 130 
soft key menu control, 119 
code for adorning an ITextCtl control 
with, 130-132 
IMenuCtl control, 118 
interface name, class ID, and function 
of,135 
Index 
317 

Index 
318 
software quality testing 
for your QUALCOMM BREW 
applications, 28B-289 
sorting 
database records, 185-186 
routine for testing sort opertations, 
197-200 
sound 
representing in QUALCOMM BREW; 
237-239 
support for by QUALCOMM BREW; 
109-110 
sound interfaces 
adding to an application, 245-246 
sounds 
playing with, 237-250 
understanding how to play, 239-244 
SPRINTF helper function 
for QUALCOMM BREW; 45 
sprite 
defined,208 
sprite and tile maps 
code for loading, 220-223 
sprite engine 
function of, 208 
sprites 
moving while handling key events, 
233-235 
sprites and tiles 
defining, 220-223 
drawing the background and, 231-232 
initializing, 223-228 
loading, 228-231 
ST_ASCII option 
for IStatic control, 117 
ST_CENTERTEXToption 
for IStatic control, 117 
ST_CENTERTITLE option 
for IStatic control, 117 
ST_ENBALEHLGHToption 
for IStatic control, 117 
ST_ENBALETAB option 
for IStatic control, 117-118 
ST_MIDDLETEXT option 
for IStatic control, 117 
ST_NOSCROLLoption 
for IStatic control, 117 
ST_TEXTALLOC option 
for IStatic control, 117 
ST_TITLEALLOC option 
for IStatic control, 117 
ST_UNDERLINE option 
for IStatic control, 117 
state field 
getting an indication of current state of 
handset with, 271 
state machine 
advantages of structuring your 
application as, 6B-70 
interfaces framework must provide, 71 
managing the applications, 71-80 
simplifying the structure, 137-142 
state management interface 
code example for, 71-72 
state stack 
code for manipulating, 75-76 
deciding where to store the base of, 
72-73 
defining its first members of 
application structure, 73 
State_HandleEvent function 
for handling events within the state 
framework, 78-80 
State_Pop function, 75-76 
State_Push function, 74-75 
State_Push function 
code example for, 73-75 
State_Resume function 
resuming the current state with, 77 
State_Suspend function 
suspending the current state with, 77 
states 
code example for managing the list of, 
138-140 
initializing, 142-147 
static item display control 
interface name, class ID, and function 
of,134 
static module-scope variables 
unsupported in QUALCOMM BREW 
platform, 39 
status callback 
setting with the IMEDIA....RegisterNotify 
function, 244 
stopwatch timer control 
interface name, class ID, and function 
of,134 
storing data, 173-201 

STR_TO_WSTR 
using, 116 
STRCAT helper function 
for QUALCOMM BREW; 45 
STRCHR helper function 
for QUALCOMM BREw; 45 
STRCMP helper function 
for QUALCOMM BREW; 45 
STRCPY helper function 
for QUALCOMM BREW; 45 
STROUP helper function 
for QUALCOMM BREW; 45 
stream interface 
code for getting from a filename, 
167-168 
process for using, 159-160 
replacing a stream with an 
IUnzipAStream, 168-169 
using, 163-170 
streaming data, 159-171 
StreamSample application 
for showing how to use streams, 
163-170 
using the framework in, 164 
STRENDS helper function 
for testing a filename, 95 
STRLEN helper function 
for QUALCOMM BREw; 45 
STRNCPY helper function 
for QUALCOMM BREw; 45 
STRSTR helper function 
for QUALCOMM BREw; 45 
system events 
handling, 65-66 
szMobileID field 
T 
handset mobile number provided by, 
271 
tactile (touch) interfaces 
for interacting with the user, 110 
TAPIStatus structure 
information about handset in, 271 
TCP lIP networking 
implementing, 253-254 
Tegic'sT9 
platform-specific entry mechanism, 67 
Tegic's T9 predictive keyboard 
for QUALCOMM BREW-enabled 
handsets and regular cell phones, 
2 
Telephony Application Programming 
Interface (TAPI) 
for using telephony features, 270 
Telephony Application Programming 
Interface (TAPI) privileges 
for your applications, 48 
telephony features 
using, 270-274 
testing 
types of for your applications, 288-289 
your first application, 15-17 
text control 
steps for combining with an input line, 
130 
text input control 
interface name, class ID, and function 
of, 135 
tile and sprite maps 
code for loading, 220-223 
tile bitmaps 
code for loading, 230-231 
function of, 209 
tile maps 
code for filling, 226-227 
function of, 209 
tiles and sprites 
defining, 220-223 
initializing, 223-228 
loading, 228-231 
tones 
playing, 240-242 
tool chains 
acquiring from QUALCOMM BREW 
Web site, 18 
Tools menu 
controlling basic operation of the 
emulator via, 52-55 
touch interfaces. See tactile (touch) 
interfaces 
Transport Layer Security (TLS) 
support for in QUALCOMM BREW 2.0, 
255 
TRUE BREW certification 
for certifying your application, 8, 
287-294 
Index 
319 

Index 
320 
U 
Unified Modeling Language (UML) 
diagrams 
capturing before starting to write 
applications, 22-23 
using to diagram actor uses for 
applications, 24-25 
unit testing 
for your QUALCOMM BREW 
applications, 288 
UNUSED macro 
using in the SlideShow application, 
91-92 
Up keystroke 
function of in a text control, 151 
use case analysis 
for designing and capturing your user 
interface, 24-25 
showing operations common to 
mUltiple use cases for 
Rocke~eage,28 
use case diagrams 
of possible features for RocketMilage 
application, 26-27 
use cases 
applying to Rocke~eage's design, 
25-28 
benefits of creating for your 
applications, 24-25 
user interaction 
understanding modes of, 107-110 
user interface 
capturing for your applications, 24-25 
presenting a prototype, 80-105 
steps for combining a text control with 
an input line, 130 
testing for, 290 
user interface controls. See QUALCOMM 
BREW controls 
user interface conventions 
for QUALCOMM BREW applications, 
108-109 
user interface events 
handling, 66-68 
user manuals 
importance offor your applications, 
290 
utility functions 
in QUALCOMM BREW API Reference, 
46 
v 
validation tests 
performing on your applications, 
289-290 
value-added modules 
selling through the QUALCOMM BREW 
Delivery System, 277 
verification testing 
for applications, 290 
vertical applications 
reason for writing in other applications, 
5 
viewport 
positioning, 217-218 
VIEW_EXTENTS constant 
setting the size of the drawing canvas 
with, 212 
vtable (virtual function table) 
storage of a module's interface in, 279 
W 
WAVfiles 
support for by QUALCOMM BREW; 
109-110 
wDataLen field 
function of, 179 
Web access privileges 
you can give your applications, 49 
Web site address 
for acquiring tool chains for ARM, 18 
Apress, 11,80 
for QUALCOMM BREW extranet, 7, 289 
WEBOPCACTIVEXACTIONS option 
for IWeb interface, 261 
WEBOPT_CONNECTI1MEOUT option 
for IWeb interface, 261 
WEBOPT_CONTEN1LENGTHoption 
for IWeb interface, 261 
WEBOPT_HANDLERDATA option 
for IWeb interface, 261 
WEBOPT_HEADER option 
for IWeb interface, 261 
WEBOPT_HEADERHANDLER option 
for IWeb interface, 261 
WEBOPT_IDLECONNTIMEOUT option 
for IWeb interface, 261 
WEBOPT_METHOD option 
for IWeb interface, 261 

WEBOP'CPROXYSPEC option 
for IWeb interface, 261 
WEBOPT_STATUSHANDLER option 
for IWeb interface, 261 
WEBOPT_USERAGENT option 
for IWeb interface, 261 
WebRespInfo structure 
code example showing fields in, 264 
WEBS_CACHEHIT 
meaning, 263 
WEBS_CANCELLED 
meaning, 263 
WEBS_CONNECT 
meaning, 263 
WEBS_GETHOSTBYNAME 
meaning, 263 
WEBS_GOTREDIRECT 
meaning, 263 
WEBS_READRESPONSE 
meaning, 263 
WEBS_SENDREQEST 
meaning, 263 
WEBS_STARTING 
meaning, 263 
WebStatus 
table of enumeration and meanings, 
263 
wireless carriers 
why they choose QUALCOMM BREW; 
3-4 
wireless handsets 
APIs for building applications for, 1 
controlling, 267-285 
determining the position of, 274-275 
running your application on, 17-20 
understanding how you can control, 
267 
using the telephony features of, 
270-274 
wireless network options 
choosing, 253-257 
wireless terminals 
limitations, availability, and cost of, 4 
World Wide Web Consortium's Request for 
Comment 2616 
for in-depth overview of HTTP, 262 
wParam argument 
function of, 64 
write access privileges 
for permitting application access to 
shared directories, 49 
Index 
321 

JOIN THE APRESS FORUMS AND BE PART OF OUR COMMUNIlY. You'll find discussions that cover topics 
of interest to IT professionals, programmers, and enthusiasts just like you. If you post a query to one of our 
forums, you can expect that some of the best minds in the business-especially Apress authors, who all write 
with The Expert's Voice 1M -will chime in to help you. Why not aim to become one of our most valuable partic-
ipants (MVPs) and win cool stuff? Here's a sampling of what you'll find: 
DATABASES 
Data drives everything. 
Share information, exchange ideas, and discuss any database 
programming or administration issues. 
INTERNET TECHNOLOGIES AND NETWORKING 
Try living without plumbing (and eventually 1Pv6). 
Talk about networking topiCS including protocols, design, 
administration, wireless, wired, storage, backup, certifications, 
trends, and new technologies. 
JAVA 
We've come a long way from the old Oak tree. 
Hang out and discuss Java In whatever flavor you choose: 
J2SE, J2EE, J2ME, Jakarta, and so on. 
MAC OS X 
All about the Zen of OS x. 
as x is both the present and the future for Mac apps. Make 
suggestions, offer up ideas, or boast about your new hardware. 
OPEN SOURCE 
Source code Is good; underslandlng (open) source Is better. 
Discuss open source technologies and related topics such as 
PHp, MySQL, Linux, Perl, Apache, Python, and more. 
HOW TO PARTICIPATE: 
PROGRAMMING/BUSINESS 
Unforhmately, It Is. 
Talk about the Apress line of books that cover software 
methodology, best practices, and how programmers interact with 
the Â·suils.' 
WEB DEVELOPMENT/DESIGN 
Ugly doesn't cut It anymore, and CGI is absurd. 
Help is in sight for your site. Rnd design solutions for your 
projects and get ideas for building an interactive Web site. 
SECURITY 
Lots of bad guys out there-the good guys need help. 
Discuss computer and network security issues here. Just don't let 
anyone else know the answers! 
TECHNOLOGY IN ACTION 
Cool things. Fun things. 
Irs after hours. Irs time to play. Whether you're into LEGOiII> 
MINDSTORMSTM or turning an old PC into a DVR, this is where 
technology tums into fun. 
WINDOWS 
No defenestration here. 
Ask questions about all aspects of Windows programming, get 
help on Microsoft technologies covered in Apress books, or 
provide feedback on any Apress Windows book. 
Go to the Apress Forums site at http://forums.apress.com/. 
Click the New User link. 

