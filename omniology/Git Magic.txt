Git Magic
Ben Lynn

Git Magic
by Ben Lynn
Revision History
August 2007 Revised by: BL

Table of Contents
Preface .......................................................................................................................................................vi
1. Thanks!..........................................................................................................................................vi
2. License ........................................................................................................................................ vii
1. Introduction............................................................................................................................................1
1.1. Work is Play ................................................................................................................................1
1.2. Version Control ...........................................................................................................................1
1.3. Distributed Control......................................................................................................................1
1.4. A Silly Superstition.....................................................................................................................2
1.5. Merge Conﬂicts...........................................................................................................................3
2. Basic Tricks ............................................................................................................................................4
2.1. Saving State.................................................................................................................................4
2.2. Add, Delete, Rename ..................................................................................................................4
2.3. Advanced Undo/Redo .................................................................................................................5
2.4. Reverting.....................................................................................................................................6
2.5. Changelog Generation.................................................................................................................6
2.6. Downloading Files ......................................................................................................................6
2.7. The Bleeding Edge......................................................................................................................7
2.8. Instant Publishing........................................................................................................................7
2.9. What Have I Done?.....................................................................................................................8
2.10. Exercise.....................................................................................................................................8
3. Cloning Around ...................................................................................................................................10
3.1. Sync Computers ........................................................................................................................10
3.2. Classic Source Control..............................................................................................................10
3.3. Secret Source.............................................................................................................................11
3.4. Bare repositories .......................................................................................................................12
3.5. Push versus pull.........................................................................................................................12
3.6. Forking a Project.......................................................................................................................12
3.7. Ultimate Backups......................................................................................................................13
3.8. Light-Speed Multitask...............................................................................................................13
3.9. Guerilla Version Control ...........................................................................................................13
3.10. Mercurial.................................................................................................................................14
3.11. Bazaar......................................................................................................................................15
3.12. Why I use Git ..........................................................................................................................15
4. Branch Wizardry.................................................................................................................................17
4.1. The Boss Key ............................................................................................................................17
4.2. Dirty Work ................................................................................................................................18
4.3. Quick Fixes ...............................................................................................................................18
4.4. Merging.....................................................................................................................................19
4.5. Uninterrupted Workﬂow ...........................................................................................................20
4.6. Reorganizing a Medley .............................................................................................................21
4.7. Managing Branches...................................................................................................................21
4.8. Temporary Branches .................................................................................................................22
4.9. Work How You Want ................................................................................................................22
iii

5. Lessons of History................................................................................................................................23
5.1. I Stand Corrected ......................................................................................................................23
5.2. ... And Then Some...................................................................................................................23
5.3. Local Changes Last...................................................................................................................24
5.4. Rewriting History......................................................................................................................25
5.5. Making History .........................................................................................................................25
5.6. Where Did It All Go Wrong?....................................................................................................27
5.7. Who Made It All Go Wrong? ...................................................................................................27
5.8. Personal Experience..................................................................................................................28
6. Multiplayer Git ....................................................................................................................................29
6.1. Who Am I?................................................................................................................................29
6.2. Git Over SSH, HTTP ................................................................................................................29
6.3. Git Over Anything.....................................................................................................................30
6.4. Patches: The Global Currency ..................................................................................................30
6.5. Sorry, We’ve Moved..................................................................................................................31
6.6. Remote Branches ......................................................................................................................32
6.7. Multiple Remotes......................................................................................................................33
6.8. My Preferences .........................................................................................................................33
7. Git Grandmastery................................................................................................................................35
7.1. Source Releases.........................................................................................................................35
7.2. Commit What Changed.............................................................................................................35
7.3. My Commit Is Too Big!............................................................................................................35
7.4. The Index: Git’s Staging Area ..................................................................................................36
7.5. Don’t Lose Your HEAD............................................................................................................36
7.6. HEAD-hunting..........................................................................................................................37
7.7. Building On Git.........................................................................................................................38
7.8. Daring Stunts.............................................................................................................................39
7.9. Preventing Bad Commits ..........................................................................................................39
8. Secrets Revealed...................................................................................................................................41
8.1. Invisibility .................................................................................................................................41
8.2. Integrity.....................................................................................................................................41
8.3. Intelligence................................................................................................................................41
8.4. Indexing.....................................................................................................................................42
8.5. Git’s Origins..............................................................................................................................42
8.6. The Object Database .................................................................................................................42
8.7. Blobs .........................................................................................................................................42
8.8. Trees..........................................................................................................................................43
8.9. Commits....................................................................................................................................44
8.10. Indistinguishable From Magic ................................................................................................45
A. Git Shortcomings ................................................................................................................................47
A.1. SHA1 Weaknesses....................................................................................................................47
A.2. Microsoft Windows..................................................................................................................47
A.3. Unrelated Files .........................................................................................................................47
A.4. Who’s Editing What?...............................................................................................................47
A.5. File History...............................................................................................................................48
A.6. Initial Clone..............................................................................................................................48
iv

A.7. Volatile Projects........................................................................................................................48
A.8. Global Counter.........................................................................................................................49
A.9. Empty Subdirectories...............................................................................................................49
A.10. Initial Commit ........................................................................................................................49
A.11. Interface Quirks......................................................................................................................50
B. Translating This Guide.......................................................................................................................51
v

Preface
Git (http://git-scm.com/) is a version control Swiss army knife. A reliable versatile multipurpose revision
control tool whose extraordinary ﬂexibility makes it tricky to learn, let alone master.
As Arthur C. Clarke observed, any sufﬁciently advanced technology is indistinguishable from magic.
This is a great way to approach Git: newbies can ignore its inner workings and view Git as a gizmo that
can amaze friends and infuriate enemies with its wondrous abilities.
Rather than go into details, we provide rough instructions for particular effects. After repeated use,
gradually you will understand how each trick works, and how to tailor the recipes for your needs.
Translations
• Simpliﬁed Chinese (/~blynn/gitmagic/intl/zh_cn/): by JunJie, Meng and JiangWei. Converted to
Traditional Chinese (/~blynn/gitmagic/intl/zh_tw/) via cconv -f UTF8-CN -t UTF8-TW.
• French (/~blynn/gitmagic/intl/fr/): by Alexandre Garel, Paul Gaborit, and Nicolas Deram. Also hosted
at itaapy (http://tutoriels.itaapy.com/).
• German (/~blynn/gitmagic/intl/de/): by Benjamin Bellee and Armin Stebich; also hosted on Armin’s
website (http://gitmagic.lordofbikes.de/).
• Italian (/~blynn/gitmagic/intl/it/): by Mattia Rigotti.
• Polish (/~blynn/gitmagic/intl/pl/): by Damian Michna.
• Brazilian Portuguese (/~blynn/gitmagic/intl/pt_br/): by José Inácio Seraﬁni and Leonardo Siqueira
Rodrigues.
• Russian (/~blynn/gitmagic/intl/ru/): by Tikhon Tarnavsky, Mikhail Dymskov, and others.
• Spanish (/~blynn/gitmagic/intl/es/): by Rodrigo Toledo and Ariset Llerena Tapia.
• Ukrainian (/~blynn/gitmagic/intl/uk/): by Volodymyr Bodenchuk.
• Vietnamese (/~blynn/gitmagic/intl/vi/): by Tr<7847>n Ng<7885>c Quân; also hosted on his website
(http://vnwildman.users.sourceforge.net/gitmagic/).
Other Editions
• Single webpage (book.html): barebones HTML, with no CSS.
• PDF ﬁle (book.pdf): printer-friendly.
• Debian package (http://packages.debian.org/gitmagic), Ubuntu package
(http://packages.ubuntu.com/gitmagic): get a fast and local copy of this site. Handy when this server is
ofﬂine (http://csdcf.stanford.edu/status/).
• Physical book [Amazon.com (http://www.amazon.com/Git-Magic-Ben-Lynn/dp/1451523343/)]: 64
pages, 15.24cm x 22.86cm, black and white. Handy when there is no electricity.
vi

Preface
1. Thanks!
I’m humbled that so many people have worked on translations of these pages. I greatly appreciate having
a wider audience because of the efforts of those named above.
Dustin Sallings, Alberto Bertogli, James Cameron, Douglas Livingstone, Michael Budde, Richard
Albury, Tarmigan, Derek Mahar, Frode Aannevik, Keith Rarick, Andy Somerville, Ralf Recker, Øyvind
A. Holm, Miklos Vajna, Sébastien Hinderer, Thomas Miedema, Joe Malin, Tyler Breisacher, Sonia
Hamilton, Julian Haagsma, Romain Lespinasse, Sergey Litvinov, Oliver Ferrigni, David Toca, Ñåðãåé
Ñåðãååâ, Joël Thieffry, and Baiju Muthukadan contributed corrections and improvements.
François Marier maintains the Debian package originally created by Daniel Baumann.
John Hinnegan bought the gitmagic.com (http://www.gitmagic.com/) domain.
My gratitude goes to many others for your support and praise. I’m tempted to quote you here, but it
might raise expectations to ridiculous heights.
If I’ve left you out by mistake, please tell me or just send me a patch!
2. License
This guide is released under the GNU General Public License version 3
(http://www.gnu.org/licenses/gpl-3.0.html). Naturally, the source is kept in a Git repository, and can be
obtained by typing:
$ git clone git://repo.or.cz/gitmagic.git
# Creates "gitmagic" directory.
or from one of the mirrors:
$ git clone git://github.com/blynn/gitmagic.git
$ git clone git://gitorious.org/gitmagic/mainline.git
$ git clone https://code.google.com/p/gitmagic/
$ git clone git://git.assembla.com/gitmagic.git
$ git clone git@bitbucket.org:blynn/gitmagic.git
GitHub, Assembla, and Bitbucket support private repositories, the latter two for free.
vii

Chapter 1. Introduction
I’ll use an analogy to introduce version control. See the Wikipedia entry on revision control
(http://en.wikipedia.org/wiki/Revision_control) for a saner explanation.
1.1. Work is Play
I’ve played computer games almost all my life. In contrast, I only started using version control systems
as an adult. I suspect I’m not alone, and comparing the two may make these concepts easier to explain
and understand.
Think of editing your code, or document, as playing a game. Once you’ve made a lot of progress, you’d
like to save. To do so, you click on the Save button in your trusty editor.
But this will overwrite the old version. It’s like those old school games which only had one save slot:
sure you could save, but you could never go back to an older state. Which was a shame, because your
previous save might have been right at an exceptionally fun part of the game that you’d like to revisit one
day. Or worse still, your current save is in an unwinnable state, and you have to start again.
1.2. Version Control
When editing, you can Save As... a different ﬁle, or copy the ﬁle somewhere ﬁrst before saving if you
want to savour old versions. You can compress them too to save space. This is a primitive and
labour-intensive form of version control. Computer games improved on this long ago, many of them
providing multiple automatically timestamped save slots.
Let’s make the problem slightly tougher. Say you have a bunch of ﬁles that go together, such as source
code for a project, or ﬁles for a website. Now if you want to keep an old version you have to archive a
whole directory. Keeping many versions around by hand is inconvenient, and quickly becomes expensive.
With some computer games, a saved game really does consist of a directory full of ﬁles. These games
hide this detail from the player and present a convenient interface to manage different versions of this
directory.
Version control systems are no different. They all have nice interfaces to manage a directory of stuff. You
can save the state of the directory every so often, and you can load any one of the saved states later on.
Unlike most computer games, they’re usually smart about conserving space. Typically, only a few ﬁles
change from version to version, and not by much. Storing the differences instead of entire new copies
saves room.
1

Chapter 1. Introduction
1.3. Distributed Control
Now imagine a very difﬁcult computer game. So difﬁcult to ﬁnish that many experienced gamers all over
the world decide to team up and share their saved games to try to beat it. Speedruns are real-life
examples: players specializing in different levels of the same game collaborate to produce amazing
results.
How would you set up a system so they can get at each other’s saves easily? And upload new ones?
In the old days, every project used centralized version control. A server somewhere held all the saved
games. Nobody else did. Every player kept at most a few saved games on their machine. When a player
wanted to make progress, they’d download the latest save from the main server, play a while, save and
upload back to the server for everyone else to use.
What if a player wanted to get an older saved game for some reason? Maybe the current saved game is in
an unwinnable state because somebody forgot to pick up an object back in level three, and they want to
ﬁnd the latest saved game where the game can still be completed. Or maybe they want to compare two
older saved games to see how much work a particular player did.
There could be many reasons to want to see an older revision, but the outcome is the same. They have to
ask the central server for that old saved game. The more saved games they want, the more they need to
communicate.
The new generation of version control systems, of which Git is a member, are known as distributed
systems, and can be thought of as a generalization of centralized systems. When players download from
the main server they get every saved game, not just the latest one. It’s as if they’re mirroring the central
server.
This initial cloning operation can be expensive, especially if there’s a long history, but it pays off in the
long run. One immediate beneﬁt is that when an old save is desired for any reason, communication with
the central server is unnecessary.
1.4. A Silly Superstition
A popular misconception is that distributed systems are ill-suited for projects requiring an ofﬁcial central
repository. Nothing could be further from the truth. Photographing someone does not cause their soul to
be stolen. Similarly, cloning the master repository does not diminish its importance.
A good ﬁrst approximation is that anything a centralized version control system can do, a well-designed
distributed system can do better. Network resources are simply costlier than local resources. While we
2

Chapter 1. Introduction
shall later see there are drawbacks to a distributed approach, one is less likely to make erroneous
comparisons with this rule of thumb.
A small project may only need a fraction of the features offered by such a system, but using systems that
scale poorly for tiny projects is like using Roman numerals for calculations involving small numbers.
Moreover, your project may grow beyond your original expectations. Using Git from the outset is like
carrying a Swiss army knife even though you mostly use it to open bottles. On the day you desperately
need a screwdriver you’ll be glad you have more than a plain bottle-opener.
1.5. Merge Conﬂicts
For this topic, our computer game analogy becomes too thinly stretched. Instead, let us again consider
editing a document.
Suppose Alice inserts a line at the beginning of a ﬁle, and Bob appends one at the end of his copy. They
both upload their changes. Most systems will automatically deduce a reasonable course of action: accept
and merge their changes, so both Alice’s and Bob’s edits are applied.
Now suppose both Alice and Bob have made distinct edits to the same line. Then it is impossible to
proceed without human intervention. The second person to upload is informed of a merge conﬂict, and
must choose one edit over another, or revise the line entirely.
More complex situations can arise. Version control systems handle the simpler cases themselves, and
leave the difﬁcult cases for humans. Usually their behaviour is conﬁgurable.
3

Chapter 2. Basic Tricks
Rather than diving into a sea of Git commands, use these elementary examples to get your feet wet.
Despite their simplicity, each of them are useful. Indeed, in my ﬁrst months with Git I never ventured
beyond the material in this chapter.
2.1. Saving State
About to attempt something drastic? Before you do, take a snapshot of all ﬁles in the current directory
with:
$ git init
$ git add .
$ git commit -m "My first backup"
Now if your new edits go awry, restore the pristine version:
$ git reset --hard
To save the state again:
$ git commit -a -m "Another backup"
2.2. Add, Delete, Rename
The above only keeps track of the ﬁles that were present when you ﬁrst ran git add. If you add new ﬁles
or subdirectories, you’ll have to tell Git:
$ git add readme.txt Documentation
Similarly, if you want Git to forget about certain ﬁles:
$ git rm kludge.h obsolete.c
$ git rm -r incriminating/evidence/
Git deletes these ﬁles for you if you haven’t already.
Renaming a ﬁle is the same as removing the old name and adding the new name. There’s also the
shortcut git mv which has the same syntax as the mv command. For example:
$ git mv bug.c feature.c
4

Chapter 2. Basic Tricks
2.3. Advanced Undo/Redo
Sometimes you just want to go back and forget about every change past a certain point because they’re
all wrong. Then:
$ git log
shows you a list of recent commits, and their SHA1 hashes:
commit 766f9881690d240ba334153047649b8b8f11c664
Author: Bob <bob@example.com>
Date:
Tue Mar 14 01:59:26 2000 -0800
Replace printf() with write().
commit 82f5ea346a2e651544956a8653c0f58dc151275c
Author: Alice <alice@example.com>
Date:
Thu Jan 1 00:00:00 1970 +0000
Initial commit.
The ﬁrst few characters of the hash are enough to specify the commit; alternatively, copy and paste the
entire hash. Type:
$ git reset --hard 766f
to restore the state to a given commit and erase all newer commits from the record permanently.
Other times you want to hop to an old state brieﬂy. In this case, type:
$ git checkout 82f5
This takes you back in time, while preserving newer commits. However, like time travel in a
science-ﬁction movie, if you now edit and commit, you will be in an alternate reality, because your
actions are different to what they were the ﬁrst time around.
This alternate reality is called a branch, and we’ll have more to say about this later. For now, just
remember that
$ git checkout master
will take you back to the present. Also, to stop Git complaining, always commit or reset your changes
before running checkout.
To take the computer game analogy again:
5

Chapter 2. Basic Tricks
• git reset --hard: load an old save and delete all saved games newer than the one just loaded.
• git checkout: load an old game, but if you play on, the game state will deviate from the newer
saves you made the ﬁrst time around. Any saved games you make now will end up in a separate
branch representing the alternate reality you have entered. We deal with this later.
You can choose only to restore particular ﬁles and subdirectories by appending them after the command:
$ git checkout 82f5 some.file another.file
Take care, as this form of checkout can silently overwrite ﬁles. To prevent accidents, commit before
running any checkout command, especially when ﬁrst learning Git. In general, whenever you feel unsure
about any operation, Git command or not, ﬁrst run git commit -a.
Don’t like cutting and pasting hashes? Then use:
$ git checkout :/"My first b"
to jump to the commit that starts with a given message. You can also ask for the 5th-last saved state:
$ git checkout master~5
2.4. Reverting
In a court of law, events can be stricken from the record. Likewise, you can pick speciﬁc commits to
undo.
$ git commit -a
$ git revert 1b6d
will undo just the commit with the given hash. The revert is recorded as a new commit, which you can
conﬁrm by running git log.
2.5. Changelog Generation
Some projects require a changelog (http://en.wikipedia.org/wiki/Changelog). Generate one by typing:
$ git log > ChangeLog
6

Chapter 2. Basic Tricks
2.6. Downloading Files
Get a copy of a project managed with Git by typing:
$ git clone git://server/path/to/files
For example, to get all the ﬁles I used to create this site:
$ git clone git://git.or.cz/gitmagic.git
We’ll have much to say about the clone command soon.
2.7. The Bleeding Edge
If you’ve already downloaded a copy of a project using git clone, you can upgrade to the latest version
with:
$ git pull
2.8. Instant Publishing
Suppose you’ve written a script you’d like to share with others. You could just tell them to download
from your computer, but if they do so while you’re improving the script or making experimental
changes, they could wind up in trouble. Of course, this is why release cycles exist. Developers may work
on a project frequently, but they only make the code available when they feel it is presentable.
To do this with Git, in the directory where your script resides:
$ git init
$ git add .
$ git commit -m "First release"
Then tell your users to run:
$ git clone your.computer:/path/to/script
to download your script. This assumes they have ssh access. If not, run git daemon and tell your users to
instead run:
$ git clone git://your.computer/path/to/script
7

Chapter 2. Basic Tricks
From now on, every time your script is ready for release, execute:
$ git commit -a -m "Next release"
and your users can upgrade their version by changing to the directory containing your script and typing:
$ git pull
Your users will never end up with a version of your script you don’t want them to see.
2.9. What Have I Done?
Find out what changes you’ve made since the last commit with:
$ git diff
Or since yesterday:
$ git diff "@{yesterday}"
Or between a particular version and 2 versions ago:
$ git diff 1b6d "master~2"
In each case the output is a patch that can be applied with git apply. Try also:
$ git whatchanged --since="2 weeks ago"
Often I’ll browse history with qgit (http://sourceforge.net/projects/qgit) instead, due to its slick
photogenic interface, or tig (http://jonas.nitro.dk/tig/), a text-mode interface that works well over slow
connections. Alternatively, install a web server, run git instaweb and ﬁre up any web browser.
2.10. Exercise
Let A, B, C, D be four successive commits where B is the same as A except some ﬁles have been
removed. We want to add the ﬁles back at D. How can we do this?
There are at least three solutions. Assuming we are at D:
1. The difference between A and B are the removed ﬁles. We can create a patch representing this
difference and apply it:
$ git diff B A | git apply
8

Chapter 2. Basic Tricks
2. Since we saved the ﬁles back at A, we can retrieve them:
$ git checkout A foo.c bar.h
3. We can view going from A to B as a change we want to undo:
$ git revert B
Which choice is best? Whichever you prefer most. It is easy to get what you want with Git, and often
there are many ways to get it.
9

Chapter 3. Cloning Around
In older version control systems, checkout is the standard operation to get ﬁles. You retrieve a bunch of
ﬁles in a particular saved state.
In Git and other distributed version control systems, cloning is the standard operation. To get ﬁles, you
create a clone of the entire repository. In other words, you practically mirror the central server. Anything
the main repository can do, you can do.
3.1. Sync Computers
I can tolerate making tarballs or using rsync for backups and basic syncing. But sometimes I edit on my
laptop, other times on my desktop, and the two may not have talked to each other in between.
Initialize a Git repository and commit your ﬁles on one machine. Then on the other:
$ git clone other.computer:/path/to/files
to create a second copy of the ﬁles and Git repository. From now on,
$ git commit -a
$ git pull other.computer:/path/to/files HEAD
will pull in the state of the ﬁles on the other computer into the one you’re working on. If you’ve recently
made conﬂicting edits in the same ﬁle, Git will let you know and you should commit again after
resolving them.
3.2. Classic Source Control
Initialize a Git repository for your ﬁles:
$ git init
$ git add .
$ git commit -m "Initial commit"
On the central server, initialize a bare repository in some directory:
$ mkdir proj.git
$ cd proj.git
$ git --bare init
$ touch proj.git/git-daemon-export-ok
10

Chapter 3. Cloning Around
Start the Git daemon if necessary:
$ git daemon --detach
# it may already be running
For Git hosting services, follow the instructions to setup the initially empty Git repository. Typically one
ﬁlls in a form on a webpage.
Push your project to the central server with:
$ git push central.server/path/to/proj.git HEAD
To check out the source, a developer types:
$ git clone central.server/path/to/proj.git
After making changes, the developer saves changes locally:
$ git commit -a
To update to the latest version:
$ git pull
Any merge conﬂicts should be resolved then committed:
$ git commit -a
To check in local changes into the central repository:
$ git push
If the main server has new changes due to activity by other developers, the push fails, and the developer
should pull the latest version, resolve any merge conﬂicts, then try again.
Developers must have SSH access for the above pull and push commands. However, anyone can see the
source by typing:
$ git clone git://central.server/path/to/proj.git
The native git protocol is like HTTP: there is no authentication, so anyone can retrieve the project.
Accordingly, by default, pushing is forbidden via the git protocol.
11

Chapter 3. Cloning Around
3.3. Secret Source
For a closed-source project, omit the touch command, and ensure you never create a ﬁle named
git-daemon-export-ok. The repository can no longer be retrieved via the git protocol; only those
with SSH access can see it. If all your repos are closed, running the git daemon is unnecessary because
all communication occurs via SSH.
3.4. Bare repositories
A bare repository is so named because it has no working directory; it only contains ﬁles that are normally
hidden away in the .git subdirectory. In other words, it maintains the history of a project, and never
holds a snapshot of any given version.
A bare repository plays a role similar to that of the main server in a centralized version control system:
the home of your project. Developers clone your project from it, and push the latest ofﬁcial changes to it.
Typically it resides on a server that does little else but disseminate data. Development occurs in the
clones, so the home repository can do without a working directory.
Many Git commands fail on bare repositories unless the GIT_DIR environment variable is set to the
repository path, or the --bare option is supplied.
3.5. Push versus pull
Why did we introduce the push command, rather than rely on the familiar pull command? Firstly, pulling
fails on bare repositories: instead you must fetch, a command we later discuss. But even if we kept a
normal repository on the central server, pulling into it would still be cumbersome. We would have to
login to the server ﬁrst, and give the pull command the network address of the machine we’re pulling
from. Firewalls may interfere, and what if we have no shell access to the server in the ﬁrst place?
However, apart from this case, we discourage pushing into a repository, because confusion can ensue
when the destination has a working directory.
In short, while learning Git, only push when the target is a bare repository; otherwise pull.
3.6. Forking a Project
Sick of the way a project is being run? Think you could do a better job? Then on your server:
$ git clone git://main.server/path/to/files
12

Chapter 3. Cloning Around
Next, tell everyone about your fork of the project at your server.
At any later time, you can merge in the changes from the original project with:
$ git pull
3.7. Ultimate Backups
Want numerous tamper-proof geographically diverse redundant archives? If your project has many
developers, don’t do anything! Every clone of your code is effectively a backup. Not just of the current
state, but of your project’s entire history. Thanks to cryptographic hashing, if anyone’s clone becomes
corrupted, it will be spotted as soon as they try to communicate with others.
If your project is not so popular, ﬁnd as many servers as you can to host clones.
The truly paranoid should always write down the latest 20-byte SHA1 hash of the HEAD somewhere
safe. It has to be safe, not private. For example, publishing it in a newspaper would work well, because
it’s hard for an attacker to alter every copy of a newspaper.
3.8. Light-Speed Multitask
Say you want to work on several features in parallel. Then commit your project and run:
$ git clone . /some/new/directory
Thanks to hardlinking (http://en.wikipedia.org/wiki/Hard_link), local clones require less time and space
than a plain backup.
You can now work on two independent features simultaneously. For example, you can edit one clone
while the other is compiling. At any time, you can commit and pull changes from the other clone:
$ git pull /the/other/clone HEAD
3.9. Guerilla Version Control
Are you working on a project that uses some other version control system, and you sorely miss Git?
Then initialize a Git repository in your working directory:
$ git init
13

Chapter 3. Cloning Around
$ git add .
$ git commit -m "Initial commit"
then clone it:
$ git clone . /some/new/directory
Now go to the new directory and work here instead, using Git to your heart’s content. Once in a while,
you’ll want to sync with everyone else, in which case go to the original directory, sync using the other
version control system, and type:
$ git add .
$ git commit -m "Sync with everyone else"
Then go to the new directory and run:
$ git commit -a -m "Description of my changes"
$ git pull
The procedure for giving your changes to everyone else depends on the other version control system. The
new directory contains the ﬁles with your changes. Run whatever commands of the other version control
system are needed to upload them to the central repository.
Subversion, perhaps the best centralized version control system, is used by countless projects. The git
svn command automates the above for Subversion repositories, and can also be used to export a Git
project to a Subversion repository
(http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html).
3.10. Mercurial
Mercurial is a similar version control system that can almost seamlessly work in tandem with Git. With
the hg-git plugin, a Mercurial user can losslessly push to and pull from a Git repository.
Obtain the hg-git plugin with Git:
$ git clone git://github.com/schacon/hg-git.git
or Mercurial:
$ hg clone http://bitbucket.org/durin42/hg-git/
Sadly, I am unaware of an analogous plugin for Git. For this reason, I advocate Git over Mercurial for the
main repository, even if you prefer Mercurial. With a Mercurial project, usually a volunteer maintains a
14

Chapter 3. Cloning Around
parallel Git repository to accommodate Git users, whereas thanks to the hg-git plugin, a Git project
automatically accommodates Mercurial users.
Although the plugin can convert a Mercurial repository to a Git repository by pushing to an empty
repository, this job is easier with the hg-fast-export.sh script, available from:
$ git clone git://repo.or.cz/fast-export.git
To convert, in an empty directory:
$ git init
$ hg-fast-export.sh -r /hg/repo
after adding the script to your $PATH.
3.11. Bazaar
We brieﬂy mention Bazaar because it is the most popular free distributed version control system after Git
and Mercurial.
Bazaar has the advantage of hindsight, as it is relatively young; its designers could learn from mistakes
of the past, and sidestep minor historical warts. Additionally, its developers are mindful of portability
and interoperation with other version control systems.
A bzr-git plugin lets Bazaar users work with Git repositories to some extent. The tailor program
converts Bazaar repositories to Git repositories, and can do so incrementally, while bzr-fast-export
is well-suited for one-shot conversions.
3.12. Why I use Git
I originally chose Git because I heard it could manage the unimaginably unmanageable Linux kernel
source. I’ve never felt a need to switch. Git has served admirably, and I’ve yet to be bitten by its ﬂaws.
As I primarily use Linux, issues on other platforms are of no concern.
Also, I prefer C programs and bash scripts to executables such as Python scripts: there are fewer
dependencies, and I’m addicted to fast running times.
I did think about how Git could be improved, going so far as to write my own Git-like tool, but only as an
academic exercise. Had I completed my project, I would have stayed with Git anyway, as the gains are
too slight to justify using an oddball system.
15

Chapter 3. Cloning Around
Naturally, your needs and wants likely differ, and you may be better off with another system.
Nonetheless, you can’t go far wrong with Git.
16

Chapter 4. Branch Wizardry
Instant branching and merging are the most lethal of Git’s killer features.
Problem: External factors inevitably necessitate context switching. A severe bug manifests in the
released version without warning. The deadline for a certain feature is moved closer. A developer whose
help you need for a key section of the project is about to leave. In all cases, you must abruptly drop what
you are doing and focus on a completely different task.
Interrupting your train of thought can be detrimental to your productivity, and the more cumbersome it is
to switch contexts, the greater the loss. With centralized version control we must download a fresh
working copy from the central server. Distributed systems fare better, as we can clone the desired version
locally.
But cloning still entails copying the whole working directory as well as the entire history up to the given
point. Even though Git reduces the cost of this with ﬁle sharing and hard links, the project ﬁles
themselves must be recreated in their entirety in the new working directory.
Solution: Git has a better tool for these situations that is much faster and more space-efﬁcient than
cloning: git branch.
With this magic word, the ﬁles in your directory suddenly shapeshift from one version to another. This
transformation can do more than merely go back or forward in history. Your ﬁles can morph from the last
release to the experimental version to the current development version to your friend’s version and so on.
4.1. The Boss Key
Ever played one of those games where at the push of a button (“the boss key”), the screen would
instantly display a spreadsheet or something? So if the boss walked in the ofﬁce while you were playing
the game you could quickly hide it away?
In some directory:
$ echo "I’m smarter than my boss" > myfile.txt
$ git init
$ git add .
$ git commit -m "Initial commit"
We have created a Git repository that tracks one text ﬁle containing a certain message. Now type:
$ git checkout -b boss
# nothing seems to change after this
$ echo "My boss is smarter than me" > myfile.txt
17

Chapter 4. Branch Wizardry
$ git commit -a -m "Another commit"
It looks like we’ve just overwritten our ﬁle and committed it. But it’s an illusion. Type:
$ git checkout master
# switch to original version of the file
and hey presto! The text ﬁle is restored. And if the boss decides to snoop around this directory, type:
$ git checkout boss
# switch to version suitable for boss’ eyes
You can switch between the two versions of the ﬁle as much as you like, and commit to each
independently.
4.2. Dirty Work
Say you’re working on some feature, and for some reason, you need to go back three versions and
temporarily put in a few print statements to see how something works. Then:
$ git commit -a
$ git checkout HEAD~3
Now you can add ugly temporary code all over the place. You can even commit these changes. When
you’re done,
$ git checkout master
to return to your original work. Observe that any uncommitted changes are carried over.
What if you wanted to save the temporary changes after all? Easy:
$ git checkout -b dirty
and commit before switching back to the master branch. Whenever you want to return to the dirty
changes, simply type:
$ git checkout dirty
We touched upon this command in an earlier chapter, when discussing loading old states. At last we can
tell the whole story: the ﬁles change to the requested state, but we must leave the master branch. Any
commits made from now on take your ﬁles down a different road, which can be named later.
In other words, after checking out an old state, Git automatically puts you in a new, unnamed branch,
which can be named and saved with git checkout -b.
18

Chapter 4. Branch Wizardry
4.3. Quick Fixes
You’re in the middle of something when you are told to drop everything and ﬁx a newly discovered bug
in commit 1b6d...:
$ git commit -a
$ git checkout -b fixes 1b6d
Then once you’ve ﬁxed the bug:
$ git commit -a -m "Bug fixed"
$ git checkout master
and resume work on your original task. You can even merge in the freshly baked bugﬁx:
$ git merge fixes
4.4. Merging
With some version control systems, creating branches is easy but merging them back together is tough.
With Git, merging is so trivial that you might be unaware of it happening.
We actually encountered merging long ago. The pull command in fact fetches commits and then merges
them into your current branch. If you have no local changes, then the merge is a fast forward, a
degenerate case akin to fetching the latest version in a centralized version control system. But if you do
have local changes, Git will automatically merge, and report any conﬂicts.
Ordinarily, a commit has exactly one parent commit, namely, the previous commit. Merging branches
together produces a commit with at least two parents. This begs the question: what commit does
HEAD~10 really refer to? A commit could have multiple parents, so which one do we follow?
It turns out this notation chooses the ﬁrst parent every time. This is desirable because the current branch
becomes the ﬁrst parent during a merge; frequently you’re only concerned with the changes you made in
the current branch, as opposed to changes merged in from other branches.
You can refer to a speciﬁc parent with a caret. For example, to show the logs from the second parent:
$ git log HEAD^2
You may omit the number for the ﬁrst parent. For example, to show the differences with the ﬁrst parent:
$ git diff HEAD^
19

Chapter 4. Branch Wizardry
You can combine this notation with other types. For example:
$ git checkout 1b6d^^2~10 -b ancient
starts a new branch “ancient” representing the state 10 commits back from the second parent of the ﬁrst
parent of the commit starting with 1b6d.
4.5. Uninterrupted Workﬂow
Often in hardware projects, the second step of a plan must await the completion of the ﬁrst step. A car
undergoing repairs might sit idly in a garage until a particular part arrives from the factory. A prototype
might wait for a chip to be fabricated before construction can continue.
Software projects can be similar. The second part of a new feature may have to wait until the ﬁrst part
has been released and tested. Some projects require your code to be reviewed before accepting it, so you
might wait until the ﬁrst part is approved before starting the second part.
Thanks to painless branching and merging, we can bend the rules and work on Part II before Part I is
ofﬁcially ready. Suppose you have committed Part I and sent it for review. Let’s say you’re in the
master branch. Then branch off:
$ git checkout -b part2
Next, work on Part II, committing your changes along the way. To err is human, and often you’ll want to
go back and ﬁx something in Part I. If you’re lucky, or very good, you can skip these lines.
$ git checkout master
# Go back to Part I.
$ fix_problem
$ git commit -a
# Commit the fixes.
$ git checkout part2
# Go back to Part II.
$ git merge master
# Merge in those fixes.
Eventually, Part I is approved:
$ git checkout master
# Go back to Part I.
$ submit files
# Release to the world!
$ git merge part2
# Merge in Part II.
$ git branch -d part2
# Delete "part2" branch.
Now you’re in the master branch again, with Part II in the working directory.
It’s easy to extend this trick for any number of parts. It’s also easy to branch off retroactively: suppose
you belatedly realize you should have created a branch 7 commits ago. Then type:
20

Chapter 4. Branch Wizardry
$ git branch -m master part2
# Rename "master" branch to "part2".
$ git branch master HEAD~7
# Create new "master", 7 commits upstream.
The master branch now contains just Part I, and the part2 branch contains the rest. We are in the latter
branch; we created master without switching to it, because we want to continue work on part2. This is
unusual. Until now, we’ve been switching to branches immediately after creation, as in:
$ git checkout HEAD~7 -b master
# Create a branch, and switch to it.
4.6. Reorganizing a Medley
Perhaps you like to work on all aspects of a project in the same branch. You want to keep
works-in-progress to yourself and want others to see your commits only when they have been neatly
organized. Start a couple of branches:
$ git branch sanitized
# Create a branch for sanitized commits.
$ git checkout -b medley
# Create and switch to a branch to work in.
Next, work on anything: ﬁx bugs, add features, add temporary code, and so forth, committing often along
the way. Then:
$ git checkout sanitized
$ git cherry-pick medley^^
applies the grandparent of the head commit of the “medley” branch to the “sanitized” branch. With
appropriate cherry-picks you can construct a branch that contains only permanent code, and has related
commits grouped together.
4.7. Managing Branches
List all branches by typing:
$ git branch
By default, you start in a branch named “master”. Some advocate leaving the “master” branch untouched
and creating new branches for your own edits.
The -d and -m options allow you to delete and move (rename) branches. See git help branch.
The “master” branch is a useful custom. Others may assume that your repository has a branch with this
name, and that it contains the ofﬁcial version of your project. Although you can rename or obliterate the
21

Chapter 4. Branch Wizardry
“master” branch, you might as well respect this convention.
4.8. Temporary Branches
After a while you may realize you are creating short-lived branches frequently for similar reasons: every
other branch merely serves to save the current state so you can brieﬂy hop back to an older state to ﬁx a
high-priority bug or something.
It’s analogous to changing the TV channel temporarily to see what else is on. But instead of pushing a
couple of buttons, you have to create, check out, merge, and delete temporary branches. Luckily, Git has
a shortcut that is as convenient as a TV remote control:
$ git stash
This saves the current state in a temporary location (a stash) and restores the previous state. Your
working directory appears exactly as it was before you started editing, and you can ﬁx bugs, pull in
upstream changes, and so on. When you want to go back to the stashed state, type:
$ git stash apply
# You may need to resolve some conflicts.
You can have multiple stashes, and manipulate them in various ways. See git help stash. As you may
have guessed, Git maintains branches behind the scenes to perform this magic trick.
4.9. Work How You Want
You might wonder if branches are worth the bother. After all, clones are almost as fast, and you can
switch between them with cd instead of esoteric Git commands.
Consider web browsers. Why support multiple tabs as well as multiple windows? Because allowing both
accommodates a wide variety of styles. Some users like to keep only one browser window open, and use
tabs for multiple webpages. Others might insist on the other extreme: multiple windows with no tabs
anywhere. Others still prefer something in between.
Branching is like tabs for your working directory, and cloning is like opening a new browser window.
These operations are fast and local, so why not experiment to ﬁnd the combination that best suits you?
Git lets you work exactly how you want.
22

Chapter 5. Lessons of History
A consequence of Git’s distributed nature is that history can be edited easily. But if you tamper with the
past, take care: only rewrite that part of history which you alone possess. Just as nations forever argue
over who committed what atrocity, if someone else has a clone whose version of history differs to yours,
you will have trouble reconciling when your trees interact.
Some developers strongly feel history should be immutable, warts and all. Others feel trees should be
made presentable before they are unleashed in public. Git accommodates both viewpoints. Like cloning,
branching, and merging, rewriting history is simply another power Git gives you. It is up to you to use it
wisely.
5.1. I Stand Corrected
Did you just commit, but wish you had typed a different message? Then run:
$ git commit --amend
to change the last message. Realized you forgot to add a ﬁle? Run git add to add it, and then run the
above command.
Want to include a few more edits in that last commit? Then make those edits and run:
$ git commit --amend -a
5.2. . . . And Then Some
Suppose the previous problem is ten times worse. After a lengthy session you’ve made a bunch of
commits. But you’re not quite happy with the way they’re organized, and some of those commit
messages could use rewording. Then type:
$ git rebase -i HEAD~10
and the last 10 commits will appear in your favourite $EDITOR. A sample excerpt:
pick 5c6eb73 Added repo.or.cz link
pick a311a64 Reordered analogies in "Work How You Want"
pick 100834f Added push target to Makefile
23

Chapter 5. Lessons of History
Older commits precede newer commits in this list, unlike the log command. Here, 5c6eb73 is the oldest
commit, and 100834f is the newest. Then:
• Remove commits by deleting lines. Like the revert command, but off the record: it will be as if the
commit never existed.
• Reorder commits by reordering lines.
• Replace pick with:
•
edit to mark a commit for amending.
•
reword to change the log message.
•
squash to merge a commit with the previous one.
•
fixup to merge a commit with the previous one and discard the log message.
For example, we might replace the second pick with squash:
pick 5c6eb73 Added repo.or.cz link
squash a311a64 Reordered analogies in "Work How You Want"
pick 100834f Added push target to Makefile
After we save and quit, Git merges a311a64 into 5c6eb73. Thus squash merges into the next commit up:
think “squash up”.
Git then combines their log messages and presents them for editing. The command ﬁxup skips this step;
the squashed log message is simply discarded.
If you marked a commit with edit, Git returns you to the past, to the oldest such commit. You can amend
the old commit as described in the previous section, and even create new commits that belong here. Once
you’re pleased with the “retcon”, go forward in time by running:
$ git rebase --continue
Git replays commits until the next edit, or to the present if none remain.
You can also abandon the rebase with:
$ git rebase --abort
So commit early and commit often: you can tidy up later with rebase.
24

Chapter 5. Lessons of History
5.3. Local Changes Last
You’re working on an active project. You make some local commits over time, and then you sync with
the ofﬁcial tree with a merge. This cycle repeats itself a few times before you’re ready to push to the
central tree.
But now the history in your local Git clone is a messy jumble of your changes and the ofﬁcial changes.
You’d prefer to see all your changes in one contiguous section, and after all the ofﬁcial changes.
This is a job for git rebase as described above. In many cases you can use the --onto ﬂag and avoid
interaction.
Also see git help rebase for detailed examples of this amazing command. You can split commits. You
can even rearrange branches of a tree.
Take care: rebase is a powerful command. For complicated rebases, ﬁrst make a backup with git clone.
5.4. Rewriting History
Occasionally, you need the source control equivalent of airbrushing people out of ofﬁcial photos, erasing
them from history in a Stalinesque fashion. For example, suppose we intend to release a project, but it
involves a ﬁle that should be kept private for some reason. Perhaps I left my credit card number in a text
ﬁle and accidentally added it to the project. Deleting the ﬁle is insufﬁcient, for the ﬁle can be accessed
from older commits. We must remove the ﬁle from all commits:
$ git filter-branch --tree-filter ’rm top/secret/file’ HEAD
See git help ﬁlter-branch, which discusses this example and gives a faster method. In general,
ﬁlter-branch lets you alter large sections of history with a single command.
Afterwards, the .git/refs/original directory describes the state of affairs before the operation.
Check the ﬁlter-branch command did what you wanted, then delete this directory if you wish to run more
ﬁlter-branch commands.
Lastly, replace clones of your project with your revised version if you want to interact with them later.
5.5. Making History
Want to migrate a project to Git? If it’s managed with one of the more well-known systems, then chances
25

Chapter 5. Lessons of History
are someone has already written a script to export the whole history to Git.
Otherwise, look up git fast-import, which reads text input in a speciﬁc format to create Git history from
scratch. Typically a script using this command is hastily cobbled together and run once, migrating the
project in a single shot.
As an example, paste the following listing into temporary ﬁle, such as /tmp/history:
commit refs/heads/master
committer Alice <alice@example.com> Thu, 01 Jan 1970 00:00:00 +0000
data <<EOT
Initial commit.
EOT
M 100644 inline hello.c
data <<EOT
#include <stdio.h>
int main() {
printf("Hello, world!\n");
return 0;
}
EOT
commit refs/heads/master
committer Bob <bob@example.com> Tue, 14 Mar 2000 01:59:26 -0800
data <<EOT
Replace printf() with write().
EOT
M 100644 inline hello.c
data <<EOT
#include <unistd.h>
int main() {
write(1, "Hello, world!\n", 14);
return 0;
}
EOT
Then create a Git repository from this temporary ﬁle by typing:
$ mkdir project; cd project; git init
$ git fast-import --date-format=rfc2822 < /tmp/history
You can checkout the latest version of the project with:
$ git checkout master .
26

Chapter 5. Lessons of History
The git fast-export command converts any repository to the git fast-import format, whose output you
can study for writing exporters, and also to transport repositories in a human-readable format. Indeed,
these commands can send repositories of text ﬁles over text-only channels.
5.6. Where Did It All Go Wrong?
You’ve just discovered a broken feature in your program which you know for sure was working a few
months ago. Argh! Where did this bug come from? If only you had been testing the feature as you
developed.
It’s too late for that now. However, provided you’ve been committing often, Git can pinpoint the
problem:
$ git bisect start
$ git bisect bad HEAD
$ git bisect good 1b6d
Git checks out a state halfway in between. Test the feature, and if it’s still broken:
$ git bisect bad
If not, replace "bad" with "good". Git again transports you to a state halfway between the known good
and bad versions, narrowing down the possibilities. After a few iterations, this binary search will lead
you to the commit that caused the trouble. Once you’ve ﬁnished your investigation, return to your
original state by typing:
$ git bisect reset
Instead of testing every change by hand, automate the search by running:
$ git bisect run my_script
Git uses the return value of the given command, typically a one-off script, to decide whether a change is
good or bad: the command should exit with code 0 when good, 125 when the change should be skipped,
and anything else between 1 and 127 if it is bad. A negative return value aborts the bisect.
You can do much more: the help page explains how to visualize bisects, examine or replay the bisect log,
and eliminate known innocent changes for a speedier search.
5.7. Who Made It All Go Wrong?
Like many other version control systems, Git has a blame command:
27

Chapter 5. Lessons of History
$ git blame bug.c
which annotates every line in the given ﬁle showing who last changed it, and when. Unlike many other
version control systems, this operation works ofﬂine, reading only from local disk.
5.8. Personal Experience
In a centralized version control system, history modiﬁcation is a difﬁcult operation, and only available to
administrators. Cloning, branching, and merging are impossible without network communication. So are
basic operations such as browsing history, or committing a change. In some systems, users require
network connectivity just to view their own changes or open a ﬁle for editing.
Centralized systems preclude working ofﬂine, and need more expensive network infrastructure,
especially as the number of developers grows. Most importantly, all operations are slower to some
degree, usually to the point where users shun advanced commands unless absolutely necessary. In
extreme cases this is true of even the most basic commands. When users must run slow commands,
productivity suffers because of an interrupted work ﬂow.
I experienced these phenomena ﬁrst-hand. Git was the ﬁrst version control system I used. I quickly grew
accustomed to it, taking many features for granted. I simply assumed other systems were similar:
choosing a version control system ought to be no different from choosing a text editor or web browser.
I was shocked when later forced to use a centralized system. A ﬂaky internet connection matters little
with Git, but makes development unbearable when it needs to be as reliable as local disk. Additionally, I
found myself conditioned to avoid certain commands because of the latencies involved, which ultimately
prevented me from following my desired work ﬂow.
When I had to run a slow command, the interruption to my train of thought dealt a disproportionate
amount of damage. While waiting for server communication to complete, I’d do something else to pass
the time, such as check email or write documentation. By the time I returned to the original task, the
command had ﬁnished long ago, and I would waste more time trying to remember what I was doing.
Humans are bad at context switching.
There was also an interesting tragedy-of-the-commons effect: anticipating network congestion,
individuals would consume more bandwidth than necessary on various operations in an attempt to reduce
future delays. The combined efforts intensiﬁed congestion, encouraging individuals to consume even
more bandwidth next time to avoid even longer delays.
28

Chapter 6. Multiplayer Git
Initially I used Git on a private project where I was the sole developer. Amongst the commands related to
Git’s distributed nature, I needed only pull and clone so could I keep the same project in different places.
Later I wanted to publish my code with Git, and include changes from contributors. I had to learn how to
manage projects with multiple developers from all over the world. Fortunately, this is Git’s forte, and
arguably its raison d’être.
6.1. Who Am I?
Every commit has an author name and email, which is shown by git log. By default, Git uses system
settings to populate these ﬁelds. To set them explicitly, type:
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
Omit the global ﬂag to set these options only for the current repository.
6.2. Git Over SSH, HTTP
Suppose you have SSH access to a web server, but Git is not installed. Though less efﬁcient than its
native protocol, Git can communicate over HTTP.
Download, compile and install Git in your account, and create a repository in your web directory:
$ GIT_DIR=proj.git git init
$ cd proj.git
$ git --bare update-server-info
$ cp hooks/post-update.sample hooks/post-update
For older versions of Git, the copy command fails and you should run:
$ chmod a+x hooks/post-update
Now you can publish your latest edits via SSH from any clone:
$ git push web.server:/path/to/proj.git master
and anybody can get your project with:
29

Chapter 6. Multiplayer Git
$ git clone http://web.server/proj.git
6.3. Git Over Anything
Want to synchronize repositories without servers, or even a network connection? Need to improvise
during an emergency? We’ve seen git fast-export and git fast-import can convert repositories to a
single ﬁle and back. We could shuttle such ﬁles back and forth to transport git repositories over any
medium, but a more efﬁcient tool is git bundle.
The sender creates a bundle:
$ git bundle create somefile HEAD
then transports the bundle, somefile, to the other party somehow: email, thumb drive, an xxd printout
and an OCR scanner, reading bits over the phone, smoke signals, etc. The receiver retrieves commits
from the bundle by typing:
$ git pull somefile
The receiver can even do this from an empty repository. Despite its size, somefile contains the entire
original git repository.
In larger projects, eliminate waste by bundling only changes the other repository lacks. For example,
suppose the commit “1b6d...” is the most recent commit shared by both parties:
$ git bundle create somefile HEAD ^1b6d
If done frequently, one could easily forget which commit was last sent. The help page suggests using tags
to solve this. Namely, after you send a bundle, type:
$ git tag -f lastbundle HEAD
and create new refresher bundles with:
$ git bundle create newbundle HEAD ^lastbundle
6.4. Patches: The Global Currency
Patches are text representations of your changes that can be easily understood by computers and humans
alike. This gives them universal appeal. You can email a patch to developers no matter what version
control system they’re using. As long as your audience can read their email, they can see your edits.
30

Chapter 6. Multiplayer Git
Similarly, on your side, all you require is an email account: there’s no need to setup an online Git
repository.
Recall from the ﬁrst chapter:
$ git diff 1b6d > my.patch
outputs a patch which can be pasted into an email for discussion. In a Git repository, type:
$ git apply < my.patch
to apply the patch.
In more formal settings, when author names and perhaps signatures should be recorded, generate the
corresponding patches past a certain point by typing:
$ git format-patch 1b6d
The resulting ﬁles can be given to git-send-email, or sent by hand. You can also specify a range of
commits:
$ git format-patch 1b6d..HEAD^^
On the receiving end, save an email to a ﬁle, then type:
$ git am < email.txt
This applies the incoming patch and also creates a commit, including information such as the author.
With a browser email client, you may need to click a button to see the email in its raw original form
before saving the patch to a ﬁle.
There are slight differences for mbox-based email clients, but if you use one of these, you’re probably
the sort of person who can ﬁgure them out easily without reading tutorials!
6.5. Sorry, We’ve Moved
After cloning a repository, running git push or git pull will automatically push to or pull from the
original URL. How does Git do this? The secret lies in conﬁg options created with the clone. Let’s take a
peek:
$ git config --list
31

Chapter 6. Multiplayer Git
The remote.origin.url option controls the source URL; “origin” is a nickname given to the source
repository. As with the “master” branch convention, we may change or delete this nickname but there is
usually no reason for doing so.
If the original repository moves, we can update the URL via:
$ git config remote.origin.url git://new.url/proj.git
The branch.master.merge option speciﬁes the default remote branch in a git pull. During the initial
clone, it is set to the current branch of the source repository, so even if the HEAD of the source
repository subsequently moves to a different branch, a later pull will faithfully follow the original branch.
This option only applies to the repository we ﬁrst cloned from, which is recorded in the option
branch.master.remote. If we pull in from other repositories we must explicitly state which branch
we want:
$ git pull git://example.com/other.git master
The above explains why some of our earlier push and pull examples had no arguments.
6.6. Remote Branches
When you clone a repository, you also clone all its branches. You may not have noticed this because Git
hides them away: you must ask for them speciﬁcally. This prevents branches in the remote repository
from interfering with your branches, and also makes Git easier for beginners.
List the remote branches with:
$ git branch -r
You should see something like:
origin/HEAD
origin/master
origin/experimental
These represent branches and the HEAD of the remote repository, and can be used in regular Git
commands. For example, suppose you have made many commits, and wish to compare against the last
fetched version. You could search through the logs for the appropriate SHA1 hash, but it’s much easier to
type:
$ git diff origin/HEAD
32

Chapter 6. Multiplayer Git
Or you can see what the “experimental” branch has been up to:
$ git log origin/experimental
6.7. Multiple Remotes
Suppose two other developers are working on our project, and we want to keep tabs on both. We can
follow more than one repository at a time with:
$ git remote add other git://example.com/some_repo.git
$ git pull other some_branch
Now we have merged in a branch from the second repository, and we have easy access to all branches of
all repositories:
$ git diff origin/experimental^ other/some_branch~5
But what if we just want to compare their changes without affecting our own work? In other words, we
want to examine their branches without having their changes invade our working directory. Then rather
than pull, run:
$ git fetch
# Fetch from origin, the default.
$ git fetch other
# Fetch from the second programmer.
This just fetches histories. Although the working directory remains untouched, we can refer to any
branch of any repository in a Git command because we now possess a local copy.
Recall that behind the scenes, a pull is simply a fetch then merge. Usually we pull because we want to
merge the latest commit after a fetch; this situation is a notable exception.
See git help remote for how to remove remote repositories, ignore certain branches, and more.
6.8. My Preferences
For my projects, I like contributors to prepare repositories from which I can pull. Some Git hosting
services let you host your own fork of a project with the click of a button.
After I fetch a tree, I run Git commands to navigate and examine the changes, which ideally are
well-organized and well-described. I merge my own changes, and perhaps make further edits. Once
satisﬁed, I push to the main repository.
33

Chapter 6. Multiplayer Git
Though I infrequently receive contributions, I believe this approach scales well. See this blog post by
Linus Torvalds (http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html).
Staying in the Git world is slightly more convenient than patch ﬁles, as it saves me from converting them
to Git commits. Furthermore, Git handles details such as recording the author’s name and email address,
as well as the time and date, and asks the author to describe their own change.
34

Chapter 7. Git Grandmastery
By now, you should be able to navigate the git help pages and understand almost everything. However,
pinpointing the exact command required to solve a given problem can be tedious. Perhaps I can save you
some time: below are some recipes I have needed in the past.
7.1. Source Releases
For my projects, Git tracks exactly the ﬁles I’d like to archive and release to users. To create a tarball of
the source code, I run:
$ git archive --format=tar --prefix=proj-1.2.3/ HEAD
7.2. Commit What Changed
Telling Git when you’ve added, deleted and renamed ﬁles is troublesome for certain projects. Instead,
you can type:
$ git add .
$ git add -u
Git will look at the ﬁles in the current directory and work out the details by itself. Instead of the second
add command, run git commit -a if you also intend to commit at this time. See git help ignore for
how to specify ﬁles that should be ignored.
You can perform the above in a single pass with:
$ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove
The -z and -0 options prevent ill side-effects from ﬁlenames containing strange characters. As this
command adds ignored ﬁles, you may want to use the -x or -X option.
7.3. My Commit Is Too Big!
Have you neglected to commit for too long? Been coding furiously and forgotten about source control
until now? Made a series of unrelated changes, because that’s your style?
No worries. Run:
35

Chapter 7. Git Grandmastery
$ git add -p
For each edit you made, Git will show you the hunk of code that was changed, and ask if it should be part
of the next commit. Answer with "y" or "n". You have other options, such as postponing the decision;
type "?" to learn more.
Once you’re satisﬁed, type
$ git commit
to commit precisely the changes you selected (the staged changes). Make sure you omit the -a option,
otherwise Git will commit all the edits.
What if you’ve edited many ﬁles in many places? Reviewing each change one by one becomes
frustratingly mind-numbing. In this case, use git add -i, whose interface is less straightforward, but more
ﬂexible. With a few keystrokes, you can stage or unstage several ﬁles at a time, or review and select
changes in particular ﬁles only. Alternatively, run git commit --interactive which automatically commits
after you’re done.
7.4. The Index: Git’s Staging Area
So far we have avoided Git’s famous index, but we must now confront it to explain the above. The index
is a temporary staging area. Git seldom shuttles data directly between your project and its history. Rather,
Git ﬁrst writes data to the index, and then copies the data in the index to its ﬁnal destination.
For example, commit -a is really a two-step process. The ﬁrst step places a snapshot of the current state
of every tracked ﬁle into the index. The second step permanently records the snapshot now in the index.
Committing without the -a option only performs the second step, and only makes sense after running
commands that somehow change the index, such as git add.
Usually we can ignore the index and pretend we are reading straight from and writing straight to the
history. On this occasion, we want ﬁner control, so we manipulate the index. We place a snapshot of
some, but not all, of our changes into the index, and then permanently record this carefully rigged
snapshot.
7.5. Don’t Lose Your HEAD
The HEAD tag is like a cursor that normally points at the latest commit, advancing with each new
commit. Some Git commands let you move it. For example:
$ git reset HEAD~3
36

Chapter 7. Git Grandmastery
will move the HEAD three commits back. Thus all Git commands now act as if you hadn’t made those
last three commits, while your ﬁles remain in the present. See the help page for some applications.
But how can you go back to the future? The past commits know nothing of the future.
If you have the SHA1 of the original HEAD then:
$ git reset 1b6d
But suppose you never took it down? Don’t worry: for commands like these, Git saves the original
HEAD as a tag called ORIG_HEAD, and you can return safe and sound with:
$ git reset ORIG_HEAD
7.6. HEAD-hunting
Perhaps ORIG_HEAD isn’t enough. Perhaps you’ve just realized you made a monumental mistake and
you need to go back to an ancient commit in a long-forgotten branch.
By default, Git keeps a commit for at least two weeks, even if you ordered Git to destroy the branch
containing it. The trouble is ﬁnding the appropriate hash. You could look at all the hash values in
.git/objects and use trial and error to ﬁnd the one you want. But there’s a much easier way.
Git records every hash of a commit it computes in .git/logs. The subdirectory refs contains the
history of all activity on all branches, while the ﬁle HEAD shows every hash value it has ever taken. The
latter can be used to ﬁnd hashes of commits on branches that have been accidentally lopped off.
The reﬂog command provides a friendly interface to these log ﬁles. Try
$ git reflog
Instead of cutting and pasting hashes from the reﬂog, try:
$ git checkout "@{10 minutes ago}"
Or checkout the 5th-last visited commit via:
$ git checkout "@{5}"
See the “Specifying Revisions” section of git help rev-parse for more.
37

Chapter 7. Git Grandmastery
You may wish to conﬁgure a longer grace period for doomed commits. For example:
$ git config gc.pruneexpire "30 days"
means a deleted commit will only be permanently lost once 30 days have passed and git gc is run.
You may also wish to disable automatic invocations of git gc:
$ git config gc.auto 0
in which case commits will only be deleted when you run git gc manually.
7.7. Building On Git
In true UNIX fashion, Git’s design allows it to be easily used as a low-level component of other
programs, such as GUI and web interfaces, alternative command-line interfaces, patch managements
tools, importing and conversion tools and so on. In fact, some Git commands are themselves scripts
standing on the shoulders of giants. With a little tinkering, you can customize Git to suit your
preferences.
One easy trick is to use built-in Git aliases to shorten your most frequently used commands:
$ git config --global alias.co checkout
$ git config --global --get-regexp alias
# display current aliases
alias.co checkout
$ git co foo
# same as ’git checkout foo’
Another is to print the current branch in the prompt, or window title. Invoking
$ git symbolic-ref HEAD
shows the current branch name. In practice, you most likely want to remove the "refs/heads/" and ignore
errors:
$ git symbolic-ref HEAD 2> /dev/null | cut -b 12-
The contrib subdirectory is a treasure trove of tools built on Git. In time, some of them may be
promoted to ofﬁcial commands. On Debian and Ubuntu, this directory lives at
/usr/share/doc/git-core/contrib.
One popular resident is workdir/git-new-workdir. Via clever symlinking, this script creates a new
working directory whose history is shared with the original repository:
$ git-new-workdir an/existing/repo new/directory
38

Chapter 7. Git Grandmastery
The new directory and the ﬁles within can be thought of as a clone, except since the history is shared, the
two trees automatically stay in sync. There’s no need to merge, push, or pull.
7.8. Daring Stunts
These days, Git makes it difﬁcult for the user to accidentally destroy data. But if you know what you are
doing, you can override safeguards for common commands.
Checkout: Uncommitted changes cause checkout to fail. To destroy your changes, and checkout a given
commit anyway, use the force ﬂag:
$ git checkout -f HEAD^
On the other hand, if you specify particular paths for checkout, then there are no safety checks. The
supplied paths are quietly overwritten. Take care if you use checkout in this manner.
Reset: Reset also fails in the presence of uncommitted changes. To force it through, run:
$ git reset --hard 1b6d
Branch: Deleting branches fails if this causes changes to be lost. To force a deletion, type:
$ git branch -D dead_branch
# instead of -d
Similarly, attempting to overwrite a branch via a move fails if data loss would ensue. To force a branch
move, type:
$ git branch -M source target
# instead of -m
Unlike checkout and reset, these two commands defer data destruction. The changes are still stored in the
.git subdirectory, and can be retrieved by recovering the appropriate hash from .git/logs (see
"HEAD-hunting" above). By default, they will be kept for at least two weeks.
Clean: Some git commands refuse to proceed because they’re worried about clobbering untracked ﬁles.
If you’re certain that all untracked ﬁles and directories are expendable, then delete them mercilessly with:
$ git clean -f -d
Next time, that pesky command will work!
39

Chapter 7. Git Grandmastery
7.9. Preventing Bad Commits
Stupid mistakes pollute my repositories. Most frightening are missing ﬁles due to a forgotten git add.
Lesser transgressions are trailing whitespace and unresolved merge conﬂicts: though harmless, I wish
these never appeared on the public record.
If only I had bought idiot insurance by using a hook to alert me about these problems:
$ cd .git/hooks
$ cp pre-commit.sample pre-commit
# Older Git versions: chmod +x pre-commit
Now Git aborts a commit if useless whitespace or unresolved merge conﬂicts are detected.
For this guide, I eventually added the following to the beginning of the pre-commit hook to guard
against absent-mindedness:
if git ls-files -o | grep ’\.txt$’; then
echo FAIL! Untracked .txt files.
exit 1
fi
Several git operations support hooks; see git help hooks. We activated the sample post-update hook
earlier when discussing Git over HTTP. This runs whenever the head moves. The sample post-update
script updates ﬁles Git needs for communication over Git-agnostic transports such as HTTP.
40

Chapter 8. Secrets Revealed
We take a peek under the hood and explain how Git performs its miracles. I will skimp over details. For
in-depth descriptions refer to the user manual (http://schacon.github.com/git/user-manual.html).
8.1. Invisibility
How can Git be so unobtrusive? Aside from occasional commits and merges, you can work as if you
were unaware that version control exists. That is, until you need it, and that’s when you’re glad Git was
watching over you the whole time.
Other version control systems force you to constantly struggle with red tape and bureaucracy.
Permissions of ﬁles may be read-only unless you explicitly tell a central server which ﬁles you intend to
edit. The most basic commands may slow to a crawl as the number of users increases. Work grinds to a
halt when the network or the central server goes down.
In contrast, Git simply keeps the history of your project in the .git directory in your working directory.
This is your own copy of the history, so you can stay ofﬂine until you want to communicate with others.
You have total control over the fate of your ﬁles because Git can easily recreate a saved state from .git
at any time.
8.2. Integrity
Most people associate cryptography with keeping information secret, but another equally important goal
is keeping information safe. Proper use of cryptographic hash functions can prevent accidental or
malicious data corruption.
A SHA1 hash can be thought of as a unique 160-bit ID number for every string of bytes you’ll encounter
in your life. Actually more than that: every string of bytes that any human will ever use over many
lifetimes.
As a SHA1 hash is itself a string of bytes, we can hash strings of bytes containing other hashes. This
simple observation is surprisingly useful: look up hash chains. We’ll later see how Git uses it to
efﬁciently guarantee data integrity.
Brieﬂy, Git keeps your data in the .git/objects subdirectory, where instead of normal ﬁlenames,
you’ll ﬁnd only IDs. By using IDs as ﬁlenames, as well as a few lockﬁles and timestamping tricks, Git
transforms any humble ﬁlesystem into an efﬁcient and robust database.
41

Chapter 8. Secrets Revealed
8.3. Intelligence
How does Git know you renamed a ﬁle, even though you never mentioned the fact explicitly? Sure, you
may have run git mv, but that is exactly the same as a git rm followed by a git add.
Git heuristically ferrets out renames and copies between successive versions. In fact, it can detect chunks
of code being moved or copied around between ﬁles! Though it cannot cover all cases, it does a decent
job, and this feature is always improving. If it fails to work for you, try options enabling more expensive
copy detection, and consider upgrading.
8.4. Indexing
For every tracked ﬁle, Git records information such as its size, creation time and last modiﬁcation time in
a ﬁle known as the index. To determine whether a ﬁle has changed, Git compares its current stats with
those cached in the index. If they match, then Git can skip reading the ﬁle again.
Since stat calls are considerably faster than ﬁle reads, if you only edit a few ﬁles, Git can update its state
in almost no time.
We stated earlier that the index is a staging area. Why is a bunch of ﬁle stats a staging area? Because the
add command puts ﬁles into Git’s database and updates these stats, while the commit command, without
options, creates a commit based only on these stats and the ﬁles already in the database.
8.5. Git’s Origins
This Linux Kernel Mailing List post (http://lkml.org/lkml/2005/4/6/121) describes the chain of events
that led to Git. The entire thread is a fascinating archaeological site for Git historians.
8.6. The Object Database
Every version of your data is kept in the object database, which lives in the subdirectory
.git/objects; the other residents of .git/ hold lesser data: the index, branch names, tags,
conﬁguration options, logs, the current location of the head commit, and so on. The object database is
elementary yet elegant, and the source of Git’s power.
Each ﬁle within .git/objects is an object. There are 3 kinds of objects that concern us: blob objects,
tree objects, and commit objects.
42

Chapter 8. Secrets Revealed
8.7. Blobs
First, a magic trick. Pick a ﬁlename, any ﬁlename. In an empty directory:
$ echo sweet > YOUR_FILENAME
$ git init
$ git add .
$ find .git/objects -type f
You’ll see .git/objects/aa/823728ea7d592acc69b36875a482cdf3fd5c8d.
How do I know this without knowing the ﬁlename? It’s because the SHA1 hash of:
"blob" SP "6" NUL "sweet" LF
is aa823728ea7d592acc69b36875a482cdf3fd5c8d, where SP is a space, NUL is a zero byte and LF is a
linefeed. You can verify this by typing:
$ printf "blob 6\000sweet\n" | sha1sum
Git is content-addressable: ﬁles are not stored according to their ﬁlename, but rather by the hash of the
data they contain, in a ﬁle we call a blob object. We can think of the hash as a unique ID for a ﬁle’s
contents, so in a sense we are addressing ﬁles by their content. The initial blob 6 is merely a header
consisting of the object type and its length in bytes; it simpliﬁes internal bookkeeping.
Thus I could easily predict what you would see. The ﬁle’s name is irrelevant: only the data inside is used
to construct the blob object.
You may be wondering what happens to identical ﬁles. Try adding copies of your ﬁle, with any ﬁlenames
whatsoever. The contents of .git/objects stay the same no matter how many you add. Git only stores
the data once.
By the way, the ﬁles within .git/objects are compressed with zlib so you should not stare at them
directly. Filter them through zpipe -d (http://www.zlib.net/zpipe.c), or type:
$ git cat-file -p aa823728ea7d592acc69b36875a482cdf3fd5c8d
which pretty-prints the given object.
8.8. Trees
But where are the ﬁlenames? They must be stored somewhere at some stage. Git gets around to the
43

Chapter 8. Secrets Revealed
ﬁlenames during a commit:
$ git commit
# Type some message.
$ find .git/objects -type f
You should now see 3 objects. This time I cannot tell you what the 2 new ﬁles are, as it partly depends on
the ﬁlename you picked. We’ll proceed assuming you chose “rose”. If you didn’t, you can rewrite history
to make it look like you did:
$ git filter-branch --tree-filter ’mv YOUR_FILENAME rose’
$ find .git/objects -type f
Now you should see the ﬁle .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9,
because this is the SHA1 hash of its contents:
"tree" SP "32" NUL "100644 rose" NUL 0xaa823728ea7d592acc69b36875a482cdf3fd5c8d
Check this ﬁle does indeed contain the above by typing:
$ echo 05b217bb859794d08bb9e4f7f04cbda4b207fbe9 | git cat-file --batch
With zpipe, it’s easy to verify the hash:
$ zpipe -d < .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9 | sha1sum
Hash veriﬁcation is trickier via cat-ﬁle because its output contains more than the raw uncompressed
object ﬁle.
This ﬁle is a tree object: a list of tuples consisting of a ﬁle type, a ﬁlename, and a hash. In our example,
the ﬁle type is 100644, which means ‘rose‘ is a normal ﬁle, and the hash is the blob object that contains
the contents of ‘rose’. Other possible ﬁle types are executables, symlinks or directories. In the last case,
the hash points to a tree object.
If you ran ﬁlter-branch, you’ll have old objects you no longer need. Although they will be jettisoned
automatically once the grace period expires, we’ll delete them now to make our toy example easier to
follow:
$ rm -r .git/refs/original
$ git reflog expire --expire=now --all
$ git prune
For real projects you should typically avoid commands like this, as you are destroying backups. If you
want a clean repository, it is usually best to make a fresh clone. Also, take care when directly
manipulating .git: what if a Git command is running at the same time, or a sudden power outage
occurs? In general, refs should be deleted with git update-ref -d, though usually it’s safe to remove
refs/original by hand.
44

Chapter 8. Secrets Revealed
8.9. Commits
We’ve explained 2 of the 3 objects. The third is a commit object. Its contents depend on the commit
message as well as the date and time it was created. To match what we have here, we’ll have to tweak it a
little:
$ git commit --amend -m Shakespeare
# Change the commit message.
$ git filter-branch --env-filter ’export
GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
GIT_AUTHOR_NAME="Alice"
GIT_AUTHOR_EMAIL="alice@example.com"
GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
GIT_COMMITTER_NAME="Bob"
GIT_COMMITTER_EMAIL="bob@example.com"’
# Rig timestamps and authors.
$ find .git/objects -type f
You should now see .git/objects/49/993fe130c4b3bf24857a15d7969c396b7bc187 which is
the SHA1 hash of its contents:
"commit 158" NUL
"tree 05b217bb859794d08bb9e4f7f04cbda4b207fbe9" LF
"author Alice <alice@example.com> 1234567890 -0800" LF
"committer Bob <bob@example.com> 1234567890 -0800" LF
LF
"Shakespeare" LF
As before, you can run zpipe or cat-ﬁle to see for yourself.
This is the ﬁrst commit, so there are no parent commits, but later commits will always contain at least
one line identifying a parent commit.
8.10. Indistinguishable From Magic
Git’s secrets seem too simple. It looks like you could mix together a few shell scripts and add a dash of C
code to cook it up in a matter of hours: a melange of basic ﬁlesystem operations and SHA1 hashing,
garnished with lock ﬁles and fsyncs for robustness. In fact, this accurately describes the earliest versions
of Git. Nonetheless, apart from ingenious packing tricks to save space, and ingenious indexing tricks to
save time, we now know how Git deftly changes a ﬁlesystem into a database perfect for version control.
For example, if any ﬁle within the object database is corrupted by a disk error, then its hash will no longer
match, alerting us to the problem. By hashing hashes of other objects, we maintain integrity at all levels.
Commits are atomic, that is, a commit can never only partially record changes: we can only compute the
hash of a commit and store it in the database after we already have stored all relevant trees, blobs and
parent commits. The object database is immune to unexpected interruptions such as power outages.
45

Chapter 8. Secrets Revealed
We defeat even the most devious adversaries. Suppose somebody attempts to stealthily modify the
contents of a ﬁle in an ancient version of a project. To keep the object database looking healthy, they
must also change the hash of the corresponding blob object since it’s now a different string of bytes. This
means they’ll have to change the hash of any tree object referencing the ﬁle, and in turn change the hash
of all commit objects involving such a tree, in addition to the hashes of all the descendants of these
commits. This implies the hash of the ofﬁcial head differs to that of the bad repository. By following the
trail of mismatching hashes we can pinpoint the mutilated ﬁle, as well as the commit where it was ﬁrst
corrupted.
In short, so long as the 20 bytes representing the last commit are safe, it’s impossible to tamper with a
Git repository.
What about Git’s famous features? Branching? Merging? Tags? Mere details. The current head is kept in
the ﬁle .git/HEAD, which contains a hash of a commit object. The hash gets updated during a commit
as well as many other commands. Branches are almost the same: they are ﬁles in .git/refs/heads.
Tags too: they live in .git/refs/tags but they are updated by a different set of commands.
46

Appendix A. Git Shortcomings
There are some Git issues I’ve swept under the carpet. Some can be handled easily with scripts and
hooks, some require reorganizing or redeﬁning the project, and for the few remaining annoyances, one
will just have to wait. Or better yet, pitch in and help!
A.1. SHA1 Weaknesses
As time passes, cryptographers discover more and more SHA1 weaknesses. Already, ﬁnding hash
collisions is feasible for well-funded organizations. Within years, perhaps even a typical PC will have
enough computing power to silently corrupt a Git repository.
Hopefully Git will migrate to a better hash function before further research destroys SHA1.
A.2. Microsoft Windows
Git on Microsoft Windows can be cumbersome:
• Cygwin (http://cygwin.com/), a Linux-like environment for Windows, contains a Windows port of Git
(http://cygwin.com/packages/git/).
• Git on MSys (http://code.google.com/p/msysgit/) is an alternative requiring minimal runtime support,
though a few of the commands need some work.
A.3. Unrelated Files
If your project is very large and contains many unrelated ﬁles that are constantly being changed, Git may
be disadvantaged more than other systems because single ﬁles are not tracked. Git tracks changes to the
whole project, which is usually beneﬁcial.
A solution is to break up your project into pieces, each consisting of related ﬁles. Use git submodule if
you still want to keep everything in a single repository.
A.4. Who’s Editing What?
Some version control systems force you to explicitly mark a ﬁle in some way before editing. While this
is especially annoying when this involves talking to a central server, it does have two beneﬁts:
47

Appendix A. Git Shortcomings
1. Diffs are quick because only the marked ﬁles need be examined.
2. One can discover who else is working on the ﬁle by asking the central server who has marked it for
editing.
With appropriate scripting, you can achieve the same with Git. This requires cooperation from the
programmer, who should execute particular scripts when editing a ﬁle.
A.5. File History
Since Git records project-wide changes, reconstructing the history of a single ﬁle requires more work
than in version control systems that track individual ﬁles.
The penalty is typically slight, and well worth having as other operations are incredibly efﬁcient. For
example, git checkout is faster than cp -a, and project-wide deltas compress better than collections
of ﬁle-based deltas.
A.6. Initial Clone
Creating a clone is more expensive than checking out code in other version control systems when there is
a lengthy history.
The initial cost is worth paying in the long run, as most future operations will then be fast and ofﬂine.
However, in some situations, it may be preferable to create a shallow clone with the --depth option.
This is much faster, but the resulting clone has reduced functionality.
A.7. Volatile Projects
Git was written to be fast with respect to the size of the changes. Humans make small edits from version
to version. A one-liner bugﬁx here, a new feature there, emended comments, and so forth. But if your
ﬁles are radically different in successive revisions, then on each commit, your history necessarily grows
by the size of your whole project.
There is nothing any version control system can do about this, but standard Git users will suffer more
since normally histories are cloned.
The reasons why the changes are so great should be examined. Perhaps ﬁle formats should be changed.
Minor edits should only cause minor changes to at most a few ﬁles.
48

Appendix A. Git Shortcomings
Or perhaps a database or backup/archival solution is what is actually being sought, not a version control
system. For example, version control may be ill-suited for managing photos periodically taken from a
webcam.
If the ﬁles really must be constantly morphing and they really must be versioned, a possibility is to use
Git in a centralized fashion. One can create shallow clones, which checks out little or no history of the
project. Of course, many Git tools will be unavailable, and ﬁxes must be submitted as patches. This is
probably ﬁne as it’s unclear why anyone would want the history of wildly unstable ﬁles.
Another example is a project depending on ﬁrmware, which takes the form of a huge binary ﬁle. The
history of the ﬁrmware is uninteresting to users, and updates compress poorly, so ﬁrmware revisions
would unnecessarily blow up the size of the repository.
In this case, the source code should be stored in a Git repository, and the binary ﬁle should be kept
separately. To make life easier, one could distribute a script that uses Git to clone the code, and rsync or a
Git shallow clone for the ﬁrmware.
A.8. Global Counter
Some centralized version control systems maintain a positive integer that increases when a new commit
is accepted. Git refers to changes by their hash, which is better in many circumstances.
But some people like having this integer around. Luckily, it’s easy to write scripts so that with every
update, the central Git repository increments an integer, perhaps in a tag, and associates it with the hash
of the latest commit.
Every clone could maintain such a counter, but this would probably be useless, since only the central
repository and its counter matters to everyone.
A.9. Empty Subdirectories
Empty subdirectories cannot be tracked. Create dummy ﬁles to work around this problem.
The current implementation of Git, rather than its design, is to blame for this drawback. With luck, once
Git gains more traction, more users will clamour for this feature and it will be implemented.
49

Appendix A. Git Shortcomings
A.10. Initial Commit
A stereotypical computer scientist counts from 0, rather than 1. Unfortunately, with respect to commits,
git does not adhere to this convention. Many commands are unfriendly before the initial commit.
Additionally, some corner cases must be handled specially, such as rebasing a branch with a different
initial commit.
Git would beneﬁt from deﬁning the zero commit: as soon as a repository is constructed, HEAD would be
set to the string consisting of 20 zero bytes. This special commit represents an empty tree, with no
parent, at some time predating all Git repositories.
Then running git log, for example, would inform the user that no commits have been made yet, instead of
exiting with a fatal error. Similarly for other tools.
Every initial commit is implicitly a descendant of this zero commit.
However there are some problem cases unfortunately. If several branches with different initial commits
are merged together, then rebasing the result requires substantial manual intervention.
A.11. Interface Quirks
For commits A and B, the meaning of the expressions "A..B" and "A...B" depends on whether the
command expects two endpoints or a range. See git help diff and git help rev-parse.
50

Appendix B. Translating This Guide
I recommend the following steps for translating this guide, so my scripts can quickly produce HTML and
PDF versions, and all translations can live in the same repository.
Clone the source, then create a directory corresponding to the target language’s IETF tag: see the W3C
article on internationalization (http://www.w3.org/International/articles/language-tags/Overview.en.php).
For example, English is "en" and Japanese is "ja". In the new directory, and translate the txt ﬁles from
the "en" subdirectory.
For instance, to translate the guide into Klingon (http://en.wikipedia.org/wiki/Klingon_language), you
might type:
$ git clone git://repo.or.cz/gitmagic.git
$ cd gitmagic
$ mkdir tlh
# "tlh" is the IETF language code for Klingon.
$ cd tlh
$ cp ../en/intro.txt .
$ edit intro.txt
# Translate the file.
and so on for each text ﬁle.
Edit the Makeﬁle and add the language code to the TRANSLATIONS variable. You can now review your
work incrementally:
$ make tlh
$ firefox book-tlh/index.html
Commit your changes often, then let me know when they’re ready. GitHub has an interface that
facilitates this: fork the "gitmagic" project, push your changes, then ask me to merge.
51

