Fundamentals
of Computer
Architecture
and Design
Ahmet Bindal

Fundamentals of Computer Architecture
and Design

Ahmet Bindal
Fundamentals
of Computer
Architecture and Design
123

Dr. Ahmet Bindal
Computer Engineering Department
San Jose State University
San Jose, CA, USA
The Solutions Manual for instructors can be found at
http://www.springer.com/us/book/9783319258096
ISBN 978-3-319-25809-6
ISBN 978-3-319-25811-9
(eBook)
DOI 10.1007/978-3-319-25811-9
Library of Congress Control Number: 2016960285
© Springer International Publishing Switzerland 2017
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or
part of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of
illustrations, recitation, broadcasting, reproduction on microﬁlms or in any other physical way,
and transmission or information storage and retrieval, electronic adaptation, computer software,
or by similar or dissimilar methodology now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this
publication does not imply, even in the absence of a speciﬁc statement, that such names are
exempt from the relevant protective laws and regulations and therefore free for general use.
The publisher, the authors and the editors are safe to assume that the advice and information in
this book are believed to be true and accurate at the date of publication. Neither the publisher nor
the authors or the editors give a warranty, express or implied, with respect to the material
contained herein or for any errors or omissions that may have been made.
Printed on acid-free paper
This Springer imprint is published by Springer Nature
The registered company is Springer International Publishing AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland

For my mother who always showed me the right path…

Preface
This book is written for young professionals and graduate students
who have prior logic design background and want to learn how to use
logic blocks to build complete systems from design speciﬁcations.
My two-decade-long industry experience has taught me that engineers
are “shape-oriented” people and that they tend to learn from charts and
diagrams. Therefore, the teaching method I followed in this textbook
caters this mind set: a lot of circuit schematics, block diagrams, timing
diagrams, and examples supported by minimal text.
The book has eight chapters. The ﬁrst three chapters give a complete
review of the logic design principles since rest of the chapters signiﬁ-
cantly depend on this review. Chapter 1 concentrates on the combina-
tional logic design. It describes basic logic gates, De Morgan’s theorem,
truth tables, and logic minimization. This chapter uses these key con-
cepts in order to design mega cells, namely various types of adders and
multipliers. Chapter 2 introduces sequential logic components, namely
latches, ﬂip-ﬂops, registers, and counters. It introduces the concept of
timing diagrams to explain the functionality of each logic block. The
Moore and Mealy-type state machines, counter–decoder-type con-
trollers, and the construction of simple memories are also explained in
this chapter.Chapter2 also illustrates thedesign process: howto develop
architectural logic blocks using timing diagrams, and how to build a
controller from a timing diagram to guide data ﬂow. Chapter 3 focuses
on the review of asynchronous logic design, which includes state deﬁ-
nitions, primitive ﬂow tables, and state minimization. Racing conditions
in asynchronous designs, how to detect and correct them are also
explained in this chapter. The chapter ends with designing an important
asynchronous timing block: the C element (or the Mueller element), and
it describes an asynchronous timing methodology that leads to a com-
plete design using timing diagrams.
vii

From Chapter 4 to Chapter 8, computer architecture-related topics
are covered. Chapter 4 examines a very essential system element:
system bus and communication protocols between system modules.
This chapter deﬁnes the bus master and the bus slave concepts and
examines their bus interfaces. Read and write bus cycles and protocols,
bus handover and arbitration are also examined in this chapter. System
memories,
namely
Static
Random
Access
Memory
(SRAM),
Synchronous
Dynamic
Random
Access
Memory
(SDRAM),
Electrically-Erasable-Programmable-Read-Only-Memory (E2PROM)
and Flash memory are examined in Chapter 5. This chapter also shows
how to design bus interface for each memory type using timing dia-
grams and state machines. Chapter 6 is all about the design of a simple
Reduced Instruction Set Computer (RISC) for central processing. The
chapter starts with introducing a simple assembly instruction set and
building individual hardware for each instruction. As other instructions
are introduced to the design, techniques are shown how to integrate
additional hardware to the existing CPU data-path to be able to execute
multiple instructions. Fixed-point and ﬂoating-point Arithmetic Logic
Units (ALU) are also studied in this chapter. Structural, data and pro-
gram control hazards, and the required hardware to avoid them are
shown. This chapter ends with the operation of various cache archi-
tectures, cache read and write protocols, and the functionality of
write-through and write-back caches. The design of system peripherals,
namely Direct Memory Access (DMA), interrupt controller, system
timers, serial interface, display adapter and data controllers are covered
in Chapter 7. The design methodology to construct data-paths with
timing diagrams in Chapter 2 is closely followed in this chapter in order
to design the bus interface for each peripheral. Chapter 8 describes the
Field-Programmable Gate array (FPGA), and the fundamentals of data
driven processors as special topics.
At the end of the book, there is a small appendix that introduces the
Verilog language. Verilog is a widely used Hardware Design
Language (HDL) to build and verify logic blocks, mega cells and
systems. Interested readers are encouraged to go one step beyond and
learn system Verilog to be able to verify large logic blocks.
Dr. Ahmet Bindal
Computer Engineering Department
San Jose State University
San Jose, CA, USA
viii
Preface

Contents
1
Review of Combinational Circuits . . . . . . . . . . . . . . . .
1
1.1
Logic Gates . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.2
Boolean Algebra. . . . . . . . . . . . . . . . . . . . . . . . .
8
1.3
Designing Combinational Logic Circuits
Using Truth Tables . . . . . . . . . . . . . . . . . . . . . . .
11
1.4
Combinational Logic Minimization—Karnaugh
Maps. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
1.5
Basic Logic Blocks. . . . . . . . . . . . . . . . . . . . . . .
20
1.6
Combinational Mega Cells. . . . . . . . . . . . . . . . . .
29
2
Review of Sequential Logic Circuits. . . . . . . . . . . . . . .
67
2.1
D Latch. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
2.2
Timing Methodology Using D Latches . . . . . . . . .
69
2.3
D Flip-Flop . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
2.4
Timing Methodology Using D Flip-Flops . . . . . . .
72
2.5
Timing Violations. . . . . . . . . . . . . . . . . . . . . . . .
73
2.6
Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
79
2.7
Shift Register . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
2.8
Counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
2.9
Moore Machine . . . . . . . . . . . . . . . . . . . . . . . . .
83
2.10
Mealy Machine . . . . . . . . . . . . . . . . . . . . . . . . .
87
2.11
Controller Design: Moore Machine
Versus Counter-Decoder Scheme . . . . . . . . . . . . .
90
2.12
Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
94
2.13
A Design Example Using Sequential Logic
and Memory . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
3
Review of Asynchronous Logic Circuits . . . . . . . . . . . .
113
3.1
S-R Latch . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
113
3.2
Fundamental-Mode Circuit Topology . . . . . . . . . .
114
ix

3.3
Fundamental-Mode Asynchronous
Logic Circuits . . . . . . . . . . . . . . . . . . . . . . . . . .
115
3.4
Asynchronous Timing Methodology . . . . . . . . . . .
123
Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
131
4
System Bus. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
133
4.1
Parallel Bus Architectures . . . . . . . . . . . . . . . . . .
133
4.2
Basic Write Transfer . . . . . . . . . . . . . . . . . . . . . .
138
4.3
Basic Read Transfer . . . . . . . . . . . . . . . . . . . . . .
140
4.4
Bus Master Status Change . . . . . . . . . . . . . . . . . .
142
4.5
Bus Master Handshake . . . . . . . . . . . . . . . . . . . .
145
4.6
Arbiter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
145
4.7
Bus Master Handover . . . . . . . . . . . . . . . . . . . . .
148
4.8
Serial Buses. . . . . . . . . . . . . . . . . . . . . . . . . . . .
149
5
Memory Circuits and Systems. . . . . . . . . . . . . . . . . . .
169
5.1
Static Random Access Memory . . . . . . . . . . . . . .
170
5.2
Synchronous Dynamic Random
Access Memory . . . . . . . . . . . . . . . . . . . . . . . . .
179
5.3
Electrically-Erasable-Programmable-
Read-Only-Memory . . . . . . . . . . . . . . . . . . . . . .
201
5.4
Flash Memory . . . . . . . . . . . . . . . . . . . . . . . . . .
209
5.5
Serial Flash Memory. . . . . . . . . . . . . . . . . . . . . .
253
References. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
274
6
Central Processing Unit . . . . . . . . . . . . . . . . . . . . . . .
275
6.1
RISC Instruction Formats. . . . . . . . . . . . . . . . . . .
275
6.2
CPU Data-Path. . . . . . . . . . . . . . . . . . . . . . . . . .
277
6.3
Fixed-Point Register-to-Register
Type ALU Instructions . . . . . . . . . . . . . . . . . . . .
280
6.4
Fixed-Point Immediate Type ALU Instructions . . . .
292
6.5
Data Movement Instructions. . . . . . . . . . . . . . . . .
298
6.6
Program Control Instructions . . . . . . . . . . . . . . . .
302
6.7
Design Example I: A Fixed-Point CPU
with Four Instructions . . . . . . . . . . . . . . . . . . . . .
308
6.8
Design Example II: A Fixed-Point CPU
with Eight Instructions . . . . . . . . . . . . . . . . . . . .
313
6.9
Floating-Point Instructions . . . . . . . . . . . . . . . . . .
316
6.10
Floating-Point. . . . . . . . . . . . . . . . . . . . . . . . . . .
317
x
Contents

6.11
Floating-Point Adder. . . . . . . . . . . . . . . . . . . . . .
322
6.12
Floating-Point Multiplier . . . . . . . . . . . . . . . . . . .
324
6.13
A RISC CPU with Fixed
and Floating-Point Units . . . . . . . . . . . . . . . . . . .
325
6.14
Structural Hazards. . . . . . . . . . . . . . . . . . . . . . . .
327
6.15
Data Hazards . . . . . . . . . . . . . . . . . . . . . . . . . . .
328
6.16
Program Control Hazards. . . . . . . . . . . . . . . . . . .
333
6.17
Handling Hazards in a Five-Stage RISC CPU:
An Example. . . . . . . . . . . . . . . . . . . . . . . . . . . .
335
6.18
Handling Hazards in a Four-Stage RISC CPU . . . .
339
6.19
Handling Hazards in a Three-Stage RISC CPU. . . .
340
6.20
Multi-cycle ALU and Related Data Hazards. . . . . .
342
6.21
Cache Topologies . . . . . . . . . . . . . . . . . . . . . . . .
346
6.22
Cache Write and Read Structures . . . . . . . . . . . . .
349
6.23
A Direct-Mapped Cache Example. . . . . . . . . . . . .
351
6.24
Write-Through and Write-Back Cache Structures
in Set-Associative Caches . . . . . . . . . . . . . . . . . .
354
6.25
A Two-Way Set-Associative Write-Through
Cache Example . . . . . . . . . . . . . . . . . . . . . . . . .
355
6.26
A Two-Way Set-Associative Write-Back
Cache Example . . . . . . . . . . . . . . . . . . . . . . . . .
358
References. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
375
7
System Peripherals . . . . . . . . . . . . . . . . . . . . . . . . . . .
377
7.1
Overall System Arcitecture. . . . . . . . . . . . . . . . . .
377
7.2
Direct Memory Access Controller . . . . . . . . . . . . .
378
7.3
Interrupt Controller . . . . . . . . . . . . . . . . . . . . . . .
387
7.4
Serial Transmitter and Receiver Interface . . . . . . . .
399
7.5
Timers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
406
7.6
Display Adaptor . . . . . . . . . . . . . . . . . . . . . . . . .
414
7.7
Data Converters . . . . . . . . . . . . . . . . . . . . . . . . .
425
7.8
Digital-to-Analog Converter (DAC). . . . . . . . . . . .
437
References. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
454
8
Special Topics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
455
8.1
Field-Programmable-Gate Array . . . . . . . . . . . . . .
455
8.2
Data-Driven Processors . . . . . . . . . . . . . . . . . . . .
473
References. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
489
Contents
xi

Appendix: An Introduction to Verilog Hardware
Design Language. . . . . . . . . . . . . . . . . . . . . . .
491
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
529
xii
Contents

About the Author
Ahmet Bindal received his M.S. and Ph.D.
degrees in Electrical Engineering Depart-
ment from the University of California, Los
Angeles, CA. His doctoral thesis was the
material characterization in High Electron
Mobility (HEMT) GaAs transistors. During
his graduate studies, he was a research
associate and a technical consultant for
Hughes Aircraft Co. In 1988, he joined the
technical staff of IBM Research and Devel-
opment Center in Fishkill, NY, where he worked as a device design
and characterization engineer. He developed asymmetrical MOS
transistors and ultrathin silicon on insulator (SOI) technologies for
IBM. In 1993, he transferred to IBM at Rochester, MN, as a senior
circuit design engineer to work on the ﬂoating-point unit for the
AS-400 main frame processor. He continued his circuit design career
at Intel Corporation in Santa Clara, CA, where he designed 16-bit
packed multipliers and adders for the MMX unit in Pentium II pro-
cessors. In 1996, he joined Philips Semiconductors in Sunnyvale, CA,
where he was involved in the designs of instruction/data caches and
various SRAM modules for the TriMedia processor. His involvement
with VLSI architecture also started in Philips Semiconductors and led
to the design of the Video-Out unit for the same processor. In 1998, he
joined Cadence Design Systems as a VLSI architect and directed a
team of engineers to design self-timed asynchronous processors. After
approximately 20 years of industry work, he joined the computer
engineering faculty at San Jose State University in 2002. His current
research interests range from nano-scale electron devices to robotics.
xiii

Dr. Bindal has over 30 scientiﬁc journal and conference publications
and 10 invention disclosures with IBM. He currently holds three US
patents with IBM and one with Intel Corporation. On the light side of
things, Dr. Bindal is a model aircraft builder and an avid windsurfer
for more than 30 years.
xiv
About the Author

1
Review of Combinational Circuits
Logic gates are the essential elements in digital design, and ultimately constitute the building
blocks for digital systems. A good understanding in designing complex logic blocks from
primitive logic gates, and mastering the design tools and techniques that need to be incor-
porated in the design process is a requirement for the reader before moving to the details of
computer architecture and design.
This chapter starts with deﬁning the logic gates and the concept of truth table which then
leads to the implementation of basic logic circuits. Later in the chapter, the concept of
Karnaugh maps is introduced in order to minimize gate count, thereby completing the basic
requirements of combinational logic design. Following the minimization techniques, various
fundamental logic blocks such as multiplexers, encoders, decoders and one-bit adders are
introduced so that they can be used to construct larger scale combinational logic circuits. The
last section of this chapter is dedicated to the design of mega cells. These include different
types of adders such as ripple-carry adder, carry-look-ahead adder, carry-select adder, and
the combination of all three types depending on the goals of the design: gate count, circuit
speed and power consumption. Subtractors, linear and barrel shifters, array and Booth
multipliers constitute the remaining sections of this chapter.
It is vital for the reader to also invest time to learn a hardware design language such as
Verilog while studying this chapter and the rest of the chapters in this book. A simulation
platform incorporating Verilog and a set of tools that work with Verilog such as design
synthesis, static timing analysis, and veriﬁcation is an effective way to check if the intended
design is correct or not. There is nothing more valuable than trying various design ideas on a
professional design environment, and understanding what works and what does not while
learning from your mistakes. An appendix introducing the basic principles of Verilog is
included at the end of this book for reference.
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9_1
1

1.1
Logic Gates
AND gate
To understand how AND gate functions, assume that the output, OUT, in Fig. 1.1 is at logic
0 when both switches, A and B, are open. Unless both A and B close, the output stays at
logic 0.
A two-input AND gate functions similarly to the circuit in Fig. 1.1. If any of the two
inputs, A or B, is at logic 0 in the AND gate in Fig. 1.2, the gate produces a logic 0 output at
OUT. Both inputs of the gate must be equal to logic 1 in order to produce an output at logic 1.
This behavior is tabulated in Table 1.1, which is called a “truth table”.
A
B
OUT
Fig. 1.2 Two-input AND gate symbol
Table 1.1 Two-input AND gate truth table
A
B
OUT
0
0
0
0
1
0
1
0
0
1
1
1
1
OUT
A
B
Fig. 1.1 Switch representation of a two-input AND gate
2
1
Review of Combinational Circuits

The functional representation of the two-input AND gate is:
OUT ¼ A : B
Here, the symbol “.” between inputs A and B represents the AND-function.
OR gate
Now, assume a parallel connectivity between switches A and B as shown in Fig. 1.3. OUT
becomes logic 1 if one of these switches closes; otherwise the output will stay at logic 0.
A two-input OR gate shown in Fig. 1.4 functions similarly to the circuit in Fig. 1.3. If any
of the two inputs is at logic 1, the gate produces an output, OUT, at logic 1. Both inputs must
be equal to logic 0 in order to produce a logic 0 output. This behavior is tabulated in the truth
table, Table 1.2.
A
B
OUT
Fig. 1.4 Two-input OR gate symbol
1
OUT
A
B
Fig. 1.3 Switch representation of two-input OR gate
Table 1.2 Two-input OR gate truth table
A
B
OUT
0
0
0
0
1
1
1
0
1
1
1
1
1.1
Logic Gates
3

The functional representation of the two-input OR gate is:
OUT ¼ A þ B
Here, the symbol “+” between inputs A and B signiﬁes the OR-function.
Exclusive OR gate
A two-input Exclusive OR gate, XOR gate, is shown in Fig. 1.5. The XOR gate produces a
logic 0 output if both inputs are equal. Therefore, in many logic applications this gate is used
to compare the input logic levels to see if they are equal. The functional behavior of the gate
is tabulated in Table 1.3.
The functional representation of the two-input XOR gate is:
OUT = A  B
Here, the “⊕” symbol between inputs A and B signiﬁes the XOR-function.
Buffer
A buffer is a single input device whose output is logically equal to its input. The only use of
this gate is to be able to supply enough current to the capacitive load created by a multitude of
logic gates connected to its output. The logical representation of this gate is shown in Fig. 1.6.
Table 1.3 Two-input XOR gate truth table
A
B
OUT
0
0
0
0
1
1
1
0
1
1
1
0
A
B
OUT
Fig. 1.5 Two-input XOR gate symbol
OUT
IN
Fig. 1.6 Buffer symbol
4
1
Review of Combinational Circuits

Complementary Logic Gates
All basic logic gates need to have complemented forms in logic design. If a single input
needs to be complemented, an inverter shown in Fig. 1.7 is used. The inverter truth table is
shown in Table 1.4.
The functional representation of the inverter is:
OUT ¼ IN
Here, the “-” symbol on top of the input, IN, represents the complement-function.
The complemented form of two-input AND gate is called two-input NAND gate, where “N”
signiﬁes negation. The logic representation is shown in Fig. 1.8, where a circle at the output of
the gate means complemented output. The truth table of this gate is shown in Table 1.5. Note
that all output values in this table are exact opposites of the values given in Table 1.1.
A
B
OUT
Fig. 1.8 Two-input NAND gate symbol
Table 1.4 Inverter truth table
IN
OUT
0
1
1
0
OUT
IN
Fig. 1.7 Inverter symbol
Table 1.5 Two-input NAND gate truth table
A
B
OUT
0
0
1
0
1
1
1
0
1
1
1
0
1.1
Logic Gates
5

The functional representation of the two-input NAND gate is:
OUT ¼ A : B
Similar to the NAND gate, the two-input OR and the two-input XOR gates have com-
plemented conﬁgurations, called the two-input NOR and the two-input XNOR gates,
respectively.
The symbolic representation and truth table of a two-input NOR gate is shown in Fig. 1.9
and Table 1.6, respectively. Again, all the outputs in Table 1.6 are the exact complements of
the outputs in Table 1.2.
The functional representation of the two-input NOR gate is:
OUT ¼ A þ B
The symbolic representation and truth table of a two-input XNOR gate is shown in
Fig. 1.10 and Table 1.7, respectively. This gate, like its counterpart the two-input XOR gate,
is often used to detect if input logic levels are equal.
Table 1.6 Two-input NOR gate truth table
A
B
OUT
0
0
1
0
1
0
1
0
0
1
1
0
A
B
OUT
Fig. 1.10 Two-input XNOR gate symbol
A
B
OUT
Fig. 1.9 Two-input NOR gate symbol
Table 1.7 Two-input XNOR gate truth table
A
B
OUT
0
0
1
0
1
0
1
0
0
1
1
1
6
1
Review of Combinational Circuits

The functional representation of the two-input XNOR gate is:
OUT ¼ A  B
Tri-State Buffer and Inverter
It is often necessary to create an open circuit between the input and the output of a logic gate
if the gate is not enabled. This need creates two more basic logic gates, the tri-state buffer
and tri-state inverter.
The tri-state buffer is shown in Fig. 1.11. Its truth table in Table 1.8 indicates continuity
between the input and the output terminals if the control input, EN, is at logic 1. When EN is
lowered to logic 0, an open circuit exists between the IN and the OUT terminals, which is
deﬁned as high impedance state (HiZ).
The tri-state inverter is shown in Fig. 1.12 along with its truth table in Table 1.9. This
gate behaves like an inverter when EN input is at logic 1. However, when EN is lowered to
logic 0, its output disconnects from its input.
Table 1.8 Tri-state buffer truth table
T
U
O
N
E
N
I
0
0
HiZ
0
1
1
0
1
1
0
HiZ
1
OUT
IN
EN
Fig. 1.12 Tri-state inverter symbol
OUT
IN
EN
Fig. 1.11 Tri-state buffer symbol
1.1
Logic Gates
7

The control input, EN, to tri-state buffer and inverter can also be complemented in order to
produce an active-low enabling scheme.
The tri-state buffer with the active-low enable input in Fig. 1.13 creates continuity when
EN = 0.
The tri-state inverter with the active-low input in Fig. 1.14 also functions like an inverter
when EN is at logic 0, but its output becomes HiZ when EN is changed to logic 1.
1.2
Boolean Algebra
It is essential to be able to reconﬁgure logic functions to suit our design goals. Logical
reconﬁgurations may be as simple as regrouping the inputs to a single gate or comple-
menting the inputs of several gates to reach a design objective.
The identity, commutative, associative, distributive laws and the DeMorgan’s negation
rules are used to perform logical manipulations. Table 1.10 tabulates these laws.
Table 1.9 Tri-state inverter truth table
T
U
O
N
E
N
I
0
0
HiZ
0
1
1
0
1
1
1
HiZ
0
OUT
IN
EN
Fig. 1.13 Tri-state buffer symbol with complemented enable input
OUT
IN
EN
Fig. 1.14 Tri-state inverter symbol with complemented enable input
8
1
Review of Combinational Circuits

Example 1.1: Reduce OUT ¼ A : B : C þ A : B : C þ A : B using algebraic rules.
OUT ¼ A : B : C þ A : B : C þ A : B
¼ A : C : ðB þ BÞ þ A : B
¼ A : (C þ BÞ
Example 1.2: Reduce OUT ¼ A þ A : B using algebraic rules.
OUT ¼ A þ A : B
¼ ðA þ AÞ : ðA þ BÞ
¼ A þ B
Table 1.10 Identity, commutative, associative, distributive and DeMorgan’s rules
A . B = B . A
A + B = B + A
Commutative
A . (B . C) = (A . B) . C
A + (B + C) = (A + B) + C
Associative
A . (B + C) = A . B + A . C
A + B . C = (A + B) . (A + C)
Distributive
A . B = A + B
A + B = A . B
A . 1 = A
A . 0 = 0
A . A = A
A . A = 0
A = A
A + 1 = 1
A + 0 = A
A + A = A
A + A = 1
Identity
DeMorgan’s
1.2
Boolean Algebra
9

Example 1.3: Reduce OUT ¼ A : B þ A : C þ B : C using algebraic rules.
OUT ¼ A : B þ A : C þ B : C
¼ A : B þ A : C þ B : C : ðA þ AÞ
¼ A : B þ A : C þ A : B : C þ A : B : C
¼ A : B : ð1 þ CÞ þ A : C : ð1 þ B)
¼ A : B þ A : C
Example 1.4: Reduce OUT ¼ ðA þ BÞ : ðA þ C) using algebraic rules.
OUT ¼ ðA þ BÞ : ðA þ C)
¼ A : A þ A : C þ A : B þ B : C
¼ A : C þ A : B þ B : C
¼ A : C þ A : B þ B : C : ðA þ AÞ
¼ A : C þ A : B þ A : B : C þ A : B : C
¼ A : C : ð1 þ BÞ þ A : B : ð1 þ CÞ
¼ A : C þ A : B
Example 1.5: Convert OUT ¼ ðA þ BÞ : C : D into an OR-combination of two-input
AND gates using algebraic laws and DeMorgan’s theorem.
OUT ¼ ðA þ BÞ : C : D
¼ ðA þ BÞ : ðC þ DÞ
¼ A : C þ A : D þ B : C þ B : D
Example 1.6: Convert OUT ¼ A : B þ C : D into an AND-combination of two-input OR
gates using algebraic laws and DeMorgan’s theorem.
OUT ¼ A : B þ C : D
¼ A : B þ C : D
¼ ðA þ BÞ : ðC þ DÞ
10
1
Review of Combinational Circuits

1.3
Designing Combinational Logic Circuits Using Truth Tables
A combinational logic circuit is a cascaded form of basic logic gates without any feedback
from the output to any of its inputs. The logic function is obtained from a truth table that
speciﬁes the complete functionality of the digital circuit.
Example 1.7: Using the truth table given in Table 1.11 determine the output function of the
digital circuit.
The output function can be expressed either as the OR combination of AND gates or the
AND combination of OR gates.
If the output is expressed in terms of AND gates, all output entries that are equal to one in
the truth table must be grouped together as a single OR gate.
Table 1.11 An arbitrary truth table with four inputs
A
B
C
D
OUT
0
0
0
0
0
0
0
1
0
0
1
0
0
0
1
1
0
1
0
0
0
1
0
1
0
1
1
0
0
1
1
1
1
0
0
0
1
0
0
1
1
0
1
0
1
0
1
1
1
1
0
0
1
1
0
1
1
1
1
0
1
1
1
1
1
1
1
0
0
1
0
0
1
1
1
0
0
0
0
0
1.3
Designing Combinational Logic Circuits Using Truth Tables
11

OUT ¼ A : B : C : D þ A : B : C : D þ A : B : C : D þ A : B : C : D
þ A : B : C : D þ A : B : C : D þ A : B : C : D
This expression is called the Sum Of Products (SOP), and it contains seven terms each
of which is called a “minterm”. In the ﬁrst minterm, each A, B, C and D input is com-
plemented to produce OUT = 1 for the A = B = C = D = 0 entry of the truth table. Each of
the remaining six minterms also complies with producing OUT = 1 for their respective input
entries.
The resulting combinational circuit is is shown Fig 1.15.
If the output function needs to be expressed in terms of OR gates, all the output entries
that are equal to zero in the truth table must be grouped as a single AND gate.
A 
B
C
D
A 
B
C
D
A 
B
C
D
A 
B
C
D
A 
B
C
D
A 
B
C
D
A 
B
C
D
OUT
Fig. 1.15 AND-OR logic representation of the truth table in Table 1.11
12
1
Review of Combinational Circuits

OUT ¼ ðA þ B þ C þ DÞ : (A þ B þ C þ DÞ : ðA þ B þ C þ D)
: ðA þ B þ C þ DÞ : ðA þ B þ C þ DÞ : ðA þ B þ C þ DÞ
: ðA þ B þ C þ DÞ : ðA þ B þ C þ D) : ðA þ B þ C þ DÞ
This expression is called the Product Of Sums (POS), and it contains nine terms each of
which is called a “maxterm”. The ﬁrst maxterm produces OUT = 0 for the ABCD = 0011
entry of the truth table. Since the output is formed with a nine-input AND gate, the values of
the other maxterms do not matter to produce OUT = 0. Each of the remaining eight max-
terms generates OUT = 0 for their corresponding truth table input entries.
The resulting combinational circuit is shown in Fig. 1.16.
A 
B
C
D
A 
B
C
D
A 
B
C
D
A 
B
C
D
A 
B
C
D
A 
B
C
D
A 
B
C
D
OUT
A 
B
C
D
A 
B
C
D
Fig. 1.16 OR-AND logic representation of the truth table in Table 1.11
1.3
Designing Combinational Logic Circuits Using Truth Tables
13

1.4
Combinational Logic Minimization—Karnaugh Maps
One of the most useful tools in logic design is the use of Karnaugh maps (K-map) to
minimize combinational logic functions.
Minimization can be performed in two ways. To obtain the SOP form of a minimized
logic function, logic 1 entries of the truth table must be grouped together in the K-map. To
obtain the POS form of a minimized logic function, logic 0 entries of the truth table must be
grouped together in the K-map.
Example 1.8: Using the truth table in Table 1.12, determine the minimized SOP and POS
output functions. Prove them to be identical.
The SOP function is formed by grouping logic 1s in Fig. 1.17 to obtain the minimized
output function, OUT.
Table 1.12 An arbitrary truth table with three inputs
OUT
A
B
C
0
0
0
1
0
0
1
1
0
1
0
1
0
1
1
0
1
0
0
1
1
0
1
1
1
1
0
0
1
1
1
0
00
01
11
10
0
1
1
1
0
1
1
1
0
0
AB
C
OUT
Fig. 1.17 K-map of the truth table in Table 1.12 to determine SOP
Grouping 1s takes place among neighboring boxes in the K-map where only one variable
is allowed to change at a time. For instance, the ﬁrst grouping of 1s combines the ABC = 000
and ABC = 010 entries as they are in the neighboring boxes. Only B changes from logic 0 to
logic 1 while A and C stay constant at logic 0. To obtain OUT = 1, both A and C need to be
complemented; this produces the ﬁrst term, A : C, for the output function. Similarly, the
second grouping of 1s combines the neighboring boxes, ABC = 000, 001, 100 and 101,
where both A and C change while B stays constant at logic 0. To obtain OUT = 1, B needs to
be complemented; this generates the second term, B, for the output function.
14
1
Review of Combinational Circuits

This means that either the term A : C or B makes OUT equal to logic 1. Therefore, the
minimized output function, OUT, in the SOP form is:
OUT ¼ B þ A : C
Grouping 0s produces the minimized POS output function as shown in Fig. 1.18.
This time, the ﬁrst grouping of 0s combines the boxes, ABC = 011 and 111, where A
changes from logic 0 to logic 1 while B and C stay constant at logic 1. This grouping targets
OUT = 0, which requires both B and C to be complemented. As a result, the ﬁrst term of the
output function, B þ C, is generated. The second grouping combines ABC = 110 and 111
where C changes from logic 0 to logic 1 while A and B stay at logic 1. To obtain OUT = 0,
both A and B need to be complemented. Consequently, the second term, A þ B, forms.
Therefore, either B þ C or A þ B should produce OUT = 0, resulting the following POS
function.
OUT ¼ ðB þ CÞ : ðA þ BÞ
To ﬁnd out if the SOP and POS forms are identical to each other, we can manipulate the
POS expression above using the algebraic rules given earlier.
OUT ¼ ðB þ CÞ : ðA þ BÞ
¼ A : B þ B : B þ A : C þ B : C
¼ A : B þ B þ A : C þ B : C
¼ B : ðA þ 1 þ CÞ þ A : C
¼ B þ A : C
00
01
11
10
0
1
1
1
0
1
1
1
0
0
AB
C
OUT
Fig. 1.18 K-map of the truth table in Table 1.12 to determine POS
This is the SOP form of the output function derived above.
Example 1.9: Using the truth table in Example 1.7 determine the minimized SOP and POS
output functions.
To obtain the output function in SOP form, logic 1s in the K-map in Fig. 1.19 are grouped
together as shown below.
1.4
Combinational Logic Minimization—Karnaugh Maps
15

The minimized output function contains only three minterms compared to seven minterms
in Example 1.7. Also, the minterms are reduced to groups of two or three inputs instead offour.
OUT ¼ B : C þ A : C : D þ B : D
The resultant combinational circuit is shown in Fig. 1.20
Further minimization can be achieved algebraically, which then reduces the number of
terms from three to two.
OUT ¼ B : ðC þ DÞ þ A : C : D
The corresponding combinational circuit is shown in Fig. 1.21.
00
01
11
10
00
01
11
10
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
AB
CD
OUT
Fig. 1.19 K-map of the truth table in Table 1.11 to determine SOP
B
C
A
C
D
B
D
OUT
Fig. 1.20 Minimized logic circuit in SOP form from the K-map in Fig. 1.19
16
1
Review of Combinational Circuits

To obtain the POS output function, logic 0s are grouped together as shown in Fig. 1.22.
The minimized output function contains only three maxterms compared to nine in
Example 1.7. Also, the maxterms are reduced to groups of two inputs instead of four.
OUT ¼ ðC þ DÞ : ðA þ BÞ : ðB þ D)
The resultant combinational circuit is shown in Fig. 1.23
B
A 
C
D
C
D
  
OUT
Fig. 1.21 Logic circuit in Fig. 1.20 after algebraic minimizations are applied
00
01
11
10
00
01
11
10
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
AB
CD
OUT
Fig. 1.22 K-map of the truth table in Table 1.11 to determine POS
C
D
A 
B
B
D
OUT
Fig. 1.23 Minimized logic circuit in POS form from the K-map in Fig. 1.22
1.4
Combinational Logic Minimization—Karnaugh Maps
17

Example 1.10: Determine if the minimized SOP and POS output functions in Example 1.9
are identical to each other.
The POS expression for the OUT function in Example 1.9 can be re-written as follows:
OUT ¼ ðC þ DÞ : ðA þ BÞ : ðB þ D)
¼ ðA : C þ A : D þ B : C þ B : DÞ : ðB þ D)
¼ A : B : C þ A : B : D þ B : C þ B : D
þ A : C : D þ B : C : D
¼ B : C þ B : D þ A : C : D
The result is identical to the SOP expression given in Example 1.9.
Example 1.11: Determine the minimal SOP and POS forms of the output function, OUT,
from the K-map in Fig. 1.24. Note that the “X” sign corresponds to a “don’t care” condition
that represents either logic 0 or logic 1.
For the SOP expression, logic 1s in the K-map in Fig. 1.25 are grouped. Boxes with
“don’t care” entries are used as logic 1s to achieve the minimal SOP expression.
00
01
11
10
00
01
11
10
1
0
0
X
1
0
1
0
1
0
0
X
0
1
X
0
AB
CD
OUT
Fig. 1.24 An arbitrary K-map with “don’t care” entries
18
1
Review of Combinational Circuits

As a result, the SOP functional expression for OUT is:
OUT = A : C : D þ A : B : C þ B : D
For the POS expression, logic 0s in the K-map in Fig. 1.26 are grouped. Boxes with
“don’t care” symbols are used as logic 0s to achieve the minimal POS expression.
Therefore, the POS functional expression for OUT becomes:
OUT ¼ ðC þ DÞ : ð B þ DÞ : (A þ B þ CÞ : ðA þ B þ CÞ
To show that the SOP and POS expressions are identical, we use the algebraic manip-
ulations in Table 1.10 on the POS expression in order to obtain the SOP expression.
00
01
11
10
00
01
11
10
1
0
0
X
1
0
1
0
1
0
0
X
0
1
X
0
AB
CD
OUT
Fig. 1.25 Grouping to determine SOP form for the K-map in Fig. 1.24
00
01
11
10
00
01
11
10
1
0
0
X
1
0
1
0
1
0
0
X
0
1
X
0
AB
CD
OUT
Fig. 1.26 Grouping to determine POS form for the K-map in Fig. 1.24
1.4
Combinational Logic Minimization—Karnaugh Maps
19

OUT ¼ (C þ D) . (B þ D) . (A þ B þ C) . (A þ B þ C)
¼ ðB : C þ C : D þ B : D þ DÞ : ðA : B þ A : C þ A : B þ B þ B : C þ A : C þ B : C)
¼ ðB : C þ DÞ : ðA : C þ A : C þ BÞ
¼ A : B . C þ A . C : D þ A : C . D þ B : D
¼ A : B . C þ A . C : D þ B : D þ A : C . D : ðB þ BÞ
¼ A : B . C þ A . C : D þ B : D þ A : B . C . D þ A : B : C . D
¼ A : B . C . (1 þ D) + A . C : D þ B : D : ð1 þ A : CÞ
¼ A : B . C þ A . C : D þ B : D
This result is identical to the minimal SOP expression for the OUT function above.
1.5
Basic Logic Blocks
2-1 Multiplexer
The 2-1 multiplexer (MUX) is one of the most versatile logic elements in logic design. It is
deﬁned as follows:
OUT ¼
A if sel ¼ 1
B else
"
A functional diagram of the 2-1 MUX is given in Fig. 1.27. According to the functional
description of this device when sel = 1, input A passes through the device to become its
output. When sel = 0, input B passes through the device to become its output.
1
0
A
B
OUT
sel
Fig. 1.27 2-1 MUX symbol
20
1
Review of Combinational Circuits

According to this functional deﬁnition, the truth table in Table 1.13 can be formed.
Now, let us transfer the output values from the truth table to the K-map in Fig. 1.28.
Grouping logic 1s in the K-map reveals the minimal output function of the 2-1 MUX in
SOP form:
OUT ¼ sel : A þ sel : B
The corresponding combinational circuit is shown in Fig. 1.29.
Table 1.13 2-1 MUX truth table
A
B
sel
OUT
0
0
0
0
0
1
0
1
0
0
1
1
1
0
0
1
0
1
1
1
0
1
1
1
0
1
0
1
0
0
1
1
00
01
11
10
0
1
0
0
0
0
1
1
1
1
AB
sel
OUT
Fig. 1.28 2-1 MUX K-map
sel
A
OUT
sel
B
Fig. 1.29 2-1 MUX logic circuit
1.5
Basic Logic Blocks
21

4-1 Multiplexer
If we apply four inputs to a multiplexer instead of two, we form a 4-1 MUX whose
functional description becomes as follows:
OUT ¼
A if sel1 ¼ 0 and sel2 ¼ 0
B if sel1 ¼ 0 and sel2 ¼ 1
C if sel1 ¼ 1 and sel2 ¼ 0
D else
2
6664
According to this description, we can form a truth table and obtain the minimal SOP or
POS expression for OUT. However, it is quite easy to decipher the SOP expression for OUT
from the description above. The AND-combination of A, complemented sel1 and comple-
mented sel2 inputs constitute the ﬁrst minterm of our SOP. The second minterm should
contain B, complemented sel1 and uncomplemented sel2 according to the description above.
Similarly, the third minterm contains C, uncomplemented sel1 and complemented sel2.
Finally, the last minterm contains D, uncomplemented sel1 and uncomplemented sel2
control inputs. Therefore, the SOP expression for the 4-1 MUX becomes equal to the logic
expression below and is implemented in Fig. 1.30.
OUT ¼ sel1 : sel2 : A þ sel1 : sel2 : B þ sel1 : sel1 : C þ sel1 : sel2 : D
sel1
A
OUT
sel2
sel1
B
sel2
sel1
C
sel2
sel1
D
sel2
Fig. 1.30 4-1 MUX logic circuit in SOP form
However, implementing a 4-1 MUX this way is not advantageous due to the amount of
gate delays. A three-input AND gate is a series combination of a three-input NAND gate and
an inverter. Similarly, a four-input OR requires a four-input NOR gate and an inverter.
Therefore, we obtain a minimum of four gate delays instead of two according to this circuit.
Logic translations are possible to reduce the gate delay. The ﬁrst stage of this process is to
complement the outputs of all four three-input AND gates. This necessitates complementing
the inputs to the four-input OR gate, and it results in a circuit in Fig. 1.31.
22
1
Review of Combinational Circuits

However, an OR gate with complemented inputs is equivalent to a NAND gate.
Therefore, the circuit Fig. 1.32 becomes an optimal implementation to achieve the shortest
gate delay for the 4-1 MUX because it contains only two gate delays instead of the earlier
four.
The symbolic diagram of the 4-1 MUX is shown in Fig. 1.33.
sel1
A
OUT
sel2
sel1
B
sel2
sel1
C
sel2
sel1
D
sel2
Fig. 1.31 Logic conversion of 4-1 MUX in Fig. 1.30
sel1
A
OUT
sel2
sel1
B
sel2
sel1
C
sel2
sel1
D
sel2
Fig. 1.32 4-1 MUX logic circuit in NAND-NAND form
00
A
B
OUT
sel1
C
D
sel2
01
10
11
Fig. 1.33 4-1 MUX symbol
1.5
Basic Logic Blocks
23

Encoders
Encoders are the combinational logic blocks that receive 2N number of inputs and produce N
number of encoded outputs.
Example 1.12: Generate an encoding logic from the truth table given in Table 1.14.
The K-maps in Fig. 1.34 group logic 1s, and produce the encoded SOP expressions for
OUT1 and OUT2.
Table 1.14 An arbitrary encoder truth table with four inputs
IN1
IN2
IN3
IN4
OUT1
OUT2
0
0
0
0
0
1
0
0
0
1
1
1
0
0
1
0
1
1
0
0
1
1
0
1
0
1
0
0
1
0
0
1
0
1
0
0
0
1
1
0
0
0
0
1
1
1
1
0
1
0
0
0
0
1
1
0
0
1
0
0
1
0
1
0
0
0
1
0
1
1
0
1
1
1
0
0
1
0
1
1
0
1
1
1
1
1
1
0
1
1
1
1
1
1
1
0
0
1
0
1
0
1
0
1
1
1
1
1
0
0
0
0
01
00
10
11
01
00
10
11
OUT1
IN3 IN4
IN1 IN2
1
1
1
1
0
0
0
0
0
1
0
1
0
1
0
1
01
00
10
11
01
00
10
11
OUT2
IN3 IN4
IN1 IN2
Fig. 1.34 K-map of the truth table in Table 1.14
24
1
Review of Combinational Circuits

OUT1 ¼ IN1 : IN2 þ IN1 : IN2 : IN3 : IN4 þ IN1 : IN2 : IN3 : IN4
þ IN2 : IN3 : IN4 þ IN2 : IN3 : IN4
¼ IN1 : IN2 þ IN1 : IN2 : ðIN3  IN4Þ þ IN2 : ðIN3  IN4Þ
OUT2 ¼ IN1 : IN2 þ IN2 : IN3 : IN4 þ IN2 : IN3 : IN4 þ IN1 : IN2 : IN3 : IN4
þ IN1 : IN2 : IN3 : IN4
¼ IN1 : IN2 þ IN2 : ðIN3  IN4Þ þ IN1 : IN2 : ðIN3  IN4Þ
Decoders
Decoders are the combinational logic blocks to decode encoded inputs. An ordinary decoder
takes N inputs and produces 2N outputs.
Example 1.13: Design a line decoder in which an active-high enable signal activates one of
the eight independent outputs according to the truth table in Table 1.15. When the enable
signal is lowered to logic 0, all eight outputs are disabled and stay at logic 0.
Table 1.15 Truth table of a line decoder with three inputs with enable
IN[2]
IN[1]
IN[0]
OUT[7] OUT[6] OUT[5]
OUT[4] OUT[3]
OUT[2] OUT[1]
OUT[0]
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
1
0
1
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
0
0
0
0
1
0
0
1
0
0
0
0
0
0
1
0
0
0
1
1
0
0
0
0
1
0
0
0
1
0
0
0
0
0
1
0
0
0
0
1
0
1
0
0
1
0
0
0
0
0
1
1
0
0
1
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
0
EN
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1.5
Basic Logic Blocks
25

In this table, all outputs become logic 0 when the enable signal, EN, is at logic 0.
However, when EN = 1, selective activation of the output starts. In this section, for each
three-bit input entry, there is always one output equal to logic 1. For example, when IN[2] =
IN[1] = IN[0] = 0, OUT[0] becomes active and equals to logic 1 while all the other outputs
stay at logic 0. IN[2] = IN[1] = IN[0] = 1 activates OUT[7] and disables all other outputs.
We can produce the expression for each output from OUT[7] to OUT[0] simply by
reading the input values from the truth table. The accompanying circuit is composed of eight
AND gates, each with four inputs as shown in Fig. 1.35.
OUT½7 ¼ EN : IN½2 : IN[1] : IN½0
OUT½6 ¼ EN : IN½2 : IN½1 : IN½0
OUT½5 ¼ EN : IN½2 : IN½1 : IN½0
OUT½4 ¼ EN : IN½2 : IN½1 : IN½0
OUT½3 ¼ EN : IN½2 : IN½1 : IN½0
OUT½2 ¼ EN : IN½2 : IN½1 : IN½0
OUT½1 ¼ EN : IN½2 : IN½1 : IN½0
OUT½0 ¼ EN : IN½2 : IN½1 : IN½0
IN [ 0]
IN [ 1]
IN [ 2]
EN
OUT[ 0]
IN [ 0]
IN [ 1]
IN [ 2]
EN
OUT[ 1]
IN [ 0]
IN [ 1]
IN [ 2]
EN
OUT[ 2]
IN [ 0]
IN [ 1]
IN [ 2]
EN
OUT[ 3]
IN [ 0]
IN [ 1]
IN [ 2]
EN
OUT[ 4]
IN [ 0]
IN [ 1]
IN [ 2]
EN
OUT[ 5]
IN [ 0]
IN [ 1]
IN [ 2]
EN
OUT[ 6]
IN [ 0]
IN [ 1]
IN [ 2]
EN
OUT[ 7]
Fig. 1.35 Logic circuit of a line decoder in Table 1.15
26
1
Review of Combinational Circuits

One-Bit Full Adder
The one-bit full adder has three inputs: A, B, and carry-in (CIN), and it produces two
outputs: sum (SUM) and carry-out (COUT). The symbolic representation of a full adder is
shown in Fig. 1.36.
The one-bit full adder simply adds the contents of its two inputs, A and B, to CIN, and
forms the truth table in Table 1.16.
We can obtain the minimized SOP expressions for SUM and COUT from the K-maps in
Figs. 1.37 and 1.38.
FA
A
B
COUT
CIN
SUM
Fig. 1.36 One-bit full adder symbol
00
01
11
10
0
1
0
1
0
1
0
1
0
1
AB
CIN
SUM
Fig. 1.37 SUM output of a one-bit full adder
Table 1.16 One-bit full adder truth table
CIN
0
0
0
0
1
1
1
A
B
SUM COUT
0
0
0
0
0
1
1
0
1
0
1
0
1
1
0
1
0
0
1
0
0
1
0
1
1
0
0
1
1
1
1
1
1
1.5
Basic Logic Blocks
27

Consequently,
SUM ¼ A : B : CIN þ A : B : CIN þ A : B : CIN þ A : B : CIN
¼ CIN : ðA : B þ A : BÞ þ CIN : ðA : B þ A : BÞ
¼ CIN : ðA  BÞ þ CIN : (A  B)
¼ A  B  CIN
Thus,
COUT ¼ CIN : B þ A : B þ A : CIN
¼ CIN : ðA þ BÞ þ A : B
The resultant logic circuits for the SUM and COUT outputs are shown in Fig. 1.39.
One-Bit Half Adder
The one-bit half adder has only two inputs, A and B with no CIN. The A and B inputs are
added to generate the SUM and COUT outputs. The symbolic representation of half-adder is
shown in Fig. 1.40.
00
01
11
10
0
1
0
0
1
0
1
0
1
1
AB
CIN
COUT
Fig. 1.38 COUT output of a one-bit full adder
CIN
A
B
A
B
COUT
A
B
CIN
SUM
Fig. 1.39 One-bit full adder logic circuit
28
1
Review of Combinational Circuits

The truth table given in Table 1.17 describes the functionality of the half adder.
From the truth table, the POS expressions for the SUM and COUT outputs can be written as:
SUM ¼ A  B
COUT ¼ A : B
Therefore, we can produce the SUM and the COUT circuits as shown in Fig. 1.41.
1.6
Combinational Mega Cells
Adders
One-bit full-adders can be cascaded serially to produce multiple-bit adder conﬁgurations.
There are three basic adder types:
HA
A
B
COUT
SUM
Fig. 1.40 One-bit half-adder symbol
Table 1.17 One-bit half-adder truth table
A
B
SUM COUT
0
0
0
0
0
1
1
0
1
0
1
0
1
1
0
1
A
B
SUM
A
B
COUT
Fig. 1.41 One-bit half adder logic circuit
1.5
Basic Logic Blocks
29

Ripple-Carry Adder
Carry-Look-Ahead Adder
Carry-Select Adder
However, hybrid topologies can also be formed by combining two or even three of these
conﬁgurations. For the sake of simplicity, we will limit the number of bits to four and
explain each topology in detail.
Ripple-Carry Adder
The ripple-carry adder is a cascaded conﬁguration of multiple one-bit full adders. The circuit
topology of a four-bit ripple carry adder is shown in Fig. 1.42. In this ﬁgure, the carry-out
output of a one-bit full adder is connected to the carry-in input of the next full adder to
propagate the carry bit from one adder to the next.
For the 0th bit of this adder, we have:
SUM½0 ¼ A½0  B½0  CIN½0
COUT½0 ¼ CIN½1 ¼ A½0 : B½0 þ CIN½0 : ðA½0 þ B½0Þ ¼ G½0 þ P½0 : CIN½0
where,
G[0] = A[0] . B[0] as the zeroth order generation term
P[0] = A[0] + B[0] as the zeroth order propagation term
FA0
FA1
FA2
FA3
A[3]
B[3]
SUM[3]
CIN[3]
CIN[0]
COUT[2]
A[2]
B[2]
A[1]
B[1]
A[0]
B[0]
CIN[2]
COUT[1]
CIN[1]
COUT[0]
SUM[2]
SUM[1]
SUM[0]
Fig. 1.42 Four-bit ripple-carry adder
30
1
Review of Combinational Circuits

For the ﬁrst bit:
SUM½1 ¼ A½1  B½1  CIN½1 ¼ A½1  B½1  ðG½0 þ P½0 : CIN½0Þ
COUT½1 ¼ CIN½2 ¼ G½1 þ P½1 : CIN½1
¼ G½1 þ P½1 : ðG½0 þ P½0 : CIN½0Þ ¼ G½1 þ P½1 : G½0
þ P½1 : P½0 : CIN½0
where,
G[1] = A[1] . B[1] as the ﬁrst order generation term
P[1] = A[1] + B[1] as the ﬁrst order propagation term
For the second bit:
SUM½2 ¼ A½2  B½2  CIN½2 ¼ A½2  B½2  fG½1 þ P½1 : ðG½0
þ P½0 : CIN½0Þg
¼ A½2  B½2  ðG½1 þ P½1 : G½0 þ P½1 : P½0 : CIN½0Þ
COUT½2 ¼ CIN½3 ¼ G½2 þ P½2 : CIN½2
¼ G½2 þ P½2 : fG½1 þ P½1 : ðG½0 þ P½0 : CIN½0Þg
¼ G½2 þ P½2 : G½1 þ P½2 : P½1 : G½0 þ P½2 : P½1 : P½0 : CIN½0
where,
G[2] = A[2] . B[2] as the second order generation term
P[2] = A[2] + B[2] as the second order propagation term
And for the third bit:
SUM½3 ¼ A½3  B½3  CIN½3
¼ A½3  B½3  fG½2 þ P½2 : fG½1 þ P½1 : ðG½0 þ P½0 : CIN½0Þgg
¼ A½3  B½3  ðG½2 þ P½2 : G½1 þ P½2 : P½1 : G½0
þ P½2 : P½1 : P½0 : CIN½0Þ
These functional expressions of the SUM and the COUT outputs also serve to estimate the
maximum and the minimum propagation delays for each bit of this adder.
The circuit diagram in Fig. 1.43 shows the maximum delay path from bit 0 to bit 3. In this
ﬁgure, the maximum gate delay from A[0] or B[0] inputs to SUM[0] is 2TXOR2, where
TXOR2 is a single two-input XOR gate delay.
The maximum gate delay from A[0] or B[0] to COUT[0] is 2TOR2 + TAND2 where TOR2
and TAND2 are the two-input OR gate and the two-input AND gate delays, respectively.
The gate delay from A[1] or B[1] to SUM[1] is still 2TXOR2; however, the delay from A[0]
or B[0] to SUM[1] is 2TOR2 + TAND2 + TXOR2, which is more than 2TXOR2 and must be
considered the maximum gate delay for this particular bit position and for more signiﬁcant bits.
1.6
Combinational Mega Cells
31

The maximum gate delay from A[0] or B[0] to COUT[1] is 3TOR2 + 2TAND2. It may make
more
sense
to
expand
the
expression
for
COUT[1]
as
COUT½1 ¼ G½1 þ P½1 :
G½0 þ P½1 : P½0 : CIN½0, and ﬁgure out if the overall gate delay, TOR2 + TAND3 + TOR3, is
smaller compared to 3TOR2 + 2TAND2. Here, TAND3 and TOR3 are the three-input AND and
the three-input OR gate delays, respectively.
The maximum gate delay from A[0] or B[0] to SUM[2] is 3TOR2 + 2TAND2 + TXOR2. When the
expression
for
SUM[2]
is
expanded
as
SUM½2 ¼ A½2  B½2  ðG½1 þ P½1 : G½0
þ P½1 : P½0 : CIN½0Þ, we see that this delay becomes TOR2 + TAND3 + TOR3 + TXOR2, and it
may be smaller than the original delay if TAND3 < 2TAND2 and TOR3 < 2TOR2.
The maximum gate delay from A[0] or B[0] to COUT[2] is 4TOR2 + 3TAND2.
When COUT[2] is expanded as COUT½2 ¼ G½2 þ P½2 : G½1 þ P½2 : P½1 : G½0 þ P½2 :
P½1 : P½0 : CIN½0; the maximum delay becomes TOR2 + TAND4 + TOR4, and it may be
smaller than the original delay if TAND4 < 3TAND2 and TOR4 < 3TOR2. Here, TAND4 and TOR4
are the four-input AND and the four-input OR gate delays, respectively.
Finally, the maximum delay from A [0] or B [0] to SUM [3] is 4TOR2 + 3TAND2 + TXOR2,
which is also the maximum propagation delay for this adder. When the functional expression
for SUM[3] is expanded as SUM½3 ¼ A½3  B½3  ðG½2 þ P½2 : G½1 þ P½2 : P½1 :
G½0 þ P½2 : P½1 : P½0 : CIN½0Þ; the total propagation delay becomes TOR2 + TAND4 +
TOR4 + TXOR2, and again it may be smaller compared to the original delay if TAND4 <
3TAND2 and TOR4 < 3TOR2.
A[3] B[3]
SUM[3]
CIN[0]
COUT[0] = CIN[1]
Minimum
Delay
Maximum
Delay
A[2] B[2]
A[2] B[2]
A[1] B[1]
A[1] B[1]
A[0] B[0]
A[0] B[0]
SUM[2]
SUM[1]
SUM[0]
COUT[1] = CIN[2]
COUT[2] = CIN[3]
Fig. 1.43 Logic circuit of the four-bit adder with the maximum and minimum delays
32
1
Review of Combinational Circuits

Carry-Look-Ahead Adder
The idea behind carry-look-ahead (CLA) adders is to create a topology where carry-in bits to
all one-bit full adders are available simultaneously. A four-bit CLA circuit topology is
shown in Fig. 1.44. In this ﬁgure, the SUM output of a more signiﬁcant bit does not have to
wait until the carry bit ripples from the least signiﬁcant bit position, but it gets computed
after some logic delay. In reality, all carry-in signals are generated by complex combina-
tional logic blocks called CLA hook-ups as shown in Fig. 1.44. Each CLA block adds a
certain propagation delay on top of the two-input XOR gate delay to produce a SUM output.
The earlier SUM and CIN expressions derived for the ripple carry adder can be applied to
the CLA adder to generate its functional equations.
Therefore,
SUM½0 ¼ A½0  B½0  CIN½0
SUM½1 ¼ A½1  B½1  CIN½1
SUM½2 ¼ A½2  B½2  CIN½2
SUM½3 ¼ A½3  B½3  CIN½3
CIN[1]
CIN[2]
CIN[3]
CIN[0]
COUT[0]
A[3]
B[3]
SUM[0]
SUM[1]
SUM[2]
SUM[3]
G[2] + P[2].G[1] + P[2].P[1].G[0] + P[2].P[1].P[0].CIN[0]
G[1] + P[1].G[0] + P[1].P[0].CIN[0]
FA0
FA1
FA2
FA3
A[2]
B[2]
A[1]
B[1]
A[0]
B[0]
Fig. 1.44 A four-bit carry-look-ahead adder
1.6
Combinational Mega Cells
33

where,
CIN½1 ¼ G½0 þ P½0 : CIN½0
CIN½2 ¼ G½1 þ P½1 : G½0 þ P½1 : P½0 : CIN½0
CIN½3 ¼ G½2 þ P½2 : G½1 þ P½2 : P½1 : G½0 þ P½2 : P½1 : P½0 : CIN½0
Therefore, CIN[1] is generated by the COUT[0] function within the zeroth (the least
signiﬁcant) full adder bit. However, CIN[2] and CIN[3] have to be produced by separate
logic blocks in order to provide the CIN signals for the second and the third (the most
signiﬁcant) full-adder bits.
According to Fig. 1.44, once a valid CIN[0] becomes available, it takes successively
longer times to generate valid CIN inputs to produce higher order SUM outputs due to the
increasing logic complexity in the CLA hook-ups.
Assume that TSUM0, TSUM1, TSUM2 and TSUM3 are the propagation delays corresponding
to the bits 0, 1, 2 and 3 with respect to the CIN[0] signal. We can approximate TSUM0 =
TXOR2. To compute TSUM1, we need to examine the expression for CIN[1]. In this
expression, P[0] . CIN[0] produces a two-input AND gate delay, and G[0] + (P[0] . CIN[0])
produces a two-input OR gate delay to be added on top of TXOR2. Therefore, TSUM1 becomes
TSUM1 = TAND2 + TOR2 + TXOR2. Similarly, the expressions for CIN[2] and CIN[3] produce
TSUM2 = TAND3 + TOR3 + TXOR2 and TSUM3 = TAND4 + TOR4 + TXOR2, respectively.
The maximum propagation delay for this adder is, therefore, TSUM3 = TAND4 + TOR4 +
TXOR2.
Despite the CLA adder’s advantage of being faster than the ripple-carry adder, in most
cases the extra CLA logic blocks make this adder topology occupy a larger chip area if the
number of adder bits is above eight.
Carry-Select Adder
Carry-Select Adders require two rows of identical adders. These adders can be as simple as
two rows of ripple-carry adders or CLA adders depending on the design requirements.
Fig. 1.45 shows the circuit topology of a four-bit carry-select adder composed of two rows
of ripple carry adders.
In this ﬁgure, the full adder at the least signiﬁcant bit position operates normally and
generates a value for COUT[0]. As this value is generated the two one-bit full adders, one
with CINA[1] = 0 and the other with CINB[1] = 1, simultaneously generate SUMA[1] and
SUMB[1]. If COUT[0] becomes equal to one, SUMB[1] gets selected and becomes SUM[1];
otherwise, SUMA[1] becomes the SUM[1] output. Whichever value ends up being SUM[1],
it is produced after a 2-1 MUX propagation delay.
However, we cannot say the same in generating SUM[2] and SUM[3] outputs in this
ﬁgure. After producing SUM[1], carry ripples through both adders normally to generate
SUM[2] and SUM[3]; hence, the speed advantage of having two rows of adders becomes
34
1
Review of Combinational Circuits

negligible. Therefore, we must be careful when employing a carry-select scheme before
designing an adder, as this method practically doubles the chip area.
Even though carry-select topology is ineffective in speeding up this particular four-bit
adder, it may be advantageous if employed to an adder with greater number of bits in
conjunction with another adder topology such as the CLA.
Example 1.14: Design a 32-bit carry-look-ahead adder. Compute the worst-case propa-
gation delay in the circuit.
We need to be careful in dealing with the CLA hook-ups when generating higher order
terms because the complexity of these logic blocks can “grow” exponentially in size while
they may only provide marginal speed gain when compared to ripple-carry scheme.
SUM[0]
CIN[0]
COUT[0]
0
1
0
1
0
1
A[0]
B[0]
FA
FA
FA
FA
FA
FA
FA
SUM[1]
SUM[2]
SUM[3]
A[3]
B[3]
CINA[1] = 0
CINB[1] = 1
CINA[2]
CINB[2]
CINA[3]
CINB[3]
SUMB[1]
SUMA[1]
A[2]
B[2]
A[1]
B[1]
SUMB[2]
SUMA[2]
SUMB[3]
SUMA[3]
Fig. 1.45 A four-bit carry-select adder
1.6
Combinational Mega Cells
35

Therefore, the ﬁrst step of the design process is to separate the adder into eight-bit
segments with full CLA hook-ups. The proposed topology is shown in Fig. 1.46.
Each eight-bit CLA segment contains six CLA hook-ups from CLA0 to CLA5 as shown
in Fig. 1.47.
SUM[7:0]
A[7:0]
CIN[0]
B[7:0]
SUM[15:8]
CIN[8]
B[15:8]
A[15:8]
SUM[23:16]
CIN[16]
B[23:16]
A[23:16]
SUM[31:24]
CIN[24]
B[31:24]
A[31:24]
8
8
8
8
8
8
8
8
8
8
8
8
8-bit CLA
8-bit CLA
8-bit CLA
8-bit CLA
Fig. 1.46 A 32-bit carry-look-ahead topology
FA
FA
FA
FA
FA
FA
FA
SUM[7]
A[7]
B[7]
FA
COUT[7]
CIN[7]
CLA0
CLA1
CLA2
CLA3
CLA4
CLA5
SUM[6]
A[6]
B[6]
CIN[6]
SUM[5]
A[5]
B[5]
CIN[5]
SUM[4]
A[4]
B[4]
CIN[4]
SUM[3]
A[3]
B[3]
CIN[3]
SUM[2]
A[2]
B[2]
CIN[2]
SUM[1]
A[1]
B[1]
CIN[1]
SUM[0]
A[0]
B[0]
CIN[0]
Fig. 1.47 An eight-bit segment of the carry-look ahead adder in Fig. 1.46
CIN and SUM expressions from bit 0 through bit 7 are given below.
SUM½0 ¼ A½0  B½0  CIN½0
SUM 1½  ¼ A½1  B½1  CIN½1
where;
CIN½1 ¼ G½0 þ P½0 : CIN½0
36
1
Review of Combinational Circuits

SUM½2 ¼ A½2  B½2  CIN½2
where,
CIN½2 ¼ G½1 þ P½1 : G½0 þ P½1 : P½0 : CIN½0
SUM½3 ¼ A½3  B½3  CIN½3
where;
CIN½3 ¼ G½2 þ P½2 : G½1 þ P½2 : P½1 : G½0 þ P½2 : P½1 : P½0 : CIN½0
SUM½4 ¼ A½4  B½4  CIN½4
where;
CIN½4 ¼ G½3 þ P½3 : ðG½2 þ P½2 : G½1 þ P½2 : P½1 : G½0
þ P½2 : P½1 : P½0 : CIN½0Þ
SUM½5 ¼ A½5  B½5  CIN½5
where;
CIN½5 ¼ G½4 þ P½4 : fG½3 þ P½3 : ðG½2
þ P½2 : G½1 þ P½2 : P½1 : G½0 þ P½2 : P½1 : P½0 : CIN½0Þg
¼ G½4 þ P½4 : G½3 þ P½4 : P½3 : ðG½2 þ P½2 : G½1
þ P½2 : P½1 : G½0 þ P½2 : P½1 : P½0 : CIN½0Þ
SUM½6 ¼ A½6  B½6  CIN½6
where;
CIN½6 ¼ G½5 þ P½5 : fG½4 þ P½4 : G½3 þ P½4 : P½3 : ðG½2 þ P½2 : G½1
þ P½2 : P½1 : G½0 þ P½2 : P½1 : P½0 : CIN½0Þg
¼ G½5 þ P½5 : G½4 þ P½5 : P½4 : G½3 þ P½5 : P½4 : P½3 : ðG½2
þ P½2 : G½1 þ P½2 : P½1 : G½0 þ P½2 : P½1 : P½0 : CIN½0Þ
SUM ½7 ¼ A½7  B½7  CIN½7
where,
CIN ½7 ¼ G½6 þ P½6 : fG½5 þ P½5 : G½4 þ P½5 : P½4 : G½3
þ P½5 : P½4 : P½3 : ðG½2 þ P½2 : G½1 þ P½2 : P½1 : G½0
þ P½2 : P½1 : P½0 : CIN½0Þg
And ﬁnally,
1.6
Combinational Mega Cells
37

COUT½7 ¼ CIN½8 ¼ G½7 þ P½7 : fG½6 þ P½6 : fG½5 þ P½5 : G½4
þ P½5 : P½4 : G½3 þ P½5 : P½4 : P½3 : ðG½2 þ P½2 : G½1
þ P½2 : P½1 : G½0 þ P½2 : P½1 : P½0 : CIN½0Þgg
¼ G½7 þ P½7 : G½6 þ P½7 : P½6 : fG½5 þ P½5 : G½4
þ P½5 : P½4 : G½3 þ P½5 : P½4 : P½3 : ðG½2 þ P½2 : G½1
þ P½2 : P½1 : G½0 þ P½2 : P½1 : P½0 : CIN½0Þg
In these derivations, particular attention was paid to limit the number of inputs to four in
all AND and OR gates since larger gate inputs are counterproductive in reducing the overall
propagation delay.
From these functional expressions, maximum propagation delays for SUM[7] and COUT[7]
are estimated using the longest logic strings in Fig. 1.48.
For SUM[7], the minterm, P[2] . P[1] . P[0] . CIN[0], generates the ﬁrst four-input
AND gate. This is followed by a four-input OR gate whose minterms are G[2], P[2] . G[1],
P[2] . P[1] . G[0], and P[2] . P[1] . P[0] . CIN[0]. The four-input OR gate is then cascaded by
a four-input AND, a four-input OR, a two-input AND, a two-input OR and a two-input
XOR-gates in successive order. The entire string creates a propagation delay of TSUM7 = 2
(TAND4 + TOR4) + TAND2 + TOR2 + TXOR2 from CIN[0] to SUM[7].
For COUT[7], the longest propagation delay between CIN[0] and COUT[7] is TCOUT7 = 2
(TAND4 + TOR4) + TAND3 + TOR3. The delays for the rest of the circuit in Fig. 1.46 become
easy to determine since the longest propagation delays have already been evaluated.
CIN[0]
P2
P0
P1
G2
P5
P3
P4
G5
P6
G6
A7 + B7
SUM[7]
CIN[0]
P2
P0
P1
G2
P5
P3
P4
G5
P7
G7
COUT[7] = CIN[8]
Fig. 1.48 Propagation delay estimation of the eight-bit carry-look-ahead adder in Fig. 1.47
38
1
Review of Combinational Circuits

The delay from CIN[0] to SUM[15], TSUM15, simply becomes equal to the sum of TCOUT7
and TSUM7. In other words, TSUM15 = 4(TAND4 + TOR4) + TAND3 + TOR3 + TAND2 + TOR2 +
TXOR2. Similarly, the delay from CIN[0] to COUT[15], TCOUT15, is equal to TCOUT15 = 4
(TAND4 + TOR4) + 2(TAND3 + TOR3).
The remaining delays are evaluated in the same way and lead to the longest propagation
delay in this circuit, TSUM31, from CIN[0] to SUM[31].
Thus,
TSUM31 ¼ 3 2 TAND4 þ TOR4
ð
Þ þ TAND3 þ TOR3
½
 þ 2 TAND4 þ TOR4
ð
Þ þ TAND2
þ TOR2 þ TXOR2
or
TSUM31 ¼ 8ðTAND4 þ TOR4Þ þ 3 TAND3 þ TOR3
ð
Þ þ TAND2 þ TOR2 þ TXOR2
Example 1.15: Design a 32-bit hybrid carry-select/carry-look-ahead adder. Compute the
worst-case propagation delay in the circuit.
Large adders are where the carry-select scheme shines! This is a classical example in
which the maximum propagation delay is reduced considerably compared to the CLA
scheme examined in Example 1.14.
As mentioned earlier, a twin set of an adder conﬁguration is required by the carry-select
scheme. The adders can be ripple-carry, carry-look-ahead or the combination of the two.
In this example, the 32-bit adder is again divided in eight-bit segments where each
segment consists of a full CLA adder as shown in Fig. 1.49. The ﬁrst segment, CLA-0, is a
single unit which produces COUT[7] with full CLA hook-ups. The rest of the eight-bit
segments are mirror images of each other, and they are either named A-segments (A1, A2
and A3) or B-segments (B1, B2 and B3).
As the CLA-0 generates a valid COUT[7], the CLA-A1 and CLA-B1 simultaneously
generate COUTA[15] and COUTB[15]. When COUT[7] ﬁnally forms, it selects either
COUTA[15] or COUTB[15] depending on its value. This segment produces COUT[15] and
SUM[15:8].
COUT[15], on the other hand, is used to select between COUTA[23] and COUTB[23],
both of which have already been formed when COUT[15] arrives at the 2-1 MUX as a
control input. COUT[15] also selects between SUMA[23:16] and SUMB[23:16] to deter-
mine the correct SUM[23:16].
Similarly, COUT[23] is used as a control input to select between SUMA[31:24] and
SUMB[31:24]. If there is a need for COUT[31], COUT[23] can also be used to determine
the value of COUT[31].
1.6
Combinational Mega Cells
39

The maximum propagation delay for the 32-bit carry-select/CLA adder can be found using
the logic string in Fig. 1.50. The ﬁrst section of this string from CIN[0] to COUT[7] is
identical to the eight-bit CLA carry delay in Fig. 1.48. In addition to the CLA delay, there are
three cascaded MUX stages which correspond to the generation of COUT[15], COUT[23]
and SUM[31].
Considering that a 2-1 MUX propagation delay consists of a two-input AND gate delay
and a two-input OR gate delay, we obtain the maximum propagation delay for this 32-bit
adder as follows:
TSUM31 ¼ 2 TAND4 þ TOR4
ð
Þ þ TAND3 þ TOR3 þ 3 TAND2 þ TOR2
ð
Þ
CIN[0]
P2
P0
P1
G2
P5
P3
P4
G5
P7
G7
COUT[7]
0
1
0
1
0
1
SUM[31]
SUMA[31]
SUMB[31]
COUTA[23]
COUTB[23]
COUTA[15]
COUTB[15]
COUT[15]
COUT[23]
Fig. 1.50 Maximum delay propagation of the 32-bit adder in Fig. 1.49
SUM[7:0]
A[7:0]
CIN[0]
B[7:0]
B[15:8]
A[15:8]
B[23:16]
A[23:16]
0
B[31:24]
A[31:24]
8
8
8
8
8
8
8
8
8
8
8
8
8-bit CLA-0
8-bit CLA-A1
8-bit CLA-A2
8-bit CLA-A3
SUM[15:8]
B[15:8]
A[15:8]
SUM[23:16]
B[23:16]
A[23:16]
SUM[31:24]
B[31:24]
A[31:24]
8
8
8
8
8
8
8
8
8
8-bit CLA-B1
8-bit CLA-B2
8-bit CLA-B3
1
0
1
0
1
8
0
1
0
1
8
0
1
0
1
8
0
1
COUT[7]
SUMA[15:8]
SUMB[15:8]
SUMA[23:16]
SUMB[23:16]
SUMA[31:24]
SUMB[31:24]
COUT[15]
COUT[23]
Fig. 1.49 A 32-bit carry-look-ahead/carry-select adder
40
1
Review of Combinational Circuits

Considering the maximum propagation delay in Example 1.14, this delay is shorter by at
least 6(TAND4 + TOR4). Larger carry-select/carry-look-ahead adder schemes provide greater
speed beneﬁts at the cost of approximately doubling the adder area.
Subtractors
Subtraction is performed by a technique called twos (2s) complement addition. Twos
complement addition ﬁrst requires complementing one of the adder inputs (1s complement)
and then adding 1 to the least signiﬁcant bit.
Example 1.16: Form −4 in four bits using 2s complement.
−4 is formed by inverting all four bits of +4 (1s complement) and then adding one to it.
Therefore, the ﬁrst step of this process is to represent +4 in four-bit binary format, which
is 0100. The second step is to determine its 1s complement, which is 1011. And the last step
is to ﬁnd its 2s complement, which is 1011 + 0001 = 1100.
Here, logic 0 signiﬁes a positive sign, and logic 1 signiﬁes a negative sign at the most
signiﬁcant bit position.
Example 1.17: Add +4 to −4 using 2s complement.
The four bit binary format of +4 is 0100. The 2s complement of +4 is 1100. If we add two
numbers together, we obtain 0100 + 1100 = 1 0000, where logic 1 at the overﬂow bit
position is neglected due to the four-bit binary format. Therefore, the ﬁnal result becomes
0000 = 0 as expected.
Subtractors function according to the 2s complement addition. We need to form the 1s
complement of the adder input to be subtracted and then add CIN[0] = 1 to the result to
perform subtraction.
Figure 1.51 illustrates the topology of a 32-bit subtractor where input B is complemented,
and CIN[0] is tied to logic 1 to satisfy the 2s complement addition requirements to produce
A−B.
CIN[0] = 1
SUB[31:0]
B[31:0]
A[31:0]
32
SUBTRACTOR
32
32
Fig. 1.51 A symbolic representation of a 32-bit subtractor
1.6
Combinational Mega Cells
41

Shifters
There are two types of shifters in logic design:
Linear shifters
Barrel shifters
Linear Shifters
A linear shifter shifts its inputs by a number of bits to the right or to the left, and routes the
result to its output.
Example 1.18: Design a four-bit linear shifter that shifts its inputs to the left by one bit and
produces logic 0 at the least signiﬁcant output bit when SHIFT = 1. When SHIFT = 0, the
shifter routes each input directly to the corresponding output.
The logic diagram for this shifter is given in Fig. 1.52. In this ﬁgure, each input is
connected to the port 0 terminal of the 2-1 MUX as well as the port 1 terminal of the next
MUX at the higher bit position. Therefore, when SHIFT = 1, logic 0, IN[0], IN[1], and IN[2]
are routed through port 1 terminal of each 2-1 MUX and become OUT[0], OUT[1], OUT[2],
and OUT[3], respectively. When SHIFT = 0, each input goes through port 0 terminal of the
corresponding 2-1 MUX and becomes the shifter output.
0
1
IN[3]
OUT[3]
0
1
IN[2]
OUT[2]
0
1
IN[1]
OUT[1]
0
1
IN[0]
OUT[0]
0
SHIFT
Fig. 1.52 Four-bit linear shifter
Barrel Shifters
Barrel shifters rotate their inputs in either clockwise or counterclockwise direction by a
number of bits and propagate them to their outputs.
Example 1.19: Design a four-bit barrel shifter that rotates its inputs in a clockwise direction
by one bit when SHIFT = 1. When SHIFT = 0, the shifter routes each input directly to the
corresponding output.
The logic diagram for this shifter is given in Fig. 1.53. The only difference between this
circuit and the linear shifter in Fig. 1.52 is the removal of logic 0 from the least signiﬁcant
bit, and connecting this input to the IN[3] pin instead. Consequently, this leads to OUT[0] =
IN[3], OUT[1] = IN[0], OUT[2] = IN[1] and OUT[3] = IN[2] when SHIFT = 1, and OUT[0]
= IN[0], OUT[1] = IN[1], OUT[2] = IN[2] and OUT[3] = IN[3] when SHIFT = 0.
42
1
Review of Combinational Circuits

Example 1.20: Design a four-bit barrel shifter that rotates its inputs clockwise by one or
two bits.
First, there must be three control inputs specifying “no shift”, “shift 1 bit” and “shift 2
bits”. This requires a two-bit control input, SHIFT[1:0], as shown in Table 1.18. All control
inputs in this table are assigned arbitrarily. However, it makes sense to assign a “No shift”
input to SHIFT[1:0] = 0, a “Shift 1 bit” input to SHIFT[1:0] = 1 and a “Shift 2 bits” input to
SHIFT[1:0] = 2 for the actual rotation amount.
According to this table, if there is no shift, each input bit is simply routed to its own output.
If the “Shift 1 bit” input is active, then each input is routed to the neighboring output at the
next signiﬁcant bit position. In other words, IN[3] rotates clockwise and becomes OUT[0].
Similarly, IN[0], IN[1] and IN[2] shift one bit to the left and become OUT[1], OUT[2] and
OUT[3], respectively. If the “Shift 2 bits” input becomes active, then each input is routed to
the output of the neighboring bit which is two signiﬁcant bits higher. This rotates all input
bits twice before they are routed to the output, producing OUT[0] = IN[2], OUT[1] = IN[3],
OUT[2] = IN[0] and OUT[3] = IN[1].
Therefore, using Table 1.18, we can conclude the logic diagram in Fig. 1.54.
0
1
IN[3]
OUT[3]
0
1
IN[2]
OUT[2]
0
1
IN[1]
OUT[1]
0
1
IN[0]
OUT[0]
SHIFT
Fig. 1.53 Four-bit barrel shifter
Table 1.18 A four-bit barrel shifter truth table
0
0
1
0
0
1
1
1
No shift
Shift 1 bit 
Shift 2 bits
No shift
SHIFT[1]
SHIFT[0]
OPERATION
OUT[3]
OUT[2]
OUT[1]
OUT[0]
IN[3]
IN[2]
IN[1]
IN[0]
IN[2]
IN[1]
IN[0]
IN[3]
IN[1]
IN[0]
IN[3]
IN[2]
IN[3]
IN[2]
IN[1]
IN[0]
1.6
Combinational Mega Cells
43

A more detailed view of Fig. 1.54 is given in Fig. 1.55.
SHIFT[1]
SHIFT[0]
shift 1 bit
shift 2 bits
no shift
IN[1]
shift 2 bits
IN[2]
shift 1 bit
IN[3]
no shift
OUT[3]
IN[0]
shift 2 bits
IN[1]
shift 1 bit
IN[2]
no shift
OUT[2]
IN[3]
shift 2 bits
IN[0]
shift 1 bit
IN[1]
no shift
OUT[1]
IN[2]
shift 2 bits
IN[3]
shift 1 bit
IN[0]
no shift
OUT[0]
Fig. 1.55 Logic circuit of the barrel shifter in Fig. 1.54
0
1
IN[3]
OUT[3]
SHIFT
2
IN[2]
IN[1]
0
1
IN[2]
OUT[2]
2
IN[1]
IN[0]
0
1
IN[1]
OUT[1]
2
IN[0]
IN[3]
0
1
IN[0]
OUT[0]
2
IN[3]
IN[2]
2
SHIFT[1:0]
Fig. 1.54 Logic diagram of the barrel shifter in Table 1.18
44
1
Review of Combinational Circuits

Multipliers
There are two types of multipliers:
Array multiplier
Booth multiplier
An array multiplier is relatively simple to design, but it requires a large number of gates.
A Booth multiplier, on the other hand, requires fewer gates but its implementation follows a
rather lengthy algorithm.
Array Multiplier
Similar to our everyday hand multiplication method, an array multiplier generates all partial
products before summing each column in the partial product tree to obtain the result. This
scheme is explained in Fig. 1.56 for a four-bit array multiplier.
The rules of partial product generation are as follows:
1. The zeroth partial product aligns with multiplicand and multiplier bit columns.
2. Each partial product is shifted one bit to the left with respect to the previous one once it is
created.
3. Each partial product is the exact replica of the multiplicand if the multiplier bit is one.
Otherwise, it is deleted.
Example 1.21: Multiply 1101 and 1001 according to the rules of array multiplication.
Suppose 1101 is the multiplicand and 1001 is the multiplier. For a four-bit multiplier, four
partial products must be formed. The bits that belong to each column of the partial product
tree are then added successively while the resultant carry bits are propagated to more
signiﬁcant bit positions. This process is illustrated in Fig. 1.57.
A[3]
A[2]
A[1]
A[0]
MULTIPLIER
B[3]
B[2]
B[1]
B[0]
MULTIPLICAND
B[0].A[2]
B[0].A[1]
B[0].A[0]
B[0].A[3]
0th PARTIAL PRODUCT
1st PARTIAL PRODUCT
2nd PARTIAL PRODUCT
3rd PARTIAL PRODUCT
SUM[0]
SUM[1]
SUM[2]
SUM[3]
SUM[4]
SUM[5]
SUM[6]
SUM OUTPUT
SUM[7]
B[1].A[2]
B[1].A[1]
B[1].A[0]
B[1].A[3]
B[2].A[2]
B[2].A[1]
B[2].A[0]
B[2].A[3]
B[3].A[2]
B[3].A[1]
B[3].A[0]
B[3].A[3]
Fig. 1.56 4x4 array multiplier algorithm
1.6
Combinational Mega Cells
45

Example 1.22: Design the partial product tree for a four-bit array multiplier.
Following the convention in Fig. 1.56 and the rules of partial product generation for an
array multiplier, we can implement the partial product tree as shown in Fig. 1.58.
In this ﬁgure, partial product elements of the zeroth partial product, B[0].A[3], B[0].A[2],
B[0].A[1] and B[0].A[0], are replaced by PP0[3:0] for purposes of better illustration.
Similarly, PP1[3:0], PP2[3:0] and PP3[3:0] are the new partial product outputs corre-
sponding to the rows one, two and three.
Example 1.23: Design a full adder tree responsible for adding every partial product in the
partial product tree for a four-bit array multiplier.
After generating the partial products, the next step in the design is to add the partial product
elements column by column to generate the SUM outputs, SUM[7:0], while propagating carry
bits to higher order columns. Following the naming convention in Fig. 1.58, all 16 partial
1
0
A[3]
B[0]
PP0[2]
1
0
A[2]
PP0[1]
1
0
A[1]
1
0
A[0] 0
PP0[3]
0
0
0
PP0[0]
0th PARTIAL PRODUCT
1
0
B[1]
PP1[2]
1
0
PP1[1]
1
0
1
0
PP1[3]
PP1[0]
1st PARTIAL PRODUCT
1
0
B[2]
PP2[2]
1
0
PP2[1]
1
0
1
0
PP2[3]
PP2[0]
2nd PARTIAL PRODUCT
1
0
B[3]
PP3[2]
1
0
PP3[1]
1
0
1
0
PP3[3]
PP3[0]
3rd PARTIAL PRODUCT
A[3]
A[2]
A[1]
A[0] 0
0
0
0
A[3]
A[2]
A[1]
A[0] 0
0
0
0
A[3]
A[2]
A[1]
A[0] 0
0
0
0
Fig. 1.58 4x4 array multiplier bit selector tree
0
1
1
1
0
1
1
0
1
1
0
1
0
0
0
0
0
0
0
0
1
1
0
1
0
1
1
1
1
1
0
0th PARTIAL PRODUCT
1st PARTIAL PRODUCT
2nd PARTIAL PRODUCT
3rd PARTIAL PRODUCT
MULTIPLIER
MULTIPLICAND
SUM OUTPUT
Fig. 1.57 4x4 array multiplier algorithm example
46
1
Review of Combinational Circuits

product elements are then fed to the carry-propagate adder in Fig. 1.59. The box outlined by
dashed lines shows how the carry propagation takes place from one column to the next.
Booth Multiplier
The Booth multiplier scheme halves the number of partial products using a lengthy algo-
rithm given below.
Assume that the product of two binary integers, X and Y, forms P = X.Y, where X is a
multiplicand and Y is a multiplier.
In binary form, Y is expressed in powers of two:
Y ¼
Xn1
k¼0 yk2k
where, the most signiﬁcant bit, yn-1, corresponds to the sign bit. When yn-1 = 0, Y is
considered a positive number, otherwise it is a negative number as mentioned earlier in the
2s complement representation of integers.
In this section, we examine the Booth multiplication algorithm when Y is both a positive
and a negative number.
CASE 1: Y > 0, thus yn-1 = 0.
We can express a kth term of Y as:
SUM[7]
PP1[0]
PP0[1]
PP0[0]
PP1[1]
PP0[2]
PP1[2]
PP0[3]
PP3[0]
PP2[1]
PP2[0]
PP2[2]
PP1[3]
PP3[1]
PP3[2]
PP2[3]
PP3[3]
FA
FA
FA
FA
FA
HA
FA
FA
FA
HA
HA
HA
SUM[6]
SUM[5]
SUM[4]
SUM[3]
SUM[2]
SUM[1]
SUM[0]
CARRY 
PROPAGATION
Fig. 1.59 An eight-bit propagate adder for the bit selector tree in Fig. 1.58
1.6
Combinational Mega Cells
47

yk2k ¼ 2yk  yk
ð
Þ2k¼ 2yk1=2 2yk


2k
¼ yk2k þ 1  2yk2k1
Thus:
Y ¼
Xn1
k¼0 yk2k ¼
Xn1
k¼0 yk2k þ 1  2yk2k1


¼ yn12n  2yn12n2
þ yn22n2
þ yn32n22yn32n4
þ yn42n4
:
:
:
þ y3242y322
þ y222
þ y1222y120
þ y020
Regrouping the terms of the same power yields:
Y ¼ yn12n þ 2n2 2yn1 þ yn2 þ yn3
ð
Þ
þ 2n4 2yn3 þ yn4 þ yn5
ð
Þ
:
:
:
þ 22 2y3 þ y2 þ y1
ð
Þ
þ 20 2y1 þ y0 þ y1
ð
Þ
But, yn-1 = 0 and y-1 = 0 since Y > 0
Y ¼ 2n2 2yn1 þ yn2 þ yn3
ð
Þ
þ 2n4 2yn3 þ yn4 þ yn5
ð
Þ
:
:
:
þ 22 2y3 þ y2 þ y1
ð
Þ
þ 20 2y1 þ y0 þ y1
ð
Þ
48
1
Review of Combinational Circuits

Now, let’s deﬁne a new set of coefﬁcients:
zk ¼ 2 yk þ 1 þ yk þ yk1
Then:
Y ¼
Xn2
k¼0 zk2k
where, k ¼ 0; 2;. . .; n  4
ð
Þ; n  2
ð
Þ:
When X is multiplied by Y, one obtains:
P ¼ X:Y ¼
Xn2
k¼0 zk:X
ð
Þ:2k
where, the number of partial products in the product term, P, is reduced by half.
Each zk = −2yk+1 + yk + yk-1 depends on the value of three adjacent bits, yk+1, yk and yk-1.
This is tabulated in Table 1.19.
Therefore, each partial product, (zk.X), becomes one of the ﬁve different forms:
zk:X
ð
Þ ¼ 0, + X,  X; þ 2X; 2X
These partial products can easily be obtained by the following methods:
For zk.X = 0, all multiplicand bits are replaced by 0.
For zk.X = +X, all multiplicand bits are multiplied by one.
For, zk.X = +2X, all multiplicand bits are shifted left by one bit.
For zk.X = −X, the multiplicand is 2s complemented.
For zk.X = −2X, all multiplicand bits are shifted left by one bit to form +2X, and then 2s
complemented to form −2X.
Now, the time has come to investigate when Y is negative.
CASE 2: Y < 0, thus yn-1 = −1
The ﬁrst step is to sign-extend Y by one bit. Sign extension does not change the actual
value of Y but increases the terms from n to (n+1). Thus:
Table 1.19 Booth encoder truth table
yk+1
yk
zk
yk-1
0
0
0
0
0
1
0
1
0
0
1
1
1
0
0
1
0
1
1
1
0
1
1
1
0
1
1
2
-2
-1
-1
0
1.6
Combinational Mega Cells
49

Y ¼ 2n þ
Xn1
k¼0 yk2k
Let us consider:
Xn1
k¼0 2k¼ 1 þ 2 þ 22 þ . . . þ 2n1 ¼ f
Then,
zk:X
ð
Þ ¼ 0, þ X,  X, þ 2X; 2X
Thus:
f ¼ 2f  f ¼ 2n1
or
2n¼ 1 þ f ¼ 1 þ
Xn1
k¼0 2k
Substituting −2n into Y yields:
Y ¼ 2n þ
Xn1
k¼0 yk2k ¼  1 
Xn1
k¼0 2k þ
Xn1
k¼0 yk2k ¼ 1 þ
Xn1
k¼0 ðyk  1Þ2k
or
Y ¼ 1 þ
Xn1
k¼0 ð1ykÞ2k
However, (1 – yk) = 1 when yk = 0, and (1 – yk) = 0 when yk = 1. That means:
1  yk
ð
Þ ¼ yk
Thus:
Y ¼ 1 þ
Xn1
k¼0 yk 2k
The same mathematical manipulation applied to yk 2k in CASE 1 can also be applied to yk 2k.
yk 2k¼ ð2 yk  ykÞ2k ¼ yk 2:2k  yk 2:1=2 :2k
50
1
Review of Combinational Circuits

Therefore,
Xn1
k¼0 yk 2k ¼
Xn1
k¼0 ðyk 2:2k  yk 2: 1=2:2kÞ
¼
Xn1
k¼0 yk 2k þ 1  yk 2:2k1
¼ yn1 2n  yn1 2:2n2
þ yn2 2n2
þ yn3 2n2  yn3 2:2n4
þ yn4 2n4
:
:
:
þ y3 24  y3 2:22
þ y2 22
þ y1 22  y1 2:20
þ 20 y0
¼ yn1 2n
þ ð2 yn1 þ yn2 þ yn3Þ 2n2
þ ð2 yn3 þ yn4 þ yn5Þ 2n4
:
:
:
þ ð2 y3 þ y2 þ y1Þ 22
þ ð2 y1 þ y0 þ y1Þ 20
Here, y1 ¼ 0:
Then,
 Y ¼ 1 þ
Xn1
k¼0 yk 2k
¼ yn1 2n
þ ð2 yn1 þ yn2 þ yn3Þ 2n2
þ ð2 yn3 þ yn4 þ yn5Þ 2n4
:
:
:
þ ð2 y3 þ y2 þ y1Þ 22
þ ð2 y1 þ y0 þ y1Þ 20 þ 1
1.6
Combinational Mega Cells
51

However, the sign-extended term, yn1 2n¼ 1
Thus,
Y ¼ 1 þ
Xn1
k¼0 yk 2k
¼ ð2 yn1 þ yn2 þ yn3Þ 2n2
þ ð2 yn3 þ yn4 þ yn5Þ 2n4
:
:
:
þ ð2 y3 þ y2 þ y1Þ 22
þ ð2 y1 þ y0 þ y1Þ 20
Let
wk ¼ 2yk þ 1 þ yk þ yk1
Then,
 Y ¼
Xn2
k¼0 wk2k
where; k ¼ 0; 2; . . . ; n  4
ð
Þ; n  2
ð
Þ:
But,
wk ¼  2yk þ 1 þ yk þ yk1 ¼ 2 1  yk þ 1


þ 1  yk
ð
Þ þ 1  yk1
ð
Þ
¼ 2yk þ 1  yk  yk1 ¼ zk
Then,
Y ¼
Xn2
k¼0 wk2k ¼ 
Xn2
k¼0 zk2k
or
Y ¼ Pn2
k¼0 zk2k which is the same equation for Y > 0.
Therefore, for both positive and negative values of Y, we have:
Y ¼
Xn2
k¼0 zk2k where; k ¼ 0; 2; . . . ; n  4
ð
Þ; n  2
ð
Þ:
where, zk = -2yk+1 + yk + yk-1
Example 1.24: Starting from the generation of its partial products, design an eight-bit
Booth multiplier.
The multiplier term, Y, for the eight-bit Booth multiplier follows the encoded expression:
52
1
Review of Combinational Circuits

Y ¼
X6
k¼0 zk2k ¼ z020 þ z222 þ z424 þ z626
Where, the encoded multiplier coefﬁcients are:
z0 ¼ 2y1 þ y0 þ y1 ¼ 2y1 þ y0
z2 ¼ 2y3 þ y2 þ y1
z4 ¼ 2y5 þ y4 þ y3
z6 ¼ 2y7 þ y6 þ y5
Thus, P = X.Y yields:
P ¼ 20 X:z0
ð
Þ þ 22 X:z2
ð
Þ þ 24 X:z4
ð
Þ þ 26 X:z6
ð
Þ
This reduces the number of partial products from eight to four as shown in Fig. 1.60. In
this ﬁgure, u0, u1, u2, and u3 are added to the least signiﬁcant bit position of each partial
product to handle cases where the partial product becomes −X, −2X.
For cases +X, +2X and 0, all u-terms become equal to zero. All partial products are
sign-extended and nine bits in length to be able to handle ± 2X.
a8
a8
a8
a8
a8
a8
a8
a8
a7
a6
a5
a4
a3
a2
a1
a0
u0
b8
b8
b8
b8
b8
b8
b7
b6
b5
b4
b3
b2
b1
b0
0
0
u1
c8
c8
c8
c8
c7
c6
c5
c4
c3
c2
c1
c0
0
0
0
0
u2
d8
d8
d7
d6
d5
d4
d3
d2
d1
d0
0
0
0
0
0
0
u3
z0X
z2X
z4X
z6X
s15
s14
s13
s12
s11
s10
s9
s8
s7
s6
s5
s4
s3
s2
s1
s0
9-bit partial product due to a possible left shift
sign extension
SUM
Fig. 1.60 Partial product tree of an eight-bit Booth multiplier
1.6
Combinational Mega Cells
53

The calculation of the ﬁnal product can be further simpliﬁed if the sign extension terms
are eliminated. Let us add all the sign extension terms and form the term, SE, as shown
below:
SE ¼ a8: 215 þ . . . þ 28


þ b8:ð215 þ . . .210Þ þ c8: 215 þ . . .212


þ d8: 215 þ 214


But,
215 þ . . . þ 28 ¼ 28: 27 þ . . . þ 1


¼ 28: 28  1


¼ 216  28
215 þ . . . þ 210 ¼ 210: 25 þ . . . þ 1


¼ 210: 26  1


¼ 216210
215 þ . . . þ 212 ¼ 212: 23 þ . . . þ 1


¼ 212: 24  1


¼ 216212
215 þ 214 ¼ 214: 2 þ 1
ð
Þ ¼ 214: 22  1


¼ 216214
SE ¼ a8:216  a8:28 þ b8:216  b8:210 þ c8:216  c8:212 þ d8:216  d8:214
¼ 216: a8 þ b8 þ c8 þ d8
ð
Þ  a8:28  b8:210  c8:212  d8:214
But,
 a8 ¼ a8  1
 b8 ¼ b8  1
 c8 ¼ c8  1
 d8 ¼ d8  1
Thus,
SE ¼ 216: a8 þ b8 þ c8 þ d8
ð
Þ þ 28:ða8  1Þ þ 210:ðb8  1Þ þ 212:ðc8  1Þ
þ 214:ðd8  1Þ
¼ 216 (a8 þ b8 þ c8 þ d8Þ þ 28:a8 þ 210:b8 þ 212:c8
þ 214:d8  28  210  212  214
SE ¼ 216:ða8 þ b8 þ c8 þ d8Þ þ 28:a8 þ 210:b8 þ 212:c8 þ 214:d8
 28  210  212  214  216 þ 216 þ
1  1
ð
Þ
¼ 216: a8 þ b8 þ c8 þ d8  1
ð
Þ þ 28:a8 þ 210:b8 þ 212:c8 þ 214:d8
 28  210  212  214 þ
216  1


þ 1
54
1
Review of Combinational Circuits

But,
2161 ¼
1 þ 2 þ 22 þ . . . þ 27


þ
28 þ 29 þ . . . þ 215


¼
281


þ
28 þ 29 þ . . . þ 215


Then,
SE ¼ 216: a8 þ b8 þ c8 þ d8  1
ð
Þ þ 28: a8
þ 210:b8 þ 212:c8 þ 214:d8
 28  210  212  214 þ 1 þ
28  1


þ
28 þ 29 þ 210 þ 211 þ 212 þ 213 þ 214 þ 215


Regrouping the terms with the same power in SE yields:
SE ¼ 216: a8 þ b8 þ c8 þ d8  1
ð
Þ þ 28:ða8 þ 1Þ þ 29 þ 210:b8 þ 211
þ 212:c8 þ 213 þ 214:d8 þ 215
But, the term, 216, is unimportant since this is the overﬂow bit in the multiplier sum.
Thus,
SE ¼ 28:ða8 þ 1Þ þ 29 þ 210: b8 þ 211 þ 212:c8 þ 213 þ 214:d8 þ 215
Then the partial product tree in Fig. 1.60 simpliﬁes and becomes Fig. 1.61.
8
a7
a 6
a 5
a 4
a 3
a 2
a1
a 0
u 0
8
b7
b6
b5
b 4
b 3
b 2
b 1
b 0
0
0
8
c 7
c 6
c 5
c 4
c 3
c 2
c 1
c 0
8
d7
d6
d5
d 4
d3
d2
d1
d 0
z0X
z2X
z4X
z6X
s15
s14
s13
s12
s11
s10
s9
s8
s7
s6
s5
s4
s3
s2
s1
s0
sign extension
SUM
1
0
0
0
c
0
0
0
0
0
d
0
0
2
3
0
0
0
0
0
0
0
a
0
0
0
0
0
b
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
u
0
0
0
0
1
0
0
0
0
0
0
u
0
0
0
0
1
0
1
0
0
0
0
0
0
u
0
0
0
0
0
0
Mid bits
MSB
LSB
Fig. 1.61 Partial product tree of an eight-bit Booth multiplier after minimization
1.6
Combinational Mega Cells
55

In Fig. 1.60, ai = z0 . xi, bi = z2 . xi, ci = z4 . xi, and di = z6 . xi where i = 0, 1, 2, …7, and xi
represents each term in the multiplicand, X.
The complemented a8, b8, c8 and d8 in Fig. 1.61 are the “reserved bits” in case of a one-bit
left shift of the partial product.
Now, the time has come to implement the components of the eight-bit Booth multiplier:
the encoder, the partial product tree and the full-adder tree.
The Booth encoder is a logic block that forms each partial product. Earlier, we obtained
the Booth coefﬁcient, zk = −2yk+1 + yk + yk-1, to aid the generation of each partial product in
Fig. 1.61. In this expression, the multiplier bits, yk+1, yk and yk-1, from neighboring terms
can be used as inputs to zk to obtain the encoder outputs. Table 1.19 is slightly modiﬁed to
form the truth table for the Booth encoder as shown in Table 1.20.
Following Table 1.20, the Booth encoder is implemented in Fig. 1.62. In this ﬁgure,
ZEROk, P1k, M1k, P2k and M2k correspond to the Booth coefﬁcients, 0, +1, -1, +2 and -2, to
be multiplied with the multiplicand, respectively.
Each partial product in Fig. 1.61 contains a u-term, namely u0, u1, u2 or u3, in case of a
2s complement conversion of the partial product. Therefore, for k = 0, 1, 2 or 3 uk becomes
equal to one if M1k or M2k = 1 (if the multiplicand is multiplied by −1), else it is equal to
zero (if the multiplicand is multiplied by zero or +1). The uk-terms are implemented as
shown in Fig. 1.63.
Table 1.20 Modiﬁed Booth encoder truth table
yk+1
yk
zk
yk-1
0
0
0
0
0
1
0
1
0
0
1
1
1
0
0
1
0
1
1
1
0
1
1
1
0
1
1
2
-2
-1
-1
0
Encoder outputs
ZEROk = 1
P1k = 1
P1k = 1
P2k = 1
M2k = 1
M1k = 1
M1k = 1
ZEROk = 1
Encoder inputs
56
1
Review of Combinational Circuits

yk+1
yk
yk-1
yk
ZEROk
yk+1
yk-1
P1k
yk
yk-1
yk
yk-1
yk+1
M1k
yk
yk-1
yk
yk-1
yk+1
yk
yk+1
yk-1
P2k
yk
yk+1
yk-1
M2k
Fig. 1.62 Booth encoder logic circuit
uk
M2k
M1k
Fig. 1.63 Implementation of uk
1.6
Combinational Mega Cells
57

The LSBs, namely the terms, a0, b0, c0 and d0, in Fig. 1.61 become equal to the values
listed in Table 1.21.
According to this table, when the multiplicand is multiplied by zero, the LSB of the partial
product becomes equal to zero. When the multiplicand is multiplied by +1 or −1, the LSB is
simply equal to the LSB of the multiplicand, x0, or its complement, respectively. Finally,
when the multiplicand is multiplied by +2 or −2, the partial product is shifted one bit to the
left; the LSB becomes either zero or one depending on the sign. Therefore, the LSB of the
partial product is generated using a 5-1 MUX as shown in Fig. 1.64.
The mid bits, a1 to a7, b1 to b7, c1 to c7, and d1 to d7, in Fig. 1.61 are generated according
to Table 1.22. In this table, all mid bits of a partial product are equal to zero if the
multiplicand is multiplied by zero. Mid bits become equal to the multiplicand bits or their
complements depending on the multiplicand is multiplied by +1 or −1, respectively.
Table 1.21 Truth table of the LSB for Fig. 1.61
ZEROk = 1
a0 = b0 = c0 = d0 = 0
P1k = 1
a0 = b0 = c0 = d0 = x0
M1k = 1
a0 = b0 = c0 = d0 = x0
P2k = 1
a0 = b0 = c0 = d0 = 0
M2k = 1
a0 = b0 = c0 = d0 = 1
Encoder output
LSB
P1k M1k
M2k
ZEROk
P2k
2
3
4
x0
x0
LSB
1
5
0
0
1
Fig. 1.64 Logic diagram of the LSB for Fig. 1.61
58
1
Review of Combinational Circuits

When the multiplicand is multiplied by +2 or −2, each term in the partial product is
shifted one bit to the left. Therefore, each partial product bit becomes equal to the lesser
signiﬁcant multiplicand bit or its complement. Each mid bit in Table 1.22 can be imple-
mented by a 5-1 MUX shown in Fig. 1.65.
The MSBs, namely the terms, a8; b8; c8 or d8, in Fig. 1.61 form according to Table 1.23.
In this table, when the multiplicand is multiplied by zero, the MSB of the partial product
becomes equal to zero. When the multiplicand is multiplied by +1 or −1, the MSB is simply
Table 1.22 Truth table of the mid bits for Fig. 1.61
ZEROk = 1
ai = bi = ci = di = 0
P1k = 1
ai = bi = ci = di = xi
M1k = 1
ai = bi = ci = di = xi
P2k = 1
ai = bi = ci = di = xi-1
M2k = 1
ai = bi = ci = di = xi-1
Encoder output
Mid bits
where i = 1, 2,…7
where i = 1, 2,…7
where i = 1, 2,…7
where i = 1, 2,…7
where i = 1, 2,…7
P1k M1k
M2k
ZEROk
P2k
2
3
4
xi
xi
Mid bit
1
5
0
xi-1
xi-1
Fig. 1.65 Logic diagram of the mid bits for Fig. 1.61
Table 1.23 Truth table of the MSB for Fig. 1.61
ZEROk = 1
a8 = b8 = c8 = d8 = 0
P1k = 1
a8 = b8 = c8 = d8 = x7
M1k = 1
a8 = b8 = c8 = d8 = x7
P2k = 1
M2k = 1
Encoder output
MSB
a8 = b8 = c8 = d8 = x7
a8 = b8 = c8 = d8 = x7
1.6
Combinational Mega Cells
59

equal to the sign-extended value of the most signiﬁcant multiplicand bit, x7, or its com-
plement, respectively. When the multiplicand is multiplied by +2 or −2, the partial product
shifts one bit to the left. Consequently, the MSB becomes equal to the most signiﬁcant
multiplicand bit or its complement, respectively. The MSB of a partial product can therefore
be implemented by a 5-1 MUX as shown in Fig. 1.66.
When all of the components of the eight-bit Booth multiplier are integrated, we ﬁnally
obtain the circuit topology in Fig. 1.67.
Example 1.25: Multiply A = 10110101 (multiplicand) by B = 01110010 (multiplier) using
the Booth algorithm. The multiplier bits are as follows:
y0 ¼ 0; y1 ¼ 1; y2 ¼ 0; y3 ¼ 0; y4 ¼ 1; y5 ¼ 1; y6 ¼ 1; y7 ¼ 0
Therefore, the Booth coefﬁcients become:
z0 ¼ 2y1 þ y0 þ y1 ¼ 2:ð1Þ þ 0 þ 0 ¼ 2
z2 ¼ 2y3 þ y2 þ y1 ¼ 2:ð0Þ þ 0 þ 1 ¼ þ 1
z4 ¼ 2y5 þ y4 þ y3 ¼ 2:ð1Þ þ 1 þ 0 ¼ 1
z6 ¼ 2y7 þ y6 þ y5 ¼ 2:ð0Þ þ 1 þ 1 ¼ þ 2
According to these coefﬁcients, the partial product tree forms as shown in Fig. 1.68.
In this ﬁgure, the zeroth partial product (top row) is generated by multiplying the mul-
tiplicand by -2. This requires taking the 2s complement of the multiplicand, and then shifting
its contents one bit to the left. In other words, if the multiplicand is equal to 10110101, then
its 2s complement becomes 01001011. Shifting this value to the left by one bit reveals a
nine-bit value of 010010110. Since the sign bit of 01001011 is zero before any shifting takes
place, sign extending 010010110 after the shift in a 16-bit ﬁeld yields 0000000010010110.
P1k M1k
M2k
ZEROk
P2k
2
3
4
x7
x7
MSB
1
5
0
x7
x7
Fig. 1.66 Logic diagram of the MSB for Fig. 1.61
60
1
Review of Combinational Circuits

BOOTH 
ENC
BOOTH 
ENC
BOOTH 
ENC
BOOTH 
ENC
U0
LSB
MID
MID
MID
MID
MID
MID
MID
MSB
U1
LSB
MID
MID
MID
MID
MID
MID
MID
MSB
U2
LSB
MID
MID
MID
MID
MID
MID
MID
MSB
U3
LSB
MID
MID
MID
MID
MID
MID
MID
MSB
y-1
y0
y1
y1
y2
y3
y3
y4
y5
y5
y6
y7
x0
x0
x0
x0
x0
x0
x0
x0
x7
x7
x7
x7
x7
x7
x7
x7
ZERO
P1
M1
P2
M2
ZERO
P1
M1
P2
M2
ZERO
P1
M1
P2
M2
ZERO
P1
M1
P2
M2
0
1
s0
s1
s2
s3
s4
s5
s6
s7
s8
s9
s10
s11
s12
s13
s14
s15
1
1
1
CARRY 
PROPAGATE 
ADDER
0
0
u0
a0
a1
a2
a3
a4
a5
a6
a7
a8
u1
b0
b1
b2
b3
b4
b5
b6
b7
b8
u2
c0
c1
c2
c3
c4
c5
c6
c7
c8
u3
d0
d1
d2
d3
d4
d5
d6
d7
d8
x1x1x0x0
x2x2x1x1
x3x3x2x2
x4x4x3x3
x5x5x4x4
x6x6x5x5
x7x7x6x6
x1x1x0x0
x2x2x1x1
x3x3x2x2
x4x4x3x3
x5x5x4x4
x6x6x5x5
x7x7x6x6
x1x1x0x0
x2x2x1x1
x3x3x2x2
x4x4x3x3
x5x5x4x4
x6x6x5x5
x7x7x6x6
x1x1x0x0
x2x2x1x1
x3x3x2x2
x4x4x3x3
x5x5x4x4
x6x6x5x5
x7x7x6x6
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
HA
FA
FA
FA
FA
FA
FA
FA
FA
FA
FA
FA
FA
FA
FA
FA
FA
Fig. 1.67 8x8 Booth multiplier
1.6
Combinational Mega Cells
61

The ﬁrst partial product (second row from the top) is produced by multiplying the multi-
plicand by +1. This simply replicates the multiplicand bits, 10110101, in the partial product.
Since the sign bit of 10110101 is one, sign extending this value in a 14-bit ﬁeld yields
11111110110101 as the partial product. The second partial product (third row from the top)
is formed by multiplying the multiplicand by −1. This simply requires taking the 2s com-
plement of the multiplicand, which is 01001011. Sign extending this value in a 12-bit ﬁeld
yields 000001001011 as the partial product. The third partial product (last row) is obtained
by multiplying the multiplicand by +2, which shifts the multiplicand one bit to the left. Since
the multiplicand is 10110101, a nine-bit value of 101101010 is obtained after the shift. Sign
extending this value within ten bits yields 1101101010.
0
0
0
0
0
0
0
0
0
1
0
0
1
0
1
1
0
1
1
1
0
0
1
0
1
0
1
1
0
1
0
1
Multiplicand =
Multiplier =
1
1
1
1
1
1
1
1
0
1
1
0
1
0
1
0
0
0
0
0
1
0
0
1
0
1
0
1
1
0
1
1
0
1
0
1
0
1
1
0
1
1
1
1
0
1
0
0
1
1
0
1
-2 = Take 2s complement of the multiplicand
and shift left by 1 bit
+ 1 = Replicate the multiplicand
-1 = Take 2s complement of the multiplicand
+ 2 = Shift the multiplicand left by 1 bit
Fig. 1.68 A numerical example of an 8x8 Booth multiplier
62
1
Review of Combinational Circuits

Review Questions
1. Implement the following gates:
(a)
Implement a two-input XOR gate using two-input NAND gates and inverters.
(b)
Implement a two-input AND gate using two-input XNOR gates and inverters.
2. Simplify the equation below:
out ¼ ðA þ BÞ : ðA þ BÞ
3. Simplify the equation below:
out ¼ ðA þ C) : ðA þ CÞ : ðA þ B þ CÞ
4. Obtain the SOP and POS expressions for the following function:
out ¼ ðA : B þ C) : ðB þ A : C)
5. Implement the following function using NAND gates and inverters:
out ¼ A : C þ B : C þ A : B : D
6. Implement the following function using NOR gates and inverters:
out ¼ ðA  B) : ðC  DÞ
7. Implement the following 2-1 multiplexer using AND and OR gates.
Note that the function of this multiplexer must produce the following:
If En = 1 then out = A else (when En = 0) out = B.
A
B
out
En
0
1
1.6
Combinational Mega Cells
63

8. Implement the following 3-1 multiplexer using AND and OR gates.
Note that the function of this multiplexer must produce the following:
If En = 2 then out = A; if En = 1 then out = B else (when En = 0 or En = 3) out = C.
A
C
out
En [1:0]
0
2
B
1
2
9. Implement a two-bit ripple-carry adder with inputs A[1:0] and B[1:0] and an output C
[1:0] using one-bit half- and one-bit full-adders. Preserve the overﬂow bit at the output
as C[2].
10. Implement a two-bit ripple-carry subtractor with inputs A[1:0] and B[1:0] and an
output C[1:0] using one-bit half- and one-bit full-adders. Preserve the overﬂow bit at
the output as C[2].
11. Implement a two-bit multiplier with inputs A[1:0] and B[1:0] and an output C[3:0]
using one-bit half- and one-bit full-adders.
12. Construct a four-bit comparator with inputs A[3:0] and B[3:0] using a subtractor. The
comparator circuit should identify the following cases with active-high outputs:
A½3:0 ¼ B½3:0
A½3:0 [ B½3:0
A½3:0 \ B½3:0
13. Implement a two-bit decoder that produces four outputs.
When enabled the decoder generates the following outputs:
If in½1:0 ¼ 0 then
out½3:0 ¼ 1
If in½1:0 ¼ 1 then
out½3:0 ¼ 2
If in½1:0 ¼ 2 then
out½3:0 ¼ 4
If in½1:0 ¼ 3 then
out½3:0 ¼ 8
When disabled the out[3:0] always equals to zero regardless of the input value.
64
1
Review of Combinational Circuits

14. Design a 64-bit adder in ripple-carry form and compare it against carry-look-ahead,
carry-select, and carry-look-ahead/carry-select hybrids in terms of speed and the number
of gates which deﬁne the circuit area. Divide the 64-bit carry-look-ahead/carry-select
hybrid into four-bit, eight-bit, 16-bit and 32-bit carry-look-ahead segments. Indicate
which carry-look-ahead/carry-select hybrid produces the optimum design.
15. Implement a 4 x 4 Booth multiplier. Design the Booth encoders for the partial product
tree and draw the entire schematic of the multiplier. Compare this implementation with
the 4 x 4 array multiplier explained in this chapter. List the advantages of both designs
in terms of speed and circuit area.
Projects
1. Implement the 4-1 multiplexer in Fig. 1.30 and verify its functionality using Verilog.
2. Implement the encoder circuit in Table 1.14 and verify its functionality using Verilog.
3. Implement the decoder circuit in Table 1.15 and verify its functionality using Verilog.
4. Implement the four-bit Ripple-Carry Adder in Fig. 1.42 and verify its functionality
using Verilog.
5. Implement the four-bit Carry-Look-Ahead Adder in Fig. 1.44 and verify its function-
ality using Verilog.
6. Implement the four-bit Carry-Select Adder in Fig. 1.45 and verify its functionality
using Verilog.
7. Implement the four-bit Carry-Select/Carry-Look-Ahead Adder in Fig. 1.49 and verify
its functionality using Verilog.
8. Implement the four-bit barrel shifter in Fig. 1.53 and verify its functionality using
Verilog.
9. Implement the four-bit array multiplier in Fig. 1.56 and verify its functionality using
Verilog.
10. Implement the eight-bit Booth multiplier in Fig. 1.67 and verify its functionality using
Verilog.
1.6
Combinational Mega Cells
65

2
Review of Sequential Logic Circuits
The deﬁnition of clock and system timing are integral parts of a sequential digital circuit.
Data in a digital system moves from one storage device to the next by the virtue of a system
clock. During its travel, data is routed in and out of different combinational logic blocks, and
becomes modiﬁed to satisfy a speciﬁc functionality.
This chapter is dedicated to reviewing the basics of memory devices that store data, and
sequential circuits that use memory devices to operate. The chapter begins with the intro-
duction of two basic memory elements, the latch and the ﬂip-ﬂop. It then explains how data
travels between memory elements using timing diagrams, and how timing violations form as
a result of unexpected combinational logic delays on the data path or in the clock line. Later
in the chapter, the basic sequential building blocks such as registers, shift registers and
counters are examined. Moore-type and Mealy-type state machines that control data
movement are also studied; their advantages and disadvantages are compared against
counter-decoder type controllers in various design tasks. The concept of block memory and
how it is used in a digital system is introduced at the end of this chapter. The chapter
concludes with a comprehensive example which demonstrates data transfer from one
memory block to another, how to build a detailed data-path during the development of the
design, and how to use timing diagrams to build a controller.
2.1
D Latch
The D Latch is the most basic memory element in logic design. It has a data input, D, a clock
input, clock, and a data output, Q, as shown in the top portion of Fig. 2.1. It contains a
tri-state inverter at its input stage followed by two back-to-back inverters connected in a loop
conﬁguration, which serves to store data.
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9_2
67

The clock signal connected to the enable input of the tri-state inverter can be set either to
active-high or active-low. In Fig. 2.1, the changes at the input transmit though the memory
element, and become the output during the low phase of the clock. In contrast, the changes at
the input are blocked during the high phase of the clock, and no data transmits to the output.
Once the data is stored in the back-to-back inverter loop, it becomes stable and does not
change until different data is introduced at the input. The buffer at the output stage of the
latch is used to drive multiple logic gate inputs.
The operation of the D latch is shown in Fig. 2.2. During the low phase of the clock, the
tri-state inverter is enabled. The new data transmits through the tri-state inverter, overwrites
the old data in the back-to-back inverter stage, and reaches the output. When the clock
switches to its high phase, the input-output data transmission stops because the tri-state
buffer is disabled and blocks any new data transfer. Therefore, if certain data needs to be
retained in the latch, it needs to be stored some time before the rising edge of the clock. This
time interval is called the set-up time, tS, and it is approximately equal to the sum of delays
through the tri-state inverter and the inverter in the memory element. At the high phase of the
clock, the data stored in the latch can no longer change as shown in Fig. 2.2.
D
clock
Q
D
Q
clock
Fig. 2.1 Logic and circuit diagrams of a D latch
68
2
Review of Sequential Logic Circuits

2.2
Timing Methodology Using D Latches
Timing in logic systems is maintained by pipeline structures. A pipeline consists of com-
binational logic blocks bounded by memory elements as shown in the top portion of Fig. 2.3.
The main purpose of pipelines is to process several data packets within the same clock cycle
and maximize the data throughput.
To illustrate the concept of pipeline, latches are used as memory elements in the pipeline
structure shown in Fig. 2.3. In every latch boundary, data propagates from one combina-
tional logic stage to the next at the high and at the low phases of the clock.
The bottom part of Fig. 2.3 shows the timing diagram of a data transfer for a set of data
packets ranging from D1 to D3 at the IN terminal. The ﬁrst data packet, D10, retains its
original value during the high phase of the clock (Cycle 1H) at the node A. D10 then
propagates through the T1 stage, and settles at the node B in a modiﬁed form, D11, sometime
before the falling edge of the clock. Similarly, D11 at the node C retains its value during the
low phase of the clock while its processed form, D12, propagates through the T2 stage, and
arrives at the node D before the rising edge of the clock. This data is processed further in the
T3 stage, and transforms into D13 before it becomes available at the OUT terminal at the
falling edge of the clock in Cycle 2L.
Similarly, the next two data packets, D20 and D30, are also fed into the pipeline at the
subsequent negative clock edges. Both of these data propagate through the combinational
logic stages, T1, T2 and T3, and become available at the OUT terminal at the falling edge of
Cycle 3L and Cycle 4L, respectively.
Q
Low phase of the clock
ts
D
D
new data
High phase of the clock
Q
new data
Fig. 2.2 Operation of D latch
2.2
Timing Methodology Using D Latches
69

The total execution time for all three data packets takes four clock cycles according to the
timing diagram in Fig. 2.3. If we were to remove all the latch boundaries between nodes A
and F, and wait until all three data packets, D1, D2 and D3, were processed through the sum
of the three combinational logic stages, T1, T2 and T3, the total execution time would have
been 3 x 1.5 = 4.5 clock cycles as each combinational logic stage requires half a clock cycle
to process data. Therefore, pipelining can be used advantageously to process data in a shorter
amount of time and increase data throughput.
2.3
D Flip-Flop
The D ﬂip-ﬂop is another important timing element in logic design to maintain timely
propagation of data from one combinational logic block to the next.
Similar to a latch, the ﬂip-ﬂop has also a data input, D, a clock input, clock, and a data
output, Q, as shown in the top portion of Fig. 2.4.
The bottom part of Fig. 2.4 shows the circuit schematic of a typical ﬂip-ﬂop which
contains two latches in series. The ﬁrst latch has an active-low clock input, and it is called
the master. The second latch has an active-high clock input, and it is called the slave. The
B
T1
A
IN
OUT
D
T2
F
C
T3
E
OUT
A
D10
IN
clock
B
C
D
E
F
T1
D11
D11
T2
D12
D12
D13
T3
D13
D20
D21
D21
D22
D22
D23
D23
D30
D31
D31
D32
D32
D33
D33
Cycle 1H
Cycle 1L
Cycle 2H
Cycle 2L
Cycle 3H
Cycle 3L
Cycle 4H
Cycle 4L
D
Q
clock
D
Q
clock
D
Q
clock
D
Q
clock
D10
D20
D30
Fig. 2.3 Timing methodology using D latches (“X” marks correspond to changing data)
70
2
Review of Sequential Logic Circuits

master accepts new data during the low phase of the clock, and transfers this data to the slave
during the high phase of the clock.
Figure 2.5 shows the timing attributes of a ﬂip-ﬂop. The set-up time, tS, is the time
interval for valid data to arrive and settle in the master latch before the rising edge of the
clock. Hold time, tH, is the time interval after the positive edge of the clock when valid data
needs to be kept steady and unchanged. The data stored in the master latch propagates
through the slave latch and becomes the ﬂip-ﬂop output some time after the rising edge of
the clock, and it is called clock-to-q delay or tCLKQ.
The operation of the ﬂip-ﬂop in two different phases of the clock is shown in Fig. 2.6.
During the low phase of the clock, new data enters the master latch, and it is stored. This data
cannot propagate beyond the master latch because the tri-state inverter in the slave latch acts
as an open circuit during the low phase of the clock. The ﬂip-ﬂop output reveals only the old
data stored in the slave latch. When the clock goes high, the new data stored in the master
D
clock
Q
clock
MASTER
SLAVE
D
Q
clock
Fig. 2.4 Logic and circuit diagrams of a D ﬂip-ﬂop
tS
tH
tCLKQ
Valid Data
D
Q
clock
?
Fig. 2.5 Timing attributes of a D ﬂip-ﬂop
2.3
D Flip-Flop
71

latch transmits through the slave and arrives at the output. One can approximate values of tS
and tCLKQ using the existing gate delays in the ﬂip-ﬂop.
2.4
Timing Methodology Using D Flip-Flops
Data propagation through a pipeline with D ﬂip-ﬂops is shown in Fig. 2.7. The bottom part
of Fig. 2.7 shows the timing diagram of a data transfer for a set of data packets ranging from
D1 to D3 at the IN terminal.
The ﬁrst data packet, D10, at the IN terminal has to be steady and valid during the set-up
and hold periods of the ﬂip-ﬂop, but it is free to change during the remaining part of the clock
period as shown by oscillatory lines. Once the clock goes high, the valid D10 starts to
propagate through the combinational logic block of T1 and reaches the second ﬂip-ﬂop
boundary. The processed data, D11, has to arrive at the second ﬂip-ﬂop input, B, no later than
the set-up time of the ﬂip-ﬂop. Otherwise, the correct data cannot be latched. D11 propagates
through the second (T2) and third (T3) combinational logic stages, and becomes D12 and D13,
respectively, before exiting at the OUT terminal as shown in the timing diagram in Fig. 2.7.
The subsequent data packets, D20 and D30, are similarly fed into the pipeline stage from
the IN terminal following D10. They are processed and modiﬁed by the T1, T2 and T3
combinational logic stages as they propagate through the pipeline, and emerge at the OUT
terminal.
The total execution time for three input data packets, D10, D20 and D30, takes six clock
cycles, including the initial three clock cycle build-up period before D13 emerges at the OUT
terminal. If we were to remove all the ﬂip-ﬂop boundaries between the nodes A and F, and
Q
Low phase of the clock
tS
D
D
Q
High phase of the clock
tCLKQ
new data
new data
old data
Fig. 2.6 Operation of D ﬂip-ﬂop
72
2
Review of Sequential Logic Circuits

wait for these three data packets to be processed without any pipeline structure, the total
execution time would have been 3 x 3 = 9 clock cycles, assuming each T1, T2 or T3 logic
stage imposes one clock cycle delay.
Once again, the pipelining technique considerably reduces the overall processing time and
increase data throughput whether the timing methodology is latch-based or ﬂip-ﬂop-based.
The advantage of using latches as opposed to ﬂip-ﬂops is to be able to borrow time from
neighboring stages. For example, the propagation delay in the T1 stage in Fig. 2.3 can be
extended at the expense of shortening the propagation delay in the T2 stage. This ﬂexibility
does not exist in a ﬂip-ﬂop based design in Fig. 2.7.
2.5
Timing Violations
Although pipelining scheme helps reducing the overall data processing time, we still need to
watch out possible timing violations because of the unexpected delays in the data-path and
the clock network.
Therefore, this section examines the set-up and hold timing violations in ﬂip-ﬂop
controlled pipelines, and proposes possible solutions to eliminate them.
B
T1
A
IN
OUT
D
T2
F
C
T3
E
OUT
D10
D20
D30
A
D10
D20
D30
IN
clock
B
T1
D11
D21
D31
C
D11
D21
D31
D
T2
D12
D22
D32
E
D12
D22
D32
F
T3
D13
D23
D33
D13
D23
D33
D
Q
clock
D
Q
clock
D
Q
clock
D
Q
clock
Fig. 2.7 Timing methodology using D ﬂip-ﬂops (“X” marks correspond to changing data)
2.4
Timing Methodology Using D Flip-Flops
73

Figure 2.8 shows a section of a pipeline where a combinational logic block with a
propagation delay of TCOMB is sandwiched between two ﬂip-ﬂop boundaries. At the rising
edge of the clock, the valid data that meets the set-up and hold time requirements is
introduced at the IN terminal. After tCLKQ delay, the data emerges at the node A and
propagates through the combinational logic block as shown in the timing diagram. However,
the data arrives at the node B too late and violates the allocated set-up time of the ﬂip-ﬂop.
This is called the set-up violation. The amount of violation is dependent on the clock period
and is calculated as follows:
Set-up violation = tS  TC  tCLKQ þ TCOMB
ð
Þ
½

Figure 2.9 describes the hold time violation where the clock shifts by TCLK due to an
unexpected delay in the clock line. In the timing diagram, the valid data is introduced to the
pipeline at the IN terminal, and it arrives at the node B after a short delay equal to (tCLKQ +
TCOMB). The shifted clock, on the other hand, creates a substantial set-up time slack equal to
(TC + TCLK – tS – tCLKQ – TCOMB), but it also produces a hold time violation at the delayed
clock edge. The amount of violation is dependent on the clock delay and is calculated as
follows:
Hold violation = TCLK þ tH
ð
Þ  tCLKQ þ TCOMB
ð
Þ
B
TCOMB
A
IN
OUT
TCOMB
setup violation
tS
tH
tCLKQ
IN
B
clock
A
valid
D
Q
clock
D
Q
clock
tS
TC
Fig. 2.8 Setup violation
74
2
Review of Sequential Logic Circuits

Set-up violations can be recovered simply by increasing the clock period, TC. However,
there is no easy way to ﬁx hold violations as they need to be searched at each ﬂip-ﬂop input.
When they are found, buffer delays are added to the combinational logic block, TCOMB, in
order to avoid the violation.
The schematic in Fig. 2.10 examines the timing ramiﬁcations of two combinational logic
blocks with different propagation delays merging into a single block. The data arrives at the
node C much earlier than the node D as shown in the timing diagram. The data at the nodes
C and D propagate through the last combinational block and arrive at the node E. This
scenario creates minimum and maximum delay paths at the node E. We need to focus on the
maximum path, (T2 + T3), when examining the possibility of a set-up violation and the
minimum path, (T1 + T3), when examining the possibility of a hold violation at the next
ﬂip-ﬂop boundary.
TCLK
B
clock
shifted clock
TCOMB
A
IN
OUT
TCOMB
tS
tH
tCLKQ
clock
IN
A
B
shifted clock
hold violation
tS
tH
tS
tH
sending edge
receiving edge
TCLK
valid
D
Q
D
Q
TC
Fig. 2.9 Hold violation
2.5
Timing Violations
75

To further illustrate the timing issues involving multiple combinational logic blocks, an
example is given in Fig. 2.11 where two combinational logic blocks merge into a single
block. The adder is bypassed with the inclusion of a 2-1 MUX which selects either the
output of the adder or the bypass path, by a selector input, SEL.
The propagation delays of the inverter, TINV, and the two-input NAND gate, TNAND2, are
given as 100 ps and 200 ps, respectively. The set-up, hold and clock-to-q delays are also
given as 100 ps, 0 ps and 300 ps, respectively.
E
T1
A
IN1
OUT
IN2
T2
B
T3
C
D
tS
tH
tCLKQ
IN1, IN2
E
sending edge
A, B
T1
C
D
T2
T3
T3
tS
tH
receiving edge
valid data
setup slack
clock
clock
clock
D
Q
D
Q
D
Q
clock
Fig. 2.10 A timing example combining two independent data-paths
76
2
Review of Sequential Logic Circuits

Both the one-bit full adder and the 2-1 MUX are decomposed into basic logic gates, such
as inverters and two-input NAND gates, as shown in Fig. 2.12. We obtain a total of seven
propagation paths all merging at the node R. However, we only need to search for the
maximum and the minimum delay paths to locate possible set-up and hold violations.
The maximum delay path consists of the inverter 1, and the series combination of four
two-input NAND gates numbered as 1, 3, 4 and 6 shown in the schematic. This path results
in a total delay of 900 ps. The minimum delay path, on the other hand, contains two
two-input NAND gates numbered as 5 and 6, and it produces a delay of 400 ps. Placing
these delays in the timing diagram in Fig. 2.13 yields a set-up slack of 100 ps at the node R
when a clock period of 1400 ps is used. There is no need to investigate hold violations
because there is no shift in the clock edge. However, if there were a shift in the clock line
beyond tCLKQ = 300 ps, then we would have a hold violation, and it would require an
additional combinational logic delay in the data-path to proportionally shift the valid data at
the node R to compensate the hold violation. This, however, would also eliminate the 100 ps
set-up slack in Fig. 2.13.
TINV = 100ps
TNAND2 = 200ps
tS = 100ps
tH = 0ps
tCLKQ = 300ps
OUT
D
Q
1
0
D
Q
D
Q
D
Q
D
Q SEL
C
B
A
S
R
clock
IN1
IN2
IN3
IN4
Fig. 2.11 An example with multiple propagation paths
2.5
Timing Violations
77

C
SEL
Maximum Delay Path
100ps
clock
D
Q
D
Q
D
Q
D
Q
clock
clock
clock
B
A
clock
D
Q
200ps
200ps
200ps
200ps
S
R
IN1
IN2
IN3
IN4
Minimum Delay Path
1
2
1
2
3
4
5
6
3
Fig. 2.12 Logic circuit of Fig. 2.11 showing maximum and minimum paths
clock
IN1 – IN4
C
500ps
100ps
A, B
S
R
300ps
400ps
100ps
400ps
700ps
800ps
1200ps
setup slack
100ps
1400ps
Fig. 2.13 Timing diagram of the circuit in Fig. 2.12
78
2
Review of Sequential Logic Circuits

2.6
Register
While the ﬂip-ﬂop holds data for only one clock cycle until new data arrives at the next clock
edge, the register can hold the same data perpetually until the power is turned off.
Figure 2.14 shows the circuit diagram of a one-bit register composed of a ﬂip-ﬂop and a
2-1 MUX. The Write Enable pin, WE, is a selector input to the 2-1 MUX and transfers new
data from the IN terminal to the ﬂip-ﬂop input when WE = 1. If the WE input is at logic 0,
any attempt to write new data to the register is blocked. The old data stored in the ﬂip-ﬂop
simply circulates around the feedback loop from one clock cycle to the next.
The timing diagram at the bottom of Fig. 2.14 describes the operation of the one-bit
register. The data at the IN terminal is blocked until the WE input becomes logic 1 in the
middle of the second clock cycle. At this point, the new data is allowed to pass through the
2-1 MUX, and it renews the contents of the register at the beginning of the third clock cycle.
The WE input transitions to logic 0 before the end of the third clock cycle, and causes the
register output, OUT, to stay at logic 1 during the fourth clock cycle.
A 32-bit register shown in Fig. 2.15 is composed of 32 one-bit registers. All 32 registers
have a common clock and WE input. Therefore, any new 32-bit data introduced at the
register input changes the contents of the register at the rising edge of the clock if the WE
input is set to logic 1.
1
0
IN
OUT
WE
clock
IN
OUT
WE
D
Q
clock
Fig. 2.14 One-bit register and a sample timing diagram
2.6
Register
79

2.7
Shift Register
The shift register is a particular version of an ordinary register, and it specializes in shifting
data to the right or to the left according to the design needs.
Figure 2.16 shows the circuit schematic of a four-bit shift register that shifts serial data at
the IN terminal to the left if enabled.
The operation of this shift register is explained in the timing diagram in Fig. 2.17. In cycle
1, SHIFT = 0. Therefore, the change at the IN terminal during this cycle does not affect the
register outputs. However, when the SHIFT input transitions to logic 1 in the middle of cycle
2, it allows IN = 1 to pass to the least signiﬁcant output bit, OUT[0], at the beginning of the
third clock cycle. From the middle of cycle 2 to the middle of cycle 13, SHIFT is kept at
logic 1. Therefore, any change at the IN node directly transmits to the OUT[0] node at the
positive edge of each clock cycle. The other outputs, OUT[1], OUT[2] and OUT[3], produce
delayed outputs one clock cycle apart from each other because the output of a lesser
signiﬁcant bit is connected to the input of a greater signiﬁcant bit in the shift register.
When the SHIFT input becomes logic 0 from the middle of cycle 13 to cycle 17, the shift
register becomes impervious to any change at the IN terminal, and retains the old values
from the beginning of cycle 13 to cycle 18 as seen in Fig. 2.17. From the middle of cycle 17
onwards, the SHIFT input becomes logic 1 again, and the shift register distributes all new
data entries at the IN terminal to its outputs.
clock
IN[0]
OUT[0]
WE
1
0
OUT[30]
OUT[31]
1
0
1
0
IN[30]
IN[31]
Q
D
Q
D
Q
D
Fig. 2.15 32-bit register
80
2
Review of Sequential Logic Circuits

2.8
Counter
The counter is a special form of a register which is designed to count up (or down) at each
rising edge of the clock.
The circuit schematic in Fig. 2.18 shows a typical 32-bit up-counter with two control inputs,
COUNT and LOAD. The COUNT = 1 entry enables the counter to count upwards at the rising
edge of each clock cycle, and the LOAD = 1 entry loads new data to the counter from its IN
[31:0] terminal. Once loaded, the counter output, OUT[31:0], increments by one at the pos-
itive edge of each clock cycle until all the output bits become logic 1. The next increment
clock
IN
SHIFT
OUT[0]
OUT[1]
OUT[2]
OUT[3]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
Fig. 2.17 A sample timing diagram of the four-bit shift register in Fig. 2.16
clock
IN
OUT[0]
SHIFT
1
0
OUT[1]
OUT[3]
1
0
1
0
OUT[2]
OUT[0]
OUT[1]
OUT[2]
1
0
Q
D
Q
D
Q
D
Q
D
Fig. 2.16 Four-bit shift register
2.8
Counter
81

automatically resets the counter output to logic 0. When LOAD = COUNT = 0, the counter
neither loads new data nor is able to count upwards; it stalls and repeats its old output value.
The sample timing diagram at the bottom of Fig. 2.18 illustrates its operation. Prior to the
ﬁrst clock edge, the LOAD input is at logic 1 which allows an input value, IN = 3, to be
stored in the counter. This results in OUT[31:0] = 3 at the positive edge of the ﬁrst clock
cycle. The LOAD = 0 and COUNT = 1 entries before the end of the ﬁrst clock cycle start the
up-count process, and the contents of the output, OUT[31:0] = 3, is subsequently incre-
mented by one. The result, 3 + 1 = 4, passes through the C-port of the 3-1 MUX and arrives
at the ﬂip-ﬂop inputs. At the positive edge of the second clock cycle, this new value
overwrites the old registered value, and the OUT[31:0] node becomes equal to 4. In the next
cycle, the counter goes through the same process and increments by one again. However, in
the same cycle, the COUNT input also transitions to logic 0, and turns on the I-port of the
3-1 MUX. This input value prevents any new data from entering the up-counter, and it keeps
the old data in the following clock cycles. As a result, the counter output stops incrementing
and stalls at the value of OUT[31:0] = 5.
clock
IN[31:0]
OUT[31:0]
LOAD
clock
OUT[31:0]
LOAD
+1
L
COUNT
C
I
32
COUNT
3
4
5
5
5
IN = 3
5
Q
D
cycle 1
cycle 2
cycle 3
cycle 4
cycle 5
cycle 6
Fig. 2.18 A 32-bit counter and a sample timing diagram
82
2
Review of Sequential Logic Circuits

2.9
Moore Machine
A state machine can be formed as soon as a ﬂip-ﬂop output is connected to a ﬂip-ﬂop input.
Therefore, an overall state machine topology consists of ﬂip-ﬂops, feedback loops from
ﬂip-ﬂop outputs to ﬂip-ﬂop inputs, and combinational logic blocks connected to ﬂip-ﬂop
outputs and embedded in feedback loops.
Figure 2.19 shows the Moore-type state machine topology consisting of a ﬂip-ﬂop and a
feedback loop. In this conﬁguration, the feedback loop includes a combinational logic block
that accepts both the ﬂip-ﬂop output and external inputs. If there are multiple ﬂip-ﬂops, the
combination of all ﬂip-ﬂop outputs constitutes the “present” state of the machine. The com-
bination of all ﬂip-ﬂop inputs is called the “next” state because at the positive edge of the clock
these inputs become the ﬂip-ﬂop outputs, and form the present state. Flip-ﬂop outputs are
processed further by an additional combinational logic block, forming the present state outputs.
The basic state diagram of a Moore machine, therefore, includes the present state (PS) and
the next state (NS) as shown in Fig. 2.19. The machine can transition from the PS to the NS
if the required present state inputs are supplied. The outputs of the Moore machine are solely
generated by the present state, and they emerge only from the current states as shown in the
basic state diagram.
Combinational
Logic
Combinational
Logic
Present State
Next State
Present State 
Outputs
Present State 
Inputs
PS
NS
Present State 
Outputs
Present State 
Inputs
Next State 
Outputs
clock
Q
D
Fig. 2.19 Block diagram and state representation of Moore machine
The state diagram in Fig. 2.20 shows an example of a Moore-type machine with four
states. Note that every state-to-state transition in the state diagram requires a valid present
state input entry, and every node generates one present state output.
The state 0, S0, produces a present state output, OUT = 1, regardless of the value of the
present state input, IN. When IN = 1, the state S0 transitions to the next state S1. Otherwise,
it circulates back to itself. The state S1 produces OUT = 2; its next state becomes S1 if IN =
0, or it becomes S2 if IN = 1. The state S2 also produces a present state output, OUT = 3, and
transitions to the state S3 if IN = 1. The state S2 remains unchanged if IN = 0. In the fourth
and the ﬁnal state, the present state output from S3 becomes 4. The machine stays in this
state if IN stays at 0; otherwise, it goes back to the state S1.
2.9
Moore Machine
83

The present state inputs and outputs of this Moore machine and its states can be tabulated
in a table called the “state table” given in Fig. 2.21. In this table, the ﬁrst column under the
PS entry lists all the possible present states in the state diagram in Fig. 2.20. The middle two
columns contain the next state entries for IN = 0 and IN = 1. The last column lists the present
state outputs, one for each present state.
PS
IN = 0
OUT
IN = 1
S0
S1
S2
S3
S0
S1
S2
S3
S1
S2
S3
S1
1
2
3
4
NS
Fig. 2.21 State table of the Moore machine in Fig. 2.20
S0
S1
S2
S3
IN = 0
IN = 1
IN = 1
IN = 1
IN = 0
IN = 0
IN = 0
IN = 1
OUT = 1
OUT = 2
OUT = 4
OUT = 3
Fig. 2.20 State diagram of a Moore machine with four states
84
2
Review of Sequential Logic Circuits

The binary state assignment is performed according to Fig. 2.22 where only one bit is
changed between adjacent states.
The binary form of the state table in Fig. 2.21 is reconstructed in Fig. 2.23 according to
the state assignment in Fig. 2.22. This table is called the “transition table”, and it includes the
binary representation of the next state and the present state outputs.
Forming this machine’s K-maps for the NS0, NS1, OUT0, OUT1 and OUT2 requires
grouping all the input terms, PS1, PS0 and IN, according to the table in Fig. 2.23. The
K-maps and their corresponding Sum of Products (SOP) expressions are shown in Fig. 2.24.
PS0
OUT2
IN = 0
PS1
0
1
1
0
0
0
1
1
1
S
N
0
S
N
0
1
1
0
0
0
1
1
IN = 1
1
S
N
0
S
N
1
1
0
1
0
1
1
0
OUT1 OUT0
0
0
0
1
0
1
1
0
1
0
1
0
Fig. 2.23 Transition table of the Moore machine in Fig. 2.20
States
NS1
NS0
S0
S1
S2
S3
0
0
1
1
0
1
1
0
Fig. 2.22 Bit representations of states S0, S1, S2 and S3
2.9
Moore Machine
85

The next step is to generate the circuit diagram that produces all ﬁve outputs of the Moore
machine according to these SOP expressions in Fig. 2.24. This circuit diagram is given in
Fig. 2.25.
In order to generate this circuit, individual combinational logic blocks for NS0 and NS1
must be formed ﬁrst in terms of PS0, PS1 and IN. Then, each NS0 and NS1 output is connected
to the corresponding ﬂip-ﬂop input, producing the feedback loops for this state machine. The
logic blocks for OUT0, OUT1 and OUT2 are generated directly from PS0 and PS1.
0
0
1
1
0
1
1
0
00
01
11
10
IN
0
1
PS1 PS0
NS1 = PS0.IN + PS1.IN
0
1
1
0
1
1
0
1
00
01
11
10
IN
0
1
NS0
PS1 PS0
NS1
NS0 = PS0.IN + PS1.PS0 + PS0.IN
= (PS0 + IN) + PS1.PS0
OUT2 = PS1.PS0
OUT1 = PS1.PS0 + PS1.PS0 = PS0
OUT0 = PS1.PS0 + PS1.PS0 = PS0 + PS0
Fig. 2.24 K-maps and SOP expressions for the Moore machine in Fig. 2.20
IN
NS1
NS0
PS0
PS1
OUT2
OUT1
OUT0
D
Q
D
Q
clock
clock
Fig. 2.25 Logic circuit of the Moore machine in Fig. 2.20
86
2
Review of Sequential Logic Circuits

2.10
Mealy Machine
The Mealy machine shares the same circuit topology with the Moore machine. The machine
conﬁguration also contains ﬂip-ﬂops and feedback loops as shown in Fig. 2.26. However,
the present state outputs are generated from the combinational logic block in the feedback
loop rather than from the present states as in the Moore-type machines.
As a result of this topology, the basic state diagram of a Mealy machine includes the
present state, the next state and the input condition that makes the state-to-state transition
possible as shown in Fig. 2.26. The present state output(s) does not emerge from the present
state; instead, it is a function of the present state input(s) and the present state.
The Mealy state diagram in Fig. 2.27 exhibits similar characteristics compared to the
Moore state diagram in Fig. 2.20, and all the state names and the state-to-state transitions in
this diagram are kept the same for comparison purposes. However, each arrow connecting
one state to the next carries the value of the present state output as a function of the present
state input and the present state as indicated in Fig. 2.26. As a result, the Mealy state table in
Fig. 2.28 contains two separate columns that tabulate the values of NS and OUT for IN = 0
and IN = 1. The binary state assignment is the same as in Fig. 2.22, which results in a
transition table in Fig. 2.29.
clock
Combinational
Logic
Present State
Next State
Present State 
Outputs
Present State 
Inputs
PS
NS
Present State Outputs
Present State Inputs
Q
D
Fig. 2.26 Block diagram and state representation of Mealy machine
2.10
Mealy Machine
87

S0
S1
S2
S3
IN = 0
OUT = 3
IN = 0
OUT = 1
IN = 0
OUT = 2
IN = 0
OUT = 4
IN = 1
OUT = 2
IN = 1
OUT = 2
IN = 1
OUT = 3
IN = 1
OUT = 4
Fig. 2.27 State diagram of a Mealy machine with four states
PS
IN = 0
OUT
IN = 1
S0
S1
S2
S3
S0
S1
S2
S3
S1
S2
S3
S1
1
2
3
4
NS
IN = 0
IN = 1
2
3
4
2
Fig. 2.28 State table of the Mealy machine in Fig. 2.27
88
2
Review of Sequential Logic Circuits

The K-maps for NS0, NS1, OUT0, OUT1 and OUT2 are formed according to the table in
Fig. 2.29 and shown in Fig. 2.30 with the corresponding SOP expressions. Figure 2.31
shows the circuit diagram of this machine according to the expressions in Fig. 2.30. The
methodology used to construct this circuit diagram is identical to the methodology used in
the circuit diagram for the Moore machine in Fig. 2.25.
PS0
OUT2
IN = 0
PS1
0
1
1
0
0
0
1
1
1
S
N
0
S
N
0
1
1
0
0
0
1
1
IN = 1
1
S
N
0
S
N
1
1
0
1
0
1
1
0
OUT1
OUT0
0
0
0
1
0
1
1
0
1
0
1
0
IN = 0
OUT2 OUT1
OUT0
0
0
1
0
1
1
0
1
0
1
0
0
IN = 1
Fig. 2.29 Transition table of the Mealy machine in Fig. 2.27
0
0
1
1
0
1
1
0
00
01
11
10
IN
0
1
PS1 PS0
NS1 = PS0.IN + PS1.IN
0
1
1
0
1
1
0
1
00
01
11
10
IN
0
1
NS0
PS1 PS0
NS1
NS0 = PS0.IN + PS1.PS0 + PS0.IN
= (PS0 + IN) + PS1.PS0
OUT2 = PS1.PS0.IN + PS1.PS0.IN = PS1.(PS0 + IN)
OUT1 = (PS0 + IN) + PS1.PS0 = NS0
OUT0 = PS1.PS0.IN + PS1.PS0.IN + PS1.PS0.IN = PS1.(PS0 + IN) + PS1.PS0.IN
0
0
0
1
0
0
1
0
00
01
11
10
IN
0
1
PS1 PS0
0
1
1
0
1
1
0
1
00
01
11
10
IN
0
1
OUT1
PS1 PS0
OUT2
1
0
1
0
0
1
0
0
00
01
11
10
IN
0
1
PS1 PS0
OUT0
Fig. 2.30 K-maps and SOP expressions for the Mealy machine in Fig. 2.27
2.10
Mealy Machine
89

2.11
Controller Design: Moore Machine Versus Counter-Decoder Scheme
Both Mealy and Moore-type state machines have practical implementation limits when it
comes to design. A large ring-style state machine composed of N states such as in Fig. 2.32
may have multiple outputs attached to each state, making its implementation nearly
impossible with conventional state machine implementation techniques. However, these
types of designs are excellent candidates for the counter-decoder type of designs where each
state in the state diagram is associated with a counter output value. Therefore, as the counter
increments, present state outputs for each state can simply be generated by a set of decoders
connected to the output of the counter.
IN
NS1
NS0
PS0
PS1
OUT2
OUT1
OUT0
clock
Q
D
Q
D
Fig. 2.31 Logic circuit of the Mealy machine in Fig. 2.27
90
2
Review of Sequential Logic Circuits

To illustrate this theory, a controller that generates the timing diagram in Fig. 2.33 will be
implemented using both the Moore-type state machine and the counter-decoder approach.
From the timing diagram below, this state machine generates a single active-high output,
Out = 1, once in every 8 cycles as long as Stop = 0. When Stop = 1, however, the machine
stalls and it retains its current state.
S0
S0
S0
S0
S0
S8
S4
S12
S2
S10
S6
S0
S0
S0
S1
S9
S5
S3
S11
S7
S(N-1)
Fig. 2.32 State diagram of a counter with N states
clock
S0
S1
Stop
Out
S2
S3
S3
S3
S4
S5
S6
S7
S0
S1
S2
Fig. 2.33 Timing diagram of a state machine with a single input, Stop, and a single output
Once the state assignments are made for each clock cycle in Fig. 2.33, the state diagram
for a Moore-type state machine emerges in Fig. 2.34.
The ﬁrst and the second clock cycles in the timing diagram are assigned to the S0 and the
S1 states, respectively. The third clock cycle is assigned to the S2 state where Out = 1. The
fourth clock cycle corresponds to the S3 state. The machine stays in the S3 state as long as
2.11
Controller Design: Moore Machine Versus Counter-Decoder Scheme
91

Stop = 1. This ranges from the fourth to the sixth clock cycle in the timing diagram. The state
assignments from the seventh to the tenth clock cycle become the S4, S5, S6 and S7 states,
respectively. The eleventh clock cycle returns to the S0 state.
Implementing the state diagram in Fig. 2.34 follows a lengthy process of producing state
tables, transition tables, and K-maps, resulting in a total of four outputs (three ﬂip-ﬂop
outputs due to eight states and one output for Out). However, using a counter-decoder
approach minimizes this design task considerably and reveals a rather explicit circuit
implementation.
When the timing diagram in Fig. 2.33 is redrawn to implement the counter-decoder design
approach, it yields a simple three-bit counter which counts from zero to seven as shown in
Fig. 2.35. The counter output, CountOut, is included in this ﬁgure to show the relationships
between the state assignments, the input (Stop) and the output (Out). The ﬁgure also shows
the clock cycle where the counter resets itself when its output reaches seven.
S0
S4
S2
S6
S1
S5
S3
S7
Out = 0
Out = 0
Out = 1
Out = 0
Out = 0
Out = 0
Out = 0
Out = 0
Stop = 1
Stop = 1
Stop = 1
Stop = 1
Stop = 1
Stop = 1
Stop = 1
Stop = 1
Stop = 0
Stop = 0
Stop = 0
Stop = 0
Stop = 0
Stop = 0
Stop = 0
Stop = 0
Fig. 2.34 Moore representation of the timing diagram in Fig. 2.33
92
2
Review of Sequential Logic Circuits

The ﬁrst task for the design is to construct a three-bit up-counter as shown in Fig. 2.36.
The counter in this ﬁgure is derived from a general counter topology, and it consists of a
three-bit adder, three 2-1 MUXes and three ﬂip-ﬂops. A three-input AND gate is used as a
decoder at the counter output to implement Out = 1 when the CountOut node becomes 2.
Therefore, this method follows a simple, step-by-step design approach in producing the ﬁnal
circuit that does not require implicit logic design techniques.
clock
S0
S1
0
CountOut
1
2
3
3
3
4
5
6
7
0
1
2
7
Stop
Out
S2
S3
S3
S3
S4
S5
S6
S7
S0
S1
S2
Fig. 2.35 Timing diagram of a three-bit counter with a single input, stop, and a single
output
clock
Out
+1
Stop
3
0
1
CountOut
Q
D
Fig. 2.36 Counter-decoder representation of the timing diagram in Fig. 2.35
2.11
Controller Design: Moore Machine Versus Counter-Decoder Scheme
93

2.12
Memory
Small memory blocks can be assembled from one-bit registers in a variety of conﬁgurations
as shown in Fig. 2.14. For example, a 32-bit wide, 16-bit deep memory block shown in
Fig. 2.37 can be built by stacking 16 rows of 32-bit registers on top of each other. Each
32-bit register contains tri-state buffers at its output to prevent logic contention during read
as shown in Fig. 2.38.
The inputs to each column of the memory block in Fig. 2.37 are connected together to
write data to a selected row. For example, the input terminal, IN[0], is connected to the In[0]
pins of all 32-bit registers between row 0 to row 15 to be able to write a single bit at a
selected row. The same is true for the remaining inputs, IN[1] to IN[31].
Similarly, all outputs of each column in Fig. 2.37 are connected together to read data from
the memory block. For example, the output pin, OUT[0], is connected to the Out[0] pin of
every 32-bit register from row 0 to row 15 to be able to read one bit from a selected row. The
same is true for the remaining output pins, OUT[1] through OUT[31].
Every row of the memory block in Fig. 2.37 is accessed by an individual Write Enable
(WE) and Read Enable (RE) signal for writing or reading data, respectively.
clock
IN[0]
OUT[0]
OUT[30]
OUT[31]
IN[30]
IN[31]
32-bit Register Row 15
32-bit Register Row 14
32-bit Register Row 0
WE[15]
4
Address [3:0]
WE
Address  Decoder
RE[15]
WE[14]
RE[14]
WE[0]
RE[0]
RE
Fig. 2.37 A 32x16 memory and the truth table of its address decoder
94
2
Review of Sequential Logic Circuits

In order to generate the WE inputs, WE[0] to WE[15], an address decoder is used. This
decoder enables only one row while deactivating all the other rows using a four-bit address,
Address[3:0], and a single WE input according to the truth table in Fig. 2.39. For example, a
32-bit data is written to row 0 if WE = 1 and Address[3:0] = 0000 at the decoder input.
However, WE = 0 blocks writing data to all rows of the memory block regardless of the
input address as shown in the truth table in Fig. 2.40.
The RE inputs, RE[0] to RE[15], use address decoders similar to Figs. 2.39 and 2.40 to
read a block of data from a selected row. The read operation is achieved with a valid input
address and RE = 1 according to the truth table in Fig. 2.41. The RE = 0 entry disables
reading data from any row regardless of the input address as shown in Fig. 2.42.
Therefore, a valid input address along with the RE and WE command inputs must be
provided to the memory in order to perform a read or a write operation, respectively.
The WE = 0, RE = 1 combination reads data from the selected row. Similarly, the WE = 1
and RE = 0 combination writes data to a selected row. The WE = 0 and RE = 0 combination
disables both reading and writing to the memory block. The control input entry, WE = 1 and
RE = 1, is not allowed, and it should be interpreted as memory read.
clock
In[0]
Out[0]
WE
1
0
Out[30]
Out[31]
1
0
1
0
In[30]
In[31]
Q
D
Q
D
Q
D
RE
Fig. 2.38 A 32-bit register slice at every row of Fig. 2.37
2.12
Memory
95

Address[3:0]
WE[15] WE[14] WE[13]
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
1
1
1
1
1
0
0
0
0
0
1
0
0
0
1
0
0
WE[2] WE[1] WE[0]
1
0
0
0
0
1
0
0
1
1
1
0
0
0
Fig. 2.39 The address decoder for the 32x16 memory in Fig. 2.37 when WE = 1
Address[3:0]
WE[15] WE[14] WE[13]
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
1
1
1
1
0
0
0
0
WE[2] WE[1]
0
0
0
0
0
0
0
0
WE[0]
0
0
0
0
0
0
0
0
1
1
1
0
0
0
Fig. 2.40 The address decoder for the 32x16 memory in Fig. 2.37 when WE = 0
Address[3:0]
RE[15] RE[14] RE[13]
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
1
1
1
1
1
0
0
0
0
RE[2] RE[1]
0
1
0
0
0
1
0
0
RE[0]
1
0
0
0
0
1
0
0
1
1
1
0
0
0
Fig. 2.41 The address decoder for the 32x16 memory in Fig. 2.37 when RE = 1
96
2
Review of Sequential Logic Circuits

2.13
A Design Example Using Sequential Logic and Memory
This design example combines the data-path and controller design concepts described in this
chapter and in Chap. 1. It also introduces the use of important sequential logic blocks such as
ﬂip-ﬂop, register, counter and memory in the same design.
Every design starts with gathering small or large logic blocks to meet the functional
speciﬁcations of the design and to construct a data-path for proper data-ﬂow. Once the
data-path is set, then the precise data movements from one logic block to the next are
described using timing diagrams. Any architectural change in the data-path should follow a
corresponding change in the timing diagram or vice versa.
When the data-path design and the timing diagram fully associate with each other, and each
describes identical data movements, the next step in the design process is to build the
controller that governs the ﬂow of data. To deﬁne the states of the controller, the clock periods
that generate different sets of outputs are separated from each other and named individually as
distinct states. Similarly, the clock periods revealing identical outputs are grouped together
under the same state name. The controller can be Moore-type or Mealy-type state machine
according to the design needs. The design methodology of building the data-path, timing
diagram and controller shown here will be repeated in every design throughout this book,
especially when designing peripherals for a computer system in Chap. 7.
The example design in this section reads two eight-bit data packets from an 8x8 source
memory (memory A), processes them and stores the result in an 8x4 target memory (memory
B). The processing part depends on the relative contents of each data packet: if the contents
Address[3:0]
RE[15] RE[14] RE[13]
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
1
1
1
1
0
0
0
0
RE[2] RE[1]
0
0
0
0
0
0
0
0
RE[0]
0
0
0
0
0
0
0
0
1
1
1
0
0
0
Fig. 2.42 The address decoder for the 32x16 memory in Fig. 2.37 when RE = 0
2.13
A Design Example Using Sequential Logic and Memory
97

of the ﬁrst data packet are larger than the second, the contents of the data packets are added.
Otherwise, they are subtracted from each other before the result is stored.
The block diagram in Fig. 2.43 demonstrates the data-path required for this
memory-to-memory data transfer as described above. The timing diagram in Fig. 2.44 needs
to accompany the data-ﬂow in Fig. 2.43 since it depicts precise data movements and values
in each clock cycle.
To be able to write data to a memory address in Fig. 2.37, a valid data and address must
be available within the same clock cycle. In a similar fashion, data is read from the memory
core a cycle after a valid address is introduced.
Initially, counter A generates the addresses, 0 to 7, for memory A and writes the data
packets, A0 to A7, through DataInA[7:0] port. This is shown in the timing diagram in
Fig. 2.44 from clock cycles 1 through 8. When this task is complete, counter A resets and
reads the ﬁrst data packet A0 from AddrA[2:0] = 0 in clock cycle 9. In the next clock cycle,
A0 becomes available at DOut1, and the counter A increments by one. In cycle 11, AddrA
[2:0] becomes 2, the data packet A1 is read from DOut1[7:0], and the data packet A0
transfers to DOut2[7:0]. In this cycle, the contents of the data packets A0 and A1 are
compared with each other by subtracting A1 (at DOut1) from A0 (at DOut2). If the contents
of A0 are less than A1, then the sign bit, Sign, of (A0 – A1) becomes negative. Sign = 1
selects (A0 + A1) at ADDOut[7:0] and routes this value to DataInB[7:0]. However, if the
contents of A0 are greater than A1, (A0 – A1) becomes positive. Sign = 0 selects (A0 – A1)
and routes this value from SUBOut[7:0] to DataInB[7:0]. The result at DataInB[7:0] is
written at AddrB[1:0] = 0 of memory B at the positive edge of clock cycle 12. In the same
cycle, A1 is transferred to DOut2[7:0], and A2 becomes available at DOut1[7:0]. A com-
parison between A1 and A2 takes place, and either (A1 + A2) or (A1 – A2) is prompted to
be written to memory B depending on the value of the Sign node. However, this is an
unwarranted step in the data transfer process because the design requirement states that the
comparison has to be done only once between two data packets from memory A. Since A1 is
used in an earlier comparison with A0, A1 cannot be used in a subsequent comparison with
A2, and neither (A1 + A2) nor (A1 – A2) should be written to memory B. The remaining
clock cycles from 13 through 18 compare the values of A2 with A3, A4 with A5, and A6
with A7, and write the added or subtracted results into memory B. After clock cycle 19, all
operations on this data-path suspend, the counters are reset and all writes to the memory core
are disabled.
98
2
Review of Sequential Logic Circuits

Counter B
AddrB[1:0]
DataInB[7:0]
Memory A
Memory B
DataInA[7:0]
0
7
0
A0
A1
DOut1[7:0]
DOut2[7:0]
Sign
clock
A2
A3
A4
A5
A6
A7
1
2
3
4
5
6
7
0
7
0
B0
B1
B2
B3
1
2
3
1
0
C
O
M
P
clock
Counter A
AddrA[2:0]
clock
ADDOut
SUBOut
Q
D
8
8
8
3
2
Fig. 2.43 Data-path of a memory transfer example
2.13
A Design Example Using Sequential Logic and Memory
99

clock
DOut1
DOut2
AddrA
SUBOut
AddrB
ADDOut
0
1
2
3
7
0
1
2
3
A0
A1
A2
A3
A4
A5
6
A
7
A
4
5
6
7
0
A0
A1
A2
A3
A4
A5
6
A
7
A
A0+A1
A2+A3
A4+A5
A6+A7
A1+A2
A3+A4
A5+A6
A7+A0
A0-A1
A2-A3
A4-A5
A6-A7
A1-A2
A3-A4
A5-A6
0
1
3
2
DataInA
A0
A1
A2
A3
A7
A0
A7-A0
0
0
0
0
0
0
0
0
0
0
A0
A0
A0
A0
A0+A0
A0-A0
A0+A0
A0-A0
1
2
3
4
8
9
11
12
13
14
15
16
17
10
0
18
19
20
Fig. 2.44 Timing diagram for the memory transfer data-path in Fig. 2.43
100
2
Review of Sequential Logic Circuits

To
govern
the
data-ﬂow
in
Fig.
2.44,
a
Moore-type
state
machine
(or
a
counter-decoder-type controller) is used. A Mealy-type state machine for a controller design
is usually avoided because present state inputs of this type of a state machine may change
during the clock period and may cause jittery outputs to form.
The inclusion of the controller in Fig. 2.45 identiﬁes the necessary control signals to be
able to guide the data ﬂow in Fig. 2.44 properly. These signals increment the counters A and
B (with IncA and IncB), and enable writes to memory A or B (with WEA and WEB) when
necessary. Thus, the timing diagram in Fig. 2.44 is expanded to include these control signals
in Fig. 2.46, and this provides a complete picture of the data transfer process from memory A
to memory B in contrast to the earlier timing diagram in Fig. 2.44.
Counter B
AddrB[1:0]
DataInB[7:0]
IncB
Reset 
Memory A
Memory B
DataInA[7:0]
0
7
0
A0
A1
DOut1[7:0]
DOut2[7:0]
Sign
8
Controller
IncA
IncB
WEA WEB
Reset
WEB
clock
A2
A3
A4
A5
A6
A7
1
2
3
4
5
6
7
0
7
0
B0
B1
B2
B3
1
2
3
1
0
C
O
M
P
8
2
8
clock
Counter A
AddrA[2:0]
IncA
Reset 
WEA
clock
clock
ADDOut
SUBOut
Q
D
8
3
Fig. 2.45 Compete block diagram of the memory transfer example with controller
2.13
A Design Example Using Sequential Logic and Memory
101

The controller in Fig. 2.45 can be implemented either by a Moore-type state machine in
Fig. 2.47 or by a counter-decoder-type design in Fig. 2.48.
In the Moore type design, the states from S1 through S18 are assigned to each clock cycle
of the timing diagram in Fig. 2.46. The values of the present state outputs, WEA, IncA,
WEB and IncB, in each clock cycle are read from the timing diagram and attached to each
state in Fig. 2.47. The reset state, S0, is included in the Moore machine in case the data-path
receives an external reset signal to interrupt an ongoing data transfer process. Whichever
state the state machine may be in, a Reset = 1 entry always forces the current state to
transition back to the S0 state at the positive edge of the clock. These transitions are not
included in Fig. 2.47 for simplicity.
The counter-decoder style design in Fig. 2.48 consists of a ﬁve-bit counter and four
decoders to generate WEA, IncA, WEB and IncB control signals. To show the operation of
this design to generate WEA, for example, this particular decoder includes eight ﬁve-input
AND gates, one for each clock cycle from cycle 1 to cycle 8 in order to keep WEA = 1 in
Fig. 2.46. The ﬁve-bit counter implicitly receives a reset signal from its output when it
reaches clock cycle 18, and resets counter A, counter B and the rest of the system in
Fig. 2.45.
102
2
Review of Sequential Logic Circuits

clock
DOut1
DOut2
AddrA
SUBOut
AddrB
ADDOut
0
1
2
3
7
0
1
2
3
A0
A1
A2
A3
A4
A5
A7
A6
4
5
6
7
0
A0
A1
A2
A3
A4
A5
A7
A6
A0+A1
A2+A3
A4+A5
A6+A7
A1+A2
A3+A4
A5+A6
A7+A0
A0-A1
A2-A3
A4-A5
A6-A7
A1-A2
A3-A4
A5-A6
0
1
3
2
WEA
IncA
IncB
WEB
DataInA
A0
A1
A2
A3
A7
A0
A7-A0
0
0
0
0
0
0
0
0
0
0
A0
A0
A0
A0
A0+A0
A0-A0
A0+A0
A0-A0
1
2
3
4
8
9
11
12
13
14
15
16
17
10
Reset
0
18
19
20
Fig. 2.46 The complete timing diagram for the memory transfer in Fig. 2.45
2.13
A Design Example Using Sequential Logic and Memory
103

Reset = 1
S1
S0
S2
WEA = 1
IncA = 1
WEA = 1
IncA = 1
S3
S4
WEA = 1
IncA = 1
WEA = 1
IncA = 1
S5
S6
WEA = 1
IncA = 1
WEA = 1
IncA = 1
S7
S8
WEA = 1
IncA = 1
WEA = 1
IncA = 1
S9
S10
IncA = 1
IncA = 1
S18
IncB = 1
S17
S16
WEB = 1
S15
S14
S13
S12
IncA = 1
IncB = 1
S11
IncA = 1
WEB = 1
IncA = 1
WEB = 1
IncA = 1
IncB = 1
IncA = 1
WEB = 1
IncA = 1
IncB = 1
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset = 0
Reset =0
Fig. 2.47 Moore representation of the controller unit in Fig. 2.45
104
2
Review of Sequential Logic Circuits

WEA
IncA
WEB
IncB
clock
Reset
5
5-BIT UP-COUNTER
Fig. 2.48 Counter-decoder representation of the controller unit in Fig. 2.45
2.13
A Design Example Using Sequential Logic and Memory
105

Review Questions
1. Implement the following Moore machine:
S0
S1
S2
S3
in = 0
in = 0
in = 1
in = 1
in = 1
in = 0
in = 0
in = 1
out = 0
out = 1
out = 0
out = 0
2. Implement the following Moore machine using a timer. The timer is initiated when In =
1. With this input, the state machine goes to the A state and stays there for 10 cycles. In
the tenth cycle, the state machine transitions to the B state and stays in this state for only
one cycle before switching to the IDLE state. One implementation scheme is to construct
a four-bit up-counter to generate the timer. When the counter output reaches 9, the
decoder at the output of the counter informs the state machine to switch from the A state
to the B state.
IDLE
B
A
In = 0
In = 0
In = 1
In = 1
t < 10 clock cycles (CountOut = 0)
Out = 0
Out = 0
Out = 1
In = 1
t = 10 clock cycles (CountOut = 1)
106
2
Review of Sequential Logic Circuits

3. The following truth table needs to be implemented using two-input NAND gates and
inverters.
A
B
C
Out
0
0
0
0
0
0
1
1
0
1
0
2
0
1
1
3
1
0
0
3
1
0
1
2
1
1
0
1
1
1
1
0
TNAND (two-input NAND gate delay) = 500 ps
TINV (inverter delay) = 500 ps
tclk-q (clock-to-q delay) = 200 ps
tsu (setup time) = 200 ps
th (hold time) = 300 ps
(a) Implement this truth table between two ﬂip-ﬂop boundaries.
(b) Find the maximum clock frequency using a timing diagram.
(c) Shift the clock by 500 ps at the receiving ﬂip-ﬂop boundary. Show whether or not
there is a hold violation using a timing diagram.
4. A block diagram is given below:
BLOCK A
BLOCK B
A
CIN
T
clkshift
clk
B
Block A contains only two ﬂip-ﬂops. Block B contains a one-bit adder with SUM and
COUT outputs connected to two ﬂip-ﬂops as shown below.
2.13
A Design Example Using Sequential Logic and Memory
107

CIN
A
B
clkshift
D
Q
D
Q
COUT
SUM
(a) Using the logic gates with propagation delays listed below, determine the setup time
for A, B, and CIN with respect to clkshift.
100ps
200ps
200ps
400ps
400ps
(b) Assuming T = 0 ns and TCLK (clock period) = 5 ns, if data at A, B and CIN become
valid and stable 4 ns after the positive edge of clkshift, will there be any timing
violations? Assume tH (hold time) = 3 ns for the ﬂip-ﬂop.
(c) How can you eliminate the timing violations? Show your calculations and draw a
timing diagram with no timing violations.
5. A schematic is given below:
D
Q
D
Q
TA
TB
D
Q
TC
IN1
IN2
clkTx
clkRx
A
B
C
D
108
2
Review of Sequential Logic Circuits

(a) If tsu (setup time) = 200 ps, th (hold time) = 200 ps and tclk-q (clock-to-q delay) =
300 ps for the ﬂip-ﬂop, and TA = 1000 ps, TB = 100 ps for the internal logic blocks
on the schematic, show if there is any timing violation or timing slack in a detailed
timing diagram if TC = 0 ps.
(b) What happens if TC = 400 ps? Show it in a separate timing diagram.
6. The state diagram of a Moore machine is given below:
A
B
C
out = 0
out = 1
out = 1
in = 0
in = 0
in = 1
in = 1
in = 0
in = 1
The assignment of the states A, B and C are indicated as follows:
states
PS[1]
PS[0]
A
B
C
0
0
0
1
1
1
(a) Implement this state machine using inverters, two-input and three-input AND gates
and two-input OR gates.
(b) Find the maximum operating frequency of the implementation in part (a) if the
following timing assignments are applied:
tsu (setup time) = 100 ps, th (hold time) = 100 ps, tclk-q (clock-to-q delay) = 200 ps,
TINV (inverter delay) = 200 ps, TAND2 (two-input AND gate delay) = 300 ps, TAND3
(three-input AND gate delay) = 400 ps, TOR2 (two-input OR gate delay) = 400 ps.
7. Data is transferred from Memory Tx to Memory Rx starting from the address 0x00 and
ending at the address 0x0F as shown below. Once a valid address is produced for
Memory Tx, the data is read from this address at the next positive clock edge. On the
other hand, data is written to Memory Rx at the positive edge of the clock when a valid
address is available. The operating clock frequency of Memory Tx is twice the clock
frequency of Memory Rx.
2.13
A Design Example Using Sequential Logic and Memory
109

0xFF
0xEE
0xDD
0xCC
0xBB
0xAA
0x99
0x88
0x77
0x66
0x55
0x44
0x33
0x22
0x11
0x00
7
0
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
clock Tx
Memory Tx
7
0
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
clock Rx
Memory Rx
(a) Assuming address generators for Memory Tx and Memory Rx start generating valid
addresses at the same positive clock edge, show which data is actually stored in
Memory Rx using a timing diagram. Indicate all the address and data values for
Memory Tx and Memory Rx in the timing diagram.
(b) Now, assume that the operating clock frequency of Memory Tx is four times higher
than the clock frequency of Memory Rx, and an actual write to Memory Rx takes
place at the negative edge of the clock when a valid address is present. Redraw the
timing diagram indicating all address and data values transferred from Memory Tx to
Memory Rx.
8. Serial data is transferred to program four eight-bit registers. The start of the transfer is
indicated by a seven-bit sequence = {1010101} immediately followed by the address of
the register (two bits) and the data (eight bits). The transfer stops after programming the
last register. After this point, all other incoming bits to the serial input are ignored. Design
this interface by developing a data-path and a timing diagram simultaneously. Implement
the state diagram. Can this controller be implemented by a counter-decoder scheme?
110
2
Review of Sequential Logic Circuits

Projects
1. Implement the one-bit register in Fig. 2.14 and verify its functionality using Verilog. Use
timing attributes in the ﬂip-ﬂop and the multiplexer to create gate propagation delays.
Change the clock frequency until set-up time violation is produced.
2. Implement the four-bit shift register in Fig. 2.16 and verify its functionality using Ver-
ilog. Use timing attributes for ﬂip-ﬂops and the multiplexers to create gate propagation
delays. Examine the resulting timing diagram.
3. Implement the 32-bit counter in Fig. 2.18 and verify its functionality using Verilog.
4. Implement the four-state Moore-type state machine in Fig. 2.20 and verify its func-
tionality using Verilog.
5. Implement the four-state Mealy-type state machine in Fig. 2.27 and verify its function-
ality using Verilog.
6. Implement the three-bit counter-decoder in Fig. 2.36 and verify its functionality using
Verilog and examining the resulting timing diagram.
7. Implement the 32x16 memory block in Fig. 2.37 using Verilog. How can this memory be
veriﬁed functionally?
8. Implement the memory-to-memory transfer circuit in Fig. 2.45 and verify its functionality
using Verilog.
2.13
A Design Example Using Sequential Logic and Memory
111

3
Review of Asynchronous Logic
Circuits
A digital system is often comprised of different time domains. Some domains work with
clock, and data is sequentially transferred from one ﬂip-ﬂop (or latch) boundary to the next.
In other domains, data is asynchronously processed and handled without the aid of a clock.
This chapter introduces asynchronous circuits that require no clock input. The complete
design methodology is given in terms of state assignments from timing diagrams, con-
struction of ﬂow tables and gate minimization, which then leads to the implementation of
fundamental mode circuits [1]. The chapter concludes with an asynchronous timing
methodology with C (Mueller) elements that allows data propagation between logic blocks
without any clock input.
3.1
S-R Latch
A common storage element in asynchronous circuits is a Set-Reset (S-R) latch. This circuit is
composed of two NAND gates whose outputs are connected to their inputs as shown in Fig. 3.1.
Initially, both S and R inputs may be at logic 0, producing Q = Q = 1. If the S input
transitions to logic 1 while R = 0, Q stays at logic 1 and Q transitions to logic 0. This state is
called the set state of the S-R latch. If, on the other hand, the R input goes to logic 1 while
the S input stays at 0, Q transitions to logic 0 and Q stays at logic 1. This state is called the
S
R
Q
Q
1
2
Fig. 3.1 S-R latch
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9_3
113

reset state. Simultaneously changing both the S and R inputs from logic 0 to logic 1 causes a
racing condition. If NAND gate number 1 has a shorter gate delay than the NAND gate
number 2, Q switches to logic 0 ﬁrst, and forces Q to stay at logic 1. If NAND gate number 2
has a shorter gate delay, Q switches to logic 0 ﬁrst. Therefore, simultaneously switching
more than one input in asynchronous circuits creates unexpected outputs due to multiple
racing paths in a circuit. The fundamental-mode design methodology corrects this problem
by permitting only one input to change, and eliminates all unwanted transitions in the circuit.
3.2
Fundamental-Mode Circuit Topology
An asynchronous circuit requires no clock input to operate, and it is composed of a combi-
national logic block and a delay block. The delay block is a combinational logic circuit whose
inputs constitute the present state. The outputs of the delay block are fed back to the inputs of
the combinational logic to form the next state as shown in Fig. 3.2.
Designing an asynchronous circuit requires to follow a certain procedure. The ﬁrst task is
to form a primitive state ﬂow table tabulating all possible states and transitions that the
asynchronous circuit can produce. This table must contain only one stable state per row to
maintain the fundamental mode of operation. Similarly, another table, containing only the
outputs of the circuit, is formed. An output table is also formed, and it includes every output
change as the circuit makes a transition from one state to another. Minimization of state and
output tables is achieved by implication tables prior to producing a ﬁnal circuit. In asyn-
chronous circuit design, it is common to create race conditions where circuit delays produce
multiple simultaneous state transitions resulting in unwanted outputs. An effective method to
eliminate racing conditions is to work on the minimized state table and remove such state
transitions that cause the circuit to depart from its fundamental-mode of operation.
Combinational
Logic
Delay
inputs
outputs
present state
next state
Fig. 3.2 Fundamental mode asynchronous circuit topology
114
3
Review of Asynchronous Logic Circuits

3.3
Fundamental-Mode Asynchronous Logic Circuits
In this section, an example will be used to present the entire process designing
fundamental-mode asynchronous circuits from the creation of primitive ﬂow tables to the
removal of racing conditions.
The circuit in this example consists of two inputs, in1 and in2, and a single output. The
output is at logic 0 whenever in1 = 0. The ﬁrst change in in2 produces out = 1 while
in1 = 1. The output transitions back to logic 0 when in1 switches to logic 0.
The timing diagram in Fig. 3.3 summarizes the behavior of this circuit. State assignments
in the timing diagram follow the basic rule that requires the change in only one input per
state. All stable states are numbered and circled.
The state ①is when in1 = in2 = 0 and out = 0. Any change in in2 transitions the circuit to
the state ②with out = 0. Additional ripples at in2 while in1 = 0 change the state of the
circuit between the states ①and ②. Switching in1 from logic 0 to logic 1 while in2 = 1
forms a new state, state ③, and produces out = 0. The ﬁrst change in in2 while in1 = 1
creates another new state, state ④, with out = 1. As in2 transitions back from logic 0 to logic
1 while in1 = 1, the state of the circuit changes to the state ⑤, but the output stays at out = 1.
Further ripples in in2 while in1 = 1 create no change at the output, and the circuit ends up
transitioning between the states ④and ⑤. When in1 transitions to logic 0 while in2 = 1, the
state of the circuit switches back to the state ②. Finally, when in2 also switches back to logic
0, the state of the circuit becomes the state ①.
Now, let us assume that in1 transitions to logic 1 ﬁrst while in2 is steady at logic 0. This
condition creates a new state, state ⑥, with an output value of out = 0. When in2 also
transitions to logic 1 while in1 = 1, the state of the circuit changes from the state ⑥to a new
state, state ⑦, and out becomes logic 1. As soon as in2 goes back to logic 0 while in1 = 1,
the circuit also switches back to the state ④but out stays at logic 1. Further ripples in in2
while in1 = 1 simply change the state of the circuit between the states ④and ⑦. As soon as
1
2
2
3
4
5
2
1
6
7
4
7
2
1
in1
in2
out
Fig. 3.3 Timing diagram and state assignments
3.3
Fundamental-Mode Asynchronous Logic Circuits
115

in1 transitions back to logic 0, the circuit goes to the state ②. When in2 also changes to
logic 0, the circuit goes back to the state ①.
Constructing primitive state table and output ﬂow table is the direct extension of the
timing diagram in Fig. 3.3. When transferring stable, circled states from the timing diagram
to the primitive state table in Fig. 3.4, the fundamental-mode rule that enforces one stable
state per row is strictly observed. The non-circled states in this table are considered “tran-
sitionary” states: the circuit momentarily stays in these states until it makes a permanent
move to a stable state. For example, as in2 transitions from logic 0 to logic 1 while in1 stays
at logic 0 in the ﬁrst row of Fig. 3.4, the state of the circuit changes from the stable state
①to the transitionary state 2. The circuit stays in this transitionary state only for a brief
moment until it ﬁnally transitions to the stable state ②in row 2. Similarly, as in1 switches
from logic 0 to logic 1 while in2 = 1, the circuit transitions from the state ②to the state
③through a transitionary state 3 in the second row. All simultaneous dual input transitions
are forbidden because of the primary rule in the fundamental mode of operation. Therefore, a
transition from in1 = in2 = 0 to in1 = in2 = 1 in the ﬁrst row is not allowed. In this ﬁgure,
the boxes marked with “-” indicate the forbidden transitions.
Primitive state and output ﬂow tables are usually integrated to produce a compact table as
shown in Fig. 3.5. Furthermore, labeling the present and next states clariﬁes the state
transitions and the output values during each transition. Figure 3.5 also separates the states
that produce out = 0 from the states that produce out = 1. This design practice comes in
handy during the minimization step when equivalence classes are formed.
in1 in2
2
-
6
1
3
-
-
2
4
1
-
5
-
2
4
1
-
7
-
2
4
1
2
3
4
5
6
7
00
01
11
10
in1 in2
0
0
0
1
1
0
1
00
01
11
10
Fig. 3.4 Primitive state (left) and output (right) ﬂow tables for Fig. 3.3
116
3
Review of Asynchronous Logic Circuits

The ﬁrst step towards state minimization is to form an implication table as shown in
Fig. 3.6. This table includes all permitted, forbidden and “implied” states that can either go
into the permitted or forbidden categories.
Figure 3.6 replicates the present state column in Fig. 3.5 in its vertical axis with the
exception of the state 1 (the ﬁrst row in Fig. 3.5), and in its horizontal axis with the exception
of state 7 (the last row in Fig. 3.5).
The box located at (2, 1) in Fig. 3.6 is checked because there are no other states involved
in a transition from the state ①to the state ②in Fig. 3.5. The box at (3, 1) contains 4-6,
because the “implied” states 6 and 4 in the column, in1 in2 = 10, in Fig. 3.5 must be
traversed in order to go from the state ①to the state ③. The columns, in1 in2 = 00 and 11,
contain forbidden transitions, and they cannot be used as implied states to allow a transition
from the state ①to the state ③. The only other column for a transition from the state ①to
2
-
6
1
3
-
-
2
4
1
-
7
1
-
5
-
2
4
-
2
4
1
2
3
6
5
7
00
01
11
10
in1 in2
0
0
0
0
1
1
1
00
01
11
10
in1 in2
1
2
3
6
4
5
7
ns
out
ps
4
Fig. 3.5 Integrated primitive state and output ﬂow tables
4-6
4-6
4-6
4-6
3-7
3-5
3-5
3-7
3-7
4-6
3-5
5-7
4-6
4-6
5-7
2
1
6
3
5
4
2
7
6
3
5
4
Fig. 3.6 The implication table for Fig. 3.5
3.3
Fundamental-Mode Asynchronous Logic Circuits
117

the state ③is the column, in1 in2 = 01, but it requires a transition from the state 2 to the state
2, which is not possible. The box at (4, 6) in Fig. 3.6 contains an “X” mark because the
outputs produced at the states ④and ⑥are different. The same applies to boxes at (5, 3) and
(7, 3). The box at (6, 3) contains two implied transitions, 3-7 and 4-6, which correspond to
the columns, in1 in2 = 11 and 10, respectively.
We can further eliminate some of the implied state entries in the implication table of
Fig. 3.6 if these states are “related” to the boxes that have already been crossed out.
Figure 3.7 shows the new implication table after eliminations. In this table, the boxes that
contain the transitionary states 4-6, 3-5 and 3-7 are safely crossed out since they are related
to the boxes at (4, 6), (5, 3) and (7, 3), respectively.
Forming the equivalence class table is the next step for minimization. First, all states in
the horizontal axis of the implication table in Fig. 3.7 are repeated backwards under the
“States” column in the equivalence class table in Fig. 3.8.
Column 5 in Fig. 3.7 contains a checked box. This box corresponds to a joint state, (5-7),
listed as an equivalence class in the ﬁrst row of Fig. 3.8. Column 4 in Fig. 3.7 consists of a
checked box at (4, 5) and a second box containing an implied state 5-7 at (4, 7). Therefore,
the second row of Fig. 3.8 contains two new joint states, (4, 5) and (4, 7), as well as the
earlier joint state, (5, 7), from the ﬁrst row. Since in this row the joint states, (5, 7), (4, 7) and
(4, 5), overlap, they can be combined in a compact joint state (4, 5, 7). Columns 6 and 3 in
Fig. 3.7 have crossed-out boxes that contain no implied states. Therefore, the third and the
fourth row of Fig. 3.8 do not have new state entries, but only a single combined state carried
over from the second row. Column 2 in Fig. 3.7 has also crossed-out boxes except at (2, 3),
and this produces a new joint state, (2, 3), in the ﬁfth row of Fig. 3.8. Finally, column 1 in
Fig. 3.7 contains two checked boxes at (1, 2) and (1, 6), which form two additional joint
states, (1, 2) and (1, 6), in the last row of Fig. 3.8. Therefore, the ﬁnal equivalence class list
includes the joint states, (4, 5, 7), (2, 3) and (1, 6). The joint state (1, 2) is a shared state
between (2, 3) and (1, 6), and it is absorbed in the ﬁnal list.
5-7
2
1
6
3
5
4
2
7
6
3
5
4
Fig. 3.7 The implication table after eliminations
118
3
Review of Asynchronous Logic Circuits

The ﬁnal equivalence class list indicates the presence of only three states. Therefore, the
same number of states must be present in the minimal state ﬂow table in Fig. 3.9, where the
joint states, (1, 6), (2, 3) and (4, 5, 7) are assigned to the states A, B and C, respectively.
In Fig. 3.5, the present states ①and ⑥correspond to the states ①and 1 when in1 in2 =
00. However, the states ①and 1 now belong to the new assigned state A in Fig. 3.9.
Therefore, the present state A transitions to a stable state A with out = 0 when in1 in2 = 00.
Similarly, the present states ①and ⑥in Fig. 3.5 correspond to the states 2 and “-” when in1
in2 = 01, and produce no output. In the new table, this translates to a transition from the
present state A to the stable state B when in1 in2 = 01. The other entries in the next state, ns,
and the output, out, columns in Fig. 3.9 are formed in a similar manner.
The three states, A, B and C, in Fig. 3.9 require two next state bits, ns1 and ns2. The state
assignments are shown in Fig. 3.10.
States
Equivalence Classes
5
4
6
3
2
1
Final List
(5, 7)
(5, 7) (4, 7) (4, 5) = (4, 5, 7)
(4, 5, 7)
(4, 5, 7) (2, 3) 
(4, 5, 7)
(4, 5, 7) (2, 3) (1, 2) (1, 6)
(4, 5, 7) (2, 3) (1, 6)
Fig. 3.8 Equivalent class table
B
C
A
C
A
B
A
B
C
00
01
11
10
in1 in2
0
-
-
0
-
0
0
-
-
-
1
1
00
01
11
10
in1 in2
ps
A
B
C
(1, 6) = A
(2, 3) = B
(4, 5, 7) = C
out
ns
Fig. 3.9 Minimized integrated primitive state and output ﬂow tables
3.3
Fundamental-Mode Asynchronous Logic Circuits
119

Employing the state assignment table in Fig. 3.10 in the combined minimal state and
output ﬂow table in Fig. 3.9 leads to the state and the output K-maps in Fig. 3.11. The
crossed-out entries in this ﬁgure correspond to “don’t care” conditions, and they are treated
as either logic 0 or logic 1 to achieve the minimal Sum of Products (SOP) expression for
each K-map.
Finally, the SOP expressions for ns1, ns2 and out in Fig. 3.11 generate the circuit diagram
in Fig. 3.12. To draw the complete circuit, ﬁrst combinational logic blocks for ns1, ns2 and
out are formed using their SOP expressions. Then, each next state, ns1 and ns2, is connected
to its corresponding present state, ps1 and ps2, to complete the circuit diagram in Fig. 3.12.
0
0
1
0
0
0
0
1
0
0
1
1
00
01
11
10
in1 in2
00
01
11
10
ns1
ps1 ps2
0
1
1
0
0
1
1
1
0
1
1
1
00
01
11
10
in1 in2
00
01
11
10
ns2
ps1 ps2
0
0
0
0
1
1
00
01
11
10
in1 in2
00
01
11
10
out
ps1 ps2
ns2 = in2 + in1.ps2
out = in1.ps1
ns1 = in1.ps1 + in1.in2.ps2 + in1.in2.ps2
Fig. 3.11 K-maps for the next states, ns1 and ns2, and the output, out
A
B
C
ns1
ns2
0
0
0
1
1
1
Fig. 3.10 State assignments
120
3
Review of Asynchronous Logic Circuits

Even though the circuit in Fig. 3.12 represents the required state behavior, it may not
eliminate all possible racing conditions. When the state table in Fig. 3.9 is transformed into a
state diagram in Fig. 3.13, the forward and backward transitions between the states A and C
may induce racing conditions because two inputs change simultaneously.
To prevent racing conditions, a ﬁctitious fourth state is introduced between the states A
and C in Fig. 3.13. This fourth state, a, forms a bridge when going from the state A to the
state C (or vice versa) and allows only one state input to change to prevent possible hazards
as shown in Fig. 3.14.
in1
in2
ns1
ns2
ps2
ps1
out
Fig. 3.12 Fundamental mode asynchronous circuit for Fig. 3.3
A = 00
B = 01
C = 11
racing condition
may exist 
during these 
transitions
Fig. 3.13 State diagram showing possible racing conditions
3.3
Fundamental-Mode Asynchronous Logic Circuits
121

However, the inclusion of the new state, a, necessitates reconﬁguring the original state
table in Fig. 3.9. The new state table contains the state a as a transitionary state in Fig. 3.15,
and the transitions into this state do not produce any output.
When the hazard-free state and output K-maps are formed based on the ﬂow table in
Fig. 3.15, the resultant SOP expressions for ns1 and ns2 in Fig. 3.16 contain only an
additional term with respect to the ones in Fig. 3.11. This is a small price to pay in the total
gate count for the beneﬁt of eliminating all racing conditions.
A = 00
B = 01
α = 10
C = 11
α
α
No hazard
A              C
or 
C              A
Fig. 3.14 Reconﬁguration of the state diagram to eliminate racing conditions
b
α
a
c
α
b
a
b
c
00
01
11
10
in1 in2
0
-
-
0
-
0
0
-
-
-
1
1
00
01
11
10
in1 in2
ps
a
b
c
a
b
c
out
ns
a
-
c
-
-
-
-
-
α
Fig. 3.15 Integrated state and output ﬂow tables without racing conditions
122
3
Review of Asynchronous Logic Circuits

3.4
Asynchronous Timing Methodology
Asynchronous data propagation through combinational logic blocks can be achieved using
C-elements (Mueller elements) as shown in Fig. 3.17.
In this ﬁgure, combinational logic blocks, CL1, CL2 and CL3, are connected through
ﬂip-ﬂops to propagate data. However, data propagation through the combinational logic does
not have to be complete within a ﬁxed clock period as in conventional sequential circuits.
The C-elements in conjunction with inverting delay blocks, D1, D2 and D3, allow variable
data propagation to take place for each stage.
As data propagates through a particular combinational logic block, the positive edge
produced at the Cout terminal of a C-element also propagates through the corresponding
delay circuit. When data reaches the next ﬂip-ﬂop boundary, the C-element in this stage also
produces a positive Cout edge for the ﬂip-ﬂop to fetch the incoming data.
data1 D
Q
CL1
D
Q
CL2
D
Q
CL3
D
Q
C
C
D1
C
D2
C
D3
data2
data3
data4
Cout1
Cout2
Cout3
Cout4
Cin4
Cin3
Cin2
F1
F2
F3
Fig. 3.17 Asynchronous timing methodology using C-elements
0
0
1
0
0
0
0
1
1
0
1
1
00
01
11
10
in1 in2
00
01
11
10
ns1
ps1 ps2
0
1
0
1
0
0
0
1
1
1
0
1
1
1
00
01
11
10
in1 in2
00
01
11
10
ns2
ps1 ps2
0
1
0
0
0
0
1
1
00
01
11
10
in1 in2
00
01
11
10
out
ps1 ps2
ns1 = in1.ps1 + in1.in2.ps2 + in2.ps1.ps2 + in1.in2.ps2
out = in1.ps1
ns2 = in1.in2 + in1.ps2 + in1.ps1
Fig. 3.16 Next state and output K-maps producing no racing conditions
3.4
Asynchronous Timing Methodology
123

The details of variable data propagation in Fig. 3.17 are illustrated in the timing diagram
in Fig. 3.18. In this ﬁgure, the C-element produces a positive edge at Cout1 and enables the
ﬂip-ﬂop to dispatch data1 from its output after a clock-to-q delay. As this data propagates
through the combinational logic block, CL1, the positive edge of Cout1 also travels through
the delay block, D1, and reaches the next C-element to form a positive edge at Cout2 to fetch
the incoming data.
Data propagation in the second stage and the positive edge formation of Cout2 is identical
to the ﬁrst stage with the exception of longer propagation delays, CL2 and D2. The third stage
presents a much smaller propagation delay, CL3, and requires a smaller delay element, D3.
Even though each combinational data-path delay in Fig. 3.18 is approximately twice as
large as the propagation delay of its corresponding delay element, the ﬂip-ﬂop set-up time,
tsu, must be taken into account to ﬁne-tune the length of delay for each delay element.
Figure 3.19 shows the detailed Input/Output timing diagram of the C-element. In the ﬁrst
stage of the data-path (CL1 in Fig. 3.17), a positive edge at Cout1 travels though the
inverting delay element, D1, and produces a negative edge at Cin2 for the next C-element.
The C-element is designed such that the negative edge at its Cin input creates a negative
edge from its F output. Therefore, the negative edge at the F1 node comes back to the ﬁrst
C-element as an input and prompts the ﬁrst C-element to lower its Cout output, resulting in
Cout1 = 0, and creating a pulse with a duration of D1. The negative edge at Cout1, on the
other hand, travels through the inverting delay element, D1, the second time, and produces a
data1
D1
D1
Cout1
data2
Cout2
data3
Cout3
data4
Cout4
D2
D2
D3
D3
tsu
tsu
tsu
CL1 = 2D1 - tsu
CL2 = 2D2 - tsu
CL3 = 2D3 - tsu
Fig. 3.18 A timing diagram with variable clock lengths and stage delays
124
3
Review of Asynchronous Logic Circuits

positive edge at Cin2. This positive edge, in turn, enables the second C-element to generate
positive edges at F1 and Cout2 to latch the valid data at the data2 port.
As the data propagates through the second stage, the sequence of timing events that took
place between the ﬁrst and second C-elements repeat once again between the second and the
third C-elements that deﬁne the boundaries of CL2. This results in generating a positive
pulse at the Cout2, two negative pulses at Cin3 and F2, and a positive Cout3 edge to be able
to receive a new data at data3.
The vertical slicing in Fig. 3.19 helps to deﬁne all possible stable states in designing the
C-element. Even though Fig. 3.19 only samples the inputs and the outputs of the second
C-element, all C-elements in Fig. 3.17 yield identical results. Every stable state from the
state ①to the state ④allows only one input change as the fundamental-mode rule in
asynchronous design methodology. The state ①is entered when Cin2 = F2 = 1, and pro-
duces F1 = 1 and Cout2 = 0. As Cin2 transitions to logic 0, the circuit goes into the state ②
where it yields F1 = 0 and Cout2 = 0. The start of the pulse at Cout2 deﬁnes the state ③
Cout1
Cout2
Cout3
F3
Cin2
F1
Cin3
F2
Cin4
D1
D1
D2
D2
D3
D3
1
2
3
4
1
F2 = 1
Cin2 = 1
F1 = 1
Cout2 = 0
F2 = 1
Cin2 = 0
F1 = 0
Cout2 = 0
F2 = 1
Cin2 = 1
F1 = 1
Cout2 = 1
F2 = 0
Cin2 = 1
F1 = 1
Cout2 = 0
F2 = 1
Cin2 = 1
F1 = 1
Cout2 = 0
Fig. 3.19 C-element and delay-element input/output activity in Fig. 3.17
3.4
Asynchronous Timing Methodology
125

where Cin2 transitions back to logic 1, and both outputs, F1 and Cout2, change to logic 1.
The last state, state ④, emerges when F2 switches to logic 0. This state also causes Cout2 to
change to logic 0, but retains F1 at logic 1. The transition of F2 to logic 1 prompts the
C-element to go back to the state ①.
All possible state and output changes of the C-element in Fig. 3.19 are condensed in an
integrated state and output ﬂow table in Fig. 3.20. In this ﬁgure, the “?” mark indicates that
the C-element never reaches these transitionary cases. The “-” mark again deﬁnes the for-
bidden states where the fundamental-mode design is violated.
The state assignments for the four stable states in Fig. 3.20 are shown in Fig. 3.21. This is
a vital step in the design since the states in Fig. 3.20 are still in symbolic form and have not
yet been converted into binary values.
Since the fundamental-mode design rule of changing only one input between state
transitions is fully observed, the state table in Fig. 3.22 shows no potential racing hazards in
the current C-element design.
-
?
2
?
-
3
-
4
?
?
1
-
1
2
3
4
00
01
11
10
F2  Cin2
10
00
11
10
00
01
11
10
F2  Cin2
1
2
3
4
ns
F1  Cout2
ps1  ps2
Fig. 3.20 Integrated primitive state and output ﬂow tables for C-element
ns1
ns2
0
0
0
1
1
1
1
0
1
2
3
4
Fig. 3.21 State assignments for Fig. 3.20
126
3
Review of Asynchronous Logic Circuits

Once the primitive ﬂow table and the state assignments are complete, the next state and
the output K-maps of the C-element can be constructed as shown in Fig. 3.23.
1
= 00
2
= 01
4
= 10
3
= 11
No hazard!
One state-bit 
at a time
Fig. 3.22 Hazard-free state diagram of the C-element
ns1 = F2.Cin2.ps2 + F2.Cin2.ps1 = Cin2.(F2.ps2 + F2.ps1)
ns2 = F2.Cin2.ps2 + F2.Cin2.ps1 = F2.(Cin2.ps2 + Cin2.ps1)
F1 = Cin2.ps1 + F2.Cin2 = Cin2.(ps1 + F2) 
Cout2 = Cin2.ps1.ps2
-
?
0
0
?
-
1
0
-
1
1
?
00
01
11
10
F2 Cin2
00
01
11
10
ns1
ps1 ps2
?
1
0
-
-
?
0
1
?
-
1
1
-
0
1
?
00
01
11
10
F2 Cin2
00
01
11
10
ns2
ps1 ps2
?
0
0
-
-
?
1
?
-
0
-
1
?
00
01
11
10
F2 Cin2
00
01
11
10
F1
ps1 ps2
?
1
-
-
?
0
?
-
0
-
1
?
00
01
11
10
F2 Cin2
00
01
11
10
Cout2
ps1 ps2
?
0
-
Fig. 3.23 Next state and output K-maps of the C-element
3.4
Asynchronous Timing Methodology
127

In this ﬁgure, the cases marked by “?” and “-” are directly transferred from the primitive
ﬂow table in Fig. 3.20. When generating the SOP expressions for the ns1, ns2, F1 and Cout2
outputs, the cases marked with “?” and “-” signs in Kmaps are deliberately excluded from
the SOP expressions in Fig. 3.23. This ensures that unwanted state transitions and outputs do
not take place in the ﬁnal circuit in Fig. 3.24.
The input and output names of the second C-element in Fig. 3.17 are also changed for a
generic C-element. According to Fig. 3.24, the inputs, Cin2 and F2, have become Cin and Fin,
andtheoutputs,F1and Cout2,havebecomeFoutandCout ofa genericC-element, respectively.
ns1
ps1
Cin2 (Cin)
F2 (Fin)
Cout2 (Cout)
F1 (Fout)
ns2
ps2
Fig. 3.24 C-element circuit according to the fundamental mode design rules
128
3
Review of Asynchronous Logic Circuits

Review Questions
1. An asynchronous circuit has two inputs, in1 and in2, and an output, out. When in1 = 1,
the ﬁrst transition from logic 0 to logic 1 at in2 generates out = 1 in the waveform below.
Output stays at logic 1 unless in1 goes back to logic 0. The ﬁrst transition from logic 1 to
logic 0 at in2 switches the output back to logic 0 while in1 = 0.
A sample waveform is given below.
in1
in2
out
Deﬁne all possible states using the waveform above and form an integrated primitive state
and output ﬂow table. Form an associated implication table leading to the minimization of
states and outputs. Design the resultant fundamental mode asynchronous circuit.
2. An asynchronous circuit has two inputs, in1 and in2, and an output, out. When in1 = 0, the
ﬁrst transition at in2 produces out = 0 as shown in the waveform below. When in1 = 1, a
transition from logic 0 to logic 1 at in2 increments the value of out by one. When out = 3
and in1 = 1, an additional logic 0 to logic 1 transition at in2 produces out = 0.
Deﬁne the possible states from the waveform above, and form the primitive state and
output ﬂow tables. Deﬁne the resultant implication table to minimize the initial states and
outputs. Design the resultant fundamental mode asynchronous circuit.
3. An asynchronous circuit has three inputs, in1, in2 and in3, and an output, out. When all
inputs are at logic 0, the ﬁrst logic 0 to logic 1 transition at any input causes the output to
display the input ID. For example, a logic 0 to logic 1 transition at in1 while in2 =
in3 = 0 produces out = 1 because this value is the ID number of in1. Similarly, the ﬁrst
logic 0 to logic 1 transition at in2 while in1 = in3 = 0 produces out = 2. Logic 0 to
logic 1 transition at any input while one or more inputs are at logic 1 does not change the
in1
in2
out [1:0]
0
1
2
3
0
0
1
2
0
?
3.4
Asynchronous Timing Methodology
129

output value. Similarly, logic 1 to logic 0 transition does not affect neither the state of the
circuit nor the output value.
Form the primitive state, the output ﬂow table(s) and the implication table to minimize
the initial state and the output assignments from the waveform above. Design the fun-
damental mode asynchronous circuit.
4. The schematic below is a data-path of an asynchronous system controlled by the
C-elements. The combinational delays are shown by T1 through T4 blocks, each of
which has a single input and output. There are also junction delays, J1 through J4, which
accept two or more inputs and generate a single output.
(a) Compute D1 and D2 in terms of combinational and junction delays, T1, T2, T3, T4,
J1, J2, J3 and J4.
(b) Show the data-ﬂow that includes the signals from Cin1 to Cin3, and from Cout1 to Cout3
in a timing diagram. Assume the clock-to-q delay is equal to Tc in the timing diagram.
T1
J1
D
Q
T2
D
Q
T3
J2
D
Q
D
Q
D
Q
J3
T4
J4
D
Q
C
D1
C
D2
C
data1
data2
data3
data4
Cin1
Cout1
Cin2
Cout2
Cin3
Cout3
clock
clock
clock
out [1:0]
1
2
in1
2
3
?
in2
in3
130
3
Review of Asynchronous Logic Circuits

5. Data is transferred from a 32x8 source memory to a 32x8 destination memory as shown
in the schematic below. When a 32-bit data is fetched from the source memory, the high
(HI) and the low (LO) 16 bits are multiplied by an integer multiplier, and the product is
delivered at a destination address. The initial values of the source and the destination
addresses are zero and seven, respectively. During the data transfer the source address
increments by one while the destination address decrements by one until all eight data
packets in the source memory are processed. Assuming that the source and the desti-
nation memories are asynchronous in nature, and neither needs a clock input to read or
write data, include the C-elements in the circuit schematic to make this data transfer
possible. Assume Tacc is the access time to fetch data from the source memory, Twrite is
the time interval to write data to the destination memory, and Taddr is the time interval to
produce addresses from the address pointer 1 and the address pointer 2.
31
AddrC1
HI
LO
0
Addr1
clock
reset
incr1
Dout
32
16 lo
16 hi
31
HI
LO
0
Din
AddrC2
Addr2
clock
reset
incr2
Addr2 = 7
Addr2 = 0
32
Addr1 = 7
Addr1 = 0
Source 
memory
Destination 
memory
Projects
1. Implement the S-R latch in Fig. 3.1 and verify its functionality using Verilog.
2. Implement the fundamental mode asynchronous circuit in Fig. 3.12 and verify its
functionality using Verilog.
3. Implement the C-element in Fig. 3.24 and verify its functionality using Verilog.
Reference
1. Hill FJ, Peterson GR. Introduction to switching theory and logical design, 2d edn. Wiley, ISBN: 9780471042730
3.4
Asynchronous Timing Methodology
131

4
System Bus
A system bus is responsible for maintaining all communications between the Central
Processing Unit (CPU), system peripherals and memories. The system bus operates with a
certain bus protocol to exchange data between a bus master and a bus slave. The bus
protocol ensures to isolate all other system devices from interfering the bus while the bus
master exchanges data with a bus slave. Bus master initiates the data transfer, and sends or
receives data from a slave device or a system memory. Bus slave, on the other hand, does not
have the capability to start data transfer.
There are two types of bus architectures. Serial bus architecture is essentially composed of
a single data line between a master and a slave where data bits are exchanged one bit at a
time. A parallel bus, on the other hand, is comprised of many lines, and multitude of bits are
sent or received all at once. In this chapter, we will describe several serial and parallel bus
protocols and priority schemes.
4.1
Parallel Bus Architectures
There are two types of parallel bus architectures in a typical system: unidirectional bus and
bidirectional bus. A unidirectional bus contains two separate paths for data: one that orig-
inates from a bus master and ends at a slave, and the other that starts from a slave and ends at
the master. A bidirectional bus, on the other hand, shares the same data path which allows
data to ﬂow in both directions. However, this type of bus requires logic overhead and control
complexity.
Figure 4.1 below describes a 32-bit unidirectional bus architecture containing two bus
masters and three slaves. In this ﬁgure, the two unidirectional data-paths are highlighted with
thicker lines. The ﬁrst path is the “write” path, which a bus master uses to write data to a
slave. This path requires a Write Data (WData) port from every master and slave. The second
path is the “read” path for reading data from a slave. This also requires a Read Data (RData)
port from each master and slave. Both the bus master and the slave have address and control
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9_4
133

ports that deﬁne the destination address, the direction of data transfer, the data bit width and
the length of data.
All bus masters have to negotiate with a bus arbiter to gain the ownership of the bus
before starting a data transfer. When there are pending requests from multiple bus masters,
the arbiter decides which bus master should start the data transfer ﬁrst according to a priority
scheme and issues an acknowledgement to the bus master with the highest priority.
Therefore, every bus master has a Request (Req) and Acknowledge (Ack) port to com-
municate with the arbiter. Once the permission is granted, the master sends out the address
and control signals to the selected slave in the ﬁrst bus cycle, and writes or reads data in the
next cycle. The decoder (DEC) unit connected to the address bus generates an Enable
(EN) signal to activate the selected slave. Every master and slave device has a Ready port
that indicates if the selected slave is ready to transmit or receive data.
A 32-bit bidirectional bus architecture is shown in Fig. 4.2. The number of masters and
slaves are kept the same as in Fig. 4.1 for comparison purposes. The only difference between
the two ﬁgures is the replacement of the unidirectional data bus in the earlier architecture
with a bidirectional bus for reading and writing data. Tri-state buffers on data lines are
essential for bidirectional bus architectures to isolate nonessential system devices from the
Bus Master 1
Req1
Address1
WData1
DEC
Bus Slave 1
EN1
WData1
RData1
Bus Slave 2
EN2
WData2
RData2
Bus Slave 3
EN3
WData3
RData3
Control1
Bus Master 2
Req2
Address2
WData2
Control2
Control1
Control2
Control3
C1
C2
A1
A2
W1
W2
RData1
RData2
R1
R2
R3
ARBITER
Req[1:0]
Ack[1:0]
Ready1
Ready2
Ready3
32
32
Ready
Ready
32
32
Ack1
Ack2
Address1
Address2
Address3
2
2
33
32
32
32
3
3
Fig. 4.1 A unidirectional bus structure with two bus masters and three slaves
134
4
System Bus

bus when data transfer takes place between a master and a slave. The address bus in Fig. 4.2
can be also integrated with the data bus to allow both address and data to be exchanged on
the same bus. However, this scheme is much slower and requires extra control logic over-
head to maintain proper data-ﬂow and management.
Figure 4.3 shows all the Input/Output (I/O) ports of a typical bus master. The Req and
Ack ports directly communicate with the arbiter as mentioned earlier. Bus master uses the
“Ready” port to determine if the slave is ready to transmit or receive data. The WData,
RData and Address ports are used for writing and reading data, and specifying the slave
address, respectively. The control signals, Status, Write, Size and Burst, describe the nature
of the data transfer.
Bus Master 1
Req1
Address1
RData1
DEC
Bus Slave 1
EN1
Control1
Control1
ARBITER
Req[1:0]
Ack[1:0]
Ready1
32
Ready
32
Ack1
Address1
2
2
WData1
Bus Master 2
Req2
Address2
Control2
Ready
Ack2
Data1
Bus Slave 2
EN2
Control2
Ready2
Address2
Data2
Bus Slave 3
EN3
Control3
Ready3
Address3
Data3
WE1
RE1
WE2
RE2
RData2 WData2
3
3
3
2
2
Fig. 4.2 A bidirectional bus structure with two bus masters and three slaves
4.1
Parallel Bus Architectures
135

The Status port is a two-bit bus that describes the status of the bus master as shown in
Table 4.1. According to this table, the bus master may initiate a new data transfer by issuing
the START signal. If the master is in the midst of exchanging data with a slave, it issues the
Continue (CONT) signal. The IDLE signal is used when the bus master ﬁnishes the data
transfer. The bus master may also be in the midst of an internal operation while exchanging
data with a slave. For this particular instance, the master may momentarily stall the data
transfer by issuing the BUSY signal.
The Write port, as its name implies, describes if the master is in the process of writing or
reading data as shown in Table 4.2.
Table 4.1 Bus master Status control
Status[1:0]
0   0
0   1
1   0
1   1
Bus Master Status
Start Transfer (START) 
Continue Transfer (CONT) 
Finish Transfer (IDLE)
Pause Transfer (BUSY)
Table 4.2 Bus master Write control
Write
0
1
Bus Master Write
Read
Write
Bus
Master
Ack
Ready
32
RData[31:0]
From Slave
From Slave
Req
To Arbiter
To Slave
From Arbiter
Burst[3:0]
Size[1:0]
WData[31:0] 
Address[31:0]
Status[1:0]
Write
32
2
32
2
4
Fig. 4.3 Bus master interface
136
4
System Bus

The Size port describes the data bit width during a transfer and is shown in Table 4.3.
A bus master is allowed to transmit or receive data in eight bits (byte), 16 bits (half-word),
32 bits (word) or 64 bits (double-word), which cannot be changed during the transfer.
The Burst port describes the number of data packets to be sent or received by the bus
master according to Table 4.4. In this table, a bus master can transfer from one packet to over
32,000 packets of data in a single burst.
Figure 4.4 shows the I/O ports of a typical bus slave. The Req and Ack ports are omitted
since the slave is not authorized to initiate a data transfer. The Ready signal indicates if the
slave is ready to transmit or receive data once the transfer is initiated by the bus master. The
WData, RData and Address ports are used to write data, read data, and specify a destination
address, respectively. The control inputs, Status, Write, Size and Burst, describe the nature of
the transfer as mentioned above. The Enable (EN) input is produced by the address decoder,
and based on the address generated by the bus master to activate a particular slave.
Table 4.3 Bus master Size control
Size[1:0]
0   0
0   1
1   0
1   1
Number of bits
8
16
32
64
Table 4.4 Bus master Burst control
Burst[3:0]
0   0   0   0
0   0   0   1
0   0   1   0
0   0   1   1
0   1   0   0
0   1   0   1
0   1   1   0
0   1   1   1
1   0   0   0
1   0   0   1
1   0   1   0
1   0   1   1
1   1   0   0
1   1   0   1
1   1   1   0
1   1   1   1
1
2
4
8
16
32
64
128
256
512
1024
2048
4096
8192
16384
32768
Number of data packets
4.1
Parallel Bus Architectures
137

4.2
Basic Write Transfer
From this point forward, we will be using timing diagram(s) as a standard tool to show the
bus activity between a master and a slave.
The bus protocol for write describes how a bus master writes data to a slave on a
unidirectional bus as shown in Fig. 4.5.
Bus
Slave
EN
Ready
From Master
From Decoder
Burst[3:0]
Size[1:0]
RData[31:0] 
WData[31:0]
Status[1:0]
Write
32
2
32
2
Address[31:0]
32
To Master
4
Fig. 4.4 Bus slave interface
clock
Address
Controls
WData
Ready
WData1
A1
C1
A2
C2
A3
C3
WData2
slave reads WData1
Fig. 4.5 Basic write transfer
138
4
System Bus

In the ﬁrst clock cycle, the bus master sends out the destination address and the control
signals, A1 and C1, to the slave regardless of the slave status. If the slave status is “Ready”,
the actual data packet, WData1, is sent in the second cycle along with the address and the
control signals, A2 and C2, of the next data packet. The slave should be able to read WData1
at the positive edge of the second clock cycle if it is ready. However, there are instances
where the slave may not be ready to receive or send data. As an example, the slave changes
its status to “Not Ready” in the second cycle of Fig. 4.6. As soon as the slave’s status is
detected at the positive edge of the third clock cycle, the master stalls the write transfer. This
means that the current data packet, WData2, and the next address and control signals, A3 and
C3, are repeated as long as the slave keeps its Not Ready status. The normal data transfer
resumes when the slave becomes Ready to receive the remaining data.
Example 4.1: What happens to the write sequence when the slave changes its status
frequently?
When the slave changes its status to Not Ready during a clock cycle, the master detects
this change at the next positive clock edge, and holds the current data, the next address and
the control signals until the slave becomes Ready again.
An example where the slave changes its status frequently is shown in Fig. 4.7. In this
ﬁgure, the slave is Not Ready in the ﬁrst cycle. Therefore, the ﬁrst address and control
packets, A1 and C1, are prolonged, and no data is sent to the slave. When the slave produces
clock
Address
Controls
WData
Ready
WData1
A2
C2
A3
C3
Not Ready
detection
A1
C1
WData2
slave reads WData1
slave reads WData2
Fig. 4.6 Basic write transfer including the case Ready = 0
4.2
Basic Write Transfer
139

a Ready signal during the second cycle, the bus master produces the ﬁrst data packet,
WData1, and changes the address and control signals to A2 and C2 at the positive edge of
the third cycle. However, the slave decides to change its status to Not Ready once again
during the third and the fourth clock cycles. The master detects the status change at the
positive edge of the fourth and ﬁfth clock cycles and responds by not changing A2, C2 and
WData1. The Ready signal in the ﬁfth cycle prompts the master to produce A3, C3 and
WData2 at the beginning of the sixth cycle. The master holds these values until the
beginning of the eighth cycle when the slave changes its status to Ready again. At this point,
the master sends the new A4, C4 and WData3.
4.3
Basic Read Transfer
A basic read transfer is shown in Fig. 4.8. According to this ﬁgure, the slave produces data
for the master anytime after it issues the Ready signal. Once the master detects the Ready
signal at a positive clock edge, it produces the next address and the control signals for the
slave in the same cycle, but reads the slave’s response at the next positive clock edge.
clock
Address
Controls
WData
Ready
A1
A2
A3
C1
C2
C3
WData1
A4
C4
Cycle 1
Cycle 2
Cycle 3
Cycle 4
Cycle 5
Cycle 6
Cycle 7
Cycle 8
WData2
WData3
slave reads WData1
slave reads WData2
Fig. 4.7 A basic write transfer with varying Ready signal
140
4
System Bus

Example 4.2: What happens to the read sequence when the slave changes its status
frequently?
Figure 4.9 shows an example where the slave changes its status frequently. In this ﬁgure,
the slave is Not Ready prior to the ﬁrst cycle. Therefore, the master holds the ﬁrst address
and the control packets, A1 and C1, until the slave becomes Ready. When the master detects
a Ready signal at the positive edge of the third cycle, it responds by issuing a new set of
address and control signals, A2 and C2, for the slave. Within the third cycle, the slave also
issues RData1 for the master. The master is not able to read this data until it detects a Ready
signal from the slave at the beginning of the sixth cycle.
The rest of the read transactions in Fig. 4.9 follow the same protocol described above. In
other words, the master produces a new set of address and control signals every time it
detects a Ready signal from the slave, and the slave issues a new data packet for the master
after it becomes Ready.
RData
RData1
clock
Address
Controls
A1
C1
Ready
A2
C2
master reads RData1
A3
C3
RData2
Fig. 4.8 Basic read transfer
4.3
Basic Read Transfer
141

4.4
Bus Master Status Change
It is possible that the bus master may be intermittently busy during a data transfer. In the
event the bus master is busy to carry out its own internal tasks, the bus protocol requires the
bus master to hold the address, control and data values as long as it is busy.
Figure 4.10 illustrates an example where the bus master becomes Busy in clock cycles 2, 9
and 10 while writing data into a slave. The master starts the data transfer by issuing Status =
Start, and promptly sends out the ﬁrst address, A1. In the second cycle, the bus master
becomes busy with its internal operations and issues a Status = Busy signal. As a result, it
repeats the previous address, A1, but is unable to dispatch any data to the slave even though
Ready = 1 during this period. In the third cycle, all internal operations cease, and the bus
master continues the normal data transfer by generating Status = Cont signal. The master also
detects that the slave is Ready at the positive edge of the third cycle and issues the second
address, A2 along with the ﬁrst write data, WD1. In the next cycle, the master repeats A2 and
WD1 because the slave is not Ready at the positive edge of the fourth cycle. Despite the slave
showing the Not Ready condition in cycle 7, the normal data transfer sequence continues until
cycle 9 where the bus master changes its status to Busy again. This change, in turn, causes the
bus master to extend the address, A5, and the data, WD4, into cycles 9 and 10 irrespective of
the slave status.
clock
Address
Controls
Ready
RData
A1
A2
A3
C1
C2
C3
RData 1
RData 2
Cycle 1
Cycle 2
Cycle 3
Cycle 4
Cycle 5
Cycle 6
Cycle 7
Cycle 8
master reads RData1
master reads RData2
Fig. 4.9 A basic read transfer with varying Ready signal
142
4
System Bus

Example 4.3: What happens to the data transfer when the master changes its status
frequently?
Assume that the bus master transfers two half words (16-bit wide data packets) to the
addresses 0x20 and 0x22 of a memory block followed by 4 words (32-bit wide data packets)
to the addresses 0x5c, 0x60, 0x64 and 0x68. The address map of this byte addressable memory
is shown in Fig. 4.11 where the numbers in each box indicate individual byte addresses.
During the data transfer, the master issues frequent Busy signals during cycles 2, 3, 4, 7
and 8 as shown in the timing diagram in Fig. 4.12. Note that the slave is continuously Ready
from cycle 2 until the end of the data transfer.
WData[31:0]
START
BUSY
A1
A2
A3
A4
A5
A5
WD1
WD2
clock
Status[1:0]
Address[31:0]
Ready
CONT
CONT
Cycle 1
Cycle 2
Cycle 3
Cycle 4
Cycle 5
Cycle 6
Cycle 7
Cycle 8
Cycle 9
Cycle10
Cycle11
WD3
WD4
WD4
BUSY
slave
reads 
WData1
slave
reads 
WData2
slave
reads 
WData3
slave
reads 
WData4
A1
A6
WD5
slave
reads 
WData5
Fig. 4.10 Bus master Status control change
20
21
22
23
5c
5d
5e
5f
60
61
62
63
64
65
66
67
68
69
6a
6b
Fig. 4.11 A byte-addressable memory
4.4
Bus Master Status Change
143

The bus master starts transferring the ﬁrst data packet by issuing Status = Start, Burst =
Two (data packets), Size = Half word, Write = 1 and Address = 0x20 in the ﬁrst cycle
according to Tables 4.1, 4.2, 4.3 and 4.4. Since the slave is Ready at the beginning of the
second cycle, the master prepares to dispatch the next address, 0x22, and the ﬁrst write data,
Data 20. However, in this cycle the master also becomes busy with internal operations until
the beginning of the ﬁfth cycle and issues a Busy signal as shown in Fig. 4.12. The Busy
condition requires the bus master to repeat its control, address and data signals during this
period. Therefore, when the master ﬁnally changes its status to Cont in the ﬁfth cycle, it is
able to send Data 20 in the same cycle, and Data 22 in the following cycle.
As soon as the ﬁrst data transfer ﬁnishes, the master starts another write transfer in the
sixth cycle by issuing Status = Start, Burst = Four (data packets), Size = Word, Write = 1 and
Address = 0x5C. Since the slave’s status is Ready, the master prepares to issue the next
address and data packets at the beginning of the seventh cycle. However, its internal
operations interfere with this process once again until the beginning of the ninth cycle. The
master issues a Busy signal, and repeats its control, address and data outputs. When the
master ﬁnally changes its status to Cont in the ninth cycle, it delivers the second address,
0x60, and the ﬁrst data, Data 5C. In the tenth cycle, the next address, 0x64, and data, Data
60, are issued, respectively. The master writes Data 64 in the eleventh cycle, and ﬁnishes the
transfer by writing the last data, Data 68, in the twelfth cycle. In this cycle, the bus master
changes its status to Idle, indicating the end of the data transfer.
clock
Status[1:0]
Burst[3:0]
Size[1:0]
Wdata[31:0]
START
BUSY
CONT
BUSY
Address[31:0]
Ready
CONT
2
HW
HW
WORD
Data22
Data60
Data64
20
20
5C
64
HW
5C
START
Write
Data22
WORD
WORD
WORD
2
4
4
4
4
4
WORD
68
Data68
2
IDLE
Cycle 1
Cycle 2
Cycle 3
Cycle 4
Cycle 5
Cycle 6
Cycle 7
Cycle 8
Cycle 9
Cycle 10
Cycle 11
Cycle 12
22
60
Data20
Data5C
Data20
is written
Data22
is written
Data5C
is written
Data60
is written
Data64
is written
Data68
is written
Fig. 4.12 A write transfer example to the byte addressable memory in Fig. 4.11
144
4
System Bus

4.5
Bus Master Handshake
Each bus master communicates with the arbiter using request-acknowledge signals, which
form the basic “handshake” protocol. The master needing a data transfer issues a request
signal, Req, requesting the ownership of the bus from the arbiter. The arbiter grants this
request by an acknowledgement signal, Ack. If there is no ongoing data transfer, the
acknowledgement is usually issued in the following cycle after the master generates a
request. However, the Ack signal may not be generated many cycles after the Req signal is
issued due to an existing data transfer.
Figure 4.13 shows the timing diagram of a handshake mechanism between a bus master
and the arbiter before the bus ownership is granted to the master. The double “*” sign on
the Ack signal signiﬁes that this signal is generated many cycles after the arbiter has received
a request from the bus master. As soon as the master receives the Ack signal in the nth cycle,
it changes its status to Start in the (n + 1)th cycle, and sends out the ﬁrst address, A1,
regardless of the slave’s status. If the slave is Ready, the master subsequently sends out the
second address, A2, and the ﬁrst data, WData1, in the following cycle.
4.6
Arbiter
Bus arbitration is an essential part of bus management if there are more than one bus master
requesting the ownership of the bus. The arbitration is either hardware-coded and imple-
mented as a state machine or programmable and register-based.
clock
Ready
Ack
Req
WData1
Status[1:0]
A1
A2
WData[31:0]
Address[31:0]
START
CONT
Cycle n
Cycle (n+1) Cycle (n+2) Cycle (n+3) Cycle (n+4)
A3
CONT
WData2
Cycle 1
Fig. 4.13 Bus master-arbiter handshake protocol
4.5
Bus Master Handshake
145

Table 4.5 explains a hardware-coded bus arbitration mechanism between two bus masters.
When there are no requests to the arbiter, no Ack is generated to either bus master. However,
if two requests are issued at the same time, the acknowledge is issued to bus master 1
according to this table since bus master 1 is assumed to have higher priority than bus master
2 as shown in the last row.
The Table 4.5 is implemented as a state machine in Fig. 4.14. In this ﬁgure, the shorthand
representation of Req = (Req1 Req2) corresponds to the bus master request inputs 1 and 2.
Similarly, Ack = (Ack1 Ack2) corresponds to the acknowledge signals generated by the
arbiter for bus masters 1 and 2, respectively.
The arbiter is normally in the IDLE state when there are no pending requests. If there are
simultaneous requests from bus masters 1 and 2, the arbiter moves from the IDLE state to the
ACK1 state, generates Ack1 = 1 for bus master 1, and ignores the request from bus master 2
by Ack2 = 0 according to Table 4.5. The inputs for this state-to-state transition are shown by
Table 4.5 Bus arbitration table for two bus masters
Req1
Req2
Ack1
Ack2
0
0
0
0
0
1
0
1
1
0
1
0
1
1
1
0
From IDLE State
IDLE
Req = (00)
Ack = (00)
ACK1
ACK2
Req = (1x)
Req = (00)
Req = (01)
Req = (1x)
Req = (x1)
Req = (01)
Req = (10)
Ack = (10)
Ack = (01)
Ack = (Ack1 Ack2)
Req = (Req1 Req2)
Req = (00)
Fig. 4.14 Bus arbiter with two bus masters
146
4
System Bus

Req = (1 x), where Req1 = 1 and Req2 = x (don’t care). When bus master 1 terminates the
data transfer by issuing Req1 = 0, the arbiter either stays in the ACK1 state if there is another
pending request from bus master 1 or moves back to the IDLE state if there are no requests.
However, if the arbiter receives Req1 = 0 and Req2 = 1 while in the ACK1 state, it
transitions to the ACK2 state, and issues Ack2 = 1 to bus master 2.
In a similar fashion, the transition from the IDLE state to the ACK2 state requires Req2 = 1
and Req1 = 0. Once in the ACK2 state, the arbiter grants the usage of the bus to bus master
2 by issuing Ack2 = 1 and Ack1 = 0. When bus master 2 ﬁnishes the transfer by issuing
Req2 = 0, the arbiter either goes back to the IDLE state or transitions to the ACK1 state if
Req1 = 1. In case the higher priority bus master, bus master 1, requests the ownership of the
bus by Req1 = 1 while the lower priority bus master is in the middle of a transfer, the arbiter
stays in the ACK2 state as long as Req2 = 1 from bus master 2, ensuring the data transfer is
complete.
Example 4.4: Design a hardware-coded arbiter with three bus masters where bus master 1
has the highest priority followed by bus masters 2 and 3.
According to this deﬁnition, the bus master priorities can be tabulated in Table 4.6.
This table generates no acknowledge signal if there are no requests from any of the bus
masters (the top row). If only bus master 3 requests the bus, Ack3 = 1 is generated for bus
master 3 (the second row from the top). If there are two pending requests from bus masters 2
and 3, Ack2 = 1 is issued for bus master 2 because it has higher priority than bus master 3
(fourth row from the top). If all three bus masters request the ownership of the bus, the
arbiter grants the bus to bus master 1 by Ack1 = 1 because it has the highest priority with
respect to the remaining bus masters (the last row).
The implementation of this priority table is shown in Fig. 4.15 as a state machine. The
naming convention in representing request and acknowledge signals in Fig. 4.15 is the same as
in Fig. 4.14. Therefore, Req = (Req1 Req2 Req3) corresponds to bus master requests 1, 2 and 3,
and Ack = (Ack1 Ack2 Ack3) corresponds to the arbiter acknowledge signals for bus masters
1, 2 and 3, respectively. Normally, the arbiter is in the IDLE state when there are no requests. If
there are three simultaneous requests from bus masters 1, 2 and 3, the arbiter transitions to the
Table 4.6 Bus arbitration table for three bus masters
Req1
Req2
Req3
Ack1
Ack2
Ack3
0
0
0
0
0
0
0
0
1
0
0
1
0
1
0
0
1
0
0
1
1
0
1
0
1
0
0
1
0
0
1
0
1
1
0
0
1
1
0
1
0
0
1
1
1
1
0
0
From IDLE State
4.6
Arbiter
147

ACK1 state where it generates Ack1 = 1 since bus master 1 has the highest priority. When bus
master 1 ﬁnishes the data transfer, the arbiter can either stay in the ACK1 state or transition to
the ACK2 state or transition the ACK3 state depending on the requests from all three bus
masters. If there are no pending requests, the arbiter goes back to the IDLE state.
The arbiter does not issue acknowledge signals to higher priority bus masters until an
ongoing data transfer of a lower priority bus master is complete. For example, in the ACK3
state the requests from bus masters 1 and 2 are ignored as long as bus master 3 keeps its
request high to continue transferring data.
4.7
Bus Master Handover
The bus may be handed over to a different bus master if the current bus master lowers its
request.
Figure 4.16 describes how this bus ownership takes place in a unidirectional bus. In this
timing diagram, the current bus master, bus master 1, starts a new transfer by generating a Start
signal a cycle after it receives Ack1 = 1 from the arbiter. The write transfer continues until the
eighth cycle when the bus master delivers its last address, A4. In cycle nine, the bus master
delivers its last data, WA4, lowers its request, and changes its status to Idle, thus terminating the
data transfer. At the positive edge of the tenth cycle, the arbiter detects Req1 = 0 and Req2 = 1,
IDLE
Req = (000)
Ack = (000)
ACK1
ACK2
ACK3
Req = (1xx)
Req = (000)
Req = (01x)
Req = (001)
Req = (1xx)
Req = (x1x)
Req = (xx1)
Req = (001)
Req = (01x)
Req = (001)
Req = (10x)
Req = (010)
Req = (1x0)
Ack = (100)
Ack = (010)
Ack = (001)
Ack = (Ack1 Ack2 Ack3)
Req = (Req1 Req2 Req3)
Req = (000)
req = (000)
Fig. 4.15 Bus arbiter with three bus masters
148
4
System Bus

and switches the bus ownership by issuing Ack1 = 0 and Ack2 = 1. The new master,
bus master 2, starts a new transfer in the eleventh cycle and generates its ﬁrst address, B1.
The write transfer continues until the fourteenth cycle when bus master 2 delivers its last data,
WB2.
4.8
Serial Buses
Peripheral devices and external buffer memories that operate at low frequencies communi-
cate with the processor using a serial bus.
There are currently two popular serial buses used in low-speed communication. The Serial
Peripheral Interface (SPI) was introduced in 1979 by Motorola as an external microprocessor
bus for the well-known Motorola 68000 microprocessor. The SPI bus normally requires four
wires; however, wire count increments by one every time a peripheral device is added to the
system. The second bus, Inter-Integrated Circuit (I2C), was developed by Philips in 1982 to
connect Philips CPUs to peripheral chips in a TV set. This bus requires only two wires, but it
is considerably slower compared to the SPI bus.
Serial Peripheral Interface (SPI)
SPI is designed as a very straightforward serial bus. Four signals establish all the serial
communication between a CPU and a peripheral device. The SPI clock signal, SCK, is
clock
Req2
Status[1:0]
START
Ready
Ack2
Ack1
Req1
Address[31:0]
A1
A2
A3
B2
WData[31:0]
WA1
WA2
WB1
WB2
WA3
B1
A4
IDLE
WA4
CONT
START
CONT
IDLE
Cycle1
Cycle2
Cycle3
Cycle4
Cycle5
Cycle6
Cycle7
Cycle8
Cycle9 Cycle10 Cycle11 Cycle12 Cycle13 Cycle14
A4
B2
Fig. 4.16 Bus master handover protocol
4.7
Bus Master Handover
149

distributed to all the slaves in a system, and forces each peripheral to be synchronous with a
single master. The Slave Select signal ðSSÞ is an active-low signal, and is used to enable a
particular slave prior to data transfer. The Serial-Data-Out (SDO) or Master-Out-Slave-In
(MOSI) port is what the master uses to send serial data to a slave. The Serial-Data-In (SDI) or
Master-In-Slave-Out (MISO) port is what the master uses to read serial data from a slave.
Figure 4.17 shows the serial bus conﬁguration between the bus master and a single slave.
All SPI signals with the exception of SDI must be initiated by the bus master.
When the bus master is connected to a multitude of slaves, it needs to generate an
active-low Slave Select signal for each slave as shown in Fig. 4.18.
SCK
SDI
SDO
SS
SPI Master
SCK
SDI
SDO
SS
SPI Slave
Fig. 4.17 SPI bus between a master and a single slave
SCK
SDO
SDI
SS1
SPI Master
SCK
SDI
SDO
SS
SPI Slave3
SS2
SS3
SS
SPI Slave2
SS
SPI Slave1
SCK
SDI
SDO
SCK
SDI
SDO
Fig. 4.18 SPI bus between a master and three slaves
150
4
System Bus

SPI is considered a single-master serial communication protocol. This means that only one
master is assigned to initiate and carry out all serial communications with slaves. When the SPI
master wishes to send or request data from a slave, ﬁrst it selects a particular slave by lowering
the corresponding SS signal to logic 0, and then it produces a clock signal for the slave as
shown in Fig. 4.19. Once the select and the clock signals are established, the master sends out
serial data to the selected slave from its SDO port at the negative edge of SCK, and simul-
taneously samples slave data at its SDI port at the positive edge of SCK. According to the SPI
protocol, the slave is capable of sending and receiving data except it cannot generate SCK.
In the following example in Fig. 4.19, the master sends out serial data, DataM1 (most
signiﬁcant bit) to DataM4 (least signiﬁcant bit), from its SDO port at the negative edge of
SCK, and samples slave data, DataS1 (most signiﬁcant bit) to DataS4 (least signiﬁcant bit),
at its SDI port at the positive edge of SCK. The slave, on the other hand, can also dispatch
serial data packets, DataS1 (most signiﬁcant bit) to DataS4 (least signiﬁcant bit), from its
SDO port at the negative edge of SCK, and sample the master data, DataM1 (most sig-
niﬁcant bit) to DataM4 (least signiﬁcant bit), at its SDI port at the positive edge of SCK.
SCK is initially at logic 0
Data release at the negative edge of SCK
Data fetch at the positive edge of SCK
SCK
SDI
SDO
SS
Master samples data at SDI port
DataS1
DataS2
DataS3
DataS4
DataM1
DataM2
DataM3
DataM4
Slave dispatches data from SDO port
Master dispatches data from SDO port
Slave samples data at SDI port
Fig. 4.19 SPI bus protocol between a master and a single slave
4.8
Serial Buses
151

There are four communication modes available for the SPI bus protocol. Each protocol is
categorized according to the initial SCK level (the logic level at which SCK resides at steady
state) and the data generation edge of the SCK. Each communication mode is shown in
Fig. 4.20.
MODE 0 communication protocol assumes that the steady state level for SCK is at logic 0.
Each data bit is generated at the negative edge of SCK by the master (or the slave), and
is sampled at the positive edge. A good example of the MODE 0 protocol is shown in
Fig. 4.19.
MODE 1 still assumes the steady state level of SCK to be at logic 0, but the data
generation takes place at the positive edge of SCK. Both the master and the slave read data at
the negative edge in this mode.
MODE 2 switches the steady state level of SCK to logic 1. Data is released at the positive
edge of SCK and is sampled at the negative edge as shown in Fig. 4.20.
MODE 3 also accepts the steady state level of SCK at logic 1. However, data is released at
the negative edge of SCK and is sampled at the positive edge.
A master-slave pair must use the same mode during a data exchange. If multiple slaves are
used, and each slave uses a different communication mode, the master has to reconﬁgure
itself each time it communicates with a different slave.
SPI bus has neither an acknowledgement mechanism to conﬁrm receipt of data nor it
offers any other data-ﬂow control. In reality, an SPI bus master has no knowledge if a
physical slave exists on the other side of the bus, or the data it sends is properly received by
the slave. Most SPI implementations pack eight bits of data in a clock burst. However, many
variants of SPI today use 16 or even 32 clock cycles to send more data bits in a burst in order
to gain speed.
152
4
System Bus

MODE 0
SCK is initially at logic 0
Data release at the negative  edge of SCK
SCK
DATA
MODE 1
SCK is initially at logic 0
Data release at the positive  edge of SCK
SCK
DATA
MODE 2
SCK is initially at logic 1
Data release at the positive  edge of SCK
MODE 3
SCK is initially at logic 1
Data release at the negative  edge of SCK
SCK
DATA
SCK
DATA
Data 1
Data 2
Data 1
Data 2
Data 3
Data 1
Data 2
Data 1
Data 2
Data 3
Fig. 4.20 SPI bus protocol modes
4.8
Serial Buses
153

Inter Integrated Circuit (I2C)
Inter Integrated Circuit (I2C) is a multi-master bus protocol that transmits and receives data
between bus masters and slaves using only two signal lines, Serial Clock (SCL) and Serial
Data (SDA).
Slave selection with slave select signals, address decoders or arbitrations is not necessary
for this particular bus protocol. Any number of slaves and masters can be employed in an I2C
bus using only two lines.
The data rate is commonly at 100 Kbps which is the standard mode. However, the bus can
operate as fast as 400 Kbps or even at 3.4 Mbps at high speed mode.
Physically, the I2C bus consists of the two active wires, SDA and SCL, between a master
and a slave device as shown in Fig. 4.21. The clock generation and data-ﬂow are both
bidirectional. This protocol assumes the device initiating the data transfer to be the bus
master; all the other devices on the I2C bus are regarded as bus slaves.
In a typical I2C bus, both the bus master and the slave have two input ports, SCL In and
SDA In, and two output ports, SCL Out and SDA Out, as shown in Fig. 4.21. When a master
issues SCL Out = 1 (or SDA Out = 1), the corresponding n-channel MOSFET turns on, and
pulls the SCL line (or SDA line) to ground. When the master issues SCL Out = 0 (or SDA
Out = 0), it causes the corresponding n-channel transistor to turn off, resulting SCL (or SDA)
aﬂoat. However, neither SCL nor SDA is truly left ﬂoating in an undetermined voltage level.
The pull-up resistor, Rpu, immediately lifts the ﬂoating line to the power supply voltage
level, VDD. On the other side of the bus, the I2C slave detects the change at the SCL In (or
SDA In) port, and determines the current bus value.
SCL In
SCL Out
SCL
SDA In
SDA Out
SDA
Rpu
VDD
Rpu
VDD
SCL In
SCL Out
SDA In
SDA Out
I2C Slave
I2C Master
Fig. 4.21 I2C architecture
154
4
System Bus

Each slave on the I2C bus is deﬁned by an address ﬁeld of either seven bits or ten bits as
shown in Fig. 4.22. Each data packet following the address is eight bits long. There are only
four control signals that regulate the data ﬂow: Start, Stop, Write/Read and Acknowledge.
The seven-bit and ten-bit versions of read and write data transfers are shown in Fig. 4.22.
The top sequence in this ﬁgure explains how a bus master writes multiple bytes of data to a
slave that uses a seven-bit address. The master begins the sequence by generating a Start bit.
This acts as a “wake-up” call to all the slave devices and enables them to watch for the
incoming address. This step is followed by a seven-bit long slave address. The bus master
sends the most signiﬁcant address bit ﬁrst. The remaining address bits are released one bit at
a time until the least signiﬁcant bit. At this point, all slave devices compare the bus address
just sent out with their own addresses. If the address does not match, the slave simply
ignores the rest of the incoming bits on the SDA bus, and waits for the beginning of the next
bus transfer. If the addresses match, however, the addressed slave waits for the next bit that
indicates the type of the data transfer from the master. When the master sends out a Write bit,
the slave responds with an acknowledge signal, SAck, by pulling the SDA line to ground.
The master detects the acknowledge signal, and sends out the ﬁrst eight-bit long data packet.
The format for transmitting data bits is the same as the address: the most signiﬁcant bit of the
data packet is sent out ﬁrst followed by the intermediate bits and the least signiﬁcant bit. The
slave produces another acknowledgement when all eight data bits are successfully received.
The data delivery continues until the master completes sending all of its data packets. The
transfer ends when the master generates a Stop signal.
The second entry in Fig. 4.22 shows the write transfer to a bus slave whose address is ten
bits long. Following the Start bit, the bus master sends out a ﬁve-bit preamble, 11110,
indicating that it is about to send out a ten-bit slave address. Next, the master sends out the two
most signiﬁcant address bits followed by the Write bit. When the delivery of all these entries
is acknowledged by the slave(s) whose two most signiﬁcant address bits match the ones sent
by the master, the master sends out the remaining eight address bits. This is followed by
another slave acknowledgement, and the master transmitting all of its data bytes to the
designated slave. The data transfer completes when the bus master generates a Stop bit.
The third and the fourth entries in Fig. 4.22 show the seven-bit and ten-bit read sequences
initiated by the bus master. In each sequence, after receiving the Start bit and the address
from the master, the designated slave starts sending out data packets to the master. After
successfully receiving the ﬁrst data byte, the master responds to the slave with an
acknowledge signal, MAck, after which the slave transmits the next byte. The transfer
continues until the slave delivers all of its data bytes to the master. However, right before
issuing a Stop bit, the master generates a no-acknowledgement bit, MNack, signaling the end
of the transfer as shown in Fig. 4.22.
4.8
Serial Buses
155

The Start and Stop signals are generated by the combination of SCL and SDA values as
shown in Fig. 4.23. According to this ﬁgure, a Start signal is produced when the SDA line is
pulled to ground by the bus master while SCL = 1. Similarly, a Stop signal is created when
the bus master releases the SDA line while SCL = 1.
Figure 4.24 shows when data is permitted to change, and when it needs to be steady. The
I2C protocol only allows data changes when SCL is at logic 0. If the data on SDA changes
while SCL is at logic 1, this may be interpreted as a Start or a Stop condition depending on
the data transition. Therefore, the data on SDA is not allowed to change as long as SCL = 1.
Master = Write   Addr Mode = 7 bits
START
Slave Address
Write
SAck
Data1
SAck
STOP
1 bit
7 bits
1 bit
1 bit
8 bits
1 bit
1 bit
8 bits
1 bit
Master = Write   Addr Mode = 10 bits
START
Slave Address
Write
SAck
1 bit
msb (2 bits)
1 bit
1 bit
Slave Address
SAck
1 bit
11110
5 bits
lsb (8 bits)
Data1
8 bits
1 bit
DataN
SAck
STOP
1 bit
8 bits
1 bit
SAck
DataN
SAck
Master response
Slave response
Master response
Slave response
Master = Read   Addr Mode = 7 bits
START
Slave Address
Read
SAck
Data1
MNack
STOP
1 bit
7 bits
1 bit
1 bit
8 bits
1 bit
1 bit
8 bits
1 bit
MAck
DataN
Master response
Slave response
Master = Read   Addr Mode = 10 bits
START
Slave Address
Read
SAck
1 bit
msb (2 bits)
1 bit
1 bit
Slave Address
SAck
1 bit
11110
5 bits
lsb (8 bits)
Data1
8 bits
1 bit
DataN
8 bits
MAck
Master response
Slave response
MNack
STOP
1 bit
1 bit
Fig. 4.22 I2C modes of operation
Start condition
SCL
SDA
Stop condition
Fig. 4.23 I2C data stream start and stop conditions
156
4
System Bus

Figure 4.25 explains the timing diagram in which the bus master writes two bytes of data
to a slave with a seven-bit address. According to this ﬁgure, the write process starts with
transitioning the value at the SDA to logic 0 while SCL = 1. Following the Start bit, the slave
address bits are delivered sequentially from the most signiﬁcant bit, SA[6], to the least
signiﬁcant bit, SA[0]. Each address bit is introduced to the SDA only when SCL is at logic 0
according to the I2C bus protocol shown in Fig. 4.24. The Write command and the subse-
quent slave acknowledgement are generated next. The data bits in Byte 0 and Byte 1 are also
delivered to the SDA starting from the most signiﬁcant data bit, D[7]. The write sequence
ﬁnishes with the SDA transitioning to logic 1 while SCL = 1.
Figure 4.26 shows the timing diagram of reading two bytes of data from a slave. Fol-
lowing the Start bit and the slave address, the master issues the Read command by SDA = 1.
Subsequently, bytes of data are transferred from the slave to the master with the master
acknowledging the delivery of each data byte. The transfer ends with the master not
acknowledging the last byte of data, MNack, and generating the Stop bit.
Data change is 
allowed
SCL
SDA
Data change is 
NOT allowed
(Data is assumed 
VALID)
Fig. 4.24 I2C data change conditions
Master = Write   Addr Mode = 7 bits
SCL
SDA
SA[6]
SA[5]
SA[0]
D[6]
D[0]
D[7]
D[6]
D[0]
D[7]
Write
SAck
SAck
SAck
Start
Stop
Slave Address
Byte 0
Byte 1
Fig. 4.25 I2C write timing diagram
4.8
Serial Buses
157

Here comes the reason why the I2C bus protocol excels in maintaining ﬂawless com-
munication between any number of masters and slaves using only two physical wires. For
example, what happens if two or more devices are simultaneously trying to write data on the
SDA? At the electrical level, there is actually no contention between multiple devices trying
to simultaneously enter a logic level on the bus. If a particular device tries to write logic 0 to
the bus while the other issues logic 1, then the physical bus structure with pull-up resistors in
Fig. 4.21 ensures that there will be no electrical short or power drainage; the bus actually
transitions to logic 0. In other words, in any conﬂict, logic 0 always wins!
This physical structure of the I2C bus also allows bus masters to be able to read values
from the bus or write values onto the bus freely without any danger of collision. In case of a
conﬂict between two masters (suppose one is trying to write logic 0 and the other logic 1),
the master that tries to write logic 0 gains the use of the bus without even being aware of the
conﬂict. Only the master that tries to write logic 1 will know that it has lost the bus access
because it reads logic 0 from the bus while trying to write logic 1. In most cases, this device
will just delay its access to the bus, and try it later.
Moreover, this bus protocol also helps to deal with communication problems. Any device
present on the bus listens to the bus activity, particularly the presence of Start and Stop bits.
Potential bus masters on the I2C bus detecting a Start signal will wait until they detect the
Stop signal before attempting to access the bus. Similarly, unaddressed slaves go back to
hibernation mode until the Stop bit is issued.
Similarly, the master-slave pair is aware of each other’s presence by the active-low
acknowledge bit after the delivery of each byte. If anything goes wrong, and the device
sending the data does not receive any acknowledgment, the device sending the data simply
issues a Stop bit to stop the data transfer and releases the bus.
An important element of the I2C communication is that the master device determines the
clock speed in order to synchronize with the slave. If there are situations where an I2C slave
device is not able to keep up with the master because the clock speed is too high, the master
Master = Read   Addr Mode = 7 bits
SCL
SDA
SA[6]
SA[5]
SA[0]
D[6]
D[0]
D[7]
D[6]
D[0]
D[7]
Read
SAck
MAck
MNack
Start
Stop
Slave Address
Byte 0
Byte 1
Fig. 4.26 I2C read timing diagram
158
4
System Bus

can lower the frequency by a mechanism referred to as “clock stretching”. According to this
mechanism, an I2C slave device is allowed to hold the SCL at logic 0 if it needs the bus
master to reduce the bus speed. The master is required to observe the SCL signal level at all
times and proceeds with the data transfer until the line is no longer pulled to logic 0 by the
slave.
All in all, both SPI and I2C offer good support for low-speed peripheral communication.
SPI is faster and better suited for single bus master applications, and I2C is slower but
better suited for multi-master applications. The two protocols offer the same level of
robustness and have been equally successful among vendors producing Flash memories,
Analog-to-Digital and Digital-to-Analog converters, real-time clocks, sensors, liquid crystal
display controllers etc.
4.8
Serial Buses
159

Review Questions
1. A CPU reads three bursts of data from a 32-bit wide byte-addressable memory in the
following manner:
• It reads four bytes with the starting address 0xF0,
• Immediately after the ﬁrst transaction, the CPU reads two half-words from the starting
address 0xF4,
• Immediately after the second transaction, it reads one word from the starting address
0xF8.
The contents of the memory are as follows:
0xCC
0xDD
0xEE
0xFF
0x88
0x99
0xAA
0xBB
0xF0
0xF4
0x44
0x55
0x66
0x77
0x00
0x11
0x22
0x33
0xF8
0xFC
31
0
The unidirectional bus protocol states that the data communication between a bus master
and a slave requires generating the address and control signals in the ﬁrst cycle, and the data in
the second cycle. The bus master always issues a Start signal to indicate the start of a data
transmission. After an initial address, the master changes its status to Cont to indicate the
continuation of the data transfer. The bus master issues Idle to indicate the end of the data
transfer or Busy to indicate its incapability to produce address and control signals (and data if
applicable). Any time the bus master is Busy, it repeats its address and control signals (and
data if applicable) from the previous clock cycle. Similarly, if a Ready signal is not generated
by the slave, the bus master also repeats its address and control signals (and data if applicable)
in the next clock cycle. At the end of a data transfer when the bus master ﬁnishes issuing new
addresses, it transitions to the Idle state even though there may be a residual data still in the
process of being read or written in the subsequent clock cycle(s).
Fill in the blanks of the following timing diagram to complete all three data read bursts in
the order speciﬁed above.
start
busy
busy
busy
busy
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
clock
status
burst
size
Addr
RData
Ready
160
4
System Bus

2. The following bidirectional bus maintains the communication between a CPU and a
memory.
Addr
WData
RData
EnAddr
EnWData
EnRData
SelAddr
SelWData
SelRData
32
32
32
Addr
Data
32
32
SelAddr
SelWData
SelRData
32
WE RE
CPU
Memory
A1
A2
A3
A4
A5
A6
A7
A8
Bus Controller
Bus
Ready
CPU 
I/F
Memory
I/F
The CPU has the Addr and the WData outputs to dispatch the address and the write-data,
respectively. It also uses the RData output to receive data from the memory.
The memory, on the other hand, has the Addr input to receive address from the CPU, and
a bidirectional Data port to receive and send data.
To validate the address and write-data, the EnAddr and EnWData signals are issued to the
bus controller, respectively. To validate read-data, the memory dispatches the Ready signal to
the controller. With all these inputs from the CPU and the memory, the controller generates
the WE and RE signals for the memory to write and read data, and the EnRData signal for the
CPU to validate the read data. The signals, SelAddr, SelWData and SelRData, are also
generated by the bus controller to manage the timely distribution of the address, write-data
and read-data using a single 32-bit wide bidirectional bus as shown in the ﬁgure above.
The write process to the memory requires a valid address with data as shown below:
clock
Addr
Data
Valid Addr
WE
RE
Data
data written
4.8
Serial Buses
161

The read process requires a cycle delay to produce valid data from the memory once an
address is issued. This is shown below:
clock
Addr
Data
Valid Addr
WE
RE
Data
data read
(a) Since the bus protocol delivers data following a valid address, construct a timing
diagram to write the data, W1 to A1, W2 to A2, W3 to A3 and W4 to A4. Without
any delay, perform a read sequence to fetch the data packets, R1, R2, R3 and R4,
from the memory addresses, A5, A6, A7 and A8, respectively. Plot a timing dia-
gram, including the 32-bit bus, Bus[31:0], and the control signals, WE, RE,
SelAddr, SelWData and SelRData, for the write and read sequences.
(b) Design the CPU and the memory interfaces with the bidirectional bus such that these
two data transfers are possible (note that these interfaces are not state machines).
3. A bus master writes four bytes of data to the following address locations of a 32-bit wide
byte-addressable memory (slave) organized in a Little Endian format:
Address
Data
-----------------------------------
0x0D
0x11
0x11
0x22
0x15
0x33
0x19
0x44
Following the write cycle, the same bus master reads data (words) from the following
slave addresses:
Address
Data
---------------------------------------
0x3C
0xAABBCCDD
0x40
0x55667788
162
4
System Bus

(a) Describe the contents of the memory after the writing and reading cycles shown
above become complete.
(b) If the bus master generates the ﬁrst address during the ﬁrst clock cycle and keeps
generating new addresses every time the slave responds with a Ready signal, what
will be the values of the address, control and data entries in the timing diagram
below? Assume that the bus master does not produce any Status signal comprised of
Start, Cont, Busy and Idle.
clock
address
WE
size
burst
WData
RData
ready
1
2
3
4
5
6
7
8
9
10
11
12
13
4. A bus master reads four data packets starting from the address, 0x00, and ending at the
address, 0x03, from an eight-bit wide memory. Immediately after this transaction, the bus
master writes 0x00, 0x11, 0x22 and 0x33 into the addresses 0x04, 0x05, 0x06 and 0x07
respectively. This memory contains the following data after this operation:
0xAA
0xBB
0xCC
0xDD
0x00
0x11
0x22
0x33
00
01
02
03
04
05
06
07
7
0
4.8
Serial Buses
163

Assuming the unidirectional bus protocol is the same as described in question 1, ﬁll in the
blanks of the timing diagram below to accommodate each read and write transfer.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
busy
busy
clock
Status
Write
Burst
Size
Address
WData
RData
Ready
5. A bus master is connected to four memory blocks acting as bus slaves in a bidirectional
bus where 32-bit address, write-data and read-data are sent or received on the same bus.
The I/O ports of the bus master and the slaves are shown below:
RData[31:0]
WData[31:0]
Addr[31:0]
EN
W/R
Ready
Bus Master
Addr/Data[31:0]
EN
WE
Ready
Bus Slave
EnAddr
The bus master has separate read and write data ports to receive and transmit data,
respectively. The Enable, and W/R ports enable the bus master to write data, i.e. EN = 1 and
W/R = 1. Similarly, EN = 1 and W/R = 0 enable the bus master to read. Since address and
data entries share the same bus, the bus master provides a third control signal, EnAddr, to
enable the address. The bus master determines if the slave is ready to receive of transmit data
through its Ready signal.
164
4
System Bus

The slave, in contrast, has only one port for receiving address or data. EN = 1 and WE = 1
writes data to the slave. If data needs to be read from the slave, then EN = 1 and WE = 0 are used.
Draw the architectural diagram of such a system. Make sure to use the most signiﬁcant
address bits, Addr[31:30], to select one of the slaves to read or write data.
6. A 16-bit digital system with a unidirectional data and address bus is given below.
Bus Arbiter
Memory 
Select
Reqm
Reqc
Reqd
Grantm
Grantc
Grantd
Addrd
Addrc
Addrm
WDatam
WDatac
MPU
Co-proc 1
Co-proc 2
RDatam
RDatac
3
3
DIn1
Addr1
DOut1
DIn2
Addr2
DOut2
DIn3
Addr3
DOut3
Memory 1
Memory 2
Memory 3
3
16
16
16
16
16
16
16
16
16
WE1, RE1
WE2, RE2
WE3, RE3
This system contains three bus masters, a Microprocessor Unit (MPU), Co-processor 1
and Co-processor 2. It also contains three slaves, Memory 1, Memory 2 and Memory 3.
A bus arbiter is responsible for prioritizing the ownership of the bus among the three bus
masters. The MPU has the highest and Co-processor 2 has the lowest priority to use the bus.
When the arbiter gives the ownership of the bus to a bus master, the bus master is free to
exchange data with a slave as long as it keeps its request signal at logic 1. When the bus
master lowers its request signal after ﬁnishing a data transfer, the arbiter also lowers its grant
to assign the bus to another bus master according to the priority list.
As long as a bus master owns the bus, it can send a 16-bit write-data (WData) to the
selected slave at a speciﬁc address (Addr). Similarly, the bus master can read data from the
selected slave using a 16-bit read-data (RData) bus.
4.8
Serial Buses
165

For the sake of simplicity, control signals on the schematic are not shown; however, each
memory has the Read Enable (RE) and Write Enable (WE) ports to control data storage.
(a) With the description above, draw the state diagram of the bus arbiter.
(b) While MPU and Co-processor 1 remain at idle, Co-processor 2 requests two data
transfers. The ﬁrst data transfer is from the addresses, 0xABC0 and 0xABC1, of
Memory 1 to the addresses, 0x0000 and 0x0001, of Memory 2, respectively. The second
one is from the address, 0x0002, of Memory 2 to the address, 0xABC2, of Memory 1.
The ﬁrst one is from the addresses 0xABC0 and 0xABC1 of Memory 1 to the addresses
0x0000 and 0x0001 of Memory 2, respectively. The second one is from the address 0x0002
of Memory 2 to the address 0xABC2 of Memory 1, respectively.
Note that Co-processor 2 and Memory 1 operate at a clock frequency twice as high as the
clock frequency used in Memory 2. Both memories have a read latency (access time) of one
clock cycle, i.e. data becomes available in the next clock cycle after issuing a valid address
with RE = 1. Write happens within the same clock cycle when the address is valid and WE = 1.
Including the request (reqd), grant (grantd) and address (Addrd) from Co-processor 2, and
the control signals (RE1, WE1, RE2, WE2) from each memory, create a timing diagram that
shows data transfers between Memory 1 and Memory 2. If you prefer, use the timing
diagram template below to make your entries.
AAAA
BBBB
0000
15
0
ABC0
ABC1
ABC2
0000
0000
CCCC
15
0
0000
0001
0002
Memory 1
Memory 2
WE1
RE1
WE2
RE2
clk1
clk2
Din1
DOut1
Addr1
Din2
DOut2
Addr2
166
4
System Bus

clk1
reqd
grantd
Addrd
RE1
DOut1
WE2
RE2
DOut2
WE1
clk2
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
7. The waveforms below describe serial transmission of data using two known bus proto-
cols, I2C and SPI.
(a) A bus master writes data to an I2C-compliant slave according to the timing diagram
below. Assuming that the bus master uses the negative edge of SCLK to produce data
on the SDA bus, determine the slave address and the data packets in binary format.
Start
Stop
Continue the waveform
SCLK
SDA
SCLK
SDA
4.8
Serial Buses
167

(b) Now, the bus master transmits the same data packets on the SPI bus. Using the timing
diagram below, show the value of each data bit at the SDI terminal. Note that the bus
master uses Mode0 convention and produces data at the negative edge of SCK.
Projects
1. Implement the unidirectional bus with two bus masters and three slaves shown in Fig. 4.1
using Verilog. Make sure both of the bus masters are able to produce status signals,
START, CONT, BUSY and IDLE to transfer data packets from one byte to two words
(64 bits) on a 32-bit wide bus. Similarly, ensure that all the slaves are able to generate
Ready signals compliant to the parallel bus protocol given in this chapter. Design the bus
arbiter shown in Fig. 4.14. Verify each individual block, i.e. the bus master, the slave, the
arbiter and the overall system functionality.
2. Implement the bidirectional bus with two bus masters and three slaves as shown in
Fig. 4.2 using Verilog. Make sure that the bus masters and slaves are fully compliant to
the parallel bus protocol given in this chapter. Design the bus arbiter shown in Fig. 4.14.
Again, verify each individual block, i.e. the bus master, the slave, the arbiter and the
entire bus system.
3. Implement the SPI bus with one bus master and three slaves as shown in Fig. 4.18 using
Verilog. Verify the system functionality with timing diagrams.
4. Implement the I2C bus in seven-bit addressing mode in Fig. 4.22 using Verilog. Verify
the system functionality with timing diagrams.
SCK
SS
SDI
168
4
System Bus

5
Memory Circuits and Systems
Basic serial and parallel bus structures and different forms of data transfer between a bus
master and a slave were explained in Chapter 4. Regardless of the bus architecture, the bus
master is deﬁned as the logic block that initiates the data transfer, and the slave is deﬁned as
the device that exchanges data with the master on demand. Both devices, however, may
include a buffer memory. The master may have an internal memory that stores user programs
or data, and the slave may have a large capacity system memory or a small buffer memory.
Depending on the read and write speed, capacity and permanence of data, system
memories and peripheral buffers can be categorized into three different forms. If fast read and
write times are desired, Static Random Access Memory (SRAM) is used despite its relatively
large cell size compared to other types of memory. SRAM is commonly used to store small
temporary data, and it is typically connected to a high speed parallel bus in a system. If large
amounts of storage are required, but slow read and write speed can be tolerated, then
Dynamic Random Access Memory (DRAM) should be the main memory type to be used.
DRAMs are still connected to the high speed parallel bus, but typically operate with large
bursts of data. A typical DRAM cell is much smaller than an SRAM cell with signiﬁcantly
lower power consumption. The main drawbacks of DRAM are high data read and write
latencies, the complexity of memory control and management of data.
The permanence of data yet calls for a third memory type whose cell type consists of a
double-gated Metal-Oxide-Semiconductor (MOS) transistor. Data is permanently stored in
the ﬂoating gate of the device until it is overwritten. Electrically-Erasable-Programmable-
Read-Only-Memory (E2PROM) or Flash memory ﬁt into this type of device category. The
advantage of this memory type is that it keeps the stored data even after the system power is
turned off. However, this memory is the slowest compared to all other memory types, and it
is subject to a limited number of read and write cycles. Its optimal usage is, therefore, to
store permanent data for Built-In-Operating-Systems (BIOS), especially in hand-held
devices where power consumption is critical. A typical computing system can contain one or
all three types of memories depending on the usage and application software.
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9_5
169

The basic functionality of SDRAM, E2PROM and Flash memory blocks in this chapter is
inspired from Toshiba memory datasheets [1–6]. The more recent serial Flash memory with
SPI interface in this chapter is based on an Atmel Flash memory datasheet [7]. In each case,
the functionality of the memory block has been substantially simpliﬁed (and modiﬁed)
compared to the original datasheet in order to increase reader’s comprehension of the subject
matter. The purpose here is to show how each memory type operates in a system, covering
only the basic modes of operation to train the reader rather than going into the details of the
actual datasheets. The address, data and control timing constraints for each memory have
also been simpliﬁed compared to the datasheets. This allows us to design the bus interface
for each memory type with ease. For the sake of simplicity, we avoided duplicating the port
names, exact timing requirements and functionality details that can be found in the actual
datasheets. After reading this chapter, interested readers are encouraged to study the refer-
enced datasheets prior to carrying out their design tasks.
5.1
Static Random Access Memory
Static Random Access Memory (SRAM) is one of the most fundamental memory blocks in
digital design. Among all different types of memory, SRAM ranks the fastest; however, its
large memory cell size limits its usage for a variety of applications.
A typical SRAM architecture shown in Fig. 5.1 is composed of four different blocks: the
SRAM core, the address decoder, the sense ampliﬁer and the internal SRAM controller. The
memory core retains all immediate data. The sense ampliﬁer ampliﬁes the cell voltage to full
logic levels during read. The address decoder generates all 2N Word Lines (WL) from an
N-bit wide address. Finally, the controller generates self-timed pulses required during a read
or write cycle.
Each SRAM cell is composed of two back-to-back inverters like the ones used in a latch,
and two N-channel Metal Oxide Semiconductor (NMOS) pass-gate transistors to isolate the
existing data in the cell or to allow new data into the cell as shown in Fig. 5.2. When data
needs to be written to a cell, WL = 1 turns on both NMOS transistors, allowing the true and
complementary bits of data to be simultaneously written from the Bit and Bitbar inputs.
Suppose the node A is initially at logic 0, and the node B at logic 1 but WL = 0. The logic
level at WL turns off both NMOS transistors, and the latch becomes completely isolated from
its surroundings. As a result, logic 0 level is contained in the cell. But, if WL = 1, Bit = 1 and
Bitbar = 0, this time the logic level at WL turn on both NMOS transistors, and the values at
the Bit and the Bitbar nodes overwrite the existing logic levels at the nodes A and B, thereby
changing the stored bit in the cell from logic 0 to logic 1.
Similarly, if the data needs to be read from the cell, both NMOS transistors are turned on
by WL = 1, and the small differential potential developed between the Bit and the Bitbar
outputs are ampliﬁed by a sense ampliﬁer to reach full logic levels at the SRAM output.
170
5
Memory Circuits and Systems

The data write sequence starts with EN (Enable) = 1 and Write Enable (WE) = 1. This
combination precharges the Bit and the Bitbar nodes in the SRAM core to a preset voltage
and prepares the memory for a write. When the precharge cycle is complete, the controller
enables the address decoder by EnWL = 1 as shown in Fig. 5.1. The decoder activates a
single WL input out of 256 WLs according to the value provided at AddrIn[7:0]. Within the
Address Decoder
Internal SRAM
Controller
AddrIn[7:0]
EN
WE
EnWL
WritePulse
WL [255:0]
8
0
31
255
0
DOut[31:0]
DIn[31:0]
SRAM Core
256
ReadPulse
Precharge
Sense Amplifier
32
32
Fig. 5.1 A typical SRAM architecture with eight-bit address and 32-bit data
WL
Bit
Bitbar
A
B
Fig. 5.2 SRAM memory cell
5.1
Static Random Access Memory
171

same time period, the controller also produces WritePulse = 1, which allows the valid data at
DIn[31:0] to be written into the speciﬁed address.
Reading data from the SRAM core is performed by EN = 1 and WE = 0. Similar to the
write operation, the controller ﬁrst precharges the SRAM core prior to reading data, and then
turns on the address decoder. According to the address value at the AddrIn port, the WL
input to a speciﬁc row is activated, and the data is read from each cell to the corresponding
Bit and Bitbar nodes at this row. The sense ampliﬁer ampliﬁes the cell voltage to full logic
levels and delivers the data to the DOut port.
The SRAM I/O timing can be synchronized with clock as shown in Figs. 5.3 and 5.4. In
Fig. 5.3, when EN and WE inputs are raised to logic 1, SRAM goes into the write mode, and
the valid data is written to a speciﬁed address at the next positive clock edge. In Fig. 5.4,
when EN = 1 and WE = 0, SRAM is enabled and operates in the read mode. The core
delivers the valid data sometime after the next positive edge of the clock.
clock
WE
EN
Addr[7:0]
Valid Address
DOut[31:0]
Valid Data
Fig. 5.4 SRAM I/O timing for read
clock
WE
EN
Addr[7:0]
Valid Address
DIn[31:0]
Valid Data
Fig. 5.3 SRAM I/O timing for write
172
5
Memory Circuits and Systems

One of the important tasks to integrate an SRAM module to an existing system is to
design its bus interface. Figure 5.5 shows the block diagram of such an implementation. The
bus interface basically translates all bus control signals to SRAM control signals (and vice
versa), but it seldom makes any modiﬁcations on address or data. In the unidirectional bus
protocol described in Chapter 4, SRAM is considered to be a bus slave that exchanges data
with the bus master on the basis of a Ready signal. As also mentioned in Chapter 4, a bus
master has four control signals to indicate the data transfer. The Status signal indicates if the
bus master is sending the ﬁrst data packet (START) or is in the process of sending remaining
data packets (CONT). The bus master may also send IDLE or BUSY signals to indicate if it
has ﬁnished the current data transfer or busy with an internal task, respectively. The Write
signal speciﬁes if the bus master intends to write data to a slave or read from a slave. The
AddrIn[7:0]
Bus Interface
SRAM
Status
Write
Ready
WE
DIn[31:0]
RData[31:0]
EN
clock
D
Q
W
R
Addr[31:0]
BIWEn
32
DOut[31:0]
WData[31:0]
32
8
32
Addr[31:28]
4
Burst
BIREn
8
Addr[7:0]
Fig. 5.5 SRAM bus interface block diagram
5.1
Static Random Access Memory
173

Burst signal designates the number of data packets in the transaction, and the Size signal
deﬁnes the width of the data.
The timing diagram in Fig. 5.6 shows how to write four data packets, W1 to W4, to four
consecutive SRAM addresses, A1 to A4, as an example to build the bus interface in Fig. 5.5.
To initiate a write sequence, the bus master issues a valid address, Status = START and
Write = 1 in the ﬁrst clock cycle of this timing diagram, and enables the bus interface for a
clock
Write
Status
Addr[7:0]
WData[31:0]
RData[31:0]
AddrIn[7:0]
DIn[31:0]
DOut[31:0]
WE
Ready
EN
START
CONT
CONT
CONT
A1
A2
A3
W3
W2
W1
W4
A2
A3
A1
W3
W2
W1
W4
IDLE
A4
Idle
Standby
Write
Write
Write
Idle
Addr[31:28]
SRAM Space
BIWEn
A4
Last 
Write
4
Burst
A4
W4
BM 
writes
BM 
writes
BM 
writes
BM 
writes
Fig. 5.6 SRAM bus interface timing diagram for write
174
5
Memory Circuits and Systems

write by producing an active-high Bus Interface Write Enable (BIWEn) signal. Upon
receiving the BIWEn = 1, the bus interface produces Ready = 1 in the next cycle, and prompts
the bus master to change the address and control signals in the third cycle. As the bus master
changes its address from A1 to A2, it also sends its ﬁrst data packet, W1, according to the
unidirectional bus protocol explained in Chapter 4. However, in order to write data into an
SRAM address, a valid data must be available within the same cycle as the valid address as
shown in Fig. 5.3. Therefore, a set of eight ﬂip-ﬂops are added to the write path prior to the
AddrIn port in Fig. 5.5 so that the address, A1, is delayed for one clock cycle, and aligned
with the current data, W1. The bus interface also produces EN = WE = 1 in the third cycle so
that W1 is written to A1 at the positive edge of the fourth clock cycle. The next write is
accomplished in the same way: the SRAM address is delayed for one cycle in order to write
W2 into A2 at the positive edge of the ﬁfth cycle. In the sixth cycle, the bus interface keeps
EN = WE = 1 to be able to write W3 to A3, but lowers the Ready signal to logic 0 so that the
bus master stops incrementing the slave address and suspends the controls in the next cycle. In
the seventh and ﬁnal write cycle, the bus interface lowers both EN and WE to logic 0 but
allows the last data, W4, to be written to A4 at the positive edge of the clock.
The bus interface state diagram for write in Fig. 5.7 is developed as a result of the timing
diagram in Fig. 5.6. The ﬁrst state, Idle state, is the result of the bus interface waiting to
receive BIWEn = 1 from the bus master, which corresponds to the ﬁrst clock cycle of the
timing diagram in Fig. 5.6. The next state that follows the Idle state is the Standby state
where the bus interface generates Ready = 1. This state is one clock cycle long and rep-
resents the second clock cycle in the timing diagram. The Write state is the state during
which the actual write sequence takes place: EN and WE are kept at logic 1 as long as the
number of write addresses issued by the bus master is less than Burst length. This state
corresponds to the third, fourth and ﬁfth clock periods in the timing diagram. When the
number of write addresses reaches the value of the Burst length, the bus interface goes to the
Last Write stage and Ready signal becomes logic 0. The bus master writes the ﬁnal data
packet to the last SRAM address at the positive edge of the seventh clock cycle before it
enters the Idle state.
In order to initiate a read sequence, the bus master issues a valid SRAM address, Status =
START and Write = 0 signals in the ﬁrst clock cycle of Fig. 5.8. This combination produces an
active-high Bus Interface Read Enable, BIREn = 1, which is interpreted as the bus master
intendingtoreaddatafrom anSRAMaddress.Consequently,thebusinterfacegeneratesEN=1,
WE = 0, Ready = 1 in the second cycle. This fetches the ﬁrst data, R1, from the SRAM address,
B1, in the third cycle. The read transactions in the fourth and ﬁfth cycles are identical to the third,
and the bus master reads R2 and R3 from the addresses, B2 and B3, respectively. In the sixth
cycle, the bus interface retains Ready = 1 so that the bus master can still read the last data, R4,
from the address, B4.
5.1
Static Random Access Memory
175

As in the write case, the read bus interface in Fig. 5.9 is also a direct consequence of the
timing diagram in Fig. 5.8. The Idle state corresponds to the ﬁrst clock cycle of the timing
diagram in Fig. 5.8. As soon as BIREn = 1 is generated, the bus interface transitions to the
Standby state where it produces EN = 1, WE = 0 and Ready = 1. The interface enters the
Read state in the third cycle and produces the same outputs as before so that the bus master
can read its ﬁrst data, R1, and sends a new address in the next cycle. The interface stays in
the Read state until the number of read addresses issued by the bus master is less than the
Burst length. The Read state covers from the third to the ﬁfth cycle in the timing diagram in
Fig. 5.8. After the number of read addresses reaches the Burst length, the bus interface
Idle
Standby
Ready = 0
EN = 0
WE = 0
Ready = 1
EN = 0
WE = 0
Write
Ready = 1
EN = 1
WE = 1
BIWEn = 1
Write = 1
Status = CONT or BUSY
Burst < Burst length
BIWEn = 0
Last
Write
Ready = 0
EN = 1
WE = 1
(BM dispatches
the last data)
Write = 1
Status = CONT
Burst = Burst length
Status = BUSY
Status = IDLE
Fig. 5.7 SRAM bus interface for write
176
5
Memory Circuits and Systems

transitions to the Last Read state in cycle six where it continues to generate Ready = 1. This
is done so that the bus master is able to read the last data as mentioned earlier. The interface
unconditionally goes back to the Idle state in the following cycle.
clock
Write
Status
Addr[7:0]
WData[31:0]
RData[31:0]
AddrIn[7:0]
DIn[31:0]
DOut[31:0]
WE
Ready
EN
START
CONT
CONT
B2
R2
R1
R2
R1
R4
B1
B2
R4
Idle
Read
Read
Addr[31:28]
SRAM Space
BIREn
B3
B3
Read
CONT
R3
R3
Last 
Read
B4
4
Burst
B4
IDLE
B4
B1
BM 
reads
BM 
reads
BM 
reads
BM 
reads
Idle
Standby
Fig. 5.8 SRAM bus interface timing diagram for read
5.1
Static Random Access Memory
177

Increasing SRAM capacity necessitates employing extra address bits. In the example shown
in Fig. 5.10, the SRAM capacity is increased from 32x16 bits to 32x64 bits by appending two
extra address bits, Addr[5:4], which serves to access one of the four SRAM blocks. In this
ﬁgure, even though Addr[3:0] points to the same address location for all four 32x16 SRAM
blocks, Addr[5:4] in conjunction with EN enables only one of the four blocks. Furthermore,
the data read from the selected block is routed through the 4-1 MUX using Addr[5:4] inputs.
Addr[5:4] = 00 selects the contents of DOut0 port and routes the data through port 0 of the 4-1
MUX to Out[31:0]. Similarly, Addr[5:4] = 01, 10 and 11 select ports 1, 2 and 3 of the 4-1
MUX, and route data from DOut1, DOut2 and DOut3 ports to Out[31:0], respectively.
Idle
Ready = 0
EN = 0
WE = 0
Standby
Ready = 1
EN = 1
WE = 0
Write = 0
Status = CONT
Burst = Burst length
BIREn = 0
BIREn = 1
Last
Read
Ready = 1
EN = 0
WE = X
Status = BUSY
Read
Ready = 1
EN = 1
WE = 0
Write = 0
Status = CONT or BUSY
Burst < Burst length
Status = IDLE
Fig. 5.9 SRAM bus interface for read
178
5
Memory Circuits and Systems

5.2
Synchronous Dynamic Random Access Memory
Synchronous Dynamic Random Access Memory (SDRAM) is a variation of the older
DRAM, and it constitutes the main memory of almost every computing system. Even though
its capacity can be many orders of magnitude higher than SRAM, it lacks speed. Therefore,
its usage is limited to storing large blocks of data when speed is not important.
An SDRAM module is composed of four blocks. The memory core is where data is
stored. The row and column decoders locate the data. The sense ampliﬁer ampliﬁes the cell
voltage during read. The controller manages all the read and write sequences.
The block diagram in Fig. 5.11 shows a typical 32-bit SDRAM architecture composed of
four memory cores, called banks, accessible by a single bidirectional input/output port. Prior
to operating the memory, the main internal functions, such as addressing mode, data latency
and burst length, must be stored in the Address Mode Register. Once programmed, the
active-low Row Address Strobe, RAS, Column Address Strobe, CAS, and Write Enable,
WE, signals determine the functionality of the memory as shown in Table 5.1. The data from
a selected bank can be masked by the Read/Write logic block at the DInOut port so that only
part of the data can be fetched from the memory. This unit also serves blocking parts of the
32-bit data to be written to a bank.
BLOCK 0
Addr[3:0]
4
WE
En0
BLOCK 1
Addr[3:0]
4
WE
Out[31:0]
32
EN
Addr[4]
Addr[5]
BLOCK 2
In[31:0]
Addr[3:0]
4
WE
BLOCK 3
Addr[3:0]
4
WE
32
Addr[4]
Addr[5]
EN
Addr[4]
Addr[5]
EN
Addr[4]
Addr[5]
EN
Addr[4]
Addr[5]
En1
En2
En3
DIn0
DOut0
DIn1
DOut1
DIn2
DOut2
DIn3
DOut3
1
0
3
2
Fig. 5.10 Increasing SRAM address space
5.2
Synchronous Dynamic Random Access Memory
179

The SDRAM cell is a simple device composed of an NMOS transistor to control the
data-ﬂow in and out of the cell and a capacitor to store data as shown in Fig. 5.12. When new
data needs to be written into the cell, the NMOS transistor is turned on by Control = 1, and
the data at the DIn/Out terminal overwrites the old data at the Cell node. Reading data from
the cell, on the other hand, requires ampliﬁcation of the cell voltage, thus activation of the
COLUMN 
DECODE
COLUMN 
DECODE
SENSE AMP
31
0
BANK
1
READ/WRITE 
LOGIC
DInOut[31:0]
R
O
W
D
E
C
O
D
E
R
O
W
D
E
C
O
D
E
4
Mask[3:0]
SENSE AMP
31
0
BANK
0
COLUMN 
DECODE
COLUMN 
DECODE
SENSE AMP
31
0
BANK
3
R
O
W
D
E
C
O
D
E
R
O
W
D
E
C
O
D
E
SENSE AMP
31
0
BANK
2
ColAddr[9:0]
RowAddr[9:0]
Column Address
Stobe (CAS)
CAS
RAS
Row Address
Stobe (RAS)
CAS
CAS
RAS
RAS
32
BS[1:0] = 3
WE
WE
BS[1:0] = 2
BS[1:0] = 1
BS[1:0] = 0
CS
CS
CS
Chip Select (CS)
WE
Address Mode Register
32
Write Enable (WE)
10
10
Fig. 5.11 Typical SDRAM architecture
Table 5.1 SDRAM modes of operation
CS
RAS
CAS
WE
0
0
0
0
Program Addr. Mode Register
0
0
0
1
Self Refresh
0
0
1
0
Precharge a Bank with BS[1:0]
0
0
1
1
Activate a Bank with BS[1:0]
Write into a Bank with BS[1:0]
Read from a Bank with BS[1:0]
Burst Stop
Reserved
SDRAM Deselect
0
1
0
0
0
1
0
1
0
1
1
0
0
1
1
1
1
X
X
X
OPERATION
180
5
Memory Circuits and Systems

sense ampliﬁer when the NMOS transistor is turned on. When data needs to be preserved,
the NMOS transistor is simply turned off by Control = 0. However, the charge on the cell
capacitor slowly leaks through its insulator, resulting in a reduced cell voltage. Thus, an
automatic or manual cell refresh cycle becomes mandatory during SDRAM operation to
preserve the bit value in the cell.
The ﬁrst row of the truth table in Table 5.1 indicates how to program the internal Address
Mode Register. At the positive edge of the clock, CS, RAS, CAS and WE signals are pulled
low to logic 0 to program the Address Mode Register as shown in Fig. 5.13. In the program,
the address bits, A[2:0], deﬁne the data burst length as shown in Table 5.2. Burst length can
range from one word of data to a full page, which is equal to the contents of the entire bank.
The address bit, A[3], deﬁnes how the SDRAM address is incremented for each data packet.
In sequential addressing mode, the starting address is incremented by one while the carry bit is
eliminated according to the size of the burst length. In linear addressing mode, the address is
incremented without eliminating the carry bit. The address bits, A[5:4], determine the data
latency when reading takes place from the memory. Latency can range from two to ﬁve clock
cycles depending on the need.
Control
C
DIn/Out
Cell
Fig. 5.12 SDRAM memory cell
clock
A[2:0]
A[3]
BURST LENGTH
ADDRESS MODE
CS
RAS
CAS
WE
A[5:4]
LATENCY
Fig. 5.13 Timing diagram for programming the address mode register
5.2
Synchronous Dynamic Random Access Memory
181

The example in Table 5.3 shows the elimination of the carry bit in sequential addressing
mode for burst lengths of 2, 4 and 8. In this example, if the starting address is 13 and the
burst length is two words, the carry bit from the column A[0] is eliminated, resulting the next
address to be 12. In the same example, if the burst length is increased to four, this time the
carry bit from the column A[1] is eliminated, and the address values following the starting
address 13 become 14, 15 and 12. If the burst length becomes eight, the carry bit from the
column A[2] is eliminated, and the address values of 14, 15, 8, 9, 10, 11 and 12 follow the
initial address 13. Sequential addressing conﬁnes reading or writing of data within a pre-
deﬁned, circulatory memory space, convenient for speciﬁc software applications.
The linear addressing mode is a simpliﬁed version of the interleave addressing in various
SDRAMs, and increments the SDRAM address linearly without eliminating the carry bit as
shown in Table 5.4. In this example, if the starting address is 13 and the burst length is two,
the next address will be 14. If the burst length is increased to four, the next three addresses
following 13 will be 14, 15 and 16. In contrast to the sequential addressing mode, the linear
addressing increments SDRAM address one bit at a time, not conﬁning the data in a
circulatory address space.
The second row of the operational truth table in Table 5.1 shows how to initiate a self
refresh cycle as shown in Fig. 5.14. In self refresh, SDRAM automatically replenishes node
voltage values at each cell because the charge across the cell capacitor leaks through its
dielectric layer over time. The time duration between refresh cycles depends on the tech-
nology used, the quality of the oxide growth and the thickness of the dielectric used between
capacitor plates.
Table 5.2 Truth tables for programming the address mode register
A[2]
A[1]
A[0]
Burst Length
0
0
0
0
0
0
1
1
0
1
0
1
1
1
1
1
0
0
1
1
0
1
0
1
1 Word
2 Words
4 Words
8 Words
16 Words
32 Words
64 Words
Full Page
A[3]
Addressing Mode
Sequential
Linear
0
1
A[5]
A[4]
Latency
0
0
1
1
0
1
0
1
2
3
4
5
182
5
Memory Circuits and Systems

Table 5.3 SDRAM sequential mode addressing for burst lengths of 2, 4 and 8
A[9]
A[8]
A[7]
A[6]
A[5]
A[4]
A[3]
A[2]
A[1]
A[0]
0
0        0
0
0
0
1
1
0
1    =  13
0
0        0
0
0
0
1
1
1
0    =  14
0
0        0
0
0
0
1
1
1
1    =  15
0
0        0
0
0
0
1
0
0
0    =  8
0
0        0
0
0
0
1
0
0
1    =  9
0
0        0
0
0
0
1
0
1
0    =  10
0
0        0
0
0
0
1
0
1
1    =  11
0
0        0
0
0
0
1
1
0
0    =  12
delete the carry bit
+ 1
+ 1
+ 1
+ 1
+ 1
+ 1
+ 1
Starting Address = 13, Burst Length = 8, Mode = Sequential
Starting Address = 13, Burst Length = 4, Mode = Sequential
+ 1
delete the carry bit
0
0
0
0
0
0
1
1
0
1
=    13
=    14
A[9]
A[8]
A[7]
A[6]
A[5]
A[4]
A[3]
A[2]
A[1]
A[0]
0
0
0
0
0
0
1
1
1
0
+ 1
=    15
0
0
0
0
0
0
1
1
1
1
=    12
0
0
0
0
0
0
1
1
0
0
+ 1
Starting Address = 13, Burst Length = 2, Mode = Sequential
+ 1
delete the carry bit
0
0
0
0
0
0
1
1
0
1
=    13
=    12
A[9]
A[8]
A[7]
A[6]
A[5]
A[4]
A[3]
A[2]
A[1]
A[0]
0
0
0
0
0
0
1
1
0
0
5.2
Synchronous Dynamic Random Access Memory
183

Table 5.4 SDRAM linear addressing mode for burst lengths of 2 and 4
Starting Address = 13, Burst Length = 2, Mode = Linear
A[9]     A[8]     A[7]     A[6]     A[5]     A[4]     A[3]     A[2]     A[1]     A[0]
0         0          0          0         0          0         1         1          0         1     =    13
0         0          0          0         0          0         1         1          1         0     =    14
0         0          0          0         0          0         1         1          1         1     =    15
0         0          0          0         0          1         0         0          0         0     =    16
Starting Address = 13, Burst Length = 4, Mode = Linear
A[9]     A[8]     A[7]     A[6]     A[5]     A[4]     A[3]     A[2]     A[1]     A[0]
0         0          0          0         0          0         1         1          0         1     =    13
0         0          0          0         0          0         1         1          1         0     =    14
Self Refresh
IDLE
IDLE
IDLE
IDLE
clock
BANK0
BANK1
BANK2
BANK3
CS
RAS
CAS
WE
Fig. 5.14 Timing diagram for self-refresh
184
5
Memory Circuits and Systems

Rows three to six in Table 5.1 deﬁne the read and write sequences in an SDRAM as
shown in Fig. 5.15. In this ﬁgure, a read or a write sequence always starts with precharging
all the rows and columns of the SDRAM core. This is followed by an activation cycle where
the row address is generated. In the last cycle, the column address is generated, and the data
is either written or read from the memory according to the control signals, CS, RAS, CAS
and WE.
Prior to a read or a write, all the rows and columns of a bank must be precharged to a
certain voltage level for a period of one clock cycle as shown in Fig. 5.16. During precharge,
CS, RAS and WE, must be lowered to logic 0, and CAS must be kept at logic 1 as shown in
the third row of Table 5.1. The value of the precharge voltage can be anywhere between 0 V
and the full supply voltage depending on the technology and the requirements of the circuit
design. The activation cycle starts right after precharging a bank. The time interval between
the precharge and activation cycles is called the precharge time period, tPRE, as shown in
Fig. 5.16. The activation cycle is enabled by lowering CS and RAS to logic 0, but keeping
CAS and WE at logic 1 as shown in the fourth row of Table 5.1. Following the activation
cycle, the next precharge period must not start until after a certain time period has elapsed for
the same bank. This time interval is called the RAS time period, tRAS, as shown in Fig. 5.16.
PRECHARGE
ACTIVATE and
supply Row Address
READ and supply
Column Address
WAIT
WAIT
WAIT
PRECHARGE
ACTIVATE and
supply Row Address
WRITE and supply 
Column Address
WAIT
WAIT
WAIT
Fig. 5.15 Write and read operation cycles
5.2
Synchronous Dynamic Random Access Memory
185

The ﬁfth row of Table 5.1 shows how to write to a selected bank when CS = CAS = WE = 0
and RAS = 1. The actual write takes place in the last phase of the write sequence in Fig. 5.15
following the precharge and activation cycles. To illustrate the write sequence in detail, an
example illustrating a single write burst is given in Fig. 5.17. In this ﬁgure, the write cycle
starts with precharging Bank 1. After t = tPRE, the activation period starts and the row
address is deﬁned for the SDRAM. When the column address is generated after a time period
of tCAS, four data packets, D(0) to D(3), are written to SDRAM core in four consecutive
clock cycles. Note that in this ﬁgure if the same bank is used for another write, a new time
period, tRAS, needs to be placed between the bank activation cycle and the next precharge
period.
clock
BS[1]
BS[0]
tPRE
Precharge
BANK1
Activate 
BANK1
CS
RAS
CAS
WE
Precharge
BANK1
tRAS
Fig. 5.16 Bank precharge and activation cycles
186
5
Memory Circuits and Systems

The example in Fig. 5.18 shows two separate write sequences into two different banks.
When writing takes place more than a single bank, interleaving one bank’s precharge and
activation time periods with respect to the other may result in a time-saving scenario where
one write burst takes place immediately after the other, resulting in a shorter overall write
period. In this ﬁgure, the interleaving technique results in writing four words to bank 1
immediately after writing four words to bank 0 without any cycle loss. Therefore, writing to
two (or more) different banks as opposed to writing continuously to a single bank is a
preferred scheme because this process eliminates all unnecessary waiting periods between
precharge cycles. However, as the burst length involves a lot more than four words, the
relative placement of the bank precharge cycle in the timing diagram becomes less
important.
A[9:0]
DInOut
ROW ADDRESS
and
ACTIVATE BANK1
PRECHARGE
BANK1
COLUMN ADDRESS
and
WRITE BANK1
ROW
COL
tRAS
BS[1]
BS[0]
tPRE
tCAS
clock
CS
RAS
CAS
WE
D(0)
D(1)
D(2)
D(3)
tBURST
tWAIT
PRECHARGE
BANK1
Fig. 5.17 A single write cycle
5.2
Synchronous Dynamic Random Access Memory
187

The sixth row of Table 5.1 shows how to initiate a read cycle from a selected bank.
Reading words from SDRAM involves a latency period, and it needs to be programmed in
the Address Mode Register. The example in Fig. 5.19 shows the start of a read burst after a
latency period of three clock cycles once the read command and the address are given.
A latency of three clock cycles means that the data becomes available at the output of
SDRAM in the third clock cycle after the address is issued.
Read 8 WORDS from the Starting Address = 13 in Sequential Mode with Latency = 3 
clock
Address
Data
D(13)
Mode
D(14)
D(15)
D(8)
D(9)
D(10)
D(11)
D(12)
controls
13
LATENCY = 1
LATENCY = 2
LATENCY = 3
Fig. 5.19 Deﬁnition of latency during a read cycle
clock
A[9:0]
DInOut
ACT
BANK0
PRE
BANK0
WRITE
BANK1
ROW1
BS[1]
BS[0]
ROW0
COL0
COL1
PRE
BANK1
WRITE
BANK0
ACT 
BANK1
D0(0)
D0(1)
D0(2)
D0(3)
D1(0)
D1(1)
D1(2)
D1(3)
CS
RAS
CAS
WE
Fig. 5.18 Multiple write cycles to different banks (tPRE = 1 cycle, tCAS = 2 cycles)
188
5
Memory Circuits and Systems

The example in Fig. 5.20 shows a single read sequence from bank 1. Until the read command
and the column address are issued, the read and write sequences follow identical paths.
However, after this point the read burst starts following a latency period. Similar to the write
process, a certain tRAS period must elapse between read bursts before additional streams of data
become available from the same bank. In this ﬁgure, tWAIT corresponds to the waiting period
between the last data packet read from the memory and the start of the next precharge period.
The example in Fig. 5.21 describes multiple reads from the same bank and assumes tWAIT
is equal to zero. This scenario produces a read burst of four words, D(0) to D(3), from bank 1
and causes the same bank to be precharged during the last data delivery. The second read
burst from bank 1 follows the same pattern as the ﬁrst one and delivers D(4) to D(7) after a
programmed latency of two clock periods. If tWAIT is different from zero, then the second
precharge period should start right after the tWAIT period as described in Fig. 5.20.
The interleaving technique used in reading data from two different banks in Fig. 5.22 is
not any different from the one used when writing data to two different banks. As with the
write case, the placement of the second precharge cycle in the timing diagram is important to
achieve two consecutive read bursts, D0(0) to D0(3) from bank 0 and D1(0) to D1(3) from
bank 1, without any cycle loss in between, accomplishing the shortest possible time to fetch
data from SDRAM.
A[9:0]
DInOut
LAST
READ BANK1
ROW
COL
BS[1]
BS[0]
LATENCY = 3
clock
D(0)
D(1)
D(2)
D(3)
CS
RAS
CAS
WE
ROW ADDRESS
and
ACTIVATE BANK1
PRECHARGE
BANK1
COLUMN ADDRESS
and
READ BANK1
tRAS
tPRE
tCAS
tBURST
tWAIT
tLAT
PRECHARGE
BANK1
Fig. 5.20 Single read cycle
5.2
Synchronous Dynamic Random Access Memory
189

The seventh row of Table 5.1 shows how to stop a read or a write burst. Figure 5.23
shows a single write sequence when the burst stop command is issued in the middle of a data
clock
A[9:0]
DInOut
ROW ADDRESS
and
ACTIVATE BANK1
PRECHARGE
BANK1
BS[1]
BS[0]
COLUMN ADDRESS
and 
READ BANK1 
COLUMN ADDRESS
and 
READ BANK1
LATENCY = 2
ROW ADDRESS
and
ACTIVATE BANK1
LATENCY = 2
CS
RAS
CAS
WE
COL
ROW
COL
ROW
D(0)
D(1)
D(2)
D(3)
D(4)
D(5)
D(6)
D(7)
LAST READ and 
PRECHARGE 
BANK1
tRAS
Fig. 5.21 Multiple read cycles from the same bank (tPRE = 1 cycle, tCAS = 2 cycles,
tWAIT = 0 cycle)
clock
DInOut
A[9:0]
BS[0]
BS[1]
PRE
BANK0
ACT
BANK0
PRE
BANK1
COL ADDR
and
READ BANK0
ACT
BANK1
COL ADDR
and
READ BANK1
CS
RAS
CAS
WE
ROW0
COL0
ROW1
COL1
D0(0)
D1(0)
D1(2)
D1(3)
D0(1)
D0(2)
D0(3)
D1(1)
Fig. 5.22 Multiple read cycles from different banks (tPRE = 1 cycle, tCAS = 2 cycles)
190
5
Memory Circuits and Systems

burst. Upon receiving this command, the selected bank goes into the standby mode and waits
for the next precharge command.
When the burst stop command is given in the middle of a read, the last data packet is still
delivered at the clock edge following the burst stop command as shown in Fig. 5.24.
clock
A[9:0]
DInOut
ROW ADDRESS
and
ACT BANK0
BURST 
STOP
PRECHARGE 
BANK0
COL ADDRESS
and
WRITE into BANK0
CS
RAS
CAS
WE
ROW
COL
Fig. 5.23 Burst stop during write
clock
A[9:0]
DInOut
CS
RAS
CAS
WE
ROW
COL
CAS LATENCY = 2
ROW ADDRESS
and
ACT BANK0
BURST 
STOP
PRECHARGE 
BANK0
COL ADDRESS
and
READ from BANK0
Fig. 5.24 Burst stop during read
5.2
Synchronous Dynamic Random Access Memory
191

The Input/Output data can be masked with the Read/Write Logic block in Fig. 5.11. The
truth table in Table 5.5 lists all the possible cases of blocking and transmitting data to/from
SDRAM core. When Mask[3:0] = 0000, for example, no mask is applied to the output data,
and all 32 bits are allowed to be written to the selected bank or read from it. The case, Mask
[3:0] = 1111, on the other hand, blocks all four bytes of data, and allows no byte to be
written or read from the selected address.
Figure 5.25 shows the data-path and the controller of the SDRAM bus interface. Prior to
operating SDRAM, each ten-bit wide bus interface register containing the precharge (tPRE),
CAS (tCAS), burst (tBURST), latency (tLAT), and wait (tWAIT) periods must be programmed
through a 10-bit program bus. The precharge, CAS and wait registers contain the number of
clock cycles to achieve the required waiting period. The burst register should store the
number of data packets of the data transfer. Therefore, the value in this register must be
identical to the value programmed in the Address Mode Register. The latency register
speciﬁes the number of clock cycles prior to reading the ﬁrst data from an SDRAM address.
The details of how the programming takes place prior to the normal SDRAM operation and
the required hardware are omitted from Fig. 5.25 to avoid complexity. The Address Mode
Table 5.5 Truth table for data output mask
Mask [3]
Mask [2]
Mask [1]
Mask [0]
0
0
0
0
0
0
0
1
DInOut[7:0]
None
0
0
1
0
0
0
1
1
DInOut[15:0]
DInOut[15:8]
0
1
0
0
0
1
0
1
DInOut[23:16] and DInOut[7:0]
DInOut[23:16]
0
1
1
0
0
1
1
1
DInOut[23:0]
DInOut[23: 8]
1
0
0
0
1
0
0
1
DInOut[31:24] and DInOut[7:0]
DInOut[31:24]
1
0
1
0
1
0
1
1
DInOut[31:24] and DInOut[15:0]
DInOut[31:24] and DInOut[15:8] 
1
1
0
0
1
1
0
1
DInOut[31:16] and DInOut[7:0]
DInOut[31:16]
1
1
1
0
1
1
1
1
DInOut[31:0]
DInOut[31:8]
MASKED BITS
192
5
Memory Circuits and Systems

Bus Interface
Control Unit
Status
Write
Size
Burst
Ready
EnRData
EnWData
WData
RData
32
32
clock
CountOut
-1
SDRAM
D
Q
BIWEn
4
32
32
CS
RAS
CAS
WE
2
10
10
C
R
Address Reg
Load tPRE
P
B
C
W
StoreReg
BIREn
Addr Mode Reg
Program Data
10
P
10
StoreReg
Load tCAS
Load tBURST
Load tWAIT
tPRE
tCAS
tBURST
tWAIT
tLAT
Addr[19:10] = Row Addr 
Addr[9:0] = Column Addr 
Addr[31:0]
Addr[31:28]
Addr[21:20]
Program Data = { 0000, Addr[5:0] = Addr Mode Reg }
DIn/DOut[31:0]
SelRow
SelCol
BS[1:0]
A[9:0]
10
Load tPRE
Load tCAS
Load tBURST
Load tWAIT
Count
Fig. 5.25 SDRAM bus interface block diagram
5.2
Synchronous Dynamic Random Access Memory
193

Register (or a set of registers deﬁning basic SDRAM functionality) exists in many older
SDRAMs. However, recent SDRAM modules omit the mode register completely and rely on
the bus interface unit to store such information. To manage the precharge, CAS, burst and
wait periods the memory controller is continuously interact with a down-counter in Fig. 5.25
since these periods are often many clock cycles long.
For normal SDRAM operation, the address bus, Addr[31:0], has been divided into several
segments. In the example in Fig. 5.26, the four most signiﬁcant bits of the SDRAM address,
Addr[31:28], indicate the SDRAM chip identiﬁcation, and it is used to activate the corre-
sponding bus interface. Addr[21:20] is used to select the SDRAM bank, BS[1:0]. Addr[19:10]
and Addr[9:0] specify the row and column addresses, respectively.
Figure 5.27 shows a typical SDRAM write sequence. In this timing diagram, all ﬁve
SDRAM interface registers must be programmed prior to the IDLE/PROG clock cycle as
mentioned earlier. The SDRAM write sequence starts with the system bus sending Status =
START, Write = 1 and the starting SDRAM address. These three signals cause the Bus
Interface Write Enable signal, BIWEn, to transition to logic 1, which in turn, enables the bus
interface for write in the ﬁrst cycle of Fig. 5.27. Once enabled, the bus interface stores the
starting SDRAM address in the Address Reg by StoreReg = 1 and issues the precharge
command by CS = 0, RAS = 0, CAS = 1 and WE = 0 for the selected bank. Within the same
cycle, the counter is loaded with the precharge wait period, tPRE, by LoadtPRE = 1 as shown
in the timing diagram.
The Precharge wait period is calculated by multiplying the number of clock cycles by the
clock period. The counter in this design is a down-counter. When its output value, CountOut,
becomes one, the controller initiates the activation cycle for the selected SDRAM bank and
dispatches the row address. The activation period starts with loading the value of tCAS into the
Addr[31:0]  = Addr[31:28]      Addr[27:22]      Addr[21:20]      Addr[19:10]      Addr[9:0]
Activate SDRAM
Bus Interface
Bank select[1:0] = BS[1:0]
Row Address[9:0] = A[9:0]
Reserved
Column Address[9:0] = A[9:0]
Fig. 5.26 SDRAM bus interface address mapping
194
5
Memory Circuits and Systems

clock
IDLE/
PROG
LOAD
PRE
tPRE
WRITE
WRITE
Addr
Status
Write
BIWEn
StoreReg
SelRow
SelCol
CS
RAS
CAS
WE
WData
EnWData
LoadtPRE
Ready
tPRE
PRE
Row
Addr
+
Act
Bank1
START
SDRAM Start Addr = A0
A1
A2
A3
Addr = B0
CONT
CONT
CONT
IDLE
START
WRITE
WRITE
Bank 1
ROW
COL
D0
3
2
1
3
2
1
3
2
1
4
3
2
1
BM sends WRITE data
Bank 1
Bank 1
BS[1:0]
A[9:0]
LoadtCAS
LoadtBURST
LoadtWAIT
tCAS
Col
Addr
+
Write
Bank1
tBURST
tWAIT
D1
D2
D3
tPRE
tPRE
LOAD
CAS
tCAS
tCAS
LOAD
BURST
START
WRITE
LOAD
WAIT
tWAIT
tWAIT
tWAIT
Output of the down-counter
Fig. 5.27 Write cycle with SDRAM bus interface
5.2
Synchronous Dynamic Random Access Memory
195

down-counter by LoadtCAS = 1. Within the same clock cycle, the row address, Addr[19:10],
is transferred from the Address Reg to the SDRAM through the R-port of the 3-1 MUX by
SelRow = 1. When the activation wait period expires, the controller uses the LoadtBURST
input to load the length of the write burst (the number of data packets) to the down-counter
and subsequently initiates the write sequence in the next cycle.
During the START WRITE period, the controller transfers the column address, Addr
[9:0], from the Address Reg through the C-port of the 3-1 MUX to the A[9:0] port of the
SDRAM by generating SelCol = 1. In the same cycle, the controller also generates CS = 0,
RAS = 1, CAS = 0, WE = 0 and enables the tri-state buffer by EnWData = 1 in order to write
the ﬁrst data packet, D0, to the SDRAM. To be able to write the remaining data packets, the
controller issues Ready = 1 from this point forward. When the sequence comes to the
LOAD WAIT period (where the last write takes place), the controller lowers the Ready
signal, but keeps the EnWData signal at logic 1 in order to write the last data packet, D3.
This clock cycle also signiﬁes the start of the wait period, tWAIT. The controller issues
LoadtWAIT = 1 to load tWAIT into the down-counter if another write sequence needs to take
place for the same bank.
The remaining control signals, Burst and Size, are omitted from the timing diagram for
simplicity. During the entire data transfer process, Burst is set to four and Size is set to 32 in
Fig. 5.27. For byte and half-word transfers, Size needs to be deﬁned with masking in place as
described in Table 5.5.
The state diagram of the controller for write is shown in Fig. 5.28. In this diagram, when the
interface receives BIWEn = 1, the controller transitions from the IDLE/PROG state, which
corresponds to the ﬁrst cycle of the timing diagram in Fig. 5.27, to the LOAD PRE state, which
corresponds to the second clock cycle in the same timing diagram. In the LOAD PRE state, the
controller resets CS, RAS and WE, but sets CAS for the selected bank to start the precharge
process. In this state, two additional signals are generated: StoreReg = 1 to store the bus
address in the Address Reg, and LoadtPRE = 1 to start the precharge wait period. In the next
cycle, the controller transitions to the precharge wait state, tPRE. The controller remains in this
state until CountOut = 1. The controller then transitions to the LOAD CAS state where it
activates the selected bank, issues SelRow = 1 to transfer the row address to the SDRAM, and
produces LoadtCAS = 1 to initiate the activation wait period. The next state, tCAS, is another
wait state where the controller waits until the activation period expires. Once this period is
over, the controller ﬁrst goes into the LOAD BURST state, and then to the START WRITE
state to initiate writing data to the SDRAM. The latter corresponds to the state where the ﬁrst
data packet is written to the SDRAM core as mentioned earlier. The subsequent writes take
place when the controller transitions to the WRITE state. The controller stays in this state until
CountOut = 2, which signiﬁes one more data packet to be written to the SDRAM. The last data
packet is ﬁnally written when the controller moves to the LOAD WAIT state. Before
attempting another write process, the controller waits in the tWAIT state until CountOut = 1.
196
5
Memory Circuits and Systems

Note that all the state names in Fig. 5.28 and the cycle names on top of Fig. 5.27 are kept the
same to make one-to-one correspondence between the timing diagram and the state diagram.
The SDRAM read sequence also starts with the system bus sending Status = START,
Write = 0 and an initial SDRAM address. This combination sets the Bus Interface Read
Enable signal, BIREn = 1, to enable the bus interface to read data from the SDRAM core in
the ﬁrst cycle of the timing diagram in Fig. 5.29. The remainder of the read process is
IDLE/
PROG
CountOut > 1
StoreReg = 1
CS = 0
RAS = 0
CAS = 1
WE = 0
LoadtPRE = 1
Ready = 0
LOAD
PRE
tPRE
Status = START
Write = 1
Addr = SDRAM start addr
else
LOAD
CAS
tCAS
START
WRITE
CountOut = 1
Ready=0
Ready=0
WRITE
EnWData = 1
Ready = 1
SelRow = 1
CS = 0
RAS = 0
CAS = 1
WE = 1
A [9:0] = Addr [19:10] = Row Address 
LoadtCAS = 1 
Ready = 0
SelCol = 1
CS = 0
RAS = 1
CAS = 0
WE = 0
A [9:0] = Addr [9:0] 
           = Col Address 
EnWData = 1
Ready = 1
LOAD
WAIT
EnWData = 1
LoadtWAIT = 1
Ready = 0
tWAIT
Ready=0
LOAD
BURST
CountOut > 2
CountOut = 2
LoadtBURST = 1
Ready = 1
CountOut > 2
CountOut = 2
CountOut > 1
CountOut = 1
Status = START
Write = 1
Addr = SDRAM start addr
else
CS = 0
RAS = 0
CAS = 0
WE = 0
Ready = 0
Fig. 5.28 SDRAM bus interface for write
5.2
Synchronous Dynamic Random Access Memory
197

clock
IDLE/
PROG
LOAD
PRE
tPRE
tPRE
tPRE
LOAD
CAS
tCAS
tCAS
START
READ
READ
READ
LOAD
WAIT
tWAIT
tWAIT
tWAIT
Addr
Status
Write
BIREn
StoreReg
SelRow
SelCol
CS
RAS
CAS
WE
BS[1:0]
A[9:0]
RData
EnRData
LoadtPRE
LoadtCAS
LoadtBURST
LoadtWAIT
Ready
tPRE
PRE
Row
Addr
  + 
Act 
Bank1
tCAS
Col
Addr
  + 
Read
Bank1
tBURST
tWAIT
START
SDRAM Start Addr = A0
A1
A2
A3
CONT
CONT
CONT
IDLE
START
READ
Bank1
Bank1
Bank1
ROW
COL
D0
D1
D2
D3
3
2
1
3
2
1
3
2
1
4
3
2
1
BM reads SDRAM data
tCAS
LAT
WAIT
READ
tLAT
ST Addr
Latency = 2
Output of the down-counter
Fig. 5.29 Read cycle with SDRAM bus interface
198
5
Memory Circuits and Systems

identical to the write process until the controller issues the read command during the
START READ cycle, and sends the column address of the selected SDRAM bank.
Since SDRAM data becomes available after a latency period, the controller must replicate
this exact delay prior to a read burst and produce the control signals during and after the
burst. For example, a cycle before the latency period expires, the controller needs to generate
LoadtBURST = 1 to load the burst duration to the down-counter to be able to detect the
beginning and the end of burst data. As a result, the controller can determine when to
generate EnRData = 1 for the tri-state buffer to read data packets, D0 to D3, from the
SDRAM RData output. During the last data delivery, the controller issues LoadtWAIT = 1 to
load the value of tWAIT to the down-counter in the event the same bank is selected for
another read.
The state diagram in Fig. 5.30 for the read sequence is a direct result of the timing
diagram in Fig. 5.29. In this diagram, when the interface receives BIREn = 1, the controller
transitions from the IDLE state which corresponds to the ﬁrst cycle in Fig. 5.29, to the
LOAD PRE state which corresponds to the second clock cycle in the same timing diagram.
In the LOAD PRE state, the precharge process is initiated by CS = 0, RAS = 0, WE = 0 and
CAS = 1 for the selected bank. In this state, the controller stores the valid bus address in the
Address Reg by StoreReg = 1, and loads the precharge wait period into the down-counter by
LoadtPRE = 1. Then the controller moves to the tPRE and stays in this state until the precharge
value in the down-counter expires. Next, the controller transitions to the LOAD CAS state
where it activates the selected bank by CS = 0, RAS = 0, CAS = 1 and WE = 1, issues
SelRow = 1 to transfer the row address from the Address Reg to the SDRAM, and generates
LoadtCAS = 1 to load the activation wait period to the down-counter. The CAS wait period
corresponds to the tCAS state in Fig. 5.30. When this period is over at CountOut = 1, the
controller transitions to the START READ state where it issues CS = 0, RAS = 1, CAS = 0
and WE = 1 to initiate the data read and produces SelCol = 1 to transfer the column address
from Address Reg to the SDRAM address port. This state is followed by four individual
latency states to select the programmed read latency period. Since the read latency in
Fig. 5.29 is equal to two, the state machine traces through a single LAT WAIT state. In the
LAT WAIT state, the controller issues LoadtBURST = 1 and loads the value of the data burst,
tBURST, to the down-counter. Following the latency states, the state machine transitions to the
READ state where it stays until CountOut = 2, signifying the end of the read burst. Here, it
produces EnRData = 1 to enable the data output buffer and Ready = 1 to validate the read
data. At the end of the burst period, the state machine moves to the LOAD WAIT state and
issues LoadtWAIT = 1 to load the required wait period into the down-counter until the next
precharge takes place. Subsequently, the state machine transitions to the tWAIT state and
stays there until the wait period is over.
5.2
Synchronous Dynamic Random Access Memory
199

IDLE/
PROG
CountOut > 1
LOAD
PRE
tPRE
Status = START
Write = 0
Addr = SDRAM Start Addr
else
LOAD
CAS
tCAS
START
READ
Ready=0
Ready=0
READ
LOAD
WAIT
EnRData = 1
Ready = 1
tWAIT
Ready=0
StoreReg = 1
CS = 0
RAS = 0
CAS = 1
WE = 0
Load tPRE = 1 
Ready = 0
SelRow = 1
CS = 0
RAS = 0
CAS = 1
WE = 1
A [9:0] = Addr [19:10] = Row Address 
Load tCAS = 1 
Ready = 0
LAT
WAIT
Load tBURST = 1
Ready = 0
LAT
WAIT
Ready = 0
LAT
WAIT
Ready = 0
LAT
WAIT
Ready = 0
LAT
WAIT
LAT
WAIT
Ready = 0
LAT
WAIT
Ready = 0
LAT
WAIT
LAT
WAIT
Ready = 0
LAT
WAIT
LATENCY = 2
SelCol = 1
CS = 0
RAS = 1
CAS = 0
WE = 1
A [9:0] = Addr [9:0] = Col Address 
Ready = 0
CountOut = 1
CountOut > 1
CountOut = 1
CountOut > 2
CountOut = 2
LoadtWAIT = 1
EnRData = 1
Ready = 1
CountOut > 1
CountOut = 1
LATENCY = 3
Load tBURST = 1
Ready = 0
LATENCY = 4
Load tBURST = 1
Ready = 0
LATENCY = 5
Load tBURST = 1
Ready = 0
Status = START
Write = 0
Addr = SDRAM Start Addr
else
CS = 0
RAS = 0
CAS = 1
WE = 0
Ready = 0
Fig. 5.30 SDRAM bus interface for read
200
5
Memory Circuits and Systems

5.3
Electrically-Erasable-Programmable-Read-Only-Memory
Electrically-Erasable-Programmable-Read-Only-Memory (E2PROM) is historically consid-
ered the predecessor of Flash memory and also the slowest memory in a computing system.
Its greatest advantage over the other memories is its ability to retain data after the system
power is turned off due to the ﬂoating-gate MOS transistor in its memory core. Its relatively
small size compared to electromechanical hard disks makes this device an ideal candidate to
store Built-In-Operating-Systems (BIOS) especially for hand-held computing platforms.
A typical E2PROM memory is composed of multiple sectors, each of which contains
multiple pages as shown in the example in Fig. 5.31. A single word in E2PROM can be
located by specifying its sector address, page address and row address. The sector address
indicates which sector a particular word resides. The page address locates the speciﬁc page
inside a sector. Finally, the row address points to the location of the data byte inside a page.
There are ﬁve control signals in E2PROM to perform read, write or erase operations. The
active-low Enable signal, EN, places a particular page in standby mode and prepares it for an
upcoming operation. The active-low Command Enable signal, CE, is issued with a command
code, such as read, write (program) or erase. The active-low Address Enable signal, AE, is
Row Addr[7:0]
8
WE
AE
RE
EN
CE
I/O
7
255
0
Page15
Page1
Page0
255
0
Page15
Page1
Page0
Sector 15
Sector 0
E2PROM Read/Write Interface
8
0
7
0
Page Addr[3:0]
Sector Addr[3:0]
4
4
Fig. 5.31 A typical E2PROM organization
5.3
Electrically-Erasable-Programmable-Read-Only-Memory
201

issued when an address is provided. Finally, the active-low Write Enable signal, WE, and the
Read Enable signal, RE, are issued for writing and reading data, respectively.
Typical E2PROM architecture consists of a memory core, an address decoder, an output
data buffer, status, address and command registers, and a control logic circuit as shown in
Fig. 5.32. Prior to any operation, command and address registers are programmed. When the
operation starts, the control logic enables the address decoder, the data buffer and the
memory core using the active-high Enable Address (ENA), Enable Data Buffer (END), and
Write Enable Core (WEC) or Read Enable Core (REC) signals depending on the operation.
The address stored in the address register is decoded to point the location of data. If the read
operation needs to be performed, the required data is retrieved from the E2PROM core and
stored in the data buffer before it is delivered to the I/O bus. If the operation is a write (or
program), the data is stored in the data buffer ﬁrst before it is uploaded to the designated
E2PROM address. In all cases, EN needs to be at logic 0 to place E2PROM into standby
mode before starting an operation. The table in Fig. 5.33 describes all major operation
modes. Hibernate mode disables the address decoder, memory core and data buffer to reduce
power dissipation, and puts the device into sleep.
8
WE
AE
RE
EN
CE
Control
Logic
Status Register
Command Register
Address Register
Address Decoder
Memory
Core
Data Buffer
8
From I/O[7:0]
From I/O[7:0]
To I/O[7:0]
ENA
END
WEC/REC
I/O[7:0]
Row + Page + Sector Addr
16
Fig. 5.32 A typical E2PROM architecture
202
5
Memory Circuits and Systems

The E2PROM cell shown in Fig. 5.34 is basically an N-channel MOS transistor with an
additional ﬂoating gate layer sandwiched between its control gate terminal (Wordline) and
the channel where the electronic conduction takes place. This device has also drain (Bitline)
and source (Sourceline) terminals for connecting the cell to the neighboring circuitry.
To write logic 0 into the memory cell, a high voltage is applied between Wordline and
Bitline terminals while the Sourceline node remains connected to ground. This conﬁguration
generates hot carriers in the transistor channel which tunnel through the gate oxide and reach
the ﬂoating gate, raising the threshold voltage of the transistor. The raised threshold voltage
prevents the programmed device to be turned on by the standard gate-source voltage used
during normal circuit operations, and causes the value stored in the device to be interpreted
as logic 0. An unprogrammed device with no charge on the ﬂoating gate, on the other hand,
exhibits low threshold voltage characteristics and can be turned on by the standard
gate-source voltage, producing a channel current. In this state, the value stored in the device
is interpreted as logic 1.
Figure 5.35 shows a typical command input sequence. There are four basic commands for
this E2PROM example: read, write (program), page-erase and status register read. The write
and program commands will be used interchangeably here and when describing the Flash
memory since they mean the same operation. The operation sequence always starts with the
command input followed by the address and data entries. To issue a command input, EN is
lowered to logic 0, AE is raised to logic 1 (because the entry is not an address), and CE is
lowered to logic 0, indicating that the value on the I/O bus is a command input. Since the
command input is written into the command register WE is also lowered to logic 0 some
EN
WE
RE
0
1
1
Standby
0
0
1
Write
0
1
0
Read
1
X
X
Hibernate
Fig. 5.33 E2PROM major operation modes
Wordline
Sourceline
Bitline
Floating gate
Channel
Fig. 5.34 E2PROM cell
5.3
Electrically-Erasable-Programmable-Read-Only-Memory
203

time after the negative edge of CE signal. This delay is called the setup time (tS) as shown in
Fig. 5.35. The low phase of WE signal lasts for a period of tLO, and transitions back to logic
1 some time before the positive edge of CE. This time interval is called the hold time, tH.
Prior to the positive edge of WE, a valid command input is issued, satisfying the data setup
time, tDS, and the data hold time, tDH, as shown in Fig. 5.35.
The address input timing shown in Fig. 5.36 has the same principle as the command input
timing described above: EN needs to be at logic 0 to enable the device, AE must be at logic 0
for the address entry, and CE needs to be at logic 1 because this operation is not a command
entry. During the low phase of EN signal, WE signal must be lowered to logic 0 twice to
locate data in the E2PROM. The ﬁrst time WE = 0, an eight-bit row address is entered at the
ﬁrst positive edge of WE. This is followed by the combination of four-bit page address and
four-bit sector address at the next WE = 0. The WE signal must be lowered to logic 0 after a
period of tS, following the negative edge of the EN signal, and then back to logic 1 for a
period of tH before the positive edge of EN. The WE signal must also be at the low phase for
a period of tLO and at the high phase for a period of tHI (or longer) during the address entry.
Valid address values are issued at each positive edge of WE within the tDS and tDH setup and
hold time periods.
CE
EN
WE
AE
I/O[7:0]
tDS
tDH
Command Input
tH
tS
tLO
Fig. 5.35 Command input timing diagram
204
5
Memory Circuits and Systems

Figure 5.37 describes data entry sequence where (M + 1) number of data packets are
written to the E2PROM. During the entire write cycle AE signal must be at logic 1, indi-
cating that the operation is a data entry but not an address. Data packets are written at each
positive edge of WE signal.
During a read the active-low control signals, AE and CE, are kept at logic 1. The Read
Enable signal, RE, enables the E2PROM to read data from the memory core at each negative
edge as shown in Fig. 5.38. The time delay between the negative edge of RE and the actual
CE
EN
WE
AE
I/O[7:0]
tDS
tDH
A[7:0]
tH
tS
tLO
tHI
A[15:8]
Row
Address
Page + Sector 
Address
Fig. 5.36 Address input timing diagram
CE
EN
WE
AE
I/O[7:0]
tDS
tDH
DIn0
tH
tS
tLO
tHI
DIn1
DInM
Fig. 5.37 Data input (write or program) timing diagram
5.3
Electrically-Erasable-Programmable-Read-Only-Memory
205

availability of data from the memory is called the access time, tA, as shown in the same
timing diagram. The RE signal must have the speciﬁed tS, tH, tLO and tHI time periods to be
able to read data from the memory core.
CE
EN
RE
AE
I/O[7:0]
DOut0
tH
tS
tLO
tHI
DOut1
DOutM
tA
Fig. 5.38 Data output (read) timing diagram
Reading data from the Status Register is a two-step process. The ﬁrst step involves
entering the command input, Status Register Read, at the positive edge of the WE signal.
The contents of the register are subsequently read sometime (tA) after the negative edge of
RE as shown in Fig. 5.39. Note that CE signal is initially kept at logic 0 when entering the
command input, but raised to logic 1 when reading the contents of the Status Register.
A full-page write data entry consists of the combination of four tasks as shown in Fig. 5.40.
The ﬁrst task is entering the Write to Data Buffer command at the positive edge of WE while
keeping CE at logic 0. The second task is entering the page and sector addresses at the
positive edge of WE while AE is at logic 0. The third task is entering the full-page of data
from D(0) to D(255) into the data buffer at each positive edge of WE signal. Both AE and CE
are kept at logic 1 during this phase. The last task is entering the Write to Core Memory
command in order to transfer all 256 bytes of data from the data buffer to the memory core.
The last cycle needs a relatively longer time period, tWRITE, to complete the full-page write.
The read operation is composed of three individual tasks similar to the write operation as
shown in Fig. 5.41. The ﬁrst task is entering the Read from Memory command at the
positive edge of WE while CE is at logic 0. The second step is entering the starting address
by specifying the row, page and sector address values at each positive edge of WE while AE
is at logic 0. The third task is to read data from the memory core at each negative edge of RE
while CE and AE signals are at logic 1.
206
5
Memory Circuits and Systems

CE
EN
WE
AE
I/O[7:0]
tDS
tDH
Status Read
tS
tLO
RE
tLO
tH
tA
tS
SR Read
Command
Read
SR Contents
tH
SR contents
Fig. 5.39 Timing diagram for reading status register
CE
EN
RE
AE
I/O[7:0]
tS
WE
tH
tS
tH
WrtDB
A15-8
tH
tS
Program 
Command 
Register:
Write to 
Data Buffer 
Command
Page + Sector 
Address
Full Page
DI(0)
DI(1)
DI(255)
WrtCM
tWRITE
Program
Command
Register:
Write to 
Core Memory
Command
tS
tH
Fig. 5.40 Timing diagram for full-page write (program)
5.3
Electrically-Erasable-Programmable-Read-Only-Memory
207

A typical full-page erase is described in Fig. 5.42. In this ﬁgure, the Erase Full Page
command is entered ﬁrst at the positive edge of WE while CE is at logic 0. The memory address,
CE
EN
RE
AE
I/O[7:0 ]
tS
WE
tH
tS
tH
Read
A7-0
A15-8
DO(N)
DO(N+1)
DO(N+255)
tH
tS
Program 
Command 
Register:
Read from 
Memory 
Command
Row
Address
Page + Sector 
Address
From 
Starting Addr 
From 
Last Addr
Fig. 5.41 Timing diagram for full-page read
CE
EN
RE
AE
I/O[7:0]
tS
WE
tH
tS
tH
FPEras
A15-8
tH
tS
Program
Command
Register:
Erase
Full Page
Command
Page + Sector
Address
CMEras
tERASE
Program
Command
Register:
Erase
Core Memory 
Command
Fig. 5.42 Timing diagram for full-page erase
208
5
Memory Circuits and Systems

composed of page and sector addresses, is entered next while AE is at logic 0. The Erase Core
Memory command is entered following the address while CE is at logic 0. Full-page erase time
period, tERASE, must be employed to complete the operation.
5.4
Flash Memory
Flash memory is the successor of the Electrically-Erasable-Programmable-Read-Only-
Memory (E2PROM), and as its predecessor it has the capability of retaining data after power
is turned off. Therefore, it is ideal to use in hand-held computers, cell phones and other
mobile platforms.
A typical Flash memory is composed of multiple sectors and pages as shown in Fig. 5.43.
An eight-bit word can be located in a Flash memory by specifying the sector, the page and
the row addresses. To be compatible with the E2PROM architecture example given in the
previous section, this particular Flash memory also contains 16 sectors and 16 pages. Each
page contains 256 bytes. The sector address constitutes the most signiﬁcant four bits of the
16-bit Flash address, namely Addr[15:12]. Each page in a sector is addressed by Addr[11:8],
and each byte in a page is addressed by Addr[7:0]. There are ﬁve main control signals in
Flash memory to perform basic read, write (program), erase, protect and reset operations.
Write and program commands are equivalent to each other, and used interchangeably
8
WE
Reset
EN
RE
255
0
Sector 15
Sector 0
Flash Read/Write Interface
8
7
0
Addr[15:8] = Addr[15:12] = Sector[3:0]
Addr[11:8]   = Page[3:0] 
8
I/O[7:0]
255
0
Page 15
Page 1
Page 0
Page 15
Page 1
Page 0
7
0
Addr[7:0] = Row[7:0]
Fig. 5.43 Flash memory organization
5.3
Electrically-Erasable-Programmable-Read-Only-Memory
209

throughout the manuscript when describing Flash memory operations. Many Flash data-
sheets use the term, program, to deﬁne writing a byte or a block of data to Flash memory.
The active-low Enable input, EN, activates a particular page in the Flash memory to prepare
it for an upcoming operation. The active-low Read Enable input, RE, activates the Read/Write
interface to read data from the memory. The active-low Write Enable input, WE, enables to
write (program) data to the memory. The active-low Reset input, Reset, is used for resetting
the hardware. After this command, Flash memory automatically goes into the read mode.
Typical Flash memory architecture, much like the other memory structures we have
examined earlier, consists of a memory core, address decoder, sense ampliﬁer, data buffer
and control logic as shown in Fig. 5.44. When a memory operation starts, the control logic
enables the address decoder, the address register, and the appropriate data buffers in order to
activate the read or the write data-path. The address in the address register is decoded to
point the location of data in the memory core. If a read operation needs to be performed, the
retrieved data is ﬁrst stored in the data buffer, and then released to the bus. If the operation
calls for a write, the data is stored in the data buffer ﬁrst, and then directed to the designated
address in the memory core. The standby mode neither writes to the memory nor reads from
it. The hibernation mode disables the address decoder, memory core and data buffer to
reduce power dissipation. The main Flash operation modes are tabulated in Fig. 5.45.
WE
RE
Reset
EN
Control
Logic
Address Decoder
Sector 15
Data Buffer
Sector 14
Sector 0
Address Register
Address[15:0]
I/O[7:0]
High voltage
Fig. 5.44 Flash memory architecture
210
5
Memory Circuits and Systems

The Flash memory cell shown in Fig. 5.34 is the basic storage element in the Flash
memory core. It is an N-channel MOS transistor with a ﬂoating gate whose sole purpose is to
store electronic charge. The device needs high voltages well above the power supply voltage
to create and transfer electrons back and forth to the ﬂoating gate according to the need. If
there is no secondary high voltage supply for this job, the control logic in Fig. 5.44 may
contain a charge pump circuit composed of a constant current source and a capacitor in order
to obtain a higher DC voltage from the primary power supply for a short duration. As the
constant current charges the capacitor, the voltage across the capacitor rises linearly with
time, ultimately reaching a high DC potential to create electron-hole pairs near the Bitline
contact (drain) of the device, ultimately causing the electrons to tunnel to the ﬂoating gate.
The mechanism of electron tunneling to the ﬂoating gate requires time. Therefore, a write or
erase operation may take many consecutive clock cycles compared to simple control
operations such as suspend or resume.
Figure 5.46 shows the basic read operation provided that data has already been transferred
from the memory core to the data buffer. Once a valid address is issued, data is produced at
the I/O terminal some time after the falling edge of the Read Enable signal, RE. Data is held
at the I/O port for a period of hold time, th, following the rising edge of RE as shown in the
timing diagram below. The actual read operation takes about four clock cycles as the entire
data retrieval process from the memory core takes time. This involves sensing the voltage
level at the Flash cell, amplifying this value using the sense ampliﬁer, and propagating the
data from the sense ampliﬁer to the data buffer.
In contrast to read, the basic write operation follows the timing diagram of Fig. 5.47. In
this ﬁgure, a valid address must be present at the address port when the Enable and the Write
Enable signals, EN and WE, are both at logic 0. Valid data satisfying the setup and hold
times, ts and th, is subsequently written to the data buffer. The actual write process can take
up to four clock cycles due to the data propagation from the I/O port to the data buffer, and
then from the data buffer to the Flash cell.
EN
RE
WE
reset
0
0
1
1
Read
0
1
0
1
Write
0
1
1
1
Standby
Hibernate
Hardware reset
1
X
X
1
X
X
X
0
MODE
Fig. 5.45 Main modes of Flash memory
5.4
Flash Memory
211

Disabling the I/O port for read or write, and therefore putting the device in standby mode
requires EN signal to be at logic 0 as shown in Fig. 5.48. The I/O port will ﬂoat and show
high impedance (Hi-Z).
Addr
Address
EN
RE
WE
Data
I/O[7:0]
th
tacc
tcommand
Reset
Fig. 5.46 Basic read operation timing diagram
Addr
Address
EN
RE
WE
Data
th
ts
tcommand
Reset
I/O[7:0]
Fig. 5.47 Basic write (program) operation timing diagram
212
5
Memory Circuits and Systems

Hardware reset requires only lowering the Reset signal during the command cycle as
shown in Fig. 5.49. The actual reset operation takes three bus cycles and resets the entire
Flash memory.
Basic Flash memory operations are tabulated in Fig. 5.50. In actuality, there are a lot more
commands in commercially available Flash memories than what is shown in this table. This
section considers only essential byte-size operations in a Flash memory. Word-size
Addr
Address
EN
RE
WE
tcommand
Reset
Hi-Z
I/O[7:0]
Fig. 5.48 Basic standby operation
Addr
Address
EN
RE
WE
tcommand
Reset
X
X
X
Hi-Z
I/O[7:0]
Fig. 5.49 Basic hardware reset operation timing diagram
5.4
Flash Memory
213

Read
Write
0x5555
0xAA
0xAAAA
0x55
0x5555
0x00
Write suspend
Write resume
Chip erase
Page erase
Page erase suspend
Page erase resume
Page protect
Fast write set
Fast write
Fast write reset
Read Addr
Read Data
0x5555
0xAA
0xAAAA
0x55
0x5555
0x20
Write Addr
Write Data
Page Addr
0x30
Addr
Data
Addr
Data
Addr
Data
Addr
Data
MAIN COMMANDS
Page Addr
0x40
0x5555
0xAA
0xAAAA
0x55
0x5555
0x50
0x5555
0xAA
0xAAAA
0x55
0x5555
0x60
0x5555
0xAA
0xAAAA
0x55
0x5555
0x50
0x5555
0xAA
0xAAAA
0x55
Page Addr
0x70
Page Addr
0x80
Page Addr
0x90
Page Addr
0xA0
Page Addr
0xA0
Page Addr
0xA0
Page Addr
Verif. Code
0x5555
0xAA
0xAAAA
0x55
0x5555
0xB0
0xXXXX
0xC0
Write Addr
Write Data
0xXXXX
0xD0
0xXXXX
0xE0
CYCLE 1
CYCLE 2
CYCLE 3
CYCLE 4
CYCLE 5
CYCLE 6
ID Read
0x5555
0xAA
0xAAAA
0x55
0x5555
0x10
Manuf. Addr
Manuf. Data
Device Addr
Device Data
Reset
0x5555
0xAA
0xAAAA
0x55
0x5555
0xF0
Fig. 5.50 Flash memory commands with required clock cycles
214
5
Memory Circuits and Systems

operations, very speciﬁc Flash command sequences, such as hidden ROM programs, query
and veriﬁcation commands and boot protection processes are avoided in order to emphasize
the core Flash memory operations for the reader. Address and data entries for each speciﬁc
command in Fig. 5.50 are also modiﬁed compared to the actual datasheets to simplify the
read, write (program) and erase sequences. The number of clock cycles, the address and data
preamble values in each cycle, and the operational codes to perform read, write, page erase,
chip erase, page protect, fast write and other modes of operation may be different from the
actual datasheets.
The ﬁrst task in Fig. 5.50 is the Flash memory read sequence which takes four clock
cycles. The ﬁrst three clock cycles of this sequence represents the waiting period to prepare
the read path from the memory core. During this period, address and data values in the form
of alternating combinations of 1s and 0s, such as 0x5555/0xAA and then 0xAAAA/0x55,
are introduced at the address and data ports of the Flash memory as shown in Fig. 5.51. Once
the read command, 0x00, is issued in the third clock cycle, a byte of data becomes available
shortly after the negative edge of the RE signal in the fourth and ﬁnal clock cycle.
Addr
0x5555
EN
RE
WE
0xAAAA
0x5555
Addr
0xAA
0x55
0x00
Data
Cycle 1
Cycle 2
Cycle 3
Cycle 4
Read command
Read data
I/O[7:0]
Fig. 5.51 Timing diagram for read operation
5.4
Flash Memory
215

Figure 5.52 shows an example of the read operation which extracts the manufacturer’s ID
and device ID from the Flash memory. The ﬁrst three clock cycles of this sequence are the
same as the normal read operation, but with the exception of the ID read code, 0x10. The
next two cycles deliver the manufacturer’s ID and the device ID following the negative edge
of the RE signal.
There are basically two types of write (program) operations for the Flash memory: auto
write (program) and fast write (program). Figure 5.53 explains the auto write sequence
where the ﬁrst three cycles are the same as the read sequence with the exception of the auto
write command code, 0x20, in the third clock cycle. In the fourth cycle, a valid address and a
data are entered to the device when EN and WE are both lowered to logic 0. The valid data is
subsequently written to the speciﬁed address at the positive edge of WE. The data written to
the Flash memory can be retrieved in the following cycle without going through a separate
read sequence. This is called the auto write veriﬁcation step, and the most recent written data
becomes available at the I/O port as soon as RE is lowered to logic 0.
Addr
0x5555
EN
RE
WE
0xAAAA
0x5555
Man Addr
Dev Addr
0xAA
0x55
0x10
Man Data
Dev Data
Cycle 1
Cycle 2
Cycle 3
Cycle 4
Cycle 5
ID read command
Manufacturer 
ID read
Device ID 
read
I/O[7:0]
Fig. 5.52 Timing diagram for ID read operation
216
5
Memory Circuits and Systems

The write sequence can be suspended or resumed depending on the need. Both operations
take only one clock cycle with the appropriate suspend and resume codes as shown in
Figs. 5.54 and 5.55, respectively. The write suspend and resume codes can be read in the
second cycle as a veriﬁcation step.
Addr
0x5555
EN
RE
WE
0xAAAA
0x5555
Write Addr
0xAA
0x55
0x20
Write Data
Write Addr
Write Data
Write command
Write Data
Verification
Cycle 1
Cycle 2
Cycle 3
Cycle 4
I/O[7:0]
Fig. 5.53 Timing diagram for write (program) operation
Addr
Page Addr
EN
RE
WE
Page Addr
0x30
Suspend comm.
Write suspend 
command
Verification
Cycle 1
I/O[7:0]
Fig. 5.54 Timing diagram for write (program) suspend operation
5.4
Flash Memory
217

The erase operation can be applied either to the entire chip or to a particular page. Both
sequences take six clock cycles because of the lengthy nature of erase process. In the auto
chip erase operation, the ﬁrst three and the last three cycles are almost identical except the
two new codes, 0x50 and 0x60, are introduced in the third and in the sixth cycles as shown
in Fig. 5.56.
Addr
Page Addr
EN
RE
WE
Page Addr
0x40
Resume comm.
Write resume 
command
Verification
Cycle 1
I/O[7:0]
Fig. 5.55 Timing diagram for write (program) resume operation
Addr
0x5555
EN
RE
WE
0xAAAA
0x5555
0xAA
0x55
0x50
Chip erase command
Cycle 1
Cycle 2
Cycle 3
0xAAAA
0x5555
0x5555
0xAA
0x55
0x60
Cycle 4
Cycle 5
Cycle 6
I/O[7:0]
Fig. 5.56 Timing diagram for chip erase operation
218
5
Memory Circuits and Systems

The ﬁrst ﬁve clock cycles of the page erase operation are identical to the chip erase as
shown in Fig. 5.57. The page address to be erased is supplied with the page erase command,
0x70, in the sixth cycle.
A certain Flash memory page can be protected from being overwritten or erased by
issuing a page protect operation. This is a three-cycle operation as shown in Fig. 5.58. In all
three cycles, the page address and the page protect code, 0x0A, have to be speciﬁed.
Addr
0x5555
EN
RE
WE
0xAAAA
0x5555
0xAA
0x55
0x50
Page erase command
Cycle 1
Cycle 2
Cycle 3
0xAAAA
Page Addr
0x5555
0xAA
0x55
0x70
Cycle 4
Cycle 5
Cycle 6
Page Addr input 
I/O[7:0]
Fig. 5.57 Timing diagram for page erase operation
Addr
Page Addr
EN
RE
WE
Page Addr
Page Addr
0xA0
0xA0
0xA0
Page protect command
Cycle 1
Cycle 2
Cycle 3
Page Addr
Protect com
Verification
I/O[7:0]
Fig. 5.58 Timing diagram for page protect operation
5.4
Flash Memory
219

If faster writing speed is required from the Flash memory, the fast write (program)
sequence can be used. This sequence is composed of three parts: fast write set, fast write and
fast write reset. The fast write set and reset codes are entered at the beginning and at the end
of a write sequence. Figure 5.59 shows the timing diagram for the fast write set sequence
where the set code, 0xB0, is entered in the third clock cycle.
The timing diagram for the fast write is a two-cycle sequence as shown in Fig. 5.60. In the
ﬁrst cycle, the fast write code, 0xC0, is entered. In the second cycle, a valid address/data pair
is entered at the positive edge of WE.
Addr
0x5555
EN
RE
WE
0xAAAA
0xAA
Cycle 1
Cycle 2
Fast write set command
0x5555
0x55
0xB0
Cycle 3
I/O[7:0]
Fig. 5.59 Timing diagram for fast write (program) set operation
Addr
0xXXXX
EN
RE
WE
Write Addr
0xC0
Cycle 1
Cycle 2
Fast write command
Write Data
I/O[7:0]
Fig. 5.60 Timing diagram for fast write (program) operation
220
5
Memory Circuits and Systems

The fast write reset sequence shown in Fig. 5.61 is also a two-cycle process with two fast
write termination codes, 0xD0 and 0xE0, entered in two consecutive clock cycles.
Device reset can be initiated either by Reset input in Fig. 5.48 or by entering the reset
code, 0xF0, in the third clock cycle of Fig. 5.62.
Addr
0xXXXX
EN
RE
WE
0xXXXX
0xD0
Cycle 1
Cycle 2
Fast write reset command
0xE0
I/O[7:0]
Fig. 5.61 Timing diagram for fast write (program) reset operation
Addr
0x5555
EN
RE
WE
0xAAAA
0x5555
0xAA
0x55
0xF0
Reset command
Cycle 1
Cycle 2
Cycle 3
I/O[7:0]
Fig. 5.62 Timing diagram for Reset operation
5.4
Flash Memory
221

Both reading and writing (programming) data are cyclic processes. This means that a loop
has to be established in the user program to generate a series of memory addresses to read or
write data.
Figure 5.63 shows the auto write (program) ﬂow chart where a loop is created to generate
the next write address. Each box in the ﬂow chart corresponds to a clock cycle. The ﬁrst
three boxes of the ﬂow chart prepare the memory core for a write operation. The preparation
period terminates with the auto write code, 0x20, as mentioned earlier in Fig. 5.53. After
entering the ﬁrst write address and data, the memory address is incremented in the fourth
cycle. The same process repeats itself prior to issuing the next address and data. When the
ﬁnal address is reached, the write process simply terminates.
Start
0x5555/0xAA
0xAAAA/0x55
0x5555/0x20
Write Addr/
Write Data
Last Addr
Addr = Addr + 1
NO
YES
Complete
Write
sequence
Fig. 5.63 Flow chart for write (program)
222
5
Memory Circuits and Systems

The sequence of events is a little different for the fast write (program) in Fig. 5.64. The
fast write phase starts with the three-cycle long fast write set sequence followed by the two
cycle long fast write sequence. The memory address keeps incrementing until the last data
byte is written to the core. The fast write process ends with the two-cycle long fast write reset
sequence.
Auto write and fast write processes can be interrupted or resumed by issuing one-cycle
long suspend and resume commands anytime during the write process.
Start
0x5555/0xAA
0xAAAA/0x55
0x5555/0xB0
0xXXXX/0xC0
Write Addr/
Write Data
Last Addr
Addr = Addr + 1
0xXXXX/0xD0
0xXXXX/0xE0
NO
YES
Complete
Fast write set
sequence
Fast write
sequence
Fast write reset
sequence
Fig. 5.64 Flow chart for fast write (program)
5.4
Flash Memory
223

In the following sections, we will demonstrate how to design three individual I2C bus
interfaces with Flash memory to perform read, write and erase operations. In each design, we
will assume only one mode of operation to simplify the design process. After studying each
design example, the reader is encouraged to design a single interface that integrates all three
operations.
Design Example 1:
I2C Fast Write (Program) Interface for Flash Memory
The following design example constructs only the I2C fast write (program) interface for a
Flash memory that has parallel address and data ports as shown in Fig. 5.44 using a modiﬁed
seven-bit address mode. No read, auto write, erase, page protect, reset or other modes are
included in this design for the sake of simplicity.
Before dealing with the design details and methodology, it may be prudent to review the
timing diagram of I2C write sequence using the seven-bit addressing mode. Although
Fig. 5.65 includes only one byte of data, it describes the entire write protocol for the
seven-bit address mode in Fig. 4.22. This diagram also includes the start and the stop
conditions in Fig. 4.23, and when data (or address) is allowed to change in Fig. 4.24. After
generating the start condition, the bus master delivers a seven-bit slave address, starting from
the most signiﬁcant bit, A6. The address sequence is followed by the write bit at logic 0.
Once the slave receives the seven-bit address and the write command, it produces an
acknowledgment, ACK, by lowering the SDA bus to logic 0. The master detects the ACK
signal, and sends out an eight-bit data starting from the most signiﬁcant bit, D7. Once the
entire byte is received, the slave responds with another ACK. More data packets follow the
same routine until the master generates the stop condition.
A6
A5
A0
W = 0
D7
D0
ACK
D6
ACK
STOP
START
SCL
SDA
A6
A5
A0
W
ACK
D7
D6
D0
ACK
I2C
reads
I2C
ACK
I2C
reads
I2C
reads
I2C
reads
Master
reads
Master
sends
Master
sends
Master
sends
Master
sends
Master
sends
Master
sends
I2C
reads
I2C
reads
Master 
sends
I2C
reads
I2C
ACK
Master
reads
Fig. 5.65 A simple timing diagram for I2C write (program) using seven-bit address mode
In Fig. 5.65, the names that appear on top of each SCL cycle describe a distinct state. If a
state machine needs to be constructed from this timing diagram, we simply assign an
independent state that corresponds to each name in Fig. 5.65 and produce a state diagram in
Fig. 5.66. In this diagram, the start condition activates the state machine, which goes through
the address and the command sequences before the data. As long as the state machine does
224
5
Memory Circuits and Systems

not detect any stop condition, it constantly traces the data states D7 to D0. However, when
there is a stop condition, the state machine goes to the IDLE state and waits for another start
condition to emerge.
Even though this example only shows the fast write interface, it sets up a solid foundation
of how to design any typical I2C interface between a bus master and a Flash memory. The
ﬁrst step of the design process is to create a rough interface block diagram showing all the
major I/O ports between the Flash memory and the I2C bus as shown in Fig. 5.67. For the
fast write sequence, the address and data packets are serially transferred to the interface
through the SDA port. However, the Flash memory needs the address and data ﬁelds all at
once. Therefore, the write operation requires the interface to perform serial-to-parallel
conversion of incoming data. The interface also needs to produce two control signals, EN
and WE, for the fast write sequence, and the control signal, EnDataOut, for writing an
eight-bit data to a designated Flash memory address.
IDLE
A6
A0
W
ACK
D7
D0
ACK
START = 1
START = 0
STOP = 1
STOP = 0
Fig. 5.66 The state diagram for the simple I2C write (program) in Fig. 5.65
5.4
Flash Memory
225

Figure 5.68 shows the architectural block diagram of the Flash memory interface for the
fast write operation. As mentioned earlier when designing SRAM and SDRAM memory
interfaces, creating a complete data-path for an interface is not a single-step process. The
design methodology requires building a simple data-path with all of its functional units and a
corresponding timing diagram showing the ﬂow of data in each clock cycle, the start and stop
conditions, address and data formations. However, as more detail is added to the architecture,
the initial timing diagram also becomes more complex to match the architecture. Figures 5.69,
5.70 and 5.71 show a set of timing diagrams related to the architecture in Fig. 5.68. These
diagrams describe the start and stop conditions, preamble sequence, address and data for-
mations, repacking and delivery of serial address and data in a systematic manner.
Once the cycle-by-cycle nature of address and data entries are accurately described in the
timing diagram, the control signals responsible for routing the address and data can be added
to the diagram. The ﬁnal step of the design process is to assign distinct states to each clock
cycle in the timing diagram that contains different sets of control signals in order to generate
a Moore-type state machine.
To start, we need to include four functional units in Fig. 5.68 to be able to handle a simple
fast write operation. The ﬁrst functional unit is an eight-bit shift register whose sole purpose is
to convert the incoming serial data from the SDA port into a parallel form. If the fast-write
process requires an authentication step prior to data exchange, the ﬁrst eight-bit packet
coming to this interface must be delivered to the device ID register, which is considered the
second functional unit. The second and the third eight-bit data packets arriving at the interface
belong to the most and the least signiﬁcant bytes of the 16-bit starting Flash memory address,
respectively, and they are stored in the address counter. The address counter, which consti-
tutes the third functional unit, uses this initial address to generate subsequent addresses for
programming the Flash memory. All eight-bit data that follows the address entry is routed
directly to the data port of the Flash memory. There are also several ﬁxed-value registers
connected to the inputs of the address and data MUXes in Fig. 5.68. These registers contain
SDA
EN
WE
Addr [15:0]
DataI/O [7:0]
16
I/O [7:0]
EnDataOut
Flash 
Fast Write 
I/F
8
SCL
Fig. 5.67 Simpliﬁed page diagram of the I2C fast write (program) interface
226
5
Memory Circuits and Systems

the preamble data for setting and resetting the fast write modes for the Flash memory prior to
address and data sequences. The write controller, which is considered to be the fourth
functional unit, generates all the control signals necessary for storing data, incrementing the
address, and routing the address and data to the output ports of the interface. The host
processor delivers all address, control and data signals to the interface at the negative edge of
the SCL, which requires all the registers to operate at the positive edge of SCL in Fig. 5.68.
Device ID + W
0
Address Counter
15
0
Shift Reg
7
0
LoadAddrLSB
LoadAddrMSB
IncrAddr
0x5555
15
0
0xAAAA
15
0
16
16
16
selAddr
selAAAA
sel5555
AddrRegOut
0
1
2
Addr[15:0]
0xAA
7
0
0x55
7
0
0xB0
7
0
0xC0
7
0
0xD0
7
0
0xE0
7
0
0
1
2
3
4
5
6
8
8
8
8
8
8
8
DataI/O [7:0]
selData
selAA
sel55
selB0
selC0
selD0
selE0
SCL
LoadDevID
shift
LoadDevID
IncrAddr
sel5555
selAAAA
selAddr
selAA
sel55
selB0
selC0
selD0
selE0
selData
EnDataOut
shift
SCL
SCL
SCL
SCL
LoadAddrLSB
LoadAddrMSB
EN
WE
Write
Controller
shiftRegOut
SDA
I/O[7:0]
EnDataOut
EnSDAOut
8
8
7
W
SCL
MSB
0
1
SCL
SCLMaster
SCLAux
selAux
SCL
SDA
Detector
START
STOP
START
STOP
EnSDAOut
Address MUX
Data MUX
Fig. 5.68 I2C fast write (program) interface data-path
5.4
Flash Memory
227

The START condition in Fig. 5.69 is produced by the bus master in cycle 1 by lowering
the SDA signal to logic 0 while keeping the SCL signal at logic 1. Once the START
condition is detected, the serial data on the SDA port is transferred to an eight-bit shift
register which converts this data into a parallel form before sending it to different registers in
Fig. 5.68. In clock cycles 2 to 8, the seven-bit Flash memory ID is loaded to the shift register
starting from the most signiﬁcant bit if device authentication is required prior to data
transmission. In cycle 9, the bus master sends the write bit, W, stored in the shift register. In
cycle 10, a number of events take place simultaneously. First, the write bit at the least
signiﬁcant bit position of the shift register activates the write controller. Second, the device
ID and the write bit are transferred from the shift register to a special device ID register.
Third, the Flash memory interface produces the ﬁrst acknowledge signal, ACK, by
EnSDAOut = 1, thus lowering the SDA bus to logic 0. Finally, the interface sends the ﬁrst
preamble which consists of the address, 0x5555, and the data, 0xAA, to the Flash memory
and lowers EN and WE to logic 0 as the ﬁrst step of the fast write set.
In cycle 11, the most signiﬁcant bit of the 16-bit initial Flash memory address, Add15, is
received from the SDA bus and stored in the shift register. This cycle is also considered a
hold period for the EN and WE signals. In cycle 12, the second most signiﬁcant address bit,
Add14, is stored in the shift register. In this cycle, the second preamble that contains the
address, 0xAAAA, and the data, 0x55, are sent to the Flash memory as the second step of the
fast write set. In cycle 14, the third address and command preamble, 0x5555 and 0xB0, are
sent to the Flash memory, completing the fast write set sequence. The fast write sequence
starts at cycle 16 where the fast write command, 0xC0, is sent to the Flash memory. In cycle
19, the most signiﬁcant byte of the 16-bit starting Flash memory address, StAddMSB, is
transferred from the shift register to the address register which resides inside the address
counter. In this cycle, the interface also generates the second ACK signal by EnSDAOut = 1.
From cycles 20 to 27 in Fig. 5.70, the least signiﬁcant byte of the starting Flash address,
StAddLSB, is received by the shift register. In cycle 28, this byte is transferred to the least
signiﬁcant byte of the address register in order to form the 16-bit starting Flash address. In this
cycle, the interface generates the third ACK signal. From cycles 29 to 36, the ﬁrst set of data
bits starting from the most signiﬁcant bit, DF7, to the least signiﬁcant bit, DF0, are received by
the shift register. In cycle 37, the ﬁrst eight-bit data packet, Data0, is transferred to the Flash
memory through its bidirectional I/O port. The tri-state buffers in Fig. 5.68 need to be enabled
by the control signal, EnDataOut, to be able write this data packet to the Flash memory.
Cycles 38 to 45 in Fig. 5.71 are used to store the second eight-bit data packet in the shift
register. Cycle 46 transfers this data packet, Data1, to the I/O port and generates an ACK
signal for receiving the second data byte from the bus master. If the STOP condition is
detected during the next clock cycle, the fast write process halts. The write controller goes into
the fast write reset mode and asynchronously produces selAux = 1 to engage the auxiliary
clock, SCLAux, instead of using the main SCL clock, SCLMaster, generated by the bus
228
5
Memory Circuits and Systems

SCL
SDA
shiftRegOut
Addr
EN
WE
shift
LoadDevID
LoadAddMSB
LoadAddLSB
IncrAddr
sel5555
selAAAA
selAddr
selB0
selC0
selD0
selE0
sel55
selAA
selData
EnDataOut
11
12
13
14
15
16
17
18
DAdd6
DAdd5
DAdd4
DAdd3
DAdd2
DAdd1
DAdd0
ACK
Add15
Add14
Add13
Add12
Add11
Add10
Add9
Add8
ACK
1
2
3
4
8
9
10
DevID
0x5555
HOLD
0xAAAA
HOLD
0x5555
HOLD
0xAA
0x55
0xB0
0xC0
EnSDAOut
W
19
START
selAux
I/O[7:0]
5
6
7
DevID+W
0xXXXX
StAddMSB
Fig. 5.69 I2C fast write (program) set sequence with device ID and memory address
5.4
Flash Memory
229

selAux
SCL
SDA
shiftRegOut
Addr
EN
WE
shift
LoadDevID
LoadAddMSB
LoadAddLSB
IncrAddr
sel5555
selAAAA
selAddr
selB0
selC0
selD0
selE0
sel55
selAA
selData
EnDataOut
30
31
32
33
34
35
36
37
38
Add7
ACK
DF7
DF6
DF5
DF4
DF3
DF2
DF1
DF0
ACK
D7
20
21
22
23
24
25
26
27
28
29
Add6
Add1
Add0
Data0
StAdd
Data0
EnSDAOut
I/O[7:0]
StAddLSB
Fig. 5.70 I2C fast write (program) sequence
230
5
Memory Circuits and Systems

selAux
SCL
SDA
shiftRegOut
Addr
EN
WE
shift
LoadDevID
LoadAddMSB
LoadAddLSB
IncrAddr
sel5555
selAAAA
selAddr
selB0
selC0
selD0
selE0
sel55
selAA
selData
EnDataOut
49
50
51
52
53
54
55
56
57
D6
D5
D4
D3
D2
D1
D0
39
40
41
42
43
44
45
46
47
48
Data1
Data1
HOLD
HOLD
0xD0
0xE0
EnSDAOut
STOP
I/O[7:0]
StAdd+1
0xXXXX
0xXXXX
ACK
Fig. 5.71 I2C fast write (program) reset sequence
5.4
Flash Memory
231

master. This is because the Flash memory needs two more preambles that contain 0xD0 and
0xE0 commands to complete the fast write reset sequence. Therefore, starting from cycle 48,
SCL resumes with three more cycles. In cycle 48, the ﬁrst preamble that contains 0xD0, and in
cycle 50 the second preamble that contains 0xE0 are sent to the Flash memory by setting
selD0 and then selE0 to logic 1, respectively. In the next cycle, selAux becomes logic 0, and
SCL switches back to the SCLMaster input which permanently stays at logic 0.
The Moore machine in Fig. 5.72 implements the write controller in Fig. 5.68. At the onset
of the START condition, the controller wakes up and goes into the device ID retrieval mode.
From cycles 2 to 8 in Fig. 5.69, the serial device ID is received by the shift register on the
SDA bus. These cycles correspond to the states DAdd6 to DAdd0 in Fig. 5.72 where the
shift signal is constantly kept at logic 1, and writing data to the Flash memory is disabled. In
cycle 9, the write bit is also stored in the shift register. This corresponds to the W state in the
state machine. In cycle 10, numerous events take place simultaneously. First, shifting serial
data into the shift register stops by shift = 0. Second, the seven-bit device ID and the write bit
are delivered to the device ID register by LoadDevID = 1. Third, the ﬁrst address and data
preamble, 0x5555 and 0xAA, is delivered to the Flash memory through port 1 of the address
MUX by sel5555 = 1 and port 1 of the data MUX by selAA = 1. Fourth, the control signals,
EN and WE, are lowered to logic 0 in order to write the address and data preamble to the
Flash memory. Finally, an ACK signal is generated by EnSDAOut = 1. This cycle corre-
sponds to the DevID ACK state of the write controller.
In cycle 11, shifting data resumes, and the shift register receives the most signiﬁcant bit of
the initial Flash address, Add15, while in the Add15 state. In cycle 12, which corresponds to
the Add14 state, the second most signiﬁcant address bit, Add14, is latched in the shift
register by shift = 1. In the same cycle, the second address and data preamble, 0xAAAA and
0x55, is delivered to the Flash memory through port 2 of the address MUX by selAAAA = 1
and port 2 of the data MUX by sel55 = 1. The control signals, EN and WE, are also lowered
to logic 0 in order to write this preamble to the Flash memory. In cycle 13, Add13 is stored
in the shift register. This cycle corresponds to the Add13 state. In cycle 14, the third address
and data preamble, 0x5555 and 0xB0, is written to the Flash memory through port 1 of the
address MUX by sel5555 = 1 and port 3 of the data MUX by selB0 = 1. In this cycle, the
control signals, EN and WE, are lowered to logic 0 in order to write the last address and data
preambles. This cycle corresponds to the Add12 state. Cycle 15 designates the end of the fast
write set cycle, and corresponds to the Add11 state when the address bit, Add11, is loaded to
the shift register.
232
5
Memory Circuits and Systems

DAdd0
DAdd6
DevID
ACK
Add15
Add14
Add13
Add12
Add11
Add10
Add9
Add8
AddMSB
ACK
Add7
Add0
AddLSB
ACK
DF7
DF0
0xD0
HOLD
0xE0
IDLE
START = 0
START = 1
shift = 1
EN = 1
WE = 1
shift  = 0
EnSDAOut = 1
EnDataOut = 1
LoadDevID = 1
sel5555 = 1
selAA = 1
EN = 0
WE = 0
shift = 1
EnDataOut = 1
sel55 = 1
selAAAA = 1
EN = 0
WE = 0
shift = 1
EN = 1
WE = 1
shift = 1
EnDataOut = 1
selB0 = 1
sel5555 = 1
EN = 0
WE = 0
shift = 1
EN = 1
WE = 1
shift = 1
EnDataOut = 1
selC0 = 1
EN = 0
WE = 0
shift = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
shift = 0
EnSDAOut = 1
LoadAddMSB = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
shift = 0
EnSDAOut = 1
LoadAddLSB = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
shift = 0
EnDataOut = 1
selD0 = 1
selAux = 1
EN = 0
WE = 0
shift = 0
selAux = 1
EN = 1
WE = 1
shift = 0
EnDataOut = 1
selE0 = 1
selAux = 1
EN = 0
WE = 0
shift = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
STOP = 0
STOP = 1
W
shift = 1
EN = 1
WE = 1
D7
D0
shift = 1
EN = 1
WE = 1
shift = 1
IncrAddr = 1
EN = 1
WE = 1
Data 
ACK
shift = 0
EnSDAOut = 1
selAddr = 1
selData = 1
EnDataOut = 1
EN = 0
WE = 0
Fig. 5.72 I2C fast write (program) interface controller
5.4
Flash Memory
233

Cycle 16 enters the fast write command mode and writes the address and data preambles,
0xXXXX and 0xC0, through port 4 of the data MUX by selC0 = 1. In this cycle, EN and
WE signals are lowered to logic 0 to accommodate the write operation, and Add10 is latched
in the shift register. This clock cycle corresponds to the Add10 state. Storing the higher byte
of the initial Flash address becomes complete by the end of cycle 18. In cycle 19, the higher
byte of the initial address is transferred to the address register by LoadAddMSB = 1, and an
acknowledge signal is generated by EnSDAOut = 1. This cycle corresponds to the
AddMSB ACK state in the state diagram. Similar events take place when storing the least
signiﬁcant byte of the starting address in the shift register. These states are marked as Add7
to Add0 in the state diagram, and correspond to the cycles 20 though 27, respectively. The
cycle 28, which corresponds to the AddLSB ACK state, generates the third acknowledge for
the bus master by EnSDAOut = 1, and transfers the least signiﬁcant byte of the starting Flash
memory address to the address register by LoadAddLSB = 1.
From cycles 29 to 36, the ﬁrst set of data bits are delivered to the shift register starting from
the most signiﬁcant data bit, DF7. This sequence is shown as the states DF7 to DF0 in the
state diagram. In cycle 37, an acknowledgement is sent to the bus master by EnSDAOut = 1
shown as the Data ACK state. During this period, the initial 16-bit address and eight-bit data
are delivered to the Flash memory through port 0 of the address MUX by selAddr = 1 and
port 0 of the data MUX by selData = 1. Tri-state buffer at the I/O port is also enabled by
EnDataOut = 1. The second data byte is received during cycles 38 to 45, which correspond to
the states D7 to D0, respectively. Cycle 45 is also the cycle to increment the Flash memory
address by issuing IncrAddr = 1. In Cycle 46, the write controller goes into the Data ACK
state once again and issues an acknowledgement for receiving the second data packet by
EnSDAOut = 1. In this cycle, the second data packet is delivered to the incremented Flash
memory address, StAdd + 1, by selAddr = 1, selData = 1 and EnDataOut = 1. As long as the
STOP condition is not detected, data packets are delivered to the Flash memory at each
incremented address. However, if the bus master issues a STOP condition, the auxiliary SCL
generator, SCLAux, is asynchronously enabled within the same cycle by selAux = 1. The
write controller goes into the fast write reset mode in the next clock cycle and keeps the
auxiliary SCL generator enabled by selAux = 1. For the next three clock cycles, the 0xD0 and
0xE0 command codes, corresponding to the 0xD0 and 0xE0 states in the state diagram, are
delivered to the Flash memory through port 5 of the data MUX by selD0 = 1 and port 6 of the
data MUX by selE0 = 1.
234
5
Memory Circuits and Systems

Design Example 2:
I2C Read Interface for Flash Memory
The following design example constructs only the I2C read interface for a Flash memory that
has parallel address and data ports shown in Fig. 5.44 using a modiﬁed seven-bit address
mode. No other modes are included in this design except the read.
The timing diagram for I2C read sequence is given in Fig. 5.73 where each eight-bit data
packet is serially read from a slave after issuing an initial seven-bit address. The address sent
by the bus master requires an acknowledgment (ACK) from the slave. In contrast, data
packets sent by the slave require the master’s acknowledgment. If the bus master chooses not
to acknowledge the receipt of data (NACK), the data transfer stops in the next cycle.
Figure 5.74 shows the sequence of events taking place in Fig. 5.73 in the form of a state
diagram where the logic level in Master ACK/NACK state determines the continuation or
the end of the data transfer.
The Flash memory read sequence described in Fig. 5.75 is a four-cycle process as
mentioned earlier in Fig. 5.50. The bus master sends the address and data preambles,
0x5555/0xAA and 0xAAAA/0x55, in the ﬁrst two cycles. This is followed by the
0x5555/0x00 preamble containing the read command code in the third cycle. All three cycles
can be considered a preparation period for a read operation which takes place in the fourth
cycle. Following the read operation, the address is incremented either by one or a predeﬁned
value according to the Flash memory address generation protocol before the next data read
sequence takes place.
To read data from the Flash memory, the address and command entries are serially sent by
the host processor to the I2C interface through the SDA port. The Flash memory requires a
A6
A5
A0
R = 1
D7
D0
ACK
D6
Master
NACK
STOP
START
SCL
SDA
A6
A5
A0
R
ACK
D7
D6
D0
NACK
I2C
reads
I2C
ACK
I2C
reads
Master
reads
Master
sends
Master
sends
Master
sends
I2C
reads
Master
sends
I2C
reads
Master
sends
Master
sends
I2C
reads
I2C
reads
Master
sends
Master
sends
I2C
reads
I2C
reads
Fig. 5.73 A simple timing diagram for the I2C read operation using seven-bit address mode
5.4
Flash Memory
235

16-bit address all at once in order to read an eight-bit data, and this necessitates an interface
to perform both serial-to-parallel and parallel-to serial conversions. The interface has to
produce three active-low control signals, EN, WE and RE, to be able to read data from the
Flash memory. It also needs to produce the control signals, EnDataIn and EnDataOut, to
route the incoming and outgoing data.
IDLE
A6
A0
R
D7
D0
START = 1
START = 0
SDA = 1
SDA = 0
Slave
ACK
Master
ACK/NACK
Fig. 5.74 The state diagram for the simple I2C read operation in Fig. 5.73
236
5
Memory Circuits and Systems

Figure 5.76 shows the architectural diagram of the Flash memory read interface. Figures
5.77, 5.78 and 5.79 show the timing diagrams related to this architecture. These waveforms
describe a complete picture of the preamble formation, device ID creation, address gener-
ation and serializing the read data from the Flash memory.
The architecture in Fig. 5.76 still contains four functional units as in the fast write
(program) data-path. The ﬁrst functional unit is an eight-bit shift register which identiﬁes the
serial address, command and data boundaries, and converts the serial data on the SDA bus
into a parallel form and the parallel data from the Flash memory into a serial form. The
second functional unit stores the device ID if the Flash memory requires an identiﬁcation
process prior to data exchange, and the command bit. The third unit stores the initial 16-bit
Flash memory address and generates the subsequent memory addresses using an up-counter.
The fourth unit is the read controller, which is responsible for storing the device ID, the
command bit, forming and incrementing the initial address, and handling the proper
data-ﬂow that complies with the timing diagrams in Figs. 5.77, 5.78 and 5.79. There are also
several ﬁxed-value registers, each of which contains the address and data preambles for
retrieval of data from the Flash memory. The host processor dispatches all address and
Start
0x5555/0xAA
0xAAAA/0x55
0x5555/0x00
Read Addr/
Read Data
Last Addr
Addr = Addr + 1
NO
YES
Complete
Read
preamble
Fig. 5.75 Flow chart for the read sequence
5.4
Flash Memory
237

control signals at the negative edge of the SCL clock in order to read data packets from the
Flash memory, and therefore it requires all the registers in Fig. 5.76 to operate at the positive
edge of the SCL clock.
Device ID + R
0
Shift Reg
7
0
0x5555
15
0
0xAAAA
15
0
16
16
16
selAddr
selAAAA
sel5555
0
1
2
Addr[15:0]
8
SCL
ShiftIn
LoadShift
IncrAddr
sel5555
selAAAA
selAddr
selAA
sel55
sel00
SDAIn
SDAOut
EnDataIn
ShiftIn
SCL
SCL
LoadAddrLSB
EN
WE
Read
Controller
ShiftRegOut
SDA
EnSDAOut
7
R
SCL
SCL
SDA
Detector
START
STOP
START
STOP
EnSDAOut
SDA
SDAIn
SDAOut
ShiftOut
LoadShift
Addr MSB
0
7
SCL
+ 1
8
8
8
8
selStartAddr
initAddr
AddrCountOut
0
1
IncrAddr
selStartAddr
0
1
2
0x55
0
7
0xAA
0
7
0x00
0
7
EnDataOut
EnDataIn
ShiftRegIn
8
LoadDevID
LoadAddrMSB
sel55
selAA
sel00
0
1
2
RE
ShiftOut
LoadDevID
selStartAddr
EnDataOut
I/O[7:0]
Address MUX
Data MUX
Addr Reg MUX
16
16
Addr Reg
0
15
SCL
SCL
MasterAck (external from the Master)
Fig. 5.76 I2C read interface data-path
238
5
Memory Circuits and Systems

SCL
SDA
ShiftRegOut
Addr
EN
WE
ShiftIn
LoadShift
LoadDevID
LoadAddMSB
IncrAddr
sel5555
selAAAA
selAddr
sel00
EnDataOut
sel55
selAA
EnSDAOut
selStartAddr
10
11
12
13
14
15
16
17
DAdd6
DAdd5
DAdd4
DAdd3
DAdd2
DAdd1
DAdd0
Add15
Add14
Add13
Add12
Add11
Add10
Add9
Add8
1
2
3
7
8
9
AddMSB
0x5555
HOLD
HOLD
0x5555
0xAA
0x55
0x00
ShiftOut
R
18
START
Slave
ACK
Slave
ACK
ShiftRegIn
AddrCountOut
RE
EnDataIn
SDAIn
SDAOut
Start Read Preamble
HIGH
I/O[7:0]
4
5
6
DevID+R
0xAAAA
Fig. 5.77 I2C read sequence with device ID and the LSB of starting memory address
5.4
Flash Memory
239

SCL
SDA
ShiftRegOut
Addr
EN
WE
ShiftIn
LoadShift
LoadDevID
LoadAddMSB
IncrAddr
sel5555
selAAAA
selAddr
sel00
EnDataOut
sel55
selAA
EnSDAOut
selStartAddr
29
30
31
32
33
34
35
36
D7
D6
D5
D4
D3
D2
D1
D0
19
20
21
22
26
27
28
0x5555
HOLD
HOLD
0x5555
0xAA
0x55
0x00
ShiftOut
37
Slave
ACK
Master
ACK
ShiftRegIn
AddrCountOut
RE
EnDataIn
SDAIn
SDAOut
Add6
Add5
Add4
Add3
Add2
Add1
Add0
Add7
D7
Data0
Data1
HOLD
Data0
Data1
I/O[7:0]
23
24
25
AddLSB
StartAdd
StartAdd
0xAAAA
StAdd+1
StAdd+1
Fig. 5.78 I2C read sequence with the MSB of starting memory address and data formation
240
5
Memory Circuits and Systems

SCL
SDA
ShiftRegOut
Addr
EN
WE
ShiftIn
LoadShift
LoadDevID
LoadAddMSB
IncrAddr
sel5555
selAAAA
selAddr
sel00
EnDataOut
sel55
selAA
EnSDAOut
selStartAddr
48
49
50
51
52
53
54
55
D7
D6
D5
D4
D3
D2
D1
D0
38
39
40
41
45
46
47
0x5555
HOLD
HOLD
0x5555
0xAA
0x55
0x00
ShiftOut
Master
ACK
Master
NACK
ShiftRegIn
AddrCountOut
RE
EnDataIn
SDAIn
SDAOut
D6
D5
D4
D3
D2
D1
D0
Data2
HOLD
Data2
STOP
0x5555
HOLD
HOLD
0x5555
0xAA
0x55
0x00
HOLD
I/O[7:0]
42
43
44
0xAAAA
StAdd+2
StAdd+2
0xAAAA
StAdd+3
StAdd+3
Fig. 5.79 I2C read sequence emphasizing the end of read cycle
5.4
Flash Memory
241

Figures 5.77, 5.78 and 5.79 describe the complete picture of reading data from the Flash
memory. Figure 5.77 shows the device ID and the command bit formations followed by the
generation of the most signiﬁcant byte of the initial Flash memory address. Figure 5.78
describes the formation of the least signiﬁcant byte of the initial Flash memory address and
the ﬁrst data byte read from the memory. Figure 5.79 includes two additional bytes of data
sent to the bus master and the termination of data transfer.
The bus master initiates the data transfer by issuing the START condition in Fig. 5.77.
Between cycles 1 and 8, the bus master sends the device ID followed by the read command
on the SDA bus, both of which are serially loaded to an eight-bit shift register by ShiftIn = 1.
These cycles are represented by the states DAdd6 to DAdd0 followed by the R state, which
corresponds to the read command, in the state diagram in Fig. 5.80. In cycle 9, the Flash
memory interface responds to the bus master with an acknowledgement by issuing
EnSDAOut = 1, but pauses shifting data by ShiftIn = 0. In the same cycle, the interface also
transfers data from the shift register to the device ID register by LoadDevID = 1. This cycle
corresponds to the ﬁrst slave-acknowledgement state, DevID SACK, in Fig. 5.80. In cycle
10, the interface starts sending the preamble to the Flash memory for a read operation. In this
cycle, the ﬁrst address and data preamble, 0x5555/0xAA, is fetched from the ﬁxed-data
registers, 0x5555 and 0xAA in Fig. 5.76. This preamble is subsequently sent to the address
port of the device through port 1 of the address MUX by sel5555 = 1, and to the data port of
the device through port 1 of the data MUX by selAA = 1. In this cycle, the bus master also
sends the most signiﬁcant bit of the 16-bit Flash memory address, Add15, on the SDA bus.
In cycle 12, the interface sends the second address and data preamble, 0xAAAA/0x55,
through port 2 of the address MUX by selAAAA = 1 and port 0 of the data MUX by sel55 = 1.
In cycle 14, the last address and data preamble, 0x5555/0x00, containing the read command, is
sent to the Flash memory address and data ports. The cycles 10 to 17 correspond to storing the
most signiﬁcant byte of the starting Flash memory address, Add15 to Add8, in the shift register
by ShiftIn = 1. In cycle 18, the interface sends an acknowledgement to the bus master by
EnSDAOut = 1 to indicate that it has received the higher byte of the starting Flash memory
address. Within the same cycle, this higher byte is stored in the 16-bit address register that
resides in the address counter by LoadAddMSB = 1. This cycle represents the second
slave-acknowledgement state, AddLSB SACK, in Fig. 5.80.
In cycles 19 to 26, the bus master sends the least signiﬁcant byte of the starting Flash
memory address by ShiftIn = 1. These cycles correspond to the states Add7 to Add0 in
Fig. 5.80, respectively. Cycle 27 constitutes the third slave-acknowledgement state,
AddLSB SACK, in Fig. 5.80. There are numerous events that take place during this clock
cycle, and they are all inter-related. The ﬁrst event concatenates the least signiﬁcant byte of
the starting Flash memory address in the shift register with the most signiﬁcant byte in the
Addr MSB register to form the complete 16-bit starting Flash memory address. This address
is subsequently sent to the Addr[15:0] terminal of the Flash memory through port 1 of the
address register MUX by selStartAddr = 1 and port 0 of the address MUX by selAddr = 1.
242
5
Memory Circuits and Systems

DAdd0
DAdd6
DevID
SACK
Add15
Add14
Add13
Add12
Add11
Add10
Add9
Add8
AddMSB
SACK
Add7
Add0
AddLSB
SACK
IDLE
START = 0
START = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
EnSDAOut = 1
LoadDevID = 1
EN = 1
WE = 1
RE = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
ShiftIn = 1
sel5555 = 1
selAA = 1
EnDataOut = 1
SDAIn = 1
EN = 0
WE = 0
RE = 1
MasterAck = 0
R
D7
MACK
D6
D5
D4
D2
D2
D1
D0
ShiftIn = 1
selAAAA = 1
sel55 = 1
EnDataOut = 1
SDAIn = 1
EN = 0
WE = 0
RE = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
ShiftIn = 1
sel5555 = 1
sel00 = 1
EnDataOut = 1
SDAIn = 1
EN = 0
WE = 0
RE = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
LoadAddMSB = 1
EnSDAOut = 1
EN = 1
WE = 1
RE = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
ShiftIn = 1
SDAIn = 1
EN = 1
WE = 1
RE = 1
LoadShift = 1
selStartAddr = 1
selAddr = 1
EnDataIn = 1
EnSDAOut = 1
EN = 0
WE = 1
RE = 0
ShiftOut = 1
SDAOut = 1
EN = 1
WE = 1
RE = 1
ShiftOut = 1
SDAOut = 1
EN = 1
WE = 1
RE = 1
ShiftOut = 1
sel5555 = 1
selAA = 1
EnDataOut = 1
SDAOut = 1
EN = 0
WE = 0
RE = 1
ShiftOut = 1
SDAOut = 1
EN = 1
WE = 1
RE = 1
ShiftOut = 1
selAAAA = 1
sel55 = 1
EnDataOut = 1
SDAOut = 1
EN = 0
WE = 0
RE = 1
ShiftOut = 1
SDAOut = 1
EN = 1
WE = 1
RE = 1
ShiftOut = 1
sel5555 = 1
sel00 = 1
EnDataOut = 1
SDAOut = 1
EN = 0
WE = 0
RE = 1
IncrAddr = 1
SDAOut = 1
EN = 1
WE = 1
RE = 1
LoadShift = 1
selAddr = 1
EnDataIn = 1
If SDA = 1 
EN = 0
WE = 1 
RE = 0
MasterAck = 1
MNACK
LoadShift = 0
selAddr = 0
EnDataIn = 0
If SDA = 1 
EN = 1
WE = 1 
RE = 1
Fig. 5.80 I2C read interface controller
5.4
Flash Memory
243

The second event lowers EN and RE control signals to logic 0 and produces EnDataIn = 1 in
order to fetch the ﬁrst data byte from the Flash memory, Data0, since the read preamble has
already been sent between cycles 10 and 14. The third event stores Data0 in the shift register
through its ShiftRegIn port by LoadShift = 1. Finally, the last event sends an acknowl-
edgement signal to the bus master by EnSDAOut = 1, signifying the least signiﬁcant byte of
the starting address has been received so that the bus master can start receiving serial data on
the SDA bus in the next cycle.
In cycle 28, the starting address, which could not be registered due to time limitations in
the earlier cycle, is now registered in the address register, and the address counter output,
AddrCountOut, becomes equal to the starting address, StartAdd. In the same cycle, the most
signiﬁcant bit of Data0, D7, becomes available on the SDA bus by SDAOut = 1. Starting
from cycle 30, the read preamble associated with the second data is sent to the Flash memory.
The read preamble could have been issued as early as cycle 28 or 29 since the address counter
still held StartAdd at the AddrCountOut node during these periods. In cycle 35, the interface
increments the starting address by IncrAddr = 1 and uses port 2 of the address register MUX
to feed through the result. Until the beginning of cycle 36, all eight bits of Data0, D7 to D0,
are serially sent to the bus master by SDAOut = 1. Therefore, cycles 28 to 35 correspond to
the states D7 to D0 in Fig. 5.80, respectively. In cycle 36, while the bus master acknowledges
the reception of Data0 by MasterAck = 1, and thereby lowering the SDA bus to logic 0, the
interface sends the incremented Flash memory address, StAdd + 1, to the Addr[15:0] terminal
through port 0 of the address counter MUX by selAddr = 1. In the same cycle, the interface
lowers EN and RE signals to logic 0, fetches Data1 from the I/O port of the Flash memory
by EnDataIn = 1, and stores this value in the shift register by LoadShift = 1. This particular
cycle corresponds to the master-acknowledge state, MACK, in Fig. 5.80, where the state
machine continues fetching data from the Flash memory.
Cycles 37 to 44 and cycles 46 to 53 contain identical events to the ones between cycles 28
and 35. They both correspond to the states D7 to D0 in Fig. 5.80. In cycle 54, the SDA bus
transitions to logic 1 because the bus master decides not to issue any more acknowledge-
ments by MasterAck = 0. Even though the current address increments at this point, the
interface neither lowers the EN nor lowers the RE signal to logic 0 as shown by the
master-no-acknowledge state, MNACK. Therefore, no data reading takes place from
the Flash memory. In the next cycle, the bus master terminates the SCL activity and
issues the STOP condition, signifying the end of data transfer.
244
5
Memory Circuits and Systems

Design Example 3:
I2C Page Erase Interface for Flash Memory
The following design example constructs only the I2C page erase interface for a Flash
memory that has parallel address and data ports as shown in Fig. 5.44. Using a modiﬁed
seven-bit address mode. No other Flash memory mode is implemented in this design except
the erase.
The Flash memory page erase is a six-cycle sequence as described earlier in Fig. 5.50. The
ﬂow chart for this process is shown in Fig. 5.81. In the ﬁrst ﬁve cycles, the bus master sends
ﬁxed address/data combinations to the Flash memory as a preamble to prepare the memory
to erase a block of data at a speciﬁed memory location. The page erase command is the 0x50
entry in the third cycle followed by the page address and the second erase command, 0x70,
in the sixth cycle to initiate the process.
Start
0x5555/0xAA
0xAAAA/0x55
0x5555/0x50
Page Addr/
0x70
Complete
Page 
Erase
preamble
0xAAAA/0x55
0x5555/0xAA
Fig. 5.81 Flow chart for page erase
5.4
Flash Memory
245

Figure 5.82 shows the data-path for the I2C page erase interface. The shift register
acquires the device ID (if the Flash memory requires any type of device authentication prior
to page erase) and the page address from the SDA bus, and transfers them to the device ID
register and the page address register, respectively. There are also address and data registers
that store only the ﬁxed values, and they are routed to the address and data ports of the Flash
memory in order to produce the correct preamble and page erase commands in Fig. 5.81.
Command Reg
0
Page Address Reg
15
0
Shift Reg
7
0
LoadBlkLSB
LoadBlkMSB
0x5555
15
0
0xAAAA
15
0
16
16
selBlkAddr
selAAAA
sel5555
0
1
2
Addr[15:0]
0xAA
7
0
0x55
7
0
0x50
7
0
0x70
7
0
0
1
2
3
8
8
8
8
8
DataI/O [7:0]
selAA
sel55
sel50
sel70
SCL
LoadDevID
shift
LoadDevID
sel5555
selAAAA
selBlkAddr
selAA
sel55
sel50
sel70
EnDataOut
shift
SCL
SCL
SCL
LoadBlkLSB
LoadBlkMSB
EN
WE
Block
Erase
Controller
shiftRegOut
SDA
EnDataOut
EnSDAOut
8
8
7
SCL
SCL
SDA
Detector
START
STOP
EraseCom
STOP
EnSDAOut
16
Device ID + W
0
LoadCom
7
SCL
Encoder
LoadCom
START
CommandOut
I/O[7:0]
Address MUX
Data MUX
Fig. 5.82 I2C page erase interface data-path
246
5
Memory Circuits and Systems

The page erase process is described in the timing diagrams of Figs. 5.83, 5.84 and 5.85.
The process starts with the bus master generating the START condition in Fig. 5.83. In
cycles 2 to 9, the bus master sends the seven-bit device ID and the write bit, starting with the
most signiﬁcant device ID bit, DAdd6. Even though the write bit is considered a command
bit, it does not have any signiﬁcance in the page erase preamble. The bus master sends this
bit only to comply with the I2C protocol. All these bits are temporarily stored in the shift
register and correspond to the states DAdd6 to W in the state diagram in Fig. 5.86. In cycle
10, the interface generates an acknowledgement, ACK, to signify that it has received the ﬁrst
eight bits from the bus master by EnSDAOut = 1, and transfers the device ID stored in the
shift register to the device ID register by LoadDevID = 1. This cycle corresponds to the
DevID ACK state in Fig. 5.86.
From cycles 11 to 18, which correspond to the states Add15 to Add8 in the state diagram,
the bus master sends the most signiﬁcant byte of the Flash memory page address to the
interface. These bits are received by the shift register and immediately transferred to the page
address register in cycle 19 by LoadBlkMSB = 1. In this cycle, the interface also sends a
second acknowledgment to the bus master by EnSDAOut = 1, which is represented by the
AddMSB ACK state in the state diagram.
From cycles 20 to 27, the interface receives the least signiﬁcant byte of the page address. It
stores this byte in cycle 28 by LoadBlkLSB = 1, and sends a third acknowledgement to the
bus master by EnSDAOut = 1. These events are shown by the states Add7 to Add0 and the
state AddLSB ACK in the state diagram, respectively. Starting in cycle 29, the complete page
address becomes available at the Addr[15:0] terminal in Fig. 5.82 even though the page erase
process has not been initiated. This cycle is also the starting point for the bus master to send
the erase command, 0x50, to the Flash memory interface. Without this step, the interface will
not be able to recognize if the ongoing process is actually about erasing a block of data.
From cycle 29 to 36 that correspond to the states 0x50-0 to 0x50-7, the interface receives
all eight bits of the command code, 0x50, in the shift register. Then in cycle 37, it generates
the fourth acknowledgment by EnSDAOut = 1, and transfers the contents of the shift
register, 0x50, to the command register by LoadCom = 1. Later on, the interface uses this
value to be able to generate the correct preamble for the page erase operation. Cycle 37
corresponds to the 0x50 ACK state in the state diagram. While the bus master sends the
second command code, 0x70, from cycles 38 to 45 to initiate the page erase, the interface,
now aware of the page erase operation, sends the ﬁrst address and data preamble,
0x5555/0xAA, to the Flash memory in cycle 39. In this cycle, the ﬁxed register value,
0x5555, is routed through port 1 of the address MUX by sel5555 = 1. The ﬁxed register data,
0xAA, is also sent to the I/O[7:0] port through port 0 of the data MUX by selAA = 1 and
EnDataOut = 1. In cycle 41, the second address and data preamble, 0xAAAA/0x55, is sent.
This is followed by sending the third preamble (including the ﬁrst page erase command),
0x5555/0x50, in cycle 43, and then the fourth preamble, 0x5555/0xAA, in cycle 45. The
interface pauses for one cycle after dispatching each address and data combination to comply
with the Flash memory protocol of writing data.
5.4
Flash Memory
247

SCL
SDA
shiftRegOut
Addr
EN
WE
shift
LoadDevID
LoadBlkMSB
LoadBlkLSB
LoadCom
sel5555
selAAAA
selBlkAddr
selAA
sel55
sel50
sel70
EnDataOut
11
12
13
14
15
16
17
18
DAdd6
DAdd5
DAdd4
DAdd0
ACK
Add15
Add14
Add13
Add12
Add11
Add10
Add9
Add8
ACK
1
2
3
4
8
9
10
EnSDAOut
W
19
START
HIGH
HIGH
CommandOut
I/O[7:0]
5
6
7
DevID+W
PageMSB
Fig. 5.83 I2C page erase sequence with device ID and the LSB of page address
248
5
Memory Circuits and Systems

SCL
SDA
shiftRegOut
Addr
EN
WE
shift
LoadDevID
LoadBlkMSB
LoadBlkLSB
LoadCom
sel5555
selAAAA
selBlkAddr
selAA
sel55
sel50
sel70
EnDataOut
29
30
31
32
33
34
35
36
Add7
Add6
Add5
Add1
ACK
0
0
1
0
0
0
0
ACK
20
21
22
26
27
28
0x50
EnSDAOut
Add0
37
HIGH
HIGH
CommandOut
Page Address
1
I/O[7:0]
23
24
25
PageLSB
Fig. 5.84 I2C page erase sequence with the MSB of page address and the erase command
5.4
Flash Memory
249

SCL
SDA
shiftRegOut
Addr
EN
WE
shift
LoadDevID
LoadBlkMSB
LoadBlkLSB
LoadCom
sel5555
selAAAA
selBlkAddr
selAA
sel55
sel50
sel70
EnDataOut
47
48
49
50
0
1
0
0
0
ACK
X
X
38
39
40
44
45
46
EnSDAOut
0
CommandOut
Page Address
X
41
42
43
0X50
0xAA
0x5555
0x55
Start Page Erase Preamble
0x50
0x5555
0xAA
0x5555
hold
hold
hold
hold
0x55
hold
0x70
1
1
0X70
Controller releases 0x70 as opposed to 0x60 (Chip Erase)
STOP
Page Address
I/O[7:0]
0xAAAA
0xAAAA
Fig. 5.85 I2C page erase preamble and the page erase command
250
5
Memory Circuits and Systems

DAdd0
DAdd6
DevID
ACK
Add15
Add8
AddMSB
ACK
Add7
Add0
AddLSB
ACK
0x50
0
0x50
7
0x50
ACK
IDLE
START = 0
START = 1
shift = 1
EN = 1
WE = 1
EnSDAOut = 1
LoadDevID = 1
EN = 1
WE = 1
SDA = 1
W
0x70
0
0x70
ACK
0x70
1
0x70
2
0x70
3
0x70
4
0x70
5
0x70
6
0x70
7
SDA = 0
shift = 1
selBlkAddr = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
EnSDAOut = 1
LoadBlkMSB = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
shift = 1
EN = 1
WE = 1
EnSDAOut = 1
LoadBlkLSB = 1
EN = 1
WE = 1
shift = 1
selBlkAddr = 1
EN = 1
WE = 1
EnSDAOut = 1
LoadCom = 1
selBlkAddr = 1
EN = 1
WE = 1
shift = 1
selBlkAddr = 1
EN = 1
WE = 1
shift = 1
selBlkAddr = 1
EN = 1
WE = 1
shift = 1
selBlkAddr = 1
EN = 1
WE = 1
shift = 1
selBlkAddr = 1
EN = 1
WE = 1
EnSDAOut = 1
selBlkAddr = 1
EN = 1
WE = 1
shift = 1
sel5555 = 1
selAA = 1
EnDataOut = 1
EN = 0
WE = 0
shift = 1
selAAAA = 1
sel55 = 1
EnDataOut = 1
EN = 0
WE = 0
shift = 1
sel5555 = 1
sel50 = 1
EnDataOut = 1
EN = 0
WE = 0
shift = 1
sel5555 = 1
selAA = 1
EnDataOut = 1
EN = 0
WE = 0
DontCare
2
DontCare
0
DontCare
1
selBlkAddr = 1
EN = 1
WE = 1
selAAAA = 1
sel55 = 1
EnDataOut = 1
EN = 0
WE = 0
selBlkAddr = 1
sel70 = 1
EnDataOut = 1
EN = 0
WE = 0
Fig. 5.86 I2C page erase interface controller
5.4
Flash Memory
251

Cycles 38 to 45 are represented by the states 0x70-0 to 0x70-7 in the state diagram,
respectively. The interface sends the ﬁfth acknowledgment to the bus master in cycle 46 by
EnSDAOut = 1 while in the 0x70 ACK state. In cycle 47, the interface sends the ﬁfth address
and data preamble, 0xAAAA/0x55, and ﬁnally in cycle 49, it sends the page address with the
second page erase command, 0x70, to erase the entire block of data. Cycles 47 to 49 are
represented by the DontCare-0, DontCare-1 and DontCare-2 states in Fig. 5.86, respectively.
An architecture combining the read and the fast write interfaces can be implemented by a
data-path shown in Fig. 5.87. A shift register can be used to receive the incoming device
address and command bit from the SDA bus, which is subsequently is stored in an auxiliary
register as shown in this ﬁgure. The seven-bit device ID ﬁeld can be used to activate one of
the maximum 128 Flash memory chips. The command bit, R or W, is used to enable either
the read interface or the fast write interface depending on its value. The Flash memory
address residing in the shift register is then forwarded to the eight-bit shift register in either
the read or the fast write interface to prepare the Flash memory for a data transfer.
The reader should be quite familiar with all three I2C interface designs shown above to be
able to integrate them in one interface to achieve a complete design.
Shift Reg
7
0
SCL
SDA
DeviceID
7
0
SCL
R/W
Decoder
EnFlash0
EnFlash127
Read 
I/F
Shift Reg
SCL
Fast Write 
I/F
Shift Reg
SCL
1
7
EnReadIF
EnWriteIF
8
6
Fig. 5.87 I2C read and fast write (program) interface topologies
252
5
Memory Circuits and Systems

5.5
Serial Flash Memory
Recent Flash memory chips already include I2C or SPI interfaces to interact with a host
processor or another bus master. The user does not have to deal with preambles, waiting
periods or other complexities of the memory, but simply write an I2C or SPI-compliant
embedded program to initiate a read, write or erase operation with the Flash memory.
This section examines the operation of a typical Flash memory with an SPI interface.
Figure 5.88 shows the basic internal architecture of the Flash memory where an external
active-low Slave Select control signal, SS, is applied to enable the memory. The clock is
supplied through the SCK port. The serial data comes into the memory through the
Serial-Data-In (SDI) port and departs from the Serial-Data-Out (SDO) port. Once a serial
address is retrieved from the SPI bus, it is stored in the address register. The address decoder
uses the contents of the address register to access the Flash memory core and read the data to
an internal data buffer. The serial data is subsequently delivered to the bus master through
the SDO port. If the operation is a write, the bus master sends serial data to the SDI port,
which is then transferred to an internal data buffer, and subsequently to the memory core.
Figure 5.89 describes a typical partitioning scheme of a 1 MB memory core that requires a
20-bit address for each byte of data. To be consistent with the E2PROM and Flash memory
organizations discussed in previous sections, the entire memory block in this example is
divided into sixteen 64 KB sectors. Each sector is subdivided into sixteen 4 KB blocks, and
each block is further subdivided into 16 pages. Each page contains 256 bytes, any of which
is accessible through the SPI bus. Figure 5.90 shows the detailed address mapping of Block
0 in Sector 0 to further illustrate the internal memory organization.
SPI Bus
Interface
Flash Memory 
Core
Control Unit
Data Buffer
Address Reg
Address 
Decoder
SS
SCK
SDI
SDO
Fig. 5.88 Serial Flash memory architecture with SPI interface
5.5
Serial Flash Memory
253

Figure 5.91 shows nine basic modes of operation for this Flash memory. Some of the
modes in this table are further divided into sub-modes according to the complexity of the main
mode. For example, in the write (program) mode, the opcode 0x20 assumes to write between
1 and 255 bytes into the memory core while the opcode 0x23 writes 64 KB of data into a
sector. Similarly, the erase mode can be conﬁgured to erase a page, a block or the entire
chip. The protect operation prevents overwriting to a sector or the chip. The write enable
feature is a security measure for the serial Flash memory, and it is used prior to an actual write
or an erase operation. Once the write enable command is issued, any kind of data alteration in
the memory core becomes possible. Both the write enable and protect features are registered
Block 15 –4KB
Block 14 –4KB
Block 0 –4KB
Sector 15 –64KB
Block 15 –4KB
Block 14 –4KB
Block 0 –4KB
Sector 14 –64KB
Block 15 –4KB
Block 14 –4KB
Block 0 –4KB
Sector 0 –64KB
Fig. 5.89 A serial Flash core memory organization: 16 sectors and 16 blocks in each sector
Page 0
(256B)
0x00000
0x000FF
7
0
Page 1
(256B)
Page 15
(256B)
7
0
7
0
0x00100
0x001FF
0x00F00
0x00FFF
Address mapping of Block 0 of Sector 0
Fig. 5.90 Memory organization of block 0 of sector 0: 16 pages, 256 bytes per page
254
5
Memory Circuits and Systems

in the status register and can be read on demand. The status register also indicates whether the
device is busy, such as in the middle of a write or read operation, write enable is engaged or
not, or which sector is protected. The Flash memory can be placed into a long term hiber-
nation mode to save power. The modes in Fig. 5.91 are at minimum compared to a typical
serial Flash memory to emphasize only the primary modes of operation. The opcode value for
each mode is also randomly selected. Actual serial Flash memory datasheets contain many
more operational modes with different opcode values assigned to each mode.
FLASH MEMORY COMMANDS
OPCODES
Read
0x10
Write Byte (1-255)
0x20
Write Page
0x21
Write Block
0x22
Write Sector
0x23
Erase Page
0x30
Erase Block
0x31
Erase Chip
0x32
Protect Sector
0x40
Unprotect Sector
0x41
Protect Chip
0x42
Unprotect Chip
0x43
0x66
0x55
Read Status Register
0x77
Hibernate
0x88
Wake up
0x99
Write
Erase
Protect/Unprotect
Write Disable
Write Enable
Fig. 5.91 Main serial Flash memory commands
5.5
Serial Flash Memory
255

This particular Flash memory operates in both mode 0 (SCK is initially at logic 0) and
mode 3 (SCK is initially at logic 1) of the SPI protocol. However, most of the timing diagrams
in this section will refer to mode 0 when explaining different commands in Fig. 5.91.
Figures 5.92 and 5.93 explain the basic write protocols in mode 0 and mode 3, respec-
tively. Once SS signal is lowered to logic 0, data bits at SDI port can be written into the
Flash memory’s data buffer at the positive edge of SCK. The data transaction stops when SS
is raised to logic 1. The entire data buffer is subsequently transferred to the memory core
within the write period, tWRITE.
Similarly, Figs. 5.94 and 5.95 explain the basic read protocols in mode 0 and mode 3,
respectively. When the SS signal is lowered to logic 0, data is delivered from the memory
core to the data buffer, and then from the data buffer to the SDO terminal at the negative edge
of each SCK cycle. The memory access is equal to tREAD with respect to the negative edge of
SCK. When the SS signal is raised to logic 1, SCK is no longer allowed to change, and the
read process terminates.
In both write and read operations, the most signiﬁcant data bit is delivered ﬁrst, and the
least signiﬁcant data bit is delivered last.
MSB
LSB
SDI
SS
SCK
Mode 0 - Write Protocol
Fig. 5.92 Serial Flash memory mode 0 SPI write (program) protocol
MSB
LSB
SDI
SS
SCK
Mode 3 - Write Protocol
Fig. 5.93 Serial Flash memory mode 3 SPI write (program) protocol
256
5
Memory Circuits and Systems

A typical Flash memory byte read is shown in Fig. 5.96. The process starts with sending
the opcode, 0x10, corresponding to a read operation according to the table in Fig. 5.91.
A 20-bit address follows the opcode with the most signiﬁcant address bit, A19, ﬁrst, and the
least signiﬁcant address bit, A0, last. The ﬁrst data bit, D7 (also the most signiﬁcant bit of
data), is delivered to the SDO terminal at the negative edge of SCK according to Fig. 5.96.
The remaining seven bits of data are sequentially delivered at each negative edge of SCK
until the SCK signal stabilizes at logic 0, and the SS signal transitions to logic 1.
MSB
LSB
SDO
SS
SCK
Mode 0 - Read Protocol
Fig. 5.94 Serial Flash memory mode 0 SPI read protocol
MSB
LSB
SDO
SS
SCK
Mode 3 - Read Protocol
Fig. 5.95 Serial Flash memory mode 3 SPI read protocol
MSB
LSB
0
0
0
1
0
SDI
SS
SCK
A19
A18
A0
D7
D6
MSB
LSB
D0
SDO
BYTE
OPCODE = 0x10 = READ
ADDRESS [19:0]
Fig. 5.96 Serial Flash memory byte read in mode 0
5.5
Serial Flash Memory
257

Once a starting 20-bit address is issued, a number of bytes, ranging from one byte to the
contents of the entire memory, can be read from the SDO port as long as the SS signal is kept
at logic 0, and the SCK activity is present. Terminating SCK and raising SS to logic 1 ceases
the read process as shown in Fig. 5.97.
The Flash memory write (program) mode has four sub modes. In the byte write mode,
bytes ranging between 1 and 255 can be written to a page following the opcode, 0x20, and a
20-bit memory address as shown in Fig. 5.98. After data is written to the last address of the
page, subsequent bytes at SDI terminal are considered invalid and will be ignored even
though there may still be SCK activity and/or SS may still be at logic 0. In some serial Flash
memory chips, excess data is not ignored but written to the memory core starting from the
ﬁrst address of the page (address looping).
MSB
LSB
0
0
0
1
0
SDI
SS
SCK
A19
A18
A0
D7
MSB
LSB
D0
SDO
BYTE 0
OPCODE = 0x10 = READ
ADDRESS [19:0]
D7
MSB
LSB
D0
BYTE N (MAX = 1,048,575)
Fig. 5.97 Serial Flash memory read burst in mode 0
MSB
LSB
0
0
1
0
0
SDI
SS
SCK
A19
A18
A0
D7
D6
MSB
LSB
D0
BYTE (1-255)
OPCODE = 0x20 = WRITE BYTE
ADDRESS [19:0]
Fig. 5.98 Serial Flash memory write burst (1 to 255 bytes) in mode 0
258
5
Memory Circuits and Systems

Figure 5.99 describes the page write mode. After issuing the write page opcode, 0x21, and
a 20-bit page address, 256 bytes of data are sequentially written into the memory core
starting from the top of the page. Any data beyond 256 bytes will be ignored by the device. It
is vital that the 20-bit starting address aligns with the ﬁrst address of the page. For example,
if page 0 of block 0 in sector 0 needs to be accessed to write data, the starting address has to
be 0x00000 according to Fig. 5.90. Similarly, the starting address has to be 0x00100 for
page 1 or 0x00F00 for page 15 if the contents of either page need to be written.
Writing to a block or a sector is not any different from writing to a page. In both instances,
the starting 20-bit address needs to align with the topmost address of the block or the sector.
For example, writing a 4 KB of data to block 0 of sector 0 requires the starting address to be
0x00000. Similarly, the starting address of block 1 of sector 0 has to be 0x01000 if 4 KB
data needs to be written to this block.
Erase can be performed on a page, a block or the entire chip according to the table in
Fig. 5.91. The page erase requires the opcode, 0x30, followed by the topmost address of the
page as shown in Fig. 5.100. Erasing the entire chip only requires the opcode, 0x32, as
shown in Fig. 5.101.
MSB
LSB
0
0
1
0
1
SDI
SS
SCK
A19
A18
A0
D7
MSB
LSB
D0
D7
MSB
LSB
D0
BYTE 0
BYTE 255
OPCODE = 0x21 = WRITE PAGE
ADDRESS [19:0]
PAGE
Fig. 5.99 Serial Flash memory page write in mode 0
5.5
Serial Flash Memory
259

Accidentally altering the contents of the Flash memory is a non-reversible process.
Therefore, many manufacturers formulate a security measure, such as a write enable com-
mand, prior to a write or an erase operation. The write enable command requires issuing an
opcode, 0x55, according to Fig. 5.91, and it is implemented in Fig. 5.102. This code changes
the write enable bit in the status register which then enables the Flash memory for write or
erase. For example, in Fig. 5.103 the write enable opcode, 0x55, is issued prior to the write
byte opcode, 0x20, to allow any number of bytes to be written to a page. If the write enable
opcode is omitted prior to a byte, a page, a block or a sector write, the data delivered to the
memory core becomes invalid and is ignored.
MSB
LSB
0
0
1
1
0
SDI
SS
SCK
A19
A18
A0
OPCODE = 0x30 = PAGE ERASE
PAGE ADDRESS [19:0]
Fig. 5.100 Serial Flash memory page erase in mode 0
0
0
1
1
0
0
1
0
SDI
SS
SCK
OPCODE = 0x32 = CHIP ERASE
Fig. 5.101 Serial Flash memory chip erase in mode 0
260
5
Memory Circuits and Systems

Protecting a sector or the entire chip is also a vital security measure for the Flash memory.
For example, if a Flash memory contains BIOS data in speciﬁc sectors, accidentally
accessing these sectors for write or erase becomes fatal. Therefore, such accesses need to be
prevented at all costs. The opcode, 0x40, is issued with a speciﬁc sector address to protect
the data in this sector as shown in Fig. 5.104. However, as with the write and erase modes,
the write enable opcode, 0x55, must accompany the sector protect opcode, 0x40, to make the
sector protect a valid entry as shown in the timing diagram in Fig. 5.105.
0
1
0
1
0
1
0
1
SDI
SS
SCK
OPCODE = 0x55 = WRITE ENABLE
Fig. 5.102 Serial Flash memory write enable operation in mode 0
0
1
0
1
0
SDI
SS
SCK
OPCODE = 0x55 = WRITE ENABLE
MSB
LSB
1
0
1
0
0
A19
A18
A0
D7
D6
MSB
LSB
D0
BYTE (1-255)
OPCODE = 0x20 = WRITE BYTE
ADDRESS [19:0]
Fig. 5.103 Serial Flash memory write (program) burst (1 to 255 bytes) followed by write
enable
5.5
Serial Flash Memory
261

The user may reverse the write enable status of the device by issuing a write disable
command, 0x66, as shown in the timing diagram in Fig. 5.106.
Status register constitutes an important part of the Flash memory programming. For this
particular Flash memory, there are four entries in the status register that contain vital
operational information as shown in Fig. 5.107. The SP0, SP1 and SP2 bits identify which
MSB
LSB
0
1
0
0
0
0
0
0
SDI
SS
SCK
A19
A18
A0
OPCODE = 0x40 = PROTECT SECTOR
SECTOR ADDRESS [19:0]
Fig. 5.104 Serial Flash memory protect sector operation in mode 0
0
1
0
1
SDI
SS
SCK
OPCODE = 0x55 = WRITE ENABLE
1
MSB
LSB
0
1
0
0
0
A19
A18
A0
OPCODE = 0x40 = PROTECT SECTOR
SECTOR ADDRESS [19:0]
Fig. 5.105 Serial Flash memory write enable operation followed by protect sector in mode 0
262
5
Memory Circuits and Systems

sectors are protected. The Write Enable Latch bit, WEL, signiﬁes if the device has already
been write-enabled or not. The Write-In-Progress, WIP, bit deﬁnes if the device is busy with
a write process.
The user can access the contents of the status register at any time by issuing the read status
register command, 0x77, as shown in Fig. 5.108. After executing this command, the contents
of the status register become available at the SDO port.
The user can also place the Flash memory into the sleep mode to conserve power by
issuing hibernate opcode, 0x88, as shown in Fig. 5.109. The hibernation mode can be
reversed by issuing the wake-up opcode, 0x99, as shown in Fig. 5.91.
0
1
1
0
0
1
1
0
SDI
SS
SCK
OPCODE = 0x66 = WRITE DISABLE
Fig. 5.106 Serial Flash memory write disable operation in mode 0
SP0
WIP
7
6
5
4
WEL = Write Enable Status = 1   Write Enable is active
                                                0   Write Enable is inactive
WIP = Write In Progress = 1   Device is busy with write
                                           0   Device is not busy with write
WEL
3
SP1
SP2
Reserved
2
1
0
SP0
SP1
SP2
0
0
0
1
0
0
0
1
0
1
1
0
0
0
1
1
0
1
0
1
1
1
1
1
No sector is protected
Address 0x00000 to 0x0FFFF is protected
Address 0x00000 to 0x1FFFF is protected
Address 0x00000 to 0x3FFFF is protected
Address 0x00000 to 0x7FFFF is protected
Address 0x00000 to 0xFFFFF is protected
Address 0x00000 to 0xFFFFF is protected
Address 0x00000 to 0xFFFFF is protected
Fig. 5.107 Serial Flash memory status register
5.5
Serial Flash Memory
263

0
1
1
1
1
SDI
SS
SCK
Res
Res
MSB
SDO
STATUS REGISTER CONTENTS
OPCODE = 0x77 = READ STATUS REGISTER
Res
SP2
SP1
SP0
WEL
WIP
LSB
Fig. 5.108 Serial Flash memory status register read operation in mode 0
1
0
0
0
1
0
0
0
SDI
SS
SCK
OPCODE = 0x88 = CHIP HIBERNATE
Fig. 5.109 Serial Flash memory chip hibernate operation in mode 0
264
5
Memory Circuits and Systems

Review Questions
1. An SDRAM is composed of two16-bit wide banks, bank 0 and bank 1, as shown below.
0000
0xAB00
1111
0xAB01
2222
0xAB02
3333
0xAB03
4444
0xAB04
5555
0xAB05
6666
0xAB06
7777
0xAB07
8888
0xAB08
9999
0xAB09
AAAA
0xAB0A
AA00
0xCD00
BB11
0xCD01
CC22
0xCD02
DD33
0xCD03
EE44
0xCD04
FF55
0xCD05
AA11
0xCD06
BB22
0xCD07
CC33
0xCD08
DD44
0xCD09
EE55
0xCD0A
SDRAM Bank0
SDRAM Bank1
15
15
0
0
The truth table below deﬁnes the precharge, activate and read cycles.
0
CS
RAS
CAS
WE
Precharge
Activate
Read
Operation
0
1
0
0
0
1
1
0
1
0
1
Each 16-bit SDRAM address is composed of two parts: the most signiﬁcant byte cor-
responds to the row address, and the least signiﬁcant byte corresponds to the column
address as shown below.
Address = {Row Address, Column Address}
The precharge wait period is two clock cycles between the positive edge of the precharge
cycle and the positive edge of the activate cycle. Similarly, the CAS wait period is two
cycles between the positive edge of the activate cycle and the positive edge of the read
command. The read burst from the speciﬁed address starts after a latency of two cycles.
The waiting period between the last data packet and the precharge cycle is also two cycles
if the read repeats from the same bank.
5.5
Serial Flash Memory
265

(a) Show the two read sequences in sequential addressing mode from Bank 0. Each burst
contains four data packets: the ﬁrst burst is from the address, 0xAB03, and the next
from the address, 0xAB07.
(b) Show the two read sequences in sequential addressing mode from different banks
with no delay in between. Each burst contains four data packets: the ﬁrst burst is from
the Bank 0 with the starting address, 0xAB03, and the next from Bank 1 with the
address, 0xCD06.
2. A Flash memory is composed of two byte-addressable sectors. It has an eight-bit
bidirectional I/O port for reading and writing data, and a 16-bit unidirectional address
port. The upper eight bits of the address ﬁeld are allocated for the sector address and the
lower eight bits for the program address. The three active-low inputs, EN, RE and WE,
control the Flash memory according to the following chart:
Operations
EN
RE
WE
Read
0
0
1
Write
0
1
0
Standby
0
1
1
Off
1
x
x
The initial data contents in this memory are shown below:
0xEE
0xFF
0x34
0x12
0xCC
0xDD
0x78
0x56
0x00
0x02
0xAA
0xBB
0xBC
0x9A
0x88
0x99
0xF0
0xDE
0x04
0x06
15
0
15
0
0x00
0x02
0x04
0x06
Sector 0
Sector 1
The Flash command chart is as follows:
Sector protect
0x5555
0xAA
0xAAAA
0x55
Sector Addr
0x01
Fast write
0x5555
0xAA
0xAAAA
0x02
Write Addr
Write Data
word
word
0xAAAA
0x5555
Write Addr
Write Data
byte
Read
0x5555
0xAA
0xAAAA
0x03
Read Addr
Read Data
word
0xAAAA
0x5555
Read Addr
Read Data
byte
Cycle 1
Cycle 2
Cycle 3
Addr
Data
Addr
Data
Addr
Data
266
5
Memory Circuits and Systems

In this diagram, the sector protect is a three-cycle sequence where the sector protect code,
0x01, is provided in the third cycle along with the sector address.
Both the fast write and the read processes are initially three cycles. However, once the
process starts, additional reads or writes are reduced to two-cycle operations as shown in
the ﬂow chart below. According to this chart, for each additional data to be read or
written, the command code must be employed in the second cycle, and the address/data
combination in the third cycle.
The ﬂow chart for the fast write and read is as follows:
Start
First cycle
Second cycle
Addr/
Data
Last Addr
Finish
yes
Incr. Addr
no
(a) Perform protect sector 1. Show the timing diagram with control inputs, address and
data.
(b) Perform fast write to sector 0 with four bytes of data, 0x11, 0x22, 0x33, 0x44. Start
from the address, 0x04, and increment the address to write each byte.
(c) Read four bytes from sector 0 at the addresses, 0x00, 0x02, 0x04 and 0x06. Show the
timing diagram with control inputs, address and data.
5.5
Serial Flash Memory
267

3. Two reads need to be accomplished from a 16-bit wide SDRAM organized in four banks
with the data shown below.
Each SDRAM address is composed of an eight-bit wide row address, RA[7:0], and an
eight-bit wide column address, CA[7:0], as in the following format:
SDRAM Address = {RA[7:0], CA[7:0]} where the row address occupies higher bits.
To control SDRAM, the following controls are supplied:
0
CS
RAS
CAS
WE
Precharge
Activate
Read
Operation
0
1
0
0
0
1
1
0
1
0
1
The wait period between the precharge and the activate cycles is one clock cycle. Similarly,
the wait period between the activate and the read cycles is one clock cycle. The precharge
cycle for the next read operation takes place after the last data is read out from SDRAM.
BS[1:0] = 0 selects Bank0, BS[1:0] = 1 selects Bank1, BS[1:0] = 2 selects Bank2, and
BS[1:0] = 3 selects Bank3 in the timing diagrams.
(a) Assuming that the mode register is pre-programmed in sequential mode addressing
with a burst length of four and a CAS latency of two, construct a timing diagram to
show the two reads from the SDRAM addresses, 0xAA00 and 0xAA04. Start from
the precharge cycle to accomplish each read.
(b) With the same mode register contents in part (a), construct a timing diagram such that
the two reads from the SDRAM addresses, 0xAA00 and 0xBB02, take place in the
shortest possible time. Again start from the precharge cycle to accomplish each read.
1111
2222
3333
4444
5555
6666
7777
8888
AA00
AA01
AA02
AA03
AA04
AA05
AA06
AA07
15
0
Bank0
AAAA
BBBB
CCCC
DDDD
EEEE
FFFF
0000
1111
BB00
BB01
BB02
BB03
BB04
BB05
BB06
BB07
15
0
Bank1
FFFF
EEEE
DDDD
CCCC
BBBB
AAAA
1111
0000
CC00
CC01
CC02
CC03
CC04
CC05
CC06
CC07
15
0
Bank2
8888
7777
6666
5555
4444
3333
2222
1111
DD00
DD01
DD02
DD03
DD04
DD05
DD06
DD07
15
0
Bank3
268
5
Memory Circuits and Systems

(c) With the same mode register contents in part (a), accomplish one read from the
SDRAM address, 0xCC00, with a burst length of two, and one read from the
SDRAM address, 0xDD02, with a burst length of eight. Start from the precharge
cycle to accomplish each read.
4. Subsequent write and read operations are performed on an SDRAM that consists of two
banks. Both banks have eight-bit wide I/O data ports.
The ﬁrst SDRAM operation is a write operation that writes 0x11 to the starting address of
0xAB in bank 0. This is followed by writing the data values, 0xEE, 0x00 and 0xFF, to
bank 0 in sequential mode.
The read operation takes place from bank 1 without any interruption. This means that the
ﬁrst read-data is delivered to the data bus immediately after the last data, 0xFF, has been
written. The ﬁrst read-address is deﬁned as 0x12. Four data packets are read from this
starting address in sequential mode with a latency of two cycles.
Both write and read operations require tPRE = tCAS = 1 cycle.
Construct a timing diagram with control, address and data values to achieve these two
consecutive operations. Assume all initial data values in Bank 0 are 0x00. Make sure to
mark each precharge, activate, write and read cycle on the timing diagram. Indicate where
latency happens.
Addr[0xA0]
7
0
Addr[0xA1]
Addr[0xA2]
Addr[0xA3]
Addr[0xA4]
Addr[0xA5]
Addr[0xA6]
Addr[0xA7]
BANK 0
Addr[0xA8]
Addr[0xA9]
Addr[0xAA]
Addr[0xAB]
Addr[0xAC]
Addr[0xAD]
Addr[0xAE]
Addr[0xAF]
Addr[0x10]
0x88
0x99
0xAA
0xBB
0xCC
0xDD
0xEE
0xFF
7
0
Addr[0x11]
Addr[0x12]
Addr[0x13]
Addr[0x14]
Addr[0x15]
Addr[0x16]
Addr[0x17]
Addr[0x18]
0x00
0x11
0x22
0x33
0x44
0x55
0x66
0x77
Addr[0x19]
Addr[0x1A]
Addr[0x1B]
Addr[0x1C]
Addr[0x1D]
Addr[0x1E]
Addr[0x1F]
BANK 1
5.5
Serial Flash Memory
269

5. An E2PROM memory is organized in four sectors. There are eight rows in each sector but
no pages. The existing data in this memory is shown below.
0x7
0x6
0x5
0x4
0x3
0x2
0x1
0x0
0x7
0x6
0x5
0x4
0x3
0x2
0x1
0x0
0xF
0xE
0xD
0xC
0xB
0xA
0x9
0x8
0xF
0xE
0xD
0xC
0xB
0xA
0x9
0x8
3
0
0
1
2
3
4
5
6
7
0
1
2
3
4
5
6
7
0
1
2
3
4
5
6
7
0
1
2
3
4
5
6
7
3
0
3
0
3
0
Sector 0
Sector 1
Sector 2
Sector 3
The command truth table is given below.
Function
Command code
SR Read
Read
Write buffer
0x0
0x1
0x2
0x3
Write core
The memory has ﬁve control pins:
EN is an active-low signal that activates the sector
AE is an active-high signal that accepts address
CE is an active-high signal that enables command function
WE is an active-low signal that enables write
RE is an active-low signal that enables read
Writing to the memory takes place at the rising edge of WE. At the falling edge of RE, reads
take place from the memory. The write sequence starts with the command function followed
by the address and then the data. The read sequence follows a similar fashion: it starts with
the read command, then the address and then the data. Assume all AE, WE and RE set-up
times are 0 s. The setup and hold times for command, address and data are all different from
0 s. It takes tWRITE amount of time to transfer data from the buffer to the memory core.
(a) Draw a timing diagram to read data from the row address = 0 and the sector address = 3.
(b) Draw a timing diagram to write 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x7, 0x6 starting
from the row address = 2 and the sector address = 2 in the following manner: the ﬁrst
data, 0xA, to the row address 2; the second data, 0xB, to the row address 0x3 and so
forth. Draw the contents of the memory after the write sequence is complete.
270
5
Memory Circuits and Systems

6. A Flash memory block has an eight-bit address, and executes all reads and writes on an
eight-bit bidirectional data bus. The Flash memory write sequence contains a preamble, a
write command, and an address/data combination as shown in the ﬂow chart below. Once
the write command is issued, the address/data combination is generated continuously until
the last write takes place. The sequence ends with the same preamble that starts the write.
Preamble
Write com
Addr/Data
Last
Addr
Preamble
DONE
Next Addr
START
yes
no
In the read sequence, the bus master starts fetching data once the preamble and the read
command are issued. The sequence has the same exit preamble as shown below.
Preamble
Read com
Addr/Data
Last
Addr
Preamble
DONE
Next Addr
START
yes
no
5.5
Serial Flash Memory
271

START and DONE do not have any signiﬁcance in timing diagrams other than that they
indicate the start and the end of the sequence, respectively.
The preamble, write and read commands are issued with the hexadecimal values shown
in the truth table below.
Preamble
Write com
Read com
COMMANDS
Address
Data
FF
AA
BB
00
FF
FF
The state of the Flash memory before any read or write operation is shown below. The
leftmost column in this ﬁgure shows the Flash memory address in hexadecimal.
FF
EE
DD
CC
BB
AA
99
88
7
0
F8
F9
FA
FB
FC
FD
FE
FF
The bus master produces three data transmissions for the Flash memory. In the ﬁrst
transmission, four data packets are written to the Flash memory as shown below.
F8
F9
00
11
Address
Data
1
2
Packet no
FA
FB
22
33
3
4
272
5
Memory Circuits and Systems

In the second transmission, the bus master reads two data packets from the following
addresses below.
FA
FB
Address
Data
1
2
Packet no
In the third transmission, the bus master reads two more data packets from the following
addresses.
FE
FF
Address
Data
1
2
Packet no
Construct a timing diagram, including the address, the active-low WE and RE signals,
and the data. Note that the Flash memory requires a hold period which coincides with the
high phase of EN signal. However, in the low phase, when the Flash memory is active,
the device either writes or reads depending on the value of the WE and RE signals,
respectively.
7. A serial on-chip SPI bus described in Chapter 4 is used to program an SDRAM register
ﬁle that consists of ﬁve registers (see the SDRAM bus interface architecture).
Assume that each register in the register ﬁle has an eight-bit long address. Data in each
register is also assumed to be eight bits long.
The Wait register receives the number of clock periods which is equivalent to tWAIT, the
Latency register to tLAT, the Burst register to tBURST, the CAS register to tCAS, and the
Precharge register to tPRE.
The SDI port of the SDRAM programming interface receives an eight-bit address (starting
with the most signiﬁcant bit) followed by an eight-bit data (again starting with the most
signiﬁcant bit) at the positive edge of SCK until all ﬁve registers are programmed while
SS = 0. Once the programming is ﬁnished, the SS node pulls back to logic 1.
Design the interface between the SPI bus and the register ﬁle. Make sure to show each
SPI-compliant I/O port (such as SCK, SDI, SS etc.), the internal address, data and control
signals of the interface on the timing diagram. The functionality of the interface must be
the same in both the timing diagram and the data-path.
Start building the timing diagram that includes only the address and the data. Then form
the corresponding data-path that matches the timing diagram. Increase the complexity of
the design by including the control signals in the timing diagram, guiding the data ﬂow.
Lastly, draw the state diagram of the Moore type controller for the interface.
5.5
Serial Flash Memory
273

Projects
1. Implement and verify the SRAM bus interface unit described in Fig. 5.5 with the uni-
directional bus designed in Chapter 4. Use Verilog as the hardware design language for
the module implementation and functional veriﬁcation. Make sure the interface complies
with the timing diagrams shown in Figs. 5.6 and 5.8 and includes a controller unit as
shown in Figs. 5.7 and 5.9.
2. Implement and verify the SDRAM bus interface unit described in Fig. 5.25 with the
unidirectional bus designed in Chapter 4. Use Verilog as the hardware design language
for the module implementation and functional veriﬁcation. Make sure the interface
complies with the timing diagrams shown in Figs. 5.27 and 5.29 and includes a controller
unit as shown in Figs. 5.28 and 5.30. Produce the hardware to program the SDRAM
register ﬁle. Assume a serial bus such as SPI or I2C to distribute the program data to the
registers.
3. Implement and verify the I2C fast write interface in the ﬁrst design example of Chapter 5
using Verilog. Make sure your design is consistent with the state machine shown in
Fig. 5.72.
4. Implement and verify the I2C read interface in the second design example using Verilog.
Make sure to be consistent with the state machine shown in Fig. 5.80.
5. Combine the read and the fast write interfaces into a single unit. Design and verify the
complete interface using Verilog.
Note that for projects 3 through 5, write a behavioral Verilog code that mimics the bus
master in order to send data on the I2C bus.
References
1. Toshiba datasheet TC59S6416/08/04BFT/BFTL-80, -10 Synchronous Dynamic RAM
2. Toshiba datasheet TC58DVM72A1FT00/TC58DVM72F1FT00 128Mbit E2PROM
3. Toshiba datasheet TC58256AFT 256Mbit E2PROM
4. Toshiba datasheet TC58FVT004/B004FT-85, -10, -12 4MBit CMOS Flash memory
5. Toshiba datasheet TC58FVT400/B400F/FT-85, -10, -12 4MBit CMOS Flash memory
6. Toshiba datasheet TC58FVT641/B641FT/XB-70, -10 64MBit CMOS Flash memory
7. Atmel datasheet AT26DF161 16Mbit serial data Flash memory
274
5
Memory Circuits and Systems

6
Central Processing Unit
This chapter describes a basic Central Processing Unit (CPU) that operates with a Reduced
Instruction Set (RISC) [1, 2, 3, 4]. The chapter is divided into four parts.
In the ﬁrst part, ﬁxed-point Arithmetic Logic Unit (ALU) instructions are described. This
section ﬁrst develops a dedicated hardware (data-path) to execute a single RISC instruction,
and then groups several data-paths together to be able to execute variety of user programs. In
each step of this process, the instruction ﬁeld is dissected into several segments as the
instruction ﬂows through the data-path, and the necessary hardware is formed to execute the
instruction and generate an output.
The second part of this chapter explains the IEEE single and double-precision
ﬂoating-point formats, leading to the designs of ﬂoating-point adder and multiplier. These
designs are then integrated with the ﬁxed-point hardware to obtain a RISC CPU capable of
executing both ﬁxed-point and ﬂoating-point arithmetic instructions.
In the third part, structural, data and program control hazards in CPU pipelines are
discussed. This section shows how to generate additional hardware (forwarding loops) to
overcome various hazards [4].
The last section of this chapter is devoted to explaining different types of cache memory
architectures, their operation and design trade-offs.
6.1
RISC Instruction Formats
In a RISC CPU, all instructions include an Operation Code (OPC) ﬁeld which instructs the
processor what to do with the rest of the ﬁelds in the instruction, and when to activate
different hardware components in the CPU to be able to execute the instruction. The OPC
ﬁeld is followed by one or more operand ﬁelds. Each ﬁeld either corresponds to a register
address in the Register File (RF) or contains immediate user data to process the instruction.
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9_6
275

There are three types of instructions in a RISC CPU: register-to-register-type,
immediate-type and jump-type.
A register-to-register-type instruction contains an OPC followed by three operands: two
source register addresses and one destination register address pointing the RF, namely RS1,
RS2 and RD. The format of this instruction is shown below.
OPC RS1; RS2; RD
This type of instruction fetches the contents of the ﬁrst and second source registers,
Reg[RS1] and Reg[RS2], from the RF, processes them according to the OPC, and writes the
result to the destination register, Reg[RD] in the RF. This operation is described below.
Reg RS1
½
 ðOPCÞ Reg RS2
½
 ! Reg RD
½

An immediate-type instruction contains an OPC followed by three operands: one source
register address, RS, one destination register address, RD, and an immediate data as shown
below.
OPC RS; RD; Imm Value
This type of instruction combines the contents of the source register, Reg[RS], with a
sign-extended immediate value according to the OPC, and writes the result to the destination
register, Reg[RD], in the RF. This operation is shown below.
Reg RS
½
 OPC
ð
Þ Immediate Value ! Reg RD
½

The jump-type instruction contains an OPC followed by an immediate value shown
below.
OPC Imm Value
This type of instruction uses the immediate ﬁeld to modify the contents of the Program
Counter (PC) for the instruction memory. The operation of this instruction is given below.
Immediate Value ! PC
All three instruction types ﬁt in a 32-bit wide instruction memory as shown Fig. 6.1. In
this ﬁgure, the numbers on top of each ﬁeld correspond to the bit positions of the instruction
memory, deﬁning the borders of the OPC or a particular operand ﬁeld.
276
6
Central Processing Unit

6.2
CPU Data-Path
A modern RISC CPU is composed of small and large size memories, such as Register File
(RF), instruction and data memories, and an ALU to execute an instruction. A Program
Counter (PC) generates an address for the instruction memory as shown in Fig. 6.2. Each
instruction is fetched from this memory and separated into OPC and operand ﬁelds.
The OPC ﬁeld guides the data-ﬂow through the rest of the CPU. The operand ﬁeld contains
either a number of RF addresses or the user data or the combination of the two. Once the
source and destination RF addresses become available at the output of the instruction
memory, the corresponding data is read from the RF and processed in the ALU according to
the OPC. The read function from the RF is achieved by simply disabling the write process to
the RF or Write Enable (WE) = 0. The processed data in the ALU is subsequently written
back to a destination address in the RF by WE = 1. On the other hand, if a particular
instruction needs to fetch data from the data memory instead of the RF, ﬁrst the ALU
calculates the effective memory address for the data memory. When data becomes available
at the output of the data memory, then the OPC decoder writes this data back to a destination
address in the RF by WE = 1. Sometimes, instructions contain a user-deﬁned immediate
value. This is separated from the rest of the operand ﬁelds and combined with the contents
of a source register, Reg[RS], in the ALU. The processed data is written back to the RF
by WE = 1.
31
OPC
RS1
RS2
RD
Not Used
26 25
21 20
16 15
11 10
0
31
OPC
RS
RD
Immediate Value/Not Used
26 25
21 20
16 15
0
31
OPC
Immediate Value/Not Used
26 25
0
Register-to-Register Type
Immediate Type
Jump Type
Fig. 6.1 Instruction ﬁeld formats
6.2
CPU Data-Path
277

Instructions can be executed in RISC CPUs in two ways. In a non-pipelined CPU
architecture, instructions are fetched from the instruction memory and processed through the
remaining four stages of the CPU in Fig. 6.2 before the CPU takes the next instruction. This
is shown in Fig. 6.3. In this ﬁgure, IF, RF, A, DM and WB represent the Instruction Fetch,
Register File access, ALU, Data Memory and Write-Back stages, respectively.
Non-pipelined structures are inefﬁcient in terms of data throughput but require lower clock
frequencies to operate. The CPU becomes more efﬁcient in terms of throughput if the archi-
tecture in Fig. 6.2 is subdivided into smaller functional stages where each stage is separated
from its neighboring stage by a ﬂip-ﬂop boundary that stores data (or address) only for one
clock cycle as shown in Fig. 6.4. In this ﬁgure, the CPU data-path consists ofﬁve stages where
individual tasks are executed in each stage within one clock cycle. According to this scheme,
the clock frequency becomes ﬁve times higher compared to the architecture in Fig. 6.2.
The ﬁrst stage of this new pipeline in Fig. 6.4 is the instruction memory access. In this
stage, each program instruction is fetched from the instruction memory and stored in the
instruction
register
at
the
ﬁrst
ﬂip-ﬂop
boundary.
This
architecture
supports
a
word-addressable instruction memory, and therefore requires the PC to increment by one.
Instruction 1
Instruction 2
Instruction 3
IF
RF
A
DM
WB
cycle 
1
cycle 
2
cycle 
3
IF
RF
A
DM
WB
IF
RF
A
DM
WB
NON-
PIPELINED
Fig. 6.3 A non-pipelined CPU timing table
PC
OPC Dec
A
L
U
Addr
Instruction
Memory
Ain
Dout
Register
File
RS1
RS2
Ain1
Ain2
Dout1
Dout2
Immediate value path
Din
RF
Imm
Ain
Dout
Data Memory bypass path
DM
BY
Data
Memory
WE
Ain3
WE
Fig. 6.2 A non-pipelined CPU
278
6
Central Processing Unit

Instruction Memory Stage
RF Stage
Data Memory Stage
Write-Back Stage
1st flip-flop 
boundary
ALU Stage
2nd flip-flop 
boundary
3rd flip-flop 
boundary
4th flip-flop 
boundary
PC
OPC Dec
A
L
U
Addr
Instruction
Memory
Ain
Dout
Register
File
RS1
RS2
Ain1
Ain2
Dout1
Dout2
Immediate value path
Din
RF
Imm
Ain
Dout
Data Memory bypass path
DM
BY
Data
Memory
WE
Ain3
WE
Fig. 6.4 A pipelined ﬁve-stage CPU
The next pipeline stage is the RF stage where the instruction OPC is separated from its
operands. The OPC is decoded in order to generate control signals to route the address and
data in the rest of the CPU. Operand ﬁelds are either source register addresses to access the
data in the RF or immediate data supplied by the user as mentioned earlier. If the operand
corresponds to an RF address, the data fetched from this address is loaded to the register that
resides at the second ﬂip-ﬂop boundary. If the operand is an immediate data, it is sign
extended to 32 bits before it is loaded to a register in the second ﬂip-ﬂop boundary.
The third stage of the CPU pipeline is the ALU stage. The data from the source registers
in the RF or the immediate data are processed in this stage according to the OPC and loaded
to the register at the third ﬂip-ﬂop boundary.
The fourth stage is the data memory stage. This stage either calculates an effective address
for the data memory or bypasses the data memory. If the instruction calls for loading or storing
data, the ALU calculates the data memory address to access its contents. Otherwise, the ALU
result simply bypasses the data memory and stored in a register at the fourth ﬂip-ﬂop boundary.
The last stage of the CPU pipeline is the write-back stage. In this stage, data is either
routed from the output of the data memory or from the bypass path to a designated desti-
nation address in the RF.
A pipelined RISC CPU’s efﬁciency and speed are shown in the timing table in Fig. 6.5.
This ﬁgure extends to 15 high frequency clock cycles, which is the equivalent to three low
frequency clock cycles in Fig. 6.3. The number of completed instructions in this new
pipeline is almost 12, which is four times larger than the number of instructions executed in a
non-pipelined CPU in Fig. 6.3. The difference between non-pipelined and pipelined CPU
efﬁciency only gets better as the number of instructions increases.
6.2
CPU Data-Path
279

The
next
section
of
this
chapter
examines
the
hardware
requirements
of
register-to-register-type, immediate-type and jump-type RISC instructions.
6.3
Fixed-Point Register-to-Register Type ALU Instructions
Fixed-point register-to-register type ALU instructions interact with the ALU only. The most
fundamental instruction in this category is the Add (ADD) instruction that contains the ADD
opcode, two source register addresses, RS1 and RS2, and a destination register address, RD,
as shown below.
ADD RS1; RS2; RD
This instruction fetches data from the source addresses, RS1 and RS2, adds them, and
returns the result to the destination address RD according to the equation below.
Reg RS1
½
 þ Reg RS2
½
 ! Reg RD
½

The ﬁeld format of this instruction in the instruction memory is shown in Fig. 6.6. The
numbers on top of each ﬁeld represent the OPC and operand boundaries.
Instruction 1
Instruction 2
Instruction 3
Instruction 4
Instruction 5
Instruction 6
IF
RF
A
DM
WB
cycle 
1
cycle 
2
cycle 
3
cycle 
4
cycle 
5
cycle 
6
cycle 
7
cycle 
8
cycle 
9
cycle 
10
cycle 
11
cycle 
12
cycle 
13
cycle 
14
cycle 
15
IF
RF
A
DM
WB
IF
RF
A
DM
WB
IF
RF
A
DM
WB
IF
RF
A
DM
WB
IF
RF
A
DM
WB
IF
RF
A
DM
WB
IF
RF
A
DM
WB
IF
RF
A
DM
WB
IF
RF
A
DM
WB
IF
RF
A
DM
WB
IF
RF
A
DM
WB
Instruction 7
Instruction 8
Instruction 9
Instruction 10
Instruction 11
Instruction 12
PIPELINED
Fig. 6.5 A pipelined CPU timing table
280
6
Central Processing Unit

The required hardware for the ADD instruction is shown in Fig. 6.7. In this ﬁgure, the PC
generates an address for the instruction memory and loads the contents of the ADD
instruction to the instruction register at the end of the ﬁrst clock cycle. Since the instruction
contains two source register addresses, RS1 and RS2, the contents of these registers,
Reg[RS1] and Reg[RS2], are read from the RF and stored at the second ﬂip-ﬂop boundary.
As mentioned earlier, the read function is achieved by disabling the write process to the RF
or WE = 0 during this cycle. In the third clock cycle, the ALU adds Reg[RS1] and Reg
[RS2], and stores the result at the third ﬂip-ﬂop boundary. In the fourth clock cycle, the ALU
result is written back to the destination register address, RD, in the RF. In this cycle, WE = 1
is generated by the OPC decoder to enable the write. No processing is done to RD, which
propagates from one stage to another without any modiﬁcation to point where the processed
ALU result needs to go in the RF.
31
ADD
RS1
RS2
RD
Not Used
26 25
21 20
16 15
11 10
0
Fig. 6.6 Fixed-point ADD instruction ﬁeld format
O
P
C
R
S
1
R
S
2
N
O
T
U
S
E
D
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut1
AIn3 DIn
clock
AIn
DOut
32
32
5
5
32
32
32
32
32
32
5
R
D
11
5
5
AIn2
DOut2
Instruction
Register
RS1
RS2
RD
Reg[RS1]
Reg[RS2]
Write-Back
Stage
PC
+1
D Q
clock
Reg[RS1] + Reg[RS2]
OPC DEC
D Q
clock
6
OPC
ADD
ADD OPC selects 
the fixed-point adder 
in the ALU
Instruction 
Memory Stage
RF
Stage
ALU
Stage
32
5
WE
ADD OPC produces WE = 1 for the RF
D Q
clock
Fig. 6.7 ADD instruction data-path
6.3
Fixed-Point Register-to-Register Type ALU Instructions
281

Since the ADD instruction does not require any data to be stored or fetched from the data
memory, the data memory stage is omitted from this data-path which reduces the number of
stages from ﬁve to four.
Similar to the ADD instruction, the Subtract (SUB) instruction subtracts the 32-bit data at
RS2 from the 32-bit data at RS1 and returns the result to RD. The instruction and its
operational equation are shown below.
SUB RS1; RS2; RD
Reg RS1
½
  Reg RS2
½
 ! Reg RD
½

The ﬁeld format of the SUB instruction in the instruction memory is the same as the ADD
instruction in Fig. 6.6 except the ADD OPC is replaced by SUB. This instruction also
follows the same data-path as the ADD instruction except the OPC selects the subtractor in
the ALU instead of the adder.
The ﬁxed-point Multiplication (MUL) instruction requires four operands as shown below.
This instruction multiplies the contents of RS1 and RS2 and generates a 64-bit result. The
lower and upper 32 bits of the result in curly brackets are written to RD1 and RD2,
respectively.
MUL RS1; RS2; RD1; RD2
Reg RS1
½
  Reg RS2
½
 ! Reg RD2
½
; Reg RD1
½

f
g
The ﬁeld format of this instruction in the instruction memory is shown in Fig. 6.8.
There are two ways to generate a data-path for this particular instruction. The ﬁrst method
executes this instruction using four pipeline stages and requires two RF write-back ports as
shown in Fig. 6.9. In this ﬁgure, the lower 32 bits of the multiplication result, MUL[31:0],
are written to the address RD1 while the higher 32 bits, MUL[63:32], are written to the
address RD2 in the RF. In the write-back cycle, WE = 1 is generated by the OPC decoder to
enable the two simultaneous writes.
31
MUL
RS1
RS2
RD2
Not Used
26 25
21 20
16 15
11 10
0
RD1
6 5
Fig. 6.8 Fixed-point MUL instruction ﬁeld format
282
6
Central Processing Unit

The second method writes the multiplication result back to the RF in two successive clock
cycles instead of one but does not require the RF to have two write-back ports. In this
scheme, the 64-bit multiplication result is divided between two distinct paths in the ALU as
shown in Fig. 6.10. The lower 32 bits, MUL[31:0], are written back into the RF at the end of
fourth cycle while the higher 32 bits, MUL[63:32], are stored at an additional ﬂip-ﬂop
boundary. The higher 32 bits are subsequently written back to the RF at the end of the ﬁfth
cycle.
O
P
C
R
S
1
R
S
2
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
RF
AIn1
DOut1
AInH
DInH
clock
AIn
DOut
32
5
5
32
32
32
32
64
5
5
R
D
2
11
5
64
5
5
AIn2
DOut2
Instruction
Register
RS1
RS2
RD2
Reg[RS1]
Reg[RS2]
Write-Back
Stage
Reg[RS1] x Reg[RS2]
R
D
1
10
6
5
DInL
AInL
D Q
clock
D Q
clock
5
MUL [63:0]
32
MUL[31:0]
32
MUL[63:32]
5
RD1
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
MUL
MUL OPC selects 
the fixed-point multiplier 
in the ALU
Instruction Memory
Stage
RF
Stage
ALU
Stage
MUL OPC produces WE = 1 for the RF
WE
D Q
clock
Fig. 6.9 Data-path for ﬁxed-point multiplication using two write-back ports
6.3
Fixed-Point Register-to-Register Type ALU Instructions
283

The And (AND) instruction bitwise “ANDs” the contents of RS1 and RS2, and returns the
result to the address RD in the RF. Again in the fourth cycle, WE = 1 is generated by the
OPC decoder to enable the write. The operational equation of this instruction contains the
“&” sign to indicate that this is an AND operation. The ﬁeld format of this instruction is
shown in Fig. 6.11.
AND RS1; RS2; RD
Reg RS1
½
 & Reg RS2
½
 ! Reg RD
½

The AND instruction data-path in Fig. 6.12 is identical to the ADD or SUB instruction
data-paths except for the ALU which requires 32 sets of two-input AND gates to carry out
the instruction.
O
P
C
R
S
1
R
S
2
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut1
DIn
clock
AIn
DOut
32
5
5
32
32
32
32
32L
5
R
D
2
11
5
32
5
5
5
AIn2
DOut2
Instruction
Register
RS1
RS2
RD2
Reg[RS1]
Reg[RS2]
Write-Back
Stage
R
D
1
10
6
5
AIn
D Q
clock
D Q
clock
5
MUL[31:0]
32
5
RD1
D Q
clock
32
64
32H
MUL[63:32]
D Q
clock
32
1
0
D Q
clock
1
0
5
5
32
DELAY
DELAY
MUL
MUL
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
MUL
MUL OPC selects the fixed-point multiplier in the ALU
Instruction Memory
Stage
RF
Stage
ALU
Stage
Fig. 6.10 Data-path for ﬁxed-point multiplication using a single write-back port (WE signal
to RF is not shown for clarity)
31
AND
RS1
RS2
RD
Not Used
26 25
21 20
16 15
11 10
0
Fig. 6.11 Fixed-point AND instruction ﬁeld format
284
6
Central Processing Unit

The Or (OR), Exclusive Or (XOR), Nand (NAND), Nor (NOR) and Exclusive Nor
(XNOR) instructions have identical instruction formats except the opcode ﬁeld. These
operations are shown below.
OR RS1, RS2, RD
Reg[RS1] | Reg[RS2] ! Reg[RD]
XOR RS1, RS2, RD
Reg[RS1] ^ Reg[RS2] ! Reg[RD]
NAND RS1, RS2, RD
Reg[RS1] *& Reg[RS2] ! Reg[RD]
NOR RS1, RS2, RD
Reg[RS1] *| Reg[RS2] ! Reg[RD]
O
P
C
R
S
1
R
S
2
N
O
T
U
S
E
D
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut1
AIn3 DIn
clock
AIn
DOut
32
32
5
5
32
32
32
32
32
32
5
R
D
11
5
5
AIn2
DOut2
Instruction
Register
RS1
RS2
RD
Reg[RS1]
Reg[RS2]
Write-Back
Stage
PC
+1
D Q
clock
Reg[RS1] & Reg[RS2]
OPC DEC
D Q
clock
6
OPC
AND
AND OPC selects 
32 2-bit AND gates 
in the ALU
Instruction 
Memory Stage
RF 
Stage
ALU Stage
32
5
AND OPC produces WE = 1 for the RF
WE
D Q
clock
Fig. 6.12 AND instruction data-path
6.3
Fixed-Point Register-to-Register Type ALU Instructions
285

XNOR RS1, RS2, RD
Reg[RS1] *^ Reg[RS2] ! Reg[RD]
Here, “|” and “^” signs refer to the OR and XOR operations, respectively. The “*” sign
corresponds to negation and generates a complemented value. Therefore, “*&”, “*|” and
“*^” operations denote the bitwise-NAND, NOR and XNOR, respectively.
The OR, XOR, NAND, NOR and XNOR instructions follow the same, four-stage
data-path as the AND instruction in Fig. 6.12. However, each logical instruction requires
different types of logic gates in the ALU stage, and the OPC ﬁeld selects which to use.
Another important register-to-register type instruction is the shift instruction. The Shift
Left (SL) instruction shifts the contents of RS1 to the left by the amount stored at the address
RS2, and returns the result to RD. The format and the operation of this instruction are shown
below. The “” sign indicates left-shift operation. This instruction’s ﬁeld format is similar
to the previous register-to-register-type instructions as shown in Fig. 6.13.
SL RS1; RS2; RD
Reg RS1
½
  Reg RS2
½
 ! Reg RD
½

The Shift Right (SR) instruction is similar to the SL instruction except the contents of RS1
are shifted to the right by the amount indicated in RS2. The “” sign corresponds to the SR
operation.
SR RS1; RS2; RD
Reg RS1
½
  Reg RS2
½
 ! Reg RD
½

Both the SL and SR instructions require linear shifters in the ALU. These units are large
combinational logic blocks that are predominantly made out of multiplexers as examined in
Chapter
1.
Both
of
these
instructions
follow
the
same
data-path
as
any
other
register-register-type instructions with three operands. Figure 6.14 shows the combined
data-path for the SL and SR instructions. The ALU stage contains both a left and a right
linear shifter. The ﬁrst input, Reg[RS1], represents the value to be shifted to the right or to
the left. The second input, Reg[RS2], speciﬁes the amount to be shifted in number of bits.
Even though the ALU executes both the left and right-shifted versions of Reg[RS1]
simultaneously, only one result is selected by the OPC and written back to the RF. If the
instruction is a SR instruction, then OPC selects port 0 of the 2-1 MUX, and the SR result is
written to the RF. Otherwise, the OPC selects port 1, and the SL result is written to the RF.
31
SL
RS1
RS2
RD
Not Used
26 25
21 20
16 15
11 10
0
Fig. 6.13 Fixed-point Shift-Left (SL) instruction ﬁeld format
286
6
Central Processing Unit

Both the SL and SR instructions require a four-stage CPU pipeline. In the write-back cycle,
WE = 1 is generated by the OPC decoder to enable the write.
As an example, we can combine the individual data-paths for ADD, SUB, AND, NAND,
OR, NOR, XOR, XNOR, SL and SR instructions in a single CPU to execute a user program.
The architecture in Fig. 6.15 shows eight individual functional units in the ALU followed by
an 8-1 MUX to select the desired ALU output. In this ﬁgure, there is only one adder, and it is
able to execute a two’s complement addition to perform subtraction. The left and right linear
shifters are also combined in a single unit as in Fig. 6.14. The SL or SR opcode selects the
output of either the left shifter or the right shifter for the destination register. The outputs of
all logical units are selected by an 8-1 MUX and forwarded to the RF.
O
P
C
R
S
1
R
S
2
N
O
T
U
S
E
D
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut1
AIn3 DIn
clock
AIn
DOut
32
5
5
32
32
32
32
32
32
5
R
D
11
5
32
5
5
AIn2
DOut2
Instruction
Register
RS1
RS2
RD
Reg[RS1]
Reg[RS2]
SL
Write-Back
Stage
SR
0
1
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
SL, SR
SL OPC selects port 1
SR OPC selects port 0
ALU
Stage
RF
Stage
Instruction Memory
Stage
2
SL or SR OPC produces WE = 1 for the RF
WE
D Q
clock
Fig. 6.14 SL and SR instruction data-paths
6.3
Fixed-Point Register-to-Register Type ALU Instructions
287

O
P
C
R
S
1
R
S
2
N
O
T
U
S
E
D
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut1
AIn3 DIn
clock
AIn
DOut
32
5
5
32
32
32
5
R
D
11
5
5
5
AIn2
DOut2
Instruction
Register
RS1
RS2
RD
Reg[RS1]
Reg[RS2]
SHIFT
SUB
Cin
0
1
SUB
0
1
S/A
AND
NAND
OR
NOR
XOR
XNOR
SH
0
1
32
32
SL, SR
Write-Back
Stage
Reg[RS1]   OPC   Reg[RS2]
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
ADD, SUB selects S/A port, 
AND, NAND, OR, NOR, XOR, XNOR select the corresponding ports, 
SL, SR select SH port
10
ALU
Stage
RF
Stage
Instruction Memory
Stage
All OPCs produce WE = 1 for the RF
WE
D Q
clock
Fig. 6.15 Combined register-to-register ALU instruction data-paths
288
6
Central Processing Unit

The next category of register-register-type instructions are the Set instructions used in
decision-making situations where two source register values are compared against each other
prior to a branch instruction.
The Set-Greater-than-or-Equal (SGE) instruction below describes setting the contents of
RD to 0x00000001 if the contents of RS1 are found to be greater than or equal to the
contents of RS2. The data in RS1 and RS2 registers are considered unsigned integers. If the
comparison fails, then the contents of RD are set to 0x00000000. The ﬁeld format of this
instruction is given in Fig. 6.16.
SGE RS1; RS2; RD
If Reg RS1
½
  Reg RS2
½
 then 1 ! Reg RD
½
 else 0 ! Reg RD
½

The data-path for the SGE instruction in Fig. 6.17 tests if the contents of RS1 are greater
than or equal to the contents of RS2 using a subtractor in the ALU. Again, the data in RS1
and RS2 registers are considered unsigned integers. To perform this test, Reg[RS1] is
subtracted from Reg[RS2], and the sign bit of the result is used to make the decision. If Reg
[RS1] is greater than or equal to Reg[RS2], the sign bit becomes zero. The complemented
31
SGE
RS1
RS2
RD
Not Used
26 25
21 20
16 15
11 10
0
Fig. 6.16 Fixed-point Set-Greater-than-or-Equal (SGE) instruction ﬁeld format
O
P
C
R
S
1
R
S
2
N
O
T
U
S
E
D
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut1
AIn3
DIn
clock
AIn
DOut
32
5
5
32
32
32
32
5
R
D
11
5
1
5
5
AIn2
DOut2
Instruction
Register
RS1
RS2
RD
Reg[RS1]
Reg[RS2]
Sign Bit
Sign Bit
Write-Back
Stage
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
SGE
SGE OPC selects 
the fixed-point subtractor in the ALU
0
1
0..00
0..01
32
32
ALU
Stage
RF
Stage
Instruction Memory
Stage
Fig. 6.17 SGE instruction data-path (WE signal to RF is not shown for clarity)
6.3
Fixed-Point Register-to-Register Type ALU Instructions
289

sign bit is then forwarded to the 2-1 MUX at the write-back port of the RF to store
0x00000001 in the destination register. If the subtraction yields a negative number, the
complemented sign bit selects 0x00000000 to be stored in the RD.
The Set-Greater-Than (SGT) instruction is another instruction that tests if Reg[RS1] is
greater than Reg[RS2]. If the comparison is successful, the instruction stores 0x00000001 in
the RD. Otherwise, the instruction stores 0x00000000 as described below.
SGT RS1; RS2; RD
If Reg RS1
½
 [ Reg RS2
½
 then 1 ! Reg RD
½

else 0 ! Reg RD
½

The data-path of the SGT instruction is shown in Fig. 6.18. In this ﬁgure, two tests are
performed in the ALU stage. The ﬁrst test checks if Reg[RS1] is greater than or equal to Reg
[RS2] using the sign bit of the subtractor as was done for the SGE instruction. The second
test checks if Reg[RS1] is not equal to Reg[RS2] using 32 sets of two-input XNOR gates
followed by a single 32-input NAND gate. Both of these tests form the input to a two-input
AND gate in the ALU, which then produces the selector input for the 2-1 MUX in the
write-back stage to test the SGT condition. If Reg[RS1] > Reg[RS2], then port 1 of the 2-1
MUX is selected to store 0x00000001 in RD. Otherwise, port 0 is selected to store
0x00000000.
Similar to the SGE and SGT instructions, there are four other set instructions that compare
the contents of the two source registers in a variety of different ways to set or reset the
destination register. The Set-Less-than-or-Equal (SLE), Set-Less-Than (SLT), Set-Equal
(SEQ) and Set-Not-Equal (SNE) instructions and how they operate in the CPU are listed below.
SLE RS1; RS2; RD
If Reg RS1
½
  Reg RS2
½
 then 1 ! Reg RD
½

else 0 ! Reg RD
½

SLT RS1; RS2; RD
If Reg RS1
½
\Reg RS2
½
 then 1 ! Reg RD
½

else 0 ! Reg RD
½

SEQ RS1; RS2; RD
If Reg RS1
½
 ¼ Reg RS2
½
 then 1 ! Reg RD
½

else 0 ! Reg RD
½

SNE RS1; RS2; RD
If Reg RS1
½
 6¼ Reg RS2
½
 then 1 ! Reg RD
½

else 0 ! Reg RD
½

All Set instructions require four clock cycles to write the result to the RF like all the other
register-to-register-type instructions.
290
6
Central Processing Unit

O
P
C
R
S
1
R
S
2
N
O
T
U
S
E
D
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut1
AIn3
DIn
clock
AIn
DOut
32
5
5
32
32
32
5
R
D
11
5
1
5
5
AIn2
DOut2
Instruction
Register
RS1
RS2
RD
Reg[RS1]
Reg[RS2]
The complemented sign bit 
tests GTE condition
0
1
0..00
This bit selects port 1 if SGT comparison is successful else selects port 0 
32
Write-Back
Stage
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
SGT
SGT OPC selects the fixed-point subtractor in the ALU
0..01
32
32
32
ALU
Stage
RF
Stage
Instruction Memory 
Stage
This bit tests Not Equal condition
sign bit
Fig. 6.18 SGT instruction data-path (WE signal to RF is not shown for clarity)
6.3
Fixed-Point Register-to-Register Type ALU Instructions
291

6.4
Fixed-Point Immediate Type ALU Instructions
Immediate ALU instructions allow user data to be included in the instruction. However,
these instructions still fetch register data from the RF to be combined with the user data.
The Add-Immediate instruction (ADDI) adds the contents of RS to the user-supplied
16-bit immediate value and returns the result to RD in the RF. This instruction and how it
operates in the CPU are shown below. The ﬁeld format of this instruction in the instruction
memory is given in Fig. 6.19.
ADDI RS; RD; Imm Value
Reg RS
½
 þ Immediate Value ! Reg RD
½

The ADDI instruction data-path is shown in Fig. 6.20. In this ﬁgure, the contents of the
instruction are transferred from the instruction memory to the instruction register at the end
31
ADDI
RS
RD
Immediate Value
26 25
21 20
16 15
0
Fig. 6.19 Fixed-point ADD Immediate (ADDI) instruction ﬁeld format
O
P
C
R
S
R
D
I
m
m
V
a
l
u
e
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut
AIn2 DIn
clock
AIn
DOut
32
5
5
32
32
5
5
5
Instruction
Register
RS
RD
Reg[RS]
Reg[RS] + Imm Value
32
32
D Q
clock
SEXT
Imm Value
32
16
16
Write-Back
Stage
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
ADDI
ADDI OPC selects 
the fixed-point adder 
in the ALU
ALU
Stage
RF
Stage
Instruction Memory 
Stage
ADDI OPC produces WE = 1 for the RF
WE
D Q
clock
Fig. 6.20 ADDI instruction data-path
292
6
Central Processing Unit

of the ﬁrst clock cycle. In the second clock cycle, the 16-bit immediate value in the
instruction is sign extended to 32 bits while the contents of RS are fetched from the RF. In
the third clock cycle, the two values are added in the ALU. At the end of the fourth cycle, the
processed data is written back to the RF at the address RD. Therefore the ADDI instruction
requires only four clock cycles to execute.
The Subtract-Immediate instruction (SUBI) behaves similarly to the ADDI, but it subtracts
the immediate value from the contents of RS, and returns the result to RD as illustrated below.
SUBI RS; RD; Imm Value
Reg RS
½
  Immediate Value ! Reg RD
½

There are also immediate logical instructions that operate with the user data. The
AND-Immediate (ANDI) instruction, for example, bitwise ANDs the contents of RS with the
immediate value and returns the result to RD as shown below. The ﬁeld format of this
instruction is given in Fig. 6.21.
31
ANDI
RS
RD
Immediate Value
26 25
21 20
16 15
0
Fig. 6.21 Fixed-point AND Immediate (ANDI) instruction ﬁeld format
ANDI RS; RD; Imm Value
Reg RS
½
 & Immediate Value ! Reg RD
½

The ANDI instruction uses a similar data-path to the ADDI instruction, but replaces the
ﬁxed-point adder with 32 two-input AND gates as shown in Fig. 6.22. The contents of RS
and the sign-extended immediate value are combined using the AND gates, and the result is
returned to RD in the RF.
Similar to the ANDI instruction, the ORI, XORI, NANDI, NORI, and XNORI instructions
operate with the immediate data and follow the same data-path as the ANDI instruction.
These instructions and how they operate in the CPU are listed below.The Or (OR), Exclusive
Or (XOR), Nand (NAND), Nor (NOR) and Exclusive Nor (XNOR) instructions have iden-
tical instruction formats except the opcode ﬁeld. These operations are shown below.
ORI RS, RD, Imm Value
Reg[RS] | Immediate Value ! Reg[RD]
XORI RS, RD, Imm Value
Reg[RS] ^ Immediate Value ! Reg[RD]
NANDI RS, RD, Imm Value
Reg[RS] *& Immediate Value ! Reg[RD]
6.4
Fixed-Point Immediate Type ALU Instructions
293

NORI RS, RD, Imm Value
Reg[RS] *| Immediate Value ! Reg[RD]
XNORI RS, RD, Imm Value
Reg[RS] *^ Immediate Value ! Reg[RD]
All logical immediate instructions require four cycles to form the result.
The Shift Left Immediate (SLI) and Shift Right Immediate (SRI) instructions use the same
functional units as the SL and SR instructions in the ALU.
The SLI instruction fetches the contents of RS from the RF, shifts it to the left by the
user-deﬁned immediate value, and stores the result in RD as indicated below. Figure 6.23
shows the ﬁeld format of this instruction.
O
P
C
R
S
R
D
I
m
m
V
a
l
u
e
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut
AIn2 DIn
clock
AIn
DOut
32
5
5
32
32
5
5
5
Instruction
Register
RS
RD
Reg[RS]
Reg[RS] & Imm Value
32
32
D Q
clock
SEXT
Imm Value
32
16
16
Write-Back
Stage
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
ANDI
ANDI OPC selects 
32 2-bit AND gates 
in the ALU
ALU
Stage
RF
Stage
Instruction Memory 
Stage
ANDI OPC produces WE = 1 for the RF
WE
D Q
clock
Fig. 6.22 ANDI instruction data-path
31
SLI
RS
RD
Immediate Value
26 25
21 20
16 15
0
Fig. 6.23 Fixed-point SL Immediate (SLI) instruction ﬁeld format
294
6
Central Processing Unit

SLI RS; RD; Imm Value
Reg RS
½
  Immediate Value ! Reg RD
½

Similar to the SLI instruction, the SRI instruction shifts the contents of RS to the right by
an amount equal to the immediate value, and stores the result in RD as shown below.
SRI RS; RD; Imm Value
Reg RS
½
  Immediate Value ! Reg RD
½

The SLI and SRI instruction data-paths in Fig. 6.24 still require the left and right linear
shifters in the ALU stage. In these instructions, one shifter input receives the immediate data
that speciﬁes the number of bits to shift to the left or to the right while the other input
receives the contents of RS.
O
P
C
R
S
R
D
I
m
m
V
a
l
u
e
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut
AIn2 DIn
clock
AIn
DOut
32
5
32
32
5
5
5
Instruction
Register
RS
RD
Reg[RS]
32
5
0
16
Imm Value
SEXT
32
16
Write-Back
Stage
SR
SL
0
1
32
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
SLI, SRI OPCs
SRI OPC selects port 0 
SLI OPC selects port 1
ALU
Stage
RF
Stage
Instruction Memory
Stage
SRI or SLI OPCs produce WE = 1 for the RF
WE
D Q
clock
Fig. 6.24 SLI and SRI instruction data-paths
Figure 6.25 combines all the immediate ALU instructions examined so far in one sche-
matic. These include the ADDI, SUBI, SLI, SRI, ANDI, ORI, XORI, NANDI, NORI and
XNORI instructions with their sign-extended input. The port selection process at the
ALU MUX is as follows: if the OPC is ADDI or SUBI, the adder/subtractor output is routed
through the S/A port; for the SLI and SRI OPCs, the shifter outputs are routed through the
SH port; for the remaining OPCs, the processed data is routed through the corresponding
MUX port carrying the same name as the OPC and becomes the ALU output.
6.4
Fixed-Point Immediate Type ALU Instructions
295

O
P
C
R
S
R
D
I
m
m
V
a
l
u
e
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut1
AIn3 DIn
clock
AIn
DOut
32
5
5
32
32
5
5
5
Instruction
Register
RS
RD
Reg[RS]
Reg[RS]  OPC  Imm Value
SHIFT
SUBI
Cin
0
1
SUBI
0
1
S/A
AND
NAND
OR
NOR
XOR
XNOR
SH
0
1
32
32
SLI, SRI
D Q
clock
SEXT
Imm Value
32
16
16
Write-Back
Stage
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
ADDI, SUBI OPCs select port S/A
SLI, SRI OPCs select port SH
ANDI, NANDI, ORI, NORI, XORI, XNORI OPCs select 
the ports with the same name in the ALU MUX
10
ALU
Stage
RF
Stage
Instruction Memory
Stage
All OPCs produce WE = 1 for the RF
WE
D Q
clock
Fig. 6.25 Combined Immediate ALU instruction data-paths
296
6
Central Processing Unit

The set-immediate instructions compare the contents of RS with an immediate value for
setting or resetting the register RD.
The Set-Greater-than-or-Equal-Immediate (SGEI) instruction sets the contents of RD if
the instruction ﬁnds the contents of RS to be greater than or equal to the immediate value.
This instruction and how it operates in the CPU is shown below. The ﬁeld format is given in
Fig. 6.26.
SGEI RS; RD; Imm Value
If Reg RS
½
  Immediate Value then 1 ! Reg RD
½
 else 0 ! Reg½RD
The SGEI instruction data-path in Fig. 6.27 tests the relative magnitudes of Reg[RS] and
the sign-extended immediate value to make a decision about the contents of RD. If Reg[RS]
is larger than the immediate value or equal to it, the sign bit of the ALU result becomes zero,
which in turn, stores 0x00000001 into RD. Otherwise, RD becomes 0x00000000.
31
SGEI
RS
RD
Immediate Value
26 25
21 20
16 15
0
Fig. 6.26 Fixed-point SGE Immediate (SGEI) instruction ﬁeld format
O
P
C
R
S
R
D
I
M
M
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Instruction
Memory
Register
File
AIn1
DOut1
AIn2
DIn
clock
AIn
DOut
32
5
16
32
32
32
5
5
1
5
5
DOut2
Instruction
Register
RS
RD
Reg[RS]
Imm Value
Sign Bit
Sign Bit
SEXT
32
16
Write-Back
Stage
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
SGEI
SGEI OPC selects 
the fixed-point subtractor in the ALU
32
0
1
0..00
0..01
32
32
ALU
Stage
RF
Stage
Instruction Memory
Stage
Fig. 6.27 SGEI instruction data-path (WE signal to RF is not shown for clarity)
6.4
Fixed-Point Immediate Type ALU Instructions
297

Similarly,
the
instruction
format
for
the
Set-Greater-Than-Immediate
(SGTI),
Set-Less-than-or-Equal-Immediate
(SLEI),
Set-Less-Than-Immediate
(SLTI),
Set-Equal-Immediate (SEQI) and Set-Not-Equal-Immediate (SNEI) instructions and how
they operate in the CPU are given below.
SGTI RS; RD; Imm Value
If Reg RS
½
 [ Immediate Value then 1 ! Reg RD
½

else 0 ! Reg RD
½

SLEI RS; RD; Imm Value
If Reg RS
½
  Immediate Value then 1 ! Reg RD
½

else 0 ! Reg RD
½

SLTI RS; RD; Imm Value
If Reg RS
½
\Immediate Value then 1 ! Reg RD
½

else 0 ! Reg RD
½

SEQI RS; RD; Imm Value
If Reg RS
½
 ¼ Immediate Value then 1 ! Reg RD
½

else 0 ! Reg RD
½

SNEI RS; RD; Imm Value
If Reg RS
½
 6¼ Immediate Value then 1 ! Reg RD
½

else 0 ! Reg RD
½

All Set Immediate instructions require four clock cycles to store the result in RD.
6.5
Data Movement Instructions
The ﬁrst data movement instruction that relocates data from the data memory to a register in the
RF is the Load (LOAD) instruction. This instruction ﬁrst adds the contents of RS to a
user-deﬁned immediate value to form an effective data memory address. It then fetches the data
at this address and moves it to a destination register, RD, in the RF. This instruction and how it
operates in the CPU is shown below. The term, Reg[RS] + Imm Value, deﬁnes the effective data
memory address, and mem{Reg[RS] + Imm Value} corresponds to the data at this address. The
ﬁeld format of this instruction while it is in the instruction memory is given in Fig. 6.28.
LOAD RS; RD; Imm Value
mem Reg RS
½
 þ Immediate Value
f
g ! Reg RD
½

31
LOAD
RS
RD
Immediate Value
26 25
21 20
16 15
0
Fig. 6.28 Fixed-point LOAD instruction ﬁeld format
The LOAD instruction data-path in Fig. 6.29 adds the contents of RS to the sign-extended
immediate value and uses this sum as an address for the data memory. The OPC selects the
298
6
Central Processing Unit

O
P
C
R
S
R
D
I
m
m
V
a
l
u
e
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
SEXT
Instruction
Memory
Data
Memory
Register
File
AIn
DOut
AIn1
DOut
AIn2 DIn
clock
AIn
DOut
32
5
16
5
32
16
32
32
32
32
32
32
32
5
Instruction
Register
RS
Reg[RS]
Imm Value
Reg[RS] + Imm
mem {Reg[RS] + Imm}
RD
32
5
5
5
32
PC
+1
D Q
clock
OPC DEC
D Q
clock
6
OPC
LOAD
OPC LOAD selects 
the adder in the ALU
Write-Back
Stage
ALU
Stage
RF
Stage
Instruction Memory 
Stage
Data Memory 
Stage
D Q
clock
RE
WE
D Q
clock
OPC LOAD produces WE = 1 for the RF
Fig. 6.29 LOAD instruction data-path
6.5
Data Movement Instructions
299

adder in the ALU to calculate the effective data memory address and enables the data
memory for read. The data read from the memory is subsequently written back to the RF at
the address RD by WE = 1. This instruction requires ﬁve clock cycles to complete, and it
traces through all ﬁve stages of the CPU.
The Store (STORE) instruction moves data in the opposite direction of the LOAD
instruction. This instruction uses the contents of RD and the immediate value to form a data
memory address, and moves the contents of RS to this address as described below. Fig-
ure 6.30 shows this instruction’s ﬁeld format.
STORE RS; RD; Imm Value
Reg RS
½
 ! mem Reg RD
½
 þ Immediate Value
f
g
The data-path for the STORE instruction is shown in Fig. 6.31. In this ﬁgure, the OPC
selects the adder in the ALU to perform an add operation between the sign-extended
immediate value and Reg[RD]. The OPC then enables the data memory to write the contents
of RS at this calculated address. The STORE instruction needs only four clock cycles to
complete.
The Move (MOVE) instruction does not interact with the data memory. Nevertheless, it
moves data from one register to another in the RF. The instruction and how it operates in the
CPU are given below. The bit ﬁeld format for the MOVE instruction is shown in Fig. 6.32.
MOVE RS; RD
Reg RS
½
 ! Reg RD
½

The Move Immediate (MOVEI) instruction moves an immediate value to a destination
register, RD, in the RF as shown below. The bit ﬁeld format of this instruction is given in
Fig. 6.33.
31
STORE
RS
RD
Immediate Value
26 25
21 20
16 15
0
Fig. 6.30 Fixed-point STORE instruction ﬁeld format
300
6
Central Processing Unit

O
P
C
R
S
R
D
I
m
m
V
a
l
u
e
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
SEXT
Instruction
Memory
Data
Memory
Register
File
AIn
AIn1
DOut1
AIn2
clock
AIn
DOut
32
5
16
5
32
16
32
32
32
32
32
D Q
clock
D Q
clock
32
32
DIn
DOut2
RS
RD
Reg[RS]
Reg[RD]
Imm Value
Reg[RD] + Imm Value
32
PC
+1
D Q
clock
OPC DEC
6
OPC
Instruction
  Register
WE
OPC STORE selects the 
adder in the ALU
D Q
clock
D Q
clock
ALU
Stage
RF
Stage
Instruction Memory 
Stage
Data Memory 
Stage
OPC STORE produces
WE = 1 for Data Memory
Fig. 6.31 STORE instruction data-path
6.5
Data Movement Instructions
301

MOVEI Imm Value; RD
Immediate Value ! Reg RD
½

The schematic in Fig. 6.34 combines the data-paths of all data movement instructions
discussed above except MOVEI. The data memory address is selected between {Reg[RS] +
Imm} and {Reg[RD] + Imm} by a 2-1 MUX at the input of the adder depending on the
OPC. Another 2-1 MUX at the write-back stage selects between the contents of RS for the
MOVE instruction and the contents of data memory for the LOAD instruction before the
result is written back to the RF.
6.6
Program Control Instructions
To be able to make decisions in a program, we need program control instructions.
The Branch (BRA) instruction is one of the most essential instructions in a program as it
controls direction of the program ﬂow. This instruction ﬁrst compares the contents of RS
with a ﬁve-bit RS value speciﬁed by the user. If the comparison is successful, the BRA
instruction redirects the program to fetch an instruction from a different PC address as shown
below. This new PC address is calculated by incrementing the old PC address by an
immediate value speciﬁed by the user. If the comparison is not successful, the program skips
the next instruction, but it executes the instruction after next. This instruction’s ﬁeld format
is shown in Fig. 6.35.
BRA RS; RS Value; Imm Value
If Reg RS
½
 ¼ RS Value
then
PC þ Immediate Value ! PC
else
PC þ 2 ! PC
The BRA instruction usually depends on a previously stored data value in the RF as a
result of a Set or Set-Immediate instruction. To be able to carry out the BRA instruction, ﬁrst
the contents of RS is compared with the RS Value. The comparator in Fig. 6.36 is composed
31
MOVE
RS
RD
Not Used
26 25
21 20
16 15
0
Fig. 6.32 Fixed-point MOVE instruction ﬁeld format
31
MOVEI
Not Used
RD
Immediate Value
26 25
21 20
16 15
0
Fig. 6.33 Fixed-point MOVEI instruction ﬁeld format
302
6
Central Processing Unit

O
P
C
R
S
R
D
I
m
m
V
a
l
u
e
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
SEXT
Instruction
Memory
Data
Memory
Register
File
AIn
DOut
AIn1
DOut1
AIn3 DIn
clock
AIn
DOut
32
5
16
5
32
16
32
32
32
32
32
32
32
5
Instruction
Register
RS
Reg[RS]
Imm Value
RD
32
5
5
D Q
clock
32
Reg[RD]
D Q
clock
32
32
DIn
32
STORE OPC
1
0
D Q
clock
MOVE OPC
1
0
32
AIn2
DOut2
32
PC
+1
D Q
clock
OPC DEC
6
OPC
D Q
clock
D Q
clock
D Q
clock
D Q
clock
Write-Back
Stage
ALU
Stage
RF
Stage
Instruction Memory 
Stage
Data Memory 
Stage
MOVE OPC selects port 1
Others select port 0
LOAD OPC selects port 1
Others select port 0
LOAD and STORE OPCs 
select the adder in the ALU
WE
MOVE or LOAD OPCs produces WE = 1 for the RF
LOAD OPC
D Q
clock
D Q
clock
WE
STORE OPC produces 
WE = 1 for Data memory
LOAD OPC
Fig. 6.34 Data movement instruction data-paths (MOVE, LOAD and STORE)
6.6
Program Control Instructions
303

of 32 two-input XNOR gates to perform a bitwise comparison between Reg[RS] and the
unsigned (positive) RS Value. All 32 XNOR outputs are then fed to a 32-input AND gate to
make a decision for the new PC value. If the comparison is successful, the current PC value
is replaced with (PC + Imm Value). If the comparison is unsuccessful, however, the PC
value is incremented by (PC + 2). The reason for (PC + 2) is because the PC increments by
two by the time a new value forms at the input of the PC. In actuality, the instruction
following the BRA instruction at (PC + 1) already enters the pipeline. However, this
instruction needs to be independent of the branch instruction. To be able to execute this
instruction (following the BRA instruction) and to remove the pending hazard, the compiler
either inserts a No Operation (NOP) instruction right after the BRA instruction or ﬁnds an
unrelated instruction in the program and inserts it at the (PC + 1) location.
31
BRA
RS
RS Value
Immediate Value
26 25
21 20
16 15
0
Fig. 6.35 Fixed-point BRANCH instruction ﬁeld format
O
P
C
R
S
R
S
V
a
l
u
e
I
m
m
V
a
l
u
e
0
15
16
20
21
25
26
31
Instruction
Memory
Register
File
AIn
DOut
clock
AIn
DOut
32
5
16
32
Instruction
Register
RS
Reg[RS]
Imm Value
SEXT
32
16
D Q
clock
32
32
PC + Imm Value
32
32
00..0
27
5
32
+1
D Q
clock
0
1
PC
OPC DEC
6
OPC
BRA OPC
32
Successful comparison between RS Value and Reg[RS] selects port 1 else port 0 is selected
Instruction Memory 
Stage
RF
Stage
Fig. 6.36 BRA instruction data-path
Unconditional decisions in the program do not need a comparison. The programmer can
simply change the ﬂow of the program by using a jump-type instruction.
304
6
Central Processing Unit

The ﬁrst unconditional jump-type instruction is the Jump (JUMP) instruction which
simply replaces the current PC value with an immediate value as shown below. Its ﬁeld
format is shown in Fig. 6.37.
JUMP Imm Value
Immediate Value ! PC
Thedata-pathfortheJUMPinstructionisshowninFig.6.38.Inthisdata-path,the26-bitjump
value is an unsigned integer extended to 32 bits before being forwarded to the PC. However, the
PC value has already incremented once by the time the immediate value from the instruction
register replaces the current value at the input of the PC. In the next clock cycle, this immediate
value transmits to the output of the PC, pointing a different instruction memory location, instead
of (PC + 2). Therefore, this instruction also creates a control hazard when the CPU fetches an
instruction at (PC + 1) and requires compiler’s intervention to remove the hazard.
31
JUMP
Immediate Value
26 25
0
Fig. 6.37 Fixed-point JUMP instruction ﬁeld format
O
P
C
I
m
m
V
a
l
u
e
0
25
26
31
Instruction
Memory
clock
AIn
DOut
32
26
32
Instruction
Register
Imm Value
000000
6
32
+1
D Q
clock
0
1
OPC
DEC
JUMP OPC selects port 1 
else port 0 is selected
6
OPC
{000000, Imm Value}
PC
Fig. 6.38 JUMP instruction data-path
6.6
Program Control Instructions
305

The second unconditional jump-type instruction is the Jump Register (JREG) instruction,
which is similar to the JUMP instruction, but uses the contents of RS to replace the current
PC value as shown below. Figure 6.39 describes this instruction’s bit ﬁeld format.
JREG RS
Reg RS
½
 ! PC
The data-path for the JREG instruction is shown in Fig. 6.40. This instruction reads the
contents of RS and loads it to the PC as the jump value. The program control hazard also
exists for this instruction. The hazard can be removed either by inserting a NOP instruction
or another unrelated instruction in the program after the JREG instruction.
31
JREG
RS
Not Used
26 25
21 20
0
Fig. 6.39 Describes this instruction’s bit ﬁeld format
O
P
C
R
S
N
O
T
U
S
E
D
0
20
21
25
26
31
Instruction
Memory
Register
File
AIn
DOut
clock
AIn
DOut
32
5
32
Instruction
Register
RS
Reg [RS]
32
+1
D Q
clock
OPC DEC
5
OPC
JREG OPC selects port 1 
else port 0 is selected
0
1
PC
Fig. 6.40 JREG instruction data-path
306
6
Central Processing Unit

The Jump-And-Link (JAL) instruction is the third unconditional jump-type instruction,
and it requires two steps to operate. In the ﬁrst step, the PC address, (PC + 2), following the
JAL instruction is stored in the register R31. In the second step, the current PC value is
replaced with an immediate value as shown below. The instruction’s bit ﬁeld format is given
in Fig. 6.41.
JAL Imm Value
PC þ 2
ð
Þ ! Reg R31
½
 followed by Immediate Value ! PC
The last unconditional jump-type instruction is the Jump-And-Link Register (JALR)
instruction. This instruction also requires a two-step process. In the ﬁrst step, the PC address,
(PC + 2), is stored in the register R31. In the second step, the PC is loaded with the contents
of RS as shown below. The ﬁeld format of this instruction is shown in Fig. 6.42.
JALR RS
PC þ 2
ð
Þ ! Reg R31
½
 followed by Reg RS
½
 ! PC
The Return instruction (RET) works with the JAL or JALR instruction. It retrieves the old
program address stored in the register R31, and replaces the current PC value with the
contents of R31 in order to go back to the original program location as described below. This
instruction’s bit ﬁeld format is given in Fig. 6.43.
RET
Reg R31
½
 ! PC
31
JAL
Immediate Value
26 25
0
Fig. 6.41 Fixed-point Jump-And-Link (JAL) instruction ﬁeld format
31
JALR
RS
Not Used
26 25
21 20
0
Fig. 6.42 Fixed-point Jump-And-Link Register (JALR) instruction ﬁeld format
31
RET
Not Used
26 25
0
Fig. 6.43 Fixed-point Return (RET) instruction ﬁeld format
6.6
Program Control Instructions
307

6.7
Design Example I: A Fixed-Point CPU with Four Instructions
This ﬁrst design example explains how to construct a single CPU data-path that executes the
ADD, LOAD, STORE and MOVE instructions.
The ﬁrst step of the design process is to start with a single instruction in the instruction list
and build its data-path. Each new instruction brings new hardware requirements to the
design, and they are added incrementally to the existing data-path. Once the data-path
reaches its ﬁnal form and is able to execute a set of instructions, the second step is to build
the OPC decoders to control each pipeline stage and guide the data.
In this design, we start building the data-path for the ADD instruction as shown in
Fig. 6.7. The next step is to introduce additional hardware for the LOAD instruction. To
accommodate this requirement, the ﬁrst modiﬁcation is to place a 2-1 MUX in the ALU
stage to select between the immediate value required by the LOAD instruction and Reg
[RS2] required by the ADD instruction as shown in Fig. 6.44. The second modiﬁcation is to
add a bypass path in the data memory stage so that the result of the adder is either guided
through this bypass path if the OPC is ADD, or it is used as an effective address for the data
memory if the OPC is LOAD. Finally, a third modiﬁcation is to place a 2-1 MUX in the
write-back stage to select either the contents of the data memory (from the LOAD
instruction) or the adder output (from the ADD instruction) before writing the result back to
the destination register, RD.
When the STORE instruction is introduced as a third instruction, it prompts a change in the
calculation of the data memory address from {Reg[RS] + Imm Value} to {Reg[RD] + Imm
Value}. This change requires a secondary 2-1 MUX to be placed in the ALU stage to guide
the effective memory address to the AIn port of the data memory, and an additional path to
transfer Reg[RS] to the DIn port of the data memory as shown in Fig. 6.45. The modiﬁcations
for the STORE instruction, however, should not alter the existing data-paths for the ADD and
LOAD instructions. If the ADD and LOAD instruction data-paths are individually traced after
adding the hardware to support the STORE instruction, both Reg[RS1] + Reg[RS2] (from the
ADD instruction) and mem{Reg[RS] + Imm Value} (from the LOAD instruction) paths
should still be available to write the result back to a destination register in the RF.
Introducing the MOVE instruction requires another write-back path to be integrated with
the three existing write-back paths in the architecture. Therefore, a 3-1 MUX needs to placed
in the write-back stage to pass the contents of RS to the RF as shown in Fig. 6.46. While the
MOVE and LOAD instructions use port 0 and port 1 of the 3-1 MUX, respectively, the rest
of the instructions use port 2 of this MUX to write data back to the RF.
308
6
Central Processing Unit

0
15
16
20
21
25
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
SEXT
Instruction
Memory
Data
Memory
Register
File
AIn
DOut
AIn1
DOut1
AIn3
DIn
clock
AIn
DOut
32
5
16
5
32
16
32
32
32
32
32
32
5
Instruction
Register
IR [25:20] = RS/RS1
Imm Value
IR [20:16] = RD/RS2
32
5
5
D Q
clock
AIn2
DOut2
5
IR [15:0]
IR [15:11]
1
0
ADD OPC 
selects port1 
else port 0 is 
selected
0
1
0
ADD OPC selects port1 else port 0 is selected
32
32
5
32
O
P
C
26
31
D Q
clock
32
1
OPC DEC
D Q
clock
6
OPC
ADD and LOAD OPCs select 
the adder in the ALU
D Q
clock
D Q
32
PC
+1
D Q
clock
ADD OPC select port 1 
else port 0 is selected
2
Fig. 6.44 CPU data-path with ADD and LOAD instructions (WE signal to the RF is omitted for clarity)
6.7
Design Example I: A Fixed-Point CPU with Four Instructions
309

0
15
16
20
21
25
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
SEXT
Instruction
Memory
Data
Memory
Register
File
AIn
DOut
AIn1
DOut1
AIn3
DIn
clock
AIn
DOut
32
5
16
5
32
16
32
32
32
32
32
32
5
Instruction
Register
IR[25:20] = RS/RS1
Imm Value
IR[20:16] = RD/RS2
32
5
5
D Q
clock
D Q
clock
32
32
DIn
AIn2
DOut2
5
IR[15:0]
IR[15:11]
1
0
1
0
1
1
0
32
32
32
5
32
O
P
C
26
31
D Q
clock
32
0
OPC DEC
6
OPC
LOAD OPC
32
PC
+1
D Q
clock
ADD OPC
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
WE
STORE OPC
LOAD or ADD select port 1 
else port 0 is selected
LOAD selects port 1 
else port 0 is selected
ADD selects port 1 else port 0 is selected
Write-Back
Stage
ALU
Stage
RF
Stage
Instruction Memory 
Stage
Data Memory 
Stage
ADD selects port 1 
else port 0 is selected
LOAD, STORE, ADD 
select the adder in the 
ALU
Fig. 6.45 CPU data-path with ADD, LOAD and STORE instructions (WE signal to the RF is omitted for clarity)
310
6
Central Processing Unit

0
15
16
20
21
25
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
SEXT
Instruction
Memory
Data
Memory
Register
File
AIn
DOut
AIn1
DOut1
AIn3
DIn
clock
AIn
DOut
32
5
16
5
32
16
32
32
32
32
32
32
5
Instruction
Register
IR[25:20] = RS/RS1
Reg[RS]
Imm Value
IR[20:16] = RD/RS2
32
5
5
D Q
clock
Reg[RD]
D Q
clock
32
32
DIn
D Q
clock
MOVE selects port 0
32
AIn2
DOut2
5
IR[15:0]
IR[15:11]
1
0
1
0
1
0
1
0
ADD selects port 1
32
32
32
5
32
O
P
C
26
31
D Q
clock
32
2
LOAD  selects port 1
OPC DEC
6
OPC
32
PC
+1
D Q
clock
D Q
clock
D Q
clock
D Q
clock
ADD OPC
LOAD OPC
MOVE OPC
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
STORE OPC
WE
LOAD or ADD select port 1 
else port 0 is selected
ADD selects port 1 
else port 0 is selected
Write-Back
Stage
ALU
Stage
RF
Stage
Instruction Memory 
Stage
Data Memory 
Stage
LOAD, STORE and ADD 
select the adder 
in the ALU
Fig. 6.46 CPU data-path with ADD, LOAD, STORE and MOVE instructions (WE signal to the RF is omitted
for clarity)
6.7
Design Example I: A Fixed-Point CPU with Four Instructions
311

The controller for each stage of the data-path is OPC-dependent and completely com-
binational as shown in Fig. 6.47. Since the OPC propagates from one stage to another with
the data, it can effectively be used as a control input to guide data and to activate the required
hardware in each stage. Four instructions need only two input bits stemming from the
instruction register, IR[27:26], to design the OPC decoder in Fig. 6.47. The more signiﬁcant
four OPC bits, IR[31:28], are considered zero for an instruction set of four.
To generate the ADD selector input, both IR[27] and IR[26] are complemented and then
ANDed according to the table in Fig. 6.47. The selector inputs for LOAD, STORE and
MOVE instructions are also generated using the same OPC table.
IR[27]
IR[26]
OPC
ADD
LOAD
STORE
MOVE
0
0
0
1
1
0
1
1
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
ADD
STORE
MOVE
IR[27]
IR[26]
RF Stage
ALU
Stage
Data Memory 
Stage
Write-Back
Stage
LOAD
D Q
clock
D Q
clock
D Q
clock
D Q
clock
MOVE
selects port 0 and
produces WE =1 for RF
LOAD
selects port 1 and
produces WE = 1 for RF
STORE produces WE = 1 
for the Data Memory
LOAD, STORE 
and ADD select 
the adder 
in the ALU
D Q
clock
D Q
clock
ADD
produces WE = 1 for RF
Fig. 6.47 OPC table for ADD, LOAD, STORE and MOVE instructions and the control
circuitry
312
6
Central Processing Unit

The STORE selector input is connected to Write Enable (WE) bit of the data memory
since the STORE instruction is the only instruction that writes data to the data memory. All
other instructions write back the results to the RF, and therefore should produce a WE signal
to enable the RF for write. However, this signal is not shown in Figs. 6.44, 6.45 and 6.46 to
avoid complexity.
6.8
Design Example II: A Fixed-Point CPU with Eight Instructions
The design methodology used in this example is the same as in the previous example. First,
as additional instructions are introduced to the design, new hardware for each instruction
should be incrementally added to the existing data-path. Second, an OPC truth table should
be constructed from the instruction set. Third, controller outputs should be generated from
the OPC truth table to guide the data in each CPU stage.
In this example, the instruction set consists of the ADD, LOAD, STORE, MOVE, SLI,
SRI, JUMP and BRA instructions.
We start with the ADD instruction data-path given in Fig. 6.7 to form the base platform.
The SLI and SRI instructions are implemented next. Both of these instructions require left
and right linear shifters in the ALU stage where each shifter can individually be selected by
the SLI or SRI inputs as shown in Fig. 6.48. These instructions also require a bypass path in
the RF stage that connects IR[15:0] to the ALU input as explained earlier.
When the LOAD instruction is introduced as the fourth instruction, the existing 32-bit
adder in the ALU is used to calculate the effective address for the data memory. The 2-1
MUX in the write-back stage is replaced by a 3-1 MUX to be able to write the contents of the
data memory back to the RF.
The STORE instruction is the ﬁfth instruction added to this design. This instruction
requires two separate paths to calculate the data memory address and to write the contents of
RS to the data memory. The STORE instruction also necessitates a secondary 2-1 MUX in
the ALU stage so that an immediate value is added to the contents of RD instead of RS.
The MOVE instruction is the sixth instruction which requires a path to write the contents
of RS to the RF, bypassing both the ALU and the data memory, and using port 0 of the 3-1
MUX in the write-back stage.
The BRA instruction is the seventh instruction in this set and requires a path to compare
Reg[RS] with RS Value, IR[20:16]. The bitwise comparison is done by 32 two-input XNOR
gates followed by a single 32-input AND gate, and produces a single bit that selects between
(PC + Imm Value) and (PC + 2). The selected target address is loaded to the PC to redirect
the program to a different PC address. This instruction also requires a special 32-bit adder in
the RF stage to calculate (PC + Imm Value) as shown earlier.
6.7
Design Example I: A Fixed-Point CPU with Four Instructions
313

O
P
C
0
15
16
20
21
25
26
31
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
SEXT
Instruction
Memory
Data
Memory
Register
File
AIn
DOut
AIn1
DOut1
AIn3
DIn
clock
AIn
DOut
32
5
16
5
32
16
32
32
32
32
32
32
5
Instruction
Register
RS/RS1
Reg[RS]
Imm Value
RD/RS2
5
5
D Q
clock
32
Reg[RD]
D Q
clock
32
32
DIn
LOAD or ADD or SLI or SRI selects port 1
AIn2
DOut2
5
IR[15:0]
IR[25:0]
IR[15:11]
000000
26
6
SHIFT
1
0
1
0
ADD selects 
port 1
1
0
1
0
ADD selects port 1
SLI or SRI selects port 1
SLI
D Q
clock
RS Value
1
0
1
0
JUMP selects port 1
32
32
32
32
32
32
5
PC
32
PC + Imm Value
32
32
SEXT
5
27
32
SRI
D Q
clock
32
32
D Q
clock
MOVE selects port 0
32
1
0
D Q
clock
32
2
LOAD  selects port 1
BRA
32
+1
D Q
clock
PC
OPC DEC
6
OPC
D Q
clock
D Q
clock
D Q
clock
ADD, LOAD
STORE, MOVE
BRA, JUMP
SLI, SRI
8
WE
STORE 
activates WE
6
8
ADD, LOAD
STORE, MOVE
SLI, SRI
LOAD, STORE
MOVE
BRA selects port 1
Fig. 6.48 CPU data-path with ADD, LOAD, STORE, MOVE, SLI, SRI, JUMP and BRA instructions (WE signal to the RF and
Data Memory are omitted for clarity)
314
6
Central Processing Unit

The JUMP instruction simply forwards the jump value, IR[25:0], extended to 32 bits to
the PC. It requires a second 2-1 MUX in the RF stage that selects this jump value when the
OPC is JUMP. The ALU adder is selected by the ADD, LOAD and STORE instructions.
However, this selection is not shown in Fig. 6.48 to avoid complexity.
Once the data-path for all eight instructions is complete, the OPC truth table in Fig. 6.49 is
formed. Since there are eight instructions in this set, only IR[28:26] are used for designing
the OPC decoder. The upper three bits of the OPC ﬁeld become equal to zero.
D Q
clock
D Q
clock
D Q
clock
D Q
clock
ADD
OPC[28]
OPC[27]
D Q
clock
D Q
clock
OPC[26]
D Q
clock
D Q
clock
ADD
D Q
clock
LOAD
SLI
SRI
ADD or
LOAD or
SLI or
SRI
SLI or
SRI
IR[27]
IR[26]
OPC
ADD
LOAD
STORE
MOVE
0
0
0
0
0
1
0
1
0
1
0
1
IR[28]
SLI
SRI
JUMP
BRA
1
0
1
0
1
1
1
1
0
1
0
1
RF Stage
ALU
Stage
Data Memory 
Stage
Write-Back 
Stage
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
LOAD
STORE
MOVE
SLI
SRI
JUMP
BRA
LOAD selects port 1
and produces WE = 1 for RF
MOVE selects port 0
and produces WE = 1 for RF
STORE produces 
WE = 1 
for Data Memory
D Q
clock
ADD produces WE = 1 for RF
D Q
clock
D Q
clock
SLI produces WE = 1 for RF
D Q
clock
D Q
clock
SRI produces WE = 1 for RF
Fig. 6.49 OPC table for ADD, LOAD, STORE, MOVE, SLI, SRI, JUMP and BRA
instructions and the control circuitry
6.8
Design Example II: A Fixed-Point CPU with Eight Instructions
315

To generate the ADD selector input (used in the RF and ALU stages), the ﬁrst row of the
OPC table is implemented. This requires IR[28], IR[27] and IR[26] to be complemented and
ANDed. The LOAD, STORE, MOVE, SLI, SRI, JUMP and BRA selector inputs are also
generated similarly using the same OPC table. The ALU stage requires the ADD, LOAD, SLI
and SRI selector inputs to be ORed to select Reg[RS] for the adder input. Similarly, SLI and
SRI inputs are ORed to select the shifter outputs. The STORE selector input is connected to WE
input of the data memory since the STORE instruction is the only instruction in the instruction
set that writes data to the data memory. The WE for the RF is omitted to avoid complexity.
6.9
Floating-Point Instructions
This RISC instruction set contains two ﬂoating-point (FP) instructions: Floating-Point Add
(ADDF) and Floating-Point Multiply (MULF). Both instructions use the IEEE single pre-
cision ﬂoating-point format which deﬁnes the most signiﬁcant bit to be the sign, the next eight
most signiﬁcant bits to be the exponent and the least 23 signiﬁcant bits to be the fraction.
The ADDF instruction adds two single precision ﬂoating-point numbers at the registers,
RS1 and RS2, and returns the result to the register RD as described below. The bit ﬁeld
format of this instruction is given in Fig. 6.50.
ADDF RS1; RS2; RD
Reg RS1
½
 þ Reg RS2
½
 ! Reg RD
½

The MULF instruction multiplies two ﬂoating-point numbers in registers RS1 and RS2,
and returns the result to the register RD as shown below. This instruction’s bit ﬁeld format is
described in Fig. 6.51.
MULF RS1; RS2; RD
Reg RS1
½
  Reg RS2
½
 ! Reg RD
½

31
ADDF
RS1
RS2
RD
Not Used
26 25
21 20
16 15
11 10
0
Fig. 6.50 Floating-point Add (ADDF) instruction ﬁeld format
31
MULF
RS1
RS2
RD
Not Used
26 25
21 20
16 15
11 10
0
Fig. 6.51 Floating-point Multiply (MULF) instruction ﬁeld format
316
6
Central Processing Unit

6.10
Floating-Point
Single and double precision ﬂoating-point bit ﬁeld formats are conveniently used in many
modern CPU platforms because the sum of sign, exponent and fraction bits ﬁt into a 32-bit
or a 64-bit wide bus.
An IEEE single-precision (SP) ﬂoating-point number shown in Fig. 6.52 has an eight-bit
ﬁeld for the exponent and 23-bit ﬁeld for the fraction. The most signiﬁcant bit constitutes the
sign bit for the fraction.
Mathematically, a single-precision ﬂoating-point number is expressed as follows:
Singleprecision FP number ¼ ð1ÞS 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F23 	 223


2REXP
Here, s = 1 if the fraction is negative, else the fraction is positive. F1 to F23 are the 23
fraction bits that range from the most signiﬁcant to the least signiﬁcant bit positions of the
fraction ﬁeld in Fig. 6.52, respectively.
Since the exponent ﬁeld does not possess a sign bit, a biasing system is employed to
distinguish the negative exponents from the positive exponents. The biased exponent
(EXP) ﬁeld shown in Fig. 6.52 is the combination of the real exponent (REXP) and the
BIAS as shown below.
EXP ¼ REXP þ BIAS
The BIAS is calculated by substituting the lowest and the highest eight-bit numbers in the
EXP ﬁeld to determine the most negative and the most positive real exponent values. Therefore,
when the most negative real exponent, REXP, equals to –MAX, the expression becomes:
0 ¼ MAX þ BIAS
Similarly, when the most positive exponent, REXP, becomes equal to +MAX, the
expression becomes:
255 ¼ MAX þ BIAS
Hence substituting MAX = BIAS into 255 = MAX + BIAS yields:
S
E7………………….E0
F1…………………………..F23
1
8 bits
23 bits
2-1
2-23
SIGN
EXP
FRACTION
Fig. 6.52 IEEE single-precision ﬂoating-point format
BIAS ¼ 127
6.10
Floating-Point
317

Example 6.1: Represent −0.7510 as a single-precision ﬂoating-point number.
 0:7510 ¼ 0:112 ¼ ð1ÞS 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F23 	 223


2REXP
 1:1 	 21 ¼ ð1ÞS 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F23 	 223


2REXP
Thus,
s ¼ 1
F1 ¼ 1
F2 through F23 ¼ 0
REXP ¼ 1 ¼ EXPBIAS ¼ EXP  127
EXP ¼ 1271 ¼ 126
Filling the fraction and the exponent ﬁelds in Fig. 6.53 yields:
Example 6.2: Represent −527.510 as a single-precision ﬂoating-point number.
527:510 ¼ ð1Þ1 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F23 	 223


2REXP
The closest real exponent to 527.5 is 512 = 29. Thus,
527:510 ¼ ð1Þ1 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F23 	 223


29
where,
1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F23 	 223


¼ 527:5=512 ¼ 1:0302710
1:000012 ¼ 1:0312510
Error in the fraction ¼ 1:03125  1:03027
1:03125
¼ 0:01%
1
  0   1   1    1   1   1   1   0
  1   0   0 .......................... 0   0
1
8 bits
23 bits
27
20
2-1
2-23
SIGN
EXP
FRACTION
Fig. 6.53 Single-precision ﬂoating-point number in Example 6.1
318
6
Central Processing Unit

The biased exponent is calculated as follows:
REXP ¼ 9 ¼ EXPBIAS ¼ EXP  127
EXP ¼ 127 þ 9 ¼ 136
After entering the fraction and exponent ﬁelds into Fig. 6.52, the single-precision
ﬂoating-point number for −527.510 produces the format in Fig. 6.54.
Example 6.3: Convert the single-precision ﬂoating-point number in Fig. 6.55 into a deci-
mal number.
Here, s = 1 corresponds to a negative fraction. The fraction and biased exponent ﬁelds
yield 0.25 and 129, respectively. Thus,
REXP ¼ 129127 ¼ 2
The decimal number ¼ ð1Þ1 1 þ 0:25
ð
Þ22 ¼ 1:25 	 4 ¼ 5
Example 6.4: Convert the single-precision ﬂoating-point number in Fig. 6.56 into a deci-
mal number.
SIGN
EXP
FRACTION
1
  1   0   0    0   1   0   0   0
  0   0   0    0   1   0   0 ...... 0   0
1
8 bits
23 bits
27
20
2-1
2-23
Fig. 6.54 Single-precision ﬂoating-point number in Example 6.2
SIGN
EXP
FRACTION
1
  1   0   0    0   0   0   0   1
  0   1   0    0   0   0   0 ...... 0   0
1
8 bits
23 bits
27
20
2-1
2-23
Fig. 6.55 Single-precision ﬂoating-point number in Example 6.3
SIGN
EXP
FRACTION
0
  1   1   1   1   1   1   1   1
  1   1   1   1   1   1   1  .....  1   1
1
8 bits
23 bits 
27
20
2-1
2-23
Fig. 6.56 Single-precision ﬂoating-point number in Example 6.4
6.10
Floating-Point
319

Here, s = 0 corresponds to a positive fraction. The fraction ﬁeld yields approximately 1.
The biased exponent produces EXP = 255. Therefore,
REXP ¼ 255127 ¼ 128
The decimal number ¼ ð1Þ0ð1 þ 1Þ2128 ¼ 2 	 1038
The IEEE double-precision (DP) ﬂoating-point number in Fig. 6.57 has 11 bits for the
exponent and 52 bits for the fraction for better accuracy. Once again, the most signiﬁcant bit
corresponds to the sign bit for the fraction.
The double-precision ﬂoating-point number is expressed as follows:
Doubleprecision FP number ¼ ð1ÞS 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F52 	 252


2REXP
Here, s = 1 corresponds to a negative, and s = 0 corresponds to a positive fraction. Bits F1
to F52 are the 52 fraction bits from the most signiﬁcant bit position to the least signiﬁcant bit
position, respectively.
The bias system used in single-precision ﬂoating-point numbers can be applied to the
double-precision exponents to distinguish between the negative and the positive exponents. Thus,
EXP ¼ REXP þ BIAS
Here, EXP is the 11-bit ﬁeld in Fig. 6.57, and REXP is the real exponent. The BIAS is
calculated by substituting the lowest and highest biased exponent in the equation,
respectively.
Therefore, for the most negative exponent the equation becomes:
0 ¼ MAX þ BIAS
Similarly, for the most positive exponent the equation becomes:
2047 ¼ MAX þ BIAS
Substituting MAX = BIAS into 2047 = MAX + BIAS yields BIAS = 1023 for
double-precision ﬂoating-point numbers.
S
E10……………….E0
F1…………………………..F52
1
11 bits
52 bits
2-1
2-52
SIGN
EXP
FRACTION
Fig. 6.57 IEEE double-precision ﬂoating-point format
320
6
Central Processing Unit

Example 6.5: Represent −0.7510 as a double-precision ﬂoating-point number.
0:7510 ¼ 0:112 ¼ ð1ÞS 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F52 	 252


2REXP
1:1 	 21 ¼ ð1ÞS 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F52 	 252


2REXP
Thus,
s ¼ 1
F1 ¼ 1
F2 through F52 ¼ 0
REXP ¼ 1 ¼ EXPBIAS ¼ EXP  1023
EXP ¼ 10231 ¼ 1022
Therefore, entering the fraction and the exponent ﬁelds in Fig. 6.58 yields:
Example 6.6: Represent 4.010 as a double-precision ﬂoating-point number.
410 ¼ 1
ð
Þ0 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F52 	 252


2REXP
The closest exponent to 4 is 4 = 22. Thus,
410 ¼ ð1Þ0 1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F52 	 252


22
where,
1 þ F1 	 21 þ F2 	 22 þ F3 	 23 þ 
 
 
 þ F52 	 252


¼ 1:02
Therefore,
F1 through F52 ¼ 0
REXP ¼ 2 ¼ EXPBIAS ¼ EXP  1023
EXP ¼ 1025
Thus, entering the fraction and exponent ﬁelds in Fig. 6.59 yields:
SIGN
EXP
FRACTION
1
 0  1  1  1  1  1  1  1  1  1  0
 1  0  0  .......... ................ 0  0
1
11 bits
52 bits
210
20
2-1
2-52
Fig. 6.58 Double-precision ﬂoating-point in Example 6.5
6.10
Floating-Point
321

Example 6.7: Convert the double-precision ﬂoating-point number in Fig. 6.60 into a
decimal number.
Here, s = 1 corresponds to a negative fraction. The fraction and biased exponent ﬁelds
yield 1 and 0, respectively. Therefore,
REXP ¼ 01023 ¼ 1023
Thus, the decimal number = (−1)1 (1 + 1) 2−1023 = −2 x 10−308.
6.11
Floating-Point Adder
Floating-point addition requires equating the exponents before adding the fractions. There
are two ways to equate exponents. The ﬁrst method is to shift the fraction of the
ﬂoating-point number with greater exponent to the left until both exponents become equal.
The second method is to shift the fraction of the ﬂoating-point number with lesser exponent
to the right until the exponents are equal.
The ﬂoating-point adder in Fig. 6.61 implements the second method. The ﬁrst step of this
method is to determine which of the two ﬂoating-point numbers has a smaller exponent. This
leads to subtracting the two exponents from each other and examining the sign bit of the
result. In the schematic in Fig. 6.61, the second number’s exponent, EXP2, is subtracted
from the ﬁrst number’s exponent, EXP1, to obtain the difference, DEXP = EXP1 −EXP2. If
the sign bit of the difference, DEXP, becomes zero, it indicates EXP1 is larger than or equal
to EXP2. Therefore, the fraction of the second number, FRAC2, is shifted to the right by
DEXP before adding the fractions. If, on the other hand, the sign bit of DEXP becomes one,
FRAC1 is shifted to the right by DEXP before adding FRAC1 to FRAC2.
SIGN
EXP
FRACTION
0
 1  0  0  0  0  0  0  0  0  0  1
 0  0  0  .......... ................ 0  0
1
11 bits
52 bits
210
20
2-1
2-52
Fig. 6.59 Double-precision ﬂoating-point in Example 6.6
SIGN
EXP
FRACTION
1
 0  0  0  0  0  0  0  0  0  0  0
 1  1  1  .......... ................ 1  1
1
11 bits
52 bits
210
20
2-1
2-52
Fig. 6.60 Double-precision ﬂoating-point in Example 6.7
322
6
Central Processing Unit

S1
EXP1
FRAC1
  0         1
S2
EXP2
FRAC2
  1         0
  1         0
  SHIFT RIGHT
NORMALIZE
FRACTION
ROUND FRACTION
S
EXP
FRACTION
OVERFLOW /
UNDERFLOW
VALIDATE
NO
YES
(TO EXCEPTIONS)
select 
BIG EXP
select
SMALL FRAC
SIGN
1.000
-1.110
-1.110
+1
-0.111
1.000
0.001
SIGN
INCREMENT / DECREMENT
1.000
1.000
select
BIG FRAC
BIASED=126
126
125
EXP=126
EXP = 123
BIASED=125
ΔEXP
Fig. 6.61 A ﬂoating-point adder implementation
6.11
Floating-Point Adder
323

The numerical example in Fig. 6.61 describes how to process the exponent and the
fraction ﬁelds of two ﬂoating-point numbers to be added. In this ﬁgure, 126, 1.000, 125 and
−1.110 are assigned to the EXP1, FRAC1, EXP2 and FRAC2 ﬁelds, respectively. Initially,
EXP2 is subtracted from EXP1, yielding ΔEXP = +1. The sign of DEXP becomes zero, and
therefore the larger exponent, EXP1 = 126, is routed to the adder that calculates the ﬁnal
exponent. The zero value of the sign bit also selects the fraction ﬁeld of the larger exponent,
FRAC1 = 1.000, and forwards it to the secondary adder that computes the fraction ﬁeld.
FRAC2 = −1.110, on the other hand, is directed to be the input of the right shifter, which
shifts this value by DEXP = 1 and produces −0.111. This shifted fraction, −0.111, is then
added to FRAC1 = 1.000, producing 0.001 while the exponent stays at 126. The normal-
ization mechanism takes place next, and shifts the result, 0.001, to the left until the leading
one in the 0.001 ﬁeld is detected. The normalizer output becomes 1.000, but the shifted
amount, −3, is added to the current exponent, 126, yielding 123 at the output of the adder
that computes the exponent.
The normalized fraction goes through a rounding process and truncates the fraction ﬁeld
to 23 bits. The result is stored in a 23-bit register at the output of the ﬂoating-point adder.
The output of the exponent adder is similarly stored in an eight-bit register along with the
sign bit for further processing in the CPU.
This ﬂoating-point adder also deals with overﬂow and underﬂow conditions in case the
exponent values become higher than 255 or smaller than 0, both of which generate
exceptions for the CPU.
6.12
Floating-Point Multiplier
The processing complexity of comparing two exponent ﬁelds in the ﬂoating-point adder
does not take place in the ﬂoating-point multiplier. The algorithm used in multiplying two
ﬂoating-point numbers simply multiplies the fractions and adds the exponents.
The ﬂoating-point multiplier architecture in Fig. 6.62 computes the fraction and exponent
ﬁelds with a numerical example. In this example, 126, 1.000, 125 and 1.110 values are
assigned to the EXP1, FRAC1, EXP2 and FRAC2 ﬁelds of the multiplier, respectively.
The ﬁrst step of the multiplication process is to calculate the real exponent values of the
two ﬂoating-point numbers. Therefore, both EXP1 = 126 and EXP2 = 125 are subtracted
from the single-precision bias, 127, yielding −1 and −2, respectively. The real exponents are
then added, producing −3, which becomes the input of an adder that increments or decre-
ments the real exponent after multiplication on the fractions is performed. The fractions,
FRAC1 = 1.000 and FRAC2 = 1.110, are multiplied and produce 1110000. The ﬂoating
point is assigned immediately after locating the leading one in the 1110000 ﬁeld which
324
6
Central Processing Unit

results in 1.11000. This result is subsequently truncated to 1.110. Since no normalization
needs to be performed on 1.110, this step effectively produces a zero increment/decrement
value, and the fraction is stored in the output register after rounding. The real exponent, −3,
on the other hand, is added to the bias, 127, and the result is stored in the exponent register.
Sign bits of the two ﬂoating-point numbers are also XORed and stored.
As in the ﬂoating-point adder, the underﬂow and overﬂow conditions in the exponent
ﬁeld of the ﬂoating-point multiplier cause the CPU to generate exceptions.
6.13
A RISC CPU with Fixed and Floating-Point Units
The ﬂoating-point adder, FP Adder, and the ﬂoating-point multiplier, FP Multiplier, can be
included in the existing ﬁxed-point data-path as shown in Fig. 6.63. The register ﬁle outputs
are connected to the ﬁxed-point ALU as well as the ﬂoating-point adder and the multiplier.
S1
EXP1
FRAC1
S2
EXP2
FRAC2
NORMALIZE 
FRACTION
ROUND FRACTION
S
EXP
FRACTION
OVERFLOW /
UNDERFLOW
VALIDATE
-1
-2
NO
1.110
INCREMENT / DECREMENT
-3
0
BIAS = 127
TRUNCATE 
FRACTION
FIND THE FLOATING PT
-3
124
YES 
(TO EXCEPTION)
1.000
01110000
1.11000
1.110
1.110
1.110
124
0
1
1
1
BIASED = 126
BIASED = 125
-127
-127
Fig. 6.62 A ﬂoating-point multiplier implementation
6.12
Floating-Point Multiplier
325

O
P
C
I
M
M
0
15
16
20
21
25
26
31
D Q
clock
A
L
U
D Q
clock
D Q
clock
D Q
clock
D Q
clock
D Q
clock
PC
Instruction
Memory
Register
File
AIn1
DOut1
AIn3
DIn
clock
clock
AIn
DOut
32
32
5
5
32
32
32
5
11
5
5
5
5
AIn2
DOut2
Instruction
Register
RS1/RS
RS2/RD
RD/Imm[15:11]
Reg [RS1/RS]
Reg [RS2/RD]
32
0
1
1
0
Imm
SEXT
16
16
32
Fixed
Reg-Reg
Instructions
Fixed
Reg-Reg
Instructions
Data
Memory
AIn
DOut
D Q
clock
D Q
clock
D Q
clock
D Q
clock
5
Fixed-Point
OPCODEs
Floating-Point
ADD
0
1
0
2
1
FP Adder
FP Multiplier
Floating-Point OPCODEs
LOAD
32
32
32
Fig. 6.63 CPU with ﬁxed and ﬂoating-point data-paths
326
6
Central Processing Unit

The OPC ﬁeld for the ADDF instruction selects the ﬂoating-point adder result in the ALU,
and routes it to port 0 terminal of the 3-1 MUX at the write-back stage. Similarly, the result
from the ﬂoating–point multiplier is directed to port 0 of the 3-1 MUX if the OPC is MULF.
Port 1 of the 3-1 MUX is dedicated to the LOAD instruction, and port 2 to the remainder of
the OPCs in the instruction set.
One can also employ a secondary RF for only storing ﬂoating-point numbers since the
formats of ﬁxed and ﬂoating-point numbers are different from each other. However, this
approach creates additional complexity in routing the RF outputs to the appropriate ALUs
and requires additional hardware. Therefore, it is avoided in this design.
6.14
Structural Hazards
When instructions are fetched from the instruction memory and introduced to the CPU
pipeline, they follow each other one clock cycle apart as shown in Fig. 6.64. In this ﬁgure,
when the ﬁrst instruction transitions to the RF stage in cycle 2, the second instruction starts
its instruction fetch cycle. In cycle 3, the ﬁrst instruction starts the ALU stage, the second
instruction enters the RF stage, and the third instruction goes into the instruction fetch stage.
The fourth cycle in Fig. 6.64 should be viewed with a particular importance because it
creates a structural hazard. In this cycle, the ﬁrst instruction accesses the data memory while
the fourth instruction is fetched from the instruction memory. If there is only one memory
block with a single port (to read instructions and to store data), this conﬁguration will create
a structural hazard because the ﬁrst and the fourth instructions will try to access the memory
in the same cycle. This is the primary reason to have separate instruction and data memories
in a RISC CPU.
INSTRUCTION 1
INSTRUCTION 2
INSTRUCTION 3
INSTRUCTION 4
INSTRUCTION 5
CYCLES
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
1
2
3
4
5
6
7
8
9
Fig. 6.64 Structural hazards in a ﬁve-stage CPU
6.13
A RISC CPU with Fixed and Floating-Point Units
327

Cycles 5 and 6 creates another type of structural hazard. In both of these cycles, data has
to be read from the RF and written to the RF in the same cycle. If the data read from the RF
depends on the data written to the RF, this condition will create a hazard because the write
needs to take place before the read in order to produce correct results. Therefore, RF should
be designed such that all writes have to be done at the high phase of the clock and all reads at
the low phase.
6.15
Data Hazards
Data hazards create a situation where the required data is unavailable when it is needed by an
instruction. There are four known data hazards in this architecture. The examples below
illustrate each data hazard type and propose solutions in the CPU architecture to avoid them.
The ﬁrst type of data hazard is shown in the example in Fig. 6.65. In this example, the
ADD instruction adds the contents of R1 and R2, and then writes the result to a destination
register, RD. The second, third and fourth instructions require the contents of RD to proceed.
The only hazard-free case here is the data exchange between the ADD and the OR
instructions since the RF permits data to be written during the high phase of the clock and
read during the low phase. However, the SUB and the AND instructions try to fetch the
contents of RD before they become available. Therefore, executing any of these instructions
would produce two separate hazards. In order to circumvent this problem, a technique called
“data-forwarding” is applied to the CPU pipeline. This method requires a special data route
in the CPU data-path so that partially processed data is immediately transferred from a
particular pipeline stage to the next when it is needed. Figure 6.66 shows the two forwarding
paths to remove the data hazards associated with the SUB and the AND instructions. The
ﬁrst path transfers data from the ALU output to the ALU input when the SUB instruction
needs the ADD instruction’s ALU result to proceed. The second path transfers data from the
output of the data memory to the ALU input when the AND instruction needs the ADD
instruction’s ALU output.
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
ADD
SUB
AND
OR
R1, R2, RD
, R3
, R5
, R7
, R4
, R6
, R8
RD
RD
RD
Fig. 6.65 Data hazard: a register-type instruction followed by other register-type instruction(s)
328
6
Central Processing Unit

Figure 6.67 shows the ﬁrst forwarding path from the ALU output to the ALU input to
remove the data hazard caused by the ADD-SUB instruction pair in Fig. 6.65. In this ﬁgure,
the source address of the SUB instruction is compared against the destination address of the
ADD instruction. If there is a match, then the ALU output to ALU input forwarding path(s)
is activated by selecting port 1 of the 2-1 MUX at the input of the ALU.
The second forwarding path shown in Fig. 6.68 feeds back the output of the data memory
stage to the input of the ALU and removes the data hazard caused by the ADD-AND
instruction pair in Fig. 6.65. Again, the source address of the AND instruction is compared
against the destination address of the ADD instruction. The path that connects the data
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
ADD
SUB
AND
OR
R1, R2, RD
, R3
, R5
, R7
, R4
, R6
, R8
RD
RD
RD
Fig. 6.66 Forwarding paths to remove the data hazards caused by a register-type instruction
followed by other register-type instruction(s)
D Q
clock
D Q
clock
D Q
clock
Data
Memory
AIn
DOut
32
32
32
32
32
DIn
D Q
clock
1
0
1
0
1
0
A
L
U
32
32
32
D Q
clock
D Q
clock
32
D Q
clock
32
ALU - ALU path
1
0
1
0
Fig. 6.67 ALU output to ALU input forwarding path
6.15
Data Hazards
329

memory output at the end of the bypass path to the ALU input is activated by selecting port 1
of the 2-1 MUX if there is a match.
Another type of data hazard is shown in Fig. 6.69. This hazard originates from an
instruction that requires the contents of the data memory as a source operand. A forwarding
path that connects the output of the data memory to the input of the ALU may not be
sufﬁcient to remove this data hazard as shown in Fig. 6.70. However, if a No Operation
(NOP) instruction is inserted between the LOAD and ADD instructions, the one cycle delay
created by this instruction can avoid this hazard as shown in Fig. 6.71. With the NOP
instruction in place, the LOAD instruction can now forward the contents of the data memory
as a source operand for the ADD instruction as it enters the ALU stage.
D Q
clock
D Q
clock
D Q
clock
Data
Memory
AIn
DOut
32
32
32
32
32
DIn
D Q
clock
1
0
1
0
1
0
A
L
U
32
32
32
D Q
clock
D Q
clock
32
D Q
clock
32
DBypass - ALU path
1
0
1
0
Fig. 6.68 Data memory bypass output to ALU input forwarding path
LOAD R1,
, R2, R3
, Imm
ADD
RD
RD
I
R
A
D
W
R
I
W
A
D
Fig. 6.69 Data hazard created by the LOAD instruction followed by a register-type
instruction
330
6
Central Processing Unit

Figure 6.72 shows the hardware implementation to remove the particular data hazard in
Fig. 6.69. The data memory output to the ALU input path is activated by implementing a
logic block that compares the destination address of the LOAD instruction with the source
address of the ADD instruction, and enables port 1 of the 2-1 MUX if they are equal.
LOAD R1,
, R2, R3
, Imm
ADD
RD
RD
I
R
A
D
R
I
W
A
D
W
Fig. 6.70 A forwarding path to remove the data hazard caused by the LOAD instruction
followed by a register-type instruction
NOP
LOAD R1,
, R2, R3
, Imm
ADD
RD
RD
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
Fig. 6.71 A forwarding path and a NOP instruction to remove the data hazard caused by the
LOAD instruction followed by a register-type instruction
D Q
clock
D Q
clock
D Q
clock
Data
Memory
AIn
DOut
32
32
32
32
32
DIn
D Q
clock
1
0
1
0
1
0
A
L
U
32
32
32
D Q
clock
D Q
clock
32
D Q
clock
32
DMem - ALU path
1
0
1
0
Fig. 6.72 Data memory output to ALU input forwarding path
6.15
Data Hazards
331

The ﬁnal data hazard shown in Fig. 6.73 stems from a LOAD instruction followed by a
STORE instruction. Here, the destination address of the LOAD instruction is the same as the
source address of the STORE instruction. This results in a situation where the data written
back to the RF has to be stored in the data memory within the same clock cycle. A for-
warding path that connects the output of the data memory to the input of the data memory
removes this hazard as shown in Figs. 6.74 and 6.75. Once again, we need a comparator that
compares the contents of the destination address of the LOAD instruction against the source
address of the STORE instruction to activate this forwarding path.
LOAD R1,
, R2, Imm2
, Imm1
STORE RD
RD
I
R
A
D
D
I
W
A
R
W
Fig. 6.73 Data hazard: a STORE instruction followed by a register-type instruction
LOAD R1,
, R2, Imm2
, Imm1
STORE RD
RD
I
R
A
D
I
W
A
R
W
D
Fig. 6.74 A forwarding path to remove the data hazard caused by a STORE instruction
followed by a register-type instruction
D Q
clock
D Q
clock
D Q
clock
Data
Memory
AIn
DOut
32
32
32
32
32
DIn
D Q
clock
1
0
1
0
1
0
A
L
U
32
32
32
D Q
clock
D Q
clock
32
1
0
D Q
clock
32
DMem − DMem path
Fig. 6.75 Data memory output to data memory input forwarding path
332
6
Central Processing Unit

Figure 6.76 shows the combination of all four forwarding paths to remove data hazards
from the CPU pipeline. The selector inputs in this ﬁgure originate from individual com-
parators that compare the destination address of an instruction with the source address of a
subsequent instruction.
6.16
Program Control Hazards
Branch and jump instructions also create hazards. In the program shown in Fig. 6.77, the
earliest time for the BRA instruction to produce a branch target address is when this
instruction is at the RF stage. Therefore, the instruction following the BRA instruction
cannot be fetched from the instruction memory in the next clock cycle but it requires one
cycle delay. This delay can be implemented either by inserting an unrelated instruction to
branch or using a NOP instruction in the “branch delay slot” as shown in Fig. 6.78.
D Q
clock
D Q
clock
D Q
clock
Data
Memory
AIn
DOut
32
32
32
32
32
DIn
D Q
clock
1
0
1
0
1
0
A
L
U
32
32
32
D Q
clock
D Q
clock
32
1
0
D Q
clock
32
DMem – DMem path
ALU - ALU path
DMem - ALU path
DBypass - ALU path
3
Fig. 6.76 CPU schematic containing all data hazard corrections
6.15
Data Hazards
333

Similar to the BRA instruction, the jump-type (JUMP, JREG, JAL and JALR) instruc-
tions also create control hazards since they can only deﬁne the address of the next instruction
when they are in the RF stage as shown in Fig. 6.79. Inserting a NOP instruction or an
unrelated instruction to jump in the “jump delay slot” removes the pending control hazard as
shown in Fig. 6.80.
Even though the jump-type and branch-type instructions update the contents of the PC,
the branch instruction requires a comparator and a special adder in the RF stage to calculate
the target address.
BRA
R1,
R3,
Imm
ADD
I
R
A
D
I
W
A
R
W
D
RSValue,
R2,
R4
Fig. 6.77 Control hazard: a BRA instruction
NOP
Unrelated instruction
Delay slot
BRA
R1,
R3,
Imm
ADD
I
R
A
D
I
W
A
R
W
D
RSValue,
R2,
R4
I
W
A
R
D
BRA
R1,
R3,
Imm
ADD
I
R
A
D
I
W
A
R
W
D
RSValue,
R2,
R4
I
W
A
R
D
BRA
R1,
R3,
Imm
ADD
I
R
A
D
I
W
A
R
W
D
RSValue,
R2,
R4
I
W
A
R
D
Fig. 6.78 Removal of BRA control-hazard using an unrelated instruction in the program or
a NOP instruction
334
6
Central Processing Unit

6.17
Handling Hazards in a Five-Stage RISC CPU: An Example
This example shows the use of forwarding paths to avoid data and control hazards on an
instruction chart. The use of the NOP instruction is also shown when forwarding paths
become insufﬁcient to remove a particular hazard.
The ﬂow chart in Fig. 6.81 shows a small user program and the contents of the instruction
memory before the program is executed. Data A in the ﬂow chart is read from the memory
address 100. Data Y, Z and W are stored at the memory addresses 200, 201 and 202,
respectively.
JREG
R1
R3,
Imm
ADD
R2,
R4
JUMP
I
R
A
D
W
I
W
A
R
D
R3,
ADD
R2,
R4
I
R
A
D
W
I
W
A
R
D
Fig. 6.79 Control hazard: JUMP and JREG instructions
NOP
Unrelated instruction
Delay slot
Imm
JUMP
R3,
ADD
R2,
R4
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
Imm
JUMP
R3,
ADD
R2,
R4
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
Imm
JUMP
R3,
ADD
R2,
R4
I
R
A
D
W
I
R
A
D
W
I
R
A
D
W
Fig. 6.80 Removal of JUMP and JREG control-hazards using an unrelated instruction in the
program or a NOP instruction
6.17
Handling Hazards in a Five-Stage RISC CPU: An Example
335

After Y is stored, the ﬂow chart comes to a decision box where the value of A is compared
against one. At this point, the program splits into two where each branch performs calcu-
lations to determine the values of Z and W before they are stored in the data memory.
The instruction, LOAD R0, R1, 100, in Fig. 6.82 adds the contents of R0, whose bits are
hard-wired to logic 0 due to the architectural speciﬁcations, to 100 to calculate the data
memory address. It then fetches A from the data memory address 100, and writes this value
to the RF address R1.
The SLI R1, R2, 1 instruction shifts the contents of R1 one bit to the left to produce 2A,
and writes the result, Y = 2A, to R2. The ADD R1, R2, R3 and SRI R1, R4, 1 instructions
compute the values 3A and 0.5A, respectively. Both values will be used later in the program.
The BRA R1, 1, 5 instruction compares the contents of R1, which currently holds A, with
the RS Value = 1. If the comparison is successful, the program branches off to fetch the next
instruction at the instruction memory location, PC = 4 + 5 = 9, to execute the SUBI R3, R5,
1 that computes Z = 3A – 1. Otherwise, the program fetches the next instruction, ADDI R3,
R5, 1 at PC = 4 + 2 = 6 to compute Z = 3A + 1.
READ A
Y = 2A
STORE Y
Z = 3A - 1
W = 0.5A + 1
Z = 3A + 1
W = 0.5A - 1
STORE Z, W
A : 1
A = 1
ELSE
A
Y
Z
W
LOADED
TO BE
STORED
100
200
201
202
Data Memory
Fig. 6.81 Flow-chart of an example program and data memory contents
336
6
Central Processing Unit

The STORE R2, R0, 200 instruction is an unrelated instruction to the branch. Therefore, it
is used in the branch delay slot following the branch instruction. This instruction stores the
contents of R2, which contains 2A, to the data memory location 200 in Fig. 6.81.
The JUMP 11 instruction at PC = 8 changes the value of the PC with an immediate value
of 11. Therefore, the program skips both the SUBI and ADDI instructions following the
JUMP instruction to execute the STORE R5, R0, 201 and STORE R6, R0, 202 instructions.
As a result, the values of Z and W are stored at the data memory addresses 201 and 202,
respectively, regardless of the branch outcome.
Figure 6.83 shows the instruction chart of the program in Fig. 6.82. The LOAD R0, R1,
100 instruction causes a data hazard as explained in Fig. 6.69, but it is corrected by a
combination of a NOP instruction and a forwarding path (from the data memory stage (D) of
the LOAD instruction to the ALU stage (A) of the SLI instruction).
The ADD R1, R2, R3 instruction also requires data forwarding from the A stage of the
SLI instruction to the A stage of the ADD instruction.
0      
   LOAD  R0, R1, 100
 A     Reg [R1]
1      
   SLI R1, R2, 1
2A     Reg [R2]
2          ADD R1, R2, R3
3A     Reg [R3]
3      
   SRI R1, R4, 1
0.5A     Reg [R4]
4      
   BRA R1, 1, 5
If A = 1 then PC + 5     PC
5      
   STORE R2, R0, 200
 2A     mem [200]
6          ADDI R3, R5, 1
Z = 3A + 1     Reg [R5]
7          SUBI R4, R6, 1
W = 0.5A - 1     Reg [R6]
8          JUMP 11
11     PC
9     
   SUBI R3, R5, 1
Z = 3A - 1     Reg [R5]
10          ADDI R4, R6, 1
W = 0.5A + 1     Reg [R6]
11          STORE R5, R0, 201
   Z     mem [201]
12    
     STORE R6, R0, 202
  W     mem [202]
PC                           
Instruction
Comments
Fig. 6.82 Instruction memory contents of the example and explanation of each instruction
6.17
Handling Hazards in a Five-Stage RISC CPU: An Example
337

The BRA R1, 1, 5 instruction computes the branch target while it is in the RF (R) stage.
An instruction unrelated to the branch instruction, such as STORE R2, R0, 200 is used in the
branch delay slot so that the CPU has enough time to fetch ADDI R3, R5, 1 if the branch
comparison is unsuccessful or SUBI R3, R5, 1 if the comparison is successful.
From this point forward, the program follows two separate instruction charts. The ﬁrst
chart shows the case where the branch comparison is unsuccessful. This chart contains a
JUMP instruction followed by a NOP instruction used in the jump delay slot. The second
chart follows the case where the branch comparison is successful, and contains two for-
warding paths required by the STORE instructions. Both of these paths forward data from
the D stage of SUBI R3, R5, 1 and ADDI R4, R6, 1 to the A stage of STORE R5, R0, 201
and STORE R6, R0, 202 to avoid data hazards, respectively.
The entire program takes 15 clock cycles to complete if the branch is successful and 17
cycles if unsuccessful.
LOAD R0, R1, 100
SLI R1, R2, 1
ADD R1, R2, R3
SRI R1, R4, 1
BRA R1, 1, 5
STORE R2, R0, 200
ADDI R3, R5, 1
SUBI R4, R6, 1
JUMP 11
SUBI R3, R5, 1
ADDI R4, R6, 1
STORE R5, R0, 201
STORE R6, R0, 202
NOP
I     R    A    D    W
I     R    A    D   W
I     R    A    D    W
I     R    A    D   W
I     R    A    D    W
I     R    A    D    W
I     R    A    D    W
I     R    A    D    W
NOP
STORE R5, R0, 201
STORE R6, R0, 202
I     R    A    D   W
I     R    A    D    W
I     R    A    D   W
I     R    A    D    W
Delay Slot
Branch TAKEN
Branch NOT TAKEN
I     R    A    D   W
I     R    A    D   W
I     R    A    D    W
I     R    A    D    W
I     R    A    D    W
Delay Slot
Fig. 6.83 Five-stage CPU instructional chart
338
6
Central Processing Unit

Can the program in Fig. 6.82 be executed more efﬁciently in a shorter amount of time and
with fewer forwarding paths if the number of pipeline stages is reduced? To answer this
question, two additional CPU pipelines are implemented: one with four pipeline stages and
the other with three.
6.18
Handling Hazards in a Four-Stage RISC CPU
Figure 6.84 shows a four-stage RISC CPU where the ALU and the data memory stages are
combined in a single stage.
If the instructional chart is reconstructed to execute the program in Fig. 6.82 in a
four-stage CPU, it will produce a chart in Fig. 6.85. The ﬁrst observation in this ﬁgure is that
there are fewer NOP instructions. For example, the NOP instruction that follows LOAD R0,
R1, 100 is eliminated because the memory contents become available during the combined
ALU/Data Memory stage (AD). Also, the forwarding paths from SUBI R3, R5, 1 to STORE
R5, R0, 201 and from ADDI R4, R6, 1 to STORE R6, R0, 202 in Fig. 6.83 are eliminated in
Fig. 6.85 because the write-back stage (W) of SUBI R3, R5, 1 lines up with the RF access
stage (R) of STORE R5, R0, 201, and similarly the W stage of ADDI R4, R6, 1 lines up with
the R stage of STORE R6, R0, 202 in this new CPU pipeline.
PC
Instruction
Memory
Register
File
OPC Dec
A
L
U
Data
Memory
Instruction Memory Stage
RF Stage
ALU/Data Memory Stage
Write-Back Stage
1st flip-flop 
boundary
2nd flip-flop 
boundary
3rd flip-flop 
boundary
Fig. 6.84 Four-stage CPU data-path
6.17
Handling Hazards in a Five-Stage RISC CPU: An Example
339

Branch and jump-related hazards still exist in the chart in Fig. 6.85. They are removed
either by inserting NOP instructions or unrelated instructions to branch and jump in the
corresponding delay slots.
The new CPU pipeline executes the program in a shorter time: 13 clock cycles if the
branch is successful and 15 cycles if unsuccessful.
6.19
Handling Hazards in a Three-Stage RISC CPU
Can there be a continuing improvement in the program efﬁciency and the overall execution
time if the number of pipeline stages is reduced further? To answer this question, the CPU
pipeline in Fig. 6.84 is repartitioned into three stages where the ALU, the data memory and
the write-back stage are grouped together to form a single stage as shown in Fig. 6.86.
LOAD R0, R1, 100
SLI R1, R2, 1
ADD R1, R2, R3
SRI R1, R4, 1
BRA R1, 1, 5
STORE R2, R0, 200
ADDI R3, R5, 1
SUBI R4, R6, 1
JUMP 11
SUBI R3, R5, 1
ADDI R4, R6, 1
STORE R5, R0, 201
STORE R6, R0, 202
I      R    AD    W
NOP
STORE R5, R0, 201
STORE R6, R0, 202
Delay Slot
Branch TAKEN
Branch NOT TAKEN
Delay Slot
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
I      R    AD    W
Fig. 6.85 Four-stage CPU instructional chart
340
6
Central Processing Unit

When the instructional chart is reconstructed for the three-stage CPU in Fig. 6.86, we see
an immediate improvement: the absence of all forwarding paths. The new chart is shown in
Fig. 6.87. However, the combined ALU, Data Memory and Write-Back stages (AW) create a
practical engineering problem: calculating the data memory address, accessing the data
memory and then writing the results back to the RF may not ﬁt in half a clock cycle.
Therefore, a NOP instruction is used after LOAD R0, R1, 100 to allow a full clock cycle
delay to complete the write-back to the RF before SLI R1, R2, 1 accesses this data.
For the SLI R1, R2, 1 and ADD R1, R2, R3 instruction pair, half a cycle may be sufﬁcient
to shift the contents of R1 and store the result into R2 before the ADD instruction accesses
this data. Therefore, no NOP instruction is inserted between the SLI and ADD instructions.
Branch and jump-related delay slots still cannot be avoided in Fig. 6.87. STORE R2, R0,
200 is inserted in the branch delay slot, and a NOP instruction is used as the jump delay in
Fig. 6.87 just as in Figs. 6.83 and 6.85.
The three-stage CPU executes the program in 13 clock cycles if the branch is successful
and 15 cycles if unsuccessful. Therefore, there is no gain in speed compared to the four-stage
CPU. However, this may not be true for larger programs if they contain more instructions to
access the data memory.
PC
Instruction
Memory
Register
File
OPC Dec
A
L
U
Data
Memory
Instruction Memory Stage
RF Stage
ALU/Data Memory/Write-Back Stage
1st flip-flop 
boundary
2nd flip-flop 
boundary
Fig. 6.86 Three-stage CPU data-path
6.19
Handling Hazards in a Three-Stage RISC CPU
341

6.20
Multi-cycle ALU and Related Data Hazards
Not all ALU operations can be executed within one clock cycle. Depending on the propa-
gation delay of the functional modules, the ALU stage may take up several cycles especially
if it includes a ﬂoating-point adder or multiplier.
To show the potential data hazards in a multi-cycle ALU, a RISC CPU containing both
ﬁxed and ﬂoating-point ALUs is used in Fig. 6.88. In this example, the ﬁxed-point ALU is
assumed to execute data in a single clock cycle, whereas the ﬂoating-point add and multiply
units require three and ﬁve clock cycles to process data, respectively.
LOAD R0, R1, 100
SLI R1, R2, 1
ADD R1, R2, R3
SRI R1, R4, 1
BRA R1, 1, 5
STORE R2, R0, 200
ADDI R3, R5, 1
SUBI R4, R6, 1
JUMP 11
SUBI R3, R5, 1
ADDI R4, R6, 1
STORE R5, R0, 201
STORE R6, R0, 202
NOP
NOP
STORE R5, R0, 201
STORE R6, R0, 202
Delay Slot
Branch TAKEN
Branch NOT TAKEN
Delay Slot
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
I     R    AW
Fig. 6.87 Three-stage CPU instructional chart
342
6
Central Processing Unit

The program below is executed in the CPU pipeline in Fig. 6.88, and deliberately
designed to contain data dependencies. All matching source and destination register
addresses are shown in bold letters.
LOAD R1, R2, 0
MULF R2, R3, R4
ADDF R4, R5, R6
STORE R6, R7, 0
The instructional chart for a ﬁve-stage CPU in Fig. 6.89 requires the combination of a
forwarding path from the D stage of LOAD R1, R2, 0 to the A stage of MULF R2, R3, R4
and a NOP instruction in order to remove the pending data hazard.
But, the more importantly this chart employs four NOP instructions following the MULF
instruction to provide the required delay for ADDF R4, R5, R6 to add the contents of R5 to
the forwarded data from the ﬂoating-point multiplier output. Similarly, STORE R6, R7, 0
needs the combination of a NOP instruction and a forwarding path from the A3 stage of the
ADDF instruction to calculate the data memory address. The entire program takes 14 clock
cycles to complete.
IMem
RF
Fixed
Point
Float
ADD
1
Float
ADD
2
Float
ADD
3
DMem
WB
Floating Point ADD
Float
MUL
1
Float
MUL
2
Float
MUL
3
Float
MUL
4
Float
MUL
5
Floating Point MULTIPLY
Floating Point Operations
Fig. 6.88 Multi-cycle ALU of a ﬁve-stage CPU
6.20
Multi-cycle ALU and Related Data Hazards
343

The chart in Fig. 6.90 is derived from the instruction chart in Fig. 6.89. This new chart
uses different RF addresses, and produces no data dependencies. Consequently, the program
is executed in 10 clock cycles instead of 14 due to the absence of NOP instructions.
Figure 6.91 alters the number of ALU cycles for the ﬂoating-point add from three to two
clock cycles to investigate the outcome. In this ﬁgure, even though the D stage of the ADDF
instruction aligns with the D stage of the STORE instruction, neither path interferes with
each other since the ADDF instruction uses the data memory bypass path while the STORE
instruction accesses the data memory with an address calculated by the ﬁxed-point adder.
Therefore, this situation does not create a structural hazard for the CPU.
LOAD R1,
R5,
0
ADDF
I
R
A
D
I
W
A
R
W
D
R4,
R6
R2,
STORE R6,
0
R7,
R3,
MULF R2,
R4
NOP
NOP
NOP
NOP
NOP
NOP
I
R
A
D
W
I
W
D
R
A
I
W
D
R
A
I
W
D
R
A
I
W
D
R
A
I
W
D
R
A
I
W
R
1
A
D
A2
A3
I
W
R
1
M
D
M2
M3
M4
M5
Fig. 6.89 Instructional chart of a program with data dependencies
LOAD R1, R2, 0
I
R
A
D
W
MULF R3, R4, R5
I
R
M
1   M2   M3   M4   M5    D
W
ADDF R6, R7, R8
I
R
A
1    A2    A3    D
W
STORE R9, R10, 0
I
R
A
D
W
Fig. 6.90 Instructional chart of a program with no data dependencies
344
6
Central Processing Unit

Similarly, the W stages of the ADDF and STORE instructions do not create a structural
hazard because the ADDF instruction uses the RF write-back path while the STORE
instruction terminates at the data memory stage.
Figure 6.92 examines the case where the ALU stage of the MULF instruction is reduced
from ﬁve to three clock cycles, and there are still no data dependencies among instructions.
In this case, both the MULF and ADDF instructions are forced to use the same data memory
bypass and write-back paths. Therefore, the ADDF instruction must be delayed for one cycle
D
Bypass path
DIn port
It does not exist
LOAD R1,
R7,
0
ADDF
I
R
A
D
W
R6,
R8
R2,
STORE R9,
0
R10,
R4,
MULF R3,
R5
I
A
R
I
W
A1
R
D
A2
I
W
M1
R
D
M2
M3
M4
M5
W
Fig. 6.91 Instructional chart of a program with no data dependencies: The MULF instruction
still requires ﬁve cycles but the ADDF instruction is reduced from three to two cycles
Bypass path
Write -Back path
Bypass path
D
DIn port
It does not exist
LOAD R1,
R7,
0
ADDF
I
R
A
D
W
R6,
R8
R2,
STORE R9,
0
R10,
R4,
MULF R3,
R5
I
A
R
I
W
A1
R
D
A2
I
W
M1
R
D
M2
M3
W
D
DIn port
It does not exist
LOAD R1,
R7,
0
ADDF
I
R
A
D
W
R6,
R8
R2,
STORE R9,
0
R10,
R4,
MULF R3,
R5
I
A
R
I
W
A1
R
D
A2
I
W
M1
R
D
M2
M3
W
Bypass path
NOP
I
R
A
D
W
Fig. 6.92 Instructional chart of a program with no data dependencies: MULF is reduced to
three cycles, but ADDF is still two cycles
6.20
Multi-cycle ALU and Related Data Hazards
345

with respect to the MULF instruction to ensure that these instructions are able to use the
same paths in different clock cycles.
The D stage alignment between the ADDF and STORE instructions does not impose any
structural hazard because the ADDF instruction uses the data memory bypass path while the
STORE instruction uses a data memory address calculated by the ﬁxed-point adder to store
data.
6.21
Cache Topologies
Cache is a local memory to the CPU where the temporary blocks of data is kept until it is
permanently stored in the system memory. No other bus master but the CPU is allowed to
access the cache memory.
There are three types of cache architectures in modern CPUs: fully-associative,
set-associative and direct-mapped.
Fully-associative cache protocol allows a block of data to be written (or read) anywhere in
the cache as shown in Fig. 6.93. In this type of cache architecture, a block of data is searched
in the entire cache before it is read. The range of cache memory addresses to place a block of
data is called a set. In Fig. 6.93, the entire cache containing N number of blocks belongs to a
single set.
Set-associative cache protocol, in contrast, allows a block of data to be written (or read)
only to a limited set of addresses in the cache. The top ﬁgure of Fig. 6.94 shows a two-way
set-associative cache where a block of data from the main memory is written only to two
SET 
Fully-Associative Cache
Main Memory
Block X
Block 0
Block 1
Block 2
Block 3
Block (N-2)
Block (N-1)
Block (N-4)
Block (N-3)
Block 4
Block 5
Block 6
Block 7
Fig. 6.93 Fully-associative cache topology
346
6
Central Processing Unit

possible cache addresses, which deﬁnes a set. Conversely, when data needs to be read from a
two-way set-associative cache, data is searched only within a given set. Therefore, the time
to search and locate data is reduced by a factor of N/2 in a two-way set associative cache
compared to a fully-associative cache containing N number of blocks.
SET 0
2-Way Set Associative Cache
Main Memory
SET 1
SET (K-1)
Block X
Block 0
Block 1
Block 2
Block 3
Block (N-2)
Block (N-1)
SET 0
4-Way Set Associative Cache
Main Memory
SET 1
SET (K-1)
Block (N-4)
Block (N-3)
Block 4
Block 5
Block 6
Block 7
Block X
Block 0
Block 1
Block 2
Block 3
Block (N-2)
Block (N-1)
Block (N-4)
Block (N-3)
Block 4
Block 5
Block 6
Block 7
SET 2
SET 3
SET (K-2)
Fig. 6.94 Two-way and four-way set-associative cache topologies
6.21
Cache Topologies
347

Similar to the two-way set-associative cache, a block of data is searched in four possible
addresses in a set when the CPU issues a cache read in a four-way set-associative cache as
shown at the bottom part of Fig. 6.94. If data needs to be written to the cache, only four
possible cache addresses in a set are considered according to the cache protocol.
The third cache type is the direct-mapped cache as shown in Fig. 6.95. Its organization is
similar to an SRAM, and it maintains a one-to-one addressing scheme with the main
memory. In other words, a block of data in the main memory can only be written to a speciﬁc
location in the cache memory or vice versa.
All stored data blocks in the cache memory are tagged. Consequently, all data transactions
between the cache and the main memory (or the CPU) require validation of the tag ﬁeld
before performing a cache read or write operation. Physically, tag ﬁelds are stored in a
different memory block in the same cache structure. However, both the cache and tag
memories retain one-to-one association with each other as shown in Fig. 6.96. In addition,
the tag memory comes with valid bits. Each bit speciﬁes if a block of data residing in the
cache has an identical twin in the main memory or not. A valid bit = 0 means that the
contents of the main memory have not been updated with the block of data residing in the
cache at a certain address. When updating is complete and there is complete data coherency
between the cache and main memories, the valid bit becomes logic 1.
SET 0 
Direct-Mapped Cache
Main Memory
Block X
Block 0
Block 1
Block 2
Block 3
Block (N-2)
Block (N-1)
Block (N-4)
Block (N-3)
Block 4
Block 5
Block 6
Block 7
SET 1 
SET 2 
SET 3 
SET 4 
SET 5 
SET 6 
SET 7 
SET (N-4) 
SET (N-3) 
SET (N-2) 
SET (N-1) 
Fig. 6.95 Direct-mapped cache topology
348
6
Central Processing Unit

The CPU address that references the cache memory consists of three separate ﬁelds as
shown at the bottom section of Fig. 6.96: tag, index and block offset. The index ﬁeld
speciﬁes the set address where the cache block resides. Since a block may contain many
words, block offset selects the word in the block. Therefore, before a cache-related operation
takes place, the tag ﬁeld in a CPU address is compared against all the tag ﬁelds in a given set.
If the tag comparison is successful, the block of data at the speciﬁed set location is trans-
ferred out of the cache memory or vice versa.
6.22
Cache Write and Read Structures
The cache write operation starts with comparing the tag ﬁeld of the CPU address with all the
tag ﬁelds of a referenced set in the tag memory. If the comparison is successful, this creates a
hit signal, and prompts the CPU to write data to the speciﬁed set (and block offset) location
in the cache memory.
Cache Memory
Block 0
V
Block 1
V
Block 2
V
Block 3
V
Block (N-2)
V
Block (N-1)
V
Tag 0
Tag 1
Tag 2
Tag 3
Tag (N-2)
Tag (N-1)
Tag Memory
Valid Bits
TAG
INDEX
BLOCK OFFSET
BLOCK ADDRESS
SET 
selection
TAG 
comparison
WORD 
selection
CPU ADDRESS:
Fig. 6.96 Cache structure
Figure 6.97 shows the cache write operation to a 32-bit, four-way set-associative cache.
This cache contains 22-bit tag ﬁelds, 256 sets due to the eight-bit index ﬁeld, and four words
6.21
Cache Topologies
349

Block 3
Tag 0
Tag 1
TAG
INDEX
BLOCK OFFSET
BLOCK ADDRESS
Hit 3
CPU ADDRESS:
Block 2
Block 3
Block 2
Block 1
Block 0
Block 1
Block 0
Block 3
Block 2
Block 3
Block 2
Block 1
Block 0
Block 1
Block 0
Tag 2
Tag 3
Tag 0
Tag 1
Tag 2
Tag 3
Tag 0
Tag 1
Tag 2
Tag 3
Tag 0
Tag 1
Tag 2
Tag 3
SET 0
SET 1
SET 255
SET 254
BOff = 3
22
22
22
22
Hit 3
Hit 2
Hit 1
Hit 0
CPU Tag
From CPU 
CPU Index
CPU Index
22 bits
8 bits
2 bits
32
32
32
32
Hit 3
BOff = 2
Hit 3
BOff = 1
Hit 3
BOff = 0
Hit 0
32
32
32
32
Hit 0
Hit 0
Hit 0
BOff = 3
BOff = 2
BOff = 1
BOff = 0
22
22
22
22
Fig. 6.97 Cache write operation
350
6
Central Processing Unit

in a block due to the two-bit block offset ﬁeld. The write process starts with identifying the set
address using the eight-bit index ﬁeld. All four tag ﬁelds at this set address are individually
compared against the CPU tag using XNOR-gates as shown at the output stage of the tag
memory in Fig. 6.97. If one of the tags at the set address compares successfully with the CPU
tag, it creates a hit signal for the CPU to write a block of data to the corresponding set address.
The CPU data is routed through the tri-state buffers placed at the input stage of the cache
memory, and written to the designated address via the index ﬁeld and the block offset ﬁeld.
The cache read operation is similar to the cache write operation except that the cache and
the tag memories are accessed simultaneously to shorten the cache read access period.
Figure 6.98 shows the same four-way set-associative cache structure shown in Fig. 6.97.
With the eight-bit index ﬁeld deﬁning the set address, four tag blocks from the tag memory
and four data blocks from the cache memory are read out simultaneously. Each tag is
individually compared with the 22-bit tag ﬁeld in the CPU address, and hit signals are
generated using four XNOR gates. These hit signals are subsequently used as selector inputs
for the 4-1 MUX at the output of the cache memory to select one of the cache blocks. The
word from the chosen block is selected by the two-bit block offset ﬁeld and given to the CPU.
6.23
A Direct-Mapped Cache Example
Even though cache read/write protocols and the related hardware have been explained in the
earlier sections of this chapter, the example shown in Fig. 6.99 further clariﬁes the operation
of a direct-mapped cache.
The cache structure in this example consists of eight sets due to the three-bit index ﬁeld in
the CPU address with no block offsets. Therefore, each data block contains a single ﬁve-bit
word with a two-bit tag ﬁeld.
Assume that the CPU issues cache reads from the following addresses: 10101, 10010,
10101, 01010, 10000, 10110, 10000, 10111 and 01111. When the cache is ﬁrst turned on, its
tag, valid bits and data ﬁelds are all zero. The index column in Fig. 6.99 is not an actual part
of cache memory. Its sole purpose is simply to indicate a set address.
When the CPU issues the ﬁrst read from the address 10101, the tag memory contents 00 at
the set address 101 are compared against the tag ﬁeld contents of 10 in the CPU address.
Since the two values are different from each other, the cache controller issues a cache miss,
fetches the data, mem (10101), from the main memory address of 10101, delivers this data to
the CPU, and stores the same data in the cache. It also updates the tag contents with 10, and
issues valid bit = 1.
Next, the CPU issues the second read from the address 10010. This time, the tag memory
contents 00 at the set address 010 are compared with the tag ﬁeld of 10 in the CPU address. The
comparisonfails and produces amiss. The cache controller fetches the data, mem(10010),from
the main memory, writes this data at the set address 010 of the cache memory, delivers the same
data to the CPU, updates the tag memory with 10, and produces valid bit = 1.
6.22
Cache Write and Read Structures
351

Block 3
Tag 0
Tag 1
TAG
INDEX
BLOCK OFFSET
BLOCK ADDRESS
Hit 3
CPU ADDRESS:
Block 2
Block 3
Block 2
Block 1
Block 0
Block 1
Block 0
Block 3
Block 2
Block 3
Block 2
Block 1
Block 0
Block 1
Block 0
Tag 2
Tag 3
Tag 0
Tag 1
Tag 2
Tag 3
Tag 0
Tag 1
Tag 2
Tag 3
Tag 0
Tag 1
Tag 2
Tag 3
SET 0
SET 1
SET 255
SET 254
128
128
128
128
128
32
Hit 2
Hit 1
Hit 0
3
2
1
0
CPU Block Offset
2
22
22
22
22
Hit 3
Hit 2
Hit 1
Hit 0
CPU Tag
To CPU 
CPU Index
CPU Index
22 bits
8 bits
2 bits
22
22
22
22
Fig. 6.98 Cache read operation
352
6
Central Processing Unit

TAG
2 bits
3 bits
0 bits
INDEX
BOFF
CPU Address: 
(3)   After the MISS at address 10010
(4)   After the HIT at address 10101 
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
0
0
1
0
0
1
0
0
00
00
10
00
00
10
00
00
0
0
0
0
mem (10101)
0
0
mem (10010)
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
0
0
1
0
0
1
0
0
00
00
10
00
00
10
00
00
0
0
0
0
mem (10101)
0
0
mem (10010)
(5)   After the MISS at address 01010
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
0
0
1
0
0
1
0
0
00
00
01
00
00
10
00
00
0
0
0
0
mem (10101)
0
0
mem (01010)
(6)   After the MISS at address 10000
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
1
0
1
0
0
1
0
0
10
00
01
00
00
10
00
00
0
0
0
mem (10101)
0
0
mem (01010)
mem (10000)
(7)   After the MISS at address 10110
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
1
0
1
0
0
1
1
0
10
00
01
00
00
10
10
00
0
0
0
mem (10101)
0
mem (01010)
mem (10000)
mem (10110)
(8)   After the HIT at address 10000
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
1
0
1
0
0
1
1
0
10
00
01
00
00
10
10
00
0
0
0
mem (10101)
0
mem (01010)
mem (10000)
mem (10110)
(9)   After the MISS at address 10100
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
1
0
1
0
1
1
1
0
10
00
01
00
10
10
10
00
0
0
0
mem (10101)
mem (01010)
mem (10000)
mem (10110)
mem (10100)
(10)   After the MISS at address 11111
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
1
0
1
0
1
1
1
1
10
00
01
00
10
10
10
11
0
0
mem (10101)
mem (01010)
mem (10000)
mem (10110)
mem (11111)
mem (10100)
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
0
0
0
0
0
0
0
0
00
00
00
00
00
00
00
00
0
0
0
0
0
0
0
0
(1)   Initial state of the cache
INDEX
TAG
DATA
000
001
010
011
100
101
110
111
V
0
0
0
0
0
1
0
0
00
00
00
00
00
10
00
00
0
0
0
0
0
mem (10101)
0
0
(2)   After the MISS at address 10101
Fig. 6.99 A direct-mapped cache operation
6.23
A Direct-Mapped Cache Example
353

The CPU reissues another read from the address 10101. The tag memory contents of 10 at
the set address of 101 compare successfully with the CPU tag ﬁeld of 10. As a result, the
cache controller issues a hit. The data, mem (10101), at the set address 101 is transferred
directly from the cache memory to the CPU.
The next CPU address 01010 accesses the set 010 in the tag memory, but ﬁnds the tag
memory contents of 10 at this address is different from the tag ﬁeld contents of 01 in the
CPU address. Therefore, the cache controller issues a miss, fetches mem (01010) from the
main memory, and delivers this data to the CPU and the cache memory. It also updates
the tag contents with 01, and issues valid bit = 1.
The ﬁfth address 10000 creates another miss because the tag memory contents of 00 at the
set address of 000 do not compare with the tag contents of 10 at the CPU address. The cache
controller transfers mem (10000) from the main memory to the set address 000 of the cache,
delivers the same data to the CPU, updates the tag contents with 10, and produces valid bit = 1.
When the CPU issues the sixth address 10110, the cache controller ﬁnds the tag memory
contents of 00 at the set address of 110 to be different from the tag ﬁeld contents of 10 in the
CPU address, and issues a miss. Consequently, the cache controller fetches mem (10110)
from the main memory, delivers it to the CPU and the cache memory. It also updates the tag
memory with 10, and assigns valid bit = 1.
Next, the CPU reissues the address 10000. Since the CPU and the tag memory contents
match, this creates a cache hit. The cache controller simply delivers mem (10000) from the
set address 000 of the cache to the CPU.
The next address, 10100, creates another cache miss. The cache controller updates the set
address contents with mem (10100) and delivers the same data to the CPU. It also updates
the tag memory with a value of 10 and issues valid bit = 1.
When the last CPU address, 11111, is issued, the cache controller ﬁnds the tag ﬁeld
contents of 11 in the CPU address to be different from the tag memory contents of 00 at the
set address of 111. It issues a miss and delivers mem (11111) to both the CPU and the cache.
It updates the tag memory with 11 and assigns valid bit = 1.
6.24
Write-Through and Write-Back Cache Structures in Set-Associative
Caches
It is very common to see two types of cache structures when analyzing set-associative
caches: write-through caches and write-back caches.
In write-through caches, the cache controller maintains data coherency between the cache
and the main memory before starting a new task.
In write-back caches, the wait time for data coherency is an essence. For example, if the
transaction is a read, but the main memory bus is busy with another data transfer, the cache
controller temporarily stores the data from the cache in a write-back buffer instead of waiting
to write it to the main memory, and starts a new task. When the bus arbiter grants the bus
354
6
Central Processing Unit

access, the cache controller resumes transferring this data from the write-back buffer to the
main memory.
6.25
A Two-Way Set-Associative Write-Through Cache Example
The example in Fig. 6.100 shows 14 different transactions between a two-way
set-associative write-through cache and a CPU. The initial contents of the main memory
are shown in the same ﬁgure. Each transaction is speciﬁed by a CPU address, the type of
transaction and data.
The CPU address in this example consists of six bits: the most signiﬁcant four bits deﬁne
the tag address; the least signiﬁcant two bits indicate the set address as shown in Fig. 6.101.
Transaction No
CPU Address
Read/Write
CPU Data
1
2
3
4
5
6
7
8
9
10
11
12
13
14
010101
110001
100000
100011
110000
010011
000110
001110
110000
100000
100100
100100
111100
000000
Read
Read
Read
Read
Read
Read
Read
Write
Write
Write
Write
Write
Write
Write
-
-
-
-
-
-
0x0B
0x1B
0x2B
0x3B
0x0C
0x1C
0x2C
-
0x3F
0x3A
0x0A
0x0E
0x0F
0x2A
0x1A
000000
010011
010101
100000
100011
110000
110001
MAIN MEMORY
(Word Addressable)
Fig. 6.100 A two-way set-associative write-through cache pending transactions and initial
data memory contents
6.24
Write-Through and Write-Back Cache Structures in Set-Associative Caches
355

CPU Address
TAG
INDEX
WAY 1
WAY 0
Set 0
Set 1
Set 2
Set 3
6 bits
6 bits
WAY 1
WAY 0
4 bits
4 bits
V
V
0x0E
0x2A
0x0A
0x1A
0x0F
0x3A
WAY 1
WAY 0
1000
1100
0101
1100
1000
0100
WAY 1
WAY 0
1
1
1
V
1
1
1
V
0x3B
0x2B
0x0A
0x1A
0x0B
0x1B
0x0F
0x3A
WAY 1
WAY 0
1000
1100
0101
1100
0001
0011
1000
0100
WAY 1
WAY 0
1
1
1
1
V
1
1
1
1
V
0x1C
0x3F
0x0A
0x1A
0x0B
0x1B
0x0F
0x3A
WAY 1
WAY 0
1001
0000
0101
1100
0001
0011
1000
0100
WAY 1
WAY 0
1
1
1
1
V
1
1
1
1
V
End of 6th transaction:
End of 10th transaction:
End of 14th transaction:
MAIN MEMORY
0x3F
0x00 →0x0B
-
0x00 →0x1B
-
0x3A
-
0x0A
-
0x0E → 0x3B
-
0x0F
-
0x00→0x0C →0x1C
-
0x2A → 0x2B
0x1A
-
0x00 →0x2C
000000
000110
001110
010011
010101
100000
100011
100100
110000
110001
TAG MEMORY
CACHE MEMORY
4 bits
2 bits
Set 0
Set 1
Set 2
Set 3
Set 0
Set 1
Set 2
Set 3
Set 0
Set 1
Set 2
Set 3
Set 0
Set 1
Set 2
Set 3
Set 0
Set 1
Set 2
Set 3
Set 0
Set 1
Set 2
Set 3
Set 0
Set 1
Set 2
Set 3
111100
-
0x1C
0x2B
0x0A
0x1A
0x0B
0x1B
0x0F
0x3A
WAY 1
WAY 0
1001
1100
0101
1100
0001
0011
1000
0100
WAY 1
WAY 0
1
1
1
1
V
1
1
1
1
V
End of 12th transaction:
Set 0
Set 1
Set 2
Set 3
Set 0
Set 1
Set 2
Set 3
Fig. 6.101 A two-way set-associative write-through cache, tag and data memory contents
after the sixth, tenth, twelfth and fourteenth transactions
356
6
Central Processing Unit

There are no bits for block offset, which indicates every block consists of a single word with
six bits of data. Since this is a two-way set-associative cache, the memory is organized as
two adjacent data blocks for every set. The tag memory also consists of two adjacent tag
ﬁelds with valid bits for each set as shown in Fig. 6.101.
The data from the main memory can either go to the most signiﬁcant (WAY 1) or the least
signiﬁcant (WAY 0) block position of the two-way set-associative cache. Therefore, a data
replacement policy must be deﬁned when designing a set-associative cache architecture. In
this example, let us assume that the data replacement policy dictates the old data with smaller
number of memory references (the total number of reads and writes) to be replaced. If the
number of memory references at either cache blocks is equal to each other, the block of data
at the most signiﬁcant cache position is replaced with the new data.
The ﬁrst transaction reads from the memory address of 010101. In this transaction, the
cache controller compares the tag ﬁeld contents of 0101 in the CPU address with the tag
memory contents of 0000 at the set address 01, and issues a miss. Next, the cache controller
fetches 0x0A from the main memory address of 010101, and delivers it to the CPU. Since
the number of memory references at the most and the least signiﬁcant cache positions are
both zero at this point, the cache controller places 0x0A at the most signiﬁcant cache
position as the result of the data replacement policy. It also updates the tag memory with
0101, and assigns valid bit = 1.
The next ﬁve read transactions result in ﬁve consecutive cache misses. By the end of the
sixth transaction, six new data entries from the main memory are written to both the cache
and the tag memories as shown in Fig. 6.101.
The seventh CPU transaction is a write. The CPU issues to write 0x0B to the main
memory address of 000110. As for the read operations, the cache controller compares the tag
memory contents of 0000 at the set address of 10 with the tag ﬁeld contents of 0001 in the
CPU address, and issues a miss. The data, 0x0B, is written to both the main memory address
of 000110 and the most signiﬁcant cache position at the set address of 10. The tag memory is
also updated with 0001, and valid bit = 1.
In the eight transaction, the cache controller again issues a miss for the set address of 10
because the tag ﬁeld comparison fails. Consequently, the cache controller stores the CPU
data, 0x1B, in the main memory address of 001110, and also writes this data to the least
signiﬁcant cache position at the set address of 10. The tag memory is updated with 0011 and
valid bit = 1.
The next write compares the tag ﬁeld entry of 1100 in the CPU address with all the tag
memory entries at the set address of 00. Since the least signiﬁcant tag memory contents are
identical to the CPU tag entry, the cache controller issues a hit, but still replaces the contents
of the main memory at the address of 110000 and the contents of the cache memory at the set
address of 00 with 0x2B. This is because the architecture of this cache is a write-through
which requires the cache and the main memory contents to be the same before the cache
controller starts a new task. Therefore, there is really no difference between a cache write
6.25
A Two-Way Set-Associative Write-Through Cache Example
357

miss and cache write hit when it comes to updating the cache and the main memory contents.
In both cases, the cache controller has to wait until the current data transaction ends before
updating the main memory. However, the tag memory contents require no updating fol-
lowing a cache write hit.
The tenth transaction is another CPU write which results in a cache hit. Like the previous
write transaction, the cache controller has to replace the contents of the main memory at the
address of 100000 and the contents of the cache memory at the set address of 00 with 0x3B.
At the end of the tenth transaction, the cache and the tag memory contents are shown in
Fig. 6.101 with two memory references for the set address of 00, and one memory reference
for the remaining set addresses.
The eleventh transaction creates a cache miss and causes the cache controller to replace the
data 0x3B at the most signiﬁcant cache position with the CPU data of 0x0C at the set address
of 00. The most signiﬁcant tag entry, 1000, is also replaced with 1001 at the same set address.
The twelfth transaction creates a cache hit because the CPU tag ﬁeld, 1001, compares
successfully with the tag memory contents at the set address of 00. However, the cache
controller replaces 0x0C at the main memory address of 100100 and at the set address of 00
with the new CPU data 0x1C.
In the thirteenth transaction, the CPU address of 111100 causes a cache miss. The CPU
data, 0x2C, is written both to the main memory address, 111100, and the least signiﬁcant
cache position at the set address of 00 per data replacement policy. The least signiﬁcant tag
memory contents at the set address of 00 are also updated with 1111.
The fourteenth transaction is a memory read and causes another miss. The cache con-
troller delivers 0x3F from the main memory location of 000000 to the CPU and writes the
same data to the least signiﬁcant cache position at the set address of 00.
6.26
A Two-Way Set-Associative Write-Back Cache Example
The example in Fig. 6.102 shows the transactions between a CPU and a two-way
set-associative write-back cache. The initial contents of the main memory and the cache are
shown in the same ﬁgure. The CPU address in this example has eight bits. The most
signiﬁcant four bits are reserved for the tag ﬁeld. The two-bit index ﬁeld indicates that there
are four sets in the cache memory. The two-bit block offset ﬁeld signiﬁes that there are four
eight-bit wide words in each block. Therefore, the cache memory consists of two adjacent
blocks at WAY 1 and WAY 0 positions, each containing four words. The tag memory has
also two adjacent tag entries with valid bits. Each tag represents a block in the cache
memory. The data replacement policy for this example assumes to replace the block of data
in the cache memory with the least number of memory references. If the number of memory
references at each block is the same, then the policy replaces the old data at the least
signiﬁcant block position.
358
6
Central Processing Unit

Two-Way Set-Associative Tag Memory
Transaction No
CPU Address
Read/Write
CPU Data
1
2
3
4
10001000
10000000
10000001
10000010
10000011
10000000
10000001
10000010
10000011
11000000
Read
Write
Write
Write
Write
Write
Write
Write
Write
Read
-
0xE0
0xE1
0xE2
0xE3
0xF0
0xF1
0xF2
0xF3
-
0xA0
10001000
MAIN MEMORY
(Word Addressable)
0xC3
WAY 1
Set 0
Set 1
Set 2
Set 3
Two-Way Set-Associative Cache Memory
0xC2
0xC1
0xC0
11
10
01
00
WAY 0
11
10
01
00
0
WAY 1
Set 0
Set 1
Set 2
Set 3
1011
D
TAG
0xB3
0xB2
0xB1
0xB0
1
V
0
WAY 0
1010
D
TAG
1
V
0xA1
10001001
0xA2
10001010
0xA3
10001011
0xB0
10101000
0xB1
10101001
0xB2
10101010
0xB3
10101011
0xC0
10111000
0xC1
10111001
0xC2
10111010
0xC3
10111011
0xD0
11000000
0xD1
11000001
0xD2
11000010
0xD3
11000011
Write-Back Buffer
Block 1
Block 0
-
-
-
-
-
-
-
-
CPU Address
4 bits
BOFF
INDEX
TAG
2 bits
2 bits
Fig. 6.102 A two-way set-associative write-back cache pending transactions and initial data
memory
6.26
A Two-Way Set-Associative Write-Back Cache Example
359

Since this is a write-back cache, its architecture enables the cache controller to store the
CPU data temporarily in a buffer to be written to the main memory at a later time. Every time
a block of data is written to this buffer, a dirty bit is attached to its tag, designating that this
block is waiting to be written to the main memory. Therefore, the cache coherency mech-
anism that presides over write-through caches is not valid for write-back caches. Instead, the
dirty bit attached to each tag entry determines whether or not a block of data exists in both
the cache and the main memories.
Initially, identical data resides both in the main memory and the cache as shown in
Fig. 6.102, and therefore valid bits at the set address of 10 in the tag memory become equal
to one. Since the write-back buffer cache architecture does not offer any data waiting period
for the main memory, the dirty bits at the set address 10 are equal to zero.
The ﬁrst CPU transaction is to read data from the memory address 10001000. The cache
controller compares the tag entry 1000 in the CPU address with all the tags at the set address
10 and issues a miss. It then transfers the block of data from the main memory address
10001000 (0xA0, 0xA1, 0xA2 and 0xA3) to replace the old block (0xB0, 0xB1, 0xB2 and
0xB3) at the least signiﬁcant cache position. The cache controller also updates the corre-
sponding tag contents with 1000 as shown at the top portion of Fig. 6.103.
The next CPU transaction is a write, which results in a cache miss. Consequently, the
cache controller writes the contents of the CPU data that consists of 0xE0, 0xE1, 0xE2 and
0xE3 to the least signiﬁcant cache position at the set address 00, and updates the tag memory
contents with 1000. However, during this transaction the data bus happens to be busy.
Therefore, the cache controller stores this block in the write-back buffer, assigns dirty bit = 1
and valid bit = 0, and starts the next transaction. When the bus access is granted, the cache
controller resumes transferring this data from the write-back buffer to the main memory, and
assigns dirty bit = 0 and valid bit = 1.
The third CPU transaction is a write and results in a cache hit. The cache controller simply
writes the new block of data, 0xF0, 0xF1, 0xF2 and 0xF3, to the write-back buffer and to the
least signiﬁcant block position of the cache memory, replacing the old block, 0xE0, 0xE1,
0xE2 and 0xE3. Since this transaction does not require transferring the old block from the
write-back buffer to the main memory, write-back cache scheme creates a distinct speed
advantage compared to the write-through scheme.
The last CPU transaction is a memory read that results in a miss. Consequently, the data
block, 0xD0, 0xD1, 0xD2 and 0xD3, that resides at the main memory address 11000000 is
transferred to the most signiﬁcant block position of the cache memory at the set address 00
since this position has zero memory references compared to the least signiﬁcant block
position. The tag memory contents are updated with 1100, valid bit = 1 and the dirty bit = 0
at this set address.
360
6
Central Processing Unit

0xC3
WAY 1
Set 0
Set 1
Set 2
Set 3
0xC2
0xC1
0xC0
11
10
01
00
WAY 0
11
10
01
00
0
WAY 1
Set 0
Set 1
Set 2
Set 3
1011
D
TAG
0xA3
0xA2
0xA1
0xA0
1
V
0
WAY 0
1000
D
TAG
1
V
Write-Back Buffer
Block 1
Block 0
-
-
-
-
-
-
-
-
Two-Way Set-Associative Cache Memory
Two-Way Set-Associative Tag Memory
AFTER THE 1st TRANSACTION
0xC3
WAY 1
Set 0
Set 1
Set 2
Set 3
0xC2
0xC1
0xC0
11
10
01
00
WAY 0
11
10
01
00
0
WAY 1
Set 0
Set 1
Set 2
Set 3
1011
D
TAG
0xE3
0xA3
0xE2
0xA2
0xE1
0xA1
0xE0
0xA0
1
V
1
0
WAY 0
1000
1000
D
TAG
0
1
V
Write-Back Buffer
Block 1
Block 0
0xE0
0xE1
0xE2
0xE3
-
-
-
-
Two-Way Set-Associative Cache Memory
Two-Way Set-Associative Tag Memory
AFTER THE 2nd TRANSACTION
0xC3
WAY 1
Set 0
Set 1
Set 2
Set 3
0xC2
0xC1
0xC0
11
10
01
00
WAY 0
11
10
01
00
0
WAY 1
Set 0
Set 1
Set 2
Set 3
1011
D
TAG
0xF3
0xA3
0xF2
0xA2
0xF1
0xA1
0xF0
0xA0
1
V
1
0
WAY 0
1000
1000
D
TAG
0
1
V
Write-Back Buffer
Block 1
Block 0
0xF0
0xF1
0xF2
0xF3
-
-
-
-
Two-Way Set-Associative Cache Memory
Two-Way Set-Associative Tag Memory
AFTER THE 3rd TRANSACTION
0xD3
0xC3
WAY 1
Set 0
Set 1
Set 2
Set 3
0xD2
0xC2
0xD1
0xC1
0xD0
0xC0
11
10
01
00
WAY 0
11
10
01
00
0
0
WAY 1
Set 0
Set 1
Set 2
Set 3
1100
1011
D
TAG
0xF3
0xA3
0xF2
0xA2
0xF1
0xA1
0xF0
0xA0
1
1
V
1
0
WAY 0
1000
1000
D
TAG
0
1
V
Write-Back Buffer
Block 1
Block 0
0xF0
0xF1
0xF2
0xF3
-
-
-
-
Two-Way Set-Associative Cache Memory
Two-Way Set-Associative Tag Memory
AFTER THE 4th TRANSACTION
Fig. 6.103 A two-way set-associative write-back cache with tag and write-back buffers
6.26
A Two-Way Set-Associative Write-Back Cache Example
361

Review Questions
1. A 32-bit RISC CPU organized in Big Endian format has three pipeline stages to
execute the following two instructions:
ADDI RS, RD, Imm Value
Reg[RS] + Imm Value ! Reg[RD]
XOR RS1, RS2, RD
Reg[RS1] + Reg[RS2] ! Reg[RD]
Draw the detailed ALU and the CPU schematic that executes these two instructions.
Label all interconnections, bus widths and control signals.
2. An eight-bit CPU interacts with a two-way set-associative write-through cache
organized in Little Endian format. The top row of this cache corresponds to set 0.
The CPU address has the following format:
Tag
Index
Block offset
3 bits
3 bits
2 bits
Data replacement policy in case of a miss is as follows:
(i) Tags with invalid bits are replaced.
(ii) The least signiﬁcant tag is replaced if the number of references is the same when
valid bit = 1 (every cache read or write is considered a reference).
(a) Draw the block diagram of the tag (with valid bits) and cache memories. Calculate
how many bits are in each memory.
(b) Draw the block diagram and the contents of the cache and the tag memories at the
end of the ﬁfth, eleventh and thirteenth transactions according to the transaction list
below:
362
6
Central Processing Unit

Transaction no.
CPU Address
Data
Write/Read
1
2
3
4
5
6
7
8
9
10
11
12
13
10100110
00111001
11110100
10001111
00100110
00111011
00111001
11001111
01101101
00010100
10100110
00100111
00101111
0x11
0x22
0x33
0x44
0x55
0x66
0x77
0x88
0x99
0xAA
?
?
?
W
W
W
W
W
W
W
W
W
W
R
R
R
3. The following speciﬁcation is given for implementing a 32-bit RISC processor that
executes the integer multiply-add (MADD) and add (ADD) instructions:
(i)
Data, a, b, c and d are read from the DOut1, DOut2, DOut3 and DOut4 ports of
the 32-bit RF at the same time.
(ii)
There are four stages in the processor. The ALU consists of two stages.
(iii)
Multiplication is the ﬁrst ALU stage for the MADD instruction between a and b,
and between c and d. It takes one clock cycle to produce results which are
eventually written to the DinH (for higher 32 data bits) and DinL (for lower 32
data bits) ports of the RF simultaneously. This stage can be bypassed if addition
is performed between a and c.
(iv)
Addition is the second ALU stage, and it also takes one clock cycle to produce
results.
(v)
For MADD instruction, RS1 is the ﬁrst source address that contains a, RS2 is the
second source address that contains b, RS3 is the third source address that
contains c, and RS4 is the fourth source address that contains d. RD1 is the ﬁrst
destination address that stores the lower 32 bits of the result, and RD2 is the
second destination address that stores the higher 32 bits. For the ADD
instruction, RS1 is the ﬁrst source address that contains a, RS3 is the second
address that contains c, and RD1 is the destination address that stores the result.
6.26
A Two-Way Set-Associative Write-Back Cache Example
363

(a) Draw the instruction bit ﬁeld format of these two instructions, indicating the
opcode and operand ﬁelds.
(b) Draw the architectural diagram of the processor that executes the ADD and the
MADD instructions, indicating all the necessary hardware such as the required
memories, the RF, the detailed ALU with all the port names and bit widths. Show
how the opcode decoder enables multiplexers and other hardware in each stage.
4. The area under y = x is calculated until the area equals to 18 square units.
y
x
0
1
2
3 .  .  .  .
delx
y = x
The incremental area is calculated in the ﬂow chart given below.
area = 0, delx = 1, x = 0
area = area + delx * (y1+y2)/2
STORE area at mem=100
y1 = x, y2 = x+delx
x = x+delx
area:18
364
6
Central Processing Unit

(a) Assuming Reg[R0] = 0, write a program using the instruction set given in Chapter 6.
Make comments next to each instruction in the program.
(b) Form an instruction chart (histogram) for this program and show all the data
dependencies that require forwarding loops in the RISC processor. Stall the
pipeline using the NOP instruction if necessary. Consider the branch or jump delay
penalty to be 1 cycle.
5. A RISC CPU computes the following:
X ¼ 2 A2 þ 1
A is located at the data cache address, 100, and X needs to be stored at the address,
200. All instructions take one cycle except the multiply, which takes three cycles.
The RF contains only R0 and R1. The contents of R0 are 0.
Make sure to have only 16-bit values in the source registers, RS1 and RS2, in order to
avoid the overﬂow condition in the destination register, RD, when the MUL
instruction is used.
(a) Write an assembly code to compute and store the value of X. Make sure to write
comments next to each instruction to keep track of the register values.
(b) Rewrite the assembly code with an instruction chart. Indicate all the forwarding
loops and the stalls caused by the NOP instructions on this chart.
6. Design a four-way set-associative cache for an eight-bit CPU. The cache is organized
in Little Endian format. It has four sets, and each block in the set contains two words.
The replacement policy on a cache miss is as follows:
(i)
An entire block of data is exchanged between the CPU and the cache
(ii)
The least signiﬁcant block is replaced
(iii)
The block with the fewest number of memory references is replaced (a memory
reference corresponds to each memory-read or memory-write cycle)
Below is the list of CPU transactions:
6.26
A Two-Way Set-Associative Write-Back Cache Example
365

The contents of the main memory before any transaction are shown below:
Transaction no.
CPU Address
Data
Write/Read
1
2
3
4
5
6
7
8
9
10
11
12
10000010
10000110
01111101
00100011
00001010
00001101
10001001
10001010
10000000
00001010
11011010
11011011
11111011
0xAB
R
R
R
R
R
R
R
R
W
W
W
W
R
10000001
0xCD
W
00001011
W
0xAB
0xCD
0xAB
0xCD
?
?
?
?
?
?
?
?
?
366
6
Central Processing Unit

(a) Draw the block diagram of the cache and tag memories. Show the ﬁeld format of
the CPU address in terms of tag, index and block offset.
0x33
00001010
0x44
00001011
0x55
00001100
0x66
00001101
0x11
00100010
0x22
00100011
0xEE
01111100
0xFF
01111101
0x00
10000000
0x00
10000001
0xAA
10000010
0xBB
10000011
0xCC
10000110
0xDD
10000111
0x77
10001000
0x88
10001001
0x00
10001010
0x99
10001011
0x00
11011010
0x00
11011011
0xAB
11111010
0xCD
11111011
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
7
0
6.26
A Two-Way Set-Associative Write-Back Cache Example
367

(b) Show the contents of the cache and the tag memories after the eighth, tenth and
twelfth transactions. Update the main memory contents if there is any change.
7. A 32-bit, ﬁve-stage RISC CPU organized in Little Endian format executes the ﬂow
chart below. The CPU contains a register ﬁle with 32 registers where Reg[R0] = 0.
The integer values, SUM = 0, i = 1 and the compare value of 100, are stored at the data
memory locations 100, 101 and 102, respectively. The ﬁnal SUM needs to be stored at
the data memory address, 200.
SUM = 0
at mem (100)
i = 1
at mem (101)
SUM = SUM + i
i : 100
i = i + 1
STORE 
SUM at mem (200)
i < 100
i = 100
(a) Write an assembly program using the following instruction set. Accompany each
instruction in the program with register data and comments.
368
6
Central Processing Unit

(b) Draw the CPU schematic that executes the instructions in the ﬂow chart above.
8. The function, Y ¼ 5ðABÞ
32
, needs to be executed using the instruction set below.
A is located at the memory address 100.
B is located at the memory address 101.
Y needs to be stored at the memory address 102.
Reg[R0] = 0.
LOAD RS, RD, Imm Value
STORE RS, RD, Imm Value
ADD RS1, RS2, RD
LOAD
RS
RD
Imm Value
26
31
STOR
RS
RD
Imm Value
ADD
RS1
RS2
RD
Not used
mem {Reg [RS] + Imm} → Reg [RD] 
Reg [RS] →  mem {Reg [RD] + Imm}
Reg [RS1] + Reg [RS2] → Reg [RD]
Instruction Set
Instruction Definition
Instruction Bit Field
25
21 20
16 15
0
26
31
25
21 20
16 15
0
26
31
25
21 20
1615
0
11 10
SUB RS1, RS2, RD
SUB
RS1
RS2
RD
Not used
Reg [RS1] - Reg [RS2] → Reg [RD]
26
31
25
21 20
1615
0
11 10
SLI RS, RD, Imm Value
SLI
RS
RD
Imm Value
26
31
Reg [RS] << Imm → Reg [RD] 
25
21 20
16 15
0
SRI RS, RD, Imm Value
SRI
RS
RD
Imm Value
26
31
Reg [RS] >> Imm → Reg [RD] 
25
21 20
16 15
0
LOAD RS, RD, Imm Value
STORE RS, RD, Imm Value
ADD RS1, RS2, RD
ADDI RS, RD, Imm Value
SEQ RS1, RS2, RD
BNEZ RS, Imm Value
JUMP Imm Value
LOAD
RS
RD
Imm Value
1
3
6
2
STOR
RS
RD
Imm Value
ADD
RS1
RS2
RD
Not used
ADDI
RS
RD
Imm Value
SEQ
RS1
RS2
RD
Not used
BNEZ
RS
NU
Imm Value
JUMP
NU
NU
Imm Value
mem {Reg[RS] + Imm} → 
[RD] 
Reg[RS] → mem {Reg[RD] + Imm}
Reg[RS1] + Reg[RS2] → Reg[RD] 
Reg[RS] + Imm Value → Reg[RD]  
If Reg[RS1] = Reg[RS2] 
then 1 → Reg[RD] else 0 → Reg[RD]  
If Reg [RS] ≠ 0 
then PC + Imm → PC else PC + 2 → PC 
Imm → PC 
Instruction Set
Instruction Definition
Instruction Bit Field
25
21 20
16 15
0
5
1
6
1
0
2
1
2
5
2
1
3
6
2
0
5
1
6
1
0
2
1
2
5
2
1
3
6
2
0
5
1
6
1
0
2
1
2
5
2
1
3
6
2
0
5
1
6
1
0
2
1
2
5
2
1
3
6
2
0
5
1
6
1
0
2
1
2
5
2
1
3
6
2
0
11 10
5
1
6
1
0
2
1
2
5
2
1
3
6
2
0
11 10
Reg 
6.26
A Two-Way Set-Associative Write-Back Cache Example
369

(a) Write a program to compute Y.
(b) If the LOAD and STORE instructions require two cycles to access the data cache,
rewrite the program to accommodate this requirement. Show all the forwarding
loops and include all the necessary NOPs in the instruction chart.
(c) Indicate the minimum number of clock cycles to execute the program in part (b).
9. A 32-bit CPU organized in Big Endian format has 32 general purpose registers (R0 is
also a general purpose register and its contents are not zero). This CPU executes the
following ﬂow chart:
mem{Imm0}    Reg[R0]
mem{Imm1}    Reg[R1]
Reg[R0]    Reg[R2]
Reg[R0] * Reg[R1]    Reg[R3], Reg[R4]
Reg[R0] + Reg[R1]    Reg[R5]
Reg[R1]    Reg[R6]
Reg[R3]    mem{Imm3}
Reg[R4]    mem{Imm4}
Reg[R2]    mem{Imm2}
Reg[R5]    mem{Imm5}
Reg[R6]    mem{Imm6}
370
6
Central Processing Unit

The instruction set and the bit-ﬁeld format for each instruction is shown below.
The CPU maintains the following rules:
(i)
Every instruction is executed in a different number of clock cycles
(ii)
No NOP instruction is allowed
(iii)
LOAD does not have an ALU cycle but requires two data memory cycles
(iv)
INVERT does not have a data memory cycle but requires one ALU cycle
(v)
MUL does not have a data memory cycle but requires three ALU cycles
(vi)
ADD does not have a data memory cycle but requires two ALU cycles
(vii)
STORE does not have an ALU cycle but requires one data memory cycle
Write a program and construct its instruction chart to execute the ﬂow chart above.
Show all the necessary forwarding loops and possible data hazards in the instruction
chart. Show the cases in which there may be structural hazards and indicate how to
prevent them.
10. An eight-bit CPU has a four-way set-associative, write-back data cache organized in
Little Endian format (the most signiﬁcant bit is at bit position 7 and the least signif-
icant bit is at bit position 0).
The cache has four sets, and each block contains two eight-bit words. In the case of a
cache miss the cache controller replaces the least signiﬁcant, least used block.
The write-back buffer stores four rows of block data in case of a cache miss. When all
four rows are ﬁlled with data, the cache controller transfers the contents of the entire
write-back buffer to the main memory.
CPU issues the following addresses to read and write data:
mem (Imm Value)      Reg[RD]
Reg[RS]      Reg[RD]
Reg[RS1] * Reg[RS2]      Reg[RD1], Reg[RD2]
Reg[RS1] + Reg[RS2]      Reg[RD]
Reg[RS]      mem{Imm Value}
upper
lower
LOAD
NU
RD
INVERT
RS
MUL
RS1
RS2
RD1
RD2
ADD
RS1
RS2
RD
STORE
RS
NU
0
5 6
10 11
15 16
31
0
5 6
10 11
31
0
5 6
10 11
15 16
31
0
5 6
10 11
15 16
31
0
5 6
10 11
15 16
31
20 21
25 26
20 21
RD
15 16
Imm Value
NU
NU
NU
Imm Value
LOAD  Imm Value, RD
INVERT  RS, RD
MUL RS1, RS2, RD1, RD2
ADD RS1, RS2, RD
STORE  RS, Imm Value
6.26
A Two-Way Set-Associative Write-Back Cache Example
371

CPU address
Write/Read
10000101
11000100
01000101
01100100
01110010
10100011
11100010
11110011
R
R
R
R
R
R
R
R
00100010
00110101
01000101
11110010
R
R
R
R
00001010
00001011
W
Data
0xCC
0xDD
00010010
00010011
W
0xEE
0xFF
00001100
00001101
W
0xAA
0xBB
00011100
00011101
W
0x55
0x66
?
?
?
?
?
?
?
?
?
?
?
?
Transaction No
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
Main memory contents are as follows prior to the 16 transactions listed above.
372
6
Central Processing Unit

(a) Draw the block diagrams of the cache and tag memories in Little Endian format,
making sure to attach the dirty and valid bits to each tag block. Indicate how many
bits are in each memory. Note that in this memory architecture, the top row of the
cache contains set 0, and the bottom row contains set 3.
(b) Draw the block diagrams of the cache and tag memories at end of the eighth
transaction. Show the address, control, data and cache hit/miss entries.
(c) Draw the block diagrams of the cache and tag memories at the end of the twelfth
transaction. Show the address, control, data and cache hit/miss entries.
0xEE
0xFF
0xAA
0xBB
0x55
0x66
0x77
0x88
0x12
0x34
0x11
0x22
0x56
0x78
0x33
0x44
0xAA
0xBB
0xCC
0xDD
00100010
00100011
00110100
00110101
01000100
01000101
01100100
01100101
01110010
01110011
10000100
10000101
10100010
10100011
11000100
11000101
11100010
11100011
11110010
11110011
Main Memory
6.26
A Two-Way Set-Associative Write-Back Cache Example
373

(d) Draw the block diagrams of the cache and tag memories, and the contents of the
write-back buffer at the end of sixteenth transaction. Show the address, control,
data and cache hit/miss entries.
11. The following instruction set needs to be executed in a 32-bit RISC CPU organized in
Little Endian format. The CPU has three pipeline stages where the ALU and
write-back stages are combined. The CPU is capable of executing the integer (ADDI,
SLI and SRI) and ﬂoating-point (ADDF and MULF) instructions. The CPU stores the
ﬁxed and ﬂoating-point numbers in two separate register ﬁles, each containing 32
registers.
In the instruction set below, RS and RD are deﬁned as the source and the destination
addresses for the ﬁxed-point registers. Similarly, FS1, FS2 and FD are the source and
the destination addresses for the ﬂoating-point registers. Show a detailed data-path of
this CPU, indicating all internal bus widths and port names. Include only the necessary
functional units.
Projects
1. Implement a 32-bit four-stage RISC CPU that executes only the ADD instruction in
Fig. 6.7 using Verilog. Verify the data and the control signals at the output ports of the
instruction memory, RF, ALU and write-back stages.
2. Implement the ADD, SUB, AND, NAND, OR, NOR, XOR, XNOR, SL and SR
instructions in a 32-bit four-stage RISC CPU shown in Fig. 6.15, and perform a complete
system veriﬁcation using Verilog.
3. Implement a 32-bit ﬁve-stage RISC CPU that executes the LOAD, STORE, MOVE and
MOVEI instructions using Verilog. Verify the data and the control signals at the output
ports of the instruction memory, RF, ALU, data memory and write-back stages.
ADDI RS, RD, Imm Value
ADDF
FS1
FS2
FD
Not used
Reg[RS] + Imm → Reg[RD]
Instruction Set
Instruction Definition
Instruction Bit Field
26
31
25
21 20
1615
0
11 10
SLI RS, RD, Imm Value
SLI
RS
RD
Imm Value
26
31
Reg[RS] << Imm → Reg[RD] 
25
21 20
16 15
0
SRI RS, RD, Imm Value
SRI
RS
RD
Imm Value
26
31
Reg[RS] >> Imm → Reg[RD] 
25
21 20
16 15
0
ADDI
RS
RD
Imm Value
26
31
25
21 20
16 15
0
ADDF FS1, FS2, FD
Reg[FS1] + Reg[FS2] → Reg[FD]
MULF FS1, FS2, FD
Reg[FS1] * Reg[FS2] → Reg[FD]
MULF
FS1
FS2
FD
Not used
26
31
25
21 20
1615
0
11 10
374
6
Central Processing Unit

4. Implement a 32-bit four-stage RISC CPU that executes only the BRA instruction shown
in Fig. 6.36 using Verilog. Verify the data and the control signals at the output ports of
the instruction memory and RF stages.
5. Implement and verify the 32-bit ﬂoating-point adder in Fig. 6.61 using Verilog. Verify
the validity of data at the outputs of every major stage using timing diagrams and perform
functional veriﬁcation for the entire adder.
6. Implement and verify the 32-bit ﬂoating-point multiplier in Fig. 6.62 using Verilog.
Verify the validity of data at the outputs of every major stage using timing diagrams, and
perform functional veriﬁcation for the entire multiplier. Use behavioral Verilog to mimic
the exponent adder and the integer multiplier.
References
1. Patterson DA, Ditzel DR (1980) The case for the reduced instruction set computer. ACM SIGARCH Comput Archit
News 8(6):25–33
2. Patterson DA, Sequin CH (1981) RISC I: a reduced instruction set VLSI computer. In: ISCA Proceedings of the 8th
annual symposium on computer architecture, pp 443–457
3. Sequin CH, Patterson DA (1982) Design and implementation of RISC I. In: Proceedings of the advanced course on
VLSI architecture, University of Bristol, pp 82–106
4. Patterson DA, Hennessy JL. Computer organization and design, the hardware/software interface, 2nd edn. Morgan
Kaufmann, ISBN: 1558604286
6.26
A Two-Way Set-Associative Write-Back Cache Example
375

7
System Peripherals
When the host processor executes a user program, it either exchanges data with system
memories such as SRAM, SDRAM or Flash, or communicates with system peripherals to
perform various tasks.
A conventional computing system may consists of one or more CPU cores, co-processors
such as hardware accelerators to perform specialized tasks, a Direct Memory Access
(DMA) controller to do routine data transfers from one memory to another, a display adaptor
to support user screen, and an interrupt controller. In most cases, data converters to convert
external analog signals into digital form or digital signals into analog form, timers to control
the length of an event, and transceivers in charge of serially transmitting and receiving
peripheral data are interrupt-driven and connected to the interrupt controller. The interrupt
controller, on the other hand, manages all event-driven or program-driven tasks through a
series of Interrupt Service Routines (ISR) that reside inside the program memory.
7.1
Overall System Arcitecture
A basic system architecture containing essential bus masters and slaves is shown in Fig. 7.1.
In this ﬁgure, the CPU is a bus master that executes user programs. The Direct Memory
Access (DMA) is another bus master in charge of transferring data between different system
memories. Bus slaves are generally the system memories such as SRAM, SDRAM and Flash
memory. However, other system devices that reside on the high speed bus such as the
display adaptor or peripheral buffer memories connected to the low speed I/O bus are also
considered bus slaves.
The display adaptor is considered an essential high-speed peripheral that displays the
results of a running program or application on the screen. Because of its bandwidth, this unit
is usually connected to the parallel port of the CPU. However, there are times when the
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9_7
377

display adaptor can also be connected to the low speed I/O bus. This choice very much
depends on how often the monitor needs to be used when running an application program.
Each type of memory mentioned in Chapter 5 serves a different purpose in a system.
SRAM usually holds immediate data generated by the CPU or stores temporary data during
a DMA transfer. Larger blocks of data are stored in SDRAM since this memory is many
orders of magnitude larger in capacity compared to SRAM. Flash memory usually stores
permanent data such as the Built-In Operating System (BIOS).
A bus adaptor translates commands, address and data signals between the parallel bus
which operates at a high clock frequency and the low speed I/O bus which operates at a
much lower clock frequency.
Sensors, electro-mechanical devices, human interface devices etc. that reside outside the
main system commonly use SPI and I2C bus protocols, and considered I/O devices. Ulti-
mately, they are all connected to the interrupt controller and memory-mapped due to their
capability to store incoming or outgoing data.
The system can also be connected to other systems (or CPUs) with a network adaptor. The
simplest connection protocol is Ethernet where many systems are serially connected to the
same bus.
Cache
CPU
DMA
SDRAM
Display
Adaptor
Display
Bus
Adaptor
SRAM
Network
Adaptor
Network
Flash
Memory
Interrupt
Controller
Timers
Data
Converters
Serial
I/O devices
Low speed I/O bus
High speed parallel bus
Fig. 7.1 A typical system architecture
7.2
Direct Memory Access Controller
The CPU assigns routine memory-to-memory data transfer operations to the Direct Memory
Access (DMA) controller. Most of these transfers take place between two system memories
or between the buffer memory of a peripheral device and a system memory. This section
378
7
System Peripherals

shows how to design the basic architecture of a DMA controller that transfers data from a
source to a destination memory.
The DMA interface in Fig. 7.2 shows the I/O port description of a typical DMA controller.
In this ﬁgure, the DMA controller interacts with the CPU through handshake signals, ReqM
and AckM. When the CPU initiates a DMA data transfer, it issues a request, ReqM, to the
DMA controller. If the controller is not busy with another transfer, it then generates a request,
ReqD, to the bus arbiter to use the bus. When the arbiter acknowledges the request by AckD,
then the controller informs the CPU that it is ready to initiate the transfer by AckM, and at the
same time it sends out its ﬁrst address and control signals to the source memory. While the
source memory is delivering data, the DMA controller issues the address and control signals
for the destination memory within the same clock cycle. In order to accomplish this task, a
direct data channel must exist between the source and the destination memories. This new
conﬁguration modiﬁes the original bus structure in Fig. 5.1 in which all bus masters are
assumed to have individual write data ports to be able to write data directly to a slave.
CPU
(Bus Master)
DMA
(Bus Master)
Bus
Arbiter
Destination
Memory
Source
Memory
ReqM
AckM
ReqD
AckD
Address
Controls
RDataD
RDataS
ReadyD
From Decoder
RData
Rs
Rd
ReadyS
Fig. 7.2 The block diagram including a DMA, source and destination memories
7.2
Direct Memory Access Controller
379

Figure 7.3 shows a typical data transfer between the source and the destination memory
until the last data packet, D4, is transmitted. The sequence starts with the DMA controller
issuing Status = START and AddrS = AS1, indicating the beginning of the data transfer and
the ﬁrst source memory address, respectively. Since both memories are ready (ReadyS =
ReadyD = 1) after the ﬁrst clock cycle, the controller continues the data transfer by issuing
Status = CONT, AddrS = AS2 (the second source memory address), and AddrD = AD1
(the ﬁrst destination memory address) in the second cycle. In this cycle, the source memory
also delivers the ﬁrst data, D1, to the destination memory. The same process takes place in
the third cycle, during which the DMA controller generates AddrS = AS3, AddrD = AD2,
and writes D2 to the destination memory. In the ﬁfth clock cycle, as the DMA controller
generates the last destination memory address, AddrD = AD4, and writes the last data, D4,
to AD4, it also changes its status to IDLE, indicating the end of the data transfer.
Any time one of the Ready signals from the source or the destination memories transitions
to logic 0, the DMA controller stalls the data transfer by repeating the address and the control
signals as long as ReadyS or ReadyD is at logic 0. Figure 7.4 shows a typical data transfer in
which the destination memory is busy in the third cycle, and prompts the DMA controller to
repeat AddrS = AS3 and AddrD = AD2 in the next cycle. The DMA controller stalls the bus
again in the sixth cycle when it detects the source memory to be busy in the ﬁfth cycle.
Status
AddrS
AddrD
Data
clock
START
CONT
CONT
CONT
IDLE
AS1
AS2
AD1
D1
AD2
D2
AS3
AD3
D3
AS4
AD4
D4
ReadyS
ReadyD
Cycle 1
Cycle 2
Cycle 3
Cycle 4
Cycle 5
Fig. 7.3 Timing diagram showing a DMA-assisted data transfer
380
7
System Peripherals

A basic DMA controller is shown in Fig. 7.5. There are three modules in this architecture.
The ﬁrst module is the DMA register ﬁle that stores the initial and incremental source address
values, InitAddS, StepAddrS. The same register ﬁle contains four other registers. The InitAddrD
and the StepAddrD registers store the initial and the incremental destination addresses. The
Size and the Burst registers store the data width and the burst length, respectively. A program
data bus is used to store all six register entries before regular operations take place.
The second section of the DMA controller manages the handshake between the CPU and
the bus arbiter. This section also provides the internal signals to the DMA data-path to guide
the data.
In the third section, the DMA data-path produces source and destination addresses, AddrS
and AddrD, and the bus master control signals, Status, Size, Burst, WED (write-enable for
the destination memory) and RES (the read-enable for the source memory).
To be able to implement this architecture, three elements need to be examined in the
design phase simultaneously: a timing diagram describing an entire data transfer process
including the stall periods, a data-path that fully complies with the timing diagram, and a
control logic that manages the timely ﬂow of data on the data-path.
As pointed out in previous chapters, the design always starts with forming a timing
diagram that describes the complete data-ﬂow in a logic block. The timing diagram generally
includes a single clock (multiple clock domains or asynchronous event signals are also
common but not relevant for a basic DMA design), address, data and control signals with
respect to this clock. In order to generate an accurate timing diagram, a data-path must be
concurrently developed. The data-path generally consists of registers and logic gates.
However, it can also contain mega cells such as complex arithmetic units or memories. As
the design develops and more details are added to the original data-path, the corresponding
Status
AddrS
AddrD
Data
clock
START
CONT
CONT
CONT
CONT
AS1
AS2
AD1
D1
AS3
ReadyS
ReadyD
CONT
IDLE
AS4
AD4
D4
AD2
AD3
D2
D3
Cycle 1
Cycle 2
Cycle 3
Cycle 4
Cycle 5
Cycle 6
Cycle 7
Fig. 7.4 DMA-assisted data transfer with varying Ready signals from memories
7.2
Direct Memory Access Controller
381

InitAddrS
StepAddrS
InitAddrD
StepAddrD
Burst
Size
DMA REGISTERS
AddrS
AddrD
Size
Burst
Status
DMA
DATAPATH
DMA CONTROLLER
ReqM
ReqD
AckD
AckM
CPU
Arbiter
WED
Internal control signals
ReadyS
ReadyD
RES
Program Data
Fig. 7.5 A typical DMA architecture
timing diagram becomes more complex to accommodate the changes in the hardware. The
design of the controller to govern the data ﬂow is the last step in the design process. This
step does not start until every internal and external signal is determined, and the complete
block functionality, including all corner cases of the data-ﬂow, is explicitly depicted on the
timing diagram.
A detailed timing diagram describing a typical DMA transfer is shown in Fig. 7.6. As we
mentioned earlier in the memory-to-memory example in Chapter 2, this diagram is also
developed in two phases. In the ﬁrst phase, the main DMA signals, namely the handshake
signals with the CPU and the arbiter (ReqM, AckM, ReqD and AckD), the source and the
destination memory addresses (AddrS and AddrD), the data (Data), the bus master control
signals (Status, Burst, Size, WriteD and ReadS), and the slave response signals (ReadyS and
ReadyD) are included in the timing diagram. In the second phase, all internal control signals
that support the address and data movement in the timing diagram are brought into the
picture. This section also includes the control signals for an internal down-counter to keep
track of the number of data packets transferred from one memory to the next.
382
7
System Peripherals

clock
AddrS
AS1
AS2
AS3
AS4
AS5
AS6
AS7
AS8
AD1
AD2
AD3
AD4
AD5
AD6
AD8
AD7
AddrD
D1
D2
D3
D4
D5
D6
D8
D7
Data
ReqM
AckM
ReqD
AckD
8
7
6
5
4
3
0
2
CountOut
1
0
Status
START
CONT
CONT
CONT
CONT
CONT
CONT
CONT
IDLE
ReadyS &
ReadyD
WriteD
WED
ReadS
RES
SetAddrS
SetAddrD
IncAddrS
IAS
IncAddrD
IAD
SetSTART
SetCONT
SetIDLE
SetCount
DecCount
DC
IDLE
REQD
ACKD
SET
SRC
SET
DEST
INCR
INCR
INCR
INCR
INCR
INCR
INCR
INCR
END
SRC
END
DEST
END
COUNT
END
REQD
IDLE
Fig. 7.6 Detailed timing diagram of a DMA transfer
In Fig. 7.6, the CPU initiates a DMA-assisted data transfer by issuing a request to the
DMA controller, ReqM, in clock cycle 1. This request enables the DMA controller to
generate a subsequent request, ReqD, to the arbiter in order to use the system bus in cycle 2.
An acknowledgment from the arbiter, AckD, may come in the third cycle or many cycles
later depending on the bus trafﬁc and the other pending requests from higher priority bus
masters. However, as soon as the DMA controller receives the acknowledgement from the
arbiter, it notiﬁes the CPU by issuing an acknowledgement signal, AckM, in cycle 4. This
cycle also prepares the DMA for an upcoming data transfer by setting the SetAddrS and
SetSTART signals to logic 1. That way, the ﬁrst source memory address, AS1, can be
fetched from the InitAddrS register and delivered to the AddrS port in Fig. 7.7, and similarly
7.2
Direct Memory Access Controller
383

SetSTART
Status
stall
start
START Code
CONT Code
IDLE Code
cont
idle
SetCONT
SetIDLE
InitAddrS
StepAddrS
InitAddrD
StepAddrD
Size
Burst
stall
set
incr
clock
D
Q
SetAddrS
IncrAddrS
ReadyD
ReadyS
AddrS
stall
set
incr
clock
D
Q
SetAddrD
IncrAddrD
ReadyD
ReadyS
AddrD
Burst
clock
D
Q
DMA 
REGISTERS
stall
set
decr
clock
D
Q
SetCount
DecCount
ReadyS
ReadyD
CountOut
- 1
2
2
2
32
32
32
32
4
32
32
2
32
WriteD
ReadyS
ReadyD
WED
IAS
IAD
Size
2
ReadS
ReadyS
ReadyD
RES
SetAddrS
SetAddrD
IncrAddrS
IncrAddrD
SetSTART
SetCONT
SetIDLE
DecCount
DMA 
CONTROLLER
WriteD
ReadS
SetCount
ReqM
AckM
AckD
ReqD
DC
Program Data
Fig. 7.7 Internal DMA architecture showing its data-path and controller
384
7
System Peripherals

the START code can be produced at the Status port in cycle 5. The port selection guide for
each 3-1 MUX in Fig. 7.7 is shown in Table 7.1. In cycle 5, the ﬁrst data read command
from AS1 is issued by ReadS = 1. This cycle also sets the control signals, SetAddrD,
IncrAddrS and SetCONT, to logic 1, so that the ﬁrst destination memory address can be
retrieved from the InitAddrD register and transferred to the destination address port, AddrD,
the second source memory address, (InitAddrS + StepAddrS), can be formed at the AddrS
output, and the status code can be changed from START to CONT in the next clock cycle.
Still in cycle 5, the down-counter, responsible for counting the number of data packets to be
delivered to the destination memory, is set with an initial value from the burst register by
SetCount = 1. Therefore, when clock cycle 6 starts, the second source memory address,
AS2, is formed at the AddrS port along with the ﬁrst destination address, AD1, at the AddrD
port. The Status output indicates CONT code specifying the ongoing data transfer. In this
cycle, the ﬁrst data, D1, is transferred from the AS1 address to the AD1 address with an
active-high WriteD signal and subsequently written in the destination memory. The
CountOut output also shows the initial value from the burst register, deﬁning the number of
data packets to be written to the destination memory. This cycle sets the control signals,
IncrAddrS, IncrAddrD and DecCount, to logic 1 in order to prepare the next source and
destination addresses, and to decrement the CountOut by one in the next cycle.
Table 7.1 3-1 MUX port assignments in Fig. 7.7
SetAddrS = 1
set
ReadyS = 1
ReadyD = 1
IncrAddrS = 1
incr
ELSE
stall
PORT
INPUT
SetAddrD = 1
set
ReadyS = 1
ReadyD = 1
IncrAddrD = 1
incr
ELSE
stall
PORT
INPUT
SetCount = 1
set
ReadyS = 1
ReadyD = 1
DecCount = 1
decr
ELSE
stall
PORT
INPUT
IAS
IAD
DC
The routine data transfer continues until either the source or the destination Ready signal
transitions to logic 0. When this happens, the entire data transfer stalls, disengaging an
ongoing write process at the destination memory. In a stall, the previous source and destination
address values repeat themselves at the AddrS and AddrD ports; the down-counter stops,
displaying the remaining number of data packets to be written to the destination memory.
The data transfer resumes when the ReadyS and ReadyD signals become logic 1. Count-
Out = 2 deﬁnes the end of the data transfer. In this cycle, the IncrAddrS signal also transitions
to logic 0, indicating that there will be no more new source address generation at the AddS port.
Similarly, the SetIDLE signal goes to logic 1, changing the bus master status code from CONT
to IDLE in the next cycle. When CountOut = 1 in the following cycle, the last data is written to
the destination address. From this point forward, the DMA handshakes with the CPU and the
arbiter to terminate the data transfer. ReqD = 0 forces the arbiter to lower the acknowledge
signal, AckD. AckM = 0 prompts the CPU to lower its DMA request signal, ReqM.
7.2
Direct Memory Access Controller
385

The controller design is a direct outcome of the timing diagram in Fig. 7.6. The ﬁrst step
in the controller design is to assign a name to each clock cycle in the timing diagram that
produces a different set of outputs from the previous clock cycle. In other words, each clock
cycle that produces a different set of outputs has to be labeled with a new state in the
controller state diagram.
Cycle 1 is named as the IDLE state, producing ReqD = 0 and AckM = 0 in Fig. 7.8.
When ReqM = 1 is received in cycle 1, ReqD switches from logic 0 to logic 1 in cycle 2,
ACKD
SET
SRC
SET
DEST
INCR
END
SRC
END
DEST
END
COUNT
CountOut > 3
AckD = 1
ReqD = 1
AckM = 0
ReqD = 1
AckM = 1
SetAddrS = 1
SetSTART = 1
ReqD = 1
AckM = 1
ReadS = 1
SetAddrD = 1
IncrAddrS = 1
SetCONT = 1
SetCount = 1
ReqD = 1
AckM = 1
WriteD = 1
ReadS = 1
IncrAddrS = 1
IncrAddrD = 1
DecCount = 1
ReqD = 1
AckM = 1
WriteD = 1
ReadS = 1
IncrAddrD = 1
SetIDLE = 1
DecCount = 1
ReqD = 1
AckM = 1
WriteD = 1
ReadS = 1
DecCount = 1
ReqD = 1
AckM = 1
END
REQD
IDLE
REQD
ReqM = 0
ReqM = 1
AckD = 0
ReqD = 0
AckM = 0
ReqD = 1
AckM = 0
ReqM = 1
AckD = 1
ReqM = 1
AckD = 1
ReqM = 1
AckD = 1
ReqM = 1
AckD = 1
ReqM = 1
AckD = 1
CountOut = 3
ReqM = 1
AckD = 1
ReqD = 0
AckM = 0
ReqM = 1
AckD = 1
ReqM = 1
AckD = 1
ReqM = 1
AckD = 1
ReqM = 1
AckD = 0
Fig. 7.8 DMA controller state diagram
386
7
System Peripherals

producing a new state, REQD. ReqD = 1, on the other hand, prompts AckD = 1 in cycle 3
which creates the ACKD state in this cycle. Cycle 4 also creates a new state, SET SRC,
because a different set of control signals (AckM = 1, SetAddrS = 1 and SetSTART = 1)
emerges in this cycle. The next cycle generates a new set of outputs (ReadS =
SetAddrD = IncrAddrS = SetCONT = SetCount = 1) compared to the previous clock
cycles, and therefore it is labeled as the SET DEST state. Between cycles 6 and 13, the
controller outputs remain the same. Therefore, all these cycles can be grouped together under
the same state name, INCR. In cycle 14, the IncrAddrS signal transitions to logic 0 and the
SetIDLE signal transitions to logic 1. This new set causes the creation of a new state,
END SRC. Cycle 15 changes the controller output values once more with respect to the
previous cycle, and it is labeled as the END DEST state. In cycle 16, the down-counter
output ﬁnally reaches zero, and all the controller outputs except the AckM and ReqD signals
become logic 0. Therefore, this cycle is named as the END COUNT state. The controller
lowers the AckM and ReqD signals to logic 0, which creates a new state, END REQD in
cycle 17. In the next cycle, AckM = ReqD = 0 prompts the CPU and the arbiter to lower
ReqM and AckD signals to logic 0, respectively, and the controller transitions to the IDLE
state.
7.3
Interrupt Controller
There are numerous events that may interrupt the normal ﬂow of program execution.
External events are created by I/O devices that need speciﬁc utility programs because they
may have data ready for the CPU or require data from the CPU. There are also internal
events within the CPU that result from errors encountered when executing user programs,
such as divide-by-zero or overﬂow conditions, which create exceptions.
There are four types of interrupts according to their priority. The interrupt for resetting the
CPU takes the precedence over all other interrupts because when reset occurs, the data in
each CPU register needs to be preserved in a special memory in order to be restored later on.
Internal interrupts take the second priority after the CPU reset. These interrupts generally
originate from errors encountered in user programs or may result from breakpoints installed
in a user program. Software interrupts take the third place in the priority list. These interrupts
are actually vectored subroutine calls that stem from software emulation routines.
Floating-point division produces one such example. Hardware interrupts are placed last in
the
priority
list.
Even
though
prioritizing
hardware
interrupts
is
completely
user-programmable, the operating system may also manage the hardware priority list and
communicate with a speciﬁc device though device drivers.
In this chapter, we will examine the sequence of events that take place to handle a
hardware interrupt, and design a simple interrupt controller interface that serves up to 256
external I/O devices.
7.2
Direct Memory Access Controller
387

The interrupt process begins when one or more I/O devices submit interrupt requests to
the interrupt interface in Fig. 7.9. In this ﬁgure, the interrupt interface is designed to handle
up to 256 interrupt inputs, INTR0 through INTR255. Interrupt controller is a programmable
state machine that prioritizes all pending interrupts, selects a highest priority device
according to a priority list, and communicates with the CPU using the INTR output as shown
in Fig. 7.9. When the acknowledgement signal, INTA, is received from the CPU, the
interrupt interface transmits the device ID, INTRID, causing the interrupt on an eight-bit
wide bus.
The interrupt ID in Fig. 7.9 matches the interrupt number at the input of the interface, and
ranges between 0 and 255. Each interrupt ID correlates to a speciﬁc address in the Interrupt
Address Table, IAT, in Fig. 7.10. Each address stored in IAT points the starting address of a
particular Interrupt Service Routine (ISR) residing in the instruction memory. Therefore,
when the interrupt interface generates an INTRID and accesses a speciﬁc memory address in
the IAT, the contents at this address is immediately loaded to the Program Counter (PC).
This prompts the CPU to pause executing the normal user program, and jump to the starting
ISR address in the instruction memory to execute the corresponding ISR instructions. This
basically translates to jumping from Instr3 of the user program to Intr1 of the ISR in the
example in Fig. 7.10. While in the ISR, a return instruction, IntrRET, indicates the end of
interrupt service routine. At this point, the program returns to ARET to execute the rest of
the user program.
To convert the block diagram in Fig. 7.10 into a detailed data-path, each step of the
interrupt service routine outlined above should be translated into a timing diagram. Creating a
timing diagram, on the other hand, is usually accomplished in two steps. The ﬁrst step deﬁnes
all primary, bus-level signals such as data and address and includes them in the timing
diagram. The second step generates the necessary control signals to manage the data-ﬂow.
To achieve the ﬁrst step, let us consider the signals, INTRx (INTR0 to INTR255), INTR,
INTA, INTRID, DOutIAT and PCOut, in Fig. 7.10 and in the timing diagram in Fig. 7.11.
The signals, INTRx, INTR and INTA, are not bus-level signals; but, they are considered as
CPU
INTR0
INTR1
INTR255
Interrupt Interface
INTRID
INTR
INTA
8
Fig. 7.9 Interrupt interface input/output description
388
7
System Peripherals

the primary I/O signals that indicate the start of an interrupt. Therefore, they will be grouped
together with the other bus-level signals to show the complete interrupt sequence. In
Fig. 7.11, an I/O device issues an interrupt, INTRx = 1, to the interrupt interface in clock
cycle 1. In response, the interrupt interface generates INTR = 1 for the Interrupt Control Unit
(ICU) in charge of the handshake signals in cycle 2. In cycle 3, the ICU generates INTA = 1,
and prompts the interrupt interface to transmit an eight-bit INTRID to the IAT in the fol-
lowing cycle. As mentioned earlier, the INTRID signal is also an address for the IAT. The
data stored at this address is actually the starting address of an ISR in the instruction memory.
Therefore, the interrupt controller simply reads the memory contents at the address, INTRID,
from the DOutIAT port and waits for the interrupt service routine to begin in cycle 5. In the
PC
INTR0
INTR1
INTR255
Interrupt Interface
INTRID
INTR
INTA
Interrupt Address Table (IAT)
Interrupt Address
31
0
8
255
0
31
0
Intr1
IntrN
Interrupt 
Service 
Routine (ISR)
Instr3
Instruction Memory
IntrRET
InstrRET
Other
Interrupt 
Service 
Subroutines
Instr2
Instr1
Instr4
A1
A2
A3
ARET
A4
I1
IN
IRET
ICU
REIAT
WEIAT
DOutIAT
PCOut
32
Fig. 7.10 A block diagram describing an interrupt
7.3
Interrupt Controller
389

clock
INTRx
INTR
INTA
INTRID
REIAT
DOutIAT
SelIAT
PCOut
StallPC
DInRF
SelPC
AddrRF
WERF
SelR31
DOutRF
SelRF
Interrupt ID
latency = 4
latency = 4
latency = 4
ARET written into R31
Writeback regular instructions
ARET
A2
A3
A1
ARET
I1
I2
I3
ARET
A4
A5
WBA1
WBA2
WBA3
ARET
WBA3
WBI1
WBI2
WBI3
WBIN
Valid WB Address
R31
Valid WB Address
R31
New Arbitration
WBRET
A6
Starting Interrupt Address = I1
IF
RF
ALU/D$
WB
Writeback interrupt service subroutine instructions
Cycle
1
Cycle
2
Cycle
3
Cycle
4
Cycle
5
Cycle
6
Cycle
7
Cycle
8
Cycle
9
Cycle
10
Cycle
11
Cycle
12
Cycle
13
Cycle
(N+3)
Cycle
(N+4)
Cycle
(N+5)
Cycle
(N+6)
Cycle
(N+7)
Cycle
(N+8)
Cycle
(N+9)
WBIN-3 WBIN-2 WBIN-1
Cycle
N
Cycle
(N+1)
Cycle
(N+2)
I4
I5
IN
IRET
IDLE
IDLE
INTA
INTRID
INTR
ADDR
LAST
WB
STORE
ARET
FETCH
I1
FETCH
I2
FETCH
I3
INTR
WB
INTR
WB
INTR
WB
INTR
WB
INTR
END
INTR
END
INTR
END
INTR
END
ACCESS
R31
LOAD
ARET
FETCH
ARET
IDLE
IDLE
IDLE
Fig. 7.11 Detailed timing diagram of an interrupt sequence
390
7
System Peripherals

mean time, at the beginning of cycle 3 when the ICU is aware of a pending interrupt by means
of the INTR signal, it immediately stalls the CPU pipeline by stopping the PC from incre-
menting. However, the PC has already incremented to A3 at this point, and there are
uncompleted instructions from the A1 and A2 addresses in the CPU pipeline. We know that
from the onset of PC address generation to the end of the write-back cycle, a normal
instruction takes four clock cycles to complete (latency = 4) according to the simpliﬁed CPU
data-path in Fig. 7.12. Therefore, the PC output stays at the A3 address until the end of cycle
6 when the instructions, Instr1, Instr2 and Instr3, are completely ﬂushed out of the CPU
pipeline and written back to the CPU’s register ﬁle (RF). However, the interaction with the
CPU pipeline adds the RF block and all its corresponding data paths to the existing block
diagram in Fig. 7.10, transforming the interrupt controller into a more detailed architecture in
Fig. 7.13.
P
C
I-Cache
D-Cache
RF
I
R
A
L
U
A1
A2
AO
DO
WB-stage
ALU/D$-stage
RF-stage
IF-stage
SelPC
PCOut
IF-stage
RF-stage
ALU/D$-stage
WB-stage
Cycle 1
Cycle 2
Cycle 3
Cycle 4
data 
at IR
data 
at A1/A2
data 
at DO/AO
data 
at RF
data 
at PC
DInRF
1
0
OPC
Fig. 7.12 A four-stage CPU employed in the interrupt sequence in Fig. 7.7
After the last write-back is completed in cycle 6, the PC is incremented by one, and the
return address, ARET, is stored in a special register, R31, in the RF as shown in cycle 7. This
step assumes that there is no Jump-and-Link (JAL) or Jump-and-Link-Register (JALR)
instruction in the CPU instruction set because the return address will simply be overwritten
by one of these instructions. Before the CPU starts executing the interrupt service routine, it
copies the contents of the entire register ﬁle into a temporary memory identical to the register
ﬁle. This step is called “context switching”, and it is omitted from the timing diagram in
7.3
Interrupt Controller
391

Interrupt
Control Unit
RF
PC
+ 1
INTR0
INTR1
INTR255
Interrupt Interface
INTRID
INTR
INTA
REIAT
WEIAT
Interrupt Address Table
DOutIAT
DInIAT
31
0
8
255
0
32
DOutRF
DInRF
R31
AddrRF
31
0
Intr1
IntrN
Interrupt 
Service 
Routine (ISR)
Instr1
Instruction Memory
SelR31
1
0
SelPC
1
0
Data from
Writeback Stage
SelRF
SelIAT
I
R
P
StallPC
PCOut
Address from
Writeback Stage
SelR31
SelIAT
SelRF
StallPC
SelPC
WERF
31
0
Instr2
Instr3
InstrRET
Instr4
IntrRET
A1
A2
A3
ARET
A4
I1
IN
IRET
C
StallPC
P-port
4-1 MUX configuration
SelRF
SelIAT
I-port
R-port
Program Counter
clock
clock
Fig. 7.13 Interrupt interface data-path producing the timing diagram in Fig. 7.11
392
7
System Peripherals

Fig. 7.11 to maintain simplicity. Only after the contents of all 32 registers in the register ﬁle
are stored, the interrupt controller starts executing the instructions in the interrupt service
subroutine, which starts in cycle 8. In this cycle, the ﬁrst interrupt instruction address, I1, at
the output of the IAT is loaded to the PC. Once loaded to the CPU data-path, it takes four
clock cycles to execute the ﬁrst interrupt instruction due to the CPU’s write-back latency.
The remaining interrupt instructions are similarly fetched from the instruction memory
addresses, I2 to IN, executed, and written back to the RF until the end of cycle (N + 3). In
cycle (N + 4), the register R31 is accessed. In the following cycle, the return address, ARET,
is fetched from R31. This cycle also completes the interrupt service routine and prompts the
ICU to transfer the control over to the CPU to execute the remaining user instructions. In
cycle (N + 6), the ICU lowers the INTA signal to logic 0, and the interrupt controller loads
the value of the ARET to the PC. In response to the INTA, the interrupt interface also lowers
the INTR signal to logic 0 and invalidates the INTRID in cycle (N + 7). New interrupt
arbitration will take place in cycle (N + 8) to service the next interrupt.
In the previous paragraphs, we only explained how the address and data bus values
changed once an interrupt signal is received from the interrupt interface. Now, we are ready
to explain the second part of the timing diagram that includes the control signals to manage
the data-ﬂow. After examining the detailed data-path in Fig. 7.13, the control signals can be
grouped into three categories. The ﬁrst group supports the PC input control and contains the
StallPC, SelIAT and SelRF signals. The StallPC signal simply routes the output of the PC,
PCOut, to its input through the P-port of the 4-1 MUX to stall the PC. The SelIAT signal
routes the output of the IAT, DOutIAT, to the input of the PC through the I-port of the 4-1
MUX to load an interrupt address. The SelRF signal enables the R-port, and connects the
output of the RF, DOutRF, to the input of the PC to load the return address, ARET, once the
interrupt service is over. If none of these control signals are generated, then the PC incre-
ments through the C-port. The second group controls the address and data inputs to the RF
and consists of the SelR31 and SelPC inputs. The SelR31 input selects the register R31 to be
the address for the RF at the AddrRF port. The SelPC input selects the contents of the PC to
be the data for the RF at the DInRF port. The third group controls the read and the write
enable signals, REIAT and WEIAT, for the IAT, respectively. Although writing into the IAT
does not take place during a routine interrupt service, it will be used to reprogram a new set
of ISR addresses in the IAT.
All three groups of controls manage the proper data ﬂow in Fig. 7.13. The StallPC signal
transitions to logic 1 at the beginning of cycle 3 and stays there until cycle 6 to stop the PC
from incrementing so that the CPU completes writing the instructions, Instr1, Instr2 and
Instr3, back to the RF. Because of these write-backs, the write-enable signal for the RF,
WERF, is also kept at logic 1 from cycles 4 to 6. The read-enable signal for the IAT, REIAT,
is kept high in cycle 4 because the ﬁrst interrupt instruction address, I1, needs to be fetched
from the IAT following a valid INTRID. Cycle 7 is a special cycle to load the register R31
with the program return address, ARET. Therefore, the signals, SelR31, SelPC and WERF,
7.3
Interrupt Controller
393

all become logic 1 during this cycle. The SelIAT signal is also kept at logic 1 during cycle 7
in order to load the ﬁrst interrupt address, I1, to the PC in cycle 8. The WERF signal is kept
at logic 1 from cycle 11 to cycle (N + 3) to be able to complete all interrupt-related
write-backs to the RF. The StallPC signal is kept at logic 1 from cycle (N + 1) to cycle
(N + 4) to stall the value of PCOut at IRET. Cycle (N + 5) is dedicated to retrieving the
program return address, ARET, from the RF. Therefore, the SelRF signal is kept at logic 1 in
this cycle to load the PC with the contents of ARET in the following cycle. The WERF
signal transitions to logic 1 in cycle (N + 9) in order to write the result of the instruction,
InstrRET, back to the RF.
Figure 7.14 shows the resultant state diagram for the interrupt controller. Its design is
solely based on the values of the control signals from the timing diagram in Fig. 7.11. The
name of each state in the state machine comes from the labels on top of the timing diagram in
INTA
INTRID
INTR
ADDR
LAST
WB
STORE
ARET
FETCH
I1
FETCH
I2
FETCH
ARET
LOAD
ARET
ACCESS
R31
INTR
END
FETCH
I3
IDLE
INTR = 0
INTA = 0
INTR = 1
INTA = 1
StallPC = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTA = 1
StallPC = 1
WERF = 1
REIAT = 1
INTA = 1
StallPC = 1
WERF = 1
INTA = 1
WERF = 1
INTA = 1
SelIAT = 1
SelR31 = 1
SelPC = 1
WERF = 1
INTA = 1
WERF = 1
StallPC = 1
INTA = 1
StallPC = 1
SelR31 = 1
INTA = 1
SelRF = 1
INTA = 0
INTR = 1
WBI(N-3) < WBIx < WBIN
INTA = 1
INTA = 1
INTA = 1
INTR = 1
INTA = 1
INTR
WB
INTA = 1
WERF = 1
INTR = 1
WBIx < WBI(N-3)
INTR = 1
INTR = 1
WBIx = WBI(N-3)
INTR = 1
WBIx = WBIN
Fig. 7.14 Interrupt controller state diagram
394
7
System Peripherals

Fig. 7.11. The machine starts with the IDLE state where there is no INTR signal. Therefore,
this state generates INTA = 0. When a valid INTR is received, the state machine transitions
to the INTA state and produces two outputs, INTA = 1 and StallPC = 1. This state corre-
sponds to cycle 3 of the timing diagram. As INTR = 1 continues, the machine goes though
the INTRID, INTR ADDR, LAST WB and STORE ARET states, which correspond to
cycles 4, 5, 6 and 7, respectively. These are the preparation states prior to an ISR.
The FETCH I1 state indicates the ﬁrst interrupt instruction fetch, which corresponds to cycle
8. The interrupt controller goes though the FETCH I2 and FETCH I3 states where it fetches
the second and third interrupt instructions. These are indicated in cycles 9 and 10, respec-
tively. A cycle later the machine enters the INTR WB state where it starts writing the results
of interrupt instructions back to the RF. The interrupt controller stays at this state until the
interrupt address reaches its last value, IN. When the last interrupt address is fetched, the
machine transitions to the INTR END state where it performs three additional interrupt
write-backs, and stalls the PC at IRET until the last interrupt write-back, WBIN, completes.
This state continues during cycles (N + 1), (N + 2) and (N + 3) in the timing diagram.
Following the last interrupt write-back, the interrupt controller prepares the system to ﬁnish
the current interrupt service before receiving another interrupt. The closing states are the
ACCESS R31, LOAD ARET and FETCH ARET states, which correspond to cycles
(N + 4), (N + 5) and (N + 6) in the timing diagram, respectively. The interrupt controller
goes back to the IDLE state in cycle (N + 7) where the INTRID becomes no longer valid.
However, a crucial problem arises when implementing this state machine. The interrupt
controller needs to know the end of an ISR. Somehow the number of instructions in the
interrupt service routine must be determined in advance in order to continue the state
transitions in the state machine. The states, INTR WB and INTR END, are the examples of
this problem. The interrupt controller needs to stay in the INTR WB state from the ﬁrst to the
(N – 4)th interrupt write-backs, and similarly in the INTR END state from the (N – 3)th to
the Nth interrupt write-backs during an ISR. Since the number of instructions varies in an
ISR program, this state machine’s implementation becomes impossible for the ICU design,
necessitating a change in the original timing diagram, which will affect the data-path in
Fig. 7.13 and the state diagram in Fig. 7.14.
Figure 7.15 shows a slightly modiﬁed version of the interrupt controller data-path to
circumvent this problem. In this ﬁgure, a decoder is added between the output of the
instruction register, IROut, and the interrupt controller in order to detect the return opcode in
the IntrRET instruction at the last interrupt address, IRET. This, however, creates an
additional input, DetIRET, for the ICU. Therefore, when the return opcode is decoded in
cycle (N + 2) in the new timing diagram in Fig. 7.16, the DetIRET signal becomes logic 1
and prompts the ICU to make preparations to end the current ISR. In this ﬁgure, the StallPC
signal is also lowered to logic 0 between cycles (N + 1) and (N + 4) because not stalling the
PC during this interval will simply generate invalid addresses at the PCOut port, and this is
7.3
Interrupt Controller
395

Interrupt
Control Unit
RF
PC
+ 1
INTR0
INTR1
INTR255
Interrupt Interface
INTRID
INTR
INTA
REIAT
WEIAT
Interrupt Address Table
DOutIAT
DInIAT
31
0
8
255
0
32
DOutRF
DInRF
R31
AddrRF
31
0
Intr1
IntrN
Interrupt 
Service 
Subroutine
Instr1
Instruction Memory
SelR31
1
0
SelPC
1
0
Data from
Writeback Stage
SelRF
SelIAT
I
R
S
StallPC
PCOut
Address from
Writeback Stage
SelR31
SelIAT
SelRF
StallPC
SelPC
WERF
31
0
Instr2
Instr3
InstrRET
Instr4
IntrRET
A1
A2
A3
ARET
A4
I1
IN
IRET
C
IntrRET Decoder
DetIRET
clock
IROut
clock
Instr. Reg
clock
Fig. 7.15 Modiﬁed interrupt interface data-path
396
7
System Peripherals

IDLE
IDLE
INTA
INTRID
INTR
ADDR
LAST
WB
STORE
ARET
FETCH
I1
FETCH
I2
FETCH
I3
INTR
WB
INTR
WB
INTR
WB
INTR
WB
ACCESS
R31
LOAD
ARET
FETCH
ARET
IDLE
IDLE
IDLE
clock
INTRx
INTR
INTA
INTRID
REIAT
DOutIAT
SelIAT
PCOut
StallPC
DInRF
SelPC
AddrRF
WERF
SelR31
DOutRF
SelRF
Interrupt ID
latency = 4
latency = 4
Latency = 4
ARET written into R31
Writeback regular instructions
ARET
A2
A3
A1
ARET
I1
I2
I3
ARET
WBA1
WBA2
WBA3
ARET
WBA3
WBI1
WBI2
WBI3
WBIN
Valid WB Address
R31
Valid WB Address
R31
New Arbitration
WBRET
Starting Interrupt Address = I1
IF
RF
ALU/D$
WB
Writeback interrupt service subroutine instructions
Cycle
1
Cycle
2
Cycle
3
Cycle
4
Cycle
5
Cycle
6
Cycle
7
Cycle
8
Cycle
9
Cycle
10
Cycle
11
Cycle
12
Cycle
13
Cycle
(N+3)
Cycle
(N+4)
Cycle
(N+5)
Cycle
(N+6)
Cycle
(N+7)
Cycle
(N+8)
Cycle
(N+9)
WBIN-3 WBN-2 WBIN-1
Cycle
N
Cycle
(N+1)
Cycle
(N+2)
I4
I5
IN
DetIRET
IRET
Invalid Address
IROut
End of interrupt service subroutine
RETURN Instruction
INTR
WB
INTR
WB
INTR
WB
WBIN
A4
A5
A6
Fig. 7.16 Timing diagram of the modiﬁed interrupt interface in Fig. 7.15
7.3
Interrupt Controller
397

not critical for the operation of the interrupt controller since the program return address,
ARET, becomes a valid address at PCOut in cycle (N + 6).
This modiﬁcation leads to a number of changes in the ICU’s state diagram shown in
Fig. 7.17. After transitioning to the INTR WB state in cycle 11, the state machine stays in
this state until it detects DetIRET = 1. This input forces the ICU to move the WBIN state to
complete the last interrupt write-back. At this point, the machine goes through three more
states, ACCESS R31, LOAD ARET and FETCH ARET, to load the user program return
address back to the PC in order to resume the original program.
INTA
INTRID
INTR
ADDR
LAST
WB
STORE
ARET
FETCH
I1
FETCH
I2
FETCH
ARET
LOAD
ARET
ACCESS
R31
WBIN
FETCH
I3
IDLE
INTR = 0
INTA = 0
INTR = 1
INTA = 1
StallPC = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTR = 1
INTA = 1
StallPC = 1
WERF = 1
REIAT = 1
INTA = 1
StallPC = 1
WERF = 1
INTA = 1
WERF = 1
INTA = 1
SelIAT = 1
SelR31 = 1
SelPC = 1
WERF = 1
INTA = 1
SelR31 = 1
INTA = 1
SelRF = 1
INTA = 0
INTA = 1
INTA = 1
INTA = 1
INTA = 1
INTR
WB
INTR = 1
DetIRET = 0
INTR = 1
INTR = 1
INTR = 1
DetIRET = 1
INTA = 1
WERF = 1
INTR = 1
INTA = 1
WERF = 1
Fig. 7.17 Modiﬁed interrupt controller state diagram
398
7
System Peripherals

7.4
Serial Transmitter and Receiver Interface
There are times when the CPU needs to use its serial I2C or SPI interface in order to
communicate with an I/O device. The serial interface consists of a transmitter to send serial
data to an I/O device, and a receiver to receive serial data from the same device on a one-bit
bus. The following section describes the basic structure of a transceiver composed of a
transmitter and a receiver to handle one-bit serial data.
Transmitter
Figure 7.18 shows the data-path of a transmitter where an incoming 32-bit data from the
CPU is received at the TXIn[31:0] port, and stored in one of the two buffers before being
serially sent out from the TXOut port. Each buffer is essentially a shift register. Once a 32-bit
data packet is loaded into a shift register, the bits start shifting from the least signiﬁcant bit
position to the most signiﬁcant bit position until all 32 bits are sent out.
TXBuf0
TXBuf1
ShiftTXBuf0
ShiftTXBuf1
LoadTXBuf0
LoadTXBuf1
32
TXOut
TXIn[31:0]
1
0
PassTXBuf
CSTX
TX
Controller
PassTXBuf
LoadTXBuf1
ShiftTXBuf1
ShiftTXBuf0
LoadTXBuf0
ValidTXData
LoadTXBuf1
LoadTXBuf0
TXBufEmpty
TX Counter
TXCount
DecTXCount
LoadTXCount
31
Fig. 7.18 Transmitter data-path
7.4
Serial Transmitter and Receiver Interface
399

This design uses a dual buffer scheme to overcome moderate waiting periods to access
system’s main memory. If the waiting period takes too long, the transmitter architecture may
require more than two buffers to sustain continuous stream of serial data from TXOut.
A single buffer may also be sufﬁcient for the transmitter provided that there should not be
any waiting period to access the main memory. Once the main memory is accessed, storing a
32-bit data in one of the transmitter buffers takes only a cycle. Streaming all 32 bits from a
particular buffer, on the other hand, takes 32 consecutive clock cycles. The clock used to
send serial data may also be a slower clock depending on the design constraints. Therefore,
the transmitter uses all 32 clock periods to request, wait and receive data to its secondary
buffer while it streams bits out of the ﬁrst buffer. When the ﬁrst buffer becomes empty, the
transmitter immediately starts streaming data out of its secondary buffer while the ﬁrst buffer
is being ﬁlled.
PassTxBuf input in Fig. 7.18 is a control signal for the 2-1 MUX that determines when to
switch buffer outputs. LoadTxBuf0 and LoadTXBuf1 inputs load data from TXIn[31:0] to
the ﬁrst and the second buffers, respectively. ShiftTXBuf0 and ShiftTXBuf1 inputs control
the beginning and the end of the serial data shift from buffer 0 and buffer1, respectively.
The CSTX is a Chip-Select input port for the transmitter, and it stays at logic 1 as long as the
system uses the transmitter.
The timing diagram in Fig. 7.19 shows how data is stored and streamed out of the data
buffers. It is constructed while the transmitter data-path in Fig. 7.18 is being developed.
Once again, the top part of this diagram shows the bus-level data signals that describe the
data-ﬂow while the bottom part contains the control signals that govern this data-ﬂow.
The transmitter wakes up when it receives an active-high CSTX signal from the CPU in
cycle 1. In cycles 2 and 3, the 32-bit data packets, Buf0 and Buf1, ﬁll the ﬁrst and second
transmitter buffers, TXBuf0 and TXBuf1, respectively. Once the ﬁrst buffer is full in cycle 2,
single bits start coming out of the least signiﬁcant bit position of the buffer (the shifting
mechanism in the buffer can also be conﬁgured such that single bits start emerging from the
most signiﬁcant bit position instead) in cycle 3. The ﬁrst bit that comes out of TXBuf0 in
cycle 3 is Bit0 which is the least signiﬁcant bit of the data packet. This is followed by Bit1
through Bit31 between cycles 4 to 34, respectively. When the ﬁrst buffer becomes empty, the
transmitter immediately switches to its second buffer and starts streaming bits from TXBuf1.
In the mean time, the transmitter ﬁlls TXBuf0 with a new 32-bit of data in cycle 35 as long
as there is no bus trafﬁc. Emptying the second buffer takes until cycle 66 when Bit31 is sent
out from the TXOut terminal. When TXBuf1 is empty, the transmitter starts streaming out
data from TXBuf0 in cycle 67 while ﬁlling TXBuf1. The process of ﬁlling one buffer while
streaming bits out of the second continues as long as the data stored in the main memory is
fully exhausted. Figure 7.19 shows all 32-bit data packets from the main memory imme-
diately available when the transmitter switches from its empty buffer to its full buffer, and
ignores any delay associated with accessing the main memory. In reality, when the trans-
mitter starts streaming data out of the full buffer, it immediately generates an interrupt for its
400
7
System Peripherals

PassTXBuf
TXIn[31:0]
ShiftTXBuf0
ShiftTXBuf1
CSTX
LoadTXBuf1
TXOut
clock
Bit0
Bit1
Bit2
Bit0
Bit31
Bit1
Bit2
Buf0
Buf0
Bit31
Bit1
Bit2
Bit31
Bit0
Bit1
Buf1
Bit0
Buf0
LoadTXBuf0
Bit2
Buf1
ValidTXData
Cycle
1
Cycle
2
Cycle
3
Cycle
4
Cycle
5
Cycle
34
Cycle
35
Cycle
36
Cycle
37
Cycle
66
Cycle
67
Cycle
68
Cycle
69
Cycle
98
Cycle
99
Cycle
100
Cycle
101
TXCount
31
30
29
31
0
30
29
0
30
29
0
31
30
31
29
DecTXCount
LoadTXCount
IDLE
PRELOAD
BUF0
LOAD
BUF1
EMPTY
BUF0
EMPTY
Last Bit
BUF0
LOAD
BUF0
EMPTY
BUF1
EMPTY
Last Bit
BUF1
LOAD
BUF1
Fig. 7.19 Transmitter timing diagram
7.4
Serial Transmitter and Receiver Interface
401

empty buffer to fetch data from the main memory. The waiting period is 31 clock cycles. In
the 32nd clock cycle, the empty buffer must be full. Otherwise, the transmitter stalls, and no
new data can be transmitted.
The control signals that govern the data-ﬂow in Fig. 7.18 constitute the second part of the
timing diagram. Once the active-high CSTX signal is received, the LoadTXBuf0 signal
transitions to logic 1 to load the ﬁrst 32-bit data packet, Buf0, to TXBuf0 in cycle 2. In cycle
3, the second 32-bit data packet, Buf1, is loaded to TXBuf1, which requires the LoadTX-
Buf1 signal to be at logic 1. From cycle 3 until cycle 33, TXBuf0 works as a shift register to
stream bits 0 to 31. Therefore, the ShiftTXBuf0 signal stays at logic 1 during this period. In
cycle 34, the last bit is shifted out of TXBuf0, and therefore, all data-ﬂow controls for this
buffer transition to logic 0. In cycle 35, the LoadTXBuf0 signal transitions to logic 1 to ﬁll
the empty buffer, TXBuf0. The ShiftTXBuf1 signal also transitions to logic 1 in the same
cycle to shift bits from 0 to 31 until cycle 66. Cycle 35 is also the time to switch the buffer
outputs. Therefore, the PassTXBuf signal becomes logic 1 in this cycle until cycle 67 when
all the data in TXBuf1 is streamed out. Cycle 66 is the cycle to deliver the last bit out of
TXBuf1. Cycles 67 through 98 are exact replicas of cycles 3 through 34 where TXBuf1 is
ﬁlled while bits are shifted out of TXBuf0. The ValidTXData signal validates bits as they are
streamed out of the transmitter. Therefore, this signal stays at logic 1 from cycle 3 until the
last transmitter bit.
Figure 7.20 shows the state diagram of the controller unit that loads and shifts data in
each buffer, to switch buffer outputs, and to validate bits out of the transmitter. The state
names in this ﬁgure follow the names depicted at the top of the timing diagram in Fig. 7.19.
When there is no activity in CSTX signal, the state machine stays in the IDLE state. When
CSTX = 1, the controller transitions to the PRELOAD BUF0 state where it produces
LoadTXBuf0 = 1 to load TXBuf0, and LoadTXCount = 1 to load the TXcounter in
Fig. 7.18 with the value of 31. This state is associated with cycle 2 in the timing diagram.
Note that the TXCounter is a ﬁve-bit counter which is used to detect the end of the serial data
stream, and it is essential for the controller to be able to make a transition to the next state.
As long as CSTX = 1, the state machine transitions to the LOAD BUF1 state where it
produces LoadTXBuf1 = ShiftTXBuf0 = ValidTXData = 1. This state corresponds to cycle
3 in the timing diagram. This state is also the beginning of the count-down stage where the
TXCounter output starts decrementing from 31 towards 0 by DecTXCount = 1. Next, the
state machine goes to the EMPTY BUF0 state, and stays there as long as the output of the
TXCounter, TXCount, is greater than one. This state corresponds to cycles 4 through 33 in
the timing diagram. When TXCount = 1, the controller goes to the EMPTY Last Bit BUF0
state where Bit31 is shifted out of TXBuf0. This state is equivalent to cycle 34 in the timing
diagram when the TXCounter is reloaded with the value of 31 to start another count-down.
As long as CSTX = 1, the state machine ﬁrst transitions to the LOAD BUF0 state in cycle
35, and then to the EMPTY BUF1 state as the TXCounter decrements towards 1 from cycles
36 to 65. When TXCount = 1, the state machine transitions to the EMPTY Last Bit BUF1
402
7
System Peripherals

state in cycle 66 when the last bit of TXBuf1 is shifted out. From cycle 67 onwards, the state
machine goes back to the LOAD BUF1 state, and traces through the previous ﬁve states
since the control outputs generated in each state are identical to the ones in the timing
diagram in each clock cycle. The state diagram in Fig. 7.20 does not show the transitions
from an arbitrary state to the IDLE state when CSTX = 0 to improve readability. The case
when the transmitter exhausts all of its valid data from both of its buffers and forced to stall
is not shown in Fig. 7.20 either. If heavy bus trafﬁc is expected, the reader should employ an
additional STALL state in case new data is not yet loaded to TXBuf0 or TXBuf1 before the
state machine transitions to the LOAD BUF0 or LOAD BUF1 states, respectively.
Receiver
Figure 7.21 shows the data-path of a receiver where incoming data bits are serially received
by the RX buffer, RXBuf, at the RXIn port before being packed as 32-bit data packets and
CSTX = 0
LoadTXBuf1 = 1
ShiftTXBuf0 = 1
ValidTXData = 1
DecTXCount = 1
LoadTXBuf0 = 1
LoadTXCount = 1
IDLE
PRELOAD
BUF0
LOAD
BUF1
EMPTY
BUF0
EMPTY
Last Bit
BUF0
LOAD
BUF0
EMPTY
BUF1
EMPTY
Last Bit
BUF1
CSTX = 1
CSTX = 1
CSTX = 1
CSTX = 1
TXCount = 1
CSTX = 1
CSTX = 1
CSTX = 1
ShiftTXBuf0 = 1
ValidTXData = 1
DecTXCount = 1
ValidTXData = 1
LoadTXCount = 1
LoadTXBuf0 = 1
ShiftTXBuf1 = 1
PassTXBuf = 1
ValidTXData = 1
DecTXCount = 1
ShiftTXBuf1 = 1
PassTXBuf = 1
ValidTXData = 1
DecTXCount = 1
PassTXBuf = 1
ValidTXData = 1
LoadTXCount = 1
CSTX = 1
TXCount > 1
CSTX = 1
TXCount > 1
CSTX = 1
TXCount = 1
Fig. 7.20 Transmitter controller state diagram
7.4
Serial Transmitter and Receiver Interface
403

sent to the CPU from the RXOut[31:0] port. This architecture can also be accomplished with
multiple buffers in case the receive clock frequency becomes much higher than the processor
clock frequency.
Figure 7.22 summarizes the operation of the receiver in a timing diagram. Once the
receiver is activated by CSRX = 1 in cycle 1, any incoming data bit is ignored until the
ValidRXDIn signal transitions to logic 1. In other words, this external signal validates the
data bit at the RXIn port, and indicates when to start latching data bits into the RX buffer. As
a result, Bit0 is stored in RXBuf in cycle 2 and Bit31 in cycle 33. In cycle 34, a new Bit0 is
fetched for the receive buffer. This cycle is also the time period to pack all 32 bits, and send
them out of the RXOut[31:0] port. The 32-bit data is accompanied by the ValidRXDOut
signal for validation. In order to determine which clock cycle the ValidRXDOut signal
transitions to logic 1, a ﬁve-bit counter is used. This counter starts decrementing as soon as
the DecRXCount or the LatchRXData signal goes to logic 1. When the counter reaches 0,
the RX Controller produces ValidRXDOut = 1 in the following cycle to validate the 32-bit
word at the RXOut[31:0] port. From cycles 34 to 67, the receiver keeps latching new valid
bits into RXBuf. As an example, there may be a period where the serial bit stream may not
be valid (ValidRXDIn = 0) such as in cycles 38 and 39. During this period, both the latching
action at the RXIn port and the count-down mechanism at the RX Counter should stop
immediately by LatchRXData = 0 and DecRXCount = 0, respectively. The normal receiver
operation resumes as soon as the ValidRXDIn signal transitions to logic 1 in cycle 40.
RXOut[31:0]
RXIn
LatchRXData
RX
Controller
ValidRXDOut
RX Counter
RXCount
DecRXCount
RXBuf
1
32
ValidRXDIn
CSRX
Fig. 7.21 Receiver data-path
404
7
System Peripherals

RXIn
RXOut[31:0]
clock
W
Bit0
Bit30
Bit1
Bit0 
latched
Bit31
latched
Bit0
Bit3
Bit1
Bit4
Bit30
Bit5
W
Bit2
Bit31
NOT VALID
Bit31
CSRX
ValidRXDIn
Bit0 
latched
Bit31
latched
Cycle 
1
Cycle 
2
Cycle 
3
Cycle 
4
Cycle 
32
Cycle 
33
Cycle 
34
Cycle 
35
Cycle 
36
Cycle 
37
Cycle 
38
Cycle 
39
Cycle 
40
Cycle 
41
Cycle 
42
Cycle 
66
Cycle 
67
Cycle 
68
31
1
30
31
28
30
1
26
29
0
27
0
31
DecRXCount
RXCount
ValidRXDOut
LatchRXData
COUNT DOWN
COUNT DOWN
VALID 
DOUT
VALID 
DOUT
IDLE
Fig. 7.22 Receiver timing diagram
7.4
Serial Transmitter and Receiver Interface
405

The RX controller is a simple state machine with three states as shown in Fig. 7.23.
The IDLE state is the state when CSRX = 0 or ValidRXDIn = 0. Even when the CSRX
signal goes to logic 1, the controller stays in this state as long as ValidRXDIn = 0. This
translates to cycles 1 and 2 in Fig. 7.22. When the CSRX and ValidRXDIn signals both go
to logic 1, the controller moves to the COUNT DOWN state to ﬁll RXBuf. The controller
stays in this state until the RXCount signal reaches 0. This state covers the cycles from 3 to
33 in the timing diagram. In the next cycle, the state machine goes to the VALID DOUT
state where it stays for only one clock cycle and produces ValidRXDOut = 1 for the 32-bit
data at the RXOut[31:0] port. Following the VALID DOUT state, the controller goes back to
the COUNT DOWN state where it starts ﬁlling the receive buffer again. As long as valid bits
arrive at the RXIn port, the state machine rotates between the COUNT DOWN and the
VALID DOUT states in Fig. 7.23. When CSRX = 0 or ValidRXDIn = 0, the state machine
transitions either from the COUNT DOWN state or from the VALID DOUT state to the
IDLE state. These transitions are omitted in Fig. 7.23 to maintain simplicity.
7.5
Timers
Every digital system contains programmable timers to handle a multitude of tasks. If an
external event needs to be monitored, it calls for a timer. Periodic internal system tasks are
also managed by timers. Timers can also be used to generate square waveforms or pulses
IDLE
COUNT
DOWN
VALID
DOUT
CSRX = 0
or
ValidRXDIn = 0
CSRX = 1
ValidRXDIn = 1
CSRX = 1
ValidRXDIn = 1
RXCount = 0
CSRX = 1
ValidRXDIn = 1
RXCount ≠0
ValidRXDout = 1
Fig. 7.23 Receiver controller state diagram
406
7
System Peripherals

with adjustable pulse widths such as Pulse Width Modulation (PWM) signals to control
output devices or perform periodic tasks.
A basic system timer is shown in Fig. 7.24 [1]. This timer essentially consists of a counter, a
compare unit and two registers. The ﬁrst register stores the entire timer period after which the
counter receives an automatic reset, and the other divides the clock frequency of the counter.
The period and the divide by N registers are fully programmable. The compare unit is simply a
subtractor which subtracts the counter output from the period value. As the counter starts
incrementing from zero and ultimately reaches the value stored in the period register, the
output of the subtactor and its sign bit become all zero. These bits are ultimately decoded by the
compare unit to produce logic 1 at the timer output and reset the counter as shown in this ﬁgure.
Divide by N
COMPARE
Reset
Output
Fclock
Cutoff period
Counter period
time
time
Output (t)
clock division, N
PERIOD
COUNTER
Fclock
N
Counter (t)
Program Data
Program Data
Fig. 7.24 Simpliﬁed timer block diagram
7.5
Timers
407

The basic philosophy used in a timer block diagram can be modiﬁed into different forms.
However, all modiﬁcations still end up with a counter, a register set and a comparator for the
intended functionality. The comparison can be achieved by a digital block that may produce
one or multiple timer outputs, or by a subtractor/decoder scheme as in Fig. 7.24.
The following section presents many different forms of timers, each of which can still be
modiﬁed and converted into various other forms that can produce additional features and
functionality. The basic timers in this section are conﬁgured to produce a one-time pulse
(one-shot timer), a periodic waveform with adjustable duty cycle (rate generator), a square
waveform with fully programmable period (square wave generator) and a step function with
adjustable delay (interrupt generator). There are subtle differences and incremental
enhancements from one timer circuit to another, but in the end each timer uses a counter, a
register and a comparator as pointed out before.
One-Shot Timer
The one-shot timer, as its name suggests, generates a single, non-repetitive pulse whose
pulse width is programmed by the user. Figure 7.25 shows the micro-architecture of a typical
one-shot timer.
Before the operation starts, the pulse width for the one-shot timer is stored in the OneShot
register via a program bus. Once programmed, the data in this register is routed through the
L-port of the 3-1 MUX by LoadOneShot = 1. This provides an initial value for the
down-counter. As a numerical example, assume that the OneShot register is programmed
with a value of four, which produces OneShotOut = 4 during cycle 1 in the timing diagram in
Fig. 7.26. In cycle 2, the RData[31:0] node becomes 4. Since this value is different from 0,
the decoder placed at the RData[31:0] node (a 32-input AND gate with an inverter) produces
logic 1 at the OneShot output. This, in turn, activates the D-port of the 3-1 MUX and routes
the decremented RData value, (RData – 1) = 3, to the input of the down-counter. In cycle 3,
the RData[31:0] node becomes 3, and the OneShot output stays at logic 1, keeping the
D-port of the 3-1 MUX active. The decremented RData value, (RData – 1) = 2, is fed back
to the timer input once again. The D-port of the 3-1 MUX stays active until cycle 6 when the
RData[31:0] node becomes zero. From this point forward, the Idle-port of the 3-1 MUX
becomes active, and the timer output becomes zero. The timer stays in this state until it is
reprogrammed with a new value.
Rate Generator
The rate generator is another type of timer which periodically generates single pulses sep-
arated by a programmable time duration. Once a desired rate is stored in the RateGen register
via program bus, it is routed through the L-port of the 2-1 MUX to the input of the timer by
LoadRateGen = 1 as shown in Fig. 7.27. This step is shown in cycle 1 of the timing diagram
408
7
System Peripherals

clock
4
4
3
2
1
LoadOneShot
OneShotOut
RData[31:0]
OneShot
Cycle
1
Cycle
2
Cycle
3
Cycle
4
Cycle
5
Cycle
6
Cycle
7
Cycle
8
Cycle
9
0
0
Fig. 7.26 Timing diagram of the One-Shot timer (OneShot register in Fig. 7.25 is
programmed with a value of 4 as an example)
- 1
32
Idle
L
D
clock
D
Q
LoadOneShot
OneShot
32
32
RData[31:0]
Program Data
OneShot Reg
OneShotOut
selects D-port
Fig. 7.25 Block diagram of the One-Shot timer
7.5
Timers
409

in Fig. 7.28 with RateGenOut = 4 as an example. In cycle 2, the RData[31:0] node becomes
four, and the RateGen output becomes zero. Because neither the RateGen port nor the
LoadRateGen input is at logic 1, the D-port of the 2-1 MUX becomes automatically active to
allow the decremented RData, (RData – 1) = 3, to become the input of the down-counter. In
cycle 3, RData[31:0] becomes equal to three, which keeps the D-port still active because
RateGen = 0. The decremented RData, (RData – 1) = 2, is routed once again to the input of
the timer. This path stays active until RData[31:0] = 1. At this point, RateGen output
becomes equal to one, and selects the L-port of the 2-1 MUX. The value in the RateGen
register is loaded to the input of the down-counter. This is shown in cycle 5 of the timing
diagram. In cycle 6, RData[31:0] becomes four, and the RateGen output becomes zero. The
cycles 7 through 9 are the exact replicas of the cycles 3 through 5. The RData node keeps
decrementing until it becomes equal to one, at which point the RateGen output also becomes
one. Therefore, periodic single pulses are generated once in every four consecutive cycles at
the RateGen output once the RateGen register is programmed with a value of four.
- 1
32
L
D
clock
D
Q
LoadRateGen
RateGen
32
32
RData[31:0]
Program Data
RateGen Reg
RateGenOut
selects L-port
Fig. 7.27 Block diagram of the Rate Generator
410
7
System Peripherals

Square Wave Generator
Square waveforms can also be generated by the timer as shown in Fig. 7.29. The pulse
duration of the square wave is initially stored in the SqWave register through a program bus.
Once the programming is ﬁnished, LoadSqWave = 1 loads the value to the Sqwave register
through the L-port of the 2-1 MUX to the input of the down counter. This is shown in
cycle 1 of the timing diagram in Fig. 7.30 with SqWaveOut = 3 as a numerical example. In
cycle 2, RData[31:0] becomes three and RateOut becomes zero since the 32-input AND gate
can only produce logic 1 when RData[31:0] = 1. The decremented RData value, (RData – 1)
= 2, is routed through the active D-port of the 2-1 MUX to the input of the down-counter. In
cycle 3, the RData[31:0] node becomes two, but the RateOut node still stays at zero. The
decremented RData value, (RData – 1) = 1, is routed to the input of the down-counter once
again. When RData[31:0] becomes equal to one in cycle 4, the 32-input AND gate produces
RateOut = 1, and activates the L-port of the 2-1 MUX. As a result, the down-counter is
reloaded with the value in the SqWave register. From this point forward, the circuit repeats
the same pattern, producing a pulse in every three cycles at the RateOut node. Although the
rate generator and the square wave circuits look identical, the square wave generator con-
tains an additional state machine whose clock is controlled by the RateOut node. Therefore,
at every positive edge of the RateOut signal, the value at the SqWave port alternates. If the
SqWave output is initially assumed to produce logic 0 between cycles 1 and 3, the positive
edge of the RateOut signal in cycle 4 switches the value of the SqWave output from logic 0
to logic 1. Similarly, the RateOut pulse in cycle 7 changes the value of the SqWave output
clock
4
4
3
2
1
4
3
2
1
4
LoadRateGen
RateGenOut
RData[31:0]
RateGen
Cycle
1
Cycle
2
Cycle
3
Cycle
4
Cycle
5
Cycle
6
Cycle
7
Cycle
8
Cycle
9
Cycle
10
Fig. 7.28 Timing diagram of the Rate Generator (RateGen register in Fig. 7.27 is
programmed with a value of 4 as an example)
7.5
Timers
411

SqWave
D
Q
RateOut
- 1
32
L
D
clock
D
Q
LoadSqWave
32
32
RData[31:0]
Program Data
SqWave Reg
SqWaveOut
selects L-port
Fig. 7.29 Block diagram of the Square Wave Generator
clock
3
3
2
1
3
2
1
3
2
1
3
2
1
3
LoadSqWave
SqWaveOut
RData[31:0]
RateOut
SqWave
Cycle
1
Cycle
2
Cycle
3
Cycle
4
Cycle
5
Cycle
6
Cycle
7
Cycle
8
Cycle
9
Cycle
10
Cycle
11
Cycle
12
Cycle
13
Cycle
14
Fig. 7.30 Timing diagram of the Square Wave Generator (SqWave register in Fig. 7.29 is
programmed with a value of 3 as an example)
412
7
System Peripherals

back to logic 0. Therefore, the circuit in Fig. 7.29 creates a square waveform whose fre-
quency is fully programmable by the SqWave register.
Interrupt Generator
One of the most useful timer functions is to have a timer generate a predetermined interrupt
signal for the system. If an external event needs to be observed at a speciﬁc time or if
periodic sampling needs to be employed for an event, the system must have the means to
generate an interrupt. It achieves this by using the circuit in Fig. 7.31. This circuit is
composed of a basic down-counter whose output is conﬁgured to make a transition from
logic 0 to logic 1 when the count-down reaches zero.
As with the other timers, the count-down period is programmed in the GenInt register using
a program bus as shown in Fig. 7.31. Once programming is ﬁnished, the L-port of the 3-1
- 1
Program Data
32
Idle
L
D
clock
D
Q
LoadGenInt
selects D-port
32
32
32
S
R
Idle
1
0
clock
D
Q
Reset
GenInt
RData[31:0]
GenInt Reg
GenIntOut
Set
Decrement
Fig. 7.31 Block diagram of the Interrupt Generator
7.5
Timers
413

MUX is activated by LoadGenInt = 1 to allow the value in the GenInt register to be loaded to
the down-counter. As a numerical example, assume that the GenInt register is programmed
with a value of four, which produces GenIntOut = 4 during cycle 1 in the timing diagram in
Fig. 7.32. In cycle 2, the contents of the down-counter input are transferred to the RData[31:0]
node. Therefore, RData[31:0] = 4 produces logic 1 at the Decrement node, which activates the
D-port of the 3-1 MUX, and allows the decremented value of RData, (RData – 1) = 3, to be
loaded to the input of the down-counter. In cycle 3, RData[31:0] = 3, but the Decrement node
stays at logic 1, keeping the D-port active for the rest of the count-down process. When the
RData[31:0] node ﬁnally reaches one in cycle 5, the Set node in Fig. 7.31 transitions to logic 1,
and turns on the S-port of the second 3-1 MUX. In cycle 6, the GenInt output transitions from
logic 0 to logic 1 after four cycles of count-down. Because the LoadGenInt input and the
Decrement node are both at logic 0, the Idle port of the 3-1 MUX automatically becomes
active. As a result, RData[31:0] = 0 keeps circulating back to the timer input until another
value is loaded to the GenInt register. The GenInt output needs to be reset by the active-high
Reset signal in Fig. 7.31 in order to generate another interrupt signal.
7.6
Display Adaptor
The display is one of the most crucial peripherals in a system because it establishes a link
between the user and the system. The format in all modern LCD or LED displays is composed
of an active image area surrounded by vertical and horizontal blanking regions [2]. The size of
the blanking regions is adjusted according to the response time of a particular display. Slower
displays require larger vertical and horizontal blanking regions to sync with the active image
clock
4
4
3
2
1
LoadGenInt
GenIntOut
RData[31:0]
GenInt
Cycle
1
Cycle
2
Cycle
3
Cycle
4
Cycle
5
Cycle
6
Cycle
7
Cycle
8
Cycle
9
0
0
Fig. 7.32 Timing diagram of the Interrupt Generator (GenInt register in Fig. 7.31 is
programmed with a value of 4 as an example)
414
7
System Peripherals

which has a frame rate between 30 and 60 frames per second. Pixels of an active image are
fetched from the system memory and displayed on a non-interlaced screen following the
vertical and the horizontal blanking sections as shown in Fig. 7.33.
Vertical and horizontal blanking areas are made out of black pixels. On the other hand,
each pixel in the active image is composed of eight-bit wide Red (R), Green (G) and Blue
(B) components. The basic operation consists of fetching a 24-bit pixel from the system
memory and placing it in the active image area one at a time. Usually each display has a
frame buffer to store pixels from the system memory. When the data in the frame buffer is
exhausted, the display controller requests another block of data to be transferred from the
system memory. As the system complexity increases, bus trafﬁc between the main memory
and the CPU (and the system peripherals) increases proportionally. As a result, the display
unit may have to wait before the next block of data arrives at its buffer. However, this is not
an acceptable solution since this situation also creates choppy images for the user. Therefore,
dual, quadruple or even higher frame buffer techniques are used to maintain continuous
stream of images to be displayed on the monitor without any interruption. A dual frame
buffer implementation is shown in Fig. 7.34 where image data is displayed from one frame
buffer while the other buffer is being ﬁlled.
Prior to image processing, the Horizontal Blank register, Vertical Blank register, Active
Image Pixel register and Active Image Line register are programmed using a separate
program bus as shown in Fig. 7.34. The program bus can be a serial bus because the
processing speed is not critical when the system programs the control, address and data
registers prior to normal operation. The reader should refer to the design examples and
review questions in Chapter 5 to devise a serial interface to program these registers. The data
stored in these four registers deﬁne the normal operational parameters of the display unit.
Vertical Blanking
Horizontal Blanking
Active Image
Line 0
Line 1023
Pixel 0
Pixel 1023
Fig. 7.33 Non-interlaced display format with an active image of 1024 pixels by 1024 lines
7.6
Display Adaptor
415

Buf0
0x00
8
8
SelR0
8
8
8
Buf1
Program Data
8
Vertical Blanking
Horizontal Blanking
1 2
N
0
Line Counter
Pixel Counter
10
10
23
23
0
0
RE0
WE0
RE1
WE1
Addr0
Addr1
20
20
IncPx
IncLine
ResetPx
ResetLine
Display Controller
RE1
WE0
RE0
SelG0
SelR0
WE1
SelB0
PxOut
LineOut
Active Image
SelBuf0
SelBlank
2
1
0
B0
B1
BK
Vertical Blank Reg
VBOut
Horizontal Blank Reg
HBOut
10
10
SelG0
SelB0
8
SelR1
8
8
8
SelG1
SelB1
SelBuf1
Act Image Line Reg
AILOut
Act Image Pixel Reg
AIPOut
10
10
SelG1
SelR1
SelB1
SelBuf0
SelBlank
SelBuf1
IncPx
ResetPx
IncLine
ResetLine
2
1
0
AILOut
AIPOut
PxOut
LineOut
VBOut
HBOut
10
10
10
10
10
10
FrameIn
Addr0 Counter
Addr0
20
IncAddr0
ResetAddr0
Addr1 Counter
Addr1
20
IncAddr0
ResetAddr0
IncAddr1
ResetAddr1
IncAddr1
ResetAddr1
CSDisplay
Buf0Empty
Buf1Empty
32
WData[31:0]
SyncVB
SyncHB
3-1 Frame MUX
Fig. 7.34 The data-path of the display unit
The image data, on the other hand, is continuously fed to the display buffers, Buf0 and Buf1,
by a 32-bit wide system bus, WData[31:0], as shown in Fig. 7.34. Even though the bus
width is 32 bits, only the lower 24 bits are used in this architecture to transfer pixels to each
buffer. The display controller ﬁrst places the incoming pixels from the system bus to both
Buf0 and Buf1, and then transfers pixels from one of these buffers to the image frame. The
controller also generates two timing attributes, SycnHB and SyncVB, to indicate the start of
416
7
System Peripherals

the horizontal blanking and the start of the vertical blanking sections of the frame, respec-
tively. This is done in order to synchronize the display adaptor with the monitor.
To illustrate the operation of the display unit, a ﬁve pixel wide, nine line tall active image
(the white area in Fig. 7.35) is considered as an example. This image is surrounded by two
lines of vertical blanking and three pixels of horizontal blanking (shaded area) in the same
ﬁgure. The numbers in each box represent a pixel component whether it belongs to the active
image or the blanking sections. Therefore, the component numbers, 0, 1 and 2, constitute the
ﬁrst blank pixel in the vertical blanking section whereas the numbers, 57, 58 and 59,
correspond to the R, G and B components of the ﬁrst pixel in the active image area. The
blank pixels have no values and equal to 0x00 as shown in Fig. 7.34. The active image
pixels, however, are fetched from one of the image buffers in Fig. 7.34 and placed in the
active frame in ascending order. For example, the component 57 is fetched ﬁrst and placed at
the upper left corner of the image frame, and the component 263 is fetched last and placed at
the lower right corner.
The display unit is activated by CSDisplay = 1 as shown in cycle 1 of the timing diagram
in Fig. 7.36. This ﬁgure shows data-path signals in the upper rows and control signals in the
lower rows. Once active, the ﬁrst component of the blanking pixel 0, 0x00, arrives at the
frame in cycle 2. Within the same cycle, the SycnVB signal becomes logic 1, indicating the
start of the vertical blanking for the frame. In cycles 3 and 4, the other two components of
the blanking pixel 0 arrive at the frame. The ﬁrst line of the vertical blanking completes in
0
1
2
3
4
5
6
7
8
PIXEL 0
PIXEL 1
PIXEL 2
9
10
11
12
13
14
15
16
17
PIXEL 3
PIXEL 4
PIXEL 5
18
19
20
21
22
23
PIXEL 6
PIXEL 7
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
80
81
95
96
119
143
167
191
215
239
263
Vertical Blank
2 LINES
Horizontal Blank
3 PIXELS
Active Image
9 LINES
Active Image
5 PIXELS
105
129
153
177
201
225
249
120
144
168
192
216
240
104
128
152
176
200
224
248
Fig. 7.35 An example of an image frame composed of active image and blanking
components
7.6
Display Adaptor
417

1
2
3
4
5
6
7
20
21
22
23
24
25
26
27
28
29
30
31
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
00
00
00
0
00
00
00
1
00
00
00
6
00
00
00
7
00
00
00
0
00
00
00
1
00
00
00
6
00
00
00
7
00
00
00
0
00
00
00
1
00
00
00
2
R
G
B
0
R
0
1
0
clock
FrameIn
PxOut
LineOut
CSDisplay
SelR0
SelG0
SelB0
SelBuf0
SelBuf1
SelBlank
RE0
RE1
Addr0
IncAddr0
ResetAddr0
IncPx
ResetPx
IncLine
ResetLine
SelR1
SelG1
SelB1
Addr1
IncAddr1
ResetAddr1
1
1
VERTICAL BLANK
HORIZONTAL BLANK
ACTIVE IMAGE
0
SyncVB
SyncHB
0
Fig. 7.36 Timing diagram for the data-path in Fig. 7.34
418
7
System Peripherals

cycle 25. The second blanking line follows the same pattern as the ﬁrst one: the ﬁrst
component of the blanking pixel 0 arrives at the frame in cycle 26, and the last component of
the blanking pixel 7 arrives in cycle 49. Cycle 49 is also the cycle that resets the line counter
by ResetLine = 1 because the next line starts the active image. In cycle 50, SycnHB
becomes logic 1, signifying the start of horizontal blanking. From cycles 50 to 58, the ﬁrst
line of horizontal blanking is formed prior to the active image. Cycle 58 also deﬁnes the
border between the horizontal blanking and the active image. In this cycle, the read enable
signal for Buf0, RE0, becomes logic 1 in order to read the ﬁrst image pixel from this buffer.
Blanking pixels are supplied to the frame from the BK-port of the 3-1 MUX as shown in
Fig. 7.34, and delivered to the frame through FrameIn input.
The timing diagram in Fig. 7.37 is the continuation of Fig. 7.36 and focuses on the active
image pixel delivery. The R-component of the ﬁrst image pixel comes into the image frame
in cycle 59 followed by the G and the B components in cycles 60 and 61, respectively. Since
the image data comes from the ﬁrst display buffer, Buf0, the port assignment in the 3-1
MUX must be changed from port BK to port B0 by SelBuf0 = 1 from cycle 59 onwards.
Therefore, after the ﬁrst image pixel is delivered to the frame, the address pointer for buffer
0, Addr0, is incremented by one in cycle 61 to be able to fetch the R-component of the next
pixel from Buf0 in cycle 62 (one cycle memory read latency). From cycles 59 to 73, the ﬁrst
line of the active image is delivered to the frame by incrementing Addr0 from 0 to 4. Cycle
73 also indicates the start of the second horizontal blanking line. In this cycle, RE0 tran-
sitions to logic 0, and Addr0 stops incrementing because pixel ﬂow from Buf0 needs to be
interrupted in order to start delivering blank pixels to the frame. To accommodate this, the
port assignment in the 3-1 MUX is changed from port B0 to port BK. After completing the
delivery of horizontal blanking pixels, the second line of the active image is delivered
between cycles 83 and 97. Addr0 is incremented from 5 to 9 during this period to fetch
pixels from Buf0 and form the second active image line. The rest of the image is delivered to
the frame by the end of cycle 265. In cycle 266, a new frame is formed with SyncVB = 1. As
in the previous frame, pixels that constitute the vertical blanking are followed by pixels that
form the horizontal blanking and the active image. The new active image pixels are delivered
from Buf1. In this example, both Buf0 and Buf1 are assumed to contain only 45 pixels, and
therefore each buffer has 3x45 = 135 bytes of image data as opposed to the architecture in
Fig. 7.34 that contains 1024  1024 = 1,048,576 active image pixels in each buffer.
Figure 7.38 shows the display controller design to manage the data-ﬂow in Fig. 7.34. The
state machine in Fig. 7.38 is a Moore-type composed of a string of states, each responsible
for delivering blank or active image pixels to the frame. The state machine needs to keep
track of the pixel and line numbers in the frame, and be able to deﬁne the boundaries
between the blanking and the active image regions. Therefore, its functionality largely
depends on the pixel and the line counter values in Fig. 7.34.
The state machine stays in the IDLE state until it is externally activated by
CSDisplay = 1, which corresponds to cycle 1 of the timing diagram in Fig. 7.36. Once
7.6
Display Adaptor
419

59
60
61
62
R
G
B
0
R
G
B
1
R
G
B
4
1
0
clock
FrameIn
PxOut
LineOut
CSDisplay
SelR0
SelG0
SelB0
SelBuf0
SelBuf1
SelBlank
RE0
RE1
Addr0
IncAddr0
ResetAddr0
IncPx
ResetPx
IncLine
ResetLine
SelR1
SelG1
SelB1
Addr1
IncAddr1
ResetAddr1
63
64
65
66
67
68
69
70
71
72
73
74
R
G
B
2
R
G
B
3
R
G
B
4
00
00
00
0
R
G
B
4
00
00
00
0
00
00
00
00
00
0
00
00
00
1
6
0
8
2
4
0
ACTIVE IMAGE
75
76
95
96
97
242 243 244
263 264 265 266 267 268 269 270 271
284 285
VERTICAL BLANK
ACTIVE IMAGE
ACTIVE IMAGE
HOR. BLANK
HOR. BLANK
0
1
2
3
4
9
44
SyncVB
SyncHB
Fig. 7.37 Continuation of the timing diagram in Fig. 7.36
420
7
System Peripherals

IDLE
CSDisplay = 0
VB0
R
VB0
G
VB0
B
Reset VB0
R
Reset VB0
G
Reset VB0
B
HB0
R
HB0
G
HB0
B
Reset HB0
R
Reset HB0
G
Reset HB0
B
R0
G0
B0
Reset R0
Reset G0
Reset B0
PxOut < (HBOut + AIPOut - 2)
LineOut < 
(VBOut - 1)
PxOut < (HBOut - 2)
PxOut = (HBOut + AIPOut - 2)
SelBlank = 1
IncPx = 1
SelBlank = 1
SelBlank = 1
SelBlank = 1
ResetPx = 1
IncLine = 1
SelBlank = 1
SelBlank = 1
SelBlank = 1
IncPx = 1
SelBlank = 1
PxOut = (HBOut - 2)
SelBlank = 1
SelBlank = 1
ResetPx = 1
SelBlank = 1
RE0 = 1
PxOut < (AIPOut - 2)
PxOut = (AIPOut - 2)
LineOut < (AILOut - 2)
SelR0 = 1
SelBuf0 = 1
RE0 = 1
SelG0 = 1
SelBuf0 = 1
RE0 = 1
IncAddr0 = 1
IncPx = 1
SelB0 = 1
SelBuf0 = 1
RE0 = 1
SelR0 = 1
SelBuf0 = 1
RE0 = 1
SelG0 = 1
SelBuf0 = 1
RE0 = 1
ResetPx = 1
IncLine = 1
SelB0 = 1
SelBuf0 = 1
Last HB0
R
Last HB0
G
Last HB0
B
Reset 
Last HB0
R
Reset 
Last HB0
G
Reset 
Last HB0
B
Last R0
Last G0
Last  B0
Reset 
Last R0
Reset 
Last G0
Reset 
Last B0
PxOut < (HBOut - 2)
SelBlank = 1
IncPx = 1
SelBlank = 1
PxOut = (HBOut - 2)
SelBlank = 1
SelBlank = 1
ResetPx = 1
SelBlank = 1
RE0 = 1
PxOut < (AIPOut - 2)
PxOut = (AIPOut - 2)
SelR0 = 1
SelBuf0 = 1
RE0 = 1
SelG0 = 1
SelBuf0 = 1
RE0 = 1
IncrAddr0 = 1
IncPx = 1
SelB0 = 1
SelBuf0 = 1
RE0 = 1
SelR0 = 1
SelBuf0 = 1
RE0 = 1
SelG0 = 1
SelBuf0 = 1
RE0 = 1
ResetAddr0 = 1
ResetLine = 1
ResetPx = 1
SelB0 = 1
SelBuf0 = 1
LineOut = (AILOut - 2)
CSDisplay = 1
START1
SelBlank = 1
SelBlank = 1
Buf0Empty = 1
SyncVB = 1
Switch0
VB-to-HB
ResetPx = 1
ResetLine = 1
SelBlank = 1
LineOut = 
(VBOut - 1)
START0
SelBlank = 1
Buf1Empty = 1
SyncVB = 1
SelBlank = 1
Sync
HB0
A
SyncHB = 1
SelBlank = 1
Sync
HB0
SyncHB = 1
SelBlank = 1
Sync
HB0
B
SyncHB = 1
SelBlank = 1
Fig. 7.38 Display adaptor controller for Buf0
7.6
Display Adaptor
421

activated, the R-component of the ﬁrst blank pixel enters the frame through the BK-port of
the 3-1 MUX, and prompts SelBlank = 1 in cycle 2. This refers to the START0 state in
Fig. 7.38. In cycle 3, the G-component of the ﬁrst blank pixel is delivered to the frame. This
is shown as the VB0-G state in the state diagram. In this state, SelBlank = 1 in order to
transmit the G-component of the ﬁrst blank pixel to the frame. The B-component of the ﬁrst
blank pixel arrives in cycle 4, which corresponds to the VB0-B state. During this cycle,
SelBlank = 1 and IncPx = 1 to increment the pixel counter by one. At this point, the
controller checks if the end of the ﬁrst vertical blanking line has been reached by forming
PxOut = (HBOut + AIPOut – 2). Here, PxOut corresponds to the output of the pixel
counter, HBOut corresponds to the number of horizontal blanking pixels in the Horizontal
Blanking register, and AIPOut corresponds to the number of active image pixels in the
Active Image Pixel register in Fig. 7.34. If the end has not been reached, the machine keeps
circling around the VB0-R, VB0-G and VB0-B states until PxOut becomes equal to
(HBOut + AIPOut – 2). This period translates from cycles 5 to 22 in the timing diagram in
Fig. 7.36. During this period, every time the B-component of a blank pixel is delivered to the
frame, the pixel counter increments by one. When the end point is detected, the state
machine goes to the Reset VB0-R state where it delivers the R-component of the last
blanking pixel that belongs to the ﬁrst blanking line. This state corresponds to cycle 23 in the
timing diagram. The controller delivers the remaining G and B-components of the last
blanking pixel in cycles 24 and 25, which translate to the Reset VB0-G and Reset VB0-B
states, respectively. In cycle 25, the pixel counter is reset by ResetPx = 1, and the line
counter is incremented by IncLine = 1 in order to produce the next vertical blanking line.
However, the contents of the Vertical Blanking register, VBOut, needs to be checked prior to
the start of the next vertical blanking line in case this register is programmed to have only
one vertical blanking line. Therefore, while in the Reset VB0-G state, the line counter
output, LineOut, is compared against (VBOut - 1). If the line counter output is less than
(VBOut – 1), then the state machine ﬁrst goes to the Reset VB0-B state and then back to the
VB0-R state in order to generate another blanking line as described in cycles 26 to 49 in the
timing diagram. If LineOut is equal to (VBOut – 1), the state machine goes to the Switch0
VB-to-HB state where it generates SelBlank = 1, ResetPx = 1 and ResetLine = 1 in order to
terminate the vertical blanking and start the ﬁrst line of the horizontal blanking.
Cycle 50 starts the beginning of horizontal blanking region, and delivers the R-component
of the ﬁrst horizontal blanking pixel to the frame. This cycle translates to the Sync HB0-A
state because SyncHB = 1 is also generated in this state. The state machine moves through
the HB0-G and HB0-B states in cycles 51 and 52, and checks if the end of the horizontal
blanking region has been reached by comparing the PxOut with (HBOut – 2). If PxOut <
(HBOut – 2), then more R, G and B blanking pixel components are brought into the frame
422
7
System Peripherals

through the BK-port of the 3-1 MUX. However, if PxOut = (HBOut – 2), then the state
machine enters the Reset HB0-R state to deliver the R-component of the last horizontal
blanking pixel in cycle 56 as this condition indicates the end of horizontal blanking. In
cycles 57 and 58, the machine traverses through the Reset HB0-G and the Reset HB0-B
states. The latter state resets the pixel counter by ResetPx = 1, and enables Buf0 by RE0 = 1
to start reading active image pixels.
In cycle 59, the state machine enters the R0 state to deliver the R-component of the ﬁrst
active image pixel from Buf0. In this state, port 0 of the 3-1 MUX at the output of Buf0
becomes active by SelR0 = 1, and port B0 of the 3-1 frame MUX becomes active by
SelBuf0 = 1. The read enable input for Buf0 also stays at logic 1 by RE0 = 1. In cycle 60,
the state machine goes to the G0 state where it delivers the G-component of the ﬁrst active
image pixel to the frame. This cycle requires SelG0 = 1 to activate port 1 of the 3-1 MUX at
the output of Buf0 while keeping SelBuf0 = 1 and RE0 = 1. Addr0 is also incremented in
this state by IncAddr0 = 1. In cycle 61, the controller reaches the B0 state where it incre-
ments the pixel counter by IncPx = 1, selects port 2 of the 3-1 MUX at the output of Buf0 by
SelB0 = 1, and maintains both SelBuf0 = 1 and RE0 = 1. In this state, the controller checks
if the end of active image has been reached by comparing PxOut against (AIPOut – 2). If the
controller ﬁnds PxOut < (AIPOut – 2), it goes back to the R0 state to retrieve more image
pixels from Buf0. This scenario corresponds to cycles 62 to 70 of the timing diagram in
Fig. 7.37. If the controller ﬁnds PxOut = (AIPOut – 2), it moves to the Reset R0 state in
cycle 71 to deliver the last R-component of the image pixel, and generates SelR0 = 1,
SelBuf0 = 1 and RE0 = 1. The state machine then moves to the Reset G0 state in cycle 72
and the Reset B0 state in cycle 73. In the Reset B0 state, the controller resets the pixel
counter by ResetPx = 1, increments the line counter by IncLine = 1, selects port 2 of the 3-1
Buf0 MUX by SelB0 = 1, and keeps SelBuf0 = 1. While in this state, the controller checks
to see if the active image is more than a single line or not, and compares the output of the
line counter, LineOut, against (AILOut – 2). If the controller ﬁnds that LineOut < (AILOut –
2), it ﬁrst moves to the Sync HB0 state to generate SyncHB = 1, and then back to the HB0-G
state to start fetching horizontal blanking pixels for the next line. However, if the controller
ﬁnds that LineOut = (AILOut – 2), it realizes that it will be processing the last line of the
current frame. First, it goes to the Sync HB0-B state and generates SyncHB = 1, and then to
the Last HB0-G state to deliver the G-component of a horizontal blanking pixel.
The states from Last HB0-R to Reset Last-B0 are the exact replicas of the states from
HB0-R to Reset B0 except that in the Reset Last-G0 state, Buf0 address pointer is reset by
ResetAddr0 = 1, and in the Reset Last-B0 state, the line counter is reset by ResetLine = 1.
Once the controller exhausts all the active image pixels in Buf0, it switches to Buf1 to
construct the next image frame as shown in the state diagram of Fig. 7.39. In this ﬁgure, the
7.6
Display Adaptor
423

VB1
R
VB1
G
VB1
B
Reset VB1
R
Reset VB1
G
Reset VB1
B
HB1
R
HB1
G
HB1
B
Reset HB1
R
Reset HB1
G
Reset HB1
B
R1
G1
B1
Reset R1
Reset G1
Reset B1
PxOut < (HBOut + AIPOut - 2)
LineOut < 
(VBOut - 1)
PxOut < (HBOut - 2)
PxOut = (HBOut + AIPOut - 2)
SelBlank = 1
IncPx = 1
SelBlank = 1
SelBlank = 1
SelBlank = 1
ResetPx = 1
IncLine = 1
SelBlank = 1
SelBlank = 1
SelBlank = 1
IncPx = 1
SelBlank = 1
PxOut = (HBOut - 2)
SelBlank = 1
SelBlank = 1
ResetPx = 1
SelBlank = 1
RE1 = 1
PxOut < (AIPOut - 2)
PxOut = (AIPOut - 2)
LineOut < (AILOut - 2)
SelR1 = 1
SelBuf1 = 1
RE1 = 1
SelG1 = 1
SelBuf1 = 1
RE1 = 1
IncAddr1 = 1
IncPx = 1
SelB1 = 1
SelBuf1 = 1
RE1 = 1
SelR1 = 1
SelBuf1 = 1
RE1 = 1
SelG1 = 1
SelBuf1 = 1
RE1 = 1
ResetPx = 1
IncLine = 1
SelB1 = 1
SelBuf1 = 1
Last HB1
R
Last HB1
G
Last HB1
B
Reset 
Last HB1
R
Reset 
Last HB1
G
Reset 
Last HB1
B
Last R1
Last G1
Last  B1
Reset 
Last R1
Reset 
Last G1
Reset 
Last B1
PxOut < (HBOut - 2)
SelBlank = 1
IncPx = 1
SelBlank = 1
PxOut = (HBOut - 2)
SelBlank = 1
SelBlank = 1
ResetPx = 1
SelBlank = 1
RE1 = 1
PxOut < (AIPOut - 2)
PxOut = (AIPOut - 2)
SelR1 = 1
SelBuf1 = 1
RE1 = 1
SelG1 = 1
SelBuf1 = 1
RE1 = 1
IncrAddr1 = 1
IncPx = 1
SelB1 = 1
SelBuf1 = 1
RE1 = 1
SelR1 = 1
SelBuf1 = 1
RE1 = 1
SelG1 = 1
SelBuf1 = 1
RE1 = 1
ResetAddr1 = 1
ResetLine = 1
ResetPx = 1
SelB1 = 1
SelBuf1 = 1
LineOut = (AILOut - 2)
START0
SelBlank = 1
SelBlank = 1
Buf1Empty = 1
SyncVB = 1
Switch1
VB-to-HB
ResetPx = 1
ResetLine = 1
SelBlank = 1
LineOut = 
(VBOut - 1)
START1
SelBlank = 1
Buf0Empty = 1
SyncVB = 1
SelBlank = 1
Sync
HB1
A
SyncHB = 1
SelBlank = 1
Sync
HB1
SyncHB = 1
SelBlank = 1
Sync
HB1
B
SyncHB = 1
SelBlank = 1
Fig. 7.39 Display adaptor controller for Buf1
424
7
System Peripherals

states controlling the blanking and the image pixel delivery from Buf1 is exactly the same as
in Buf0. Once all the pixels are delivered to the frame from Buf1, the state machine in
Fig. 7.39 hands over the control of the display adaptor to the state machine in Fig. 7.38.
7.7
Data Converters
Analog-to-Digital Converter
All analog domains interface with digital systems through Analog-to-Digital Converters
(ADC). In Fig. 7.40, an analog signal from a sensor is ampliﬁed to a certain level before
sampling takes place in a sample-and-hold circuit inside the ADC. The sampled analog
signal is then converted into digital form and directed to the CPU for processing according to
an embedded program.
The signal resolution is an important factor to consider in an ADC design. It simply means
dividing a sampled analog signal by 2N number of voltage levels where N represents the
number of bits in the ADC. The second important consideration is the range of analog values
an ADC can capture and process.
Figure 7.41 describes the ADC resolution in a numerical example where an analog signal
changes between 0 V and 5 V. The bit resolution is only three bits, and therefore the ADC
uses 23 = 8 levels to identify the value of an analog signal at the ADC input. For example,
an analog signal of 2.501 V is identiﬁed by a digital output of 100. If the analog signal
increases to 3.124 V, the digital output that represents this voltage value still stays at 100. In
other words, in a three-bit ADC there is no difference between 2.501 V and 3.124 V in terms
of their digital representation. The 0.625 V step size is the natural occurring error in a
three-bit ADC, and it can be reduced only if the number of bits in the ADC is increased. In
general, increasing the number of ADC bits by one halves the error. Therefore, designing a
four-bit ADC instead of a three-bit ADC reduces the quantization error by 0.3125 V.
Sensor
Sample
Hold
Analog To 
Digital 
Converter
Micro-
controller
AMP
Small Analog Signal
Amplified Analog Signal
Digital Input
Sampled Analog Signal
Digital to 
Analog 
Converter
Analog Signal
Digital Output
Fig. 7.40 Typical Analog-to-Digital and Digital-to-Analog Converter data-paths
7.6
Display Adaptor
425

The reference voltage of an ADC is generally determined by the maximum voltage level
of the analog signal, and it is used to calculate the step size. In this three-bit ADC example in
Fig. 7.41, the reference voltage is 5 V because the ampliﬁed analog voltage at the input of
the ADC is limited not go beyond 5 V.
ADC samples non-periodic analog signals in regular time intervals as described in
Fig. 7.42. The time interval between sampling points is called the sampling period. The
sampling period is adjusted according to the processing speed of the ADC in order to
generate accurate digital outputs.
Once sampled, the analog voltage at the input of an ADC is held steady throughout the
sampling period while the conversion takes place as shown in Fig. 7.43. The shape of the
converted signal may be quite different from the original analog signal due to the ADC
resolution and the time duration between samples. In a three-bit ADC, sampling takes place
0.625
1.250
1.875
2.500
0.000
3.125
3.750
4.375
5.000
Analog Signal (V)
000
001
010
011
100
101
110
111
Digital Output
23 Levels
Maximum Digital Output
Reference Voltage
Step Size =
Reference Voltage – Minimum Voltage
2ADC Bit Size
=
5 - 0
23
= 0.625V
Fig. 7.41 Input-output description of a three-bit ADC
426
7
System Peripherals

0.625
1.250
1.875
2.500
0.000
3.125
3.750
4.375
5.000
Sampling Period
Time (sec)
Signal (V)
Sampling Point
Fig. 7.42 Sampling a continuous analog signal
Quantization Error
Step
Size
Quantized Signal
0.625
1.250
1.875
2.500
0.000
3.125
3.750
4.375
5.000
Sampling Period
Time (sec)
Signal (V)
Sampling Point
Fig. 7.43 Sampling period, hold concept and regeneration of an analog signal
7.7
Data Converters
427

in 0.625 V increments. Therefore, each sampling point becomes subject to a dynamic
quantization error which changes between 0 V and 0.3125 V. For example, a three-bit ADC
samples 3.4 V according to its closest sampling level of 3.125 V, and produces a 0.275 V
error. Arbitrary signals that change with a frequency faster than the sampling frequency are
subject to much larger dynamic errors. When converted back to their analog form, these
signals show large deviations from their original shapes.
A basic sample-and-hold circuit consists of an NMOS transistor and a capacitor as shown
in Fig. 7.44. The control input simply turns on the N-channel MOSFET for a short period of
time, called the sampling width, during which the analog voltage level at the input is stored
on the capacitor. When the transistor is turned off, this analog value is held constant until the
next sampling point.
Flash ADC
The simplest ADC is the ﬂash-type as shown in Fig. 7.45. This three-bit ADC contains 23 = 8
operational ampliﬁers. The analog signal is applied to all eight positive input terminals. The
reference voltage is distributed to each negative input terminal via a voltage divider circuit.
Each operational ampliﬁer acts as a differential ampliﬁer and ampliﬁes the difference between
a continuously changing analog signal and the portion of the reference voltage.
Figure 7.46 describes the operation of the three-bit ﬂash ADC and its encoder in a truth
table. When the analog voltage is less than or equal to 0.625 V, only Out[0] becomes logic
1, all other outputs from Out[1] to Out[7] become logic 0. When the analog signal exceeds
0.625 V but less than 1.25 V, only Out[0] and Out[1] become logic 1, and again all others
become logic 0. Higher analog voltages at the input successively produce more logic 1 levels
Control Input
Sampling Width
Analog Input
Capacitor
Quantized Signal
Fig. 7.44 A typical sample-and-hold circuit
428
7
System Peripherals

as shown in Fig. 7.46. An encoder is placed at the output stage of all operational ampliﬁers
to transform the voltage levels at Out[7:0] into a three-bit digital output, DOut[2:0]. The
digital output is subject to a maximum error of 0.625 V because only three bits are used for
conversion.
Out[7]
Reference voltage
R
Out[6]
Out[5]
Out[4] 
Out[3] 
Out[2] 
Out[1] 
Out[0] 
R
R
R
R
R
R
DOut[2]
DOut[1]
DOut[0]
FLASH ADC ENCODER
Analog voltage
4.375V
3.750V
3.125V
2.500V
1.875V
1.250V
0.625V
R
0.0V
Fig. 7.45 Typical three-bit ﬂash ADC schematic
7.7
Data Converters
429

Ramp ADC
The ramp ADC uses only a single operation ampliﬁer, but it employs an up-counter and a
Digital-to-Analog Converter (DAC) in a loop structure as shown in Fig. 7.47. The digital
output is obtained from the C[3:0] terminals, and progressively generates a ﬁnal output
within several clock periods.
Out[7] Out[6] Out[5] Out[4] Out[3] Out[2] Out[1] Out[0]
DOut[2]
DOut[1] DOut[0]
0.625 > 
> 0.000
1.250 > VIN 
VIN 
VIN 
VIN 
VIN 
VIN 
VIN 
VIN 
> 0.625
1.875 > 
> 1.250
2.500 > 
> 1.875
3.125 > 
> 2.500
3.750 > 
> 3.125
4.375 > 
> 3.750
5.000 > 
> 4.375
0
0
0
0
0
0
0
1
0
0
0
0
0
0
1
1
0
0
0
0
0
1
1
1
0
0
0
0
1
1
1
1
0
0
0
1
1
1
1
1
0
0
1
1
1
1
1
1
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
Analog Input
Fig. 7.46 Three-bit ﬂash ADC truth table describing its operation
4-bit Counter
DAC
S/H
Analog Input
+VCC = 5V
-VCC = 0V
C[3]
C[0]
C[2]
C[1]
Reset
DACOUT
SHOUT
INCR
Fig. 7.47 Typical four-bit ramp ADC schematic
430
7
System Peripherals

The top portion of Fig. 7.48 describes the output voltage assignments of a four-bit ramp
ADC using two different types of number-rounding schemes. The down-rounding scheme
assigns a lower analog value to each digital output compared to the up-rounding scheme. For
example, the down-rounding scheme produces a digital output of C[3:0] = 0100 for analog
voltages between 1.0937 V and 1.4062 V applied to its input. If the up-rounding scheme is
used, the same digital output becomes equivalent to an analog voltage anywhere between
1.4062 V and 1.7187 V.
The middle table in Fig. 7.48 shows how the conversion takes place if the down-rounding
mechanism is used in an example. Prior to its operation, the four-bit up-counter is reset and
produces C[3:0] = 0000. Assuming an analog voltage of 2 V is applied to the input, which
must be kept constant until the conversion is complete, C[3:0] = 0000 causes the DAC
output, DACOUT, to produce 0 V according to the down-rounding scheme. Since this value
is less than 2 V at the sample/hold circuit output, SHOUT, the output of the differential
ampliﬁer, INCR, transitions to the positive supply potential of the operational ampliﬁer,
+VCC = 5 V, which prompts the four-bit counter to increment to C[3:0] = 0001. Conse-
quently, the DAC generates DACOUT = 0.3125 V according to the truth table in Fig. 7.48.
However, this value is still less than SHOUT = 2 V. Therefore, the differential ampliﬁer
produces another INCR = 5 V which prompts the counter to increment again to C
[3:0] = 0010. Up-counting continues until C[3:0] = 0111 or DACOUT = 2.1875 V. Since
this last voltage is greater than SHOUT = 2 V, the differential ampliﬁer output switches back
to its negative supply voltage, −VCC = 0 V, and stops the up-counter from incrementing
further. The digital output stays steady at C[3:0] = 0111 from this point forward, repre-
senting 2 V analog voltage with a dynamic error of 0.1875 V.
The table at the bottom part of Fig. 7.48 represents the conversion steps if the
up-rounding mechanism is used in this ADC. External reset still produces C[3:0] = 0000
initially. However, the DAC output starts the conversion with an increased amount of
0.3125 V instead of 0 V. The counter increments until C[3:0] = 0110, and produces
2.1875 V at the DACOUT node. At this value, INCR becomes 0 V, and the up-counter stops
incrementing further. As a result, C[3:0] = 0110 becomes the ﬁnal ADC output for 2 V.
Successive Approximation ADC
The third type ADC is based on the successive approximation technique to estimate the
value of the analog voltage. This converter type is a trade-off between the ﬂash-type and the
ramp-type ADC in terms of speed and the number of components used in the circuit. As a
7.7
Data Converters
431

C[3]
C[2] C[1] C[0]
0
0
0
0
0
0
0
1
0
0
1
0
0
0
1
1
0
1
0
0
0
1
0
1
0
1
1
0
Down-Round (V)
Up-Round (V)
0.3125
0.0000
0.6250
0.3125
0.9375
0.6250
1.2500
0.9375
1.5625
1.2500
1.8750
1.5625
2.1875
1.8750
Step Size = 5/24 = 0.3125V
1
0
0
0
1
0
0
1
1
0
1
0
1
0
1
1
1
1
0
0
1
1
0
1
1
1
1
0
2.8125
2.5000
3.1250
2.8125
3.4375
3.1250
3.7500
3.4375
4.0625
3.7500
4.3750
4.0625
4.6875
4.3750
0
1
1
1
2.1875
2.5000
1
1
1
1
5.0000
4.6875
C[3]
Analog Input = 2V with Up-Rounding Mechanism
C[2] C[1] C[0]
Step
0
0
0
0
5.0
0
0
0
1
0.3125
5.0
0
0
1
0
0.6250
5.0
0
0
1
1
0.9375
5.0
0
1
0
0
1.2500
5.0
0
1
0
1
1.5625
5.0
0
1
1
0
1.8750
0.0
2.1875
1
2
3
4
5
6
7
Final output with quantization error of 0.3125V 
C[3]
Analog Input = 2V with Down-Rounding Mechanism
C[2] C[1] C[0]
DACOUT(V) 
Step
INCR(V)
DACOUT(V) 
INCR(V)
0
0
0
0
5.0
0
0
0
1
0.3125
5.0
0
0
1
0
0.6250
5.0
0
0
1
1
0.9375
5.0
0
1
0
0
1.2500
5.0
0
1
0
1
1.5625
5.0
0
1
1
0
1.8750
5.0
0.0000
1
2
3
4
5
6
7
Final output with quantization error of 0.3125V 
0
1
1
1
2.1875
0.0
8
Fig. 7.48 Four-bit ramp ADC truth table describing its operation
432
7
System Peripherals

numerical example, a typical four-bit successive approximation ADC schematic is shown in
Fig. 7.49. In this ﬁgure, the up-counter in the ramp ADC is replaced by a control logic which
successively transforms an analog input into a digital output by a trial and error method. The
output is obtained at the C[3:0] terminal.
The top portion of Fig. 7.50 shows the truth table to operate a four-bit successive
approximation ADC. Two numerical examples in this ﬁgure illustrate the down-rounding
and up-rounding schemes used during conversion.
The ﬁrst example in Fig. 7.50 illustrates the down rounding mechanism in a four-bit
successive approximation ADC. In this example, an analog voltage of 3.5 V is applied to the
analog input of the ADC. An external reset starts the converter at C[3:0] = 1000, which is
considered a mid point between C[3:0] = 0000, representing the minimum analog input of
0 V, and C[3:0] = 1111, representing the maximum analog input of 5 V for this ADC. For C
[3:0] = 1000, the DAC generates an initial analog voltage of 2.5 V at the DACOUT node.
Since this value is less than the sampled analog voltage of 3.5 V at the SHOUT node, the
operational ampliﬁer produces IN = 5 V, and prompts the control logic to try a slightly
Control Logic
DAC
S/H
Analog Input
C[3]
C[0]
C[2]
C[1]
Reset
DACOUT
SHOUT
IN
At Reset  C[3:0] = 1000 
DONE
+VCC = 5V
-VCC = 0V
Fig. 7.49 Typical four-bit successive approximation ADC schematic
7.7
Data Converters
433

C[3]
C[2] C[1] C[0]
0
0
0
0
0
0
0
1
0
0
1
0
0
0
1
1
0
1
0
0
0
1
0
1
0
1
1
0
Down-Round (V)
Up-Round (V)
0.3125
0.0000
0.6250
0.3125
0.9375
0.6250
1.2500
0.9375
1.5625
1.2500
1.8750
1.5625
2.1875
1.8750
Step Size = 5/24 = 0.3125V
1
0
0
0
1
0
0
1
1
0
1
0
1
0
1
1
1
1
0
0
1
1
0
1
1
1
1
0
2.8125
2.5000
3.1250
2.8125
3.4375
3.1250
3.7500
3.4375
4.0625
3.7500
4.3750
4.0625
4.6875
4.3750
0
1
1
1
2.1875
2.5000
1
1
1
1
5.0000
4.6875
C[3]
Analog Input = 3.5V with Up-Rounding Mechanism
C[2] C[1] C[0]
Step
1
0
0
0
1
1
0
0
4.0625
1
0
1
0
3.4375
2.8125
1
2
3
Final output with quantization error of 0.3125V 
Control Logic In
3.5 > 2.8125 
Thus try 2.8125 + (2.5/2) = 4.0625
START with (5.0/2) = 2.8125
3.5 < 4.0625 
Thus try 2.8125 + (2.5/4) = 3.4375
3.5 > 3.4375 
Stop at 3.4375 since there is no resolution under (2.5/8)
C[3]
Analog Input = 3.5V with Down-Rounding Mechanism
C[2] C[1] C[0]
DACOUT(V)
DACOUT(V)
Step
1
0
0
0
1
1
0
0
3.7500
1
0
1
0
3.1250
1
0
1
1
3.4375
2.5000
1
2
3
4
Final output with quantization error of 0.3125V 
Control Logic In
3.5 > 2.5000 
Thus try 2.5 + (2.5/2) = 3.75
START with (5.0/2) = 2.5
3.5 < 3.7500 
Thus try 2.5 + (2.5/4) = 3.125
3.5 > 3.1250 
Thus try 2.5 + (2.5/4) + (2.5/8) = 3.4375
3.5 > 3.4375 
Stop at 3.4375 since there is no resolution under (2.5/8)
Fig. 7.50 Four-bit successive approximation ADC truth table describing down-rounding
and up-rounding approximation techniques
434
7
System Peripherals

higher digital output. As a result, the control logic produces C[3:0] = 1100 as its ﬁrst trial,
which is equivalent to a midway point between C[3:0] = 1000 and 1111. DACOUT becomes
2.5 + (2.5/2) = 3.75 V. But, this new voltage is larger than SHOUT = 3.5 V, and the oper-
ational ampliﬁer produces IN = 0 V in return. The drop at the IN node is an indication to the
control logic that its initial attempt of C[3:0] = 1100 was too large, and it must lower its
output. This time, the control logic tries C[3:0] = 1010, which is between C[3:0] = 1000 and
1100, and produces a DAC output, DACOUT = 2.5 + (2.5/4) = 3.125 V. This value, in turn,
generates IN = 5 V, and prompts the control logic to try a slightly higher output between
C[3:0] = 1010 and 1100. In the third round, the control logic produces C[3:0] = 1011.
DACOUT node becomes 2.5 + (2.5/4) + (2.5/8) = 3.4375 V and generates IN = 5 V. This
new input suggests that the control logic should try a slightly higher output in the next round,
producing 2.5 + (2.5/4) + (2.5/8) + (2.5/16) = 3.5937 V at DACOUT. However, 2.5/8 =
0.3125 V is the resolution limit for this four-bit ADC, and as a result, the controller stalls at
C[3:0] = 1011, revealing DACOUT = 3.4375 V. This voltage differs from SHOUT = 3.5 V
by only 0.0625 V.
The second example in Fig. 7.50 explains the successive approximation technique if the
up-rounding scheme is employed. The conversion again starts at C[3:0] = 1000, but with an
incremented value of 2.5 + 0.3125 = 2.8125 V at the DAC output. Since this voltage is below
SHOUT = 3.5 V, IN node becomes 5 V and prompts the control logic to produce a larger digital
output. The control logic responds to this with a digital output of C[3:0] = 1100, which
corresponds to 2.8125 + (2.5/2) = 4.0625 V at the DACOUT node. As a result, IN node becomes
0 V, and forces the control logic to lower its digital output. This time, the control logic tries
C[3:0] = 1010 which is equivalent to 2.8125 + (2.5/4) = 3.4375 at the DACOUT node. Due to
the resolution limit of this four-bit ADC, this step also becomes the end of successive
approximation.
The control circuit of the four-bit ADC with down-rounding scheme is shown in Fig. 7.51.
In this ﬁgure, the approximation process starts at the midpoint, C[3:0] = 1000, corresponding
to DACOUT = 2.5 V according to the table in Fig. 7.50. When the external reset is removed,
and the difference between SHOUT and DACOUT (Δv) is found to be greater than the 0.3125 V
step size, the control logic either goes to the state 1.25 and produces C[3:0] = 0100 (equivalent
to 1.25 V), or to the state 3.75 and produces C[3:0] = 1100 (equivalent to 3.75 V) in the ﬁrst
step of the successive approximation. This decision depends on the value of the control logic
input, IN. If IN = 0, which translates to the analog input to be less than 2.5 V, the next state
becomes the state 1.25. However, if IN = 1, the analog input is considered to be greater than
2.5 V, and the next state becomes the state 3.75. If Δv is less than 0.3125 V, on the other
hand, the control logic cannot proceed further due to its resolution limit, and moves to the
7.7
Data Converters
435

4.6875
4.0625
4.375
3.75
3.4375
3.125
2.8125
2.1875
2.5
1.5625
1.875
1.25
0.625
0.3125
0.9375
DONE
Reset = 0
IN = 0,  Δv > 0.3125
Reset = 0
IN = 1,  Δv > 0.3125
Reset = 0
IN = 0,  Δv > 0.3125
Reset = 0
IN = 1,  Δv > 0.3125
IN = 0,  Δv > 0.3125
IN = 1,  Δv > 0.3125
Reset = 0
IN = 0,  Δv > 0.3125
Reset = 0
IN = 1,  Δv > 0.3125
Reset = 1
Reset = 0
Reset = 1
Reset = 0,  Δv < 0.3125
Reset = 0
IN = 0,  Δv > 0.3125
Reset = 0
IN = 1,  Δv > 0.3125
Reset = 0
IN = 0,  Δv > 0.3125
Reset = 0
IN = 1,  Δv > 0.3125
Reset = 0
IN = 0,  Δv > 0.3125
Reset = 0
IN = 1,  Δv > 0.3125
Reset = 0,  Δv < 0.3125
Reset = 0,  Δv < 0.3125
Reset = 0,  Δv < 0.3125
Reset = 0,  Δv < 0.3125
DONE = 1
Reset = 0,  Δv < 0.3125
Reset = 0,  Δv < 0.3125
Fig. 7.51 Four-bit successive approximation control circuit
436
7
System Peripherals

state DONE. In the second step of successive approximation, the state 1.25 either transitions
to the state 0.625 or to the state 1.875, depending on the value at the IN node. Similar
transitions take place from the state 3.75 to either the state 3.125 or the state 4.375, again
depending on the value of the IN node. After this point, the state machine performs one last
approximation to estimate the value of analog input voltage, and reaches the DONE state with
an output value as shown in Fig. 7.51.
7.8
Digital-to-Analog Converter (DAC)
The most common DAC utilizes the weighted summation method of digital inputs. A
three-bit DAC with a weighted binary adder is shown in Fig. 7.52 as an example.
This circuit is composed of two parts. The ﬁrst part adds all three binary input bits, IN[2]
(the most signiﬁcant bit), IN[1] and IN[0] (the least signiﬁcant bit), and produces an output,
ADDOUT = −(0.5 IN[2] + 0.25 IN[1] + 0.125 IN[0]) according to the equation in
Fig. 7.53. The second part is an analog inverter which forms OUT = −ADDOUT.
Therefore, the circuit in Fig. 7.52 generates OUT = 0.5 IN[2] + 0.25 IN[1] + 0.125 IN[0],
where each binary value at IN[2:0] input is multiplied by the coefﬁcients, 2−1, 2−2 and 2−3,
before they are added to produce an output. For example, the combination of IN[2] = 1,
IN[1] = 0 and IN[0] = 1, with +5 V and 0 V logic levels generates OUT = 2.5 + 0.625 =
3.125 V. All the other analog outputs in Fig. 7.53 can be generated using the equation in this
ﬁgure with a maximum error of 0.625 V.
4R
R
OUT
2R
8R
IN[2]
IN[1]
IN[0]
Weighted Binary Adder
Analog Inverter with Unity Gain
ADDOUT
R
R
Fig. 7.52 Three-bit DAC schematic with weighted binary adder
7.7
Data Converters
437

ADDOUT
ADDOUT
R
2R
=
R
4R
R
8R
IN[2]
IN[1]
IN[0]
0.5 IN[2]
0.25 IN[1]
0.125 IN[0]
=
IN[2] = 1, IN[1] = 0, IN[0] = 1 with +5V/0V logic levels 
ADDOUT =    2.5    0    0.625 =    3.125V
OUT = + 3.125V  with 0.625V quantization error 
IN[2]
IN[1]
IN[0]
OUT(V)
OUT =    
= 0.5 IN[2] + 0.25 IN[1] + 0.125 IN[0]
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
0.000
0.625
1.250
1.875
2.500
3.125
3.750
4.375
Example:
Fig. 7.53 Three-bit DAC operation with weighted binary adder
438
7
System Peripherals

Review Questions
1. A DMA controller transfers four words of data, D1, D2, D3 and D4, from SRAM 1
(source memory) to SRAM 2 (destination memory) on a 32-bit wide bidirectional bus
as shown below. D1, D2, D3 and D4 are fetched from addresses, AS1, AS2, AS3 and
AS4, in the source memory and placed at the AD1, AD2, AD3 and AD4 addresses in
the destination memory, respectively. Since each SRAM memory has a single I/O port,
address and data cannot be transferred in the same clock cycle. Therefore, for the read
operation, data becomes available at the SRAM I/O port a cycle after a valid address is
presented. For the write operation, data has to be present at the SRAM port a cycle after
the valid address. The active-high RE and WE signals enable the SRAM for read or
write operations when a valid address is available.
The DMA controller has two programming ports to program the initial address and the
incremented address values. It uses ProgAddrS and ProgIncrS control inputs to ini-
tialize and increment the source address, and the ProgAddrD and ProgIncrD inputs to
initialize and increment the destination memory address. The active-high StartS pro-
duces the ﬁrst address at AddrOutS. The IncrS input increments addresses based on the
initial address. Similarly, the StartD input produces the ﬁrst address at the AddrOutD
port, and the IncrD increments addresses based on the initial address.
The Capture1 and Capture2 inputs capture data from the bus temporarily and store it in
the Buf1 and Buf2 data buffers, respectively. All active-high enable inputs enable the
tri-state buffers when they are at logic 1. Otherwise, there will be no connection
between the address pointers and the bus or between the memories and the bus.
Addr PointS
Addr PointD
Buf1
Capture1
SRAM1
31
0
EnDIn1
EnDOut1
EnAddr1
32
32
WE1
RE1
EnAddrD
EnAddrS
Buf2
Capture2
SRAM2
31
0
EnDIn2
EnDOut2
EnAddr2
32
WE2
RE2
IncrD
StartD
ProgIncrD
ProgAddrD
IncrS
StartS
ProgIncrS
ProgAddrS
ProgInD
ProgInS
DMA
A/D1
A/D2
AddrOutS
AddrOutD
Bus
7.8
Digital-to-Analog Converter (DAC)
439

(a) Draw the schematic for the source and destination address pointers.
(b) Form a timing diagram to transfer four words of data from SRAM1 to SRAM2.
2. The waveforms shown below are generated by two different timers.
(a) A rate generating timer produces an active-high pulse in every 128 cycles as shown
below. Design this timer and draw its schematic.
(b) A one-shot timer produces a continuous pulse 100 cycles after the start signal as
shown below. Design this timer and draw its schematic.
3. An interrupt controller managing four hardware interrupts is connected to a 16-bit CPU,
which consists of a 16-bit wide instruction memory, Imem, a data memory, Dmem, a
program counter for the Imem, PC, a program counter for the data memory, DC, the
data registers A and B, and a controller. This schematic is shown below.
The interrupt protocol in this schematic is as follows:
Step 1: The active-high interrupt, INTR, is generated by the interrupt controller to
inform the CPU about the presence of an interrupt. The interrupt controller
must have a request from an external device with an interrupt ID before
generating INTR.
Step 2: The CPU acknowledges receiving an INTR with an active-high interrupt
acknowledge, INTA.
clock
1
2
3
125
126
127
0
0
Out
1
clock
Start
1
2
3
98
99
100
101
0
Out
102
440
7
System Peripherals

Step 3: The interrupt controller produces an interrupt ID on the 16-bit bi-directional
data bus.
Step 4: The interrupt ID is loaded to the PC to access the interrupt service routine
(ISR) address.
Step 5: The ISR address is loaded to the PC.
Step 6: One of the four interrupt service instructions is fetched from the instruction
memory for a particular interrupt. The steps are as follows:
DC
Dmem
PC
Imem
A
B
+
CPU Controller
INTR
INTA
Int ID0
16
DIn
DC Addr
DIn/Out
16
0
2
1
sel port0
sel port1
sel port2
REDmem
WEDmem
REDC IncDC
PC Addr
WEA
WEB
Int ID1
Int ID2
Int ID3
Req0
Req1
Req2
Req3
16
16
16
16
REPC IncPC
DOut
WEDC
WEPC
OEIC
Int ID
Interrupt
Controller
REImem
WEImem
16
16
16
7.8
Digital-to-Analog Converter (DAC)
441

Step 6a: The ﬁrst interrupt instruction speciﬁes the data memory address to
be loaded to the DC.
Step 6b: The second instruction contains the value of A to be loaded to the
A register.
Step 6c: The third instruction contains the value of B to be loaded to the B
register.
Step 6d: The fourth instruction provides either the contents of the A register
or the contents of B register or the added results of both registers to
be loaded to the data memory at a DC address. This value will later
be used in the program (the related hardware is not shown in the
schematic above).
Step 7: When the four-cycle interrupt service is complete, the CPU lowers its INTA
signal. In response, the interrupt controller lowers its INTR signal a cycle after
the INTA input transitions to logic 0, and waits for the next interrupt.
Note: Imem or Dmem have SRAM conﬁgurations. Storing data at a valid address is
achieved by WE = 1 within the same clock cycle. Reading data from a memory address is
achieved by RE = 1 with a latency of two clock cycles (data is not read at the beginning of
the next clock cycle, but the one after next).
(a)
If the priority scheme in the interrupt controller is such that device 0 has the highest
priority and device 3 has the lowest priority, design this controller with the I/O port
description shown on the schematic. Note that this controller can support only
hardware interrupts.
(b)
Show a timing diagram outlining the complete interrupt service from step 1 to step 7
above.
(c)
Show the state diagram of the controller, including all the inputs to operate the
instruction and data memories, registers etc.
4. A display unit works on a unidirectional bus that transmits 24-bit video pixels. Each pixel
is comprised of eight-bit wide R, G and B components which occupy the least signiﬁcant
three bytes of the write-data bus (the most signiﬁcant byte is always 0x00). The write-bus
ﬁlls a video buffer at a frequency of 2f. Similarly, the frequency of fetching data from a
buffer to ﬁll a video frame is f (buffer emptying rate). Assume the horizontal and the
vertical blanking sections of the video frame are both zero.
The display unit is the highest priority peripheral on the bus because of the fact that it
requires a minimum rate of 30 frames/sec to process and display data. However, other
442
7
System Peripherals

peripherals in the system also use the same bus in order to send or receive data between
video bursts.
Each timing diagram below contains three vital entries for a frame buffer. The top row
indicates the ID number of a ﬂag associated with an empty buffer. The middle row
indicates the ID number of an empty buffer. The bottom row shows the ID number of a
full buffer. The ﬂag is a direct input to the CPU, and points out which buffer in the
display unit needs to be ﬁlled. Note that all buffers are considered full before data
transactions start. Each square in the timing diagram corresponds to ﬁlling or emptying
an entire buffer. Since ﬁlling a buffer takes half the time of emptying it, the number of
squares doubles at the bottom row relative to the middle row.
Suppose you have the ﬂexibility of using a two buffer, a three buffer or a four buffer
system in the video unit. The key consideration in this design is to have enough frame
buffers in the system so that a continuous stream of data can be supplied to the display
unit while other peripherals use the bus.
Once full, deﬁne the length of the data burst from each buffer in the timing tables below.
Mark each entry with buffer numbers, and use the letters E or F to indicate whether each
buffer is empty or full, respectively. The video unit empties buffers in the following
order. In a two-buffer system, buffer 1 empties ﬁrst, buffer 2 empties second. In a
three-buffer system, buffer 1 empties ﬁrst, buffer 2 second, and buffer 3 third. In a
four-buffer system, buffer 1 empties ﬁrst, buffer 2 second, buffer 3 third, and buffer 4
fourth. Indicate the ﬂag number for each empty buffer inside the circle.
2. Buffer system:
3. Buffer system:
4. Buffer system:
Flag No
Empy No
Full No
Time
Flag No
Empy No
Full No
Time
Flag No
Empy No
Full No
Time
7.8
Digital-to-Analog Converter (DAC)
443

5. A three-bit successive approximation ADC is given below. A Sample-Hold circuit (S/H)
samples varying analog voltages at the Analog Input port in periodic time intervals and
directs them to the operational ampliﬁer.
Use the empty timing diagram below and ﬁll the blanks for Analog Input = 0.5 V with
down-rounding mechanism.
Control
Logic
DAC
S/H
Analog Input
+Vcc = 5V
-Vcc = 0V
C[2:0]
Reset
DACOUT
SHOUT
IN
At Reset  C[2:0] = 100 
3
clock
Reset
C[2:0]
DACOUT
IN
444
7
System Peripherals

6. A three-bit ramp ADC below operates with +VCC = 3 V and –VCC = 0 V. This ADC is
designed to take any analog input between 0 V and 3 V.
(a) Assume that the DAC has an up-rounding scheme to generate analog outputs from
digital inputs. Apply 1.2 V to the Analog Input port, and draw the timing diagram that
contains the clock, Reset, counter output (COUNTOUT), DAC output (DACOUT) and
operational ampliﬁer output (INCR). Show what happens to the timing diagram when
the active-high Reset signal transitions to logic 1 after the ADC produces the desired
digital output.
(b) Assume that the rounding scheme has changed from up-rounding to down rounding.
(c) Assume that the DAC rounding scheme is changed from up-rounding to
down-rounding scheme. Apply 1.2 V to the Analog Input and generate the timing
diagram with the input and output signals listed above. Show what happens to the
timing diagram when the Reset signal transitions to logic 1 after the ADC produces
the desired digital output. Do you see any issues with the operation of this circuit?
(d) Now apply 2.9 V to the Analog Input port and generate the timing diagram with the
input and output signals listed above. Do you see any issues in the operation of this
circuit?
3-bit counter
DAC
S/H
Analog Input
+Vcc = 5V
-Vcc = 0V
Reset
DACOUT
SHOUT
INCR
3
COUNTOUT[2:0]
7.8
Digital-to-Analog Converter (DAC)
445

7. The following circuit shows the block diagram of a simple transmitter-receiver. The
transmission protocol starts with the transmitter sending the request signal, Req, to the
receiver. The receiver acknowledges the request by producing an acknowledgement
signal, Ack, and starts reading data from the transmitter at the next positive edge of the
clock following the Ack signal. Once the data transmission ends, the transmitter keeps
sending the last data packet on the Data bus.
Transmitter
Receiver
Req
Ack
Data
32
clockTx
clockRx
(a) Assume the transmitter sends out three consecutive data packets, D0, D1, D2.
Complete the timing diagram below for the Ack and Data signals. Show which data
the receiver actually receives.
(b) In this case, the transmitter sends out three consecutive data packets, D0, D1, D2,
again, but uses a slower clock. Complete the timing diagram below for the Ack and
Data signals, and show which data the receiver acquires.
clockTx
clockRx
Req
Ack
Data
clockTx
clockRx
Req
Ack
Data
446
7
System Peripherals

8. A black-and-white display supports 256 shades of gray, ranging from white to black. The
physical display frame has 100 pixels in the x-direction and 100 lines in the y-direction,
and it requires a frame rate of 100 frames/sec. The display needs no horizontal or vertical
blanking pixels to synch with the display adaptor. The clock frequency of the display
adaptor is set to 1 MHz. The display adaptor is connected to an eight-bit wide high-speed
bus operating at 10 MHz to receive data. Once the adaptor recognizes that one of its
buffers is empty, it immediately sends a request signal to the bus arbiter to own the bus.
The acknowledgement from the bus arbiter requires 18 ms delay due to heavy bus trafﬁc.
Once the acknowledgment is received, the display adaptor ﬁlls all of its buffers. Each
buffer contains exact number of pixels to ﬁll only one frame.
(a) With the timing specs deﬁned above, determine the number of buffers that need to be
used in this system. Draw a timing table that shows how these buffers are periodically
emptied and ﬁlled following an 18 ms bus waiting period. Note that this is not a
timing diagram that includes the frame clock, bus clock or propagation of data.
(b) Draw an architectural data-path of the display adaptor including the buffers, the
gray-scale frame and the related hardware (counters, multiplexers, controller etc.).
Make sure to generate all the internal I/O signals of the controller to operate the
arbiter and maintain the proper data ﬂow in the display adaptor.
9. A display adaptor has an overlay feature where an overlay image is mapped over the
active image as long as the overlay image area is smaller than the active image area. The
system neither requires any blanking space nor needs a dual buffering scheme.
Assume the pixels in the image and overlay buffers are not separated into RGB com-
ponents, but rather integrated into single pixels when they are taken out of these buffers to
feed the frame. There is a certain synchronization mechanism between the image and the
overlay address counters, and also between the pixel and line counters. As soon as a pixel
is fetched from the image or overlay buffer, it is placed in the display frame with the aid
of the pixel and the line counter.
There are no write-enable controls for the buffers as these buffers will not be replenished
with new pixels once exhausted. The image is displayed only once. The read-enables for
both buffers are also kept at logic 1 until the buffers are empty. Therefore, the only
mechanism that aids the pixels out of these buffers and moves them to the display frame
is incrementing the address counters and switching the selector inputs at the 2-1 buffer
MUX. After removing the external reset, the operation of the display unit starts as shown
in the timing diagram.
7.8
Digital-to-Analog Converter (DAC)
447

Image
Overlay
Overlay
X
Y
YOF
XOF
XOL
YOL
Image
selImage, selOL
I
O
24
24
24
23
23
0
0
AddrImage
AddrOL
RESET
IncrOL
RESET
DataImage
DataOL
PixCount
LineCount
IncrPix
IncrLine
ResetPix
RESET
RESET
448
7
System Peripherals

clock
AddrImage
DataImage
AddrOL
DataOL
PixCount
LineCount
selImage
selOL
IncrPix
ResetPix
IncrLine
IncrOL
1
2
3
4
2
3
4
5
6
7
8
9
1st OL line
Last OL line
Last image 
line after OL
1st image line 
before OL
2nd image line 
before OL
6
7
8
9
3
1
3
4
1
2
3
6
7
8
9
10
5
RESET
1
OL line #1
OL line #OLY
5
10
11
11
4
2
5
3
1
2
6
4
5
1
2
6
4
5
7.8
Digital-to-Analog Converter (DAC)
449

(a) Build the register ﬁle. Indicate the programmable values in each register to support
the operation of this unit.
(b) Fill in each blank space that corresponds to the numbers in the timing diagram (if
there are no numbers, ignore the entries), and complete the control signals, selImage
(to select the image buffer), selOL (to select the overlay buffer), IncrPix (to increment
the pixel counter), ResetPix (to reset the pixel counter to 0), IncrLine (to increment
the line counter) and IncrOL (to increment the overlay counter).
Use the following notation to represent the data when retrieving them from the data
buffers:
For the Image buffer, Data = IM [Image Buffer Address]
For the Overlay buffer, Data = OL [OL Buffer Address]
10. An interrupt controller interfaced with a three-stage RISC CPU is shown below. Once
an external interrupt (INTR0 to INTR15) is generated, the interrupt interface selects the
highest priority interrupt and generates a single interrupt (INTR) bit for the Interrupt
Control Unit (ICU). The ICU acknowledges the interrupt with an interrupt acknowledge
signal (INTA), which prompts the interface to send a four-bit interrupt ID (INTRID) to
the Interrupt Address Table (IAT). A 32-bit interrupt address is then produced from the
IAT which causes the program counter (PC) to jump and execute an Interrupt Service
Routine (ISR) program in the instruction memory. Before the ISR is executed, the
remains of the original program in the CPU pipeline have to be to be executed and
stored in the register ﬁle (RF). Also, the address of the next instruction in the user
program is stored in R31 in the RF. Upon the completion of a particular ISR, the
program returns to its original location by retrieving the address stored in R31 and
executes the rest of the user program.
In this particular case, INTR0 = 1, as the highest priority interrupt, prompts the interrupt
interface to generate INTRID = 0. This is the beginning of a four instruction long ISR0
cycle that starts at the address 100 as shown in the instruction memory.
Assuming there are a total of seven instructions in the user program, each instruction
written back to the RF is labeled as WUi. For example, the results of Ins1 are written
back to the RF as WU1, the results of Ins2 as WU2 etc. as shown in the timing diagram.
Similarly, each ISR instruction written back to the RF is labeled as WIi. For example,
the results of Intr1 are written back to the RF as WI1, the results of Intr2 as WI2 etc.
Also, once the PC generates a value, each instruction produces an RF output as DUi.
For example, Ins1 produces DU1, Ins2 produces DU2 etc. Similarly, each interrupt
instruction produces an RF output as DIi. For example, Intr1 produces DI1, Intr2
produces DI2 etc.
Based on the inputs in the preceding paragraphs, ﬁll the blanks in the timing diagram
below, and indicate when each write takes place to the RF with a little arrow.
450
7
System Peripherals

Interrupt
Control Unit
RF
PC
+ 1
INTR0
INTR1
INTR15
Interrupt Interface
INTRID
INTR
INTA
Interrupt Address Table
(IAT)
DOutIAT
31
0
4
15
0
32
DInRF
R31
31
0
Intr1
Intr3
Interrupt 
Service 
Routine 0 
(ISR0)
Ins1
Instruction Memory
selPC
0
selI
selS
I
R
S
selC
PCOut
selC
selS
selI
selR
selR31
31
0
Ins2
Ins3
Ins4
Ins5
RET
1
2
3
4
5
100
C
D-Cache
A
L
U
Instruction register
1
AInRF
selR31
0
1
31
0
Intr2
101
102
103
selR
selPC
clk
clk
clk
clk
1
0
If OPC = LOAD sel 1 else sel 0
DOutRF
AInAIT
clk
User
program
7.8
Digital-to-Analog Converter (DAC)
451

11.
Design an SPI (see Chapter 4 on serial bus) interface using an integrated transmitter
and receiver shown below. The eight-bit Shift Register at the interface transmits one-bit
data from the SDO port at the negative edge of SCK, and simultaneously receives
one-bit data from the SDI port at the following positive edge. The transmit data is ﬁrst
loaded to the SPI Register using an eight-bit system bus. Subsequently, the contents of
the SPI Register are loaded to the Tx Buffer if the buffer is empty and then to the Shift
Register when it requires new data. In a similar fashion, when the Shift Register
acquires new eight new bits through its SDI port, it transfers its contents to Rx Buffer
ﬁrst and then to the SPI Register. When the transmit function is desired, the received
data is considered junk data. When the receive function is desired, the transmit data is,
in turn, assumed junk. The two ﬂags, TxF and RxF, update the SPI status register and
indicate if the TxBuffer and the RxBuffer are empty or not.
Design the SPI data-path and the controller using timing diagrams. The SCK applied to
the shift register is assumed to be a slower clock, and it has a period of eight system
clock periods. The designer should feel free to alter the design and add additional
hardware or signals when necessary to conclude a different implementation.
clk
INT0
INTR
INTA
INTRID
DOutIAT
PCOut
DInRF
AInRF
DOutRF
selI
selS
selC
selR
selPC
selR31
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
0
100
1
2
WU1
DU1
1
1
452
7
System Peripherals

Projects
1. Implement and verify the DMA in Fig. 7.7 that supports two identical 32x64 SRAM
memories using Verilog. The DMA should produce a timing diagram similar to the one
shown in Fig. 7.6 and include a controller in Fig. 7.8.
2. Implement and verify the interrupt controller in Fig. 7.15 that supports 256 hardware
interrupts using Verilog. Include the hardware for context switching, i.e. transferring the
contents of the entire register ﬁle to a temporary buffer prior to executing interrupt service
routine instructions.
3. Implement the one-shot timer in Fig. 7.24 using Verilog. Produce its timing diagram as
shown in Fig. 7.25.
SCK
Shift Register
7
0
clock
Tx Buffer
7
0
clock
Rx Buffer
7
0
SDO
SDI
clock
SPI Register
7
0
System bus
8
clock
TxF
clock
RxF
LoadRxBuf
LoadTxBuf
Shift
LoadSR
LoadSPIReg
clock
Controller
LoadRxBuf
LoadTxBuf
LoadSPIReg
LoadSR
Shift
RxMT
TxMT
SetTxF
TxEmpty
RxEmpty
ResetTxF
SetRxF
ResetRxF
SetTxF
ResetTxF
SetRxF
ResetRxF
7.8
Digital-to-Analog Converter (DAC)
453

4. Implement the rate generator in Fig. 7.26 using Verilog. Produce its timing diagram as
shown in Fig. 7.27.
5. Implement and verify the display adaptor unit in Fig. 7.34 that supports a screen with
eight pixels, two blanking lines and nine active image lines as shown in Fig. 7.35.
References
1. Microchip Technologies, dsPIC33FJ128MCX02/X04 datasheet, Timer1, pp 195–204
2. Philips TM1000 PCI media processor preliminary data book (1997) Chapter 7, pp 1–19
454
7
System Peripherals

8
Special Topics
This chapter introduces two core topics that may be part of a computing system. The ﬁrst
topic is a brief introduction to programmable logic. The second topic is the analysis of a
basic data-driven processor that operates with arrival of new data.
When it comes to prototyping an application-speciﬁc digital block, the ﬁrst thing that
comes to mind is the Field-Programmable-Gate-Array (FPGA) platform. This platform is
ﬂexible enough to implement any combinatorial, sequential or asynchronous logic with ease.
Using programmable logic, we can create mega cells such as ALU blocks or simple
memories, logic blocks that perform speciﬁc functions, processors, even a System on Chip
(SoC) platform using a Hardware Design Language (HDL).
The second topic in this chapter describes a data-driven architecture that works with a
cluster of simple processors. Each processor in the cluster is designed to carry out speciﬁc
task(s), and each becomes active when valid data arrives from a neighboring processor. In a
data-driven system, either an individual processor carries out a speciﬁc task and transfers the
result to the next processor or every processor in the cluster simultaneously execute many
different tasks all at once to produce a single result.
8.1
Field-Programmable-Gate Array
The basic idea behind the Field-Programmable-Gate-Array (FPGA) architecture is the use of
Look-Up-Tables (LUT) [1, 2]. A typical three-input LUT in Fig. 8.1 contains eight registers
to store bits, an 8-1 MUX to select one of the eight register outputs, and a ﬂip-ﬂop at the
output of the 8-1 MUX to implement sequential logic. The programming phase consists of
serially distributing the desired bit values to all eight registers through the ProgIn port when
the Prog input is set to logic 1. This is achieved by using all eight LUT registers in a shift
register conﬁguration, and shifting an eight-bit data from Bit[0] to Bit[7] at each positive
edge of the clock. The bottom register at the Bit[7] position has another output, ProgOut,
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9_8
455

1
0
D
Q
clock
Prog
Prog
Prog
Prog
Prog
Prog
Prog
Prog
1
0
D
Q
1
0
D
Q
1
0
D
Q
1
0
D
Q
1
0
D
Q
1
0
D
Q
1
0
D
Q
ProgOut
ProgIn (serial truth table entry port) 
0
clock
clock
clock
clock
clock
clock
clock
Bit[0]
Bit[1]
Bit[2]
Bit[3]
Bit[4]
Bit[5]
Bit[6]
Bit[7]
1
2
3
4
5
6
7
1
0
D
Q
clock
bypass
LUTOut
LUTIn[2]
LUTIn[0]
LUTIn[1]
Fig. 8.1 Three-input look-up-table (LUT) block diagram
456
8
Special Topics

connected to the ProgIn input of another LUT such that every LUT on the FPGA chip can be
serially programmed using a single wire to save wiring space.
In normal operation, bits stored in the LUT registers constitute the output values of the truth
table in Table 8.1. The inputs of the truth table, on the other hand, are the selectors of the 8-1
MUX, from LUTIn[0] to LUTIn[2], in Fig. 8.1. Therefore, any arbitrary truth table can be
produced simply by programming the LUT registers, needing no other conventional logic gate.
For example, when LUTIn[2] = LUTIn[1] = LUTIn[0] = 0 in Fig. 8.1, the 8-1 MUX routes
the value stored in Bit[0] to its output. Similarly, LUTIn[2] = LUTIn[1] = LUTIn[0] = 1
combination routes Bit[7] to the output. The 2-1 MUX is used to bypass the ﬂip-ﬂop output if a
combinational logic implementation is preferred.
The number of registers in a LUT is determined by the number of outputs in the truth
table. For example, if there are three inputs in the truth table, this combination generates
23 = 8 possible outputs. Therefore, the LUT must contain eight registers. In general, N
inputs require 2N registers in a LUT.
In summary, in order to implement a logic function using FPGA, the inputs of a logic
function (truth table) must be applied to the MUX selectors, and the outputs must be stored
in the LUT registers according to Table 8.1.
To demonstrate how a combinational logic block is implemented in an FPGA platform,
we will design a four-bit Ripple-Carry-Adder (RCA) as shown in Fig. 8.2. The circuit
consists of four full adders all connected serially to propagate the carry bit from right to left.
The sum outputs, from SUM0 to SUM3, and the carry-out ports, from Cout0 to Cout3, have
to be generated by programming in the LUT registers.
Figure 8.3 describes how a full adder sum output is stored in a three-input LUT. This
process is the same to generate each sum output, from SUM0 to SUM3. In this ﬁgure, the
LUT output value at the ﬁrst row (logic 0) is stored in the Bit[0] position, and the last output
entry at the last row (logic 1) is stored in the Bit[7] position. This bit arrangement in the LUT
Table 8.1 Three-input LUT truth table (when bypass port is set to 1)
LUTIn[2]
LUTIn[1]
LUTIn[0]
LUTOut
0
0
0
Bit[0]
0
0
1
Bit[1]
0
1
0
Bit[2]
0
1
1
Bit[3]
1
0
0
Bit[4]
1
0
1
Bit[5]
1
1
0
Bit[6]
1
1
1
Bit[7]
8.1
Field-Programmable-Gate Array
457

registers implements the SUM function if Cin, A and B are applied to the 8-1 MUX as
selector inputs. The bypass input at the output 2-1 MUX must also be set to logic 1 to bypass
the ﬂip-ﬂop stage since this design is not a sequential circuit.
The Cout function of the full adder is implemented similarly as shown in Fig. 8.4. The
Cout function in the last column of the truth table is programmed in the LUT registers while
Cin, A and B are applied to the 8-1 MUX as selector inputs. The bypass bit is also set to
logic 1 to bypass the ﬂip-ﬂop since the implementation is purely combinational.
Figure 8.5 shows the FPGA implementation of the four-bit RCA in Fig. 8.2 after the
programming phase is complete. In this design, each FPGA cell, called a cluster, is assumed
to contain two LUTs. While A0, A1, A2, A3, B0, B1, B2, B3 and Cin0 are external input
pins for the four-bit RCA, Cin1, Cin2 and Cin3 inputs are all internally generated from
Cout0, Cout1 and Cout2 function blocks, and routed between clusters to maintain inter-
connectivity. All the bypass inputs, from bypass-Cout0 to bypass-SUM3, have to be at logic
1 and stored in a separate LUT during programming phase.
FA0
A0
B0
SUM0
FA1
A1
B1
SUM1
FA2
A2
B2
SUM2
FA3
A3
B3
SUM3
Cin0
Cout0
Cout1
Cout2
Cout3
SUM0 = A0 + B0 + Cin0
SUM1 = A1 + B1 + Cin1
SUM2 = A2 + B2 + Cin2
SUM3 = A3 + B3 + Cin3
Cout0 = A0.B0 + Cin0.(A0 + B0)
Cout1 = A1.B1 + Cin1.(A1 + B1)
Cout2 = A2.B2 + Cin2.(A2 + B2)
Cout3 = A3.B3 + Cin3.(A3 + B3)
Fig. 8.2 Four-bit ripple-carry-adder
458
8
Special Topics

LUTIn[2] = Cin
LUTOut[0] = SUM
0
0
0
0
0
1
0
1
0
0
1
1
1
0
0
1
0
1
1
1
0
1
1
1
LUTIn[1] = A
LUTIn[0] = B
0
1
1
0
1
0
0
1
0
Bit[0]
1
Bit[1]
1
Bit[2]
0
Bit[3]
1
Bit[4]
0
Bit[5]
0
Bit[6]
1
Bit[7]
0
1
2
3
4
5
6
7
LUTIn[0] = B
LUTIn[1] = A
LUTIn[2] = Cin
1
0
D
Q
clock
bypass = 1
LUTOut[0] = SUM
ProgIn
ProgOut
Feed the truth table output into the LUT
Fig. 8.3 Programming the full adder SUM output with a three-input LUT
8.1
Field-Programmable-Gate Array
459

LUTIn[2] = Cin
LUTOut[1] = Cout
0
0
0
0
0
1
0
1
0
0
1
1
1
0
0
1
0
1
1
1
0
1
1
1
LUTIn[1] = A
LUTIn[0] = B
0
0
0
1
0
1
1
1
0
Bit[0]
0
Bit[1]
0
Bit[2]
1
Bit[3]
0
Bit[4]
1
Bit[5]
1
Bit[6]
1
Bit[7]
0
1
2
3
4
5
6
7
LUTIn[0] = B
LUTIn[1] = A
LUTIn[2] = Cin
1
0
D
Q
clock
bypass = 1
LUTOut[1] = Cout
ProgIn
ProgOut
Feed the truth table output into the LUT
Fig. 8.4 Programming the full adder Cout output with a three-input LUT
460
8
Special Topics

1
0
clock
D
Q
bypass-SUM0 = 1
SUM0
Bit[0]
Bit[7]
A0 B0 Cin0
S0 - LUT
1
0
clock
D
Q
bypass-Cout0 = 1
Cout0
Bit[0]
Bit[7]
A0 B0 Cin0
Cout0 - LUT
1
0
clock
D
Q
bypass-SUM1 = 1
SUM1
Bit[0]
Bit[7]
A1 B1
Cin1
S1 - LUT
1
0
clock
D
Q
bypass-Cout1 = 1
Cout1
Bit[0]
Bit[7]
A1 B1
Cin1
Cout1 - LUT
1
0
clock
D
Q
bypass-SUM2 = 1
SUM2
Bit[0]
Bit[7]
A2 B2
Cin2
S2 - LUT
1
0
clock
D
Q
bypass-Cout2 = 1
Cout2
Bit[0]
Bit[7]
A2 B2
Cin2
Cout2 - LUT
1
0
clock
D
Q
bypass-SUM3 = 1
SUM3
Bit[0]
Bit[7]
A3 B3
Cin3
S3 - LUT
1
0
clock
D
Q
bypass-Cout3 = 1
Cout3
Bit[0]
Bit[7]
A3 B3
Cin3
Cout3 - LUT
Cluster 0
Cluster 1
Cluster 2
Cluster 3
Fig. 8.5 Four-bit ripple-carry-adder data-path in FPGA
8.1
Field-Programmable-Gate Array
461

A commercial FPGA cluster contains a multitude of multiplexers connected to the LUT
inputs to accomplish the maximum ﬂexibility in logic conﬁguration [3]. Figure 8.6 shows
one such cluster conﬁguration that contains two LUTs, each with three inputs. A cluster
conﬁgured this way is able to achieve maximum networking capability with other clusters in
addition to implementing many types of combinational and sequential logic circuits. Pro-
gramming these LUTs is achieved simply by connecting the ProgOut port of one LUT to the
ProgIn port of the neighboring LUT, and feeding the serial data from the ProgIn port as
shown in the ﬁgure.
ProgIn
LUTIn2
LUTIn1
LUTIn0
LUTIn2
LUTIn1
LUTIn0
Out[1]
Out[0]
bypass1
bypass0
In0[0]
In0[1]
In0[2]
In1[0]
In1[1]
In1[2]
LUT 1
LUT 0
ProgOut
Fig. 8.6 A commercial FPGA cluster containing two LUTs per cluster
462
8
Special Topics

The detailed schematic in Fig. 8.7 shows the FPGA implementation of Cluster 0 in
Fig. 8.5 but uses a commercial FPGA architecture in Fig. 8.6. Each 3-1 MUX selector input
from SelOut0[0] to SelOut1[5] is stored in a 12-bit shift register (LUT2) in Fig. 8.7.
1
0
clock
D
Q
bypass1 = 1
Out1 = SUM0
Bit[0]
Bit[7]
A0
B0
Cin0
LUT1 (for SUM0)
in1[2] = Cin0
in1[1] = B0
in1[0] = A0
1
0
clock
D
Q
Out0 = Cout0
Bit[0]
Bit[7]
A0
B0
Cin0
LUT0 (for Cout0)
in0[2] = Cin0
in0[1] = B0
in0[0] = A0
ProgIn
ProgOut
ProgIn
ProgOut
SelOut1[5] = 0
SelOut0[5] = 0
SelOut1[4] = 0
SelOut0[4] = 0
SelOut1[3] = 0
SelOut0[3] = 0
SelOut1[2] = 0
SelOut0[2] = 0
SelOut1[1] = 0
SelOut0[1] = 0
SelOut1[0] = 0
SelOut0[0] = 0
bypass0 = 1
SelOut1 [5]
LUT2 (for SelOut)
SelOut0 [0]
12 SelOut inputs
bypass1
LUT3 (for bypass)
ProgIn
ProgOut
ProgOut
ProgIn
bypass0
1
0
2
1
0
2
1
0
2
1
0
2
1
0
2
1
0
2
Fig. 8.7 Implementing SUM0 and Cout0 using a single cluster containing two LUTs
8.1
Field-Programmable-Gate Array
463

In this ﬁgure, SelOut1[i] = 0 and SelOut0[i] = 1 combination selects port 1 of the
3-1MUX where i changes from 0 to 5. Similarly, SelOut1[i] = 1 and SelOut0[i] = 0
combination selects port 2. When SelOut1[i] = SelOut0[i] = 0, the default port 0 is selected,
and an external input becomes one of the selector inputs for the 8-1 LUT MUX. The bypass
pins, bypass0 and bypass1, are also stored in a two-bit shift register (LUT3).
A Moore or Mealy type state machine can also be implemented using an FPGA platforms.
The state diagram in Fig. 8.8 produces the transition table in Table 8.2, which includes two
next state outputs, NS0 and NS1, two present state inputs, PS0 and PS1, an external input,
IN, and a present state output, OUT[2:0], to produce integer values between one and four.
For state assignments only one bit is allowed to change between neighboring states, i.e.
S0 = 00, S1 = 01, S2 = 11 and S3 = 10. The resultant circuit in Fig. 8.9 shows the locations
of the present and next states, the input and the output.
S0
S1
S2
S3
IN = 0
IN = 1
IN = 1
IN = 1
IN = 0
IN = 0
IN = 0
IN = 1
OUT = 1
OUT = 2
OUT = 4
OUT = 3
Fig. 8.8 A Moore machine
Programming the NS0 function in Table 8.2 in a three-input LUT conﬁguration is
explained in Fig. 8.10. In this ﬁgure, the NS0 column is distributed among eight LUT
registers, storing the ﬁrst bit of NS0 in a LUT register at the Bit[0] position, and the last bit
of NS0 in a register at the Bit[7] position. The inputs, PS0, PS1 and IN, that generate NS0
are connected to the 8-1 MUX selector pins, LUTIn[0], LUTIn[1] and LUTIn[2], respec-
tively. Since the bypass input pin is set to logic 0, the NS0 node becomes the input of the
ﬂip-ﬂop, and the PS0 node becomes the output.
464
8
Special Topics

IN
NS1
NS0
PS0
PS1
OUT[2]
D
Q
OUT[1]
OUT[0]
D
Q
clock
clock
Fig. 8.9 The circuit diagram for the Moore machine in Fig. 8.8
Table 8.2 The transition table for the Moore machine in Fig. 8.8
PS0
PS1
0
1
0
1
0
0
1
1
IN
0
0
0
0
NS0
NS1
OUT[0]
OUT[1]
OUT[2]
0
1
0
1
0
0
1
1
1
1
1
1
0
1
0
1
1
1
1
0
0
0
1
1
0
1
0
1
1
0
0
1
1
0
0
1
0
1
0
1
0
1
0
1
0
0
1
0
0
0
1
0
8.1
Field-Programmable-Gate Array
465

0
Bit[0]
1
Bit[1]
0
Bit[2]
1
Bit[3]
1
Bit[4]
1
Bit[5]
1
Bit[6]
0
Bit[7]
0
1
2
3
4
5
6
7
LUTIn[0] = PS0
LUTIn[1] = PS1
LUTIn[2] = IN
1
0
D
Q
clock
bypass = 0
PS0
ProgIn
ProgOut
Feed the truth table output into the LUT
PS0
PS1
0
1
0
1
0
0
1
1
IN
0
0
0
0
NS0
0
1
0
1
0
0
1
1
1
1
1
1
0
1
0
1
1
1
1
0
NS0
NS0
PS0
Fig. 8.10 Programming the PS0/NS0 output with a three-input LUT
466
8
Special Topics

The NS1 functionality is implemented in a similar fashion as shown in Fig. 8.11. The
NS1 column in Table 8.2 is stored in the LUT registers. PS0, PS1 and IN inputs are
connected to LUTIn[0], LUTIn[1] and LUTIn[2] MUX selector pins, respectively. The
bypass pin is set to logic 0 in order to form NS1 node at the input of the ﬂip-ﬂop and PS1
node at the output.
00
Bit
Bit[[00]]
0
Bit
Bit[[11]
11
Bit
Bit[[22]]
11
Bit
Bit[[33]]
0
Bit
Bit[[44]
1
Bit
Bit[[55]]
00
Bit
Bit[[66]]
11
Bit
Bit[[77]]
00
1
22
33
4
5
66
77
LUTIn
LUTIn[0] = 
] = PS
PS00
LUTIn
LUTIn[[11] = 
] = PS
PS11
LUTIn
LUTIn[[22] = 
] = IN
IN
11
00
DD
QQ
clock
clock
bypass 
bypass = 
= 00
PS
PS11
ProgIn
ProgIn
ProgOut
ProgOut
Feed the truth table output into the LUT
Feed the truth table output into the LUT
PS
PS00
PS
PS11
00
1
00
1
00
0
1
11
IN
IN
0
0
0
0
NS
NS11
00
1
00
1
00
0
1
11
1
1
1
1
00
0
11
11
00
1
00
11
NS
NS11
NS
NS11
PS
PS11
Fig. 8.11 Programming the PS1/NS1 output with a three-input LUT
8.1
Field-Programmable-Gate Array
467

The OUT[0], OUT[1] and OUT[2] outputs are also programmed in the LUT registers
according to Table 8.2, and shown in Figs. 8.12, 8.13 and 8.14, respectively. However, the
bypass input in each case must be set to logic 1 in order to bypass the ﬂip-ﬂop stage since
these outputs are completely combinational and do not require any clock in their paths.
1
Bit[0]
0
Bit[1]
0
Bit[2]
1
Bit[3]
1
Bit[4]
0
Bit[5]
0
Bit[6]
1
Bit[7]
0
1
2
3
4
5
6
7
LUTIn[0] = PS0
LUTIn[1] = PS1
LUTIn[2] = IN
1
0
D
Q
clock
bypass = 1
OUT[0]
ProgIn
ProgOut
Feed the truth table output into the LUT
PS0
PS1
0
1
0
1
0
0
1
1
IN
0
0
0
0
OUT[0]
0
1
0
1
0
0
1
1
1
1
1
1
1
0
0
1
1
0
0
1
OUT[0]
OUT[0]
Fig. 8.12 Programming the OUT[0] output with a three-input LUT
468
8
Special Topics

0
Bit[0]
1
Bit[1]
0
Bit[2]
1
Bit[3]
0
Bit[4]
1
Bit[5]
0
Bit[6]
1
Bit[7]
0
1
2
3
4
5
6
7
LUTIn[0] = PS0
LUTIn[1] = PS1
LUTIn[2] = IN
1
0
D
Q
clock
bypass = 1
OUT[1]
ProgIn
ProgOut
Feed the truth table output into the LUT
PS0
PS1
0
1
0
1
0
0
1
1
IN
0
0
0
0
OUT[1]
0
1
0
1
0
0
1
1
1
1
1
1
0
1
0
1
0
1
0
1
OUT[1]
OUT[1]
Fig. 8.13 Programming the OUT[1] output with a three-input LUT
8.1
Field-Programmable-Gate Array
469

0
Bit[0]
0
Bit[1]
1
Bit[2]
0
Bit[3]
0
Bit[4]
0
Bit[5]
1
Bit[6]
0
Bit[7]
0
1
2
3
4
5
6
7
LUTIn[0] = PS0
LUTIn[1] = PS1
LUTIn[2] = IN
1
0
D
Q
clock
bypass = 1
OUT[2]
ProgIn
ProgOut
Feed the truth table output into the LUT
PS0
PS1
0
1
0
1
0
0
1
1
IN
0
0
0
0
OUT[2]
0
1
0
1
0
0
1
1
1
1
1
1
0
0
1
0
0
0
1
0
OUT[2]
OUT[2]
Fig. 8.14 Programming the OUT[2] output with a three-input LUT
470
8
Special Topics

Figure 8.15 describes the implementation of the Moore machine in Fig. 8.9 after pro-
gramming each LUT in three different clusters. Cluster 0 generates NS0 and NS1 functions
implicitly but also produces PS0 and PS1 outputs. Cluster 1 and Cluster 2 implement OUT
[2:0]. The IN port is the only external input that goes to all three clusters to maintain the
logic functionality. All the bypass inputs from bypass-PS0 to bypass-OUT2 are stored in a
separate LUT.
The schematic in Fig. 8.16 shows the implementation of Cluster 0 in Fig. 8.15 in a
commercial FPGA platform in Fig. 8.6. In this schematic, all 3-1 MUX selector inputs from
SelOut0[0] to SelOut1[5], are stored in LUT2. Similarly, the bypass inputs, bypass0 and
bypass1, are stored in LUT3 to be used during normal operation.
1
0
clock
D
Q
bypass-PS0 = 0
PS0
Bit[0]
Bit[7]
IN
PS0 - LUT
Cluster 0
Cluster 1
Cluster 2
NS0
1
0
clock
D
Q
bypass-PS1 = 0
PS1
Bit[0]
Bit[7]
IN
PS1 - LUT
NS1
1
0
clock
D
Q
bypass-OUT0 = 1
OUT[0]
Bit[0]
Bit[7]
PS0
PS1
IN
OUT0 - LUT
1
0
clock
D
Q
bypass-OUT1 = 1
Bit[0]
Bit[7]
IN
OUT1 - LUT
1
0
clock
D
Q
bypass-OUT2 = 1
Bit[0]
Bit[7]
IN
OUT2 - LUT
PS0
PS1
PS0
PS1
PS0
PS1
PS0
PS1
OUT[1]
OUT[2]
Fig. 8.15 Moore state machine data-path in FPGA
8.1
Field-Programmable-Gate Array
471

1
0
clock
D
Q
bypass1 = 0
Out1 = PS1
Bit[0]
Bit[7]
PS0
PS1
IN
LUT1 (for PS1)
In1[2] = IN
SelOut1[5] = 0
SelOut0[5] = 0
In1[1] = dont care
In1[0] = dont care
SelOut1[4] = 1
SelOut0[4] = 0
SelOut1[3] = 0
SelOut0[3] = 1
1
0
clock
D
Q
bypass0 = 0
Out0 = PS0
Bit[0]
Bit[7]
LUT0 (for PS0)
In0[2] = IN
In0[1] = dont care
In0[0] = dont care
SelOut1[5]
LUT2 (for SelOut)
SelOut0[0]
12 SelOut inputs
bypass1
LUT3 (for bypass)
ProgIn
ProgOut
ProgOut
ProgIn
ProgOut
ProgIn
ProgOut
ProgIn
bypass0
PS0
PS1
IN
NS1
NS0
2
1
0
2
1
0
2
1
0
2
1
0
2
1
0
2
1
0
SelOut1[2] = 0
SelOut0[2] = 0
SelOut1[1] = 1
SelOut0[1] = 0
SelOut1[0] = 0
SelOut0[0] = 1
Fig. 8.16 Implementing PS0 and PS1 using a single cluster containing two LUTs
472
8
Special Topics

8.2
Data-Driven Processors
Data-Flow Graphs
Programming data-driven processors is achieved by data-ﬂow graphs [4]. Each graph con-
sists of a group of functional nodes and communication paths, connecting the nodes. Each
node in the ﬂow-graph executes two incoming data tokens. When they arrive, the node
produces an output operand according to the function deﬁned in the node. Therefore, a node
function can simply be deﬁned by an instruction. Each instruction representing a functional
node contains an operation code (OPC), input operand(s) (OPER), and output operand node
addresses. All input-output paths among functional nodes are connected with directed
communication paths to guide the ﬂow of data. With this picture in mind, operands that ﬂow
into a functional node are executed according to the node’s operation code. Once executed in
the node, new operands form and ﬂow out of the node to other nodes. A simple example is
given in Fig. 8.17. In this example, the operands, OPERS1 and OPERS2, are executed by the
node’s operation code, OPCS, when they arrive at the functional node, NS. After the exe-
cution, new operands form and ﬂow out of the node to two new destination nodes, ND0 and
ND1, where they meet with two other operands, OPERD0 and OPERD1, respectively. The
data-ﬂow program stops when all operands are executed.
The parallel nature of data-ﬂow architecture makes parallel processing tasks quite achievable
in data-driven machines. While conventional processors are set to be maximally serial to
minimize hardware, data-driven architectures can be maximally parallel with up to one
L
R
NS
OPERS1
OPERS2
OPCS
L
R
ND0
OPCD0
OPCD1
ND1
L
R
OPERD0
OPERD1
to (NK,L)
to (NL,R)
Fig. 8.17 Sample ﬂow graph for a data-driven machine
8.2
Data-Driven Processors
473

processor per operation to maximize performance. For the example in Fig. 8.17, two dif-
ferent data-driven processors can be used simultaneously to perform OPCD0 and OPCD1
following the operation at the node NS. Multi-processor platforms formed by a group of
conventional processors may have limitations to achieve certain parallel processing tasks. In
contrast, data-driven processors can time-share the processing load of several functional
nodes, and therefore reduce the hardware requirement to implement a data-ﬂow graph.
Data-Flow Node Types
The types of data-ﬂow nodes used in this architecture are classiﬁed according to the number
of input operands fed into the functional nodes. Figure 8.18 illustrates this classiﬁcation.
Functional nodes that accept no inputs are nodes with constants (CONS). The contents of
this node type do not change during programming. Functional nodes that accept one input
are the unitary (UNIT) nodes. This node type transforms an operand as soon as it arrives at
its input. Invert (negate), Set and Reset are the unitary nodes in this architecture that require a
single input operand. Functional nodes that accept two input operands are the combinatorial
(COMB) nodes. This node type executes incoming operands when they are both valid at the
input. The operation of some combinatorial functional nodes, such as subtract and shift,
depends on the relative placement of the input operands. This is called the operand polarity.
It is reﬂected in the instruction format by deﬁning input operands as left or right input
operands. In this architecture, operands with changing data values are directed to the left side
of a functional node, whereas constant operands or operands used as control signals are
placed on the right side of the functional node in a data-ﬂow diagram.
While operands emanating from functional nodes are forwarded only to one destination
address in the earlier data-ﬂow diagrams, this architecture offers the ﬂexibility where the
same operand can be forwarded to two different destination addresses. This unique feature
saves the number of nodes used in the data-ﬂow diagram as well as increases execution
speed of the program.
L
R
OPER1
OPER2
COMB
OPEROUT
L
OPER1
UNIT
OPEROUT
CONS
OPEROUT
Fig. 8.18 Functional node types
474
8
Special Topics

Basic Data-Flow Program Structures
There are three basic programming structures in data-driven architectures when constructing
data-ﬂow diagrams: sequential, conditional and recursive. Each structure is illustrated in
Fig. 8.19.
Sequential programming constructs imply that data-ﬂow is unidirectional, from one func-
tional node to the next without any loops or paths related to a condition. The simple data-ﬂow
diagram in Fig. 8.17 is one such example of the sequential programming structure. Another
example composed of multi-layer functional nodes is given in the top ﬁgure of Fig. 8.19.
The conditional programming structure consists of a functional node that accepts a con-
ditional input besides a data input. If the condition is satisﬁed, a valid operand at the data input
becomes a valid operand at the output. If the condition is not satisﬁed, the operand at the
output retains its old value. The conditional input enters the node from the right side since it is
considered to be a control input as mentioned earlier. Gate and Compare instructions are
considered conditional since the data-ﬂow produced at the output of the node depends on
whether the condition is satisﬁed or not. The output operand does not change its value until
the condition is satisﬁed. An example of this type is shown in the middle ﬁgure of Fig. 8.19.
The recursive programming structure contains looping constructs in the form of a feedback
path from one node to another as shown in the bottom ﬁgure of Fig. 8.19. The number of
iterations in a loop continues until all input operands are exhausted. The loop can be broken to
allow a conditional node if needed, otherwise the loop is activated on the arrival of new
operands either from the right side or from the left side of the node.
A simple example in Fig. 8.20 combines all the programming structures mentioned
above. This example calculates the area under a straight line, Y = (X −1), from X = 2 to
X = 3. The increment in the x-axis is deﬁned to be DeltaX, which is equal to 0.1 in the ﬂow
chart.
The ﬂow chart in Fig. 8.20 has been transformed into a data-ﬂow graph shown in
Fig. 8.21. All the nodes with constants in the data-ﬂow graph in Fig. 8.21 are zero-input
nodes, which accept no operands. The only unitary functional node is the one with the SET
operation code. Upon the arrival of an operand to its single input, this node generates logic 1
at its output. Otherwise, its output stays at logic 0.
There are two types of two-input functional nodes in the same data-ﬂow diagram. The
majority of these nodes are conditional type: they either wait for a condition to arrive
(GATE) or they have a permanent condition attached at their right port in terms of a
constant. Greater-Than-Or-Equal-To (GE), Less-Than (LT), Add-with-Constant (ADC), and
Multiply-with-Constant (MULC) functional nodes belong to the latter category.
The rest of the two-input nodes are sequential such as Add node (ADD) where polarity
information is not important for data execution.
8.2
Data-Driven Processors
475

L
R
N1
OPER1
OPER2
OPC1
L
R
N2
OPC2
OPC3
N3
L
OPER3
OPC4
L
R
N4
OPER4
L
R
N1
OPER1
OPER2
OPC
COMP
CONS
N2
N3
L
R
GATE
L
R
N4
OPC
GATE
N2
N3
CONS
L
R
start
N1
L
True
/False
OPER3
Sequential-Type
Data Flow Graph
Conditional-Type
Data Flow Graph
Recursive-Type
Data Flow Graph
Fig. 8.19 Data-ﬂow programming structures
476
8
Special Topics

During the programming phase, the initial values of Xstart, Ystart and SUMstart are
stored at the proper arcs in Fig. 8.21. When program execution starts, Xstart = 2 is added to
a ﬂoating-point constant, C = 0.1, at the nodes 0 and 1, generating the ﬁrst value of X.
While X is compared against C = 3 at the nodes 3 and 4, it is also directed to the node 2 for a
Gate operation, and added to C = −1 at the node 5, producing Y. Subsequently, Y is directed
to the node 6 to be added to Ystart = 1, and to the node 7 for another Gate operation. The
output of the node 6 multiplies with C = 0.05 at the node 8, producing the ﬁrst incremental
area value, and it is directed to the node 9 to be added with SUMstart = 0. The output of the
node 9, SUM, is then forwarded to the nodes 10 and 11 for two other Gate operations.
Depending on comparisons at the nodes 3 and 4, the SUM output will either be forwarded
outside of the processor or forwarded to the node 12 in order to set this node. If the node is
set, Gate operations at the nodes 2, 7 and 11 take place, replacing the old values of Xstart,
Ystart and SUMstart with X, Y and SUM, respectively. Iterations continue until the node 10
becomes active and the result is delivered to the user.
X : 3
SUMstart = 0
Xstart = 2
Ystart = 1
DeltaX = 0.1
SUMstart = SUM
Xstart = X
Ystart = Y
X = Xstart + DeltaX
Y = X - 1
Area = 0.05 (Y + Ystart)
SUM = SUMstart + Area
SUM to host
X  <  3 
else
Fig. 8.20 Flow chart integrating the area under Y = (X −1)
8.2
Data-Driven Processors
477

Input Flags
An input operand to a functional node contains an operand ﬂag to indicate whether or not the
data processing is complete. A high ﬂag implies that the input operand is valid and ready to
be processed. The input operand ﬂag goes to logic 0 as soon as the functional node processes
the input operand.
ADC
C = 0.1
C = 0.05
C = 3
C = 3
C = -1
ADC
ADD
GATE
LT
ADC
ADD
GATE
MULC
SET
GE
GATE
GATE
R
Xstart
X
SUMstart
Ystart
Y
SUM
R
R
X
X
X
SUM
to host
Area
#1
#2
#3
#4
#5
#6
#7
#8
#9
#11
#12
#10
L
L
L
L
L
L
L
R
R
R
R
R
R
L
L
L
L
R
R
L
L
R
#0
C = 0.1
Xstart
Y
Fig. 8.21 Data-ﬂow graph integrating the area under Y = (X −1)
478
8
Special Topics

Nodal Networks
Data-ﬂow diagrams in this architecture can be structured in three different ways. The ﬁrst is a
direct connection among functional nodes: data ﬂows from one node to another freely in an
unobstructed fashion as shown at the top left corner of Fig. 8.22. The only control mech-
anism for processing data at each functional node is that both input operand ﬂags must be at
logic 1. The second and the third nodal networks use programmable routers to send operands
from the source to the destination nodes. The simple router at the top right corner of
Fig. 8.22 uses a local network to connect a group of functional nodes and thereby creates a
cluster. Note that the inputs to a functional node in a cluster can come from any functional
node in this network. This decision is made by a simple arbitration scheme in the router,
which dictates that any node in the process of generating a new input operand for itself has
priority over the other nodes in a cluster. In other words, if a neighboring node produces an
input operand for a particular node in a cluster while this particular node is in the process of
generating an input operand for itself, the arbiter stalls any data processing in the neigh-
boring node until the self-operand generation is complete. The bottom structure in Fig. 8.22
L
R
NA
OPERA
OPERB
OPCA
L
R
NB
OPCB
OPCC
NC
L
OPERC
OPCD
R
ND
L
N A
OPCA
NZ
OPCZ
LOCAL CLUSTER NETWORK
L
R
L
R
INTER-CLUSTER NETWORK
OPCA
N Z
N A
OPCZ
LOCAL CLUSTER NETWORK 1  
N A
OPCA
N Z
OPCZ
L
R
L
R
L
R
L
R
LOCAL CLUSTER NETWORK  N
Fig. 8.22 Data-ﬂow graphs without router, and with local and hierarchical cluster networks
8.2
Data-Driven Processors
479

illustrates the hierarchical organization of clusters where an inter-cluster network manages
many local cluster networks. While each cluster arbiter manages its own individual cluster,
all cluster-to-cluster communication is maintained by a separate inter-cluster arbiter.
Processor Design Overview
The processor implements the node functionality by reading the node instruction from the
memory, executing it, and writing the result back to the two destination node addresses
speciﬁed in the instruction. In order to implement this sequence, each processor needs to
have a memory, an ALU and a controller. The memory contains all nodal instructions. Each
nodal instruction consists of two input operands with their valid ﬂags, an operation code and
the two destination node addresses where the results are sent as shown in Fig. 8.23.
Consider a processor implementing a single node. Initially, assume the processor is at
idle. When both operand ﬂags in the instruction become valid, the controller starts. In the
ﬁrst step, the controller generates a nodal address for the instruction that resides in the
memory. In the second step, the controller fetches the input operands and operation code
from this instruction and forwards them to the ALU. The ALU combines the input operands
and generates an output operand, which is directed to the ﬁrst destination address. In the
third step, the controller writes the same output operand to the second destination address,
sets the operand ﬂag at the ﬁrst destination address, and clears input operand ﬂags at the
source address. In the fourth and ﬁnal step, the controller sets the operand ﬂag at the second
destination address.
If the processor needs to execute more than one node, then each nodal address in the ﬂow
graph must be mapped to a physical address in the memory. This approach automatically
transfers the left and the right nodal operands, the operation code and the destination
addresses of a particular node from the ﬂow graph to an instruction in the memory. However,
during this process each operand ﬂag is stored in a separate tag memory to allow the
controller to continuously search for valid operand ﬂags. If the controller ﬁnds a node with
valid left and right operand ﬂags, it sends the corresponding operands to the ALU for
execution. After the operands are processed and sent to the destination addresses in the
instruction, the controller points the next node to be processed. If there is no other node with
OPC
V0
N0
P0
FR
OPERR
V1
N1
P1
Destination
Address 0
Destination
Address 1
FL
OPERL
Left 
Operand 
Flag
Right 
Operand 
Flag
17
17
1
1
5
1
6
1
1
6
1
Fig. 8.23 Instruction format
480
8
Special Topics

valid operand ﬂags, the controller stalls the processor until an instruction with valid operand
ﬂags emerges in the instruction memory.
The processing efﬁciency and speed in the processor can be increased by pipelining. After
an instruction is executed, sending the ALU result to a destination address can be overlapped
with tasks such as generating an address or fetching a different instruction. This can be
achieved using a dual port memory.
Instruction Format
In this architecture, the instruction format contains two 17-bit input operands, OPERL and
OPERR, two ﬂags to validate the operands, FL and FR, one ﬁve-bit operation code, OPC, and
two eight-bit destination address ﬁelds. Each destination address is composed of a valid bit,
V, a six-bit node number, N, and a left-right polarity bit, P. The valid bits in the destination
address ﬁelds, V0 and V1 indicate the validity of the corresponding nodal address. This
instruction format is shown in Fig. 8.23.
Architecture and Operation
Figure 8.24 shows a simpliﬁed block diagram of a processor executing the simple program
in Fig. 8.17. Each node number in the data-ﬂow graph in Fig. 8.17 corresponds to an address
in the instruction memory in Fig. 8.24.
The program execution starts when the controller detects an instruction with valid left and
right operand ﬂags, such as the one at the memory location NS with FL = FR = 1. The controller
reads out the instruction and sends the operands, OPERS1 and OPERS2, and the operation code,
OPCS, to the ALU. The ALU executes the operands according to the OPCS, and the controller
clears both operand ﬂags of the instruction, underlining the completion of this instruction. The
controller subsequently sends the ALU result to the ﬁrst and second destination addresses, ND0
and ND1, as data tokens as shown in Fig. 8.24. When the result is delivered to a valid destination
address, the controller automatically sets the operand ﬂag to specify the validity of data for
further processing. For example, the right operand ﬂag at ND0 is set when OPERA = OPERS1
(OPCS) OPERS2 is delivered to this address. Similarly, the controller sets the left operand ﬂag at
ND1 when it delivers the same ALU result to this address in the next cycle.
After executing the instruction at NS, the controller detects the next instruction with valid
operand ﬂags at the memory location ND0. Once again, the controller extracts the operation
code, OPCD0, and the operands, OPERD0 and OPERA, from the instruction and sends them
to the ALU for execution. Subsequently, the controller clears the operand ﬂags at ND0 and
sends the ALU result as a left operand to the memory address NK. This is shown as the third
data token in Fig. 8.24. The controller performs the same set of tasks for the instruction
located at the address ND1 and forms the fourth data token. The program execution stops
when the controller can no longer ﬁnd a pair of valid operand ﬂags in the tag memory.
8.2
Data-Driven Processors
481

Implementation
Figure 8.25 shows the implemented instruction ﬁeld format. Besides the operation code and
the input operand ﬁelds, each destination address in Fig. 8.23 is now expanded to contain an
additional seven-bit processor ID, ProcID, and a cluster ID, ClusID, to allow multiple
processor communication in a local network. In this architecture, we have the ﬂexibility of
choosing a network ranging from 128 processors in a single cluster to two processors per
cluster for 64 different clusters. The presence of ClusID and ProcID enables independent but
simultaneous networking activities to take place among clusters and processors. In other
ClusID0
ProcID0
OPC
V0
N0
OPERR
OPERL
FR
FL
P0
ClusID1
ProcID1
V1
N1
P1
17
17
1
1
5
7
1
6
1
7
1
6
1
Fig. 8.25 Instruction format in the implementation
OPC
RDataRIGHT
1st token
2nd token
3rd token
4th token
NS
ND0
OPCS
1 ND0
R
OPERS1
1
OPERS2
1
ND1
L
1
OPCD0
1
NK
L
OPERD0
0
-
0
-
-
1
OPCD1
1
NL
R
-
1
OPERD1
0
-
-
0
ND1
ALU
ND0
R
OPERS1 (OPCS ) OPERS2 = OPERA
ND1
L
OPERA
NK
L
OPERD0 (OPCD0) OPERA 
NL
R
V0
V1
FL
FR
WData
RDataLEFT
OPERD1 (OPCD1) OPERA 
Fig. 8.24 Processor architecture executing the program in Fig. 8.17
482
8
Special Topics

words, the source processor can write the same ALU result to two different destination
processors within the same cluster or in different clusters.
Processor Micro-architecture
The simpliﬁed data-driven processor architecture shown in Fig. 8.24 is implemented in
Fig. 8.26. One of the essential elements in Fig. 8.26 is the presence of a dual-port RAM.
While the controller fetches an instruction from the ﬁrst data port, it writes the ALU result of
another instruction to the second port to increase processor performance and programming
efﬁciency.
In this architecture, all operand ﬂags are stored in a separate tag memory in the processor.
The left and right operand ﬂags at each tag address are AND-gated and connected to the
node address generator as inputs. When the operand ﬂags that belong to a speciﬁc tag
memory address become valid, the address generator uses this tag address as a read address,
RAddress, to read the corresponding instruction from the dual-port RAM. If there is more
than one set of valid ﬂags in the tag memory, the node address generator selects a pair of
ﬂags with the lowest nodal address value, and delivers this address to the memory. When
there are no more valid ﬂags, the address generator produces a NoSelect signal for the
TAG 
MEMORY
NODE
ADDRESS
GENERATOR
APort1
APort2
DPort1
DPort2
DUAL-PORT
SRAM
ALU
(NS, PS)
(VD, ND, PD)
WAddr0
WAddr1
RData
WAddress
[native]
WAddr
[from others]
Out 
[native]
Out
 [from others]
NoSelect
[to the arbiter]
FL(0)
WAddr
RAddress
psel
OPC
hold
hold
NODE
RETAINER
FR(0)
FL(N)
psel
WData
WAddress
hold
Out
Source Address
Destination Address
OPERAND
RETAINER
WRITE ADDRESS
REGISTER
RDataRIGHT
RDataLEFT
Node
 No
Select Address
ALU REGISTER
FR(N)
Fig. 8.26 Processor data-path and micro-architecture
8.2
Data-Driven Processors
483

network arbiter which, in turn, stalls the processor. From this moment on, the processor
suspends all its activity and waits for new operands to be delivered to the instruction
memory.
When a processor interacts with other processors in a network, it is quite possible that it
may receive a hold request from the network arbiter while attempting to write into a
neighboring processor. This hold signal is generated because the neighboring processor may
be busy processing data for itself or writing data to another processor as mentioned earlier.
When the source processor receives a hold signal, it stalls all its processing functions and
retains its internal status and output data values until the hold is removed. Therefore,
RAddress is also stored in the node retainer to preserve the node address, NS, and the source
operand polarity, PS, for the tag memory in case the network arbiter issues a hold.
Once the instruction at RAddress is read from the RData port of the dual-port memory, its
right and left operands are routed to the ALU along with the operation code for execution.
The source operands are also stored in the operand retainer in case the program execution is
put on a momentary hold by the network arbiter. Both of the destination addresses, WAddr0
and WAddr1, are buffered in the write address register and used alternately to deliver the
processed data from the Out terminal to destination processors. The write address register
also keeps the old write addresses for the duration of hold.
The processed data either produced locally or from other processors in a network is
eventually written to the dual-port RAM through the WData port. The destination address at
the WAddress port simply accompanies the newly arrived data, and it is directed to the tag
memory to update the corresponding operand ﬂags.
Processor Programming
Prior to the program execution, instructions are loaded to the dual-port RAM through the
WData port in Fig. 8.26. While the program is loaded to the memory, operand ﬂags of each
instruction are also stored in the tag memory.
Inter-processor Arbiter and Router
In a data-driven architecture, the organization of processors in a network is hierarchical.
A group of processors form a local cluster, in which each individual processor owns a pro-
cessor ID, ProcID, to communicate with other processors using a simple arbitration protocol.
A local cluster has also an identiﬁcation number, ClusID, in a network. Only one pro-
cessor in a cluster can communicate with another processor in a different cluster at a given
time.
The inter-processor router connects each processor’s destination address and data output
to other processors address and data ports with a massive multiplexing network as shown in
Fig. 8.27. The arbiter is designed to give address and data transfer privileges to a single
processor while issuing a hold to all lower-priority processors in a cluster. There are two
general rules observed in the arbiter’s priority scheme. The ﬁrst rule states that if a processor
484
8
Special Topics

issues a write to itself, it has the highest priority over the other processors in a cluster. The
second rule is that if two or more processors issue write requests simultaneously to a
processor at idle, the highest priority among these processors belongs to the one with the
lowest ProcID.
LOCAL CLUSTER ARBITER and ROUTER
Out[0]
psel[N:0]
phold[N:0]
phold[0]
psel[0]
processor 0
psel[0]
0
N
WAddr[0]
WAddr[N]
Out[0]
Out[N]
Aport
Dport
WAddr[0]
NoSelect[0]
psel[0]
0
N
Out[N]
phold[N]
psel[N]
processor N
psel[N]
0
N
Aport
Dport
WAddr[N]
NoSelect[N]
psel[N]
0
N
WAddr[0]
WAddr[N]
Out[0]
Out[N]
Fig. 8.27 Inter-processor arbiter and router
8.2
Data-Driven Processors
485

Review Questions
1. The following sum of products (SOP) function is given:
out ¼ AC þ ABC þ B
Implement this function using three-input LUTs only.
2. The following product of sums (POS) function is given:
out ¼ ðA þ BÞ : ðB þ CÞ : ðA þ B þ CÞ
Implement this function using two-input LUTs only.
3. The following truth table needs to be implemented in FPGA.
0
0
0
1
0
0
1
0
0
1
0
1
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
1
1
1
1
0
A
B
C
out
Assume the three-input LUT conﬁguration is given below:
inputs
out
clock
bypass
Prog in
Prog out
0
1
2
3
4
5
6
7
D Q
1
0
486
8
Special Topics

(a) Implement the truth table only with three-input LUTs.
(b) Implement the same truth table only with four-input LUTs.
(c) Implement the same truth table only with two-input LUTs.
4. Implement the 3-1 multiplexer below using three-input LUTs.
The deﬁnition of the MUX is given below:
If sel[1:0] = 00 or 11 then out = a
If sel[1:0] = 01 then out = b
If sel[1:0] = 10 then out = c
sel [1:0]
out
a
1
2
2
b
c
0
5. A simple Moore state machine that consists of two states is given below. After con-
structing the state and transitional tables, draw the circuit diagram of this state machine
using minimal number of logic gates and ﬂip-ﬂops.
Once the logic diagram is ﬁnalized, implement the state machine in FPGA using
two-input LUTs and three LUTs in a cluster. Draw the architectural diagram of this
FPGA platform, including interconnections.
Assign the values A = 0 and B = 1 to the state machine below.
A
B
IN = 0
IN = 0
IN = 1
IN = 1
OUT = 1
OUT = 2
8.2
Data-Driven Processors
487

6. A three-bit counter is given below. The Hold input activates port 1 of the 2-1 MUX to
retain the output value. Otherwise, the counter keeps incrementing by one.
1
1
0
Hold
clk
3
3
MuxOut
Out [2:0]
D Q
Assume that the three-bit adder is simply a ripple-carry adder composed of three
full-adders (FA) with sum (Sum) and carry-out (Cout) outputs as shown below.
FA
FA1
FA
A[2]
B[2]
A[1]
B[1]
A[0]
B[0]
Sum[2]
Cin[0]=0
Cin[2] = Cout[1]
Cin[1] = Cout[0]
Sum[1]
Sum[0]
Sum[i] = A[i] ⊕B[i] ⊕Cin[i]
Cout[i] = A[i] . B[i] + Cin[i-1] . (A[i] + B[i])
Implement this circuit using three-input LUTs in FPGA platform.
Projects
1. Implement and verify the three-input LUT in Fig. 8.1 using Verilog.
2. Implement the four-bit ripple-carry adder in Fig. 8.2 using Verilog. Use three-input LUTs
from project 1 to create an FPGA implementation of the adder in Fig. 8.5. Perform
functional veriﬁcation on the entire circuit.
3. Implement the Moore state machine in Fig. 8.8 and the corresponding logic diagram in
Fig. 8.9 using Verilog. Use three-input LUTs from project 1 to create an FPGA imple-
mentation of the state machine in Fig. 8.15. Perform functional veriﬁcation on the entire
circuit.
488
8
Special Topics

References
1. Brown S, Francis R, Rose J, Vranesic Z. Field-programmable gate arrays. Springer, ISBN: 9780792392484
2. Ahmed E, Rose J (2004) The effect of LUT and cluster size on deep-submicron FPGA performance and density.
IEEE trans larg Scale Integr (VLSI) Syst 12(3):288–298
3. Brown S, Rose J (1996) FPGA and CPLD architectures: a tutorial. IEEE Design Test Comput 13(2):42–57
4. Bindal A, Brugada S, Ha T, Sana W, Singh M, Tejaswi V, Wyland D (2004) A simple micro-threaded data-driven
processor. IEEE Euromicro Symp Digital Syst Design
8.2
Data-Driven Processors
489

Appendix: An Introduction to Verilog
Hardware Design Language
A.1. Module Definition
A digital system in Verilog is deﬁned in terms of modules as shown in Fig. A.1. Each
module has inputs and outputs with different bit widths. Modules can be integrated to form
bigger digital blocks as shown in Fig. A.2. In this ﬁgure, the top module contains four
smaller modules, each of which has inputs and outputs. They are interconnected with each
other to produce much larger system functionality with a new set of external input and output
signals.
module
inputs
outputs
Fig. A.1 A typical module in Verilog
module 1
module 2
module 3
module 4
top module
input 1
input 2
output 1
output 2
Fig. A.2 Module integration to form a much larger system
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9
491

When creating a Verilog code to represent a digital block such as in Fig. A.3, the module
name is written ﬁrst. The input and output names are written in parentheses next to the
module name as shown below. Their order is not important. The module statement is
followed by separate input-output (I/O) statements and the description of the module.
module blockX (out, in); 
output out; 
input [3:0] in; 
/* module description here */ 
endmodule  
For a more speciﬁc example let us write a small Verilog code for the two-input AND gate
in Fig. A.4.
module andgate (out, in1, in2); 
output out; 
input in1, in2; 
/* module description here */ 
endmodule  
Now, let us integrate blockX in Fig. A.3 with the two-input AND gate in Fig. A.4 to form
a larger digital block as shown in Fig. A.5.
blockX
in[3:0]
out
4
Fig. A.3 A Verilog module, blockX, with in[3:0] and out
in1
in2
out
Fig. A.4 Two-input AND gate
492
Appendix: An Introduction to Verilog Hardware Design Language

This new module, called blockY, has different I/O names due to the naming convention
used in the schematic in Fig. A.5. As a preference, the I/O names in the module deﬁnition
statement and in individual I/O statements list the outputs ﬁrst and the inputs second.
However, this is not a requirement but a choice.
In addition, both the blockX and the two-input AND gate need to be instantiated inside
the blockY. This is achieved by using the “dotted” convention as shown below. Here, the
individual module I/O names are written outside the parentheses; the I/O names used in the
top module are written inside the parentheses. The names, i1 and i2, are the instantiation
names of the modules, andgate and blockX, respectively.
module blockY (out1, out2, a, b, c);
output out1, out2;
input [3:0] a;
input b, c;
andgate
i1
(.out(out2),
.in1(b),
.in2(c));
blockX
i2
(.out(out1),
.in[0](a[0]),
.in[1](a[1]),
.in[2](a[2]),
.in[3](a[3]));
/* the rest of the code here */
endmodule
blockX
in[3:0]
out
4
in1
in2
out
a[3:0]
b
c
out1
out2
blockY
Fig. A.5 A Verilog module integrating blockX in Fig. A.3 and the two-input AND gate in
Fig. A.4
A.1. Module Definition
493

Basic logic gates (or Verilog primitives) do not need instantiations. The two-input AND
gate in Fig. A.4 could have been written without any “dotted” instantiation in the top module
above.
The Verilog primitives are the following gates:
AND, NAND, OR, NOR, XOR, XNOR, BUF, NOT.   
Here, BUF corresponds to a buffer, and NOT corresponds to an inverter.
Example: Let us implement one-bit full adder using Verilog.
In a full adder, the sum and carry-out functions are shown as:
sum = a 
b
 cin 
cout = a . b + cin . (a + b) 
In the functional equations above, cin corresponds to the carry-in input and cout corre-
sponds to the carry-out output of the full adder. The terms, a and b, are the two inputs to the
full-adder.
The schematic to produce sum and carry-out functions are shown in Fig. A.6. The
intermediate nodes are named as node1, node2, node3 and node4 as interconnecting nodes.
The Verilog code below contains no “dotted” instantiations. This style of Verilog code is
called structural where only primitive gates are used.
a
b
cin
cout
sum
node1
node2
node3
node4
Fig. A.6 Hardware implementation of the full adder
494
Appendix: An Introduction to Verilog Hardware Design Language

module fulladder (sum, cout, a, b, cin); 
output sum, cout; 
input a, b, cin; 
/* structural style module description */ 
xor (node1, a, b); 
xor (sum, node1, cin); 
and (node2, a, b); 
or (node3, a, b); 
and (node4, cin, node3); 
or (cout, node2, node4);   
endmodule 
After the Verilog code is written, a test ﬁxture needs to be produced to verify the module.
For our example of the one-bit full adder, Fig. A.7 illustrates the concept of building the test
ﬁxture.
In this ﬁgure, the outputs of the full adder must be declared as the inputs to the test ﬁxture
using the wire statement. The outputs of the test ﬁxture are the inputs for the full adder, and
they should generate all the veriﬁcation vectors needed to test the full adder thoroughly. For
each test input, the outputs of the test ﬁxture must remain unchanged until a new set of
outputs are produced. Therefore, each output has a memory, and uses the reg statement in
Verilog. Also, the test ﬁxture neither contains any I/O names in the module deﬁnition nor
has any input and output statements. Thus, the general structure of the test ﬁxture becomes as
follows:
sum
in1
sum
fulladder
cout
carryout
a
in2
b
carryin
cin
testfixture
Fig. A.7 Test ﬁxture formation to verify the functionality of the full adder
A.1. Module Definition
495

module testfixture; 
/* all test fixture outputs are declared as reg statements */ 
/* all test fixture inputs are declared as wire statements */ 
/* module instantiation here */ 
/* verification vectors here */ 
/* display results here */ 
endmodule 
The veriﬁcation vectors are executed only once using the initial statement in Verilog. For
a combinational logic such as a full adder, these vectors are simply the inputs of the truth
table. The outputs, on the other hand, need to be either displayed or stored in a ﬁle in order to
be compared against the “expected” outputs. Therefore, for the one-bit full adder test ﬁxture
shown in Fig. A.7, the Verilog code becomes as follows:
module testfixture; 
/* all test fixture outputs are declared as reg statements */ 
reg in1, in2, carryin; 
/* all test fixture inputs are declared as wire statements */ 
wire sum, carryout; 
/* module instantiation here */ 
fulladder   i1    (.sum(sum),  
                         .cout(carryout),  
                         .a(in1),  
                         .b(in2),  
                         .cin(carryin)); 
/* verification vectors here are executed only once due to initial statement */ 
initial 
begin 
carryin = 0; in1 = 0; in2 = 0; 
#10 
 
 
in2 = 1; 
#10 
 
in1 = 1; in2 = 0; 
#10 
 
 
in2 = 1; 
#10 
carryin = 1; in1 = 0; in2 = 0; 
#10 
 
 
in2 = 1; 
#10 
 
in1 = 1; in2 = 0; 
#10 
 
 
in2 = 1; 
end
/* display results here */ 
endmodule 
496
Appendix: An Introduction to Verilog Hardware Design Language

The “#” sign used in almost every statement inside the initial block indicates a delay
function. For example, the code waits for 10 time units after the ﬁrst line (cin = 0; in1 = 0;
in2 = 0;) is executed before the value of in2 is changed from logic 0 to logic 1 in the second
line. Since in1, in2 and cin are all reg statements, their values are retained until changed.
Monitoring the results are achieved by the $time and $monitor statements. $time displays
the current simulation time. $monitor displays the variable value whenever the variable
value changes.
For example, $monitor ($time, output, input1, input2); statement displays simulation time
and the values of output, input1 and input2. On the other hand, $monitor ($time,,”output=%h
input=%b”, out, in \n); statement displays the simulation time, leaves a space between the
simulation time and “output” because of the extra comma, displays “output” in hexadecimal
format and “input” as binary format. After each set of simulation time, input and output, a new
line starts for the second set due to carriage return, “\n”, entry. One can also use “\t” to insert a
tab between the terms to achieve separation.
All Verilog ﬁles are stored with the “.v” extension after the ﬁle name, such as fulladder.v.
When executing the Verilog command to simulate multiple ﬁles, including the test ﬁxture,
the command line should include the top module last and all the remaining modules inside
the top module ﬁrst.
In this full adder example, we need to write fulladder.v ﬁrst and then testﬁxture.v because
the test ﬁxture contains the full adder module. Therefore, the command line becomes:
verilog fulladder.v testﬁxture.v
The notation for a comment in Verilog is identical to the ones used in C-programming.
For a single line comment, a pair of slashes, “//”, is used. For a multiple line comment, the
comment starts with a slash and a star, “/*”, and ends with a star and a slash, “*/”.
A.2. Numbers in Verilog
The numbers in Verilog are represented by three distinct terms:
SIZE   `BASE   VALUE 
Note that the tick mark, “`”, attached to the BASE entry is not apostrophe.
As an example, 32`h3C represents a 32-bit hexadecimal number, 0x0000003C. 8`b1
represents an eight-bit binary number, 00000001. Any time the size entry is omitted, the size
defaults to 32 bits. For example, `h8A corresponds to 0x0000008A. The base entry to
represent high impedance or ﬂoating wire is “`z”. For example, 8`bz means an eight-bit bus
with all its eight bits are ﬂoating or zzzzzzzz. Similarly, don’t care bits are shown by “`x”.
For example, 4`bx means four wires either at logic 0 or logic 1, and represents xxxx.
A.1. Module Definition
497

498
Appendix: An Introduction to Verilog Hardware Design Language
A.3. Time Directives for Compiler
To mimic propagation delays in Verilog simulation, a timing directive is used. The directive,
`timescale, is preceded by a tick mark to point out that the command is for the compiler to
delay the execution of a Verilog statement if the statement starts with the pound mark, “#”.
The `timescale directive is the ﬁrst line in a Verilog code. The statement does not end with
a semicolon and contains two entries separated by a “/” sign. The ﬁrst entry corresponds to
the actual delay. The second entry represents the simulation resolution.
For example, `timescale 10 ns / 100 ps means each time the compiler sees a “#” sign in a
Verilog statement, it delays the execution of the statement by multiplies of 10 ns, depending
on the number that follows the “#” sign. The resolution is 100 ps. Therefore, for a delay of
10 ns, the simulation accuracy is 1:100.
Let us consider the following structural Verilog code as an example.
`timescale 1 ns / 100 ps 
module  inverter (out, in); 
output out;
input 
in; 
not
#2 (out, in); 
//2 ns delay between input and output 
endmodule 
This is a module that represents a single inverter. The propagation delay in the inverter is
2 ns because the number following the “#” sign in the “not” gate is 2, and this number is
multiplied by 1 ns in the timescale directive. The simulation resolution is 100 ps. Therefore,
there is 1:20 accuracy when generating a delay function for the inverter.
Other common compiler directives are the `deﬁne and `include statements, and neither
ends with a semicolon. The `deﬁne statement deﬁnes a variable for the Verilog code. For
example, in the following Verilog code a variable called inv_delay corresponds a delay of
30 ps with 1 ps simulation resolution.
`timescale 10ps / 1ps 
`define inv_delay #3 
module  inverter (out, in); 
output out;
input 
in; 
not 
inv_delay (out, in); 
//30ps delay between input and output 
endmodule 
The `include statement fetches smaller modules from various directories and includes them
into a bigger module for simulation. For example, the following Verilog code brings the
full_adder.v module located in the verilog_modules directory to be used in bigger_module.v.

endmodule 
`include “verilog_modules/full_adder.v”
`timescale 10ps / 1ps 
`define inv_delay #3 
module bigger_module (out1, out2, in1, in2, in3);
…
…
A.4. Parameters
Parameters are used to replace numbers for enhancing the readability of Verilog code. The
parameter statement is not a compiler directive. Therefore, it is ended with a semicolon. The
statement has only one entry, which attaches a name to a number.
parameter 
name = value; 
Assume the following example: 
module  
alu (out,in1,in2); 
output  
[31:0] out; 
input 
 
[31:0] in1,in2; 
…
…
endmodule 
The value, 31, can be replaced by the name, BUS, using the parameter statement to
enhance readability of the Verilog code. Thus,
module  
alu (out,in1,in2); 
parameter 
BUS=31; 
output  
[BUS:0] out; 
input 
 
[BUS:0] in1,in2; 
…
…
endmodule 
A.5. Basics of Structural Verilog Modeling
Structural modeling was introduced in the earlier sections and described how to use basic
logic gates in a Verilog code. Structural Verilog eliminates the dotted convention when
instantiating Verilog primitives. The logic gates supported by Verilog are:
A.3. Time Directives for Compiler
499

AND 
NAND 
OR 
NOR 
XOR 
XNOR 
BUF 
NOT 
For example, a three-input NOR gate with inputs, in1, in2 and in3, is represented by:
nor (out, in1, in2, in3); 
As another example, a buffer with an input, in, and an output, out, is written as:
buf (out, in); 
In each structural statement, the output of the logic gate is listed ﬁrst followed by the
inputs.
Tri-state buffers and inverters are represented by conditional structural statements. The
statement buﬁf1 represents a tri-state buffer with an active-high enable as shown in Fig. A.8.
This gate behaves like a buffer when enable = 1, and becomes an open circuit when
enable = 0. The structural Verilog statement for the tri-state buffer becomes:
bufif1 (out, in, enable); 
A tri-state buffer with an active-low enable signal shown in Fig. A.9 makes this logic gate
behave like a buffer when enable = 0, and an open-circuit when enable = 1.
in
out
enable
Fig. A.8 Tri-state buffer with active-high enable
in
out
enable
Fig. A.9 Tri-state buffer with active-low enable
500
Appendix: An Introduction to Verilog Hardware Design Language
The structural Verilog statement for this gate uses a buﬁf0 statement:
bufif0 (out, in, enable); 
Tri-state inverters use the same active-high or active-low enable signals. To represent a
tri-state inverter with an active-high signal in Fig. A.10, the notif1 statement is used.

notif1 (out, in, enable); 
The tri-state inverter with an active-low enable signal in Fig. A.11 uses the notif0
statement as shown below.
notif0 (out, in, enable); 
in
out
enable
Fig. A.11 Tri-state inverter with active-low enable
A.5. Basics of Structural Verilog Modeling
501
in
out
enable
Fig. A.10 Tri-state inverter with active-high enable
A.6. Behavioral Modeling
There are two types of procedural blocks in behavioral Verilog coding. The ﬁrst one is called
the “initial” statement. Each Verilog statement included in the initial statement is executed
only once. The procedural block below shows the general form of the initial statement. The
statements in an initial block are enveloped with the “begin” and “end” clauses. The initial
statement may or may not come with a condition(s) listed in parentheses after the symbol
“@”. If the initial statement comes with a condition, the statement is executed when the
condition occurs. Otherwise, the program omits the initial statement.
initial @ (condition) 
 
begin 
 
statement 1; 
// all statements within the initial statement are executed only once 
 
statement 2; 
…
…
end
As an example, let us consider a test ﬁxture that veriﬁes the functionality of a module with
two inputs, in1 and in2, and receives three outputs, a, b and c, from the module. The test
vectors applied to this module need to be executed only once. The form of the initial
statement will be as follows:

reg input1, input2; 
wire outa, outb, outc; 
testmodule i1   (.in1(input1), 
 
 
.in2(input2), 
.a(outa), 
 
 
.b(outb), 
 
 
.c(outc)) 
initial 
begin 
input1 = 0; input2 = 0; 
#10 
input2 = 1; 
#10 
input1 = 1; input2 = 0; 
#10 
input2 = 1; 
end
endmodule 
module test; 
The second type of procedural block is the “always” statement. This statement may also
come with a condition in parentheses. Unlike the initial statement, the always statement is
executed repeatedly. If the always statement comes with a condition, the execution of
statements within the always statement takes place only when the condition is encountered.
Otherwise, the program skips over the always statement. The general form of the always
statement is shown below.
always @ (condition) 
 
begin 
 
statement 1; 
// all statements within the always statement are executed repeatedly 
 
statement 2; 
…
…
end
An example is to implement a ﬂip-ﬂop with two inputs, d and clock, and two outputs, q
and qbar.
endmodule 
`timescale 10ps / 1ps 
module flip_flop (q, qbar, d, clock); 
output q, qbar; // qbar is the inverted output, q 
input clock, d; 
reg q, qbar; 
always @ (posedge clock) 
 
begin 
#2 
q = d; 
#1 
qbar = ~d; 
end
502
Appendix: An Introduction to Verilog Hardware Design Language

A.6. Behavioral Modeling
503
In the Verilog code above, the logical value at the ﬂip-ﬂop output, q, becomes equal to the
logical value at the input, d, 20 ps after the rising edge of the clock. The logical value at the
qbar output waits for the completion of the ﬁrst statement, and becomes equal to the inverted d
input 10 ps after the ﬁrst statement. This waiting period from one statement to the next arises
because these two statements are the blocking type. In other words, when an assignment uses
the “=” sign in a statement inside the procedural block, the statement becomes a blocking
statement, which blocks the execution of the next statement until it is executed ﬁrst. The reg
statement is also added to this program because values or other variables (inputs in this case)
are assigned to the outputs, q and qbar, inside the always procedural block.
The same Verilog code can be rewritten as:
`timescale 10ps / 1ps 
module flip_flop (q, qbar, d, clock); 
output q, qbar;  
input clock, d; 
reg q, qbar; 
always @ (posedge clock) 
 
begin 
#2 
q <= d; 
#3 
qbar <= ~d; 
end
endmodule 
In this program, the ﬁrst and the second statements in the always block become
non-blocking type due to the “<=” sign, and they are executed simultaneously. Therefore, the
output, q, becomes equal to the input, d, 20 ns after the positive edge of the clock. Similarly, the
output, qbar, becomes equal to the inverted input, *d, 30 ps after the positive edge of the clock.
More than one condition can be included in an initial or always procedural block. For
example, a ﬂip-ﬂop with an asynchronous active-low reset input can be modeled as follows:
`timescale  
10ps/1ps
module  flip_flop (q, qbar, d, clock, reset); 
output   
q, qbar; 
input 
 
d, clock, reset; 
reg 
 
q, qbar; 
always @ (posedge clock or negedge reset) 
 
 
begin 
if (reset == 0) 
 
 
begin 
 
 
 
 
#2  
q <= 0;
#2 
qbar <= 1; 
end
else 
 
 
begin 
#4  
q <= d;
 
 
#5 
qbar <= ~d; 
 
 
end
end
endmodule 

If the program encounters an active-low reset before the positive edge of clock, both q and
qbar outputs become logic 0 20 ps after the negative edge of reset. Otherwise, without any
reset, the ﬂip-ﬂop operates normally, and the output, q, becomes equal to the input, d, 40 ps
after the positive edge of the clock, and the output, qbar, becomes equal to the inverted input,
*d, 50 ps after the positive edge of the clock due to the non-blocking nature of these
assignments.
A.7. Arithmetic and Logical Operators in Verilog
There are two types of operators used in Verilog: arithmetic and logical. The arithmetic
operators simply add, subtract, multiply or divide the variables used in a program. The
symbol for each operation is given below:
Add 
 
 
+ 
Subtract 
 
- 
Multiply  
 
* 
Divide  
 
/ 
The logical operators execute all the logic functions, comparisons, bit shifting and con-
catenation. The symbol for each operation is given below:
Bitwise AND 
 
& 
 
Bitwise NAND  
~&
Bitwise OR 
 
| 
 
 
Bitwise NOR 
 
~|
Bitwise XOR 
 
^ 
Bitwise XNOR  
~^
Bitwise NOT 
 
~ 
Less than 
 
< 
Greater than 
 
> 
Greater than or equal 
>=
Less than or equal 
<=
Equal  
 
==
Logical left shift  
<<
Logical right shift 
>>
Conditional 
 
? : 
Concatenation  
{ } 
For example, if four-bit variables, X and Y, are equal to 0110 and 1011, respectively, the
logical operations on X and Y become as follows:
~Y 
= 0100 
X & Y = 0010 
X ~| Y = 0000 
504
Appendix: An Introduction to Verilog Hardware Design Language

As another example, let us assume A = 4’b1101 and B = 8’b01110101. Shifting B one bit
to the left becomes:
B << 1 = 11101010 
A & (B << 1) = 00001101 & 11101010 = 00001000 
A.8. Conditional Statement
Conditional statements are equivalent to the “if-then” statements in C-programming. They
follow the same format in C-language but enveloped between the begin and end clauses.
The simplest form of a conditional statement is given below:
begin 
if (condition1) 
 
if (condition2) 
 
 
if (condition3) 
 
 
statement 1; 
…
 
 
else 
 
statement 2; 
…
 
else  
 
statement 3;
…
else 
statement 4; 
…
end
Conditions may also be combined using logical operators. For example, the Verilog code
below AND-gates all three conditions, condition 1, condition 2 and condition 3, and pro-
duces a single condition for the if-clause.
begin 
if (condition1 && condition 2 && condition 3) 
statement 1; 
…
else 
 
statement 2; 
…
end
The condition can include many operators as shown in the example below.
A.7. Arithmetic and Logical Operators in Verilog
505

begin 
if (a > 0) 
 
if (x <= 0)
 
 
y = 1;
 
else 
 
// x > 0 is implied 
 
 
y != 2; 
else if (a == 0)
if (x < = 0) 
 
 
y = 3;
 
else 
 
// x > 0 is implied 
 
 
y != 4; 
else 
 
 
// no if statement, thus a < 0 is implied 
 
if (x <= 0)
 
 
y = 5;
 
else 
 
// x > 0 is implied 
 
 
y != 6;
end
A.9. Case Statement
Conditional statements can be written using a “case” statement. The example below
implements an 8-1 multiplexer in Fig. A.12 with a case statement.
in0
in1
in2
in7
out
0
1
2
7
sel [2:0]
3
Fig. A.12 8-1 MUX
506
Appendix: An Introduction to Verilog Hardware Design Language

The case statement for this MUX can be written as follows:
`define sel_value0 
3’b000
`define sel_value1 
3’b001
`define sel_value2 
3’b010
`define sel_value3 
3’b011
`define sel_value4 
3’b100
`define sel_value5 
3’b101
`define sel_value6 
3’b110
`define sel_value7 
3’b111
module mux (out, sel, in0,in1, in2, in3, in4, in5, in6, in7); 
output out; 
input in0, in1, in2, in3, in4, in5, in6, in7; 
input [2:0] sel; 
reg out; 
always @ (sel or in0 or in1 or in2 or in3 or in4 or in5 or in6 or in7) 
In this code, the case statement is executed if any of the inputs, in0 to in7, or the select
input, sel [2:0], changes. Once inside the case statement, the output of the MUX, out,
becomes equal to one of the MUX inputs according to the input select signal, sel_value0 to
sel_value7. The output of the MUX, out, also needs to be declared with a reg statement
because this variable is declared inside the procedural block, and assigned with different
input values, in0 to in7. The default statement inside the case statement declares the value of
the output if none of the other cases apply. The case statement is enclosed between the case
and the endcase clauses. Since the case statement is in a procedural block it also needs the
begin and the end statements enveloping the case statement.
A.9. Case Statement
507
begin 
case (sel) 
`sel_value0 : out = in0; 
`sel_value1 : out = in1; 
`sel_value2 : out = in2; 
…
`sel_value7 : out = in7; 
default:         out = in0; 
endcase 
end
endmodule 

A simple example is the implementation of a 4-1 MUX in Fig. A.13.
module mux (out, sel, in0, in1, in2, in3); 
output out; 
input in0, in1, in2, in3; 
input [1:0] sel; 
reg out; 
always @ (sel or in0 or in1 or in2 or in3) 
begin 
case (sel) 
2’b00 : out = in0;
2’b01 : out = in1;
2’b10 : out = in2;
2’b11 : out = in3;
default: out = in0; 
endcase 
end
endmodule 
The case statement can also be used to implement an Arithmetic Logic Unit (ALU) as
shown in Fig. A.14 because the ALU output is accompanied by a multiplexer.
in0
in1
in2
in3
out
0
1
2
3
sel [1:0]
2
Fig. A.13 4-1 MUX
508
Appendix: An Introduction to Verilog Hardware Design Language

`define  XOR  
2’b00
`define  SHIFT  2’b01 
 
 
`define  ADD  
2’b10
`define  SUB 
2’b11
module  alu (out, opcode, a, b); 
output  [7:0] out; 
input  
[7:0] a, b; 
input 
[1:0] opcode; 
reg 
[7:0] out; 
always @ (opcode or a or b) 
begin 
case (opcode) 
`XOR: out = a ^ b;
`SHIFT: out = a << b;
`ADD: out = a + b;
`SUB: out = a - b; 
default: out = a + b; 
endcase 
end
endmodule 
A.10. Looping Statements
There are two useful looping statements in Verilog, the “for” statement and the “while”
statement. Both statements have to be included in a procedural block.
In the for-loop example given below, the variable, i, starts from 0, and stops at 10,
incrementing by 1. The variable, j, is deﬁned in terms of the variable, i. The array that
follows determines a[j] in terms of a[i]. Thus,
for (i = 0; i <= 10; i ++)
begin 
 
j = i + 1;
 
a[j] = a[i] + 1;
end
A.9. Case Statement
509
out
0
1
2
3
opcode [1:0]
2
a ⊕ b
a << b
a + b
a - b
8
8
8
8
8
Fig. A.14 A simple ALU

The while-loop waits for the occurrence of an event. When the event takes place, the
statements in the while-loop are executed. In the example below, a for-loop is engaged, and the
variable, x[i], is determined in terms of a[i] and b[i]as longas the variable, sum,is not equalto 0.
while (sum != 0)
begin 
 
 
for (i = 0; i < 10; i++) 
 
 
begin 
 
 
x[i] = a[i] - b[i]; 
end
end
A.11. State Machine Implentations
There are two types of state machines: Mealy-type and Moore-type. Both types can easily be
implemented in Verilog using case statements.
The present state of a state machine is deﬁned by ﬂip-ﬂop outputs. The next state is
deﬁned by ﬂip-ﬂop inputs because at the positive edge of clock the next state becomes the
present state.
A.12. Mealy Machine
The present state outputs of the Mealy machine stems from the present state and the present
state inputs. Therefore, if the present state inputs change during the clock period, this change
affects the present state outputs and the next state instantaneously as shown in Fig. A.15.
clock
Combinational
Logic
Present State
Next State
Present State 
Outputs
Present State 
Inputs
PS
NS
Present State Outputs
Present State Inputs
Q
D
Fig. A.15 Block diagram and state representation of Mealy machine
510
Appendix: An Introduction to Verilog Hardware Design Language

The example in Fig. A.16 shows a Mealy-type state machine with four states. When
implementing this state machine in Verilog, it is best to divide the overall circuit topology
into two sections as shown in Fig. A.17.
The ﬁrst section is purely combinational. This section’s inputs stem from the present state
and the present state inputs as shown in Fig. A.17. The outputs form the next state and the
present state outputs. Since both the outputs and the next state are functions of the inputs and
the present state, this section can conveniently be implemented with a multiplexer. The
second section constitutes a sequential logic circuit with ﬂip-ﬂop inputs and outputs. This
section, as we will see below, is implemented with an always statement.
S0
S1
S2
S3
IN = 0
OUT = 3
IN = 0
OUT = 1
IN = 0
OUT = 2
IN = 0
OUT = 4
IN = 1
OUT = 2
IN = 1
OUT = 2
IN = 1
OUT = 3
IN = 1
OUT = 4
Fig. A.16 State diagram of a Mealy machine with four states (reset not shown for
simplicity)
A.12. Mealy Machine
511

The Verilog code below ﬁrst implements the combinational logic section of the state
machine then the sequential part. The numeric values corresponding to each of the four
present states in Fig. A.16 are assigned to the parameters, s0, s1, s2 and s3, using the
parameter statement because this simpliﬁes the observation of the input and the output
values at a particular state.
The combinational part of the state machine is implemented by a case statement inside an
always procedural block, and executed if one of the multiplexer inputs, in and pstate,
changes. Here, the input, in, corresponds the only input, IN, in Fig. A.16, and the input,
pstate, corresponds to the present state. If the pstate input is assumed to be the selector input
to a multiplexer, the case statement then lists all possible combinations of the multiplexer
output as a function of pstate. The default in the case statement always corresponds to the
initial state of the state machine. In each case statement, the output assignments are always
non-blocking type because in real hardware the outputs are produced concurrently and
independent of each other.
The sequential part of the state machine is implemented by an always statement. How-
ever, this statement becomes active only at the positive edge of the clock and the negative
edge of the reset rather than static values of these two signals.
clock
Combinational
Logic
Present State
Next State
Present State 
Outputs
Present State 
Inputs
Q
D
State assignment part
Combinational logic part
reset
Fig. A.17 Segmentation of the Mealy machine (with asynchronous reset)
512
Appendix: An Introduction to Verilog Hardware Design Language

// Mealy machine with asynchronous reset
module mealy (out, reset, in, clock);
output
[2:0] out;
input
reset, in, clock;
reg
[2:0] out;
reg
[1:0] nstate, pstate;
parameter s0=2’b00, s1=2’b01, s2=2’b10, s3 =2’b11;
always @ (in or pstate)
begin
case (pstate)
s0:
begin
if (in == 0)
begin
out <=1;
nstate <= s0;
end
else
begin
out <= 2;
nstate <= s1;
end
end
end
s1:
begin
if (in == 0 )
begin
out <= 2;
nstate <= s1;
end
else
begin
out <= 3;
nstate <= s2;
end
s2:
begin
if (in ==0)
begin
out <= 3;
nstate <= s2;
end
A.12. Mealy Machine
513

 
 
else 
 
 
 
begin 
 
 
 
out < = 4;
 
 
 
nstate <= s3; 
end
end
s3: 
begin 
 
 
if (in ==0) 
 
 
 
begin 
 
 
 
out <= 4; 
 
 
 
nstate <= s3; 
end
 
 
else 
 
 
 
begin 
 
 
 
out < = 2; 
 
 
 
nstate <= s1; 
end
end
default: begin 
 
 
out <=1; 
 
 
nstate <= s0; 
end
endcase
end
always @ (posedge clock or negedge reset) 
begin 
if (reset == 0) 
 
 
pstate <= s0; 
 
else  
 
 
pstate <= nstate; 
end
endmodule 
A.13. Moore Machine
Implementing the Moore machine is not any different from the Mealy machine except the
formation of present state outputs. Figure A.18 shows the present state outputs of the Moore
machine to be only a function of the present state, and independent of any present state inputs.
514
Appendix: An Introduction to Verilog Hardware Design Language

If we consider a four-state Moore machine in Fig. A.19, its implementation in Verilog
requires combining the two combinational logic sections of the circuit in Fig. A.20 with a
case statement, and implementing the sequential part with an always statement.
Implementing the combinational logic parts of the state machine is accomplished by a
multiplexer. The present state input, IN, and the present state, pstate, constitute the inputs to
this multiplexer. Implementing the sequential section of the state machine, on the other hand,
requires the next state of the state machine to be ﬂip-ﬂop inputs and the present state to be
ﬂip-ﬂop outputs.
Combinational
Logic
Combinational
Logic
Present State
Next State
Present State 
Outputs
Present State 
Inputs
PS
NS
Present State 
Outputs
Present State 
Inputs
Next State 
Outputs
clock
Q
D
Fig. A.18 Block diagram and state representation of Moore machine
S0
S1
S2
S3
IN = 0
IN = 1
IN = 1
IN = 1
IN = 0
IN = 0
IN = 0
IN = 1
OUT = 1
OUT = 2
OUT = 4
OUT = 3
Fig. A.19 State diagram of a Moore machine with four states (reset not shown for
simplicity)
A.13. Moore Machine
515

The program below assigns numeric values to all four states with a parameter statement.
The ﬁrst always statement includes a case statement to show what happens to the multiplexer
outputs if one of the selector inputs changes. Again, all multiplexer outputs form concur-
rently. Therefore, all output assignments are deﬁned to be non-blocking type. As opposed to
the Mealy machine, the present state outputs of the Moore machine are solely generated from
the present state. Therefore, for each state from s0 to s3 the output assignments are written
ﬁrst, independent of any present state input.
The sequential part is implemented by an always statement which includes the edge
dependency of the clock and the reset. This statement is executed only if the indicated edges
of these two inputs take place. Otherwise, it is ignored.
Combinational
Logic
Combinational
Logic
Present State
Next State
Present State 
Outputs
Present State Inputs
clock
Q
D
State assignment part
Combinational logic part
reset
Fig. A.20 Segmentation of the Moore machine (with asynchronous reset)
516
Appendix: An Introduction to Verilog Hardware Design Language

// Moore machine with asynchronous reset
module moore_async (out, reset, in, clock);
output
[2:0] out;
input
reset, in, clock; 
reg
[2:0] out;
reg
[1:0] nstate, pstate;
parameter 
s0=2’b00, s1= 2’b01, s2= 2’b10, s3= 2’b11;
always @ (in or pstate)
begin
case (pstate)
s0:
begin
out <= 1;
if (in == 1)
nstate <= s1;
else
nstate <= s0;
end
s1:
begin
out <= 2;
if (in == 1)
nstate <= s2;
else
nstate <= s1;
end
s2:
begin
out <= 3;
if (in == 1)
nstate <= s3;
else
nstate <= s2;
end
s3:
begin
out <= 4;
if (in == 1)
nstate <= s1;
else
nstate <= s3;
end
default: begin
out <= 1;
nstate <= s0;
end
endcase
end
A.13. Moore Machine
517

The Verilog code below implements the Moore machine with a synchronous reset. This
time, reset is not an isolated input to the ﬂip-ﬂops as in Fig. A.20, but instead it is applied to
the combinational logic block along with the other present state inputs.
always @ (posedge clock or negedge reset) 
 
begin 
if (reset == 0)   
pstate <= s0; 
 
else  
 
 
 
end  
 
 
pstate <= nstate; 
endmodule 
//Moore machine with synchronous reset 
module  more_sync (out, reset, in, clock);
output   
[2:0] out; 
input  
 
reset, in, clock; 
reg 
 
[2:0] out; 
reg  
 
[1:0] nstate, pstate; 
parameter  
s0= 2’b00, s1= 2’b01, s2 =2’b10, s3 = 2’b11;
always @ (in or reset or pstate) 
begin 
case (pstate) 
 
s0:  
begin 
 
 
out <= 1;
 
 
if (reset == 0 )   
nstate <=s0; 
 
 
else 
 
 
begin 
if (in == 1) 
nstate <= s1; 
else 
nstate <= s0; 
end
end
 
s1: 
begin 
 
 
out <= 2;
if (reset == 0 )  
nstate <= s0; 
 
 
else  
 
 
 
begin 
 
 
 
 
if (in == 1) 
 
nstate <= s2; 
 
 
 
else  
 
 
nstate <= s1; 
end
end
518
Appendix: An Introduction to Verilog Hardware Design Language

A.14. Principles of Register-Transfer-Logic Type Coding
The Register-Transfer-Logic (RTL) style of Verilog coding inherits many C-program con-
structs and implements the intended hardware with ease. Although structural or behavioral
Verilog coding may be necessary for certain types of logic blocks, RTL is still the most
common coding style to build hardware.
s2:
begin
out <= 3;
if (reset == 0)
nstate <= s0;
else
begin
if (in == 1)
nstate <= s3;
else
nstate <= s2;
end
end
s3:
begin
out <= 4;
if (reset == 0)
nstate <= s0;
else
begin
if (in == 1)
nstate <= s1;
else
nstate <= s3;
end
end
default: begin
out <= 1;
nstate <= s0;
end
endcase
end
always @ (posedge clock)
begin
pstate <= nstate;
end
endmodule
A.13. Moore Machine
519

in
out
enable
Fig. A.21 Tri-state buffer implemented by conditional operator
520
Appendix: An Introduction to Verilog Hardware Design Language
A.15. Wire Assignment
The ﬁrst statement in RTL style coding is the wire statement. This statement is either
accompanied by an assign statement or declared by itself, and it resides outside the pro-
cedural block. In the ﬁrst example below, the inputs, a and b, form an XOR gate with an
output, out. Separate wire and assign statements are used to implement the XOR gate.
wire out; 
assign out = a ^ b; 
However, the two statements can be combined to form a single wire statement.
wire out = a ^ b; 
If the implementation requires multiple wires in the form of a bus, then the statements for
the node, out, can be written as follows:
wire [7:0] out; 
assign out = a ^ b; 
or
wire [7:0] out = a ^ b; 
A.16. Conditional Operator
Another useful RTL construct is the conditional operator. Assume a tri-state buffer in
Fig. A.21.

The wire statement that includes the conditional operator can be written as follows:
wire out; 
assign out = enable ? in : 1’bz;
The “?” in the above statement signiﬁes the condition for the input, enable, to be equal to
logic 1 or not. If enable is logic 0, then the output, out, becomes an open circuit. Since out is
only one bit, the high impedance state is shown as 1’bz.
The wire and assign statements can also be combined to produce a single statement.
wire out = enable ? in : 1’bz;
Another example is a 3-1 MUX shown in Fig. A.22.
wire out; 
assign out = (sel == 2’b00) ? a : (sel == 2’b01) ? b : c;
In this statement, if sel [1:0] = 00 then the output, out, becomes a. If sel [1:0] = 01 then
out becomes b. For all the other values of sel, out becomes c.
The same statement can also be written without the assign statement as:
wire out = (sel == 2’b00) ? a : (sel == 2’b01) ? b : c;
If the 3-1 MUX accepts bus inputs to produce a bus output as in Fig. A.23, then the wire
statement has to be modiﬁed to include the bus width.
a
b
c
out
0
1
2
sel [1:0]
2
Fig. A.22 A 3-1 MUX implemented by conditional operator
A.16. Conditional Operator
521

wire [7:0] out = (sel == 2’b00) ? a : (sel == 2’b01) ? b : c;
The bus width of the inputs, a, b, c and sel, should be declared in the input statements
prior to the wire statement as shown below.
…
input [7:0] a, b, c; 
input [1:0] sel; 
…
wire [7:0] out = (sel == 2’b00) ? a : (sel == 2’b01) ? b : c;
…
A.17. Memory Declaration
Memory is declared by a reg statement in Verilog. Assume an SRAM-like memory with (x+1)
number of bits and (y+1) number of rows as shown in Fig. A.24. This memory is declared as
follows:
reg [x:0] fifo [y:0]; 
Here, “ﬁfo” is the name of the memory with a dimension of [x:0] by [y:0].
x
0
y
0
y-1
Fig. A.24 (x+1) wide (y+1) deep memory
522
Appendix: An Introduction to Verilog Hardware Design Language
a
b
c
out
0
1
2
sel [1:0]
2
8
8
8
8
Fig. A.23 An eight-input 3-1 MUX implemented by conditional operator

A.18. Memory Addressing
Following the memory declaration, the memory addressing should be speciﬁed to locate a
speciﬁc data in the memory.
Assume an eight-bit wide memory with 16 rows in Fig. A.25. In order to access the most
signiﬁcant bit (msb) and the least signiﬁcant bit (lsb) of this memory at any row, an address
needs to be formed in the Verilog code.
…
input [3:0] address; 
reg [7:0] mem [15:0]; 
reg [7:0] row; 
reg msb, lsb; 
row = mem [address]; 
msb = row [7]; 
lsb = row [0]; 
…
In this example, the reg statement, reg [7:0] mem [15:0], declares a 8x16 memory with a
name, mem.
If the memory address is externally supplied to the memory, this input needs to be
declared in the input statement. Each row is declared with a second reg statement, reg [7:0]
row. Once the row declaration is ﬁnished, the most and the least signiﬁcant bits are then
declared in the third reg statement, reg msb, lsb.
Therefore,eachbitinanarbitraryrowcanbeaccessedbythestatement,row=mem[address],
in the Verilog program above. To access the most signiﬁcant bit and the least signiﬁcant bit
are accomplished by msb = row [7] and lsb = row [0], respectively.
7
0
15
0
lsb
msb
address [3:0]
Fig. A.25 An 8x16 memory
A.18. Memory Addressing
523

A.19. Memory Modeling
Different types of memory require different styles of memory modeling. The simple SRAM
memory shown in Fig. A.26 has a single bidirectional data port and operates with a clock.
The data is written to an arbitrary row or read from an arbitrary row at the positive edge of
the clock signal once the memory address is speciﬁed.
Since the data port is bidirectional, this port needs to be declared as an inout statement.
Therefore, the Verilog program can be written as follows:
7
0
15
0
14
address [3:0]
WE
RE
clock
data [7:0]
8
Fig. A.26 An 8x16 single port, bidirectional memory
524
Appendix: An Introduction to Verilog Hardware Design Language

module mem (data, address, WE, RE, clock); 
inout [7:0] data; 
input [3:0] address; 
input WE, RE, clock; 
reg [7:0] SRAM [15:0]; 
reg [7:0] data; 
reg [1:0] read_write_state; 
always @ (posedge clock) 
begin 
read_write_state = {WE, RE};       // curly brackets are for concatenating WE and RE 
case (read_write_state) 
2’b00:
data = 8’bz;
2’b01: data = SRAM [address]; 
2’b10: SRAM [address] = data; 
2’b11:
$display (“error”);  // WE and RE cannot be at logic 1 simultaneously
default: data = SRAM [address];    // SRAM needs to be in the read mode when idling 
encase 
end
endmodule 
In the example above, the case statement is formed in a procedural block because both the
read and the write cycles take place at the positive edge of the clock. When neither RE nor
WE is at logic 1, the bidirectional data port must be at a high impedance state, data = 8’bz.
When a read takes place, data is read out from a speciﬁed memory address and directed to
the bidirectional bus, data [7:0]. When a write takes place, data from the bidirectional bus is
written to a speciﬁed address, SRAM [address]. When both WE and RE are at logic 1, this
should be indicated as an error.
A set of if statements can also be used to replace the case statement except the case
statement is more compact, and it includes all possible cases to model a memory.
The following example models a unidirectional, byte addressable memory shown in
Fig. A.27 with two data ports. The input port, DataIn [31:0], is byte-addressable and
therefore contains four bytes. The output port, DataOut, is not byte-addressable, and it is
used to read all 32 bits of data. Thus,
A.19. Memory Modeling
525

module mem (DataOut, DataIn, address, clock, ByteEn, WE, RE); 
output [31:0] DataOut; 
input [31:0] DataIn; 
input [3:0] address, ByteEn; 
input clock, RE, WE; 
reg [31:0] SRAM [15:0]; 
reg [31:0] temp; 
begin 
casex (ByteEn) 
4’b0000:   temp [31:0] = 32’bz;
4’b0001:   temp [7:0] = DataIn [7:0];
4’b0010:   temp [15:8] = DataIn [15:8]; 
4’b0011:   temp [15:0] = DataIn [15:0];
4’b0100:   temp [23:16] = DataIn [23:16];
4’b0101:   begin  
                temp [23:16] = DataIn [23:16]; 
                temp [7:0] = DataIn [7:0]; 
                end 
4’b0110:  temp [23:8] = DataIn [23:8];            
…
4’b1111:  temp [31:0] = DataIn [31:0];
default:   begin 
              
temp [31:0] = 32’bx;
              
$display (“no bytes are enabled”);
              
end
endcase 
 
SRAM [address] = temp; 
end
else if  (RE == 1 && WE == 0) 
 
DataOut = SRAM [address]; 
else if  (RE == 0 && WE == 0) 
DataOut = 32’bz;
else 
display (“Error - RE and WE are enabled”);
end
endmodule 
always @ (posedge clock) 
begin 
if (WE == 1 && RE == 0) 
526
Appendix: An Introduction to Verilog Hardware Design Language

A.20. A Few Words about Functional Verification
Functional veriﬁcation is a very critical step in logic design and needs to cover every
possible corner case and input combination to a Verilog module. However, when the circuit
is not purely combinational but contains sequential components, the difﬁculty of functional
veriﬁcation increases. A proper process in this case is to isolate the sequential sections from
the combinational sections of the circuit and verify each section individually before verifying
the entire system.
When a combinational circuit goes through a formal functional veriﬁcation step, the best
method is to apply the inputs of the entire truth table as test vectors to the module, store the
circuit’s response in an output ﬁle, and then compare this output ﬁle with the one that
contains the expected outputs (the ouputs of the truth table) as shown in Fig. A.28.
However, if the circuit is sequential, each state-to-state transition needs to be examined in
the state machine when the inputs to the state change. Furthermore, the outputs from each
state need to match the expected output values.
It may be sufﬁcient to do functional check using timing diagrams if the size of the circuit
is small. However, for bigger circuits, including many combinational and sequential mod-
ules, the veriﬁcation process is applied to each individual module, and then to the entire
system. Both types of veriﬁcation are essentially a ﬁle matching process as shown in
Fig. A.28.
31
0
15
0
address [3:0]
WE
RE
clock
DataOut [31:0]
byte3
byte0
8
ByteEn [3:0]
DataIn [31:0]
8
8
8
32
32
Fig. A.27 32x16 dual port, unidirectional memory
A.20. A Few Words on Functional Verification
527

528
Appendix: An Introduction to Verilog Hardware Design Language
stimuli
(input file)
module.v
output file
compare
expected
output file
Fig. A.28 Formal functional veriﬁcation process

Index
A
Acknowledge, 381, 386, 444, 449, 453
Activating a bank, 178
Active image, 417–420, 422, 424, 426, 450, 458
ADDI instruction, 290, 291, 335
ADD instruction, 279, 280, 305, 307, 326–329, 335, 339,
360, 365, 366, 376
Address, 131–143, 146, 147, 152–156, 158–161
Address decoder, 94–97, 168–170, 198–200, 207, 208,
249
Address enable signal, 198
Address input, 201, 202
Address mode register, 177–180, 184, 190
Analog-to-digital converter (ADC), 428, 429, 431–438,
447, 448
AND-gate, 2, 3, 5, 10–13, 22, 26, 31, 34, 38, 40, 63
ANDI instruction, 290–293
AND instruction, 282–284, 326, 328
Arbiter, 132, 133, 134, 143–146, 163, 164, 166
Arbitration, 143–145, 152
Architecture, 459, 463, 478, 479, 484–489
Arithmetic Logic Unit (ALU), 273, 275, 277, 279–283,
284, 285, 287, 293–295, 305, 307, 324, 327–329,
335, 337, 338, 340, 342, 365, 373
Array multiplier, 45, 46
Asynchronous circuit, 111–113, 127, 128, 129
Asynchronous clock methodology, 121
B
Barrel shifter, 1, 42–44
Basic data-ﬂow program structure, 479
Bidirectional bus, 131–133, 159, 160
Block address, 176
Block diagram, 83, 98, 100, 105
Block erase, 243
Block protect, 206
Boolean algebra, 8
Booth multiplier, 45, 47, 52, 53, 55, 56, 60–62, 65
BRA instruction, 299, 303, 307, 312, 313, 332, 377
Buffer, 4, 7, 8
Burst, 133–136, 142, 150, 158
Burst stop, 178, 187, 188
Bus interface, 160
Busmaster, 131–161
Bus master interface, 134
Bus slave, 131, 132, 135, 136, 152, 153, 162
Bus slave interface, 136
Bypass port, 462
C
Cache, 273, 275, 344–359, 364, 367, 370, 372, 373, 375,
376
Cache topology, 344, 345
Carry-look-ahead adder, 1, 33, 35, 38, 39, 41
Carry-select adder, 1, 30, 34, 35, 40
C-element, 121–124, 125, 126, 128
Central Processing Unit (CPU), 273, 275–278, 285, 288,
290, 292–294, 297, 305, 307, 309–312, 315, 321,
324–327, 329, 333, 335–340, 344, 345, 347, 350,
352, 353, 356, 366, 370, 371, 376
Chip erase, 210, 215, 257
Chip hibernate, 261
Chip select (CS) signal, 177–179, 181–197, 261, 265
Cluster, 459, 460, 462, 463, 465, 477, 484, 487, 489, 490,
492
Column address, 181, 183, 184, 186, 190, 191, 192, 194,
195, 262, 265, 267
Column address strobe (CAS), 177–179, 182–197, 262,
265, 270
Combinational logic, 1, 11, 14, 24, 25, 33
Command enable signal, 198
Command input, 200, 201, 203
Complemented logic gate, 5
Controller design, 90, 97, 100
Counter, 67, 81, 82, 90–93, 97–100, 103, 104
Counter-decoder design, 92
D
Data, 131–141, 143, 147, 152–156, 158
Data converter, 379, 428
Data dependency, 340–343
Data driven processor, 459, 478, 479, 487
Data-ﬂow, 178, 238
© Springer International Publishing Switzerland 2017
A. Bindal, Fundamentals of Computer Architecture and Design,
DOI 10.1007/978-3-319-25811-9
529

Data-ﬂow graph, 478, 479, 482, 483, 484, 486
Data-ﬂow node, 479
Data hazards, 326, 327, 329, 336, 340, 373
Data input, 182, 212
Data memory, 287, 289–291, 310, 312, 314, 321, 325,
327, 329, 342, 344, 347, 351, 352, 354, 356, 358,
360, 378, 390, 393
Data movement instructions, 297, 299
Data output (read), 203
Data-path, 67, 73, 76, 97–99, 101, 108
Decoder, 1, 25, 26, 64
Destination address, 381, 384, 385, 442
D ﬂip-ﬂop, 70–73
Digital-to-analog converter (DAC), 433, 434, 437, 440,
441, 448
Direct-mapped cache, 345, 346, 350, 351
Direct memory access (DMA), 379, 387, 389, 442, 457
Dirty bit, 356, 357
Display adapter, 379, 380, 417, 419, 425, 426, 427, 450,
458
D latch, 67–70
Down-rounding, 434, 437, 438, 448
E
Electrically erasable programmable read only memory
(E2PROM), 167, 168, 198–203, 206, 250
Enable signal, 198
Encoder, 1, 24, 49, 56–59, 65
E2PROM cell, 199, 200
Equivalent class table, 117
Exclusive NOR-gate, 6, 22
Exclusive OR-gate, 4
F
Fast write, 211, 213, 216–220, 222–231, 233, 248, 263,
271
Fast write reset, 216–218, 228, 231
Fast write set, 211, 216, 218, 227, 230
Field-programmable-gate-array (FPGA), 459, 460, 462,
465–467, 476, 491–494
Fixed-point, 273, 279–282, 284, 287, 288–291, 293, 296,
297, 299, 301, 303–304, 307–310, 312, 324, 340,
360, 361
Flash ADC, 431–433
Flash memory, 167, 168, 198, 201, 206, 207, 208,
210–213, 215, 216, 219, 222, 227–233, 238,
240–243, 248–262, 268–270, 380
Flash memory commands, 211, 252
Floating-point, 273, 314–325, 340, 342, 376, 377, 390
Floating-point adder, 273, 321, 322, 324, 340, 377
Floating-point multiplier, 322–324, 342, 377
Flow chart, 218, 219, 220, 233, 241, 242, 263, 264, 268
Forwarding loop, 273, 367, 372, 373
Forwarding path, 327–331, 333, 335–338, 342
Full adder, 27–30, 33, 34, 46, 47, 56, 64
Full-page erase, 205, 206
Full-page write, 204, 205
Full-page-read, 205
Fully-associative cache, 344
Fundamental-Mode Circuit, 111
G
Gate, 1–8, 22, 23, 33, 34, 38, 45, 63–65
H
Half adder, 28
Handover, 146, 147
Handshake, 143
Hazard-free, 120, 125
Hazards, 273, 303, 324, 326, 329, 333, 336–338, 340, 373
Hibernate, 198, 200, 208, 252, 260
High impedance, 209
Hi-Z, 209
Hold-slack, 74, 77, 107
Hold time, 71, 74, 105–107
Hold violation, 74, 75, 77, 105
Horizontal blanking, 417, 418, 419, 422, 424, 426
I
I2C Block erase interface, 241, 243, 247
I2C Fast write interface, 271
I2C interface, 222, 232, 248
I2C Read interface, 231, 234, 239, 271
I2C start condition, 154
I2C stop condition, 154
I2C, 147, 152–157, 165
ID read, 212
IEEE double-precision format, 273, 318
IEEE single-precision format, 273, 314, 315
Image frame, 419, 422, 426
Immediate type instructions, 274
Immediate value, 274, 275, 290–297, 299, 301, 303, 305,
311, 335
Implication table, 112, 115, 116, 127, 128
Input, 67, 68, 70–72, 75–77, 79, 80, 82, 83, 87, 92–94,
100, 101, 105, 107
Input ﬂag, 482
Instruction, 273–279, 282–285, 287, 288, 290–293, 305,
307, 325, 326–329, 338, 360, 365, 366, 376
Instructional chart, 336–338, 340–343
Instruction format, 273, 283, 294, 479, 485–487
Instruction memory, 274–277, 279–281, 290, 297, 324,
332, 334, 376, 377
Inter Integrated Circuit, 147, 152
Inter-processor arbiter, 489, 490
Interrupt address table, 453
Interrupt controller, 379, 380, 389, 390, 392, 394, 397,
398, 401, 443–445, 453, 457
Interrupt generator, 411, 416, 417
Interrupt sequence, 392, 393, 395
Inverter, 5, 7, 8, 22, 63
I/O port, 209, 213, 222, 228, 230, 241, 262, 270
Iterative ﬁxed-point multiplication, 360, 361, 363
530
Index

J
JAL instruction, 303
JALR instruction, 305
JREG instruction, 301, 303, 307, 333
JUMP instruction, 301, 304, 314, 332, 335, 336
K
Karnaugh map (K-map), 1, 14–19, 21, 24, 27
L
Latency, 177, 180, 184, 186, 187, 190, 194–198, 262,
265, 266, 270
LCD display, 417
LED display, 417
Linear SDRAM addressing, 180
Linear shifter, 42
LOAD instruction, 297, 298, 305, 306, 308, 324, 328,
329, 335
Logic gate, 1, 2, 4, 5, 7, 8, 11
Look-up-table (LUT), 459–465, 462, 463, 465, 475–477,
491–493
M
Main Flash memory modes, 207
Master, 131–166
Master-in-slave-out (MISO), 148
Master-out-slave-in (MOSI), 148
Master status, 134, 136, 140, 141
Mealy machine, 87–90
Memory, 67–69, 94, 95
Micro-architecture, 487, 488
Minimization, 1, 14, 16, 17, 55
Minimization tables, 116, 127
Modes of operation, 154
Moore machine, 83–87, 89, 101, 104
MOVEI instruction, 301, 377
MOVE instruction, 297, 305, 306, 310–313
Mueller element, 111, 121
MUL instruction, 280, 281, 360, 366, 367
Multi-cycle operations, 340, 341
Multiple read cycles, 187
Multiple write cycles, 185
2-1 multiplexer, 20, 63
4-1 multiplexer, 21
Multiplier, 1, 45–47, 52, 53, 55, 56, 60–62, 64
2-1 MUX, 20, 21, 34, 39, 40, 42
4-1 MUX, 21–23
N
NAND-gate, 5, 6, 23, 63
NANDI instruction, 292, 293
NAND instruction, 283–285, 376
Next state, 83–85, 87
Nodal network, 484
Non-interlaced display, 418
Non-pipelined CPU, 276
NOP instruction, 301, 303, 329, 332, 333, 335–339, 342,
367, 373
NOR-gate, 6, 7, 63
NORI instruction, 292, 293
NOR instruction, 283–285, 376
O
One bit full adder, 27–30, 33, 34
One-bit half adder, 28, 29
One-shot timer, 411–413, 443, 457
Opcode, 279, 283, 285, 366
Operand, 273–275, 277, 279, 280, 284, 328, 366
OR-gate, 3, 4, 6, 11, 12, 22, 23, 31, 32, 34, 38, 40, 63, 64
ORI instruction, 292, 293
OR instruction, 283, 284, 376
Output, 67, 68, 70–72, 76, 79–87, 90–94, 101, 104
Output ﬂow table, 114, 115, 117, 118, 120, 124, 127, 128
Output mask, 189
P
Page address, 198, 201, 213, 215, 241– 246, 248, 255,
256
Page erase, 200, 211, 213, 241–243, 246, 256
Page write, 205, 255
Parallel bus, 131, 166
Pipeline, 285, 288–290, 293, 321, 342, 343, 348, 354,
355, 387, 396
Pipelined CPU, 290
Precharging a bank, 188, 189
Present state, 85–87, 89, 102, 103
Primitive state table, 116
Processor design, 509
Product of sums (POS), 13–15, 17–19, 22, 31, 64
Program control hazards, 285, 348
Program control instructions, 316
Program counter, 287
Programming, 483, 484, 487–489, 491, 494–500,
502–506, 512, 513
Protect bank, 182, 183, 187
Q
Quantization error, 453, 454
R
Racing condition, 114, 115, 121–123
Ramp ADC, 458, 460, 461, 473
Rate generator, 435–437, 482
Read, 133–145, 149, 150, 155–158, 160
Read enable, 96
Index
531

Read enable signal, 202, 207, 212, 219
Reading from a bank, 183
Read transfer, 140–142
Ready signal, 137, 139, 140, 144, 148, 149, 155, 164
Receiver, 423, 428–431, 474, 480
Receiver buffer, 428
Reduced Instruction Set Computer (RISC), 285, 287, 288,
290, 330, 340, 342, 350, 354, 355, 357, 384, 385,
387, 390, 396, 397
Reference voltage, 453, 456
Register, 69, 81–84, 86, 97, 99, 110
Register ﬁle, 285, 287, 340, 396
Register-to-register type instructions, 296, 302
Request, 401, 406, 407, 412, 425, 442, 469, 474, 475
RET instruction, 320
Ripple-carry adder, 1, 31, 32, 35, 65
Router, 508, 513, 514
Row address, 182, 183, 188, 189–192, 194, 193, 198,
199, 201, 202, 205–207, 211, 216, 274, 277
Row address strobe (RAS), 182–184, 186–194, 197–202,
204–206, 274, 277
S
Sample-and-hold, 453, 456
Sampling, 439, 453–456
Sampling width, 456
SCK, 149–153
SCLK, 167
S-clock, 151
2s complement addition, 42
SDRAM address mapping, 198
SDRAM bus interface, 196–198, 200, 202, 204, 206, 282,
283
SDRAM cell, 183
SDRAM core, 187, 195, 201, 202
SDRAM modes of operation, 183
SDRAM operation cycles, 183, 196
Self-refresh, 187
Sense ampliﬁer, 170–172, 182, 183, 217, 219
SEQI instruction, 309
SEQ instruction, 302
Sequential logic, 69, 99
Sequential SDRAM addressing, 184, 185
Serial bus, 133, 149, 150
Serial ﬂash memory, 170, 262–273
Serial ﬂash memory commands, 264
Serial Peripheral Interface (SPI), 149–153, 159, 167, 168
Set, 295, 299, 302, 308, 309, 316, 321, 325–327, 329,
330, 340, 361, 362, 364, 365, 367, 369, 370,
372–374, 376, 377, 384, 387, 391, 393, 396
Set-associative cache, 362, 363, 365, 367, 372, 387
Set-up slack, 79
Set-up time, 70, 73, 74, 76
Set-up violation, 73, 77
SGEI instruction, 308
SGE instruction, 299, 300
SGTI instruction, 308
SGT instruction, 300, 302
Shifter, 1, 43–45
Shift register, 69, 82, 83
Size, 135–138, 144, 160, 163
Slave, 133–145, 150–152, 154–160, 162–165
SLEI instruction, 308
SLE instruction, 302
SLI instruction, 305, 306, 326, 327, 329, 352, 380, 396
SL instruction, 296, 297, 305, 396
SLTI instruction, 308
SLT instruction, 302
SNEI instruction, 309
SNE instruction, 302
Source address, 407, 467
SPI mode 0, 152, 153
SPI mode 1, 152, 153
SPI mode 2, 152, 153
SPI mode 3, 152, 153
Square wave generator, 437, 438
SRAM bus interface, 174, 176, 177, 179, 180, 283.
SRAM cell, 171
SRAM controller, 170
SRAM core, 170–172
SRAM I/O, 172, 173
SRI instruction, 305, 306, 326, 327, 329, 396
SR instruction, 296, 297, 305, 396
S-R latch, 113, 131
SS, 150, 151
5-stage CPU, 289, 342, 353, 358
Standby, 176, 177, 179, 180, 194, 207–209, 218, 220,
275
State assignment, 113, 115, 120, 126, 127
State diagram, 85, 86, 89, 90, 92–94, 99, 110
State machine, 69, 85, 88, 92, 93, 99, 102, 103, 106, 109
State table, 85–87, 89, 90, 94
Static Random Access Memory (SRAM), 169–181, 233,
283
Status, 135–145, 160, 164
Status register, 209, 210, 213, 263, 264, 269, 272, 273
Status register read, 210, 213, 273
Step size, 453, 454, 464
STORE instruction, 312, 313, 321, 323, 325, 327, 329,
346, 347, 353, 359, 360
Structural hazards, 324, 393
SUBI instruction, 306, 352
SUB instruction, 292, 295, 343
Subtractor, 1, 42, 65
Successive approximation ADC, 461, 462, 463, 472
Sum of products (SOP), 12, 14–16, 18–22, 26, 29, 64
Synchronous Dynamic Random Access Memory
(SDRAM), 170, 181–187, 189–192, 195–206,
233, 274, 277, 278, 282, 283
System architecture, 399, 400
T
Tag comparison, 364
Timer, 399, 431–435, 437, 439, 468, 482
532
Index

Timing diagram, 69, 72, 74, 76, 79–84, 93–95, 99–103,
107–110
Timing methodology, 71, 72, 74, 75
Timing table, 288, 290
Timing violations, 69, 75, 108
Transceiver, 399, 424
Transfer, 133–145, 147–149, 154, 155, 157–160
Transition table, 87, 89, 91, 94
Transmitter, 423–428, 474, 480
Transmitter buffer, 425
Tri-state, 7, 8
Truth table, 1–7, 11–17, 20–22, 24–27, 29, 30, 31, 44, 50,
57, 59, 60, 61
U
Unidirectional bus, 133, 134, 138, 148, 160, 164, 168
Up-rounding, 459, 462, 463, 473
V
Valid bit, 345, 346, 350, 351, 354, 355, 356, 358, 364,
375
Variable clock, 122
Vertical blanking, 420, 421, 424, 445
W
2-way set-associative cache, 344, 345, 354, 362
4-way set-associative cache, 344, 345, 347, 349, 367
Weighted binary adder DAC, 440, 441
Write, 131–137, 138, 139, 141, 145, 152, 154, 156, 159
Write-back cache, 353, 357–376
Write burst, 187, 193
Write enable, 79, 94
Write enable (WE) signal, 169–182, 185–192, 195–200,
202–226, 230–233, 235–238, 240, 243, 245,
248–251, 253, 255–258, 272, 273, 275, 277, 280
Write resume, 214
Write suspend, 213
Write-through cache, 352, 354–356, 364
Write transfer, 135–137, 141, 145, 146, 152, 161
Writing into a bank, 179
X
XNOR-gate, 6, 7, 22, 64
XNORI instruction, 294, 295
XNOR instruction, 282–294, 376
XOR-gate, 4, 6, 31, 32, 39, 64
XORI instruction, 294, 295
XOR instruction, 283–284
Index
533

