
Numerical Methods
for Unconstrained
Optimization and
Nonlinear Equations

SIAM's Classics in Applied Mathematics series consists of books that were previously
allowed to go out of print. These books are republished by SIAM as a professional
service because they continue to be important resources for mathematical scientists.
Editor-in'Chief
Robert E. O'Malley, Jr., University of Washington
Editorial Board
Richard A. Brualdi, University of Wisconsin-Madison
Herbert B. Keller, California Institute of Technology
Andrzej Z. Manitius, George Mason University
Ingram Olkin, Stanford University
Stanley Richardson, University of Edinburgh
Ferdinand Verhulst, Mathematisch Instituut, University of Utrecht
Classics in Applied Mathematics
C. C. Lin and L. A. Segel, Mathematics Applied to Deterministic Problems in the
Natural Sciences
Johan G. F. Belinfante and Bernard Kolman, A Survey of Lie Groups and Lie Algebras
with Applications and Computational Methods
James M. Ortega, Numerical Analysis: A Second Course
Anthony V. Fiacco and Garth P. McCormick, Nonlinear Programming: Sequential
Unconstrained Minimization Techniques
F. H. Clarke, Optimisation and Nonsmooth Analysis
George F. Carrier and Carl E. Pearson, Ordinary Differential 
Equations
Leo Breiman, Probability
R. Bellman and G. M. Wing, An Introduction to Invariant Imbedding
Abraham Berman and Robert J. Plemmons, Nonnegative Matrices in the Mathemat-
ical Sciences
Olvi L. Mangasarian, Nonlinear Programming
*Carl Friedrich Gauss, Theory of the Combination of Observations Least Subject
to Errors: Part One, Part Two, Supplement. Translated by G. W. Stewart
Richard Bellman, Introduction to Matrix Analysis
U. M. Ascher, R. M. M. Mattheij, and R. D. Russell, Numerical Solution of Boundary
Value Problems for Ordinary Differential 
Equations
K. E. Brenan, S. L. Campbell, and L. R. Petzold, Numerical Solution of Initial-Value
Problems in Differential-Algebraic 
Equations
Charles L. Lawson and Richard J. Hanson, Solving Least Squares Problems
J. E. Dennis, Jr. and Robert B. Schnabel, Numerical Methods for Unconstrained
Optimization and Nonlinear Equations
Richard E. Barlow and Frank Proschan, Mathematica/ Theory of Reliability
Cornelius Lanczos, Linear Differential 
Operators
Richard Bellman, Introduction to Matrix Analysis, Second Edition
Beresford N. Parlett, The Symmetric Eigenvalue Problem
*First time in print.

Classics in Applied Mathematics (continued)
Richard Haberman, Mathematical Models: Mechanical Vibrations, Population
Dynamics, and Traffic 
Flow
Peter W. M. John, Statistical Design and Analysis of Experiments
Tamer Ba§ar and Geert Jan Olsder, Dynamic Noncooperative Game Theory, Second
Edition
Emanuel Parzen, Stochastic Processes
Petar Kokotovic, Hassan K. Khalil, and John O'Reilly, Singular Perturbation Methods
in Control: Analysis and Design
Jean Dickinson Gibbons, Ingram Olkin, and Milton Sobel, Selecting and Ordering
Populations: A New Statistical Methodology
James A. Murdock, Perturbations: Theory and Methods
Ivar Ekeland and Roger Temam, Convex Analysis and Variational Problems
Ivar Stakgold, Boundary Value Problems of Mathematical Physics, Volumes I and II
J. M. Ortega and W. C. Rheinboldt, Iterative Solution of Nonlinear Equations in
Several Variables
David Kinderlehrer and Guido Stampacchia, An Introduction to Variational
Inequalities and Their Applications
F. Natterer, The Mathematics of Computerized Tomography
Avinash C. Kak and Malcolm Slaney, Principles of Computerized Tomographic Imaging
R. Wong, Asymptotic Approximations of Integrals
O. Axelsson and V. A. Barker, Finite Element Solution of Boundary Value Problems:
Theory and Computation
David R. Brillinger, Time Series: Data Analysis and Theory
Joel N. Franklin, Methods of Mathematical Economics: Linear and Nonlinear
Programming, Fixed-Point Theorems
Philip Hartman, Ordinary Differential Equations, Second Edition
Michael D. Intriligator, Mathematical Optimization and Economic Theory
Philippe G. Ciarlet, The Finite Element Method for Elliptic Problems
Jane K. Cullum and Ralph A. Willoughby, Lanczos Algorithms for Large Symmetric
Eigenvalue Computations, Vol. I: Theory
M. Vidyasagar, Nonlinear Systems Analysis, Second Edition
Robert Mattheij and Jaap Molenaar, Ordinary Differential Equations in Theory and
Practice
Shanti S. Gupta and S. Panchapakesan, Multiple Decision Procedures: Theory and
Methodology of Selecting and Ranking Populations
Eugene L. Allgower and Kurt Georg, Introduction to Numerical Continuation Methods
Heinz-Otto Kreiss and Jens Lorenz, Initial-Boundary Value Problems and the Navier-
Stofces Equations

Copyright © 1996 by the Society for Industrial and Applied Mathematics.
This SIAM edition is an unabridged, corrected republication of the work first
published by Prentice-Hall, Inc., Englewood Cliffs, NJ, 1983.
1 0 9 8 7 6 5
All rights reserved. Printed in the United States of America. No part of this book
may be reproduced, stored, or transmitted in any manner without the written
permission of the publisher. For information, write to the Society for Industrial and
Applied Mathematics, 3600 University City Science Center, Philadelphia, PA 19104-
2688.
Library of Congress Cataloging-in-Publication Data
Dennis, J. E. ( John E. ) , 1939-
Numerical methods for unconstrained optimization and nonlinear
equations / J.E. Dennis, Jr., Robert B. Schnabel .
p. cm. — ( Classics in applied mathematics ; 16 )
Originally published : Englewood Cliffs, NJ. : Prentice-Hall,
©1983.
Includes bibliographical references and indexes.
ISBN 0-89871-364-1 ( pbk )
1. Mathematical optimization. 
2. Equations—Numerical solutions.
I. Schnabel, Robert B. II. Title III. Series.
QA402.5.D44 
1996 
95-51776
The royalties from the sales of this book are being placed in a fund to help
students attend SIAM meetings and other SIAM related activities. This fund
is administered by SIAM and qualified individuals are encouraged to write directly to
SIAM for guidelines.
•
is a registered trademark.

Numerical Methods
for Unconstrained
Optimization and
Nonlinear Equations
J. R Dennis, Jr.
Rice University
Houston, Texas
Robert B. Schnabel
University of Colorado
Boulder, Colorado
siaiiL
Society for Industrial and Applied Mathematics
Philadelphia

To Catherine, Heidi, and Cory

Contents
PREFACE TO THE CLASSICS EDITION 
xi
PREFACE 
xiii
1 
INTRODUCTION 
2
1.1 Problems to be considered 2
1.2 Characteristics of "real-world" problems 5
1.3 Finite-precision arithmetic and measurement of error 10
1.4 Exercises 13
21 
NONLINEAR PROBLEMS
IN ONE VARIABLE 
15
2.1 What is not possible 75
2.2 Newton's method for solving one equation in one unknown 16
2.3 Convergence of sequences of real numbers 19
2.4 Convergence of Newton's method 21
2.5 Globally convergent methods for solving one equation in one unknown 24
2.6 Methods when derivatives are unavailable 27
2.7 Minimization of a function of one variable 32
2.8 Exercises 36
vii

viii 
Contents
3 
NUMERICAL LINEAR
ALGEBRA BACKGROUND 
40
3.1 Vector and matrix norms and orthogonality 41
3.2 Solving systems of linear equations—matrix factorizations 47
3.3 Errors in solving linear systems 51
3.4 Updating matrix factorizations 55
3.5 Eigenvalues and positive definiteness 58
3.6 Linear least squares 60
3.7 Exercises 66
41 
MULTIVARIABLE CALCULUS BACKGROUND 
69
4.1 Derivatives and multivariable models 69
4.2 Multivariable finite-difference derivatives 77
4.3 Necessary and sufficient conditions for unconstrained minimization 80
4.4 Exercises 83
5 
NEWTON'S METHOD
FOR NONLINEAR 
EQUATIONS
AND UNCONSTRAINED MINIMIZATION 
86
5.1 Newton's method for systems of nonlinear equations 86
5.2 Local convergence of Newton's method 89
5.3 The Kantorovich and contractive mapping theorems 92
5.4 Finite-difference derivative methods for systems of nonlinear equations 94
5.5 Newton's method for unconstrained minimization 99
5.6 Finite-difference derivative methods for unconstrained minimization 103
5.7 Exercises 107
6 
GLOBALLY CONVERGENT MODIFICATIONS
OF NEWTON'S METHOD 
111
6.1 The quasi-Newton framework 112
6.2 Descent directions 113
6.3 Line searches 776
6.3.1 Convergence results for properly chosen steps 
120
6.3.2 Step selection by backtracking 126
6.4 The model-trust region approach 729
6.4.1 The locally constrained optimal ("hook") step 134
6.4.2 The double dogleg step 139
6.4.3 Updating the trust region 143
6.5 Global methods for systems of nonlinear equations 147
6.6 Exercises 752

Contents 
ix
7 STOPPING, SCALING, AND TESTING 155
7.1 Scaling 155
7.2 Stopping criteria 759
7.3 Testing 767
7.4 Exercises 164
8 
SECANT METHODS FOR SYSTEMS
OF NONLINEAR EQUATIONS 
168
8.1 Broyden's method 769
8.2 Local convergence analysis of Broyden's method 174
8.3 Implementation of quasi-Newton algorithms using Broyden's update 186
8.4 Other secant updates for nonlinear equations 189
8.5 Exercises 790
9 
SECANT METHODS
FOR UNCONSTRAINED MINIMIZATION 
194
9.1 The symmetric secant update of Powell 795
9.2 Symmetric positive definite secant updates 198
9.3 Local convergence of positive definite secant methods 203
9.4 Implementation of quasi-Newton algorithms using the positive definite secant
update 205
9.5 Another convergence result for the positive definite secant method 270
9.6 Other secant updates for unconstrained minimization 277
9.7 Exercises 272
10 
NONLINEAR LEAST SQUARES 
218
10.1 The nonlinear least-squares problem 218
10.2 Gauss-Newton-type methods 227
10.3 Full Newton-type methods 228
10.4 Other considerations in solving nonlinear least-squares problems 233
10.5 Exercises 236
11 
METHODS FOR PROBLEMS
WITH SPECIAL STRUCTURE 
239
11.1 The sparse finite-difference Newton method 240
11.2 Sparse secant methods 242
11.3 Deriving least-change secant updates 246
11.4 Analyzing least-change secant methods 257
11.5 Exercises 256

x Contents
A APPENDIX: A MODULAR SYSTEM
OF ALGORITHMS
FOR UNCONSTRAINED MINIMIZATION
AND NONLINEAR EQUATIONS 
259
(by Robert Schnabel)
B 
APPENDIX: TEST PROBLEMS 
361
(by Robert Schnabel)
REFERENCES 
364
AUTHOR INDEX 
371
SUBJECT INDEX 
373

Preface to the Classics Edition
We are delighted that SI AM is republishing our original 1983 book after what many
in the optimization field have regarded as "premature termination" by the previous
publisher. At 12 years of age, the book may be a little young to be a "classic," but since
its publication it has been well received in the numerical computation community. We
are very glad that it will continue to be available for use in teaching, research, and
applications.
We set out to write this book in the late 1970s because we felt that the basic techniques
for solving small to medium-sized nonlinear equations and unconstrained optimization
problems had matured and converged to the point where they would remain relatively
stable. Fortunately, the intervening years have confirmed this belief. The material that
constitutes most of this book—the discussion of Newton-based methods, globally
convergent line search and trust region methods, and secant (quasi-Newton) methods
for nonlinear equations, unconstrained optimization, and nonlinear least squares-
continues to represent the basis for algorithms and analysis in this field. On the teaching
side, a course centered around Chapters 4 to 9 forms a basic, in-depth introduction to
the solution of nonlinear equations and unconstrained optimization problems. For
researchers or users of optimization software, these chapters give the foundations of
methods and software for solving small to medium-sized problems of these types.
We have not revised the 1983 book, aside from correcting all the typographical errors
that we know of. (In this regard, we especially thank Dr. Oleg Burdakov who, in the
process of translating the book for the Russian edition published by Mir in 1988, found
numerous typographical errors.) A main reason for not revising the book at this time
is that it would have delayed its republication substantially. A second reason is that there
appear to be relatively few places where the book needs updating. But inevitably there
are some. In our opinion, the main developments in the solution of small to medium-
sized unconstrained optimization and nonlinear equations problems since the publication
of this book, which a current treatment should include, are
1. improved algorithms and analysis for trust region methods
for unconstrained optimization in the case when the Hessian
matrix is indefinite [1, 2] and
2. improved global convergence analysis for secant
(quasi-Newton) methods 13).
A third, more recent development is the field of automatic (or computational)
differentiation [4]. Although it is not yet fully mature, it is clear that this development
is increasing the availability of analytic gradients and Jacobians and therefore reducing the
cases where finite difference approximations to these derivatives are needed. A fourth,
more minor but still significant development is a new, more stable modified Cholesky
factorization method [5, 61. Far more progress has been made in the solution of large
nonlinear equations and unconstrained optimization problems. This includes the
XI

x i i 
Preface to the Classics Edition
development or improvement of conjugate gradient, truncated-Newton, Krylov-subspace,
and limited-memory methods. Treating these fully would go beyond the scope of this
book even if it were revised, and fortunately some excellent new references are emerging,
including [71. Another important topic that is related to but not within the scope of this
book is that of new derivative-free methods for unconstrained optimization (8).
The appendix of this book has had an impact on software in this field. The IMSL library
created their unconstrained optimization code from this appendix, and the UNCMIN
software [9] created in conjunction with this appendix has been and continues to be a
widely used package for solving unconstrained optimization problems. This software
also has been included in a number of software packages and other books. The UNCMIN
software continues to be available from the second author (bobby@cs.colorado.edu).
Finally, one of the most important developments in our lives since 1983 has been the
emergence of a new generation: a granddaughter for one of us, a daughter and son for
the other. This new edition is dedicated to them in recognition of the immense joy they
have brought to our lives and with all our hopes and wishes for the lives that lay ahead
for them.
[ 1 ] J. J. More and D. C. Sorensen, Computing a trust region step, S1AM J. Sci.
Statist. Comput., 4 (1983), pp. 553-572.
[2] G. A. Shultz, R. B. Schnabel, and R. H. Byrd, A family of trust region based
algorithms for unconstrained minimization with strong global convergence
properties, SIAM J. Numer. Anal., 22 (1985), pp. 47-67.
[3] R. H. Byrd, J. Nocedal, and Y. Yuan, Global convergence of a class of quasi-
Newton methods on convex problems, SIAM J. Numer. Anal., 24 (1987), pp.
1171-1189.
[4] A. Griewank and G. F. Corliss, eds., Automatic Differentiation of Algorithms:
Theory, Implementation, and Application, Society for Industrial and Applied
Mathematics, Philadelphia, PA, 1991.
[5J R. B. Schnabel and E. Eskow, A new modified Cholesky factorization, SIAM J.
Sci. Statist. Comput., 11 (1990), pp. 1136-1158.
[6] E. Eskow and R. B. Schnabel, Software for a new modified Cholesky
factorization, ACM Trans. Math. Software, 17 (1991), pp. 306-312.
[7] C. T. Kelley, Iterative Methods for Linear and Nonlinear Equations, Society for
Industrial and Applied Mathematics, Philadelphia, PA, 1995.
[8] J. E. Dennis, Jr. and V. Torczon, Direct search methods on parallel computers,
SIAM J. Optim., 1 (1991), pp. 448-474.
(9J R. B. Schnabel, J. E. Koontz, and B. E. Weiss, A modular system of algorithms
for unconstrained minimization, ACM Trans. Math. Software, 11 (1985), pp. 419—440.

Preface
This book offers a careful introduction, at a low level of mathematical and
computational sophistication, to the numerical solution of problems in un-
constrained optimization and systems of nonlinear equations. We have written
it, beginning in 1977, because we feel that the algorithms and theory for small-
to-medium-size problems in this field have reached a mature state, and that a
comprehensive reference will be useful. The book is suitable for graduate or
upper-level undergraduate courses, but also for self-study by scientists, en-
gineers, and others who have a practical interest in such problems.
The minimal background required for this book would be calculus and
linear algebra. The reader should have been at least exposed to multivariable
calculus, but the necessary information is surveyed thoroughly in Chapter 4.
Numerical linear algebra or an elementary numerical methods course would
be helpful; the material we use is covered briefly in Section 1.3 and Chapter 3.
The algorithms covered here are all based on Newton's method. They
are often called Newton-like, but we prefer the term quasi-Newton. Unfortu-
nately, this term is used by specialists for the subclass of these methods co-
vered in our Chapters 8 and 9. Because this subclass consists of sensible
multidimensional generalizations of the secant method, we prefer to call them
secant methods. Particular secant methods are usually known by the proper
names of their discoverers, and we have included these servings of alphabet
soup, but we have tried to suggest other descriptive names commensurate with
their place in the overall scheme of our presentation.
The heart of the book is the material on computational methods for
xiii

xiv 
Preface
multidimensional unconstrained optimization and nonlinear equation prob-
lems covered in Chapters 5 through 9. Chapter 1 is introductory and will be
more useful for students in pure mathematics and computer science than for
readers with some experience in scientific applications. Chapter 2, which
covers the one-dimensional version of our problems, is an overview of our
approach to the subject and is essential motivation. Chapter 3 can be omitted
by readers who have studied numerical linear algebra, and Chapter 4 can be
omitted by those who have a good background in multivariable calculus.
Chapter 10 gives a fairly complete treatment of algorithms for nonlinear least
squares, an important type of unconstrained optimization problem that, owing
to its special structure, is solved by special methods. It draws heavily on the
chapters that precede it. Chapter 11 indicates some research directions in
which the field is headed; portions of it are more difficult than the preceding
material.
We have used the book for undergraduate and graduate courses. At the
lower level, Chapters 1 through 9 make a solid, useful course; at the graduate
level the whole book can be covered. With Chapters 1, 3, and 4 as remedial
reading, the course takes about one quarter. The remainder of a semester is
easily filled with these chapters or other material we omitted.
The most important omitted material consists of methods not related to
Newton's method for solving unconstrained minimization and nonlinear equa-
tion problems. Most of them are important only in special cases. The Nelder-
Meade simplex algorithm [see, e.g., Avriel (1976)], an effective algorithm for
problems with less than five variables, can be covered in an hour. Conjugate
direction methods [see, e.g., Gill, Murray, and Wright (1981)] properly belong
in a numerical linear algebra course, but because of their low storage require-
ments they are useful for optimization problems with very large numbers of
variables. They can be covered usefully in two hours and completely in two
weeks.
The omission we struggled most with is that of the Brown-Brent meth-
ods. These methods are conceptually elegant and startlingly effective for partly
linear problems with good starting points. In their current form they are not
competitive for general-purpose use, but unlike the simplex or conjugate-
direction algorithms, they would not be covered elsewhere. This omission can
be remedied in one or two lectures, if proofs are left out [see, e.g., Dennis
(1977)]. The final important omission is that of the continuation or homotopy-
based methods, which enjoyed a revival during the seventies. These elegant
ideas can be effective as a last resort for the very hardest problems but are not
yet competitive for most problems. The excellent survey by Allgower and
Georg (1980) requires at least two weeks.
We have provided many exercises; many of them further develop ideas
that are alluded to briefly in the text. The large appendix (by Schnabel) is
intended to provide both a mechanism for class projects and an important
reference for readers who wish to understand the details of the algorithms and

Preface xv
perhaps to develop their own versions. The reader is encouraged to read the
preface to the appendix at an early stage.
Several problems of terminology and notation were particularly trouble-
some. We have already mentioned the confusion over the terms "quasi-
Newton" and "secant methods." In addition, we use the term "unconstrained
optimization" in the title but "unconstrained minimization" in the text, since
technically we consider only minimization. For maximization, turn the prob-
lems upside-down. The important term "global" has several interpretations,
and we try to explain ours clearly in Section 1.1. Finally, a major notational
problem was how to differentiate between the ith component of an n-vector x,
a scalar usually denoted by x,, and the ith iteration in a sequence of such x's, a
vector also usually denoted x,. After several false starts, we decided to allow
this conflicting notation, since the intended meaning is always clear from the
context; in fact, the notation is rarely used in both ways in any single section
of the text.
We wanted to keep this book as short and inexpensive as possible with-
out slighting the exposition. Thus, we have edited some proofs and topics in a
merciless fashion. We have tried to use a notion of rigor consistent with good
taste but subservient to insight, and to include proofs that give insight while
omitting those that merely substantiate results. We expect more criticism for
omissions than for inclusions, but as every teacher knows, the most difficult
but important part in planning a course is deciding what to leave out.
We sincerely thank Idalia Cuellar, Arlene Hunter, and Dolores Pendel
for typing the numerous drafts, and our students for their specific identifi-
cation of unclear passages. David Gay, Virginia Klema, Homer Walker, Pete
Stewart, and Layne Watson used drafts of the book in courses at MIT,
Lawrence Livermore Laboratory, University of Houston, University of New
Mexico, University of Maryland, and VPI, and made helpful suggestions.
Trond Steihaug and Mike Todd read and commented helpfully on portions of
the text.
Rice University 
J. E. Dennis, Jr.
University of Colorado at Boulder 
Robert B. Schnabel

This page intentionally left blank 

Before we begin, a program note
The first four chapters of this book contain the background material
and motivation for the study of multivariable nonlinear problems. In
Chapter 1 we introduce the problems we will be considering. Chapter
2 then develops some algorithms for nonlinear problems in just one
variable. By developing these algorithms in a way that introduces the
basic philosophy of all the nonlinear algorithms to be considered in
this book, we hope to provide an accessible and solid foundation for
the study of multivariable nonlinear problems. Chapters 3 and 4 con-
tain the background material in numerical linear algebra and multi-
variable calculus required to extend our consideration to problems in
more than one variable.
1

1
Introduction
This book discusses the methods, algorithms, and analysis involved in the
computational solution of three important nonlinear problems: solving sys-
tems of nonlinear equations, unconstrained minimization of a nonlinear func-
tional, and parameter selection by nonlinear least squares. Section 1.1 intro-
duces these problems and the assumptions we will make about them. Section
1.2 gives some examples of nonlinear problems and discusses some typical
characteristics of problems encountered in practice; the reader already familiar
with the problem area may wish to skip it. Section 1.3 summarizes the features
of finite-precision computer arithmetic that the reader will need to know in
order to understand the computer-dependent considerations of the algorithms
in the text.
1.1 PROBLEMS TO BE CONSIDERED
This book discusses three nonlinear problems in real variables that arise often
in practice. They are mathematically equivalent under fairly reasonable hy-
potheses, but we will not treat them all with the same algorithm. Instead we
will show how the best current algorithms seek to exploit the structure of each
problem.
The simultaneous nonlinear equations problem (henceforth called " nonlin-
ear equations") is the most basic of the three and has the least exploitable
2

structure. It is
Introduction Chap. 1 
3
where Rn denotes n-dimensional Euclidean space. Of course, (1.1.1) is just the
standard way of denoting a system of n nonlinear equations in n unknowns,
with the convention that right-hand side of each equation is zero. An example
is
which has F(x* = 0 for x, = (1, -2)T
Certainly the x* that solves (1.1.1) would be a minimizer of
where fi (x) denotes the ith component function of F. This is a special case of
the unconstrained minimization problem
which is the second problem we will consider. Usually (1.1.2) is abbreviated to
An example is
which has the solution x* = (3, — 5, 8)T.
In some applications, one is interested in solving a constrained version of
(1.1.3),
where Q is a closed connected region. If the solution to (1.1.4) lies in the
interior of 
then (1.1.4) can still be viewed as an unconstrained minimization
problem. However, if x* is a boundary point of 
then the minimization of f
over 
becomes a constrained minimization problem. We will not consider the
constrained problem because less is known about how it should be solved, and
there is plenty to occupy us in considering unconstrained problems. Fur-
thermore, the techniques for solving unconstrained problems are the founda-
tion for constrained-problem algorithms. In fact, many attempts to solve
constrained problems boil down to either solving a related unconstrained

4 
Chap. 1 
Introduction
minimization problem whose solution x is at least very near the solution x,, of
the constrained problem, or to finding a nonlinear system of equations whose
simultaneous solution is the same x* . Finally, a large percentage of the prob-
lems that we have met in practice are either unconstrained or else constrained
in a very trivial way—for example, every component of x might have to be
nonnegative.
The third problem that we consider is also a special case of un-
constrained minimization, but owing to its importance and its special structure
it is a research area all by itself. This is the nonlinear least-squares problem:
where ri(x) denotes the ith component function of R. Problem (1.1.5) is most
frequently met within the context of curve fitting, but it can arise whenever a
nonlinear system has more nonlinear requirements than degrees of freedom.
We are concerned exclusively with the very common case when the
nonlinear functions F, f, or R are at least once, twice, or twice continuously
differentiable, respectively. We do not necessarily assume that the derivatives
are analytically available, only that the functions are sufficiently smooth. For
further comments on the typical size and other characteristics of nonlinear
problems being solved today, see Section 1.2.
The typical scenario in the numerical solution of a nonlinear problem is
that the user is asked to provide a subroutine to evaluate the problem func-
tion (S), and a starting point x0 that is a crude approximation to the solution
x*. If they are readily available, the user is asked to provide first and perhaps
second derivatives. Our emphasis in this book is on the most common diffi-
culties encountered in solving problems in this framework: (1) what to do if
the starting guess x0 is not close to the solution x* ("global method") and how
to combine this effectively with a method that is used in the vicinity of the
answer ("local method"); (2) what to do if analytic derivatives are not avail-
able; and (3) the construction of algorithms that will be efficient if evaluation
of the problem function(s) is expensive. (It often is, sometimes dramatically so.)
We discuss the basic methods and supply details of the algorithms that are
currently considered the best ones for solving such problems. We also give the
analysis that we believe is relevant to understanding these methods and ex-
tending or improving upon them in the future. In particular, we try to identify
and emphasize the ideas and techniques that have evolved as the central ones
in this field. We feel that the field has jelled to a point where these techniques
are identifiable, and while some improvement is still likely, one no longer
expects new algorithms to result in quantum jumps over the best being used
today.
The techniques for solving the nonlinear equations and unconstrained
minimization problems are closely related. Most of the book is concerned with

Introduction 
Chap. 1 
5
these two problems. The nonlinear least-squares problem is just a special case
of unconstrained minimization, but one can modify unconstrained mini-
mization techniques to take special advantage of the structure of the nonlinear
least-squares problem and produce better algorithms for it. Thus Chapter 10 is
really an extensive worked-out example that illustrates how to apply and
extend the preceding portion of the book.
One problem that we do not address in this book is finding the "global
minimizer" of a nonlinear functional—that is, the absolute lowest point of
f(x) in the case when there are many distinct local minimizers, solutions to
(1.1.2) in open connected regions of Rn. This is a very difficult problem that is
not nearly as extensively studied or as successfully solved as the problems we
consider; two collections of papers on the subject are Dixon and Szego (1975,
1978). Throughout this book we will use the word "global," as in "global
method" or "globally convergent algorithm" to denote a method that is de-
signed to converge to a local minimizer of a nonlinear functional or some
solution of a system of nonlinear equations, from almost any starting point. It
might be appropriate to call such methods local or locally convergent, but
these descriptions are already reserved by tradition for another usage. Any
method that is guaranteed to converge from every starting point is probably
too inefficient for general use [see Allgower and Georg (1980)].
1.2 CHARACTERISTICS OF "REAL-WORLD"
PROBLEMS
In this section we attempt to provide some feeling for nonlinear problems
encountered in practice. First we give three real examples of nonlinear pro-
blems and some considerations involved in setting them up as numerical prob-
lems. Then we make some remarks on the size, expense, and other character-
istics of nonlinear problems encountered in general.
One difficulty with discussing sample problems is that the background
and algebraic description of problems in this field is rarely simple. Although
this makes consulting work interesting, it is of no help in the introductory
chapter of a numerical analysis book. Therefore we will simplify our examples
when possible.
The simplest nonlinear problems are those in one variable. For example,
a scientist may wish to determine the molecular configuration of a certain
compound. The researcher derives an equation f(x) giving the potential energy
of a possible configuration as a function of the tangent x of the angle between
its two components. Then, since nature will cause the molecule to assume the
configuration with the minimum potential energy, it is desirable to find the x
for which f(x) is minimized. This is a minimization problem in the single
variable x. It is likely to be highly nonlinear, owing to the physics of the
function f It truly is unconstrained, since x can take any real value. Since the

6 
Chap. 1 
Introduction
problem has only one variable, it should be easy to solve by the techniques of
Chapter 2. However, we have seen related problems where / was a function of
between 20 and 100 variables, and although they were not difficult to solve, the
evaluations of f cost between $5 and $100 each, and so they were expensive to
solve.
A second common class of nonlinear problems is the choice of some best
one of a family of curves to fit data provided by some experiment or from
some sample population. Figure 1.2.1 illustrates an instance of this problem
that we encountered: 20 pieces of solar spectroscopy data y, taken at wave-
lengths ti were provided by a satellite, and the underlying theory implied that
any m such pieces of data (r1, y1), ..., (tm, ym), could be fitted by a bell-shaped
curve. In practice, however, there was experimental error in the points, as
shown in the figure. In order to draw conclusions from the data, one wants to
find the bell-shaped curve that comes "closest" to the m points. Since the
general equation for a bell-shaped curve is
this means choosing x1, x2, x3, and x4 to minimize some aggregate measure of
the discrepancies (residuals) between the data points and the curve; they are
given by
The most commonly used aggregate measure is the sum of the squares of the
r,'s, leading to determination of the bell-shaped curve by solution of the
nonlinear least-squares problem,
Some comments are in order. First, the reason problem (1.2.1) is called a
nonlinear least-squares problem is that the residual functions r,(x) are nonlin-
ear functions of some of the variables xt, x2, x3, x4. Actually ri is linear in x1
and x2, and some recent methods take advantage of this (see Chapter 10).
Second, there are functions other than the sum of squares that could be chosen
to measure the aggregate distance of the data points from the bell-shaped
Figure 1.2.1 Data points to be fitted with a bell-shaped curve.

Introduction Chap. 1 
7
curve. Two obvious choices are
and
The reasons one usually chooses to minimize f (x) rather than f1 (x) orf00(x) are
sometimes statistical and sometimes that the resultant optimization problem is
far more mathematically tractable, since the least-squares function is continu-
ously differentiable and the other two are not. In practice, most data-fitting
problems are solved using least squares. Often / is modified by introducing
"weights" on the residuals, but this is not important to our discussion here.
As a final example, we give a version of a problem encountered in
studying nuclear fusion reactors. A nuclear fusion reactor would be shaped
like a doughnut, with some hot plasma inside (see Figure 1.2.2). An illustrative
simplification of the actual problem is that we were asked to find the combi-
nation of the inner radius (r), width of the doughnut (w), and temperature of
the plasma (t) that would lead to the lowest cost per unit of energy. Scientists
had determined that the cost per unit of energy was modeled by
where cl c2, c3, c4 are constants. Thus the nonlinear problem was to mini-
mize/as a function of r, w, and t.
There were, however, other important aspects to this problem. The first
was that, unlike the variables in the previous examples, r, w, and t could not
assume arbitrary real values. For example, r and w could not be negative.
Figure 1.2.2 Nuclear fusion reactor.

8 
Chap. 1 Introduction
Therefore, this was a constrained minimization problem. Altogether there were
five simple linear constraints in the three variables.
It is important to emphasize that a constrained problem must be treated
as such only if the presence of the constraints is expected to affect the solution,
in the sense that the solution to the constrained problem is expected not to be
a minimizer of the same function without the constraints. In the nuclear
reactor problem, the presence of the constraints usually did make a difference,
and so the problem was solved by constrained techniques. However, many
problems with simple constraints, such as bounds on the variables, can be
solved by unconstrained algorithms, because the constraints are satisfied by
the unconstrained minimizer.
Notice that we said the constraints in the nuclear reactor problem us-
ually made a difference. This is because we were actually asked to solve 625
instances of the problem, using different values for the constants cl c2, c3, and
c4. These constant values depended on factors, such as the cost of electricity,
that would be constant at the time the reactor was running, but unknown until
then. It was necessary to run different instances of the problem in order to see
how the optimal characteristics of the reactor were affected by changes in these
factors. Often in practical applications one wants to solve many related in-
stances of a particular problem; this makes the efficiency of the algorithm
more important. It also makes one willing to experiment with various algo-
rithms initially, to evaluate them on the particular class of problems.
Finally, equation (1.2.2) was only the simple model of the nuclear fusion
reactor. In the next portion of the study, the function giving the cost per unit
of energy was not an analytic formula like (1.2.2); rather it was the output
from a model of the reactor involving partial differential equations. There were
also five more parameters (see Figure 1.2.3). The minimization of this sort of
function is very common in nonlinear optimization, and it has some important
influences on our algorithm development. First, a function like this is probably
accurate to only a few places, so it wouldn't make sense to ask for many places
of accuracy in the solution. Second, while the function / may be many times
continuously differentiable, its derivatives usually are not obtainable. This is
one reason why derivative approximation becomes so important. And finally,
evaluation of / may be quite expensive, further stimulating the desire for
efficient algorithms.
The problems above give some indication of typical characteristics of
nonlinear problems. The first is their size. While certainly there are problems
Figure 1.23 
Function evaluation in refined model of the nuclear reactor
problem.

Introduction 
Chap. 1 
9
that have more variables than those discussed above, most of the ones we see
have relatively few variables, say 2 to 30. The state of the art is such that we
hope to be able to solve most of the small problems, say those with from 2 to
15 variables, but even 2-variable problems can be difficult. Intermediate prob-
lems in this field are those with from 15 to 50 variables; current algorithms
will solve many of these. Problems with 50 or more variables are large prob-
lems in this field; unless they are only mildly nonlinear, or there is a good
starting guess, we don't have a good chance of solving them economically.
These size estimates are very volatile and depend less on the algorithms than
on the availability of fast storage and other aspects of the computing environ-
ment.
A second issue is the availability of derivatives. Frequently we deal with
problems where the nonlinear function is itself the result of a computer simula-
tion, or is given by a long and messy algebraic formula, and so it is often the
case that analytic derivatives are not readily available although the function is
several times continuously differentiable. Therefore it is important to have
algorithms that work effectively in the absence of analytic derivatives. In fact,
if a computer-subroutine library includes the option of approximating deriva-
tives, users rarely will provide them analytically—who can blame them?
Third, as indicated above, many nonlinear problems are quite expensive
to solve, either because an expensive nonlinear function is evaluated repeatedly
or because the task is to solve many related problems. We have heard of a
50-variable problem in petroleum engineering where each function evaluation
costs 100 hours of IBM 3033 time. Efficiency, in terms of algorithm running
time and function and derivative evaluations, is an important concern in de-
veloping nonlinear algorithms.
Fourth, in many applications the user expects only a few digits of accu-
racy in the answer. This is primarily due to the approximate nature of the
other parts of the problem: the function itself, other parameters in the model,
the data. On the other hand, users often ask for more digits than they need.
Although it is reasonable to want extra accuracy, just to be reasonably sure
that convergence has been attained, the point is that the accuracy required is
rarely near the computer's precision.
A fifth point, not illustrated above, is that many real problems are poorly
scaled, meaning that the sizes of the variables differ greatly. For example, one
variable may always be in the range 106 to 107 and another in the range 1 to
10. In our experience, this happens surprisingly often. However, most work in
this field has not paid attention to the problem of scaling. In this book we try
to point out where ignoring the affects of scaling can degrade the performance
of nonlinear algorithms, and we attempt to rectify these deficiencies in our
algorithms.
Finally, in this book we discuss only those nonlinear problems where the
unknowns can have any real value, as opposed to those where some variables
must be integers. All our examples had this form, but the reader may wonder if

10 
Chap. 1 Introduction
this is a realistic restriction in general. The answer is that there certainly are
nonlinear problems where some variables must be integers because they rep-
resent things like people, trucks, or large widgits. However, this restriction
makes the problems so much more difficult to solve—because all continuity is
lost—that often we can best solve them by regarding the discrete variables as
continuous and then rounding the solution values to integers as necessary. The
theory does not guarantee this approach to solve the corresponding integer
problem, but in practice it often produces reasonable answers. Exceptions are
problems where some discrete variables are constrained to take only a few
values such as 0, 1, or 2. In this case, discrete methods must be used. [See, e.g.,
Beale (1977), Garfinkel and Nemhauser (1972).]
1.3 FINITE-PRECISION ARITHMETIC
AND MEASUREMENT OF ERROR
Some features of our computer algorithms, such as tests for convergence,
depend on how accurately real numbers are represented on the computer. On
occasion, arithmetical coding also is influenced by an understanding of com-
puter arithmetic. Therefore, we need to describe briefly finite-precision arith-
metic, which is the computer version of real arithmetic. For more information,
see Wilkinson (1963).
In scientific notation, the number 51.75 is written +0.5175 x 10+2.
Computers represent real numbers in the same manner, using a sign ( + in
our example), a base (10), an exponent ( + 2), and a mantissa (0.5175). The
representation is made unique by specifying that I/base < mantissa < 1—that
is, the first digit to the right of the "decimal" point is nonzero. The length of
the mantissa, called the precision of the representation, is especially important
to numerical computation. The representation of a real number on a computer
is called its floating-point representation; we will denote the floating-point
representation of x by fl(x).
On CDC machines the base is 2, and the mantissa has 48 places. Since
248 
1014 4, this means that we can accurately store up to 14 decimal digits.
The exponent can range from —976 to + 1070, so that the smallest and largest
numbers are about 10-294 and 10322. On IBM machines the base is 16; the
mantissa has 6 places in single precision and 14 in double precision, which
corresponds to about 7 and 16 decimal digits, respectively. The exponent can
range from —64 to +63, so that the smallest and largest numbers are about
10-77 and 1076.
The implications of storing real numbers to only a finite precision are
important, but they can be summarized simply. First, since not every real
number can be represented exactly on the computer, one can at best expect a

Introduction 
Chap. 1 
11
solution to be as accurate as the computer precision. Second, depending on the
computer and the compiler, the result of each intermediate arithmetic oper-
ation is either truncated or rounded to the accuracy of the machine. Thus the
inaccuracy due to finite precision may accumulate and further diminish
the accuracy of the results. Such errors are called round-off errors. Although
the effects of round-off can be rather subtle, there are really just three funda-
mental situations in which it can unduly harm computational accuracy. The
first is the addition of a sequence of numbers, especially if the numbers are
decreasing in absolute value; the right-hand parts of the smaller numbers are
lost, owing to the finite representation of intermediate results. (For an exam-
ple, see Exercise 4.) The second is the taking of the difference of two almost
identical numbers; much precision is lost because the leading left-hand digits
of the difference are zero. (For an example, see Exercise 5.) The third is the
solution of nearly singular systems of linear equations, which is discussed in
Chapter 3. This situation is actually a consequence of the first two, but it is so
basic and important that we prefer to think of it as a third fundamental
problem. If one is alert to these three situations in writing and using computer
programs, one can understand and avoid many of the problems associated
with the use of finite-precision arithmetic.
A consequence of the use of finite-precision arithmetic, and even more, of
the iterative nature of our algorithms, is that we do not get exact answers to
most nonlinear problems. Therefore we often need to measure how close a
number x is to another number y. The concept we will use most often is the
relative error in y as an approximation to a nonzero x,
This is preferable, unless x = 0, to the use of absolute error,
because the latter measure is dependent on the scale of x and y but the former
is not (see Exercise 6).
A common notation in the measurement of error and discussion of algo-
rithms will be useful to us. Given two sequences of positive real numbers ai
we write ai = O 
(read "ai is big-oh of 
if there exists
some positive constant c such that for all positive integers i, except perhaps
some finite subset, 
This notation is used to indicate that the mag-
nitude of each ai, is of the same order as the corresponding 
or possibly
smaller. For further information see Aho, Hopcroft, and Ullman [1974].
Another effect of finite-precision arithmetic is that certain aspects of our
algorithms, such as stopping criteria, will depend on the machine precision. It
is important, therefore, to characterize machine precision in such a way that

12 
Chap. 1 Introduction
discussions and computer programs can be reasonably independent of any
particular machine. The concept commonly used is machine epsilon, abbrevi-
ated macheps; it is defined as the smallest positive number 
such that
1 + t > 1 on the computer in question (see Exercise 7). For example, on the
CDC machine, since there are 48 base-2 places, macheps = 2 - 4 7 with truncat-
ing arithmetic, or 2 - 4 8 with rounding. The quantity, macheps, is quite useful
when we discuss computer numbers. For example, we can easily show that the
relative error in the computer representation fl(x) of any real nonzero number
x is less than macheps; conversely, the computer representation of any real
number x will be in the range (x(l — macheps), x(l + macheps)). Similarly, two
numbers x and y agree in the leftmost half of their digits approximately when
This test is quite common in our algorithms.
Another way to view macheps is as a key to the difficult task of deciding
when a finite-precision number could just as well be zero in a certain context.
We are used to thinking of 0 as that unique solution to x + 0 = x for every
real number x. In finite precision, the additive identity role of 0 is played
by an interval Ox which contains 0 and is approximately equal to (— macheps •
x, + macheps • x). It is common that in the course of a computation we will
generate finite-precision numbers x and y of different enough magnitude so
that fl(x + y) = fl(x). This means that y is zero in the context, and sometimes,
as in numerical linear algebra algorithms, it is useful to monitor the compu-
tation and actually set y to zero.
Finally, any computer user should be aware of overflow and underflow,
the conditions that occur when a computation generates a nonzero number
whose exponent is respectively larger than, or smaller than, the extremes al-
lowed on the machine. For example, we encounter an underflow condition
when we reciprocate 10322 on a CDC machine, and we encounter an overflow
condition when we reciprocate 10-77 on an IBM machine.
In the case of an overflow, almost any machine will terminate the run
with an error message. In the case of an underflow, there is often either a
compiler option to terminate, or one to substitute zero for the offending ex-
pression. The latter choice is reasonable sometimes, but not always (see Exer-
cise 8). Fortunately, when one is using well-written linear algebra routines, the
algorithms discussed in this book are not usually prone to overflow or under-
flow. One routine, discussed in Section 3.1, that does require care is computing
Euclidean norm of a vector,

Introduction Chap. 1 
13
1.4 EXERCISES
1. Rephrase as a simultaneous nonlinear equation problem in standard form: Find
(x1, x2)T such that
2. A laboratory experiment measures a function / at 20 distinct points in time t
(between 0 and 50). It is known that f(t) is a sine wave, but its amplitude, frequency,
and displacement in both the f and t directions are unknown. What numerical
problem would you set up to determine these characteristics from your experimental
data?
3. An economist has a complex computer model of the economy which, given the
unemployment rate, rate of growth in the GNP, and the number of housing starts in
the past year, estimates the inflation rate. The task is to determine what combi-
nation of these three factors will lead to the lowest inflation rate. You are to set up
and solve this problem numerically.
(a) What type of numerical problem might this turn into? How would you handle
the variable "number of housing starts"?
(b) What are some questions you would ask the economist in an attempt to make
the problem as numerically tractable as possible (for example, concerning con-
tinuity, derivatives, constraints)?
(c) 
Is the problem likely to be expensive to solve? Why?
4. Pretend you have a computer with base 10 and precision 4 that truncates after each
arithmetic operation; for example, the sum of 24.57 + 128.3 = 152.87 becomes
152.8. What are the results when 128.3, 24.57, 3.163, and 0.4825 are added in
ascending order and in descending order in this machine? How do these compare
with the correct ("infinite-precision") result? What does this show you about adding
sequences of numbers on the computer?
5. Assume you have the same computer as in Exercise 4, and you perform the compu-
tation (3- — 0.3300)/0.3300. How many correct digits of the real answer do you get?
What does this show you about subtracting almost identical numbers on the com-
puter?
6. What are the relative and absolute errors of the answer obtained by the computer in
Exercise 5 as compared to the correct answer? What if the problem is changed to
What does this show about the usefulness of relative versus absolute
error?
7. Write a program to calculate machine epsilon on your computer or hand calculator.
You may assume that macheps will be a power of 2, so that your algorithm can
look like
EPS
WHILE 
1 + EPS > 1 DO
EPS 
== EPS/2.

14 
Chap. 1 Introduction
Keep a counter that enables you to know at the end of your program which power
of 2 macheps is. Print out this value and the decimal value of macheps. (Note: The
value of macheps will vary by a factor of 2 depending on whether rounding or
truncating arithmetic is used. Why?)
For further information on the computer evaluation of machine environment
parameters, see Ford (1978).
8. In each of the following calculations an underflow will occur (on an IBM machine).
In which cases is it reasonable to substitute zero for the quantity that underflows?
Whv?

Nonlinear Problems
in One Variable
We begin our study of the solution of nonlinear problems by discussing prob-
lems in just one variable: finding the solution of one nonlinear equation in one
unknown, and finding the minimum of a function of one variable. The reason
for studying one-variable problems separately is that they allow us to see those
principles for constructing good local, global, and derivative-approximating
algorithms that will also be the basis of our algorithms for multivariable
problems, without requiring knowledge of linear algebra or multivariable cal-
culus. The algorithms for multivariable problems will be more complex than
those in this chapter, but an understanding of the basic approach here should
help in the multivariable case.
Some references that consider the problems of this chapter in detail are
Avriel (1976), Brent (1973), Conte and de Boor (1980), and Dahlquist, Bjorck,
and Anderson (1974).
2.1 WHAT IS NOT POSSIBLE
Consider the problem of finding the real roots of each of the following three
nonlinear equations in one unknown:
f1(x) = x4 - 12x3 + 47x2 - 60x;
f2 (X) = x4 - 12x3 + 47x2 - 60x 
+ 24,
f3(x) = x4 - 12x3 + 47x2 - 60x + 24.1.
15
2

16 
Chap. 2 Nonlinear Problems in One Variable
(see Figure 2.1.1). It would be wonderful if we had a general-purpose computer
routine that would tell us: "The roots of f1(x) are x = 0, 3, 4, and 5; the real
roots of f2(x) are x = 1 and x 
0.888 ;f3(x) has no real roots."
It is unlikely that there will ever be such a routine. In general, the
questions of existence and uniqueness—does a given problem have a solution,
and is it unique?—are beyond the capabilities one can expect of algorithms
that solve nonlinear problems. In fact, we must readily admit that for any
computer algorithm there exist nonlinear functions (infinitely continuously
differentiable, if you wish) perverse enough to defeat the algorithm. Therefore,
all a user can be guaranteed from any algorithm applied to a nonlinear prob-
lem 
is 
the 
answer, 
"An 
approximate 
solution 
to 
the 
problem
is 
," or, "No approximate solution to the problem was
found in the alloted time." In many cases, however, the supplier of a nonlinear
problem knows from practical considerations that it has a solution, and either
that the solution is unique or that a solution in a particular region is desired.
Thus the inability to determine the existence or uniqueness of solutions is
usually not the primary concern in practice.
It is also apparent that one will be able to find only approximate solu-
tions to most nonlinear problems. This is due not only to the finite precision of
our computers, but also to the classical result of Galois that for some poly-
nomials of degree n > 5, no closed-form solutions can be found using integers
and the operations +, —, x, 
-=-, exponentiation, and second through nth
roots. Therefore, we will develop methods that try to find one approximate
solution of a nonlinear problem.
2.2 NEWTON'S METHOD FOR SOLVING
ONE EQUATION IN ONE UNKNOWN
Our consideration of finding a root of one equation in one unknown begins
with Newton's method, which is the prototype of the algorithms we will gener-
ate. Suppose we wish to calculate the square root of 3 to a reasonable number
of places. This can be viewed as finding an approximate root x * of the func-
Figure 2.1.1 The equation f1 (x) = x4 - 12x3 + 47x2 - 60x

The logical thing to do next is to apply the same process from the new
current estimate xf = 1.75. Using (2.2.1) gives x+ = 1.75 - (0.0625/3.5) =
1.732 , which already has four correct digits of 
One more iteration gives
x + = 1.7320508, which has eight correct digits.
The method we have just developed is called the Newton-Raphson
method or Newton's method. It is important to our understanding to take a
more abstract view of what we have done. At each iteration we have construc-
ted a local model of our function /(x) and solved for the root of the model. In
Figure 2.2.1 An iteration of Newton's method on f(x) = x2 — 3 (not to
scale)
Nonlinear Problems in One Variable Chap. 2 
17
tion/(x) = x2 — 3 (see Figure 2.2.1). If our initial or current estimate of the
answer is xc = 2, we can get a better estimate x + by drawing the line that is
tangent to f(x) at (2, f(2)) = (2, 1), and finding the point x + where this line
crosses the x axis. Since
and
we have that
which gives
or

18 
Chap. 2 Nonlinear Problems in One Variable
the present case, our model
is just the unique line with function value f(xc) and slope f(xc) at the point xc .
[We use capital M to be consistent with the multidimensional case and to
differentiate from minimization problems where our model is denoted by
mc(x).] It is easy to verify that Mc(x) crosses the x axis at the point x+ defined
by (2.2.1).
Pedagogical tradition calls for us to say that we have obtained Newton's
method by writing f(x) as its Taylor series approximation around the current
estimate xc ,
and then approximating f(x) by the affine* portion of this series, which nat-
urally is given also by (2.2.2). Again the root is given by (2.2.1). There are
several reasons why we prefer a different approach. It is unappealing and
unnecessary to make assumptions about derivatives of any higher order than
those actually used in the iteration. Furthermore, when we consider multivari-
able problems, higher-order derivatives become so complicated that they are
harder to understand than any of the algorithms we will derive.
Instead, Newton's method comes simply and naturally from Newton's
theorem,
It seems reasonable to approximate the indefinite integral by
and once more obtain the affine approximation to f(x) given by (2.2.2). This
type of derivation will be helpful to us in multivariable problems, where geo-
metrical derivations become less manageable.
Newton's method is typical of methods for solving nonlinear problems; it
is an iterative process that generates a sequence of points that we hope come
increasingly close to a solution. The obvious question is, "Will it work?" The
* We will refer to (2.2.2) as an affine model, although colloquially it is often called a linear
model. The reason is that an affine model corresponds to an affine subspace through (x, f(x )), a line
that does not necessarily pass through the origin, whereas a linear subspace must pass through the
origin.

Nonlinear Problems in One Variable Chap. 2 
19
answer is a qualified "Yes." Notice that if f(x) were linear, Newton's method
would find its root in one iteration. Now let us see what it will do for the
general square-root problem;
given a > 0, find x such that /(x) = x2 — a = 0,
starting from a current guess xc ± 0. Since
one has
or, using relative error, one has
Thus as long as the initial error 
is less than 
the new error
will be smaller than the old error 
and eventually each
new error will be much smaller than the previous error. This agrees with our
experience for finding the square root of 3 in the example that began this
section.
The pattern of decrease in error given by (2.2.4) is typical of Newton's
method. The error at each iteration will be approximately the square of the
previous error, so that, if the initial guess is good enough, the error will
decrease and eventually decrease rapidly. This pattern is known as local q-
quadratic convergence. Before deriving the general convergence theorem for
Newton's method, we need to discuss rates of convergence.
2.3 CONVERGENCE OF SEQUENCES
OF REAL NUMBERS
Given an iterative method that produces a sequence of points xl x 2,..., from
a starting guess x0, we will want to know if the iterates converge to a solution
x *, and if so, how quickly. If we assume that we know what it means to write
for a real sequence {ak}, then the following definition characterizes the proper-
ties we will need.
Definition 2.3.1 Let x * e R, xk e R, k = 0, 1, 2,.... Then the sequence

20 
Chap. 2 Nonlinear Problems in One Variable
{|xk} = {x0, x1, x2, ...} is said to converge to x,, if
If in addition, there exists a constant c e [0, 1) and an integer 
such that
for all 
then {xk} is said to be q-linearly convergent to x* If for some sequen
that converges to 0,
then {xk} is said to converge q-superlinearly to x* . If there exist constants
and 
such that {xk} converges to x* and for all
then {xk} is said to converge to x* with q-order at least p. If , - ' or 3, the
convergence is said to be q-quadratic or q-cubic, respectively.
If {xk} converges to x* and, in place of (2.3.2),
for some fixed integer j, then {xk} is said to bey-step q-superlinearly convergent
to x*. If {xk} converges to x,,, and, in place of (2.3.3), for k > k,
for some fixed integer j, then {xk} is said to have j-step q-order convergence of
order at least p.
An example of a q-linearly convergent sequence is
This sequence converges to x* = 1 with c = 
on a CDC machine it will take
48 iterations until fl(xk) = 1. An example of a g-quadratically convergent se-
quence is
which converges to x* = 1 with c = 1; on a CDC machine, fl(x6) will equal 1.
In practice, q-linear convergence can be fairly slow, whereas q-quadratic or
g-superlinear convergence is eventually quite fast. However, actual behavior
also depends upon the constants c in (2.3.1-2.3.3); for example, q-linear con-
vergence with c = 0.001 is probably quite satisfactory, but with c = 0.9 it is
not. (For further examples see Exercises 2 and 3). It is worth emphasizing that
the utility of g-superlinear convergence is directly related to how many iter-
ations are needed for ck to become small.
for all

Nonlinear Problems in One Variable Chap. 2 
21
The prefix "q" stands for quotient and is used to differentiate from "r"
(root) orders of convergence. K-order* is a weaker type of convergence rate; all
that is said of the errors | xk — *„, |, of a sequence with r-order p, is that they
are bounded above by another sequence of g-order p. A definitive reference is
Ortega and Rheinboldt [1970]. An iterative method that will converge to the
correct answer at a certain rate, provided it is started close enough to the
correct answer, is said to be locally convergent at that rate. In this book we will
be interested mainly in methods that are locally g-superlinearly or q-
quadratically convergent and for which this behavior is apparent in practice.
2.4 CONVERGENCE OF NEWTON'S
METHOD
We now show that, for most problems, Newton's method will converge q-
quadratically to the root of one nonlinear equation in one unknown, provided
it is given a good enough starting guess. However, it may not converge at all
from a poor start, so that we need to incorporate the global methods of
Section 2.5. The local convergence proof for Newton's method hinges on an
estimate of the errors in the sequence of affine models Mc(x) as approxi-
mations to f(x). Since we obtained the approximations by usingf'(xc)(x — xc)
to approximate
we are going to need to make some smoothness assumptions on/' in order to
estimate the error in the approximation, which is
First we define the notion of Lipschitz continuity.
Definition 2.4.1 A function g is Lipschitz continuous with constant y in
a set X, written g e Lipy(X), if for every x, y e X,
In order to prove the convergence of Newton's method, we first prove a
simple lemma showing that if f'(x) is Lipschitz continuous, then we can obtain
a bound on how close the affine approximationf(x) +f'(x)(y — x) is to f (y).
* We will capitalize the prefix letters R and Q when they begin a sentence, but not
otherwise.

22 
Chap. 2 Nonlinear Problems in One Variable
LEMMA 2.4.2 For an open interval D, let f: D-> R and let f' e Lipy(D).
Then for any x, v e D
Proof. 
From basic calculus
dz, or equivalently,
Making the change of variables
z = x + t(y- x), 
dz = dt(y - x),
(2.4.2) becomes
and so by the triangle inequality applied to the integral and the Lipschitz
continuity of f',
Note that (2.4.1) closely resembles the error bound given by the Taylor
series with remainder, with the Lipschitz constant y taking the place of a
bound on 
for 
D. The main advantage of using Lipschitz continuity
is that we do not need to discuss this next higher derivative. This is especially
convenient in multiple dimensions.
We are now ready to state and prove a fundamental theorem of numeri-
cal mathematics. We will prove the most useful form of the result and leave the
more general ones as exercises (see Exercises 13-14.)
THEOREM 2.4.3 Let f: D 
R, for an open interval D, and let /' 6
Lipy(D). Assume that for some 
for every x e D. If
f(x) = 0 has a solution x* e D, then there is some n > 0 such that: if
xo — xo <n then the sequence {xk} generated by
exists and converges to x*.. Furthermore, for k = 0, 1, ...,

Nonlinear Problems in One Variable Chap. 2 
23
Proof. 
Let 
(0,1), let n be the radius of the largest open interval around
x* that is contained in D, and define 77 = mm{n, (2 / )}. We will show by
induction that for k = 0, 1, 2,..., (2.4.3) holds, and
The proof simply shows at each iteration that the new error \xk+l — x,|
is bounded by a constant times the error the affine model makes in
approximatingf at x*., which from Lemma 2.4.2 is 0(|xk — x,|2). For
k = 0,
The term in brackets isf(x*) — M0(x#), the error at x,,, in the local affine
model at xc = x0. Thus from Lemma 2.4.2,
and by the assumptions onf'(x)
Since
proof of the induction step then proceeds identically.
The condition in Theorem 2.4.3 that/'(x) have a nonzero lower bound in
D simply means thatf'(x*) must be nonzero for Newton's method to converge
quadratically. Indeed, if f'(x*) = 0, then x* is a multiple root, and Newton's
method converges only linearly (see Exercise 12). To appreciate the difference,
we give below sample iterations of Newton's method applied to f1(x) = x2 — 1
and f2(x) = x2 — 2x + 1, both starting from x0 = 2. Notice how much more
slowly Newton's method converges on f2(x) becausef'2(x*) = 0.
EXAMPLE 2.4.4 Newton's Method Applied to Two Quadratics (CDC, Single
Precision)
f1(x) = x2 - 1 
f2(x) 
= x2 - 2x + 1
2
1.25
1.025
1.0003048780488
1.0000000464611
1.0
X0
x1
X2
X3
X4
X5
2
1.5
1.25
1.125
1.0625
1.03125

24 
Chap. 2 Nonlinear Problems in One Variable
Figure 2.4.1 Newton's method applied to/(x) = arctan(x)
It is also informative to examine the constant y/2p involved in the q-
quadratic convergence relation (2.4.3). The numerator y, a Lipschitz constant
for/' on D, can be considered a measure of the nonlinearity of/. However, .y is
a scale-dependent measure; multiplying / or changing the units of x by a
constant will scale/' by that constant without making the function more or
less nonlinear. A partially scale-free measure of nonlinearity is the relative rate of
change in f'(x), which is obtained by dividing y by f'(x). Thus, since p is a
lower bound on f'(x) for x e D, y/p is an upper bound on the relative nonlin-
earity off(x), and Theorem 2.4.3 says that the smaller this measure of relative
nonlinearity, the faster Newton's method will converge. If f is linear, then y = 0
and Xj = x*.
Theorem 2.4.3 guarantees the convergence of Newton's method only
from a good starting point x0, and indeed it is easy to see that Newton's
method may not converge at all if x0 — x* is large. For example, consider
the function f(x) = arctan x (see Figure 2.4.1). For some xc € [1.39, 1.40], if
x0 = xc, then Newton's method will produce the cycle x1 = — xc, x2 = xc,
x3 = — x c,.... If x0 < xc, Newton's method will converge to x* = 0, but if
x0 > xc, Newton's method will diverge; i.e., the error xk — x* | will increase
at each iteration. Thus Newton's method is useful to us for its fast local
convergence, but we need to incorporate it into a more robust method that
will be successful from farther starting points.
2.5 GLOBALLY CONVERGENT
METHODS* FOR SOLVING ONE
EQUATION IN ONE UNKNOWN
We will use a simple philosophy to incorporate Newton's method into a
globally convergent algorithm: use Newton's method whenever it seems to be
working well, otherwise fall back on a slower but sure global method. This
strategy produces globally convergent algorithms with the fast local conver-
* For our definition of "global method," see the last paragraph of Section 1.1.

Nonlinear Problems in One Variable Chap. 2 
25
gence of Newton's method. In this section we discuss two global methods and
then show how to combine a global method with Newton's method into a
hybrid algorithm. We also discuss the stopping tests and other computer-
dependent criteria necessary to successful computational algorithms.
The simplest global method is the method of bisection. It makes the
somewhat reasonable assumption that one starts with an interval [x0, z0] that
contains a root. It sets xl to the midpoint of this interval, chooses the new
interval to be the one of [x0, x1] or [x1, z0] that contains a root, and con-
tinues to halve the interval until a root is found (see Figure 2.5.1). This is
expressed algebraically as:
given x0, z0 such that f(x 0)f(z 0) < 0,
fork = 0, 1, 2, ...,do
The method of bisection always works in theory, but it is guaranteed
only to reduce the error bound by for each iteration. This makes the method
very marginal for practical use. Programs that use bisection generally do so
only until an xk is obtained from which some variant of Newton's method will
converge. The method of bisection also does not extend naturally to multiple
dimensions.
A method more indicative of how we will proceed in n-space is the
following. Think of Newton's method as having suggested not only the step
XN = xc —f(xc)/f'(xc), but also the direction in which that step points.
[Assume 
Although the Newton step may actually cause an increase
in the absolute value of the function, its direction always will be one in which
the absolute function value decreases initially (see Figure 2.5.2). This should be
obvious geometrically; for the simple proof, see Exercise 16. Thus, if the
Newton point XN doesn't produce a decrease in | /(x) |, a reasonable strat-
egy is to backtrack from XN toward xc until one finds a point x+ for
Figure 2.5.1 The method of bisection

26 
Chap. 2 Nonlinear Problems in One Variable
Note that this strategy does not require an initial interval bracketing a root.
Iteration (2.5.1) is an example of a hybrid algorithm, one that attempts to
combine global convergence and fast local convergence by first trying the
Newton step at each iteration, but always insisting that the iteration decreases
some measure of the closeness to a solution. Constructing such hybrid algo-
rithms is the key to practical success in solving multivariable nonlinear prob-
lems. Below is the general form of a class of hybrid algorithms for finding a
root of one nonlinear equation; it is meant to introduce and emphasize those
basic techniques for constructing globally and fast locally convergent algo-
rithms that will be the foundation of all the algorithms in this book.
ALGORITHM 2.5.1 General hybrid quasi-Newton algorithm for solving
one nonlinear equation in one unknown:
given f: R —> R, x0,
for k = 0, 1, 2, ...,do
1. decide whether to stop; if not:
2. make a local model of faround xk, and find the point XN that
solves (or comes closest to solving) the model problem.
3. (a) decide whether to take xk+1 = XN, if not,
(b) choose xk + 1 using a global strategy (make more conser-
vative use of the solution to the model problem).
Figure 2.5.2 Backtracking from the Newton step
which 
A possible iteration is

Nonlinear Problems in One Variable 
Chap. 2 
27
Step 1 is discussed below; it requires our first use of computer-dependent
and problem-dependent tolerances. Step 2 usually involves calculating the
Newton step, or a variant without derivatives (see Section 2.6). Equation (2.5.1)
is an example of Step 3(a)-{b). We will see in Chapter 6 that the criterion in
Step 3(a) has to be chosen with only a little bit of care to assure the global
convergence in most cases of the hybrid algorithm to a solution.
Deciding when to stop is a somewhat ad hoc process that can't be perfect
for every problem, yet it calls for considerable care. Since there may be no
computer-representable x* such that f ( x * ) = 0, one must decide when one is
"close enough." This decision usually takes two parts: "Have you approxi-
mately solved the problem?" or "Have the last two (or few) iterates stayed in
virtually the same place?" The first question is represented by a test such as,
"Is | f(x+)| < T!?" where the tolerance TI is chosen to reflect the user's idea of
being close enough to zero for this problem. For example, t1 might be set to
(macheps)1/2. Naturally this test is very sensitive to the scale off(x), and so it is
important that a routine instruct the user to choose T1, or scale/, so that an
x + that satisfies f(x+)| < Tt will be a satisfactory solution to the problem.
Partly to guard against this condition's being too restrictive, the second
question is included and it is tested by a relation such as, "Is (x+ — xc
|x+ ) < T2?" A reasonable tolerance is T2 = (macheps)1/2, which corresponds
to stopping whenever the left half of the digits of xc and x+ agree, though any
T2 greater than macheps can be selected. Since x+ might be close to zero, the
second test is usually modified to something like, "Is (x + — xc ./max {|x+ |,
|xc|} < T2?" A better test uses a user-supplied variable typx containing the
typical size of x in the place of the | xc | in the denominator (see Exercise 17), so
that the stopping condition on a CDC machine might be,
In practicef(x+) usually gets small before the step does in any problem for
which local convergence is fast, but for a problem on which convergence is
only linear, the step may become small first. The reader can already see that
the choice of stopping rules is quite a can of worms, especially for poorly
scaled problems. We will treat it more completely in Chapter 7.
2.6 METHODS WHEN DERIVATIVES
ARE UNAVAILABLE
In many practical applications, f(x) is not given by a formula; rather it is the
output from some computational or experimental procedure. Since f'(x) us-
ually is not available then, our methods that use values of f'(x) to solve
f(x) = 0 must be modified to require only values of/(x).

28 
Chap. 2 Nonlinear Problems in One Variable
We have been using/'(x) in modeling f near the current solution estimate
xc by the line tangent to f at xc. When f'(x) is unavailable, we replace this
model by the secant line that goes through / at xc and at some nearby point
xc + hc (see Figure 2.6.1). It is easy to calculate that the slope of this line is
and so the model we obtain is the line
Mc(x) =f(xc) + ac(x - xc).
Therefore, what we have done is equivalent to replacing the derivative f'(xc) in
our original model Mc(x) =f(x c) +f'(xc)(x — xc) by the approximation ac.
The quasi-Newton step to the zero of Mc(x) then becomes
Two questions immediately arise: "Will this method work?" and, "How
should hc be chosen ?" We know from calculus that as hc —> 0, ac will converge
to f'(xc). If nc is chosen to be a small number, ac is called a finite-difference
approximation to f'(xc). It seems reasonable that the finite-difference Newton
method, the quasi-Newton method based on this approximation, should work
almost as well as Newton's method, and we will see later that it does. How-
ever, this technique requires an additional evaluation of f at each iteration, and
if f(x) is expensive, the extra function evaluation is undesirable. In this
case, hc is set to (.x_ — xc), where x_ is the previous iterate, so that ac =
(f(x-) 
— f(xc))/(x- — xc) and no additional function evaluations are used.
The resultant quasi-Newton algorithm is called a secant method. While it may
seem totally ad hoc, it also turns out to work well; the convergence of the
secant method is slightly slower than a properly chosen finite-difference
method, but it is usually more efficient in terms of total function evaluations
required to achieve a specified accuracy.
Figure 2.6.1 
A secant approximation to f(x\

Nonlinear Problems in One Variable Chap. 2 
29
Example 2.6.1 contains samples of the convergence of the secant method
and the finite-difference Newton's method (with hc = 10-
7xc) on the problem
f(x) = x2 — 1, x0 = 2, that was solved by Newton's method in Example 2.4.4.
Notice how similar Newton's method and the finite-difference Newton's
method are; the secant method is a bit slower.
EXAMPLE 2.6.1 Finite-difference 
Newton's method and the secant method
applied to f(x) = x2 — 1 (CDC, single precision).
Finite-Difference N.M. 
Secant Method
(hk = 1(10-7 • xk) 
(x1 
chosen by f.d.N.M.)
2
1.2500000266453
1.0250000179057
1.0003048001120
1.0000000464701
1.0
x0 2
X1 
1.2500000266453
x2 1.0769230844910
x3 1.0082644643823
x4 1.0003048781354
x5 1.0000012544523
x6 1.0000000001912
x7 1.0
There is a great deal of insight to be gained from an analysis of the effect
of the difference step hc on the convergence rate of the resultant finite-
difference Newton method. Let us take
Then
under the same Lipschitz continuity assumption f' e Lipy(D) as in Lemma
2.4.2.
If we define
and
then we have

30 
Chap. 2 Nonlinear Problems in One Variable
The reader can see that (2.6.2) is similar to our error bound for Newton's
method in Section 2.4, except that the right-hand side of (2.6.2) has a-l
c in
the place of f'(x c)- l , and an additional term involving the difference between
f'(xc) and its approximation ac. Notice also that the above analysis so far is
independent of the value of 
Now let us define ac by (2.6.1) and again
bring in the assumption of Lipschitz continuity of f' from Section 2.4. Then we
have an easy corollary which tells us how close, as a function of hc, the
finite-difference approximation (2.6.1) is tof'(xc).
COROLLARY 2.6.2 
Let f:D-»R for an open interval D and let
/' e Lipy(D). Let xc, xc + hc e D, and define ac by (2.6.1). Then
Now, if we bring in from Theorem 2.4.3 the assumption that f'(x) \ > p > 0 in
a neighborhood of x, it is easy to show from (2.6.3), for hc sufficiently small,
and xc E D, that 
This gives
At this point it is really rather easy to finish a proof of the following
theorem.
THEOREM 2.6.3 Let 
f:D-»R 
for an open 
interval D and let
f' e Lipy(D). Assume that 
for some p > 0 and for every
x E D. If f(x) = 0 has a solution x* D), then there exist positive con-
stants 
such that if {hk} is a real sequence with 0 
and if
xo — x
* < n, then the sequence {xk} defined by
Proof. 
From Lemma 2.4.2,
Dividing both sides by hc gives the desired result.
Substituting (2.6.3) into (2.6.2) gives

Nonlinear Problems in One Variable 
Chap. 2 
31
is defined and converges q-linearly to x*. If lim 
hk = 0, then the
convergence is g-superlinear. If there exists some constant c1 such that
or equivalently, a constant c2 such that
then the convergence is q-quadratic. If there exists some constant c3 such
that
then the convergence is at least two-step q-quadratic; this includes the
secant method hk = xk _ l — xk as a special case.
We began this discussion with a claim that insight is contained in the
existence and simplicity of the analysis. In particular, the finite-difference idea
seemed somewhat ad hoc when we introduced it. However, not only can we
observe its excellent computational behavior in practice, but with analysis
hardly more complicated than for Newton's method we can characterize exact-
ly how it will converge as a function of the stepsizes {hk}. This is just one of
many instances in numerical analysis where theoretical analysis is an ally to
algorithmic development.
If order of convergence were the only consideration in choosing {hk} in
the finite-difference Newton's method, then we would just set hc — c2 
f(xc)
for some constant c2, and our analysis would be complete, since it is easy to
show for xc sufficiently close to x* that f(xc) < c xc — xc . (See Exercise 18.)
However, finite-precision arithmetic has a very important effect that we want
to look at now. Obviously in practice hc cannot be too small in relation to xc.
For example, if 
fl 
and hc < xc • macheps, then fl(xc + hc) = fl(xc.) and
so the numerator of (2.6.1) will be computed to be zero, since the subroutine
that evaluates / will have been called with the same floating-point argument
both times.
Even if hc is large enough that fl(xc + hc) fl(xc), there remains the loss
of accuracy in the floating-point subtraction necessary to form the numerator
of (2.6.1). After all, since f is continuously differentiable, if f is evaluated at two
nearby points, then the resulting values of f (xc + hc) and f (xc) should also be
nearly equal. We might even have fl(f(xc + hc)) = fl(/(xc)). If | hc \ is small, we
certainly should expect to have several of the leftmost digits of the mantissa
the same. For example, suppose on a base-10 machine with 5-digit mantissa
we have f(xc) = 1.0001 and f(xc + hc) = 1.0010 returned by some hypothetical
function subroutine with hc = 10-4. In this case,f(xc + hc) —f(x c) would be
computed as 9 x 10-4 and ac as 9. Thus we have lost most of the significant
digits in taking the difference of the function values.

32 
Chap. 2 Nonlinear Problems in One Variable
In practice, furthermore, one often has progressively less confidence in
the digits of the function values as one scans to the right. This is due not only
to finite-precision arithmetic, but also to the fact that the function values are
sometimes themselves just the approximate results returned by a numerical
routine. Thus in the above example the difference f ( x c + hc) —f(xc) =
9 x 10 -4 may reflect only random fluctuation in the rightmost digits of/and
have no significance at all. The result is that the slope of the model of fat xc
may not even have the same sign asf'(xc).
The obvious way to compute ac more accurately is to take | hc \ large
enough so that not all the most trustworthy leading digits are the same for
f ( x c + hc) and f (xc). There is a limit to how large hc can be, since our whole
object in computing ac is to use it as an approximation to f'(xc), and (2.6.3)
indicates that this approximation deteriorates as hc increases. A good com-
promise is to try to balance the nonlinearity error caused by taking hc too
large with the finite-precision and function evaluation errors from allowing
hc 
too small. We develop this as an exercise (Exercise 19) and discuss it
further in Section 5.4.
A simple rule for the case when / is assumed to be computed accurately
to machine precision is to perturb roughly half the digits of xc:
where typx is the typical size of x used in Section 2.5. This often-used rule is
generally satisfactory in practice. If the accuracy of the f-subroutine is suspect,
then hc should be large enough so that only half the reliable digits of
f(xc + hc) and f(xc) will be the same. If this hc is large enough to cast doubt
on the utility of (2.6.1)as an approximation tof'(xc), then one remedy is to use
the central difference,
2.7 MINIMIZATION OF A FUNCTION
OF ONE VARIABLE
We conclude our study of one-dimensional problems by discussing mini-
mization of a function of one variable. It turns out that this problem is so
closely related to solving one nonlinear equation in one unknown that we
virtually know already how to compute solutions.
First of all, one must again admit that one cannot practically answer
questions of existence and uniqueness. Consider, for example, the fourth-
This gives a more accurate derivative approximation for a given hc (see Exer-
cise 20) than the forward difference approximation (2.6.1), but it has the disad-
vantage of doubling the expense in function evaluations.

Nonlinear Problems in One Variable Chap. 2 
33
degree polynomial of Figure 2.1.1. Its global minimizer, where the function
takes its absolute lowest value, is at 
but it also has a local minimizer,
a minimizing point in an open region, at 
If we divide the function by
x, it becomes a cubic with a local minimum at 
but no finite global
minimizer since
In general, it is practically impossible to know if you are at the global mini-
mum of a function. So, just as our algorithms for nonlinear equations can find
only one root, our optimization algorithms at best can locate one local mini-
mum; usually this is good enough in practice. Once again, a closed-form
solution is out of the question: if we could find a closed form for a global
minimizer of f (x), we could solve f(x) = 0 by setting/(x) =f(x)2.
The reason we said earlier that the reader already knows how to solve
the minimization problem is that a local minimum of a continuously differen-
tiable function must come at a point where f'(x) = 0. Graphically, this just
says that the function can't initially decrease in either direction from such a
point. A proof of this fact suggests an algorithm, so we give it below. It will be
useful to denote by Cl(D) and C2(D), respectively, the sets of once and twice
continuously differentiable functions from D into R.
THEOREM 2.7.1 Let f Cl(D) for an open interval D, and let z e D. If
then for any s with f'(z) • s < 0, there is a constant t > 0 for
which f(z + As) <f(z), for every A e (0, t)-
Proof. 
We need only choose t, using the continuity of f', so that
f'(z +As)s < 0 and z + As e D for every A e (0, t). The rest is immediate
from calculus, since, for any such A,
Theorem 2.7.1 suggests that we find a minimizing point x* of a function f
by solving f'(x) = 0. On the other hand, by applying the theorem to g(x) =
—f(x), we see that this condition also identifies possible maximizing points.
That is, solving f'(x) = 0 is necessary for finding a minimizing point for f, but
not sufficient. Theorem 2.7.2 shows that a sufficient additional condition
is f'(x ) > 0.
THEOREM 2.7.2 Let f e C2(D) for an open interval D and let x* e D
for which f'(x* = 0 and f"(x *.) > 0. Then there is some open subinterval
D' c D for which x* e D' and f(x) >f(x*) for any other x e D'.

34 
Chap. 2 Nonlinear Problems in One Variable
Proof. 
Let D' be chosen about *„, so that /" > 0 on D'. The use of a
Taylor series with remainder does not lead to later problems in the
multidimensional instance of the minimization problem, so we note that
for any x 
D' there is an x 
(x+, x) 
D' for which
Thus we are finished, sincef'(x*) = 0 and x 
D' imply
Now that we can recognize a solution, let us decide how to compute one.
The easiest way to the class of algorithms we will use is to think of solving
/'(x) = 0 by applying the hybrid Newton's method strategy we studied in
Section 2.5, only making sure that we find a minimizer and not a maximizer
by incorporating into the globalizing strategy the requirement that/(xk) de-
creases as k increases.
An iteration of the hybrid method starts by applying Newton's method,
or a modification discussed in Section 2.6, to /'(x) = 0 from the current point
xc. The Newton step is
It is important to note the meaning of this step in terms of model problems.
Since (2.7.1) is derived by making an affine model off'(x) around xc, it is
equivalent to having made a quadratic model of/(x) around xf,
and setting x + to the critical point of this model. A quadratic model is more
appropriate than an affine model off(x) for either maximization or mini-
mization because it has at most one extreme point. Thus the step (2.7.1) will
find the extreme point.of a quadratic function in one iteration; also, by exactly
the same proof as in Theorem 2.4.3, it will converge locally and q-
quadratically to an extreme point x* of/(x) 
i f f " ( x * ) 0 andf" is Lipschitz
continuous near x*,,.
Our global strategy for minimization will differ from that in Section 2.5
in that, rather than deciding to use the Newton point XN by the condition
lf'(X N)| < |f'(xc)), which measures progress toward a zero off'(x), we will
want f(xN) <f(xc\ which indicates progress toward a minimum. If f(xN) >
f(xc) butf'(xc)(xN — xc) < 0, then Theorem 2.7.1 shows thatf(x) must initially
decrease in the direction from xc toward XN, and so we can find an acceptable
next point x+ by backtracking from XN toward xc. From (2.7.1),/'(xcXxw — xc)
will be negative if and only if/"(xc) (or its approximation) is positive. That is, if
the local model used to derive the Newton step has a minimum and not a

Nonlinear Problems in One Variable Chap. 2 
35
Figure 2.7.1 
Correspondence of the local quadratic model to the initial
slope from xc toward XN
maximum, then it is guaranteed to provide an appropriate step direction (see
Figure 2.7.1). On the other hand, iff"(xc) < 0 and/'(xc)(xn - xc) > 0, thenf(x)
initially increases going from xc toward XN , and we should take a step in the
opposite direction. One strategy is to try a step of length | XN — xc \ and then
backtrack, if necessary, until f(x + ) <f(xc). More advanced global strategies
for minimization are discussed in Chapter 6.
The stopping criteria for optimization are a bit different than those for
solving nonlinear equations. Again one asks, "Have we approximately solved
the problem?" or, "Have the iterates stayed in virtually the same place?" The
second question is tested by the same relative/absolute step-size condition as
in Section 2.5, "Is |x+ — xf |/max {typx, |x+ |} < 
?" The first can simply be
"Is |f'(x + )| < 
?" but once again this is dependent upon the scale off, and
now also on the scale of x. This time, however, something can be done about
it: one can ask for the relative rate of change in /, f'(x)//(x), to have absolute
value less than 
2, or even for the relative change infdivided by the relative
change in x,
to be less than T2 in absolute value. The last test is appealing because it tries to
account for scaling in both/and x.
Finally, there is the question of what to do if the derivativesf'(x) are not
available. The solution is so similar to the discussion in Section 2.6 that we
defer consideration of this problem to the multidimensional case (see also
Exercise 21).

36 
Chap. 2 
Nonlinear Problems in One Variable
2.8 EXERCISES
1. Carry out one iteration of Newton's method from x = 2 for the function/,(x) given
in Section 2.1. Which root are you converging to? What happens if you start from
x = 1?
2. Approximately how many iterations will the q-linearly convergent sequence
xk = 1 4+ (0.9)k, k = 0, 1,..., take to converge to 1 on a CDC machine? (Do this on
paper, not on the computer!) Is q-linear convergence with constant 0.9 satisfactory
for general computational algorithms?
3. Consider the sequence xk — 1 + 1/k!, k — 0, 1, 
Does this sequence converge
g-linearly to 1 ? Does it converge q-linearly with any constant c > 0? What type of
convergence is this? Does {xk} converge to 1 with q-order / for any constant / > 1 ?
4. Prove that the r-order of a sequence is always at least as large as its q-order. Give a
counterexample to the converse.
5. Prove that {xk} has g-order at least p if and only if it has a sequence of error
bounds {bk} with bk > ek — \ xk — x*, | for which {bk} converges to zero with g-order
at least p and
6. (Harder) There is an interesting relationship between l-step g-order and "1-step"
r-order. See if you can discover and prove this result. To find the result and an
application see Gay (1979).
7. On the IBM 360-370 series, extended-precision multiplication is hardwired, but
extended-precision division is done by doing double-precision division, and then
using a Newton's method iteration that requires only multiplication and addition.
To understand this, (a) derive a suitable Newton's method iteration for calculating
x* = l/a for a given real number a, and (b) carry out three iterations for a = 9
given x0 = 0.1. What sort of convergence are you getting?
8. Analyze the convergence rate of the bisection method.
9. Write, debug, and test a program for solving one nonlinear equation in one un-
known. It should follow the hybrid strategy explained in Section 2.5. For the local
step, use either Newton's method, finite-difference Newton's method, or the secant
method. For the global strategy, use bisection, backtracking, a strategy that inter-
polates between xn and xk, or another strategy of your own choosing. Run your
program on:
(a) f(x) = sin x — cos 2x, x0 = 1
(b) f(x) = x3 - 7x2 + 1 1x - 5, x0 = 2, 7
(c) f(x) = sin x — cos x, x0 = 1
(d) f(x) given in Section2.1, x0 = 0, 2.
(If you use bisection, pick an appropriate initial interval for each problem, and
constrain all your iterates to remain in that interval.) What rate of convergence do
you observe in each case? It won't always be quadratic. Why?
10. Use your program from Exercise 9 to find the point c > 0 from which Newton's
method for arc tan x = 0 will cycle (see Figure 2.4.1).

Nonlinear Problems in One Variable 
Chap. 2 
37
11. Modify your program from Exercise 9 to find the minimum of a function of one
variable. (The modifications are explained in Section 2.7.)
12. What rate of convergence (to x* = 0) does Newton's method have when solving
x2 = 0? x3 = 0? How about x + x3 = 0? x + x4 = 0? Which assumptions of
Theorem 2.4.3, if any, are violated in each case?
13. Prove that if/(x*) = /'(x*) = 
0,f"(x* 
0, Newton's method converges g-linearly
to X*. with lim 
[If 
you 
wish, generalize this result to f ( x * )=
f'(x*) = (x* ) =fn(x*) = 0,fn+1(x*)^0.]
14. Prove that if f ( x * )= 0, f'(x*) 0, f"(x*) - 0, f'"(x*) 0, Newton's method con-
verges q-cubicly to x* [If you wish, generalize this result to f'(x *) 
0, f(x* )=
f 2(x *)= 
• • = fn(x,) = 0,fn + 
1(x*) 0.]
15. Derive a cubicly convergent method for solvingf(x) = 0 by modelingfby a qua-
dratic Taylor series approximation at each step. What are the major problems in
using this method? Do you think a quadratic model is appropriate for this prob-
lem? (See also "Muller's method" in most introductory numerical analysis texts.)
16. Given / e C1(D), xc e D with f'(xc) 0, and d = -f(xc)/f'(xc), show that there
exists some t > 0 such that|/(xc + 
)|<|/(xc)|for all 
6 (0, 0- [Hint: Choose t so
thatf'(xc + d) • f'(xc) > 0 for all A e (0, t), and then use the techniques of proof of
Theorem 2.7.1.] (Assume f(xc) is not 0.)
17. Consider solving x2 = 0 by Newton's method starting from x0 = 1. Will any two
successive iterates satisfy |x k + 1 — xk|/max {|xK, |xk + 11} < 10-7? What about the
test involving "typx" suggested at the end of Section 2.6?
18. Givenf e Cl(D) and x* e D with/(x*) = 0, show that there exists a constant a > 0
and an interval D c; D containing x* such that for all x e D, | f(x) | < a | x — x* \.
[Hint. Choose D so that | f'(x)| < a for all x e D.]
19. Supposef: D—> R for an open interval D and assumef' e Lipy(D). Suppose that
the computer routine for evaluating f(x) has a total error bounded by n \ /(x) |,
where n is a nonnegative constant. Develop an upper bound on the total error in
[f(xc + hc) -f(xc)]/hc
 as an approximation tof'(xc), as a function of hc [and y, n,
f(xc), andf(xc + nc)]. Find the value of hc that minimizes this bound for fixed y, n,
and f(xc). [Assume here thatf(x c + hc) = f(xc).] Also comment on the compu-
tational utility of finite differences iff'(x) is extremely small in comparison tof(x).
20. Suppose D is an open interval containing xc — hc, xc + hc e R, and letf": D—> R
satisfy f" e LipyD). Prove that the error in the central difference formula (2.6.7) as
an approximation tof'(xc) is bounded by y|nc|2/6. [Hint: Expand the techniques
of Lemma 2.4.2 to show that
or derive a similar bound from the Taylor series with remainder.]
21. Suppose you are solving a minimization problem in one variable in which/(x) and
f'(x) are analytically available but expensive to evaluate, and f"(x) is not analyti-
cally available. Suggest a local method for solving this problem.

This page intentionally left blank 

A second program note
It was evident in Chapter 2 that we like to derive iterative algorithms
for nonlinear problems from considering the solutions to properly
chosen models of the problems. The model used must be from a class
for which the solution of the model problem is possible by an ef-
fective numerical procedure, but also it must be chosen to adequately
model the nonlinear problems so that the iteration sequence will
converge to a solution.
In Chapter 2, elementary calculus gave all the necessary tech-
niques for building the relevant linear and quadratic models and ana-
lyzing their approximation errors with respect to a realistic class of
nonlinear problems. The solution of the model problem required only
a couple of arithmetic operations. This simplicity was our reason for
writing Chapter 2. There seems no pressing need for another expo-
sition of scalar iterations, but we were able to present, without the
complications of multivariable calculus and linear algebra, ideas that
will extend to the multivariable case.
In multiple dimensions, our models will involve derivatives of mul-
tivariable functions, and the solution of a system of linear equations
will be needed to solve the model problem. Chapter 3 presents mate-
rial from computational linear algebra relevant to the solution of the
model problems or the extraction of useful information from them.
Chapter 4 is a review of some multivariable calculus theorems that we
will find useful in setting up multivariable models and analyzing their
approximation properties.
There is a subtle and interesting relationship between the
models we build and the means we have to extract information from
them. If it is cheap to form and to solve the model problem, the
model need not be as good as if the model solution were very ex-
pensive. This is just a way of stating the obvious fact that we can
afford to do more iterations of a cheap method than of an expensive
one. Part of our interest lies in using problem structure, which is not
too expensive to incorporate into the model, in order to improve the
model or to facilitate the extraction of x+ from it. Another interest is
in considering how much problem structure we can safely ignore in
the model for the facilitation of its solution and still expect meaning-
ful convergence of the iteration. We will give examples of both ap-
proaches at appropriate times.
39

3
Numerical Linear
Algebra Background
This chapter discusses the topics in numerical linear algebra needed to im-
plement and analyze algorithms for multivariable nonlinear problems. In Sec-
tion 3.1 we introduce vector and matrix norms to measure the sizes of these
objects in our algorithms, and norm properties useful in analyzing our meth-
ods. We then describe in Section 3.2 the various matrix factorizations used by
our algorithms for solving systems of n linear equations in n unknowns. In
Section 3.3 we briefly discuss problem sensitivity to the errors involved in
solving such systems. Our point of view is that the user may obtain the
appropriate algorithms from some subroutine library, but the serious user
needs to understand the principles behind them well enough to know the tools
of numerical linear algebra that can help, which routines to use for specific
problems, and the costs and errors involved. For reference, Section 3.5 sum-
marizes properties of eigenvalues that we will use in this book, especially their
relation to positive definiteness. In Sections 3.4 and 3.6 we discuss the updat-
ing of matrix factorizations and the solution of overdetermined systems of
linear equations, respectively. Since these topics will not be needed until
Chapters 8 and 11, respectively, their consideration can be postponed until
then.
Excellent references for this material are the books by J. Wilkinson
40

Numerical Linear Algebra Background 
Chap. 3 
41
(1965), G. W. Stewart (1973), G. Strarvg (1976), G. H. Golub, and C. Van Loan
(1983).
3.1 VECTOR AND MATRIX NORMS
AND ORTHOGONALITY
In Chapter 2 we found it useful to make certain assumptions on/, such as the
absolute value of a derivative being bounded below, or the Lipschitz condition
(2.4.1), that gave a bound on the magnitude of the derivative change divided
by the magnitude of the corresponding argument change. In the sequel, we will
need similar conditions, but in a context where the absolute value no longer
can measure magnitude because the arguments and derivatives are no longer
scalar. Similarly, conditions like the stopping criterion |f(xk)| < 
l will have
to be replaced by criteria suitable for the case where F(xk) is a vector.
In Chapter 4 we will see that function values will be vectors or scalars,
and derivatives will be matrices or vectors. This section will introduce norms
of vectors and matrices as the appropriate generalizations of the absolute
value of a real number.
There are many different norms, appropriate to different purposes, and
we will limit our discussion to just a few. We will especially be interested in the
so-called Euclidean or l2 norm, which coincides with the usual notion of
vector magnitude. Also in this section is a discussion of orthogonal matrices.
These matrices have a special relationship to the Euclidean norm that makes
them very important for numerical linear algebra.
Recall that Rn denotes the vector space of real n x 1 vectors. We will
generally use Greek lower-case letters for real numbers, elements of R, and
lower-case roman letters for vectors. Matrices will be denoted by capital
roman letters, and the set of n x m real matrices will be denoted by Rnx m. The
superscript T will denote the matrix transpose. We will use the same symbol 0
for the zero vector as well as the zero scalar. Thus the reader will easily see
from (3.Lib) below that || 0 || = 0.
Definition 3.1.1. A norm on Rn is a real-valued function || • || on Rn that
obeys:

42 
Chap. 3 Numerical Linear Algebra Background
The three vector norms most suitable for our purposes are: for v =
(v l,v 2,...,v n) TeR n,
These are all instances of the general class of lp vector norms for 1 < p < 
,
The reader can show that (3.1.2a) is consistent with (3.1.3) in the limit as p
approaches 
(Exercise 1).
In our discussions of convergence, we will be speaking of a vector se-
quence {xk} converging to a vector x*. We will be thinking of a certain norm
when we make such a statement, and we will mean
We will also speak of the rate of convergence of {xk} to x* and we will mean
the rate of convergence of {|| xk - x+ \\} to 0. It would be unfortunate if it were
necessary to specify the norm, as we would have to if it were possible to
converge in one norm but not in another. It would mean that whether a
particular algorithm converged in practice might depend on what norm its
stopping criteria used. Fortunately in R" we have no such problem, owing to
the following result that is not true in infinite-dimensional space. We should
point out that q-linear convergence is a norm-dependent property.
THEOREM 3.1.2 
Let || • || and HI • HI be any two norms on Rn. There
exist positive constants a and 
such that
for any v e Rn. Furthermore, if {vk} is any sequence in Rn, then for
v* e Rn,
if and only if for each i, 1 < i < n, the sequence (vk)i of ith components of
vk converges to the ith component (v*)i of v*.

Numerical Linear Algebra Background Chap. 3 
43
We leave the proof as an exercise, since it is not central to our topic. An
easier exercise is the particular set of relations
from which (3.1.4) can be derived for the l1 12, and / 
norms. The relation
II v || 
can be proven easily, using the Cauchy-Schwarz inequality:
The important conclusion from relations (3.1.4) and (3.1.5) is that the per-
formance of an algorithm is unlikely to be affected seriously by a choice of
norm, and so this choice is usually based on convenience, or appropriateness
to a particular problem.
We mentioned earlier that we will need to measure matrices as well as
vectors. This certainly can be done by thinking of a matrix A = (aij) as corre-
sponding to the vector (a11, a 2 1,...,a n l, a 1 2,..., ann)T and applying any
vector norm to this "long" vector. In fact, the useful Frobenius norm is just
the l2 norm of A written as a long vector:
It is usual to call these "matrix norms," and they are relevant when we view
the matrix as a set of pigeonholes filled with quantitative information. This
will relate to their function in the local models on which the iterations of our
nonlinear methods will be based.
We also will want to measure matrices in the context of their roles as
operators. If v has a certain magnitude || v ||, then we will want to be able to
bound || Av \\, the magnitude of the image of v under the operator A. This will
be useful in analyzing convergence; the reader can look back to Section 2.4
and see that this was exactly the use of the bound, involving the symbol p, for
the model derivative. Operator norms must depend on the particular vector
norms we use to measure v and Av.
A natural definition of the norm of A induced by a given vector norm is
—that is, the maximum amount A can stretch any vector in the given vector
norm || • ||. It is not necessary at all to use the same norm on v and Av, but we
have no need of such generality.
Norm (3.1.7) is called the operator norm induced by vector norm || • ||,
and for any lp vector norm it is denoted by || A \\p. It is easily shown to obey
the three defining properties of a matrix norm, which are simply (3.1.1) with A,

44 
Chap. 3 Numerical Linear Algebra Background
Be Rnxm replacing v, w e Rn. Although it appears that definition (3.1.7) may
be of little use computationally, since it involves the solution of an opti-
mization problem, it is an exercise to show that the l1 /2, and / 
induced
matrix norms are given by
Here a j denotes thejth column of A and a, its ith row. Thus \\A\\1 and || A \\
are easy to compute, while || A \\ 2 is useful in analysis.
Sometimes a linear transformation of the problem will cause us to use a
weighted Frobenius norm:
("nonsingular" means "invertible"). Although the Frobenius and the lp in-
duced norms obey the consistency condition
the weighted Frobenius norm does not, except in special cases.
Several properties of matrix norms and matrix-vector products are of
particular importance in analyzing our algorithms, and these properties are
listed below. Proofs of some are given as exercises with appropriate hints as
necessary. The n-dimensional identity matrix is denoted by /, with n under-
stood from the context. For M e Rnxn, the trace of M is defined as
THEOREM 3.1.3 
Let || • || and ||| • ||| be any norms on Rnxn. There exist
positive constants a, 
such that
for every A e Un xn. In particular,
and, for p = 1 or p = 
,
The Frobenius norm of A satisfies

Numerical Linear Algebra Background Chap. 3 
45
and for any Be Rnxn,
Furthermore, for any v, w e Rn,
and
If A is nonsingular, then the operator norm induced by || • || satisfies
The next theorem says that matrix inversion is continuous in norm.
Furthermore it gives a relation between the norms of the inverses of two
nearby matrices that will be useful later in analyzing algorithms.
THEOREM 3.1.4 
Let || • || be any norm on RnXn that obeys (3.1.10) and
= 1 and let EE R n x n. If ||E|| 
< 1, then (I- E) - 1 exists and
If A is nonsingular and || A 
l(B — A) \\ < 1, then B is nonsingular and
Proof. 
We will give the idea rather than the detail. Inequality (3.1.20)
follows from the direct application of (3.1.19) with one use of (3.1.10), and
so we leave it as an exercise. The proof of (3.1.19) is very much like the
proof that
The outline is to show that (/ + E + E2 + • • • + Ek) = Sk defines a
Cauchy sequence in Rnxn and hence converges. Then it is easy to show
that (limk _ Sk) is (/ - E)-', and (3.1.19) follows from

46 
Chap. 3 Numerical Linear Algebra Background
Finally we introduce the concept of orthogonal vectors and matrices.
Some simple properties of orthogonal matrices in the 12 norm indicate that
they will be useful computationally. We have been denoting the inner product
of two vectors v, w e Rn as VTW, but we will occasionally find some special
notation useful. In the following two definitions, we juxtapose two meanings
for V1 to warn the reader again to interpret it in context.
Definition 3.1.5. 
Let v, w e Rn; the inner product of v and w is defined
to be
where 
is the angle between v and w, if v 
0 
w. If <v, w> = 0, then v and w
are said to be orthogonal or perpendicular.
Definition 3.1.6. 
Vectors v1 ..., vk e Rn are said to be orthogonal or
mutually orthogonal if vi,, vj) = 0 for i 
j. If <v1, v1,> = 1 in addition, then
the set {v1,..., vk} is said to be orthonormal, and if k = n, it is an orthonormal
basis for Rn.
If Q e Rnx p, then Q is said to be an orthogonal matrix if
An equivalent definition to (3.1.22) is that the columns or rows of an
orthogonal matrix form an orthonormal set of vectors. The following theorem
contains some properties of orthogonal matrices that make them important in
practice. Proofs are left as exercises.
THEOREM 3.1.7 
If Q, Q€ Rnxn are orthogonal matrices, then QQ is
orthogonal. Also, for any v € Rn and A e Rnxn,
and
Equation (3.1.23) shows that an orthogonal matrix corresponds to our
geometric concept of a rotation-reflection operator, since it can change only
the direction, but not the size, of a vector v. Equation (3.1.24) says that an

Numerical Linear Algebra Background Chap. 3 
47
orthogonal matrix also does not change the size of a matrix. These are two
reasons why orthogonal matrices are useful in matrix factorizations.
3.2 SOLVING SYSTEMS OF LINEAR
EQUATIONS—MATRIX
FACTORIZATIONS
Multidimensional nonlinear algorithms almost always require the simulta-
neous solution of at least one system of n linear equations in n unknowns,
at each iteration, usually to find the Newton point by solving the model
problem or some modification of it. Luckily, excellent subroutine libraries for
this problem are available: in the United States primarily in the LINPACK
and IMSL libraries, and in Britain in the NAG and Harwell libraries. These
libraries include algorithms to solve (3.2.1) for general matrices A and special
algorithms more efficient for cases when A has particular kinds of structure
such as symmetry and positive definiteness—common attributes in systems
arising from minimization applications. Because of the availability of these
routines and the careful effort and testing invested in them, our approach is
that a person who solves nonlinear problems need not, and probably should
not, write a personal linear equations solver; rather, that person should know
which canned routine to use for the various types of problems (3.2.1) he or she
may encounter, and the costs and possible problems involved in using these
routines. It is also important to have a basic understanding of the structure of
these routines in order to interface with them easily and to be aware of
techniques useful in other parts of nonlinear algorithms.
It is common practice to write the form A - l b for economy of notation in
mathematical formulas—for example, xk + 1 =xk — A
- l F ( x k ) in the Newton
iteration for F(x) - 0. The trouble is that a reader unfamiliar with numerical
computation might assume that we actually compute A-1 and take its product
with the vector b. On most computers it is always more effective to calculate
A ~ lb by solving the linear system Ax = b using matrix factorization methods;
this may not be true on some "vector machines."
Matrix factorization techniques are based on decomposing A into
A = A1 A2- ... • Am
where each At is of a form for which (3.2.1) is easy. For us, m < 5 with m = 2
or 3 most often. Once we have A factored, or while we are factoring it, we try
to determine questions of singularity or invertibility of A. If A is nearly singu-
lar, then problem (3.2.1) is not numerically well posed, and perhaps it is more

48 
Chap. 3 Numerical Linear Algebra Background
important to know this than to compute an unreliable solution. More will be
said about this in the next section.
If we decide to proceed with the solution of Ax = b, then we peel off the
factors to solve in order:
A1b1 =b,
A2b2 = b1„
Ambm = 
bm-1.
and x = bm is the desired solution. To verify this, note that each b1 equals
sothat
Below we list the six most important choices of At and briefly mention
special features of solving (3.2.1) with each choice.
1. AI is a permutation matrix P. A permutation matrix has the same rows
(and columns) as the identity matrix, although not in the same order. For
any matrix M, PM is then just the same permutation of the rows of M,
and MP permutes the columns. Also P-1 = PT is a permutation matrix.
P is usually stored as a vector p = (p1 ..., pn)T, a permutation of
(1, 2, ..., n)T, where the convention is that the rth row of P is the p,th
row of /. It is easy to see that Px = b is solved by xpi = bi, i = 1, ..., n.
2. AI is an orthogonal matrix denoted by Q or U. Since Q-' = QT, Qx = b
is solved by forming QTb, and, since we often generate Q as a product of
elementary orthogonal transformations, often this can be done in an
efficient way that doesn't require an explicit computation of Q.
3. AI is a nonsingular diagonal matrix D, dti = di,•, 
0, i = 1, ..., n, dtj = 0,
i 
j. Dx = b is solved by xi = bi/di, i = 1, ..., n. D is stored as a vector.
4. Al is a nonsingular block diagonal matrix DB, which consists of 1 x 1
and 2x2 
invertible blocks on the main diagonal and zeros elsewhere;
for example,
DBx = b is solved by solving the corresponding 1 x 1 and 2x2 
linear
systems.
5. A, is a nonsingular lower triangular matrix L, /ii 0, i = 1, ..., n, lij_,- = 0,

Numerical Linear Algebra Background 
Chap. 3 
49
1 < i < j < n; schematically,
If lii= 1, i = 1, ..., n, L is called unit lower triangular. Lx = b is solved
by forward substitution; use the first equation to solve for x1, then
substitute into the second equation to solve for x2, then the third equa-
tion for x3, and so on.
6. AI is a nonsingular upper triangular matrix denoted by U or R, the
transpose of a lower triangular matrix. Ux = b is solved by back substi-
tution, using equations n through 1 to solve for xn through x1, in that
order.
The arithmetic costs of solving linear systems with the above types of
matrices are given in Table 3.2.1. All are small in comparison to the cost of
matrix factorizations. Note that solving Px = b just involves n assignments.
Table 3.2.1
Matrix
Q
D
DB
Lor V
Arithmetic cost in solving linear systems, leading terms
Multiplications/ Divisions
n2
n
<5n/2
n2/2
Additions/ Subtractions
n2
<n
n2/2
We will be interested in factorizations for three types of matrices: no special
structure, symmetric, and symmetric and positive definite. A e Rnxn is sym-
metric if A = AT. A is positive definite if vTAv > 0 for all nonzero v e Rn, or
equivalently if A is symmetric, if all its eigenvalues are positive.
For a general square matrix A, two important factorizations are the
PLU and the QR. The PLU decomposition yields A = P • L • U or PTA = LU
for a permutation matrix P, a unit lower triangular L, and an upper triangular
U. The decomposition is found by Gaussian elimination with partial pivoting,
or Doolittle reduction, using standard row operations (equivalent to premul-
tiplying A by L - 1 P - 1 ) to transform A into U, and simultaneously yields the
decomposition. The QR or QRP decomposition, A = QRP, Q orthogonal, R
upper triangular, and P a permutation matrix, is obtained by transforming A
to R by premultiplying A by a series of n — 1 orthogonal matrices Qi. Each Q,
zeros out the elements of the ith column of Qi_1 • ... -Q 1A below the main
diagonal, while leaving the first i — 1 columns unchanged. Qi is called a

50 
Chap. 3 Numerical Linear Algebra Background
Householder transformation and is of the form
where (ui) = 0, j = 1, ..., i — 1, and the remaining elements of ui, are selected
so that Qi is orthogonal and induces the desired zeros in column i. The
permutation matrix, which is not always used, is formed from the column
permutations necessary to move the column with the largest sum of squares
below row i — 1 into column i at the ith iteration.
The advantage of the QR decomposition is that, since || R \\2 = \\ QR ||2 =
IAPTII2 = I A I l a * it doesn't magnify size differences of elements in A when
forming R. This makes it very stable numerically and is one reason House-
holder and other orthogonal transformations are important to numerical
linear algebra. On the other hand, the PLU decomposition is generally quite
accurate and is half as expensive as the QR, so both factorizations are used in
practice. In our secant algorithms, we will use the QR without column pivots
on the derivative matrices because it is cheaper to update, after low-rank
changes to the matrix, than the PLU. In fact, we will recommend using the QR
algorithm in any algorithm for solving dense systems of nonlinear equations
for an implementation reason that is discussed in Section 6.5. A QR decompo-
sition algorithm is given in Algorithm A3.2.1 in the appendix.
When A is symmetric and positive definite, a more efficient algorithm is
the Cholesky decomposition, A = LLT, L lower triangular. L is found simply
by writing the (n2 + n)/2 equations expressing each element in the lower trian-
gle of A in terms of the elements in L:
and solving in this order for /11, /21, ..., /nl, /22, /32, ..., /n2, /33, ..., /n3, ...,
using the equation for au to solve for ltj. The algorithm is very stable numeri-
cally; it involves taking n square roots to find the diagonal elements lij,
i=1,...,«, which will all be of positive numbers if and only if A is positive

Numerical Linear Algebra Background Chap. 3 
51
definite. Sometimes the decomposition is expressed as A — LDLF, L unit lower
triangular, D diagonal with positive diagonal elements. This form of the de-
composition does not require any square roots. A Cholesky decomposition
algorithm is a special case of Algorithm A5.5.2 in the appendix.
If A is symmetric but indefinite—i.e., A has positive and negative
eigenvalues—then A can be efficiently and stably factored into PLDB LT, P a
permutation matrix, L unit lower triangular, DB a 1 x 1 and 2x2 
block
diagonal matrix. For further information on this factorization, see Bunch and
Parlett (1971). Aasen (1973) gives a version in which DB is replaced by T, a
tridiagonal matrix. See Golub and Van Loan (1983) for more details. For a
detailed discussion of the PL U, QR, or LIT decompositions, see e.g. Stewart
(1973) or Dongarra et al (1979).
The arithmetic costs of all the factorizations are small multiples of n3
and are given in Table 3.2.2.
Table 3.2.2 
Arithmetic cost of matrix factorization, leading terms
Factorization
A = PLU
A = QR
A = LLT, LDLT
A = PLDBLTPT
A = PLTLTPT
Multiplications/ Divisions
n3/3
2n3/3
n3/6
n3/6
n3/6
Additions/ Subtractions
n3/3
2n3/3
n3/6
n3/6
n3/6
Nonlinear problems that give rise to sparse linear systems, where most of
the matrix elements are zero, are discussed briefly in Chapter 11. In solving
them, one should use the special subroutines available for sparse matrix prob-
lems; the Harwell and Yale packages are widely available.
3.3 ERRORS IN SOLVING
LINEAR SYSTEMS
An iteration of a nonlinear algorithm will use the solution s of a linear system
Acs = — F(xc) to determine the step or direction to the next approximate
solution x + . Therefore, it is important to know how much the computed step
may be affected by the use of finite-precision arithmetic. Also, since Ac and
F(xc) are sometimes approximations to the quantities one really wants to use,
one is interested in how sensitive the computed step is to changes in the data
Ac and F(xc). These topics are discussed in this section.

52 
Chap. 3 
Numerical Linear Algebra Background
Consider two linear systems
Both have the solution (1, l)r. If we change bl to b1 - (0.04, 0.06)T, a relative
change of 0.43% in the 12 norm of b1 the new solution to the first system is
(0.993, 0.9968)T, a 0.51% relative change in the 12 norm of x. However, if we
change b2 by the same ( — 0.04, — 0.06)T, a relative change of 0.55%, the new
solution to the second system is (6, 0)T, a whopping relative change of 324% in
x. Similarly, changing the first column of A2 to ( , 2.00)T also causes x to become
(6, 0)T. Clearly, the second system is very sensitive to changes in its data. Why?
Graphing its two equations shows that they represent two nearly parallel lines, so
that moving one a little alters their point of intersection drastically. On the other
hand, the first system corresponds to lines meeting at about an 80° angle, so that a
shift in either line causes a similar shift in the point at which they cross. (See
Figure 3.3.1.)
Linear systems whose solutions are very sensitive to changes in their
data are called ill-conditioned, and we will want a way to recognize such
systems. It is easily shown that ill-conditioning can be detected in terms of the
matrix in the system. Consider any system Ax = b with A nonsingular, and let
us determine the relative change in the solution x*, given some relative change
in b or in A. If we change b by Ab, then the new solution can be written as
x* + Ax, where
so that
Thus in any vector norm || • || and the corresponding induced matrix operator
Figure 33.1

Numerical Linear Algebra Background Chap. 3 
53
norm
Also from Ax* = b,
so that
Similarly if we change A by
set
and let
then
which yields
In both cases, the relative change in x is bounded by the relative change
in the data multiplied by \\A \\ • \ \ A - l \\. This term is known as the condition
number of A and is denoted by Kp(A), when using the corresponding lp induced
matrix norm. In any induced matrix norm, the condition number is the ratio
of the maximum to the minimum stretch induced by A [see equations (3.1.7)
and (3.1.18)] and so it is greater than or equal to 1. In our examples,Kl(Al) =
(15X0.14) = 2.1 and Kl(A2) = (13.35X300) = 4005, indicating that the second
system is far more sensitive to changes in its data than the first. Since the
minimum stretch induced by a singular matrix is zero, the condition number
of a singular matrix can be considered infinite. Therefore, the condition
number of a nonsingular matrix is a measure of the matrix's nearness to
singularity. It has the nice property of being a scale-free measure with respect
to scalar multiples, since K(aA) = K(A) for any nonzero a e R and any matrix
norm.
The condition number is also a measure of sensitivity of the solution of
Ax = b to finite-precision arithmetic. When a linear system is solved on a
computer, it can be shown that the solution obtained is the exact solution to a
perturbed system (A + A)x = b. This method of analysis is often called the
Wilkinson backward error analysis, and the reference is Wilkinson (1965). It
can be shown that some of the methods discussed in Section 3.2 limit
|| A 11/| | A || to a constant times machine epsilon, and in practice this is almost
always true for all of them. Therefore, the relative error in the finite-precision solution
is bounded by a constant times (k(A) • macheps).

54 
Chap. 3 Numerical Linear Algebra Background
So, the condition number of A is a useful quantity in bounding how
sensitive the solution of Ax = b will be to either data errors or the effects of
finite-precision arithmetic. If A is almost singular in this sense, one can expect
trouble in solving Ax = b. Thus, we will look out for ill-conditioned linear
systems in extracting information from our local models, because however
simple and accurate the model, the solution of a model problem that is sensi-
tive to small changes is certainly of limited use as an approximation to the
solution of the nonlinear problem. If ill-conditioning occurs far from the solu-
tion to the nonlinear problem, where the model is not reckoned to be very
accurate anyway, we usually just perturb the linear system into a better-
conditioned one, and proceed. If ill-conditioned systems occur near the solu-
tion, where the model seems to be good, then this indicates that the solution of
the nonlinear problem is itself very sensitive to small changes in its data (see
Figure 3.3.2). This may indicate that the underlying problem is not well posed.
Finally, we need to discuss how we will determine in practice whether a
linear system (3.2.1) is sufficiently ill-conditioned that we should avoid solving
it. From the analysis of Wilkinson (1965), we see that if K(A) > (macheps)-1,
then the computed solution to (3.2.1) is likely to be entirely unreliable. In fact
it is generally felt that if K(A) > (macheps)-1/2, then the computed solution to
(3.2.1) may not be trustworthy. Our algorithms will check for such a condition
and then perturb poorly conditioned models into ones that are better behaved.
A problem is that calculating K(A) involves finding || A-l ||, and not only
may this be unreliable, but its expense is rarely justified. Therefore what is
done is to estimate K(A) by
condest = \\M\\- invest,
where M is either A or the factor of A most likely to have the same condition-
ing as A, and invest is an estimate of || M - 11|. In our application, we will want
Figure 3.3.2 
The correspondence between ill conditioning in linear and
nonlinear systems of equations

Numerical Linear Algebra Background Chap. 3 
55
to estimate the condition number of a matrix A that has been factored into
Q • R. It is an easy exercise to show that in this case,
Therefore, we estimate Kt(K), since the l1 norm of a matrix is easy to compute.
The algorithm we use is an instance of a class of condition number estimates
given by Cline, Moler, Stewart, and Wilkinson (1979) and is given by Algo-
rithm A3.3.1 in Appendix A.
The algorithm first computes || R 
- The technique then used to estimate
|| R' l ||1 is based on the inequality
for any nonzero z. The algorithm chooses z by solving RTz = e, where e is a
vector of + 1's with the signs chosen to maximize the magnitude ofz1 ..., zn
in succession. It then solves Ry = z and returns condest = 
.
Although 
is only guaranteed to be a lower bound on \\R - l 
, in
practice it is quite close. One explanation is that the process for obtaining y is
related to the inverse power method for finding the largest eigenvalue of
( R T R ) - l . Another is that it turns out to have a knack for extracting any large
elements of R - 1. The reader who wants to establish more intuition about this
is urged to work through the example given in Exercise 19.
3.4 UPDATING MATRIX
FACTORIZATIONS
Later in the book we will consider multivariable generalizations of the secant
method for which the successive model derivatives Ac, A + e Rnxn, are related
in an especially simple way. In this section we see how to use the two most
important relationships between Ac and A+ to lessen the work in obtaining
factorizations of A + from those for Ac.
Specifically, we want to look first in some detail at the problem of
obtaining the factorization of Q + R + of
where u, v e Rn, and Ac is some nonsingular matrix with no special structure,
for which we already have the decomposition Qc Rc. The idea of the algorithm
is not hard at all. For w = 
, we write
and then we form the QR decomposition

56 
Chap. 3 Numerical Linear Algebra Background
Then R + = R and Q + = Qc Q. The advantage is that the QR decomposition of
Rc + WVT is much cheaper than the 5n3/3 operations we would have to spend
for Q + R+ if we made no use of the previous decomposition.
The tool we need for the factorization (3.4.2) is an orthogonal transform-
ation called a Jacobi rotation, a two-dimensional rotation imbedded in an
n-dimensional matrix. A Jacobi rotation is used to zero out one element of a
matrix while only changing two rows of the matrix. The two-dimensional
rotation matrix and th n-dimensional Jacobi rotation matrix are defined in
Definition 3.4.1, and the important properties are stated in Lemma 3.4.2.
Definition 3.4.1. A two-dimensional rotation matrix is an R( )) e R2 x 2,
or equivalently,
A Jacobi rotation is a matrix J(i, j, a, ) e Rnxn such that
Schematically,

Numerical Linear Algebra Background 
Chap. 3 
57
LEMMA 3.4.2 Let n > 2, and R( R(a, ), J(i, j, a, ) be defined above.
Then:
(a) For all 
e R and nonzero u e R2, R( ) is orthogonal, and R( ) • v
rotates v by 
counterclockwise; R(v2, v1)-1; = (0, |v||2)T, and
R(v1, -v2)-v = (||v||2,0)T.
(b) For all integers i,j e [1, n], i < j, and a, e R, | a | + | 1 0, J(i,j, a,
) is orthogonal. If M+ = J(i, j, a, )• M, M e Rnxn, then (M+)t. =
(M)k for 1 < k < n, k 
i or j; rows i and 7 of M + are each linear
combinations of rows i and 7 of M.
(c) If M,, • Mil 0, then [J(i,j, Mjl, Mil) • M]il = 0
and[J(/,7, M,,,-M,,)-M],, = 0.
To update the QR decomposition of Ac into a QR decomposition of
A + = Qc Rc + UV
T, Jacobi rotations are used to decompose Rc + Q* UVT =
Rc + WVT into QR as follows. First, n — 1 Jacobi rotations are applied to zero
out in succession rows n, n — 1, ..., 2 of wvr, by combining rows i and i — 1 to
zero out row i. The effect of each rotation on Rc is to alter some existing
elements and to introduce one new element directly below the diagonal in the
(i, i — 1) position. Thus the n — 1 rotations transform Rc + wvT into an upper
triangular matrix augmented by a diagonal below the main diagonal (an
"upper Hessenberg" matrix). Now n — 1 additional Jacobi rotations are ap-
plied, successively zeroing out the (i, i — 1) element, i = 2, 3, ..., n, by combin-
ing rows i — 1 and i. The result is an upper triangular matrix R, so that
Rc + WVT = QR and (Q)T is the product of the 2n - 2 rotations.
The reader can verify that the entire QR update process requires only
0(n2) operations. The most expensive part is getting Q+ = QCQcollected to
save for the next step. For the other important special relationship between Ac
and A+, Q+ is unnecessary, as we will now see.
When we are using local quadratic modeling to solve the unconstrained
minimization problem, we will prefer the Hessians, second-derivative matrices
in Rnxn, of the quadratic models to be symmetric and positive definite. We will
find extremely reasonable circumstances for the next model Hessian A+ to be
chosen to have these properties if the current model Hessian Ac does. Fur-
thermore, the derivation of A + from Ac will be very suggestive. It will say that
if Lc L is the Cholesky factorization of Ac, then A+ = J+J+, where
J+ = Lc + VUT.
But this tells us exactly how to get the Cholesky decomposition
A + = L, + L, + .
We simply apply the above technique to obtain the decomposition Q+R+ of
from the QR decomposition 
. We then

58 
Chap. 3 Numerical Linear Algebra Background
have immediately that
This update process also requires O(n2) operations. In this special case, how-
ever, we don't have the n2 operations necessary to form w = 
, since Qc = /,
nor do we have to accumulate Q+, since only R+ = 
is needed. The com-
plete algorithm is given in Algorithm A3.4.1 in the appendix.
As an alternative to the QR factorization and the updates discussed in
this secton, Gill, Golub, Murray, and Saunders (1974) suggest using the de-
composition A = LDV, where L is unit lower triangular, D is diagonal, and the
rows of V are an orthogonal, but not necessarily orthonormal, basis for Rn. In
this case, VVT = D, a diagonal matrix. The computation of L + D+V+ =
Lc Dc Vc + UVT, for u, v e Rn, is a bit cheaper than the QR update described
above. In the symmetric positive definite case, this corresponds to carrying
along the LDLT decomposition of {Ak}. These algorithms are collected in
Goldfarb(1976).
The sequencing of symmetric indefinite factorizations has been studied
extensively by Sorensen (1977), and his somewhat complex algorithm seems
completely satisfactory. The main source of the complication is in the permu-
tation matrices, and this is also why no algorithm for updating the PLU
decomposition of a matrix Ac into the decomposition P+L + U + of A+ =
Ac + UVT is known that is satisfactory in the current context.
3.5 EIGENVALUES AND POSITIVE
DEFINITENESS
In this section we state the properties of eigenvalues and eigenvectors that we
have used or will use in the text. We also summarize the definitions of positive
definite, negative definite, and indefinite symmetric matrices and their
characterizations in terms of eigenvalues. This characterization provides in-
sight into the shapes of the multivariable quadratic models introduced in
Chapter 4 and used thereafter.
Most of the theorems are stated without proof. Proofs can be found in
any of the references listed at the beginning of this chapter.
Definition 3.5.1. Let A e Rnxn. The eigenvalues and eigenvectors of A
are the real or complex scalars 
and n-dimensional vectors v such that
Av = v,v 
0.
Definition 3.5.2. 
Let A e Rnxn be symmetric. A is said to be positive
definite if vTAv > 0 for every nonzero v e Rn. A is said to be positive semi-
definite if vTAv > 0 for all v e Rn. A is said to be negative definite or negative

Numerical Linear Algebra Background 
Chap. 3 
59
semidefinite if — A is positive definite or positive semidefinite, respectively. A is
said to be indefinite if it is neither positive semidefinite nor negative semi-
definite.
THEOREM 3.5.3 
Let A e Rnxn be symmetric. Then A has n real eigen-
values 1, ..., 
n, and a corresponding set of eigenvectors v1 ..., vn that
form an orthonormal basis for Rn.
THEOREM 3.5.4 
Let A e R n x n be symmetric. Then A is positive defi-
nite if, and only if, all its eigenvalues are positive.
Proof. 
Let A have eigenvalues 
1,..., 
n, and corresponding orthonor-
mal eigenvectors v1, ..., vn. Suppose j, < 0 for some j. Then 
Av- —
, which shows that A is not positive definite.
Now suppose every 
is positive. Since {vi} is a basis for Rn, any non-
zero v 6 Rn can be written as
where at least one 
is nonzero. Then
owing to the orthonormality of the 
. Thus A is positive definite.
THEOREM 3.5.5 
Let A e R n x n be symmetric. Then A is positive semi-
definite if, and only if, all its eigenvalues are nonnegative. A is negative
definite or negative semidefinite if, and only if, all its eigenvalues are
negative or nonpositive, respectively. A is indefinite if and only if it has
both positive and negative eigenvalues.
The following definitions and theorems will be needed in Section 5.5.
THEOREM 3.5.6 
Let A e IR
nxn be symmetric with eigenvalues 
l ..., 
n.
Then

60 
Chap. 3 Numerical Linear Algebra Background
If A is nonsingular, then
THEOREM 3.5.7 
Let A e R n x n have eigenvalue ,. Then , - a is an
eigenvalue of A + I, for any real .
Definition 3.5.8. Let A e Rnxn be symmetric. A is said to be strictly
diagonally dominant if, for i = 1, ..., n,
THEOREM 3.5.9 
GERSCHGORIN
Let A e Rnxn be symmetric with eigenvalues 1,..., n. Then
COROLLARY 3.5.10 
If A is strictly diagonally dominant, then A is
positive definite.
3.6 LINEAR LEAST SQUARES
The final linear algebra topic we discuss is the linear least-squares problem:
which is the special case of the nonlinear least-squares problem:

Numerical Linear Algebra Background Chap. 3 
61
where r,(x) = (a,.) x — bi for each i = 1,..., m. The reasons for studying prob-
lem (3.6.1) are that one sometimes needs to solve it as a subproblem of the
nonlinear least-squares problem and that an understanding of the linear prob-
lem aids the understanding of its nonlinear counterpart. In connection with
the linear least-squares problem, we introduce the singular value decompo-
sition, a powerful numerical linear algebra tool that is helpful in many situ-
ations.
A common occurrence of the linear least-squares problem is in trying to
fit m data points (t i, yi) with a function /(x, t) that is linear in its n free
parameters xl ..., xn. For example, suppose one would like to fit the three
pairs (1,2), (2, 3), (3, 5) with the functionf(x, t) = x1 + x2 e' (see Figure 3.6.1).
To get an exact fitf(x, tt) = yi i = 1,2, 3, would require Ax = b, where
Since Ax = b is an overdetermined system of equations, we don't expect to
solve it in the usual sense. Instead we choose x to minimize some measure of
the vector of residuals Ax — b. The /2 norm is chosen because the resultant
problem (3.6.1) is mathematically well behaved and also has a statistical justi-
fication.
Note that finding the solution to this instance of (3.6.1) is equivalent to
asking "Which linear combination of (1, 2, 3)T and (e, e2, e3)T comes closest to
(2, 3, 5)r in the 12 norm?" In general, problem (3.6.1) can be interpreted as
"Find the linear combination of the columns a 1, ..., an of A that is closest to
b in the 12 norm." Geometrically, this means finding the point in the n-
dimensional subspace C(A) spanned by the columns of A that is closest to the
Figure 3.6.1 A sample linear least squares problem

62 
Chap. 3 Numerical Linear Algebra Background
vector b in the Euclidean norm (see Figure 3.6.2). This interpretation leads to
an easy solution of the linear least-squares problem.
We know that the closest point to b in C(A) will be Ax* e C(A) such
that Ax* — b is perpendicular to the entire subspace C(A). Thus x* must
satisfy 
(a .i)T(Ax* — b) = 0, i = 1, ..., n, or equivalently, AT(Ax* — b) = 0.
Clearly, Ax* is unique, and if the columns of A are linearly independent, the
value of x* that yields the point Ax* is also unique and is the solution to the
system of equations
which is nonsingular.
This information is summarized in Theorem 3.6.1, and its algebraic proof
is left as an easy exercise.
THEOREM 3.6.1 Let m > n > 0, A e Rmxn, b e Rm. Then the solution to
is the set of points (x*: AT(Ax*. — b) = 0}. If the columns of A are
linearly independent, then x* is unique, ATA is nonsingular, and x* =
(ATA)-lATb.
Equations (3.6.3) are known as the normal equations. Although they
define x* uniquely when A has full column rank, they are not always the way
x* should be calculated. This is because forming the matrix ATA can cause
underflows and overflows and can square the conditioning of the problem in
Figure 3.6.2 
The solution to the linear least squares problem

Numerical Linear Algebra Background Chap. 3 
63
comparison to a method that uses A directly. When A has full column rank,
we can use the QR decomposition of A,
Q E R m x m orthogonal, R e Rmxn upper triangular, obtained using the same
techniques as the QR decomposition of a square matrix. This decomposition
also yields a numerically stable orthonormalkation of the columns of A. The
following theorem shows how to use (3.6.4) to solve (3.6.1).
THEOREM 3.6.2 Let m > n > 0, b e Rm, A e Rmxn with full column
rank. Then there exists a decomposition A = QR of the form (3.6.4),
where Q is an m x m orthogonal matrix, R e Rmxn is upper triangular,
and Ru, the top n rows of R, is a nonsingular upper triangular matrix.
The unique solution to (3.6.1) is
where
the minimum of
Proof. 
The existence of the QR decomposition of A follows from its
derivation by Householder transformations, and the nonsingularity
of Ru follows from the full column rank of A. Using equation (3.1.23),
so (3.6.1) can be rewritten
Then if
we have
which clearly is minimized when
If A doesn't have full rank, there are multiple answers x to problem
(3.6.1), and so the problem can be further restricted to find the smallest of these

64 
Chap. 3 
Numerical Linear Algebra Background
answers in the /2 norm:
Problem (3.6.5) is of interest whether m is greater than, equal to, or less than n,
and it can be solved in all cases by using the singular value decomposition
(SVD) of A. The SVD is a matrix factorization that is more costly to obtain
than the factorizations we have discussed so far, but also more powerful. It is
defined in Definition 3.6.3, and its factors are characterized in Theorem 3.6.4.
Theorem 3.6.5 shows how to use the SVD to solve problem (3.6.5).
Definition 3.6.3. Let A e Rmxn and let -k = min {m, n}. The singular
value decomposition of A is A = UDVT, where V e R m x m and V E Rnxn are
orthogonal matrices, D e Rmxn is defined by dii = , > 0, i = 1, ..., k, dij = 0,
i 
j. The quantities 
are called the singular values of A.
Notice that we are using U to denote an orthogonal matrix, even though
we used the same symbol in Section 3.3 for upper triangular matrices. There
should be no confusion for the alert reader in this well-established notation.
Furthermore, the use of the symbols U and V is traditional for matrices whose
columns are to be thought of as eigenvectors, and the following lemma will
show that this is the case.
THEOREM 3.6.4 
Let A e R
m x n. Then the SVD of A exists, the diagonal
elements a, of D are the nonnegative square roots of the eigenvalues of
AAT if m < n, or of ATA if m > n, and the columns of U and V are the
eigenvectors of AAT and ATA, respectively. The number of nonzero
singular values equals the rank of A.
Proof. 
An existence proof for the SVD can be found in the references
given at the beginning of the chapter. Since AAT = UDDTUT 
and
ATA = VDTDVT, 
we have (AAT)- U = U-(DD
T) (ATA)V = V(DTD).
Thus, if u j and Vj are the respective jth columns of U and V, then:
where the 
are the diagonal elements of DDT and DTD, A, = ( })2,
j = 1, ..., min {m, n}; and 
,- = 0, j = min {m, n} + 1, ..., max {m, n}.
Since multiplying a matrix by a nonsingular matrix doesn't change its
rank, rank (A) = rank ( ), the number of nonzero

Numerical Linear Algebra Background Chap. 3 
65
THEOREM 3.6.5. 
Let A e Rm xn have the SVD A = UDVT, with V, D, V
as defined in Definition 3.6.3. Let the pseudoinverse of A be defined as
D+ e IR
n x m. Then the unique solution to problem (3.6.5) is x* = A + b.
Proof. 
From A = UDVT and equation (3.1.23), (3.6.5) is equivalent to
min
or equivalently, for
min
Let k equal the number of nonzero .'s in D. Then
which is minimized by any z such that z,•, = (U
Tb) 
, i = 1, ..., k.
Among all such z, ||z||2 is minimized by the one for which zi, = 0,
i = k + 1, ..., m. Thus the solution to (3.6.7) is z = D+UTb, so that x* =
VD+UTb = A + b.
The singular value decomposition is found by an iterative process closely
related to the algorithm for finding the eigenvalues and eigenvectors of a
symmetric matrix, so it is more costly to obtain than our other matrix de-
compositions. It is the recommended method for solving (3.6.5) when A is not
known to have full row or column rank. If m < n and A has full row rank,
(3.6.5) is solved more efficiently by the LQ decomposition (see Exercise 27).
The SVD is also the most reliable technique for computing the rank of a
matrix, or equivalently, the number of linearly independent vectors in a set of
vectors. The SVD can also be used to determine the sensitivity of x = A - l b
for a square matrix A with respect to data changes 
b. Also, if A is non-
singular, then K2(A) = 
n, and the SVD is the most dependable way of
computing K2(A).
One final note on determining the rank of a matrix from its SVD is that
D really gives us more information about linear independence of the columns
of A than we can pack into the single integer whose value is the rank of A. For
example, if n = 3 and 
v = 1, 2 = .1, 
3 = 0, then we would agree that A has
rank 2. If 
3 were changed to macheps, we would probably still feel that all the
information was conveyed by saying rank (A) = 2. What about 
l = 1, 
3 =

66 
Chap. 3 Numerical Linear Algebra Background
macheps, and 
2 = (macheps)1/2 or 100 macheps, and so on? As n get larger,
there are more awkward distributions of the singular values to worry about.
No one really knows what to do, but it is certainly reasonable to look for
"breaks" in the singular values and count all singular values of about the same
magnitude as either all zero, or all nonzero.
It is important that the user of canned programs understand these
issues. The reason is that, for example, in ROSEPACK and EISPACK, when
(3.6.1) is solved by use of the SVD, once rank decisions have been made, A is
modified to have the "small" singular values set to zero and the modified
problem is solved. However, nothing is done behind the user's back, and it is
only necessary to read the program documentation to understand what is
done. It is safe to say that for internal efficiency reasons, any subroutine to
compute an SVD will return zero values for any singular values that are
negligible in the context of the computation. Dongarra et al. (1979) gives a
particularly succinct explanation of a typical test for negligibility.
3.7 
EXERCISES
1. Prove for any x € Rn that
Notice that we really mean that for every real sequence {pk} that converges to
we have
2. (Hard) Prove Theorem 3.1.2.
3. Prove relations (3.1.5).
4. Prove that for any p > 1, the lp induced matrix operator norm (3.1.7) obeys the
three defining properties of a norm [(3.1.1) using matrices] plus consistency
[(3.1.10)].
5. Prove that (3.1.8a) correctly evaluates the l1, induced matrix norm. [Hint: Show
that for all v e Rn,
with equality for at least one v.] Do the same for the / induced matrix norm.
6. Prove (3.1.8b). (Use the techniques of proof of Theorem 3.5.4.)
7. Show that tr(ATB) is the standard inner product of A and B treated as "long
vectors." Relate this to the Frobenius norm; i.e., prove (3.1.14).
8. Prove that \\A \\ = \\AT\\ for both the /2 and Frobenius norms. Notice that
(AB)j = ABj and see if these facts let you prove (3.1.15, 3.1.16).

Numerical Linear Algebra Background 
Chap. 3 
67
9. Prove (3.1.17).
10. Complete the proof of Theorem 3.1.4.
11. Prove for any A e R
nXn and any orthonormal set of vectors vt e Rn, i = 1, ..., n,
that
12. Prove Theorem 3.1.7.
13. Solve the block diagonal system: Ax = b,
14. Derive the Householder transformation: given v e Rn, v 
0, find u e Rn such that
(/ — UU
T) is orthogonal and (/ — UU
T)V = (a, 0, ..., 0)T, a 
0. [Hint: u must have
the form 0(y, v2, ..., vn)r, , y e R.]
15. Apply Householder transformations to factor A into QR,
16. 15(2 3) positive definite? Use the Cholesky factorization to find out.
17. Find the Cholesky factorization of
What if the 10 is changed to a 7?
18. Prove that if A = Q • R, then
Also prove that K2(A) = K2(R).
19. Calculate the l1 condition number of
Then estimate its condition number by Algorithm A.3.3.1.
20. Program the upper triangular condition estimator as a module for later use.
21. The simple form 
R( 
) we gave for Jacobi rotations is subject to unnecessary

68 
Chap. 3 
Numerical Linear Algebra Background
finite-precision inaccuracies from a or 
being small, or large, or of differing mag-
nitudes. Write an accurate procedure to evaluate R(a, ).
22. Write a Jacobi rotation that would introduce a zero into the (3, 1) position of
23. Prove Theorem 3.6.1: Show that if AT(Ax* - b) = 0, then for all x e Rn,
\\Ax — b\\2> II/1.x* — b\\2, with strict inequality if A has full column rank and
x 
. Show also that if A has full column rank, then ATA is nonsingular.
24. Given the QR decomposition of a rectangular matrix A with full column rank (as
defined in Theorem 3.6.2), show that the first n columns of Q form an orthonormal
basis for the space spanned by the columns of A.
25. Fit a line x1 + x2 Mo the data (ti, yi) = (- 1, 3), (0, 2), (1, 0), (2, 4). Do the problem
using QR and the normal equations. [Hint: Did you do Exercise 15?]
26. Given n > m > 0, be Rm, A e (R
mxn with full row rank, show how to solve the
problem
using the decomposition A = LQ, L e Rmxn lower triangular, Q e Rnxn orthog-
onal. [Hint: Use techniques similar to those used in the proofs of Theorems 3.6.2
and 3.6.5.]
27. Show how to carry out the LQ decomposition in the last exercise using House-
holder transformations.
28. Given the singular value decomposition A = UDVT of a nonsingular A e Rnxn,
prove that K2(A) = 
n. If u - and v j are the columns of U and V, respectively,
show also that a change b = u, to the right-hand side of a linear system Ax = b
will produce a change Ax = ( 
to the answer.

4
Multivariable Calculus Background
This chapter presents the material from multivariable calculus prerequisite to
our study of the numerical solution of nonlinear problems. In Section 4.1 we
discuss derivatives, line integrals, Taylor series, and related properties we will
use to derive and analyze our methods. Section 4.2 introduces the formulas for
constructing finite-difference approximations to derivatives of multivariable
functions, and Section 4.3 presents the necessary and sufficient conditions
characterizing an unconstrained minimizer. Ortega and Rheinboldt (1970) is a
detailed reference for this material and for the theoretical treatment of nonlin-
ear algebraic problems in general.
4.1 DERIVATIVES AND MULTIVARIABLE
MODELS
In our study of function minimization in one variable, we made use of first-
and second-order derivatives in order to build a local quadratic model of the
function to be minimized. In this way we managed to have our model problem
match the real problem in value, slope, and curvature at the point currently
held to be the best estimate of the minimizer. Taylor series with remainder was
a useful analytic device for bounding the approximation error in the quadratic
model, and it will be equally useful here.
We begin this section with a no-frills exposition of Taylor series up to
order two for a real-valued function of a real vector variable. Then, in order to
69

70 
Chap. 4 
Multivariable Calculus Background
set the stage for a consideration of nonlinear simultaneous equations, we
consider the problem of providing a local affine model for a function
F: Rn —> Rm. In this case, the Taylor series approach is quite unsatisfactory
because the mean value theorem fails. It was in anticipation of this fact that we
used Newton's theorem in Chapter 2 to derive our affine models. The second
part of this section will be devoted to building the machinery to make the
same analysis in multiple dimensions.
Consider first a continuous function f: Rn —»R, n > 1. If the first partial
derivatives offwith respect to the n variables exist and are continuous, the
column vector of these n partials is called the gradient offat x, V/(x), and it
functions like the first derivative of a one-variable function. In particular, there
is a corresponding mean value theorem that says that the difference of the
function values at two points is equal to the inner product of the difference
between the points and the gradient of some point on the line connecting
them. Similarly, if the n2 second partial derivatives of / also exist and are
continuous, the matrix containing them is- called the Hessian off at x, V2/(x),
and it too satisfies a mean value theorem in the form of a Taylor series with
remainder. The exact definitions and lemmas are given below. The reason that
these important results from single-variable calculus hold for functions of
multiple variables is because they involve the value of a real-valued function at
two points in Rn, x and x + p, and the line connecting these points can be
parameterized using one variable. Thus the results follow directly from the
corresponding theorems in one-variable calculus.
We will denote the open and closed line segment connecting x, x e Rn,
by (x, x) and [x, x], respectively, and we remind the reader that D Rn is
called a convex set, if for every x, x e D, [x, x] 
D.
Definition 4.1.1. A continuous function /: Rn —»R is said to be con-
tinuously differentiable at x e Rn, if ( 
) exists and is continuous,
i = 1, ..., n; the gradient offat x is then defined as
The function / is said to be continuously differentiable in an open region
D 
Rn, denoted/e Cl(D), if it is continuously differentiable at every point in
D.
LEMMA 4.1.2 Letf: Rn —> R be continuously differentiable in an open
convex set D 
Rn. Then, for x e D and any nonzero perturbation
p e Rn, the directional derivative off at x in the direction of p, defined by

Multivariable Calculus Background 
Chap. 4 
71
exists and equals f(x)Tp. For any x, x + p e D,
and there exists z e (x, x + p) such that
Proof. 
We simply parametrizefalong the line through x and (x + p) as
the function of one variable
and appeal to the calculus of one variable. Define x(t) = x + tp. Then by
the chain rule, for 0 < a < 1,
Substituting a = 0 reduces (4.1.4) to
By the fundamental theorem of calculus or Newton's theorem,
which, by the definition of g and (4.1.4), is equivalent to
and proves (4.1.2). Finally, by the mean value theorem for functions of
one variable,
which by the definition of g and (4.1.4), is equivalent to
and proves (4.1.3).

72 
Chap. 4 Multivariable Calculus Background
EXAMPLE 
4.1.3 Let /: R2 —> R, f(x) = x - 2x1 + 3x1x , -I- 4x , xc =
(1, 1)T, p = (-2, 1)T Then
f(xc) = 6, f(xc + p) = 23, f(xc) = (3, 18)T In the notation of Lemma 4.1.2,
g(t) =f(xc + t p ) = f ( l -2t, 
1 + 0 = 6 + 12f + 7t2 - 2t3, and the reader can
verify that (4.1.3) is true for z = xc + tp with t = (1 - 
.44.
Definition 4.1.4 
A continuously differentiable function 
: R n—»R is
said to be twice continuously differentiable at x e Rn, if ( 
) exists and
is continuous, 1 < i , _ / ' < « ; the Hessian offat x is then defined as the n x n
matrix whose i,j element is
The function/is said to be twice continuously differentiable in an open region
D Rn denotedfe C2(D), if it is twice continuously differentiable at every
point in D.
LEMMA 4.1.5 L e t f : R n—>R be twice continuously differentiable in
an open convex set D 
Rn. Then for any x e D and any nonzero pertur-
bation p e Rn, the second directional derivative offat x in the direction
of p, defined by
exists and equals p 
. For any x, x + p e D, there exists
2 e (x, x + p) such that
Proof. 
The proof is analogous to the proof of Lemma 4.1.2.
The Hessian is always symmetric as long as / is twice continuously
differentiable. This is the reason we were interested in symmetric matrices in
our chapter on linear algebra.
EXAMPLE 4.1.6 Letf xc, and p be given by Example 4.1.3. Then

Multivariable Calculus Background Chap. 4 
73
The reader can verify that (4.1.6) is true for z = xc + tp, t — .
Lemma 4.1.5 suggests that we might model the functionfaround a point
xc by the quadratic model
and this is precisely what we will do. In fact, it shows that the error in this
model is given by
for some z e (xc, xc + p). In Corollary 4.1.14 we will give an alternative error
bound.
Now let us proceed to the less simple case of F: Rn —»Rm, where m = n
in the nonlinear simultaneous equations problem and m > n in the nonlinear
least-squares problem. It will be convenient to have the special notation ef for
the ith row of the identity matrix. There should be no confusion with the
natural log base. Since the value of the ith component function of F can be
written fi (x) = 
F(x), consistency with the product rule makes it necessary
that fi (x) = 
F'(x), the ith row of F'(x). Thus F'(x) must be an m x n matrix
whose ith row is 
(x)T. The following definition makes this official.
Definition 4.1.7. A continuous function F: Rn—>• Rm is continuously
differentiable at x e Rn if each component functionf, i = 1, ..., m is continu-
ously differentiable at x. The derivative of F at x is sometimes called the
Jacobian (matrix) of F at x, and its transpose is sometimes called the gradient
of F at x. The common notations are:
F is said to be continuously differentiable in an open set D 
Rn, denoted
F € Cl(D), if F is continuously differentiable at every point in D.
EXAMPLE 4.1.8 Let
Then
For the remainder of this book we will denote the Jacobian matrix of F
at x by J(x). Also, we will often speak of the Jacobian of F rather than the
Jacobian matrix of F at x. The only possible confusion might be that the latter
term is sometimes used for the determinant of J(x). However, no confusion
should arise here, since we will find little use for determinants.

74 
Chap. 4 Multivariable Calculus Background
Now comes the big difference from real-valued functions: there is no
mean value theorem for continuously differentiable vector-valued functions.
That is, in general there may not exist z e Rn such that F(x + p) =
F(x) + J(z)p. Intuitively the reason is that, although each functionfi satisfies
fi(x + p) =fi(x) + 
(zi)rp, the points z, may differ. For example, consider the
function of Example 4.1.8. There is no z e Rn for which F(l, 1) =
F(0, 0) + J(z) l, l)r, as this would require
or ezi = e — 1 and 2z1 = 1, which is clearly impossible.
Although the standard mean value theorem is impossible, we will be able
to replace it in our analysis by Newton's theorem and the triangle inequality
for line integrals. Those results are given below. The integral of a vector-
valued function of a real variable can be interpreted as the vector of Riemann
integrals of each component function.
LEMMA 4.1.9 Let F: R n—»R m be continuously differentiable in an
open convex set D 
Rn. For any x, x + p e D,
Proof. 
The proof comes right from Definition 4.1.7 and a component-
by-component application of Newton's formula (4.1.2).
Notice that (4.1.8) looks like a mean value theorem if we think of it as
where the integral of the matrix-valued function is now interpreted compo-
nentwise. We will occasionally find this form useful. To use (4.1.8) in our
analysis, we need to be able to bound the integral in terms of the integrand.
The next lemma is just what we need.
LEMMA 4.1.10 
Let G : D 
Rn 
-» Rmxn, where D is an open convex set
with x, x + p € D. For any norm on Rmxn, if G is integrable on [x, x + p],

Multivariable Calculus Background 
Chap. 4 
75
Proof. 
The proof is an exercise but it comes from writing the integral
as a vector Riemann sum and then applying the triangle inequality
(3.1.1c). Then a limiting argument can be applied.
Lemma 4.1.9 suggests that we model F(xc + p) by the affine model
and this is what we will do. To produce a bound on the difference between
F(xc + p) and Mc(xc + p), we need to make an assumption about the conti-
nuity of J(x) just as we did in Section 2.4. Then we derive a bound analogous
to the one given in Lemma 2.4.2 for functions of one variable.
Definition 4.1.11. Let m, n > 0, G: Rn —- Rmxn, x e Rn, let || • || be a
norm on Rn, and ||| • ||| a norm on Rmxn. G is said to be Lipschitz continuous at
x if there exists an open set D 
Rn, x e D, and a constant y such that for all
v e D,
The constant y is called a Lipschitz constant for G at x. For any specific D
containing x for which (4.1.11) holds, G is said to be Lipschitz continuous at x
in the neighborhood D. If (4.1.11) holds for every x 6 D, then G e Lipy(D).
Note that the value of y depends on the norms in (4.1.11), but the
existence of y does not.
LEMMA 4.1.12 Let F: Rn — Rm be continuously differentiate in the
open convex set D 
Rn, x e D, and let J be Lipschitz continuous at x in
the neighborhood D, using a vector norm and the induced matrix oper-
ator norm and the constant y. Then, for any x + p E D,
Proof. 
By Lemma 4.1.9,
Using (4.1.9), the definition of a matrix operator norm, and the Lipschitz

76 
Chap. 4 Multivariable Calculus Background
continuity of J at x in neighborhood D, we obtain
EXAMPLE 4.1.13 Let F : R2 —» R2, f1(x) =
[The system of equations F(x) = 0 expresses the solution to x1 +ix2 =
Then
and the reader can easily verify that, for any x, v e R2 and using the l1 norm,
J(x) obeys (4.1.11) with y = 2.
Using Lipschitz continuity, we can also obtain a useful bound on the
error in the quadratic model (4.1.7) as an approximation tof(xc + p). This is
given below. The proof is similar to that of Lemma 4.1.12 and is left as an
exercise.
LEMMA 4.1.14. Letf: Rn —»R be twice continuously differentiable in
an open convex set D 
Rn, and let 
2 (x) be Lipschitz continuous at x
in the neighborhood D, using a vector norm and the induced matrix
operator norm and the constant y. Then, for any x + p e D,
We conclude this section with two inequalities, related to (4.1.12), that we
will use to bound ||F(v) — F(v)|| in our convergence proofs. The proof of
Lemma 4.1.15, which generalizes Lemma 4.1.12, is left as an exercise.

Multivariable Calculus Background Chap. 4 
77
LEMMA 4.1.15 Let F, J satisfy the conditions of Lemma 4.1.12. Then,
for any v, u e D,
LEMMA 4.1.16 Let F, J satisfy the conditions of Lemma 4.1.12, and
assume that J(x) -l exists. Then there exists e > 0, 0 < a < , such that
for all v,ueD for which max
Proof. 
Using the triangle inequality and (4.1.14),
which proves the second part of (4.1.15) with 
= \\J(x)\\ + ye. Similarly,
Thus if e < (1/|| J(x)-1 ||y), the first part of (4.1.15) holds with
4.2 MULTIVARIABLE 
FINITE-DIFFERENCE
DERIVATIVES
In the preceding section we saw that the Jacobian, gradient, and Hessian will
be useful quantities in forming models of multivariable nonlinear functions. In
many applications, however, these derivatives are not analytically available. In
this section we introduce the formulas used to approximate these derivatives

78 
Chap. 4 Multivariable Calculus Background
by finite differences, and the error bounds associated with these formulas. The
choice of finite-difference stepsize in the presence of finite-precision arithmetic
and the use of finite-difference derivatives in our algorithms are discussed in
Sections 5.4 and 5.6.
Recall that, for a function / of a single variable, the finite-difference
approximation to/'(x) was given by
where h is a small quantity. From the error bound on the affine model of
f(x + h) we had \a —f'(x)! = O(h) for h sufficiently small. In the case when
F: Rn —» Rm, it is reasonable to use the same idea to approximate the (i, j)th
component of J(x) by the forward difference 
approximation
where e, denotes the y'th unit vector. This is equivalent to approximating the
;th column of J(x) by
Again, one would expect \\Aj — (J(x))j\\ = 0(h) for h sufficiently small, and
this is verified in Lemma 4.2.1.
LEMMA 4.2.1 
Let F: Rn —> Rm satisfy the conditions of Lemma 4.1.12,
using a vector norm || • || for which ||ej-,\\ = 1,; = 1, ..., n. Let A e Rnxm,
with A j; defined by (4.2.1),; = 1,...,«. Then
If the norm being used is the l1 norm, then
Proof. 
Substituting p = hej into (4.1.12) gives
Dividing both sides by h gives (4.2.2). Since the l1 norm of a matrix
is the maximum of the lv norms of its columns, (4.2.3) follows
immediately.

Multivariable Calculus Background Chap. 4 
79
It should be mentioned that, although (4.2.3) assumes that one stepsize h
is used in constructing all of A, finite-precision arithmetic will cause us to use a
different stepsize for each column of A. Notice also that finite-difference
approximation of the Jacobian requires n additional evaluations of the func-
tion F, so it can be relatively expensive if evaluation of F is expensive or n is
large.
When the nonlinear problem is minimization of a functionf: Rn —» R,
we may need to approximate the gradient V/(x) and/or the Hessian 
2f(x).
Approximation of the gradient is just a special case of the approximation of
J(x) discussed above, with m = 1. In some cases, finite-precision arithmetic
causes us to seek a more accurate finite-difference approximation using the
central difference approximation given in Lemma 4.2.2. Notice that this ap-
proximation requires twice as many evaluations offas forward differences.
LEMMA 4.2.2 Let f: Rn —- R satisfy the conditions of Lemma 4.1.14
using a vector norm with the property that ||e,-|| = 1, i=1,...,«.
Assume x + he,;, x — he,• e D, i = 1, ..., n. Let a e Rn, a,- given by
Then
If the norm being used is the / norm, then
Proof. 
Define the real quantities a and 
by
Applications of (4.1.13) with p = ±hef yield
and from the triangle inequality,
so (4.2.5) follows from a - ft = 2h(ai - 
f(x),). The definition of the /
norm and (4.2.5) imply (4.2.6).

80 
Chap. 4 
Multivariable Calculus Background
On some occasions f is analytically available but 
2f is not. In this
case, 
2f can be approximated by applying formula (4.2.1) to the function
F = f followed by A -— (A + AT), since the approximation to 
2fshould be
symmetric. We know from Lemma 4.2.1 that || A — 
2f(x)|| = 0(h) for h suf-
ficiently small and it is easy to show that \\A- 
2f(x) ||F < || A - 
2f(x) ||f (see
Exercise 12). Thus || A - 
2f(x)|| = O(h).
If V/ is not available, it is possible to approximate 
2f using only values
off(x). This is described in Lemma 4.2.3. Once again the error is 0(h) for h
sufficiently small. Notice, however, that (n2 + 3n)/2 additional evaluations of/
are required.
LEMMA 4.2.3 Let / satisfy the conditions of Lemma 4.2.2. Assume x,
x + hej, x + he}, x + het + he, e D, 1 < i,j < n. Let A e R"xn, Au given
by
Then
If the matrix norm being used is the /1, / , or Frobenius norm, then
Proof. 
The proof is very similar to that of Lemma 4.2.2. To prove
(4.2.8), first substitute p = hei + hei p = het, and p = hej into (4.1.13).
Call the expressions inside the absolute-value signs, on the three re-
sulting left-hand sides, a, 
, and n, respectively. Then a — — n —
(Aij - 
2f(x)ij)h2. 
Using | a - 0 - » n < | a | + | | + n and dividing by
h2 yields (4.2.8). Then (4.2.9) follows immediately from (3.1.8a), (3.1.8c),
and the definition of the Frobenius norm.
4.3 NECESSARY AND SUFFICIENT
CONDITIONS FOR UNCONSTRAINED
MINIMIZATION
In this section we derive the first- and second-order necessary and sufficient
conditions for a point x* to be a local minimizer of a continuously differen-
tiable function/: Rn —»R, n > 1. Naturally, these conditions will be a key to
our algorithms for the unconstrained minimization problem. They are closely
related to the following conditions given in Chapter 2 for the one-variable

Multivariable Calculus Background 
Chap. 4 
81
problem. In one dimension, it is necessary thatf(x *) = 0 for x,,, to be a local
minimizer off; it is sufficient that, in addition,f"(x*) > 0, and it is necessary
that /"(x* > 0. In multiple dimensions, f(x*) = 0 is required for x* to be a
local minimizer; a sufficient condition is that, in addition,
 
2f(x *) is positive
definite, and it is necessary that
 
2 f ( x * ) at least be positive semidefinite.
The proof and interpretation of these conditions is virtually the same as
for one-variable functions. The gradient being zero says simply that there is no
direction from x* in which /(x) necessarily decreases, or increases, initially.
Thus a point with zero gradient can be a minimizer or maximizer off, or a
saddle point, which is a maximizer in some cross section of the variable space
and a minimizer in another (and corresponds to the seat of a saddle in two
variables). Positive definitiveness of
 
2f(x *) corresponds to the geometric con-
cept of strict local convexity, and just means that / curves up from x* in all
directions.
LEMMA 4.3.1 
Letf: Rn —» R be continuously differentiable in an open
convex set D 
Rn. Then x e D can be a local minimizer of / only if
V/(x) = 0.
Proof. 
As in the one-variable case, a proof by contradiction is better
than a direct proof, because the lemma and proof taken together tell how
to recognize a possible minimizer and how to improve the current candi-
date if it can't be a minimizer.
If y/(x) 
0, then choose any p e Rn for which pT 
/(x) < 0. There
certainly is such a p, since p = — V/(x) would do. To keep the notation
simple, scale p by a positive constant so that x -I- p e D. Since D is open
and convex, this cart be done and x + tp e D for every 0 < t < 1.
Now by the continuity of V/on D, there is some t e [0, 1] such
that V/(x -I- tp)Tp < 0 for every t e [0, t]. Now we apply Newton's
theorem (Lemma 4.1.2) to give
and so
A class of algorithms called descent methods are characterized by their
being based on the previous proof. If V/(xc) 
0, they choose a descent direc-
tion p as above, and then a point x + by descending in the direction p as above.
THEOREM 4.3.2 
Letf: Rn -—» R be twice continuously differentiable in
the open convex set D = Rn, and assume there exists x e D such that

82 
Chap. 4 Multivariable Calculus Background
V/(x) = 0. If 
2/(x) is positive definite, then x is a local minimizer of/. If
2f(x) is Lipschitz continuous at x, then x can be a local minimizer off
only if 
2f(x) is positive semidefinite.
Proof. 
If 
2f(x) is positive definite, then by the continuity of 
2f there
exists an open convex subset of D containing x, such that 
2f(z) is
positive definite for all z in that subset. To keep it simple, let us rename
that set D. Then for any p e Rn for which x + p E D, by Lemma 4.1.5, for
some z e [x, x + p],
which proves that x is a local minimizer off. The necessity for V2/(x) to
be positive semidefinite is left to an exercise.
The proof of the following corollary is an easy exercise. We include it
because it is a clean statement of that part of Theorem 4.3.2 most relevant to
the conditions for Newton's method to find a local minimizer by finding a zero
of 
f
COROLLARY 4.3.3 
Letf: Rn —> R be twice continuously differentiable
in the open convex set D c= Rn. If x* e D and f(x,) = 0 and if 2f is
Lipschitz continuous at x* with 
2f(x*) nonsingular, then x* is a local
minimizer of/if, and only if, 
2f(x* is positive definite.
The necessary and sufficient conditions for x* to be a local maximizer of
/are simply the conditions for x* to be a local minimizer of —f: f(x^) = 0 is
necessary, and in addition,
 
2f(x *.) negative semidefinite is necessary; 
2f(x*)
negative definite is sufficient. If 
2f(x*) is indefinite, x* cannot be a local
minimizer or maximizer.
The sufficient conditions for minimization partially explain our interest
in symmetric and positive definite matrices in Chapter 3. They become more
important because our minimization algorithms commonly modelfat pertur-
bations p of xc by a quadratic function
and a slight modification of the proof of Theorem 4.3.2 shows that mc has a
unique minimizer if, and only if, H is positive definite. Thus we will often use
symmetric and positive definite matrices H in our models. It is important to
understand the shapes of multivariable quadratic functions: they are strictly
convex or convex, respectively bowl- or trough-shaped in two dimensions, if H

Multivariable Calculus Background Chap. 4 
83
is positive definite or positive semidefinite; they are strictly concave or concave
(turn the bowl or trough upside down) if H is negative definite or negative
semidefinite; and they are saddle-shaped (in n dimensions) if H is indefinite.
4.4 EXERCISES
1. Calculate the Jacobian of the following system of three equations in three un-
knowns:
2. Let/: R2 —> R, f(x) = 
+ x2/x,. Find V/(x) and 
2f(x).
3. Prove Lemma 4.1.5.
4. An alternate definition of the Jacobian of F: Rn —> Rn at x e Rn is the linear
operator J(x), if it exists, for which
Prove that if each component of F is continuously differentiable in an open set D
containing x, and J is defined in Definition 4.1.5, then J(x) = J(x). Note: The
existence of J(x) in (4.5.1) is the definition of Gateaux differentiability of F at x; a
stronger condition on F is Frechet differentiability (at x), which requires J(x) e
Rm x" to satisfy
[For further information, see Ortega and Rheinboldt (1970).]
5. Let
Prove that/(x) is Lipschitz continuous but not differentiable at x = 0.
6. Prove Lemma 4.1.14. [Hint: You will need a double-integral extension of Newton's
theorem.]
7. Prove Lemma 4.1.15 (the techniques are very similar to those used to prove
Lemma 4.1.12).
8. If equation (4.1.11) in the definition of Lipschitz continuity is replaced by

84 
Chap. 4 
Multivariable Calculus Background
for some a e (0, 1], then G is said to be Holder continuous at x. Show that if the
assumption of Lipschitz continuity in Lemma 4.1.12 is replaced with Holder conti-
nuity, then the lemma remains true if (4.1.12) is changed to
9. Given F: R2 —- R2,
calculate J(x) at x = (1, l)T. Then use formula (4.2.1) to calculate (by hand or hand
calculator) a finite-difference approximation to J(x) at x = (1, l)T, with h = 0.01.
Comment on the accuracy of the approximation.
10. Extend the central difference formula for V/(x) to find a central difference approxi-
mation to V2/(x)n that uses only function values and has asymptotic accuracy
0(h2). (This approximation is used in discretizing some partial differential equa-
tions.) You may assume that the third derivative of/(x) is Lipschitz continuous.
11. Extend your techniques from Exercise 10 to find an approximation to
, that uses only function values and has asymptotic accuracy
O(h2). How does the cost of this approximation in function evaluations com-
pare to (4.2.7)?
12. Let A, M e RnXB, M symmetric, and let A = (A + AT)/2. Prove that ||M - A\\F <
\\M-A\\F.
13. Complete the proof of Theorem 4.3.2.
14. Prove Corollary 4.3.3.
15. Prove that a quadratic function of n variables,/(x) = 
TAx + bTx + c, A e Rnxn
symmetric, b e Rn, c e R, has a unique minimizer if, and only if, A is positive
definite. What is the minimizer? How would you find it? Recall that
V/(x) = Ax + b, 
2f(x) = A.
16. Use the necessary and sufficient conditions for unconstrained minimization to
prove that the solution(s) to the linear least-squares problem
is (are) x* e Rn satisfying (ATA)x* — ATb. [Hint: For the case when A doesn't have
full column rank, generalize Exercise 15 to consider positive semidefinite matrices.]

Another program note
Chapters 5 through 9 contain the heart of this book, the development
of algorithms for the multivariable nonlinear equations and un-
constrained minimization problems. In Chapter 5 we derive and dis-
cuss multidimensional Newton's method, the quickly convergent
local method that will be the basic model for our algorithms. Chapter
6 presents the leading techniques that are used along with Newton's
method to assure the global convergence of nonlinear algorithms.
Chapter 7 discusses the practical considerations of stopping, scaling,
and testing necessary to complete the development of good com-
puter software. Chapters 8 and 9 discuss the multidimensional secant
methods that will be used in place of Newton's method when deriva-
tives are unavailable and function evaluation is expensive.
It will turn out that the structure of the hybrid algorithm for
multivariable problems is basically the same as was given for one-
variable problems in Chapter 2. This similarity continues at a more
detailed level in the definition and analysis of the local step, except
that finite-difference derivatives become more expensive and secant
approximations far less obvious. However, the most significant differ-
ence is in the diversity and increased complexity of the global stra-
tegies for multivariable problems.
85

Newton's Method
for Nonlinear Equations
and Unconstrained Minimization
This chapter begins our consideration of multivariable problems by discussing
local algorithms for systems of nonlinear equations and unconstrained mini-
mization. We start by deriving Newton's method for systems of nonlinear
equations and discussing its computer implementation and its good and bad
features.
In Sections 5.2 and 5.3 we use two different and important approaches to
show that Newton's method is locally q-quadratically convergent for most
problems, although it will not necessarily achieve global convergence. Section
5.4 discusses the finite-difference version of Newton's method for nonlinear
equations, including the selection of finite-difference stepsizes in practice. We
conclude the chapter by discussing the version of Newton's method for multi-
dimensional unconstrained minimization problems, (Section 5.5) and the use of
finite-difference derivatives for these problems (Section 5.6).
5.1 NEWTON'S METHOD FOR
SYSTEMS OF NONLINEAR
EQUATIONS
The most basic problem studied here is the solution of a system of nonlinear
equations:
86
5

Nonlinear Equations and Unconstrained Optimization Chap. 5 
87
where F is assumed to be continuously differentiable. In this section we derive
Newton's method for problem (5.1.1) and discuss its requirements, implemen-
tation, and local and global convergence characteristics. These factors moti-
vate the work in the remainder of this book, which modifies and builds around
Newton's method to create globally robust and locally fast algorithms. Once
again we ignore the questions of the existence or uniqueness of solutions to
(5.1.1), and assume that in practice this will not usually be a problem.
Newton's method for problem (5.1.1) again is derived by rinding the root
of an affine approximation to F at the current iterate xc. This approximation
is created using the same techniques as for the one-variable problem. Since we
approximate the integral in (5.1.2) by the linear term J(x c)- p to get the affme
approximation to F at perturbations p of xc,
(Mc again stands for current model.) Next we solve for the step SN that makes
Mc(xc + sN) = 0, giving the Newton iteration for (5.1.1). Solve
An equivalent way to view this procedure is that we are finding a simultaneous zero
of the affine models of the n component functions of F given by
Since x+ is not expected to equal x^, but only to be a better estimate
than xc, we make the Newton iteration (5.1.4) into an algorithm by applying it
iteratively from a starting guess x0.
ALGORITHM 5.1.1 
NEWTON'S METHOD FOR SYSTEMS OF NONLINEAR
EQUATIONS
Given F: R" R" continuously differentiable and x0 
R": at each
iteration k, solve
For example, let

88 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
which has roots at (3, 0)T and (0, 3)T, and let x0 = (1, 5)T. Then the first two
iterations of Newton's method are
Newton's method seems to be working well here; x2 is already quite
close to the root (0, 3)T. This is the main advantage of Newton's method: if x0
is close enough to a solution x,,, and J(x+) is nonsingular, it is shown in Section
5.2 that the xk's generated by Algorithm 5.1.1 converge g-quadratically tox^.
Newton's method will also work well on nearly linear problems, since it finds
the zero of a (nonsingular) affine function in one iteration. Notice also that if
any component functions of F are affine, each iterate generated by Newton's
method will be a solution of these equations, since the affine models it uses will
always be exact for these functions. For instance, /t is affine in the above
example, and
3 f
1 ( x 1 ) = f 1 ( x 2 ) ( = f 1 ( x 3 ) . . . ) = 0 .
On the other hand, Newton's method naturally will be no better at
converging from bad starting guesses for multivariable nonlinear problems
than it was for one-variable problems. For example, if
for which
and
then
which isn't a very good step! Therefore the convergence characteristics of
Newton's method indicate how to use it in multidimensional algorithms: we
will always want to use it in at least the final iterations of any nonlinear
algorithm to take advantage of its fast local convergence, but it will have to be
modified in order to converge globally.
There are also two fundamental problems in implementing the iteration
in Algorithm 5.1.1. First, the Jacobian of F may not be analytically available.
This occurs commonly in real applications—for example, when F itself is not
given in analytic form. Thus, approximating J(xk) by finite differences or by a

Nonlinear Equations and Unconstrained Optimization Chap. 5 
89
less expensive method is a very important problem; it is the subject of Section
5.4 and Chapter 8. Second, J(xk) may be singular or ill-conditioned, so that the
linear system J(xk)sk = — F(xk) cannot be reliably solved for the step sk. As we
saw in Section 3.3, our matrix factorization methods can be used to detect
ill-conditioning reasonably well, and so a possible modification to Algorithm
5.1.1 is to perturb J(xk) just enough to make it well-conditioned and proceed
with the iteration. However, such a modification of J(xk) has no good justi-
fication in terms of the underlying problem (5.1.1), and so we don't recommend
it. Instead, when J(xk) is badly conditioned, we prefer to proceed directly to a
global method for nonlinear equations (Section 6.5) that corrresponds to per-
turbing the linear model (5.1.3) in a way meaningful to the nonlinear equations
problem.
The advantages and disadvantages of Newton's method discussed above are
the key to the development of our multidimensional algorithms, since they
point out the properties we will wish to retain and the areas where improve-
ment or modification may be necessary. They are summarized in Table 5.1.2.
Table 5.1.2 
Advantages and disadvantages of Newton's method for
systems of nonlinear equations
Advantages
1. Q-quadraticaliy convergent from good starting guesses if
J(x^) is nonsingular.
2. Exact solution in one iteration for an affine F (exact at each
iteration for any affine component functions of F).
Disadvantages
1. Not globally convergent for many problems.
2. Requires J(xk) at each iteration.
3. Each iteration requires the solution of a system of linear equations
that may be singular or ill-conditioned.
5.2 LOCAL CONVERGENCE
OF NEWTON'S METHOD
In this section we prove the local g-quadratic convergence of Newton's
method for systems of nonlinear equations and discuss its implications. The
techniques of the proof are similar to those in the one-variable case; they also
form the prototype for most of the convergence proofs in this book. Given a
vector norm || • ||, we define N(x, r) as the open neighborhood of radius r
around x—i.e., N(x, r) — { 
R": || 
— x || < r}.

90 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
THEOREM 5.2.1 
Let F: Rn —> Rn be continuously differentiable in an
open convex set D 
Rn. Assume that there exists x* Rn and r , 
> 0,
such that N ( x * , ) 
D, F(x*) = 0, J(x*)
-1 exists with \\J(x*)-1 \\
and J 
Lipy ( N ( x * ) ) . Then there exists e > 0 such that for all x0 €
N(x,., e) the sequence xx, x 2,... generated by
xk+1 = xk - 
J(xk)-1F(x4) 
k 
= 0, 1, ...
is well defined, converges to x,,,, and obeys
Proof. 
We choose e so that J(x) is nonsingular for any x e N(x+, E), and
then show that, since the local error in the affine model used to produce
each iterate of Newton's method is at most 0( xk — x *
2 ) , the conver-
gence is ^-quadratic. Let
We show by induction on k that at each step (5.2.1) holds, and also that
and so
We first show that J(x0) is nonsingular. From ||x0 — x*|| 
the
Lipschitz continuity of J at x,,,, and (5.2.2), it follows that
Thus by the perturbation relation (3.1.20), J(x0) is nonsingular and
Therefore xl is well defined and

Nonlinear Equations and Unconstrained Optimization 
Chap. 5 
91
Notice that the term in brackets is just the difference between F(x J and
the affme model Mc(x) evaluated at x*. Therefore, using Lemma 4.1.12
and (5.2.4),
This proves (5.2.1). Since
which shows (5.2.3) and completes the case k = 0. The proof of the
induction step proceeds identically.
The constants y and 
can be combined into one constant yRel = y • /?, a
Lipschitz constant measuring the relative nonlinearity of F at x,,,, since
for x e N(xi)s, r). Therefore Theorem 5.2.1 can also be viewed as saying that
the radius of convergence of Newton's method is inversely proportional to the
relative nonlinearity of F at x^. The relative nonlinearity of a function is the
key factor determining its behavior in our algorithms, and all our convergence
theorems could easily be restated and proven in terms of this concept. We
have chosen to use absolute nonlinearity only because it is standard and
therefore perhaps less confusing.
The reader might wonder whether the bounds on the region of conver-
gence of Newton's method given by Theorem 5.2.1 are tight in practice. This
question is studied in the exercises, where it is illustrated that the bound e in
Theorem 5.2.1 is a worst-case estimate in that it shows reasonably well how far
the region of quadratic convergence extends in the direction from x^ in which
F is most nonlinear. On the other hand, in directions from x,,, in which F is
less nonlinear, the region of convergence of Newton's method may be much
greater. This is just another price we pay for using norms in our analysis.
Ortega and Rheinboldt (1970, p. 428) give an excellent history of the
convergence analysis for Newton's method, including the Kantorovich analy-
sis, which is introduced in the next section.

92 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
5.3 THE KANTOROVICH
AND CONTRACTIVE MAPPING
THEOREMS
In this section we state a second convergence result for Newton's method, a
different and powerful result introduced by L. Kantorovich (1948). We also
show that its assumptions and method of proof are related to a classical result
on the convergence of iterative algorithms called the contractive mapping
theorem. While we will not directly apply either of these results in the remain-
der of this book, they are two beautiful and powerful theorems that a person
studying nonlinear problems should be aware of.
The Kantorovich theorem differs from Theorem 5.2.1 mainly in that it
makes no assumption about the existence of a solution to F(x *) = 0. Rather, it
shows that if J(x0) is nonsingular, J is Lipschitz continuous in a region con-
taining x0, and the first step of Newton's method is sufficiently small relative
to the nonlinearity of F, then there must be a root in this region, and fur-
thermore it is unique. The price paid for these broader assumptions is the
exhibition of only an r-quadratic rate of convergence. The reader will see as
the book proceeds that a separate proof is required to get the best rate-of-
convergence results for many methods.
THEOREM 5.3.1 
KANTOROVICH
Let r > 0, x0 
Rn, F: 
Rn 
Rn, and assume that F is continuously
differentiable in in N(x0, r). Assume for a vector norm and the induced
operator norm that J 
Lipy (N(x 0, r)) with J (X 0) nonsingular, and that there
exist constants 
such that
Define
and
then the sequence {xk} produced by
is well defined and converges to x*„, a unique zero of F in the closure of N (X o,r O) .
If a < i, then x* is the unique zero of F in N(X0,, r1), where r\ = min [r, (1 +
and
The proof of Theorem 5.3.1 is quite long and is sketched in Exercises 6
through 8. The basic idea behind it is simple and very clever. Plot the iterates
x0, .X|, ... in n-space, and stretch a rope through them in order. Mark the spot

Nonlinear Equations and Unconstrained Optimization Chap. 5 
93
on the rope where it meets each xk, and then pull it taut with perhaps a little
stretching. What one has produced is a linear segment of successive upper
bounds on the distances || xk+l — xk ||, k = 0, 1, — The proof of the Kantoro-
vich theorem basically shows that for any sequence {xk} generated under the
assumptions of Theorem 5.3.1, these distances are respectively less than or
equal to the distances t k + 1 — tk\ produced by applying Newton's method to
the function
starting at f0 = 0 (which is seen to exactly obey the assumptions of Theorem
5.3.1). Since the sequence [tk] converges monotonically to the smaller root
of/(t), the total length of the x-rope past xk must be
less than or equal to \tk — t x \ . Thus {xk} is a Cauchy sequence, and so it
converges to some x* with the errors || xk — x* || bounded by the q-
quadratically convergent sequence \tk — t*+ \. This technique of proof is called
majorization and does not use the finite dimensionality of IR". The sequence
{tk} is said to majorize the sequence {xk}. For further development of the
proof, see the exercises or, e.g., Dennis (1971).
The nice thing about the Kantorovich theorem is that it doesn't assume
the existence of x* or the nonsingularity of ./(x*); indeed, there are functions F
and points x0 that meet the assumptions of Theorem 5.3.1 even though J(x *) is
singular. The unfortunate part is that the r-order convergence says nothing
about the improvement at each iteration, and the error bounds given by the
theorem are often much too loose in practice. This is not important, since
Dennis(1971)shows 
Also, it is traditional
to think of testing the assumptions of Theorem 5.3.1 to see whether Newton's method
will converge from some XQ for a particular function F, but in practice it is virtually
always more work to estimate the Lipschitz constant y accurately than to just try
Newton's method and see whether it converges, so this is not a practical application
except for special cases.
The form of the Kantorovich theorem is very similar to the form of the
contractive mapping theorem. This other classical theorem considers any iter-
ative method of the form xk+l = G(xk) and states conditions on G under which
the sequence {xk} will converge q-linearly to a point x* from any point x0 in a
region D. Furthermore, x,,, is shown to be the unique point in D such that
G(x*) = x*. Thus the contractive mapping theorem is a broader but weaker
result than the Kantorovich theorem.
THEOREM 5.3.2 
CONTRACTIVE MAPPING THEOREM
Let G. D 
D, D a closed subset of R". If for some norm || • ||, there
exists a e [0, 1) such that

94 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
then:
(a) there exists a unique x* D such that G(x*) = x*;
(b) for any x0 e D, the sequence {xk} generated by xk + 1 = G(xk),
k = 0, 1, ..., remains in D and converges ^-linearly to x^ with
constant a;
(c) for any
An iteration function G that satisfies (5.3.2) is said to be contractive in the
region D. Contractivity implies that starting from any point x0 
D, the step
lengths || xk +1 — xk || decrease by at least a factor a at each iteration, since
From (5.3.3) it is straightforward to show that {xk} is majorized by a g-linearly
convergent sequence, and the proof of Theorem 5.3.2 follows as an exercise.
Thus the proofs of the Kantorovich theorem and the contractive mapping
theorem are closely related.
The contractive mapping theorem can be applied to problem (5.1.1) by
defining an iteration function G(x) such that G(x) = x if and only if F(x) = 0.
An example is
The theorem can then be used to test whether there is any region D such that
the points generated by (5.3.4) from an x0 e D will converge to a root of F.
However, the contractive mapping theorem can be used to show only linear
convergence, and so it is generally inadequate for the methods we consider in
this book.
5.4 FINITE-DIFFERENCE DERIVATIVE
METHODS FOR SYSTEMS
OF NONLINEAR EQUATIONS
In this section we discuss the effect on Newton's method of replacing the
analytic Jacobian J(x) with the finite-difference approximation developed in
Section 4.2. It is easy to show that if the finite-difference step size is chosen
properly, then the q-quadratic convergence of Newton's method is retained.
We also discuss the choice of the stepsize in practice, taking into consider-
ation the effects of finite-precision arithmetic. An example illustrates that for
most problems, Newton's method using analytic derivatives and Newton's
method using properly chosen finite differences are virtually indistinguishable.

Nonlinear Equations and Unconstrained Optimization Chap. 5 
95
THEOREM 5.4.1 
Let F and x* obey the assumptions of Theorem 5.2.1,
where || • || denotes the l1 vector norm and the corresponding induced
matrix norm. Then there exist , h > 0 such that if {hk} is a real sequence
with 
and x0 
N ( x * , ), the sequence xt, x2, ... generated
by
is well defined and converges q-linearly to x*. If
then the convergence is g-superlinear. If there exists some constant ct
such that
or equivalently a constant c2 such that
then the convergence is ^-quadratic.
Proof. 
The proof is similar to that of Theorem 5.2.1 combined with that
of Theorem 2.6.3 (finite-difference Newton's method in one dimension).
We will choose e and h so that Ak is nonsingular for any xk 
N(x+, )
and 
Let 
and
( 
are defined in Theorem 5.2.1.) We first show by induction on k
that at each step
For k = 0, we first show that A 
is nonsingular. From the tri-
angle inequality, Lemma 4.2.1, the Lipschitz continuity of J at x^,
and (5.4.4), we see that
We now proceed as in the proof of Theorem 5.2.1. By the perturbation

96 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
relation (3.1.20), (5.4.6) implies that A0 is nonsingular and
Therefore Xj is well defined and
Notice that this formula differs from the corresponding one in the analy-
sis of Newton's method only in that A0-1 has replaced J(x 0)-1 and 
tne
term (J(x0) - A0)(x+ - x0) has been added. Now using Lemma 4.1.12,
Lemma 4.2.1, (5.4.7), 
and (5.4.4), we see that
which proves (5.4.5). The proof of the induction step is identical.
The proof of q-superlinear or q-quadratic convergence requires the
improved bound on || Ak — J(xk)|| and is left as an exercise. To show the
equivalence of (5.4.2) and (5.4.3), one simply uses Lemma 4.1.16.
As in the one-variable case, Theorem 5.4.1 doesn't indicate exactly how
finite-difference stepsizes should be chosen in practice. This is because there
are again two conflicting sources of error in computing finite-difference deriva-
tives. Consider the finite-difference equation (5.4.1) and for convenience let us
omit the iteration subscripts k. From Lemma 4.2.1, the error in A.j as an approxi-
mation to (J(x)).j is O(yh) in exact arithmetic, which suggests choosing h as small
as possible. However, another error in (5.4.1), caused by evaluating the numerator
in finite-precision arithmetic, is made worse by small values of h. Since we divide
the numerator by h to get (5.4.1), any error 
in the numerator results in an error
in (5.4.1) of /h. This error in the numerator, which results from inaccuracies in
the function values and cancellation errors in subtracting them, is reasonably as-
sumed to be some small fraction of F(x). In fact if h is too small, x + hej may
be so close to x that F(x + hej) 
F(x) and A.j may have zero, or very few,
good digits. Thus h must be chosen to balance the O(yh) and O(F(x)/h) errors
in (5.4.1).

Nonlinear Equations and Unconstrained Optimization 
Chap. 5 
97
A reasonable aim is that if F(x) has t reliable digits, then F(x + hCj)
should differ from F(x) in the latter half of these digits. More precisely, if the
relative error in computing F(x) is r\ (rj stands for relative noise), then we
would like
In the absence of any better information, a reasonable way to accomplish
(5.4.8) is to perturb each component x,- by its own stepsize
which constitutes a relative change of 
in x,, and then compute Aj by
For convenience, we have assumed to this point that we use one stepsize h for
the entire finite-difference approximation, but there is no reason to do this in
practice, and a uniform stepsize could be disastrous if the components of x
differed widely in magnitude (see Exercise 12). Theorem 5.4.1 is easily revised
to remain true when individual component stepsizes /i7 are used.
In cases when F(x) is given by a simple formula, it is reasonable that
n 
macheps, so that the stepsize hj is 
macheps • x,. Example 5.4.2 compares
the finite-difference Newton's method, using (5.4.9) with n macheps, to
Newton's method, using analytic derivatives, starting from the same point. The
reader will see that the results, including derivatives, are virtually indis-
tinguishable, and this is usually the case in practice. For this reason, some
software packages do not even allow for the provision of analytic derivatives;
instead they always use finite differences. While we do not advocate this ex-
treme, it should be stressed that perhaps the leading cause of error in using
software for any nonlinear problem is incorrect coding of derivatives. Thus, if
analytic derivatives are provided, we strongly recommend that they be
checked for agreement with a finite-difference approximation at the initial
point x0.
If F(x) is calculated by either a lengthy piece of code or an iterative
procedure, r\ may be much larger than macheps. If n is so large that the
finite-difference derivatives (5.4.9) are expected to be inaccurate, then a secant
approximation to J(x) should probably be used instead (see Chapter 8). This is
also the case if the cost of n additional evaluations of F(x) per iteration for
computing A is prohibitive.
An algorithm for calculating finite-difference Jacobians is given in Algo-
rithm A5.4.1 in Appendix A. Because equation (5.4.9a) may give an inappro-

98 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
EXAMPLE 5.4.2
Computations on a computer with 48 base-2 digits ( = 14.4 base-10 digits):
priately small value of hj if x, wanders close to zero, it is modified slightly to
where typx, is a typical size of x, provided by the user (see Section 7.1).
Finally, we will indicate briefly how stepsize (5.4.10) can be justified
somewhat by analysis. It is reasonable to assume that x, is an exact computer

Nonlinear Equations and Unconstrained Optimization Chap. 5 
99
number. To simplify the analysis, we assume that x, + hj is an exact computer
number with x, + xj x,. This is the case if hj is calculated by any stepsize
rule that guarantees \hj\ > macheps xj, and then the calculation
temp = Xj + hj,
hj = temp — Xj,
is performed before hj is used in (5.4.9b). This trick improves the accuracy of
any finite-difference approximation, so we use it in practice. Now it is easy to
see that the error from round-off and function noise in calculating A.j by
(5.4.9b) is bounded by
where F is an upper bound on ||F(x)|| for x 
[x, x + h j ] . [We omit the
negligible error from the division in (5.4.9b).] Also from Theorem 4.2.1, the
difference in exact arithmetic between Aj and J(x)j is bounded by
where y, is a Lipschitz constant for which
for all t 
[0, hj]. The hj that minimizes the sum of (5.4.11) and (5.4.12) is
Under the somewhat reasonable assumption (see Exercise 14) that
(5.4.13) reduces to (5.4.10), modulo a constant. Note finally that this analysis
can be modified to allow also for an absolute error in the computed value of
F(x).
5.5 NEWTON'S METHOD FOR
UNCONSTRAINED MINIMIZATION
We now discuss Newton's method for
where / is assumed twice continuously differentiable. Just as in Chapter 2, we

100 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
model f at the current point xc by the quadratic
and solve for the point x + = xc + SN, where 
mc(x + ) = 0, a necessary con-
dition for x+ to be the minimizer of mc. This corresponds to the following
algorithm.
ALGORITHM 5.5.1 
NEWTON'S METHOD FOR UNCONSTRAINED
MINIMIZATION
Given/: 
Rn 
R 
twice continuously differentiable, x0 
Rn; at each
iteration /c,
solve
EXAMPLE 5.5.2 Let /(X1, x2) = (x1 - 2)4 + (x1 - 2)2x , + (x2 + I)2, which
has its minimum at x,,, = (2, — \)T. Algorithm 5.5.1, started from x0 = (1, l)T,
produces the following sequence of points (to eight figures on a CDC machine
in single precision):
F(XK)
X
X
X
X
X
X
X
0
1
2
3
4
5
6
= (1
= 0.
= (1
= 0.
= (1
= 0.
= 0.
.0
.0
.3913043
.7459441
.9862783
.9987342
.9999996
, 1 . 0 
) T
, -0.5 
)T
, - 0.695652 17)T
, -0.94879809)T
, - 1.048208 1)T
, -1.0001700)T
, - 1.000001 6)T
6.0
1.5
4.09 x 10
6.49 x 10
2.53 x 10
1.63 x 10
2.75 x 10
- 1
-2
-3
-6
-12
Algorithm 5.5.1 is simply the application of Newton's method (Algorithm
5.1.1) to the system V/(x) = 0 of n nonlinear equations in n unknowns, because
it steps at each iteration to the zero of the affine model of V/ defined by
Mk(xk +. p) = V[mK(xk + p)] = f(xK) + f(xk)p. From this perspective, some
of the algorithm's advantages and disadvantages for the minimization problem
(5.5.1) are clearly those given in Table 5.1.2. On the good side, if x0 is suf-
ficiently close to a local minimizer x* of / with 
nonsingular (and
therefore positive definite by Corollary 4.3.3), then the sequence {xk} generated
by Algorithm 5.5.1 will converge q-quadratically to x*, as is evident in Exam-
ple 5.5.2. Also, if f is a strictly convex quadratic, then 
is affine and so xl will
be the unique minimizer of f.

Nonlinear Equations and Unconstrained Optimization 
Chap. 5 
101
On the bad side, Algorithm 5.5.1 shares the disadvantages of Newton's
method for solving F(x) = 0, and it has one new problem as well. The old
difficulties are that the method isn't globally convergent, requires the solutions
of systems of linear equations, and requires analytic derivatives, in this case V/
and 
These issues are discussed subsequently: finite-difference approxi-
mation of derivatives for minimization in Section 5.6, global methods in
Chapter 6, and secant approximations of the Hessian in Chapter 9.
We must also consider that even as a local method, Newton's method is
not specifically geared to the minimization problem; there is nothing in Algo-
rithm 5.5.1 that makes it any less likely to proceed toward a maximizer or
saddle point of f, where 
is also zero. From the modeling point of view, the
difficulty with Algorithm 5.5.1 is that each step simply goes to the critical
point of the current local quadratic model, whether the critical point is a
minimizer, maximizer, or saddle point of the model. This is only consistent
with trying to minimize f(x) if 
is positive definite so that the critical
point is a minimizer. Even though Newton's method is intended primarily as a
local method to be used when xc is close enough to a minimizer that 
is
positive definite, we would still like to make some useful adaptation when
is not positive definite.
There seem to be two reasonable modifications to Newton's method
when 
is not positive definite. The first is to try to use the shape of
the model, in particular the "directions of negative curvature" p for which
to decrease f(x) rapidly. A lot of effort has gone into such
strategies [see, e.g., More and Sorensen (1979)], but they have not yet proven
themselves. We recommend the second alternative, which is to change the
model when necessary so that it has a unique minimizer and to use this
minimizer to define the Newton step. Specifically, we will see in Chapter 6 that
there 
are 
several 
good 
reasons 
for 
taking 
steps 
of 
the 
form
where 
and 
I is positive definite.
Therefore, when 
is not positive definite, we recommend changing the
model Hessian to 
where 
is not much larger, ideally, than
the smallest 
that will make 
positive definite and reasonably
well conditioned. Our algorithm for doing this is discussed at the end of this
section. It is a modification of the modified Cholesky factorization given in
Gill, Murray, and Wright (1981, p. 111). The result is the following modified
version of Newton's method:
ALGORITHM 5.5.3 
MODIFIED NEWTON'S METHOD FOR
UNCONSTRAINED MINIMIZATION
Given/: 
Rn 
R twice continuously differentiable, x0 
Rn, at each iter-
ation k:
Apply Algorithm A5.5.1 to 
to find the Cholesky decompo-

102 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
sition of
where
is safely positive
definite, and
is sufficiently large that Hk is safely
positive definite otherwise:
Solve
If x0 is sufficiently close to a minimizer x* of/and if 
is positive
definite and reasonably well conditioned, then Algorithm 5.5.3 will be equival-
ent to Algorithm 5.5.1 and hence g-quadratically convergent. A reexamination
of the proof of Lemma 4.3.1 will show that Algorithm 5.5.3 has the additional
advantage that the modified Newton direction 
is one in which
any twice-differentiable/(x) initially decreases from any xc.
Algorithm 5.5.3 also has two important interpretations in terms of qua-
dratic models of/(xf). The first is that it setsx+ equal to the minimizer xc + p
of the approximation
We will see in Section 6.4 that x+ is also the minimizer of the unmodified
model,
subject to a constraint
which is perhaps a more appealing explanation. Both interpretations can be
used to explain the main problem with the modified Newton algorithm: it can
produce overly large steps sf in some situations. We will deal quite satisfac-
torily with this problem in Chapter 6. The length of the step can be adjusted
by tinkering with the parameters in Algorithm A5.5.1, but any such adjust-
ment is too dependent on the scale of the problem to be included in a general-
purpose algorithm.
We conclude this section with a brief description of our algorithm (A5.5.1
in the appendix) for determining both 
such that
is positive definite and well conditioned, and the Cholesky factorization of Hc.
Although this algorithm is central to our minimization software, it is not
crucial that the reader study it in detail.
Clearly the smallest possible 
(when 
is not positive definite) is
slightly larger than the magnitude of the most negative eigenvalue of
Although this can be computed without too much trouble, we have decided to

Nonlinear Equations and Unconstrained Optimization Chap. 5 
103
provide a much simpler algorithm that may result in a larger 
We first
apply the Gill and Murray modified Cholesky factorization algorithm to
which results in 
a diagonal matrix with nonne-
gative diagonal elements that are zero if 
is safely positive definite. If
D = 0, 
= 0 and we are done. If D 
0, we calculate an upper bound bl on
using the Gerschgorin circle theorem (Theorem 3.5.9). Since
is also an upper bound on 
we set 
= min {b1 b2} and conclude the
algorithm by calculating the Cholesky factorization of Hc = V2/(xc) + nc I.
5.6 FINITE-DIFFERENCE DERIVATIVE
METHODS FOR UNCONSTRAINED
MINIMIZATION
In this section we consider the effect on Newton's method for unconstrained
minimization of substituting finite-difference approximations for the analytic
derivatives V/(x) and V2/(x), and also the practical choice of stepsize in
computing these approximations. We will see that there are several important
differences in theory and in practice from the use of finite-difference Jacobians
studied in Section 5.4.
We first discuss the use of a finite-difference approximation to the Hess-
ian. In Section 4.2 we saw two ways to approximate V2/(xc) by finite differ-
ences, one when V/(x) is analytically available and the other when it isn't. Both
approximations satisfy
(hc the finite-difference stepsize) under the standard assumptions and so, using
the same techniques as in the proof of Theorem 5.4.1, it is easy to show that if
hc = 0(\\ec\\\ where ec = xc — x* then Newton's method using finite-
difference Hessians is still g-quadratically convergent. The issue that remains is
the choice of the finite-difference stepsize in practice.
If 
is analytically available, Ac is calculated by
Since (5.6.la) is the same formula as for finite-difference Jacobians, the same
stepsize

104 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
is recommended, where 
macheps is the estimated relative error in calculat-
ing V/(x). Algorithm A5.6.1 is used for this approximation. Recall that we
expected to get about the first half of the digits of 
correct if V/(x) is
calculated accurately; see Example 5.6.1 below.
When V/(x) is not available analytically, recall that Ac is calculated by
Example 5.6.1 shows that the stepsize (5.6.2) can be disastrous in this formula.
EXAMPLE 5.6.1 Let/^, x2) be given by Example 5.5.2 and let xf = (1, 1)T.
Then
i— 
—'
If 
V2/(x`
) 
is approximated by equation (5.6.1) using stepsize hj = 10-7xj on a
CDC computer with 48 base-2 digits ( 14.4 base-10 digits), the result is
However if 
is approximated by equation (5.6.3) using the same stepsize,
the result is
If the stepsize in (5.6.3) is changed to hj = 10-4xJ the result is
The incorrect results of the second portion of Example 5.6.1 are
easy to explain. If, as in the example, 
macheps Xi and hj = 
macheps
Xj, then the denominator of (5.6.3) equals (macheps • x.Xj). Since the numerator
of (5.6.3) will probably be calculated with a finite-precision error of at
least macheps • | f(xc) |, 
(Ac)ij will have a finite-precision error of at least
which need not be small in comparison to 
We have
often seen equation (5.6.3) produce entirely incorrect results when used with
stepsize (5.6.2); zero is a fairly common result in our experience. [If we use
hj = 10 8Xj in our example, we get
is approximated

Nonlinear Equations and Unconstrained Optimization 
Chap. 5 
105
The same reasoning and analysis as in Section 5.4 indicate that one
should choose instead the finite-difference stepsize in equation (5.6.3) to per-
turb the right-hand two-thirds of the good digits of(xc). This can usually be
done by choosing
or simply hj = (macheps)1/3xj in many cases, where 
macheps is again the
relative error in calculating f(x). This stepsize works quite well in practice, as
shown in the last portion of Example 5.6.1, where we use hj — 10-4xj and get
at least four good digits of each component of 
Algorithm A5.6.2 in
Appendix A is our algorithm for computing finite-difference Hessians from
function values, using equation (5.6.3) with stepsize (5.6.4). Notice that it can
only reasonably be expected to get the first third of the digits of 
correct,
with even fewer digits correct i f ( x ) is a noisy function.
In summary, when the analytic Hessian is not readily available, approxi-
mating it by either finite-difference Algorithm A5.6.1 using analytic values of
V/(x) or Algorithm A5.6.2 using only function values will usually not change
the behavior of Newton's method, although Algorithm A5.6.1 is definitely
preferred if V/(x) is analytically available. If/(x) is quite noisy, Algorithm
A5.6.2 may be unsatisfactory and a secant approximation to V2/(x) should
probably be used instead (see Chapter 9). A secant approximation to the
Hessian should certainly be used if the cost of the finite-difference approxi-
mation, n evaluations of V/(x) or (n2 + 3n)/2 evaluations of/(x) per iteration,
is too expensive.
We now turn to the finite-difference approximation of the gradient in
minimization algorithms. The reader can guess that this will be a stickier issue
than the approximation of the Jacobian or Hessian, because the gradient is the
quantity we are trying to make zero in our minimization algorithm. Therefore,
a finite-difference approximation to the gradient will have to be particularly
accurate.
Recall that we have two formulas for approximating V/(xc) by finite
differences: the forward difference formula
which is just a special case of Jacobian approximation and has error 0(hj) in
the^'th component, and the central difference formula
which has error 0(h*). Remember also that in the case of finite-difference
Jacobians or Hessians, we have seen that if the stepsizes obey hj = 0(\\ec\\),
where ec = xc — x^, then under standard assumptions the g-quadratic conver-

106 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
gence of Newton's method is retained. However, this cannot possibly be the
case for the forward difference gradient approximation (5.6.5), because as xc
approaches a minimizer of/(x), ||V/(xc)|| ^ O(\\ec ||) and so a stepsize of
0(|| ec ||) in (5.6.5) would result in an approximation error 
of the
same order of magnitude as the quantity being approximated. Instead, the
analysis of Theorem 5.4.1 can be expanded easily to show that if the Newton
iteration for minimization is amended to
where gc and Ac approximate 
and 
respectively, then, under the
analogous assumptions,
(see Exercise 17). Therefore, q-quadratic convergence requires
which means 
using forward differences or
using central differences. Furthermore, it is hard to estimate 
since
isn't analytically available.
In practice this analysis doesn't really apply, since we will just try to
select hj to minimize the combined effects of the errors due to the nonlinearity
of f and to finite precision. For the forward difference formula (5.6.5) this just
means using the same stepsize (5.6.2) as for a Jacobian approximation. For
the central difference formula (5.6.6), the same analysis as in Section 5.4 shows
that 
is optimal, and we suggest the same stepsize (5.6.4) as is used
in approximating the Hessian with function values. In our experience, forward
difference approximation of the gradient is usually quite sufficient, and since
central differences are twice as expensive, the algorithm we recommend for
gradient approximation is Algorithm A5.6.3, the Jacobian Algorithm A5.4.1
with m (the number of equations) = 1. One should realize, however, that the
accuracy in the solution x^ will be limited by the accuracy in the gradient
approximation. For this reason, and to cover the unusual case when forward
differences are too inaccurate, a central difference gradient routine is provided
in Algorithm A5.6.4 in the appendix. Some production codes decide automati-
cally whether and when to switch from forward difference to central difference
gradient approximation. [See, e.g., Stewart (1967).]
In conclusion, a user should be aware of the possible difficulties in using
finite-difference gradients in minimization algorithms. Boggs and Dennis
(1976) analyze the error inherent in using such algorithms to find approximate
minimizers. Although their bounds are too pessimistic in practice, users are
encouraged strongly to supply an analytic gradient whenever possible. A user
who obtains bad results with forward difference gradients or requires increased
accuracy might want to try central differences instead. Owing to the accuracy
needed in the gradient approximation, we will see that there is no useful secant
approximation to the gradient in minimization algorithms.

Nonlinear Equations and Unconstrained Optimization Chap. 5 
107
5.7 EXERCISES
1. The system of equations
has a solution x+ = (1, l)r. Carry out one iteration of Newton's method from
-x0 = (2, 0)r
2. Carry out the second iteration of Newton's method on the system
starting from x0 = (—10, — 10)T. (The first iteration is done in Section 5.1.) What
will happen if Newton's method is continued on this problem, using finite-precision
arithmetic?
Exercises 3 and 4 are meant to give insight into the region of convergence given by the
convergence theorems for Newton's method.
3. For each of the functions f(x) = x, f(x) = x2 + x , f ( x ) = e* — 1, answer the follow-
ing questions:
(a) What is f(.x) at the root x* = 0?
(b) What is a Lipschitz constant for f'(x) in the interval [ — a, a]; i.e., what is a
bound on | (f(x) -/'(0))/x | in this interval?
(c) What region of convergence of Newton's method on /(x) is predicted by Theo-
rem 2.4.3?
(d) In what interval [b, c], b < 0 < c, is Newton's method on f(x) actually conver-
gent to x* = 0?
4. Using your answers to Exercise 3, consider applying Newton's method to
(a) What is J(x) at the root x# = (0, 0,0)T?
(b) What is a Lipschitz constant on J(x) in an interval of radius a around x* ?
(c) What region of convergence for Newton's method on F(x) is predicted by
Theorem 5.2.1?
(d) What would the region of convergence be if (x0)3 = 0? If (x0)2 = (x0)3 = 0?
5. Show that if the assumption J 
Lipy(N(x*, r)) in Theorem 5.2.1 is replaced by the
Holder continuity assumption of Exercise 4.8, then Theorem 5.2.1 remains true if
(5.2.1) is changed to
Hint: Change (5.2.2) to £ = min
which implies that
Exercises 6 through 8 develop the proof of the Kantorovich theorem.

108 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
6. Prove that the conditions and conclusions of the Kantorovich theorem are satisfied
for the quadratic
[Hint: Prove (5.3.1) by proving the stronger inequality
To prove this, show inductively that
and, using this, that
7. Let F: 
Rn 
Rn, x0 
R", satisfy the assumptions of the Kantorovich theorem and
let f (t), t0 be defined as in Exercise 6. Let {xk}, {tk} be the sequences generated by
applying Newton's method to F(x) and/(f) from x0 and f0, respectively. Prove by
induction that
k = 0, 1, — [Hint: At the induction step, use (3.1.20) to help prove the first rela-
tion. To prove the second, first use the equation
to show that
Similarly, show that
Then use these two equations and the first induction relation to prove the second.]
8. Use Exercises 6 and 7 to prove the Kantorovich theorem.
9. Read and enjoy Bryan (1968) for a beautiful application of the Kantorovich theory.
10. Prove the contractive mapping theorem by showing that, under the assumptions of
Theorem 5.3.2:
(a) for any j > 0,
[Hint: use equations (5.3.3).]

Nonlinear Equations and Unconstrained Optimization Chap. 5 
109
(b) using (a), that the sequence {x,} has a limit x*, because {x,} is a Cauchy
sequence, and that G(x*) = x*.
(c) using (b) and equation (5.3.3), that x* is the unique fixed point of G in D and
that the q-linear convergence and error bounds given by Theorem 5.3.2 hold.
(d) Use (a) to prove another version of the contractive mapping theorem without
the assumption that F(D) 
D.
11. Let f(x) = x2 — 1, a 
R, a > 1. Prove that for some d > 0 (6 dependent on a), the
sequence of points {xi} generated from any x0 
(1 — , 1 + 6) by
converges q-linearly to x* = 1, but that
12. Complete the proof of Theorem 5.4.1.
13. let F:R2 R2
. 
r . ire —> iw ,
let \k = (107, 10 - 7) T, and suppose we are using a computer with 14 base-10 digits.
What will happen if we compute an approximation to J(x *) by equation (5.4.1)
with hk = 1? with hk = 10-14? Is there any choice of hk that is good for approxi-
mating both J(xk)i, and J(xk)22 in this case?
14. Let 
or 
Letting 
) and 
, what is
the optimal step size given by (5.4.13) for f1,(x)? for f2(x)? How do these compare
with step size (5.4.10)? What special problems occur in the finite-difference ap-
proximation of f'2(x) when x is a very large positive number?
15. Let/(x,, x2) = (x] - x2)2 + {(\ - Xj)2. What is the minimizer of f(x)? Compute
one iteration of Newton's method for minimizing f(x) starting from x0 = (2, 2)T. Is
this a good step? Before you decide, compute/(x0) and/(x1).
16. Consider applying Newton's method to find a minimizer of f(x) = sin x fromx0
The desired answer is x* = — /2. Let £ be a small positive number. Show
that if x0 = 
Newton's method gives 
Similarly, what happens if
but f"(x0) is modified to make it a small positive number?
17. Let /,(x) = -x1
2 — x2
2, f2(x) = x1
2 — x22. Show that Algorithm 5.5.3 will not con-
verge to the maximizer x* = (0, 0)T of f1,(x) if x0 
x*. Also show that Algorithm
5.5.3 will not converge to the saddle point x*, — (0, 0)T of f2(x) unless (x0)2 = 0.
18. On a computer of your choice, compute the finite-difference approximation to the
Hessian of/(x) given in Exercise 15 at x0 = (2, 2)T, using equation (5.6.3) with
hj•, = (macheps)1/2xj, and again with hj•, = (macheps)1/3xj;. Compare your results
with the analytic value of V2/(x0).
19. Let 
f: 
!Rn 
R obey 
Lipy D for some D = R" and assume there exists
x* 
D for which 
. Show that if 
and 
is non-
singular, then the x+ generated by x+ == xc — Ac
1 gc obeys (5.6.7).

110 
Chap. 5 Nonlinear Equations and Unconstrained Optimization
20. Show how to efficiently combine the central difference algorithm for computing
V/(jc) (Algorithm A5.6.4) and the forward difference algorithm for computing
V2/(jc) (Algorithm A5.6.2) into one routine. How does the number of function eval-
uations required compare with: (a) using the two routines separately, and (b) using for-
ward difference algorithms A5.6.3 for the gradient and A5.6.2 for the Hessian? What
disadvantages would there be in using your new routine in practice?

Globally Convergent Modifications
of Newton's Method
In the last chapter, Newton's method was shown to be locally g-quadratically
convergent. This means that when the current solution approximation is good
enough, it will be improved rapidly and with relative ease. Unfortunately, it is
not unusual to expend significant computational effort in getting close enough.
In addition, the strategies for getting close constitute the major part of the
program and the programming effort, and they can be sensitive to small
differences in implementation.
This chapter will be devoted to the two major ideas for proceeding when
the Newton step is unsatisfactory. Section 6.1 will set the framework for the
class of algorithms we want to consider, and Section 6.2 will reintroduce the
concept of a descent direction that we saw briefly in the proof of Lemma 4.3.1.
Section 6.3 discusses the first major global approach, modern versions of the
traditional idea of backtracking along the Newton direction if a full Newton
step is unsatisfactory. Section 6.4 discusses the second major approach, based
on estimating the region in which the local model, underlying Newton's
method, can be trusted to adequately represent the function, and taking a step
to approximately minimize the model in this region. Both approaches are
derived initially for the unconstrained minimization problem; their application
to solving systems of nonlinear equations is the topic of Section 6.5.
For our definition of "globally convergent," see the last paragraph of Section 1.1.
111
6

112 
Chap. 6 Globally Convergent Modifications of Newton's Method
6.1 THE QUASI-NEWTON FRAMEWORK
The basic idea in forming a successful nonlinear algorithm is to combine a
globally convergent strategy with a fast local strategy in a way that derives the
benefits of both. The framework for doing this, a slight expansion of the hybrid
algorithm discussed in Chapter 2 (Algorithm 2.5.1), is outlined in Algorithm
6.1.1 below. The most important point is to try Newton's method, or some
modification of it, first at each iteration. If it seems to be taking a reasonable
step—for example, if/decreases in a minimization application—use it. If not,
fall back on a step dictated by a global method. Such a strategy will always
end up using Newton's method close to the solution and thus retain its fast
local convergence rate. If the global method is chosen and incorporated pro-
perly, the algorithm will also be globally convergent. We will call an algorithm
that takes this approach quasi-Newton.
ALGORITHM 6.1.1 
QUASI-NEWTON 
ALGORITHM 
FOR 
NONLINEAR
EQUATIONS OR UNCONSTRAINED OPTIMIZATION [for Optimization,
replace F(xk) by V f ( x k ) and Jk by #fc]
Given F: 
Rn 
Rn 
continuously differentiable, and x0 
Rn. At each
iteration k:
1. Compute F(xk), if it is not already done, and decide whether to stop
or continue.
2. Compute Jk to be J(xk), or an approximation to it.
3. Apply a factorization technique to Jk and estimate its condition
number. If Jk is ill-conditioned, perturb it in an appropriate
manner.
4. Solve
5. Decide whether to take a Newton step, 
or to
choose x k + 1 by a global strategy. This step often furnishes F(xk) to
step 1.
At this point we have covered steps 2, 3, and 4; step 5 is the topic of this
chapter. At the end of this chapter, then, the reader could construct a complete
quasi-Newton algorithm, with the exception of the stopping criteria, which are
covered in Chapter 7. The secant updates of Chapters 8 and 9 are alternate
versions of step 2.
We remind the reader that a modular system of algorithms for nonlinear
equations and unconstrained minimization is provided in Appendix A, supply-

Globally Convergent Modifications of Newton's Method Chap. 6 
113
ing a variety of completely detailed quasi-Newton algorithms for the two
problems. Algorithm 6.1.1 is the basis of the driver for these algorithms, which
in the appendix is Algorithm D6.1.1 for minimization and Algorithm D6.1.3
for nonlinear equations. The main difference between Algorithm 6.1.1 above
and the two drivers in the appendix is that the actual drivers contain a
separate initialization section proceeding the iteration section.
The purpose, organization, and use of the modular system of algorithms
is discussed at the beginning of Appendix A. We recommend reading this
discussion now if you have not previously done so, and then referring back to
the appendix for details as the algorithms arise in the text.
6.2 DESCENT DIRECTIONS
We start our discussion of global methods by considering the unconstrained
minimization problem
because there is a natural global strategy for minimization problems; it is to
make sure that each step decreases the value of/ There are corresponding
strategies for systems of nonlinear equations, in particular, making sure each
step decreases the value of some norm of F: IR" -—»R". However, by using a
norm, one is really transforming the problem of solving the system of equa-
tions F(x) = 0 into the problem of minimizing a function, such as
Therefore, for this section and the next two we will discuss global strategies for
unconstrained minimization. In Section 6.5 we will apply these strategies to systems
of nonlinear equations, using the transformation (6.2.2).
The basic idea of a global method for unconstrained minimization is
geometrically obvious: take steps that lead "downhill" for the function/ More
precisely, one chooses a direction p from the current point xe in which /
decreases initially, and a new point x+ in this direction from xc such that
f(x+) <f(xc). Such a direction is called a descent direction. Mathematically, p
is a descent direction from xc if the directional derivative of / at xc in the
direction p is negative—that is, from Section 4.1, if
If (6.2.3) holds, then it is guaranteed that for sufficiently small positive 6,
Descent directions form the basis of some global methods
for minimization and are important to all of them, and therefore they are the
topic of this section.

114 
Chap. 6 Globally Convergent Modifications of Newton's Method
So far, the only direction we have considered for minimization is the
Newton direction SN = — Hc
-l 
where Hc is either 
or an ap-
proximation to it. Therefore, it is natural to ask whether the Newton direction
is a descent direction. By (6.2.3), it is if and only if
which is true if Hc
- l or, equivalently, Hc is positive definite. This is the second
reason why, in Algorithm 5.4.2, we coerce Hc to be positive definite if it isn't
already. It guarantees not only a quadratic model with a unique minimizer but
also that the resultant Newton direction will be a descent direction for the
actual problem. This in turn guarantees that for sufficiently small steps in the
Newton direction, the function value will be decreased. In all our methods for
unconstrained minimization, the model Hessian Hc will be formed or coerced
to make it positive definite.
A second natural question is: as long as one is taking steps in descent
directions, what is the direction p in which / decreases most rapidly from x?
The notion of direction needs to be made more explicit before we can answer
this question, since, for a given perturbation vector p, the directional derivative
of f in the direction p is directly proportional to the length of p. A reasonable
way to proceed is to choose a norm || • ||, and define the direction of any p as
When we speak of a direction p, we will assume that this normalization
has been carried out. We can now pose our question about a most rapid
descent direction for a given norm as
which, in the l2 norm, has solution 
Thus the negative
of the gradient direction is the steepest downhill direction from x in the l2
norm, and it is referred to as the steepest-descent direction.
A classic minimization algorithm due to Cauchy is based solely on the
steepest-descent direction. Its theoretical form is given below.
ALGORITHM 6.2.1 
METHOD OF STEEPEST DESCENT
Given/: 
Rn 
R continuously differentiable, x0 
Rn. At each iteration
k:
find the lowest point of f in the direction — V/(xk) from xk—i.e.,
find 
that solves
min
min 
subject to

Globally Convergent Modifications of Newton's Method Chap. 6 
115
This is not a computational method, because each step contains an exact
one-dimensional minimization problem, but it can be implemented by doing
an inexact minimization. In either case, under mild conditions it can be shown
to converge to a local minimizer or saddle point of f(x). [See, e.g., Goldstein
(1967).] However, the convergence is only linear, and sometimes very slowly
linear. Specifically, if Algorithm 6.2.1 converges to a local minimizer x* where
is positive definite, and evmax and evmin are the largest and smallest
eigenvalues of 
then one can show that {x k} satisfies
in a particular weighted 12 norm, and that the bound on c is tight for some
starting x0. If 
is nicely scaled with evmax 
evmin, then c will be very
small and convergence will be fast, but if 
is even slightly poorly
scaled—e.g., evmax = 102 evmin—then c will be almost 1 and convergence may
be very slow (see Figure 6.2.1). An example, where c = 0.8 and || xk + 1 — x* || =
c || xk — x* || at each iteration, is given in Example 6.2.2. It is any easy exercise
to generalize this example to make c arbitrarily close to 1.
EXAMPLE 6.2.2 Let 
This is a positive definite quad-
ratic with minimizer at x* = (0, 0)r and
for all x.
Thus, the c given by (6.2.4) is (9 — l)/(9 + 1) = 0.8. Also, the reader can verify
that if f(x) is a positive definite quadratic, the steepest descent step of Algo-
rithm 6.2.1 is given by
Figure 6.2.1 Method of steepest descent on a slightly poorly scaled
quadratic

116 
Chap. 6 Globally Convergent Modifications of Newton's Method
where 
Using (6.2.5), it is easy to verify that the sequence of points
generated by Algorithm 6.2.1 with the given/(x) and x0 = (9, 1)T is
Therefore,
The sequence {xk} given in (6.2.6) is drawn in Figure 6.2.1.
c in any lp norm.
Thus, the method of steepest descent should not be used as a compu-
tational algorithm in most circumstances, since a quasi-Newton algorithm will
be far more efficient. However, when our global strategy must take steps much
smaller than the Newton step, we will see in Section 6.4 that it may take steps
in, or close to, the steepest descent direction.
We note finally that the steepest descent direction is very sensitive to
changes in the scale of x, while the Newton direction is independent of such
changes. For this reason, when we seem to use the steepest descent direction in
our algorithms of Section 6.4, the corresponding implementations in the ap-
pendix will actually first premultiply it by a diagonal scaling matrix. We defer
to Section 7.1 consideration of this important practical topic called scaling.
6.3 
LINE SEARCHES
The first strategy we consider for proceeding from a solution estimate outside
the convergence region of Newton's method is the method of line searches.
This is really a very natural idea after the discussion of descent directions in
Section 6.2.
The idea of a line-search algorithm is simple: given a descent direction
pk, we take a step in that direction that yields an "acceptable" xk + 1. That is,
at iteration k:
calculate a descent direction pk,
Graphically, this means selecting xk + 1 by considering the half of a one-
dimensional cross section of /(x) in which /(x) decreases initially from xk, as
depicted in Figure 6.3.1. However, rather than setting pk to the steepest descent
direction — 
as in Algorithm 6.2.1, we will use the quasi-Newton direc-
tion — 
discussed 
in Section 5.5, where 
is posi-
tive definite with 
is safely positive definite. This will allow us
to retain fast local convergence.

Globally Convergent Modifications of Newton's Method Chap. 6 
117
Figure 6.3.1 
A cross section of/(x): Rn 
(R from xk in the direction pk
The term "line search" refers to a procedure for choosing kk in (6.3.1).
Until the mid 1960s the prevailing belief was that >lk should be chosen to solve"
the one-dimensional minimization problem accurately. More careful compu-
tational testing has led to a complete turnabout, and in this section we will
give weak acceptance criteria for {At} that lead to methods that perform as
well in theory and better in practice.
The common procedure now is to try the full quasi-Newton step first
and, if Ak = 1 fails to satisfy the criterion in use, to backtrack in a systematic
way along the direction defined by that step. Computational experience has
shown the importance of taking a full quasi-Newton step whenever possible.
Failure to do so leads to forfeiture of the advantage of Newton's method near
the solution. Therefore, it is important that our procedure for choosing At
allow Ak = 1 near the solution.
In the remainder of this section we discuss the choice of Afc in theory and
in practice. Since there is no compelling reason to confine our discussion to
line searches in the quasi-Newton direction, we consider the search forx+ =
xc + Ac p along a general descent direction p from the current solution esti-
mate xc.
While no step-acceptance rule will always be optimal, it does seem to be
common sense to require that
It comes as no great surprise that this simple condition does not gurantee that
{xk} will converge to a minimizer of/ 
We look now at two simple one-
dimensional examples that show two ways that a sequence of iterates can
satisfy (6.3.2) but fail to converge to a minimizer. These examples will guide us
to useful step-acceptance criteria.
First, let
If we choose
then
each pk is
a descent direction from xk, and/(xk) is monotonically decreasing with

118 
Chap. 6 Globally Convergent Modifications of Newton's Method
[see Figure 6.3.2(a)]. Of course this is not a minimum of any sort for /, and
furthermore {xk} has limit points + 1, so it does not converge.
Now consider the same function with the same initial estimate, and let us
takeTheneach pk is again a descent direction, f(xk) decreases monotonically, and
lim 
which again is not a minimizer of f [see Figure 6.3.2(b)].
The problem in the first case is that we achieved very small decreases in f
values relative to the lengths of the steps. We can fix this by requiring that the
average rate of decrease from/(xc) to/(x+) be at least some prescribed fraction
of the initial rate of decrease in that direction; that is, we pick an a 
(0, 1) and
choose 
from among those 
that satisfy
(see Figure 6.3.3). Equivalently, must be chosen so that
It can be verified that this precludes the first unsuccessful choice of points but
not the second.
The problem in the second example is that the steps are too small,
relative to the initial rate of decrease of f. There are various conditions that
ensure sufficiently large steps; we will present one that will also be useful to us
in Chapter 9. We will require that the rate of decrease of fin the direction p at
x+ be larger than some prescribed fraction of the rate of decrease in the
direction p at xc—that is,
Figure 63.2 
Monotonically decreasing sequences of iterates that don't
converge to the minimizer

Globally Convergent Modifications of Newton's Method Chap. 6 
119
Figure 6.3.3 Permissible values of A under condition (6.3.3) (a = 0.1)
or equivalently,
for some fixed constant 
(see Figure 6.3.4). The condition
guarantees that (6.3.3) and (6.3.4) can be satisfied simultaneously. In practice,
(6.3.4) generally is not needed because the use of a backtracking strategy
avoids excessively small steps. An alternative condition to (6.3.4) is given in
Exercise 7.
Conditions (6.3.3) and (6.3.4) are based on work of Armijo (1966) and
Goldstein (1967). Example 6.3.1 demonstrates the effect of these conditions on
a simple function. In Subsection 6.3.1 we prove powerful convergence results
for any algorithm obeying these conditions. Subsection 6.3.2 discusses a practi-
cal line-search algorithm.
Figure 6.3.4 The two line search conditions

120 
Chap. 6 Globally Convergent Modifications of Newton's Method
EXAMPLE 6.3.1 Let
and let a = 0.1 in (6.3.3), 
in (6.3.4). Since
pc is a descent direction for f(x) from xc. Now consider 
If
x + = x ( l ) = (-2,0)T,
so that x+ satisfies (6.3.4), but
so that x + doesn't satisfy (6.3.3). Similarly, the reader can verify that x + =
x(O.l) = (0.7, 0.9)T satisfies (6.3.3) but not (6.3.4), and that x+ = x(0.5) = (-0.5,
0.5).T satisfies both (6.3.3) and (6.3.4). These three points correspond to points
to the right of, to the left of, and in the "permissible" region in Figure 6.3.4,
respectively.
6.3.1 
CONVERGENCE RESULTS FOR
PROPERLY CHOSEN STEPS
Using conditions (6.3.3) and (6.3.4), we can prove some amazingly power-
ful results: that given any direction pk such that 
there exist
satisfying (6.3.3) and (6.3.4); that any method that generates a sequence
{xk} obeying 
and (6.3.4) at each iteration is
essentially globally convergent; and that close to a minimizer of fwhere V2/ is
positive definite, Newton steps satisfy (6.3.3) and (6.3.4). This means we can
readily create algorithms that are globally convergent and, by always trying
the Newton step first, are also quickly locally convergent on most functions.
Theorem 6.3.2, due to Wolfe (1969, 1971), shows that given any descent
direction pk, there exist points 
satisfying (6.3.3) and (6.3.4).
THEOREM 6.3.2 Let /: 
Rn 
R be continuously differentiable on Rn.
Let 
obey 
< 0, and assume
0} is bounded below. Then if 
there exist 
such
that 
satisfies (6.3.3) and (6.3.4) if
Proof. 
Since 
for all A > 0 suf-
ficiently small. Since 
is also bounded below, there exists some
smallest positive A such that
Thus any 
satisfies (6.3.3). By the mean value theorem, there

Globally Convergent Modifications of Newton's Method Chap. 6 
121
exists
such that
and so from (6.3.5) and (6.3.6),
since
and
By the continuity of
(6.3.7) still holds
for 
in some interval
about
Therefore, if we restrict
be in
satisfies
and
for any
Theorem 6.3.3 also is due to Wolfe (1969, 1971). It shows that if any
sequence {xk} is generated to obey 
(6.3.3), and (6.3.4),
then, unless the angle between 
and 
converges to 90° as
either the gradient converges to 0, or / is unbounded below. Of
course, both may be true. We comment below that the case where the angle
between 
) and (xk +1 — xk) approaches 90° can be prevented by the algo-
rithm.
THEOREM 6.3.3 Let /: 
Rn 
R be continuously differentiable on Rn,
and assume there exists 
such that
for every x, 
Then, given any x0 
Rn, either f is unbounded below
or there exists a sequence {xk}, k = 0, 1, ..., obeying (6.3.3), (6.3.4), and
either
or
for each k 
0, where
Furthermore, for any such sequence, either
(a)
for some )
(b) lim
(c) lim

122 
Chap. 6 Globally Convergent Modifications of Newton's Method
Proof. 
For each k, if 
then (a) holds and the sequence
is constant subsequently. If 
then there exists pk—e.g., pk =
— 
that f(xk)Tpk < 0. By Theorem 6.3.2, either/is unbound-
ed below, or there exists Ak > 0 such that 
satisfies
(6.3.3) and (6.3.4). In order to simplify notation, let us assume that
l S° 
This constitutes no loss of generality.
So far we see that either/is unbounded below, or {xk} exists, and
either {xk} satisfies (a) or else sk £ 0 for every k. We must now show that
if no term of {sk} is zero, then (b) or (c) must hold. It will be useful to
have
By (6.3.3) and 
for every k, for any j > 0,
Hence, either
is convergent.
In the first case (b) is true and we are finished, so we consider the
second. In particular, we deduce that lim 
Now we want to
conclude that lim 
and so we need to use condition (6.3.4),
since it was imposed to ensure that the steps don't get too small.
We have for each k that
and so
by (6.3.9) and 
. Applying the Cauchy-Schwarz inequality and (6.3.8)
to the left side of the last equation, and using the definition of 
gives
us
so

Globally Convergent Modifications of Newton's Method Chap. 6 
123
and
Thus
which shows that
[i.e., (c) is true] and completes the proof.
Note that while Theorem 6.3.3 applies readily to any line-search algo-
rithm, it is completely independent of the method for selecting the descent
directions or the step lengths. Therefore, this theorem gives sufficient con-
ditions for global convergence, in a weak sense, of any optimization algorithm,
including the model-trust region algorithms of Section 6.4. Furthermore, while
the Lipschitz condition (6.3.8) is assumed on all of Rn, it is used only in a
neighborhood of the solution x*. Finally, although 
in Theorem
6.3.3 does not necessarily imply 
it does as long as the angle
between 
and sk is bounded away from 90°. This can easily be achieved
in practice. For example, in a quasi-Newton line-search algorithm where pk =
and Hk is positive definite, all that is needed is that the con-
dition numbers of {Hk} are uniformly bounded above. Thus, Theorem 6.3.3
can be viewed as implying global covergence toward f = 
or 
al-
though the conditions are too weak to imply that {xk} converges.
Theorem 6.3.4, due to Dennis and More (1974), shows that our global
strategy will permit full quasi-Newton steps 
close to a
minimizer of f as long as — 
is close enough to the Newton step.
THEOREM 6.3.4 
Let/: 
Rn 
R be twice continuously differentiable in
an open convex set D, and assume that 
lip 
y(D). Consider a se-
quence {xk} generated by 
where 
for all
k and 
is chosen to satisfy (6.3.3) with an 
and (6.3.4). If {xk}
converges to a point x+ 
D at which 
is positive definite, and if
then there is an index 
such that for all 
is admis-
sible. Furthermore, 
and if 
for all 
then {xk}
converges g-superlinearly to x*.

124 
Chap. 6 Globally Convergent Modifications of Newton's Method
Proof. 
The proof is really just a generalization of the easy exercise that
if f(x) is a positive definite quadratic and 
then
and 
satisfies (6.3.3) for any 
and
(6.3.4) for any 
Some readers may wish to skim or skip it, as the
details are not too illuminating. We set
where throughout this proof, || • || means || • ||2. First we show that
By a now familiar argument, if x is near enough x,,,, then 
exists
and is positive definite, and if 
then 
Therefore, since
and 
(6.3.11) and (6.3.10) show that for k suf-
ficiently large,
Since from Theorem 6.3.3 we have
(6.3.12) implies
We now show that 
satisfies (6.3.3), for all k greater than
or equal to some k0. From the mean value theorem, for some
[xk, 
xk+pk]
or
because of (6.3.11) and the Lipschitz continuity of 
Now choose k0 so

Globally Convergent Modifications of Newton's Method Chap. 6 
125
that for 
(6.3.12) holds and
If 
satisfies (6.3.3) because from (6.3.13), (6.3.12), and
(6.3.14)
To show that (6.3.4) is satisfied by 
for 
we use the
mean value theorem again to get, for some 
that
so
by (6.3.11), the Lipschitz continuity of 
(6.3.14), and (6.3.12). This
yields 
Thus 
eventu-
ally satisfies (6.3.3,6.3.4), and so it is admissible. It is an easy consequence of
(6.3.10) and lim 
that 
This leaves only the proof of
g-superlinear convergence if 
is chosen for all but finitely many terms.
We postpone this until it follows from a much more general result in Chap-
ter 8.
Taken together, the conclusions of Theorems 6.3.3 and 6.3.4 are quite
remarkable. They say that if / is bounded below, then the sequence {xk}
generated by any algorithm that takes descent steps whose angles with the
gradients are bounded away from 90°, and that satisfy conditions (6.3.3) and
(6.3.4), will obev
Furthermore, if any such algorithm tries a Newton or quasi-Newton step first
at each iteration, then {xk} will also converge g-quadratically or q-
superlinearly to a local minimizer x,,, if any xk is sufficiently close to x*, and if
local convergence assumptions for the Newton or quasi-Newton method are
met. These results are all we will need for the global convergence of the
algorithms we discuss in the remainder of this book. (See also Exercise 25.)

126 
Globally Convergent Modification of Newton's Method
6.3.22 
STEP SELECTION
BY 
BACKTRACKING
We now specify how our line-search algorithm will choose 
As we
have stated, the modern strategy is to start with 
and then, if 
is
not acceptable, " backtrack" (reduce 
) until an acceptable 
is found.
The framework of such an algorithm is given below. Recall that condition
(6.3.4) is not implemented because the backtracking strategy avoids excessively
small steps. (See also Exercise 25.)
ALGORITHM 6.3.5 
BACKTRACKING LINE-SEARCH FRAMEWORK
Given
while
for some
(*p 
is chosen anew each time by the line search*)
In practice, a is set quite small, so that hardly more than a decrease in
function value is required. Our algorithm uses 
Now just the strategy
for reducing 
(choosing p) remains. Let us define
the one-dimensional restriction of f to the line through xk in the direction pk. If
we need to backtrack, we will use our most current information about / to
model it, and then take the value of 
that minimizes this model as our next
value of 
in Algorithm 6.3.5.
Initially, we have two pieces of information abou
After calculating/(xk + pk), we also know that
so if f (xk + pk) does not satisfy (6.3.3) [i.e.,/(l) >/(0) + af'(0)], we model/(/l)
by the one-dimensional quadratic satisfying (6.3.15) and (6.3.16),

Globally Convergent Modifications of Newton's Method Chap. 6 
127
and calculate the point
for which 
Now
since
Thus 
minimizes
Also
because 
Therefore we take A as our new value of 
in Algorithm
6.3.5 (see Figure 6.3.5). Note that since 
we have
In fact, if 
then 
Thus, (6.3.17) gives a useful implicit upper
bound of 
on the first value of p in Algorithm 6.3.5. On the other hand, if
(I) is much larger than 
can be very small. We probably do not want to
decrease 
too much based on this information, since probably it indicates
that 
is poorly modeled by a quadratic in this region, so we impose a lower
bound of 
in Algorithm 6.3.5. This means that at the first backtrack at
each iteration, if 
then we next try
EXAMPLE 
6.3.6 Let f: Rn R, and xc and p be given by Example 6.3.1.
Since f(x c) = 3 and f(xc + p) = 20, xc + p is not acceptable and a backtrack is
needed. Then
20, and (6.3.17) gives 
Now 
satisfies
condition (6.3.3) with a = 10-4, since 
Therefore 
Incidentally, the minimum of
occurs at
Figure 6.3.5 
Backtracking at the first iteration, using a quadratic model

128 
Chap. 6 Globally Convergent Modifications of Newton's Method
Now suppose 
doesn't satisfy (6.3.3). In this case we
need to backtrack again. Although we could use a quadratic model as we did
on the first backtrack, we now have four pieces of information about 
. So
at this and any subsequent backtrack during the current iteration, we use a
cubic model of 
fit 
and the last two values of 
and,
subject to the same sort of upper and lower limits as before, set 
to the value
of 
at which 
has its local minimizer (see Figure 6.3.6). The reason for
using a cubic is that it can more accurately model situations where / has
negative curvature, which are likely when (6.3.3) has failed for two positive
values of 
Furthermore, such a cubic has a unique local minimizer, as illus-
trated in Figure 6.3.6.
The calculation of proceeds as follows. Let prev and 2prev be the last
two previous values of 
Then the cubic that 
fits 
prev), and
prev) is
where
Its local minimizing point 1 is
It can be shown that if 
prev) 
then 
prev, but this reduction can
be achieved in practice and is considered too small (see Example 6.5.1). There-
fore the upper bound 
= 0.5 is imposed, which means that if 
prev, we
Figure 63.6 
Cubic backtrack—the two possibilities

Globally Convergent Modifications of Newton's Method Chap. 6 
129
set the new 
Aprev. Also, since 
can be an arbitrarily small fraction of
prev, the lower bound 
is used again (i.e., if 
prev, we set the new
prev). It can be shown that (6.3.18) is never imaginary if a in Algo-
rithm 6.3.5 is less than |.
There is one important case for which backtracking based on cubic
interpolation can be used at every step of Algorithm 6.3.5. Sometimes it is
possible to obtain 
at very little additional cost while computing
In this 
case, 
can 
be fitted to 
prev) 
prev) at
each backtrack. It is a valuable exercise for the student to work out the
resulting algorithm in detail.
Algorithm A6.3.1 in the appendix contains our backtracking line-search
procedure. It has two additional features. A minimum step length is imposed
called minstep; it is the quantity used to test for convergence in the upcoming
Algorithm A7.2.1. If condition (6.3.3) is not satisfied, but 
is smaller
than minstep, then the line search is terminated, since convergence to xk will be
detected at the end of the current iteration anyway. This criterion prevents the
line search from looping forever if pk is not a descent direction. (This some-
times occurs at the final iteration of minimization algorithms, owing to finite-
precision errors, especially if the gradient is calculated by finite differences.)
Because this condition could also indicate convergence to a false solution, a
warning message should be printed. A maximum allowable step length also is
declared by the user, because excessively long steps could occur in practice
when 
and Hk is nearly singular. The maximum step
length is imposed precisely to prevent taking steps that would result in the
algorithm's leaving the domain of interest and possibly cause an overflow in
the computation of/(I).
When we use a line search in conjunction with the secant algorithms of
Chapter 9, we will see that we also need to assume that condition (6.3:4) is
satisfied at each iteration. Algorithm A6.3.1 mod is the modification of Algo-
rithm A6.3.1 that explicitly enforces this condition. Usually it results in the
same steps as Algorithm A6.3.1.
6.4 THE MODEL-TRUST REGION
APPROACH
The last section dealt exclusively with the problem of finding an acceptable
step length in a given direction of search. The underlying assumptions were
that the direction would be the quasi-Newton direction, and that the full
quasi-Newton step would always be the first trial step. The resulting back-
tracking algorithm incorporated these assumptions to attempt global conver-
gence without sacrificing the local convergence properties of the quasi-Newton
method, clearly the goal of any global strategy. In this section we seek the

130 
Chap. 6 Globally Convergent Modifications of Newton's Method
same goal, but we drop the assumption that shortened steps must be in the
quasi-Newton direction.
Suppose that the full quasi-Newton step is unsatisfactory. This indicates
that our quadratic model does not adequately model / in a region containing
the full quasi-Newton step. In line-search algorithms we retain the same step
direction and choose a shorter step length. This new length is determined by
building a new one-dimensional quadratic or cubic model, based only on
function and gradient information in the quasi-Newton direction. While this
strategy is successful, it has the disadvantage that it makes no further use of
the n-dimensional quadratic model, including the model Hessian. In this sec-
tion, when we need to take a shorter step, we first will choose a shorter step
length, and then use the full n-dimensional quadratic model to choose the step
direction.
Before we begin to consider ways to choose such directions, it will be
useful to make a few preliminary remarks about prespecifying step length. It
seems reasonable that after the first iteration we would begin to get at least a
rough idea about the length of step we can reasonably expect to make. For
example, we might deduce from the length of the step we took at iteration k an
upper bound on the length of step likely to be successful at iteration k + 1. In
fact, in Subsection 6.4.3 we will see how to use information about/, gained as
the iteration proceeds, to better estimate the length of step likely to be suc-
cessful. Given this estimate, we might want to start our next iteration with a
step of about this length, and not waste possibly expensive function evalu-
ations on longer steps that are unlikely to be successful. Of course, this means
that in order to save function evaluations, we might not try a full quasi-
Newton step at some iteration when it might be satisfactory. In Subsection
6.4.3 we give some heuristics that are intended to minimize the chances of this
occurrence.
Now suppose that we have xc and some estimate de of the maximum
length of a successful step we are likely to be able to take from xf. This raises
the question: how can we best select a step of maximal length (5f from xc ? A
natural answer exists if we return to our idea of a quadratic model. From the
beginning we have taken the view that the quasi-Newton step sf is reasonable
because it is the step from xc to the global minimizer of the local quadratic
model mc (if the model Hessian Hc is positive definite). If we add the idea of
bounding the maximal step length by 5C > 0, then the corresponding answer to
our question is to try the step sf that solves
Problem (6.4.1) is the basis of the "model-trust region" approach to
minimization. Its solution is given in Lemma 6.4.1 below. The name comes
from viewing <5C as providing a region in which we can trust mc to adequately
model f.

Globally Convergent Modifications of Newton's Method Chap. 6 
131
In the next chapter we will see the merit of using a scaled version of the
12 norm in the step-length bound, but to do so now would only add clutter.
LEMMA 6.4.1 
Let /: R"—> R be twice continuously differentiable,
be symmetric and positive definite, and let || -|| designate the
12 norm. Then problem 6.4.1 is solved by
for the unique 
such that 
unless 
in which
case 
is the solution. For any 
defines a descent direc
tion for/from xc.
Proof. 
(6.4.2) is straightforward from the necessary and sufficient con-
ditions for constrained optimization, but we do not need this generality
elsewhere in the book. While reading the proof, the reader may want to
refer to Figure 6.4.1. It shows xc, a positive definite quadratic model mc
with minimum at XN surrounded by contours at some increasing values
of mc, and a step bound 
C.
Let us call the solution to (6.4.1) s*+, and let *„, = xc + s*+. Since the
Newton point xr + s* is the global minimizer of mc, it is clear that if
then 
Now consider the case when 
is outside
the step bound as in Figure 6.4.1. Let 
be any point interior to the
constraint region —i.e., 
Then 
so it is possible
to decrease mc from x while staying inside the constrained region by
Figure 6.4.1 
The solution to (6.4.1)

132 
Chap. 6 Globally Convergent Modifications of Newton's Method
considering points of the form x — A 
This implies that 5 cannot
be the solution to (6.4.1), so s*+ must satisfy || s* \\ = 
unless
Also, since the constrained region in problem (6.4.1) is closed and com-
pact, some s for which 
must be the solution.
Now consider some s such that 
For s to be the solution
to (6.4.1), it is necessary that if we move an arbitrarily small distance
from xc + s in any descent direction for mc, we increase the distance
from xc. A descent direction for mc from xc + s is any vector p for which
Similarly a direction 
from xc + s increases distance from xc if and only
if
What we are saying is that for s to solve (6.4.1), any p that satisfies (6.4.3)
must also satisfy (6.4.4). Since we know that 
this can
occur only if 
and — s point in the same direction, or in other
words, if for some
which is just 
Thus s* = s( ) for some 
when
Since 
and Hc is symmetric and positive definite,
is symmetric and positive definite, so s( ) is a descent direction
for / from xc. In order to finish the proof, we need to show that s* is
unique, which is implied by the stronger result that if 
then
This shows that 
has a unique solution
that must be the solution to (6.4.1). The proof is straightforward, because
if 
and
then
and so 
as long as 
Thus 
is a monotonically decreas-
ing function of
The trouble with using Lemma 6.4.1 as the basis of a step in a mini-
mization algorithm is that there is no finite method of determining the
such that 
when 
Therefore, in the next two
subsections we will describe two computational methods for approximately
solving problem (6.4.1). The first, the locally constrained optimal (or "hook")
step, finds a 
such that 
and takes x+ = xc + s( ). The second,
the dogleg step, makes a piecewise linear approximation to the curve s( ), and
takes x+ as the point on this approximation for which

Globally Convergent Modifications of Newton's Method Chap. 6 
133
There is no guarantee that the x+ that approximately or exactly solves
(6.4.1) will be an acceptable next point, although we hope it will be if 
is a
good step bound. Therefore, a complete step of a trust-region algorithm will
have the following form:
ALGORITHM 6.4.2 
A GLOBAL STEP BY THE MODEL-TRUST REGION
APPROACH
Given 
symmetric and
positive definite:
repeat
(1) sc —approximate solution to (6.4.1),
X + :— Xc + Sc ,
(2) decide whether x+ is acceptable, and calculate a new
value of
until x+ is an acceptable next point;
To complete the model-trust region algorithm, we discuss the above Step
2 in Subsection 6.4.3.
Finally, some observations are in order. First, Gay (1981) shows that
even if Hc has negative eigenvalues, the solution to (6.4.1) is still an s* satisfy-
ing 
for some 
such that 
is at least posi-
tive semidefinite. This leads to another justification for our strategy from
Section 5.5 of perturbing the model Hessian to a positive definite 
when 
is not positive definite; the resultant quasi-Newton
step — 
is to the minimizer of the original (non positive definite)
quadratic model in some spherical region around xc. For the remainder of
Section 6.4 we will assume that Hc is positive definite.
Second, it is important to note that s( ) runs smoothly from the quasi-
Newton step — 
when 
to 
when 
gets
large. Thus when 
is very small, the solution to (6.4.1) is a step of length 
in
approximately the steepest-descent direction. Figure 6.4.2 traces the curve
for the same quadratic model as in Figure 6.4.1. We note that in
general when n > 2, this curve does not lie in the subspace spanned by
and 
(see Exercise 6.10).
Fletcher (1980) calls these algorithms restricted step methods. This term
emphasizes the procedure to be covered in Subsection 6.4.3 for updating
which could also be used in line-search algorithms. Some important ground-
work for the algorithms of this section was provided by Levenberg (1944),
Marquardt (1963), and Goldfeldt, Quandt, and Trotter (1966). More recent
references are cited in the following pages.

134 
Chap. 6 Globally Convergent Modifications of Newton's Method
Figure 6.4.2 
The curve s( )
6.4.1 
THE LOCALLY CONSTRAINED
OPTIMAL ("HOOK") STEP
Our first approach for calculating the step in model-trust region Algo-
rithm 6.4.2, when 
is to find an 
such
that 
and then make a trial step to 
In this section
we discuss an algorithm for finding an approximate solution 
to the scalar
equation
In practice we will not require a very exact solution at all, but we defer that
consideration to the end of this subsection.
An application of the ideas of Chapter 2 would cause us to use Newton's
method to solve (6.4.5). Although this would work, it can be shown that for all
and 
so Newton's method will always underestimate
the exact solution ^ (see Figure 6.4.3). Therefore, we will construct a different
method geared specifically to (6.4.5).
The proper idea to bring from Chapter 2 is the device of a local model of
the problem to be solved. In this case, the one-dimensional version
suggests a local model of the form
with two free parameters a, p. Before we discuss 
notice that we have
slipped into a new notation for dealing with the iteration on 
which comes

Globally Convergent Modifications of Newton's Method Chap. 6 
135
from the model above, takes place inside the main x-iteration, and whose
purpose is to find the uc satisfying (6.4.5). We will use boldface for the current
values of the quantities ac, Bc, uc that are changing in the inner iteration on u,
and normal type for the current values of C, xc, f(xc), Hc that come from
the outer iteration and are unchanged during the solution of (6.4.5). Thus, we
obtain uc as the inner iteration's last approximation uc to u*, the exact solu-
tion of (6.4.5); and we use xc and uc to define x+ = xc + s(uc),
The model mc(u) has two free parameters, ac and Bc, and so as in the
derivation of Newton's method, it is reasonable to choose them to satisfy the
two conditions:
and
This gives
Notice that the computation of s(uc) requires a factorization of Hc + uc I, and
so it will require 0(n3) arithmetic operations. Once we have this factorization,
the computation of (Hc + ucI)-1s(uc) costs only O(n2) operations, so O'(uc) is
relatively cheap.
Figure 6.4.3 
Newton's method for finding 
(u) = 0

136 
Chap. 6 Globally Convergent Modifications of Newton's Method
Now that we have our model mc(u), we naturally choose u+ such that
mc(u+ ) — 0 — that is
The reader can verify that substituting (6.4.6), (6.4.7), and (6.4.5) into the above
gives
as our iteration for solving 
(u) = 0. The form of (6.4.8) shows that when
uc < u*, we are taking a larger correction than Newton's method would give,
but that when uc > u*, the step is smaller than the Newton step. As 
uc 
u*,
(6.4.8) becomes more and more like Newton's method; in fact, (6.4.8) is locally
g-quadratically convergent to \i+.
Several issues remain in transforming (6.4.8) into a computational algo-
rithm. The following discussion, and our algorithm, is based on Hebden (1973)
and More (1977). Another comprehensive reference is Gander (1978). Readers
not interested in implementation details may wish to skip the next three
paragraphs.
The first consideration is a starting value for ji in solving (6.4.5). Reinsch
(1971) has shown that if (6.4.8) is started with \IQ = 0, then the p iteration
converges monotonically up to n*, but we would like a closer start because
each iteration of (6.4.8) involves solving a linear system. More's implemen-
tation uses the approximate solution //_ to the last instance of (6.4.5) to
generate an initial guess for the current instance. The rule More uses is simple:
if the current step bound Sc is p times the last value of the step bound 6_ , then
jic = n _/p is used to start (6.4.8). We prefer a different strategy. Remember
where we are in the iteration: we have just made an x-steps(/*_) from x _ to
xf, and we now want x+ ; we have obtained 6C from 6. . Before we get Hc, we
still have (H _ + /^- /) in factored form, and so it costs only O(n2) to compute
and
In analogy with (6.4.8), we use
the value of \JL gotten from /z_, the previous model, and the new trust radius Sc. If
Bc = 5_, then ^ is exactly the value we would have gotten had we taken one more
^-iteration on the previous model. On the other hand, if the previous iteration took
the Newton step, then we find no by a different technique mentioned later.

Globally Convergent Modifications of Newton's Method Chap. 6 
137
Another computational detail, important to the performance of the algo-
rithm for solving (6.4.5), is the generation and updating of lower and upper
bounds u+ and l+ on u+ . These bounds are used with (6.4.8) in the same way
that bounds were used to safeguard the backtrack steps in Algorithm 6.3.5;
that is, we restrict n+ to be in [1+ , u+]. Since the Newton iteration applied to
(6.4.5) always undershoots u*, we take 10 = — <I>(0)/O'(0). We then calculate
along with each calculation of (6.4.8), and update the lower bound to 1+ =
max {lc, n+}, where lc is the current lower bound. Also, since
because Hc is positive definite and fi* > 0, we take || V/(xc)||2/ c as our initial
upper bound u0 on u*. Then, at each iteration, if O(|ic) < 0 we update the
upper bound to u+ = min (uc, uc}, where uc is the current upper bound.
If, at any iteration, ji+ is not in [l+,u+], we follow More in choosing
H+ by
the second term being a safeguard against near-zero values of 1+ . In practice,
these bounds are invoked most frequently in calculating u0. In particular,
(6.4.10) is used to define u0 whenever (6.4.9) cannot be used because the pre-
vious iteration used the Newton step.
Finally, we do not solve (6.4.5) to any great accuracy, settling instead for
The reason is that, as will be seen in Subsection 6.4.3, the trust region is never
increased or decreased by a factor smaller than 2. So if the current trust radius
is 
C, the previous one was either greater than or equal to 2 C, or less than or
equal to 6e/2. Thus we consider the actual value of 6C to be rather arbitrary
within the range [3<5f/4, 3<5c/2], which splits the difference in either direction,
and it seems reasonable to allow || s(u)||2 to have any value in this range. Some
other implementations, for example More (1977), require ||s(u)||2 e [0.9<5C,
1.1 <5C], and it is not clear whether either is better. Experience shows that either
choice is satisfied in practice with an average of between 1 and 2 values of p
per x-iteration.
We have now completed our discussion of an algorithm for approxi-
mately solving (6.4.5); a simple example is given below.

138 
Chap. 6 Globally Convergent Modifications of Newton's Method
EXAMPLE 6.4.3 Let /(xj, x2) = xf + x? + x\, xc = (1, l)r, tfc = V2/(xc),
<5C = i» /* - = 0. Then
Since || sf ||2 > f<5c, the Newton step is too long, and we seek some \i > 0 such
that
(see Figure 6.4.4). Since \i _ = 0, we calculate
Next we calculate
Figure 6.4.4 "Hook" step for Example 6.4.3

Globally Convergent Modifications of Newton's Method Chap. 6 
139
we take nc = \i0 and x + = xc 4- s(nc) = (0.666, 0.665)7 as our approximate
solution to (6.4.1). Note that in this case we have not used iteration (6.4.8). For
illustration, the reader can verify that one application of (6.4.8) would result in
and that s(u1.) = (-0.343, -0.365)r, ||s(n,)||2 = 0.5006. Incidentally, (6.4.5) is
solved exactly by u* = 3.496.
Our algorithm for computing the locally constrained optimal ("hook")
step by the techniques described in this section is given in Algorithm A6.4.2 in
the appendix. It is preceded by the driver for a complete global step using the
locally constrained optimal approach in Algorithm A6.4.1. The complete step
involves selecting a new point x+ by Algorithm A6.4.2, checking if x + is
satisfactory and updating the trust radius (Algorithm A6.4.5), and repeating
this process if necessary. All the algorithms use a diagonal scaling matrix on
the variable space that will be discussed in Section 7.1.
Some recent research [Gay (1981), Sorensen (1982)] has centered on
approximately solving the locally constrained model problem (6.4.1) by the
techniques of this section expanded to cover the case when Hc is not positive
definite. These techniques may become an important addition to the algo-
rithms of this section.
6.4.2 
THE DOUBLE DOGLEG STEP
The other implementation of the model-trust region approach that we
discuss is a modification of the trust region algorithm introduced by Powell
(1970a). It also finds an approximate solution to problem (6.4.1). However,
rather than finding a point x + = xc + s(/O on the s(u) curve such that
\\x+ — xc\\2 = Sc, it approximates this curve by a piecewise linear function
connecting the "Cauchy point" C.P., the minimizer of the quadratic model mc
in the steepest-descent direction, to the Newton direction for mc, as indicated
in Figure 6.4.5. Then it chooses x + to be the point on this polygonal arc such
that || x+ — xc||2 = 
C, unless \\H~l V/(xc)||2 < 
C, in which case x+ is the
Newton point. This strategy can alternatively be viewed as a simple strategy
for looking in the steepest-descent direction when 
C is small, and more and
more toward the quasi-Newton direction as 
C increases.
The specific way of choosing the double dogleg curve makes it have two
important properties. First, as one proceeds along the piecewise linear curve
from xc to C.P. to N to x +, the distance from xc increases monotonically.
Thus for any 8 < \\ H 
1 V/(xc)||, there is a unique point x+ on the curve such
that || x+ — xc||2 = 6. This just makes the process well defined. Second, the
value of the quadratic model mc (xr + s) decreases monotonically as s goes

140 
Chap. 6 Globally Convergent Modifications of Newton's Method
Figure 6.4.5 
The double dogleg curve, xc —> C.P. -+ N — > x +
along the curve from xc to C.P. to N to x + . This makes the process reason-
able.
Point C.P. in Figure 6.4.5 is found by solving
which has the unique solution
Therefore,
and if
the algorithm takes a step of length <5C in the steepest-descent direction:
In order for the double dogleg curve to satisfy the first property stated
above, it must be shown that the Cauchy point C.P. is no farther from xc than
the Newton point x + . Let

Globally Convergent Modifications of Newton's Method Chap. 6 
141
Then
It is an exercise to prove that y < 1 for any positive definite Hc, with y = 1
only if Sc p = SN, a case which we exclude for the remainder of this section.
Thus,
The point N on the double dogleg curve is now chosen to have the form
for some r\ such that
and
mc(x) decreases monotonically along the line from C.P. to N. 
(6.4.12)
Since we know that mc(x) decreases monotonically from xc to C.P. and from N
to x + , (6.4.12) will guarantee that mc(x) decreases monotonically along the
entire double dogleg curve.
To satisfy (6.4.12), r\ must be chosen so that the directional derivative
along the line connecting C.P. and N is negative at every point on that line
segment. Parametrize this line segment by
The directional derivative of mc along this line at x+(A) is
Since Hc is positive definite, the right-hand side of (6.4.13) is a monotonically
increasing function of L Therefore, we need only require that (6.4.13) be nega-
tive for A = 1 to make it negative for 0 < A < 1. Some cancellation and substi-

142 
Chap. 6 Globally Convergent Modifications of Newton's Method
tution shows that this condition is equivalent to
which is satisfied for any r\ e (y, 1).
Thus $ can be chosen as any point in the Newton direction xe + qsN for
which rj is between 1 and y given by (6.4.11). Powell's original choice was
r\ = 1, giving the single dogleg curve. Computational testing, however, has
shown that an earlier bias to the Newton direction seems to improve the
performance of the algorithm. Therefore, Dennis and Mei (1979) suggest the
choice rj = 0.8y + 0.2, leading to a double dogleg curve as in Figure 6.4.5.
The choices of C.P. and fl completely specify the double dogleg curve.
The selection of the x+ on the curve such that ||x+ - xc||2 = 8C is then a
straightforward inexpensive algebraic problem, as illustrated in Example 6.4.4
below. Notice that the entire algorithm costs only O(n2) arithmetic operations
after s" has been calculated.
EXAMPLE 6.4.4 Let/(x), xc, Hc be given by Example 6.4.3, and let 6C =
0.75. Recall that
Since || s" ||2 = 1.088 > 6C, the double dogleg algorithm first calculates the step
to the Cauchy point. The reader can verify that it is given by
Since || sc p ||2 ^ 0.494 < 6C, the algorithm next calculates the step to the point
N. The reader can verify that
Since \\sP\\2 = 0.813 > 6C, the double dogleg step must be along the line con-
necting C.P. and N—that is, sc = scp-+- A(s* - sc-p>) for the /I e (0, 1) for which
\\sc\\2 = <5C. A is calculated by solving for the positive root of the quadratic
equation

Globally Convergent Modifications of Newton's Method Chap. 6 143
Figure 6.4.6 The double dogleg step of Example 6.4.4
which is A s 0.867. Thus,
The entire calculation is shown in Figure 6.4.6.
Our algorithm for selecting a point by the double dogleg strategy is
given in Algorithm A6.4.4 in the appendix. Computational experience shows
that the points selected by this strategy are, at worst, marginally inferior to
those selected by the locally constrained optimal step of Algorithm A6.4.2.
However, there is a trade-off: the complexity and running time of Algorithm
A6.4.4 are considerably less than those of Algorithm A6.4.2. This makes the
dogleg strategy attractive, especially for problems where the cost of function
and derivative evaluation is not high.
Algorithm A6.4.3 contains the driver for a complete global step using the
double dogleg algorithm to find candidate points x+ . Both algorithms contain
the diagonal scaling of the variable space that is described in Section 7.1.
6.4.3 UPDATING THE TRUST REGION
To complete the global step given in Algorithm 6.4.2, one needs to decide
whether the point x+, found by using the techniques of Subsection 6.4.1 or
6.4.2, is a satisfactory next iterate. If x+ is unacceptable, one reduces the size of
the trust region and minimizes the same quadratic model on the smaller trust
region. If x + is satisfactory, one must decide whether the trust region should
be increased, decreased, or kept the same for the next step (of Algorithm 6.1.1).
The basis for these decisions is discussed below.

144 
Chap. 6 
Globally Convergent Modifications of Newton's Method
The condition for accepting x + is the one developed in Section 6.3,
where gc = V/(xc) or an approximation to it, and a is a constant in (0, ^). In
our algorithm we again choose a = 10 ~4, so that (6.4.14) is hardly more strin-
gent than f(x + ) </(xc). If x+ does not satisfy (6.4.14), we reduce the trust
region by a factor between 75 and j and return to the approximate solution of
the locally constrained minimization problem by the locally constrained opti-
mal step or double dogleg method. The reduction factor is determined by the
same quadratic backtrack strategy used to decrease the line-search parameter
in Algorithm A6.3.1. We model /(xc + A(X + — xc)) by the quadratic mq(k) that
fits /(xf), /(x + ), and the directional derivative 0c
r(x + — xc) of /at 
xc in the
direction x + — xc . We then let the new trust radius 6+ extend to the mini-
mizer of this model, which occurs at
(see Figure 6.4.7). Thus,
we instead set <5 + to the closer endpoint of this interval for the same reasons as
in the line-search algorithm. Note that ||x+ — xf ||2 = 6C if x + is selected by
the double dogleg strategy of Subsection 6.4.2, but that we only know that
II *+ — xc \\2 e [4^0 2^cl if x+ is selected by the locally constrained optimal
strategy of Subsection 6.4.1.
Now suppose we have just found an x + that satisfies (6.4.14). Ifx + is a
full Newton step from xc, then we make the step, update 6, form the new
model, and go to the next iteration. However, if x+ — xc isn't the Newton step,
we first consider whether we should try a larger step from xc, using the current
Figure 6.4.7 
Reducing the trust region when x + is unacceptable.

Globally Convergent Modifications of Newton's Method Chap. 6 
145
model. The reason this may be worthwhile is that we may thereby avoid
having to evaluate the gradient (and Hessian) at x+ , which is often the domi-
nant cost in expensive problems. The reason a longer step may be possible is
that the trust region may have become small during the course of the algo-
rithm and may now need to be increased. This occurs when we leave a region
where the step bound had to be small because the function was not well
represented by any quadratic, and enter a region where the function is more
nicely behaved.
To decide whether to attempt a larger step from xc, we compare the
actual reduction A/ = /(x + ) —f(xc) to the predicted reduction A/pred = wc(x + )
—/(xc). and accept x+ as the next iterate unless either the agreement is so
good—i.e., | A/pred — A/| < 0.11 A/|—that we suspect 6C is an underestimate of
the radius in which mc adequately represents/, or the actual reduction in/is so
large that the presence of negative curvature, and thus a continuing rapid
decrease in/(x), is implied—i.e.,/(x+) <f(xc) + V/(xc)r(x+ — xc). In both these
cases we save x+ and/(x+), but rather than move directly to x+, we first
double dc and compute a new x+ using our current model. If (6.4.14) isn't
satisfied for the new x + , we drop back to the last good step we computed, but
if it is, we consider doubling again. In practice we may save a significant
number of gradient calls in this way.
An interesting situation in which the step bound must contract and then
expand is when the algorithm passes close by a point that looks like a mini-
mizer. The Newton steps shorten; the algorithm takes these Newton steps and
behaves as though it were converging. Then the algorithm discovers a way out,
the Newton steps lengthen, and the algorithm moves away. Such behavior is
desirable, since a perturbed problem might indeed have a real minimizer at
this point of distraction. We want to be able to increase <5C rapidly in such a
case. In one example, we saw six of these internal doublings of the step bound
after a point of distraction.
Now suppose we are content with x+ as our next iterate, and so we need
to update Sc to <5 + . We allow three alternatives: doubling, halving, or retaining
the current step bound to get <5 + . The actual conditions are somewhat arbi-
trary; what is important is that if our current quadratic model is predicting the
function well, we increase the trust region, but if it is predicting poorly, we
decrease the trust region. If the quadratic model has predicted the actual
function reduction sufficiently well—i.e., A/< 0.75 A/pred—then we take 6+ =
2dc. If the model has greatly overestimated the decrease in /(x)—i.e., A/ >
0.1 A/pred—then we take 6 + = de/2. Otherwise 6 + = 6C.
EXAMPLE 
6.4.5 Let/(x), xc, Hc, 6C be given by Example 6.4.3, and sup-
pose we have just taken the step determined in that example,

146 
Chap. 6 Globally Convergent Modifications of Newton's Method
Recall that
We want to decide whether x+ is a satisfactory point, and update the trust
region. First, we calculate
Therefore, x+ is acceptable. Next, we decide whether to try a larger step at the
current iteration. We calculate
and
Since | A/ — A/pred|/| A/| = 0.071 < 0.1, we double the trust region and go back
to the locally constrained optimal step, Algorithm A6.4.1. The reader can
confirm that with the new trust radius <5C = 1, Algorithm A6.4.1 will select the
Newton step. It is an exercise to complete the updating of the trust region for
this global iteration.
The algorithm for updating the trust region is Algorithm A6.4.5 in the
appendix. It has several additional features.
1. It uses a minimum and maximum step length, discussed in Section 7.2.
The trust radius is never allowed outside these bounds. The maximum
step length is supplied by the user. The minimum step length is the
quantity used to test for convergence in Algorithm 7.2.1. If x+ is unsatis-
factory, but the current trust region is already less than minstep, the
global step is halted, because convergence would necessarily be detected
at the end of the current global iteration. This situation may indicate
convergence to a nonsolution, so a warning message should be printed.
2. When the approximate solution from Algorithm A6.4.2 or A6.4.4 to the
constrained model problem is a Newton step that is shorter than the
current trust radius, these algorithms immediately reduce the size of the
trust region to the length of the Newton step. It is then still adjusted by
Algorithm A6.4.5. This is an additional mechanism for regulating the
trust region.
3. The algorithm is implemented using a diagonal scaling of the available
space, discussed in Section 7.1.

Globally Convergent Modifications of Newton's Method Chap. 6 
147
Finally, we discuss how the initial estimate of the trust region radius, or
step bound is obtained. Sometimes the user can supply a reasonable estimate
based on his knowledge of the problem. If not, Powell (1970a) suggests using
the length of the Cauchy step (see Subsection 6.4.2) as the initial trust region
radius. Other strategies are possible. The updating strategy of Algorithm
A6.4.5 does enable a trust region algorithm to recover in practice from a bad
starting value of 6, but there is usually some cost in additional iterations.
Therefore the initial trust region is reasonably important.
6.5 GLOBAL METHODS FOR SYSTEMS
OF NONLINEAR EQUATIONS
We return now to the nonlinear equations problem:
In this section we show how Newton's method for (6.5.1) can be combined
with global methods for unconstrained optimization to produce global
methods for (6.5.1).
The Newton step for (6.5.1) is
where J(xc) is the Jacobian matrix of F at xc. From Section 5.2 we know that
(6.5.2) is locally g-quadratically convergent to x+, but not necessarily globally
convergent. Now assume xc is not close to any solution x,,, of (6.5.1). How
would one decide then whether to accept x+ as the next iterate? A reasonable
answer is that ||F(x+)|| should be less than ||F(xc)|| for some norm ||-||, a
convenient choice being the /2 norm || F(x)||2 = F(x)TF(x).
Requiring that our step result in a decrease of ||F(x)||2 is the same thing
we would require if we were trying to find a minimum of the function || F(x) ||2.
Thus, we have in effect turned our attention to the corresponding mini-
mization problem:
where the "|" is added for later algebraic convenience. Note that every solu-
tion to (6.5.1) is a solution to (6.5.3), but there may be local minimizers of
(6.5.3) that are not solutions to (6.5.1) (see Figure 6.5.1). Therefore, although we
could try to solve (6.5.1) simply by using a minimization routine on (6.5.3), it is
better to use the structure of the orginal problem wherever possible, in particu-
lar to compute the Newton step (6.5.2). However, our global strategy for (6.5.1)
will be based on a global strategy for the related minimization problem (6.5.3).
An important question to ask is, "What is a descent direction for prob-

148 
Chap. 6 Globally Convergent Modifications of Newton's Method
Figure 6.5.1 The nonlinear equations and corresponding minimization
problem, in one dimension
lem (6.5.3)?" It is any direction p for which V/(xc)rp < 0, where
Therefore, the steepest-descent direction for (6.5.3) is along — J(xc)TF(xc). Fur-
thermore, the Newton direction along SN = — J(xc)~lF(xc) is a descent direc-
tion, since
as long as F(xc) =/= 0. This may seem surprising, but it is geometrically reason-
able. Since the Newton step yields a root of
it also goes to a minimum of the quadratic function
because mc(xc + s) > 0 for all s and mc(xc + SN) = 0. Therefore, SN is a descent
direction for mc, and since the gradients at xc of mc and / are the same, it is
also a descent direction for/
The above development motivates how we will create global methods for
(6.5.1). They will be based on applying our algorithms of Section 6.3 or 6.4 to
the quadratic model mc(x) in (6.5.4). Since V2m(xc) = J(xf)rJ(xc), this model is
positive definite as long as J(xc) is nonsingular, which is consistent with the
fact that xc -I- SN is the unique root of Mc(x) and thus the unique minimizer of
mc(x) in this case. Thus, the model mc(x) has the attractive properties that its
minimizer is the Newton point for the original problem, and that all its de-
scent directions are descent directions for /(x) because Vmc(xc) = 
Vf(xc).
Therefore methods based on this model, by going downhill and trying to

Globally Convergent Modifications of Newton's Method Chap. 6 
149
minimize mc(x), will combine Newton's method for nonlinear equations with
global methods for an associated minimization problem. Note that mc(x) is not
quite the same as the quadratic model of f(x) = yF(x)TF(x) around xc,
because V2/(xc) ^ J(xc)rJ(xc) (see Exercise 18 of Chapter 5).
The application of the global methods of Sections 6.3 and 6.4 to the
nonlinear equations problem is now straightforward. As long as J(xc) is suf-
ficiently well conditioned, then J(xc)TJ(xc) is safely positive definite, and the
algorithms apply without change if we define the objective function by
il|F(x)||2, tne Newton direction by — J(x)~lF(x), and the positive definite
quadratic model by (6.5.4). This means that in a line-search algorithm, we
search in the Newton direction, looking for a sufficient decrease in || F(x) ||2. In
trust region algorithms, we approximately minimize mc(xc + s) subject to
||s||2 <<5 C. If <5C > H./tar^xJHj, then the step attempted is the Newton
step; otherwise, for the locally constrained optimal step, it is
for /ic such that || s \\2 = <5C. Using either global strategy, we expect to be taking
Newton steps for F(x) = 0 eventually. Example 6.5.1 shows how our global
strategy using a line search would work on the example of Section 5.4, started
here from a different point, one at which the Newton step is unsatisfactory.
EXAMPLE 6.5.1 Let
which has the root
and let
Define
Then
and
Our line-search algorithm A6.3.1 will calculate x + = x0 + 
OS starting with
0 = 1, decreasing 
0 if necessary until/(x+) </(x0) + 10~4A0 V/(x0)rSo- For
A 0 = l ,
so that the Newton step clearly is unsatisfactory. Therefore we reduce A0 by a

150 
Chap. 6 Globally Convergent Modifications of Newton's Method
quadratic backtrack, calculating
In this case, f ( x + ) =• 5.79 x 105, f(x 0) * 2.89, Vf(x)Ts% = -F(x0)TF(x0) ^
-5.77, so that (6.5.6) gives /lt a 4.99 x 10~6. SinceJ^ < 0.1, Algorithm A6.3.1
sets A, =0.1,
This is still unsatisfactory, and so Algorithm A6.3.2 does a cubic backtrack.
The reader can verify that a backtrack yields A2 = 0.0659. Since A2 > i^, the
algorithm sets A2 = i^i = 0.05,
This point is still unsatisfactory, since/(x+) ^ 3.71 >/(x0), so the algorithm
does another cubic backtrack. It yields A3 = 0.0116, which is used since it is in
the interval [A2/10, A2/2] = [0.005, 0.025]. Now
This point is satisfactory, since
so we set X! = x+ and proceed to the next iteration.
It is interesting to follow this problem further. At the next iteration,
which is again unsatisfactory. However, the first backtrack step is successful:
Algorithm A6.31 computes At = 0.0156, and, since this is less than 0.1, it sets
/! =0.1,
and the step is accepted, since

Globally Convergent Modifications of Newton's Method 
Chap. 6 
151
At the next iteration,
so the Newton step is very good. From here on, Newton's method converges
g-quadratically to x^ = (1, l)r.
The only complication to this global strategy arises when J is nearly
singular at the current point xc. In this case we cannot accurately calculate the
Newton direction SN = — J(xc)~1F(.vf), and the model Hessian J(xc)TJ(xc) is
nearly singular. To detect this situation, we perform the QR factorization of
J(xc), and if R is nonsingular, estimate its condition number by Algorithm
A3.3.1. If R is singular or its estimated condition number is greater than
macheps ~1/2, we perturb the quadratic model to
where
(The condition number of Hc is about macheps 
1/2; see Exercise 23 for a more
precise justification.) From Section 6.4 we know that the Newton step to the
minimizer of this model, SN = — H~l J(xc}TF(xc), solves
subject to
for some 6 > 0. It is also a descent direction for/(x) = il|F(x)||2. Therefore,
we prefer this modified Newton step to some s = — J(xc)-1F(xc) that would
result from a perturbation J(xc) of the QR factorization of J(xc). See Exercise
24 for further discussion of this step.
Driver D6.1.3 shows how we use the global algorithms for unconstrained
minimization in solving systems of nonlinear equations. First at each iteration,
Algorithm A6.5.1 calculates the Qc Rc factorization of J(xc) and estimates the
condition number of Rc. If the condition number estimate is less than
macheps ~ l / 2, it calculates the Newton step — J(xc)~lF(xc), otherwise it calcu-
lates the perturbed Newton step described above. Then the driver calls either
the line-search, dogleg, or locally constrained optimal algorithm as selected by
the user. All these global algorithms require V/(xc) = J(xc)TF(xc), which is also
calculated by Algorithm D6.1.3. In addition, the trust region algorithms re-

152 
Chap. 6 
Globally Convergent Modifications of Newton's Method
quire the Cholesky factorization Lc Lf
r of Hc = J(xc)TJ(xc) (except for the case
when Hc is perturbed as described above). Since we have J(xc) = Qc Rc, it is
immediate that Lc = R*. Finally, all our algorithms for nonlinear equations
are implemented using a diagonal scaling matrix DF on F(x), discussed in
Section 7.2. It causes
/(x) = ill DF F(x) \\l, 
V/(x) = J(x)TD2
F F(x), and 
H = J(x)TD2
F J(x).
There is one significant case when these global algorithms for nonlinear
equations can fail. It is when a local minimizer of/(x) = j\\ F(x) \\\ is not a root
of F(x) (see Figure 6.5.1). A global minimization routine, started close to such a
point, may converge to it. There is not much one can do in such a case, except
report what has happened and advise the user to try to restart nearer to a root
of F(x) if possible. The stopping routine for nonlinear equations (Algorithm
A7.2.3) detects this situation and produces such a message. Research is cur-
rently underway on methods that might be able to restart themselves from
such local minimizers. See Allgower and Georg (1980) and Zirilli (1982).
6.6 
EXERCISES
1. Let f(x) = 3x2 + 2x,x2 + x2
2, x0 = (I, l)T. What is the steepest-descent direction
for/from x0? Is (1, — l)r a descent direction?
2. Show that for a positive definite quadratic f(x k + s) = gTs + ?ST V2/(xk)s, the
steepest-descent step from xk is given by equation (6.2.5).
3. Given a c e (0, 1), generalize Example 6.2.2 to an example where the sequence of
points generated by the steepest-descent algorithm from a specific x0 obeys
ll**+i -*JI = c"||xt-xJ|,/c = 0, ! . - • • •
4. Let /(x) = x2. Show that the infinite sequence of points from Figure 6.3.2, x, =
(-!)'(! + 2"'), ii = 0, 1, ..., is not permitted by (6.3.3) for any a > 0.
5. Let /(x) = x2. Show that the infinite sequence of points x, = 1 + 2~', i — 0, 1, ...,
is permitted by (6.3.3) for any a < j but is prohibited by (6.3.4) for any ft > 0.
6. Show that if/(x) is a positive definite quadratic, the Newton step from any xk e R"
satisfies condition (6.3.3) for a < \ and (6.3.4) for any /? > 0.
7. Prove that if (6.3.4) is replaced by
then Theorems 6.3.2 and 6.3.3 remain true; and that if in addition ft > j, then
Theorem 6.3.4 also remains true. This is Goldstein's original condition.
8. Let/(x) = xf + x|, xc = (1, 1)T, and the search direction pc be determined by the
Newton step. What will x+ be, using:
(a) The Newton step?
(b) Line-search Algorithm A6.3.1?
(c) A "perfect line-search" algorithm that sets x+ to the minimizer of/(x) in the
direction pc from xc? [Answer (c) approximately.]

Globally Convergent Modification of Newton's Method Chap. 6 153
9. Let/(x) - %x\ + x2,, xc = (1, l)r What is the exact solution to (6.4.1) if 6 = 2? if
6 = £ ? {Hint: Try // = 1 for the second part.]
10. Prove that the locally constrained optimal curve s(u) in Figure 6.4.2 is not necessarily
planar by constructing a simple three-dimensional example in which xc and some three
points on the curve are not coplanar. [/(jc) = x2 + 2x2 + 3jt2 will do.]
11. Let He IR"
Xn be symmetric and positive definite, and let t;,,..., vn be an orthonor-
maf basis of eigenvectors for H with corresponding eigenvalues A!,..., An. Show
that for
How does this relate to the model mc(ju) for \\H + nl 
lg\\ — 8 used in the locally
constrained optimal algorithm?
12. Let H, g be given by Exercise 11, and define s(/x) = (H + /u7)~'g for n > 0 and
r/O^) = ||j(/x)||2. Using the techniques of Exercise 11, show that
[You can also show that (J2/J/x2)^(/Lt) > 0 for all /z > 0 using these techniques, but the
proof is tedious.]
13. Let/(x) = {x\ + x2
2, x0 = (1, 1)T, flf = V/(x0), H = V2f(x0). Calculate the Cauchy
point of/from x0 (see Subsection 6.4.2), and the point N = x0 — (0.8y + 0.2)H~ lg
as used in our double dogleg algorithm. Then graph the double dogleg curve and
show graphically the values of xl if S = 1; if 6 — 5.
14. Let H e IR"xn be symmetric and positive definite, g e R". Prove that (gTg)2<
(gTHg)(gTH~}g). 
[Hint: Let u = Hl/2g, v = H~l/2g, and apply the Cauchy-Schwarz
inequality.]
15. Complete Example 6.4.5.
16. Let F(x) = (xt, 2x2)r, x0 = (1, 1)T. Using the techniques of Section 6.5, what is the
"steepest-descent" step from x0 for F = 0? If all your steps were in steepest-descent
directions, what rate of convergence to the root of F would you expect?
17. Let F: IR" —> IR" be continuously differentiable and x e IR". Suppose x is a local
minimizer of/(x) £ {F(x)rF(x) but F(x) + 0. Is J(x) singular? If J(x) is singular,
must x be a local minimizer of/(x)?
18. An alternative quadratic model for F = 0 to the one used in the global algorithms
of Section 6.5 is the first three terms of the Taylor series of 3l|F(xc + s)]!2,.
Show that this model is
How does this compare with the model used in Section 6.5? Is the Newton step for
minimizing mc(x) the same as the Newton step for F(x) = 0? Comment on the
attractiveness of this model versus the one used in Section 6.5. (An analogous

154 
Chap. 6 Globally Convergent Modifications of Newton's Method
situation with different conclusions occurs in the solution of nonlinear least-
squares problems—see Chapter 10.)
19. Why is the Newton step from x0 in Example 6.5.1 bad? [Hint: What would
happen if x0 were changed to (2, e/6)T z (2, 0.45)r?]
20. What step would be taken from x0 in Example 6.5.1 using the double dogleg
strategy (Algorithm A6.4.4) with S0 = 3?
21. Find out what the conjugate gradient algorithm is for minimizing convex quadra-
tic functions, and show that the dogleg with N = x+ is the conjugate gradient
method applied to mc(x) on the subspace spanned by the steepest-descent and
Newton directions.
22. One of the disadvantages often cited for the dogleg algorithm is that its steps are
restricted to be in the two-dimensional subspace spanned by the steepest-descent
and Newton directions at each step. Suggest ways to alleviate this criticism, based
on Exercise 21. See Steihaug (1981).
23. Let J e R"x" be singular. Show that
[Hint: Use (3.1.13) and Theorem 3.5.7.] Generalize this inequality to the case when
K2(J) > macheps"1/2.
24. Let F e R" be nonzero, J e R"x" singular. Another step that has been suggested for
the nonlinear equations problem is the s that solves
It was shown in Section 3.6 that the solution to (6.6.1) iss = —J*F, where J+ is
the pseudoinverse of J. Show that this step is similar to s = —(JTJ + a/)~'JrF,
where a > 0 is small, by proving:
(a) 
lim (JTJ + xirlJr = J + .
a-»0 +
(b) for any a > 0 and v e R", both (JTJ + a/)~ lJTv and J + v are perpendicular to
all vectors w in the null space of J.
25. The global convergence of the line search and trust region algorithms of Subsec-
tions 6.3.2, 6.4.1, and 6.4.2 does not follow directly from the theory in Subsection
6.3.1, because none of the algorithms implement condition (6.3.4). However, the
bounds in the algorithms on the amount of each adjustment in the line search
parameter A or the trust region 6C have the same theoretical effect. For a proof that
all of our algorithms are globally convergent, see Shultz, Schnabel, and Byrd
(1982).

Stopping, Scaling, and Testing
In this chapter we discuss three issues that are peripheral to the basic math-
ematical considerations in the solution of nonlinear equations and mini-
mization problems, but essential to the computer solution of actual problems.
The first is how to adjust for problems that are badly scaled in the sense that
the dependent or independent variables are of widely differing magnitudes.
The second is how to determine when to stop the iterative algorithms in
finite-precision arithmetic. The third is how to debug, test, and compare non-
linear algorithms.
7.1 SCALING
An important consideration in solving many "real-world" problems is that
some dependent or independent variables may vary greatly in magnitude. For
example, we might have a minimization problem in which the first indepen-
dent variable, x1? is in the range [102, 103] meters and the second, x2, is in the
range [10~7, 10 ~6] seconds. These ranges are referred to as the scales of the
respective variables. In this section we consider the effect of such widely dis-
parate scales on our algorithms.
One place where scaling will effect our algorithms is in calculating terms
such as || x+ — xc||2, which we used in our algorithms in Chapter 6. In the
above example, any such calculation will virtually ignore the second (time)
155
7

156 
Chap. 7 Scaling, Stopping, and Testing
variable. However, there is an obvious remedy: rescale the independent vari-
ables; that is, change their units. For example, if we change the units of Xj to
kilometers and x2 to microseconds, then both variables will have range
[10"1, 1] and the scaling problem in computing ||x+ — xc ||2 will be elimin-
ated. Notice that this corresponds to changing the independent variable to
x = Dxx, where Dx is the diagonal scaling matrix
This leads to an important question. Say we transform the units of our
problem to x = Dx x, or more generally, transform the variable space to x =
Tx, where T e IR"*" is nonsingular, calculate our global step in the new vari-
able space, and then transform back. Will the resultant step be the same as if
we had calculated it using the same globalizing strategy in the old variable
space? The surprising answer is that the Newton step is unaffected by this
transformation but the steepest-descent direction is changed, so that a line-
search step in the Newton direction is unaffected by a change in units, but a
trust region step may be changed.
To see this, consider the minimization problem and let us define x = Tx,
/(x) =/CT~ 'x). Then it is easily shown that
so that the Newton step and steepest-descent direction in the new variable
space are
or, in the old variable space,
These conclusions are really common sense. The Newton step goes to the
lowest point of a quadratic model, which is unaffected by a change in units of
x. (The Newton direction for systems of nonlinear equations is similarly un-
changed by transforming the independent variable.) However, determining
which direction is "steepest" depends on what is considered a unit step in each
direction. The steepest-descent direction makes the most sense if a step of one
unit in variable direction x, has about the same relative length as a step of one
unit in any other variable direction x,.
For these reasons, we believe the preferred solution to scaling problems
is for the user to choose the units of the variable space so that each component
of x will have roughly the same magnitude. However, if this is troublesome,
the equivalent effect can be achieved by a transformation in the algorithm of

Scaling, Stopping, and Testing Chap. 7 
157
the variable space by a corresponding diagonal scaling matrix Dx . This is the
scaling strategy on the independent variable space that is implemented in our
algorithms. All the user has to do is set Dx to correspond to the desired change
in units, and then the algorithms operate as if they were working in the
transformed variable space. The algorithms are still written in the original
variable space, so that an expression like || x+ — xc ||2 becomes || D^x+ — xc) \\2
and the steepest-descent and hook steps become
respectively (see Exercise 3). The Newton direction is unchanged, however, as
we have seen.
The positive diagonal scaling matrix Dx is specified by the user on input
by simply supplying n values typx;, i = 1, ..., n, giving "typical" magnitudes
of each x,. Then the algorithm sets (D,),-,- = (typx,)-1, making the magnitude of
each transformed variable x, = (£*);, x, about 1. For instance, if the user inputs
typxt = 103, typx2 = 10~6 in our example, then Dx will be (7.1.1). If no scaling
of x, is considered necessary, typx, should be set to 1. Further instructions for
choosing typx, are given in Guideline 2 in the appendix. Naturally, our algo-
rithms do not store the diagonal matrix Dx, but rather a vector Sx (S stands
for scale), where (Sx),. = (DJ,, = (typx,)-l.
The above scaling strategy is not always sufficient; for example, there are
rare cases that need dynamic scaling because some x, varies by many orders of
magnitude. This corresponds to using Dx exactly as in all our algorithms, but
recalculating it periodically. Since there is little experience along these lines, we
have not included dynamic scaling in our algorithms, although we would need
only to add a module to periodically recalculate Dx at the conclusion of an
iteration of Algorithm D6.1.1 or D6.1.3.
An example illustrating the importance of considering the scale of the
independent variables is given below.
EXAMPLE 7.1.1 A common test problem for minimization algorithms is the
Rosenbrock banana function
which has its minimum at x^ = (\, l)r. Two typical starting points are
x0 = (-1.2, 1)T and x0 = (6.39, -0.221)T. This problem is well scaled, but if
a ^ 1, then the scale can be made worse by substituting axt for x1? and x2/a
for x2 in (7.1.2), giving

158 
Chap. 7 Scaling, Stopping, and Testing
This corresponds to the transformation
If we run the minimization algorithms found in the appendix on/(x), starting
from x0 = ( — 1.2/a, a)r and x0 = (6.39/a, a( — 0.221))T, use exact derivatives, the
"hook" globalizing step, and the default tolerances, and neglect the scale by
setting typxj = typx2 = 1, then the number of iterations required for conver-
gence with various values of a are as follows (the asterisk indicates failure to
converge after 150 iterations):
a
0.01
0.1
1
10
100
Iterations from 
Iterations from
x0 = (-1.2/a, a)r 
x0 = (6.39/a, a(-0.221))r
150 + *
94
24
52
150 + *
150 +
47
29
48
150 +
*
*
However, if we set typxi = I/a, typ*2 = <*» then the output of the program is
exactly the same as for a = 1 in all cases, except that the x values are multiplied
by
It is also necessary to consider the scale of the dependent variables. In
minimization problems, the scale of the objective function/really only matters
in the stopping conditions, discussed in Section 7.2. In all other calculations,
such as the test/(x+) </(x) + 10 ~4 V/(x)r(x + - x), a change in the units of/
is of no consequence.
On the other hand, in solving systems of nonlinear equations, differing
sizes among the component functions/ can cause the same types of problems
as differing sizes among the independent variables. Once again, the Newton
step is independent of this scaling (see Exercise 4). However, the globalizing
strategy for nonlinear equations requires a decrease in ||F||2, and it is clear
that if the units of two component functions of F(x) are widely different, then
the smaller component function will be virtually ignored.
For this reason, our algorithms also use a positive diagonal scaling
matrix DF on the dependent variable F(x), which works as Dx does on x. The
diagonal matrix DF is chosen so that all the components ofDFF(x) will have
about the same typical magnitude at points not too near the root. DF is then

Scaling, Stopping, and Testing 
Chap. 7 
159
used to scale F in all the modules for nonlinear equations. The affine model
becomes DFMC, and the quadratic model function for the globalizing step
becomes mc = \ || DFMC \\\. All our interfaces and algorithms are implemented
like this, and the user just needs to specify DF initially. This is done by
inputting values typ/, i — 1,..., n, giving typical magnitudes of each/ at
points not too near a root. The algorithm then sets (DF),j = typ/,~l. [Actually
it stores SF e U", where (SF), = (Df),-,.] Further instructions on choosing typ/
are given in Guideline 5 in the appendix.
7.2 STOPPING CRITERIA
In this section we discuss how to terminate our algorithms. The stopping
criteria are the same common-sense conditions discussed in Section 2.5 for
one-dimensional problems: "Have we solved the problem?" "Have we ground
to a halt?" or "Have we run out of money, time, or patience?" The factors
that need consideration are how to implement these tests in finite-precision
arithmetic, and how to pay proper attention to the scales of the dependent and
independent variables.
We first discuss stopping criteria for unconstrained minimization. The
most important test is "Have we solved the problem?" In infinite precision, a
necessary condition for x to be the exact minimizer of / is V/(x) = 0, but in an
iterative and finite-precision algorithm, we will need to modify this condition
to V/(x) ^ 0. Although V/(x) = 0 can also occur at a maximum or saddle
point, our globalizing strategy and our strategy of perturbing the model Hes-
sian to be positive definite make convergence virtually impossible to maxima
and saddle points. In our context, therefore, V/(x) = 0 is considered a neces-
sary and sufficient condition for x to be a local minimizer of/
To test whether V/= 0, a test such as
is inadequate, because it is strongly dependent on the scaling of both / and x.
For example, if E = 10~3 and/is always in [10~7, 10~5], then it is likely that
any value of x will satisfy (7.2.1); conversely if / e [105, 107], (7.2.1) may be
overly stringent. Also, if x is inconsistently scaled—for example, xl e [106,
107] and x2 e [KT1, 1]—then (7.2.1) is likely to treat the variables unequally.
A common remedy is to use
Inequality (7.2.2) is invariant under any linear transformation of the indepen-
dent variables and thus is independent of the scaling of x. However, it is still
dependent on the scaling of/ A more direct modification of (7.2.1) is to define

160 
Chap. 7 Scaling, Stopping, and Testing
the relative gradient of/at x by
and test
Test (7.2.4) is independent of any change in the units of/or \. It has the
drawback that the idea of relative change in xt or/breaks down if x, or/(x)
happen to be near zero. This problem is easily fixed by replacing x, and / in
(7.2.3) by max {|x,|, typxj and max {|/(x)|, typ/}, respectively, where typ/is
the user's estimate of a typical magnitude of/ The resulting test,
is the one used in our algorithms.
It should be mentioned that the problem of measuring relative change
when the argument z is near zero is commonly addressed by substituting
(|z| + 1) or max {|z|, 1} for z. It is apparent from the above discussion that
both these substitutions make the implicit assumption that z has scale around
1. They may also work satisfactorily if |z| is much larger than 1, but they will
be unsatisfactory if |z| is always much smaller than 1. Therefore, if a value of
typz is available, the substitution max {| z |, typz} is preferable.
The other stopping tests for minimization are simpler to explain. The test
for whether the algorithm has ground to a halt, either because it has stalled or
converged, is
Following the above discussion, we measure the relative change in x, by
Selection of steptol is discussed in Guideline 2; basically, if p significant digits
of x^ are desired, steptol should be set to 10~p.
As in most iterative procedures, we quantify available time, money, and
patience by imposing an iteration limit. In real applications this limit is often

Scaling, Stopping, and Testing 
Chap. 7 
161
governed by the cost of each iteration, which can be high if function evalu-
ation is expensive. During debugging, it is a good idea to use a low iteration
limit so that an erroneous program won't run too long. In a minimization
algorithm one should also test for divergence of the iterates xk, which can
occur if / is unbounded below, or asymptotically approaches a finite lower
bound from above. To test for divergence, we ask the user to supply a maxi-
mum step length, and if five consecutive steps are this long, the algorithm is
terminated. (See Guideline 2.)
The stopping criteria for systems of nonlinear equations are similar. We
first test whether x+ approximately solves the problem—that is, whether
F(x+) ^ 0. The test ||F(x+)|| < e is again inappropriate, owing to problems
with scaling, but since (DF)n = 1/typ/j has been selected so that (Df),, F, should
have magnitude about 1 at points not near the root, the test
should be appropriate. Suggestions for fntol are given in Guideline 5; values
around 10 ~5 are typical.
Next one tests whether the algorithm has converged or stalled at x+,
using the test (7.2.6-7.2.7). The tests for iteration limit and divergence are also
the same as for minimization, though it is less likely for an algorithm for
solving F(x) = 0 to diverge.
Finally, it is possible for our nonlinear equations algorithm to become
stuck by finding a local minimum of the associated minimization function
/=lH^F^Il2 at which F^O (see Figure 6.5.1). Although convergence test
(7.2.6-7.2.7) will stop the algorithm in this case, we prefer to test for it ex-
plicitly by checking whether the gradient of/at x+ is nearly zero, using a
relative measure of the gradient analogous to (7.2.5). If the algorithm has
reached a local minimum of || DF F \\\ at which F ^ 0, all that can be done is to
restart the algorithm in a different place.
Algorithms A7.2.1 and A7.2.3 in the appendix contain the stopping cri-
teria for unconstrained minimization and nonlinear equations, respectively.
Algorithms A7.2.2 and A7.2.4 are used before the initial iteration to test whe-
ther the starting point x0 is already a minimizer or a root, respectively. Guide-
lines 2 and 5 contain advice for selecting all the user-supplied parameters. In
our software that implements these algorithms [Schnabel, Weiss, and Koontz
(1982)], default values are available for all the stopping and scaling tolerances.
7.3 TESTING
Once a computer program for nonlinear equations or minimization has been
written, it will presumably be tested to see whether it works correctly and how
it compares with other software that solves the same problem. It is important
to discuss two aspects of this testing process: (1) how should the software be

162 
Chap. 7 Scaling, Stopping, and Testing
tested and (2) what criteria should be used to evaluate its performance? It is
perhaps surprising that there is no consensus on either of these important
questions. In this section we indicate briefly some of the leading ideas.
The first job in testing is to see that, the code is working correctly. By
"correctly" we currently mean a general idea that the program is doing what it
should, as opposed to the computer scientist's much more stringent definition
of "correctness." This is certainly a nontrivial task for any program the size of
those in this book. We strongly recommend a modular testing procedure,
testing first each module as it is written, then the pieces the modules form, and
finally the entire program. Taking the approach of testing the entire program
at once can make finding errors extremely difficult. The difficulty with modu-
lar testing is that it may not be obvious how to construct input data to test
some modules, such as the module for updating the trust region. Our advice is
to start with data from the simplest problems, perhaps one or two dimensions
with identity or diagonal Jacobians or Hessians, since it should be possible to
hand-check the calculations. Then it is advisable to check the module on more
complex problems. An advantage of this modular testing is that it usually adds
to our understanding of the algorithms.
Once all the components are working correctly, one should test the
program on a variety of nonlinear problems. This serves two purposes: to
check that the entire program is working correctly, and then to observe its
performance on some standard problems. The first problems to try are the
simplest ones: linear systems in two or three dimensions for a program to
solve systems of nonlinear equations, positive definite quadratics in two or
three variables for minimization routines. Then one might try polynomials or
systems of equations of slightly higher degree and small (two to five) dimen-
sion. When the program is working correctly on these, it is time to run. it on
some standard problems accepted in this field as providing good tests of
software for nonlinear .equations or minimization. Many of them are quite
difficult. It is often useful to start these test problems from 10 or 100 times
further out on the ray from the solution x+ to the standard starting point x0,
as well as from x0 ; More, Garbow, and Hillstrom (1981) report that this often
brings out in programs important differences not indicated from the standard
starting points.
Although the literature on test problems is still developing, we provide
some currently accepted problems in Appendix B. We give a nucleus of stan-
dard problems for nonlinear equations or minimization sufficient for class
projects or preliminary research results and provide references to additional
problems that would be used in a thorough research study. It should be noted
that most of these problems are well scaled; this is indicative of the lack of
attention that has been given to the scaling problem. The dimensions of the
test problems in Appendix B are a reflection of the problems currently being
solved. The supply of medium (10 to 100) dimensional problems is still inad-
equate, and the cost of testing on such problems is a significant factor.

Scaling, Stopping, and Testing Chap. 7 
163
The difficult question of how to evaluate and compare software for mini-
mization or nonlinear equations is a side issue in this book. It is complicated
by whether one is primarily interested^ in measuring the efficiency and reliabil-
ity of the program in solving problems, or its overall quality as a piece of
software. In the latter case, one is also interested in the interface between the
software and its users (documentation, ease of use, response to erroneous
input, robustness, quality of output), and between the software and the com-
puting environment (portability). We will comment only on the first set of
issues; for a discussion of all these issues, see, e.g., Fosdick (1979).
By reliability, we mean the ability of the program to solve successfully
the problems it is intended for. This is determined first by its results on test
problems, and ultimately by whether it solves the problems of the user com-
munity. For the user, efficiency refers to the computing bill incurred running
the program on his or her problems. For minimization or nonlinear equations
problems, this is sometimes measured by the running times of the program on
test problems. Accurate timing data is difficult to obtain on shared computing
systems, but a more obvious objection is the inherent assumption that the test
problems are like those of the user. Another common measure of efficiency is
the number of function and derivative evaluations the program requires to
solve test problems. The justification for this measure is that it indicates the
cost on those problems that are inherently expensive, namely those for which
function and derivative evaluation is expensive. This measure is especially
appropriate for evaluating secant methods (see Chapters 8 and 9), since they
are used often on such problems. In minimization testing, the number of
function and gradient evaluations used sometimes are combined into one
statistic,
number of equivalent function evaluations
= number of/-evaluations + n (number of Devaluations).
This statistic indicates the number of function evaluations that would be used
if the gradients were evaluated by finite differences. Since this is not always the
case, it is preferable to report the function and gradient totals separately.
Some other possible measures of efficiency are number of iterations re-
quired, computational cost per iteration, and computer storage required. The
number of iterations required is a simple measure, but is useful only if it is
correlated to the running time of the problem, or the function and derivative
evaluations required. The computational cost of an iteration, excluding func-
tion and derivative evaluations, is invariably determined by the linear algebra
and is usually proportional to n3, or n2 for secant methods. When multiplied
by the number of iterations required, it gives an indication of the running time
for a problem where function and derivative evaluation is very inexpensive.
Computer storage is usually not an issue for problems of the size discussed in
this book; however, storage and computational cost per iteration become
crucially important for large problems.

164 
Chap. 7 Scaling, Stopping, and Testing
Using the above measures, one can compare two entirely different pro-
grams for minimization or nonlinear equations, but often one is interested
only in comparing two or more versions of a particular segment of the
algorithm—for example, the line search. In this case it may be desirable to test
the alternative segments by substituting them into a modular program such as
ours, so that the remainder of the program is identical throughout the tests.
Such controlled testing reduces the reliance of the results on other aspects of
the programs, but it is possible for the comparison to be prejudiced if the
remainder of the program is more favorable to one alternative.
Finally, the reader should realize that we have discussed the evaluation
of computer programs, not algorithms, in this section. The distinction is that a
computer program may include many details that are crucial to its per-
formance but are not part of the "basic algorithm." Examples are stopping
criteria, linear algebra routines, and tolerances in line-search or trust region
algorithms. The basic algorithm may be evaluated using measures we have
already discussed: rate of local convergence, global convergence properties,
performance on special classes of functions. When one tests a computer pro-
gram, however, as discussed above, one must realize that a particular software
implementation of a basic algorithm is being tested, and that two implemen-
tations of the same basic algorithm may perform quite differently.
7.4 EXERCISES
1. Consider the problem
What problems might you encounter in applying an optimization algorithm without
scaling to this problem? (Consider steepest-descent directions, trust regions, stop-
ping criteria.) What value would you give to typx,, typx2 in our algorithms in order
to alleviate these problems? What change might be even more helpful?
2. Let /: R" —> R, T e R"x" nonsingular. For any x 6 R", define x = Tx, /(x) =
f ( T ~ l x ) = /(x). Using the chain rule for multivariable calculus, show that
3. Let/e R, g e IR", H e R" x ", H symmetric and positive definite, D e R"x", Da posi-
tive diagonal matrix. Using Lemma 6.4.1, show that the solution to
subject to
is given by

Scaling, Stopping, and Testing Chap. 7 
165
for some n > 0. [Hint: Make the transformation s = Ds, use Lemma 6.4.1, and
transform back.]
4. Let F : R" — > Rn,T^T2 e Rnx" nonsingular. For any x e R" define £ = T^JC,
F(jt) = T2F(Tl~lx) = T2F(jc). Show that the Jacobian matrix of F with respect to x is
given by
What is the Newton step in the x variable space? If this step is transformed back to
the original variable space, how does it compare to the normal Newton step in the
original variable space?
5. What are some situations in which the scaling strategy of Section 7.1 would be
unsatisfactory? Suggest a dynamic scaling strategy that would be successful in these
situations. Now give a situation in which your dynamic strategy would be unsuc-
cessful.
6. Suppose our stopping test for minimization finds that V/(xk) « 0. How could you
test whether xk is a saddle point (or maximizer)? If xk is a saddle point, how could
you proceed in the minimization algorithm?
7. Write a program for unconstrained minimization or solving systems of nonlinear
equations using the algorithms in Appendix A (and using exact derivatives). Choose
one of globalizing strategies of Sections 6.3 and 6.4 to implement in your program.
Debug and test your program as discussed in Section 7.3.

This page intentionally left blank 

... And another program note
In the preceding chapters we have developed all the components of a
system of complete quasi-Newton algorithms for solving systems of
nonlinear equations and unconstrained minimization problems. There
is one catch: we have assumed that we would compute the required
derivative matrix, namely the Jacobian for nonlinear equations or the
Hessian for unconstrained minimization, or approximate it accurately
using finite differences. The problem with this assumption is that for
many problems analytic derivatives are unavailable and function
evaluation is expensive. Thus, the cost of finite-difference derivative
approximations, n additional evaluations of F(x) per iteration for a
Jacobian or (n2 + 3n)/2 additional evaluations of f (x) for a Hessian,
is high. In the next two chapters, therefore, we discuss a class of
quasi-Newton methods that use cheaper ways of approximating the
Jacobian or Hessian. We call these approximations secant approxi-
mations, because they specialize to the secant approximation to f'(x)
in the one-variable case, and we call the quasi-Newton methods that
use them secant methods. We emphasize that only the method for
approximating the derivative will be new; the remainder of the quasi-
Newton algorithm will be virtually unchanged.
The development of secant methods has been an active re-
search area since the mid 1960s. The result has been a class of
methods very successful in practice and most interesting theo-
retically; we will try to transmit a feeling for both of these aspects. As
in many active new fields, however, the development has been
chaotic and sometimes confusing. Therefore, our exposition will be
quite different from the way the methods were first derived, and we
will even introduce some new names. The reason is to try to lessen
the initial confusion the novice has traditionally had to endure to
understand these methods and their interrelationships.
Two comprehensive references on this subject are Dennis and
More (1977) and Dennis (1978). Another view of these approxi-
mations can be found in Fletcher (1980). Our naming convention for
the methods is based on suggestions of Dennis and Tapia (1976).
167

8
Secant Methods for Systems
of Nonlinear Equations
We start our discussion of secant methods with the nonlinear equations
problem, because secant approximations to the Jacobian are simpler than
secant approximations to the Hessian, which we discuss in Chapter 9. Recall
that in Chapter 2 we saw that we could approximate /'(x + ) at no additional
cost in function evaluations by a+ = (f(x + ) —f(xc))/(x+ — xc), and that the
price we paid was a reduction in the local ^-convergence rate from 2 to
(1 + >/5)/2. The idea in multiple dimensions is similar: we approximate J(x + )
using only function values that we have already calculated. In fact, multivari-
able generalizations of the secant method have been proposed which, although
they require some extra storage for the derivative, do have r-order equal to the
largest root of r" + 1 — r" — 1 =0; but none of them seem robust enough for
general use. Instead, in this chapter we will see the basic idea for a class of
approximations that require no additional function evaluations or storage and
that are very successful in practice. We will single out one that has a q-
superlinear local convergence rate and r-order 21/2fl.
In Section 8.1 we introduce the most used secant approximation to the
Jacobian, proposed by C. Broyden. The algorithm, analogous to Newton's
method, but that substitutes this approximation for the analytic Jacobian, is
called Broyden's method. In Section 8.2 we present the local convergence
analysis of Broyden's method, and in Section 8.3 we discuss the implemen-
tation of a complete quasi-Newton method using this Jacobian approximation.
We conclude the chapter with a brief discussion in Section 8.4 of other secant
approximations to the Jacobian.
168

Secant Methods for Systems of Nonlinear Equations 
Chap. 8 
169
8.1 
BROYDEN'S METHOD
In this section we present the most successful secant-method extension to solve
systems of nonlinear equations. Recall that in one dimension, we considered
the model 
** , \ 
\
M+(x) = /(*+) + a+(x - *+),
which satisfies M+(x+) = /(*+) for any a+ e R, and yields Newton's method if
a+ = f'(x+). If /'(*+) was unavailable, we instead asked the model to satisfy
M+(xc) = f(xc)~that is,
fM 
= /(* + ) + a+(xc ~ x+)
—which gave the secant approximation
The next iterate of the secant method was the x + + for which Af+(*++) = 0—
that is, x++ = x+ -f(x + )/a+.
In multiple dimensions, the analogous affine model is
M
which satisfies M+(x+) = F(x+) for any A+ e Rnx". In Newton's method,
A+ = J(x+). If J(x+) is not available, the requirement that led to the one-
dimensional secant method is M+(xc) = F(xc)—that is,
or
We will refer to (8.1.2) as the secant equation. Furthermore, we will use the
notation sc = x+ — xc for the current step and yc = F(x+) — F(xc) for the yield
of the current step, so that the secant equation is written
The crux of the problem in extending the secant method to n dimensions
is that (8.1.3) does not completely specify A+ when n > 1. In fact, if sc ± 0,
there is an n(n — l)-dimensional affine subspace of matrices obeying (8.1.3).
Constructing a successful secant approximation consists of selecting a good
way to choose from among these possibilities. Logically, the choice should
enhance the Jacobian approximation properties of A + or facilitate its use in a
quasi-Newton algorithm.
Perhaps the most obvious strategy is to require the model (8.1.1) to
interpolate F(x) at other past points x _,—that is,
F(x_i) = F(x+) + A+(x_i-x+)
—which leads to the equations

170 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
where
If m = n — 1 and sc, s-\,..., 5_(n_i) are linearly independent, then the n2 equations
(8.1.3) and (8.1.4) uniquely determine the n2 unknown elements of A+. Unfor-
tunately, this is precisely the strategy we were referring to in the introduction to
this chapter, that has r-order equal to the largest root of rn+1 — rn — 1 = 0; but is
not successful in practice. One problem is that the directions sc, s- \,..., .$_(„_ i) tend
to be linearly dependent or close to it, making the computation of A+ a poorly
posed numerical problem. 
Furthermore, the strategy requires an additional n2
storage.
The approach that leads to the successful secant approximation is quite
different. We reason that aside from the secant equation we have no new
information about either the Jacobian or the model, so we should preserve as
much as possible of what we already have. Therefore, we will choose A + by
trying to minimize the change in the affine model, subject to satisfying
A + sc = yc. The difference between the new and old affine models at any
x 6 R" is
M+(x) - M((x) = F(x+) + A+(x - x+) - F(xf) - Ae(x - xc)
= F(x+) - F(xf) - A+(x+ - xc) + (A+ - Ac\x - xc)
= (A+- 4 cXx-x f)
with the last equality due to the secant equation (8.1.2). Now for any x e R",
let us express
where tTs = 0. Then the term we wish to minimize becomes
We have no control over the first term on the right side, since the secant
equation implies (A + — Ac)sc =-yc — Acsc. However, we can make the second
term zero for all x e R" by choosing A + such that (A + — Ac)t = 0 for all t
orthogonal to sf. This requires that A + — Ac be a rank-one matrix of the form
wsc
r, u e U". Now to fulfill the secant equation, which is equivalent to
(A + — Ac)sf = yc — Ac sc, u must be (yc — Ac sc)/sc
r sf. This gives
as the least change in the affine model consistent with A+sc = yc.
Equation (8.1.5) was proposed in 1965 by C. Broyden, and we will refer
to it as Broyderfs update or simply the secant update. The word update indi-
cates that we are not approximating J(x+) from scratch; rather we are updat-
ing the approximation Ac to J(xc) into an approximation A+ to J(x+). This
updating characteristic is shared by all the successful multidimensional secant
approximation techniques.
The preceding derivation is in keeping with the way Broyden derived the

Secant Methods for Systems of Nonlinear Equations 
Chap. 8 
171
formula, but it can be made much more rigorous. In Lemma 8.1.1 we show
that Broyden's update is the minimum change to Ac consistent with A+sc = yc,
if the change A + — Ac is measured in the Frobenius norm. We comment on
the choice of norm after the proof. One new piece of notation will be useful :
we denote
That is, Q(y, s) is the set of matrices that act as quotients of y over s.
LEMMA 8.1.1 Let A € R"*n, s, y € R", s ^ 0. Then for any matrix norms
1 1 - 1 1 , III • III such that
and
the solution to
is
In particular, (8.1.9) solves (8.1.8) when || • || is the /2 matrix norm, and
(8.1.9) solves (8.1.8) uniquely when || • || is the Frobenius norm.
Proof. 
Let B e Q(y, s); then
If || • || and HI • HI are both taken to be the 12 matrix norm, then (8.1.6) and
(8.1.7) follow from (3.1.10) and (3.1.17), respectively. If || • || and ||| • |||
stand for the Frobenius and /2 matrix norm, respectively, then (8.1.6) and
(8.1.7) come from (3.1.15) and (3.1.17). To see that (8.1.9) is the unique
solution to (8.1.8) in the Frobenius norm, we remind the reader that the
Frobenius norm is strictly convex, since it is the 12 vector norm of the
matrix written as an n2 vector. Since Q(y, s) is a convex—in fact, affine—
subset of R"x" or IR"2, the solution to (8.1.8) is unique in any strictly
convex norm. 

172 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
The Frobenius norm is a reasonable one to use in Lemma 8.1.1 because
it measures the change in each component of the Jacobian approximation. An
operator norm such as the /2 norm is less appropriate in this case. In fact, it is
an interesting exercise to show that (8.1.8) may have multiple solutions in the
/2 operator norm, some clearly less desirable than Broyden's update. (See
Exercise 2.) This further indicates that an operator norm is inappropriate in
(8.1.8).
Now that we have completed our affine model (8.1.1) by selecting A+, the
obvious way to use it is to select the next iterate to be the root of this model.
This is just another way of saying that we replace J(x+) in Newton's method
by A + . The resultant algorithm is:
ALGORITHM 8.1.2 BROYDEN'S METHOD
Given F: R" —> R", x0 e R", 40 e R1""1
Dofor fc = 0, 1,...:
Solve Ak sk = — F(xk) for sk
Xk+l:= Xk + Sk
yk
:=F(xk + i)-F(Xk)
We will also refer to this method as the secant method. At this point, the readei
may have grave doubts whether it will work. In fact, it works quite well
locally, as we suggest below by considering its behavior on the same problem
that we solved by Newton's method in Section 5.1. Of course, like Newton's
method, it may need to be supplemented by the techniques of Chapter 6 to
converge from some starting points.
There is one ambiguity in Algorithm 8.1.1: how do we get the initial
approximation A0 to J(x0)? In practice, we use finite differences this one time
to get a good start. This also makes the minimum-change characteristic oi
Broyden's update more appealing. In Example 8.1.3, we assume for simplicity
that A0 = J(x0).
EXAMPLE 8.1.3 Let
which has roots (0, 3)r and (3, 0)r. Let x0 = (1, 5)r, and apply Algorithm 8.1.2

Secant Methods for Systems of Nonlinear Equations 
Chap. 8 
173
with
Then
Therefore, (8.1.10) gives
The reader can confirm that Als0 = y0. Note that
so that A! is not very close to J(xl). At the next iteration,
Again A2 is not very close to
The complete sequences of iterates produced by Broyden's method, and for
comparison, Newton's method, are given below. For k > 1, (xk)i + (xk)2 = 3
for both methods; so only (xk)2 is listed below.
Broyden's Method
(1, 5f
3.625
3.0757575757575
3.0127942681679
3.0003138243387
3.0000013325618
3.0000000001394
3.0
X0
*i
*2
*3
*4
*5
*6
*7
Newton's Method
(1, 5)r
3.625
3.0919117647059
3.0026533419372
3.0000023425973
3.0000000000018
3.0

174 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
Example 8.1.3 is characteristic of the local behavior of Broyden's
method. If any components of F(x) are linear, such as/^x) above, then the
corresponding rows of the Jacobian approximation will be correct for k > 0,
and the corresponding components of F(xk) will be zero for k > 1 (Exercise 4).
The rows of Ak corresponding to nonlinear components of F(x) may not be
very accurate, but the secant equation still gives enough good information that
there is rapid convergence to the root. We show in Section 8.2 that the rate of
convergence is g-superlinear, not ^-quadratic.
8.2 LOCAL CONVERGENCE ANALYSIS
OF BROYDEN'S METHOD
In this section we investigate the local convergence behavior of Broyden's
method. We show that if x0 is sufficiently close to a root x,,, where J(x^) is
nonsingular, and if A0 is sufficiently close to J(x0), then the sequence of iterates
{xk} converges g-superlinearly to x,,,. The proof is a special case of a more
general proof technique that applies to the secant methods for minimization as
well. We provide only the special case here, because it is simpler and easier to
understand than the general technique and provides insight into why multi-
dimensional secant methods work. The convergence results in Chapter 9 will
then be stated without proof. The reader who is interested in a deeper treat-
ment of the subject is urged to consult Broyden, Dennis, and More (1973) or
Dennis and Walker (1981).
We motivate our approach by using virtually the same simple analysis
that we used in analyzing the secant method in Section 2.6 and Newton's
method in Section 5.2. If F(x])[) = 0, then from the iteration
we have
or
Defining ek = xk — x* and adding and subtracting J(x*)ek to the right side of
the above equation gives
Under our standard assumptions,
so the key to the local convergence analysis of Broyden's method will be an
analysis of the second term, (Ak — J(x^))ek. First, we will prove local ^-linear

Secant Methods for Systems of Nonlinear Equations 
Chap. 8 
175
convergence of {ek} to zero by showing that the sequence {\\ Ak - J(xJ \\}
stays bounded below some suitable constant. It may not be true that
but we will prove local <j-superlinear convergence by showing that
This is really all we want out of the Jacobian approximation, and it implies
that 
the 
secant 
step, 
— Ak
lF(xk), 
converges 
to 
the Newton 
step,
— J(xk) ~l F(xk), in magnitude and direction.
Let us begin by asking how well we expect A+ given by Broyden's
update to approximate J(x+). If F(x) is affine with Jacobian J, then J will
always satisfy the secant equation—i.e., J e Q(yc, sc) (Exercise 5). Since A + is
the nearest element in Q(yc, sc) to Ac in the Frobenius norm, we have from the
Pythagorian theorem that
—i.e., \\A+ — J \\F < || Ac — J \\f (see Figure 8.2.1). Hence Broyden's update
cannot make the Frobenius norm of the Jacobian approximation error worse
in the affine case. Unfortunately, this is not necessarily true for nonlinear
functions. For example, one could have Ac = J(xJ 
but Ac sc ^ yc, which
would guarantee || A+ — J(xJ \\ > \\ Ac — J(x+) ||. In the light of such an exam-
ple, it is hard to imagine what useful result we can prove about how well Ak
approximates J(x4:). What is done is to show in Lemma 8.2.1 that if the
approximation gets worse, then it deteriorates slowly enough for us to prove
convergence of {xk} to x+.
LEMMA 8.2.1 Let D e R" be an open convex set containing xc, x + ,
with xc 7* x,,,. Let F: Rn —> Rn, J(x) e Lipy (D), Ac e Rnxn, A+ defined
by (8.1.5). Then for either the Frobenius or /2 matrix norms,
Furthermore, if x* e D and J(x) obeys the weaker Lipschitz condition
then

176 
Chap. 8 
Secant Methods for Systems of Nonlinear Equations
Figure 8.2.1 Broyden's method in the affine case
Proof. 
We prove (8.2.3), which we use subsequently. The proof of (8.2.2)
is very similar.
Let J^ = J(xJ. Subtracting J+ from both sides of (8.1.5),
Now for either the Frobenius or /2 matrix norm, we have from (3.1.15) or
(3.1.10), and (3.1.17),
Using
[because / — (sc SC
T/SC
T sc) is a Euclidean projection matrix], and
from Lemma 4. 1 . 1 5, concludes the proof. 
Inequalities (8.2.2) and (8.2.3) are examples of a property called bounded
deterioration. It means that if the Jacobian approximation gets worse, then it
does so in a controlled way. Broyden, Dennis, and More (1973) have shown
that any quasi-Newton algorithm whose Jacobian approximation rule obeys
this property is locally q-linearly convergent to a root x^ , where J(x+) is
nonsingular. In Theorem 8.2.2, we give the special case of their proof for
Broyden's method. Later, we show Broyden's method to be locally q-

Secant Methods for Systems of Nonlinear Equations Chap. 8 
177
superlinearly convergent, by deriving a tighter bound on the norm of the term
in (8.2.4).
For the remainder of this section we assume that xk + 1 ^ xk , k = 0,
1, ... . Since we show below that our assumptions imply Ak nonsingular, k = 0,
1, ..., and since xfc + 1 — xfc = — Ak
1F(xk), the assumption that xk + 1 
xk is
equivalent to assuming F(xk) = 0, k = 0, 1, ____ Hence we are precluding the
simple case when the algorithm finds the root exactly, in a finite number of
steps.
THEOREM 8.2.2 Let all the hypotheses of Theorem 5.2.1 hold. There
exist positive constants e, 6 such that if || x0 — x^ || 2 < e and
|| A0 — J(x+) || 2 < <5, then the sequence {xt} generated by Algorithm 8.1.2
is well defined and converges g-superlinearly to x^. If {Ak} is just as-
sumed to satisfy (8.2.3), then {xk} converges at least ^-linearly to x%.
Proof. 
Let || • || designate the vector or matrix 12 norm, ek 
xk — x+,
J* - J(x+\ P ^ II J(x*)~1II> and choose E and d such that
6pd < 1, 
(8.2.5)
3ye < 26. 
(8.2.6)
The local q-linear convergence proof consists of showing by induction
that
for k = 0, 1, .... In brief, the first inequality is proven at each iteration
using the bounded deterioration result (8.2.3), which gives
The reader can see that if
is uniformly bounded above for all k, then the sequence { \\ Ak — J+ \\ }
will be bounded above, and using the two induction hypotheses and
(8.2.6), we get (8.2.7). Then it is not hard to prove (8.2.8) by using (8.2.1),
(8.2.7), and (8.2.5).

178 
Chap. 8 
Secant Methods for Systems of Nonlinear Equations
For k = 0, (8.2.7) is trivially true. The proof of (8.2.8) is identical to
the proof at the induction step, so we omit it here.
Now assume that (8.2.7) and (8.2.8) hold for k = 0, ...,/- 1. For
k = i, we have from (8.2.9), and the two induction hypotheses that
From (8.2.8) and || e0 \\ < E we get
Substituting this into (8.2.10) and using (8.2.6) gives
which verifies (8.2.7).
To verify (8.2.8), we must first show that A{ is invertible so that the
iteration is well defined. From || J(xJ~l II ^ P, (8.2.7) and (8.2.5),
so we have from Theorem 3.1.4 that /4, is nonsingular and
Thus xi+i is well defined and by (8.2.1),
By Lemma 4.1.12,
Substituting this, (8.2.7), and (8.2.11) into (8.2.12) gives
From (8.2.8), || e0 \\ < e, and (8.2.6), we have

Secant Methods for Systems of Nonlinear Equations Chap. 8 
179
which, substituted into (8.2.13), gives
with the final inequality coming from (8.2.5). This proves (8.2.8) and
completes the proof of ^-linear convergence. We delay the proof of q-
superlinear convergence until later in this section. 
Q
We have proven <j-linear convergence of Broyden's method by showing
that the bounded deterioration property (8.2.3) ensures that || Ak — J(xJ \\
stays sufficiently small. Notice that if all we knew about a sequence of Ja-
cobian approximations {Ak} was that they satisfy (8.2.3), then we could not
expect to prove better than ^-linear convergence; for example, the approxi-
mations Ak — AQ 
J(xJ, k = 0, 1, ..., trivially satisfy (8.2.3), but from Exer-
cise 11 of Chapter 5 the resultant method is at best g-linearly convergent. Thus
the ^-linear part of the proof of Theorem 8.2.2 is of theoretical interest partly
because it shows us how badly we can approximate the Jacobian and get away
with it. However, its real use is to ensure that {xk} converges to x+ with
which we will use in proving <j-superlinear convergence.
We indicated at the beginning of this section that a sufficient condition
for the g-superlinear convergence of a secant method is
We will actually use a slight variation. In Lemma 8.2.3, we show that if {xk}
converges g-superlinearly to *„,, then
where sk = xk + l — xk and ek = xk — x+. This suggests that we can replace ek
by Sk in (8.2.14) and we might still have a sufficient condition for the ^-superlinear
convergence of a secant method; this is proven in Theorem 8.2.4. Using this
condition, we prove the g-superlinear convergence of Broyden's method.

180 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
LEMMA 8.2.3 Let Xk e R", k = 0, 1, 
If {**} converges ^-superlinearly to
x* e R", then in any norm || • ||
Proof. 
Define sk = xk + l — xk, ek = xk — x+. The proof is really just the
following picture:
Clearly, if
then
Mathematically,
where the final equality is the definition of ^-superlinear convergence
when ek ^ 0 for all k. 
Note that Lemma 8.2.3 is also of interest to the stopping criteria in our
algorithms. It shows that whenever an algorithm achieves at least q-
superlinear convergence, then any stopping test that uses sk is essentially
equivalent to the same test using ek, which is the quantity we are really
interested in.
Theorem 8.2.4 shows that (8.2.14), with ek replaced by sk, is a necessary
and sufficient condition for g-superlinear convergence of a quasi-Newton
method.

Secant Methods for Systems of Nonlinear Equations Chap. 8 
181
THEOREM 8.2.4 (Dennis-More, 1974) Let D £ R" be an open convex
set, F: R" — » R", J(x) € Lipy(D), X, e D and J(xJ nonsingular. Let {Ak}
be a sequence of nonsingular matrices in IR" x ", and suppose for some
x0 e D that the sequence of points generated by
remains in D, and satisfies xk 
x+ for any k, and \imk_tao xk = *„,. Then
{xk} converges g-superlinearly to x^ in some norm || • ||, and F(x^) = 0, if
and only if
where
Proof. 
Define J^ = J(xJ, ek = xk — x^. First we assume that (8.2.16)
holds, and show that F(xJ = 0 and {xfc} converges ^-superlinearly to x,,,.
From (8.2.15)
so that
with 
the final inequality coming 
from 
Lemma 
4.1.15. 
Using
lirn*^ || ek || = 0 and (8.2.16) in (8.2.18) gives
Since limk_QO | sk \\ — 0, this implies
From Lemma 4.1.16, there exist a > 0, fe0 > 0, such that

182 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
for all k^k0. Combining (8.2.19) and (8.2.20),
where
This implies
which completes the proof of g-superlinear convergence.
This proof that g-superlinear convergence and F(xJ = 0 imply
(8.2.16) is almost the reverse of the above. From Lemma 4.1.16, there
exist 0 > 0, k0 £ 0, such that
for all k^.k0. Thus g-superlinear convergence implies
Since lim,,.^ \\ sk ||/|| ek \\ = 1 from Lemma 8.2.3, (8.2.21) implies that
(8.2.19) holds. Finally, from (8.2.17) and Lemma 4.1.15,
which together with (8.2.19) and lim 
|| ek \\ = 0 proves (8.2.16).
Since J(x) is Lipschitz continuous, it is easy to show that Lemma 8.2.4
remains true if (8.2.16) is replaced by
This condition has an interesting interpretation. Since sk = —Ak
 1F(xk),
(8.2.22) is equivalent to
where
the Newton step from xk. Thus the necessary and

Secant Methods for Systems of Nonlinear Equations Chap. 8 
183
sufficient condition for the g-superlinear convergence of a secant method is
that the secant steps converge, in magnitude and direction, to the Newton
steps from the same points.
Now we complete the proof of Theorem 8.2.2. It is preceded by a techni-
cal lemma that is used in the proof.
LEMMA 8.2.5 Let s e Rn be nonzero, E e Rnxn, and let || • || denote the
/2 vector norm. Then
Proof. 
We remarked before that / — (SST/STS) is a Euclidean projector,
and so is SST/STS. Thus by the Pythagorian theorem,
Since
this proves (8.2.23a). Since for any a > 101 > 0, (a2 - 02)1/2 < a - 02/2a,
(8.2.23a) implies (8.2.23b). 
D
Completion of the proof of 
Theorem 8.2.2 (q-superttnear conver-
gence). Define Ek = Ak — J*, and let || • || denote the /2 vector norm.
From Theorem 8.2.4, a sufficient condition for {xk} to converge q-
superlinearly to x+ is
From (8.2.4),
In the proof of Lemma 8.2.1, we showed that

184 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
Using this, along with || ek + 1 \\ < \\ ek \\/2 from (8.2.8) and Lemma 8.2.5 in
(8.2.25), gives
or
From the proof of Theorem 8.2.2, || Ek \\F < 26 for all k > 0, and
Thus from (8.2.26),
and summing the left and right sides of (8.2.27) for k = 0, 1,..., i,
Since (8.2.28) is true for any / > 0,
is finite. This implies (8.2.24) and completes the proof.
We present another example, which illustrates the convergence of Broy-
den's method on a completely nonlinear problem. We also use this example to
begin looking at how close the final Jacobian approximation Ak is to the
Jacobian J(x*) at the solution.
EXAMPLE 
8.2.6 Let
which has a root x+ = (1, 1)T. The sequences of points generated by Broyden's

Secant Methods for Systems of Nonlinear Equations Chap. 8 
185
method and Newton's method from x0 = (1.5, 2)T with A0 = J(x0) for Broy-
den's method, are shown below.
Broyden's
1.5
0.8060692
0.7410741
0.8022786
0.9294701
1.004003
1.003084
1.000543
0.99999818
0.9999999885
0.99999999999474
1.0
Method
2.0
1.457948
1.277067
1.159900
1.070406
1.009609
0.9992213
0.9996855
1.00000000389
0.999999999544
0.99999999999998
1.0
x0
X,
X2
x3
X4
X5
x6
X7
X8
X9
X10
X11
Newton's
1.5
0.8060692
0.8901193
0.9915891
0.9997085
0.999999828
0.99999999999992
1.0
Method
2.0
1.457948
1.145571
1.021054
1.000535
1.000000357
1.0000000000002
1.0
The final approximation to the Jacobian generated by Broyden's method is
In the above example, A10 has a maximum relative error of 1.1% as an
approximation to J(x *). This is typical of the final Jacobian approximation
generated by Broyden's method. On the other hand, it is easy to show that in
Example 8.1.3, {Ak} does not converge to J(x *):
LEMMA 8.2.7 
In Example 8.1.3,
Proof. 
We showed in Example 8.1.3 that (Ak)11 = (Ak)l2 = 1 for all
k 
0, that
and that
for all k 
1. From (8.2.29), (1, 1)
Tsk = 0 for all k 
1. From the formula
(8.1.10) for Broyden's update, this implies that (Ak+l — Ak)(1, 1)T = 0 for

186 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
all k 
1. Thus
for all k 
1. Also, it is easily shown that the secant equation implies
in this case. From (8.2.30) and (8.2.31),
The results of Lemma 8.2.7 are duplicated exactly on the computer; we
got
in Example 8.1.1. The proof of Lemma 8.2.7 is easily generalized to show that
for almost any partly linear system of equations that is solved using Broyden's
method. Exercise 11 is an example of a completely nonlinear system of equa-
tions where {xk} converges to a root x* but the final Ak is very different from
J(x*).
In summary, when Broyden's method converges q-superlinearly to a root
x* one cannot assume that the final Jacobian approximation Ak will approxi-
mately equal J(x*), although often it does.
If we could say how fast 
goes to 0, then we could say
more about the order of convergence of Broyden's method. The nearest to
such a result is the proof given by Gay (1979). He proved that for any affine F,
Broyden's method gives x2n+1 = x* which is equivalent to || E2ns2n ||/|| s2n || =
0. Under the hypotheses of Theorem 8.2.2, this allowed him to prove 2n-step
q-quadratic convergence for Broyden's method on general nonlinear functions.
As a consequence of Exercise 2.6, this implies r-order 21/2n.
8.3 IMPLEMENTATION OF
QUASI-NEWTON ALGORITHMS
USING BROYDEN'S UPDATE
This section discusses two issues to consider in using a secant approximation,
instead of an analytic or finite-difference Jacobian, in one of our quasi-Newton
algorithms for solving systems of nonlinear equations: (1) the details involved
in implementing the approximation, and (2) what changes, if any, need to be
made to the rest of the algorithm.

Secant Methods for Systems of Nonlinear Equations Chap. 8 
187
The first problem in using secant updates to approximate the Jacobian is
how to get the initial approximation A0. We have already said that in practice
we use a finite-difference approximation to J(x0), which we calculate using
Algorithm A5.4.1. More's HYBRD implementation in MINPACK [More,
Garbow, and Hillstrom (1980)] uses a modification of this algorithm that is
more efficient when J(x) has many zero elements; we defer its consideration to
Chapter 11.
If Broyden's update is implemented directly as written, there is little to
say about its implementation; it is simply
t = y - As,
However, recall that the first thing our quasi-Newton algorithm will do with
A+ is determine its QR factorization in order to calculate the step
Therefore, the reader may already have realized that since Broy-
den's update exactly fits the algebraic structure of equation (3.4.1), a more
efficient updating strategy is to apply Algorithm A3.4.1 to update the factori-
zation Qc Rc of Ac into the factorization Q+ R+ of A + , in O(n2) operations.
This saves the 0(n3) cost of the QR factorization of Ak, at every iteration after
the first. The reader can confirm that an entire iteration of a quasi-Newton
algorithm, using the QR form of Broyden's update and a line-search or dogleg
globalizing strategy, costs only 0(n2) arithmetic operations.
We will refer to these two possible implementations of Broyden's update
as the unfactored and factored forms of the update, respectively. Appendix A
contains both forms, in Algorithms A8.3.1 and A8.3.2 respectively. The fac-
tored form leads to a more efficient algorithm and should be used in any
production implementation. The unfactored form is simpler to code, and may
be preferred for preliminary implementations.
Both forms of the update in the appendix contain two more features.
First, the reader can confirm (Exercise 12) that the diagonal scaling of the
independent variables discussed in Section 7.1 causes Broyden's update to
become
and this is the update actually implemented. The reader can confirm that the
update is independent of a diagonal scaling of the dependent variables.
Second, under some circumstances we decide not to change a row of Ac.
Notice that if (yc — Acsc)i = 0, then (8.3.1) automatically causes row i of A+
to equal row i of Ac. This makes sense, because Broyden's update makes
the smallest change to row i of Ac consistent with (A+)i.sc = (yc)i, and if

188 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
(yc — Ac sc)i = 0, no change is necessary. Our algorithms also leave row i of Ac
unchanged if | (yc — Ac sc)i | is smaller than the computational uncertainty in
(yc)i, measured by 
, where 
is the relative noise in func-
tion values that was discussed in Section 5.4. This condition is intended to
prevent the update from introducing random noise rather than good deriva-
tive information into A+ .
There is another implementation of Broyden's method that also results
in O(n2) arithmetic work per iteration. It uses the 
Sherman-Morrison-
Woodbury formula given below.
LEMMA 8.3.1 (Sherman-Morrison-Woodbury) Let 
u, 
, 
and
assume that 
is nonsingular. Then A + UVT is nonsingular if
and only if
Furthermore,
Proof. 
Exercise 13.
Straightforward application of Lemma 8.3.1 shows that if one knows
, then Broyden's update can be expressed as
which requires 0(n2) operations. The secant direction 
then can be
calculated by a matrix-vector multiplication requiring an additional O(n2) op-
erations. Therefore, until Gill and Murray (1972) introduced the notion of
sequencing QR factorizations, algorithms using Broyden's update were im-
plemented by initially calculating 
and then using (8.3.2). This implemen-
tation usually works fine in practice, but it has the disadvantage that it makes
it hard to detect ill-conditioning in A+. Since the factored update from Ac to
A+ doesn't have this problem, and since it requires essentially the same
number of arithmetic operations as (8.3.2), it has replaced (8.3.2) as the pre-
ferred implementation in production codes.
The other question we answer in this section is, "What changes need to
be made to the rest of our quasi-Newton algorithm for nonlinear equations
when we use secant updates?" From the way we have presented the general
quasi-Newton framework, we would like the answer to be "None," but there
are two exceptions. The first is trivial: when the factored form of the update is
used, the QR factorization of the model Jacobian at each iteration is omitted,
and several implementation details are adjusted as discussed in Appendix A.

Secant Methods for Systems of Nonlinear Equations Chap. 8 
189
The other change is more significant: it is no longer guaranteed that the
quasi-Newton direction, 
, is a descent direction for /(x) =
. Recall from Section 6.5 that
so that
which is nonpositive if Ac = J(xc), but not necessarily otherwise. Furthermore,
there is no way we can check whether sc is a descent direction for f(x) in a
secant algorithm, since we cannot calculate 
without J(xc). This means
that sc may be an uphill direction for f(x), and our global step may fail to
produce any satisfactory point. Luckily, this doesn't happen often in practice,
since Ac is an approximation to J(xc). If it does, there is an easy fix; we reset
Ac, using a finite-difference approximation to J(xc), and continue the algo-
rithm. This provision is included in the driver for our nonlinear equations
algorithm; it is essentially what is done in More's MINPACK code as well.
8.4 OTHER SECANT UPDATES FOR
NONLINEAR EQUATIONS
So far in this chapter we have discussed one secant update, Broyden's, for
approximating the Jacobian. We saw that of all the members of Q(yc, sc), the
affine subspace of matrices satisfying the secant equation
Broyden's update is the one that is closest to Ac in the Frobenius norm. In this
section we mention some other proposed approximations from Q(yc, sc).
Perhaps the best-known alternative was suggested by Broyden, in the
paper where he proposed Broyden's update. The idea from the last section, of
sequencing 
rather than Ak, suggested to Broyden the choice
A straightforward application of Lemma 8.1.1 shows that (8.4.2) is the solution
to
From Lemma 8.3.1, (8.4.2) is equivalent to
—clearly a different update from Broyden's update.
Update (8.4.2) has the attractive property that it produces values of

190 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
directly, without problems of a zero denominator. Furthermore, it shares all
the good theoretical properties of Broyden's update. That is, one can modify
the proof of Lemma 8.2.1 to show that this method of approximating J(x)
-1 is
of bounded deterioration as an approximation to J(x *) - 1, and from there
show that Theorem 8.2.2 holds using (8.4.2) in the place of Broyden's update.
In practice, however, methods using (8.4.2) have been considerably less suc-
cessful than the same methods using Broyden's update; in fact, (8.4.2) has
become known as "Broyden's bad update."
Although we don't pretend to understand the lack of computational
success with Broyden's bad update, it is interesting that Broyden's good
update comes from minimizing the change in the affine model, subject to
satisfying the secant equation, while Broyden's bad update is related to mini-
mizing the change in the solution to the model. Perhaps the fact that we use
information about the function, and not about its solution, in forming the
secant model, is a reason why the former approach is more desirable. In any
case, we will see an analogous situation in Section 9.2, where an update for
unconstrained minimization derived from Broyden's good update outperforms
a similar method derived from Broyden's bad update, although the two again
have similar theoretical properties.
There are many other possible secant updates for nonlinear equations,
some of which may hold promise for the future. For example, the update
is well defined and satisfies (8.4.1) for any 
for which 
. Broy-
den's good and bad updates are just the choices vk = sk and 
, respec-
tively. Barnes (1965) and Gay and Schnabel (1978) have proposed an update of
the form (8.4.5), where vk is the Euclidean projection of sk orthogonal to
s k - 1,..., sk-m, 0 
m < n. This enables A+ to satisfy m + 1 secant equations
Ak + 1si = yi, i = k — m,..., k, meaning that the affine model interpolates F(xi),
i = k — m,..., k — 1, as well as F(xk) and F(xk + 1). In implementations where
m < n is chosen so that s k_ m,..., sk are very linearly independent, this update
has slightly outperformed Broyden's update, but experience with it is still
limited. Therefore, we still recommend Broyden's update as the secant ap-
proximation for solving systems of nonlinear equations.
8.5 EXERCISES
1. Suppose si, 
, i = 1,..., n, and that the vectors s1,..., sn are linearly inde-
pendent. How would you calculate 
to satisfy Asi = yi, i = 1,..., n? Why
is this a bad way to form the model (8.1.1), if the directions s 1,..., sn are close to
being linearly dependent?

Secant Methods for Systems of Nonlinear Equations Chap. 8 
191
2. Show that if
then the solution to
is
What is the solution in the Frobenius norm? If F(x) is linear in x2, which solution
is preferable?
3. (a) Carry out two iterations of Broyden's method on
starting with x0 = (2, 7)T and A0 = J(x0).
(b) Continue part (a) (on a computer) until ||xk+, — xk|| 
(macheps)1/2. What is
the final value of Ak ? How does it compare with J(k*)?
4. Suppose Broyden's method is applied to a function F: 
for which f1,
..., fm are linear, m < n. Show that if A0 is calculated analytically or by finite
differences, then for k 
0, (Ak)i = J(x k) i , i = 1, ...,m, and that for k 
1,
fi(xk) = 0, i = l,...,m.
5. Suppose 
, F(x) = Jx + b. Show that if xc and x+ are any two
distinct points in Rn with sc = x+ — xc, yc = F(x+ ) — F(xc), then 
.
6. Prove (8.2.2) using the techniques of the proof of Lemma 8.2.1.
7. Suppose that 
, and I is the n x n identity matrix. Show that
8. Prove Theorem 8.2.4 with (8.2.22) in the place of (8.2.16).
9. Run Broyden's method to convergence on the function of Example 8.2.6, using the
starting point x0 == (2, 3)T (which was used with this function in Example 5.4.2).
Why didn't we use x0 = (2, 3)T in Example 8.2.6?
10. Generalize Lemma 8.2.7 as follows: let 1 
m < n,
where 
, and F2: 
is nonlinear. Suppose Broyden's
method is used to solve F(x) = 0, generating a sequence of Jacobian approxi-
mations A0, A1, A2, .... Let Ak be partitioned into

192 
Chap. 8 Secant Methods for Systems of Nonlinear Equations
Show that if A0 is calculated analytically or by finite differences, then Ak1 = Jl for
all k 
0, and 
for all k 
1. What does this imply about the
convergence of the sequence {Ak2} to the correct value F'2(x*)?
11. Computational examples of poor convergence of {Ak} to J(x *) on completely
nonlinear functions: Run Broyden's method to convergence on the function from
Example 8.2.6, using the starting point x0 = (0.5, 0.5)T and printing out the values
of Ak. Compare the final value of Ak with J(x *). Do the same using the starting
point x0 = (2, 3)T.
12. Suppose we transform the variables x and F(x) by
where Dx and DF are positive diagonal matrices, perform Broyden's update in the
new variable and function space, and then transform back to the original variables.
Show that this process is equivalent to using update (8.3.1) in the original variables
x and F(x). [Hint: The new Jacobian J(x) is related to the old Jacobian J(x) by
13. Prove Lemma 8.3.1.
14. Using the algorithms from the appendix, program and run an algorithm for solving
systems of nonlinear equations, using Broyden's method to approximate the Ja-
cobian. When your code is working properly, try to find a problem where an
"uphill" secant direction is generated [i.e., 
], so that it is
necessary to reset Ak to J(xk).
15. Use Lemma 8.1.1 to show that (8.4.2) is the solution to (8.4.3). Then use Lemma
8.3.1 to show that (8.4.2) and (8.4.4) are equivalent, if Ac is nonsingular and
.
16. (Hard) Come up with a better explanation of why Broyden's "good" method,
(8.1.5), is more successful computationally than Broyden's bad method, (8.4.4).
Exercises 17 and 18 are taken from Gay and Schnabel (1978).
17. Let 
, si, 
i = k - 1, k, sk-1, 
and sk linearly independent, and
assume that Ak s k - l = yk-1.
(a) Derive a condition on vk in (8.4.5) so that Ak + lsk-1 = y k - 1.
(b) Show that the Ak+1 given by (8.4.5), with
is the solution to
minimize
subject to
18. Generalize Exercise 17 as follows: assume in addition that for some m < n, si,
i = k — m,...,k, with sk_m, ..., sk linearly independent and Aksi = yi,
i = k — m, ..., k — 1.

Secant Methods for Systems of Nonlinear Equations 
Chap. 8 
193
(a) 
Derive a condition on vk in (8.4.5) so that Ak + lsl, = yi, i = k — m, ..., k — 1.
(b) Find a choice of vk so that Ak +1 given by (8.4.5) is the solution to
subject to

Secant Methods
for Unconstrained Minimization
In this chapter we consider secant methods for the unconstrained mini-
mization problem. The derivatives we have used in our algorithms for this
problem are the gradient, V/(x), and the Hessian, 
. The gradient must be
known accurately in minimization algorithms, both for calculating descent
directions and for stopping tests, and the reader can see from Chapter 8 that
secant approximations do not provide this accuracy. Therefore, secant ap-
proximations to the gradient are not used in quasi-Newton algorithms. On the
other hand, the Hessian can be approximated by secant techniques in much
the same manner as the Jacobian was in Chapter 8, and this is the topic of the
present chapter. We will present the most successful secant updates to the
Hessian and the theory that accompanies them. These updates require no
additional function or gradient evaluations, and again lead to locally q-
superlinearly convergent algorithms.
Since the Hessian is the Jacobian of the nonlinear system of equations
it could be approximated using the techniques of Chapter 8. How-
ever, this would disregard two important properties of the Hessian: it is always
symmetric and often positive definite. The incorporation of these two proper-
ties into the secant approximation to the Hessian is the most important new
aspect of this chapter. In Section 9.1 we introduce a symmetric secant update,
and in Section 9.2 one that preserves positive definiteness as well. The latter
update, called the positive definite secant update (or the BFGS), is in practice
the most successful secant update for the Hessian. In Section 9.3 we present
194
9

Secant Methods for Unconstrained Minimization Chap. 9 
195
another derivation of the positive definite secant update that leads to its local
convergence proof. Implementation considerations are discussed in Section
9.4. We conclude the chapter with a global convergence result for the positive
definite secant update in Section 9.5 and a brief discussion of other secant
approximations to the Hessian in Section 9.6.
9.1 THE SYMMETRIC SECANT
UPDATE OF POWELL
Suppose that we are solving
that we have just taken a step from xc to x+, and that we wish to approximate
by H+ using secant techniques. Following the development in Section
8.1, we ask first what the secant equation should be. If we think of the Hessian
as the derivative matrix of the system of nonlinear equations V/(x) = 0, then
the analogous secant equation to (8.1.3) is
where
We will refer to (9.1.1) as the secant equation for the unconstrained mini-
mization problem. Notice that if H+ satisfies (9.1.1), then the quadratic model
satisfies
and
This is an-
other way to motivate equation (9.1.1).
We could now use the secant update of Chapter 8 to approximate
by
where 
is our approximation to 
. The main problem with
(9.1.2) is that even if Hc is symmetric, (H+)1 will not be unless yc — Hcsc is a
multiple of sc. We have already seen several reasons why a Hessian approxi-
mation should be symmetric. (See, for example, Exercise 12 of Chapter 4.)
Therefore we seek an H+ that obeys 
as well as (9.1.1).
Since Frobenius norm projection into Q(yc, sc) proved to be a good way
to update Ac in Chapter 8, a reasonable idea to construct a symmetric (H+)2
from (H+)1 is to make the Frobenius norm projection of (H+)l into the

196 
Chap. 9 Secant Methods for Unconstrained Minimization
subspace S of symmetric matrices. It is an easy exercise to show that this is
accomplished by
Now (H+)2 is symmetric (Hc is), but it does not in general obey the secant
equation. However, one might consider continuing this process, generating
(H+)3,(H+)4,...by
Here each (H+)2k + l is the closest matrix in Q(yc,sc) to (H+)2k, and each
(H +) 2 k + 2 
the closest symmetric matrix to (H+)2k + l (see Figure 9.1.1). This
sequence of matrices was shown by M. J. D. Powell (1970b) to converge to
We will call update (9.1.3) the symmetric secant update; it is also known
as the Powell-symmetric-Broyden (PSB) update. It is an easy exercise to con-
firm that H+ given by (9.1.3) obeys the secant equation (9.1.1), and that
H+ — Hc is a symmetric matrix of rank two. In fact, Dennis and More (1977)
prove the following theorem:
THEOREM 9.1.1 Let 
be symmetric, sc,
Then
the unique solution to
minimize
subject to 
Hsc — yc, 
(H — Hc) symmetric
is given by (9.1.3).
The proof of Theorem 9.1.1 is similar to that of Theorem 8.1.1 and is
indicated in Exercise 4. Theorem 9.1.1 also follows from a much more general
result of Dennis and Schnabel (1979), given in Chapter 11, that guarantees the
process of Figure 9.1.1 will converge to the closest matrix to Hc in the intersec-
tion of the two affine subspaces.
The local convergence properties of the quasi-Newton method using
(9.1.3) are the same as for the secant method for systems of nonlinear equa-
tions, and so we just state the following theorem. The proof is a generalization
of the techniques of Section 8.2; it is indicated in Exercise 5 and 6. Notice that

Secant Methods for Unconstrained Minimization 
Chap. 9 
197
Figure 9.1.1 The Powell symmetrization process
the algorithm converges locally to any isolated zero of 
, since
is required only to be symmetric and nonsingular, but not necessarily positive
definite.
THEOREM 9.1.2 [Broyden, Dennis, and More (1973)] 
Let f:
be twice continuously differentiable in an open convex set 
, and
let 
. Assume there exists 
such that 
and
is nonsingular and that H0 is symmetric. Then there exist positive
constants , 
such that if
the
symmetric secant method
is well defined, and {xk} remains in D and converges q-superlinearly to
x*•
At this point it might seem that we have accomplished everything that
we want out of a secant approximation to the Hessian. However, the sym-
metric secant update has one important problem that hurts its performance in
practice: H+ given by (9.1.3) may not be positive definite, even if Hc is and
there are positive definite matrices in 
. Figure 9.1.2 illustrates the
reason. Let PD be the set of symmetric and positive definite matrices, and QS =
the affine space of symmetric matrices that obey the secant equation.
Then we see that the closest matrix to Hc in QS may not be positive definite, even if
is nonempty. Furthermore, since PD is an open convex cone, there may not
even be a closest matrix to Hc in

198 
Chap. 9 Secant Methods for Unconstrained Minimization
Figure 9.1.2 Why the symmetric secant update may not be positive defi-
nite
Since we have stressed the importance of having a positive definite model
Hessian, we would like H+ to be positive definite in the above situation. In
Section 9.2 we see a useful way to accomplish this. The result is the secant
update to the Hessian that is most successful in practice. It is also a symmetric,
rank-two change to Hc.
To conclude this section, we mention a formula closely related to (9.1.3)
that we will want to refer to in Section 9.3. J. Greenstadt (1970) suggested the
update
The reader will easily guess that (9.1.5) is the result of applying the symmetri-
zation procedure of Figure 9.1.1 to the bad Broyden update (8.4.2), and that
is the nearest matrix in 
to 
in the Frobenius norm.
Theorem 9.1.2 also holds for this update, but (9.1.5) shares with the symmetric
secant update the deficiency of not necessarily giving a positive definite H+
even when Hc is positive definite and 
is nonempty. However, we will
see in Section 9.3 that (9.1.5) has an interesting relationship to the most suc-
cessful secant update to the Hessian.
9.2 SYMMETRIC POSITIVE DEFINITE
SECANT UPDATES
In solving the unconstrained minimization problem by a quasi-Newton algo-
rithm, much has been made of the advantages in efficiency, numerical stability,
and global convergence of having a symmetric and positive definite model

Secant Methods for Unconstrained Minimization Chap. 9 
199
Hessian. In this section we show how to create symmetric and positive definite
secant approximations to the Hessian.
We seek a solution to:
given
To ensure that H+ is symmetric and positive definite, we will use the analog of
a common trick in mathematical programming. There, if a certain variable
must be nonnegative, we replace it by j2, where j € R is a new un-
constrained independent variable. In analogy, it is easy to prove that H+ is
symmetric and positive definite if and only if
for some nonsingular
Thus we will reexpress (9.2.1) as:
For any solution J+ to (9.2.2), 
will solve (9.2.1).
Even for n = 1, we see that there is no solution to (9.2.2) unless
has the same sign as sc, so first we must determine the conditions under which
(9.2.2) will have a solution. Lemma 9.2.1 contains the answer and also suggests
a procedure for finding J+ .
LEMMA 9.2.1 Let
Then there exists a nonsingular
such that
if and only if
Proof. 
Suppose there exists a nonsingular J+ such that
Define
Then
This proves the only if portion of the lemma. The if part is proven by the
derivation below, but first we digress to a discussion of the condition
Since
condition (9.2.3) is equivalent to
which simply means that the directional derivative of f(x) in the direction
sc is larger at x+ than at xc. This condition must be satisfied if the global
algorithm implements our second step-acceptance condition from Sec-
tion 6.3,

200 
Chap. 9 Secant Methods for Unconstrained Minimization
which we used to prevent excessively small steps. Even if the step-
acceptance criterion does not explicitly enforce (9.2.5), the steps taken by
our algorithms will usually satisfy (9.2.4), unless one is in a region with
significant negative curvature.
Now we return to the first part of the proof of Lemma 9.2.1. It
points out that for any J+ that solves (9.2.2), there will exist a
such that
J + v c = y c and
This suggests the following procedure for solving (9.2.2):
1. Select
such that J + vc = yc. J + will be a function of vc
and yc.
2. Choose vc so that
At this point, let us remember where we are in our minimization algo-
rithm when we want to find H + . We have determined the step sc using
the Cholesky factorization 
of the positive definite model Hessian
Hc. It seems entirely in keeping with the spirit of Chapter 8 to select J +
to be as close to Lc as possible. This suggests that we satisfy step 1 above
by selecting
which by Lemma 8.1.1 is the nearest matrix to Lc in Q(yc, vc). Then step
2 requires that
which can be satisfied only if
for some
Substituting (9.2.8) into (9.2.7) and simplifying yields
which has a real solution if and only if
since
We
will choose the positive square root,
because this makes J + closer to Lc when 
. It is an easy exercise
to show that J + given by (9.2.6, 9.2.9) is nonsingular, and thus solves

Secant Methods for Unconstrained Minimization 
Chap. 9 
201
(9.2.2). This completes the proof of Lemma 9.2.1, since given any non-
singular Lc, the if portion of Lemma 9.2.1 is satisfied by (9.2.6, 9.2.9).
We have now derived a symmetric secant update that retains positive
definiteness, whenever this is possible, by updating the Cholesky factor Lc of
Hc to a J+ for which 
. However, a really useful form for J + would
be as a lower triangular matrix L + , since then we would have the Cholesky
factorization of H +. The reader may already have realized how to get L + from
J+ in O(n2) operations, by using the QR factorization updating techniques
introduced in Section 3.4 and used in Section 8.3. If we use Algorithm A3.4.1
to get 
operations, then
, and it is not even necessary to accumulate Q + . Similarly, it is possible
to get the 
factorization of H+ directly from the 
factoriza-
tion of Hc in O(n2) operations via the LDV factorization update.
We can also express (9.2.6, 9.2.9) as a direct update of Hc to H + . If we
form 
using (9.2.6, 9.2.9) and recall 
, then we get
This form of the update [or a form given in equation (9.3.5)] was discovered
independently by Broyden, Fletcher, Goldfarb, and Shanno in 1970, and the
update has become known as the BFGS update. We will refer to it simply as
the positive definite secant update. The procedure for directly updating the
Cholesky factor Lc to L+ can be found in Goldfarb (1976). The reader can
confirm that, like the symmetric secant update of Section 9.1, (9.2.10) obeys
H+sc = yc, and (H + — Hc) is a symmetric matrix of rank at most two.
Is this positive definite secant update at all useful? Yes—it is the best
Hessian update currently known. This is illustrated in Example 9.2.2, where we
employ quasi-Newton methods using the symmetric secant update and the
positive definite secant update, respectively, to solve the same problem solved
by Newton's method in Section 5.5. In analogy with Chapter 8, we set H0 =
. However, we will see in Section 9.4 that a different strategy for
choosing H0 is recommended in practice.
EXAMPLE 
9.2.2 Let
which
has the minimizer x*, = (2, — l)r. Then the sequence of points produced by the
positive definite secant method,

202 
Chap. 9 Secant Methods for Unconstrained Minimization
starting from x0 = (1, l)T and 
, are (to eight figures on a CDC
machine with 14 base-10 digits):
f(xk)
x0 = (1 
. 1 
)T
x1=0 
,-0.5 
)T
x2 = (1.45 
,-0.3875 
)T
x3 = (1.5889290, -0.63729087)T
x4 = (1.8254150, -0.97155747)T
x5 = (1.9460278, -1.0705597 )T
x6 = (1.9641387, -1.0450875 )T
x7 = (1.9952140, -1.0017148 )T
x8 = (2.0000653, -1.0004294 )T
x9 = (1.9999853, -0.99995203)T
x10 = (2.0 
,-1.0 
)T
6.0
1.5
5.12 x 10-1
2.29 x 10-1
3.05 x 10-2
8.33 x 10-3
3.44 x 10-3
2.59 x 10-5
1.89 x 10-7
2.52 x 10-9
0
The sequence of points produced by the symmetric secant method (9.2.4), using
the same x0 and H0, are
f(xk)
xo = (1
x 1=(l
x2 = (1.3272727,
x3 = (1.5094933,
x4 = (1.7711111,
x5 = (1.9585530,
x6 = (1.9618742,
x7 = (1.9839076,
x8 = (1.9938584,
x9 = ( 1.9999506,
x10 = (2.0000343,
x11 = (2.0000021,
x12 = (2.0
1 
)T
-0.5 
)T
-0.41818182)T
-0.60145121)T
-0.88948020)T
-1.0632382 )T
-1.0398148 )T
- 0.99851156)T
-0.99730502)T
-0.99940456)T
- 0.99991078)T
-0.99999965)T
-1.0 
)T
6.0
1.5
6.22 x 10-1
3.04 x 10-1
5.64 x 10-2
5.94 x 10-3
3.16 x 10-3
2.60 x 10-4
4.48 x 10-5
3.57 x 10-7
9.13 x 10-9
1.72 x 10-11
0
Newton's method requires six or seven iterations to achieve the same accuracy.
The reasons why the positive definite secant update has been so suc-
cessful are still not fully understood, although the next section offers some
explanation. There we will also discuss another update that results from using
a derivation analogous to the one in this section to find an

Secant Methods for Unconstrained Minimization Chap. 9 
203
such that
The result is
where again 
. Using the Sherman-Morrison-Woodbury formula
(Lemma 8.3.1), (9.2.12) can be shown to yield
Update (9.2.13) is often called the DFP update for its discoverers Davi-
don (1959) and Fletcher and Powell (1963). It was the first secant update of
any kind to be found, and the original derivation was by entirely different
means than the above. From (9.2.12), it is easy to show that the DFP update
also has the property that H+ is positive definite if Hc is positive definite and
Therefore we will sometimes refer to this update as the inverse posi-
tive definite secant update.
In the early 1970s a number of studies were made comparing quasi-
Newton methods using the two secant updates introduced in this section [see,
e.g., Dixon (1972) and Brodlie (1977)]. The consensus seems to be that the
positive definite secant update (BFGS) performs better in conjunction with the
algorithms of Chapter 6, and the DFP update sometimes produces numeri-
cally singular Hessian approximations. Nevertheless, the DFP is a seminal
update that has been used in many successful computer codes, and it will also
play an important role in our analysis in the next section.
9.3 LOCAL CONVERGENCE OF
POSITIVE DEFINITE
SECANT METHODS
In this section we give an alternate derivation of the positive definite secant
update and the DFP update. The easy derivation of the last section has not yet
led to a successful convergence analysis, but the derivation of this section has.
We will see that if a natural rescaling of the variable space is applied to the
minimization problem, then the two symmetric and positive definite updates of
the last section result from the two symmetric updates of Section 9.1 applied to
the rescaled problem. A very closely related rescaling leads to the convergence
results.

204 
Chap. 9 Secant Methods for Unconstrained Minimization
We have seen in Chapter 7 how important it is to treat a well-scaled
minimization problem. A quadratic minimization problem could be considered
perfectly scaled if its Hessian were the identity, since this would result in
circular contours, and the Newton and steepest-descent directions would be
the same. This "perfect" scaling will be the key to our derivations.
We saw in Section 7.1 that if we rescale the variable space by
then in the new variable space, the quadratic model around
is
where H+ is the model Hessian in the original variable space. That is, the
gradient is transformed to 
, and the model Hessian to T-TH 
+ T-1.
Thus the rescaling that leads to an identity Hessian in the model around x+
satisfies
It would be nice to generate our secant update to Hc in the variable
space transformed by this T+, since we would be using the perfect rescaling for
the new quadratic model. However, we don't know T+ or H+ a priori, so let us
consider instead any arbitrary scale matrix T such that
Now consider the symmetric secant update of Section 9.1 in this variable
space. It is
where
If we use the above relations to reexpress (9.3.1) in the original variable space,
the reader can verify that we get
Since
for any symmetric
(9.3.2) is independent

Secant Methods for Unconstrained Minimization Chap. 9 
205
of the particular H or T and becomes
which is just the DFP update! Note that if we had known H+ a priori, we
could have used a T+ such that 
in our derivation, and the result
would have been the same.
Another way of stating the above is that if Hc is symmetric and
then for any 
such that 
, (9.3.3) is the unique solution
to
That is, the DFP update is the projection of Hc onto 
in this
weighted Frobenius norm.
If we apply the same rescaling, use Greenstadt's update (9.1.5) of 
to
, and then transform back, the result is
It is straightforward but tedious to show that (9.3.5) is the expression that
results from inverting both sides of equation (9.2.10), the H-form of the posi-
tive definite secant (BFGS) update. Thus, if Hc is symmetric and 
, then
for any 
such that 
, the positive definite secant update
is the unique solution to
The reader has probably noticed the intriguing duality that has run through
the derivations of the positive definite and inverse positive definite secant
updates in Sections 9.2 and 9.3. Since each of these updates can be derived
using a scaling of the variable space that is different at every iteration, the
methods that use them are sometimes called variable metric methods.
The local convergence proof for the positive definite secant method uses
the rescaling idea in a central way. The proof shows that the sequence of
Hessian approximations {Hk} obeys a bounded deterioration property of the
sort given in Chapter 8. To show this, the proof uses a weighted Frobenius
norm like (9.3.6), but with T replaced by a T* for which 
. This
is just the rescaling that causes the Hessian matrix at the minimizer to be the

206 
Chap. 9 Secant Methods for Unconstrained Minimization
identity. If the sequence of Hessian approximations converges to 
, it is
the limit of the rescalings used in the above derivations. The same techniques
are used to prove the local convergence of the DFP method. In this case the
norm from (9.3.4) is used, with T again replaced by T*.
The proof of the following theorem is based on the techniques of Section
8.2; it can be found in Broyden, Dennis, and More (1973).
THEOREM 9.3.1 (Broyden-Dennis-More) Let the hypotheses of
Theorem 9.1.2 hold, and assume in addition that 
is pos-
itive definite. Then there exist positive constants , 
such that if
then the positive definite
secant method (BFGS), (9.2.11), is well defined, {xk} remains in D and
converges q-superlinearly to x*. The same is true if (9.2.l1c) is replaced
by the inverse positive definite secant (DFP) update,
This convergence result for the positive definite secant method is no
stronger than Theorem 9.1.2, the convergence result for the symmetric secant
method. However, the positive definite secant method often performs sig-
nificantly better in practice, as we reiterate in Example 9.3.2 below. In this
example, we also examine the convergence of the sequence of Hessian
approximations {Hk} to the Hessian at the minimizer, 
. We see, at
intermediate steps in the example, that the approximations generated by the
positive definite secant update are more accurate than those generated by the
symmetric secant update. This behavior, which is common in practice, par-
tially explains the superiority of the positive definite secant method.
Another advantage of the positive definite secant method is related to the
derivations that began this section. It is an easy exercise to show that the
positive definite and inverse positive definite secant updates are invariant
under linear transformations of the variable space, while the symmetric secant
update is not (Exercise 13). This invariance property, which is shared by
Newton's method but not by the method of steepest descent, allows the associ-
ated computer code to be nearly independent of the scaling of the mini-
mization problem.
EXAMPLE 9.3.2 Let
which has its
minimum at x* = (0, 0)T. In the cases x0 = (1, 1)T and x0 = (— 1, 3)T, the fol-

Secant Methods for Unconstrained Minimization Chap. 9 
207
lowing methods require the indicated number of iterations to achieve
Method
Newton's method
Positive definite secant method,
Symmetric secant method,
Iterations from
x0 = (1, 1)T
6
13
14
x0 = (-l,3)T
11
20
41
When X0 = (— 1, 3)T, the following values of Hk are produced by the two
secant methods at intermediate and final values of xk. The value of 
at the
minimizer is
Values of Hk at the first iteration k for which
Positive Definite
Secant Method
Symmetric
Secant Method
10-1
10-3
10-8
H12 =
H16 =
H19 =
5.485
6.996
6.996
11.78
2.365
2.264
2.264
4.160
2.009
1.993
1.993
4.004
H24 =
H34 =
H40 =
16.86
11.35
11.35
9.645
3.147
3.783
3.783"
6.797
2.003
2.021
2.021
4.143
In Example 9.3.2, the value of the final positive definite secant approxi-
mation agrees with 
to within about 0.5%. This is typical of the beha-
vior of secant updates to the Hessian: the final value of Hk often agrees with
to a few significant digits. In practice, it seems to be less common for a
final Hessian approximation to differ markedly from 
, than for a final
Jacobian approximation to differ markedly from J(x*). One reason is that,
although we saw in Example 8.2.7 that the sequence of secant approximations
to the Jacobian generally fails to converge to J(x *) when F(x) is linear in some
components, the Hessian approximations of this chapter do not share this
problem in the analogous case when 
has some linear components (see
Exercise 14). The difference is due to the symmetry of the Hessian updates. For
more information on this topic, see Schnabel (1982).

208 
Chap. 9 Secant Methods for Unconstrained Minimization
9.4 IMPLEMENTATION OF
QUASI-NEWTON ALGORITHMS
USING THE POSITIVE
DEFINITE SECANT UPDATE
In this section we discuss the incorporation of secant updates into our quasi-
Newton algorithms for unconstrained minimization. Since the most successful
secant approximation for minimization has been the positive definite secant
update (BFGS), it is the secant approximation provided in the algorithms in
the appendix. We provide both the unfactored and factored forms of the
update, in Algorithms A9.4.1 and A9.4.2, respectively. The unfactored algo-
rithm simply implements the rank-two update formula (9.2.10). After the
update one calls the model Hessian routine to obtain a Cholesky factorization
of the Hessian approximation. The factored algorithm implements the update
as it was derived in Section 9.2. It calculates the rank-one update J + to Lc
[equations (9.2.6, 9.2.9)] and then calls Algorithm A3.4.1 to calculate the lower
triangular L+ = J + Q + . Since 
is the Cholesky factorization of the new
Hessian approximation, the model Hessian routine is omitted in the factored
form of the update.
The main advantage of the factored update is that the total cost of
updating the Hessian approximation and obtaining its Cholesky factorization
is 0(n2}, whereas using the unfactored update it is O(n3). The disadvantage is
that it is more work to code and debug, especially if one already has coded the
model Hessian routine. Also, it is difficult to interface the factored update with
the hook step, since this step needs Hc explicitly, and also because normally it
may overwrite Lc with the Cholesky factor of Hc + acI. Therefore, we recom-
mend the factored update for production codes using a line search or dogleg,
but not for the hook step. For class projects or preliminary research work, the
unfactored form may be preferred in all cases. When using the factored update,
one could estimate the condition number of Lc using Algorithm A3.3.1, and if
the estimate is greater than (macheps)-1/2, reform 
, use Algorithm
A5.5.1 to augment Hc by a scaled multiple of the identity, and reset Lc to the
Cholesky factor of this augmented Hessian. For simplicity, we have omitted
this feature from the algorithms in the appendix.
The only additional feature of either update algorithm is that the update
is skipped in two cases. First, it is omitted if 
, since H + would not be
positive definite. In fact, we skip the update if
In a line-search algorithm, this condition can virtually always be prevented
by using line-search Algorithm A6.3.1 mod, which implements
; in a trust region algorithm, (9.4.1) may occur. Second, if yc is
sufficiently close to Hc sc, there is no need to update. We skip the update if the

Secant Methods for Unconstrained Minimization 
Chap. 9 
209
magnitude of each component of yc — Hc sc is less than the expected noise
level in that component.
We must also discuss the choice of the initial Hessian approximation H0.
In contrast to the practice in solving systems of nonlinear equations, it is not
usual to set H0 to a finite-difference approximation to 
. One reason is
the cost of this approximation in function or gradient evaluations. Another is
that secant methods for minimization are predicated on starting with and
maintaining a positive-definite Hessian approximation, and so H0 must be
positive definite. However, there is no guarantee that 
will be positive
definite. If not, it could be perturbed into a positive-definite matrix using the
techniques of Section 5.5, but then it is questionable whether the cost of the
finite-difference approximation was justified.
Instead, it is common to start secant algorithms for minimization with
H0 = I. This H0 is certainly positive definite, and it results in the first step
being in the steepest-descent direction. Following the discussion of scaling in
Section 7.1, the reader can guess that we generalize this choice to
which causes the first step to be in the scaled steepest-descent direction.
The one problem with setting H0 = I, or 
is that it doesn't consider the
scale of f(x). For this reason, || H0 || may differ from 
by many
orders of magnitude, which can cause the algorithm to require an excessive
number of iterations. Various strategies have been proposed to overcome this
problem; Shanno and Phua (1978a) use a special case of a more general idea
of Oren (1974), premultiplying H0 by 
immediately prior to
the first update. This causes 
to obey 
, a weakened
form of the secant equation. If /(x) is quadratic, it guarantees that the range of
eigenvalues of H0 and 
overlap, and in general it causes the magnitude
of the diagonal elements of H0 to more closely resemble those of 
. After
this premultiplication, the normal updates are performed. Computational ex-
perience indicates that this modification may improve the performance of
secant algorithms for minimization.
Because there are some small problems involved in using Shanno and
Phua's modification in our modular system of algorithms, we use an alternate
modification. We simply set
where typ f is the user-supplied typical size of f(x). This formula has the
obvious drawback that it is sensitive to adding a constant to f(x). However, in
experiments by Frank and Schnabel (1982) it was the most successful among
various strategies, including Shanno and Phua's. Our algorithms for calculat-
ing H0 are A9.4.3 for the unfactored case and A9.4.4 for the factored case.
Owing to the modular structure, the user can also set H0 to a finite-difference
approximation to 
.
Example 9.4.1 uses the positive definite secant method to solve again the
problem from Example 9.2.2, this time using H0 = I and 
. The

210 
Chap. 9 Secant Methods for Unconstrained Minimization
performance using 
is slightly better than with
whereas using H0 = I it is much worse. Example 9.4.2 shows the effect of using
instead of 
on the problem from Example 9.3.2.
When the positive definite secant update is used in place of the analytic
or finite-difference Hessian in our minimization algorithms, there are no other
changes besides the ones we have mentioned in this section.
EXAMPLE 
9.4.1 Let
which
has the minimizer x* = (2, — 1)T. The following number of iterations are re-
quired by the positive definite secant method (9.2.11) to achieve
, using the specified values of H0:
H0
Iterations
10
8
24
/
EXAMPLE 
9.4.2 Let
which has its
minimum at x* = (0, 0)T. Starting from x0 = (1, l)T and x0 = (— 1, 3)T, the
indicated number of iterations are required by the positive definite secant
method (9.2.11) to achieve 
, using the following values of
H0:
HO
Iterations from x0 = (1, l)T
Iterations from x0 = (— 1, 3)T
13
11
20
18
If H0 = I, the full secant step from x0,
causes f ( x ) to in-
crease.
9.5 ANOTHER CONVERGENCE
RESULT FOR THE POSITIVE
DEFINITE SECANT METHOD
Powell (1976) has proven a strong convergence result for the positive definite
secant method, in the case when it is applied to a strictly convex function and
used in conjunction with a line search that obeys the conditions given in
Subsection 6.3.1. This result is given below. Since a line search is included, this
theorem is to some extent a global convergence result for the positive definite
secant method. It has another attractive feature in that it makes no assump-

Secant Methods for Unconstrained Minimization 
Chap. 9 
211
tions about the initial Hessian approximation H0, except that it be positive
definite.
We do not give the proof of Theorem 9.5.1 because it provides little
insight, but the interested student is encouraged to study it further. To deepen
the challenge, we mention that it is not known whether the results of this
theorem hold for the DFP method.
THEOREM 9.5.1 [Powell (1976)] 
Let the hypotheses of Theorem 9.3.1
hold and, in addition, let 
be positive definite for every x. Let
and H0 be any positive definite symmetric matrix. Let the se-
quence {xk} be defined by
where 
is chosen to satisfy (6.3.3, 6.3.4), 
is used whenever it is a
permissible value, and Hk + l is defined by (9.2.l1b, c). Then the sequences
{ x k } and [Hk] are well defined, and {xk} converges q-superlinearly to x*.
9.6 OTHER SECANT UPDATES FOR
UNCONSTRAINED MINIMIZATION
Many secant updates for minimization have been proposed besides those we
have mentioned in this chapter. None of them seem to be superior to the
positive definite secant update for general-purpose use. In this section we
briefly mention some of these other updates, largely for reasons of historical
interest.
So far, all our secant updates for minimization have been symmetric
rank-two changes to Hc that obey the secant equation H+sc = yc. It is an easy
exercise to show that there is one symmetric rank-one change to Hc that obeys
the secant equation, the symmetric rank-one (SRI) update
The fatal flaw of this update is that it does not necessarily produce a positive
definite H + when Hc is positive definite and 
, and in fact the denomi-
nator is sometimes zero when the positive definite update is well behaved.
Broyden (1970) was the first to consider the continuous class of updates,

212 
Chap. 9 Secant Methods for Unconstrained Minimization
that includes the DFP update when 
, the positive definite secant update
(BFGS) when 
, and the SRI update when
For any 
, 
is a symmetric rank-two matrix whose row and
column spaces are both spanned by yc and Hc sc. There have been consider-
able theoretical investigations into this class of updates and some gener-
alizations of it; they are discussed extensively in Fletcher (1980). However,
these investigations have not produced an update that is superior to the BFGS
in practice.
It is interesting that all the members of (9.6.2) for which 
has
one negative and one positive eigenvalue can equivalently be represented as
where vc is a linear combination of yc and Hcsc [see Schnabel (1977) or
Exercise 22]. In particular, the positive definite secant update (BFGS) corre-
sponds to the choice
where 
. Thus, the positive definite secant update can be
derived from the weighted norm or scaling derivation of Section 9.3 by setting
TTT to the appropriate convex combination of Hc and H + .
Another class of secant updates for minimization that have received
considerable attention are the "projected and optimally conditioned" updates
of Davidon (1975) [see also Schnabel (1977)]. Interesting theoretical properties
can also be proven about methods that use these updates, but in compu-
tational tests [see, e.g., Shanno and Phua (1978b)], they have not performed
better than the BFGS.
9.7 EXERCISES
1. Give several reasons why a secant approximation to the Hessian should be sym-
metric.
2. Show that the problem
is solved by
3. Let H + be the symmetric secant update (9.1.3). Confirm that H + sc = yc, and that
H + — Hc is a symmetric matrix of rank at most two.

Secant Methods for Unconstrained Minimization 
Chap. 9 
213
4. Prove Theorem 9.1.1. [Hint: Use the techniques of the proof of Theorem 8.1.1 to
show that if H + is given by (9.1.3) and 
satisfies H — Hc symmetric and
Hsc = yc, then (H - Hc)sc = (H + - Hc)sc and 
for
any t satisfying tTsc = 0. Then use Exercise 11 of Chapter 3 to complete the proof.]
Exercises 5 and 6 indicate the proof of Theorem 9.1.2. They are taken from Broyden,
Dennis, and More (1973).
5. Let H+ be given by (9.1.3), 
, 
. Using the assump-
tions of Theorem 9.1.2 and the identity
show that H + obeys
the analogous equation to (8.2.3). Use (9.7.2) and the techniques from the linear
convergence proof for the secant method (Theorem 8.2.2) to prove the local q-
linear convergence of the symmetric secant method.
6. Use (9.7.1) to derive a stronger form of (9.7.2),
where Ec = Hc — H*. Use (9.7.3) and the techniques from the superliner conver-
gence proof for the secant method to prove the local q-superlinear convergence of
the symmetric secant method.
7. Prove that 
is positive definite and symmetric if and only if H = JJT for
some nonsingular 
8. Show that if J+ is given by (9.2.6, 9.2.9) and 
, then 
is given
by (9.2.10), independent of the sign in (9.2.9).
9. Suppose Hc sc = yc. What is the value of J + given by (9.2.6, 9.2.9)? What if the sign
on the right side of (9.2.9) is changed from plus to minus? How does this justify the
choice of sign in (9.2.9)?
10. Let J+ be given by (9.2.12), H+ = J+ JT
+ , 
. Show that (9.2.12) yields
Then show that (9.7.4) is the inverse of (9.2.13).
11. Show, under the assumptions following equation (9.3.1), that (9.3.1) and (9.3.2) are
equivalent.
12. Work through the proof of Theorem 9.3.1 with the help of Broyden, Dennis, and
More (1973).

214 
Chap. 9 Secant Methods for Unconstrained Minimization
13. (a) Show that the positive definite secant update is invariant under linear trans-
formations of the variable space (as discussed in Section 9.3) and that the
symmetric secant update is not.
(b) Derive a nonsymmetric rank-one update that is invariant under linear trans-
formations of the variable space.
14. (a) 
Let
which has the minimizer x* = (0,0)T, and
Show that if x0 = (1, — l)T and 
, then the positive definite secant
method generates a sequence of Hessian approximations {Hk} obeying
and the symmetric secant method generates the identical sequence of iterates
{xk}, but a sequence of Hessian approximations {Hk} obeying
{Hint: Generalize the techniques of the proof of Lemma 8.2.7]
(b) Generalize part (a) to any problem where V/(x) is linear in some of its compo-
nents 
, and 
is zero in all of those components.
(c) 
Determine experimentally how parts (a) and (b) are changed if 
is not
zero in the linear components of V/(x).
15. Let
which has the minimizer x* = (0, 0)T, and
Show that if x0 = (0, — l)T and H0 = I, then the positive definite secant method
and the symmetric secant method produce identical sequences of points {xk} and of
Hessian approximations {Hk}, and that
16. Program a minimization algorithm from Appendix A that uses the positive definite
secant update. Run your algorithm on some of the test problems from Appendix B.
Then replace the secant update in your algorithm by a finite-difference Hessian
approximation (leaving the rest of the algorithm unchanged) and rerun your algo-
rithm on the same problems. How do the numbers of iterations required by the
two methods to solve the same problems compare? How do the numbers of

Secant Methods for Unconstrained Minimization Chap. 9 
215
function and gradient evaluations compare? (Remember to count the function or
gradient evaluations that you use in the finite-difference Hessian approximation.)
How do the run times compare?
17. Program a minimization algorithm from Appendix A that uses the positive definite
secant update and the modified line search. Run your algorithm on some test
problems from Appendix B.
(a) 
How often is the modification to the line search necessary; i.e., how often does
the point x + returned by the regular line search fail to satisfy
(b) 
How close is the final value of Hk to 
on your test problems? Try to
find cases when there is a large discrepancy.
18. Let 
f: 
be a positive definite quadratic with Hessian 
, xc and x +
any two distinct points in Rn, s = x+ — xc, 
. Show that the
range of eigenvalues of H includes the eigenvalue of (sT y/srs)I.
19. What is the secant step 
for the problems of Example 9.4.2 if
If H0 = I? Comment on the comparison.
20. Show that H+ given by (9.6.1) is the unique matrix for which H + sc = yc and
(H + — Hc) is a symmetric matrix of rank one.
21. Confirm that the SRI update (9.6.1) is the choice 
in
(9.6.2).
22. (a) 
Show that if 
, where a is either solution to
then (9.6.3) is identical to (9.6.2).
(b) 
Use (9.7.5) to show that the positive definite secant update [ 
in (9.6.2)] is
equivalent to (9.6.3) with vc given by (9.6.4)

This page intentionally left blank 

A final program note
We have now finished the basic material of this book—methods for
solving small-to-medium-size unconstrained optimization or nonlinear
equations problems with no special structure. In the final two chapters
we discuss extensions of these methods to problems with significant
special structure. An important example is parameter estimation by
nonlinear least squares, a special case of unconstrained minimization
that is the topic of Chapter 10. In Chapter 11 we discuss the more
general class of problems where part of the derivative matrix is read-
ily available while another portion is not. Included in this category are
problems where the derivative matrix is sparse. We discuss sparse
problems briefly and then give a derivation and convergence analy-
sis of least-change secant methods for any problem from this general
class.
217

10
Nonlinear Least Squares
In this chapter we discuss the solution of the nonlinear least-squares problem
that we introduced in Chapter 1. This problem is very closely related to the
unconstrained minimization and nonlinear equations problems we have dis-
cussed already in this book, and our treatment will consist largely of an
application of the techniques we have presented. Section 10.1 reintroduces the
nonlinear least-squares problem and discusses the derivatives that will be
important to us. In Sections 10.2 and 10.3 we explore two different approaches
for nonlinear least-squares algorithms. The first is most closely related to
solving systems of nonlinear equations, and it leads to the Gauss-Newton and
Levenberg-Marquardt algorithms. The second, closely related to un-
constrained minimization, leads to Newton's method for nonlinear least
squares as well as the successful secant methods. Of course, the two types of
methods are closely related to each other, and we explore this relationship. In
Section 10.4 we mention briefly some other aspects of nonlinear least squares,
including stopping criteria and the treatment of mixed linear-nonlinear least-
squares problems.
10.1 
THE NONLINEAR LEAST-SQUARES
PROBLEM
The nonlinear least-squares problem is
218

Nonlinear Least Squares Chap. 10 
219
where m > n, the residual Junction
is nonlinear in x, and r i(x) denotes the ith component function of R(x). If R(x)
is linear, ( l 0 . l . l ) is a linear least-squares problem, whose solution was dis-
cussed in Section 3.6. The nonlinear least-squares problem arises most com-
monly from data-fitting applications, where one is attempting to fit the data
(ti, yi), i = I, ..., m, with a model w(x, t) that is nonlinear in x. In this case
r i(x) = m(x, ti) — yi, and the nonlinear least-squares problem consists of
choosing x so that the fit is as close as possible in the sense that the sum of the
squares of the residuals—ri(x)'s—is minimized. Commonly, m is much larger
than n (e.g., n — 5, m = 100). The choice of the sum-of-squares measure for
data fitting is justified by statistical considerations [see, e.g., Bard (1970)]; in
statistical literature, however, the notation for the same problem is
where now 
is the variable of p parameters, f( , x) is the model function, and
there are n data points (xi, 
yi), 
. (Sometimes different
symbols are used in place of 5 and 
.) We will use the numerical analysis
notation ( l 0 . l . l ) to be consistent with the rest of this book.
The nonlinear least-squares problem is extremely closely related to the
problems we have studied in this book. When m = n, it includes as a special
case solving a system of nonlinear equations, and for any value of m, it is just a
special case of unconstrained minimization. The reasons why we do not
recommend that it be solved by general-purpose unconstrained minimization
codes will become clear in this chapter; mainly, one wants to take the special
structure of ( l 0 . l . l ) into consideration. To start doing this, we investigate the
derivatives of R(x), and of 
. An example of a nonlinear least-
squares problem and its derivatives is given at the end of this section.
The first-derivative matrix of R(x) is simply the Jacobian matrix
, where 
. Thus an affine model of R(x) around a point
xc is
MC(x) = R(xc) + j(xc)(x - xc),
the generalization to the case 
of the affine model for systems of nonlin-
ear equations that we have used throughout this book. This model will be the
basis for the methods discussed in Section 10.2, which are related to thinking
of the nonlinear least-squares problem as an overdetermined system of equa-
tions.
We saw in Section 6.5 that the first derivative of

220 
Chap. 10 Nonlinear Least Squares
Similarly, the second derivative is
where
denotes the second-order information in 
. Thus the quadratic model of
f(x) around xc is
the specialization of the Taylor series quadratic model for minimization to
objective functions of form (10.1.1).
From (10.1.2), Newton's method applied to (10.1.1) is
Certainly (10.1.3) would be a fast local method for the nonlinear least-squares
problem, since it is locally y-quadratically convergent under standard assump-
tions. The problem with the full Newton approach is that S(x) is usually either
unavailable or inconvenient to obtain, and it is too expensive to approximate
by finite differences. Although frequently used in practice, a secant approxi-
mation to all of 
is undesirable, because the portion J(x)TJ(x) of
will already be readily available, since J(x) must be calculated analytically or
by finite differences to calculate V/(x). The methods of Section 10.3 will be
related to unconstrained minimization methods, but we will use the structure
of the quadratic model (10.1.2) in solving the nonlinear least-squares problem
when S(x) is not analytically available.
In discussing the various methods for nonlinear least squares, we will
want to distinguish between zero-residual, small-residual, and large-residual
problems. These terms refer to the value of R(x) [or f(x)] at the minimizer x*
of (10.1.1). A problem for which R(x *) = 0 is called a zero-residual problem; in
data-fitting applications this means that the model m(x*, t) fits the data yi,
exactly at each data point. The distinction between small- and large-residual
problems will be clarified in Sections 10.2. It will turn out that the methods of
Section 10.2 perform better on zero- or small-residual problems than on large-
residual problems, while the methods of Section 10.3 are equally effective in all
these cases.
EXAMPLE 10.1.1 Suppose we wish to fit the data (ti, yi), i = 1, ..., 4, with the
model 
, using nonlinear least squares. Then

Nonlinear Least Squares Chap. 10 
221
and the nonlinear least-squares prob-
lem is to minimize
Thus we have
Also
and
Using
and
we have
10.2 
GAUSS-NEWTON-TYPE METHODS
The first class of methods we consider for solving the nonlinear least-squares
problem comes from using the affine model of R(x) around xc,
where
and m > n.
We cannot in general expect to find an x + for which Mc(x + ) = 0, since
this is an overdetermined system of linear equations. However, a logical way
to use (10.2.1) to solve the nonlinear least-squares problem is to choose the
next iterate x+ as the solution to the linear least-squares problem
Let us assume for now that J(xc) has full column rank. Then we saw in Section
3.6 that the solution to (10.2.2) is
Of course, we would not usually compute x+ by (10.2.3); instead we would
solve (10.2.2) using the QR decomposition of J(xc).

222 
Chap. 10 
Nonlinear Least Squares
The iterative method that consists of using (10.2.3) at each iteration is
called the Gauss-Newton method. To get some insight into its behavior close to
a solution x* of (10.1.1), let us compare it to Newton's method for nonlinear
least squares, equation (10.1.3). The two equations differ only in the term S(x),
included by Newton's method in the second-derivative matrix 
J(xc)TJ(xc)
+ S(xc) but omitted by the Gauss-Newton method. Equivalently, the only
difference between the quadratic model mc(x), (10.1.2), from which we derived
Newton's method, and the quadratic model mc(x), (10.2.2), that gives the
Gauss-Newton method, is that the portion S(xc) of 
is omitted from
mc(x). Since Newton's method is locally g-quadratically convergent under stan-
dard assumptions, the reader might guess that the success of the Gauss-
Newton method will depend on whether the omitted term S(xc) is important—
that is, whether it is a large part of 
. This is essen-
tially confirmed by Theorem 10.2.1 and Corollary 10.2.2. They show that if
S(x*) = 0, then the Gauss-Newton method is also q-quadratically convergent.
This occurs when R(x) is linear, or when we have a zero-residual problem. If
S(x*) is small relative to J(x *)
TJ(x *), 
the Gauss-Newton method is locally
q-linearly convergent. However, if S(x *) is too large, the Gauss-Newton
method may not be locally convergent at all. We comment further on these
results following Corollary 10.2.2.
THEOREM 10.2.1 Let R: 
, and let 
be twice
continuously differentiate in an open convex set 
. Assume that
with 
for all 
, and that there exists
D and 
, such that J(x *)
TR(x *.) = 0, 
is the smallest eigenvalue of
J(x *)
TJ(x *), and
for all 
. If 
, then for any 
, there exists 
such
that for all 
, the sequence generated by the Gauss-Newton
method
xk+1 = xk - 
(J(x k)
TJ(x k))
- 1J(x k)
TR(x k)
is well defined, converges to x*, and obeys
and
Proof. 
The proof is by induction. We may assume that 
, since
the conclusions of the theorem apply only in this case. Let c be a fixed

Nonlinear Least Squares Chap. 10 
223
constant in (1, 
), let us abbreviate J(x0), R(x0), and R(x*.) by J0, 
R0,
and R*, respectively, and let || • || denote the vector or matrix 12 norm.
By a now familiar argument, there exists 
such that 
is non-
singular and
Let
Then at the first step, x1 is well defined and
By Lemma 4.1.12,
From (10.2.4), recalling that
Combining (10.2.9), (10.2.7), (10.2.10), and (10.2.11) and
gives
which proves (10.2.5) in the case k = 0. From (10.2.8) and the above,
which proves (10.2.6) in the case k = 0. The induction step now proceeds
identically.

224 
Chap. 10 
Nonlinear Least Squares
COROLLARY 10.2.2 Let the assumptions of Theorem 10.2.1 be satisfied.
If R(x *) = 0, then there exists 
such that for all 
, the
sequence {xk} generated by the Gauss-Newton method is well defined
and converges q-quadratically to x*.
Proof. 
If R(x *) = 0, a can be chosen equal to zero in (10.2.4). Therefore
from (10.2.6), {xk} converges to x*, and from (10.2.5) the rate of conver-
gence is q-quadratic.
Theorem 10.2.1 shows why the Gauss-Newton method is less satisfactory
than most of the local methods we have studied earlier in this book, because
on many problems with J ( x * )
T J ( x * ) nonsingular it is not quickly locally con-
vergent, and on some of these it is not locally convergent at all. The constant
in (10.2.4) plays a crucial role in the convergence proof and deserves further
examination.
It is convenient to view a as denoting || S(x*) ||2, since for x sufficiently
close to x*, it is an exercise to show that
From this interpretation or from (10.2.4), a is a combined absolute measure of
the nonlinearity and residual size of the problem; if R(x) is linear or R(x*) = 0,
it is immediate from (10.2.4) that a = 0. The ratio 
, which must be less than
1 to guarantee convergence, can be viewed as a combined relative measure of
the nonlinearity and residual size of the problem. Thus Theorem 10.2.1 says
that the speed of convergence of the Gauss-Newton method decreases as the
relative nonlinearity or relative residual size of the problem increases; if either
of these is too large, the method may not converge at all. Alternatively, it
indicates that the larger S(x *) is in comparison to J(x *)
TJ(x *), 
the worse the
Gauss-Newton method is likely to perform.
Even though the Gauss-Newton method has several problems, it is the
basis of some important and successful practical methods for nonlinear least
squares. In Table 10.2.3 we summarize the advantages of the Gauss-Newton
method that we will want to retain and the disadvantages that we will want to
overcome. Examples 10.2.4 and 10.2.5 show the behavior of the Gauss-Newton
method on a simple, one-variable problem.
In Example 10.2.4 we examine the behavior of the Gauss-Newton
method in fitting the model e'x = y to the (t, y) data (1, 2), (2, 4), (3, y3) for
various values of y3. When y3 = 8, the model fits the data exactly with x* =
In 2 
0.69315, and the Gauss-Newton method is quadratically convergent. As
y3 becomes smaller, the optimal value x* becomes smaller, the residual at the
solution R(x*) becomes larger, and the performance of the Gauss-Newton
method deteriorates. In the cases y3 = 3 and y3 = — 1, the Gauss-Newton

Nonlinear Least Squares Chap. 10 
225
Table 10.2.3 Advantages and disadvantages of the Gauss-Newton
method
Advantages
1. Locally q-quadratically convergent on zero-residual problems.
2. Quickly locally q-linearly convergent on problems that aren't too nonlinear and
have reasonably small residuals.
3. Solves linear least-squares problems in one iteration.
Disadvantages
1. Slowly locally q-linearly convergent on problems that are sufficiently nonlinear or
have reasonably large residuals.
2. Not locally convergent on problems that are very nonlinear or have very large
residuals.
3. Not well defined if J(xk) doesn't have full column rank.
4. Not necessarily globally convergent.
method is still linearly convergent, although in the latter case the convergence
is very slow. In the cases y3 = — 4 and y3 = —8, the Gauss-Newton method
does not converge locally.
For comparison, Example 10.2.4 also shows the behavior of Newton's
method for nonlinear least squares, (10.1.3), on all these problems. While the
performance of the Gauss-Newton method is strongly dependent on the re-
sidual size, Newton's method is not, and it does well on all these problems.
For each problem we consider two starting points: x0 = 1, and a value of x0
within 0.1 of x*. The behavior of the algorithms from the closer starting point
gives the best indication of their local convergence properties.
EXAMPLE 
10.2.4 Let 
R: 
, 
ri(x) = etix - yi, i = 1, ..., 4,
where tl = 1, y1 = 2, t2 = 2, y2 = 4, t3 = 3, and let y3 and
x0 have the values shown on p. 226. Then the Gauss-Newton method, (10.2.3),
and Newton's method, (10.1.3), require the following number of iterations to
achieve 
on each of these problems, on a CDC machine with
14+ base-10 digits. The minimizer of f(x), x*, and the residual at the solu-
tion, f(x*), are also shown for each problem.
Example 10.2.5 examines more closely the cases in Example 10.2.4 when
the Gauss-Newton method does not converge.
EXAMPLE 
10.2.5 
Let f(x) be given by Example 10.2.4. If y3 = -4, then
x* = —0.3719287. Let 
, then for 
sufficiently small, the Gauss-
Newton method produces

226 
Chap. 10 Nonlinear Least Squares
Iterations required to
achieve 
by:
y3
8
3
–1
-4
-8
x0
1
0.6
1
0.5
1
0
1
-0.3
1
-0.7
Gauss-
Newton
5
4
12
9
34
32
*
*
*
*
Newton's
method
7
6
9
5
10
4
12
4
12
4
x*
0.69315
0.44005
0.044744
-0.37193
-0.79148
f(x*)
0
1.6390
6.9765
16.435
41.145
* Gauss-Newton method is not locally convergent (see Example 10.2.5).
so that 
. Thus x1 is further than x0 from x*. For
example, if x0 = -0.3719000, then x1 = -0.3719919. If y3 = -8, x* =
-0.7914863, and now for 
with 
sufficiently small, the
Gauss-Newton method produces
so that 
• For example, if x0 = -0.7915000, then
x1 = -0.7913968.
An interesting feature of Example 10.2.5 is that the Gauss-Newton
method takes bad steps by taking steps that are too long, but in the correct
direction. This may make the reader wonder whether the Gauss-Newton step
is always in a descent direction, and indeed this is the case whenever the step is
well defined. The proof is just a generalization of the proof in Section 6.5 that
the Newton step for nonlinear equations is in a descent direction for the
associated minimization problem. If J(xc) has full column rank, so that
J(xc)TJ(xc) is nonsingular and the Gauss-Newton step
is well defined, then J(xc)TJ(xc) is positive definite and
which proves that the Gauss-Newton step is in a descent direction. This sug-

Nonlinear Least Squares 
Chap. 10 
227
gests two ways of improving the Gauss-Newton algorithm: using it with a line
search or with a trust region strategy. These two approaches lead to two
algorithms that are used in practice.
The algorithm that uses the Gauss-Newton method with a line search is
simply
where 
is chosen by the methods of Section 6.3. We will refer to (10.2.12) as
the damped Gauss-Newton method; unfortunately, some references call it the
Gauss-Newton method. Since the damped Gauss-Newton method always
takes descent steps that satisfy the line-search criteria, it is locally convergent
on almost all nonlinear least-squares problems, including large-residual or
very nonlinear problems. In fact, by Theorem 6.3.3 it is usually globally con-
vergent. However, it may still be very slowly convergent on the problems that
the Gauss-Newton method had trouble with. For example, if (10.2.12) is used
on the fourth problem from Example 10.2.4, using a simple halving line search
(i.e., the first satisfactory value of 
in the sequence 
... is used), then
starting from x0 = —0.3, the algorithm still requires 44 iterations, 45 evalu-
ations of J(x) and 89 evaluations of R(x) to achieve 
whereas
Newton's method requires 4 iterations! Also, the damped Gauss-Newton algo-
rithm still is not well defined if J(x c) doesn't have full column rank.
The other modification of the Gauss-Newton algorithm we suggested is
to choose x+ by the trust region approach:
It is an easy corollary of Lemma 6.4.1 to show that the solution to (10.2.13) is
where 
if. 
and 
otherwise. For-
mula (10.2.14) was first suggested by Levenberg (1944) and Marquardt (1963)
and is known as the Levenberg-Marquardt method. Many versions of the
Levenberg-Marquardt method have been coded using various strategies to
choose 
; the implementation of (10.2.14) as a trust region algorithm, where
and 
are chosen by the techniques of Sections 6.4.1 and 6.4.3, is due to
More (1977). (More uses a scaled trust region as described in Section 7.1.) The
step x+ — xc given by (10.2.14) can be calculated more accurately by solving
an equivalent linear least-squares problem (see Exercise 12).
The local convergence properties of the Levenberg-Marquardt method
are similar to those of the Gauss-Newton method and are given in Theorem
10.2.6.

228 
Chap. 10 Nonlinear Least Squares
THEOREM 10.2.6 
Let the conditions of Theorem 10.2.1 be satisfied, and
let the sequence { } of nonnegative real numbers be bounded by b > 0.
If 
, then for any 
, there exists 
such that
for all 
the sequence generated by the Levenberg-
Marquardt method
is well defined and obeys
and
If 
R(x *) = 0 and 
, then {xk} converges q-
quadratically to x*.
Proof. 
A straightforward extension of Theorem 10.2.1 and Corollary
10.2.2. See also Dennis (1977).
Theorem 10.2.5 suggests that a Levenberg-Marquardt algorithm may
still be slowly locally convergent on large residual or very nonlinear problems,
and sometimes this is the case. However, many implementations of this algo-
rithm, particularly the one by More that is contained in MINPACK, have
proven to be very successful in practice, and so this is one of the approaches
that we recommend for the general solution of nonlinear least-squares prob-
lems. Several factors make Levenberg-Marquardt algorithms preferable to
damped Gauss-Newton algorithms on many problems. One is that the
Levenberg-Marquardt method is well defined even when J(xc) doesn't have full
column rank. Another is that when the Gauss-Newton step is much too long,
the Levenberg-Marquardt step is close to being in the steepest-descent direc-
tion — J(xc)TR(xc) and is often superior to the damped Gauss-Newton step.
Several versions of the Levenberg-Marquardt algorithm have been proven
globally convergent—for example, by Powell (1975), Osborne (1976), and
More (1977).
In Section 10.3 we discuss another nonlinear least-squares approach that
is somewhat more robust, but also more complex, than the Levenberg-
Marquardt.
10.3 
FULL NEWTON-TYPE METHODS
The other class of methods we consider for solving the nonlinear least-squares
problem is based on the full Taylor-series quadratic model of f(x) around xc,

Nonlinear Least Squares Chap. 10 
229
(10.1.2). Newton's method for nonlinear least squares consists of choosing x +
to be the critical point of this model,
x+ = xc - (J(xc)TJ(xc) + 
S(x c))
- 1J(x c)
TR(x c).
By Theorem 5.2.1, it is locally q-quadratically convergent to the minimizer x*
of f(x) as long as 
is Lipschitz continuous around
xc, and 
is positive definite. Thus the local convergence properties of
Newton's method for nonlinear least squares are quite superior to those of the
methods of the previous section, since Newton's method is quickly locally
convergent on almost all problems, while the damped Gauss-Newton or
Levenberg-Marquardt methods may be slowly locally convergent if R(x) is
very nonlinear or R(x *) is large.
The reason why Newton's method is rarely used for nonlinear least
squares is that 7(xc)TJ(xc) + S(xc) is rarely available analytically at a reason-
able cost. If J(xc) is not available analytically, it must be approximated by
finite differences in order that 
be known accurately. This
costs n additional evaluations of R(x) per iteration. However, the cost of
approximating 
or S(xc) by finite differences, (n2 + 3n)/2 additional
evaluations of R(x) per iteration for either one, is usually prohibitively
expensive.
A straightforward application of the secant methods of Chapter 9 to
nonlinear least squares is also not desirable, because these methods approxi-
mate all of 
. However, since we have just said that nonlinear least-
squares algorithms always should calculate J(xc) either analytically or by finite
differences, the portion J(xc)TJ(xc) of 
is always readily available, and
we only need to approximate S(xc). Since in addition J(xf)TJ(xc) often is the
dominant portion of 
, secant methods that disregard this information
and approximate all of 
by a secant approximation have not been very
efficient in practice.
Since
another alternative is to approximate each n x n matrix 
by the tech-
niques of Chapter 9. This is unacceptable for a general-purpose algorithm
because it would require the storage of m additional symmetric n x n matrices.
However, it is related to the approach that is used.
The successful secant approach to nonlinear least squares approximates
where Ac is a single secant approximation to S(xc).
We will discuss the approach of Dennis, Gay, and Welsch (1981), but refer-
ences to other approaches can be found in that paper. The determination of Ac
is just an application of the techniques of Chapters 8 and 9. Suppose we have
an approximation Ac to S(xc), have taken a step from xc to x + , and desire an
approximation A+ to S(x + ). The first question is, "What secant equation

230 
Chap. 10 
Nonlinear Least Squares
should A+ obey?" Recall that for minimization, H+ approximated 
,
and the secant equation was 
. Similarly, if we
think temporarily of approximating
by
where each ( H i ) + approximates 
, then each (Hi) + should obey
Combining (10.3.1) and (10.3.2) gives
as the analagous secant equation for A+. Note that while this equation was
derived by considering individual approximations (Hi) + , the result is a single
secant equation for A+, the only additional matrix we will store.
In the one-dimensional case, A+ is completely determined by (10.3.3).
Example 10.3.1 shows how the resulting secant method for nonlinear least
squares performs on the same problems that we considered in Examples 10.2.4
and 10.2.5. Overall, we see that the secant method is only a little slower than
Newton's method and that it can be superior to the Gauss-Newton method on
the medium- and large-residual problems. In particular, it is quickly locally
convergent on the examples for which the Gauss-Newton method did not
converge at all.
EXAMPLE 10.3.1 
Let R(x), f(x), t1, y1, t2, y2, t3, and the choices of y3 and
x0 be given by Example 10.2.4. Then the secant method for one-dimensional
nonlinear least squares,

Nonlinear Least Squares 
Chap. 10 
231
requires the following number of iterations to achieve 
on
each of the following problems on a CDC machine with 14+ base-10 digits.
For comparison, the number of iterations required by Newton's method is
repeated from Example 10.2.4, along with the solution, x*, and the residual at
the solution, f(x*).
Iterations required to
achieve 
by:
>'3
8
3
-1
— 4
-8
x0
1
0.6
1
0.5
1
0
1
-0.3
1
-0.7
Secant
method
6
5
8
4
11
5
13
6
15
8
Newton's
method
7
6
9
5
10
4
12
4
12
4
x*
0.69315
0.44005
0.044744
-0.37193
-0.79148
f(x*)
0
1.6390
6.9765
16.435
41.145
When n > 1, (10.3.3) doesn't completely specify A+, and we complete the
determination of A+ using the techniques of Chapter 9. Since S(x+) is sym-
metric, A+ should be too; however, in general S(x) may not be positive definite
even at the solution x* (see Exercise 15), so we will not require A+ to be
positive definite. We have no other new information about A+, so, as in
Chapter 9, we will choose A+ to be the matrix that is most similar to Ac
among the set of permissible approximants, by selecting the A + that solves the
least-change problem
Here se = x+ - xc, 
is defined by (10.3.3), and 
is nonsingular. If
we choose the same weighting matrix T as produced the DFP update, i.e., any
T for which
then it is an easy extension of the techniques of Section 9.3 to show that

232 
Chap. 10 Nonlinear Least Squares
(10.3.5) is solved by
Update (10.3.6) was proposed by Dennis, Gay, and Welsch (1981) and is
used to approximate S(x) in their nonlinear least-squares code NL2SOL. As
the reader might suspect, the resulting secant method for nonlinear least
squares, which uses iteration formula (10.3.4) and updates Ak by (10.3.6), is
locally q-superlinearly convergent under standard assumptions on f(x) and
A0. This result is given by Dennis and Walker (1981) and is a special case of
Theorem 11.4.2.
The NL2SOL code that implements the secant method we have just
described has several additional interesting features. To make the algorithm
globally convergent, a model-trust region strategy is used; at each iteration the
problem
is solved for sc, so that
for some 
. (Again, a scaled trust region is actually used.) Second, the
algorithm sometimes uses the Gauss-Newton model (10.2.2) that doesn't in-
clude Ac instead of the augmented model (10.3.7). Because of the above-
mentioned difficulty in approximating S(x) by finite differences and because
the Gauss-Newton method tends to do well initially, NL2SOL uses the zero
matrix for A0, so that initially the two models are equivalent. Then at the
point in each iteration where the step bound 
is updated to 
by
comparing the actual reduction f(xc) —f(x+ ) to the reduction predicted by
the quadratic model, NL2SOL calculates the reductions predicted by both
quadratic models, regardless of which was used to make the step from xc
to x + . The update of Ac to A+ is always made, but the first trial step from
x+ is calculated using the model whose predicted reduction best matched the
actual reduction from xc to x + . Typically, this adaptive modeling causes
NL2SOL to use Gauss-Newton or Levenberg-Marquardt steps until Ac builds
up useful second-order information, and then to switch to augmented steps
defined by (10.3.7-10.3.8). For easy problems with small final residuals, conver-
gence sometimes is obtained using only Gauss-Newton steps.
Finally, before each update (10.3.6) in NL2SOL, Ac is multiplied by the

Nonlinear Least Squares 
Chap. 10 
233
"sizing" factor
which is almost the same as the factor of Shanno and Phua mentioned in
Section 9.4. The reason this sizing is necessary at each iteration is that the
scalar components ri(x) of
sometimes change more quickly than the second-derivative components
and the update (10.3.6) may not reflect these scalar changes quickly
enough. This is particularly true if R(x *) is quite small. The sizing factor
(10.3.9) tries to account for a reduction from || R(xc) ||2 to || R(x + ) ||2, so that
the approximation A + is more accurate in the small- or zero-residual case. For
further details about the NL2SOL algorithm, see Dennis, Gay, and Welsch
(1981).
In practice, the comparison between a good Levenberg-Marquardt code
(e.g., More's in MINPACK) and a good secant code for nonlinear least
squares (e.g., NL2SOL) seems to be close. On small-residual problems that are
not very nonlinear, there usually isn't much difference between the two. On
large-residual or very nonlinear problems, a secant code often requires fewer
iterations and function evaluations. This is especially true if the solution x* is
required to high accuracy, since then the difference between slow linear con-
vergence and q-superlinear convergence becomes important. On the other
hand, a Levenberg-Marquardt code such as More's requires fewer lines of code
and is less complex than a secant code with all the features described above.
For these reasons, we recommend either for general-purpose use.
10.4 
OTHER CONSIDERATIONS IN
SOLVING NONLINEAR LEAST-
SQUARES PROBLEMS
In this section we discuss briefly several other topics related to nonlinear least
squares and refer the interested reader to more complete references. The first
topic is stopping criteria for nonlinear least squares, which differ in several
interesting ways from the criteria discussed in Section 7.2 for general un-
constrained minimization problems. First, since the smallest possible value of
is zero, the test
is an appropriate convergence criterion for zero-residual problems. This is
implemented as 
tol1 
where the tolerance tol1 is appropriately chosen.

234 
Chap. 10 Nonlinear Least Squares
Second, the gradient convergence test for nonlinear least squares,
has a special meaning due to the structure of 
, since it can be interpreted
as asking whether R(x + ) is nearly orthogonal to the linear subspace spanned
by the columns of J(x + ). It is an exercise to show that the cosine of the
angle 
between R(x + ) and this subspace is
where 
and 
. If 
is available, as it will
be in a damped Gauss-Newton or Levenberg-Marquardt code, then the test
may be used instead of (10.4.1). Other stopping criteria, such as
(x+ — xc) 
0, are the same as for unconstrained minimization. In addition,
stopping criteria with statistical significance are sometimes used in data-fitting
applications; a common one closely related to (10.4.2) is discussed in Exercise
18 and Pratt (1977). A discussion of stopping criteria for nonlinear least
squares is given by Dennis, Gay, and Welsch (1981).
A second important topic is the solution of mixed linear-nonlinear least-
squares problems, those problems where the residual function R(x) is linear in
some variables and nonlinear in others. A typical example is
Here xl and x2 are the linear variables while x3 and x4 are the nonlinear
variables. It would seem that we should be able to minimize f(x) by solving a
nonlinear least-squares problem in just the two nonlinear variables x3 and x4,
since, given any values of x3 and x4, we can calculate the corresponding
optimal values of xl and x2 by solving a linear least-squares problem. This is
indeed the case; the somewhat difficult analysis required to produce the
algorithm was performed by Golub and Pereyra (1973) and is sketched in
Exercises 19 and 20. Several computer codes are available that solve mixed
linear-nonlinear least-squares problems 
in this manner, including the
VARPRO algorithm of Kaufman (1975). Their advantages are that they usu-
ally solve these problems in less time and fewer function evaluations than
standard nonlinear least-squares codes, and that no starting estimate of the
linear variables is required.
Many interesting considerations related to the solution of data-fitting
problems by nonlinear least squares are mainly outside the scope of this book.
One is the estimation of the uncertainty in the answers. In linear least-squares
problems 
that come from data fitting, the calculation of the solution is
usually followed 
by the calculation of the vanance-covarianee matrix
where a is an appropriate statistical constant. Under appropriate

Nonlinear Least Squares Chap. 10 
235
statistical assumptions, this matrix gives the variance and covariance of the
answers xi, given the expected uncertainty in the data measurements b.
In nonlinear least squares, several corresponding variance-covariance
matrices are used, namely 
, 
and 
, where
xf is the final estimate of x*, Jf = J(x f) Hf = J(xf)TJ(xf) 
+ S(xf) or an ap-
proximation to it, and a = 2f(x)/(m — n) is the analogous constant to the
linear case [see, e.g., Bard (1970)]. While a proper discussion of the variance-
covariance matrix is beyond the scope of this book, it is important to warn
users of nonlinear least-squares software that variance-covariance estimates for
nonlinear least squares are not nearly as reliable as for linear least squares and
should be used with caution. Considerable research has gone into improving
this situation; see, e.g., Bates and Watts (1980).
Finally, as we mentioned in Section 1.2, many other measures of the size
of the vector R(x) besides least squares can be used for defining what is meant
by a "close fit," and some of these are becoming increasingly important in
practice. In fact, we can view nonlinear least squares as just the special case of
minimize f(x) = p(R(x)), 
R: Rn —> Rm, p: Rm —> R, 
(10.4.3)
xe Kn
where 
. Other obvious possibilities are 
and p(z) =
, referred to as l1 and minimax data fitting, respectively. [See, e.g.,
Murray and Overton (1980, 1981) and Bartels and Conn (1982).] When bad
data points ("outliers") are present, one sometimes becomes interested in other
measures p(z) that don't weigh very large components of z as heavily. Two
examples are the Huber (1973) loss function
which is linear in z, for 
, and the Beaton-Tukey (1974) loss function
which is constant for 
in each case, the constant k must be chosen
appropriately. These are examples of "robust" data-fitting measures and a

236 
Chap. 10 Nonlinear Least Squares
good reference is Huber (1981). In Chapter 11 we will refer briefly to some
issues involved in the minimization of a twice continuously differentiable func-
tion of form (10.4.3).
10.5 
EXERCISES
1. Let R(x): R4 —> R20, ri(x) = x1 + x2e-(ti+x3)2/x4 - Yi, i = 1, ..., 20, f(.x) =
. (This problem was discussed in Section 1.2.) What is
2. Prove that Theorem 10.2.1 remains true if the constant 
in (10.2.6) is
replaced by any other constant between 
and 1.
3. Show that under the assumptions of Theorem 10.2.1 and for x sufficiently close to
x*,
[Hint: Write
and use a Taylor series expansion of 
around x*.]
4. Calculate, by hand or calculator, the first step of the Gauss-Newton method for the
problem of Example 10.2.4 when y3 = 8 and x0 = 1. Also calculate the first step of
Newton's method, and the first two steps of the secant method given in Example
10.3.1.
5. Repeat Exercise 4 in the case
6. Let
. Show that .
Use this to show that if
is Lipschitz continuous
around the minimizer
is nonsmgular, and xc is
sufficiently close to x*, then
In the case n = 1, you should be able to show that
7. Calculate J ( x * )
T J(x*) and S(x*) for the two problems of Example 10.2.5. Then use
(10.5.1) to derive the two constants of repulsion, 2.20 and 6.55, that are given in
that example.
8. Let R(x): R2 —> R4, r,(x) = ex1+tix2 - y, i = 1 
4, 
. Suppose
t1 = -2, t2 = - 1, t3 = 0. t4 = 1, y1, = 0.5, y2 = 1, y3 = 2, y4 = 4. [f(x) = 0 at
.x* = (in 2, In 2).] Calculate one iteration of the Gauss-Newton method and one
iteration of Newton's method starting from x0 = (1, 1)
T. Do the same if the values
of y1 and y4 are changed to 5 and —4, respectively.

Nonlinear Least Squares Chap. 10 
237
9. Program a damped Gauss-Newton algorithm using the line-search algorithm
A6.3.1, and run it on the problems from Example 9.3.2. How do your results
compare with those of Newton's method and the secant method on these prob-
lems?
10. Use Lemma 6.4.1 to show that the solution to (10.2.13) is (10.2.14).
11. Show that for any /u 0, the Levenberg-Marquardt step x + — xc given by (10.2.14)
is a descent direction for the nonlinear least-squares function.
12. Given R e Rm, J e R m x n, show that s = -(JTJ 
+ u I )
- 1 J
T R is the solution to the
linear least-squares problem
13. Prove Theorem 10.2.6, using the techniques of the proofs of Theorem 10.2.1 and
Corollary 10.2.2.
14. Solve the problems of Example 10.3.1 by the secant method for unconstrained
minimization,
Compare your results to those given in Example 10.3.1 for the secant method for
nonlinear least squares.
15. Let f(x) be given by Example 10.2.4, with y3 = 10. Calculate x* (by calculator or
computer) and show that S(x *) < 0.
16. Use the techniques of Section 9.3 to show that if TTTsc = yc, then the solution to
(10.3.5) is (10.3.6).
17. Let R € Rm, J e Rmxn have full column rank. Show that the Euclidean projec-
tion of R onto the linear subspace spanned by the columns of J is 
J(J
TJ)
- 1 JTR.
[Hint: How is this problem related to the linear least-squares problem, minimize
Then show that the cosine of the angle between R and this linear
subspace is given by (10.4.2).
Exercise 18 indicates a statistically based stopping test for nonlinear least squares.
18. (a) Let a e 1R, s e R", M e Unxn. Show that the maximum value of
Assume M positive definite and a > 0.
(b) 
If M is the variance-covariance matrix for nonlinear least squares, then
given by (10.5.2) is proportional to the component of s in the direction v
divided by the uncertainty of the nonlinear least-squares solution in the direc-

238 
Chap. 10 Nonlinear Least Squares
tion v, and so the stopping test
is a statistically meaningful way of measuring whether the step s is small.
Show that if s = -(J TJ) - 
1JTR and M = (J
TJ)
- 1 , then (10.5.3) is equivalent to
Show that a similar expression is true if s- = — H - 1 J T R and M = H - l , where
H e Rnxn is 
or an approximation to it. Relate (10.5.4) to the cosine stopping
test, cos 
tol, 
where cos 
is given by (10.4.2).
Exercises 19 and 20 indicate the mixed linear-nonlinear least-squares algorithm of
Golub and Pereyra (1973).
19. Let R: Rn —>Rm, m > n. Furthermore, let x = (u, v)T, u e R n - p , v E Rp, 0 <
p < n, and let R(x) = N(v)-u - b, where N: Rp —> Rmx(n-p), 
b e Rm. For example,
if 
R: 
(R4 —> R20, 
r i(x) = x1etix3 + x 2 e t i x 4 - yi, then 
u = (x1, 
x2), v =
(x3, x4), row i of N(r) = (e
t i x 3,e
t i x 4), b, = yi,. Let the minimizer of
be .x* = (u *, v*). Prove that u* = N(v *) + b. Furthermore, prove that the problem
"minimize,x E.Rn f(x)" is equivalent to
20. With the help of Golub and Pereyra (1973), develop a damped Gauss-Newton or
Levenberg-Marquardt algorithm for solving (10.5.5). In particular, describe how
the required derivatives are obtained analytically (this is the hardest part), and how
the QR decomposition is used.
21. Modify the algorithms in Appendix A for solving a system of nonlinear equations,
using the locally constrained optimal ("hook") global step and an analytic or
finite-difference Jacobian, to create a Levenberg-Marquardt algorithm for nonlin-
ear least squares. You will not have to make many modifications to the existing
algorithms. Algorithms A5.4.1 (finite-difference Jacobian), A6.5.1 (formation of the
model Jacobian), and A3.2.1-A3.2.2 (QR decomposition and solve) will differ only
in that J has m rather than n rows, and the QR algorithm now calculates a linear
least-squares solution [see Stewart (1973) for the minor changes required]. The
hook-step algorithms are unchanged [however, see More (1977) for a more efficient
linear algebra implementation]. The stopping criteria must be changed as dis-
cussed in Section 10.4; see also More (1977) or Dennis, Gay, and Welsch (1981).
You can test your code on many of the problems in Appendix B, since many of
them are easily recast as nonlinear least-squares problems.

11
Methods for Problems
with Special Structure
This chapter is almost like an appendix to the main material of the book in
that it is concerned with ways to apply the techniques already given to prob-
lems where the Jacobian or Hessian matrix has an important type of structure
that is encountered frequently in practice.
The incorporation of special structure into our quasi-Newton methods is
not new to us. For example, in Chapter 9 we incorporated first hereditary
symmetry, and then hereditary positive definiteness, into the secant update
from Chapter 8. In Chapter 10 we modified our unconstrained minimization
methods to use the special structure of the nonlinear least-squares problem.
Our concern in this chapter is for the case when part of the derivative
matrix is easily and accurately obtained, while another part is not. The most
obvious and probably most important example is when we know that many
entries of the derivative matrix are zero. In this case the Jacobian or Hessian is
said to be sparse. Sections 11.1 and 11.2 discuss the finite-difference Newton
method and secant methods for sparse problems, respectively.
The generalization of Section 11.2 is the case when the Jacobian or
Hessian matrix can be represented as
J(x) = C(x) + A(x)
where C(.x) is obtained accurately by some method, and we wish to use secant
approximations for A(x), a matrix with some special structure. We have al-
ready seen an example of this type of structure in the secant method for
nonlinear least squares in Section 10.3. In Section 11.3 we give several ad-
239

240 
Chap. 11 Methods for Problems with Special Structures
ditional examples of this type of structure and present a general theory that
shows how to construct secant approximations for any problem that fits this
very general form. In Section 11.4 we present a general convergence theory for
any secant method that is derived by the techniques of Section 11.3. These
results actually include as special cases all the derivations and convergence
results of Chapters 8 and 9.
11.1 
THE SPARSE FINITE-DIFFERENCE
NEWTON METHOD
In this section we consider the problem of solving a system of nonlinear
equations F(x) = 0, where we also know that each single equation depends on
relatively few of the unknowns. In other words, the ith row of the derivative
matrix has very few nonzero elements, and their positions are independent of
the particular value of .x. We could consider just ignoring these zeros and
trying to solve the problem with the methods of Chapters 5 through 9. For
many problems, however, taking advantage of the zero or sparsity structure of
J(x) is crucial in order that we can even consider solving the problem. In the
first place, n may be so large that storage of J(x) is out of the question unless
we take advantage of not having to store the zeros. Furthermore, the savings
in arithmetic operations achieved by taking advantage of the zeros in solving
for the Newton step can be very significant.
If the nonzero elements of J(x) are readily computed analytically, then
there is not much to say. An efficient storage scheme for J(x) should be used,
along with an efficient sparse linear solver for (11.1.1). Several sparse linear
equations packages are available by now, for example in the Harwell library
or the Yale Sparse Matrix Package available through IMSL. The global strat-
egies of Chapter 6 can be adapted to the sparse problem without much diffi-
culty, except that the multiple linear systems required by the locally con-
strained optimal step make it less attractive.
The remainder of this section is devoted to efficient techniques for ap-
proximating the nonzero elements of J(x) by finite differences when they are
not available analytically. It is based mainly on Curtis, Powell, and Reid
(1974).
The discussion of finite differences in Chapter 4, including the choice of
the step sizes hi, is still valid here. The only change is that we will try to use
fewer than n additional evaluations of F(x) for an approximation of J(x), by
obtaining more than one column of the finite-difference Jacobian from a single
additional value of F(x). To see how this can be done, consider the following
example.

Methods for Problems with Special Structures Chap. 11 
241
Let e- denote the jth unit vector, and
for which
We see immediately that the (1,2) and (2, 1) elements of the Jacobian are zero,
and so the two Jacobian columns have the key property that there is at most
one nonzero in each row. On a hypothetical machine with macheps = 10-6,
the method of Section 5.4 would choose h = (10-3, 10-2)T, evaluate
and then approximate the first and second columns of J(xc) by
The important point is that since we were interested only in Al 1 and A22, only
the first element f1(xc + h1e1) of vl and the second element f2(xc + h2e2) of v2
were required. Furthermore, since f1 doesn't depend on x2 and f2 doesn't
depend on x1, these two values could have been obtained from the single
function evaluation
Then A11 — (wl — fi(xc))/h1, A22 = (w2—f2(xc))/h2, 
and we have approxi-
mated J(xr) with just one evaluation of F(x) in addition to F(xc)
The general case works the same way. First we find a set of column
indices 
1, ..., n] with the property that among this subset of the columns
of the Jacobian, there is at most one nonzero element in each row. Then we
evaluate
and for each nonzero row i of a column j e T, approximate J(xc)ij by
The total number of additional evaluations of F(x) required to approximate

242 
Chap. 11 Methods for Problems with Special Structures
J(xc) is just the number of such index sets 
required to span all the columns.
For example, if J(x) is a tridiagonal matrix
then it is an easy exercise to show that the three index sets {j\ j — k mod 3},
k = 0, 1,2, will suffice for any value of n. Thus only three, rather than n
additional evaluations of F(.x) are required at each iteration to approximate
J(xc).
In general, it is easy to group the columns of a banded matrix into the
smallest number of groups of such index sets, and to generalize the above
tridiagonal example (Exercise 1). Unfortunately, there does not seem to be an
efficient way to get the smallest number of groups for a general sparse Ja-
cobian. Nevertheless, simple heuristic algorithms have proven to be very ef-
fective. Recent work by Coleman and More (1983) has improved upon the
heuristics of Curtis, Powell, and Reid and shown the general problem to be
/VP-complete. Note that if the evaluation of F(x) can be decomposed naturally
into the evaluation of its n component functions, then the above techniques
are unnecessary, since we can simply approximate each nonzero J(xc)ij by
(fi(xc + hjej —fi(xc))/hj. 
However, in practice, if J(xc) isn't analytically avail-
able, then F(xc) is not usually cheaply decomposable in this manner.
These techniques extend to the unconstrained minimization problem,
where the derivative matrix is the Hessian 
. Again, a quasi-Newton
method for large sparse minimization problems should store 
efficiently
and use a symmetric (and positive definite, if applicable) sparse linear solver. If
is approximated by finite differences using function values, then one
simply approximates the nonzero elements using the methods of Section 5.6.
Sometimes in practice, however, 
is analytically available at little ad-
ditional cost when /(x) is calculated. In this case, 
should be approxi-
mated from additional values of V/(x), using a procedure like the above to
make the process efficient. One can simply use the techniques of Curtis,
Powell, and Reid and then average the resultant matrix with its transpose to
get the sparse symmetric Hessian approximation. Recent research by Powell
and Toint (1979) and by Coleman and More (1982) has centered on exploiting
symmetry to obtain this approximation more efficiently (see Exercise 2).
11.2 SPARSE SECANT METHODS
In the previous section we saw how to use sparsity to reduce the number of
funcUon evaluations required to approximate J(x) by finite differences. If F ( x )
is expensive to evaluate, however, (his may still he loo costly, and we may
want to approximate . J ( x ) by secant techniques. We will want these secant

Methods for Problems with Special Structures 
Chap. 11 
243
approximations to be as sparse as the actual Jacobian to achieve the savings in
storage and arithmetic operations mentioned in Section 11.1. In this section we
discuss a sparse secant update that is just the specialization of the secant
update of Chapter 8 to the sparse case. We also discuss briefly sparse sym-
metric secant updates for minimization problems.
Recall that the secant update for nonlinear equations (Broyden's update),
is the solution to the least-change problem
where Ac, A+ e Rnxn approximate J(x c) and J(x + ), respectively, sc = x+ — xc,
and yc = F(x + ) — F(xc) (for convenience, we will drop the subscript c from A,
.s, and y for the remainder of this chapter). In the sparse case, let Z e Rnxn be
the 0-1 matrix denoting the pattern of zeros in J(x)--- i.e.,
and let SP(Z) denote the set of n x n matrices with this zero pattern—i.e.,
If we assume that A e SP(Z), then the natural extension of (11.2.2) to the
sparse case is
Of course, there may be no element of SP(Z) for which Bs = y, as in the case
when a whole row of B is required to be zero but the corresponding compo-
nent of y is not zero. When the sparsity required is consistent with Bs — y,
then the solution to (11.2.4) is easy to find, and is given in Theorem 11.2.1. It
also can be obtained using the more general Theorem 11.3.1.
We require the following additional notation: we define the matrix pro-
jection operator Pz: Rnxn ---> Rnxn by
That is, Pz zeros out the elements of M corresponding to the zero positions of
the sparsity pattern Z, while otherwise leaving M unchanged. It is an exercise
to show that P z ( M ) is the closest matrix in SP(Z) to M in the Frobenius norm.
Similarly for v e U", we define vi E Rn by

244 
Chap. 11 Methods for Problems with Special Structures
That is, vi is the result of imposing on v the sparsity pattern of the ith row
of Z.
THEOREM 11.2.1 
Let Z e Rnxn be a 0-1 matrix, and let SP(Z) be de-
fined by (11.2.3) and Pz by (11.2.5). Let A e SP(Z), s, y e R", and define
si, i = 1, ..., n by (11.2.6). If si = 0 only when yi = 0, then the solution
to (11.2.4) is the sparse secant update
where D+ is defined by (3.6.6) for D e R n x n, a diagonal matrix with
Proof. 
Let Ai Bi e Rn denote the ith rows of A and 5, respectively.
Then since
(11.2.4) can be solved by choosing each Bi to solve
where
It is an easy exercise to show that the solution to (11.2.8) is
Since for any u, v € Rn, row i of Pz(uvT) is (ui)vi, then Bi, given by (11.2.9)
is just the ith row of A+ given by (11.2.7).
EXAMPLE 11.2.2 Let
s = (1, -1, 2)T, y = (2, 1, 3)T, A = I. Then 5, = (1, 0, 2)T, s2 = (1, -1, 0)T,
s3 = (0, - 1, 2)T, and (11.2.7) gives

Methods for Problems with Special Structures Chap. 11 
245
By comparison, Broyden's update (11.2.1) would be
Update (11.2.7) was suggested independently by Schubert (1970) and
Broyden (1971), and Theorem 11.2.1 was proved independently by Reid (1973)
and Marwil (1979). The update seems effective in quasi-Newton algorithms for
sparse nonlinear equations, although there is little published computational
experience. If some si = 0, then (11.2.4) has a solution only if the corresponding
y,•. — 0; however, when J(x) E SP(Z), s = x+ — xc, and y — F(x + ) — F(xc), this
is always the case (Exercise 5). The more general case is addressed by Theorem
11.3.1. Theorem 11.4.1 will show that a quasi-Newton method using update
(11.2.7) on problems with J(x) E SP(Z) is locally g-superlinearly 
convergent
under standard assumptions.
Unfortunately, the adaptation of sparse updating to unconstrained mini-
mization where the approximations must also be symmetric and likely positive
definite has not been as satisfying. Marwil (1978) and Toint (1977, 1978) were
the first to generalize the symmetric secant update to the sparse case, solving
(B — A) symmetric.
We give this update in Section 11.3, and the local g-superlinear convergence of
the quasi-Newton method using it is proven in Section 11.4. However, this
update has several major disadvantages that we mention below, one being that
the approximations generated are not necessarily positive definite. In fact, the
effort to generate positive definite sparse symmetric updates has as yet been
unsuccessful. Shanno (1980) and Toint (1981) have produced a sparse update
that reduces to the BFGS in the nonsparse case, but it doesn't necessarily
preserve positive definiteness in sparse situations.
The fact that none of these sparse symmetric updates preserves positive
definiteness already eliminates a major advantage of secant updates for mini-
mization. In addition, the calculation of any of the known sparse symmetric
updates requires the solution of an additional sparse symmetric system of
linear equations at each iteration. Finally, the limited computational experi-
ence with methods using these updates has not been good. For these reasons,
secant methods may not be a promising technique for large sparse mini-
mization problems.
Instead, it appears likely that large minimization problems will be solved
using either the finite-difference methods of Section 11.1 or conjugate gradient
methods. Conjugate gradient methods are somewhat different from quasi-
Newton methods in their basic structure, and we do not cover them in this

246 
Chap. 11 Methods for Problems with Special Structures
book. For small problems they are usually less efficient than the methods of
this book, but for large problems they are a leading contender. Like secant
methods, they use only function and gradient information in minimizing a
function, but a major difference is that they do not store any approximation to
the second-derivative matrix. For further information, see Buckley (1978),
Shanno (1978), Fletcher (1980), Hestenes (1980) or Gill, Murray, and Wright
(1981). For a straight linear algebra treatment, see Golub and Van Loan
(1983). Truncated Newton methods [see, e.g., Dembo, Eisenstat, and Steihaug
(1982)] combine some features of conjugate gradient methods with the trust
region methods of Chapter 6. Another recent approach is given in the papers
by Griewank and Toint (1982a, b, c).
We conclude our discussion of secant methods for sparse problems by
mentioning an advantage of secant methods for nonsparse problems that does
not carry over to the sparse case. We saw in Chapters 8 and 9 that we could
use secant updates to reduce the arithmetic cost per iteration from 0(n3) to
0(n2) operations, either by updating an approximation to the inverse directly
or by sequencing a QR or LLT factorization. In the sparse case, the first option
is unattractive because the inverse of a sparse matrix is rarely sparse, while the
second is unavailable because the update usually constitutes a rank-n change
to Ac. On the other hand, losing this advantage may not be important in the
sparse case, because the factorization and solution of a sparse linear system
often requires only O(n) operations.
11.3 
DERIVING LEAST-CHANGE
SECANT UPDATES
For the remainder of this chapter we consider problems F: U" —»R" where
the derivative matrix J(x) & F'(x) has the form
and C(x) is readily available while A(x) needs to be approximated using secant
updates. [This includes optimization problems, where F(x) = V/(x) and J(x) =
V2/(x).] In this section we give an extended abstract of the results of Dennis
and Schnabel (1979) for deriving least-change updates in this general frame-
work. We will leave out the lengthy proof of the main theorem and include
only the simplest applications, since the specialist reader can consult the orig-
inal reference.
We have already seen several examples of problem structure (11.3.1). In
the sparse problems considered in Sections 11.1 and 11.2, where the full gener-
ality of this section is not needed, C(x) = 0 and A(x) contains the nonzero
elements of J(x) and must be approximated by matrices having the same
sparsity pattern. Two slight variations are when some of the equations of F(x)
are linear, or when F(x) is linear in some of its variables. An example of the

Methods for Problems with Special Structures Chap. 11 
247
first case is
An example of the second case is
In each case, C(x) is a known constant matrix, while A(x] may need to he
approximated by secant methods.
Another example is UK: nonlinear least-squares problem we saw in
Chapter !0, where C(x) = J(x)T J(x) and
Remember thai J ( x ) is always calculated analytically or by tinite differences in
order to compute 
and so C ( x ) is readily available, but A(x)

248 
Chap. 11 Methods for Problems with Special Structures
is usually approximated by zero or by secant techniques. Even more interest-
ing is the general data-fitting function
that we mentioned in Section 10.4. Here
where the m x n matrix 
. In practice, 
and 
are usually
trivial to obtain and J(x) is evaluated analytically or by finite differences to
calculate V/(x), but obtaining the roughly mn2/2 different second partial de-
rivatives of the residuals is out of the question. Thus we readily have C(x) but
need to approximate A(x).
In all these examples, the secant approximation to A(x) should incorpo-
rate the special structure of the particular matrix being approximated. The
idea we will use in finding an appropriate approximation to A(x + ) at some
iterate x+ is just a logical extension of what we have done so far. We will
decide on a secant condition, say A+ e Q(y*, 5) 
{M e R n x n: Ms = y*}. In
addition, we will choose an affine subspace A defined by properties such as
symmetry or sparsity that all the approximants Ak should have. Then we will
ask A+ to be the nearest matrix in 
to A e A, in an appropriate
norm. That is, A+ will be the "least-change update" to A with the desired
properties.
Let us consider the choices of Q(y*, s), A, and the least-change metric
for some of our examples. We again use 
and 
,
and we remind the reader that the secant equation from Chapter 8, A + s = y,
came from the fact that y = J(x + )s if F(x) is linear and 
otherwise.
Here we will want
For the first example, function (11.3.2), we see that A = {A e R 2* 2:
A i = (0, 0)} and the Frobenius norm seems reasonable as a measure ol
change. The secant condition is also very simple, since
so we take v* = (0,f2(x + ) -f2(xf))T = (0, y2)T
In the second example, function (11.3.3), A = (A e R 3 x 3: A1 = (0, 0,
0)r}, and again the Frobenius norm seems reasonable, but the secant condition
is a bit more interesting. If we can evaluate the messy portion Mess (X1 t x3) of
F(x1, x2, x3) directly, then there is no difficulty, since clearly y* — Mess ((x + )2,
(x+)3) — Mess ((xc)2, (xc)3) is the logical choice. If we cannot separate the
function F in this way, we use instead a general technique that always works

Methods for Problems with Special Structures Chap. 11 
249
and that reduces to the same choice of y* in this case as well as in the first
example.
If the structure of A(x) doesn't suggest to us an inexpensive choice of y*,
then, since we are computing C(x+), we can always default to the secant
equation
which is equivalent to asking our complete Jacobian approximation J+ =
C(x + ) + A+ to satisfy the standard secant equation
The reader can verify that (11.3.5) is equivalent to our choice of y* in the
above two examples.
Our final example, function (11.3.4), is much more interesting because the
default y* is not the same as the y# we obtain by looking directly at A(x+)s.
From (11.3.5), the default y* is
On the other hand, a straightforward generalization of the derivation in equa-
tions (10.3.1-10.3.3) leads us to suggest
which in general is different from (11.3.6). It is satisfying that the latter choice
of y* is a little better in practice.
To complete specifying the secant approximation conditions for function
(11.3.4), we choose A = {A e R
n X n : A = AT}, since A(x) is always symmetric.
We could certainly choose the least-change metric to be the Frobenius norm,
which would reduce our update to the symmetric secant update (9.1.3) if
C(x+) = 0. However, since we are solving a minimization problem, the dis-
cussion of scaling in Section 9.3 is applicable here and leads us to use a
Frobenius norm after scaling by J, where JJ
Ts = y if yTs > 0. This reduces our
update to a DFP update if C(x + ) = 0.
Given a choice of the secant condition A+ e Q(y*, s), the subspace of
approximants A, and the weighted Frobenius norm || • ||, Theorem 11.3.1
produces the update satisfying

250 
Chap. 11 Methods for Problems with Special Structures
if such a B exists. In fact, Theorem 11.3.1 considers the more general case when
A may be empty. In this case, A+ is chosen to be the matrix in A
that is nearest to A among the set of nearest matrices of A to Q(y*, s). For
simplicity, we state the theorem for the unweighted Frobenius norm, but it
remains true for any weighted Frobenius norm. Dennis and Schnabel's proof
uses an iterated projection technique that is the straightforward generalization
of the Powell symmetrization procedure of Section 9.1. The reader can simply
look back at Figure 9.1.1, putting A in place of S and y* in place of yc.
We will need the notion that every affine space A has a unique translate
y, which is a subspace. For any 
is indepen-
dent of A0.
THEOREM 11.3.1 [Dennis and Schnabel (1979)] Let 
and let PA
and Py be the orthogonal projectors into A and y. Let P be the n x n
matrix whose jth column is
and let A e A. If v is any solution to
or equivalently to
then
is the nearest to A of all the nearest matrices of 
to Q(y*, s). If th
minimum is zero, then 
.
Combining (11.3.8) and (11.3.9), we can express our least-change update
as
where P+ denotes the generalized inverse of P (see Section 3.6). Now we will
use (11.3.10) to derive the sparse secant update and the symmetric sparse
secant update that we discussed in Section 11.2.
To derive the sparse secant update using Theorem 11.3.1, we choose

Methods for Problems with Special Structures 
Chap. 11 
251
y# =y,A 
= S = SP(Z) and PA = Ps = Pz given by (11.2.5). Then
so P = (l/sTs) diag
i and (11.3.10) gives
which is equivalent to (11.2.7).
To derive the symmetric sparse update, we choose y* = y, s4 = & =
It is an easy exercise to show that for any M €
Rnxn, PA(M) = Py(M) = 
(M + MT) The reader can then show that in this
instance, the matrix P in Theorem 11.3.1 is given by
so that (11.3.10) gives
It is a further exercise to show that (11.3.12) reduces to the symmetric secant
update (9.1.3) when SP(Z) = R n x n and Pz = I- Notice, however, that in general
the computation of update (11.3.12) requires v, which in turn requires the
solution of a new sparse linear system at each iteration.
Finally, let us give the updates of Theorem 11.3.1 for the three examples
of this section. It is an easy exercise to see that for the first example (11.3.2),
the update is
and for the second (11.3.12), if
We have already indicated in Chapter 10 that for function (11.3.4), the DFP
analog is update (10.3.6), with y# now given by (11.3.7) (see also Exercise 16 of
Chapter 10).
11.4 
ANALYZING LEAST-CHANGE
SECANT METHODS
This section, based on Dennis and Walker (1981), presents two theorems
giving necessary conditions on y* and A for the local convergence of any

252 
Chap. 11 Methods for Problems with Special Structures
secant method that is derived using Theorem 11.3.1. These theorems show that
every least-change secant method we have presented in this book is locally and
g-superlinearly convergent. They also indicate how secant updates for other
problems with special structure should be constructed.
Let us assume below that J(x) and C(x) both satisfy Lipschitz conditions
and that J(x *) is invertible.
It is useful for our purposes to distinguish between two kinds of least-
change secant updates: those, like Broyden's method, which use the same
unsealed or fixed-scale Frobenius norm at every iteration in calculating the
least-change update, and those, like the DFP, which can be thought of as
rescaling the problem anew at every iteration before calculating the update.
We will state a theorem for each of these two types of methods, but for reasons
of brevity we won't discuss methods like the BFGS, which are usually viewed
in the least-change sense as projections of the inverse Hessian approximation.
We will also restrict ourselves here to Frobenius and weighted Frobenius
norms, although the Dennis-Walker paper is more general.
The theorems can be interpreted as saying roughly that least-change
secant update methods are convergent if the space of approximants A is
chosen reasonably and if the secant condition characterized by y* is chosen
properly and that they are superlinearly convergent if in addition A is chosen
properly. Thus, the choice of secant condition is crucial to the convergence of
the method. This fact has been somewhat obscured by the ease with which y*
can be chosen for the traditional problems or even for the more general
problems of Section 11.3. The interaction of A and y* in these cases is
expressed by the always allowed choice
which reduces to the default choice
if A(x) € A for every x, as it always was in Section 11.3.
Theorem 11.4.1 is going to be stated with a rather minimal assumption
on A. It amounts to assuming that there is some A* e A for which the
stationary quasi-Newton iteration
x+ =xc -(C(x *) + A * )
- l F ( x c )
would be locally q-linearly convergent. Surely this is little enough to require of
A, and if A(x *) € A, then A+ A(x *) will certainly satisfy this condition. The
requirement on y# is also pretty minimal; it should be thought of as requiring
that the Frobenius distance from either A(x *) or A(x+ ) to Q(y#, s) decreases
like the maximum of 
and 
, for some p > 0. In other
words, the size of the update to the model should get smaller as the solution

Methods for Problems with Special Structures 
Chap. 11 
253
is approached. As in Section 11.3, the theory includes the case when 
,A
Q(y#, s) is empty. This is an important case for some applications that we
comment on briefly at the end of this section.
We note that 
is used to denote an arbitrary vector and subordinate
matrix norm while 
is still used to denote the Frobenius norm.
THEOREM 11.4.1 
Let the hypotheses of Theorem 5.2.1 hold. Let A S,
Q(y, s), and PA be defined as in Theorem 11.3.1, let 
denote the
Euclidean projector orthogonal to 
and let C:R n—>IR n X n.
Let A+ = P A [ J ( x * )- C(x*)] and B* = C(x*) + A* have the properties
that B* is invertible and that there exists an r*. for which
Assume also that the choice rule y#(s), s = x+ — x, either is the default
choice (11.4.1) or more generally has the property with j/ that there
exists an a > 0, p > 0 such that for any x, x + in a neighborhood ofx^,
one has
for at least one G that is a nearest point in ,A to Q(y*(s), s), where
Under these hypotheses, there exist positive numbers 
such that
if 
and 
, the sequence defined by
given by Theorem 11.3.1 exists and converges to x* at least q-linearly
with
Hence [xk] converges q-superlinearly to x* if and only if
In particular, {xk} converges q-superlinearly to x^ if

254 
Chap. 11 Methods for Problems with Special Structures
The proof of Theorem 11.4.1 is difficult, as the reader might suspect,
since it implies the local qr-superlinear convergence of every fixed-scale secant
method we have discussed in this book. For example, for the sparse secant
method in Section 11.2, A = SP(Z) and C(x) 
0, so we have trivially that
A(x* )= J(x * )- C(x*) = J(x *) E A, and (11.4.2) is true with r* = 0. Fur-
thermore y* = y = F(x + ) - F(x c) is the default choice (11.4.1). Thus, it is a
trivial corollary of Theorem 11.4.1 that the sparse secant method is locally
convergent, and since A(x *) E ,A, is g-superlinearly convergent to x* under
standard assumptions. Virtually the same words suffice to prove the local
g-superlinear convergence of the sparse symmetric secant method from Theo-
rem 11.4.1. Of course, the convergence of the nonsparse secant and symmetric
secant methods of Chapters 8 and 9 are just the special cases where the
sparsity pattern has no zero elements.
All the standard methods of Chapters 8 and 9 use the default choice, and
so the more general and mysterious condition (11.4.3) is not needed. On the
other hand, it is needed in the fixed-scale or rescaled least-squares methods
with y* = J(x + )TF(x + ) — J(x)TF(x + ). Dennis and Walker elaborate on this
question, but we mention that for S = {M: M = MT} it suffices to have
For general ,S, it suffices to have
In fact, we will see an example later for which one can more easily show the
stronger result 
.
The statement of Theorem 11.4.2 on iteratively rescaled least-change
secant methods, differs from the statement of Theorem 11.4.1 on fixed-scale
methods in that the roles of y and y* as functions of s = x + — x must be
clarified. The distinction is simple: the scaling matrices are from Q(y, s) and the
secant matrices are in Q(y*, s). In short, y is trying to look like J(x*)s and y*
is trying to look like A(x*)s.
For an affine space A and symmetric positive definite matrix W, it will
be convenient to have the notation P A.w to denote the orthogonal projection
into A in the inner product norm 
trce 
(W- 
1MW -'M T)] 1 / 2 on
Rnxn. If W = JJT and M is symmetric, then it is useful to think of
.
THEOREM 11.4.2 Let the hypotheses of Theorem 5.2.1 hold. Let ,A, S,
and Q(y, s) be defined as in Theorem 11.3.1, let 
denote the
projector orthogonal to 
in the inner-product norm 
,
and let C: Rn —>[Rnxn. Let J ( x * ) be symmetric and positive definite and
let ,(
S have the property that for any S, y with sTy > 0, the projection

Methods for Problems with Special Structures Chap. 11 
255
Py,w is independent of any particular symmetric positive definite W e
Q(y, s). In addition, let A have the properties that
are such that B* is invertible and there exists an r* with
Also assume that there exist a1, a2, 
0, p > 0, such that the choice rule
y(s) obeys
and the choice rule y*(s) either is the default choice
for W — J ( x * ) or some W E Q(y, s), or has the property with A that for
any x, x+ in a neighborhood of x*,
for every symmetric positive definite W e Q(y, s) and at least one G that
in the W-norm is a nearest point in j/ to Q(y*, s). Under these hypo-
theses, there exist positive constants e, 6 such that if 
and
the sequence defined by
Ak + 1 the least-change secant update with respect to A and 
in a
Wk-norm, Wk E Q(yk, sk), exists and converges at least q-linearly to x*.
Furthermore,
Hence, {xk} converges q-superlinearly to x* if and only if
In particular, {xk} converges g-superlinearly to
The discussion of condition (11.4.3) following Theorem 11.4.1 applies to
condition (11.4.5) as well. Using this, it is an exercise to apply Theorem 11.4.2
to prove the local q-superlinear convergence of the secant method of Dennis,

256 
Chap. 11 Methods for Problems with Special Structures
Gay, and Welsch given in Section 10.3 for solving the nonlinear least-squares
problem. Of course, Theorem 11.4.2 proves the convergence of the DFP
method as well. In general, Theorems 11.4.1-11.4.2 say that if you use the right
kind of approximating space A and know how to choose the correct secant
condition for that class of approximants, then the least-change principle is an
excellent way to choose the secant update.
Finally, some interesting possibilities open up when we drop the require-
ment on A that A(x) e A for every x e Rn. This may occur when we decide to
approximate A(x) by a sequence of matrices that have a simpler structure than
A(x). For example, in a secant version of the nonlinear Jacobi algorithm, the
iteration is
xk+i = xk - Akl F(xk),
where each Ak is diagonal even though J(x) is not diagonal; that is, sJ =
[diagonal 
matrices e U"*"} 
but 
. 
If 
F(x *) = 0 and
(diag 
then Theorem 11.4.1 says that given a proper
choice rule for >'*, the method will still be locally convergent. Theorem 11.4.1
also suggests that we choose 
so that it approximates
if,
and
if si = 0. It is an easy exercise to show that (11.4.4) with
holds for this choice of yi, and so this method is q-linearly convergent under
the proper assumptions.
The important thing to notice in the above example is that the choice of
y* is not the same as the default choice (11.3.5), which would yield y* = y =
F(x + ) — F(x), since C(x*) = 0. In general, the default rule (11.3.5) is unsatis-
factory when A(x *) 
A, 
because it causes 
to approximate A(x*)sk when we
want it to approximate (P A(A(x *)))s k = A *s k. There are other practical exam-
ples where the subspace of approximants A has a simpler structure than
(A(x)}, and in many of these selecting an appropriate choice rule for y* is
particularly difficult (see, for example, Exercise 19). If we could find a simple
idea like the default condition (11.3.5) to choose the y#'s properly, then the
Dennis-Walker theorems would tell us that the methods would be locally
convergent and that the speed of convergence would depend on how near
A(x *) is to stf. This is an area of current research. [See Dennis-Walker (1983).]
11.5 
EXERCISES
1. Let F: Rn—-> Rn, and let J ( x ) = F(x) have the property that J(.Y),, = 0 if
where m < n/2. Using the techniques of Section 11.1, how many evalu-
ations of F(.x) are required to calculate a finite-difference approximation to J(x)'?

Methods for Problems with Special Structures 
Chap. 11 
257
2. [This exercise is taken from Powell and Toint (1979).] Let J(x) e R 5 x 5 have the
nonzero structure
Show that the techniques of Section 11.1 require the full five evaluations of F(x) in
addition to F(xc) to approximate J(x). However, if J(x) is symmetric for all x, show
that J(x) can be approximated using only two additional evaluations of F(x).
3. Let SP(Z) be defined by (11.2.3). Show that the problem
is solved by B = Pz(A), Pz defined by (11.2.5).
4. Using the Cauchy-Schwarz inequality, show that the solution to (11.2.8) is (11.2.9).
5. Let F: Rn —> Rn be continuously differentiate in an open convex region
x, x + e D, s = x+ - x, y = F(x+) - F(x), s, defined by (11.2.6). Prove that if st = 0,
then yt = 0. [Hint: Use equation (4.1.8).]
6. Show by example that the inverse of a sparse matrix may have no zero elements.
For example, consider A e Rnxn defined by
(This matrix arises in calculating cubic splines).
7. Let A e (R
nxn be tridiagonal, symmetric, and positive definite. Construct an algo-
rithm and data structure to solve the linear system Ax = b using 0(n) arithmetic
operations and 0(n) storage. Why is it important that A is positive definite?
8. Calculate 
and 
for the data-fitting functions (10.4.4) and (10.4.5).
Use these to calculate 
and V2/(x) in each case.
9. Show that the values of y* obtained in Section 11.3 for functions (11.3.2) and
(11.3.3) are equivalent to the default choice (11.3.5).
10. Let f(x) be the nonlinear least-squares function, (11.3.4) with p(R(x)) = 
R(x)TR(x).
Show by example that the default choice of y*, (11.3.6), and the choice used in
Section 10.3, (11.3.7), may differ.
11. Work through the proof of Theorem 11.3.1 using Dennis and Schnabel (1979).
Alternatively, see Powell (1981) or Griewank (1982).
12. Let
Show that
13. Using Theorem 11.3.1 and Exercise 12, complete the derivation of the least-change
sparse symmetric secant update. Also, show that P given by (11.3.11) is positive
definite if 
for all i. [See Dennis and Schnabel (1979).]
14. Show that the sparse symmetric secant update (11.3.12) reduces to the symmetric
secant update (9.1.3) when SP(Z) = R n x n so that Pz = /.

258 
Chap. 11 Methods for Problems with Special Structures
15. Using Theorem 11.3.1, derive the least-change updates (11.3.13) and (11.3.14) for
functions (11.3.2) and (11.3.3), respectively.
16. Read Dennis and Walker (1981), and then try to give proofs for Theorems 11.4.1-
11.4.2. (These theorems are slight simplifications of the theorems in the paper.)
17. Use Theorem 11.4.2 to prove the local g-superlinear convergence of the secant
method of Dennis, Gay, and Welsch for nonlinear least squares,
xk+l=xk + (J(xk)TJ(xk) + 
A k)
- lJ(x k)
TR(x k),
where Ak is updated by (10.3.6), y* is given by (10.3.3).
18. Show that the nonlinear Jacobi secant method described in Section 11.4 is q-
linearly convergent. [Hint: Show
19. In an algorithm by Dennis and Marwil (1982), a sparse J(xk) is approximated for a
finite number of iterations by L0Uk, where J(x0) = L0-V0 and Uk e {matrices
with the sparsity pattern of U0}. Then when the algorithm decides that the Ja-
cobian has become too poor, J(xk + l) = L(xk+l)U(xk+l) is recalculated using finite
differences, and the process is restarted. What does Theorem 11.4.1 suggest thaty*
should be for this algorithm? How could you implement this choice? What cri-
terion might you use to decide when to restart? Discuss the incorporation of
pivoting.
20. In an algorithm by Johnson and Austria (1983), the LU factorization is updated to
satisfy LUs = y by updating U and L-1 to satisfy Us — L - l y = 0 a row at a time.
Remember that L-1 is also lower triangular and see if you can derive from this
hint the clever Johnson and Austria update before you read their paper.

Appendix A
?*,*s.&j.i * 
, r jfl**^,*' *" ',,.
A Modular System of Algorithms
for Unconstrained Minimization
and Nonlinear Equations
CONTENTS
PREFACE 262
I. DESCRIPTION 264
1. Purpose of the modular system of algorithms 264
2. Organization of the modular system of algorithms 266
3. Organization of the individual modules 267
4. Input and output 270
5. Modules for basic algebraic operations 271
II. DRIVER MODULES AND GUIDELINES FOR
UNCONSTRAINED MINIMIZATION 272
1. Algorithm D6.1.1 (UMDRIVER)—Driver for a modular system of algo-
rithms for unconstrained minimization 272
2. List of modules for unconstrained minimization 276
3. Guideline 1—Choosing algorithmic options for unconstrained mini-
mization 277
4. Guideline 2—Choosing tolerances for unconstrained minimization 275
5. Guideline 
3—Storage 
considerations 
for 
unconstrained 
mini-
mization 280
* by Robert B. Schnabel
259

260 
Appendix A
6. Algorithm D6.1.2 (UMEXAMPLE)—Driver for an unconstrained mini-
mization algorithm using line search, finite difference gradients, and
factored secant approximations to the Hessian 283
III. DRIVER MODULES AND GUIDELINES FOR
NONLINEAR EQUATIONS 255
1. Algorithm D6.1.3 (NEDRIVER)—Driver for a modular system of algo-
rithms for nonlinear equations 285
2. List of modules for nonlinear equations 289
3. Guideline 4—Choosing algorithmic options for nonlinear equa-
tions 290
4. Guideline 5—Choosing tolerances for nonlinear equations 297
5. Guideline 6—Storage considerations for nonlinear equations 292
6. Algorithm D6.1.4 (NEEXAMPLE)—Driver for a nonlinear equations
algorithm using dogleg and 
finite difference Jacobian approxi-
mation 294
IV. INDIVIDUAL MODULES 296
(U) = used for unconstrained minimization only
(N) = used for nonlinear equations only
1. Modules supplied by the user (requirements) 296
(U) 
FN—Routine for evaluating unconstrained minimization objective
function/(x) 296
(U) 
GRAD—Routine for evaluating gradient vector 
(optional) 296
(U) 
HESS—Routine for evaluating Hessian matrix 
(optional) 297
(N) 
FVEC—Routine for evaluating nonlinear equations function F(x) 298
(N) 
JAC—Routine for evaluating Jacobian matrix J(x) (optional) 298
2. Modules supplied by the implementor (partial description) 299
(U) 
UMINCK—Checking 
input parameters and tolerances for un-
constrained minimization 299
(N) 
NEINCK—Checking input parameters and tolerances for nonlinear
equations 301
3. Algorithmic modules (given in full) 302
(N) 
NEFN—Calculating sum of squares for nonlinear equations 302
Al.3.1 (MACHINEPS)—Calculating machine epsilon 303
(N) 
A3.2.1 (QRDECOMP)—QR decomposition 304
(N) 
A3.2.2 (QRSOLVE)—QR solve 305
(N) 
A3.2.2a (RSOLVE)—R solve for QR solve 306
A3.2.3 (CHOLSOLVE)—Cholesky solve driver 307
A3.2.3a (LSOLVE)—L solve 308
A3.2.3b (LTSOLVE)—L 
transposed solve 309
(N) 
A3.3.1 (CONDEST)—Estimating the condition number of an upper tri-
angular matrix 309

Appendix A 
261
A3.4.1 (QRUPDATE)—QR factorization update 311
A3.4.1a (JACROTATE)—3sLCobi 
rotation 572
(N) 
A3.4.2 (QFORM)— Forming Q from the QR factorization 313
A5.4.1 (FDJAC)—Finite difference Jacobian approximation 314
(U) 
A5.5.1 (MODELHESS)—Formation of the model Hessian 315
A5.5.2 (CHOLDECOMP)—Perturbed Cholesky decomposition 318
(U) 
A5.6.1 (FDHESSG)—Finite difference Hessian approximation from
analytic gradients 320
(U) 
A5.6.2 (FDHESSF)—Finite 
difference Hessian approximation 
from
function values 321
(U) 
A5.6.3 (FDGRAD)—Forward difference gradient approximation 322
(U) 
A5.6.4 (CDGRAD)—Central difference gradient approximation 323
A6.3.1 (LINESEARCH)—Line search 325
A6.3.1mod (LINESEARCHMOD)—Line search with directional de-
rivative condition 328
A6.4.1 (HOOKDRIVER)-Locally 
constrained 
optimal 
("hook")
driver 330
A6.4.2 (HOOKSTEP)—Locally constrained optimal ("hook") step 332
A6.4.3 (DOGDRIVER)—Double dogleg driver 335
A6.4.4 (DOGSTEP)—Double dogleg step 336
A6.4.5 (TRUSTREGUP)—Updating the model trust region 338
(N) 
A6.5.1 (NEMODEL)—Formation of the affine model for nonlinear
equations 342
(N) 
A6.5.1fac (NEMODELFAQ^Formation of the affine model for non-
linear equations with factored secant updates 344
(U) 
A7.2.1 (UMSTOP)—Stopping 
conditions 
for unconstrained 
mini-
mization 347
(U) 
A7.2.2 (UMSTOPO)—Stopping conditions for unconstrained mini-
mization at iteration zero 348
(N) 
A7.2.3 (NESTOP)—Stopping conditions for nonlinear equations 349
(N) 
A7.2.4 (NESTOPO)—Stopping conditions for nonlinear equations at
iteration zero 357
(N) 
A8.3.1 (BROYUNFAQ—Broyden's update, unfactored form 352
(N) 
A8.3.2 (BROYFAQ— Broyden's update, factored form 353
(U) 
A9.4.1 (BFGSUNFAQ— Positive definite secant update (BFGS), un-
factored form 355
(U) 
A9.4.2 (BFGSFAC)—Positive definite secant update (BFGS), factored
form 356
(U) 
A9.4.3 (INITHESSUNFAQ— Initial Hessian for secant updates in un-
factored form 359
(U) 
A9.4.4 (INITHESSFAQ—Initial Hessian for secant updates in factored
form 359

262 
Appendix A
PREFACE
The appendix to this book has several diverse purposes that are dis-
cussed, in Section I.I of Appendix A. The following comments concern how
the appendix may be used to create class projects. They should be read
after reading sections 1.1 and 1.2 of Appendix A.
I have used the pseudo-code in appendix A, in various forms, to create
class projects for my graduate optimization class each year for the past five
years. The students, usually working in groups of two, select a specific
method for unconstrained optimization or nonlinear equations, and code a
complete routine using the pseudo-code in Appendix A. Usually each group
codes only one global strategy (line search, hookstep, or dogleg) but several
derivative evaluation options (e.g. finite difference and secant approxima-
tion). They create and debug their code as the semester progresses, and
then run it on several test problems, such as the problems in appendix B. I
have found these projects to be the most valuable part of a course based on
this book. Even though the pseudo-code is completely detailed, the stu-
dents must understand it thoroughly to implement it successfully and to
remove the inevitable coding errors. Watching the completed algorithms
perform on test problems also is very instructive. This is especially true if
the students print out details of the step selection process, for example the
values attempted for the line search parameter at each iteration, and
answer questions based on this data. ("Is the cubic backtrack ever used?
How often are the default backtracks taken?) It also is instructive to com-
pare finite difference and secant methods on the same problems.
The project can be pursued throughout the semester. For example, for
unconstrained minimization, the groups can code the machineps and Chole-
sky backsolve routines towards the start of the semester, and the finite
difference derivative and model Hessian / perturbed Cholesky decomposi-
tion routines after they are covered in Chapter 5. After Chapter 6 is studied,
they can select a global method, code it and the driver program. The addi-
tion of the stopping routines from Chapter 7 gives a complete finite
difference routine which the students can test, It can then be changed to a
BFGS method after secant updates are covered in Chapters 8-9. Similar
remarks apply to a nonlinear equations project. Two simplifications may be
useful for class projects: omitting the scaling matrices (assuming that Dr =
Dp - I in all cases), and using the simpler to understand but less efficient
matrix storage scheme that is the default in the pseudo-code (see Guide-
lines 3 and 6). Omitting scaling has virtually no effect on test problems
since almost all of the standard ones are well scaled. It is easiest to use the
default tolerances given in Guidelines 2 and 5.
My use of this pseudo-code for class projects over the years led to
several changes. Originally, I used strictly PASCAL control structures, with
BEGINs and ENDs. Students unfamiliar with block structured languages had
difficulty following the structure, so I switched to the hybrid PASCAL /
numbering scheme found in the present pseudo-code. The switch met with
indifference from the block-structured students and was a big help to stu-
dents familiar only with FORTRAN. A second change was to expand fully in
the pseudo-code products involving matrices. Originally the pseudo-code
contained statements like t «- H* s where H is symmetric and only its
upper triangle is stored, but many errors occurred due to the triangular

Appendix A 
263
matrix storage. My students find the pseudo-code in its present form easy
to use, whether they are coding in FORTRAN or in a block-structured
language. Many of them have more difficulty debugging and testing a
software system of this size; the comments at the start of Section 7.3 in the
text are aimed at this problem.
Unfortunately, it is inevitable that the pseudo-code will contain errors.
A few of the algorithms have not been used by my students and may contain
algorithmic errors, The rest of the algorithms may contain typographic
errors. I have tried to reduce the number of errors by preparing the appen-
dix myself, using the UNIX text-editing facilities on the VAX 11/780 system
of the Department of Computer Science at the University of Colorado. I will
maintain a computer-generated list of errata, and distribute it to anyone
who requests it by sending a stamped, self-addressed envelope. Any instruc-
tor using this pseudo-code for a class project is encouraged to send for the
errata.
Another possibility for class projects is to obtain a production code for
nonlinear equations or unconstrained minimization, and have the students
run it on test problems and perhaps alter portions of it if the source is avail-
able. The code of Schnabel, Weiss and Koontz that corresponds closely to
the pseudo-code for unconstrained minimization in this appendix may be
used for this purpose. It is available through the author.
Robert B. Schnabel

264 
Appendix A
SECTION I. 
DESCRIPTION
1.1. 
PURPOSE OF THE MODULAR SYSTEM OF AICORITHMS
Appendix A contains a modular system of fully detailed algorithms for
solving both unconstrained minimization problems and systems of nonlinear
equations. By modular, we mean that each distinct functional component of
these methods is given in one or more separate modules. For example, the
stopping check, derivative calculation, matrix factorization, and step selec-
tion strategy ("global method") each correspond to one or more separate
modules. The word system refers to the fact that several alternative
modules are provided for several parts of the minimization or nonlinear
equations process, so that a large number of different methods may be
obtained by using different combinations of these modules. In addition, the
methods for unconstrained minimization and nonlinear equations share
several components. For example, there are three alternative global
methods (line search, dogleg, and hookstep) that can be used interchange-
ably along with any of the other parts of the algorithms for either problem.
There are also several alternatives for calculation or approximation of
derivatives (analytic, finite differences, secant approximation). Finally, by
fully detailed algorithms we mean that each module is completely specified,
including storage and any tolerances or heuristic decisions that usually are
omitted in high level descriptions.
There are five main reasons why we included these algorithms in this
book:
1) To provide a completely detailed description of any method for
unconstrained minimization or nonlinear equations discussed in the text.
In the text, we present algorithms to the level of detail we consider
appropriate for a thorough introduction to the subject. Readers who desire
the remaining details can find them in this appendix.
2) To show that the modular framework for quasi-Newton algo-
rithms that we refer to throughout the text (Mg. 6.1.1) can be carried to the
implementation level. This substantiates a basic premise of the text, that
all the approaches we discuss for both problems are variations on one
framework.
3) To provide a mechanism for class projects. We have found that
implementing one or more particular methods from this system is an excel-
lent way to reinforce the material presented in the text. Class projects are
discussed further in the preface to the appendix.
4) To encourage the use of structured and controlled software
environments in testing new methods for optimization and related prob-
lems. If production optimization codes were written in a modular manner
such as we describe, then many new methods could be developed and tested
by changing one or a few modules. This would provide an easy and con-
trolled testing environment. The code of Schnabel, Weiss and Koontz men-
tioned below has been used in this manner.
5) To aid practitioners who need to develop their own codes. We
emphasize that one should use codes from numerical software libraries

Appendix A 
265
whenever possible. However, the special nature of a class of applied prob-
lems sometimes necessitates the development of specialized codes, either
from scratch or adapted from existing routines. The algorithms in this
appendix may serve as a refence in such cases.
A production code for unconstrained minimization that corresponds
closely but not exactly to the algorithms in this appendix has been
developed by Schnabel, Weiss and Koontz [1982], The purpose of this appen-
dix was not to create this code, because several software libraries contain
good codes for unconstrained minimization, including the Harwell, IMSL,
MINPACK and NAG libraries. The code was developed to test the algorithms
in this appendix and to provide the research environment mentioned above.
It is generally available through the author and may be used for class pro-
jects or to supplement this text.
The main reason for providing algorithms in the pseudo-code form that
follows instead of an actual coded version (e.g. in FORTRAN) is to make them
easier to read. The pseudo-code algorithms differ from algorithms in a com-
puter language in that mathematical notation has been retained, for exam-
ple Greek letters (X), summation notation 
, inner products of
vectors ( V T w ) and norms 
. The pseudo-code we use was developed so
that it translates readily either into FORTRAN or into block structured
languages like PASCAL or ALGOL, and so that it can be implemented in most
computing environments. It is related to the pseudo-code used by Vander-
graft[1978].
The remainder of Section 1 as well as Sections II and III of this appendix
primarily will be of interest to readers who wish to implement algorithms
contained herein. Section 1.2 explains how the parts of this appendix can be
used together to create one, several, or the entire system of algorithms for
solving unconstrained minimization or nonlinear equations problems. This
includes describing the organization of Sections II and III, which contain
more detailed instructions for using this appendix to create unconstrained
minimization or nonlinear equations algorithms, respectively. Section 1.3
discusses the conversion of the individual modules of this system into com-
puter code, including the effects of computer environment. Sections 1.4 and
1.5 briefly discuss two more specific considerations in coding these algo-
rithms.
Section IV contains the fully detailed individual modules for the various
parts of our methods. It should be of interest to all readers of this book, as
an accompaniment to the discussion of the methods in the body of the text.
The modules are numbered to correspond to the text: the first two digits of
the three digit algorithm number refer to the section in the text where the
method is covered. (For example. Algorithms A7.2.1 through A7.2.4 are
stopping algorithms discussed in Section 7.2 of the text.) The modules are
also given short descriptive names (e.g. Alg. A7.2.1 is UMSTOP) that are used
within the pseudo-code for increased readability.

266 
Appendix A
12 ORGANIZATION OF THE MODUIAR SYSTEM OF ALGORITHMS
The organization of this system of algorithms for unconstrained minimi-
zation and nonlinear equations 
follows the quasi-Newton framework
presented in Section 6.1 of the text. The methods for both problems are
divided into a number of separate functional components (e.g. stopping
check, derivative calculation, global method), and each component is imple-
mented by one or more modules. In some cases (derivative calculation or
approximation, and global method), a number of alternatives are given for
one component, and any one may be selected. A complete method for
unconstrained minimization or nonlinear equations is created by selecting
and coding algorithms for each of the separate components, and joining
them together with a driver program.
In the text, Alg. 6.1.1 served as an indication of the required com-
ponents as well as the driver program, but here more detail is required. The
Description sections of Algorithms D6.1.1 and D6.1.3 (in Sections II. 1 and
111.1 below) list the steps of our methods for unconstrained minimization and
nonlinear equations, respectively. Some of these steps are simple lines of
code in the driver algorithm, while others are the components mentioned
above that correspond to one or more individual modules. Sections II.2 and
111.2 list these separate components, and the modules that are used to
implement them, including alternatives if there are any.
The Algorithm sections of Algorithms D6.1.1 and D6.1.3 contain the
pseudo-code for the driver algorithms one would use to implement the
entire system, of algorithms for unconstrained minimization or nonlinear
equations, with all the alternatives for global method and derivative calcula-
tion. The driver for the code of Schnabel, Weiss and Koontz [1982] is similar
to this. To implement one (or a few) specific method rather than the whole
system, a pared down driver suffices. Algorithms D6.1.2 and D6.1.4 are
examples of drivers that implement one specific method for unconstrained
minimization and nonlinear equations, respectively. Drivers for other
specific methods can be created similarly by selecting the appropriate parts
from Algorithms D6.1.1 orD6.1.3.
Each main driver algorithm (D6.1.1 and D6.1.3) is supplemented by the
list of modules mentioned above, and by three guidelines. Guideline 1 con-
tains suggestions for choosing among the algorithmic options provided for
the global method and for derivative calculation, for unconstrained minimi-
zation. It is intended as advice to a user of this system and as information
to students and other interested readers. Guideline 2 discusses the choice
of the stopping tolerances and all other tolerances used in the uncon-
strained minimization algorithms. In a production implementation, these
tolerances might be selected by the user or given values in the code; in a
class project, the student will select them based on Guideline 2. Guideline 3
discusses in some detail the matrix storage required by the unconstrained
minimization code. We found efficient storage allocation to be the most
difficult aspect of these algorithms to specify completely in a pseudo-code
description intended mainly for easy readability 
Guideline 3 together with
the Storage Considerations sections of the individual modules attempts to
remedy this situation.
Guideline:; 4-6 contain the analogous information to Guidelines 1-3, fo-
nonlinear equations. In cases where the information is repetitious, the non-
linear equations guidelines refer to the corresponding unconstrained rruni.fr:-
ization guideline;;.

Appendix A 
267
1.3. 
ORGANIZATION OF THE INDIVIDUAL MODULES
The structure of each module in Section IV, and of the driver modules
D6.1.1-4, is :
Purpose
Input Parameters
Input-Output Parameters
Output Parameters
Meaning of Return Codes
Storage Considerations
Additional Considerations
Description
Algorithm
The Purpose section gives a one or two sentence summary of the pur-
pose of the module. The three Parameter sections list the names, data
types, and occasional additional information about all the parameters to the
module. When the module is called by other modules in the system, the
order of the arguments in the calling statement corresponds to the order of
the parameters in these sections. The Return Codes section is provided for
algorithms like stopping checks that return an integer code to the algo-
rithm that calls them; for all other algorithms this section is omitted.
The Storage Considerations sections of the modules, together with
Guidelines 3 and 6, specify the matrix and vector storage requirements of
these algorithms. Alternative implementations are discussed that achieve
more efficient storage while diminishing the readability of the code. Item 1
of the Storage Considerations section of each individual module lists any
local variables that are vectors or matrices. All variables in the module not
listed in this item or in the parameter lists are scalar local variables (real,
integer, or Boolean). The code is constructed so that all communication
between routines is via parameters and no global variables (i.e. FORTRAN
COMMON) are required. The single exception is two variables that must be
passed as global variables between algorithms NEFN and D6.1.3 for nonlinear
equations, as described in these algorithms.
The Additional Considerations section is included occasionally for an
additional comment about the module. The Description section is intended
to make clear the basic structure of the algorithm that follows. It may over-
simplify some details of the algorithm. For very simple algorithms, this sec-
tion may be omitted.
The Algorithm section contains the fully detailed pseudo-code for the
module. The format of the pseudo-code is intended to be self-evident to all
readers, and is similar to that used by Vandergraft [1978]. It is based on
PASCAL control structures described briefly below; they were selected
because their function is obvious from their wording. (PASCAL control
structures are very similar to those in ALGOL, PL/1 and FORTRAN 77.)
Rather than use PASCAL BEGINs and ENDs, a numbering scheme is used that
indicates sequence number and nesting level. In our experience, it makes
the pseudo-code easier to follow for readers unfamiliar with block struc-
tured languages, and has the additional advantage of giving each statement
a unique number.
The following six control structures are used. A reader familiar with
block structured languages should glance at these only to notice the sample
numbering schemes.

268 
Appendix A
i) IF-THEN statement
1. IF (condition i) THEN
1.1 first statement inside IF-THEN
1.5 last statement inside IF-THEN (5 is sample length)
2. next statement
meaning : If condition i is true, execute statements 1.1-5 and then
proceed to statement 2, otherwise proceed directly to statement 2.
ii) IF-THEN-ELSE statement
4. IF (condition ii]
4T. THEN
4T.1 first statement in THEN block
4T.3 last statement in THEN block
4E. ELSE
4E. 1 first statement in ELSE block
4E.7 last statement in ELSE block
5. next statement
meaning : If condition ii is true, execute statements 4T. 1-3, otherwise
execute statements 4E.1-7. Then proceed to statement 5.
iii) Multiple branch statement
2 last statement
3a. IF (condition iiia) THEN
statements 3a.l through 3a.4
3b. ELSEIF (condition iiib) THEN
statement 3b.l
3c. ELSE
statements 3c.l through 3c.l2
4. next statement
meaning : If condition iiia is true, execute statements 3a.l-4 and
proceed to statement 4; else if condition iiib is true, execute state-
ment 3b.l and proceed to statement 4; otherwise execute state-
ments 3c.l-12 and proceed to statement 4.
This control structure with its characteristic labelling is included
because it indicates the conceptual structure in several of our algo-
rithms better than an IF-THEN-ELSE statement whose ELSE clause is
itself an IF-THEN-ELSE. The number of alternatives can be increased
to any number desired; for example, Algorithm A7.2.1 has state-
ments 2a through 2f.
iv) FOR loop (equivalent to FORTRAN DO loop)
6.2 FOR integer variable =integer valuejf 1 TO integer vaJue#2 DO
statements 6.2.1 through 6.2.9
6.3 next statement
meaning :
a. integer variable *- integer value # 1
b. if integer variable > integer value#2, go to next statement (6.3),
otherwise go to step c.
c. execute statements 6.2.1-9.
d. integer variable <- (integer variable+l)
e. go to step b.
note 
that 
the 
loop 
is never executed if integer valueft 1 >

Appendix A 
269
integer value#2; it is executed once if these two values are equal,
a FOR ... DOWNTO statement also is used occasionally; its meaning
differs from the above only in that the > is changed to a < in step b,
and the + is changed to a - in step d.
v) WHILE loop
7.3.2 WHILE (condition v) DO
statements 7.3.2.1 through 7.3.2.8
7.3.3 next statement
meaning :
a. if condition v is true, go to step b, otherwise go to next state-
ment (7.3.3).
b. execute statements 7.3.2.1-9.
c. go to step a.
vi) REPEAT loop
2.3 REPEAT
statements 2.3.1 through 2.3.6
2.3U UNTIL (condition i/i)
2.4 next statement
meaning :
a. execute statements 2.3.1-6.
b. if condition vi is true go to next statement (2.4), otherwise go to
step a.
note that the body of a repeat loop is always executed at least once but
the body of a while loop may be executed zero times.
The condition in the above statements can either be a simple condition
(s2 > x - 2), a compound condition ((i = 2) AND ((b < 1) OR (b > 3))), or a
Boolean variable. Compound conditions use the operators AND, OR, and NOT
and follow normal precedence rules. Boolean variables may be assigned the
values TRUE and FALSE; if boo is a boolean variable then boo and NOT boo
are possible conditions. Boolean variables may be part of compound condi-
tions as well.
Since these algorithms contain no input or output statements (see Sec-
tion 14) there are only two other types of statements besides the six given
above, an assignment statement and a procedure call statement. (One GO
TO is used in Atg. D6.1.3., and one RETURN statement is used in each driver
algorithm.) An assignment statement is written
variable «- expression
read, "variable gets value of expression". The operator = is reserved for
conditions and FOR loops. Procedure calls are written
CALL modidename (List of arguments).
The module name is the descriptive name (e.g. UMSTOP); the module
number (A7.2.1) is always given as an accompanying comment. The argu-
ments correspond, in order, to the Input Parameters, Input-Output Parame-
ters and Output Parameters of the module being called. If the body of one
of the control statements consists of only one assignment statement or pro-
cedure call, it is usually not given a separate number, for example:
3.2 FOR i = 1 TO n DO
x[i] «- 1
3.3 next statement
Elements of vectors and matrices are denoted as in PASCAL: the ith
element of a vector x is x [ i ] , the i,j element of a matrix M is M [ i , j ] .
Scalar variables may have type integer, real or Boolean, their type is

270 
Appendix A
implied by their use in the algorithm. Variable names are sometimes Greek
letters when this corresponds to the usage in the text; in a coded version
these could be converted to the English equivalent (i e a becomes alpha).
Variable names are descriptive and some are longer than allowed by stan-
dard FORTRAN. All variable names are italicized.
The precision of real variables is not specified. These methods usually
should have at least 10-15 base 10 digits of accuracy available for real
numbers. Thus on a CDC, Cray, or similar machine, single precision is
sufficient, but on an IBM, DEC or similar machine, real variables should be
double precision. The only machine dependent constants in the code are
functions of the machine epsilon, macheps, which is calculated at the begin-
ning of any method for unconstrained minimization or nonlinear equations.
The main feature that makes the pseudo-code different from and more
readable than actual computer language code is the use of mathematical
and vector notation. The main instances are summation notation, max and
min operators, exponents, assignments of vectors to vectors, vector pro-
ducts, norms of vectors, and multiplication of vectors by diagonal matrices
(see Section 15). Coding these operations sometimes will require the intro-
duction of additional variables. Operations involving non-diagonal matrices
generally are specified componentwise. The reason is that too much confu-
sion arose when our students coded statements like t «-H*s where
//e/?nxn is a symmetric matrix and only the upper triangle of H is stored.
The matrix form of the statement is always provided in an accompanying
comment.
Comments are denoted using PASCAL notation: (* starts the comment
and the next *) .not necessarily on the same line, ends it The RETURN
statements that would be required in FORTRAN, but not in a block struc-
tured language, are indicated in comments.
1.4. 
INPUT AND OUTPUT
This system of algorithms does not contain any input (read) or output
(write, print) statements. It communicates to the outside world solely via
the parameter list of the main driver program. This is the standard and
desirable way to receive input, and there should be no need to insert any
input statements into the algorithms. However, most implementors will
want to insert output statements.
A production code usually has several levels of printed output available,
including no printed output, sometimes desirable when the code is imbed-
ded inside another routine, and a small amount of printed output, say the
method used, the function (and gradient) values at the initial and final
points, a termination message, and the number of iterations and function
and derivative evaluations used. Another option usually is to also print the
function (and gradient) values at the end of each iteration. For debugging
or a class project, it is useful to have the additional option of printing infor-
mation about the step selection process, for example, the values of A
attempted at each iteration in a line search method, the successive values
of the trust radius in a trust region method, some details of the jj, iteration
in a hookstep method. The level of printed output can be controlled by

Appendix A 
271
adding an input parameter to the main driver, say printcode; the output
statements in the code are made conditional on the value of printcode.
The output parameters of the main drivers also are not completely
specified. They must include the termination code, and the final value of the
independent variable x. They may include the final function vector (for non-
linear equations) or function and gradient values (for minimization) as well.
For nonlinear equations, the Jacobian or its approximation is calculated at
the final point and is available for output. For minimization, the Hessian or
its approximation is not calculated at the final point; a user desiring this
information must modify the algorithms slightly.
1.5. 
MODULES FOR BASIC ALGEBRAIC OPERATIONS
Several algebraic operations appear frequently enough in the pseudo-
code that an implementor of these algorithms may wish to provide special
subroutines to perform them. Some possibilities are max and min, vector
product (VTW), lz norm of a vector, and operations involving the diagonal
scaling matrices Dx and Dp. When coding in FORTRAN, it may be convenient
to use the Basic Linear Algebra Subroutines (BIAS) to implement some of
these; see Lawson, Hanson, Kincaid and Krogh [1979].
Algorithms A6.4.1-5 and A8.3.1-2 contain a number of expressions of the
form 
or 
, where k is +2 or ±1, and 
. In all cases, a com-
ment in the pseudo-code reminds the reader that the diagonal scaling
matrix Dx is not stored as such, rather the vector Sxz.Rn is stored, where
Dx = diag ((S x) l 
(Sx)n). 
Thus the ith component of 
.
If one is implementing scaling, it may be convenient to write a subroutine
that, given k, Sx, and v, returns 
, and another that returns 
.

272 
Appendix A
SECTION n
DRIVER MODULES AND GUIDELINES FOR
UNCONSTRAINED MINIMIZATION
D. 1 ALGORITHM D6.1.1. (UMDRIVER)
DRIVER FOR A MODULAR SYSTEM OF ALGORITHMS
FOR UNCONSTRAINED MINIMIZATION
Purpose : Attempt to find a local minimizer xm of / (x) : Rn -->R starting from
x0, using one of a variety of algorithms.
Input Parameters : neZ (n l), z0eRn, FN (the name of a user-supplied
function / : Rn —> R that is at least twice continuously differentiable)
plus optionally :
i) GRAD, HESS — names of user-supplied functions for evaluating
and 
, respectively.
ii) global eZ, anagrad e Boolean, analhess e Boolean, cheap f E Boolean,
factsec eBoolean — parameters 
used in choosing algorithmic
options. These are explained in Guideline 1. (Parameters that are
not input are given values by algorithm UMINCK).
iii) typx ERn, typf ER, f digits eZ, gradtolcR, steptol ER, maxstep^R,
itrdim.it eZ, 
-- tolerances and constants used by the algorithm.
These are explained in Guideline 2. (Tolerances or constants that
are not input are given values by algorithm UMINCK).
iv) printcode eZ — see Section 1.4 of this Appendix.
Input-Output Parameters : none (see however item 2 under Storage Con-
siderations)
Output Parameters : xfeRn (the final approximation to xM), termcodezZ
(indicates which termination condition caused the algorithm to stop)
plus optionally :
other output parameters as
desired by the implementor (see Section 1.4)
Meaning of Return Codes :
termcode <0 : algorithm terminated due to input error, see Alg.
UMINCK.
termcode > 0 : algorithm terminated for reason given in Alg. A7.2.1.

Appendix A 
273
Storage Considerations:
1) Matrix and vector storage requirements are discussed in Guideline 3. Be
sure to read item 5 in Guideline 3 if you are implementing these algorithms
in FORTRAN.
2) The names x0 and xj are used in this driver for clarity only. In the
implementation, xc and xf can both share storage with xc.
Additional Considerations :
1) The List of Modules for Unconstrained Minimization shows which modules
correspond to each step in the Description below. The choice between alter-
natives in the list is determined by the algorithmic option parameters
described in Guideline 1.
2) The Algorithm below is used for implementing the entire system of
unconstrained minimization algorithms. A simpler driver can be used to
implement a particular algorithm for unconstrained minimization, as is
illustrated by Algorithm D6.1.2.
3) On some computing systems, it will be necessary to supply dummy rou-
tines GRAD and HESS, for the case when the user doesn't supply routines for
evaluating 
or 
, respectively. These dummy routines are
required solely to allow compilation of the program.
Description:
Initialization:
1) Calculate machine epsilon.
2a) Check input for reasonableness, assign default values to optional
parameters and tolerances that weren't input to user. (Return termcode to
driver.)
2b) If termcode < 0, terminate algorithm, returning xf - x0 and termcode.
If termcode = 0, set itncount <-- 0 and continue.
3) Calculate fc = f (x0).
4) Calculate or approximate gc = 
.
5a) Decide whether to stop. (Return termcode to driver).
5b) If termcode > 0, terminate algorithm, returning Xf = x0 and termcode.
If termcode - 0, continue.
6) Calculate or approximate 
.
7) Set xc = x0.
Iteration:
1) itncount <-- itncount + 1
2) Form positive definite model Hessian Hc (= H c+uI, u>0, u>0 if Hc is
already safely positive definite) and its Cholesky decomposition Hc = Lc
LC lower triangular.
3) Solve (Lc 
sN = -gc.
4) Choose x+ - xc + sc where sc = sN or a step chosen by the global stra-
tegy. f+. = f (x+) is calculated during this step.
5) Calculate or approximate g+ = 
.
6a) Decide whether to stop. (Return ferracode to driver).
6b) If termcode > 0, terminate algorithm, returning xj - x+ and termcode.
If termcode = 0, continue.
7) Calculate or approximate 
.
8) Set xc <--x +, fc 
f+, 
gc <- g+ and return to step 1 of the iteration sec-
tion.

274 
Appendix A
Algorithm :
(* Initialization section : *)
1. CALLMACHINEPS(macheps)
2. CALL UMINCK (parameter list selected by implementor)
(* see UMINCK description *)
3. IF termcode < 0 THEN
3.1 xf <- x0
3.2 RETURN from Algorithm D6.1.1 
(* write appropriate message, if
desired *)
4. itncount <- 0
5. CALLFN(n,x 0.f c)
6. IF analgrad
6T. THEN CALL GRAD (n. x0, gc)
6E. ELSE CALL FDGRAD (n, x0, fc, FN, Sx, rj, gc) 
(* Alg. A5.6.3 *)
7. CALL UMSTOPO (n, x0, fc, gc, Sx, typf, gradtol, termcode, consecmax)
(*Alg. A7.2.2 *)
6. IF termcode > 0
8T. THEN xf «- x0
8E. ELSE (* calculate initial Hessian or approximation *)
BE.la IF analhess THEN
CALL HESS (n, xO, Hc)
BE.lb ELSEIF analgrad AND cheapf 
THEN
CALLFDHESSG (n,x 0,g c, GRAD, Sx, n, Hc) (* Alg. A5.6.1 *)
BE.lc ELSEIF cheap/ THEN
CALLFDHESSF(n,z0./c. FN, Sx, n, Hc) 
(*Alg. A5.6.2 *)
BE.Id ELSEIF f actsec THEN
CALL INITHESSFAC (n, fc. *MP/ . -S".. Lc) (* Alg. A9.4.4 *)
(* note: /actsec must be false if global=2 *)
BE.le ELSE (* /actsec = FALSE *)
CALL INITHESSUNFAC (n, fc, typ f , Sx, Hc] 
(* Alg. A9.4.3 *)
9. xc <- X0
(* Iteration section : *)
10. WHILE termcode - 0 DO
10.1 itncount <-- itncount + 1
10.2 IF NOT f actsec THEN
CALL MODELHESS (n, SX, macheps, Hc. 
Lc) 
(* Alg. A5.5.1 *)
10.3 CALLCHOLSOLVE(n,g c, Zt.stf) 
(* Alg. A3.2.3 *)
10.4a IF global = 1 THEN
CALL LINESEARCH (n, xc , fc, FN, gc, SN, Sx. maxstep, steptol,
retcode, x + , f+, maxtaken) (* Alg. A6.3.1 *)
10.4b ELSEIF global = 2 THEN
CALL HOOK DRIVER (n, xc, fc, FN, ge, La, He, SN, Sx, maxstep,,

Appendix A 
275
steptol, itncount, macheps, ,u, prev, 
, retcode, x+, /+,
maxtaken) (*Alg. A6.4.1 *)
10.4c ELSEW global - 3 THEN
CALL DOGDRIVER (n, xc, fc, FN, gc, Lc, SN, Sx, maxstep, steptol,
6, retcode, x+, f +, maxtaken') 
(* Alg. A6.4.3 *)
10.4d ELSE ('global = 4*)
CALL LINESEARCHMOD ( n , x c , f c , FN, gc, analgrad, GRAD, SN, Sx,
maxstep, steptol, retcode, x+, f + , g+, maxtaken) 
(* Alg.
A6.3.1mod *)
10.5 IF global 
4 THEN
10.5.1 IF analgrad
10.5.IT THEN CALL GRAD (n. x+ , g+)
10.5.IE ELSE CALL FDGRAD (n, x+, f+, FN, Sx, n,. g+) 
(*Alg. A5.6.3
*)
(* if central difference switch is used, perhaps call CDGRAD (n, x+.
FN, Sx, 77, g+) instead -- see Alg. A5.6.4 *)
10.6 CALL UMSTOP (n, xc, z+, fx, g+ , Sx. t y p f , retcode, gradtol, step-
tol, itncount, itnlimit, maxtaken, consec-max, termcode) 
(* Alg
A7.2.1 *)
10.7 Wtermcode > 0
10.7T THEN xf <-- X+*
10.7E ELSE (* calculate next Hessian or approximation *)
10.7E.la IF analhess THEN
CALL HESS ( n , x + , H c )
10.7E.lb ELSEIF analgrad AND cheapf THEN
C A L L F D H E S S G ( n , x + l , g + 1 G R A D , S x , n , ) 
(*Alg. A5.6.1 *)
lO.7E.lc ELSEIF cheapf THEN
CALLFDHESSF(n, zt, f+, FN, Sx,n, Hc) 
(* Alg. A5.6.2 *)
lO.7E.ld ELSEIF factsec THEN
CALL BFGSFAC (n, xc, z+, gc, g+, macheps, n, analgrad, Lc)
(*Alg. A9.4.2*)
10.7E.le ELSE (* factsec - FALSE *)
CALL BFGSUNFAC (n, xc, x+, gc, g+, macheps, 77, analgrad,
Hc) 
(*Alg.A9.4.1 *)
10.7E.2 xc <- x +
10.7E.3 fc <- f+
10.7E.4 gc <- g+
(* END, WHILE loop 10*)
(* write appropriate termination message, if desired *)
(* RETURN from Algorithm D6.1.1 *)
(* END, Algorithm D6.1.1 *)

276 
Appendix A
II. 2. 
LIST OF MODULES FOR UNCONSTRAINED MINIMIZATION
The steps in the Description section of Driver D6.1.1 correspond to the
following modules. The steps in the Description that are not listed below
correspond to lines of code in the driver algorithm.
Initialization
Step 1 -- MACHINEPS
Step 2a -- UMINCK
Step 3 -- FN
Step 4 -- GRAD or FDGRAD
Step 5a -- UMSTOPO
Step 6 - HESS or (FDHESSG / FDJAC) or FDHESSF or INITHESSUNFAC or
IN1THESSFAC
Iteration
Step 2 -- (MODELHESS / CHOLDECOMP)
StepS --CHOLSOLVE
Step 4 -- LINESEARCH or LINESEARCHmod or (HOOKDRIVER / HOOKSTEP /
TRUSTREGUP) or (DOGDRIVER / DOGSTEP / TRUSTREGUP)
Step 5 -- GRAD or FDGRAD (or perhaps CDGRAD if using central difference
switching option)
Step 6a - UMSTOP
Step 7 -- HESS or (FDHESSG / FDJAC) or FDHESSF or BFGSUNFAC or
(BFGSFAC / QRUPDATE)
When a step above contains two or more modules or groups of modules
separated by the word "or", these are alternative choices selected by the
algorithmic option parameters. A given method would use only one choice
throughout the algorithm for each such step.
When two or more modules are listed above in parentheses separated
by slashes (/), the first module in the parenthesized group is called by the
driver, the remaining module(s) in the group are called by the first module.
For example, FDHESSG calls FDJAC. In addition, the following modules call
the following service and function evaluation modules :
HOOKSTEP calls CHOLDECOMP and LSOLVE
LINESEARCH calls FN
LINESEARCHmod calls FN and (GRAD or FDGRAD (or CDGRAD))
TRUSTREGUP calls FN
The following modules also call their following subalgorithms :
CHOLSOLVE calls LSOLVE and LTSOLVE
QRUPDATE calls JACROTATE

Appendix A 
277
D.3. 
GUIDELINE 1
CHOOSING ALGORITHMIC OPTIONS
FOR UNCONSTRAINED MINIMIZATION
The following are the algorithmic options available when using this sys-
tem of algorithms for unconstrained minimization, and an indication of how
to choose them.
global -- A positive integer designating which global strategy to use at each
iteration, as follows
= 1 Line search (Alg. A6.3.1)
=2 Hookstep trust region (Alg. A6.4.1)
=3 Dogleg trust region (Alg. A6.4.3)
=4 Modified line search (Alg. A6.3.1 mod)
On some problems, there may be rather large variations in the accuracy
and efficiency obtained by interchanging methods 1, 2, and 3 while keep-
ing all other parameters and tolerances unchanged. 
However, no
method seems clearly superior or inferior to the others in general, and
each is likely to be best on some problems. The first three possibilities
are provided for comparison, and to allow a user to select the best
method for a particular class of problems. Method 4 is a slight augmen-
tation of method 1 that may be preferred when secant approximations
to the Hessian are used; in our experience, the results using methods 1
and 4 are very similar.
Suggested default value : global = 1 (because this probably is the easiest
method to understand and to code)
analgrad — A Boolean variable that is TRUE if a routine that computes the
analytic gradient V/ (x) has been supplied by the user, and is FALSE oth-
erwise. If analytic gradients are not supplied, the system will approxi-
mate the gradient at each iteration by finite differences. The algorithms
in this system usually will be able to find a more accurate approximation
to the minimizer, and sometimes may perform more efficiently, using
analytic rather than finite difference gradients. Therefore it is impor-
tant to supply a routine that evaluates the analytic gradient if it is
readily available.
Suggested default value : analgrad = FALSE
analhess - A Boolean variable that is TRUE if a routine that computes the
analytic Hessian matrix 
has been supplied by the user, and is
FALSE otherwise. If analytic Hessians are not supplied, the system will
approximate the Hessian at each iteration by finite differences or secant
approximations depending on the value of cheapf . The algorithms in
this system may perform more efficiently if analytic Hessians are pro-
vided; a routine to evaluate the analytic Hessian should be supplied if it
is readilv available.
Suggested default value : analhess — FALSE
cheapf — A Boolean variable that is TRUE if the objective function / (x) is
inexpensive to evaluate and is FALSE otherwise. If analhess - TRUE,
cheapf is disregarded. If analhess - FALSE, cheapf is used to choose
the method of Hessian approximation: finite difference Hessians are
used if cheapf 
- TRUE, secant approximations to the Hessian (BFGS

278 
Appendix A
updates) are used if cheapf 
= FALSE. Methods using finite difference
Hessians usually (but not always) will require fewer iterations than
methods using secant approximations on the same problem. Methods
using secant approximations usually will require fewer objective function
evaluations than methods using finite difference Hessians (including the
function evaluations used for finite differences), especially for problems
with medium or large values of n. Thus if the cost of evaluating / (x) is
appreciable or if secant approximations are desired for any other rea-
son, cheapf should be set FALSE, otherwise cheapf should be set TRUE.
Suggested default value : cheapf = FALSE
factsec — A Boolean variable that only is used if secant approximations to
the Hessian are used, i.e. if analhess = FALSE and cheapf - FALSE, and
is disregarded in all other cases. When it is used, the value of factsec
only affects the algorithmic overhead of the algorithm, the results and
sequence of iterates are unaffected. If factsec = TRUE, the system uses
a factored secant approximation, updating an LLT factorization of the
Hessian approximation and requiring 0(n2) operations per iteration; if
factsec - FALSE, it uses an unfactored approximation, requiring 0(n3)
operations per iteration. (See Section 9.4 of the text for details.) If glo-
bal = 2, factsec must be set FALSE because the hookstep algorithm as
written could overwrite the Cholesky factor L of the Hessian approxima-
tion. If global = 1, 3 or 4, a production code should use factsec - TRUE
because this is more efficient. In all cases, factsec = FALSE may be
preferred for class projects as this version is easier to understand.
Suggested default value : factsec = FALSE for class projects or when glo-
bal = 2, factsec = TRUE otherwise
D.4. 
GUIDELINE 2
CHOOSING TOLERANCES FOR UNCONSTRAINED MINIMIZATION
The following are the scaling, stopping and other tolerances used for
unconstrained minimization, and an indication of appropriate values for
them.
typx — An n dimensional array whose ith component is a positive scalar
specifying the typical magnitude of x [ i ] . For example, if it is antici-
pated that the range of values for the iterates x will be
x1e[-1010- 1010], x2e[-102- -104]. x3e[-6* 10-6' 9* I0-6]
then an appropriate choice would be
typx = (1010, 103, 7*10-6).
typx is used to determine the scale vector Sx, and diagonal scaling
matrix Dx used throughout the code; Dx = diag ((Sx)i 
(Sz)n) where
S x[i] - 1/ typx[i]- It is important to supply values of typx when the
magnitudes of the components of x are expected to be very different; in
this case, the code may work better with good scale information than
with Dx-l'. If the magnitudes of the components of x are similar, the

Aooendix A 
279
code will probably work as well with Dx =1 as with any other values.
Suggested default value : typx [i] - 1, i = 1, • • • ,n
typf - A positive scalar estimating the magnitude of / (x) near the minim-
izer xm. It is used only in the gradient stopping condition given below. If
too large a value is provided for typf, the algorithm may halt prema-
turely. In particular, if f ( x 0 ) is >> f(xx), typf 
should be approxi-
mately
Suggested default value : typf = 1
fdigits 
— A positive integer specifying the number of reliable digits
returned by the objective function FN. For example, if FN is the result
of an iterative procedure (quadrature, a p.d.e, code) expected to provide
five good digits to the answer, fdigits should be set to 5. If FN is
expected to provide within one or two of the full number of significant
digits available on the host computer, fdigits should be set to -1.
fdigits is used to set the parameter 77 that is used in the code to specify
the relative noise in / (x); the main use of 77 is in calculating finite
difference step sizes. 
77 is set 
to macheps 
if fdigits = —1, 
to
maxf mac heps, lO
- f d i g i t s} otherwise. If / (x) is suspected to be noisy but
the approximate value of f digits is unknown, it should be estimated by
the routine of Hamming [1973] given in Gill, Murray and Wright [1981].
Suggested default value . f digits = -1
gradtol -- A positive scalar giving the tolerance at which the scaled gradient
is considered close enough to zero to terminate the algorithm. The algo-
rithm is stopped if
(see Section 7.2). This is the primary stopping condition for uncon-
strained minimization, and gradtol should reflect the user's idea of what
constitutes a solution to the problem. If the gradient is approximated
by finite differences, 
is likely to be the smallest value of gradtol for
which the above condition can be satisfied.
Suggested default value : gradtol - machepsl/3
steptol — A positive scalar giving the tolerance at which the scaled distance
between two successive iterates is considered close enough to zero to
terminate the algorithm. The algorithm is stopped if
(see Section 7.2). steptol should be at least as small as 10-d where d is
the number of accurate digits the user desires in the solution xx. The
algorithm may terminate prematurely if steptol is too large, especially
when secant updates are being used. 
For example, steptol =
machepsl/3 is often too large when secant methods are used.
Suggested default value : steptol - macheps2/3
maxstep — A positive scalar giving the maximum allowable scaled steplength
at any iteration, maxstep is used to prevent steps that
would cause the optimization algorithm to overflow or leave the domain
of interest, as weU as to detect, divergence. It should be chosen small

280 
Appendix A
enough to prevent the first two of these occurrences but larger than any
anticipated reasonable stepsize. The algorithm will halt if it takes steps
of length maxstep on five consecutive iterations
Suggested default value : maxstep = 103 *max
itnlinnit — A positive integer specifying the maximum number of iterations
that may be performed before the algorithm is halted. Appropriate
values depend strongly on the dimension and difficulty of the problem,
and on the cost of evaluating the nonlinear function.
Suggested default value : itrdimit =100
5 - A positive scalar giving the initial trust region radius (see Section 6.4)
It is used only when global - 2 or 3 (hookstep or dogleg methods),
ignored when globed = 1 or 4 (line search). The value of a should be what
the user considers a reasonable scaled steplength for the first iteration,
and should obey 6 maxstep. If no value of 
is supplied by the user or
if 
, the length of the initial scaled gradient is used instead. In all
cases, the trust radius is adjusted automatically thereafter.
Suggested default value : 6 = -1
II.5. 
GUIDELINE 3
STORAGE CONSIDERATIONS FOR UNCONSTRAINED MINIMIZATION
The following are some storage considerations relevant to the entire
system of algorithms for unconstrained minimization. In addition, many
individual modules contain a Storage Considerations section giving com-
ments specific to that module.
1) The entire system of algorithms for unconstrained minimization uses two
nxn matrices, L and H. However, only the lower triangle of L and the
upper triangle of H, including the main diagonals of both, actually are used.
Thus the entire system of algorithms could be implemented using n2+ O(n)
storage locations. We have written it using separate matrices for L and H,
thus wasting n2-n locations, because this makes the pseudo-code easier to
follow. However, the system also is written so that with only a few minor
modifications to a few modules, discussed in item 2 below, it uses only
n2+0(n) storage locations. For class projects, the maximum problem
dimension n probably will be small, so the system probably should be imple-
mented as written to make it easy to understand. Any production imple-
mentation certainly should make the modifications given in item 2.
2) To make the entire system of algorithms for unconstrained minimization
use only one nxn matrix, minor modifications are required to Algorithms
A5.5.1-2, A6.4.1-2, A6.4.5, A9.4.1, and the driver D6.1.1 (or the pared down
driver being used). Basically, they consist of combining L and H into one
matrix, with the main diagonal of H sometimes stored in a separate n-
vector hdiag. and changing the code, parameter lists and calling sequences
accordingly. The modifications are :

Appendix A 
281
Algorithm A5.5.1
i) Change output parameter LeRnXn to output parameter hdiag ERn
ii) Between lines 11 and 12, insert the statement
l11/2 FORi = I TO n DO
hdiag [i] <- H[i,i]
iii) Change lines 12 and 13.8 to
CALL CHOLDECOMP (n, hdiag, maxo f A, macheps, H, maxadd]
iv) On lines 13.3.2, 13.3.3 and 13.7. change all occurrences of H[i,i\ to
hdiag [i]
v) Replace statement 14.1 by
14.1 FOR; = i + l TO n DO
H [ i j - ] ^ H [ i , j ] *Sx,[i] *5,[j]
14.2 hdiag [i] <-- hdiag[i] * S x[i] 2
vi) On line 15.1, change both instances of L [ i , j ] to H [ i , j ]
Algorithm A5.5.2
i) Change input parameter HeRnxn to input parameter hdiag &Rn
ii) On line 2.1, chang e H [i ,i ] to hdiag [i ]
iii) On line 4.1, change H[j ,j ] to hdiag [j ]
iv) On line 4.3.1, change H[j ,i] to L[j ,i]
Algorithm A6.4.1
i) Change input parameter H£-Rn*n to input parameter hdiag E Rn
ii) On lines 5.1 and 5.3, change the parameter H to hdiag
Algorithm A6.4.2
i) Change input parameter HeRnxn to input parameter hdiag ERn
ii) On lines 3E.8.2 and 3E.8.5, change all occurrences of H[i,i] to
hdiag [i]
iii) On line 3E.8 3, change the parameter H to hdiag
Algorithm A6.4.5
i) Change input parameter HERnXn to input parameter hdiag eRn
ii) On line 9c.2T.l.l, change H[i,i] to hdiag[i]
Algorithm A9.4.1
i) Add input parameter hdiag eRn as the final input parameter
ii) Before line 1, insert the statement
1/2 FOR i = 1 TO n DO
H[i,i] <- hdiag[i]
Driver D6.1.1
i) On line 10.2, change the parameter Lc to hdiag
ii) On line 10.4b, change the parameter Hc to hdiag
iii) On line 10.7E.le, insert the parameter hdiag between analgrad and
#c
iv) Change all remaining instances of Lc in the parameter lists to Hc.
These occur on lines BE.ld, 10.3, 10.4b, 10.4c, and 10.7E.ld.
3) It is possible to reduce the storage requirement further, to 1/2n2+0(n)
locations, in one special case : when factored secant approximations to the
Hessian are used. H never is used in this case; the only matrices used are
the lower triangular L, and the upper triangular R used by Alg. A3.4.1, and
they may share storage. In most languages, to actually use only (n2+n)/2
locations to store a triangular matrix, the matrix would have to be

282 
Appendix A
implemented as a vector with (n2+n)/2 elements, for example with
L[i,j] = v[((iz-i)/2)+j] - R[j,i], 1<j<i<n The remaining details of this
conversion are left as an exercise.
For all the other methods, n2 storage is required, because they all use
Alg. A5.5.1 which requires L and H to be known simultaneously. The
hookstep algorithms and any algorithms using unfactored secant updates
also require both L and H.
4) The vector storage required by each module is the sum of the vectors in
its parameter list, plus any vectors used as local variables. Item 1 of each
module's Storage Considerations section lists any vectors used as local vari-
ables. The implementor should determine the vector storage required by
the driver.
5) When implementing these algorithms in FORTRAN, all modules containing
matrices as parameters may require an additional parameter ndim giving
the actual row dimension of the matrices. This is required whenever the
matrix dimensions in the modules are given as variables instead of as fixed
integers. For example in a production implementation, any matrices used
usually will be passed by the user as an additional parameter to the main
driver. They will be declared in the user's program with some fixed dimen-
sions, say H(50.50), where the matrix dimension (50) is greater than or
equal to the problem dimension n. All matrices in the driver and the
modules of the system will then be declared as H(ndim.n) or L(ndim,n)
where ndim is an additional parameter passed by the user to the driver and
by the system to each module containing a matrix parameter. Here ndim
contains the number of rows in the matrix in the users program, ndim =50,
while n may be any number between 1 and 50. If instead the matrix dimen-
sions in the modules are given as (n,n), the algorithms 'will not work
correctly. The reason is that FORTRAN stores matrices by columns, and the
compiler must know the number of locations reserved for each column, i.e.
the number of rows, to find its place in the matrix correctly.
In any FORTRAN implementation, these considerations apply to any
modules where matrix dimensions are given as variables. The dimensions
must be (ndim.n) where ndim is an input parameter to the module contain-
ing the number of rows in the matrix in whatever subroutine or main pro-
gram it is declared with fixed integer dimensions. (In a class implementa-
tion of our system, this could be the driver.) An alternative for class pro-
jects is to declare all matrices in all modules with the same fixed integer
dimensions, say (50,50). In this case, the extra parameter ndim is not
needed and no modifications to our pseudo-code are required, but the sys-
tem will only work for n<50.
In most strongly-typed languages, the additional parameter ndim
would not be required, and our pseudo-code can be used as is For example
in PASCAL, one could declare a data type
MATRIX = ARRAY [1.. 50, 1..50] OF REAL
in the calling program. Again the matrix dimension (50) would be greater
than or equal to the largest problem dimension n to be used. Then all
matrices in all procedures in the system simply would be given the data
type MATRIX. To run the system with n>50, only the declaration of MATRIX
would have to be changed. The disadvantage of this scheme is that the same
word MATRIX must be used by all procedures in the system and by the cal-
ling program.

Appendix A 
283
II. 6 ALGORITHM D6.1.2. (UMEXAMPLE)
DRIVER FOR AN UNCONSTRAINED MINIMIZATION ALGORITHM
USING LINE SEARCH. UNITE DIFFERENCE GRADIENTS.
AND FACTORED SECANT APPROXIMATIONS TO THE HESSIAN
Purpose : Attempt to find a local minimizer x* of f (x) : Rn ->R starting from
X0, using a line search algorithm, finite difference gradients, and BFGS
Hessian approximations.
Input Parameters : nEZ (n>l), z0eRn, FN (the name of a user-supplied
function/: Rn->R)
plus optionally : typxERn, typf ER, f 'digits EZ, gradtol^R, steptol^R,
maxstep ER, itrdimit EZ, printcode EZ (for further information see
Algorithm D6.1.1 )
Input-Output Parameters : none (see item 2 under Storage Considerations,
Alg. D6.1.1)
Output Parameters : xfERn (the final approximation to xm), termcode EZ
(indicates which termination condition caused the algorithm to stop)
plus optionally : fc ER ( = f (zf)), gc ERn ( 
), other output param-
eters as desired by the implementor (see Section 1.4)
Meaning of Return Codes. Storage Considerations :
same as Algorithm D6.1.1
Algorithm :
(* Initialization section : *)
1. CALLMACHINEPS(mac/ieps)
2. CALL UMINCK (parameter list selected by implementor)
(* see UMINCK description *)
3. IF termcode < 0 THEN
3.1 Xj «- x0
3.2 RETURN from Algorithm D6.1.2 
(* write appropriate message, i!
desired *)
4. itncount «- 0
5. CALLFN(n,z0, fc)
6. CALLFDGRAD(n,x0, f C,FN, Sx, n, gc) 
(*Alg. A5.6.3 *)
7. CALL UMSTOPO (n, XG, fc, gc, Sx, typf, gradtol, termcode, consecmax)
(*Alg. A7.2.2 *)
8. IF termcode > 0
8T. THEN xf <-- x0
BE. CALL INITHESSFAC (n, fc, typf , Sx, Lc) 
(* Alg. A9.4.4 *)
9. xc <-- x0

284 
Appendix A
(* Iteration section : *)
10. WHILE termcode = 0 DO
10.1 itncount <- itncount + 1
10.2 CALL CHOLSOLVE (n, gc, Lc. SN) 
(* Alg.A3.2.3 *)
10.3 CALL LJNESEARCH (n, xc, fc, FN, gc, SN, sx, maxstep. steptol.
retcode , x+, f + , maxtaken] 
(* Alg. A6.3.1 *)
10.4 CALLFDGRAD (n.x +, f+, FN, Sx, n, g+ ) (* Alg. A5.6.3 *)
10.5 CALL UMSTOP (n, xc, x+, f + , g+, Sx, t y p f , retcode, gradtol, step-
tol, itncount, itnlimit, maxtaken, consecmax, termcode') 
(* Alg.
A7.2.1 *)
10.6 IF termcode > 0
10.6T THEN xf <- x+
10.6E 
ELSE (* calculate next Hessian approximation *)
10.6E.1 CALL BFGSFAC ( n , x c , x + . g c , g + , macheps, n , analgrad, 
10.6E.2 xc <- x +
10.6E.3 fc «- f+
10.6E.4 gc «- g +
(*END, WHILE loop 10*)
(* write appropriate termination message, if desired *)
(* RETURN from Algorithm D6.1.2 *)
(* END, Algorithm D6.1.2 *)

Appendix A 
285
SECTION III
DRIVER MODULES AND GUIDELINES FOR
NONLINEAR EQUATIONS
III.3 ALGORITHM D6.1.3. (NEDRTVER)
DRIVER FOR A MODULAR SYSTEM OF ALGORITHMS
FOR NONLINEAR EQUATIONS
Purpose : Attempt to find a root x* of F(x) : Rn Rn starting from x0, using
one of a variety of algorithms.
Input Parameters : n Z (n>1), 
FVEC (the name of a user-supplied
function F: Rn Rn that is a least once continuously differentiable)
plus optionally :
i) JAC — name of a user-supplied function for evaluating F(x). (F(x) is
denoted hereafter by J(x).)
ii) global Z, analjac Boolean, cheopF Boolean, factsec Boolean —
parameters used in choosing algorithmic options. 
These are
explained in Guideline 4. (Parameters that are not input are given
values by algorithm NE1NCK).
iii) typx Rn, typF Rn, Fdigits Z, fvectol R, steptol R, mintol R,
maxstep 
R, itrdim.it Z, 
— tolerances and constants used by
the algorithm. These are explained in Guideline 5. (Tolerances or
constants that are not input are given values by algorithm NEINCK).
iv) printcode 
Z — see Section 1.4 of this Appendix.
Input-Output Parameters : none (see however item 2 under Storage Con-
siderations)
Output Parameters : Xj Rn (the final approximation to x*), termcode^Z
(indicates which termination condition caused the algorithm to stop)
plus optionally :
FV 
Rn ( = F(xf)), 
Jc Rnxn ( = J ( x f ) ) , 
other output parameters as
desired by the implementor (see Section 1.4)
Meaning of Return Codes :
termcode <0 : algorithm terminated due to input error, see Alg.
NEINCK.
termcode >0 : algorithm terminated for reason given in Alg. A7.2.1.

286 
Appendix A
Storage Considerations :
1) Matrix and vector storage requirements are discussed in Guideline 3 and
6. Be sure to read item 5 in Guideline 3 if you are implementing these algo-
rithms in FORTRAN.
2) The names x0 and xf are used in this driver for clarity only. In the
implementation, x0 and xf can both share storage with xc.
3) Two global variables (FORTRAN COMMON), SF and FV+, must be shared
between this driver and Algorithm NEFN. See Algorithm NEFN for further
information.
Additional Considerations :
1) The List of Modules for Nonlinear Equations shows which modules
correspond to each step in the Description below. The choice between alter-
natives in the list is determined by the algorithmic option parameters
described in Guideline 4.
2) The Algorithm below is used for implementing the entire system of non-
linear equations algorithms. A simpler driver can be used to implement a
particular algorithm for nonlinear equations, as is illustrated by Algorithm
D6.1.4.
3) On some computing systems, it will be necessary to a supply dummy rou-
tine JAC for the case when the user doesn't supply a routine for evaluating
F (x). This dummy routine is required solely to allow compilation of the pro-
gram.
Description :
Initialization:
1) Calculate machine epsilon.
2a) Check input for reasonableness, assign default values to optional
parameters and tolerances that weren't input to user. (Return termcode to
driver.)
2b) If termcode < 0, terminate algorithm, returning xf = x0 and termcode.
If termcode = 0, set itncount 
0 and continue.
3) Calculate FV+ = F(x0), fc = 
Dr FV+
4a) Decide whether to stop. (Return termcode to driver).
4b) If termcode > 0, terminate algorithm, returning xf = X0 and termcode.
If termcode = 0, continue.
5) Calculate Jc = J(x0) or approximate it by finite differences.
6) Calculate 
= 
FV+.
7) Set xc = X0, FVC = FV+, and restart = TRUE.
Iteration :
1) itncount 
itncount + 1
2) Compute Newton step sN = — 
Fc or a variation if Jc is singular or ill-
conditioned. Also compute associated minimization model if a trust region
global algorithm is being used.
3) Choose x+ = xc + sc where sc = sN or a step chosen by the global stra-
tegy. F+ - F(x+) and f+ = Df FV+ are calculated during this step.
4) If Jc is being calculated by secant approximations and the algorithm has
bogged down, reset Jc to J(xc) using finite differences, recalculate gc. and
restart the iteration.
5) Calculate or approximate Jc = J(x+).
6) Calculate gc = 
D FV+.

Appendix A 
287
7a) Decide whether to stop. (Return termcode to driver).
7b) If termcode > 0, terminate algorithm, returning xf = x + and termcode .
If termcode - 0, continue.
B) Set xc 
x+, fc 
f+, 
FVC 
FV+ and return to step 1 of the iteration sec-
tion.
Algorithm :
(* Initialization section : *)
1. CALLMACHINEPS(macheps)
2. CALL NEINCK (parameter list selected by implementor)
(* see NEINCK description *)
3. IF termcode < 0 THEN
3.1 
Xf 
X0
3.2 RETURN from Algorithm D6.1.3 .(* write appropriate message, if
desired *)
4. itncount 
0
5. CALLNEFN (n,x0,fc)
(* NEFN also calculates FV+ = F(x0) and communicates it to the driver
Via a global parameter *)
6. CALL NESTOPO (n, x0, FV+, SF, fvectol, termcode. consecmax} 
(* Alg.
A7.2.4 *)
7. IF termcode > 0
7T. THEN xf 
x0
7E. ELSE (* calculate initial Jacobian *)
7E.1 IF analjac
7E.1T THEN CALL JAC (n, x0, Jc)
7E.1E ELSE CALL FDJAC (n. x0, FV+, FVEC, Sz, n, Jc) 
(* Alg. A5.4.1 *)
7E.2 FORi = 1 TOn DO
7E.3 FFC 
FV+
8. xc 
x0
9. restart 
TRUE
(* Iteration section : *)
10. WHILE termcode - 0 DO
10.1 itncount 
itncount + 1
10.2 IF analjac OR cheapF OR (NOTfactsec)
10. 2T THEN CALL NEMODEL (n. FVC , Jc , gc , Sf, Sx, mac heps , global, M,
HC.SN) 
(*Alg. A6.5.1 *)
10. 2E ELSE CALL NEMODELFAC (n, FVC , gc , SF, SX, mac heps , global,
restart, M, M2. Jc.Hc,sN) 
(* Alg. A6.5.1fac *)
10.3a IFglobo1 = 1 THEN

288 
Appendix A
CALL LINESEARCH (n. xc. fc, FVEC, gc, SN, Sx, maxstep, steptol,
retcode , x+, f +, maxtaken) 
(* Alg. A6.3. 1 *)
10. 3b ELSEIFglobal = 2 THEN
CALL HOOKDRIVER (n, xc, fc, FVEC, gc., M, Hc, SN, Sx,maxstep,
steptol, mac heps , itncount, prev , 
, ,, 
, 
, retcode, xH.
f+, maxtaken) 
(* Alg. A6.4.1 *)
10.3c ELSE 
(* global = 3 * )
CALL DOGDRIVER (n, xc, fc. FVEC, gc , M. SN, Sx, maxstep, step-
tol, , retcode , x + , f +, maxtaken) 
(* Alg. A6.4.3 *)
10.4 IF (retcode - l) AND (NOT restart) AND (NOT analjac) AND (NOT
cheapF)
10. 4T THEN 
(* secant method restart : recalculate Jc and redo itera-
tion *)
10.4T.1 CALLFDJAC (n,xc, FVC, FVEC, Sx, n. Jc) 
(* Alg. A5.4.1 *)
10.4T.2 gc 
* D * FVC
(* same as statement 7E.2 except substitute FVC for FV+ *)
10.4T.3 IF (global = 2) OR (global = 3) THEN 
-1
10.4T.4 restart 
TRUE
10.4E ELSE 
(* complete the iteration *)
10.4E.la IF analjac THEN
CALLJAC (n,x + , Jc)
10.4E.lb ELSE1F cheapF THEN
CALLFDJAC (n. x + . FV+, FVEC, SX, n, Jc) (*Alg. A5.4.1 *)
lO.4E.lc ELSEIF factsec THEN
CALL BROYFAC (n , xc . x + , FVC . FV+. n, Sx , SF, Jc . M. 
M2) 
(*
Alg. A8.3.2 *)
10.4E.ld ELSE 
(* factsec - FALSE *)
CALL BROYUNFAC (n, xc, x+. FVC , FV+, n. Sx, Jc) 
(• Alg.
A8.3.1 *)
10.4E.2 IF factsec
10.4E.2T THEN 
(* calculate gc using QR factorization*)
(*gc 
Jc DFFV, = QT D FFV+ : *)
10.4E.2T.1 FORi = 1 TO n DO
10.4E.2T.2 FOR i = n DOWNTO 1 DO
10.4E.2E ELSE
gc 
* 
*FV+
(* same as statement 7E.2 *)
10.4E.3 CALL NESTOP (n, xc , x+, FV. f+. gc, Sx, SF, retcode,
fvectol, steptol, itncount, itnlim.it, maxtaken. analjac, cheapF,

Appendix A 
289
mintol, consecmax, termcode} 
(* Alg. A7.2.3 *)
lO.4E.4a IF (termcode = 2) AND (NOT restart) AND (NOT analjac)
AND (NOT cheapF} THEN 
(* restart *)
GOTO 10.4T.1
lO.4E.4b ELSEIF termcode > 0 THEN
10.4E.4bT.l Xf 
x+
10.4E.4bT.2 IF termcode = 1 THEN FV+ 
FVC
10.4E.4c ELSE restart 
FALSE
10.4E.5 xc x +
10.4E.6 fc 
f 
+
10.4E.7 FVC FV+
(* END, IFTHENELSE 10.4 and WHILE loop 10 *)
(* write appropriate termination message, if desired *)
(* RETURN from Algorithm D6.1.3 *)
(* END, Algorithm D6.1.3 *)
III. 2. 
LIST OF MODULES FOR NONLINEAR EQUATIONS
The steps in the Description section of Driver D6.1.3 correspond to the
following modules. The steps in the Description that are not listed below
correspond to lines of code in the driver algorithm.
Initialization
Step 1 -- MACHINEPS
Step 2a -- NEINCK
Step 3 -- (NEFN / FVEC)
Step 4a -- NESTOPO
Step 5 -- JAC or FDJAC
Iteration
Step 2 -- (NEMODEL / QRDECOMP / CONDEST / QRSOLVE / CHOLDECOMP /
CHOLSOLVE) or (NEMODELfac / QRDECOMP / QFORM / CONDEST /
RSOLVE / CHOLDECOMP / CHOLSOLVE)
Step 3 -- LINESEARCH or LINESEARCHmod or (HOOKDRIVER / HOOKSTEP /
TRUSTREGUP) or (DOGDRIVER / DOGSTEP / TRUSTREGUP)
Step 4 -- FDJAC (see note below)
Step 5 -- JAC or FDJAC or BROYUNFAC or (BROYFAC / QRUPDATE)
Step 7a -- NESTOP
When a step above contains two or more modules or groups of modules
separated by the word "or", these are alternative choices selected by the
algorithmic option parameters. A given method would use only one choice
throughout the algorithm for each such step. Note that step 4 in the itera-
tion list above (FDJAC) is used only when secant approximations to the Jaco-
bian are being used.

290 
Appendix A
When two or more modules are listed above in parentheses separated
by slashes (/), the first module in the parenthesized group is called by the
driver, the remaining module(s) in the group are called by the first module.
For example. NEFN calls FVEC. In addition, the following modules call the
following service and function evaluation modules :
HOOKSTEP calls CHOLDECOMP and LSOLVE
LINESEARCH calls (NEFN / FVEC)
TRUSTREGUP calls (NEFN / FVEC)
The following modules also call their following subalgorithms :
CHOLSOLVE calls LSOLVE and LTSOLVE
QRSOLVE calls RSOLVE
QRUPDATE calls JACROTATE
III.3. 
GUIDELINE 4
CHOOSING ALGORITHMIC OPTIONS
FDR NONLINEAR EQUATIONS
The following are the algorithmic options available when using this sys-
tem of algorithms for nonlinear equations, and an indication of how to
choose them.
global — A positive integer designating which global strategy to use at each
iteration, as follows
= 1 Line search (Alg. A6.3.1)
-2 Hookstep trust region (Alg. A6.4.1)
=3 Dogleg trust region (Alg. A6.4.3)
On some problems, there may be rather large variations in the accuracy
and efficiency obtained by interchanging methods 1, 2, and 3 while keep-
ing all other parameters and tolerances unchanged. However, no
method seems clearly superior or inferior to the others in general, and
each is likely to be best on some problems. The three possibilities are
provided for comparison, and to allow a user to select the best method
for a particular class of problems.
Suggested default value : global = 1 (because this probably is the easiest
method to understand and to code)
anaijac -- A Boolean variable that is TRUE if a routine that computes the
analytic Jacobian matrix J ( x ) has been supplied by the user, and is
FALSE otherwise. If analytic Jacobians are not supplied, the system will
approximate the Jacobian at each iteration by finite differences or
secant approximations depending on the value of cheapF. The algo-
rithms in this system may perform more efficiently if analytic Jacobians
are provided; a routine to evaluate the analytic Jacobian should be sup-
plied if it is readily available.
Suggested default value : analjac = FALSE
cheapF - A Boolean variable that is TRUE if the objective function F(z) is

Appendix A 
291
inexpensive to evaluate and is FALSE otherwise. If analjac - TRUE,
cheapF is disregarded. If anaLjac - FALSE, cheapF is used to choose
the method of Jacobian approximation: finite difference Jacobians are
used if cheapF - TRUE, secant approximations to the Jacobian
(Broyden's updates) are used if cheapF = FALSE. Methods using finite
difference Jacobians usually will require fewer iterations than methods
using secant approximations on the same problem. Methods using
secant approximations usually will require fewer objective function
evaluations than methods using finite difference Jacobians (including the
function evaluations used for finite differences), especially for problems
with medium or large values of n. Thus if the cost of evaluating F(x] is
appreciable, cheapF should be set FALSE, otherwise cheapF should be
set TRUE.
Suggested default value : cheapF - FALSE
factsec — A Boolean variable that only is used if secant approximations to
the Jacobian are used, i.e. if anaLjac = FALSE and cheapF - FALSE, and
is disregarded in all other cases. When it is used, the value of factsec
only affects the algorithmic overhead of the algorithm, the results and
sequence of iterates are unaffected. If factsec = TRUE, the system uses
a factored secant approximation, updating an QR factorization of the
Jacobian approximation and requiring 0(n2) operations per iteration; if
factsec = FALSE, it uses an unfactored approximation, requiring 0(n3)
operations per iteration. (See Section 8.3 of the text for details.) A pro-
duction code should use factsec - TRUE because this is more efficient.
However, factsec - FALSE may be preferred for class projects as this
version is easier to understand.
Suggested default value : factsec - FALSE for class projects, factsec 
-
TRUE otherwise
III.4. 
GUIDELINE 5
CHOOSING TOLERANCES FOR NONLINEAR EQUATIONS
The following are the scaling, stopping and other tolerances used for
nonlinear equations, and an indication of appropriate values for them.
typx - see Guideline 2
typF — An n dimensional array whose ith component is a positive scalar
specifying the typical magnitude of the iih component function of F(x)
at points that are not near a root of F(x). typF is used to determine the
scale vector SF and diagonal scaling matrix Dp used throughout the
code; DF = diag 
((SF)1 
(Sf)n) where SF[i] = 1/ typF[i]. It should
be chosen so that all the components of DFF(x) have similar typical
magnitudes at points not too near a root, and should be chosen in con-
junction with fvectol as discussed below. It is important to supply
values of typF when the magnitudes of the components of F(x) are
expected to be very different; in this case, the code may work better
with good scale information than with Dp-I. If the magnitudes of the

292 
Appendix A
components of F(x) are similar, the code will probably work as well with
Df=I as with any other values.
Suggested default value : typF[i] = 1, i = 1, • • • ,n
Fdigits — A positive integer specifying the number of reliable digits
returned by the nonlinear equations function FVEC. If the components of
F(x) have differing numbers of reliable digits, Fdigits should be set to
the smallest of these numbers. The remainder of the discussion of Fdi-
gits is analogous to the discussion of fdigits in Guideline 2.
Suggested default value : Fdigits = -1
fvectol — A positive scalar giving the tolerance at which the scaled function
DfF(x) is considered close enough to zero to terminate the algorithm.
The algorithm is halted if the maximum component of DfF(x + )
is < fvectol. This is the primary stopping condition for nonlinear equa-
tions; the values of typF and fvectol should be chosen so that this test
reflects the user's idea of what constitutes a solution to the problem.
Suggested default value : fvectol - machepsl/3
steptol - see Guideline 2
mintol - A positive scalar used to test whether the algorithm is stuck at a
local minimizer of f(x) = 
where F ( x ) 0. The algorithm is
halted if the maximum component of the scaled gradient of / (z) at x+ is
<mintol, here V/(x) = J ( x )
T 
(x) 
and the scaled value of f(x+) is
denned as for minimization (see gradtol. Guideline 2). mintol should be
set rather small to be sure this condition isn't invoked inappropriately.
Suggested default value : mintol =• macheps2/3
maxstep — see Guideline 2
itnlimit --see Guideline 2
8 — see Guideline 2
III. 5. 
GUIDELINE 6
STORAGE CONSIDERATIONS FOR NONLJNEAR EQUATIONS
The storage considerations for nonlinear equations are closely related
to those for unconstrained minimization given in Guideline 3; please read
Guideline 3 before Guideline 6. The following are additional remarks that
apply to the algorithms for nonlinear equations.
l) The entire system of algorithms for nonlinear equations uses three nxn
matrices, J, M, and H. J is used to store the analytic or finite difference
Jacobian. When factored secant updates are used, J also is used to hold the
matrix Z - QT used in Algorithms A3.4.1 and AB.3.2. M is used to hold the
(compressed) QR factorization of J; the lower triangle of M also is used to
store the matrix L used in the global portion of the algorithm. H is used by
the global portion of the algorithm; only the upper triangle including the
main diagonal of H is used. If analytic Jacobians, finite difference Jacobians

Appendix A 
293
or unfactored secant approximations are used (i.e anything but factored
secant approximations), H easily can share storage with M if the algorithms
are modified slightly as described in item 2 below. This reduces the matrix
storage requirement to two nxn matrices. In addition, when analytic or
finite difference Jacobians are used, J also can share storage with M if
several additional modifications are made as indicated in item 3 below. This
reduces the matrix storage requirement to one nxn matrix, but this reduc-
tion is not possible when secant updates are used. When factored secant
approximations to the Jacobian are used, H can share storage with M
only if some fairly substantial modifications are made as indicated in item 4
below.
2) To allow H to share storage with M when analytic Jacobians, finite
difference Jacobians or unfactored secant approximations are used, Algo-
rithms A5.5.2, A64 1-2, and A6.4.5 must be modified as described in item 2
of Guideline 3. In addition, the following modifications must be made to
Algorithm A6.5.1 and Driver D6.1.3 :
Algorithm A6.5.1
i) Change output parameter H Rnxn to output parameter hdiag Rn
ii) Change H [ i , j ] to M[i,j] on lines 4T.1.1, 4T.3.1 and 4E.5.1.2.
iii) Change H[l,j] to M[l,j] online 4T.2.
iv) Change H[j,i] to M[j,i] on line 4T.3.1.
v) Change the body of the FOR loop on line 4T.4 to
hdiag [i] 
M[i,i] + • • • (rest is unchanged)
vi) On line 4T.5, change the parameter H to hdiag
vii) Change H[i,i] to hdiag [i] on line 4E.5.1.1.
Driver D6.1.3
i) On lines 10.2T and 10.3b, change the parameter Hc to hdiag
3) When analytic or finite difference Jacobians are used, the matrices / and
M may share storage simply by combining J and M into one parameter in
the call and parameter list of Algorithm A6.5.1, changing J[i,j] to M[i,j] in
line 1.1 of Algorithm A6.5.1, and replacing all remaining parameters M in
Driver D6.1.3 by J. The only further modification required is to revise steps
4T.1-4 of Algorithm A6.5.1 to form H 
RTR instead of H 
JT 
J. Since H
and M (which contains R in its upper triangle) also may share storage as
described in item 2 above, this is a bit tricky. An easy way to accomplish it
is to use the lower triangle of M, which is unoccupied at that time, as tem-
porary storage for H. The details of this conversion are left as an exercise.
4) When factored secant approximations to the Jacobian are used, the
matrix H may share storage with M only if the following changes are made
to the system of algorithms. The details are left as an exercise.
i) Factored secant updates are not allowed when global = 2.
ii) Modifications similar to those described in item 2 above are made to
Algorithm A6.5.1fac and Driver D6.1.3.
iii) In steps 3T. 1-4 of Algorithm A6.5.Ifac, RTR is formed in the lower tri-
angle of M, and the CHOLDECOMP routine called by step 3T.5 is replaced
by one that does the decomposition in place in the lower triangle of the
matrix. (CHOLDECOMP as written inputs an upper triangular matrix and
outputs a lower triangular matrix.)

294 
Appendix A
III.6 ALGORITHM D6.1.4. (NEKXAMPLF)
DRIVER FOR A NONIJNEAR EQUATIONS ALGORITHM
USING DOGLEG AND
FINITE DIFFERENCE JACOBLAN APPROXIMATION
Purpose : Attempt to find a root xm of F(x) : Rn Rn starting from x0, using
a dogleg algorithm with finite difference Jacobians
Input Parameters : n Z (n>l), x0 Rn, FVEC (the name of a user-supplied
function F: Rn Rn that is a least once continuously differentiable)
plus optionally : typx Rn, typF Rn. Fdigits Z. fvectol R, steptol R,
mintol R, maxstep R, itnlimit Z, 
R, printcode Z (for further
information see Algorithm D6.1.3)
Input-Output Parameters : none (see item 2 under Storage Considerations,
Alg. D6.1.3)
Output Parameters : Xf Rn (the final approximation to XM), termcode Z
(indicates which termination condition caused the algorithm to stop)
plus optionally :
FV 
Rn ( = F(x f)), 
Jc Rnxn ( 
( x f ) ) , 
other output parameters 
as
desired by the implementor (see Section 1.4)
Meaning of Return Codes. Storage Considerations :
same as Algorithm D6.1.3
Algorithm :
(* Initialization section : *)
1. CALLMACHINEPS(mocheps)
2. CALL NEINCK (parameter list selected by implementor)
(* see NEINCK description *)
3. IF termcode < 0 THEN
3. 1 Xf 
X0
3.2 RETURN from Algorithm D6.1.4 
(* write appropriate message, if
desired *)
4. itncount 
0
5. CALLNEFN(n,x 0,F c)
(* NEFN also calculates FV+ = F(x0) and communicates it to the driver
via a global parameter *)
6. CALL NESTOPO (n. x0, FV+, SF, fvectol, termcode, consecmax) 
(* Alg.
A7.2.4 *)
7. IF termcode > 0
7T. THEN Xf 
x0
7E. ELSE (* calculate initial finite difference Jacobian *)
7E.1 CALL FDJAC (n. x0, FV+, FVEC. S x . n , J c ) (* Alg. A5.4.1 •)

Appendix A 
295
7E.2 FORi = ITOn DO
7E.3 FFC 
FV+
B. 
xc 
x0
9. restart 
TRUE
(* Iteration section : *)
10. WHILE termcode = 0 DO
10.1 ifncount itncount + 1
10.2 CALL NEMODEL (n, FVC , Jc, gc. SF, Sx, macheps , global , M . Hc , SN)
(*Alg. A6.5.1 *)
10.3 CALL DOGDRIVER (n. xc, fc 
FVEC, gc. M, SN, Sx, maxstep, steptol,
6, retcode , x+, f +, maxtaken) 
(* Alg. A6.4.3 *)
10.4 CALLFDJAC (n, x+, FV+, FVEC, Sx n, Jc) (* Alg. A5.4.1 *)
10.5 gc *- 
* 
*FV+
(* same as statement 7E.2 *)
10.6 CALL NESTOP (n, xc, x+, FV+. f + , gc, Sx, SF, retcode, fvectol,
steptol, itncount, itnlimit , maxtaken, analjac , cheap F , mintol.
consecmax , termcode) (* Alg. A7.2.3 *)
10.7 IF termcode > 0
THEN xf 
x +
ELSE restart 
FALSE
10.8 xc 
x+
10.9 fc f 
+
10.10 FVc FV+
(*END, WHILE loop 10*)
(* write appropriate termination message, if desired *)
(* RETURN from Algorithm D6.1.4 *)
(* END, Algorithm D6. 1.4 *)

296 
Appendix A
SECTION IV. 
INDIVIDUAL MODULES
IV. 1. MODULES SUPPLIED BY THE USER
The following are the specifications for the user-supplied functions that are
required or optional when using this system of algorithms for unconstrained
minimization or for solving systems of nonlinear equations.
ALGORITHM FN
ROUTINE FDR EVALUATING UNCONSTRAINED MINIMIZATION
OBJECTIVE FUNCTION / (x)
Purpose : Evaluate the user-supplied function f (x) : Rn R at a point xc.
Input Parameters : n Z, xc .Rn
Input-Output Parameters : none
Output Parameters : fc R( = f (xc))
Description :
The user must supply this routine when using this system of algorithms for
unconstrained minimization. It may have any name (except the name of
any routine in this package); its name is input to Driver D6.1.1. Its input and
output parameters must be exactly as shown (or all the calls to FN in the
system of algorithms must be changed). The input parameters n and xc
may not be altered by this routine; the routine must assign to fc the value
of the objective function at xc .
ALGORITHM GRAD
ROUTINE FOR EVALUATING GRADIENT VECTOR V/ (x ) (Optional)
Purpose : Evaluate the user-supplied gradient f(x) : Rn Rn of the objec-
tive function f (x) at a point xc. ( f(x)[i] = d f ( x ) / 
d x [ i ] )

Appendix A 
297
Input Parameters : n Z, xc Rn
Input-Output Parameters: none
Output Parameters : g Rn ( = f (xc))
Description :
The user optionally may supply this routine when using this system of algo-
rithms for unconstrained minimization (see analgrad in Guideline l). It may
have any name (except the name of any routine in this package); its name is
input to Driver D6.1.1. Its input and output parameters must be exactly as
shown (or all the calls to GRAD in the system of algorithms must be
changed). The input parameters n and xc may not be altered by this rou-
tine; the routine must assign to g the value of the gradient of the objective
function at xc.
ALGORITHM HESS
ROUTINE FOR EVALUATING HESSIAN MATRIX f (x ) (Optional)
Purpose : Evaluate the user-supplied Hessian 2f (x) : Rn Rnxn of the
objective 
function 
/ (x) 
at 
a 
point 
zc.
( 
(x)[i,;] = 2 f(x)/ dx[i]dx\j]\ it is assumed that /(x) is at least
twice continuously differentiable so that 2f (x) is symmetric.)
Input Parameters : n Z, xc Rn
Input-Output Parameters: none
Output Parameters : H Rnxn symmetric ( = 2f (xc))
Storage Considerations :
1) Only the upper triangle of H, including the main diagonal, is used by the
remainder of the system of algorithms. Thus, no values need to be inserted
in the lower triangle of H, i.e., H [ i , j ] where i>j. If the lower triangle of H
is filled, it will be ignored, but no harm will be caused to the remainder of
the system of algorithms.
2) There are no changes to this algorithm if one is economizing on matrix
storage.
3) Algorithm HESS may require an additional input parameter ndimif these
algorithms are implemented in FORTRAN — see item 5 of Guideline 3.
Description :
The user optionally may supply this routine when using this system of algo-
rithms for unconstrained minimization (see analhess in Guideline l). It may
have any name (except the name of any routine in this package); its name is
Input to Driver D6.1.1. Its input and output parameters must be exactly as
shown (or all the calls to HESS in the system of algorithms must be
changed). The input parameters n and xc may not be altered by this

298 
Appendix A
routine; the routine must assign to H the value of the Hessian of the objec-
tive function at xc.
ALGORITHM FVEC
ROUTINE FOR EVALUATING NONLINEAR EQUATIONS
FUNCTION F(x)
Purpose : Evaluate the user-supplied function vector F(x) : Rn Rn at a
point xc .
Input Parameters : n Z, xc Rn
Input-Output Parameters : none
Output Parameters : Fc Rn ( = F(xc))
Description:
The user must supply this routine when using this system of algorithms to
solve systems of nonlinear equations. It may have any name (except the
name of any routine in this package); its name is input to Driver D6.1.3.
However if its name is not FVEC, then the word FVEC on line 2 of Algorithm
NEFN must be changed to the name of this routine (see Algorithm NEFN for
clarification). Its input and output parameters must be exactly as shown (or
all the calls to FVEC in the system of algorithms must be changed). The
input parameters n and xc may not be altered by this routine; the routine
must assign to Fc the value of the nonlinear equations function vector at xc .
ALGORITHM JAC
ROUTINE FOR EVALUATING JACOBIAN MATRIX J ( x ) (Optional)
Purpose : Evaluate the user-supplied Jacobian J ( x ) : Rn Rnxn of the func-
tion vector F(x) at a point xc. (J[i,j] = 
f i ( x ) / 
x[j] where f i ( x ) is
the ith component function of F(x).)
Input Parameters : n Z, xc Rn
Input-Output Parameters : none
Output Parameters : JRnxn ( = J ( x e ) )

Appendix A 
299
Storage Considerations:
1) The full matrix J is used.
2) There are no changes to this algorithm if one is economizing on matrix
storage.
Description :
The user optionally may supply this routine when using this system of algo-
rithms for solving systems of nonlinear equations (see analjac in Guideline
4). It may have any name (except the name of any routine in this package);
its name is input to Driver D6.1.3. Its input and output parameters must be
exactly as shown (or all the calls to HESS in the system of algorithms must
be changed). The input parameters n and xc may not be altered by this
routine; the routine must assign to J the value of the Jacobian of the non-
linear equations function vector at xc.
IV. 2. 
MODULES SUPPLIED BY THE IMPLEMENTOR
ALGORITHM UMINCK
CHECKING INPUT PARAMETERS AND TOLERANCES
FOR UNCONSTRAINED MINIMIZATION
Purpose : Check values of algorithmic options, tolerances, and other param-
eters input by the user to the unconstrained minimization driver, and
assign values to algorithmic options and tolerances not input by the
user, and to the constants Sx and n.
Input Parameters : n Z, macheps R,
plus typx Rn and f digits Z if input by the user to the unconstrained
minimization driver
Optional Input or Output Parameters : typf 
R, gradtol R, steptol R,
maxstep R, itnlimit Z, printcodecZ (see Additional Consideration 1
below); 
(see Additional Consideration 2 below); global eZ,
analgrad Boolean, 
analhess eBoolean, 
cheap f Boolean,

300 
Appendix A
factsec Boolean (see Additional Consideration 3 below)
Output Parameters : Sx Rn (see Additional Consideration 4 below), n R,
termcode Z
Meaning of Return Codes :
termcode = 0 : all input satisfactory or corrected by this routine
termcode < 0 : fatal input error found, as follows
termcode = — 1 : n < 1
termcode < — 1 : other termination codes assigned by the implementor
of Algorithm UMINCK
Storage Considerations :
1) No additional vector or matrix storage is required.
2) If typx is input by the user, it may share storage with Sx, that is,
together they may be one input-output parameter to this algorithm.
Additional Considerations :
1) The values of t y p f , gradtol, steptol, maxstep, and itrdimit either must
be input by the user to the unconstrained minimization driver, or must be
assigned by Algorithm UMINCK. The choice is up to the implementor of this
system of algorithms. Values input by the user optionally may be checked
by Algorithm UMINCK. Values assigned by Algorithm UMINCK either may be
the default values given in Guideline 2, or other values selected by the
implementor. (x0 is used to calculate the default value of maxstep.) If
printcode is used as discussed in Section 1.4 of this Appendix, it also should
be assigned a value by the user or by Algorithm UMINCK.
2) 6 must be given a value by the user or by Algorithm UMINCK if global = 2
or 3; it is ignored if global = 1 or 4. See step 4 below.
3) When implementing the full system of algorithms for unconstrained
minimization (Driver D6.1.1), global, analgrad, analhess, cheapf, 
and
factsec either must have values input to Driver D6.1.1 or must be assigned
values by Algorithm UMINCK. The same discussion as in item 1 above applies
here. Suggestions for values of these algorithmic options are given in Guide-
line 1. If one is implementing a subset of the system of algorithms for
unconstrained minimization, such as Driver D6.1.2, some or all of these five
parameters may not be required.
4) If scaling is not being implemented in the entire system, the output
parameter Sx and step 2 below are eliminated.
Description:
1) If n < 1 set termcode to -1 and terminate Algorithm UMINCK.
2) If typx was input by the user, set S x[i] to (1/ typx[i]), i = l, 
• ,n, oth-
erwise set Sx[i] - 1, i = l, • • • ,n.
3) If fdigits was input by the user, set 77 to max macheps. 10 - f d i g i t s }, or to
macheps if fdigits = -1. Otherwise, set 77 to macheps or estimate it, for
example by the routine of Hamming [1973] given in Gill, Murray and Wright
[1981], Section 8.5.2.3. If 77 > 0.01, a negative termcode probably should be
returned.
4) If global = 2 or 3 and no value was input for , set 6 to -1.
5) Assign values to algorithmic options and tolerances not input by the
user, and optionally check those that were input by the user, as discussed in

Appendix A 
301
Additional Considerations 1 and 3 above. Note: if global = 2 and analhess =
FALSE and cheapf 
= FALSE, factsec must be set to FALSE. (See Guideline
1.)
ALGORITHM NEINCK
Purpose : Check values of algorithmic options, tolerances, and other param-
eters input by the user to the nonlinear equations driver, and assign
values to algorithmic options and tolerances not input by the user, and
to the constants Sx, SF, and 77.
Input Parameters : n Z, mac heps R,
plus typx Rn, typF Rn, and Fdigits Z if input by the user to the non-
linear equations driver
Optional Input or Output Parameters : fvectol R, steptol R, mintol R,
maxstep 
R, itnlimit Z, printcode 
Z (see Additional Consideration 1
below); 
R 
(see Additional Consideration 2 below); global Z,
analjac Boolean, cheapF Boolean, factsec EBoolean (see Additional
Consideration 3 below)
Output Parameters : Sz Rn, SF Rn (see Additional Consideration 4 below),
termcode eZ
Meaning of Return Codes :
termcode = 0 : all input satisfactory or corrected by this routine
termcode < 0 : fatal input error found, as follows
termcode = — 1 : n < 1
termcode < — 1 : other termination codes assigned by the implementor
of Algorithm NEINCK
Storage Considerations :
1) No additional vector or matrix storage is required.
2) If typx or typF are input by the user, they may share storage with Sx
and SF respectively, that is, each pair may be one input-output parameter
to this algorithm.
Additional Considerations :
l) The values of fvectol , steptol , mintol , maxstep , and itrdimit either
must be input by the user to the nonlinear equations driver, or must be
assigned by Algorithm NEINCK. The choice is up to the implementor of this
system of algorithms. Values input by the user optionally may be checked
CHECKING INPUT PARAMETERS AND TOLERANCES
FOR NONLINEAR EQUATIONS

302 
Appendix A
by Algorithm NEINCK. Values assigned by Algorithm NEINCK either may be
the default values given in Guidelines 2 and 5, or other values selected by
the implementor. (x0 is used to calculate the default value of maxstep.) If
printcode is used as discussed in Section 1.4 of this Appendix, it also should
be assigned a value by the user or by Algorithm NEINCK.
2) 5 must be given a value by the user or by Algorithm NEINCK if global - 2
or 3; it is ignored if global - 1. See step 5 below.
3) When implementing the full system of algorithms for nonlinear equations
(Driver D6.1.3), global, analjac, cheapF. and factsec either must have
values input to Driver D6.1.3 or must be assigned values by Algorithm
NEINCK. The same discussion as in item 1 above applies here. Suggestions
for values of these algorithmic options are given in Guideline 4. If one is
implementing a subset of the system of algorithms for nonlinear equations,
such as Driver D6.1.4, some or all of these four parameters may not be
required.
4) If scaling is not being implemented in the entire system, the output
parameters Sz and Sf and steps 2 and 3 below are eliminated.
Description :
1) If n < 1 set termcode to -1 and terminate Algorithm NEINCK.
2) If typx was input by the user, set Sx[i] to (1/ typx[i]), i = l, 
• ,n, oth-
erwise set Sx[i] = l,i = l, • • ,n.
3) If typF was input by the user, set Sf[i] to (1/ typF[i]), i = l, • • .n, oth-
erwise set Sf[i] = l,i = l , - - ' , n .
4) If Fdigits was input by the user, set n to max macheps, 10-fdigits }, or to
macheps if Fdigits = -1. Otherwise, set 77 to macheps or estimate it, for
example by the routine of Hamming [1973] given in Gill, Murray and Wright
f 1981], Section 8.5.2.3 If n > 0.01, a negative termcode probably should be
returned.
5) If global = 2 or 3 and no value was input for , set 6 to -1.
6) Assign values to algorithmic options and tolerances not input by the
user, and optionally check those that were input by the user, as discussed in
Additional Considerations 1 and 3 above.
IV. 3. 
ALGORITHMIC MODULES
ALGORITHM NEFN
CALCULATING THE SUM OF SQUARES FOR NONIJNEAR EQUATIONS

Appendix A 
303
Purpose : Evaluate the nonlinear equations function F(x) at x+, and calcu-
late 
f+ 
DFF(x+)
Input Parameters : n Z, x 
Rn
Input-Output Parameters : none
Output Parameters : f + R
Storage Considerations :
l) 
In addition to the above parameters, the input variable SF Rn
(DF = diag ((SF)1- • • • - (S f)n)) and 
the output variable FV+ Rn( = F(x+))
must be passed as global variables between NEFN and the nonlinear equa-
tions driver D6.1.3. (In FORTRAN, this is done by placing SF and FV+ in a
labeled COMMON block in NEFN and Alg. D6.1.3.) This is the only use of glo-
bal variables in the entire system of algorithms. It is required so that the
parameters of NEFN and the unconstrained minimization objective function
FN are the same; this enables the identical global routines to be applicable
to both unconstrained minimization and nonlinear equations.
Additional Considerations :
1) If the name of the user-supplied routine that evaluates the nonlinear
equations function vector is not FVEC (see Algorithm FVEC in Section IV.1 of
this appendix), then the word FVEC on line 2 of this algorithm must be
changed to the name of this user-supplied routine. This is not necessary if
the name of the user-supplied routine for F(x) can be passed as a global
variable between Alg. D6.1.3 and NEFN; in FORTRAN this is not possible.
Algorithm :
1. CALL FVEC(n, x+, FV+ ) (* FV+ 
F(x+) *)
2. 
f+
"
(* RETURN from Algorithm NEFN *)
(* END, Algorithm NEFN *)
ALGORITHM A1.3.1 (MACHINEPS) - CALCULATING MACHINE EPSILON
Purpose : Calculate machine epsilon
Input Parameters : none
Input-Output Parameters : none
Output Parameters : macheps 
R

304 
Appendix A
Storage Considerations :
l) No vector or matrix storage is required.
Algorithm :
1. macheps 
1
2. REPEAT
macheps 
macheps / 2
UNTIL (1 + macheps) = 1
3. macheps 
2 * macheps
(* RETURN from Algorithm Al.3.1 *)
(* END. Algorithm Al.3.1*)
ALGORITHM A3.2.1 (QRDECOMP) - QR DECOMPOSITION
Purpose : Calculate the QR decomposition of a square matrix M using the
algorithm in Stewart [1973], Upon termination of the algorithm, the
decomposition is stored in M, M1, and MZ as described below.
Input Parameters : n Z
Input-Output Parameters : M Rnxn (on output, Q and R are encoded in M,
M1, and M2 as described below)
Output Parameters : Ml Rn, M2 Rn, sing Boolean
Storage Considerations :
1) No additional vector or matrix storage is required.
2) On output, Q and R are stored as described by Stewart : R is contained
in the upper triangle of M except that its main diagonal is contained in M2,
and 
QT = Qn_1 • • • Q1 where Qj = I - (uj 
/ 
). uj[i] = 0, i = l. • • • ,j-!,
,-[i] = M[i.j], i-j, 
• • • ,n, 
j = M1[j].
3; There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 6.
Description :
The QR decomposition of M is performed using Householder transforma-
tions by the algorithm in Stewart [1973]. The decomposition returns
sing - TRUE if singularity of M is detected, sing - FALSE otherwise. The
decomposition is completed even if singularity is detected.

Appendix A 
305
Algorithm :
1. sing 
FALSE
(* sing becomes TRUE if singularity of M is detected during the decom-
position *)
2. FORk = lTOn-1 DO
2.1 77 max{ 
M [ i , k ] \ l
2.2 IF n =0
2.2T THEN 
(* matrix is singular *)
2.2T.1 Ml[k] 
0
2.2T.2 MZ[k] 
0
2.2T.3 sing 
TRUE
2.2E ELSE
(* form Qk and premultiply M by it *)
2.2E.1 FORi = k TOn DO
M[i,k] 
M[i,k] / n
2.2E.2 
sign(M[k,k]) *
2.2E.3 M[k.k] 
M[k,k] +
2.2E.4 
Ml[k] 
*M[k,k]
2.2E.5 M2[k] -n)*
2.2E.6 FORj = k + 1 TOn DO
2.2E.6.1
2.2E.6.2 FORi = * TOn DO
M[i.j] M[i,j] - 
*M[i,k]
3. IF M[n,n] = 0 THEN sing 
TRUE
4. M2[n] 
M[n, n]
(* RETURN from Algorithm A3.2.1 *)
(* END, Algorithm A3.2.1 *)
ALGORITHM A3.2.2 (QRSOLVE) - QR SOLVE
Purpose : Solve (QR)x - b for x. where the orthogonal matrix Q and the
upper triangular matrix R are stored as described in Algorithm A3.2.1.
Input Parameters : n Z, M Rnxn, Ml Rn, M2 Rn (Q and R are encoded
inM. Ml, and M2 as described in Algorithm A3.2.1)
Input-Output Parameters : b Rn (on output,b is overwritten by the solution
x)

306 
Appendix A
Output Parameters : none
Storage Considerations:
1) No additional vector or matrix storage is required.
2) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 6.
Additional Considerations:
1) Algorithm A3.2.2a must be a separate routine because it is also called
separately by Algorithm A3.3.1 and Algorithm A6.5. 1fac.
Description:
1) Multiply 6 by QT. QT is stored as Qn-1 • • Q1. where each Qj is a House-
holder transformation encoded as described in Algorithm A3.2.1. Thus this
step consists of premultiplying b by Qj, j=1, 
,n-l.
2) Solve Rx = QTb.
Algorithm :
(* b QTb *)
1. FOR; = 1 TOn-1 DO
(*b Qjb•)
1.1
1.2 FOR i =j TOn DO
b[i] 
b[i]- 
* M [ i , j ]
(* b R-lb *)
2. CALL RSOLVE(n, M. M2. 6) 
(* Alg A.3.2.2a *)
(* RETURN from Algorithm A3.2.2 *)
(* END, Algorithm A3.2.2 *)
ALGORITHM A3.2.2a (RSOLVE) - R SOLVE FOR QR SOLVE
Purpose : Solve Rx = b for x, where the upper triangular matrix R is stored
as described in Algorithm A3.2.1.
Input Parameters : n Z. M Rnxn. M2 Rn (M2 contains the diagonal of R,
the remainder of R is contained in the upper triangle of M)
Input-Output Parameters : b Rn (on output, b is overwritten by the solu-
tion x)

Appendix A 
307
Output Parameters : none
Storage Considerations :
1) No additional vector or matrix storage is required.
2) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 6.
Algorithm :
1. b[n] b[n]/ M2[n]
2. FOR i = n -1 DOWNTO 1 DO
(* RETURN from Algorithm A3.2.2a *)
(* END, Algorithm A3.2.2a *)
ALGORITHM A3.2.3 (CHOLSOLVE) - CHOLESKY SOLVE DRIVER
Purpose : Solve (LLT )s = —g for s
Input Parameters : n Z, g Rn, L Rnxn lower triangular
Input-Output Parameters: none
Output Parameters :
Storage Considerations:
1} No additional vector or matrix storage is required.
2) g is not changed by the solution process.
3) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 3.
Additional Considerations:
1) Algorithm A3.2.3a must be a separate routine because it is also called
directly by Algorithm A6.4.2 (HOOKSTEP).
Algorithm :
(* Solve Ly = g : *)
1. CALL LSOLVE (n.g.L.s) 
(* Alg. A3.2.3a *)
(* Solve LTs = y : *)
2. CALLLTSOLVE (n.s.L.s) 
(* Alg. A3.2.3b *)
3. s 
s

308 
Appendix A
(* RETURN from Algorithm A3.2.3 *)
(* END, Algorithm A3.2.3 *)
ALGORITHM A3.2.3a (LSOLVE) - L SOLVE
Purpose : Solve Ly = b for y
Input Parameters : n Z, b Rn , L Rn+n lower triangular
Input-Output Parameters : none
Output Parameters : y Rn
Storage Considerations :
1) No additional vector or matrix storage is required.
2) b and y are intended to be separate parameters. If the calling sequence
causes b and y to correspond to the same vector, the algorithm will work
and b will be overwritten.
3) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 3.
Algorithm :
I- y[1] b[1]/ L[1,1]
2. FOR i = 2 TO n DO
(* RETURN from Algorithm A3.2.3a *)
(* END, Algorithm A3.2.3a *)

Appendix A 
309
ALGORITHM A3.2.3b (LTSOLVE) -1. TRANSPOSED SOLVE
Purpose : Solve LTx = y for x
Input Parameters : n Z, y Rn, L Rnxn lower triangular
Input-Output Parameters : none
Output Parameters : x Rn
Storage Considerations :
1) No additional vector or matrix storage is required.
2) y and x are intended to be separate parameters. If the calling sequence
causes y and x to correspond to the same vector, the algorithm will work
and y will be overwritten.
3) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 3.
Algorithm :
1. x[n] 
y[n] / L[n,n]
2. FORi = n-l 
DOWNTO 1 DO
(* RETURN from Algorithm A3.2.3b *)
(* END, Algorithm A3.2.3b *)
ALGORITHM A3.3.1 (CONDEST)
ESTIMATING THE CONDITION NUMBER OF
AN UPPER TRIANGULAR MATRIX
Purpose : Estimate the LI condition number of an upper triangular matrix
R, using an algorithm contained in Cline, Moler, Stewart and Wilkinson
[1979].
Input Parameters : neZ, Afe/?nXn, M2z:Rn (M2, contains the main diagonal
of R, the remainder of R is contained in the upper triangle of Af)
Input-Output Parameters : none
Output Parameters : estzR (an underestimate of the ll condition number of
R}

310 
Appendix A
Storage Considerations :
1) 3 n-vectors of additional storage are required, for p, pm, and x.
2) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 6.
Description :
1) est
2) Solve RTx = e for x, where et = ±1, i=l, • • • ,n, and the signs of the et's
are chosen by the algorithm in Cline, Moler, Stewart and Wilkinson, using
their equation (3.19).
3) Solve Ry - x for y . (In the implementation below, y overwrites x .)
4) est 
est •
Algorithm :
(* steps 1 and 2 set est
1. est
2. FORj =2TOn DO
2.1 temp 
|
i=l
2.2 est 
maxitemp, est]
(* steps 3-5 solve RTx=e , selecting e as they proceed *)
3. z[l] 1/ M2[l]
4. FOR i = 2 TO n DO
5. FOR j = 2 TO n DO
(* select ej and calculate x{J] *)
5.1 xp (1 -P[j])/ M2[j]
5.2 am 
(-1 -p[j])/ M2[j]
5.3 temp 
|xp |
5.4 tempm 
|zm|
5.5 FORi =j + l TOn DO
5.5.1 pm[i] p[i] + M[j,i] + xm
5.5.2 tempm 
tempm + (|pm[i]| / |M2[i]|)
5.5.3 p[i] p[i] + M[j,i] • xp
5.5.4 temp 
temp + (|p[i]| / |M2[i]|)
5.6 IF temp > tempm
5.6T THEN x[j] 
zp 
(* By = 1 *)
5.6E ELSE 
(* ej = -1 *)
5.6E.1 x [ j ] 
xm
5.6E.2 FOR i = j + 1 TO n DO
6. xnorm
7. est 
est / xnorm

Appendix A 
311
8. CALL RSOLVE(n. M. 112. z)
(* call Alg. A3.2.2a to calculate R - lx *)
9. xnorm
10 est 
est * xnorm
(* RETURN from Algorithm A3.3.1 *)
(* END. Algorithm A3.3.1 *)
ALGORITHM A3.4.1 (QRUPDATE) - QR FACTORIZATION UPDATE
Purpose : Given the QR factorization of A, calculate the factorization Q+R+
+ - Q(R+uvT) in 0(n)2 operations.
Input Parameters : n Z, u Rn , v Rn, methodtZ (=1 for nonlinear equa-
tions, 2 for unconstrained minimization)
Input-Output Parameters : Z Rnxn (only used when method = l. contains QT
on input. 
on output), M Rnxn (upper triangle contains R on input,
R.t. on output)
Output Parameters : none
Storage Considerations :
1) No additional vector or matrix storage is required.
2) When method = 2, Z is not used, and this algorithm requires only one
nxn matrix since the call of Alg. A3. 4.1 by Alg. A9.4.2 causes Z and M to
refer to the same matrix.
3) The first lower subdiagonal of M, as well as the upper triangle including
the main diagonal, are used at intermediate stages of this algorithm.
4) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guidelines 3 and 6.
Description :
R+uvT is premultiplied by 2(n-l) Jacobi rotations. 
The first n-1
transform UVT to the matrix 
and R to an upper Hessenberg
matrix RH. The last n-1 
transform the upper Hessenberg matrix
to the upper triangular matrix R+. If method = 1. QT is
premultiplied by the same 2(n— 1) Jacobi rotations to form 
. For further
details, see section 3.4 of the text.

312 
Appendix A
Algorithm :
0. FOR i: = 2 TO n DO
M[i, i - 1] 0
(*find the largest k such that u [ k ] 0 *)
1. k 
n
2. WHILE (u[kJ = 0) AND (k > 1) DO
k 
k-1
(* transform R+uvT to upper Hessenberg : *)
3. FOR i = k -1 DOWNTO 1 DO
3.1 CALL JACROTATE(n. i.u[i], -u[i + l], method, Z . M )
(*Alg. A3.4.1a*)
3.2 IFu[t] = 0
THENu[i] 
|u[i+l]|
ELSEu[i] 
+
4. FORj = 1TOn DO
M[l,j] 
M[l,j]+u[l]*v[j]
(* transform upper Hessenberg matrix to upper triangular : *)
5. FORi = 1 TO k -1 DO
CALL JACROTATE(n, i, M[i,i], -M[i+1,i], method. Z. M)
(* RETURN from Algorithm A3.4.1 *)
(* END, Algorithm A3.4.1 *)
ALGORITHM A3.4.U (JACROTATE) - JACOBI ROTATION
Purpose : premultiply M, and if method = l, Z, by the Jacobi rotation matrix
J(i.i+1.a.b) as described in section 3.4.
Input Parameters : n Z, i Z, 
R, 
b R. method Z ( = 1 for nonlinear
equations. 2 for unconstrained minimization)
Input-Output Parameters : Z Rnxn (only used when method = l), M Rnxn
Output Parameters : none
Storage Considerations :
same as for Algorithm A3.4.1
Description:
1)
2) New row i of M c * old row i of M — s * old row i +1 of M:
new row i +1 of M 
s * old row i of M + c * old row i +1 of M
3) If method = l, perform step 2 on Z

Appendix A 
313
Algorithm :
1. IF a = 0
IT. THEN
1T.1 c 
0
1T.2 s 
sign(b)
1E. ELSE
1E. 1 den 
+
1E.2 c 
a / den
1E.3 s 
6 / den
(* premultiply M by Jacobi rotation : *)
2. FOR j = i TO n DO
2.1 y 
M[i,j]
2.2 w M[i + l,j]
2.3 M[i,j] 
c *y -s * w
2.4 M[i+l,j] s *y + c * w
3. IF method = 1 THEN
(* premultiply Z by Jacobi rotation : *)
3.1 FOR j = 1 TO n DO
3.1.1 y 
Z [ i . j ]
3.1.2 
w 
Z[i + l,j]
3.1.3 Z [ i , j ] 
c *y -s *w
3.1.4 Z[i + l,j] 
s *y + c *w
(* RETURN from Algorithm A3.4.1a *)
(* END, Algorithm A3.4.1a *)
ALGORITHM A3.4.2 (QFORM)
FORIONG Q FROM THE QR FACTORIZATION
Purpose : Form the orthogonal matrix QT = Qn-1 Q1 from the House-
holder transformation matrices Q1 • • • Qn-i produced by the QR fac-
torization algorithm A3.2.1. (This is only required when the factored
form of Broyden's update is used.)
Input Parameters : n Z, M Rnxn. Ml Rn (Q is contained in M and M1 as
described in Algorithm A3.2. l)
Input-Output Parameters : none
Output Parameters : Z Rnxn (contains QT)

314 
Appendix A
Storage Considerations :
1) No additional vector or matrix storage is required.
2) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 6.
Description:
1) Z 
I
2) For k - 1 • • • n-l, premultiply Z by Qk, where Qk= I if M1|K]=0, Qk =
I - (uk )/ 
k 
otherwise, 
uk[i]=0, 
i = l, • • • ,Jb-l, 
uk[i]=M[i,k],
i=k, • • • ,n, 
k = M 1 [ k ]
Algorithm :
(• Z 
I:*)
1. FOR i - 1 TO n DO
1.1 FORj = 1 TOn DO
Z[i,j] 
0
1.2 Z[i,i] 
1
2. FORk = 1 TO n-l DO
2.1 
I F M l [ k ] 0 THEN
(* Z Qk * Z : *)
2.1.1 FORj = 1 TOn DO
2.1.1.1 
( M[i-k] *Z[i,j])/ 
M 1 [ k ]
2.1.1.2 FORi = k TOn DO
Z[i,j] Z[i,j] - 
*M[i.k]
(* RETURN from Algorithm A3.4.2 *)
(• END, Algorithm A3.4.2 *)
ALGORITHM A5.4. 1 (FDJAC)
FINITE DIFFERENCE JACOBIAN APPROXIMATION
Purpose : Calculate a forward difference approximation to J(xc) (the Jaco-
bian matrix of F(x) at xc ). using values of F(x)
Input Parameters : n Z, XC Rn , Fc Rn ( = F (xc)), FVEC (the name of
F: Rn-*Rn'). Sz Rn. n R
Input-Output Parameters : none
Output Parameters : J Rnxn J(xc)

Appendix A 
315
Storage Considerations:
1) One n-vector of additional storage is required for Fj.
2) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 6.
Additional Considerations:
l) See additional considerations, Alg. A5.6.3
Description:
Column j of J(xc) is approximated by (F(xc+hjej)-F(zc))/hj, where BJ is
the jth unit vector, and hj = rp * max| |xc [j ] \, I/ Sx [j ]} * sign(zc [j ]). Here
!/£",[;] is the typical size of |sc[j]| input by the user, and 77 = 10-DIGITS,
DIGITS the number of reliable base 10 digits in F(x). The corresponding
elements of J(xc) and J typically will agree in about their first (DIGITS/2)
base 10 digits.
Algorithm :
1. sqrteta
2. FOR j = 1 to n DO
(* calculate column j of J *)
2.1 stepsizej 
sqrteta. * max{| xc [j ] |, l/sz[j']} * sign(xc [j ])
(* to incorporate a different stepsize rule, change line 2.1 *)
2.2 tempj 
xc[j]
2.3 xc[j] 
xc[j] + stepsizej
2.4 stepsizej 
xc[j]—tempj
(* line 2.4 reduces finite precision errors slightly; see Section 5.4 *)
2.5 CALL FVEC(n, xc , Fj) 
(• Fj 
F(xc +stepsizej*ej) *)
2.6 FORi = 1 TOn DO
J[i,j] 
(Fj[i] - Fc[i]) / stepsizej
2.7 xc[j] 
tempj 
(* reset xc[j]*)
(* end of FOR loop 2 *)
(* RETURN from Algorithm A5.4.1 *)
(* END, Algorithm A5.4.1 *)
ALGORITHM A5.5.1 (MODELHESS)
FORMATION OF THE MODEL HESSIAN
Purpose : Find a >0 such that H + 
is safely positive definite,
where 
=0 if H is already safely positive definite. Then set

316 
Appendix A
H 
H+ /, and calculate the Cholesky decomposition LLT of H.
Input Parameters : n Z, Sx Rn, macheps R
Input-Output Parameters : H Rnxn symmetric
Output Parameters : L Rnxn lower triangular
Storage Considerations :
1) No additional vector or matrix storage is required.
2) Only the upper triangle of H and the lower triangle of L, including the
main diagonals of both, are used. It is assumed for simplicity that each is
stored in a full matrix. However, one can economize on matrix storage by
modifying the algorithm as explained in Guideline 3.
Description:
1) If H has any negative diagonal elements or the absolute value of the larg-
est off-diagonal element of H is greater than the largest diagonal element of
H, H 
H + 
where 
is chosen so that the new diagonal is all posi-
tive, with the ratio of its smallest to largest element >(raoc/ieps)^, and the
ratio of its largest element to the largest absolute off-diagonal is
> 1+2 (macheps )
2) A perturbed Cholesky decomposition is performed on H (see Alg.
A5.5.2). It results in H+D = LLT, D a non-negative diagonal matrix that is
implicitly added to H during the decomposition and contains one or more
positive elements if H is not safely positive definite. On output, moxodd
contains the maximum element of D.
3) If moxodd = 0 (i.e. D=0), then H = LLT is safely positive definite and the
algorithm terminates, returning H and L. Otherwise, it calculates the
number sdd that must be added to the diagonal of H to make (H + sdd*/)
safely strictly diagonally dominant. 
Since both (H + mcLrodd*/) and
(H + sdd*/) 
are 
safely 
positive 
definite, 
it 
then 
calculates
= min{moxodd, sdd}, H 
H + 
, calculates the Cholesky decomposi-
tion LLT of H, and returns H and L.
Algorithm :
(* steps 1, 14. and 15 below are omitted if scaling is not being implemented
*)
(* scale H 
where Dx = diag ((S z) l 
(Sx)n) *)
1. FORi = 1 TOn DO
1.1 FOR; =i TOn DO
H[i,j} 
H[i,j}/ (S,[i] *Sx[j])
(* step 1 in Description : *)
2. sqrteps 
(macheps')
3. maxdiag 
max{H[i,i]}
4. mindiog 
min{H[i,i]}

Appendix A 
317
5. maxposdiag 
max|0, maxdiag \
6. IF mindiag < sqrteps * maxposdiag
6T. THEN (* 
will contain amount to add to diagonal of H before attempt-
ing the Cholesky decomposition *)
6T.1 
2 * (maxposdiag — mindiag) * sqrteps — mindiag
6T.2 maxdiag 
maxdiag +
6E. ELSE 
0
7. maxoff 
max ]H[i,j]|
8. IF maxoff 
* (l + 2 * sqrteps) > maxdiag THEN
6.1 
, 
+ (maxoff 
— maxdiag) + 2 * sqrteps * maxoff
8.2 maxdiag 
maxoff 
* (l + 2 *sqfr£eps)
9. IF maxdiag = 0 THEN 
(* H=0 *)
9.1 
1
9.2 maxdiag 
1
10. IF 
> 0 THEN 
(*H 
H+ 
I 
*)
10.1 FORi = 1 TOn DO
H[i.i] H[i,i] +
11. maxoff 
L 
(* see Alg. A5.5.2 *)
(* step 2 in Description : call perturbed Cholesky decomposition *)
12. CALL. CHOLDECOMP (n. H, maxoff I, macheps , L, maxadd) 
(* Alg.
A5.5.2 *)
(* step 3 in Description : *)
13. IF maxadd > 0 THEN
(* H wasn't positive definite *)
13.1 maxev 
H [ l , l ]
13.2 minev 
H[l,l]
13.3 FORi = 1 TOn DO
13.3.1 offrow
13.3.2 maxev 
max{maxev, H[i,i]+ 
offrow]
13.3.3 minev 
min{minev, H[i,i]— o f f r o w }
13.4 
sdd 
(maxev —minev) * sqrteps —minev
13.5 sdd 
max{sdd, 0}
13.6 
min{maxadd. sdd}
(*H 
H 
+ 
: *)
13.7 FORi = 1 TOn DO
H[i,i] H[i,i] +
(* call Cholesky decomposition of H : *)
13.8 CALL CHOLDECOMP (n, H. 0, macheps . L, maxadd) 
(* Alg. A5.5.2 *)
(* unscale H 
DXHDX, L DxL *)
14. FOR i = 1 TO n DO

318 
Appendix A
14.1 FOR ; = i TO n DO
H[ij]-H[ij] 
*S,[i] 
* S x [ j ]
15. FOR i = 1 TO n DO
15.1 FOR; = iTOiDO
L[ij}^L[i.j] 'S,[i]
(* RETURN from Algorithm A5.5.1 *)
(* END, Algorithm A5.5.1 *)
ALGORITHM A5.5.2 (CHOLDECOMP)
PERTURBED CHOLESKY DECOMPOSITION
Purpose : Find the LLT decomposition of H+D, D a non-negative diagonal
matrix that is added to H if necessary to allow the decomposition to
continue, using an algorithm based on the modified Cholesky decom-
position in Gill, Murray and Wright [1981].
Input Parameters : n Z, H Rnxn symmetric, maxoffl R, macheps R
Input-Output Parameters : none
Output Parameters : L Rnxn lower triangular, maxadd R
Storage Considerations :
1) No additional vector or matrix storage is required.
2) Only the upper triangle of H and the lower triangle of L, including the
main diagonals of both, are used. It is assumed for simplicity that each is
stored in a full matrix. However, one can economize on matrix storage by
modifying the algorithm as explained in Guideline 3.
Description:
The normal Cholesky decomposition is attempted. However, if at any point
the algorithm determines that H is not positive definite, or if it would set
L[j j] — minl or if the value of L [ j , j ] would cause any element L [ i . j ] , i>j,
to be greater than maxoffl, 
then a positive number D[j,j] implicitly is
added to H [ j , j ] . 
D[j,j] is determined so that L [ j , j ] is the maximum of
mini and the smallest value that causes max{ |L,[i,j]|} = maxoffl. 
This
strategy guarantees that L[i,i]>minl for all i, and 
| L [ i , j ] \ < m a x o f f l for
all i>j. This in turn implies an upper bound on the condition number of
H+D.
At the same time, the algorithm is constructed so that if minl=0 and //
is numerically positive definite, then the normal Cholesky decomposition is
performed with no loss of efficiency, resulting in H = LLT and D = 0. When

Appendix A 
319
Alg. A5.5.2 is called by Alg. A6.4.2, A6.5.1 or A6.5.1fac, the input parameter
maxo f f I will be zero and so minl will be zero. When Alg. A5.5.2 is called by
Alg. A5.5.1, minl will be positive, but D will still equal 0 if H is positive
definite and reasonably well conditioned. In general, the algorithm attempts
to create D not much larger than necessary.
For further information, including an explanation of the choice of
maxoffl, 
see GUI, Murray and Wright [1981],
Algorithm :
1. mini 
(macheps )1/4 * maxoffl
2. IF maxoffl 
= 0 THEN
(* this occurs when Alg. A5.5.2 is called with H known to be positive
definite by Alg A6.4.2 or Alg. A6.5.1; these lines are a finite precision
arithmetic precaution for this case *)
2.1 maxoffl
2a. minl2 
(macheps)1/2 * maxo f fl
3. maxadd 
0
(* maxadd will contain the maximum amount that is implicitly added
to any diagonal element of H in forming LLT = H+D *)
4. FOR j = 1 TO n DO
(* form column j of L *)
4 - 1 L [ j , j ] 
H [ j . j ] -
l
4.2 mirdjj 
0
4.3 FORi =j + 1 TOn DO
4.3.1 L [ i , j ] 
H[j,i]- 
L[i,k] 
* L [ j , k ] )
4.3.2 mijiljj max{ | L[i ,j ] \, minljj }
mirdjj 
.
4.4 
mrd]] *- max) 
*'*rr; mini I
JJ 
( m a x o f f L 
'
4.5 IF Z,[;',j ] > minljj2
4.5T THEN 
(* normal Cholesky iteration *)
i[;,;]-vTUTI
4.5E ELSE 
(* augment //[;,;]*)
4.5E.1 IF miT^;; < minlZ THEN
minljj «- mini 2
(* only possible when input value of maxoffl 
=0 *)
4.5E.2 maxadd «- max|maxadd, mirdjj2 - L[j ,j]}
4.5E.3 L[j 
,j] 
minljj
4.6 FORi =j + 1 TOn DO
L[i.j] L[i.j]/ L[i,j]
(* RETURN from Algorithm A5.5.2 *)
(* END, Algorithm A5.5.2 *)

320 
Appendix A
ALGORITHM A5.6. 1 (FDHESSG)
FINITE DIFFERENCE HESSIAN APPROXIMATION
FROM ANALYTIC GRADIENTS
Purpose : Calculate a forward difference approximation to 
f(xc,.), using
analytic values of f (x)
Input Parameters : n Z, xc Rn, g Rn( = f (xc)), GRAD (the name of
f: Rn Rn). Sz 
Rn, n R
Input-Output Parameters : none
Output Parameters : H Rn+n symmetric ( 
f 
(xc ))
Storage Considerations :
1) No additional vector or matrix storage is required.
2) Only the diagonal and upper triangle of H have correct values upon
return from Algorithm A5.6.1, because these are the only portions of H that
are referenced by the rest of the system of algorithms. However, the entire
matrix H is used at an intermediate stage of'this algorithm.
3) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 3.
Description :
1) Approximate 2f (xc ) by H using Algorithm A5.4. 1.
2) H (H+ HT) / 2.
Algorithm :
1. CALL FDJAC(n, xe.g, 
GRAD, S x , n , H )
(* Alg. A5.4.1 *)
2. FORi = 1 TOn-1 DO
2.1 FORj =i + l TOn DO
(* RETURN from Algorithm A5.6.1 *)
(* END, Algorithm A5.6. 1 *)
H[i.j] 
(H[i.j] + H [ j . i ] ) / 2

Appendix A 
321
ALGORITHM A5.6.2 (FDHESSF)
FINITE DIFFERENCE HESSIAN APPROXIMATION
FROM FUNCTION VALUES
Purpose : Calculate a forward difference approximation to 
f(xc), 
using
values of / (x) only
Input Parameters : n Z, xc Rn, fc R( = f (xc)), FN (the name of
Input-Output Parameters : none
Output Parameters : H Rnxn symmetric ( f (xc))
Storage Considerations :
1) Two n-vectors of additional storage are required, for stepsize 
and
fneighbor .
2) Only the diagonal and upper triangle of H are filled by Algorithm A5.6.2,
as these are the only portions of H that are referenced by the entire system
of algorithms,
3) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 3.
Description :
f ( x c ) [ i , j ] is approximated by H [ i , j ] = (f (xc + hiei + hjej) - f (xc + hiei
- / (xc + hjej) + 
f(x c)) / (hi*/ij), where et is the ith unit vector, and
hi = n1/3 * max{xc[i]|, l/Sz[i]j * sign(xc[i]). Here l/sx[i] is the typical
size of |xc[i]| input by the user, and n = 10-DIGITS, DIGITS the number of
reliable base 10 digits in f ( x ) . 
The corresponding elements of f(xc) and
H typically will agree in about their first (DIGITS/ 3) base 10 digits.
Algorithm :
1. cuberteta 
n1/3
2. FOR i = 1 TO n DO
(* calculate stepsize [i] and f (xc +s£epsize [i] * et) *)
2.1 stepsize [i ] 
cuberteta *max||xc[i] , l/5.p[i]J * sign(xc[i])
(* to incorporate a different stepsize rule, change line 2.1 *)
2.2 tempi 
xc[i]
2.3 xc[i] 
xc[i] + stepsize [i]
2.4 stepsize [i] 
xc [i] — tempi
(* line 2.4 reduces finite precision errors slightly; see Section 5.4 *)
2.5 CALL FN(n, xc , f neighbor [i])
( * f neighbor [i] f (xc +stepsize [i] * et) *)
2.6 xc[i] 
tempi 
(* reset xc [i] *)
3. FORi = l TOn DO
(* calculate row i of H *)

322 
Appendix A
3.1 tempi 
xc[i]
3.2 xc[i] xc[i] + 2 *stepsize[i]
(* alternatively. xc [i] xc[i] - stepsize [i] *)
3.3 CALLFN(n,xc,fii)
(*fii f(xc + 2 stepsize[i] ei) *)
3.4 H[i,i] ((fc - fneighbor [i]) + (fii -fneighbor[i])) /
(stepsize[i] * stepsize[i])
3.5 xc[i] 
tempi + stepsize[i]
3.6 FORj =i + l TO n DO
(* calculate #[i ,;']*)
3.6.1 tempji 
xc[,j]
3.6.2 xc[j] xc[j] + stepsize[j]
3.6.3 CALLFN(n,xc fij )
(* fij f(xc + stepsize [i] * et 4- stepsize [j ] * ej) *)
3.6.4 H[i,j] 
((fc -fneighbor[i]) + (fij - fneighbor[j ]))
(stepsize [i] * stepsize [j ])
3.6.5 xc[j] 
tempj 
(* reset xc[j] *)
3.7 xc [i] 
tempi 
(* reset xc [i] *)
(* end of FOR loop 3*)
(* RETURN from Algorithm A5.6.2 *)
(* END. Algorithm A5.6.2 *)
ALGORITHM A5.6.3 (FDGRAD)
FORWARD DIFFERENCE GRADIENT APPROXIMATION
Purpose : Calculate a forward difference approximation to 
f(xc), using
values of f(x)
Input Parameters : n Z. Xc Rn. fc R( = f(xc)). FN (the name of
Input-Output Parameters : none
Output Parameters : g Rn ( f (xe ))
Storage Considerations :
1) No additional vector or matrix storage is required.
Additional Considerations :
l) This algorithm is identical to Algorithm A5.4.1, except that the parame-
ters fc R and g Rn in Algorithm A5.6.3 are replaced by the parameters

Appendix A 
323
Fc Rn and J Rnxn in Algorithm A5.4.1, and line 2.6 in Algorithm A5.6.3 is
replaced by the corresponding loop in Algorithm A5.4. 1.
Description :
is approximated by g[j] = (f (xc+hjej)-f 
(x c))/hj, where eJ is
the jth unit vector, and hj - max{ 
] xc [j ] \ , 1 / Sx [j ]} * sign(xc [j ]). Here
1/ Sx[j ] is the typical size of |xc[j]| input by the user, and n = 10-DIGiTS
 t
DIGITS the number of reliable base 10 digits in f(*). The corresponding
elements of f (x c) and g typically will agree in about their first (DIGITS/ 2)
base 10 digits.
Algorithm :
1. sqrteta 
n1/2
2. FOR j - 1 to n DO
(* calculate g[j] *)
2.1 stepsizej 
sqrteta * maxf ]xc [j] \ , I/ S x [ j ] \ * sign(xc [j ])
(* to incorporate a different stepsize rule, change line 2.1 *)
2.2 tempj *~ xc [j ']
2.3 x c [ j ] *- x c [ j ] + stepsizej
2.4 stepsizej *- xc[j]—tempj
(* line 2.4 reduces finite precision errors slightly; see Section 5.4 *)
2.5 CALL FN(n , xc , fj ) (*/;<-/ (arc +stepsizej *fe;- ) *)
2.6 g[j] <- (fj -/c) / stepsizej
2.7 xc[j] <- tempj 
(* reset xc[j] *)
(*endof FOR loop 2 *)
(* RETURN from Algorithm A5.6.3 *)
(* END, Algorithm A5.6.3 *)
ALGORITHM A5.6.4 (CDGRAD)
CENTRAL DIFFEIRENCE GRADIENT APPROXIMATION
Purpose : Calculate a central difference approximation to V/(xc), using
values of / (x}
Input Parameters : neZ, xc e/?n, FN (the name of / : /?"->/?), 5,e/?n,
Input-Output Parameters : none
Output Parameters : g e/?n (-V/ (xc))

324 
Appendix A
Storage Considerations :
1) No additional vector or matrix storage is required.
Additional Considerations :
1) Central difference gradient approximation may be helpful in solving
some unconstrained optimization problems, as discussed in section 5.6.
Driver D6.1.1 is not set up to use Algorithm A5.6.4, but it can easily be aug-
mented to include an automatic switch from forward to central difference
gradient approximation, as is shown below. The switch would be invoked
when an algorithm using forward difference gradients fails to achieve
sufficient descent at some iteration but has not yet satisfied the gradient
termination criterion. In this case, the current iteration would be repeated
using a central difference approximation to f(xc). and then the algorithm
would continue using central difference gradients exclusively until some ter-
mination criterion is satisfied.
The revisions to Driver D6.1.1 to incorporate this automatic switch to
central differences are.
Change the ELSE clause of statement 6 to:
6E. ELSE
6E.1 CALLFDGRAD(n,x0, fc, FN, Sx, n , g c )
6E.2 fordiff 
TRUE
Insert between statements 10.3 and 10.4:
10.3 
IF (global=2) OR (global=3 THEN trustsave
Insert between statements 10. 4d and 10.5:
10.4 
IF (retcode=1) AND (NOT analgrad) AND (fordiff 
=TRUE)
THEN
10.4 . 1 CALLCDGRAD(n,xc, FN, SX.TJ, gc)
10.4)$.2 fordiff 
*- FALSE
10.4)$.3 IF (global =2) OR (global =3) THEN 
trustsave
10.4)1/2. 4 IF global =2 THEN
10.41/2. 4.1 CALL MODELHESS(n, Sx, macheps. Hc , 4)
10.41/2. 4.2 
0
10.41/2 GOTO 10.3
Change the ELSE clause of line 10.5.1 to
10.5. IE ELSE
10. 5. IE. 1 IF fordiff 
= TRUE
THEN CALL FDGRAD(n . x+. f +, FN. Sx . n, g +)
ELSE CALL CDGRAD(n, x+. FN. 5X. 77. g+
Description :
is approximated by g [ j ] = (f (xc+hiej')-f(xc 
-fyej))/ (2*^),
where e;- is the jth unit vector, and hj - r;1/3 * max{ |xc[j] |. I/ S x [ j ] \
* sign(xc[j]). 
Here \/ Sx[j] is the typical size of |a:c[jj| input by the user.

Appendix A 
325
and n = 10-DIGITS, DIGITS the number of reliable base 10 digits in / (z). The
corresponding elements of f (xc) and g typically will agree in about their
first (2 *DIGITS/ 3) base 10 digits.
Algorithm :
1. cuberteta 
nl/3
2. FOR 3 = 1 to n DO
(* calculate g [ j ] *)
2.1 stepsizej 
cuberteta * max{|x c[j]|, I/Sx[j]\ 
*sign(zc[j])
(* to incorporate a different stepsize rule, change line 2.1 *)
2.2 tempj 
x c [ j ]
2.3 x c [ j ] 
x c [ j ] + stepsizej
2.4 stepsizej 
xc[j]—tempj
(* line 2.4 reduces finite precision errors slightly; see Section 5.4 *)
2.5 CALL FN(n, zc , fp) 
( * fp 
f 
(zc +sfepsize;' *ej) *)
2.6 xc[j] 
tempj —stepsizej
2.7 CALL FN(n, xc , fin) (* fm 
f (xc -stepsizej*fej) *)
28 g[j] 
(fp - fm) / (2* stepsizej)
2.9 zc [j] 
tempj 
(* reset xc[j] *)
(* end of FOR loop 2 *)
(* RETURN from Algorithm A5.6.4 *)
(* END, Algorithm A5.6.4 *)
ALGORITHM A6.3.1 (LINESEARCH) - LINE SEARCH
Purpose 
: 
Given 
gtp <0 
and 
< 1/2 ( =10-4 
is 
used), 
find
x+ = xc + \p, Xe(0,l] such that / (x+) < / (xc) + aXgTp, using a back-
tracking line search.
Input Parameters : neZ, xc Rn, fc R( = f (xc)), FN (the name of
f: Rn R), p Rn( = f(xc)),p 
Rn, Sz Rn, maxstep R, steptol R
Input-Output Parameters: none
Output 
Parameters 
: 
reicode Z, 
x+ 
R
n, 
f+ R( = f (x+)),
maxtaJcen Boole an
Meaning of Return Codes :
retcode - 0 : satisfactory x+. found
retcode - 1 : routine failed to locate satisfactory x+ sufficiently

326 
Appendix A
distinct from xc
Storage Considerations:
l) No additional vector or matrix storage is required
Additional Considerations :
1) In all our calls of this algorithm (in Drivers D6.1.1-3), p is the Newton or
secant step. However, this algorithm will work for any p that obeys g Tp < 0.
Description:
(Let x+( ) denote xc + p.)
1) Set 
= 1.
2) Decide whether x+( ) is satisfactory. If so, set retcode = 0 and ter-
minate Algorithm A6.3.1. If not:
3) Decide whether steplength is too small. If so, set retcode = 1 and ter-
minate Algorithm A6.3.1. If not:
4) Decrease A by a factor between 0.1 and 0.5, as follows:
(Let fp(x c)denote the directional derivative of f (x) at xc in the direc-
tionp.)
a. On the first backtrack: select the new A such that x+f (A) is the minim-
izer of the one dimensional quadratic interpolating f(xc), 
f p(x c),
f (xc +p), but constrain the new A to be > 0.1. (It is guaranteed that the
new 
< l/(2(l 
)) = 1/1.9998; see Section 6.3.2.)
b. On all subsequent backtracks: select the new A such that z+ (A) is the
local minimizer of the one dimensional cubic interpolating / (xc), 
f p ( x c ) ,
f(x+(\)), /(^(Apnw)), but constrain the new A to be in [0.1* oldA, 0.5*
oldA].
5) Return to step 2.
Algorithm :
1. maxtaken «- FALSE
2. retcode «- 2
3. 
. 4- 10-4
(* 
a 
is 
a 
constant 
used 
in 
the 
step-acceptance 
test
/ (x+) 
f ( x c ) + a. gTp ; it can be changed by changing this statement
*)
4. Newtlen 
\\Dxp\\2
(* Dx - diag ((sz)1 (sz)n) is stored as sx Rn. For suggested imple-
mentation of expressions involving Dx. see Section 15 of this appendix. *)
5. IF Newtlen > maxstep THEN
(* Newton step x+ = xc +p longer than maximum allowed *)
5.1 p 
p * (maxstep / Newtlen)
5.2 Newtlen 
maxstep
6. initslope 
gTp
7. rellength. 
max{|p[i]\/(max{\x c[i], I/Sx[i]\ ) }
(* rellength is relative length of p as calculated in the stopping rou-
tine *)

Appendix A 
327
8. minlambda 
steptol/rellength
(* minlambda is the minimum allowable steplength *)
9. 
1
10. REPEAT {* loop to check whether x+ = xc+Xp is satisfactory, and gen-
erate next X if required *)
10.1 x+ 
xc + Xp
10.2 CALL FN(n,x«., f+) (*f + f(x+) *)
10.3a IFf + <fc 
+ 
* 
*initslope THEN
(* satisfactory x+ found *)
lO.3a.l retcode 
0
10.3a.2 IF X = 1 AND (Newtlen > 0.99 * mozstep) THEN
maxtaken 
TRUE
{* Algorithm A6.3.1 RETURNS from here *)
10.3b ELSEIF X < minlambda THEN
(* no satisfactory x + can be found sufficiently distinct from xc *)
10.3b.l reicode 
1
10.3b.2 x+ xc
(* Algorithm A6.3.1 RETURNS from here *)
10.3c ELSE (* reduce \ *)
10.3c.l IF = 1
10.3c.lT THEN (* first backtrack, quadratic fit *)
10.3c.lT.l Xtemp 
-initslope / (2*(f+-fc -initslape))
lO.3c.lE ELSE (* all subsequent backtracks, cubic fit *)
10.3c.lE-l
( - prev)
1/ 2 
-l/(Xpreiv2)
— prev / 
2 
/ ( prev 2)
— fc 
— X * initslope
prev — fc - \prev * initslope
10.3c.lE-2 disc b2 - 3* a*initslope
10.3c.lE.3 IF a = 0
THEN (* cubic is a quadratic *)
Xtemp 
initslope / (2 * b )
ELSE (* legitimate cubic *)
Xtemp 
(-b+(disc)1/2)/(3* a)
10.3c.lE-4 IF temp > 0.5 * THEN Xtemp 
0.5*
10.3c.2 prei/ 
X
10.3C.3 f +prev f +
10.3C.4 IF Temp < 0.1 * THEN X 0.1 * ELSE 
Xtemp
(* end of alternative 10.3c, "reduce X", and of multiple branch state-
ment 10.3 *)
10U UNTIL retcode <2 
(* end of REPEAT loop 10 *)
(* RETURN from Algorithm A6.3.1 *)
(* END, Algorithm A6.3.1 *)

328 
Appendix A
ALGORITHM A6.3.1 mod (LINESEARCHMOD)
LINE SEARCH WITH DIRECTIONAL DERIVATIVE CONDITION
Purpose : Given gTp < 0, a < 1/2 ( =l0 4 is used) and e(a,l) ( =0.9 is used),
find x+ = xc+ p, 
X>0, such that 
f ( x + ) < f(xc) + a grp 
and
Input Parameters: those in Algorithm A6.3.1, plus n R, analgrad 
Boolean,
GRAD (the name of f : Rn Rn if analgrad = TRUE, dummy name otherwise)
Input-Output Parameters: none
Output Parameters : those in Algorithm A6.3.1, plus g + Rn( = f (x+))
Meaning of Return Codes. Storage Considerations, Additional Considera-
tions :
same as Algorithm A6.3.1
Description :
(Let x+( ) 
denote 
xc + p, 
and 
let 
the 
two 
inequalities
f ( x + ) < f (xc) + 
gTp and f(x+)Tp > gTp be referred to as the "a con-
dition" and the 
condition", respectively.)
1) Set 
= 1.
2) If x+( ) satisfies the a and ft conditions, set retcode = 0 and terminate
Algorithm A6.3.1mod. If not:
3) If x+( ) satisfies the a condition only and X>1, set X 2* 
and go to step
2.
4) If x+(X) satisfies the a condition only and X<1, or z+( ) doesn't satisfy
the a condition and X>1, then:
a. If <1, define Lo = , A/it = the last previously attempted value of X. If
X>1, define 
hi = , Zo = the last previously attempted value of X. Note,
in both cases. x+(lo) satisfies the a condition and not the 
condition,
x+( hi) doesn't satisfy the a condition, and XZo < Xhi.
b. Find a e( lo, hi) for which x+( ) satisfies the a and ft conditions,
using successive quadratic interpolations. Then set retcode = 0 and ter-
minate Algorithm A6.3.1mod.
5) Otherwise (x+( ) doesn't satisfy the a condition and X<1) do the same
backtracking step as is described in step 4 of the Description of Algorithm
A6.3.1, and go to step 2.
Algorithm :
The same as Algorithm A6.3.1, except that steps 10.3a. 1 and 10.3a.2 are
replaced by the following:
10.3a. 1 IF analgrad
THEN CALL GRAD(n, x+.g)
ELSE CALL FDGRAD(n. x+, f+, FN, Sx, 77, g+) (* Alg. A5.6.3, forward
difference gradient approximation *)

Appendix A 
329
(* or instead CALL CDGRAD(n, x+. FN, Sx, N, g+), Alg. A5.6.4, if central
difference gradient is desired *)
10.3a.2 
0.9
(* to change the constant 
in this algorithm, just change this line *)
10.3a.3 newslope
10.3a.4 IF newslope < 
* initslope THEN
I0.3a.4,l IF ( = 1) AND (Newtlen < maxstep) THEN
10.3a. 4.1.1 maxlambda 
maxstep / Newtlen
10.3a.4.1.2 REPEAT
10.3a.4.1.2.1 prev
10.3a.4.1.2.2 f +prev 
f 
+
10.3a.4.1.2.3 
min{2* , maxlambda.}
10.3a.4.1.2.4 x+ 
xc + X *p
10.3a.4.1.2.5 CALL FN(n. x+, 
f+) 
(* x+ 
f 
(x+) *)
10.3a.4.1.2.6 I F f + < f c + 
* 
* initslope THEN
10.3a.4.1.2.6.1 same as line 10.3a.l above
10.3a.4.1.2.6.2 newslope
(* end of IFTHEN 10.3a.4.1.2.6 *)
!0.3a.4.1.2U 
UNTIL 
(f 
> fc + a * 
* initslope) 
OR
(newslope > * inifsiope) OR ( > maxlambada)
(* end of IFTHEN 10.3a.4.1 *)
10.3a.4.2 IF ( < 1) OR (( > l) A N D ( f + > f c + 
* 
* initslope)) THEN
10.3a.4.2.1 lo min{ , prev}
10.3a.4.2.2 
diff 
prev - |
10.3a.4.2.3 IF < prev
10.3a.4.2.3T THEN
10.3a.4.2.3T.l flo 
f 
+
10.3a.4.2.3T.2 
fhi 
f +prev
10.3a.4.2.3E ELSE
10.3a.4.2.3E.l 
flo 
f+prev
10.3a.4.2.3E.2 fhi 
f +
10.3a.4.2.4 REPEAT
10.3a.4.2.4.1 incr
10.3a.4.2.4.2 IF incr < 0.2 * \diff 
THEN
incr 
0.2 * diff
10.3a.4.2.4.3 
io + Xincr
10.3a.4.2.4.4 x+ xc +
10.3a.4.2.4.5 CALJ, FN(n, x+, f+) (* xt f (x+) *)
10.3a. 4.2.4.6 I F f + > f c + 
* 
* initslope
10.3a.4.2.4.6T THEN
10.3a.4.2.4.6T.l 
diff 
incr
10.3a.4.2.4.6T.2 fhi f 
+
10.3a.4.2.4.6E ELSE

330 
Appendix A
10.3a.4.2.4.6E.l same as line lO.3a.l above
10.3a.4.2.4.6E.2 newslope
10.3a.4.2.4.6E.3 IF newslope < 
* initslope THEN
10.3a.4.2.4.6E.3.1 
lo
10.3a.4.2.4.6E.3.2 
diff 
diff 
- incr
10.3a.4.2.4.6E.3.3 flo 
+
(* end of IFTHEN 10.3a.4.2.4.6E.3 and IFTHENELSE 10.3a.4.2.4.6 *)
10.3a.4.2.4U 
UNTIL 
(newslope > * initslope) 
OR
( diff < mirdambda)
10.3a.4.2.5 IFnewslape < 
* initslope THEN
(* couldn't satisfy condition *)
10.3a.4.2.5.1 f + 
flo
10.3a.4.2.5.2 x,. 
xc + lo • p
(* end of IFTHEN 10.3a.4.2 and IFTHEN 10.3a.4 *)
10.3a.5 retcode 
0
10.3a.6 IF (X * Newtlen > 0.99 * maxstep) THEN
moarfoken 
TRUE
(* END, additions in Algorithm A6.3.1mod *)
ALGORITHM A6.4. 1 (HOOKDRIVER)
LOCALLY CONSTRAINED OPTIMAL ("HOOK') DRIVER
Purpose 
: 
Find 
an 
x+ = xc - (H+ , 
) - lg . 
such 
that
f(x+) < f(xc) + agT(x+-xc) ( =10-4 is used) and scaled steplength
[,75 , 1.5 ], starting with the input 
but increasing or decreasing 6 if
necessary. 
(Dx = diag ((Sx)1 (Sx)n).) Also, produce starting trust
region 
for the next iteration.
Input Parameters : n Z, Xc Rn, fc 
R( = f(xc)). FN (the name of
f:Rn R), 
g Rn( = 
f(xc)) 
L Rn+n lower 
triangular,
H Rnxn symmetric(=LLT). 
(= - H - 19). 
, maxstep^K.
steptol R , itncount Z, macheps R
Input-Output Parameters : 
R, 
R, 
prev R. 
R, 
R (the last four
will not have values the first time this algorithm is called; the last two
will have current values on output only if 
0 )
Output 
Parameters 
: 
retcodecZ, 
z+e/?*1. 
f +^R( - f (*+)),
maxtaken eBoolean

Appendix A 
331
Meaning of Return Codes :
retcode - 0 : satisfactory x+ found
retcode = 1 : routine failed to locate satisfactory x+ sufficiently dis-
tinct from xc
Storage Considerations :
1) Two n-vectors of additional storage are required, for s and x+prev.
2) Only the upper triangle of H and the lower triangle of L, including the
main diagonals of both, are used. It is assumed for simplicity that each is
stored in a full matrix. However, one can economize on matrix storage by
modifying the algorithm as explained in Guideline 3.
Description :
1) Call Algorithm A6.4.2 to find a step s = -(H+ D )-lg , 
, such that
\\Dgs\\z e [0.75 ,1. 56], or sets=SAr if \\DxsN\\z< 1.56.
2) Call Algorithm A6.4.5 to decide whether to accept x+ as the next iterate,
and to calculate the new value of . If retcode = 2 or 3, return to step 1; if
retcode = 0 or 1, terminate algorithm A6.4. 1.
Algorithm :
1. retcode 
4
(* signifies initial call of Algorithm A6.4.2 *)
2. firsthook 
- TRUE.
3. Newtlen
(* Dx - diag ((Sz)1 (Sz)n) is stored as Sz Rn, For suggested imple-
mentation of expressions involving Dx, see Section 1.5 of this appendix.
*)
4. IF (itncount = 1) OR (6 - -l) THEN
4.1 
0 (* needed by Alg. A6.4.2 *)
4.2 IF 6 = -1 THEN
(* no initial trust region was provided by user (or nonlinear equa-
tions secant method restart); set 6 to length of scaled Cauchy step *)
4.2.1
(* 4.2.2-3 implement
4.2.2 
0
4.2.3 FORi = 1 TOn DO
4.2.3.1 temp - (L,[j ,i] • g[j]/ (S.[j]* SX[j]))
4.2.3.2 
+ temp* temp
4.2.4 5 
*
4.2.5 IF 
> maxstep THEN 
maxstep
5. REPEAT (• calculate and check a new step *)
5.1 CALL HOOKSTEP (n, g , L, H, SN, Sx, Newtlen, mac heps , prev,
, ' , firsthook, p'irdt , s, Newttaken')
(* Find new step by hook step Algorithm A6.4.2 *)

332 
Appendix A
5.2 dprev
5.3 CALL TRUSTREGUP (n. xe. fe. FN. g. L. s. Sx. NewttaJcen, maxstep,
steptol, 1, H, 
, r etcode. x+prev, f +prev, x+, f +, maxtaken)
(* check new point and update trust radius, Alg. A6.4.5 *)
5U UNTIL retcode < 2
(* RETURN from Algorithm A6.4.1 *)
(* END. Algorithm A6.4.1 •)
ALGORITHM A6.4.2 (HOOKSTEP)
LOCALLY CONSTRAINED OPTIMAL ("HOOK") STEP
Purpose : Find an approximate solution to
minimize g Ts + 1/2s THs
subject to || 
||2 <
by 
selecting 
an 
s = 
—(H+ 
-1g, 
such 
that
\\DxS\\2 
[0.75 , 1.55], 
or 
s = H- lg 
if 
NewtLen < 1.56.
(Dx = diag ((Sx)1 (Sx)B).)
Input 
Parameters 
: 
n Z. 
g Rn, 
L Rnxn lower 
triangular,
H Rnxn symmetric (=LLT). 
sN Rn (= - H - l g ) , 
Sx 
Rn.
Newtlen R ( =\\DxSn) rnacheps R, prev R
Input-Output Parameters : 
R, 
R. 
R. 
firsthookeBoolean,
' nit 
R 
( . 
will have new values on output only if 
; init will
have a new value on output only if firsthook has become false during
this call.)
Output Parameters : s Rn, Ne-wttaken eBoolean
Storage Considerations :
1) One additional n-vector of storage is required, for tempvec.
2) Only the upper triangle of H and the lower triangle of L, including the
main diagonals of both, are used. It is assumed for simplicity that each is
stored in a full matrix. However, one can economize on matrix storage by
modifying the algorithm as explained in Guideline 3.
Description:
1. If 1.5( > Newtlen, set s = sn, 6 = min { , Newtlen}, and terminate Algo-
rithm A6.4.2. If not:
2. Calculate the starting value of . from the final value of 
at the previous

Appendix A 
333
iteration, and lower and upper bounds low and up on the exact solution
, as explained in Section 6.4 .1 of the text.
3. If 
[ low, 
up\, set // = max 
10~3/mp}
4. 
Calculate 
s =s(/x) = — (H+[ 
~lg. 
Also 
calculate 
= 
=
I| 
and 
.
5. If 
terminate Algorithm A6.4.2. If not:
6. Calculate new values of 
, 
, and 
as explained in Section 6.4.1,
and return to step 3.
Algorithm :
1. hi 
1.5
2. lo 
0.75
(*ht and lo are constants used in the step acceptance 
test
they can be changed by changing statements 1
and 2 *)
3. IF Ne-wtlen < hi * 6
3T. THEN (* s is Newton step *)
3T. 1 Newttaken 
TRUE
3T.2 s 
sn
3T.3 
0
3T.4 
min 
, Neivtlen]
(* Algorithm A6.4.2 RETURNS from here *)
3E. ELSE (* find such that
3E.1 Newttaken 
FALSE
(* compute starting value of , if previous step wasn't Newton step *)
3E.2 IF 
> 0 THEN
(* the term ( prev — } should be parenthesized as prev = 
is
possible *)
(* steps 3E.3-6 compute lower and upper bounds on 
*)
3E.3 
Newtlen -
3E.4 IF firsthook THEN (* calculate init *)
3E.4.1 firsthook 
FALSE
(* steps 3E.4.2-3 result in tempvec 
L-I 
*)
3E.4.2 tempvec 
•
(* 
= diag ((sz)1 (S",)B) is stored as S5x Rn. For sug-
gested implementation of expressions involving Dz, see Sec-
tion 1.5 of this appendix. *)
3E.4.3 CALLLSOLVE (n, tempvec, L, tempvec)
(* solve L* tempvec - 
by Alg. A3.2.3a *)
3E.4.4 
'init 
\tempvec j|| / Ne-wtlen
3E.5 
init
3E.6

334 
Appendix A
3E.7 done 
FALSE
3E.8 REPEAT
(* test value of , generate next 
if necessary *)
3E.8.1 IF(( 
< 
OR ( > 
)) THEN
max 
* 
. l0-3
(*H 
H+ 
: *)
3E.8.2 FORi = 1 TO n DO
H[i,i] H[i,i] + *Sx,[i]*5,[i]
(* calculate the LLT factorization of new H, using Alg. A5.5.2: *)
3E.8.3 CALL CHOLDECOMP (n,H,0, macAeps, L, mazadd)
(* solve (LLT}s = -g, using Alg. A3.2.3 : *)
3E.8.4 CALLCHOLSOLVE(n.p,Z,,s)
(* reset H to original value: H 
H 
* 
)
3E.8.5 FORi = 1 TO n DO
H[i,i] H[i,i] - 
Sz[i]*Sz[i]
3E.8.6 steplen 
|| 
||2
3E.8.7 
steplen - 6
(* steps 3E.8.8-9 result in tempvec 
L-l 
)
3E.8.8 tempvec
3E.8.9 CALL LSOLVE (n, tempvec , L, tempvec)
(* solve L* tempvec = 
by Alg. A3.2.3a *)
3E.8.10 
steplen
3E.8.11 
IF 
((steplen>lo* ) 
AND 
(steplen < hi* )) 
OR
( 
- 
< 0)
3E.8.11T THEN (*s is acceptable step *)
3E.8.11T.1 done 
TRUE
(* Algorithm A6.4.2 RETURNS from here *)
3E.8.11E ELSE (* s not acceptable, calculate new , and bounds
plow and 
*)
3E.8.11E.1 
maxlfJ.ow.
3E.B.11E.2 IF 
< 0 THEN
3E.8.11E.3
(* end of IFTHENELSE 3E.8.11 *)
3E.8U UNTIL done = TRUE
(* end of IFTHENELSE 3 *)
(* RETURN from Algorithm A6.4.2 *)
(• END, Algorithm A6.4.2 *)

Appendix A 
335
ALGORITHM A6.4.3 (DOGDRIVER)
DOUBLE DOGLEG DRIVER
Purpose : Find an x+ on the 
double dogleg curve such that
/ (x+) f (xc) + agT(x+—xc) (a=10-4 is used) and scaled steplength =
starting with the input 6 but increasing or decreasing 6 if necessary.
Also, produce starting trust region 6 for the next iteration.
the name of
Input Parameters :
lower
triangular.
maxstep 
steptol
Input-Output Parameters :
Output 
Parameters 
: 
retcode 
x+ 
f+ ( = f (x+)),
maxt aken Boole an
Meaning of Return Codes :
retcode = 0 : satisfactory x+ found
retcode = 1 : routine failed to locate satisfactory x+ sufficiently dis-
tinct from xc
Storage Considerations :
1) Four n-vectors of additional storage are required, for s, 
and
x +prev.
2) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guidelines 3 and 6.
Description:
1) Call Algorithm A6.4.4 to find the step s on the double dogleg curve such
that \\Dzs \\2 = 
or set s =SN if \\DzsN\\2 < 6. (Dz = diag ((Sz)i 
(Sx,)n)).
2) Call Algorithm A6.4.5 to decide whether to accept x+ as the next iterate,
and to calculate the new value of 6. If retcode = 2 or 3, return to step 1; if
retcode - 0 or 1, terminate algorithm A6.4.3.
Algorithm :
1. retcode 
4
(* signifies initial call of Algorithm A6.4.4 *)
2. firstdog 
TRUE.
3. Newtlen ||DxsN ||2
(* Dz = diag ((5z)! (5z)n) is stored as 5x 
For suggested imple-
mentation of expressions involving Dx. see Section 1.5 of this appendix.
*)
4. REPEAT (* calculate and check a new step *)
4.1 CALL DOGSTEP (n, g , L, SN, Sx. Newtlen, maxstep, 6, firstdog. Cau-
chylen, 
NewttaJcen)

336 
Appendix A
(* Find new step by double dogleg Algorithm A6.4.4 *)
4.2 CALL TRUSTREGUP (n, xc, fc, FN, g, L. s, Sx, NewttaJcen, maxstep,
steptol, 2, L, 6, retcode , x+prev. f+prev, x+, f+, maxtaJcen)
(* check new point and update trust radius, Alg. A6.4.5 *)
(* second L in above parameter list is a dummy parameter *)
4U UNTIL retcode < 2
(* RETURN from Algorithm A6.4.3 *)
(* END, Algorithm A6.4.3 *)
ALGORITHM A6.4.4 (DOGSTEP) - DOUBLE DOGLEG STEP
Purpose : Find an approximate solution to
minimize gTs + 
LLTs
subject to ||Dzs||2
by selecting the s on the double dogleg curve described below such
that \\Dxs||2 = . or s = SN if Newtlen 
(Dz 
- diag ((SX}1 
(S z) n).}
Input 
Parameters 
: 
lower 
triangular,
(LL T) - lg) 1 
5x 
Newtlen 
( = ||DzsN||2), maxsteptR
Input-Output Parameters : (5e/?, firstdogeBoolean, Cauchylen^R.
(the last four parameters will have current values, on
input or output, only if firstdog = FALSE at that point)
Output Parameters : 
NewttaJcen Boolean
Storage Considerations :
1) No additional vector or matrix storage is required.
2) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guidelines 3 and 6.
Description :
1) If Newtlen 
set s = sN, 6 = Ne-wtlen, and terminate Algorithm A6.4.4.
If not:
2) Calculate the double dogleg curve if it hasn't already been calculated
during this call of Algorithm A6.4.3. The double dogleg curve is the piece-
wise linear curve connecting xc , xc +s SD, xc + 
and xc +SN. where SSD is the
Cauchy step to the minimizer of the quadratic model in the scaled steepest
descent direction, and 
1. (See Section 6.4.2 of the text for further
details.)
3) Calculate the unique point xc + s on the double dogleg curve such that

Appendix A 
337
Algorithm :
1. IF Newtlert
IT. THEN (* s is Newton step *)
IT. 1 NewttaJcen 
TRUE
1T.2 s
1T.3
Ne-wtlen
(* Algorithm A6.4.4 RETURNS from here *)
IE. ELSE
(* Newton step too long, s on double dogleg curve *)
1E.1 NewttaJcen 
FALSE
IE.2 IF firstdog THEN
(* calculate double dogleg curve *)
1E.2.1 firstdog 
FALSE
1E.2.2
diag
is stored as
For sug-
gested implementation of expressions involving Dx, see Sec-
tion 1.5 of this appendix. *)
(* 1E.2.3-4 implement
1E.2.3
IE.2.4 FORi = 1 TOn DO
IE. 2.4.1 temp
IE.2.4.2
temp * temp
1E.2.5
is Cauchy step in scaled metric; SSD in Description is
IE.2.6 Cauchylen
see Section 6.4.2
1E.2.B
in the scaled metric
1E.2.9
-1 THEN
min Cauchylen, maxstep
first iteration, and no initial trust region was provided by
the user
(* end of IE.2, calculate double dogleg curve *)
lE.Sa IF
Newtlen
THEN
(* take partial step in Newton direction *)
lE.3a.l s
Newtlen) * sN
(* Algorithm A6.4.4 RETURNS from here *)

338 
Appendix A
lE.3b ELSEIF Cauchylen 
THEN
(* take step in steepest descent direction *)
1E.36.1 s
Cauchylen
(* Algorithm A6.4.4 RETURNS form here *)
lE.3c ELSE
(* calculate convex combination of SSD and
that has scaled length
lE.Sc.l temp
lE.3c.2 tempv
1E.3C.3
tempv
1E.3C.4 s
end of ELSE lE.3c, and of multiple branch IE.3, and of IFTHENELSE 1
(* RETURN from Algorithm A6.4.4 *)
(* END, Algorithm A6.4.4 *)
ALGORITHM A6.4.5 (TRUSTREGUP)
UPDATING THE MODEL TRUST REGION
Purpose : Given a step s produced by the hookstep or dogstep algorithm,
decide whether x+ = xc + s should be accepted as the next iterate. If
so, choose the initial trust region for the next iteration. If not,
decrease or increase the trust region for the current iteration.
Input Parameters
the name of
lower 
triangular,
NevjttakeneBoolean, maxstepz 
steptol 
steptypezR 
(= 1 for
hookstep, 2 for dogstep), 
symmetric (only used if steptype-l.
contains model Hessian in this case)
Input-Output Parameters : 
retcodeeZ, x+prev 
f+prevs-R (the
last two parameters will have current values on input, or new values on
output, only if retcode = 3 at that point)

Appendix A 
339
Output Parameters
maxtaken cBoolean
Meaning of Return Codes :
retcode = 0 : x+ accepted as next iterate, 
is trust region for next
iteration
retcode = 1 : x+ unsatisfactory but global step is terminated because
the relative length of (x+ - xC) is within the stopping algorithm's
steplength stopping tolerance, indicating in most cases that no
further progress is possible — see termocde - 3 in Algorithms
A7.2.1 and A7.2.3
retcode = 2 : / (x+) too large, current iteration to be continued with a
new, reduced
retcode = 3 : f(x+} sufficiently small, but the chance of taking a
longer successful step seems sufficiently good that the current
iteration is to be continued with a new, doubled 6
Storage Considerations :
1) No additional vector or matrix storage is required, except the n-vector
F+prev for nonlinear equations only.
2) Only the upper triangle of H and the lower triangle of L, including the
main diagonals of both, are used. It is assumed for simplicity that each is
stored in a full matrix. However, one can economize on matrix storage by
modifying the algorithm as explained in Guideline 3.
3) When steptype = 2, H is not used, and this algorithm requires only one
nxn matrix since the call of Alg. A6.4.5 by Alg. A6.4.3 causes H and L to
refer to the same matrix.
4) For nonlinear equations, the global variable FV+ is used.
Description :
1) Calculate
2) If retcode
reset
retcode
and terminate Algorithm A6.4.5 If
not:
step is unacceptable. If relative stepiength is too small,
set retcode = 1 and terminate Algorithm A6.4.5. If not, calculate the X for
which xc + \s is the minimizer of the one dimensional quadratic interpolat-
, and the directional derivative of / at xc in the direction
except constrain the new 5 to be between 0.1 and 0.5 of the
old 5. Terminate Algorithm A6,4.5.
, so the step is acceptable. Calculate 
pred = the value of
predicted by the quadratic model
do one of:
a. If 
and 
pred agree to within relative error 0.1 or negative curva-
ture is indicated3, and a longer step is possible, and 6 hasn't been
decreased during this iteration, set 6 = 2 , retcode - 3, x+prev = x+,
f +prev = f +, and terminate Algorithm A6.4.5. If not:
b. 
Set retcode = 0. If 
0.1 * pred set 6 = 6/2, 
otherwise if
pred set 6 = 2*5, otherwise don't change 6. Terminate
Algorithm A6.4.5.
ing
Then

340 
Appendix A
Algorithm :
1. maxtaJcen 
FALSE
is a constant used in the step-acceptance test / (x+)
; it can be changed by changing this statement *)
is stored as 5z 
For suggested imple-
mentation of expressions involving Dx, see Section 1.5 of this appendix.
*)
3. steplen
diag
CALLFN
initslope
IF retcode
3 THEN
prrev
may be necessary to prevent run-time error in following statement
9a. IF (retcode = 3) AND
OR
((f+ 
f+prev
initslope
THEN
(* reset x+ to x+prev and terminate global step *)
retcode
9a.2 x+ 
x+prev
9a.3 f + 
f+prev
9a.5 FV+ 
F+prev (* Nonlinear Equations only *)
(* Algorithm A6.4.5 RETURNS from here *)
9b. ELSEIF 
a*initslope THEN
( * f ( x + ) too large*)
9b.l rellength
9b.2 IF rellength <steptol
9b.2TTHEN
(* x+-xc too small, terminate global step *)
Qb.ZT.l retcode «- 1
9b.2T.2 x+ «- xc
(* Algorithm A6.4.5 RETURNS from here *)
9b.2E ELSE
(* reduce 
continue global step *)
9b.2E.l retcode 
2
9b.2E.3a IF
THEN
9b.2E.3b ELSEIF
THEN
9b,2E.3c ELSE

Appendix A 
341
(* Algorithm A6.4.5 RETURNS from here *)
9c ELSE (* / (x+) sufficiently small *)
9c.l 
pred 
initslope
9c.2 IF steptype = 1
9c.2T THEN 
(* hookstep, calculate sTHs *)
9c.2T.l FORi = 1 TO n DO
9c.2T1.l temp
9c.2T.1.2 
pred «- fpred + temp
9c.2E ELSE
(* dogleg step, calculate sTLLTs instead *)
9c.2E.l FORi = 1 TOn DO
9c.2E.l.l temp
9c.2E.L2 
fpred 
fpred 
+ (temp * temp/2)
9c.3 
IF 
retcode#2 
AND ((| fpred - f | 
0.1 * | f |) OR
(A/ < initslope )) 
AND 
(Newttaken = FALSE) 
AND
(<5< 0.99 *maxstep)
9c.3T THEN
(* double 5 and continue global step *)
9c.3T.l retcode 
3
9c.3T.2 x+prev 
x +
9c.3T.3 f+prev f 
+
9c.3T.4 6 
min 2 * , moxstep
9c.3T.5 F+prev FV+ (* Nonlinear Equations only *)
(* Algorithm A6.4.5 RETURNS from here *)
9c.3E ELSE
{* accept x+ as new iterate, choose new *)
9c.3E.l retcode 
0
9c.3E.2 IF steplen > 0.99 * maxstep THEN
maxtaJcen *- TRUE
9c.3E.3a IF 
f 
0.1 * fpred THEN 6 
/2
(* decrease for next iteration *)
9c.3E.3b ELSEIF 
f 
0.75 * fpred THEN
min 2 * 6, maxstep
(* increase 6 for next iteration *)
(*9c.3E.3c ELSE 
is unchanged *)
(* end of ELSE 9c.3E, and of ELSE 9c, and of multiple branch 9 *)
(* RETURN from Algorithm A6.4.5 *)
(* END, Algorithm A6.4.5 *)

342 
Appendix A
ALGORITHM A6.5.1 (NEHODEL)
FORMATION OF THE AFF1NE MODEL
FOR NONLINEAR EQUATIONS
Purpose : Factor the model Jacobian, calculate the Newton step, and provide
the necessary information for the global algorithm. If the model Jaco-
bian is singular or ill-conditioned, modify it before calculating the New-
ton step, as described in Section 6.5 in the text.
Input Parameters
or an approx-
imation to
macheps
global i
Input-Output Parameters : none
Output Parameters
Storage Considerations:
1) Two n-vectors of additional storage are required, for M1 and M2.
2) Only the upper triangle and main diagonal of H is used. H may share
storage with M, if some minor modifications are made to this algorithm (and
others) as explained in Guidelines 6 and 3.
3) M is used in the first part of this algorithm to contain the QR factoriza-
tion of DfJ as described in Alg. A3.2.1. On output, if global - 2 or 3, its
lower triangle and main diagonal contain the Cholesky. factor L of the matrix
H described in step 3 and 4 below, if global = 2, this same matrix H is con-
tained in the upper triangle and main diagonal of the parameter H on out-
put. (H may be used within the algorithn regardless of the value of global.)
Description:
1) Calculate the QR decomposition of DFJ. (DF = diag 
((SF)1 
(S F)n)-)
2) Estimate the Za condition number of RDz
-1. (Dz = diag ((Sz)1 (S z} n).)
3) 
If 
singular 
or 
ill-conditioned, 
set 
H =
(see Section 6.5), calculate the
Cholesky factorization of H, set SN 
H - lg where g = 
and ter-
minate Algorithm A6.5.1.
4) If 
is well conditioned, calculate SN 
If global = 2 or 3,
store KT in the lower triangle of M. If global - 2, set H = RTR, Terminate
Algorithm A6.5.1.
Algorithm :
(* M 
DfJ: 
DF = diag ( ( s F , 
( S f ) n ) *)
1. FORi = 1 TOn DO
1.1 FOR .j = I TOn DO
u[ij]-sF[i.] 
'J[ij]
2. CALL QRDEC.OMP(n, M . M l . M 2 , sing)
(* call Alg. A3.2.1 to calculate the QR factorization of M *)

Appendix A 
343
3. IFNOTsingf
3T. THEN 
(* estimate K1(RDx-1) *)
(* R 
RD - l *)
3T.1 FORj = 1 TO n DO
3T.1.1 FORi = 1 TOj-1 DO
M [ i j ] 
M [ i , j ] / 
S z [ j ]
3T.1.2 M2[j] <- Af2[j]/ 5x[j]
3T.2 CALL CONDEST(n, M, M2. est)
(* call Alg. A3.3.1 to estimate the condition number of R *)
3E. ELSE est «- 0
4. IF(sing) OR(est > 1/
4T. THEN (* perturb Jacobian as described in Section 6.5 *)
4T. 1 FOR i = 1 TO n DO
4T.1.1 FORj = i TOn DO
(* steps 4T.2-3 calculate Hnarm
4T.2 Unarm
4T.3 FORi = 2 TOn DO
4T.3.1 temp
4T.3.2 Unarm 
max temp, Hnorm
4T.4 FORi = 1 TO n DO
Hnorm
(* steps 4T.5-6 calculate sN H - lg *)
4T.5 CALL CHOLDECOMP(n, H, 0, macheps, M, maxadd) 
(* Alg. A5.5.2
')
4T.6 CALL CHOLSOLVE(n, g. M, SN) 
(* Alg. A3.2.3 *)
4E. ELSE 
(* calculate normal Newton step *)
(* reset R 
RDX *)
4E.1 FOR.7 = ITOn DO
4E.1.1 FORi = 1 TO j-1 DO
M[i,j] 
M[i,j] »5x[j]
4E.1.2 Af2[j]<-Af2[j] *5z[j]
4E.2 sjy 3- DF * Fc
(*Df = diag((5F.)1 
(5F)n)*)
4E.3 CALL QRSOLVE(n, M. Ml, M2, SN)
(* call Alg. A3.2.2 to calculate M - ls N *)
4E.4 IF (global = 2) OR (global = 3) THEN
(* lower triangle of M RT *)

344 
Appendix A
4E.4.1 FORi = 1 TO n DO
4E.4.1.1 M[i.i] 
M2[i]
4E.4.1.2 FORj = 1 TO i-1 DO
M [ i , j } ^ M [ j , i }
4E.5 IF global = 2 THEN
(*H 
LLT*)
4E.5.1 FORi = 1 TO n DO
4E.5.1.1 H[i,i]
4E.5.1.2 FORj =i + l TOn DO
(* RETURN from Algorithm A6.5.1 *)
(* END, Algorithm A6.5.1 *)
ALGORITHM A6.5. If ac (NEMODELFAC)
FORMATION OF THE AFFINE MODEL FOR
NONLINEAR EQUATIONS WITH FACTORED SECANT UPDATES
Purpose : A modification of Algorithm A6.5.1 that is used with factored
secant updates. This algorithm differs from Algorithm A6.5.1 mainly in
the storage of the QR factorization of the Jacobian approximation.
Input Parameters : 
, Fc 
( = F(xc)),
machepse , globaltZ, restarteBoolean
Input-Output Parameters :
Output Parameters :
Storage Considerations :
1) One n-vector of additional storage is required, for M1.
2) Only the upper triangle and main diagonal of H are used. H may share
storage with M, if some minor modifications are made to this algorithm as
explained in Guidelines 6 and 3.
3) If this is a restart J contains J ( x c ) on input and QT on output, where
QR = DFJ(xc). 
Otherwise, J contains QT on input, where QR is the factored
secant approximation to D f J ( x c ] , and is unchanged by this algorithm. M
contains R in its upper triangle on output (sometimes excluding its main
diagonal), and also on input (including the main diagonal) unless this is a
restart. The diagonal of /? is stored in M2 on output, and also on input
unless this is a restart. If global = 2 or 3, the main diagonal and lower trian-
gle of M will contain on output the same matrix L as is output in M by

Appendix A 
345
Algorithm A6.5.1 If global - 2. H contains the same matrix on output as is
output in H by Algorithm A6.5.1.
Description:
1) If this is a restart, calculate the QR decomposition of DpJ, placing QT
into J and R into M. (DF - diag ((SF 
) 
(SF)n)-)
2) Estimate the l1 condition number of RDx
-l. (Dx = diag 
((S x) 1 
(Sx)n).)
3) 
If 
singular 
or 
ill-conditioned, 
set 
H =
(see Section 6.5), calculate the
Cholesky factorization of H, set 
sN 
H - l g , where g = RT QT DFFC, and ter-
minate Algorithm A6.5. 1fac.
4) If RD-
x
l is well conditioned, calculate SN 
R - 1Q TD FF C. If global - 2 or
3, store RT in the lower triangle of M. If global = 2, set H RTR. Ter-
minate Algorithm A6.5.1fac.
Algorithm :
1. IF restart
IT. THEN 
(* calculate new QR factorization *)
(* M - DPJ(xc); 
DF = diag ((SF), 
(5F.)n) *)
IT. 1 FOR i = 1 TO 7n DO
1T.1.1 FOR; = 1 TOn DO
M [ i j ] - S F [ i ] 
*/[ij]
IT.2 CALL QRDECOMP(n, M , M 1 , M 2 , ring)
(* call Alg. A3.2.1 to calculate the QR factorization of M *)
1T.3 CALLQFORM(n, It, Ml, J)
(* call Alg. A3.4.2 to calculate QT and store it in J *)
1T.4 FORi = 1 TOn DO
M[i,i] «- M2[i]
1E. ELSE 
(* check if R is singular *)
1E.1 sing 
FALSE
1E.2 FORi = 1 TOn DO
1E.2.1 IF M[i,i] = O THEN sing TRUE
2. IFNOTsingf
2T. THEN 
(* estimate K1(RDx
-1) *)
(R 
RDz
-1 
*)
2T. 1 FOR j - 1 TO n DO
2T.1.1 FORi = 1 TOj-l DO
M [ i , j ] 
M[i.j]/ 
S x [ j ]
2T.1.2 Af2[j] M2[j] / 5X[j]
2T.2 CALL CONDEST(n, M, M2. est)
(* call Alg. A3.3.1 to estimate the condition number of R *)
(* reset R RDZ *)
2T.3 FOR; = 1 TO n DO
2T.3.1 FORi = 1 T0;-l DO

346 
Appendix A
M [ i . j ] 
M ( i , j ] Sz[j]
2T.3.2 M2[j] 
M 2 [ j ] • Sx[j]
2E. ELSE est 
0
3. IF (sing) OR
3T. THEN (* perturb Jacobian as described in Section 6.5 *)
(* H RT R *)
3T. 1 FOR i = 1 TO n DO
3T.1.1 FOR; = i TO n DO
(* steps 3T.2-3 calculate Hnorm ||Dx-l HD -1 ||*)
3T.2 Hnorm
3T.3 FOR i = 2 TO n DO
3T.3.1 temp 
(I/ 5x[i])
3T.3.2 Hnorm max temp, Hnorm
3T.4 FOR i = 1 TO n DO
H[i.i] 
H[i.i] +
Hnorm *5r[i]2
{* steps 3T.5-6 calculate SN 
H - lg *)
3T.5 CALL CHOLDECOMP(n, H. 0, macheps. M, moxodd) (* Alg. A5.5.2
*)
3T.6 CALL CHOLSOLVE(n, g, M. SN) 
(* Alg. A3.2.3 *)
3E. ELSE 
(* calculate normal Newton step *)
(*SAT «- -JDFFC ; recall J = QT *)
3E. 1 FOR i = 1 TO n DO
3E.2 CALLRSOLVE(n, M. M2, SN)
(* call Alg. A3.2.2a to calculate R-lsN *)
3E.3 IF (gioooZ = 2) OR (oioooJ = 3) THEN
(* lower triangle of M 
RT 
*)
3E.3.1 FORi = 2 TO n DO
3E.3.1.1 FOR; = 1 TOi-1 DO
^[*^]-M[j,i]
3E.4 IF globl = 2 THEN
(*H 
LL,T 
*)
3E.4.1 FOR i = 1 TO n DO
3E.4.1.1 FOR ; = i TO n DO
(* RETURN from Algorithm A6.5.1fac *)

Appendix A 
347
(* END, Algorithm A6.5.1fac *)
ALGORITHM A7.2.1 (UMSTOP)
STOPPING CONDITIONS FOR UNCONSTRAINED MINIMIZATION
Purpose : Decide whether to terminate unconstrained minimization algo-
rithm D6.1.1, for any of the reasons listed below
Input Parameters :
retcode 
, gradtol 
, steptol 
, itncount 
,
itnlimit 
, maxtaken eBoolean
Input-Output Parameters : consecmoxeZ
Output Parameters : termcode
Meaning of Return Codes :
termcode = 0 : no termination criterion satisfied
termcode > 0 : some termination criterion satisfied, as follows:
termcode = 1 : norm of scaled gradient less than gradtol, x+ probably is
an approximate local minimizer of / (x) (unless gradtol is too large)
termcode = 2 : scaled distance between last two steps less than steptol,
x + may be an approximate local minimizer of / (x), but it is also pos-
sible that the algorithm is making very slow progress and is not near
a minimizer, or that steptol is too large
termcode = 3 : last global step failed to locate a lower point than xc;
either xc is an approximate local minimizer and no more accuracy is
possible, or an inaccurately coded analytic gradient is being used, or
the finite difference gradient approximation is too inacurate, or step-
tol is too large
termcode = 4 : iteration limit exceeded
termcode - 5 : five consecutive steps of length maxstep have been
taken; either / (x) is unbounded below, or / (x) has a finite asymp-
tote in some direction, or maxstep is too small
Storage Considerations :
1) No additional vector or matrix storage is required.
Description :
termcode is set to 1, 2, 3, 4, or 5 if the corresponding condition described
above is satisfied; if none of these conditions are satisfied, termcode *- 0.
Also, consecmax is augmented by one if maxtaken - TRUE, otherwise con-
secmax is set to zero.

348 
Appendix A
Algorithm :
1. termcode 
0
2a. IF retcode = 1 THEN termcode 
3
2b. 
ELSEIF
gradtol 
THEN
termcode 
1
(* this is maximum component of scaled gradient; see Section 7.2.
WARNING: if typf is too large, algorithm may terminate prematurely
*)
2c. ELSEIF
steptol THEN termcode *- 2
(* this is maximum component of scaled step; see Section 7.2 *)
2d. ELSEIF itncount 
itnlimit THEN termcode 
4
2e. ELSEIF moxfofcen = TRUE THEN
(* step of length maxstep was taken; print this message if desired *)
2e.l consecmax 
consecmax + 1
2e.2 IF consecmax = 5 THEN termcode 
5
(* limit of five maxsteps is completely arbitrary and can be changed by
changing this statement *)
2f. ELSE consecmax 
0
(* end of multiple branch 2 *)
(* if desired, output appropriate termination message from here if
termcode > 0 *)
(* RETURN from Algorithm A7.2.1 *)
(* END, Algorithm, A7.2.1 *)
ALGORITHM A7.2.2 (UHSTOPO)
STOPPING CONDITIONS FDR UNCONSTRAINED MINIMIZATION
AT ITERATION ZERO
Purpose : Decide whether to terminate Algorithm D6.1.1 at iteration zero
because x0 is an approximate critical point of / (x)
Input Parameters : 
.
typf 
gradtol
Input-Output Parameters : none
Output Parameters : termcode 
, consecmax

Appendix A 
349
Meaning of Return Codes :
termcode = 0 : XD is not an approximate critical point of / (x)
termcode = 1 : x0 is an approximate critical point of / (x)
Storage Considerations:
1) No additional vector or matrix storage is required.
Additional Considerations :
1) If termcode = 1, it is possible that x0 is an approximate local maximizer
or saddle point of / (x). This can be determined by calculating whether
is positive definite. Alternatively. Algorithm D6.1.1 can be restarted
from some point in the vicinity of x0. Then it will most likely converge back
to x0 only if x0 is an approximate local minimizer of / (x).
Description:
termcode is set to 1 if the absolute value of the maximum component of the
scaled gradient is less than 10-3 * gradtol. (A stricter gradient tolerance is
used at iteration zero.) Otherwise, termcode 
0.
Algorithm :
1. consecmax 
0
(* consecmax will be used by Algorithm A7.2.1 to check for divergence;
it contains the number of consecutive past steps whose scaled length
was equal to maxstep *)
gradtol
THEN termcode 
1
(* if desired, output appropriate termination message *)
ELSE termcode 
0
(* RETURN from Algorithm A7.2.2 *)
(* END, Algorithm A7.2.2 *)
ALGORITHM A7.3.3 (NESTOP)
STOPPING CONDITIONS FOR NONLINEAR EQUATIONS
Purpose : Decide whether to terminate nonlinear equations algorithm
D6.1.3. for any of the reasons listed below
Input 
Parameters

350 
Appendix A
Fnorm
retcodetZ, 
fvectol 
, 
steptol 
, 
itncount 
, 
itrdimit 
,
maxtaJceneBoolean, analjac Boolean, cheop 
Boolean, mintol
Input-Output Parameters : consecmozeZ
Output Parameters : termcode
Meaning of Return Codes :
termcode = 0 : no termination criterion satisfied
termcode > 0 : some termination criterion satisfied, as follows:
termcode = 1 : norm of scaled function value is less than fvectol, x +
probably is an approximate root of F(x) 
(unless fvectol is too
large)
termcode - 2 : scaled distance between last two steps less than steptol,
x+ may be an approximate root of F ( x ) , but it is also possible that
the algorithm is making very slow progress and is not near a root, or
that steptol is too large
termcode - 3 : last global step failed to decrease ||F(x)||2 sufficiently;
either zc is close to a root of F(x} and no more accuracy is possible,
or an incorrectly coded analytic Jacobian is being used, or the
secant approximation to the Jacobian is inaccurate, or steptol is too
large
termcode = 4 : iteration limit exceeded
termcode - 5 : five consecutive steps of length maxstep have been
taken; either ||F(x)||2 asymptotes from above to a finite value in
some direction, or maxstep is too small
termcode = 6 : xc seems to be an approximate local minimizer of
||F(x)||2 that is not a root of F(x) (or mintol is too small); to find a
root of F ( x ) , the algorithm must be restarted from a different
region
Storage Considerations :
l) No additional vector or matrix storage is required.
Description:
termcode is set to 1, 2, 3, 4, 5 or 6 if the corresponding condition described
above is satisfied; if none of these conditions are satisfied, termcode 
0.
Also, consecmax is augmented by one if maxtoJcen - TRUE, otherwise con-
secmax is set to zero.
Algorithm :
1. termcode 
0
2a. IF retcode = 1 THEN termcode 
3
2b. ELSEIF max 
fvectol TEEN termcode *- 1
(* this is maximum component of scaled function value; see Section
7.2. *)
2c. ELSEIF
steptol THEN termcode 
2

Appendix A 
351
(* this is maximum component of scaled step; see Section 7.2 *)
2d. ELSEIF itncount 
itnlimit THEN termcode 
4
2e. ELSEIF maxtaken - TRUE THEN
(* step of length maxstep was taken; print this message if desired *)
2e,l consecmax 
consecmax + 1
2e,2 IF consecmax - 5 THEN termcode *- 5
(* limit of five maxsteps is completely arbitrary and can be changed by
changing this statement *)
2f. ELSE
2f.l consecmax *- 0
2f.2 IF analjac OR cheapf THEN
2f.21 IF
mintol THEN
termcode 
6
(* test for local minimizer of ||F(x)||2 omitted when using
secant methods because g may not be accurate in this
case *)
(* end of multiple branch 2 *)
(* if desired, output appropriate termination message from here if
termcode 
0 *)
(* RETURN from Algorithm A7.2.3 *)
(* END, Algorithm, A7.2.3 *)
ALGORITHM A7.2.4 (NESTOPO)
STOPPING CONDITIONS FOR NONLINEAR EQUATIONS
AT ITERATION ZERO
Purpose : Decide whether to terminate Algorithm D6.1.3 at iteration zero
because x0 is an approximate root of F ( x )
Input Parameters :
Input-Output Parameters : none
Output Parameters : termcode 
, consecmax
Meaning of Return Codes :
termcode = 0 : x0 is not an approximate root of F(x)
termcode - 1 : x0 is an approximate root of F(x}

352 
Appendix A
Storage Considerations :
1) No additional vector or matrix storage is required.
Description:
termcode is set to 1 if the absolute value of the maximum component of the
scaled function is less than 10~2 * fvectol 
(A stricter function tolerance is
used at iteration zero.) Otherwise, termcode 
0.
Algorithm :
1. consecmax 
0
(* consecmax will be used by Algorithm A7.2.3 to check for divergence;
it contains the number of consecutive past steps whose scaled length
was equal to maxstep *)
2. IF max 
fvectol
THEN termcode 
1
(* if desired, output appropriate termination message *)
ELSE termcode 
0
(* RETURN from Algorithm A7.2.4 *)
(* END, Algorithm A7.2.4 *)
ALGORITHM A8.3.1 (BROYUNFAC)
BROYDEN'S UPDATE. UNFACTORED FORM
Purpose : Update A by the formula
where s =x+ — x c , y = F+ — Fc, skipping all or part of the update
under the conditions described below
Input 
Parameters 
:
Input-Output Parameters :
Output Parameters : none
Storage Considerations :
1) One n-vector of additional storage is required, for s .
2) There are no changes to this algorithm if one is economizing on matrix

Appendix A 
353
storage as described in Guideline 6.
Description :
For each row i, the update to row i is made unless j (y — As}[i] \ is less than
the estimated noise i n y [ i ] , which is 77 * ( | F + [ i ] + \ F c [ i ] | ) .
Algorithm :
1. s 
x + - xc
2. denom ||Dzs||22
(* Dx = diag 
((S x)3 (S x) n) is stored as 
For suggested imple-
mentation of expressions involving Dx, see Section 1.5 of this appendix.
*)
3. FOR i - 1 TO n DO
(* tempi *- (y— As)[i] *)
3.1 tempi
3.2 IF | tempi 
| 
* (| F+[i] \ + \ F c [ i ] \ ) THEN
(* update row i *)
3.2.1 tempi 
tempi / denom
3.2.2 FOR; = 1 TO n DO
A[ij] A[i,j] + tempi *s[;] * SZ|j]2
(* RETURN from Algorithm A8.3.1 *)
(* END, Algorithm A8.3.1 *)
ALGORITHM AB.3.2 (BROYFAC)
BROYDEN'S UPDATE. FACTORED FORM
Purpose : Update the QR factorization of A, an approximation to 
D f J ( x c ) ,
into the factorization Q+R+ of
an approximation to D FJ(x +), where s = x+ — xc, y = F+ — Fc, skip-
ping all or part of the update under the conditions described below
Input 
Parameters

354 
Appendix A
(Df = diag ((5jr), 
(5jr)B))
Input-Output Parameters : Ze/?nxn (contains 
on input, 
on output),
(the upper triangle and main diagonal of M contain R on
input, R+ on output), M2 € /?" (contains the main diagonal of R on input,
of Rjf on output)
Output Parameters: none
Storage Considerations :
1) Three n-vectors of additional storage are required, for s, t and w.
2) The first lower subdiagonal of M, as well as the upper triangle including
the main diagonal, are used at intermediate stages of this algorithm.
3) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 6.
Description:
1} Move A/2 to the diagonal of M.
2) s «- x+ - xc.
3) Calculate t = Rs.
4) 
Calculate w - DFy - As - DFy - ZTt. If 
is less than the
estimated noise in DFy [i], measured by 
.
then w[i] is set to zero.
5) If w = 0, skip the update. Otherwise :
5a) Set t = QTw = Zw. 
.
5b) Call Alg. A3.4.1 to update the QR factorization of A to the factoriza-
tion Q+R+ of Q(R+ tsT).
5c) Move the new diagonal of M to A/2.
Algorithm :
1. FORi = 1 TO n DO
M[i,i] «- A/2[i]
2. s <- x+ - xc
3. shipupdate «- TRUE
(* t «- Rs : *)
4. FOR i = 1 TO n DO
5. FOR i = 1 TO n DO
<*i«[t]-(flrv-zrO[*]:')
5.1 iw[i]*-5r[il*/'Ji]-5F[*]*/'c[i]
WlPtciI.^^^Itrdl'VIill +l^o[t]|)
THEN skipupdate *- FALSE
ELSEtufil «-0
6. IF skipupdate = FALSE THEN
(** «- Z *iu : *)

Appendix A 
355
6.1 FOR i = 1 TO n DO
6.2 denom
(* Dx = diag ((Sx)n...,(Sz)n) is stored as 
For suggested
implementation, of expressions involving Dx, see Section 1.5 of this
appendix. *)
6.3 s Dx2 *s / denom
6.4 CALL QRUPDATE(n, t, s, 1, Z, M) 
(*Alg. A3.4,1 *)
6.5 FOR i = 1 TO n DO
M2[i] 
M[i,i]
(* RETURN from Algorithm A8.3.2 *)
(* END, Algorithm A8.3.2 *)
ALGORITHM A9.4.1 (EFGSUNFAC)
POSITIVE DEFINITE SECANT UPDATE (BFGS).
UNFACTOKED FORM
Purpose : Update H by the BFGS formula
where s=x+-xc,y=g+-gc, skipping the update under the condi-
tions stated below
Input Parameters 
macheps
analgradeBoolean (= TRUE if analytic gradient is being used, FALSE
otherwise)
Input-Output Parameters : 
symmetric
Output Parameters: none
Storage Considerations :
1) Three n-vectors of additional storage are required, for s, y, and t.
2) Only the upper triangle of H, including the main diagonal, is used.
(These are the only portions of H that are referenced by the rest of the sys-
tem of algorithms.)
3) If one is conserving matrix storage, this algorithm is modified slightly as
explained in Guideline 3.

356 
Appendix A
Description :
The above update is made unless either : i) yTs < (mac heps ) \\s\\2\\y\\2, or
ii) for every i. |(y— H s ) [ i ] \ is less than the estimated noise in y[i]. The
estimated noise in y[i] is calculated by tol * ( g c [ i ] \ + l<7+[i]|) where
tol=rj if analytic gradients are being used, tol=rj" if finite difference gra-
dients are being used.
Algorithm :
1. s *- x + - xc
2 y 
g+ -gc
3. temp 1 
yTs
4. IF tempi 
(macheps)* ||s||2||j/||2 THEN
(* ELSE update is skipped and algorithm terminates *)
4.1 IF analgrad - TRUE
THEN tol
ELSE tol
4.2 shipupdate 
TRUE
4.3 FORi = 1 TOn DO
C*[i]«-Hc[i]:*)
THEN
skipupdate 
FALSE
4.4 IF skipupdate - FALSE THEN
(* do update; ELSE update is skipped and algorithm terminates *)
4.4.1 temp2 
sTt 
( * = sTHs *)
4.4.2 
FORi = l TOn DO
4.4.2.1 FOR.;=i TOn DO
(* end of IFTHEN 4.4. and of IFTHEN 4 *)
(* RETURN from Algorithm A9.4.1 *)
(* END, Algorithm A9.4.1 *)
ALGORITHM A9.4.2 (BFGSFAC)
POSITIVE DEFINTTE SECANT UPDATE (BTCS).
FACTORED FORM

Appendix A 
357
Purpose : Update the LLT factorization of H into the factorization L+Ll of
where s = x+ — xc, y = g + — gc, by using Algorithm A3.4.1 to calculate
the QR factorization of JT in 0(n2) operations. The update is skipped
under conditions stated below.
Input Parameters : 
ma.ch.eps fLR, rj&R.
onoigradeBoolean (= TRUE if analytic gradient is being used, FALSE
otherwise)
Input-Output Parameters : 
(the lower triangle and main diagonal of
M contain L on input, L+ on output)
Output Parameters : none
Storage Considerations :
1) Four n-vectors of additional storage are required, for s, y, t, and u. This
can be reduced to two vectors simply by replacing t by s and u by y in all
instances in the algorithm below. (I.e., t and u are only used to make the
algorithm easier to follow.)
2) The entire matrix M is used at intermediate stages of this algorithm,
although only the lower triangle and main diagonal are needed for input to
and output from the algorithm.
3) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 3.
Description :
1) If yTs < (ma.cheps) ||s||2||y/||2, or for every i, 
| ( y — L L
T s ) [ i ] \ is less than
the estimated noise in y [ i ] , the update is skipped. The estimated noise in
y[i] is calculated by tot * (|gc [i] + | g + [ i ] | ) where tol= 
if analytic gra-
dients are being used, tol= 
if finite difference gradients are being used.
2) 
If the update is to be performed, 
and
t - y—a.LLTs are calculated, and LT is copied into the upper triangle of M.
Then Algorithm A3.4.1 is called, returning in the upper triangle of M the
matrix R+ for which 
is then copied into the
lower triangle of M and returned as the new value L+.
Algorithm :
1. s «- x+ — xc
2. y 
g + -gc
3. temp 1 
y Ts
4. IF temp 1 
(macheps) 
\\s \\2\\y \\2 THEN
(* ELSE update is skipped and algorithm terminates *)

358 
Appendix A
(* t 
LTs : *)
4.1 FORi = 1 TOn DO
4.4 IF cmaLgrad = TRUE
THEN 
fol
ELSE 
tol
4.5 skipupdate 
TRUE
4.6 FORi = 1 TOn DO
(* temp3 «- LLTs)[i] : *)
4.6.1 temp3
4.6.2 IF \ y [ i ] - temp3\ * tol •max 
JTHEN
skipupdate 
FALSE
4.6.3 u[i] 
y [ i ] - a * temp3
4.7 IF skipupdate - FALSE THEN
(* do update; ELSE update is skipped and algorithm terminates *)
4.7.1 tempS
4.7.2 FORi = 1TOn DO
t [ i ] *- temp3 *t[i]
(* copy LT into upper triangle of M : *)
4.7.3 FORi = 2 TOn DO
4.7.3.1 FOR; = ITOi-l DO
M [j,i] M[i,j]
(* Call Alg. A3.4.1 to calculate the QR factorization of LT + utT : *)
4.7.4 CALL QRUPDATE(n,t,-u,2,M,M)
(* second L is a dummy parameter *)
(* copy transpose of upper triangle of M into L : *)
4.7.5 FORi =2 TOn DO
4.7.5.1 FOR; = 1 TO i-l DO
M[i,j 
MM
(* end of IFTHEN 4.4, and of IFTHEN 4 *)
(* RETURN from Algorithm A9.4.2 *)
(* END, Algorithm A9.4.2 *)

Appendix A 
359
ALGORITHM A9.4 3 (INTTHESSUNFAC)
INITIAL HESSIAN FOR SECANT UPDATES
IN UNFACTORED FORM
Purpose:
where
Input Parameters : neZ, / e/? (=/ (x0)), typf e/?( 5xe#n
Input-Output Parameters : none
Output Parameters : #e/?nxn symmetric
Storage Considerations :
1) No additional vector or matrix storage is required.
2) Only the upper triangle of H, including the main diagonal, is used.
(These are the only portions of H that are referenced by the rest of the sys-
tem of algorithms.)
3) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 3.
Algorithm :
1. temp *- maxj \f \, typf }
2. FOR i = 1 TO n DO
2.1 H[i,i] «- temp * Sx[i] * St[i]
2.2 FOR; = i + 1 TO n DO
H [ i , j ] « - 0
(* RETURN from Algorithm A9.4.3 *)
(* END, Algorithm A9.4.3 *)
ALGORITHM A9.4.4 (INITHESSFAC)
INITIAL HESSIAN FOR SECANT UPDATES
IN FACTORED FORM
Purpose:
, where
Input Parameters : neZ, / e/? (=/ (x0))- typf e/?, 5ze^n
Input-Output Parameters: none
Output Parameters : 
Z,e#
lower triangular

360 
Appendix A
Storage Considerations :
1) No additional vector or matrix storage is required.
2) Only the lower triangle of L. including the main diagonal, is used.
3) There are no changes to this algorithm if one is economizing on matrix
storage as described in Guideline 3.
Algorithm :
1. temp
2. FOR i - 1 TO n DO
2.1 £[i,i]<- temp*Sx[i]
2.2 FOR j - 1 TO i-1 DO
L [ i , j ] 
0
{* RETURN from Algorithm A9.4.4 *)
(* END, Algorithm A9.4.4 *)

Test Problems*
Test problems are discussed in Section 7.3 and the interested reader should
read that section before this one. More, Garbow, and Hillstrom [1981] pro-
vide a set of approximately 15 test problems each for unconstrained minimi-
zation, systems of nonlinear equations, and nonlinear least squares. Many of
these problems can be run with various values of n. A standard starting
point x0 is given for each problem, and most are intended to be started
from 10* x0 and 100* z0 as well. Thus the number of possible problems pro-
vided by More, Garbow, and Hillstrom actually is quite large. Below we give a
small subset of these problems that might be used in testing a class project
or in very preliminary testing of a new method. Anyone interested in
comprehensive testing is urged to read More, Garbow, and Hillstrom and to
use the larger set of test problems contained therein. Hiebert [1982]
discusses a comparison of codes for solving systems of nonlinear equations
using the test problems in More, Garbow and Hillstrom, and includes sugges-
tions for modifying these problems into problems with poor scaling or prob-
lems where the objective function is noisy.
Problems 1-4 below are standard test problems for both nonlinear
equations and unconstrained minimization. In each case, a set of n single-
valued functions of n unknowns, f i ( x ) , i = l, • • • ,n, is given. The nonlinear
equations function vector is
while the unconstrained minimization objective function is
* by Robert B. Schnabel 
361
Appendix B

362 
Appendix B
Problems 1-3 may be run with various values of n. The standard dimensions
for problems 1 and 2 are n=2 and n=4 respectively, and these should be
tried first. A reasonable first choice for problem 3 is n = 10. Problem 5 is a
difficult and often used test problem for unconstrained minimization only.
We copy Mor6, Garbow, and Hillstrom and list for each problem: a the
dimension n; b) tne nonlinear functton(s); c) the starting point xc; d) the
root and minimizer x if it is available in closed form. The minimum value
of /(x) is zero in all cases. All these problems may be started from x0,
10*x0, or 100*x0. For the original source of each problem, see Mor6, Gar-
bow, and Hillstrom.
1) Extended Rosenbrock Function
a) n = any positive multiple of 2
b) for i = l, • ,n/2 :
/2^-l(z) =
f2i(*) = 1 -x2i-l
c)x0 = (-1.2, 1, • • • ,-1.2, 1)
d)ar. = (1, 1, • • • ,1, 1)
2) Extended Powell Singular Function
a) n = any positive multiple of 4
b) for i=l, • • • ,n/4 :
c)x0 = (3,-l,0,l, • • ' ,3,-1,0,1)
d)xB = (0,0,0,0, 
,0,0,0,0)
note: both F"'(x ) and V2/ (x ) are singular
3) Trigonometric Function
a) n = any positive integer
b) for i=l, • • • , 
:
- cos Xi) - sinxt)
/=i
c) x0 = (1/n, 1/n, 
,1/n)
4) Helical Valley Function
a)n = 3
b)f 1(x)= 10(x3-I00(x1.x8))
f2(x) = 10 f3(x) =x3
where
(x,, xz) = (l/2 ) arctan(x2/x1) if X1 > 0

Appendix B 
363
(x1, zz) = (l/2 ) arctan(x2/x1) + 0.5 if xl < 0
c)xo = (-1, 0, 0)
d)*« = (1, 0, 0)
5) FKood Function
a) n = 4
b) 
/(*) = 100(z? -x2)2 + (l -zj)8 
+90(z| -x 4) 2-H(l-x 3) 2
-»- 10.1((1 -x2)2 + (l -z4)2) + 19.8(1 -z2)(l -x4)
c)z0 = (-3, -1, -3, -1)
d) *» = (!, 1, 1, 1)

References
Aasen, J. O. (1971), "On the reduction of a symmetric matrix to tridiagonal
form," BIT 11, 233-242.
Aho, A. V., J. E. Hopcroft, and J. D. Ullman (1974). The Design and Analysis of
Computer Algorithms, Addison-Wesley, Reading, Mass.
Allgower, E., and K. Georg (1980), "Simplicial and continuation methods for
approximating fixed points and solutions to systems of equations," SI AM Review 22,
28-85.
Armijo, L., (1966), "Minimization of functions having Lipschitz-continuous first
partial derivatives," Pacific J. Math. 16, 1-3.
Avriel, M. (1976), Nonlinear Programming: Analysis and Methods, Prentice-Hall,
Englewbod Cliffs, N.J.
Bard, Y. (1970), Nonlinear Parameter Estimation, Academic Press, New York.
Barnes, J. (1965), "An algorithm for solving nonlinear equations based on the
secant method," Comput. J. 8, 66-72.
Bartels, R., and A. Conn. (1982), "An approach to nonlinear l, data fitting," in
Numerical Analysis, Cocoyoc 1981, ed. by J. P. Hennart, Springer Verlag. Lecture Notes
in Math. 909,48-58.
Bates, D. M., and D. G. Watts (1980), "Relative curvature measures of nonlin-
earity," J. Roy. Statist. Soc. Ser. B 42, 1-25, 235.
Beale, E. M. L. (1977), "Integer programming," in The State of the Art in Nu-
merical Analysis, D. Jacobs, ed., Academic Press, London, 409-448.
Beaton, A. E., and J. W. Tukey (1974), "The fitting of power series, meaning
polynomials, illustrated on hand-spectroscopic data," Technometrics 16, 147-192.
364

References 
365
Boggs, P. T., and J. E. Dennis, Jr. (1976), "A stability analysis for perturbed
nonlinear iterative methods," Math. Comp. 30, 1-17.
Brent, R. P. (1973), Algorithms For Minimization Without Derivatives, Prentice-
Hall, Englewood Cliffs, N.J.
Brodlie, K. W. (1977), "Unconstrained minimization," in The State of the Art in
Numerical Analysis, D. Jacobs, ed., Academic Press, London, 229-268.
Broyden, C. G. (1965), "A class of methods for solving nonlinear simultaneous
equations," Math. Comp. 19, 577 593.
Broyden, C. G. (1969), "A new double-rank minimization algorithm," AMS
Notices 16, 670.
Broyden, C. G. (1970), "The covergence of a class of double-rank minimization
algorithms," Parts I and II, J.l.M.A. 6, 76-90, 222-236.
Broyden, C. G. (1971), "The convergence of an algorithm for solving sparse
nonlinear systems," Math. Comp. 25, 285-294.
Broyden, C. G., J. E. Dennis, Jr., and J. J. More (1973), "On the local and
superlinear covergence of quasi-Newton methods," J.l.M.A. 12, 223-246.
Bryan, C. A. (1968), "Approximate solutions to nonlinear integral equations,"
SI AM J. Numer. Anal. 5, 151-155.
Buckley, A. G. (1978), "A combined conjugate gradient quasi-Newton mini-
mization algorithm," Math. Prog. 15, 200-210.
Bunch, J. R., and B. N. Parlett (1971), "Direct methods for solving symmetric
indefinite systems of linear equations," SI AM J. Numer. Anal. 8, 639-655.
Cline, A. K., C. B. Moler, G. W. Stewart, and J. H. Wilkinson (1979), "An
estimate for the condition number of a matrix," SI AM J. Numer. Anal. 16, 368-375.
Coleman, T. F., and J. J. More (1983), "Estimation of sparse Jacobian matrices
and graph coloring problems," SI AM J. Numer. Anal. 20, 187-209.
Coleman, T. F., and J. J. More (1982), "Estimation of sparse Hessian matrices
and graph coloring problems," Argonne National Labs, Math-C. S. Div. TM-4.
Conte, S. D., and C. de Boor (1980), Elementary Numerical Analysis: An Algo-
rithmic Approach, 3d ed., McGraw-Hill, New York.
Curtis, A., M. J. D. Powell, and J. K. Reid (1974), "On the estimation of sparse
Jacobian matrices," J.l.M.A. 13, 117 120.
Dahlquist, G., A. Bjorck, and N. Anderson (1974), Numerical Methods, Prentice-
Hall, Englewood Cliffs, N.J.
Davidon, W. C. (1959), "Variable metric methods for minimization," Argonne
National Labs Report ANL-5990.
Davidon, W. C. (1975), "Optimally conditioned optimization algorithms without
line searches," Math. Prog. 9, 1-30.
Dem bo, R. S., S. C. Eisenstat, and T. Steihaug (1982). "Inexact Newton meth-
ods," SI AM J. Numer. Anal. 19, 400-408.
Dennis, J. E., Jr. (1971), "Toward a unified convergence theory for Newton-like
methods," in Nonlinear Functional Analysis and Applications, L. B. Rail, ed., Academic
Press, New York, 425 472.
Dennis, J. E., Jr. (1977), "Nonlinear least squares and equations," in The State of
the Art in Numerical Analysis, D. Jacobs, ed., Academic Press, London, 269-312.
Dennis, J. E., Jr. (1978), "A brief introduction to quasi-Newton methods," in
Numerical Analysis, G. H. Golub and J. Oliger, eds., AMS, Providence, R.I., 19-52.
Dennis, J. E., Jr., D. M. Gay, and R. E. Welsch (1981a), "An adaptive nonlinear
least-squares algorithm," TOMS 7, 348-368.

366 
References
Dennis, J. E., Jr., D. M. Gay, and R. E. Welsch (1981b), "Algorithm 573
NL2SOL—An adaptive nonlinear least-squares algorithm [E4]," TOMS 7, 369-383.
Dennis, J. E., Jr., and E. S. Marwil (1982), "Direct secant updates of matrix
factorizations," Math. Comp. 38,459-474.
Dennis, J, E., Jr., and H. H. W. Mei (1979), "Two new unconstrained opti-
mization algorithms which use function and gradient values," J. Optim. Theory .Appl.
28, 453-482.
Dennis, J. E., Jr., and J. J. More (1974), "A characterization of superlinear con-
vergence and its application to quasi-Newton methods," Math. Comp. 28, 549-560.
Dennis, J. E., Jr., and J. J. More (1977), "Quasi-Newton methods, motivation and
theory," SI AM Review 19, 46-89.
Dennis, J. E., Jr., and R. B. Schnabel (1979), "Least change secant updates for
quasi-Newton methods," SI AM Review 21, 443-459.
Dennis, J. E., Jr., and R. A. Tapia (1976), "Supplementary terminology for non-
linear iterative methods," SIGNUM Newsletter 11:4, 4-6.
Dennis, J. E., Jr., and H. F. Walker (1981), "Convergence theorems for least-
change secant update methods," SI AM J. Numer. Anal. 18,949-987,19,443.
Dennis, J. E., Jr., and H. F. Walker (1983), "Sparse secant update methods for
problems with almost sparse Jacobians," in preparation.
Dixon, L. C. W. (1972a), "Quasi-Newton family generate identical points," Parts
I and II, Math. Prog. 2, 383-387, 2nd Math. Prog. 3, 345-358.
Dixon, L. C. W. (1972b), "The choice of step length, a crucial factor in the
performance of variable metric algorithms," in Numerical Met hods for Non-linear Opti-
mization, F. Lootsma, ed., Academic Press, New York, 149-170.
Dixon, L. C. W., and G. P. Szego (1975, 1978), Towards Global Optimization,
Vols. 1, 2, North-Holland, Amsterdam.
Dongarra, J. J., J. R. Bunch, C. B. Moler, and G. W. Stewart (1979), UNPACK
Users Guide, SIAM Publications, Philadelphia.
Fletcher, R. (1970), "A new approach to variable metric algorithms," Comput. J.
13,317-322.
Fletcher, R. (1980), Practical Methods of Optimization, Vol. 1, Unconstrained
Optimization, John Wiley & Sons, New York.
Fletcher, R., and M. J. D. Powell (1963), "A rapidly convergent descent method
for minimization," Comput. J. 6, 163-168.
Ford, B. (1978), "Parameters for the environment for transportable numerical
software," TOMS 4, 100-103.
Fosdick, L. ed. (1979), Performance Evaluation of Numerical Software, North-
Holland, Amsterdam.
Frank, P., and R. B. Schnabel (1982), "Calculation of the initial Hessian approxi-
mation in secant algorithms," in preparation.
Gander, W. (1978), "On the linear least squares problem with a quadratic con-
straint," Stanford Univ. Computer Science Tech. Rept. STAN-CS-78-697, Stanford,
Calif.
Gander, W. (1981), "Least squares with a quadratic constraint," Numer. Math.
36, 291 307. [This is an abbreviated version of Gander (1978).]
Garfinkel, R. S., and G. L. Nemhauser (1972), Integer Programming, John Wiley
& Sons, New York.

References 
367
Gay, D. M. (1979), "Some convergence properties of Broyden's method," SI AM
J. Numer. Anal,. 16, 623 630.
Gay, D. M. (1981), "Computing optimal locally constrained steps," SI AM J. Sci.
Stat. Comp. 2, 186 197.
Gay, D. M., and R. B. Schnahel (1978), "Solving systems of nonlinear equations
by Broyden's method with projected updates." in Nonlinear Proyramminy 3, O.
Mangasarian, R. Meyer, and S. Robinson, eds.. Academic Press, New York, 245-281.
Gill, P. K.. G. H. Golub, W. Murray, and M. A. Saunders (1974), "Methods for
modifying matrix factorizations," Math. Comp. 28, 505 535.
Gill, P. K., and W. Murray (1972), "Quasi-Newton methods for unconstrained
optimi/ation," J.I.M.A. 9, 91 108.
Gill, P. E., W. Murray and M. H. Wright (1981), Practical Optimization, Academ-
ic Press. London.
Goldfarb, D. (1976), "Kactorized variable metric methods for unconstrained opti-
mi/ation." Math. Comp. 30. 796 811.
Goldfarb, D, (1970). "A family of variable metric methods derived by variational
means." Math. Comp, 24. 23 26.
Goldfcldt. S. M.. R. E. Quandt. and H. K. Trotter (1966), "Maximization by
quadratic hill-climbing." Econometrica 34. 541 551.
Goldstein. A. A. (1967). Constructive Real Analysis, Harper & Row. New York.
Golub. G. H.. and V. Pereyra (1973). "The differentiation of pseudo-inverse and
non-linear least squares problems whose variables separate." SI AM J. Numer. Anal. 10.
413 432.
Golub. G. H., and C, Van Loan (1983), Matrix Computations, the Johns Hopkins
University Press.
Greenstadt. J. L. (1970), "Variations on variable-metric methods," Math. Comp.
24. 1 22.
Griewank, A. O., (1982), "A short proof of the Dennis-Schnabel theorem." K.l.T.
::, 252 256.
Griewank. A. O., and Ph. L. Toint (I982a). "Partitioned variable metric updates
for large sparse optimisation problems." Numer. Math. 39, 119 37.
Griewank. A. O.. and Ph. L. Toint (1982b). "Local convergence analysis for
partitioned quasi-Newton updates in the Broyden class," to appear in Numer. Math.
Griewank. A. O.. and Ph. L. Toint (1982c), "On the unconstrained optimization
of partially separable functions," in Nonlinear Optimization. M. J. D. Powell, ed.. Aca-
demic Press, London.
Hamming. R. W. (1973). Numerical Methods for Scientists and Engineers. 1 ed.,
McGraw-Hill. New York.
Hebden, M. D. (1973). "An algorithm for minimization using exact second de-
rivatives," Rept. TP515. A.E.R.E., Harwell, England.
Hestenes. M. R (1980), Conjugate-Direction Methods In Optimization. Springer
Verlag. New York.
Hiebert, K. L, (1982). "An evaluation of mathematical software that solves sys-
tems of nonlinear equations," TOMS 8, 5 20.
Huber, P. J. (1973), "Robust regression: asymptotics, conjectures, and Monte
Carlo," Anals of Statistics 1, 799-821.
Huber, P. J. (1981), Robust Statistics, John Wiley & Sons, New York.

368 
References
Johnson, G. W., and N. H. Austria (1983), "A quasi-Newton method employing
direct secant updates of matrix factorizations," SI AM J. Numer. Anal. 20, 315-325.
Kantorovich, L. V. (1948), "Functional analysis and applied mathematics,"
Uspehi Mat. Nauk. 3, 89-185; transl. by C. Benster as N.B.S. Kept. 1509, Washington,
D. C, 1952.
Kaufman, L. C. (1975), "A variable projection method for solving separable
nonlinear least squares problems," BIT 15, 49-57.
Lawson, C. L., R. J. Hanson, D. R. Kincaid, and F. T. Krogh (1979), "Basic linear
algebra subprograms for Fortran usage," ACM TOMS 5, 308-323.
Levenberg, K. (1944), "A method for the solution of certain problems in least
squares," Quart. Appl. Math. 2, 164-168.
Marquardt, D. (1963), "An algorithm for least-squares estimation of nonlinear
parameters," SI AM J. Appl. Math. II, 431-441.
Marwil, E. S. (1978), "Exploiting sparsity in Newton-type methods," Cornell
Applied Math. Ph.D. Thesis.
Marwil, E. S. (1979), "Convergence results for Schubert's method for solving
sparse nonlinear equations," SI AM J. Numer. Anal.'\6, 588-604.
More, J. J. (1977), "The Levenberg-Marquardt algorithm: implementation and
theory," in Numerical Analysis, G. A. Watson, ed., Lecture Notes in Math. 630,
Springer Verlag, Berlin, 105-116.
More, J. J., B. S. Garbow, and K. E. Hillstrom (1980), "User guide for
MINPACK-1," Argonne National Labs Report ANL-80-74.
More, J. J., B. S. Garbow, and K. E. Hillstrom (1981a), "Testing unconstrained
optimization software," TOMS 7, 17-41.
More, J. J., B. S. Garbow, and K. E. Hillstrom (1981b), "Fortran subroutines for
testing unconstrained optimization software," TOMS 7, 136-140.
More, J. J., and D. C. Sorensen (1979), "On the use of directions of negative
curvature in a modified Newton method," Math. Prog. 16, 1-20.
Murray, W. (1972), Numerical Methods for Unconstrained Optimization, Academ-
ic Press, London.
Murray, W., and M. L. Overton (1980), "A projected Lagrangian algorithm for
nonlinear minimax optimization," SI AM J. Sci. Statist. Comput. 1, 345-370.
Murray, W., and M. L. Overton (1981), "A projected Lagrangian algorithm for
nonlinear /, optimization," SI AM J. Sci. Statist. Comput. 2, 207-224.
Nelder, J. A., and R. Mead (1965), "A simplex method for function mini-
mization," Comput. J. 1, 308-313.
Oren, S. S., (1974), "On the selection of parameters in self-scaling variable metric
algorithms," Math. Prog. 7, 351-367.
Ortega, J. M., and W. C. Rheinboldt (1970), Iterative Solution of Nonlinear
Equations in Several Variables, Academic Press, New York.
Osborne, M. R. (1976), "Nonlinear least squares—the Levenberg algorithm re-
visited," J. Austral. Math. Soc. 19 (Series B), 343-357.
Powell, M. J. D. (1970a), "A hybrid method for nonlinear equations," in Nu-
merical Methods for Nonlinear Algebraic Equations, P. Rabinowitz, ed., Gordon and
Breach, London, 87-114.
Powell, M. J. D. (1970b), "A new algorithm for unconstrained optimization," in
Nonlinear Programming, J. B. Rosen, O. L. Mangasarian, and K. Ritter, eds., Academic
Press, New York, 31-65.

References 
369
Powell, M. J. D. (1975), "Convergence properties of a class of minimization
algorithms," in Nonlinear Programming 2, O. Mangasarian, R. Meyer, and S. Robinson,
eds. Academic Press, New York, 1-27.
Powell, M. J. D. (1976), "Some global convergence properties of a variable metric
algorithm without exact line searches," in Nonlinear Programming, R. Cottle and
C. Lemke, eds., AMS, Providence, R. I., 53-72.
Powell, M. J. D. (1981), "A note on quasi-Newton formulae for sparse second
derivative matrices," Math. Prog. 20, 144-151.
Powell, M. J. D., and Ph. L. Toint (1979), "On the estimation of sparse Hessian
matrices," SI AM J. Numer. Anal. 16, 1060-1074.
Pratt, J. W. (1977), "When to stop a quasi-Newton search for a maximum
likelihood estimate," Harvard School of Business WP 77-16.
Reid, J. K. (1973), "Least squares solution of sparse systems of non-linear equa-
tions by a modified Marquardt algorithm," in Proc. NATO Con/, at Cambridge, July
1972, North-Holland, Amsterdam, 437-445.
Reinsch, C. (1971), "Smoothing by spline functions, II," Numer. Math. 16, 451-
454.
Schnabel, R. B. (1977), "Analysing and improving quasi-Newton methods for
unconstrained optimization," Ph.D. Thesis, Cornell Computer Science TR-77-320.
Schnabel, R. B. (1982), "Convergence of quasi-Newton updates to correct deriva-
tive values," in preparation.
Schnabel, R. B., B. E. Weiss, and J. E. Koontz (1982), "A modular system of
algorithms for unconstrained 
minimization," 
Univ. Colorado Computer Science,
TR CU-CS-240-82.
Schubert, L. K. (1970), "Modification of a quasi-Newton method for nonlinear
equations with a sparse Jacobian," Math. Comp. 24, 27-30.
Shanno, D. F. (1970), "Conditioning of quasi-Newton methods for function mini-
mization," Math. Comp. 24, 647-657.
Shanno, D. F. (1978), "Conjugate-gradient methods with inexact searches,"
Math, of 0per. Res. 3, 244-256.
Shanno, D. F. (1980), "On the variable metric methods for sparse Hessians,"
Math. Comp. 34, 499-514.
Shanno, D. F., and K. H. Phua (1978a), "Matrix conditioning and nonlinear
optimization," Math. Prog. 14, 145 160.
Shanno, D. F., and K. H. Phua (1978b), "Numerical comparison of several
variable metric algorithms," J. Optim. Theory Appl. 25, 507-518.
Shultz, G. A., R. B. Schnabel, and R. H. Byrd (1982),. "A family of trust region
based algorithms for unconstrained minimization with strong global convergence
properties," Univ. Colorado Computer Science TR CU-CS-216-82.
Sorensen, D. C. (1977), "Updating the symmetric indefinite factorization with
applications in a modified Newton's method," Ph.D. Thesis, U. C. San Diego, Argonne
National Labs Report ANL-77-49.
Sorensen, D. C. (1982), "Newton's method with a model trust region modifi-
cation," SI AM J. Numer. Anal. 19, 409-426.
Steihaug, T. (1981), "Quasi-Newton methods for large scale nonlinear problems,"
Ph.D. Thesis, Yale University.
Stewart, G. W., Ill (1967), "A modification of Davidon's method to accept differ-
ence approximations of derivatives," J. ACM 14, 72-83.

370 
References
Stewart, G. W., Ill (1973), Introduction to Matrix Computations, Academic Press,
New York.
Strang, G. (1976), Linear Algebra and Its Applications, Academic Press, New
York.
Toint, Ph. L. (1977), "On sparse and symmetric matrix updating subject to a
linear equation," Math. Comp. 31, 954-961.
Toint, Ph. L. (1978), "Some numerical results using a sparse matrix updating
formula in unconstrained optimization," Math. Comp. 32, 839-851.
Toint, Ph. L. (1981), "A sparse quasi-Newton update derived variationally with a
non-diagonally weighted Frobenius norm," Math. Comp. 37, 425-434.
Vandergraft, J. S. (1978), Introduction to 'Numerical Computations, Academic
Press, New York.
Wilkinson, J. H. (1963), Rounding Errors in Algebraic Processes, Prentice-Hall,
Englewood Cliffs, N.J.
Wilkinson, J. H. (1965), The Algebraic Eigenvalue Problem, Oxford University
Press, London.
Wolfe, P. (1969), "Convergence conditions for ascent methods," SI AM Review 11,
226-235.
Wolfe, P. (1971), "Convergence conditions for ascent methods. II: Some correc-
tions," SI AM Review 13, 185-188.
Zirilli, F. (1982), "The solution of nonlinear systems of equations by second order
systems of o.d.e. and linearly implicit A-stable techniques," SI AM J. Numer. Anal. 19,
800-815.

Author Index
Aasen, J., 51
Aho, A., 11
Allgower, E., x, 5, 152
Anderson, N., 15
Armijo, L., 119
Austria, N., 258
Avriel, M., x, 15
Bard, Y., 219, 235
Barnes, J., 190
Bartels, R., 235
Bates, D., 235
Beale, E., 10
Beaton, A., 235
Bjorck, A., 15
Boggs, P., 106
Brent, R., 15
Brodlie, K., 203
Broyden, C., 168, 170, 174, 189, 197, 201, 206, 211,
213, 245
Bryan, C., 108
Buckley, A., 246
Bunch, J., 51,66
Byrd, R., 154
Cline, A., 55, 309, 310
Coleman, T., 242
Conte, S., 15
Curtis, A., 240, 242
Dahlquist, G., 15
Davidon, W., 203, 212
deBoor, C., 15
Dembo, R., 246
Dennis, J., x, 93, 106, 123, 167, 174, 181, 196, 197, 206,
213, 228, 229, 232, 233, 234, 238, 246, 250, 251, 254,
256, 258
Dixon, L., 5, 203
Dongarra, J., 51, 66
Eisenstat, S., 246
Fletcher, R., 133, 167, 203, 212, 246
Ford, B., 14
Fosdick, L., 163
Frank, P., 209
Gander, W., 136
Garbow, B., 162, 187,361,362
Garfinkel, R., 10
Gay, D., 36, 133, 139, 186, 190, 192, 229, 232, 233, 234,
238, 256, 258
Georg, K., x, 5, 152
Gill, P., x, 58, 101, 188, 246, 279, 300, 302, 318, 319
Goldfarb, D., 58, 201
Goldfeldt, S., 133
Goldstein, A., 115, 119, 152
Golub, G., 41, 51, 58, 234, 238, 246
Greenstadt, J., 198, 205
Griewank, A., 246, 257
Hamming, R., 279, 300, 302
Hanson, R., 271
Hebden, M., 136
Hestenes, M., 246
Hiebert, K., 361
Hillstrom, K., 162, 187,361,362
Hopcroft, J., 11
Huber, P., 235, 236
Johnson, G., 258
Kantorovich, L., 92
Kaufman, L., 234
Kincaid, D., 271
Koontz, J., 161,263,265,266
371

372 
Author Index
Krogh, F., 271
Lawson, C, 271
Levenberg, K., 133, 227
Marquardt, D., 133,227
Marwil, E., 245, 258
Mei, H., 142
Moler, C, 51, 55, 66, 309, 310
More, J., 101, 123, 133, 136, 137, 162, 167, 174, 181,
187, 196, 197, 206, 213, 227, 228, 233, 238, 242, 361,
362
Murray, W., x, 58, 101, 188, 235, 246, 279, 300, 302,
318,319
Nemhauser, G., 10
Oren, S., 209
Ortega, J., 21, 69, 83,91
Osborne, M., 228
Overton, M., 235
Parlett, B, 51
Pereyra, V., 234, 238
Phua,K., 209, 212, 233
Powell, M., 139, 142, 196, 203, 210, 211, 228, 240, 242,
250, 257
Pratt, J., 234
Quandt, R., 133
Reid, J., 240, 242, 245
Reinsch, C, 136
Rheinboldt, W., 21,69, 83,91
Saunders, M., 58
Schnabel, R., 154, 161, 196, 207, 209, 212, 246, 250,
263, 265, 266
Schubert, L., 245
Shanno, D., 201, 209, 212, 233, 245, 246
Shultz,G., 154
Sorensen, D., 58,101,139
Steihaug,!., 154, 246
Stewart, G., 41, 51, 55, 66, 67, 238, 304, 309, 310
Strang,G., 41
Szego, G., 5
Tapia, R., 167
Toint, Ph., 242, 245, 246, 257
Trotter, H., 133
Tukey, J., 235
Ullman, J., 11
Vandergraft, J., 265, 267
Van Loan, C, 41,51,246
Walker, H., 174, 232, 251, 254, 256, 258
Watts, D., 235
Weiss, B., 161,263,265,266
Welsch, R., 229, 232, 233, 234, 238, 256, 258
Wilkinson, J., 10, 40, 53, 54, 55, 309, 310
Wolfe, P., 120, 121
Wright, M., x, 101, 246, 279, 300, 302, 318, 319
Zirilli, F., 152

Subject Index
A
Absolute error, 11, 13
Accuracy of nonlinear function, 8, 32, 97, 105, 279,
292
effect on finite precision derivatives, 32, 96-99,
103 6
effect on secant updates, 188, 209
Accuracy of solution, 8-9, 233
Affine model, 18, 75, 87, 100, 159, 169-70, 219
ALGOL, 265, 267
Algorithms, modular, 259-360
class projects, use in, 262-63
description, 264-71
format of pseudo-code, 267-70
implementation language, choice of, 263, 265, 276
precision requirements, 270
B
Back substitution, 49
Backtracking line search, 117, 126-29
Backward error analysis, 53
Banded matrix, 242, 256
BFGS method, 198-203, 205-11,213-14, 245, 252
algorithms, 355-60
convergence, 206, 210-11
implementation, 201, 208-10, 278
Bisection, method of, 25
BLAS (Basic Linear Algebra Subroutines), 271
Block-diagonal matrix, 48-51, 67
Bounded deterioration, 175-79, 190, 205, 213
Broyden class of updates, 211-12
Broyden's method, 169-92, 252, 254
algorithms, 352-55
convergence, 174-86
implementation, 186-89, 291
c
C,(D), 70
C2(/)),72
Cauchy point, 139-40
Cauchy-Schwartz inequality, 43
Central-difference derivative approximation, 32
gradient, 79, 105-6, 110
gradient, algorithm, 323 25
Hessian, 84
switch from forward to central-difference gradients,
106, 324
Choice of method:
for nonlinear equations, 97, 167, 290^ 91
for nonlinear least squares, 228, 233
for unconstrained minimization, 105-6, 143, 167
203, 277-78
Choice of tolerances:
for nonlinear equations, 278-80, 291 92
for unconstrained minimization, 278 80
Cholesky decomposition, 50-51, 67
algorithm, 318-19
modified, 101-3
updating, 57-58, 200-201, 208, 246
Condition number, 53-54
estimating, 54-55, 67
estimating, algorithm, 309 11
nonlinear equations algorithms, use in, 151
373

374 Subject Index
Conjugate gradient methods, 154, 245-46
Constrained optimization, 3, 7, 131
Continuously differentiate function, C^D), C2(D),
70-73
Contractive mapping theorem, 93-94, 108-9
Convergence (local) (See also Global convergence)
definition, 19, 42
finite-difference Newton's method, 29-31, 95-96,
106
Gauss-Newton method, 222-26, 236
Levenberg-Marquardt method, 227-28
line search methods, 123-25
Newton's method, 21-24, 34, 37, 89-93, 100, 107,
220, 229
rates of, 20-21, 36
secant methods, 29-31, 174-86, 190, 196-98, 206,
210-11,213, 232, 245, 251 56
steepest descent method, 115-16, 152
Convex function, 81-83, 100, 210-11
Convex set, 70
Cubic interpolation in line search, 128-29, 150
D
Data fitting (See Linear least squares; Non-
linear least squares, /,, I f)
general, 235-36, 248-49
Derivative approximation, derivative-free methods
(See Finite-difference derivatives and methods;
Secant methods)
Derivatives, availability of, 4, 8, 27, 167, 220, 229, 277,
290
existence of, 4
multivariate, 69-73
Derivatives, first (See Gradient vector; Jacobian
matrix)
Derivatives, second (See Hessian matrix)
Descent directions, 81, 113-14, 116, 131-32, 147-48,
151,189,226
Descent method, 81, 113-16
DFP method, 202-6, 213, 231, 249, 252, 256
Diagonally dominant matrix, 60
Diagonal matrix, 48
scaling by, 152, 156-61, 164, 187, 192, 278-79,
291-92
Differentiation, numerical (See Finite-difference de-
rivative)
Directional derivative, 70-72, 113
Discrete 
Newton's 
method (See Finite-difference
Newton's method)
Discrete variable problems, 10
Dogleg step, 139-43, 151-54
algorithm, 336-38
Dot product, 46
E
Efficiency of methods, 3, 163-64
Eigenvalue, 58-60,64, 102, 115, 215
Eigenvector, 58-60, 64
EISPACK, 66
Equivalent function evaluations, 163
Error, measurement of, 11-12
Euclidean norm, 42
Existence of solutions, 16, 87
F
Failure, of line search, 129
of nonlinear equations algorithm, 152, 161, 279-8
292, 350
of unconstrained minimization algorithm, 161, 275
80, 347, 349
Finite-difference derivative approximations:
algorithms, 314-15, 320-25
expense of, 79-80, 167, 229, 278, 291
gradient, 79, 105-6, 110
Hessian, 80, 84, 103-5, 242, 257
Jacobian, 78-79, 96-99, 220, 229, 240-42, 248, 256
one-variable problems, 27-32
sparse problems, 240-42, 256-57
Finite-difference derivative step sizes:
central-difference gradient, 105-6
forward-difference gradient, 105-6
Hessian, from function values, 104-5
Hessian, from gradient values, 103-4
Jacobian, 96-99, 109, 240
one-variable problems, 31-32, 37
Finite-difference Newton's method:
convergence of, 29-31, 95-96, 106
single nonlinear equation, 27-32
systems of nonlinear equations, 94-99, 240
unconstrained minimization, 103-6, 242
Finite-precision arithmetic, 10-12, 270
effect on finite-difference derivatives, 31-32, 96-9
104-6, 109
effect on stopping criteria, 27, 159-60
Floating-point representation of real numbers, 10
FORTRAN, 262-63, 265, 267, 270, 271, 282, 297, 303
Forward-difference derivative approximation, 78 (Si
also Finite-difference derivative approximations
Forward substitution, 49
Frechet differentiability, 83
Frobenius norm, 43-44, 67
use in least-change updates, 171-72
Function evaluation, accuracy of, 8, 32, 97. 105, 18
279, 292
expense of, 9, 28, 79-80, 97, 105-6, 163, 167, 229
242, 278, 291
G
Gateaux differentiability, 83
Gauss-Newton method, 221-28, 232. 236
Gerschgorm theorem, 60, 103
Global convergence:
definition, 5
Levenberg-Marquardt method, 228
line search methods, 117-25, 152, 154
Newton's method, 24, 88, 101
secant methods, 188, 210-11
steepest descent method, 115-16
trust region methods, 154
Global methods:
algorithms, 325-41
choice of, 277, 290
definition, 4
framework, 26,85, 112
one-variable problems, 24-27. 34-35
nonlinear least squares, 225-28. 232
systems of nonlinear equations, 147-54
unconstrained minimization. 113-47, 152-54

Global minimizer, S, 33
Gradient vector, 70-73,148, 219
algorithms, 296-97, 322-25
central-difference approximation, 79,105-6,110
conditions for unconstrained minimum, 81-82
forward-difference approximation, 78-79,105-6
H
Harwell library, 47, 51, 240, 265
Hessian matrix, 70-73, 220 (See also Indefinite matrix;
Positive definite matrix)
algorithms, 297-98, 320-22, 355-60
conditions for unconstrained minimum, 81-82
finite-difference approximation, 80, 84, 103-5
secant approximations, 194-215
singular or ill-conditioned, 101-3,123
sparse finite-difference approximation, 242, 257
sparse secant approximation, 245-46, 251
Holder continuity, 83-84, 107
Hookstep (See Locally constrained optimal step)
Householder transformation, 50, 67, 304, 313
Hybrid algorithm, 26, 85, 112
I
Identity matrix, 44
Ill-conditioned matrices and problems, 52-55 (See
also Hessian matrix; Jacobian matrix)
IMSL library, 47, 240, 265
Indefinite matrix, 51, 59, 82-83
as model Hessian, 82-83, 101-3, 133, 139
Inner product, 46
Integral of vector-valued function, 74
J
Jacobi algorithm, nonlinear, 256
Jacobian matrix, 73-77, 83, 219
algorithms, 298-99, 314-15, 352-55
finite-difference approximation, 78-79, 94-99, 220,
229
secant approximations, 169-93
singular or ill-conditioned, 89, 93, 151, 153-54,
225-28
sparse finite-difference approximation, 240-42, 256
sparse secant approximation, 242-46, 250-51
Jacobi rotation, 56-57, 67-68
algorithm, 312-13
K
Kantorovich theorem, 92-93, 107-8
L
/,,/„, data fitting, 7, 235
'i> '2 • 'oo • ')> vector norms, 42, 66
matrix norms, 43-44, 66
Large problems, 245-46
LDLf decomposition, 50-51, 57-58, 201
Subject Index 375
Least-change secant updates, 170-72, 189, 196, 198,
204-6,213,231-32,244-58
general convergence theory, 246-51
general derivation, 251-56
Least squares (See Linear least squares; Nonlinear
least squares)
Levenberg-Marquardt method, 227 28, 232-33, 237
Linear convergence, 20, 36
contractive mapping theorem, 93-94, 109
of Gauss-Newton method, 222-26, 236
of Levenberg-Marquardt method, 227-28
of secant methods, 174-79, 213, 251-56
of steepest descent method, 115-16, 152
Linear equations, systems of:
algorithms, 304-9, 318-19
errors in solving, 51-55
software, 47, 240
solving, 47-51
sparse, 240, 242
Linear least squares, 60-66, 68, 84, 219, 221, 234,
237-38
Linear model (See Affine model)
Linear transformation of variable space, 156, 159,
164-65, 192,204-6,214
Line search methods:
algorithms, 325-30
convergence theory, 120-25, 152, 154
cubic interpolation, 128-29, 150
failure to terminate, 129
nonlinear least squares, 227
quadratic interpolation, 126-27, 150
step-length selection, practice, 117, 126-29
step-length selection, theory, 117 25, 152, 154
systems of nonlinear equations, 149-51
unconstrained minimization, 116-29, 152, 154, 208
LINPACK, 47
Lipschitz continuity, Lip^D), 21 22, 75-77, 83 84
LLT decomposition (See Cholesky decomposition)
Local convergence (See Convergence, local)
Locally constrained optimal step, 130-39. 149, 151
54, 227, 232, 240
algorithm, 332-34
scaled, 157, 164,227,232
Local method, 4
Local minimizer, 5, 33, 80-84, 159
in nonlinear equations algorithm, 147, 152-53, 292
Local model (See Model of nonlinear function)
Lower triangular matrix, 48-51
LQ decomposition, 65, 68
LU decomposition, 49 51, 58, 258
M
Machine epsilon, 12, 13, 270
algorithm, 303-4
condition number, relation to, 53 54
finite-difference step sizes, use in, 31 32, 97-99,
103-6
stopping criteria, use in, 27, 279, 292
Majorizing sequence, 93
Matrix factorizations, 47-51, 63 66, 102 3
algorithms, 304-5, 311-14, 318 19
updating, 55 58, 187, 200-201, 208
Matrix inversion, 47
continuity of, 45

376 Subject Index
Maximization, 33-34, 101, 109
necessary and sufficient conditions for, 81-83
Mean value theorem, 70, 74
Minimization (See Unconstrained minimization)
MINPACK, 187, 189, 228, 265
Model Hessian matrix, 82-83, 101-3, 114, 116, 133,
194, 198, 229
algorithm, 315-18
Model of nonlinear function, 39
algorithm, unconstrained minimization, 315-18
algorithms, nonlinear equations, 342-47
nonlinear least squares, 219-21, 229
one-variable problems, 17-18, 28, 134-36
systems of nonlinear equations, 75, 87, 147-48, 151,
153, 159, 169-70
unconstrained minimization, 73, 76, 82-84, 100,
102, 130, 145, 195
Model trust region (See Trust region methods)
Modular algorithms or software (See Algorithms;
Software)
Multivariate derivatives, 69-73, 77-80
N
N(x, r), 89
NAG library, 47, 265
Necessary conditions for unconstrained minimization,
33, 80-84
Negative curvature directions, 101, 145
Negative definite matrix, 58, 82-83
Neighborhood, N(x, r), 89
Newton's method (See also Finite-difference Newton's
method)
convergence, nonlinear equations, 21-24, 37, 89-93,
107
convergence, unconstrained minimization, 27,100
as descent method, 114,147-48
for extended precision division, 36
nonlinear least squares, 220, 229
scaled, 156, 165
single nonlinear equation, 16-19
systems of nonlinear equations, 86-89
unconstrained minimizations, 34,99-103
Newton's theorem, 18, 74
NL2SOL, 232-33
Noise in nonlinear function, 32, 96-99, 103-6, 188,
209, 279, 292
Nonlinear equations, systems of:
algorithms (main driver), 285-89, 294-95
Broyden's method, 169-74, 189-92
choosing methods, 97, 167, 290-91
choosing tolerances, 278-80, 291-92
convergence theory, 21-25, 29-31, 89-96, 174-86,
245,251-56
definition, 2
failure to find root, 152, 161, 279-80, 292, 350
finite-difference Newton's method, 28-32, 94-99,
240^12, 256
global methods, 24-27, 147-52
line search methods, 149-51
Newton's method, 16-19, 86-89
one equation in one unknown, 15-32
problems with special structure, 239-58
scaling, 152, 155-61, 165, 187, 192, 278 79, 291-92
secant methods, 28-31, 168-93, 242-58
Nonlinear equations, systems of (com.):
singular Jacobian matrix, 89, 93, 151, 153-54
software, 187, 189
sparse problems, 239^16, 250-51, 254, 256-57
stopping criteria, 27, 160-61
trust region methods, 149
Nonlinear least squares:
algorithms, 238
choosing methods, 228, 233
convergence theory, 222-28, 232, 236, 254-56
definition, 4
derivatives, 219-21
example problem, 6
Gauss-Newton method, 221-28, 232, 236
global methods, 225-28, 232
Levenberg-Marquardt method, 227-28, 232-33, 237
line search methods, 227
Newton's method, 220, 229
partly linear problems, 234, 238
rank-deficient Jacobian, 225-28
residuals, 219-20, 222-28, 230-31, 233-34
secant methods, 229-33, 249, 251, 254-56
software, 228, 232-33
statistical considerations, 219, 234-35, 237-38
stopping criteria, 233-34, 237-38
trust region methods, 227-28, 232
Nonsingular matrix, 44
Normal equations, 62, 221, 237
Norms, vector, 41-43, 66
matrix, 43-45, 66-67
Numerical derivatives (See Finite-difference deriva-
tives)
o
0, o notation, 11
One-variable problems, 15-37
convergence theory, 21-25, 29-31, 34
finite-difference Newton's method, 28-32
global methods, 24-27, 34-35
Newton's method, 16-19, 21-24
one nonlinear equation in one unknown, 15-19,
21-32
secant method, 28-31
unconstrained minimization, 32-35
Operation counts, matrix factorizations, 51
solving factored linear systems, 49
updating matrix factorizations, 57-58
Optimally conditioned secant update, 212
Order of convergence (See Rates of convergence)
Orthogonal factorization (See QR decomposition)
Orthogonal matrix, 46, 48
Orthogonal vectors, 46
Orthonormal vectors, 46, 59, 67
Overdetermined systems of equations (See Linear
least squares; Nonlinear least squares)
Overflow, 12, 13
P
Partial derivatives (See Gradient; Hessian;
Jacobian)
PASCAL, 262, 265, 267, 270, 282
Permutation matrix, 48

Positive definite matrix, 49-51, 58 (See also Cholesky
decomposition)
as model Hessian, 82-83, 101-3, 114, 116, 133, 148,
151, 194, 197-201, 245
sufficient condition for unconstrained minimum,
81-82
Positive definite secant method (see BFGS method)
Precision of real variables, 10-12, 270
Problems with special structure:
partly linear problems, 234, 238, 246-49, 251
secant methods, 246-58
sparse problems, 240-46, 256-57
Program notes, 1, 39, 85, 167, 217
Projected secant updates, 190, 192-93, 212
Projection operator, 176, 183, 195, 205, 243, 250-51,
253, 255
PSB method (See Symmetric secant method)
Pseudoinverse, 65
use in nonlinear equations algorithm, 154
Q
Q-order convergence rates, 20-21, 36 (See also Linear;
Quadratic; Superlinear convergence)
QR decomposition, 49-51, 63, 68
algorithms, 304-5, 311-14
nonlinear equations algorithm, use in, 151-52, 187
nonlinear least squares, use in, 221
updating, 55-57, 187, 201, 246
Quadratic convergence, 20
of finite-difference Newton's method, 29-31, 95-96,
106
of Gauss-Newton method, 222 26
of Levenberg-Marquardt method, 227-28
of line search algorithms, 123-25
of Newton's method, 21 24, 34, 89-93, 100, 102,
220, 229
Quadratic interpolation in line search, 126-27, 150
in trust region method, 144
Quadratic model, 28, 73, 76, 82-84, 100, 102, 130, 145,
147-49, 159,195,220,229
Quasi-Newton direction (or step), 116-17, 123-25,
129-30, 139, 189
Quasi-Newton equation (See Secant equation)
Quasi-Newton method, 26, 112 (See also Secant meth-
ods)
R
Rank deficiency (See Hessian matrix; Jacobian
matrix, singular or ill-conditioned; Singular
value decomposition)
Rank of matrix, 64-66
Rank-one update, 170, 190, 211, 215
Rank-two update, 196, 198, 201, 203, 211 12, 215, 232
Rates of convergence, 20-21, 36 (See also Linear; Q-
order; Quadratic; R-order; Superlinear conver-
gence)
Regression (See Linear least squares; Nonlinear least
squares)
Regression, robust, 235-36
Relative error, 11, 13, 160
Relative nonlinearity, 24, 91, 224
Residuals, 6, 61, 219-20, 222-28, 230-31, 233-34
Subject Index 377
R-order convergence rates, 21, 36, 92-93, 168, 170,
186
ROSEPACK, 66
Round-off errors, 11-13 (See also Finite-precision
arithmetic; Machine epsilon)
S
Saddle point, 81, 101, 109, 115, 165, 349
Scaling, 9
independent variables, 35, 155-60, 164-65, 187, 192,
206, 209, 227, 232, 278-79
objective function for minimization, 35, 153, 209,
279
objective function for nonlinear equations, 27, 152,
158-59, 161, 165, 187, 192, 291-92
Secant equation, 169, 195, 229-30, 248-58
Secant method, one variable problems, 28-31
Secant methods, multi-variable problems (See also
BFGS; Broyden's; 
DFP; 
Symmetric secant
method; 
Optimally 
conditioned; 
Projected
secant updates)
convergence of derivative approximations, 
174,
184-86, 191-92, 206-7, 214
convergence theory, 174-86, 190, 196-98, 206, 210-
11,213,232,245,251-56
implementation, 186-189, 201, 208 10, 278, 291
initial approximation, 172, 187, 209 10, 215, 232
least change updates, 170-72, 189, 196, 198, 204-6,
213,231-32,244-56
nonlinear least squares, 229-33
problems with special structure, 246-56
sparse problems, 242 46, 250-51, 254, 257
systems of nonlinear equations, 168 93, 242 58
unconstrained minimization, 194-215, 245-58
Sensitivity of linear equations, 51-55
Sherman-Morrison-Woodbury formula, 188
Simultaneous nonlinear equations (See Nonlinear
equations)
Single-variable problems (See One-variable problems)
Singular matrix, test for, 47 (See also Hessian matrix;
Jacobian matrix)
Singular value decomposition (SVD), 64-66, 68
Size of nonlinear problems, 8
Software (See also E1SPACK; Harwell; IMSL; LIN-
PACK; 
MINPACK; 
NAG; 
NL2SOL;
ROSEPACK; VARPRO; Yale sparse matrix
package)
evaluation and testing, 161-64
for linear equations, 47, 51, 240
modular, 162, 164, 264
for nonlinear equations, 187, 189
for nonlinear least squares, 228, 232 34
for singular value decomposition, 66
for unconstrained minimization, 265
Sparse matrix, 239
closest to nonsparse matrix, 243
Sparse problems:
finite-difference methods, 240-42, 256-57
secant methods, 242^46, 250-51, 257
secant methods, convergence, 245, 254
Steepest descent direction, 114, 116, 133, 13943, 148,
209, 228
scaled, 156 57, 209

378 Subject Index
Steepest descent method, 114-16, 152-53
Step length, maximum and minimum, 129, 147, 161
Step length selection (See Line search)
Step selection (See Line search; Trust region)
Step size (See Finite-difference derivative step size)
Stopping criteria:
algorithms, 347-52
nonlinear least squares, 233-34, 237-38
one-variable problems, 27-35
systems of nonlinear equations, 160-61
unconstrained minimization, 159-61
Storage for nonlinear equations, 163, 280-82, 292-93
for unconstrained minimization, 163, 280-82
Strictly diagonally dominant matrix, 60
Structure (See Problems with special structure)
Sufficient conditions for unconstrained minimization,
33-34, 80-84
Sum of squares (see Linear least squares; Nonlinear
least squares)
Superlinear convergence, 20
of line search algorithm, 123-25
necessary and sufficient conditions for, 181-83
of secant methods, 29-31, 174 85, 190, 196-98, 206,
210-11.213,232.245.251-56
stopping criteria, relation to, 180
Symmetric matrix, 49 51. 72 (See also Cholesky de-
composition; Hessian matrix)
closest to nonsymmetric matrix, 84, 195-96, 213
Symmetric rank-one update, 211,215
Symmetric secant method, 195-98, 251, 254
Systems of equations (See Linear equations; Nonlin-
ear equations)
T
Taylor series, 18, 34,69-70
Termination criteria (See Stopping criteria)
Testing algorithms and software, 161-64, 361-63
Test problems, 162, 361-43
Tolerances (See Choice of tolerances)
Triangle inequality, 41, 75
for integrals, 22, 74
Triangular matrix, 48-51
Tridiagonal matrix, 242, 257
Truncated Newton's method, 246
Trust region methods:
algorithms, 330-41
convergence theory, 123-25, 154
dogleg step, 139-43. 151-54
initial trust region, 147, 280
locally constrained optimal step (hookstep), 139-43,
149, 151-54
nonlinear lea*t cquarc*, 227-28, 232
Trust region methods (com.):
scaled, 157, 164,227.232
systems of nonlinear equations, 149
unconstrained minimization, 129-47, 153-54
updating trust region, 130, 143-47
U
Unconstrained minimization:
algorithms (main driver), 272-75,283-84
BFGS method, 198-203,205-11,213-14
choosing methods, 105-6. 143, 167, 203. 277-78
choosing tolerances, 278-80
convergence theory, 34, 100, 106, 196-98, 206, 210-
11,213,245.251-56
definition, 3
descent methods, 113-16
example problem, 5
failure to find minimizer, 161, 279-80, 347, 349
finite-difference Newton's method, 103-6,242
global methods, 34-35. 113-47, 152-54
indefinite Hessian matrix. 82-83, 101-3
line search methods, 116 29, 152, 154, 208
Newton's method, 34.99-103
one-variable problems, 32-35
problems with special structure, 242, 245-46,
251-58
scaling, 155-60, 164, 206. 209, 278-79
secant methods, 194-215, 245-58
software. 265
sparse problems. 242, 245-46, 251. 254, 257
stopping criteria, 35,159-61
trust region methods, 129-47, 153-54
Underflow, 12, 13
Uniqueness of solutions, 16, 87
Update methods (See Secant methods)
Updating matrix factorizations, 55 58, 187, 200-201,
208
algorithms, 311-14
Upper triangular matrix, 48-51
V
Variable-metric methods, 205 (See Secant
methods)
Variance-covariance matrix, 234-35. 237-38
VARPRO. 234
Y
Yale sparse matrix package.
240

