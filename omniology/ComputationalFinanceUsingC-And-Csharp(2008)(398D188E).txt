
Computational Finance Using C and C#

Quantitative Finance Series
Aims and Objectives
• Books based on the work of ﬁnancial market practitioners and academics
• Presenting cutting-edge research to the professional/practitioner market
• Combining intellectual rigour and practical application
• Covering the interaction between mathematical theory and ﬁnancial practice
• To improve portfolio performance, risk management and trading book performance
• Covering quantitative techniques
Market
Brokers/Traders; Actuaries; Consultants; Asset Managers; Fund Managers; Regula-
tors; Central Bankers; Treasury Ofﬁcials; Technical Analysis; and Academics for Mas-
ters in Finance and MBA market.
Series Titles
Computational Finance Using C and C#
The Analytics of Risk Model Validation
Forecasting Expected Returns in the Financial Markets
Corporate Governance and Regulatory Impact on Mergers and Acquisitions
International Mergers and Acquisitions Activity Since 1990
Forecasting Volatility in the Financial Markets, Third Edition
Venture Capital in Europe
Funds of Hedge Funds
Initial Public Offerings
Linear Factor Models in Finance
Computational Finance
Advances in Portfolio Construction and Implementation
Advanced Trading Rules, Second Edition
Real R&D Options
Performance Measurement in Finance
Economics for Financial Markets
Managing Downside Risk in Financial Markets
Derivative Instruments: Theory, Valuation, Analysis
Return Distributions in Finance
Series Editor: Dr Stephen Satchell
Dr Satchell is Reader in Financial Econometrics at Trinity College, Cambridge;
Visiting Professor at Birkbeck College, City University Business School and Univer-
sity of Technology, Sydney. He also works in a consultative capacity to many ﬁrms,
and edits the journal Derivatives: use, trading and regulations and the Journal of Asset
Management.

Computational Finance
Using C and C#
George Levy
AMSTERDAM • BOSTON • HEIDELBERG • LONDON • NEW YORK
OXFORD • PARIS • SAN DIEGO • SAN FRANCISCO • SINGAPORE
SYDNEY • TOKYO
Academic Press is an imprint of Elsevier

Cover image courtesy of iStockphoto
Academic Press is an imprint of Elsevier
30 Corporate Drive, Suite 400, Burlington, MA 01803, USA
525 B Street, Suite 1900, San Diego, California 92101-4495, USA
84 Theobald’s Road, London WC1X 8RR, UK
Copyright © 2008, Elsevier Ltd. All rights reserved.
No part of this publication may be reproduced or transmitted in any form or by any
means, electronic or mechanical, including photocopy, recording, or any information
storage and retrieval system, without permission in writing from the publisher.
Permissions may be sought directly from Elsevier’s Science & Technology Rights
Department in Oxford, UK: phone: (+44) 1865 843830, fax: (+44) 1865 853333,
E-mail: permissions@elsevier.com. You may also complete your request on-line
via the Elsevier homepage (http://elsevier.com), by selecting “Support & Contact”
then “Copyright and Permission” and then “Obtaining Permissions.”
Library of Congress Cataloging-in-Publication Data
Levy, George.
Computational Finance Using C and C# / George Levy.
p. cm. – (Quantitative ﬁnance)
Includes bibliographical references and index.
ISBN-13: 978-0-7506-6919-1 (alk. paper) 1. Finance-Mathematical models. I. Title.
HG106.L484 2008
332.0285’5133-dc22
2008000470
British Library Cataloguing-in-Publication Data
A catalogue record for this book is available from the British Library.
For information on all Academic Press publications
visit our Web site at www.books.elsevier.com
Printed in the United States of America
08
09
10
11
9
8
7
6
5
4
3
2
1

To my parents Paul and Paula

blank
left
intentionally
page
This

Contents
Preface
xi
1
Overview of ﬁnancial derivatives
1
2
Introduction to stochastic processes
5
2.1
Brownian motion
5
2.2
A Brownian model of asset price movements
9
2.3
Ito’s formula (or lemma)
10
2.4
Girsanov’s theorem
12
2.5
Ito’s lemma for multiasset geometric Brownian motion
13
2.6
Ito product and quotient rules in two dimensions
15
2.7
Ito product in n dimensions
18
2.8
The Brownian bridge
19
2.9
Time-transformed Brownian motion
21
2.10 Ornstein–Uhlenbeck process
24
2.11 The Ornstein–Uhlenbeck bridge
27
2.12 Other useful results
31
2.13 Selected problems
33
3
Generation of random variates
37
3.1 Introduction
37
3.2 Pseudo-random and quasi-random sequences
38
3.3 Generation of multivariate distributions: independent variates
41
3.4 Generation of multivariate distributions: correlated variates
47
4
European options
59
4.1 Introduction
59
4.2 Pricing derivatives using a martingale measure
59
4.3 Put call parity
60
4.4 Vanilla options and the Black–Scholes model
62
4.5 Barrier options
85
5
Single asset American options
97
5.1 Introduction
97
5.2 Approximations for vanilla American options
97
5.3 Lattice methods for vanilla options
114

viii
Computational Finance Using C and C#
5.4 Grid methods for vanilla options
135
5.5 Pricing American options using a stochastic lattice
172
6
Multiasset options
181
6.1 Introduction
181
6.2 The multiasset Black–Scholes equation
181
6.3 Multidimensional Monte Carlo methods
183
6.4 Introduction to multidimensional lattice methods
185
6.5 Two asset options
190
6.6 Three asset options
201
6.7 Four asset options
205
7
Other ﬁnancial derivatives
209
7.1 Introduction
209
7.2 Interest rate derivatives
209
7.3 Foreign exchange derivatives
228
7.4 Credit derivatives
232
7.5 Equity derivatives
237
8
C# portfolio pricing application
245
8.1 Introduction
245
8.2 Storing and retrieving the market data
254
8.3 The PricingUtils class and the Analytics_MathLib
262
8.4 Equity deal classes
267
8.5 FX deal classes
280
Appendix A:
The Greeks for vanilla European options
289
A.1 Introduction
289
A.2 Gamma
290
A.3 Delta
291
A.4 Theta
292
A.5 Rho
293
A.6 Vega
294
Appendix B:
Barrier option integrals
295
B.1 The down and out call
295
B.2 The up and out call
298
Appendix C:
Standard statistical results
303
C.1 The law of large numbers
303
C.2 The central limit theorem
303
C.3 The variance and covariance of random variables
305
C.4 Conditional mean and covariance of normal distributions
310
C.5 Moment generating functions
311

Contents
ix
Appendix D:
Statistical distribution functions
313
D.1 The normal (Gaussian) distribution
313
D.2 The lognormal distribution
315
D.3 The Student’s t distribution
317
D.4 The general error distribution
319
Appendix E:
Mathematical reference
321
E.1 Standard integrals
321
E.2 Gamma function
321
E.3 The cumulative normal distribution function
322
E.4 Arithmetic and geometric progressions
323
Appendix F:
Black–Scholes ﬁnite-difference schemes
325
F.1 The general case
325
F.2 The log transformation and a uniform grid
325
Appendix G:
The Brownian bridge: alternative derivation
329
Appendix H:
Brownian motion: more results
333
H.1 Some results concerning Brownian motion
333
H.2 Proof of Eq. (H.1.2)
334
H.3 Proof of Eq. (H.1.4)
335
H.4 Proof of Eq. (H.1.5)
335
H.5 Proof of Eq. (H.1.6)
335
H.6 Proof of Eq. (H.1.7)
338
H.7 Proof of Eq. (H.1.8)
338
H.8 Proof of Eq. (H.1.9)
338
H.9 Proof of Eq. (H.1.10)
339
Appendix I:
The Feynman–Kac formula
341
Appendix J:
Answers to problems
343
J.1
Problem 1
343
J.2
Problem 2
344
J.3
Problem 3
345
J.4
Problem 4
346
J.5
Problem 5
346
J.6
Problem 6
347
J.7
Problem 7
348
J.8
Problem 8
350
J.9
Problem 9
350
J.10 Problem 10
352
J.11 Problem 11
354
References
355
Index
361

blank
left
intentionally
page
This

Preface
This book builds on the author’s previous book Computational Finance: Nu-
merical Methods for Pricing Financial Instruments, which contained informa-
tion on pricing equity options using C code. The current book covers the fol-
lowing instrument types:
• Equity derivatives
• Interest rate derivatives
• Foreign exchange derivatives
• Credit derivatives
There is also an extensive ﬁnal chapter which demonstrates how a C-based
analytics pricing library can be used by C# portfolio valuation software. In ad-
dition this application:
• illustrates the use of C# dictionaries, abstract classes and .NET InteropSer-
vices
• permits the reader to value bespoke portfolios
• allows market data to be speciﬁed via a conﬁguration ﬁle
• contains a generic basket pricer for which the reader can specify the payoff
function
• can be freely downloaded for use by the reader.
The current book also contains increased coverage of stochastic processes, Ito
calculus and Monte Carlo simulation. These topics are supported by practical
applications and solved example problems.
In addition the Numerical Algorithms Group (NAG) have allowed readers
to enjoy an extended trial licence for the NAG C library and associated ﬁnan-
cial routines from the following url: www.nag.co.uk/market/elsevier_glevy. The
NAG C library may be called into C# and provides a large suite of mathematical
routines addressing many areas covered in this book (random numbers, statisti-
cal distributions, option pricing, correlation and covariance matrices etc.).
Computational Finance Using C and C# also includes supporting software
that may be downloaded for free. The software consists of executable ﬁles, con-
ﬁguration ﬁles and results ﬁles. With these ﬁles the user can run the example
portfolio application in Chapter 8 and change the portfolio composition and
the attributes of the deals.
Additional upgrade software is available for purchase with Computational
Finance Using C and C#. The software includes:
• Code to run all the C, C# and Excel examples in the book

xii
Computational Finance Using C and C#
• Complete C source code for the Analytics_Mathlib math library that is used
in the book
• C# source code, market data and portfolio ﬁles for the portfolio application
described in Chapter 8
All the C/C# software in the book can be compiled using either Visual Studio
.NET 2005, or the freely available Microsoft Visual C#/C++ Express Editions.
I would like to take this opportunity of thanking my wife Kathy for her sup-
port.
In addition I am grateful to Karen Maloney of Elsevier for her patience with
regard to the book’s delivery date, and Dr. Stephen Satchell of Trinity College
Cambridge for allowing me the opportunity to write a sequel.
George Levy
Benson, Oxfordshire, UK
2008

1 Overview of ﬁnancial derivatives
A ﬁnancial derivative is a contract between two counterparties (here referred
to as A and B) which derives its value from the state of underlying ﬁnancial
quantities. We can further divide derivatives into those that carry a future oblig-
ation and those that don’t. In the ﬁnancial world a derivative which gives the
owner the right but not the obligation to participate in a given ﬁnancial contract
is called an option. We will now illustrate this using both a Foreign Exchange
Forward contract and a Foreign Exchange option.
Foreign Exchange Forward—a contract with an obligation
In a Foreign Exchange Forward contract a certain amount of foreign currency
will be bought (or sold) at a future date using a prearranged foreign exchange
rate.
For instance, counterparty A may own a Foreign Exchange Forward which,
in one year’s time, contractually obliges A to purchase from B the sum of $200
for £100. At the end of one year several things may have happened.
(i) The value of the pound may have decreased with respect to the dollar
(ii) The value of the pound may have increased with respect to the dollar
(iii) Counterparty B may refuse to honor the contract—B may have gone bust,
etc.
(iv) Counterparty A may refuse to honor the contract—A may have gone bust,
etc.
We will now consider events (i)–(iv) from A’s perspective.
Firstly, if (i) occurs then A will be able to obtain $200 for less than the current
market rate, say £120. In this case the $200 can be bought for £100 and then
immediately sold for £120, giving a proﬁt of £20. However, this proﬁt can only
be realized if B honors the contract—that is, event (iii) does not happen.
Secondly, when (ii) occurs then A is obliged to purchase $200 for more than
the current market rate, say £90. In this case the $200 are bought for £100 but
could have been bought for only £90, giving a loss of £10.
The probability of events (iii) and (iv) occurring are related to the Credit Risk
associated with counterparty B. The value of the contract to A is not affected
by (iv), although A may be sued if both (ii) and (iv) occur. Counterparty A
should only be concerned with the possibility of events (i) and (iii) occurring—
that is, the probability that the contract is worth a positive amount in one year

2
Computational Finance Using C and C#
and the probability that B will honor the contract (which is one minus the
probability that event (iii) will happen).
From B’s point of view the important Credit Risk is when both (ii) and (iv)
occur—that is, when the contract has positive value but counterparty A defaults.
Foreign Exchange option—a contract without an obligation
A Foreign Exchange option is similar to the Foreign Exchange Forward, the
difference being that if event (ii) occurs then A is not obliged to buy dollars
at an unfavorable exchange rate. To have this ﬂexibility A needs to buy a For-
eign Exchange option from B, which here can be regarded as insurance against
unexpected exchange rate ﬂuctuations.
For instance, counterparty A may own a Foreign Exchange option which, in
one year, contractually allows A to purchase from B the sum of $200 for £100.
As before, at the end of one year the following may have happened:
(i) The value of the pound may have decreased with respect to the dollar
(ii) The value of the pound may have increased with respect to the dollar
(iii) Counterparty B may refuse to honor the contract—B may have gone bust,
etc.
(iv) Counterparty A may have gone bust, etc.
We will now consider events (i)–(iv) from A’s perspective.
Firstly, if (i) occurs then A will be able to obtain $200 for less than the current
market rate, say £120. In this case the $200 can be bought for £100 and then
immediately sold for £120, giving a proﬁt of £20. However, this proﬁt can only
be realized if B honors the contract—that is, event (iii) does not happen.
Secondly, when (ii) occurs then A will decide not to purchase $200 for more
than the current market rate; in this case the option is worthless.
We can thus see that A is still concerned with the Credit Risk when events
(i) and (iii) occur simultaneously.
The Credit Risk from counterparty B’s point of view is different. B has sold
to A a Foreign Exchange option, which matures in one year, and has already
received the money—the current fair price for the option. Counterparty B has
no Credit Risk associated with A. This is because if event (iv) occurs, and A
goes bust, it doesn’t matter to B since the money for the option has already
been received. On the other hand, if event (iii) occurs B may be sued by A but
B still has no Credit Risk associated with A.
This book considers the valuation of ﬁnancial derivatives that carry obliga-
tions and also ﬁnancial options.
Chapters 1–7 deal with both the theory of stochastic processes and the pric-
ing of ﬁnancial instruments. In Chapter 8 this information is then applied to a
C# portfolio valuer. The application is easy to use (the portfolios and current
market rates are deﬁned in text ﬁles) and can also be extended to include new
trade types.

Overview of ﬁnancial derivatives
3
The book has been written so that (as far as possible) ﬁnancial mathematics
results are derived from ﬁrst principles.
Finally, the appendices contain various information, which we hope the
reader will ﬁnd useful.

blank
left
intentionally
page
This

2 Introduction to stochastic
processes
2.1
Brownian motion
Brownian motion is named after the botanist Robert Brown who used a micro-
scope to study the fertilization mechanism of ﬂowering plants. He ﬁrst observed
the random motion of pollen particles (obtained from the American species
Clarkia pulchella) suspended in water, and wrote:
The fovilla or granules ﬁll the whole orbicular disk but do not extend to the
projecting angles. They are not sphaerical but oblong or nearly cylindrical,
and the particles have manifest motion. This motion is only visible to my
lens which magniﬁes 370 times. The motion is obscure yet certain . . .
Robert Brown, 12th June 1827; see Ramsbottom (1932)
It appears that Brown considered this motion no more than a curiosity (he be-
lieved that the particles were alive) and continued undistracted with his botan-
ical research. The full signiﬁcance of his observations only became apparent
about eighty years later when it was shown (Einstein, 1905) that the motion
is caused by the collisions that occur between the pollen grains and the water
molecules. In 1908 Perrin (1909) was ﬁnally able to conﬁrm Einstein’s predic-
tions experimentally. His work was made possible by the development of the
ultramicroscope by Richard Zsigmondy and Henry Siedentopf in 1903. He was
able to work out from his experimental results and Einstein’s formula the size
of the water molecule and a precise value for Avogadro’s number. His work
established the physical theory of Brownian motion and ended the skepticism
about the existence of atoms and molecules as actual physical entities. Many of
the fundamental properties of Brownian motion were discovered by Paul Levy
(Levy, 1939, 1948), and the ﬁrst mathematically rigorous treatment was pro-
vided by Norbert Wiener (Wiener, 1923, 1924). Karatzas and Shreve (1991) is
an excellent textbook on the theoretical properties of Brownian motion, while
Shreve, Chalasani, and Jha (1997) provides much useful information concerning
the use of Brownian processes within ﬁnance.
Brownian motion is also called a random walk, a Wiener process, or some-
times (more poetically) the drunkard’s walk. We will now present the three fun-
damental properties of Brownian motion.

6
Computational Finance Using C and C#
2.1.1
The properties of Brownian motion
In formal terms a process W = (Wt: t ⩾0) is (one-dimensional) Brownian
motion if:
(i) Wt is continuous, and W0 = 0,
(ii) Wt ∼N(0, t),
(iii) The increment dWt = Wt+dt −Wt is normally distributed as dWt ∼N(0, dt),
so E[dWt] = 0 and Var[dWt] = dt. The increment dWt is also independent
of the history of the process up to time t.
From (iii) we can further state that, since the increments dWt are independent
of past values Wt, a Brownian process is also a Markov process. In addition we
shall now show that a Brownian process is also a martingale process.
In a martingale process Pt, t ⩾0, the conditional expectation E[Pt+dt|Ft] =
Pt, where Ft is called the ﬁltration generated by the process and contains the
information learned by observing the process up to time t. Since for Brownian
motion we have
E[Wt+dt|Ft] = E

(Wt+dt −Wt) + Wt|Ft

= E[Wt+dt −Wt] + Wt
= E[dWt] + Wt = Wt
where we have used the fact that E[dWt] = 0. Since E[Wt+dt|Ft] = Wt the
Brownian motion W is a martingale process.
Using property (iii) we can also derive an expression for the covariance of
Brownian motion. The independent increment requirement means that for the
n times 0 ⩽t0 < t1 < t2 < · · · < tn < ∞the random variables Wt1 −Wt0, Wt2 −
Wt1, . . . , Wtn −Wtn−1 are independent. So
Cov[Wti −Wti−1, Wtj −Wtj−1] = 0,
i ̸= j
(2.1.1)
We will show that Cov[Ws, Wt] = s ∧t.
Proof. Using Wt0 = 0, and assuming t ⩾s we have
Cov[Ws −Wt0, Wt −Wt0] = Cov[Ws, Wt] = Cov

Ws, Ws + (Wt −Ws)

From Appendix C.3.2 we have
Cov

Ws, Ws + (Wt −Ws)

= Cov[Ws, Ws] + Cov[Ws, Wt −Ws]
= Var[Ws] + Cov[Ws, Wt −Ws]
Therefore
Cov[Ws, Wt] = s + Cov[Ws, Wt −Ws]
Now
Cov[Ws, Wt −Ws] = Cov[Ws −Wt0, Wt −Ws] = 0
where we have used Eq. (2.1.1) with n = 2, t1 = s and t2 = t.

Introduction to stochastic processes
7
We thus obtain
Cov[Ws, Wt] = s
So
Cov[Ws, Wt] = s ∧t
(2.1.2)
□
We will now consider the Brownian increments over the time interval dt in
more detail. Let us ﬁrst deﬁne the process X such that:
dXt = dWt
(2.1.3)
where dWt is a random variable drawn from a normal distribution with mean
zero and variance dt, which we denote as dWt ∼N(0, dt). Equation (2.1.3) can
also be written in the equivalent form:
dXt =
√
dt dZ
(2.1.4)
where dZ is a random variable drawn from a standard normal distribution (that
is a normal distribution with zero mean and unit variance).
Equations (2.1.3) and (2.1.4) give the incremental change in the value of X
over the time interval dt for standard Brownian motion.
We shall now generalize these equations slightly by introducing the extra
(volatility) parameter σ which controls the variance of the process. We now
have:
dXt = σdWt
(2.1.5)
where dWt ∼N(0, dt) and dXt ∼N(0, σ 2 dt). Equation (2.1.5) can also be
written in the equivalent form:
dXt = σ
√
dt dZ,
dZ ∼N(0, 1)
(2.1.6)
or equivalently
dXt =
√
dt dZ,
dZ ∼N

0, σ 2
(2.1.7)
We are now in a position to provide a mathematical description of the move-
ment of the pollen grains observed by Robert Brown in 1827. We will start
by assuming that the container of water is perfectly level. This will ensure that
there is no drift of the pollen grains in any particular direction. Let us denote
the position of a particular pollen grain at time t by Xt, and set the position
at t = 0, Xt0, to zero. The statistical distribution of the grain’s position, XT , at
some later time t = T , can be found as follows:
Let us divide the time T into n equal intervals dt = T /n. Since the position of
the particle changes by the amount dXi = σ
√
dt dZi over the ith time interval
dt, the ﬁnal position XT is given by:
XT =
n

i=1

σ
√
dt dZi

= σ
√
dt
n

i=1
dZi

8
Computational Finance Using C and C#
Since dZi ∼N(0, 1), by the Law of Large Numbers (see Appendix C.1), we have
that the expected value of position XT is:
E[XT ] = σ
√
dtE
 n

i=1
dZi
	
= 0
The variance of the position XT is:
Var[XT ] = Var

σ
√
dt
n

i=1
dZi
	
= σ 2 dt Var
 n

i=1
dZi
	
(2.1.8)
Since all the dZi variates are IID N(0, 1) we have Var[dZi]
=
1 and
Var[
n
i=1 Xi] = 
n
i=1 Var[Xi] (see Appendix C.3.1).
Thus
Var[XT ] = σ 2 dt
n

i=1
Var[dZi] = σ 2 dt
n

i=1
1
(2.1.9)
which gives:
Var[XT ] = σ 2n dt = T σ 2
(2.1.10)
So, at time T , the position of the pollen grain XT is distributed as XT
∼
N(0, T σ 2).
If the water container is not perfectly level then the pollen grains will ex-
hibit drift in a particular direction. We can modify Eq. (2.1.5) to take this into
account as follows:
dXt = μ dt + σ
√
dt dZi,
dZi ∼N(0, 1),
(2.1.11)
or equivalently
dXt = μ dt + σ dWt,
dWt ∼N(0, dt),
(2.1.12)
where we have included the constant drift μ. Proceeding in a similar manner to
that for the case of zero drift Brownian motion we have:
XT =
n

i=1

μ dt + σ
√
dt dZi

= μ
n

i=1
dt + σ
√
dt
n

i=1
dZi
= μT + σ
√
dt
n

i=1
dZi
which gives
E[XT ] = E

μT + σ
√
dt
n

i=1
dZi
	
E[XT ] = μT + σ
√
dtE
 n

i=1
dZi
	
= μT

Introduction to stochastic processes
9
The variance of the position XT is:
Var[XT ] = Var

μT + σ
√
dt
n

i=1
dZi
	
= Var

σ
√
dt
n

i=1
dZi
	
Here we have used the fact (see Appendix C.3.1) that Var[a + bX] = b2 Var[X],
where a = μT , and b = 1. From Eqs. (2.1.9) and (2.1.10) we have:
Var[XT ] = Var

σ
√
dt
n

i=1
dZi
	
= T σ 2
So, at time T , the position of the pollen grain XT is distributed as XT
∼
N(μT, T σ 2).
We have just shown that when we vary the drift of a Brownian motion, its
volatility remains unchanged. This is a very important property and (as we will
see later) is used extensively in the theory of derivative pricing.
2.2
A Brownian model of asset price movements
In the previous section we showed how Brownian motion can be used to de-
scribe the random motion of small particles suspended in a liquid. The ﬁrst
attempt at using Brownian motion to describe ﬁnancial asset price movements
was provided by Bachelier (1900). This, however, only had limited success be-
cause the signiﬁcance of a given absolute change in asset price depends on the
original asset price. For example, a £1 increase in the value of a share originally
worth £1.10 is much more signiﬁcant than a £1 increase in the value of a share
originally worth £100. It is for this reason that asset price movements are gen-
erally described in terms of relative or percentage changes. For example, if the
£1.10 share increases in value by 11 pence and the £100 share increases in value
by £10, then both of these price changes have the same signiﬁcance, and corre-
spond to a 10 percent increase in value. The idea of relative price changes in the
value of a share can be formalized by deﬁning a quantity called the return, Rt,
of a share at time t. The return Rt is deﬁned as follows:
Rt = St+dt −St
St
= dSt
St
(2.2.1)
where St+dt is the value of the share at time t + dt, St is the value of the share at
time t, and dSt is the change in value of the share over the time interval dt. The
percentage return R∗over the time interval dt is simply deﬁned as R∗= 100×Rt.
We are now in a position to construct a simple Brownian model of asset
price movements; further information on Brownian motion within ﬁnance can
be found in Shreve, Chalasani, and Jha (1997).
The asset return at time t is now given by:
Rt = dSt
St
= μ dt + σ dWt,
dWt ∼N(0, dt),
(2.2.2)

10
Computational Finance Using C and C#
or equivalently:
dSt = Stμ dt + Stσ dWt
(2.2.3)
The process in Eqs. (2.2.2) and (2.2.3) is termed geometric Brownian motion;
which we will abbreviate as GBM. This is because the relative (rather than ab-
solute) price changes follow Brownian motion.
2.3
Ito’s formula (or lemma)
In this section we will derive Ito’s formula; a more rigorous treatment can be
found in Karatzas and Shreve (1991).
Let us consider the stochastic process X:
dX = a dt + b dW = a dt + b
√
dt dZ,
dZ ∼N(0, 1), dW ∼N(0, dt)
(2.3.1)
where a and b are constants. We want to ﬁnd the process followed by a function
of the stochastic variable X, that is φ(X, t). This can be done by applying a
Taylor expansion, up to second order, in the two variables X and t as follows:
φ∗= φ + ∂φ
∂t dt + ∂φ
∂X dX + 1
2
∂2φ
∂X2 dX2 + 1
2
∂2φ
∂t2 dt2 +
∂φ
∂X ∂t dX dt
(2.3.2)
where φ∗is used to denote the value φ(X + dX, t + dt), and φ denotes the value
φ(X, t). We will now consider the magnitude of the terms dX2, dX dt, and dt2
as dt →0. First
dX2 =

a dt + b
√
dt dZ

a dt + b
√
dt dZ

= a2 dt2 + 2ab dt3/2 dZ + b2 dt dZ2
then
dX dt = a dt2 + b dt3/2 dZ
So as dt →0, and ignoring all terms in dt of order greater than 1, we have:
dX2 ∼b2 dt dZ2,
dt2 ∼0,
and
dX dt ∼0
Therefore Eq. (2.3.2) can be rewritten as:
dφ = ∂φ
∂t dt + ∂φ
∂X dX + 1
2
∂2φ
∂X2 E

dX2
(2.3.3)
where dφ = φ∗−φ, and we have replaced dX2 by its expected value E[dX2].
Now
E

dX2
= E

b2 dt dZ2
= b2 dtE

dZ2
= b2 dt

Introduction to stochastic processes
11
where we have used the fact that, since dZ ∼N(0, 1), the variance of dZ,
E[dZ2], is by deﬁnition equal to 1. Using these values in Eq. (2.3.3) and substi-
tuting for dX from Eq. (2.3.1), we obtain:
dφ = ∂φ
∂t dt + ∂φ
∂X (a dt + b dw) + b2
2
∂2φ
∂X2 dt
(2.3.4)
This gives Ito’s formula
dφ =
∂φ
∂t + a ∂φ
∂X + b2
2
∂2φ
∂X2

dt + ∂φ
∂X b dW
(2.3.5)
In particular if we consider the geometric Brownian process:
dS = μS dt + σS dW
where μ and σ are constants, then substituting X = S, a = μS, and b = σS into
Eq. (2.3.5) yields:
dφ =
∂φ
∂t + μS ∂φ
∂S + σ 2S2
2
∂2φ
∂S2

dt + ∂φ
∂S σS dW
(2.3.6)
Equation (2.3.6) describes the change in value of a function φ(S, t) over the time
interval dt, when the stochastic variable S follows GBM. This result has very
important applications in the pricing of ﬁnancial derivatives. Here the function
φ(S, t) is taken as the price of a ﬁnancial derivative, f (S, t), that depends on the
value of an underlying asset S, which is assumed to follow GBM. In Chapter 4
we will use Eq. (2.3.6) to derive the (Black–Scholes) partial differential equation
that is satisﬁed by the price of a ﬁnancial derivative.
We can also use Eq. (2.3.3) to derive the process followed by φ = log(St). We
have:
∂φ
∂St
= ∂log(St)
∂S
= 1
S ,
∂2φ
∂S2t
=
∂
∂St
∂log(St)
∂St

=
∂
∂St
 1
St

= −1
S2t
∂φ
∂t = ∂log(St)
∂t
= 0
So
d

log(St)

= ν dt + σ dWt
where ν = μ −σ 2
2
(2.3.7)
Integrating Eq. (2.3.7) yields
 T
t=t0
d

log(St)

=
 T
t=t0
ν dt +
 T
t=t0
σ dWt
so
log(ST ) −log(St0) = νT + σWT
(2.3.8)
where we have used t0 = 0 and Wt0 = 0.

12
Computational Finance Using C and C#
We obtain
log
ST
St0

∼N

νT, σ 2T

(2.3.9)
and so
log
ST
St0

= νT + σWT
(2.3.10)
The solution to the geometric Brownian motion (GBM) in Eq. (2.2.3) is
ST = St0 exp(νT + σWT ),
ν = μ −σ 2
2
(2.3.11)
The asset value at time t + dt can therefore be generated from its value at
time t by using
St+dt = St exp{ν dt + σ dWt}
We have shown that if the asset price follows geometric Brownian motion,
then the logarithm of the asset price follows standard Brownian motion. An-
other way of stating this is that, over the time interval dt, the change in the
logarithm of the asset price is a Gaussian distribution with mean (μ −σ 2/2) dt,
and variance σ 2 dt.
These results can easily be generalized to include time varying drift and
volatility. Now instead of Eq. (2.2.3) we have
dSt = Stμt dt + Stσt dWt
(2.3.12)
which results in
d

log(St)

= νt dt + σt dWt
(2.3.13)
so
 T
t=t0
d

log(St)

=
 T
t=t0
νt dt +
 T
t=t0
σt dWt
which results in the following solution for ST
ST = St0 exp
 T
t=t0
νt dt +
 T
t=t0
σt dWt

where νt = μt −σ 2
t
2
(2.3.14)
The results presented in Eqs. (2.3.11) and (2.3.14) are very important and
will be referred to in later sections of the book.
2.4
Girsanov’s theorem
This theorem states that for any stochastic process k(t) such that
 t
0 k(s)2 ds <
∞then the Radon–Nikodym derivative dQ
dP = ρ(t) is given by:
ρ(t) = exp
 t
0
k(s) dW P
s −1
2
 t
0
k(s)2 ds

(2.4.1)

Introduction to stochastic processes
13
where W P
t
is Brownian motion (possibly with drift) under probability measure
P, see Baxter and Rennie (1996). Under probability measure Q we have:
W Q
t
= W P
t −
 t
0
k(s) ds
(2.4.2)
where W Q
t
is also Brownian motion (possibly with drift).
We can also write
dW P = dW Q + k(t) dt
(2.4.3)
Girsanov’s theorem thus provides a mechanism for changing the drift of a
Brownian motion.
2.5
Ito’s lemma for multiasset geometric Brownian motion
We will now consider the n-dimensional stochastic process:
dXi = ai dt + bi
√
dt dZi = ai dt + bi dWi,
i = 1, . . . , n,
(2.5.1)
or in vector form:
dX = A dt +
√
dtB dZ = A dt + B dW
(2.5.2)
where A and B are n-element vectors respectively containing the constants,
ai, i = 1, . . . , n, and bi, i = 1, . . . , n. The stochastic vector dX contains the
n stochastic variables Xi, i = 1, . . . , n.
We will assume that the n element random vector dZ is drawn from a mul-
tivariate normal distribution with zero mean and covariance matrix 
C. That is,
we can write:
dZ ∼N(0, 
C)
Since 
Cii = Var[dZi] = 1, i = 1, . . . , n, the diagonal elements of 
C are all unity
and the matrix 
C is in fact a correlation matrix with off-diagonal elements given
by:

Cij = E[dZi dZj] = ρi,j,
i = 1, . . . , n, j = 1, . . . , n, i ̸= j,
where ρij is the correlation coefﬁcient between the ith and jth elements of the
vector dZ.
Similarly the n-element random vector dW is drawn from a multivariate nor-
mal distribution with zero mean and covariance matrix C. We can thus write:
dW ∼N(0, C)
The diagonal elements of C are Cii = Var[dWi] = dt, i = 1, . . . , n, and off-
diagonal elements are
Cij = E[dWi dWj] = ρi,j dt,
i = 1, . . . , n, j = 1, . . . , n, i ̸= j

14
Computational Finance Using C and C#
As in Section 2.3 we want to ﬁnd the process followed by a function of the
stochastic vector X, that is the process followed by φ(X, t). This can be done by
applying an n-dimensional Taylor expansion, up to second order, in the variables
X and t as follows:
φ∗= φ + ∂φ
∂t dt +
n

i=1
∂φ
∂Xi
dXi + 1
2E
 n

i=1
n

j=1
∂2φ
∂Xi ∂Xj
dXi dXj
	
+ 1
2
∂2φ
∂t2 dt2 +
n

i=1
∂φ
∂Xi ∂t dXi dt
(2.5.3)
where φ∗is used to denote the value φ(X + dX, t + dt), and φ denotes the value
φ(X, t). We will now consider the magnitude of the terms dXi dXj, dXi dt, and
dt2 as dt →0. Expanding the terms dXi dXj and dXi dt we have:
dXi dXj =

ai dt + bi
√
dt dZi

aj dt + bj
√
dt dZj

∴dXi dXj = aiaj dt2 + aibj dt3/2 dZj + ajbi dt3/2 dZi
(2.5.4)
+ bibj dt dZi dZj
dXi dt = ai dt2 + bi dt3/2 dZi
So as dt →0, and ignoring all terms in dt of order greater than 1, we have:
dXi dt ∼0
and
dXi dXj ∼bibj dt dZi dZj
Therefore Eq. (2.5.3) can be rewritten as
dφ = ∂φ
∂t dt +
n

i=1
∂φ
∂Xi
dXi + 1
2E
 n

i=1
n

j=1
∂2φ
∂Xi ∂Xj
dXi dXj
	
(2.5.5)
where dφ = φ∗−φ.
Now
E[dXi dXj] = E[bibj dt dZi dZj] = bibj dtE[dZi dZj] = bibjρij dt
where ρij is the correlation coefﬁcient between the ith and jth assets.
Using these values in Eq. (2.5.5), and substituting for dXi from Eq. (2.5.1),
we obtain:
dφ =
n

i=1
∂φ
∂Xi
(ai dt + bi dWi) + ∂φ
∂t dt + 1
2
n

i=1
n

j=1
bibjρij dt
∂2φ
∂Xi ∂Xj
(2.5.6)
This gives Ito’s n-dimensional formula:

Introduction to stochastic processes
15
dφ =

∂φ
∂t +
n

i=1
ai
∂φ
∂Xi
+ 1
2
n

i=1
n

j=1
bibjρij
∂2φ
∂Xi ∂Xj

dt
+
n

i=1
∂φ
∂Xi
bi dWi
(2.5.7)
In particular if we consider the geometric Brownian motion:
dSi = μiSi dt + σiSi dWi,
i = 1, . . . , n,
where μi is the constant drift of the ith asset and σi is the constant volatility of
the ith asset, then substituting Xi = Si, ai = μiSi, and bi = σiSi into Eq. (2.5.7)
yields:
dφ =

∂φ
∂t +
n

i=1
μiSi
∂φ
∂Si
+ 1
2
n

i=1
n

j=1
σiσjSiSjρij
∂2φ
∂Si ∂Sj

dt
+
n

i=1
∂φ
∂Si
σiSi dWi
(2.5.8)
2.6
Ito product and quotient rules in two dimensions
We will now derive expressions for the product and quotient of two stochastic
processes. In this case φ →φ(X1, X2), with
dX1 = a1 dt + b1 dW1
and
dX2 = a2 dt + b2 dW2
The following two-dimensional version of Ito’s lemma will be used:
dφ = ∂φ
∂X1
dX1 + ∂φ
∂X2
dX2 + 1
2E
 2

i=1
2

j=1
∂2φ
∂Xi ∂Xj
dXi dXj
	
(2.6.1)
where we have used the fact that ∂φ
∂t = 0.
2.6.1
Ito product rule
Here φ = φ(X1X2), and the partial derivatives are as follows:
∂φ
∂X1
= X2,
∂φ
∂X2
= X1
∂2φ
∂X2
1
= ∂2φ
∂X2
2
= 0,
∂2φ
∂X1 ∂X2
=
∂2φ
∂X2 ∂X1
= 1
Therefore using Eq. (2.6.1)
dφ = X2 dX1 + X1 dX2 + 2E[dX1 dX2]
2

16
Computational Finance Using C and C#
and the product rule is
d(X1X2) = X2 dX1 + X1 dX2 + E[dX1 dX2]
(2.6.2)
Brownian motion with one source of randomness
For the special case where X1 is Brownian motion and X2 has no random term
we have:
dX1 = X1μ1 dt + X1σ1 dW1
and
dX2 = X2μ2 dt
Now
E[dX1 dX2] = E

(X1μ1 dt + X1σ1 dW1)X2μ2 dt

= X1X2μ1μ2 dt2 + X1X2σ1μ2 dtX2μ2 dt E[dW1]
= 0
where we have ignored terms in dt with order higher than 1, and used
E[dW1] = 0.
Therefore Eq. (2.6.2) becomes:
d(X1X2) = X2 dX1 + X1 dX2
d(X1X2) = X2(X1μ1 dt + X1σ1 dW1) + X1X2μ2 dt
So we ﬁnally obtain:
d(X1X2) = (X1X2){μ1 + μ2} dt + (X1X2)σ1 dW1
(2.6.3)
2.6.2
Ito quotient rule
Here φ = φ(X1/X2) and the partial derivatives are as follows:
∂φ
∂X1
= 1
X2
,
∂φ
∂X2
= −X1
X2
2
,
∂2φ
∂X2
1
= 0,
∂2φ
∂X2
2
= 2X1
X3
2
,
∂2φ
∂X1 ∂X2
=
∂2φ
∂X2 ∂X1
= −1
X2
2
Therefore using Eq. (2.6.1)
dφ = dX1
X2
−X1
dX2
X2
2
+ 1
2E
2X1
X3
2
dX2
2 −2dX1 dX2
X2
2

We obtain the following expression for the quotient rule:
d
X1
X2

=
X1
X2
dX1
X1
−dX2
X2
+ E
dX2
X2
dX2
X2

−E
dX1
X1
dX2
X2

(2.6.4)

Introduction to stochastic processes
17
Brownian motion
Here we have:
dX1 = X1μ1 dt + X1σ1 dW1
and
dX2 = X2μ2 dt + X2σ2 dW2
or equivalently
dX1
X1
= μ1 dt + σ1 dW1
and
dX2
X2
= μ2 dt + σ2 dW2
Therefore
E
dX2
X2
dX2
X2

= E

(μ2 dt + σ2 dW2)(μ2 dt + σ2 dW2)

= E

μ2
2 dt2
+ E

σ 2
2 (dW2)2
+ 2E[σ2 dt dW2]
= μ2
2 dt2 + σ 2
2 dt + 2σ2 dt E[dW2]
which results in
E
dX2
X2
dX2
X2

= σ 2
2 dt
(2.6.5)
where we have ignored all terms in dt with order higher than 1, and used the
fact that E[dW2] = 0.
In a similar manner
E
dX1
X1
dX2
X2

= E

(μ1 dt + σ1 dW1)(μ2 dt + σ2 dW2)

= E

μ1μ2 dt2
+ E[σ1μ2 dt dW1]
+ E[σ2μ1 dt dW2] + E[σ1σ2 dW1 dW2]
= μ1μ2 dt2 + σ1μ2 dtE[dW1] + σ2μ1 dtE[dW2]
+ σ1σ2E[dW1 dW2]
which gives
E
dX1
X1
dX2
X2

= σ1σ2 dt ρ12
(2.6.6)
where we have proceeded as before but also used the fact that E[dW1 dW2] =
ρ12 dt.
Substituting these into Eq. (2.6.4) we have:
d
X1
X2

=
X1
X2
dX1
X1
−dX2
X2
+ σ 2
2 dt −σ1σ2ρ12 dt

=
X1
X2

μ1 dt + σ1 dt −μ2 dt −σ2 dt + σ 2
2 dt −σ1σ2ρ12 dt

=
X1
X2

μ1 dt + σ1 dW1 −μ2 dt −σ2 dW2 + σ 2
2 dt −σ1σ2ρ12 dt


18
Computational Finance Using C and C#
This yields:
d
X1
X2

=
X1
X2

μ1 −μ2 + σ 2
2 −σ1σ2ρ12

dt
+
X1
X2

{σ1 dW1 −σ2 dW2}
(2.6.7)
Brownian motion with one source of randomness
We have
dX1 = X1μ1 dt + X1σ1 dW1
and
dX2 = X2μ2 dt
As before
E
dX2
X2
dX2
X2

= E

μ2
2 dt2
= μ2
2 dt2 →0
E
dX1
X1
dX2
X2

= E

(μ1 dt + σ1 dW1)μ2 dt

= E

μ1μ2 dt2 + σ1μ2 dt dW1

= μ1μ2 dt2 + σ1μ2 dt E[dW1] →0
Therefore
d
X1
X2

=
X1
X2
dX1
X1
−dX2
X2

=
X1
X2

{μ1 dt + σ1 dW1 −μ2 dt}
So the ﬁnal expression is
d
X1
X2

=
X1
X2

{μ1 −μ2} dt +
X1
X2

σ1 dW1
(2.6.8)
2.7
Ito product in n dimensions
Using Eq. (2.5.7) we will now derive an expression for the product of n sto-
chastic processes. In this case φ →n
i=1 Xi, and the partial derivatives are as
follows:
∂φ
∂Xi
= φ dXi
Xi
for i = 1, . . . , n
∂2φ
∂X2
i
= 0
for i = 1, . . . , n

Introduction to stochastic processes
19
∂2φ
∂Xi ∂Xj
=
∂2φ
∂Xj ∂Xi
=
dXi
Xi
dXj
Xj

φ
for i ̸= j, i = 1, . . . , n, j = 1, . . . , n
∂φ
∂t = 0
So substituting into Eq. (2.5.7) we have
dφ = φ
n

i=1
dXi
Xi

+ φE
 n

i=1
n

j=1(i̸=j)
dXi
Xi
dXj
Xj
	
(2.7.1)
which in full is
d
 n

i=1
Xi

=
 n

i=1
Xi

n

i=1
dXi
Xi

+
 n

i=1
Xi

E
 n

i=1
n

j=1(i̸=j)
dXi
Xi
dXj
Xj
	
(2.7.2)
2.8
The Brownian bridge
Let a Brownian process have values Wt0 at time t0 and Wt1 at time t1. We want
to ﬁnd the conditional distribution of Wt, where t0 < t < t1. This distribution
will be denoted by P(Wt|{Wt0, Wt1}), to indicate that Wt is conditional on the
end values Wt0 and Wt1. We now write Wt0 and Wt1 as
Wt = Wt0 + √t −t0Xt,
Xt ∼N(0, 1),
(2.8.1)
Wt1 = Wt + √t1 −tYt,
Yt ∼N(0, 1),
(2.8.2)
where Xt and Yt are independent normal variates.
Combining Eqs. (2.8.1) and (2.8.2) we have
Wt1 = Wt0 + √t −t0Xt + √t1 −tYt
which can be re-expressed as
Wt1 −Wt0 = √t −t0Xt + √t1 −tYt
Using the Brownian motion property (iii) in Section 2.1
Wt1 −Wt0 = √t1 −t0Zt,
Zt ∼N(0, 1)
So
√t1 −t0Zt = √t −t0Xt + √t1 −tYt

20
Computational Finance Using C and C#
and
Y(Xt, Zt) =
√t1 −t0Zt −√t −t0Xt
√t1 −t
(2.8.3)
Now P(Wt|{Wt0, Wt1}) = P(Xt|Zt), the probability distribution of Xt condi-
tional on Zt. From Bayes law
P(Xt|Zt) = P(Xt)P(Y(Xt, Zt))
P(Zt)
=
1
√
2π
exp

−X2
t + Y 2
t −Z2
t
2

(2.8.4)
Since Xt, Yt and Zt are Gaussians we can write
P(Xt|Zt) =
1
√
2π
exp

−X2
t + Y 2
t −Z2
t
2

(2.8.5)
First let us compute Y 2
t .
Y 2
t =
√t1 −t0Zt −√t −t0Xt
√t1 −t
2
so
Y 2
t = (t1 −t0)Z2
t + (t −t0)X2
t −2√t1 −t0
√t −t0XtZt
t1 −t
(2.8.6)
Next we compute X2
t + Y 2
t −Z2
t as follows
X2
t + Y 2
t −Z2
t
= (t1 −t0)X2
t + (t −t0)Z2
t −2√t1 −t0
√t −t0XtZt
t1 −t
(2.8.7)
Dividing top and bottom of Eq. (2.8.7) by t1 −t0 we obtain:
X2
t + Y 2
t −Z2
t
= X2
t + ((t −t0)/(t1 −t0))Z2
t −2√t1 −t0
√t −t0/(t1 −t0)XtZt
(t1 −t)/(t1 −t0)
= X2
t + ((t −t0)/(t1 −t0))Z2
t −2√(t −t0)/(t1 −t0)XtZt
(t1 −t)/(t1 −t0)
which gives
X2
t + Y 2
t −Z2
t = (Xt −√(t −t0)/(t1 −t0)Zt)2
(t1 −t)/(t1 −t0)
(2.8.8)
where we have used

Xt −
 t −t0
t1 −t0
Zt
2
= X2
t + t −t0
t1 −t0
Z2
t −2
 t −t0
t1 −t0
XtZt
Substituting Eq. (2.8.8) into Eq. (2.8.5) yields
P(Xt|Zt) =
1
√
2π
exp

−(Xt −√(t −t0)/(t1 −t0)Zt)2
2(t1 −t)/(t1 −t0)


Introduction to stochastic processes
21
Therefore P(Xt|Zt) is a Gaussian distribution with:
E[Xt] =
 t −t0
t1 −t0
Zt
and
Var[Xt] = t1 −t
t1 −t0
Substituting for Zt we have
E[Xt] =
 t −t0
t1 −t0
Zt =
 t −t0
t1 −t0
Wt1 −Wt0
√t1 −t0
which gives:
E[Xt] =
√t −t0
t1 −t0
(Wt1 −Wt0)
(2.8.9)
The variate 
Xt = E[Xt] + √Var[Xt]Zt has the same distribution as P(Xt|Zt).
So we can substitute 
Xt for Xt in Eq. (2.8.1) to obtain:
Wt = Wt0 + √t −t0

E[Xt] +

Var[Xt]Zt

which gives:
Wt = Wt0 + √t −t0
√t −t0
t1 −t0
(Wt1 −Wt0) +
 t1 −t
t1 −t0
Zt

and simplifying we obtain:
Wt = Wt0
t1 −t0
t1 −t0
+ t −t0
t1 −t0
(Wt1 −Wt0) +

(t1 −t)(t −t0)
t1 −t0
Zt
(2.8.10)
Variates, Wt, from the distribution of P(Wt|{Wt0, Wt1}) can therefore be gener-
ated by using
Wt = Wt0
t1 −t
t1 −t0
+ Wt1
t −t0
t1 −t0
+

(t1 −t)(t −t0)
t1 −t0
Zt
(2.8.11)
An alternative derivation of the Brownian bridge is given in Appendix G.
2.9
Time-transformed Brownian motion
Let us consider the Brownian motion:
dWt = σ
√
dt dZt
(2.9.1)
and also the scaled and time-transformed Brownian motion
YW,t = atWft
(2.9.2)
where the scale factor, at, is a real function and the time transformation, ft, is a
continuous increasing function satisfying ft ⩾0; see Cox and Miller (1965).

22
Computational Finance Using C and C#
Using Ito’s lemma,
dYW,t = ∂Yt
∂t dt + ∂Yt
∂Wt
dWt
(2.9.3)
where we have used the fact that ∂2Yt
∂W 2t = 0.
From Eq. (2.9.3)
dYW,t =
∂at
∂t

Wft dt + at dWft
(2.9.4)
Now
dWft =

dft dZt =

∂ft
∂t dt dZt
(2.9.5)
so we can write:
dYW,t = a′
tWft dt + at

f ′t dt dZt
(2.9.6)
where
a′
t = ∂at
∂t
and
f ′
t = ∂ft
∂t
2.9.1
Scaled Brownian motion
We will prove that 
Wt deﬁned by

Wt = 1
c Wc2t,
c > 0,
is Brownian motion.
Let us consider the process
Yt = Wc2t
From Eq. (2.9.2) we have at = 1, ft = c2t, a′
t = 0 and f ′
t = c2. Substituting
these values into Eq. (2.9.6), yields
dYt =

c2dt dZt
which gives
dYt = c
√
dt dZt = c dWt
Therefore 
Wt = dYt/c is Brownian motion.
2.9.2
The Ornstein–Uhlenbeck process
We will now show that the Ornstein–Uhlenbeck process (see Section 2.10) can
be represented as follows:
YW,t = exp(−αt)Wψt
where ψt = σ 2 exp(2αt)
2α
, α > 0
(2.9.7)

Introduction to stochastic processes
23
Proof. From Eqs. (2.9.2) and (2.9.7) we have:
ft = σ 2 exp(σ 2 exp(2αt))
2α
and
at = exp(−2αt)
(2.9.8)
Therefore
a′
t
at
= −−α exp(−αt)
exp(−αt)
= −α
(2.9.9)
and
f ′
t = σ 2
2α 2α exp(2αt) = σ 2 exp(2αt)
(2.9.10)
So

f ′t dt =

σ 2 exp(2αt) = σ exp(αt)
√
dt
(2.9.11)
Thus
dYW,t = −αYW,t dt + exp(−αt)σ exp(αt)
√
dt dZ
(2.9.12)
which means that
dYW,t = −αYW,t dt + σ dWt
(2.9.13)
From Eq. (2.9.13) it can be seen that conditional mean and variance are
E[dYW,t|Ft] = αYW,t dt
(2.9.14)
Var[dYW,t|Ft] = σ 2 dt
(2.9.15)
□
Unconditional mean
The unconditional mean is
E[YW,t] = E

exp(−αt)W
σ 2 exp(2αt)
2α

where α > 0 and t →∞
(2.9.16)
So
E[YW,t] = 0
(2.9.17)
Unconditional variance and covariance
Let
YW,t = exp(−αt)Wψt
where ψt =
σ 2 exp(2αt)
2α

(2.9.18)

24
Computational Finance Using C and C#
and
YW,s = exp(−αs)Wψs
where ψs =
σ 2 exp(2αs)
2α

(2.9.19)
The covariance is:
Cov[YW,s, YW,t] = E[YW,tYW,s] −E[YW,t]E[YW,s]
= E[YW,tYW,s]
(2.9.20)
since E[YW,s] = E[YW,t] = 0.
Shortening the notation of YW,t to Yt we obtain
Cov[Ys, Yt] = E

exp(−αt)Wψt exp(−αt)Wψs

= exp

−α(t + s)

E

{Wψt Wψs}

From Eq. (2.1.2)
E[Ws, Wt] = s ∧t
(2.9.21)
Therefore, if s ⩽t
E[Wψt Wψs] = Wψs
(2.9.22)
and
Cov[Ys, Yt] = exp(−α(t + s))σ 2 exp(2αs)
2α
= σ 2
2α exp

−α(t −s)

(2.9.23)
The unconditional variance (obtained by setting s = t) is
Var[Yt] = σ 2
2α
(2.9.24)
2.10
Ornstein–Uhlenbeck process
The Ornstein–Uhlenbeck process is often used to model interest rates because
of its mean reverting property. It is deﬁned by the equation
dXt = −αXt dt + σ dWt
(2.10.1)
Using the integrating factor exp(αt) we have:
exp(αt) dXt = −αXt exp(αt) dt + σ exp(αt) dWt
so
exp(αt) dXt + αXt exp(αt) dt = σ exp(αt) dWt
(2.10.2)
Using the Ito product rule we have:
d

Xt exp(αt)

= exp(αt) dXt + αXt exp(αt) dt
(2.10.3)

Introduction to stochastic processes
25
So from Eqs. (2.10.2) and (2.10.3) we obtain
d

Xt exp(αt)

= σ exp(αt) dWt
(2.10.4)
Integrating Eq. (2.10.4) gives
 s=t
s=0
d

Xs exp(αs)

= σ
 s=t
s=0
exp(αs) dWs
which yields
Xt exp(αt) −Xt0 = σ
 s=t
s=0
exp(αs) dWs
and thus the solution of Eq. (2.10.1) is
Xt = Xt0 exp(−αt) + σ exp(−αt)
 s=t
s=0
exp(αs) dWs
(2.10.5)
We will now derive expressions for both the unconditional mean and the un-
conditional variance of Xt.
The mean
Taking expectations of both sides of Eq. (2.10.5) yields
E[Xt] = E

Xt0 exp(−αt)

+ E

σ exp(−αt)
 s=t
s=0
exp(αs) dWs

(2.10.6)
since
E

σ exp(−αt)
 s=t
s=0
exp(αs) dWs

= σ exp(−αt)E
 s=t
s=0
exp(αs) dWs

= 0
the unconditional mean is
E[Xt] = Xt0 exp(−αt)
(2.10.7)
The variance
To derive the expression for unconditional variance requires a bit more effort.
We have
Var[Xt] = E

Xt −E[Xt]
2
(2.10.8)
= E

Xt −Xt0 exp(−αt)
2
However, from Eq. (2.10.5)
Xt −Xt0 exp(−αt) = σ exp(−αt)
 s=t
s=0
exp(αs) dWs

26
Computational Finance Using C and C#
So substituting the above expression into Eq. (2.10.8)
Var[Xt] = E

exp(−αt)σ
 s=t
s=0
exp(αs) dWs
2
(2.10.9)
Var[Xt] = σ 2 exp(−2αt)E
 s=t
s=0
exp(αs) dWs
2
(2.10.10)
Using Ito’s isometry (see Section 2.12.2)
E
 s=t
s=0
exp(αs) dWs
2
= E
 s=t
s=0

exp(αs)
2 ds

Then using Fubini’s theorem (see Section 2.12.1)
E
 s=t
s=0

exp(αs)
2 ds

=
 s=t
s=0
E

exp(αs)
2
ds
=
 s=t
s=0
exp(2αs) ds
= exp(2αs)
2α
s=t
s=0
= exp(2αt) −1
2α
Substituting the above result into Eq. (2.10.10)
Var[Xt] = σ 2 exp(−2αt)
exp(2αt) −1
2α

which yields the following expression for the variance
Var[Xt] = σ 2
1 −exp(−2αt)
2α

(2.10.11)
The expressions for the mean and variance derived in Eqs. (2.10.7) and
(2.10.11) allow us to write the distribution of Xt as
Xt ∼N

Xt0 exp(−αt), σ 2
1 −exp(−2αt)
2α

(2.10.12)
which, if Xt0 = 0, reduces to
Xt ∼N

0, σ 2
1 −exp(−2αt)
2α

(2.10.13)
The transition density from Xt0 to Xt is:
P(Xt|Xt0) =

K
2π(1 −γ 2) exp

−K(Xt −Xt0 exp(−α(t −t0)))2
1 −γ 2

(2.10.14)
where K = 2α/σ 2 and γ = exp(−α(t −t0)).

Introduction to stochastic processes
27
Ornstein–Uhlenbeck stochastic paths can thus be simulated using
Xt+dt = Xt exp(−α dt) + σ

1 −exp(−2α dt)
2α
dZ
(2.10.15)
From Eq. (2.10.14) we can write
E[Xt+dt|Xt] = Xt exp(−α dt)
Var[Xt+dt|Xt] = σ 2
1 −exp(−2α dt)
2α

We will now show that in the limit dt →0, Eq. (2.10.15) reduces to the
Ornstein–Uhlenbeck process given in Eq. (2.10.1).
For small dt we can take a ﬁrst-order expansion of the exponentials in
Eq. (2.10.15) to obtain
Xt+dt = Xt

(1 −α dt)

+ σ

(1 −(1 −2α dt))
2α
dZ
so
Xt+dt = Xt −Xtα dt + σ

2α dt
2α
dZ
Therefore
Xt+dt −Xt = −αXt dt + σ
√
dt dZ
which is
dXt = −αXt dt + σ dWt
2.11
The Ornstein–Uhlenbeck bridge
Let an Ornstein–Uhlenbeck process have value Xt0 at time t0 and Xt1 at time t1.
We are interested in the distribution of Xt at an intermediate point, that is
P(Xt|{Xt0, Xt1}), where t0 < t < t1.
We will show that Xt is a Gaussian with conditional mean
μt = Xt0 exp

−α(t −t0)
1 −exp(−2α(t1 −t))
1 −γ 2

+ Xt1 exp

−α(t1 −t)
1 −exp(−2α(t −t0))
1 −γ 2

(2.11.1)
and conditional variance
Vt = (1 −exp(−2α(t −t0)))(1 −exp(−2α(t1 −t)))
2α(1 −exp(−2α(t1 −t0)))
(2.11.2)
where γ = exp(−α(t1 −t0)).

28
Computational Finance Using C and C#
Proof. The standard Ornstein–Uhlenbeck process (σ = 1) is deﬁned by the
process:
dXt = −αXt dt +
√
dt dZt
(2.11.3)
From Section 2.10 we have that
Xt = Xt0 exp

−α(t −t0)

+
1 −exp(−2α(t −t0))
2α

dZt
(2.11.4)
and that the transition density from Xt0 to Xt is
P(Xt|Xt0) =
√
2α

2π(1 −exp(−2α(t −t0)))
× exp

−α(Xt −Xt0 exp(−α(t −t0)))2
1 −exp(−2α(t −t0))

(2.11.5)
The joint density of Xt and Xt1 given Xt0 is:
P

{Xt, Xt1}|Xt0

= P(Xt1|Xt)P(Xt|Xt0)
(2.11.6)
We thus have:
P

{Xt, Xt1}|Xt0

= κ exp

−α(Xt −Xt0 exp(−α(t −t0)))2
(1 −exp(−2α(t −t0)))

× exp

−α(Xt1 −Xt exp(−α(t1 −t)))2
1 −exp(−2α(t1 −t))

where
κ = 1
2π
2α

(1 −exp(−2α(t −t0)))(1 −exp(−2α(t1 −t)))
The distribution of Xt given Xt0 and Xt1, P(Xt|Xt0, Xt1) is:
P

Xt|{Xt0, Xt1}

= P({Xt, Xt1}|Xt0)
P(Xt1|Xt0)
(2.11.7)
where
P(Xt1|Xt0) =
√
2α

2π(1 −exp(−2α(t1 −t0)))
× exp

−α(Xt1 −Xt0 exp(−α(t1 −t0)))2
1 −exp(−2α(t1 −t0))

(2.11.8)
After some algebra we can re-express Eq. (2.11.7) as
P

Xt|{Xt0, Xt1}

=
 α
πφt
exp{A}
(2.11.9)

Introduction to stochastic processes
29
where
A = −α
φ (B1 + B2 −B3)
B1 =

X2
t + X2
t0 exp

−2α(t −t0)

−2XtXt0 exp

−α(t −t0)

×
1 −exp(−2α(t1 −t))
1 −γ 2

(2.11.10)
B2 =

X2
t1 + X2
t exp

−2α(t1 −t)

−2XtXt1 exp

−α(t1 −t)

×
1 −exp(−2α(t −t0))
1 −γ 2

(2.11.11)
B3 =

X2
t1 + X2
t0 exp

−2α(t1 −t0)

−2Xt1Xt0 exp

−α(t1 −t0)

×

1 −exp

−2α(t −t0)
1 −exp(−2α(t1 −t))
(1 −γ 2)2

(2.11.12)
φt = (1 −exp(−2α(t −t0)))(1 −exp(−2α(t1 −t)))
1 −exp(−2α(t1 −t0))
and
γ = exp

−α(t1 −t0)

Let us now assume that P(Xt|{Xt0, Xt1}) is a normal distribution with condi-
tional mean μt and conditional variance Vt. We thus have:
P

Xt|{Xt0, Xt1}

=
1
√2πVt
exp

−(Xt −μt)2
2Vt

(2.11.13)
Equating Eqs. (2.11.7) and (2.11.13)
−1
2Vt

(Xt −μt)2
= −1
2Vt

X2
t −μ2
t −2Xtμt

= −α
φ (B1 + B2 −B3)
(2.11.14)
The conditional variance Vt can be obtained by noting that:
1
2Vt
= α
φt
and hence:
Vt = φ
2α
(2.11.15)
so substituting for φ in Eq. (2.11.15) we obtain the following expression for the
conditional variance:
Vt = (1 −exp(−2α(t −t0)))(1 −exp(−2α(t1 −t)))
1 −exp(−2α(t1 −t0))
= φt
2α

30
Computational Finance Using C and C#
The conditional mean can be obtained by noting that Xt0 and Xt1 are constants
and the coefﬁcients of Xt and X2
t in Eq. (2.11.14) must be the same. Comparing
coefﬁcients of Xt we thus have:
−2μt = −2Xt0 exp

−α(t −t0)
1 −exp(−2α(t1 −t))
1 −γ 2

−2Xt1 exp

−α(t1 −t)
1 −exp(−2α(t −t0))
1 −γ 2

So the conditional mean μt is:
μt = Xt0 exp

−α(t −t0)
1 −exp(−2α(t1 −t))
1 −γ 2

+ Xt1 exp

−α(t1 −t)
1 −exp(−2α(t −t0))
1 −γ 2

This completes the proof.
□
Relation to the Brownian bridge
We will now prove that in the limit (t1 −t0) →0 the Brownian bridge result is
obtained.
For the conditional mean, we have:
μ = Xt0 exp

−α(t −t0)
1 −exp(−2α(t1 −t))
1 −γ 2

+ Xt1 exp

−α(t1 −t)
1 −exp(−2α(t −t0))
1 −γ 2

where:
γ = exp

−α(t1 −t0)

which is:
μ = Xt0
exp(−α(t −t0)) −exp(−2α(t1 −t))
1 −exp(−2α(t1 −t0) −α(t −t0))

+ Xt1
exp(−α(t1 −t)) −exp(−2α(t −t0) −α(t1 −t))
1 −exp(−2α(t1 −t0))

For small t1 −t0 both t1 −t and t −t0 are small, so:
μ →Xt0
1 −α(t −t0) −{1 −2α(t1 −t) −α(t −t0)}
1 −{1 −2α(t1 −t0)}

+ Xt1
1 −α(t1 −t) −{1 −2α(t −t0) −α(t1 −t)}
1 −{1 −2α(t1 −t0)}

which yields the Brownian bridge result for the conditional mean:
μ →Xt0
t1 −t0
t1 −t0
+ Xt1
t −t0
t1 −t0

Introduction to stochastic processes
31
For the conditional variance:
Vt = (1 −exp(−2α(t −t0)))(1 −exp(−2α(t1 −t)))
2α(1 −exp(−2α(t1 −t0)))
For small t1 −t0 both t1 −t and t −t0 are small, so we can write:
V →(1 −{1 −2α(t −t0)})(1 −{1 −2α(t1 −t)})
2α(1 −{1 −2α(t1 −t0)})
which yields the Brownian bridge result for the conditional variance:
Vt →(t −t0)(t1 −t)
t1 −t0
2.12
Other useful results
2.12.1
Fubini’s theorem
Fubini’s theorem states that (for well-behaved functions) the value of a multidi-
mensional integral is independent of the order in which the integral is evaluated.
For example, the two-dimensional integral of the function f (X, Y) can be
evaluated as:
 b
X=a
 d
Y=c
f (X, Y) dX dY =
 d
Y=c
 b
X=a
f (X, Y) dX

dY
=
 b
X=a
 d
Y=c
f (X, Y) dY

dX
We will mainly use this result in the form:
E
 t
s=0
f (W, s) ds

=
 t
s=0
E

f (W, s)

ds
(2.12.1)
Since
E

f (W, s)

=
 ∞
−∞
P(W, s)f (W, s) dW
where P(W, s) is the probability density function of f (W, s), we can thus write
Eq. (2.12.1) in full as:
 ∞
W=−∞
 t
s=0
P(W, s)f (W, s) ds

dW
=
 t
s=0
 ∞
W=−∞
P(W, s)f (W, s) dW

ds

32
Computational Finance Using C and C#
2.12.2
Ito’s isometry
The expected value of the integral of the well-behaved function f (Wt, t) satisﬁes:
E
 tb
s=ta
f (Ws, s) dWs
2
= E
 tb
s=ta

f (Ws, s)
2 ds

(2.12.2)
Proof. We ﬁrst use the following approximation:
 s=tb
s=ta
f (W, s) dWs =
n−1

i=0
f (Wti, ti){Wti+1 −Wti}
where a < t0 < t1 < · · · < tn < tb and ti+1 −ti = dt. Thus the integral on the
left-hand side of Eq. (2.12.2) is:
 tb
s=ta
f (Ws, s) dWs
2
=
n−1

i=0
n−1

j=0
f (Wti, ti)f (Wtj , tj){Wti+1 −Wti}{Wtj+1 −Wtj }
(2.12.3)
Taking expectations of Eq. (2.12.3) we obtain:
E
 tb
s=ta
f (Ws, s) dWs
2
= E
n−1

i=0
n−1

j=0
f (Wti, ti)f (Wtj , tj){Wti+1 −Wti}{Wtj+1 −Wtj }
	
(2.12.4)
which means that:
E
 tb
s=ta
f (Ws, s) dWs
2
=
n−1

i=0
n−1

j=0
f (Wti, ti)f (Wtj , tj)E

{Wti+1 −Wti}{Wtj+1 −Wtj }

(2.12.5)
However from the Brownian motion property (iii) in Section 2.1 we have:
E

{Wti+1 −Wti}{Wtj+1 −Wtj }

= 0
when i ̸= j and dt when i = j
Therefore Eq. (2.12.5) can be rewritten as:
E
 tb
s=ta
f (Ws, s) dWs
2
=
n−1

i=0

f (Wti, ti)
2 dt
which means:
E
 tb
s=ta
f (Ws, s) dWs
2
= E
 tb
s=ta

f (Ws, s)
2 ds

□

Introduction to stochastic processes
33
2.12.3
Expectation of a stochastic integral
If f (t) is a deterministic function of time then
E
 s=b
s=a
f (s) dWs

= 0
(2.12.6)
Proof. We ﬁrst express the integral (2.12.6) by the following summation:
 s=tb
s=ta
f (s) dWs =
n−1

i=0
f (ti){Wti+1 −Wti},
where a < t0 < t1 < · · · < tn < tb
Taking expectations of the above equation yields:
E
 s=b
s=a
f (s) dWs

= E
n−1

i=0
f (ti){Wti+1 −Wti}
	
=
n−1

i=0
f (ti)E[Wti+1 −Wti]
= 0
where we have used E[Wti+1 −Wti] = 0, which is Brownian motion property (iii)
in Section 2.1.
□
2.13
Selected problems
In this section we provide various problems that test the reader’s understanding
of stochastic calculus. The answers are given in the appendix at the end of the
book.
Problem 1 (Problem 4.5, Øksendal (2003)). Let βk
t = E[W k
t ], k = 0, 1, 2, . . . ,
t ⩾0, where Wt0 = 0.
(a) Show using Ito’s formula for k = 2, 3, 4, . . . , that:
βk
t = 1
2(k −1)
 t
s=0
βk−2
s
ds
(b) Deduce that E[W 4
t ] = 3t2
(c) What is E[W 6
t ]?
Problem 2 (Problem 5.4(ii), Øksendal (2003)). Solve the stochastic differential
equation:
dXt = Xt dt + dWt

34
Computational Finance Using C and C#
Problem 3 (Problem 5.4(iii), Øksendal (2003)). Solve the stochastic differen-
tial equation:
dXt = −Xt dt + exp(−t) dWt
Problem 4 (Problem 4.2, Øksendal (2003)). Use Ito’s formula to prove that

s=0
W 2
s dWs = 1
3W 3
t −
 t
s=0
Ws ds
where Wt0 = 0.
Problem 5 (Problem 5.6, Øksendal (2003)). Solve:
dYt = r dt + αYt dWt
where r and α are real constants. Use the integrating factor Ft = exp(−αWt +
(α2/2)t).
Problem 6 (Problem 5.7, Øksendal (2003)). The mean reverting Ornstein–
Uhlenbeck process is the solution Xt of the stochastic differential equation:
dXt = (m −Xt) dt + σ dWt
where m and σ are constants.
(a) Solve this equation
(b) Find E[Xt] and Var[Xt] = E[{Xt −E[Xt]}2].
Problem 7. Consider the equation dSt = μtSt dt +σtSt dWt where the value of
St at time t = 0 is denoted by S0.
(a) Show that the mean is:
E

log(St)

= log(S0) +
 t
τ=0

μτ −σ 2
τ
2

dτ
(b) Show that the variance is:
Var

log(St)

=
 t
τ=0
σ 2
τ dτ
Problem 8. Prove that if φ = exp(tWt) then
dφ = φ

Wt + t2
2

dt + tφ dWt
Problem 9 (Problem 4.4, Øksendal (2003)). Deﬁne:
Zt = exp
 t
s=0
θs dWs −1
2
 t
s=0
θ2
s ds

Use Ito’s formula to prove that
dZt = Ztθt dWt

Introduction to stochastic processes
35
Problem 10. Let St = S0 exp(μt + σWt) where μ and σ are constants.
(a) Show by Ito’s lemma that:
dSt =

μ + σ 2
2

St dt + σSt dWt
(b) Show that:
E[St] −E[S0] =

μ + σ 2
2
  t
τ=0
E

S(τ)

dτ
(c) Show that:
E[St] = S0 exp

μt + σ 2
2 t

Problem 11 (Problem 4.3, Øksendal (2003)). Let Xt, Yt be stochastic processes.
Prove that:
d(XtYt) = Xt dYt + Yt dXt + E[dXt dYt]
Deduce the following general integration by parts formula:
 t
s=0
Xs dYs = XtYt −Xt0Yt0 −
 t
s=0
Ys dXs −
 t
s=0
E[dXs dYs]

blank
left
intentionally
page
This

3 Generation of random variates
3.1
Introduction
Monte Carlo simulation and random number generation are techniques that
are widely used in ﬁnancial engineering as a means of assessing the level of
exposure to risk. Typical applications include the pricing of ﬁnancial derivatives
and scenario generation in portfolio management. In fact many of the ﬁnancial
applications that use Monte Carlo simulation involve the evaluation of various
stochastic integrals which are related to the probabilities of particular events
occurring.
In many cases, however, the assumptions of constant volatility and a lognor-
mal distribution for ST are quite restrictive. Real ﬁnancial applications may re-
quire a variety of extensions to the standard Black–Scholes model. Common re-
quirements are for: nonlognormal distributions, time-varying volatilities, caps,
ﬂoors, barriers, etc. In these circumstances, it is often the case that there is no
closed form solution to the problem. Monte Carlo simulation can then provide
a very useful means of evaluating the required integrals.
When we evaluate the integral of a function, f (x), in the s-dimensional unit
cube, I S, by the Monte Carlo method we are in fact calculating the average of
the function at a set of randomly sampled points. This means that each point
adds linearly to the accumulated sum that will become the integral and also
linearly to the accumulated sum of squares that will become the variance of the
integral.
When there are N sample points, the integral is:
ν = 1
N
N

i=1
f

xi
where ν is used to denote the approximation to the integral and x1, x2, . . . , xN
are the N, s-dimensional, sample points. If a pseudo-random number generator
is used the points xi will be (should be) independently and identically distrib-
uted. From standard statistical results we can then estimate the expected error
of the integral as follows:
If we set χi = f (xi) then since xi is independently and identically distributed
χi is also independently and identically distributed. The mean of χi is ν and we

38
Computational Finance Using C and C#
will denote the variance as Var[χi] = Δ2. It is a well-known statistical prop-
erty that the variance of ν is given by Var[ν] = N−1Δ2 (see Appendix E.1 for
further details). We can therefore conclude that the estimated integral ν has a
standard error of N−1/2Δ. This means that the estimated error of the integral
will decrease at the rate of N−1/2.
It is possible to achieve faster convergence than this if the sample points are
chosen to lie on a Cartesian grid. If we sample each grid point exactly once, then
the Monte Carlo method effectively becomes a deterministic quadrature scheme,
whose fractional error decreases at the rate of N−1 or faster. The trouble with
the grid approach is that it is necessary to decide in advance how ﬁne it should
be, and all the grid points need to be used. It is therefore not possible to sample
until some convergence criterion has been met.
Quasi-random number sequences seek to bridge the gap between the ﬂexibil-
ity of pseudo-random number generators and the advantages of a regular grid.
They are designed to have a high level of uniformity in multidimensional space,
but unlike pseudo-random numbers they are not statistically independent.
3.2
Pseudo-random and quasi-random sequences
Here we consider the generation of multidimensional pseudo-random and quasi-
random sequences to approximate the multidimensional uniform distribution
over the interval [0, 1], that is the distribution U(0, 1).
Quasi-random numbers are also called low-discrepancy sequences. The dis-
crepancy of a sequence is a measure of its uniformity and is deﬁned as follows:
Given a set of points x1, x2, . . . , xN ∈I S and a subset G ⊂I S, deﬁne
the counting function SN(G) as the number of points xi
∈G. For each
x = (x1, x2, . . . , xs) ∈I S, let Gx be the rectangular s-dimensional region
Gx = [0, x1) × [0, x2) × · · · × [0, xs), with volume x1, x2, . . . , xn. Then the dis-
crepancy of the points x1, x2, . . . , xN is given by:
D∗
N

x1, x2, . . . , xN
= sup
x∈I S
  SN(Gx) −Nx1x2, . . . , xs
  
The discrepancy is therefore computed by comparing the actual number of sam-
ple points in a given volume of multidimensional space with the number of
sample points that should be there assuming a uniform distribution.
It can be shown that the discrepancy of the ﬁrst terms of quasi-random se-
quence has the form:
D∗
N

x1, x2, . . . , xN
⩽CS(log N)S + O

(log N)S−1
for all N ⩾2.
The principal aim in the construction of low-discrepancy sequences is thus to
ﬁnd sequences in which the constant is as small as possible. Various sequences
have been constructed to achieve this goal. Here we consider the following
quasi-random sequences: Niederreiter, Sobol, and Faure.

Generation of random variates
39
The results of using various random number generators are shown below.
Figures 3.1–3.3 illustrate the visual uniformity of the sequences. They were cre-
Figure 3.1 The scatter diagram formed by one thousand points from a 16-dimensional
U(0, 1) pseudo-random sequence. For each point the 4th-dimensional component is plot-
ted against the 5th-dimensional component.
Figure 3.2 The scatter diagram formed by one thousand points from a 16-dimensional
U(0, 1) Sobol sequence. For each point the 4th-dimensional component is plotted against
the 5th-dimensional component.

40
Computational Finance Using C and C#
Figure 3.3 The scatter diagram formed by one thousand points from a 16-dimensional
U(0, 1) Niederreiter sequence. For each point the 4th-dimensional component is plotted
against the 5th-dimensional component.
ated by generating one thousand 16-dimensional U(0, 1) sample points, and
then plotting the 4th-dimensional component of each point against its 5th-
dimensional component.
In Fig. 3.1, it can be seen that the pseudo-random sequence exhibits clustering
of points, and there are regions with no points at all.
Visual inspection of Figs. 3.2 and 3.3 shows that both the Sobol and Nieder-
reiter quasi-random sequences appear to cover the area more uniformly.
It is interesting to note that the Sobol sequence appears to be a structured
lattice which still has some gaps. The Niederreiter sequence, on the other hand,
appears to be more irregular and covers the area better. However, we cannot
automatically conclude from this that the Niederreiter sequence is the best. This
is because we have not considered all the other possible pairs of dimensions.
Perhaps the easiest way to evaluate the random number sequences is to use
them to calculate an integral.
In Fig. 3.4 Monte Carlo results are presented for the calculation of the
6-dimensional integral:
I =
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
6

i=1
cos(ixi) dx1 dx2 dx3 dx4 dx5 dx6
The exact value of this integral is:
I =
6

i=1
sin(i)
which for i = 6, gives I = −0.0219.

Generation of random variates
41
Figure 3.4 Monte Carlo integration using random numbers.
It can be seen that the pseudo-random sequence gives the worst performance.
But as the number of points increases, its approximation to the integral im-
proves. Of the quasi-random sequences, it can be seen that the Faure sequence
has the worst performance, while both the Sobol and Neiderreiter sequences
give rapid convergence to the solution.
Finance literature contains many references to the beneﬁts of using quasi-
random numbers for computing important ﬁnancial integrals. For instance,
Brotherton-Ratcliffe (1994) discusses the use of Sobol sequences for the val-
uation of geometric mean stock options, and provides results that show that
the root-mean-squared pricing error obtained using quasi-random numbers is
considerably less than that computed with pseudo-random numbers. Another
ﬁnancial application of quasi-random numbers is the efﬁcient pricing mort-
gage backed securities, Caﬂisch, Morokoff, and Owen (1997). Here Brownian
bridge techniques are employed to reduce the effective dimension of the prob-
lem and thus provide greater pricing accuracy than if pseudo-random numbers
were used.
3.3
Generation of multivariate distributions:
independent variates
In this section we show how to generate multivariate distributions that contain
independent variates; that is, the variates have zero correlation.

42
Computational Finance Using C and C#
3.3.1
Normal distribution
The most fundamental distribution is the univariate standard normal distri-
bution, N(0, 1), with zero mean and unit variance. In the case of p indepen-
dent variates this takes the form of a p variate independent normal distribution
N(0, Ip) with zero mean and p × p unit covariance matrix Ip.
First we will quote a result concerning multivariate probability density func-
tions; see Press, Teukolsky, Vetterling, and Flannery (1992). If x1, x2, . . . are ran-
dom variates with a joint probability density function p(x1, x2, . . .), and if there
are an equal number of y variates y1, y2, . . . that are functions of the x’s, then
the joint probability density function of the y variates, p(y1, y2, . . .), is given by
the following expression:
p(y1, y2, . . .) dy1 dy2, . . . = p(x1, x2, . . .)Jx,y dy1 dy2, . . .
(3.3.1)
where Jx,y is the Jacobian determinant of the x’s with respect to the y’s.
An important application of this result is the Box–Muller transformation in
which a p variate independent normal distribution N(0, Ip) is generated from a
p variate uniform distribution U(0, 1); see Box and Muller (1958).
We will now describe how the method works.
Consider two independently distributed N(0, 1) variables x and y, and use the
polar transformation to obtain:
x = r cos θ,
y = r sin θ,
and
r2 = x2 + y2
(3.3.2)
From Eq. (3.3.1) the joint probability density functions f (r, θ) and f (x, y) obey
the equation
f (r, θ) dr dθ = f (x, y)Jxy,rθ dr dθ
where the Jacobian is
Jxy,rθ =
    
cos θ
sin θ
−r sin θ
r cos θ
    = r
We therefore have
f (r, θ) = rf (x, y)
(3.3.3)
Furthermore since x and y are independent N(0, 1)
f (x, y) = f (x)f (y)
where
f (x) = e−x2/2
√
2π
and
f (y) = e−y2/2
√
2π
Therefore:
f (r, θ) = rf (x)f (y) = r e−x2/2
√
2π
e−y2/2
√
2π

Generation of random variates
43
which gives
f (r, θ) = r
2πe(−x2+y2)/2 = 1
2πre−r2/2 = f (θ)f (r)
(3.3.4)
where f (θ) = 1/(2π), f (r) = re−r2/2 are independent probability density func-
tions.
The corresponding cumulative probability distribution functions F(θ) and
F(r) can be found by evaluating the following integrals:
F(θ) = 1
2π
 θ
0
dθ = θ
2π
and
F(r) =
 r
0
re−r2/2 dr =

−e−r2/2r
0 = 1 −e−r2/2
We now want to draw variates ˆr and ˆθ from the probability distributions f (r)
and f (θ) respectively. To do this we will use the result (see for example Evans,
Hastings, and Peacock (2000)), that a uniform variate ¯u, from the distribution
U(0, 1) can be transformed into a variate ¯v from the distribution f (v) by using
¯v = F −1(¯u), or equivalently F(¯v) = ¯u. The variates ¯v are thus found by ﬁrst
drawing the uniform variate ¯u and then ﬁnding the value of v which makes
cumulative distribution function F(v) equal to ¯u.
Therefore, if variates V ′
1 and V ′
2 are from U(0, 1), then the variates ˆr and ˆθ
which satisfy V ′
1 = F(ˆr) = 1 −e−ˆr2/2, and V ′
2 = F( ˆθ) = ˆθ/(2π) are from the
distributions f (r) and f (θ) respectively.
For convenience we will deﬁne the U(0, 1) variates
V1 = 1 −V ′
1 = e−ˆr2/2
and
V2 = V ′
2
So we have:
V1 = e−ˆr2/2,
V2 =
ˆθ
2π
and
log V1 = −ˆr2
2 ,
ˆr = (−2 log V1)1/2,
and
ˆθ = 2πV2
Since ˆr is from the same distribution as r, and ˆθ is from the same distribution
as θ, we can use
log V1 = −r2/2,
r = (−2 log V1)1/2,
and
θ = 2πV2
Substituting these results into Eq. (3.3.2) gives
x = (−2 log V1)1/2 cos 2πV2,
y = (−2 log V1)1/2 sin 2πV2
(3.3.5)
where x and y are N(0, 1).

44
Computational Finance Using C and C#
The Box–Muller method is contained in Eq. (3.3.5), which shows that the
N(0, 1) variates are generated in pairs from the uniform U(0, 1) variates V1
and V2.
Since the N(0, 1) variates are created two at a time, if we want to generate a
normal distribution with an odd number of dimensions, nodd, it is necessary to
generate nodd + 1 dimensions and discard one of the dimensions.
It is easy to modify Eq. (3.3.5) so that we can specify the means and variances
of the variates x and y; this is accomplished as follows:
x = σ1(−2 log V1)1/2 cos 2πV2 + μ1,
(3.3.6)
y = σ2(−2 log V1)1/2 sin 2πV2 + μ2
where the distributions of x and y are now
x ∼N

μ1, σ 2
1

and
y ∼N

μ2, σ 2
2

Code excerpt 3.1 illustrates how to generate quasi-random normal variates with
given means and standard deviations.
long Quasi_Normal_Independent(long fcall, long seq, double xmean[], double std[],
long idim, double quasi[])
{
/* Input parameters:
=================
fcall
-
if fcall == 1 then it is an initialisation call,
if fcall == 0 then a continuation call
seq
-
if seq == 0 then a Faure sequence, if seq == 1 then a Niederreiter sequence,
if seq == 2 then a Sobol sequence
xmean[]
-
the means of the independent normal variates
std[]
-
the standard deviations of the independent normal variates
idim
-
the number of independent normal variates, idim must be less than 40
Output parameters:
==================
quasi[]
-
the elements quasi[0], .. quasi[idim-1] contain the independent normal variates
*/
long ierr, i, j;
double twopi, v1, v2, pi;
long ind1, ind2;
#define QUASI(I) quasi[(I)-1]
#define STD(I) std[(I)-1]
#define XMEAN(I) xmean[(I)-1]
if ((idim / 2) * 2 != idim) {
printf("Error on entry, idim is not an even number: idim = %ld\n" ,idim);
return 1;
} else if (idim > 40) {
printf("On entry, idim > 40: idim = %ld\n" ,idim);
return 1;
}
for (i = 1; i <= idim; ++i) {
if (STD(i) <= 0.0) {
printf("On entry, the standard deviation is not greater than zero:
STD(%ld) = %12.4f\n" ,i,STD(i));
return 1;
}
}
pi = 4.0*atan(1.0);
Code excerpt 3.1 Generating quasi-random normal variates using the Box–Muller trans-
formation.

Generation of random variates
45
if (fcall) { /* first call for initialisation */
if (seq == 0) {
Generate_Faure_Sequence(fcall, idim, &QUASI(1));
}
else if (seq == 1) {
Generate_Niederreiter_Sequence(fcall, idim, &QUASI(1));
}
else if (seq == 2) {
Generate_Sobol_Sequence(fcall, idim, &QUASI(1));
}
} else { /* a continuation call */
if (seq == 0) {
Generate_Faure_Sequence(fcall, idim, &QUASI(1));
}
else if (seq == 1) {
Generate_ Niederreiter_Sequence(fcall, idim, &QUASI(1));
}
else if (seq == 2) {
Generate_Sobol_Sequence(fcall, idim, &QUASI(1));
}
for (i = 1; i <= idim/2; ++i) { /* generate the normal variates */
ind1 = i * 2 - 1;
ind2 = i * 2;
twopi = pi * 2.0;
v1 = sqrt(log(QUASI(ind1)) * -2.0);
v2 = twopi * QUASI(ind2);
QUASI(ind1) = XMEAN(ind1) + STD(ind1) * v1 * cos(v2);
QUASI(ind2) = XMEAN(ind2) + STD(ind2) * v1 * sin(v2);
}
}
return 0 ;
}
Code excerpt 3.1 (Continued).
3.3.2
Lognormal distribution
The lognormal distribution can be generated from the normal distribution dis-
cussed in the previous section by means of a simple transformation. If y ∼
N(μ, σ 2) and y = log(x) then x = exp(y), and we say that the variable x has the
lognormal distribution (μ, σ 2).
The lognormal density function is:
f (x) =
1
xσ(2π)1/2 exp

−(log x −μ)2
2σ 2

(3.3.7)
If zi, i = 1, . . . , p, are independent normal variates N(μi, σ 2
i ), i = 1, . . . , p, then
lognormal variates ℓi, i = 1, . . . , p, can be generated using the transformation:
ℓi = exp(zi),
i = 1, . . . , p,
(3.3.8)
where the mean of the ith lognormal variate is
E[xi] = ¯mi = exp

μi + σ 2
i
2

(3.3.9)
and the variance is
Var[xi] = s2
i = exp

2μi + σ 2
i

exp

σ 2
i

−1

(3.3.10)
The ratio of variance to the mean squared is therefore
s2
i
¯m2
i
= exp

σ 2
i

−1
(3.3.11)

46
Computational Finance Using C and C#
or equivalently
σ 2
i = log

1 + s2
i
¯m2
i

(3.3.12)
A lognormal distribution consisting of p independent variates with means
¯mi, i = 1, . . . , p, and variances s2
i , i = 1, . . . , p, can thus be generated using
the following procedure.
First, generate the p independent normal variates:
zi ∼N

μi, σ 2
i

,
i = 1, . . . , p,
where
μi = log( ¯mi) −σ 2
i
2
(3.3.13)
and
σ 2
i = log

1 + s2
i
¯m2
i

(3.3.14)
Then create the independent lognormal variates using
ℓi = exp(zi),
i = 1, . . . , p
3.3.3
Student’s t-distribution
If St(μ, ν) represents the Student’s t-distribution with mean μ and number of
degrees of freedom ν, then variates X ∼St(0, ν) can be generated as follows:
X ∼
Z
√Y/ν
(3.3.15)
where Z ∼N(0, 1), and Y ∼χ2
ν . The variance of X is:
E

X2
=
ν
ν −2
Variates X′ from a Student’s t-distribution having ν degrees of freedom with
mean μ and variance s can be generated by modifying Eq. (3.3.15) as follows:
X′ ∼μ +
s1/2
√ν/(ν −2)
Z
√Y/ν
(3.3.16)
The probability density function, f (x), for X′ is:
f (x) = ((ν + 1)/2)(ν −2)−1/2s−1/2
π1/2(ν/2)

1 + (x −μ)2
s(ν −2)
−(ν+1)/2
(3.3.17)
where ν > 2.

Generation of random variates
47
3.4
Generation of multivariate distributions:
correlated variates
In this section we will show how to generate variates from a multivariate distri-
bution with a known mean and a given covariance or correlation matrix. The
methods described for covariance matrices are also applicable to correlation ma-
trices, although in this case the generated variates are normalized to have unit
variance.
3.4.1
Estimation of correlation and covariance
Here we show how to obtain a valid correlation matrix Cr or covariance ma-
trix C from historic market data.
Let 
X be an n by p data matrix, with the entries in the ith row corresponding
to the ith observation, and the jth column containing the values of the jth
variable. If we create a new matrix X such that the entries of the jth column of
X are Xi,j = 
Xi,j −μj, i = 1, . . . , n, where μj is the mean of the jth column of

X, then the p by p matrix C = XTX is the covariance matrix of 
X.
Further, if another matrix 
X is deﬁned such that 
Xi,j =

Xi,j −μj
σj
, i = 1, . . . , n,
where μj is the mean of the jth column of 
X, and σj is the standard deviation
of the jth column, then the p by p matrix Cr = 
XT
X is the correlation matrix
of 
X.
Correlation matrix
Let us ﬁrst consider the properties of a valid correlation matrix. They are:
• The matrix is symmetric with unit diagonal
• The matrix has to be positive deﬁnite—that is, all the eigenvalues need to be
positive.
We will now show that the p by p matrix Cr is a valid correlation matrix
if it can be factored as Cr = XTX, where X is a nonsingular (that is, full rank)
n by m data matrix.
The proof is as follows:
Since X is nonsingular we can perform the singular value decomposition:
X = UKV T
where U is an n by n unitary matrix, K is an n by p matrix containing the
(nonzero) singular values σi, i = 1, . . . , p, as the diagonal elements and zero
elsewhere, and V is a p by p unitary matrix.
We thus have
XTX =

UKV TTUKV T
= V KTUTUKV T

48
Computational Finance Using C and C#
= V TKTKV T
since UTU = UUT = In
= V ΣV T
Therefore
Cr = XTX = V ΣV T
where Σ is the p by p diagonal matrix containing the eigenvalues of Cr, and
V is the corresponding matrix of eigenvectors. Since the ith eigenvalue satisﬁes
λi = σ 2
i it can be seen that all the eigenvalues are positive, and thus Cr must be
positive deﬁnite.
If Cr is positive deﬁnite, then we can perform the Cholesky decomposition
Cr = LLT where L is a lower triangular matrix.
3.4.2
Repairing correlation and covariance matrices
There are situations when a supplied correlation matrix is not positive deﬁnite.
Some of the reasons for this are:
• There may be missing data, or asynchronous data feeds. As a consequence
the elements in the correlation matrix may have then been computed using
pairwise correlations, with a variety of sequence lengths. Under these circum-
stances the equation Cr = XTX is no longer true, and so Cr cannot be guar-
anteed to be positive deﬁnite
• Manual adjustment of a correlation matrix may have occurred to reﬂect ex-
pected market conditions. This especially occurs when the market crashes and
certain stock prices become highly correlated
• There may be rounding error in computing Cr = XTX.
Under these circumstances the best that can be done is to try and repair the
correlation matrix Cr into a valid correlation matrix 
Cr.
We proceed as follows.
When Cr is not positive deﬁnite (the Cholesky decomposition fails) then we
use the eigen decomposition:
Cr = V ΣV T
where
Σ =
⎛
⎜⎜⎜⎝
λ1
λ2
.
.
λp
⎞
⎟⎟⎟⎠
We then form the matrix
C+
r = V KKTV T = V K(V K)T

Generation of random variates
49
where the matrix K is formed by taking the square root of the maximum of
each eigenvalue and a very small number ε (say ∼10−16). Thus:
K =
⎛
⎜⎜⎜⎝
√max(λ1, ε)
√max(λ2, ε)
.
.
max(λp, ε)
⎞
⎟⎟⎟⎠
The matrix C+
r is not acceptable as a correlation matrix because, although real,
symmetric and positive deﬁnite, its diagonal elements are not unity. It is possi-
ble to remedy this by premultiplying and postmultiplying C+ by the diagonal
matrix F:

Cr = FC+
r F = FC+
r F T
where 
C is the new repaired correlation matrix—i.e., it is positive deﬁnite, sym-
metric, and has unit diagonal elements. To achieve this, the diagonal elements
of F must be given by:
Fii =
1

C+
rii
We thus have:

Cr = FC+
r F T
= FV K(V K)TF T
= (FV K)

KTV TF T
= (FV K)(FV K)T
(3.4.1)
An optimally repaired correlation matrix C∗
r , which minimizes the distance
∥Cr −C∗
r ∥, can be obtained via numerical optimization on the n-dimensional
unit hypersphere; this is described below.
However, it has been found that 
Cr is a very good approximation for the
optimal estimate C∗
r .
Optimally repaired correlation matrix
Here we provide details of how to obtain an optimally repaired correlation
matrix by using hyperspherical coordinates and the method of Rebonato and
Jäckel (1999/2000)—for a different approach see Higham (2002) or Qi and
Sun (2006).
The Cartesian coordinates of the ith point on an n-dimensional hypersphere
with radius r can be shown to be:
xi,1 = r cos(θi,1)
xi,2 = r sin(θi,1) cos(θi,2)

50
Computational Finance Using C and C#
xi,3 = r sin(θi,1) sin(θi,2) cos(θi,3)
xi,4 = r sin(θi,1) sin(θi,2) sin(θi,3) cos(θi,4)
...
xi,n−1 = r sin(θi,1) sin(θi,2) · · · sin(θi,n−3) sin(θi,n−2) cos(θi,n−1)
xi,n = r sin(θi,1) sin(θi,2) · · · sin(θi,n−2) sin(θi,n−1)
where θi,1 are spherical coordinates and have the following constraints: 0 ⩽
θi,k ⩽π, k = 1, . . . , n −2, and 0 ⩽θi,n−1 ⩽2π.
By construction the radius of the sphere satisﬁes
r2 =
n

k=1
(xi,k)2
This can be seen as follows:
n

k=1
(xi,k)2
= r2
cos2(θi,1) + sin2(θi,1)

cos2(θi,2)
+ sin2(θi,2)

cos2(θi,3)
+ sin2(θi,3)

cos4(θi,4)
+ · · · + sin2(θi,n−2)
×

cos2(θi,n−1) + sin2(θi,n−1)

· · ·

= r2
where we have used
cos2(θi,k) + sin2(θi,k) = 1,
k = 1, . . . , n −1
If, when r = 1, the coordinates of n hyperspherical points are stored in the n
rows of the n by n matrix BT, then:
BT
i,1 = cos(θi,1)
BT
i,j = cos(θi,j)
j−1

k=1
sin(θi,k),
j = 2, . . . , n −1,
BT
i,n =
n−1

k=1
sin(θi,k),
n > 1,
BT =
⎛
⎜⎜⎝
cos(θ1,1)
sin(θ1,1) cos(θ1,2)
sin(θ1,1) sin(θ1,2) cos(θ1,3)
· · ·
cos(θ2,1)
sin(θ2,1) cos(θ2,2)
sin(θ2,1) sin(θ2,2) cos(θ2,3)
· · ·
cos(θ3,1)
sin(θ3,1) cos(θ3,2)
sin(θ3,1) sin(θ3,2) cos(θ3,3)
· · ·
...
...
...
...
⎞
⎟⎟⎠

Generation of random variates
51
It can thus be seen that the diagonal elements of BTB are

BTB

i,i =
n

k=1
(xi,k)2 = 1
The Cholesky decomposition can be formed by setting the angles of the upper
triangular elements of BT to zero, and this results in
LT =
⎛
⎜⎜⎝
1
0
0
· · ·
cos(θ2,1)
sin(θ2,1)
0
· · ·
cos(θ3,1)
sin(θ3,1) cos(θ3,2)
sin(θ3,1) sin(θ3,2)
· · ·
...
...
...
...
⎞
⎟⎟⎠
LT
1,1 = 1
LT
i,1 = cos(θi,1)
LT
i,j = cos(θi,j)
j−1

k=1
sin(θi,k),
j = 2, . . . , i −1,
LT
i,i =
i−1

k=1
sin(θi,k),
i > 1,
LT
i,j = 0,
j = i + 1, . . . , n
We want to ﬁnd the positive deﬁnite matrix C∗
r which minimizes ∥Cr −C∗
r ∥.
This can be found by writing
C∗
r = LTL
and using numerical optimization to determine the appropriate n(n −1)/2 an-
gles. An initial approximation can be obtained by computing the Cholesky fac-
torization 
Cr = LTL and then calculating the angles corresponding to each
nonzero element of LT.
Covariance matrix
We will now consider the case when a covariance matrix C is supplied which
is not positive deﬁnite—that is, there is no Cholesky decomposition C = LTL,
where L is lower triangular.
In these circumstances, since a covariance matrix does not require unit diag-
onal elements, it is possible to repair C using:
C+ = V K(V K)T
where V and K have the same meanings as before. A better approximation
could be obtained via numerical optimization of the elements of the Cholesky
decomposition. However, these optimal points are no longer constrained to lie
on the n-dimensional unit hypersphere.

52
Computational Finance Using C and C#
3.4.3
Normal distribution
Here we show how to generate a p variate normal distribution with a given
mean and covariance matrix.
We will denote the vector containing the variates of the ith observation from
a p variate zero mean normal distribution by Zi; that is, we write a sample of n
observations as:
Zi ∼N(0, C),
i = 1, . . . , n,
(3.4.2)
where C is the p × p covariance matrix.
Further Zi,k is used to denote the kth element of Zi, which contains the value
of the kth variate for the ith observation.
From a computational point of view, we can then consider a sample of n
observations to be represented by the n×p matrix Z. The ith row of Z contains
the values for ith the observation, and the kth column of the ith row, Zi,k,
contains the value of the kth variate for the ith observation.
Also, since the distribution has zero mean, the sample covariance matrix is
given by: C = ZTZ.
To generate variates with the covariance matrix C we can use the fact that, if
the matrix C is positive deﬁnite, a Cholesky factorization exists in which:
C = AAT
(3.4.3)
where A is lower triangular.
We can therefore generate p variates which have a covariance matrix C as
follows.
First generate by (for example) using the Box–Muller method described in
Section 3.3.1, the independent normal variates:
X ∼N(0, Ip)
where the vector X contains the p variates, Ip is the unit matrix, and XXT = Ip.
Then, using the Cholesky factorization of Eq. (3.4.4), form:
Y = AX
(3.4.4)
where Y is a p-element vector.
Now, since YY T = AX(AX)T = A(XXT)AT = AAT = C, we have that
Y ∼N(0, C)
Variates that have nonzero means μk, k = 1, . . . , p, can be obtained by simply
modifying Eq. (3.4.4) to:
Y ′ = AX + μ
(3.4.5)
where Y ′ is a p variate vector that is distributed as N(μ, C), and the p elements
of vector μ contain the means of the variates Y ′
k, k = 1, . . . , p.
If the matrix C is not positive deﬁnite, then we can create a repaired matrix,

C, by using the approach outlined in Section 3.4.2.

Generation of random variates
53
We now use the decomposition:

C = V K(V K)T
Under these circumstances the p-element vectors Y and Y ′ are generated using
the following modiﬁed versions of Eqs. (3.4.4) and (3.4.5):
Y = V KX
and
Y ′ = V KX + μ
(3.4.6)
The method for generating variates Y from a given correlation matrix Cr
is identical. However, in this case nonpositive deﬁnite matrices are repaired as

Cr = FV K(FV K)T; see Section 3.4.2.
A function to generate correlated normal and lognormal variates is given in
Code excerpt 3.2.
long Quasirandom_Normal_LogNormal_Correlated(long fcall, long seq, long lnorm,
double means[], long n, double c[], long tdc, double tol, long *irank,
double x[], double work[], long lwk) {
/* Input parameters:
=================
fcall
-
if fcall == 1 then it is an initialisation call,
if fcall == 0 then a continuation call
seq
-
if seq == 0 then a Faure sequence, if seq == 1 then a Niederreiter sequence,
if seq == 2 then a Sobol sequence
lnorm
-
if lnorm == 1 then it is a lognormal distribution,
if lnorm == 0 then a normal distribution
n
-
the number of variates, n must be less than 40
c[]
-
a matrix which contains the required covariance matrix, C
tdc
-
the second dimension of the matrix C
tol
-
the tolerance used for calculating the rank of the covariance matrix C
means[]
-
the means of the independent normal variates
std[]
-
the standard deviations of the independent normal variates
lwk
-
the size of the work array, work
Output parameters:
==================
rank
-
the computed rank of the covariance matrix C
x[]
-
the elements x[0], .. x[n-1] contain the variates
Input/Output parameters:
=========================
work
-
a work array
*/
double zero = 0.0, one = 1.0, two = 2.0;
long n1, i, j, k, kk;
double mtol, alpha;
long ptrc, ptre, ptrv, ptrw, ptrw0, ptrw1;
#define C(I,J) c[((I)-1) * tdc + ((J)-1)]
#define MEANS(I) means[(I)-1]
#define X(I) x[(I)-1]
#define WORK(I) work[(I)-1]
if (lwk < (2 + 3*n + 2*n*n + 3)) {
printf ("Error lwk is too small \n");
return 1;
}
ptre = 2;
ptrv = n+2;
ptrw = n*n + n + 2;
Code excerpt 3.2 The function Quasirandom_Normal_LogNormal_Correlated
which generates correlated quasi-random normal variates and correlated quasi-random
lognormal variates.

54
Computational Finance Using C and C#
/* add extra 1 to allow for odd values of n */
ptrw0 = ptrw + 1 + n;
ptrw1 = ptrw0 + 1 + n;
ptrc
= ptrw1 + n + 1;
n1 = n;
if (((n/2)*2) != n) { /*
test for odd n */
n1 = n + 1;
}
if (fcall) {
/* first call for initialisation */
if (lnorm) { /* lognormal distribution */
for (i = 1; i <=n; ++i) { /* Load the modified covariance matrix into WORK */
for (j = 1; j <= n; ++j) {
WORK(ptrc+(i-1)*n+j-1) = log(one + C(i,j)/(MEANS(i)*MEANS(j)));
}
}
}
else { /* normal distribution */
for (i = 1; i <=n; ++i) {
/* Load the covariance matrix into WORK */
for (j = 1; j <= n; ++j) {
WORK(ptrc+(i-1)*n+j-1) = C(i,j);
}
}
}
/* calculate the eigenvalues and eigenvector of the matrix that
has been loaded into WORK */
calc_eigvals_eigvecs (n,&WORK(ptrc),n,&WORK(ptre),&WORK(ptrv),n);
/* The code uses NAG routine f02abc */
*irank = 0;
/*
printf ("The eigenvalues are \n");
for (j=n; j >= 1; --j) {
printf ("%12.5f \n", WORK(ptre+j-1));
}
*/
for (j=n; j >= 1; --j) { /* use the eigenvalues to calculate the rank of the matrix */
if (WORK(ptre+j-1) < tol) goto L24;
*irank = *irank + 1;
}
printf ("*irank = %ld \n",*irank);
L24:
mtol = -tol;
if (WORK(ptre) < mtol) {
printf ("Warning there is an eigenvalue less than %12.4f \n",mtol);
}
for (j=1; j <= *irank; ++j) {
kk = 1;
for (k=1; k <=n; ++k) {
if(WORK(ptrv+(k-1)*n+(j-1)) != zero) goto L28;
kk = kk + 1;
}
L28:
/* ensure that all eigenvectors have the same sign on different machines */
alpha = sqrt(WORK(ptre+j-1));
if
(WORK(ptrv+(kk-1)*n+(j-1)) < zero)
alpha = -sqrt(WORK(ptre+j-1));
for (i = 1; i <= n; ++i) {
WORK(ptrv+(j-1)+(i-1)*n)=WORK(ptrv+(j-1)+(i-1)*n)*alpha;
}
}
/*
printf ("The eigenvectors are \n");
for (j=1; j <= *irank; ++j) {
for (i = 1; i <= n; ++i) {
printf ("%10.5f ", WORK(ptrv+(j-1)+(i-1)*n));
}
printf ("\n");
}
*/
for (i = 1; i <=n; ++i)
{ /* store a vector of ones and zeros for generating the quasi-random numbers */
WORK(ptrw0+i-1) = zero;
WORK(ptrw1+i-1) = one;
}
Code excerpt 3.2 (Continued).

Generation of random variates
55
for (i = n; i <= n1; ++ i) {
WORK(ptrw0+i-1) = zero;
WORK(ptrw1+i-1) = one;
}
} /* end of first
call section */
/* generate a vector of n1 random variables from a standard normal distribution,
zero mean and unit variance */
Quasi_Normal_Independent(fcall, seq, &WORK(ptrw0), &WORK(ptrw1),
n1, &WORK(ptrw));
/*
printf ("The quasi random numbers are:\n");
for (i = 1; i <= n; ++i) {
printf ("%12.4f \n", WORK(ptrw+(i-1)));
}
*/
/* Now generate variates with the specified mean and variance */
if (lnorm) { /* a lognormal distribution */
for (i = 1; i <= n; ++i) {
X(i) =
log(MEANS(i)) - WORK(ptrc+(i-1)*n+i-1)/two;
for (k = 1; k <= *irank; ++k) {
X(i)=X(i)+WORK(ptrv+(k-1)+(i-1)*n)*WORK(ptrw+k-1);
}
}
for (i = 1; i <= n; ++i) {
X(i) = exp(X(i));
}
}
else { /* a normal distribution */
for (i = 1; i <= n; ++i) {
X(i) =
MEANS(i);
for (k = 1; k <= *irank; ++k) {
X(i)=X(i)+WORK(ptrv+(k-1)+(i-1)*n)*WORK(ptrw+k-1);
}
}
}
/*
printf ("The generated variates are:\n");
for (i = 1; i <= n; ++i) {
printf (" %12.4f \n", X(i));
}
*/
return 0;
}
Code excerpt 3.2 (Continued).
In order to visualize the effect of the covariance matrix we will display the
results of using function Quasirandom_Normal_LogNormal_Correlated
to generate the following variates:
• A vector of three normal independent variates with covariance matrix:
C1 =
 1.0
0.0
0.0
0.0
1.0
0.0
0.0
0.0
1.0

• A vector of three normal variates in which the elements of the covariance
matrix are all positive; the covariance matrix is:
C2 =
 1.0
0.8
0.8
0.8
1.0
0.8
0.8
0.8
1.0


56
Computational Finance Using C and C#
Figure 3.5 Scatter diagram for a sample of 3000 observations (Zi, i = 1, . . . , 3000) gener-
ated from a multivariate normal distribution consisting of three variates with covariance
matrix C1 and mean μ. Here we plot the values of the ﬁrst variate against the values of
the second variate. If we use the notation of Eq. (3.4.2), then the (x, y) coordinates for
the points are xi = Zi,1, i = 1, . . . , 3000, and yi = Zi,2, i = 1, . . . , 3000.
• A vector of three normal variates in which two elements of the covariance
matrix are negative; the covariance matrix is:
C3 =
 1.0
−0.7
0.2
−0.7
1.0
0.2
0.2
0.2
1.0

In all cases the mean vector is given by:
μ =
 2.0
2.0
2.0

The results are displayed in Figs. 3.5–3.7.
3.4.4
Lognormal distribution
The multivariate lognormal distribution is important because it is the asset re-
turns distribution assumed by the Black–Scholes equation.
Let the p-element vectors Y and X be related by Y = log(X) where Y ∼
N(μ, Σ), μ is a p-element vector, and Σ is a p×p matrix. Then X = exp(Y) and
X has multivariate lognormal distribution, which we denote by X ∼(μ, Σ).
We will represent the p-element mean vector of X by ¯m and the p × p covari-
ance matrix of X by S.

Generation of random variates
57
Figure 3.6 Scatter diagram for a sample of 3000 observations (Zi, i = 1, . . . , 3000) gener-
ated from a multivariate normal distribution consisting of three variates with covariance
matrix C2 and mean μ. Here we plot the values of the ﬁrst variate against the values of
the second variate. If we use the notation of Eq. (3.4.2), then the (x, y) coordinates for
the points are xi = Zi,1, i = 1, . . . , 3000, and yi = Zi,2, i = 1, . . . , 3000.
Figure 3.7 Scatter diagram for a sample of 3000 observations (Zi, i = 1, . . . , 3000) gener-
ated from a multivariate normal distribution consisting of three variates with covariance
matrix C3 and mean μ. Here we plot the values of the ﬁrst variate against the values of
the second variate. If we use the notation of Eq. (3.4.2), then the (x, y) coordinates for
the points are xi = Zi,1, i = 1, . . . , 3000, and yi = Zi,2, i = 1, . . . , 3000.

58
Computational Finance Using C and C#
It can be shown that:
Σi,j = log

1 + Si,j
¯mi ¯mj

(3.4.7)
and
μi = log( ¯mi) −Σi,i
2 ,
i = 1, . . . , p, and j = 1, . . . , p
(3.4.8)
For the case of independent variates we then have:
μi = log( ¯mi) −σ 2
i
2 ,
i = 1, . . . , p,
and
Σi,i = σ 2
i = log

1 + s2
i
¯mi2

,
i = 1, . . . , p,
and for i ̸= j,
Σi,j = 0
which are just Eqs. (3.3.13) and (3.3.14) given in Section 3.3.2.
Code excerpt 3.3 shows how to generate a multivariate lognormal distri-
bution with a given mean ¯m and covariance matrix S. More complete infor-
mation can be found in the function Quasirandom_Normal_LogNormal_
Correlated which is provided in Code excerpt 3.2.
double sig[40][40], s[40][40]; /* limit of 40 */
double means[40], x[40], lx[40], tmp;
.
.
.
#define S(I,J) s[(I)-1][(J)-1]
#define SIG(I,J) sig[(I)-1][(J)-1]
#define MEANS(i) means[(I)-1]
/* the means of the lognormal distribution */
#define X(I) x[(I)-1] /* normal variates */
#define LX(I) lx[(I)-1] /* lognormal variates */
.
.
.
/* obtain the Gaussian covariance matrix SIG, that corresponds to the
lognormal covariance matrix S. */
for (i=1; i <= m; ++i) {
for (j=1; j <= m; ++j) {
tmp = MEANS(i) * MEANS(j);
SIG(i,j) = log( 1 + (S(i,j)/tmp));
}
}
.
.
.
/* Generate multivariate Gaussian variates X(i),i = 1,..,m, with zero mean and
covariance matrix SIG, using section ..
*/
.
.
.
/* Using equation () generate normal variates with the correct mean */
for (i=1; i <= m; ++i) {
X(i) = X(i) + log(MEANS(i)) - SIG(i,i)/2;
}
/* Now exponentiate to create lognormal variates with mean
XMEAN, and covariance matrix S */
for (i=1; i <= m; ++i) {
LX(i) = exp(X(i));
}
Code excerpt 3.3 Illustrating how to generate variates from a lognormal distribution
with a given mean and covariance matrix.

4 European options
4.1
Introduction
A European option taken out at current time t gives the owner the right (but not
the obligation) to do something when the option matures at time T . This could,
for example, be the right to buy or sell stocks at a particular strike price. The
option would of course only be exercised if it was in the owner’s interest to do
so. For example, a single asset European vanilla put option, with strike price E
and expiry time T , gives the owner the right at time T to sell a particular asset
for E. If the asset is worth ST at maturity then the value of the put option at
maturity, known as the payoff, is thus max(E −ST , 0). By contrast a single asset
European vanilla call option, with strike price E and expiry time T , gives the
owner the right at time T to buy an asset for E; the payoff at maturity for a call
option is max(ST −E, 0).
The owner of an American option has the right (but not the obligation) to
exercise the option at any time from current time t to option maturity. These
options are more difﬁcult to value than European options because of this ex-
tra ﬂexibility. Even the simple single asset American vanilla put has no analytic
solution and requires ﬁnite-difference and lattice methods to estimate its value.
Many European options, on the other hand, take the form of a relatively easy
deﬁnite integral from which it is possible to compute a closed form solution.
The valuation of multiasset European options, dependent on a large number of
underlying assets, is more complicated but can conveniently be achieved by us-
ing Monte Carlo simulation to compute the required multidimensional deﬁnite
integral.
The expected current value of a single asset European vanilla option will de-
pend on the current asset price at time t, S, the duration of the option, τ = T −t,
the strike price, E, the riskless interest rate, r, and the probability density func-
tion of the underlying asset at maturity, p(ST ).
4.2
Pricing derivatives using a martingale measure
In this section we will brieﬂy summarize the results of Harrison and Kreps
(1979) and Harrison and Pliska (1981). Let us consider an economy over the
time interval [0, T ] which consists of n assets Si, i = 1, . . . , n, which can take

60
Computational Finance Using C and C#
the values Si
t , i = 1, . . . , n, 0 ⩽t ⩽T . Any asset Si which only takes values that
are greater than zero is called a numeraire. Numeraires can be used to denom-
inate all the asset prices in the economy. So (for example) if S1 is a numeraire
then the prices of the other assets denominated in units of S1 are the relative
prices Zi
t = (Si
t /S1
t ), i = 2, . . . , n.
One can ﬁnd a unique probability measure Q such that the relative prices
Zi
t , i = 2, . . . , n, are martingales. If the economy is free of arbitrage opportu-
nities then every payoff pattern HT can be represented as a linear combination
of the asset values Si
t , i = 1, . . . , n, and in addition the relative price process
(HT /S1
T ) is a martingale.
This means that we can write
EQ
Ht
S1t

= EQ
HT
S1
T

,
where 0 ⩽t ⩽T
The current (time t) value Vt of the payoff HT is thus
Vt = S1
t EQ
HT
S1
T

In general for a numeraire N which takes the values Nt, 0 ⩽t ⩽T , we can write
Vt = NtEQ
HT
NT

(4.2.1)
Equation (4.2.1) is very important because Vt is the current (time t) price of a
ﬁnancial derivative with maturity T and payoff HT .
It should be mentioned that the price of a ﬁnancial derivative is independent
of the martingale measure under which it is valued, and thus the same price Vt
will be obtained for different numeraires N.
4.3
Put call parity
4.3.1
Discrete dividends
Here we consider single asset European put and call options, and derive the
following relationship between their values in the presence of cash dividends:
c(S, E, τ) + E exp(−rτ) + D = p(S, E, τ) + S
(4.3.1)
where D is the present value of the dividends that are paid during the life of the
option. That is:
D =
n

k=1
Dk exp

−r(tk −t)

with Dk the kth cash dividend paid at time tk; the other symbols have already
been deﬁned in Section 4.1.
This result can be proved by considering the following two investments:

European options
61
Portfolio A: One European call, c(S, E, τ), and cash of value E exp(−rτ)+D.
Portfolio B: One European put, p(S, E, τ), and one share of value S.
At option maturity the value of the call and put are c(ST , E, 0) and
p(ST , E, 0), respectively; also at time T the value of the dividends paid dur-
ing the life of the option is D exp(rτ).
We now consider the value of both portfolios at time T under all possible
conditions.
If ST ⩾E
Portfolio A is worth:
max(ST −E, 0) + exp(rτ)

E exp(−tτ) + D

= ST −E + E + D exp(rτ)
= ST + D exp(rτ)
Portfolio B is worth:
max(E −ST , 0) + ST + D exp(rτ) = 0 + ST + D exp(rτ)
= ST + D exp(rτ)
If ST < E
Portfolio A is worth:
max(ST −E, 0) + exp(rτ)

E exp(−tτ) + D

= 0 + E + D exp(rτ)
= E + D exp(rτ)
Portfolio B is worth:
max(E −ST , 0) + ST + D exp(rτ) = E −ST + ST + D exp(rτ)
= E + D exp(rτ)
We have therefore shown that under all conditions the value of portfolio A is
the same as that of portfolio B.
4.3.2
Continuous dividends
Here we consider single asset European put and call options, and derive the
following relationship:
c(S, E, τ) + E exp(−rτ) = p(S, E, τ) + S exp(−qτ)
(4.3.2)
where q is the asset’s continuous dividend yield that is paid during the life of the
option. The result can be proved by considering the following two investments:
Portfolio A: One European call, c(S, E, τ), and cash of value E exp(−rτ).

62
Computational Finance Using C and C#
Portfolio B: One European put, p(S, E, τ), and one share of value
S exp(−qτ).
At option expiry the value of the call and put are c(ST , E, 0) and p(ST , E, 0),
respectively. Also, if the value of the share at time t is denoted by S, the com-
bined value of shares and dividends at time T is S exp(qτ): Note that q is treated
in a similar manner to the continuously compounded riskless interest rate r.
If ST ⩾E
Portfolio A is worth:
max(ST −E, 0) + exp(rτ)E exp(−rτ) = ST −E + E = ST
Portfolio B is worth:
max(E −ST , 0) + ST exp(−qτ) exp(qτ) = 0 + ST = ST
where ST exp(−qτ) exp(qτ) is the combined value of the shares and dividends at
option maturity.
If ST < E
Portfolio A is worth:
max(ST −E, 0) + exp(rτ)E exp(−rτ) = 0 + E = E
Portfolio B is worth:
max(E −ST , 0) + ST exp(−qτ) exp(qτ) = E −ST + ST = E
We have therefore shown that under all conditions the value of portfolio A is
the same as that of portfolio B.
4.4
Vanilla options and the Black–Scholes model
4.4.1
The option pricing partial differential equation
In this section we will derive the (Black–Scholes) partial differential equation
that is obeyed by options written on a single asset.
Previously, in Section 2.3 and Section 2.5, we derived Ito’s lemma, which
provides an expression for the change in value of the function φ(X, t), where
X is a stochastic variable. When the stochastic variable, X, follows GBM, the
change in the value of φ was shown to be given by Eq. (2.3.6). Here we will
assume that the function φ(S, t) is the value of a ﬁnancial option and that the
price of the underlying asset, S, follows GBM.
If we denote the value of the ﬁnancial derivative by f , then its change, df ,
over the time interval dt is given by:
df =

μS ∂f
∂S + ∂f
∂t + σ 2S2
2
∂2f
∂S2

dt + ∂f
∂S σS dW,
dW ∼N(0, dt)

European options
63
The discretized version of this equation is:
f = t

μS ∂f
∂S + ∂f
∂t + σ 2S2
2
∂2f
∂S2

+ ∂f
∂S σSW,
W ∼N(0, t),
(4.4.1)
where the time interval is now t and the change in derivative value is f .
If we assume that the asset price, S, follows GBM we also have:
S = μSt + σSW,
W ∼N(0, t),
(4.4.2)
where μ is the constant drift and the deﬁnition of the other symbols is as before.
Let us now consider a portfolio consisting of −1 derivative and ∂f
∂S units of the
underlying stock. In other words we have gone short (that is sold) a derivative
on an asset and have ∂f
∂S stocks of the (same) underlying asset. The value of the
portfolio, Π, is therefore:
Π = −f + ∂f
∂S S
(4.4.3)
and the change, Π, in the value of the portfolio over time t is:
Π = −f + ∂f
∂S S
(4.4.4)
Substituting Eqs. (4.4.1) and (4.4.2) into Eq. (4.4.4) we obtain:
Π = −

μS ∂f
∂S + ∂f
∂t + 1
2σ 2S2 ∂2f
∂S2

t
−σSW ∂f
∂S + ∂f
∂S {μSt + σSW}
∴Π = −μSt ∂f
∂S −t ∂f
∂t −1
2tσ 2S2 ∂2f
∂S2
−σSW ∂f
∂S + μSt ∂f
∂S + σSW ∂f
∂S
(4.4.5)
Cancelling terms we obtain:
Π = −t
∂f
∂t + 1
2σ 2S2 ∂2f
∂S2

(4.4.6)
If this portfolio is to grow at the riskless interest rate r, we have:
rΠt = Π
So we have that:
rΠt = −t
∂f
∂t + 1
2σ 2S2 ∂2f
∂S2

(4.4.7)
Substituting for Π, we obtain:
rt

f −S ∂f
∂S

= −t
∂f
∂t + 1
2σ 2S2 ∂2f
∂S2

(4.4.8)

64
Computational Finance Using C and C#
On rearranging we have:
∂f
∂t + S ∂f
∂S + 1
2σ 2S2 ∂2f
∂S2 = rf
(4.4.9)
which is the Black–Scholes partial differential equation. See Appendix I con-
cerning the Feynman–Kac formula.
Let us now consider put and call options on the same underlying asset. If we
let c be the value of a European call option and p that of a European put option
then we have the following equations:
∂p
∂t + S ∂p
∂S + 1
2σ 2S2 ∂2p
∂S2 = rp
(4.4.10)
and
∂c
∂t + S ∂c
∂S + 1
2σ 2S2 ∂2c
∂S2 = rc
(4.4.11)
If we now form a linear combination of put and call options, Ψ = a1c + a2p,
where both a1 and a2 are constants, then Ψ also obeys the Black–Scholes equa-
tion:
∂Ψ
∂t + S ∂Ψ
∂S + 1
2σ 2S2 ∂2Ψ
∂S2 = rΨ
(4.4.12)
We will now prove that Ψ satisﬁes Eq. (4.4.12).
First we rewrite Eq. (4.4.12) as:
∂(a1c + a2p)
∂t
+ S ∂(a1c + a2p)
∂S
+ 1
2σ 2S2 ∂2(a1c + a2p)
∂S2
= r(a1c + a2p)
(4.4.13)
and use the following results from elementary calculus:
∂(a1c + a2p)
∂t
= a1
∂c
∂t + a2
∂p
∂t
∂(a1c + a2p)
∂S
= a1
∂c
∂S + a2
∂p
∂S
and
∂2(a1c + a2p)
∂S2
= a1
∂2c
∂S2 + a2
∂2p
∂S2
If we denote the left-hand side of Eq. (4.4.12) by LHS, then we have:
LHS = a1
∂c
∂t + S ∂c
∂S + 1
2σ 2S2 ∂2c
∂S2

+ a2
∂p
∂t + S ∂p
∂S + 1
2σ 2S2 ∂2p
∂S2

(4.4.14)

European options
65
We now use Eqs. (4.4.10) and (4.4.11) to substitute for the values in the curly
brackets in Eq. (4.4.14), and we obtain:
LHS = a1rc + a2rp
(4.4.15)
which is just the right-hand side of Eq. (4.4.12); so we have proved the result.
It should be noted that this result is also true for American options, since they
also obey the Black–Scholes equation.
The above result can be generalized to include a portfolio consisting of n sin-
gle asset options. Here we have:
Ψ =
n

j=1
ajfj,
j = 1, . . . , n,
where fj represents the value of the jth derivative and aj is the number of
units of the jth derivative. To prove that Ψ follows the Black–Scholes equa-
tion we simply partition the portfolio into sectors whose options depend on the
same underlying asset. We then proceed as before by showing that the value
of each individual sector obeys the Black–Scholes equation and thus the value
of the complete portfolio (the sum of the values of all the sectors) obeys the
Black–Scholes equation. It should be mentioned that this result applies for both
American and European options and it does not matter whether we have bought
or sold the options.
In Chapter 5 we will use the fact that the difference between the value of a
European option and the equivalent American option obeys the Black–Scholes
equation. We can see this immediately by considering the following portfolios
that are long in an American option and short (i.e., have sold) a European op-
tion:
Ψ p = P −p,
Ψ c = C −c
where P and C are the values of American put and call options. Ψ p and Ψ c both
obey the Black–Scholes equations, and are the respective differences in value of
American/European put options and American/European call options.
4.4.2
The multiasset option pricing partial differential equation
In this section we will derive the multiasset (Black–Scholes) differential equation
that is obeyed by options written on n assets. Proceeding as in Section 4.4.1, we
will use the n-dimensional version of Ito’s lemma to ﬁnd the process followed
by the value of a multiasset ﬁnancial derivative. We will denote the value of this
derivative by f (S, t), where S is an n-element stochastic vector containing the
prices of the underlying assets, Si, i = 1, . . . , n. If we assume that S follows
n-dimensional GBM then the change in the value of the derivative, df , is (see

66
Computational Finance Using C and C#
Eq. (2.5.8)) given by:
df =

∂f
∂t +
n

i=1
μiSi
∂f
∂Si
+ 1
2
n

i=1
n

j=1
σiσjSiSjρij
∂2f
∂Si ∂Sj

dt
+
n

i=1
∂f
∂Si
σiSi dWi
(4.4.16)
The discretized version of this equation is:
f =

∂f
∂t +
n

i=1
μiSi
∂f
∂Si
+ 1
2
n

i=1
n

j=1
σiσjSiSjρij
∂2f
∂Si ∂Sj

t
+
n

i=1
∂f
∂Si
σiSiWi
(4.4.17)
where the time interval is now t and the change in derivative value is f .
Let us now consider a portfolio consisting of −1 derivative and ∂f
∂Si units of
the ith underlying stock. In other words we have gone short (that is sold) a
derivative that depends on the price, Si, i = 1, . . . , n, of n underlying assets, and
have ∂f
∂Si units of the ith asset. The value of the portfolio, Π, is therefore:
Π = −f +
n

i=1
∂f
∂Si
Si
(4.4.18)
and the change, Π, in the value of the portfolio over the time interval t is:
Π = −f +
n

i=1
∂f
∂Si
Si
(4.4.19)
Since the stochastic variables Si, i = 1, . . . , n, follow n-dimensional GBM, the
change in the ith asset price, Si, over the time interval t is given by:
Si = μiSit + σiSiWi,
i = 1, . . . , n,
(4.4.20)
where Wi = dZi
√
t,
E

dZ2
i

= 1,
i = 1, . . . , n,
and
E[dZi dZj] = ρi,j,
i = 1, . . . , n, j = 1, . . . , n, i ̸= j
Substituting Eqs. (4.4.17) and (4.4.20) into Eq. (4.4.19), we obtain:
Π = −

∂f
∂t +
n

i=1
μiSi
∂f
∂Si
+ 1
2
n

i=1
n

j=1
σiσjρijSiSj
∂2f
∂Si ∂Sj

t
−
n

i=1
σiSiWi
∂f
∂Si
+
n

i=1
∂f
∂Si
{μiSit + σSiWi}

European options
67
∴Π = −
n

i=1
μiSit ∂f
∂Si
−t ∂f
∂t −1
2t
n

i=1
n

j=1
σiσjρijSiSj
∂2f
∂Si ∂Sj
−
n

i=1
σiSiWi
∂f
∂Si
+
n

i=1
μiSit ∂f
∂Si
+
n

i=1
σiSiWi
∂f
∂Si
(4.4.21)
Cancelling terms we obtain:
Π = −t

∂f
∂t + 1
2
n

i=1
n

j=1
σiσjρijSiSj
∂2f
∂Si ∂Sj

(4.4.22)
If this portfolio is to grow at the riskless interest rate r we have:
rΠt = Π
So from Eq. (4.4.22) we have that:
rΠt = −t

∂f
∂t + 1
2
n

i=1
n

j=1
σiσjρijSiSj
∂2f
∂Si ∂Sj

(4.4.23)
Substituting for Π we obtain:
rt

f −
n

i=1
Si
∂f
∂Si

= −t

∂f
∂t + 1
2
n

i=1
n

j=1
σiσjρijSiSj
∂2f
∂Si ∂Sj

(4.4.24)
Rearranging Eq. (4.4.24) gives:
∂f
∂t +
n

i=1
Si
∂f
∂Si
+ 1
2
n

i=1
n

j=1
σiσjρijSiSj
∂2f
∂Si ∂Sj
= rf
(4.4.25)
which is the n-dimensional Black–Scholes partial differential equation.
4.4.3
The Black–Scholes formula
The Black–Scholes model consists of two assets: the riskless money account and
an equity. It can be cast as the following two-dimensional Ito equation:
dSt = μSt dt + σSt dW P
(4.4.26)
dBt = rBt dt
where W P is Brownian motion (without drift) under measure P, so dW P ∼
N(0, dt).

68
Computational Finance Using C and C#
Current time will be denoted by t0, and the option maturity time by T . The
money market account has value Bt0 = 1 at time t0 and BT = exp(r(T −t0) at
time T .
We will now consider the process followed by the relative value φ(St, Bt) =
St/Bt.
Using the Ito quotient rule as described in Section 2.6.2 and substituting X1 =
St and X2 = Bt in Eq. (2.6.8) we have:
d
 St
Bt

=
 St
Bt

(μ −r) dt +
 St
Bt

σ dW P
So ﬁnally we can write:
dS∗
t = S∗
t (μ −r) dt + S∗
t σ dW P
(4.4.27)
where S∗
t = St/Bt.
Referring to Girsanov’s theorem in Section 2.4, we can choose a probability
measure Q such that:
dW p = dW Q −
μ −r
σ

dt
(4.4.28)
In Eq. (2.4.3) we thus have k(t) = −((μ −r)/σ) and
dQ
dP = exp

−
μ −r
σ

W P −1
2
μ −r
σ
2
t

(4.4.29)
See p. 114 of Musiela (1998). Substituting for dW p in Eq. (4.4.27) yields
dS∗
t = S∗
t {μ −r} dt −S∗
t σ
μ −r
σ

dt + S∗σ dW Q
which simpliﬁes to
dS∗
t = S∗
t σ dW Q
(4.4.30)
Equation (4.4.30) means that the process for S∗
t is a martingale under proba-
bility measure Q.
Replacing dW p in Eq. (4.4.26) with the value in Eq. (4.4.28) yields
dSt = μSt dt + Stσ dW P
= μSt dt + Stσ

dW Q −
μ −r
σ

dt

=

Stμ dt −Stσ
μ −r
σ

dt + Stσ dW Q
So in the risk neutral measure Q the dynamics of dS are
dSt = Str dt + Stσ dW Q
(4.4.31)
Comparing Eq. (4.4.31) with the original Eq. (4.4.26) we see that changing from
the real-world measure to the risk neutral measure simply involves substituting
dW Q for dW P and r for μ.

European options
69
We can now solve Eq. (4.4.31) by using the result given in Eq. (2.3.11). We
have
ST = S exp

ν(T −t0) + σW Q
T −t0

where S is the asset price at current time t0, and ν = r −σ 2/2.
The forward price with maturity T , denoted by S(t0, T ), is E[ST ]. From Ap-
pendix D.2 we have
S(t0, T ) = E[ST ] = S exp

r(T −t0)

(4.4.32)
Using Eq. (2.3.9) the distribution of the asset price at time T is:
log
ST
S

∼N

ν(T −t0), σ 2(T −t0)

(4.4.33)
We want to obtain the current price of a vanilla European option with strike
price E which matures at future time T , and thus has a duration of τ = T −t0.
The approach we will adopt here is to ﬁrst derive an expression for the value
of a European call option, and then use the put/call parity relationships of Sec-
tion 2.2 to obtain the value of the corresponding European put option.
Referring to (4.2.1) we have
Vt0 = Bt0EQ
HT
BT

= Bt0
BT
EQ[HT ]
(4.4.34)
Substituting Bt0 = 1, BT = exp(r(T −t0)) = exp(rτ), and HT = max(ST −E, 0)
we have:
Vt0 =
1
exp(rτ)EQ
max(ST −E, 0)

(4.4.35)
and so denoting the value of the call option by c(S, E, τ) we obtain
c(S, E, τ) = exp(−rτ)EQ
max(ST −E, 0)

(4.4.36)
It can be seen from Eq. (4.4.36) that the value of the European call option is the
expected value of the option’s payoff at maturity, discounted to current time t
by the riskless interest rate r.
This means that the value of the call option can be written as
c(S, E, τ) = exp(−rτ)
 ∞
ST =E
f (ST )(ST −E) dST
(4.4.37)
where f (ST ) is the probability density function of ST .
Instead of integrating over ST we will evaluate (4.4.37) by using the variable
X = log(ST /S). From Eq. (4.4.33), we know that the probability density func-
tion of X is
f (X) =
1
σ√τ
√
2π
exp

−(X −(r −σ 2/2)τ)2
2σ 2τ

(4.4.38)

70
Computational Finance Using C and C#
and therefore the value of the option is
c(S, E, τ) = exp(−rτ)
 ∞
X=log(E/S)

S exp(X) −E

f (X) dX
(4.4.39)
where we have used ST = S exp(X). The lower limit in Eq. (4.4.39) correspond-
ing to ST = E in Eq. (4.4.37) is found by setting E = exp(X); this yields the
lower limit X = log(E/S).
The integral in Eq. (4.4.39) is evaluated by splitting it into the two parts:
c(S, E, τ) = IA −IB
(4.4.40)
where
IA = S exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp(X) exp

−{X −(r −σ 2/2)τ}2
2σ 2τ

dX
(4.4.41)
and
IB = E exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp

−{X −(r −σ 2/2)τ}2
2σ 2τ

E dX
(4.4.42)
To evaluate these integrals we will make use of the fact that the univariate cu-
mulative normal function N1(x) is:
N1(x) =
1
√
2π
 x
u=−∞
exp

−u2
2

du
By symmetry we have N1(−x) = 1 −N1(x) and
1
√
2π
 ∞
x
exp

−u2
2

du =
1
√
2π
 −x
−∞
exp

−u2
2

du = N1(−x)
We will ﬁrst consider IB, which is the easier of the two integrals.
IB = E exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp

−{X −(r −σ 2/2)τ}2
2σ 2τ

dX
If we let u = X−(r−σ 2/2)τ
σ√τ
then dX = σ√τ du. So
IB = E exp(−rτ)σ√τ
σ
√
2π√τ
 ∞
u=k2
exp

−u2
2

du
where the lower integration limit is k2 = log(E/S)−(r−σ 2/2)τ
σ√τ
.
We therefore have:
IB = E exp(−rτ)N1(−k2)
(4.4.43)
We will now consider the integral IA.
IA = S exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp(X) exp

−{X −(r −σ 2/2)τ}2
2σ 2τ

dX

European options
71
Rearranging the integrand:
IA = exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp

−{X −(r −σ 2/2)τ}2 −2σ 2τX
2σ 2τ

dX
(4.4.44)
Expanding the terms in the exponential:

X −

r −σ 2/2

τ
2 −2σ 2τX
= X2 −2

r −σ 2/2

τ

X +

r −σ 2/2

τ
2 −2σ 2τX
= X2 −2

r + σ 2/2

τ

X +

r −σ 2/2

τ
2
=

X −

r + σ 2/2

τ
2 +

r −σ 2/2

τ
2 −

r + σ 2/2

τ
2
Which results in:

X −

r −σ 2/2

τ
2 −2σ 2τX =

X −

r + σ 2/2

τ
2 −2σ 2rτ 2
(4.4.45)
Substituting Eq. (4.4.45) into the integrand of Eq. (4.4.44) we have:
exp(X) exp

−{X −(r −σ 2/2)τ}2
2σ 2τ

= exp(rτ) exp

−{X −(r + σ 2/2)τ}2
2σ 2τ

The integral IA can therefore be expressed as:
IA = S exp(rτ) exp(−rτ)
στ
√
2π
 ∞
X=log(E/S)
exp

−{X −(r + σ 2/2)τ}2
2σ 2τ

dX
If we let u = X−(r+σ 2/2)τ
σ√τ
then dX = σ√τ du. So
IA =
Sσ√τ
σ
√
2π√τ
 ∞
u=k1
exp

−u2
2

du
where the lower limit of integration is k1 =
log(E/S)−(r+σ 2/2)τ
σ√τ
. We therefore
have:
IA = SN1(−k1)
(4.4.46)
Therefore the value of a European call is:
c(S, E, τ) = SN1(−k1) −E exp(−rτ)N1(−k2)
which gives the usual form of the Black–Scholes formula for a European
call as:
c(S, E, τ) = SN1(d1) −E exp(−rτ)N1(d2)
(4.4.47)

72
Computational Finance Using C and C#
where
d1 = log(S/E) + (r + σ 2/2)τ
σ√τ
and
(4.4.48)
d2 = log(S/E) + (r −σ 2/2)τ
σ√τ
= d1 −σ√τ
To gain some insight into the meaning of the above equation, we will rewrite it
in the following form:
c(S, E, τ) = exp(−rτ)

SN1(d1) exp(rτ) −EN1(d2)

(4.4.49)
The term N1(d2) is the probability that the option will be exercised in a risk-
neutral world, so that EN1(d2) is the strike price multiplied by the probability
that the strike price will be paid. The term SN1(d1) exp(rτ) is the expected value
of a variable, in a risk neutral world, that equals ST if ST > E and is otherwise
zero.
The corresponding formula for a put can be shown using put call parity (see
Section 4.3) to be:
p(S, E, τ) = E exp(−rτ)N1(−d2) −SN1(−d1)
(4.4.50)
or equivalently, using N1(−x) = 1 −N1(x) we have
p(S, E, τ) = E exp(−rτ)

1 −N1(d2)

−S

1 −N1(d1)

(4.4.51)
The inclusion of continuous dividends
The effect of dividends on the value of a European option can be dealt with
by assuming that the asset price is the sum of a riskless component involving
known dividends that will be paid during the life of the option, and a risky
(stochastic) component; see Hull (2003).
As continuous dividends q are paid, the stock price is reduced by the same
amount, and by the time the European option matures all the dividends will
have been paid, leaving only the risky component of the asset price.
From Eq. (4.4.26) we thus have:
dS = μS dt −Sq dt + σS dW P
(4.4.52)
dB = rB dt
where under probability measure P we know that dW P ∼N(0, dt).
As before (using Girsanov’s theorem), we choose probability measure Q so
that
dW p = dW Q −
μ −r
σ

dt
and thus under this measure the process for S is
dS = Sμ dt −Sq dt −
μ −r
σ

dt + Sσ dW Q,
where dW Q ∼N(0, dt)

European options
73
which results in
dS = S(r −q) dt + σS dW Q
where dW Q ∼N(0, dt)
(4.4.53)
Proceeding as before we obtain:
X ∼N

r −q −σ 2/2

τ, σ 2τ

where X = ST /S. The probability density function of X is now:
f (X) =
1
σ√τ
√
2π
exp

−(X −(r −q −σ 2/2)τ)2
2σ 2τ

The value of a call option is thus:
c(S, E, τ) = exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)

S exp(X) −E

× exp

−(X −(r −q −σ 2/2)τ)2
2σ 2τ

dX
(4.4.54)
with
IA = S exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp(X) exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

dX
and
IB = E exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

E dX
So IB = E exp(−rτ)N1(−k2), where k2 = log(E/S)−(r−q−σ 2/2)τ
σ√τ
.
We will now consider the integral IA.
IA = S exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp(X) exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

dX
Rearranging the integrand:
IA = exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp

−{X −(r −q −σ 2/2)τ}2 −2σ 2τX
2σ 2τ

dX
Expanding the exponential, we obtain:

X −

r −q −σ 2/2

τ
2 −2σ 2τX
= 2

X −

r −q + σ 2/2

τ
2 −2σ 2(r −q)τ 2
The integral IA can therefore be expressed as:
IA = S exp((r −q)τ) exp(−rτ)
στ
√
2π
×
 ∞
X=log(E/S)
exp

−{X −(r −q + σ 2/2)τ}2
2σ 2τ

dX
which gives IA = S exp(−qτ)N1(−k1) where k1 = log(E/S)−(r−q+σ 2/2)τ
σ√τ
.

74
Computational Finance Using C and C#
The Black–Scholes formula for the value of a European call including contin-
uous dividends is thus:
c(S, E, τ) = S exp(−qτ)N1(d1) −E exp(−rτ)N1(d2)
(4.4.55)
and the corresponding formula for a put can be shown (using put call parity) to
be:
p(S, E, τ) = −S exp(−qτ)N1(−d1) + E exp(−rτ)N1(−d2)
(4.4.56)
or equivalently, using N1(−x) = 1 −N1(x), we have
p(S, E, τ) = E exp(−rτ)

1 −N1(d2)

−S exp(−qτ)

1 −N1(d1)

(4.4.57)
where
d1 = log(S/E) + (r −q + σ 2/2)τ
σ√τ
,
d2 = log(S/E) + (r −q −σ 2/2)τ
σ√τ
Thus European put/call options with continuous dividends can be priced us-
ing Eqs. (4.4.47) and (4.4.50) but with S replaced by S exp(−qτ).
These formulae can also be re-expressed in terms of the current equity for-
ward price with maturity T , S(t, T ), as follows:
ct = exp

−r(T −t)

S(t, T )N1(d1) −EN1(d2)

(4.4.58)
pt = exp

−r(T −t)

−S(t, T )N1(−d1) + EN1(−d2)

(4.4.59)
where we have used the shortened notation pt and ct to denote the current
(time t) value of put and call options; the current equity forward price with
maturity T is
S(t, T ) = S exp

(r −q)(T −t)

,
t ⩽T,
and
d1 = log(S(t, T )/E) + (σ 2/2)τ
σ√(T −t)
,
d2 = log(S(t, T )/E) −(σ 2/2)(T −t)
σ√(T −t)
The inclusion of discrete dividends
Here we consider n discrete cash dividends Di, i = 1, . . . , n, paid at times
ti, i
= 1, . . . , n, during the life of the option. In these circumstances the
Black–Scholes formula can be used to price European options, but with
the current asset value S reduced by the present value of the cash divi-
dends.
This means that instead of S we use the quantity SD which is computed as
SD = S −
n

i=1
Di exp(−rti)

European options
75
where r is the (in this case constant) riskless interest rate. The formulae for
European puts and calls is then
c(S, E, τ) = SDN1(d1) −E exp(−rτ)N1(d2)
(4.4.60)
p(S, E, τ) = E exp(−rτ)

1 −N1(d2)

−SD

1 −N1(d1)

(4.4.61)
where
d1 = log(SD/E) + (r + σ 2/2)τ
σ√τ
and
(4.4.62)
d2 = log(SD/E) + (r −σ 2/2)τ
σ√τ
= d1 −σ√τ
The Greeks
Now that we have derived formulae to price European vanilla puts and calls
it is possible to work out their partial derivatives (hedge statistics). We will
now merely quote expressions for the Greeks (hedge statistics) for European
options. Here the subscript c refers to a European call, and the subscript p
refers to a European put. Complete derivations of these results can be found in
Appendix A.
Gamma:
Γc = ∂2c
∂S2 = Γp = ∂2p
∂S2 = exp(−qτ) n(d1)
Sσ√τ
(4.4.63)
Delta:
Δc = ∂c
∂S = exp(−qτ)N1(d1)
(4.4.64)
Δp = ∂p
∂S = exp(−qτ)

N1(d1) −1

Theta:
Θc = ∂c
∂t = q exp(−qτ)SN1(d1) −rE exp(−rτ)N1(d2)
−Sn(d1)σ exp(−qτ)
2√τ
(4.4.65)
Θp = ∂p
∂t = −q exp(−qτ)SN1(−d1) + rE exp(−rτ)N1(−d2)
−Sn(d1)σ exp(−qτ)
2√τ
Rho:
ρc = ∂c
∂r = EτN1(d2),
ρp = ∂p
∂r = −EτN1(−d2)
(4.4.66)

76
Computational Finance Using C and C#
Vega:
Vc = ∂c
∂σ = Vp = ∂p
∂σ = S exp(−qτ)n(d1)√τ
(4.4.67)
where n(x) =
1
√
2π exp(−x2/2)
We now present, in Code excerpt 4.1, a computer program to calculate the
Black–Scholes option value and Greeks given in Eqs. (4.4.63)–(4.4.67). The rou-
tine uses EPS = 1.0e-16 to identify whether the arguments are too small,
void black_scholes(double *value, double greeks[], double s0, double x,
double sigma, double t, double r, double q, long put, long *iflag)
{
/* Input parameters:
=================
s0 - the current price of the underlying asset
x - the strike price
sigma - the volatility
t - the time to maturity
r - the interest rate
q - the continuous dividend yield
put - if put is 0 then a call option, otherwise a put option
Output parameters:
==================
value - the value of the option
greeks[] - the hedge statistics output as follows: greeks[0] is gamma, greeks[1] is delta
greeks[2] is theta, greeks[3] is rho, and greeks[4] is vega
iflag - an error indicator
*/
double one=1.0,two=2.0,zero=0.0;
double eps,d1,d2,temp,temp1,temp2,pi,np;
if( (x < EPS) || (sigma < EPS) || (t < EPS) ) { /* Check if any of the the input
arguments are too small */
*iflag = 2;
return;
}
temp = log(s0/x);
d1 = temp+(r-q+(sigma*sigma/two))*t;
d1 = d1/(sigma*sqrt(t));
d2 = d1-sigma*sqrt(t);
/* evaluate the option price */
if (put==0)
*value = (s0*exp(-q*t)*cum_norm(d1)- x*exp(-r*t)*cum_norm(d2));
else
*value = (-s0*exp(-q*t)*cum_norm(-d1) + x*exp(-r*t)*cum_norm(-d2));
if (greeks) { /* then calculate the Greeks */
temp1 = -d1*d1/two;
d2 = d1-sigma*sqrt(t);
np = (one/sqrt(two*PI)) * exp(temp1);
if (put==0) { /* a call option */
greeks[1] = (cum_norm(d1))*exp(-q*t); /* delta */
greeks[2] = -s0*exp(-q*t)*np*sigma/(two*sqrt(t))
+ q*s0*cum_norm(d1)*exp(-q*t)- r*x*exp(-r*t)*cum_norm(d2); /* theta */
greeks[3] = x*t*exp(-r*t)*cum_norm(d2); /* rho */
}
else { /* a put option */
greeks[1] = (cum_norm(d1) - one)*exp(-q*t); /* delta */
greeks[2] = -s0*exp(-q*t)*np*sigma/(two*sqrt(t)) -
q*s0*cum_norm(-d1)*exp(-q*t) + r*x*exp(-r*t)*cum_norm(-d2); /* theta */
greeks[3] = -x*t*exp(-r*t)*cum_norm(-d2); /* rho */
}
greeks[0] = np*exp(-q*t)/(s0*sigma*sqrt(t)); /* gamma */
greeks[4] = s0*sqrt(t)*np*exp(-q*t); /* vega */
}
return;
}
Code excerpt 4.1 Function to compute the Black–Scholes value for European options.

European options
77
PI = 3.14159, and also the function cum_norm to compute the cumulative
normal distribution function.
It can be seen in Tables 4.1 and 4.2 that the values for gamma and vega are
the same for both puts and calls. We can also demonstrate that the option values
are consistent by using put call parity.
c(S, E, τ) + E exp(−rτ) = p(S, E, τ) + S exp(−qτ)
For example, when τ = 1.0 we have c(S, E, τ) = 12.952 and P(S, E, T ) =
9.260. So: c(S, E, τ) + E exp(−rτ) = 12.952 + 100 × exp(−0.1) = 103.436 and
p(S, E, τ) + S exp(−qτ) = 9.260 + 100 × exp(−0.06) = 103.436.
Table 4.1 European put option values and Greeks
τ
Value
Delta
Gamma
Theta
Vega
Rho
0.100
3.558
−0.462
0.042
−16.533
12.490
−4.971
0.200
4.879
−0.444
0.029
−10.851
17.487
−9.860
0.300
5.824
−0.431
0.024
−8.298
21.204
−14.663
0.400
6.571
−0.419
0.020
−6.758
24.241
−19.377
0.500
7.191
−0.408
0.018
−5.698
26.832
−24.004
0.600
7.720
−0.399
0.016
−4.909
29.100
−28.544
0.700
8.179
−0.390
0.015
−4.292
31.118
−32.997
0.800
8.582
−0.381
0.014
−3.792
32.935
−37.364
0.900
8.940
−0.373
0.013
−3.377
34.585
−41.646
1.000
9.260
−0.366
0.012
−3.025
36.093
−45.843
The parameters are: S = 100.0, E = 100.0, r = 0.10, σ = 0.30, q = 0.06.
Table 4.2 European call option values and Greeks
τ
Value
Delta
Gamma
Theta
Vega
Rho
0.100
3.955
0.532
0.042
−20.469
12.490
4.929
0.200
5.667
0.544
0.029
−14.724
17.487
9.744
0.300
6.996
0.552
0.024
−12.109
21.204
14.451
0.400
8.121
0.558
0.020
−10.508
24.241
19.054
0.500
9.113
0.562
0.018
−9.387
26.832
23.557
0.600
10.007
0.566
0.016
−8.539
29.100
27.962
0.700
10.826
0.569
0.015
−7.863
31.118
32.271
0.800
11.584
0.572
0.014
−7.305
32.935
36.485
0.900
12.290
0.574
0.013
−6.832
34.585
40.608
1.000
12.952
0.576
0.012
−6.422
36.093
44.640
The parameters are: S = 100.0, E = 100.0, r = 0.10, σ = 0.30, q = 0.06.

78
Computational Finance Using C and C#
4.4.4
Historical and implied volatility
Obtaining the best estimate of the volatility parameter, σ, in the Black–Scholes
formula is of crucial importance. There are many different approaches to volatil-
ity estimation. These include:
• Historical estimation
• Implied volatility
We will now consider both historical and implied volatility estimation.
Historical volatility
In this method we calculate the volatility using n + 1 historical asset prices,
Si, i = 0, . . . , n, and we assume that the asset prices are observed at the regular
time interval, dτ. Since the asset prices are assumed to follow GBM the volatil-
ity is computed as the standard deviation of the n continuously compounded
returns, ui, i = 1, . . . , n, where
Si = Si−1 exp(ui)
or
ui = log
 Si
Si−1

We already know (see Eq. (2.1.10)) that the expected standard deviation of the
asset returns over the time interval is σ
√
dτ. This means that we obtain the
following expression for ˆσ, the estimated volatility:
ˆσ
√
dτ =
'
(
(
)
1
n −1
n

i=1
(ui −¯u)2
(4.4.68)
or
ˆσ =
'
(
(
)
1
(n −1) dτ
n

i=1
(ui −¯u)2
(4.4.69)
It is accepted practice to express all times in years, and so the volatility is the
annualized standard deviation of the returns. There is also the issue of how to
account for non-trading days such as weekends and holidays. For example, let
us suppose that the history of assets prices Si, i = 0, . . . , n, was obtained by
recording the price on each trading day. One approach is to use dτ = 1/Ntd,
where Ntd is the number of trading days in a year. If we take Ntd = 250 then
Eq. (4.4.69) becomes
ˆσ =
'
(
(
)
250
(n −1)
n

i=1
(ui −¯u)2
(4.4.70)

European options
79
void hist_vol(double *sigma, double *err, double data[], long n, double dt, long *ifail)
{
/* Input parameters:
=================
data[]
- the data, which consists of n asset prices
n
- the number of data points
dt
- the (constant) time spacing between the data points (in years)
Output parameters:
==================
sigma
- the computed historical volatility
err
- the standard error in the volatility estimate sigma
iflag
- an error indicator
*/
#define DATA(I) data[(I)-1]
double mean=0.0,sum=0.0;
double temp,tn;
long i;
for(i = 2; i <= n; ++i)
mean = mean + log(DATA(i))-log(DATA(i-1));
mean = mean/(double)(n-1);
for(i = 2; i <= n; ++i) {
temp = log(DATA(i))-log(DATA(i-1));
sum = sum + (temp-mean)*(temp-mean);
}
sum = sum/(double)(n-2);
*sigma = sqrt(sum/dt);
tn = (double)(2*(n-1));
*err = *sigma/sqrt(tn);
return;
}
Code excerpt 4.2 Function to compute the historical volatility from asset data.
The estimated standard error in ˆσ is (see for example Hull (2003)) given by
ˆσstd = ˆσ

1
2(n −1)
(4.4.71)
A computer program to perform these calculations is given in Code excerpt 4.2.
Implied volatility
The implied volatility of a European option is the volatility that, when sub-
stituted into the Black–Scholes equation, yields the market value quoted for the
same option. In general the implied volatility will depend on both the time to ex-
piry of the option and also the ratio of the current asset price to the strike—this
is known as the volatility smile. These values are usually stored in a multidi-
mensional implied volatility surface, and the volatility for pricing a given option
obtained via multidimensional interpolation.
The routine provided in Code excerpt 4.3 uses Newton’s method to calcu-
late the implied volatility for a European option from its market price. We
will now ilustrate this technique for a European call option with market value
opt_value. The implied volatility, σ, is then that value which satisﬁes:
K(σ) = c(S, E, τ, σ) −opt_value = 0
where c(S, E, τ, σ) represents the value of the European call and the other sym-
bols have their usual meaning.

80
Computational Finance Using C and C#
void implied_volatility(double value, double s0, double x, double sigma[],
double t, double r, double q, long put, long *iflag)
{
/* Input parameters:
=================
value
- the current value of the option
s0
- the current price of the underlying asset
x
- the strike price
sigma[]
- the input bounds on the volatility: sigma[0], the lower bound and, sigma[1],
the upper bound
t
- the time to maturity
r
- the interest rate
q
- the continuous dividend yield
put
- if put is 0 then a call option, otherwise a put option
Output parameters:
==================
sigma[]
- the element sigma[0] contains the estimated implied volatility
iflag
- an error indicator
*/
double zero=0.0;
double fx, sig1, sig2;
double val,tolx;
double temp,eps,epsqrt,temp1,v1;
long max_iters, i, ind, ir;
double greeks[5],c[20],sig,vega;
long done;
tolx = eps;
epsqrt = sqrt(EPS);
if(put == 0)
/* a call option */
temp1 = MAX(s0*exp(-q*t)-x*exp(-r*t),zero);
else
/* a put option */
temp1 = MAX(x*exp(-r*t)-s0*exp(-q*t),zero);
v1 = fabs(value-temp1);
if (v1 <= epsqrt) {
/* the volatility is too small */
*iflag = 3;
return;
}
*iflag = 0;
i = 0;
max_iters = 50;
done = 0;
sig = sigma[0];
/* initial estimate */
val = value;
while ((i < max_iters) && (!done)) {
/* Newton iteration */
black_scholes(&val,greeks,s0,x,sig,t,r,q,put,iflag); /* compute the Black-Scholes option
value, val
*/
vega = greeks[4];
/* and vega. */
sig1 = sig - ((val - value)/vega);
/* compute the new estimate of sigma
using Newton’s method */
if (tolx > fabs((sig1 - sig)/sig1)) {
/* check whether the specified
accuracy has been reached */
done = 1;
}
sig = sig1;
/* up date sigma */
++i;
}
sigma[0] = sig1;
/* return the estimate for sigma */
return;
}
Code excerpt 4.3 Function to compute the implied volatility of European options.
From Newton’s method we have:
σi+1 = σi −F(σi)
F ′(σi)
where
F ′(σi) = ∂F
∂σ = ∂c(S, E, τ, σ)
∂σ
= Vc

European options
81
Therefore the iterative procedure is
σi+1 = σi −c(S, E, τ, σ) −opt_value
Vc
where σ0 is the initial estimate, and σi+1 is the improved estimate of the implied
volatility based on the ith estimate σi. Termination of this iteration occurs when
ABS(σi+1 −σi) < tol, for a speciﬁed tolerance, tol.
It can be seen that as σ →0, d1 →∞, d2 →∞and, from Eq. (4.4.67), we
have Vc →0. Under these circumstances Newton’s method fails.
The same procedure can be used to compute the implied volatility for a Eu-
ropean put, in this case we just replace c(S, E, τ, σ) by p(S, E, τ, σ), the value
of a European put; from Eq. (4.4.67) Vc = Vp.
If the implied volatility of American options is required, the procedure is ex-
actly the same. However, instead of using the Black–Scholes formula to compute
both the option value and vega we use a binomial lattice to do this. The use of
binomial lattices to obtain option prices and the Greeks is described in Chap-
ter 5.
Code excerpt 4.4 provides a simple test program which illustrates the use of
the function implied_volatility; the results are presented in Table 4.3.
double X,
value, S, sigma[2], sigmat, T, r, q;
long i, ifail, put;
ifail
= 0;
S
= 10.0;
X
= 10.5;
r
= 0.1;
sigmat = 0.1;
q
= 0.04;
put
= 0;
printf ("
Time
option value
implied
volatility
(Error)\n");
for(i = 1;i < 6; ++i) {
T = (double)i*0.5;
black_scholes(&value,NULL,S,X,sigmat,T,r,q,put,&flag);
sigma[0] = 0.05;
sigma[1] = 1.0;
implied_volatility(value,S,X,sigma,T,r,q,put,&flag);
printf("%8.4f
%15.4f
%15.4f (%8.4e) \n",T,value,sigma[0],
fabs(sigmat-sigma[0]));
sigmat = sigmat + 0.1;
}
Code excerpt 4.4 Simple test program for function implied_volatility.
Table 4.3 Calculated option values and implied volatilities from Code excerpt 4.4
Time (years)
Option value
True σ
Error in estimated σ
0.5
0.1959
0.1
2.7756 × 10−16
1.0
0.8158
0.2
2.2204 × 10−16
1.5
1.5435
0.3
3.8858 × 10−16
2.0
2.3177
0.4
5.5511 × 10−17
2.5
3.1033
0.5
1.1102 × 10−16

82
Computational Finance Using C and C#
4.4.5
Pricing options with Microsoft Excel
In this section we show how the Visual Basic within Excel can be used to create
powerful derivative pricing applications based on the Black–Scholes formula.
We will explain how Excel’s Visual Basic can be used to create an application
that prices a selection of simple European put and call options at the press of a
button.
In Section 4.4.3 we derived the Black–Scholes formula:
c(S, E, τ) = SN1(d1) −e−rτEN1(d2)
and
p(S, E, τ) = −SN1(−d1) + e−rτEN1(−d2)
where
d1 = log(S/E)(r −σ 2/2)τ
σ√τ
= d1 −σ√τ
where S is the current value of the asset and σ is the volatility of the asset, and
N1(x) =
1
√
2π
 x
−∞e−x2/2 dx.
The univariate cumulative standard normal distribution, N1(x), can be eval-
uated in Excel by using its built-in function NORMDIST. The deﬁnition of this
function is as follows:
NORMDIST(x,mean,standard_dev,cumulative)
This function returns the normal cumulative distribution for the speciﬁed mean
and standard deviation.
Function parameters:
x: is the value for which you want the distribution.
mean: is the arithmetic mean of the distribution.
standard_dev: is the standard deviation of the distribution.
cumulative: is a logical value that determines the form of the function. If
cumulative is TRUE, NORMDIST returns the cumulative distri-
bution function; if FALSE, it returns the probability density
function.
If mean = 0 and standard_dev = 1, NORMDIST returns the standard
normal distribution.
This function can be used to create a Visual Basic function to calculate Euro-
pean option values within Excel, see Code excerpt 4.5.
Once the function has been deﬁned, it can be accessed interactively using the
Paste Function facility within Excel as shown in Fig. 4.1.
The function bs_opt can also be incorporated into other Visual Basic
code within Excel. Code excerpt 4.6 deﬁnes the Visual Basic subroutine
MANY_EUROPEANS_Click().

European options
83
Function bs_opt(S0 As Double, _
ByVal X As Double, sigma As Double, T As Double, _
r As Double, q As Double, ByVal putcall As Long) As Double
’ Visual Basic Routine to calculate the value of
’ either a European Put or European Call option.
’ Author: George Levy
Dim temp As Double
Dim d1 As Double
Dim d2 As Double
Dim SQT As Double
Dim value As Double
temp = Log(S0 / X)
d1 = temp + (r - q + (sigma * sigma / 2#)) * T
SQT = Sqr(T)
d1 = d1 / (sigma * SQT)
d2 = d1 - sigma * SQT
If (putcall = 0) Then ’ a call option
value = S0 * Exp(-q * T) * WorksheetFunction.NormDist(d1, 0#, 1#, True) _
- WorksheetFunction.NormDist(d2, 0#, 1#, True) * X * Exp(-r * T)
Else ’ a put option
value = -S0 * Exp(-q * T) * WorksheetFunction.NormDist(-d1, 0#, 1#, True) + _
X * WorksheetFunction.NormDist(-d2, 0#, 1#, True) * Exp(-r * T)
End If
bs_opt = value
End Function
Code excerpt 4.5 Visual Basic code to price European options using the Black–Scholes
formula.
Figure 4.1 Using the function bs_opt interactively within Excel. Here a call option is
processed with the following parameters: S = 10.0, X = 9.0, q = 0.0, T = 1.5, r = 0.1,
and σ = 0.2.

84
Computational Finance Using C and C#
Private Sub MANY_EUROPEANS_Click()
Dim i As Long
Dim putcall As Long
Dim S0 As Double
Dim q As Double
Dim sigma As Double
Dim T As Double
Dim r As Double
q = 0#
T = 1.5
r = 0.1
sigma = 0.2
For i = 1 To 22
S0 = Sheet1.Cells(i + 1, 1).value
X = Sheet1.Cells(i + 1, 2).value
putcall = Sheet1.Cells(i + 1, 3).value
Sheet1.Cells(i + 1, 4).value = bs_opt(S0, X, sigma, T, r, q, putcall)
Next i
End Sub
Code excerpt 4.6 Visual Basic code that uses the function bs_opt.
Figure 4.2 Excel worksheet before calculation of the European option values.
When the button labelled “CALCULATE OPTIONS” is clicked, the values
of 22 European options will be calculated using the data in columns 1–3 on
worksheet 1, see Figs. 4.2 and 4.3.

European options
85
Figure 4.3 Excel worksheet after calculation of the European option values.
The cumulative standard normal distribution can also be used to provide an-
alytic solutions for a range of other exotic options such as: Barrier options,
Exchange options, Lookback options, Binary options, etc.
4.5
Barrier options
4.5.1
Introduction
Barrier options are derivatives where the payoff depends on whether the asset
price reaches a given barrier level, B. Knockout options become worthless (cease
to exist) if the asset price reaches the barrier, whereas knockin options come into
existence when the asset price hits the barrier. We will consider the following
single asset European barrier options:
• Down and out call: A knockout vanilla call option, value cdo, which ceases
to exist when the asset price reaches or goes below the barrier level.
• Up and out call: A knockout vanilla call option, value cuo, which ceases to
exist when the asset price reaches, or goes above the barrier level.
• Down and in call: A knockin vanilla call option, value cdi, which comes
into existence when the asset prices reaches or goes below the barrier
level.

86
Computational Finance Using C and C#
• Up and in call: A knockin vanilla call option, value cui, which comes
into existence when the asset price reaches or goes above the barrier
level.
The following expressions must be true:
c = cuo + cui
(4.5.1)
c = cdo + cdi
(4.5.2)
where c is the value of a vanilla call option. We thus need only derive expressions
for both the knockout options, and then use the above equations to calculate
the value of the corresponding knockin options.
The notation that we will use is as follows: The symbol t represents the cur-
rent time, T represents the time at which the option matures, and τ = T −t,
the duration of the option. The symbol s, with constraint t ⩽s ⩽T , is any
intermediate time during which the option is alive.
4.5.2
Analytic pricing of down and out call options
If we consider Brownian motion (with zero drift) Xs
∼N(0, (s −t)σ 2),
t ⩽s ⩽
T , which starts at Xt = 0 and, after time τ = T −t, ends at the
point XT = X then (for example, see Freedman, 1983) the probability density
function for this motion not to exceed the value X = b (where b > 0) during
time τ is given by:
f

b ⩾Xmax
s
, X

= Ω

2
π exp
2b(X −b)
σ 2τ

exp

−X2
2σ 2τ

(4.5.3)
where for convenience we have used Ω = (2b −X)/(σ 3τ 3/2), and Xmax
s
=
max(Xs, t ⩽s ⩽T ). Since Xs is Brownian motion without drift and volatility σ,
then −Xs is identical Brownian motion. Therefore by substituting X →−X, and
b →−b in the above equation we obtain:
f

b ⩽Xmin
s
, X

= −Ω

2
π exp
2b(X −b)
σ 2τ

exp

−X2
2σ 2τ

(4.5.4)
where we have used Xmin
s
= min(Xs, t ⩽s ⩽T ). Equation (4.5.4) is the prob-
ability density function of −Xs staying above the value X = b, where b < 0.
These results can be generalized to include drift (Musiela and Rutkowski, 1998,
p. 212), so that Xs ∼N((r −q −σ 2/2)(s −t), σ(s −t)), for t ⩽s ⩽T . We now
have the following results:
f

b ⩾Xmax
s
, X

= Ω

2
π exp
2b(X −b)
σ 2τ

exp

−(X −(r −q −σ 2/2)τ)2
2σ 2τ

(4.5.5)

European options
87
f

b ⩽Xmin
s
, X

= −Ω

2
π exp
2b(X −b)
σ 2τ

exp

−(X −(r −q −σ 2/2)τ)2
2σ 2τ

(4.5.6)
where r is the risk free rate and q is the continuous dividend yield. A European
down and out barrier option with maturity τ and a barrier at X = B will cease
to exist (become worthless) if at any time Xs ⩽B, for t ⩽s ⩽T . The probability
density function that the barrier option will continue to exist at time T if the
end point is X is therefore:
f (X > B) = −

2
π
 b=X
B=S exp(b)
Ω exp
2b(X −b)
σ 2τ

× exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

db
(4.5.7)
or
f (X > B) = −

2
π exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

×
 b=X
b=log(B/S)
Ω exp
2b(X −b)
σ 2τ

db
(4.5.8)
where we have integrated over all possible values of b (i.e., B < b < X) that
keep the option alive. Recalling that:
−
 b=X
b=log(B/S)
Ω exp
2b(X −b)
σ 2τ

db
=
 b=X
b=log(B/S)
(X −2b)
σ 3τ 3/2
exp
2b(X −b)
σ 2τ

db
and noting that:
∂
∂b exp
2b(X −b)
σ 2τ

= 2(X −2b)
σ 2τ
exp
2b(X −b)
σ 2τ

we have:
 b=X
b=log(B/S)
2(X −2b)
σ 2τ
exp
2b(X −b)
σ 2τ

db
= exp
2b(X −b)
σ 2τ
b=X
b=log(B/S)
= 1 −exp
2 log(B/S)(X −log(B/S))
σ 2τ

So we have:
f (X > B) =
1
σ√τ
√
2π
exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

×

1 −exp
2 log(B/S)(X −log(B/S)
σ 2τ


88
Computational Finance Using C and C#
The value cdo of a European down and out call option with strike E, satisfying
E > B, is given by:
cdo = exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)

S exp(X) −E

f (X > B) dX
(4.5.9)
This integral is evaluated in Appendix B.1, and the value of the down and out
call option cdo is:
cdo = c −cdi
(4.5.10)
where
c = S exp(−qτ)N1(d1) −E exp(−rτ)N1(d2)
cdi = S exp(−qτ)N1(d4)
B
S
 2(r−q)
σ2
+1
−E exp(−rτ)N1(d3)
B
S
 2(r−q)
σ2
−1
d1 = log(S/E) + (r −q + σ 2/2)τ
σ√τ
d2 = log(S/E) + (r −q −σ 2/2)τ
σ√τ
d3 = log(B2/SE) + (r −q −σ 2/2)τ
σ√τ
and
d4 = log(B2/ES) + (r −q + σ 2/2)τ
σ√τ
In Code excerpt 4.7 we provide the function bs_opt_barrier_downout_
call which uses Eq. (4.5.10) to price a down and out European call option.
This routine will be used in Chapter 5 to measure the accuracy achieved by
using various ﬁnite-difference grid techniques to solve the Black–Scholes equa-
tion.
4.5.3
Analytic pricing of up and out call options
Here we will obtain an expression for an up and out European call option with
continuous dividend yield q, in a similar manner to that used in Section 4.5.2 for
the down and out European call option. A European up and out barrier option
with maturity τ and a barrier at X = B will cease to exist (become worthless)
if at any time Xs ⩾B, for t ⩽s ⩽T . The probability density function that the
barrier option will continue to exist at time T if the end point is X is therefore:
f (X < B) =

2
π
 B=S exp(b)
b=X
Ω exp
2b(X −b)
σ 2t

× exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

db
(4.5.11)

European options
89
void bs_opt_barrier_downout_call(double *value, double barrier_level,
double s0, double x, double sigma, double t, double r,
double q, long *iflag)
{
/* Input parameters:
=================
barrier_level
- the level of the barrier
s0
- the current price of the underlying asset
x
- the strike price
sigma
- the volatility
t
- the time to maturity
r
- the risk free interest rate
q
- the dividend yield
Output parameters:
==================
value
- the value of the option
iflag
- an error indicator
*/
double one=1.0,two=2.0,zero=0.0;
double temp,temp1,temp2,a,b,d1,d2,d3,d4,d5,d6,d7,d8;
double fac;
if(x < EPS) { /* then strike price (X) is too small */
*iflag = 2;
return;
}
if (sigma < EPS) { /* then volatility (sigma) is too small */
*iflag = 3;
return;
}
if (t < EPS) { /* then time to expiry (t) is too small */
*ifail = 3;
return;
}
if (barrier_level <= 0) {
/* barrier level must be greater than zero */
*iflag = 4;
}
if (s0 <= barrier_level) { /* option has already been knocked out */
*value = 0.0;
return;
}
fac = sigma*sqrt(t);
temp1 = -one+(two*(r-q)/(sigma*sigma));
temp2 = barrier_level/s0;
a = pow(temp2,temp1);
temp1 = one+(two*(r-q)/(sigma*sigma));
b = pow(temp2,temp1);
if (x > barrier_level) {
/* strike > barrier_level */
d1 = (log(s0/x)+(r-q+0.5*sigma*sigma)*t)/fac;
d2 = (log(s0/x)+(r-q-0.5*sigma*sigma)*t)/fac;
temp = (s0*x)/(barrier_level*barrier_level);
d7 = (log(temp)-(r-q-0.5*sigma*sigma)*t)/fac;
d8 = (log(temp)-(r-q+0.5*sigma*sigma)*t)/fac;
temp1 = s0*exp(-q*t)*(cum_norm(d1)-b*(one-cum_norm(d8)));
temp2 = x*exp(-r*t)*(cum_norm(d2)-a*(one-cum_norm(d7)));
*value = temp1-temp2;
}
else { /* strike <= barrier_level */
d3 = (log(s0/barrier_level)+(r-q-0.5*sigma*sigma)*t)/fac;
d6 = (log(s0/barrier_level)-(r-q-0.5*sigma*sigma)*t)/fac;
d4 = (log(s0/barrier_level)+(r-q+0.5*sigma*sigma)*t)/fac;
d5 = (log(s0/barrier_level)-(r-q+0.5*sigma*sigma)*t)/fac;
temp1 = s0*exp(-q*t)*(cum_norm(d3)-b*(one-cum_norm(d6)));
temp2 = x*exp(-r*t)*(cum_norm(d4)-a*(one-cum_norm(d5)));
*value = temp1-temp2;
}
return;
}
Code excerpt 4.7 Function to compute the value for European down and out call op-
tions.

90
Computational Finance Using C and C#
or
f (X < B) =

2
π exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

×
 b=log(B/S)
b=X
Ω exp
2b(X −b)
σ 2τ

db
(4.5.12)
where, as in Section 4.5.2, we have used Ω = (2b−X)
σ 3τ 3/2 and have integrated over
all possible values of b (i.e., B > b > X) that keep the option alive. Recalling
that:
 b=log(B/S)
b=X
Ω exp
2b(X −b)
σ 2τ

db
=
 b=log(B/S)
b=X
(2b −X)
σ 3τ 3/2
exp
2b(X −b)
σ 2τ

db
and noting:
−∂
∂b exp
2b(X −b)
σ 2τ

= 2(X −2b)
σ 2τ
exp
2b(X −b)
σ 2τ

(4.5.13)
we have:
 b=log(B/S)
b=X
2(2b −X)
σ 2τ
exp
2b(X −b)
σ 2τ

db
= −exp
2b(X −b)
σ 2τ
b=log(B/S)
b=X
=

1 −exp
2 log(B/S)(X −log(B/S))
σ 2τ

Therefore:
f (X < B) =
1
σ√τ
√
2π

2
π exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

×

1 −exp
2 log(B/S)(X −log(B/S))
σ 2τ

(4.5.14)
We will now derive the formula for an up and out call option when E < B.
In fact if E > B then the option is worthless, since at the current time t the
call option’s payout, max(St −E, 0) = 0, and if St > E then the option will be
knocked out.
cuo = exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)

S exp(X) −E

f (X < B) dX
(4.5.15)
Taking into account the fact the option becomes worthless when S exp(X) > B,
(i.e., X > log(B/S)) we have:
cuo = exp(−rτ)
σ√τ
√
2π
 log(B/S)
X=log(E/S)

S exp(X) −E

f (X < B) dX
(4.5.16)

European options
91
This integral is evaluated in Appendix B.2, and the value of the down and out
call option cuo is:
cuo = c −cui
where c is the value of a vanilla call and cui, the value of an up and in call, is
given by:
cui = S exp(−qτ)N1(d2) −E exp(−rτ)N1(d4)
−E exp(−rτ)

N1(d5) −N1(d6)
B
S
 2(r−q)
σ2
−1
+ S exp(−rτ)

N1(d7) −N1(d8)
B
S
 2(r−q)
σ2
+1
(4.5.17)
and
d1 = log(S/E) + (r −q + σ 2/2)τ
σ√τ
d2 = log(S/B) + (r −q + σ 2/2)τ
√τ
d3 = log(S/E) + (r −q −σ 2/2)τ
σ√τ
d4 = log(S/B) + (r −q −σ 2/2)τ
σ√τ
d5 = log(B2/ES) −(r −q −σ 2/2)τ
σ√τ
d6 = log(B/S) + (r −q −σ 2/2)τ
σ√τ
d7 = log(B2/ES) + (r −q + σ 2/2)τ
σ√τ
d8 = log(B/S) + (r −q + σ 2/2)τ
σ√τ
4.5.4
Monte Carlo pricing of down and out options
In this section we show how Monte Carlo simulation can be used to price
down and out barrier options. We will describe both a basic Monte Carlo ap-
proach and also a Brownian bridge method which gives more accurate results
(see Chapter 8).
The asset price, S, will be assumed to be GBM, so the logarithm of the asset
price X follows the Brownian process:
X = νt + σWt
(4.5.18)
where ν is the drift and σ is the volatility.

92
Computational Finance Using C and C#
If the barrier level is B then the option will be knocked out when S ⩽B,
or equivalently log(S) ⩽log(B). This will be expressed as X ⩽b, where b =
log(B).
The basic approach to simulating the down and out option is to ﬁrst de-
cide how many Scenarios to use and also how many TimeSteps there
are to be in each scenario. The size of each time step is then time_step =
TimeToExpiry/TimeSteps. For each scenario the path of Xt is advanced
in time from t to t + t using Eq. (4.5.18), with dt =
time_step and a
value for Wt output from a Gaussian random number generator. Path con-
struction is stopped if either the option expiry time is reached or if the option
is knocked out—i.e., X ⩽b. When the option is knocked out before expiry
the payoff for that scenario is zero. We will denote the option value obtained
from the ith scenario by DOi where i = 1, . . . , Scenarios. The option value
is the average value of DOi over all scenarios; for more details see Code ex-
cerpt 4.8.
One problem with this approach to simulation is that it does not take into
account the possibility that Xτ ⩽b, t < τ < t + t, even though Xt > b and
Xt+t > b. In these circumstances the option should be treated as knocked out,
since X hit (or crossed) the barrier b at time τ, but then increased to the value
Xt+t > b at time t + t.
We will now discuss how the Brownian bridge method deals with this situa-
tion.
Let us take two consecutive time points t1 and t2 = t1 + t, and assume that
both Xt1, and Xt2 are above the (logarithmic) barrier level b. We want to ﬁnd the
probability that in the time interval [t1, t2], the asset price went lower than B,
and use this to get more accurate values for down and out options. The required
barrier crossing probability is thus:
P

mX
t1,t2 ⩽b|{Xt2, Xt1}

where mX
t1,t2 denotes the minimum of X over the time interval [t1, t2].
The probability density of Xt2 conditional on Xt1 is
p(Xt2|Xt1) =
1
σ
√
2πt
exp

−(Xt2 −Xt1 −νt)2
2σ 2t

where t = t2 −t1.
From Bayes law we know that:
P

mX
t1,t2 ⩽b|{Xt2, Xt1}

= p({mX ⩽b, Xt2}|Xt1)
p(Xt2|Xt1)
We show in Appendix I that
p

mX
t1,t2 ⩽b, Xt2

|Xt1

=
1
σ
√
2πt
exp
2ν(b −Xt1)
σ 2

exp

−(Xt2 + Xt1 −2b −νt)2
2σ 2t


European options
93
so
P

mX
t1,t2 ⩽b|{Xt2, Xt1}

= exp
2ν(b −Xt1)
σ 2

× exp

−−(Xt2 + Xt1 −2b −νt)2 + (Xt2 −Xt1 −νt)2
2σ 2t

We will now use some algebra to simplify this expression.
P

mX
t1,t2 ⩽b|{Xt2, Xt1}

= exp
4νt(b −Xt1) −(Xt2 + Xt1 −2b −νt)2 + (Xt2 −Xt1 −νt)2
2σ 2t

= exp

4νt(b −Xt1) −

(Xt2 −Xt1 −νt) −2(b −Xt1)
2
+ (Xt2 −Xt1 −νt)2
/

2σ 2t

= exp
4νt(b −Xt1) + 4(b −Xt1)(Xt2 −Xt1 −νt) + 4(b −Xt1)2
2σ 2t

= exp

−2(b −Xt1)(b −Xt2)
σ 2t

which ﬁnally yields
P

mlog(S)
t1,t2
⩽b|

log(St2), log(St1)

= exp

−2(log(B) −log(St1))(log(B) −log(St2))
σ 2t

(4.5.19)
Equation (4.5.19) gives the probability of the option having been knocked out
between times t1 and t2 even though the asset prices St1 and St2 are greater
than B. The probability that the option hasn’t been knocked out between times
t1 and t2 is therefore
P

mlog(S)
t1,t2
> b|

log(St2), log(St1)

= 1 −exp

−2(log(B) −log(St1))(log(B) −log(St2))
σ 2t

(4.5.20)
This means that for the (complete) ith scenario path, of n time steps, the prob-
ability that mlog(S) > b is
BBi
c =
n−1

j=0

1 −exp

−
2(log(B) −log(Si
tj ))(log(B) −log(Si
tj+1))
σ 2t

where Si
tj is the ith scenario asset price at time tj.
The basic Monte Carlo ith scenario option value DOi can therefore be ad-
justed as follows
DO∗
i = DOi BBi
c

94
Computational Finance Using C and C#
and the new Monte Carlo estimate DO∗is
DO∗=

Scenarios
i=1
DO∗
i
Scenarios
where more details can be found in Code excerpt 4.8.
private double MonteCarloSim(bool is_put)
{
int seed = 111;
double[] asset_path = new double[fTimeSteps];
double time_step = fTimeToExpiry / fTimeSteps;
double sqrt_time_step = System.Math.Sqrt(time_step);
double disc = System.Math.Exp(-fRiskFreeRate * fTimeToExpiry);
set_seed(seed);
double opt_val = 0.0;
bool not_out = true;
int k = 0;
double STN = 0.0;
double mean = (fRiskFreeRate - fDividendYield - fSigma1 * fSigma1 * 0.5) * time_step;
double std = System.Math.Sqrt(fSigma1 * fSigma1 * time_step);
double z;
double sum_opt_vals = 0.0;
for (int i = 0; i < fNumberScenarios; ++i)
{
// generate the asset path
double ST1 = fS1;
not_out = true;
k = 0;
while (not_out && k < fTimeSteps)
{
z = RndNorm(mean, std);
STN = ST1 * System.Math.Exp(z);
if (STN < fBarrierLevel) not_out = false;
ST1 = STN;
asset_path[k] = STN;
++k;
}
if (is_put)
{
opt_val = System.Math.Max(fStrike - STN, 0.0);
}
else
{
opt_val = System.Math.Max(STN - fStrike, 0.0);
}
if (not_out)
{ // only has value if asset value is above the barrier_level
// compute the probability that the asset remained above the barrier
if (UseBrownianBridge)
{
double total_probability_above = 1.0, pr;
double sigma_2 = fSigma1 * fSigma1;
double log_barrier_level = System.Math.Log(fBarrierLevel);
double fac;
for (int jj = 0; jj < fTimeSteps - 1; ++jj)
{
double log_S_i = System.Math.Log(asset_path[jj]);
double log_S_i1 = System.Math.Log(asset_path[jj + 1]);
fac = 2.0 * (log_barrier_level - log_S_i)
* (log_barrier_level - log_S_i1) / (sigma_2 * time_step);
pr = (1.0 - System.Math.Exp(-fac)); // probability of staying above the
barrier between i and i+1
total_probability_above *= pr;
Code excerpt 4.8 An example of using the Brownian bridge barrier crossing probability
to enhance the pricing of a European down and out option.

European options
95
}
sum_opt_vals += total_probability_above * opt_val * disc;
}
else
{ // don’t use the Brownian Bridge
sum_opt_vals += opt_val * disc;
}
}
}
double temp = sum_opt_vals / (double)fNumberScenarios;
return temp;
}
Code excerpt 4.8 (Continued).

blank
left
intentionally
page
This

5 Single asset American options
5.1
Introduction
In Chapter 4 we discussed single asset European options and the analytic for-
mulae that can be used to price them. Here we will consider the valuation of
single asset American-style options using both numeric methods and analytic
formulae; in addition we will discuss the use of numerical techniques to value
certain European options. The coverage in this chapter is as follows:
• Analytic approximation techniques for the valuation of American options
• Binomial lattice techniques used for the valuation of American and European
options
• The valuation of American and European vanilla and barrier options using
ﬁnite-difference grids
• The valuation of American options via Monte Carlo simulation.
It should be mentioned that although much of the discussion here concerns the
valuation of vanilla European and American puts and calls, the techniques used
can be modiﬁed without much difﬁculty to include more exotic options with
customized payoffs and early exercise features.
5.2
Approximations for vanilla American options
5.2.1
American call options with cash dividends
In this section we will consider the valuation of vanilla American call options
with cash dividends and discuss the methods of Roll, Geske, Whaley and Black.
We will ﬁrst consider the Roll–Geske–Whaley method.
The Roll–Geske–Whaley approximation
This method uses the work of Roll (1977), Geske (1979), and Whaley (1981).
Let S be the current (time t) price of an asset which pays a single cash dividend
D1 at time t1. At the ex-dividend date, t1, there will be a decrease in the asset’s
value from St1 to St1 −D1. Also the current asset price net of escrowed dividends
is:
SD = S −D1 exp

−r(t1 −t)

(5.2.1)

98
Computational Finance Using C and C#
where r is the riskless interest rate.
Now consider an American call option, with strike price E and expiry time T ,
which is taken out on this asset. At t1 there will be a given ex-dividend asset
price, S∗, above which the option will be exercised early. This value can be
found by solving the following equation:
c

S∗, E, τ1

= S∗+ D1 −E
(5.2.2)
where c(S∗, E, τ1) is the Black–Scholes value of a European call option with
strike price E and maturity τ1 = T −t1, on an asset with current value S∗at
time t1. If just prior to the ex-dividend date St1 > S∗then the American option
will be exercised and realize a cash payoff of St1 + D1 −E. On the other hand
if St1 ⩽S∗then the option is worth more unexercised and it will be held until
option maturity at time T .
We can rewrite Eq. (5.2.2) so that S∗is the root of the following equation:
K

S∗
= c

S∗, E, τ1

−S∗−D1 + E = 0
(5.2.3)
where K(S∗) denotes the function in the single variable S∗.
A well-known technique for solving Eq. (5.2.3) is Newton’s method, which
in this case takes the form:
S∗
i+1 = S∗
i −K(S∗
i )
K′(Si)∗
(5.2.4)
where S∗
i is the ith approximation to S∗and S∗
i+1 is the improved (i + 1)th
approximation.
If we now consider the terms in Eq. (5.2.4) we have from Eqs. (5.2.2) and
(5.2.3) that
K

S∗
i

= c

S∗
i , E, τ1

−S∗
i −D1 + E
and
K′
S∗
i

= ∂K(S∗
i )
∂S∗
i
= ∂c(S∗
i , E, τ1)
∂S∗
i
−1
Also from Eq. (A.3.2) in Appendix A.3:
∂c(S∗
i , E, τ1)
∂S∗
i
= N1

d1

S∗
i

we note that here the continuous dividend yield q = 0.
So
K′
S∗
i

= ∂K(S∗
i )
∂S∗
i
= N1

d1

S∗
i

−1
where d1 = log(S∗
i /E) + (r + σ 2/2)τ1
σ√T −t1
Substituting these results into Eq. (5.2.4) gives:
S∗
i+1 = S∗
i −c(S∗
i , E, τ1) −(S∗
i + D1 −E)
N1(d1(S∗
i )) −1

Single asset American options
99
On rearrangement this yields:
S∗
i+1 = S∗
i N1(d1(S∗
i )) −c(S∗
i , E, τ1) + D1 −E
N1(d1(S∗
i )) −1
for i = 0, . . . , max_iter
(5.2.5)
where a convenient initial approximation is to choose S∗
0 = E, and max_iter
is the maximum number of iterations that are to be used.
We will now quote the Roll, Geske, and Whaley formula for the current value
of an American call which pays a single cash dividend D1 at time t1; it is:
C(S, E, τ)
= SD

N1(b1) + N2

a1, −b1,

t1 −t
τ

+ D1 exp

−r(t1 −t)

N1(b2)
−E exp(−rτ)

N1(b2) exp(rτ1) + N2

a2, −b2, −

t1 −t
τ

(5.2.6)
where SD is given by Eq. (5.2.1), E is the exercise price, T is the option ex-
piry date, t represents the current time, τ is the option maturity, N1(a) is the
univariate cumulative normal density function with upper intergral limit a, and
N2(a, b, ρ) is the bivariate cumulative normal density function with upper inte-
gral limits a and b and correlation coefﬁcient ρ. The other symbols used in Eq.
(5.2.6) are deﬁned as
a1 = log(S/E) + (r + σ 2/2)τ
σ√τ
,
a2 = a1 −σ√τ
b2 = log(S/S∗) + (r + σ 2/2)(t1 −t)
σ√t1 −t
,
b2 = b1 −σ√t1 −t
and S is the current (time t) asset price, S∗is found using Eq. (5.2.5), r is the
riskless interest rate, σ is the asset’s volatility, τ = T −t and τ1 = T −t1.
To compute the value of an American call option which pays n cash dividends
Di, i = 1, . . . , n, at times ti, i = 1, . . . , n, we can use the fact that optimal exer-
cise normally only ever occurs at the ﬁnal ex-dividend date tn; see for example
Hull (2003). Under these circumstances Eq. (5.2.6) can still be shown to value
the American call but now t1 should be set to tn, D1 should be set to Dn, and SD
is given by:
SD = S −
n

i=1
Di exp

−r(ti −t)

(5.2.7)
A program to compute the Roll–Geske–Whaley approximation for an American
call option with multiple cash dividends is given in Code excerpt 5.1. Here the
functions cum_norm and cum_norm2 are used to calculate the values of N1(a)
and N2(a, b, ρ), respectively. Code excerpt 5.3 was used to compute the values

100
Computational Finance Using C and C#
void RGW_approx(double *opt_value, double *critical_value, long n_divs, double dividends[],_
double Divs_T[],
double S0, double X, double sigma, double T, double r, long *iflag)
{
/* Input parameters:
=================
n_divs
- the number of dividends
dividends[]
- the dividends: dividends[0] contains the first dividend, dividend[1]
the second etc.
Divs_T[]
- the times at which the dividends are paid: Divs_T[0] is the time at which_
the first dividend is paid
Divs_T[1] is the time at which the second dividend is paid, etc.
S0
- the current value of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
Output parameters:
==================
opt_value
- the value of the option
critical_value - the critical value
iflag
- an error indicator
*/
double A_1,A_2,S_star,a1,a2,nt1,t1,S;
double b1,b2,d1,alpha,h,div,beta,temp,temp1,temp2,temp3;
double pdf,b,eur_val,fac,tol,loc_q,err,zero=0.0;
long iterate;
long i,iflagx,putx;
loc_q = 0.0;
temp = 0.0;
for (i=0; i < n_divs; ++i) { /Check the Divs_T array */
if ((Divs_T[i] <= temp) || (Divs_T[i] > T) || (Divs_T[i] <= zero)) {
*flag = 2;
return;
}
temp = Divs_T[i];
}
/* calculate the present value of the dividends (excluding the final one) */
temp = 0.0;
for (i=0; i < n_divs-1; ++i) {
temp = fac + dividends[i] * exp(-r*Divs_T[i]);
}
t1 = Divs_T[n_divs-1];
/* decrease the stock price by the present value of all dividends */
div = dividends[n_divs-1];
S = S0-temp-div*exp(-r*t1);
iterate = 1;
tol = 0.000001;
S_star = X;
while (iterate) {
/* calculate S_star, iteratively */
/* calculate the Black-Scholes value of a European call */
d1 = (log(S_star/X) + (r+(sigma*sigma/2.0))*(T-t1))/(sigma*sqrt(T-t1));
putx = 0;
loc_q = 0.0;
black_scholes(&eur_val,NULL,S_star,X,sigma,T-t1,r,loc_q,putx,&iflag);
S_star = (S_star*cum_norm(d1)-eur_val+div-X)/(cum_norm(d1)-1.0);
err = fabs(eur_val - (S_star + div- X))/X;
if (err < tol) iterate = 0;
}
a1 = (log(S/X) + (r+(sigma*sigma/2.0))*T)/(sigma*sqrt(T));
a2 = a1 - sigma*sqrt(T);
b1 = (log(S/S_star)+(r+(sigma*sigma/2.0))*t1)/(sigma*sqrt(t1));
b2 = b1 - sigma*sqrt(t1);
nt1 = sqrt(t1/T);
temp1 = S*(cum_norm(b1)+cum_norm2(a1,-b1,-nt1,&iflagx));
temp2 = -X*exp(-r*T)*cum_norm2(a2,-b2,-nt1,&iflagx)-(X-div)*exp(-r*t1)*cum_norm(b2);
*opt_value = temp1+temp2;
*critical_value = S_star;
}
Code excerpt 5.1 Function to compute the Roll–Geske–Whaley approximation for the
value of an American call option with discrete dividends.

Single asset American options
101
Table 5.1 A comparison of the computed values for American call options with
dividends, using the Roll–Geske–Whaley approximation and the Black approximation
Stock price
Critical price, S∗
RGW approximation
Black approximation
80.0
123.582
3.212
3.208
85.0
123.582
4.818
4.808
90.0
123.582
6.839
6.820
95.0
123.582
9.276
9.239
100.0
123.582
12.111
12.048
105.0
123.582
15.316
15.215
110.0
123.582
18.851
18.703
115.0
123.582
22.676
22.470
120.0
123.582
26.748
26.476
The parameters used were: E = 100.0, r = 0.04, σ = 0.2, τ = 2.0, and there is one cash
dividend of value 5.0 at time t = 1.0. The current stock price, S, is varied from 80.0 to
120.0. The results are in agreement with those given in Table 1 of Whaley (1981).
presented in Table 5.1. These compare the Roll–Geske–Whaley approximation
with the Black approximation, which we will now brieﬂy discuss.
We will now consider the Black approximation.
The Black approximation
The Black (1973) approximation for an American call with cash dividends is
simpler than the Roll–Geske–Whaley method we have just described. For an
American call option which expires at time T , with n discrete cash dividends
Di, i = 1, . . . , n, at times ti, i = 1, . . . , n, it involves calculating the prices of
European options that mature at times T , and tn, and then setting the option
price to the greater of these two values, see for example Hull (2003).
The Black approximation, CBL, can be expressed more concisely in terms of
our previously deﬁned notation as:
CBL(S, E, τ) = max(v1, v2)
where v1 and v2 are the following European calls:
v1 = c(SD, E, τ)
and
v2 = c

S+
D, E, τ1

,
τ = T −t, τ1 = T −tn
and
SD = S −
n

i=1
Di
and
S+
D = S −
n−1

i=1
Di
Code excerpt 5.2 computes the Black approximation.
Code excerpt 5.3 uses the same values as in Whaley (1981) and compares the
Roll–Geske–Whaley approximation with that of Black; the results are presented
in Table 5.1.

102
Computational Finance Using C and C#
void black_approx(double *value, long n_divs, double dividends[], double Divs_T[],
double S0, double X, double sigma, double T, double r, long put, long *ifail)
{
/* Input parameters:
=================
n_divs
- the number of dividends
dividends[] - the dividends, dividends[0] contains the first dividend, dividend[1] the_
second etc.
Divs_T[]
- the times at which the dividends are paid, Divs_T[0] is the time at which_
the first dividend is paid
Divs_T[1] is the time at which the second dividend is paid, etc.
S0
- the current value of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
put
- if put is 0 then a call option, otherwise a put option
Output parameters:
==================
value
- the value of the option, iflag - an error indicator
*/
double zero = 0.0;
double beta,temp,temp1,temp2,temp3;
double tn,val_T,val_tn,tol,loc_q,err,fac;
long i,ifailx;
loc_q = 0.0;
temp = 0.0;
for (i=0; i < n_divs; ++i) {
if (Divs_T[i] <= temp ) printf ("Error in Divs_T array, elements not increasing \n");
if (Divs_T[i] > T) printf ("Error in Divs_T array element has a value greater than T \n");
if (Divs_T[i] <= zero) printf ("Error in Divs_T array element <= zero \n");
temp = Divs_T[i];
}
/* calculate the present value of the dividends */
fac = 0.0;
for (i=0; i < n_divs; ++i) {
fac = fac + dividends[i] * exp(-r*Divs_T[i]);
}
temp = S0 - fac;
/* calculate the value of the option on expiry */
black_scholes(&val_T,NULL,temp,X,sigma,T,r,loc_q,put,&ifailx);
/* calculate the value of the option on last dividend date */
tn = Divs_T[n_divs-1];
temp = temp + dividends[n_divs-1]*exp(-r*tn);
nag_opt_bs(&val_tn,NULL,temp,X,sigma,tn,r,loc_q,putx,&ifailx);
*value = MAX(val_tn,val_T);
}
Code excerpt 5.2 Function to compute the value of the Black approximation for the
value of an American call option with discrete dividends.
We will now consider a more general technique for pricing both American
puts and calls.
5.2.2
The MacMillan–Barone-Adesi–Whaley method
Here we consider a method of pricing American options which relies on an ap-
proximation that reduces a transformed Black–Scholes equation into a second-
order ordinary differential equation, see Barone-Adesi and Whaley (1987) and
MacMillan (1986). It thus provides an alternative way of evaluating American
options that can be used instead of computationally intensive techniques such
as ﬁnite-difference methods. Although the method prices American options, it
is really based on the value of an American option relative to the corresponding

Single asset American options
103
double q,r,temp,loc_r;
long i,m,m2,m_acc;
double S0,E,T,sigma,t1,delta,value,ad_value,put_value;
long is_american,ifail,put;
double bin_greeks[5],greeks[5],bin_value,bs_value;
double opt_value, critical_value, E1, E2, crit1, crit2;
double black_value;
double Divs_T[3],dividends[3];
long n_divs, put;
E
= 100.0;
r = 0.04;
sigma = 0.2;
T =
2.0;
t1 = 1.0;
put = 0;
/* check using the same parameters as in \inlinecite{Wha1981} */
Divs_T[0] = 1.0;
dividends[0] = 5.0;
n_divs = 1;
printf ("\nPrice S
RGW Approximation
Black Approximation
\n\n");
for (i=0; i < 9; ++i) {
put = 0;
S0 = 80.0+(double)i*5.0;
opt_RGW_approx(&opt_value,&critical_value,n_divs,dividends,Divs_T,S0,E,sigma,T,r,&ifail);
printf("%8.4f
",S0);
printf("%12.3f %12.3f ",opt_value,critical_value);
opt_black_approx(&black_value,n_divs,dividends,Divs_T,S0,E,sigma,T,r,put,&ifail);
printf("%12.3f (%8.4e) ",black_value);
}
Code
excerpt
5.3 Simple
test
program
to
compare
the
results
of
function
opt_RGW_approx with function opt_black_approx; the parameters used are the
same as in Whaley (1981).
European option value (which can readily be computed using the Black–Scholes
pricing formula).
Since an American option gives more choice, its value is always at least that of
its European counterpart. This early exercise premium (ν(S, E, τ) ⩾0) is now
deﬁned more precisely for American puts and calls. If at current time t the asset
price is S, then the early exercise premium for an American call which expires
at time T , and therefore has maturity τ = T −t, is:
νc(S, E, τ) = C(S, E, τ) −c(S, E, τ) ⩾0
(5.2.8)
where C(S, E, τ) denotes the value of the American call and c(S, E, τ) denotes
the value of the corresponding European call. The early exercise premium of an
American put option, νp(S, E, τ), is similarly deﬁned as:
νp(S, E, τ) = P(S, E, τ) −p(S, E, τ) ⩾0
(5.2.9)
where P(S, E, τ) is the value of the American put, and p(S, E, τ) is the value of
the corresponding European put. The key insight provided by the MacMillan–
Barone-Adesi–Whaley method is that, since both the American and European
option values satisfy the Black–Scholes partial differential equation, so does the
early exercise premium, ν(S, E, τ); see Section 4.4.1. This means that we can
write:
∂ν
∂t + (r −q)S ∂ν
∂S + σ 2S2
2
∂2ν
∂S2 = rν
(5.2.10)

104
Computational Finance Using C and C#
where as usual S is the asset price, r is the continuously compounded interest
rate, q is the continuously compounded dividend, σ is the volatility, and time t
increases from the current time to the expiry time T .
We will now introduce the variable h(τ) = 1 −exp(−rτ) and use the factor-
ization ν(S, E, τ) = h(τ)g(S, E, h). From standard calculus we obtain:
∂ν
∂t = g ∂h
∂t + h∂g
∂t = rg(h −1) + h∂g
∂h
∂h
∂t = rg(h −1) + hr(h −1)∂g
∂h
and also
∂ν
∂S = h ∂g
∂S
and
∂2ν
∂S2 = h∂2g
∂S2
Substituting these results into Eq. (5.2.10) yields the following transformed
Black–Scholes equation:
S2σ 2h
2
∂2g
∂S2 + (r −q)Sh ∂g
∂S + rg(h −1) + rh(h −1)∂g
∂h = rgh
(5.2.11)
which can be further simpliﬁed to give:
S2σ 2 ∂2g
∂S2 + 2(r −q)S
σ 2
∂g
∂S −2rg
hσ 2 −2r(1 −h)
σ 2
∂g
∂h = rgh
(5.2.12)
or
S2 ∂2g
∂S2 + βS ∂g
∂S −α
hg −(1 −h)α ∂g
∂h = 0
(5.2.13)
where α = 2r/σ 2 and β = 2(r −q)/σ 2.
We now consider the last term of Eq. (5.2.13) and note that when τ is large,
1 −h(τ) ∼0. Also when τ →0 the option is close to maturity, and the
value of both the European and American options converge; this means that
ν(S, E, τ) ∼0 and ∂g
∂h ∼0. It can thus be seen that the last term is generally
quite small and the MacMillan–Barone-Adesi–Whaley approximation assumes
that it can be ignored. This results in the following equation:
S2 ∂2g
∂S2 + βS ∂g
∂S −α
hg = 0
(5.2.14)
which is a second-order differential equation with two linearly independent so-
lutions of the form aSγ . They can be found by substituting g(S, E, h) = aSγ
into Eq. (5.2.14) as follows:
∂g
∂S = γ Sγ −1,
∂2g
∂S2 = aγ (γ −1)Sγ −2 = aγ 2Sγ −2 −aγ Sγ −2
so
S2 ∂2g
∂S2 = aγ 2Sγ −aγ Sγ = γ 2g −γg
and
βS ∂g
∂S = βSaγ Sγ −1 = βγ Sγ = βγg

Single asset American options
105
When the above results are substituted in Eq. (5.2.14) we obtain the quadratic
equation:
γ 2g −γg + βγg −α
h = g

γ 2 −γ + (β −1)γ −α
h

= 0
or
γ 2 −γ + (β −1)γ −α
h = 0
(5.2.15)
which has the two solutions
γ1 = 1
2

−(β −1) −

(β −1)2 + 4α
h

(5.2.16)
and
γ2 = 1
2

−(β −1) +

(β −1)2 + 4α
h

(5.2.17)
where we note that since α/h > 0, we have γ1 < 0 and γ2 > 0.
The general solution to Eq. (5.2.14) is thus:
g(S, E, h) = a1Sγ1 + a2Sγ2
(5.2.18)
We will now derive the appropriate solutions pertaining to American call op-
tions and American put options.
American call options
Here we use the fact that both the value and the early exercise premium
(νc(S, E, τ) = hgc(S, E, h)) of an American call tend to zero as the asset price
S →0. This means that as S →0, gc(S, E, h) →0.
However, since γ1 < 0, the only way this can be achieved in Eq. (5.2.18) is if
a1 = 0. So gc(S, E, h) = a2Sγ2, and the value of an American call is:
C(S, E, τ) = c(S, E, τ) + ha2Sγ2
(5.2.19)
An expression for a2 can be found by considering the critical asset price (point
on the early exercise boundary), S∗, above which the American option will be
exercised. For S < S∗, the value of the American call is governed by Eq. (5.2.19),
and when S > S∗we have C(S, E, τ) = S −E.
Now, since the value of the American option is continuous, at the critical asset
value S∗the following equation applies:
S∗−E = c

S∗, E, τ

+ ha2S∗γ2
(5.2.20)
Furthermore, since the gradient of the American option value is also continuous,
at S∗we have:
∂(S∗−E)
∂S∗
=
∂
∂S∗

c

S∗, E, τ

+ ha2S∗γ2
(5.2.21)
which gives:
1 = exp(−qτ)N1

d1

S∗
+ γ2ha2S∗(γ2−1)
(5.2.22)

106
Computational Finance Using C and C#
where we have used the value of the hedge parameter Δc for a European call
(see the section on the Greeks):
Δc = ∂c(S∗, E, τ)
∂S∗
= exp(−qτ)N1

d1

S∗
Equation (5.2.22) can therefore be written as:
ha2S∗γ2 = S∗
γ2

1 −exp(−qτ)N1

d1

S∗
(5.2.23)
When the left-hand side of the above equation is substituted into Eq. (5.2.20)
we obtain the following equation for S∗:
S∗−E = c

S∗, E, τ

+ S∗
γ2

1 −exp(−qτ)N1

d1

S∗
(5.2.24)
This equation can be solved for S∗using standard iterative methods (see the
section on the numerical solution of critical asset values). Once S∗has been
found Eq. (5.2.23) gives:
ha2 = A2S∗−γ2
where
A2 = S∗
γ2

1 −exp(−qτ)N1

d1

S∗
From Eq. (5.2.19) the value of an American call is thus of the form:
C(S, E, τ) = c(S, E, τ) + A2
 S
S∗
γ2
when S < S∗
(5.2.25)
C(S, E, τ) = S −E
when S ⩾S∗
(5.2.26)
American put options
For an American put option we proceed in a similar manner to that for the
American call. We now use the fact that both the value and early exercise pre-
mium (νp(S, E, τ) = hgp(S, E, h)) of an American put tend to zero as the asset
price S →∞. So gp(S, E, h) →0 as S →∞. Since γ2 > 0 the only way this can
be achieved by Eq. (5.2.18) is if a2 = 0. This gives gp(S, E, h) = a1Sγ1 and the
value of an American put is:
P(S, E, τ) = p(S, E, τ) + ha1Sγ1
(5.2.27)
An expression for a1 can be found by considering the critical asset price, S∗∗,
below which the American option will be exercised. For S > S∗∗the value
of the American put is given by Eq. (5.2.27), and for S < S∗∗we have
P(S, E, τ) = E −S.
Continuity of the American option value at the critical asset price gives:
E −S∗∗= p

S∗∗, E, τ

+ ha1S∗∗γ1
(5.2.28)

Single asset American options
107
and continuity of the option value’s gradient at the critical asset price yields:
∂(E −S∗∗)
∂S∗∗
=
∂
∂S∗∗

p

S∗∗, E, τ

+ ha1S∗∗γ1
(5.2.29)
which can be simpliﬁed to:
−1 = −N1

−d1

S∗∗
exp(−qτ) + γ1a1S∗∗(γ1−1)
(5.2.30)
where we have used the value of hedge parameter Δp for a European put (see
Appendix A.3):
Δp = ∂p(S∗∗, E, τ)
∂S∗∗
=

N1

d1

S∗∗
−1

exp(−qτ) = −N1

−d1

S∗∗
exp(−qτ)
Equation (5.2.30) can therefore be written as:
ha1S∗∗γ1 = −S∗∗
γ1

1 −N1

−d1

S∗∗
exp(−qτ)

(5.2.31)
When the left-hand side of the above equation is substituted into Eq. (5.2.28)
we obtain the following equation for S∗∗:
E −S∗∗= p

S∗∗, E, τ

+

1 −exp(−qτ)N

−d1

S∗∗S∗∗
γ1
(5.2.32)
which can be solved iteratively to yield S∗∗(see the section on the numerical
solution of critical asset values). Once S∗∗has been found Eq. (5.2.31) gives:
ha1 = A1S∗∗−γ1
where
A1 = −
S∗∗
γ1

1 −exp(−qτ)N1

−d1

S∗∗
We note here that A1
> 0 since, γ1
< 0, S∗∗
> 0, and N1(−d1(S∗∗))
exp(−qτ) < 1.
From Eq. (5.2.27) the value of an American put is thus:
P(S, E, τ) = p(S, E, τ) + A1
 S
S∗∗
γ2
when S > S∗∗
P(S, E, τ) = E −S
when S ⩽S∗∗
5.2.3
Numerical solution of critical asset values
We now provide details on how to iteratively solve for the critical asset price in
Eqs. (5.2.24) and (5.2.32).

108
Computational Finance Using C and C#
American call options
For American call options we need to solve Eq. (5.2.24), which is:
S∗−E = c

S∗, E, τ

+ S∗
γ2

1 −exp(−qτ)N1

d1

S∗
We denote the ith approximation to the critical asset value S∗by S∗
i , and repre-
sent the left-hand side of the equation by:
LHS

S∗
i , E, τ

= S∗
i −E
and the right-hand side of the equation by:
RHS

S∗
i , E, τ

= c

S∗
i , E, τ

+ S∗
i
γ2

1 −exp(−qτ)N1

d1

S∗
i

If we let K(S∗
i , E, τ) = RHS(S∗
i , E, τ) −LHS(S∗
i , E, τ) then we want to ﬁnd the
value of S∗
i which (to a speciﬁed tolerance) gives K(S∗
i , E, τ) ∼0. This can be
achieved with Newton’s root ﬁnding method, in which a better approximation,
S∗
i+1, can be found using:
S∗
i+1 = S∗
i −K(S∗
i , E, τ)
K
′(S∗
i , E, τ)
(5.2.33)
where:
K′
S∗
i , E, τ

=
∂
∂S∗
i

RHS

S∗
i , E, τ

−LHS

S∗
i , E, τ

=
∂
∂S∗
i

RHS

S∗
i , E, τ

−
∂
∂S∗
i

LHS

S∗
i , E, τ

= bi −1
Here we have used bi =
∂
∂S∗
i {RHS(S∗
i , E, τ)}, and the expression for bi is given
by Eq. (5.2.35), which is derived at the end of this section.
Substituting for K(S∗
i , E, τ) and K′(S∗
i , E, τ) into Eq. (5.2.32), we therefore
obtain:
S∗
i+1 = S∗
i −RHS(S∗
i , E, τ) −LHS(S∗
i , E, τ)
bi −1
= S∗
i −RHS(S∗
i , E, τ) −(S∗
i −E)
bi −1
= biS∗
i −RHS(S∗
i , E, τ) −E
bi −1
The ﬁnal iterative algorithm for the American call is therefore:
S∗
i+1 = E + RHS(S∗
i , E, τ) −biS∗
i
1 −bi
(5.2.34)

Single asset American options
109
where we can use S∗
0 = E for the initial estimate of the critical value (see the
computer Code excerpt 5.4).
The expression for bi
Here we derive an expression for the term bi which is used in Eq. (5.2.34).
bi = ∂c(S∗
i , E, τ)
∂S∗
i
+ 1
γ2

1 −exp(−qτ)N1

d1

S∗
i

−S∗
i
γ2
∂N1(d1(S∗
i ))
∂d1(S∗
i )
∂d1(S∗
i )
∂S∗
i
We will now quote the following results which are derived in Appendix A:
Appendix A, Eq. (A.1.3)
∂N1(d1(S∗
i ))
∂d1(S∗
i )
= n

d1

S∗
i

Appendix A, Eq. (A.1.6)
∂d1(S∗
i )
∂S∗
i
=
1
S∗
i σ√τ
Appendix A, Eq. (A.3.2)
Δc = ∂c(S∗
i , E, τ)
∂S∗
i
= exp(−qτ)N1

d1

S∗
i

Substituting these results into the above expression, we therefore obtain:
bi = exp(−qτ)N1

d1

S∗
i

+ 1
γ2
−exp(−qτ)N1(d1(S∗
i ))
γ2
−exp(−qτ)n(d1(S∗
i ))
γ2σ√τ
which can be rearranged to yield:
bi = exp(−qτ)N1

d1

S∗
i

1 −1
γ2

+ 1
γ2

1 −exp(−qτ)n(d1(S∗
i ))
σ√τ

(5.2.35)
American put options
For American put options we need to solve Eq. (5.2.32) which is:
E −S∗∗
i
= p

S∗∗
i , E, τ

−S∗∗
i
γ1

1 −N1

−d1

S∗∗
i

exp(−qτ)

If we let S∗∗
i
denote the ith approximation to the critical asset value S∗∗, then
we can represent the left-hand side of the equation by:
LHS

S∗∗
i , E, τ

= E −S∗∗
i

110
Computational Finance Using C and C#
and the right-hand side of the equation by:
RHS

S∗∗
i , E, τ

= p

S∗∗
i , τ

−S∗∗
i
γ1

1 −N1

−d1

S∗∗
i

exp(−qτ)

= p

S∗∗
i , E, τ

−S∗∗
i
γ1

1 −

1 −N1

d1

S∗∗
i

exp(−qτ)

= p

S∗∗
i , E, τ

−S∗∗
i
γ1

1 −exp(−qτ)
+ N1

d1

S∗∗
i

exp(−qτ)

We then denote K(S∗∗
i , E, τ) = RHS(S∗∗
i , E, τ) −LHS(S∗∗
i , E, τ) and using
Newton’s method we obtain:
S∗∗
i+1 = S∗∗
i
−K(S∗∗
i , E, τ)
K′(S∗∗
i , E, τ)
(5.2.36)
where as before:
K′
S∗∗
i , E, τ

=
∂
∂S∗∗
i

RHS

S∗∗
i , E, τ

−LHS

S∗∗
i , E, τ

So K′(S∗∗
i , E, τ) = 1 + bi, where bi = ∂(RHS(S∗∗
i ,E,τ))
∂S∗∗
i
, and the expression for bi
is given by Eq. (5.2.38), which is derived at the end of this section.
Equation (5.2.36) can therefore be written as:
S∗∗
i+1 = S∗∗
i
−RHS(S∗∗
i , E, τ) −LHS(S∗∗
i , E, τ)
1 + bi
= S∗∗
i (1 + bi) −RHS(S∗∗
i , E, τ) + E −S∗∗
i
1 + bi
The ﬁnal iterative algorithm for the American put is therefore:
S∗∗
i
= E −RHS(S∗∗
i , E, τ) + biS∗∗
i
1 + bi
(5.2.37)
where we can use S∗∗
0
= E for the initial estimate of the critical asset value (see
the computer Code excerpt 5.4).
The expression for bi
Here we derive an expression for the term bi which is used in Eq. (5.2.37).
Since
bi =
∂
∂S∗∗
i

p

S∗∗
i , E, τ

−S∗∗
i
γ1

1 −exp(−qτ) + N1

d1

S∗∗
i

exp(−qτ)

we have
bi = ∂p(S∗∗
i , E, τ)
∂S∗∗
i
−1
γ1

1 −exp(−qτ)

−1
γ1
exp(−qτ)N1

d1

S∗∗
i

−S∗∗
i
exp(−qτ)
γ1
∂N1(d1(S∗∗
i ))
∂d1(S∗∗
i )
∂d1(S∗∗
i )
∂S∗∗
i

Single asset American options
111
We will now quote the following results which are derived in Appendix A:
Appendix A, Eq. (A.1.3):
∂N1(d1(S∗∗
i ))
∂d1(S∗∗
i )
= n

d1

S∗∗
i

Appendix A, Eq. (A.1.6):
∂d1(S∗∗
i )
∂S∗∗
i
=
1
S∗∗
i σ√τ
Appendix A, Eq. (A.3.4):
Δp = ∂p(S∗∗
i , E, τ)
∂S∗∗
i
= exp(−qτ)

N1

d1

S∗∗
i

−1

Substituting these results into the above expression, we therefore obtain:
bi = exp(−qτ)

N1

d1

S∗∗
i

−1

−1
γ1

1 −exp(−qτ) + N1

d1

S∗∗
i

exp(−qτ)

−S∗∗
i
exp(−qτ)
γ1
∂N1(d1(S∗∗
i ))
∂d1(S∗∗
i )
∂d1(S∗∗
i )
∂S∗∗
i
= exp(−qτ)

N1

d1

S∗∗
i

−1

−1
γ1

1 −exp(−qτ) + N1

d1

S∗∗
i

exp(−qτ)

−S∗∗
i
exp(−qτ)n(d1(S∗∗
i ))
γ1σ√τ
which can be rearranged to yield:
bi = exp(−qτ)N1

d1

S∗∗
i

1 −1
γ1

+ 1
γ1

exp(−qτ) −1 −exp(−qτ)n(d1(S∗∗
i ))
σ√τ

−exp(−qτ)
(5.2.38)
In Code excerpt 5.4 we provide computer code to implement the MacMillan–
Barone-Adesi–Whaley method.
void MBW_approx(double *opt_value, double *critical_value, double S0, double X,
double sigma, double T, double r, double q, long put, long *iflag)
{
/* Input parameters:
=================
S0
- the current value of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
Code excerpt 5.4.

112
Computational Finance Using C and C#
q
- the continuous dividend yield
put
- if put is 0 then a call option, otherwise a put option
Output parameters:
==================
opt_value
- the value of the option
critical_value
- the critical value
iflag
- an error indicator
*/
double A_1,A_2,S_star,gamma_2,gamma_1;
double d1,alpha,h,beta,temp,temp1;
double pdf,pi,b,rhs,eur_val,tol,err;
long iterate;
long iflagx,putx;
pi = PI;
beta = 2.0 * (r - q) / (sigma * sigma);
alpha = 2.0 * r / (sigma * sigma);
h = 1.0 - exp(-r*T);
temp = beta - 1.0;
iterate = 1;
tol = 0.000001;
if (!put) {
/* An American call */
gamma_2 = (-temp + sqrt((temp*temp) + (4.0*alpha/h)));
gamma_2 = gamma_2 / 2.0;
S_star = X;
while (iterate) {
/* calculate S_star, iteratively */
d1 = log(S_star/X) + (r-q+(sigma*sigma/2.0))*T;
d1 = d1/(sigma*sqrt(T));
pdf = (1.0/sqrt(2.0*pi))*exp(-d1*d1/2.0);
temp = exp (-q*T)*cum_norm(d1)*(1.0 - (1.0/gamma_2));
temp1 = (1.0 - ((exp(-q*T)*pdf)/(sigma*sqrt(T))))/gamma_2;
b = temp + temp1;
/* calculate the Black-Scholes value of a European call */
putx = 0;
black_scholes(&eur_val,NULL,S_star,X,sigma,T,r,q,putx,&iflagx);
rhs = eur_val+(1.0-exp(-q*T)*cum_norm(d1))*S_star/gamma_2;
S_star = (X + rhs - b*S_star)/(1.0-b);
err = fabs((S_star - X) - rhs)/X;
if (err < tol) iterate = 0;
}
A_2 = (S_star/gamma_2)*(1.0 - exp(-q*T)*cum_norm(d1));
if (S0 < S_star) {
temp1 = S0/S_star;
black_scholes(&temp,NULL,S0,X,sigma,T,r,q,putx,&iflagx);
*opt_value = temp + A_2 * pow(temp1,gamma_2);
}
else {
*opt_value = S0 - X;
}
}
else { /* An American put */
gamma_1 = (-temp - sqrt((temp*temp) + (4.0*alpha/h)));
gamma_1 = gamma_1 / 2.0;
S_star = X;
while (iterate) {
/* calculate S_star, iteratively */
d1 = log(S_star/X) + (r-q+(sigma*sigma/2.0))*T;
d1 = d1/(sigma*sqrt(T));
pdf = (1.0/sqrt(2.0*pi))*exp(-d1*d1/2.0);
temp = exp(-q*T)*(cum_norm(d1)*(1.0-(1.0/gamma_1))-1.0);
temp1 = (exp(-q*T)-1.0-((exp(-q*T)*pdf)/(sigma*sqrt(T))))/gamma_1;
b = temp + temp1;
/* calculate the Black-Scholes value of a European put */
putx = 1;
black_scholes(&eur_val,NULL,S_star,X,sigma,T,r,q,putx,&iflagx);
rhs = eur_val-(1.0-exp(-q*T)+exp(-q*T)*cum_norm(d1))*S_star/gamma_1;
S_star = (X - rhs + b*S_star)/(1.0+b);
err = fabs((X - S_star) - rhs)/X;
if (err < tol) iterate = FALSE;
}
A_1 = -(S_star/gamma_1)*(1.0 - exp(-q*T)*cum_norm(-d1));
if (S0 > S_star) {
temp1 = S0/S_star;
black_scholes(&temp,NULL,S0,X,sigma,T,r,q,putx,&iflagx);
*opt_value = temp + A_1 * pow(temp1,gamma_1);
}
Code excerpt 5.4 (Continued).

Single asset American options
113
else {
*opt_value = X - S0;
}
}
*critical_value = S_star;
}
Code excerpt 5.4 Function to compute the MacMillan–Barone-Adesi–Whaley approxi-
mation for American options.
Table 5.2 The MacMillan–Barone-Adesi–Whaley method for American option values
computed by the routine MBW_approx
Stock price
Call
Put
Accurate value
Error
Accurate value
Error
86.0
1.2064
5.54 × 10−4
14.0987
−3.69 × 10−2
89.0
1.8838
1.95 × 10−4
11.5120
−4.85 × 10−2
92.0
2.7890
7.03 × 10−4
9.2478
−3.58 × 10−2
95.0
3.9427
1.16 × 10−3
7.3031
−1.66 × 10−2
98.0
5.3522
1.15 × 10−3
5.6674
7.19 × 10−4
101.0
7.0119
1.10 × 10−3
4.3209
1.35 × 10−2
104.0
8.9043
2.21 × 10−3
3.2362
2.22 × 10−2
107.0
11.0072
2.63 × 10−3
2.3823
2.63 × 10−2
110.0
13.2905
4.20 × 10−3
1.7235
2.80 × 10−2
113.0
15.7264
4.77 × 10−3
1.2272
2.66 × 10−2
The parameters used were: τ = 0.5, X = 100.0, r = 0.1, q = 0.06, σ = 0.2. The accurate
value was calculated using a standard lattice with 2000 time steps, and the error was the
MacMillan–Barone-Adesi–Whaley estimate minus the accurate value.
Table 5.3 The MacMillan, Barone-Adesi, and Whaley critical asset values for the early
exercise boundary of an American put computed by the routine MBW_approx
Time to expiry, τ
Critical asset value, S∗∗
Time to expiry, τ
Critical asset value, S∗∗
1.00
82.1510
0.50
85.1701
0.95
82.3751
0.45
85.6199
0.90
82.6115
0.40
86.1176
0.85
82.8618
0.35
86.6740
0.80
83.1273
0.30
87.3049
0.75
83.4098
0.25
88.0333
0.70
83.7115
0.20
88.8959
0.65
84.0349
0.15
89.9568
0.60
84.3830
0.10
91.3469
0.55
84.7598
0.05
93.4260
The parameters used were: S = 101.0, X = 101.0, r = 0.1, q = 0.06, and σ = 0.20.
The results given in Tables 5.2 and 5.3 were obtained by using the function
MBW_approx.

114
Computational Finance Using C and C#
5.3
Lattice methods for vanilla options
5.3.1
Binomial lattice
In this section we will derive equations for a binomial lattice that describes the
GBM movement of asset price changes. The approach that we will adopt is
based on the work of Cox, Ross, and Rubinstein (1979) and will be referred to
as the CRR lattice.
From Chapter 2, Eq. (2.3.9), we know that if the price of an asset, St, follows
GBM then the change in value of its price over time interval t has the following
distribution:
log
St+t
St

∼N

r −σ 2
2

t, σ 2t

If we use the notation:
X = St+t
St
and
η =

r −σ 2
2

t,
ν2 = σ 2t
the above equation becomes:
log(X) ∼N

η, ν2
or equivalently
X ∼

η, ν2
where (η, ν2) is the lognormal distribution derived from a Gaussian distribu-
tion with mean η and variance ν2. It is well known—see for example Evans,
Hastings, and Peacock (2000)—that the ﬁrst two moments of a variable X
drawn from a lognormal distribution are:
Lognormal mean
E[X] = exp

η + ν2
2

(5.3.1)
substituting for η and ν2 gives:
E[X] = exp

r −σ 2
2

t + σ 2
2 t

(5.3.2)

Single asset American options
115
Lognormal variance
Var[X] = E

X −E[X]
2
= E

X2
−

E[X]
2
= exp

2η + ν2
exp

ν2
−1

(5.3.3)
substituting for η and ν2 gives:
Var[X] = exp

2r

r −σ 2
2

t + σ 2t

which can be simpliﬁed to yield:
Var[X] = exp{2rt}

exp

σ 2t

−1

(5.3.4)
Since we can assume that the expected value of X grows at the riskless interest
rate, r, we can also write:
E[X] = exp(rt)
(5.3.5)
The above results can be used to ﬁnd the ﬁrst two moments of the asset price
distribution St+t, given that we know the asset price, St, at time instant t. To
do this we will use (see Appendix C.3 for a proof) the fact that for a random
variable G we have:
E[a + bG] = E[a] + bE[G]
and
Var[a + bG] = b2 Var[G]
where a and b are constants. Applying this to the variable X gives:
E[X] = E
St+t
St

= 1
St
E[St+t]
(5.3.6)
and
Var[X] = Var
St+t
St

= 1
S2t
Var[St+t]
(5.3.7)
where we have used a = 0 and b = 1
St
. Note: It is also easy to show that:
Var[St+t] = Var[S]
(5.3.8)
where the change in asset price over the time interval t is denoted by S =
St+t −St. This elementary result sometimes is used without proof, see for ex-
ample Hull (1997), p. 344. The proof is simple:
Var[St+t] = Var[St + S] = Var[S]
where again we have used:
Var[a + bG] = b2 Var[G],
this time with a = 0 and b = 1.
To ﬁnd expressions for the mean and variance of St+t we simply substitute
Eq. (5.3.5) into Eq. (5.3.6) and obtain:
E[St+t] = St exp(rt)
(5.3.9)

116
Computational Finance Using C and C#
and substituting Eq. (5.3.4) into Eq. (5.3.7) gives:
Var[St+t] = S2
t exp

2rt

exp

σ 2t

−1

(5.3.10)
Since we are modelling asset price movements with a binomial lattice, the asset
price, St, at any given node is only permitted to either jump up or jump down
in value over the next time step t. Here we will assume that the new asset
price, St+t, is Stu for an up jump and Std for a down jump where u and d are
constants that apply to all lattice nodes. If we further denote the probability of
an up jump by p, then the probability of a down jump must (by deﬁnition) be
1 −p.
Now that we have speciﬁed the lattice parameters we will use these to match
the ﬁrst two moments of the lognormal distribution. This results in the following
equation for the mean:
E[St+t] = pStu + (1 −p)Std = St exp(rt)
(5.3.11)
The corresponding equation for the variance requires a little more work:
Var[St+t] = E

(St+t)2
−

E[St+t]
2
(5.3.12)
Since
E

(St+t)2
= p(Stu)2 + (1 −p)(Std)2 = S2
t

pu2 + (1 −p)d2
(5.3.13)
and, from Eq. (5.3.9), we have:

E[St+t]
2 =

St exp(rt)
2 = S2
t exp(2rt)
(5.3.14)
we can substitute Eqs. (5.3.13) and (5.3.14) into Eq. (5.3.12) to obtain:
Var[St+t] = S2
t

pu2 + (1 −p)d2
−S2
t exp(2rt)
(5.3.15)
So from Eqs. (5.3.10) and (5.3.15):
exp(2rt)

exp

σ 2t

−1

= pu2 + (1 −p)d2
= pu2 + (1 −p)d2 −exp(2rt)
(5.3.16)
So, restating Eq. (5.3.11) and simplifying Eq. (5.3.16), we obtain the following
two equations:
pu + (1 −p)d = exp(rt)
(5.3.17)
exp

2rt + σ 2t

= pu2 + (1 −p)d2
(5.3.18)
which we will use to solve for the three parameters u, d, and p. Since there
are three unknowns and only two equations, we can impose an additional con-
straint to obtain a unique solution. The constraint used in the CRR binomial
model is:
u = 1
d
We now use the following notation:
a = exp(rt)

Single asset American options
117
and
b2 = exp(2rt)

exp

σ 2t

−1

= a2
exp

σ 2t

−1

This means that Eq. (5.3.17) can be written as:
a = pu + (1 −p)d
which gives:
p = a −d
u −d
(5.3.19)
From Eq. (5.3.18) we have:
exp

2rt + σ 2t

= a2 exp

σ 2t

= a2 + b2
and so:
a2 + b2 = pu2 + (1 −p)d2
Rearranging we have:
pu2 + (1 −p)d2 −a2 = b2
pu3 + (1 −p)d2u −a2u −b2u = 0
but:
(1 −p)d2u = (1 −p)d = a −pu
so
pu3 + (a −pu) −a2u −b2u = 0
or
p

u3 −u

+ a −a2u −b2u = 0
Now,
p

u3 −u

= u2p(u −d) = u2(a −d) = u2a −u
which gives:
au2 −u + a −a2u −b2u = 0
So we obtain the following quadratic equation in u:
au2 −u

1 + a2 + b2
+ a = 0
The solution is:
u = (1 + a2 + b2) +

(1 + a2 + b2)2 −4a2
2a
If t is small we can obtain a reasonable approximation to the solution by
neglecting terms of order higher than t.

118
Computational Finance Using C and C#
In these circumstances we have:
a2 + b2 + 1 = exp(2rt) + exp(2rt)

exp

σ 2t

−1

+1
∼1 + 2rt + (1 + 2rt)σ 2t + 1 ∼2 + 2rt + σ 2t
Therefore,

a2 + b2 + 1
2 −4a2 ∼

2 + 2rt + σ 2t
2 −4(1 + 2rt)
∼

4 + 8rt + 4σ 2t −4 −8rt
=

4σ 2t = 2σ
√
t
and so
u ∼2 + 2rt + σ 2t + 2σ
√
t
2 exp(rt)
u ∼

1 + rt + σ 2t
2
+ σ
√
t

(1 −rt)
u ∼1 + rt + σ 2t
2
+ σ
√
t −rt = 1 + σ
√
t + σ 2t
2
which to order t gives:
u = exp

σ
√
t

and
d = exp

−σ
√
t

(5.3.20)
where we have used
exp

σ
√
t

= 1 + σ
√
t + σ 2t
2
+ σ 3(t)3/2
6
+ · · ·
and
d = 1
u
It is interesting to note (by substituting into Eq. (5.3.19)) that when r = 0 and
t →0, we have p →1
2.
Now that we know the values of the lattice parameters u, d, and p we can use
these to build a lattice with a speciﬁed number of time steps. Once this has been
constructed, it can be used to compute the values and Greeks for various types
of ﬁnancial options. These could simply be American/European vanilla options,
or more exotic options that may incorporate features such as: lockout periods,
barriers, and nonstandard payoff functions.
We will now discuss how to create a lattice which can be used to value Amer-
ican and European vanilla options.
If the current value of the underlying asset is S, and the duration of the option
is τ and we use a lattice with n equally spaced time intervals t, then we have:
t = τ
n
The values of the asset price at various nodes in the lattice can easily be com-
puted. This is illustrated, in Fig. 5.1, for a lattice with six time steps (that is
seven lattice levels).

Single asset American options
119
Figure 5.1 A standard binomial lattice consisting of six time steps. The root lattice
node R corresponds to the current time t, and the terminal nodes G to M are those at
option maturity; that is time t + τ, where τ is the duration of the option. The asset value
at node R is S, where S is the current asset value. Asset values at other nodes are, for ex-
ample, node S: Su, node T: Sd, node V: S, and node A: Su5. Option values are computed
using a backward iterative process: the option values at nodes A–F on the penultimate
time step are computed from the payouts of the terminal nodes G–M, and this process con-
tinues until the root node is reached which yields the current value of the option. Here
we compute the Greeks using the following nodes: Delta uses nodes S and T, Gamma
uses nodes U, V, and W, and Theta uses nodes R and V.
The asset values at the labelled nodes are:
Lattice level 1: Time t
SR = S
Lattice level 2: Time t + t
SS = Su,
ST = Sd
Lattice level 6: Time t + 5t
SA = Su5,
SB = Su3,
SC = Su,
SD = Sd,
SE = S,
SF = Sd5
Lattice level 7: Time t + 6t
SG = Su6,
SH = Su4,
SI = Su2,
SJ = S,
SK = Sd2,
SL = Sd4,
SM = Sd6

120
Computational Finance Using C and C#
In general, at time t + it, there are i + 1 stock prices; these are:
Si,j = Sujdi−j,
j = 0, 1, . . . , i
We note that, since u = 1/d, an up movement followed by a down movement
gives the same stock price as a down movement followed by an up movement;
for instance, Su2d = Su. This means that the tree recombines, and the number of
nodes required to represent all the different asset prices is signiﬁcantly reduced.
5.3.2
Constructing and using the binomial lattice
In this section we are concerned with the practical details of how to construct,
and then use, a standard one-dimensional binomial lattice to value Ameri-
can and European options. Since this lattice forms the basis for other one-
dimensional and multidimensional lattice techniques, we will discuss its con-
struction in some detail. A complete computer program for a standard bino-
mial lattice is given in Code excerpt 5.11, and we will use this as a basis for
our discussions. The results of using this code are presented in Fig. 5.2. For
Figure 5.2 The error in the estimated value, est_val, of an American put using a stan-
dard binomial lattice. The parameters used were: T = 1.0, S = 105.0, X = 105.0, r = 0.1,
q = 0.02, σ = 0.3. The very accurate value (acc_val) was 9.2508 and was computed us-
ing a 6000 step standard binomial lattice. The error in the estimated value was obtained
as est_val −acc_val.

Single asset American options
121
easy reference we will now list the input parameters used by this computer pro-
gram:
S0
the current price of the underlying asset, S
X
the strike price
sigma
the volatility of the asset
T
the maturity of the option in years
r
the risk-free interest rate
q
the continuous dividend yield
put
if put equals 1 then the option is a put
option, if put equals 0 then it is a call option
is_american
if is_american equals 1 then it is an
American option, if is_american equals 0 then it is a
European option
M
the number of time steps in the lattice
We will now discuss in more detail the computational issues involved in each
stage of the calculation.
Compute the values of the constants used by the lattice
First calculate the values of various constants that will be used, see Code ex-
cerpt 5.5.
For convenience, we have used the variables p_u and p_d to store, respec-
tively, the up and down jump probabilities discounted by the interest rate r
over one time step; these values will be used later on when we work backwards
through the lattice to calculate the current option value.
Assign the asset values to the lattice nodes
We will now show that the number of different asset prices, LSn, for an n step
recombining lattice is 2n + 1.
The nodes in a recombining lattice can be considered as being composed of
two kinds: those corresponding to an even time step, and those corresponding
to an odd time step.
This is because the set of node asset values, ET , for an even time step is
distinct from the set of node asset values, OT , for an odd time step. Although
dt = T/(double)M;
t1 = sigma*sqrt(dt);
u = exp(t1);
d = exp(-t1);
a = exp((r-q)*dt);
p = (a - d)/(u - d);
if ((p < zero) || (p > 1.0)) printf ("Error p out of range\n");
discount = exp(-r*dt);
p_u = discount*p;
p_d = discount*(1.0-p);
Code excerpt 5.5 A code fragment which computes the values of various lattice con-
stants.

122
Computational Finance Using C and C#
s[M] = S0;
for (i = 1; i <= M; ++i) {
s[M+i] = u*s[M+i-1];
s[M-i] = d*s[M-i+1];
}
Code excerpt 5.6 A code fragment which assigns the different binomial lattice asset
values to the storage array s by using the up and down jump ratios u and d de-
ﬁned in Section 3.4.1. The current asset value S is assigned to the central array el-
ement s[M], where M is the number of time steps in the lattice. The array elements
above center are S[M+i] = Sui, i = 1, . . . ,M, and the array elements below center are
S[M-i] = Sdi, i = 1, . . . ,M.
ET ∩OT = ∅, the elements of ET and OT for any consecutive pair of time steps
are related by the simple constant multiplicative factor d. Also, for an even time
step there is a central node corresponding to the current asset price S0, and the
remaining nodes are symmetrically arranged about this, see Code excerpt 5.6.
These features are illustrated in Fig. 5.1, for a standard lattice with six time
steps.
The number of distinct asset prices in a lattice is therefore the sum of the
number of nodes in the last two time steps. Since the number of nodes in the ith
time step, Si, is i + 1 (see Fig. 5.1), for an n time step lattice we have:
Sn = n + 1
and
Sn−1 = n
This means that the number of different asset values in an n time step lattice is:
LSn = Sn + Sn−1 = 2n + 1
The number of nodes in an n time step lattice, LN n, is:
LN n =
n

i=0
(i + 1) = (n + 1)(n + 2)
2
where we have used the fact that LN n is the sum of an arithmetic progression
with ﬁrst term 1, increment 1 and last term n + 1.
One might initially think that, in order to price options, it is necessary to
store the asset value of each lattice node which would entail storing LN n values.
However, this is not the case. We only need to store the number of different asset
values in the lattice; that is, LSn values.
Storing LSn values instead of LN n can result in dramatic economies of stor-
age. For example, an accurate, 1000 step lattice, has LN n = 2001×2002×1/2 =
2003001, while the corresponding value of LSn is only 2 × 1000 + 1 = 2001.
Compute the option payoff at the terminal nodes
The current value of an option is evaluated by starting at option maturity, the
end of the tree, and working backwards. The option values for the terminal
nodes of the tree are just given by the payoff (at maturity) of the option; this

Single asset American options
123
if (((M+1)/2) == (M/2)) { /* then M is even */
if (put)
v[M/2] = MAX(X - s[M],zero);
else
v[M/2] = MAX(s[M]-X,zero);
}
P1 = 2*M;
P2 = 0;
for (i = 0; i < (M+1)/2; ++i) {
if (put) {
v[M-i] = MAX(X - s[P1],zero);
v[i]
= MAX(X - s[P2],zero);
}
else {
v[M-i] = MAX(s[P1]-X,zero);
v[i]
= MAX(s[P2]-X,zero);
}
P1 = P1 - 2;
P2 = P2 + 2;
}
Code excerpt 5.7 A code fragment that computes the payouts for puts and calls at the
lattice terminal nodes. The payouts are assigned to elements of the array v and are com-
puted using the strike price, X, and the previously computed asset values stored in ar-
ray s; as before M is the number of time steps in the lattice.
is independent of whether the option is an American or European. For a lattice
with n time steps there are n + 1 terminal nodes, with option values, fn,j, j =
0, . . . , n.
To compute the values of vanilla American and European options, with exer-
cise price E, then we will start with the following terminal node values:
for put options:
fn,j = max

E −Sujdn−j, 0

,
j = 0, . . . , n,
and for call options:
fn,j = max

Sujdn−j −E, 0

,
j = 0, . . . , n
The computer code used to achieve this is Code excerpt 5.7.
Iterate backwards through the lattice
The probability of moving from node (i, j) at time it to node (i + 1, j + 1) at
time (i + 1)t is p, and the probability of moving from node (i, j) at time it
to the node (i + 1, j) at time (i + 1)t is 1 −p. If we assume that there is no
early exercise then:
f E
i,j = exp(−rt)

pfi+1,j+1 + (1 −p)fi+1,j

,
j ⩽i ⩽n −1, 0 ⩽j ⩽i
(5.3.21)

124
Computational Finance Using C and C#
When early exercise, for an American option, is taken into account we have:
f A
i,j = max

E −Si,j, f E
i,j

(5.3.22)
or for an American call option:
f A
i,j = max

Si,j −E, f E
i,j

,
j ⩽i ⩽N −1, 0 ⩽j ⩽i,
(5.3.23)
where f E
i,j is given by Eq. (5.3.21).
Code excerpt 5.8 works backward through the lattice and uses the array v to
store the option values.
At each time step the newly calculated option values overwrite those com-
puted by the previous time step. This process is continued until the second time
step (m1 = 2) is reached. A different technique is then used, which doesn’t
overwrite the option values and thus allows the Greeks to be computed in the
vicinity of the root lattice node R. If the Greeks are not required, continue work-
ing backward through the lattice until the root node R (m1 = 0) is reached, and
the current value of the option is then given by v[0] (or its multidimensional
equivalent).
The option values at all lattice nodes in time steps 0, 1, and 2 are made acces-
sible by the Code excerpt 5.9.
P2 = 0;
for (m1 = M-1; m1 >= 2; --m1) {
P2 = P2 + 1;
P1 = P2;
for (n =0; n <= m1; ++n) {
if ((v[n] == zero) && (v[n+1] == zero))
{
hold = zero;
}
else
hold = p_d*v[n] + p_u*v[n+1];
if (is_american) {
if (put)
v[n] = MAX(hold,X-s[P1]);
else
v[n] = MAX(hold,s[P1]-X);
}
else
v[n] = hold;
P1 = P1 + 2;
}
}
Code excerpt 5.8 Computer code that works iteratively backward through the lattice
computing the option values at each time step. The array v contains the option values
computed from the previous time step, and these are overwritten with option values
computed for the current time step. The iteration stops at the second time step, since we
do not want to overwrite values in the array v which are required for calculating the
Greeks in the neighborhood of the root node.

Single asset American options
125
jj = 2;
for (m1 = 2; m1 >= 1; --m1) {
ind = M-m1+1;
for (n =0; n < m1; ++n) {
hold =
p_d*v[5-jj-m1-1] + p_u*v[5-jj-m1];
if (is_american) {
if (put)
v[5-jj] = MAX(hold,X-s[ind]);
else
v[5-jj] = MAX(hold,s[ind]-X);
}
else
v[5-jj] = hold;
--jj;
ind = ind + 2;
}
}
*value = v[5];
Code excerpt 5.9 Code fragment illustrating how the option values are stored for the
ﬁrst two time steps so that the Greeks can be computed in the vicinity of the root node R.
Table 5.4 Lattice node values in the vicinity of the root node R
Node
Time step
Asset array element
Asset value
Option array element
R
0
s[M]
S
v[5]
S
1
s[M+1]
Su
v[4]
T
1
s[M-1]
Sd
v[3]
U
2
s[M+2]
Su2
v[2]
V
2
s[M]
S
v[1]
W
2
s[M-2]
Sd2
v[0]
Computing the Greeks: Δ, Γ and Θ
We will now describe how to calculate the option’s hedge statistics (Greeks).
Let the option value and asset value at lattice node k be denoted by fk and
Sk respectively. So, for instance, ST represents the asset price at node T and fT
is the corresponding option value at node T. Table 5.4 supplies details of the
lattice node values in the vicinity of the root node R.
The computation of each Greek is now considered.
Delta
The deﬁnition of Δ is the rate of change of the option value with asset price
all other parameters remaining ﬁxed. Thus,
Δ = ∂f
∂S = f
S
where f is the change option value corresponding to the change in the asset
price S. Ideally we would like to evaluate this partial derivative at the root
node R (m1=0); however, we cannot because we need at least two lattice nodes
to compute a value. The best we can do is to evaluate the derivative at the ﬁrst
time step (m1=1) as follows:
Δ = fS −fT
SS −ST
=
v[4] −v[3]
s[M + 1] −s[M −1]

126
Computational Finance Using C and C#
Gamma
The deﬁnition of Γ is the rate of change of Δ with asset price all other para-
meters remaining ﬁxed. Thus,
Γ = ∂2f
∂S2 = ∂Δ
∂S
In order to evaluate Γ we require at least two values of Δ. The nearest this can
be achieved to the root node R is at time step 2, where we have:
Γ = Δ∗
UV −Δ∗
V W
S∗
UV −S∗
V W
with the midpoints
S∗
UV = 1
2{SU + SV }
and the values of Δ at the midpoints S∗
UV and S∗
V W denoted by Δ∗
UV and Δ∗
V W,
respectively. Since
Δ∗
UV = fU −fV
SU −SV
Δ∗
V W = fV −fW
SV −SW
and
S∗
UV −S∗
V W = 1
2{SU −SW}
we have
Δ∗
UV =
v[2] −v[1]
s[M + 2] −s[M]
Δ∗
V W =
v[1] −v[0]
s[M] −s[M −2]
The value of Γ can therefore be approximated as:
Γ =
2{Δ∗
UV −Δ∗
V W}
s[M + 2] −s[M −2]
Theta
The deﬁnition of Θ is the rate of change of option value with time all other
parameters remaining ﬁxed. Thus,
Θ = ∂f
∂t = f
t
The nearest to the root node R this can be computed is over the time interval
from time step 0 to time step 2. We then obtain the following approximation:
Θ = fV −fR
2t
= v[1] −v[5]
2t

Single asset American options
127
Code excerpt 5.10 computes the Δ, Γ , and Θ by using the approximations we
have just discussed.
Vega
The deﬁnition of V is the rate of change of the option value with volatility:
V = ∂f
∂σ
In a standard binomial lattice V cannot be computed directly. A simple approach
is to use two binomial lattices as follows:
V = fσ+σ −fσ
σ
where fσ+σ is the option value computed using a binomial lattice with volatil-
ity σ + σ, and fσ is the option value computed using another binomial lattice
with a volatility of σ; all other lattice parameters remain constant.
The implied volatility of American options can be computed using the method
outlined for European options in Section 5.4.4; however, in this case the option
value and Greeks are computed using a binomial lattice (see Code excerpt 5.11).
/* assign the value of delta (obtained from m1 = 1) */
greeks[1] = (v[4]-v[3])/(s[M+1]-s[M-1]);
/* assign the value of gamma (use the values at time step m1 = 2) */
dv1 = v[2] - v[1];
ds1 = s[M+2] - s[M];
dv2 = v[1] - v[0];
ds2 = s[M] - s[M-2];
h = 0.5*(s[M+2] - s[M-2]);
greeks[0] = ((dv1/ds1) - (dv2/ds2))/h;
/* assign the value of theta */
greeks[2] = (v[1]-*value)/(2.0*dt); /* can also write: greeks[2] = (v[1]-v[5])/(2.0*dt); */
}
Code excerpt 5.10 A code fragment that computes the values of the Greeks, Delta,
Gamma and Theta, in the vicinity of the root lattice node R.
void standard_lattice(double *value, double greeks[], double S0,_
double X, double sigma, double T, double r,
double q, long put, long is_american, long M, long *iflag)
{
/* Input parameters:
=================
S0
- the current price of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
q
- the continuous dividend yield
put
- if put is 0 then a call option, otherwise a put option
is_american
- if is_american is 0 then a European option, otherwise an American option
M
- the number of time steps
Output parameters:
==================
value
- the value of the option,
greeks[]
- the hedge statistics output as follows: greeks[0] is gamma, greeks[1]_
is delta, greeks[2] is theta,
iflag
- an error indicator.
*/
.
.
.
/* Allocate the arrays s[2*M+1], and v[M+1] */
Code excerpt 5.11.

128
Computational Finance Using C and C#
dt = T/(double)M;
t1 = sigma*sqrt(dt);
u = exp(t1);
d = exp(-t1);
a = exp((r-q)*dt);
p = (a - d)/(u - d);
if ((p < zero) || (p > 1.0)) printf ("Error p out of range\n");
discount = exp(-r*dt);
p_u = discount*p;
p_d = discount*(1.0-p);
/* assign the 2*M+1 asset values */
s[M] = S0;
for (i = 1; i <= M; ++i) {
s[M+i] = u*s[M+i-1];
s[M-i] = d*s[M-i+1];
}
/* Find out if the number of time steps, M, is odd or even */
if (((M+1)/2) == (M/2)) { /* then M is even */
if (put)
v[M/2] = MAX(X - s[M],zero);
else
v[M/2] = MAX(s[M]-X,zero);
}
/* Calculate the option values at maturity
*/
P1 = 2*M;
P2 = 0;
for (i = 0; i < (M+1)/2; ++i) {
if (put) {
v[M-i] = MAX(X - s[P1],zero);
v[i]
= MAX(X - s[P2],zero);
}
else {
v[M-i] = MAX(s[P1]-X,zero);
v[i]
= MAX(s[P2]-X,zero);
}
P1 = P1 - 2;
P2 = P2 + 2;
}
/* now work backwards through the lattice to calculate the current option value */
P2 = 0;
for (m1 = M-1; m1 >= 2; --m1) {
P2 = P2 + 1;
P1 = P2;
for (n =0; n <= m1; ++n) {
if ((v[n] == zero) && (v[n+1] == zero))
{
hold = zero;
}
else
hold = p_d*v[n] + p_u*v[n+1];
if (is_american) {
if (put)
v[n] = MAX(hold,X-s[P1]);
else
v[n] = MAX(hold,s[P1]-X);
}
else
v[n] = hold;
P1 = P1 + 2;
}
}
/* The values v[0], v[1] & v[2] correspond to the nodes for m1 = 2, v[3] & v[4] correspond_
the nodes for m1 = 1 and the
option value (*value) is the node for m1 = 0, v[5]. For a given time step v[0]_
corresponds to the lowest asset price,
v[1] to the next lowest etc.. */
jj = 2;
for (m1 = 2; m1 >= 1; --m1) {
ind = M-m1+1;
for (n =0; n < m1; ++n) {
hold =
p_d*v[5-jj-m1-1] + p_u*v[5-jj-m1];
if (is_american) {
if (put)
v[5-jj] = MAX(hold,X-s[ind]);
else
Code excerpt 5.11 (Continued).

Single asset American options
129
v[5-jj] = MAX(hold,s[ind]-X);
}
else
v[5-jj] = hold;
--jj;
ind = ind + 2;
}
}
*value = v[5];
if(greeks) {
/* assign the value of delta (obtained from m1 = 1) */
greeks[1] = (v[4]-v[3])/(s[M+1]-s[M-1]);
/*
assign the value of gamma (use the values at time step m1 = 2)
*/
dv1 = v[2] - v[1];
ds1 = s[M+2] - s[M];
dv2 = v[1] - v[0];
ds2 = s[M] - s[M-2];
h
= 0.5*(s[M+2] - s[M-2]);
greeks[0] = ((dv1/ds1) - (dv2/ds2))/h;
/* assign the value of theta */
greeks[2] = (v[1]-*value)/(2.0*dt);
/* can also write:y greeks[2] = (v[1]-v[5])/_
(2.0*dt); */
}
Code excerpt 5.11 Function to compute the value of an option using a standard binomial
lattice.
5.3.3
Binomial lattice with a control variate
The control variate technique can be used to enhance the accuracy that a stan-
dard binomial lattice gives for the value of an American vanilla option. It in-
volves using the same standard binomial lattice to value both an American op-
tion and also the equivalent European option. The Black–Scholes formula is
then used to compute the accurate value of the European option. If we assume
that the error in pricing the European option is the same as that for the Ameri-
can option, we can achieve an improved estimate for the value of the American
option.
When applied to the valuation of an American put option this can be ex-
pressed as follows:
European pricing error, E = pBS(S, E, τ) −pL(S, E, τ)
American pricing error, A = P ∗(S, E, τ) −P L(S, E, τ)
where as usual S is the current value of the asset, E is the strike price, and τ is
the maturity of the option. Also pBS(S, E, τ) is the Black–Scholes value of the
European put option, pL(S, E, τ) is the binomial lattice estimate of the Euro-
pean put option, P ∗(S, E, τ) is the (unknown) accurate value of the American
put option, and P L(S, E, τ) is the binomial lattice estimate of the American put
option.
Letting E = A we then have:
pBS(S, E, τ) −pL(S, E, τ) = P ∗(S, E, τ) −P L(S, E, τ)
which on rearrangement yields:
P ∗(S, E, τ) = pBS(S, E, τ) −pL(S, E, τ) + P L(S, E, τ)
We thus use P ∗(S, E, τ) as the improved, control variate estimate for the value
of the American put option. Of course, exactly the same approach can be used
to obtain an improved estimate for the value of an American call.

130
Computational Finance Using C and C#
Code excerpt 5.12 shows the use of the control variate technique in a standard
binomial lattice to provide improved estimates for both the value and the hedge
statistics of an American option.
/* Set up the arrays as in the standard lattice */
.
.
.
for (i = 0; i < (M+1)/2; ++i) { /* Calculate the option values at maturity
*/
if (put) {
a_v[M-i] = MAX(X - s[P1],zero);
a_v[i]
= MAX(X - s[P2],zero);
}
else {
a_v[M-i] = MAX(s[P1]-X,zero);
a_v[i]
= MAX(s[P2]-X,zero);
}
e_v[i]
= a_v[i];
e_v[M-i] = a_v[M-i];
P1 = P1 - 2;
P2 = P2 + 2;
}
/* now work backwards through the lattice to calculate the current option value */
P2 = 0;
for (m1 = M-1; m1 >= 2; --m1) {
P2 = P2 + 1;
P1 = P2;
for (n =0; n <= m1; ++n) {
if ((a_v[n] == zero) && (a_v[n+1] == zero))
hold = zero;
else
hold = p_d*a_v[n] + p_u*a_v[n+1];
if (put)
a_v[n] = MAX(hold,X-s[P1]);
else
a_v[n] = MAX(hold,s[P1]-X);
if ((e_v[n] == zero) && (e_v[n+1] == zero))
e_v[n] = zero;
else
e_v[n] = p_d*e_v[n] + p_u*e_v[n+1];
P1 = P1 + 2;
}
}
/* The American values are stored in the array a_v, and the European values in the array_
e_v. The array
indexing is the same as for the standard lattice */
jj = 2;
for (m1 = 2; m1 >= 1; --m1) {
ind = M-m1+1;
for (n =0; n < m1; ++n) {
hold =
p_d*a_v[5-jj-m1-1] + p_u*a_v[5-jj-m1];
if (put)
a_v[5-jj] = MAX(hold,X-s[ind]);
else
a_v[5-jj] = MAX(hold,s[ind]-X);
e_v[5-jj] = p_d*e_v[5-jj-m1-1] + p_u*e_v[5-jj-m1];
--jj;
ind = ind + 2;
}
}
/* v1 = American binomial approximation, v2 = European Binomial approximation, temp =_
exact (European) Black-Scholes value */
black_scholes(&temp,bs_greeks,S0,X,sigma,T,r,q,put,&iflagx);
*value = (a_v[5] - e_v[5]) + temp; /* return the control variate approximation */
if(greeks) {
/* assign the value of delta (obtained from m1 = 1) */
a_delta = (a_v[4]-a_v[3])/(s[M+1]-s[M-1]);
e_delta = (e_v[4]-e_v[3])/(s[M+1]-s[M-1]);
greeks[1] = a_delta - e_delta + bs_greeks[1];
/*
assign the value of gamma (use the values at time step m1 = 2)
*/
dv1 = a_v[2] - a_v[1];
Code excerpt 5.12.

Single asset American options
131
ds1 = s[M+2] - s[M];
dv2 = a_v[1] - a_v[0];
ds2 = s[M] - s[M-2];
h
= 0.5*(s[M+2] - s[M-2]);
a_gamma = ((dv1/ds1) - (dv2/ds2))/h;
dv1 = e_v[2] - e_v[1];
dv2 = e_v[1] - e_v[0];
e_gamma = ((dv1/ds1) - (dv2/ds2))/h;
greeks[0] = (a_gamma - e_gamma) + bs_greeks[0];
/* assign the value of theta */
a_theta = (a_v[1]-a_v[5])/(2.0*dt);
e_theta = (e_v[1]-e_v[5])/(2.0*dt);
greeks[2] = (a_theta - e_theta) + bs_greeks[2];
}
Code excerpt 5.12 Function to compute the value and hedge statistics of an American
option using a binomial lattice with a control variate.
Finally we should mention that the control variate technique does not just
apply to American vanilla options. The method is quite general and can be used
to obtain improved estimates for any integral (or exotic option) so long as an
accurate (closed form) solution of a similar integral is known. One common
use of the control variate method is to improve the accuracy of Monte Carlo
estimates.
5.3.4
The Binomial lattice with BBS and BBSR
Here we consider the Binomial Black–Scholes (BBS) method and also the Bino-
mial Black–Scholes method with Richardson extrapolation (BBSR) (see Broadie
and DeTemple (1996)). As with the control variate method discussed in the
previous section, both of these techniques can be used in conjunction with a
standard binomial lattice to improve the computed results.
We will ﬁrst discuss the BBS method.
The BBS method
The BBS method is identical to the standard binomial lattice except that in the
last time step (that is just before option maturity) the Black–Scholes formula is
used to calculate the option values at maturity. For an n time step binomial lat-
tice this involves evaluating the Black–Scholes formula at each of the n nodes in
the penultimate time step; see Fig. 5.1. In Code excerpt 5.13 we deﬁne the func-
tion bs_lattice which incorporates the BBS method into a standard binomial
lattice. The reader will have noticed that bbs_lattice is rather lax concern-
ing the amount of storage that is required; see Section 5.3.2. It uses an array of
size LN n rather than LSn to store the lattice asset prices; the modiﬁcation to
use an array of size LSn is left as an exercise.
The beneﬁts of using the BBS approach to price an American call are illus-
trated in Fig 5.3. Here we compare the results obtained using the function
bbs_lattice with those computed by the function standard_ lattice,
the standard binomial lattice of Code excerpt 5.11. It can be clearly seen that
the BBS method is signiﬁcantly more accurate than the standard binomial lattice
approach, in which option pricing error exhibits pronounced oscillations.

132
Computational Finance Using C and C#
void bbs_lattice(double *value, double greeks[], double S0, double X, double sigma, double T,_
double r,
double q, long put, long M, long *iflag)
{
/* Input parameters:
=================
S0
- the current price of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
q
- the continuous dividend yield
put
- if put is 0 then a call option, otherwise a put option
M
- the number of time steps
Output parameters:
==================
value
- the value of the option, greeks[] - the hedge statistics output as follows:_
greeks[0] is gamma,
greeks[1] is delta, greeks[2] is theta,
iflag
- an error indicator.
*/
.
.
.
/* allocate the arrays s[((M+2)*(M+1))/2], and v[M+1] */
dt = T/(double)M;
t1 = sigma*sqrt(dt);
u = exp(t1);
d = exp(-t1);
a = exp((r-q)*dt);
p = (a - d)/(u - d);
if ((p < zero) || (p > 1.0)) return; /* Invalid probability */
discount = exp(-r*dt);
p_u = p*discount;
p_d = (1.0-p)*discount;
jj = 0;
s[0] = S0;
/* The "higher" the value of jj, at a given time instant, the lower the
value of the_
asset price */
for (m1 = 1; m1 <= M-1; ++m1) { /* Calculate asset values up to (M-1)th time step */
for (n = m1; n >= 1; --n) {
++jj;
s[jj] =
u*s[jj-m1];
}
++jj;
s[jj] = d*s[jj-m1-1];
}
for (n = 0; n <= M-1; ++n) { /* Use Black-Scholes for the final step */
black_scholes(&temp,NULL,s[jj],X,sigma,dt,r,q,put,&iflagx);
v[n] = temp;
--jj;
}
for (m1 = M-1; m1 >= 3; --m1) { /* work backwards through the lattice */
for (n =0; n < m1; ++n) {
if ((v[n] == zero) && (v[n+1] == zero))
{
hold = zero;
}
else
hold = p_d*v[n] + p_u*v[n+1];
if (is_american) {
if (put)
v[n] = MAX(hold,X-s[jj]);
else
v[n] = MAX(hold,s[jj]-X);
}
else
v[n] = hold;
--jj;
}
}
/* The values v[0], v[1] & v[2] correspond to the nodes for m1 = 2, v1 & v2 correspond to_
the nodes for m1 = 1 and the
option value (*value) is the node for m1 = 0. For a given time step v[0] corresponds to_
the lowest asset price,
v[1] to the next lowest etc.. */
Code excerpt 5.13.

Single asset American options
133
hold = p_d*v[0] + p_u*v[1];
if (is_american) {
if (put)
v1 = MAX(hold,X-s[jj]);
else
v1 = MAX(hold,s[jj]-X);
}
else
v1 = hold;
--jj;
hold = p_d*v[1] + p_u*v[2];
if (is_american) {
if (put)
v2 = MAX(hold,X-s[jj]);
else
v2 = MAX(hold,s[jj]-X);
}
else
v2 = hold;
--jj;
hold = p_d*v1 + p_u*v2;
if (is_american) {
if (put)
*value = MAX(hold,X-s[0]);
else
*value = MAX(hold,s[0]-X);
}
else
*value = hold;
if(greeks) {
/* assign the value of delta (obtained from m1 = 1) */
greeks[1] = (v2-v1)/(s[1]-s[2]);
/*
assign the value of gamma (use the values at time step m1 = 2)
*/
dv1 = v[2] - v[1];
ds1 = s[3] - s[4];
dv2 = v[1] - v[0];
ds2 = s[4] - s[5];
h
= 0.5*(s[3] - s[5]);
greeks[0] = ((dv1/ds1) - (dv2/ds2))/h;
/* assign the value of theta */
greeks[2] = (v[1]-*value)/(2.0*dt);
}
}
Code excerpt 5.13 The function bbs_lattice which incorporates the BBS method
into a standard binomial lattice. The Black–Scholes formula is evaluated by using the
function black_scholes, given in Code excerpt 4.1.
The BBSR method
The BBSR method applies two point Richardson extrapolation to the com-
puted BBS values; for more information concerning Richardson extrapolation
see Marchuk and Shaidurov (1983). In this method the option price estimates
from two BBS lattices, with differing numbers of time steps, are combined to
form an improved estimate.
Here we use the following BBSR scheme to compute the value of an American
call option:
CBBSR(S, E, τ, 2n) = 4
3CBBS(S, E, τ, 2n) −1
3CBBS(S, E, τ, n)
(5.3.24)
where S is the current asset value, E is the strike price, τ is the option maturity,
CBBS(S, E, τ, n) is the value of the call option computed using a BBS lattice with
n time steps, CBBS(S, E, τ, 2n) is the value of the call option computed using a

134
Computational Finance Using C and C#
Figure 5.3 The error in the estimated value, est_val, of an American call using both a
standard binomial lattice and BBS binomial lattice. The parameters used were: T = 1.0,
S = 105.0, E = 105.0, r = 0.1, q = 0.02, σ = 0.3. The very accurate value (acc_val) was
16.1697, and was computed using a 6000 step standard binomial lattice. The error in
the estimated value was obtained as est_val −acc_val.
BBS lattice with 2n time steps, and CBBSR(S, E, τ, 2n) is the BBSR estimate. We
compute the value of an American put using:
PBBSR(S, E, τ, 2n) = 4
3PBBS(S, E, τ, 2n) −1
3PBBS(S, E, τ, n)
(5.3.25)
Figure 5.4 displays the computed BBSR results for an American call option
with S = 105.0, τ = 1.0, E = 105.0, q = 0.02 and σ = 0.3.
In Tables 5.5 and 5.6 the errors in computing both an American put and an
American call option are presented; the methods used are the standard binomial
lattice, the BBS lattice and the BBSR lattice. It can be seen that the BBSR lattice
gives the most accurate results. This is not surprising since, from Eqs. (5.3.24)
and (5.3.25) we see that when we use either an n time step standard binomial
lattice or an n time step BBS lattice the corresponding BBSR estimate is obtained
using both an n time step BBS lattice and also a 2n time step BBS lattice. One way
of checking whether Richardson extrapolation is providing increased accuracy
is to compare the results for a 2n time step BBS latticewith those for an n time
step BBSR lattice. Inspection of the results shows that Richardson extrapolation
has in fact led to an improvement. For example, in Table 5.5 the error for a 160

Single asset American options
135
Figure 5.4 The error in the estimated value, est_val, of an American call, using a BBSR
binomial lattice. The parameters used were: T = 1.0, S = 105.0, E = 105.0, r = 0.1,
q = 0.02, σ = 0.3. The very accurate value (acc_val) was 16.1697, and was computed
using a 6000 step standard binomial lattice. The error in the estimated value was ob-
tained as est_val −acc_val.
time step BBS lattice is 5.0869e-003, while that for an 80 time step BBSR
lattice is 3.5725e-003; in Table 5.6 the error for an 80 time step BBS lattice
is 6.3858e-003, and that for a 40 time step BBSR lattice is 3.5725e-003.
5.4
Grid methods for vanilla options
5.4.1
Introduction
In Section 5.3 we discussed the use of binomial lattice methods for valuing both
European and American options. The lattice methods we described have the
advantage that they are fairly easy to implement and can value simple options,
such as vanilla puts and calls, reasonably accurately. The use of up and down
jump probabilities at the lattice nodes is also an appealing feature, since they
are directly related to the stochastic process which is being modelled. However,
lattice techniques have the following drawbacks:
• They require small time steps to ensure numerical stability

136
Computational Finance Using C and C#
Table 5.5 The pricing errors for an American call option computed by: a standard
binomial lattice, a BBS lattice and also a BBSR lattice
n steps
Standard lattice
BBS lattice
BBSR lattice
20
−1.5075e−001
3.6187e−002
1.2754e−002
30
−1.0057e−001
2.4526e−002
8.6771e−003
40
−7.5382e−002
1.8612e−002
6.6361e−003
50
−6.0244e−002
1.5036e−002
5.4109e−003
60
−5.0141e−002
1.2639e−002
4.5939e−003
70
−4.2919e−002
1.0922e−002
4.0103e−003
80
−3.7499e−002
9.6302e−003
3.5725e−003
90
−3.3282e−002
8.6236e−003
3.2320e−003
100
−2.9908e−002
7.8171e−003
2.9596e−003
110
−2.7146e−002
7.1565e−003
2.7367e−003
120
−2.4844e−002
6.6053e−003
2.5509e−003
130
−2.2896e−002
6.1385e−003
2.3938e−003
140
−2.1226e−002
5.7382e−003
2.2590e−003
150
−1.9778e−002
5.3909e−003
2.1423e−003
160
−1.8511e−002
5.0869e−003
2.0401e−003
170
−1.7393e−002
4.8186e−003
1.9500e−003
180
−1.6399e−002
4.5799e−003
1.8698e−003
190
−1.5510e−002
4.3663e−003
1.7981e−003
200
−1.4710e−002
4.1740e−003
1.7336e−003
The pricing error is deﬁned as estimated value −accurate value, where the accurate
value, 16.1697, was obtained by using a 6000 step standard binomial lattice. The option
parameters used were: T = 1.0, S = 105.0, E = 105.0, r = 0.1, q = 0.02, and σ = 0.3.
• There is little control over where the lattice nodes are located. This can lead
to very poor accuracy when valuing certain types of options; for example,
those with barriers at particular asset prices.
One method of avoiding these limitations is through the use of ﬁnite-difference
grids. Although this approach no longer has the probabilistic interpretation of
the binomial lattice it has the following advantages:
• Fewer time steps are required to ensure numerical stability
• There is complete control over the placement of grid lines, and their associ-
ated grid nodes.
5.4.2
Uniform grids
The Black–Scholes equation for the value of an option f is given by:
∂f
∂t + (r −q)S ∂f
∂S + 1
2σ 2S2 ∂2f
∂S2 = rf
(5.4.1)
We want to solve this equation over the duration of the option, that is from
the current time t to the maturity of the option at time t + τ. To do this we

Single asset American options
137
Table 5.6 The pricing errors for an American put option computed by: a standard
binomial lattice, a BBS lattice and also a BBSR lattice
n steps
Standard lattice
BBS lattice
BBSR lattice
20
−6.1971e−002
2.3917e−002
7.6191e−003
30
−4.1648e−002
1.6800e−002
6.0465e−003
40
−3.2264e−002
1.1694e−002
4.6165e−003
50
−2.6538e−002
8.4790e−003
4.2654e−003
60
−2.1069e−002
8.7348e−003
3.2946e−003
70
−1.8298e−002
7.2743e−003
2.9633e−003
80
−1.5885e−002
6.3858e−003
2.6088e−003
90
−1.3977e−002
5.9417e−003
2.2099e−003
100
−1.2612e−002
5.3188e−003
2.1793e−003
110
−1.1338e−002
4.9652e−003
2.0992e−003
120
−1.0239e−002
4.6547e−003
1.8723e−003
130
−9.5208e−003
4.1505e−003
1.8808e−003
140
−8.6142e−003
4.0411e−003
1.7505e−003
150
−8.2382e−003
3.6020e−003
1.7341e−003
160
−7.5811e−003
3.5531e−003
1.6411e−003
170
−7.1097e−003
3.3726e−003
1.5507e−003
180
−6.7887e−003
3.1428e−003
1.5478e−003
190
−6.3033e−003
3.1345e−003
1.4134e−003
200
−6.0276e−003
2.9642e−003
1.3973e−003
The pricing error is deﬁned as estimated value −accurate value, where the accurate
value, 9.2508, was obtained by using a 6000 step standard binomial lattice. The option
parameters used were: T = 1.0, S = 105.0, E = 105.0, r = 0.1, q = 0.02, and σ = 0.3.
will use a grid in which the asset price S takes ns uniformly spaced values,
Sj = jS, j = 0, . . . , ns −1, where S is the spacing between grid points. If
Smax is the maximum asset value we want to represent, then the grid spacing,
S∗, can be simply calculated as:
S∗= Smax
ns −1
(5.4.2)
However, since we would like to solve the option values and Greeks at the
current asset price S0, we would also like an asset grid line to coincide with
the current asset price. This avoids the use of interpolation which is necessary
when the asset value does not correspond to a grid line. The method by which
we achieve this is outlined in Code excerpt 5.12. Here the user supplies the
function opt_gfd with values for Smax and ns −1 from which S∗is computed
using Eq. (5.4.2). We then ﬁnd the integer, n1, that is just below (or equal to)
the value S0/S∗, and use this to obtain a new grid spacing S = S0/n1. This
leads to the new asset price discretization Sj = jS, j = 0, . . . , ns −1, where
we have now ensured that Sn1 = S0.

138
Computational Finance Using C and C#
The user also supplies the function opt_gfd with the number of time inter-
vals for the grid. When there are nt time intervals, the grid has nt + 1 uniformly
spaced time instants, ti = it, i = 0, . . . , nt, and the time step is simply:
t = τ
nt
(5.4.3)
As with the binomial lattice methods we will solve the equation backwards in
time from maturity (at time t + τ) to the present (time t). So as we solve the
equation the time index will start at i = nt (time t + τ) and decrease to i = 0
(current time t).
Here we discuss the grid method of solving the Black–Scholes equation in
terms of:
• The ﬁnite-difference approximation
• The boundary conditions
• Computation of the option values at a given time instant
• Backwards iteration and early exercise
Each of these aspects will now be considered in turn.
The ﬁnite-difference approximation
The option value corresponding to the grid node at which ti = it and Sj =
jS will be denoted by fi,j. We will approximate the partial derivative of fi,j
with respect to time simply as:
∂f
∂t = fi+1,j −fi,j
t
(5.4.4)
For the other terms in Eq. (5.4.1) we will use the weighted, Θm, method. This
technique involves selecting an appropriate choice for Θm in the range 0 ⩽
Θm ⩽1 so that the contribution from node (i, j) is a weighted sum involving
the values at nodes (i, j) and (i+1, j). For instance, the term rf |i,j in Eq. (5.4.1)
is approximated as:
rf |i,j = r

Θmfi+1,j + (1 −Θm)fi,j

(5.4.5)
and the term ∂f
∂S |i,j in Eq. (5.4.1) is approximated as:
∂f
∂S
    
i,j
=

Θm
∂f
∂S
    
i+1,j
+ (1 −Θm)∂f
∂S
    
i,j

(5.4.6)
Using this method we thus obtain, at node (i, j), the following discretized ver-
sion of Eq. (5.4.1):
fi+1,j −fi,j
t
+ (r −q)Sj

Θmf ′
i+1,j + Θ∗
mf ′
i,j

+ 1
2σ 2S2
j

Θmf ′′
i+1,j + Θ∗
mf ′′
i,j

= r

Θmfi+1,j + Θ∗
mfi,j

(5.4.7)

Single asset American options
139
where for compactness we have written Θ∗
m = 1 −Θm, and denote the partial
derivatives w.r.t. S at node (i, j) as: f ′
i,j = ∂f
∂S |i,j and f ′′
i,j = ∂2f
∂S2 |i,j.
Finite-difference approximations for these derivatives can be obtained by
considering a Taylor expansion about the point fi,j. We proceed as fol-
lows:
fi,j+1 = fi,j + f ′
i,jS + 1
2f ′′
i,j(S)2
(5.4.8)
fi,j−1 = fi,j −f ′
i,jS + 1
2f ′′
i,j(S)2
(5.4.9)
Subtracting Eq. (5.4.9) from Eq. (5.4.8) we obtain:
fi,j+1 −fi,j−1 = 2f ′
i,jS
and so
f ′
i,j = fi,j+1 −fi,j−1
2S
(5.4.10)
Adding Eqs. (5.4.9) and (5.4.8) we obtain:
fi,j+1 + fi,j−1 = 2fi,j + f ′′
i,jS2
which gives:
f ′′
i,j = fi,j+1 −2fi,j + fi,j−1
S2
(5.4.11)
The complete ﬁnite-difference approximation to the Black–Scholes equation can
then be found by substituting the approximations for the ﬁrst and second par-
tial derivatives, given in Eqs. (5.4.10) and (5.4.11), into (5.4.7). We thus ob-
tain:
rt

Θmfi+1,j + Θ∗
mfi,j

= fi+1,j −fi,j + (r −q)jtA1
2
+ σ 2j2tA2
2
(5.4.12)
where we have used the fact that Sj = jS, and for compactness have deﬁned
the terms:
A1 = Θmfi+1,j+1 −Θmfi+1,j−1 + Θ∗
mfi,j+1 −Θ∗
mfi,j−1
and
A2 = Θmfi+1,j+1 + Θmfi+1,j−1 −2Θmfi+1,j + Θ∗
mfi,j+1
+ Θ∗
mfi,j−1 −2Θ∗
mfi,j
Collecting like terms in fi,j, fi+1,j, etc. results in:
B1fi,j−1 + B2fi,j + B3fi,j+1 + C1fi+1,j−1 + C2fi+1,j
+ C3fi+1,j+1 = 0
(5.4.13)

140
Computational Finance Using C and C#
where
B1 = −Θ∗
m(r −q)jt
2
+ Θ∗
mσ 2j2t
2
B2 = −1 −rtΘ∗
m −Θ∗
mσ 2j2t
B3 = Θ∗
m(r −q)jt
2
+ Θ∗
mσ 2j2t
2
C1 = Θmσ 2j2t
2
−Θm(r −q)jt
2
C2 = 1 −rtΘm −Θmσ 2j2t
C3 = Θm(r −q)jt
2
+ Θmσ 2j2t
2
Since we are solving the equation backwards in time and we want to de-
termine the option values at time index i from the known option values
(fi+1,j+1, fi+1,j and fi+1,j−1) at time index i + 1. This can be achieved by
rearranging Eq. (5.4.13) as follows:
ajfi,j−1 + bjfi,j + cjfi,j+1 = Ri+1,j
(5.4.14)
where the right-hand side, Ri+1,j, is:
Ri+1,j = ¯ajfi+1,j−1 + ¯bjfi+1,j + ¯cjfi+1,j+1
(5.4.15)
The six coefﬁcients are:
aj = (1 −Θm)t
2

(r −q)j −σ 2j2
(5.4.16)
bj = 1 + (1 −Θm)t

r + σ 2j2
(5.4.17)
cj = −(1 −Θm)t
2

(r −q)j + σ 2j2
(5.4.18)
¯aj = −Θm
t
2

(r −q)j −σ 2j2
(5.4.19)
¯bj = 1 −Θmt

r + σ 2j2
(5.4.20)
¯cj = Θm
t
2

(r −q)j + σ 2j2
(5.4.21)
For each value of j Eq. (5.4.14) gives us a relationship between three option
values, fi+1,j−1, fi+1,j, fi+1,j+1 at time index i + 1, and three option values
fi,j−1, fi,j, fi,j+1 at time index i.
This situation is shown in Fig. 5.5 where we have labelled the grid nodes that
contribute to the option value f5,5 at grid node E. These are the known option
values:
node A: f6,6,
node B: f6,5,
and
node C: f6,4

Single asset American options
141
and the unknown option values
node D: f5,6,
node E: f5,5,
and
node F: f5,4.
Before we solve Eq. (5.4.14), we will brieﬂy consider its characteristics for dif-
ferent values of the weight parameter Θm.
When Θm = 1 the values of the coefﬁcients in Eq. (5.4.14) are aj = cj = 0,
and bj = 1. This means that Eq. (5.4.14) reduces to:
fi,j = ¯ajfi+1,j−1 + ¯bjfi+1,j + ¯cjfi+1,j+1
This is termed the explicit method, and it can be seen that the unknown option
value fi,j, at the grid node (i, j) is just a weighted sum of the (known) op-
tion values fi+1,j−1, fi+1,j, fi+1,j+1. This is the simplest situation to deal with
and actually corresponds to a trinomial lattice. However, it has poor numerical
properties and usually requires a very small step size to obtain accurate results;
see Smith (1985).
When Θm ̸= 1, the unknown option value fi,j depends not only on the
known option values fi+1,j−1, fi+1,j, fi+1,j+1 (as in the explicit method above),
but also on the neighboring unknown option values fi,j−1 and fi,j+1. It is
now necessary to solve a set of simultaneous equations in order to com-
pute the value fi,j. This is therefore called an implicit method; see Smith
(1985).
The implicit method Θm
= 0 is also called the fully implicit method,
since now the unknown value fi,j only depends on the neighboring values
fi,j−1, fi,j+1, and its previous value, fi+1,j, at time step i + 1. This can
be shown by substituting Θm = 0 in Eqs. (5.4.16)–(5.4.21). We then ob-
tain ¯aj
=
¯cj
= 0, and ¯bj
= 1, which means that Eq. (5.4.14) reduces
to:
ajfi,j−1 + bjfi,j + cjfi,j+1 = fi+1,j
The implicit method Θm = 0.5 is also termed the Crank–Nicolson method.
This method, ﬁrst used by John Crank and Phyliss Nicolson in 1946 (see
Crank and Nicolson (1947)), computes fi,j by giving equal weight to the con-
tributions from time step i + 1 and time step i. Substituting Θm = 0.5 in
Eq. (5.4.16) to Eq. (5.4.21) we obtain the following Crank–Nicolson coefﬁ-
cients:
aj = −¯aj = t
4

(r −q)j −σ 2j2
bj = 1 + t
2

r + σ 2j2
¯bj = 1 −t
2

r + σ 2j2
cj = −¯cj = −t
4

(r −q)j + σ 2j2
We notice that since we are solving backwards in time, but index time in the
forward direction, our values of Θm corresponding to implicit and explicit are

142
Computational Finance Using C and C#
different from those normally used. For example, in Smith (1985) Θm = 0 is
the explicit method and Θm = 1 is the implicit method; the Crank–Nicolson
method is still Θm = 0.5.
The boundary conditions
In order to solve Eq. (5.4.14) at time instant it we need to obtain the option
values at: the upper asset boundary, the lower asset boundary, and the initial
values that are speciﬁed at option maturity.
Here we calculate the boundary values by using the time independent payoff,
pj, at the jth asset index within the grid. If E is the strike price then vanilla call
options have payoffs:
pj = max(jS −E, 0),
j = 0, . . . , ns −1,
and vanilla put options have payoffs:
pj = max(E −jS, 0),
j = 0, . . . , ns −1
Upper asset boundary values
At the upper boundary j = ns −1 and (ns −1)S = Smax; where we note that
for the grid to be useful we require Smax > E.
Here we assume that Smax > E and so for call options:
pns−1 = Smax −E
and for put options:
pns−1 = 0
The option value at the upper boundary, denoted by fBU, is set to pns−1, and
we have fi,ns−1 = fBU, i = 0, . . . , nt.
Lower asset boundary values
At the lower boundary j = 0, and the value of jS is zero.
So for call options:
p0 = 0
and for put options:
p0 = E
The option value at the lower boundary, denoted by fBL, is set to p0, and we
have fi,0 = fBL, i = 0, . . . , nt.
Boundary values at option maturity
At option maturity (i = nt) the initial option (boundary) values are the pre-
viously mentioned payouts. If E is the strike price then for vanilla call op-
tions:
fnt,j = max(jS −E, 0),
j = 0, . . . , ns −1,

Single asset American options
143
and for vanilla put options:
fnt,j = max(E −jS, 0),
j = 0, . . . , ns −1
This is illustrated in Fig. 5.5 for a vanilla put option with current asset value
S0 = 20, strike, E = 25, and maturity τ = 2. The grid asset price spacing is
S = 5, and the time increment is t = 0.2. At option maturity, corresponding
to time index i = 10, the value of the put option is zero for all asset indices
j ⩾5.
Computation of the option values at a given time instant
Having found the option boundary values, we are now in a position to solve
Eq. (5.4.14) at time instant ti = it.
First we note that since fi,0 = fBL and fi,ns−1 = fBU Eq. (5.4.14) only needs
to be solved for values of the asset index j in the range j = 1 to j = ns −2.
We now deal with the following situations:
• Case 1: j = 1, the asset grid line just above the lower boundary
• Case 2: j = ns −2, the asset grid line just below the upper boundary
• Case 3: all other asset grid lines not included in Case 1 or Case 2
and consider the form that Eq. (5.4.14) takes under each condition.
Case 1: j = 1
Substituting j = 1 into Eq. (5.4.14) we obtain:
a1fi,0 + b1fi,1 + c1fi,2 = ¯a1fi+1,0 + ¯b1fi+1,1 + ¯c1fi+1,2
Now, since fi,0 = fBL, this becomes:
b1fi,1 + c1fi,2 = (¯a1 −a1)fBL + ¯b1fi+1,1 + ¯c1fi+1,2
or equivalently:
b1fi,1 + c1fi,2 = Ri+1,1
(5.4.22)
where
Ri+1,1 = (¯a1 −a1)fBL + ¯b1fi+1,1 + ¯c1fi+1,2
(5.4.23)
Case 2: j = ns −2
Substituting j = ns −1 into Eq. (5.4.14) we obtain:
ans−2fi,ns−3 + bns−2fi,ns−2 + cns−2fi,ns−1
= ¯ans−2fi+1,ns−3 + ¯bns−2fi+1,ns−2 + ¯cns−2fi+1,ns−1
Since fi,ns−1 = fBU this gives:
ans−2fi,ns−3 + bns−2fi,ns−2
= ¯ans−2fi+1,ns−3 + ¯bns−2fi+1,ns−2 + (¯cns−2 −cns−2)fBU

144
Computational Finance Using C and C#
or equivalently:
ans−2fi,ns−3 + bns−2fi,ns−2 = Ri+1,ns−2
(5.4.24)
where
Ri+1,ns−2 = ¯ans−2fi+1,ns−3 + ¯bns−2fi+1,ns−2 + (¯cns−2 −cns−2)fBU (5.4.25)
Case 3
In this case the boundary values do not enter into the expressions, and we
simply restate Eq. (5.4.14) as:
ajfi,j−1 + bjfi,j + cjfi,j+1 = Ri+1,j,
j = 3, . . . , ns −3,
(5.4.26)
where as before the right-hand side, Ri+1,j, is:
Ri+1,j = ¯ajfi+1,j−1 + ¯bjfi+1,j + ¯cjfi+1,j+1
(5.4.27)
We can now gather all the information in Eqs. (5.4.23)–(5.4.27) and represent
it by the following tridiagonal system:
⎛
⎜⎜⎜⎜⎜⎝
b1
c1
0
0
0
0
a2
b2
c2
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0
ans−3
bns−3
cns−3
0
0
0
0
ans−2
bns−2
⎞
⎟⎟⎟⎟⎟⎠
⎛
⎜⎜⎜⎜⎜⎝
fi,1
fi,2
.
.
fi,ns−3
fi,ns−2
⎞
⎟⎟⎟⎟⎟⎠
=
⎛
⎜⎜⎜⎜⎜⎝
Ri+1,1
Ri+1,2
.
.
Ri+1,ns−3
Ri+1,ns−2
⎞
⎟⎟⎟⎟⎟⎠
(5.4.28)
In matrix notation Eq. (5.4.28) can be written as:
Ax = R
(5.4.29)
where A is the (ns −2) × (ns −2) tridiagonal matrix containing the known
coefﬁcients aj, j = 2, . . . , ns −2, bj, j = 1, . . . , ns −2, and cj, j = 1, . . . , ns −3.
The vector R denotes the known right-hand side, Ri+1,j, j = 1, . . . , ns −2,
and the vector x contains the unknown option values that we wish to compute,
fi,j, j = 1, . . . , ns −2.
It is well known that, if matrix A is nonsingular, Eq. (5.4.29) can be solved
using an LU decomposition. Here we factorize the n × n matrix A as:
A = LU
where L is an n × n lower triangular matrix with 1s on the diagonal and U is
an n × n upper triangular matrix. We illustrate the LU decomposition for a full
4 × 4 matrix below:

Single asset American options
145
⎛
⎜⎝
a1,1
a1,2
a1,3
a1,4
a2,1
a2,2
a2,3
a2,4
a3,1
a3,2
a3,3
a3,4
a4,1
a4,2
a4,3
a4,4
⎞
⎟⎠
=
⎛
⎜⎝
1
0
0
0
l2,1
1
0
0
l3,1
l3,2
1
0
l4,1
l4,2
l4,3
1
⎞
⎟⎠
⎛
⎜⎝
u1,1
u1,2
u1,3
u1,4
0
u2,2
u2,3
u2,4
0
0
u3,3
u3,4
0
0
0
u4,4
⎞
⎟⎠
(5.4.30)
If A is a tridiagonal matrix then the LU decomposition takes the simpler form:
⎛
⎜⎝
a1,1
a1,2
0
0
a2,1
a2,2
a2,3
0
0
a3,2
a3,3
a3,4
0
0
a4,3
a4,4
⎞
⎟⎠
=
⎛
⎜⎝
1
0
0
0
l2,1
1
0
0
0
l3,2
1
0
0
0
l4,3
1
⎞
⎟⎠
⎛
⎜⎝
u1,1
u1,2
0
0
0
u2,2
u2,3
0
0
0
u3,3
u3,4
0
0
0
u4,4
⎞
⎟⎠
(5.4.31)
where it can be seen that now both L and U are bidiagonal.
Once the LU decomposition of A has been found, it is possible to solve for
x in Eq. (5.4.29) by using a two stage method (see for example Golub and Van
Loan (1989)). Here forward elimination is used to solve Ly = R, and then
back-substitution is applied to Ux = y. We can thus write the procedure as:
Ax = (LU)x = L(Ux) = Ly = R
We will now provide code excerpts which show how to solve the (ns −2) ×
(ns −2) tridiagonal system represented by Eq. (5.4.29). These excerpts are in
fact contained within the larger Code excerpt 5.18, which displays the complete
C code for the option pricing function opt_gfd. If the reader requires more
detail concerning the precise code used for option pricing, then this code should
be consulted. (It should be noted that in Code excerpt 5.18, time is indexed
using j and asset price using index i. We have modiﬁed the indices for the
smaller code excerpts given below so that, as might be expected, time is indexed
using i, and asset price using j. The author apologizes for any inconvenience
this may cause.) Here, for brevity, we will assume that all the required arrays
have already been allocated and loaded with the relevant information.
First we need to compute the LU decomposition of the tridiagonal matrix A.
The code to achieve this is given in Code excerpt 5.14. Here we use the following
three arrays to store the elements of the tridiagonal matrix A: array b contains
the diagonal elements, array c contains the upper diagonal elements, and array a
holds the lower diagonal elements.
It should be noted we do not explicitly compute the elements of the matrix L.
This is because all the diagonal elements of L are known to be 1, and the sub-
diagonal elements of L can be computed from the diagonal elements of U by
using l[j] = a[j]/u[j-1]. Also we do not need to compute the upper di-
agonal elements of U since they are known to be the same as the upper diagonal

146
Computational Finance Using C and C#
u[1] = b[1];
if (u[1] == 0.0) printf ("ERROR in array u \n");
for(j=2; j <=ns-2; ++j) {
u[j] = b[j] - a[j]*c[j-1]/u[j-1];
if (u[j] == 0.0) printf ("ERROR in array u \n");
}
Code excerpt 5.14 Computer code that calculates the diagonal elements of the matrix U,
in an LU decomposition of a tridiagonal matrix A. The elements of matrix A are stored
in the following arrays: array b contains the diagonal elements, array c contains the
upper diagonal elements, and array a holds the lower diagonal elements. The diagonal
elements of U are stored in the array u for later use, in Code excerpts 5.15 and 5.16.
work[1] = rhs[1];
for(j=2; j<=ns-2; ++j) {
work[j] = rhs[j] - a[j]*work[j-1]/u[j-1];
}
Code excerpt 5.15 Computer code that uses forward elimination to solve the lower tri-
angular system Ly = R, where y is stored in the array work.
opt_vals[ns-2] = work[ns-2]/u[ns-2];
for(j = ns-2; j >= 1; --j)
opt_vals[j] = (work[j] - c[j]*opt_vals[j+1])/u[j];
Code excerpt 5.16 Computer code that uses back-substitution to solve the upper trian-
gular system Ux = y. At time instant ti = it, the elements of x are the calculated option
values fi,j, i = 1, . . . , ns−2.
elements of the original matrix A, and are contained in the array c; see for
example Hager (1988).
Having computed the LU decomposition we can now solve the lower tri-
angular system Ly = R using forward elimination; this is shown in Code ex-
cerpt 5.15.
In Code excerpt 5.15 we make use of the following two arrays: the array rhs
which is used to store the elements of the right-hand side R, and the array work
which is both used as workspace and to store the computed solution vector y.
As previously mentioned the subdiagonal elements of L are given by l[j] =
a[j]/u[j-1]. This means that in Code excerpt 5.15, the line:
work[j] = rhs[j] −a[j] ∗work[j −1]/u[j −1];
is in fact equivalent to:
work[j] = rhs[j] −l[j] ∗work[j −1];
where l[j],j=2,..,ns-2, contains the subdiagonal elements of L, if we had
(needlessly) decided to allocate space for an extra array called l.
We are now in a position to solve the triangular system Ux = y by using back-
substitution. The code to achieve this is given in Code excerpt 5.16. Here the
array work contains the previously computed values of y, the diagonal elements
of U are contained in the array u, and (as previously mentioned) the upper
diagonal elements of U are stored in the array a.

Single asset American options
147
In Code excerpt 5.16 the array opt_vals contains the solution vector x. As
its name suggests the contents of the array opt_vals are in fact the computed
option values, fi,j, j = 1, . . . , ns −2, in Eq. (5.4.28) and represent the solution
of the Black–Scholes partial differential equation at time instant ti = it based
on the previously computed option values fi+1,j, j = 1, . . . , ns −2.
Backwards iteration and early exercise
The Black–Scholes equation can be solved over the time interval t to t+τ by iter-
atively solving Eq. (5.4.28). We iterate backwards in time by solving Eq. (5.4.28)
at the ith time step and then using the computed values to solve Eq. (5.4.28) for
the (i −1)th time step. The option values at current time t are obtained when
time index i = 0 is reached. It can be seen that the grid method yields ns −2
option values, f0,j, j = 1, . . . , ns −2, which correspond to the current asset
prices:
Sj
0 = jS,
j = 1, . . . , ns −2
As previously mentioned the asset price S0 coincides with grid index j = n1.
Therefore S0 = Sn1
0 , and the option value for the current asset price S0 is given
by f0,n1.
This is in contrast to the lattice methods discussed in Chapter 4, which yield
a single option value corresponding to the root node.
The option values obtained using the grid methods we have just described
are for vanilla European options. However, vanilla European options can
be more accurately valued by using the Black–Scholes option pricing for-
mula discussed in Chapter 4. The importance of ﬁnite difference grids is
that, by slightly modifying our backward iterative method, we can take
into account the possibility of early exercise, and thus price American op-
tions.
This can be achieved by using Code excerpt 5.17 to modify the option prices
contained in the array opt_vals as follows:
if (put) {
/* a put */
for(j=1; j<=ns-2; ++j)
opt_vals[j] = MAX(opt_vals[j],E-s[j]);
}
else { /* a call */
for(j=1; j<=ns-2; ++j)
opt_vals[j] = MAX(opt_vals[j],s[j]-E);
}
Code excerpt 5.17 Computer code that modiﬁes the computed option values contained
in array opt_vals to include the possibility of early exercise; this is required if we are
to determine the value of American options. Here s[j] contains the asset value at asset
index j, opt_vals[j] contains the option value (computed by Code excerpt 5.16) at
asset index j, and E is the strike price.

148
Computational Finance Using C and C#
Figure 5.5 An example uniform grid, which could be used to estimate the value of a
vanilla option which matures in two years’ time. The grid parameters are: ns = nt = 10,
t = 0.2, S = 5, and Smax = 50. The option parameters are E = 25, S0 = 20, and
τ = 2.0. As usual we denote the grid node option values by fi,j, where i is the time index
and j is the asset index. The option values of the grid nodes at maturity for a vanilla put
are thus labelled as val, f10,j , j = 0, . . . , 10, where val is the value of the option at the
node; these are shown on the right-hand grid boundary. Since E = 25 only those nodes
with j < 5 have nonzero option values.
Now that we know how to solve the Black–Scholes equation it is possible to
include, without much difﬁculty, more exotic features such as lock out periods,
barriers, rebates, etc.
The routine opt_gfd solves the Black–Scholes equation using a uniform grid.
The asset price is set to one of the grid lines, which means that interpolation is
not required.
5.4.3
Nonuniform grids
In the previous section we showed how to solve the Black–Scholes equation
using a uniform grid. Although this approach will provide satisfactory solutions
to many option pricing problems, there are situations in which it is important to
be able to place grid lines at locations that do not correspond to those available
in a uniform grid. Increasing the density of grid lines in regions of interest can
lead to improved accuracy in both the estimated option values and also the
estimates of the hedge statistics (the Greeks).
Here we provide an example which illustrates the beneﬁts of using a nonuni-
form grids in the evaluation of down and out call barrier options. Later on in

Single asset American options
149
Section 5.4.6 we give a further example which shows the use of nonuniform
grids to evaluate double barrier options.
The purpose of this section is to show how to discretize the Black–Scholes
equation using a nonuniform grid, and to derive an expression (see Eq. (5.4.39))
that is equivalent to Eq. (5.4.14). Although the tridiagonal system of equa-
tions we have to solve in this section will be different from that in Section
5.4, the solution method is exactly the same. This means that once we have
derived Eq. (5.4.39) all the other information which we require to evaluate
both European and American options is available in Section 5.4 under the head-
ings:
• The boundary conditions
• Computation of the option values at a given time instant
• Backwards iteration and early exercise.
We will now consider the ﬁnite-difference approximation for a nonuniform
grid, and then show how to value the down and out call barrier option.
The ﬁnite-difference approximation
Here we consider how to discretize the Black–Scholes equation using a nonuni-
form grid, in which both the asset price interval S and the time step t are
not constant but can vary throughout the grid.
Allowing for a nonconstant time step is quite simple. The time step oc-
curs in both the ﬁrst derivative fi,j (see Eq. (5.4.4)) and in the option value
equations (see Eqs. (5.4.14)–(5.4.21)) as the constant t. To incorporate a
varying time step, ti, i = 0, nt, thus only requires setting t = ti, at the
ith time step and then continuing with the solution method outlined in Sec-
tion 5.4.
The incorporation of nonconstant asset price intervals requires more work.
This is because the ﬁnite-difference approximations to the ﬁrst and second deriv-
atives f ′
i,j and f ′′
i,j, in Eqs. (5.4.10) and (5.4.11) are based on a Taylor expansion
about the point fi,j.
We will now derive expressions for these derivatives.
If we let X−
j
= Sj −Sj−1 and X+
j
= Sj+1 −Sj and then use a Taylor
expansion about fi+1,j we have
fi+1,j+1 = fi+1,j + f ′
i+1,jX+
j + 1
2f ′′
i+1,j

X+
j
2
(5.4.32)
and also
fi+1,j−1 = fi+1,j −f ′
i+1,jX−
j + 1
2f ′′
i+1,j

X−
j
2
(5.4.33)
Multiplying Eq. (5.4.32) by X−
j and adding it to X+
j times Eq. (5.4.33), gives
X+
j fi+1,j−1 + X−
j fi+1,j+1
= X−
j fi+1,j + X+
j fi+1,j + 1
2f ′′
i+1,j

X+
j
2X−
j +

X−
j
2X+
j


150
Computational Finance Using C and C#
Therefore
1
2f ′′
i+1,j =
X+
j fi+1,j−1 + X−
j fi+1,j+1 −X−
j fi+1,j −X+
j fi+1,j
(X+
j )2X−
j + (X−
j )2X+
j
So
f ′′
i+1,j =
2{X+
j fi+1,j−1 + X−
j fi+1,j+1 −fi+1,j(X−
j + X+
j )}
(X+
j )2X−
j + (X−
j )2X+
j
(5.4.34)
To calculate f ′
i+1,j we rearrange Eq. (5.4.33) to obtain
−f ′
i+1,jX−
j = fi+1,j−1 −fi+1,j −1
2f ′′
i+1,j

X−
j
2
and
f ′
i+1,j = fi+1,j −fi+1,j−1
X−
j
+ 1
2f ′′
i+1,jX−
j
(5.4.35)
If we now substitute for f ′′
i+1,j, from Eq. (5.4.34), into Eq. (5.4.35) we have
f ′
i+1,j = fi+1,j −fi+1,j−1
X−
j
+
{X+
j fi+1,j−1 −(X−
j + X+
j )fi+1,j + X−
j fi+1,j+1}X−
j
(X+
j )2X−
j + (X−
j )2X+
j
which simpliﬁes to give
f ′
i+1,j =
(X+
j )2(fi+1,j −fi+1,j−1) −(X−
j )2fi+1,j + (X−
j )2fi+1,j+1
(X+
j )2X−
j + (X−
j )2X+
j
so that we ﬁnally have
f ′
i+1,j =
(X−
j )2fi+1,j+1 + ((X+
j )2 −(X−
j )2)fi+1,j −(X+
j )2fi+1,j−1
(X+
j )2X−
j + (X−
j )2X+
j
(5.4.36)
As in Section 5.4, we can now substitute the expressions for f ′
i+1,j and f ′′
i+1,j
given in Eqs. (5.4.36) and (5.4.34), into Eq. (5.4.7) the discretized Black–Scholes
equation. If we let D = (X+
j )2X−
j + (X−
j )2X+
j we then obtain
rt

Θmfi+1,j + Θ∗
mfi,j

= fi+1,j −fi,j + (r −q)SjtA1
D
+
σ 2S2
j tA2
D
(5.4.37)

Single asset American options
151
where Θ∗
m = 1 −Θm, and
A1 = Θm

fi+1,j+1

X−
j
2 −fi+1,j−1

X+
j
2
−fi+1,j

X−
j
2 −

X+
j
2
+ Θ∗
m

fi,j+1

X−
j
2 −fi,j−1

X+
j
2 −fi,j

X−
j
2 −

X+
j
2
and
A2 = Θm

fi+1,j+1X−
j + fi+1,j−1X+
j −fi+1,j

X−
j + X+
j

+ Θ∗
m

fi,j+1X−
j + fi,j−1X+
j −fi,j

X−
j + X+
j

Collecting like terms, we obtain:
B1fi,j−1 + B2fi,j + B3fi,j+1 + C1fi+1,j−1 + C2fi+1,j
+ C3fi+1,j+1 = 0
(5.4.38)
where
B1 =
−Θ∗
m(r −q)Sjt(X+
j )2
D
+
(1 −θ)σ 2S2
j tX+
j
D
B2 = −1 −rtΘ∗
m −
Θ∗
mσ 2S2
j t(X−
j + X+
j )
D
−
Θ∗
m(r −q)Sjt{(X−
j )2 −(X+
j )2}
D
B3 =
Θ∗
m(r −q)Sjt(X−
j )2
D
+
Θ∗
mσ 2S2
j tX−
j
D
C1 =
Θmσ 2S2
j tX+
j
D
−
Θm(r −q)Sjt(X+
j )2
D
C2 = 1 −rtΘm −
Θm(r −q)Sjt{(X−
j )2 −(X+
j )2}
D
−
Θmσ 2S2
j t{X−
j + X+
j }
D
C3 =
Θm(r −q)Sjt(X−
j )2
D
+
Θmσ 2S2
j tX−
j
D
Since we are solving the Black–Scholes equation backwards in time we will re-
arrange Eq. (5.4.38) as:
ajfi,j−1 + bjfi,j + cj = Ri+1,j
(5.4.39)
where the right-hand side Ri+1,j is:
Ri+1,j = ¯ajfi+1,j−1 + ¯bjfi+1,j + ¯cjfi+1,j+1
(5.4.40)

152
Computational Finance Using C and C#
and the coefﬁcients are
aj = Θ∗
mt
(r −q)Sj(X+
j )2
D
−
σ 2S2
j X+
j
D

(5.4.41)
bj = 1 + tΘ∗
m

r +
σ 2S2
j (X−
j + X+
j )
D
+
(r −q)Sj{(X−
j )2 −(X+
j )2}
D

(5.4.42)
cj = Θ∗
mt
−(r −q)Sj(X−
j )2
D
−
σ 2S2
j X−
j
D

(5.4.43)
¯aj = Θmt
σ 2S2
j X+
j
D
−
(r −q)Sj(X+
j )2
D

(5.4.44)
¯bj = 1 −Θmrt
−Θmt
(r −q)Sj{(X−
j )2 −(X+
j )2}
D
+
σ 2S2
j {X−
j + X+
j }
D

(5.4.45)
¯cj = Θmt
(r −q)Sj(X−
j )2
D
+
σ 2S2
j X−
j
D

(5.4.46)
Here Eq. (5.4.39), as is the case for Eq. (5.4.14) in Section 5.4, provides the
relationship between the three option values fi+1,j−1, fi+1,j, fi+1,j+1 at time
index i + 1, and the three option values fi,j−1, fi,j, fi,j+1 at time index i. It can
also be seen that Eq. (5.4.39) is the nonuniform grid equivalent of Eq. (5.4.14)
given in Section 5.4. We will now show that Eqs. (5.4.39) and (5.4.14) are
identical when a uniform grid is used, that is X+
j
= X−
j . We proceed as
follows:
Let X+
j = X−
j = S and Sj = jS.
So
D =

X+
j
2X−
j +

X−
j
2X+
j
= 2(S)3 (X+
j )2
D
=
(X−
j )2
D
= (S)2
2(S)3 =
1
2S
X+
j
D
=
X−
j
D
=
1
2S2
(X+
j )2 −(X−
j )2
D
= 0
If we substitute the above values into Eqs. (5.4.41)–(5.4.46) we obtain the fol-
lowing expressions for the coefﬁcients in Eq. (5.4.39).

Single asset American options
153
aj = (1 −Θm)t
(r −q)Sj
2S
−
σ 2S2
j
2S2

= (1 −Θm)t
2

(r −q)j −σ 2j2
bj = 1 + t(1 −Θm)

r +
σ 2S2
j
S2

= 1 + (1 −Θm)t

r + σ 2j2
cj = (1 −Θm)t
−(r −q)Sj
2S
−
σ 2S2
j
2S2

= −(1 −Θm)t
2

(r −q)j + σ 2j2
¯aj = Θmt
 σ 2S2
j
2S2 −(r −q)Sj
2S

= −Θm
t
2

(r −q)j −σ 2j2
¯bj = 1 −Θmrt −
Θmσ 2S2
j t
S2
= 1 −Θmt

r + σ 2j2
¯cj = Θmt
(r −q)Sj
2S
+
σ 2S2
j
S2

= Θm
t
2

(r −q)j + σ 2j2
It can be seen that these coefﬁcients are identical to those given in Section 5.4.2
Eqs. (5.4.16)–(5.4.21).
We now provide examples of using nonuniform grids to evaluate European
down and out call options.
Valuation of a down and out call option
Here the improved accuracy that can be achieved by using nonuniform grids
instead of uniform grids is illustrated in Figs. 5.7 and 5.8. The uniform grids are
constructed using the method outlined in Section 5.4 and Code excerpt 5.18.
That is, an asset grid line is set to coincide with the current asset price S0, and
the other grid lines are positioned above and below S0 with a uniform spacing
of S. The disadvantage of this approach is that there will be an unspeciﬁed
pricing error that depends on the distance, ds, of the barrier level, B, to the
void opt_gfd(double theta_m, double asset_price, double sigma, double r, double T,
double strike, long is_american, long put, double *option_value,
double greeks[], double q, long pns, long nt, double smax, long *iflag)
{
/* Input parameters:
=================
theta_m
- the value of theta used for the finite difference method,
asset_price
- the current price of the underlying asset,
sigma
- the volatility,
r
- the interest rate,
T
- the time to maturity,
strike
- the strike price,
is_american
- if is_american is 0 then a European option, otherwise an American_
option,
Code excerpt 5.18.

154
Computational Finance Using C and C#
put
- if put is 0 then a call option, otherwise a put option,
q
- the continuous dividend yield,
pns
- the maximum asset index on the grid, corresponding to the upper_
boundary,
nt
- the number of time intervals,
smax
- the maximum asset price.
Output parameters:
option_value
- the value of the option,
greeks[]
- the hedge statistics output as follows: greeks[0] is gamma, greeks[1]_
is delta, and greeks[2] is theta,
iflag
- an error indicator.
*/
double *a,*b,*c,*a1,*b1,*c1,*opt_vals,*vals,*rhs,*s,*work,*u;
double ds,dt;
long i,j;
double tmp,t2,time_2mat;
long n1,n2,ind=0;
double sig2,temp[4];
if (asset_price >= smax) printf ("ERROR asset price >= smax");
n1 = floor((asset_price/smax)*(double)pns);
n2 = pns - n1;
ds = asset_price/(double)n1;
dt = T/(double)nt;
/* time interval size
*/
ns = n1+n2+1;
/* Note: Now nps = ns-1. Since we define asset grid lines 0...ns-1, this is the maximum grid_
line; corresponding
to the upper boundary. The lower boundary is at the asset grid line 0, and we solve for_
option values between
the asset grid line 1 and the asset grid line ns-2
*/
/* Allocate (all size ns+1) the arrays: a, b, c, a1, b1, c1, opt_vals, vals, rhs, s, work_
and u */
.
.
.
s[0] = 0.0;
s[n1] = asset_price;
for(i=1; i<=n1-1; ++i )
/* set prices below asset_price */
s[i] = (double)i * ds;
for(i=1; i<= n2+1; ++i )
/* set prices above asset_price */
s[n1+i] = asset_price + (double)i * ds;
/* Set up the RHS and LHS coefficients a[], b[] and c[] are the LHS coefficients
for the unknown option values (time step j) a1[], b1[] and c1[] are the values of the
RHS coefficients for the known option prices (time step j+1).
Note: a1, b1 and c1 are used to form the RHS vector rhs[] of the tridiagonal system.
*/
sig2 = sigma*sigma;
t2 = dt/2.0;
tmp = 1.0-theta_m;
/* 1 - theta (for theta method) */
for( i=1; i<=ns-2; ++i) { /* Assign elements of the (ns-2)*(ns-2) tridiagonal matrix */
a[i] = -i*(i*sig2-(r-q))*t2*tmp;
a1[i] = i*(i*sig2-(r-q))*t2*theta_m;;
c[i] = -i*(i*sig2+(r-q))*t2*tmp;
c1[i] = i*(i*sig2+(r-q))*t2*theta_m;;
b[i] = 1.0+r*dt*tmp+(i*i*sig2)*dt*tmp;
b1[i]= 1.0-(i*i*sig2+r)*dt*theta_m;
}
/* Perform LU decomposition of the tridiagonal matrix with:
diagonal elements contained in the array b[],
upper diagonal elements contained in the_
array c[]
and lower diagonal elements in the array a[]. Store the elements of U but not those of L
(they will be computed from U)
Matrix U: The diagonal elements of U are stored in the array u[] and the upper diagonal_
elements of U
are just c[].
Matrix L: For the lower triangular matrix L, the diagonal elements are 1 and the lower_
diagonal elements
are l[i] = a[i]/u[i-1], where u[] is the upper diagonal of U. */
u[1] = b[1];
if (u[1] == 0.0) printf ("ERROR in array u \n");
for(i=2; i <=ns-2; ++i) {
u[i] = b[i] - a[i]*c[i-1]/u[i-1];
Code excerpt 5.18 (Continued).

Single asset American options
155
if (u[i] == 0.0) printf ("ERROR in array u \n");
}
/*
Set option values at maturity.
Note : opt_vals[0] and opt_vals[ns-1] are the lower and_
upper
(put/call) option price boundary values. */
if (!put) { /* a call */
for( i=0; i<ns; ++i )
opt_vals[i] = MAX(s[i]-strike, 0.0 );
}
else { /* a put */
for( i=0; i<ns; ++i)
opt_vals[i] = MAX(strike - s[i], 0.0);
}
/* From the option values at maturity (t = nt*dt) calculate values at earlier times (nt-1)*dt_
etc..
*/
for( j=nt-1; j>=-2; --j) { /* Go two steps past current time (0) so that can evaluate_
theta */
time_2mat = T-j*dt;
for(i=2; i<=ns-3; ++i) /* set up the rhs of equation for Crank-Nicolson method */
rhs[i] = a1[i]*opt_vals[i-1]+b1[i]*opt_vals[i]+c1[i]*opt_vals[i+1];
/* Incorporate the boundary conditions at the upper/lower asset value boundaries */
rhs[1] = (a1[1]-a[1])*opt_vals[0]+ b1[1]*opt_vals[1]+c1[1]*opt_vals[2];
rhs[ns-2] = a1[ns-2]*opt_vals[ns-3]+b1[ns-2]*opt_vals[ns-2]+(c1[ns-2]-c[ns-2])_
*opt_vals[ns-1];
/* Solve the lower triangular system Ly = b, where y is stored in array work[].
Compute the elements of L from those of U, l[i] = a[i]/u[i-1].
*/
work[1] = rhs[1];
for( i=2; i<=ns-2; ++i ) {
work[i] = rhs[i] - a[i]*work[i-1]/u[i-1];
}
/* Solve the upper (ns-2)*(ns-2) triangular system Ux = y (where x = opt_vals) */
opt_vals[ns-2] = work[ns-2]/u[ns-2];
for( i = ns-2; i >= 1; --i )
opt_vals[i] = (work[i] - c[i]*opt_vals[i+1])/u[i];
if (is_american) {
/* take into account early exercise for american options */
if (put) {
/* a put */
for(i=1; i<=ns-2; ++i)
opt_vals[i] = MAX(opt_vals[i],strike-s[i]);
}
else { /* a call */
for(i=1; i<=ns-2; ++i)
opt_vals[i] = MAX(opt_vals[i],s[i]-strike);
}
}
if (j==0) {
for (i=0; i < ns; ++i)
vals[i] = opt_vals[i];
}
if ((j==1)||(j==2)||(j==-1)||(j==-2)) { /* Store option values so that can compute_
theta */
temp[ind] = opt_vals[n1];
++ind;
}
}
if (greeks) {
/* Compute gamma (4th order accuracy) */
greeks[0] = (-vals[n1+2]+16.0*vals[n1+1]-30.0*vals[n1]+16.0*vals[n1-1]-vals[n1-2])_
/(12.0*ds*ds);
/* Compute delta (4th order accuracy) */
greeks[1] = (-vals[n1+2]+8.0*vals[n1+1]-8.0*vals[n1-1]+vals[n1-2])/(12.0*ds);
/* Compute theta (4th order accuracy) */
greeks[2] = (-temp[0]+8.0*temp[1]-8.0*temp[2]+temp[3])/(12.0*dt);
/* Note: could also compute theta as greeks[2] = (-temp[0]+4.0*temp[1]-3.0*vals[n1])
/(2.0*dt); */
}
*option_value = vals[n1]; /* Return option value */
}
Code excerpt 5.18 Function to compute the value of a vanilla option using a uniform
grid.

156
Computational Finance Using C and C#
nearest asset grid line. Furthermore, as the number of asset points, ns, increases
the magnitude of ds will oscillate within the range 0 to S/2.
When ds ∼0 the grid will be accurate, but when |ds| ∼S/2 there will be
a large pricing error. This gives rise to the oscillating pricing errors shown in
Figs. 5.7 and 5.8.
The nonuniform grids are constructed using the techniques mentioned earlier
in this section, and also Code excerpt 5.19. We now, irrespective of ns, arrange
for one asset grid line to coincide with the current asset value, S0, and another
asset grid line to coincide with B, the barrier asset price. In Fig 5.6 this corre-
sponds to setting BL to B and not using BU.
It can be seen in Figs. 5.7 and 5.8 that in this case the pricing error is very
much less, and also does not exhibit the pronounced oscillations that are pro-
duced by a uniform grid. In Code excerpt 5.19 we give the computer program
which was used to obtained the nonuniform grid values for the down and out
call options presented in Figs. 5.7 and 5.8. Although this program only deals
with European options it can easily be altered, using the same techniques as in
Code excerpt 5.18, to deal with American-style options; this is left as an exercise
for the reader.
Figure 5.6 A nonuniform grid in which the grid spacing is reduced near current time t,
and also in the neighborhood of the asset price 25; this can lead to greater accuracy in
the computed option values and the associated Greeks. Grid lines are also placed at asset
prices of BU and BL; this enables the accurate evaluation of options which have barriers
at these asset prices.

Single asset American options
157
void barrier_downout(double barrier_level, double theta_m, double asset_price, double sigma,_
double r, double T,
double strike, long put, double *option_value, double greeks[], double q, long ns,_
long nt, double smax, long *ifail)
{
/* ns - the number of asset intervals
nt - the number of time intervals
*/
double *a,*b,*c,*a1,*b1,*c1,*opt_vals,*vals,*rhs,*s,*work,*u;
double ds,time_step;
long i,j,barrier_index;
double tmp,t2,time_2mat,zero = 0.0;
long n1,n2,ind=0,ns1;
double sig2,temp[4],ds_plus,ds_minus,temp1,temp2,temp3;
double D;
n1 = floor((asset_price/smax)*(double)ns);
if (n1 < 3) {
printf ("increase the number of asset points \n");
}
n2 = ns - n1;
ds = asset_price/(double)n1;
time_step = T/(double)nt;
/* time interval size
*/
ns1 = n1+n2+2; /* number of nodes - including extra grid line*/
/* allocate the required arrays (all of size ns1+1): a, b, c, a1, b1, c1, opt_vals,_
vals, rhs, s, work, u */
.
.
.
/* set prices below asset_price */
s[0] = zero;
s[n1] = asset_price;
for(i=1; i < n1; ++i )
s[i] = (double)i * ds;
/* set prices above asset_price */
for(i=1; i<= n2+2; ++i ) {
s[n1+i] = asset_price + (double)i * ds;
}
/* find out the index corresponding to barrier_level */
barrier_index = 0;
while(barrier_level > s[barrier_index]) {
++barrier_index;
}
if (barrier_level != s[barrier_index]) { /* decrement barrier index */
--barrier_index;
}
if (s[barrier_index] != barrier_level) { /* then barrier does not correspond_
to an existing grid line
so create another_
one*/
for (i=1; i < ns1-barrier_index; ++i) {
s[barrier_index+1+i] = s[barrier_index] + (double)i*ds;
}
++barrier_index;
s[barrier_index] = barrier_level;
if (n1>barrier_index) {
++n1;
}
}
/* set up the RHS and LHS coefficients a[], b[] and c[] are the LHS coefficients
for the unknown option values (time step j) a1[], b1[] and c1[] are the values of the
RHS coefficients for the known option prices (time step j+1).
Note: a1, b1 and c1 are used to form the RHS vector rhs[] of the tridiagonal_
system. */
sig2 = sigma*sigma;
t2 = time_step/2.0;
tmp = 1.0-theta_m;
/* 1 - theta (for theta method) */
/* assign elements of the (ns1-2)*(ns1-2) tridiagonal matrix */
for( i=1; i<=ns1-2; ++i) {
ds_plus
= s[i+1]-s[i];
ds_minus = s[i] - s[i-1];
D = ((ds_plus*ds_plus*ds_minus) + (ds_minus*ds_minus*ds_plus));
temp1 = tmp*time_step/D;
a[i] = temp1*((r-q)*s[i]*ds_plus*ds_plus) -temp1*ds_plus*(s[i]*s[i]*sig2);
temp1 = theta_m*time_step/D;
a1[i] = -(temp1*((r-q)*s[i]*ds_plus*ds_plus) -temp1*ds_plus*(s[i]*s[i]*sig2));
temp1 = (ds_minus*ds_minus)/D;
temp2 = ds_minus/D;
Code excerpt 5.19.

158
Computational Finance Using C and C#
c[i]
= -time_step*tmp*(temp1*s[i]*(r-q)+(sig2*s[i]*s[i]*temp2));
c1[i] = time_step*theta_m*(temp1*s[i]*(r-q)+(sig2*s[i]*s[i]*temp2));
temp1 = ((ds_minus*ds_minus) - (ds_plus*ds_plus))/D;
temp2 = (ds_minus+ds_plus)/D;
b[i] = 1.0+time_step*tmp*(r+((r-q)*s[i]*temp1)+(s[i]*s[i]*sig2)*temp2);
b1[i] = 1.0-time_step*theta_m*(r+((r-q)*s[i]*temp1)+(s[i]*s[i]*sig2)*temp2);
}
/* Perform LU decomposition of the tridiagonal matrix with: diagonal elements contained_
in the array b[],
upper diagonal elements contained in the array c[]
and lower diagonal elements in_
the array a[].
Store the elements of U but not those of L (they will be computed from U)
Matrix U: The diagonal elements of U are stored in the array u[] and the upper
diagonal elements of U are just c[].
Matrix L: For the lower triangular matrix L, the diagonal elements are 1 and the_
lower diagonal
elements are l[i] = a[i]/u[i-1], where u[] is the upper diagonal of U. */
u[1] = b[1];
if (u[1] == zero) printf ("error in array u \n");
for( i=2; i <=ns1-2; ++i) {
u[i] = b[i] - a[i]*c[i-1]/u[i-1];
if (u[i] == zero) printf ("error in array u \n");
}
/* Set option values at maturity. Note : opt_vals[0] and opt_vals[ns1-1] are the lower and_
upper
(put/call) option price boundary values. */
if (!put) { /* a call */
for( i=0; i<ns1; ++i )
opt_vals[i] = MAX(s[i]-strike, zero );
/* now modify option values to include the barrier */
for( i=0; i <= barrier_index; ++i )
opt_vals[i] = zero;
}
else { /* a put */
for( i=0; i<ns1; ++i)
opt_vals[i] = MAX(strike - s[i], zero);
}
/* From the option values at maturity, t = nt*time_step, compute
the values at times (nt-1)*time_step to 0 (current time)
*/
for( j=nt-1; j>=-2; --j) { /* go two steps past current time so that can evaluate_
theta */
time_2mat = T-j*time_step;
/* set up the rhs of equation for the Theta method */
for(i=2; i<=ns1-3; ++i)
rhs[i] = a1[i]*opt_vals[i-1]+b1[i]*opt_vals[i]+c1[i]*opt_vals[i+1];
/* incorporate the boundary conditions1 at the upper/lower asset value boundaries */
rhs[1] = (a1[1]-a[1])*opt_vals[0]+ b1[1]*opt_vals[1]+c1[1]*opt_vals[2];
rhs[ns1-2] = a1[ns1-2]*opt_vals[ns1-3]+b1[ns1-2]*opt_vals[ns1-2]+(c1[ns1-2]-c[ns1-2])_
*opt_vals[ns1-1];
/* Solve the lower triangular system Ly = b, where y is stored in array work[].
Compute the elements of L from those of U, l[i] = a[i]/u[i-1]. */
work[1] = rhs[1];
for( i=2; i<=ns1-2; ++i ) {
work[i] = rhs[i] - a[i]*work[i-1]/u[i-1];
}
/* Solve the upper (ns1-2)*(ns1-2) triangular system Ux = y (where x = opt_vals) */
opt_vals[ns1-2] = work[ns1-2]/u[ns1-2];
for( i = ns1-2; i >= 1; --i )
opt_vals[i] = (work[i] - c[i]*opt_vals[i+1])/u[i];
if (j==0) {
for (i=0; i < ns1; ++i)
vals[i] = opt_vals[i];
}
/* store option values so that can compute theta */
if ((j==1)||(j==2)||(j==-1)||(j==-2)) {
temp[ind] = opt_vals[n1];
++ind;
}
/* now modify for barrier */
for( i=0; i <= barrier_index; ++i )
opt_vals[i] = zero;
}
if (greeks) { /* assume an irregular grid */
ds_minus = s[n1]-s[n1-1];
Code excerpt 5.19 (Continued).

Single asset American options
159
ds_plus
= s[n1+1]-s[n1];
D = (ds_minus*ds_minus*ds_plus) + (ds_plus*ds_plus*ds_minus);
temp1 = ds_minus*ds_minus;
temp2 = ds_plus*ds_plus;
temp3 = temp1-temp2;
/* GAMMA */
greeks[0] = (ds_minus*vals[n1+1]+ds_plus*vals[n1-1]-vals[n1]*(ds_plus+ds_minus))_
/(0.5*D);
/* DELTA */
greeks[1] = (temp1*vals[n1+1] - temp2*vals[n1-1] - vals[n1]*temp3)/D;
/*
THETA */
greeks[2] = (-temp[0]+8.0*temp[1]-8.0*temp[2]+temp[3])/(12.0*time_step);
/* could also compute theta like this:
greeks[2] = (-temp[0]+4.0*temp[1]-3.0*vals[n1])/(2.0*time_step); */
}
*option_value = vals[n1]; /* Return option value */
/* deallocate the arrays that were previously allocated */
.
.
.
}
Code excerpt 5.19 Function to compute the value of a European down and out barrier
option using a nonuniform grid.
Figure 5.7 The absolute error in the estimated values for a European down and out call
barrier option (B < E) as the number of asset grid points, ns, are varied. Here we show
a comparison of the results obtained using both uniform and nonuniform grids; loga-
rithmic transformations were not employed. The algorithm for the uniform grid is de-
scribed in Section 5.4.2, and that for the nonuniform grid is outlined in Section 5.4.3. The
Crank–Nicolson method (Θm = 0.5) was used and the other parameters were E = 50.0,
B = 47.5, S0 = 55.0, Smax = 300.0, T = 0.5, σ = 0.2, r = log(1.1), q = 0.0, nt = 100.
The correct option value was 7.6512, which was obtained using the analytic formulae
given in Code excerpt 4.7.

160
Computational Finance Using C and C#
Figure 5.8 The absolute error in the estimated values for a European down and out call
barrier option (E < B) as the number of asset grid points, ns, is varied. Here we show
a comparison of the results obtained using both uniform and nonuniform grids; loga-
rithmic transformations were not employed. The algorithm for the uniform grid is de-
scribed in Section 5.4.2 and that for the nonuniform grid is outlined in Section 5.4.3. The
Crank–Nicolson method (Θm = 0.5) was used and the other parameters were E = 50.0,
B = 52.5, S0 = 65.0, Smax = 300.0, T = 0.5, σ = 0.2, r = log(1.1), q = 0.0, nt = 100.
The correct option value was 17.0386, which was obtained using the analytic formulae
given in Code excerpt 4.7.
5.4.4
The log transformation and uniform grids
Up to this point we have been dealing with the standard Black–Scholes equation,
which is:
∂f
∂t + (r −q)S ∂f
∂S + σ 2S2
2
∂2f
∂S2 = rf
(5.4.47)
However, if we introduce the change of variable Z = log S, we obtain the fol-
lowing equation:
∂f
∂t + b ∂f
∂Z + σ 2
2
∂2f
∂Z2 = rf
(5.4.48)
where b = r −q −σ 2/2. This form of the Black–Scholes equation has beneﬁcial
numerical properties—see Appendix F.

Single asset American options
161
Derivation of Eq. (5.4.48)
We will now derive an expression for the logarithmic Black–Scholes equation,
and show that it agrees with Eq. (5.4.48).
Since Z = log S we have ∂Z
∂S = 1
S . This gives:
∂f
∂S = ∂f
∂Z
∂Z
∂S = 1
S
∂f
∂Z
and
∂2f
∂S2 = ∂
∂S
∂f
∂S

= 1
S2
∂f
∂Z + 1
S
∂
∂S
 ∂f
∂Z

= −1
S2
∂f
∂Z + 1
S
∂Z
∂S
∂
∂Z
 ∂f
∂Z

∂2f
∂S2 = −1
S2
∂f
∂Z + 1
S2
∂2f
∂Z2
So Eq. (5.4.47) becomes:
∂f
∂t + (r −q)S
S
∂f
∂Z −σ 2S2
2S2
∂f
∂Z + σ 2S2
2S2
∂2f
∂Z2 = rf
thus setting b = r −q −σ 2/2 we obtain:
∂f
∂t + b ∂f
∂Z + σ 2
2
∂2f
∂Z2 = rf
We will now consider the ﬁnite difference discretization of Eq. (5.4.48).
The ﬁnite-difference method
Application of the ﬁnite-difference method to the log transformed Black–
Scholes equation is very similar to that already outlined in Sections 5.4.2
and 5.4.3.
Use of the Θm method on Eq. (5.4.48) results in:
fi+1,j −fi,j
t
+ b

Θmf ′
i+1,j + Θ∗
mf ′
i,j

+ 1
2σ 2
Θmf ′′
i+1,j + Θ∗
mf ′′
i,j

= r

Θmfi+1,j + Θ∗
mfi,j

where Θ∗
m = 1−Θm. Applying a uniform discretization at node (i, j) we obtain:
fi+1,j −fi,j + btA1
2Z
+ σ 2tA2
2Z2
= rt

Θmfi+1,j + Θ∗
mfi,j

(5.4.49)
where
A1 = Θm{fi+1,j+1 −fi+1,j−1} + Θ∗
m{fi,j+1 −fi,j−1}
A2 = Θm{fi+1,j+1 −2fi+1,j + fi+1,j−1} + Θ∗
m{fi,j+1 −2fi,j + fi,j−1}
Collecting like terms we obtain:
B1fi,j−1 + B2fi,j + B3fi,j+1 + C1fi+1,j−1 + C2fi+1,j + C3fi+1,j+1 = 0

162
Computational Finance Using C and C#
where
B1 = −Θ∗
mbt
2Z
+ Θ∗
mσ 2t
2Z2
B2 = −1 −rtΘ∗
m −Θ∗
mσ 2t
Z2
B3 = Θ∗
mbt
2Z
+ Θ∗
mσ 2t
2Z2
C1 = Θmσ 2t
2Z2
−Θmbt
2Z
C2 = 1 −rtΘm −Θmσ 2t
Z2
C3 = Θmbt
2Z
+ Θmσ 2t
2Z2
If we rearrange we have the following equation:
ajfi,j−1 + bjfi,j + cj = ¯ajfi+1,j−1 + ¯bjfi+1,j + ¯cjfi+1,j+1
where:
aj = (1 −Θm)t
2Z2

bZ −σ 2
(5.4.50)
bj = 1 + (1 −Θm)t

r + σ 2
Z2

(5.4.51)
cj = −(1 −Θm)t
2Z2

bZ + σ 2
(5.4.52)
¯aj = −Θmt
2Z2

bZ −σ 2
(5.4.53)
¯bj = 1 −Θmt

r + σ 2
Z2

(5.4.54)
¯cj = Θmt
2Z2

bZ + σ 2
(5.4.55)
It can be seen that, unlike in Section 5.4.2, the coefﬁcients in Eqs. (5.4.50)–
(5.4.55) are independent of the asset price index j.
When Θm = 0.5 (the Crank–Nicolson method) we have the following coefﬁ-
cients:
aj = −¯aj =
t
4Z2

bZ −σ 2
bj = 1 + t
2

r + σ 2
Z2

cj = −¯cj = −t
4Z2

bZ + σ 2
¯bj = 1 −t
2

r + σ 2
Z2


Single asset American options
163
Table 5.7 Valuation results and pricing errors for a vanilla American put option using a
uniform grid with and without a logarithmic transformation; the implicit method and
Crank–Nicolson method are used
Time
Value
Θm = 0.0
Θm = 0.5
BS
Log BS
BS
Log BS
0.1
0.7599
1.4733 × 10−2
7.7803 × 10−3
1.4719 × 10−2
7.6716 × 10−3
0.2
0.8335
4.5838 × 10−2
1.2924 × 10−2
4.5682 × 10−2
1.1997 × 10−2
0.3
0.8921
6.4218 × 10−2
1.4125 × 10−2
6.3800 × 10−2
1.2567 × 10−2
0.4
0.9403
7.4699 × 10−2
1.6559 × 10−2
7.3924 × 10−2
1.4655 × 10−2
0.5
0.9812
8.0297 × 10−2
1.8471 × 10−2
7.9101 × 10−2
1.6041 × 10−2
0.6
1.0167
8.2796 × 10−2
1.9125 × 10−2
8.1135 × 10−2
1.6067 × 10−2
0.7
1.0479
8.3285 × 10−2
1.8959 × 10−2
8.1131 × 10−2
1.5273 × 10−2
0.8
1.0758
8.2470 × 10−2
1.8408 × 10−2
7.9803 × 10−2
1.4159 × 10−2
0.9
1.1009
8.0829 × 10−2
1.7756 × 10−2
7.7647 × 10−2
1.3020 × 10−2
1.0
1.1237
7.8646 × 10−2
1.7138 × 10−2
7.4947 × 10−2
1.1997 × 10−2
1.1
1.1445
7.6164 × 10−2
1.6643 × 10−2
7.1961 × 10−2
1.1174 × 10−2
1.2
1.1637
7.3514 × 10−2
1.6290 × 10−2
6.8803 × 10−2
1.0552 × 10−2
1.3
1.1813
7.0785 × 10−2
1.6092 × 10−2
6.5594 × 10−2
1.0143 × 10−2
1.4
1.1977
6.8080 × 10−2
1.6042 × 10−2
6.2419 × 10−2
9.9309 × 10−3
1.5
1.2129
6.5424 × 10−2
1.6128 × 10−2
5.9295 × 10−2
9.8909 × 10−3
The accurate values (obtained using a logarithmic transformed grid with ns = 1000 and
nt = 1000) are presented in the column labelled “Value”. The absolute pricing errors,
ABS (accurate value −estimated value) presented in the column labelled BS were ob-
tained using a standard uniform grid (as outlined in Section 5.4.2), and those in the
column labelled Log BS use a uniform grid and logarithmic transformation as explained
in this section. The maturity of the option was varied from 0.1 years to 1.5 years, and
the other parameters were: S = 9.0, X = 9.7, r = 0.1, q = 0.0, σ = 0.30, Smax = 100.0,
ns = 50, and nt = 50.
The method of using the ﬁnite-difference grid to compute option prices is iden-
tical to that already outlined in Section 5.4.2, which solves the standard (non-
logarithmic) Black–Scholes equation. Table 5.7 compares the results obtained
with and without a logarithmic transformation.
5.4.5
The log transformation and nonuniform grids
In the previous section we considered the use of a uniform grid to discretize the
logarithmically transformed Black–Scholes equation:
∂f
∂t + b ∂f
∂Z + σ 2
2
∂2f
∂Z2 = rf
(5.4.56)

164
Computational Finance Using C and C#
where
b = r −q −σ 2
2
and
Z = log S
Here we will generalize these results and use a nonuniform grid to solve
Eq. (5.4.56).
Our description will be very brief since most of the details have already been
discussed in previous sections. Here we are only concerned with the ﬁnite-
difference approximation and derive the equations that need to be solved at
each time step. Later, in Section 5.4.6, we will apply our results to solving a
European double knockout barrier option.
The ﬁnite-difference approximation
At the grid node (i, j) we have
Z−
j = Zj −Zj−1
and
Z+
j = Zj + 1 −Zj
Following Section 5.4.2 the ﬁrst and second derivatives of f w.r.t. Z are
f ′′
i+1,j =
2{Z+
j fi+1,j−1 + Z−
j fi+1,j+1 −Z−
j fi+1,j −Z+
j fi+1,j}
(Z+
j )2Z−
j + (Z−
j )2Z+
j
and
f ′
i+1,j =
(Z−
j )2fi+1,j+1 + ((Z+)2 −(Z−
j )2)fi+1,j −(Z+
j )2fi+1,j−1
(Z+
j )2Z−
j + (Z−
j )2Z+
Then discretizing Eq. (5.4.56) in the usual manner we obtain
fi+1,j −fi,j
t
+ b

Θmf ′
i+1,j + Θ∗
mf ′
i,j

+ σ 2
2

Θmf ′′
i+1,j + Θ∗
mf ′′
i,j

= r

Θmfi+1,j + Θ∗
mfi,j

where Θ∗
m = 1 −Θm. Letting D = (Z+
j )2Z−
j + (Z−
j )2Z+
j we obtain
rt

Θmfi+1,j + Θ∗
mfi,j

(5.4.57)
= fi+1,j −fi,j + btA1
D
+ σ 2tA2
D
where
A1 = Θm

fi+1,j+1

Z−
j
2 −fi+1,j−1

Z+
j
2
−fi+1,j

Z−
j
2 −

Z+
j
2
+ Θ∗
m

fi,j+1

Z−
j
2 −fi,j−1

Z+
j
2 −fi,j

Z−
j
2 −

Z+
j
2
A2 = Θm

fi+1,j+1Z−
j + fi+1,j−1Z+
j −fi+1,j

Z−
j + Z+
j

+ Θ∗
m

fi,j+1Z−
j + fi,j−1Z+
j −fi,j

Z−
j + Z+
j


Single asset American options
165
Collecting like terms we obtain:
B1fi,j−1 + B2fi,j + B3fi,j+1 + C1fi+1,j−1 + C2fi+1,j + C3fi+1,j+1 = 0
where
B1 =
−Θ∗
mbt(Z+
j )2
D
+
Θ∗
mσ 2tZ+
j
D
B2 = −1 −rtΘ∗
m
−
Θ∗
mσ 2t(Z−
j + Z+
j )
D
−
Θ∗
mbt{(Z−
j )2 −(Z+
j )2}
D
B3 =
Θ∗
mbt(Z−
j )2
D
+ Θ∗
mσ 2tZ−
D
C1 =
Θmσ 2tZ+
j
D
−
Θmbt(Z+
j )2
D
C2 = 1−rtΘm −
Θmbt{(Z−
j )2 −(Z+
j )2}
D
−
Θmσ 2t{Z−
j + Z+
j }
D
C3 =
Θmbt(Z−
j )2
D
+
Θmσ 2tZ−
j
D
If we rearrange we have the following equation:
ajfi,j−1 + bjfi,j + cj = ¯ajfi+1,j−1 + ¯bjfi+1,j + ¯cjfi+1,j+1
(5.4.58)
where:
aj = (1 −Θm)t
b(Z+
j )2
D
−
σ 2Z+
j
D

(5.4.59)
bj = 1 + t(1 −Θm)
×

r −
σ 2(Z−
j + Z+
j )
D
−
b{(Z−
j )2 −(Z+
j )2}
D

(5.4.60)
cj = (1 −Θm)t
−b(Z−
j )2
D
−
σ 2Z−
j
D

(5.4.61)
¯aj = Θmt
σ 2Z+
j
D
−
b(Z+
j )2
D

(5.4.62)
¯bj = 1 −Θmrt
−Θmt
b{(Z−
j )2 −(Z+
j )2}
D
+
σ 2{Z−
j + Z+
j }
D

(5.4.63)
¯cj = Θmt
b(Z−
j )2
D
+
σ 2Z−
j
D

(5.4.64)
The incorporation of boundary conditions and the solution of Eq. (5.4.58) is
similar in manner to that already discussed in Section 5.4.2. If further details

166
Computational Finance Using C and C#
are required Code excerpt 5.19, which uses a nonuniform grid to solve the log
transformed Black–Scholes equation, can be consulted.
When a uniform grid is used Z+
j = Z−
j = Z and therefore
D =

Z+
j
2Z−
j +

Z−
j
2Z+
j = 2(Z)3
(Z+
j )2
D
=
(Z−
j )2
D
= (Z)2
2(Z)3 =
1
2Z
Z+
j
D
=
Z−
j
D
=
1
2Z2
and
(Z+
j )2 −(Z−
j )2
D
= 0
In these circumstances
aj = (1 −Θm)t
2Z2

bZ −σ 2
bj = 1 + t(1 −Θm)

r −σ 2
Z2

cj = (1 −Θm)t
 −b
2Z −
σ 2
2Z2

¯aj = −Θmt
2Z2

bZ −σ 2
¯bj = 1 −Θmt

r + σ 2
Z2

¯cj = Θmt
2Z2

bZ + σ 2
which are the same as Eqs. (5.4.50)–(5.4.55) in Section 5.4.4.
5.4.6
The double knockout call option
The purpose of this section is to provide an example that illustrates the beneﬁts
to be gained from using both the log transformed Black–Scholes equation and
also a nonuniform grid.
The problem we will consider is the European double knockout call option
with strike price E, and expiry date T . This is a barrier option with both an
upper barrier at BU and a lower barrier at BL. If, during the life of the option,
the asset price either goes above the upper barrier or below the lower barrier,
then the option becomes worthless. If, on the other hand, the asset price stays
between the barriers then the option has value max(ST −E, 0), where ST is the
asset price at time T .
This problem has been previously investigated by Boyle and Tian (1998),
henceforth referred to as BT, who used an explicit ﬁnite-difference method
based on a modiﬁed trinomial lattice. The method we use here is based on
the ﬁnite-difference equations given in Section 5.4.5, and all the results ob-
tained by using the function dko_call (see Code excerpt 5.20) are presented
in Tables 5.8–5.12.

Single asset American options
167
void dko_call(double lower_barrier, double upper_barrier, double theta_m,
double S0, double sigma_array[], double sigma_times[], long n_sigma, double r,
double opt_mat, double X, double *option_value, double greeks[], double q,
long ns_below_S0, long ns_above_S0, long nt, long *iflag)
{
/* Input parameters:
=================
lower_barrier
- the asset price corresponding to the lower barrier,
upper_barrier
- the asset price corresponding to the upper barrier,
theta_m
- the value of theta used for the finite difference method,
S0
- the current price of the underlying asset,
sigma_array[]
- an array containing values of the volatility: sigma_array[0] is the_
first value of the volatility,
sigma_array[1] is the second value of the volatility, etc..,
sigma_times[]
- an array containing the times for different volatilities:_
sigma_times[0] is the time corresponding to
the first volatility, sigma_times[1] is the time corresponding to_
the second volatility, etc..,
n_sigma
- the number of elements in sigma_array[], and sigma_times[],
r
- the interest rate,
opt_mat
- the time to maturity,
X
- the strike price,
q
- the continuous dividend yield,
ns_below_S0
- the number of asset intervals below the current price S0,
ns_above_S0
- the number of asset intervals above the current price S0,
nt
- the number of time intervals.
Output parameters:
==================
option_value
- the value of the option,
greeks[]
- the hedge statistics output as follows: greeks[0] is gamma,_
greeks[1] is delta, and greeks[2] is theta,
iflag
- an error indicator.
*/
double *a,*b,*c,*vals,*a1,*b1,*c1,*opt_vals,*rhs,*z,*delta,*gamma,*work,*u;
double dt,dz,dz1,dz2,zmax,zmin;
long i,j;
double tmp,t2,t4,dt2;
long ind=0,n1,n2,ns1;
double ds,log_asset,sig2,alpha,v2,b_fac,temp[4];
double zero = 0.0;
long barrier_index,ind2;
double dz_shift,time_step,log_barrier_level1,log_barrier_level2;
double temp1, temp2, ds_plus, ds_minus, bb, D;
double curr_time;
if (S0 >= upper_barrier) printf ("ERROR current asset price is greater than_
upper_barrier \n");
if (lower_barrier >= S0) printf("ERROR lower barrier is greater than current asset_
price \n");
if (S0 <= zero) printf ("ERROR asset price is not > 0 \n");
if (upper_barrier <= lower_barrier) printf ("ERROR upper_barrier must be >_
lower_barrier \n");
log_asset = log(S0);
log_barrier_level1 = log(lower_barrier);
log_barrier_level2 = log(upper_barrier);
dz1 = (log_asset-log_barrier_level1)/(double)ns_below_S0;
n1 = ns_below_S0;
/* Include 5 extra points above the asset price so that don’t get discontinuity in grid_
spacing
which may adversely affect the computation of the greeks */
n2 = ns_above_S0 + 5;
dz_shift = dz1*5.0; /* shift caused by extra 5 grid points */
dz2 = (log_barrier_level2-log_asset-dz_shift)/(double)ns_above_S0;
dt = opt_mat/(double)nt;
/* time interval size
*/
time_step = dt;
--n2;
ns1 = n1+n2+2;
/* Set up the RHS and LHS coefficients a[], b[] and c[] are the LHS coefficients for the_
unknown option
values (time step j) a1[], b1[] and c1[] are the values of the RHS coefficients for the_
known option prices
(time step j+1). Note: a1, b1 and c1 are used to form the RHS vector rhs[] of the_
tridiagonal system. */
/* Allocate the required arrays (all of size (ns1+2): a,b,c,a1,b1,c1,opt_vals,vals,_
rhs,z,delta,gamma,work,u */
Code excerpt 5.20.

168
Computational Finance Using C and C#
.
.
.
/* Set up the RHS and LHS coefficients a[], b[] and c[] are the LHS coefficients
for the unknown option values (time step j) a1[], b1[] and c1[] are the values of the
RHS coefficients for the known option prices (time step j+1). Note: a1, b1 and c1 are used_
to form the RHS
vector rhs[] of the tridiagonal system. */
/* Set grid line asset values, set one grid spacing to align with the asset price, then won’t_
have to
interpolate to get the option value */
z[n1] = log_asset;
for (i = 1; i <=n1; ++i) /* This should be the fine mesh */
z[n1-i] = log_asset - (double)i*dz1;
for (i = 1; i <= 5; ++i) /* Include 5 extra fine mesh points here */
z[n1+i] = log_asset + (double)i*dz1;
for (i = 6; i <= n2+2; ++i) { /* The coarse mesh */
j = i - 5;
z[n1+i] = z[n1+5] + (double)j*dz2;
}
/*
Set option values at maturity (for a call). Note : opt_vals[0] and opt_vals[ns1-1] are the
lower and upper
(put/call) option price boundary values. */
for( i=1; i<ns1; ++i ) {
opt_vals[i] = MAX(exp(z[i])-X, zero);
}
opt_vals[0] = zero;
opt_vals[ns1-1] = zero;
tmp = 1.0-theta_m;
/* 1 - theta (for theta method) */
curr_time = -1.0;
ind2 = n_sigma - 1;
for( j=nt-1; j>=-2; --j) { /* Iterate from maturity to current time
*/
if ((ind2 >= 0) && (curr_time <= sigma_times[ind2])) {
sig2 = sigma_array[ind2]*sigma_array[ind2];
t2 = time_step/2.0;
bb = r - q - (sig2/2.0);
--ind2;
for( i=1; i<=ns1-2; ++i) { /* Assign elements of the (ns1-2)*(ns1-2) tridiagonal_
matrix */
ds_plus
= z[i+1]-z[i];
ds_minus = z[i] - z[i-1];
D = ((ds_plus*ds_plus*ds_minus) + (ds_minus*ds_minus*ds_plus));
temp1 = tmp*time_step/D;
a[i] = temp1*(bb*ds_plus*ds_plus) -temp1*ds_plus*(sig2);
temp1 = theta_m*time_step/D;
a1[i] = temp1*ds_plus*(sig2)-temp1*(bb*ds_plus*ds_plus);
temp1 = (ds_minus*ds_minus)/D;
temp2 = ds_minus/D;
c[i]
= -time_step*tmp*(temp1*bb+(sig2*temp2));
c1[i] = time_step*theta_m*(temp1*bb+(sig2*temp2));
temp1 = ((ds_minus*ds_minus) - (ds_plus*ds_plus))/D;
temp2 = (ds_minus+ds_plus)/D;
b[i] = 1.0+time_step*tmp*(r+(bb*temp1)+(sig2)*temp2);
b1[i] = 1.0-time_step*theta_m*(r+(bb*temp1)+(sig2)*temp2);
}
u[1] = b[1];
if (u[1] == zero) printf ("ERROR in array u \n");
for( i=2; i <=ns1-2; ++i) {
u[i] = b[i] - a[i]*c[i-1]/u[i-1];
if (u[i] == zero) printf ("ERROR in array u \n");
}
}
curr_time = j*dt;
/* Set up the rhs of equation for the theta method */
for(i=2; i<=ns1-3; ++i)
rhs[i] = a1[i]*opt_vals[i-1]+b1[i]*opt_vals[i]+c1[i]*opt_vals[i+1];
/* Incorporate the boundary conditions1 at the upper/lower asset value boundaries */
rhs[1] = (a1[1]-a[1])*opt_vals[0]+ b1[1]*opt_vals[1]+c1[1]*opt_vals[2];
rhs[ns1-2] = a1[ns1-2]*opt_vals[ns1-3]+b1[ns1-2]*opt_vals[ns1-2]+(c1[ns1-2]-c[ns1-2])_
*opt_vals[ns1-1];
/* Solve the lower triangular system Ly = b, where y is stored in array work[]. Compute the_
elements of L from those of U, l[i] = a[i]/u[i-1]. */
work[1] = rhs[1];
for( i=2; i<=ns1-2; ++i ) {
work[i] = rhs[i] - a[i]*work[i-1]/u[i-1];
}
Code excerpt 5.20 (Continued).

Single asset American options
169
/* Solve the upper (ns1-2)*(ns1-2) triangular system Ux = y (where x = vold) */
opt_vals[ns1-2] = work[ns1-2]/u[ns1-2];
for( i = ns1-2; i >= 1; --i )
opt_vals[i] = (work[i] - c[i]*opt_vals[i+1])/u[i];
if (j==0) {
for (i=0; i < ns1; ++i)
vals[i] = opt_vals[i];
}
/* Store option values so that can compute theta */
if ((j==1)||(j==2)||(j==-1)||(j==-2)) {
temp[ind] = opt_vals[n1];
++ind;
}
}
if (greeks) {
/* Compute gamma and delta (4th order accuracy) */
greeks[1] = (-vals[n1+2]+8.0*vals[n1+1]-8.0*vals[n1-1]+vals[n1-2])/(12.0*dz1);
/* Compute gamma (4th order accuracy) - use chain rule to obtain derivative wrt S */
greeks[0] = (-vals[n1+2]+16.0*vals[n1+1]-30.0*vals[n1]+16.0*vals[n1-1]-vals[n1-2])_
/(12.0*dz1*dz1);
greeks[0] = greeks[0]-greeks[1];
greeks[0] = greeks[0]/(S0*S0);
greeks[1] = greeks[1]/S0;
/* Compute theta (4th order accuracy) */
greeks[2] = (-temp[0]+8.0*temp[1]-8.0*temp[2]+temp[3])/(12.0*dt);
/* could also compute theta as: greeks[2] = (-temp[0]+4.0*temp[1]-3.0*vals[n1])_
/(2.0*dt);
*/
}
*option_value = vals[n1];
}
Code excerpt 5.20 Code excerpt 5.20 Function to compute the value and Greeks of
a European double knockout call option using a nonuniform grid and a logarithmic
transformation.
Table 5.8 Estimated value of a European double knockout call option
Time steps (n)
Estimated value
Boyle and Tian (1998)
50
1.4569
1.4238
100
1.4578
1.4437
200
1.4583
1.4495
300
1.4583
1.4524
400
1.4584
1.4542
500
1.4584
1.4553
600
1.4584
1.4557
700
1.4584
1.4559
800
1.4584
1.4563
900
1.4584
1.4565
1000
1.4584
1.4566
2000
1.4584
1.4576
3000
1.4584
1.4578
4000
1.4584
1.4580
5000
1.4584
1.4581
The values in column two were computed by the function dko_call, and those in column three
are the results reported in Table 2 of Boyle and Tian (1998). The model parameters were: current
asset price S = 95.0, exercise price E = 100.0, volatility σ = 0.25, maturity τ = 1.0, interest rate
r = 0.1, dividend yield q = 0.0. The upper barrier level is set at 140.0 and the lower barrier is
set at 90.0. The other parameters used by the function dko_call were: nt = n, ns_below_S0
= n/2, ns_above_S0 = n/2, and Θm = 0.5 (i.e., the Crank–Nicolson method).

170
Computational Finance Using C and C#
Table 5.9 The estimated values of European down and out call options calculated by
the function dko_call
Time steps
Stock price
92
91
90.5
90.4
90.3
90.2
50
2.5652
1.3046
0.6588
0.5282
0.3971
0.2653
100
2.5221
1.2816
0.6466
0.5182
0.3894
0.2601
200
2.5104
1.2758
0.6435
0.5157
0.3875
0.2588
300
2.5080
1.2747
0.6429
0.5152
0.3871
0.2585
400
2.5072
1.2743
0.6427
0.5150
0.3869
0.2584
500
2.5069
1.2742
0.6426
0.5149
0.3869
0.2584
600
2.5067
1.2741
0.6425
0.5149
0.3868
0.2583
700
2.5066
1.2740
0.6425
0.5149
0.3868
0.2583
800
2.5065
1.2740
0.6424
0.5148
0.3868
0.2583
900
2.5065
1.2739
0.6424
0.5148
0.3868
0.2583
1000
2.5064
1.2739
0.6424
0.5148
0.3868
0.2583
2000
2.5063
1.2738
0.6424
0.5148
0.3868
0.2583
Closed form
2.5063
1.2738
0.6424
0.5148
0.3868
0.2583
The ﬁxed model parameters were: exercise price E = 100.0, volatility σ = 0.25, maturity τ = 1.0,
interest rate r = 0.1, dividend yield q = 0.0, and the lower barrier is set at 90.0. The other parameters
used by the function dko_call were: nt = n, ns_below_S0 = n/2, ns_above_S0 = n/2,
upper_barrier = 1000.0, lower_barrier = 90.0, and Θm = 0.5 (i.e., the Crank–Nicolson
method).
Table 5.10 The estimated values of European down and out call options as calculated
by the function dko_call
Time steps
Stock price
92
91
90.5
90.4
90.3
90.2
50
2.5572
1.3005
0.6567
0.5266
0.3958
0.2645
100
2.5181
1.2796
0.6455
0.5174
0.3888
0.2597
200
2.5084
1.2748
0.6429
0.5153
0.3872
0.2586
300
2.5067
1.2741
0.6425
0.5149
0.3869
0.2584
400
2.5062
1.2738
0.6424
0.5148
0.3868
0.2583
500
2.5061
1.2738
0.6424
0.5148
0.3868
0.2583
600
2.5061
1.2737
0.6423
0.5148
0.3867
0.2583
700
2.5060
1.2737
0.6423
0.5147
0.3867
0.2583
800
2.5060
1.2747
0.6423
0.5147
0.3867
0.2583
900
2.5060
1.2737
0.6423
0.5147
0.3867
0.2583
1000
2.5060
1.2737
0.6423
0.5147
0.3867
0.2583
2000
2.5061
1.2737
0.6423
0.5147
0.3867
0.2583
Closed form
2.5063
1.2738
0.6424
0.5148
0.3868
0.2583
The ﬁxed parameters used were: exercise price E = 100.0, volatility σ = 0.25, maturity τ = 1.0,
interest rate r = 0.1, dividend yield q = 0.0, and the lower barrier is set at 90.0. The other parameters
used by the function dko_call were: nt = n, ns_below_S0 = n/2, ns_above_S0 = n/2,
upper_barrier = 1000.0, lower_barrier = 90.0, and Θm = 0.0 (i.e., the implicit method).

Single asset American options
171
Table 5.11 The estimated values of European double knockout call options computed
by the function dko_call
Time steps
Stock price
92
91
90.5
90.4
90.3
90.2
50
0.6251 (0.6184)
0.3189 (0.3177)
0.1610
0.1290
0.0969
0.0647
100
0.6260 (0.6212)
0.3194 (0.3184)
0.1613
0.1292
0.0971
0.0649
200
0.6263 (0.6228)
0.3196 (0.3186)
0.1613
0.1293
0.0972
0.0649
300
0.6263 (0.6236)
0.3196 (0.3187)
0.1613
0.1293
0.0972
0.0649
400
0.6263 (0.6242)
0.3196 (0.3189)
0.1613
0.1293
0.0972
0.0649
500
0.6263 (0.6252)
0.3196 (0.3190)
0.1613
0.1293
0.0972
0.0649
600
0.6263 (0.6253)
0.3196 (0.3191)
0.1613
0.1293
0.0972
0.0649
700
0.6263 (0.6253)
0.3196 (0.3191)
0.1613
0.1293
0.0972
0.0649
800
0.6263 (0.6255)
0.3196 (0.3192)
0.1613
0.1293
0.0972
0.0649
900
0.6263 (0.6256)
0.3196 (0.3192)
0.1613
0.1293
0.0972
0.0649
1000
0.6263 (0.6255)
0.3196 (0.3192)
0.1613
0.1293
0.0972
0.0649
2000
0.6263 (0.6260)
0.3196 (0.3195)
0.1613
0.1293
0.0972
0.0649
In column 2 and column 3 the values given in Boyle and Tian (1998), Table 5, are shown
for comparison. The ﬁxed model parameters were: exercise price E = 100.0, volatility
σ = 0.25, dividend yield q = 0.0, maturity τ = 1.0, interest rate r = 0.1, the lower
barrier is set at 90.0, and the upper barrier is set at 140.0. The other parameters used
by the function dko_call were: nt = n, ns_below_S0 = n/2, ns_above_S0 = n/2,
and Θm = 0.5 (i.e., the Crank–Nicolson method).
Table 5.12 The estimated Greeks for European double knockout call options computed
by the function dko_call
Asset price
Gamma
Delta
Theta
95.0
−0.0165 (−0.0166)
0.2536 (0.2551)
2.3982 (2.3928)
92.0
−0.0141 (−0.0141)
0.2998 (0.3016)
1.0268 (1.0242)
91.0
−0.0129 (−0.0130)
0.3133 (0.3151)
0.5237 (0.5224)
90.5
−0.0123 (−0.0123)
0.3196 (0.3215)
0.2643 (0.2636)
90.4
−0.0121 (−0.0122)
0.3208 (0.3227)
0.2119 (0.2113)
90.3
−0.0120 (−0.0121)
0.3221 (0.3239)
0.1592 (0.1588)
90.2
−0.0119 (−0.0119)
0.3233 (0.3251)
0.1063 (0.1060)
The ﬁxed model parameters: the exercise price E = 100.0, volatility σ = 0.25, dividend
yield q = 0.0, maturity τ = 1.0, interest rate r = 0.1, the lower barrier is set at 90.0, and
the upper barrier is set at 140.0. The other parameters used by the function dko_call
were: nt = 200, ns_below_S0 = 100, ns_above_S0 = 100, and Θm = 0.5 (i.e., the
Crank–Nicolson method). The results for Θm = 0.0 (i.e., the implicit method) are shown
in brackets; see Table 6, Boyle and Tian (1998).
Inspection of the results shows that the ﬁnite-difference grid method has both
greater accuracy and faster convergence than the method proposed by BT. The

172
Computational Finance Using C and C#
key to the accuracy achieved by dko_call is a combination of:
• The logarithmic transformation of the Black–Scholes equation
• The ability to place a grid line at both the upper barrier BU, and also at the
lower boundary BL
• The use of a weighted Θm ﬁnite-difference scheme, 0 ⩽Θm ⩽1, instead of
the numerically unstable explicit ﬁnite-difference method used by a trinomial
lattice which in our notation (see Section 5.4.2) is equivalent to Θm = 1.
It should be mentioned that the function dko_call could, without much
difﬁculty, be modiﬁed to deal with:
• American double knockout call options
• European double knockout put options
• American double knockout put options
and also a range of other variations which may include lockout periods, rebates,
etc. In particular, options with time-varying barrier levels can be dealt with by
using grid lines to locate the barrier position at each time instant.
5.5
Pricing American options using a stochastic lattice
In this section we consider the use of Monte Carlo simulation and stochastic
lattices to price American options. Information on the use of Monte Carlo sim-
ulation to value both single asset and multiasset European options is provided
in Chapter 4 and Chapter 6. The main difﬁculty in using simulation to value
American options is the need to incorporate optimal early exercise policies. The
standard simulation algorithms for valuing European contracts are forward in
time. That is each price path, which contributes to the value of the option, is
generated by stepping forward from current time, t, to option maturity, t + τ,
where τ is the duration of the option. For instance if there are n equispaced
time steps of size t, and only one underlying asset, then we use the asset values
Si, i = 0, . . . , n, where Si corresponds to the asset value at the ith time instant,
ti, and t0 = t. Here Si+1 is generated from the previous asset value Si as follows:
Si+1
Si
= dSi
for i = 0, . . . , n −1
(5.5.1)
where dSi is a random variate taken from a given distribution. When Si follows
GBM, we have from Eq. (2.3.11) that:
Si+1
Si
= exp

r −σ 2
i
2

t + σi dWi

,
i = 0, . . . , n −1,
(5.5.2)
where dWi ∼N(0, t) and the usual deﬁnitions are used for σi and r.
For European exotic options (such as time dependent barrier options) the
value of a particular price path will depend on the asset values Si, i = 0, . . . , n.

Single asset American options
173
This is not true of European vanilla options whose value only depends on Sn,
the underlying asset price at option maturity. The Monte Carlo approximation
to the value of a European option is thus:
f =

nsim
j=1 pj(nj)
nsim
where nsim is the number of simulations used, nj is the number of time steps
associated with the jth price path, and pj(nj) is the value of the jth price path.
In the case of European vanilla options we can use nj = 1, j = 1, . . . , nsim; the
accuracy obviously improves with increasing nsim.
The valuation of American-style options, which include the possibility of early
exercise, is more complicated. In Chapter 5 we described the use of binomial lat-
tices to price American options when the underlying asset price process is GBM.
Dynamic programming was used and the option prices were computed by work-
ing backward in time through the lattice. The application of Monte Carlo meth-
ods for pricing American options is described in Tilley (1993), Barraquand and
Martineau (1995), and also Boyle, Broadie, and Glasserman (1997). Here we
will outline the stochastic lattice approach discussed in Broadie and Glasserman
(1997), where both a high estimator and a low estimator of the American op-
tion value are calculated. Since both of these biased estimators converge (with
increasing number of simulations and lattice nodes) to the true option value, we
will only consider how to compute the high estimator, θH. We summarize the
approach as follows
• Set the parameters
• Generate the lattice asset prices
• Compute the lattice option prices
• Compute the Monte Carlo estimate.
We will now consider each of these steps in more detail.
Set the parameters
First we set the simulation parameters; that is: nsim is the number of lattice
simulations, b is the number of branches per lattice node, and d is the number
of time instants in the lattice. Note: This deﬁnition of d here is different from
that used in the original paper by Broadie and Glasserman (1997) where d is
deﬁned as the number of time steps in the lattice.
Generate the lattice asset prices
Next we generate the asset prices for the pth stochastic lattice. Since the lattice is
non recombining at the i lattice time instant there are bi nodes/asset prices. This
contrasts with the binomial lattice of Chapter 5 where the asset prices at a given
time step are arranged in ascending order, that is Sj
i increases with increasing j.

174
Computational Finance Using C and C#
Figure 5.9 An example showing the asset prices generated for a stochastic lattice with
three branches per node and two time steps, that is b = 3 and d = 3. The current asset
value, 101, is at time t0, and the asset values at option maturity are at time t2.
We will denote the jth value at the ith time step by Sj
i . For example, in Fig. 5.9,
where b = 3 and d = 3, we have for the ﬁrst time step:
S1
1 = 115,
S2
1 = 60,
and S3
1 = 114
and for the second time step:
S1
2 = 116,
S2
2 = 90,
S3
2 = 149,
. . . ,
S7
2 = 102,
S8
2 = 88,
S9
2 = 80
The kth asset price at the ith time step, Sk
i then generates the following asset
prices at the (i + 1)th time step:
S(k−1)b+j
i+1
Sk
i
= dSj,
j = 1, . . . , b, k = 1, . . . , bi,
where (see Eq. (5.5.1)), dSj is a random variate from a given distribution. When
Si follows GBM, we therefore have:
S(k−1)b+j
i+1
Sk
i
= exp

r −σ 2
i
2

t + σi dWi

,
j = 1, . . . , b, k = 1, . . . , bi
Compute the lattice option prices
The method used to compute the option values is similar to that used by the
binomial lattice. The main difference is that there are now b branches per node
instead of two. The option values are computed by starting at the lattice termi-

Single asset American options
175
nal nodes and then iterating backward. Here we denote the kth option value at
the ith time step by f k
i .
The option values at the terminal nodes, time instant td−1, are computed in
the usual manner. For a put we have:
f k
d−1 = max

E −Sk
d−1, 0

,
k = 1, . . . , bd−1,
where E is the exercise price.
The option values at the (i −1)th time step are computed from those at the
ith time step as follows:
f k
i−1 = max

gk
i−1, hk
i−1

where
hk
i−1 = exp(−rt)
b
b

j=1
f (k−1)b+j
i
and
gk
i−1 = max

E −Sk
i−1, 0

The option value for the pth stochastic lattice is therefore:
θp
H = f 1
0 = exp(−rt)
b
b

j=1
f j
1
Figure 5.10 shows the option values for an American call with strike price E =
100 and interest rate r = 0, when the lattice asset prices in Fig. 5.9 have been
Figure 5.10 The option prices for the b = 3, d = 3 lattice in Fig. 5.9 corresponding to an
American put with strike E = 100 and interest rate r = 0. The option values at the lattice
nodes are computed backwards in time from the payoffs at maturity, t2 to the current
time t0; the value of the option is 11.9.

176
Computational Finance Using C and C#
used. To make things as clear as possible, we will show how the value of each
node is computed.
Terminal nodes
The option values at the terminal nodes are:
f 1
2 = max(116 −100, 0) = 16,
f 2
2 = max(90 −100, 0) = 0,
f 3
2 = max(149 −100, 0) = 49,
f 4
2 = max(32 −100, 0) = 0,
f 5
2 = max(50 −100, 0) = 0,
f 6
2 = max(48 −100, 0) = 0,
f 7
2 = max(102 −100, 0) = 2,
f 8
2 = max(88 −100, 0) = 0,
f 9
2 = max(80 −100, 0) = 0
Time step 1
Here we have:
g1
1 = max(115 −100, 0) = 15,
g2
1 = max(60 −100, 0) = 0,
g3
1 = max(114 −100, 0) = 14
Since r = 0, we have exp(−rt) = 1 which gives:
h1
1 = 1
3

f 1
2 + f 2
2 + f 3
2

= 1
3{16 + 0 + 49} = 21.7
h2
1 = 1
3

f 4
2 + f 5
2 + f 6
2

= 1
3{0 + 0 + 0} = 0
h3
1 = 1
3

f 7
2 + f 8
2 + f 9
2

= 1
3{2 + 0 + 0} = 0.66
The option values are then computed as follows:
f 1
1 = max

h1
1, g1
1

= max(21.7, 15) = 21.7
f 2
1 = max

h2
1, g2
1

= max(0, 0) = 0
f 3
1 = max

h3
1, g3
1

= max(0.66, 14.0) = 14.0
Time step 0
Here
g1
0 = max(101 −100, 0) = 1
and
h1
0 = 1
3

f 1
1 + f 2
1 + f 3
1

= 1
3{21.7 + 0 + 14.0} = 11.9
The ﬁnal value of the option for this particular lattice is therefore:
f 1
1 = max

h1
0, g1
0

= max(11.9, 1) = 11.9

Single asset American options
177
Compute the Monte Carlo estimate
The Monte Carlo estimate, θH, is computed as the average of θp
H, p
=
1, . . . , nsim, where nsim is the number of simulations:
θH =

nsim
i=1 θi
H
nsim
In Code excerpt 5.21, we provide a computer program which prices single asset
American put and call options using a stochastic lattice. The method used by the
program is the depth ﬁrst procedure outlined in Broadie and Glasserman (1997),
which has the advantage that the memory requirements are only of order b × d;
as before, b is the number of branches per node and d is the number of time
intervals.
Here it is assumed the underlying asset follows GBM and the function
normal(M, S) is used to generate a normal distribution with mean M and
standard deviation S. We can therefore check the accuracy of the simulation
with that obtained by a closed form solution which assumes a lognormal asset
distribution, in this case the formula in Geske and Johnson (1984).
However, the real power of this method is when the underlying asset fol-
lows a more realistic process which is non-Gaussian and time varying. The only
modiﬁcation to the code is to replace the call to normal with that of another
probability distribution and supply the time-varying parameters to it.
// Stochastic lattice for computing the value of American and European options via Monte Carlo_
simulation.
// Here we assume that the asset prices have a lognormal distribution, and so generate
// normal variates; this assumption can easily be removed.
void __cdecl main()
{
long i,j,jj,is_put,is_american,w[200],num_simulations,b,d,seed;
double T,time_step,sqrt_time_step,opt_value,pay_off,log_fac,asset_price;
double temp,opt_val,hold,sum_opt_val,disc;
double tot_opt_vals, X, drift_term, std_term, S0, q, r, sigma, zero = 0.0;
double v[200][60], opt_v[200][60];
printf("Stochastic lattice for pricing European and American options \n");
is_put = 1;
// If is_put == 0 then a call option, otherwise a put option
T = 1.0;
// The time to maturity of the option
is_american = 1; // If is_american
== 0 then an European option, otherwise an American_
option
sigma = 0.2;
// The volatility of the underlying asset
X = 110.0;
// The strike price
S0 = 100.0;
// The current price of the underlying assset
r = 0.1;
// The risk free interest rate
q = 0.05;
// The continuous dividend yield
d = 4;
// The number of time steps, the number time intervals = d - 1
b = 50;
// The number of branches per node in the lattice
time_step = T/(double)(d-1); // time step = T/(number of time intervals)
sqrt_time_step = sqrt(time_step);
disc = exp(-r*time_step); // The discount factor between time steps
std_term = sigma*sqrt(time_step); // The standard deviation of each normal variate generated
drift_term = (r - q - sigma*sigma*0.5)*time_step; // The mean value of each normal variate_
generated
seed = 111;
// The seed for the random number generator
srand(seed);
tot_opt_vals = zero;
num_simulations = 100;
for (jj = 1; jj <= num_simulations; ++jj) {
v[1][1] = S0;
Code excerpt 5.21.

178
Computational Finance Using C and C#
w[1] = 1;
asset_price = S0;
for (j = 2; j <= d; ++j) {
w[j] = 1;
log_fac = normal(drift_term,std_term); // A normal variate:mean==drift_term,_
standard deviation==std_term
asset_price = asset_price*exp(log_fac); // Compute the new asset price: assuming a_
lognormal distribution
v[1][j] = asset_price;
}
j = d;
while (j > 0) {
if ((j == d) && (w[j] < b)) { // CASE 1::Terminal node, set asset prices for b branches,_
and option values for b-1 branches
if (is_put ) {
pay_off = MAX (X - v[w[j]][j],zero);
}
else {
pay_off = MAX (v[w[j]][j]-X,zero);
}
opt_v[w[j]][j] = pay_off;
asset_price = v[w[j-1]][j-1];
log_fac = normal(drift_term,std_term);
v[w[j]+1][j] = asset_price*exp(log_fac);
w[j] = w[j] + 1;
}
else if ((j == d) && (w[j] == b)) { // CASE 2::Terminal node, set option value for last_
branch
if (is_put) {
pay_off = MAX (X - v[w[j]][j],zero);
}
else {
pay_off = MAX (v[w[j]][j]-X,zero);
}
opt_v[w[j]][j] = pay_off;
w[j] = 0;
j = j - 1;
}
else if ((j < d) && (w[j] < b)) { // CASE 3::Internal node, calculate option value for_
node (parent wrt to cases 1 & 2)
sum_opt_val = zero;
// Also generate a new terminal node and set asset_
values.
for (i = 1; i <= b; ++i) {
sum_opt_val += opt_v[i][j+1];
}
temp = sum_opt_val/(double)b;
hold = temp*disc;
if (is_american) { // An American option
if (is_put) {
pay_off = MAX(X-v[w[j]][j],zero); // pay off for a put option
}
else {
pay_off = MAX(v[w[j]][j]-X,zero);
// pay off for a call option
}
opt_val = MAX(pay_off,hold);
}
else { // A European option
opt_val = hold;
}
opt_v[w[j]][j] = opt_val;
if (j > 1) {
asset_price = v[w[j-1]][j-1];
log_fac = normal(drift_term,std_term);
v[w[j]+1][j] = asset_price*exp(log_fac);
w[j] = w[j] + 1;
for (i = j + 1; i <= d; ++i) { // Generate a new terminal node
log_fac = normal(drift_term,std_term);
asset_price = asset_price*exp(log_fac);
v[1][i] = asset_price;
w[i] = 1;
}
j = d;
}
else {
j = 0;
}
Code excerpt 5.21 (Continued).

Single asset American options
179
}
else if ((j < d) && (w[j] == b)) { // CASE 4::Internal node, calculate the option value_
for the last branch
sum_opt_val = zero;
for (i = 1; i <= b; ++i) {
sum_opt_val += opt_v[i][j+1];
}
temp = sum_opt_val/(double)b;
hold = temp*disc;
if (is_american) { // An American option
if (is_put) {
pay_off = MAX(X - v[w[j]][j],zero); // pay off for a put option
}
else {
pay_off = MAX(v[w[j]][j]-X,zero); // pay off for a call option
}
opt_val = MAX(pay_off,hold);
}
else { // A European option
opt_val = hold;
}
opt_v[w[j]][j] = opt_val;
w[j] = 0;
j = j - 1;
}
}
tot_opt_vals = tot_opt_vals + opt_v[1][1]; // Sum the option values for each simulation
}
opt_value = tot_opt_vals/(double)num_simulations; // Compute the average option value
printf ("The estimated option value = %12.4f\n", opt_value);
}
Code excerpt 5.21 A computer program that uses a stochastic lattice to value American
and European options.
Table 5.13 American put option values, computed using the stochastic lattice given in
Code excerpt 5.21, with four exercise times t, t + τ/3, t + 2τ/3 and t + τ
X
MC100
50
MC1
250
True
Binomial lattice
70
0.118 (0.003)
0.123 (0.002)
0.121
0.126
80
0.663 (0.007)
0.672 (0.002)
0.670
0.696
90
2.317 (0.014)
2.307 (0.004)
2.303
2.389
100
5.830 (0.099)
5.720 (0.011)
5.731
5.928
110
11.564 (0.223)
11.361 (0.020)
11.341
11.770
120
20.205 (0.205)
20.000 (0.000)
20.000
20.052
130
30.054 (0.054)
30.000 (0.000)
30.000
30.000
The option parameters used were: r = 0.1, q = 0.05, τ = 1.0, σ = 0.2, and S = 100.0.
The column labelled MC100
50
refers to the results obtained using d = 4, b = 50,
num_simulations = 100, and the column labelled MC1
250 refers to the results obtained
using d = 4, b = 50, num_simulations = 1. The true values are those given in Broadie
and Glasserman (1997), and were computed with the formula in Geske and Johnson
(1984). The absolute error, ABS(stochastic_lattice_value −true_value), is given in
brackets. The last column gives the values computed using an accurate (6000 time step)
binomial lattice.
In Table 5.13 we present computed values of an American put option with
maturity τ, which can only be exercised at the following four times: t, t + τ/3,
t + 2τ/3 and t + τ, where t is the current time.

180
Computational Finance Using C and C#
The column labelled MC100
50 contains the results obtained using 100 simula-
tions of a stochastic lattice with 50 branches per node, and the column labelled
MC1
250 contains the values computed using a single stochastic lattice with 250
branches per node. These values demonstrate that one high accuracy stochas-
tic lattice can give better results than using the average of 100 lower accuracy
lattices. In the last column we present the results obtained using a 6000 step
binomial lattice in which it is possible to exercise the option at every time step.
It can be seen that the binomial option values are higher than the true values,
which only permit the option to be exercised at four distinct times. This is in
agreement with the extra ﬂexibility present in the binomial lattice.

6 Multiasset options
6.1
Introduction
In this section we consider the valuation of multiasset, basket, options within
the Black–Scholes pricing framework. These options will be priced using the
following techniques:
• Analytic methods
• Monte Carlo methods
• Multidimensional lattices
Analytic methods can be useful for pricing multiasset European options which
have a known closed form solution. They are particularly appropriate for low
dimensional European options, when the closed form expressions are not too
difﬁcult to evaluate.
Monte Carlo methods have the advantage that they can easily compute the
value of multiasset European options, but have difﬁculty including the possibil-
ity of early exercise; this is required for American-style options.
On the other hand, multidimensional lattice techniques allow American op-
tions to be evaluated with ease. However, lattices become increasingly difﬁcult
to program as the number of dimensions increases, and the constraints of com-
puter storage limits their use to problems involving (about) four or less assets.
6.2
The multiasset Black–Scholes equation
In Chapter 2 we mentioned that when the price, S, of a single asset follows
geometric Brownian motion (GBM) the change in price, dS, over a time interval,
dt, is given by:
dS = rS dt + σS dW
where r is the risk free interest rate, σ is the volatility of asset S, and dW ∼
N(0, dt).
We also proved using Ito’s lemma that the process followed by Y = log(S) is:
dY =

r −σ 2
2

dt + σ dW

182
Computational Finance Using C and C#
where dY is the change in the value of log(S) over the time interval dt. Later on
we derived the (Black–Scholes) partial differential equation that is satisﬁed by
the value, V , of an option written on a single underlying asset. The equation is
∂V
∂t + σ 2S2
2
∂2V
∂S2 + rS ∂V
∂S −rV = 0
The above result can be generalized to deal with multiasset options. Suppose
that m assets are described by the following processes:
dYi =

r −σ 2
i
2

dt + σi dWi,
i = 1, . . . , m,
(6.2.1)
where the subscript i refers to the value associated with the ith asset. The
m-element random vector dW is distributed according to dW ∼N(0, C). The
diagonal elements of C are Cii = Var[dWi] = dt, i = 1, . . . , m, and off-diagonal
elements are:
Cij = E[dWi dWj] = ρi,j dt,
i = 1, . . . , m, j = 1, . . . , m, i ̸= j
We can also write the above equation in vector form by introducing the
m-element vector dY which is normally distributed as:
dY ∼N(ν, C)
(6.2.2)
where ν is the mean vector and C is the covariance matrix. The elements of the
covariance matrix are:
Cii = σ 2
i dt,
i = 1, . . . , m,
Cij = σiσjρij dt,
i ̸= j, i = 1, . . . , m, j = 1, . . . , m,
(6.2.3)
where ρij is the correlation coefﬁcient between asset i and asset j; that is, the
correlation between dWi and dWj. The elements of the mean vector ν are:
νi = r −σ 2
i
2 ,
i = 1, . . . , m
(6.2.4)
The value V of an option written on m assets satisﬁes the following partial
differential equation:
∂V
∂t + 1
2
m

i=1
m

j=1
σiσjρijSiSj
∂2V
∂Si ∂Sj
+ r
m

i=1
Si
∂V
∂Si
−rV = 0.
For a European call on the maximum of m assets the pay-off PMAX
c
at maturity
(time τ) is given by PMAX
c
= max(max(Sτ
1 , Sτ
2, . . . , Sτ
m) −E, 0), where Sτ
i , i =
1, . . . , m, denotes the value of the ith asset at maturity, and E represents the
strike price. Similarly a European put option on the minimum of m assets has a
pay-off, PMIN
p
, at time τ, given by PMIN
p
= max(E −min(Sτ
1 , Sτ
2 , . . . , Sτ
m), 0).

Multiasset options
183
6.3
Multidimensional Monte Carlo methods
We have already mentioned that Monte Carlo simulation can easily price Euro-
pean multiasset options (also sometimes referred to as basket options, or rain-
bow options) involving a large number of assets (say 20 or more).
In addition Monte Carlo simulation can also include the following features
into an option without much difﬁculty:
• Non-Gaussian distribution of stock returns; distributions with heavy tails are
usually of interest because they more accurately represent what is observed in
the ﬁnancial markets
• Options with path dependency (such as barrier options, etc.); these are known
as exotic options
• Complex time dependency (e.g., ARMA, GARCH or Levy processes) of
model parameters such as interest rates, asset prices, etc.
The main drawbacks with Monte Carlo simulation are:
• It is to difﬁcult compute the value of American-style options
• It is difﬁcult (or impossible) to achieve the same accuracy that can be obtained
using ﬁnite difference methods.
In a different section of this book we will show how Monte Carlo simulation
can be used to price American options by using a hybrid Monte Carlo lattice
approach originally developed by Boyle, Evnine, and Gibbs (1997).
In Chapter 3 we show that when pseudo-random numbers are used, the stan-
dard errors of integrals computed via Monte Carlo simulation decrease at the
rate N1/2, where N is the number of simulations. This means that it can re-
quire hundreds of thousands of simulations just to achieve an accuracy of 10−1
or 10−2 in the estimated option price. It is because of this that various Monte
Carlo variance reduction techniques are used to increase the accuracy of the
computed integral.
In this section we show how to price a three-asset basket option using Monte
Carlo simulation; the accuracy of the results obtained with quasirandom num-
bers and pseudo-random numbers are compared.
The options we consider are European put and call options on the maximum
and minimum of three assets. All the options have a maturity of one year, and
the other model parameters used are given in Tables 6.1 and 6.2.
In Code excerpt 6.1 most of the work is done by the routine multivari-
ate_normal. This generates a vector of multivariate pseudo-random numbers
with a particular covariance matrix. In the program the values of the assets at
current time t are S1 = S2 = S3 = 100, and the option matures in one year.
The asset process evolves according to
dYi = log(Si,t+dt) −log(Si,t) =

r −σ 2
i
2

dt + σi dWi,
i = 1, . . . , m,

184
Computational Finance Using C and C#
Table 6.1 The computed values and absolute errors, in brackets, for European options
on the maximum of three assets
Nsim
Put
Quasi
Pseudo
500
0.890 (4.5948 × 10−2)
1.1044 (1.6839 × 10−1)
1000
0.924 (1.1534 × 10−2)
1.0193 (8.3297 × 10−2)
1500
0.919 (1.6807 × 10−2)
0.8957 (4.0344 × 10−2)
2000
0.932 (4.3221 × 10−3)
0.8995 (3.6488 × 10−2)
2500
0.932 (3.5698 × 10−3)
0.8886 (4.7352 × 10−2)
3000
0.937 (1.1376 × 10−3)
0.9025 (3.3548 × 10−2)
Call
Quasi
Pseudo
500
22.629 (4.3231 × 10−2)
22.4089 (2.6312 × 10−1)
1000
22.683 (1.1306 × 10−2)
22.3520 (3.1998 × 10−1)
1500
22.670 (2.2954 × 10−3)
22.6346 (3.7430 × 10−2)
2000
22.685 (1.3299 × 10−2)
22.7675 (9.5491 × 10−2)
2500
22.670 (1.6619 × 10−3)
22.9326 (2.6058 × 10−1)
3000
22.679 (7.2766 × 10−3)
22.8050 (1.3301 × 10−1)
Monte Carlo simulation was used with both quasirandom (Sobol) sequences and pseudo-
random sequences. The number of paths used varied from 500 to 3000. The parameters
were: E = 100.0, S1 = S2 = S3 = 100.0, r = 0.1, τ = 1.0, σ1 = σ2 = σ3 = 0.2, ρ12 =
ρ13 = ρ23 = 0.5, q1 = q2 = q3 = 0.0. The accurate values were 0.936 for a put and
22.672 for a call; see Table 6.7 and Table 2 of Boyle, Evnine, and Gibbs (1989).
where we have used the notation Si,t to denote the value of the ith asset at
current time t, and Si,t+dt to denote the value of the asset at the future time
t + dt. Simple rearrangement of the above equation gives:
log
Si,t+dt
Si,t

=

r −σ 2
i
2

dt + σi dWi,
i = 1, . . . , m
Taking exponentials of both sides we obtain:
Si,t+dt
Si,t
= exp

r −σ 2
i
2

dt + σi dWi

,
i = 1, . . . , m,
which is equivalent to:
Si,t+dt = Si,t exp

r −σ 2
i
2

dt + σi dWi

(6.3.1)

Multiasset options
185
Table 6.2 The computed values and absolute errors, in brackets, for European options
on the minimum of three assets
Nsim
Put
Quasi
Pseudo
500
7.365 (3.8122 × 10−2)
7.6760 (2.7298 × 10−1)
1000
7.425 (2.1554 × 10−2)
7.7607 (3.5772 × 10−1)
1500
7.408 (5.1232 × 10−3)
7.5654 (1.6240 × 10−1)
2000
7.399 (3.6364 × 10−3)
7.4820 (7.8995 × 10−2)
2500
7.407 (4.1463 × 10−3)
7.3592 (4.3754 × 10−2)
3000
7.400 (2.7166 × 10−3)
7.3997 (3.3236 × 10−3)
Call
Quasi
Pseudo
500
5.312 (6.3431 × 10−2)
5.3086 (5.9591 × 10−2)
1000
5.293 (4.3958 × 10−2)
5.4376 (1.8857 × 10−1)
1500
5.253 (4.0761 × 10−3)
5.4121 (1.6307 × 10−1)
2000
5.266 (1.7236 × 10−2)
5.4029 (1.5390 × 10−1)
2500
5.267 (1.7707 × 10−2)
5.4690 (2.2005 × 10−1)
3000
5.245 (3.5024 × 10−3)
5.4331 (1.8407 × 10−1)
Monte Carlo simulation was used with both quasirandom (Sobol) sequences and pseudo-
random sequences. The number of paths used varied from 500 to 3000. The parameters
were: E = 100.0, S1 = S2 = S3 = 100.0, r = 0.1, τ = 1.0, σ1 = σ2 = σ3 = 0.2, ρ12 =
ρ13 = ρ23 = 0.5, q1 = q2 = q3 = 0.0. The accurate values were 7.403 for a put and 5.249
for a call; see Table 6.8 and Table 2 of Boyle, Evnine, and Gibbs (1989).
6.4
Introduction to multidimensional lattice methods
Finite-difference lattices can be used to value options on up to about 4 assets
before they require impossibly large amounts of computer memory. The main
advantage of ﬁnite-difference methods is that they are able to easily cater for
American style early exercise within the option. This is not true of Monte Carlo
methods. They can easily model complex European options, but have difﬁculty
modelling American-style options.
In this section we use the approach of Kamrad and Ritchken (1991), and
Boyle, Evnine, and Gibbs (1989), which we will call the BEGKR method, to
price multiasset options. We ﬁrst derive expressions for the jump size and jump
probabilities for a single asset, and show that these are equivalent to those of the
Cox, Ross, and Rubinstein binomial lattice (CRR lattice) discussed in Chapter 5.
We will then give expressions for the jump sizes and jump probabilities of a
general multiasset option.
To derive the BEGKR equations for one asset we ﬁrst assume that the asset
follows a lognormal process with drift μ = r −σ 2/2, where r is the riskless
interest rate and σ is the instantaneous volatility.

186
Computational Finance Using C and C#
/* Monte Carlo simulation: 3 dimensional Black-Scholes, The results are compared with those_
of Boyle et. al.,1989
George Levy: 2007
*/
long seed,i,num_simulations,iflag;
double time_step,sqrt_time_step,rho, zero = 0.0, half = 0.5;
double r,opt_val, opt_val1, tol;
double the_max, the_min, X, ST1, ST2, ST3, ST4, S1, S2, S3, S4;
double disc, sumit_max_put, sumit_max_call;
double sumit_min_put, sumit_min_call;
double *rvec = (double *)0;
double rho_12, rho_13, rho_23;
double
*c3, *c4, *z, *std, *means;
double tmp1, tmp2, tmp3, tmp4, sigma1, sigma2, sigma3, sigma4;
long is_fcall;
#define MEANS(I) means[(I)-1]
#define XBAR(I) xbar[(I)-1]
#define Z(I) z[(I)-1]
#define STD(I) std[(I)-1]
#define C3(I,J) c3[((I)-1) * 3 + ((J)-1)]
seed = 111;
r = 0.1;
sigma1 = 0.2;
sigma2 = 0.2;
sigma3 = 0.2;
S1 = 100.0;
S2 = 100.0;
S3 = 100.0;
X = 100.0;
rho_12 = 0.5;
rho_13 = 0.5;
rho_23 = 0.5;
time_step = 1.0;
sqrt_time_step = sqrt(time_step);
disc = exp(-r*time_step);
c3 = ALLOCATE(3*3, double);
means = ALLOCATE(3, double);
z = ALLOCATE(3, double);
std = ALLOCATE(3, double);
if ((!means) || (!std) || (!z) ) {
printf("Allocation error \n");
}
tmp1 = sigma1*sigma1*time_step;
tmp2 = sigma2*sigma2*time_step;
tmp3 = sigma3*sigma3*time_step;
C3(1,1) = tmp1;
C3(2,2) = tmp2;
C3(3,3) = tmp3;
C3(1,2) = sigma1*sigma2*time_step*rho_12;
C3(2,3) = sigma2*sigma3*time_step*rho_23;
C3(1,3) = sigma1*sigma3*time_step*rho_13;
C3(2,1) = C3(1,2);
C3(3,1) = C3(1,3);
C3(3,2) = C3(2,3);
tmp1 = (r - sigma1*sigma1*half)*time_step;
tmp2 = (r - sigma2*sigma2*half)*time_step;
tmp3 = (r - sigma3*sigma3*half)*time_step;
MEANS(1) = tmp1;
MEANS(2) = tmp2;
MEANS(3) = tmp3;
Code excerpt 6.1 A Monte Carlo simulation computer program, using pseudo-random
numbers, for estimating the value of European put and call options on the maximum and
minimum of three underlying assets. The results are presented in Tables 6.1 and 6.2.

Multiasset options
187
sumit_max_put = zero;
sumit_max_call = zero;
sumit_min_put = zero;
sumit_min_call = zero;
tol = 1.0e-8;
srand(seed);
is_fcall = 1;
/* initialisation call to the random number generator */
multivariate_normal(is_fcall,&MEANS(1),3,&C3(1,1),3,tol,&rvec,&Z(1),&iflag);
num_simulations = 6000;
is_fcall = 0;
for (i = 1; i <= num_simulations ; ++i) {
/* continuation calls to the random number generator */
multivariate_normal(is_fcall,&MEANS(1),3,&C3(1,1),3,tol,&rvec,&Z(1),&iflag);
ST1 = S1*exp(Z(1));
ST2 = S2*exp(Z(2));
ST3 = S3*exp(Z(3));
// options on the maximum
tmp2 = MAX(ST1,ST2);
the_max = MAX(tmp2,ST3);
tmp1 = the_max-X;
opt_val1 = MAX(tmp1, zero);
sumit_max_call += opt_val1*disc;
tmp1 = X-the_max;
opt_val1 = MAX(tmp1, zero);
sumit_max_put += opt_val1*disc;
// options on the minimum
tmp2 = MIN(ST1,ST2);
the_min = MIN(tmp2,ST3);
tmp1 = the_min-X;
opt_val1 = MAX(tmp1, zero);
sumit_min_call += opt_val1*disc;
tmp1 = X-the_min;
opt_val1 = MAX(tmp1, zero);
sumit_min_put += opt_val1*disc;
}
opt_val = sumit_max_put/(double)num_simulations;
/* put option value on the maximum_
of three assets */
opt_val = sumit_max_call/(double)num_simulations; /* call option value on the maximum_
of three assets */
opt_val = sumit_min_put/(double)num_simulations; /* put option value on the minimum_
of three assets */
opt_val = sumit_min_call/(double)num_simulations; /* call option value on the maximum_
of three assets */
}
Code excerpt 6.1 (Continued).
Therefore if St is the price of the asset at time t, and St+t is the price at time
instant t + t, we then have the following equations:
log(St+t) = log(St) + εt,
εt ∼N

μt, σ 2t

,
or equivalently
log
St+t
St

∼N

μt, σ 2t

where εt represents a random variable and as usual N(μt, σ 2t) denotes a
Gaussian with mean μt and variance σ 2t.

188
Computational Finance Using C and C#
We will now consider the situation when εt either jumps up or down by an
amount ν = σ
√
t. For an up jump:
log
St+t
St

= σ
√
t
and therefore St+t = St exp(σ
√
t).
While for a down jump we have
log
St+t
St

= −σ
√
t
and therefore St+t = St exp(−σ
√
t).
The reader will notice that these expressions are the same as those for the
CCR lattice of Chapter 5. That is: for an up jump St+t = Stu, for a down
jump St+t = Std, and u = 1/d = exp(σ
√
t).
The probability of undergoing either an up or down jump occurring can be
found by matching the mean and variance of εt.
From the mean:
E[εt] = ν(pu −pd) = μt
(6.4.1)
and from the variance:
Var[εt] = ν2(pu + pd) = σ 2t
(6.4.2)
So combining Eqs. (6.4.1) and (6.4.2) we obtain:
νμt + σ 2t = 2ν2pu
so
pu = 1
2
σ 2t
ν2
+ μt
ν

Substituting ν = σ
√
t we obtain:
pu = 1
2

1 + μ
√
t
σ

(6.4.3)
and using the fact that pd = 1 −pu gives:
pd = 1
2

1 −μ
√
t
σ

(6.4.4)
We shall now show that this is equivalent to the Cox–Rubinstein–Ross binomial
model.
For the CRR model (Chapter 5, Eq. (5.3.19)) we have:
pu = exp(rt) −d
u −d
expanding exp(rt), u and d to order t we obtain:

Multiasset options
189
exp(rt) ∼1 + rt
u = exp

σ
√
t

∼1 + σ
√
t + σ 2
2 t
d = exp

σ
√
t

∼1 −σ
√
t + σ 2
2 t
so
exp(rt) −d ∼rt + σ
√
t −σ 2t
2
and
u −d ∼2σ
√
t
So
pu = exp(rt) −d
u −d
∼rt + σ −σ 2/2t
2σ
√
t
which simpliﬁes to
pu = 1
2

1 + μ
√
t
σ

and therefore
pd = 1 −pu = 1
2

1 −μ
√
t
σ

which are the expressions for pu and pd given in Eqs. (6.4.1) and (6.4.2), re-
spectively. So we have shown that, to ﬁrst order in t, both the size of the jump
and the probability of the jump are the same as the CRR binomial model.
The attractive feature of the BEGKR binomial lattice model is that it can easily
be generalized to describe a model consisting of k assets. Here we will merely
quote the results in Kamrad and Ritchken (1991). As before it is assumed that
the asset prices follow a multivariate lognormal distribution. Let μi = r −σ 2
i /2,
and σi be the instantaneous mean and variance, respectively (i = 1, 2, . . . , k)
and let ρij be the correlation between asset i and j. The binomial model now
requires 2k possible jumps in the time interval t. Let m denote the state of
the process after time t with pm representing the probability of state m (m =
1, . . . , 2k). The probabilities of these jumps are now given by:
pm =

1 +
√
t
k

i=1
xim
μi
σi

+
k−1

i=1
k

j=i+1

xm
ij ρij


,
m = 1, 2, . . . , 2k, k ⩾2,
where xim = 1 if asset i has an up jump in state m, and xim = −1 if asset i has
a down jump in state m. In addition xm
ij = 1 if asset i and asset j have jumps in
the same direction in state m, and xm
ij = −1 if asset i and asset j have jumps in
the opposite direction in state m.

190
Computational Finance Using C and C#
6.5
Two asset options
In this section we consider options based on the underlying prices of two as-
sets, S1 and S2. We give analytic formulae to price European exchange options
and also those based on the maximum or minimum of two assets. In addi-
tion we show how to construct binomial lattices for the valuation of two asset
American-style options.
6.5.1
European exchange options
A European exchange option gives the holder the right to exchange one asset
for another asset at maturity; see Margrabe (1978). Let the real-world processes
of assets SA and SB be:
dSA
t = SA
t μA dt + SA
t σA dW P
A
dSB
t = SB
t μB dt + SB
t σB dW P
B
where SA
t
denotes the value of asset A at time t and SB
t
denotes the value of
asset B at time t—the other symbols have their obvious meanings.
We will now ﬁnd the value, at current time t0, of an option that gives the
holder the right to exchange asset A for asset B at maturity T . The payoff at
maturity is HT = max(SB
T −SA
T , 0).
If we use the value of asset A as the numeraire then, from Eq. (4.2.1), the
value of the exchange option at time t0 is:
V (t0) = SA
t0 EQ
max(SB
T −SB
T , 0)
SA
T

which can be written as
V (t0) = SA
t0 EQ

max
SB
T
SA
T

−1, 0

(6.5.1)
where Q is the probability measure under which the relative price (SB
t /SA
t ) is a
martingale.
The process followed by (SB
t /SA
t ) can be found by substituting X1 = SB
t and
X2 = SA
t into Eq. (2.6.7). This yields
d
SB
t
SA
t

=
SB
t
SA
t

μB −μA + σ 2
A −σAσBρAB

dt
+
SB
t
SA
t

σB dW P
B −σA dW P
A

Let 
X = σB dW P
B −σA dW P
A , so E[
X] = σBE[dW P
B ] −σAE[dW P
A ] = 0, and
Var[
X] = σ 2
B dt + σ 2
A dt −2σBσAρAB dt where we have used (see Appendix C.3):
Var[a dW1 + b dW2] = a2 Var[dW1] + b2 Var[dW2] + 2ab Cov[dW1, dW2]
Var

dW P
B

= Var

dW P
A

= dt
and
Cov

dW P
B , dW P
A

= σBσAρAB dt

Multiasset options
191
which means that 
X ∼N(0, σ 2
B dt + σ 2
A dt −2σBσAρAB dt) and the variate (σ 2
B +
σ 2
A −2σBσAρAB) dW P is from the same distribution as 
X.
Therefore we can write:
d
SB
t
SA
t

=
SB
t
SA
t

¯μ dt +
SB
t
SA
t

¯σ dW P
(6.5.2)
where
¯σ =

σ 2
B + σ 2
A −2σBσA
and
¯μ = μB −μA + σ 2
A −σBσAρAB
Following Section 4.4.3 we choose the probability measure Q so that the drift
term in Eq. (6.5.2) is zero. We have
dW P = dW Q −
 ¯μ
¯σ

dt
Substituting this into Eq. (6.5.2) gives
d
SB
t
SA
t

=
SB
t
SA
t

¯σ dW Q
(6.5.3)
It can be seen that Eq. (6.5.3) is identical to Eq. (4.4.31) but with the mapping:
St →
SB
t
SA
t

,
σ →¯σ, r →0
(6.5.4)
Now combining Eqs. (4.4.35) and (4.4.37) we have
exp(−rτ)EQ
max(ST −E, 0)

= SN1(d1) −E exp(−rτ)N1(d2)
where d1 and d2 have been deﬁned in Section 4.4.3.
Therefore,
EQ
max(ST −1, 0)

= exp(rτ)SN1(d1) −N1(d2)
Using the mapping deﬁned in Eq. (6.5.4), and also E = 1 in the Black–Scholes
formula, we have:
EQ
SB
T
SA
T

−1, 0

=
SB
t0
SA
t0

N1(d1) −N1(d2)
and from Eq. (6.5.1):
V (t0) = SA
t0
SB
t0
SA
t0

N1(d1) −N1(d2)

This means that the value of the exchange option at time t0 is:
V (t0) = SB
t0 N1(d1) −SA
t0 N1(d2)

192
Computational Finance Using C and C#
where
d1 =
log(SA
t0 /SB
t0 ) + 1
2(T −t0)¯σ 2
¯σ√T −t0
d2 =
log(SA
t0 /SB
t0 ) −1
2(T −t0)¯σ 2
¯σ√T −t0
6.5.2
European options on the maximum or minimum
Here we present the results from Stulz (1982) and Johnson (1987) concerning
the value of European put and call options on the maximum and minimum of
two assets, see Code excerpts 6.2 and 6.3, and results in Tables 6.3 and 6.4.
void rainbow_bs_2d(double *opt_value, double S1, double S2, double X, double sigma1,
double sigma2, double rho, double opt_mat, double r, long is_max,_
long *iflag)
{
/* Input parameters:
=================
S1
- the current price of the underlying asset 1,
S2
- the current price of the underlying asset 2,
X
- the strike price,
sigma1
- the volatility of asset 1,
sigma2
- the volatility of asset 2,
rho
- the correlation coefficient between asset 1 and asset 2,
opt_mat
- the time to maturity,
r
- the interest rate,
is_max
- if is_max is 1 then the option is a call on the maximum of two assets,_
otherwise the option is a
call on the minimum of two assets.
Output parameters:
==================
opt_value
- the value of the option,
iflag
- an error indicator.
*/
double one=1.0,two=2.0,zero=0.0;
double eps,d1,d2_1,d2_2,temp,temp1,temp2,pi,np;
double rho_112, rho_212, d1_prime;
double sigma, term1, term2, term3;
long ifailx = 0;
if(X < EPS) {
/*
ERROR the strike price is too small */
*iflag = 2;
return;
}
if (sigma1 < EPS) {
/*
ERROR the volatility (sigma1) is too small */
*iflag = 3;
return;
}
if (sigma2 < EPS) {
/* ERROR the volatility (sigma2) is too small */
*flag = 3;
return;
}
if (opt_mat < EPS) {
/* ERROR the time to maturity (opt_mat) is too small */
*iflag = 3;
return;
}
sigma = sqrt((sigma1*sigma1 + sigma2*sigma2) - two*sigma1*sigma2*rho);
Code excerpt 6.2 Function to calculate the value of a European call on the maximum or
minimum of two assets using the analytic result of Johnson (1987) and Stulz (1982).

Multiasset options
193
if (is_max == 1) { /* then the maximum of two assets */
/* calculate term1 */
temp = log(S1/X);
d1 = temp+(r+(sigma1*sigma1/two))*opt_mat;
d1 = d1/(sigma1*sqrt(opt_mat));
temp = log(S1/S2);
d1_prime = temp+(sigma*sigma/two)*opt_mat;
d1_prime = d1_prime/(sigma*sqrt(opt_mat));
rho_112 = (sigma1 - rho*sigma2) / sigma;
term1 =
cum_norm2(d1,d1_prime,rho_112,&ifailx);
term1 =
term1*S1;
/* calculate term2 */
temp = log(S2/X);
d1 = temp+(r+(sigma2*sigma2/two))*opt_mat;
d1 = d1/(sigma2*sqrt(opt_mat));
temp = log(S2/S1);
d1_prime = temp+(sigma*sigma/two)*opt_mat;
d1_prime = d1_prime/(sigma*sqrt(opt_mat));
rho_212 = (sigma2 - rho*sigma1) / sigma;
term2 =
S2*cum_norm2(d1,d1_prime,rho_212,&ifailx);
/* calculate term3 */
temp = log(S1/X);
d2_1 = temp+(r-(sigma1*sigma1/two))*opt_mat;
d2_1 = d2_1/(sigma1*sqrt(opt_mat));
temp = log(S2/X);
d2_2 = temp+(r-(sigma2*sigma2/two))*opt_mat;
d2_2 = d2_2/(sigma2*sqrt(opt_mat));
term3 =
one-cum_norm2(-d2_1,-d2_2,rho,&ifailx);
*opt_value = term1+term2-X*exp(-r*opt_mat)*term3;
}
else {
/* the minimum of two assets */
/* calculate term1 */
temp = log(S1/X);
d1 = temp+(r+(sigma1*sigma1/two))*opt_mat;
d1 = d1/(sigma1*sqrt(opt_mat));
temp = log(S1/S2);
d1_prime = temp+(sigma*sigma/two)*opt_mat;
d1_prime = d1_prime/(sigma*sqrt(opt_mat));
rho_112 = (sigma1 - rho*sigma2) / sigma;
term1 =
cum_norm2(d1,-d1_prime,-rho_112,&ifailx);
term1 =
term1*S1;
/* calculate term2 */
temp = log(S2/X);
d1 = temp+(r+(sigma2*sigma2/two))*opt_mat;
d1 = d1/(sigma2*sqrt(opt_mat));
temp = log(S2/S1);
d1_prime = temp+(sigma*sigma/two)*opt_mat;
d1_prime = d1_prime/(sigma*sqrt(opt_mat));
rho_212 = (sigma2 - rho*sigma1) / sigma;
term2 =
S2*cum_norm2(d1,-d1_prime,-rho_212,&ifailx);
/* calculate term3 */
temp = log(S1/X);
d2_1 = temp+(r-(sigma1*sigma1/two))*opt_mat;
d2_1 = d2_1/(sigma1*sqrt(opt_mat));
temp = log(S2/X);
d2_2 = temp+(r-(sigma2*sigma2/two))*opt_mat;
d2_2 = d2_2/(sigma2*sqrt(opt_mat));
term3 =
cum_norm2(d2_1,d2_2,rho,&ifailx);
*opt_value = term1+term2-X*exp(-r*opt_mat)*term3;
}
return;
}
Code excerpt 6.2 (Continued).
Call options on the maximum and minimum of two assets
Let the value of a European call option on the minimum of two assets, S1 and
S2, with strike price E, maturity τ, and correlation coefﬁcient ρ, be denoted by
cmin. The value of the corresponding call option on the maximum of these assets
will be represented by cmax.

194
Computational Finance Using C and C#
void opt_rainbow_bs_2d(double *opt_value, double S1, double S2, double X, double sigma1,
double sigma2, double rho, double opt_mat, double r, long is_max, long putcall,_
long *flag)
{
/* Input parameters:
=================
S1
- the current price of the underlying asset 1,
S2
- the current price of the underlying asset 2,
X
- the strike price,
sigma1
- the volatility of asset 1,
sigma2
- the volatility of asset 2,
rho
- the correlation coefficient between asset 1 and asset 2,
opt_mat
- the time to maturity,
r
- the interest rate,
is_max
- if is_max is 1 then the option is on the maximum of two assets,_
otherwise the option is on
the minimum of two assets,
putcall
- if putcall is 0 then the option is a call, otherwise the option is a put.
Output parameters:
==================
opt_value
- the value of the option,
iflag
- an error indicator.
*/
double temp1;
double temp2;
double fac;
double a_zero = 1.0e-6; /* approximate zero number to prevent overflow in rainbow_bs_2d */
if (putcall) { /* a put option */
fac = X*exp(-r*opt_mat);
rainbow_bs_2d(&temp1, S1, S2, a_zero, sigma1, sigma2, rho, opt_mat, r, is_max, flag);
rainbow_bs_2d(&temp2, S1, S2, X, sigma1, sigma2, rho, opt_mat, r, is_max, flag);
*opt_value = fac - temp1 + temp2;
} else { /* a call option */
rainbow_bs_2d(opt_value, S1, S2, X, sigma1, sigma2, rho, opt_mat, r, is_max, flag);
}
}
Code excerpt 6.3 Function to calculate the value of a European put or call on the max-
imum or minimum of two assets using the analytic result of Johnson (1987) and Stulz
(1982).
Table 6.3 The computed values and absolute errors for European put and call options
on the maximum of two assets
Time
Call
Put
Analytic
Lattice
Error
Analytic
Lattice
Error
0.1
6.45320
6.45245
7.4972 × 10−4
0.01524
0.01451
7.3344 × 10−4
0.2
6.96192
6.95953
2.3845 × 10−3
0.08252
0.08001
2.5106 × 10−3
0.3
7.49587
7.49376
2.1084 × 10−3
0.15787
0.15580
2.0675 × 10−3
0.4
8.03710
8.04022
3.1260 × 10−3
0.22362
0.22680
3.1768 × 10−3
0.5
8.57808
8.57916
1.0757 × 10−3
0.27762
0.27683
7.8867 × 10−4
0.6
9.11529
9.10809
7.2006 × 10−3
0.32115
0.31872
2.4328 × 10−3
0.7
9.64700
9.64838
1.3826 × 10−3
0.35598
0.35714
1.1548 × 10−3
0.8
10.17238
10.17663
4.2571 ×10−3
0.38372
0.38711
3.3891 × 10−3
The results were obtained using a binomial lattice and the analytic formula (Johnson
(1987) and Stulz (1982)). The time to maturity of the option is varied from 0.1 years to
0.8 years. The parameters are: E = 44.0, S1 = 40.0, S2 = 50.0, r = 0.1, σ1 = 0.2, σ2 =
0.2, q1 = q2 = 0.0, ρ = 0.5, n_steps = 50.

Multiasset options
195
Table 6.4 The computed values and absolute errors for European put and call options
on the minimum of two assets
Time
Call
Put
Analytic
Lattice
Error
Analytic
Lattice
Error
0.1
0.10810
0.10753
5.7048 × 10−4
3.67044
3.66993
5.0955 × 10−4
0.2
0.40862
0.40781
8.1047 × 10−4
3.54551
3.54514
3.6961 × 10−4
0.3
0.74162
0.73418
7.4339 × 10−3
3.47882
3.47206
6.7642 × 10−3
0.4
1.06989
1.07299
3.1076 × 10−3
3.43283
3.43715
4.3214 × 10−3
0.5
1.38675
1.38909
2.3414 × 10−3
3.39540
3.40159
6.1826 × 10−3
0.6
1.69203
1.69025
1.7757 × 10−3
3.36145
3.35775
3.6964 × 10−3
0.7
1.98691
1.96939
1.7520 × 10−2
3.32859
3.31517
1.3417 × 10−2
0.8
2.27276
2.26274
1.0018 × 10−2
3.29566
3.29157
4.0885 × 10−3
The results were obtained using a binomial lattice and the analytic formula (Johnson
(1987) and Stulz (1982)). The time to maturity of the option is varied from 0.1 years to
0.8 years. The parameters are: E = 44.0, S1 = 40.0, S2 = 50.0, r = 0.1, σ1 = 0.2, σ2 =
0.2, q1 = q2 = 0.0, ρ = 0.5, n_steps = 50.
Then, following Stulz (1982) and Johnson (1987), we have:
cmax = S1N2

d1

S1, E, σ 2
1

, d′
1

S1, S2, σ 2
∗

, ρ1

+ S2N2

d1

S2, E, σ 2
2

, d′
1

S2, S1, σ 2
∗

, ρ2

−E exp(−rτ)

1 −N2

−d2

S1, E, σ 2
1

, −d2

S2, E, σ 2
2

, ρ

(6.5.5)
and
cmin = S1N2

d1

S1, E, σ 2
1

, −d′
1

S1, S2, σ 2
∗

, −ρ1

+ S2N2

d1

S2, E, σ 2
2

, −d′
1

S2, S1, σ 2
∗

, −ρ2

−E exp(−rτ)N2

d2

S1, E, σ 2
1

, d2

S2, E, σ 2
2

, ρ

(6.5.6)
where N2(a, b, ρ) is the bivariate cumulative normal. It gives the cumulative
probability, in a standardized bivariate normal distribution, that the variables
x1 and x2 satisfy x1 ⩽a and x2 ⩽b when the correlation coefﬁcient between
x1 and x2 is ρ—the value is computed using the routine cum_norm2. The other
symbols are deﬁned as follows:
σ 2
∗= σ 2
1 −2ρσ1σ2 + σ 2
2
d1

Si, E, σ 2
i

= log(Si/E) + (r + σ 2
i /2)τ
σi
√τ
,
i = 1, 2,
d2

Si, E, σ 2
i

= log(Si/E) + (r −σ 2
i /2)τ
σi
√τ
,
i = 1, 2,
d′
1

Si, Sj, σ 2
∗

= log(Si/Sj) + (σ 2
∗/2)τ
σ∗
√τ
for i = 1, j = 2, or i = 2, j = 1

196
Computational Finance Using C and C#
and
ρ1 = σ1 −ρσ2
σ∗
,
ρ2 = σ2 −ρσ1
σ∗
It can also be shown that:
cmax(S1, S2, E, τ) + cmin(S1, S2, E, τ) = c(S1, E, τ) + c(S2, E, τ)
(6.5.7)
where c(S, E, τ) is the value of a vanilla European call.
We will now derive an expression for the value of the corresponding European
put options.
Put options on the minimum of two assets
It will now be shown that the price of a European put option on the minimum
of two assets, pmin(S1, S2, E, τ) is:
pmin(S1, S2, E, τ) = E exp(−rτ) −cmin(S1, S2, 0, τ) + cmin(S1, S2, E, τ)
(6.5.8)
where the meaning of the symbols has been previously deﬁned.
This result can be proved by considering the following two investments:
Portfolio A: Purchase one put option on the minimum of S1 and S2 with
exercise price E.
Portfolio B: Purchase one discount bond which pays E at maturity. Write
(that is, sell) one option on the minimum of S1 and S2 with an exercise price of
zero. Purchase one option on the minimum of S1 and S2 with exercise price E.
We now consider the values of these portfolios at option maturity, time τ.
If min(S1, S2) ⩾E
Portfolio A: pays zero
Portfolio B: Pays E −min(S1, S2) + min(S1, S2) −E = 0
If min(S −1, S2) = S1 < E
Portfolio A: Pays E −S1
Portfolio B: Pays E −S1 + 0 = E −S1
If min(S1, S2) = S2 < E
Portfolio A: Pays E −S2
Portfolio B: Pays E −S2 + 0 = E −S2
We have therefore shown that, under all possible circumstances, Portfolio A
has the same value as Portfolio B. This means that Eq. (6.5.8) is true.

Multiasset options
197
Put options on the maximum of two assets
It will now be shown that the price of a European put option on the maximum
of two assets, pmax(S1, S2, E, τ) is:
pmax(S1, S2, E, τ) = E exp(−rτ) −cmax(S1, S2, 0, τ) + cmax(S1, S2, E, τ)
(6.5.9)
where, as before, the meaning of the symbols has been previously deﬁned.
This result can be proved by considering the following two investments:
Portfolio A: Purchase one put option on the maximum of S1 and S2 with
exercise price E.
Portfolio B: Purchase one discount bond which pays E at maturity. Write
(that is, sell) one option on the maximum of S1 and S2 with an exercise price
of zero. Purchase one option on the maximum of S1 and S2 with exercise
price E.
As before we now consider the values of these portfolios at option maturity,
time τ.
If max(S1, S2) ⩾E
Portfolio A: Pays zero
Portfolio B: Pays E −max(S1, S2) + max(S1, S2) −E = 0
If max(S1, S2) = S1 < E
Portfolio A: Pays E −S1
Portfolio B: Pays E −S1 + 0 = E −S1
If max(S1, S2) = S2 < E
Portfolio A: Pays E −S2
Portfolio B: Pays E −S2 + 0 = E −S2
It therefore follows that, under all possible circumstances, Portfolio A has the
same value as Portfolio B, and this means that Eq. (6.5.9) is true.
6.5.3
American options
We assume that the prices of asset 1 and asset 2 follow a lognormal process with
drift terms of μ1 = r −σ 2
1 /2 and μ2 = r −σ 2
2 /2, respectively. As before, r is the
riskless interest rate and σ1 and σ2 are the instantaneous volatilities of asset 1
and asset 2.
If we let S1,t and S2.t denote the respective prices of asset 1 and asset 2 at
time t, then we can write:
log(S1,t+t) = log(S1,t) + ε1,t
(6.5.10)

198
Computational Finance Using C and C#
and
log(S2,t+t) = log(S2,t) + ε2,t
(6.5.11)
where ε1,t is a random normal variable with mean μ1t and variance σ 2
1 t, and
ε2,t is a random normal variable with mean μ2t and variance σ 2
2 t.
In the binomial lattice model, over the time interval t, the variate log(S1,t)
is only allowed to jump up or down by an amount ν1 = σ1
√
t, and simi-
larly the variate log(S2,t) is only permitted to jump up and down by the amount
ν2 = σ2
√
t. We will denote the probability of both log(S1,t) and log(S2,t) hav-
ing an up jump over t by puu, and the probability of log(S1,t) having an up
jump and log(S2,t) having a down jump by pud, etc.
The mean values in Eqs. (5.15) and (5.16) then give
E[ε1,t] = ν1(puu + pud −pdd −pdu) = μ1t
(6.5.12)
E[ε2,t] = ν2(puu + pud −pdd −pdu) = μ2t
(6.5.13)
and the variance/covariance terms yields
Var[ε1,t] = ν2
1(puu + pud + pdd + pdu) = σ 2
1 t
(6.5.14)
Var[ε2,t] = ν2
2(puu + pud + pdd + pdu) = σ 2
2 t
(6.5.15)
E[ε1,tε2,t] = ν1ν2(puu −pud + pdd −pdu) = ρσ1σ2t
(6.5.16)
where ρ is the correlation coefﬁcient between ε1,t and ε2,t.
We therefore obtain:
puu + pud −pdd + pdu = μ1
√
t
σ1
puu −pud −pdd + pdu = μ2
√
t
σ2
puu + pud + pdd + pdu = 1
puu −pud + pdd −pdu = ρ
These lead to the following jump probabilities:
puu = 1
4

1 +
√
t
μ1
σ1
+ μ2
σ2

+ ρ

pud = 1
4

1 +
√
t
μ1
σ1
−μ2
σ2

−ρ

pdd = 1
4

1 +
√
t

−μ1
σ1
−μ2
σ2

+ ρ

pdu = 1
4

1 +
√
t

−μ1
σ1
+ μ2
σ2

−ρ

In Code excerpt 6.4, we provide the computer code for a standard binomial
lattice which prices options on the maximum and minimum of two assets.

Multiasset options
199
The parameter M is the number of time steps used, and the lattice is con-
structed under the assumption that M is even.
void standard_2D_binomial(double *value, double S1, double S2, double X,
double sigma1, double sigma2, double rho, double T,
double r, double q1, double q2, long put,
long M, long opt_type, long is_american, long *iflag)
{
/* Input parameters:
=================
S1
- the current price of the underlying asset 1
S2
- the current price of the underlying asset 2
X
- the strike price
sigma1
- the volatility of asset 1
sigma2
- the volatility of asset 2
rho
- the correlation coefficient between asset 1 and asset 2
T
- the time to maturity
r
- the interest rate
q1
- the continuous dividend yield for asset 1
q2
- the continuous dividend yield for asset 2
put
- if put is 0 then a call option, otherwise a put option
M
- the number of time steps, the zeroth time step is the root node_
of the lattice
opt_type
- if opt_type is 0 then an option on the maximum of two asset
otherwise an option on the minimum of two assets
is_american
- if is_american is 0 then a European option, otherwise_
an American option
Output parameters:
==================
value
- the value of the option,
iflag
- an error indicator.
*/
double discount,t1,dt,d1,d2,u1,u2;
long i,j,m1,n,iflagx,jj,ind;
double zero=0.0,hold;
double temp,ds1,ds2,dv1,dv2,h,tmp;
double *s1, *s2, *v;
double p[4];
long P1,P2,tdv;
double sqrt_dt, t, mu1, mu2, jp1, jp2;
double one = 1.0, half = 0.5, quarter = 0.25;
long v1;
if (!((M+1)/2) == (M/2)) printf ("ERROR THE NUMBER OF TIME STEPS IS NOT EVEN \n");
tdv = M + 1;
#define V(I,J) v[(I) * tdv + (J)]
#define UU
0
#define UD
1
#define DD
2
#define DU
3
dt = T/(double)M;
sqrt_dt = sqrt(dt);
jp1 = sigma1*sqrt_dt;
jp2 = sigma2*sqrt_dt;
mu1 = r - q1 - sigma1*sigma1*half;
mu2 = r - q2 - sigma2*sigma2*half;
u1 = exp(jp1); /* assign the jump sizes */
u2 = exp(jp2);
d1 = exp(-jp1);
d2 = exp(-jp2);
p[UU] = quarter*(one + sqrt_dt * ((mu1/sigma1) + (mu2/sigma2)) +
rho); /* set up the jump_
probabilities */
p[UD] = quarter*(one + sqrt_dt * ((mu1/sigma1) - (mu2/sigma2)) - rho);
p[DD] = quarter*(one + sqrt_dt * (-(mu1/sigma1) - (mu2/sigma2)) + rho);
p[DU] = quarter*(one + sqrt_dt * (-(mu1/sigma1) + (mu2/sigma2)) - rho);
for (i = 0; i < 4; ++i) {
if ((p[i] < zero) || (p[i] > 1.0)) printf ("ERROR p out of range\n");
}
discount = exp(-r*dt);
Code excerpt 6.4 Function to calculate the value of a European put or call on the maxi-
mum or minimum of two assets using a standard binomial lattice.

200
Computational Finance Using C and C#
for (i = 0; i < 4; ++i) {
p[i] = p[i]*discount;
}
/* Allocate the arrays v[(M+1)*(M+1)], s1[2*M+1] and s2[2*M+1] */
.
.
.
s1[M] = S1; /* assign the 2*M+1 asset values for s1 */
for (i = 1; i <= M; ++i) {
s1[M+i] = u1*s1[M+i-1];
s1[M-i] = d1*s1[M-i+1];
}
s2[M] = S2; /* assign the 2*M+1 asset values for s2 */
for (i = 1; i <= M; ++i) {
s2[M+i] = u2*s2[M+i-1];
s2[M-i] = d2*s2[M-i+1];
}
P1 = 0;
for (i = 0; i <= M; ++i) { /* Calculate the option values at maturity
*/
P2 = 0;
for (j = 0; j <= M; ++j) {
if (opt_type == 0) { /* Maximum of two assets */
if (put) {
V(i,j)
= MAX(X - MAX(s1[P1],s2[P2]),zero);
}
else {
V(i,j)
= MAX(MAX(s1[P1],s2[P2])-X,zero);
}
}
else {
if (put) { /* Minimum of two assets */
V(i,j)
= MAX(X - MIN(s1[P1],s2[P2]),zero);
}
else {
V(i,j)
= MAX(MIN(s1[P1],s2[P2])-X,zero);
}
}
P2 = P2 + 2;
}
P1 = P1 + 2;
}
for (m1 = M-1; m1 >= 0; --m1) { /* work backwards through the lattice_
to calculate option value */
P1 = M-m1;
for (i = 0; i <= m1; ++i) {
P2 = M-m1;
for (j = 0; j <= m1; ++j) {
hold = p[UD]*V(i+1,j) + p[UU]*V(i+1,j+1) + p[DU]*V(i,j+1) + p[DD]*V(i,j);
if (is_american) {
/* An American option */
if (opt_type == 0) {
/* Maximum of two assets */
if (put)
V(i,j) = MAX(hold,X-MAX(s1[P1],s2[P2]));
else
V(i,j) = MAX(hold,MAX(s1[P1],s2[P2])-X);
}
else {
/* Minimum of two assets */
if (put)
V(i,j) = MAX(hold,X-MIN(s1[P1],s2[P2]));
else
V(i,j) = MAX(hold,MIN(s1[P1],s2[P2])-X);
}
}
else {
V(i,j) = hold;
}
P2 = P2 + 2;
}
P1 = P1 + 2;
}
}
*value = V(0,0);
}
Code excerpt 6.4 (Continued).

Multiasset options
201
6.6
Three asset options
For three asset options (see Code excerpt 6.5 and results in Tables 6.5–6.8), we
have the following jump probabilities:
puuu = 1
8

1 +
√
t
μ1
σ1
+ μ2
σ2
+ μ3
σ3

+ ρ12 + ρ13 + ρ23

puud = 1
8

1 +
√
t
μ1
σ1
+ μ2
σ2
−μ3
σ3

+ ρ12 −ρ13 −ρ23

pudu = 1
8

1 +
√
t
μ1
σ1
−μ2
σ2
+ μ3
σ3

−ρ12 + ρ13 −ρ23

pudd = 1
8

1 +
√
t
μ1
σ1
−μ2
σ2
−μ3
σ3

−ρ12 −ρ13 + ρ23

pduu = 1
8

1 +
√
t

−μ1
σ1
+ μ2
σ2
+ μ3
σ3

−ρ12 −ρ13 + ρ23

pdud = 1
8

1 +
√
t

−μ1
σ1
+ μ2
σ2
+ μ3
σ3

−ρ12 + ρ13 −ρ23

pddu = 1
8

1 +
√
t

−μ1
σ1
−μ2
σ2
+ μ3
σ3

+ ρ12 −ρ13 −ρ23

pddd = 1
8

1 +
√
t

−μ1
σ1
−μ2
σ2
−μ3
σ3

+ ρ12 + ρ13 + ρ23

void standard_3D_binomial(double *value, double S1, double S2, double S3, double X,
double sigma1, double sigma2, double sigma3, double rho_12, double rho_13, double rho_23,
double T, double r, long put, long M, long opt_type, long is_american, long *iflag)
{
/* Input parameters:
=================
S1
- the current price of the underlying asset 1
S2
- the current price of the underlying asset 2
S3
- the current price of the underlying asset 3
X
- the strike price
sigma1
- the volatility of asset 1
sigma2
- the volatility of asset 2
sigma3
- the volatility of asset 3
rho_12
- the correlation coefficient between asset 1 and asset 2
rho_13
- the correlation coefficient between asset 1 and asset 3
rho_23
- the correlation coefficient between asset 2 and asset 3
T
- the time to maturity
r
- the interest rate
put
- if put is 0 then a call option, otherwise a put option
M
- the number of time steps, the zeroth time step is the root node_
of the lattice
opt_type
- if opt_type is 0 then an option on the maximum of two asset
otherwise an option on the minimum of two assets
is_american
- if is_american is 0 then a European option, otherwise an American option.
Output parameters:
==================
value
- the value of the option,
iflag
- an error indicator.
Code excerpt 6.5 Standard 3-dimensional binomial lattice.

202
Computational Finance Using C and C#
*/
double discount,t1,dt,d1,d2,d3,u1,u2,u3;
long i,j,k,m1,n,iflagx,jj,ind;
double zero=0.0,hold;
double temp,ds1,ds2,dv1,dv2,h,tmp,tmp1,tmp2;
double *s1, *s2, *s3, *v;
double p[9];
long P1,P2,P3,tdv, tdv2;
double sqrt_dt, t, mu1, mu2, mu3, jp1, jp2, jp3;
double one = 1.0, half = 0.5, eighth = 0.125;
long v1;
if (!((M+1)/2) == (M/2)) printf ("ERROR THE NUMBER OF TIME STEPS IS NOT EVEN \n");
tdv = M + 1;
tdv2 = tdv*tdv;
#define V(I,J, K) v[(I) * tdv2 + (J)*tdv + (K)]
#define UUU
0
#define UUD
1
#define UDU
2
#define UDD
3
#define DUU
4
#define DUD
5
#define DDU
6
#define DDD
7
dt = T/(double)M;
sqrt_dt = sqrt(dt);
jp1 = sigma1*sqrt_dt;
jp2 = sigma2*sqrt_dt;
jp3 = sigma3*sqrt_dt;
mu1 = r - sigma1*sigma1*half;
mu2 = r - sigma2*sigma2*half;
mu3 = r - sigma3*sigma3*half;
u1 = exp(jp1); /* assign the jump sizes */
u2 = exp(jp2);
u3 = exp(jp3);
d1 = exp(-jp1);
d2 = exp(-jp2);
d3 = exp(-jp3);
/* set up the jump probabilities
*/
p[UUU] = eighth*(one + sqrt_dt * ((mu1/sigma1) + (mu2/sigma2)_
+ (mu3/sigma3)) + rho_12 + rho_13 + rho_23);
p[UUD] = eighth*(one + sqrt_dt * ((mu1/sigma1) + (mu2/sigma2)_
- (mu3/sigma3)) + rho_12 - rho_13 - rho_23);
p[UDU] = eighth*(one + sqrt_dt * ((mu1/sigma1) - (mu2/sigma2)_
+ (mu3/sigma3)) - rho_12 + rho_13 - rho_23);
p[UDD] = eighth*(one + sqrt_dt * ((mu1/sigma1) - (mu2/sigma2)_
- (mu3/sigma3)) - rho_12 - rho_13 + rho_23);
p[DUU] = eighth*(one + sqrt_dt * (-(mu1/sigma1) + (mu2/sigma2)_
+ (mu3/sigma3)) - rho_12 - rho_13 + rho_23);
p[DUD] = eighth*(one + sqrt_dt * (-(mu1/sigma1) + (mu2/sigma2)_
- (mu3/sigma3)) - rho_12 + rho_13 - rho_23);
p[DDU] = eighth*(one + sqrt_dt * (-(mu1/sigma1) - (mu2/sigma2)_
+ (mu3/sigma3)) + rho_12 - rho_13 - rho_23);
p[DDD] = eighth*(one + sqrt_dt * (-(mu1/sigma1) - (mu2/sigma2)_
- (mu3/sigma3)) + rho_12 + rho_13 + rho_23);
for (i = 0; i < 8; ++i) {
if ((p[i] < zero) || (p[i] > 1.0)) printf ("ERROR p[%ld] = %12.4f out_
of range\n",i, p[i]);
}
discount = exp(-r*dt);
for (i = 0; i < 8; ++i) {
p[i] = p[i]*discount;
}
/* Allocate the arrays v[(M+1)*(M+1)*(M+1)], s1[2*M+1], s2[2*M+1], and s3[2*M+1] */
.
.
.
s1[M] = S1;
for (i = 1; i <= M; ++i) { /* assign the 2*M+1 asset values for s1 */
s1[M+i] = u1*s1[M+i-1];
s1[M-i] = d1*s1[M-i+1];
}
s2[M] = S2;
Code excerpt 6.5 (Continued).

Multiasset options
203
for (i = 1; i <= M; ++i) { /* assign the 2*M+1 asset values for s2 */
s2[M+i] = u2*s2[M+i-1];
s2[M-i] = d2*s2[M-i+1];
}
s3[M] = S3;
for (i = 1; i <= M; ++i) { /* assign the 2*M+1 asset values for s2 */
s3[M+i] = u3*s3[M+i-1];
s3[M-i] = d3*s3[M-i+1];
}
/* Calculate the option values at maturity
*/
P1 = 0;
for (i = 0; i <= M; ++i) {
P2 = 0;
for (j = 0; j <= M; ++j) {
P3 = 0;
for (k = 0; k <= M; ++k) {
if (put) { /* put */
if (opt_type == 0) { /* Maximum of 3 assets */
tmp = MAX(s1[P1],s2[P2]);
V(i,j,k)
= MAX(X - MAX(tmp,s3[P3]),zero);
}
else if (opt_type == 1) { /* Minimum of 3 assets */
tmp = MIN(s1[P1],s2[P2]);
V(i,j,k)
= MAX(X - MIN(tmp,s3[P3]),zero);
}
}
else { /* call */
** Insert call option code using the supplied put option code as a template **
}
P3 = P3 + 2;
}
P2 = P2 + 2;
}
P1 = P1 + 2;
}
for (m1 = M-1; m1 >= 0; --m1) {
/* work backwards through the lattice to calculate_
the option value */
P1 = M-m1;
for (i = 0; i <= m1; ++i) {
P2 = M-m1;
for (j = 0; j <= m1; ++j) {
P3 = M-m1;
for (k = 0; k <= m1; ++k) {
hold = p[UUU]*V(i+1,j+1,k+1) + p[UUD]*V(i+1,j+1,k) + p[UDU]*V(i+1,j,k+1)_
+ p[UDD]*V(i+1,j,k) + p[DUU]*V(i,j+1,k+1) + p[DUD]*V(i,j+1,k)_
+ p[DDU]*V(i,j,k+1) + p[DDD]*V(i,j,k);
if (is_american) {
if (put) {
if (opt_type == 0) { /* Maximum of 3 assets */
tmp = MAX(s1[P1],s2[P2]);
if (opt_type == 0) { /* Maximum of 3 assets */
tmp = MAX(s1[P1],s2[P2]);
tmp1
= MAX(tmp,s3[P3]);
tmp2 = MAX(X-tmp1,hold);
V(i,j,k) = MAX(tmp2,zero);
}
else if (opt_type == 1) { /* Minimum of 3 assets */
tmp = MIN(s1[P1],s2[P2]);
tmp1 = MIN(tmp,s3[P3]);
tmp2 = MAX(X-tmp1,hold);
V(i,j,k)
= MAX(tmp2,zero);
}
}
else { /* call option */
** Insert call option code using the supplied put option_
code as a template **
}
}
Code excerpt 6.5 (Continued).

204
Computational Finance Using C and C#
else { /* European option */
V(i,j,k) = hold;
}
P3 = P3 + 2;
}
P2 = P2 + 2;
}
P1 = P1 + 2;
}
}
*value = V(0,0,0);
}
Code excerpt 6.5 (Continued).
Table 6.5 The computed values and absolute errors for European options on the
maximum of three assets
N steps
Put
Call
Computed value
Error
Computed value
Error
10
0.9112
2.485 ×10−2
21.8601
8.119 ×10−1
20
0.9192
1.678 ×10−2
22.2807
3.913 ×10−1
30
0.9232
1.276 ×10−2
22.4137
2.583 ×10−1
40
0.9254
1.056 ×10−2
22.4792
1.928 ×10−1
50
0.9268
9.180 ×10−3
22.5182
1.538 ×10−1
60
0.9278
8.236 ×10−3
22.5441
1.279 ×10−1
A binomial lattice was used and we show how the accuracy of the results depends on
the number of time steps. The parameters are: E = 100.0, S1 = S2 = S3 = 100.0, r =
0.1, τ = 1.0, σ1 = σ2 = σ3 = 0.2, ρ12 = ρ13 = ρ23 = 0.5, q1 = q2 = q3 = 0.0. The
accurate values are 0.936 for a put and 22.672 for a call; see Table 2, Boyle, Evnine, and
Gibbs (1989).
Table 6.6 The computed values and absolute errors for European options on the
minimum of three assets
N steps
Put
Call
Computed value
Error
Computed value
Error
10
7.0759
3.271 ×10−1
5.2072
4.176 ×10−2
20
7.2402
1.628 ×10−1
5.2263
2.269 ×10−2
30
7.2953
1.077 ×10−1
5.2334
1.560 ×10−2
40
7.3229
8.015 ×10−2
5.2371
1.192 ×10−2
50
7.3394
6.357 ×10−2
5.2393
9.665 ×10−2
60
7.3505
5.251 ×10−2
5.2409
8.143 ×10−3
A binomial lattice was used and we show how the accuracy of the results depends on
the number of time steps. The parameters are: E = 100.0, S1 = S2 = S3 = 100.0, r =
0.1, τ = 1.0, σ1 = σ2 = σ3 = 0.2, ρ12 = ρ13 = ρ23 = 0.5, q1 = q2 = q3 = 0.0. The
accurate values are 7.403 for a put and 5.249 for a call; see Table 2, Boyle, Evnine, and
Gibbs (1989).

Multiasset options
205
Table 6.7 The computed values and absolute errors for European options on the
maximum of three assets
N steps
Put
Call
Computed value
Error
Computed value
Error
10
0.0122
4.041 ×10−2
27.3180
5.091 ×10−1
20
0.0295
2.314 ×10−2
27.5743
2.528 ×10−1
30
0.0366
1.600 ×10−2
27.6589
1.682 ×10−1
40
0.0404
1.221 ×10−2
27.7010
1.261 ×10−1
50
0.0427
9.868 ×10−3
27.7263
1.008 ×10−1
60
0.0443
8.280 ×10−3
27.7431
8.396 ×10−2
A binomial lattice was used and we show how the accuracy depends on the number of
time steps. The parameters are: E = 100.0, S1 = S2 = S3 = 100.0, r = 0.1, τ = 1.0, σ1 =
σ2 = σ3 = 0.2, ρ12 = −0.5, ρ13 = −0.5, ρ23 = 0.5, q1 = q2 = q3 = 0.0. The accurate
values are 0.0526 for a put and 27.8271 for a call, and were computed using Monte Carlo
simulation with 107 paths.
Table 6.8 The computed values and absolute errors for European options on the
minimum of three assets
N steps
Put
Call
Computed value
Error
Computed value
Error
10
8.9646
3.130 ×10−1
1.4047
1.800 ×10−1
20
9.1231
1.545 ×10−1
1.4963
8.836 ×10−2
30
9.1749
1.027 ×10−1
1.5261
5.857 ×10−2
40
9.2007
7.694 ×10−2
1.5409
4.381 ×10−2
50
9.2161
6.151 ×10−2
1.5497
3.499 ×10−2
60
9.2264
5.123 ×10−2
1.5556
2.913 ×10−2
A binomial lattice was used and we show how the accuracy depends on the number of
time steps. The parameters are: E = 100.0, S1 = S2 = S3 = 100.0, r = 0.1, τ = 1.0, σ1 =
σ2 = σ3 = 0.2, ρ12 = −0.5, ρ13 = −0.5, ρ23 = 0.5, q1 = q2 = q3 = 0.0. The accurate
values are 9.2776 for a put and 1.5847 for a call, and were computed using Monte Carlo
simulation with 107 paths.
6.7
Four asset options
The results for four assets are presented in Tables 6.9 and 6.10. We have the
following jump probabilities:
puuuu = 1
16

1 +
√
t
μ1
σ1
+ μ2
σ2
+ μ3
σ3
+ μ4
σ4

+ ρ12 + ρ13 + ρ14 + ρ23 + ρ24 + ρ34


206
Computational Finance Using C and C#
puuud = 1
16

1 +
√
t
μ1
σ1
+ μ2
σ2
+ μ3
σ3
−μ4
σ4

+ ρ12 + ρ13 −ρ14 + ρ23 −ρ24 + ρ34

puudu = 1
16

1 +
√
t
μ1
σ1
+ μ2
σ2
−μ3
σ3
+ μ4
σ4

+ ρ12 −ρ13 + ρ14 −ρ23 + ρ24 −ρ34

puudd = 1
16

1 +
√
t
μ1
σ1
+ μ2
σ2
−μ3
σ3
−μ4
σ4

+ ρ12 −ρ13 −ρ14 −ρ23 −ρ24 + ρ34

puduu = 1
16

1 +
√
t
μ1
σ1
−μ2
σ2
+ μ3
σ3
+ μ4
σ4

−ρ12 + ρ13 + ρ14 −ρ23 −ρ24 + ρ34

pudud = 1
16

1 +
√
t
μ1
σ1
−μ2
σ2
+ μ3
σ3
−μ4
σ4

−ρ12 + ρ13 −ρ14 −ρ23 + ρ24 −ρ34

puddu = 1
16

1 +
√
t
μ1
σ1
−μ2
σ2
−μ3
σ3
+ μ4
σ4

−ρ12 −ρ13 + ρ14 + ρ23 −ρ24 −ρ34

puddd = 1
16

1 +
√
t
μ1
σ1
−μ2
σ2
−μ3
σ3
−μ4
σ4

−ρ12 −ρ13 −ρ14 + ρ23 + ρ24 + ρ34

pduuu = 1
16

1 +
√
t

−μ1
σ1
+ μ2
σ2
+ μ3
σ3
+ μ4
σ4

−ρ12 −ρ13 −ρ14 + ρ23 + ρ24 + ρ34

pduud = 1
16

1 +
√
t

−μ1
σ1
+ μ2
σ2
+ μ3
σ3
−μ4
σ4

−ρ12 −ρ13 + ρ14 + ρ23 −ρ24 −ρ34

pdudu = 1
16

1 +
√
t

−μ1
σ1
+ μ2
σ2
−μ3
σ3
+ μ4
σ4

−ρ12 + ρ13 −ρ14 −ρ23 + ρ24 −ρ34


Multiasset options
207
pdudd = 1
16

1 +
√
t

−μ1
σ1
+ μ2
σ2
−μ3
σ3
−μ4
σ4

−ρ12 + ρ13 + ρ14 −ρ23 −ρ24 + ρ34

pdduu = 1
16

1 +
√
t

−μ1
σ1
−μ2
σ2
+ μ3
σ3
+ μ4
σ4

+ ρ12 −ρ13 −ρ14 −ρ23 −ρ24 + ρ34

pddud = 1
16

1 +
√
t

−μ1
σ1
−μ2
σ2
+ μ3
σ3
−μ4
σ4

+ ρ12 −ρ13 + ρ14 −ρ23 + ρ24 −ρ34

pdddu = 1
16

1 +
√
t

−μ1
σ1
−μ2
σ2
−μ3
σ3
+ μ4
σ4

+ ρ12 + ρ13 −ρ14 + ρ23 −ρ24 −ρ34

pdddd = 1
16

1 +
√
t

−μ1
σ1
−μ2
σ2
−μ3
σ3
−μ4
σ4

+ ρ12 + ρ13 −ρ14 + ρ23 + ρ24 + ρ34

Table 6.9 The computed values and absolute errors for European options on the
maximum of four assets
N steps
Put
Call
Computed value
Error
Computed value
Error
4
0.6548
2.386 ×10−2
22.1403
3.096
8
0.6268
4.129 ×10−3
23.8640
1.372
12
0.6246
6.275 ×10−3
24.3630
8.733 ×10−1
16
0.6251
5.836 ×10−3
24.5934
6.429 ×10−1
20
0.6257
5.167 ×10−3
24.7270
5.093 ×10−1
24
0.6263
4.570 ×10−3
24.8144
4.219 ×10−1
28
0.6268
4.074 ×10−3
24.8762
3.601 ×10−1
32
0.6272
3.665 ×10−3
24.9222
3.141 ×10−1
A binomial lattice was used and we show how the accuracy depends on the number of
time steps. The parameters are: E = 100.0, S1 = S2 = S3 = S4 = 100.0, r = 0.1, τ =
1.0, σ1 = σ2 = σ3 = σ4 = 0.2, ρ12 = 0.5, ρ13 = 0.5, ρ23 = 0.5, q1 = q2 = q3 = q4 = 0.0.
The accurate values are 0.6309 for a put and 25.2363 for a call, and were computed using
Monte Carlo simulation with 107 paths.

208
Computational Finance Using C and C#
Table 6.10 The computed values and absolute errors for European options on the
minimum of four assets
N steps
Put
Call
Computed value
Error
Computed value
Error
4
7.8274
7.120 ×10−1
3.5676
4.986 ×10−1
8
8.1571
3.823 ×10−1
3.8528
2.134 ×10−1
12
8.2794
2.600 ×10−1
3.9300
1.362 ×10−1
16
8.3429
1.965 ×10−1
3.9659
1.003 ×10−1
20
8.3815
1.579 ×10−1
3.9868
7.944 ×10−2
24
8.4075
1.319 ×10−1
4.0004
6.577 ×10−2
28
8.4262
1.132 ×10−1
4.0101
5.612 ×10−2
32
8.4402
9.920 ×10−2
4.0173
4.894 ×10−2
A binomial lattice was used and we show how the accuracy depends on the number of
time steps. The parameters are: E = 100.0, S1 = S2 = S3 = S4 = 100.0, r = 0.1, τ =
1.0, σ1 = σ2σ3 = σ4 = 0.2, ρ12 = 0.5, ρ13 = 0.5, ρ23 = 0.5, q1 = q2 = q3 = q4 = 0.0.
The accurate values are 8.5394 for a put and 4.0662 for a call, and were computed using
Monte Carlo simulation with 107 paths.

7 Other ﬁnancial derivatives
7.1
Introduction
In the preceding sections of the book we have only dealt with the valuation of
equity derivatives. We are now going to consider some of the other types of
trades such as
• Interest rate derivatives
• Foreign exchange derivatives
• Credit derivatives
A selection of these trades will be used by the C# portfolio pricing example in
Chapter 8.
7.2
Interest rate derivatives
It is not possible to make real proﬁt without risk. For example, if we (without
risk) invest £1 in a bank account, then allowing for interest, the total number
of pounds at future time T will be 1 + I(t, T ), where I(t, T ) is the amount
of interest accrued from t to time T . Since our investment grew by the riskless
interest rate, the real value which allows for inﬂation must still be £1, so:
DF(t, T )

1 + I(t, T )

= 1
where DF(t, T ) is the discount factor from t to T .
Continuously compounded spot rate
When continuous compounding is used 1 + I(t, T ) = exp{R(t, T )(T −t)},
where R(t, T ) is the annual continuously compounded spot rate between times
t years and T years. We thus have:
DF(t, T ) exp

R(t, T )(T −t)

= 1
(7.2.1)
so the discount factor is given by
DF(t, T ) = exp

−R(t, T )(T −t)

(7.2.2)
and the continuously compounded rate is
R(t, T ) = −log(DF(t, T ))
T −t
(7.2.3)

210
Computational Finance Using C and C#
Simply compounded spot rate
When simple compounding is used I(t, T ) = L(t, T )(T −t), where L(t, T ) is
the simply compounded spot rate between time t and T . Thus,
DF(t, T )

1 + L(t, T )(T −t)

= 1
and so the simply compounded rate is:
L(t, T ) =
1
T −t

1
DF(t, T ) −1

(7.2.4)
7.2.1
Forward rate agreement
A Forward Rate Agreement (FRA) is a contract between two counterparties
(referred to here as A and B), in which one counterparty (say A) agrees to pay
interest at the (variable) spot rate, while the other agrees to pay at a ﬁxed interest
rate. Let the agreement start at time Ts and end at the maturity Tm, at which time
the counterparties settle the amount that is owed. If P is the principal then, at
time Tm, the contract has the following value to A:
V (Tm) = P

(Tm −Ts)K −L(Ts, Tm)(Tm −Ts)

(7.2.5)
where K is the agreed ﬁxed rate, and L(Ts, Tm) is the simply compounded rate
between times Ts and Tm. From Eq. (7.2.4) we have:
L(Ts, Tm) =
1
Tm −Ts

1
DF(Ts, Tm) −1

so
V (Tm) = P

(Tm −Ts)K −

1
DF(Ts, Tm) −1

(7.2.6)
The value of the FRA to A at time t ⩽Tm is therefore FRA(t) = DF(t, Tm)V (Tm)
which means that
FRA(t) = DF(t, Tm)P

(Tm −Ts)K −

1
DF(Ts, Tm) −1

(7.2.7)
Using DF(t, Tm) = DF(t, Ts)DF(Ts, Tm) we can rewrite Eq. (7.2.7) as
FRA(t) = DF(t, Tm)P

(Tm −Ts)K −
 DF(t, Ts)
DF(t, Tm) −1

(7.2.8)
The value of K that sets FRA(t) to zero is termed the time t forward rate be-
tween times Ts and Tm, and is here denoted by F(t, Ts, Tm). From Eq. (7.2.8),
F(t, Ts, Tm) =
1
Tm −Ts
 DF(t, Ts)
DF(t, Tm) −1

(7.2.9)
Combining Eqs. (7.2.8) and (7.2.10) we can express the value of the FRA as:
FRA(t) = DF(t, Tm)Pτ

K −F(t, Ts, Ts + τ)

(7.2.10)
where τ = Tm −Ts is known as the tenor of the FRA, and Ts is the reset time
for forward rate F(t, Ts, Ts + τ).

Other ﬁnancial derivatives
211
7.2.2
Interest rate swap
Interest Rate Swaps (IRS) are very common ﬁnancial instruments—it is not un-
usual for 80 percent of the trades in a portfolio to be IRS deals. Here we will
provide a description of some of the characteristics of interest rate swaps; more
detail can be found in Hull (2003).
A vanilla IRS consists of a strip of FRA trades, each FRA starting when the
previous FRA ﬁnishes. The maturity date of the IRS thus corresponds to the
maturity date of the last FRA.
Let the start times of the FRAs be ti, i = 0, . . . , n −1, and the maturity times
of the FRAs be ti, i = 1, . . . , n; note that the FRA start times correspond to
the forward rate reset times, and the maturity times correspond to the FRA
payment times. We will now adopt the (common) convention of calling the
trades swaplets, so an IRS is made up of a number of swaplets.
When the counterparty A pays the ﬁxed rate and receives the ﬂoating rate the
trade (from A perspective) is termed a payer IRS. Alternatively, if A receives the
ﬁxed rate and pays the ﬂoating rate, then the trade is termed a receiver IRS.
The value of an IRS at time t, where tk−1 < t < tk, will now be considered.
We will assume that discount factors used to compute the forward rates and
those used to discount the coupon payments are associated with the same yield
curve. Using Eq. (7.2.10) we have:
IRS(t) = CDF(t, tk) +
n

i=k+1
DF(t, ti)Pτi

K −F(t, ti−1, ti−1 + τi)

(7.2.11)
where C is the next coupon payment after current time t (this occurs at time tk),
and τi is the tenor of the ith swaplet which starts at time ti−1 and ends at time
ti.
Note that the next coupon payment C for the swaplet starting at time tk−1
and maturing at time tj is already known with certainty at time t because the
forward rate F(t, tk−1, tk) was reset in the past; tk−1 < t.
We will now rewrite Eq. (7.2.11) as:
IRS(t) = CDF(t, tk) + FXD(t) −FLT(t)
(7.2.12)
where FXD(t), the time t value of the ﬁxed leg, is:
FXD(t) = PK
n

i=k+1
DF(t, ti)τi
(7.2.13)
and FLT(t), the time t value of the ﬂoating leg, is:
FLT(t) = P
n

i=k+1
DF(t, ti)τiF(t, ti−1, ti−1 + τi)
(7.2.14)

212
Computational Finance Using C and C#
The ﬂoating leg
We will now evaluate Eq. (7.2.14). The ﬂoating leg coupon payment at time ti
will be denoted by Ci and has value:
Ci = PF(t, ti−1, ti−1 + τi)τi
where
F(t, ti−1, ti−1 + τi) =

DF(t, ti−1)
DF(t, ti−1 + τi) −1
 1
τi
From Eq. (7.2.14) we thus have:
FLT(t) =
n

i=k+1
CiDF(t, ti)
= P
n

i=k+1
DF(t, ti)τi
DF(t, ti−1)
DF(t, ti)
−1
 1
τi
= P
n

i=k+1

DF(t, ti−1) −DF(t, ti)

= P

DF(t, tk) −DF(t, tk+1) + DF(t, tk+1) −· · ·
−DF(t, ti) + DF(t, ti) −· · · −DF(t, tn)

= P

DF(t, tk) −DF(t, tn)

and so the value of the ﬂoating leg is
FLT(t) = P

DF(t, tk) −DF(t, tn)

(7.2.15)
The swap rate
The time t swap rate SRt is the value of the ﬁxed rate K that makes the IRS(t)
zero. Thus, from Eqs. (7.2.12)–(7.2.14):
P

DF(t, tk) −DF(t, tn)

−CDF(t, tk) = PSRt
n

i=k+1
DF(t, ti)τi
(7.2.16)
so
SRt = {DF(t, tk) −DF(t, tn)} −C
P DF(t, tk)

n
i=k+1 DF(t, ti)τi
(7.2.17)
Amortization
So far we have assumed that the principal is ﬁxed and set to the value P. We
will now deal with the situation where the principal varies with time according
to the following amortization schedule:
AMi = Pi−1 −Pi,
i = 0, . . . , n −1,
(7.2.18)

Other ﬁnancial derivatives
213
where Pi is the value of the principal at time ti and P0 = P.
The value of the ﬂoating leg is now computed as:
FLT(t) =
n

i=k+1
Pi−1DF(t, ti)τi
DF(t, ti−1)
DF(t, ti)
−1
 1
τi
=
n

i=k+1
Pi−1

DF(t, ti−1) −DF(t, ti)

= PkDF(t, tk) −PkDF(t, tk+1)
+ Pk+1DF(t, tk+1) −Pk+1DF(t, tk+2) + · · ·
+ Pn−2DF(t, tn−1) −Pn−1DF(t, tn−1) −Pn−1DF(t, tn)
= PkDF(t, tk) −DF(t, tk+1){Pk −Pk+1} −Pk+1 −· · ·
−DF(t, tn−2){Pn−2 −Pn−1} −Pn−1DF(t, tn)
= PkDF(t, tk) −Pn−1DF(t, tn) +
n−1

i=k+1
AMiDF(t, ti)
(7.2.19)
and so the value of the ﬂoating leg is:
FLT(t) = PkDF(t, tk) −Pn−1DF(t, tn) +
n−1

i=k+1
AMiDF(t, ti)
(7.2.20)
When there is no amortization (Pk = Pn−1 and AMi = 0, i = 0, . . . , n −1)
then Eq. (7.2.20) reduces to Eq. (7.2.15).
Basis swap
This is very similar to an interest rate swap, but now there are two ﬂoating legs,
each with their associated principal amount.
For example, ﬂoating leg 1 could be associated with the one month LIBOR
(London Inter Bank Offer Rate) and have a schedule of monthly payments,
while ﬂoating leg 2 could use the three month LIBOR rates and have quarterly
payments. In this case, the forward rates and discount factors for leg 1 would
be computed using the 1 month LIBOR yield curve and the forward rates and
discount factors for leg 2 will be computed using the three month LIBOR yield
curve.
We will use the subscripts 1 and 2 to denote quantities associated with
legs 1 and 2 respectively. The payment times associated with leg 1 are ti
1, i =
1, . . . , n1, while those for leg 2 are ti
2, i = 1, . . . , n2, and (for this example)
n1 = 3n2.
If counterparty A makes the quarterly payments (that is, receives the pay-
ments made on leg 1), then the time t value of the basis swap is:
BS(t) = C1DF1(t, tk1) + FLT1(t) −C2DF2(t, tk2) −FLT2(t)
(7.2.21)

214
Computational Finance Using C and C#
where we have used similar notation to that used in Eq. (7.2.12), with
FLT1(t) = P1

DF1(t, tk1) −DF1(t, tn)

(7.2.22)
and
FLT2(t) = P2

DF2(t, tk2) −DF2(t, tn)

(7.2.23)
In Eqs. (7.2.22) and (7.2.23) P1 is the principal for leg 1 and P2 is the principal
for leg 2. The time of the next coupon payment for leg 1 is tk1, while that for
leg 2 is tk2: in addition we have used the fact that tn1 = tn2 = tn.
We will now consider the case in which the basis swap has been traded at
time t, and shall also assume that C1 = C2 = 0 and t = tk1 = tk2. In addition, we
will specify that principal exchange occurs at the start (time t) and end (time tn)
of the swap.
The cash ﬂows associated with principal exchange at the start of the swap leg
are in the opposite direction to those for the remainder of the swap leg; see Hull
(2003). We have:
FLT1(t) = P1 −P1DF1(t, tn) +

−P1 + P1DF(t, tn)

(7.2.24)
and
FLT2(t) = P2 −P2DF2(t, tn) +

−P2 + P2DF(t, tn)

(7.2.25)
where the principal exchange terms are in the curly brackets, and use discount
factors DF(t, T ) derived from the main currency yield curve (in this case GBP)
rather than DF1(t, T ) or DF2(t, T ).
It can be seen from Eq. (7.2.21) that principal exchange at the start of the
swap causes leg 2 to contribute the positive amount P2 to the value of the swap,
while leg 1 contributes the negative amount P2 to the value of the swap. In
contrast, principal exchange at the end of the swap results in leg 2 contributing
the negative amount −P2DF(t, tn) to the swap value, while leg 1 contributes
the positive amount P1DF(t, tn). If P1 = P2 = P then principal exchange does
not affect the value of the basis swap. It can also be seen from Eq. (7.2.24)
that if leg 1 used the main GBP yield curve instead of the one month LIBOR
curve, then DF1(t, tn) = DF(t, tn) which would result in FLT1(t) = 0. Similarly
DF2(t, tn) = DF(t, tn) would mean that FLT2(t) = 0.
If the valuation time t is after the trade has started, then Eq. (7.2.21) can be
used to price the basis swap, but Eqs. (7.2.24) and (7.2.25) need to be modiﬁed
as follows:
FLT1(t) = P1DF1(t, tk1) −P1DF1(t, tn) +

P1DF(t, tn)

(7.2.26)
and
FLT2(t) = P2DF2(t, tk2) −P2DF2(t, tn) +

P2DF(t, tn)

(7.2.27)
We will now consider how the timing of the coupon payment in relation to its
associated forward rate affects the present value, Vt0, of the coupon.

Other ﬁnancial derivatives
215
Coupon payment on time
In this section we will justify the approach we have adopted in obtaining the
present value of future cashﬂows generated from vanilla forward rates.
From Eq. (4.2.1) we know that the value at time t0 of a coupon payment at
time tk is:
Vt0 = DF(t0, tk)EQkF(tk−1, tk−1, tk)
DF(tk, tk)

τP
where the symbols have their usual meaning, and we have chosen the numeraire
to be the zero coupon bond which matures at time tk. Since DF(tk, tk) = 1 we
can write
Vt0 = DF(t0, tk)EQk
F(tk−1, tk−1, tk)

τP
(7.2.28)
In Section 7.2.3 we show that F(t, tk−1, tk) follows the process:
d

F(t, tk−1, tk)

= σkF(t, tk−1, tk) dW k
(7.2.29)
If we assume that σk is constant, then Eq. (7.2.29) is GBM (see Chapter 2) and
has the solution:
F(t, tk−1, tk) = F(t0, tk−1, tk) exp

−(t −t0)σ 2
k
2
+ σkW k
t

(7.2.30)
where we have taken W k
t0 = 0.
Substituting t = tk−1 into Eq. (7.2.30) gives:
F(tk−1, tk−1, tk) = F(t0, tk−1, tk) exp

−(tk−1 −t0)σ 2
k
2
+ σkW k
tk−1

(7.2.31)
which means that:
EQk
F(tk−1, tk−1, tk)

= EQk
F(t0, tk−1, tk) exp

−(tk−1 −t0)σ 2
k
2
+ σkW k
tk−1

= F(t0, tk−1, tk)EQk
exp

−(tk−1 −t0)σ 2
k
2
+ σkW k
tk−1

= F(t0, tk−1, tk)EQk
exp

−(tk−1 −t0)σ 2
k
2
+ σk

tk−1 −t0 N(0, 1)

= F(t0, tk−1, tk)
where we have used the fact (see Appendix D.2) that
EQk
exp

−(tk−1 −t0)σ 2
k
2
+ σk

tk−1 −t0 N(0, 1)

= exp

−(tk−1 −t0)σ 2
k
2
+ (tk−1 −t0)σ 2
k
2

= 1

216
Computational Finance Using C and C#
Substituting for EQk[F(tk−1, tk−1, tk)] in Eq. (7.2.28):
Vt0 = PτF(t0, tk−1, tk) = DF(t0, tk)1
τ
DF(t0, tk−1)
DF(t0, tk)
−1

Pτ
This yields
Vt0 = P

DF(t0, tk−1) −DF(t0, tk)

(7.2.32)
which is our current method of valuing the future coupons generated by forward
rates.
General payment timing
For the general case, in which the coupon payment date does not correspond to
the end of its associated forward rate, we use the result from Eq. (7.2.43) that
dW k =
μk
σk

dt + dW i,
i ̸= k
(7.2.33)
Equation (7.2.33) states that Brownian motion W i under numeraire DF(t, ti)
can be transformed into Brownian motion W k under numeraire DF(t, tk) by the
addition of a drift term—more detail can be found in Section 7.2.3. If we assume
constant drift μk, W k
t0 = W i
t0 = 0 we obtain:
W k
t = (t −t0)
μk
σk

+ W i
t
(7.2.34)
and in Eq. (7.2.30)
σkW k
t = (t −t0)μk + σkW i
t
A constant μk can be achieved by freezing the forward rates that make up μk;
for example, F(t, tk−1, tk) →F(t0, tk−1, tk); see Section 7.2.3 for more details
concerning μk.
This means that F(t, tk−1, tk) follows the process:
d

F(t, tk−1, tk)

= F(t, tk−1, tk)μk dt + F(t, tk−1, tk)σk dW i
The above equation is GBM with drift and can be solved by modifying
Eq. (7.2.30) to:
F(t, tk−1, tk)
= F(t0, tk−1, tk) exp

(t −t0)μk −(t −t0)σ 2
k
2
+ σkW i
t

(7.2.35)
As before, the time t0 value of the coupon payment at time ti is:
Vt0 = DF(t0, ti)EQiF(tk−1, tk−1, tk)
DF(ti, ti)

τP
which since DF(ti, ti) = 1 becomes
Vt0 = DF(t0, ti)EQi
F(tk−1, tk−1, tk)

τP
(7.2.36)

Other ﬁnancial derivatives
217
Now, from Eq. (7.2.35) we have:
EQi
F(tk−1, tk−1, tk)

= EQi
F(t0, tk−1, tk) exp

(t −t0)μk −(tk−1 −t0)σ 2
k
2
+ σkW i
tk−1

= F(t0, tk−1, tk) exp

(tk−1 −t0)μk

× EQi
exp

−(tk−1 −t0)σ 2
k
2
+ σkW i
tk−1

= F(t0, tk−1, tk) exp

(tk−1 −t0)μk

(7.2.37)
where, as before, we have used the expectation given in Appendix D.2.
By expanding Eq. (7.2.37) to ﬁrst order we obtain:
EQi
F(tk−1, tk−1, tk)

= F(t0, tk−1, tk) + F(t0, tk−1, tk)(tk−1 −t0)μk
(7.2.38)
Substituting Eq. (7.2.38) into Eq. (7.2.36), we obtain a general expression for
the value of the coupon payment:
Vt0 = DF(t0, ti)τ

F(t0, tk−1, tk) + F(t0, tk−1, tk)(tk−1 −t0)μk

(7.2.39)
We will now consider the cases of early and late coupon payments.
Early coupon payment
Let us consider the case when i = k −1. From Eq. (7.2.50):
μk = τσ 2
k F(t, tk−1, tk)
1 + τF(t, tk−1, tk)
First we freeze the forward rates in μk so we use the following:
μk = τσ 2
k F(t0, tk−1, tk)
1 + τF(t0, tk−1, tk)
Substituting for μk in Eq. (7.2.39) we obtain:
Vt0 = DF(t0, tk−1)τP

F(t0, tk−1, tk) + (tk−1 −t0)σ 2
k τkF 2(t0, tk−1, tk)
1 + τF(t0, tk−1, tk)

(see Brigo and Mercurio, 2001, p. 387, and Hull, 2003).
Late coupon payment
We consider the case when i = k + 1. From Eq. (7.2.66):
μk = −τρk,k+1σkσk+1F(t, tk, tk+1)
1 + τF(t, tk, tk+1)

218
Computational Finance Using C and C#
Freezing the forward rates we obtain:
μk = −τρk,k+1σkσk+1F(t0, tk, tk+1)
1 + τF(t0, tk, tk+1)
Substituting for μk in Eq. (7.2.39) we obtain:
Vt0 = DF(t0, tk+1)
× τP

F(t0, tk−1, tk)
−(tk −t0)τρk,k+1σkσk+1F(t0, tk−1, tk)F(t0, tk, tk+1)
1 + τF(t0, tk, tk+1)

7.2.3
Timing adjustment
In this section we derive expressions for the drift of the forward rate F(t, tk−1, tk)
under various probability measures. We will denote the time t value of a zero
coupon bond which pays 1 unit of currency at maturity ti by DF(t, ti). For
convenience we will also use the shortened notation Fk = F(t, tk−1, tk) and
DFi = DF(t, ti).
The probability measure under which all tradable assets are priced relative to
the zero coupon bond price DFi (that is, DFi is the numeraire) will be denoted
by Qi; under this probability measure the relative prices will be martingales. We
will also denote Brownian motion under probability measure Qi by W i.
Case i = k
Here the maturity of the numeraire DFk is at the expiry of the forward rate Fk.
Since DFk(1+τFk) is a tradable its relative price, (1 + τFk)/DFk, is a martin-
gale under Qk and thus has zero drift.
Also DFk(1 + τFk)/DFk = 1 + τFk and, since both τ and 1 are constants,
Fk must be a martingale under Qk. Thus the process for Fk has zero drift and is:
dFk = Fkσk dW k
(7.2.40)
For the general case in which i ̸= k, the process followed by Fk is:
dFk = Fkμk dt + Fkσk dW i
(7.2.41)
where μk is a drift that needs to be determined. Equation (7.2.41) can be rewrit-
ten as:
dFk = Fkσk
μk
σk
dt + dW i

(7.2.42)
Comparing Eqs. (7.2.41) and (7.2.42) we have:
dW k = μk
σk
dt + dW i
(7.2.43)
This equation gives the relation between Brownian motions under probability
measures Qk and Qi. We will now show how to compute the value of μk.

Other ﬁnancial derivatives
219
Case i < k
Here we consider situations in which the maturity of the numeraire DFi is before
the expiry of the forward rate Fk.
i = k −1
In this case DFk−1 is the numeraire, the forward rate is Fk = F(t, tk−1, tk),
and the numeraire matures at time tk−1, while the forward rate has expiry tk.
Since DFk is a tradable the relative price, φ = DFk/DFk−1, is a martingale
under Qk−1, and thus has zero drift.
Now
φ =
DFk
DFk−1
=
1
1 + τFk
(7.2.44)
where we have used:
DFk−1 = DFk(1 + τFk)
(7.2.45)
Let the stochastic process followed by Fk under Qk−1 be:
dFk = Fkμk dt + Fkσk dW k−1
(7.2.46)
and the drift, μk, is to be determined.
Using Ito we have:
dφ = ∂φ
∂Fk
dFk + 1
2
∂2φ
∂F 2
k
E

(dFk)2
,
E

(dFk)2
= σ 2
k F 2
k dt,
(7.2.47)
where from Eq. (7.2.44):
∂φ
∂Fk
= −
τ
(1 + τFk)2 ,
∂2φ
∂Fk2 =
2τ 2
(1 + τFk)3
(7.2.48)
Substituting the values in Eq. (7.2.48) into Eq. (7.2.47) we obtain:
dφ = −
τφ
1 + τFk

Fkμk dt + Fkσk dW k−1
+ 1
2
τ 22φσ 2F 2
k dt
(1 + τFk)2
which can be rearranged as:
dφ =

−τFkμkφ
1 + τFk
+ φτ 2σ 2
k F 2
k
(1 + τFk)2

dt −τφFkσk
1 + τFk
dW k−1
(7.2.49)
Now since Eq. (7.2.49) is driftless:

−τFkμkφ
1 + τFk
+ φτ 2σ 2
k F 2
k
(1 + τFk)2

dt = 0
and
μk = τσ 2
k Fk
1 + τFk
(7.2.50)

220
Computational Finance Using C and C#
Substituting Eq. (7.2.50) into Eq. (7.2.46):
dFk = τσ 2
k F 2
k
1 + Fkτ dt + Fkσk dW k−1
or
dFk = Fkσk
 τσ 2
k Fk
1 + Fkτ dt + dW k−1

(7.2.51)
Comparing Eqs. (7.2.51) and (7.2.40) thus yields:
dW k = τσkFk
1 + Fkτ dt + dW k−1
(7.2.52)
which is the relationship between the Brownian motions dW k−1 and dW k under
the respective probability measures Qk−1 and Qk.
i ⩽k −2
Let the stochastic process followed by Fk under Qk−2 be:
dFk = Fkμk dt + Fkσk dW k−2
(7.2.53)
where W k−2 is Brownian motion under probability measure Qk−2, and the drift,
μk, is unknown.
Replacing k with k −1 in Eq. (7.2.52) gives:
dW k−1 = τσk−1Fk−1
1 + Fk−1τ dt + dW k−2
(7.2.54)
and using Eq. (7.2.54) to substitute for dW k−1 in Eq. (7.2.52) we obtain:
dW k = τσkFk
1 + Fkτ dt + τσk−1Fk−1
1 + Fk−1τ dt + dW k−2
(7.2.55)
Replacing dW k in Eq. (7.2.40) with that given in Eq. (7.2.55):
dFk = Fkσk
 τσkFk
1 + Fkτ dt + τσk−1Fk−1
1 + Fk−1τ dt

+ Fkσk dW k−2
(7.2.56)
so the drift is:
μk = τσ 2
k Fk
1 + τFk
+ τFk−1σkσk−1ρk,k−1
1 + τFk−1
(7.2.57)
The following general expression can be derived in a similar manner:
dFk = σkFk
k

j=i+1
ρk,jτσjFj
1 + τFj
dt + σkFk dW i
(7.2.58)
where all the symbols have the same meanings as before, but now i can take
any integer value less than k.

Other ﬁnancial derivatives
221
Case i > k
We now consider the case when the maturity of the numeraire DFi is after the
expiry of the forward rate Fk.
i = k + 1
Here DFk+1 is the numeraire and Fk is the forward rate which starts at time
tk−1 and ends at time tk.
Since DFk−1 is a tradable its relative price, φ = DFk−1/DFk+1, is a martingale
under Qk+1, and thus has zero drift.
Now:
φ = DFk−1
DFk+1
= (1 + τFk)(1 + τFk+1)
(7.2.59)
where the processes for Fk and Fk+1 are
dFk+1 = Fk+1σk+1dW k+1
(7.2.60)
dFk = Fkμk dt + Fkσk dW k+1
(7.2.61)
and the drift, μk, is to be determined.
Using Ito we have:
dφ = ∂φ
∂Fk
dFk +
∂φ
∂Fk+1
dFk+1 + 1
2
k+1

i=k
k+1

j=k
∂2φ
∂Fi ∂Fj
E[dFi, dFj]
(7.2.62)
where
∂φ
∂Fk
= τ(1 + τFk+1),
∂φ
∂Fk+1
= τ(1 + τFk)
∂2φ
∂F 2
k
=
∂2φ
∂F 2
k+1
= 0,
∂2φ
∂Fk+1 ∂Fk
=
∂2φ
∂Fk ∂Fk+1
= τ 2
(7.2.63)
E[dFk, dFk+1] = [dFk+1, dFk] = ρk,k+1σkσk+1FkFk+1 dt
Substituting the values in (7.2.63) into Eq. (7.2.62) we obtain:
dφ = τ(1 + τFk+1) dFk + τ(1 + τFk) dFk+1 + τ 2ρk,k+1σkσk+1FkFk+1 dt
After expanding the terms in dFk and dFk+1 we have:
dφ = τ(1 + τFk+1)

Fkμk dt + Fkσk dW k+1
+ τ(1 + τFk)Fk+1σk+1 dW k+1 + τ 2ρk,k+1σkσk+1FkFk+1 dt
and this can be re-expressed as:
dφ = D + τ(1 + τFk+1)Fkσk dW k+1
+ τ(1 + τFk)Fk+1σk+1 dW k+1
(7.2.64)
where the drift term D in Eq. (7.2.64) is given by:
D = τ(1 + τFk+1)Fkμk dt + τ 2ρk,k+1σkσk+1FkFk+1 dt
(7.2.65)

222
Computational Finance Using C and C#
Now since φ is a martingale under Qk+1 we know that D = 0, and therefore
Eq. (7.2.65) results in:
(1 + τFk+1)Fkμk dt = −ρk,k+1σkσk+1FkFk+1 dt
This means that the drift is:
μk = −τρk,k+1σkσk+1Fk+1
1 + τFk+1
(7.2.66)
Substituting for μk in Eq. (7.2.61) gives:
dFk = Fkσk

−τρk,k+1σk+1Fk+1
1 + τFk+1
dt + dW k+1

(7.2.67)
Comparing Eq. (7.2.67) with Eq. (7.2.40) we have:
dW k = −τρk,k+1σk+1Fk+1
1 + τFk+1
dt + dW k+1
(7.2.68)
which is the relationship between Brownian motions dW k and dW k+1.
i ⩾k + 2
Let the stochastic process followed by Fk under Qk+2 be:
dFk = Fkμk dt + Fkσk dW k+2
(7.2.69)
where W k+2 is Brownian motion under probability measure Qk+2, and drift
term μk is to be found.
Replacing k with k + 1 in Eq. (7.2.68) gives:
dW k+1 = −τρk+1,k+2σk+2Fk+2
1 + τFk+2
dt + dW k+2
(7.2.70)
and using Eq. (7.2.70) to substitute for dW k+1 in Eq. (7.2.68) gives:
dW k = −τρk,k+1σk+1Fk+1
1 + τFk+1
dt −τρk+1,k+2σk+2Fk+2
1 + τFk+2
dt + dW k+2
Substituting for dW k in Eq. (7.2.40) gives:
dW k = −Fkσk
τρk,k+1σk+1Fk+1
1 + τFk+1
dt + τρk+1,k+2σk+2Fk+2
1 + τFk+2
dt

+ Fkσk dW k+2
(7.2.71)
and thus the drift is a
μk = −τρk,k+1σk+1Fk+1
1 + τFk+1
−τρk+1,k+2σk+2Fk+2
1 + τFk+2
(7.2.72)
The following general expression can be derived in a similar manner:
dFk = −σkFk
i

j=k+1
ρk,jτσjFj
1 + τFj
dt + σkFk dW i
(7.2.73)
where all the symbols have the same meanings as before, but now i can take
any integer value greater than k.

Other ﬁnancial derivatives
223
7.2.4
Interest rate quantos
This section considers derivatives whose value depends on the foreign interest
rate yield curve but have a payoff in domestic currency. We use the same nota-
tion as in Section 7.3, which deals with foreign exchange derivatives.
For example, a standard interest rate caplet has a payoff in domestic currency
and also depends on the domestic currency forward rates. The value at time t0
of a caplet which pays at time tk and extends from time tk−1 to time tk is:
Caplet(t0) = PτDFd(t0, tk)EQk
max

F d
k −K, 0

(7.2.74)
where P is the principal, K is the strike, τ = tk−1−tk, Fk is the domestic forward
rate F(t0, tk−1, tk). Equation (7.2.74) can be evaluated using the Black–Scholes
formula as follows:
Caplet(t0) = PτDFd(t0, tk)

F d(t0, tk−1, tk)N1(d1) −KN1(d2)

(7.2.75)
where σd is the volatility of Fk, and
d1 = log(F d(t0, tk−1, tk)/K) + σ 2
d
2 (tk−1 −t0)
σd
√tk−1 −t0
d2 = log(F d(t0, tk−1, tk)/K) −σ 2
d
2 (tk−1 −t0)
σd
√tk−1 −t0
(7.2.76)
In Section 7.2.3 we showed that the process (F d(t, tk−1, tk)/DFd(t, tk)) is a mar-
tingale, that is has zero drift when DFd(t, tk) is used as a numeraire.
d

F d(t, tk−1, tk)

= σdF d(t, tk−1, tk) dW Q
k
Quanto caplet
In a quanto caplet instead of using the domestic forward rate F d(t0, tk−1, tk) we
use the foreign forward rate F f (t0, tk−1, tk). Under the probability measure F
associated with a foreign zero coupon bond DFf (t, kk) the foreign forward rate
is a martingale, and is described by the following equation:
d

F f (t, tk−1, tk)

= σf F f (t, tk−1, tk) dW F
f
(7.2.77)
However, when we use DFd(t, tk) as a numeraire the process (F f (t, tk−1, tk)/
DFd(t, tk)) has a drift, and follows the process:
d

F f (t, tk−1, tk)

= F f (t, tk−1, tk)α dt + σf F f (t, tk−1, Tk) dW Q
f
(7.2.78)
Our aim is to ﬁnd the value of α and then price the quanto caplet using:
QCaplet(t0) = PτDFd(t0, tk)
×

F f (t0, tk−1, tk) exp

α(tk−1 −t0)

N1(d1) −KN1(d2)

(7.2.79)

224
Computational Finance Using C and C#
where P is the principal, K is the strike, τ = tk−1 −tk, F f (t0, tk−1, tk) is the
foreign currency forward rate, σf is the volatility of F f (t0, tk−1, tk) and
d1 =
log(F f (t0, tk−1, tk)/K) + (α + σ 2
f /2)(tk−1 −t0)
σf
√tk−1 −t0
d2 =
log(F f (t0, tk−1, tk)/K) + (α −σ 2
f /2)(tk−1 −t0)
σf
√tk−1 −t0
We will now derive the value of α.
First we deﬁne two processes X1(t) and X2(t) such that:
X1(t) =
DFf (t, tk−1) −DFf (t, tk)
DFd(t, tk)

Xf
d (t)
(7.2.80)
and
X2(t) = τXf
d (t)DFf (t, tk)
DFd(t, tk)
= τXf
d (t, tk)
(7.2.81)
where Xf
d (t, tk) is the forward foreign exchange rate (see Section 7.3). Therefore,
X1(t)
X2(t) = DFf (t, tk−1) −DFf (t, tk)
τDFf (t, tk)
= F f (t, tk−1, tk)
(7.2.82)
Now X1 and X2 are martingales under Q so we have:
dX1 = σ1X1 dW Q
1
(7.2.83)
and
dX2 = σ2X2 dW Q
2
(7.2.84)
Equation (7.2.84) can also be expressed as
d(τXf
d (t, tk))
τXf
d (t, tk)
= σx dW Q
x
(7.2.85)
Using Ito we obtain:
d
X1
X2

= X1
X2

σ1 dW Q
1 −σ2 dW Q
2

+ X1
X2

E

σ2 dW Q
2
2
−E

σ1 dW Q
1

σ2 dW Q
2

(7.2.86)
and the following processes for log(X1) and log(X2):
d

log(X1)

= −σ 2
1
2 dt + σ1 dW Q
1
d

log(X2)

= −σ 2
2
2 dt + σ2 dW Q
2
(7.2.87)

Other ﬁnancial derivatives
225
Using Eq. (7.2.85) we can write Eq. (7.2.87) as:
d

log

τXf
d (t, tk)

= −σ 2
x
2 dt + σx dW Q
x
(7.2.88)
Now,
E

d

log(X2)

d

log(X2)

−d

log(X1)

= E

d

log(X2)
2
−E

d

log(X1)

d

log(X2)

= E

σ2 dW Q
2
2
−E

σ1 dW Q
1

σ2 dW Q
2

where we have ignored terms in dt with order greater than 1.
In addition,
E

d

log(X2)

d

log(X2)

−d

log(X1)

= −E

d(log(X2)) d

log
X1
X2

= −E

d

log(X2)

d

log

F f (t, tk−1, tk)

= −E

d

log

τXf
d (t, tk)

d

log

F f (t, tk−1, tk)

= −E

d

log

Xf
d (t, tk)

d

log

F f (t, tk−1, tk)

= −σxσf ρx,f dt
where σx is the volatility of the forward foreign exchange rate Xf
d (t, tk), σf is the
volatility of the foreign forward rate F f (t, tk−1, k), and ρx,f is the correlation
between dW Q
x and dW F
f .
Therefore Eq. (7.2.86) can be written as:
d
X1
X2

= −X1
X2
{σxσf ρx,f } dt + X1
X2

σ1 dW Q
1 −σ2 dW Q
2

which means that
d

F f (t, tk−1, tk)

= −F f (t, tk−1, tk){σxσf ρx,f } dt + F f (t, tk−1, tk)

σ1 dW Q
1 −σ2 dW Q
2

Comparing the above equation with Eq. (7.2.78):
d

F f (t, tk−1, tk)

= −F f (t, tk−1, tk){σxσf ρx,F } dt + σf F f (t, tk−1, tk) dW Q
(7.2.89)
and so α = −σxσf ρx,f .

226
Computational Finance Using C and C#
Quanto ﬂoorlet
The formula to value a quanto ﬂoorlet can be obtained in similar manner to
that used for the quanto caplet.
The value at time t0 of a standard ﬂoorlet which pays at time tk and extends
from time tk−1 to time tk is:
Floorlet(t0) = PτDFd(t0, tk)EQk
max

K −F d
k , 0

(7.2.90)
where P is the principal, K is the strike, τ = tk−1−tk, Fk is the domestic forward
rate F(t0, tk−1, tk). Equation (7.2.90) can be evaluated using the Black–Scholes
formula as follows:
Floorlet(t0) = PτDFd(t0, tk)

−F d(t0, tk−1, tk)N1(−d1) + KN1(−d2)

(7.2.91)
where the symbols have the same meaning as for the corresponding quanto
caplet.
d1 = log(F d(t0, tk−1, tk)/K) + σ 2
d
2 (tk−1 −t0)
σd
√tk−1 −t0
,
d2 = log(F d(t0, tk−1, tk/K) −σ 2
d
2 (tk−1 −t0)
σd
√tk−1 −t0
(7.2.92)
In a quanto ﬂoorlet, instead of using the domestic forward rate F d(t0, tk−1, tk),
we use the foreign forward rate F f (t0, tk−1, tk):
QFloorlet(t0)
= PτDFd(t0, tk)
×

−F f (t0, tk−1, tk) exp

α(tk−1 −t0)

N1(−d1) + KN1(−d2)

(7.2.93)
where P is the principal, K is the strike, τ = tk−1 −tk, F f (t0, tk−1, tk) is the
foreign currency forward rate, σf is the volatility of F f (t0, tk−1, tk) and
d1 = log(F f (t0, tk−1, tk)/K) + (α +
σ 2
f
2 )(tk−1 −t0)
σf
√tk−1 −t0
d2 = log(F f (t0, tk−1, tk)/K) + (α −
σ 2
f
2 )(tk−1 −t0)
σf
√tk−1 −t0
and as before α = −σxσf ρx,f .

Other ﬁnancial derivatives
227
Quanto swaplet
A quanto (also known as diff or differential) swaplet is an agreement in which
one party makes ﬂoating rate payments based on the foreign forward rate while
the other makes ﬁxed or ﬂoating payments based on the domestic interest rates.
Here we consider quanto swaplets in which the received ﬂoating leg coupons
(in domestic currency) are computed using foreign forward rates.
The value of a standard swaplet (in which all the currencies are domestic) can
be found by using Eqs. (7.2.90) and (7.2.74) to write:
Caplet(t0) −Floorlet(t0)
= PτDFd(t0, tk)EQk
max

F d
k −K, 0

−max

K −F d
k , 0

= PτDFd(t0, tk)EQk
F d
k −K

= PτDFd(t0, tk)

EQk
F d
k

−K

= PτDFd(t0, tk)

F d
k (t0, tk−1, tk) −K

(7.2.94)
From Eq. (7.2.94) we can see that Caplet(t0) −Floorlet(t0) is the value of a
swaplet in which the owner pays the ﬁxed rate K and receives the ﬂoating rate
F d
k (t0, tk−1, tk).
The value of the ﬂoating leg payment can be found by setting K = 0 in
Eq. (7.2.94), and is PτDFd(t0, tk)F d
k (t0, tk−1, tk).
The value of the ﬂoating leg payments in a quanto swap can be found in a
similar manner:
QCaplet(t0) −QFloorlet(t0)
= PτDFd(t0, tk)EQk
max

F f
k −K, 0

−max

K −F f
k , 0

Substituting from Eqs. (7.2.79) and (7.2.93):
QCaplet(t0) −QFloorlet(t0)
= PτDFd(t0, tk)

F f (t0, tk−1, tk) exp

α(tk−1 −t0)

N1(d1) −KN1(d2)
−F f (t0, tk−1, tk)N1(−d1) + KN1(−d2)

When K = 0 we have d1 = ∞, N1(d1) = 1 and N1(−d1) = 0, which means that
the value of the ﬂoating leg payment is:
FloatLeg(t0) = PτDFd(t0, tk)F f (t0, tk−1, tk) exp

α(tk−1 −t0)

(7.2.95)
where as before α = −σxσf ρx,f .
Using Eq. (7.2.95) the value of a quanto swaplet with (pay) ﬁxed domestic
rate and (receive) foreign ﬂoating rate is:
QSwaplet(t0) = PτDFd(t0, tk)

F f (t0, tk−1, tk) exp

α(tk−1 −t0)

−K


228
Computational Finance Using C and C#
7.3
Foreign exchange derivatives
Here we consider derivatives based on the exchange rate between a domestic
currency and a foreign currency. We will use the convention that quantities re-
lating to the domestic currency will have the superscript d, while those for the
foreign currency will have the superscript f . The notation for the various ex-
change rates is as follows:
• Xf
d (t) is the spot value of one unit of foreign currency in domestic currency
at time t
• Xf
b (t) is the spot value of one unit of foreign currency in base currency at
time t
• Xd
b(t) is the spot value of one unit of domestic currency in base currency at
time t
• Xf
d (t, T ) is the (time t) forward value of one unit of foreign currency in do-
mestic currency at time T .
Covered interest arbitrage
If the current spot exchange rate, Xf
d (t), is known then using covered interest
arbitrage it is possible to obtain a value for the future spot exchange rate—we
denote this forward exchange rate by Xf
d (t, T ), where T > t.
Let us consider the following two scenarios:
Scenario A
At time t an investor deposits one unit of foreign currency which grows
at the (constant) foreign risk free interest rate rf . By time T the initial
amount will have increased to 1/DFf (t, T ) units of foreign currency, where
DFf (t, T ) = exp(−rf (T −t)). The foreign currency is then converted into do-
mestic currency at the time T forward exchange rate Xf
d (t, T ), and thus yields
Xf
d (t, T )/DFf (t, T ) units of domestic currency.
Scenario B
At time t an investor deposits Xf
d (t) units of domestic currency (the sum is
equivalent to one unit of foreign currency), and this grows at the (constant)
domestic risk free interest rate rd. At time T the initial sum will have increased
to Xf
d (t)/DFd(t, T ) units of domestic currency, where DFd(t, T ) = exp(−rd(T −
t)).
For no arbitrage to occur the ﬁnal amount of domestic currency in both sce-
narios must be the same—we have assumed that there is no charge in converting
one currency into another.
We thus have:
Xf
d (t, T )
DFf (t, T )
=
Xf
d (t)
DFd(t, T )

Other ﬁnancial derivatives
229
which means that the forward exchange rate, at time T is
Xf
d (t, T ) = Xf
d (t)DFf (t, T )
DFd(t, T )
(7.3.1)
7.3.1
FX forward
An FX forward is a contract to exchange a given amount of domestic currency
for an agreed amount of foreign currency at a future time T . If P f is the amount
(number of units) of foreign currency, and P d is the amount (number of units)
of domestic currency, then the value (in domestic currency) of the FX contract
at time T is:
FXd(T ) = P f Xf
d (T ) −P d
The value of the contract at time t is thus:
FXd(t) =

P f Xf
d (t, T ) −P d
DFd(t, T )
where t < T . Substituting for Xf
d (t, T ) from Eq. (7.3.1) then gives:
FXd(t) =

P f Xf
d (t)DFf (t, T )
DFd(t, T )
−P d

DFd(t, T )
which can be re-expressed as
FXd(t) = P f Xf
d (t)DFf (t, T ) −P dDFd(t, T )
(7.3.2)
The value of this FX forward contract in base currency is thus
FXb(t) =

P f Xf
d (t)DFf (t, T ) −P dDFd(t, T )

Xd
b
That is,
FXb(t) = P f Xf
b (t)DFf (t, T ) −P dDFd(t, T )Xd
b(t)
(7.3.3)
where we have used the fact that Xf
d (t)Xd
b(t) = Xf
b (t).
An alternative way of expressing Eq. (7.3.3) is as:
FXb(t) = P f 
Xf
b (t)DFf (t, T ) −KDFd(t, T )Xd
b(t)

(7.3.4)
where K = P d/P f . In the next section we will see that K, the agreed rate to be
paid for one unit of foreign currency in units of domestic currency, corresponds
to the strike of an FX call option.
7.3.2
European FX option
Foreign exchange options can be priced using the Black–Scholes formula (Gar-
man and Kohlhagen, 1983). There are three processes involved in foreign ex-

230
Computational Finance Using C and C#
change options and, under the real-world probability measure P, they are:
dBf = rf Bf dt
dXf
d = Xf
d μ dt + Xf
d σ dW P ,
dW P ∼N(0, dt)
(7.3.5)
dBd = rdBd dt
where Xf
d is the value of one unit of foreign currency in units of domestic cur-
rency, Bd is the domestic money account where money grows at the (constant)
risk free rate rd, Bf is the foreign money account where money grows at the
(constant) risk free rate rf , and σ is the volatility of Xf
d . From a domestic point
of view there are only two assets—the money market account Bd, and the value
of the foreign money market account in domestic currency, Bf Xf
d .
From Ito’s product rule in Chapter 2, and using Eq. (2.6.3) with X1 = Xf
d
and X2 = Bd, we have:
d

Xf
d Bf 
= Xf
d Bf 
rf + μ

dt + Xf
d Bf σ dW P
We will now choose Bd as the numeraire and obtain the process for Bf Xf
d /Bd
using the Ito quotient rule given in Chapter 2. Substituting X1 = Bf Xf
d and
X2 = Bd in Eq. (2.6.8) we obtain:
d
Bf Xf
d
Bd

= Bf Xf
d
Bd

rf −rd + μ

dt

+ Bf Xf
d
Bd
σ dW P
If we choose the probability measure Q such that:
dW P = dW Q −(rf −rd + μ)
σ
dt
(7.3.6)
then (Bf Xf
d /Bd) is a martingale since
d
Bf Xf
d
Bd

= Bf Xf
d
Bd
σ dW Q
Substituting for dW P in Eq. (7.3.5) yields:
dXf
d = Xf
d μ dt + Xf
d σ

dW Q −(rf −rd + μ) dt
σ

= Xf
d μ dt −Xf
d

rf −rd + μ

dt + Xf
d σ dW Q
so
dXf
d = Xf
d

rd −rf 
dt + Xf
d σ dW Q
(7.3.7)
It can be seen that Eq. (7.3.7) is identical to Eq. (4.4.53) if the following map-
ping is used:
S →Xf
d ,
r →rd,
q →rf
(7.3.8)
This means that the above mapping allows us to price European FX puts and
calls with the Black–Scholes formulae given in Eqs. (4.4.55) and (4.4.56).

Other ﬁnancial derivatives
231
FX call
The time t value (in domestic currency) of an FX call to buy one unit of foreign
currency can be found from Eq. (4.4.55) and the substitutions given in (7.3.8).
We have:
Cd(t) = Xf
d (t) exp

−rf (T −t)

N(d1) −K exp

−rd(T −t)

N(d2)
(7.3.9)
d1 =
1
σ√T −t

log
Xf
d (t)
K

+

rd −rf 
(T −t) + 1
2σ 2(T −t)

(7.3.10)
d2 = d1 −σ
√
T −t
(7.3.11)
where K is the strike the rate that has been agreed to pay for one unit of foreign
currency in units of domestic currency, and σ is the implied foreign/domestic
currency exchange rate FX option volatility, which may depend on effects such
as time to maturity, volatility smile, etc.
In practice the following, modiﬁed version of Eq. (7.3.9) is usually used:
Cd(t) = P f 
Xf
d (t) exp

−rf (T −t)

N(d1) −K exp

−rd(T −t)

N(d2)

(7.3.12)
where P f is the number of units of foreign currency and all the other symbols
have their previous meanings.
The value Cb(t) of the call option in base currency can be found by using
Cb(t) = Xd
bCd(t). From Eq. (7.3.12) we have:
Cb(t) = P f 
Xf
b (t)N(d1)DFf (t, T ) −KXd
b(t)N(d2)DFd(t, T )

(7.3.13)
where we have used the fact that Xd
b(t)Xf
d (t)
=
Xf
b (t), DFf (t, T )
=
exp(−rf (T −t)) and DFd(t, T ) = exp(−rd(T −t)). We can also re-express
the values for d1 given in Eq. (7.3.10) as:
d1 =
1
σ√T −t

log
 Xf
b (t)
KXd
b(t)

+ log
DFf (t, T )
DFd(t, T )

+ 1
2σ 2(T −t)

(7.3.14)
where we have used the fact that
log

DFf (t, T )

= −rf (T −t),
log

DFd(t, T )

= −rd(T −t)
and
log
Xf
d (t)
K

= log
Xf
b (t)Xd
b(t)
KXd
b(t)

= log
 Xf
b (t)
KXd
b(t)

We note that the term KXd
b is the strike in units of base currency—that is, the
amount that has been agreed to pay for one unit of foreign currency in units of
base currency.

232
Computational Finance Using C and C#
In the case when N(d1) = N(d2) = 1 (i.e., there is no uncertainty) Eq. (7.3.13)
becomes:
Cb(t) = P f 
Xf
b (t)DFf (t, T ) −KXd
b(t)DFd(t, T )

which is the same as that already given in Eq. (7.3.4) for the FX forward.
FX put
The time t value of the corresponding put in units of base currency is:
Pb(t) = P f 
−Xf
b (t)DFf (t, T )N(−d1) + KXd
b(t)DFd(t, T )N(−d2)

(7.3.15)
where the symbols have the same meanings as for the FX call.
7.4
Credit derivatives
Credit derivatives take into account the fact that a counterparty may not honor
(for reasons of bankruptcy, etc.) the obligations set out in a given ﬁnancial con-
tract. In order to obtain the time t value of these derivatives it is necessary to
determine the probability that the counterparty (and thus the contract) will sur-
vive until some future time T > t. Here we will denote the survival probability
between times t and T by S(t, T ), and we compute its value from the hazard
rate.
The hazard rate
As previously mentioned the survival probability between times t and T , where
T > t, is denoted by S(t, T ). This means that the probability of default between
times t and T is:
Pdef(t, T ) = 1 −S(t, T )
and the probability of default, as seen from time t, between times T1 and T2 is:
Pdef(t, T1, T2) = S(t, T1) −S(t, T2),
T2 > T1
(7.4.1)
The time t discrete hazard rate between times T and T + T , denoted by
H(t, T, T + T ) is deﬁned by:
H(t, T, T + T ) =
1
T
Pdef(t, T, T + T )
S(t, T + T )
=
1
T
S(t, T ) −S(t, T + T )
S(t, T + T )
which means that
H(t, T, T + T ) = −S(t, T + T ) −S(t, T )
T
1
S(t, T + T )
(7.4.2)

Other ﬁnancial derivatives
233
As T →0, H(t, T, T +T ) →h(t, T ), where h(t, T ) is termed the continuous
hazard rate between times t and T .
We observe that as T →0 Eq. (7.4.2) becomes:
h(t, T ) = −∂S(t, T )
∂T
1
S(t, T )
(7.4.3)
Now Eq. (7.4.3) can be re-expressed as:
h(t, s) = −∂S(t, s)
∂s
∂{ln(S(t, s))}
∂S(t, s)
= −∂{ln(S(t, s))}
∂s
(7.4.4)
where s > t, and we have used:
1
S(t, T ) = −∂{ln(S(t, T ))}
∂S(t, T )
Integrating Eq. (7.4.4) yields:
 T
s=t
h(t, s) ds = −
 T
s=t
d

ln

S(t, s)

= −

ln

S(t, T )

−ln

S(t, t)

= −ln

S(t, T )

(7.4.5)
where we have used S(t, t) = 1 and ln(S(t, t)) = 0.
So using Eq. (7.4.5) the survival probability can be expressed as:
S(t, T ) = exp

−
 T
s=t
h(t, s) ds

(7.4.6)
or
S(t, T ) = exp

I(t, T )

(7.4.7)
where I(t, T ) is the cummulative hazard rate from time t to time T .
It is usual to approximate I(t, T ) as follows:
I(t, T ) ∼I(t, tk) =
k

i=1
h(ti−1, t)(ti −ti−1)
(7.4.8)
where t0 = t, tk = T , and the following section gives details on how to estimate
h(ti−1, t) from market observables.
One way of representing the hazard rates is to use a hazard rate curve which
is deﬁned as:

t0, I(t0, ti)

,
i = 0, , . . . , n
(7.4.9)
If we further deﬁne t0 = t = 0 and tn = T , then Eq. (7.4.9) becomes:
{0, 0},

t1, I(0, t1)

,

t2, I(0, t2)

, . . . ,

tn, I(0, tn)

(7.4.10)
where we have used the fact that I(t0, t0) = I(0, 0) = 0.

234
Computational Finance Using C and C#
Estimating the hazard rate from market observables
From Eq. (7.2.10) we know that the time t forward rate between times T1 and
T2 is given by:
F(t, T1, T2) =
1
T2 −T1
DF(t, T1)
DF(t, T2) −1

(7.4.11)
where DF(t, T1) and DF(t, T2) are the prices of the nondefaultable zero coupon
bonds with maturities T1 and T2, respectively.
Letting T1 = T and T2 = T + T we obtain:
F(t, T, T + T ) =
1
T

DF(t, T )
DF(t, T + T ) −1

(7.4.12)
which can be re-expressed as
F(t, T, T + T )
= −DF(t, T + T ) −DF(t, T )
T
1
DF(t, T + T )
(7.4.13)
If T →0 then F(t, T, T + T ) →f (t, T ) and from Eq. (7.4.13) we obtain:
f (t, T ) = −∂DF(t, T )
∂T
1
DF(t, T )
= −∂DF(t, T )
∂T
ln(DF(t, T ))
∂DF(t, T )
(7.4.14)
Using Eq. (7.4.14) the instantaneous forward rate computed using nondefault-
able zero coupon bond prices is:
f (t, T ) = −ln(DF(t, T ))
∂T
(7.4.15)
and the corresponding instantaneous forward rate computed from defaultable
zero coupon bond prices is:
¯f (t, T ) = −ln(DF(t, T ))
∂T
(7.4.16)
Taking the survival probability S(t, T ) to be the ratio of the prices of defaultable
and nondefaultable zero coupon bonds:
S(t, T ) = DF(t, T )
DF(t, T )
(7.4.17)
Now from Eqs. (7.4.15) and (7.4.16) we have:
¯f (t, T ) −f (t, T ) = −ln(DF(t, T ) −DF(t, T ))
∂T
= −∂
∂T ln
DF(t, T )
DF(t, T )

(7.4.18)

Other ﬁnancial derivatives
235
so from Eqs. (7.4.18) and (7.4.17):
¯f (t, T ) −f (t, T ) = −∂
∂T ln

S(t, T )

(7.4.19)
Combining Eqs. (7.4.19) and (7.4.4) we have:
h(t, T ) = ¯f (t, T ) −f (t, T )
(7.4.20)
This means that we can compute the hazard rate h(t, T ) by taking the differ-
ence between the instantaneous forward rates computed using defaultable and
nondefaultable zero coupon bonds.
7.4.1
Defaultable bond
For a defaultable bond we need to take into account the fact that the bond issuer
may default, that is cease to make the bond coupon payments.
The time t value of a defaultable bond is:

B(t) = PDF(t, tm)
principal
+
m

j=1
CjDF(t, tj)
coupons
+ PR
m

j=1
DF(t, tj)

S(t, tj−1) −S(t, tj)

recovery value
where tm is the maturity of the bond, P is the principal, Cj is the value of
the jth coupon, R is the recovery rate, S(t, tj) is the probability that the bond
will survive until time tj, and the zero coupon defaultable bond prices are de-
ﬁned by DF(t, tm) = S(t, tm)DF(t, tm) and DF(t, tj) = DF(t, tj)S(t, tj). The term
{S(t, tj−1) −S(t, tj)} is the probability that the bond will default between times
tj−1 and tj.
7.4.2
Credit default swap
A Credit Default Swap (CDS) is a contract between two counterparties in which
one (say A) makes periodic ﬁxed payments to the other (say B) in order to obtain
protection on the default of a reference credit. In the event of default, B pays
A the default payment of 1 −R, where R is the recovery rate, and the contract
ceases.
The time t value of the credit default swap to A, the purchaser of the insur-
ance, is:
CDS(t) = −
m

j=1
CjDF(t, tj)
coupons
+ P(1 −R)
m

j=1
DF(t, tj)

S(t, tj−1) −S(t, tj)

recovery value

236
Computational Finance Using C and C#
where the symbols have the same meanings as for the defaultable bond.
7.4.3
Total return swap
A Total Return Swap (TRS) is a synthetic replication of the return of a reference
asset (bond) B. The receiver of the TRS receives the coupon payments of the
reference asset during the life of the swap in return for making periodic coupon
payments at the risk-free ﬂoating rate plus an agreed margin. In the event of
default, the receiver makes a default payment to the payer equal to the agreed
initial price of the reference asset less the price at default, and the transaction
terminates. If there is no default then the difference between the initial asset
(bond) price B0 and the price at maturity B(tm) is settled between the payer and
the receiver, with the receiver paying (receiving) if the asset (bond) is worth less
(more) at maturity. The maturity of the reference asset (bond) may be longer
than the maturity tm of the swap.
To the receiver of the reference asset coupons a TRS has value TRSr, which is
given by:
TRSr = total bond return −total ﬂoating coupon payments of the swap
where total bond return is given by:
total bond return = total bond ﬁxed coupons over the duration of the
TRS+increase in the bond value at maturity of the TRS−default payment,
if the bond defaults over the duration of the TRS
The value of TRSr at time t is:
TRSr(t)
= C
tm

tj =t1
DF(t, tj)
ﬁxed reference bond payments
+ P
B(tm) −B0
B0

DF(t, tm)
increase in value of reference bond
−
tm

tj =t1
CjDF(t, tj)
ﬂoating payments of swap
at LIBOR + margin
−P(1 −R)
tm

tj =t1
DF(t, tj)
×

S(t, tj−1) −S(t, tj)

bond default payments
and the reference bond satisﬁes:
B(tR) = 1
B(tm) = DF(tm, tR)|t + C
tR

tj =tm
DF(tm, tj)|t

Other ﬁnancial derivatives
237
+ R
tR

tj =tm
DF(tm, tj)|t

S(t, tj−1) −S(tm, tj)

All symbols already deﬁned in this chapter have their previous meanings. In
addition,
P – the swap principal
C – the ﬁxed coupon of the reference bond
tm – the swap maturity
tR – the maturity of the reference bond B
B0 – the initial price of the reference bond
B(tm) – the ﬁnal price of the reference bond (at swap maturity)
Cj – the ﬂoating coupon payment at time tj. It is computed as:
Cj = P

F(t, tj−1, tj) + marginTRS
{tj −tj−1}
DF(t1, t2)|t – the discount factor between times t1 and t2 (as seen from time t)
is:
DF(t1, t2)|t = D(t, t2)
D(t, t1)
DF(t1, t2)|t – the defaultable discount factor between times t1 and t2 (as seen
from time t) is:
DF(t1, t2)|t = DF(t, t2)
DF(t, t1)
= DF(t, t2)
DF(t, t1)
S(t, t2)
S(t, t1)
DF(t, t1) – the defaultable discount factor between times t and t1 is:
DF(t, t1) = DF(t, t1)S(t, t1)
7.5
Equity derivatives
7.5.1
Total return swap
An equity total return swap consists of an equity leg (whose coupons are de-
termined by the change in value of the equity) and a ﬂoating leg which pays
according to the forwards of the ﬂoating interest rate.
Here we ignore the effect of equity dividends and also assume that the cur-
rencies for both the ﬂoating and equity legs of the swap are the same.
Equity leg
Let the equity leg be speciﬁed by coupon payments at times tk, k = 1, . . . , Ne,
where τe = tk −tk−1. If, at time t the next coupon payment occurs at ti then the
value of the equity leg is:

238
Computational Finance Using C and C#
Ve(t) =

S(t)
DF(t, ti) −L(ti−1)

DF(t, ti)
+
Ne

k=i+1

S(t)
DF(t, tk) −
S(t)
DF(t, tk−1)

DF(t, tk)
(7.5.1)
where S(t) is the equity value at current time t, L(ti−1) is the reset value of
the equity at time ti−1, and DF(t, tk) is the discount factor between times t and
tk, tk > t. It can be seen that the value of the equity S(t1) at time t1 > t is
obtained by inﬂating the current value, S(t) by the reciprocal of the discount
factor, DF(t, t1); that is, S(t1) = S(t)/DF(t, t1).
Floating leg
Let the ﬂoating leg have coupon payments at times tm, m = 1, . . . , Nf , where
τf = tm −tm−1. If the next coupon is at time tj, then the value of the ﬂoating leg
is:
Vf (t) = L(tj−1)

R(tj−1) + Φ

τf DF(t, tj)
+
Nf

m=j+1
S(t)
DF(t, tm−1)

F(t, tm−1, tm) + Φ

τf DF(t, tm)
(7.5.2)
where Φ is the margin added to the forward rate used to compute coupons,
F(t, tm−1, tm) is the time t forward rate between times tm−1 and tm, and R(tj−1)
is the reset rate that is used between times tj−1 and tj to compute the coupon
payment at time tj.
Payer equity total return swap
The owner of a payer equity TRS pays the equity leg coupons, and thus at time
t the swap has value:
ETRSp(t) = Vf (t) −Ve(t)
(7.5.3)
The owner of a receiver equity TRS receives the equity leg coupons, and the
value of the swap is:
ETRSr(t) = −Vf (t) + Ve(t)
(7.5.4)
We will now compute an expression for the value of a payer equity swap. Since
F(t, tm−1, tm) =
1
tm −tm−1
DF(t, tm−1)
DF(t, tm)
−1

we have:
τf F(t, tm−1, tm) = DF(t, tm−1)
DF(t, tm)
−1
(7.5.5)
Substituting Eq. (7.5.5) into Eq. (7.5.2) and using Eq. (7.5.3) we obtain:

Other ﬁnancial derivatives
239
ETRSp(t) =
Nf

m=j+1
S(t)DF(t, tm)
DF(t, tm−1)
DF(t, tm−1)
DF(t, tm)
−1

+
Nf

m=j+1
S(t)
DF(t, tm−1)Φτf DF(t, tm)
+ L(tj−1)(R(tj−1) + Φ)τf DF(t, tj)
−
Ne

k=i+1
S(t)

1 −
DF(t, tk)
DF(t, tk−1)

−

S(t)
DF(t, ti) −L(ti−1)

DF(t, ti)
(7.5.6)
If Ne = Nf = N, and τe = τf = τ, then all the equity and ﬂoat leg payments
coincide and Eq. (7.5.6) simpliﬁes to:
ETRSp(t) = S(t)
N

k=j+1
DF(t, tk)
DF(t, tk−1)ΦτDF(t, tk)
+ L(R + Φ)τDF(t, tj) −

S(t)
DF(t, tj) −L

DF(t, tj)
(7.5.7)
Thus, if the spread Φ is zero the value of the payer equity TRS is:
ETRSp(t) = L(tj−1)R(tj−1)τDF(t, tj)
−

S(t)
DF(t, tj) −L(tj−1)

DF(t, tj)
(7.5.8)
In these circumstances the value of the equity TRS at time t only depends on the
current swaplet, which extends from tj−1 to tj, where tj−1 < t < tj.
Equity swap
A special case of an equity TRS is an equity swap. Here one party (say A) pays
the total returns on a given equity and receives (from party B) the returns on
another equity, together with the interest on the net difference of the last reset
notional of the two equity assets. An equity swap, ESWP, can be constructed
from a structured deal consisting of a long position in one equity TRS and a
short position in another equity TRS, with the same coupon payment dates and
currency. If the individual equity TRS deals are denoted by ETRS1
p and ETRS2
p,
then the value of the equity swap at time t is:
ESWP(t) = ETRS1
p(t) −ETRS2
p(t)
(7.5.9)
Substituting Eq. (7.5.8) into Eq. (7.5.9) we have:

240
Computational Finance Using C and C#
ESWP(t) = L1(tj−1)R(tj−1)τDF(t, tj) −

S1(t)
DF(t, tj) −L1(tj−1)

DF(t, tj)
−

L2(tj−1)R(tj−1)τDF(t, tj)
−

S2(t)
DF(t, tj) −L2(tj−1)

DF(t, tj)

so the value of the equity swap to party A is:
ESWP(t) = −

S1(t)
DF(t, tj) −L1(tj−1)

DF(t, tj)
equity 1 returns paid by A
+

L1(tj−1) −L2(tj−1)

R(tj−1)τDF(t, tj)
interest on difference of reset notionals paid by B
+

S2(t)
DF(t, tj) −L2(tj−1)

DF(t, tj)
equity 2 returns paid by B
7.5.2
Equity quantos
The Black–Scholes equation can also be used to price equity quanto options
(Reiner (1992)). We have the following processes:
dSf = μsSf dt + σsSf dW P
s
dXf
d = μxXf
d dt + σxXf
d dW P
x
(7.5.10)
dBf = rf Bf dt
dBd = rdBd dt
Here Sf is the price (in foreign currency units) of the foreign stock. Bd is the
domestic money market account where money grows at the (constant) risk free
interest rate rd. Bf is the foreign money market account where money grows at
the (constant) risk free interest rate rf . Xf
d is the foreign exchange rate, that is
the value of one unit of foreign currency in units of domestic currency.
The tradables for the domestic investor are the foreign money market account
priced in domestic currency units (that is, Xf
d Bf ) and the foreign stock priced
in domestic currency units, Xf
d Sf .
We know from Eq. (4.4.30) that there is a probability measure (the risk neu-
tral measure) Q under which the relative price of domestic tradables such as
equities are martingales. Also we established that under Q the process followed
by these tradables is GBM with constant drift rd. So the process for the domestic
equity Sd is:
dSd = Sdrd dt + σSd dW Q
(7.5.11)

Other ﬁnancial derivatives
241
Similarly the process followed by the price of a foreign equity Sf under the
foreign risk neutral measure F is:
dSf = Sf rf dt + σsSf dW F
s
(7.5.12)
However, the process followed by the price of a foreign equity Sf under the
domestic risk neutal measure Q is:
dSf = Sf 
rf + α

dt + σsSf dW Q
s
(7.5.13)
where α (the quanto adjustment) is to be determined.
We will now derive the value for α, and then use this to price both quanto
forwards and quanto options.
Determining the quanto adjustment, α
Since Xf
d Bf and Xf
d Sf are domestic tradables it means that the relative prices
Xf
d Bf /Bd and Xf
d Sf /Bd are also martingales under the probability measure Q
Now since Xf
d Bf /Bd is a martingale,
d
Xf
d Bf
Bd

= σx
Xf
d Bf
Bd
dW Q
x
(7.5.14)
We will start by writing Xf
d Bf /Bd as (Sf /Bf )(Xf
d Bf /Bd). Using the Ito
product rule we have:
d
 Sf
Bf
Xf
d Bf
Bd

= Xf
d Bf
Bd
d
 Sf
Bf

+ Sf
Bf d
Xf
d Bf
Bd

+ E

d
 Sf
Bf

d
Xf
d Bf
Bd

(7.5.15)
Substituting for d(Xf
d Bf /Bd) from Eq. (7.5.14) into Eq. (7.5.15) gives:
d
 Sf
Bf
Xf
d Bf
Bd

= Xf
d Bf
Bd
d
 Sf
Bf

+ σx
Sf
Bf
Xf
d Bf
Bd
dW Q
x
+ E

d
 Sf
Bf

d
Xf
d Bd
Bf

(7.5.16)
Using the Ito quotient rule (see Section 1.7.2) with one source of randomness,
Eqs. (7.5.13) and (7.5.10) yield:
d
 Sf
Bf

= Sf
Bf α dt + Sf
Bf σs dW Q
s
(7.5.17)
We now consider the term E[d(Sf /Bf ) d(Xf
d Bf /Bd)] in Eq. (7.5.16):

242
Computational Finance Using C and C#
E

d
 Sf
Bf

d
Xf
d Bf
Bd

= E
 Sf
Bf

α dt + Sf
Bf σs dW Q
s

σx
Xf
d Bf
Bd
dW Q
x

= Xf
d Bf
Bd
Sf
Bf α dt σxE

dW Q
x

+ Sf
Bf
Xf
d Bf
Bd
σsσxE

dW Q
x dW Q
s

Since E[dW Q
x ] = 0 and E[dW Q
x dW Q
s ] = ρxs dt
E

d
 Sf
Bf

d
Xf
d Bd
Bf

= Sf
Bf
Xf
d Bf
Bd
σsσxρxs dt
(7.5.18)
Using the values of d(Sf /Bf ) and E[d(Sf /Bf ) d(Xf
d Bd/Bf )] from Eqs. (7.5.17)
and (7.5.18) in Eq. (7.5.16) results in:
d
 Sf
Bf
Xf
d Bf
Bd

= Xf
d Bf
Bd
Sf
Bf α dt + Xf
d Bf
Bd
Sf
Bf σsσx dW Q
s
+ σx
Xf
d Sf
Bd
dW Q
x + Sf
Bf
Xf
d Bf
Bd
σsσxρxs dt
Rearranging we obtain:
d
Xf
d Sf
Bd

= Xf
d Sf
Bd
{α + σsσxρxs} dt
+ Xf
d Sf
Bd

σs dW Q
s + σx dW Q
x

(7.5.19)
We already mentioned that Xf
d Bf /Bd is a martingale under probability measure
Q so the drift term in Eq. (7.5.19) must be zero. This means that:
α = −σsσxρxs
where σs is volatility of the foreign equity, σx is volatility of the foreign exchange
rate and ρxs is the correlation between dWs and dWx.
Equation (7.5.13) can then be written as:
dSf =

rf −σsσxρxs

Sf dt + σsSf dW Q
s
(7.5.20)
Equity quanto forward
The (time t) value of a domestic equity forward contract with maturity T is:
F(t) = DFd(t, T )

Sd(t, T ) −Kd
where Kd is the strike in domestic currency and Sd(t, T ) is the domestic forward
price.
To value an equity quanto forward contract we need to know the forward
price of the foreign equity Sf .

Other ﬁnancial derivatives
243
It can be seen from Eqs. (4.4.31), (4.4.32) and (7.5.20) that this forward price
is:
Sf (t, T ) = Sf (t) exp

rf −σxσsρxs

(T −t)

(7.5.21)
where Sf (t) is the current price of the foreign equity and T is the maturity of
the forward.
In an equity quanto forward the payoff is in foreign currency but it is con-
verted to domestic currency at a predetermined exchange rate (which we denote
here by X). The value equity quanto forward is thus:
QF(t) = DFd(t, T )

Sf (t, T ) −Kf 
X
where X is the prespeciﬁed exchange rate, Kf is the strike in units of foreign
currency, and Sf (t, T ) is the foreign forward equity price.
Equity quanto option
In Chapter 4 Eqs. (4.4.58) and (4.4.59) expressed the value of vanilla European
put and call options as:
Call(t) = exp

−rd(T −t)

Sd(t, T )N1(d1) −EN1(d2)

Put(t) = exp

−rd(T −t)

−Sd(t, T )N1(−d1) + EN1(−d2)

d1 = log(Sd(t, T )/Ed) + (σ 2/2)τ
σ√(T −t)
d2 = log(Sd(t, T )/Ed) −(σ 2/2)(T −t)
σ√(T −t)
where we have used superscripts to denote the domestic currency, and the cur-
rent equity forward price with maturity T is:
Sd(t, T ) = Sd(t) exp

rd(T −t)

,
t ⩽T
The value of an equity quanto option can be found by substituting Sf for Sd
in the above expression. We obtain:
QCall(t) = exp

−rd(T −t)

Sf (t, T )N1(d1) −Ef N1(d2)

X
QPut(t) = exp

−rd(T −t)

−Sf (t, T )N1(−d1) + Ef N1(−d2)

X
d1 = log(Sf (t, T )/Ef ) + (σ 2
s /2)τ
σs
√(T −t)
d2 = log(Sf (t, T )/Ef ) −(σ 2
s /2)(T −t)
σs
√(T −t)
where Ef is the strike in foreign currency units, Sf (t, T ) is the foreign equity
forward price (obtained from Eq. (7.5.21)) and X is the prespeciﬁed exchange
rate (number of units of domestic currency per foreign currency unit).

blank
left
intentionally
page
This

8 C# portfolio pricing application
8.1
Introduction
This section provides details concerning a C# application, created using Mi-
crosoft Visual Studio 2005 (version 2.0), which values the deals contained in a
set of user speciﬁed portfolios. It has been included to illustrate how the pricing
functions discussed in the previous sections of the book can be incorporated
into the kind of software that may be found in a bank, ﬁnancial institution, or
educational establishment. Here we provide code excerpts from the application;
however, additional source code is available from the publisher’s website.
The main features of this application are as follows:
• User deﬁned portfolios of deals can be valued without the need to compile
either C or C# programs. This means that the application is easy to use and is
accessible to those who may possess business or ﬁnancial knowledge, but do
not have the technical skills required to write computer code.
• This application only deals with equity, foreign exchange derivatives—the ex-
ception is the inclusion of an interest rate forward rate trade. However, the
software can be easily extended to include new deal types.
• All input/output to the application is by means of text ﬁles which can be easily
edited.
• The software is modular and consists of a main C# program which calls
both a compiled C# DealLibrary and also a compiled C Analytics_
MathLib. It should be mentioned that in many cases the C# deal class calls
the C pricing function with reasonable values for various parameters. For
example, the number of time steps in a binomial lattice is set internally and
cannot be altered by the user. Also the initial random seed for all Monte
Carlo simulation is set internally to the same number (111) and this cannot
be changed by the user.
We will now provide a brief overview of each component part of the applica-
tion; more detail will be given later when speciﬁc deal classes are described.
8.1.1
The C# code
The application is deﬁned by the C# solution PortfolioValuer.sln, and
the projects DealLibrary.csproj and PortfolioValuer.csproj.

246
Computational Finance Using C and C#
The project PortfolioValuer.csproj is the driver for the application
and contains the C# code given in Code excerpt 8.1. The user interface is simply
a windows form with a button to start the application, and if required this could
easily be customized by the reader. Once the application has been started, it ﬁrst
loads a market data ﬁle and then reads a portfolio conﬁguration ﬁle to determine
which portfolios are to be valued. Valuation then proceeds for all the deals
contained in the portfolio ﬁles and the results are written to the appropriate
portfolio results ﬁle.
The project DealLibrary.csproj is concerned with the valuation of the
available trades in the application. A separate C# deal class, derived from a
single abstract base class BaseDeal, is provided for each trade type. The
BaseDeal class provides abstract methods such as Price() and Vali-
date(), which need to be implemented in deal classes. We will be primarily
concerned with the method Price(), which is used to return the current value
of a trade. Deal valuation may either be performed completely in C# code or
by calling appropriate C routines in the Analytics_MathLib dynamic link
library—this contains C pricing functions discussed in previous sections of the
book and also utilities (such as random number generators), etc.
Code excerpt 8.2 provides the declaration of BaseDeal and illustrates how
the deal class EquityOptionDeal implements the necessary methods; the
complete C# code for a range of deals is provided later.
It can be seen that the deal class needs to specify the attributes which it will
present to the user, and in addition access market data such as the equity price.
8.1.2
The text ﬁles
The application is driven by a portfolio conﬁguration ﬁle and also a number of
portfolio deﬁnition ﬁles, each of which is in plain text format and thus can easily
be edited by the user. The portfolio conﬁguration ﬁle speciﬁes the names of the
portfolio ﬁles that are to be valued, and each portfolio deﬁnition ﬁle provides
the details of the trades contained in a given portfolio. In addition there is a
market data ﬁle (also in text format) which provides the market data required
to value the trades.
A portfolio conﬁguration ﬁle and also two portfolio deﬁnition ﬁles are given
in Exhibit 8.1. It can be seen that comments may be included in the portfolio
deﬁnition ﬁles; these are useful for documenting the deals contained in the port-
folio. It is also possible to ignore a single trade by using a // at the beginning
of a line. Complete sections of a portfolio deﬁnition ﬁle can also be ignored by
using the C style comment syntax /**/.
The syntax of each deal entry in the Portfolio Deﬁnition ﬁle is as follows:
Trade=<DealClass>,Reference=<Descriptive Text>,DealClassParam1=<Value1>, . . . ,_
DealClassParamN=<ValueN>
Each deal line must begin with an assignment to the Trade attribute using
the syntax Trade=<DealClass>, where <DealClass> is the name of the
C# class used to represent the given deal—i.e., EquityOptionDeal for an

C# portfolio pricing application
247
namespace PortfolioValuer
{
public partial class Form1 : Form
{
public Form1()
{
InitializeComponent();
}
private void button1_Click(object sender, EventArgs e)
{
StreamReader sr_config;
StreamReader sr_tests;
StreamWriter sw;
MessageBox.Show("Computing value of portfolios");
string AppDir = Path.GetDirectoryName(Application.ExecutablePath);
string config_filename = AppDir + "\\Portfolios.txt";
string MD_filename = AppDir + "\\MarketData.txt";
try {
BaseDeal.LoadMarketData(MD_filename);
// Load and execute the specified tests
sr_config = new StreamReader(config_filename);
string assembly_name = AppDir + "\\DealLibrary.dll";
Assembly Assm = Assembly.LoadFrom(assembly_name);
Type[] LoadedTypes = Assm.GetTypes();
string test_file;
int block_comment_depth = 0;
double port_val = 0.0;
string BaseCurrency = BaseDeal.GetBaseCurrency();
while ((test_file = sr_config.ReadLine()) != null)
{
sr_tests = new StreamReader(test_file + ".txt");
string current_test;
string sdate = DateTime.Now.ToString();
string results_filename = AppDir + "\\" + test_file + "results.txt";
bool append = false;
sw = new StreamWriter(results_filename, append, Encoding.ASCII);
sw.WriteLine("=============================");
sw.WriteLine(test_file + " in units of " + BaseCurrency);
sw.WriteLine(test_file +"
:" +sdate);
sw.WriteLine("=============================");
port_val = 0.0;
block_comment_depth = 0;
while ((current_test = sr_tests.ReadLine()) != null) {
block_comment_depth += ((current_test.Length > 1)_
&& (current_test.Substring(0,2) == "/*")) ? 1:0;
block_comment_depth -= ((current_test.Length > 1)_
&& (current_test.Substring(0, 2) == "*/")) ? 1 : 0;
.
.
.
try
{
deal_value = ac1.Price(); // return the value of the deal
}
catch (Exception ex)
{
sr_config.Close();
sw.Close();
sr_tests.Close();
throw new Exception(ex.Message);
}
port_val +=
deal_value; // add to the value to the portfolio
string str_deal_val = deal_value.ToString(" 0.0000;-0.0000; 0.0000");
sw.WriteLine(str_deal_val + "=" + ac1.Reference+","+ac1.Name());
}
} // end of tests for a given portfolio
Code excerpt 8.1 The main driver for the C# portfolio valuer application. After reading
the market data ﬁle, it prices the trades contained in the portfolio deﬁnition ﬁles. The
total value of each portfolio is also computed.

248
Computational Finance Using C and C#
public abstract class BaseDeal
// The declaration for BaseDeal
{
public abstract string Name();
public abstract double Price();
protected abstract void Validate();
public string Reference { get { return Reference_; } set { Reference_ = value; } }
protected string Reference_;
public string BaseCurrency {get { return MarketDataDictionaries.GetBaseCurrency(); }}
}
public class EquityOptionDeal: BaseDeal
// The declaration for EquityOptionDeal
{
public string Equity { get { return EquityName_; } set { EquityName_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
.
.
.
public override string Name()
// implement method Name()
{
return "Equity Option";
}
public override double Price()
// implement method Price()
{
Validate();
double val=0.0;
double[] greeks = new double[6];
double s0 = 0.0;
double fx_spot = 0.0;
try
{
s0 = MarketDataDictionaries.EquityTable[EquityName_].Spot;_
// get current equity price
Currency_ = MarketDataDictionaries.EquityTable[EquityName_].Currency;_
// get equity volatility (assumed constant)
DividendYield_ = MarketDataDictionaries.EquityTable[EquityName_].DivYield;_
// get equity dividend yield
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for " + EquityName_);
}
.
.
.
val *= fx_spot * NumberOfUnits_; // return value in base currency
return val;
}
protected override void Validate()
// implelement method Validate()
{
Pre_string_ = Name() + "
(" + Reference_ +")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
.
.
.
}
Code excerpt 8.2 C# code showing the declaration of class BaseDeal and illustrating the
implementation of methods Price(), Validate(), and Name().

C# portfolio pricing application
249
// write the portfolio value
sw.WriteLine("========================");
string str_port_val = port_val.ToString(" 0.00;-0.00; 0.00");
sw.WriteLine("TOTAL VALUE = " + str_port_val + " " + BaseCurrency + "
");
sw.WriteLine("=========================");
sw.Close();
sr_tests.Close();
}
MessageBox.Show("Have completed computing portfolio values");
sr_config.Close();
// Clear the dictionaries
BaseDeal.CurrencyTable.Clear();
BaseDeal.EquityTable.Clear();
BaseDeal.BondTable.Clear();
BaseDeal.CorrelationTable.Clear();
}
}
catch (Exception ex)
{
MessageBox.Show("Computation aborted : exception : " + ex.Message);
}
}
}
Code excerpt 8.2 (Continued).
equity option. The other deal attributes are the public properties of Deal-
Class and can be in any order. Deal valuation proceeds by ﬁrst construct-
ing an empty class object of type DealClass. The application then con-
verts the string representation of the deal attribute values to the types ex-
pected by the DealClass, and assignment to the deal object occurs. Once
the deal object has been populated with the required trade data, the deal’s
Price() method is run. This retrieves the required market data, computes
the deal value, and returns this to the application for output to the portfolio
results ﬁle. All deals have the Reference attribute which is used for the pur-
poses of identiﬁcation. The deal reference is a description (or alphanumeric
code) assigned to the trade, for instance Reference=EQ:LaserComm-1001
or Reference=Tech-10008_Generic. The portfolio results ﬁles contain
both the value and reference for each deal which has been valued.
The portfolio driver ﬁle
EQ-Investments
Broad-Investments
Portfolio deﬁnition ﬁle: EQ-investments
// EQ-Investments : Only contains equities
//=========================================
Trade=EquityOptionDeal,Reference=EQ:LaserComm-1001,Equity=LaserComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.5,OptionType=Put,ExerciseStyle=European
Trade=EquityOptionDeal,Reference=EQ:WebComm-1004A,Equity=WebComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.0,OptionType=Call,ExerciseStyle=European
Trade=EquityOptionDeal,Reference=EQ:LaserComm-1004,Equity=LaserComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.0,OptionType=Call,ExerciseStyle=American

250
Computational Finance Using C and C#
Trade=TwoEquityOptionDeal,Reference=EQ:CompuKalc-1005,Equity1=Mobile-Tech,_
Equity2=CompuKalc,Volatility1=0.2,Volatility2=0.2,RiskFreeRate=0.1,Strike=44.0,_
Time_To_Expiry=0.8,OptionType=Call,MinMax=Minimum,ExerciseStyle=European
Trade=TwoEquityOptionDeal,Reference=EQ:MobileTech|CompuKalc-1006,Equity1=Mobile-Tech,_
Equity2=CompuKalc,Volatility1=0.2,Volatility2=0.2,RiskFreeRate=0.1,Strike=94.0,_
Time_To_Expiry=0.8,OptionType=Call,MinMax=Maximum,ExerciseStyle=European
Trade=ThreeEquityOptionDeal,Reference=Tech-10001,Equity1=LaserComm,Equity2=TelComm,_
Equity3=SmartWeb,Volatility1=0.2,Volatility2=0.2,Volatility3=0.2,NumberOfUnits=100,_
Strike=100.0,Time_To_Expiry=1.0,OptionType=Put,MinMax=Maximum,MonteCarlo=No
Trade=GenericEquityBasketOptionDeal,Reference=Tech-10008_Generic,Volatilities=0.2%0.2%0.2,_
Equities=LaserComm%TelComm%SmartWeb,NumberOfUnits=100,_
Strike=100.0,Time_To_Expiry=1.0,OptionType=Call,MinMax=Maximum,MonteCarlo=Yes
Trade=FourEquityOptionDeal,Reference=Drinks-20001,Equity1=Drinks-4U,Equity2=Beverage-Ltd,_
Equity3=H2O-Ltd,Equity4=Fine-Wines-Ltd,Volatility1=0.2,Volatility2=0.2,Volatility3=0.2,_
Volatility4=0.2,NumberOfUnits=100,Strike=100.0,_
Time_To_Expiry=1.0,OptionType=Call,MinMax=Maximum,MonteCarlo=No
Trade=DownOutEquityOptionDeal,Reference=JPCA_111,Equity=H2O-Ltd,Volatility=0.2,Strike=100.0,_
Time_To_Expiry=1.0,Barrier_Level=90.0,OptionType=Call
Trade=DoubleKnockOutCallEquityOptionDeal,Reference=JPCAPP_115,Equity=LaserComm,Volatility=0.2,
Strike=100.0,Time_To_Expiry=1.0,Lower_Barrier_Level=90.0,Upper_Barrier_Level=340.0
Portfolio deﬁnition ﬁle: broad-investments
In the C derivative pricing functions developed in the earlier part of this book,
all the deal information such as asset price, risk free interest rate, etc. was passed
explicitly to the pricing function.
For instance, let us consider the pricing of the simple
EquityOption,
Reference=EQ:WebComm-1004A, which is speciﬁed in Exhibit 8.1. The en-
try (which we will refer to as E1 in the portfolio deﬁnition ﬁle EQ-investments)
is:
Trade=EquityOptionDeal,Reference=EQ:WebComm-1004A,Equity=WebComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.0,OptionType=Call,ExerciseStyle=European
The reason for the inclusion of the Volatility attribute will be discussed
later.
If we explicitly passed all the information required by the underlying C func-
tion black_scholes then the form of the required entry (referred to here as
E2) would be:
Trade=EquityOptionDeal,Reference=EQ:WebComm-1004A,Equity=WebComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.5,OptionType=Put,ExerciseStyle=European,EquitySpot=100,_
FXEquityCurrency=0.5565,RiskFreeRate=0.1,DividendYield=0.05
The reason that E1 does not require the extra four deal attributes
EquitySpot=100,FXEquityCurrency=0.5565,RiskFreeRate=0.1,
DividendYield=0.05 is that these are stored in a market data dictionar-
ies object and are accessed by the C# class EquityOptionDeal before the C
function black_scholes is called.
The market data dictionaries are populated as soon as the application starts.
Exhibit 8.2 shows an example market data ﬁle. This is a plain text ﬁle, and pro-
vides a common repository for the market parameters that are required by the

C# portfolio pricing application
251
// Broad-Investments : Contains equity, FX and IR products
//=========================================================
// Example FX deal Foreign currency = GBP Domestic Currency = USD, Strike = 1.5,
Settlement = 4.0 years
// Note: The Strike is the number of units of domestic currency that have been agreed to be
paid for one unit
// of foreign currency.
Trade=FXForwardDeal,Reference=FX-5001,ForeignAmount=100,Strike=1.5,ForeignCurrency=GBP,_
DomesticCurrency=USD,Settlement=4.0,BuySell=Buy
Trade=ForwardRateAgreementDeal,Reference=IR-6001,Principal=100.0,Strike=3.0,Currency=GBP,_
Maturity=4.5,Start=4.0,BuySell=Buy
//Trade=FXOptionDeal,Reference=FXOption_Call,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,_
Time_To_Expiry=5.0,ExerciseStyle=European,OptionType=Call,BuySell=Buy
Trade=DownOutEquityOptionDeal,Reference=Tech-7001,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,OptionType=Call,CalcMethod=Analytic
/*
Trade=DownOutEquityOptionDeal,Reference=Tech-7002,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=MonteCarlo,OptionType=Call,_
NumberScenarios=10000,UseBrownianBridge=true
Trade=DownOutEquityOptionDeal,Reference=Tech-7005,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=Analytic,OptionType=Call
*/
Trade=DownOutEquityOptionDeal,Reference=Tech-7006,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=Numeric,OptionType=Call
Trade=DownOutEquityOptionDeal,Reference=Tech-7007,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=Numeric,OptionType=Call,_
ExerciseStyle=American
//Trade=DownOutEquityOptionDeal,Reference=JPCA_BB_False,Equity=Real-Computers,Strike=100.0,_
Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=MonteCarlo,OptionType=Call,_
NumberScenarios=10000,UseBrownianBridge=false
Trade=DownOutFXOptionDeal,Reference=FX-5004,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,ExerciseStyle=European,_
OptionType=Call,BuySell=Buy,CalcMethod=Analytic,Barrier_Level=0.01
Trade=DownOutFXOptionDeal,Reference=FX-5006,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,ExerciseStyle=European,_
OptionType=Call,BuySell=Buy,CalcMethod=MonteCarlo,UseBrownianBridge=true,Barrier_Level=0.01
// American FX Barrier Call
Trade=DownOutFXOptionDeal,Reference=FX-5007,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,OptionType=Call,BuySell=Buy,_
CalcMethod=Numeric,Barrier_Level=0.01,ExerciseStyle=American
// European Put
Trade=FXOptionDeal,Reference=FX-5008,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,ExerciseStyle=European,_
OptionType=Put,BuySell=Buy
Trade=DownOutFXOptionDeal,Reference=FX-5009,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,OptionType=Put,BuySell=Buy,_
CalcMethod=MonteCarlo,Barrier_Level=0.01,ExerciseStyle=European
Exhibit 8.1 Here we show an example portfolio driver ﬁle and the individual portfolio
deﬁnition ﬁles EQ-Investments.txt and Broad-Investments.txt. The symbol
_ is used to indicate a line continuation; it should be noted the C# application requires
each deal to be speciﬁed on a single line.
deal classes. For instance, all foreign exchange derivatives will need access to the
current FX rates, and all equity derivatives will require the current equity price.
The contents of the market data ﬁle can be updated as frequently as required

252
Computational Finance Using C and C#
// Currency market data. This is used for pricing interest rate swaps, FX options, etc...
Currency.USD,FXSpot=0.5565,YieldCurve=[(0.0027,0.0184),...,(40.58,0.0533)],
VolCurve=[(0.0,0.10),(1.0,0.12),(3.0,0.13),(6.0,0.14),(20,0.15)]
Currency.GBP<<--Base,FXSpot=1.0,YieldCurve=[(0.0027,0.047),...,(50.03,0.042)],
VolCurve=[(0.0,0.10),(1.0,0.12),(3.0,0.13),(6.0,0.14),(20,0.15)]
Currency.EUR,FXSpot=0.689024,YieldCurve=[(0.0,0.04),...,(20,0.056)],
VolCurve=[(0.0,0.10),(1.0,0.12),(3.0,0.13),(6.0,0.14),(20,0.15)]
Currency.CAD,FXSpot=1.5,YieldCurve=[(0.0,0.04),...,(20,0.056)],
VolCurve=[(0.0,0.10),(1.0,0.12),(3.0,0.13),(6.0,0.14),(20,0.15)]
// Equity market data. This is used for pricing equity options, etc...
Equity.Imperial-Art,Currency=GBP,Spot=9.0,DivYield=0.03
Equity.Real-Computers,Currency=USD,Spot=200.0,DivYield=0.04
Equity.TelComm,Currency=GBP,Spot=120.0,DivYield=0.09
Equity.WebComm,Currency=USD,Spot=100.0,DivYield=0.07
Equity.Hackers,Currency=GBP,Spot=40.0,DivYield=0.02
Equity.LaserComm,Currency=GBP,Spot=95.0,DivYield=0.05
Equity.SmartWeb,Currency=GBP,Spot=100.0,DivYield=0.01
Equity.Web-Comm,Currency=GBP,Spot=100.0,DivYield=0.04
Equity.Mobile-Tech,Currency=GBP,Spot=92.0,DivYield=0.02
Equity.CompuKalc,Currency=GBP,Spot=95.0,DivYield=0.11
Equity.The-Bookshop,Currency=GBP,Spot=100.0,DivYield=0.02
Equity.Everyman-Books,Currency=GBP,Spot=100.0,DivYield=0.03
Equity.The-RealBook-Company,Currency=GBP,Spot=100.0,DivYield=0.04
Equity.Drinks-4U,Currency=GBP,Spot=100.0,DivYield=0.05
Equity.Beverage-Ltd,Currency=GBP,Spot=100.0,DivYield=0.06
Equity.H2O-Ltd,Currency=GBP,Spot=100.0,DivYield=0.05
Equity.Fine-Wines-Ltd,Currency=GBP,Spot=100.0,DivYield=0.03
Equity.French-Wines-Ltd,Currency=EUR,Spot=100.0,DivYield=0.2
Equity.The-English-Beer-Company,Currency=GBP,Spot=100.0,DivYield=0.03
Equity.Water-Works-Ltd,Currency=GBP,Spot=100.0,DivYield=0.012
Equity.Welsh-Spring,Currency=GBP,Spot=100.0,DivYield=0.06
Equity.ThamesBeer,Currency=GBP,Spot=100.0,DivYield=0.05
Equity.Edingburgh-Whiskey,Currency=GBP,Spot=100.0,DivYield=0.04
Equity.The-Wine-Box,Currency=GBP,Spot=100.0,DivYield=0.085
// Bond market data. This is used for pricing bonds, and credit derivatives such as CDS, and
TRS
Bond.Fine-Wines-Ltd-Bond-2020,Currency=GBP,Spot=150.0,
SurvivalProb=[(0.0,1.0),(1.0,0.9),(3.0,0.96),(6.0,0.9),(20,0.5)]
Bond.Hackers-Bond-2018,Currency=GBP,Spot=200.0,
SurvivalProb=[(0.0,1.0),(2.0,0.91),(5.0,0.9),(8.0,0.8),(30,0.6)]
Bond.Hackers-Bond-2060,Currency=GBP,Spot=260.0,
SurvivalProb=[(0.0,1.0),(1.0,0.92),(20.0,0.8),(20.0,0.65),(60,0.7)]
Bond.Real-Computers-Bond-2020,Currency=USD,Spot=100.0,
SurvivalProb=[(0.0,1.0),(1.0,0.94),(4.0,0.9),(8.0,0.6),(30,0.5)]
// Market data correlation. These are used for multiasset options
Correlation.Imperial-Art,Real-Computers=0.5
Correlation.Real-Computers,WebComm=0.4
Correlation.Real-Computers,Hackers=0.5
Correlation.Real-Computers,LaserComm=0.3
Correlation.Real-Computers,SmartWeb=0.4
Correlation.TelComm,Hackers=0.5
Correlation.TelComm,LaserComm=0.5
Correlation.TelComm,SmartWeb=0.5
Correlation.TelComm,Web-Comm=0.5
Correlation.LaserComm,SmartWeb=0.5
Correlation.Hackers,Mobile-Tech=0.4
Correlation.LaserComm,Mobile-Tech=0.4
Correlation.SmartWeb,Mobile-Tech=0.5
Correlation.Web-Comm,Mobile-Tech=0.5
Exhibit 8.2 An example market data ﬁle, which is used to specify the current market
values such as equity spot, FX spot, interest rate yield curves, etc. The third line in
the ﬁle provides currency information for GBP, and the entry Currency.GBP«--Base
speciﬁes that the base currency will be GBP, and thus all portfolio and deal values will be
computed in GBP.

C# portfolio pricing application
253
Correlation.Mobile-Tech,The-Bookshop=0.1
Correlation.CompuKalc,LaserComm=0.3
Correlation.ThamesBeer,French-Wines-Ltd=0.3
Correlation.ThamesBeer,Fine-Wines-Ltd=0.5
Correlation.ThamesBeer,H2O-Ltd=0.5
Correlation.ThamesBeer,Beverage-Ltd=0.6
Correlation.ThamesBeer,Drinks-4U=0.6
Correlation.ThamesBeer,The-RealBook-Company=0.8
Correlation.ThamesBeer,People-Books=0.1
.
.
.
Correlation.Edingburgh-Whiskey,French-Wines-Ltd=0.5
Correlation.Edingburgh-Whiskey,Water-Works-Ltd=0.5
Correlation.Edingburgh-Whiskey,The-English-Beer-Company=0.6
Exhibit 8.2 (Continued).
(i.e., daily, hourly, etc.) but will always maintain a set of market values that can
be used consistently across all deal valuations.
It should be mentioned that the main advantage of type E1 deal entries is
not just that the portfolio deﬁnition ﬁle is smaller—it also ensures that consis-
tent market data values are used to price all the trades in the portfolio. When
type E2 deal entries are used, it is necessary to ensure that all the extra deal
attributes are updated as new market data becomes available. This would be
a time-consuming task and, if only a partial update occurs, could give rise to
invalid deal valuations caused by inconsistent deal attribute values such as FX-
EquityCurrency, DividendYield.
The format of the result ﬁles is shown in Exhibit 8.3. The output syntax is
simply:
<deal value>=<deal reference>,<deal type>
It can be seen that each deal is valued in base currency (which here is speciﬁed
in the market data ﬁle as GBP) and the total value for the portfolio is also
reported.
Results ﬁle for portfolio EQ-investments
=============================
EQ-Investments in units of GBP
EQ-Investments
:14/07/2007 00:00:00
=============================
4.3501=EQ:LaserComm-1001,Equity Option
2.9278=EQ:LaserComm-1002,Equity Option
3.5716=EQ:LaserComm-1003,Equity Option
2.0245=EQ:LaserComm-1004,Equity Option
2.2171=EQ:WebComm-1004A,Equity Option
41.7119=EQ:CompuKalc-1005,Rainbow option(two equities)
14.0274=EQ:MobileTech|CompuKalc-1006,Rainbow option(two equities)
8.8511=EQ:MobileTech|CompuKalc-1007,Rainbow option(two equities)
70.3151=EQ:MobileTech|TelComm-1008,Rainbow option(two equities)
13.3263=JPCAM11,Rainbow option(two equities)
6.5840=JPCAM111,Rainbow option(two equities)
72.7866=Tech-10001,Three Equity Option
70.1046=Tech-10002,Three Equity Option
69.7412=Tech-10003,Three Equity Option
1010.6123=Tech-10004,Three Equity Option
1030.3894=Tech-10005,Three Equity Option
2850.8918=Tech-10006,Three Equity Option

254
Computational Finance Using C and C#
2838.9643=Tech-10007,Three Equity Option
2838.9643=Tech-10008_Generic,Generic Equity Option
399.4981=Tech-10009,Three Equity Option
409.1153=Tech-10010,Three Equity Option
2646.6473=Drinks-20001,Four Equity Option
2644.3642=Drinks-20002,Four Equity Option
15.3381=Drinks-20003,Four Equity Option
21.8691=Drinks-20004,Four Equity Option
53.8106=Drinks-20005,Four Equity Option
63.2889=Drinks-20006,Four Equity Option
1511.6543=Drinks-20007,Four Equity Option
1524.5000=Drinks-20008,Four Equity Option
1510.7045=Drinks-20009,Four Equity Option
1518.8670=Drinks-20010,Four Equity Option
1513.7578=Drinks-20011,Four Equity Option
1524.5000=Drinks-20012,Generic Equity Option
1513.7578=Drinks-20013,Four Equity Option
2030.2451=Drinks-20013,Generic Equity Option
6.1238=JPCA_111,Down Out Equity Option
6.1240=JPCA_111A,Down Out Equity Option
3.0006=JPCA_112,Down Out Equity Option
3.0006=JPCA_113,Down Out Equity Option
3.0006=JPCA_114,Down Out Equity Option
3.0036=JPCAPP_115,Double Knock Out Call Equity Option
========================
TOTAL VALUE =
29878.53 GBP
=========================
Results ﬁle for portfolio broad-investments
=============================
Broad-Investments in units of GBP
Broad-Investments
:14/07/2007 00:00:00
=============================
9.4359=FX-5001,FX Forward
-9.4359=FX-5002,FX Forward
0.8661=IR-6001,Forward Rate Agreement
1.1755=IR-6002,Forward Rate Agreement
52.6353=Tech-7001,Down Out Equity Option
52.6757=Tech-7002,Down Out Equity Option
52.6757=Tech-7003,Down Out Equity Option
52.6583=Tech-7004,Down Out Equity Option
52.6353=Tech-7005,Down Out Equity Option
52.6358=Tech-7006,Down Out Equity Option
55.6500=Tech-7007,Down Out Equity Option
11.6849=FX-5003,FX Option
11.6849=FX-5004,Down Out FX Option
11.6813=FX-5005,Down Out FX Option
11.5356=FX-5006,Down Out FX Option
11.9998=FX-5007,Down Out FX Option
2.9173=FX-5008,FX Option
2.9827=FX-5009,Down Out FX Option
========================
TOTAL VALUE =
438.09 GBP
=========================
Exhibit 8.3 Portfolio results ﬁles. The reporting currency is set in the market data ﬁle; in
this example, all values are given in pounds sterling.
8.2
Storing and retrieving the market data
As mentioned before, the market data required to price derivatives is stored
in market data dictionaries. The MarketDataDictionaries class, shown in

C# portfolio pricing application
255
Code excerpt 8.4, contains a set of C# Dictionary member items which hold all
the market data required by the deal classes. Below we give the declaration of
the CurrencyTable, EquityTable and CorrelationTable dictionaries:
public static Dictionary<string, Currency> CurrencyTable = new Dictionary<string,_
Currency>();
public static Dictionary<string, Equity> EquityTable = new Dictionary<string,_
Equity>();
public static Dictionary<string, Correlation> CorrelationTable = new Dictionary<string,_
Correlation>();
Each dictionary entry is made up of a {<unique-key>, <value-object>}
pair, where unique-key is a unique string, and value-object is a class
containing the corresponding market data. We will now consider each of the
above dictionaries and the information they hold in more detail.
8.2.1
CurrencyTable
In a CurrencyTable dictionary value-object is a class of type Currency
and is used to store currency information. The class declaration is provided in
Code excerpt 8.3.
public class TPair : IComparable
{
public double t;
public double val;
public TPair(double t1, double val1)
{
t = t1;
val = val1;
}
int IComparable.CompareTo(object obj)
{
TPair temp = (TPair)obj;
if (this.t > temp.t)
return (1);
if (this.t < temp.t)
return (-1);
else
return (0);
}
}
// ICurve - a curve for storing interest rates
public class ICurve: List<TPair>
{
private double t_pt;
// internal value used for matching
private string name_ = "";
public ICurve (string name) {
name_ = name;
}
public double this[double t_0, double t]
{ get { // return the discount factor between t and t1
double eps = 1.0e-6;
double val;
Code excerpt 8.3 Code showing the class Currency and also the classes ICurve and
TPair which all enable the interest rate yield curve to be stored.

256
Computational Finance Using C and C#
t_pt = t;
// find the bounding indicies corresponding to a given t value
int indx1 = this.FindIndex(TPairFind);
if (indx1 == -1)
throw new Exception("Invalid market data interest rate yield curve for currency "
+ name_);
double v2 = this[indx1].val;
double v1 = this[indx1 - 1].val;
double t2 = this[indx1].t;
double t1 = this[indx1 - 1].t;
if (Math.Abs(t2 - t) < eps)
{
val = v2;
}
else
{ // use linear interpolation to compute the value of DF
val = v1 + ((v2 - v1) / (t2 - t1)) * (t - t1);
}
val = Math.Exp(-val * t);
return val;
}
}
public double this[double t, double t1, double t2] {
get {
// return the forward rate between t1 and t2
// t2 >= t1
double DF1 = this[t, t1];
double DF2 = this[t, t2];
double fwd = (DF1 / DF2 - 1.0) / (t2 - t1);
return fwd;
}
}
private bool TPairFind(TPair v)
{
if ((v.t >= t_pt))
{
return true;
}
else
{
return false;
}
}
}
public class Currency
{
public string name;
// the name of the currency (e.g GBP, or USD)
public double spot;
// the FX spot of the currency with respect to base
currency
public ICurve YieldCurve;
// the currency yield curve
public VCurve VolCurve;
// the volatility of the yield curve (not currently used
by the C# application)
public Currency(string name1, double spot1) // two parameter constructor
{
name = name1;
spot = spot1;
YieldCurve = new ICurve(name1);
}
public Currency(string name1) // single parameter constructor
{
YieldCurve = new ICurve(name1);
VolCurve = new VCurve(name1);
}
}
Code excerpt 8.3 (Continued).

C# portfolio pricing application
257
string CcyCode = "USD"; // set the unique currency code to USD
// create a new (empty) entry in the CurrencyTable for USD
CurrencyTable.Add(CcyCode, new Currency(CcyCode));
double FXSpot = 0.5565; // set the USD to base currency FX spot
// assign to public data member spot, in class Currency
CurrencyTable[CcyCode].spot = FXSpot;
// assign to public data member name, in class Currency
CurrencyTable[CcyCode].name = CcyCode;
double t;
double rt;
t= 0.0027;
// time - for point 1
rt = 0.0184;
// rate - for point 1
// add the first point to the public data member YieldCurve, in class Currency
CurrencyTable[CcyCode].YieldCurve.Add(new TPair(t, rt));
.
.
.
t = 40.58;
rt = 0.0533;
CurrencyTable[CcyCode].YieldCurve.Add(new TPair(t, rt));
Code excerpt 8.4 C# code showing the addition of USD currency market data to the
CurrencyTable dictionary.
It is straightforward to add currency data to CurrencyTable. The C# code
fragment shown in Excerpt 8.4 illustrates the addition of USD information.
The information in the CurrencyTable is accessed by the deal classes and
used to compute discount factors, forward rates and FX spots. In the market
data ﬁle (see Exhibit 8.2) the YieldCurve consists of a set of time/value pairs
and is deﬁned using the following syntax:
YieldCurve = [(t1, r1), . . . , (ti, ri), . . . , (tn, rn)], where ti is the time in years,
and ri is the corresponding zero coupon rate with tenor ti.
The value, at t = 0, of a zero coupon bond with unit cash ﬂow at maturity, ti,
is exp(−ri ti), and is known as the discount factor DF(0, ti). Code excerpt 8.4
shows the addition of two data items to the USD yield curve, while Code ex-
cerpt 8.5 illustrates the retrieval from DF(0, ti) of ri. The code fragment:
double discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate = -Math.Log(discount_fac) / Time_To_Expiry_;
computes the zero coupon rate RiskFreeRate and this can be used as a
value for the risk free rate required by the option pricing routines in Analyt-
ics_MathLib.dll. It should be mentioned that it would have been more efﬁ-
cient to have written code to directly obtain the interpolated risk free rate from
the USD yield curve (without ﬁrst computing the associated discount factor).
However, the required code can easily be supplied by the reader.
Discount factors and forward rates are accessed from an ICurve object. The
discount factor is obtained as follows:
ICurve DF = MarketDataDictionaries.
CurrencyTable[Currency_].YieldCurve;

258
Computational Finance Using C and C#
try
{
string Currency_ = "USD";
// DF
will be used to access discount factors
ICurve DF =
MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// FWD will be used to access forward rates
ICurve FWD =
MarketDataDictionaries.CurrencyTable[BaseCurrency].YieldCurve;
// obtain the discount factor DF(0,1) using methods in class ICurve
double discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate = -Math.Log(discount_fac) / Time_To_Expiry_;
double Time_To_Expiry_ = 1.0;
double FXspot =
// obtain the FX spot with repect the base currency (GBP)
MarketDataDictionaries.CurrencyTable[Currency_].spot;
double t1 = 1.0;;
double t2 = 1.5;
// obtain the forward rate F(0,1,1.5) using methods in class ICurve
double forward_rate = FWD[0, t1, t2];
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for " + Currency_);
}
Code excerpt 8.5 Code showing the retrieval of USD currency market data from the
CurrencyTable dictionary.
public class Equity
{
public string Name;
public double Spot;
public string Currency;
public double DivYield;
public Equity(string Name1, double Spot1, string Currency1, double DivYield1)
{
Name = Name1;
Spot = Spot1;
Currency = Currency1;
DivYield = DivYield1;
}
public Equity()
{
}
}
public class Correlation
{
public string Name1;
public string Name2;
public double Correl;
public Correlation(string Name11, string Name12, double Correl1)
{
Name1 = Name11;
Name2 = Name12;
Correl = Correl1;
}
public Correlation()
{
}
}
Code excerpt 8.6 The equity and correlation classes.

C# portfolio pricing application
259
declares the ICurve object DF. Then the discount factor between 0 and
Time_To_Expiry_ is computed with the statement:
double discount_fac = DF[0, Time_To_Expiry_];
where DF[0, Time_To_Expiry_] calls the ICurve accessor (declared as
public double this[double t_0, double t]) with t_0 = 0 and t
= Time_To_Expiry. It can be seen from Code excerpt 8.3 that linear inter-
polation is performed by the accessor if required.
The forward rate is obtained in a similar manner:
ICurve FWD = MarketDataDictionaries.
CurrencyTable[Currency_].YieldCurve;
declares the ICurve object FWD. Then the forward rate F(0, t1, t2) is returned
with the statement:
double forward_rate = FWD[0, 0.5, 1.5];
where FWD[0, t1, t2] calls the ICurve accessor (declared as public
double this[double t, double t1, double t2])
with
t = 0,
t1=0.5, and t2 = 1.5. It can be seen from Code excerpt 8.3 that the ac-
cessor computes the forward rate as:
FWD[0,t1,t2] = (DF[0,t1] / DF[0,t2] - 1.0)
/ (t2 - t1);
EquityTable and CorrelationTable
Code excerpt 8.7 shows how market data is added to the internal dictionaries
of the MarketDataDictionaries class. For instance, to add a correlation
public class MarketDataDictionaries
{
public static Dictionary<string, Currency> CurrencyTable = new Dictionary<string,
Currency>();
public static Dictionary<string, Equity> EquityTable = new Dictionary<string,
Equity>();
public static Dictionary<string, Correlation> CorrelationTable = new Dictionary<string,
Correlation>();
protected static string BaseCurrency_ = "";
public static string GetBaseCurrency()
{
return BaseCurrency_;
}
public static void LoadMarketData(string marketdata_file)
{
// Load the market data file and assign values to dictionaries
StreamReader MDFILE = new StreamReader(marketdata_file);
string cur_line = "";
while ((cur_line = MDFILE.ReadLine()) != null)
// loop through the market data
file
Code excerpt 8.7 The MarketDataDictionaries class, illustrating how market data
is added to the internal dictionaries.

260
Computational Finance Using C and C#
{
if ((cur_line.Length > 1) && ((cur_line.Substring(0, 2) != "//")))
{
char[] seps = new char[] { ’=’, ’,’ };
string[] v = cur_line.Split(seps, StringSplitOptions.None);
int num_elems = v.GetUpperBound(0);
int k = 0;
double t_, val_;
bool stop;
double FXSpot = 0.0;
if (v[0].Substring(0, 8) == "Currency") // currency data
{
string CcyCode = v[0].Substring(9, 3);
if (v[0].IndexOf("<<--Base") != -1) BaseCurrency_ = CcyCode;
k += 2;
if (!CurrencyTable.ContainsKey(CcyCode))
{
CurrencyTable.Add(CcyCode, new Currency(CcyCode));
}
else
{
throw new Exception("Spot & interest rate market data already
supplied for " + CcyCode);
}
FXSpot = (double)Convert.ChangeType(v[k], typeof(double));
CurrencyTable[CcyCode].spot = FXSpot;
CurrencyTable[CcyCode].name = CcyCode;
k += 2;
t_ = (double)Convert.ChangeType(v[k].Substring(2, v[k].Length - 2),
typeof(double));
k += 1;
val_ = (double)Convert.ChangeType(v[k].Substring(0, v[k].Length - 1),
typeof(double));
CurrencyTable[CcyCode].YieldCurve.Add(new TPair(t_, val_));
k += 1;
int vv = v[k].IndexOf(")]");
stop = false;
while (!stop) // Add the yield curve data
{
t_ = (double)Convert.ChangeType(v[k].Substring(1, v[k].Length - 1),
typeof(double));
k += 1;
if (v[k].IndexOf(")]") == -1)
{
val_ = (double)Convert.ChangeType(v[k].Substring(0, v[k].
Length - 1),typeof(double));
}
else
{
val_ = (double)Convert.ChangeType(v[k].Substring(0, v[k].
Length - 2), typeof(double));
stop = true;
}
k += 1;
CurrencyTable[CcyCode].YieldCurve.Add(new TPair(t_, val_));
}
CurrencyTable[CcyCode].YieldCurve.Sort();
.
.
.
}
else if (v[0].Substring(0, 6) == "Equity") // equity data
{
int idx = v[k].IndexOf(".");
string EquityName = v[0].Substring(idx + 1, v[0].Length - idx - 1);
k += 2;
string CcyCode = v[k];
Code excerpt 8.7 (Continued).

C# portfolio pricing application
261
k += +2;
double spot = (double)Convert.ChangeType(v[k], typeof(double));
k += +2;
double div = (double)Convert.ChangeType(v[k], typeof(double));
if (!EquityTable.ContainsKey(EquityName))
{
EquityTable.Add(EquityName, new Equity());
EquityTable[EquityName].Currency = CcyCode;
EquityTable[EquityName].Name = EquityName;
EquityTable[EquityName].Spot = spot;
EquityTable[EquityName].DivYield = div;
}
else
{
throw new Exception("Spot & currency market data already supplied
for " + EquityName);
}
}
.
.
.
else if (v[0].Length >= 12 && v[0].Substring(0, 11) == "Correlation")
// correlation data
{
int idx = v[0].IndexOf(".");
string AssetName1 = v[0].Substring(idx + 1, v[0].Length - idx - 1);
k += 1;
string AssetName2 = v[k];
k += 1;
double corr = (double)Convert.ChangeType(v[k], typeof(double));
string CorrelationKey = AssetName1 + "%" + AssetName2;
if(!CorrelationTable.ContainsKey(CorrelationKey))
{
// ie The-Wine-Box%Water-Works-Ltd and The-Wine-Box%Water-Works-Ltd
CorrelationTable.Add(CorrelationKey, new Correlation());
CorrelationTable[CorrelationKey].Correl = corr;
CorrelationTable[CorrelationKey].Name1 = AssetName1;
CorrelationTable[CorrelationKey].Name2 = AssetName2;
CorrelationKey = AssetName2 + "%" + AssetName1;
CorrelationTable.Add(CorrelationKey, new Correlation());
CorrelationTable[CorrelationKey].Correl = corr;
CorrelationTable[CorrelationKey].Name1 = AssetName2;
CorrelationTable[CorrelationKey].Name2 = AssetName1;
}
else
{
throw new Exception("market data already supplied for "
+ CorrelationKey);
}
}
}
}
MDFILE.Close();
}
}
Code excerpt 8.7 (Continued).
entry it is ﬁrst necessary to construct the dictionary key, and then determine
whether or not the entry already exists in the dictionary. This is shown in the
code fragment below:
// first construct the unique key string from AssetName1 and AssetName2
string CorrelationKey = AssetName1 + "%" + AssetName2;
// Now check whether this key already exists in the dictionary CorrelationTable.
// If it doesn’t then add a new entry, if it does then raise an exception
if(!CorrelationTable.ContainsKey(CorrelationKey))

262
Computational Finance Using C and C#
{
// Create a new empty dictionary entry for the unique key
CorrelationTable.Add(CorrelationKey, new Correlation());
// Now fill out the entry by assigning the correlation and the asset names
CorrelationTable[CorrelationKey].Correl = corr;
CorrelationTable[CorrelationKey].Name1 = AssetName1;
CorrelationTable[CorrelationKey].Name2 = AssetName2;
// Create another empty dictionary entry with the asset names in reverse order
// (because correlation(a,b) = correlation(b,a)
CorrelationKey = AssetName2 + "%" + AssetName1;
// Now fill out the entry by assigning the correlation and the asset names
CorrelationTable.Add(CorrelationKey, new Correlation());
CorrelationTable[CorrelationKey].Correl = corr;
CorrelationTable[CorrelationKey].Name1 = AssetName2;
CorrelationTable[CorrelationKey].Name2 = AssetName1;
}
else
{
throw new Exception("market data already supplied for " + CorrelationKey);
}
8.3
The PricingUtils class and the
Analytics_MathLib
It has already been mentioned that the deal classes often make calls to the C
pricing function that are contained in Analytics_MathLib.dll. To do this
it is necessary to provide a C# declaration for the corresponding C function.
This is carried out in the PricingUtils class by declaring the routines as ex-
tern and using the C# DllImport attribute, which is deﬁned in the namespace
System.Runtime.InteropServices. Code excerpt 8.8 provides a sample
of the C# declarations in PricingUtils and some of the corresponding C dec-
using System;
using System.Collections.Generic;
using System.Collections;
using System.IO;
using System.Text;
using System.Runtime.InteropServices;
public class PricingUtils
{
public static double EPS = 1.0e-6;
[DllImport("Analytics_MathLib.dll")]
public static extern void dko_call(double lower_barrier, double upper_barrier,
double theta_m, double S0, ref double sigma_array, ref double sigma_times,
int n_sigma, double r, double opt_mat, double X, int is_american, ref double
option_value,
IntPtr greeks, double q, int ns_below_S0, int ns_above_S0, int nt, ref int iflag);
[DllImport("Analytics_MathLib.dll", EntryPoint = "black_scholes")]
public static extern void black_scholes2(ref double value, ref double greeks, double s0,
double x, double sigma,
double t, double r, double q, int put, ref int iflag);
Code excerpt 8.8 The PricingUtils class, which permits C# code to call the C func-
tions that reside in Analytics_Mathlib.dll. The attribute DllImport (deﬁned in
namespace System.Runtime.InteropServices) indicates to C# Interop services
that unmanaged code is being called.

C# portfolio pricing application
263
[DllImport("Analytics_MathLib.dll", EntryPoint = "black_scholes")]
public static extern void black_scholes(ref double value, IntPtr greeks, double s0,
double x, double sigma,
double t, double r, double q, int put, ref int iflag);
[DllImport("Analytics_MathLib.dll")]
public static extern void opt_gfd(double theta, double S0, double sigma, double r,
double T, double X, int is_american,
int put, ref double value, IntPtr greeks, double q, int ns, int nt,
double smax, ref int iflag);
[DllImport("Analytics_MathLib.dll")]
public static extern void standard_2D_binomial(ref double value, double S1, double S2,
double X, double sigma1,
double sigma2, double rho, double T, double r, double q1, double q2, int put,
int M, int is_max,
int is_american, ref int iflag);
.
.
.
public static double RndNorm(double mean, double std)
{
return mean + std * normal(0.0, 1.0);
}
[DllImport("Analytics_MathLib.dll")]
public static extern double normal(double mean, double std);
[DllImport("Analytics_MathLib.dll")]
public static extern void set_seed(int seed);
[DllImport("Analytics_MathLib.dll", EntryPoint = "multivariate_normal2")]
public static extern void multivariate_normal(int is_fcall, ref double a, int n,
ref double c, int tdc, double eps,
ref double r, ref double z, ref int iflag);
// array r has size nr = ((n+1)*(n+2))/2 + 1
}
Code excerpt 8.8 (Continued).
larations are given in Code excerpt 8.9. It can be seen that C function parameters
passed by value and declared as double dval and long ival correspond to
C# double dval and int ival parameters, respectively. C functions that
are passed by reference are a little more tricky to deal with in C#. This is be-
cause C# does not explicitly support pointers. A C double parameter passed
by reference using double *dval can be mapped in C# by using ref dou-
ble dval. Similarly, the C function parameter long* ival is declared in C#
as ref int ival. It should be noted that for clarity we use the C syntax
double a_dval[] and long a_ival[] for arrays of double and long,
respectively; it is also correct to declare these as double *a_dval, and long
*a_ival.
However, there is still a problem because C functions can be coded to check
whether or not a null pointer has been supplied as a parameter, and then take
appropriate action. For instance, the function black_scholes in Code ex-
cerpt 4.1, will not compute the Greeks if the parameter double greeks[] is
null. The code fragment below shows how IntPtr, which is a recent addition
to C#, can be used to resolve this:
[DllImport("Analytics_MathLib.dll", EntryPoint = "black_scholes")]
public static extern void black_scholes2(ref double value, ref double greeks,_
double s0, double x,double sigma, double t, double r, double q, int put, ref int iflag);

264
Computational Finance Using C and C#
[DllImport("Analytics_MathLib.dll", EntryPoint = "black_scholes")]
public static extern void black_scholes(ref double value, IntPtr greeks, double s0,_
double x, double sigma, double t, double r, double q, int put, ref int iflag);
The ﬁrst declaration speciﬁes that the function called
black_scholes
in Analytics_MathLib.dll will have the name black_scholes2 in C#.
In addition the C parameter double greeks[] is mapped to ref double
greeks in C#. This means that we will need to declare an array variable (say
the_greeks which will hold the ﬁve Greeks and pass it to black_scholes2
using the syntax ref the_greeks[0]. In this case the Greeks will always be
computed, even if we don’t want to use them.
The second declaration speciﬁes that the function black_scholes2 in C#
will also call the routine black_scholes in Analytics_MathLib.dll.
However, in this case, the C parameter double greeks[] is mapped
to IntPtr greeks in C#. This allows us to set the parameter double
greeks[] to
null by passing the value IntPtr.Zero—see for example
class EquityOptionDeal in Code excerpt 8.10.
#define DLLExport __declspec(dllexport)
void DLLExport __stdcall black_scholes(double *value, double greeks[],double s0,double x,
double sigma,
double t,double r,double q, long put, long *iflag)
{
.
.
.
See code excerpt 4.1 for more detail
.
.
.
}
void DLLExport __stdcall opt_gfd(double theta_m, double asset_price, double sigma, double r,
double T,
double strike, long is_american, long put, double *option_value,
double greeks[], double q, long pns, long nt, double smax, long *iflag)
{
.
.
.
See code excerpt 5.18 for more detail
.
.
.
}
void DLLExport __stdcall multivariate_normal2(long is_fcall, double a[], long n, double c[],
long tdc,
double eps, double r[], double z[], long *iflag)
{
.
.
.
Standard C code to generate a multivariate normal
.
.
.
}
Code excerpt 8.9 Illustrative C code which is contained in the windows dynamic link
library Analytics_MathLib.dll.

C# portfolio pricing application
265
using System;
namespace Computational_Lib
{
public class EquityOptionDeal: BaseDeal
{
public string Equity { get { return EquityName_; } set { EquityName_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public PutCall OptionType{ get {return OptionType_;} set { OptionType_= value;}}
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
public double Strike { get { return Strike_; } set { Strike_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public double Volatility { get { return Sigma_; } set { Sigma_ = value; } }
protected PutCall
OptionType_ = PutCall.Put;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected double
Strike_ = 0;
protected string
EquityName_ = "";
protected double
Time_To_Expiry_ = 0.0;
protected string
Currency_ = "";
protected double
DividendYield_ = 0.0;
protected string
Pre_string_ = "";
protected BuySell
BuySell_ = BuySell.Buy;
protected int NumberOfUnits_ = 1;
protected double Sigma_ = 0.0;
public override string Name()
{
return "Equity Option";
}
public override double Price()
{
Validate();
double val=0.0;
double[] greeks = new double[6];
double s0 = 0.0;
double fx_spot = 0.0;
try
{
s0 = MarketDataDictionaries.EquityTable[EquityName_].Spot;
// get current equity price
Currency_ = MarketDataDictionaries.EquityTable[EquityName_].Currency;
// get equity volatility (assumed constant)
DividendYield_ = MarketDataDictionaries.EquityTable[EquityName_].DivYield;
// get equity dividend yield
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityName_);
}
// get the risk free rate to use
double discount_fac = 0.0;
double RiskFreeRate = 0.0;
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// obtain the discount factor
discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate = -Math.Log(discount_fac) / Time_To_Expiry_;
fx_spot = MarketDataDictionaries.CurrencyTable[Currency_].spot;
}
Code excerpt 8.10 The complete C# code for class EquityOptionDeal, which com-
putes the value of a single equity option.

266
Computational Finance Using C and C#
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for " + Currency_);
}
int iflag, put;
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
if (ExerciseStyle_ == EuropeanAmerican.European)
// use BlackScholes
{
// call C routine.
// Note: A null pointer is supplied so that the Greeks are not computed
PricingUtils.black_scholes(ref val, IntPtr.Zero, s0, Strike_, Sigma_,
Time_To_Expiry_,
RiskFreeRate, DividendYield_, put, ref iflag);
}
else
{
// Use Crank Nicolson
double theta = 0.5;
int is_american = 1;
// fix the geometry of the grid (these values should give "reasonable" results)
int ns = 50;
// 50 divisions on asset axis
int nt = 50;
// 50 divisions on time axis
double smax = 10.0 * s0;
PricingUtils.opt_gfd(theta, s0, Sigma_,RiskFreeRate, Time_To_Expiry_, Strike_,
is_american, put, ref val, IntPtr.Zero, DividendYield_, ns,
nt, smax, ref iflag);
}
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the_
pricing library");
val *= fx_spot * NumberOfUnits_; // return value in base currency
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ +")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than_
zero years");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- The number of units cannot be less_
than zero");
}
if (Sigma_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility cannot be less than zero");
}
}
}
}
Code excerpt 8.10 (Continued).

C# portfolio pricing application
267
8.4
Equity deal classes
In this section we provide the C# code for both single and multiasset equity
options. The trade attributes correspond to the public properties of the deal
class, and attribute default values can be readily found by reading the C# code.
The enumerations used by the deal attributes are declared below.
public enum BuySell { Buy, Sell };
public enum PutCall { Put, Call };
public enum EuropeanAmerican { European, American };
public enum MinimumMaximum { Minimum, Maximum };
public enum UseMonteCarlo { Yes, No };
public enum CalculationMethod { Analytic, Numeric, MonteCarlo };
and it can be seen that the enumerators have obvious names.
It has already been noted that the volatility used by the application to price
options is supplied as a deal attribute, rather than being stored as market data.
The reason for this is simplicity. In Chapter 4 we mentioned that a volatility
surface is required to represent the implied volatility used to price options. Stor-
ing the implied volatility would thus require a set of volatility surfaces in the
market data ﬁle and also multidimensional interpolation to retrieve the volatil-
ity applicable to a given option. It was thus decided to supply the volatility as a
trade attribute—and update its value appropriately.
8.4.1
Single equity option
Code excerpt 8.10 gives the C# code for class EquityOptionDeal, which
computes the values of a single equity option.
8.4.2
Option on the price of two equities
Code excerpt 8.11 gives the C# code to compute the value of options that de-
pend on the price of two equities.
using System;
namespace Computational_Lib
{
public class TwoEquityOptionDeal : BaseDeal
{
public string Equity1 { get { return EquityName1_; } set { EquityName1_ = value; } }
public string Equity2 { get { return EquityName2_; } set { EquityName2_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
public PutCall OptionType { get { return OptionType_; } set { OptionType_ = value; } }
public MinimumMaximum
MinMax{ get { return MinMax_; } set { MinMax_ = value; } }
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
Code excerpt 8.11 C# code to compute the value of options which depend on the price
of two equities. For example, it is possible to specify whether the option is European or
American, and if it is on the minimum or maximum of the equity prices.

268
Computational Finance Using C and C#
public double Strike { get { return Strike_; } set { Strike_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public double Volatility1 { get { return Sigma1_; } set { Sigma1_ = value; } }
public double Volatility2 { get { return Sigma2_; } set { Sigma2_ = value; } }
protected PutCall OptionType_ = PutCall.Put;
protected MinimumMaximum MinMax_ = MinimumMaximum.Maximum;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected double Strike_ = 0;
protected string EquityName1_ = "";
protected string EquityName2_ = "";
protected string Currency_ = "";
protected int NumberOfUnits_ = 1;
protected double Time_To_Expiry_ = 0.0;
protected string Pre_string_ = "";
protected double S1_ = 0.0;
protected double S2_ = 0.0;
protected double Sigma1_ = 0.0;
protected double Sigma2_ = 0.0;
protected BuySell BuySell_ = BuySell.Buy;
public override string Name()
{
return "Rainbow option(two equities)";
}
public override double Price()
{
Validate();
double val = 0.0;
double rho = 0.0; // default correlation set to zero
double RiskFreeRate = 0.0;
double fx_spot = 0.0;
try
{
S1_ = MarketDataDictionaries.EquityTable[EquityName1_].Spot;
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityName1_);
}
try
{
S2_ = MarketDataDictionaries.EquityTable[EquityName2_].Spot;
S1_ = MarketDataDictionaries.EquityTable[EquityName1_].Spot;
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityName2_);
}
if(string.Compare(MarketDataDictionaries.EquityTable[EquityName1_].Currency,
MarketDataDictionaries.EquityTable[EquityName2_].Currency) != 0){
throw new Exception(Pre_string_ + "--- Currencies for both equities are not
the same");
}
Currency_ = MarketDataDictionaries.EquityTable[EquityName1_].Currency;
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// obtain the discount factor
double discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate = -Math.Log(discount_fac) / Time_To_Expiry_;
fx_spot = MarketDataDictionaries.CurrencyTable[Currency_].spot;
}
Code excerpt 8.11 (Continued).

C# portfolio pricing application
269
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ Currency_);
}
string corr_key = EquityName1_ + "%" + EquityName2_;
if (MarketDataDictionaries.CorrelationTable.ContainsKey(corr_key))
rho = MarketDataDictionaries.CorrelationTable[corr_key].Correl;
else
rho = 0.0;
int iflag, put, is_max;
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
is_max = MinMax_ == MinimumMaximum.Maximum ? 1 : 0;
if (ExerciseStyle_ == EuropeanAmerican.European)
// use analytic method
{
PricingUtils.opt_rainbow_bs_2d(ref val, S1_, S2_, Strike_, Sigma1_, Sigma2_,
rho, Time_To_Expiry_, RiskFreeRate, is_max,
put, ref iflag);
}
else { // use numeric method
double q1 = 0.0;
double q2 = 0.0;
int num_steps = 200; // need to use an even number of time steps for the lattice
int is_american = 1;
PricingUtils.standard_2D_binomial(ref val, S1_, S2_, Strike_, Sigma1_, Sigma2_,
rho, Time_To_Expiry_, RiskFreeRate,
q1, q2, put, num_steps, is_max, is_american, ref iflag);
}
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
val *= fx_spot * NumberOfUnits_; // return value in base currency
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
if (Sigma1_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility1 cannot be less than zero");
}
if (Sigma2_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility2 cannot be less than zero");
}
}
}
}
Code excerpt 8.11 (Continued).

270
Computational Finance Using C and C#
8.4.3
Generic equity basket option
Here (see Code excerpt 8.12) we consider the abstract deal class GenericE-
quityBasketOptionDeal which enables its derived classes to value an op-
using System;
namespace Computational_Lib
{
public abstract class GenericEquityBasketOptionDeal : BaseDeal
{
public string Equities { set { Equities_ = value; } }
public string Volatilities { set { Volatilities_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }
set { Time_To_Expiry_ = value; } }
public int NumberScenarios { get { return NumberScenarios_; }
set { NumberScenarios_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }
set { NumberOfUnits_ = value; } }
public string Currency { get { return Currency_; } set { Currency_ = value; } }
public double Strike { get { return Strike_; } set { Strike_ = value; } }
protected string Equities_ = "";
protected string Volatilities_ = "";
protected double Time_To_Expiry_ = 0.0;
protected double RiskFreeRate_ = 0.0;
protected string Pre_string_ = "";
protected double[] S_;
protected double[] Sigma_;
protected int NumberScenarios_ = 3000;
protected double[,] Correlations_;
protected int n_ = 0;
protected int NumberOfUnits_ = 1;
protected string Currency_ = "";
protected BuySell BuySell_ = BuySell.Buy;
protected double[] ST_;
protected double Strike_ = 0.0;
public override string Name()
{
return "Generic Equity Option";
}
public abstract double Payoff();
public override double Price()
{
Validate();
double val = 0.0;
double fx_spot = 0.0;
char[] seps = new char[] { ’%’ };
string[] EquityNames = Equities_.Split(seps, StringSplitOptions.None);
n_ = EquityNames.Length;
ST_ = new double[n_];
S_ = new double[n_];
Sigma_ = new double[n_];
for (int k = 0; k < n_; ++k)
{
try
{
S_[k] = MarketDataDictionaries.EquityTable[EquityNames[k]].Spot;
}
Code excerpt 8.12 C# code for the abstract class GenericEquityBasketOption-
Deal. It contains the abstract method Payoff().

C# portfolio pricing application
271
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityNames[k]);
}
}
for (int k = 1; k < n_; ++k)
{
if (string.Compare(MarketDataDictionaries.EquityTable[EquityNames[k - 1]].
Currency, MarketDataDictionaries.EquityTable[EquityNames[k]].Currency) != 0)
throw new Exception(Pre_string_ + "--- Not all the currencies are
the same");
}
Currency_ = MarketDataDictionaries.EquityTable[EquityNames[1]].Currency;
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// obtain the discount factor
double discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
fx_spot = MarketDataDictionaries.CurrencyTable[Currency_].spot;
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ Currency_);
}
string[] Vols = Volatilities_.Split(seps, StringSplitOptions.None);
int n_v;
n_v = Vols.Length;
if (n_v != n_)
throw new Exception(Pre_string_ + "--- Number of volatilities is not the same
as the number of equities ");
Sigma_ = new double[n_];
for (int k = 0; k < n_; ++k)
{
try
{
Sigma_[k] = double.Parse(Vols[k]);
}
catch
{
throw new Exception(Pre_string_ + "--- Invalid volatility supplied for
"
+ EquityNames[k]);
}
}
Correlations_ = new double[n_, n_];
for (int i = 0; i < n_; ++i)
{
for (int j = 0; j < n_; ++j)
{
if (i != j)
{
string corr_key = EquityNames[i] + "%" + EquityNames[j];
if (MarketDataDictionaries.CorrelationTable.ContainsKey(corr_key))
Correlations_[i, j] = MarketDataDictionaries
.CorrelationTable[corr_key].Correl;
else
Correlations_[i, j] = 0.0; // default correlation is zero
}
else
{
Correlations_[i, j] = 1.0;
}
}
}
Code excerpt 8.12 (Continued).

272
Computational Finance Using C and C#
int iflag=0;
val = MonteCarloSim(ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
val *= fx_spot * NumberOfUnits_;
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
}
private double MonteCarloSim(ref int iflag)
{
double[] C = new double[n_ * n_];
double half = 0.5;
double zero = 0.0;
double sumit_val = zero;
double tol = 1.0e-8;
double opt_val = 0.0;
// set the covariance matrix
for (int i = 0; i < n_; ++i)
{
for (int j = 0; j < n_; ++j) {
C[i * n_ + j] = Sigma_[i] * Sigma_[j] * Correlations_[i, j]
* Time_To_Expiry_;
}
}
double[] MEANS = new double[n_];
// set the means
for (int i = 0; i < n_; ++i) {
MEANS[i] = (RiskFreeRate_ - Sigma_[i] * Sigma_[i] * half) * Time_To_Expiry_;
}
int seed = 111;
PricingUtils.set_seed(seed);
int len_rvec = ((n_ + 1) * (n_ + 2)) / 2 + 1;
double[] rvec = new double[len_rvec];
double[] Z = new double[n_];
double disc = Math.Exp(-RiskFreeRate_ * Time_To_Expiry_);
Code excerpt 8.12 (Continued).

C# portfolio pricing application
273
int is_fcall = 1;
PricingUtils.multivariate_normal(is_fcall, ref MEANS[0], n_, ref C[0], n_, tol,
ref rvec[0], ref Z[0], ref iflag);
is_fcall = 0;
for (int i = 1; i <= NumberScenarios_; ++i)
{
PricingUtils.multivariate_normal(is_fcall, ref MEANS[0], n_, ref C[0], n_, tol,
ref rvec[0], ref Z[0], ref iflag);
for (int jj=0; jj < n_; ++jj) {
ST_[jj] = S_[jj] * Math.Exp(Z[jj]);
}
sumit_val += Payoff();
}
opt_val = sumit_val * disc / (double)NumberScenarios_;
return opt_val;
}
}
}
Code excerpt 8.12 (Continued).
tion on an arbitrary number of underlying assets; the derived class also must
implement the abstract method Payoff. In the earlier sections of this book,
we have considered options with standard payoffs such as: vanilla put, vanilla
call, and call/put on the min/max of a number of assets. However, the class
GenericEquityBasketOptionDeal now opens the possibility of supplying
a user-deﬁned Payoff function so that options with nonstandard payoffs can
be valued.
Below we provide some example results for options on four and ten assets.
The assets were: Drinks-4U, Beverage-Ltd, H2O-Ltd, and Fine-Wines-
Ltd. The trade attributes are a time to expiry of one year, all volatilities are 0.2,
and the number of units is 100. Other information required to price the option,
such as the correlations between the equities and the risk free interest rate, is
taken from the market data dictionaries.
The syntax for using the deal class GenericEquityBasketOptionDeal
with the portfolio deﬁnition File is:
Trade=GenericEquityBasketOptionDeal:Payoff_MaxPut,Reference=1A,Strike=100.0,_
Volatilities=0.2%0.2%0.2%0.2,_
Equities=Drinks-4U%Beverage-Ltd%H2O-Ltd%Fine-Wines-Ltd,NumberOfUnits=100,_
Time_To_Expiry=1.0,NumberScenarios=1000
while that for calling the deal class FourEquityOptionDeal is:
Trade=FourEquityOptionDeal,Reference=1B,Volatility1=0.2,Volatility2=0.2,_
Volatility3=0.2,Volatility4=0.2,Equity1=Drinks-4U,Equity2=Beverage-Ltd,_
Equity3=H2O-Ltd,Equity4=Fine-Wines-Ltd,NumberOfUnits=100,Strike=100.0,_
Time_To_Expiry=1.0,OptionType=Put,MinMax=Maximum,MonteCarlo=Yes,NumberScenarios=1000
The crucial diffference is that the entry for GenericEquityBasketOption-
Deal contains the extra directive Trade=GenericEquityBasketOptionDeal:
Payoff_MaxPut, whereas FourEquityOptionDeal is the usual Trade=
FourEquityOptionDeal. The directive GenericEquityBasketOption-
Deal:Payoff_MaxPut means that the contents of the ﬁle Payoff_MaxPut.

274
Computational Finance Using C and C#
txt will be compiled at runtime and thereby create the (sub)class Generic
EquityBasketOptionDeal_MaxPut, which is derived from the abstract
base class GenericEquityBasketOptionDeal. The .NET assembly con-
taining the class GenericEquityBasketOptionDeal_MaxPut is stored in
memory and its Price() method is called to value the option.
The ﬁle Payoff_MaxPut.txt contains the following C# code:
using System;
namespace Computational_Lib
{
public class GenericEquityBasketOptionDeal_MaxPut : GenericEquityBasketOptionDeal
{
public override string Name()
{
string temp_string = "";
temp_string = "Generic option: Put on the maximum of " + n_.ToString() + " assets";
return temp_string;
}
public override double Payoff() { // implement max, put
double the_max = 0.0;
double pay_val = 0.0;
double zero = 0.0;
the_max = ST_[0];
for (int jj = 1; jj < n_; ++jj)
{
if (ST_[jj] > the_max) the_max = ST_[jj];
}
pay_val = Math.Max(Strike_ - the_max, zero);
return pay_val;
}
}
}
In the above code ST_, Strike_, and n_ are data members of the base class
GenericEquityBasketOptionDeal. We now present some other entries
in the portfolio deﬁnition ﬁle which illustrate the versatility of the deal class
GenericEquityBasketOptionDeal.
// Call on average of 4 assets
Trade=GenericEquityBasketOptionDeal:Payoff_AvgCall,Reference=5,Strike=100.0,_
Volatilities=0.2%0.2%0.2%0.2,Equities=Drinks-4U%Beverage-Ltd%H2O-Ltd%Fine-Wines-Ltd,_
NumberOfUnits=100,Time_To_Expiry=1.0,NumberScenarios=1000
// Put on the average of 10 assets (Strike=100)
Trade=GenericEquityBasketOptionDeal:Payoff_AvgPut,Reference=8,Strike=100.0,_
Volatilities=0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2,_
Equities=Drinks-4U%Beverage-Ltd%H2O-Ltd%Fine-Wines-Ltd%The-English-Beer-Company_
%Water-Works-Ltd%Welsh-Spring%ThamesBeer_
%Edingburgh-Whiskey%The-Wine-Box,NumberOfUnits=100,Time_To_Expiry=1.0,NumberScenarios=10000
// Put on the average of 10 assets (Strike=99)
Trade=GenericEquityBasketOptionDeal:Payoff_AvgPut,Reference=9,Strike=99.0,_
Volatilities=0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2,_
Equities=Drinks-4U%Beverage-Ltd%H2O-Ltd%Fine-Wines-Ltd%The-English-Beer-Company_
%Water-Works-Ltd%Welsh-Spring%ThamesBeer%_
Edingburgh-Whiskey%The-Wine-Box,NumberOfUnits=100,Time_To_Expiry=1.0,NumberScenarios=10000
where the ﬁle Payoff_AvgCall.txt contains the C# code:
using System;
namespace Computational_Lib
{
public class GenericEquityBasketOptionDealAverageCall : GenericEquityBasketOptionDeal
{
public override string Name()
string temp_string = "";
temp_string = "Generic option: Call on the average of_
" + n_.ToString() + " assets";
return temp_string;

C# portfolio pricing application
275
}
public override double Payoff() {
// implement Call on average of n_assets
double the_average = 0.0;
double pay_val = 0.0;
double zero = 0.0;
the_average = ST_[0];
for (int jj = 1; jj < n_; ++jj)
{
the_average += ST_[jj];
}
the_average = the_average/n_;
pay_val = Math.Max(the_average - Strike_, zero);
return pay_val;
}
}
}
The
contents
of
the
ﬁle
Payoff_AvgPut
can
be
deduced
from
Payoff_AvgCall in the obvious manner.
The output from the application is given below:
================================================================
TestGenericEQ in units of GBP
TestGenericEQ
:31/07/2007 19:05:10
=============================
23.0100=1A,Generic option: Put on the maximum of 4 assets
23.0100=1B,Four Equity Option
.
.
.
681.4034=5,Generic option: Call on the average of 4 assets
.
.
.
338.3212=8,Generic option: Put on the average of 10 assets
302.6056=9,Generic option: Put on the average of 10 assets
=========================
TOTAL VALUE =
10936.18 GBP
=========================
It can be seen that result 1A, obtained using the deal class GenericEquity-
BasketOptionDeal, is exactly the same as result 1B, which was computed
with the deal class FourEquityOptionDeal. This is because in both cases
Monte Carlo simulation is used, and the same initial random seed is used for all
Monte Carlo simulations.
8.4.4
Equity barrier option
Code excerpt 8.13 gives the C# code for computing the value of an equity barrier
option.
using System;
namespace Computational_Lib
{
public class DownOutEquityOptionDeal : BaseDeal
{
public string Equity { get { return EquityName_; } set { EquityName_ = value; } }
public double Barrier_Level { get { return BarrierLevel_; }_
set { BarrierLevel_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public PutCall OptionType { get { return OptionType_; } set { OptionType_ = value; } }
public double Strike { get { return Strike_; } set { Strike_ = value; } }
public CalculationMethod CalcMethod { get { return CalcMethod_; }_
set { CalcMethod_ = value; } }
Code excerpt 8.13 C# code to compute the value of an equity barrier option.

276
Computational Finance Using C and C#
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
public int TimeSteps { get { return TimeSteps_; } set { TimeSteps_ = value; } }
public int NumberScenarios { get { return NumberScenarios_; }_
set { NumberScenarios_ = value; } }
public bool UseBrownianBridge{ get { return UseBrownianBridge_; }_
set { UseBrownianBridge_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public double Volatility { get { return Sigma1_; } set { Sigma1_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
protected PutCall OptionType_ = PutCall.Call;
protected double Strike_ = 0;
protected double BarrierLevel_ = 0.0;
protected string EquityName_ = "";
protected double Time_To_Expiry_ = 0.0;
protected double RiskFreeRate_ = 0.0;
protected double DividendYield_ = 0.0;
protected string Pre_string_ = "";
protected CalculationMethod CalcMethod_ = CalculationMethod.Analytic;
protected int TimeSteps_ = 300;
protected int NumberScenarios_ = 3000;
protected bool UseBrownianBridge_ = true;
protected double S1_ = 0.0;
protected double Sigma1_ = 0.0;
protected int NumberOfUnits_ = 1;
protected BuySell BuySell_ = BuySell.Buy;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected string Currency_ = "";
public override string Name()
{
return "Down Out Equity Option";
}
public override double Price()
{
Validate();
double val = 0.0;
double fx_spot = 0.0;
try
{
S1_ = MarketDataDictionaries.EquityTable[EquityName_].Spot;
Currency_ = MarketDataDictionaries.EquityTable[EquityName_].Currency;
// get equity volatility (assumed constant)
DividendYield_ = MarketDataDictionaries.EquityTable[EquityName_].DivYield;
// get equity dividend yield
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityName_);
}
double discount_fac = 0.0;
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// obtain the discount factor
discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
fx_spot = MarketDataDictionaries.CurrencyTable[Currency_].spot;
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ Currency_);
}
int iflag, put, is_american;
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
is_american = ExerciseStyle_ == EuropeanAmerican.American ? 1 : 0;
Code excerpt 8.13 (Continued).

C# portfolio pricing application
277
BarrierLevel_ = Math.Max(BarrierLevel_, PricingUtils.EPS);
if (CalcMethod_ == CalculationMethod.Analytic)
{
if (put == 1) throw new Exception(Pre_string_ + "--- Can’t price a put using
this calculation method");
if (is_american == 1) throw new Exception(Pre_string_ + "--- Can’t price an
American option using this calculation method");
PricingUtils.bs_opt_barrier_downout_call(ref val, BarrierLevel_,
S1_, Strike_, Sigma1_,
Time_To_Expiry_, RiskFreeRate_, DividendYield_,
ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
}
else if (CalcMethod_ == CalculationMethod.Numeric)
{
if (put == 1) throw new Exception(Pre_string_ + "--- Can’t price a put using
this calculation method");
int n_sigma = 2;
// set up the parameters so that have "reasonable accuracy"
double[] sigma_array = new double[n_sigma];
double[] sigma_times = new double[n_sigma];
sigma_array[0] = Sigma1_;
sigma_array[1] = Sigma1_;
sigma_times[0] = 0.0;
sigma_times[1] = Time_To_Expiry_;
int nt = 100;
int ns_below_S0 = nt / 2;
int ns_above_S0 = nt / 2;
double theta_m = 0.5;
double UpperBarrierLevel = S1_ * 5.0;
iflag = 0;
PricingUtils.dko_call(BarrierLevel_, UpperBarrierLevel,
theta_m, S1_, ref sigma_array[0], ref sigma_times[0],
n_sigma, RiskFreeRate_, Time_To_Expiry_,
Strike_, is_american, ref val,
IntPtr.Zero, DividendYield_, ns_below_S0, ns_above_S0,
nt, ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
}
else
{
bool is_put = (put == 1);
if (is_american == 1) throw new Exception(Pre_string_ + "--- Can’t price an
American option using this calculation method");
if (S1_ < BarrierLevel_)
// the opton is already knocked out
val = 0.0;
else
val = MonteCarloSim(is_put);
}
val *= fx_spot * NumberOfUnits_;
return val;
}
Code excerpt 8.13 (Continued).

278
Computational Finance Using C and C#
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (RiskFreeRate_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Risk free rate cannot be less than
zero");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
if (BarrierLevel_ < 0.0)
{
throw new Exception(Pre_string_ + "--- BarrierLevel cannot be less than zero");
}
if (Sigma1_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility cannot be less than zero");
}
}
private double MonteCarloSim(bool is_put)
{
// Use the Brownian Bridge to compute the value of a down and out call option
int seed = 111;
double[] asset_path = new double[TimeSteps_];
double time_step = Time_To_Expiry_ / TimeSteps_;
double sqrt_time_step = System.Math.Sqrt(time_step);
double disc = System.Math.Exp(-RiskFreeRate_ * Time_To_Expiry_);
PricingUtils.set_seed(seed);
double opt_val = 0.0;
bool not_out = true;
int k = 0;
double STN = 0.0;
double mean = (RiskFreeRate_ - DividendYield_ - Sigma1_ * Sigma1_ * 0.5)
* time_step;
double std = System.Math.Sqrt(Sigma1_ * Sigma1_ * time_step);
double z;
double sum_opt_vals = 0.0;
for (int i = 0; i < NumberScenarios_; ++i)
{
// generate the asset path
double ST1 = S1_;
not_out = true;
k = 0;
while (not_out && k < TimeSteps_)
{
z = PricingUtils.RndNorm(mean, std);
STN = ST1 * System.Math.Exp(z);
if (STN < BarrierLevel_) not_out = false;
ST1 = STN;
asset_path[k] = STN;
++k;
}
Code excerpt 8.13 (Continued).

C# portfolio pricing application
279
if (is_put)
{
opt_val = System.Math.Max(Strike_ - STN, 0.0);
}
else
{
opt_val = System.Math.Max(STN - Strike_, 0.0);
}
if (not_out)
{ // only has value if asset value is above the barrier_level
// compute the probability that the asset remained above the barrier
if (UseBrownianBridge)
{
double total_probability_above = 1.0, pr;
double sigma_2 = Sigma1_ * Sigma1_;
double log_barrier_level = System.Math.Log(BarrierLevel_);
double fac;
for (int jj = 0; jj < TimeSteps_ - 1; ++jj)
{
double log_S_i = System.Math.Log(asset_path[jj]);
double log_S_i1 = System.Math.Log(asset_path[jj + 1]);
fac = 2.0 * (log_barrier_level - log_S_i)
* (log_barrier_level - log_S_i1) / (sigma_2 * time_step);
pr = (1.0 - System.Math.Exp(-fac));
// probability of staying above the barrier between i and i+1
total_probability_above *= pr;
}
sum_opt_vals += total_probability_above * opt_val * disc;
}
else
{ // don’t use the Brownian Bridge
sum_opt_vals += opt_val * disc;
}
}
}
double temp = sum_opt_vals / (double)NumberScenarios_;
return temp;
}
}
}
Code excerpt 8.13 (Continued).
Below we show the results of using the deal class DownOutEquityOption-
Deal to value Down and Out call options on LaserComm which is a GBP
equity with current (spot) price of £95, and a dividend yield of 5 percent (i.e.,
0.05). All the options priced had a barrier level of £90, a strike of £90, a time to
expiry of one year, and a volatility of 20 percent (i.e., 0.2). The ﬁrst value,
£3.8347, was computed by a call to
bs_opt_barrier_downout_call,
which uses the closed form analytic expression provided in Code excerpt 2.6.
The second price, £3.8269, which is in close agreement with the ﬁrst, was
obtained from dko_call and uses a ﬁnite-difference grid. The third valuation
was also computed using dko_call, and illustrates the early exercise premium
for an American call option (with a nonzero dividend). The other values were
estimated using Monte Carlo simulation as the number of scenarios varied from
1000 to 64000; the default of 300 time steps was used throughout.
It can be seen that, when the Brownian bridge is used, much closer agreement
is obtained with both the analytic and numeric estimates.
DownOutTests in units of GBP
DownOutTests
:26/07/2007 13:11:28
=============================
3.8347=Analytic,Down Out Equity Option

280
Computational Finance Using C and C#
3.8269=Numeric,Down Out Equity Option
3.8860=Numeric (American style),Down Out Equity Option
4.1871=MonteCarlo(1000 Scenarios: not using BrownianBridge),Down Out Equity Option
3.8908=MonteCarlo(2000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1968=MonteCarlo(4000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1176=MonteCarlo(8000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1790=MonteCarlo(16000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1961=MonteCarlo(32000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1833=MonteCarlo(64000 Scenarios: not using BrownianBridge),Down Out Equity Option
3.8375=MonteCarlo(1000 Scenarios: using BrownianBridge),Down Out Equity Option
3.5469=MonteCarlo(2000 Scenarios: using BrownianBridge),Down Out Equity Option
3.8737=MonteCarlo(4000 Scenarios: using BrownianBridge),Down Out Equity Option
3.7356=MonteCarlo(8000 Scenarios: using BrownianBridge),Down Out Equity Option
3.8089=MonteCarlo(16000 Scenarios: using BrownianBridge),Down Out Equity Option
3.8506=MonteCarlo(32000 Scenarios: using BrownianBridge),Down Out Equity Option
3.8482=MonteCarlo(64000 Scenarios: using BrownianBridge),Down Out Equity Option
=========================
TOTAL VALUE =
70.83 GBP
=========================
8.5
FX deal classes
Here we provide code for valuing FX derivatives. The FX option routines are
very similar to the equity option routines we have already considered, the funda-
mental difference being that for FX routines there is both a domestic and foreign
currency. The FX routine calls the Black–Scholes routine with the dividend yield
set to the foreign currency risk free interest rate, and the supplied volatility is
that of the foreign/domestic exchange rate. In the market data ﬁle the currency
FX spot rates are with respect to the base currency.
8.5.1
FX forward
Code excerpt 8.14 gives the C# code to compute the value of FX forwards.
using System;
namespace Computational_Lib
{
public class FXForwardDeal : BaseDeal
{
public double ForeignAmount { get { return fForeignAmount; }_
set { fForeignAmount = value; } }
// Note: Strike is the number of units of domestic currency required to
//
obtain one unit of foreign currency.
public double Strike { get { return fStrike; } set { fStrike = value; } }
public string ForeignCurrency { get { return fForeignCurrency; }_
set { fForeignCurrency = value; } }
public string DomesticCurrency { get { return fDomesticCurrency; }_
set { fDomesticCurrency = value; } }
public BuySell BuySell { get { return fBuySell; } set { fBuySell = value; } }
public double Settlement { get { return fSettlement; } set { fSettlement = value; } }
Code excerpt 8.14 C# code to compute the value of FX forwards.

C# portfolio pricing application
281
protected double fStrike
= 0;
protected string fForeignCurrency = "";
protected string fDomesticCurrency = "";
protected double fForeignAmount = 0;
protected BuySell fBuySell = BuySell.Buy;
protected double fSettlement = 0;
protected string pre_string = "";
public override string
Name()
{
return "FX Forward";
}
public override double Price()
{
double val=0.0;
Validate();
double sign = fBuySell == BuySell.Buy ? 1.0 : -1.0;
try
{
ICurve DF_F = CurrencyTable[fForeignCurrency].YieldCurve;
// obtain the discount factor
ICurve DF_D = CurrencyTable[fDomesticCurrency].YieldCurve;
// obtain the discount factor
double X_fb = CurrencyTable[fForeignCurrency].spot;
double X_db = CurrencyTable[fDomesticCurrency].spot;
double DF_f = DF_F[0,fSettlement];
double DF_d = DF_D[0,fSettlement];
val = fForeignAmount *( DF_f * X_fb - X_db * DF_d * fStrike);
val = val * sign;
}
catch(Exception ex)
{
throw new Exception(pre_string + " : " + ex.Message);
}
return val;
}
protected override void Validate()
{
pre_string = Name() + "
(" + fReference + ")";
}
}
}
Code excerpt 8.14 C# code to compute the value of FX forwards.
8.5.2
Single FX option
The code for the single FX option, given in Code excerpt 8.15, is very similar
to that for the single equity option. For example, European equity options are
priced using the call:
PricingUtils.black_scholes(ref val, IntPtr.Zero, s0, Strike_, Sigma_,
Time_To_Expiry_, RiskFreeRate, DividendYield_, put,
ref iflag);
while European FX options use:
PricingUtils.black_scholes(ref val, IntPtr.Zero, S0, Strike_b,Sigma_f_d_,
Time_To_Expiry_, DomesticRiskFreeRate_, ForeignRiskFreeRate_, put, ref iflag);

282
Computational Finance Using C and C#
using System;
namespace Computational_Lib
{
public class FXOptionDeal: BaseDeal
{
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
// Note: Strike is the number of units of domestic currency required to
//
obtain one unit of foreign currency.
public double Strike { get { return Strike_f_d_; } set { Strike_f_d_ = value; } }
// Volatility is that of the Foreign/Domestic exchange rate.
public double Volatility { get { return Sigma_f_d_; } set { Sigma_f_d_ = value; } }
public string ForeignCurrency { get { return ForeignCurrency_; }_
set { ForeignCurrency_ = value; } }
public string DomesticCurrency { get { return DomesticCurrency_; }_
set { DomesticCurrency_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public PutCall OptionType { get { return OptionType_; } set { OptionType_ = value; } }
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
protected double Strike_f_d_ = 0.0;
protected string ForeignCurrency_ = "";
protected string DomesticCurrency_ = "";
protected BuySell BuySell_ = BuySell.Buy;
protected int NumberOfUnits_ = 1;
protected PutCall OptionType_ = PutCall.Put;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected double Time_To_Expiry_ = 0.0;
protected double ForeignRiskFreeRate_ = 0.0;
protected double DomesticRiskFreeRate_ = 0.0;
protected double Sigma_f_d_ = 0.0;
protected string Pre_string_ = "";
public override string Name()
{
return "FX Option";
}
public override double Price()
{
Validate();
double val = 0.0;
double[] greeks = new double[6];
int iflag, put;
double discount_fac = 0.0;
double X_f_b = 0.0, X_d_b = 0.0;
double S0=0.0,Strike_b;
// Get domestic currency information
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[DomesticCurrency_].YieldCurve;
// obtain the domestic discount factor
discount_fac = DF[0, Time_To_Expiry_];
DomesticRiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
X_d_b = MarketDataDictionaries.CurrencyTable[DomesticCurrency_].spot;
Strike_b = X_d_b * Strike_f_d_;
// Strike_b is the Strike in base currency units
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ DomesticCurrency_);
}
Code excerpt 8.15 C# code to compute the value of FX options.

C# portfolio pricing application
283
// Get foreign currency information
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[ForeignCurrency_].YieldCurve;
// obtain the domestic discount factor
discount_fac = DF[0, Time_To_Expiry_];
ForeignRiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
X_f_b = MarketDataDictionaries.CurrencyTable[ForeignCurrency_].spot;
S0 = X_f_b;
// Foreign exchange wrt base currency
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ ForeignCurrency_);
}
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
if (ExerciseStyle_ == EuropeanAmerican.European)
// use BlackScholes
{
// Note: A null pointer is supplied so that the Greeks are not computed
// Dividend yield is set to foreign risk free rate
// Risk free interest rate is set to the domestic rate
// S0 the value of the "asset" in base cuurency units
// val is
the value of the FX option in base currency units
PricingUtils.black_scholes(ref val, IntPtr.Zero, S0, Strike_b, Sigma_f_d_,
Time_To_Expiry_,
DomesticRiskFreeRate_, ForeignRiskFreeRate_, put, ref iflag);
}
else
{
// Use Finite Difference Grid - Crank Nicolson
double theta = 0.5;
int is_american = 1;
// fix the geometry of the grid (these avluse should give "reasonable" results)
int ns = 50;
// 50 divisions on asset axis
int nt = 50;
// 50 divisions on time axis
double smax = 10.0 * S0;
PricingUtils.opt_gfd(theta, S0, Sigma_f_d_, DomesticRiskFreeRate_,
Time_To_Expiry_, Strike,
is_american, put, ref val, IntPtr.Zero, ForeignRiskFreeRate_, ns,
nt, smax, ref iflag);
// val is
the value of the FX option in base currency units
}
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
val *= NumberOfUnits_;
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
Code excerpt 8.15 (Continued).

284
Computational Finance Using C and C#
if (Strike_f_d_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
}
}
}
Code excerpt 8.15 (Continued).
It can be seen that, when pricing FX options, the foreign risk free rate is
used instead of the dividend yield, and the supplied volatility is that of the for-
eign/domestic exchange rate. Another difference is that the equity option value
val returned by the call to black_scholes is in domestic currency units, and
is then converted to base currency, while in the case of FX options the value
val is already in base currency units, and requires no conversion.
8.5.3
FX barrier option
The C# code for the Barrier option is given in Code excerpt 8.16.
using System;
namespace Computational_Lib
{
public class DownOutFXOptionDeal: BaseDeal
{
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
// Note: Strike is the number of units of domestic currency required to obtain one
//
unit of foreign currency.
public double Strike { get { return Strike_f_d_; } set { Strike_f_d_ = value; } }
// Barrier is in the same units a the strike
public double Barrier_Level { get { return Barrier_f_d_; }_
set { Barrier_f_d_ = value; } }
// Volatiliy is that of the Foreign/Domestic exchange rate.
public double Volatility { get { return Sigma_f_d_; } set { Sigma_f_d_ = value; } }
public string ForeignCurrency { get { return ForeignCurrency_; }_
set { ForeignCurrency_ = value; } }
public string DomesticCurrency { get { return DomesticCurrency_; }_
set { DomesticCurrency_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public CalculationMethod CalcMethod { get { return CalcMethod_; }_
set { CalcMethod_ = value; } }
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
public int NumberScenarios { get { return NumberScenarios_; }_
set { NumberScenarios_ = value; } }
public bool UseBrownianBridge { get { return UseBrownianBridge_; }_
set { UseBrownianBridge_ = value; } }
protected double Strike_f_d_ = 0.0;
protected double Barrier_f_d_ = 0.0;
protected string ForeignCurrency_ = "";
protected string DomesticCurrency_ = "";
protected BuySell BuySell_ = BuySell.Buy;
protected int NumberOfUnits_ = 1;
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public PutCall OptionType { get { return OptionType; } set { OptionType_ = value; } }
protected PutCall OptionType_ = PutCall.Call;
protected double Time_To_Expiry_ = 0.0;
Code excerpt 8.16 C# code to compute the value of FX barrier options.

C# portfolio pricing application
285
protected double ForeignRiskFreeRate_ = 0.0;
protected double DomesticRiskFreeRate_ = 0.0;
protected double Sigma_f_d_ = 0.0;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected CalculationMethod CalcMethod_ = CalculationMethod.Analytic;
protected int TimeSteps_ = 300;
protected int NumberScenarios_ = 3000;
protected double S0_,Strike_b_,BarrierLevel_b_;
protected bool UseBrownianBridge_ = true;
protected string Pre_string_ = "";
public override string Name()
{
return "Down Out FX Option";
}
public override double Price()
{
Validate();
double val = 0.0;
int iflag, put, is_american;
double discount_fac = 0.0;
double X_f_b = 0.0, X_d_b = 0.0;
// Get domestic currency information
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[DomesticCurrency_].YieldCurve;
// obtain the domestic discount factor
discount_fac = DF[0, Time_To_Expiry_];
DomesticRiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
X_d_b = MarketDataDictionaries.CurrencyTable[DomesticCurrency_].spot;
Strike_b_ = X_d_b * Strike_f_d_;
// Strike is the Strike in base currency units
BarrierLevel_b_ = X_d_b * Barrier_f_d_;
BarrierLevel_b_ = Math.Max(BarrierLevel_b_, PricingUtils.EPS);
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ DomesticCurrency_);
}
// Get foreign currency information
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[ForeignCurrency_].YieldCurve;
// obtain the domestic discount factor
discount_fac = DF[0, Time_To_Expiry_];
ForeignRiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
X_f_b = MarketDataDictionaries.CurrencyTable[ForeignCurrency_].spot;
S0_ = X_f_b;
// Foreign exchange wrt base currency
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ ForeignCurrency_);
}
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
is_american = ExerciseStyle_ == EuropeanAmerican.American ? 1 : 0;
if (CalcMethod_ == CalculationMethod.Analytic)
{
if (put == 1) throw new Exception(Pre_string_ + "--- Can’t price a put using
this calculation method");
if (is_american == 1) throw new Exception(Pre_string_ + "--- Can’t price an
American option using this calculation method");
// call C routine.
// Note: A null pointer is supplied so that the Greeks are not computed
// Dividend yield is set to foreign risk free rate
// Risk free interest rate is set to the domestic rate
Code excerpt 8.16 (Continued).

286
Computational Finance Using C and C#
// val is
the value of the FX option in base currency units
PricingUtils.bs_opt_barrier_downout_call(ref val, BarrierLevel_b_,
S0_, Strike_b_, Sigma_f_d_,
Time_To_Expiry_, DomesticRiskFreeRate_,
ForeignRiskFreeRate_, ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
}
else if (CalcMethod_ == CalculationMethod.Numeric)
{
if (put == 1) throw new Exception(Pre_string_ + "--- Can’t price a put using
this calculation method");
int n_sigma = 2;
// set up the parameters so that have "reasonable accuracy"
double[] sigma_array = new double[n_sigma];
double[] sigma_times = new double[n_sigma];
sigma_array[0] = Sigma_f_d_;
sigma_array[1] = Sigma_f_d_;
sigma_times[0] = 0.0;
sigma_times[1] = Time_To_Expiry_;
int nt = 100;
int ns_below_S0 = nt / 2;
int ns_above_S0 = nt / 2;
double theta_m = 0.5;
double UpperBarrierLevel = S0_ * 5.0;
iflag = 0;
// val is
the value of the FX option in base currency units
PricingUtils.dko_call(BarrierLevel_b_, UpperBarrierLevel,
theta_m, S0_, ref sigma_array[0], ref sigma_times[0],
n_sigma, DomesticRiskFreeRate_, Time_To_Expiry_,
Strike_b_, is_american, ref val,
IntPtr.Zero, ForeignRiskFreeRate_, ns_below_S0, ns_above_S0,
nt, ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
}
else
{
bool is_put = (put == 1);
if (is_american == 1) throw new Exception(Pre_string_ + "--- Can’t price an
American option using this calculation method");
if (S0_ < BarrierLevel_b) // the option has already been knocked out
val = 0.0;
else
val = MonteCarloSim(is_put);
}
val *= NumberOfUnits_;
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than
zero years");
}
Code excerpt 8.16 (Continued).

C# portfolio pricing application
287
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
if (Strike_f_d_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
if (Barrier_f_d_ < 0.0)
{
throw new Exception(Pre_string_ + "--- BarrierLevel cannot be less than zero");
}
if (Sigma_f_d_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility cannot be less than zero");
}
}
private double MonteCarloSim(bool is_put)
{
// Use the Brownian Bridge to compute the value of a down and out call option
int seed = 111;
double[] asset_path = new double[TimeSteps_];
double time_step = Time_To_Expiry_ / TimeSteps_;
double sqrt_time_step = System.Math.Sqrt(time_step);
double disc = System.Math.Exp(-DomesticRiskFreeRate_ * Time_To_Expiry_);
PricingUtils.set_seed(seed);
double opt_val = 0.0;
bool not_out = true;
int k = 0;
double STN = 0.0;
double mean = (DomesticRiskFreeRate_ - ForeignRiskFreeRate_
- Sigma_f_d_ * Sigma_f_d_ * 0.5) * time_step;
double std = System.Math.Sqrt(Sigma_f_d_ * Sigma_f_d_ * time_step);
double z;
double sum_opt_vals = 0.0;
for (int i = 0; i < NumberScenarios_; ++i)
{
// generate the asset path
double ST1 = S0_;
not_out = true;
k = 0;
while (not_out && k < TimeSteps_)
{
z = PricingUtils.RndNorm(mean, std);
STN = ST1 * System.Math.Exp(z);
if (STN < BarrierLevel_b_) not_out = false;
ST1 = STN;
asset_path[k] = STN;
++k;
}
if (is_put)
{
opt_val = System.Math.Max(Strike_b_ - STN, 0.0);
}
else
{
opt_val = System.Math.Max(STN - Strike_b_, 0.0);
}
if (not_out)
{ // only has value if asset value is above the barrier_level
// compute the probability that the asset remained above the barrier
if (UseBrownianBridge)
{
double total_probability_above = 1.0, pr;
double sigma_2 = Sigma_f_d_ * Sigma_f_d_;
Code excerpt 8.16 (Continued).

288
Computational Finance Using C and C#
double log_barrier_level = System.Math.Log(BarrierLevel_b_);
double fac;
for (int jj = 0; jj < TimeSteps_ - 1; ++jj)
{
double log_S_i = System.Math.Log(asset_path[jj]);
double log_S_i1 = System.Math.Log(asset_path[jj + 1]);
fac = 2.0 * (log_barrier_level - log_S_i)
* (log_barrier_level - log_S_i1) / (sigma_2 * time_step);
pr = (1.0 - System.Math.Exp(-fac));
// probability of staying above the barrier between i and i+1
total_probability_above *= pr;
}
sum_opt_vals += total_probability_above * opt_val * disc;
}
else
{ // don’t use the Brownian Bridge
sum_opt_vals += opt_val * disc;
}
}
}
double temp = sum_opt_vals / (double)NumberScenarios_;
return temp;
}
}
}
Code excerpt 8.16 (Continued).

Appendix A:
The Greeks for vanilla European
options
A.1
Introduction
In this section we will present some useful results which will be used later on to
derive expressions for the Greeks.
A fundamental result of calculus is that:
∂
∂x

f (x) dx = f (x)
(A.1.1)
Also the indeﬁnite integral,

f (x) dx, can be expressed as a deﬁnite integral
with variable upper bound as follows:

f (x) dx =
 x
a
f (x) dx + c
so
∂
∂x
 y=x
y=a
f (y) dy = f (x)
(A.1.2)
We can now use this result to obtain the derivative of the cumulative distribution
function:
N1(x) =
1
√
2π
 y=x
y=−∞
exp

−y2
2

dy
which gives:
∂N1(x)
∂x
= n(x)
(A.1.3)
where
n(x) =
1
√
2π
exp

−x2
2

We now derive various results for the parameters d1 and d2 which appear in
the Black–Scholes equation:
d1 = log(S/E) + (r −q + σ 2/2)(T −t)
σ√T −t
(A.1.4)

290
Computational Finance Using C and C#
and
d2 = log(S/E) + (r −q −σ 2/2)(T −t)
σ√T −t
= d1 −σ
√
T −t
(A.1.5)
We have:
∂d2
∂S = ∂d1
∂S =
1
Sσ√T −t
(A.1.6)
∂d2
∂σ = ∂d1
∂σ −
√
T −t
(A.1.7)
∂d1
∂r = ∂d2
∂r =
√T −t
σ
(A.1.8)
∂d2
∂t = ∂d1
∂t +
σ
2(T −t)
(A.1.9)
Also:
n(d2) =
1
√
2π
exp

−d2
2
2

=
1
√
2π
exp

−d2
1
2

exp

σd1
√
T −t −σ 2(T −t)
2

= n(d1) exp

log
 S
E

+

r −q + σ 2
2

(T −t) −σ 2(T −t)
2

so
n(d2) = S
E n(d1) exp

r(T −t)

exp

−q(T −t)

(A.1.10)
We note that:
∂N1(d1)
∂S
= ∂N1(d1)
∂d1
∂d1
∂S = n(d1)
1
Sσ√T −t
This technique will be used for computing the Greeks.
A.2
Gamma
Gamma is deﬁned as the second derivative of the option value with respect to
the underlying stock price. This means (see Section A.3) it is the rate of change
of delta with the underlying stock price.
For a European call the value of gamma is:
Γc = ∂2c
∂S2 = ∂Δc
∂S = ∂
∂S

N1(d1) exp

−q(T −t)

where the value of Δc is given in Section A.3. So
Γc = exp

−q(T −t)
∂N1(d1)
∂S
= exp

−q(T −t)

n(d1)∂d1
∂S

Appendix A: The Greeks for vanilla European options
291
Therefore:
Γc =
n(d1)
Sσ√T −t
exp

−q(T −t)

(A.2.1)
The value of gamma for a European put can be calculated similarly:
Γp = ∂2p
∂S2 = ∂Δp
∂S
= ∂
∂S

N1(d1) −1

exp

−q(T −t)

where we have used the value of Δp, derived in Section A.3. Therefore:
Γp = exp

−q(T −t)
∂(N1(d1) −1)
∂S
= exp

−q(T −t)

n(d1)∂d1
∂S
So
Γp = Γc =
n(d1)
Sσ√T −t
exp

−q(T −t)

(A.2.2)
So the value of gamma for both a put and a call is the same.
A.3
Delta
Delta is deﬁned as the rate of change of option value with the underlying stock
price.
For a European call we have:
Δc = ∂c
∂S = ∂
∂S

S exp

−q(T −t)

N1(d1) −E exp

−r(T −t)

N1(d2)

So
Δc = exp

−q(T −t)

N1(d1) + Sn(d1)∂d1
∂S

−E exp

−r(T −t)

n(d2)∂d2
∂S
(A.3.1)
Substituting for n(d2) and ∂d2
∂S we obtain:
Δc = exp

−q(T −t)

N1(d1)
(A.3.2)
In similar manner we have for a European put:
Δp = ∂p
∂S
= ∂
∂S

E exp

−r(T −t)

1 −N1(d2)

−S exp

−q(T −t)

1 −N1(d1)

So
Δp = −E exp

−r(T −t)

n(d2)∂d2
∂S
−exp

−q(T −t)

1 −N1(d1)

+ Sn(d1)∂d1
∂S

(A.3.3)

292
Computational Finance Using C and C#
Substituting for n(d2) and ∂d2
∂S we obtain:
Δp = exp

−q(T −t)

N1(d1) −1

(A.3.4)
A.4
Theta
Theta is deﬁned as the rate of change of the option value with time.
For a European call option we have:
Θc = ∂c
∂t = ∂
∂t

S exp

−q(T −t)

N1(d1) −E exp

−r(T −t)

N1(d2)

= q exp

−q(T −t)

SN1(d1) + exp

−q(T −t)

Sn(d1)∂d1
∂t
−rE exp

−r(T −t)

N1(d2) −E exp

−r(T −t)

n(d2)∂d2
∂t
Substituting for n(d2) and ∂d2
∂t we obtain:
Θc = q exp

−q(T −t)

SN1(d1) −rE exp

−r(T −t)

N1(d2)
+ exp

−q(T −t)

Sn(d1)∂d1
∂t
−E exp

−r(T −t)

n(d1) S
E exp

r(T −t)

× exp

−q(T −t)
∂d1
∂t +
σ
2(T −t)

= q exp

−q(T −t)

SN1(d1)
−rE exp

−r(T −t)

N1(d2) −Sn(d1)σ exp(−q(T −t))
2√T −t
Therefore the value of theta is:
Θc = exp

−q(T −t)

q −SN1(d1) Sn(d1)σ
2√T −t

−rE exp

−r(T −t)

N1(d2)
(A.4.1)
For a put we can similarly show that
Θp = ∂p
∂t = ∂
∂t

E exp

−r(T −t)

1 −N1(d2)

−S exp

−q(T −t)

1 −N1(d1)

Θp = rE exp

−r(T −t)

1 −N1(d2)

−E exp

−r(T −t)

n(d2)∂d2
∂t
−qS exp

−q(T −t)

1 −N1(d1)

+ S exp

−q(T −t)

n(d1)∂d1
∂t
Substituting for n(d2) and ∂d2
∂t we obtain:

Appendix A: The Greeks for vanilla European options
293
Θp = rE exp

−r(T −t)

N1(−d2) −qS exp

−q(T −t)

N1(−d1)
−E exp

−r(T −t)

exp

r(T −t)

× exp

−q(T −t)

n(d1) S
E
∂d1
∂t +
σ
2(T −t)

+ S exp

−q(T −t)

n(d1)∂d1
∂t
So we have:
Θp = −exp

−q(T −t)

qSN1(−d1) + Sn(d1)σ
2
√
T −t

+ rE exp

−r(T −t)

N1(−d2)
(A.4.2)
A.5
Rho
Rho is the rate of change of the option value with interest rate.
For a call we have:
ρc = ∂c
∂r = ∂
∂r

S exp

−q(T −t)

N1(d1) −E exp

−r(T −t)

N1(d2)

= S exp

−q(T −t)

n(d1)∂d1
∂r + E(T −t)N1(d2)
−E exp

−r(T −t)

n(d2)∂d2
∂r
Substituting for n(d2) and ∂d2
∂r we obtain:
ρc = E(T −t)N1(d2)
(A.5.1)
For a European put we have:
ρp = ∂p
∂r
= ∂
∂r

E exp

−r(T −t)

1 −N1(d2)

−S exp

−q(T −t)

1 −N1(d2)

= −E(T −t)

1 −N1(d2)

−E exp

−r(T −t)

n(d2)∂d2
∂r
+ S exp

−q(T −t)

n(d1)∂d1
∂r
= −E(T −t)N1(−d2) −E exp

−r(T −t)

n(d2)∂d2
∂r
+ S exp

−q(T −t)

n(d1)∂d1
∂r
Substituting for n(d2) and ∂d2
∂r we obtain:
ρp = −E(T −t)N1(−d2)
(A.5.2)

294
Computational Finance Using C and C#
A.6
Vega
Vega is the rate of change of option value with volatility. For a call we have:
Vc = ∂c
∂σ
= ∂
∂σ

S exp

−q(T −t)

N1(d1) −E exp

−r(T −t)

N1(d2)

= S exp

−q(T −t)

n(d1)∂d1
∂σ −E exp

−r(T −t)

n(d2)∂d2
∂r
(A.6.1)
Substituting for n(d2) and ∂d2
∂σ we obtain:
Vc = S exp

−q(T −t)

n(d1)∂d1
∂σ
−Sn(d1) exp

−q(T −t)
∂d1
∂σ −
√
T −t

Therefore
Vc = S exp

−q(T −t)

n(d1)
√
T −t
(A.6.2)
For a European put we have:
Vp = ∂c
∂σ
= ∂
∂σ

E exp

−r(T −t)

1 −N1(d2)

−S exp

−q(T −t)

1 −N1(d1)

= −E exp

−r(T −t)

n(d2)∂d2
∂σ + S exp

−q(T −t)

n(d1)∂d1
∂σ
Substituting for n(d2) and ∂d2
∂σ we obtain:
Vp = S exp

−q(T −t)

n(d1)
√
T −t
(A.6.3)
which is the same as for a call.

Appendix B:
Barrier option integrals
B.1
The down and out call
We will now derive the formula for the value cdo of a European down and out
call option with dividend yield q when the strike, E, satisﬁes E > B.
cdo = exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)

S exp(X) −E

f (X > B) dX
(B.1.1)
Substituting for f (X > B) we have cdo = IA + IB where:
IA = exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)

S exp(X) −E

× exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

dX
and
IB = −exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)

S exp(X) −E

× exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

× exp
2 log(B/S)(X −log(B/S))
σ 2τ

dX
Now comparing IA with Eq. (4.4.54) we can identify IA as c, the price of a
European call. That is:
IA = S exp(−qτ)N1(d1) −E exp(−rτ)N1(d2)
(B.1.2)
where:
d1 = log(S/E) + (r −q + σ 2/2)τ
σ√τ
d2 = log(S/E) + (r −q −σ 2/2)τ
σ√τ
We now consider the term IB, and let IB = IC + ID where:

296
Computational Finance Using C and C#
IC = −S exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp(X) exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

× exp
2 log(B/S)(X −log(B/S))
σ 2τ

dX
and
ID = E exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

× exp
2 log(B/S)(X −log(B/S))
σ 2τ

dX
We will ﬁrst consider ID and factor the integrand as follows:
−exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

exp
2 log(B/S)(X −log(B/S))
σ 2τ

= exp

−{X −(r −q −σ 2/2)τ}2 −4 log(B/S)(X −log(B/S))
2σ 2τ

= exp

−{X −(r −q −σ 2/2)τ −2 log(B/S)}2
2σ 2τ

× exp
4(r −q −σ 2/2)τ log(B/S)
2σ 2τ

(B.1.3)
This means that ID can be expressed as:
∴ID =
B
S
2((r−q)σ 2/2)/σ 2 E exp(−rτ)
σ√τ
√
2π
×
 ∞
X=log(E/S)
exp

−{X −(r −qσ 2/2)τ −2 log(B/S)}2
2σ 2τ

dX
Letting u = (X −(r −q −σ 2/2)τ −2 log(B/S))/(σ√τ) we have dX = σ√τ du
and
ID =
B
S
2(r−q−σ 2/2)/σ 2 E exp(−rτ)
σ√τ
√
2π
 ∞
u=k3
exp

−u2
2

du
where
k3 = log(E/S) −(r −q −σ 2/2)τ −2 log(B/S)
σ√τ
= log(ES/B2) −(r −q −σ 2/2)τ
σ√τ
So
ID =
B
S
2r/σ 2−1
E exp(−rτ)N1(−k3)
(B.1.4)

Appendix B: Barrier option integrals
297
Letting d3 = −k3 we have:
d3 = log(B2/SE) + (r −q −σ 2/2)τ
σ√τ
and
ID =
B
S
2r/σ 2−1
E exp(−rτ)N1(d3)
(B.1.5)
Now consider the term:
IC = S exp(−rτ)
σ√τ
√
2π
 ∞
X=log(E/S)
exp(X) exp

−{X −(r −σ 2/2)τ}2
2σ 2τ

× exp
2 log(B/S)(X −log(B/S))
σ 2τ

dX
Now we have
exp(X) exp

−(X −(r −q −σ 2/2)τ)2
2σ 2τ

exp
2 log(B/S)(X −log(B/S))
σ 2τ

= exp

−

X −

−qr −σ 2/2

τ
2 −2σ 2τX
−4 log(B/S)X + 4

log(B/S)
2
/

2σ 2τ

= exp

σ 2τ
2 + 2

r −q −σ 2/2

τ 2σ 2
+ 4

r −q −σ 2/2

τ log(B/S) + 4σ 2τ log(B/S)

/

2σ 2τ

× exp
−{X −(r −q −σ 2/2)τ −σ 2τ −2 log(B/S)}2
2σ 2τ

= exp

(r −q)τ

exp
2(r −q)
σ 2
+ 1

log
B
S

× exp
−{X −(r −q −σ 2/2)τ −σ 2τ −2 log(B/S)}2
2σ 2τ

= exp

(r −q)τ
B
S
2(r−q)/σ 2+1
× exp
−{X −(r −q −σ 2/2)τ −σ 2τ −2 log(B/S)}2
2σ 2τ

So we have:
IC = −
B
S
2(r−q)/σ 2+1 S exp(−qτ)
σ√τ
√
2π
×
 ∞
X=log(E/S)
exp

−

X −

r −q −σ 2/2

τ −σ 2τ −2 log(B/S)
2
×

2σ 2τ
−1
dX

298
Computational Finance Using C and C#
Letting
u = X −(r −q −σ 2/2)τ −σ 2τ −2 log(B/S)
σ√τ
we have dX = σ√τ du and
IC = −S exp(−qτ)
B
S
2(r−q)/σ 2+1
N1(−k4)
(B.1.6)
where
k4 = log(E/S) −(r −q −σ 2/2)τ −σ 2τ −2 log(B/S)
σ√τ
= log(ES/B2) −(r −q + σ 2/2)τ
σ√τ
∴IC = −S exp(−qτ)
B
S
2(r−q)/σ 2+1
N1(−k4)
or letting d4 = −k4 we have
d4 = log(B2/ES) + (r −q + σ 2/2)τ
σ√τ
IC = −S exp(−qτ)
B
S
2(r−q)/σ 2+1
N1(d4)
(B.1.7)
Therefore the value for the down and out call option is:
cdo = IA + IC + ID = IA −(−IC −ID)
Since cdo + cdi = c, where c is the value of vanilla call and cdi is the value of
down and in call, we can write:
cdo = c −cdi
where
cdi = S exp(−qτ)N1(d4)
B
S
2(r−q)/σ 2+1
−E exp(−rτ)N1(d3)
B
S
2(r−q)/σ 2−1
B.2
The up and out call
We will now derive the formula for a European up and out call option with
dividend yield q when the strike, E, satisﬁes B > E.
cuo = exp(−rτ)
σ√τ
√
2π
 log(B/S)
X=log(E/S)

S exp(X) −E

f (X < B) dX
(B.2.1)

Appendix B: Barrier option integrals
299
Substituting for f (X < B) we have cuo = IA + IB where:
IA = exp(−rτ)
σ√τ
√
2π
 log(B/S)
X=log(E/S)

S exp(X) −E

× exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

dX
and
IB = −exp(−rτ)
σ√τ
√
2π
×
 log(B/S)
X=log(E/S)

S exp(X) −E

exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

× exp
2 log(B/S)(X −log(B/S))
σ 2τ

dX
Letting IA = I1 + I2 where
I1 = S exp(−rτ)
σ√τ
√
2π
 log(B/S)
X=log(E/S)
exp(X) exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

dX
and
I2 = −E exp(−rτ)
σ√τ
√
2π
 log(B/S)
X=log(E/S)
exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

dX
From our previous derivation of the Black–Scholes formula in Chapter 4 we
have:
I1 = S exp(−qτ)
σ√τ
√
2π
 k2
u=k1
exp

−u2
2

du = S exp(−qτ)

N1(k2) −N1(k1)

where
k1 = log(E/S) −(r −q + σ 2/2)τ
σ√τ
and
k2 = log(B/S) −(r −q + σ 2/2)τ
σ√τ
I2 = −E exp(−rτ)
σ√τ
√
2π
 k4
u=k3
exp

−u2
2

du = −E exp(−rτ)

N1(k4) −N1(k3)

where
k3 = log(E/S) −(r −q −σ 2/2)τ
σ√τ
and
k4 = log(B/S) −(r −q −σ 2/2)τ
σ√τ

300
Computational Finance Using C and C#
Therefore,
IA = S exp(−qτ)

N1(k2) −N1(k1)

−E exp(−rτ)

N1(k4) −N1(k3)

Since N1(−x) = 1 −N1(x) we have
N1(k2) −N1(k1) = N1(−k1) −N1(−k2)
so
IA = S exp(−qτ)

N1(d1) −N1(d2)

−E exp(−rτ)

N1(d3) −N1(d4)

= S exp(−qτ)N1(d1) −E exp(−rτ)N1(d3)
−S exp(−qτ)N1(d2) + E exp(−rτ)N1(d4)
which gives:
IA = c −S exp(−qτ)N1(d2) + E exp(−rτ)N1(d4)
(B.2.2)
where c is the value of a vanilla call and
d1 = log(S/E) + (r −q + σ 2/2)τ
σ√τ
,
d2 = log(S/B) + (r −q + σ 2/2)τ
σ√τ
d3 = log(S/E) + (r −q −σ 2/2)τ
σ√τ
,
d4 = log(S/B) + (r −q −σ 2/2)τ
σ√τ
Letting IB = IC + ID where:
IC = −S exp(−rτ)
σ√τ
√
2π
 log(B/S)
X=log(E/S)
exp(X) exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

× exp
2 log(B/S)(X −log(B/S))
σ 2τ

dX
and
ID = E exp(−rτ)
σ√τ
√
2π
 log(B/S)
X=log(E/S)
exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

× exp
2 log(B/S)(X −log(B/S))
σ 2τ

dX
In a similar manner to that in Section B.1 we have:
ID =
B
S
2(r−q−σ 2/2)/σ 2 E exp(−rτ)
σ√τ
√
2π
×
 log(B/S)
X=log(E/S)
exp

−{X −(r −q −σ 2/2)τ −2 log(B/S)}2
2σ 2τ

dX
Letting
u = X −(r −q −σ 2/2)τ −2 log(B/S)
σ√τ

Appendix B: Barrier option integrals
301
gives
ID =
B
S
2(r−q−σ 2/2)/σ 2 E exp(−rτ)
σ√τ
√
2π
 k6
u=k5
exp

−u2
2

du
(B.2.3)
where
k5 = log(E/S) −(r −q −σ 2/2)τ −2 log(B/S)
σ√τ
= log(ES/B2) −(r −q −σ 2/2)τ
σ√τ
and
k6 = log(B/S) −(r −q −σ 2/2)τ −2 log(B/S)
σ√τ
= log(S/B) −(r −q −σ 2/2)τ
σ√τ
and so
ID =
B
S
2(r−q)/σ 2−1
E exp(−rτ)

N1(k6) −N1(k5)

This can be re-expressed as:
ID =
B
S
2(r−q)/σ 2−1
E exp(−rτ)

N1(d5) −N1(d6)

(B.2.4)
where
d5 = log(B2/ES) −(r −q −σ 2/2)τ
σ√τ
d6 = log(B/S) + (r −q −σ 2/2)τ
σ√τ
We now consider the term:
IC = −S exp(−rτ)
σ√τ
√
2π
 log(B/S)
X=log(E/S)
exp(X) exp

−{X −(r −q −σ 2/2)τ}2
2σ 2τ

× exp
2 log(B/S)(X −log(B/S))
σ 2τ

dX
In a similar manner to Section B.1 we let
u = X −(r −q −σ 2/2)τ −σ 2τ −2 log(B/S)
σ√τ
which gives:
IC = −S exp(−rτ)
B
S
2(r−q)/σ 2+1
N1(k8) −N1(k7)


302
Computational Finance Using C and C#
where
k7 = log(E/S) −(r −q −σ 2/2)τ −σ 2τ −2 log(B/S)
σ√τ
= log(ES/B2) −(r −q + σ 2/2)τ
σ√τ
and
k8 = log(B/S) −(r −q −σ 2/2)τ −σ 2τ −2 log(B/S)
σ√τ
= log(S/B) −(r −q + σ 2/2)τ
σ√τ
This can be re-expressed as:
IC = −S exp(−rτ)
B
S
2(r−q)/σ 2+1
N1(d7) −N1(d8)

where
d7 = log(B2/ES) + (r −q + σ 2/2)τ
σ√τ
,
d8 = log(B/S) + (r −q + σ 2/2)τ
σ√τ
So we have:
cuo = IA + IC + ID
which can be written as:
cuo = c −cui
where c is the value of a vanilla call and cui, the value of an up and in call, is
given by:
cui = S exp(−qτ)N1(d2) −E exp(−rτ)N1(d4)
−E exp(−rτ)

N1(d5) −N1(d6)
B
S
2(r−q)/σ 2−1
+ S exp(−rτ)

N1(d7) −N1(d8)
B
S
2(r−q)/σ 2+1
(B.2.5)

Appendix C:
Standard statistical results
C.1
The law of large numbers
Let x1, x2, . . . be a sequence of independent, identically distributed random vari-
ables (IID), each with expected value μ and variance σ 2. Deﬁne the sequence of
averages
yn =

n
i=1 xi
n
= x1 + x2 + · · · + xn
n
,
n = 1, 2, . . .
Then the law of large numbers states that yn converges to μ as n →∞, that is
Var[yn] →0.
The mean of yn is:
E[yn] = 1
n

E[x1] + E[x2] + · · · + E[xn]

= 1
nnμ = μ
For the variance of yn we have:
Var[yn] = Var

n
i=1 xi
n

= 1
n2 Var
 n

i=1
xi
	
= 1
n2
n

i=1
Var[xi] = 1
n2 nσ 2 = σ 2
n
where we have used the fact that the variance of the sum of independent random
variables is the sum of their variances; see Section C.2.
We have therefore shown that as n →∞, Var[yn] →0.
C.2
The central limit theorem
Let x1, x2, . . . be a sequence of independent, identically distributed random vari-
ables (IID), each with expected value μ and variance σ 2. If we deﬁne ui = xi −μ
then:
E[ui] = E[u] = 0,
Var[ui] = E

u2
= σ 2

304
Computational Finance Using C and C#
Let
sn =
n

i=1
ui + nμ
So
sn =
n

i=1
xi
We now introduce the normalized value zn, as follows:
zn = sn −nμ
σ√n
=
1
σ√n
n

i=1
ui
The central limit theorem states that as n tends to inﬁnity the probability distri-
bution of zn tends to a normal distribution with zero mean and unit variance;
mathematically zn →N(0, 1) as n →∞.
Proof. From Section C.5, Eq. (C.5.3)
Mzn = E

exp(tzn)

= E

exp

t
σ√n
n

i=1
ui
	
and using Eq. (C.5.5)
Mzn =

Mu

t
σ√n
n
Equation (C.5.1) then yields:
Mu

t
σ√n

≈1 +
t
σ√nE[u] + 1
2

t
σ√n
2
E

u2
+ · · ·
As n →∞,
t
σ√n →0 and
Mu

t
σ√n

→1 +
t
σ√nE[u] + 1
2

t
σ√n
2
E

u2
= 1 + t2
2n
Thus 
Mu

t
σ√n
n
=

1 + t2
2n
n
→1 + t2
2
as n →∞
where we have used the fact that t ≪1; see Grimmett and Welsh (1986).
We have therefore shown that as n →∞
Mzn(t) →1 + t2
2 →et2/2
However, from Section D.1 the moment generating function Mz(t) for a stan-
dard normal distribution (μ = 0, σ 2 = 1) is:
Mz(t) = et2/2
where z ∼N(0, 1)
Thus we have proved that zn →N(0, 1) as n →∞.
□

Appendix C: Standard statistical results
305
C.3
The variance and covariance of random variables
C.3.1
Variance
One variable
Let X be a variate from a given distribution, and Z be the following linear
function of this variate:
Z = a + bX
where and a and b are constants. Then
E[Z] = E[a] + E[bX] = a + bE[X]
and
Var[Z] = E

Z −E[Z]
2
= E

a + bX −a −bE[X]
2
= E

bX −bE[X]
2
= E

b2
X −E[X]
2
= b2E

X −E[X]
2
Therefore the mean is a + bE[X], and the variance is b2 Var[X].
Two variables
Let Z = a + b1X1 + b2X2, where a, b1 and b2 are constants.
Then the mean is E[Z] = E[a]+E[b1X1]+E[b2X2] = a+b1E[X1]+b2E[X2].
The variance Var[Z] is computed as follows:
Var[Z] = E

a + b1X1 + b2X2 −a −b1E[X1] −b2E[X2]
2
= E

b1

X1 −E[X1]

+ b2

X2 −E[X2]
2
= b2
1E

X1 −E[X1]
2
+ b2
2E

X2 −E[X2]
2
+ 2b1b2E

X1 −E[X1]

E

X2 −E[X2]

= b2
1 Var[X1] + b2
2 Var[X2] + 2b1b2 Cov[X1, X2]
where Cov[X1, X2] is the covariance between X1 and X2. If X1 and X2 are iden-
tical independently distributed random variables (IID) then Cov[X1, X2] = 0,
and we thus have:
Var[Z] = b2
1 Var[X1] + b2
2 Var[X2]

306
Computational Finance Using C and C#
Three variables
Let Z = a + b1X1 + b2X2 = b3X3, where a, b1, b2 and b3 are constants.
Then the mean is E[Z] = E[a]+E[b1X1]+E[b2X2]+E[b3X3] = a+b1E[X1]+
b2E[X2] + b3E[X3].
The variance Var[Z] is computed as follows:
Var[Z] = E

a + b1X1 + b2X2 + b3X3 −a
−b1E[X1] −b2E[X2] −b3E[X3]
2
= E

b1

X1 −E[X1]

+ b2

X2 −E[X2]

+ b3

X3 −E[X3]
2
= b2
1E

X1 −E[X1]
2
+ b2
2E

X2 −E[X2]
2
+ b2
3E

X3 −E[X3]
2
+ 2b1b2E

X1 −E[X1]

E

X2 −E[X2]

+ 2b2b3E

X2 −E[X2]

E

X3 −E[X3]

+ 2b1b3E

X1 −E[X1]

E

X3 −E[X3]

= b2
1 Var[X1] + b2
2 Var[X2] + b2
3 Var[X2] + 2b2b3 Cov[X2, X3]
+ 2b1b2 Cov[X2, X3] + 2b1b3 Cov[X1, X3]
If X1, X2 and X3 are IID all the covariance terms are zero and the variance is:
Var[Z] = b2
1 Var[X1] + b2
2 Var[X2] + b2
3 Var[X3]
Variance of n variables
We will now derive an expression for the sum of n IID random variables.
Let Z = a + 
n
i=1 biXi, where a and bi, i = 1, . . . , n, are constants.
Then we have: E[Z] = E[a] + E[
n
i=1 biXi] = a + 
n
i=1 biE[Xi] and
Var[Z] = E

a +
n

i=1
biXi −a −
n

i=1
biE[Xi]
2	
= E
 n

i=1
biXi −
n

i=1
biE[Xi]
2	
= E
 n

i=1
bi

Xi −E[Xi]

2	
=
n

i=1
b2
i E

Xi −E[Xi]
2
+
n

i=1
n

j=1(j̸=i)
bibjE

Xi −E[Xi]

Xj −E[Xj]


Appendix C: Standard statistical results
307
=
n

i=1
b2
i Var[Xi] +
n

i=1
n

j=1(j̸=i)
bibj Cov[Xi, Xj]
As before if all the X variables are IID then the covariance terms are zero, and
we have:
Var[Z] =
n

i=1
b2
i Var[xi]
If in addition all the bi terms are one and all the X variable have variance σ 2 we
obtain:
Var[Z] =
n

i=1
Var[xi] = nσ 2
C.3.2
Covariance
The covariance between two variables X and Y is deﬁned by:
Cov[X, Y] = E

X −E[X]

Y −E[Y]

= E

XY −YE[X] −XE[Y] + E[X]E[Y]

= E[XY] −E[Y]E[X] −E[X]E[Y] + E[X]E[Y]
= E[XY] −E[X]E[Y]
By symmetry it can be seen that Cov[X, Y] = Cov[Y, X].
Two variables
Let Z1 = a + bX and Z2 = c + dY, where a, b, c and d are constants.
We have:
Cov[Z1, Z2] = Cov[a + bX, c + dY]
= E

(a + bX)(c + dY)

−E

(a + bX)

E

(c + dY)

= E[ac + bcX + adY + bdXY] −

a + bE[X]

c + dE[Y]

= ac + bcE[X] + adE[Y] + bdE[XY]
−ac + bcE[X] −adE[Y] −bdE[X]E[Y]
= bd

E[XY] −E[X]E[Y]

∴Cov[Z1, Z2] = bd Cov[X, Y]
Three variables
Let Z1 = a+b1X1+b2X2 and Z2 = c+dY, where a, b1, b2, c and d are constants.

308
Computational Finance Using C and C#
We have:
Cov[Z1, Z2] = Cov[a + b1X1 + b2X2, c + dY]
= E

(a + b1X1 + b2X2)(c + dY)

−E

(a + b1X1 + b2X2)

E

(c + dY)

= E

(a + b1X1)(c + dY) + b2X2(c + dY)

−

E

(a + b1X1)

E[c + dY] + E[b2X2]E[c + dY]

= E

(a + b1X1)(c + dY)

+ E

b2X2(c + dY)

−E

(a + b1X1)

E[c + dY] −E[b2X2]E[c + dY]
=

E

(a + b1X1)(c + dY)

−E

(a + b1X1)

E[c + dY]

−

E

(b2X2)(c + dY)

−E[b2X2)]E[c + dY]

∴Cov[Z1, Z2] = b1d Cov[X1, Y] + b2d Cov[X2, Y]
Four variables
Let Z1 = a + b1X1 + b2X2 + b3X3 and Z2 = c + dY, where a, b1, b2, b3, c and d
are constants.
We have:
Cov[Z1, Z2] = Cov[a + b1X1 + b2X2 + b3X3, c + dY]
= E

(a + b1X1 + b2X2 + b3X3)(c + dY)

−E

(a + b1X1 + b2X2 + b3X3)

E

(c + dY)

= E

(a + b1X1 + b2X2)(c + dY) + b3X3(c + dY)

−

E

(a + b1X1 + b2X2)

E[c + dY] + E[b3X3]E[c + dY]

= E

(a + b1X1 + b2X2)(c + dY)

+ E

b3X3(c + dY)

−E

(a + b1X1 + b2X2)

E[c + dY] −E[b3X3]E[c + dY]
=

E

(a + b1X1 + b2X2)(c + dY)

−E

(a + b1X1 + b2X2)

E[c + dY]

+

E

(b3X3)(c + dY)

−E[b3X3]E[c + dY]

= Cov

(a + b1X1 + b2X2), c + dY

+ Cov[b3X3, c + dY]
∴Cov[Z1, Z2] = b1d Cov[X1, Y] + b2d Cov[X2, Y] + b3d Cov[X3, Y]
Covariance of n variables
In a similar manner to that outlined above:
Cov

a +
n

i=1
biXi, c + dY
	
= d
n

i=1
bi Cov[Xi, Y]

Appendix C: Standard statistical results
309
For the most general case let: Z1 = a + 
n
i=1 biXi and Z2 = c + 
M
j=1 bjYj.
So
Cov[Z1, Z2] = Cov

a +
n

i=1
biXi, c +
M

j=1
djYj
	
= Cov

a +
n

i=1
biXi, c +
M

j=1
djYj
	
So
Cov

a +
n

i=1
biXi, c +
M

j=1
djYj
	
=
n

i=1
Cov

biXi,
M

j=1
djYj
	
=
n

i=1
bi Cov

Xi,
M

j=1
djYj
	
=
n

i=1
bi Cov
 M

j=1
djYj, Xi
	
∴Cov[Z1, Z2] =
n

i=1

bi
M

j=1
dj Cov[Yj, Xi]

C.3.3
Covariance matrix
Let X denote the n element vector containing the random variates Xi, i =
1, . . . , n. The mean and variance of the ith variate is then E[Xi] and E[(Xi −
E[Xi])2] respectively. The covariance Cov[X]ij between the ith and jth vari-
ates is E[(Xi −E[Xi])(Xj −E[Xj])]. The elements of n by n covariance matrix
Cov[X] are then:
Cov[X]ij = E

Xi −E[Xi]

Xj −E[Xj]

,
i = 1, . . . , n, j = 1, . . . , n
(C.3.1)
We will now show that Cov[X + A] = Cov[X] where A is an n element vector
containing the constants Ai, i = 1, . . . , n. Since E[Xi + Ai] = E[Xi] + Ai we
obtain:
Var

(X + A)i

= Var[Xi + Ai]
= E

Xi + Ai −E[Xi + Ai]
2
= E

Xi −E[Xi]
2
and
Cov[X + A]ij = E

Xi + Ai −E[Xi + Ai]

Xj + Aj −E[Xj + Aj]

= E

Xi −E[Xi]

Xj −E[Xj]

= Cov[X]ij
(C.3.2)

310
Computational Finance Using C and C#
C.4
Conditional mean and covariance of normal
distributions
Let X = [ X1
X2 ] be distributed as Np(μ, Σ) with μ = [ μ1
μ2 ], and Σ = [ Σ11
Σ12
Σ21
Σ22 ],
and |Σ22| > 0.
We will prove that the conditional distribution of X1, given that X2 = x2, is
normal and has:
Mean = μes1 + Σ11Σ−1
22 (x2 −μ2), and covariance = Σ11 −Σ12Σ−1
22 Σ21.
Let the inverse of Σ be Σ−1, where:
Σ−1 =

Σ11
Σ12
Σ21
Σ22

(C.4.1)
So Σ−1Σ = Ip, where Ip represents the p × p unit matrix, and:

Σ11
Σ12
Σ21
Σ22
 
Σ11
Σ12
Σ21
Σ22

=

Iq
0
0
Ip−q

(C.4.2)
Multiplying out these matrices yields the following equations:
Σ11Σ11 + Σ21Σ21 = Iq
(C.4.3)
Σ21Σ11 + Σ22Σ22 = 0
(C.4.4)
Σ11Σ12 + Σ12Σ22 = 0
(C.4.5)
Σ21Σ12 + Σ22Σ22 = Ip−q
(C.4.6)
Multiplying Eq. (C.4.5) on the left by (Σ11)−1 and on the right by Σ−1
22 gives:

Σ11−1Σ12 = −Σ12Σ−1
22
(C.4.7)
Multiplying Eq. (C.4.3) on the left by (Σ11)−1 yields
Σ11 +

Σ11−1Σ12Σ21 = (Σ11)−1
(C.4.8)
and substituting for (Σ11)−1Σ12 from Eq. (C.4.7) into Eq. (C.4.8) gives
(Σ11)−1 = Σ11 −Σ12Σ−1
22 Σ21
(C.4.9)
The joint probability density function of x is:
f (x) = (2π)−p/2|Σ|−1/2 exp

−1
2(x −μ)⊤Σ−1(x −μ)

writing x, μ and Σ−1 in their partitioned form and expanding gives:
f (x) = (2π)−p/2|Σ|−1/2
× exp

−1
2

(x1 −μ1)⊤Σ11(x1 −μ1) + 2(x1 −μ1)⊤Σ12(x2 −μ2)
+ (x2 −μ2)⊤Σ22(x2 −μ2)

(C.4.10)

Appendix C: Standard statistical results
311
The conditional distribution of x1 given the value of x2 is thus obtained by
dividing this density by the marginal density of x2, and treating x2 as a constant
in the resulting expression. The only portion of the resultant that is not constant
is the portion involving terms in x1. It can easily be shown that:
f (x1|x2) ∝exp

−1
2

(x1 −μ1)⊤Σ11(x1 −μ1)
+ 2(x1 −μ1)⊤Σ12(x2 −μ2)

where the constant of proportionality is obtained using

f (x1|x2) dx1 = 1.
If we let G = (x1 −μ1)⊤Σ11(x1 −μ1) + 2(x1 −μ1)⊤Σ12(x2 −μ2) we then
obtain:
G = (x1 −μ1)⊤Σ11(x1 −μ1) + (x1 −μ1)⊤Σ12(x2 −μ2)
+ (x2 −μ2)⊤Σ21(x1 −μ1)
G =

x1 −μ1 +

Σ11−1Σ12(x2 −μ2)
⊤
× Σ11
x1 −μ1 +

Σ11−1Σ12(x2 −μ2)

−(x2 −μ2)⊤Σ21
Σ12−1(x2 −μ2)
(C.4.11)
where, for instance, we have used the fact that the scalar quantity

(x1 −μ1)⊤Σ12(x2 −μ2)

= (x2 −μ2)⊤Σ21(x1 −μ1)
Since the last term in Eq. (C.4.11) only involves constants (as far as f (x1|x2) is
concerned), it follows that:
f (x1|x2) ∝exp

−1
2

x1 −μ1 +

Σ11−1Σ12(x2 −μ2)
⊤
× Σ11
x1 −μ1 +

Σ11−1Σ12(x2 −μ2)

which is the density of a multivariate normal distribution that has a mean of
μ1 −(Σ11)−1Σ12(x2 −μ2), which from Eq. (C.4.7) can be expressed as μ1 +
Σ12Σ−1
22 (x2 −μ2). The covariance matrix is (Σ11)−1, which from Eq. (C.4.9)
can be written as Σ11 −Σ12Σ−1
22 Σ21.
C.5
Moment generating functions
If x is a random variable with probability distribution fx(x) then the moment
generating function Mx(t) is deﬁned by:
Mx(t) = E

etx
=
 ∞
−∞
etxfx(x) dx

312
Computational Finance Using C and C#
We can expand the above expression as follows:
E

etx
= E

1 + tx + 1
2(tx)2 + · · ·

Mx(t) = 1 + tE[x] + 1
2t2E

x2
+ · · ·
(C.5.1)
Now
dk(Mx(t))
dtk
= dk
dtk

E

etx
= E
dketx
dtk

= E

xketx
For t = 0 we thus have:
dk(Mx(t))
dtk
    
t=0
= dk(Mx(0))
dtk
= E

xke0
= E

xk
(C.5.2)
Moment generating function of a linear function of a random variable x
If the random variable y is deﬁned as: y = ax + b then the moment generating
function of y, My(t) is obtained as follows:
My(t) = Max+b(t) = E

ety
= E

eatx+bt
= ebtE

etx
Therefore:
My(t) = ebtMx(at)
(C.5.3)
Moment generating function of a linear combination of random variables
Let z = x + y where x and y are independent random variables. Then
Mz(t) = E

etz
= E

ex+y
= E

etxety
Since x and y are independent:
E

etxety
= E

etx
E

ety
= Mx(t)My(t)
More generally if sn = 
n
i=1 xi where xi, i = 1, . . . , n, are independent variables
then:
Msn(t) =
n

i=1
Mxi(t)
(C.5.4)
If xi, i = 1, . . . , n, are IID then we have
Msn(t) = E

exp

t
n

i=1
xi
	
=

E

etxn =

Mx(t)
n
(C.5.5)

Appendix D:
Statistical distribution functions
D.1
The normal (Gaussian) distribution
Here we describe some properties of the normal distribution. If x comes from a
normal distribution, then the associated moment generating function, Mx(t), is
given by:
Mx(t) = E

etx
=
1
σ
√
2π
 ∞
−∞
exp(tx) exp

−(x −μ)2
2σ 2

dx
=
1
σ
√
2π
 ∞
−∞
exp

−(x −μ)2 −2σ 2tx
2σ 2

dx
Now completing the square we have:
−1
2σ 2

(x −μ)2 −2tσ 2x

= −1
2σ 2

x2 + μ2 −2μx −2tσ 2
= −1
2σ 2

x −σ 2t −μ
2 −2μtσ 2 −σ 4t2
= μt + σ 2t2
2
−
1
2σ 2

x −σ 2t −μ
2
We thus have:
E

etx
=
1
σ
√
2π
exp

μt + σ 2t2
2
  x=∞
x=−∞
exp

−(x −σ 2t −μ)2
2σ 2

dx
Now letting y = x −σ 2t −μ, dx = dy and
E

etx
=
1
σ
√
2π
exp

μt + σ 2t2
2
  y=∞
y=−∞
exp

−y2
2σ 2

dy
=
1
σ
√
2π
σ
√
2π exp

μt + σ 2t2
2

= exp

μt + σ 2t2
2


314
Computational Finance Using C and C#
where we have used (see Section E.1) the fact that
 ∞
−∞
exp

−ay2
dy =
π
a
Thus the moment generating function Mx(t) for a normal distribution with
mean μ and variance σ 2 is:
Mx(t) = exp

μt + σ 2t2
2

D.1.1
Some elementary results involving the mean and variance of
a normal distribution
From ﬁrst principles we have:
• The mean:
E[x] =
1
σ
√
2π
 x=∞
x=−∞
x exp

−(x −μ)2
2σ 2

dx
Letting y = x −μ we have dx = dy and x = y + μ; therefore:
E[x] =
1
σ
√
2π
 y=∞
y=−∞
(y + μ) exp

−y2
2σ 2

dy
E[x] = μ
1
σ
√
2π
 y=∞
y=−∞
exp

−y2
2σ 2

dy
+
1
σ
√
2π
 y=∞
y=−∞
y exp

−y2
2σ 2

dy
Since
 ∞
−∞
y exp

−y2
2σ 2

dy = 0
we have using the integral result (i) in Section E.1 with a = 1/(2σ 2):
E[x] = μ
1
σ
√
2π
 ∞
−∞
exp

−y2
2σ 2

dy = μ
• The variance:
E

x2
=
1
σ
√
2π
 x=∞
x=−∞
x2 exp

−(x −μ)2
2σ 2

dx
Letting y = x −μ we have dx = dy and x2 = y2 + 2μy + μ2; therefore:
E

x2
=
1
σ
√
2π
 y=∞
y=−∞

y2 + 2μy + μ2
exp

−y2
2σ 2

dy

Appendix D: Statistical distribution functions
315
E

x2
= μ2
1
σ
√
2π
 ∞
−∞
exp

−y2
2σ 2

dy
+
1
σ
√
2π
 y∞
−∞
y2 exp

−y2
2σ 2

dy
So
E

x2
= μ2 + σ 2
where we have used (see Section E.1 result (ii) with a = 1/(2σ 2)) that
1
σ
√
2π
 ∞
−∞
y2 exp

−y2
2σ 2

dy = σ 2
Therefore:
Var[x] = E

x2
−

E[x]
2 = μ2 + σ 2 −μ2 = σ 2
The mean and variance can also be obtained by using the moment generating
function, Mx(t).
From Section C.5:
E[x] = dMx(t)
dt
    
t=0
= d
dt

exp

μt + σ 2t2
2

t=0
=

μ + σ 2t

exp

μt + σ 2t2
2
    
t=0
= μ
also
E

x2
= d2Mx(t)
dt2
    
t=0
= d
dt

μ + σ 2t

exp

μt + σ 2t2
2

t=0
E

x2
=

exp

μt + σ 2t2
2

μ + μσ 2t
2 + σ 2

t=0
= μ2 + σ 2
These results are the same as those we previously derived from ﬁrst principles:
E[x] = μ
and
E

x2
= μ2 + σ 2
D.2
The lognormal distribution
If the variable x follows a lognormal distribution then the probability density
function f (x) is given by:
1
xσ
√
2π
exp

−(log(x) −μ)2
2σ 2

(D.2.1)
where x > 0. Here we denote the lognormal distribution for x as: x ∼(μ, σ 2).
Setting y = log(x) it can be seen that y ∼N(μ, σ 2). Thus if x is a lognormal

316
Computational Finance Using C and C#
distribution (μ, σ 2) then log(x) is a normal distribution with mean μ and
variance σ 2. Conversely if y ∼N(μ, σ 2) then the distribution for x = ey is
x ∼(μ, σ 2).
The expectation of the tth moment (where t is a positive integer) of x is thus:
E

xt
=
1
σ
√
2π
 x=∞
x=−∞
xt 1
x exp

−(log(x) −μ)2
2σ 2

dx
Using y = log(x) we have:
dy
dx = d log(x)
dx
= 1
x ,
dx = x dy,
and
xt =

eyt = ety
Thus,
E

xt
= E

ety
= My(t) =
1
σ
√
2π
 y=∞
y=−∞
ety exp

−(y −μ)2
2σ 2

dy
where My(t) is the moment generating function of a normal distribution with
mean μ and variance σ 2.
From Section D.1:
E

xt
= My(t) = exp

μt + σ 2t2
2

Therefore if x ∼(μ, σ 2) then:
For t = 1
E[x] = exp

μ + σ 2
2

(D.2.2)
for t = 2
E

x2
= exp

2μ + 2σ 2
(D.2.3)
and the variance is obtained using
Var[x] = E

x2
−

E[x]
2 = exp

2μ + 2σ 2
−exp

2μ + σ 2
So
Var[x] = exp

2μ + σ 2
exp

σ 2
−1

or
Var[x] =

E[x]
2
exp

σ 2
−1

(D.2.4)
Note. If x1 = exp(μ + σZ), where Z ∼N(0, 1) then x1 ∼(μ, σ 2). So E[x1]
and Var[x1] are given by Eqs. (D.2.2) and (D.2.4).

Appendix D: Statistical distribution functions
317
D.3
The Student’s t distribution
This section derives an expression for the kurtosis of the Student’s t distribution.
Since the Student’s t distribution density function is:
f (ϵi) = K

1 +
ϵi2
hi(ν −2)
−(ν+1)/2
where
K = ((ν + 1)/2)(ν −2)−1/2h−1/2
i
π1/2(ν/2)
we have:
E

ϵ2
i

= 2K
 ∞
0
ϵ2
i dϵi
(1 + ϵ2
i /(hi(ν −2)))(ν+1)/2
= 2K

hi(ν −2)
(ν+1)/2
 ∞
0
ϵ2
i dϵi
(hi(ν −2) + ϵ2
i )(ν+1)/2
Using the standard integrals in Section E.1 with a = 2, b = 2, c = (ν + 1)/2
and m = (ν −2)hi gives:
m(a+1−bc)/b
b
= (hi(ν −2))(2−ν)/2
2
,

a + 1
b

= 
3
2

,


c −a + 1
b

= 
ν −2
2

,
(c) = 
ν + 1
2

This gives
E

ϵ2
i

= 2K

hi(ν −2)
(ν+1)/2
(hi(ν −2))(2−ν)/2√π((ν −2)/2)
4((ν + 1)/2)

Substituting for K and simplifying we obtain:
E

ϵ2
i

= hi(ν −2)((ν −1)/2)
(ν/2)
But
ν −2
2


ν −2
2

= 
ν −1
2
+ 1

= 
ν
2

So
E

ϵ2
i

= hi(ν −2)(ν/2)
2(ν −2)(ν/2) = hi

318
Computational Finance Using C and C#
Similarly we have:
E

ϵ4
i

= 2K
 ∞
0
ϵ4
i dϵi
(1 + ϵ2
i /(hi(ν −2)))(ν+1)/2
= 2K

hi(ν −2)
(ν+1)/2
 ∞
0
ϵ4
i dϵi
(hi(ν −2) + ϵ2
i )(ν+1)/2
Using the standard integrals in Section E.1 with a = 4, b = 2, c = (ν +1)/2, and
m = (ν −2)hi gives:
m(a+1−bc)/b
b
= (hi(ν −2))(4−ν)/2
2
,

a + 1
b

= 
5
2

,


c −a + 1
b

= 
ν −4
2

,
(c) = 
ν + 1
2

and
E

ϵ4
i

= 2K

hi(ν −2)
(ν+1)/2
(hi(ν −2))(4−ν)/23√π((ν −4)/2)
8((ν + 1)/2)

Substituting for K and simplifying we obtain:
E

ϵ4
i

= 3hi(ν −2)2((ν −4)/2)h2
i
4(ν/2)
But
ν −4
2


ν −4
2

= 
ν −2
2

and
ν −2
2


ν −2
2

= 
ν
2

Therefore:

ν −4
2

=
4(ν/2)
(ν −4)(ν −2)
So
E

ϵ4
i

=
3(ν −2)24(ν/2)h2
i
4(ν/2)(ν −4)(ν −2) = 3(ν −2)h2
i
ν −4
The kurtosis is then:
ℵ=
E[e4
i ]
(E[e2
i ])2 = 3(ν −2)h2
i
(ν −4)h2
i
= 3(ν −2)
ν −4
(D.3.1)

Appendix D: Statistical distribution functions
319
D.4
The general error distribution
This section proves various relations for the generalized error distribution.
The density function for the generalized error distribution is:
f (ϵi) = K exp

−1
2
    
ϵi
λ
    
a
where K =
a
λ2(1+1/a)(1/a)
(D.4.1)
D.4.1
Value of λ for variance hi
Calculation of the scale factor λ required for a generalized error distribution
with mean zero and variance hi.
The variance of the distribution, E(ϵ2
i ), is given by:
E

ϵ2
i

= K
 ∞
−∞
ϵ2
i exp

−1
2
    
ϵi
λ
    
a
dϵi = 2K
 ∞
0
ϵ2
i exp

−1
2
ϵi
λ
a
dϵi
Using the standard integrals in Section E.1 with n = 2, p = a, and b = 1
2( 1
λ)a
gives:
hi = 2K
a 
3
a
1
2
1
λ
a−3/a
which after some simpliﬁcation yields:
hi = 2K23/aλ3
a

3
a

Substituting for K and simplifying then gives:
hi = λ222/a (3/a)
(1/a)
The required value of λ is therefore:
λ =

hi2−2/a (1/a)
(3/a)
1/2
D.4.2
The kurtosis
E

ϵ4
i

= K
 ∞
−∞
ϵ4
i exp

−1
2
    
ϵi
λ
    
a
dϵi = 2K
 ∞
0
ϵ4
i exp

−1
2
ϵi
λ
a
dϵi
However, from standard mathematical tables:
 ∞
0
ϵ4
i exp

−bϵp
i

= (k)
pbk
where p = a, b = 1
2( 1
λ)a, and k = 5/a which gives:
E

ϵ4
i

= 2K25/aλ5
a

5
a

= 22/aλ2hi
(5/a)
(3/a)

320
Computational Finance Using C and C#
From Section E.1 we have:
E

ϵ2
i

= hi = 2K23/aλ3
a

3
a

and
λ2 = hi2−2/a(1/a)
(3/a)
Therefore:
E

ϵ4
i

= h2
i
(5/a)(1/a)
(3/a)(3/a)
which gives the kurtosis as:
ℵ=
E[ϵ4
i ]
(E[ϵ2
i ])2 = h2
i
h2
i
(5/a)(1/a)
(3/a)(3/a) = (5/a)(1/a)
(3/a)(3/a)
D.4.3
The distribution for shape parameter, a
If the distribution has variance hi then, from Section D.4.1:
λ =
2−2/a(1/a)hi
(3/a)
1/2
Now for 0 < x < 1 we have (1 + x) = 1 + a1x + a2x2 + a3x3 + · · ·, where
the coefﬁcients are |ai| < 1 (see Abramowitz and Stegun (1968)).
Since x(x) = (1 + x), to third order in x, we have:
x(x) = 1 + a1x + a2x2 + a3x3
This gives (x) = 1
x + a1 + a2x + a3x2, and (x) ≈1
x as x →0.
So as a →∞we have the following:
2(1+1/a) ≈2,
2−2/a ≈1,
1
(1/a) ≈1
a ,
(1/a)
(3/a) ≈3a
a = 3
and
(5/a)
(3/a) ≈3a
5a = 3
5
The kurtosis is then:
ℵ= (5/a)(1/a)
(3/a)(3/a) = 9
5
Also as a →∞, λ ≈(3hi)1/2, and for the range −(3hi)1/2 < ϵi < (3hi)1/2, we
have:    
ϵi
λ
    
a
≈
    
ϵi
(3hi)1/2
    ≈0
and therefore
exp

−1
2
    
ϵi
λ
    
a
≈1
Substituting the above results into Eq. (D.4.1), the probability density function
reduces to:
f (ϵi) ≈
1
2(3hi)1/2
which is a uniform distribution U(−(3hi)1/2, (3hi)1/2), with lower limit
−(3hi)1/2 and upper limit −(3hi)1/2.

Appendix E:
Mathematical reference
E.1
Standard integrals
 ∞
0
exp

−ay2
dy = 1
2
π
a
(i)
 ∞
0
y exp

−ay2
dy = 1
2
(ii)
 ∞
0
y2 exp

−ay2
dy = 1
4a
π
a
(iii)
 ∞
0
y4 exp

−ay2
dy =
3
8a2
π
a
(iv)
 ∞
0
y2n exp

−ay2
dy = 1 × 3 × 5 × · · · × (2n −1)
2n+1an
π
a
(v)
 ∞
0
ϵn
i exp

−bϵp
i

= (k)
pbk ,
(vi)
where n > −1, p > 0, b > 0 and k = n + 1
p
 ∞
0
ϵa
i dϵi
(m + ϵb
i )c = m(a+1−bc)/b
b
((a + 1)/b)(c −(a + 1)/b)
(c)
(vii)
where a > −1, b > 0, m > 0 and c > a + 1
b
E.2
Gamma function
For more detail see Abramowitz and Stegun (1968).
(1 + x) = x!
x(x) = (x + 1)

1
2

= √π

322
Computational Finance Using C and C#

3
2

=
√π
2

5
2

= 3√π
4
∂log((x))
∂x
= ψ(x)
For 0 ⩽x ⩽1 we have:
(1 + x) = 1 + a1x + a2x2 + a3x3 + a4x4 + a5x5
where a1 = −0.5748, a2 = 0.9512, a3 = −0.6998, a4 = 0.4245 and a5 =
−0.1010.
E.3
The cumulative normal distribution function
In this section we show that the cumulative normal distribution function, N1(x),
is related to the complementary error function, erfc(x), by the following equa-
tion:
N1(x) = 1
2 erfc

−x
√
2

(E.3.1)
If we let the error function be represented by erf(x) then we have:
erf(x) =
2
√π
 ∞
0
exp

−t2
dt
Now we have the following:
erfc(x) = 1 −erf(x),
erf(−x) = −erf(x),
erf(∞) = 1
and
erfc(−x) = 2 −erfc(x)
We will consider the integral
I(x) =
2
√π
 x
−∞
exp

−t2
dt
=
2
√π
 0
−∞
exp

−t2
dt +
2
√π
 x
0
exp

−t2
dt
Since
2
√π
 0
−∞
exp

−t2
dt = 1
we therefore have
I(x) = 1 + erf(x) = 1 +

1 −erfc(x)

= 2 −erfc(x)

Appendix E: Mathematical reference
323
Substituting for erfc(x) we obtain:
I(x) = 2 −

2 −erfc(−x)

= erfc(−x)
So we have
erfc(−x) =
2
√π
 x
−∞
exp

−t2
dt
(E.3.2)
Now the cumulative normal distribution is deﬁned as
N1(x) =
1
√
2π
 x
−∞
exp

−t2
dt
Letting u = t
√
2, we have du =
√
2 dt, and for the upper limit we have x = t
√
2,
or t = x/
√
2.
This integral becomes:
N1(x) =
1
√
2π
 t=x/
√
2
∞
exp

−t2√
2 dt
(E.3.3)
So from Eq. (E.3.2) we have:
N1(x) = 1
2 erfc

−x
√
2

We also note that:
N1(−x) = 1 −N1(x)
E.4
Arithmetic and geometric progressions
Arithmetic progression
The sum of the ﬁrst n terms of an arithmetic progression is:
sn = n
2

2a1 + (n −1)d

(E.4.1)
where a1 is the ﬁrst term, and d is the common difference; that is, the terms in
the sequence are: a1, a1 + d, a1 + 2d, a1 + 3d, . . . .
Geometric progression
The sum of the ﬁrst n terms of a geometric progression is:
sn = a1(1 −rn)
1 −r
(E.4.2)
where a1 is the ﬁrst term, and r is the common ratio; that is, the terms in se-
quence are: a1, a1r, a1r2, a1r3, . . . .

blank
left
intentionally
page
This

Appendix F:
Black–Scholes ﬁnite-difference
schemes
F.1
The general case
In this section we consider the stability of the ﬁnite-difference schemes described
in Chapter 5. It is assumed that the grid contains ns asset points, and we will
denote the time dependent option values at the ith and (i + 1)th time instants
by the ns −2 element vectors Xi and Xi+1 respectively. We can therefore write:
T1Xi = T2Xi+1
(F.1.1)
where T1 and T2 are (ns −2) × (ns −2) tridiagonal matrices, and xi
k, k = 1, . . . ,
ns −2, will be used to denote the elements of the vector Xi.
The option values at the ith time instant are computed from those at the
(i + 1)th time instant by using
Xi = T −1
1
T2Xi+1
(F.1.2)
However, Eq. (F.1.2) is only stable if the eigenvalues of the (ns −2) × (ns −2)
matrix T −1
1
T2 all have modulus less than one (see Smith (1985)).
F.2
The log transformation and a uniform grid
We will now prove that the implicit ﬁnite difference method, Θm = 0, when used
on the log transformed Black–Scholes equation with a uniform grid is uncondi-
tionally stable which means that the stability does not depend on the values of
σ, t, Z, etc.
From Chapter 5 the ﬁnite-difference scheme is described by the following
tridiagonal system:
⎛
⎜⎜⎜⎜⎜⎝
B
C
0
0
0
0
A
B
C
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0
A
B
C
0
0
0
0
A
B
⎞
⎟⎟⎟⎟⎟⎠
⎛
⎜⎜⎜⎜⎜⎜⎝
xi
1
xi
2
.
.
xi
s−1
xi
s−2
⎞
⎟⎟⎟⎟⎟⎟⎠

326
Computational Finance Using C and C#
=
⎛
⎜⎜⎜⎜⎜⎝

B
C
0
0
0
0

A

B
C
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0

A

B
C
0
0
0
0

A

B
⎞
⎟⎟⎟⎟⎟⎠
⎛
⎜⎜⎜⎜⎜⎜⎝
xi+1
1
xi+1
2
.
.
xi+1
s−3
xi+1
s−2
⎞
⎟⎟⎟⎟⎟⎟⎠
where
A = (1 −Θm)t
2Z2

bZ −σ 2
(F.2.1)
B = 1 + (1 −Θm)t

r + σ 2
Z2

(F.2.2)
C = −(1 −Θm)t
2Z2

bZ + σ 2
(F.2.3)

A = −Θmt
2Z2

bZ −σ 2
(F.2.4)

B = 1 −Θmt

r + σ 2
Z2

(F.2.5)
C = Θmt
2Z2

bZ + σ 2
(F.2.6)
As in Chapter 5, b = r −q −σ 2
2 and r > 0.
Substituting Θm = 0 into Eqs. (F.2.1)–(F.2.6) we have 
A = C = 0, 
B = 1, and
A =
t
2Z2

bZ −σ 2
,
B = 1 + t

r + σ 2
Z2

,
C = −t
2Z2

bZ + σ 2
The ﬁnite-difference scheme is thus represented by the equations
⎛
⎜⎜⎜⎜⎜⎝
B
C
0
0
0
0
A
B
C
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0
A
B
C
0
0
0
0
A
B
⎞
⎟⎟⎟⎟⎟⎠
⎛
⎜⎜⎜⎜⎜⎜⎝
xi
1
xi
2
.
.
xi
s−1
xi
s−2
⎞
⎟⎟⎟⎟⎟⎟⎠
=
⎛
⎜⎜⎜⎜⎜⎝
1
0
0
0
0
0
1
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0
0
1
0
0
0
0
0
0
1
⎞
⎟⎟⎟⎟⎟⎠
⎛
⎜⎜⎜⎜⎜⎜⎝
xi+1
1
xi+1
2
.
.
xi+1
s−3
xi+1
s−2
⎞
⎟⎟⎟⎟⎟⎟⎠
or in matrix notation
Xi = T1−1Xi+1
(F.2.7)
where T2 = I in Eq. (F.1.1).
As mentioned in Section F.1, Eq. (F.2.7) is stable if the modulus of all the
eigenvalues of T −1
1
are less than one. We will now show that this is in fact the
case.

Appendix F: Black–Scholes ﬁnite-difference schemes
327
If the eigenvalues of T1 are λk, k = 1, . . . , ns −2, then the eigenvalues of
T −1
1
are λ−1
k , k = 1, . . . , ns −2. This means that the system is stable if all the
eigenvalues of T1 have a modulus greater than one. This result can be proved
by considering the eigenvalue with the smallest modulus, λmin. If |λmin| > 1 then
the result is proved.
Now the eigenvalues of T1, see Smith (1985), are given by:
λk = 1 + t

r + σ 2
Z2

+ 2
√
AC cos

kπ
ns −2 + 1

(F.2.8)
k = 1, . . . , ns −2,
where the term
2
√
AC =

t2(σ 4 −b2Z2)
Z4
(F.2.9)
It can be seen that if b2Z2 > σ 4 then the eigenvalues are complex and if
σ 4 ⩾b2Z2 then eigenvalues are real. We will consider each of these cases in
turn.
Complex eigenvalues: b2Z2 > σ 4
We will represent the kth complex eigenvalue as:
λk = R + iY
where the real part is
R = 1 + t

r + σ 2
Z2

and the imaginary part is
Y = 2
√
AC cos

kπ
ns −2 + 1

Since
|λk| > |R| + |Y|
and
|R| > 1,
we conclude that
|λmin| > 1
Real eigenvalues: σ 4 ⩾⩾⩾b2Z2
In this case the kth eigenvalue is real, and from Eq. (F.2.8) we have:
λk > 1 + t

r + σ 2
Z2

−2
√
AC

328
Computational Finance Using C and C#
Since b22 > 0 from Eq. (F.2.9) we have
2
√
AC <

σ 4t2
Z4
or
  2
√
AC
  < σ 2t
Z2
So
λmin > 1 + t

r + σ 2
Z2

−σ 2t
Z2
Therefore we have
|λmin| > 1 + rt
and, since r > 0, we have:
|λmin| > 1

Appendix G:
The Brownian bridge:
alternative derivation
Here we provide an alternative derivation of the Brownian bridge equation
given in Chapter 2.
Let a Brownian process have values Wt0 at time t0 and Wt1 at time t1. We want
to ﬁnd the conditional distribution of Wt, where t0 < t < t1. This distribution
will be denoted by P(Wt|{Wt0, Wt1}), to indicate that Wt is conditional on the
end values Wt0 and Wt1.
We have:
P(Wt|Wt0) =
1
√2π(t −t0) exp

−(Wt −Wt0)2
2(t −t0)

The joint distribution of Wt and Wt1 given Wt0 is:
P

{Wt, Wt1}|Wt0

= P(Wt1|Wt)P(Wt|Wt0)
=
1
√2π(t −t0)(t1 −t) exp

−(Wt −Wt0)2
2(t −t0)
−(Wt1 −Wt)2
2(t1 −t)

=
1
√2π(t −t0)(t1 −t) exp

−1
2
(Wt −Wt0)2
2(t −t0)
+ (Wt1 −Wt)2
2(t1 −t)

Similarly
P(Wt1|Wt0) =
1
√2π(t1 −t0) exp

−(Wt1 −Wt0)2
2(t1 −t0)

Now we have:
P

Wt|{Wt0, Wt1}

= P({Wt, Wt1}|Wt0)
P(Wt1|Wt0)
=
1
√
2π

t1 −t0
(t −t0)(t1 −t)
× exp

−1
2
(Wt −Wt0)2
2(t −t0)
+ (Wt1 −Wt)2
2(t1 −t)
−(Wt1 −Wt0)2
2(t1 −t0)


330
Computational Finance Using C and C#
For ease of reference we will write the above equation as:
P

Wt|{Wt0, Wt1}

=
1
√
2π

t1 −t0
(t −t0)(t1 −t) exp{A}
We now consider the terms in the exponent A.
A = −1
2
(X −Xt0)2(t1 −t)(t1 −t0)
(t −t0)(t1 −t)(t1 −t0)
+ (X1 −X)2(t −t0)(t1 −t0)
(t −t0)(t1 −t)(t1 −t0)
−(X1 −Xt0)2(t −t0)(t1 −t)
(t −t0)(t1 −t)(t1 −t0)

Dividing top and bottom of the above expression for A by (t1 −t0)2 we then
obtain:
A = −1
2V

W 2
t + W 2
t0 −2WtWt0
 t1 −t
t1 −t0
+

W 2
t1 + W 2
t −2WtWt1
 t −t0
t1 −t0
−

W 2
t1 + W 2
t0 −2Wt1Wt0
(t −t0)(t1 −t)
(t1 −t0)2

where
V = (t −t0)(t1 −t)
t1 −t0
So
A = −1
2V

W 2
t
 t1 −t
t1 −t0
+ t −t0
t1 −t0

+ W 2
t1
 t −t0
t1 −t0
−(t −t0)(t1 −t)
(t1 −t0)2

+ W 2
t0
 t −t0
t1 −t0
−(t −t0)(t1 −t)
(t1 −t0)2

−2WtWt0
 t1 −t
t1 −t0

−2WtWt1
 t −t0
t1 −t0

+ 2Wt1Wt0
(t −t0)(t1 −t)
(t1 −t0)2

We now show that A can be expressed as quadratic form:
B = −1
2V (Wt −μ)2 = −1
2V

W 2
t + μ2 −2μWt

where
V = (t −t0)(t1 −t)
t1 −t0
and
μ = Wt0
t1 −t
t1 −t0
+ Wt1
t −t0
t1 −t0
Therefore we have:
B = −1
2V

W 2
t +

Wt0
t1 −t
t1 −t0
+ Wt1
t −t0
t1 −t0
2
−2Wt

Wt0
t1 −t
t1 −t0
+ Wt1
t −t0
t1 −t0


Appendix G: The Brownian bridge: alternative derivation
331
Expanding and gathering terms we obtain:
B = −1
2V

W 2
t + W 2
t0
(t1 −t)2
(t1 −t0)2 + W 2
t1
(t −t0)2
(t1 −t0)2 + 2Wt0Wt1
(t1 −t)(t −t0)
(t1 −t0)2
−2WtWt0
t1 −t
t1 −t0
−2WtWt1
t −t0
t1 −t0

Comparing coefﬁcients of A and B we have:
Coefﬁcients for W 2
t
A: −1
2V
 t1 −t
t1 −t0
+ t −t0
t1 −t0

= −1
2V
t1 −t + t −t0
t1 −t0

= −1
2V
B : −1
2V
Coefﬁcients for W 2
t0
A: −1
2V
 t1 −t
t1 −t0
−(t −t0)(t1 −t)
(t1 −t0)2

= −1
2V
(t1 −t)(t1 −t0) −(t −t0)(t1 −t)
(t1 −t0)2

A: −1
2V
(t1 −t)(t1 −t0 −t + t0)
(t1 −t0)2

= −1
2V
 (t1 −t)2
(t1 −t0)2

B : −1
2V
 (t1 −t)2
(t1 −t0)2

Coefﬁcients for W 2
t1
A: −1
2V
(t −t0)(t1 −t0) −(t −t0)(t1 −t)
(t1 −t0)2

= −1
2V
(t −t0)(t1 −t0 −t1 + t)
(t1 −t0)2

A: −1
2V
 (t1 −t)2
(t1 −t0)2

B : −1
2V
 (t −t0)2
(t1 −t0)2

The remaining coefﬁcients in A and B for Wt0Wt1, WtWt1 and Wt0Wt are identi-
cal.

332
Computational Finance Using C and C#
We have thus shown that:
P

Wt|{Wt0, Wt1}

=
1
√
2π

t1 −t0
(t −t0)(t1 −t) exp

−(Wt −μ)2
2V

=
1
√
2πV
exp

−(Wt −μ)2
2V

Thus the conditional distribution of Wt is a Gaussian with mean
μ = Wt0
t1 −t
t1 −t0
+ Wt1
t −t0
t1 −t0
and variance
V = (t −t0)(t1 −t)
t1 −t0
and we can obtain a variate 
Wt from this distribution by using:

Wt = Wt0
t1 −t
t1 −t0
+ Wt1
t −t0
t1 −t0
+

(t −t0)(t1 −t)
t1 −t0
Z,
where Z ∼N(0, 1)

Appendix H:
Brownian motion: more results
H.1
Some results concerning Brownian motion
Here we will prove some facts concerning Brownian motion.
If the Brownian motion has zero drift then:
dXt = σ
√
dt dZt,
dZt ∼N(0, 1)
(H.1.1)
and
P

mX
t ⩽b, Xt ⩾x

= N1
2b −x
σ√t

(H.1.2)
where mX
t denotes the minimum value of Xt over the time interval [0, t], b ⩽0,
and x ⩾0.
When the Brownian motion has nonzero drift
d
Xt = ν dt + σ
√
dt dZt,
dZt ∼N(0, 1)
(H.1.3)
and the following equations are satisﬁed by m
X
t and 
Xt:
P(
Xt ⩽K) = N1
K −νt
σ√t

(H.1.4)
P(
Xt ⩾K) = N1
νt −K
σ√t

(H.1.5)
P

m
X
t ⩽b, 
Xt ⩾x

= exp
2νb
σ 2

N1
2b −x + νt
σ√t

(H.1.6)
P

m
X
t ⩾b, 
Xt ⩾x

= N1
νt −x
σ√t

−exp
2νb
σ 2

N1
2b −x + νt
σ√t

(H.1.7)
P

m
X
t ⩽b

= N1
b −νt
σ√t

+ exp
2νb
σ 2

N1
b + νt
σ√t

(H.1.8)
P

m
X
t ⩾b

= N1
νt −b
σ√t

−exp
2νb
σ 2

N1
b + νt
σ√t

(H.1.9)
where K is a constant, 
X ⩾0, b ⩽0, and P(condition) denotes the probability
associated with the appropriate condition, i.e., 
Xt ⩾K, m
X
t ⩾b, 
Xt ⩾x, etc.

334
Computational Finance Using C and C#
The conditional probability density function associated with P(m
X
t ⩽b, 
Xt ⩾
x) is
p

m
X
t1,t2 ⩽b, 
Xt2

|
Xt1

=
1
σ
√
2πt
exp
2ν(b −
Xt1)
σ 2

exp

−(
Xt1 + 
Xt2 −2b + νt)2
2σ 2t

(H.1.10)
where t2 ⩾t1 and t = t2 −t1.
H.2
Proof of Eq. (H.1.2)
From Eq. (H.1.1):
Xt = σ
√
t
Zt, Zt ∼N(0, 1)
where X0 = 0. We will derive the probability of events mX
t
⩽b and Xt ⩾x
occurring. For event mX
t
to occur there must be a time τ at which Xτ ⩽b,
where 0 < τ ⩽t. At time τ, instead of continuing with the original Brownian
motion, Xt we will consider the reﬂected motion XR
t deﬁned by:
XR
s = Xs,
s < τ
XR
s = 2b −Xs,
s ⩾τ
Therefore, before time τ the motion Xs is identical to XR
s . For s ⩾τ the coordi-
nates of XR
s are obtained by reﬂecting those of Xs about the level b. The event
Xt ⩾x is thus equivalent to the event XR
t ⩽2b−x (remember b ⩽0 and x ⩾0).
However, the event XR
t ⩽2b −x only occurs if mX
t ⩽b also occurs, giving:
P

XR
t ⩽2b −x

= P

mX
t ⩽b, Xt ⩽x

At time τ we have
XR
τ = 2b −Xτ
(H.2.1)
and after time τ
XR
τ+γ = 2b −Xτ+γ ,
γ > 0
(H.2.2)
Thus subtracting Eq. (H.2.1) from Eq. (H.2.2) gives:
XR
τ+γ −XR
τ = Xτ −Xτ+γ
XR
τ+γ −XR
τ = −(Xτ+γ −Xτ)
(H.2.3)
However, we know that:
(Xτ+γ −Xτ) ∼N

0, σ 2γ

(H.2.4)
So

XR
τ+γ −XR
τ

∼−N

0, σ 2γ


Appendix H: Brownian motion: more results
335
which means that:

XR
τ+γ −XR
τ

∼N

0, σ 2γ

(H.2.5)
Since the left-hand sides of Eqs. (H.2.4) and (H.2.5) have the same distribution,
and Xt satisﬁes the three Brownian properties given in Section 2.1, we can write:
P

XR
t ⩽2b −x

= P(Xt ⩽2b −x) = N1
2b −x
σ√t

Therefore:
P

mX
t ⩽b, Xt ⩾x

= N1
2b −x
σ√t

H.3
Proof of Eq. (H.1.4)
From Eq. (H.1.3) 
Xt = νt + σ√tZt, Zt ∼N(0, 1).
So we can write:
P(
Xt ⩽K) = P

νt + σ
√
tZt ⩽K

= P

Zt ⩽K −νt
σ√t

= N1
K −νt
σ√t

,
Zt ∼N(0, 1)
H.4
Proof of Eq. (H.1.5)
We know that P(
Xt ⩾K) = 1 −P(
Xt ⩽K).
Substituting from Eq. (H.1.4) gives:
P(
Xt ⩾K) = 1 −N1
K −νt
σ√t

Since 1 −N1(x) = N1(−x) we obtain:
P(
Xt ⩾K) = N1
νt −K
σ√t

H.5
Proof of Eq. (H.1.6)
From Eq. (H.1.1):
dXt = σ
√
dt dZt,
dZt ∼N(0, 1)

336
Computational Finance Using C and C#
This can be expressed as zero drift Brownian motion under probability mea-
sure P:
dXt = σ dW P,
dW P ∼N(0, dt)
(H.5.1)
or
Xt = σW P
t ,
W P
t ∼N(0, t)
Now we can choose another probability measure Q so that:
dW P = dW Q + ν
σ dt
(H.5.2)
where ν is a constant.
Under probability measure Q the motion in Eq. (H.5.1) is:
d
Xt = σ

dW Q + ν
σ dt

(H.5.3)
so
d
Xt = ν dt + σ dW Q
(H.5.4)
It can be seen from Section 2.4 that the transformation between measures
P and Q can be accomplished using k = ν/σ, and that the associated Radon–
Nikodym derivative is:
dQ
dP = exp

kW P
t −1
2k2t

= exp
 ν
σ W P
t −1
2
ν2t
σ

= exp
 ν
σ 2 Xt −1
2
ν2t
σ

(H.5.5)
where we have used the fact that under probability measure P we can write:
W P
t = Xt/σ.
Now
P

m
X
t ⩽b, 
Xt ⩾x

= EQ
I{m
Xt ⩽b}I{
Xt⩾x}

(H.5.6)
where I{condition} is an indicator function which takes unit value when condition
is satisﬁed and zero otherwise—for example I{m
Xt ⩽b} is one when m
X
t
⩽b and
zero when m
X
t > b.
However (see for example Baxter and Rennie (1996)), we have:
EQ
I{m
Xt ⩽b}I{
Xt⩾x}

= EP

I{mXt ⩽b}I{Xt⩾x}
dQ
dP

(H.5.7)
So substituting for dQ
dP from Eq. (H.5.5) gives:
EQ
I{m
Xt ⩽b}I{
Xt⩾x}

= EP

I{mXt ⩽b}I{Xt⩾x} exp
νXt
σ 2 −ν2t
2σ 2

(H.5.8)

Appendix H: Brownian motion: more results
337
Expressed in terms of the reﬂected Brownian motion, XR
t = 2b−Xt, Eq. (H.5.8)
can be written:
P

m
X
t ⩽b, 
Xt ⩾x

= EP

I{2b−XRt ⩾x} exp
ν(2b −XR
t )
σ 2
−ν2t
2σ 2

= exp
2νb
σ 2

EP

I{2b−Xt⩾x} exp

−νXR
t
σ 2
−ν2t
2σ 2

(H.5.9)
Since
I{2b−XRt >x} = I{−2b+XRt <−x} = I{XRt <2b−x}
Equation (H.5.9) becomes:
P

m
X
t ⩽b, 
Xt ⩾x

= exp
2νb
σ 2

EP

I{Xt<2b−x} exp

−νXt
σ 2 −ν2t
2σ 2

(H.5.10)
where, for ease of notation, we now denote XR
t by Xt on the right-hand side of
Eq. (H.5.10).
Therefore:
P

m
X
t ⩽b, 
Xt ⩾x

= exp
2νb
σ 2
  Xt=2b−x
Xt=−∞
1
σ
√
2πt
exp

−X2
t
2σ 2t

exp
νXt
σ 2 −ν2t
σ 2

dXt
=
1
σ
√
2πt
exp
2νb
σ 2
  Xt=2b−x
Xt=−∞
exp

−(X2
t + 2νXtt + ν2t2)
2σ 2t

dXt
=
1
σ
√
2πt
exp
2νb
σ 2
  Xt=2b−x
Xt=−∞
exp

−(Xt + νt)2
2σ 2t

dXt
If V = (Xt + νt)/(σ√t) then dXt = σ√t dV , Xt = 2b −x corresponds to
V = (2b −x + νt)/(σ√t), and Xt = −∞corresponds to V = −∞.
1
σ
√
2πt
 Xt=2b−x
Xt=−∞
exp

−(Xt + νt)2
2σ 2t

dXt
=
1
σ
√
2πt
 V =(2b−x+νt)/(σ√t)
V =−∞
exp

−V 2
2

dV
= N1
2b −x + νt
σ√t

We thus obtain:
P

m
X
t ⩽b, 
Xt ⩾x

= exp
2νb
σ 2

N1
2b −x + νt
σ√t


338
Computational Finance Using C and C#
H.6
Proof of Eq. (H.1.7)
Since P(
Xt ⩾x) = P(m
X
t ⩾b, 
Xt ⩾x) + P(m
X
t ⩾b, 
Xt ⩽x) we have:
P

m
X
t ⩾b, 
Xt ⩾x

= P(
Xt ⩾x) −P

m
X
t ⩾b, 
Xt ⩽x

(H.6.1)
Substituting the results of Eqs. (H.1.4) and (H.1.6) into Eq. (H.6.1) yields:
P

m
X
t ⩾b, 
Xt ⩾x

= N1
νt −x
σ√t

−exp
2νb
σ 2

N1
2b −x + νt
σ√t

H.7
Proof of Eq. (H.1.8)
We start by writing:
P

m
X
t ⩽b

= P

m
X
t ⩽b, 
Xt ⩽b

+ P

m
X
t ⩽b, 
Xt ⩾b

However, P(m
X
t
⩽b, 
Xt ⩽b) = P(
Xt ⩽b) since the probability that the
minimum is less than b and the ﬁnal value 
Xt is less than b is the same as the
probability that the ﬁnal value 
Xt is less than b. Therefore:
P

m
X
t ⩽b

= P(
Xt ⩽b) + P

m
X
t ⩽b, 
Xt ⩾b

Substituting for P(
Xt ⩽b) from Eq. (H.1.4) gives:
P

m
X
t ⩽b

= N1
b −νt
σ√t

+ P

m
X
t ⩽b, 
Xt ⩾b

(H.7.1)
From Eq. (H.1.6):
P

m
X
t ⩽b, 
Xt ⩾b

= exp
2νb
σ 2

N1
2b −b + νt
σ√t

= exp
2νb
σ 2

N1
b + νt
σ√t

(H.7.2)
Combining Eqs. (H.7.2) and (H.7.1) yields:
P

m
X
t ⩽b

= N1
b −νt
σ√t

+ exp
2νb
σ 2

N1
b + νt
σ√t

H.8
Proof of Eq. (H.1.9)
We start with:
P

m
X
t ⩾b

= 1 −P

m
X
t ⩽b


Appendix H: Brownian motion: more results
339
Substituting from (H.1.8):
P

m
X
t ⩾b

= 1 −N1
b −νt
σ√t

+ exp
2νb
σ 2

N1
b + νt
σ√t

(H.8.1)
But since 1 −N1(x) = N1(−x), Eq. (H.8.1) can be expressed as:
P

m
X
t ⩾b

= N1
νt −b
σ√t

+ exp
2νb
σ 2

N1
b + νt
σ√t

H.9
Proof of Eq. (H.1.10)
We will use Eq. (H.1.6) to compute ∂P
∂x , where P(m
X
t
⩽b, 
Xt ⩾x) is denoted
by P.
Letting Θ = (2b −x + νt)/(σ√t) we obtain:
∂P
∂x = exp
2νb
σ 2
 ∂
∂x

N1(Θ)

= exp
2νb
σ 2
 ∂
∂Θ

N1(Θ)
∂Θ
∂x
= −exp
2νb
σ 2

1
σ√t n(Θ)
= −
1
σ
√
2πt
exp
2νb
σ 2

exp
(2b −x + νt)2
2σ 2t

(H.9.1)
Now since the probability P(m
X
t ⩽b, 
Xt ⩾x) decreases as x increases we have:
P

m
X
t ⩽b, 
Xt ⩾x

−P

m
X
t ⩽b, 
Xt ⩾x + x

= −∂P
∂x x
(H.9.2)
and also:
P

m
X
t ⩽b, 
Xt ⩾x

−P

m
X
t ⩽b, 
Xt ⩾x + x

∼p

m
X
t ⩽b, 
Xt = x

x
(H.9.3)
where p(m
X
t ⩽b, 
Xt = x) is the probability density function of P(m
X
t ⩽b, 
Xt ⩾
x), and x →0.
Combining Eqs. (H.9.2) and (H.9.3) we thus obtain
p

m
X
t ⩽b, 
Xt = x

= −∂P
∂x x
So,
p

m
X
t ⩽b, 
Xt = x

=
1
σ
√
2πt
exp
2νb
σ 2

exp

−(2b −x + νt)2
2σ 2t


340
Computational Finance Using C and C#
which means that:
p

m
X
t ⩽b, 
Xt

|
X0

=
1
σ
√
2πt
exp
2νb
σ 2

× exp

−(2b −
Xt + νt)2
2σ 2t

(H.9.4)
where as usual we take 
X0 = 0. So Eq. (H.9.4) gives the probability density
for the Brownian motion which goes through the points 
X0 and 
Xt and has a
minimum value which is less than or equal to b.
Instead of considering the complete path of 
Xt from 
X0 we can move the
origin to the point 
Xt1, where t1 ⩽t. Substituting into Eq. (H.9.4) we then
obtain:
p

m
X
t1,t ⩽b, 
Xt

|
Xt1

=
1
σ√2π(t −t1) exp
2ν(b −
Xt1)
σ 2

× exp

−(2(b −
Xt1) −(
Xt −
Xt1) + ν(t −t1))2
2σ 2(t −t1)

=
1
σ√2π(t −t1) exp
2ν(b −
Xt1)
σ 2

× exp

−(2b −
Xt1 −
Xt + ν(t −t1))2
2σ 2(t −t1)

which can be re-expressed as:
p

m
X
t1,t2 ⩽b, 
Xt2

|
Xt1

=
1
σ
√
2πt
exp
2ν(b −
Xt1)
σ 2

× exp

−(
Xt1 + 
Xt2 −2b −νt)2
2σ 2t

where t2 ⩾t1 and t = t2 −t1.

Appendix I:
The Feynman–Kac formula
The Feynman–Kac formula provides a link between stochastic processes and
partial differential equations, which we will now illustrate.
In the risk neutral measure the equation followed by the asset price is:
dS = rS dt + σS dW
(I.1.1)
and that of the money account:
dB = Br dt
(I.1.2)
If f (S, t) is the value of a derivative then using Ito’s lemma we have:
df =
∂f
∂t + rS ∂f
∂S + σ 2S2
2
∂2f
∂S2

+ ∂f
∂S σ dW
(I.1.3)
Since f is a tradable we know that the process ( f
B ) must be a martingale in the
risk neutral measure, and therefore have zero drift.
We will now evaluate d( f
B ) using the Ito quotient rule (see Eq. (2.6.4)):
d
X1
X2

=
X1
X2
dX1
X1
−dX2
X2

+ E
dX2
X2
dX2
X2

−E
dX2
X2
dX1
X1

(I.1.4)
and rewrite Eqs. (I.1.2) and (I.1.3) as:
dX1 = ¯μ1 dt + ¯σ1 dW
dX2 = X2 ¯μ2 dt
where
d
X1
X2

= d
f
B

,
¯μ1 =
∂f
∂t + σ 2S2
2
∂2f
∂S2

¯σ1 = σ1
∂f
∂S ,
X1 = f,
X2 = B,
¯μ2 = r
Evaluating Eq. (I.1.4) we obtain:
E
dX2
X2
dX2
X2

= E

¯μ2
2 dt2
→0
E
dX1
X1
dX2
X2

= E
 ¯μ1 dt + ¯σ1 dW
X1
X2 ¯μ2 dt
X2

→0

342
Computational Finance Using C and C#
and therefore:
d
X1
X2

=
X1
X2
μ1 dt + ¯σ1 dW
X1
−X2 ¯μ2 dt
X2

=
 ¯μ1
X2
−
X1
X2

¯μ2

dt +
 ¯σ1
X2

= 1
X2
{ ¯μ1 −X1 ¯μ2} dt +
 ¯σ1
X2

(I.1.5)
Since ( X1
X2 ) is a martingale, the drift term in Eq. (I.1.5) is zero so:
¯μ1 −X1 ¯μ2 = 0
(I.1.6)
Therefore, substituting for ¯μ1, X1 and ¯μ2 in Eq. (I.1.6) we obtain:
∂f
∂t + rS ∂f
∂S + σ 2S2
2
∂2f
∂S2 −rf = 0
(I.1.7)
or
∂f
∂t + rS ∂f
∂S + σ 2S2
2
∂2f
∂S2 = rf
(I.1.8)
which is the Black–Scholes partial differential equation, which we derived in
Chapter 4.
In general if an asset follows the process:
dS = ¯μ dt + ¯σ dW
(I.1.9)
then the price of a derivative f (S, t) obeys the partial differential equation:
∂f
∂t + ¯μ∂f
∂S + ¯μ2
2
∂2f
∂S2 = rf
(I.1.10)
or
 ∂
∂t + ¯μ ∂
∂S + ¯μ2
2
∂2
∂S2

f = rf
(I.1.11)

Appendix J:
Answers to problems
Problem 1
Let βk
t = E[W k
t ], where Wt0 = 0.
(a) Show using Ito’s formula for k = 2, 3, 4, . . . that
βk
t = 1
2(k −1)
 t
s=0
βk−2
s
ds
(b) Deduce that E[W 4
t ] = 3t2
(c) What is E[W 6
t ]
1(a)
Let φ(Wt) = W k
t ; using Ito’s formula we have:
dφ = ∂φ
∂Wt
dWt + 1
2
∂2φ
dW 2t
dt
So
d

W k
t

= kW k−1
t
dWt + 1
2k(k −1)W k−2
t
dt
Integrating both sides
 t
s=0
d

W k
s

= k
 t
s=0
W k−1
s
dWs + 1
2(k −1)
 t
s=0
W k−2
s
ds
W k
t −W k
t0 = k
 t
s=0
W k−1
s
dWs + 1
2(k −1)
 t
s=0
W k−2
s
ds
Now
E

s=0
W k−1
s
dWs

= 0
and using Fubini’s theorem
E
 t
s=0
W k−2
s
ds

=
 t
s=0
E

W k−2
s

ds

344
Computational Finance Using C and C#
Therefore
E

W k
t

−E

W k
t0

= kE
 t
s=0
W k−1
s
dWs

+ 1
2(k −1)
 t
s=0
E

W k−2
s

ds
= 1
2(k −1)
 t
s=0
E

W k−2
s

ds
Since E[W k
t0] = 0 we obtain
βk
t = 1
2(k −1)
 t
s=0
βk−2
s
ds
1(b)
Since Wt is standard Brownian motion (zero drift and σ = 1)
E

W 2
t

= t
Substituting k = 4 in the relation from part (a) yields
E

W 4
t

= 4 × 3
2
 t
s=0
E

W 2
s

ds = 12
2
 t
s=0
s ds = 6t2
2 = 3t2
1(c)
Using the relation from part (a) with k = 6 yields
E

W 6
t

= 6 × 5
2
 t
s=0
E

W 4
s

ds = 6 × 5
2
 t
s=0
3s2 ds = 30
2
3t3
3 = 15t3
Problem 2
Solve
dXt = Xt dt + dWt
Rearranging we have
dXt −Xt dXt = dWt
Using the integrating factor exp(−t) gives
exp(−t) dXt −Xt exp(−t) dt = exp(−t) dWt
and
d

Xt exp(−t)

= −Xt exp(−t) dt + exp(−t) dXt = exp(−t) dWt
So
d

Xt exp(−t)

= exp(−t) dWt

Appendix J: Answers to problems
345
Integrating both sides
 t
s=0
d

Xs exp(−s)

=
 t
s=0
exp(−s) dWs
and
Xt exp(−t) −Xt0 =
 t
s=0
exp(−s) dWs
which means that
Xt = Xt0 exp(t) +
 t
s=0
exp(t −s) dWs
Problem 3
Solve
dXt = −Xt dt + exp(−t) dWt
Rearranging yields
dXt + Xt dt = exp(−t) dWt
Using the integrating factor exp(t) we obtain
exp(t) dXt + exp(t)Xt dt = dWt
and
d

exp(t)Xt

= exp(t) dXt + exp(t)Xt dt
which means that
d

exp(t)Xt

= dWt
and
 t
s=0
d

exp(s)Xs

=
 t
s=0
dWs
Integrating
Xt exp(t) −Xt0 = Wt −Wt0
Since Wt0 = 0
Xt exp(t) −Xt0 = Wt
that is
Xt = Xt0 exp(−t) + Wt exp(−t)

346
Computational Finance Using C and C#
Problem 4
Prove
s=0
W 2
s dWs = 1
3W 3
t −
 t
s=0
Ws ds
Using Ito’s formula
d

W 3
t

= 3W 2
t dW + 6
2Wt dt
Therefore
 t
s=0
d

W 3
t

= 3
 t
s=0
W 2
s dWs + 3
 t
s=0
Ws ds
and
W 3
t −W 3
t0 = 3
 t
s=0
W 2
s dWs + 3
 t
s=0
Ws ds
Using Wt0 = 0 we obtain
W 3
t = 3
 t
s=0
W 2
s dWs + 3
 t
s=0
Ws ds
So
 t
s=0
W 2
s dWs = 1
3W 3
t −
 t
s=0
Ws ds
Problem 5
Solve dYt = r dt + αYt dWt where r and α are real constants.
Use the integrating factor Ft = exp(−αWt + α2
2 t)
dYt −αYt dt = r dt
Multiplying by Ft
dYt exp

−αWt + α2
2 t

−αYt exp

−αWt + α2
2 t

= r exp

−αWt + α2
2 t

dt
Using Ito’s formula
d

Yt exp

−αWt + α2
2 t

= dYt exp

−αWt + α2
2 t

−αYt exp

−αWt + α2
2 t

dWt

Appendix J: Answers to problems
347
= r exp

−αWt + α2
2 t

dt
Integrating
 t
s=0
d

Ys exp

−αWs + α2
2 s

= r
 t
s=0
exp

−αWs + α2
2 s

ds
Yt exp

−αWt + α2
2 t

−Yt0 exp(−αWt0) = r
 t
s=0
exp

−αWs + α2
2 s

ds
Using Wt0 = 0 yields
Yt exp

−αWt + α2
2 t

= Yt0 + r
 t
s=0
exp

−αWs + α2
2 s

ds
So
Yt = Yt0 exp

αWt −α2
2 t

+ r
 t
s=0
exp

α(Wt −Ws) + α2
2 (t −s)

ds
Problem 6
6(a)
Solve
dXt = (m −Xt) dt + σ dWt
where m and σ are constants.
Rearranging
dXt + Xt dt = m dt + σ dWt
Use the integrating factor exp(t)
d

Xt exp(t)

= exp(t) dXt + Xt exp(t) dt
= m exp(t) dt + σ exp(t) dWt
Integrating
 t
s=0
d

Xs exp(s)

= m
 t
s=0
exp(s) ds + σ
 t
s=0
exp(s) dWs
Xt exp(t) −Xt0 = m

exp(t) −1

+ σ
 t
s=0
exp(s) dWs
which can be expressed as
Xt = m + (Xt0 −m) exp(−t) + σ exp(−t)
 t
s=0
exp(s) dWs

348
Computational Finance Using C and C#
6(b)
Taking expectations of the expression for Xt derived in part (a)
E[Xt] = m + (Xt0 −m) exp(−t)
where we have used
E
 t
s=0
exp(s) dWs

= 0
Var[Xt] = E

Xt −E[Xt]
2
= E

σ 2 exp(−2t)
 t
s=0
exp(s) dWs
2
= σ 2 exp(−2t)E
 t
s=0
exp(s) dWs
2
From Ito’s isometry
Var[Xt] = σ 2 exp(−2t)E
 t
s=0
exp(2s) ds

= σ 2 exp(−2t)
exp(2s)
2
t
s=0
= σ 2 exp(−2t)
exp(2t)
2
−1
2

which gives
Var[Xt] =
1
2σ 2

1 −exp(−2t)

Problem 7
Consider the equation dSt = μtSt dt + σtSt dWt where the value of St at time
t = 0 is denoted by S0.
(a) Show that the mean is
E

log(St)

= log(S0) +
 t
τ=0

μτ −σ 2
τ
2

dτ
(b) Show that the variance is
Var

log(St)

=
 t
τ=0
σ 2
τ dτ

Appendix J: Answers to problems
349
7(a)
If φ = log(S) then using Ito’s formula we have
dφ = ∂φ
∂S dS + 1
2
∂2φ
∂S2 E

(dS)2
= 1
S {μtSt dt + σtSt dWt} −1
2
S2
S2 σt dt
So
d

log(St)

=

μt −σ 2
t
2

dt + σt dWt
and therefore
 t
τ=0
d

log(Sτ)

=
 t
τ=0

μτ −σ 2
τ
2

dτ +
 t
τ=0
στ dWτ
which gives
log(Sτ) −log(S0) =
 t
τ=0

μτ −σ 2
τ
2

dτ +
 t
τ=0
στ dWτ
Taking expectations we obtain
E

log(St)

−E

log(S0)

= E
 t
τ=0

μτ −σ 2
τ
2

dτ

+ E
 t
τ=0
στ dWτ

Since
 t
τ=0(μτ −σ 2
τ
2 ) dτ is deterministic
E
 t
τ=0

μτ −σ 2
τ
2

dτ

=
 t
τ=0

μτ −σ 2
τ
2

dτ
and using
E
 t
τ=0
στ dWτ

= 0
and
E

log(S0)

= log(S0)
we ﬁnally obtain
E

log(St)

= log(S0) +
 t
τ=0

μτ −σ 2
τ
2

dτ
7(b)
Var

log(St)

= E

log(St) −E

log(St)
2
= E

log(S0) +
 t
τ=0

μτ −σ 2
τ
2

dτ
+
 t
τ=0
στ dWτ −log(S0) −
 t
τ=0

μτ −σ 2
τ
2

dτ
2

350
Computational Finance Using C and C#
= E
 t
τ=0
στ dWτ
2
Using Ito’s isometry we have:
E
 t
τ=0
στ dτ
2
= E
 t
τ=0
σ 2
τ dτ

Since
 t
τ=0 σ 2
τ dτ is deterministic we can write
E
 t
τ=0
σ 2
τ dτ

=
 t
τ=0
σ 2
τ dτ
and ﬁnally we obtain
Var

log(St)

=
 t
τ=0
σ 2
τ dτ
Problem 8
Prove that if φ = exp(tWt) then
dφ = φ

Wt + t2
2

dt + tφ dWt
From Ito we have
dφ = ∂φ
∂t dt + ∂φ
∂Wt
dWt + 1
2
∂2φ
∂W 2t
E

( dWt)2
Now
∂φ
∂t = Wt exp(tWt),
∂φ
∂Wt
= t exp(tWt),
∂2φ
∂W 2t
= t2 exp(tWt)
So
dφ = Wt exp(tWt) dt + t exp(tWt) dWt + t2
2 exp(tWt) dt
where we have used E[(dWt)2] = dt.
Therefore
dφ = φ

Wt + t2
2

dt + tφ dWt
Problem 9
Given
Zt = exp
 t
s=0
θs dWs −1
2
 t
s=0
θ2
s ds


Appendix J: Answers to problems
351
Use Ito to prove that the process for Zt is dZt = Ztθt dWt.
9(a)
Let
Xt =
 t
s=0
θs dWs −1
2
 t
s=0
θ2
s ds
so
dXt = θt dWt −1
2θ2
t dt
We thus have:
Zt = exp(Xt)
Using Ito we have
dZt = ∂Zt
∂Xt
dXt + ∂2Zt
∂X2t
(dXt)2
so
dZt = Zt

θt dWt −1
2θ2
t dt

+ ZtE

θt dWt −1
2θ2
t dt

θt dWt −1
2θ2
t dt

Now
E

θt dWt −1
2θ2
t dt

θt dWt −1
2θ2
t dt

= E

θ2
t dW 2
t

+ E
1
4θ4
t dt2

−E

θ3
t dWt dt

Ignoring terms in dt of order higher than 1 using the fact that:
E

dW 2
t

= θ2
t E

dW 2
t

= θ2
t dt
and
E

θ3
t θt dWt dt

= θ3
t dt E[dWt] = 0
We have
dZt = Zt

θt dWt −1
2θ2
t dt

+ 1
2Ztθ2
t dt = Ztθt dWt
Hence we have shown that
dZt = Ztθt dWt

352
Computational Finance Using C and C#
Problem 10
Let St = S0 exp(μt + σWt) where μ and σ are constants.
(a) Show by Ito’s lemma that
dSt =

μ + σ 2
2

St dt + σSt dWt
(b) Show that
E[St] −E[S0] =

μ + σ 2
2
  t
τ=0
E

S(τ)

dτ
(c) Show that
E[St] = S0 exp

μt + σ 2
2 t

10(a)
Let φ = S0 exp(μt + σWt).
Then using Ito’s formula:
dφ = ∂φ
∂t dt + ∂φ
∂Wt
dWt + 1
2
∂2φ
∂W 2t
E

(dWt)2
So
dφ = μφ dt + σφ dWt + 1
2φσ 2 dt
where we have used ∂2φ
∂W 2t = φσ 2 and E[(dWt)] = dt.
Therefore
dSt =

μ + 1
2σ 2

St dt + Stσ dWt
10(b)
From part (a) we have
 t
τ=0
dSτ =

μ + 1
2σ 2
  t
τ=0
Sτ dτ + σ
 t
τ=0
Sτ dWτ
Therefore
St −S0 =

μ + 1
2σ 2
  t
τ=0
Sτ dτ + σ
 t
τ=0
Sτ dWτ
Taking expectations we have
E[St] −E[S0] =

μ + 1
2σ 2

E
 t
τ=0
Sτ dτ

+ σE
 t
τ=0
Sτ dWτ


Appendix J: Answers to problems
353
Using the fact that:
E
 t
τ=0
f (τ) dWτ

= 0
and from Fubini’s theorem:
E
 t
τ
S(τ) dτ

=
 t
τ
E

S(τ)

dτ
we thus ﬁnally obtain:
E[St] −E[S0] =

μ + 1
2σ 2
  t
τ=0
E[Sτ] dτ
10(c)
From part (a) we know:
dSt =

μ + 1
2σ 2

St dt + Stσ dWt
Therefore
d

log (St)

=

μ + 1
2σ 2

dt + σ dWt
 t
τ=0
d

log (Sτ)

=

μ + 1
2σ 2
  t
τ=0
dτ + σ
 t
τ=0
dWτ
So
log (St) −log (S0) =

μ + 1
2σ 2

t + σ
 t
τ=0
dWτ
Taking expectations we obtain:
E

log(St)

−E

log(S0)

=

μ + 1
2σ 2

t + E

σ
 t
τ=0
dWτ

Since
E

σ
 t
τ=0
dWτ

= 0
and
E[S0] = S0
we have:
log
E[St]
S0

=

μ + 1
2σ 2

t
which yields:
E[St] = S0 exp

μ + 1
2σ 2

t


354
Computational Finance Using C and C#
Problem 11
Let φ = XtYt.
From Ito’s formula we obtain:
dφ = ∂φ
∂Xt
dXt + E
∂Yt
∂Yt
dYt + 1
2
∂2φ
∂Xt ∂Yt
dXt dYt + 1
2
∂2φ
∂Yt ∂Xt
dYt dXt

Now
∂2φ
∂Xt ∂Yt
=
∂2φ
∂Yt ∂Xt
= 1,
∂φ
∂Xt
= Yt
and
∂φ
∂Yt
= Xt
We thus obtain:
dφ = Yt dXt + Xt dYt + E[dXt dYt]
Using
d(XtYt) = Yt dXt + Xt dYt + E[dXt dYt]
we have:
 t
s=0
d(XtYt) =
 t
s=0
Ys dXs +
 t
s=0
XsdYs +
 t
s=0
E[dXs dYs]
Therefore
XtYt −Xt0Yt0 =
 t
s=0
YsdXs +
 t
s=0
XsdYs +
 t
s=0
E[dXs dYs]
Thus
 t
s=0
XsdYs = XtYt −Xt0Yt0 −
 t
s=0
YsdXs −
 t
s=0
E[dXs dYs]

References
Abramowitz, M., and Stegun, I.A. (1968). Handbook of Mathematical Functions. Dover
Publications.
Bachelier, L. (1900). Théorie de la spéculation. Annales scientiﬁques de l’École Normale
Supérieure, 17:21–86.
Barone-Adesi, G., and Whaley, R.E. (1987). Efﬁcient Analytic Approximation of Ameri-
can Option Values. The Journal of Finance, 42(2):301–320.
Barraquand, J., and Martineau, D. (1995). Numerical Valuation of High Dimen-
sional Multivariate American Securities. Journal of Finance ad Quantitative Analysis,
30:383–405.
Baxter, M., and Rennie, A. (1996). Financial Calculus: An Introduction to Derivative
Pricing. Cambridge University Press.
Black, F. (1973). Fact and Fantasy in the Use of Options and Corporate Liabilities. Finan-
cial Analysts Journal, 31:36–41, 61–72. Journal of Political Economy, 81:637–657.
Boyle, P.P., and Tian, Y. (1998). An Explicit Finite Difference Approach to the Pricing of
Barrier Options. Applied Mathematical Finance, 5:17–43.
Box, G.E.P., and Muller, M.E. (1958). A Note on the Generation of Random Normal
Deviates. Annals of Mathematical Statistics, 29:610–611.
Boyle, P.P., Evnine, J., and Gibbs, S. (1989). Numerical Evaluation of Multivariate Con-
tingent Claims. The Review of Management Studies, 2(2):241–250.
Boyle, P.P., Broadie, M., and Glasserman, P. (1997). Monte Carlo Methods for Security
Pricing. Journal of Economic Dynamics and Control, 21:1267–1321.
Brigo, D., and Mercurio, F. (2001). Interest Rate Models – Theory and Practice: With
Smile, Inﬂation and Credit. Springer-Verlag.
Broadie, M., and DeTemple, J. (1996). American Option Valuation: New Bounds, Ap-
proximations, and a Comparison of Existing Methods. The Review of Financial Stud-
ies, 9(4):1211–1250.
Broadie, M., and Glasserman, P. (1997). Pricing American-Style Securities Simulation.
Journal of Economic Dynamics and Control, 21:1323–1352.
Brotherton-Ratcliffe, R. (1994). Monte Carlo Motoring. Risk, 7(12):53–58.
Caﬂisch, R.E., Morokoff, W., and Owen, A. (1997). Valuation of Mortgage-Backed Se-
curities Using Brownian Bridges to Reduce Effective Dimension. The Journal of Com-
putational Finance, 1(1):27–46.
Cox, D.R., and Miller, H.D. (1965). The Theory of Stochastic Processes. Methuen & Co
Ltd.
Cox, J.C., Ross, S.A., and Rubinstein, M. (1979). Option Pricing: A Simpliﬁed Ap-
proach. Journal of Financial Economics, 7:229–263.
Crank, J., and Nicolson, P. (1947). A Practical Method for Numerical Evaluation of
Solutions of Partial Differential Equations of the Heat Conduction Type. Proceedings
of the Cambridge Philosophical Society, 43:50–67.

356
Computational Finance Using C and C#
Einstein, A. (1905). On the Movement of Small Particles Suspended in a Stationary Liq-
uid Demanded by the Molecular-Kinetic Theory of Heat. Annalen der Physik, 17.
Evans, M., Hastings, N., and Peacock, B. (2000). Statistical Distributions, Third Edition.
Wiley.
Garman, M.B., and Kohlhagen, S.W. (1983). Foreign Currency Option Values. Journal
of International Money and Finance, 2:231–237.
Geske, R. (1979). A Note on an Analytic Valuation Formula for Unprotected American
Options on Stocks with Known Dividends. Journal of Econometrics, 7:375–380.
Geske, R., and Johnson, H.E. (1984). The American Put Options Valued Analytically.
Journal of Finance, 39:1511–1524.
Golub, G.H., and Van Loan, C.F. (1989). Matrix Computation. The John Hopkins Uni-
versity Press.
Grimmett, G., and Welsh, D. (1986). Probability: An Introduction. Oxford Science Pub-
lications.
Hager, W. (1988). Applied Numerical Linear Algebra. Prentice Hall.
Harrison, J.M., and Kreps, D. (1979). Martingales and Arbitrage in Multiperiod Securi-
ties Markets. Journal of Economic Theory, 20:381–408.
Harrison, J.M., and Pliska, D. (1981). Martingales and Stochastic Integrals in the Theory
of Continuous Trading. Stochastic Processes and Their Applications, 11:215–260.
Higham, N.J. (2002). Computing the Nearest Correlation Matrix – A Problem from
Finance. IMA Journal of Numerical Analysis, 22(3):329–343.
Hull, J.C. (1997). Options, Futures and Other Derivatives, Third Edition. Prentice Hall.
Hull, J.C. (2003). Options, Futures and Other Derivatives, Fifth Edition. Prentice Hall.
Johnson, H. (1987). Options on the Maximum or the Minimum of Several Assets. Jour-
nal of Financial and Quantitative Analysis, 22(3):277–283.
Kamrad, B., and Ritchken, P. (1991). Multinomial Approximating Models for Options
with k State Variables. Management Science, 37(12):1640–1652.
Karatzas, I., and Shreve, S. (1991). Brownian Motion and Stochastic Calculus. Springer-
Verlag, New York.
Levy, P. (1939). Sur certains processus stochastiques homogènes. Compositio Mathemat-
ica, 7:283–339.
Levy, P. (1948). Processus stochastiques et mouvement brownien. Gauthier-Villar, Paris.
MacMillan, L.W. (1986). Analytic Approximation for the American Put Option. Ad-
vances in Futures and Options Research, 1:119–139.
Margrabe, W. (1978). The Value of an Option to Exchange one Asset for Another. Jour-
nal of Finance, 33(1):177–186.
Musiela, M., and Rutkowski, M. (1998). Martingale Methods in Financial Modelling.
Springer-Verlag.
Marchuk, G.I., and Shaidurov, V.V. (1983). Difference Methods and Their Extrapola-
tions. Springer-Verlag.
Øksendal, B. (2003). Stochastic Differential Equations: An Introduction with Applica-
tions. Springer-Verlag.
Perrin, J.B. (1909). Annales de Chimie et de Physique, 8me series, September 1909,
Translated by F. Soddy, as Brownian Movement and Molecular Reality, Taylor and
Francis, London, 1910.
Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery, B.P. (1992). Numerical
Recipes in C: The Art of Scientiﬁc Computing, Second Edition. Cambridge Univer-
sity Press.

References
357
Qi, H.D., and Sun, D. (2006). A Quadratically Convergent Newton Method for Com-
puting the Nearest Correlation Matrix. SIAM Journal on Matrix Analysis and Appli-
cations, 28(2):360–385.
Ramsbottom, J. (1932). Centenary of Robert Brown’s Discovery of the Nucleus –
Exhibit at Natural History Museum. The Journal of Botany British and Foreign,
(January):13–16.
Rebonato, R., and Jäckel, P. (1999/2000). The Most General Methodology for Creating a
Valid Correlation Matrix for Risk Management and Option Pricing Purposes. Journal
of Risk, 2(2).
Reiner, E. (1992). Quanto Mechanics. Risk, 5(3):59–63.
Roll, R. (1977). An Analytic Valuation Formula for Unprotected American Call Options
on Stocks with Known Dividends. Journal of Econometrics, 5:251–258.
Shreve, S., Chalasani, P., and Jha, S. (1997). Stochastic Calculus and Finance. Available
at: http://www.stat.berkeley.edu/users/evans/shreve.pdf.
Smith, G.D. (1985). Numerical Solution of Partial Differential Equations: Finite Differ-
ence Methods. Oxford University Press.
Stulz, R.M. (1982). Options on the Minimum or Maximum of Two Risky Assets. Journal
of Financial Economics, 10:161–185.
Tilley, J.A. (1993). Valuing American Options in a Path Simulation Model. Transactions
of the Society of Actuaries, 45:83–104.
Wiener, N. (1923). Differential Spaces. Journal of Mathematical Physics, 2:131–174.
Wiener, N. (1924). Un problème de probabilité dénombrables. Bulletin de Société Math-
ématique de France, 52:569–578.
Whaley, R.E. (1981). On the Valuation of American Call Options on Stocks with Known
Dividends. Journal of Financial Economics, 9:207–211.
Further reading
Aitchison, J., and Brown, J.A.C. (1966). The Lognormal Distribution. Cambridge Uni-
versity Press.
Andersen, L.B.G., and Brotherton-Ratcliffe, R. (1998). The Equity Option Volatility
Smile: An Implicit Finite-Difference Approach. Journal of Computational Finance,
1(2):5–37.
Anderson, T.W. (1984). An Introduction to Multivariate Statistical Analysis, Second Edi-
tion. Wiley, New York.
Berndt, E.K., Hall, B.H., Hall, R.E., and Hausman, J.A. (1974). Estimation and Infer-
ence in Nonlinear Structural Models. Annals of Economic and Social Measurement,
3/4:653–665.
Beyer, W.H. (1982). CRC Standard Mathematical Tables. CRC Press, Florida.
Black, F., and Scholes, M. (1973). The Pricing of Corporate Liabilities. Journal of Politi-
cal Economy, 81:637–657.
Bratley, P. (1986). Algorithm 647: Implementation and Relative Efﬁciency of Quasiran-
dom Sequence Generators. ACM Transactions on Mathematical Software, 12(4):362–
376.
Bratley, P., and Fox, B.L. (1988). Algorithm 659: Implementing Sobol’s Quasirandom
Sequence Generator. ACM Transactions on Mathematical Software, 14(1):88–100.

358
Computational Finance Using C and C#
Bratley, P., Fox, B.L., and Niederreiter, H. (1992). Implementation and Tests of Low-
Discrepancy Sequences. ACM Transactions on Modeling and Computer Simulation,
2(3):195–213.
Brennan, M.J., and Schwartz, E.S. (1978). Finite Difference Methods and Jump Processes
Arising in the Pricing of Contingent Claims: A Synthesis. Journal of Financial and
Quantitative Analysis, 13:462–474.
Chan, T.F., Golub, G.H., and Leveque, R.J. (1982). Updating Formulae and a Pair-
wise Algorithm for Computing Sample Variances. In: Caussinus, H.,, Tomassone,
R.,, Ettinger, P., eds.)Compstat 1982 Part 1: Proceedings in Computational Statistics.
Physica-Verlag, 1982.
Cotton, I.W. (1975). Remark on Stably Updating Mean and Standard Deviation of Data.
Communications of the ACM, 18(8):458.
Cox, D.R., and Hinkley, D.V. (1979). Theoretical Statistics. Chapman & Hall.
Craig, I.J.D., and Sneyd, A.D. (1988). An Alternating Direction Implicit Scheme for Par-
abolic Equations with Mixed Derivatives. Computers & Mathematics with Applica-
tions, 16(4):341–350.
Dickey, J.M. (1967). Multivariate Generalizations of the Multivariate t Distribution
and the Inverted Multivariate t Distribution. Annals of Mathematical Statistics,
38(2):511–518.
Dufﬁe, D. (1996). Dynamic Asset Pricing Theory, Second Edition. Princeton University
Press.
Engle, R.F. (1995). ARCH: Selected Readings. Advanced Texts in Econometrics. Oxford
University Press.
Faure, H. (1982). Discrépance de suites associées à un système de numération (en dimen-
sion s). Acta Arithmetica, 41:337–351.
Feller, W. (1971). An Introduction to Probability Theory and Its Applications, Vol. II.
Wiley.
Freedman, D. (1983). Brownian Motion and Diffusion. Springer-Verlag, New York.
Glasserman, P. (2004). Monte Carlo Methods in Financial Engineering. Springer-Verlag,
New York.
Glasserman, P., and Heidelberger, P. (2000). Variance Reduction Techniques for Value-
at-Risk with Heavy-Tailed Risk Factors. In: Joines, J.A., Barton, R.R., Kang, K., Fish-
wick, P.A. (eds.), Proceedings of the 2000 Winter Simulation Conference.
Goldberger, A.S. (1997). A Course in Econometrics. Harvard University Press.
Good, I.J. (1979). Computer Generation of the Exponential Power Distribution. Journal
of Statistical Computation and Simulation, 9(3):239–240.
Hamilton, J. (1994). Time Series Analysis. Princeton University Press.
Hanson, R.J. (1975). Stably Updating Mean and Standard Deviation of Data. Commu-
nications of the ACM, 18(1):57–58.
Haug, E.G. (1998). Option Pricing Formulas. McGraw Hill.
Hunt, P.J., and Kennedy, J.E. (2004). Financial Derivatives in Theory and Practice. Wiley.
Jäckel, P. (2002). Monte Carlo Methods in Finance. Wiley.
Johnson, N.L., and Kotz, S. (1992). Distributions in Statistics: Continuous Multivariate
Distributions. Wiley.
Johnson, N.L., Kotz, S., and Kemp, A. (1992). Univariate Discrete Distributions. Wiley.
Johnson, N.L., Kotz, S., and Balakvishnam, N. (1994). Continuous Univariate Distribu-
tions, Second Edition. Wiley.
Johnson, R.A., and Wichern, D.W. (1999). Applied Multivariate Statistical Analysis.
Prentice Hall.

References
359
Jorion, P. (1997). Value at Risk. McGraw Hill.
Joshi, M.S. (2004). The Concepts and Practice of Mathematical Finance. Cambridge
University Press.
Kloeden, P.E., and Platen, E. (1999). Numerical Solution of Stochastic Differential Equa-
tions. Springer-Verlag.
Krzanowski, W.J. (2000). Principles of Multivariate Analysis: A User’s Perspective. Ox-
ford University Press.
Levy, G. (2004). Computational Finance: Numerical Methods for Pricing Financial In-
struments. Elsevier.
Mardia, K.V., Kent, J.T., and Bibby, J.M. (1988). Multivariate Analysis. Probability and
Mathematical Statistics. Academic Press, London.
Martellini, L., and Priaulet, P. (2001). Fixed-Income Securities: Dynamic Methods for
Interest Rate Risk Pricing and Hedging. John Wiley.
Merton, R.C. (1973). The Theory of Rational Option Pricing. The Bell Journal of Econ-
omy and Management Science, 4(1):141–181.
Markowitz, H.M. (1989). Mean-Variance Analysis in Portfolio Choice and Capital Mar-
kets. Blackwell.
McIntyre, R. (1999). Black–Scholes Will Do. Energy & Power Risk Management,
(November):26–27.
McKee, S., and Mitchell, A.R. (1970). Alternating Direction Methods for Parabolic
Equations in Two Space Dimensions with a Mixed Derivative. The Computer Journal,
13(1):81–86.
Mitchell, A.R., and Grifﬁths, D.F. (1980). The Finite Difference Method in Partial Dif-
ferential Equations. Wiley, New York.
Morokoff, W. (1999). The Brownian Bridge E–M Algorithm for Covariance Estimation
with Missing Data. Journal of Computational Finance, 2(2):75–100.
Morgan, J.P. (1996). RiskMetrics – Technical Document, Fourth Edition. New York.
Niederreiter, H. (1992). Random Number Generation and Quasi-Monte Carlo Methods.
SIAM.
Pelsser, A. (2000). Efﬁcient Methods for Valuing Interest Rate Derivatives. Springer-
Verlag.
Rebonato, R. (1998). Interest-Rate Option Models, Second Edition. Wiley.
Richardson, L.F. (1910). The Approximate Arithmetical Solution by Finite Differences
od Physical Problems Involving Differential Equations, with an Application to the
Stresses in a Masonry Dam. Philos. Trans. R. Soc. Lond. A, 210:307–357.
Richardson, L.F., and Gaunt, G.A. (1927). The Deferred Approach to the Limit. Philos.
Trans. R. Soc. Lond. A, 226:299–361.
Richardson, L.F. (1927). Philosophical Transactions of the Royal Society of London,
Series A, 226:299.
Rogers, L.C.G., and Talay, D. (1997). Numerical Methods in Finance. Cambridge Uni-
versity Press.
Schonbucher, P.J. (2003). Credit Derivatives Pricing Models: Model, Pricing and Imple-
mentation. Wiley.
Sobol, I.M. (1967). The Distribution of Points in a Cube and the Approximate Eval-
uation of Integrals. USSR Computational Mathematics and Mathematical Physics,
7(4):86–112.
Strang, G. (1976). Linear Algebra and Its Applications. Academic Press.
Stuart, A., and Ord, J.K. (1987). Kendall’s Advanced Theory of Statistics, Fifth Edition.
Grifﬁn.

360
Computational Finance Using C and C#
West, D.H.D. (1979). Updating Mean and Variance Estimates: An Improved Method.
Communications of the ACM, 22(9):532–535.
Wilmott, P., Howison, S., and Dewynne, J. (1995). The Mathematics of Financial Deriv-
atives. Cambridge University Press.

Index
A
Absolute pricing errors 162
American options 59, 97–179
call options 99–102
Black approximation 101, 102
with cash dividends 97–102
critical asset values 107–109
MacMillan–Barone-Adesi–
Whaley method
105, 106, 112–114
pricing errors 135
Roll–Geske–Whaley
approximation 97–101
implied volatility 81
put options 179
critical asset values 109–111
MacMillan–Barone-Adesi–
Whaley method
106, 107, 112–114
pricing errors 136
stochastic lattice 172–180
asset prices 173, 174
Monte Carlo estimate 177–180
option prices 174–176
simulation parameters 173
two assets 194–200
vanilla 97–111
call with cash dividends 97–102
grid methods 135–167
lattice methods 114–135
MacMillan–Barone-Adesi–
Whaley method
102–107
numerical solution of critical
asset values 107–111
Amortization 212
Analytic pricing
down and out call options 86–88
up and out call options 88–91
Analytics_MathLib function 262–266
Annualized standard deviation 78
Arithmetic progression 323
Asset price, stochastic lattice 173, 174
Asset price index 161
Asset price movements, Brownian
motion 9, 10
Asset values 121, 122
Avogadro’s number 5
B
Back-substitution 146
Backwards iteration 123–125,
147–150
Barrier options 85–95, 118, 295–302
down and out call 86–88, 295–298
Monte Carlo pricing 91–95
equity 275–280
foreign exchange 284–288
up and out call 88–91, 298–301
Base currency 231
Basis swap 212–214
Bayes law 20, 93
BBS see binomial
Black–Scholes method
BBSR see binomial
Black–Scholes method, with
Richardson extrapolation
BEGKR method 185, 187–189
Binomial Black–Scholes method
131–133
with Richardson extrapolation
133–135

362
Index
Binomial lattice 81, 114–122
backwards iteration 123–125
with BBS and BBSR 131–135
computation of Greeks 125–129
construction and use 120–128
with control variate 129, 130
node asset values 121, 122
terminal node option payoff 122
values of constants 121
Black approximation 101, 102
black_scholes function 264
Black–Scholes equation 11, 37, 55
American options 129, 130
binomial 131–133
with Richardson
extrapolation 133–135
continuous dividends 72–74
derivation of 62–65
discrete dividends 74, 75
equity quanto options 240–243
European options 62–83, 129
multiasset option 65–67
foreign exchange 229–232
Greeks 75–77
historical volatility 78, 79
implied volatility 79–81
multiasset options 181, 182
see also grid methods;
MacMillan–Barone-Adesi–
Whaley method
Black–Scholes ﬁnite-difference
approximation 325–328
general case 325
log transformation 325–328
nonuniform grid method 148–155
uniform grid method 138–142,
160–162, 325–328
Boundary values 142, 143
lower asset 142
option maturity 142, 143
upper asset 142
Box–Muller transformation 42–45, 52
Brownian bridge 19–21
alternative derivation 329–332
down and out call options 91–95
relation to Ornstein–Uhlenbeck
bridge 30, 31
Brownian model of asset price
movements 9, 10
Brownian motion 5–9, 86
asset price movements 9, 10
drift
changing see Girsanov’s theorem
constant 8
zero 8
geometric 10, 12, 181
Ito’s quotient rule 17, 18
multiasset geometric 13–15
one source of randomness 16, 18
proofs 333–340
properties of 6–9
scaled 22
time-transformed 21–24
Brown, Robert 5, 7
bs_opt function 82
bs_opt_barrier_downout_call
function 88
C
C# code 245, 246
C# portfolio pricing 245–288
equity deal classes 267–280
equity barrier option 275–280
generic equity basket option
270–275
single equity options 267
two-equity option 267–269
foreign exchange deal classes
280–288
FX barrier option 284–288
FX forward 280, 281
single FX option 281–284
market data ﬁle 246
portfolio conﬁguration ﬁle 246
portfolio deﬁnition ﬁle 246
broad-investments 250–254
EQ-investments 249, 250,
253, 254
portfolio driver ﬁle 249

Index
363
portfolio valuer application
248, 249
PricingUtils and Analytics_MathLib
262–266
storing/retrieving market data
254–262
CurrencyTable 255–259
EquityTable and
CorrelationTable 259–262
Call options
American 99–102
Black approximation 101, 102
with cash dividends 97–102
critical asset values 107–109
MacMillan–Barone-Adesi–
Whaley method 105, 106,
112–114
pricing errors 135
Roll–Geske–Whaley
approximation 97–101
double knockout 166–171
down and in 85
down and out 85–88, 168
analytic pricing 86–88
Brownian bridge 91–95
Monte Carlo pricing 91–95
nonuniform grid method
153, 154
European 60, 61, 64, 65, 69, 73, 74,
76, 77, 79, 80, 82
multiasset
four assets 208
three assets 201, 204, 205
two assets 197, 198
up and in 85
up and out 85, 88–91
analytic pricing 88–91
vanilla
American 97–111
European 59, 69, 83, 84
Caplet, quanto 223–225
Central limit theorem 303, 304
Cholesky decomposition 48,
50, 52
Closed form solutions 181
Conditional mean 310, 311
Constant drift 8
Continuous dividends 61, 62, 72–74
Continuous hazard rate 233
Continuously compounded spot
rate 209
Control variate technique 129, 130
Correlated variates 47–58
correlation and covariance 46, 47
lognormal distribution 56–58
normal distribution 51–55
repairing correlation and covariance
matrices 48–51
Correlation 47
Correlation matrix 13, 47
optimally repaired 49–51
repair of 48–51
CorrelationTable 259–262
Coupon payment 211
early 217
ﬂoating leg 212
late 217, 218
on time 215, 216
Covariance 307–309
estimation of 47
four variables 308
normal distribution 310, 311
n variables 308, 309
three variables 307, 308
two variables 307
unconditional 23, 24
Covariance matrix 182, 309
repair of 48–51
Covered interest arbitrage 228, 229
Cox–Rubinstein–Ross binomial
model 188
Crank–Nicolson method 141,
159, 162, 163
Credit default swap 235, 236
Credit derivatives 232–237
credit default swap 235, 236
defaultable bond 235
hazard rate 232, 233
continuous 233

364
Index
estimation from market
observables 234, 235
total return swap 236, 237
Credit risk 2
Critical asset values, numerical
solution 107–111
CRR lattice 113
Cumulative normal distribution
function 322, 323
CurrencyTable 255–259
Current value 59
D
Defaultable bond 235
Delta 75, 119, 169
computation of 125
vanilla European options 291, 292
Depth ﬁrst procedure 177
Differential swaplet see
quanto, swaplet
Diff swaplet see quanto, swaplet
Discrete dividends 60, 61, 74, 75
Dividends
continuous 61, 62, 72–74
discrete 60, 61
Double knockout call option
166–171
Greeks 169
Down and in call options 85
Down and out call options 85–88,
168
analytic pricing 86–88
Brownian bridge 91–95
derivation of 295–298
Monte Carlo pricing 91–95
nonuniform grid method 153, 154
DownOutEquityOption-Deal 279
Drunkard’s walk see Brownian motion
E
Early coupon payment 217
Early exercise 147–150
Eigen decomposition 48
Equity barrier option 275–280
Equity deal classes 267–280
equity barrier option 275–280
generic equity basket option
270–275
single equity options 267
two-equity option 267–269
Equity derivatives 237–243
quantos 240–243
equity quanto forward 242, 243
quanto adjustment factor 241,
242
total return swap 237–240
equity leg 237, 238
equity swap 239, 240
ﬂoating leg 238
payer equity 238, 239
EquityOptionDeal 265–267
Equity quanto forward 242, 243
EquityTable 259–262
European options 59–95
barrier options 85–95
down and out call options 86–88
Monte Carlo pricing of down and
out options 91–95
up and out call options 88–91
call options 60, 61, 64, 65, 69, 73,
74, 76, 77, 79, 80, 82
double knockout 166, 167, 169–
171
down and in 85
down and out 85–88, 155,
156, 168
two assets 197, 198
foreign exchange 229–232
implied volatility 79–81
martingale measure 59, 60
multiasset
four assets 207, 208
three assets 201, 204, 205
two assets 190–194
put call parity 60–62
continuous dividends 61, 62
discrete dividends 60, 61
put options 59
four assets 208
three assets 202, 204, 205

Index
365
two assets 197, 198
vanilla 59, 62–83, 85
Black–Scholes equation 62–65
call options 59–85
Greeks for 289–294
put options 59
volatility
historical 78, 79
implied 79–81
Exotic options 83, 97, 118, 129, 147,
168, 183
Explicit method 141
F
Faure sequence 41
Feynman–Kac formula 64, 341, 342
Filtration 6
Financial derivatives 1–3
Finite-difference approximation
see Black–Scholes ﬁnite-difference
approximation
Floorlet, quanto 226
Foreign exchange call 231, 232
Foreign exchange deal classes
280–288
FX barrier option 284–288
FX forward 280, 281
single FX option 281–284
Foreign exchange derivatives 228–232
covered interest arbitrage 228, 229
European option 229–232
FX forward 229
Foreign exchange forward 1, 229
Foreign exchange option 2, 3
Forward rate agreement 210
Four asset options 205–208
FourEquityOptionDeal 273
Fubini’s theorem 26, 31
Fully implicit method 141
FX see foreign exchange
FX forward 229, 280, 281
G
Gamma 75, 119, 169
computation of 125
vanilla European options 290, 291
Gamma function 321, 322
Gaussian distribution see normal
distribution
General error distribution 319, 320
kurtosis 319, 320
shape parameter a 320
value of λ for variance hi 319
generic equity basket option 270–275
GenericEquityBasketOptionDeal
270–275
Geometric Brownian motion 10,
12, 181
Geometric progression 323
Girsanov’s theorem 12, 13, 68, 72
Going short 63, 66
Greeks 119
binomial lattice 125–129
Black–Scholes equation 75–77
double knockout call option 169
vanilla European options 289–294
see also individual Greeks
Grid methods 135–167
double knockout call option
166–169
log transformation
nonuniform grids 162–165
uniform grids 156–163
nonuniform grids 148–159
down and out call option
153, 154
ﬁnite-difference approximation
149–155
log transformation 162–165
uniform grids 136–150
backwards iteration and early
exercise 147–150
boundary conditions 142, 143
ﬁnite-difference approximation
138–142
log transformation 156–163
option values 143–147
H
Hazard rate 232, 233

366
Index
continuous 233
estimation from market observables
234, 235
Hazard rate curve 233
Heavy tail distributions 183
Hedge statistics see Greeks
I
ICurve 257–259
Implicit method 141
implied_volatility function 81
Implied volatility
American options 81
European options 79–81
Independent variates 41–46
lognormal distribution 45, 46
normal distribution 42–44
Student’s t-distribution 46
Integrals
barrier option 295–302
down and out call 295–298
up and out call 298–302
standard 321
stochastic 33
Interest rate derivatives 209–227
continuously compounded spot rate
209, 210
forward rate agreement 210
quantos 223–227
caplet 223–225
ﬂoorlet 226
swaplet 227
simply compounded spot rate 210
timing adjustment 218–223
Interest rate swap 211–218
amortization 212
basis swap 212–214
coupon payment 215–218
ﬂoating leg 212
general payment timing 216, 217
swap rate 212
vanilla 211
Ito’s formula 10–12
multiasset geometric Brownian
motion 13–15
two-dimensional 67
Ito’s isometry 26, 32
Ito’s product rule 15, 16
n dimensions 18, 19
Ito’s quotient rule 16–18, 241
K
Knockin options 83
Knockout options 83, 92
L
Late coupon payment 217, 218
Lattice methods
binomial lattice 81, 114–122
backwards iteration 123–125
with BBS and BBSR 131–135
computation of Greeks 125–129
construction and use 120–128
with control variate 129, 130
node asset values 121, 122
terminal node option payoff 122
values of constants 121
multiasset options 185–189
stochastic lattice 172–180
asset prices 173, 174
Monte Carlo estimate 177–180
option prices 174–176
simulation parameters 173
Law of large numbers 303
Lockout periods 118
Lognormal distribution 45, 46, 55–58,
114, 315, 316
Lognormal mean 114
Lognormal variance 115
log transformation
nonuniform grids 162–165
uniform grids 160–163
London Inter Bank Offer Rate
(LIBOR) 213
Low discrepancy sequences 38
M
MacMillan–Barone-Adesi–Whaley
method 102–107, 112–114
see also Black–Scholes equation

Index
367
Main currency 214
MarketDataDictionaries 254, 255,
259–262
Market data ﬁle 246
Market data, storing/retrieving
254–262
CurrencyTable 255–259
EquityTable and CorrelationTable
259–262
Market observables 233–235
Market rate dictionaries 250
Markov process 6
Martingale measure 6, 59, 60
Maturation 59
Mean 25
Ornstein–Uhlenbeck process 25
unconditional 23
Microsoft Excel
CALCULATE OPTIONS 83
NORMDIST 83
pricing options 82, 83
Moment generating functions 311,
312
Monte Carlo simulation 37, 172
American option 177–180
down and out options 91–95
multiasset options 183–185
with random numbers 40, 41
Multiasset geometric Brownian
motion 13–15
Multiasset options 181–208
Black–Scholes equation 65–67,
181, 182
four assets 205–208
lattices 185–189
Monte Carlo methods 183–185
three assets 201–205
two assets 190–201
American options 194–200
European exchange options
190–192
European options on maximum
or minimum 192–196
Multivariate distributions 41–46
generation of 47–58
lognormal distribution 45, 46
55–58, 114, 315–316
normal distribution see normal
distribution
Student’s t distribution 46, 317–318
N
Neiderreiter sequence 39, 40
Newton’s method 79, 80, 81, 98
Nonuniform grids 150–159
down and out call option 153, 154
ﬁnite-difference approximation
149–155
log transformation 162–165
Normal distribution 11, 21, 42–44,
51–55, 313–315
conditional mean 310, 311
covariance 310, 311
cumulative function 322, 323
mean 314
variance 314, 315
Numeraire 60, 218–222
O
Obligation 1
Option payoff 122
Option prices 174–176
Option values 143–147
Ornstein–Uhlenbeck bridge 27–31
relation to Brownian bridge 30, 31
Ornstein–Uhlenbeck process 22–27
mean 25
unconditional mean 23, 25
unconditional variance/covariance
23, 24
variance 25, 26
P
Payer equity total return swap 238,
239
Payer interest rate swap 211
Payment timing 216, 217
Payoff 59
Portfolio conﬁguration ﬁle 246
Portfolio deﬁnition ﬁle 246

368
Index
broad-investments 250–253, 254
EQ-investments 249, 250, 253, 254
Portfolio driver ﬁle 249
Present value 60
Pricing errors 135, 136
Pricing options, Microsoft Excel 82,
83
PricingUtils 262–266
Principal exchange 214
Pseudo-random sequences 38–41
Put call parity 77
continuous dividends 61, 62
discrete dividends 60, 61
Put options
American 179
critical asset values 109–111
MacMillan–Barone-Adesi–
Whaley method 106, 107,
112–114
pricing errors 136
European 59
four assets 208
three assets 202, 204, 205
two assets 197, 198
multiasset
four assets 208
three assets 201, 204
two assets 194, 197, 198
Q
Quantos
equity 240–243
equity quanto forward 242, 243
quanto adjustment factor 241,
242
interest rate 223–227
caplet 223–225
ﬂoorlet 226
swaplet 227
Quasirandom_Normal_LogNormal_
Correlated function 53–55
Quasi-random sequences 38–41
R
Radon–Nikodym derivative 12
Random variates 37–58
correlated variates 47–58
independent 41–46
lognormal distribution 45, 46
normal distribution 42–44
Student’s t-distribution 46
pseudo-random/quasi-random
sequences 38–41
Random walk see Brownian motion
Rate swap 211–218
amortization 212
basis swap 212–214
coupon payment
early 217
late 217, 218
on time 215, 216
ﬂoating leg 212
general payment timing 216, 217
payer 211
receiver 211
swap rate 212
vanilla 211
Receiver interest rate swap 211
Return 9
Rho 75
vanilla European options 293
RiskFreeRate 257
Roll–Geske–Whaley approximation
97–101
S
Scaled Brownian motion 22
Siedentopf, Henry 5
Simply compounded spot rate 210
Single equity options 267
Single FX option 281–284
Sobol sequences 39, 41, 184, 185
Spot rate
continuously compounded 209
simply compounded 210
Standard deviation, annualized 78
Standard integrals 321
Stochastic integral, expectation of 33
Stochastic lattice 172–180
asset prices 173–174

Index
369
Monte Carlo estimate 177–180
option prices 174–176
simulation parameters 173
Stochastic processes 5–35
Brownian bridge 19–21
Brownian model of asset price
movements 9, 10
Brownian motion 5–9
time-transformed 21–24
Girsanov’s theorem 12, 13
Ito’s product
in n dimensions 18, 19
and quotient rules 15–18
Ito’s formula 10–12
multiasset geometric Brownian
motion 13–15
Ornstein–Uhlenbeck bridge 27–31
Ornstein–Uhlenbeck process 22–27
Strike price 59
Structured deal 239
Student’s t-distribution 46, 317, 318
Swaplets 211
quanto 227
Swap rate 212
T
Taylor expansion 10, 14, 151
Theta 75, 119, 169
computation of 125, 126
vanilla European options 292, 293
Three asset options 201–205
Time-transformed Brownian motion
21–24
Timing adjustment 218–223
Total return swap
credit 236, 237
equity 237–240
equity leg 237, 238
equity swap 239, 240
ﬂoating leg 238
payer equity 238, 239
Trading days 78
Two asset options 190–201
American 197–200
European 190–192
maximum or minimum 192–194
Two-equity option 267–269
U
Unconditional mean 23
Unconditional variance 23, 24
Uniform grids 136–150
backwards iteration and early
exercise 147–150
boundary conditions 142, 143
ﬁnite-difference approximation
138–142
log transformation 156–163
option values 143–147
Up and in call options 86
Up and out call options 83, 88–91
analytic pricing 88–91
derivation of 298–302
V
Vanilla options
American 97–111
call with cash dividends 97–102
grid methods 135–167
lattice methods 114–135
MacMillan–Barone-Adesi–
Whaley method 102–107
numerical solution of critical asset
values 107–111
binomial lattice 81, 114–122
with BBS and BBSR 131–135
construction and use 120–128
with control variate 129, 130
European 59, 62–84
call 59, 69, 83, 85
Greeks for 289–294
put 59
grid methods 135–167
double knockout call option
166–169
nonuniform grids 148–159
uniform grids 136–150
interest rate swap 211
Variance 25, 26, 305–307
n variables 306, 307

370
Index
one variable 305
Ornstein–Uhlenbeck process 25, 26
three variables 306
two variables 305
unconditional 23, 24
Vega 76
computation of 126
vanilla European options 294
Visual Basic 82–84
bs_opt 84
bs_opt_barrier_downout_call 88
Volatility 7
historical 78, 79
implied 79–81
volatility smile 79
W
Wiener, Norbert 5
Wiener process see Brownian motion
Y
YieldCurve 257
Z
Zero coupon rate 257
Zero drift 8
Zsigmondy, Richard 5

Glossary
The notation used is as follows:
GBM Geometric Brownian motion
BM Brownian motion
Wt Brownian motion at time t
ρ the correlation coefﬁcient
E[x] the expectation value of X
Var[X] the variance of X
Cov[X, Y] the covariance between X and Y
Cov[X] the covariance between the variates contained in the vector X
σ the volatility. Since assets are assumed to follow GBM it is com-
puted as the annualized standard deviation of the n continuously
compounded returns
N1(a) the univariate cumulative normal distribution function. It gives the
cumulative probability, in a standardized univariate normal distrib-
ution, that the variable x1 satisﬁed x1 ⩽a
N2(a, b, ρ) the bivariate cumulative normal distribution. It gives the cumulative
probability, in a standardized bivariate normal distribution, that the
variables x1 and x2 satisfy x1 ⩽a and x2 ⩽b when with correlation
coefﬁcient between x1 and x2 is ρ
r the risk free interest rate
q the continously compounded dividend yield
Sit the ith asset price at time t
Inn the n by n unit matrix
(μ, σ 2) a lognormal distribution with parameters μ and σ 2. If y = log(x)
and y ∼N(μ, σ 2) then the distribution for x = ey is x ∼(μ, σ 2).
We have E[x] = exp(μ+ σ 2
2 ) and Var[x] = exp(2μ+σ 2)(exp(σ 2)−1)
Continued on back cover

Glossary (Continued)
DF(t, T ) the discount factor between times t and T , where T ⩾t. The price
of a nondefaultable zero coupon bond which matures at time T
is the expected value of DF(t, T ). In this book we assume that in-
terest rates are deterministic and thus DF(t, T ) is the value of a
nondefaultable zero coupon bond maturing at T
DF(t, T ) the discount factor (including the possibility of default) between
times t and T , where T ⩾t: DF(t, T ) = S(t, T )DF(t, T ). The price
of a defaultable zero coupon bond which matures at time T is the
expected value of DF(t, T ). In this book we assume that interest
rates are deterministic and thus DF(t, T ) is the value of a default-
able zero coupon bond maturing at T
F(t, T1, T2) the forward rate at time t between times T1 and T2 where T2 ⩾T1
and T1 ⩾t
L(T1, T2) the simply compounded spot rate between times T1 and T2, where
T2 ⩾T1
log(x) the natural logarithm of x
N(a, b) normal distribution, with mean a and variance b
dWt a normal variate (sampled at time t) from the distribution N(0, dt),
where dt a speciﬁed time interval e.g. dx = μ dt + dWt
dZt a normal variate (sampled at time t) from the distribution N(0, 1).
Note: The variate dψ =
√
dt dZt has the same distribution as dWt
IID independently and identically distributed
U(a, b) the uniform distribution, with lower limit a and upper limit b
|x| the absolute value of the variable x
PDF the probability density function of a given distribution
x ∧y the minimum of x and y, that is min(x, y)
S(t, T ) the survival probability between time t and T , T > t
∥A −B∥the distance between two matrices with the same dimensions. If A
and B both have n rows and m columns then this distance is:




n

i=1
m

j=1
{Ai,j −Bi,j}2
where Ai,j and Bi,j refer to the element in the ith row and jth
column

