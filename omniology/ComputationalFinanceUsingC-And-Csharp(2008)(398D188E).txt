
Computational Finance Using C and C#

Quantitative Finance Series
Aims and Objectives
‚Ä¢ Books based on the work of Ô¨Ånancial market practitioners and academics
‚Ä¢ Presenting cutting-edge research to the professional/practitioner market
‚Ä¢ Combining intellectual rigour and practical application
‚Ä¢ Covering the interaction between mathematical theory and Ô¨Ånancial practice
‚Ä¢ To improve portfolio performance, risk management and trading book performance
‚Ä¢ Covering quantitative techniques
Market
Brokers/Traders; Actuaries; Consultants; Asset Managers; Fund Managers; Regula-
tors; Central Bankers; Treasury OfÔ¨Åcials; Technical Analysis; and Academics for Mas-
ters in Finance and MBA market.
Series Titles
Computational Finance Using C and C#
The Analytics of Risk Model Validation
Forecasting Expected Returns in the Financial Markets
Corporate Governance and Regulatory Impact on Mergers and Acquisitions
International Mergers and Acquisitions Activity Since 1990
Forecasting Volatility in the Financial Markets, Third Edition
Venture Capital in Europe
Funds of Hedge Funds
Initial Public Offerings
Linear Factor Models in Finance
Computational Finance
Advances in Portfolio Construction and Implementation
Advanced Trading Rules, Second Edition
Real R&D Options
Performance Measurement in Finance
Economics for Financial Markets
Managing Downside Risk in Financial Markets
Derivative Instruments: Theory, Valuation, Analysis
Return Distributions in Finance
Series Editor: Dr Stephen Satchell
Dr Satchell is Reader in Financial Econometrics at Trinity College, Cambridge;
Visiting Professor at Birkbeck College, City University Business School and Univer-
sity of Technology, Sydney. He also works in a consultative capacity to many Ô¨Årms,
and edits the journal Derivatives: use, trading and regulations and the Journal of Asset
Management.

Computational Finance
Using C and C#
George Levy
AMSTERDAM ‚Ä¢ BOSTON ‚Ä¢ HEIDELBERG ‚Ä¢ LONDON ‚Ä¢ NEW YORK
OXFORD ‚Ä¢ PARIS ‚Ä¢ SAN DIEGO ‚Ä¢ SAN FRANCISCO ‚Ä¢ SINGAPORE
SYDNEY ‚Ä¢ TOKYO
Academic Press is an imprint of Elsevier

Cover image courtesy of iStockphoto
Academic Press is an imprint of Elsevier
30 Corporate Drive, Suite 400, Burlington, MA 01803, USA
525 B Street, Suite 1900, San Diego, California 92101-4495, USA
84 Theobald‚Äôs Road, London WC1X 8RR, UK
Copyright ¬© 2008, Elsevier Ltd. All rights reserved.
No part of this publication may be reproduced or transmitted in any form or by any
means, electronic or mechanical, including photocopy, recording, or any information
storage and retrieval system, without permission in writing from the publisher.
Permissions may be sought directly from Elsevier‚Äôs Science & Technology Rights
Department in Oxford, UK: phone: (+44) 1865 843830, fax: (+44) 1865 853333,
E-mail: permissions@elsevier.com. You may also complete your request on-line
via the Elsevier homepage (http://elsevier.com), by selecting ‚ÄúSupport & Contact‚Äù
then ‚ÄúCopyright and Permission‚Äù and then ‚ÄúObtaining Permissions.‚Äù
Library of Congress Cataloging-in-Publication Data
Levy, George.
Computational Finance Using C and C# / George Levy.
p. cm. ‚Äì (Quantitative Ô¨Ånance)
Includes bibliographical references and index.
ISBN-13: 978-0-7506-6919-1 (alk. paper) 1. Finance-Mathematical models. I. Title.
HG106.L484 2008
332.0285‚Äô5133-dc22
2008000470
British Library Cataloguing-in-Publication Data
A catalogue record for this book is available from the British Library.
For information on all Academic Press publications
visit our Web site at www.books.elsevier.com
Printed in the United States of America
08
09
10
11
9
8
7
6
5
4
3
2
1

To my parents Paul and Paula

blank
left
intentionally
page
This

Contents
Preface
xi
1
Overview of Ô¨Ånancial derivatives
1
2
Introduction to stochastic processes
5
2.1
Brownian motion
5
2.2
A Brownian model of asset price movements
9
2.3
Ito‚Äôs formula (or lemma)
10
2.4
Girsanov‚Äôs theorem
12
2.5
Ito‚Äôs lemma for multiasset geometric Brownian motion
13
2.6
Ito product and quotient rules in two dimensions
15
2.7
Ito product in n dimensions
18
2.8
The Brownian bridge
19
2.9
Time-transformed Brownian motion
21
2.10 Ornstein‚ÄìUhlenbeck process
24
2.11 The Ornstein‚ÄìUhlenbeck bridge
27
2.12 Other useful results
31
2.13 Selected problems
33
3
Generation of random variates
37
3.1 Introduction
37
3.2 Pseudo-random and quasi-random sequences
38
3.3 Generation of multivariate distributions: independent variates
41
3.4 Generation of multivariate distributions: correlated variates
47
4
European options
59
4.1 Introduction
59
4.2 Pricing derivatives using a martingale measure
59
4.3 Put call parity
60
4.4 Vanilla options and the Black‚ÄìScholes model
62
4.5 Barrier options
85
5
Single asset American options
97
5.1 Introduction
97
5.2 Approximations for vanilla American options
97
5.3 Lattice methods for vanilla options
114

viii
Computational Finance Using C and C#
5.4 Grid methods for vanilla options
135
5.5 Pricing American options using a stochastic lattice
172
6
Multiasset options
181
6.1 Introduction
181
6.2 The multiasset Black‚ÄìScholes equation
181
6.3 Multidimensional Monte Carlo methods
183
6.4 Introduction to multidimensional lattice methods
185
6.5 Two asset options
190
6.6 Three asset options
201
6.7 Four asset options
205
7
Other Ô¨Ånancial derivatives
209
7.1 Introduction
209
7.2 Interest rate derivatives
209
7.3 Foreign exchange derivatives
228
7.4 Credit derivatives
232
7.5 Equity derivatives
237
8
C# portfolio pricing application
245
8.1 Introduction
245
8.2 Storing and retrieving the market data
254
8.3 The PricingUtils class and the Analytics_MathLib
262
8.4 Equity deal classes
267
8.5 FX deal classes
280
Appendix A:
The Greeks for vanilla European options
289
A.1 Introduction
289
A.2 Gamma
290
A.3 Delta
291
A.4 Theta
292
A.5 Rho
293
A.6 Vega
294
Appendix B:
Barrier option integrals
295
B.1 The down and out call
295
B.2 The up and out call
298
Appendix C:
Standard statistical results
303
C.1 The law of large numbers
303
C.2 The central limit theorem
303
C.3 The variance and covariance of random variables
305
C.4 Conditional mean and covariance of normal distributions
310
C.5 Moment generating functions
311

Contents
ix
Appendix D:
Statistical distribution functions
313
D.1 The normal (Gaussian) distribution
313
D.2 The lognormal distribution
315
D.3 The Student‚Äôs t distribution
317
D.4 The general error distribution
319
Appendix E:
Mathematical reference
321
E.1 Standard integrals
321
E.2 Gamma function
321
E.3 The cumulative normal distribution function
322
E.4 Arithmetic and geometric progressions
323
Appendix F:
Black‚ÄìScholes Ô¨Ånite-difference schemes
325
F.1 The general case
325
F.2 The log transformation and a uniform grid
325
Appendix G:
The Brownian bridge: alternative derivation
329
Appendix H:
Brownian motion: more results
333
H.1 Some results concerning Brownian motion
333
H.2 Proof of Eq. (H.1.2)
334
H.3 Proof of Eq. (H.1.4)
335
H.4 Proof of Eq. (H.1.5)
335
H.5 Proof of Eq. (H.1.6)
335
H.6 Proof of Eq. (H.1.7)
338
H.7 Proof of Eq. (H.1.8)
338
H.8 Proof of Eq. (H.1.9)
338
H.9 Proof of Eq. (H.1.10)
339
Appendix I:
The Feynman‚ÄìKac formula
341
Appendix J:
Answers to problems
343
J.1
Problem 1
343
J.2
Problem 2
344
J.3
Problem 3
345
J.4
Problem 4
346
J.5
Problem 5
346
J.6
Problem 6
347
J.7
Problem 7
348
J.8
Problem 8
350
J.9
Problem 9
350
J.10 Problem 10
352
J.11 Problem 11
354
References
355
Index
361

blank
left
intentionally
page
This

Preface
This book builds on the author‚Äôs previous book Computational Finance: Nu-
merical Methods for Pricing Financial Instruments, which contained informa-
tion on pricing equity options using C code. The current book covers the fol-
lowing instrument types:
‚Ä¢ Equity derivatives
‚Ä¢ Interest rate derivatives
‚Ä¢ Foreign exchange derivatives
‚Ä¢ Credit derivatives
There is also an extensive Ô¨Ånal chapter which demonstrates how a C-based
analytics pricing library can be used by C# portfolio valuation software. In ad-
dition this application:
‚Ä¢ illustrates the use of C# dictionaries, abstract classes and .NET InteropSer-
vices
‚Ä¢ permits the reader to value bespoke portfolios
‚Ä¢ allows market data to be speciÔ¨Åed via a conÔ¨Åguration Ô¨Åle
‚Ä¢ contains a generic basket pricer for which the reader can specify the payoff
function
‚Ä¢ can be freely downloaded for use by the reader.
The current book also contains increased coverage of stochastic processes, Ito
calculus and Monte Carlo simulation. These topics are supported by practical
applications and solved example problems.
In addition the Numerical Algorithms Group (NAG) have allowed readers
to enjoy an extended trial licence for the NAG C library and associated Ô¨Ånan-
cial routines from the following url: www.nag.co.uk/market/elsevier_glevy. The
NAG C library may be called into C# and provides a large suite of mathematical
routines addressing many areas covered in this book (random numbers, statisti-
cal distributions, option pricing, correlation and covariance matrices etc.).
Computational Finance Using C and C# also includes supporting software
that may be downloaded for free. The software consists of executable Ô¨Åles, con-
Ô¨Åguration Ô¨Åles and results Ô¨Åles. With these Ô¨Åles the user can run the example
portfolio application in Chapter 8 and change the portfolio composition and
the attributes of the deals.
Additional upgrade software is available for purchase with Computational
Finance Using C and C#. The software includes:
‚Ä¢ Code to run all the C, C# and Excel examples in the book

xii
Computational Finance Using C and C#
‚Ä¢ Complete C source code for the Analytics_Mathlib math library that is used
in the book
‚Ä¢ C# source code, market data and portfolio Ô¨Åles for the portfolio application
described in Chapter 8
All the C/C# software in the book can be compiled using either Visual Studio
.NET 2005, or the freely available Microsoft Visual C#/C++ Express Editions.
I would like to take this opportunity of thanking my wife Kathy for her sup-
port.
In addition I am grateful to Karen Maloney of Elsevier for her patience with
regard to the book‚Äôs delivery date, and Dr. Stephen Satchell of Trinity College
Cambridge for allowing me the opportunity to write a sequel.
George Levy
Benson, Oxfordshire, UK
2008

1 Overview of Ô¨Ånancial derivatives
A Ô¨Ånancial derivative is a contract between two counterparties (here referred
to as A and B) which derives its value from the state of underlying Ô¨Ånancial
quantities. We can further divide derivatives into those that carry a future oblig-
ation and those that don‚Äôt. In the Ô¨Ånancial world a derivative which gives the
owner the right but not the obligation to participate in a given Ô¨Ånancial contract
is called an option. We will now illustrate this using both a Foreign Exchange
Forward contract and a Foreign Exchange option.
Foreign Exchange Forward‚Äîa contract with an obligation
In a Foreign Exchange Forward contract a certain amount of foreign currency
will be bought (or sold) at a future date using a prearranged foreign exchange
rate.
For instance, counterparty A may own a Foreign Exchange Forward which,
in one year‚Äôs time, contractually obliges A to purchase from B the sum of $200
for ¬£100. At the end of one year several things may have happened.
(i) The value of the pound may have decreased with respect to the dollar
(ii) The value of the pound may have increased with respect to the dollar
(iii) Counterparty B may refuse to honor the contract‚ÄîB may have gone bust,
etc.
(iv) Counterparty A may refuse to honor the contract‚ÄîA may have gone bust,
etc.
We will now consider events (i)‚Äì(iv) from A‚Äôs perspective.
Firstly, if (i) occurs then A will be able to obtain $200 for less than the current
market rate, say ¬£120. In this case the $200 can be bought for ¬£100 and then
immediately sold for ¬£120, giving a proÔ¨Åt of ¬£20. However, this proÔ¨Åt can only
be realized if B honors the contract‚Äîthat is, event (iii) does not happen.
Secondly, when (ii) occurs then A is obliged to purchase $200 for more than
the current market rate, say ¬£90. In this case the $200 are bought for ¬£100 but
could have been bought for only ¬£90, giving a loss of ¬£10.
The probability of events (iii) and (iv) occurring are related to the Credit Risk
associated with counterparty B. The value of the contract to A is not affected
by (iv), although A may be sued if both (ii) and (iv) occur. Counterparty A
should only be concerned with the possibility of events (i) and (iii) occurring‚Äî
that is, the probability that the contract is worth a positive amount in one year

2
Computational Finance Using C and C#
and the probability that B will honor the contract (which is one minus the
probability that event (iii) will happen).
From B‚Äôs point of view the important Credit Risk is when both (ii) and (iv)
occur‚Äîthat is, when the contract has positive value but counterparty A defaults.
Foreign Exchange option‚Äîa contract without an obligation
A Foreign Exchange option is similar to the Foreign Exchange Forward, the
difference being that if event (ii) occurs then A is not obliged to buy dollars
at an unfavorable exchange rate. To have this Ô¨Çexibility A needs to buy a For-
eign Exchange option from B, which here can be regarded as insurance against
unexpected exchange rate Ô¨Çuctuations.
For instance, counterparty A may own a Foreign Exchange option which, in
one year, contractually allows A to purchase from B the sum of $200 for ¬£100.
As before, at the end of one year the following may have happened:
(i) The value of the pound may have decreased with respect to the dollar
(ii) The value of the pound may have increased with respect to the dollar
(iii) Counterparty B may refuse to honor the contract‚ÄîB may have gone bust,
etc.
(iv) Counterparty A may have gone bust, etc.
We will now consider events (i)‚Äì(iv) from A‚Äôs perspective.
Firstly, if (i) occurs then A will be able to obtain $200 for less than the current
market rate, say ¬£120. In this case the $200 can be bought for ¬£100 and then
immediately sold for ¬£120, giving a proÔ¨Åt of ¬£20. However, this proÔ¨Åt can only
be realized if B honors the contract‚Äîthat is, event (iii) does not happen.
Secondly, when (ii) occurs then A will decide not to purchase $200 for more
than the current market rate; in this case the option is worthless.
We can thus see that A is still concerned with the Credit Risk when events
(i) and (iii) occur simultaneously.
The Credit Risk from counterparty B‚Äôs point of view is different. B has sold
to A a Foreign Exchange option, which matures in one year, and has already
received the money‚Äîthe current fair price for the option. Counterparty B has
no Credit Risk associated with A. This is because if event (iv) occurs, and A
goes bust, it doesn‚Äôt matter to B since the money for the option has already
been received. On the other hand, if event (iii) occurs B may be sued by A but
B still has no Credit Risk associated with A.
This book considers the valuation of Ô¨Ånancial derivatives that carry obliga-
tions and also Ô¨Ånancial options.
Chapters 1‚Äì7 deal with both the theory of stochastic processes and the pric-
ing of Ô¨Ånancial instruments. In Chapter 8 this information is then applied to a
C# portfolio valuer. The application is easy to use (the portfolios and current
market rates are deÔ¨Åned in text Ô¨Åles) and can also be extended to include new
trade types.

Overview of Ô¨Ånancial derivatives
3
The book has been written so that (as far as possible) Ô¨Ånancial mathematics
results are derived from Ô¨Årst principles.
Finally, the appendices contain various information, which we hope the
reader will Ô¨Ånd useful.

blank
left
intentionally
page
This

2 Introduction to stochastic
processes
2.1
Brownian motion
Brownian motion is named after the botanist Robert Brown who used a micro-
scope to study the fertilization mechanism of Ô¨Çowering plants. He Ô¨Årst observed
the random motion of pollen particles (obtained from the American species
Clarkia pulchella) suspended in water, and wrote:
The fovilla or granules Ô¨Åll the whole orbicular disk but do not extend to the
projecting angles. They are not sphaerical but oblong or nearly cylindrical,
and the particles have manifest motion. This motion is only visible to my
lens which magniÔ¨Åes 370 times. The motion is obscure yet certain . . .
Robert Brown, 12th June 1827; see Ramsbottom (1932)
It appears that Brown considered this motion no more than a curiosity (he be-
lieved that the particles were alive) and continued undistracted with his botan-
ical research. The full signiÔ¨Åcance of his observations only became apparent
about eighty years later when it was shown (Einstein, 1905) that the motion
is caused by the collisions that occur between the pollen grains and the water
molecules. In 1908 Perrin (1909) was Ô¨Ånally able to conÔ¨Årm Einstein‚Äôs predic-
tions experimentally. His work was made possible by the development of the
ultramicroscope by Richard Zsigmondy and Henry Siedentopf in 1903. He was
able to work out from his experimental results and Einstein‚Äôs formula the size
of the water molecule and a precise value for Avogadro‚Äôs number. His work
established the physical theory of Brownian motion and ended the skepticism
about the existence of atoms and molecules as actual physical entities. Many of
the fundamental properties of Brownian motion were discovered by Paul Levy
(Levy, 1939, 1948), and the Ô¨Årst mathematically rigorous treatment was pro-
vided by Norbert Wiener (Wiener, 1923, 1924). Karatzas and Shreve (1991) is
an excellent textbook on the theoretical properties of Brownian motion, while
Shreve, Chalasani, and Jha (1997) provides much useful information concerning
the use of Brownian processes within Ô¨Ånance.
Brownian motion is also called a random walk, a Wiener process, or some-
times (more poetically) the drunkard‚Äôs walk. We will now present the three fun-
damental properties of Brownian motion.

6
Computational Finance Using C and C#
2.1.1
The properties of Brownian motion
In formal terms a process W = (Wt: t ‚©æ0) is (one-dimensional) Brownian
motion if:
(i) Wt is continuous, and W0 = 0,
(ii) Wt ‚àºN(0, t),
(iii) The increment dWt = Wt+dt ‚àíWt is normally distributed as dWt ‚àºN(0, dt),
so E[dWt] = 0 and Var[dWt] = dt. The increment dWt is also independent
of the history of the process up to time t.
From (iii) we can further state that, since the increments dWt are independent
of past values Wt, a Brownian process is also a Markov process. In addition we
shall now show that a Brownian process is also a martingale process.
In a martingale process Pt, t ‚©æ0, the conditional expectation E[Pt+dt|Ft] =
Pt, where Ft is called the Ô¨Åltration generated by the process and contains the
information learned by observing the process up to time t. Since for Brownian
motion we have
E[Wt+dt|Ft] = E

(Wt+dt ‚àíWt) + Wt|Ft

= E[Wt+dt ‚àíWt] + Wt
= E[dWt] + Wt = Wt
where we have used the fact that E[dWt] = 0. Since E[Wt+dt|Ft] = Wt the
Brownian motion W is a martingale process.
Using property (iii) we can also derive an expression for the covariance of
Brownian motion. The independent increment requirement means that for the
n times 0 ‚©Ωt0 < t1 < t2 < ¬∑ ¬∑ ¬∑ < tn < ‚àûthe random variables Wt1 ‚àíWt0, Wt2 ‚àí
Wt1, . . . , Wtn ‚àíWtn‚àí1 are independent. So
Cov[Wti ‚àíWti‚àí1, Wtj ‚àíWtj‚àí1] = 0,
i Ã∏= j
(2.1.1)
We will show that Cov[Ws, Wt] = s ‚àßt.
Proof. Using Wt0 = 0, and assuming t ‚©æs we have
Cov[Ws ‚àíWt0, Wt ‚àíWt0] = Cov[Ws, Wt] = Cov

Ws, Ws + (Wt ‚àíWs)

From Appendix C.3.2 we have
Cov

Ws, Ws + (Wt ‚àíWs)

= Cov[Ws, Ws] + Cov[Ws, Wt ‚àíWs]
= Var[Ws] + Cov[Ws, Wt ‚àíWs]
Therefore
Cov[Ws, Wt] = s + Cov[Ws, Wt ‚àíWs]
Now
Cov[Ws, Wt ‚àíWs] = Cov[Ws ‚àíWt0, Wt ‚àíWs] = 0
where we have used Eq. (2.1.1) with n = 2, t1 = s and t2 = t.

Introduction to stochastic processes
7
We thus obtain
Cov[Ws, Wt] = s
So
Cov[Ws, Wt] = s ‚àßt
(2.1.2)
‚ñ°
We will now consider the Brownian increments over the time interval dt in
more detail. Let us Ô¨Årst deÔ¨Åne the process X such that:
dXt = dWt
(2.1.3)
where dWt is a random variable drawn from a normal distribution with mean
zero and variance dt, which we denote as dWt ‚àºN(0, dt). Equation (2.1.3) can
also be written in the equivalent form:
dXt =
‚àö
dt dZ
(2.1.4)
where dZ is a random variable drawn from a standard normal distribution (that
is a normal distribution with zero mean and unit variance).
Equations (2.1.3) and (2.1.4) give the incremental change in the value of X
over the time interval dt for standard Brownian motion.
We shall now generalize these equations slightly by introducing the extra
(volatility) parameter œÉ which controls the variance of the process. We now
have:
dXt = œÉdWt
(2.1.5)
where dWt ‚àºN(0, dt) and dXt ‚àºN(0, œÉ 2 dt). Equation (2.1.5) can also be
written in the equivalent form:
dXt = œÉ
‚àö
dt dZ,
dZ ‚àºN(0, 1)
(2.1.6)
or equivalently
dXt =
‚àö
dt dZ,
dZ ‚àºN

0, œÉ 2
(2.1.7)
We are now in a position to provide a mathematical description of the move-
ment of the pollen grains observed by Robert Brown in 1827. We will start
by assuming that the container of water is perfectly level. This will ensure that
there is no drift of the pollen grains in any particular direction. Let us denote
the position of a particular pollen grain at time t by Xt, and set the position
at t = 0, Xt0, to zero. The statistical distribution of the grain‚Äôs position, XT , at
some later time t = T , can be found as follows:
Let us divide the time T into n equal intervals dt = T /n. Since the position of
the particle changes by the amount dXi = œÉ
‚àö
dt dZi over the ith time interval
dt, the Ô¨Ånal position XT is given by:
XT =
n

i=1

œÉ
‚àö
dt dZi

= œÉ
‚àö
dt
n

i=1
dZi

8
Computational Finance Using C and C#
Since dZi ‚àºN(0, 1), by the Law of Large Numbers (see Appendix C.1), we have
that the expected value of position XT is:
E[XT ] = œÉ
‚àö
dtE
 n

i=1
dZi
	
= 0
The variance of the position XT is:
Var[XT ] = Var

œÉ
‚àö
dt
n

i=1
dZi
	
= œÉ 2 dt Var
 n

i=1
dZi
	
(2.1.8)
Since all the dZi variates are IID N(0, 1) we have Var[dZi]
=
1 and
Var[
n
i=1 Xi] = 
n
i=1 Var[Xi] (see Appendix C.3.1).
Thus
Var[XT ] = œÉ 2 dt
n

i=1
Var[dZi] = œÉ 2 dt
n

i=1
1
(2.1.9)
which gives:
Var[XT ] = œÉ 2n dt = T œÉ 2
(2.1.10)
So, at time T , the position of the pollen grain XT is distributed as XT
‚àº
N(0, T œÉ 2).
If the water container is not perfectly level then the pollen grains will ex-
hibit drift in a particular direction. We can modify Eq. (2.1.5) to take this into
account as follows:
dXt = Œº dt + œÉ
‚àö
dt dZi,
dZi ‚àºN(0, 1),
(2.1.11)
or equivalently
dXt = Œº dt + œÉ dWt,
dWt ‚àºN(0, dt),
(2.1.12)
where we have included the constant drift Œº. Proceeding in a similar manner to
that for the case of zero drift Brownian motion we have:
XT =
n

i=1

Œº dt + œÉ
‚àö
dt dZi

= Œº
n

i=1
dt + œÉ
‚àö
dt
n

i=1
dZi
= ŒºT + œÉ
‚àö
dt
n

i=1
dZi
which gives
E[XT ] = E

ŒºT + œÉ
‚àö
dt
n

i=1
dZi
	
E[XT ] = ŒºT + œÉ
‚àö
dtE
 n

i=1
dZi
	
= ŒºT

Introduction to stochastic processes
9
The variance of the position XT is:
Var[XT ] = Var

ŒºT + œÉ
‚àö
dt
n

i=1
dZi
	
= Var

œÉ
‚àö
dt
n

i=1
dZi
	
Here we have used the fact (see Appendix C.3.1) that Var[a + bX] = b2 Var[X],
where a = ŒºT , and b = 1. From Eqs. (2.1.9) and (2.1.10) we have:
Var[XT ] = Var

œÉ
‚àö
dt
n

i=1
dZi
	
= T œÉ 2
So, at time T , the position of the pollen grain XT is distributed as XT
‚àº
N(ŒºT, T œÉ 2).
We have just shown that when we vary the drift of a Brownian motion, its
volatility remains unchanged. This is a very important property and (as we will
see later) is used extensively in the theory of derivative pricing.
2.2
A Brownian model of asset price movements
In the previous section we showed how Brownian motion can be used to de-
scribe the random motion of small particles suspended in a liquid. The Ô¨Årst
attempt at using Brownian motion to describe Ô¨Ånancial asset price movements
was provided by Bachelier (1900). This, however, only had limited success be-
cause the signiÔ¨Åcance of a given absolute change in asset price depends on the
original asset price. For example, a ¬£1 increase in the value of a share originally
worth ¬£1.10 is much more signiÔ¨Åcant than a ¬£1 increase in the value of a share
originally worth ¬£100. It is for this reason that asset price movements are gen-
erally described in terms of relative or percentage changes. For example, if the
¬£1.10 share increases in value by 11 pence and the ¬£100 share increases in value
by ¬£10, then both of these price changes have the same signiÔ¨Åcance, and corre-
spond to a 10 percent increase in value. The idea of relative price changes in the
value of a share can be formalized by deÔ¨Åning a quantity called the return, Rt,
of a share at time t. The return Rt is deÔ¨Åned as follows:
Rt = St+dt ‚àíSt
St
= dSt
St
(2.2.1)
where St+dt is the value of the share at time t + dt, St is the value of the share at
time t, and dSt is the change in value of the share over the time interval dt. The
percentage return R‚àóover the time interval dt is simply deÔ¨Åned as R‚àó= 100√óRt.
We are now in a position to construct a simple Brownian model of asset
price movements; further information on Brownian motion within Ô¨Ånance can
be found in Shreve, Chalasani, and Jha (1997).
The asset return at time t is now given by:
Rt = dSt
St
= Œº dt + œÉ dWt,
dWt ‚àºN(0, dt),
(2.2.2)

10
Computational Finance Using C and C#
or equivalently:
dSt = StŒº dt + StœÉ dWt
(2.2.3)
The process in Eqs. (2.2.2) and (2.2.3) is termed geometric Brownian motion;
which we will abbreviate as GBM. This is because the relative (rather than ab-
solute) price changes follow Brownian motion.
2.3
Ito‚Äôs formula (or lemma)
In this section we will derive Ito‚Äôs formula; a more rigorous treatment can be
found in Karatzas and Shreve (1991).
Let us consider the stochastic process X:
dX = a dt + b dW = a dt + b
‚àö
dt dZ,
dZ ‚àºN(0, 1), dW ‚àºN(0, dt)
(2.3.1)
where a and b are constants. We want to Ô¨Ånd the process followed by a function
of the stochastic variable X, that is œÜ(X, t). This can be done by applying a
Taylor expansion, up to second order, in the two variables X and t as follows:
œÜ‚àó= œÜ + ‚àÇœÜ
‚àÇt dt + ‚àÇœÜ
‚àÇX dX + 1
2
‚àÇ2œÜ
‚àÇX2 dX2 + 1
2
‚àÇ2œÜ
‚àÇt2 dt2 +
‚àÇœÜ
‚àÇX ‚àÇt dX dt
(2.3.2)
where œÜ‚àóis used to denote the value œÜ(X + dX, t + dt), and œÜ denotes the value
œÜ(X, t). We will now consider the magnitude of the terms dX2, dX dt, and dt2
as dt ‚Üí0. First
dX2 =

a dt + b
‚àö
dt dZ

a dt + b
‚àö
dt dZ

= a2 dt2 + 2ab dt3/2 dZ + b2 dt dZ2
then
dX dt = a dt2 + b dt3/2 dZ
So as dt ‚Üí0, and ignoring all terms in dt of order greater than 1, we have:
dX2 ‚àºb2 dt dZ2,
dt2 ‚àº0,
and
dX dt ‚àº0
Therefore Eq. (2.3.2) can be rewritten as:
dœÜ = ‚àÇœÜ
‚àÇt dt + ‚àÇœÜ
‚àÇX dX + 1
2
‚àÇ2œÜ
‚àÇX2 E

dX2
(2.3.3)
where dœÜ = œÜ‚àó‚àíœÜ, and we have replaced dX2 by its expected value E[dX2].
Now
E

dX2
= E

b2 dt dZ2
= b2 dtE

dZ2
= b2 dt

Introduction to stochastic processes
11
where we have used the fact that, since dZ ‚àºN(0, 1), the variance of dZ,
E[dZ2], is by deÔ¨Ånition equal to 1. Using these values in Eq. (2.3.3) and substi-
tuting for dX from Eq. (2.3.1), we obtain:
dœÜ = ‚àÇœÜ
‚àÇt dt + ‚àÇœÜ
‚àÇX (a dt + b dw) + b2
2
‚àÇ2œÜ
‚àÇX2 dt
(2.3.4)
This gives Ito‚Äôs formula
dœÜ =
‚àÇœÜ
‚àÇt + a ‚àÇœÜ
‚àÇX + b2
2
‚àÇ2œÜ
‚àÇX2

dt + ‚àÇœÜ
‚àÇX b dW
(2.3.5)
In particular if we consider the geometric Brownian process:
dS = ŒºS dt + œÉS dW
where Œº and œÉ are constants, then substituting X = S, a = ŒºS, and b = œÉS into
Eq. (2.3.5) yields:
dœÜ =
‚àÇœÜ
‚àÇt + ŒºS ‚àÇœÜ
‚àÇS + œÉ 2S2
2
‚àÇ2œÜ
‚àÇS2

dt + ‚àÇœÜ
‚àÇS œÉS dW
(2.3.6)
Equation (2.3.6) describes the change in value of a function œÜ(S, t) over the time
interval dt, when the stochastic variable S follows GBM. This result has very
important applications in the pricing of Ô¨Ånancial derivatives. Here the function
œÜ(S, t) is taken as the price of a Ô¨Ånancial derivative, f (S, t), that depends on the
value of an underlying asset S, which is assumed to follow GBM. In Chapter 4
we will use Eq. (2.3.6) to derive the (Black‚ÄìScholes) partial differential equation
that is satisÔ¨Åed by the price of a Ô¨Ånancial derivative.
We can also use Eq. (2.3.3) to derive the process followed by œÜ = log(St). We
have:
‚àÇœÜ
‚àÇSt
= ‚àÇlog(St)
‚àÇS
= 1
S ,
‚àÇ2œÜ
‚àÇS2t
=
‚àÇ
‚àÇSt
‚àÇlog(St)
‚àÇSt

=
‚àÇ
‚àÇSt
 1
St

= ‚àí1
S2t
‚àÇœÜ
‚àÇt = ‚àÇlog(St)
‚àÇt
= 0
So
d

log(St)

= ŒΩ dt + œÉ dWt
where ŒΩ = Œº ‚àíœÉ 2
2
(2.3.7)
Integrating Eq. (2.3.7) yields
 T
t=t0
d

log(St)

=
 T
t=t0
ŒΩ dt +
 T
t=t0
œÉ dWt
so
log(ST ) ‚àílog(St0) = ŒΩT + œÉWT
(2.3.8)
where we have used t0 = 0 and Wt0 = 0.

12
Computational Finance Using C and C#
We obtain
log
ST
St0

‚àºN

ŒΩT, œÉ 2T

(2.3.9)
and so
log
ST
St0

= ŒΩT + œÉWT
(2.3.10)
The solution to the geometric Brownian motion (GBM) in Eq. (2.2.3) is
ST = St0 exp(ŒΩT + œÉWT ),
ŒΩ = Œº ‚àíœÉ 2
2
(2.3.11)
The asset value at time t + dt can therefore be generated from its value at
time t by using
St+dt = St exp{ŒΩ dt + œÉ dWt}
We have shown that if the asset price follows geometric Brownian motion,
then the logarithm of the asset price follows standard Brownian motion. An-
other way of stating this is that, over the time interval dt, the change in the
logarithm of the asset price is a Gaussian distribution with mean (Œº ‚àíœÉ 2/2) dt,
and variance œÉ 2 dt.
These results can easily be generalized to include time varying drift and
volatility. Now instead of Eq. (2.2.3) we have
dSt = StŒºt dt + StœÉt dWt
(2.3.12)
which results in
d

log(St)

= ŒΩt dt + œÉt dWt
(2.3.13)
so
 T
t=t0
d

log(St)

=
 T
t=t0
ŒΩt dt +
 T
t=t0
œÉt dWt
which results in the following solution for ST
ST = St0 exp
 T
t=t0
ŒΩt dt +
 T
t=t0
œÉt dWt

where ŒΩt = Œºt ‚àíœÉ 2
t
2
(2.3.14)
The results presented in Eqs. (2.3.11) and (2.3.14) are very important and
will be referred to in later sections of the book.
2.4
Girsanov‚Äôs theorem
This theorem states that for any stochastic process k(t) such that
 t
0 k(s)2 ds <
‚àûthen the Radon‚ÄìNikodym derivative dQ
dP = œÅ(t) is given by:
œÅ(t) = exp
 t
0
k(s) dW P
s ‚àí1
2
 t
0
k(s)2 ds

(2.4.1)

Introduction to stochastic processes
13
where W P
t
is Brownian motion (possibly with drift) under probability measure
P, see Baxter and Rennie (1996). Under probability measure Q we have:
W Q
t
= W P
t ‚àí
 t
0
k(s) ds
(2.4.2)
where W Q
t
is also Brownian motion (possibly with drift).
We can also write
dW P = dW Q + k(t) dt
(2.4.3)
Girsanov‚Äôs theorem thus provides a mechanism for changing the drift of a
Brownian motion.
2.5
Ito‚Äôs lemma for multiasset geometric Brownian motion
We will now consider the n-dimensional stochastic process:
dXi = ai dt + bi
‚àö
dt dZi = ai dt + bi dWi,
i = 1, . . . , n,
(2.5.1)
or in vector form:
dX = A dt +
‚àö
dtB dZ = A dt + B dW
(2.5.2)
where A and B are n-element vectors respectively containing the constants,
ai, i = 1, . . . , n, and bi, i = 1, . . . , n. The stochastic vector dX contains the
n stochastic variables Xi, i = 1, . . . , n.
We will assume that the n element random vector dZ is drawn from a mul-
tivariate normal distribution with zero mean and covariance matrix 
C. That is,
we can write:
dZ ‚àºN(0, 
C)
Since 
Cii = Var[dZi] = 1, i = 1, . . . , n, the diagonal elements of 
C are all unity
and the matrix 
C is in fact a correlation matrix with off-diagonal elements given
by:

Cij = E[dZi dZj] = œÅi,j,
i = 1, . . . , n, j = 1, . . . , n, i Ã∏= j,
where œÅij is the correlation coefÔ¨Åcient between the ith and jth elements of the
vector dZ.
Similarly the n-element random vector dW is drawn from a multivariate nor-
mal distribution with zero mean and covariance matrix C. We can thus write:
dW ‚àºN(0, C)
The diagonal elements of C are Cii = Var[dWi] = dt, i = 1, . . . , n, and off-
diagonal elements are
Cij = E[dWi dWj] = œÅi,j dt,
i = 1, . . . , n, j = 1, . . . , n, i Ã∏= j

14
Computational Finance Using C and C#
As in Section 2.3 we want to Ô¨Ånd the process followed by a function of the
stochastic vector X, that is the process followed by œÜ(X, t). This can be done by
applying an n-dimensional Taylor expansion, up to second order, in the variables
X and t as follows:
œÜ‚àó= œÜ + ‚àÇœÜ
‚àÇt dt +
n

i=1
‚àÇœÜ
‚àÇXi
dXi + 1
2E
 n

i=1
n

j=1
‚àÇ2œÜ
‚àÇXi ‚àÇXj
dXi dXj
	
+ 1
2
‚àÇ2œÜ
‚àÇt2 dt2 +
n

i=1
‚àÇœÜ
‚àÇXi ‚àÇt dXi dt
(2.5.3)
where œÜ‚àóis used to denote the value œÜ(X + dX, t + dt), and œÜ denotes the value
œÜ(X, t). We will now consider the magnitude of the terms dXi dXj, dXi dt, and
dt2 as dt ‚Üí0. Expanding the terms dXi dXj and dXi dt we have:
dXi dXj =

ai dt + bi
‚àö
dt dZi

aj dt + bj
‚àö
dt dZj

‚à¥dXi dXj = aiaj dt2 + aibj dt3/2 dZj + ajbi dt3/2 dZi
(2.5.4)
+ bibj dt dZi dZj
dXi dt = ai dt2 + bi dt3/2 dZi
So as dt ‚Üí0, and ignoring all terms in dt of order greater than 1, we have:
dXi dt ‚àº0
and
dXi dXj ‚àºbibj dt dZi dZj
Therefore Eq. (2.5.3) can be rewritten as
dœÜ = ‚àÇœÜ
‚àÇt dt +
n

i=1
‚àÇœÜ
‚àÇXi
dXi + 1
2E
 n

i=1
n

j=1
‚àÇ2œÜ
‚àÇXi ‚àÇXj
dXi dXj
	
(2.5.5)
where dœÜ = œÜ‚àó‚àíœÜ.
Now
E[dXi dXj] = E[bibj dt dZi dZj] = bibj dtE[dZi dZj] = bibjœÅij dt
where œÅij is the correlation coefÔ¨Åcient between the ith and jth assets.
Using these values in Eq. (2.5.5), and substituting for dXi from Eq. (2.5.1),
we obtain:
dœÜ =
n

i=1
‚àÇœÜ
‚àÇXi
(ai dt + bi dWi) + ‚àÇœÜ
‚àÇt dt + 1
2
n

i=1
n

j=1
bibjœÅij dt
‚àÇ2œÜ
‚àÇXi ‚àÇXj
(2.5.6)
This gives Ito‚Äôs n-dimensional formula:

Introduction to stochastic processes
15
dœÜ =

‚àÇœÜ
‚àÇt +
n

i=1
ai
‚àÇœÜ
‚àÇXi
+ 1
2
n

i=1
n

j=1
bibjœÅij
‚àÇ2œÜ
‚àÇXi ‚àÇXj

dt
+
n

i=1
‚àÇœÜ
‚àÇXi
bi dWi
(2.5.7)
In particular if we consider the geometric Brownian motion:
dSi = ŒºiSi dt + œÉiSi dWi,
i = 1, . . . , n,
where Œºi is the constant drift of the ith asset and œÉi is the constant volatility of
the ith asset, then substituting Xi = Si, ai = ŒºiSi, and bi = œÉiSi into Eq. (2.5.7)
yields:
dœÜ =

‚àÇœÜ
‚àÇt +
n

i=1
ŒºiSi
‚àÇœÜ
‚àÇSi
+ 1
2
n

i=1
n

j=1
œÉiœÉjSiSjœÅij
‚àÇ2œÜ
‚àÇSi ‚àÇSj

dt
+
n

i=1
‚àÇœÜ
‚àÇSi
œÉiSi dWi
(2.5.8)
2.6
Ito product and quotient rules in two dimensions
We will now derive expressions for the product and quotient of two stochastic
processes. In this case œÜ ‚ÜíœÜ(X1, X2), with
dX1 = a1 dt + b1 dW1
and
dX2 = a2 dt + b2 dW2
The following two-dimensional version of Ito‚Äôs lemma will be used:
dœÜ = ‚àÇœÜ
‚àÇX1
dX1 + ‚àÇœÜ
‚àÇX2
dX2 + 1
2E
 2

i=1
2

j=1
‚àÇ2œÜ
‚àÇXi ‚àÇXj
dXi dXj
	
(2.6.1)
where we have used the fact that ‚àÇœÜ
‚àÇt = 0.
2.6.1
Ito product rule
Here œÜ = œÜ(X1X2), and the partial derivatives are as follows:
‚àÇœÜ
‚àÇX1
= X2,
‚àÇœÜ
‚àÇX2
= X1
‚àÇ2œÜ
‚àÇX2
1
= ‚àÇ2œÜ
‚àÇX2
2
= 0,
‚àÇ2œÜ
‚àÇX1 ‚àÇX2
=
‚àÇ2œÜ
‚àÇX2 ‚àÇX1
= 1
Therefore using Eq. (2.6.1)
dœÜ = X2 dX1 + X1 dX2 + 2E[dX1 dX2]
2

16
Computational Finance Using C and C#
and the product rule is
d(X1X2) = X2 dX1 + X1 dX2 + E[dX1 dX2]
(2.6.2)
Brownian motion with one source of randomness
For the special case where X1 is Brownian motion and X2 has no random term
we have:
dX1 = X1Œº1 dt + X1œÉ1 dW1
and
dX2 = X2Œº2 dt
Now
E[dX1 dX2] = E

(X1Œº1 dt + X1œÉ1 dW1)X2Œº2 dt

= X1X2Œº1Œº2 dt2 + X1X2œÉ1Œº2 dtX2Œº2 dt E[dW1]
= 0
where we have ignored terms in dt with order higher than 1, and used
E[dW1] = 0.
Therefore Eq. (2.6.2) becomes:
d(X1X2) = X2 dX1 + X1 dX2
d(X1X2) = X2(X1Œº1 dt + X1œÉ1 dW1) + X1X2Œº2 dt
So we Ô¨Ånally obtain:
d(X1X2) = (X1X2){Œº1 + Œº2} dt + (X1X2)œÉ1 dW1
(2.6.3)
2.6.2
Ito quotient rule
Here œÜ = œÜ(X1/X2) and the partial derivatives are as follows:
‚àÇœÜ
‚àÇX1
= 1
X2
,
‚àÇœÜ
‚àÇX2
= ‚àíX1
X2
2
,
‚àÇ2œÜ
‚àÇX2
1
= 0,
‚àÇ2œÜ
‚àÇX2
2
= 2X1
X3
2
,
‚àÇ2œÜ
‚àÇX1 ‚àÇX2
=
‚àÇ2œÜ
‚àÇX2 ‚àÇX1
= ‚àí1
X2
2
Therefore using Eq. (2.6.1)
dœÜ = dX1
X2
‚àíX1
dX2
X2
2
+ 1
2E
2X1
X3
2
dX2
2 ‚àí2dX1 dX2
X2
2

We obtain the following expression for the quotient rule:
d
X1
X2

=
X1
X2
dX1
X1
‚àídX2
X2
+ E
dX2
X2
dX2
X2

‚àíE
dX1
X1
dX2
X2

(2.6.4)

Introduction to stochastic processes
17
Brownian motion
Here we have:
dX1 = X1Œº1 dt + X1œÉ1 dW1
and
dX2 = X2Œº2 dt + X2œÉ2 dW2
or equivalently
dX1
X1
= Œº1 dt + œÉ1 dW1
and
dX2
X2
= Œº2 dt + œÉ2 dW2
Therefore
E
dX2
X2
dX2
X2

= E

(Œº2 dt + œÉ2 dW2)(Œº2 dt + œÉ2 dW2)

= E

Œº2
2 dt2
+ E

œÉ 2
2 (dW2)2
+ 2E[œÉ2 dt dW2]
= Œº2
2 dt2 + œÉ 2
2 dt + 2œÉ2 dt E[dW2]
which results in
E
dX2
X2
dX2
X2

= œÉ 2
2 dt
(2.6.5)
where we have ignored all terms in dt with order higher than 1, and used the
fact that E[dW2] = 0.
In a similar manner
E
dX1
X1
dX2
X2

= E

(Œº1 dt + œÉ1 dW1)(Œº2 dt + œÉ2 dW2)

= E

Œº1Œº2 dt2
+ E[œÉ1Œº2 dt dW1]
+ E[œÉ2Œº1 dt dW2] + E[œÉ1œÉ2 dW1 dW2]
= Œº1Œº2 dt2 + œÉ1Œº2 dtE[dW1] + œÉ2Œº1 dtE[dW2]
+ œÉ1œÉ2E[dW1 dW2]
which gives
E
dX1
X1
dX2
X2

= œÉ1œÉ2 dt œÅ12
(2.6.6)
where we have proceeded as before but also used the fact that E[dW1 dW2] =
œÅ12 dt.
Substituting these into Eq. (2.6.4) we have:
d
X1
X2

=
X1
X2
dX1
X1
‚àídX2
X2
+ œÉ 2
2 dt ‚àíœÉ1œÉ2œÅ12 dt

=
X1
X2

Œº1 dt + œÉ1 dt ‚àíŒº2 dt ‚àíœÉ2 dt + œÉ 2
2 dt ‚àíœÉ1œÉ2œÅ12 dt

=
X1
X2

Œº1 dt + œÉ1 dW1 ‚àíŒº2 dt ‚àíœÉ2 dW2 + œÉ 2
2 dt ‚àíœÉ1œÉ2œÅ12 dt


18
Computational Finance Using C and C#
This yields:
d
X1
X2

=
X1
X2

Œº1 ‚àíŒº2 + œÉ 2
2 ‚àíœÉ1œÉ2œÅ12

dt
+
X1
X2

{œÉ1 dW1 ‚àíœÉ2 dW2}
(2.6.7)
Brownian motion with one source of randomness
We have
dX1 = X1Œº1 dt + X1œÉ1 dW1
and
dX2 = X2Œº2 dt
As before
E
dX2
X2
dX2
X2

= E

Œº2
2 dt2
= Œº2
2 dt2 ‚Üí0
E
dX1
X1
dX2
X2

= E

(Œº1 dt + œÉ1 dW1)Œº2 dt

= E

Œº1Œº2 dt2 + œÉ1Œº2 dt dW1

= Œº1Œº2 dt2 + œÉ1Œº2 dt E[dW1] ‚Üí0
Therefore
d
X1
X2

=
X1
X2
dX1
X1
‚àídX2
X2

=
X1
X2

{Œº1 dt + œÉ1 dW1 ‚àíŒº2 dt}
So the Ô¨Ånal expression is
d
X1
X2

=
X1
X2

{Œº1 ‚àíŒº2} dt +
X1
X2

œÉ1 dW1
(2.6.8)
2.7
Ito product in n dimensions
Using Eq. (2.5.7) we will now derive an expression for the product of n sto-
chastic processes. In this case œÜ ‚Üín
i=1 Xi, and the partial derivatives are as
follows:
‚àÇœÜ
‚àÇXi
= œÜ dXi
Xi
for i = 1, . . . , n
‚àÇ2œÜ
‚àÇX2
i
= 0
for i = 1, . . . , n

Introduction to stochastic processes
19
‚àÇ2œÜ
‚àÇXi ‚àÇXj
=
‚àÇ2œÜ
‚àÇXj ‚àÇXi
=
dXi
Xi
dXj
Xj

œÜ
for i Ã∏= j, i = 1, . . . , n, j = 1, . . . , n
‚àÇœÜ
‚àÇt = 0
So substituting into Eq. (2.5.7) we have
dœÜ = œÜ
n

i=1
dXi
Xi

+ œÜE
 n

i=1
n

j=1(iÃ∏=j)
dXi
Xi
dXj
Xj
	
(2.7.1)
which in full is
d
 n

i=1
Xi

=
 n

i=1
Xi

n

i=1
dXi
Xi

+
 n

i=1
Xi

E
 n

i=1
n

j=1(iÃ∏=j)
dXi
Xi
dXj
Xj
	
(2.7.2)
2.8
The Brownian bridge
Let a Brownian process have values Wt0 at time t0 and Wt1 at time t1. We want
to Ô¨Ånd the conditional distribution of Wt, where t0 < t < t1. This distribution
will be denoted by P(Wt|{Wt0, Wt1}), to indicate that Wt is conditional on the
end values Wt0 and Wt1. We now write Wt0 and Wt1 as
Wt = Wt0 + ‚àöt ‚àít0Xt,
Xt ‚àºN(0, 1),
(2.8.1)
Wt1 = Wt + ‚àöt1 ‚àítYt,
Yt ‚àºN(0, 1),
(2.8.2)
where Xt and Yt are independent normal variates.
Combining Eqs. (2.8.1) and (2.8.2) we have
Wt1 = Wt0 + ‚àöt ‚àít0Xt + ‚àöt1 ‚àítYt
which can be re-expressed as
Wt1 ‚àíWt0 = ‚àöt ‚àít0Xt + ‚àöt1 ‚àítYt
Using the Brownian motion property (iii) in Section 2.1
Wt1 ‚àíWt0 = ‚àöt1 ‚àít0Zt,
Zt ‚àºN(0, 1)
So
‚àöt1 ‚àít0Zt = ‚àöt ‚àít0Xt + ‚àöt1 ‚àítYt

20
Computational Finance Using C and C#
and
Y(Xt, Zt) =
‚àöt1 ‚àít0Zt ‚àí‚àöt ‚àít0Xt
‚àöt1 ‚àít
(2.8.3)
Now P(Wt|{Wt0, Wt1}) = P(Xt|Zt), the probability distribution of Xt condi-
tional on Zt. From Bayes law
P(Xt|Zt) = P(Xt)P(Y(Xt, Zt))
P(Zt)
=
1
‚àö
2œÄ
exp

‚àíX2
t + Y 2
t ‚àíZ2
t
2

(2.8.4)
Since Xt, Yt and Zt are Gaussians we can write
P(Xt|Zt) =
1
‚àö
2œÄ
exp

‚àíX2
t + Y 2
t ‚àíZ2
t
2

(2.8.5)
First let us compute Y 2
t .
Y 2
t =
‚àöt1 ‚àít0Zt ‚àí‚àöt ‚àít0Xt
‚àöt1 ‚àít
2
so
Y 2
t = (t1 ‚àít0)Z2
t + (t ‚àít0)X2
t ‚àí2‚àöt1 ‚àít0
‚àöt ‚àít0XtZt
t1 ‚àít
(2.8.6)
Next we compute X2
t + Y 2
t ‚àíZ2
t as follows
X2
t + Y 2
t ‚àíZ2
t
= (t1 ‚àít0)X2
t + (t ‚àít0)Z2
t ‚àí2‚àöt1 ‚àít0
‚àöt ‚àít0XtZt
t1 ‚àít
(2.8.7)
Dividing top and bottom of Eq. (2.8.7) by t1 ‚àít0 we obtain:
X2
t + Y 2
t ‚àíZ2
t
= X2
t + ((t ‚àít0)/(t1 ‚àít0))Z2
t ‚àí2‚àöt1 ‚àít0
‚àöt ‚àít0/(t1 ‚àít0)XtZt
(t1 ‚àít)/(t1 ‚àít0)
= X2
t + ((t ‚àít0)/(t1 ‚àít0))Z2
t ‚àí2‚àö(t ‚àít0)/(t1 ‚àít0)XtZt
(t1 ‚àít)/(t1 ‚àít0)
which gives
X2
t + Y 2
t ‚àíZ2
t = (Xt ‚àí‚àö(t ‚àít0)/(t1 ‚àít0)Zt)2
(t1 ‚àít)/(t1 ‚àít0)
(2.8.8)
where we have used

Xt ‚àí
 t ‚àít0
t1 ‚àít0
Zt
2
= X2
t + t ‚àít0
t1 ‚àít0
Z2
t ‚àí2
 t ‚àít0
t1 ‚àít0
XtZt
Substituting Eq. (2.8.8) into Eq. (2.8.5) yields
P(Xt|Zt) =
1
‚àö
2œÄ
exp

‚àí(Xt ‚àí‚àö(t ‚àít0)/(t1 ‚àít0)Zt)2
2(t1 ‚àít)/(t1 ‚àít0)


Introduction to stochastic processes
21
Therefore P(Xt|Zt) is a Gaussian distribution with:
E[Xt] =
 t ‚àít0
t1 ‚àít0
Zt
and
Var[Xt] = t1 ‚àít
t1 ‚àít0
Substituting for Zt we have
E[Xt] =
 t ‚àít0
t1 ‚àít0
Zt =
 t ‚àít0
t1 ‚àít0
Wt1 ‚àíWt0
‚àöt1 ‚àít0
which gives:
E[Xt] =
‚àöt ‚àít0
t1 ‚àít0
(Wt1 ‚àíWt0)
(2.8.9)
The variate 
Xt = E[Xt] + ‚àöVar[Xt]Zt has the same distribution as P(Xt|Zt).
So we can substitute 
Xt for Xt in Eq. (2.8.1) to obtain:
Wt = Wt0 + ‚àöt ‚àít0

E[Xt] +

Var[Xt]Zt

which gives:
Wt = Wt0 + ‚àöt ‚àít0
‚àöt ‚àít0
t1 ‚àít0
(Wt1 ‚àíWt0) +
 t1 ‚àít
t1 ‚àít0
Zt

and simplifying we obtain:
Wt = Wt0
t1 ‚àít0
t1 ‚àít0
+ t ‚àít0
t1 ‚àít0
(Wt1 ‚àíWt0) +

(t1 ‚àít)(t ‚àít0)
t1 ‚àít0
Zt
(2.8.10)
Variates, Wt, from the distribution of P(Wt|{Wt0, Wt1}) can therefore be gener-
ated by using
Wt = Wt0
t1 ‚àít
t1 ‚àít0
+ Wt1
t ‚àít0
t1 ‚àít0
+

(t1 ‚àít)(t ‚àít0)
t1 ‚àít0
Zt
(2.8.11)
An alternative derivation of the Brownian bridge is given in Appendix G.
2.9
Time-transformed Brownian motion
Let us consider the Brownian motion:
dWt = œÉ
‚àö
dt dZt
(2.9.1)
and also the scaled and time-transformed Brownian motion
YW,t = atWft
(2.9.2)
where the scale factor, at, is a real function and the time transformation, ft, is a
continuous increasing function satisfying ft ‚©æ0; see Cox and Miller (1965).

22
Computational Finance Using C and C#
Using Ito‚Äôs lemma,
dYW,t = ‚àÇYt
‚àÇt dt + ‚àÇYt
‚àÇWt
dWt
(2.9.3)
where we have used the fact that ‚àÇ2Yt
‚àÇW 2t = 0.
From Eq. (2.9.3)
dYW,t =
‚àÇat
‚àÇt

Wft dt + at dWft
(2.9.4)
Now
dWft =

dft dZt =

‚àÇft
‚àÇt dt dZt
(2.9.5)
so we can write:
dYW,t = a‚Ä≤
tWft dt + at

f ‚Ä≤t dt dZt
(2.9.6)
where
a‚Ä≤
t = ‚àÇat
‚àÇt
and
f ‚Ä≤
t = ‚àÇft
‚àÇt
2.9.1
Scaled Brownian motion
We will prove that 
Wt deÔ¨Åned by

Wt = 1
c Wc2t,
c > 0,
is Brownian motion.
Let us consider the process
Yt = Wc2t
From Eq. (2.9.2) we have at = 1, ft = c2t, a‚Ä≤
t = 0 and f ‚Ä≤
t = c2. Substituting
these values into Eq. (2.9.6), yields
dYt =

c2dt dZt
which gives
dYt = c
‚àö
dt dZt = c dWt
Therefore 
Wt = dYt/c is Brownian motion.
2.9.2
The Ornstein‚ÄìUhlenbeck process
We will now show that the Ornstein‚ÄìUhlenbeck process (see Section 2.10) can
be represented as follows:
YW,t = exp(‚àíŒ±t)Wœàt
where œàt = œÉ 2 exp(2Œ±t)
2Œ±
, Œ± > 0
(2.9.7)

Introduction to stochastic processes
23
Proof. From Eqs. (2.9.2) and (2.9.7) we have:
ft = œÉ 2 exp(œÉ 2 exp(2Œ±t))
2Œ±
and
at = exp(‚àí2Œ±t)
(2.9.8)
Therefore
a‚Ä≤
t
at
= ‚àí‚àíŒ± exp(‚àíŒ±t)
exp(‚àíŒ±t)
= ‚àíŒ±
(2.9.9)
and
f ‚Ä≤
t = œÉ 2
2Œ± 2Œ± exp(2Œ±t) = œÉ 2 exp(2Œ±t)
(2.9.10)
So

f ‚Ä≤t dt =

œÉ 2 exp(2Œ±t) = œÉ exp(Œ±t)
‚àö
dt
(2.9.11)
Thus
dYW,t = ‚àíŒ±YW,t dt + exp(‚àíŒ±t)œÉ exp(Œ±t)
‚àö
dt dZ
(2.9.12)
which means that
dYW,t = ‚àíŒ±YW,t dt + œÉ dWt
(2.9.13)
From Eq. (2.9.13) it can be seen that conditional mean and variance are
E[dYW,t|Ft] = Œ±YW,t dt
(2.9.14)
Var[dYW,t|Ft] = œÉ 2 dt
(2.9.15)
‚ñ°
Unconditional mean
The unconditional mean is
E[YW,t] = E

exp(‚àíŒ±t)W
œÉ 2 exp(2Œ±t)
2Œ±

where Œ± > 0 and t ‚Üí‚àû
(2.9.16)
So
E[YW,t] = 0
(2.9.17)
Unconditional variance and covariance
Let
YW,t = exp(‚àíŒ±t)Wœàt
where œàt =
œÉ 2 exp(2Œ±t)
2Œ±

(2.9.18)

24
Computational Finance Using C and C#
and
YW,s = exp(‚àíŒ±s)Wœàs
where œàs =
œÉ 2 exp(2Œ±s)
2Œ±

(2.9.19)
The covariance is:
Cov[YW,s, YW,t] = E[YW,tYW,s] ‚àíE[YW,t]E[YW,s]
= E[YW,tYW,s]
(2.9.20)
since E[YW,s] = E[YW,t] = 0.
Shortening the notation of YW,t to Yt we obtain
Cov[Ys, Yt] = E

exp(‚àíŒ±t)Wœàt exp(‚àíŒ±t)Wœàs

= exp

‚àíŒ±(t + s)

E

{Wœàt Wœàs}

From Eq. (2.1.2)
E[Ws, Wt] = s ‚àßt
(2.9.21)
Therefore, if s ‚©Ωt
E[Wœàt Wœàs] = Wœàs
(2.9.22)
and
Cov[Ys, Yt] = exp(‚àíŒ±(t + s))œÉ 2 exp(2Œ±s)
2Œ±
= œÉ 2
2Œ± exp

‚àíŒ±(t ‚àís)

(2.9.23)
The unconditional variance (obtained by setting s = t) is
Var[Yt] = œÉ 2
2Œ±
(2.9.24)
2.10
Ornstein‚ÄìUhlenbeck process
The Ornstein‚ÄìUhlenbeck process is often used to model interest rates because
of its mean reverting property. It is deÔ¨Åned by the equation
dXt = ‚àíŒ±Xt dt + œÉ dWt
(2.10.1)
Using the integrating factor exp(Œ±t) we have:
exp(Œ±t) dXt = ‚àíŒ±Xt exp(Œ±t) dt + œÉ exp(Œ±t) dWt
so
exp(Œ±t) dXt + Œ±Xt exp(Œ±t) dt = œÉ exp(Œ±t) dWt
(2.10.2)
Using the Ito product rule we have:
d

Xt exp(Œ±t)

= exp(Œ±t) dXt + Œ±Xt exp(Œ±t) dt
(2.10.3)

Introduction to stochastic processes
25
So from Eqs. (2.10.2) and (2.10.3) we obtain
d

Xt exp(Œ±t)

= œÉ exp(Œ±t) dWt
(2.10.4)
Integrating Eq. (2.10.4) gives
 s=t
s=0
d

Xs exp(Œ±s)

= œÉ
 s=t
s=0
exp(Œ±s) dWs
which yields
Xt exp(Œ±t) ‚àíXt0 = œÉ
 s=t
s=0
exp(Œ±s) dWs
and thus the solution of Eq. (2.10.1) is
Xt = Xt0 exp(‚àíŒ±t) + œÉ exp(‚àíŒ±t)
 s=t
s=0
exp(Œ±s) dWs
(2.10.5)
We will now derive expressions for both the unconditional mean and the un-
conditional variance of Xt.
The mean
Taking expectations of both sides of Eq. (2.10.5) yields
E[Xt] = E

Xt0 exp(‚àíŒ±t)

+ E

œÉ exp(‚àíŒ±t)
 s=t
s=0
exp(Œ±s) dWs

(2.10.6)
since
E

œÉ exp(‚àíŒ±t)
 s=t
s=0
exp(Œ±s) dWs

= œÉ exp(‚àíŒ±t)E
 s=t
s=0
exp(Œ±s) dWs

= 0
the unconditional mean is
E[Xt] = Xt0 exp(‚àíŒ±t)
(2.10.7)
The variance
To derive the expression for unconditional variance requires a bit more effort.
We have
Var[Xt] = E

Xt ‚àíE[Xt]
2
(2.10.8)
= E

Xt ‚àíXt0 exp(‚àíŒ±t)
2
However, from Eq. (2.10.5)
Xt ‚àíXt0 exp(‚àíŒ±t) = œÉ exp(‚àíŒ±t)
 s=t
s=0
exp(Œ±s) dWs

26
Computational Finance Using C and C#
So substituting the above expression into Eq. (2.10.8)
Var[Xt] = E

exp(‚àíŒ±t)œÉ
 s=t
s=0
exp(Œ±s) dWs
2
(2.10.9)
Var[Xt] = œÉ 2 exp(‚àí2Œ±t)E
 s=t
s=0
exp(Œ±s) dWs
2
(2.10.10)
Using Ito‚Äôs isometry (see Section 2.12.2)
E
 s=t
s=0
exp(Œ±s) dWs
2
= E
 s=t
s=0

exp(Œ±s)
2 ds

Then using Fubini‚Äôs theorem (see Section 2.12.1)
E
 s=t
s=0

exp(Œ±s)
2 ds

=
 s=t
s=0
E

exp(Œ±s)
2
ds
=
 s=t
s=0
exp(2Œ±s) ds
= exp(2Œ±s)
2Œ±
s=t
s=0
= exp(2Œ±t) ‚àí1
2Œ±
Substituting the above result into Eq. (2.10.10)
Var[Xt] = œÉ 2 exp(‚àí2Œ±t)
exp(2Œ±t) ‚àí1
2Œ±

which yields the following expression for the variance
Var[Xt] = œÉ 2
1 ‚àíexp(‚àí2Œ±t)
2Œ±

(2.10.11)
The expressions for the mean and variance derived in Eqs. (2.10.7) and
(2.10.11) allow us to write the distribution of Xt as
Xt ‚àºN

Xt0 exp(‚àíŒ±t), œÉ 2
1 ‚àíexp(‚àí2Œ±t)
2Œ±

(2.10.12)
which, if Xt0 = 0, reduces to
Xt ‚àºN

0, œÉ 2
1 ‚àíexp(‚àí2Œ±t)
2Œ±

(2.10.13)
The transition density from Xt0 to Xt is:
P(Xt|Xt0) =

K
2œÄ(1 ‚àíŒ≥ 2) exp

‚àíK(Xt ‚àíXt0 exp(‚àíŒ±(t ‚àít0)))2
1 ‚àíŒ≥ 2

(2.10.14)
where K = 2Œ±/œÉ 2 and Œ≥ = exp(‚àíŒ±(t ‚àít0)).

Introduction to stochastic processes
27
Ornstein‚ÄìUhlenbeck stochastic paths can thus be simulated using
Xt+dt = Xt exp(‚àíŒ± dt) + œÉ

1 ‚àíexp(‚àí2Œ± dt)
2Œ±
dZ
(2.10.15)
From Eq. (2.10.14) we can write
E[Xt+dt|Xt] = Xt exp(‚àíŒ± dt)
Var[Xt+dt|Xt] = œÉ 2
1 ‚àíexp(‚àí2Œ± dt)
2Œ±

We will now show that in the limit dt ‚Üí0, Eq. (2.10.15) reduces to the
Ornstein‚ÄìUhlenbeck process given in Eq. (2.10.1).
For small dt we can take a Ô¨Årst-order expansion of the exponentials in
Eq. (2.10.15) to obtain
Xt+dt = Xt

(1 ‚àíŒ± dt)

+ œÉ

(1 ‚àí(1 ‚àí2Œ± dt))
2Œ±
dZ
so
Xt+dt = Xt ‚àíXtŒ± dt + œÉ

2Œ± dt
2Œ±
dZ
Therefore
Xt+dt ‚àíXt = ‚àíŒ±Xt dt + œÉ
‚àö
dt dZ
which is
dXt = ‚àíŒ±Xt dt + œÉ dWt
2.11
The Ornstein‚ÄìUhlenbeck bridge
Let an Ornstein‚ÄìUhlenbeck process have value Xt0 at time t0 and Xt1 at time t1.
We are interested in the distribution of Xt at an intermediate point, that is
P(Xt|{Xt0, Xt1}), where t0 < t < t1.
We will show that Xt is a Gaussian with conditional mean
Œºt = Xt0 exp

‚àíŒ±(t ‚àít0)
1 ‚àíexp(‚àí2Œ±(t1 ‚àít))
1 ‚àíŒ≥ 2

+ Xt1 exp

‚àíŒ±(t1 ‚àít)
1 ‚àíexp(‚àí2Œ±(t ‚àít0))
1 ‚àíŒ≥ 2

(2.11.1)
and conditional variance
Vt = (1 ‚àíexp(‚àí2Œ±(t ‚àít0)))(1 ‚àíexp(‚àí2Œ±(t1 ‚àít)))
2Œ±(1 ‚àíexp(‚àí2Œ±(t1 ‚àít0)))
(2.11.2)
where Œ≥ = exp(‚àíŒ±(t1 ‚àít0)).

28
Computational Finance Using C and C#
Proof. The standard Ornstein‚ÄìUhlenbeck process (œÉ = 1) is deÔ¨Åned by the
process:
dXt = ‚àíŒ±Xt dt +
‚àö
dt dZt
(2.11.3)
From Section 2.10 we have that
Xt = Xt0 exp

‚àíŒ±(t ‚àít0)

+
1 ‚àíexp(‚àí2Œ±(t ‚àít0))
2Œ±

dZt
(2.11.4)
and that the transition density from Xt0 to Xt is
P(Xt|Xt0) =
‚àö
2Œ±

2œÄ(1 ‚àíexp(‚àí2Œ±(t ‚àít0)))
√ó exp

‚àíŒ±(Xt ‚àíXt0 exp(‚àíŒ±(t ‚àít0)))2
1 ‚àíexp(‚àí2Œ±(t ‚àít0))

(2.11.5)
The joint density of Xt and Xt1 given Xt0 is:
P

{Xt, Xt1}|Xt0

= P(Xt1|Xt)P(Xt|Xt0)
(2.11.6)
We thus have:
P

{Xt, Xt1}|Xt0

= Œ∫ exp

‚àíŒ±(Xt ‚àíXt0 exp(‚àíŒ±(t ‚àít0)))2
(1 ‚àíexp(‚àí2Œ±(t ‚àít0)))

√ó exp

‚àíŒ±(Xt1 ‚àíXt exp(‚àíŒ±(t1 ‚àít)))2
1 ‚àíexp(‚àí2Œ±(t1 ‚àít))

where
Œ∫ = 1
2œÄ
2Œ±

(1 ‚àíexp(‚àí2Œ±(t ‚àít0)))(1 ‚àíexp(‚àí2Œ±(t1 ‚àít)))
The distribution of Xt given Xt0 and Xt1, P(Xt|Xt0, Xt1) is:
P

Xt|{Xt0, Xt1}

= P({Xt, Xt1}|Xt0)
P(Xt1|Xt0)
(2.11.7)
where
P(Xt1|Xt0) =
‚àö
2Œ±

2œÄ(1 ‚àíexp(‚àí2Œ±(t1 ‚àít0)))
√ó exp

‚àíŒ±(Xt1 ‚àíXt0 exp(‚àíŒ±(t1 ‚àít0)))2
1 ‚àíexp(‚àí2Œ±(t1 ‚àít0))

(2.11.8)
After some algebra we can re-express Eq. (2.11.7) as
P

Xt|{Xt0, Xt1}

=
 Œ±
œÄœÜt
exp{A}
(2.11.9)

Introduction to stochastic processes
29
where
A = ‚àíŒ±
œÜ (B1 + B2 ‚àíB3)
B1 =

X2
t + X2
t0 exp

‚àí2Œ±(t ‚àít0)

‚àí2XtXt0 exp

‚àíŒ±(t ‚àít0)

√ó
1 ‚àíexp(‚àí2Œ±(t1 ‚àít))
1 ‚àíŒ≥ 2

(2.11.10)
B2 =

X2
t1 + X2
t exp

‚àí2Œ±(t1 ‚àít)

‚àí2XtXt1 exp

‚àíŒ±(t1 ‚àít)

√ó
1 ‚àíexp(‚àí2Œ±(t ‚àít0))
1 ‚àíŒ≥ 2

(2.11.11)
B3 =

X2
t1 + X2
t0 exp

‚àí2Œ±(t1 ‚àít0)

‚àí2Xt1Xt0 exp

‚àíŒ±(t1 ‚àít0)

√ó

1 ‚àíexp

‚àí2Œ±(t ‚àít0)
1 ‚àíexp(‚àí2Œ±(t1 ‚àít))
(1 ‚àíŒ≥ 2)2

(2.11.12)
œÜt = (1 ‚àíexp(‚àí2Œ±(t ‚àít0)))(1 ‚àíexp(‚àí2Œ±(t1 ‚àít)))
1 ‚àíexp(‚àí2Œ±(t1 ‚àít0))
and
Œ≥ = exp

‚àíŒ±(t1 ‚àít0)

Let us now assume that P(Xt|{Xt0, Xt1}) is a normal distribution with condi-
tional mean Œºt and conditional variance Vt. We thus have:
P

Xt|{Xt0, Xt1}

=
1
‚àö2œÄVt
exp

‚àí(Xt ‚àíŒºt)2
2Vt

(2.11.13)
Equating Eqs. (2.11.7) and (2.11.13)
‚àí1
2Vt

(Xt ‚àíŒºt)2
= ‚àí1
2Vt

X2
t ‚àíŒº2
t ‚àí2XtŒºt

= ‚àíŒ±
œÜ (B1 + B2 ‚àíB3)
(2.11.14)
The conditional variance Vt can be obtained by noting that:
1
2Vt
= Œ±
œÜt
and hence:
Vt = œÜ
2Œ±
(2.11.15)
so substituting for œÜ in Eq. (2.11.15) we obtain the following expression for the
conditional variance:
Vt = (1 ‚àíexp(‚àí2Œ±(t ‚àít0)))(1 ‚àíexp(‚àí2Œ±(t1 ‚àít)))
1 ‚àíexp(‚àí2Œ±(t1 ‚àít0))
= œÜt
2Œ±

30
Computational Finance Using C and C#
The conditional mean can be obtained by noting that Xt0 and Xt1 are constants
and the coefÔ¨Åcients of Xt and X2
t in Eq. (2.11.14) must be the same. Comparing
coefÔ¨Åcients of Xt we thus have:
‚àí2Œºt = ‚àí2Xt0 exp

‚àíŒ±(t ‚àít0)
1 ‚àíexp(‚àí2Œ±(t1 ‚àít))
1 ‚àíŒ≥ 2

‚àí2Xt1 exp

‚àíŒ±(t1 ‚àít)
1 ‚àíexp(‚àí2Œ±(t ‚àít0))
1 ‚àíŒ≥ 2

So the conditional mean Œºt is:
Œºt = Xt0 exp

‚àíŒ±(t ‚àít0)
1 ‚àíexp(‚àí2Œ±(t1 ‚àít))
1 ‚àíŒ≥ 2

+ Xt1 exp

‚àíŒ±(t1 ‚àít)
1 ‚àíexp(‚àí2Œ±(t ‚àít0))
1 ‚àíŒ≥ 2

This completes the proof.
‚ñ°
Relation to the Brownian bridge
We will now prove that in the limit (t1 ‚àít0) ‚Üí0 the Brownian bridge result is
obtained.
For the conditional mean, we have:
Œº = Xt0 exp

‚àíŒ±(t ‚àít0)
1 ‚àíexp(‚àí2Œ±(t1 ‚àít))
1 ‚àíŒ≥ 2

+ Xt1 exp

‚àíŒ±(t1 ‚àít)
1 ‚àíexp(‚àí2Œ±(t ‚àít0))
1 ‚àíŒ≥ 2

where:
Œ≥ = exp

‚àíŒ±(t1 ‚àít0)

which is:
Œº = Xt0
exp(‚àíŒ±(t ‚àít0)) ‚àíexp(‚àí2Œ±(t1 ‚àít))
1 ‚àíexp(‚àí2Œ±(t1 ‚àít0) ‚àíŒ±(t ‚àít0))

+ Xt1
exp(‚àíŒ±(t1 ‚àít)) ‚àíexp(‚àí2Œ±(t ‚àít0) ‚àíŒ±(t1 ‚àít))
1 ‚àíexp(‚àí2Œ±(t1 ‚àít0))

For small t1 ‚àít0 both t1 ‚àít and t ‚àít0 are small, so:
Œº ‚ÜíXt0
1 ‚àíŒ±(t ‚àít0) ‚àí{1 ‚àí2Œ±(t1 ‚àít) ‚àíŒ±(t ‚àít0)}
1 ‚àí{1 ‚àí2Œ±(t1 ‚àít0)}

+ Xt1
1 ‚àíŒ±(t1 ‚àít) ‚àí{1 ‚àí2Œ±(t ‚àít0) ‚àíŒ±(t1 ‚àít)}
1 ‚àí{1 ‚àí2Œ±(t1 ‚àít0)}

which yields the Brownian bridge result for the conditional mean:
Œº ‚ÜíXt0
t1 ‚àít0
t1 ‚àít0
+ Xt1
t ‚àít0
t1 ‚àít0

Introduction to stochastic processes
31
For the conditional variance:
Vt = (1 ‚àíexp(‚àí2Œ±(t ‚àít0)))(1 ‚àíexp(‚àí2Œ±(t1 ‚àít)))
2Œ±(1 ‚àíexp(‚àí2Œ±(t1 ‚àít0)))
For small t1 ‚àít0 both t1 ‚àít and t ‚àít0 are small, so we can write:
V ‚Üí(1 ‚àí{1 ‚àí2Œ±(t ‚àít0)})(1 ‚àí{1 ‚àí2Œ±(t1 ‚àít)})
2Œ±(1 ‚àí{1 ‚àí2Œ±(t1 ‚àít0)})
which yields the Brownian bridge result for the conditional variance:
Vt ‚Üí(t ‚àít0)(t1 ‚àít)
t1 ‚àít0
2.12
Other useful results
2.12.1
Fubini‚Äôs theorem
Fubini‚Äôs theorem states that (for well-behaved functions) the value of a multidi-
mensional integral is independent of the order in which the integral is evaluated.
For example, the two-dimensional integral of the function f (X, Y) can be
evaluated as:
 b
X=a
 d
Y=c
f (X, Y) dX dY =
 d
Y=c
 b
X=a
f (X, Y) dX

dY
=
 b
X=a
 d
Y=c
f (X, Y) dY

dX
We will mainly use this result in the form:
E
 t
s=0
f (W, s) ds

=
 t
s=0
E

f (W, s)

ds
(2.12.1)
Since
E

f (W, s)

=
 ‚àû
‚àí‚àû
P(W, s)f (W, s) dW
where P(W, s) is the probability density function of f (W, s), we can thus write
Eq. (2.12.1) in full as:
 ‚àû
W=‚àí‚àû
 t
s=0
P(W, s)f (W, s) ds

dW
=
 t
s=0
 ‚àû
W=‚àí‚àû
P(W, s)f (W, s) dW

ds

32
Computational Finance Using C and C#
2.12.2
Ito‚Äôs isometry
The expected value of the integral of the well-behaved function f (Wt, t) satisÔ¨Åes:
E
 tb
s=ta
f (Ws, s) dWs
2
= E
 tb
s=ta

f (Ws, s)
2 ds

(2.12.2)
Proof. We Ô¨Årst use the following approximation:
 s=tb
s=ta
f (W, s) dWs =
n‚àí1

i=0
f (Wti, ti){Wti+1 ‚àíWti}
where a < t0 < t1 < ¬∑ ¬∑ ¬∑ < tn < tb and ti+1 ‚àíti = dt. Thus the integral on the
left-hand side of Eq. (2.12.2) is:
 tb
s=ta
f (Ws, s) dWs
2
=
n‚àí1

i=0
n‚àí1

j=0
f (Wti, ti)f (Wtj , tj){Wti+1 ‚àíWti}{Wtj+1 ‚àíWtj }
(2.12.3)
Taking expectations of Eq. (2.12.3) we obtain:
E
 tb
s=ta
f (Ws, s) dWs
2
= E
n‚àí1

i=0
n‚àí1

j=0
f (Wti, ti)f (Wtj , tj){Wti+1 ‚àíWti}{Wtj+1 ‚àíWtj }
	
(2.12.4)
which means that:
E
 tb
s=ta
f (Ws, s) dWs
2
=
n‚àí1

i=0
n‚àí1

j=0
f (Wti, ti)f (Wtj , tj)E

{Wti+1 ‚àíWti}{Wtj+1 ‚àíWtj }

(2.12.5)
However from the Brownian motion property (iii) in Section 2.1 we have:
E

{Wti+1 ‚àíWti}{Wtj+1 ‚àíWtj }

= 0
when i Ã∏= j and dt when i = j
Therefore Eq. (2.12.5) can be rewritten as:
E
 tb
s=ta
f (Ws, s) dWs
2
=
n‚àí1

i=0

f (Wti, ti)
2 dt
which means:
E
 tb
s=ta
f (Ws, s) dWs
2
= E
 tb
s=ta

f (Ws, s)
2 ds

‚ñ°

Introduction to stochastic processes
33
2.12.3
Expectation of a stochastic integral
If f (t) is a deterministic function of time then
E
 s=b
s=a
f (s) dWs

= 0
(2.12.6)
Proof. We Ô¨Årst express the integral (2.12.6) by the following summation:
 s=tb
s=ta
f (s) dWs =
n‚àí1

i=0
f (ti){Wti+1 ‚àíWti},
where a < t0 < t1 < ¬∑ ¬∑ ¬∑ < tn < tb
Taking expectations of the above equation yields:
E
 s=b
s=a
f (s) dWs

= E
n‚àí1

i=0
f (ti){Wti+1 ‚àíWti}
	
=
n‚àí1

i=0
f (ti)E[Wti+1 ‚àíWti]
= 0
where we have used E[Wti+1 ‚àíWti] = 0, which is Brownian motion property (iii)
in Section 2.1.
‚ñ°
2.13
Selected problems
In this section we provide various problems that test the reader‚Äôs understanding
of stochastic calculus. The answers are given in the appendix at the end of the
book.
Problem 1 (Problem 4.5, √òksendal (2003)). Let Œ≤k
t = E[W k
t ], k = 0, 1, 2, . . . ,
t ‚©æ0, where Wt0 = 0.
(a) Show using Ito‚Äôs formula for k = 2, 3, 4, . . . , that:
Œ≤k
t = 1
2(k ‚àí1)
 t
s=0
Œ≤k‚àí2
s
ds
(b) Deduce that E[W 4
t ] = 3t2
(c) What is E[W 6
t ]?
Problem 2 (Problem 5.4(ii), √òksendal (2003)). Solve the stochastic differential
equation:
dXt = Xt dt + dWt

34
Computational Finance Using C and C#
Problem 3 (Problem 5.4(iii), √òksendal (2003)). Solve the stochastic differen-
tial equation:
dXt = ‚àíXt dt + exp(‚àít) dWt
Problem 4 (Problem 4.2, √òksendal (2003)). Use Ito‚Äôs formula to prove that

s=0
W 2
s dWs = 1
3W 3
t ‚àí
 t
s=0
Ws ds
where Wt0 = 0.
Problem 5 (Problem 5.6, √òksendal (2003)). Solve:
dYt = r dt + Œ±Yt dWt
where r and Œ± are real constants. Use the integrating factor Ft = exp(‚àíŒ±Wt +
(Œ±2/2)t).
Problem 6 (Problem 5.7, √òksendal (2003)). The mean reverting Ornstein‚Äì
Uhlenbeck process is the solution Xt of the stochastic differential equation:
dXt = (m ‚àíXt) dt + œÉ dWt
where m and œÉ are constants.
(a) Solve this equation
(b) Find E[Xt] and Var[Xt] = E[{Xt ‚àíE[Xt]}2].
Problem 7. Consider the equation dSt = ŒºtSt dt +œÉtSt dWt where the value of
St at time t = 0 is denoted by S0.
(a) Show that the mean is:
E

log(St)

= log(S0) +
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ
(b) Show that the variance is:
Var

log(St)

=
 t
œÑ=0
œÉ 2
œÑ dœÑ
Problem 8. Prove that if œÜ = exp(tWt) then
dœÜ = œÜ

Wt + t2
2

dt + tœÜ dWt
Problem 9 (Problem 4.4, √òksendal (2003)). DeÔ¨Åne:
Zt = exp
 t
s=0
Œ∏s dWs ‚àí1
2
 t
s=0
Œ∏2
s ds

Use Ito‚Äôs formula to prove that
dZt = ZtŒ∏t dWt

Introduction to stochastic processes
35
Problem 10. Let St = S0 exp(Œºt + œÉWt) where Œº and œÉ are constants.
(a) Show by Ito‚Äôs lemma that:
dSt =

Œº + œÉ 2
2

St dt + œÉSt dWt
(b) Show that:
E[St] ‚àíE[S0] =

Œº + œÉ 2
2
  t
œÑ=0
E

S(œÑ)

dœÑ
(c) Show that:
E[St] = S0 exp

Œºt + œÉ 2
2 t

Problem 11 (Problem 4.3, √òksendal (2003)). Let Xt, Yt be stochastic processes.
Prove that:
d(XtYt) = Xt dYt + Yt dXt + E[dXt dYt]
Deduce the following general integration by parts formula:
 t
s=0
Xs dYs = XtYt ‚àíXt0Yt0 ‚àí
 t
s=0
Ys dXs ‚àí
 t
s=0
E[dXs dYs]

blank
left
intentionally
page
This

3 Generation of random variates
3.1
Introduction
Monte Carlo simulation and random number generation are techniques that
are widely used in Ô¨Ånancial engineering as a means of assessing the level of
exposure to risk. Typical applications include the pricing of Ô¨Ånancial derivatives
and scenario generation in portfolio management. In fact many of the Ô¨Ånancial
applications that use Monte Carlo simulation involve the evaluation of various
stochastic integrals which are related to the probabilities of particular events
occurring.
In many cases, however, the assumptions of constant volatility and a lognor-
mal distribution for ST are quite restrictive. Real Ô¨Ånancial applications may re-
quire a variety of extensions to the standard Black‚ÄìScholes model. Common re-
quirements are for: nonlognormal distributions, time-varying volatilities, caps,
Ô¨Çoors, barriers, etc. In these circumstances, it is often the case that there is no
closed form solution to the problem. Monte Carlo simulation can then provide
a very useful means of evaluating the required integrals.
When we evaluate the integral of a function, f (x), in the s-dimensional unit
cube, I S, by the Monte Carlo method we are in fact calculating the average of
the function at a set of randomly sampled points. This means that each point
adds linearly to the accumulated sum that will become the integral and also
linearly to the accumulated sum of squares that will become the variance of the
integral.
When there are N sample points, the integral is:
ŒΩ = 1
N
N

i=1
f

xi
where ŒΩ is used to denote the approximation to the integral and x1, x2, . . . , xN
are the N, s-dimensional, sample points. If a pseudo-random number generator
is used the points xi will be (should be) independently and identically distrib-
uted. From standard statistical results we can then estimate the expected error
of the integral as follows:
If we set œái = f (xi) then since xi is independently and identically distributed
œái is also independently and identically distributed. The mean of œái is ŒΩ and we

38
Computational Finance Using C and C#
will denote the variance as Var[œái] = Œî2. It is a well-known statistical prop-
erty that the variance of ŒΩ is given by Var[ŒΩ] = N‚àí1Œî2 (see Appendix E.1 for
further details). We can therefore conclude that the estimated integral ŒΩ has a
standard error of N‚àí1/2Œî. This means that the estimated error of the integral
will decrease at the rate of N‚àí1/2.
It is possible to achieve faster convergence than this if the sample points are
chosen to lie on a Cartesian grid. If we sample each grid point exactly once, then
the Monte Carlo method effectively becomes a deterministic quadrature scheme,
whose fractional error decreases at the rate of N‚àí1 or faster. The trouble with
the grid approach is that it is necessary to decide in advance how Ô¨Åne it should
be, and all the grid points need to be used. It is therefore not possible to sample
until some convergence criterion has been met.
Quasi-random number sequences seek to bridge the gap between the Ô¨Çexibil-
ity of pseudo-random number generators and the advantages of a regular grid.
They are designed to have a high level of uniformity in multidimensional space,
but unlike pseudo-random numbers they are not statistically independent.
3.2
Pseudo-random and quasi-random sequences
Here we consider the generation of multidimensional pseudo-random and quasi-
random sequences to approximate the multidimensional uniform distribution
over the interval [0, 1], that is the distribution U(0, 1).
Quasi-random numbers are also called low-discrepancy sequences. The dis-
crepancy of a sequence is a measure of its uniformity and is deÔ¨Åned as follows:
Given a set of points x1, x2, . . . , xN ‚ààI S and a subset G ‚äÇI S, deÔ¨Åne
the counting function SN(G) as the number of points xi
‚ààG. For each
x = (x1, x2, . . . , xs) ‚ààI S, let Gx be the rectangular s-dimensional region
Gx = [0, x1) √ó [0, x2) √ó ¬∑ ¬∑ ¬∑ √ó [0, xs), with volume x1, x2, . . . , xn. Then the dis-
crepancy of the points x1, x2, . . . , xN is given by:
D‚àó
N

x1, x2, . . . , xN
= sup
x‚ààI S
  SN(Gx) ‚àíNx1x2, . . . , xs
  
The discrepancy is therefore computed by comparing the actual number of sam-
ple points in a given volume of multidimensional space with the number of
sample points that should be there assuming a uniform distribution.
It can be shown that the discrepancy of the Ô¨Årst terms of quasi-random se-
quence has the form:
D‚àó
N

x1, x2, . . . , xN
‚©ΩCS(log N)S + O

(log N)S‚àí1
for all N ‚©æ2.
The principal aim in the construction of low-discrepancy sequences is thus to
Ô¨Ånd sequences in which the constant is as small as possible. Various sequences
have been constructed to achieve this goal. Here we consider the following
quasi-random sequences: Niederreiter, Sobol, and Faure.

Generation of random variates
39
The results of using various random number generators are shown below.
Figures 3.1‚Äì3.3 illustrate the visual uniformity of the sequences. They were cre-
Figure 3.1 The scatter diagram formed by one thousand points from a 16-dimensional
U(0, 1) pseudo-random sequence. For each point the 4th-dimensional component is plot-
ted against the 5th-dimensional component.
Figure 3.2 The scatter diagram formed by one thousand points from a 16-dimensional
U(0, 1) Sobol sequence. For each point the 4th-dimensional component is plotted against
the 5th-dimensional component.

40
Computational Finance Using C and C#
Figure 3.3 The scatter diagram formed by one thousand points from a 16-dimensional
U(0, 1) Niederreiter sequence. For each point the 4th-dimensional component is plotted
against the 5th-dimensional component.
ated by generating one thousand 16-dimensional U(0, 1) sample points, and
then plotting the 4th-dimensional component of each point against its 5th-
dimensional component.
In Fig. 3.1, it can be seen that the pseudo-random sequence exhibits clustering
of points, and there are regions with no points at all.
Visual inspection of Figs. 3.2 and 3.3 shows that both the Sobol and Nieder-
reiter quasi-random sequences appear to cover the area more uniformly.
It is interesting to note that the Sobol sequence appears to be a structured
lattice which still has some gaps. The Niederreiter sequence, on the other hand,
appears to be more irregular and covers the area better. However, we cannot
automatically conclude from this that the Niederreiter sequence is the best. This
is because we have not considered all the other possible pairs of dimensions.
Perhaps the easiest way to evaluate the random number sequences is to use
them to calculate an integral.
In Fig. 3.4 Monte Carlo results are presented for the calculation of the
6-dimensional integral:
I =
 1
0
 1
0
 1
0
 1
0
 1
0
 1
0
6

i=1
cos(ixi) dx1 dx2 dx3 dx4 dx5 dx6
The exact value of this integral is:
I =
6

i=1
sin(i)
which for i = 6, gives I = ‚àí0.0219.

Generation of random variates
41
Figure 3.4 Monte Carlo integration using random numbers.
It can be seen that the pseudo-random sequence gives the worst performance.
But as the number of points increases, its approximation to the integral im-
proves. Of the quasi-random sequences, it can be seen that the Faure sequence
has the worst performance, while both the Sobol and Neiderreiter sequences
give rapid convergence to the solution.
Finance literature contains many references to the beneÔ¨Åts of using quasi-
random numbers for computing important Ô¨Ånancial integrals. For instance,
Brotherton-Ratcliffe (1994) discusses the use of Sobol sequences for the val-
uation of geometric mean stock options, and provides results that show that
the root-mean-squared pricing error obtained using quasi-random numbers is
considerably less than that computed with pseudo-random numbers. Another
Ô¨Ånancial application of quasi-random numbers is the efÔ¨Åcient pricing mort-
gage backed securities, CaÔ¨Çisch, Morokoff, and Owen (1997). Here Brownian
bridge techniques are employed to reduce the effective dimension of the prob-
lem and thus provide greater pricing accuracy than if pseudo-random numbers
were used.
3.3
Generation of multivariate distributions:
independent variates
In this section we show how to generate multivariate distributions that contain
independent variates; that is, the variates have zero correlation.

42
Computational Finance Using C and C#
3.3.1
Normal distribution
The most fundamental distribution is the univariate standard normal distri-
bution, N(0, 1), with zero mean and unit variance. In the case of p indepen-
dent variates this takes the form of a p variate independent normal distribution
N(0, Ip) with zero mean and p √ó p unit covariance matrix Ip.
First we will quote a result concerning multivariate probability density func-
tions; see Press, Teukolsky, Vetterling, and Flannery (1992). If x1, x2, . . . are ran-
dom variates with a joint probability density function p(x1, x2, . . .), and if there
are an equal number of y variates y1, y2, . . . that are functions of the x‚Äôs, then
the joint probability density function of the y variates, p(y1, y2, . . .), is given by
the following expression:
p(y1, y2, . . .) dy1 dy2, . . . = p(x1, x2, . . .)Jx,y dy1 dy2, . . .
(3.3.1)
where Jx,y is the Jacobian determinant of the x‚Äôs with respect to the y‚Äôs.
An important application of this result is the Box‚ÄìMuller transformation in
which a p variate independent normal distribution N(0, Ip) is generated from a
p variate uniform distribution U(0, 1); see Box and Muller (1958).
We will now describe how the method works.
Consider two independently distributed N(0, 1) variables x and y, and use the
polar transformation to obtain:
x = r cos Œ∏,
y = r sin Œ∏,
and
r2 = x2 + y2
(3.3.2)
From Eq. (3.3.1) the joint probability density functions f (r, Œ∏) and f (x, y) obey
the equation
f (r, Œ∏) dr dŒ∏ = f (x, y)Jxy,rŒ∏ dr dŒ∏
where the Jacobian is
Jxy,rŒ∏ =
    
cos Œ∏
sin Œ∏
‚àír sin Œ∏
r cos Œ∏
    = r
We therefore have
f (r, Œ∏) = rf (x, y)
(3.3.3)
Furthermore since x and y are independent N(0, 1)
f (x, y) = f (x)f (y)
where
f (x) = e‚àíx2/2
‚àö
2œÄ
and
f (y) = e‚àíy2/2
‚àö
2œÄ
Therefore:
f (r, Œ∏) = rf (x)f (y) = r e‚àíx2/2
‚àö
2œÄ
e‚àíy2/2
‚àö
2œÄ

Generation of random variates
43
which gives
f (r, Œ∏) = r
2œÄe(‚àíx2+y2)/2 = 1
2œÄre‚àír2/2 = f (Œ∏)f (r)
(3.3.4)
where f (Œ∏) = 1/(2œÄ), f (r) = re‚àír2/2 are independent probability density func-
tions.
The corresponding cumulative probability distribution functions F(Œ∏) and
F(r) can be found by evaluating the following integrals:
F(Œ∏) = 1
2œÄ
 Œ∏
0
dŒ∏ = Œ∏
2œÄ
and
F(r) =
 r
0
re‚àír2/2 dr =

‚àíe‚àír2/2r
0 = 1 ‚àíe‚àír2/2
We now want to draw variates ÀÜr and ÀÜŒ∏ from the probability distributions f (r)
and f (Œ∏) respectively. To do this we will use the result (see for example Evans,
Hastings, and Peacock (2000)), that a uniform variate ¬Øu, from the distribution
U(0, 1) can be transformed into a variate ¬Øv from the distribution f (v) by using
¬Øv = F ‚àí1(¬Øu), or equivalently F(¬Øv) = ¬Øu. The variates ¬Øv are thus found by Ô¨Årst
drawing the uniform variate ¬Øu and then Ô¨Ånding the value of v which makes
cumulative distribution function F(v) equal to ¬Øu.
Therefore, if variates V ‚Ä≤
1 and V ‚Ä≤
2 are from U(0, 1), then the variates ÀÜr and ÀÜŒ∏
which satisfy V ‚Ä≤
1 = F(ÀÜr) = 1 ‚àíe‚àíÀÜr2/2, and V ‚Ä≤
2 = F( ÀÜŒ∏) = ÀÜŒ∏/(2œÄ) are from the
distributions f (r) and f (Œ∏) respectively.
For convenience we will deÔ¨Åne the U(0, 1) variates
V1 = 1 ‚àíV ‚Ä≤
1 = e‚àíÀÜr2/2
and
V2 = V ‚Ä≤
2
So we have:
V1 = e‚àíÀÜr2/2,
V2 =
ÀÜŒ∏
2œÄ
and
log V1 = ‚àíÀÜr2
2 ,
ÀÜr = (‚àí2 log V1)1/2,
and
ÀÜŒ∏ = 2œÄV2
Since ÀÜr is from the same distribution as r, and ÀÜŒ∏ is from the same distribution
as Œ∏, we can use
log V1 = ‚àír2/2,
r = (‚àí2 log V1)1/2,
and
Œ∏ = 2œÄV2
Substituting these results into Eq. (3.3.2) gives
x = (‚àí2 log V1)1/2 cos 2œÄV2,
y = (‚àí2 log V1)1/2 sin 2œÄV2
(3.3.5)
where x and y are N(0, 1).

44
Computational Finance Using C and C#
The Box‚ÄìMuller method is contained in Eq. (3.3.5), which shows that the
N(0, 1) variates are generated in pairs from the uniform U(0, 1) variates V1
and V2.
Since the N(0, 1) variates are created two at a time, if we want to generate a
normal distribution with an odd number of dimensions, nodd, it is necessary to
generate nodd + 1 dimensions and discard one of the dimensions.
It is easy to modify Eq. (3.3.5) so that we can specify the means and variances
of the variates x and y; this is accomplished as follows:
x = œÉ1(‚àí2 log V1)1/2 cos 2œÄV2 + Œº1,
(3.3.6)
y = œÉ2(‚àí2 log V1)1/2 sin 2œÄV2 + Œº2
where the distributions of x and y are now
x ‚àºN

Œº1, œÉ 2
1

and
y ‚àºN

Œº2, œÉ 2
2

Code excerpt 3.1 illustrates how to generate quasi-random normal variates with
given means and standard deviations.
long Quasi_Normal_Independent(long fcall, long seq, double xmean[], double std[],
long idim, double quasi[])
{
/* Input parameters:
=================
fcall
-
if fcall == 1 then it is an initialisation call,
if fcall == 0 then a continuation call
seq
-
if seq == 0 then a Faure sequence, if seq == 1 then a Niederreiter sequence,
if seq == 2 then a Sobol sequence
xmean[]
-
the means of the independent normal variates
std[]
-
the standard deviations of the independent normal variates
idim
-
the number of independent normal variates, idim must be less than 40
Output parameters:
==================
quasi[]
-
the elements quasi[0], .. quasi[idim-1] contain the independent normal variates
*/
long ierr, i, j;
double twopi, v1, v2, pi;
long ind1, ind2;
#define QUASI(I) quasi[(I)-1]
#define STD(I) std[(I)-1]
#define XMEAN(I) xmean[(I)-1]
if ((idim / 2) * 2 != idim) {
printf("Error on entry, idim is not an even number: idim = %ld\n" ,idim);
return 1;
} else if (idim > 40) {
printf("On entry, idim > 40: idim = %ld\n" ,idim);
return 1;
}
for (i = 1; i <= idim; ++i) {
if (STD(i) <= 0.0) {
printf("On entry, the standard deviation is not greater than zero:
STD(%ld) = %12.4f\n" ,i,STD(i));
return 1;
}
}
pi = 4.0*atan(1.0);
Code excerpt 3.1 Generating quasi-random normal variates using the Box‚ÄìMuller trans-
formation.

Generation of random variates
45
if (fcall) { /* first call for initialisation */
if (seq == 0) {
Generate_Faure_Sequence(fcall, idim, &QUASI(1));
}
else if (seq == 1) {
Generate_Niederreiter_Sequence(fcall, idim, &QUASI(1));
}
else if (seq == 2) {
Generate_Sobol_Sequence(fcall, idim, &QUASI(1));
}
} else { /* a continuation call */
if (seq == 0) {
Generate_Faure_Sequence(fcall, idim, &QUASI(1));
}
else if (seq == 1) {
Generate_ Niederreiter_Sequence(fcall, idim, &QUASI(1));
}
else if (seq == 2) {
Generate_Sobol_Sequence(fcall, idim, &QUASI(1));
}
for (i = 1; i <= idim/2; ++i) { /* generate the normal variates */
ind1 = i * 2 - 1;
ind2 = i * 2;
twopi = pi * 2.0;
v1 = sqrt(log(QUASI(ind1)) * -2.0);
v2 = twopi * QUASI(ind2);
QUASI(ind1) = XMEAN(ind1) + STD(ind1) * v1 * cos(v2);
QUASI(ind2) = XMEAN(ind2) + STD(ind2) * v1 * sin(v2);
}
}
return 0 ;
}
Code excerpt 3.1 (Continued).
3.3.2
Lognormal distribution
The lognormal distribution can be generated from the normal distribution dis-
cussed in the previous section by means of a simple transformation. If y ‚àº
N(Œº, œÉ 2) and y = log(x) then x = exp(y), and we say that the variable x has the
lognormal distribution (Œº, œÉ 2).
The lognormal density function is:
f (x) =
1
xœÉ(2œÄ)1/2 exp

‚àí(log x ‚àíŒº)2
2œÉ 2

(3.3.7)
If zi, i = 1, . . . , p, are independent normal variates N(Œºi, œÉ 2
i ), i = 1, . . . , p, then
lognormal variates ‚Ñìi, i = 1, . . . , p, can be generated using the transformation:
‚Ñìi = exp(zi),
i = 1, . . . , p,
(3.3.8)
where the mean of the ith lognormal variate is
E[xi] = ¬Ømi = exp

Œºi + œÉ 2
i
2

(3.3.9)
and the variance is
Var[xi] = s2
i = exp

2Œºi + œÉ 2
i

exp

œÉ 2
i

‚àí1

(3.3.10)
The ratio of variance to the mean squared is therefore
s2
i
¬Øm2
i
= exp

œÉ 2
i

‚àí1
(3.3.11)

46
Computational Finance Using C and C#
or equivalently
œÉ 2
i = log

1 + s2
i
¬Øm2
i

(3.3.12)
A lognormal distribution consisting of p independent variates with means
¬Ømi, i = 1, . . . , p, and variances s2
i , i = 1, . . . , p, can thus be generated using
the following procedure.
First, generate the p independent normal variates:
zi ‚àºN

Œºi, œÉ 2
i

,
i = 1, . . . , p,
where
Œºi = log( ¬Ømi) ‚àíœÉ 2
i
2
(3.3.13)
and
œÉ 2
i = log

1 + s2
i
¬Øm2
i

(3.3.14)
Then create the independent lognormal variates using
‚Ñìi = exp(zi),
i = 1, . . . , p
3.3.3
Student‚Äôs t-distribution
If St(Œº, ŒΩ) represents the Student‚Äôs t-distribution with mean Œº and number of
degrees of freedom ŒΩ, then variates X ‚àºSt(0, ŒΩ) can be generated as follows:
X ‚àº
Z
‚àöY/ŒΩ
(3.3.15)
where Z ‚àºN(0, 1), and Y ‚àºœá2
ŒΩ . The variance of X is:
E

X2
=
ŒΩ
ŒΩ ‚àí2
Variates X‚Ä≤ from a Student‚Äôs t-distribution having ŒΩ degrees of freedom with
mean Œº and variance s can be generated by modifying Eq. (3.3.15) as follows:
X‚Ä≤ ‚àºŒº +
s1/2
‚àöŒΩ/(ŒΩ ‚àí2)
Z
‚àöY/ŒΩ
(3.3.16)
The probability density function, f (x), for X‚Ä≤ is:
f (x) = ((ŒΩ + 1)/2)(ŒΩ ‚àí2)‚àí1/2s‚àí1/2
œÄ1/2(ŒΩ/2)

1 + (x ‚àíŒº)2
s(ŒΩ ‚àí2)
‚àí(ŒΩ+1)/2
(3.3.17)
where ŒΩ > 2.

Generation of random variates
47
3.4
Generation of multivariate distributions:
correlated variates
In this section we will show how to generate variates from a multivariate distri-
bution with a known mean and a given covariance or correlation matrix. The
methods described for covariance matrices are also applicable to correlation ma-
trices, although in this case the generated variates are normalized to have unit
variance.
3.4.1
Estimation of correlation and covariance
Here we show how to obtain a valid correlation matrix Cr or covariance ma-
trix C from historic market data.
Let 
X be an n by p data matrix, with the entries in the ith row corresponding
to the ith observation, and the jth column containing the values of the jth
variable. If we create a new matrix X such that the entries of the jth column of
X are Xi,j = 
Xi,j ‚àíŒºj, i = 1, . . . , n, where Œºj is the mean of the jth column of

X, then the p by p matrix C = XTX is the covariance matrix of 
X.
Further, if another matrix 
X is deÔ¨Åned such that 
Xi,j =

Xi,j ‚àíŒºj
œÉj
, i = 1, . . . , n,
where Œºj is the mean of the jth column of 
X, and œÉj is the standard deviation
of the jth column, then the p by p matrix Cr = 
XT
X is the correlation matrix
of 
X.
Correlation matrix
Let us Ô¨Årst consider the properties of a valid correlation matrix. They are:
‚Ä¢ The matrix is symmetric with unit diagonal
‚Ä¢ The matrix has to be positive deÔ¨Ånite‚Äîthat is, all the eigenvalues need to be
positive.
We will now show that the p by p matrix Cr is a valid correlation matrix
if it can be factored as Cr = XTX, where X is a nonsingular (that is, full rank)
n by m data matrix.
The proof is as follows:
Since X is nonsingular we can perform the singular value decomposition:
X = UKV T
where U is an n by n unitary matrix, K is an n by p matrix containing the
(nonzero) singular values œÉi, i = 1, . . . , p, as the diagonal elements and zero
elsewhere, and V is a p by p unitary matrix.
We thus have
XTX =

UKV TTUKV T
= V KTUTUKV T

48
Computational Finance Using C and C#
= V TKTKV T
since UTU = UUT = In
= V Œ£V T
Therefore
Cr = XTX = V Œ£V T
where Œ£ is the p by p diagonal matrix containing the eigenvalues of Cr, and
V is the corresponding matrix of eigenvectors. Since the ith eigenvalue satisÔ¨Åes
Œªi = œÉ 2
i it can be seen that all the eigenvalues are positive, and thus Cr must be
positive deÔ¨Ånite.
If Cr is positive deÔ¨Ånite, then we can perform the Cholesky decomposition
Cr = LLT where L is a lower triangular matrix.
3.4.2
Repairing correlation and covariance matrices
There are situations when a supplied correlation matrix is not positive deÔ¨Ånite.
Some of the reasons for this are:
‚Ä¢ There may be missing data, or asynchronous data feeds. As a consequence
the elements in the correlation matrix may have then been computed using
pairwise correlations, with a variety of sequence lengths. Under these circum-
stances the equation Cr = XTX is no longer true, and so Cr cannot be guar-
anteed to be positive deÔ¨Ånite
‚Ä¢ Manual adjustment of a correlation matrix may have occurred to reÔ¨Çect ex-
pected market conditions. This especially occurs when the market crashes and
certain stock prices become highly correlated
‚Ä¢ There may be rounding error in computing Cr = XTX.
Under these circumstances the best that can be done is to try and repair the
correlation matrix Cr into a valid correlation matrix 
Cr.
We proceed as follows.
When Cr is not positive deÔ¨Ånite (the Cholesky decomposition fails) then we
use the eigen decomposition:
Cr = V Œ£V T
where
Œ£ =
‚éõ
‚éú‚éú‚éú‚éù
Œª1
Œª2
.
.
Œªp
‚éû
‚éü‚éü‚éü‚é†
We then form the matrix
C+
r = V KKTV T = V K(V K)T

Generation of random variates
49
where the matrix K is formed by taking the square root of the maximum of
each eigenvalue and a very small number Œµ (say ‚àº10‚àí16). Thus:
K =
‚éõ
‚éú‚éú‚éú‚éù
‚àömax(Œª1, Œµ)
‚àömax(Œª2, Œµ)
.
.
max(Œªp, Œµ)
‚éû
‚éü‚éü‚éü‚é†
The matrix C+
r is not acceptable as a correlation matrix because, although real,
symmetric and positive deÔ¨Ånite, its diagonal elements are not unity. It is possi-
ble to remedy this by premultiplying and postmultiplying C+ by the diagonal
matrix F:

Cr = FC+
r F = FC+
r F T
where 
C is the new repaired correlation matrix‚Äîi.e., it is positive deÔ¨Ånite, sym-
metric, and has unit diagonal elements. To achieve this, the diagonal elements
of F must be given by:
Fii =
1

C+
rii
We thus have:

Cr = FC+
r F T
= FV K(V K)TF T
= (FV K)

KTV TF T
= (FV K)(FV K)T
(3.4.1)
An optimally repaired correlation matrix C‚àó
r , which minimizes the distance
‚à•Cr ‚àíC‚àó
r ‚à•, can be obtained via numerical optimization on the n-dimensional
unit hypersphere; this is described below.
However, it has been found that 
Cr is a very good approximation for the
optimal estimate C‚àó
r .
Optimally repaired correlation matrix
Here we provide details of how to obtain an optimally repaired correlation
matrix by using hyperspherical coordinates and the method of Rebonato and
J√§ckel (1999/2000)‚Äîfor a different approach see Higham (2002) or Qi and
Sun (2006).
The Cartesian coordinates of the ith point on an n-dimensional hypersphere
with radius r can be shown to be:
xi,1 = r cos(Œ∏i,1)
xi,2 = r sin(Œ∏i,1) cos(Œ∏i,2)

50
Computational Finance Using C and C#
xi,3 = r sin(Œ∏i,1) sin(Œ∏i,2) cos(Œ∏i,3)
xi,4 = r sin(Œ∏i,1) sin(Œ∏i,2) sin(Œ∏i,3) cos(Œ∏i,4)
...
xi,n‚àí1 = r sin(Œ∏i,1) sin(Œ∏i,2) ¬∑ ¬∑ ¬∑ sin(Œ∏i,n‚àí3) sin(Œ∏i,n‚àí2) cos(Œ∏i,n‚àí1)
xi,n = r sin(Œ∏i,1) sin(Œ∏i,2) ¬∑ ¬∑ ¬∑ sin(Œ∏i,n‚àí2) sin(Œ∏i,n‚àí1)
where Œ∏i,1 are spherical coordinates and have the following constraints: 0 ‚©Ω
Œ∏i,k ‚©ΩœÄ, k = 1, . . . , n ‚àí2, and 0 ‚©ΩŒ∏i,n‚àí1 ‚©Ω2œÄ.
By construction the radius of the sphere satisÔ¨Åes
r2 =
n

k=1
(xi,k)2
This can be seen as follows:
n

k=1
(xi,k)2
= r2
cos2(Œ∏i,1) + sin2(Œ∏i,1)

cos2(Œ∏i,2)
+ sin2(Œ∏i,2)

cos2(Œ∏i,3)
+ sin2(Œ∏i,3)

cos4(Œ∏i,4)
+ ¬∑ ¬∑ ¬∑ + sin2(Œ∏i,n‚àí2)
√ó

cos2(Œ∏i,n‚àí1) + sin2(Œ∏i,n‚àí1)

¬∑ ¬∑ ¬∑

= r2
where we have used
cos2(Œ∏i,k) + sin2(Œ∏i,k) = 1,
k = 1, . . . , n ‚àí1
If, when r = 1, the coordinates of n hyperspherical points are stored in the n
rows of the n by n matrix BT, then:
BT
i,1 = cos(Œ∏i,1)
BT
i,j = cos(Œ∏i,j)
j‚àí1

k=1
sin(Œ∏i,k),
j = 2, . . . , n ‚àí1,
BT
i,n =
n‚àí1

k=1
sin(Œ∏i,k),
n > 1,
BT =
‚éõ
‚éú‚éú‚éù
cos(Œ∏1,1)
sin(Œ∏1,1) cos(Œ∏1,2)
sin(Œ∏1,1) sin(Œ∏1,2) cos(Œ∏1,3)
¬∑ ¬∑ ¬∑
cos(Œ∏2,1)
sin(Œ∏2,1) cos(Œ∏2,2)
sin(Œ∏2,1) sin(Œ∏2,2) cos(Œ∏2,3)
¬∑ ¬∑ ¬∑
cos(Œ∏3,1)
sin(Œ∏3,1) cos(Œ∏3,2)
sin(Œ∏3,1) sin(Œ∏3,2) cos(Œ∏3,3)
¬∑ ¬∑ ¬∑
...
...
...
...
‚éû
‚éü‚éü‚é†

Generation of random variates
51
It can thus be seen that the diagonal elements of BTB are

BTB

i,i =
n

k=1
(xi,k)2 = 1
The Cholesky decomposition can be formed by setting the angles of the upper
triangular elements of BT to zero, and this results in
LT =
‚éõ
‚éú‚éú‚éù
1
0
0
¬∑ ¬∑ ¬∑
cos(Œ∏2,1)
sin(Œ∏2,1)
0
¬∑ ¬∑ ¬∑
cos(Œ∏3,1)
sin(Œ∏3,1) cos(Œ∏3,2)
sin(Œ∏3,1) sin(Œ∏3,2)
¬∑ ¬∑ ¬∑
...
...
...
...
‚éû
‚éü‚éü‚é†
LT
1,1 = 1
LT
i,1 = cos(Œ∏i,1)
LT
i,j = cos(Œ∏i,j)
j‚àí1

k=1
sin(Œ∏i,k),
j = 2, . . . , i ‚àí1,
LT
i,i =
i‚àí1

k=1
sin(Œ∏i,k),
i > 1,
LT
i,j = 0,
j = i + 1, . . . , n
We want to Ô¨Ånd the positive deÔ¨Ånite matrix C‚àó
r which minimizes ‚à•Cr ‚àíC‚àó
r ‚à•.
This can be found by writing
C‚àó
r = LTL
and using numerical optimization to determine the appropriate n(n ‚àí1)/2 an-
gles. An initial approximation can be obtained by computing the Cholesky fac-
torization 
Cr = LTL and then calculating the angles corresponding to each
nonzero element of LT.
Covariance matrix
We will now consider the case when a covariance matrix C is supplied which
is not positive deÔ¨Ånite‚Äîthat is, there is no Cholesky decomposition C = LTL,
where L is lower triangular.
In these circumstances, since a covariance matrix does not require unit diag-
onal elements, it is possible to repair C using:
C+ = V K(V K)T
where V and K have the same meanings as before. A better approximation
could be obtained via numerical optimization of the elements of the Cholesky
decomposition. However, these optimal points are no longer constrained to lie
on the n-dimensional unit hypersphere.

52
Computational Finance Using C and C#
3.4.3
Normal distribution
Here we show how to generate a p variate normal distribution with a given
mean and covariance matrix.
We will denote the vector containing the variates of the ith observation from
a p variate zero mean normal distribution by Zi; that is, we write a sample of n
observations as:
Zi ‚àºN(0, C),
i = 1, . . . , n,
(3.4.2)
where C is the p √ó p covariance matrix.
Further Zi,k is used to denote the kth element of Zi, which contains the value
of the kth variate for the ith observation.
From a computational point of view, we can then consider a sample of n
observations to be represented by the n√óp matrix Z. The ith row of Z contains
the values for ith the observation, and the kth column of the ith row, Zi,k,
contains the value of the kth variate for the ith observation.
Also, since the distribution has zero mean, the sample covariance matrix is
given by: C = ZTZ.
To generate variates with the covariance matrix C we can use the fact that, if
the matrix C is positive deÔ¨Ånite, a Cholesky factorization exists in which:
C = AAT
(3.4.3)
where A is lower triangular.
We can therefore generate p variates which have a covariance matrix C as
follows.
First generate by (for example) using the Box‚ÄìMuller method described in
Section 3.3.1, the independent normal variates:
X ‚àºN(0, Ip)
where the vector X contains the p variates, Ip is the unit matrix, and XXT = Ip.
Then, using the Cholesky factorization of Eq. (3.4.4), form:
Y = AX
(3.4.4)
where Y is a p-element vector.
Now, since YY T = AX(AX)T = A(XXT)AT = AAT = C, we have that
Y ‚àºN(0, C)
Variates that have nonzero means Œºk, k = 1, . . . , p, can be obtained by simply
modifying Eq. (3.4.4) to:
Y ‚Ä≤ = AX + Œº
(3.4.5)
where Y ‚Ä≤ is a p variate vector that is distributed as N(Œº, C), and the p elements
of vector Œº contain the means of the variates Y ‚Ä≤
k, k = 1, . . . , p.
If the matrix C is not positive deÔ¨Ånite, then we can create a repaired matrix,

C, by using the approach outlined in Section 3.4.2.

Generation of random variates
53
We now use the decomposition:

C = V K(V K)T
Under these circumstances the p-element vectors Y and Y ‚Ä≤ are generated using
the following modiÔ¨Åed versions of Eqs. (3.4.4) and (3.4.5):
Y = V KX
and
Y ‚Ä≤ = V KX + Œº
(3.4.6)
The method for generating variates Y from a given correlation matrix Cr
is identical. However, in this case nonpositive deÔ¨Ånite matrices are repaired as

Cr = FV K(FV K)T; see Section 3.4.2.
A function to generate correlated normal and lognormal variates is given in
Code excerpt 3.2.
long Quasirandom_Normal_LogNormal_Correlated(long fcall, long seq, long lnorm,
double means[], long n, double c[], long tdc, double tol, long *irank,
double x[], double work[], long lwk) {
/* Input parameters:
=================
fcall
-
if fcall == 1 then it is an initialisation call,
if fcall == 0 then a continuation call
seq
-
if seq == 0 then a Faure sequence, if seq == 1 then a Niederreiter sequence,
if seq == 2 then a Sobol sequence
lnorm
-
if lnorm == 1 then it is a lognormal distribution,
if lnorm == 0 then a normal distribution
n
-
the number of variates, n must be less than 40
c[]
-
a matrix which contains the required covariance matrix, C
tdc
-
the second dimension of the matrix C
tol
-
the tolerance used for calculating the rank of the covariance matrix C
means[]
-
the means of the independent normal variates
std[]
-
the standard deviations of the independent normal variates
lwk
-
the size of the work array, work
Output parameters:
==================
rank
-
the computed rank of the covariance matrix C
x[]
-
the elements x[0], .. x[n-1] contain the variates
Input/Output parameters:
=========================
work
-
a work array
*/
double zero = 0.0, one = 1.0, two = 2.0;
long n1, i, j, k, kk;
double mtol, alpha;
long ptrc, ptre, ptrv, ptrw, ptrw0, ptrw1;
#define C(I,J) c[((I)-1) * tdc + ((J)-1)]
#define MEANS(I) means[(I)-1]
#define X(I) x[(I)-1]
#define WORK(I) work[(I)-1]
if (lwk < (2 + 3*n + 2*n*n + 3)) {
printf ("Error lwk is too small \n");
return 1;
}
ptre = 2;
ptrv = n+2;
ptrw = n*n + n + 2;
Code excerpt 3.2 The function Quasirandom_Normal_LogNormal_Correlated
which generates correlated quasi-random normal variates and correlated quasi-random
lognormal variates.

54
Computational Finance Using C and C#
/* add extra 1 to allow for odd values of n */
ptrw0 = ptrw + 1 + n;
ptrw1 = ptrw0 + 1 + n;
ptrc
= ptrw1 + n + 1;
n1 = n;
if (((n/2)*2) != n) { /*
test for odd n */
n1 = n + 1;
}
if (fcall) {
/* first call for initialisation */
if (lnorm) { /* lognormal distribution */
for (i = 1; i <=n; ++i) { /* Load the modified covariance matrix into WORK */
for (j = 1; j <= n; ++j) {
WORK(ptrc+(i-1)*n+j-1) = log(one + C(i,j)/(MEANS(i)*MEANS(j)));
}
}
}
else { /* normal distribution */
for (i = 1; i <=n; ++i) {
/* Load the covariance matrix into WORK */
for (j = 1; j <= n; ++j) {
WORK(ptrc+(i-1)*n+j-1) = C(i,j);
}
}
}
/* calculate the eigenvalues and eigenvector of the matrix that
has been loaded into WORK */
calc_eigvals_eigvecs (n,&WORK(ptrc),n,&WORK(ptre),&WORK(ptrv),n);
/* The code uses NAG routine f02abc */
*irank = 0;
/*
printf ("The eigenvalues are \n");
for (j=n; j >= 1; --j) {
printf ("%12.5f \n", WORK(ptre+j-1));
}
*/
for (j=n; j >= 1; --j) { /* use the eigenvalues to calculate the rank of the matrix */
if (WORK(ptre+j-1) < tol) goto L24;
*irank = *irank + 1;
}
printf ("*irank = %ld \n",*irank);
L24:
mtol = -tol;
if (WORK(ptre) < mtol) {
printf ("Warning there is an eigenvalue less than %12.4f \n",mtol);
}
for (j=1; j <= *irank; ++j) {
kk = 1;
for (k=1; k <=n; ++k) {
if(WORK(ptrv+(k-1)*n+(j-1)) != zero) goto L28;
kk = kk + 1;
}
L28:
/* ensure that all eigenvectors have the same sign on different machines */
alpha = sqrt(WORK(ptre+j-1));
if
(WORK(ptrv+(kk-1)*n+(j-1)) < zero)
alpha = -sqrt(WORK(ptre+j-1));
for (i = 1; i <= n; ++i) {
WORK(ptrv+(j-1)+(i-1)*n)=WORK(ptrv+(j-1)+(i-1)*n)*alpha;
}
}
/*
printf ("The eigenvectors are \n");
for (j=1; j <= *irank; ++j) {
for (i = 1; i <= n; ++i) {
printf ("%10.5f ", WORK(ptrv+(j-1)+(i-1)*n));
}
printf ("\n");
}
*/
for (i = 1; i <=n; ++i)
{ /* store a vector of ones and zeros for generating the quasi-random numbers */
WORK(ptrw0+i-1) = zero;
WORK(ptrw1+i-1) = one;
}
Code excerpt 3.2 (Continued).

Generation of random variates
55
for (i = n; i <= n1; ++ i) {
WORK(ptrw0+i-1) = zero;
WORK(ptrw1+i-1) = one;
}
} /* end of first
call section */
/* generate a vector of n1 random variables from a standard normal distribution,
zero mean and unit variance */
Quasi_Normal_Independent(fcall, seq, &WORK(ptrw0), &WORK(ptrw1),
n1, &WORK(ptrw));
/*
printf ("The quasi random numbers are:\n");
for (i = 1; i <= n; ++i) {
printf ("%12.4f \n", WORK(ptrw+(i-1)));
}
*/
/* Now generate variates with the specified mean and variance */
if (lnorm) { /* a lognormal distribution */
for (i = 1; i <= n; ++i) {
X(i) =
log(MEANS(i)) - WORK(ptrc+(i-1)*n+i-1)/two;
for (k = 1; k <= *irank; ++k) {
X(i)=X(i)+WORK(ptrv+(k-1)+(i-1)*n)*WORK(ptrw+k-1);
}
}
for (i = 1; i <= n; ++i) {
X(i) = exp(X(i));
}
}
else { /* a normal distribution */
for (i = 1; i <= n; ++i) {
X(i) =
MEANS(i);
for (k = 1; k <= *irank; ++k) {
X(i)=X(i)+WORK(ptrv+(k-1)+(i-1)*n)*WORK(ptrw+k-1);
}
}
}
/*
printf ("The generated variates are:\n");
for (i = 1; i <= n; ++i) {
printf (" %12.4f \n", X(i));
}
*/
return 0;
}
Code excerpt 3.2 (Continued).
In order to visualize the effect of the covariance matrix we will display the
results of using function Quasirandom_Normal_LogNormal_Correlated
to generate the following variates:
‚Ä¢ A vector of three normal independent variates with covariance matrix:
C1 =
 1.0
0.0
0.0
0.0
1.0
0.0
0.0
0.0
1.0

‚Ä¢ A vector of three normal variates in which the elements of the covariance
matrix are all positive; the covariance matrix is:
C2 =
 1.0
0.8
0.8
0.8
1.0
0.8
0.8
0.8
1.0


56
Computational Finance Using C and C#
Figure 3.5 Scatter diagram for a sample of 3000 observations (Zi, i = 1, . . . , 3000) gener-
ated from a multivariate normal distribution consisting of three variates with covariance
matrix C1 and mean Œº. Here we plot the values of the Ô¨Årst variate against the values of
the second variate. If we use the notation of Eq. (3.4.2), then the (x, y) coordinates for
the points are xi = Zi,1, i = 1, . . . , 3000, and yi = Zi,2, i = 1, . . . , 3000.
‚Ä¢ A vector of three normal variates in which two elements of the covariance
matrix are negative; the covariance matrix is:
C3 =
 1.0
‚àí0.7
0.2
‚àí0.7
1.0
0.2
0.2
0.2
1.0

In all cases the mean vector is given by:
Œº =
 2.0
2.0
2.0

The results are displayed in Figs. 3.5‚Äì3.7.
3.4.4
Lognormal distribution
The multivariate lognormal distribution is important because it is the asset re-
turns distribution assumed by the Black‚ÄìScholes equation.
Let the p-element vectors Y and X be related by Y = log(X) where Y ‚àº
N(Œº, Œ£), Œº is a p-element vector, and Œ£ is a p√óp matrix. Then X = exp(Y) and
X has multivariate lognormal distribution, which we denote by X ‚àº(Œº, Œ£).
We will represent the p-element mean vector of X by ¬Øm and the p √ó p covari-
ance matrix of X by S.

Generation of random variates
57
Figure 3.6 Scatter diagram for a sample of 3000 observations (Zi, i = 1, . . . , 3000) gener-
ated from a multivariate normal distribution consisting of three variates with covariance
matrix C2 and mean Œº. Here we plot the values of the Ô¨Årst variate against the values of
the second variate. If we use the notation of Eq. (3.4.2), then the (x, y) coordinates for
the points are xi = Zi,1, i = 1, . . . , 3000, and yi = Zi,2, i = 1, . . . , 3000.
Figure 3.7 Scatter diagram for a sample of 3000 observations (Zi, i = 1, . . . , 3000) gener-
ated from a multivariate normal distribution consisting of three variates with covariance
matrix C3 and mean Œº. Here we plot the values of the Ô¨Årst variate against the values of
the second variate. If we use the notation of Eq. (3.4.2), then the (x, y) coordinates for
the points are xi = Zi,1, i = 1, . . . , 3000, and yi = Zi,2, i = 1, . . . , 3000.

58
Computational Finance Using C and C#
It can be shown that:
Œ£i,j = log

1 + Si,j
¬Ømi ¬Ømj

(3.4.7)
and
Œºi = log( ¬Ømi) ‚àíŒ£i,i
2 ,
i = 1, . . . , p, and j = 1, . . . , p
(3.4.8)
For the case of independent variates we then have:
Œºi = log( ¬Ømi) ‚àíœÉ 2
i
2 ,
i = 1, . . . , p,
and
Œ£i,i = œÉ 2
i = log

1 + s2
i
¬Ømi2

,
i = 1, . . . , p,
and for i Ã∏= j,
Œ£i,j = 0
which are just Eqs. (3.3.13) and (3.3.14) given in Section 3.3.2.
Code excerpt 3.3 shows how to generate a multivariate lognormal distri-
bution with a given mean ¬Øm and covariance matrix S. More complete infor-
mation can be found in the function Quasirandom_Normal_LogNormal_
Correlated which is provided in Code excerpt 3.2.
double sig[40][40], s[40][40]; /* limit of 40 */
double means[40], x[40], lx[40], tmp;
.
.
.
#define S(I,J) s[(I)-1][(J)-1]
#define SIG(I,J) sig[(I)-1][(J)-1]
#define MEANS(i) means[(I)-1]
/* the means of the lognormal distribution */
#define X(I) x[(I)-1] /* normal variates */
#define LX(I) lx[(I)-1] /* lognormal variates */
.
.
.
/* obtain the Gaussian covariance matrix SIG, that corresponds to the
lognormal covariance matrix S. */
for (i=1; i <= m; ++i) {
for (j=1; j <= m; ++j) {
tmp = MEANS(i) * MEANS(j);
SIG(i,j) = log( 1 + (S(i,j)/tmp));
}
}
.
.
.
/* Generate multivariate Gaussian variates X(i),i = 1,..,m, with zero mean and
covariance matrix SIG, using section ..
*/
.
.
.
/* Using equation () generate normal variates with the correct mean */
for (i=1; i <= m; ++i) {
X(i) = X(i) + log(MEANS(i)) - SIG(i,i)/2;
}
/* Now exponentiate to create lognormal variates with mean
XMEAN, and covariance matrix S */
for (i=1; i <= m; ++i) {
LX(i) = exp(X(i));
}
Code excerpt 3.3 Illustrating how to generate variates from a lognormal distribution
with a given mean and covariance matrix.

4 European options
4.1
Introduction
A European option taken out at current time t gives the owner the right (but not
the obligation) to do something when the option matures at time T . This could,
for example, be the right to buy or sell stocks at a particular strike price. The
option would of course only be exercised if it was in the owner‚Äôs interest to do
so. For example, a single asset European vanilla put option, with strike price E
and expiry time T , gives the owner the right at time T to sell a particular asset
for E. If the asset is worth ST at maturity then the value of the put option at
maturity, known as the payoff, is thus max(E ‚àíST , 0). By contrast a single asset
European vanilla call option, with strike price E and expiry time T , gives the
owner the right at time T to buy an asset for E; the payoff at maturity for a call
option is max(ST ‚àíE, 0).
The owner of an American option has the right (but not the obligation) to
exercise the option at any time from current time t to option maturity. These
options are more difÔ¨Åcult to value than European options because of this ex-
tra Ô¨Çexibility. Even the simple single asset American vanilla put has no analytic
solution and requires Ô¨Ånite-difference and lattice methods to estimate its value.
Many European options, on the other hand, take the form of a relatively easy
deÔ¨Ånite integral from which it is possible to compute a closed form solution.
The valuation of multiasset European options, dependent on a large number of
underlying assets, is more complicated but can conveniently be achieved by us-
ing Monte Carlo simulation to compute the required multidimensional deÔ¨Ånite
integral.
The expected current value of a single asset European vanilla option will de-
pend on the current asset price at time t, S, the duration of the option, œÑ = T ‚àít,
the strike price, E, the riskless interest rate, r, and the probability density func-
tion of the underlying asset at maturity, p(ST ).
4.2
Pricing derivatives using a martingale measure
In this section we will brieÔ¨Çy summarize the results of Harrison and Kreps
(1979) and Harrison and Pliska (1981). Let us consider an economy over the
time interval [0, T ] which consists of n assets Si, i = 1, . . . , n, which can take

60
Computational Finance Using C and C#
the values Si
t , i = 1, . . . , n, 0 ‚©Ωt ‚©ΩT . Any asset Si which only takes values that
are greater than zero is called a numeraire. Numeraires can be used to denom-
inate all the asset prices in the economy. So (for example) if S1 is a numeraire
then the prices of the other assets denominated in units of S1 are the relative
prices Zi
t = (Si
t /S1
t ), i = 2, . . . , n.
One can Ô¨Ånd a unique probability measure Q such that the relative prices
Zi
t , i = 2, . . . , n, are martingales. If the economy is free of arbitrage opportu-
nities then every payoff pattern HT can be represented as a linear combination
of the asset values Si
t , i = 1, . . . , n, and in addition the relative price process
(HT /S1
T ) is a martingale.
This means that we can write
EQ
Ht
S1t

= EQ
HT
S1
T

,
where 0 ‚©Ωt ‚©ΩT
The current (time t) value Vt of the payoff HT is thus
Vt = S1
t EQ
HT
S1
T

In general for a numeraire N which takes the values Nt, 0 ‚©Ωt ‚©ΩT , we can write
Vt = NtEQ
HT
NT

(4.2.1)
Equation (4.2.1) is very important because Vt is the current (time t) price of a
Ô¨Ånancial derivative with maturity T and payoff HT .
It should be mentioned that the price of a Ô¨Ånancial derivative is independent
of the martingale measure under which it is valued, and thus the same price Vt
will be obtained for different numeraires N.
4.3
Put call parity
4.3.1
Discrete dividends
Here we consider single asset European put and call options, and derive the
following relationship between their values in the presence of cash dividends:
c(S, E, œÑ) + E exp(‚àírœÑ) + D = p(S, E, œÑ) + S
(4.3.1)
where D is the present value of the dividends that are paid during the life of the
option. That is:
D =
n

k=1
Dk exp

‚àír(tk ‚àít)

with Dk the kth cash dividend paid at time tk; the other symbols have already
been deÔ¨Åned in Section 4.1.
This result can be proved by considering the following two investments:

European options
61
Portfolio A: One European call, c(S, E, œÑ), and cash of value E exp(‚àírœÑ)+D.
Portfolio B: One European put, p(S, E, œÑ), and one share of value S.
At option maturity the value of the call and put are c(ST , E, 0) and
p(ST , E, 0), respectively; also at time T the value of the dividends paid dur-
ing the life of the option is D exp(rœÑ).
We now consider the value of both portfolios at time T under all possible
conditions.
If ST ‚©æE
Portfolio A is worth:
max(ST ‚àíE, 0) + exp(rœÑ)

E exp(‚àítœÑ) + D

= ST ‚àíE + E + D exp(rœÑ)
= ST + D exp(rœÑ)
Portfolio B is worth:
max(E ‚àíST , 0) + ST + D exp(rœÑ) = 0 + ST + D exp(rœÑ)
= ST + D exp(rœÑ)
If ST < E
Portfolio A is worth:
max(ST ‚àíE, 0) + exp(rœÑ)

E exp(‚àítœÑ) + D

= 0 + E + D exp(rœÑ)
= E + D exp(rœÑ)
Portfolio B is worth:
max(E ‚àíST , 0) + ST + D exp(rœÑ) = E ‚àíST + ST + D exp(rœÑ)
= E + D exp(rœÑ)
We have therefore shown that under all conditions the value of portfolio A is
the same as that of portfolio B.
4.3.2
Continuous dividends
Here we consider single asset European put and call options, and derive the
following relationship:
c(S, E, œÑ) + E exp(‚àírœÑ) = p(S, E, œÑ) + S exp(‚àíqœÑ)
(4.3.2)
where q is the asset‚Äôs continuous dividend yield that is paid during the life of the
option. The result can be proved by considering the following two investments:
Portfolio A: One European call, c(S, E, œÑ), and cash of value E exp(‚àírœÑ).

62
Computational Finance Using C and C#
Portfolio B: One European put, p(S, E, œÑ), and one share of value
S exp(‚àíqœÑ).
At option expiry the value of the call and put are c(ST , E, 0) and p(ST , E, 0),
respectively. Also, if the value of the share at time t is denoted by S, the com-
bined value of shares and dividends at time T is S exp(qœÑ): Note that q is treated
in a similar manner to the continuously compounded riskless interest rate r.
If ST ‚©æE
Portfolio A is worth:
max(ST ‚àíE, 0) + exp(rœÑ)E exp(‚àírœÑ) = ST ‚àíE + E = ST
Portfolio B is worth:
max(E ‚àíST , 0) + ST exp(‚àíqœÑ) exp(qœÑ) = 0 + ST = ST
where ST exp(‚àíqœÑ) exp(qœÑ) is the combined value of the shares and dividends at
option maturity.
If ST < E
Portfolio A is worth:
max(ST ‚àíE, 0) + exp(rœÑ)E exp(‚àírœÑ) = 0 + E = E
Portfolio B is worth:
max(E ‚àíST , 0) + ST exp(‚àíqœÑ) exp(qœÑ) = E ‚àíST + ST = E
We have therefore shown that under all conditions the value of portfolio A is
the same as that of portfolio B.
4.4
Vanilla options and the Black‚ÄìScholes model
4.4.1
The option pricing partial differential equation
In this section we will derive the (Black‚ÄìScholes) partial differential equation
that is obeyed by options written on a single asset.
Previously, in Section 2.3 and Section 2.5, we derived Ito‚Äôs lemma, which
provides an expression for the change in value of the function œÜ(X, t), where
X is a stochastic variable. When the stochastic variable, X, follows GBM, the
change in the value of œÜ was shown to be given by Eq. (2.3.6). Here we will
assume that the function œÜ(S, t) is the value of a Ô¨Ånancial option and that the
price of the underlying asset, S, follows GBM.
If we denote the value of the Ô¨Ånancial derivative by f , then its change, df ,
over the time interval dt is given by:
df =

ŒºS ‚àÇf
‚àÇS + ‚àÇf
‚àÇt + œÉ 2S2
2
‚àÇ2f
‚àÇS2

dt + ‚àÇf
‚àÇS œÉS dW,
dW ‚àºN(0, dt)

European options
63
The discretized version of this equation is:
f = t

ŒºS ‚àÇf
‚àÇS + ‚àÇf
‚àÇt + œÉ 2S2
2
‚àÇ2f
‚àÇS2

+ ‚àÇf
‚àÇS œÉSW,
W ‚àºN(0, t),
(4.4.1)
where the time interval is now t and the change in derivative value is f .
If we assume that the asset price, S, follows GBM we also have:
S = ŒºSt + œÉSW,
W ‚àºN(0, t),
(4.4.2)
where Œº is the constant drift and the deÔ¨Ånition of the other symbols is as before.
Let us now consider a portfolio consisting of ‚àí1 derivative and ‚àÇf
‚àÇS units of the
underlying stock. In other words we have gone short (that is sold) a derivative
on an asset and have ‚àÇf
‚àÇS stocks of the (same) underlying asset. The value of the
portfolio, Œ†, is therefore:
Œ† = ‚àíf + ‚àÇf
‚àÇS S
(4.4.3)
and the change, Œ†, in the value of the portfolio over time t is:
Œ† = ‚àíf + ‚àÇf
‚àÇS S
(4.4.4)
Substituting Eqs. (4.4.1) and (4.4.2) into Eq. (4.4.4) we obtain:
Œ† = ‚àí

ŒºS ‚àÇf
‚àÇS + ‚àÇf
‚àÇt + 1
2œÉ 2S2 ‚àÇ2f
‚àÇS2

t
‚àíœÉSW ‚àÇf
‚àÇS + ‚àÇf
‚àÇS {ŒºSt + œÉSW}
‚à¥Œ† = ‚àíŒºSt ‚àÇf
‚àÇS ‚àít ‚àÇf
‚àÇt ‚àí1
2tœÉ 2S2 ‚àÇ2f
‚àÇS2
‚àíœÉSW ‚àÇf
‚àÇS + ŒºSt ‚àÇf
‚àÇS + œÉSW ‚àÇf
‚àÇS
(4.4.5)
Cancelling terms we obtain:
Œ† = ‚àít
‚àÇf
‚àÇt + 1
2œÉ 2S2 ‚àÇ2f
‚àÇS2

(4.4.6)
If this portfolio is to grow at the riskless interest rate r, we have:
rŒ†t = Œ†
So we have that:
rŒ†t = ‚àít
‚àÇf
‚àÇt + 1
2œÉ 2S2 ‚àÇ2f
‚àÇS2

(4.4.7)
Substituting for Œ†, we obtain:
rt

f ‚àíS ‚àÇf
‚àÇS

= ‚àít
‚àÇf
‚àÇt + 1
2œÉ 2S2 ‚àÇ2f
‚àÇS2

(4.4.8)

64
Computational Finance Using C and C#
On rearranging we have:
‚àÇf
‚àÇt + S ‚àÇf
‚àÇS + 1
2œÉ 2S2 ‚àÇ2f
‚àÇS2 = rf
(4.4.9)
which is the Black‚ÄìScholes partial differential equation. See Appendix I con-
cerning the Feynman‚ÄìKac formula.
Let us now consider put and call options on the same underlying asset. If we
let c be the value of a European call option and p that of a European put option
then we have the following equations:
‚àÇp
‚àÇt + S ‚àÇp
‚àÇS + 1
2œÉ 2S2 ‚àÇ2p
‚àÇS2 = rp
(4.4.10)
and
‚àÇc
‚àÇt + S ‚àÇc
‚àÇS + 1
2œÉ 2S2 ‚àÇ2c
‚àÇS2 = rc
(4.4.11)
If we now form a linear combination of put and call options, Œ® = a1c + a2p,
where both a1 and a2 are constants, then Œ® also obeys the Black‚ÄìScholes equa-
tion:
‚àÇŒ®
‚àÇt + S ‚àÇŒ®
‚àÇS + 1
2œÉ 2S2 ‚àÇ2Œ®
‚àÇS2 = rŒ®
(4.4.12)
We will now prove that Œ® satisÔ¨Åes Eq. (4.4.12).
First we rewrite Eq. (4.4.12) as:
‚àÇ(a1c + a2p)
‚àÇt
+ S ‚àÇ(a1c + a2p)
‚àÇS
+ 1
2œÉ 2S2 ‚àÇ2(a1c + a2p)
‚àÇS2
= r(a1c + a2p)
(4.4.13)
and use the following results from elementary calculus:
‚àÇ(a1c + a2p)
‚àÇt
= a1
‚àÇc
‚àÇt + a2
‚àÇp
‚àÇt
‚àÇ(a1c + a2p)
‚àÇS
= a1
‚àÇc
‚àÇS + a2
‚àÇp
‚àÇS
and
‚àÇ2(a1c + a2p)
‚àÇS2
= a1
‚àÇ2c
‚àÇS2 + a2
‚àÇ2p
‚àÇS2
If we denote the left-hand side of Eq. (4.4.12) by LHS, then we have:
LHS = a1
‚àÇc
‚àÇt + S ‚àÇc
‚àÇS + 1
2œÉ 2S2 ‚àÇ2c
‚àÇS2

+ a2
‚àÇp
‚àÇt + S ‚àÇp
‚àÇS + 1
2œÉ 2S2 ‚àÇ2p
‚àÇS2

(4.4.14)

European options
65
We now use Eqs. (4.4.10) and (4.4.11) to substitute for the values in the curly
brackets in Eq. (4.4.14), and we obtain:
LHS = a1rc + a2rp
(4.4.15)
which is just the right-hand side of Eq. (4.4.12); so we have proved the result.
It should be noted that this result is also true for American options, since they
also obey the Black‚ÄìScholes equation.
The above result can be generalized to include a portfolio consisting of n sin-
gle asset options. Here we have:
Œ® =
n

j=1
ajfj,
j = 1, . . . , n,
where fj represents the value of the jth derivative and aj is the number of
units of the jth derivative. To prove that Œ® follows the Black‚ÄìScholes equa-
tion we simply partition the portfolio into sectors whose options depend on the
same underlying asset. We then proceed as before by showing that the value
of each individual sector obeys the Black‚ÄìScholes equation and thus the value
of the complete portfolio (the sum of the values of all the sectors) obeys the
Black‚ÄìScholes equation. It should be mentioned that this result applies for both
American and European options and it does not matter whether we have bought
or sold the options.
In Chapter 5 we will use the fact that the difference between the value of a
European option and the equivalent American option obeys the Black‚ÄìScholes
equation. We can see this immediately by considering the following portfolios
that are long in an American option and short (i.e., have sold) a European op-
tion:
Œ® p = P ‚àíp,
Œ® c = C ‚àíc
where P and C are the values of American put and call options. Œ® p and Œ® c both
obey the Black‚ÄìScholes equations, and are the respective differences in value of
American/European put options and American/European call options.
4.4.2
The multiasset option pricing partial differential equation
In this section we will derive the multiasset (Black‚ÄìScholes) differential equation
that is obeyed by options written on n assets. Proceeding as in Section 4.4.1, we
will use the n-dimensional version of Ito‚Äôs lemma to Ô¨Ånd the process followed
by the value of a multiasset Ô¨Ånancial derivative. We will denote the value of this
derivative by f (S, t), where S is an n-element stochastic vector containing the
prices of the underlying assets, Si, i = 1, . . . , n. If we assume that S follows
n-dimensional GBM then the change in the value of the derivative, df , is (see

66
Computational Finance Using C and C#
Eq. (2.5.8)) given by:
df =

‚àÇf
‚àÇt +
n

i=1
ŒºiSi
‚àÇf
‚àÇSi
+ 1
2
n

i=1
n

j=1
œÉiœÉjSiSjœÅij
‚àÇ2f
‚àÇSi ‚àÇSj

dt
+
n

i=1
‚àÇf
‚àÇSi
œÉiSi dWi
(4.4.16)
The discretized version of this equation is:
f =

‚àÇf
‚àÇt +
n

i=1
ŒºiSi
‚àÇf
‚àÇSi
+ 1
2
n

i=1
n

j=1
œÉiœÉjSiSjœÅij
‚àÇ2f
‚àÇSi ‚àÇSj

t
+
n

i=1
‚àÇf
‚àÇSi
œÉiSiWi
(4.4.17)
where the time interval is now t and the change in derivative value is f .
Let us now consider a portfolio consisting of ‚àí1 derivative and ‚àÇf
‚àÇSi units of
the ith underlying stock. In other words we have gone short (that is sold) a
derivative that depends on the price, Si, i = 1, . . . , n, of n underlying assets, and
have ‚àÇf
‚àÇSi units of the ith asset. The value of the portfolio, Œ†, is therefore:
Œ† = ‚àíf +
n

i=1
‚àÇf
‚àÇSi
Si
(4.4.18)
and the change, Œ†, in the value of the portfolio over the time interval t is:
Œ† = ‚àíf +
n

i=1
‚àÇf
‚àÇSi
Si
(4.4.19)
Since the stochastic variables Si, i = 1, . . . , n, follow n-dimensional GBM, the
change in the ith asset price, Si, over the time interval t is given by:
Si = ŒºiSit + œÉiSiWi,
i = 1, . . . , n,
(4.4.20)
where Wi = dZi
‚àö
t,
E

dZ2
i

= 1,
i = 1, . . . , n,
and
E[dZi dZj] = œÅi,j,
i = 1, . . . , n, j = 1, . . . , n, i Ã∏= j
Substituting Eqs. (4.4.17) and (4.4.20) into Eq. (4.4.19), we obtain:
Œ† = ‚àí

‚àÇf
‚àÇt +
n

i=1
ŒºiSi
‚àÇf
‚àÇSi
+ 1
2
n

i=1
n

j=1
œÉiœÉjœÅijSiSj
‚àÇ2f
‚àÇSi ‚àÇSj

t
‚àí
n

i=1
œÉiSiWi
‚àÇf
‚àÇSi
+
n

i=1
‚àÇf
‚àÇSi
{ŒºiSit + œÉSiWi}

European options
67
‚à¥Œ† = ‚àí
n

i=1
ŒºiSit ‚àÇf
‚àÇSi
‚àít ‚àÇf
‚àÇt ‚àí1
2t
n

i=1
n

j=1
œÉiœÉjœÅijSiSj
‚àÇ2f
‚àÇSi ‚àÇSj
‚àí
n

i=1
œÉiSiWi
‚àÇf
‚àÇSi
+
n

i=1
ŒºiSit ‚àÇf
‚àÇSi
+
n

i=1
œÉiSiWi
‚àÇf
‚àÇSi
(4.4.21)
Cancelling terms we obtain:
Œ† = ‚àít

‚àÇf
‚àÇt + 1
2
n

i=1
n

j=1
œÉiœÉjœÅijSiSj
‚àÇ2f
‚àÇSi ‚àÇSj

(4.4.22)
If this portfolio is to grow at the riskless interest rate r we have:
rŒ†t = Œ†
So from Eq. (4.4.22) we have that:
rŒ†t = ‚àít

‚àÇf
‚àÇt + 1
2
n

i=1
n

j=1
œÉiœÉjœÅijSiSj
‚àÇ2f
‚àÇSi ‚àÇSj

(4.4.23)
Substituting for Œ† we obtain:
rt

f ‚àí
n

i=1
Si
‚àÇf
‚àÇSi

= ‚àít

‚àÇf
‚àÇt + 1
2
n

i=1
n

j=1
œÉiœÉjœÅijSiSj
‚àÇ2f
‚àÇSi ‚àÇSj

(4.4.24)
Rearranging Eq. (4.4.24) gives:
‚àÇf
‚àÇt +
n

i=1
Si
‚àÇf
‚àÇSi
+ 1
2
n

i=1
n

j=1
œÉiœÉjœÅijSiSj
‚àÇ2f
‚àÇSi ‚àÇSj
= rf
(4.4.25)
which is the n-dimensional Black‚ÄìScholes partial differential equation.
4.4.3
The Black‚ÄìScholes formula
The Black‚ÄìScholes model consists of two assets: the riskless money account and
an equity. It can be cast as the following two-dimensional Ito equation:
dSt = ŒºSt dt + œÉSt dW P
(4.4.26)
dBt = rBt dt
where W P is Brownian motion (without drift) under measure P, so dW P ‚àº
N(0, dt).

68
Computational Finance Using C and C#
Current time will be denoted by t0, and the option maturity time by T . The
money market account has value Bt0 = 1 at time t0 and BT = exp(r(T ‚àít0) at
time T .
We will now consider the process followed by the relative value œÜ(St, Bt) =
St/Bt.
Using the Ito quotient rule as described in Section 2.6.2 and substituting X1 =
St and X2 = Bt in Eq. (2.6.8) we have:
d
 St
Bt

=
 St
Bt

(Œº ‚àír) dt +
 St
Bt

œÉ dW P
So Ô¨Ånally we can write:
dS‚àó
t = S‚àó
t (Œº ‚àír) dt + S‚àó
t œÉ dW P
(4.4.27)
where S‚àó
t = St/Bt.
Referring to Girsanov‚Äôs theorem in Section 2.4, we can choose a probability
measure Q such that:
dW p = dW Q ‚àí
Œº ‚àír
œÉ

dt
(4.4.28)
In Eq. (2.4.3) we thus have k(t) = ‚àí((Œº ‚àír)/œÉ) and
dQ
dP = exp

‚àí
Œº ‚àír
œÉ

W P ‚àí1
2
Œº ‚àír
œÉ
2
t

(4.4.29)
See p. 114 of Musiela (1998). Substituting for dW p in Eq. (4.4.27) yields
dS‚àó
t = S‚àó
t {Œº ‚àír} dt ‚àíS‚àó
t œÉ
Œº ‚àír
œÉ

dt + S‚àóœÉ dW Q
which simpliÔ¨Åes to
dS‚àó
t = S‚àó
t œÉ dW Q
(4.4.30)
Equation (4.4.30) means that the process for S‚àó
t is a martingale under proba-
bility measure Q.
Replacing dW p in Eq. (4.4.26) with the value in Eq. (4.4.28) yields
dSt = ŒºSt dt + StœÉ dW P
= ŒºSt dt + StœÉ

dW Q ‚àí
Œº ‚àír
œÉ

dt

=

StŒº dt ‚àíStœÉ
Œº ‚àír
œÉ

dt + StœÉ dW Q
So in the risk neutral measure Q the dynamics of dS are
dSt = Str dt + StœÉ dW Q
(4.4.31)
Comparing Eq. (4.4.31) with the original Eq. (4.4.26) we see that changing from
the real-world measure to the risk neutral measure simply involves substituting
dW Q for dW P and r for Œº.

European options
69
We can now solve Eq. (4.4.31) by using the result given in Eq. (2.3.11). We
have
ST = S exp

ŒΩ(T ‚àít0) + œÉW Q
T ‚àít0

where S is the asset price at current time t0, and ŒΩ = r ‚àíœÉ 2/2.
The forward price with maturity T , denoted by S(t0, T ), is E[ST ]. From Ap-
pendix D.2 we have
S(t0, T ) = E[ST ] = S exp

r(T ‚àít0)

(4.4.32)
Using Eq. (2.3.9) the distribution of the asset price at time T is:
log
ST
S

‚àºN

ŒΩ(T ‚àít0), œÉ 2(T ‚àít0)

(4.4.33)
We want to obtain the current price of a vanilla European option with strike
price E which matures at future time T , and thus has a duration of œÑ = T ‚àít0.
The approach we will adopt here is to Ô¨Årst derive an expression for the value
of a European call option, and then use the put/call parity relationships of Sec-
tion 2.2 to obtain the value of the corresponding European put option.
Referring to (4.2.1) we have
Vt0 = Bt0EQ
HT
BT

= Bt0
BT
EQ[HT ]
(4.4.34)
Substituting Bt0 = 1, BT = exp(r(T ‚àít0)) = exp(rœÑ), and HT = max(ST ‚àíE, 0)
we have:
Vt0 =
1
exp(rœÑ)EQ
max(ST ‚àíE, 0)

(4.4.35)
and so denoting the value of the call option by c(S, E, œÑ) we obtain
c(S, E, œÑ) = exp(‚àírœÑ)EQ
max(ST ‚àíE, 0)

(4.4.36)
It can be seen from Eq. (4.4.36) that the value of the European call option is the
expected value of the option‚Äôs payoff at maturity, discounted to current time t
by the riskless interest rate r.
This means that the value of the call option can be written as
c(S, E, œÑ) = exp(‚àírœÑ)
 ‚àû
ST =E
f (ST )(ST ‚àíE) dST
(4.4.37)
where f (ST ) is the probability density function of ST .
Instead of integrating over ST we will evaluate (4.4.37) by using the variable
X = log(ST /S). From Eq. (4.4.33), we know that the probability density func-
tion of X is
f (X) =
1
œÉ‚àöœÑ
‚àö
2œÄ
exp

‚àí(X ‚àí(r ‚àíœÉ 2/2)œÑ)2
2œÉ 2œÑ

(4.4.38)

70
Computational Finance Using C and C#
and therefore the value of the option is
c(S, E, œÑ) = exp(‚àírœÑ)
 ‚àû
X=log(E/S)

S exp(X) ‚àíE

f (X) dX
(4.4.39)
where we have used ST = S exp(X). The lower limit in Eq. (4.4.39) correspond-
ing to ST = E in Eq. (4.4.37) is found by setting E = exp(X); this yields the
lower limit X = log(E/S).
The integral in Eq. (4.4.39) is evaluated by splitting it into the two parts:
c(S, E, œÑ) = IA ‚àíIB
(4.4.40)
where
IA = S exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp(X) exp

‚àí{X ‚àí(r ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
(4.4.41)
and
IB = E exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

E dX
(4.4.42)
To evaluate these integrals we will make use of the fact that the univariate cu-
mulative normal function N1(x) is:
N1(x) =
1
‚àö
2œÄ
 x
u=‚àí‚àû
exp

‚àíu2
2

du
By symmetry we have N1(‚àíx) = 1 ‚àíN1(x) and
1
‚àö
2œÄ
 ‚àû
x
exp

‚àíu2
2

du =
1
‚àö
2œÄ
 ‚àíx
‚àí‚àû
exp

‚àíu2
2

du = N1(‚àíx)
We will Ô¨Årst consider IB, which is the easier of the two integrals.
IB = E exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
If we let u = X‚àí(r‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
then dX = œÉ‚àöœÑ du. So
IB = E exp(‚àírœÑ)œÉ‚àöœÑ
œÉ
‚àö
2œÄ‚àöœÑ
 ‚àû
u=k2
exp

‚àíu2
2

du
where the lower integration limit is k2 = log(E/S)‚àí(r‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
.
We therefore have:
IB = E exp(‚àírœÑ)N1(‚àík2)
(4.4.43)
We will now consider the integral IA.
IA = S exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp(X) exp

‚àí{X ‚àí(r ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

dX

European options
71
Rearranging the integrand:
IA = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíœÉ 2/2)œÑ}2 ‚àí2œÉ 2œÑX
2œÉ 2œÑ

dX
(4.4.44)
Expanding the terms in the exponential:

X ‚àí

r ‚àíœÉ 2/2

œÑ
2 ‚àí2œÉ 2œÑX
= X2 ‚àí2

r ‚àíœÉ 2/2

œÑ

X +

r ‚àíœÉ 2/2

œÑ
2 ‚àí2œÉ 2œÑX
= X2 ‚àí2

r + œÉ 2/2

œÑ

X +

r ‚àíœÉ 2/2

œÑ
2
=

X ‚àí

r + œÉ 2/2

œÑ
2 +

r ‚àíœÉ 2/2

œÑ
2 ‚àí

r + œÉ 2/2

œÑ
2
Which results in:

X ‚àí

r ‚àíœÉ 2/2

œÑ
2 ‚àí2œÉ 2œÑX =

X ‚àí

r + œÉ 2/2

œÑ
2 ‚àí2œÉ 2rœÑ 2
(4.4.45)
Substituting Eq. (4.4.45) into the integrand of Eq. (4.4.44) we have:
exp(X) exp

‚àí{X ‚àí(r ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

= exp(rœÑ) exp

‚àí{X ‚àí(r + œÉ 2/2)œÑ}2
2œÉ 2œÑ

The integral IA can therefore be expressed as:
IA = S exp(rœÑ) exp(‚àírœÑ)
œÉœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp

‚àí{X ‚àí(r + œÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
If we let u = X‚àí(r+œÉ 2/2)œÑ
œÉ‚àöœÑ
then dX = œÉ‚àöœÑ du. So
IA =
SœÉ‚àöœÑ
œÉ
‚àö
2œÄ‚àöœÑ
 ‚àû
u=k1
exp

‚àíu2
2

du
where the lower limit of integration is k1 =
log(E/S)‚àí(r+œÉ 2/2)œÑ
œÉ‚àöœÑ
. We therefore
have:
IA = SN1(‚àík1)
(4.4.46)
Therefore the value of a European call is:
c(S, E, œÑ) = SN1(‚àík1) ‚àíE exp(‚àírœÑ)N1(‚àík2)
which gives the usual form of the Black‚ÄìScholes formula for a European
call as:
c(S, E, œÑ) = SN1(d1) ‚àíE exp(‚àírœÑ)N1(d2)
(4.4.47)

72
Computational Finance Using C and C#
where
d1 = log(S/E) + (r + œÉ 2/2)œÑ
œÉ‚àöœÑ
and
(4.4.48)
d2 = log(S/E) + (r ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
= d1 ‚àíœÉ‚àöœÑ
To gain some insight into the meaning of the above equation, we will rewrite it
in the following form:
c(S, E, œÑ) = exp(‚àírœÑ)

SN1(d1) exp(rœÑ) ‚àíEN1(d2)

(4.4.49)
The term N1(d2) is the probability that the option will be exercised in a risk-
neutral world, so that EN1(d2) is the strike price multiplied by the probability
that the strike price will be paid. The term SN1(d1) exp(rœÑ) is the expected value
of a variable, in a risk neutral world, that equals ST if ST > E and is otherwise
zero.
The corresponding formula for a put can be shown using put call parity (see
Section 4.3) to be:
p(S, E, œÑ) = E exp(‚àírœÑ)N1(‚àíd2) ‚àíSN1(‚àíd1)
(4.4.50)
or equivalently, using N1(‚àíx) = 1 ‚àíN1(x) we have
p(S, E, œÑ) = E exp(‚àírœÑ)

1 ‚àíN1(d2)

‚àíS

1 ‚àíN1(d1)

(4.4.51)
The inclusion of continuous dividends
The effect of dividends on the value of a European option can be dealt with
by assuming that the asset price is the sum of a riskless component involving
known dividends that will be paid during the life of the option, and a risky
(stochastic) component; see Hull (2003).
As continuous dividends q are paid, the stock price is reduced by the same
amount, and by the time the European option matures all the dividends will
have been paid, leaving only the risky component of the asset price.
From Eq. (4.4.26) we thus have:
dS = ŒºS dt ‚àíSq dt + œÉS dW P
(4.4.52)
dB = rB dt
where under probability measure P we know that dW P ‚àºN(0, dt).
As before (using Girsanov‚Äôs theorem), we choose probability measure Q so
that
dW p = dW Q ‚àí
Œº ‚àír
œÉ

dt
and thus under this measure the process for S is
dS = SŒº dt ‚àíSq dt ‚àí
Œº ‚àír
œÉ

dt + SœÉ dW Q,
where dW Q ‚àºN(0, dt)

European options
73
which results in
dS = S(r ‚àíq) dt + œÉS dW Q
where dW Q ‚àºN(0, dt)
(4.4.53)
Proceeding as before we obtain:
X ‚àºN

r ‚àíq ‚àíœÉ 2/2

œÑ, œÉ 2œÑ

where X = ST /S. The probability density function of X is now:
f (X) =
1
œÉ‚àöœÑ
‚àö
2œÄ
exp

‚àí(X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ)2
2œÉ 2œÑ

The value of a call option is thus:
c(S, E, œÑ) = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)

S exp(X) ‚àíE

√ó exp

‚àí(X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ)2
2œÉ 2œÑ

dX
(4.4.54)
with
IA = S exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp(X) exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
and
IB = E exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

E dX
So IB = E exp(‚àírœÑ)N1(‚àík2), where k2 = log(E/S)‚àí(r‚àíq‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
.
We will now consider the integral IA.
IA = S exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp(X) exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
Rearranging the integrand:
IA = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2 ‚àí2œÉ 2œÑX
2œÉ 2œÑ

dX
Expanding the exponential, we obtain:

X ‚àí

r ‚àíq ‚àíœÉ 2/2

œÑ
2 ‚àí2œÉ 2œÑX
= 2

X ‚àí

r ‚àíq + œÉ 2/2

œÑ
2 ‚àí2œÉ 2(r ‚àíq)œÑ 2
The integral IA can therefore be expressed as:
IA = S exp((r ‚àíq)œÑ) exp(‚àírœÑ)
œÉœÑ
‚àö
2œÄ
√ó
 ‚àû
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíq + œÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
which gives IA = S exp(‚àíqœÑ)N1(‚àík1) where k1 = log(E/S)‚àí(r‚àíq+œÉ 2/2)œÑ
œÉ‚àöœÑ
.

74
Computational Finance Using C and C#
The Black‚ÄìScholes formula for the value of a European call including contin-
uous dividends is thus:
c(S, E, œÑ) = S exp(‚àíqœÑ)N1(d1) ‚àíE exp(‚àírœÑ)N1(d2)
(4.4.55)
and the corresponding formula for a put can be shown (using put call parity) to
be:
p(S, E, œÑ) = ‚àíS exp(‚àíqœÑ)N1(‚àíd1) + E exp(‚àírœÑ)N1(‚àíd2)
(4.4.56)
or equivalently, using N1(‚àíx) = 1 ‚àíN1(x), we have
p(S, E, œÑ) = E exp(‚àírœÑ)

1 ‚àíN1(d2)

‚àíS exp(‚àíqœÑ)

1 ‚àíN1(d1)

(4.4.57)
where
d1 = log(S/E) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
,
d2 = log(S/E) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
Thus European put/call options with continuous dividends can be priced us-
ing Eqs. (4.4.47) and (4.4.50) but with S replaced by S exp(‚àíqœÑ).
These formulae can also be re-expressed in terms of the current equity for-
ward price with maturity T , S(t, T ), as follows:
ct = exp

‚àír(T ‚àít)

S(t, T )N1(d1) ‚àíEN1(d2)

(4.4.58)
pt = exp

‚àír(T ‚àít)

‚àíS(t, T )N1(‚àíd1) + EN1(‚àíd2)

(4.4.59)
where we have used the shortened notation pt and ct to denote the current
(time t) value of put and call options; the current equity forward price with
maturity T is
S(t, T ) = S exp

(r ‚àíq)(T ‚àít)

,
t ‚©ΩT,
and
d1 = log(S(t, T )/E) + (œÉ 2/2)œÑ
œÉ‚àö(T ‚àít)
,
d2 = log(S(t, T )/E) ‚àí(œÉ 2/2)(T ‚àít)
œÉ‚àö(T ‚àít)
The inclusion of discrete dividends
Here we consider n discrete cash dividends Di, i = 1, . . . , n, paid at times
ti, i
= 1, . . . , n, during the life of the option. In these circumstances the
Black‚ÄìScholes formula can be used to price European options, but with
the current asset value S reduced by the present value of the cash divi-
dends.
This means that instead of S we use the quantity SD which is computed as
SD = S ‚àí
n

i=1
Di exp(‚àírti)

European options
75
where r is the (in this case constant) riskless interest rate. The formulae for
European puts and calls is then
c(S, E, œÑ) = SDN1(d1) ‚àíE exp(‚àírœÑ)N1(d2)
(4.4.60)
p(S, E, œÑ) = E exp(‚àírœÑ)

1 ‚àíN1(d2)

‚àíSD

1 ‚àíN1(d1)

(4.4.61)
where
d1 = log(SD/E) + (r + œÉ 2/2)œÑ
œÉ‚àöœÑ
and
(4.4.62)
d2 = log(SD/E) + (r ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
= d1 ‚àíœÉ‚àöœÑ
The Greeks
Now that we have derived formulae to price European vanilla puts and calls
it is possible to work out their partial derivatives (hedge statistics). We will
now merely quote expressions for the Greeks (hedge statistics) for European
options. Here the subscript c refers to a European call, and the subscript p
refers to a European put. Complete derivations of these results can be found in
Appendix A.
Gamma:
Œìc = ‚àÇ2c
‚àÇS2 = Œìp = ‚àÇ2p
‚àÇS2 = exp(‚àíqœÑ) n(d1)
SœÉ‚àöœÑ
(4.4.63)
Delta:
Œîc = ‚àÇc
‚àÇS = exp(‚àíqœÑ)N1(d1)
(4.4.64)
Œîp = ‚àÇp
‚àÇS = exp(‚àíqœÑ)

N1(d1) ‚àí1

Theta:
Œòc = ‚àÇc
‚àÇt = q exp(‚àíqœÑ)SN1(d1) ‚àírE exp(‚àírœÑ)N1(d2)
‚àíSn(d1)œÉ exp(‚àíqœÑ)
2‚àöœÑ
(4.4.65)
Œòp = ‚àÇp
‚àÇt = ‚àíq exp(‚àíqœÑ)SN1(‚àíd1) + rE exp(‚àírœÑ)N1(‚àíd2)
‚àíSn(d1)œÉ exp(‚àíqœÑ)
2‚àöœÑ
Rho:
œÅc = ‚àÇc
‚àÇr = EœÑN1(d2),
œÅp = ‚àÇp
‚àÇr = ‚àíEœÑN1(‚àíd2)
(4.4.66)

76
Computational Finance Using C and C#
Vega:
Vc = ‚àÇc
‚àÇœÉ = Vp = ‚àÇp
‚àÇœÉ = S exp(‚àíqœÑ)n(d1)‚àöœÑ
(4.4.67)
where n(x) =
1
‚àö
2œÄ exp(‚àíx2/2)
We now present, in Code excerpt 4.1, a computer program to calculate the
Black‚ÄìScholes option value and Greeks given in Eqs. (4.4.63)‚Äì(4.4.67). The rou-
tine uses EPS = 1.0e-16 to identify whether the arguments are too small,
void black_scholes(double *value, double greeks[], double s0, double x,
double sigma, double t, double r, double q, long put, long *iflag)
{
/* Input parameters:
=================
s0 - the current price of the underlying asset
x - the strike price
sigma - the volatility
t - the time to maturity
r - the interest rate
q - the continuous dividend yield
put - if put is 0 then a call option, otherwise a put option
Output parameters:
==================
value - the value of the option
greeks[] - the hedge statistics output as follows: greeks[0] is gamma, greeks[1] is delta
greeks[2] is theta, greeks[3] is rho, and greeks[4] is vega
iflag - an error indicator
*/
double one=1.0,two=2.0,zero=0.0;
double eps,d1,d2,temp,temp1,temp2,pi,np;
if( (x < EPS) || (sigma < EPS) || (t < EPS) ) { /* Check if any of the the input
arguments are too small */
*iflag = 2;
return;
}
temp = log(s0/x);
d1 = temp+(r-q+(sigma*sigma/two))*t;
d1 = d1/(sigma*sqrt(t));
d2 = d1-sigma*sqrt(t);
/* evaluate the option price */
if (put==0)
*value = (s0*exp(-q*t)*cum_norm(d1)- x*exp(-r*t)*cum_norm(d2));
else
*value = (-s0*exp(-q*t)*cum_norm(-d1) + x*exp(-r*t)*cum_norm(-d2));
if (greeks) { /* then calculate the Greeks */
temp1 = -d1*d1/two;
d2 = d1-sigma*sqrt(t);
np = (one/sqrt(two*PI)) * exp(temp1);
if (put==0) { /* a call option */
greeks[1] = (cum_norm(d1))*exp(-q*t); /* delta */
greeks[2] = -s0*exp(-q*t)*np*sigma/(two*sqrt(t))
+ q*s0*cum_norm(d1)*exp(-q*t)- r*x*exp(-r*t)*cum_norm(d2); /* theta */
greeks[3] = x*t*exp(-r*t)*cum_norm(d2); /* rho */
}
else { /* a put option */
greeks[1] = (cum_norm(d1) - one)*exp(-q*t); /* delta */
greeks[2] = -s0*exp(-q*t)*np*sigma/(two*sqrt(t)) -
q*s0*cum_norm(-d1)*exp(-q*t) + r*x*exp(-r*t)*cum_norm(-d2); /* theta */
greeks[3] = -x*t*exp(-r*t)*cum_norm(-d2); /* rho */
}
greeks[0] = np*exp(-q*t)/(s0*sigma*sqrt(t)); /* gamma */
greeks[4] = s0*sqrt(t)*np*exp(-q*t); /* vega */
}
return;
}
Code excerpt 4.1 Function to compute the Black‚ÄìScholes value for European options.

European options
77
PI = 3.14159, and also the function cum_norm to compute the cumulative
normal distribution function.
It can be seen in Tables 4.1 and 4.2 that the values for gamma and vega are
the same for both puts and calls. We can also demonstrate that the option values
are consistent by using put call parity.
c(S, E, œÑ) + E exp(‚àírœÑ) = p(S, E, œÑ) + S exp(‚àíqœÑ)
For example, when œÑ = 1.0 we have c(S, E, œÑ) = 12.952 and P(S, E, T ) =
9.260. So: c(S, E, œÑ) + E exp(‚àírœÑ) = 12.952 + 100 √ó exp(‚àí0.1) = 103.436 and
p(S, E, œÑ) + S exp(‚àíqœÑ) = 9.260 + 100 √ó exp(‚àí0.06) = 103.436.
Table 4.1 European put option values and Greeks
œÑ
Value
Delta
Gamma
Theta
Vega
Rho
0.100
3.558
‚àí0.462
0.042
‚àí16.533
12.490
‚àí4.971
0.200
4.879
‚àí0.444
0.029
‚àí10.851
17.487
‚àí9.860
0.300
5.824
‚àí0.431
0.024
‚àí8.298
21.204
‚àí14.663
0.400
6.571
‚àí0.419
0.020
‚àí6.758
24.241
‚àí19.377
0.500
7.191
‚àí0.408
0.018
‚àí5.698
26.832
‚àí24.004
0.600
7.720
‚àí0.399
0.016
‚àí4.909
29.100
‚àí28.544
0.700
8.179
‚àí0.390
0.015
‚àí4.292
31.118
‚àí32.997
0.800
8.582
‚àí0.381
0.014
‚àí3.792
32.935
‚àí37.364
0.900
8.940
‚àí0.373
0.013
‚àí3.377
34.585
‚àí41.646
1.000
9.260
‚àí0.366
0.012
‚àí3.025
36.093
‚àí45.843
The parameters are: S = 100.0, E = 100.0, r = 0.10, œÉ = 0.30, q = 0.06.
Table 4.2 European call option values and Greeks
œÑ
Value
Delta
Gamma
Theta
Vega
Rho
0.100
3.955
0.532
0.042
‚àí20.469
12.490
4.929
0.200
5.667
0.544
0.029
‚àí14.724
17.487
9.744
0.300
6.996
0.552
0.024
‚àí12.109
21.204
14.451
0.400
8.121
0.558
0.020
‚àí10.508
24.241
19.054
0.500
9.113
0.562
0.018
‚àí9.387
26.832
23.557
0.600
10.007
0.566
0.016
‚àí8.539
29.100
27.962
0.700
10.826
0.569
0.015
‚àí7.863
31.118
32.271
0.800
11.584
0.572
0.014
‚àí7.305
32.935
36.485
0.900
12.290
0.574
0.013
‚àí6.832
34.585
40.608
1.000
12.952
0.576
0.012
‚àí6.422
36.093
44.640
The parameters are: S = 100.0, E = 100.0, r = 0.10, œÉ = 0.30, q = 0.06.

78
Computational Finance Using C and C#
4.4.4
Historical and implied volatility
Obtaining the best estimate of the volatility parameter, œÉ, in the Black‚ÄìScholes
formula is of crucial importance. There are many different approaches to volatil-
ity estimation. These include:
‚Ä¢ Historical estimation
‚Ä¢ Implied volatility
We will now consider both historical and implied volatility estimation.
Historical volatility
In this method we calculate the volatility using n + 1 historical asset prices,
Si, i = 0, . . . , n, and we assume that the asset prices are observed at the regular
time interval, dœÑ. Since the asset prices are assumed to follow GBM the volatil-
ity is computed as the standard deviation of the n continuously compounded
returns, ui, i = 1, . . . , n, where
Si = Si‚àí1 exp(ui)
or
ui = log
 Si
Si‚àí1

We already know (see Eq. (2.1.10)) that the expected standard deviation of the
asset returns over the time interval is œÉ
‚àö
dœÑ. This means that we obtain the
following expression for ÀÜœÉ, the estimated volatility:
ÀÜœÉ
‚àö
dœÑ =
'
(
(
)
1
n ‚àí1
n

i=1
(ui ‚àí¬Øu)2
(4.4.68)
or
ÀÜœÉ =
'
(
(
)
1
(n ‚àí1) dœÑ
n

i=1
(ui ‚àí¬Øu)2
(4.4.69)
It is accepted practice to express all times in years, and so the volatility is the
annualized standard deviation of the returns. There is also the issue of how to
account for non-trading days such as weekends and holidays. For example, let
us suppose that the history of assets prices Si, i = 0, . . . , n, was obtained by
recording the price on each trading day. One approach is to use dœÑ = 1/Ntd,
where Ntd is the number of trading days in a year. If we take Ntd = 250 then
Eq. (4.4.69) becomes
ÀÜœÉ =
'
(
(
)
250
(n ‚àí1)
n

i=1
(ui ‚àí¬Øu)2
(4.4.70)

European options
79
void hist_vol(double *sigma, double *err, double data[], long n, double dt, long *ifail)
{
/* Input parameters:
=================
data[]
- the data, which consists of n asset prices
n
- the number of data points
dt
- the (constant) time spacing between the data points (in years)
Output parameters:
==================
sigma
- the computed historical volatility
err
- the standard error in the volatility estimate sigma
iflag
- an error indicator
*/
#define DATA(I) data[(I)-1]
double mean=0.0,sum=0.0;
double temp,tn;
long i;
for(i = 2; i <= n; ++i)
mean = mean + log(DATA(i))-log(DATA(i-1));
mean = mean/(double)(n-1);
for(i = 2; i <= n; ++i) {
temp = log(DATA(i))-log(DATA(i-1));
sum = sum + (temp-mean)*(temp-mean);
}
sum = sum/(double)(n-2);
*sigma = sqrt(sum/dt);
tn = (double)(2*(n-1));
*err = *sigma/sqrt(tn);
return;
}
Code excerpt 4.2 Function to compute the historical volatility from asset data.
The estimated standard error in ÀÜœÉ is (see for example Hull (2003)) given by
ÀÜœÉstd = ÀÜœÉ

1
2(n ‚àí1)
(4.4.71)
A computer program to perform these calculations is given in Code excerpt 4.2.
Implied volatility
The implied volatility of a European option is the volatility that, when sub-
stituted into the Black‚ÄìScholes equation, yields the market value quoted for the
same option. In general the implied volatility will depend on both the time to ex-
piry of the option and also the ratio of the current asset price to the strike‚Äîthis
is known as the volatility smile. These values are usually stored in a multidi-
mensional implied volatility surface, and the volatility for pricing a given option
obtained via multidimensional interpolation.
The routine provided in Code excerpt 4.3 uses Newton‚Äôs method to calcu-
late the implied volatility for a European option from its market price. We
will now ilustrate this technique for a European call option with market value
opt_value. The implied volatility, œÉ, is then that value which satisÔ¨Åes:
K(œÉ) = c(S, E, œÑ, œÉ) ‚àíopt_value = 0
where c(S, E, œÑ, œÉ) represents the value of the European call and the other sym-
bols have their usual meaning.

80
Computational Finance Using C and C#
void implied_volatility(double value, double s0, double x, double sigma[],
double t, double r, double q, long put, long *iflag)
{
/* Input parameters:
=================
value
- the current value of the option
s0
- the current price of the underlying asset
x
- the strike price
sigma[]
- the input bounds on the volatility: sigma[0], the lower bound and, sigma[1],
the upper bound
t
- the time to maturity
r
- the interest rate
q
- the continuous dividend yield
put
- if put is 0 then a call option, otherwise a put option
Output parameters:
==================
sigma[]
- the element sigma[0] contains the estimated implied volatility
iflag
- an error indicator
*/
double zero=0.0;
double fx, sig1, sig2;
double val,tolx;
double temp,eps,epsqrt,temp1,v1;
long max_iters, i, ind, ir;
double greeks[5],c[20],sig,vega;
long done;
tolx = eps;
epsqrt = sqrt(EPS);
if(put == 0)
/* a call option */
temp1 = MAX(s0*exp(-q*t)-x*exp(-r*t),zero);
else
/* a put option */
temp1 = MAX(x*exp(-r*t)-s0*exp(-q*t),zero);
v1 = fabs(value-temp1);
if (v1 <= epsqrt) {
/* the volatility is too small */
*iflag = 3;
return;
}
*iflag = 0;
i = 0;
max_iters = 50;
done = 0;
sig = sigma[0];
/* initial estimate */
val = value;
while ((i < max_iters) && (!done)) {
/* Newton iteration */
black_scholes(&val,greeks,s0,x,sig,t,r,q,put,iflag); /* compute the Black-Scholes option
value, val
*/
vega = greeks[4];
/* and vega. */
sig1 = sig - ((val - value)/vega);
/* compute the new estimate of sigma
using Newton‚Äôs method */
if (tolx > fabs((sig1 - sig)/sig1)) {
/* check whether the specified
accuracy has been reached */
done = 1;
}
sig = sig1;
/* up date sigma */
++i;
}
sigma[0] = sig1;
/* return the estimate for sigma */
return;
}
Code excerpt 4.3 Function to compute the implied volatility of European options.
From Newton‚Äôs method we have:
œÉi+1 = œÉi ‚àíF(œÉi)
F ‚Ä≤(œÉi)
where
F ‚Ä≤(œÉi) = ‚àÇF
‚àÇœÉ = ‚àÇc(S, E, œÑ, œÉ)
‚àÇœÉ
= Vc

European options
81
Therefore the iterative procedure is
œÉi+1 = œÉi ‚àíc(S, E, œÑ, œÉ) ‚àíopt_value
Vc
where œÉ0 is the initial estimate, and œÉi+1 is the improved estimate of the implied
volatility based on the ith estimate œÉi. Termination of this iteration occurs when
ABS(œÉi+1 ‚àíœÉi) < tol, for a speciÔ¨Åed tolerance, tol.
It can be seen that as œÉ ‚Üí0, d1 ‚Üí‚àû, d2 ‚Üí‚àûand, from Eq. (4.4.67), we
have Vc ‚Üí0. Under these circumstances Newton‚Äôs method fails.
The same procedure can be used to compute the implied volatility for a Eu-
ropean put, in this case we just replace c(S, E, œÑ, œÉ) by p(S, E, œÑ, œÉ), the value
of a European put; from Eq. (4.4.67) Vc = Vp.
If the implied volatility of American options is required, the procedure is ex-
actly the same. However, instead of using the Black‚ÄìScholes formula to compute
both the option value and vega we use a binomial lattice to do this. The use of
binomial lattices to obtain option prices and the Greeks is described in Chap-
ter 5.
Code excerpt 4.4 provides a simple test program which illustrates the use of
the function implied_volatility; the results are presented in Table 4.3.
double X,
value, S, sigma[2], sigmat, T, r, q;
long i, ifail, put;
ifail
= 0;
S
= 10.0;
X
= 10.5;
r
= 0.1;
sigmat = 0.1;
q
= 0.04;
put
= 0;
printf ("
Time
option value
implied
volatility
(Error)\n");
for(i = 1;i < 6; ++i) {
T = (double)i*0.5;
black_scholes(&value,NULL,S,X,sigmat,T,r,q,put,&flag);
sigma[0] = 0.05;
sigma[1] = 1.0;
implied_volatility(value,S,X,sigma,T,r,q,put,&flag);
printf("%8.4f
%15.4f
%15.4f (%8.4e) \n",T,value,sigma[0],
fabs(sigmat-sigma[0]));
sigmat = sigmat + 0.1;
}
Code excerpt 4.4 Simple test program for function implied_volatility.
Table 4.3 Calculated option values and implied volatilities from Code excerpt 4.4
Time (years)
Option value
True œÉ
Error in estimated œÉ
0.5
0.1959
0.1
2.7756 √ó 10‚àí16
1.0
0.8158
0.2
2.2204 √ó 10‚àí16
1.5
1.5435
0.3
3.8858 √ó 10‚àí16
2.0
2.3177
0.4
5.5511 √ó 10‚àí17
2.5
3.1033
0.5
1.1102 √ó 10‚àí16

82
Computational Finance Using C and C#
4.4.5
Pricing options with Microsoft Excel
In this section we show how the Visual Basic within Excel can be used to create
powerful derivative pricing applications based on the Black‚ÄìScholes formula.
We will explain how Excel‚Äôs Visual Basic can be used to create an application
that prices a selection of simple European put and call options at the press of a
button.
In Section 4.4.3 we derived the Black‚ÄìScholes formula:
c(S, E, œÑ) = SN1(d1) ‚àíe‚àírœÑEN1(d2)
and
p(S, E, œÑ) = ‚àíSN1(‚àíd1) + e‚àírœÑEN1(‚àíd2)
where
d1 = log(S/E)(r ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
= d1 ‚àíœÉ‚àöœÑ
where S is the current value of the asset and œÉ is the volatility of the asset, and
N1(x) =
1
‚àö
2œÄ
 x
‚àí‚àûe‚àíx2/2 dx.
The univariate cumulative standard normal distribution, N1(x), can be eval-
uated in Excel by using its built-in function NORMDIST. The deÔ¨Ånition of this
function is as follows:
NORMDIST(x,mean,standard_dev,cumulative)
This function returns the normal cumulative distribution for the speciÔ¨Åed mean
and standard deviation.
Function parameters:
x: is the value for which you want the distribution.
mean: is the arithmetic mean of the distribution.
standard_dev: is the standard deviation of the distribution.
cumulative: is a logical value that determines the form of the function. If
cumulative is TRUE, NORMDIST returns the cumulative distri-
bution function; if FALSE, it returns the probability density
function.
If mean = 0 and standard_dev = 1, NORMDIST returns the standard
normal distribution.
This function can be used to create a Visual Basic function to calculate Euro-
pean option values within Excel, see Code excerpt 4.5.
Once the function has been deÔ¨Åned, it can be accessed interactively using the
Paste Function facility within Excel as shown in Fig. 4.1.
The function bs_opt can also be incorporated into other Visual Basic
code within Excel. Code excerpt 4.6 deÔ¨Ånes the Visual Basic subroutine
MANY_EUROPEANS_Click().

European options
83
Function bs_opt(S0 As Double, _
ByVal X As Double, sigma As Double, T As Double, _
r As Double, q As Double, ByVal putcall As Long) As Double
‚Äô Visual Basic Routine to calculate the value of
‚Äô either a European Put or European Call option.
‚Äô Author: George Levy
Dim temp As Double
Dim d1 As Double
Dim d2 As Double
Dim SQT As Double
Dim value As Double
temp = Log(S0 / X)
d1 = temp + (r - q + (sigma * sigma / 2#)) * T
SQT = Sqr(T)
d1 = d1 / (sigma * SQT)
d2 = d1 - sigma * SQT
If (putcall = 0) Then ‚Äô a call option
value = S0 * Exp(-q * T) * WorksheetFunction.NormDist(d1, 0#, 1#, True) _
- WorksheetFunction.NormDist(d2, 0#, 1#, True) * X * Exp(-r * T)
Else ‚Äô a put option
value = -S0 * Exp(-q * T) * WorksheetFunction.NormDist(-d1, 0#, 1#, True) + _
X * WorksheetFunction.NormDist(-d2, 0#, 1#, True) * Exp(-r * T)
End If
bs_opt = value
End Function
Code excerpt 4.5 Visual Basic code to price European options using the Black‚ÄìScholes
formula.
Figure 4.1 Using the function bs_opt interactively within Excel. Here a call option is
processed with the following parameters: S = 10.0, X = 9.0, q = 0.0, T = 1.5, r = 0.1,
and œÉ = 0.2.

84
Computational Finance Using C and C#
Private Sub MANY_EUROPEANS_Click()
Dim i As Long
Dim putcall As Long
Dim S0 As Double
Dim q As Double
Dim sigma As Double
Dim T As Double
Dim r As Double
q = 0#
T = 1.5
r = 0.1
sigma = 0.2
For i = 1 To 22
S0 = Sheet1.Cells(i + 1, 1).value
X = Sheet1.Cells(i + 1, 2).value
putcall = Sheet1.Cells(i + 1, 3).value
Sheet1.Cells(i + 1, 4).value = bs_opt(S0, X, sigma, T, r, q, putcall)
Next i
End Sub
Code excerpt 4.6 Visual Basic code that uses the function bs_opt.
Figure 4.2 Excel worksheet before calculation of the European option values.
When the button labelled ‚ÄúCALCULATE OPTIONS‚Äù is clicked, the values
of 22 European options will be calculated using the data in columns 1‚Äì3 on
worksheet 1, see Figs. 4.2 and 4.3.

European options
85
Figure 4.3 Excel worksheet after calculation of the European option values.
The cumulative standard normal distribution can also be used to provide an-
alytic solutions for a range of other exotic options such as: Barrier options,
Exchange options, Lookback options, Binary options, etc.
4.5
Barrier options
4.5.1
Introduction
Barrier options are derivatives where the payoff depends on whether the asset
price reaches a given barrier level, B. Knockout options become worthless (cease
to exist) if the asset price reaches the barrier, whereas knockin options come into
existence when the asset price hits the barrier. We will consider the following
single asset European barrier options:
‚Ä¢ Down and out call: A knockout vanilla call option, value cdo, which ceases
to exist when the asset price reaches or goes below the barrier level.
‚Ä¢ Up and out call: A knockout vanilla call option, value cuo, which ceases to
exist when the asset price reaches, or goes above the barrier level.
‚Ä¢ Down and in call: A knockin vanilla call option, value cdi, which comes
into existence when the asset prices reaches or goes below the barrier
level.

86
Computational Finance Using C and C#
‚Ä¢ Up and in call: A knockin vanilla call option, value cui, which comes
into existence when the asset price reaches or goes above the barrier
level.
The following expressions must be true:
c = cuo + cui
(4.5.1)
c = cdo + cdi
(4.5.2)
where c is the value of a vanilla call option. We thus need only derive expressions
for both the knockout options, and then use the above equations to calculate
the value of the corresponding knockin options.
The notation that we will use is as follows: The symbol t represents the cur-
rent time, T represents the time at which the option matures, and œÑ = T ‚àít,
the duration of the option. The symbol s, with constraint t ‚©Ωs ‚©ΩT , is any
intermediate time during which the option is alive.
4.5.2
Analytic pricing of down and out call options
If we consider Brownian motion (with zero drift) Xs
‚àºN(0, (s ‚àít)œÉ 2),
t ‚©Ωs ‚©Ω
T , which starts at Xt = 0 and, after time œÑ = T ‚àít, ends at the
point XT = X then (for example, see Freedman, 1983) the probability density
function for this motion not to exceed the value X = b (where b > 0) during
time œÑ is given by:
f

b ‚©æXmax
s
, X

= Œ©

2
œÄ exp
2b(X ‚àíb)
œÉ 2œÑ

exp

‚àíX2
2œÉ 2œÑ

(4.5.3)
where for convenience we have used Œ© = (2b ‚àíX)/(œÉ 3œÑ 3/2), and Xmax
s
=
max(Xs, t ‚©Ωs ‚©ΩT ). Since Xs is Brownian motion without drift and volatility œÉ,
then ‚àíXs is identical Brownian motion. Therefore by substituting X ‚Üí‚àíX, and
b ‚Üí‚àíb in the above equation we obtain:
f

b ‚©ΩXmin
s
, X

= ‚àíŒ©

2
œÄ exp
2b(X ‚àíb)
œÉ 2œÑ

exp

‚àíX2
2œÉ 2œÑ

(4.5.4)
where we have used Xmin
s
= min(Xs, t ‚©Ωs ‚©ΩT ). Equation (4.5.4) is the prob-
ability density function of ‚àíXs staying above the value X = b, where b < 0.
These results can be generalized to include drift (Musiela and Rutkowski, 1998,
p. 212), so that Xs ‚àºN((r ‚àíq ‚àíœÉ 2/2)(s ‚àít), œÉ(s ‚àít)), for t ‚©Ωs ‚©ΩT . We now
have the following results:
f

b ‚©æXmax
s
, X

= Œ©

2
œÄ exp
2b(X ‚àíb)
œÉ 2œÑ

exp

‚àí(X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ)2
2œÉ 2œÑ

(4.5.5)

European options
87
f

b ‚©ΩXmin
s
, X

= ‚àíŒ©

2
œÄ exp
2b(X ‚àíb)
œÉ 2œÑ

exp

‚àí(X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ)2
2œÉ 2œÑ

(4.5.6)
where r is the risk free rate and q is the continuous dividend yield. A European
down and out barrier option with maturity œÑ and a barrier at X = B will cease
to exist (become worthless) if at any time Xs ‚©ΩB, for t ‚©Ωs ‚©ΩT . The probability
density function that the barrier option will continue to exist at time T if the
end point is X is therefore:
f (X > B) = ‚àí

2
œÄ
 b=X
B=S exp(b)
Œ© exp
2b(X ‚àíb)
œÉ 2œÑ

√ó exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

db
(4.5.7)
or
f (X > B) = ‚àí

2
œÄ exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó
 b=X
b=log(B/S)
Œ© exp
2b(X ‚àíb)
œÉ 2œÑ

db
(4.5.8)
where we have integrated over all possible values of b (i.e., B < b < X) that
keep the option alive. Recalling that:
‚àí
 b=X
b=log(B/S)
Œ© exp
2b(X ‚àíb)
œÉ 2œÑ

db
=
 b=X
b=log(B/S)
(X ‚àí2b)
œÉ 3œÑ 3/2
exp
2b(X ‚àíb)
œÉ 2œÑ

db
and noting that:
‚àÇ
‚àÇb exp
2b(X ‚àíb)
œÉ 2œÑ

= 2(X ‚àí2b)
œÉ 2œÑ
exp
2b(X ‚àíb)
œÉ 2œÑ

we have:
 b=X
b=log(B/S)
2(X ‚àí2b)
œÉ 2œÑ
exp
2b(X ‚àíb)
œÉ 2œÑ

db
= exp
2b(X ‚àíb)
œÉ 2œÑ
b=X
b=log(B/S)
= 1 ‚àíexp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

So we have:
f (X > B) =
1
œÉ‚àöœÑ
‚àö
2œÄ
exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó

1 ‚àíexp
2 log(B/S)(X ‚àílog(B/S)
œÉ 2œÑ


88
Computational Finance Using C and C#
The value cdo of a European down and out call option with strike E, satisfying
E > B, is given by:
cdo = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)

S exp(X) ‚àíE

f (X > B) dX
(4.5.9)
This integral is evaluated in Appendix B.1, and the value of the down and out
call option cdo is:
cdo = c ‚àícdi
(4.5.10)
where
c = S exp(‚àíqœÑ)N1(d1) ‚àíE exp(‚àírœÑ)N1(d2)
cdi = S exp(‚àíqœÑ)N1(d4)
B
S
 2(r‚àíq)
œÉ2
+1
‚àíE exp(‚àírœÑ)N1(d3)
B
S
 2(r‚àíq)
œÉ2
‚àí1
d1 = log(S/E) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
d2 = log(S/E) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
d3 = log(B2/SE) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
and
d4 = log(B2/ES) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
In Code excerpt 4.7 we provide the function bs_opt_barrier_downout_
call which uses Eq. (4.5.10) to price a down and out European call option.
This routine will be used in Chapter 5 to measure the accuracy achieved by
using various Ô¨Ånite-difference grid techniques to solve the Black‚ÄìScholes equa-
tion.
4.5.3
Analytic pricing of up and out call options
Here we will obtain an expression for an up and out European call option with
continuous dividend yield q, in a similar manner to that used in Section 4.5.2 for
the down and out European call option. A European up and out barrier option
with maturity œÑ and a barrier at X = B will cease to exist (become worthless)
if at any time Xs ‚©æB, for t ‚©Ωs ‚©ΩT . The probability density function that the
barrier option will continue to exist at time T if the end point is X is therefore:
f (X < B) =

2
œÄ
 B=S exp(b)
b=X
Œ© exp
2b(X ‚àíb)
œÉ 2t

√ó exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

db
(4.5.11)

European options
89
void bs_opt_barrier_downout_call(double *value, double barrier_level,
double s0, double x, double sigma, double t, double r,
double q, long *iflag)
{
/* Input parameters:
=================
barrier_level
- the level of the barrier
s0
- the current price of the underlying asset
x
- the strike price
sigma
- the volatility
t
- the time to maturity
r
- the risk free interest rate
q
- the dividend yield
Output parameters:
==================
value
- the value of the option
iflag
- an error indicator
*/
double one=1.0,two=2.0,zero=0.0;
double temp,temp1,temp2,a,b,d1,d2,d3,d4,d5,d6,d7,d8;
double fac;
if(x < EPS) { /* then strike price (X) is too small */
*iflag = 2;
return;
}
if (sigma < EPS) { /* then volatility (sigma) is too small */
*iflag = 3;
return;
}
if (t < EPS) { /* then time to expiry (t) is too small */
*ifail = 3;
return;
}
if (barrier_level <= 0) {
/* barrier level must be greater than zero */
*iflag = 4;
}
if (s0 <= barrier_level) { /* option has already been knocked out */
*value = 0.0;
return;
}
fac = sigma*sqrt(t);
temp1 = -one+(two*(r-q)/(sigma*sigma));
temp2 = barrier_level/s0;
a = pow(temp2,temp1);
temp1 = one+(two*(r-q)/(sigma*sigma));
b = pow(temp2,temp1);
if (x > barrier_level) {
/* strike > barrier_level */
d1 = (log(s0/x)+(r-q+0.5*sigma*sigma)*t)/fac;
d2 = (log(s0/x)+(r-q-0.5*sigma*sigma)*t)/fac;
temp = (s0*x)/(barrier_level*barrier_level);
d7 = (log(temp)-(r-q-0.5*sigma*sigma)*t)/fac;
d8 = (log(temp)-(r-q+0.5*sigma*sigma)*t)/fac;
temp1 = s0*exp(-q*t)*(cum_norm(d1)-b*(one-cum_norm(d8)));
temp2 = x*exp(-r*t)*(cum_norm(d2)-a*(one-cum_norm(d7)));
*value = temp1-temp2;
}
else { /* strike <= barrier_level */
d3 = (log(s0/barrier_level)+(r-q-0.5*sigma*sigma)*t)/fac;
d6 = (log(s0/barrier_level)-(r-q-0.5*sigma*sigma)*t)/fac;
d4 = (log(s0/barrier_level)+(r-q+0.5*sigma*sigma)*t)/fac;
d5 = (log(s0/barrier_level)-(r-q+0.5*sigma*sigma)*t)/fac;
temp1 = s0*exp(-q*t)*(cum_norm(d3)-b*(one-cum_norm(d6)));
temp2 = x*exp(-r*t)*(cum_norm(d4)-a*(one-cum_norm(d5)));
*value = temp1-temp2;
}
return;
}
Code excerpt 4.7 Function to compute the value for European down and out call op-
tions.

90
Computational Finance Using C and C#
or
f (X < B) =

2
œÄ exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó
 b=log(B/S)
b=X
Œ© exp
2b(X ‚àíb)
œÉ 2œÑ

db
(4.5.12)
where, as in Section 4.5.2, we have used Œ© = (2b‚àíX)
œÉ 3œÑ 3/2 and have integrated over
all possible values of b (i.e., B > b > X) that keep the option alive. Recalling
that:
 b=log(B/S)
b=X
Œ© exp
2b(X ‚àíb)
œÉ 2œÑ

db
=
 b=log(B/S)
b=X
(2b ‚àíX)
œÉ 3œÑ 3/2
exp
2b(X ‚àíb)
œÉ 2œÑ

db
and noting:
‚àí‚àÇ
‚àÇb exp
2b(X ‚àíb)
œÉ 2œÑ

= 2(X ‚àí2b)
œÉ 2œÑ
exp
2b(X ‚àíb)
œÉ 2œÑ

(4.5.13)
we have:
 b=log(B/S)
b=X
2(2b ‚àíX)
œÉ 2œÑ
exp
2b(X ‚àíb)
œÉ 2œÑ

db
= ‚àíexp
2b(X ‚àíb)
œÉ 2œÑ
b=log(B/S)
b=X
=

1 ‚àíexp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

Therefore:
f (X < B) =
1
œÉ‚àöœÑ
‚àö
2œÄ

2
œÄ exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó

1 ‚àíexp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

(4.5.14)
We will now derive the formula for an up and out call option when E < B.
In fact if E > B then the option is worthless, since at the current time t the
call option‚Äôs payout, max(St ‚àíE, 0) = 0, and if St > E then the option will be
knocked out.
cuo = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)

S exp(X) ‚àíE

f (X < B) dX
(4.5.15)
Taking into account the fact the option becomes worthless when S exp(X) > B,
(i.e., X > log(B/S)) we have:
cuo = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 log(B/S)
X=log(E/S)

S exp(X) ‚àíE

f (X < B) dX
(4.5.16)

European options
91
This integral is evaluated in Appendix B.2, and the value of the down and out
call option cuo is:
cuo = c ‚àícui
where c is the value of a vanilla call and cui, the value of an up and in call, is
given by:
cui = S exp(‚àíqœÑ)N1(d2) ‚àíE exp(‚àírœÑ)N1(d4)
‚àíE exp(‚àírœÑ)

N1(d5) ‚àíN1(d6)
B
S
 2(r‚àíq)
œÉ2
‚àí1
+ S exp(‚àírœÑ)

N1(d7) ‚àíN1(d8)
B
S
 2(r‚àíq)
œÉ2
+1
(4.5.17)
and
d1 = log(S/E) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
d2 = log(S/B) + (r ‚àíq + œÉ 2/2)œÑ
‚àöœÑ
d3 = log(S/E) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
d4 = log(S/B) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
d5 = log(B2/ES) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
d6 = log(B/S) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
d7 = log(B2/ES) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
d8 = log(B/S) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
4.5.4
Monte Carlo pricing of down and out options
In this section we show how Monte Carlo simulation can be used to price
down and out barrier options. We will describe both a basic Monte Carlo ap-
proach and also a Brownian bridge method which gives more accurate results
(see Chapter 8).
The asset price, S, will be assumed to be GBM, so the logarithm of the asset
price X follows the Brownian process:
X = ŒΩt + œÉWt
(4.5.18)
where ŒΩ is the drift and œÉ is the volatility.

92
Computational Finance Using C and C#
If the barrier level is B then the option will be knocked out when S ‚©ΩB,
or equivalently log(S) ‚©Ωlog(B). This will be expressed as X ‚©Ωb, where b =
log(B).
The basic approach to simulating the down and out option is to Ô¨Årst de-
cide how many Scenarios to use and also how many TimeSteps there
are to be in each scenario. The size of each time step is then time_step =
TimeToExpiry/TimeSteps. For each scenario the path of Xt is advanced
in time from t to t + t using Eq. (4.5.18), with dt =
time_step and a
value for Wt output from a Gaussian random number generator. Path con-
struction is stopped if either the option expiry time is reached or if the option
is knocked out‚Äîi.e., X ‚©Ωb. When the option is knocked out before expiry
the payoff for that scenario is zero. We will denote the option value obtained
from the ith scenario by DOi where i = 1, . . . , Scenarios. The option value
is the average value of DOi over all scenarios; for more details see Code ex-
cerpt 4.8.
One problem with this approach to simulation is that it does not take into
account the possibility that XœÑ ‚©Ωb, t < œÑ < t + t, even though Xt > b and
Xt+t > b. In these circumstances the option should be treated as knocked out,
since X hit (or crossed) the barrier b at time œÑ, but then increased to the value
Xt+t > b at time t + t.
We will now discuss how the Brownian bridge method deals with this situa-
tion.
Let us take two consecutive time points t1 and t2 = t1 + t, and assume that
both Xt1, and Xt2 are above the (logarithmic) barrier level b. We want to Ô¨Ånd the
probability that in the time interval [t1, t2], the asset price went lower than B,
and use this to get more accurate values for down and out options. The required
barrier crossing probability is thus:
P

mX
t1,t2 ‚©Ωb|{Xt2, Xt1}

where mX
t1,t2 denotes the minimum of X over the time interval [t1, t2].
The probability density of Xt2 conditional on Xt1 is
p(Xt2|Xt1) =
1
œÉ
‚àö
2œÄt
exp

‚àí(Xt2 ‚àíXt1 ‚àíŒΩt)2
2œÉ 2t

where t = t2 ‚àít1.
From Bayes law we know that:
P

mX
t1,t2 ‚©Ωb|{Xt2, Xt1}

= p({mX ‚©Ωb, Xt2}|Xt1)
p(Xt2|Xt1)
We show in Appendix I that
p

mX
t1,t2 ‚©Ωb, Xt2

|Xt1

=
1
œÉ
‚àö
2œÄt
exp
2ŒΩ(b ‚àíXt1)
œÉ 2

exp

‚àí(Xt2 + Xt1 ‚àí2b ‚àíŒΩt)2
2œÉ 2t


European options
93
so
P

mX
t1,t2 ‚©Ωb|{Xt2, Xt1}

= exp
2ŒΩ(b ‚àíXt1)
œÉ 2

√ó exp

‚àí‚àí(Xt2 + Xt1 ‚àí2b ‚àíŒΩt)2 + (Xt2 ‚àíXt1 ‚àíŒΩt)2
2œÉ 2t

We will now use some algebra to simplify this expression.
P

mX
t1,t2 ‚©Ωb|{Xt2, Xt1}

= exp
4ŒΩt(b ‚àíXt1) ‚àí(Xt2 + Xt1 ‚àí2b ‚àíŒΩt)2 + (Xt2 ‚àíXt1 ‚àíŒΩt)2
2œÉ 2t

= exp

4ŒΩt(b ‚àíXt1) ‚àí

(Xt2 ‚àíXt1 ‚àíŒΩt) ‚àí2(b ‚àíXt1)
2
+ (Xt2 ‚àíXt1 ‚àíŒΩt)2
/

2œÉ 2t

= exp
4ŒΩt(b ‚àíXt1) + 4(b ‚àíXt1)(Xt2 ‚àíXt1 ‚àíŒΩt) + 4(b ‚àíXt1)2
2œÉ 2t

= exp

‚àí2(b ‚àíXt1)(b ‚àíXt2)
œÉ 2t

which Ô¨Ånally yields
P

mlog(S)
t1,t2
‚©Ωb|

log(St2), log(St1)

= exp

‚àí2(log(B) ‚àílog(St1))(log(B) ‚àílog(St2))
œÉ 2t

(4.5.19)
Equation (4.5.19) gives the probability of the option having been knocked out
between times t1 and t2 even though the asset prices St1 and St2 are greater
than B. The probability that the option hasn‚Äôt been knocked out between times
t1 and t2 is therefore
P

mlog(S)
t1,t2
> b|

log(St2), log(St1)

= 1 ‚àíexp

‚àí2(log(B) ‚àílog(St1))(log(B) ‚àílog(St2))
œÉ 2t

(4.5.20)
This means that for the (complete) ith scenario path, of n time steps, the prob-
ability that mlog(S) > b is
BBi
c =
n‚àí1

j=0

1 ‚àíexp

‚àí
2(log(B) ‚àílog(Si
tj ))(log(B) ‚àílog(Si
tj+1))
œÉ 2t

where Si
tj is the ith scenario asset price at time tj.
The basic Monte Carlo ith scenario option value DOi can therefore be ad-
justed as follows
DO‚àó
i = DOi BBi
c

94
Computational Finance Using C and C#
and the new Monte Carlo estimate DO‚àóis
DO‚àó=

Scenarios
i=1
DO‚àó
i
Scenarios
where more details can be found in Code excerpt 4.8.
private double MonteCarloSim(bool is_put)
{
int seed = 111;
double[] asset_path = new double[fTimeSteps];
double time_step = fTimeToExpiry / fTimeSteps;
double sqrt_time_step = System.Math.Sqrt(time_step);
double disc = System.Math.Exp(-fRiskFreeRate * fTimeToExpiry);
set_seed(seed);
double opt_val = 0.0;
bool not_out = true;
int k = 0;
double STN = 0.0;
double mean = (fRiskFreeRate - fDividendYield - fSigma1 * fSigma1 * 0.5) * time_step;
double std = System.Math.Sqrt(fSigma1 * fSigma1 * time_step);
double z;
double sum_opt_vals = 0.0;
for (int i = 0; i < fNumberScenarios; ++i)
{
// generate the asset path
double ST1 = fS1;
not_out = true;
k = 0;
while (not_out && k < fTimeSteps)
{
z = RndNorm(mean, std);
STN = ST1 * System.Math.Exp(z);
if (STN < fBarrierLevel) not_out = false;
ST1 = STN;
asset_path[k] = STN;
++k;
}
if (is_put)
{
opt_val = System.Math.Max(fStrike - STN, 0.0);
}
else
{
opt_val = System.Math.Max(STN - fStrike, 0.0);
}
if (not_out)
{ // only has value if asset value is above the barrier_level
// compute the probability that the asset remained above the barrier
if (UseBrownianBridge)
{
double total_probability_above = 1.0, pr;
double sigma_2 = fSigma1 * fSigma1;
double log_barrier_level = System.Math.Log(fBarrierLevel);
double fac;
for (int jj = 0; jj < fTimeSteps - 1; ++jj)
{
double log_S_i = System.Math.Log(asset_path[jj]);
double log_S_i1 = System.Math.Log(asset_path[jj + 1]);
fac = 2.0 * (log_barrier_level - log_S_i)
* (log_barrier_level - log_S_i1) / (sigma_2 * time_step);
pr = (1.0 - System.Math.Exp(-fac)); // probability of staying above the
barrier between i and i+1
total_probability_above *= pr;
Code excerpt 4.8 An example of using the Brownian bridge barrier crossing probability
to enhance the pricing of a European down and out option.

European options
95
}
sum_opt_vals += total_probability_above * opt_val * disc;
}
else
{ // don‚Äôt use the Brownian Bridge
sum_opt_vals += opt_val * disc;
}
}
}
double temp = sum_opt_vals / (double)fNumberScenarios;
return temp;
}
Code excerpt 4.8 (Continued).

blank
left
intentionally
page
This

5 Single asset American options
5.1
Introduction
In Chapter 4 we discussed single asset European options and the analytic for-
mulae that can be used to price them. Here we will consider the valuation of
single asset American-style options using both numeric methods and analytic
formulae; in addition we will discuss the use of numerical techniques to value
certain European options. The coverage in this chapter is as follows:
‚Ä¢ Analytic approximation techniques for the valuation of American options
‚Ä¢ Binomial lattice techniques used for the valuation of American and European
options
‚Ä¢ The valuation of American and European vanilla and barrier options using
Ô¨Ånite-difference grids
‚Ä¢ The valuation of American options via Monte Carlo simulation.
It should be mentioned that although much of the discussion here concerns the
valuation of vanilla European and American puts and calls, the techniques used
can be modiÔ¨Åed without much difÔ¨Åculty to include more exotic options with
customized payoffs and early exercise features.
5.2
Approximations for vanilla American options
5.2.1
American call options with cash dividends
In this section we will consider the valuation of vanilla American call options
with cash dividends and discuss the methods of Roll, Geske, Whaley and Black.
We will Ô¨Årst consider the Roll‚ÄìGeske‚ÄìWhaley method.
The Roll‚ÄìGeske‚ÄìWhaley approximation
This method uses the work of Roll (1977), Geske (1979), and Whaley (1981).
Let S be the current (time t) price of an asset which pays a single cash dividend
D1 at time t1. At the ex-dividend date, t1, there will be a decrease in the asset‚Äôs
value from St1 to St1 ‚àíD1. Also the current asset price net of escrowed dividends
is:
SD = S ‚àíD1 exp

‚àír(t1 ‚àít)

(5.2.1)

98
Computational Finance Using C and C#
where r is the riskless interest rate.
Now consider an American call option, with strike price E and expiry time T ,
which is taken out on this asset. At t1 there will be a given ex-dividend asset
price, S‚àó, above which the option will be exercised early. This value can be
found by solving the following equation:
c

S‚àó, E, œÑ1

= S‚àó+ D1 ‚àíE
(5.2.2)
where c(S‚àó, E, œÑ1) is the Black‚ÄìScholes value of a European call option with
strike price E and maturity œÑ1 = T ‚àít1, on an asset with current value S‚àóat
time t1. If just prior to the ex-dividend date St1 > S‚àóthen the American option
will be exercised and realize a cash payoff of St1 + D1 ‚àíE. On the other hand
if St1 ‚©ΩS‚àóthen the option is worth more unexercised and it will be held until
option maturity at time T .
We can rewrite Eq. (5.2.2) so that S‚àóis the root of the following equation:
K

S‚àó
= c

S‚àó, E, œÑ1

‚àíS‚àó‚àíD1 + E = 0
(5.2.3)
where K(S‚àó) denotes the function in the single variable S‚àó.
A well-known technique for solving Eq. (5.2.3) is Newton‚Äôs method, which
in this case takes the form:
S‚àó
i+1 = S‚àó
i ‚àíK(S‚àó
i )
K‚Ä≤(Si)‚àó
(5.2.4)
where S‚àó
i is the ith approximation to S‚àóand S‚àó
i+1 is the improved (i + 1)th
approximation.
If we now consider the terms in Eq. (5.2.4) we have from Eqs. (5.2.2) and
(5.2.3) that
K

S‚àó
i

= c

S‚àó
i , E, œÑ1

‚àíS‚àó
i ‚àíD1 + E
and
K‚Ä≤
S‚àó
i

= ‚àÇK(S‚àó
i )
‚àÇS‚àó
i
= ‚àÇc(S‚àó
i , E, œÑ1)
‚àÇS‚àó
i
‚àí1
Also from Eq. (A.3.2) in Appendix A.3:
‚àÇc(S‚àó
i , E, œÑ1)
‚àÇS‚àó
i
= N1

d1

S‚àó
i

we note that here the continuous dividend yield q = 0.
So
K‚Ä≤
S‚àó
i

= ‚àÇK(S‚àó
i )
‚àÇS‚àó
i
= N1

d1

S‚àó
i

‚àí1
where d1 = log(S‚àó
i /E) + (r + œÉ 2/2)œÑ1
œÉ‚àöT ‚àít1
Substituting these results into Eq. (5.2.4) gives:
S‚àó
i+1 = S‚àó
i ‚àíc(S‚àó
i , E, œÑ1) ‚àí(S‚àó
i + D1 ‚àíE)
N1(d1(S‚àó
i )) ‚àí1

Single asset American options
99
On rearrangement this yields:
S‚àó
i+1 = S‚àó
i N1(d1(S‚àó
i )) ‚àíc(S‚àó
i , E, œÑ1) + D1 ‚àíE
N1(d1(S‚àó
i )) ‚àí1
for i = 0, . . . , max_iter
(5.2.5)
where a convenient initial approximation is to choose S‚àó
0 = E, and max_iter
is the maximum number of iterations that are to be used.
We will now quote the Roll, Geske, and Whaley formula for the current value
of an American call which pays a single cash dividend D1 at time t1; it is:
C(S, E, œÑ)
= SD

N1(b1) + N2

a1, ‚àíb1,

t1 ‚àít
œÑ

+ D1 exp

‚àír(t1 ‚àít)

N1(b2)
‚àíE exp(‚àírœÑ)

N1(b2) exp(rœÑ1) + N2

a2, ‚àíb2, ‚àí

t1 ‚àít
œÑ

(5.2.6)
where SD is given by Eq. (5.2.1), E is the exercise price, T is the option ex-
piry date, t represents the current time, œÑ is the option maturity, N1(a) is the
univariate cumulative normal density function with upper intergral limit a, and
N2(a, b, œÅ) is the bivariate cumulative normal density function with upper inte-
gral limits a and b and correlation coefÔ¨Åcient œÅ. The other symbols used in Eq.
(5.2.6) are deÔ¨Åned as
a1 = log(S/E) + (r + œÉ 2/2)œÑ
œÉ‚àöœÑ
,
a2 = a1 ‚àíœÉ‚àöœÑ
b2 = log(S/S‚àó) + (r + œÉ 2/2)(t1 ‚àít)
œÉ‚àöt1 ‚àít
,
b2 = b1 ‚àíœÉ‚àöt1 ‚àít
and S is the current (time t) asset price, S‚àóis found using Eq. (5.2.5), r is the
riskless interest rate, œÉ is the asset‚Äôs volatility, œÑ = T ‚àít and œÑ1 = T ‚àít1.
To compute the value of an American call option which pays n cash dividends
Di, i = 1, . . . , n, at times ti, i = 1, . . . , n, we can use the fact that optimal exer-
cise normally only ever occurs at the Ô¨Ånal ex-dividend date tn; see for example
Hull (2003). Under these circumstances Eq. (5.2.6) can still be shown to value
the American call but now t1 should be set to tn, D1 should be set to Dn, and SD
is given by:
SD = S ‚àí
n

i=1
Di exp

‚àír(ti ‚àít)

(5.2.7)
A program to compute the Roll‚ÄìGeske‚ÄìWhaley approximation for an American
call option with multiple cash dividends is given in Code excerpt 5.1. Here the
functions cum_norm and cum_norm2 are used to calculate the values of N1(a)
and N2(a, b, œÅ), respectively. Code excerpt 5.3 was used to compute the values

100
Computational Finance Using C and C#
void RGW_approx(double *opt_value, double *critical_value, long n_divs, double dividends[],_
double Divs_T[],
double S0, double X, double sigma, double T, double r, long *iflag)
{
/* Input parameters:
=================
n_divs
- the number of dividends
dividends[]
- the dividends: dividends[0] contains the first dividend, dividend[1]
the second etc.
Divs_T[]
- the times at which the dividends are paid: Divs_T[0] is the time at which_
the first dividend is paid
Divs_T[1] is the time at which the second dividend is paid, etc.
S0
- the current value of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
Output parameters:
==================
opt_value
- the value of the option
critical_value - the critical value
iflag
- an error indicator
*/
double A_1,A_2,S_star,a1,a2,nt1,t1,S;
double b1,b2,d1,alpha,h,div,beta,temp,temp1,temp2,temp3;
double pdf,b,eur_val,fac,tol,loc_q,err,zero=0.0;
long iterate;
long i,iflagx,putx;
loc_q = 0.0;
temp = 0.0;
for (i=0; i < n_divs; ++i) { /Check the Divs_T array */
if ((Divs_T[i] <= temp) || (Divs_T[i] > T) || (Divs_T[i] <= zero)) {
*flag = 2;
return;
}
temp = Divs_T[i];
}
/* calculate the present value of the dividends (excluding the final one) */
temp = 0.0;
for (i=0; i < n_divs-1; ++i) {
temp = fac + dividends[i] * exp(-r*Divs_T[i]);
}
t1 = Divs_T[n_divs-1];
/* decrease the stock price by the present value of all dividends */
div = dividends[n_divs-1];
S = S0-temp-div*exp(-r*t1);
iterate = 1;
tol = 0.000001;
S_star = X;
while (iterate) {
/* calculate S_star, iteratively */
/* calculate the Black-Scholes value of a European call */
d1 = (log(S_star/X) + (r+(sigma*sigma/2.0))*(T-t1))/(sigma*sqrt(T-t1));
putx = 0;
loc_q = 0.0;
black_scholes(&eur_val,NULL,S_star,X,sigma,T-t1,r,loc_q,putx,&iflag);
S_star = (S_star*cum_norm(d1)-eur_val+div-X)/(cum_norm(d1)-1.0);
err = fabs(eur_val - (S_star + div- X))/X;
if (err < tol) iterate = 0;
}
a1 = (log(S/X) + (r+(sigma*sigma/2.0))*T)/(sigma*sqrt(T));
a2 = a1 - sigma*sqrt(T);
b1 = (log(S/S_star)+(r+(sigma*sigma/2.0))*t1)/(sigma*sqrt(t1));
b2 = b1 - sigma*sqrt(t1);
nt1 = sqrt(t1/T);
temp1 = S*(cum_norm(b1)+cum_norm2(a1,-b1,-nt1,&iflagx));
temp2 = -X*exp(-r*T)*cum_norm2(a2,-b2,-nt1,&iflagx)-(X-div)*exp(-r*t1)*cum_norm(b2);
*opt_value = temp1+temp2;
*critical_value = S_star;
}
Code excerpt 5.1 Function to compute the Roll‚ÄìGeske‚ÄìWhaley approximation for the
value of an American call option with discrete dividends.

Single asset American options
101
Table 5.1 A comparison of the computed values for American call options with
dividends, using the Roll‚ÄìGeske‚ÄìWhaley approximation and the Black approximation
Stock price
Critical price, S‚àó
RGW approximation
Black approximation
80.0
123.582
3.212
3.208
85.0
123.582
4.818
4.808
90.0
123.582
6.839
6.820
95.0
123.582
9.276
9.239
100.0
123.582
12.111
12.048
105.0
123.582
15.316
15.215
110.0
123.582
18.851
18.703
115.0
123.582
22.676
22.470
120.0
123.582
26.748
26.476
The parameters used were: E = 100.0, r = 0.04, œÉ = 0.2, œÑ = 2.0, and there is one cash
dividend of value 5.0 at time t = 1.0. The current stock price, S, is varied from 80.0 to
120.0. The results are in agreement with those given in Table 1 of Whaley (1981).
presented in Table 5.1. These compare the Roll‚ÄìGeske‚ÄìWhaley approximation
with the Black approximation, which we will now brieÔ¨Çy discuss.
We will now consider the Black approximation.
The Black approximation
The Black (1973) approximation for an American call with cash dividends is
simpler than the Roll‚ÄìGeske‚ÄìWhaley method we have just described. For an
American call option which expires at time T , with n discrete cash dividends
Di, i = 1, . . . , n, at times ti, i = 1, . . . , n, it involves calculating the prices of
European options that mature at times T , and tn, and then setting the option
price to the greater of these two values, see for example Hull (2003).
The Black approximation, CBL, can be expressed more concisely in terms of
our previously deÔ¨Åned notation as:
CBL(S, E, œÑ) = max(v1, v2)
where v1 and v2 are the following European calls:
v1 = c(SD, E, œÑ)
and
v2 = c

S+
D, E, œÑ1

,
œÑ = T ‚àít, œÑ1 = T ‚àítn
and
SD = S ‚àí
n

i=1
Di
and
S+
D = S ‚àí
n‚àí1

i=1
Di
Code excerpt 5.2 computes the Black approximation.
Code excerpt 5.3 uses the same values as in Whaley (1981) and compares the
Roll‚ÄìGeske‚ÄìWhaley approximation with that of Black; the results are presented
in Table 5.1.

102
Computational Finance Using C and C#
void black_approx(double *value, long n_divs, double dividends[], double Divs_T[],
double S0, double X, double sigma, double T, double r, long put, long *ifail)
{
/* Input parameters:
=================
n_divs
- the number of dividends
dividends[] - the dividends, dividends[0] contains the first dividend, dividend[1] the_
second etc.
Divs_T[]
- the times at which the dividends are paid, Divs_T[0] is the time at which_
the first dividend is paid
Divs_T[1] is the time at which the second dividend is paid, etc.
S0
- the current value of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
put
- if put is 0 then a call option, otherwise a put option
Output parameters:
==================
value
- the value of the option, iflag - an error indicator
*/
double zero = 0.0;
double beta,temp,temp1,temp2,temp3;
double tn,val_T,val_tn,tol,loc_q,err,fac;
long i,ifailx;
loc_q = 0.0;
temp = 0.0;
for (i=0; i < n_divs; ++i) {
if (Divs_T[i] <= temp ) printf ("Error in Divs_T array, elements not increasing \n");
if (Divs_T[i] > T) printf ("Error in Divs_T array element has a value greater than T \n");
if (Divs_T[i] <= zero) printf ("Error in Divs_T array element <= zero \n");
temp = Divs_T[i];
}
/* calculate the present value of the dividends */
fac = 0.0;
for (i=0; i < n_divs; ++i) {
fac = fac + dividends[i] * exp(-r*Divs_T[i]);
}
temp = S0 - fac;
/* calculate the value of the option on expiry */
black_scholes(&val_T,NULL,temp,X,sigma,T,r,loc_q,put,&ifailx);
/* calculate the value of the option on last dividend date */
tn = Divs_T[n_divs-1];
temp = temp + dividends[n_divs-1]*exp(-r*tn);
nag_opt_bs(&val_tn,NULL,temp,X,sigma,tn,r,loc_q,putx,&ifailx);
*value = MAX(val_tn,val_T);
}
Code excerpt 5.2 Function to compute the value of the Black approximation for the
value of an American call option with discrete dividends.
We will now consider a more general technique for pricing both American
puts and calls.
5.2.2
The MacMillan‚ÄìBarone-Adesi‚ÄìWhaley method
Here we consider a method of pricing American options which relies on an ap-
proximation that reduces a transformed Black‚ÄìScholes equation into a second-
order ordinary differential equation, see Barone-Adesi and Whaley (1987) and
MacMillan (1986). It thus provides an alternative way of evaluating American
options that can be used instead of computationally intensive techniques such
as Ô¨Ånite-difference methods. Although the method prices American options, it
is really based on the value of an American option relative to the corresponding

Single asset American options
103
double q,r,temp,loc_r;
long i,m,m2,m_acc;
double S0,E,T,sigma,t1,delta,value,ad_value,put_value;
long is_american,ifail,put;
double bin_greeks[5],greeks[5],bin_value,bs_value;
double opt_value, critical_value, E1, E2, crit1, crit2;
double black_value;
double Divs_T[3],dividends[3];
long n_divs, put;
E
= 100.0;
r = 0.04;
sigma = 0.2;
T =
2.0;
t1 = 1.0;
put = 0;
/* check using the same parameters as in \inlinecite{Wha1981} */
Divs_T[0] = 1.0;
dividends[0] = 5.0;
n_divs = 1;
printf ("\nPrice S
RGW Approximation
Black Approximation
\n\n");
for (i=0; i < 9; ++i) {
put = 0;
S0 = 80.0+(double)i*5.0;
opt_RGW_approx(&opt_value,&critical_value,n_divs,dividends,Divs_T,S0,E,sigma,T,r,&ifail);
printf("%8.4f
",S0);
printf("%12.3f %12.3f ",opt_value,critical_value);
opt_black_approx(&black_value,n_divs,dividends,Divs_T,S0,E,sigma,T,r,put,&ifail);
printf("%12.3f (%8.4e) ",black_value);
}
Code
excerpt
5.3 Simple
test
program
to
compare
the
results
of
function
opt_RGW_approx with function opt_black_approx; the parameters used are the
same as in Whaley (1981).
European option value (which can readily be computed using the Black‚ÄìScholes
pricing formula).
Since an American option gives more choice, its value is always at least that of
its European counterpart. This early exercise premium (ŒΩ(S, E, œÑ) ‚©æ0) is now
deÔ¨Åned more precisely for American puts and calls. If at current time t the asset
price is S, then the early exercise premium for an American call which expires
at time T , and therefore has maturity œÑ = T ‚àít, is:
ŒΩc(S, E, œÑ) = C(S, E, œÑ) ‚àíc(S, E, œÑ) ‚©æ0
(5.2.8)
where C(S, E, œÑ) denotes the value of the American call and c(S, E, œÑ) denotes
the value of the corresponding European call. The early exercise premium of an
American put option, ŒΩp(S, E, œÑ), is similarly deÔ¨Åned as:
ŒΩp(S, E, œÑ) = P(S, E, œÑ) ‚àíp(S, E, œÑ) ‚©æ0
(5.2.9)
where P(S, E, œÑ) is the value of the American put, and p(S, E, œÑ) is the value of
the corresponding European put. The key insight provided by the MacMillan‚Äì
Barone-Adesi‚ÄìWhaley method is that, since both the American and European
option values satisfy the Black‚ÄìScholes partial differential equation, so does the
early exercise premium, ŒΩ(S, E, œÑ); see Section 4.4.1. This means that we can
write:
‚àÇŒΩ
‚àÇt + (r ‚àíq)S ‚àÇŒΩ
‚àÇS + œÉ 2S2
2
‚àÇ2ŒΩ
‚àÇS2 = rŒΩ
(5.2.10)

104
Computational Finance Using C and C#
where as usual S is the asset price, r is the continuously compounded interest
rate, q is the continuously compounded dividend, œÉ is the volatility, and time t
increases from the current time to the expiry time T .
We will now introduce the variable h(œÑ) = 1 ‚àíexp(‚àírœÑ) and use the factor-
ization ŒΩ(S, E, œÑ) = h(œÑ)g(S, E, h). From standard calculus we obtain:
‚àÇŒΩ
‚àÇt = g ‚àÇh
‚àÇt + h‚àÇg
‚àÇt = rg(h ‚àí1) + h‚àÇg
‚àÇh
‚àÇh
‚àÇt = rg(h ‚àí1) + hr(h ‚àí1)‚àÇg
‚àÇh
and also
‚àÇŒΩ
‚àÇS = h ‚àÇg
‚àÇS
and
‚àÇ2ŒΩ
‚àÇS2 = h‚àÇ2g
‚àÇS2
Substituting these results into Eq. (5.2.10) yields the following transformed
Black‚ÄìScholes equation:
S2œÉ 2h
2
‚àÇ2g
‚àÇS2 + (r ‚àíq)Sh ‚àÇg
‚àÇS + rg(h ‚àí1) + rh(h ‚àí1)‚àÇg
‚àÇh = rgh
(5.2.11)
which can be further simpliÔ¨Åed to give:
S2œÉ 2 ‚àÇ2g
‚àÇS2 + 2(r ‚àíq)S
œÉ 2
‚àÇg
‚àÇS ‚àí2rg
hœÉ 2 ‚àí2r(1 ‚àíh)
œÉ 2
‚àÇg
‚àÇh = rgh
(5.2.12)
or
S2 ‚àÇ2g
‚àÇS2 + Œ≤S ‚àÇg
‚àÇS ‚àíŒ±
hg ‚àí(1 ‚àíh)Œ± ‚àÇg
‚àÇh = 0
(5.2.13)
where Œ± = 2r/œÉ 2 and Œ≤ = 2(r ‚àíq)/œÉ 2.
We now consider the last term of Eq. (5.2.13) and note that when œÑ is large,
1 ‚àíh(œÑ) ‚àº0. Also when œÑ ‚Üí0 the option is close to maturity, and the
value of both the European and American options converge; this means that
ŒΩ(S, E, œÑ) ‚àº0 and ‚àÇg
‚àÇh ‚àº0. It can thus be seen that the last term is generally
quite small and the MacMillan‚ÄìBarone-Adesi‚ÄìWhaley approximation assumes
that it can be ignored. This results in the following equation:
S2 ‚àÇ2g
‚àÇS2 + Œ≤S ‚àÇg
‚àÇS ‚àíŒ±
hg = 0
(5.2.14)
which is a second-order differential equation with two linearly independent so-
lutions of the form aSŒ≥ . They can be found by substituting g(S, E, h) = aSŒ≥
into Eq. (5.2.14) as follows:
‚àÇg
‚àÇS = Œ≥ SŒ≥ ‚àí1,
‚àÇ2g
‚àÇS2 = aŒ≥ (Œ≥ ‚àí1)SŒ≥ ‚àí2 = aŒ≥ 2SŒ≥ ‚àí2 ‚àíaŒ≥ SŒ≥ ‚àí2
so
S2 ‚àÇ2g
‚àÇS2 = aŒ≥ 2SŒ≥ ‚àíaŒ≥ SŒ≥ = Œ≥ 2g ‚àíŒ≥g
and
Œ≤S ‚àÇg
‚àÇS = Œ≤SaŒ≥ SŒ≥ ‚àí1 = Œ≤Œ≥ SŒ≥ = Œ≤Œ≥g

Single asset American options
105
When the above results are substituted in Eq. (5.2.14) we obtain the quadratic
equation:
Œ≥ 2g ‚àíŒ≥g + Œ≤Œ≥g ‚àíŒ±
h = g

Œ≥ 2 ‚àíŒ≥ + (Œ≤ ‚àí1)Œ≥ ‚àíŒ±
h

= 0
or
Œ≥ 2 ‚àíŒ≥ + (Œ≤ ‚àí1)Œ≥ ‚àíŒ±
h = 0
(5.2.15)
which has the two solutions
Œ≥1 = 1
2

‚àí(Œ≤ ‚àí1) ‚àí

(Œ≤ ‚àí1)2 + 4Œ±
h

(5.2.16)
and
Œ≥2 = 1
2

‚àí(Œ≤ ‚àí1) +

(Œ≤ ‚àí1)2 + 4Œ±
h

(5.2.17)
where we note that since Œ±/h > 0, we have Œ≥1 < 0 and Œ≥2 > 0.
The general solution to Eq. (5.2.14) is thus:
g(S, E, h) = a1SŒ≥1 + a2SŒ≥2
(5.2.18)
We will now derive the appropriate solutions pertaining to American call op-
tions and American put options.
American call options
Here we use the fact that both the value and the early exercise premium
(ŒΩc(S, E, œÑ) = hgc(S, E, h)) of an American call tend to zero as the asset price
S ‚Üí0. This means that as S ‚Üí0, gc(S, E, h) ‚Üí0.
However, since Œ≥1 < 0, the only way this can be achieved in Eq. (5.2.18) is if
a1 = 0. So gc(S, E, h) = a2SŒ≥2, and the value of an American call is:
C(S, E, œÑ) = c(S, E, œÑ) + ha2SŒ≥2
(5.2.19)
An expression for a2 can be found by considering the critical asset price (point
on the early exercise boundary), S‚àó, above which the American option will be
exercised. For S < S‚àó, the value of the American call is governed by Eq. (5.2.19),
and when S > S‚àówe have C(S, E, œÑ) = S ‚àíE.
Now, since the value of the American option is continuous, at the critical asset
value S‚àóthe following equation applies:
S‚àó‚àíE = c

S‚àó, E, œÑ

+ ha2S‚àóŒ≥2
(5.2.20)
Furthermore, since the gradient of the American option value is also continuous,
at S‚àówe have:
‚àÇ(S‚àó‚àíE)
‚àÇS‚àó
=
‚àÇ
‚àÇS‚àó

c

S‚àó, E, œÑ

+ ha2S‚àóŒ≥2
(5.2.21)
which gives:
1 = exp(‚àíqœÑ)N1

d1

S‚àó
+ Œ≥2ha2S‚àó(Œ≥2‚àí1)
(5.2.22)

106
Computational Finance Using C and C#
where we have used the value of the hedge parameter Œîc for a European call
(see the section on the Greeks):
Œîc = ‚àÇc(S‚àó, E, œÑ)
‚àÇS‚àó
= exp(‚àíqœÑ)N1

d1

S‚àó
Equation (5.2.22) can therefore be written as:
ha2S‚àóŒ≥2 = S‚àó
Œ≥2

1 ‚àíexp(‚àíqœÑ)N1

d1

S‚àó
(5.2.23)
When the left-hand side of the above equation is substituted into Eq. (5.2.20)
we obtain the following equation for S‚àó:
S‚àó‚àíE = c

S‚àó, E, œÑ

+ S‚àó
Œ≥2

1 ‚àíexp(‚àíqœÑ)N1

d1

S‚àó
(5.2.24)
This equation can be solved for S‚àóusing standard iterative methods (see the
section on the numerical solution of critical asset values). Once S‚àóhas been
found Eq. (5.2.23) gives:
ha2 = A2S‚àó‚àíŒ≥2
where
A2 = S‚àó
Œ≥2

1 ‚àíexp(‚àíqœÑ)N1

d1

S‚àó
From Eq. (5.2.19) the value of an American call is thus of the form:
C(S, E, œÑ) = c(S, E, œÑ) + A2
 S
S‚àó
Œ≥2
when S < S‚àó
(5.2.25)
C(S, E, œÑ) = S ‚àíE
when S ‚©æS‚àó
(5.2.26)
American put options
For an American put option we proceed in a similar manner to that for the
American call. We now use the fact that both the value and early exercise pre-
mium (ŒΩp(S, E, œÑ) = hgp(S, E, h)) of an American put tend to zero as the asset
price S ‚Üí‚àû. So gp(S, E, h) ‚Üí0 as S ‚Üí‚àû. Since Œ≥2 > 0 the only way this can
be achieved by Eq. (5.2.18) is if a2 = 0. This gives gp(S, E, h) = a1SŒ≥1 and the
value of an American put is:
P(S, E, œÑ) = p(S, E, œÑ) + ha1SŒ≥1
(5.2.27)
An expression for a1 can be found by considering the critical asset price, S‚àó‚àó,
below which the American option will be exercised. For S > S‚àó‚àóthe value
of the American put is given by Eq. (5.2.27), and for S < S‚àó‚àówe have
P(S, E, œÑ) = E ‚àíS.
Continuity of the American option value at the critical asset price gives:
E ‚àíS‚àó‚àó= p

S‚àó‚àó, E, œÑ

+ ha1S‚àó‚àóŒ≥1
(5.2.28)

Single asset American options
107
and continuity of the option value‚Äôs gradient at the critical asset price yields:
‚àÇ(E ‚àíS‚àó‚àó)
‚àÇS‚àó‚àó
=
‚àÇ
‚àÇS‚àó‚àó

p

S‚àó‚àó, E, œÑ

+ ha1S‚àó‚àóŒ≥1
(5.2.29)
which can be simpliÔ¨Åed to:
‚àí1 = ‚àíN1

‚àíd1

S‚àó‚àó
exp(‚àíqœÑ) + Œ≥1a1S‚àó‚àó(Œ≥1‚àí1)
(5.2.30)
where we have used the value of hedge parameter Œîp for a European put (see
Appendix A.3):
Œîp = ‚àÇp(S‚àó‚àó, E, œÑ)
‚àÇS‚àó‚àó
=

N1

d1

S‚àó‚àó
‚àí1

exp(‚àíqœÑ) = ‚àíN1

‚àíd1

S‚àó‚àó
exp(‚àíqœÑ)
Equation (5.2.30) can therefore be written as:
ha1S‚àó‚àóŒ≥1 = ‚àíS‚àó‚àó
Œ≥1

1 ‚àíN1

‚àíd1

S‚àó‚àó
exp(‚àíqœÑ)

(5.2.31)
When the left-hand side of the above equation is substituted into Eq. (5.2.28)
we obtain the following equation for S‚àó‚àó:
E ‚àíS‚àó‚àó= p

S‚àó‚àó, E, œÑ

+

1 ‚àíexp(‚àíqœÑ)N

‚àíd1

S‚àó‚àóS‚àó‚àó
Œ≥1
(5.2.32)
which can be solved iteratively to yield S‚àó‚àó(see the section on the numerical
solution of critical asset values). Once S‚àó‚àóhas been found Eq. (5.2.31) gives:
ha1 = A1S‚àó‚àó‚àíŒ≥1
where
A1 = ‚àí
S‚àó‚àó
Œ≥1

1 ‚àíexp(‚àíqœÑ)N1

‚àíd1

S‚àó‚àó
We note here that A1
> 0 since, Œ≥1
< 0, S‚àó‚àó
> 0, and N1(‚àíd1(S‚àó‚àó))
exp(‚àíqœÑ) < 1.
From Eq. (5.2.27) the value of an American put is thus:
P(S, E, œÑ) = p(S, E, œÑ) + A1
 S
S‚àó‚àó
Œ≥2
when S > S‚àó‚àó
P(S, E, œÑ) = E ‚àíS
when S ‚©ΩS‚àó‚àó
5.2.3
Numerical solution of critical asset values
We now provide details on how to iteratively solve for the critical asset price in
Eqs. (5.2.24) and (5.2.32).

108
Computational Finance Using C and C#
American call options
For American call options we need to solve Eq. (5.2.24), which is:
S‚àó‚àíE = c

S‚àó, E, œÑ

+ S‚àó
Œ≥2

1 ‚àíexp(‚àíqœÑ)N1

d1

S‚àó
We denote the ith approximation to the critical asset value S‚àóby S‚àó
i , and repre-
sent the left-hand side of the equation by:
LHS

S‚àó
i , E, œÑ

= S‚àó
i ‚àíE
and the right-hand side of the equation by:
RHS

S‚àó
i , E, œÑ

= c

S‚àó
i , E, œÑ

+ S‚àó
i
Œ≥2

1 ‚àíexp(‚àíqœÑ)N1

d1

S‚àó
i

If we let K(S‚àó
i , E, œÑ) = RHS(S‚àó
i , E, œÑ) ‚àíLHS(S‚àó
i , E, œÑ) then we want to Ô¨Ånd the
value of S‚àó
i which (to a speciÔ¨Åed tolerance) gives K(S‚àó
i , E, œÑ) ‚àº0. This can be
achieved with Newton‚Äôs root Ô¨Ånding method, in which a better approximation,
S‚àó
i+1, can be found using:
S‚àó
i+1 = S‚àó
i ‚àíK(S‚àó
i , E, œÑ)
K
‚Ä≤(S‚àó
i , E, œÑ)
(5.2.33)
where:
K‚Ä≤
S‚àó
i , E, œÑ

=
‚àÇ
‚àÇS‚àó
i

RHS

S‚àó
i , E, œÑ

‚àíLHS

S‚àó
i , E, œÑ

=
‚àÇ
‚àÇS‚àó
i

RHS

S‚àó
i , E, œÑ

‚àí
‚àÇ
‚àÇS‚àó
i

LHS

S‚àó
i , E, œÑ

= bi ‚àí1
Here we have used bi =
‚àÇ
‚àÇS‚àó
i {RHS(S‚àó
i , E, œÑ)}, and the expression for bi is given
by Eq. (5.2.35), which is derived at the end of this section.
Substituting for K(S‚àó
i , E, œÑ) and K‚Ä≤(S‚àó
i , E, œÑ) into Eq. (5.2.32), we therefore
obtain:
S‚àó
i+1 = S‚àó
i ‚àíRHS(S‚àó
i , E, œÑ) ‚àíLHS(S‚àó
i , E, œÑ)
bi ‚àí1
= S‚àó
i ‚àíRHS(S‚àó
i , E, œÑ) ‚àí(S‚àó
i ‚àíE)
bi ‚àí1
= biS‚àó
i ‚àíRHS(S‚àó
i , E, œÑ) ‚àíE
bi ‚àí1
The Ô¨Ånal iterative algorithm for the American call is therefore:
S‚àó
i+1 = E + RHS(S‚àó
i , E, œÑ) ‚àíbiS‚àó
i
1 ‚àíbi
(5.2.34)

Single asset American options
109
where we can use S‚àó
0 = E for the initial estimate of the critical value (see the
computer Code excerpt 5.4).
The expression for bi
Here we derive an expression for the term bi which is used in Eq. (5.2.34).
bi = ‚àÇc(S‚àó
i , E, œÑ)
‚àÇS‚àó
i
+ 1
Œ≥2

1 ‚àíexp(‚àíqœÑ)N1

d1

S‚àó
i

‚àíS‚àó
i
Œ≥2
‚àÇN1(d1(S‚àó
i ))
‚àÇd1(S‚àó
i )
‚àÇd1(S‚àó
i )
‚àÇS‚àó
i
We will now quote the following results which are derived in Appendix A:
Appendix A, Eq. (A.1.3)
‚àÇN1(d1(S‚àó
i ))
‚àÇd1(S‚àó
i )
= n

d1

S‚àó
i

Appendix A, Eq. (A.1.6)
‚àÇd1(S‚àó
i )
‚àÇS‚àó
i
=
1
S‚àó
i œÉ‚àöœÑ
Appendix A, Eq. (A.3.2)
Œîc = ‚àÇc(S‚àó
i , E, œÑ)
‚àÇS‚àó
i
= exp(‚àíqœÑ)N1

d1

S‚àó
i

Substituting these results into the above expression, we therefore obtain:
bi = exp(‚àíqœÑ)N1

d1

S‚àó
i

+ 1
Œ≥2
‚àíexp(‚àíqœÑ)N1(d1(S‚àó
i ))
Œ≥2
‚àíexp(‚àíqœÑ)n(d1(S‚àó
i ))
Œ≥2œÉ‚àöœÑ
which can be rearranged to yield:
bi = exp(‚àíqœÑ)N1

d1

S‚àó
i

1 ‚àí1
Œ≥2

+ 1
Œ≥2

1 ‚àíexp(‚àíqœÑ)n(d1(S‚àó
i ))
œÉ‚àöœÑ

(5.2.35)
American put options
For American put options we need to solve Eq. (5.2.32) which is:
E ‚àíS‚àó‚àó
i
= p

S‚àó‚àó
i , E, œÑ

‚àíS‚àó‚àó
i
Œ≥1

1 ‚àíN1

‚àíd1

S‚àó‚àó
i

exp(‚àíqœÑ)

If we let S‚àó‚àó
i
denote the ith approximation to the critical asset value S‚àó‚àó, then
we can represent the left-hand side of the equation by:
LHS

S‚àó‚àó
i , E, œÑ

= E ‚àíS‚àó‚àó
i

110
Computational Finance Using C and C#
and the right-hand side of the equation by:
RHS

S‚àó‚àó
i , E, œÑ

= p

S‚àó‚àó
i , œÑ

‚àíS‚àó‚àó
i
Œ≥1

1 ‚àíN1

‚àíd1

S‚àó‚àó
i

exp(‚àíqœÑ)

= p

S‚àó‚àó
i , E, œÑ

‚àíS‚àó‚àó
i
Œ≥1

1 ‚àí

1 ‚àíN1

d1

S‚àó‚àó
i

exp(‚àíqœÑ)

= p

S‚àó‚àó
i , E, œÑ

‚àíS‚àó‚àó
i
Œ≥1

1 ‚àíexp(‚àíqœÑ)
+ N1

d1

S‚àó‚àó
i

exp(‚àíqœÑ)

We then denote K(S‚àó‚àó
i , E, œÑ) = RHS(S‚àó‚àó
i , E, œÑ) ‚àíLHS(S‚àó‚àó
i , E, œÑ) and using
Newton‚Äôs method we obtain:
S‚àó‚àó
i+1 = S‚àó‚àó
i
‚àíK(S‚àó‚àó
i , E, œÑ)
K‚Ä≤(S‚àó‚àó
i , E, œÑ)
(5.2.36)
where as before:
K‚Ä≤
S‚àó‚àó
i , E, œÑ

=
‚àÇ
‚àÇS‚àó‚àó
i

RHS

S‚àó‚àó
i , E, œÑ

‚àíLHS

S‚àó‚àó
i , E, œÑ

So K‚Ä≤(S‚àó‚àó
i , E, œÑ) = 1 + bi, where bi = ‚àÇ(RHS(S‚àó‚àó
i ,E,œÑ))
‚àÇS‚àó‚àó
i
, and the expression for bi
is given by Eq. (5.2.38), which is derived at the end of this section.
Equation (5.2.36) can therefore be written as:
S‚àó‚àó
i+1 = S‚àó‚àó
i
‚àíRHS(S‚àó‚àó
i , E, œÑ) ‚àíLHS(S‚àó‚àó
i , E, œÑ)
1 + bi
= S‚àó‚àó
i (1 + bi) ‚àíRHS(S‚àó‚àó
i , E, œÑ) + E ‚àíS‚àó‚àó
i
1 + bi
The Ô¨Ånal iterative algorithm for the American put is therefore:
S‚àó‚àó
i
= E ‚àíRHS(S‚àó‚àó
i , E, œÑ) + biS‚àó‚àó
i
1 + bi
(5.2.37)
where we can use S‚àó‚àó
0
= E for the initial estimate of the critical asset value (see
the computer Code excerpt 5.4).
The expression for bi
Here we derive an expression for the term bi which is used in Eq. (5.2.37).
Since
bi =
‚àÇ
‚àÇS‚àó‚àó
i

p

S‚àó‚àó
i , E, œÑ

‚àíS‚àó‚àó
i
Œ≥1

1 ‚àíexp(‚àíqœÑ) + N1

d1

S‚àó‚àó
i

exp(‚àíqœÑ)

we have
bi = ‚àÇp(S‚àó‚àó
i , E, œÑ)
‚àÇS‚àó‚àó
i
‚àí1
Œ≥1

1 ‚àíexp(‚àíqœÑ)

‚àí1
Œ≥1
exp(‚àíqœÑ)N1

d1

S‚àó‚àó
i

‚àíS‚àó‚àó
i
exp(‚àíqœÑ)
Œ≥1
‚àÇN1(d1(S‚àó‚àó
i ))
‚àÇd1(S‚àó‚àó
i )
‚àÇd1(S‚àó‚àó
i )
‚àÇS‚àó‚àó
i

Single asset American options
111
We will now quote the following results which are derived in Appendix A:
Appendix A, Eq. (A.1.3):
‚àÇN1(d1(S‚àó‚àó
i ))
‚àÇd1(S‚àó‚àó
i )
= n

d1

S‚àó‚àó
i

Appendix A, Eq. (A.1.6):
‚àÇd1(S‚àó‚àó
i )
‚àÇS‚àó‚àó
i
=
1
S‚àó‚àó
i œÉ‚àöœÑ
Appendix A, Eq. (A.3.4):
Œîp = ‚àÇp(S‚àó‚àó
i , E, œÑ)
‚àÇS‚àó‚àó
i
= exp(‚àíqœÑ)

N1

d1

S‚àó‚àó
i

‚àí1

Substituting these results into the above expression, we therefore obtain:
bi = exp(‚àíqœÑ)

N1

d1

S‚àó‚àó
i

‚àí1

‚àí1
Œ≥1

1 ‚àíexp(‚àíqœÑ) + N1

d1

S‚àó‚àó
i

exp(‚àíqœÑ)

‚àíS‚àó‚àó
i
exp(‚àíqœÑ)
Œ≥1
‚àÇN1(d1(S‚àó‚àó
i ))
‚àÇd1(S‚àó‚àó
i )
‚àÇd1(S‚àó‚àó
i )
‚àÇS‚àó‚àó
i
= exp(‚àíqœÑ)

N1

d1

S‚àó‚àó
i

‚àí1

‚àí1
Œ≥1

1 ‚àíexp(‚àíqœÑ) + N1

d1

S‚àó‚àó
i

exp(‚àíqœÑ)

‚àíS‚àó‚àó
i
exp(‚àíqœÑ)n(d1(S‚àó‚àó
i ))
Œ≥1œÉ‚àöœÑ
which can be rearranged to yield:
bi = exp(‚àíqœÑ)N1

d1

S‚àó‚àó
i

1 ‚àí1
Œ≥1

+ 1
Œ≥1

exp(‚àíqœÑ) ‚àí1 ‚àíexp(‚àíqœÑ)n(d1(S‚àó‚àó
i ))
œÉ‚àöœÑ

‚àíexp(‚àíqœÑ)
(5.2.38)
In Code excerpt 5.4 we provide computer code to implement the MacMillan‚Äì
Barone-Adesi‚ÄìWhaley method.
void MBW_approx(double *opt_value, double *critical_value, double S0, double X,
double sigma, double T, double r, double q, long put, long *iflag)
{
/* Input parameters:
=================
S0
- the current value of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
Code excerpt 5.4.

112
Computational Finance Using C and C#
q
- the continuous dividend yield
put
- if put is 0 then a call option, otherwise a put option
Output parameters:
==================
opt_value
- the value of the option
critical_value
- the critical value
iflag
- an error indicator
*/
double A_1,A_2,S_star,gamma_2,gamma_1;
double d1,alpha,h,beta,temp,temp1;
double pdf,pi,b,rhs,eur_val,tol,err;
long iterate;
long iflagx,putx;
pi = PI;
beta = 2.0 * (r - q) / (sigma * sigma);
alpha = 2.0 * r / (sigma * sigma);
h = 1.0 - exp(-r*T);
temp = beta - 1.0;
iterate = 1;
tol = 0.000001;
if (!put) {
/* An American call */
gamma_2 = (-temp + sqrt((temp*temp) + (4.0*alpha/h)));
gamma_2 = gamma_2 / 2.0;
S_star = X;
while (iterate) {
/* calculate S_star, iteratively */
d1 = log(S_star/X) + (r-q+(sigma*sigma/2.0))*T;
d1 = d1/(sigma*sqrt(T));
pdf = (1.0/sqrt(2.0*pi))*exp(-d1*d1/2.0);
temp = exp (-q*T)*cum_norm(d1)*(1.0 - (1.0/gamma_2));
temp1 = (1.0 - ((exp(-q*T)*pdf)/(sigma*sqrt(T))))/gamma_2;
b = temp + temp1;
/* calculate the Black-Scholes value of a European call */
putx = 0;
black_scholes(&eur_val,NULL,S_star,X,sigma,T,r,q,putx,&iflagx);
rhs = eur_val+(1.0-exp(-q*T)*cum_norm(d1))*S_star/gamma_2;
S_star = (X + rhs - b*S_star)/(1.0-b);
err = fabs((S_star - X) - rhs)/X;
if (err < tol) iterate = 0;
}
A_2 = (S_star/gamma_2)*(1.0 - exp(-q*T)*cum_norm(d1));
if (S0 < S_star) {
temp1 = S0/S_star;
black_scholes(&temp,NULL,S0,X,sigma,T,r,q,putx,&iflagx);
*opt_value = temp + A_2 * pow(temp1,gamma_2);
}
else {
*opt_value = S0 - X;
}
}
else { /* An American put */
gamma_1 = (-temp - sqrt((temp*temp) + (4.0*alpha/h)));
gamma_1 = gamma_1 / 2.0;
S_star = X;
while (iterate) {
/* calculate S_star, iteratively */
d1 = log(S_star/X) + (r-q+(sigma*sigma/2.0))*T;
d1 = d1/(sigma*sqrt(T));
pdf = (1.0/sqrt(2.0*pi))*exp(-d1*d1/2.0);
temp = exp(-q*T)*(cum_norm(d1)*(1.0-(1.0/gamma_1))-1.0);
temp1 = (exp(-q*T)-1.0-((exp(-q*T)*pdf)/(sigma*sqrt(T))))/gamma_1;
b = temp + temp1;
/* calculate the Black-Scholes value of a European put */
putx = 1;
black_scholes(&eur_val,NULL,S_star,X,sigma,T,r,q,putx,&iflagx);
rhs = eur_val-(1.0-exp(-q*T)+exp(-q*T)*cum_norm(d1))*S_star/gamma_1;
S_star = (X - rhs + b*S_star)/(1.0+b);
err = fabs((X - S_star) - rhs)/X;
if (err < tol) iterate = FALSE;
}
A_1 = -(S_star/gamma_1)*(1.0 - exp(-q*T)*cum_norm(-d1));
if (S0 > S_star) {
temp1 = S0/S_star;
black_scholes(&temp,NULL,S0,X,sigma,T,r,q,putx,&iflagx);
*opt_value = temp + A_1 * pow(temp1,gamma_1);
}
Code excerpt 5.4 (Continued).

Single asset American options
113
else {
*opt_value = X - S0;
}
}
*critical_value = S_star;
}
Code excerpt 5.4 Function to compute the MacMillan‚ÄìBarone-Adesi‚ÄìWhaley approxi-
mation for American options.
Table 5.2 The MacMillan‚ÄìBarone-Adesi‚ÄìWhaley method for American option values
computed by the routine MBW_approx
Stock price
Call
Put
Accurate value
Error
Accurate value
Error
86.0
1.2064
5.54 √ó 10‚àí4
14.0987
‚àí3.69 √ó 10‚àí2
89.0
1.8838
1.95 √ó 10‚àí4
11.5120
‚àí4.85 √ó 10‚àí2
92.0
2.7890
7.03 √ó 10‚àí4
9.2478
‚àí3.58 √ó 10‚àí2
95.0
3.9427
1.16 √ó 10‚àí3
7.3031
‚àí1.66 √ó 10‚àí2
98.0
5.3522
1.15 √ó 10‚àí3
5.6674
7.19 √ó 10‚àí4
101.0
7.0119
1.10 √ó 10‚àí3
4.3209
1.35 √ó 10‚àí2
104.0
8.9043
2.21 √ó 10‚àí3
3.2362
2.22 √ó 10‚àí2
107.0
11.0072
2.63 √ó 10‚àí3
2.3823
2.63 √ó 10‚àí2
110.0
13.2905
4.20 √ó 10‚àí3
1.7235
2.80 √ó 10‚àí2
113.0
15.7264
4.77 √ó 10‚àí3
1.2272
2.66 √ó 10‚àí2
The parameters used were: œÑ = 0.5, X = 100.0, r = 0.1, q = 0.06, œÉ = 0.2. The accurate
value was calculated using a standard lattice with 2000 time steps, and the error was the
MacMillan‚ÄìBarone-Adesi‚ÄìWhaley estimate minus the accurate value.
Table 5.3 The MacMillan, Barone-Adesi, and Whaley critical asset values for the early
exercise boundary of an American put computed by the routine MBW_approx
Time to expiry, œÑ
Critical asset value, S‚àó‚àó
Time to expiry, œÑ
Critical asset value, S‚àó‚àó
1.00
82.1510
0.50
85.1701
0.95
82.3751
0.45
85.6199
0.90
82.6115
0.40
86.1176
0.85
82.8618
0.35
86.6740
0.80
83.1273
0.30
87.3049
0.75
83.4098
0.25
88.0333
0.70
83.7115
0.20
88.8959
0.65
84.0349
0.15
89.9568
0.60
84.3830
0.10
91.3469
0.55
84.7598
0.05
93.4260
The parameters used were: S = 101.0, X = 101.0, r = 0.1, q = 0.06, and œÉ = 0.20.
The results given in Tables 5.2 and 5.3 were obtained by using the function
MBW_approx.

114
Computational Finance Using C and C#
5.3
Lattice methods for vanilla options
5.3.1
Binomial lattice
In this section we will derive equations for a binomial lattice that describes the
GBM movement of asset price changes. The approach that we will adopt is
based on the work of Cox, Ross, and Rubinstein (1979) and will be referred to
as the CRR lattice.
From Chapter 2, Eq. (2.3.9), we know that if the price of an asset, St, follows
GBM then the change in value of its price over time interval t has the following
distribution:
log
St+t
St

‚àºN

r ‚àíœÉ 2
2

t, œÉ 2t

If we use the notation:
X = St+t
St
and
Œ∑ =

r ‚àíœÉ 2
2

t,
ŒΩ2 = œÉ 2t
the above equation becomes:
log(X) ‚àºN

Œ∑, ŒΩ2
or equivalently
X ‚àº

Œ∑, ŒΩ2
where (Œ∑, ŒΩ2) is the lognormal distribution derived from a Gaussian distribu-
tion with mean Œ∑ and variance ŒΩ2. It is well known‚Äîsee for example Evans,
Hastings, and Peacock (2000)‚Äîthat the Ô¨Årst two moments of a variable X
drawn from a lognormal distribution are:
Lognormal mean
E[X] = exp

Œ∑ + ŒΩ2
2

(5.3.1)
substituting for Œ∑ and ŒΩ2 gives:
E[X] = exp

r ‚àíœÉ 2
2

t + œÉ 2
2 t

(5.3.2)

Single asset American options
115
Lognormal variance
Var[X] = E

X ‚àíE[X]
2
= E

X2
‚àí

E[X]
2
= exp

2Œ∑ + ŒΩ2
exp

ŒΩ2
‚àí1

(5.3.3)
substituting for Œ∑ and ŒΩ2 gives:
Var[X] = exp

2r

r ‚àíœÉ 2
2

t + œÉ 2t

which can be simpliÔ¨Åed to yield:
Var[X] = exp{2rt}

exp

œÉ 2t

‚àí1

(5.3.4)
Since we can assume that the expected value of X grows at the riskless interest
rate, r, we can also write:
E[X] = exp(rt)
(5.3.5)
The above results can be used to Ô¨Ånd the Ô¨Årst two moments of the asset price
distribution St+t, given that we know the asset price, St, at time instant t. To
do this we will use (see Appendix C.3 for a proof) the fact that for a random
variable G we have:
E[a + bG] = E[a] + bE[G]
and
Var[a + bG] = b2 Var[G]
where a and b are constants. Applying this to the variable X gives:
E[X] = E
St+t
St

= 1
St
E[St+t]
(5.3.6)
and
Var[X] = Var
St+t
St

= 1
S2t
Var[St+t]
(5.3.7)
where we have used a = 0 and b = 1
St
. Note: It is also easy to show that:
Var[St+t] = Var[S]
(5.3.8)
where the change in asset price over the time interval t is denoted by S =
St+t ‚àíSt. This elementary result sometimes is used without proof, see for ex-
ample Hull (1997), p. 344. The proof is simple:
Var[St+t] = Var[St + S] = Var[S]
where again we have used:
Var[a + bG] = b2 Var[G],
this time with a = 0 and b = 1.
To Ô¨Ånd expressions for the mean and variance of St+t we simply substitute
Eq. (5.3.5) into Eq. (5.3.6) and obtain:
E[St+t] = St exp(rt)
(5.3.9)

116
Computational Finance Using C and C#
and substituting Eq. (5.3.4) into Eq. (5.3.7) gives:
Var[St+t] = S2
t exp

2rt

exp

œÉ 2t

‚àí1

(5.3.10)
Since we are modelling asset price movements with a binomial lattice, the asset
price, St, at any given node is only permitted to either jump up or jump down
in value over the next time step t. Here we will assume that the new asset
price, St+t, is Stu for an up jump and Std for a down jump where u and d are
constants that apply to all lattice nodes. If we further denote the probability of
an up jump by p, then the probability of a down jump must (by deÔ¨Ånition) be
1 ‚àíp.
Now that we have speciÔ¨Åed the lattice parameters we will use these to match
the Ô¨Årst two moments of the lognormal distribution. This results in the following
equation for the mean:
E[St+t] = pStu + (1 ‚àíp)Std = St exp(rt)
(5.3.11)
The corresponding equation for the variance requires a little more work:
Var[St+t] = E

(St+t)2
‚àí

E[St+t]
2
(5.3.12)
Since
E

(St+t)2
= p(Stu)2 + (1 ‚àíp)(Std)2 = S2
t

pu2 + (1 ‚àíp)d2
(5.3.13)
and, from Eq. (5.3.9), we have:

E[St+t]
2 =

St exp(rt)
2 = S2
t exp(2rt)
(5.3.14)
we can substitute Eqs. (5.3.13) and (5.3.14) into Eq. (5.3.12) to obtain:
Var[St+t] = S2
t

pu2 + (1 ‚àíp)d2
‚àíS2
t exp(2rt)
(5.3.15)
So from Eqs. (5.3.10) and (5.3.15):
exp(2rt)

exp

œÉ 2t

‚àí1

= pu2 + (1 ‚àíp)d2
= pu2 + (1 ‚àíp)d2 ‚àíexp(2rt)
(5.3.16)
So, restating Eq. (5.3.11) and simplifying Eq. (5.3.16), we obtain the following
two equations:
pu + (1 ‚àíp)d = exp(rt)
(5.3.17)
exp

2rt + œÉ 2t

= pu2 + (1 ‚àíp)d2
(5.3.18)
which we will use to solve for the three parameters u, d, and p. Since there
are three unknowns and only two equations, we can impose an additional con-
straint to obtain a unique solution. The constraint used in the CRR binomial
model is:
u = 1
d
We now use the following notation:
a = exp(rt)

Single asset American options
117
and
b2 = exp(2rt)

exp

œÉ 2t

‚àí1

= a2
exp

œÉ 2t

‚àí1

This means that Eq. (5.3.17) can be written as:
a = pu + (1 ‚àíp)d
which gives:
p = a ‚àíd
u ‚àíd
(5.3.19)
From Eq. (5.3.18) we have:
exp

2rt + œÉ 2t

= a2 exp

œÉ 2t

= a2 + b2
and so:
a2 + b2 = pu2 + (1 ‚àíp)d2
Rearranging we have:
pu2 + (1 ‚àíp)d2 ‚àía2 = b2
pu3 + (1 ‚àíp)d2u ‚àía2u ‚àíb2u = 0
but:
(1 ‚àíp)d2u = (1 ‚àíp)d = a ‚àípu
so
pu3 + (a ‚àípu) ‚àía2u ‚àíb2u = 0
or
p

u3 ‚àíu

+ a ‚àía2u ‚àíb2u = 0
Now,
p

u3 ‚àíu

= u2p(u ‚àíd) = u2(a ‚àíd) = u2a ‚àíu
which gives:
au2 ‚àíu + a ‚àía2u ‚àíb2u = 0
So we obtain the following quadratic equation in u:
au2 ‚àíu

1 + a2 + b2
+ a = 0
The solution is:
u = (1 + a2 + b2) +

(1 + a2 + b2)2 ‚àí4a2
2a
If t is small we can obtain a reasonable approximation to the solution by
neglecting terms of order higher than t.

118
Computational Finance Using C and C#
In these circumstances we have:
a2 + b2 + 1 = exp(2rt) + exp(2rt)

exp

œÉ 2t

‚àí1

+1
‚àº1 + 2rt + (1 + 2rt)œÉ 2t + 1 ‚àº2 + 2rt + œÉ 2t
Therefore,

a2 + b2 + 1
2 ‚àí4a2 ‚àº

2 + 2rt + œÉ 2t
2 ‚àí4(1 + 2rt)
‚àº

4 + 8rt + 4œÉ 2t ‚àí4 ‚àí8rt
=

4œÉ 2t = 2œÉ
‚àö
t
and so
u ‚àº2 + 2rt + œÉ 2t + 2œÉ
‚àö
t
2 exp(rt)
u ‚àº

1 + rt + œÉ 2t
2
+ œÉ
‚àö
t

(1 ‚àírt)
u ‚àº1 + rt + œÉ 2t
2
+ œÉ
‚àö
t ‚àírt = 1 + œÉ
‚àö
t + œÉ 2t
2
which to order t gives:
u = exp

œÉ
‚àö
t

and
d = exp

‚àíœÉ
‚àö
t

(5.3.20)
where we have used
exp

œÉ
‚àö
t

= 1 + œÉ
‚àö
t + œÉ 2t
2
+ œÉ 3(t)3/2
6
+ ¬∑ ¬∑ ¬∑
and
d = 1
u
It is interesting to note (by substituting into Eq. (5.3.19)) that when r = 0 and
t ‚Üí0, we have p ‚Üí1
2.
Now that we know the values of the lattice parameters u, d, and p we can use
these to build a lattice with a speciÔ¨Åed number of time steps. Once this has been
constructed, it can be used to compute the values and Greeks for various types
of Ô¨Ånancial options. These could simply be American/European vanilla options,
or more exotic options that may incorporate features such as: lockout periods,
barriers, and nonstandard payoff functions.
We will now discuss how to create a lattice which can be used to value Amer-
ican and European vanilla options.
If the current value of the underlying asset is S, and the duration of the option
is œÑ and we use a lattice with n equally spaced time intervals t, then we have:
t = œÑ
n
The values of the asset price at various nodes in the lattice can easily be com-
puted. This is illustrated, in Fig. 5.1, for a lattice with six time steps (that is
seven lattice levels).

Single asset American options
119
Figure 5.1 A standard binomial lattice consisting of six time steps. The root lattice
node R corresponds to the current time t, and the terminal nodes G to M are those at
option maturity; that is time t + œÑ, where œÑ is the duration of the option. The asset value
at node R is S, where S is the current asset value. Asset values at other nodes are, for ex-
ample, node S: Su, node T: Sd, node V: S, and node A: Su5. Option values are computed
using a backward iterative process: the option values at nodes A‚ÄìF on the penultimate
time step are computed from the payouts of the terminal nodes G‚ÄìM, and this process con-
tinues until the root node is reached which yields the current value of the option. Here
we compute the Greeks using the following nodes: Delta uses nodes S and T, Gamma
uses nodes U, V, and W, and Theta uses nodes R and V.
The asset values at the labelled nodes are:
Lattice level 1: Time t
SR = S
Lattice level 2: Time t + t
SS = Su,
ST = Sd
Lattice level 6: Time t + 5t
SA = Su5,
SB = Su3,
SC = Su,
SD = Sd,
SE = S,
SF = Sd5
Lattice level 7: Time t + 6t
SG = Su6,
SH = Su4,
SI = Su2,
SJ = S,
SK = Sd2,
SL = Sd4,
SM = Sd6

120
Computational Finance Using C and C#
In general, at time t + it, there are i + 1 stock prices; these are:
Si,j = Sujdi‚àíj,
j = 0, 1, . . . , i
We note that, since u = 1/d, an up movement followed by a down movement
gives the same stock price as a down movement followed by an up movement;
for instance, Su2d = Su. This means that the tree recombines, and the number of
nodes required to represent all the different asset prices is signiÔ¨Åcantly reduced.
5.3.2
Constructing and using the binomial lattice
In this section we are concerned with the practical details of how to construct,
and then use, a standard one-dimensional binomial lattice to value Ameri-
can and European options. Since this lattice forms the basis for other one-
dimensional and multidimensional lattice techniques, we will discuss its con-
struction in some detail. A complete computer program for a standard bino-
mial lattice is given in Code excerpt 5.11, and we will use this as a basis for
our discussions. The results of using this code are presented in Fig. 5.2. For
Figure 5.2 The error in the estimated value, est_val, of an American put using a stan-
dard binomial lattice. The parameters used were: T = 1.0, S = 105.0, X = 105.0, r = 0.1,
q = 0.02, œÉ = 0.3. The very accurate value (acc_val) was 9.2508 and was computed us-
ing a 6000 step standard binomial lattice. The error in the estimated value was obtained
as est_val ‚àíacc_val.

Single asset American options
121
easy reference we will now list the input parameters used by this computer pro-
gram:
S0
the current price of the underlying asset, S
X
the strike price
sigma
the volatility of the asset
T
the maturity of the option in years
r
the risk-free interest rate
q
the continuous dividend yield
put
if put equals 1 then the option is a put
option, if put equals 0 then it is a call option
is_american
if is_american equals 1 then it is an
American option, if is_american equals 0 then it is a
European option
M
the number of time steps in the lattice
We will now discuss in more detail the computational issues involved in each
stage of the calculation.
Compute the values of the constants used by the lattice
First calculate the values of various constants that will be used, see Code ex-
cerpt 5.5.
For convenience, we have used the variables p_u and p_d to store, respec-
tively, the up and down jump probabilities discounted by the interest rate r
over one time step; these values will be used later on when we work backwards
through the lattice to calculate the current option value.
Assign the asset values to the lattice nodes
We will now show that the number of different asset prices, LSn, for an n step
recombining lattice is 2n + 1.
The nodes in a recombining lattice can be considered as being composed of
two kinds: those corresponding to an even time step, and those corresponding
to an odd time step.
This is because the set of node asset values, ET , for an even time step is
distinct from the set of node asset values, OT , for an odd time step. Although
dt = T/(double)M;
t1 = sigma*sqrt(dt);
u = exp(t1);
d = exp(-t1);
a = exp((r-q)*dt);
p = (a - d)/(u - d);
if ((p < zero) || (p > 1.0)) printf ("Error p out of range\n");
discount = exp(-r*dt);
p_u = discount*p;
p_d = discount*(1.0-p);
Code excerpt 5.5 A code fragment which computes the values of various lattice con-
stants.

122
Computational Finance Using C and C#
s[M] = S0;
for (i = 1; i <= M; ++i) {
s[M+i] = u*s[M+i-1];
s[M-i] = d*s[M-i+1];
}
Code excerpt 5.6 A code fragment which assigns the different binomial lattice asset
values to the storage array s by using the up and down jump ratios u and d de-
Ô¨Åned in Section 3.4.1. The current asset value S is assigned to the central array el-
ement s[M], where M is the number of time steps in the lattice. The array elements
above center are S[M+i] = Sui, i = 1, . . . ,M, and the array elements below center are
S[M-i] = Sdi, i = 1, . . . ,M.
ET ‚à©OT = ‚àÖ, the elements of ET and OT for any consecutive pair of time steps
are related by the simple constant multiplicative factor d. Also, for an even time
step there is a central node corresponding to the current asset price S0, and the
remaining nodes are symmetrically arranged about this, see Code excerpt 5.6.
These features are illustrated in Fig. 5.1, for a standard lattice with six time
steps.
The number of distinct asset prices in a lattice is therefore the sum of the
number of nodes in the last two time steps. Since the number of nodes in the ith
time step, Si, is i + 1 (see Fig. 5.1), for an n time step lattice we have:
Sn = n + 1
and
Sn‚àí1 = n
This means that the number of different asset values in an n time step lattice is:
LSn = Sn + Sn‚àí1 = 2n + 1
The number of nodes in an n time step lattice, LN n, is:
LN n =
n

i=0
(i + 1) = (n + 1)(n + 2)
2
where we have used the fact that LN n is the sum of an arithmetic progression
with Ô¨Årst term 1, increment 1 and last term n + 1.
One might initially think that, in order to price options, it is necessary to
store the asset value of each lattice node which would entail storing LN n values.
However, this is not the case. We only need to store the number of different asset
values in the lattice; that is, LSn values.
Storing LSn values instead of LN n can result in dramatic economies of stor-
age. For example, an accurate, 1000 step lattice, has LN n = 2001√ó2002√ó1/2 =
2003001, while the corresponding value of LSn is only 2 √ó 1000 + 1 = 2001.
Compute the option payoff at the terminal nodes
The current value of an option is evaluated by starting at option maturity, the
end of the tree, and working backwards. The option values for the terminal
nodes of the tree are just given by the payoff (at maturity) of the option; this

Single asset American options
123
if (((M+1)/2) == (M/2)) { /* then M is even */
if (put)
v[M/2] = MAX(X - s[M],zero);
else
v[M/2] = MAX(s[M]-X,zero);
}
P1 = 2*M;
P2 = 0;
for (i = 0; i < (M+1)/2; ++i) {
if (put) {
v[M-i] = MAX(X - s[P1],zero);
v[i]
= MAX(X - s[P2],zero);
}
else {
v[M-i] = MAX(s[P1]-X,zero);
v[i]
= MAX(s[P2]-X,zero);
}
P1 = P1 - 2;
P2 = P2 + 2;
}
Code excerpt 5.7 A code fragment that computes the payouts for puts and calls at the
lattice terminal nodes. The payouts are assigned to elements of the array v and are com-
puted using the strike price, X, and the previously computed asset values stored in ar-
ray s; as before M is the number of time steps in the lattice.
is independent of whether the option is an American or European. For a lattice
with n time steps there are n + 1 terminal nodes, with option values, fn,j, j =
0, . . . , n.
To compute the values of vanilla American and European options, with exer-
cise price E, then we will start with the following terminal node values:
for put options:
fn,j = max

E ‚àíSujdn‚àíj, 0

,
j = 0, . . . , n,
and for call options:
fn,j = max

Sujdn‚àíj ‚àíE, 0

,
j = 0, . . . , n
The computer code used to achieve this is Code excerpt 5.7.
Iterate backwards through the lattice
The probability of moving from node (i, j) at time it to node (i + 1, j + 1) at
time (i + 1)t is p, and the probability of moving from node (i, j) at time it
to the node (i + 1, j) at time (i + 1)t is 1 ‚àíp. If we assume that there is no
early exercise then:
f E
i,j = exp(‚àírt)

pfi+1,j+1 + (1 ‚àíp)fi+1,j

,
j ‚©Ωi ‚©Ωn ‚àí1, 0 ‚©Ωj ‚©Ωi
(5.3.21)

124
Computational Finance Using C and C#
When early exercise, for an American option, is taken into account we have:
f A
i,j = max

E ‚àíSi,j, f E
i,j

(5.3.22)
or for an American call option:
f A
i,j = max

Si,j ‚àíE, f E
i,j

,
j ‚©Ωi ‚©ΩN ‚àí1, 0 ‚©Ωj ‚©Ωi,
(5.3.23)
where f E
i,j is given by Eq. (5.3.21).
Code excerpt 5.8 works backward through the lattice and uses the array v to
store the option values.
At each time step the newly calculated option values overwrite those com-
puted by the previous time step. This process is continued until the second time
step (m1 = 2) is reached. A different technique is then used, which doesn‚Äôt
overwrite the option values and thus allows the Greeks to be computed in the
vicinity of the root lattice node R. If the Greeks are not required, continue work-
ing backward through the lattice until the root node R (m1 = 0) is reached, and
the current value of the option is then given by v[0] (or its multidimensional
equivalent).
The option values at all lattice nodes in time steps 0, 1, and 2 are made acces-
sible by the Code excerpt 5.9.
P2 = 0;
for (m1 = M-1; m1 >= 2; --m1) {
P2 = P2 + 1;
P1 = P2;
for (n =0; n <= m1; ++n) {
if ((v[n] == zero) && (v[n+1] == zero))
{
hold = zero;
}
else
hold = p_d*v[n] + p_u*v[n+1];
if (is_american) {
if (put)
v[n] = MAX(hold,X-s[P1]);
else
v[n] = MAX(hold,s[P1]-X);
}
else
v[n] = hold;
P1 = P1 + 2;
}
}
Code excerpt 5.8 Computer code that works iteratively backward through the lattice
computing the option values at each time step. The array v contains the option values
computed from the previous time step, and these are overwritten with option values
computed for the current time step. The iteration stops at the second time step, since we
do not want to overwrite values in the array v which are required for calculating the
Greeks in the neighborhood of the root node.

Single asset American options
125
jj = 2;
for (m1 = 2; m1 >= 1; --m1) {
ind = M-m1+1;
for (n =0; n < m1; ++n) {
hold =
p_d*v[5-jj-m1-1] + p_u*v[5-jj-m1];
if (is_american) {
if (put)
v[5-jj] = MAX(hold,X-s[ind]);
else
v[5-jj] = MAX(hold,s[ind]-X);
}
else
v[5-jj] = hold;
--jj;
ind = ind + 2;
}
}
*value = v[5];
Code excerpt 5.9 Code fragment illustrating how the option values are stored for the
Ô¨Årst two time steps so that the Greeks can be computed in the vicinity of the root node R.
Table 5.4 Lattice node values in the vicinity of the root node R
Node
Time step
Asset array element
Asset value
Option array element
R
0
s[M]
S
v[5]
S
1
s[M+1]
Su
v[4]
T
1
s[M-1]
Sd
v[3]
U
2
s[M+2]
Su2
v[2]
V
2
s[M]
S
v[1]
W
2
s[M-2]
Sd2
v[0]
Computing the Greeks: Œî, Œì and Œò
We will now describe how to calculate the option‚Äôs hedge statistics (Greeks).
Let the option value and asset value at lattice node k be denoted by fk and
Sk respectively. So, for instance, ST represents the asset price at node T and fT
is the corresponding option value at node T. Table 5.4 supplies details of the
lattice node values in the vicinity of the root node R.
The computation of each Greek is now considered.
Delta
The deÔ¨Ånition of Œî is the rate of change of the option value with asset price
all other parameters remaining Ô¨Åxed. Thus,
Œî = ‚àÇf
‚àÇS = f
S
where f is the change option value corresponding to the change in the asset
price S. Ideally we would like to evaluate this partial derivative at the root
node R (m1=0); however, we cannot because we need at least two lattice nodes
to compute a value. The best we can do is to evaluate the derivative at the Ô¨Årst
time step (m1=1) as follows:
Œî = fS ‚àífT
SS ‚àíST
=
v[4] ‚àív[3]
s[M + 1] ‚àís[M ‚àí1]

126
Computational Finance Using C and C#
Gamma
The deÔ¨Ånition of Œì is the rate of change of Œî with asset price all other para-
meters remaining Ô¨Åxed. Thus,
Œì = ‚àÇ2f
‚àÇS2 = ‚àÇŒî
‚àÇS
In order to evaluate Œì we require at least two values of Œî. The nearest this can
be achieved to the root node R is at time step 2, where we have:
Œì = Œî‚àó
UV ‚àíŒî‚àó
V W
S‚àó
UV ‚àíS‚àó
V W
with the midpoints
S‚àó
UV = 1
2{SU + SV }
and the values of Œî at the midpoints S‚àó
UV and S‚àó
V W denoted by Œî‚àó
UV and Œî‚àó
V W,
respectively. Since
Œî‚àó
UV = fU ‚àífV
SU ‚àíSV
Œî‚àó
V W = fV ‚àífW
SV ‚àíSW
and
S‚àó
UV ‚àíS‚àó
V W = 1
2{SU ‚àíSW}
we have
Œî‚àó
UV =
v[2] ‚àív[1]
s[M + 2] ‚àís[M]
Œî‚àó
V W =
v[1] ‚àív[0]
s[M] ‚àís[M ‚àí2]
The value of Œì can therefore be approximated as:
Œì =
2{Œî‚àó
UV ‚àíŒî‚àó
V W}
s[M + 2] ‚àís[M ‚àí2]
Theta
The deÔ¨Ånition of Œò is the rate of change of option value with time all other
parameters remaining Ô¨Åxed. Thus,
Œò = ‚àÇf
‚àÇt = f
t
The nearest to the root node R this can be computed is over the time interval
from time step 0 to time step 2. We then obtain the following approximation:
Œò = fV ‚àífR
2t
= v[1] ‚àív[5]
2t

Single asset American options
127
Code excerpt 5.10 computes the Œî, Œì , and Œò by using the approximations we
have just discussed.
Vega
The deÔ¨Ånition of V is the rate of change of the option value with volatility:
V = ‚àÇf
‚àÇœÉ
In a standard binomial lattice V cannot be computed directly. A simple approach
is to use two binomial lattices as follows:
V = fœÉ+œÉ ‚àífœÉ
œÉ
where fœÉ+œÉ is the option value computed using a binomial lattice with volatil-
ity œÉ + œÉ, and fœÉ is the option value computed using another binomial lattice
with a volatility of œÉ; all other lattice parameters remain constant.
The implied volatility of American options can be computed using the method
outlined for European options in Section 5.4.4; however, in this case the option
value and Greeks are computed using a binomial lattice (see Code excerpt 5.11).
/* assign the value of delta (obtained from m1 = 1) */
greeks[1] = (v[4]-v[3])/(s[M+1]-s[M-1]);
/* assign the value of gamma (use the values at time step m1 = 2) */
dv1 = v[2] - v[1];
ds1 = s[M+2] - s[M];
dv2 = v[1] - v[0];
ds2 = s[M] - s[M-2];
h = 0.5*(s[M+2] - s[M-2]);
greeks[0] = ((dv1/ds1) - (dv2/ds2))/h;
/* assign the value of theta */
greeks[2] = (v[1]-*value)/(2.0*dt); /* can also write: greeks[2] = (v[1]-v[5])/(2.0*dt); */
}
Code excerpt 5.10 A code fragment that computes the values of the Greeks, Delta,
Gamma and Theta, in the vicinity of the root lattice node R.
void standard_lattice(double *value, double greeks[], double S0,_
double X, double sigma, double T, double r,
double q, long put, long is_american, long M, long *iflag)
{
/* Input parameters:
=================
S0
- the current price of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
q
- the continuous dividend yield
put
- if put is 0 then a call option, otherwise a put option
is_american
- if is_american is 0 then a European option, otherwise an American option
M
- the number of time steps
Output parameters:
==================
value
- the value of the option,
greeks[]
- the hedge statistics output as follows: greeks[0] is gamma, greeks[1]_
is delta, greeks[2] is theta,
iflag
- an error indicator.
*/
.
.
.
/* Allocate the arrays s[2*M+1], and v[M+1] */
Code excerpt 5.11.

128
Computational Finance Using C and C#
dt = T/(double)M;
t1 = sigma*sqrt(dt);
u = exp(t1);
d = exp(-t1);
a = exp((r-q)*dt);
p = (a - d)/(u - d);
if ((p < zero) || (p > 1.0)) printf ("Error p out of range\n");
discount = exp(-r*dt);
p_u = discount*p;
p_d = discount*(1.0-p);
/* assign the 2*M+1 asset values */
s[M] = S0;
for (i = 1; i <= M; ++i) {
s[M+i] = u*s[M+i-1];
s[M-i] = d*s[M-i+1];
}
/* Find out if the number of time steps, M, is odd or even */
if (((M+1)/2) == (M/2)) { /* then M is even */
if (put)
v[M/2] = MAX(X - s[M],zero);
else
v[M/2] = MAX(s[M]-X,zero);
}
/* Calculate the option values at maturity
*/
P1 = 2*M;
P2 = 0;
for (i = 0; i < (M+1)/2; ++i) {
if (put) {
v[M-i] = MAX(X - s[P1],zero);
v[i]
= MAX(X - s[P2],zero);
}
else {
v[M-i] = MAX(s[P1]-X,zero);
v[i]
= MAX(s[P2]-X,zero);
}
P1 = P1 - 2;
P2 = P2 + 2;
}
/* now work backwards through the lattice to calculate the current option value */
P2 = 0;
for (m1 = M-1; m1 >= 2; --m1) {
P2 = P2 + 1;
P1 = P2;
for (n =0; n <= m1; ++n) {
if ((v[n] == zero) && (v[n+1] == zero))
{
hold = zero;
}
else
hold = p_d*v[n] + p_u*v[n+1];
if (is_american) {
if (put)
v[n] = MAX(hold,X-s[P1]);
else
v[n] = MAX(hold,s[P1]-X);
}
else
v[n] = hold;
P1 = P1 + 2;
}
}
/* The values v[0], v[1] & v[2] correspond to the nodes for m1 = 2, v[3] & v[4] correspond_
the nodes for m1 = 1 and the
option value (*value) is the node for m1 = 0, v[5]. For a given time step v[0]_
corresponds to the lowest asset price,
v[1] to the next lowest etc.. */
jj = 2;
for (m1 = 2; m1 >= 1; --m1) {
ind = M-m1+1;
for (n =0; n < m1; ++n) {
hold =
p_d*v[5-jj-m1-1] + p_u*v[5-jj-m1];
if (is_american) {
if (put)
v[5-jj] = MAX(hold,X-s[ind]);
else
Code excerpt 5.11 (Continued).

Single asset American options
129
v[5-jj] = MAX(hold,s[ind]-X);
}
else
v[5-jj] = hold;
--jj;
ind = ind + 2;
}
}
*value = v[5];
if(greeks) {
/* assign the value of delta (obtained from m1 = 1) */
greeks[1] = (v[4]-v[3])/(s[M+1]-s[M-1]);
/*
assign the value of gamma (use the values at time step m1 = 2)
*/
dv1 = v[2] - v[1];
ds1 = s[M+2] - s[M];
dv2 = v[1] - v[0];
ds2 = s[M] - s[M-2];
h
= 0.5*(s[M+2] - s[M-2]);
greeks[0] = ((dv1/ds1) - (dv2/ds2))/h;
/* assign the value of theta */
greeks[2] = (v[1]-*value)/(2.0*dt);
/* can also write:y greeks[2] = (v[1]-v[5])/_
(2.0*dt); */
}
Code excerpt 5.11 Function to compute the value of an option using a standard binomial
lattice.
5.3.3
Binomial lattice with a control variate
The control variate technique can be used to enhance the accuracy that a stan-
dard binomial lattice gives for the value of an American vanilla option. It in-
volves using the same standard binomial lattice to value both an American op-
tion and also the equivalent European option. The Black‚ÄìScholes formula is
then used to compute the accurate value of the European option. If we assume
that the error in pricing the European option is the same as that for the Ameri-
can option, we can achieve an improved estimate for the value of the American
option.
When applied to the valuation of an American put option this can be ex-
pressed as follows:
European pricing error, E = pBS(S, E, œÑ) ‚àípL(S, E, œÑ)
American pricing error, A = P ‚àó(S, E, œÑ) ‚àíP L(S, E, œÑ)
where as usual S is the current value of the asset, E is the strike price, and œÑ is
the maturity of the option. Also pBS(S, E, œÑ) is the Black‚ÄìScholes value of the
European put option, pL(S, E, œÑ) is the binomial lattice estimate of the Euro-
pean put option, P ‚àó(S, E, œÑ) is the (unknown) accurate value of the American
put option, and P L(S, E, œÑ) is the binomial lattice estimate of the American put
option.
Letting E = A we then have:
pBS(S, E, œÑ) ‚àípL(S, E, œÑ) = P ‚àó(S, E, œÑ) ‚àíP L(S, E, œÑ)
which on rearrangement yields:
P ‚àó(S, E, œÑ) = pBS(S, E, œÑ) ‚àípL(S, E, œÑ) + P L(S, E, œÑ)
We thus use P ‚àó(S, E, œÑ) as the improved, control variate estimate for the value
of the American put option. Of course, exactly the same approach can be used
to obtain an improved estimate for the value of an American call.

130
Computational Finance Using C and C#
Code excerpt 5.12 shows the use of the control variate technique in a standard
binomial lattice to provide improved estimates for both the value and the hedge
statistics of an American option.
/* Set up the arrays as in the standard lattice */
.
.
.
for (i = 0; i < (M+1)/2; ++i) { /* Calculate the option values at maturity
*/
if (put) {
a_v[M-i] = MAX(X - s[P1],zero);
a_v[i]
= MAX(X - s[P2],zero);
}
else {
a_v[M-i] = MAX(s[P1]-X,zero);
a_v[i]
= MAX(s[P2]-X,zero);
}
e_v[i]
= a_v[i];
e_v[M-i] = a_v[M-i];
P1 = P1 - 2;
P2 = P2 + 2;
}
/* now work backwards through the lattice to calculate the current option value */
P2 = 0;
for (m1 = M-1; m1 >= 2; --m1) {
P2 = P2 + 1;
P1 = P2;
for (n =0; n <= m1; ++n) {
if ((a_v[n] == zero) && (a_v[n+1] == zero))
hold = zero;
else
hold = p_d*a_v[n] + p_u*a_v[n+1];
if (put)
a_v[n] = MAX(hold,X-s[P1]);
else
a_v[n] = MAX(hold,s[P1]-X);
if ((e_v[n] == zero) && (e_v[n+1] == zero))
e_v[n] = zero;
else
e_v[n] = p_d*e_v[n] + p_u*e_v[n+1];
P1 = P1 + 2;
}
}
/* The American values are stored in the array a_v, and the European values in the array_
e_v. The array
indexing is the same as for the standard lattice */
jj = 2;
for (m1 = 2; m1 >= 1; --m1) {
ind = M-m1+1;
for (n =0; n < m1; ++n) {
hold =
p_d*a_v[5-jj-m1-1] + p_u*a_v[5-jj-m1];
if (put)
a_v[5-jj] = MAX(hold,X-s[ind]);
else
a_v[5-jj] = MAX(hold,s[ind]-X);
e_v[5-jj] = p_d*e_v[5-jj-m1-1] + p_u*e_v[5-jj-m1];
--jj;
ind = ind + 2;
}
}
/* v1 = American binomial approximation, v2 = European Binomial approximation, temp =_
exact (European) Black-Scholes value */
black_scholes(&temp,bs_greeks,S0,X,sigma,T,r,q,put,&iflagx);
*value = (a_v[5] - e_v[5]) + temp; /* return the control variate approximation */
if(greeks) {
/* assign the value of delta (obtained from m1 = 1) */
a_delta = (a_v[4]-a_v[3])/(s[M+1]-s[M-1]);
e_delta = (e_v[4]-e_v[3])/(s[M+1]-s[M-1]);
greeks[1] = a_delta - e_delta + bs_greeks[1];
/*
assign the value of gamma (use the values at time step m1 = 2)
*/
dv1 = a_v[2] - a_v[1];
Code excerpt 5.12.

Single asset American options
131
ds1 = s[M+2] - s[M];
dv2 = a_v[1] - a_v[0];
ds2 = s[M] - s[M-2];
h
= 0.5*(s[M+2] - s[M-2]);
a_gamma = ((dv1/ds1) - (dv2/ds2))/h;
dv1 = e_v[2] - e_v[1];
dv2 = e_v[1] - e_v[0];
e_gamma = ((dv1/ds1) - (dv2/ds2))/h;
greeks[0] = (a_gamma - e_gamma) + bs_greeks[0];
/* assign the value of theta */
a_theta = (a_v[1]-a_v[5])/(2.0*dt);
e_theta = (e_v[1]-e_v[5])/(2.0*dt);
greeks[2] = (a_theta - e_theta) + bs_greeks[2];
}
Code excerpt 5.12 Function to compute the value and hedge statistics of an American
option using a binomial lattice with a control variate.
Finally we should mention that the control variate technique does not just
apply to American vanilla options. The method is quite general and can be used
to obtain improved estimates for any integral (or exotic option) so long as an
accurate (closed form) solution of a similar integral is known. One common
use of the control variate method is to improve the accuracy of Monte Carlo
estimates.
5.3.4
The Binomial lattice with BBS and BBSR
Here we consider the Binomial Black‚ÄìScholes (BBS) method and also the Bino-
mial Black‚ÄìScholes method with Richardson extrapolation (BBSR) (see Broadie
and DeTemple (1996)). As with the control variate method discussed in the
previous section, both of these techniques can be used in conjunction with a
standard binomial lattice to improve the computed results.
We will Ô¨Årst discuss the BBS method.
The BBS method
The BBS method is identical to the standard binomial lattice except that in the
last time step (that is just before option maturity) the Black‚ÄìScholes formula is
used to calculate the option values at maturity. For an n time step binomial lat-
tice this involves evaluating the Black‚ÄìScholes formula at each of the n nodes in
the penultimate time step; see Fig. 5.1. In Code excerpt 5.13 we deÔ¨Åne the func-
tion bs_lattice which incorporates the BBS method into a standard binomial
lattice. The reader will have noticed that bbs_lattice is rather lax concern-
ing the amount of storage that is required; see Section 5.3.2. It uses an array of
size LN n rather than LSn to store the lattice asset prices; the modiÔ¨Åcation to
use an array of size LSn is left as an exercise.
The beneÔ¨Åts of using the BBS approach to price an American call are illus-
trated in Fig 5.3. Here we compare the results obtained using the function
bbs_lattice with those computed by the function standard_ lattice,
the standard binomial lattice of Code excerpt 5.11. It can be clearly seen that
the BBS method is signiÔ¨Åcantly more accurate than the standard binomial lattice
approach, in which option pricing error exhibits pronounced oscillations.

132
Computational Finance Using C and C#
void bbs_lattice(double *value, double greeks[], double S0, double X, double sigma, double T,_
double r,
double q, long put, long M, long *iflag)
{
/* Input parameters:
=================
S0
- the current price of the underlying asset
X
- the strike price
sigma
- the volatility
T
- the time to maturity
r
- the interest rate
q
- the continuous dividend yield
put
- if put is 0 then a call option, otherwise a put option
M
- the number of time steps
Output parameters:
==================
value
- the value of the option, greeks[] - the hedge statistics output as follows:_
greeks[0] is gamma,
greeks[1] is delta, greeks[2] is theta,
iflag
- an error indicator.
*/
.
.
.
/* allocate the arrays s[((M+2)*(M+1))/2], and v[M+1] */
dt = T/(double)M;
t1 = sigma*sqrt(dt);
u = exp(t1);
d = exp(-t1);
a = exp((r-q)*dt);
p = (a - d)/(u - d);
if ((p < zero) || (p > 1.0)) return; /* Invalid probability */
discount = exp(-r*dt);
p_u = p*discount;
p_d = (1.0-p)*discount;
jj = 0;
s[0] = S0;
/* The "higher" the value of jj, at a given time instant, the lower the
value of the_
asset price */
for (m1 = 1; m1 <= M-1; ++m1) { /* Calculate asset values up to (M-1)th time step */
for (n = m1; n >= 1; --n) {
++jj;
s[jj] =
u*s[jj-m1];
}
++jj;
s[jj] = d*s[jj-m1-1];
}
for (n = 0; n <= M-1; ++n) { /* Use Black-Scholes for the final step */
black_scholes(&temp,NULL,s[jj],X,sigma,dt,r,q,put,&iflagx);
v[n] = temp;
--jj;
}
for (m1 = M-1; m1 >= 3; --m1) { /* work backwards through the lattice */
for (n =0; n < m1; ++n) {
if ((v[n] == zero) && (v[n+1] == zero))
{
hold = zero;
}
else
hold = p_d*v[n] + p_u*v[n+1];
if (is_american) {
if (put)
v[n] = MAX(hold,X-s[jj]);
else
v[n] = MAX(hold,s[jj]-X);
}
else
v[n] = hold;
--jj;
}
}
/* The values v[0], v[1] & v[2] correspond to the nodes for m1 = 2, v1 & v2 correspond to_
the nodes for m1 = 1 and the
option value (*value) is the node for m1 = 0. For a given time step v[0] corresponds to_
the lowest asset price,
v[1] to the next lowest etc.. */
Code excerpt 5.13.

Single asset American options
133
hold = p_d*v[0] + p_u*v[1];
if (is_american) {
if (put)
v1 = MAX(hold,X-s[jj]);
else
v1 = MAX(hold,s[jj]-X);
}
else
v1 = hold;
--jj;
hold = p_d*v[1] + p_u*v[2];
if (is_american) {
if (put)
v2 = MAX(hold,X-s[jj]);
else
v2 = MAX(hold,s[jj]-X);
}
else
v2 = hold;
--jj;
hold = p_d*v1 + p_u*v2;
if (is_american) {
if (put)
*value = MAX(hold,X-s[0]);
else
*value = MAX(hold,s[0]-X);
}
else
*value = hold;
if(greeks) {
/* assign the value of delta (obtained from m1 = 1) */
greeks[1] = (v2-v1)/(s[1]-s[2]);
/*
assign the value of gamma (use the values at time step m1 = 2)
*/
dv1 = v[2] - v[1];
ds1 = s[3] - s[4];
dv2 = v[1] - v[0];
ds2 = s[4] - s[5];
h
= 0.5*(s[3] - s[5]);
greeks[0] = ((dv1/ds1) - (dv2/ds2))/h;
/* assign the value of theta */
greeks[2] = (v[1]-*value)/(2.0*dt);
}
}
Code excerpt 5.13 The function bbs_lattice which incorporates the BBS method
into a standard binomial lattice. The Black‚ÄìScholes formula is evaluated by using the
function black_scholes, given in Code excerpt 4.1.
The BBSR method
The BBSR method applies two point Richardson extrapolation to the com-
puted BBS values; for more information concerning Richardson extrapolation
see Marchuk and Shaidurov (1983). In this method the option price estimates
from two BBS lattices, with differing numbers of time steps, are combined to
form an improved estimate.
Here we use the following BBSR scheme to compute the value of an American
call option:
CBBSR(S, E, œÑ, 2n) = 4
3CBBS(S, E, œÑ, 2n) ‚àí1
3CBBS(S, E, œÑ, n)
(5.3.24)
where S is the current asset value, E is the strike price, œÑ is the option maturity,
CBBS(S, E, œÑ, n) is the value of the call option computed using a BBS lattice with
n time steps, CBBS(S, E, œÑ, 2n) is the value of the call option computed using a

134
Computational Finance Using C and C#
Figure 5.3 The error in the estimated value, est_val, of an American call using both a
standard binomial lattice and BBS binomial lattice. The parameters used were: T = 1.0,
S = 105.0, E = 105.0, r = 0.1, q = 0.02, œÉ = 0.3. The very accurate value (acc_val) was
16.1697, and was computed using a 6000 step standard binomial lattice. The error in
the estimated value was obtained as est_val ‚àíacc_val.
BBS lattice with 2n time steps, and CBBSR(S, E, œÑ, 2n) is the BBSR estimate. We
compute the value of an American put using:
PBBSR(S, E, œÑ, 2n) = 4
3PBBS(S, E, œÑ, 2n) ‚àí1
3PBBS(S, E, œÑ, n)
(5.3.25)
Figure 5.4 displays the computed BBSR results for an American call option
with S = 105.0, œÑ = 1.0, E = 105.0, q = 0.02 and œÉ = 0.3.
In Tables 5.5 and 5.6 the errors in computing both an American put and an
American call option are presented; the methods used are the standard binomial
lattice, the BBS lattice and the BBSR lattice. It can be seen that the BBSR lattice
gives the most accurate results. This is not surprising since, from Eqs. (5.3.24)
and (5.3.25) we see that when we use either an n time step standard binomial
lattice or an n time step BBS lattice the corresponding BBSR estimate is obtained
using both an n time step BBS lattice and also a 2n time step BBS lattice. One way
of checking whether Richardson extrapolation is providing increased accuracy
is to compare the results for a 2n time step BBS latticewith those for an n time
step BBSR lattice. Inspection of the results shows that Richardson extrapolation
has in fact led to an improvement. For example, in Table 5.5 the error for a 160

Single asset American options
135
Figure 5.4 The error in the estimated value, est_val, of an American call, using a BBSR
binomial lattice. The parameters used were: T = 1.0, S = 105.0, E = 105.0, r = 0.1,
q = 0.02, œÉ = 0.3. The very accurate value (acc_val) was 16.1697, and was computed
using a 6000 step standard binomial lattice. The error in the estimated value was ob-
tained as est_val ‚àíacc_val.
time step BBS lattice is 5.0869e-003, while that for an 80 time step BBSR
lattice is 3.5725e-003; in Table 5.6 the error for an 80 time step BBS lattice
is 6.3858e-003, and that for a 40 time step BBSR lattice is 3.5725e-003.
5.4
Grid methods for vanilla options
5.4.1
Introduction
In Section 5.3 we discussed the use of binomial lattice methods for valuing both
European and American options. The lattice methods we described have the
advantage that they are fairly easy to implement and can value simple options,
such as vanilla puts and calls, reasonably accurately. The use of up and down
jump probabilities at the lattice nodes is also an appealing feature, since they
are directly related to the stochastic process which is being modelled. However,
lattice techniques have the following drawbacks:
‚Ä¢ They require small time steps to ensure numerical stability

136
Computational Finance Using C and C#
Table 5.5 The pricing errors for an American call option computed by: a standard
binomial lattice, a BBS lattice and also a BBSR lattice
n steps
Standard lattice
BBS lattice
BBSR lattice
20
‚àí1.5075e‚àí001
3.6187e‚àí002
1.2754e‚àí002
30
‚àí1.0057e‚àí001
2.4526e‚àí002
8.6771e‚àí003
40
‚àí7.5382e‚àí002
1.8612e‚àí002
6.6361e‚àí003
50
‚àí6.0244e‚àí002
1.5036e‚àí002
5.4109e‚àí003
60
‚àí5.0141e‚àí002
1.2639e‚àí002
4.5939e‚àí003
70
‚àí4.2919e‚àí002
1.0922e‚àí002
4.0103e‚àí003
80
‚àí3.7499e‚àí002
9.6302e‚àí003
3.5725e‚àí003
90
‚àí3.3282e‚àí002
8.6236e‚àí003
3.2320e‚àí003
100
‚àí2.9908e‚àí002
7.8171e‚àí003
2.9596e‚àí003
110
‚àí2.7146e‚àí002
7.1565e‚àí003
2.7367e‚àí003
120
‚àí2.4844e‚àí002
6.6053e‚àí003
2.5509e‚àí003
130
‚àí2.2896e‚àí002
6.1385e‚àí003
2.3938e‚àí003
140
‚àí2.1226e‚àí002
5.7382e‚àí003
2.2590e‚àí003
150
‚àí1.9778e‚àí002
5.3909e‚àí003
2.1423e‚àí003
160
‚àí1.8511e‚àí002
5.0869e‚àí003
2.0401e‚àí003
170
‚àí1.7393e‚àí002
4.8186e‚àí003
1.9500e‚àí003
180
‚àí1.6399e‚àí002
4.5799e‚àí003
1.8698e‚àí003
190
‚àí1.5510e‚àí002
4.3663e‚àí003
1.7981e‚àí003
200
‚àí1.4710e‚àí002
4.1740e‚àí003
1.7336e‚àí003
The pricing error is deÔ¨Åned as estimated value ‚àíaccurate value, where the accurate
value, 16.1697, was obtained by using a 6000 step standard binomial lattice. The option
parameters used were: T = 1.0, S = 105.0, E = 105.0, r = 0.1, q = 0.02, and œÉ = 0.3.
‚Ä¢ There is little control over where the lattice nodes are located. This can lead
to very poor accuracy when valuing certain types of options; for example,
those with barriers at particular asset prices.
One method of avoiding these limitations is through the use of Ô¨Ånite-difference
grids. Although this approach no longer has the probabilistic interpretation of
the binomial lattice it has the following advantages:
‚Ä¢ Fewer time steps are required to ensure numerical stability
‚Ä¢ There is complete control over the placement of grid lines, and their associ-
ated grid nodes.
5.4.2
Uniform grids
The Black‚ÄìScholes equation for the value of an option f is given by:
‚àÇf
‚àÇt + (r ‚àíq)S ‚àÇf
‚àÇS + 1
2œÉ 2S2 ‚àÇ2f
‚àÇS2 = rf
(5.4.1)
We want to solve this equation over the duration of the option, that is from
the current time t to the maturity of the option at time t + œÑ. To do this we

Single asset American options
137
Table 5.6 The pricing errors for an American put option computed by: a standard
binomial lattice, a BBS lattice and also a BBSR lattice
n steps
Standard lattice
BBS lattice
BBSR lattice
20
‚àí6.1971e‚àí002
2.3917e‚àí002
7.6191e‚àí003
30
‚àí4.1648e‚àí002
1.6800e‚àí002
6.0465e‚àí003
40
‚àí3.2264e‚àí002
1.1694e‚àí002
4.6165e‚àí003
50
‚àí2.6538e‚àí002
8.4790e‚àí003
4.2654e‚àí003
60
‚àí2.1069e‚àí002
8.7348e‚àí003
3.2946e‚àí003
70
‚àí1.8298e‚àí002
7.2743e‚àí003
2.9633e‚àí003
80
‚àí1.5885e‚àí002
6.3858e‚àí003
2.6088e‚àí003
90
‚àí1.3977e‚àí002
5.9417e‚àí003
2.2099e‚àí003
100
‚àí1.2612e‚àí002
5.3188e‚àí003
2.1793e‚àí003
110
‚àí1.1338e‚àí002
4.9652e‚àí003
2.0992e‚àí003
120
‚àí1.0239e‚àí002
4.6547e‚àí003
1.8723e‚àí003
130
‚àí9.5208e‚àí003
4.1505e‚àí003
1.8808e‚àí003
140
‚àí8.6142e‚àí003
4.0411e‚àí003
1.7505e‚àí003
150
‚àí8.2382e‚àí003
3.6020e‚àí003
1.7341e‚àí003
160
‚àí7.5811e‚àí003
3.5531e‚àí003
1.6411e‚àí003
170
‚àí7.1097e‚àí003
3.3726e‚àí003
1.5507e‚àí003
180
‚àí6.7887e‚àí003
3.1428e‚àí003
1.5478e‚àí003
190
‚àí6.3033e‚àí003
3.1345e‚àí003
1.4134e‚àí003
200
‚àí6.0276e‚àí003
2.9642e‚àí003
1.3973e‚àí003
The pricing error is deÔ¨Åned as estimated value ‚àíaccurate value, where the accurate
value, 9.2508, was obtained by using a 6000 step standard binomial lattice. The option
parameters used were: T = 1.0, S = 105.0, E = 105.0, r = 0.1, q = 0.02, and œÉ = 0.3.
will use a grid in which the asset price S takes ns uniformly spaced values,
Sj = jS, j = 0, . . . , ns ‚àí1, where S is the spacing between grid points. If
Smax is the maximum asset value we want to represent, then the grid spacing,
S‚àó, can be simply calculated as:
S‚àó= Smax
ns ‚àí1
(5.4.2)
However, since we would like to solve the option values and Greeks at the
current asset price S0, we would also like an asset grid line to coincide with
the current asset price. This avoids the use of interpolation which is necessary
when the asset value does not correspond to a grid line. The method by which
we achieve this is outlined in Code excerpt 5.12. Here the user supplies the
function opt_gfd with values for Smax and ns ‚àí1 from which S‚àóis computed
using Eq. (5.4.2). We then Ô¨Ånd the integer, n1, that is just below (or equal to)
the value S0/S‚àó, and use this to obtain a new grid spacing S = S0/n1. This
leads to the new asset price discretization Sj = jS, j = 0, . . . , ns ‚àí1, where
we have now ensured that Sn1 = S0.

138
Computational Finance Using C and C#
The user also supplies the function opt_gfd with the number of time inter-
vals for the grid. When there are nt time intervals, the grid has nt + 1 uniformly
spaced time instants, ti = it, i = 0, . . . , nt, and the time step is simply:
t = œÑ
nt
(5.4.3)
As with the binomial lattice methods we will solve the equation backwards in
time from maturity (at time t + œÑ) to the present (time t). So as we solve the
equation the time index will start at i = nt (time t + œÑ) and decrease to i = 0
(current time t).
Here we discuss the grid method of solving the Black‚ÄìScholes equation in
terms of:
‚Ä¢ The Ô¨Ånite-difference approximation
‚Ä¢ The boundary conditions
‚Ä¢ Computation of the option values at a given time instant
‚Ä¢ Backwards iteration and early exercise
Each of these aspects will now be considered in turn.
The Ô¨Ånite-difference approximation
The option value corresponding to the grid node at which ti = it and Sj =
jS will be denoted by fi,j. We will approximate the partial derivative of fi,j
with respect to time simply as:
‚àÇf
‚àÇt = fi+1,j ‚àífi,j
t
(5.4.4)
For the other terms in Eq. (5.4.1) we will use the weighted, Œòm, method. This
technique involves selecting an appropriate choice for Œòm in the range 0 ‚©Ω
Œòm ‚©Ω1 so that the contribution from node (i, j) is a weighted sum involving
the values at nodes (i, j) and (i+1, j). For instance, the term rf |i,j in Eq. (5.4.1)
is approximated as:
rf |i,j = r

Œòmfi+1,j + (1 ‚àíŒòm)fi,j

(5.4.5)
and the term ‚àÇf
‚àÇS |i,j in Eq. (5.4.1) is approximated as:
‚àÇf
‚àÇS
    
i,j
=

Œòm
‚àÇf
‚àÇS
    
i+1,j
+ (1 ‚àíŒòm)‚àÇf
‚àÇS
    
i,j

(5.4.6)
Using this method we thus obtain, at node (i, j), the following discretized ver-
sion of Eq. (5.4.1):
fi+1,j ‚àífi,j
t
+ (r ‚àíq)Sj

Œòmf ‚Ä≤
i+1,j + Œò‚àó
mf ‚Ä≤
i,j

+ 1
2œÉ 2S2
j

Œòmf ‚Ä≤‚Ä≤
i+1,j + Œò‚àó
mf ‚Ä≤‚Ä≤
i,j

= r

Œòmfi+1,j + Œò‚àó
mfi,j

(5.4.7)

Single asset American options
139
where for compactness we have written Œò‚àó
m = 1 ‚àíŒòm, and denote the partial
derivatives w.r.t. S at node (i, j) as: f ‚Ä≤
i,j = ‚àÇf
‚àÇS |i,j and f ‚Ä≤‚Ä≤
i,j = ‚àÇ2f
‚àÇS2 |i,j.
Finite-difference approximations for these derivatives can be obtained by
considering a Taylor expansion about the point fi,j. We proceed as fol-
lows:
fi,j+1 = fi,j + f ‚Ä≤
i,jS + 1
2f ‚Ä≤‚Ä≤
i,j(S)2
(5.4.8)
fi,j‚àí1 = fi,j ‚àíf ‚Ä≤
i,jS + 1
2f ‚Ä≤‚Ä≤
i,j(S)2
(5.4.9)
Subtracting Eq. (5.4.9) from Eq. (5.4.8) we obtain:
fi,j+1 ‚àífi,j‚àí1 = 2f ‚Ä≤
i,jS
and so
f ‚Ä≤
i,j = fi,j+1 ‚àífi,j‚àí1
2S
(5.4.10)
Adding Eqs. (5.4.9) and (5.4.8) we obtain:
fi,j+1 + fi,j‚àí1 = 2fi,j + f ‚Ä≤‚Ä≤
i,jS2
which gives:
f ‚Ä≤‚Ä≤
i,j = fi,j+1 ‚àí2fi,j + fi,j‚àí1
S2
(5.4.11)
The complete Ô¨Ånite-difference approximation to the Black‚ÄìScholes equation can
then be found by substituting the approximations for the Ô¨Årst and second par-
tial derivatives, given in Eqs. (5.4.10) and (5.4.11), into (5.4.7). We thus ob-
tain:
rt

Œòmfi+1,j + Œò‚àó
mfi,j

= fi+1,j ‚àífi,j + (r ‚àíq)jtA1
2
+ œÉ 2j2tA2
2
(5.4.12)
where we have used the fact that Sj = jS, and for compactness have deÔ¨Åned
the terms:
A1 = Œòmfi+1,j+1 ‚àíŒòmfi+1,j‚àí1 + Œò‚àó
mfi,j+1 ‚àíŒò‚àó
mfi,j‚àí1
and
A2 = Œòmfi+1,j+1 + Œòmfi+1,j‚àí1 ‚àí2Œòmfi+1,j + Œò‚àó
mfi,j+1
+ Œò‚àó
mfi,j‚àí1 ‚àí2Œò‚àó
mfi,j
Collecting like terms in fi,j, fi+1,j, etc. results in:
B1fi,j‚àí1 + B2fi,j + B3fi,j+1 + C1fi+1,j‚àí1 + C2fi+1,j
+ C3fi+1,j+1 = 0
(5.4.13)

140
Computational Finance Using C and C#
where
B1 = ‚àíŒò‚àó
m(r ‚àíq)jt
2
+ Œò‚àó
mœÉ 2j2t
2
B2 = ‚àí1 ‚àírtŒò‚àó
m ‚àíŒò‚àó
mœÉ 2j2t
B3 = Œò‚àó
m(r ‚àíq)jt
2
+ Œò‚àó
mœÉ 2j2t
2
C1 = ŒòmœÉ 2j2t
2
‚àíŒòm(r ‚àíq)jt
2
C2 = 1 ‚àírtŒòm ‚àíŒòmœÉ 2j2t
C3 = Œòm(r ‚àíq)jt
2
+ ŒòmœÉ 2j2t
2
Since we are solving the equation backwards in time and we want to de-
termine the option values at time index i from the known option values
(fi+1,j+1, fi+1,j and fi+1,j‚àí1) at time index i + 1. This can be achieved by
rearranging Eq. (5.4.13) as follows:
ajfi,j‚àí1 + bjfi,j + cjfi,j+1 = Ri+1,j
(5.4.14)
where the right-hand side, Ri+1,j, is:
Ri+1,j = ¬Øajfi+1,j‚àí1 + ¬Øbjfi+1,j + ¬Øcjfi+1,j+1
(5.4.15)
The six coefÔ¨Åcients are:
aj = (1 ‚àíŒòm)t
2

(r ‚àíq)j ‚àíœÉ 2j2
(5.4.16)
bj = 1 + (1 ‚àíŒòm)t

r + œÉ 2j2
(5.4.17)
cj = ‚àí(1 ‚àíŒòm)t
2

(r ‚àíq)j + œÉ 2j2
(5.4.18)
¬Øaj = ‚àíŒòm
t
2

(r ‚àíq)j ‚àíœÉ 2j2
(5.4.19)
¬Øbj = 1 ‚àíŒòmt

r + œÉ 2j2
(5.4.20)
¬Øcj = Œòm
t
2

(r ‚àíq)j + œÉ 2j2
(5.4.21)
For each value of j Eq. (5.4.14) gives us a relationship between three option
values, fi+1,j‚àí1, fi+1,j, fi+1,j+1 at time index i + 1, and three option values
fi,j‚àí1, fi,j, fi,j+1 at time index i.
This situation is shown in Fig. 5.5 where we have labelled the grid nodes that
contribute to the option value f5,5 at grid node E. These are the known option
values:
node A: f6,6,
node B: f6,5,
and
node C: f6,4

Single asset American options
141
and the unknown option values
node D: f5,6,
node E: f5,5,
and
node F: f5,4.
Before we solve Eq. (5.4.14), we will brieÔ¨Çy consider its characteristics for dif-
ferent values of the weight parameter Œòm.
When Œòm = 1 the values of the coefÔ¨Åcients in Eq. (5.4.14) are aj = cj = 0,
and bj = 1. This means that Eq. (5.4.14) reduces to:
fi,j = ¬Øajfi+1,j‚àí1 + ¬Øbjfi+1,j + ¬Øcjfi+1,j+1
This is termed the explicit method, and it can be seen that the unknown option
value fi,j, at the grid node (i, j) is just a weighted sum of the (known) op-
tion values fi+1,j‚àí1, fi+1,j, fi+1,j+1. This is the simplest situation to deal with
and actually corresponds to a trinomial lattice. However, it has poor numerical
properties and usually requires a very small step size to obtain accurate results;
see Smith (1985).
When Œòm Ã∏= 1, the unknown option value fi,j depends not only on the
known option values fi+1,j‚àí1, fi+1,j, fi+1,j+1 (as in the explicit method above),
but also on the neighboring unknown option values fi,j‚àí1 and fi,j+1. It is
now necessary to solve a set of simultaneous equations in order to com-
pute the value fi,j. This is therefore called an implicit method; see Smith
(1985).
The implicit method Œòm
= 0 is also called the fully implicit method,
since now the unknown value fi,j only depends on the neighboring values
fi,j‚àí1, fi,j+1, and its previous value, fi+1,j, at time step i + 1. This can
be shown by substituting Œòm = 0 in Eqs. (5.4.16)‚Äì(5.4.21). We then ob-
tain ¬Øaj
=
¬Øcj
= 0, and ¬Øbj
= 1, which means that Eq. (5.4.14) reduces
to:
ajfi,j‚àí1 + bjfi,j + cjfi,j+1 = fi+1,j
The implicit method Œòm = 0.5 is also termed the Crank‚ÄìNicolson method.
This method, Ô¨Årst used by John Crank and Phyliss Nicolson in 1946 (see
Crank and Nicolson (1947)), computes fi,j by giving equal weight to the con-
tributions from time step i + 1 and time step i. Substituting Œòm = 0.5 in
Eq. (5.4.16) to Eq. (5.4.21) we obtain the following Crank‚ÄìNicolson coefÔ¨Å-
cients:
aj = ‚àí¬Øaj = t
4

(r ‚àíq)j ‚àíœÉ 2j2
bj = 1 + t
2

r + œÉ 2j2
¬Øbj = 1 ‚àít
2

r + œÉ 2j2
cj = ‚àí¬Øcj = ‚àít
4

(r ‚àíq)j + œÉ 2j2
We notice that since we are solving backwards in time, but index time in the
forward direction, our values of Œòm corresponding to implicit and explicit are

142
Computational Finance Using C and C#
different from those normally used. For example, in Smith (1985) Œòm = 0 is
the explicit method and Œòm = 1 is the implicit method; the Crank‚ÄìNicolson
method is still Œòm = 0.5.
The boundary conditions
In order to solve Eq. (5.4.14) at time instant it we need to obtain the option
values at: the upper asset boundary, the lower asset boundary, and the initial
values that are speciÔ¨Åed at option maturity.
Here we calculate the boundary values by using the time independent payoff,
pj, at the jth asset index within the grid. If E is the strike price then vanilla call
options have payoffs:
pj = max(jS ‚àíE, 0),
j = 0, . . . , ns ‚àí1,
and vanilla put options have payoffs:
pj = max(E ‚àíjS, 0),
j = 0, . . . , ns ‚àí1
Upper asset boundary values
At the upper boundary j = ns ‚àí1 and (ns ‚àí1)S = Smax; where we note that
for the grid to be useful we require Smax > E.
Here we assume that Smax > E and so for call options:
pns‚àí1 = Smax ‚àíE
and for put options:
pns‚àí1 = 0
The option value at the upper boundary, denoted by fBU, is set to pns‚àí1, and
we have fi,ns‚àí1 = fBU, i = 0, . . . , nt.
Lower asset boundary values
At the lower boundary j = 0, and the value of jS is zero.
So for call options:
p0 = 0
and for put options:
p0 = E
The option value at the lower boundary, denoted by fBL, is set to p0, and we
have fi,0 = fBL, i = 0, . . . , nt.
Boundary values at option maturity
At option maturity (i = nt) the initial option (boundary) values are the pre-
viously mentioned payouts. If E is the strike price then for vanilla call op-
tions:
fnt,j = max(jS ‚àíE, 0),
j = 0, . . . , ns ‚àí1,

Single asset American options
143
and for vanilla put options:
fnt,j = max(E ‚àíjS, 0),
j = 0, . . . , ns ‚àí1
This is illustrated in Fig. 5.5 for a vanilla put option with current asset value
S0 = 20, strike, E = 25, and maturity œÑ = 2. The grid asset price spacing is
S = 5, and the time increment is t = 0.2. At option maturity, corresponding
to time index i = 10, the value of the put option is zero for all asset indices
j ‚©æ5.
Computation of the option values at a given time instant
Having found the option boundary values, we are now in a position to solve
Eq. (5.4.14) at time instant ti = it.
First we note that since fi,0 = fBL and fi,ns‚àí1 = fBU Eq. (5.4.14) only needs
to be solved for values of the asset index j in the range j = 1 to j = ns ‚àí2.
We now deal with the following situations:
‚Ä¢ Case 1: j = 1, the asset grid line just above the lower boundary
‚Ä¢ Case 2: j = ns ‚àí2, the asset grid line just below the upper boundary
‚Ä¢ Case 3: all other asset grid lines not included in Case 1 or Case 2
and consider the form that Eq. (5.4.14) takes under each condition.
Case 1: j = 1
Substituting j = 1 into Eq. (5.4.14) we obtain:
a1fi,0 + b1fi,1 + c1fi,2 = ¬Øa1fi+1,0 + ¬Øb1fi+1,1 + ¬Øc1fi+1,2
Now, since fi,0 = fBL, this becomes:
b1fi,1 + c1fi,2 = (¬Øa1 ‚àía1)fBL + ¬Øb1fi+1,1 + ¬Øc1fi+1,2
or equivalently:
b1fi,1 + c1fi,2 = Ri+1,1
(5.4.22)
where
Ri+1,1 = (¬Øa1 ‚àía1)fBL + ¬Øb1fi+1,1 + ¬Øc1fi+1,2
(5.4.23)
Case 2: j = ns ‚àí2
Substituting j = ns ‚àí1 into Eq. (5.4.14) we obtain:
ans‚àí2fi,ns‚àí3 + bns‚àí2fi,ns‚àí2 + cns‚àí2fi,ns‚àí1
= ¬Øans‚àí2fi+1,ns‚àí3 + ¬Øbns‚àí2fi+1,ns‚àí2 + ¬Øcns‚àí2fi+1,ns‚àí1
Since fi,ns‚àí1 = fBU this gives:
ans‚àí2fi,ns‚àí3 + bns‚àí2fi,ns‚àí2
= ¬Øans‚àí2fi+1,ns‚àí3 + ¬Øbns‚àí2fi+1,ns‚àí2 + (¬Øcns‚àí2 ‚àícns‚àí2)fBU

144
Computational Finance Using C and C#
or equivalently:
ans‚àí2fi,ns‚àí3 + bns‚àí2fi,ns‚àí2 = Ri+1,ns‚àí2
(5.4.24)
where
Ri+1,ns‚àí2 = ¬Øans‚àí2fi+1,ns‚àí3 + ¬Øbns‚àí2fi+1,ns‚àí2 + (¬Øcns‚àí2 ‚àícns‚àí2)fBU (5.4.25)
Case 3
In this case the boundary values do not enter into the expressions, and we
simply restate Eq. (5.4.14) as:
ajfi,j‚àí1 + bjfi,j + cjfi,j+1 = Ri+1,j,
j = 3, . . . , ns ‚àí3,
(5.4.26)
where as before the right-hand side, Ri+1,j, is:
Ri+1,j = ¬Øajfi+1,j‚àí1 + ¬Øbjfi+1,j + ¬Øcjfi+1,j+1
(5.4.27)
We can now gather all the information in Eqs. (5.4.23)‚Äì(5.4.27) and represent
it by the following tridiagonal system:
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éù
b1
c1
0
0
0
0
a2
b2
c2
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0
ans‚àí3
bns‚àí3
cns‚àí3
0
0
0
0
ans‚àí2
bns‚àí2
‚éû
‚éü‚éü‚éü‚éü‚éü‚é†
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éù
fi,1
fi,2
.
.
fi,ns‚àí3
fi,ns‚àí2
‚éû
‚éü‚éü‚éü‚éü‚éü‚é†
=
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éù
Ri+1,1
Ri+1,2
.
.
Ri+1,ns‚àí3
Ri+1,ns‚àí2
‚éû
‚éü‚éü‚éü‚éü‚éü‚é†
(5.4.28)
In matrix notation Eq. (5.4.28) can be written as:
Ax = R
(5.4.29)
where A is the (ns ‚àí2) √ó (ns ‚àí2) tridiagonal matrix containing the known
coefÔ¨Åcients aj, j = 2, . . . , ns ‚àí2, bj, j = 1, . . . , ns ‚àí2, and cj, j = 1, . . . , ns ‚àí3.
The vector R denotes the known right-hand side, Ri+1,j, j = 1, . . . , ns ‚àí2,
and the vector x contains the unknown option values that we wish to compute,
fi,j, j = 1, . . . , ns ‚àí2.
It is well known that, if matrix A is nonsingular, Eq. (5.4.29) can be solved
using an LU decomposition. Here we factorize the n √ó n matrix A as:
A = LU
where L is an n √ó n lower triangular matrix with 1s on the diagonal and U is
an n √ó n upper triangular matrix. We illustrate the LU decomposition for a full
4 √ó 4 matrix below:

Single asset American options
145
‚éõ
‚éú‚éù
a1,1
a1,2
a1,3
a1,4
a2,1
a2,2
a2,3
a2,4
a3,1
a3,2
a3,3
a3,4
a4,1
a4,2
a4,3
a4,4
‚éû
‚éü‚é†
=
‚éõ
‚éú‚éù
1
0
0
0
l2,1
1
0
0
l3,1
l3,2
1
0
l4,1
l4,2
l4,3
1
‚éû
‚éü‚é†
‚éõ
‚éú‚éù
u1,1
u1,2
u1,3
u1,4
0
u2,2
u2,3
u2,4
0
0
u3,3
u3,4
0
0
0
u4,4
‚éû
‚éü‚é†
(5.4.30)
If A is a tridiagonal matrix then the LU decomposition takes the simpler form:
‚éõ
‚éú‚éù
a1,1
a1,2
0
0
a2,1
a2,2
a2,3
0
0
a3,2
a3,3
a3,4
0
0
a4,3
a4,4
‚éû
‚éü‚é†
=
‚éõ
‚éú‚éù
1
0
0
0
l2,1
1
0
0
0
l3,2
1
0
0
0
l4,3
1
‚éû
‚éü‚é†
‚éõ
‚éú‚éù
u1,1
u1,2
0
0
0
u2,2
u2,3
0
0
0
u3,3
u3,4
0
0
0
u4,4
‚éû
‚éü‚é†
(5.4.31)
where it can be seen that now both L and U are bidiagonal.
Once the LU decomposition of A has been found, it is possible to solve for
x in Eq. (5.4.29) by using a two stage method (see for example Golub and Van
Loan (1989)). Here forward elimination is used to solve Ly = R, and then
back-substitution is applied to Ux = y. We can thus write the procedure as:
Ax = (LU)x = L(Ux) = Ly = R
We will now provide code excerpts which show how to solve the (ns ‚àí2) √ó
(ns ‚àí2) tridiagonal system represented by Eq. (5.4.29). These excerpts are in
fact contained within the larger Code excerpt 5.18, which displays the complete
C code for the option pricing function opt_gfd. If the reader requires more
detail concerning the precise code used for option pricing, then this code should
be consulted. (It should be noted that in Code excerpt 5.18, time is indexed
using j and asset price using index i. We have modiÔ¨Åed the indices for the
smaller code excerpts given below so that, as might be expected, time is indexed
using i, and asset price using j. The author apologizes for any inconvenience
this may cause.) Here, for brevity, we will assume that all the required arrays
have already been allocated and loaded with the relevant information.
First we need to compute the LU decomposition of the tridiagonal matrix A.
The code to achieve this is given in Code excerpt 5.14. Here we use the following
three arrays to store the elements of the tridiagonal matrix A: array b contains
the diagonal elements, array c contains the upper diagonal elements, and array a
holds the lower diagonal elements.
It should be noted we do not explicitly compute the elements of the matrix L.
This is because all the diagonal elements of L are known to be 1, and the sub-
diagonal elements of L can be computed from the diagonal elements of U by
using l[j] = a[j]/u[j-1]. Also we do not need to compute the upper di-
agonal elements of U since they are known to be the same as the upper diagonal

146
Computational Finance Using C and C#
u[1] = b[1];
if (u[1] == 0.0) printf ("ERROR in array u \n");
for(j=2; j <=ns-2; ++j) {
u[j] = b[j] - a[j]*c[j-1]/u[j-1];
if (u[j] == 0.0) printf ("ERROR in array u \n");
}
Code excerpt 5.14 Computer code that calculates the diagonal elements of the matrix U,
in an LU decomposition of a tridiagonal matrix A. The elements of matrix A are stored
in the following arrays: array b contains the diagonal elements, array c contains the
upper diagonal elements, and array a holds the lower diagonal elements. The diagonal
elements of U are stored in the array u for later use, in Code excerpts 5.15 and 5.16.
work[1] = rhs[1];
for(j=2; j<=ns-2; ++j) {
work[j] = rhs[j] - a[j]*work[j-1]/u[j-1];
}
Code excerpt 5.15 Computer code that uses forward elimination to solve the lower tri-
angular system Ly = R, where y is stored in the array work.
opt_vals[ns-2] = work[ns-2]/u[ns-2];
for(j = ns-2; j >= 1; --j)
opt_vals[j] = (work[j] - c[j]*opt_vals[j+1])/u[j];
Code excerpt 5.16 Computer code that uses back-substitution to solve the upper trian-
gular system Ux = y. At time instant ti = it, the elements of x are the calculated option
values fi,j, i = 1, . . . , ns‚àí2.
elements of the original matrix A, and are contained in the array c; see for
example Hager (1988).
Having computed the LU decomposition we can now solve the lower tri-
angular system Ly = R using forward elimination; this is shown in Code ex-
cerpt 5.15.
In Code excerpt 5.15 we make use of the following two arrays: the array rhs
which is used to store the elements of the right-hand side R, and the array work
which is both used as workspace and to store the computed solution vector y.
As previously mentioned the subdiagonal elements of L are given by l[j] =
a[j]/u[j-1]. This means that in Code excerpt 5.15, the line:
work[j] = rhs[j] ‚àía[j] ‚àówork[j ‚àí1]/u[j ‚àí1];
is in fact equivalent to:
work[j] = rhs[j] ‚àíl[j] ‚àówork[j ‚àí1];
where l[j],j=2,..,ns-2, contains the subdiagonal elements of L, if we had
(needlessly) decided to allocate space for an extra array called l.
We are now in a position to solve the triangular system Ux = y by using back-
substitution. The code to achieve this is given in Code excerpt 5.16. Here the
array work contains the previously computed values of y, the diagonal elements
of U are contained in the array u, and (as previously mentioned) the upper
diagonal elements of U are stored in the array a.

Single asset American options
147
In Code excerpt 5.16 the array opt_vals contains the solution vector x. As
its name suggests the contents of the array opt_vals are in fact the computed
option values, fi,j, j = 1, . . . , ns ‚àí2, in Eq. (5.4.28) and represent the solution
of the Black‚ÄìScholes partial differential equation at time instant ti = it based
on the previously computed option values fi+1,j, j = 1, . . . , ns ‚àí2.
Backwards iteration and early exercise
The Black‚ÄìScholes equation can be solved over the time interval t to t+œÑ by iter-
atively solving Eq. (5.4.28). We iterate backwards in time by solving Eq. (5.4.28)
at the ith time step and then using the computed values to solve Eq. (5.4.28) for
the (i ‚àí1)th time step. The option values at current time t are obtained when
time index i = 0 is reached. It can be seen that the grid method yields ns ‚àí2
option values, f0,j, j = 1, . . . , ns ‚àí2, which correspond to the current asset
prices:
Sj
0 = jS,
j = 1, . . . , ns ‚àí2
As previously mentioned the asset price S0 coincides with grid index j = n1.
Therefore S0 = Sn1
0 , and the option value for the current asset price S0 is given
by f0,n1.
This is in contrast to the lattice methods discussed in Chapter 4, which yield
a single option value corresponding to the root node.
The option values obtained using the grid methods we have just described
are for vanilla European options. However, vanilla European options can
be more accurately valued by using the Black‚ÄìScholes option pricing for-
mula discussed in Chapter 4. The importance of Ô¨Ånite difference grids is
that, by slightly modifying our backward iterative method, we can take
into account the possibility of early exercise, and thus price American op-
tions.
This can be achieved by using Code excerpt 5.17 to modify the option prices
contained in the array opt_vals as follows:
if (put) {
/* a put */
for(j=1; j<=ns-2; ++j)
opt_vals[j] = MAX(opt_vals[j],E-s[j]);
}
else { /* a call */
for(j=1; j<=ns-2; ++j)
opt_vals[j] = MAX(opt_vals[j],s[j]-E);
}
Code excerpt 5.17 Computer code that modiÔ¨Åes the computed option values contained
in array opt_vals to include the possibility of early exercise; this is required if we are
to determine the value of American options. Here s[j] contains the asset value at asset
index j, opt_vals[j] contains the option value (computed by Code excerpt 5.16) at
asset index j, and E is the strike price.

148
Computational Finance Using C and C#
Figure 5.5 An example uniform grid, which could be used to estimate the value of a
vanilla option which matures in two years‚Äô time. The grid parameters are: ns = nt = 10,
t = 0.2, S = 5, and Smax = 50. The option parameters are E = 25, S0 = 20, and
œÑ = 2.0. As usual we denote the grid node option values by fi,j, where i is the time index
and j is the asset index. The option values of the grid nodes at maturity for a vanilla put
are thus labelled as val, f10,j , j = 0, . . . , 10, where val is the value of the option at the
node; these are shown on the right-hand grid boundary. Since E = 25 only those nodes
with j < 5 have nonzero option values.
Now that we know how to solve the Black‚ÄìScholes equation it is possible to
include, without much difÔ¨Åculty, more exotic features such as lock out periods,
barriers, rebates, etc.
The routine opt_gfd solves the Black‚ÄìScholes equation using a uniform grid.
The asset price is set to one of the grid lines, which means that interpolation is
not required.
5.4.3
Nonuniform grids
In the previous section we showed how to solve the Black‚ÄìScholes equation
using a uniform grid. Although this approach will provide satisfactory solutions
to many option pricing problems, there are situations in which it is important to
be able to place grid lines at locations that do not correspond to those available
in a uniform grid. Increasing the density of grid lines in regions of interest can
lead to improved accuracy in both the estimated option values and also the
estimates of the hedge statistics (the Greeks).
Here we provide an example which illustrates the beneÔ¨Åts of using a nonuni-
form grids in the evaluation of down and out call barrier options. Later on in

Single asset American options
149
Section 5.4.6 we give a further example which shows the use of nonuniform
grids to evaluate double barrier options.
The purpose of this section is to show how to discretize the Black‚ÄìScholes
equation using a nonuniform grid, and to derive an expression (see Eq. (5.4.39))
that is equivalent to Eq. (5.4.14). Although the tridiagonal system of equa-
tions we have to solve in this section will be different from that in Section
5.4, the solution method is exactly the same. This means that once we have
derived Eq. (5.4.39) all the other information which we require to evaluate
both European and American options is available in Section 5.4 under the head-
ings:
‚Ä¢ The boundary conditions
‚Ä¢ Computation of the option values at a given time instant
‚Ä¢ Backwards iteration and early exercise.
We will now consider the Ô¨Ånite-difference approximation for a nonuniform
grid, and then show how to value the down and out call barrier option.
The Ô¨Ånite-difference approximation
Here we consider how to discretize the Black‚ÄìScholes equation using a nonuni-
form grid, in which both the asset price interval S and the time step t are
not constant but can vary throughout the grid.
Allowing for a nonconstant time step is quite simple. The time step oc-
curs in both the Ô¨Årst derivative fi,j (see Eq. (5.4.4)) and in the option value
equations (see Eqs. (5.4.14)‚Äì(5.4.21)) as the constant t. To incorporate a
varying time step, ti, i = 0, nt, thus only requires setting t = ti, at the
ith time step and then continuing with the solution method outlined in Sec-
tion 5.4.
The incorporation of nonconstant asset price intervals requires more work.
This is because the Ô¨Ånite-difference approximations to the Ô¨Årst and second deriv-
atives f ‚Ä≤
i,j and f ‚Ä≤‚Ä≤
i,j, in Eqs. (5.4.10) and (5.4.11) are based on a Taylor expansion
about the point fi,j.
We will now derive expressions for these derivatives.
If we let X‚àí
j
= Sj ‚àíSj‚àí1 and X+
j
= Sj+1 ‚àíSj and then use a Taylor
expansion about fi+1,j we have
fi+1,j+1 = fi+1,j + f ‚Ä≤
i+1,jX+
j + 1
2f ‚Ä≤‚Ä≤
i+1,j

X+
j
2
(5.4.32)
and also
fi+1,j‚àí1 = fi+1,j ‚àíf ‚Ä≤
i+1,jX‚àí
j + 1
2f ‚Ä≤‚Ä≤
i+1,j

X‚àí
j
2
(5.4.33)
Multiplying Eq. (5.4.32) by X‚àí
j and adding it to X+
j times Eq. (5.4.33), gives
X+
j fi+1,j‚àí1 + X‚àí
j fi+1,j+1
= X‚àí
j fi+1,j + X+
j fi+1,j + 1
2f ‚Ä≤‚Ä≤
i+1,j

X+
j
2X‚àí
j +

X‚àí
j
2X+
j


150
Computational Finance Using C and C#
Therefore
1
2f ‚Ä≤‚Ä≤
i+1,j =
X+
j fi+1,j‚àí1 + X‚àí
j fi+1,j+1 ‚àíX‚àí
j fi+1,j ‚àíX+
j fi+1,j
(X+
j )2X‚àí
j + (X‚àí
j )2X+
j
So
f ‚Ä≤‚Ä≤
i+1,j =
2{X+
j fi+1,j‚àí1 + X‚àí
j fi+1,j+1 ‚àífi+1,j(X‚àí
j + X+
j )}
(X+
j )2X‚àí
j + (X‚àí
j )2X+
j
(5.4.34)
To calculate f ‚Ä≤
i+1,j we rearrange Eq. (5.4.33) to obtain
‚àíf ‚Ä≤
i+1,jX‚àí
j = fi+1,j‚àí1 ‚àífi+1,j ‚àí1
2f ‚Ä≤‚Ä≤
i+1,j

X‚àí
j
2
and
f ‚Ä≤
i+1,j = fi+1,j ‚àífi+1,j‚àí1
X‚àí
j
+ 1
2f ‚Ä≤‚Ä≤
i+1,jX‚àí
j
(5.4.35)
If we now substitute for f ‚Ä≤‚Ä≤
i+1,j, from Eq. (5.4.34), into Eq. (5.4.35) we have
f ‚Ä≤
i+1,j = fi+1,j ‚àífi+1,j‚àí1
X‚àí
j
+
{X+
j fi+1,j‚àí1 ‚àí(X‚àí
j + X+
j )fi+1,j + X‚àí
j fi+1,j+1}X‚àí
j
(X+
j )2X‚àí
j + (X‚àí
j )2X+
j
which simpliÔ¨Åes to give
f ‚Ä≤
i+1,j =
(X+
j )2(fi+1,j ‚àífi+1,j‚àí1) ‚àí(X‚àí
j )2fi+1,j + (X‚àí
j )2fi+1,j+1
(X+
j )2X‚àí
j + (X‚àí
j )2X+
j
so that we Ô¨Ånally have
f ‚Ä≤
i+1,j =
(X‚àí
j )2fi+1,j+1 + ((X+
j )2 ‚àí(X‚àí
j )2)fi+1,j ‚àí(X+
j )2fi+1,j‚àí1
(X+
j )2X‚àí
j + (X‚àí
j )2X+
j
(5.4.36)
As in Section 5.4, we can now substitute the expressions for f ‚Ä≤
i+1,j and f ‚Ä≤‚Ä≤
i+1,j
given in Eqs. (5.4.36) and (5.4.34), into Eq. (5.4.7) the discretized Black‚ÄìScholes
equation. If we let D = (X+
j )2X‚àí
j + (X‚àí
j )2X+
j we then obtain
rt

Œòmfi+1,j + Œò‚àó
mfi,j

= fi+1,j ‚àífi,j + (r ‚àíq)SjtA1
D
+
œÉ 2S2
j tA2
D
(5.4.37)

Single asset American options
151
where Œò‚àó
m = 1 ‚àíŒòm, and
A1 = Œòm

fi+1,j+1

X‚àí
j
2 ‚àífi+1,j‚àí1

X+
j
2
‚àífi+1,j

X‚àí
j
2 ‚àí

X+
j
2
+ Œò‚àó
m

fi,j+1

X‚àí
j
2 ‚àífi,j‚àí1

X+
j
2 ‚àífi,j

X‚àí
j
2 ‚àí

X+
j
2
and
A2 = Œòm

fi+1,j+1X‚àí
j + fi+1,j‚àí1X+
j ‚àífi+1,j

X‚àí
j + X+
j

+ Œò‚àó
m

fi,j+1X‚àí
j + fi,j‚àí1X+
j ‚àífi,j

X‚àí
j + X+
j

Collecting like terms, we obtain:
B1fi,j‚àí1 + B2fi,j + B3fi,j+1 + C1fi+1,j‚àí1 + C2fi+1,j
+ C3fi+1,j+1 = 0
(5.4.38)
where
B1 =
‚àíŒò‚àó
m(r ‚àíq)Sjt(X+
j )2
D
+
(1 ‚àíŒ∏)œÉ 2S2
j tX+
j
D
B2 = ‚àí1 ‚àírtŒò‚àó
m ‚àí
Œò‚àó
mœÉ 2S2
j t(X‚àí
j + X+
j )
D
‚àí
Œò‚àó
m(r ‚àíq)Sjt{(X‚àí
j )2 ‚àí(X+
j )2}
D
B3 =
Œò‚àó
m(r ‚àíq)Sjt(X‚àí
j )2
D
+
Œò‚àó
mœÉ 2S2
j tX‚àí
j
D
C1 =
ŒòmœÉ 2S2
j tX+
j
D
‚àí
Œòm(r ‚àíq)Sjt(X+
j )2
D
C2 = 1 ‚àírtŒòm ‚àí
Œòm(r ‚àíq)Sjt{(X‚àí
j )2 ‚àí(X+
j )2}
D
‚àí
ŒòmœÉ 2S2
j t{X‚àí
j + X+
j }
D
C3 =
Œòm(r ‚àíq)Sjt(X‚àí
j )2
D
+
ŒòmœÉ 2S2
j tX‚àí
j
D
Since we are solving the Black‚ÄìScholes equation backwards in time we will re-
arrange Eq. (5.4.38) as:
ajfi,j‚àí1 + bjfi,j + cj = Ri+1,j
(5.4.39)
where the right-hand side Ri+1,j is:
Ri+1,j = ¬Øajfi+1,j‚àí1 + ¬Øbjfi+1,j + ¬Øcjfi+1,j+1
(5.4.40)

152
Computational Finance Using C and C#
and the coefÔ¨Åcients are
aj = Œò‚àó
mt
(r ‚àíq)Sj(X+
j )2
D
‚àí
œÉ 2S2
j X+
j
D

(5.4.41)
bj = 1 + tŒò‚àó
m

r +
œÉ 2S2
j (X‚àí
j + X+
j )
D
+
(r ‚àíq)Sj{(X‚àí
j )2 ‚àí(X+
j )2}
D

(5.4.42)
cj = Œò‚àó
mt
‚àí(r ‚àíq)Sj(X‚àí
j )2
D
‚àí
œÉ 2S2
j X‚àí
j
D

(5.4.43)
¬Øaj = Œòmt
œÉ 2S2
j X+
j
D
‚àí
(r ‚àíq)Sj(X+
j )2
D

(5.4.44)
¬Øbj = 1 ‚àíŒòmrt
‚àíŒòmt
(r ‚àíq)Sj{(X‚àí
j )2 ‚àí(X+
j )2}
D
+
œÉ 2S2
j {X‚àí
j + X+
j }
D

(5.4.45)
¬Øcj = Œòmt
(r ‚àíq)Sj(X‚àí
j )2
D
+
œÉ 2S2
j X‚àí
j
D

(5.4.46)
Here Eq. (5.4.39), as is the case for Eq. (5.4.14) in Section 5.4, provides the
relationship between the three option values fi+1,j‚àí1, fi+1,j, fi+1,j+1 at time
index i + 1, and the three option values fi,j‚àí1, fi,j, fi,j+1 at time index i. It can
also be seen that Eq. (5.4.39) is the nonuniform grid equivalent of Eq. (5.4.14)
given in Section 5.4. We will now show that Eqs. (5.4.39) and (5.4.14) are
identical when a uniform grid is used, that is X+
j
= X‚àí
j . We proceed as
follows:
Let X+
j = X‚àí
j = S and Sj = jS.
So
D =

X+
j
2X‚àí
j +

X‚àí
j
2X+
j
= 2(S)3 (X+
j )2
D
=
(X‚àí
j )2
D
= (S)2
2(S)3 =
1
2S
X+
j
D
=
X‚àí
j
D
=
1
2S2
(X+
j )2 ‚àí(X‚àí
j )2
D
= 0
If we substitute the above values into Eqs. (5.4.41)‚Äì(5.4.46) we obtain the fol-
lowing expressions for the coefÔ¨Åcients in Eq. (5.4.39).

Single asset American options
153
aj = (1 ‚àíŒòm)t
(r ‚àíq)Sj
2S
‚àí
œÉ 2S2
j
2S2

= (1 ‚àíŒòm)t
2

(r ‚àíq)j ‚àíœÉ 2j2
bj = 1 + t(1 ‚àíŒòm)

r +
œÉ 2S2
j
S2

= 1 + (1 ‚àíŒòm)t

r + œÉ 2j2
cj = (1 ‚àíŒòm)t
‚àí(r ‚àíq)Sj
2S
‚àí
œÉ 2S2
j
2S2

= ‚àí(1 ‚àíŒòm)t
2

(r ‚àíq)j + œÉ 2j2
¬Øaj = Œòmt
 œÉ 2S2
j
2S2 ‚àí(r ‚àíq)Sj
2S

= ‚àíŒòm
t
2

(r ‚àíq)j ‚àíœÉ 2j2
¬Øbj = 1 ‚àíŒòmrt ‚àí
ŒòmœÉ 2S2
j t
S2
= 1 ‚àíŒòmt

r + œÉ 2j2
¬Øcj = Œòmt
(r ‚àíq)Sj
2S
+
œÉ 2S2
j
S2

= Œòm
t
2

(r ‚àíq)j + œÉ 2j2
It can be seen that these coefÔ¨Åcients are identical to those given in Section 5.4.2
Eqs. (5.4.16)‚Äì(5.4.21).
We now provide examples of using nonuniform grids to evaluate European
down and out call options.
Valuation of a down and out call option
Here the improved accuracy that can be achieved by using nonuniform grids
instead of uniform grids is illustrated in Figs. 5.7 and 5.8. The uniform grids are
constructed using the method outlined in Section 5.4 and Code excerpt 5.18.
That is, an asset grid line is set to coincide with the current asset price S0, and
the other grid lines are positioned above and below S0 with a uniform spacing
of S. The disadvantage of this approach is that there will be an unspeciÔ¨Åed
pricing error that depends on the distance, ds, of the barrier level, B, to the
void opt_gfd(double theta_m, double asset_price, double sigma, double r, double T,
double strike, long is_american, long put, double *option_value,
double greeks[], double q, long pns, long nt, double smax, long *iflag)
{
/* Input parameters:
=================
theta_m
- the value of theta used for the finite difference method,
asset_price
- the current price of the underlying asset,
sigma
- the volatility,
r
- the interest rate,
T
- the time to maturity,
strike
- the strike price,
is_american
- if is_american is 0 then a European option, otherwise an American_
option,
Code excerpt 5.18.

154
Computational Finance Using C and C#
put
- if put is 0 then a call option, otherwise a put option,
q
- the continuous dividend yield,
pns
- the maximum asset index on the grid, corresponding to the upper_
boundary,
nt
- the number of time intervals,
smax
- the maximum asset price.
Output parameters:
option_value
- the value of the option,
greeks[]
- the hedge statistics output as follows: greeks[0] is gamma, greeks[1]_
is delta, and greeks[2] is theta,
iflag
- an error indicator.
*/
double *a,*b,*c,*a1,*b1,*c1,*opt_vals,*vals,*rhs,*s,*work,*u;
double ds,dt;
long i,j;
double tmp,t2,time_2mat;
long n1,n2,ind=0;
double sig2,temp[4];
if (asset_price >= smax) printf ("ERROR asset price >= smax");
n1 = floor((asset_price/smax)*(double)pns);
n2 = pns - n1;
ds = asset_price/(double)n1;
dt = T/(double)nt;
/* time interval size
*/
ns = n1+n2+1;
/* Note: Now nps = ns-1. Since we define asset grid lines 0...ns-1, this is the maximum grid_
line; corresponding
to the upper boundary. The lower boundary is at the asset grid line 0, and we solve for_
option values between
the asset grid line 1 and the asset grid line ns-2
*/
/* Allocate (all size ns+1) the arrays: a, b, c, a1, b1, c1, opt_vals, vals, rhs, s, work_
and u */
.
.
.
s[0] = 0.0;
s[n1] = asset_price;
for(i=1; i<=n1-1; ++i )
/* set prices below asset_price */
s[i] = (double)i * ds;
for(i=1; i<= n2+1; ++i )
/* set prices above asset_price */
s[n1+i] = asset_price + (double)i * ds;
/* Set up the RHS and LHS coefficients a[], b[] and c[] are the LHS coefficients
for the unknown option values (time step j) a1[], b1[] and c1[] are the values of the
RHS coefficients for the known option prices (time step j+1).
Note: a1, b1 and c1 are used to form the RHS vector rhs[] of the tridiagonal system.
*/
sig2 = sigma*sigma;
t2 = dt/2.0;
tmp = 1.0-theta_m;
/* 1 - theta (for theta method) */
for( i=1; i<=ns-2; ++i) { /* Assign elements of the (ns-2)*(ns-2) tridiagonal matrix */
a[i] = -i*(i*sig2-(r-q))*t2*tmp;
a1[i] = i*(i*sig2-(r-q))*t2*theta_m;;
c[i] = -i*(i*sig2+(r-q))*t2*tmp;
c1[i] = i*(i*sig2+(r-q))*t2*theta_m;;
b[i] = 1.0+r*dt*tmp+(i*i*sig2)*dt*tmp;
b1[i]= 1.0-(i*i*sig2+r)*dt*theta_m;
}
/* Perform LU decomposition of the tridiagonal matrix with:
diagonal elements contained in the array b[],
upper diagonal elements contained in the_
array c[]
and lower diagonal elements in the array a[]. Store the elements of U but not those of L
(they will be computed from U)
Matrix U: The diagonal elements of U are stored in the array u[] and the upper diagonal_
elements of U
are just c[].
Matrix L: For the lower triangular matrix L, the diagonal elements are 1 and the lower_
diagonal elements
are l[i] = a[i]/u[i-1], where u[] is the upper diagonal of U. */
u[1] = b[1];
if (u[1] == 0.0) printf ("ERROR in array u \n");
for(i=2; i <=ns-2; ++i) {
u[i] = b[i] - a[i]*c[i-1]/u[i-1];
Code excerpt 5.18 (Continued).

Single asset American options
155
if (u[i] == 0.0) printf ("ERROR in array u \n");
}
/*
Set option values at maturity.
Note : opt_vals[0] and opt_vals[ns-1] are the lower and_
upper
(put/call) option price boundary values. */
if (!put) { /* a call */
for( i=0; i<ns; ++i )
opt_vals[i] = MAX(s[i]-strike, 0.0 );
}
else { /* a put */
for( i=0; i<ns; ++i)
opt_vals[i] = MAX(strike - s[i], 0.0);
}
/* From the option values at maturity (t = nt*dt) calculate values at earlier times (nt-1)*dt_
etc..
*/
for( j=nt-1; j>=-2; --j) { /* Go two steps past current time (0) so that can evaluate_
theta */
time_2mat = T-j*dt;
for(i=2; i<=ns-3; ++i) /* set up the rhs of equation for Crank-Nicolson method */
rhs[i] = a1[i]*opt_vals[i-1]+b1[i]*opt_vals[i]+c1[i]*opt_vals[i+1];
/* Incorporate the boundary conditions at the upper/lower asset value boundaries */
rhs[1] = (a1[1]-a[1])*opt_vals[0]+ b1[1]*opt_vals[1]+c1[1]*opt_vals[2];
rhs[ns-2] = a1[ns-2]*opt_vals[ns-3]+b1[ns-2]*opt_vals[ns-2]+(c1[ns-2]-c[ns-2])_
*opt_vals[ns-1];
/* Solve the lower triangular system Ly = b, where y is stored in array work[].
Compute the elements of L from those of U, l[i] = a[i]/u[i-1].
*/
work[1] = rhs[1];
for( i=2; i<=ns-2; ++i ) {
work[i] = rhs[i] - a[i]*work[i-1]/u[i-1];
}
/* Solve the upper (ns-2)*(ns-2) triangular system Ux = y (where x = opt_vals) */
opt_vals[ns-2] = work[ns-2]/u[ns-2];
for( i = ns-2; i >= 1; --i )
opt_vals[i] = (work[i] - c[i]*opt_vals[i+1])/u[i];
if (is_american) {
/* take into account early exercise for american options */
if (put) {
/* a put */
for(i=1; i<=ns-2; ++i)
opt_vals[i] = MAX(opt_vals[i],strike-s[i]);
}
else { /* a call */
for(i=1; i<=ns-2; ++i)
opt_vals[i] = MAX(opt_vals[i],s[i]-strike);
}
}
if (j==0) {
for (i=0; i < ns; ++i)
vals[i] = opt_vals[i];
}
if ((j==1)||(j==2)||(j==-1)||(j==-2)) { /* Store option values so that can compute_
theta */
temp[ind] = opt_vals[n1];
++ind;
}
}
if (greeks) {
/* Compute gamma (4th order accuracy) */
greeks[0] = (-vals[n1+2]+16.0*vals[n1+1]-30.0*vals[n1]+16.0*vals[n1-1]-vals[n1-2])_
/(12.0*ds*ds);
/* Compute delta (4th order accuracy) */
greeks[1] = (-vals[n1+2]+8.0*vals[n1+1]-8.0*vals[n1-1]+vals[n1-2])/(12.0*ds);
/* Compute theta (4th order accuracy) */
greeks[2] = (-temp[0]+8.0*temp[1]-8.0*temp[2]+temp[3])/(12.0*dt);
/* Note: could also compute theta as greeks[2] = (-temp[0]+4.0*temp[1]-3.0*vals[n1])
/(2.0*dt); */
}
*option_value = vals[n1]; /* Return option value */
}
Code excerpt 5.18 Function to compute the value of a vanilla option using a uniform
grid.

156
Computational Finance Using C and C#
nearest asset grid line. Furthermore, as the number of asset points, ns, increases
the magnitude of ds will oscillate within the range 0 to S/2.
When ds ‚àº0 the grid will be accurate, but when |ds| ‚àºS/2 there will be
a large pricing error. This gives rise to the oscillating pricing errors shown in
Figs. 5.7 and 5.8.
The nonuniform grids are constructed using the techniques mentioned earlier
in this section, and also Code excerpt 5.19. We now, irrespective of ns, arrange
for one asset grid line to coincide with the current asset value, S0, and another
asset grid line to coincide with B, the barrier asset price. In Fig 5.6 this corre-
sponds to setting BL to B and not using BU.
It can be seen in Figs. 5.7 and 5.8 that in this case the pricing error is very
much less, and also does not exhibit the pronounced oscillations that are pro-
duced by a uniform grid. In Code excerpt 5.19 we give the computer program
which was used to obtained the nonuniform grid values for the down and out
call options presented in Figs. 5.7 and 5.8. Although this program only deals
with European options it can easily be altered, using the same techniques as in
Code excerpt 5.18, to deal with American-style options; this is left as an exercise
for the reader.
Figure 5.6 A nonuniform grid in which the grid spacing is reduced near current time t,
and also in the neighborhood of the asset price 25; this can lead to greater accuracy in
the computed option values and the associated Greeks. Grid lines are also placed at asset
prices of BU and BL; this enables the accurate evaluation of options which have barriers
at these asset prices.

Single asset American options
157
void barrier_downout(double barrier_level, double theta_m, double asset_price, double sigma,_
double r, double T,
double strike, long put, double *option_value, double greeks[], double q, long ns,_
long nt, double smax, long *ifail)
{
/* ns - the number of asset intervals
nt - the number of time intervals
*/
double *a,*b,*c,*a1,*b1,*c1,*opt_vals,*vals,*rhs,*s,*work,*u;
double ds,time_step;
long i,j,barrier_index;
double tmp,t2,time_2mat,zero = 0.0;
long n1,n2,ind=0,ns1;
double sig2,temp[4],ds_plus,ds_minus,temp1,temp2,temp3;
double D;
n1 = floor((asset_price/smax)*(double)ns);
if (n1 < 3) {
printf ("increase the number of asset points \n");
}
n2 = ns - n1;
ds = asset_price/(double)n1;
time_step = T/(double)nt;
/* time interval size
*/
ns1 = n1+n2+2; /* number of nodes - including extra grid line*/
/* allocate the required arrays (all of size ns1+1): a, b, c, a1, b1, c1, opt_vals,_
vals, rhs, s, work, u */
.
.
.
/* set prices below asset_price */
s[0] = zero;
s[n1] = asset_price;
for(i=1; i < n1; ++i )
s[i] = (double)i * ds;
/* set prices above asset_price */
for(i=1; i<= n2+2; ++i ) {
s[n1+i] = asset_price + (double)i * ds;
}
/* find out the index corresponding to barrier_level */
barrier_index = 0;
while(barrier_level > s[barrier_index]) {
++barrier_index;
}
if (barrier_level != s[barrier_index]) { /* decrement barrier index */
--barrier_index;
}
if (s[barrier_index] != barrier_level) { /* then barrier does not correspond_
to an existing grid line
so create another_
one*/
for (i=1; i < ns1-barrier_index; ++i) {
s[barrier_index+1+i] = s[barrier_index] + (double)i*ds;
}
++barrier_index;
s[barrier_index] = barrier_level;
if (n1>barrier_index) {
++n1;
}
}
/* set up the RHS and LHS coefficients a[], b[] and c[] are the LHS coefficients
for the unknown option values (time step j) a1[], b1[] and c1[] are the values of the
RHS coefficients for the known option prices (time step j+1).
Note: a1, b1 and c1 are used to form the RHS vector rhs[] of the tridiagonal_
system. */
sig2 = sigma*sigma;
t2 = time_step/2.0;
tmp = 1.0-theta_m;
/* 1 - theta (for theta method) */
/* assign elements of the (ns1-2)*(ns1-2) tridiagonal matrix */
for( i=1; i<=ns1-2; ++i) {
ds_plus
= s[i+1]-s[i];
ds_minus = s[i] - s[i-1];
D = ((ds_plus*ds_plus*ds_minus) + (ds_minus*ds_minus*ds_plus));
temp1 = tmp*time_step/D;
a[i] = temp1*((r-q)*s[i]*ds_plus*ds_plus) -temp1*ds_plus*(s[i]*s[i]*sig2);
temp1 = theta_m*time_step/D;
a1[i] = -(temp1*((r-q)*s[i]*ds_plus*ds_plus) -temp1*ds_plus*(s[i]*s[i]*sig2));
temp1 = (ds_minus*ds_minus)/D;
temp2 = ds_minus/D;
Code excerpt 5.19.

158
Computational Finance Using C and C#
c[i]
= -time_step*tmp*(temp1*s[i]*(r-q)+(sig2*s[i]*s[i]*temp2));
c1[i] = time_step*theta_m*(temp1*s[i]*(r-q)+(sig2*s[i]*s[i]*temp2));
temp1 = ((ds_minus*ds_minus) - (ds_plus*ds_plus))/D;
temp2 = (ds_minus+ds_plus)/D;
b[i] = 1.0+time_step*tmp*(r+((r-q)*s[i]*temp1)+(s[i]*s[i]*sig2)*temp2);
b1[i] = 1.0-time_step*theta_m*(r+((r-q)*s[i]*temp1)+(s[i]*s[i]*sig2)*temp2);
}
/* Perform LU decomposition of the tridiagonal matrix with: diagonal elements contained_
in the array b[],
upper diagonal elements contained in the array c[]
and lower diagonal elements in_
the array a[].
Store the elements of U but not those of L (they will be computed from U)
Matrix U: The diagonal elements of U are stored in the array u[] and the upper
diagonal elements of U are just c[].
Matrix L: For the lower triangular matrix L, the diagonal elements are 1 and the_
lower diagonal
elements are l[i] = a[i]/u[i-1], where u[] is the upper diagonal of U. */
u[1] = b[1];
if (u[1] == zero) printf ("error in array u \n");
for( i=2; i <=ns1-2; ++i) {
u[i] = b[i] - a[i]*c[i-1]/u[i-1];
if (u[i] == zero) printf ("error in array u \n");
}
/* Set option values at maturity. Note : opt_vals[0] and opt_vals[ns1-1] are the lower and_
upper
(put/call) option price boundary values. */
if (!put) { /* a call */
for( i=0; i<ns1; ++i )
opt_vals[i] = MAX(s[i]-strike, zero );
/* now modify option values to include the barrier */
for( i=0; i <= barrier_index; ++i )
opt_vals[i] = zero;
}
else { /* a put */
for( i=0; i<ns1; ++i)
opt_vals[i] = MAX(strike - s[i], zero);
}
/* From the option values at maturity, t = nt*time_step, compute
the values at times (nt-1)*time_step to 0 (current time)
*/
for( j=nt-1; j>=-2; --j) { /* go two steps past current time so that can evaluate_
theta */
time_2mat = T-j*time_step;
/* set up the rhs of equation for the Theta method */
for(i=2; i<=ns1-3; ++i)
rhs[i] = a1[i]*opt_vals[i-1]+b1[i]*opt_vals[i]+c1[i]*opt_vals[i+1];
/* incorporate the boundary conditions1 at the upper/lower asset value boundaries */
rhs[1] = (a1[1]-a[1])*opt_vals[0]+ b1[1]*opt_vals[1]+c1[1]*opt_vals[2];
rhs[ns1-2] = a1[ns1-2]*opt_vals[ns1-3]+b1[ns1-2]*opt_vals[ns1-2]+(c1[ns1-2]-c[ns1-2])_
*opt_vals[ns1-1];
/* Solve the lower triangular system Ly = b, where y is stored in array work[].
Compute the elements of L from those of U, l[i] = a[i]/u[i-1]. */
work[1] = rhs[1];
for( i=2; i<=ns1-2; ++i ) {
work[i] = rhs[i] - a[i]*work[i-1]/u[i-1];
}
/* Solve the upper (ns1-2)*(ns1-2) triangular system Ux = y (where x = opt_vals) */
opt_vals[ns1-2] = work[ns1-2]/u[ns1-2];
for( i = ns1-2; i >= 1; --i )
opt_vals[i] = (work[i] - c[i]*opt_vals[i+1])/u[i];
if (j==0) {
for (i=0; i < ns1; ++i)
vals[i] = opt_vals[i];
}
/* store option values so that can compute theta */
if ((j==1)||(j==2)||(j==-1)||(j==-2)) {
temp[ind] = opt_vals[n1];
++ind;
}
/* now modify for barrier */
for( i=0; i <= barrier_index; ++i )
opt_vals[i] = zero;
}
if (greeks) { /* assume an irregular grid */
ds_minus = s[n1]-s[n1-1];
Code excerpt 5.19 (Continued).

Single asset American options
159
ds_plus
= s[n1+1]-s[n1];
D = (ds_minus*ds_minus*ds_plus) + (ds_plus*ds_plus*ds_minus);
temp1 = ds_minus*ds_minus;
temp2 = ds_plus*ds_plus;
temp3 = temp1-temp2;
/* GAMMA */
greeks[0] = (ds_minus*vals[n1+1]+ds_plus*vals[n1-1]-vals[n1]*(ds_plus+ds_minus))_
/(0.5*D);
/* DELTA */
greeks[1] = (temp1*vals[n1+1] - temp2*vals[n1-1] - vals[n1]*temp3)/D;
/*
THETA */
greeks[2] = (-temp[0]+8.0*temp[1]-8.0*temp[2]+temp[3])/(12.0*time_step);
/* could also compute theta like this:
greeks[2] = (-temp[0]+4.0*temp[1]-3.0*vals[n1])/(2.0*time_step); */
}
*option_value = vals[n1]; /* Return option value */
/* deallocate the arrays that were previously allocated */
.
.
.
}
Code excerpt 5.19 Function to compute the value of a European down and out barrier
option using a nonuniform grid.
Figure 5.7 The absolute error in the estimated values for a European down and out call
barrier option (B < E) as the number of asset grid points, ns, are varied. Here we show
a comparison of the results obtained using both uniform and nonuniform grids; loga-
rithmic transformations were not employed. The algorithm for the uniform grid is de-
scribed in Section 5.4.2, and that for the nonuniform grid is outlined in Section 5.4.3. The
Crank‚ÄìNicolson method (Œòm = 0.5) was used and the other parameters were E = 50.0,
B = 47.5, S0 = 55.0, Smax = 300.0, T = 0.5, œÉ = 0.2, r = log(1.1), q = 0.0, nt = 100.
The correct option value was 7.6512, which was obtained using the analytic formulae
given in Code excerpt 4.7.

160
Computational Finance Using C and C#
Figure 5.8 The absolute error in the estimated values for a European down and out call
barrier option (E < B) as the number of asset grid points, ns, is varied. Here we show
a comparison of the results obtained using both uniform and nonuniform grids; loga-
rithmic transformations were not employed. The algorithm for the uniform grid is de-
scribed in Section 5.4.2 and that for the nonuniform grid is outlined in Section 5.4.3. The
Crank‚ÄìNicolson method (Œòm = 0.5) was used and the other parameters were E = 50.0,
B = 52.5, S0 = 65.0, Smax = 300.0, T = 0.5, œÉ = 0.2, r = log(1.1), q = 0.0, nt = 100.
The correct option value was 17.0386, which was obtained using the analytic formulae
given in Code excerpt 4.7.
5.4.4
The log transformation and uniform grids
Up to this point we have been dealing with the standard Black‚ÄìScholes equation,
which is:
‚àÇf
‚àÇt + (r ‚àíq)S ‚àÇf
‚àÇS + œÉ 2S2
2
‚àÇ2f
‚àÇS2 = rf
(5.4.47)
However, if we introduce the change of variable Z = log S, we obtain the fol-
lowing equation:
‚àÇf
‚àÇt + b ‚àÇf
‚àÇZ + œÉ 2
2
‚àÇ2f
‚àÇZ2 = rf
(5.4.48)
where b = r ‚àíq ‚àíœÉ 2/2. This form of the Black‚ÄìScholes equation has beneÔ¨Åcial
numerical properties‚Äîsee Appendix F.

Single asset American options
161
Derivation of Eq. (5.4.48)
We will now derive an expression for the logarithmic Black‚ÄìScholes equation,
and show that it agrees with Eq. (5.4.48).
Since Z = log S we have ‚àÇZ
‚àÇS = 1
S . This gives:
‚àÇf
‚àÇS = ‚àÇf
‚àÇZ
‚àÇZ
‚àÇS = 1
S
‚àÇf
‚àÇZ
and
‚àÇ2f
‚àÇS2 = ‚àÇ
‚àÇS
‚àÇf
‚àÇS

= 1
S2
‚àÇf
‚àÇZ + 1
S
‚àÇ
‚àÇS
 ‚àÇf
‚àÇZ

= ‚àí1
S2
‚àÇf
‚àÇZ + 1
S
‚àÇZ
‚àÇS
‚àÇ
‚àÇZ
 ‚àÇf
‚àÇZ

‚àÇ2f
‚àÇS2 = ‚àí1
S2
‚àÇf
‚àÇZ + 1
S2
‚àÇ2f
‚àÇZ2
So Eq. (5.4.47) becomes:
‚àÇf
‚àÇt + (r ‚àíq)S
S
‚àÇf
‚àÇZ ‚àíœÉ 2S2
2S2
‚àÇf
‚àÇZ + œÉ 2S2
2S2
‚àÇ2f
‚àÇZ2 = rf
thus setting b = r ‚àíq ‚àíœÉ 2/2 we obtain:
‚àÇf
‚àÇt + b ‚àÇf
‚àÇZ + œÉ 2
2
‚àÇ2f
‚àÇZ2 = rf
We will now consider the Ô¨Ånite difference discretization of Eq. (5.4.48).
The Ô¨Ånite-difference method
Application of the Ô¨Ånite-difference method to the log transformed Black‚Äì
Scholes equation is very similar to that already outlined in Sections 5.4.2
and 5.4.3.
Use of the Œòm method on Eq. (5.4.48) results in:
fi+1,j ‚àífi,j
t
+ b

Œòmf ‚Ä≤
i+1,j + Œò‚àó
mf ‚Ä≤
i,j

+ 1
2œÉ 2
Œòmf ‚Ä≤‚Ä≤
i+1,j + Œò‚àó
mf ‚Ä≤‚Ä≤
i,j

= r

Œòmfi+1,j + Œò‚àó
mfi,j

where Œò‚àó
m = 1‚àíŒòm. Applying a uniform discretization at node (i, j) we obtain:
fi+1,j ‚àífi,j + btA1
2Z
+ œÉ 2tA2
2Z2
= rt

Œòmfi+1,j + Œò‚àó
mfi,j

(5.4.49)
where
A1 = Œòm{fi+1,j+1 ‚àífi+1,j‚àí1} + Œò‚àó
m{fi,j+1 ‚àífi,j‚àí1}
A2 = Œòm{fi+1,j+1 ‚àí2fi+1,j + fi+1,j‚àí1} + Œò‚àó
m{fi,j+1 ‚àí2fi,j + fi,j‚àí1}
Collecting like terms we obtain:
B1fi,j‚àí1 + B2fi,j + B3fi,j+1 + C1fi+1,j‚àí1 + C2fi+1,j + C3fi+1,j+1 = 0

162
Computational Finance Using C and C#
where
B1 = ‚àíŒò‚àó
mbt
2Z
+ Œò‚àó
mœÉ 2t
2Z2
B2 = ‚àí1 ‚àírtŒò‚àó
m ‚àíŒò‚àó
mœÉ 2t
Z2
B3 = Œò‚àó
mbt
2Z
+ Œò‚àó
mœÉ 2t
2Z2
C1 = ŒòmœÉ 2t
2Z2
‚àíŒòmbt
2Z
C2 = 1 ‚àírtŒòm ‚àíŒòmœÉ 2t
Z2
C3 = Œòmbt
2Z
+ ŒòmœÉ 2t
2Z2
If we rearrange we have the following equation:
ajfi,j‚àí1 + bjfi,j + cj = ¬Øajfi+1,j‚àí1 + ¬Øbjfi+1,j + ¬Øcjfi+1,j+1
where:
aj = (1 ‚àíŒòm)t
2Z2

bZ ‚àíœÉ 2
(5.4.50)
bj = 1 + (1 ‚àíŒòm)t

r + œÉ 2
Z2

(5.4.51)
cj = ‚àí(1 ‚àíŒòm)t
2Z2

bZ + œÉ 2
(5.4.52)
¬Øaj = ‚àíŒòmt
2Z2

bZ ‚àíœÉ 2
(5.4.53)
¬Øbj = 1 ‚àíŒòmt

r + œÉ 2
Z2

(5.4.54)
¬Øcj = Œòmt
2Z2

bZ + œÉ 2
(5.4.55)
It can be seen that, unlike in Section 5.4.2, the coefÔ¨Åcients in Eqs. (5.4.50)‚Äì
(5.4.55) are independent of the asset price index j.
When Œòm = 0.5 (the Crank‚ÄìNicolson method) we have the following coefÔ¨Å-
cients:
aj = ‚àí¬Øaj =
t
4Z2

bZ ‚àíœÉ 2
bj = 1 + t
2

r + œÉ 2
Z2

cj = ‚àí¬Øcj = ‚àít
4Z2

bZ + œÉ 2
¬Øbj = 1 ‚àít
2

r + œÉ 2
Z2


Single asset American options
163
Table 5.7 Valuation results and pricing errors for a vanilla American put option using a
uniform grid with and without a logarithmic transformation; the implicit method and
Crank‚ÄìNicolson method are used
Time
Value
Œòm = 0.0
Œòm = 0.5
BS
Log BS
BS
Log BS
0.1
0.7599
1.4733 √ó 10‚àí2
7.7803 √ó 10‚àí3
1.4719 √ó 10‚àí2
7.6716 √ó 10‚àí3
0.2
0.8335
4.5838 √ó 10‚àí2
1.2924 √ó 10‚àí2
4.5682 √ó 10‚àí2
1.1997 √ó 10‚àí2
0.3
0.8921
6.4218 √ó 10‚àí2
1.4125 √ó 10‚àí2
6.3800 √ó 10‚àí2
1.2567 √ó 10‚àí2
0.4
0.9403
7.4699 √ó 10‚àí2
1.6559 √ó 10‚àí2
7.3924 √ó 10‚àí2
1.4655 √ó 10‚àí2
0.5
0.9812
8.0297 √ó 10‚àí2
1.8471 √ó 10‚àí2
7.9101 √ó 10‚àí2
1.6041 √ó 10‚àí2
0.6
1.0167
8.2796 √ó 10‚àí2
1.9125 √ó 10‚àí2
8.1135 √ó 10‚àí2
1.6067 √ó 10‚àí2
0.7
1.0479
8.3285 √ó 10‚àí2
1.8959 √ó 10‚àí2
8.1131 √ó 10‚àí2
1.5273 √ó 10‚àí2
0.8
1.0758
8.2470 √ó 10‚àí2
1.8408 √ó 10‚àí2
7.9803 √ó 10‚àí2
1.4159 √ó 10‚àí2
0.9
1.1009
8.0829 √ó 10‚àí2
1.7756 √ó 10‚àí2
7.7647 √ó 10‚àí2
1.3020 √ó 10‚àí2
1.0
1.1237
7.8646 √ó 10‚àí2
1.7138 √ó 10‚àí2
7.4947 √ó 10‚àí2
1.1997 √ó 10‚àí2
1.1
1.1445
7.6164 √ó 10‚àí2
1.6643 √ó 10‚àí2
7.1961 √ó 10‚àí2
1.1174 √ó 10‚àí2
1.2
1.1637
7.3514 √ó 10‚àí2
1.6290 √ó 10‚àí2
6.8803 √ó 10‚àí2
1.0552 √ó 10‚àí2
1.3
1.1813
7.0785 √ó 10‚àí2
1.6092 √ó 10‚àí2
6.5594 √ó 10‚àí2
1.0143 √ó 10‚àí2
1.4
1.1977
6.8080 √ó 10‚àí2
1.6042 √ó 10‚àí2
6.2419 √ó 10‚àí2
9.9309 √ó 10‚àí3
1.5
1.2129
6.5424 √ó 10‚àí2
1.6128 √ó 10‚àí2
5.9295 √ó 10‚àí2
9.8909 √ó 10‚àí3
The accurate values (obtained using a logarithmic transformed grid with ns = 1000 and
nt = 1000) are presented in the column labelled ‚ÄúValue‚Äù. The absolute pricing errors,
ABS (accurate value ‚àíestimated value) presented in the column labelled BS were ob-
tained using a standard uniform grid (as outlined in Section 5.4.2), and those in the
column labelled Log BS use a uniform grid and logarithmic transformation as explained
in this section. The maturity of the option was varied from 0.1 years to 1.5 years, and
the other parameters were: S = 9.0, X = 9.7, r = 0.1, q = 0.0, œÉ = 0.30, Smax = 100.0,
ns = 50, and nt = 50.
The method of using the Ô¨Ånite-difference grid to compute option prices is iden-
tical to that already outlined in Section 5.4.2, which solves the standard (non-
logarithmic) Black‚ÄìScholes equation. Table 5.7 compares the results obtained
with and without a logarithmic transformation.
5.4.5
The log transformation and nonuniform grids
In the previous section we considered the use of a uniform grid to discretize the
logarithmically transformed Black‚ÄìScholes equation:
‚àÇf
‚àÇt + b ‚àÇf
‚àÇZ + œÉ 2
2
‚àÇ2f
‚àÇZ2 = rf
(5.4.56)

164
Computational Finance Using C and C#
where
b = r ‚àíq ‚àíœÉ 2
2
and
Z = log S
Here we will generalize these results and use a nonuniform grid to solve
Eq. (5.4.56).
Our description will be very brief since most of the details have already been
discussed in previous sections. Here we are only concerned with the Ô¨Ånite-
difference approximation and derive the equations that need to be solved at
each time step. Later, in Section 5.4.6, we will apply our results to solving a
European double knockout barrier option.
The Ô¨Ånite-difference approximation
At the grid node (i, j) we have
Z‚àí
j = Zj ‚àíZj‚àí1
and
Z+
j = Zj + 1 ‚àíZj
Following Section 5.4.2 the Ô¨Årst and second derivatives of f w.r.t. Z are
f ‚Ä≤‚Ä≤
i+1,j =
2{Z+
j fi+1,j‚àí1 + Z‚àí
j fi+1,j+1 ‚àíZ‚àí
j fi+1,j ‚àíZ+
j fi+1,j}
(Z+
j )2Z‚àí
j + (Z‚àí
j )2Z+
j
and
f ‚Ä≤
i+1,j =
(Z‚àí
j )2fi+1,j+1 + ((Z+)2 ‚àí(Z‚àí
j )2)fi+1,j ‚àí(Z+
j )2fi+1,j‚àí1
(Z+
j )2Z‚àí
j + (Z‚àí
j )2Z+
Then discretizing Eq. (5.4.56) in the usual manner we obtain
fi+1,j ‚àífi,j
t
+ b

Œòmf ‚Ä≤
i+1,j + Œò‚àó
mf ‚Ä≤
i,j

+ œÉ 2
2

Œòmf ‚Ä≤‚Ä≤
i+1,j + Œò‚àó
mf ‚Ä≤‚Ä≤
i,j

= r

Œòmfi+1,j + Œò‚àó
mfi,j

where Œò‚àó
m = 1 ‚àíŒòm. Letting D = (Z+
j )2Z‚àí
j + (Z‚àí
j )2Z+
j we obtain
rt

Œòmfi+1,j + Œò‚àó
mfi,j

(5.4.57)
= fi+1,j ‚àífi,j + btA1
D
+ œÉ 2tA2
D
where
A1 = Œòm

fi+1,j+1

Z‚àí
j
2 ‚àífi+1,j‚àí1

Z+
j
2
‚àífi+1,j

Z‚àí
j
2 ‚àí

Z+
j
2
+ Œò‚àó
m

fi,j+1

Z‚àí
j
2 ‚àífi,j‚àí1

Z+
j
2 ‚àífi,j

Z‚àí
j
2 ‚àí

Z+
j
2
A2 = Œòm

fi+1,j+1Z‚àí
j + fi+1,j‚àí1Z+
j ‚àífi+1,j

Z‚àí
j + Z+
j

+ Œò‚àó
m

fi,j+1Z‚àí
j + fi,j‚àí1Z+
j ‚àífi,j

Z‚àí
j + Z+
j


Single asset American options
165
Collecting like terms we obtain:
B1fi,j‚àí1 + B2fi,j + B3fi,j+1 + C1fi+1,j‚àí1 + C2fi+1,j + C3fi+1,j+1 = 0
where
B1 =
‚àíŒò‚àó
mbt(Z+
j )2
D
+
Œò‚àó
mœÉ 2tZ+
j
D
B2 = ‚àí1 ‚àírtŒò‚àó
m
‚àí
Œò‚àó
mœÉ 2t(Z‚àí
j + Z+
j )
D
‚àí
Œò‚àó
mbt{(Z‚àí
j )2 ‚àí(Z+
j )2}
D
B3 =
Œò‚àó
mbt(Z‚àí
j )2
D
+ Œò‚àó
mœÉ 2tZ‚àí
D
C1 =
ŒòmœÉ 2tZ+
j
D
‚àí
Œòmbt(Z+
j )2
D
C2 = 1‚àírtŒòm ‚àí
Œòmbt{(Z‚àí
j )2 ‚àí(Z+
j )2}
D
‚àí
ŒòmœÉ 2t{Z‚àí
j + Z+
j }
D
C3 =
Œòmbt(Z‚àí
j )2
D
+
ŒòmœÉ 2tZ‚àí
j
D
If we rearrange we have the following equation:
ajfi,j‚àí1 + bjfi,j + cj = ¬Øajfi+1,j‚àí1 + ¬Øbjfi+1,j + ¬Øcjfi+1,j+1
(5.4.58)
where:
aj = (1 ‚àíŒòm)t
b(Z+
j )2
D
‚àí
œÉ 2Z+
j
D

(5.4.59)
bj = 1 + t(1 ‚àíŒòm)
√ó

r ‚àí
œÉ 2(Z‚àí
j + Z+
j )
D
‚àí
b{(Z‚àí
j )2 ‚àí(Z+
j )2}
D

(5.4.60)
cj = (1 ‚àíŒòm)t
‚àíb(Z‚àí
j )2
D
‚àí
œÉ 2Z‚àí
j
D

(5.4.61)
¬Øaj = Œòmt
œÉ 2Z+
j
D
‚àí
b(Z+
j )2
D

(5.4.62)
¬Øbj = 1 ‚àíŒòmrt
‚àíŒòmt
b{(Z‚àí
j )2 ‚àí(Z+
j )2}
D
+
œÉ 2{Z‚àí
j + Z+
j }
D

(5.4.63)
¬Øcj = Œòmt
b(Z‚àí
j )2
D
+
œÉ 2Z‚àí
j
D

(5.4.64)
The incorporation of boundary conditions and the solution of Eq. (5.4.58) is
similar in manner to that already discussed in Section 5.4.2. If further details

166
Computational Finance Using C and C#
are required Code excerpt 5.19, which uses a nonuniform grid to solve the log
transformed Black‚ÄìScholes equation, can be consulted.
When a uniform grid is used Z+
j = Z‚àí
j = Z and therefore
D =

Z+
j
2Z‚àí
j +

Z‚àí
j
2Z+
j = 2(Z)3
(Z+
j )2
D
=
(Z‚àí
j )2
D
= (Z)2
2(Z)3 =
1
2Z
Z+
j
D
=
Z‚àí
j
D
=
1
2Z2
and
(Z+
j )2 ‚àí(Z‚àí
j )2
D
= 0
In these circumstances
aj = (1 ‚àíŒòm)t
2Z2

bZ ‚àíœÉ 2
bj = 1 + t(1 ‚àíŒòm)

r ‚àíœÉ 2
Z2

cj = (1 ‚àíŒòm)t
 ‚àíb
2Z ‚àí
œÉ 2
2Z2

¬Øaj = ‚àíŒòmt
2Z2

bZ ‚àíœÉ 2
¬Øbj = 1 ‚àíŒòmt

r + œÉ 2
Z2

¬Øcj = Œòmt
2Z2

bZ + œÉ 2
which are the same as Eqs. (5.4.50)‚Äì(5.4.55) in Section 5.4.4.
5.4.6
The double knockout call option
The purpose of this section is to provide an example that illustrates the beneÔ¨Åts
to be gained from using both the log transformed Black‚ÄìScholes equation and
also a nonuniform grid.
The problem we will consider is the European double knockout call option
with strike price E, and expiry date T . This is a barrier option with both an
upper barrier at BU and a lower barrier at BL. If, during the life of the option,
the asset price either goes above the upper barrier or below the lower barrier,
then the option becomes worthless. If, on the other hand, the asset price stays
between the barriers then the option has value max(ST ‚àíE, 0), where ST is the
asset price at time T .
This problem has been previously investigated by Boyle and Tian (1998),
henceforth referred to as BT, who used an explicit Ô¨Ånite-difference method
based on a modiÔ¨Åed trinomial lattice. The method we use here is based on
the Ô¨Ånite-difference equations given in Section 5.4.5, and all the results ob-
tained by using the function dko_call (see Code excerpt 5.20) are presented
in Tables 5.8‚Äì5.12.

Single asset American options
167
void dko_call(double lower_barrier, double upper_barrier, double theta_m,
double S0, double sigma_array[], double sigma_times[], long n_sigma, double r,
double opt_mat, double X, double *option_value, double greeks[], double q,
long ns_below_S0, long ns_above_S0, long nt, long *iflag)
{
/* Input parameters:
=================
lower_barrier
- the asset price corresponding to the lower barrier,
upper_barrier
- the asset price corresponding to the upper barrier,
theta_m
- the value of theta used for the finite difference method,
S0
- the current price of the underlying asset,
sigma_array[]
- an array containing values of the volatility: sigma_array[0] is the_
first value of the volatility,
sigma_array[1] is the second value of the volatility, etc..,
sigma_times[]
- an array containing the times for different volatilities:_
sigma_times[0] is the time corresponding to
the first volatility, sigma_times[1] is the time corresponding to_
the second volatility, etc..,
n_sigma
- the number of elements in sigma_array[], and sigma_times[],
r
- the interest rate,
opt_mat
- the time to maturity,
X
- the strike price,
q
- the continuous dividend yield,
ns_below_S0
- the number of asset intervals below the current price S0,
ns_above_S0
- the number of asset intervals above the current price S0,
nt
- the number of time intervals.
Output parameters:
==================
option_value
- the value of the option,
greeks[]
- the hedge statistics output as follows: greeks[0] is gamma,_
greeks[1] is delta, and greeks[2] is theta,
iflag
- an error indicator.
*/
double *a,*b,*c,*vals,*a1,*b1,*c1,*opt_vals,*rhs,*z,*delta,*gamma,*work,*u;
double dt,dz,dz1,dz2,zmax,zmin;
long i,j;
double tmp,t2,t4,dt2;
long ind=0,n1,n2,ns1;
double ds,log_asset,sig2,alpha,v2,b_fac,temp[4];
double zero = 0.0;
long barrier_index,ind2;
double dz_shift,time_step,log_barrier_level1,log_barrier_level2;
double temp1, temp2, ds_plus, ds_minus, bb, D;
double curr_time;
if (S0 >= upper_barrier) printf ("ERROR current asset price is greater than_
upper_barrier \n");
if (lower_barrier >= S0) printf("ERROR lower barrier is greater than current asset_
price \n");
if (S0 <= zero) printf ("ERROR asset price is not > 0 \n");
if (upper_barrier <= lower_barrier) printf ("ERROR upper_barrier must be >_
lower_barrier \n");
log_asset = log(S0);
log_barrier_level1 = log(lower_barrier);
log_barrier_level2 = log(upper_barrier);
dz1 = (log_asset-log_barrier_level1)/(double)ns_below_S0;
n1 = ns_below_S0;
/* Include 5 extra points above the asset price so that don‚Äôt get discontinuity in grid_
spacing
which may adversely affect the computation of the greeks */
n2 = ns_above_S0 + 5;
dz_shift = dz1*5.0; /* shift caused by extra 5 grid points */
dz2 = (log_barrier_level2-log_asset-dz_shift)/(double)ns_above_S0;
dt = opt_mat/(double)nt;
/* time interval size
*/
time_step = dt;
--n2;
ns1 = n1+n2+2;
/* Set up the RHS and LHS coefficients a[], b[] and c[] are the LHS coefficients for the_
unknown option
values (time step j) a1[], b1[] and c1[] are the values of the RHS coefficients for the_
known option prices
(time step j+1). Note: a1, b1 and c1 are used to form the RHS vector rhs[] of the_
tridiagonal system. */
/* Allocate the required arrays (all of size (ns1+2): a,b,c,a1,b1,c1,opt_vals,vals,_
rhs,z,delta,gamma,work,u */
Code excerpt 5.20.

168
Computational Finance Using C and C#
.
.
.
/* Set up the RHS and LHS coefficients a[], b[] and c[] are the LHS coefficients
for the unknown option values (time step j) a1[], b1[] and c1[] are the values of the
RHS coefficients for the known option prices (time step j+1). Note: a1, b1 and c1 are used_
to form the RHS
vector rhs[] of the tridiagonal system. */
/* Set grid line asset values, set one grid spacing to align with the asset price, then won‚Äôt_
have to
interpolate to get the option value */
z[n1] = log_asset;
for (i = 1; i <=n1; ++i) /* This should be the fine mesh */
z[n1-i] = log_asset - (double)i*dz1;
for (i = 1; i <= 5; ++i) /* Include 5 extra fine mesh points here */
z[n1+i] = log_asset + (double)i*dz1;
for (i = 6; i <= n2+2; ++i) { /* The coarse mesh */
j = i - 5;
z[n1+i] = z[n1+5] + (double)j*dz2;
}
/*
Set option values at maturity (for a call). Note : opt_vals[0] and opt_vals[ns1-1] are the
lower and upper
(put/call) option price boundary values. */
for( i=1; i<ns1; ++i ) {
opt_vals[i] = MAX(exp(z[i])-X, zero);
}
opt_vals[0] = zero;
opt_vals[ns1-1] = zero;
tmp = 1.0-theta_m;
/* 1 - theta (for theta method) */
curr_time = -1.0;
ind2 = n_sigma - 1;
for( j=nt-1; j>=-2; --j) { /* Iterate from maturity to current time
*/
if ((ind2 >= 0) && (curr_time <= sigma_times[ind2])) {
sig2 = sigma_array[ind2]*sigma_array[ind2];
t2 = time_step/2.0;
bb = r - q - (sig2/2.0);
--ind2;
for( i=1; i<=ns1-2; ++i) { /* Assign elements of the (ns1-2)*(ns1-2) tridiagonal_
matrix */
ds_plus
= z[i+1]-z[i];
ds_minus = z[i] - z[i-1];
D = ((ds_plus*ds_plus*ds_minus) + (ds_minus*ds_minus*ds_plus));
temp1 = tmp*time_step/D;
a[i] = temp1*(bb*ds_plus*ds_plus) -temp1*ds_plus*(sig2);
temp1 = theta_m*time_step/D;
a1[i] = temp1*ds_plus*(sig2)-temp1*(bb*ds_plus*ds_plus);
temp1 = (ds_minus*ds_minus)/D;
temp2 = ds_minus/D;
c[i]
= -time_step*tmp*(temp1*bb+(sig2*temp2));
c1[i] = time_step*theta_m*(temp1*bb+(sig2*temp2));
temp1 = ((ds_minus*ds_minus) - (ds_plus*ds_plus))/D;
temp2 = (ds_minus+ds_plus)/D;
b[i] = 1.0+time_step*tmp*(r+(bb*temp1)+(sig2)*temp2);
b1[i] = 1.0-time_step*theta_m*(r+(bb*temp1)+(sig2)*temp2);
}
u[1] = b[1];
if (u[1] == zero) printf ("ERROR in array u \n");
for( i=2; i <=ns1-2; ++i) {
u[i] = b[i] - a[i]*c[i-1]/u[i-1];
if (u[i] == zero) printf ("ERROR in array u \n");
}
}
curr_time = j*dt;
/* Set up the rhs of equation for the theta method */
for(i=2; i<=ns1-3; ++i)
rhs[i] = a1[i]*opt_vals[i-1]+b1[i]*opt_vals[i]+c1[i]*opt_vals[i+1];
/* Incorporate the boundary conditions1 at the upper/lower asset value boundaries */
rhs[1] = (a1[1]-a[1])*opt_vals[0]+ b1[1]*opt_vals[1]+c1[1]*opt_vals[2];
rhs[ns1-2] = a1[ns1-2]*opt_vals[ns1-3]+b1[ns1-2]*opt_vals[ns1-2]+(c1[ns1-2]-c[ns1-2])_
*opt_vals[ns1-1];
/* Solve the lower triangular system Ly = b, where y is stored in array work[]. Compute the_
elements of L from those of U, l[i] = a[i]/u[i-1]. */
work[1] = rhs[1];
for( i=2; i<=ns1-2; ++i ) {
work[i] = rhs[i] - a[i]*work[i-1]/u[i-1];
}
Code excerpt 5.20 (Continued).

Single asset American options
169
/* Solve the upper (ns1-2)*(ns1-2) triangular system Ux = y (where x = vold) */
opt_vals[ns1-2] = work[ns1-2]/u[ns1-2];
for( i = ns1-2; i >= 1; --i )
opt_vals[i] = (work[i] - c[i]*opt_vals[i+1])/u[i];
if (j==0) {
for (i=0; i < ns1; ++i)
vals[i] = opt_vals[i];
}
/* Store option values so that can compute theta */
if ((j==1)||(j==2)||(j==-1)||(j==-2)) {
temp[ind] = opt_vals[n1];
++ind;
}
}
if (greeks) {
/* Compute gamma and delta (4th order accuracy) */
greeks[1] = (-vals[n1+2]+8.0*vals[n1+1]-8.0*vals[n1-1]+vals[n1-2])/(12.0*dz1);
/* Compute gamma (4th order accuracy) - use chain rule to obtain derivative wrt S */
greeks[0] = (-vals[n1+2]+16.0*vals[n1+1]-30.0*vals[n1]+16.0*vals[n1-1]-vals[n1-2])_
/(12.0*dz1*dz1);
greeks[0] = greeks[0]-greeks[1];
greeks[0] = greeks[0]/(S0*S0);
greeks[1] = greeks[1]/S0;
/* Compute theta (4th order accuracy) */
greeks[2] = (-temp[0]+8.0*temp[1]-8.0*temp[2]+temp[3])/(12.0*dt);
/* could also compute theta as: greeks[2] = (-temp[0]+4.0*temp[1]-3.0*vals[n1])_
/(2.0*dt);
*/
}
*option_value = vals[n1];
}
Code excerpt 5.20 Code excerpt 5.20 Function to compute the value and Greeks of
a European double knockout call option using a nonuniform grid and a logarithmic
transformation.
Table 5.8 Estimated value of a European double knockout call option
Time steps (n)
Estimated value
Boyle and Tian (1998)
50
1.4569
1.4238
100
1.4578
1.4437
200
1.4583
1.4495
300
1.4583
1.4524
400
1.4584
1.4542
500
1.4584
1.4553
600
1.4584
1.4557
700
1.4584
1.4559
800
1.4584
1.4563
900
1.4584
1.4565
1000
1.4584
1.4566
2000
1.4584
1.4576
3000
1.4584
1.4578
4000
1.4584
1.4580
5000
1.4584
1.4581
The values in column two were computed by the function dko_call, and those in column three
are the results reported in Table 2 of Boyle and Tian (1998). The model parameters were: current
asset price S = 95.0, exercise price E = 100.0, volatility œÉ = 0.25, maturity œÑ = 1.0, interest rate
r = 0.1, dividend yield q = 0.0. The upper barrier level is set at 140.0 and the lower barrier is
set at 90.0. The other parameters used by the function dko_call were: nt = n, ns_below_S0
= n/2, ns_above_S0 = n/2, and Œòm = 0.5 (i.e., the Crank‚ÄìNicolson method).

170
Computational Finance Using C and C#
Table 5.9 The estimated values of European down and out call options calculated by
the function dko_call
Time steps
Stock price
92
91
90.5
90.4
90.3
90.2
50
2.5652
1.3046
0.6588
0.5282
0.3971
0.2653
100
2.5221
1.2816
0.6466
0.5182
0.3894
0.2601
200
2.5104
1.2758
0.6435
0.5157
0.3875
0.2588
300
2.5080
1.2747
0.6429
0.5152
0.3871
0.2585
400
2.5072
1.2743
0.6427
0.5150
0.3869
0.2584
500
2.5069
1.2742
0.6426
0.5149
0.3869
0.2584
600
2.5067
1.2741
0.6425
0.5149
0.3868
0.2583
700
2.5066
1.2740
0.6425
0.5149
0.3868
0.2583
800
2.5065
1.2740
0.6424
0.5148
0.3868
0.2583
900
2.5065
1.2739
0.6424
0.5148
0.3868
0.2583
1000
2.5064
1.2739
0.6424
0.5148
0.3868
0.2583
2000
2.5063
1.2738
0.6424
0.5148
0.3868
0.2583
Closed form
2.5063
1.2738
0.6424
0.5148
0.3868
0.2583
The Ô¨Åxed model parameters were: exercise price E = 100.0, volatility œÉ = 0.25, maturity œÑ = 1.0,
interest rate r = 0.1, dividend yield q = 0.0, and the lower barrier is set at 90.0. The other parameters
used by the function dko_call were: nt = n, ns_below_S0 = n/2, ns_above_S0 = n/2,
upper_barrier = 1000.0, lower_barrier = 90.0, and Œòm = 0.5 (i.e., the Crank‚ÄìNicolson
method).
Table 5.10 The estimated values of European down and out call options as calculated
by the function dko_call
Time steps
Stock price
92
91
90.5
90.4
90.3
90.2
50
2.5572
1.3005
0.6567
0.5266
0.3958
0.2645
100
2.5181
1.2796
0.6455
0.5174
0.3888
0.2597
200
2.5084
1.2748
0.6429
0.5153
0.3872
0.2586
300
2.5067
1.2741
0.6425
0.5149
0.3869
0.2584
400
2.5062
1.2738
0.6424
0.5148
0.3868
0.2583
500
2.5061
1.2738
0.6424
0.5148
0.3868
0.2583
600
2.5061
1.2737
0.6423
0.5148
0.3867
0.2583
700
2.5060
1.2737
0.6423
0.5147
0.3867
0.2583
800
2.5060
1.2747
0.6423
0.5147
0.3867
0.2583
900
2.5060
1.2737
0.6423
0.5147
0.3867
0.2583
1000
2.5060
1.2737
0.6423
0.5147
0.3867
0.2583
2000
2.5061
1.2737
0.6423
0.5147
0.3867
0.2583
Closed form
2.5063
1.2738
0.6424
0.5148
0.3868
0.2583
The Ô¨Åxed parameters used were: exercise price E = 100.0, volatility œÉ = 0.25, maturity œÑ = 1.0,
interest rate r = 0.1, dividend yield q = 0.0, and the lower barrier is set at 90.0. The other parameters
used by the function dko_call were: nt = n, ns_below_S0 = n/2, ns_above_S0 = n/2,
upper_barrier = 1000.0, lower_barrier = 90.0, and Œòm = 0.0 (i.e., the implicit method).

Single asset American options
171
Table 5.11 The estimated values of European double knockout call options computed
by the function dko_call
Time steps
Stock price
92
91
90.5
90.4
90.3
90.2
50
0.6251 (0.6184)
0.3189 (0.3177)
0.1610
0.1290
0.0969
0.0647
100
0.6260 (0.6212)
0.3194 (0.3184)
0.1613
0.1292
0.0971
0.0649
200
0.6263 (0.6228)
0.3196 (0.3186)
0.1613
0.1293
0.0972
0.0649
300
0.6263 (0.6236)
0.3196 (0.3187)
0.1613
0.1293
0.0972
0.0649
400
0.6263 (0.6242)
0.3196 (0.3189)
0.1613
0.1293
0.0972
0.0649
500
0.6263 (0.6252)
0.3196 (0.3190)
0.1613
0.1293
0.0972
0.0649
600
0.6263 (0.6253)
0.3196 (0.3191)
0.1613
0.1293
0.0972
0.0649
700
0.6263 (0.6253)
0.3196 (0.3191)
0.1613
0.1293
0.0972
0.0649
800
0.6263 (0.6255)
0.3196 (0.3192)
0.1613
0.1293
0.0972
0.0649
900
0.6263 (0.6256)
0.3196 (0.3192)
0.1613
0.1293
0.0972
0.0649
1000
0.6263 (0.6255)
0.3196 (0.3192)
0.1613
0.1293
0.0972
0.0649
2000
0.6263 (0.6260)
0.3196 (0.3195)
0.1613
0.1293
0.0972
0.0649
In column 2 and column 3 the values given in Boyle and Tian (1998), Table 5, are shown
for comparison. The Ô¨Åxed model parameters were: exercise price E = 100.0, volatility
œÉ = 0.25, dividend yield q = 0.0, maturity œÑ = 1.0, interest rate r = 0.1, the lower
barrier is set at 90.0, and the upper barrier is set at 140.0. The other parameters used
by the function dko_call were: nt = n, ns_below_S0 = n/2, ns_above_S0 = n/2,
and Œòm = 0.5 (i.e., the Crank‚ÄìNicolson method).
Table 5.12 The estimated Greeks for European double knockout call options computed
by the function dko_call
Asset price
Gamma
Delta
Theta
95.0
‚àí0.0165 (‚àí0.0166)
0.2536 (0.2551)
2.3982 (2.3928)
92.0
‚àí0.0141 (‚àí0.0141)
0.2998 (0.3016)
1.0268 (1.0242)
91.0
‚àí0.0129 (‚àí0.0130)
0.3133 (0.3151)
0.5237 (0.5224)
90.5
‚àí0.0123 (‚àí0.0123)
0.3196 (0.3215)
0.2643 (0.2636)
90.4
‚àí0.0121 (‚àí0.0122)
0.3208 (0.3227)
0.2119 (0.2113)
90.3
‚àí0.0120 (‚àí0.0121)
0.3221 (0.3239)
0.1592 (0.1588)
90.2
‚àí0.0119 (‚àí0.0119)
0.3233 (0.3251)
0.1063 (0.1060)
The Ô¨Åxed model parameters: the exercise price E = 100.0, volatility œÉ = 0.25, dividend
yield q = 0.0, maturity œÑ = 1.0, interest rate r = 0.1, the lower barrier is set at 90.0, and
the upper barrier is set at 140.0. The other parameters used by the function dko_call
were: nt = 200, ns_below_S0 = 100, ns_above_S0 = 100, and Œòm = 0.5 (i.e., the
Crank‚ÄìNicolson method). The results for Œòm = 0.0 (i.e., the implicit method) are shown
in brackets; see Table 6, Boyle and Tian (1998).
Inspection of the results shows that the Ô¨Ånite-difference grid method has both
greater accuracy and faster convergence than the method proposed by BT. The

172
Computational Finance Using C and C#
key to the accuracy achieved by dko_call is a combination of:
‚Ä¢ The logarithmic transformation of the Black‚ÄìScholes equation
‚Ä¢ The ability to place a grid line at both the upper barrier BU, and also at the
lower boundary BL
‚Ä¢ The use of a weighted Œòm Ô¨Ånite-difference scheme, 0 ‚©ΩŒòm ‚©Ω1, instead of
the numerically unstable explicit Ô¨Ånite-difference method used by a trinomial
lattice which in our notation (see Section 5.4.2) is equivalent to Œòm = 1.
It should be mentioned that the function dko_call could, without much
difÔ¨Åculty, be modiÔ¨Åed to deal with:
‚Ä¢ American double knockout call options
‚Ä¢ European double knockout put options
‚Ä¢ American double knockout put options
and also a range of other variations which may include lockout periods, rebates,
etc. In particular, options with time-varying barrier levels can be dealt with by
using grid lines to locate the barrier position at each time instant.
5.5
Pricing American options using a stochastic lattice
In this section we consider the use of Monte Carlo simulation and stochastic
lattices to price American options. Information on the use of Monte Carlo sim-
ulation to value both single asset and multiasset European options is provided
in Chapter 4 and Chapter 6. The main difÔ¨Åculty in using simulation to value
American options is the need to incorporate optimal early exercise policies. The
standard simulation algorithms for valuing European contracts are forward in
time. That is each price path, which contributes to the value of the option, is
generated by stepping forward from current time, t, to option maturity, t + œÑ,
where œÑ is the duration of the option. For instance if there are n equispaced
time steps of size t, and only one underlying asset, then we use the asset values
Si, i = 0, . . . , n, where Si corresponds to the asset value at the ith time instant,
ti, and t0 = t. Here Si+1 is generated from the previous asset value Si as follows:
Si+1
Si
= dSi
for i = 0, . . . , n ‚àí1
(5.5.1)
where dSi is a random variate taken from a given distribution. When Si follows
GBM, we have from Eq. (2.3.11) that:
Si+1
Si
= exp

r ‚àíœÉ 2
i
2

t + œÉi dWi

,
i = 0, . . . , n ‚àí1,
(5.5.2)
where dWi ‚àºN(0, t) and the usual deÔ¨Ånitions are used for œÉi and r.
For European exotic options (such as time dependent barrier options) the
value of a particular price path will depend on the asset values Si, i = 0, . . . , n.

Single asset American options
173
This is not true of European vanilla options whose value only depends on Sn,
the underlying asset price at option maturity. The Monte Carlo approximation
to the value of a European option is thus:
f =

nsim
j=1 pj(nj)
nsim
where nsim is the number of simulations used, nj is the number of time steps
associated with the jth price path, and pj(nj) is the value of the jth price path.
In the case of European vanilla options we can use nj = 1, j = 1, . . . , nsim; the
accuracy obviously improves with increasing nsim.
The valuation of American-style options, which include the possibility of early
exercise, is more complicated. In Chapter 5 we described the use of binomial lat-
tices to price American options when the underlying asset price process is GBM.
Dynamic programming was used and the option prices were computed by work-
ing backward in time through the lattice. The application of Monte Carlo meth-
ods for pricing American options is described in Tilley (1993), Barraquand and
Martineau (1995), and also Boyle, Broadie, and Glasserman (1997). Here we
will outline the stochastic lattice approach discussed in Broadie and Glasserman
(1997), where both a high estimator and a low estimator of the American op-
tion value are calculated. Since both of these biased estimators converge (with
increasing number of simulations and lattice nodes) to the true option value, we
will only consider how to compute the high estimator, Œ∏H. We summarize the
approach as follows
‚Ä¢ Set the parameters
‚Ä¢ Generate the lattice asset prices
‚Ä¢ Compute the lattice option prices
‚Ä¢ Compute the Monte Carlo estimate.
We will now consider each of these steps in more detail.
Set the parameters
First we set the simulation parameters; that is: nsim is the number of lattice
simulations, b is the number of branches per lattice node, and d is the number
of time instants in the lattice. Note: This deÔ¨Ånition of d here is different from
that used in the original paper by Broadie and Glasserman (1997) where d is
deÔ¨Åned as the number of time steps in the lattice.
Generate the lattice asset prices
Next we generate the asset prices for the pth stochastic lattice. Since the lattice is
non recombining at the i lattice time instant there are bi nodes/asset prices. This
contrasts with the binomial lattice of Chapter 5 where the asset prices at a given
time step are arranged in ascending order, that is Sj
i increases with increasing j.

174
Computational Finance Using C and C#
Figure 5.9 An example showing the asset prices generated for a stochastic lattice with
three branches per node and two time steps, that is b = 3 and d = 3. The current asset
value, 101, is at time t0, and the asset values at option maturity are at time t2.
We will denote the jth value at the ith time step by Sj
i . For example, in Fig. 5.9,
where b = 3 and d = 3, we have for the Ô¨Årst time step:
S1
1 = 115,
S2
1 = 60,
and S3
1 = 114
and for the second time step:
S1
2 = 116,
S2
2 = 90,
S3
2 = 149,
. . . ,
S7
2 = 102,
S8
2 = 88,
S9
2 = 80
The kth asset price at the ith time step, Sk
i then generates the following asset
prices at the (i + 1)th time step:
S(k‚àí1)b+j
i+1
Sk
i
= dSj,
j = 1, . . . , b, k = 1, . . . , bi,
where (see Eq. (5.5.1)), dSj is a random variate from a given distribution. When
Si follows GBM, we therefore have:
S(k‚àí1)b+j
i+1
Sk
i
= exp

r ‚àíœÉ 2
i
2

t + œÉi dWi

,
j = 1, . . . , b, k = 1, . . . , bi
Compute the lattice option prices
The method used to compute the option values is similar to that used by the
binomial lattice. The main difference is that there are now b branches per node
instead of two. The option values are computed by starting at the lattice termi-

Single asset American options
175
nal nodes and then iterating backward. Here we denote the kth option value at
the ith time step by f k
i .
The option values at the terminal nodes, time instant td‚àí1, are computed in
the usual manner. For a put we have:
f k
d‚àí1 = max

E ‚àíSk
d‚àí1, 0

,
k = 1, . . . , bd‚àí1,
where E is the exercise price.
The option values at the (i ‚àí1)th time step are computed from those at the
ith time step as follows:
f k
i‚àí1 = max

gk
i‚àí1, hk
i‚àí1

where
hk
i‚àí1 = exp(‚àírt)
b
b

j=1
f (k‚àí1)b+j
i
and
gk
i‚àí1 = max

E ‚àíSk
i‚àí1, 0

The option value for the pth stochastic lattice is therefore:
Œ∏p
H = f 1
0 = exp(‚àírt)
b
b

j=1
f j
1
Figure 5.10 shows the option values for an American call with strike price E =
100 and interest rate r = 0, when the lattice asset prices in Fig. 5.9 have been
Figure 5.10 The option prices for the b = 3, d = 3 lattice in Fig. 5.9 corresponding to an
American put with strike E = 100 and interest rate r = 0. The option values at the lattice
nodes are computed backwards in time from the payoffs at maturity, t2 to the current
time t0; the value of the option is 11.9.

176
Computational Finance Using C and C#
used. To make things as clear as possible, we will show how the value of each
node is computed.
Terminal nodes
The option values at the terminal nodes are:
f 1
2 = max(116 ‚àí100, 0) = 16,
f 2
2 = max(90 ‚àí100, 0) = 0,
f 3
2 = max(149 ‚àí100, 0) = 49,
f 4
2 = max(32 ‚àí100, 0) = 0,
f 5
2 = max(50 ‚àí100, 0) = 0,
f 6
2 = max(48 ‚àí100, 0) = 0,
f 7
2 = max(102 ‚àí100, 0) = 2,
f 8
2 = max(88 ‚àí100, 0) = 0,
f 9
2 = max(80 ‚àí100, 0) = 0
Time step 1
Here we have:
g1
1 = max(115 ‚àí100, 0) = 15,
g2
1 = max(60 ‚àí100, 0) = 0,
g3
1 = max(114 ‚àí100, 0) = 14
Since r = 0, we have exp(‚àírt) = 1 which gives:
h1
1 = 1
3

f 1
2 + f 2
2 + f 3
2

= 1
3{16 + 0 + 49} = 21.7
h2
1 = 1
3

f 4
2 + f 5
2 + f 6
2

= 1
3{0 + 0 + 0} = 0
h3
1 = 1
3

f 7
2 + f 8
2 + f 9
2

= 1
3{2 + 0 + 0} = 0.66
The option values are then computed as follows:
f 1
1 = max

h1
1, g1
1

= max(21.7, 15) = 21.7
f 2
1 = max

h2
1, g2
1

= max(0, 0) = 0
f 3
1 = max

h3
1, g3
1

= max(0.66, 14.0) = 14.0
Time step 0
Here
g1
0 = max(101 ‚àí100, 0) = 1
and
h1
0 = 1
3

f 1
1 + f 2
1 + f 3
1

= 1
3{21.7 + 0 + 14.0} = 11.9
The Ô¨Ånal value of the option for this particular lattice is therefore:
f 1
1 = max

h1
0, g1
0

= max(11.9, 1) = 11.9

Single asset American options
177
Compute the Monte Carlo estimate
The Monte Carlo estimate, Œ∏H, is computed as the average of Œ∏p
H, p
=
1, . . . , nsim, where nsim is the number of simulations:
Œ∏H =

nsim
i=1 Œ∏i
H
nsim
In Code excerpt 5.21, we provide a computer program which prices single asset
American put and call options using a stochastic lattice. The method used by the
program is the depth Ô¨Årst procedure outlined in Broadie and Glasserman (1997),
which has the advantage that the memory requirements are only of order b √ó d;
as before, b is the number of branches per node and d is the number of time
intervals.
Here it is assumed the underlying asset follows GBM and the function
normal(M, S) is used to generate a normal distribution with mean M and
standard deviation S. We can therefore check the accuracy of the simulation
with that obtained by a closed form solution which assumes a lognormal asset
distribution, in this case the formula in Geske and Johnson (1984).
However, the real power of this method is when the underlying asset fol-
lows a more realistic process which is non-Gaussian and time varying. The only
modiÔ¨Åcation to the code is to replace the call to normal with that of another
probability distribution and supply the time-varying parameters to it.
// Stochastic lattice for computing the value of American and European options via Monte Carlo_
simulation.
// Here we assume that the asset prices have a lognormal distribution, and so generate
// normal variates; this assumption can easily be removed.
void __cdecl main()
{
long i,j,jj,is_put,is_american,w[200],num_simulations,b,d,seed;
double T,time_step,sqrt_time_step,opt_value,pay_off,log_fac,asset_price;
double temp,opt_val,hold,sum_opt_val,disc;
double tot_opt_vals, X, drift_term, std_term, S0, q, r, sigma, zero = 0.0;
double v[200][60], opt_v[200][60];
printf("Stochastic lattice for pricing European and American options \n");
is_put = 1;
// If is_put == 0 then a call option, otherwise a put option
T = 1.0;
// The time to maturity of the option
is_american = 1; // If is_american
== 0 then an European option, otherwise an American_
option
sigma = 0.2;
// The volatility of the underlying asset
X = 110.0;
// The strike price
S0 = 100.0;
// The current price of the underlying assset
r = 0.1;
// The risk free interest rate
q = 0.05;
// The continuous dividend yield
d = 4;
// The number of time steps, the number time intervals = d - 1
b = 50;
// The number of branches per node in the lattice
time_step = T/(double)(d-1); // time step = T/(number of time intervals)
sqrt_time_step = sqrt(time_step);
disc = exp(-r*time_step); // The discount factor between time steps
std_term = sigma*sqrt(time_step); // The standard deviation of each normal variate generated
drift_term = (r - q - sigma*sigma*0.5)*time_step; // The mean value of each normal variate_
generated
seed = 111;
// The seed for the random number generator
srand(seed);
tot_opt_vals = zero;
num_simulations = 100;
for (jj = 1; jj <= num_simulations; ++jj) {
v[1][1] = S0;
Code excerpt 5.21.

178
Computational Finance Using C and C#
w[1] = 1;
asset_price = S0;
for (j = 2; j <= d; ++j) {
w[j] = 1;
log_fac = normal(drift_term,std_term); // A normal variate:mean==drift_term,_
standard deviation==std_term
asset_price = asset_price*exp(log_fac); // Compute the new asset price: assuming a_
lognormal distribution
v[1][j] = asset_price;
}
j = d;
while (j > 0) {
if ((j == d) && (w[j] < b)) { // CASE 1::Terminal node, set asset prices for b branches,_
and option values for b-1 branches
if (is_put ) {
pay_off = MAX (X - v[w[j]][j],zero);
}
else {
pay_off = MAX (v[w[j]][j]-X,zero);
}
opt_v[w[j]][j] = pay_off;
asset_price = v[w[j-1]][j-1];
log_fac = normal(drift_term,std_term);
v[w[j]+1][j] = asset_price*exp(log_fac);
w[j] = w[j] + 1;
}
else if ((j == d) && (w[j] == b)) { // CASE 2::Terminal node, set option value for last_
branch
if (is_put) {
pay_off = MAX (X - v[w[j]][j],zero);
}
else {
pay_off = MAX (v[w[j]][j]-X,zero);
}
opt_v[w[j]][j] = pay_off;
w[j] = 0;
j = j - 1;
}
else if ((j < d) && (w[j] < b)) { // CASE 3::Internal node, calculate option value for_
node (parent wrt to cases 1 & 2)
sum_opt_val = zero;
// Also generate a new terminal node and set asset_
values.
for (i = 1; i <= b; ++i) {
sum_opt_val += opt_v[i][j+1];
}
temp = sum_opt_val/(double)b;
hold = temp*disc;
if (is_american) { // An American option
if (is_put) {
pay_off = MAX(X-v[w[j]][j],zero); // pay off for a put option
}
else {
pay_off = MAX(v[w[j]][j]-X,zero);
// pay off for a call option
}
opt_val = MAX(pay_off,hold);
}
else { // A European option
opt_val = hold;
}
opt_v[w[j]][j] = opt_val;
if (j > 1) {
asset_price = v[w[j-1]][j-1];
log_fac = normal(drift_term,std_term);
v[w[j]+1][j] = asset_price*exp(log_fac);
w[j] = w[j] + 1;
for (i = j + 1; i <= d; ++i) { // Generate a new terminal node
log_fac = normal(drift_term,std_term);
asset_price = asset_price*exp(log_fac);
v[1][i] = asset_price;
w[i] = 1;
}
j = d;
}
else {
j = 0;
}
Code excerpt 5.21 (Continued).

Single asset American options
179
}
else if ((j < d) && (w[j] == b)) { // CASE 4::Internal node, calculate the option value_
for the last branch
sum_opt_val = zero;
for (i = 1; i <= b; ++i) {
sum_opt_val += opt_v[i][j+1];
}
temp = sum_opt_val/(double)b;
hold = temp*disc;
if (is_american) { // An American option
if (is_put) {
pay_off = MAX(X - v[w[j]][j],zero); // pay off for a put option
}
else {
pay_off = MAX(v[w[j]][j]-X,zero); // pay off for a call option
}
opt_val = MAX(pay_off,hold);
}
else { // A European option
opt_val = hold;
}
opt_v[w[j]][j] = opt_val;
w[j] = 0;
j = j - 1;
}
}
tot_opt_vals = tot_opt_vals + opt_v[1][1]; // Sum the option values for each simulation
}
opt_value = tot_opt_vals/(double)num_simulations; // Compute the average option value
printf ("The estimated option value = %12.4f\n", opt_value);
}
Code excerpt 5.21 A computer program that uses a stochastic lattice to value American
and European options.
Table 5.13 American put option values, computed using the stochastic lattice given in
Code excerpt 5.21, with four exercise times t, t + œÑ/3, t + 2œÑ/3 and t + œÑ
X
MC100
50
MC1
250
True
Binomial lattice
70
0.118 (0.003)
0.123 (0.002)
0.121
0.126
80
0.663 (0.007)
0.672 (0.002)
0.670
0.696
90
2.317 (0.014)
2.307 (0.004)
2.303
2.389
100
5.830 (0.099)
5.720 (0.011)
5.731
5.928
110
11.564 (0.223)
11.361 (0.020)
11.341
11.770
120
20.205 (0.205)
20.000 (0.000)
20.000
20.052
130
30.054 (0.054)
30.000 (0.000)
30.000
30.000
The option parameters used were: r = 0.1, q = 0.05, œÑ = 1.0, œÉ = 0.2, and S = 100.0.
The column labelled MC100
50
refers to the results obtained using d = 4, b = 50,
num_simulations = 100, and the column labelled MC1
250 refers to the results obtained
using d = 4, b = 50, num_simulations = 1. The true values are those given in Broadie
and Glasserman (1997), and were computed with the formula in Geske and Johnson
(1984). The absolute error, ABS(stochastic_lattice_value ‚àítrue_value), is given in
brackets. The last column gives the values computed using an accurate (6000 time step)
binomial lattice.
In Table 5.13 we present computed values of an American put option with
maturity œÑ, which can only be exercised at the following four times: t, t + œÑ/3,
t + 2œÑ/3 and t + œÑ, where t is the current time.

180
Computational Finance Using C and C#
The column labelled MC100
50 contains the results obtained using 100 simula-
tions of a stochastic lattice with 50 branches per node, and the column labelled
MC1
250 contains the values computed using a single stochastic lattice with 250
branches per node. These values demonstrate that one high accuracy stochas-
tic lattice can give better results than using the average of 100 lower accuracy
lattices. In the last column we present the results obtained using a 6000 step
binomial lattice in which it is possible to exercise the option at every time step.
It can be seen that the binomial option values are higher than the true values,
which only permit the option to be exercised at four distinct times. This is in
agreement with the extra Ô¨Çexibility present in the binomial lattice.

6 Multiasset options
6.1
Introduction
In this section we consider the valuation of multiasset, basket, options within
the Black‚ÄìScholes pricing framework. These options will be priced using the
following techniques:
‚Ä¢ Analytic methods
‚Ä¢ Monte Carlo methods
‚Ä¢ Multidimensional lattices
Analytic methods can be useful for pricing multiasset European options which
have a known closed form solution. They are particularly appropriate for low
dimensional European options, when the closed form expressions are not too
difÔ¨Åcult to evaluate.
Monte Carlo methods have the advantage that they can easily compute the
value of multiasset European options, but have difÔ¨Åculty including the possibil-
ity of early exercise; this is required for American-style options.
On the other hand, multidimensional lattice techniques allow American op-
tions to be evaluated with ease. However, lattices become increasingly difÔ¨Åcult
to program as the number of dimensions increases, and the constraints of com-
puter storage limits their use to problems involving (about) four or less assets.
6.2
The multiasset Black‚ÄìScholes equation
In Chapter 2 we mentioned that when the price, S, of a single asset follows
geometric Brownian motion (GBM) the change in price, dS, over a time interval,
dt, is given by:
dS = rS dt + œÉS dW
where r is the risk free interest rate, œÉ is the volatility of asset S, and dW ‚àº
N(0, dt).
We also proved using Ito‚Äôs lemma that the process followed by Y = log(S) is:
dY =

r ‚àíœÉ 2
2

dt + œÉ dW

182
Computational Finance Using C and C#
where dY is the change in the value of log(S) over the time interval dt. Later on
we derived the (Black‚ÄìScholes) partial differential equation that is satisÔ¨Åed by
the value, V , of an option written on a single underlying asset. The equation is
‚àÇV
‚àÇt + œÉ 2S2
2
‚àÇ2V
‚àÇS2 + rS ‚àÇV
‚àÇS ‚àírV = 0
The above result can be generalized to deal with multiasset options. Suppose
that m assets are described by the following processes:
dYi =

r ‚àíœÉ 2
i
2

dt + œÉi dWi,
i = 1, . . . , m,
(6.2.1)
where the subscript i refers to the value associated with the ith asset. The
m-element random vector dW is distributed according to dW ‚àºN(0, C). The
diagonal elements of C are Cii = Var[dWi] = dt, i = 1, . . . , m, and off-diagonal
elements are:
Cij = E[dWi dWj] = œÅi,j dt,
i = 1, . . . , m, j = 1, . . . , m, i Ã∏= j
We can also write the above equation in vector form by introducing the
m-element vector dY which is normally distributed as:
dY ‚àºN(ŒΩ, C)
(6.2.2)
where ŒΩ is the mean vector and C is the covariance matrix. The elements of the
covariance matrix are:
Cii = œÉ 2
i dt,
i = 1, . . . , m,
Cij = œÉiœÉjœÅij dt,
i Ã∏= j, i = 1, . . . , m, j = 1, . . . , m,
(6.2.3)
where œÅij is the correlation coefÔ¨Åcient between asset i and asset j; that is, the
correlation between dWi and dWj. The elements of the mean vector ŒΩ are:
ŒΩi = r ‚àíœÉ 2
i
2 ,
i = 1, . . . , m
(6.2.4)
The value V of an option written on m assets satisÔ¨Åes the following partial
differential equation:
‚àÇV
‚àÇt + 1
2
m

i=1
m

j=1
œÉiœÉjœÅijSiSj
‚àÇ2V
‚àÇSi ‚àÇSj
+ r
m

i=1
Si
‚àÇV
‚àÇSi
‚àírV = 0.
For a European call on the maximum of m assets the pay-off PMAX
c
at maturity
(time œÑ) is given by PMAX
c
= max(max(SœÑ
1 , SœÑ
2, . . . , SœÑ
m) ‚àíE, 0), where SœÑ
i , i =
1, . . . , m, denotes the value of the ith asset at maturity, and E represents the
strike price. Similarly a European put option on the minimum of m assets has a
pay-off, PMIN
p
, at time œÑ, given by PMIN
p
= max(E ‚àímin(SœÑ
1 , SœÑ
2 , . . . , SœÑ
m), 0).

Multiasset options
183
6.3
Multidimensional Monte Carlo methods
We have already mentioned that Monte Carlo simulation can easily price Euro-
pean multiasset options (also sometimes referred to as basket options, or rain-
bow options) involving a large number of assets (say 20 or more).
In addition Monte Carlo simulation can also include the following features
into an option without much difÔ¨Åculty:
‚Ä¢ Non-Gaussian distribution of stock returns; distributions with heavy tails are
usually of interest because they more accurately represent what is observed in
the Ô¨Ånancial markets
‚Ä¢ Options with path dependency (such as barrier options, etc.); these are known
as exotic options
‚Ä¢ Complex time dependency (e.g., ARMA, GARCH or Levy processes) of
model parameters such as interest rates, asset prices, etc.
The main drawbacks with Monte Carlo simulation are:
‚Ä¢ It is to difÔ¨Åcult compute the value of American-style options
‚Ä¢ It is difÔ¨Åcult (or impossible) to achieve the same accuracy that can be obtained
using Ô¨Ånite difference methods.
In a different section of this book we will show how Monte Carlo simulation
can be used to price American options by using a hybrid Monte Carlo lattice
approach originally developed by Boyle, Evnine, and Gibbs (1997).
In Chapter 3 we show that when pseudo-random numbers are used, the stan-
dard errors of integrals computed via Monte Carlo simulation decrease at the
rate N1/2, where N is the number of simulations. This means that it can re-
quire hundreds of thousands of simulations just to achieve an accuracy of 10‚àí1
or 10‚àí2 in the estimated option price. It is because of this that various Monte
Carlo variance reduction techniques are used to increase the accuracy of the
computed integral.
In this section we show how to price a three-asset basket option using Monte
Carlo simulation; the accuracy of the results obtained with quasirandom num-
bers and pseudo-random numbers are compared.
The options we consider are European put and call options on the maximum
and minimum of three assets. All the options have a maturity of one year, and
the other model parameters used are given in Tables 6.1 and 6.2.
In Code excerpt 6.1 most of the work is done by the routine multivari-
ate_normal. This generates a vector of multivariate pseudo-random numbers
with a particular covariance matrix. In the program the values of the assets at
current time t are S1 = S2 = S3 = 100, and the option matures in one year.
The asset process evolves according to
dYi = log(Si,t+dt) ‚àílog(Si,t) =

r ‚àíœÉ 2
i
2

dt + œÉi dWi,
i = 1, . . . , m,

184
Computational Finance Using C and C#
Table 6.1 The computed values and absolute errors, in brackets, for European options
on the maximum of three assets
Nsim
Put
Quasi
Pseudo
500
0.890 (4.5948 √ó 10‚àí2)
1.1044 (1.6839 √ó 10‚àí1)
1000
0.924 (1.1534 √ó 10‚àí2)
1.0193 (8.3297 √ó 10‚àí2)
1500
0.919 (1.6807 √ó 10‚àí2)
0.8957 (4.0344 √ó 10‚àí2)
2000
0.932 (4.3221 √ó 10‚àí3)
0.8995 (3.6488 √ó 10‚àí2)
2500
0.932 (3.5698 √ó 10‚àí3)
0.8886 (4.7352 √ó 10‚àí2)
3000
0.937 (1.1376 √ó 10‚àí3)
0.9025 (3.3548 √ó 10‚àí2)
Call
Quasi
Pseudo
500
22.629 (4.3231 √ó 10‚àí2)
22.4089 (2.6312 √ó 10‚àí1)
1000
22.683 (1.1306 √ó 10‚àí2)
22.3520 (3.1998 √ó 10‚àí1)
1500
22.670 (2.2954 √ó 10‚àí3)
22.6346 (3.7430 √ó 10‚àí2)
2000
22.685 (1.3299 √ó 10‚àí2)
22.7675 (9.5491 √ó 10‚àí2)
2500
22.670 (1.6619 √ó 10‚àí3)
22.9326 (2.6058 √ó 10‚àí1)
3000
22.679 (7.2766 √ó 10‚àí3)
22.8050 (1.3301 √ó 10‚àí1)
Monte Carlo simulation was used with both quasirandom (Sobol) sequences and pseudo-
random sequences. The number of paths used varied from 500 to 3000. The parameters
were: E = 100.0, S1 = S2 = S3 = 100.0, r = 0.1, œÑ = 1.0, œÉ1 = œÉ2 = œÉ3 = 0.2, œÅ12 =
œÅ13 = œÅ23 = 0.5, q1 = q2 = q3 = 0.0. The accurate values were 0.936 for a put and
22.672 for a call; see Table 6.7 and Table 2 of Boyle, Evnine, and Gibbs (1989).
where we have used the notation Si,t to denote the value of the ith asset at
current time t, and Si,t+dt to denote the value of the asset at the future time
t + dt. Simple rearrangement of the above equation gives:
log
Si,t+dt
Si,t

=

r ‚àíœÉ 2
i
2

dt + œÉi dWi,
i = 1, . . . , m
Taking exponentials of both sides we obtain:
Si,t+dt
Si,t
= exp

r ‚àíœÉ 2
i
2

dt + œÉi dWi

,
i = 1, . . . , m,
which is equivalent to:
Si,t+dt = Si,t exp

r ‚àíœÉ 2
i
2

dt + œÉi dWi

(6.3.1)

Multiasset options
185
Table 6.2 The computed values and absolute errors, in brackets, for European options
on the minimum of three assets
Nsim
Put
Quasi
Pseudo
500
7.365 (3.8122 √ó 10‚àí2)
7.6760 (2.7298 √ó 10‚àí1)
1000
7.425 (2.1554 √ó 10‚àí2)
7.7607 (3.5772 √ó 10‚àí1)
1500
7.408 (5.1232 √ó 10‚àí3)
7.5654 (1.6240 √ó 10‚àí1)
2000
7.399 (3.6364 √ó 10‚àí3)
7.4820 (7.8995 √ó 10‚àí2)
2500
7.407 (4.1463 √ó 10‚àí3)
7.3592 (4.3754 √ó 10‚àí2)
3000
7.400 (2.7166 √ó 10‚àí3)
7.3997 (3.3236 √ó 10‚àí3)
Call
Quasi
Pseudo
500
5.312 (6.3431 √ó 10‚àí2)
5.3086 (5.9591 √ó 10‚àí2)
1000
5.293 (4.3958 √ó 10‚àí2)
5.4376 (1.8857 √ó 10‚àí1)
1500
5.253 (4.0761 √ó 10‚àí3)
5.4121 (1.6307 √ó 10‚àí1)
2000
5.266 (1.7236 √ó 10‚àí2)
5.4029 (1.5390 √ó 10‚àí1)
2500
5.267 (1.7707 √ó 10‚àí2)
5.4690 (2.2005 √ó 10‚àí1)
3000
5.245 (3.5024 √ó 10‚àí3)
5.4331 (1.8407 √ó 10‚àí1)
Monte Carlo simulation was used with both quasirandom (Sobol) sequences and pseudo-
random sequences. The number of paths used varied from 500 to 3000. The parameters
were: E = 100.0, S1 = S2 = S3 = 100.0, r = 0.1, œÑ = 1.0, œÉ1 = œÉ2 = œÉ3 = 0.2, œÅ12 =
œÅ13 = œÅ23 = 0.5, q1 = q2 = q3 = 0.0. The accurate values were 7.403 for a put and 5.249
for a call; see Table 6.8 and Table 2 of Boyle, Evnine, and Gibbs (1989).
6.4
Introduction to multidimensional lattice methods
Finite-difference lattices can be used to value options on up to about 4 assets
before they require impossibly large amounts of computer memory. The main
advantage of Ô¨Ånite-difference methods is that they are able to easily cater for
American style early exercise within the option. This is not true of Monte Carlo
methods. They can easily model complex European options, but have difÔ¨Åculty
modelling American-style options.
In this section we use the approach of Kamrad and Ritchken (1991), and
Boyle, Evnine, and Gibbs (1989), which we will call the BEGKR method, to
price multiasset options. We Ô¨Årst derive expressions for the jump size and jump
probabilities for a single asset, and show that these are equivalent to those of the
Cox, Ross, and Rubinstein binomial lattice (CRR lattice) discussed in Chapter 5.
We will then give expressions for the jump sizes and jump probabilities of a
general multiasset option.
To derive the BEGKR equations for one asset we Ô¨Årst assume that the asset
follows a lognormal process with drift Œº = r ‚àíœÉ 2/2, where r is the riskless
interest rate and œÉ is the instantaneous volatility.

186
Computational Finance Using C and C#
/* Monte Carlo simulation: 3 dimensional Black-Scholes, The results are compared with those_
of Boyle et. al.,1989
George Levy: 2007
*/
long seed,i,num_simulations,iflag;
double time_step,sqrt_time_step,rho, zero = 0.0, half = 0.5;
double r,opt_val, opt_val1, tol;
double the_max, the_min, X, ST1, ST2, ST3, ST4, S1, S2, S3, S4;
double disc, sumit_max_put, sumit_max_call;
double sumit_min_put, sumit_min_call;
double *rvec = (double *)0;
double rho_12, rho_13, rho_23;
double
*c3, *c4, *z, *std, *means;
double tmp1, tmp2, tmp3, tmp4, sigma1, sigma2, sigma3, sigma4;
long is_fcall;
#define MEANS(I) means[(I)-1]
#define XBAR(I) xbar[(I)-1]
#define Z(I) z[(I)-1]
#define STD(I) std[(I)-1]
#define C3(I,J) c3[((I)-1) * 3 + ((J)-1)]
seed = 111;
r = 0.1;
sigma1 = 0.2;
sigma2 = 0.2;
sigma3 = 0.2;
S1 = 100.0;
S2 = 100.0;
S3 = 100.0;
X = 100.0;
rho_12 = 0.5;
rho_13 = 0.5;
rho_23 = 0.5;
time_step = 1.0;
sqrt_time_step = sqrt(time_step);
disc = exp(-r*time_step);
c3 = ALLOCATE(3*3, double);
means = ALLOCATE(3, double);
z = ALLOCATE(3, double);
std = ALLOCATE(3, double);
if ((!means) || (!std) || (!z) ) {
printf("Allocation error \n");
}
tmp1 = sigma1*sigma1*time_step;
tmp2 = sigma2*sigma2*time_step;
tmp3 = sigma3*sigma3*time_step;
C3(1,1) = tmp1;
C3(2,2) = tmp2;
C3(3,3) = tmp3;
C3(1,2) = sigma1*sigma2*time_step*rho_12;
C3(2,3) = sigma2*sigma3*time_step*rho_23;
C3(1,3) = sigma1*sigma3*time_step*rho_13;
C3(2,1) = C3(1,2);
C3(3,1) = C3(1,3);
C3(3,2) = C3(2,3);
tmp1 = (r - sigma1*sigma1*half)*time_step;
tmp2 = (r - sigma2*sigma2*half)*time_step;
tmp3 = (r - sigma3*sigma3*half)*time_step;
MEANS(1) = tmp1;
MEANS(2) = tmp2;
MEANS(3) = tmp3;
Code excerpt 6.1 A Monte Carlo simulation computer program, using pseudo-random
numbers, for estimating the value of European put and call options on the maximum and
minimum of three underlying assets. The results are presented in Tables 6.1 and 6.2.

Multiasset options
187
sumit_max_put = zero;
sumit_max_call = zero;
sumit_min_put = zero;
sumit_min_call = zero;
tol = 1.0e-8;
srand(seed);
is_fcall = 1;
/* initialisation call to the random number generator */
multivariate_normal(is_fcall,&MEANS(1),3,&C3(1,1),3,tol,&rvec,&Z(1),&iflag);
num_simulations = 6000;
is_fcall = 0;
for (i = 1; i <= num_simulations ; ++i) {
/* continuation calls to the random number generator */
multivariate_normal(is_fcall,&MEANS(1),3,&C3(1,1),3,tol,&rvec,&Z(1),&iflag);
ST1 = S1*exp(Z(1));
ST2 = S2*exp(Z(2));
ST3 = S3*exp(Z(3));
// options on the maximum
tmp2 = MAX(ST1,ST2);
the_max = MAX(tmp2,ST3);
tmp1 = the_max-X;
opt_val1 = MAX(tmp1, zero);
sumit_max_call += opt_val1*disc;
tmp1 = X-the_max;
opt_val1 = MAX(tmp1, zero);
sumit_max_put += opt_val1*disc;
// options on the minimum
tmp2 = MIN(ST1,ST2);
the_min = MIN(tmp2,ST3);
tmp1 = the_min-X;
opt_val1 = MAX(tmp1, zero);
sumit_min_call += opt_val1*disc;
tmp1 = X-the_min;
opt_val1 = MAX(tmp1, zero);
sumit_min_put += opt_val1*disc;
}
opt_val = sumit_max_put/(double)num_simulations;
/* put option value on the maximum_
of three assets */
opt_val = sumit_max_call/(double)num_simulations; /* call option value on the maximum_
of three assets */
opt_val = sumit_min_put/(double)num_simulations; /* put option value on the minimum_
of three assets */
opt_val = sumit_min_call/(double)num_simulations; /* call option value on the maximum_
of three assets */
}
Code excerpt 6.1 (Continued).
Therefore if St is the price of the asset at time t, and St+t is the price at time
instant t + t, we then have the following equations:
log(St+t) = log(St) + Œµt,
Œµt ‚àºN

Œºt, œÉ 2t

,
or equivalently
log
St+t
St

‚àºN

Œºt, œÉ 2t

where Œµt represents a random variable and as usual N(Œºt, œÉ 2t) denotes a
Gaussian with mean Œºt and variance œÉ 2t.

188
Computational Finance Using C and C#
We will now consider the situation when Œµt either jumps up or down by an
amount ŒΩ = œÉ
‚àö
t. For an up jump:
log
St+t
St

= œÉ
‚àö
t
and therefore St+t = St exp(œÉ
‚àö
t).
While for a down jump we have
log
St+t
St

= ‚àíœÉ
‚àö
t
and therefore St+t = St exp(‚àíœÉ
‚àö
t).
The reader will notice that these expressions are the same as those for the
CCR lattice of Chapter 5. That is: for an up jump St+t = Stu, for a down
jump St+t = Std, and u = 1/d = exp(œÉ
‚àö
t).
The probability of undergoing either an up or down jump occurring can be
found by matching the mean and variance of Œµt.
From the mean:
E[Œµt] = ŒΩ(pu ‚àípd) = Œºt
(6.4.1)
and from the variance:
Var[Œµt] = ŒΩ2(pu + pd) = œÉ 2t
(6.4.2)
So combining Eqs. (6.4.1) and (6.4.2) we obtain:
ŒΩŒºt + œÉ 2t = 2ŒΩ2pu
so
pu = 1
2
œÉ 2t
ŒΩ2
+ Œºt
ŒΩ

Substituting ŒΩ = œÉ
‚àö
t we obtain:
pu = 1
2

1 + Œº
‚àö
t
œÉ

(6.4.3)
and using the fact that pd = 1 ‚àípu gives:
pd = 1
2

1 ‚àíŒº
‚àö
t
œÉ

(6.4.4)
We shall now show that this is equivalent to the Cox‚ÄìRubinstein‚ÄìRoss binomial
model.
For the CRR model (Chapter 5, Eq. (5.3.19)) we have:
pu = exp(rt) ‚àíd
u ‚àíd
expanding exp(rt), u and d to order t we obtain:

Multiasset options
189
exp(rt) ‚àº1 + rt
u = exp

œÉ
‚àö
t

‚àº1 + œÉ
‚àö
t + œÉ 2
2 t
d = exp

œÉ
‚àö
t

‚àº1 ‚àíœÉ
‚àö
t + œÉ 2
2 t
so
exp(rt) ‚àíd ‚àºrt + œÉ
‚àö
t ‚àíœÉ 2t
2
and
u ‚àíd ‚àº2œÉ
‚àö
t
So
pu = exp(rt) ‚àíd
u ‚àíd
‚àºrt + œÉ ‚àíœÉ 2/2t
2œÉ
‚àö
t
which simpliÔ¨Åes to
pu = 1
2

1 + Œº
‚àö
t
œÉ

and therefore
pd = 1 ‚àípu = 1
2

1 ‚àíŒº
‚àö
t
œÉ

which are the expressions for pu and pd given in Eqs. (6.4.1) and (6.4.2), re-
spectively. So we have shown that, to Ô¨Årst order in t, both the size of the jump
and the probability of the jump are the same as the CRR binomial model.
The attractive feature of the BEGKR binomial lattice model is that it can easily
be generalized to describe a model consisting of k assets. Here we will merely
quote the results in Kamrad and Ritchken (1991). As before it is assumed that
the asset prices follow a multivariate lognormal distribution. Let Œºi = r ‚àíœÉ 2
i /2,
and œÉi be the instantaneous mean and variance, respectively (i = 1, 2, . . . , k)
and let œÅij be the correlation between asset i and j. The binomial model now
requires 2k possible jumps in the time interval t. Let m denote the state of
the process after time t with pm representing the probability of state m (m =
1, . . . , 2k). The probabilities of these jumps are now given by:
pm =

1 +
‚àö
t
k

i=1
xim
Œºi
œÉi

+
k‚àí1

i=1
k

j=i+1

xm
ij œÅij


,
m = 1, 2, . . . , 2k, k ‚©æ2,
where xim = 1 if asset i has an up jump in state m, and xim = ‚àí1 if asset i has
a down jump in state m. In addition xm
ij = 1 if asset i and asset j have jumps in
the same direction in state m, and xm
ij = ‚àí1 if asset i and asset j have jumps in
the opposite direction in state m.

190
Computational Finance Using C and C#
6.5
Two asset options
In this section we consider options based on the underlying prices of two as-
sets, S1 and S2. We give analytic formulae to price European exchange options
and also those based on the maximum or minimum of two assets. In addi-
tion we show how to construct binomial lattices for the valuation of two asset
American-style options.
6.5.1
European exchange options
A European exchange option gives the holder the right to exchange one asset
for another asset at maturity; see Margrabe (1978). Let the real-world processes
of assets SA and SB be:
dSA
t = SA
t ŒºA dt + SA
t œÉA dW P
A
dSB
t = SB
t ŒºB dt + SB
t œÉB dW P
B
where SA
t
denotes the value of asset A at time t and SB
t
denotes the value of
asset B at time t‚Äîthe other symbols have their obvious meanings.
We will now Ô¨Ånd the value, at current time t0, of an option that gives the
holder the right to exchange asset A for asset B at maturity T . The payoff at
maturity is HT = max(SB
T ‚àíSA
T , 0).
If we use the value of asset A as the numeraire then, from Eq. (4.2.1), the
value of the exchange option at time t0 is:
V (t0) = SA
t0 EQ
max(SB
T ‚àíSB
T , 0)
SA
T

which can be written as
V (t0) = SA
t0 EQ

max
SB
T
SA
T

‚àí1, 0

(6.5.1)
where Q is the probability measure under which the relative price (SB
t /SA
t ) is a
martingale.
The process followed by (SB
t /SA
t ) can be found by substituting X1 = SB
t and
X2 = SA
t into Eq. (2.6.7). This yields
d
SB
t
SA
t

=
SB
t
SA
t

ŒºB ‚àíŒºA + œÉ 2
A ‚àíœÉAœÉBœÅAB

dt
+
SB
t
SA
t

œÉB dW P
B ‚àíœÉA dW P
A

Let 
X = œÉB dW P
B ‚àíœÉA dW P
A , so E[
X] = œÉBE[dW P
B ] ‚àíœÉAE[dW P
A ] = 0, and
Var[
X] = œÉ 2
B dt + œÉ 2
A dt ‚àí2œÉBœÉAœÅAB dt where we have used (see Appendix C.3):
Var[a dW1 + b dW2] = a2 Var[dW1] + b2 Var[dW2] + 2ab Cov[dW1, dW2]
Var

dW P
B

= Var

dW P
A

= dt
and
Cov

dW P
B , dW P
A

= œÉBœÉAœÅAB dt

Multiasset options
191
which means that 
X ‚àºN(0, œÉ 2
B dt + œÉ 2
A dt ‚àí2œÉBœÉAœÅAB dt) and the variate (œÉ 2
B +
œÉ 2
A ‚àí2œÉBœÉAœÅAB) dW P is from the same distribution as 
X.
Therefore we can write:
d
SB
t
SA
t

=
SB
t
SA
t

¬ØŒº dt +
SB
t
SA
t

¬ØœÉ dW P
(6.5.2)
where
¬ØœÉ =

œÉ 2
B + œÉ 2
A ‚àí2œÉBœÉA
and
¬ØŒº = ŒºB ‚àíŒºA + œÉ 2
A ‚àíœÉBœÉAœÅAB
Following Section 4.4.3 we choose the probability measure Q so that the drift
term in Eq. (6.5.2) is zero. We have
dW P = dW Q ‚àí
 ¬ØŒº
¬ØœÉ

dt
Substituting this into Eq. (6.5.2) gives
d
SB
t
SA
t

=
SB
t
SA
t

¬ØœÉ dW Q
(6.5.3)
It can be seen that Eq. (6.5.3) is identical to Eq. (4.4.31) but with the mapping:
St ‚Üí
SB
t
SA
t

,
œÉ ‚Üí¬ØœÉ, r ‚Üí0
(6.5.4)
Now combining Eqs. (4.4.35) and (4.4.37) we have
exp(‚àírœÑ)EQ
max(ST ‚àíE, 0)

= SN1(d1) ‚àíE exp(‚àírœÑ)N1(d2)
where d1 and d2 have been deÔ¨Åned in Section 4.4.3.
Therefore,
EQ
max(ST ‚àí1, 0)

= exp(rœÑ)SN1(d1) ‚àíN1(d2)
Using the mapping deÔ¨Åned in Eq. (6.5.4), and also E = 1 in the Black‚ÄìScholes
formula, we have:
EQ
SB
T
SA
T

‚àí1, 0

=
SB
t0
SA
t0

N1(d1) ‚àíN1(d2)
and from Eq. (6.5.1):
V (t0) = SA
t0
SB
t0
SA
t0

N1(d1) ‚àíN1(d2)

This means that the value of the exchange option at time t0 is:
V (t0) = SB
t0 N1(d1) ‚àíSA
t0 N1(d2)

192
Computational Finance Using C and C#
where
d1 =
log(SA
t0 /SB
t0 ) + 1
2(T ‚àít0)¬ØœÉ 2
¬ØœÉ‚àöT ‚àít0
d2 =
log(SA
t0 /SB
t0 ) ‚àí1
2(T ‚àít0)¬ØœÉ 2
¬ØœÉ‚àöT ‚àít0
6.5.2
European options on the maximum or minimum
Here we present the results from Stulz (1982) and Johnson (1987) concerning
the value of European put and call options on the maximum and minimum of
two assets, see Code excerpts 6.2 and 6.3, and results in Tables 6.3 and 6.4.
void rainbow_bs_2d(double *opt_value, double S1, double S2, double X, double sigma1,
double sigma2, double rho, double opt_mat, double r, long is_max,_
long *iflag)
{
/* Input parameters:
=================
S1
- the current price of the underlying asset 1,
S2
- the current price of the underlying asset 2,
X
- the strike price,
sigma1
- the volatility of asset 1,
sigma2
- the volatility of asset 2,
rho
- the correlation coefficient between asset 1 and asset 2,
opt_mat
- the time to maturity,
r
- the interest rate,
is_max
- if is_max is 1 then the option is a call on the maximum of two assets,_
otherwise the option is a
call on the minimum of two assets.
Output parameters:
==================
opt_value
- the value of the option,
iflag
- an error indicator.
*/
double one=1.0,two=2.0,zero=0.0;
double eps,d1,d2_1,d2_2,temp,temp1,temp2,pi,np;
double rho_112, rho_212, d1_prime;
double sigma, term1, term2, term3;
long ifailx = 0;
if(X < EPS) {
/*
ERROR the strike price is too small */
*iflag = 2;
return;
}
if (sigma1 < EPS) {
/*
ERROR the volatility (sigma1) is too small */
*iflag = 3;
return;
}
if (sigma2 < EPS) {
/* ERROR the volatility (sigma2) is too small */
*flag = 3;
return;
}
if (opt_mat < EPS) {
/* ERROR the time to maturity (opt_mat) is too small */
*iflag = 3;
return;
}
sigma = sqrt((sigma1*sigma1 + sigma2*sigma2) - two*sigma1*sigma2*rho);
Code excerpt 6.2 Function to calculate the value of a European call on the maximum or
minimum of two assets using the analytic result of Johnson (1987) and Stulz (1982).

Multiasset options
193
if (is_max == 1) { /* then the maximum of two assets */
/* calculate term1 */
temp = log(S1/X);
d1 = temp+(r+(sigma1*sigma1/two))*opt_mat;
d1 = d1/(sigma1*sqrt(opt_mat));
temp = log(S1/S2);
d1_prime = temp+(sigma*sigma/two)*opt_mat;
d1_prime = d1_prime/(sigma*sqrt(opt_mat));
rho_112 = (sigma1 - rho*sigma2) / sigma;
term1 =
cum_norm2(d1,d1_prime,rho_112,&ifailx);
term1 =
term1*S1;
/* calculate term2 */
temp = log(S2/X);
d1 = temp+(r+(sigma2*sigma2/two))*opt_mat;
d1 = d1/(sigma2*sqrt(opt_mat));
temp = log(S2/S1);
d1_prime = temp+(sigma*sigma/two)*opt_mat;
d1_prime = d1_prime/(sigma*sqrt(opt_mat));
rho_212 = (sigma2 - rho*sigma1) / sigma;
term2 =
S2*cum_norm2(d1,d1_prime,rho_212,&ifailx);
/* calculate term3 */
temp = log(S1/X);
d2_1 = temp+(r-(sigma1*sigma1/two))*opt_mat;
d2_1 = d2_1/(sigma1*sqrt(opt_mat));
temp = log(S2/X);
d2_2 = temp+(r-(sigma2*sigma2/two))*opt_mat;
d2_2 = d2_2/(sigma2*sqrt(opt_mat));
term3 =
one-cum_norm2(-d2_1,-d2_2,rho,&ifailx);
*opt_value = term1+term2-X*exp(-r*opt_mat)*term3;
}
else {
/* the minimum of two assets */
/* calculate term1 */
temp = log(S1/X);
d1 = temp+(r+(sigma1*sigma1/two))*opt_mat;
d1 = d1/(sigma1*sqrt(opt_mat));
temp = log(S1/S2);
d1_prime = temp+(sigma*sigma/two)*opt_mat;
d1_prime = d1_prime/(sigma*sqrt(opt_mat));
rho_112 = (sigma1 - rho*sigma2) / sigma;
term1 =
cum_norm2(d1,-d1_prime,-rho_112,&ifailx);
term1 =
term1*S1;
/* calculate term2 */
temp = log(S2/X);
d1 = temp+(r+(sigma2*sigma2/two))*opt_mat;
d1 = d1/(sigma2*sqrt(opt_mat));
temp = log(S2/S1);
d1_prime = temp+(sigma*sigma/two)*opt_mat;
d1_prime = d1_prime/(sigma*sqrt(opt_mat));
rho_212 = (sigma2 - rho*sigma1) / sigma;
term2 =
S2*cum_norm2(d1,-d1_prime,-rho_212,&ifailx);
/* calculate term3 */
temp = log(S1/X);
d2_1 = temp+(r-(sigma1*sigma1/two))*opt_mat;
d2_1 = d2_1/(sigma1*sqrt(opt_mat));
temp = log(S2/X);
d2_2 = temp+(r-(sigma2*sigma2/two))*opt_mat;
d2_2 = d2_2/(sigma2*sqrt(opt_mat));
term3 =
cum_norm2(d2_1,d2_2,rho,&ifailx);
*opt_value = term1+term2-X*exp(-r*opt_mat)*term3;
}
return;
}
Code excerpt 6.2 (Continued).
Call options on the maximum and minimum of two assets
Let the value of a European call option on the minimum of two assets, S1 and
S2, with strike price E, maturity œÑ, and correlation coefÔ¨Åcient œÅ, be denoted by
cmin. The value of the corresponding call option on the maximum of these assets
will be represented by cmax.

194
Computational Finance Using C and C#
void opt_rainbow_bs_2d(double *opt_value, double S1, double S2, double X, double sigma1,
double sigma2, double rho, double opt_mat, double r, long is_max, long putcall,_
long *flag)
{
/* Input parameters:
=================
S1
- the current price of the underlying asset 1,
S2
- the current price of the underlying asset 2,
X
- the strike price,
sigma1
- the volatility of asset 1,
sigma2
- the volatility of asset 2,
rho
- the correlation coefficient between asset 1 and asset 2,
opt_mat
- the time to maturity,
r
- the interest rate,
is_max
- if is_max is 1 then the option is on the maximum of two assets,_
otherwise the option is on
the minimum of two assets,
putcall
- if putcall is 0 then the option is a call, otherwise the option is a put.
Output parameters:
==================
opt_value
- the value of the option,
iflag
- an error indicator.
*/
double temp1;
double temp2;
double fac;
double a_zero = 1.0e-6; /* approximate zero number to prevent overflow in rainbow_bs_2d */
if (putcall) { /* a put option */
fac = X*exp(-r*opt_mat);
rainbow_bs_2d(&temp1, S1, S2, a_zero, sigma1, sigma2, rho, opt_mat, r, is_max, flag);
rainbow_bs_2d(&temp2, S1, S2, X, sigma1, sigma2, rho, opt_mat, r, is_max, flag);
*opt_value = fac - temp1 + temp2;
} else { /* a call option */
rainbow_bs_2d(opt_value, S1, S2, X, sigma1, sigma2, rho, opt_mat, r, is_max, flag);
}
}
Code excerpt 6.3 Function to calculate the value of a European put or call on the max-
imum or minimum of two assets using the analytic result of Johnson (1987) and Stulz
(1982).
Table 6.3 The computed values and absolute errors for European put and call options
on the maximum of two assets
Time
Call
Put
Analytic
Lattice
Error
Analytic
Lattice
Error
0.1
6.45320
6.45245
7.4972 √ó 10‚àí4
0.01524
0.01451
7.3344 √ó 10‚àí4
0.2
6.96192
6.95953
2.3845 √ó 10‚àí3
0.08252
0.08001
2.5106 √ó 10‚àí3
0.3
7.49587
7.49376
2.1084 √ó 10‚àí3
0.15787
0.15580
2.0675 √ó 10‚àí3
0.4
8.03710
8.04022
3.1260 √ó 10‚àí3
0.22362
0.22680
3.1768 √ó 10‚àí3
0.5
8.57808
8.57916
1.0757 √ó 10‚àí3
0.27762
0.27683
7.8867 √ó 10‚àí4
0.6
9.11529
9.10809
7.2006 √ó 10‚àí3
0.32115
0.31872
2.4328 √ó 10‚àí3
0.7
9.64700
9.64838
1.3826 √ó 10‚àí3
0.35598
0.35714
1.1548 √ó 10‚àí3
0.8
10.17238
10.17663
4.2571 √ó10‚àí3
0.38372
0.38711
3.3891 √ó 10‚àí3
The results were obtained using a binomial lattice and the analytic formula (Johnson
(1987) and Stulz (1982)). The time to maturity of the option is varied from 0.1 years to
0.8 years. The parameters are: E = 44.0, S1 = 40.0, S2 = 50.0, r = 0.1, œÉ1 = 0.2, œÉ2 =
0.2, q1 = q2 = 0.0, œÅ = 0.5, n_steps = 50.

Multiasset options
195
Table 6.4 The computed values and absolute errors for European put and call options
on the minimum of two assets
Time
Call
Put
Analytic
Lattice
Error
Analytic
Lattice
Error
0.1
0.10810
0.10753
5.7048 √ó 10‚àí4
3.67044
3.66993
5.0955 √ó 10‚àí4
0.2
0.40862
0.40781
8.1047 √ó 10‚àí4
3.54551
3.54514
3.6961 √ó 10‚àí4
0.3
0.74162
0.73418
7.4339 √ó 10‚àí3
3.47882
3.47206
6.7642 √ó 10‚àí3
0.4
1.06989
1.07299
3.1076 √ó 10‚àí3
3.43283
3.43715
4.3214 √ó 10‚àí3
0.5
1.38675
1.38909
2.3414 √ó 10‚àí3
3.39540
3.40159
6.1826 √ó 10‚àí3
0.6
1.69203
1.69025
1.7757 √ó 10‚àí3
3.36145
3.35775
3.6964 √ó 10‚àí3
0.7
1.98691
1.96939
1.7520 √ó 10‚àí2
3.32859
3.31517
1.3417 √ó 10‚àí2
0.8
2.27276
2.26274
1.0018 √ó 10‚àí2
3.29566
3.29157
4.0885 √ó 10‚àí3
The results were obtained using a binomial lattice and the analytic formula (Johnson
(1987) and Stulz (1982)). The time to maturity of the option is varied from 0.1 years to
0.8 years. The parameters are: E = 44.0, S1 = 40.0, S2 = 50.0, r = 0.1, œÉ1 = 0.2, œÉ2 =
0.2, q1 = q2 = 0.0, œÅ = 0.5, n_steps = 50.
Then, following Stulz (1982) and Johnson (1987), we have:
cmax = S1N2

d1

S1, E, œÉ 2
1

, d‚Ä≤
1

S1, S2, œÉ 2
‚àó

, œÅ1

+ S2N2

d1

S2, E, œÉ 2
2

, d‚Ä≤
1

S2, S1, œÉ 2
‚àó

, œÅ2

‚àíE exp(‚àírœÑ)

1 ‚àíN2

‚àíd2

S1, E, œÉ 2
1

, ‚àíd2

S2, E, œÉ 2
2

, œÅ

(6.5.5)
and
cmin = S1N2

d1

S1, E, œÉ 2
1

, ‚àíd‚Ä≤
1

S1, S2, œÉ 2
‚àó

, ‚àíœÅ1

+ S2N2

d1

S2, E, œÉ 2
2

, ‚àíd‚Ä≤
1

S2, S1, œÉ 2
‚àó

, ‚àíœÅ2

‚àíE exp(‚àírœÑ)N2

d2

S1, E, œÉ 2
1

, d2

S2, E, œÉ 2
2

, œÅ

(6.5.6)
where N2(a, b, œÅ) is the bivariate cumulative normal. It gives the cumulative
probability, in a standardized bivariate normal distribution, that the variables
x1 and x2 satisfy x1 ‚©Ωa and x2 ‚©Ωb when the correlation coefÔ¨Åcient between
x1 and x2 is œÅ‚Äîthe value is computed using the routine cum_norm2. The other
symbols are deÔ¨Åned as follows:
œÉ 2
‚àó= œÉ 2
1 ‚àí2œÅœÉ1œÉ2 + œÉ 2
2
d1

Si, E, œÉ 2
i

= log(Si/E) + (r + œÉ 2
i /2)œÑ
œÉi
‚àöœÑ
,
i = 1, 2,
d2

Si, E, œÉ 2
i

= log(Si/E) + (r ‚àíœÉ 2
i /2)œÑ
œÉi
‚àöœÑ
,
i = 1, 2,
d‚Ä≤
1

Si, Sj, œÉ 2
‚àó

= log(Si/Sj) + (œÉ 2
‚àó/2)œÑ
œÉ‚àó
‚àöœÑ
for i = 1, j = 2, or i = 2, j = 1

196
Computational Finance Using C and C#
and
œÅ1 = œÉ1 ‚àíœÅœÉ2
œÉ‚àó
,
œÅ2 = œÉ2 ‚àíœÅœÉ1
œÉ‚àó
It can also be shown that:
cmax(S1, S2, E, œÑ) + cmin(S1, S2, E, œÑ) = c(S1, E, œÑ) + c(S2, E, œÑ)
(6.5.7)
where c(S, E, œÑ) is the value of a vanilla European call.
We will now derive an expression for the value of the corresponding European
put options.
Put options on the minimum of two assets
It will now be shown that the price of a European put option on the minimum
of two assets, pmin(S1, S2, E, œÑ) is:
pmin(S1, S2, E, œÑ) = E exp(‚àírœÑ) ‚àícmin(S1, S2, 0, œÑ) + cmin(S1, S2, E, œÑ)
(6.5.8)
where the meaning of the symbols has been previously deÔ¨Åned.
This result can be proved by considering the following two investments:
Portfolio A: Purchase one put option on the minimum of S1 and S2 with
exercise price E.
Portfolio B: Purchase one discount bond which pays E at maturity. Write
(that is, sell) one option on the minimum of S1 and S2 with an exercise price of
zero. Purchase one option on the minimum of S1 and S2 with exercise price E.
We now consider the values of these portfolios at option maturity, time œÑ.
If min(S1, S2) ‚©æE
Portfolio A: pays zero
Portfolio B: Pays E ‚àímin(S1, S2) + min(S1, S2) ‚àíE = 0
If min(S ‚àí1, S2) = S1 < E
Portfolio A: Pays E ‚àíS1
Portfolio B: Pays E ‚àíS1 + 0 = E ‚àíS1
If min(S1, S2) = S2 < E
Portfolio A: Pays E ‚àíS2
Portfolio B: Pays E ‚àíS2 + 0 = E ‚àíS2
We have therefore shown that, under all possible circumstances, Portfolio A
has the same value as Portfolio B. This means that Eq. (6.5.8) is true.

Multiasset options
197
Put options on the maximum of two assets
It will now be shown that the price of a European put option on the maximum
of two assets, pmax(S1, S2, E, œÑ) is:
pmax(S1, S2, E, œÑ) = E exp(‚àírœÑ) ‚àícmax(S1, S2, 0, œÑ) + cmax(S1, S2, E, œÑ)
(6.5.9)
where, as before, the meaning of the symbols has been previously deÔ¨Åned.
This result can be proved by considering the following two investments:
Portfolio A: Purchase one put option on the maximum of S1 and S2 with
exercise price E.
Portfolio B: Purchase one discount bond which pays E at maturity. Write
(that is, sell) one option on the maximum of S1 and S2 with an exercise price
of zero. Purchase one option on the maximum of S1 and S2 with exercise
price E.
As before we now consider the values of these portfolios at option maturity,
time œÑ.
If max(S1, S2) ‚©æE
Portfolio A: Pays zero
Portfolio B: Pays E ‚àímax(S1, S2) + max(S1, S2) ‚àíE = 0
If max(S1, S2) = S1 < E
Portfolio A: Pays E ‚àíS1
Portfolio B: Pays E ‚àíS1 + 0 = E ‚àíS1
If max(S1, S2) = S2 < E
Portfolio A: Pays E ‚àíS2
Portfolio B: Pays E ‚àíS2 + 0 = E ‚àíS2
It therefore follows that, under all possible circumstances, Portfolio A has the
same value as Portfolio B, and this means that Eq. (6.5.9) is true.
6.5.3
American options
We assume that the prices of asset 1 and asset 2 follow a lognormal process with
drift terms of Œº1 = r ‚àíœÉ 2
1 /2 and Œº2 = r ‚àíœÉ 2
2 /2, respectively. As before, r is the
riskless interest rate and œÉ1 and œÉ2 are the instantaneous volatilities of asset 1
and asset 2.
If we let S1,t and S2.t denote the respective prices of asset 1 and asset 2 at
time t, then we can write:
log(S1,t+t) = log(S1,t) + Œµ1,t
(6.5.10)

198
Computational Finance Using C and C#
and
log(S2,t+t) = log(S2,t) + Œµ2,t
(6.5.11)
where Œµ1,t is a random normal variable with mean Œº1t and variance œÉ 2
1 t, and
Œµ2,t is a random normal variable with mean Œº2t and variance œÉ 2
2 t.
In the binomial lattice model, over the time interval t, the variate log(S1,t)
is only allowed to jump up or down by an amount ŒΩ1 = œÉ1
‚àö
t, and simi-
larly the variate log(S2,t) is only permitted to jump up and down by the amount
ŒΩ2 = œÉ2
‚àö
t. We will denote the probability of both log(S1,t) and log(S2,t) hav-
ing an up jump over t by puu, and the probability of log(S1,t) having an up
jump and log(S2,t) having a down jump by pud, etc.
The mean values in Eqs. (5.15) and (5.16) then give
E[Œµ1,t] = ŒΩ1(puu + pud ‚àípdd ‚àípdu) = Œº1t
(6.5.12)
E[Œµ2,t] = ŒΩ2(puu + pud ‚àípdd ‚àípdu) = Œº2t
(6.5.13)
and the variance/covariance terms yields
Var[Œµ1,t] = ŒΩ2
1(puu + pud + pdd + pdu) = œÉ 2
1 t
(6.5.14)
Var[Œµ2,t] = ŒΩ2
2(puu + pud + pdd + pdu) = œÉ 2
2 t
(6.5.15)
E[Œµ1,tŒµ2,t] = ŒΩ1ŒΩ2(puu ‚àípud + pdd ‚àípdu) = œÅœÉ1œÉ2t
(6.5.16)
where œÅ is the correlation coefÔ¨Åcient between Œµ1,t and Œµ2,t.
We therefore obtain:
puu + pud ‚àípdd + pdu = Œº1
‚àö
t
œÉ1
puu ‚àípud ‚àípdd + pdu = Œº2
‚àö
t
œÉ2
puu + pud + pdd + pdu = 1
puu ‚àípud + pdd ‚àípdu = œÅ
These lead to the following jump probabilities:
puu = 1
4

1 +
‚àö
t
Œº1
œÉ1
+ Œº2
œÉ2

+ œÅ

pud = 1
4

1 +
‚àö
t
Œº1
œÉ1
‚àíŒº2
œÉ2

‚àíœÅ

pdd = 1
4

1 +
‚àö
t

‚àíŒº1
œÉ1
‚àíŒº2
œÉ2

+ œÅ

pdu = 1
4

1 +
‚àö
t

‚àíŒº1
œÉ1
+ Œº2
œÉ2

‚àíœÅ

In Code excerpt 6.4, we provide the computer code for a standard binomial
lattice which prices options on the maximum and minimum of two assets.

Multiasset options
199
The parameter M is the number of time steps used, and the lattice is con-
structed under the assumption that M is even.
void standard_2D_binomial(double *value, double S1, double S2, double X,
double sigma1, double sigma2, double rho, double T,
double r, double q1, double q2, long put,
long M, long opt_type, long is_american, long *iflag)
{
/* Input parameters:
=================
S1
- the current price of the underlying asset 1
S2
- the current price of the underlying asset 2
X
- the strike price
sigma1
- the volatility of asset 1
sigma2
- the volatility of asset 2
rho
- the correlation coefficient between asset 1 and asset 2
T
- the time to maturity
r
- the interest rate
q1
- the continuous dividend yield for asset 1
q2
- the continuous dividend yield for asset 2
put
- if put is 0 then a call option, otherwise a put option
M
- the number of time steps, the zeroth time step is the root node_
of the lattice
opt_type
- if opt_type is 0 then an option on the maximum of two asset
otherwise an option on the minimum of two assets
is_american
- if is_american is 0 then a European option, otherwise_
an American option
Output parameters:
==================
value
- the value of the option,
iflag
- an error indicator.
*/
double discount,t1,dt,d1,d2,u1,u2;
long i,j,m1,n,iflagx,jj,ind;
double zero=0.0,hold;
double temp,ds1,ds2,dv1,dv2,h,tmp;
double *s1, *s2, *v;
double p[4];
long P1,P2,tdv;
double sqrt_dt, t, mu1, mu2, jp1, jp2;
double one = 1.0, half = 0.5, quarter = 0.25;
long v1;
if (!((M+1)/2) == (M/2)) printf ("ERROR THE NUMBER OF TIME STEPS IS NOT EVEN \n");
tdv = M + 1;
#define V(I,J) v[(I) * tdv + (J)]
#define UU
0
#define UD
1
#define DD
2
#define DU
3
dt = T/(double)M;
sqrt_dt = sqrt(dt);
jp1 = sigma1*sqrt_dt;
jp2 = sigma2*sqrt_dt;
mu1 = r - q1 - sigma1*sigma1*half;
mu2 = r - q2 - sigma2*sigma2*half;
u1 = exp(jp1); /* assign the jump sizes */
u2 = exp(jp2);
d1 = exp(-jp1);
d2 = exp(-jp2);
p[UU] = quarter*(one + sqrt_dt * ((mu1/sigma1) + (mu2/sigma2)) +
rho); /* set up the jump_
probabilities */
p[UD] = quarter*(one + sqrt_dt * ((mu1/sigma1) - (mu2/sigma2)) - rho);
p[DD] = quarter*(one + sqrt_dt * (-(mu1/sigma1) - (mu2/sigma2)) + rho);
p[DU] = quarter*(one + sqrt_dt * (-(mu1/sigma1) + (mu2/sigma2)) - rho);
for (i = 0; i < 4; ++i) {
if ((p[i] < zero) || (p[i] > 1.0)) printf ("ERROR p out of range\n");
}
discount = exp(-r*dt);
Code excerpt 6.4 Function to calculate the value of a European put or call on the maxi-
mum or minimum of two assets using a standard binomial lattice.

200
Computational Finance Using C and C#
for (i = 0; i < 4; ++i) {
p[i] = p[i]*discount;
}
/* Allocate the arrays v[(M+1)*(M+1)], s1[2*M+1] and s2[2*M+1] */
.
.
.
s1[M] = S1; /* assign the 2*M+1 asset values for s1 */
for (i = 1; i <= M; ++i) {
s1[M+i] = u1*s1[M+i-1];
s1[M-i] = d1*s1[M-i+1];
}
s2[M] = S2; /* assign the 2*M+1 asset values for s2 */
for (i = 1; i <= M; ++i) {
s2[M+i] = u2*s2[M+i-1];
s2[M-i] = d2*s2[M-i+1];
}
P1 = 0;
for (i = 0; i <= M; ++i) { /* Calculate the option values at maturity
*/
P2 = 0;
for (j = 0; j <= M; ++j) {
if (opt_type == 0) { /* Maximum of two assets */
if (put) {
V(i,j)
= MAX(X - MAX(s1[P1],s2[P2]),zero);
}
else {
V(i,j)
= MAX(MAX(s1[P1],s2[P2])-X,zero);
}
}
else {
if (put) { /* Minimum of two assets */
V(i,j)
= MAX(X - MIN(s1[P1],s2[P2]),zero);
}
else {
V(i,j)
= MAX(MIN(s1[P1],s2[P2])-X,zero);
}
}
P2 = P2 + 2;
}
P1 = P1 + 2;
}
for (m1 = M-1; m1 >= 0; --m1) { /* work backwards through the lattice_
to calculate option value */
P1 = M-m1;
for (i = 0; i <= m1; ++i) {
P2 = M-m1;
for (j = 0; j <= m1; ++j) {
hold = p[UD]*V(i+1,j) + p[UU]*V(i+1,j+1) + p[DU]*V(i,j+1) + p[DD]*V(i,j);
if (is_american) {
/* An American option */
if (opt_type == 0) {
/* Maximum of two assets */
if (put)
V(i,j) = MAX(hold,X-MAX(s1[P1],s2[P2]));
else
V(i,j) = MAX(hold,MAX(s1[P1],s2[P2])-X);
}
else {
/* Minimum of two assets */
if (put)
V(i,j) = MAX(hold,X-MIN(s1[P1],s2[P2]));
else
V(i,j) = MAX(hold,MIN(s1[P1],s2[P2])-X);
}
}
else {
V(i,j) = hold;
}
P2 = P2 + 2;
}
P1 = P1 + 2;
}
}
*value = V(0,0);
}
Code excerpt 6.4 (Continued).

Multiasset options
201
6.6
Three asset options
For three asset options (see Code excerpt 6.5 and results in Tables 6.5‚Äì6.8), we
have the following jump probabilities:
puuu = 1
8

1 +
‚àö
t
Œº1
œÉ1
+ Œº2
œÉ2
+ Œº3
œÉ3

+ œÅ12 + œÅ13 + œÅ23

puud = 1
8

1 +
‚àö
t
Œº1
œÉ1
+ Œº2
œÉ2
‚àíŒº3
œÉ3

+ œÅ12 ‚àíœÅ13 ‚àíœÅ23

pudu = 1
8

1 +
‚àö
t
Œº1
œÉ1
‚àíŒº2
œÉ2
+ Œº3
œÉ3

‚àíœÅ12 + œÅ13 ‚àíœÅ23

pudd = 1
8

1 +
‚àö
t
Œº1
œÉ1
‚àíŒº2
œÉ2
‚àíŒº3
œÉ3

‚àíœÅ12 ‚àíœÅ13 + œÅ23

pduu = 1
8

1 +
‚àö
t

‚àíŒº1
œÉ1
+ Œº2
œÉ2
+ Œº3
œÉ3

‚àíœÅ12 ‚àíœÅ13 + œÅ23

pdud = 1
8

1 +
‚àö
t

‚àíŒº1
œÉ1
+ Œº2
œÉ2
+ Œº3
œÉ3

‚àíœÅ12 + œÅ13 ‚àíœÅ23

pddu = 1
8

1 +
‚àö
t

‚àíŒº1
œÉ1
‚àíŒº2
œÉ2
+ Œº3
œÉ3

+ œÅ12 ‚àíœÅ13 ‚àíœÅ23

pddd = 1
8

1 +
‚àö
t

‚àíŒº1
œÉ1
‚àíŒº2
œÉ2
‚àíŒº3
œÉ3

+ œÅ12 + œÅ13 + œÅ23

void standard_3D_binomial(double *value, double S1, double S2, double S3, double X,
double sigma1, double sigma2, double sigma3, double rho_12, double rho_13, double rho_23,
double T, double r, long put, long M, long opt_type, long is_american, long *iflag)
{
/* Input parameters:
=================
S1
- the current price of the underlying asset 1
S2
- the current price of the underlying asset 2
S3
- the current price of the underlying asset 3
X
- the strike price
sigma1
- the volatility of asset 1
sigma2
- the volatility of asset 2
sigma3
- the volatility of asset 3
rho_12
- the correlation coefficient between asset 1 and asset 2
rho_13
- the correlation coefficient between asset 1 and asset 3
rho_23
- the correlation coefficient between asset 2 and asset 3
T
- the time to maturity
r
- the interest rate
put
- if put is 0 then a call option, otherwise a put option
M
- the number of time steps, the zeroth time step is the root node_
of the lattice
opt_type
- if opt_type is 0 then an option on the maximum of two asset
otherwise an option on the minimum of two assets
is_american
- if is_american is 0 then a European option, otherwise an American option.
Output parameters:
==================
value
- the value of the option,
iflag
- an error indicator.
Code excerpt 6.5 Standard 3-dimensional binomial lattice.

202
Computational Finance Using C and C#
*/
double discount,t1,dt,d1,d2,d3,u1,u2,u3;
long i,j,k,m1,n,iflagx,jj,ind;
double zero=0.0,hold;
double temp,ds1,ds2,dv1,dv2,h,tmp,tmp1,tmp2;
double *s1, *s2, *s3, *v;
double p[9];
long P1,P2,P3,tdv, tdv2;
double sqrt_dt, t, mu1, mu2, mu3, jp1, jp2, jp3;
double one = 1.0, half = 0.5, eighth = 0.125;
long v1;
if (!((M+1)/2) == (M/2)) printf ("ERROR THE NUMBER OF TIME STEPS IS NOT EVEN \n");
tdv = M + 1;
tdv2 = tdv*tdv;
#define V(I,J, K) v[(I) * tdv2 + (J)*tdv + (K)]
#define UUU
0
#define UUD
1
#define UDU
2
#define UDD
3
#define DUU
4
#define DUD
5
#define DDU
6
#define DDD
7
dt = T/(double)M;
sqrt_dt = sqrt(dt);
jp1 = sigma1*sqrt_dt;
jp2 = sigma2*sqrt_dt;
jp3 = sigma3*sqrt_dt;
mu1 = r - sigma1*sigma1*half;
mu2 = r - sigma2*sigma2*half;
mu3 = r - sigma3*sigma3*half;
u1 = exp(jp1); /* assign the jump sizes */
u2 = exp(jp2);
u3 = exp(jp3);
d1 = exp(-jp1);
d2 = exp(-jp2);
d3 = exp(-jp3);
/* set up the jump probabilities
*/
p[UUU] = eighth*(one + sqrt_dt * ((mu1/sigma1) + (mu2/sigma2)_
+ (mu3/sigma3)) + rho_12 + rho_13 + rho_23);
p[UUD] = eighth*(one + sqrt_dt * ((mu1/sigma1) + (mu2/sigma2)_
- (mu3/sigma3)) + rho_12 - rho_13 - rho_23);
p[UDU] = eighth*(one + sqrt_dt * ((mu1/sigma1) - (mu2/sigma2)_
+ (mu3/sigma3)) - rho_12 + rho_13 - rho_23);
p[UDD] = eighth*(one + sqrt_dt * ((mu1/sigma1) - (mu2/sigma2)_
- (mu3/sigma3)) - rho_12 - rho_13 + rho_23);
p[DUU] = eighth*(one + sqrt_dt * (-(mu1/sigma1) + (mu2/sigma2)_
+ (mu3/sigma3)) - rho_12 - rho_13 + rho_23);
p[DUD] = eighth*(one + sqrt_dt * (-(mu1/sigma1) + (mu2/sigma2)_
- (mu3/sigma3)) - rho_12 + rho_13 - rho_23);
p[DDU] = eighth*(one + sqrt_dt * (-(mu1/sigma1) - (mu2/sigma2)_
+ (mu3/sigma3)) + rho_12 - rho_13 - rho_23);
p[DDD] = eighth*(one + sqrt_dt * (-(mu1/sigma1) - (mu2/sigma2)_
- (mu3/sigma3)) + rho_12 + rho_13 + rho_23);
for (i = 0; i < 8; ++i) {
if ((p[i] < zero) || (p[i] > 1.0)) printf ("ERROR p[%ld] = %12.4f out_
of range\n",i, p[i]);
}
discount = exp(-r*dt);
for (i = 0; i < 8; ++i) {
p[i] = p[i]*discount;
}
/* Allocate the arrays v[(M+1)*(M+1)*(M+1)], s1[2*M+1], s2[2*M+1], and s3[2*M+1] */
.
.
.
s1[M] = S1;
for (i = 1; i <= M; ++i) { /* assign the 2*M+1 asset values for s1 */
s1[M+i] = u1*s1[M+i-1];
s1[M-i] = d1*s1[M-i+1];
}
s2[M] = S2;
Code excerpt 6.5 (Continued).

Multiasset options
203
for (i = 1; i <= M; ++i) { /* assign the 2*M+1 asset values for s2 */
s2[M+i] = u2*s2[M+i-1];
s2[M-i] = d2*s2[M-i+1];
}
s3[M] = S3;
for (i = 1; i <= M; ++i) { /* assign the 2*M+1 asset values for s2 */
s3[M+i] = u3*s3[M+i-1];
s3[M-i] = d3*s3[M-i+1];
}
/* Calculate the option values at maturity
*/
P1 = 0;
for (i = 0; i <= M; ++i) {
P2 = 0;
for (j = 0; j <= M; ++j) {
P3 = 0;
for (k = 0; k <= M; ++k) {
if (put) { /* put */
if (opt_type == 0) { /* Maximum of 3 assets */
tmp = MAX(s1[P1],s2[P2]);
V(i,j,k)
= MAX(X - MAX(tmp,s3[P3]),zero);
}
else if (opt_type == 1) { /* Minimum of 3 assets */
tmp = MIN(s1[P1],s2[P2]);
V(i,j,k)
= MAX(X - MIN(tmp,s3[P3]),zero);
}
}
else { /* call */
** Insert call option code using the supplied put option code as a template **
}
P3 = P3 + 2;
}
P2 = P2 + 2;
}
P1 = P1 + 2;
}
for (m1 = M-1; m1 >= 0; --m1) {
/* work backwards through the lattice to calculate_
the option value */
P1 = M-m1;
for (i = 0; i <= m1; ++i) {
P2 = M-m1;
for (j = 0; j <= m1; ++j) {
P3 = M-m1;
for (k = 0; k <= m1; ++k) {
hold = p[UUU]*V(i+1,j+1,k+1) + p[UUD]*V(i+1,j+1,k) + p[UDU]*V(i+1,j,k+1)_
+ p[UDD]*V(i+1,j,k) + p[DUU]*V(i,j+1,k+1) + p[DUD]*V(i,j+1,k)_
+ p[DDU]*V(i,j,k+1) + p[DDD]*V(i,j,k);
if (is_american) {
if (put) {
if (opt_type == 0) { /* Maximum of 3 assets */
tmp = MAX(s1[P1],s2[P2]);
if (opt_type == 0) { /* Maximum of 3 assets */
tmp = MAX(s1[P1],s2[P2]);
tmp1
= MAX(tmp,s3[P3]);
tmp2 = MAX(X-tmp1,hold);
V(i,j,k) = MAX(tmp2,zero);
}
else if (opt_type == 1) { /* Minimum of 3 assets */
tmp = MIN(s1[P1],s2[P2]);
tmp1 = MIN(tmp,s3[P3]);
tmp2 = MAX(X-tmp1,hold);
V(i,j,k)
= MAX(tmp2,zero);
}
}
else { /* call option */
** Insert call option code using the supplied put option_
code as a template **
}
}
Code excerpt 6.5 (Continued).

204
Computational Finance Using C and C#
else { /* European option */
V(i,j,k) = hold;
}
P3 = P3 + 2;
}
P2 = P2 + 2;
}
P1 = P1 + 2;
}
}
*value = V(0,0,0);
}
Code excerpt 6.5 (Continued).
Table 6.5 The computed values and absolute errors for European options on the
maximum of three assets
N steps
Put
Call
Computed value
Error
Computed value
Error
10
0.9112
2.485 √ó10‚àí2
21.8601
8.119 √ó10‚àí1
20
0.9192
1.678 √ó10‚àí2
22.2807
3.913 √ó10‚àí1
30
0.9232
1.276 √ó10‚àí2
22.4137
2.583 √ó10‚àí1
40
0.9254
1.056 √ó10‚àí2
22.4792
1.928 √ó10‚àí1
50
0.9268
9.180 √ó10‚àí3
22.5182
1.538 √ó10‚àí1
60
0.9278
8.236 √ó10‚àí3
22.5441
1.279 √ó10‚àí1
A binomial lattice was used and we show how the accuracy of the results depends on
the number of time steps. The parameters are: E = 100.0, S1 = S2 = S3 = 100.0, r =
0.1, œÑ = 1.0, œÉ1 = œÉ2 = œÉ3 = 0.2, œÅ12 = œÅ13 = œÅ23 = 0.5, q1 = q2 = q3 = 0.0. The
accurate values are 0.936 for a put and 22.672 for a call; see Table 2, Boyle, Evnine, and
Gibbs (1989).
Table 6.6 The computed values and absolute errors for European options on the
minimum of three assets
N steps
Put
Call
Computed value
Error
Computed value
Error
10
7.0759
3.271 √ó10‚àí1
5.2072
4.176 √ó10‚àí2
20
7.2402
1.628 √ó10‚àí1
5.2263
2.269 √ó10‚àí2
30
7.2953
1.077 √ó10‚àí1
5.2334
1.560 √ó10‚àí2
40
7.3229
8.015 √ó10‚àí2
5.2371
1.192 √ó10‚àí2
50
7.3394
6.357 √ó10‚àí2
5.2393
9.665 √ó10‚àí2
60
7.3505
5.251 √ó10‚àí2
5.2409
8.143 √ó10‚àí3
A binomial lattice was used and we show how the accuracy of the results depends on
the number of time steps. The parameters are: E = 100.0, S1 = S2 = S3 = 100.0, r =
0.1, œÑ = 1.0, œÉ1 = œÉ2 = œÉ3 = 0.2, œÅ12 = œÅ13 = œÅ23 = 0.5, q1 = q2 = q3 = 0.0. The
accurate values are 7.403 for a put and 5.249 for a call; see Table 2, Boyle, Evnine, and
Gibbs (1989).

Multiasset options
205
Table 6.7 The computed values and absolute errors for European options on the
maximum of three assets
N steps
Put
Call
Computed value
Error
Computed value
Error
10
0.0122
4.041 √ó10‚àí2
27.3180
5.091 √ó10‚àí1
20
0.0295
2.314 √ó10‚àí2
27.5743
2.528 √ó10‚àí1
30
0.0366
1.600 √ó10‚àí2
27.6589
1.682 √ó10‚àí1
40
0.0404
1.221 √ó10‚àí2
27.7010
1.261 √ó10‚àí1
50
0.0427
9.868 √ó10‚àí3
27.7263
1.008 √ó10‚àí1
60
0.0443
8.280 √ó10‚àí3
27.7431
8.396 √ó10‚àí2
A binomial lattice was used and we show how the accuracy depends on the number of
time steps. The parameters are: E = 100.0, S1 = S2 = S3 = 100.0, r = 0.1, œÑ = 1.0, œÉ1 =
œÉ2 = œÉ3 = 0.2, œÅ12 = ‚àí0.5, œÅ13 = ‚àí0.5, œÅ23 = 0.5, q1 = q2 = q3 = 0.0. The accurate
values are 0.0526 for a put and 27.8271 for a call, and were computed using Monte Carlo
simulation with 107 paths.
Table 6.8 The computed values and absolute errors for European options on the
minimum of three assets
N steps
Put
Call
Computed value
Error
Computed value
Error
10
8.9646
3.130 √ó10‚àí1
1.4047
1.800 √ó10‚àí1
20
9.1231
1.545 √ó10‚àí1
1.4963
8.836 √ó10‚àí2
30
9.1749
1.027 √ó10‚àí1
1.5261
5.857 √ó10‚àí2
40
9.2007
7.694 √ó10‚àí2
1.5409
4.381 √ó10‚àí2
50
9.2161
6.151 √ó10‚àí2
1.5497
3.499 √ó10‚àí2
60
9.2264
5.123 √ó10‚àí2
1.5556
2.913 √ó10‚àí2
A binomial lattice was used and we show how the accuracy depends on the number of
time steps. The parameters are: E = 100.0, S1 = S2 = S3 = 100.0, r = 0.1, œÑ = 1.0, œÉ1 =
œÉ2 = œÉ3 = 0.2, œÅ12 = ‚àí0.5, œÅ13 = ‚àí0.5, œÅ23 = 0.5, q1 = q2 = q3 = 0.0. The accurate
values are 9.2776 for a put and 1.5847 for a call, and were computed using Monte Carlo
simulation with 107 paths.
6.7
Four asset options
The results for four assets are presented in Tables 6.9 and 6.10. We have the
following jump probabilities:
puuuu = 1
16

1 +
‚àö
t
Œº1
œÉ1
+ Œº2
œÉ2
+ Œº3
œÉ3
+ Œº4
œÉ4

+ œÅ12 + œÅ13 + œÅ14 + œÅ23 + œÅ24 + œÅ34


206
Computational Finance Using C and C#
puuud = 1
16

1 +
‚àö
t
Œº1
œÉ1
+ Œº2
œÉ2
+ Œº3
œÉ3
‚àíŒº4
œÉ4

+ œÅ12 + œÅ13 ‚àíœÅ14 + œÅ23 ‚àíœÅ24 + œÅ34

puudu = 1
16

1 +
‚àö
t
Œº1
œÉ1
+ Œº2
œÉ2
‚àíŒº3
œÉ3
+ Œº4
œÉ4

+ œÅ12 ‚àíœÅ13 + œÅ14 ‚àíœÅ23 + œÅ24 ‚àíœÅ34

puudd = 1
16

1 +
‚àö
t
Œº1
œÉ1
+ Œº2
œÉ2
‚àíŒº3
œÉ3
‚àíŒº4
œÉ4

+ œÅ12 ‚àíœÅ13 ‚àíœÅ14 ‚àíœÅ23 ‚àíœÅ24 + œÅ34

puduu = 1
16

1 +
‚àö
t
Œº1
œÉ1
‚àíŒº2
œÉ2
+ Œº3
œÉ3
+ Œº4
œÉ4

‚àíœÅ12 + œÅ13 + œÅ14 ‚àíœÅ23 ‚àíœÅ24 + œÅ34

pudud = 1
16

1 +
‚àö
t
Œº1
œÉ1
‚àíŒº2
œÉ2
+ Œº3
œÉ3
‚àíŒº4
œÉ4

‚àíœÅ12 + œÅ13 ‚àíœÅ14 ‚àíœÅ23 + œÅ24 ‚àíœÅ34

puddu = 1
16

1 +
‚àö
t
Œº1
œÉ1
‚àíŒº2
œÉ2
‚àíŒº3
œÉ3
+ Œº4
œÉ4

‚àíœÅ12 ‚àíœÅ13 + œÅ14 + œÅ23 ‚àíœÅ24 ‚àíœÅ34

puddd = 1
16

1 +
‚àö
t
Œº1
œÉ1
‚àíŒº2
œÉ2
‚àíŒº3
œÉ3
‚àíŒº4
œÉ4

‚àíœÅ12 ‚àíœÅ13 ‚àíœÅ14 + œÅ23 + œÅ24 + œÅ34

pduuu = 1
16

1 +
‚àö
t

‚àíŒº1
œÉ1
+ Œº2
œÉ2
+ Œº3
œÉ3
+ Œº4
œÉ4

‚àíœÅ12 ‚àíœÅ13 ‚àíœÅ14 + œÅ23 + œÅ24 + œÅ34

pduud = 1
16

1 +
‚àö
t

‚àíŒº1
œÉ1
+ Œº2
œÉ2
+ Œº3
œÉ3
‚àíŒº4
œÉ4

‚àíœÅ12 ‚àíœÅ13 + œÅ14 + œÅ23 ‚àíœÅ24 ‚àíœÅ34

pdudu = 1
16

1 +
‚àö
t

‚àíŒº1
œÉ1
+ Œº2
œÉ2
‚àíŒº3
œÉ3
+ Œº4
œÉ4

‚àíœÅ12 + œÅ13 ‚àíœÅ14 ‚àíœÅ23 + œÅ24 ‚àíœÅ34


Multiasset options
207
pdudd = 1
16

1 +
‚àö
t

‚àíŒº1
œÉ1
+ Œº2
œÉ2
‚àíŒº3
œÉ3
‚àíŒº4
œÉ4

‚àíœÅ12 + œÅ13 + œÅ14 ‚àíœÅ23 ‚àíœÅ24 + œÅ34

pdduu = 1
16

1 +
‚àö
t

‚àíŒº1
œÉ1
‚àíŒº2
œÉ2
+ Œº3
œÉ3
+ Œº4
œÉ4

+ œÅ12 ‚àíœÅ13 ‚àíœÅ14 ‚àíœÅ23 ‚àíœÅ24 + œÅ34

pddud = 1
16

1 +
‚àö
t

‚àíŒº1
œÉ1
‚àíŒº2
œÉ2
+ Œº3
œÉ3
‚àíŒº4
œÉ4

+ œÅ12 ‚àíœÅ13 + œÅ14 ‚àíœÅ23 + œÅ24 ‚àíœÅ34

pdddu = 1
16

1 +
‚àö
t

‚àíŒº1
œÉ1
‚àíŒº2
œÉ2
‚àíŒº3
œÉ3
+ Œº4
œÉ4

+ œÅ12 + œÅ13 ‚àíœÅ14 + œÅ23 ‚àíœÅ24 ‚àíœÅ34

pdddd = 1
16

1 +
‚àö
t

‚àíŒº1
œÉ1
‚àíŒº2
œÉ2
‚àíŒº3
œÉ3
‚àíŒº4
œÉ4

+ œÅ12 + œÅ13 ‚àíœÅ14 + œÅ23 + œÅ24 + œÅ34

Table 6.9 The computed values and absolute errors for European options on the
maximum of four assets
N steps
Put
Call
Computed value
Error
Computed value
Error
4
0.6548
2.386 √ó10‚àí2
22.1403
3.096
8
0.6268
4.129 √ó10‚àí3
23.8640
1.372
12
0.6246
6.275 √ó10‚àí3
24.3630
8.733 √ó10‚àí1
16
0.6251
5.836 √ó10‚àí3
24.5934
6.429 √ó10‚àí1
20
0.6257
5.167 √ó10‚àí3
24.7270
5.093 √ó10‚àí1
24
0.6263
4.570 √ó10‚àí3
24.8144
4.219 √ó10‚àí1
28
0.6268
4.074 √ó10‚àí3
24.8762
3.601 √ó10‚àí1
32
0.6272
3.665 √ó10‚àí3
24.9222
3.141 √ó10‚àí1
A binomial lattice was used and we show how the accuracy depends on the number of
time steps. The parameters are: E = 100.0, S1 = S2 = S3 = S4 = 100.0, r = 0.1, œÑ =
1.0, œÉ1 = œÉ2 = œÉ3 = œÉ4 = 0.2, œÅ12 = 0.5, œÅ13 = 0.5, œÅ23 = 0.5, q1 = q2 = q3 = q4 = 0.0.
The accurate values are 0.6309 for a put and 25.2363 for a call, and were computed using
Monte Carlo simulation with 107 paths.

208
Computational Finance Using C and C#
Table 6.10 The computed values and absolute errors for European options on the
minimum of four assets
N steps
Put
Call
Computed value
Error
Computed value
Error
4
7.8274
7.120 √ó10‚àí1
3.5676
4.986 √ó10‚àí1
8
8.1571
3.823 √ó10‚àí1
3.8528
2.134 √ó10‚àí1
12
8.2794
2.600 √ó10‚àí1
3.9300
1.362 √ó10‚àí1
16
8.3429
1.965 √ó10‚àí1
3.9659
1.003 √ó10‚àí1
20
8.3815
1.579 √ó10‚àí1
3.9868
7.944 √ó10‚àí2
24
8.4075
1.319 √ó10‚àí1
4.0004
6.577 √ó10‚àí2
28
8.4262
1.132 √ó10‚àí1
4.0101
5.612 √ó10‚àí2
32
8.4402
9.920 √ó10‚àí2
4.0173
4.894 √ó10‚àí2
A binomial lattice was used and we show how the accuracy depends on the number of
time steps. The parameters are: E = 100.0, S1 = S2 = S3 = S4 = 100.0, r = 0.1, œÑ =
1.0, œÉ1 = œÉ2œÉ3 = œÉ4 = 0.2, œÅ12 = 0.5, œÅ13 = 0.5, œÅ23 = 0.5, q1 = q2 = q3 = q4 = 0.0.
The accurate values are 8.5394 for a put and 4.0662 for a call, and were computed using
Monte Carlo simulation with 107 paths.

7 Other Ô¨Ånancial derivatives
7.1
Introduction
In the preceding sections of the book we have only dealt with the valuation of
equity derivatives. We are now going to consider some of the other types of
trades such as
‚Ä¢ Interest rate derivatives
‚Ä¢ Foreign exchange derivatives
‚Ä¢ Credit derivatives
A selection of these trades will be used by the C# portfolio pricing example in
Chapter 8.
7.2
Interest rate derivatives
It is not possible to make real proÔ¨Åt without risk. For example, if we (without
risk) invest ¬£1 in a bank account, then allowing for interest, the total number
of pounds at future time T will be 1 + I(t, T ), where I(t, T ) is the amount
of interest accrued from t to time T . Since our investment grew by the riskless
interest rate, the real value which allows for inÔ¨Çation must still be ¬£1, so:
DF(t, T )

1 + I(t, T )

= 1
where DF(t, T ) is the discount factor from t to T .
Continuously compounded spot rate
When continuous compounding is used 1 + I(t, T ) = exp{R(t, T )(T ‚àít)},
where R(t, T ) is the annual continuously compounded spot rate between times
t years and T years. We thus have:
DF(t, T ) exp

R(t, T )(T ‚àít)

= 1
(7.2.1)
so the discount factor is given by
DF(t, T ) = exp

‚àíR(t, T )(T ‚àít)

(7.2.2)
and the continuously compounded rate is
R(t, T ) = ‚àílog(DF(t, T ))
T ‚àít
(7.2.3)

210
Computational Finance Using C and C#
Simply compounded spot rate
When simple compounding is used I(t, T ) = L(t, T )(T ‚àít), where L(t, T ) is
the simply compounded spot rate between time t and T . Thus,
DF(t, T )

1 + L(t, T )(T ‚àít)

= 1
and so the simply compounded rate is:
L(t, T ) =
1
T ‚àít

1
DF(t, T ) ‚àí1

(7.2.4)
7.2.1
Forward rate agreement
A Forward Rate Agreement (FRA) is a contract between two counterparties
(referred to here as A and B), in which one counterparty (say A) agrees to pay
interest at the (variable) spot rate, while the other agrees to pay at a Ô¨Åxed interest
rate. Let the agreement start at time Ts and end at the maturity Tm, at which time
the counterparties settle the amount that is owed. If P is the principal then, at
time Tm, the contract has the following value to A:
V (Tm) = P

(Tm ‚àíTs)K ‚àíL(Ts, Tm)(Tm ‚àíTs)

(7.2.5)
where K is the agreed Ô¨Åxed rate, and L(Ts, Tm) is the simply compounded rate
between times Ts and Tm. From Eq. (7.2.4) we have:
L(Ts, Tm) =
1
Tm ‚àíTs

1
DF(Ts, Tm) ‚àí1

so
V (Tm) = P

(Tm ‚àíTs)K ‚àí

1
DF(Ts, Tm) ‚àí1

(7.2.6)
The value of the FRA to A at time t ‚©ΩTm is therefore FRA(t) = DF(t, Tm)V (Tm)
which means that
FRA(t) = DF(t, Tm)P

(Tm ‚àíTs)K ‚àí

1
DF(Ts, Tm) ‚àí1

(7.2.7)
Using DF(t, Tm) = DF(t, Ts)DF(Ts, Tm) we can rewrite Eq. (7.2.7) as
FRA(t) = DF(t, Tm)P

(Tm ‚àíTs)K ‚àí
 DF(t, Ts)
DF(t, Tm) ‚àí1

(7.2.8)
The value of K that sets FRA(t) to zero is termed the time t forward rate be-
tween times Ts and Tm, and is here denoted by F(t, Ts, Tm). From Eq. (7.2.8),
F(t, Ts, Tm) =
1
Tm ‚àíTs
 DF(t, Ts)
DF(t, Tm) ‚àí1

(7.2.9)
Combining Eqs. (7.2.8) and (7.2.10) we can express the value of the FRA as:
FRA(t) = DF(t, Tm)PœÑ

K ‚àíF(t, Ts, Ts + œÑ)

(7.2.10)
where œÑ = Tm ‚àíTs is known as the tenor of the FRA, and Ts is the reset time
for forward rate F(t, Ts, Ts + œÑ).

Other Ô¨Ånancial derivatives
211
7.2.2
Interest rate swap
Interest Rate Swaps (IRS) are very common Ô¨Ånancial instruments‚Äîit is not un-
usual for 80 percent of the trades in a portfolio to be IRS deals. Here we will
provide a description of some of the characteristics of interest rate swaps; more
detail can be found in Hull (2003).
A vanilla IRS consists of a strip of FRA trades, each FRA starting when the
previous FRA Ô¨Ånishes. The maturity date of the IRS thus corresponds to the
maturity date of the last FRA.
Let the start times of the FRAs be ti, i = 0, . . . , n ‚àí1, and the maturity times
of the FRAs be ti, i = 1, . . . , n; note that the FRA start times correspond to
the forward rate reset times, and the maturity times correspond to the FRA
payment times. We will now adopt the (common) convention of calling the
trades swaplets, so an IRS is made up of a number of swaplets.
When the counterparty A pays the Ô¨Åxed rate and receives the Ô¨Çoating rate the
trade (from A perspective) is termed a payer IRS. Alternatively, if A receives the
Ô¨Åxed rate and pays the Ô¨Çoating rate, then the trade is termed a receiver IRS.
The value of an IRS at time t, where tk‚àí1 < t < tk, will now be considered.
We will assume that discount factors used to compute the forward rates and
those used to discount the coupon payments are associated with the same yield
curve. Using Eq. (7.2.10) we have:
IRS(t) = CDF(t, tk) +
n

i=k+1
DF(t, ti)PœÑi

K ‚àíF(t, ti‚àí1, ti‚àí1 + œÑi)

(7.2.11)
where C is the next coupon payment after current time t (this occurs at time tk),
and œÑi is the tenor of the ith swaplet which starts at time ti‚àí1 and ends at time
ti.
Note that the next coupon payment C for the swaplet starting at time tk‚àí1
and maturing at time tj is already known with certainty at time t because the
forward rate F(t, tk‚àí1, tk) was reset in the past; tk‚àí1 < t.
We will now rewrite Eq. (7.2.11) as:
IRS(t) = CDF(t, tk) + FXD(t) ‚àíFLT(t)
(7.2.12)
where FXD(t), the time t value of the Ô¨Åxed leg, is:
FXD(t) = PK
n

i=k+1
DF(t, ti)œÑi
(7.2.13)
and FLT(t), the time t value of the Ô¨Çoating leg, is:
FLT(t) = P
n

i=k+1
DF(t, ti)œÑiF(t, ti‚àí1, ti‚àí1 + œÑi)
(7.2.14)

212
Computational Finance Using C and C#
The Ô¨Çoating leg
We will now evaluate Eq. (7.2.14). The Ô¨Çoating leg coupon payment at time ti
will be denoted by Ci and has value:
Ci = PF(t, ti‚àí1, ti‚àí1 + œÑi)œÑi
where
F(t, ti‚àí1, ti‚àí1 + œÑi) =

DF(t, ti‚àí1)
DF(t, ti‚àí1 + œÑi) ‚àí1
 1
œÑi
From Eq. (7.2.14) we thus have:
FLT(t) =
n

i=k+1
CiDF(t, ti)
= P
n

i=k+1
DF(t, ti)œÑi
DF(t, ti‚àí1)
DF(t, ti)
‚àí1
 1
œÑi
= P
n

i=k+1

DF(t, ti‚àí1) ‚àíDF(t, ti)

= P

DF(t, tk) ‚àíDF(t, tk+1) + DF(t, tk+1) ‚àí¬∑ ¬∑ ¬∑
‚àíDF(t, ti) + DF(t, ti) ‚àí¬∑ ¬∑ ¬∑ ‚àíDF(t, tn)

= P

DF(t, tk) ‚àíDF(t, tn)

and so the value of the Ô¨Çoating leg is
FLT(t) = P

DF(t, tk) ‚àíDF(t, tn)

(7.2.15)
The swap rate
The time t swap rate SRt is the value of the Ô¨Åxed rate K that makes the IRS(t)
zero. Thus, from Eqs. (7.2.12)‚Äì(7.2.14):
P

DF(t, tk) ‚àíDF(t, tn)

‚àíCDF(t, tk) = PSRt
n

i=k+1
DF(t, ti)œÑi
(7.2.16)
so
SRt = {DF(t, tk) ‚àíDF(t, tn)} ‚àíC
P DF(t, tk)

n
i=k+1 DF(t, ti)œÑi
(7.2.17)
Amortization
So far we have assumed that the principal is Ô¨Åxed and set to the value P. We
will now deal with the situation where the principal varies with time according
to the following amortization schedule:
AMi = Pi‚àí1 ‚àíPi,
i = 0, . . . , n ‚àí1,
(7.2.18)

Other Ô¨Ånancial derivatives
213
where Pi is the value of the principal at time ti and P0 = P.
The value of the Ô¨Çoating leg is now computed as:
FLT(t) =
n

i=k+1
Pi‚àí1DF(t, ti)œÑi
DF(t, ti‚àí1)
DF(t, ti)
‚àí1
 1
œÑi
=
n

i=k+1
Pi‚àí1

DF(t, ti‚àí1) ‚àíDF(t, ti)

= PkDF(t, tk) ‚àíPkDF(t, tk+1)
+ Pk+1DF(t, tk+1) ‚àíPk+1DF(t, tk+2) + ¬∑ ¬∑ ¬∑
+ Pn‚àí2DF(t, tn‚àí1) ‚àíPn‚àí1DF(t, tn‚àí1) ‚àíPn‚àí1DF(t, tn)
= PkDF(t, tk) ‚àíDF(t, tk+1){Pk ‚àíPk+1} ‚àíPk+1 ‚àí¬∑ ¬∑ ¬∑
‚àíDF(t, tn‚àí2){Pn‚àí2 ‚àíPn‚àí1} ‚àíPn‚àí1DF(t, tn)
= PkDF(t, tk) ‚àíPn‚àí1DF(t, tn) +
n‚àí1

i=k+1
AMiDF(t, ti)
(7.2.19)
and so the value of the Ô¨Çoating leg is:
FLT(t) = PkDF(t, tk) ‚àíPn‚àí1DF(t, tn) +
n‚àí1

i=k+1
AMiDF(t, ti)
(7.2.20)
When there is no amortization (Pk = Pn‚àí1 and AMi = 0, i = 0, . . . , n ‚àí1)
then Eq. (7.2.20) reduces to Eq. (7.2.15).
Basis swap
This is very similar to an interest rate swap, but now there are two Ô¨Çoating legs,
each with their associated principal amount.
For example, Ô¨Çoating leg 1 could be associated with the one month LIBOR
(London Inter Bank Offer Rate) and have a schedule of monthly payments,
while Ô¨Çoating leg 2 could use the three month LIBOR rates and have quarterly
payments. In this case, the forward rates and discount factors for leg 1 would
be computed using the 1 month LIBOR yield curve and the forward rates and
discount factors for leg 2 will be computed using the three month LIBOR yield
curve.
We will use the subscripts 1 and 2 to denote quantities associated with
legs 1 and 2 respectively. The payment times associated with leg 1 are ti
1, i =
1, . . . , n1, while those for leg 2 are ti
2, i = 1, . . . , n2, and (for this example)
n1 = 3n2.
If counterparty A makes the quarterly payments (that is, receives the pay-
ments made on leg 1), then the time t value of the basis swap is:
BS(t) = C1DF1(t, tk1) + FLT1(t) ‚àíC2DF2(t, tk2) ‚àíFLT2(t)
(7.2.21)

214
Computational Finance Using C and C#
where we have used similar notation to that used in Eq. (7.2.12), with
FLT1(t) = P1

DF1(t, tk1) ‚àíDF1(t, tn)

(7.2.22)
and
FLT2(t) = P2

DF2(t, tk2) ‚àíDF2(t, tn)

(7.2.23)
In Eqs. (7.2.22) and (7.2.23) P1 is the principal for leg 1 and P2 is the principal
for leg 2. The time of the next coupon payment for leg 1 is tk1, while that for
leg 2 is tk2: in addition we have used the fact that tn1 = tn2 = tn.
We will now consider the case in which the basis swap has been traded at
time t, and shall also assume that C1 = C2 = 0 and t = tk1 = tk2. In addition, we
will specify that principal exchange occurs at the start (time t) and end (time tn)
of the swap.
The cash Ô¨Çows associated with principal exchange at the start of the swap leg
are in the opposite direction to those for the remainder of the swap leg; see Hull
(2003). We have:
FLT1(t) = P1 ‚àíP1DF1(t, tn) +

‚àíP1 + P1DF(t, tn)

(7.2.24)
and
FLT2(t) = P2 ‚àíP2DF2(t, tn) +

‚àíP2 + P2DF(t, tn)

(7.2.25)
where the principal exchange terms are in the curly brackets, and use discount
factors DF(t, T ) derived from the main currency yield curve (in this case GBP)
rather than DF1(t, T ) or DF2(t, T ).
It can be seen from Eq. (7.2.21) that principal exchange at the start of the
swap causes leg 2 to contribute the positive amount P2 to the value of the swap,
while leg 1 contributes the negative amount P2 to the value of the swap. In
contrast, principal exchange at the end of the swap results in leg 2 contributing
the negative amount ‚àíP2DF(t, tn) to the swap value, while leg 1 contributes
the positive amount P1DF(t, tn). If P1 = P2 = P then principal exchange does
not affect the value of the basis swap. It can also be seen from Eq. (7.2.24)
that if leg 1 used the main GBP yield curve instead of the one month LIBOR
curve, then DF1(t, tn) = DF(t, tn) which would result in FLT1(t) = 0. Similarly
DF2(t, tn) = DF(t, tn) would mean that FLT2(t) = 0.
If the valuation time t is after the trade has started, then Eq. (7.2.21) can be
used to price the basis swap, but Eqs. (7.2.24) and (7.2.25) need to be modiÔ¨Åed
as follows:
FLT1(t) = P1DF1(t, tk1) ‚àíP1DF1(t, tn) +

P1DF(t, tn)

(7.2.26)
and
FLT2(t) = P2DF2(t, tk2) ‚àíP2DF2(t, tn) +

P2DF(t, tn)

(7.2.27)
We will now consider how the timing of the coupon payment in relation to its
associated forward rate affects the present value, Vt0, of the coupon.

Other Ô¨Ånancial derivatives
215
Coupon payment on time
In this section we will justify the approach we have adopted in obtaining the
present value of future cashÔ¨Çows generated from vanilla forward rates.
From Eq. (4.2.1) we know that the value at time t0 of a coupon payment at
time tk is:
Vt0 = DF(t0, tk)EQkF(tk‚àí1, tk‚àí1, tk)
DF(tk, tk)

œÑP
where the symbols have their usual meaning, and we have chosen the numeraire
to be the zero coupon bond which matures at time tk. Since DF(tk, tk) = 1 we
can write
Vt0 = DF(t0, tk)EQk
F(tk‚àí1, tk‚àí1, tk)

œÑP
(7.2.28)
In Section 7.2.3 we show that F(t, tk‚àí1, tk) follows the process:
d

F(t, tk‚àí1, tk)

= œÉkF(t, tk‚àí1, tk) dW k
(7.2.29)
If we assume that œÉk is constant, then Eq. (7.2.29) is GBM (see Chapter 2) and
has the solution:
F(t, tk‚àí1, tk) = F(t0, tk‚àí1, tk) exp

‚àí(t ‚àít0)œÉ 2
k
2
+ œÉkW k
t

(7.2.30)
where we have taken W k
t0 = 0.
Substituting t = tk‚àí1 into Eq. (7.2.30) gives:
F(tk‚àí1, tk‚àí1, tk) = F(t0, tk‚àí1, tk) exp

‚àí(tk‚àí1 ‚àít0)œÉ 2
k
2
+ œÉkW k
tk‚àí1

(7.2.31)
which means that:
EQk
F(tk‚àí1, tk‚àí1, tk)

= EQk
F(t0, tk‚àí1, tk) exp

‚àí(tk‚àí1 ‚àít0)œÉ 2
k
2
+ œÉkW k
tk‚àí1

= F(t0, tk‚àí1, tk)EQk
exp

‚àí(tk‚àí1 ‚àít0)œÉ 2
k
2
+ œÉkW k
tk‚àí1

= F(t0, tk‚àí1, tk)EQk
exp

‚àí(tk‚àí1 ‚àít0)œÉ 2
k
2
+ œÉk

tk‚àí1 ‚àít0 N(0, 1)

= F(t0, tk‚àí1, tk)
where we have used the fact (see Appendix D.2) that
EQk
exp

‚àí(tk‚àí1 ‚àít0)œÉ 2
k
2
+ œÉk

tk‚àí1 ‚àít0 N(0, 1)

= exp

‚àí(tk‚àí1 ‚àít0)œÉ 2
k
2
+ (tk‚àí1 ‚àít0)œÉ 2
k
2

= 1

216
Computational Finance Using C and C#
Substituting for EQk[F(tk‚àí1, tk‚àí1, tk)] in Eq. (7.2.28):
Vt0 = PœÑF(t0, tk‚àí1, tk) = DF(t0, tk)1
œÑ
DF(t0, tk‚àí1)
DF(t0, tk)
‚àí1

PœÑ
This yields
Vt0 = P

DF(t0, tk‚àí1) ‚àíDF(t0, tk)

(7.2.32)
which is our current method of valuing the future coupons generated by forward
rates.
General payment timing
For the general case, in which the coupon payment date does not correspond to
the end of its associated forward rate, we use the result from Eq. (7.2.43) that
dW k =
Œºk
œÉk

dt + dW i,
i Ã∏= k
(7.2.33)
Equation (7.2.33) states that Brownian motion W i under numeraire DF(t, ti)
can be transformed into Brownian motion W k under numeraire DF(t, tk) by the
addition of a drift term‚Äîmore detail can be found in Section 7.2.3. If we assume
constant drift Œºk, W k
t0 = W i
t0 = 0 we obtain:
W k
t = (t ‚àít0)
Œºk
œÉk

+ W i
t
(7.2.34)
and in Eq. (7.2.30)
œÉkW k
t = (t ‚àít0)Œºk + œÉkW i
t
A constant Œºk can be achieved by freezing the forward rates that make up Œºk;
for example, F(t, tk‚àí1, tk) ‚ÜíF(t0, tk‚àí1, tk); see Section 7.2.3 for more details
concerning Œºk.
This means that F(t, tk‚àí1, tk) follows the process:
d

F(t, tk‚àí1, tk)

= F(t, tk‚àí1, tk)Œºk dt + F(t, tk‚àí1, tk)œÉk dW i
The above equation is GBM with drift and can be solved by modifying
Eq. (7.2.30) to:
F(t, tk‚àí1, tk)
= F(t0, tk‚àí1, tk) exp

(t ‚àít0)Œºk ‚àí(t ‚àít0)œÉ 2
k
2
+ œÉkW i
t

(7.2.35)
As before, the time t0 value of the coupon payment at time ti is:
Vt0 = DF(t0, ti)EQiF(tk‚àí1, tk‚àí1, tk)
DF(ti, ti)

œÑP
which since DF(ti, ti) = 1 becomes
Vt0 = DF(t0, ti)EQi
F(tk‚àí1, tk‚àí1, tk)

œÑP
(7.2.36)

Other Ô¨Ånancial derivatives
217
Now, from Eq. (7.2.35) we have:
EQi
F(tk‚àí1, tk‚àí1, tk)

= EQi
F(t0, tk‚àí1, tk) exp

(t ‚àít0)Œºk ‚àí(tk‚àí1 ‚àít0)œÉ 2
k
2
+ œÉkW i
tk‚àí1

= F(t0, tk‚àí1, tk) exp

(tk‚àí1 ‚àít0)Œºk

√ó EQi
exp

‚àí(tk‚àí1 ‚àít0)œÉ 2
k
2
+ œÉkW i
tk‚àí1

= F(t0, tk‚àí1, tk) exp

(tk‚àí1 ‚àít0)Œºk

(7.2.37)
where, as before, we have used the expectation given in Appendix D.2.
By expanding Eq. (7.2.37) to Ô¨Årst order we obtain:
EQi
F(tk‚àí1, tk‚àí1, tk)

= F(t0, tk‚àí1, tk) + F(t0, tk‚àí1, tk)(tk‚àí1 ‚àít0)Œºk
(7.2.38)
Substituting Eq. (7.2.38) into Eq. (7.2.36), we obtain a general expression for
the value of the coupon payment:
Vt0 = DF(t0, ti)œÑ

F(t0, tk‚àí1, tk) + F(t0, tk‚àí1, tk)(tk‚àí1 ‚àít0)Œºk

(7.2.39)
We will now consider the cases of early and late coupon payments.
Early coupon payment
Let us consider the case when i = k ‚àí1. From Eq. (7.2.50):
Œºk = œÑœÉ 2
k F(t, tk‚àí1, tk)
1 + œÑF(t, tk‚àí1, tk)
First we freeze the forward rates in Œºk so we use the following:
Œºk = œÑœÉ 2
k F(t0, tk‚àí1, tk)
1 + œÑF(t0, tk‚àí1, tk)
Substituting for Œºk in Eq. (7.2.39) we obtain:
Vt0 = DF(t0, tk‚àí1)œÑP

F(t0, tk‚àí1, tk) + (tk‚àí1 ‚àít0)œÉ 2
k œÑkF 2(t0, tk‚àí1, tk)
1 + œÑF(t0, tk‚àí1, tk)

(see Brigo and Mercurio, 2001, p. 387, and Hull, 2003).
Late coupon payment
We consider the case when i = k + 1. From Eq. (7.2.66):
Œºk = ‚àíœÑœÅk,k+1œÉkœÉk+1F(t, tk, tk+1)
1 + œÑF(t, tk, tk+1)

218
Computational Finance Using C and C#
Freezing the forward rates we obtain:
Œºk = ‚àíœÑœÅk,k+1œÉkœÉk+1F(t0, tk, tk+1)
1 + œÑF(t0, tk, tk+1)
Substituting for Œºk in Eq. (7.2.39) we obtain:
Vt0 = DF(t0, tk+1)
√ó œÑP

F(t0, tk‚àí1, tk)
‚àí(tk ‚àít0)œÑœÅk,k+1œÉkœÉk+1F(t0, tk‚àí1, tk)F(t0, tk, tk+1)
1 + œÑF(t0, tk, tk+1)

7.2.3
Timing adjustment
In this section we derive expressions for the drift of the forward rate F(t, tk‚àí1, tk)
under various probability measures. We will denote the time t value of a zero
coupon bond which pays 1 unit of currency at maturity ti by DF(t, ti). For
convenience we will also use the shortened notation Fk = F(t, tk‚àí1, tk) and
DFi = DF(t, ti).
The probability measure under which all tradable assets are priced relative to
the zero coupon bond price DFi (that is, DFi is the numeraire) will be denoted
by Qi; under this probability measure the relative prices will be martingales. We
will also denote Brownian motion under probability measure Qi by W i.
Case i = k
Here the maturity of the numeraire DFk is at the expiry of the forward rate Fk.
Since DFk(1+œÑFk) is a tradable its relative price, (1 + œÑFk)/DFk, is a martin-
gale under Qk and thus has zero drift.
Also DFk(1 + œÑFk)/DFk = 1 + œÑFk and, since both œÑ and 1 are constants,
Fk must be a martingale under Qk. Thus the process for Fk has zero drift and is:
dFk = FkœÉk dW k
(7.2.40)
For the general case in which i Ã∏= k, the process followed by Fk is:
dFk = FkŒºk dt + FkœÉk dW i
(7.2.41)
where Œºk is a drift that needs to be determined. Equation (7.2.41) can be rewrit-
ten as:
dFk = FkœÉk
Œºk
œÉk
dt + dW i

(7.2.42)
Comparing Eqs. (7.2.41) and (7.2.42) we have:
dW k = Œºk
œÉk
dt + dW i
(7.2.43)
This equation gives the relation between Brownian motions under probability
measures Qk and Qi. We will now show how to compute the value of Œºk.

Other Ô¨Ånancial derivatives
219
Case i < k
Here we consider situations in which the maturity of the numeraire DFi is before
the expiry of the forward rate Fk.
i = k ‚àí1
In this case DFk‚àí1 is the numeraire, the forward rate is Fk = F(t, tk‚àí1, tk),
and the numeraire matures at time tk‚àí1, while the forward rate has expiry tk.
Since DFk is a tradable the relative price, œÜ = DFk/DFk‚àí1, is a martingale
under Qk‚àí1, and thus has zero drift.
Now
œÜ =
DFk
DFk‚àí1
=
1
1 + œÑFk
(7.2.44)
where we have used:
DFk‚àí1 = DFk(1 + œÑFk)
(7.2.45)
Let the stochastic process followed by Fk under Qk‚àí1 be:
dFk = FkŒºk dt + FkœÉk dW k‚àí1
(7.2.46)
and the drift, Œºk, is to be determined.
Using Ito we have:
dœÜ = ‚àÇœÜ
‚àÇFk
dFk + 1
2
‚àÇ2œÜ
‚àÇF 2
k
E

(dFk)2
,
E

(dFk)2
= œÉ 2
k F 2
k dt,
(7.2.47)
where from Eq. (7.2.44):
‚àÇœÜ
‚àÇFk
= ‚àí
œÑ
(1 + œÑFk)2 ,
‚àÇ2œÜ
‚àÇFk2 =
2œÑ 2
(1 + œÑFk)3
(7.2.48)
Substituting the values in Eq. (7.2.48) into Eq. (7.2.47) we obtain:
dœÜ = ‚àí
œÑœÜ
1 + œÑFk

FkŒºk dt + FkœÉk dW k‚àí1
+ 1
2
œÑ 22œÜœÉ 2F 2
k dt
(1 + œÑFk)2
which can be rearranged as:
dœÜ =

‚àíœÑFkŒºkœÜ
1 + œÑFk
+ œÜœÑ 2œÉ 2
k F 2
k
(1 + œÑFk)2

dt ‚àíœÑœÜFkœÉk
1 + œÑFk
dW k‚àí1
(7.2.49)
Now since Eq. (7.2.49) is driftless:

‚àíœÑFkŒºkœÜ
1 + œÑFk
+ œÜœÑ 2œÉ 2
k F 2
k
(1 + œÑFk)2

dt = 0
and
Œºk = œÑœÉ 2
k Fk
1 + œÑFk
(7.2.50)

220
Computational Finance Using C and C#
Substituting Eq. (7.2.50) into Eq. (7.2.46):
dFk = œÑœÉ 2
k F 2
k
1 + FkœÑ dt + FkœÉk dW k‚àí1
or
dFk = FkœÉk
 œÑœÉ 2
k Fk
1 + FkœÑ dt + dW k‚àí1

(7.2.51)
Comparing Eqs. (7.2.51) and (7.2.40) thus yields:
dW k = œÑœÉkFk
1 + FkœÑ dt + dW k‚àí1
(7.2.52)
which is the relationship between the Brownian motions dW k‚àí1 and dW k under
the respective probability measures Qk‚àí1 and Qk.
i ‚©Ωk ‚àí2
Let the stochastic process followed by Fk under Qk‚àí2 be:
dFk = FkŒºk dt + FkœÉk dW k‚àí2
(7.2.53)
where W k‚àí2 is Brownian motion under probability measure Qk‚àí2, and the drift,
Œºk, is unknown.
Replacing k with k ‚àí1 in Eq. (7.2.52) gives:
dW k‚àí1 = œÑœÉk‚àí1Fk‚àí1
1 + Fk‚àí1œÑ dt + dW k‚àí2
(7.2.54)
and using Eq. (7.2.54) to substitute for dW k‚àí1 in Eq. (7.2.52) we obtain:
dW k = œÑœÉkFk
1 + FkœÑ dt + œÑœÉk‚àí1Fk‚àí1
1 + Fk‚àí1œÑ dt + dW k‚àí2
(7.2.55)
Replacing dW k in Eq. (7.2.40) with that given in Eq. (7.2.55):
dFk = FkœÉk
 œÑœÉkFk
1 + FkœÑ dt + œÑœÉk‚àí1Fk‚àí1
1 + Fk‚àí1œÑ dt

+ FkœÉk dW k‚àí2
(7.2.56)
so the drift is:
Œºk = œÑœÉ 2
k Fk
1 + œÑFk
+ œÑFk‚àí1œÉkœÉk‚àí1œÅk,k‚àí1
1 + œÑFk‚àí1
(7.2.57)
The following general expression can be derived in a similar manner:
dFk = œÉkFk
k

j=i+1
œÅk,jœÑœÉjFj
1 + œÑFj
dt + œÉkFk dW i
(7.2.58)
where all the symbols have the same meanings as before, but now i can take
any integer value less than k.

Other Ô¨Ånancial derivatives
221
Case i > k
We now consider the case when the maturity of the numeraire DFi is after the
expiry of the forward rate Fk.
i = k + 1
Here DFk+1 is the numeraire and Fk is the forward rate which starts at time
tk‚àí1 and ends at time tk.
Since DFk‚àí1 is a tradable its relative price, œÜ = DFk‚àí1/DFk+1, is a martingale
under Qk+1, and thus has zero drift.
Now:
œÜ = DFk‚àí1
DFk+1
= (1 + œÑFk)(1 + œÑFk+1)
(7.2.59)
where the processes for Fk and Fk+1 are
dFk+1 = Fk+1œÉk+1dW k+1
(7.2.60)
dFk = FkŒºk dt + FkœÉk dW k+1
(7.2.61)
and the drift, Œºk, is to be determined.
Using Ito we have:
dœÜ = ‚àÇœÜ
‚àÇFk
dFk +
‚àÇœÜ
‚àÇFk+1
dFk+1 + 1
2
k+1

i=k
k+1

j=k
‚àÇ2œÜ
‚àÇFi ‚àÇFj
E[dFi, dFj]
(7.2.62)
where
‚àÇœÜ
‚àÇFk
= œÑ(1 + œÑFk+1),
‚àÇœÜ
‚àÇFk+1
= œÑ(1 + œÑFk)
‚àÇ2œÜ
‚àÇF 2
k
=
‚àÇ2œÜ
‚àÇF 2
k+1
= 0,
‚àÇ2œÜ
‚àÇFk+1 ‚àÇFk
=
‚àÇ2œÜ
‚àÇFk ‚àÇFk+1
= œÑ 2
(7.2.63)
E[dFk, dFk+1] = [dFk+1, dFk] = œÅk,k+1œÉkœÉk+1FkFk+1 dt
Substituting the values in (7.2.63) into Eq. (7.2.62) we obtain:
dœÜ = œÑ(1 + œÑFk+1) dFk + œÑ(1 + œÑFk) dFk+1 + œÑ 2œÅk,k+1œÉkœÉk+1FkFk+1 dt
After expanding the terms in dFk and dFk+1 we have:
dœÜ = œÑ(1 + œÑFk+1)

FkŒºk dt + FkœÉk dW k+1
+ œÑ(1 + œÑFk)Fk+1œÉk+1 dW k+1 + œÑ 2œÅk,k+1œÉkœÉk+1FkFk+1 dt
and this can be re-expressed as:
dœÜ = D + œÑ(1 + œÑFk+1)FkœÉk dW k+1
+ œÑ(1 + œÑFk)Fk+1œÉk+1 dW k+1
(7.2.64)
where the drift term D in Eq. (7.2.64) is given by:
D = œÑ(1 + œÑFk+1)FkŒºk dt + œÑ 2œÅk,k+1œÉkœÉk+1FkFk+1 dt
(7.2.65)

222
Computational Finance Using C and C#
Now since œÜ is a martingale under Qk+1 we know that D = 0, and therefore
Eq. (7.2.65) results in:
(1 + œÑFk+1)FkŒºk dt = ‚àíœÅk,k+1œÉkœÉk+1FkFk+1 dt
This means that the drift is:
Œºk = ‚àíœÑœÅk,k+1œÉkœÉk+1Fk+1
1 + œÑFk+1
(7.2.66)
Substituting for Œºk in Eq. (7.2.61) gives:
dFk = FkœÉk

‚àíœÑœÅk,k+1œÉk+1Fk+1
1 + œÑFk+1
dt + dW k+1

(7.2.67)
Comparing Eq. (7.2.67) with Eq. (7.2.40) we have:
dW k = ‚àíœÑœÅk,k+1œÉk+1Fk+1
1 + œÑFk+1
dt + dW k+1
(7.2.68)
which is the relationship between Brownian motions dW k and dW k+1.
i ‚©æk + 2
Let the stochastic process followed by Fk under Qk+2 be:
dFk = FkŒºk dt + FkœÉk dW k+2
(7.2.69)
where W k+2 is Brownian motion under probability measure Qk+2, and drift
term Œºk is to be found.
Replacing k with k + 1 in Eq. (7.2.68) gives:
dW k+1 = ‚àíœÑœÅk+1,k+2œÉk+2Fk+2
1 + œÑFk+2
dt + dW k+2
(7.2.70)
and using Eq. (7.2.70) to substitute for dW k+1 in Eq. (7.2.68) gives:
dW k = ‚àíœÑœÅk,k+1œÉk+1Fk+1
1 + œÑFk+1
dt ‚àíœÑœÅk+1,k+2œÉk+2Fk+2
1 + œÑFk+2
dt + dW k+2
Substituting for dW k in Eq. (7.2.40) gives:
dW k = ‚àíFkœÉk
œÑœÅk,k+1œÉk+1Fk+1
1 + œÑFk+1
dt + œÑœÅk+1,k+2œÉk+2Fk+2
1 + œÑFk+2
dt

+ FkœÉk dW k+2
(7.2.71)
and thus the drift is a
Œºk = ‚àíœÑœÅk,k+1œÉk+1Fk+1
1 + œÑFk+1
‚àíœÑœÅk+1,k+2œÉk+2Fk+2
1 + œÑFk+2
(7.2.72)
The following general expression can be derived in a similar manner:
dFk = ‚àíœÉkFk
i

j=k+1
œÅk,jœÑœÉjFj
1 + œÑFj
dt + œÉkFk dW i
(7.2.73)
where all the symbols have the same meanings as before, but now i can take
any integer value greater than k.

Other Ô¨Ånancial derivatives
223
7.2.4
Interest rate quantos
This section considers derivatives whose value depends on the foreign interest
rate yield curve but have a payoff in domestic currency. We use the same nota-
tion as in Section 7.3, which deals with foreign exchange derivatives.
For example, a standard interest rate caplet has a payoff in domestic currency
and also depends on the domestic currency forward rates. The value at time t0
of a caplet which pays at time tk and extends from time tk‚àí1 to time tk is:
Caplet(t0) = PœÑDFd(t0, tk)EQk
max

F d
k ‚àíK, 0

(7.2.74)
where P is the principal, K is the strike, œÑ = tk‚àí1‚àítk, Fk is the domestic forward
rate F(t0, tk‚àí1, tk). Equation (7.2.74) can be evaluated using the Black‚ÄìScholes
formula as follows:
Caplet(t0) = PœÑDFd(t0, tk)

F d(t0, tk‚àí1, tk)N1(d1) ‚àíKN1(d2)

(7.2.75)
where œÉd is the volatility of Fk, and
d1 = log(F d(t0, tk‚àí1, tk)/K) + œÉ 2
d
2 (tk‚àí1 ‚àít0)
œÉd
‚àötk‚àí1 ‚àít0
d2 = log(F d(t0, tk‚àí1, tk)/K) ‚àíœÉ 2
d
2 (tk‚àí1 ‚àít0)
œÉd
‚àötk‚àí1 ‚àít0
(7.2.76)
In Section 7.2.3 we showed that the process (F d(t, tk‚àí1, tk)/DFd(t, tk)) is a mar-
tingale, that is has zero drift when DFd(t, tk) is used as a numeraire.
d

F d(t, tk‚àí1, tk)

= œÉdF d(t, tk‚àí1, tk) dW Q
k
Quanto caplet
In a quanto caplet instead of using the domestic forward rate F d(t0, tk‚àí1, tk) we
use the foreign forward rate F f (t0, tk‚àí1, tk). Under the probability measure F
associated with a foreign zero coupon bond DFf (t, kk) the foreign forward rate
is a martingale, and is described by the following equation:
d

F f (t, tk‚àí1, tk)

= œÉf F f (t, tk‚àí1, tk) dW F
f
(7.2.77)
However, when we use DFd(t, tk) as a numeraire the process (F f (t, tk‚àí1, tk)/
DFd(t, tk)) has a drift, and follows the process:
d

F f (t, tk‚àí1, tk)

= F f (t, tk‚àí1, tk)Œ± dt + œÉf F f (t, tk‚àí1, Tk) dW Q
f
(7.2.78)
Our aim is to Ô¨Ånd the value of Œ± and then price the quanto caplet using:
QCaplet(t0) = PœÑDFd(t0, tk)
√ó

F f (t0, tk‚àí1, tk) exp

Œ±(tk‚àí1 ‚àít0)

N1(d1) ‚àíKN1(d2)

(7.2.79)

224
Computational Finance Using C and C#
where P is the principal, K is the strike, œÑ = tk‚àí1 ‚àítk, F f (t0, tk‚àí1, tk) is the
foreign currency forward rate, œÉf is the volatility of F f (t0, tk‚àí1, tk) and
d1 =
log(F f (t0, tk‚àí1, tk)/K) + (Œ± + œÉ 2
f /2)(tk‚àí1 ‚àít0)
œÉf
‚àötk‚àí1 ‚àít0
d2 =
log(F f (t0, tk‚àí1, tk)/K) + (Œ± ‚àíœÉ 2
f /2)(tk‚àí1 ‚àít0)
œÉf
‚àötk‚àí1 ‚àít0
We will now derive the value of Œ±.
First we deÔ¨Åne two processes X1(t) and X2(t) such that:
X1(t) =
DFf (t, tk‚àí1) ‚àíDFf (t, tk)
DFd(t, tk)

Xf
d (t)
(7.2.80)
and
X2(t) = œÑXf
d (t)DFf (t, tk)
DFd(t, tk)
= œÑXf
d (t, tk)
(7.2.81)
where Xf
d (t, tk) is the forward foreign exchange rate (see Section 7.3). Therefore,
X1(t)
X2(t) = DFf (t, tk‚àí1) ‚àíDFf (t, tk)
œÑDFf (t, tk)
= F f (t, tk‚àí1, tk)
(7.2.82)
Now X1 and X2 are martingales under Q so we have:
dX1 = œÉ1X1 dW Q
1
(7.2.83)
and
dX2 = œÉ2X2 dW Q
2
(7.2.84)
Equation (7.2.84) can also be expressed as
d(œÑXf
d (t, tk))
œÑXf
d (t, tk)
= œÉx dW Q
x
(7.2.85)
Using Ito we obtain:
d
X1
X2

= X1
X2

œÉ1 dW Q
1 ‚àíœÉ2 dW Q
2

+ X1
X2

E

œÉ2 dW Q
2
2
‚àíE

œÉ1 dW Q
1

œÉ2 dW Q
2

(7.2.86)
and the following processes for log(X1) and log(X2):
d

log(X1)

= ‚àíœÉ 2
1
2 dt + œÉ1 dW Q
1
d

log(X2)

= ‚àíœÉ 2
2
2 dt + œÉ2 dW Q
2
(7.2.87)

Other Ô¨Ånancial derivatives
225
Using Eq. (7.2.85) we can write Eq. (7.2.87) as:
d

log

œÑXf
d (t, tk)

= ‚àíœÉ 2
x
2 dt + œÉx dW Q
x
(7.2.88)
Now,
E

d

log(X2)

d

log(X2)

‚àíd

log(X1)

= E

d

log(X2)
2
‚àíE

d

log(X1)

d

log(X2)

= E

œÉ2 dW Q
2
2
‚àíE

œÉ1 dW Q
1

œÉ2 dW Q
2

where we have ignored terms in dt with order greater than 1.
In addition,
E

d

log(X2)

d

log(X2)

‚àíd

log(X1)

= ‚àíE

d(log(X2)) d

log
X1
X2

= ‚àíE

d

log(X2)

d

log

F f (t, tk‚àí1, tk)

= ‚àíE

d

log

œÑXf
d (t, tk)

d

log

F f (t, tk‚àí1, tk)

= ‚àíE

d

log

Xf
d (t, tk)

d

log

F f (t, tk‚àí1, tk)

= ‚àíœÉxœÉf œÅx,f dt
where œÉx is the volatility of the forward foreign exchange rate Xf
d (t, tk), œÉf is the
volatility of the foreign forward rate F f (t, tk‚àí1, k), and œÅx,f is the correlation
between dW Q
x and dW F
f .
Therefore Eq. (7.2.86) can be written as:
d
X1
X2

= ‚àíX1
X2
{œÉxœÉf œÅx,f } dt + X1
X2

œÉ1 dW Q
1 ‚àíœÉ2 dW Q
2

which means that
d

F f (t, tk‚àí1, tk)

= ‚àíF f (t, tk‚àí1, tk){œÉxœÉf œÅx,f } dt + F f (t, tk‚àí1, tk)

œÉ1 dW Q
1 ‚àíœÉ2 dW Q
2

Comparing the above equation with Eq. (7.2.78):
d

F f (t, tk‚àí1, tk)

= ‚àíF f (t, tk‚àí1, tk){œÉxœÉf œÅx,F } dt + œÉf F f (t, tk‚àí1, tk) dW Q
(7.2.89)
and so Œ± = ‚àíœÉxœÉf œÅx,f .

226
Computational Finance Using C and C#
Quanto Ô¨Çoorlet
The formula to value a quanto Ô¨Çoorlet can be obtained in similar manner to
that used for the quanto caplet.
The value at time t0 of a standard Ô¨Çoorlet which pays at time tk and extends
from time tk‚àí1 to time tk is:
Floorlet(t0) = PœÑDFd(t0, tk)EQk
max

K ‚àíF d
k , 0

(7.2.90)
where P is the principal, K is the strike, œÑ = tk‚àí1‚àítk, Fk is the domestic forward
rate F(t0, tk‚àí1, tk). Equation (7.2.90) can be evaluated using the Black‚ÄìScholes
formula as follows:
Floorlet(t0) = PœÑDFd(t0, tk)

‚àíF d(t0, tk‚àí1, tk)N1(‚àíd1) + KN1(‚àíd2)

(7.2.91)
where the symbols have the same meaning as for the corresponding quanto
caplet.
d1 = log(F d(t0, tk‚àí1, tk)/K) + œÉ 2
d
2 (tk‚àí1 ‚àít0)
œÉd
‚àötk‚àí1 ‚àít0
,
d2 = log(F d(t0, tk‚àí1, tk/K) ‚àíœÉ 2
d
2 (tk‚àí1 ‚àít0)
œÉd
‚àötk‚àí1 ‚àít0
(7.2.92)
In a quanto Ô¨Çoorlet, instead of using the domestic forward rate F d(t0, tk‚àí1, tk),
we use the foreign forward rate F f (t0, tk‚àí1, tk):
QFloorlet(t0)
= PœÑDFd(t0, tk)
√ó

‚àíF f (t0, tk‚àí1, tk) exp

Œ±(tk‚àí1 ‚àít0)

N1(‚àíd1) + KN1(‚àíd2)

(7.2.93)
where P is the principal, K is the strike, œÑ = tk‚àí1 ‚àítk, F f (t0, tk‚àí1, tk) is the
foreign currency forward rate, œÉf is the volatility of F f (t0, tk‚àí1, tk) and
d1 = log(F f (t0, tk‚àí1, tk)/K) + (Œ± +
œÉ 2
f
2 )(tk‚àí1 ‚àít0)
œÉf
‚àötk‚àí1 ‚àít0
d2 = log(F f (t0, tk‚àí1, tk)/K) + (Œ± ‚àí
œÉ 2
f
2 )(tk‚àí1 ‚àít0)
œÉf
‚àötk‚àí1 ‚àít0
and as before Œ± = ‚àíœÉxœÉf œÅx,f .

Other Ô¨Ånancial derivatives
227
Quanto swaplet
A quanto (also known as diff or differential) swaplet is an agreement in which
one party makes Ô¨Çoating rate payments based on the foreign forward rate while
the other makes Ô¨Åxed or Ô¨Çoating payments based on the domestic interest rates.
Here we consider quanto swaplets in which the received Ô¨Çoating leg coupons
(in domestic currency) are computed using foreign forward rates.
The value of a standard swaplet (in which all the currencies are domestic) can
be found by using Eqs. (7.2.90) and (7.2.74) to write:
Caplet(t0) ‚àíFloorlet(t0)
= PœÑDFd(t0, tk)EQk
max

F d
k ‚àíK, 0

‚àímax

K ‚àíF d
k , 0

= PœÑDFd(t0, tk)EQk
F d
k ‚àíK

= PœÑDFd(t0, tk)

EQk
F d
k

‚àíK

= PœÑDFd(t0, tk)

F d
k (t0, tk‚àí1, tk) ‚àíK

(7.2.94)
From Eq. (7.2.94) we can see that Caplet(t0) ‚àíFloorlet(t0) is the value of a
swaplet in which the owner pays the Ô¨Åxed rate K and receives the Ô¨Çoating rate
F d
k (t0, tk‚àí1, tk).
The value of the Ô¨Çoating leg payment can be found by setting K = 0 in
Eq. (7.2.94), and is PœÑDFd(t0, tk)F d
k (t0, tk‚àí1, tk).
The value of the Ô¨Çoating leg payments in a quanto swap can be found in a
similar manner:
QCaplet(t0) ‚àíQFloorlet(t0)
= PœÑDFd(t0, tk)EQk
max

F f
k ‚àíK, 0

‚àímax

K ‚àíF f
k , 0

Substituting from Eqs. (7.2.79) and (7.2.93):
QCaplet(t0) ‚àíQFloorlet(t0)
= PœÑDFd(t0, tk)

F f (t0, tk‚àí1, tk) exp

Œ±(tk‚àí1 ‚àít0)

N1(d1) ‚àíKN1(d2)
‚àíF f (t0, tk‚àí1, tk)N1(‚àíd1) + KN1(‚àíd2)

When K = 0 we have d1 = ‚àû, N1(d1) = 1 and N1(‚àíd1) = 0, which means that
the value of the Ô¨Çoating leg payment is:
FloatLeg(t0) = PœÑDFd(t0, tk)F f (t0, tk‚àí1, tk) exp

Œ±(tk‚àí1 ‚àít0)

(7.2.95)
where as before Œ± = ‚àíœÉxœÉf œÅx,f .
Using Eq. (7.2.95) the value of a quanto swaplet with (pay) Ô¨Åxed domestic
rate and (receive) foreign Ô¨Çoating rate is:
QSwaplet(t0) = PœÑDFd(t0, tk)

F f (t0, tk‚àí1, tk) exp

Œ±(tk‚àí1 ‚àít0)

‚àíK


228
Computational Finance Using C and C#
7.3
Foreign exchange derivatives
Here we consider derivatives based on the exchange rate between a domestic
currency and a foreign currency. We will use the convention that quantities re-
lating to the domestic currency will have the superscript d, while those for the
foreign currency will have the superscript f . The notation for the various ex-
change rates is as follows:
‚Ä¢ Xf
d (t) is the spot value of one unit of foreign currency in domestic currency
at time t
‚Ä¢ Xf
b (t) is the spot value of one unit of foreign currency in base currency at
time t
‚Ä¢ Xd
b(t) is the spot value of one unit of domestic currency in base currency at
time t
‚Ä¢ Xf
d (t, T ) is the (time t) forward value of one unit of foreign currency in do-
mestic currency at time T .
Covered interest arbitrage
If the current spot exchange rate, Xf
d (t), is known then using covered interest
arbitrage it is possible to obtain a value for the future spot exchange rate‚Äîwe
denote this forward exchange rate by Xf
d (t, T ), where T > t.
Let us consider the following two scenarios:
Scenario A
At time t an investor deposits one unit of foreign currency which grows
at the (constant) foreign risk free interest rate rf . By time T the initial
amount will have increased to 1/DFf (t, T ) units of foreign currency, where
DFf (t, T ) = exp(‚àírf (T ‚àít)). The foreign currency is then converted into do-
mestic currency at the time T forward exchange rate Xf
d (t, T ), and thus yields
Xf
d (t, T )/DFf (t, T ) units of domestic currency.
Scenario B
At time t an investor deposits Xf
d (t) units of domestic currency (the sum is
equivalent to one unit of foreign currency), and this grows at the (constant)
domestic risk free interest rate rd. At time T the initial sum will have increased
to Xf
d (t)/DFd(t, T ) units of domestic currency, where DFd(t, T ) = exp(‚àírd(T ‚àí
t)).
For no arbitrage to occur the Ô¨Ånal amount of domestic currency in both sce-
narios must be the same‚Äîwe have assumed that there is no charge in converting
one currency into another.
We thus have:
Xf
d (t, T )
DFf (t, T )
=
Xf
d (t)
DFd(t, T )

Other Ô¨Ånancial derivatives
229
which means that the forward exchange rate, at time T is
Xf
d (t, T ) = Xf
d (t)DFf (t, T )
DFd(t, T )
(7.3.1)
7.3.1
FX forward
An FX forward is a contract to exchange a given amount of domestic currency
for an agreed amount of foreign currency at a future time T . If P f is the amount
(number of units) of foreign currency, and P d is the amount (number of units)
of domestic currency, then the value (in domestic currency) of the FX contract
at time T is:
FXd(T ) = P f Xf
d (T ) ‚àíP d
The value of the contract at time t is thus:
FXd(t) =

P f Xf
d (t, T ) ‚àíP d
DFd(t, T )
where t < T . Substituting for Xf
d (t, T ) from Eq. (7.3.1) then gives:
FXd(t) =

P f Xf
d (t)DFf (t, T )
DFd(t, T )
‚àíP d

DFd(t, T )
which can be re-expressed as
FXd(t) = P f Xf
d (t)DFf (t, T ) ‚àíP dDFd(t, T )
(7.3.2)
The value of this FX forward contract in base currency is thus
FXb(t) =

P f Xf
d (t)DFf (t, T ) ‚àíP dDFd(t, T )

Xd
b
That is,
FXb(t) = P f Xf
b (t)DFf (t, T ) ‚àíP dDFd(t, T )Xd
b(t)
(7.3.3)
where we have used the fact that Xf
d (t)Xd
b(t) = Xf
b (t).
An alternative way of expressing Eq. (7.3.3) is as:
FXb(t) = P f 
Xf
b (t)DFf (t, T ) ‚àíKDFd(t, T )Xd
b(t)

(7.3.4)
where K = P d/P f . In the next section we will see that K, the agreed rate to be
paid for one unit of foreign currency in units of domestic currency, corresponds
to the strike of an FX call option.
7.3.2
European FX option
Foreign exchange options can be priced using the Black‚ÄìScholes formula (Gar-
man and Kohlhagen, 1983). There are three processes involved in foreign ex-

230
Computational Finance Using C and C#
change options and, under the real-world probability measure P, they are:
dBf = rf Bf dt
dXf
d = Xf
d Œº dt + Xf
d œÉ dW P ,
dW P ‚àºN(0, dt)
(7.3.5)
dBd = rdBd dt
where Xf
d is the value of one unit of foreign currency in units of domestic cur-
rency, Bd is the domestic money account where money grows at the (constant)
risk free rate rd, Bf is the foreign money account where money grows at the
(constant) risk free rate rf , and œÉ is the volatility of Xf
d . From a domestic point
of view there are only two assets‚Äîthe money market account Bd, and the value
of the foreign money market account in domestic currency, Bf Xf
d .
From Ito‚Äôs product rule in Chapter 2, and using Eq. (2.6.3) with X1 = Xf
d
and X2 = Bd, we have:
d

Xf
d Bf 
= Xf
d Bf 
rf + Œº

dt + Xf
d Bf œÉ dW P
We will now choose Bd as the numeraire and obtain the process for Bf Xf
d /Bd
using the Ito quotient rule given in Chapter 2. Substituting X1 = Bf Xf
d and
X2 = Bd in Eq. (2.6.8) we obtain:
d
Bf Xf
d
Bd

= Bf Xf
d
Bd

rf ‚àírd + Œº

dt

+ Bf Xf
d
Bd
œÉ dW P
If we choose the probability measure Q such that:
dW P = dW Q ‚àí(rf ‚àírd + Œº)
œÉ
dt
(7.3.6)
then (Bf Xf
d /Bd) is a martingale since
d
Bf Xf
d
Bd

= Bf Xf
d
Bd
œÉ dW Q
Substituting for dW P in Eq. (7.3.5) yields:
dXf
d = Xf
d Œº dt + Xf
d œÉ

dW Q ‚àí(rf ‚àírd + Œº) dt
œÉ

= Xf
d Œº dt ‚àíXf
d

rf ‚àírd + Œº

dt + Xf
d œÉ dW Q
so
dXf
d = Xf
d

rd ‚àírf 
dt + Xf
d œÉ dW Q
(7.3.7)
It can be seen that Eq. (7.3.7) is identical to Eq. (4.4.53) if the following map-
ping is used:
S ‚ÜíXf
d ,
r ‚Üírd,
q ‚Üírf
(7.3.8)
This means that the above mapping allows us to price European FX puts and
calls with the Black‚ÄìScholes formulae given in Eqs. (4.4.55) and (4.4.56).

Other Ô¨Ånancial derivatives
231
FX call
The time t value (in domestic currency) of an FX call to buy one unit of foreign
currency can be found from Eq. (4.4.55) and the substitutions given in (7.3.8).
We have:
Cd(t) = Xf
d (t) exp

‚àírf (T ‚àít)

N(d1) ‚àíK exp

‚àírd(T ‚àít)

N(d2)
(7.3.9)
d1 =
1
œÉ‚àöT ‚àít

log
Xf
d (t)
K

+

rd ‚àírf 
(T ‚àít) + 1
2œÉ 2(T ‚àít)

(7.3.10)
d2 = d1 ‚àíœÉ
‚àö
T ‚àít
(7.3.11)
where K is the strike the rate that has been agreed to pay for one unit of foreign
currency in units of domestic currency, and œÉ is the implied foreign/domestic
currency exchange rate FX option volatility, which may depend on effects such
as time to maturity, volatility smile, etc.
In practice the following, modiÔ¨Åed version of Eq. (7.3.9) is usually used:
Cd(t) = P f 
Xf
d (t) exp

‚àírf (T ‚àít)

N(d1) ‚àíK exp

‚àírd(T ‚àít)

N(d2)

(7.3.12)
where P f is the number of units of foreign currency and all the other symbols
have their previous meanings.
The value Cb(t) of the call option in base currency can be found by using
Cb(t) = Xd
bCd(t). From Eq. (7.3.12) we have:
Cb(t) = P f 
Xf
b (t)N(d1)DFf (t, T ) ‚àíKXd
b(t)N(d2)DFd(t, T )

(7.3.13)
where we have used the fact that Xd
b(t)Xf
d (t)
=
Xf
b (t), DFf (t, T )
=
exp(‚àírf (T ‚àít)) and DFd(t, T ) = exp(‚àírd(T ‚àít)). We can also re-express
the values for d1 given in Eq. (7.3.10) as:
d1 =
1
œÉ‚àöT ‚àít

log
 Xf
b (t)
KXd
b(t)

+ log
DFf (t, T )
DFd(t, T )

+ 1
2œÉ 2(T ‚àít)

(7.3.14)
where we have used the fact that
log

DFf (t, T )

= ‚àírf (T ‚àít),
log

DFd(t, T )

= ‚àírd(T ‚àít)
and
log
Xf
d (t)
K

= log
Xf
b (t)Xd
b(t)
KXd
b(t)

= log
 Xf
b (t)
KXd
b(t)

We note that the term KXd
b is the strike in units of base currency‚Äîthat is, the
amount that has been agreed to pay for one unit of foreign currency in units of
base currency.

232
Computational Finance Using C and C#
In the case when N(d1) = N(d2) = 1 (i.e., there is no uncertainty) Eq. (7.3.13)
becomes:
Cb(t) = P f 
Xf
b (t)DFf (t, T ) ‚àíKXd
b(t)DFd(t, T )

which is the same as that already given in Eq. (7.3.4) for the FX forward.
FX put
The time t value of the corresponding put in units of base currency is:
Pb(t) = P f 
‚àíXf
b (t)DFf (t, T )N(‚àíd1) + KXd
b(t)DFd(t, T )N(‚àíd2)

(7.3.15)
where the symbols have the same meanings as for the FX call.
7.4
Credit derivatives
Credit derivatives take into account the fact that a counterparty may not honor
(for reasons of bankruptcy, etc.) the obligations set out in a given Ô¨Ånancial con-
tract. In order to obtain the time t value of these derivatives it is necessary to
determine the probability that the counterparty (and thus the contract) will sur-
vive until some future time T > t. Here we will denote the survival probability
between times t and T by S(t, T ), and we compute its value from the hazard
rate.
The hazard rate
As previously mentioned the survival probability between times t and T , where
T > t, is denoted by S(t, T ). This means that the probability of default between
times t and T is:
Pdef(t, T ) = 1 ‚àíS(t, T )
and the probability of default, as seen from time t, between times T1 and T2 is:
Pdef(t, T1, T2) = S(t, T1) ‚àíS(t, T2),
T2 > T1
(7.4.1)
The time t discrete hazard rate between times T and T + T , denoted by
H(t, T, T + T ) is deÔ¨Åned by:
H(t, T, T + T ) =
1
T
Pdef(t, T, T + T )
S(t, T + T )
=
1
T
S(t, T ) ‚àíS(t, T + T )
S(t, T + T )
which means that
H(t, T, T + T ) = ‚àíS(t, T + T ) ‚àíS(t, T )
T
1
S(t, T + T )
(7.4.2)

Other Ô¨Ånancial derivatives
233
As T ‚Üí0, H(t, T, T +T ) ‚Üíh(t, T ), where h(t, T ) is termed the continuous
hazard rate between times t and T .
We observe that as T ‚Üí0 Eq. (7.4.2) becomes:
h(t, T ) = ‚àí‚àÇS(t, T )
‚àÇT
1
S(t, T )
(7.4.3)
Now Eq. (7.4.3) can be re-expressed as:
h(t, s) = ‚àí‚àÇS(t, s)
‚àÇs
‚àÇ{ln(S(t, s))}
‚àÇS(t, s)
= ‚àí‚àÇ{ln(S(t, s))}
‚àÇs
(7.4.4)
where s > t, and we have used:
1
S(t, T ) = ‚àí‚àÇ{ln(S(t, T ))}
‚àÇS(t, T )
Integrating Eq. (7.4.4) yields:
 T
s=t
h(t, s) ds = ‚àí
 T
s=t
d

ln

S(t, s)

= ‚àí

ln

S(t, T )

‚àíln

S(t, t)

= ‚àíln

S(t, T )

(7.4.5)
where we have used S(t, t) = 1 and ln(S(t, t)) = 0.
So using Eq. (7.4.5) the survival probability can be expressed as:
S(t, T ) = exp

‚àí
 T
s=t
h(t, s) ds

(7.4.6)
or
S(t, T ) = exp

I(t, T )

(7.4.7)
where I(t, T ) is the cummulative hazard rate from time t to time T .
It is usual to approximate I(t, T ) as follows:
I(t, T ) ‚àºI(t, tk) =
k

i=1
h(ti‚àí1, t)(ti ‚àíti‚àí1)
(7.4.8)
where t0 = t, tk = T , and the following section gives details on how to estimate
h(ti‚àí1, t) from market observables.
One way of representing the hazard rates is to use a hazard rate curve which
is deÔ¨Åned as:

t0, I(t0, ti)

,
i = 0, , . . . , n
(7.4.9)
If we further deÔ¨Åne t0 = t = 0 and tn = T , then Eq. (7.4.9) becomes:
{0, 0},

t1, I(0, t1)

,

t2, I(0, t2)

, . . . ,

tn, I(0, tn)

(7.4.10)
where we have used the fact that I(t0, t0) = I(0, 0) = 0.

234
Computational Finance Using C and C#
Estimating the hazard rate from market observables
From Eq. (7.2.10) we know that the time t forward rate between times T1 and
T2 is given by:
F(t, T1, T2) =
1
T2 ‚àíT1
DF(t, T1)
DF(t, T2) ‚àí1

(7.4.11)
where DF(t, T1) and DF(t, T2) are the prices of the nondefaultable zero coupon
bonds with maturities T1 and T2, respectively.
Letting T1 = T and T2 = T + T we obtain:
F(t, T, T + T ) =
1
T

DF(t, T )
DF(t, T + T ) ‚àí1

(7.4.12)
which can be re-expressed as
F(t, T, T + T )
= ‚àíDF(t, T + T ) ‚àíDF(t, T )
T
1
DF(t, T + T )
(7.4.13)
If T ‚Üí0 then F(t, T, T + T ) ‚Üíf (t, T ) and from Eq. (7.4.13) we obtain:
f (t, T ) = ‚àí‚àÇDF(t, T )
‚àÇT
1
DF(t, T )
= ‚àí‚àÇDF(t, T )
‚àÇT
ln(DF(t, T ))
‚àÇDF(t, T )
(7.4.14)
Using Eq. (7.4.14) the instantaneous forward rate computed using nondefault-
able zero coupon bond prices is:
f (t, T ) = ‚àíln(DF(t, T ))
‚àÇT
(7.4.15)
and the corresponding instantaneous forward rate computed from defaultable
zero coupon bond prices is:
¬Øf (t, T ) = ‚àíln(DF(t, T ))
‚àÇT
(7.4.16)
Taking the survival probability S(t, T ) to be the ratio of the prices of defaultable
and nondefaultable zero coupon bonds:
S(t, T ) = DF(t, T )
DF(t, T )
(7.4.17)
Now from Eqs. (7.4.15) and (7.4.16) we have:
¬Øf (t, T ) ‚àíf (t, T ) = ‚àíln(DF(t, T ) ‚àíDF(t, T ))
‚àÇT
= ‚àí‚àÇ
‚àÇT ln
DF(t, T )
DF(t, T )

(7.4.18)

Other Ô¨Ånancial derivatives
235
so from Eqs. (7.4.18) and (7.4.17):
¬Øf (t, T ) ‚àíf (t, T ) = ‚àí‚àÇ
‚àÇT ln

S(t, T )

(7.4.19)
Combining Eqs. (7.4.19) and (7.4.4) we have:
h(t, T ) = ¬Øf (t, T ) ‚àíf (t, T )
(7.4.20)
This means that we can compute the hazard rate h(t, T ) by taking the differ-
ence between the instantaneous forward rates computed using defaultable and
nondefaultable zero coupon bonds.
7.4.1
Defaultable bond
For a defaultable bond we need to take into account the fact that the bond issuer
may default, that is cease to make the bond coupon payments.
The time t value of a defaultable bond is:

B(t) = PDF(t, tm)
principal
+
m

j=1
CjDF(t, tj)
coupons
+ PR
m

j=1
DF(t, tj)

S(t, tj‚àí1) ‚àíS(t, tj)

recovery value
where tm is the maturity of the bond, P is the principal, Cj is the value of
the jth coupon, R is the recovery rate, S(t, tj) is the probability that the bond
will survive until time tj, and the zero coupon defaultable bond prices are de-
Ô¨Åned by DF(t, tm) = S(t, tm)DF(t, tm) and DF(t, tj) = DF(t, tj)S(t, tj). The term
{S(t, tj‚àí1) ‚àíS(t, tj)} is the probability that the bond will default between times
tj‚àí1 and tj.
7.4.2
Credit default swap
A Credit Default Swap (CDS) is a contract between two counterparties in which
one (say A) makes periodic Ô¨Åxed payments to the other (say B) in order to obtain
protection on the default of a reference credit. In the event of default, B pays
A the default payment of 1 ‚àíR, where R is the recovery rate, and the contract
ceases.
The time t value of the credit default swap to A, the purchaser of the insur-
ance, is:
CDS(t) = ‚àí
m

j=1
CjDF(t, tj)
coupons
+ P(1 ‚àíR)
m

j=1
DF(t, tj)

S(t, tj‚àí1) ‚àíS(t, tj)

recovery value

236
Computational Finance Using C and C#
where the symbols have the same meanings as for the defaultable bond.
7.4.3
Total return swap
A Total Return Swap (TRS) is a synthetic replication of the return of a reference
asset (bond) B. The receiver of the TRS receives the coupon payments of the
reference asset during the life of the swap in return for making periodic coupon
payments at the risk-free Ô¨Çoating rate plus an agreed margin. In the event of
default, the receiver makes a default payment to the payer equal to the agreed
initial price of the reference asset less the price at default, and the transaction
terminates. If there is no default then the difference between the initial asset
(bond) price B0 and the price at maturity B(tm) is settled between the payer and
the receiver, with the receiver paying (receiving) if the asset (bond) is worth less
(more) at maturity. The maturity of the reference asset (bond) may be longer
than the maturity tm of the swap.
To the receiver of the reference asset coupons a TRS has value TRSr, which is
given by:
TRSr = total bond return ‚àítotal Ô¨Çoating coupon payments of the swap
where total bond return is given by:
total bond return = total bond Ô¨Åxed coupons over the duration of the
TRS+increase in the bond value at maturity of the TRS‚àídefault payment,
if the bond defaults over the duration of the TRS
The value of TRSr at time t is:
TRSr(t)
= C
tm

tj =t1
DF(t, tj)
Ô¨Åxed reference bond payments
+ P
B(tm) ‚àíB0
B0

DF(t, tm)
increase in value of reference bond
‚àí
tm

tj =t1
CjDF(t, tj)
Ô¨Çoating payments of swap
at LIBOR + margin
‚àíP(1 ‚àíR)
tm

tj =t1
DF(t, tj)
√ó

S(t, tj‚àí1) ‚àíS(t, tj)

bond default payments
and the reference bond satisÔ¨Åes:
B(tR) = 1
B(tm) = DF(tm, tR)|t + C
tR

tj =tm
DF(tm, tj)|t

Other Ô¨Ånancial derivatives
237
+ R
tR

tj =tm
DF(tm, tj)|t

S(t, tj‚àí1) ‚àíS(tm, tj)

All symbols already deÔ¨Åned in this chapter have their previous meanings. In
addition,
P ‚Äì the swap principal
C ‚Äì the Ô¨Åxed coupon of the reference bond
tm ‚Äì the swap maturity
tR ‚Äì the maturity of the reference bond B
B0 ‚Äì the initial price of the reference bond
B(tm) ‚Äì the Ô¨Ånal price of the reference bond (at swap maturity)
Cj ‚Äì the Ô¨Çoating coupon payment at time tj. It is computed as:
Cj = P

F(t, tj‚àí1, tj) + marginTRS
{tj ‚àítj‚àí1}
DF(t1, t2)|t ‚Äì the discount factor between times t1 and t2 (as seen from time t)
is:
DF(t1, t2)|t = D(t, t2)
D(t, t1)
DF(t1, t2)|t ‚Äì the defaultable discount factor between times t1 and t2 (as seen
from time t) is:
DF(t1, t2)|t = DF(t, t2)
DF(t, t1)
= DF(t, t2)
DF(t, t1)
S(t, t2)
S(t, t1)
DF(t, t1) ‚Äì the defaultable discount factor between times t and t1 is:
DF(t, t1) = DF(t, t1)S(t, t1)
7.5
Equity derivatives
7.5.1
Total return swap
An equity total return swap consists of an equity leg (whose coupons are de-
termined by the change in value of the equity) and a Ô¨Çoating leg which pays
according to the forwards of the Ô¨Çoating interest rate.
Here we ignore the effect of equity dividends and also assume that the cur-
rencies for both the Ô¨Çoating and equity legs of the swap are the same.
Equity leg
Let the equity leg be speciÔ¨Åed by coupon payments at times tk, k = 1, . . . , Ne,
where œÑe = tk ‚àítk‚àí1. If, at time t the next coupon payment occurs at ti then the
value of the equity leg is:

238
Computational Finance Using C and C#
Ve(t) =

S(t)
DF(t, ti) ‚àíL(ti‚àí1)

DF(t, ti)
+
Ne

k=i+1

S(t)
DF(t, tk) ‚àí
S(t)
DF(t, tk‚àí1)

DF(t, tk)
(7.5.1)
where S(t) is the equity value at current time t, L(ti‚àí1) is the reset value of
the equity at time ti‚àí1, and DF(t, tk) is the discount factor between times t and
tk, tk > t. It can be seen that the value of the equity S(t1) at time t1 > t is
obtained by inÔ¨Çating the current value, S(t) by the reciprocal of the discount
factor, DF(t, t1); that is, S(t1) = S(t)/DF(t, t1).
Floating leg
Let the Ô¨Çoating leg have coupon payments at times tm, m = 1, . . . , Nf , where
œÑf = tm ‚àítm‚àí1. If the next coupon is at time tj, then the value of the Ô¨Çoating leg
is:
Vf (t) = L(tj‚àí1)

R(tj‚àí1) + Œ¶

œÑf DF(t, tj)
+
Nf

m=j+1
S(t)
DF(t, tm‚àí1)

F(t, tm‚àí1, tm) + Œ¶

œÑf DF(t, tm)
(7.5.2)
where Œ¶ is the margin added to the forward rate used to compute coupons,
F(t, tm‚àí1, tm) is the time t forward rate between times tm‚àí1 and tm, and R(tj‚àí1)
is the reset rate that is used between times tj‚àí1 and tj to compute the coupon
payment at time tj.
Payer equity total return swap
The owner of a payer equity TRS pays the equity leg coupons, and thus at time
t the swap has value:
ETRSp(t) = Vf (t) ‚àíVe(t)
(7.5.3)
The owner of a receiver equity TRS receives the equity leg coupons, and the
value of the swap is:
ETRSr(t) = ‚àíVf (t) + Ve(t)
(7.5.4)
We will now compute an expression for the value of a payer equity swap. Since
F(t, tm‚àí1, tm) =
1
tm ‚àítm‚àí1
DF(t, tm‚àí1)
DF(t, tm)
‚àí1

we have:
œÑf F(t, tm‚àí1, tm) = DF(t, tm‚àí1)
DF(t, tm)
‚àí1
(7.5.5)
Substituting Eq. (7.5.5) into Eq. (7.5.2) and using Eq. (7.5.3) we obtain:

Other Ô¨Ånancial derivatives
239
ETRSp(t) =
Nf

m=j+1
S(t)DF(t, tm)
DF(t, tm‚àí1)
DF(t, tm‚àí1)
DF(t, tm)
‚àí1

+
Nf

m=j+1
S(t)
DF(t, tm‚àí1)Œ¶œÑf DF(t, tm)
+ L(tj‚àí1)(R(tj‚àí1) + Œ¶)œÑf DF(t, tj)
‚àí
Ne

k=i+1
S(t)

1 ‚àí
DF(t, tk)
DF(t, tk‚àí1)

‚àí

S(t)
DF(t, ti) ‚àíL(ti‚àí1)

DF(t, ti)
(7.5.6)
If Ne = Nf = N, and œÑe = œÑf = œÑ, then all the equity and Ô¨Çoat leg payments
coincide and Eq. (7.5.6) simpliÔ¨Åes to:
ETRSp(t) = S(t)
N

k=j+1
DF(t, tk)
DF(t, tk‚àí1)Œ¶œÑDF(t, tk)
+ L(R + Œ¶)œÑDF(t, tj) ‚àí

S(t)
DF(t, tj) ‚àíL

DF(t, tj)
(7.5.7)
Thus, if the spread Œ¶ is zero the value of the payer equity TRS is:
ETRSp(t) = L(tj‚àí1)R(tj‚àí1)œÑDF(t, tj)
‚àí

S(t)
DF(t, tj) ‚àíL(tj‚àí1)

DF(t, tj)
(7.5.8)
In these circumstances the value of the equity TRS at time t only depends on the
current swaplet, which extends from tj‚àí1 to tj, where tj‚àí1 < t < tj.
Equity swap
A special case of an equity TRS is an equity swap. Here one party (say A) pays
the total returns on a given equity and receives (from party B) the returns on
another equity, together with the interest on the net difference of the last reset
notional of the two equity assets. An equity swap, ESWP, can be constructed
from a structured deal consisting of a long position in one equity TRS and a
short position in another equity TRS, with the same coupon payment dates and
currency. If the individual equity TRS deals are denoted by ETRS1
p and ETRS2
p,
then the value of the equity swap at time t is:
ESWP(t) = ETRS1
p(t) ‚àíETRS2
p(t)
(7.5.9)
Substituting Eq. (7.5.8) into Eq. (7.5.9) we have:

240
Computational Finance Using C and C#
ESWP(t) = L1(tj‚àí1)R(tj‚àí1)œÑDF(t, tj) ‚àí

S1(t)
DF(t, tj) ‚àíL1(tj‚àí1)

DF(t, tj)
‚àí

L2(tj‚àí1)R(tj‚àí1)œÑDF(t, tj)
‚àí

S2(t)
DF(t, tj) ‚àíL2(tj‚àí1)

DF(t, tj)

so the value of the equity swap to party A is:
ESWP(t) = ‚àí

S1(t)
DF(t, tj) ‚àíL1(tj‚àí1)

DF(t, tj)
equity 1 returns paid by A
+

L1(tj‚àí1) ‚àíL2(tj‚àí1)

R(tj‚àí1)œÑDF(t, tj)
interest on difference of reset notionals paid by B
+

S2(t)
DF(t, tj) ‚àíL2(tj‚àí1)

DF(t, tj)
equity 2 returns paid by B
7.5.2
Equity quantos
The Black‚ÄìScholes equation can also be used to price equity quanto options
(Reiner (1992)). We have the following processes:
dSf = ŒºsSf dt + œÉsSf dW P
s
dXf
d = ŒºxXf
d dt + œÉxXf
d dW P
x
(7.5.10)
dBf = rf Bf dt
dBd = rdBd dt
Here Sf is the price (in foreign currency units) of the foreign stock. Bd is the
domestic money market account where money grows at the (constant) risk free
interest rate rd. Bf is the foreign money market account where money grows at
the (constant) risk free interest rate rf . Xf
d is the foreign exchange rate, that is
the value of one unit of foreign currency in units of domestic currency.
The tradables for the domestic investor are the foreign money market account
priced in domestic currency units (that is, Xf
d Bf ) and the foreign stock priced
in domestic currency units, Xf
d Sf .
We know from Eq. (4.4.30) that there is a probability measure (the risk neu-
tral measure) Q under which the relative price of domestic tradables such as
equities are martingales. Also we established that under Q the process followed
by these tradables is GBM with constant drift rd. So the process for the domestic
equity Sd is:
dSd = Sdrd dt + œÉSd dW Q
(7.5.11)

Other Ô¨Ånancial derivatives
241
Similarly the process followed by the price of a foreign equity Sf under the
foreign risk neutral measure F is:
dSf = Sf rf dt + œÉsSf dW F
s
(7.5.12)
However, the process followed by the price of a foreign equity Sf under the
domestic risk neutal measure Q is:
dSf = Sf 
rf + Œ±

dt + œÉsSf dW Q
s
(7.5.13)
where Œ± (the quanto adjustment) is to be determined.
We will now derive the value for Œ±, and then use this to price both quanto
forwards and quanto options.
Determining the quanto adjustment, Œ±
Since Xf
d Bf and Xf
d Sf are domestic tradables it means that the relative prices
Xf
d Bf /Bd and Xf
d Sf /Bd are also martingales under the probability measure Q
Now since Xf
d Bf /Bd is a martingale,
d
Xf
d Bf
Bd

= œÉx
Xf
d Bf
Bd
dW Q
x
(7.5.14)
We will start by writing Xf
d Bf /Bd as (Sf /Bf )(Xf
d Bf /Bd). Using the Ito
product rule we have:
d
 Sf
Bf
Xf
d Bf
Bd

= Xf
d Bf
Bd
d
 Sf
Bf

+ Sf
Bf d
Xf
d Bf
Bd

+ E

d
 Sf
Bf

d
Xf
d Bf
Bd

(7.5.15)
Substituting for d(Xf
d Bf /Bd) from Eq. (7.5.14) into Eq. (7.5.15) gives:
d
 Sf
Bf
Xf
d Bf
Bd

= Xf
d Bf
Bd
d
 Sf
Bf

+ œÉx
Sf
Bf
Xf
d Bf
Bd
dW Q
x
+ E

d
 Sf
Bf

d
Xf
d Bd
Bf

(7.5.16)
Using the Ito quotient rule (see Section 1.7.2) with one source of randomness,
Eqs. (7.5.13) and (7.5.10) yield:
d
 Sf
Bf

= Sf
Bf Œ± dt + Sf
Bf œÉs dW Q
s
(7.5.17)
We now consider the term E[d(Sf /Bf ) d(Xf
d Bf /Bd)] in Eq. (7.5.16):

242
Computational Finance Using C and C#
E

d
 Sf
Bf

d
Xf
d Bf
Bd

= E
 Sf
Bf

Œ± dt + Sf
Bf œÉs dW Q
s

œÉx
Xf
d Bf
Bd
dW Q
x

= Xf
d Bf
Bd
Sf
Bf Œ± dt œÉxE

dW Q
x

+ Sf
Bf
Xf
d Bf
Bd
œÉsœÉxE

dW Q
x dW Q
s

Since E[dW Q
x ] = 0 and E[dW Q
x dW Q
s ] = œÅxs dt
E

d
 Sf
Bf

d
Xf
d Bd
Bf

= Sf
Bf
Xf
d Bf
Bd
œÉsœÉxœÅxs dt
(7.5.18)
Using the values of d(Sf /Bf ) and E[d(Sf /Bf ) d(Xf
d Bd/Bf )] from Eqs. (7.5.17)
and (7.5.18) in Eq. (7.5.16) results in:
d
 Sf
Bf
Xf
d Bf
Bd

= Xf
d Bf
Bd
Sf
Bf Œ± dt + Xf
d Bf
Bd
Sf
Bf œÉsœÉx dW Q
s
+ œÉx
Xf
d Sf
Bd
dW Q
x + Sf
Bf
Xf
d Bf
Bd
œÉsœÉxœÅxs dt
Rearranging we obtain:
d
Xf
d Sf
Bd

= Xf
d Sf
Bd
{Œ± + œÉsœÉxœÅxs} dt
+ Xf
d Sf
Bd

œÉs dW Q
s + œÉx dW Q
x

(7.5.19)
We already mentioned that Xf
d Bf /Bd is a martingale under probability measure
Q so the drift term in Eq. (7.5.19) must be zero. This means that:
Œ± = ‚àíœÉsœÉxœÅxs
where œÉs is volatility of the foreign equity, œÉx is volatility of the foreign exchange
rate and œÅxs is the correlation between dWs and dWx.
Equation (7.5.13) can then be written as:
dSf =

rf ‚àíœÉsœÉxœÅxs

Sf dt + œÉsSf dW Q
s
(7.5.20)
Equity quanto forward
The (time t) value of a domestic equity forward contract with maturity T is:
F(t) = DFd(t, T )

Sd(t, T ) ‚àíKd
where Kd is the strike in domestic currency and Sd(t, T ) is the domestic forward
price.
To value an equity quanto forward contract we need to know the forward
price of the foreign equity Sf .

Other Ô¨Ånancial derivatives
243
It can be seen from Eqs. (4.4.31), (4.4.32) and (7.5.20) that this forward price
is:
Sf (t, T ) = Sf (t) exp

rf ‚àíœÉxœÉsœÅxs

(T ‚àít)

(7.5.21)
where Sf (t) is the current price of the foreign equity and T is the maturity of
the forward.
In an equity quanto forward the payoff is in foreign currency but it is con-
verted to domestic currency at a predetermined exchange rate (which we denote
here by X). The value equity quanto forward is thus:
QF(t) = DFd(t, T )

Sf (t, T ) ‚àíKf 
X
where X is the prespeciÔ¨Åed exchange rate, Kf is the strike in units of foreign
currency, and Sf (t, T ) is the foreign forward equity price.
Equity quanto option
In Chapter 4 Eqs. (4.4.58) and (4.4.59) expressed the value of vanilla European
put and call options as:
Call(t) = exp

‚àírd(T ‚àít)

Sd(t, T )N1(d1) ‚àíEN1(d2)

Put(t) = exp

‚àírd(T ‚àít)

‚àíSd(t, T )N1(‚àíd1) + EN1(‚àíd2)

d1 = log(Sd(t, T )/Ed) + (œÉ 2/2)œÑ
œÉ‚àö(T ‚àít)
d2 = log(Sd(t, T )/Ed) ‚àí(œÉ 2/2)(T ‚àít)
œÉ‚àö(T ‚àít)
where we have used superscripts to denote the domestic currency, and the cur-
rent equity forward price with maturity T is:
Sd(t, T ) = Sd(t) exp

rd(T ‚àít)

,
t ‚©ΩT
The value of an equity quanto option can be found by substituting Sf for Sd
in the above expression. We obtain:
QCall(t) = exp

‚àírd(T ‚àít)

Sf (t, T )N1(d1) ‚àíEf N1(d2)

X
QPut(t) = exp

‚àírd(T ‚àít)

‚àíSf (t, T )N1(‚àíd1) + Ef N1(‚àíd2)

X
d1 = log(Sf (t, T )/Ef ) + (œÉ 2
s /2)œÑ
œÉs
‚àö(T ‚àít)
d2 = log(Sf (t, T )/Ef ) ‚àí(œÉ 2
s /2)(T ‚àít)
œÉs
‚àö(T ‚àít)
where Ef is the strike in foreign currency units, Sf (t, T ) is the foreign equity
forward price (obtained from Eq. (7.5.21)) and X is the prespeciÔ¨Åed exchange
rate (number of units of domestic currency per foreign currency unit).

blank
left
intentionally
page
This

8 C# portfolio pricing application
8.1
Introduction
This section provides details concerning a C# application, created using Mi-
crosoft Visual Studio 2005 (version 2.0), which values the deals contained in a
set of user speciÔ¨Åed portfolios. It has been included to illustrate how the pricing
functions discussed in the previous sections of the book can be incorporated
into the kind of software that may be found in a bank, Ô¨Ånancial institution, or
educational establishment. Here we provide code excerpts from the application;
however, additional source code is available from the publisher‚Äôs website.
The main features of this application are as follows:
‚Ä¢ User deÔ¨Åned portfolios of deals can be valued without the need to compile
either C or C# programs. This means that the application is easy to use and is
accessible to those who may possess business or Ô¨Ånancial knowledge, but do
not have the technical skills required to write computer code.
‚Ä¢ This application only deals with equity, foreign exchange derivatives‚Äîthe ex-
ception is the inclusion of an interest rate forward rate trade. However, the
software can be easily extended to include new deal types.
‚Ä¢ All input/output to the application is by means of text Ô¨Åles which can be easily
edited.
‚Ä¢ The software is modular and consists of a main C# program which calls
both a compiled C# DealLibrary and also a compiled C Analytics_
MathLib. It should be mentioned that in many cases the C# deal class calls
the C pricing function with reasonable values for various parameters. For
example, the number of time steps in a binomial lattice is set internally and
cannot be altered by the user. Also the initial random seed for all Monte
Carlo simulation is set internally to the same number (111) and this cannot
be changed by the user.
We will now provide a brief overview of each component part of the applica-
tion; more detail will be given later when speciÔ¨Åc deal classes are described.
8.1.1
The C# code
The application is deÔ¨Åned by the C# solution PortfolioValuer.sln, and
the projects DealLibrary.csproj and PortfolioValuer.csproj.

246
Computational Finance Using C and C#
The project PortfolioValuer.csproj is the driver for the application
and contains the C# code given in Code excerpt 8.1. The user interface is simply
a windows form with a button to start the application, and if required this could
easily be customized by the reader. Once the application has been started, it Ô¨Årst
loads a market data Ô¨Åle and then reads a portfolio conÔ¨Åguration Ô¨Åle to determine
which portfolios are to be valued. Valuation then proceeds for all the deals
contained in the portfolio Ô¨Åles and the results are written to the appropriate
portfolio results Ô¨Åle.
The project DealLibrary.csproj is concerned with the valuation of the
available trades in the application. A separate C# deal class, derived from a
single abstract base class BaseDeal, is provided for each trade type. The
BaseDeal class provides abstract methods such as Price() and Vali-
date(), which need to be implemented in deal classes. We will be primarily
concerned with the method Price(), which is used to return the current value
of a trade. Deal valuation may either be performed completely in C# code or
by calling appropriate C routines in the Analytics_MathLib dynamic link
library‚Äîthis contains C pricing functions discussed in previous sections of the
book and also utilities (such as random number generators), etc.
Code excerpt 8.2 provides the declaration of BaseDeal and illustrates how
the deal class EquityOptionDeal implements the necessary methods; the
complete C# code for a range of deals is provided later.
It can be seen that the deal class needs to specify the attributes which it will
present to the user, and in addition access market data such as the equity price.
8.1.2
The text Ô¨Åles
The application is driven by a portfolio conÔ¨Åguration Ô¨Åle and also a number of
portfolio deÔ¨Ånition Ô¨Åles, each of which is in plain text format and thus can easily
be edited by the user. The portfolio conÔ¨Åguration Ô¨Åle speciÔ¨Åes the names of the
portfolio Ô¨Åles that are to be valued, and each portfolio deÔ¨Ånition Ô¨Åle provides
the details of the trades contained in a given portfolio. In addition there is a
market data Ô¨Åle (also in text format) which provides the market data required
to value the trades.
A portfolio conÔ¨Åguration Ô¨Åle and also two portfolio deÔ¨Ånition Ô¨Åles are given
in Exhibit 8.1. It can be seen that comments may be included in the portfolio
deÔ¨Ånition Ô¨Åles; these are useful for documenting the deals contained in the port-
folio. It is also possible to ignore a single trade by using a // at the beginning
of a line. Complete sections of a portfolio deÔ¨Ånition Ô¨Åle can also be ignored by
using the C style comment syntax /**/.
The syntax of each deal entry in the Portfolio DeÔ¨Ånition Ô¨Åle is as follows:
Trade=<DealClass>,Reference=<Descriptive Text>,DealClassParam1=<Value1>, . . . ,_
DealClassParamN=<ValueN>
Each deal line must begin with an assignment to the Trade attribute using
the syntax Trade=<DealClass>, where <DealClass> is the name of the
C# class used to represent the given deal‚Äîi.e., EquityOptionDeal for an

C# portfolio pricing application
247
namespace PortfolioValuer
{
public partial class Form1 : Form
{
public Form1()
{
InitializeComponent();
}
private void button1_Click(object sender, EventArgs e)
{
StreamReader sr_config;
StreamReader sr_tests;
StreamWriter sw;
MessageBox.Show("Computing value of portfolios");
string AppDir = Path.GetDirectoryName(Application.ExecutablePath);
string config_filename = AppDir + "\\Portfolios.txt";
string MD_filename = AppDir + "\\MarketData.txt";
try {
BaseDeal.LoadMarketData(MD_filename);
// Load and execute the specified tests
sr_config = new StreamReader(config_filename);
string assembly_name = AppDir + "\\DealLibrary.dll";
Assembly Assm = Assembly.LoadFrom(assembly_name);
Type[] LoadedTypes = Assm.GetTypes();
string test_file;
int block_comment_depth = 0;
double port_val = 0.0;
string BaseCurrency = BaseDeal.GetBaseCurrency();
while ((test_file = sr_config.ReadLine()) != null)
{
sr_tests = new StreamReader(test_file + ".txt");
string current_test;
string sdate = DateTime.Now.ToString();
string results_filename = AppDir + "\\" + test_file + "results.txt";
bool append = false;
sw = new StreamWriter(results_filename, append, Encoding.ASCII);
sw.WriteLine("=============================");
sw.WriteLine(test_file + " in units of " + BaseCurrency);
sw.WriteLine(test_file +"
:" +sdate);
sw.WriteLine("=============================");
port_val = 0.0;
block_comment_depth = 0;
while ((current_test = sr_tests.ReadLine()) != null) {
block_comment_depth += ((current_test.Length > 1)_
&& (current_test.Substring(0,2) == "/*")) ? 1:0;
block_comment_depth -= ((current_test.Length > 1)_
&& (current_test.Substring(0, 2) == "*/")) ? 1 : 0;
.
.
.
try
{
deal_value = ac1.Price(); // return the value of the deal
}
catch (Exception ex)
{
sr_config.Close();
sw.Close();
sr_tests.Close();
throw new Exception(ex.Message);
}
port_val +=
deal_value; // add to the value to the portfolio
string str_deal_val = deal_value.ToString(" 0.0000;-0.0000; 0.0000");
sw.WriteLine(str_deal_val + "=" + ac1.Reference+","+ac1.Name());
}
} // end of tests for a given portfolio
Code excerpt 8.1 The main driver for the C# portfolio valuer application. After reading
the market data Ô¨Åle, it prices the trades contained in the portfolio deÔ¨Ånition Ô¨Åles. The
total value of each portfolio is also computed.

248
Computational Finance Using C and C#
public abstract class BaseDeal
// The declaration for BaseDeal
{
public abstract string Name();
public abstract double Price();
protected abstract void Validate();
public string Reference { get { return Reference_; } set { Reference_ = value; } }
protected string Reference_;
public string BaseCurrency {get { return MarketDataDictionaries.GetBaseCurrency(); }}
}
public class EquityOptionDeal: BaseDeal
// The declaration for EquityOptionDeal
{
public string Equity { get { return EquityName_; } set { EquityName_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
.
.
.
public override string Name()
// implement method Name()
{
return "Equity Option";
}
public override double Price()
// implement method Price()
{
Validate();
double val=0.0;
double[] greeks = new double[6];
double s0 = 0.0;
double fx_spot = 0.0;
try
{
s0 = MarketDataDictionaries.EquityTable[EquityName_].Spot;_
// get current equity price
Currency_ = MarketDataDictionaries.EquityTable[EquityName_].Currency;_
// get equity volatility (assumed constant)
DividendYield_ = MarketDataDictionaries.EquityTable[EquityName_].DivYield;_
// get equity dividend yield
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for " + EquityName_);
}
.
.
.
val *= fx_spot * NumberOfUnits_; // return value in base currency
return val;
}
protected override void Validate()
// implelement method Validate()
{
Pre_string_ = Name() + "
(" + Reference_ +")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
.
.
.
}
Code excerpt 8.2 C# code showing the declaration of class BaseDeal and illustrating the
implementation of methods Price(), Validate(), and Name().

C# portfolio pricing application
249
// write the portfolio value
sw.WriteLine("========================");
string str_port_val = port_val.ToString(" 0.00;-0.00; 0.00");
sw.WriteLine("TOTAL VALUE = " + str_port_val + " " + BaseCurrency + "
");
sw.WriteLine("=========================");
sw.Close();
sr_tests.Close();
}
MessageBox.Show("Have completed computing portfolio values");
sr_config.Close();
// Clear the dictionaries
BaseDeal.CurrencyTable.Clear();
BaseDeal.EquityTable.Clear();
BaseDeal.BondTable.Clear();
BaseDeal.CorrelationTable.Clear();
}
}
catch (Exception ex)
{
MessageBox.Show("Computation aborted : exception : " + ex.Message);
}
}
}
Code excerpt 8.2 (Continued).
equity option. The other deal attributes are the public properties of Deal-
Class and can be in any order. Deal valuation proceeds by Ô¨Årst construct-
ing an empty class object of type DealClass. The application then con-
verts the string representation of the deal attribute values to the types ex-
pected by the DealClass, and assignment to the deal object occurs. Once
the deal object has been populated with the required trade data, the deal‚Äôs
Price() method is run. This retrieves the required market data, computes
the deal value, and returns this to the application for output to the portfolio
results Ô¨Åle. All deals have the Reference attribute which is used for the pur-
poses of identiÔ¨Åcation. The deal reference is a description (or alphanumeric
code) assigned to the trade, for instance Reference=EQ:LaserComm-1001
or Reference=Tech-10008_Generic. The portfolio results Ô¨Åles contain
both the value and reference for each deal which has been valued.
The portfolio driver Ô¨Åle
EQ-Investments
Broad-Investments
Portfolio deÔ¨Ånition Ô¨Åle: EQ-investments
// EQ-Investments : Only contains equities
//=========================================
Trade=EquityOptionDeal,Reference=EQ:LaserComm-1001,Equity=LaserComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.5,OptionType=Put,ExerciseStyle=European
Trade=EquityOptionDeal,Reference=EQ:WebComm-1004A,Equity=WebComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.0,OptionType=Call,ExerciseStyle=European
Trade=EquityOptionDeal,Reference=EQ:LaserComm-1004,Equity=LaserComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.0,OptionType=Call,ExerciseStyle=American

250
Computational Finance Using C and C#
Trade=TwoEquityOptionDeal,Reference=EQ:CompuKalc-1005,Equity1=Mobile-Tech,_
Equity2=CompuKalc,Volatility1=0.2,Volatility2=0.2,RiskFreeRate=0.1,Strike=44.0,_
Time_To_Expiry=0.8,OptionType=Call,MinMax=Minimum,ExerciseStyle=European
Trade=TwoEquityOptionDeal,Reference=EQ:MobileTech|CompuKalc-1006,Equity1=Mobile-Tech,_
Equity2=CompuKalc,Volatility1=0.2,Volatility2=0.2,RiskFreeRate=0.1,Strike=94.0,_
Time_To_Expiry=0.8,OptionType=Call,MinMax=Maximum,ExerciseStyle=European
Trade=ThreeEquityOptionDeal,Reference=Tech-10001,Equity1=LaserComm,Equity2=TelComm,_
Equity3=SmartWeb,Volatility1=0.2,Volatility2=0.2,Volatility3=0.2,NumberOfUnits=100,_
Strike=100.0,Time_To_Expiry=1.0,OptionType=Put,MinMax=Maximum,MonteCarlo=No
Trade=GenericEquityBasketOptionDeal,Reference=Tech-10008_Generic,Volatilities=0.2%0.2%0.2,_
Equities=LaserComm%TelComm%SmartWeb,NumberOfUnits=100,_
Strike=100.0,Time_To_Expiry=1.0,OptionType=Call,MinMax=Maximum,MonteCarlo=Yes
Trade=FourEquityOptionDeal,Reference=Drinks-20001,Equity1=Drinks-4U,Equity2=Beverage-Ltd,_
Equity3=H2O-Ltd,Equity4=Fine-Wines-Ltd,Volatility1=0.2,Volatility2=0.2,Volatility3=0.2,_
Volatility4=0.2,NumberOfUnits=100,Strike=100.0,_
Time_To_Expiry=1.0,OptionType=Call,MinMax=Maximum,MonteCarlo=No
Trade=DownOutEquityOptionDeal,Reference=JPCA_111,Equity=H2O-Ltd,Volatility=0.2,Strike=100.0,_
Time_To_Expiry=1.0,Barrier_Level=90.0,OptionType=Call
Trade=DoubleKnockOutCallEquityOptionDeal,Reference=JPCAPP_115,Equity=LaserComm,Volatility=0.2,
Strike=100.0,Time_To_Expiry=1.0,Lower_Barrier_Level=90.0,Upper_Barrier_Level=340.0
Portfolio deÔ¨Ånition Ô¨Åle: broad-investments
In the C derivative pricing functions developed in the earlier part of this book,
all the deal information such as asset price, risk free interest rate, etc. was passed
explicitly to the pricing function.
For instance, let us consider the pricing of the simple
EquityOption,
Reference=EQ:WebComm-1004A, which is speciÔ¨Åed in Exhibit 8.1. The en-
try (which we will refer to as E1 in the portfolio deÔ¨Ånition Ô¨Åle EQ-investments)
is:
Trade=EquityOptionDeal,Reference=EQ:WebComm-1004A,Equity=WebComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.0,OptionType=Call,ExerciseStyle=European
The reason for the inclusion of the Volatility attribute will be discussed
later.
If we explicitly passed all the information required by the underlying C func-
tion black_scholes then the form of the required entry (referred to here as
E2) would be:
Trade=EquityOptionDeal,Reference=EQ:WebComm-1004A,Equity=WebComm,Volatility=0.1,_
Strike=95.0,Time_To_Expiry=1.5,OptionType=Put,ExerciseStyle=European,EquitySpot=100,_
FXEquityCurrency=0.5565,RiskFreeRate=0.1,DividendYield=0.05
The reason that E1 does not require the extra four deal attributes
EquitySpot=100,FXEquityCurrency=0.5565,RiskFreeRate=0.1,
DividendYield=0.05 is that these are stored in a market data dictionar-
ies object and are accessed by the C# class EquityOptionDeal before the C
function black_scholes is called.
The market data dictionaries are populated as soon as the application starts.
Exhibit 8.2 shows an example market data Ô¨Åle. This is a plain text Ô¨Åle, and pro-
vides a common repository for the market parameters that are required by the

C# portfolio pricing application
251
// Broad-Investments : Contains equity, FX and IR products
//=========================================================
// Example FX deal Foreign currency = GBP Domestic Currency = USD, Strike = 1.5,
Settlement = 4.0 years
// Note: The Strike is the number of units of domestic currency that have been agreed to be
paid for one unit
// of foreign currency.
Trade=FXForwardDeal,Reference=FX-5001,ForeignAmount=100,Strike=1.5,ForeignCurrency=GBP,_
DomesticCurrency=USD,Settlement=4.0,BuySell=Buy
Trade=ForwardRateAgreementDeal,Reference=IR-6001,Principal=100.0,Strike=3.0,Currency=GBP,_
Maturity=4.5,Start=4.0,BuySell=Buy
//Trade=FXOptionDeal,Reference=FXOption_Call,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,_
Time_To_Expiry=5.0,ExerciseStyle=European,OptionType=Call,BuySell=Buy
Trade=DownOutEquityOptionDeal,Reference=Tech-7001,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,OptionType=Call,CalcMethod=Analytic
/*
Trade=DownOutEquityOptionDeal,Reference=Tech-7002,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=MonteCarlo,OptionType=Call,_
NumberScenarios=10000,UseBrownianBridge=true
Trade=DownOutEquityOptionDeal,Reference=Tech-7005,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=Analytic,OptionType=Call
*/
Trade=DownOutEquityOptionDeal,Reference=Tech-7006,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=Numeric,OptionType=Call
Trade=DownOutEquityOptionDeal,Reference=Tech-7007,Equity=Real-Computers,Volatility=0.2,_
Strike=100.0,Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=Numeric,OptionType=Call,_
ExerciseStyle=American
//Trade=DownOutEquityOptionDeal,Reference=JPCA_BB_False,Equity=Real-Computers,Strike=100.0,_
Time_To_Expiry=1.0,Barrier_Level=90.0,CalcMethod=MonteCarlo,OptionType=Call,_
NumberScenarios=10000,UseBrownianBridge=false
Trade=DownOutFXOptionDeal,Reference=FX-5004,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,ExerciseStyle=European,_
OptionType=Call,BuySell=Buy,CalcMethod=Analytic,Barrier_Level=0.01
Trade=DownOutFXOptionDeal,Reference=FX-5006,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,ExerciseStyle=European,_
OptionType=Call,BuySell=Buy,CalcMethod=MonteCarlo,UseBrownianBridge=true,Barrier_Level=0.01
// American FX Barrier Call
Trade=DownOutFXOptionDeal,Reference=FX-5007,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,OptionType=Call,BuySell=Buy,_
CalcMethod=Numeric,Barrier_Level=0.01,ExerciseStyle=American
// European Put
Trade=FXOptionDeal,Reference=FX-5008,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,ExerciseStyle=European,_
OptionType=Put,BuySell=Buy
Trade=DownOutFXOptionDeal,Reference=FX-5009,NumberOfUnits=123,Strike=0.5,Volatility=0.1375,_
ForeignCurrency=USD,DomesticCurrency=GBP,Time_To_Expiry=5.0,OptionType=Put,BuySell=Buy,_
CalcMethod=MonteCarlo,Barrier_Level=0.01,ExerciseStyle=European
Exhibit 8.1 Here we show an example portfolio driver Ô¨Åle and the individual portfolio
deÔ¨Ånition Ô¨Åles EQ-Investments.txt and Broad-Investments.txt. The symbol
_ is used to indicate a line continuation; it should be noted the C# application requires
each deal to be speciÔ¨Åed on a single line.
deal classes. For instance, all foreign exchange derivatives will need access to the
current FX rates, and all equity derivatives will require the current equity price.
The contents of the market data Ô¨Åle can be updated as frequently as required

252
Computational Finance Using C and C#
// Currency market data. This is used for pricing interest rate swaps, FX options, etc...
Currency.USD,FXSpot=0.5565,YieldCurve=[(0.0027,0.0184),...,(40.58,0.0533)],
VolCurve=[(0.0,0.10),(1.0,0.12),(3.0,0.13),(6.0,0.14),(20,0.15)]
Currency.GBP<<--Base,FXSpot=1.0,YieldCurve=[(0.0027,0.047),...,(50.03,0.042)],
VolCurve=[(0.0,0.10),(1.0,0.12),(3.0,0.13),(6.0,0.14),(20,0.15)]
Currency.EUR,FXSpot=0.689024,YieldCurve=[(0.0,0.04),...,(20,0.056)],
VolCurve=[(0.0,0.10),(1.0,0.12),(3.0,0.13),(6.0,0.14),(20,0.15)]
Currency.CAD,FXSpot=1.5,YieldCurve=[(0.0,0.04),...,(20,0.056)],
VolCurve=[(0.0,0.10),(1.0,0.12),(3.0,0.13),(6.0,0.14),(20,0.15)]
// Equity market data. This is used for pricing equity options, etc...
Equity.Imperial-Art,Currency=GBP,Spot=9.0,DivYield=0.03
Equity.Real-Computers,Currency=USD,Spot=200.0,DivYield=0.04
Equity.TelComm,Currency=GBP,Spot=120.0,DivYield=0.09
Equity.WebComm,Currency=USD,Spot=100.0,DivYield=0.07
Equity.Hackers,Currency=GBP,Spot=40.0,DivYield=0.02
Equity.LaserComm,Currency=GBP,Spot=95.0,DivYield=0.05
Equity.SmartWeb,Currency=GBP,Spot=100.0,DivYield=0.01
Equity.Web-Comm,Currency=GBP,Spot=100.0,DivYield=0.04
Equity.Mobile-Tech,Currency=GBP,Spot=92.0,DivYield=0.02
Equity.CompuKalc,Currency=GBP,Spot=95.0,DivYield=0.11
Equity.The-Bookshop,Currency=GBP,Spot=100.0,DivYield=0.02
Equity.Everyman-Books,Currency=GBP,Spot=100.0,DivYield=0.03
Equity.The-RealBook-Company,Currency=GBP,Spot=100.0,DivYield=0.04
Equity.Drinks-4U,Currency=GBP,Spot=100.0,DivYield=0.05
Equity.Beverage-Ltd,Currency=GBP,Spot=100.0,DivYield=0.06
Equity.H2O-Ltd,Currency=GBP,Spot=100.0,DivYield=0.05
Equity.Fine-Wines-Ltd,Currency=GBP,Spot=100.0,DivYield=0.03
Equity.French-Wines-Ltd,Currency=EUR,Spot=100.0,DivYield=0.2
Equity.The-English-Beer-Company,Currency=GBP,Spot=100.0,DivYield=0.03
Equity.Water-Works-Ltd,Currency=GBP,Spot=100.0,DivYield=0.012
Equity.Welsh-Spring,Currency=GBP,Spot=100.0,DivYield=0.06
Equity.ThamesBeer,Currency=GBP,Spot=100.0,DivYield=0.05
Equity.Edingburgh-Whiskey,Currency=GBP,Spot=100.0,DivYield=0.04
Equity.The-Wine-Box,Currency=GBP,Spot=100.0,DivYield=0.085
// Bond market data. This is used for pricing bonds, and credit derivatives such as CDS, and
TRS
Bond.Fine-Wines-Ltd-Bond-2020,Currency=GBP,Spot=150.0,
SurvivalProb=[(0.0,1.0),(1.0,0.9),(3.0,0.96),(6.0,0.9),(20,0.5)]
Bond.Hackers-Bond-2018,Currency=GBP,Spot=200.0,
SurvivalProb=[(0.0,1.0),(2.0,0.91),(5.0,0.9),(8.0,0.8),(30,0.6)]
Bond.Hackers-Bond-2060,Currency=GBP,Spot=260.0,
SurvivalProb=[(0.0,1.0),(1.0,0.92),(20.0,0.8),(20.0,0.65),(60,0.7)]
Bond.Real-Computers-Bond-2020,Currency=USD,Spot=100.0,
SurvivalProb=[(0.0,1.0),(1.0,0.94),(4.0,0.9),(8.0,0.6),(30,0.5)]
// Market data correlation. These are used for multiasset options
Correlation.Imperial-Art,Real-Computers=0.5
Correlation.Real-Computers,WebComm=0.4
Correlation.Real-Computers,Hackers=0.5
Correlation.Real-Computers,LaserComm=0.3
Correlation.Real-Computers,SmartWeb=0.4
Correlation.TelComm,Hackers=0.5
Correlation.TelComm,LaserComm=0.5
Correlation.TelComm,SmartWeb=0.5
Correlation.TelComm,Web-Comm=0.5
Correlation.LaserComm,SmartWeb=0.5
Correlation.Hackers,Mobile-Tech=0.4
Correlation.LaserComm,Mobile-Tech=0.4
Correlation.SmartWeb,Mobile-Tech=0.5
Correlation.Web-Comm,Mobile-Tech=0.5
Exhibit 8.2 An example market data Ô¨Åle, which is used to specify the current market
values such as equity spot, FX spot, interest rate yield curves, etc. The third line in
the Ô¨Åle provides currency information for GBP, and the entry Currency.GBP¬´--Base
speciÔ¨Åes that the base currency will be GBP, and thus all portfolio and deal values will be
computed in GBP.

C# portfolio pricing application
253
Correlation.Mobile-Tech,The-Bookshop=0.1
Correlation.CompuKalc,LaserComm=0.3
Correlation.ThamesBeer,French-Wines-Ltd=0.3
Correlation.ThamesBeer,Fine-Wines-Ltd=0.5
Correlation.ThamesBeer,H2O-Ltd=0.5
Correlation.ThamesBeer,Beverage-Ltd=0.6
Correlation.ThamesBeer,Drinks-4U=0.6
Correlation.ThamesBeer,The-RealBook-Company=0.8
Correlation.ThamesBeer,People-Books=0.1
.
.
.
Correlation.Edingburgh-Whiskey,French-Wines-Ltd=0.5
Correlation.Edingburgh-Whiskey,Water-Works-Ltd=0.5
Correlation.Edingburgh-Whiskey,The-English-Beer-Company=0.6
Exhibit 8.2 (Continued).
(i.e., daily, hourly, etc.) but will always maintain a set of market values that can
be used consistently across all deal valuations.
It should be mentioned that the main advantage of type E1 deal entries is
not just that the portfolio deÔ¨Ånition Ô¨Åle is smaller‚Äîit also ensures that consis-
tent market data values are used to price all the trades in the portfolio. When
type E2 deal entries are used, it is necessary to ensure that all the extra deal
attributes are updated as new market data becomes available. This would be
a time-consuming task and, if only a partial update occurs, could give rise to
invalid deal valuations caused by inconsistent deal attribute values such as FX-
EquityCurrency, DividendYield.
The format of the result Ô¨Åles is shown in Exhibit 8.3. The output syntax is
simply:
<deal value>=<deal reference>,<deal type>
It can be seen that each deal is valued in base currency (which here is speciÔ¨Åed
in the market data Ô¨Åle as GBP) and the total value for the portfolio is also
reported.
Results Ô¨Åle for portfolio EQ-investments
=============================
EQ-Investments in units of GBP
EQ-Investments
:14/07/2007 00:00:00
=============================
4.3501=EQ:LaserComm-1001,Equity Option
2.9278=EQ:LaserComm-1002,Equity Option
3.5716=EQ:LaserComm-1003,Equity Option
2.0245=EQ:LaserComm-1004,Equity Option
2.2171=EQ:WebComm-1004A,Equity Option
41.7119=EQ:CompuKalc-1005,Rainbow option(two equities)
14.0274=EQ:MobileTech|CompuKalc-1006,Rainbow option(two equities)
8.8511=EQ:MobileTech|CompuKalc-1007,Rainbow option(two equities)
70.3151=EQ:MobileTech|TelComm-1008,Rainbow option(two equities)
13.3263=JPCAM11,Rainbow option(two equities)
6.5840=JPCAM111,Rainbow option(two equities)
72.7866=Tech-10001,Three Equity Option
70.1046=Tech-10002,Three Equity Option
69.7412=Tech-10003,Three Equity Option
1010.6123=Tech-10004,Three Equity Option
1030.3894=Tech-10005,Three Equity Option
2850.8918=Tech-10006,Three Equity Option

254
Computational Finance Using C and C#
2838.9643=Tech-10007,Three Equity Option
2838.9643=Tech-10008_Generic,Generic Equity Option
399.4981=Tech-10009,Three Equity Option
409.1153=Tech-10010,Three Equity Option
2646.6473=Drinks-20001,Four Equity Option
2644.3642=Drinks-20002,Four Equity Option
15.3381=Drinks-20003,Four Equity Option
21.8691=Drinks-20004,Four Equity Option
53.8106=Drinks-20005,Four Equity Option
63.2889=Drinks-20006,Four Equity Option
1511.6543=Drinks-20007,Four Equity Option
1524.5000=Drinks-20008,Four Equity Option
1510.7045=Drinks-20009,Four Equity Option
1518.8670=Drinks-20010,Four Equity Option
1513.7578=Drinks-20011,Four Equity Option
1524.5000=Drinks-20012,Generic Equity Option
1513.7578=Drinks-20013,Four Equity Option
2030.2451=Drinks-20013,Generic Equity Option
6.1238=JPCA_111,Down Out Equity Option
6.1240=JPCA_111A,Down Out Equity Option
3.0006=JPCA_112,Down Out Equity Option
3.0006=JPCA_113,Down Out Equity Option
3.0006=JPCA_114,Down Out Equity Option
3.0036=JPCAPP_115,Double Knock Out Call Equity Option
========================
TOTAL VALUE =
29878.53 GBP
=========================
Results Ô¨Åle for portfolio broad-investments
=============================
Broad-Investments in units of GBP
Broad-Investments
:14/07/2007 00:00:00
=============================
9.4359=FX-5001,FX Forward
-9.4359=FX-5002,FX Forward
0.8661=IR-6001,Forward Rate Agreement
1.1755=IR-6002,Forward Rate Agreement
52.6353=Tech-7001,Down Out Equity Option
52.6757=Tech-7002,Down Out Equity Option
52.6757=Tech-7003,Down Out Equity Option
52.6583=Tech-7004,Down Out Equity Option
52.6353=Tech-7005,Down Out Equity Option
52.6358=Tech-7006,Down Out Equity Option
55.6500=Tech-7007,Down Out Equity Option
11.6849=FX-5003,FX Option
11.6849=FX-5004,Down Out FX Option
11.6813=FX-5005,Down Out FX Option
11.5356=FX-5006,Down Out FX Option
11.9998=FX-5007,Down Out FX Option
2.9173=FX-5008,FX Option
2.9827=FX-5009,Down Out FX Option
========================
TOTAL VALUE =
438.09 GBP
=========================
Exhibit 8.3 Portfolio results Ô¨Åles. The reporting currency is set in the market data Ô¨Åle; in
this example, all values are given in pounds sterling.
8.2
Storing and retrieving the market data
As mentioned before, the market data required to price derivatives is stored
in market data dictionaries. The MarketDataDictionaries class, shown in

C# portfolio pricing application
255
Code excerpt 8.4, contains a set of C# Dictionary member items which hold all
the market data required by the deal classes. Below we give the declaration of
the CurrencyTable, EquityTable and CorrelationTable dictionaries:
public static Dictionary<string, Currency> CurrencyTable = new Dictionary<string,_
Currency>();
public static Dictionary<string, Equity> EquityTable = new Dictionary<string,_
Equity>();
public static Dictionary<string, Correlation> CorrelationTable = new Dictionary<string,_
Correlation>();
Each dictionary entry is made up of a {<unique-key>, <value-object>}
pair, where unique-key is a unique string, and value-object is a class
containing the corresponding market data. We will now consider each of the
above dictionaries and the information they hold in more detail.
8.2.1
CurrencyTable
In a CurrencyTable dictionary value-object is a class of type Currency
and is used to store currency information. The class declaration is provided in
Code excerpt 8.3.
public class TPair : IComparable
{
public double t;
public double val;
public TPair(double t1, double val1)
{
t = t1;
val = val1;
}
int IComparable.CompareTo(object obj)
{
TPair temp = (TPair)obj;
if (this.t > temp.t)
return (1);
if (this.t < temp.t)
return (-1);
else
return (0);
}
}
// ICurve - a curve for storing interest rates
public class ICurve: List<TPair>
{
private double t_pt;
// internal value used for matching
private string name_ = "";
public ICurve (string name) {
name_ = name;
}
public double this[double t_0, double t]
{ get { // return the discount factor between t and t1
double eps = 1.0e-6;
double val;
Code excerpt 8.3 Code showing the class Currency and also the classes ICurve and
TPair which all enable the interest rate yield curve to be stored.

256
Computational Finance Using C and C#
t_pt = t;
// find the bounding indicies corresponding to a given t value
int indx1 = this.FindIndex(TPairFind);
if (indx1 == -1)
throw new Exception("Invalid market data interest rate yield curve for currency "
+ name_);
double v2 = this[indx1].val;
double v1 = this[indx1 - 1].val;
double t2 = this[indx1].t;
double t1 = this[indx1 - 1].t;
if (Math.Abs(t2 - t) < eps)
{
val = v2;
}
else
{ // use linear interpolation to compute the value of DF
val = v1 + ((v2 - v1) / (t2 - t1)) * (t - t1);
}
val = Math.Exp(-val * t);
return val;
}
}
public double this[double t, double t1, double t2] {
get {
// return the forward rate between t1 and t2
// t2 >= t1
double DF1 = this[t, t1];
double DF2 = this[t, t2];
double fwd = (DF1 / DF2 - 1.0) / (t2 - t1);
return fwd;
}
}
private bool TPairFind(TPair v)
{
if ((v.t >= t_pt))
{
return true;
}
else
{
return false;
}
}
}
public class Currency
{
public string name;
// the name of the currency (e.g GBP, or USD)
public double spot;
// the FX spot of the currency with respect to base
currency
public ICurve YieldCurve;
// the currency yield curve
public VCurve VolCurve;
// the volatility of the yield curve (not currently used
by the C# application)
public Currency(string name1, double spot1) // two parameter constructor
{
name = name1;
spot = spot1;
YieldCurve = new ICurve(name1);
}
public Currency(string name1) // single parameter constructor
{
YieldCurve = new ICurve(name1);
VolCurve = new VCurve(name1);
}
}
Code excerpt 8.3 (Continued).

C# portfolio pricing application
257
string CcyCode = "USD"; // set the unique currency code to USD
// create a new (empty) entry in the CurrencyTable for USD
CurrencyTable.Add(CcyCode, new Currency(CcyCode));
double FXSpot = 0.5565; // set the USD to base currency FX spot
// assign to public data member spot, in class Currency
CurrencyTable[CcyCode].spot = FXSpot;
// assign to public data member name, in class Currency
CurrencyTable[CcyCode].name = CcyCode;
double t;
double rt;
t= 0.0027;
// time - for point 1
rt = 0.0184;
// rate - for point 1
// add the first point to the public data member YieldCurve, in class Currency
CurrencyTable[CcyCode].YieldCurve.Add(new TPair(t, rt));
.
.
.
t = 40.58;
rt = 0.0533;
CurrencyTable[CcyCode].YieldCurve.Add(new TPair(t, rt));
Code excerpt 8.4 C# code showing the addition of USD currency market data to the
CurrencyTable dictionary.
It is straightforward to add currency data to CurrencyTable. The C# code
fragment shown in Excerpt 8.4 illustrates the addition of USD information.
The information in the CurrencyTable is accessed by the deal classes and
used to compute discount factors, forward rates and FX spots. In the market
data Ô¨Åle (see Exhibit 8.2) the YieldCurve consists of a set of time/value pairs
and is deÔ¨Åned using the following syntax:
YieldCurve = [(t1, r1), . . . , (ti, ri), . . . , (tn, rn)], where ti is the time in years,
and ri is the corresponding zero coupon rate with tenor ti.
The value, at t = 0, of a zero coupon bond with unit cash Ô¨Çow at maturity, ti,
is exp(‚àíri ti), and is known as the discount factor DF(0, ti). Code excerpt 8.4
shows the addition of two data items to the USD yield curve, while Code ex-
cerpt 8.5 illustrates the retrieval from DF(0, ti) of ri. The code fragment:
double discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate = -Math.Log(discount_fac) / Time_To_Expiry_;
computes the zero coupon rate RiskFreeRate and this can be used as a
value for the risk free rate required by the option pricing routines in Analyt-
ics_MathLib.dll. It should be mentioned that it would have been more efÔ¨Å-
cient to have written code to directly obtain the interpolated risk free rate from
the USD yield curve (without Ô¨Årst computing the associated discount factor).
However, the required code can easily be supplied by the reader.
Discount factors and forward rates are accessed from an ICurve object. The
discount factor is obtained as follows:
ICurve DF = MarketDataDictionaries.
CurrencyTable[Currency_].YieldCurve;

258
Computational Finance Using C and C#
try
{
string Currency_ = "USD";
// DF
will be used to access discount factors
ICurve DF =
MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// FWD will be used to access forward rates
ICurve FWD =
MarketDataDictionaries.CurrencyTable[BaseCurrency].YieldCurve;
// obtain the discount factor DF(0,1) using methods in class ICurve
double discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate = -Math.Log(discount_fac) / Time_To_Expiry_;
double Time_To_Expiry_ = 1.0;
double FXspot =
// obtain the FX spot with repect the base currency (GBP)
MarketDataDictionaries.CurrencyTable[Currency_].spot;
double t1 = 1.0;;
double t2 = 1.5;
// obtain the forward rate F(0,1,1.5) using methods in class ICurve
double forward_rate = FWD[0, t1, t2];
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for " + Currency_);
}
Code excerpt 8.5 Code showing the retrieval of USD currency market data from the
CurrencyTable dictionary.
public class Equity
{
public string Name;
public double Spot;
public string Currency;
public double DivYield;
public Equity(string Name1, double Spot1, string Currency1, double DivYield1)
{
Name = Name1;
Spot = Spot1;
Currency = Currency1;
DivYield = DivYield1;
}
public Equity()
{
}
}
public class Correlation
{
public string Name1;
public string Name2;
public double Correl;
public Correlation(string Name11, string Name12, double Correl1)
{
Name1 = Name11;
Name2 = Name12;
Correl = Correl1;
}
public Correlation()
{
}
}
Code excerpt 8.6 The equity and correlation classes.

C# portfolio pricing application
259
declares the ICurve object DF. Then the discount factor between 0 and
Time_To_Expiry_ is computed with the statement:
double discount_fac = DF[0, Time_To_Expiry_];
where DF[0, Time_To_Expiry_] calls the ICurve accessor (declared as
public double this[double t_0, double t]) with t_0 = 0 and t
= Time_To_Expiry. It can be seen from Code excerpt 8.3 that linear inter-
polation is performed by the accessor if required.
The forward rate is obtained in a similar manner:
ICurve FWD = MarketDataDictionaries.
CurrencyTable[Currency_].YieldCurve;
declares the ICurve object FWD. Then the forward rate F(0, t1, t2) is returned
with the statement:
double forward_rate = FWD[0, 0.5, 1.5];
where FWD[0, t1, t2] calls the ICurve accessor (declared as public
double this[double t, double t1, double t2])
with
t = 0,
t1=0.5, and t2 = 1.5. It can be seen from Code excerpt 8.3 that the ac-
cessor computes the forward rate as:
FWD[0,t1,t2] = (DF[0,t1] / DF[0,t2] - 1.0)
/ (t2 - t1);
EquityTable and CorrelationTable
Code excerpt 8.7 shows how market data is added to the internal dictionaries
of the MarketDataDictionaries class. For instance, to add a correlation
public class MarketDataDictionaries
{
public static Dictionary<string, Currency> CurrencyTable = new Dictionary<string,
Currency>();
public static Dictionary<string, Equity> EquityTable = new Dictionary<string,
Equity>();
public static Dictionary<string, Correlation> CorrelationTable = new Dictionary<string,
Correlation>();
protected static string BaseCurrency_ = "";
public static string GetBaseCurrency()
{
return BaseCurrency_;
}
public static void LoadMarketData(string marketdata_file)
{
// Load the market data file and assign values to dictionaries
StreamReader MDFILE = new StreamReader(marketdata_file);
string cur_line = "";
while ((cur_line = MDFILE.ReadLine()) != null)
// loop through the market data
file
Code excerpt 8.7 The MarketDataDictionaries class, illustrating how market data
is added to the internal dictionaries.

260
Computational Finance Using C and C#
{
if ((cur_line.Length > 1) && ((cur_line.Substring(0, 2) != "//")))
{
char[] seps = new char[] { ‚Äô=‚Äô, ‚Äô,‚Äô };
string[] v = cur_line.Split(seps, StringSplitOptions.None);
int num_elems = v.GetUpperBound(0);
int k = 0;
double t_, val_;
bool stop;
double FXSpot = 0.0;
if (v[0].Substring(0, 8) == "Currency") // currency data
{
string CcyCode = v[0].Substring(9, 3);
if (v[0].IndexOf("<<--Base") != -1) BaseCurrency_ = CcyCode;
k += 2;
if (!CurrencyTable.ContainsKey(CcyCode))
{
CurrencyTable.Add(CcyCode, new Currency(CcyCode));
}
else
{
throw new Exception("Spot & interest rate market data already
supplied for " + CcyCode);
}
FXSpot = (double)Convert.ChangeType(v[k], typeof(double));
CurrencyTable[CcyCode].spot = FXSpot;
CurrencyTable[CcyCode].name = CcyCode;
k += 2;
t_ = (double)Convert.ChangeType(v[k].Substring(2, v[k].Length - 2),
typeof(double));
k += 1;
val_ = (double)Convert.ChangeType(v[k].Substring(0, v[k].Length - 1),
typeof(double));
CurrencyTable[CcyCode].YieldCurve.Add(new TPair(t_, val_));
k += 1;
int vv = v[k].IndexOf(")]");
stop = false;
while (!stop) // Add the yield curve data
{
t_ = (double)Convert.ChangeType(v[k].Substring(1, v[k].Length - 1),
typeof(double));
k += 1;
if (v[k].IndexOf(")]") == -1)
{
val_ = (double)Convert.ChangeType(v[k].Substring(0, v[k].
Length - 1),typeof(double));
}
else
{
val_ = (double)Convert.ChangeType(v[k].Substring(0, v[k].
Length - 2), typeof(double));
stop = true;
}
k += 1;
CurrencyTable[CcyCode].YieldCurve.Add(new TPair(t_, val_));
}
CurrencyTable[CcyCode].YieldCurve.Sort();
.
.
.
}
else if (v[0].Substring(0, 6) == "Equity") // equity data
{
int idx = v[k].IndexOf(".");
string EquityName = v[0].Substring(idx + 1, v[0].Length - idx - 1);
k += 2;
string CcyCode = v[k];
Code excerpt 8.7 (Continued).

C# portfolio pricing application
261
k += +2;
double spot = (double)Convert.ChangeType(v[k], typeof(double));
k += +2;
double div = (double)Convert.ChangeType(v[k], typeof(double));
if (!EquityTable.ContainsKey(EquityName))
{
EquityTable.Add(EquityName, new Equity());
EquityTable[EquityName].Currency = CcyCode;
EquityTable[EquityName].Name = EquityName;
EquityTable[EquityName].Spot = spot;
EquityTable[EquityName].DivYield = div;
}
else
{
throw new Exception("Spot & currency market data already supplied
for " + EquityName);
}
}
.
.
.
else if (v[0].Length >= 12 && v[0].Substring(0, 11) == "Correlation")
// correlation data
{
int idx = v[0].IndexOf(".");
string AssetName1 = v[0].Substring(idx + 1, v[0].Length - idx - 1);
k += 1;
string AssetName2 = v[k];
k += 1;
double corr = (double)Convert.ChangeType(v[k], typeof(double));
string CorrelationKey = AssetName1 + "%" + AssetName2;
if(!CorrelationTable.ContainsKey(CorrelationKey))
{
// ie The-Wine-Box%Water-Works-Ltd and The-Wine-Box%Water-Works-Ltd
CorrelationTable.Add(CorrelationKey, new Correlation());
CorrelationTable[CorrelationKey].Correl = corr;
CorrelationTable[CorrelationKey].Name1 = AssetName1;
CorrelationTable[CorrelationKey].Name2 = AssetName2;
CorrelationKey = AssetName2 + "%" + AssetName1;
CorrelationTable.Add(CorrelationKey, new Correlation());
CorrelationTable[CorrelationKey].Correl = corr;
CorrelationTable[CorrelationKey].Name1 = AssetName2;
CorrelationTable[CorrelationKey].Name2 = AssetName1;
}
else
{
throw new Exception("market data already supplied for "
+ CorrelationKey);
}
}
}
}
MDFILE.Close();
}
}
Code excerpt 8.7 (Continued).
entry it is Ô¨Årst necessary to construct the dictionary key, and then determine
whether or not the entry already exists in the dictionary. This is shown in the
code fragment below:
// first construct the unique key string from AssetName1 and AssetName2
string CorrelationKey = AssetName1 + "%" + AssetName2;
// Now check whether this key already exists in the dictionary CorrelationTable.
// If it doesn‚Äôt then add a new entry, if it does then raise an exception
if(!CorrelationTable.ContainsKey(CorrelationKey))

262
Computational Finance Using C and C#
{
// Create a new empty dictionary entry for the unique key
CorrelationTable.Add(CorrelationKey, new Correlation());
// Now fill out the entry by assigning the correlation and the asset names
CorrelationTable[CorrelationKey].Correl = corr;
CorrelationTable[CorrelationKey].Name1 = AssetName1;
CorrelationTable[CorrelationKey].Name2 = AssetName2;
// Create another empty dictionary entry with the asset names in reverse order
// (because correlation(a,b) = correlation(b,a)
CorrelationKey = AssetName2 + "%" + AssetName1;
// Now fill out the entry by assigning the correlation and the asset names
CorrelationTable.Add(CorrelationKey, new Correlation());
CorrelationTable[CorrelationKey].Correl = corr;
CorrelationTable[CorrelationKey].Name1 = AssetName2;
CorrelationTable[CorrelationKey].Name2 = AssetName1;
}
else
{
throw new Exception("market data already supplied for " + CorrelationKey);
}
8.3
The PricingUtils class and the
Analytics_MathLib
It has already been mentioned that the deal classes often make calls to the C
pricing function that are contained in Analytics_MathLib.dll. To do this
it is necessary to provide a C# declaration for the corresponding C function.
This is carried out in the PricingUtils class by declaring the routines as ex-
tern and using the C# DllImport attribute, which is deÔ¨Åned in the namespace
System.Runtime.InteropServices. Code excerpt 8.8 provides a sample
of the C# declarations in PricingUtils and some of the corresponding C dec-
using System;
using System.Collections.Generic;
using System.Collections;
using System.IO;
using System.Text;
using System.Runtime.InteropServices;
public class PricingUtils
{
public static double EPS = 1.0e-6;
[DllImport("Analytics_MathLib.dll")]
public static extern void dko_call(double lower_barrier, double upper_barrier,
double theta_m, double S0, ref double sigma_array, ref double sigma_times,
int n_sigma, double r, double opt_mat, double X, int is_american, ref double
option_value,
IntPtr greeks, double q, int ns_below_S0, int ns_above_S0, int nt, ref int iflag);
[DllImport("Analytics_MathLib.dll", EntryPoint = "black_scholes")]
public static extern void black_scholes2(ref double value, ref double greeks, double s0,
double x, double sigma,
double t, double r, double q, int put, ref int iflag);
Code excerpt 8.8 The PricingUtils class, which permits C# code to call the C func-
tions that reside in Analytics_Mathlib.dll. The attribute DllImport (deÔ¨Åned in
namespace System.Runtime.InteropServices) indicates to C# Interop services
that unmanaged code is being called.

C# portfolio pricing application
263
[DllImport("Analytics_MathLib.dll", EntryPoint = "black_scholes")]
public static extern void black_scholes(ref double value, IntPtr greeks, double s0,
double x, double sigma,
double t, double r, double q, int put, ref int iflag);
[DllImport("Analytics_MathLib.dll")]
public static extern void opt_gfd(double theta, double S0, double sigma, double r,
double T, double X, int is_american,
int put, ref double value, IntPtr greeks, double q, int ns, int nt,
double smax, ref int iflag);
[DllImport("Analytics_MathLib.dll")]
public static extern void standard_2D_binomial(ref double value, double S1, double S2,
double X, double sigma1,
double sigma2, double rho, double T, double r, double q1, double q2, int put,
int M, int is_max,
int is_american, ref int iflag);
.
.
.
public static double RndNorm(double mean, double std)
{
return mean + std * normal(0.0, 1.0);
}
[DllImport("Analytics_MathLib.dll")]
public static extern double normal(double mean, double std);
[DllImport("Analytics_MathLib.dll")]
public static extern void set_seed(int seed);
[DllImport("Analytics_MathLib.dll", EntryPoint = "multivariate_normal2")]
public static extern void multivariate_normal(int is_fcall, ref double a, int n,
ref double c, int tdc, double eps,
ref double r, ref double z, ref int iflag);
// array r has size nr = ((n+1)*(n+2))/2 + 1
}
Code excerpt 8.8 (Continued).
larations are given in Code excerpt 8.9. It can be seen that C function parameters
passed by value and declared as double dval and long ival correspond to
C# double dval and int ival parameters, respectively. C functions that
are passed by reference are a little more tricky to deal with in C#. This is be-
cause C# does not explicitly support pointers. A C double parameter passed
by reference using double *dval can be mapped in C# by using ref dou-
ble dval. Similarly, the C function parameter long* ival is declared in C#
as ref int ival. It should be noted that for clarity we use the C syntax
double a_dval[] and long a_ival[] for arrays of double and long,
respectively; it is also correct to declare these as double *a_dval, and long
*a_ival.
However, there is still a problem because C functions can be coded to check
whether or not a null pointer has been supplied as a parameter, and then take
appropriate action. For instance, the function black_scholes in Code ex-
cerpt 4.1, will not compute the Greeks if the parameter double greeks[] is
null. The code fragment below shows how IntPtr, which is a recent addition
to C#, can be used to resolve this:
[DllImport("Analytics_MathLib.dll", EntryPoint = "black_scholes")]
public static extern void black_scholes2(ref double value, ref double greeks,_
double s0, double x,double sigma, double t, double r, double q, int put, ref int iflag);

264
Computational Finance Using C and C#
[DllImport("Analytics_MathLib.dll", EntryPoint = "black_scholes")]
public static extern void black_scholes(ref double value, IntPtr greeks, double s0,_
double x, double sigma, double t, double r, double q, int put, ref int iflag);
The Ô¨Årst declaration speciÔ¨Åes that the function called
black_scholes
in Analytics_MathLib.dll will have the name black_scholes2 in C#.
In addition the C parameter double greeks[] is mapped to ref double
greeks in C#. This means that we will need to declare an array variable (say
the_greeks which will hold the Ô¨Åve Greeks and pass it to black_scholes2
using the syntax ref the_greeks[0]. In this case the Greeks will always be
computed, even if we don‚Äôt want to use them.
The second declaration speciÔ¨Åes that the function black_scholes2 in C#
will also call the routine black_scholes in Analytics_MathLib.dll.
However, in this case, the C parameter double greeks[] is mapped
to IntPtr greeks in C#. This allows us to set the parameter double
greeks[] to
null by passing the value IntPtr.Zero‚Äîsee for example
class EquityOptionDeal in Code excerpt 8.10.
#define DLLExport __declspec(dllexport)
void DLLExport __stdcall black_scholes(double *value, double greeks[],double s0,double x,
double sigma,
double t,double r,double q, long put, long *iflag)
{
.
.
.
See code excerpt 4.1 for more detail
.
.
.
}
void DLLExport __stdcall opt_gfd(double theta_m, double asset_price, double sigma, double r,
double T,
double strike, long is_american, long put, double *option_value,
double greeks[], double q, long pns, long nt, double smax, long *iflag)
{
.
.
.
See code excerpt 5.18 for more detail
.
.
.
}
void DLLExport __stdcall multivariate_normal2(long is_fcall, double a[], long n, double c[],
long tdc,
double eps, double r[], double z[], long *iflag)
{
.
.
.
Standard C code to generate a multivariate normal
.
.
.
}
Code excerpt 8.9 Illustrative C code which is contained in the windows dynamic link
library Analytics_MathLib.dll.

C# portfolio pricing application
265
using System;
namespace Computational_Lib
{
public class EquityOptionDeal: BaseDeal
{
public string Equity { get { return EquityName_; } set { EquityName_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public PutCall OptionType{ get {return OptionType_;} set { OptionType_= value;}}
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
public double Strike { get { return Strike_; } set { Strike_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public double Volatility { get { return Sigma_; } set { Sigma_ = value; } }
protected PutCall
OptionType_ = PutCall.Put;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected double
Strike_ = 0;
protected string
EquityName_ = "";
protected double
Time_To_Expiry_ = 0.0;
protected string
Currency_ = "";
protected double
DividendYield_ = 0.0;
protected string
Pre_string_ = "";
protected BuySell
BuySell_ = BuySell.Buy;
protected int NumberOfUnits_ = 1;
protected double Sigma_ = 0.0;
public override string Name()
{
return "Equity Option";
}
public override double Price()
{
Validate();
double val=0.0;
double[] greeks = new double[6];
double s0 = 0.0;
double fx_spot = 0.0;
try
{
s0 = MarketDataDictionaries.EquityTable[EquityName_].Spot;
// get current equity price
Currency_ = MarketDataDictionaries.EquityTable[EquityName_].Currency;
// get equity volatility (assumed constant)
DividendYield_ = MarketDataDictionaries.EquityTable[EquityName_].DivYield;
// get equity dividend yield
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityName_);
}
// get the risk free rate to use
double discount_fac = 0.0;
double RiskFreeRate = 0.0;
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// obtain the discount factor
discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate = -Math.Log(discount_fac) / Time_To_Expiry_;
fx_spot = MarketDataDictionaries.CurrencyTable[Currency_].spot;
}
Code excerpt 8.10 The complete C# code for class EquityOptionDeal, which com-
putes the value of a single equity option.

266
Computational Finance Using C and C#
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for " + Currency_);
}
int iflag, put;
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
if (ExerciseStyle_ == EuropeanAmerican.European)
// use BlackScholes
{
// call C routine.
// Note: A null pointer is supplied so that the Greeks are not computed
PricingUtils.black_scholes(ref val, IntPtr.Zero, s0, Strike_, Sigma_,
Time_To_Expiry_,
RiskFreeRate, DividendYield_, put, ref iflag);
}
else
{
// Use Crank Nicolson
double theta = 0.5;
int is_american = 1;
// fix the geometry of the grid (these values should give "reasonable" results)
int ns = 50;
// 50 divisions on asset axis
int nt = 50;
// 50 divisions on time axis
double smax = 10.0 * s0;
PricingUtils.opt_gfd(theta, s0, Sigma_,RiskFreeRate, Time_To_Expiry_, Strike_,
is_american, put, ref val, IntPtr.Zero, DividendYield_, ns,
nt, smax, ref iflag);
}
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the_
pricing library");
val *= fx_spot * NumberOfUnits_; // return value in base currency
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ +")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than_
zero years");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- The number of units cannot be less_
than zero");
}
if (Sigma_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility cannot be less than zero");
}
}
}
}
Code excerpt 8.10 (Continued).

C# portfolio pricing application
267
8.4
Equity deal classes
In this section we provide the C# code for both single and multiasset equity
options. The trade attributes correspond to the public properties of the deal
class, and attribute default values can be readily found by reading the C# code.
The enumerations used by the deal attributes are declared below.
public enum BuySell { Buy, Sell };
public enum PutCall { Put, Call };
public enum EuropeanAmerican { European, American };
public enum MinimumMaximum { Minimum, Maximum };
public enum UseMonteCarlo { Yes, No };
public enum CalculationMethod { Analytic, Numeric, MonteCarlo };
and it can be seen that the enumerators have obvious names.
It has already been noted that the volatility used by the application to price
options is supplied as a deal attribute, rather than being stored as market data.
The reason for this is simplicity. In Chapter 4 we mentioned that a volatility
surface is required to represent the implied volatility used to price options. Stor-
ing the implied volatility would thus require a set of volatility surfaces in the
market data Ô¨Åle and also multidimensional interpolation to retrieve the volatil-
ity applicable to a given option. It was thus decided to supply the volatility as a
trade attribute‚Äîand update its value appropriately.
8.4.1
Single equity option
Code excerpt 8.10 gives the C# code for class EquityOptionDeal, which
computes the values of a single equity option.
8.4.2
Option on the price of two equities
Code excerpt 8.11 gives the C# code to compute the value of options that de-
pend on the price of two equities.
using System;
namespace Computational_Lib
{
public class TwoEquityOptionDeal : BaseDeal
{
public string Equity1 { get { return EquityName1_; } set { EquityName1_ = value; } }
public string Equity2 { get { return EquityName2_; } set { EquityName2_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
public PutCall OptionType { get { return OptionType_; } set { OptionType_ = value; } }
public MinimumMaximum
MinMax{ get { return MinMax_; } set { MinMax_ = value; } }
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
Code excerpt 8.11 C# code to compute the value of options which depend on the price
of two equities. For example, it is possible to specify whether the option is European or
American, and if it is on the minimum or maximum of the equity prices.

268
Computational Finance Using C and C#
public double Strike { get { return Strike_; } set { Strike_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public double Volatility1 { get { return Sigma1_; } set { Sigma1_ = value; } }
public double Volatility2 { get { return Sigma2_; } set { Sigma2_ = value; } }
protected PutCall OptionType_ = PutCall.Put;
protected MinimumMaximum MinMax_ = MinimumMaximum.Maximum;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected double Strike_ = 0;
protected string EquityName1_ = "";
protected string EquityName2_ = "";
protected string Currency_ = "";
protected int NumberOfUnits_ = 1;
protected double Time_To_Expiry_ = 0.0;
protected string Pre_string_ = "";
protected double S1_ = 0.0;
protected double S2_ = 0.0;
protected double Sigma1_ = 0.0;
protected double Sigma2_ = 0.0;
protected BuySell BuySell_ = BuySell.Buy;
public override string Name()
{
return "Rainbow option(two equities)";
}
public override double Price()
{
Validate();
double val = 0.0;
double rho = 0.0; // default correlation set to zero
double RiskFreeRate = 0.0;
double fx_spot = 0.0;
try
{
S1_ = MarketDataDictionaries.EquityTable[EquityName1_].Spot;
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityName1_);
}
try
{
S2_ = MarketDataDictionaries.EquityTable[EquityName2_].Spot;
S1_ = MarketDataDictionaries.EquityTable[EquityName1_].Spot;
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityName2_);
}
if(string.Compare(MarketDataDictionaries.EquityTable[EquityName1_].Currency,
MarketDataDictionaries.EquityTable[EquityName2_].Currency) != 0){
throw new Exception(Pre_string_ + "--- Currencies for both equities are not
the same");
}
Currency_ = MarketDataDictionaries.EquityTable[EquityName1_].Currency;
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// obtain the discount factor
double discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate = -Math.Log(discount_fac) / Time_To_Expiry_;
fx_spot = MarketDataDictionaries.CurrencyTable[Currency_].spot;
}
Code excerpt 8.11 (Continued).

C# portfolio pricing application
269
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ Currency_);
}
string corr_key = EquityName1_ + "%" + EquityName2_;
if (MarketDataDictionaries.CorrelationTable.ContainsKey(corr_key))
rho = MarketDataDictionaries.CorrelationTable[corr_key].Correl;
else
rho = 0.0;
int iflag, put, is_max;
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
is_max = MinMax_ == MinimumMaximum.Maximum ? 1 : 0;
if (ExerciseStyle_ == EuropeanAmerican.European)
// use analytic method
{
PricingUtils.opt_rainbow_bs_2d(ref val, S1_, S2_, Strike_, Sigma1_, Sigma2_,
rho, Time_To_Expiry_, RiskFreeRate, is_max,
put, ref iflag);
}
else { // use numeric method
double q1 = 0.0;
double q2 = 0.0;
int num_steps = 200; // need to use an even number of time steps for the lattice
int is_american = 1;
PricingUtils.standard_2D_binomial(ref val, S1_, S2_, Strike_, Sigma1_, Sigma2_,
rho, Time_To_Expiry_, RiskFreeRate,
q1, q2, put, num_steps, is_max, is_american, ref iflag);
}
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
val *= fx_spot * NumberOfUnits_; // return value in base currency
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
if (Sigma1_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility1 cannot be less than zero");
}
if (Sigma2_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility2 cannot be less than zero");
}
}
}
}
Code excerpt 8.11 (Continued).

270
Computational Finance Using C and C#
8.4.3
Generic equity basket option
Here (see Code excerpt 8.12) we consider the abstract deal class GenericE-
quityBasketOptionDeal which enables its derived classes to value an op-
using System;
namespace Computational_Lib
{
public abstract class GenericEquityBasketOptionDeal : BaseDeal
{
public string Equities { set { Equities_ = value; } }
public string Volatilities { set { Volatilities_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }
set { Time_To_Expiry_ = value; } }
public int NumberScenarios { get { return NumberScenarios_; }
set { NumberScenarios_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }
set { NumberOfUnits_ = value; } }
public string Currency { get { return Currency_; } set { Currency_ = value; } }
public double Strike { get { return Strike_; } set { Strike_ = value; } }
protected string Equities_ = "";
protected string Volatilities_ = "";
protected double Time_To_Expiry_ = 0.0;
protected double RiskFreeRate_ = 0.0;
protected string Pre_string_ = "";
protected double[] S_;
protected double[] Sigma_;
protected int NumberScenarios_ = 3000;
protected double[,] Correlations_;
protected int n_ = 0;
protected int NumberOfUnits_ = 1;
protected string Currency_ = "";
protected BuySell BuySell_ = BuySell.Buy;
protected double[] ST_;
protected double Strike_ = 0.0;
public override string Name()
{
return "Generic Equity Option";
}
public abstract double Payoff();
public override double Price()
{
Validate();
double val = 0.0;
double fx_spot = 0.0;
char[] seps = new char[] { ‚Äô%‚Äô };
string[] EquityNames = Equities_.Split(seps, StringSplitOptions.None);
n_ = EquityNames.Length;
ST_ = new double[n_];
S_ = new double[n_];
Sigma_ = new double[n_];
for (int k = 0; k < n_; ++k)
{
try
{
S_[k] = MarketDataDictionaries.EquityTable[EquityNames[k]].Spot;
}
Code excerpt 8.12 C# code for the abstract class GenericEquityBasketOption-
Deal. It contains the abstract method Payoff().

C# portfolio pricing application
271
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityNames[k]);
}
}
for (int k = 1; k < n_; ++k)
{
if (string.Compare(MarketDataDictionaries.EquityTable[EquityNames[k - 1]].
Currency, MarketDataDictionaries.EquityTable[EquityNames[k]].Currency) != 0)
throw new Exception(Pre_string_ + "--- Not all the currencies are
the same");
}
Currency_ = MarketDataDictionaries.EquityTable[EquityNames[1]].Currency;
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// obtain the discount factor
double discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
fx_spot = MarketDataDictionaries.CurrencyTable[Currency_].spot;
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ Currency_);
}
string[] Vols = Volatilities_.Split(seps, StringSplitOptions.None);
int n_v;
n_v = Vols.Length;
if (n_v != n_)
throw new Exception(Pre_string_ + "--- Number of volatilities is not the same
as the number of equities ");
Sigma_ = new double[n_];
for (int k = 0; k < n_; ++k)
{
try
{
Sigma_[k] = double.Parse(Vols[k]);
}
catch
{
throw new Exception(Pre_string_ + "--- Invalid volatility supplied for
"
+ EquityNames[k]);
}
}
Correlations_ = new double[n_, n_];
for (int i = 0; i < n_; ++i)
{
for (int j = 0; j < n_; ++j)
{
if (i != j)
{
string corr_key = EquityNames[i] + "%" + EquityNames[j];
if (MarketDataDictionaries.CorrelationTable.ContainsKey(corr_key))
Correlations_[i, j] = MarketDataDictionaries
.CorrelationTable[corr_key].Correl;
else
Correlations_[i, j] = 0.0; // default correlation is zero
}
else
{
Correlations_[i, j] = 1.0;
}
}
}
Code excerpt 8.12 (Continued).

272
Computational Finance Using C and C#
int iflag=0;
val = MonteCarloSim(ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
val *= fx_spot * NumberOfUnits_;
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
}
private double MonteCarloSim(ref int iflag)
{
double[] C = new double[n_ * n_];
double half = 0.5;
double zero = 0.0;
double sumit_val = zero;
double tol = 1.0e-8;
double opt_val = 0.0;
// set the covariance matrix
for (int i = 0; i < n_; ++i)
{
for (int j = 0; j < n_; ++j) {
C[i * n_ + j] = Sigma_[i] * Sigma_[j] * Correlations_[i, j]
* Time_To_Expiry_;
}
}
double[] MEANS = new double[n_];
// set the means
for (int i = 0; i < n_; ++i) {
MEANS[i] = (RiskFreeRate_ - Sigma_[i] * Sigma_[i] * half) * Time_To_Expiry_;
}
int seed = 111;
PricingUtils.set_seed(seed);
int len_rvec = ((n_ + 1) * (n_ + 2)) / 2 + 1;
double[] rvec = new double[len_rvec];
double[] Z = new double[n_];
double disc = Math.Exp(-RiskFreeRate_ * Time_To_Expiry_);
Code excerpt 8.12 (Continued).

C# portfolio pricing application
273
int is_fcall = 1;
PricingUtils.multivariate_normal(is_fcall, ref MEANS[0], n_, ref C[0], n_, tol,
ref rvec[0], ref Z[0], ref iflag);
is_fcall = 0;
for (int i = 1; i <= NumberScenarios_; ++i)
{
PricingUtils.multivariate_normal(is_fcall, ref MEANS[0], n_, ref C[0], n_, tol,
ref rvec[0], ref Z[0], ref iflag);
for (int jj=0; jj < n_; ++jj) {
ST_[jj] = S_[jj] * Math.Exp(Z[jj]);
}
sumit_val += Payoff();
}
opt_val = sumit_val * disc / (double)NumberScenarios_;
return opt_val;
}
}
}
Code excerpt 8.12 (Continued).
tion on an arbitrary number of underlying assets; the derived class also must
implement the abstract method Payoff. In the earlier sections of this book,
we have considered options with standard payoffs such as: vanilla put, vanilla
call, and call/put on the min/max of a number of assets. However, the class
GenericEquityBasketOptionDeal now opens the possibility of supplying
a user-deÔ¨Åned Payoff function so that options with nonstandard payoffs can
be valued.
Below we provide some example results for options on four and ten assets.
The assets were: Drinks-4U, Beverage-Ltd, H2O-Ltd, and Fine-Wines-
Ltd. The trade attributes are a time to expiry of one year, all volatilities are 0.2,
and the number of units is 100. Other information required to price the option,
such as the correlations between the equities and the risk free interest rate, is
taken from the market data dictionaries.
The syntax for using the deal class GenericEquityBasketOptionDeal
with the portfolio deÔ¨Ånition File is:
Trade=GenericEquityBasketOptionDeal:Payoff_MaxPut,Reference=1A,Strike=100.0,_
Volatilities=0.2%0.2%0.2%0.2,_
Equities=Drinks-4U%Beverage-Ltd%H2O-Ltd%Fine-Wines-Ltd,NumberOfUnits=100,_
Time_To_Expiry=1.0,NumberScenarios=1000
while that for calling the deal class FourEquityOptionDeal is:
Trade=FourEquityOptionDeal,Reference=1B,Volatility1=0.2,Volatility2=0.2,_
Volatility3=0.2,Volatility4=0.2,Equity1=Drinks-4U,Equity2=Beverage-Ltd,_
Equity3=H2O-Ltd,Equity4=Fine-Wines-Ltd,NumberOfUnits=100,Strike=100.0,_
Time_To_Expiry=1.0,OptionType=Put,MinMax=Maximum,MonteCarlo=Yes,NumberScenarios=1000
The crucial diffference is that the entry for GenericEquityBasketOption-
Deal contains the extra directive Trade=GenericEquityBasketOptionDeal:
Payoff_MaxPut, whereas FourEquityOptionDeal is the usual Trade=
FourEquityOptionDeal. The directive GenericEquityBasketOption-
Deal:Payoff_MaxPut means that the contents of the Ô¨Åle Payoff_MaxPut.

274
Computational Finance Using C and C#
txt will be compiled at runtime and thereby create the (sub)class Generic
EquityBasketOptionDeal_MaxPut, which is derived from the abstract
base class GenericEquityBasketOptionDeal. The .NET assembly con-
taining the class GenericEquityBasketOptionDeal_MaxPut is stored in
memory and its Price() method is called to value the option.
The Ô¨Åle Payoff_MaxPut.txt contains the following C# code:
using System;
namespace Computational_Lib
{
public class GenericEquityBasketOptionDeal_MaxPut : GenericEquityBasketOptionDeal
{
public override string Name()
{
string temp_string = "";
temp_string = "Generic option: Put on the maximum of " + n_.ToString() + " assets";
return temp_string;
}
public override double Payoff() { // implement max, put
double the_max = 0.0;
double pay_val = 0.0;
double zero = 0.0;
the_max = ST_[0];
for (int jj = 1; jj < n_; ++jj)
{
if (ST_[jj] > the_max) the_max = ST_[jj];
}
pay_val = Math.Max(Strike_ - the_max, zero);
return pay_val;
}
}
}
In the above code ST_, Strike_, and n_ are data members of the base class
GenericEquityBasketOptionDeal. We now present some other entries
in the portfolio deÔ¨Ånition Ô¨Åle which illustrate the versatility of the deal class
GenericEquityBasketOptionDeal.
// Call on average of 4 assets
Trade=GenericEquityBasketOptionDeal:Payoff_AvgCall,Reference=5,Strike=100.0,_
Volatilities=0.2%0.2%0.2%0.2,Equities=Drinks-4U%Beverage-Ltd%H2O-Ltd%Fine-Wines-Ltd,_
NumberOfUnits=100,Time_To_Expiry=1.0,NumberScenarios=1000
// Put on the average of 10 assets (Strike=100)
Trade=GenericEquityBasketOptionDeal:Payoff_AvgPut,Reference=8,Strike=100.0,_
Volatilities=0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2,_
Equities=Drinks-4U%Beverage-Ltd%H2O-Ltd%Fine-Wines-Ltd%The-English-Beer-Company_
%Water-Works-Ltd%Welsh-Spring%ThamesBeer_
%Edingburgh-Whiskey%The-Wine-Box,NumberOfUnits=100,Time_To_Expiry=1.0,NumberScenarios=10000
// Put on the average of 10 assets (Strike=99)
Trade=GenericEquityBasketOptionDeal:Payoff_AvgPut,Reference=9,Strike=99.0,_
Volatilities=0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2%0.2,_
Equities=Drinks-4U%Beverage-Ltd%H2O-Ltd%Fine-Wines-Ltd%The-English-Beer-Company_
%Water-Works-Ltd%Welsh-Spring%ThamesBeer%_
Edingburgh-Whiskey%The-Wine-Box,NumberOfUnits=100,Time_To_Expiry=1.0,NumberScenarios=10000
where the Ô¨Åle Payoff_AvgCall.txt contains the C# code:
using System;
namespace Computational_Lib
{
public class GenericEquityBasketOptionDealAverageCall : GenericEquityBasketOptionDeal
{
public override string Name()
string temp_string = "";
temp_string = "Generic option: Call on the average of_
" + n_.ToString() + " assets";
return temp_string;

C# portfolio pricing application
275
}
public override double Payoff() {
// implement Call on average of n_assets
double the_average = 0.0;
double pay_val = 0.0;
double zero = 0.0;
the_average = ST_[0];
for (int jj = 1; jj < n_; ++jj)
{
the_average += ST_[jj];
}
the_average = the_average/n_;
pay_val = Math.Max(the_average - Strike_, zero);
return pay_val;
}
}
}
The
contents
of
the
Ô¨Åle
Payoff_AvgPut
can
be
deduced
from
Payoff_AvgCall in the obvious manner.
The output from the application is given below:
================================================================
TestGenericEQ in units of GBP
TestGenericEQ
:31/07/2007 19:05:10
=============================
23.0100=1A,Generic option: Put on the maximum of 4 assets
23.0100=1B,Four Equity Option
.
.
.
681.4034=5,Generic option: Call on the average of 4 assets
.
.
.
338.3212=8,Generic option: Put on the average of 10 assets
302.6056=9,Generic option: Put on the average of 10 assets
=========================
TOTAL VALUE =
10936.18 GBP
=========================
It can be seen that result 1A, obtained using the deal class GenericEquity-
BasketOptionDeal, is exactly the same as result 1B, which was computed
with the deal class FourEquityOptionDeal. This is because in both cases
Monte Carlo simulation is used, and the same initial random seed is used for all
Monte Carlo simulations.
8.4.4
Equity barrier option
Code excerpt 8.13 gives the C# code for computing the value of an equity barrier
option.
using System;
namespace Computational_Lib
{
public class DownOutEquityOptionDeal : BaseDeal
{
public string Equity { get { return EquityName_; } set { EquityName_ = value; } }
public double Barrier_Level { get { return BarrierLevel_; }_
set { BarrierLevel_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public PutCall OptionType { get { return OptionType_; } set { OptionType_ = value; } }
public double Strike { get { return Strike_; } set { Strike_ = value; } }
public CalculationMethod CalcMethod { get { return CalcMethod_; }_
set { CalcMethod_ = value; } }
Code excerpt 8.13 C# code to compute the value of an equity barrier option.

276
Computational Finance Using C and C#
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
public int TimeSteps { get { return TimeSteps_; } set { TimeSteps_ = value; } }
public int NumberScenarios { get { return NumberScenarios_; }_
set { NumberScenarios_ = value; } }
public bool UseBrownianBridge{ get { return UseBrownianBridge_; }_
set { UseBrownianBridge_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public double Volatility { get { return Sigma1_; } set { Sigma1_ = value; } }
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
protected PutCall OptionType_ = PutCall.Call;
protected double Strike_ = 0;
protected double BarrierLevel_ = 0.0;
protected string EquityName_ = "";
protected double Time_To_Expiry_ = 0.0;
protected double RiskFreeRate_ = 0.0;
protected double DividendYield_ = 0.0;
protected string Pre_string_ = "";
protected CalculationMethod CalcMethod_ = CalculationMethod.Analytic;
protected int TimeSteps_ = 300;
protected int NumberScenarios_ = 3000;
protected bool UseBrownianBridge_ = true;
protected double S1_ = 0.0;
protected double Sigma1_ = 0.0;
protected int NumberOfUnits_ = 1;
protected BuySell BuySell_ = BuySell.Buy;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected string Currency_ = "";
public override string Name()
{
return "Down Out Equity Option";
}
public override double Price()
{
Validate();
double val = 0.0;
double fx_spot = 0.0;
try
{
S1_ = MarketDataDictionaries.EquityTable[EquityName_].Spot;
Currency_ = MarketDataDictionaries.EquityTable[EquityName_].Currency;
// get equity volatility (assumed constant)
DividendYield_ = MarketDataDictionaries.EquityTable[EquityName_].DivYield;
// get equity dividend yield
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ EquityName_);
}
double discount_fac = 0.0;
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[Currency_].YieldCurve;
// obtain the discount factor
discount_fac = DF[0, Time_To_Expiry_];
RiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
fx_spot = MarketDataDictionaries.CurrencyTable[Currency_].spot;
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ Currency_);
}
int iflag, put, is_american;
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
is_american = ExerciseStyle_ == EuropeanAmerican.American ? 1 : 0;
Code excerpt 8.13 (Continued).

C# portfolio pricing application
277
BarrierLevel_ = Math.Max(BarrierLevel_, PricingUtils.EPS);
if (CalcMethod_ == CalculationMethod.Analytic)
{
if (put == 1) throw new Exception(Pre_string_ + "--- Can‚Äôt price a put using
this calculation method");
if (is_american == 1) throw new Exception(Pre_string_ + "--- Can‚Äôt price an
American option using this calculation method");
PricingUtils.bs_opt_barrier_downout_call(ref val, BarrierLevel_,
S1_, Strike_, Sigma1_,
Time_To_Expiry_, RiskFreeRate_, DividendYield_,
ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
}
else if (CalcMethod_ == CalculationMethod.Numeric)
{
if (put == 1) throw new Exception(Pre_string_ + "--- Can‚Äôt price a put using
this calculation method");
int n_sigma = 2;
// set up the parameters so that have "reasonable accuracy"
double[] sigma_array = new double[n_sigma];
double[] sigma_times = new double[n_sigma];
sigma_array[0] = Sigma1_;
sigma_array[1] = Sigma1_;
sigma_times[0] = 0.0;
sigma_times[1] = Time_To_Expiry_;
int nt = 100;
int ns_below_S0 = nt / 2;
int ns_above_S0 = nt / 2;
double theta_m = 0.5;
double UpperBarrierLevel = S1_ * 5.0;
iflag = 0;
PricingUtils.dko_call(BarrierLevel_, UpperBarrierLevel,
theta_m, S1_, ref sigma_array[0], ref sigma_times[0],
n_sigma, RiskFreeRate_, Time_To_Expiry_,
Strike_, is_american, ref val,
IntPtr.Zero, DividendYield_, ns_below_S0, ns_above_S0,
nt, ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
}
else
{
bool is_put = (put == 1);
if (is_american == 1) throw new Exception(Pre_string_ + "--- Can‚Äôt price an
American option using this calculation method");
if (S1_ < BarrierLevel_)
// the opton is already knocked out
val = 0.0;
else
val = MonteCarloSim(is_put);
}
val *= fx_spot * NumberOfUnits_;
return val;
}
Code excerpt 8.13 (Continued).

278
Computational Finance Using C and C#
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (RiskFreeRate_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Risk free rate cannot be less than
zero");
}
if (Strike_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
if (BarrierLevel_ < 0.0)
{
throw new Exception(Pre_string_ + "--- BarrierLevel cannot be less than zero");
}
if (Sigma1_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility cannot be less than zero");
}
}
private double MonteCarloSim(bool is_put)
{
// Use the Brownian Bridge to compute the value of a down and out call option
int seed = 111;
double[] asset_path = new double[TimeSteps_];
double time_step = Time_To_Expiry_ / TimeSteps_;
double sqrt_time_step = System.Math.Sqrt(time_step);
double disc = System.Math.Exp(-RiskFreeRate_ * Time_To_Expiry_);
PricingUtils.set_seed(seed);
double opt_val = 0.0;
bool not_out = true;
int k = 0;
double STN = 0.0;
double mean = (RiskFreeRate_ - DividendYield_ - Sigma1_ * Sigma1_ * 0.5)
* time_step;
double std = System.Math.Sqrt(Sigma1_ * Sigma1_ * time_step);
double z;
double sum_opt_vals = 0.0;
for (int i = 0; i < NumberScenarios_; ++i)
{
// generate the asset path
double ST1 = S1_;
not_out = true;
k = 0;
while (not_out && k < TimeSteps_)
{
z = PricingUtils.RndNorm(mean, std);
STN = ST1 * System.Math.Exp(z);
if (STN < BarrierLevel_) not_out = false;
ST1 = STN;
asset_path[k] = STN;
++k;
}
Code excerpt 8.13 (Continued).

C# portfolio pricing application
279
if (is_put)
{
opt_val = System.Math.Max(Strike_ - STN, 0.0);
}
else
{
opt_val = System.Math.Max(STN - Strike_, 0.0);
}
if (not_out)
{ // only has value if asset value is above the barrier_level
// compute the probability that the asset remained above the barrier
if (UseBrownianBridge)
{
double total_probability_above = 1.0, pr;
double sigma_2 = Sigma1_ * Sigma1_;
double log_barrier_level = System.Math.Log(BarrierLevel_);
double fac;
for (int jj = 0; jj < TimeSteps_ - 1; ++jj)
{
double log_S_i = System.Math.Log(asset_path[jj]);
double log_S_i1 = System.Math.Log(asset_path[jj + 1]);
fac = 2.0 * (log_barrier_level - log_S_i)
* (log_barrier_level - log_S_i1) / (sigma_2 * time_step);
pr = (1.0 - System.Math.Exp(-fac));
// probability of staying above the barrier between i and i+1
total_probability_above *= pr;
}
sum_opt_vals += total_probability_above * opt_val * disc;
}
else
{ // don‚Äôt use the Brownian Bridge
sum_opt_vals += opt_val * disc;
}
}
}
double temp = sum_opt_vals / (double)NumberScenarios_;
return temp;
}
}
}
Code excerpt 8.13 (Continued).
Below we show the results of using the deal class DownOutEquityOption-
Deal to value Down and Out call options on LaserComm which is a GBP
equity with current (spot) price of ¬£95, and a dividend yield of 5 percent (i.e.,
0.05). All the options priced had a barrier level of ¬£90, a strike of ¬£90, a time to
expiry of one year, and a volatility of 20 percent (i.e., 0.2). The Ô¨Årst value,
¬£3.8347, was computed by a call to
bs_opt_barrier_downout_call,
which uses the closed form analytic expression provided in Code excerpt 2.6.
The second price, ¬£3.8269, which is in close agreement with the Ô¨Årst, was
obtained from dko_call and uses a Ô¨Ånite-difference grid. The third valuation
was also computed using dko_call, and illustrates the early exercise premium
for an American call option (with a nonzero dividend). The other values were
estimated using Monte Carlo simulation as the number of scenarios varied from
1000 to 64000; the default of 300 time steps was used throughout.
It can be seen that, when the Brownian bridge is used, much closer agreement
is obtained with both the analytic and numeric estimates.
DownOutTests in units of GBP
DownOutTests
:26/07/2007 13:11:28
=============================
3.8347=Analytic,Down Out Equity Option

280
Computational Finance Using C and C#
3.8269=Numeric,Down Out Equity Option
3.8860=Numeric (American style),Down Out Equity Option
4.1871=MonteCarlo(1000 Scenarios: not using BrownianBridge),Down Out Equity Option
3.8908=MonteCarlo(2000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1968=MonteCarlo(4000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1176=MonteCarlo(8000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1790=MonteCarlo(16000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1961=MonteCarlo(32000 Scenarios: not using BrownianBridge),Down Out Equity Option
4.1833=MonteCarlo(64000 Scenarios: not using BrownianBridge),Down Out Equity Option
3.8375=MonteCarlo(1000 Scenarios: using BrownianBridge),Down Out Equity Option
3.5469=MonteCarlo(2000 Scenarios: using BrownianBridge),Down Out Equity Option
3.8737=MonteCarlo(4000 Scenarios: using BrownianBridge),Down Out Equity Option
3.7356=MonteCarlo(8000 Scenarios: using BrownianBridge),Down Out Equity Option
3.8089=MonteCarlo(16000 Scenarios: using BrownianBridge),Down Out Equity Option
3.8506=MonteCarlo(32000 Scenarios: using BrownianBridge),Down Out Equity Option
3.8482=MonteCarlo(64000 Scenarios: using BrownianBridge),Down Out Equity Option
=========================
TOTAL VALUE =
70.83 GBP
=========================
8.5
FX deal classes
Here we provide code for valuing FX derivatives. The FX option routines are
very similar to the equity option routines we have already considered, the funda-
mental difference being that for FX routines there is both a domestic and foreign
currency. The FX routine calls the Black‚ÄìScholes routine with the dividend yield
set to the foreign currency risk free interest rate, and the supplied volatility is
that of the foreign/domestic exchange rate. In the market data Ô¨Åle the currency
FX spot rates are with respect to the base currency.
8.5.1
FX forward
Code excerpt 8.14 gives the C# code to compute the value of FX forwards.
using System;
namespace Computational_Lib
{
public class FXForwardDeal : BaseDeal
{
public double ForeignAmount { get { return fForeignAmount; }_
set { fForeignAmount = value; } }
// Note: Strike is the number of units of domestic currency required to
//
obtain one unit of foreign currency.
public double Strike { get { return fStrike; } set { fStrike = value; } }
public string ForeignCurrency { get { return fForeignCurrency; }_
set { fForeignCurrency = value; } }
public string DomesticCurrency { get { return fDomesticCurrency; }_
set { fDomesticCurrency = value; } }
public BuySell BuySell { get { return fBuySell; } set { fBuySell = value; } }
public double Settlement { get { return fSettlement; } set { fSettlement = value; } }
Code excerpt 8.14 C# code to compute the value of FX forwards.

C# portfolio pricing application
281
protected double fStrike
= 0;
protected string fForeignCurrency = "";
protected string fDomesticCurrency = "";
protected double fForeignAmount = 0;
protected BuySell fBuySell = BuySell.Buy;
protected double fSettlement = 0;
protected string pre_string = "";
public override string
Name()
{
return "FX Forward";
}
public override double Price()
{
double val=0.0;
Validate();
double sign = fBuySell == BuySell.Buy ? 1.0 : -1.0;
try
{
ICurve DF_F = CurrencyTable[fForeignCurrency].YieldCurve;
// obtain the discount factor
ICurve DF_D = CurrencyTable[fDomesticCurrency].YieldCurve;
// obtain the discount factor
double X_fb = CurrencyTable[fForeignCurrency].spot;
double X_db = CurrencyTable[fDomesticCurrency].spot;
double DF_f = DF_F[0,fSettlement];
double DF_d = DF_D[0,fSettlement];
val = fForeignAmount *( DF_f * X_fb - X_db * DF_d * fStrike);
val = val * sign;
}
catch(Exception ex)
{
throw new Exception(pre_string + " : " + ex.Message);
}
return val;
}
protected override void Validate()
{
pre_string = Name() + "
(" + fReference + ")";
}
}
}
Code excerpt 8.14 C# code to compute the value of FX forwards.
8.5.2
Single FX option
The code for the single FX option, given in Code excerpt 8.15, is very similar
to that for the single equity option. For example, European equity options are
priced using the call:
PricingUtils.black_scholes(ref val, IntPtr.Zero, s0, Strike_, Sigma_,
Time_To_Expiry_, RiskFreeRate, DividendYield_, put,
ref iflag);
while European FX options use:
PricingUtils.black_scholes(ref val, IntPtr.Zero, S0, Strike_b,Sigma_f_d_,
Time_To_Expiry_, DomesticRiskFreeRate_, ForeignRiskFreeRate_, put, ref iflag);

282
Computational Finance Using C and C#
using System;
namespace Computational_Lib
{
public class FXOptionDeal: BaseDeal
{
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
// Note: Strike is the number of units of domestic currency required to
//
obtain one unit of foreign currency.
public double Strike { get { return Strike_f_d_; } set { Strike_f_d_ = value; } }
// Volatility is that of the Foreign/Domestic exchange rate.
public double Volatility { get { return Sigma_f_d_; } set { Sigma_f_d_ = value; } }
public string ForeignCurrency { get { return ForeignCurrency_; }_
set { ForeignCurrency_ = value; } }
public string DomesticCurrency { get { return DomesticCurrency_; }_
set { DomesticCurrency_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public PutCall OptionType { get { return OptionType_; } set { OptionType_ = value; } }
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
protected double Strike_f_d_ = 0.0;
protected string ForeignCurrency_ = "";
protected string DomesticCurrency_ = "";
protected BuySell BuySell_ = BuySell.Buy;
protected int NumberOfUnits_ = 1;
protected PutCall OptionType_ = PutCall.Put;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected double Time_To_Expiry_ = 0.0;
protected double ForeignRiskFreeRate_ = 0.0;
protected double DomesticRiskFreeRate_ = 0.0;
protected double Sigma_f_d_ = 0.0;
protected string Pre_string_ = "";
public override string Name()
{
return "FX Option";
}
public override double Price()
{
Validate();
double val = 0.0;
double[] greeks = new double[6];
int iflag, put;
double discount_fac = 0.0;
double X_f_b = 0.0, X_d_b = 0.0;
double S0=0.0,Strike_b;
// Get domestic currency information
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[DomesticCurrency_].YieldCurve;
// obtain the domestic discount factor
discount_fac = DF[0, Time_To_Expiry_];
DomesticRiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
X_d_b = MarketDataDictionaries.CurrencyTable[DomesticCurrency_].spot;
Strike_b = X_d_b * Strike_f_d_;
// Strike_b is the Strike in base currency units
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ DomesticCurrency_);
}
Code excerpt 8.15 C# code to compute the value of FX options.

C# portfolio pricing application
283
// Get foreign currency information
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[ForeignCurrency_].YieldCurve;
// obtain the domestic discount factor
discount_fac = DF[0, Time_To_Expiry_];
ForeignRiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
X_f_b = MarketDataDictionaries.CurrencyTable[ForeignCurrency_].spot;
S0 = X_f_b;
// Foreign exchange wrt base currency
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ ForeignCurrency_);
}
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
if (ExerciseStyle_ == EuropeanAmerican.European)
// use BlackScholes
{
// Note: A null pointer is supplied so that the Greeks are not computed
// Dividend yield is set to foreign risk free rate
// Risk free interest rate is set to the domestic rate
// S0 the value of the "asset" in base cuurency units
// val is
the value of the FX option in base currency units
PricingUtils.black_scholes(ref val, IntPtr.Zero, S0, Strike_b, Sigma_f_d_,
Time_To_Expiry_,
DomesticRiskFreeRate_, ForeignRiskFreeRate_, put, ref iflag);
}
else
{
// Use Finite Difference Grid - Crank Nicolson
double theta = 0.5;
int is_american = 1;
// fix the geometry of the grid (these avluse should give "reasonable" results)
int ns = 50;
// 50 divisions on asset axis
int nt = 50;
// 50 divisions on time axis
double smax = 10.0 * S0;
PricingUtils.opt_gfd(theta, S0, Sigma_f_d_, DomesticRiskFreeRate_,
Time_To_Expiry_, Strike,
is_american, put, ref val, IntPtr.Zero, ForeignRiskFreeRate_, ns,
nt, smax, ref iflag);
// val is
the value of the FX option in base currency units
}
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
val *= NumberOfUnits_;
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than zero
years");
}
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
Code excerpt 8.15 (Continued).

284
Computational Finance Using C and C#
if (Strike_f_d_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
}
}
}
Code excerpt 8.15 (Continued).
It can be seen that, when pricing FX options, the foreign risk free rate is
used instead of the dividend yield, and the supplied volatility is that of the for-
eign/domestic exchange rate. Another difference is that the equity option value
val returned by the call to black_scholes is in domestic currency units, and
is then converted to base currency, while in the case of FX options the value
val is already in base currency units, and requires no conversion.
8.5.3
FX barrier option
The C# code for the Barrier option is given in Code excerpt 8.16.
using System;
namespace Computational_Lib
{
public class DownOutFXOptionDeal: BaseDeal
{
public int NumberOfUnits { get { return NumberOfUnits_; }_
set { NumberOfUnits_ = value; } }
// Note: Strike is the number of units of domestic currency required to obtain one
//
unit of foreign currency.
public double Strike { get { return Strike_f_d_; } set { Strike_f_d_ = value; } }
// Barrier is in the same units a the strike
public double Barrier_Level { get { return Barrier_f_d_; }_
set { Barrier_f_d_ = value; } }
// Volatiliy is that of the Foreign/Domestic exchange rate.
public double Volatility { get { return Sigma_f_d_; } set { Sigma_f_d_ = value; } }
public string ForeignCurrency { get { return ForeignCurrency_; }_
set { ForeignCurrency_ = value; } }
public string DomesticCurrency { get { return DomesticCurrency_; }_
set { DomesticCurrency_ = value; } }
public BuySell BuySell { get { return BuySell_; } set { BuySell_ = value; } }
public CalculationMethod CalcMethod { get { return CalcMethod_; }_
set { CalcMethod_ = value; } }
public EuropeanAmerican ExerciseStyle { get { return ExerciseStyle_; }_
set { ExerciseStyle_ = value; } }
public int NumberScenarios { get { return NumberScenarios_; }_
set { NumberScenarios_ = value; } }
public bool UseBrownianBridge { get { return UseBrownianBridge_; }_
set { UseBrownianBridge_ = value; } }
protected double Strike_f_d_ = 0.0;
protected double Barrier_f_d_ = 0.0;
protected string ForeignCurrency_ = "";
protected string DomesticCurrency_ = "";
protected BuySell BuySell_ = BuySell.Buy;
protected int NumberOfUnits_ = 1;
public double Time_To_Expiry { get { return Time_To_Expiry_; }_
set { Time_To_Expiry_ = value; } }
public PutCall OptionType { get { return OptionType; } set { OptionType_ = value; } }
protected PutCall OptionType_ = PutCall.Call;
protected double Time_To_Expiry_ = 0.0;
Code excerpt 8.16 C# code to compute the value of FX barrier options.

C# portfolio pricing application
285
protected double ForeignRiskFreeRate_ = 0.0;
protected double DomesticRiskFreeRate_ = 0.0;
protected double Sigma_f_d_ = 0.0;
protected EuropeanAmerican ExerciseStyle_ = EuropeanAmerican.European;
protected CalculationMethod CalcMethod_ = CalculationMethod.Analytic;
protected int TimeSteps_ = 300;
protected int NumberScenarios_ = 3000;
protected double S0_,Strike_b_,BarrierLevel_b_;
protected bool UseBrownianBridge_ = true;
protected string Pre_string_ = "";
public override string Name()
{
return "Down Out FX Option";
}
public override double Price()
{
Validate();
double val = 0.0;
int iflag, put, is_american;
double discount_fac = 0.0;
double X_f_b = 0.0, X_d_b = 0.0;
// Get domestic currency information
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[DomesticCurrency_].YieldCurve;
// obtain the domestic discount factor
discount_fac = DF[0, Time_To_Expiry_];
DomesticRiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
X_d_b = MarketDataDictionaries.CurrencyTable[DomesticCurrency_].spot;
Strike_b_ = X_d_b * Strike_f_d_;
// Strike is the Strike in base currency units
BarrierLevel_b_ = X_d_b * Barrier_f_d_;
BarrierLevel_b_ = Math.Max(BarrierLevel_b_, PricingUtils.EPS);
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ DomesticCurrency_);
}
// Get foreign currency information
try
{
ICurve DF = MarketDataDictionaries.CurrencyTable[ForeignCurrency_].YieldCurve;
// obtain the domestic discount factor
discount_fac = DF[0, Time_To_Expiry_];
ForeignRiskFreeRate_ = -Math.Log(discount_fac) / Time_To_Expiry_;
X_f_b = MarketDataDictionaries.CurrencyTable[ForeignCurrency_].spot;
S0_ = X_f_b;
// Foreign exchange wrt base currency
}
catch
{
throw new Exception(Pre_string_ + "--- No Market Data supplied for "
+ ForeignCurrency_);
}
iflag = 0;
put = OptionType_ == PutCall.Put ? 1 : 0;
is_american = ExerciseStyle_ == EuropeanAmerican.American ? 1 : 0;
if (CalcMethod_ == CalculationMethod.Analytic)
{
if (put == 1) throw new Exception(Pre_string_ + "--- Can‚Äôt price a put using
this calculation method");
if (is_american == 1) throw new Exception(Pre_string_ + "--- Can‚Äôt price an
American option using this calculation method");
// call C routine.
// Note: A null pointer is supplied so that the Greeks are not computed
// Dividend yield is set to foreign risk free rate
// Risk free interest rate is set to the domestic rate
Code excerpt 8.16 (Continued).

286
Computational Finance Using C and C#
// val is
the value of the FX option in base currency units
PricingUtils.bs_opt_barrier_downout_call(ref val, BarrierLevel_b_,
S0_, Strike_b_, Sigma_f_d_,
Time_To_Expiry_, DomesticRiskFreeRate_,
ForeignRiskFreeRate_, ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
}
else if (CalcMethod_ == CalculationMethod.Numeric)
{
if (put == 1) throw new Exception(Pre_string_ + "--- Can‚Äôt price a put using
this calculation method");
int n_sigma = 2;
// set up the parameters so that have "reasonable accuracy"
double[] sigma_array = new double[n_sigma];
double[] sigma_times = new double[n_sigma];
sigma_array[0] = Sigma_f_d_;
sigma_array[1] = Sigma_f_d_;
sigma_times[0] = 0.0;
sigma_times[1] = Time_To_Expiry_;
int nt = 100;
int ns_below_S0 = nt / 2;
int ns_above_S0 = nt / 2;
double theta_m = 0.5;
double UpperBarrierLevel = S0_ * 5.0;
iflag = 0;
// val is
the value of the FX option in base currency units
PricingUtils.dko_call(BarrierLevel_b_, UpperBarrierLevel,
theta_m, S0_, ref sigma_array[0], ref sigma_times[0],
n_sigma, DomesticRiskFreeRate_, Time_To_Expiry_,
Strike_b_, is_american, ref val,
IntPtr.Zero, ForeignRiskFreeRate_, ns_below_S0, ns_above_S0,
nt, ref iflag);
if (iflag != 0)
throw new Exception(Pre_string_ + "--- An error occurred in a call to the
pricing library");
}
else
{
bool is_put = (put == 1);
if (is_american == 1) throw new Exception(Pre_string_ + "--- Can‚Äôt price an
American option using this calculation method");
if (S0_ < BarrierLevel_b) // the option has already been knocked out
val = 0.0;
else
val = MonteCarloSim(is_put);
}
val *= NumberOfUnits_;
return val;
}
protected override void Validate()
{
Pre_string_ = Name() + "
(" + Reference_ + ")";
if (Time_To_Expiry_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Time to expiry cannot be less than
zero years");
}
Code excerpt 8.16 (Continued).

C# portfolio pricing application
287
if (NumberOfUnits_ < 0)
{
throw new Exception(Pre_string_ + "--- Number of units cannot be less than
zero");
}
if (Strike_f_d_ < 0.0)
{
throw new Exception(Pre_string_ + "--- The strike cannot be less than zero");
}
if (Barrier_f_d_ < 0.0)
{
throw new Exception(Pre_string_ + "--- BarrierLevel cannot be less than zero");
}
if (Sigma_f_d_ < 0.0)
{
throw new Exception(Pre_string_ + "--- Volatility cannot be less than zero");
}
}
private double MonteCarloSim(bool is_put)
{
// Use the Brownian Bridge to compute the value of a down and out call option
int seed = 111;
double[] asset_path = new double[TimeSteps_];
double time_step = Time_To_Expiry_ / TimeSteps_;
double sqrt_time_step = System.Math.Sqrt(time_step);
double disc = System.Math.Exp(-DomesticRiskFreeRate_ * Time_To_Expiry_);
PricingUtils.set_seed(seed);
double opt_val = 0.0;
bool not_out = true;
int k = 0;
double STN = 0.0;
double mean = (DomesticRiskFreeRate_ - ForeignRiskFreeRate_
- Sigma_f_d_ * Sigma_f_d_ * 0.5) * time_step;
double std = System.Math.Sqrt(Sigma_f_d_ * Sigma_f_d_ * time_step);
double z;
double sum_opt_vals = 0.0;
for (int i = 0; i < NumberScenarios_; ++i)
{
// generate the asset path
double ST1 = S0_;
not_out = true;
k = 0;
while (not_out && k < TimeSteps_)
{
z = PricingUtils.RndNorm(mean, std);
STN = ST1 * System.Math.Exp(z);
if (STN < BarrierLevel_b_) not_out = false;
ST1 = STN;
asset_path[k] = STN;
++k;
}
if (is_put)
{
opt_val = System.Math.Max(Strike_b_ - STN, 0.0);
}
else
{
opt_val = System.Math.Max(STN - Strike_b_, 0.0);
}
if (not_out)
{ // only has value if asset value is above the barrier_level
// compute the probability that the asset remained above the barrier
if (UseBrownianBridge)
{
double total_probability_above = 1.0, pr;
double sigma_2 = Sigma_f_d_ * Sigma_f_d_;
Code excerpt 8.16 (Continued).

288
Computational Finance Using C and C#
double log_barrier_level = System.Math.Log(BarrierLevel_b_);
double fac;
for (int jj = 0; jj < TimeSteps_ - 1; ++jj)
{
double log_S_i = System.Math.Log(asset_path[jj]);
double log_S_i1 = System.Math.Log(asset_path[jj + 1]);
fac = 2.0 * (log_barrier_level - log_S_i)
* (log_barrier_level - log_S_i1) / (sigma_2 * time_step);
pr = (1.0 - System.Math.Exp(-fac));
// probability of staying above the barrier between i and i+1
total_probability_above *= pr;
}
sum_opt_vals += total_probability_above * opt_val * disc;
}
else
{ // don‚Äôt use the Brownian Bridge
sum_opt_vals += opt_val * disc;
}
}
}
double temp = sum_opt_vals / (double)NumberScenarios_;
return temp;
}
}
}
Code excerpt 8.16 (Continued).

Appendix A:
The Greeks for vanilla European
options
A.1
Introduction
In this section we will present some useful results which will be used later on to
derive expressions for the Greeks.
A fundamental result of calculus is that:
‚àÇ
‚àÇx

f (x) dx = f (x)
(A.1.1)
Also the indeÔ¨Ånite integral,

f (x) dx, can be expressed as a deÔ¨Ånite integral
with variable upper bound as follows:

f (x) dx =
 x
a
f (x) dx + c
so
‚àÇ
‚àÇx
 y=x
y=a
f (y) dy = f (x)
(A.1.2)
We can now use this result to obtain the derivative of the cumulative distribution
function:
N1(x) =
1
‚àö
2œÄ
 y=x
y=‚àí‚àû
exp

‚àíy2
2

dy
which gives:
‚àÇN1(x)
‚àÇx
= n(x)
(A.1.3)
where
n(x) =
1
‚àö
2œÄ
exp

‚àíx2
2

We now derive various results for the parameters d1 and d2 which appear in
the Black‚ÄìScholes equation:
d1 = log(S/E) + (r ‚àíq + œÉ 2/2)(T ‚àít)
œÉ‚àöT ‚àít
(A.1.4)

290
Computational Finance Using C and C#
and
d2 = log(S/E) + (r ‚àíq ‚àíœÉ 2/2)(T ‚àít)
œÉ‚àöT ‚àít
= d1 ‚àíœÉ
‚àö
T ‚àít
(A.1.5)
We have:
‚àÇd2
‚àÇS = ‚àÇd1
‚àÇS =
1
SœÉ‚àöT ‚àít
(A.1.6)
‚àÇd2
‚àÇœÉ = ‚àÇd1
‚àÇœÉ ‚àí
‚àö
T ‚àít
(A.1.7)
‚àÇd1
‚àÇr = ‚àÇd2
‚àÇr =
‚àöT ‚àít
œÉ
(A.1.8)
‚àÇd2
‚àÇt = ‚àÇd1
‚àÇt +
œÉ
2(T ‚àít)
(A.1.9)
Also:
n(d2) =
1
‚àö
2œÄ
exp

‚àíd2
2
2

=
1
‚àö
2œÄ
exp

‚àíd2
1
2

exp

œÉd1
‚àö
T ‚àít ‚àíœÉ 2(T ‚àít)
2

= n(d1) exp

log
 S
E

+

r ‚àíq + œÉ 2
2

(T ‚àít) ‚àíœÉ 2(T ‚àít)
2

so
n(d2) = S
E n(d1) exp

r(T ‚àít)

exp

‚àíq(T ‚àít)

(A.1.10)
We note that:
‚àÇN1(d1)
‚àÇS
= ‚àÇN1(d1)
‚àÇd1
‚àÇd1
‚àÇS = n(d1)
1
SœÉ‚àöT ‚àít
This technique will be used for computing the Greeks.
A.2
Gamma
Gamma is deÔ¨Åned as the second derivative of the option value with respect to
the underlying stock price. This means (see Section A.3) it is the rate of change
of delta with the underlying stock price.
For a European call the value of gamma is:
Œìc = ‚àÇ2c
‚àÇS2 = ‚àÇŒîc
‚àÇS = ‚àÇ
‚àÇS

N1(d1) exp

‚àíq(T ‚àít)

where the value of Œîc is given in Section A.3. So
Œìc = exp

‚àíq(T ‚àít)
‚àÇN1(d1)
‚àÇS
= exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇS

Appendix A: The Greeks for vanilla European options
291
Therefore:
Œìc =
n(d1)
SœÉ‚àöT ‚àít
exp

‚àíq(T ‚àít)

(A.2.1)
The value of gamma for a European put can be calculated similarly:
Œìp = ‚àÇ2p
‚àÇS2 = ‚àÇŒîp
‚àÇS
= ‚àÇ
‚àÇS

N1(d1) ‚àí1

exp

‚àíq(T ‚àít)

where we have used the value of Œîp, derived in Section A.3. Therefore:
Œìp = exp

‚àíq(T ‚àít)
‚àÇ(N1(d1) ‚àí1)
‚àÇS
= exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇS
So
Œìp = Œìc =
n(d1)
SœÉ‚àöT ‚àít
exp

‚àíq(T ‚àít)

(A.2.2)
So the value of gamma for both a put and a call is the same.
A.3
Delta
Delta is deÔ¨Åned as the rate of change of option value with the underlying stock
price.
For a European call we have:
Œîc = ‚àÇc
‚àÇS = ‚àÇ
‚àÇS

S exp

‚àíq(T ‚àít)

N1(d1) ‚àíE exp

‚àír(T ‚àít)

N1(d2)

So
Œîc = exp

‚àíq(T ‚àít)

N1(d1) + Sn(d1)‚àÇd1
‚àÇS

‚àíE exp

‚àír(T ‚àít)

n(d2)‚àÇd2
‚àÇS
(A.3.1)
Substituting for n(d2) and ‚àÇd2
‚àÇS we obtain:
Œîc = exp

‚àíq(T ‚àít)

N1(d1)
(A.3.2)
In similar manner we have for a European put:
Œîp = ‚àÇp
‚àÇS
= ‚àÇ
‚àÇS

E exp

‚àír(T ‚àít)

1 ‚àíN1(d2)

‚àíS exp

‚àíq(T ‚àít)

1 ‚àíN1(d1)

So
Œîp = ‚àíE exp

‚àír(T ‚àít)

n(d2)‚àÇd2
‚àÇS
‚àíexp

‚àíq(T ‚àít)

1 ‚àíN1(d1)

+ Sn(d1)‚àÇd1
‚àÇS

(A.3.3)

292
Computational Finance Using C and C#
Substituting for n(d2) and ‚àÇd2
‚àÇS we obtain:
Œîp = exp

‚àíq(T ‚àít)

N1(d1) ‚àí1

(A.3.4)
A.4
Theta
Theta is deÔ¨Åned as the rate of change of the option value with time.
For a European call option we have:
Œòc = ‚àÇc
‚àÇt = ‚àÇ
‚àÇt

S exp

‚àíq(T ‚àít)

N1(d1) ‚àíE exp

‚àír(T ‚àít)

N1(d2)

= q exp

‚àíq(T ‚àít)

SN1(d1) + exp

‚àíq(T ‚àít)

Sn(d1)‚àÇd1
‚àÇt
‚àírE exp

‚àír(T ‚àít)

N1(d2) ‚àíE exp

‚àír(T ‚àít)

n(d2)‚àÇd2
‚àÇt
Substituting for n(d2) and ‚àÇd2
‚àÇt we obtain:
Œòc = q exp

‚àíq(T ‚àít)

SN1(d1) ‚àírE exp

‚àír(T ‚àít)

N1(d2)
+ exp

‚àíq(T ‚àít)

Sn(d1)‚àÇd1
‚àÇt
‚àíE exp

‚àír(T ‚àít)

n(d1) S
E exp

r(T ‚àít)

√ó exp

‚àíq(T ‚àít)
‚àÇd1
‚àÇt +
œÉ
2(T ‚àít)

= q exp

‚àíq(T ‚àít)

SN1(d1)
‚àírE exp

‚àír(T ‚àít)

N1(d2) ‚àíSn(d1)œÉ exp(‚àíq(T ‚àít))
2‚àöT ‚àít
Therefore the value of theta is:
Œòc = exp

‚àíq(T ‚àít)

q ‚àíSN1(d1) Sn(d1)œÉ
2‚àöT ‚àít

‚àírE exp

‚àír(T ‚àít)

N1(d2)
(A.4.1)
For a put we can similarly show that
Œòp = ‚àÇp
‚àÇt = ‚àÇ
‚àÇt

E exp

‚àír(T ‚àít)

1 ‚àíN1(d2)

‚àíS exp

‚àíq(T ‚àít)

1 ‚àíN1(d1)

Œòp = rE exp

‚àír(T ‚àít)

1 ‚àíN1(d2)

‚àíE exp

‚àír(T ‚àít)

n(d2)‚àÇd2
‚àÇt
‚àíqS exp

‚àíq(T ‚àít)

1 ‚àíN1(d1)

+ S exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇt
Substituting for n(d2) and ‚àÇd2
‚àÇt we obtain:

Appendix A: The Greeks for vanilla European options
293
Œòp = rE exp

‚àír(T ‚àít)

N1(‚àíd2) ‚àíqS exp

‚àíq(T ‚àít)

N1(‚àíd1)
‚àíE exp

‚àír(T ‚àít)

exp

r(T ‚àít)

√ó exp

‚àíq(T ‚àít)

n(d1) S
E
‚àÇd1
‚àÇt +
œÉ
2(T ‚àít)

+ S exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇt
So we have:
Œòp = ‚àíexp

‚àíq(T ‚àít)

qSN1(‚àíd1) + Sn(d1)œÉ
2
‚àö
T ‚àít

+ rE exp

‚àír(T ‚àít)

N1(‚àíd2)
(A.4.2)
A.5
Rho
Rho is the rate of change of the option value with interest rate.
For a call we have:
œÅc = ‚àÇc
‚àÇr = ‚àÇ
‚àÇr

S exp

‚àíq(T ‚àít)

N1(d1) ‚àíE exp

‚àír(T ‚àít)

N1(d2)

= S exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇr + E(T ‚àít)N1(d2)
‚àíE exp

‚àír(T ‚àít)

n(d2)‚àÇd2
‚àÇr
Substituting for n(d2) and ‚àÇd2
‚àÇr we obtain:
œÅc = E(T ‚àít)N1(d2)
(A.5.1)
For a European put we have:
œÅp = ‚àÇp
‚àÇr
= ‚àÇ
‚àÇr

E exp

‚àír(T ‚àít)

1 ‚àíN1(d2)

‚àíS exp

‚àíq(T ‚àít)

1 ‚àíN1(d2)

= ‚àíE(T ‚àít)

1 ‚àíN1(d2)

‚àíE exp

‚àír(T ‚àít)

n(d2)‚àÇd2
‚àÇr
+ S exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇr
= ‚àíE(T ‚àít)N1(‚àíd2) ‚àíE exp

‚àír(T ‚àít)

n(d2)‚àÇd2
‚àÇr
+ S exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇr
Substituting for n(d2) and ‚àÇd2
‚àÇr we obtain:
œÅp = ‚àíE(T ‚àít)N1(‚àíd2)
(A.5.2)

294
Computational Finance Using C and C#
A.6
Vega
Vega is the rate of change of option value with volatility. For a call we have:
Vc = ‚àÇc
‚àÇœÉ
= ‚àÇ
‚àÇœÉ

S exp

‚àíq(T ‚àít)

N1(d1) ‚àíE exp

‚àír(T ‚àít)

N1(d2)

= S exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇœÉ ‚àíE exp

‚àír(T ‚àít)

n(d2)‚àÇd2
‚àÇr
(A.6.1)
Substituting for n(d2) and ‚àÇd2
‚àÇœÉ we obtain:
Vc = S exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇœÉ
‚àíSn(d1) exp

‚àíq(T ‚àít)
‚àÇd1
‚àÇœÉ ‚àí
‚àö
T ‚àít

Therefore
Vc = S exp

‚àíq(T ‚àít)

n(d1)
‚àö
T ‚àít
(A.6.2)
For a European put we have:
Vp = ‚àÇc
‚àÇœÉ
= ‚àÇ
‚àÇœÉ

E exp

‚àír(T ‚àít)

1 ‚àíN1(d2)

‚àíS exp

‚àíq(T ‚àít)

1 ‚àíN1(d1)

= ‚àíE exp

‚àír(T ‚àít)

n(d2)‚àÇd2
‚àÇœÉ + S exp

‚àíq(T ‚àít)

n(d1)‚àÇd1
‚àÇœÉ
Substituting for n(d2) and ‚àÇd2
‚àÇœÉ we obtain:
Vp = S exp

‚àíq(T ‚àít)

n(d1)
‚àö
T ‚àít
(A.6.3)
which is the same as for a call.

Appendix B:
Barrier option integrals
B.1
The down and out call
We will now derive the formula for the value cdo of a European down and out
call option with dividend yield q when the strike, E, satisÔ¨Åes E > B.
cdo = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)

S exp(X) ‚àíE

f (X > B) dX
(B.1.1)
Substituting for f (X > B) we have cdo = IA + IB where:
IA = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)

S exp(X) ‚àíE

√ó exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
and
IB = ‚àíexp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)

S exp(X) ‚àíE

√ó exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

dX
Now comparing IA with Eq. (4.4.54) we can identify IA as c, the price of a
European call. That is:
IA = S exp(‚àíqœÑ)N1(d1) ‚àíE exp(‚àírœÑ)N1(d2)
(B.1.2)
where:
d1 = log(S/E) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
d2 = log(S/E) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
We now consider the term IB, and let IB = IC + ID where:

296
Computational Finance Using C and C#
IC = ‚àíS exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp(X) exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

dX
and
ID = E exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

dX
We will Ô¨Årst consider ID and factor the integrand as follows:
‚àíexp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

= exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2 ‚àí4 log(B/S)(X ‚àílog(B/S))
2œÉ 2œÑ

= exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àí2 log(B/S)}2
2œÉ 2œÑ

√ó exp
4(r ‚àíq ‚àíœÉ 2/2)œÑ log(B/S)
2œÉ 2œÑ

(B.1.3)
This means that ID can be expressed as:
‚à¥ID =
B
S
2((r‚àíq)œÉ 2/2)/œÉ 2 E exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
√ó
 ‚àû
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíqœÉ 2/2)œÑ ‚àí2 log(B/S)}2
2œÉ 2œÑ

dX
Letting u = (X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àí2 log(B/S))/(œÉ‚àöœÑ) we have dX = œÉ‚àöœÑ du
and
ID =
B
S
2(r‚àíq‚àíœÉ 2/2)/œÉ 2 E exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
u=k3
exp

‚àíu2
2

du
where
k3 = log(E/S) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àí2 log(B/S)
œÉ‚àöœÑ
= log(ES/B2) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
So
ID =
B
S
2r/œÉ 2‚àí1
E exp(‚àírœÑ)N1(‚àík3)
(B.1.4)

Appendix B: Barrier option integrals
297
Letting d3 = ‚àík3 we have:
d3 = log(B2/SE) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
and
ID =
B
S
2r/œÉ 2‚àí1
E exp(‚àírœÑ)N1(d3)
(B.1.5)
Now consider the term:
IC = S exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 ‚àû
X=log(E/S)
exp(X) exp

‚àí{X ‚àí(r ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

dX
Now we have
exp(X) exp

‚àí(X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ)2
2œÉ 2œÑ

exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

= exp

‚àí

X ‚àí

‚àíqr ‚àíœÉ 2/2

œÑ
2 ‚àí2œÉ 2œÑX
‚àí4 log(B/S)X + 4

log(B/S)
2
/

2œÉ 2œÑ

= exp

œÉ 2œÑ
2 + 2

r ‚àíq ‚àíœÉ 2/2

œÑ 2œÉ 2
+ 4

r ‚àíq ‚àíœÉ 2/2

œÑ log(B/S) + 4œÉ 2œÑ log(B/S)

/

2œÉ 2œÑ

√ó exp
‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àíœÉ 2œÑ ‚àí2 log(B/S)}2
2œÉ 2œÑ

= exp

(r ‚àíq)œÑ

exp
2(r ‚àíq)
œÉ 2
+ 1

log
B
S

√ó exp
‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àíœÉ 2œÑ ‚àí2 log(B/S)}2
2œÉ 2œÑ

= exp

(r ‚àíq)œÑ
B
S
2(r‚àíq)/œÉ 2+1
√ó exp
‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àíœÉ 2œÑ ‚àí2 log(B/S)}2
2œÉ 2œÑ

So we have:
IC = ‚àí
B
S
2(r‚àíq)/œÉ 2+1 S exp(‚àíqœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
√ó
 ‚àû
X=log(E/S)
exp

‚àí

X ‚àí

r ‚àíq ‚àíœÉ 2/2

œÑ ‚àíœÉ 2œÑ ‚àí2 log(B/S)
2
√ó

2œÉ 2œÑ
‚àí1
dX

298
Computational Finance Using C and C#
Letting
u = X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àíœÉ 2œÑ ‚àí2 log(B/S)
œÉ‚àöœÑ
we have dX = œÉ‚àöœÑ du and
IC = ‚àíS exp(‚àíqœÑ)
B
S
2(r‚àíq)/œÉ 2+1
N1(‚àík4)
(B.1.6)
where
k4 = log(E/S) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àíœÉ 2œÑ ‚àí2 log(B/S)
œÉ‚àöœÑ
= log(ES/B2) ‚àí(r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
‚à¥IC = ‚àíS exp(‚àíqœÑ)
B
S
2(r‚àíq)/œÉ 2+1
N1(‚àík4)
or letting d4 = ‚àík4 we have
d4 = log(B2/ES) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
IC = ‚àíS exp(‚àíqœÑ)
B
S
2(r‚àíq)/œÉ 2+1
N1(d4)
(B.1.7)
Therefore the value for the down and out call option is:
cdo = IA + IC + ID = IA ‚àí(‚àíIC ‚àíID)
Since cdo + cdi = c, where c is the value of vanilla call and cdi is the value of
down and in call, we can write:
cdo = c ‚àícdi
where
cdi = S exp(‚àíqœÑ)N1(d4)
B
S
2(r‚àíq)/œÉ 2+1
‚àíE exp(‚àírœÑ)N1(d3)
B
S
2(r‚àíq)/œÉ 2‚àí1
B.2
The up and out call
We will now derive the formula for a European up and out call option with
dividend yield q when the strike, E, satisÔ¨Åes B > E.
cuo = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 log(B/S)
X=log(E/S)

S exp(X) ‚àíE

f (X < B) dX
(B.2.1)

Appendix B: Barrier option integrals
299
Substituting for f (X < B) we have cuo = IA + IB where:
IA = exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 log(B/S)
X=log(E/S)

S exp(X) ‚àíE

√ó exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
and
IB = ‚àíexp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
√ó
 log(B/S)
X=log(E/S)

S exp(X) ‚àíE

exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

dX
Letting IA = I1 + I2 where
I1 = S exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 log(B/S)
X=log(E/S)
exp(X) exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
and
I2 = ‚àíE exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 log(B/S)
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

dX
From our previous derivation of the Black‚ÄìScholes formula in Chapter 4 we
have:
I1 = S exp(‚àíqœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 k2
u=k1
exp

‚àíu2
2

du = S exp(‚àíqœÑ)

N1(k2) ‚àíN1(k1)

where
k1 = log(E/S) ‚àí(r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
and
k2 = log(B/S) ‚àí(r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
I2 = ‚àíE exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 k4
u=k3
exp

‚àíu2
2

du = ‚àíE exp(‚àírœÑ)

N1(k4) ‚àíN1(k3)

where
k3 = log(E/S) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
and
k4 = log(B/S) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ

300
Computational Finance Using C and C#
Therefore,
IA = S exp(‚àíqœÑ)

N1(k2) ‚àíN1(k1)

‚àíE exp(‚àírœÑ)

N1(k4) ‚àíN1(k3)

Since N1(‚àíx) = 1 ‚àíN1(x) we have
N1(k2) ‚àíN1(k1) = N1(‚àík1) ‚àíN1(‚àík2)
so
IA = S exp(‚àíqœÑ)

N1(d1) ‚àíN1(d2)

‚àíE exp(‚àírœÑ)

N1(d3) ‚àíN1(d4)

= S exp(‚àíqœÑ)N1(d1) ‚àíE exp(‚àírœÑ)N1(d3)
‚àíS exp(‚àíqœÑ)N1(d2) + E exp(‚àírœÑ)N1(d4)
which gives:
IA = c ‚àíS exp(‚àíqœÑ)N1(d2) + E exp(‚àírœÑ)N1(d4)
(B.2.2)
where c is the value of a vanilla call and
d1 = log(S/E) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
,
d2 = log(S/B) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
d3 = log(S/E) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
,
d4 = log(S/B) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
Letting IB = IC + ID where:
IC = ‚àíS exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 log(B/S)
X=log(E/S)
exp(X) exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

dX
and
ID = E exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 log(B/S)
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

dX
In a similar manner to that in Section B.1 we have:
ID =
B
S
2(r‚àíq‚àíœÉ 2/2)/œÉ 2 E exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
√ó
 log(B/S)
X=log(E/S)
exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àí2 log(B/S)}2
2œÉ 2œÑ

dX
Letting
u = X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àí2 log(B/S)
œÉ‚àöœÑ

Appendix B: Barrier option integrals
301
gives
ID =
B
S
2(r‚àíq‚àíœÉ 2/2)/œÉ 2 E exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 k6
u=k5
exp

‚àíu2
2

du
(B.2.3)
where
k5 = log(E/S) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àí2 log(B/S)
œÉ‚àöœÑ
= log(ES/B2) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
and
k6 = log(B/S) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àí2 log(B/S)
œÉ‚àöœÑ
= log(S/B) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
and so
ID =
B
S
2(r‚àíq)/œÉ 2‚àí1
E exp(‚àírœÑ)

N1(k6) ‚àíN1(k5)

This can be re-expressed as:
ID =
B
S
2(r‚àíq)/œÉ 2‚àí1
E exp(‚àírœÑ)

N1(d5) ‚àíN1(d6)

(B.2.4)
where
d5 = log(B2/ES) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
d6 = log(B/S) + (r ‚àíq ‚àíœÉ 2/2)œÑ
œÉ‚àöœÑ
We now consider the term:
IC = ‚àíS exp(‚àírœÑ)
œÉ‚àöœÑ
‚àö
2œÄ
 log(B/S)
X=log(E/S)
exp(X) exp

‚àí{X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ}2
2œÉ 2œÑ

√ó exp
2 log(B/S)(X ‚àílog(B/S))
œÉ 2œÑ

dX
In a similar manner to Section B.1 we let
u = X ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àíœÉ 2œÑ ‚àí2 log(B/S)
œÉ‚àöœÑ
which gives:
IC = ‚àíS exp(‚àírœÑ)
B
S
2(r‚àíq)/œÉ 2+1
N1(k8) ‚àíN1(k7)


302
Computational Finance Using C and C#
where
k7 = log(E/S) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àíœÉ 2œÑ ‚àí2 log(B/S)
œÉ‚àöœÑ
= log(ES/B2) ‚àí(r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
and
k8 = log(B/S) ‚àí(r ‚àíq ‚àíœÉ 2/2)œÑ ‚àíœÉ 2œÑ ‚àí2 log(B/S)
œÉ‚àöœÑ
= log(S/B) ‚àí(r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
This can be re-expressed as:
IC = ‚àíS exp(‚àírœÑ)
B
S
2(r‚àíq)/œÉ 2+1
N1(d7) ‚àíN1(d8)

where
d7 = log(B2/ES) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
,
d8 = log(B/S) + (r ‚àíq + œÉ 2/2)œÑ
œÉ‚àöœÑ
So we have:
cuo = IA + IC + ID
which can be written as:
cuo = c ‚àícui
where c is the value of a vanilla call and cui, the value of an up and in call, is
given by:
cui = S exp(‚àíqœÑ)N1(d2) ‚àíE exp(‚àírœÑ)N1(d4)
‚àíE exp(‚àírœÑ)

N1(d5) ‚àíN1(d6)
B
S
2(r‚àíq)/œÉ 2‚àí1
+ S exp(‚àírœÑ)

N1(d7) ‚àíN1(d8)
B
S
2(r‚àíq)/œÉ 2+1
(B.2.5)

Appendix C:
Standard statistical results
C.1
The law of large numbers
Let x1, x2, . . . be a sequence of independent, identically distributed random vari-
ables (IID), each with expected value Œº and variance œÉ 2. DeÔ¨Åne the sequence of
averages
yn =

n
i=1 xi
n
= x1 + x2 + ¬∑ ¬∑ ¬∑ + xn
n
,
n = 1, 2, . . .
Then the law of large numbers states that yn converges to Œº as n ‚Üí‚àû, that is
Var[yn] ‚Üí0.
The mean of yn is:
E[yn] = 1
n

E[x1] + E[x2] + ¬∑ ¬∑ ¬∑ + E[xn]

= 1
nnŒº = Œº
For the variance of yn we have:
Var[yn] = Var

n
i=1 xi
n

= 1
n2 Var
 n

i=1
xi
	
= 1
n2
n

i=1
Var[xi] = 1
n2 nœÉ 2 = œÉ 2
n
where we have used the fact that the variance of the sum of independent random
variables is the sum of their variances; see Section C.2.
We have therefore shown that as n ‚Üí‚àû, Var[yn] ‚Üí0.
C.2
The central limit theorem
Let x1, x2, . . . be a sequence of independent, identically distributed random vari-
ables (IID), each with expected value Œº and variance œÉ 2. If we deÔ¨Åne ui = xi ‚àíŒº
then:
E[ui] = E[u] = 0,
Var[ui] = E

u2
= œÉ 2

304
Computational Finance Using C and C#
Let
sn =
n

i=1
ui + nŒº
So
sn =
n

i=1
xi
We now introduce the normalized value zn, as follows:
zn = sn ‚àínŒº
œÉ‚àön
=
1
œÉ‚àön
n

i=1
ui
The central limit theorem states that as n tends to inÔ¨Ånity the probability distri-
bution of zn tends to a normal distribution with zero mean and unit variance;
mathematically zn ‚ÜíN(0, 1) as n ‚Üí‚àû.
Proof. From Section C.5, Eq. (C.5.3)
Mzn = E

exp(tzn)

= E

exp

t
œÉ‚àön
n

i=1
ui
	
and using Eq. (C.5.5)
Mzn =

Mu

t
œÉ‚àön
n
Equation (C.5.1) then yields:
Mu

t
œÉ‚àön

‚âà1 +
t
œÉ‚àönE[u] + 1
2

t
œÉ‚àön
2
E

u2
+ ¬∑ ¬∑ ¬∑
As n ‚Üí‚àû,
t
œÉ‚àön ‚Üí0 and
Mu

t
œÉ‚àön

‚Üí1 +
t
œÉ‚àönE[u] + 1
2

t
œÉ‚àön
2
E

u2
= 1 + t2
2n
Thus 
Mu

t
œÉ‚àön
n
=

1 + t2
2n
n
‚Üí1 + t2
2
as n ‚Üí‚àû
where we have used the fact that t ‚â™1; see Grimmett and Welsh (1986).
We have therefore shown that as n ‚Üí‚àû
Mzn(t) ‚Üí1 + t2
2 ‚Üíet2/2
However, from Section D.1 the moment generating function Mz(t) for a stan-
dard normal distribution (Œº = 0, œÉ 2 = 1) is:
Mz(t) = et2/2
where z ‚àºN(0, 1)
Thus we have proved that zn ‚ÜíN(0, 1) as n ‚Üí‚àû.
‚ñ°

Appendix C: Standard statistical results
305
C.3
The variance and covariance of random variables
C.3.1
Variance
One variable
Let X be a variate from a given distribution, and Z be the following linear
function of this variate:
Z = a + bX
where and a and b are constants. Then
E[Z] = E[a] + E[bX] = a + bE[X]
and
Var[Z] = E

Z ‚àíE[Z]
2
= E

a + bX ‚àía ‚àíbE[X]
2
= E

bX ‚àíbE[X]
2
= E

b2
X ‚àíE[X]
2
= b2E

X ‚àíE[X]
2
Therefore the mean is a + bE[X], and the variance is b2 Var[X].
Two variables
Let Z = a + b1X1 + b2X2, where a, b1 and b2 are constants.
Then the mean is E[Z] = E[a]+E[b1X1]+E[b2X2] = a+b1E[X1]+b2E[X2].
The variance Var[Z] is computed as follows:
Var[Z] = E

a + b1X1 + b2X2 ‚àía ‚àíb1E[X1] ‚àíb2E[X2]
2
= E

b1

X1 ‚àíE[X1]

+ b2

X2 ‚àíE[X2]
2
= b2
1E

X1 ‚àíE[X1]
2
+ b2
2E

X2 ‚àíE[X2]
2
+ 2b1b2E

X1 ‚àíE[X1]

E

X2 ‚àíE[X2]

= b2
1 Var[X1] + b2
2 Var[X2] + 2b1b2 Cov[X1, X2]
where Cov[X1, X2] is the covariance between X1 and X2. If X1 and X2 are iden-
tical independently distributed random variables (IID) then Cov[X1, X2] = 0,
and we thus have:
Var[Z] = b2
1 Var[X1] + b2
2 Var[X2]

306
Computational Finance Using C and C#
Three variables
Let Z = a + b1X1 + b2X2 = b3X3, where a, b1, b2 and b3 are constants.
Then the mean is E[Z] = E[a]+E[b1X1]+E[b2X2]+E[b3X3] = a+b1E[X1]+
b2E[X2] + b3E[X3].
The variance Var[Z] is computed as follows:
Var[Z] = E

a + b1X1 + b2X2 + b3X3 ‚àía
‚àíb1E[X1] ‚àíb2E[X2] ‚àíb3E[X3]
2
= E

b1

X1 ‚àíE[X1]

+ b2

X2 ‚àíE[X2]

+ b3

X3 ‚àíE[X3]
2
= b2
1E

X1 ‚àíE[X1]
2
+ b2
2E

X2 ‚àíE[X2]
2
+ b2
3E

X3 ‚àíE[X3]
2
+ 2b1b2E

X1 ‚àíE[X1]

E

X2 ‚àíE[X2]

+ 2b2b3E

X2 ‚àíE[X2]

E

X3 ‚àíE[X3]

+ 2b1b3E

X1 ‚àíE[X1]

E

X3 ‚àíE[X3]

= b2
1 Var[X1] + b2
2 Var[X2] + b2
3 Var[X2] + 2b2b3 Cov[X2, X3]
+ 2b1b2 Cov[X2, X3] + 2b1b3 Cov[X1, X3]
If X1, X2 and X3 are IID all the covariance terms are zero and the variance is:
Var[Z] = b2
1 Var[X1] + b2
2 Var[X2] + b2
3 Var[X3]
Variance of n variables
We will now derive an expression for the sum of n IID random variables.
Let Z = a + 
n
i=1 biXi, where a and bi, i = 1, . . . , n, are constants.
Then we have: E[Z] = E[a] + E[
n
i=1 biXi] = a + 
n
i=1 biE[Xi] and
Var[Z] = E

a +
n

i=1
biXi ‚àía ‚àí
n

i=1
biE[Xi]
2	
= E
 n

i=1
biXi ‚àí
n

i=1
biE[Xi]
2	
= E
 n

i=1
bi

Xi ‚àíE[Xi]

2	
=
n

i=1
b2
i E

Xi ‚àíE[Xi]
2
+
n

i=1
n

j=1(jÃ∏=i)
bibjE

Xi ‚àíE[Xi]

Xj ‚àíE[Xj]


Appendix C: Standard statistical results
307
=
n

i=1
b2
i Var[Xi] +
n

i=1
n

j=1(jÃ∏=i)
bibj Cov[Xi, Xj]
As before if all the X variables are IID then the covariance terms are zero, and
we have:
Var[Z] =
n

i=1
b2
i Var[xi]
If in addition all the bi terms are one and all the X variable have variance œÉ 2 we
obtain:
Var[Z] =
n

i=1
Var[xi] = nœÉ 2
C.3.2
Covariance
The covariance between two variables X and Y is deÔ¨Åned by:
Cov[X, Y] = E

X ‚àíE[X]

Y ‚àíE[Y]

= E

XY ‚àíYE[X] ‚àíXE[Y] + E[X]E[Y]

= E[XY] ‚àíE[Y]E[X] ‚àíE[X]E[Y] + E[X]E[Y]
= E[XY] ‚àíE[X]E[Y]
By symmetry it can be seen that Cov[X, Y] = Cov[Y, X].
Two variables
Let Z1 = a + bX and Z2 = c + dY, where a, b, c and d are constants.
We have:
Cov[Z1, Z2] = Cov[a + bX, c + dY]
= E

(a + bX)(c + dY)

‚àíE

(a + bX)

E

(c + dY)

= E[ac + bcX + adY + bdXY] ‚àí

a + bE[X]

c + dE[Y]

= ac + bcE[X] + adE[Y] + bdE[XY]
‚àíac + bcE[X] ‚àíadE[Y] ‚àíbdE[X]E[Y]
= bd

E[XY] ‚àíE[X]E[Y]

‚à¥Cov[Z1, Z2] = bd Cov[X, Y]
Three variables
Let Z1 = a+b1X1+b2X2 and Z2 = c+dY, where a, b1, b2, c and d are constants.

308
Computational Finance Using C and C#
We have:
Cov[Z1, Z2] = Cov[a + b1X1 + b2X2, c + dY]
= E

(a + b1X1 + b2X2)(c + dY)

‚àíE

(a + b1X1 + b2X2)

E

(c + dY)

= E

(a + b1X1)(c + dY) + b2X2(c + dY)

‚àí

E

(a + b1X1)

E[c + dY] + E[b2X2]E[c + dY]

= E

(a + b1X1)(c + dY)

+ E

b2X2(c + dY)

‚àíE

(a + b1X1)

E[c + dY] ‚àíE[b2X2]E[c + dY]
=

E

(a + b1X1)(c + dY)

‚àíE

(a + b1X1)

E[c + dY]

‚àí

E

(b2X2)(c + dY)

‚àíE[b2X2)]E[c + dY]

‚à¥Cov[Z1, Z2] = b1d Cov[X1, Y] + b2d Cov[X2, Y]
Four variables
Let Z1 = a + b1X1 + b2X2 + b3X3 and Z2 = c + dY, where a, b1, b2, b3, c and d
are constants.
We have:
Cov[Z1, Z2] = Cov[a + b1X1 + b2X2 + b3X3, c + dY]
= E

(a + b1X1 + b2X2 + b3X3)(c + dY)

‚àíE

(a + b1X1 + b2X2 + b3X3)

E

(c + dY)

= E

(a + b1X1 + b2X2)(c + dY) + b3X3(c + dY)

‚àí

E

(a + b1X1 + b2X2)

E[c + dY] + E[b3X3]E[c + dY]

= E

(a + b1X1 + b2X2)(c + dY)

+ E

b3X3(c + dY)

‚àíE

(a + b1X1 + b2X2)

E[c + dY] ‚àíE[b3X3]E[c + dY]
=

E

(a + b1X1 + b2X2)(c + dY)

‚àíE

(a + b1X1 + b2X2)

E[c + dY]

+

E

(b3X3)(c + dY)

‚àíE[b3X3]E[c + dY]

= Cov

(a + b1X1 + b2X2), c + dY

+ Cov[b3X3, c + dY]
‚à¥Cov[Z1, Z2] = b1d Cov[X1, Y] + b2d Cov[X2, Y] + b3d Cov[X3, Y]
Covariance of n variables
In a similar manner to that outlined above:
Cov

a +
n

i=1
biXi, c + dY
	
= d
n

i=1
bi Cov[Xi, Y]

Appendix C: Standard statistical results
309
For the most general case let: Z1 = a + 
n
i=1 biXi and Z2 = c + 
M
j=1 bjYj.
So
Cov[Z1, Z2] = Cov

a +
n

i=1
biXi, c +
M

j=1
djYj
	
= Cov

a +
n

i=1
biXi, c +
M

j=1
djYj
	
So
Cov

a +
n

i=1
biXi, c +
M

j=1
djYj
	
=
n

i=1
Cov

biXi,
M

j=1
djYj
	
=
n

i=1
bi Cov

Xi,
M

j=1
djYj
	
=
n

i=1
bi Cov
 M

j=1
djYj, Xi
	
‚à¥Cov[Z1, Z2] =
n

i=1

bi
M

j=1
dj Cov[Yj, Xi]

C.3.3
Covariance matrix
Let X denote the n element vector containing the random variates Xi, i =
1, . . . , n. The mean and variance of the ith variate is then E[Xi] and E[(Xi ‚àí
E[Xi])2] respectively. The covariance Cov[X]ij between the ith and jth vari-
ates is E[(Xi ‚àíE[Xi])(Xj ‚àíE[Xj])]. The elements of n by n covariance matrix
Cov[X] are then:
Cov[X]ij = E

Xi ‚àíE[Xi]

Xj ‚àíE[Xj]

,
i = 1, . . . , n, j = 1, . . . , n
(C.3.1)
We will now show that Cov[X + A] = Cov[X] where A is an n element vector
containing the constants Ai, i = 1, . . . , n. Since E[Xi + Ai] = E[Xi] + Ai we
obtain:
Var

(X + A)i

= Var[Xi + Ai]
= E

Xi + Ai ‚àíE[Xi + Ai]
2
= E

Xi ‚àíE[Xi]
2
and
Cov[X + A]ij = E

Xi + Ai ‚àíE[Xi + Ai]

Xj + Aj ‚àíE[Xj + Aj]

= E

Xi ‚àíE[Xi]

Xj ‚àíE[Xj]

= Cov[X]ij
(C.3.2)

310
Computational Finance Using C and C#
C.4
Conditional mean and covariance of normal
distributions
Let X = [ X1
X2 ] be distributed as Np(Œº, Œ£) with Œº = [ Œº1
Œº2 ], and Œ£ = [ Œ£11
Œ£12
Œ£21
Œ£22 ],
and |Œ£22| > 0.
We will prove that the conditional distribution of X1, given that X2 = x2, is
normal and has:
Mean = Œºes1 + Œ£11Œ£‚àí1
22 (x2 ‚àíŒº2), and covariance = Œ£11 ‚àíŒ£12Œ£‚àí1
22 Œ£21.
Let the inverse of Œ£ be Œ£‚àí1, where:
Œ£‚àí1 =

Œ£11
Œ£12
Œ£21
Œ£22

(C.4.1)
So Œ£‚àí1Œ£ = Ip, where Ip represents the p √ó p unit matrix, and:

Œ£11
Œ£12
Œ£21
Œ£22
 
Œ£11
Œ£12
Œ£21
Œ£22

=

Iq
0
0
Ip‚àíq

(C.4.2)
Multiplying out these matrices yields the following equations:
Œ£11Œ£11 + Œ£21Œ£21 = Iq
(C.4.3)
Œ£21Œ£11 + Œ£22Œ£22 = 0
(C.4.4)
Œ£11Œ£12 + Œ£12Œ£22 = 0
(C.4.5)
Œ£21Œ£12 + Œ£22Œ£22 = Ip‚àíq
(C.4.6)
Multiplying Eq. (C.4.5) on the left by (Œ£11)‚àí1 and on the right by Œ£‚àí1
22 gives:

Œ£11‚àí1Œ£12 = ‚àíŒ£12Œ£‚àí1
22
(C.4.7)
Multiplying Eq. (C.4.3) on the left by (Œ£11)‚àí1 yields
Œ£11 +

Œ£11‚àí1Œ£12Œ£21 = (Œ£11)‚àí1
(C.4.8)
and substituting for (Œ£11)‚àí1Œ£12 from Eq. (C.4.7) into Eq. (C.4.8) gives
(Œ£11)‚àí1 = Œ£11 ‚àíŒ£12Œ£‚àí1
22 Œ£21
(C.4.9)
The joint probability density function of x is:
f (x) = (2œÄ)‚àíp/2|Œ£|‚àí1/2 exp

‚àí1
2(x ‚àíŒº)‚ä§Œ£‚àí1(x ‚àíŒº)

writing x, Œº and Œ£‚àí1 in their partitioned form and expanding gives:
f (x) = (2œÄ)‚àíp/2|Œ£|‚àí1/2
√ó exp

‚àí1
2

(x1 ‚àíŒº1)‚ä§Œ£11(x1 ‚àíŒº1) + 2(x1 ‚àíŒº1)‚ä§Œ£12(x2 ‚àíŒº2)
+ (x2 ‚àíŒº2)‚ä§Œ£22(x2 ‚àíŒº2)

(C.4.10)

Appendix C: Standard statistical results
311
The conditional distribution of x1 given the value of x2 is thus obtained by
dividing this density by the marginal density of x2, and treating x2 as a constant
in the resulting expression. The only portion of the resultant that is not constant
is the portion involving terms in x1. It can easily be shown that:
f (x1|x2) ‚àùexp

‚àí1
2

(x1 ‚àíŒº1)‚ä§Œ£11(x1 ‚àíŒº1)
+ 2(x1 ‚àíŒº1)‚ä§Œ£12(x2 ‚àíŒº2)

where the constant of proportionality is obtained using

f (x1|x2) dx1 = 1.
If we let G = (x1 ‚àíŒº1)‚ä§Œ£11(x1 ‚àíŒº1) + 2(x1 ‚àíŒº1)‚ä§Œ£12(x2 ‚àíŒº2) we then
obtain:
G = (x1 ‚àíŒº1)‚ä§Œ£11(x1 ‚àíŒº1) + (x1 ‚àíŒº1)‚ä§Œ£12(x2 ‚àíŒº2)
+ (x2 ‚àíŒº2)‚ä§Œ£21(x1 ‚àíŒº1)
G =

x1 ‚àíŒº1 +

Œ£11‚àí1Œ£12(x2 ‚àíŒº2)
‚ä§
√ó Œ£11
x1 ‚àíŒº1 +

Œ£11‚àí1Œ£12(x2 ‚àíŒº2)

‚àí(x2 ‚àíŒº2)‚ä§Œ£21
Œ£12‚àí1(x2 ‚àíŒº2)
(C.4.11)
where, for instance, we have used the fact that the scalar quantity

(x1 ‚àíŒº1)‚ä§Œ£12(x2 ‚àíŒº2)

= (x2 ‚àíŒº2)‚ä§Œ£21(x1 ‚àíŒº1)
Since the last term in Eq. (C.4.11) only involves constants (as far as f (x1|x2) is
concerned), it follows that:
f (x1|x2) ‚àùexp

‚àí1
2

x1 ‚àíŒº1 +

Œ£11‚àí1Œ£12(x2 ‚àíŒº2)
‚ä§
√ó Œ£11
x1 ‚àíŒº1 +

Œ£11‚àí1Œ£12(x2 ‚àíŒº2)

which is the density of a multivariate normal distribution that has a mean of
Œº1 ‚àí(Œ£11)‚àí1Œ£12(x2 ‚àíŒº2), which from Eq. (C.4.7) can be expressed as Œº1 +
Œ£12Œ£‚àí1
22 (x2 ‚àíŒº2). The covariance matrix is (Œ£11)‚àí1, which from Eq. (C.4.9)
can be written as Œ£11 ‚àíŒ£12Œ£‚àí1
22 Œ£21.
C.5
Moment generating functions
If x is a random variable with probability distribution fx(x) then the moment
generating function Mx(t) is deÔ¨Åned by:
Mx(t) = E

etx
=
 ‚àû
‚àí‚àû
etxfx(x) dx

312
Computational Finance Using C and C#
We can expand the above expression as follows:
E

etx
= E

1 + tx + 1
2(tx)2 + ¬∑ ¬∑ ¬∑

Mx(t) = 1 + tE[x] + 1
2t2E

x2
+ ¬∑ ¬∑ ¬∑
(C.5.1)
Now
dk(Mx(t))
dtk
= dk
dtk

E

etx
= E
dketx
dtk

= E

xketx
For t = 0 we thus have:
dk(Mx(t))
dtk
    
t=0
= dk(Mx(0))
dtk
= E

xke0
= E

xk
(C.5.2)
Moment generating function of a linear function of a random variable x
If the random variable y is deÔ¨Åned as: y = ax + b then the moment generating
function of y, My(t) is obtained as follows:
My(t) = Max+b(t) = E

ety
= E

eatx+bt
= ebtE

etx
Therefore:
My(t) = ebtMx(at)
(C.5.3)
Moment generating function of a linear combination of random variables
Let z = x + y where x and y are independent random variables. Then
Mz(t) = E

etz
= E

ex+y
= E

etxety
Since x and y are independent:
E

etxety
= E

etx
E

ety
= Mx(t)My(t)
More generally if sn = 
n
i=1 xi where xi, i = 1, . . . , n, are independent variables
then:
Msn(t) =
n

i=1
Mxi(t)
(C.5.4)
If xi, i = 1, . . . , n, are IID then we have
Msn(t) = E

exp

t
n

i=1
xi
	
=

E

etxn =

Mx(t)
n
(C.5.5)

Appendix D:
Statistical distribution functions
D.1
The normal (Gaussian) distribution
Here we describe some properties of the normal distribution. If x comes from a
normal distribution, then the associated moment generating function, Mx(t), is
given by:
Mx(t) = E

etx
=
1
œÉ
‚àö
2œÄ
 ‚àû
‚àí‚àû
exp(tx) exp

‚àí(x ‚àíŒº)2
2œÉ 2

dx
=
1
œÉ
‚àö
2œÄ
 ‚àû
‚àí‚àû
exp

‚àí(x ‚àíŒº)2 ‚àí2œÉ 2tx
2œÉ 2

dx
Now completing the square we have:
‚àí1
2œÉ 2

(x ‚àíŒº)2 ‚àí2tœÉ 2x

= ‚àí1
2œÉ 2

x2 + Œº2 ‚àí2Œºx ‚àí2tœÉ 2
= ‚àí1
2œÉ 2

x ‚àíœÉ 2t ‚àíŒº
2 ‚àí2ŒºtœÉ 2 ‚àíœÉ 4t2
= Œºt + œÉ 2t2
2
‚àí
1
2œÉ 2

x ‚àíœÉ 2t ‚àíŒº
2
We thus have:
E

etx
=
1
œÉ
‚àö
2œÄ
exp

Œºt + œÉ 2t2
2
  x=‚àû
x=‚àí‚àû
exp

‚àí(x ‚àíœÉ 2t ‚àíŒº)2
2œÉ 2

dx
Now letting y = x ‚àíœÉ 2t ‚àíŒº, dx = dy and
E

etx
=
1
œÉ
‚àö
2œÄ
exp

Œºt + œÉ 2t2
2
  y=‚àû
y=‚àí‚àû
exp

‚àíy2
2œÉ 2

dy
=
1
œÉ
‚àö
2œÄ
œÉ
‚àö
2œÄ exp

Œºt + œÉ 2t2
2

= exp

Œºt + œÉ 2t2
2


314
Computational Finance Using C and C#
where we have used (see Section E.1) the fact that
 ‚àû
‚àí‚àû
exp

‚àíay2
dy =
œÄ
a
Thus the moment generating function Mx(t) for a normal distribution with
mean Œº and variance œÉ 2 is:
Mx(t) = exp

Œºt + œÉ 2t2
2

D.1.1
Some elementary results involving the mean and variance of
a normal distribution
From Ô¨Årst principles we have:
‚Ä¢ The mean:
E[x] =
1
œÉ
‚àö
2œÄ
 x=‚àû
x=‚àí‚àû
x exp

‚àí(x ‚àíŒº)2
2œÉ 2

dx
Letting y = x ‚àíŒº we have dx = dy and x = y + Œº; therefore:
E[x] =
1
œÉ
‚àö
2œÄ
 y=‚àû
y=‚àí‚àû
(y + Œº) exp

‚àíy2
2œÉ 2

dy
E[x] = Œº
1
œÉ
‚àö
2œÄ
 y=‚àû
y=‚àí‚àû
exp

‚àíy2
2œÉ 2

dy
+
1
œÉ
‚àö
2œÄ
 y=‚àû
y=‚àí‚àû
y exp

‚àíy2
2œÉ 2

dy
Since
 ‚àû
‚àí‚àû
y exp

‚àíy2
2œÉ 2

dy = 0
we have using the integral result (i) in Section E.1 with a = 1/(2œÉ 2):
E[x] = Œº
1
œÉ
‚àö
2œÄ
 ‚àû
‚àí‚àû
exp

‚àíy2
2œÉ 2

dy = Œº
‚Ä¢ The variance:
E

x2
=
1
œÉ
‚àö
2œÄ
 x=‚àû
x=‚àí‚àû
x2 exp

‚àí(x ‚àíŒº)2
2œÉ 2

dx
Letting y = x ‚àíŒº we have dx = dy and x2 = y2 + 2Œºy + Œº2; therefore:
E

x2
=
1
œÉ
‚àö
2œÄ
 y=‚àû
y=‚àí‚àû

y2 + 2Œºy + Œº2
exp

‚àíy2
2œÉ 2

dy

Appendix D: Statistical distribution functions
315
E

x2
= Œº2
1
œÉ
‚àö
2œÄ
 ‚àû
‚àí‚àû
exp

‚àíy2
2œÉ 2

dy
+
1
œÉ
‚àö
2œÄ
 y‚àû
‚àí‚àû
y2 exp

‚àíy2
2œÉ 2

dy
So
E

x2
= Œº2 + œÉ 2
where we have used (see Section E.1 result (ii) with a = 1/(2œÉ 2)) that
1
œÉ
‚àö
2œÄ
 ‚àû
‚àí‚àû
y2 exp

‚àíy2
2œÉ 2

dy = œÉ 2
Therefore:
Var[x] = E

x2
‚àí

E[x]
2 = Œº2 + œÉ 2 ‚àíŒº2 = œÉ 2
The mean and variance can also be obtained by using the moment generating
function, Mx(t).
From Section C.5:
E[x] = dMx(t)
dt
    
t=0
= d
dt

exp

Œºt + œÉ 2t2
2

t=0
=

Œº + œÉ 2t

exp

Œºt + œÉ 2t2
2
    
t=0
= Œº
also
E

x2
= d2Mx(t)
dt2
    
t=0
= d
dt

Œº + œÉ 2t

exp

Œºt + œÉ 2t2
2

t=0
E

x2
=

exp

Œºt + œÉ 2t2
2

Œº + ŒºœÉ 2t
2 + œÉ 2

t=0
= Œº2 + œÉ 2
These results are the same as those we previously derived from Ô¨Årst principles:
E[x] = Œº
and
E

x2
= Œº2 + œÉ 2
D.2
The lognormal distribution
If the variable x follows a lognormal distribution then the probability density
function f (x) is given by:
1
xœÉ
‚àö
2œÄ
exp

‚àí(log(x) ‚àíŒº)2
2œÉ 2

(D.2.1)
where x > 0. Here we denote the lognormal distribution for x as: x ‚àº(Œº, œÉ 2).
Setting y = log(x) it can be seen that y ‚àºN(Œº, œÉ 2). Thus if x is a lognormal

316
Computational Finance Using C and C#
distribution (Œº, œÉ 2) then log(x) is a normal distribution with mean Œº and
variance œÉ 2. Conversely if y ‚àºN(Œº, œÉ 2) then the distribution for x = ey is
x ‚àº(Œº, œÉ 2).
The expectation of the tth moment (where t is a positive integer) of x is thus:
E

xt
=
1
œÉ
‚àö
2œÄ
 x=‚àû
x=‚àí‚àû
xt 1
x exp

‚àí(log(x) ‚àíŒº)2
2œÉ 2

dx
Using y = log(x) we have:
dy
dx = d log(x)
dx
= 1
x ,
dx = x dy,
and
xt =

eyt = ety
Thus,
E

xt
= E

ety
= My(t) =
1
œÉ
‚àö
2œÄ
 y=‚àû
y=‚àí‚àû
ety exp

‚àí(y ‚àíŒº)2
2œÉ 2

dy
where My(t) is the moment generating function of a normal distribution with
mean Œº and variance œÉ 2.
From Section D.1:
E

xt
= My(t) = exp

Œºt + œÉ 2t2
2

Therefore if x ‚àº(Œº, œÉ 2) then:
For t = 1
E[x] = exp

Œº + œÉ 2
2

(D.2.2)
for t = 2
E

x2
= exp

2Œº + 2œÉ 2
(D.2.3)
and the variance is obtained using
Var[x] = E

x2
‚àí

E[x]
2 = exp

2Œº + 2œÉ 2
‚àíexp

2Œº + œÉ 2
So
Var[x] = exp

2Œº + œÉ 2
exp

œÉ 2
‚àí1

or
Var[x] =

E[x]
2
exp

œÉ 2
‚àí1

(D.2.4)
Note. If x1 = exp(Œº + œÉZ), where Z ‚àºN(0, 1) then x1 ‚àº(Œº, œÉ 2). So E[x1]
and Var[x1] are given by Eqs. (D.2.2) and (D.2.4).

Appendix D: Statistical distribution functions
317
D.3
The Student‚Äôs t distribution
This section derives an expression for the kurtosis of the Student‚Äôs t distribution.
Since the Student‚Äôs t distribution density function is:
f (œµi) = K

1 +
œµi2
hi(ŒΩ ‚àí2)
‚àí(ŒΩ+1)/2
where
K = ((ŒΩ + 1)/2)(ŒΩ ‚àí2)‚àí1/2h‚àí1/2
i
œÄ1/2(ŒΩ/2)
we have:
E

œµ2
i

= 2K
 ‚àû
0
œµ2
i dœµi
(1 + œµ2
i /(hi(ŒΩ ‚àí2)))(ŒΩ+1)/2
= 2K

hi(ŒΩ ‚àí2)
(ŒΩ+1)/2
 ‚àû
0
œµ2
i dœµi
(hi(ŒΩ ‚àí2) + œµ2
i )(ŒΩ+1)/2
Using the standard integrals in Section E.1 with a = 2, b = 2, c = (ŒΩ + 1)/2
and m = (ŒΩ ‚àí2)hi gives:
m(a+1‚àíbc)/b
b
= (hi(ŒΩ ‚àí2))(2‚àíŒΩ)/2
2
,

a + 1
b

= 
3
2

,


c ‚àía + 1
b

= 
ŒΩ ‚àí2
2

,
(c) = 
ŒΩ + 1
2

This gives
E

œµ2
i

= 2K

hi(ŒΩ ‚àí2)
(ŒΩ+1)/2
(hi(ŒΩ ‚àí2))(2‚àíŒΩ)/2‚àöœÄ((ŒΩ ‚àí2)/2)
4((ŒΩ + 1)/2)

Substituting for K and simplifying we obtain:
E

œµ2
i

= hi(ŒΩ ‚àí2)((ŒΩ ‚àí1)/2)
(ŒΩ/2)
But
ŒΩ ‚àí2
2


ŒΩ ‚àí2
2

= 
ŒΩ ‚àí1
2
+ 1

= 
ŒΩ
2

So
E

œµ2
i

= hi(ŒΩ ‚àí2)(ŒΩ/2)
2(ŒΩ ‚àí2)(ŒΩ/2) = hi

318
Computational Finance Using C and C#
Similarly we have:
E

œµ4
i

= 2K
 ‚àû
0
œµ4
i dœµi
(1 + œµ2
i /(hi(ŒΩ ‚àí2)))(ŒΩ+1)/2
= 2K

hi(ŒΩ ‚àí2)
(ŒΩ+1)/2
 ‚àû
0
œµ4
i dœµi
(hi(ŒΩ ‚àí2) + œµ2
i )(ŒΩ+1)/2
Using the standard integrals in Section E.1 with a = 4, b = 2, c = (ŒΩ +1)/2, and
m = (ŒΩ ‚àí2)hi gives:
m(a+1‚àíbc)/b
b
= (hi(ŒΩ ‚àí2))(4‚àíŒΩ)/2
2
,

a + 1
b

= 
5
2

,


c ‚àía + 1
b

= 
ŒΩ ‚àí4
2

,
(c) = 
ŒΩ + 1
2

and
E

œµ4
i

= 2K

hi(ŒΩ ‚àí2)
(ŒΩ+1)/2
(hi(ŒΩ ‚àí2))(4‚àíŒΩ)/23‚àöœÄ((ŒΩ ‚àí4)/2)
8((ŒΩ + 1)/2)

Substituting for K and simplifying we obtain:
E

œµ4
i

= 3hi(ŒΩ ‚àí2)2((ŒΩ ‚àí4)/2)h2
i
4(ŒΩ/2)
But
ŒΩ ‚àí4
2


ŒΩ ‚àí4
2

= 
ŒΩ ‚àí2
2

and
ŒΩ ‚àí2
2


ŒΩ ‚àí2
2

= 
ŒΩ
2

Therefore:

ŒΩ ‚àí4
2

=
4(ŒΩ/2)
(ŒΩ ‚àí4)(ŒΩ ‚àí2)
So
E

œµ4
i

=
3(ŒΩ ‚àí2)24(ŒΩ/2)h2
i
4(ŒΩ/2)(ŒΩ ‚àí4)(ŒΩ ‚àí2) = 3(ŒΩ ‚àí2)h2
i
ŒΩ ‚àí4
The kurtosis is then:
‚Ñµ=
E[e4
i ]
(E[e2
i ])2 = 3(ŒΩ ‚àí2)h2
i
(ŒΩ ‚àí4)h2
i
= 3(ŒΩ ‚àí2)
ŒΩ ‚àí4
(D.3.1)

Appendix D: Statistical distribution functions
319
D.4
The general error distribution
This section proves various relations for the generalized error distribution.
The density function for the generalized error distribution is:
f (œµi) = K exp

‚àí1
2
    
œµi
Œª
    
a
where K =
a
Œª2(1+1/a)(1/a)
(D.4.1)
D.4.1
Value of Œª for variance hi
Calculation of the scale factor Œª required for a generalized error distribution
with mean zero and variance hi.
The variance of the distribution, E(œµ2
i ), is given by:
E

œµ2
i

= K
 ‚àû
‚àí‚àû
œµ2
i exp

‚àí1
2
    
œµi
Œª
    
a
dœµi = 2K
 ‚àû
0
œµ2
i exp

‚àí1
2
œµi
Œª
a
dœµi
Using the standard integrals in Section E.1 with n = 2, p = a, and b = 1
2( 1
Œª)a
gives:
hi = 2K
a 
3
a
1
2
1
Œª
a‚àí3/a
which after some simpliÔ¨Åcation yields:
hi = 2K23/aŒª3
a

3
a

Substituting for K and simplifying then gives:
hi = Œª222/a (3/a)
(1/a)
The required value of Œª is therefore:
Œª =

hi2‚àí2/a (1/a)
(3/a)
1/2
D.4.2
The kurtosis
E

œµ4
i

= K
 ‚àû
‚àí‚àû
œµ4
i exp

‚àí1
2
    
œµi
Œª
    
a
dœµi = 2K
 ‚àû
0
œµ4
i exp

‚àí1
2
œµi
Œª
a
dœµi
However, from standard mathematical tables:
 ‚àû
0
œµ4
i exp

‚àíbœµp
i

= (k)
pbk
where p = a, b = 1
2( 1
Œª)a, and k = 5/a which gives:
E

œµ4
i

= 2K25/aŒª5
a

5
a

= 22/aŒª2hi
(5/a)
(3/a)

320
Computational Finance Using C and C#
From Section E.1 we have:
E

œµ2
i

= hi = 2K23/aŒª3
a

3
a

and
Œª2 = hi2‚àí2/a(1/a)
(3/a)
Therefore:
E

œµ4
i

= h2
i
(5/a)(1/a)
(3/a)(3/a)
which gives the kurtosis as:
‚Ñµ=
E[œµ4
i ]
(E[œµ2
i ])2 = h2
i
h2
i
(5/a)(1/a)
(3/a)(3/a) = (5/a)(1/a)
(3/a)(3/a)
D.4.3
The distribution for shape parameter, a
If the distribution has variance hi then, from Section D.4.1:
Œª =
2‚àí2/a(1/a)hi
(3/a)
1/2
Now for 0 < x < 1 we have (1 + x) = 1 + a1x + a2x2 + a3x3 + ¬∑ ¬∑ ¬∑, where
the coefÔ¨Åcients are |ai| < 1 (see Abramowitz and Stegun (1968)).
Since x(x) = (1 + x), to third order in x, we have:
x(x) = 1 + a1x + a2x2 + a3x3
This gives (x) = 1
x + a1 + a2x + a3x2, and (x) ‚âà1
x as x ‚Üí0.
So as a ‚Üí‚àûwe have the following:
2(1+1/a) ‚âà2,
2‚àí2/a ‚âà1,
1
(1/a) ‚âà1
a ,
(1/a)
(3/a) ‚âà3a
a = 3
and
(5/a)
(3/a) ‚âà3a
5a = 3
5
The kurtosis is then:
‚Ñµ= (5/a)(1/a)
(3/a)(3/a) = 9
5
Also as a ‚Üí‚àû, Œª ‚âà(3hi)1/2, and for the range ‚àí(3hi)1/2 < œµi < (3hi)1/2, we
have:    
œµi
Œª
    
a
‚âà
    
œµi
(3hi)1/2
    ‚âà0
and therefore
exp

‚àí1
2
    
œµi
Œª
    
a
‚âà1
Substituting the above results into Eq. (D.4.1), the probability density function
reduces to:
f (œµi) ‚âà
1
2(3hi)1/2
which is a uniform distribution U(‚àí(3hi)1/2, (3hi)1/2), with lower limit
‚àí(3hi)1/2 and upper limit ‚àí(3hi)1/2.

Appendix E:
Mathematical reference
E.1
Standard integrals
 ‚àû
0
exp

‚àíay2
dy = 1
2
œÄ
a
(i)
 ‚àû
0
y exp

‚àíay2
dy = 1
2
(ii)
 ‚àû
0
y2 exp

‚àíay2
dy = 1
4a
œÄ
a
(iii)
 ‚àû
0
y4 exp

‚àíay2
dy =
3
8a2
œÄ
a
(iv)
 ‚àû
0
y2n exp

‚àíay2
dy = 1 √ó 3 √ó 5 √ó ¬∑ ¬∑ ¬∑ √ó (2n ‚àí1)
2n+1an
œÄ
a
(v)
 ‚àû
0
œµn
i exp

‚àíbœµp
i

= (k)
pbk ,
(vi)
where n > ‚àí1, p > 0, b > 0 and k = n + 1
p
 ‚àû
0
œµa
i dœµi
(m + œµb
i )c = m(a+1‚àíbc)/b
b
((a + 1)/b)(c ‚àí(a + 1)/b)
(c)
(vii)
where a > ‚àí1, b > 0, m > 0 and c > a + 1
b
E.2
Gamma function
For more detail see Abramowitz and Stegun (1968).
(1 + x) = x!
x(x) = (x + 1)

1
2

= ‚àöœÄ

322
Computational Finance Using C and C#

3
2

=
‚àöœÄ
2

5
2

= 3‚àöœÄ
4
‚àÇlog((x))
‚àÇx
= œà(x)
For 0 ‚©Ωx ‚©Ω1 we have:
(1 + x) = 1 + a1x + a2x2 + a3x3 + a4x4 + a5x5
where a1 = ‚àí0.5748, a2 = 0.9512, a3 = ‚àí0.6998, a4 = 0.4245 and a5 =
‚àí0.1010.
E.3
The cumulative normal distribution function
In this section we show that the cumulative normal distribution function, N1(x),
is related to the complementary error function, erfc(x), by the following equa-
tion:
N1(x) = 1
2 erfc

‚àíx
‚àö
2

(E.3.1)
If we let the error function be represented by erf(x) then we have:
erf(x) =
2
‚àöœÄ
 ‚àû
0
exp

‚àít2
dt
Now we have the following:
erfc(x) = 1 ‚àíerf(x),
erf(‚àíx) = ‚àíerf(x),
erf(‚àû) = 1
and
erfc(‚àíx) = 2 ‚àíerfc(x)
We will consider the integral
I(x) =
2
‚àöœÄ
 x
‚àí‚àû
exp

‚àít2
dt
=
2
‚àöœÄ
 0
‚àí‚àû
exp

‚àít2
dt +
2
‚àöœÄ
 x
0
exp

‚àít2
dt
Since
2
‚àöœÄ
 0
‚àí‚àû
exp

‚àít2
dt = 1
we therefore have
I(x) = 1 + erf(x) = 1 +

1 ‚àíerfc(x)

= 2 ‚àíerfc(x)

Appendix E: Mathematical reference
323
Substituting for erfc(x) we obtain:
I(x) = 2 ‚àí

2 ‚àíerfc(‚àíx)

= erfc(‚àíx)
So we have
erfc(‚àíx) =
2
‚àöœÄ
 x
‚àí‚àû
exp

‚àít2
dt
(E.3.2)
Now the cumulative normal distribution is deÔ¨Åned as
N1(x) =
1
‚àö
2œÄ
 x
‚àí‚àû
exp

‚àít2
dt
Letting u = t
‚àö
2, we have du =
‚àö
2 dt, and for the upper limit we have x = t
‚àö
2,
or t = x/
‚àö
2.
This integral becomes:
N1(x) =
1
‚àö
2œÄ
 t=x/
‚àö
2
‚àû
exp

‚àít2‚àö
2 dt
(E.3.3)
So from Eq. (E.3.2) we have:
N1(x) = 1
2 erfc

‚àíx
‚àö
2

We also note that:
N1(‚àíx) = 1 ‚àíN1(x)
E.4
Arithmetic and geometric progressions
Arithmetic progression
The sum of the Ô¨Årst n terms of an arithmetic progression is:
sn = n
2

2a1 + (n ‚àí1)d

(E.4.1)
where a1 is the Ô¨Årst term, and d is the common difference; that is, the terms in
the sequence are: a1, a1 + d, a1 + 2d, a1 + 3d, . . . .
Geometric progression
The sum of the Ô¨Årst n terms of a geometric progression is:
sn = a1(1 ‚àírn)
1 ‚àír
(E.4.2)
where a1 is the Ô¨Årst term, and r is the common ratio; that is, the terms in se-
quence are: a1, a1r, a1r2, a1r3, . . . .

blank
left
intentionally
page
This

Appendix F:
Black‚ÄìScholes Ô¨Ånite-difference
schemes
F.1
The general case
In this section we consider the stability of the Ô¨Ånite-difference schemes described
in Chapter 5. It is assumed that the grid contains ns asset points, and we will
denote the time dependent option values at the ith and (i + 1)th time instants
by the ns ‚àí2 element vectors Xi and Xi+1 respectively. We can therefore write:
T1Xi = T2Xi+1
(F.1.1)
where T1 and T2 are (ns ‚àí2) √ó (ns ‚àí2) tridiagonal matrices, and xi
k, k = 1, . . . ,
ns ‚àí2, will be used to denote the elements of the vector Xi.
The option values at the ith time instant are computed from those at the
(i + 1)th time instant by using
Xi = T ‚àí1
1
T2Xi+1
(F.1.2)
However, Eq. (F.1.2) is only stable if the eigenvalues of the (ns ‚àí2) √ó (ns ‚àí2)
matrix T ‚àí1
1
T2 all have modulus less than one (see Smith (1985)).
F.2
The log transformation and a uniform grid
We will now prove that the implicit Ô¨Ånite difference method, Œòm = 0, when used
on the log transformed Black‚ÄìScholes equation with a uniform grid is uncondi-
tionally stable which means that the stability does not depend on the values of
œÉ, t, Z, etc.
From Chapter 5 the Ô¨Ånite-difference scheme is described by the following
tridiagonal system:
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éù
B
C
0
0
0
0
A
B
C
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0
A
B
C
0
0
0
0
A
B
‚éû
‚éü‚éü‚éü‚éü‚éü‚é†
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éú‚éù
xi
1
xi
2
.
.
xi
s‚àí1
xi
s‚àí2
‚éû
‚éü‚éü‚éü‚éü‚éü‚éü‚é†

326
Computational Finance Using C and C#
=
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éù

B
C
0
0
0
0

A

B
C
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0

A

B
C
0
0
0
0

A

B
‚éû
‚éü‚éü‚éü‚éü‚éü‚é†
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éú‚éù
xi+1
1
xi+1
2
.
.
xi+1
s‚àí3
xi+1
s‚àí2
‚éû
‚éü‚éü‚éü‚éü‚éü‚éü‚é†
where
A = (1 ‚àíŒòm)t
2Z2

bZ ‚àíœÉ 2
(F.2.1)
B = 1 + (1 ‚àíŒòm)t

r + œÉ 2
Z2

(F.2.2)
C = ‚àí(1 ‚àíŒòm)t
2Z2

bZ + œÉ 2
(F.2.3)

A = ‚àíŒòmt
2Z2

bZ ‚àíœÉ 2
(F.2.4)

B = 1 ‚àíŒòmt

r + œÉ 2
Z2

(F.2.5)
C = Œòmt
2Z2

bZ + œÉ 2
(F.2.6)
As in Chapter 5, b = r ‚àíq ‚àíœÉ 2
2 and r > 0.
Substituting Œòm = 0 into Eqs. (F.2.1)‚Äì(F.2.6) we have 
A = C = 0, 
B = 1, and
A =
t
2Z2

bZ ‚àíœÉ 2
,
B = 1 + t

r + œÉ 2
Z2

,
C = ‚àít
2Z2

bZ + œÉ 2
The Ô¨Ånite-difference scheme is thus represented by the equations
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éù
B
C
0
0
0
0
A
B
C
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0
A
B
C
0
0
0
0
A
B
‚éû
‚éü‚éü‚éü‚éü‚éü‚é†
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éú‚éù
xi
1
xi
2
.
.
xi
s‚àí1
xi
s‚àí2
‚éû
‚éü‚éü‚éü‚éü‚éü‚éü‚é†
=
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éù
1
0
0
0
0
0
1
0
0
0
0
0
.
.
0
0
0
0
0
.
.
0
0
0
0
0
1
0
0
0
0
0
0
1
‚éû
‚éü‚éü‚éü‚éü‚éü‚é†
‚éõ
‚éú‚éú‚éú‚éú‚éú‚éú‚éù
xi+1
1
xi+1
2
.
.
xi+1
s‚àí3
xi+1
s‚àí2
‚éû
‚éü‚éü‚éü‚éü‚éü‚éü‚é†
or in matrix notation
Xi = T1‚àí1Xi+1
(F.2.7)
where T2 = I in Eq. (F.1.1).
As mentioned in Section F.1, Eq. (F.2.7) is stable if the modulus of all the
eigenvalues of T ‚àí1
1
are less than one. We will now show that this is in fact the
case.

Appendix F: Black‚ÄìScholes Ô¨Ånite-difference schemes
327
If the eigenvalues of T1 are Œªk, k = 1, . . . , ns ‚àí2, then the eigenvalues of
T ‚àí1
1
are Œª‚àí1
k , k = 1, . . . , ns ‚àí2. This means that the system is stable if all the
eigenvalues of T1 have a modulus greater than one. This result can be proved
by considering the eigenvalue with the smallest modulus, Œªmin. If |Œªmin| > 1 then
the result is proved.
Now the eigenvalues of T1, see Smith (1985), are given by:
Œªk = 1 + t

r + œÉ 2
Z2

+ 2
‚àö
AC cos

kœÄ
ns ‚àí2 + 1

(F.2.8)
k = 1, . . . , ns ‚àí2,
where the term
2
‚àö
AC =

t2(œÉ 4 ‚àíb2Z2)
Z4
(F.2.9)
It can be seen that if b2Z2 > œÉ 4 then the eigenvalues are complex and if
œÉ 4 ‚©æb2Z2 then eigenvalues are real. We will consider each of these cases in
turn.
Complex eigenvalues: b2Z2 > œÉ 4
We will represent the kth complex eigenvalue as:
Œªk = R + iY
where the real part is
R = 1 + t

r + œÉ 2
Z2

and the imaginary part is
Y = 2
‚àö
AC cos

kœÄ
ns ‚àí2 + 1

Since
|Œªk| > |R| + |Y|
and
|R| > 1,
we conclude that
|Œªmin| > 1
Real eigenvalues: œÉ 4 ‚©æ‚©æ‚©æb2Z2
In this case the kth eigenvalue is real, and from Eq. (F.2.8) we have:
Œªk > 1 + t

r + œÉ 2
Z2

‚àí2
‚àö
AC

328
Computational Finance Using C and C#
Since b22 > 0 from Eq. (F.2.9) we have
2
‚àö
AC <

œÉ 4t2
Z4
or
  2
‚àö
AC
  < œÉ 2t
Z2
So
Œªmin > 1 + t

r + œÉ 2
Z2

‚àíœÉ 2t
Z2
Therefore we have
|Œªmin| > 1 + rt
and, since r > 0, we have:
|Œªmin| > 1

Appendix G:
The Brownian bridge:
alternative derivation
Here we provide an alternative derivation of the Brownian bridge equation
given in Chapter 2.
Let a Brownian process have values Wt0 at time t0 and Wt1 at time t1. We want
to Ô¨Ånd the conditional distribution of Wt, where t0 < t < t1. This distribution
will be denoted by P(Wt|{Wt0, Wt1}), to indicate that Wt is conditional on the
end values Wt0 and Wt1.
We have:
P(Wt|Wt0) =
1
‚àö2œÄ(t ‚àít0) exp

‚àí(Wt ‚àíWt0)2
2(t ‚àít0)

The joint distribution of Wt and Wt1 given Wt0 is:
P

{Wt, Wt1}|Wt0

= P(Wt1|Wt)P(Wt|Wt0)
=
1
‚àö2œÄ(t ‚àít0)(t1 ‚àít) exp

‚àí(Wt ‚àíWt0)2
2(t ‚àít0)
‚àí(Wt1 ‚àíWt)2
2(t1 ‚àít)

=
1
‚àö2œÄ(t ‚àít0)(t1 ‚àít) exp

‚àí1
2
(Wt ‚àíWt0)2
2(t ‚àít0)
+ (Wt1 ‚àíWt)2
2(t1 ‚àít)

Similarly
P(Wt1|Wt0) =
1
‚àö2œÄ(t1 ‚àít0) exp

‚àí(Wt1 ‚àíWt0)2
2(t1 ‚àít0)

Now we have:
P

Wt|{Wt0, Wt1}

= P({Wt, Wt1}|Wt0)
P(Wt1|Wt0)
=
1
‚àö
2œÄ

t1 ‚àít0
(t ‚àít0)(t1 ‚àít)
√ó exp

‚àí1
2
(Wt ‚àíWt0)2
2(t ‚àít0)
+ (Wt1 ‚àíWt)2
2(t1 ‚àít)
‚àí(Wt1 ‚àíWt0)2
2(t1 ‚àít0)


330
Computational Finance Using C and C#
For ease of reference we will write the above equation as:
P

Wt|{Wt0, Wt1}

=
1
‚àö
2œÄ

t1 ‚àít0
(t ‚àít0)(t1 ‚àít) exp{A}
We now consider the terms in the exponent A.
A = ‚àí1
2
(X ‚àíXt0)2(t1 ‚àít)(t1 ‚àít0)
(t ‚àít0)(t1 ‚àít)(t1 ‚àít0)
+ (X1 ‚àíX)2(t ‚àít0)(t1 ‚àít0)
(t ‚àít0)(t1 ‚àít)(t1 ‚àít0)
‚àí(X1 ‚àíXt0)2(t ‚àít0)(t1 ‚àít)
(t ‚àít0)(t1 ‚àít)(t1 ‚àít0)

Dividing top and bottom of the above expression for A by (t1 ‚àít0)2 we then
obtain:
A = ‚àí1
2V

W 2
t + W 2
t0 ‚àí2WtWt0
 t1 ‚àít
t1 ‚àít0
+

W 2
t1 + W 2
t ‚àí2WtWt1
 t ‚àít0
t1 ‚àít0
‚àí

W 2
t1 + W 2
t0 ‚àí2Wt1Wt0
(t ‚àít0)(t1 ‚àít)
(t1 ‚àít0)2

where
V = (t ‚àít0)(t1 ‚àít)
t1 ‚àít0
So
A = ‚àí1
2V

W 2
t
 t1 ‚àít
t1 ‚àít0
+ t ‚àít0
t1 ‚àít0

+ W 2
t1
 t ‚àít0
t1 ‚àít0
‚àí(t ‚àít0)(t1 ‚àít)
(t1 ‚àít0)2

+ W 2
t0
 t ‚àít0
t1 ‚àít0
‚àí(t ‚àít0)(t1 ‚àít)
(t1 ‚àít0)2

‚àí2WtWt0
 t1 ‚àít
t1 ‚àít0

‚àí2WtWt1
 t ‚àít0
t1 ‚àít0

+ 2Wt1Wt0
(t ‚àít0)(t1 ‚àít)
(t1 ‚àít0)2

We now show that A can be expressed as quadratic form:
B = ‚àí1
2V (Wt ‚àíŒº)2 = ‚àí1
2V

W 2
t + Œº2 ‚àí2ŒºWt

where
V = (t ‚àít0)(t1 ‚àít)
t1 ‚àít0
and
Œº = Wt0
t1 ‚àít
t1 ‚àít0
+ Wt1
t ‚àít0
t1 ‚àít0
Therefore we have:
B = ‚àí1
2V

W 2
t +

Wt0
t1 ‚àít
t1 ‚àít0
+ Wt1
t ‚àít0
t1 ‚àít0
2
‚àí2Wt

Wt0
t1 ‚àít
t1 ‚àít0
+ Wt1
t ‚àít0
t1 ‚àít0


Appendix G: The Brownian bridge: alternative derivation
331
Expanding and gathering terms we obtain:
B = ‚àí1
2V

W 2
t + W 2
t0
(t1 ‚àít)2
(t1 ‚àít0)2 + W 2
t1
(t ‚àít0)2
(t1 ‚àít0)2 + 2Wt0Wt1
(t1 ‚àít)(t ‚àít0)
(t1 ‚àít0)2
‚àí2WtWt0
t1 ‚àít
t1 ‚àít0
‚àí2WtWt1
t ‚àít0
t1 ‚àít0

Comparing coefÔ¨Åcients of A and B we have:
CoefÔ¨Åcients for W 2
t
A: ‚àí1
2V
 t1 ‚àít
t1 ‚àít0
+ t ‚àít0
t1 ‚àít0

= ‚àí1
2V
t1 ‚àít + t ‚àít0
t1 ‚àít0

= ‚àí1
2V
B : ‚àí1
2V
CoefÔ¨Åcients for W 2
t0
A: ‚àí1
2V
 t1 ‚àít
t1 ‚àít0
‚àí(t ‚àít0)(t1 ‚àít)
(t1 ‚àít0)2

= ‚àí1
2V
(t1 ‚àít)(t1 ‚àít0) ‚àí(t ‚àít0)(t1 ‚àít)
(t1 ‚àít0)2

A: ‚àí1
2V
(t1 ‚àít)(t1 ‚àít0 ‚àít + t0)
(t1 ‚àít0)2

= ‚àí1
2V
 (t1 ‚àít)2
(t1 ‚àít0)2

B : ‚àí1
2V
 (t1 ‚àít)2
(t1 ‚àít0)2

CoefÔ¨Åcients for W 2
t1
A: ‚àí1
2V
(t ‚àít0)(t1 ‚àít0) ‚àí(t ‚àít0)(t1 ‚àít)
(t1 ‚àít0)2

= ‚àí1
2V
(t ‚àít0)(t1 ‚àít0 ‚àít1 + t)
(t1 ‚àít0)2

A: ‚àí1
2V
 (t1 ‚àít)2
(t1 ‚àít0)2

B : ‚àí1
2V
 (t ‚àít0)2
(t1 ‚àít0)2

The remaining coefÔ¨Åcients in A and B for Wt0Wt1, WtWt1 and Wt0Wt are identi-
cal.

332
Computational Finance Using C and C#
We have thus shown that:
P

Wt|{Wt0, Wt1}

=
1
‚àö
2œÄ

t1 ‚àít0
(t ‚àít0)(t1 ‚àít) exp

‚àí(Wt ‚àíŒº)2
2V

=
1
‚àö
2œÄV
exp

‚àí(Wt ‚àíŒº)2
2V

Thus the conditional distribution of Wt is a Gaussian with mean
Œº = Wt0
t1 ‚àít
t1 ‚àít0
+ Wt1
t ‚àít0
t1 ‚àít0
and variance
V = (t ‚àít0)(t1 ‚àít)
t1 ‚àít0
and we can obtain a variate 
Wt from this distribution by using:

Wt = Wt0
t1 ‚àít
t1 ‚àít0
+ Wt1
t ‚àít0
t1 ‚àít0
+

(t ‚àít0)(t1 ‚àít)
t1 ‚àít0
Z,
where Z ‚àºN(0, 1)

Appendix H:
Brownian motion: more results
H.1
Some results concerning Brownian motion
Here we will prove some facts concerning Brownian motion.
If the Brownian motion has zero drift then:
dXt = œÉ
‚àö
dt dZt,
dZt ‚àºN(0, 1)
(H.1.1)
and
P

mX
t ‚©Ωb, Xt ‚©æx

= N1
2b ‚àíx
œÉ‚àöt

(H.1.2)
where mX
t denotes the minimum value of Xt over the time interval [0, t], b ‚©Ω0,
and x ‚©æ0.
When the Brownian motion has nonzero drift
d
Xt = ŒΩ dt + œÉ
‚àö
dt dZt,
dZt ‚àºN(0, 1)
(H.1.3)
and the following equations are satisÔ¨Åed by m
X
t and 
Xt:
P(
Xt ‚©ΩK) = N1
K ‚àíŒΩt
œÉ‚àöt

(H.1.4)
P(
Xt ‚©æK) = N1
ŒΩt ‚àíK
œÉ‚àöt

(H.1.5)
P

m
X
t ‚©Ωb, 
Xt ‚©æx

= exp
2ŒΩb
œÉ 2

N1
2b ‚àíx + ŒΩt
œÉ‚àöt

(H.1.6)
P

m
X
t ‚©æb, 
Xt ‚©æx

= N1
ŒΩt ‚àíx
œÉ‚àöt

‚àíexp
2ŒΩb
œÉ 2

N1
2b ‚àíx + ŒΩt
œÉ‚àöt

(H.1.7)
P

m
X
t ‚©Ωb

= N1
b ‚àíŒΩt
œÉ‚àöt

+ exp
2ŒΩb
œÉ 2

N1
b + ŒΩt
œÉ‚àöt

(H.1.8)
P

m
X
t ‚©æb

= N1
ŒΩt ‚àíb
œÉ‚àöt

‚àíexp
2ŒΩb
œÉ 2

N1
b + ŒΩt
œÉ‚àöt

(H.1.9)
where K is a constant, 
X ‚©æ0, b ‚©Ω0, and P(condition) denotes the probability
associated with the appropriate condition, i.e., 
Xt ‚©æK, m
X
t ‚©æb, 
Xt ‚©æx, etc.

334
Computational Finance Using C and C#
The conditional probability density function associated with P(m
X
t ‚©Ωb, 
Xt ‚©æ
x) is
p

m
X
t1,t2 ‚©Ωb, 
Xt2

|
Xt1

=
1
œÉ
‚àö
2œÄt
exp
2ŒΩ(b ‚àí
Xt1)
œÉ 2

exp

‚àí(
Xt1 + 
Xt2 ‚àí2b + ŒΩt)2
2œÉ 2t

(H.1.10)
where t2 ‚©æt1 and t = t2 ‚àít1.
H.2
Proof of Eq. (H.1.2)
From Eq. (H.1.1):
Xt = œÉ
‚àö
t
Zt, Zt ‚àºN(0, 1)
where X0 = 0. We will derive the probability of events mX
t
‚©Ωb and Xt ‚©æx
occurring. For event mX
t
to occur there must be a time œÑ at which XœÑ ‚©Ωb,
where 0 < œÑ ‚©Ωt. At time œÑ, instead of continuing with the original Brownian
motion, Xt we will consider the reÔ¨Çected motion XR
t deÔ¨Åned by:
XR
s = Xs,
s < œÑ
XR
s = 2b ‚àíXs,
s ‚©æœÑ
Therefore, before time œÑ the motion Xs is identical to XR
s . For s ‚©æœÑ the coordi-
nates of XR
s are obtained by reÔ¨Çecting those of Xs about the level b. The event
Xt ‚©æx is thus equivalent to the event XR
t ‚©Ω2b‚àíx (remember b ‚©Ω0 and x ‚©æ0).
However, the event XR
t ‚©Ω2b ‚àíx only occurs if mX
t ‚©Ωb also occurs, giving:
P

XR
t ‚©Ω2b ‚àíx

= P

mX
t ‚©Ωb, Xt ‚©Ωx

At time œÑ we have
XR
œÑ = 2b ‚àíXœÑ
(H.2.1)
and after time œÑ
XR
œÑ+Œ≥ = 2b ‚àíXœÑ+Œ≥ ,
Œ≥ > 0
(H.2.2)
Thus subtracting Eq. (H.2.1) from Eq. (H.2.2) gives:
XR
œÑ+Œ≥ ‚àíXR
œÑ = XœÑ ‚àíXœÑ+Œ≥
XR
œÑ+Œ≥ ‚àíXR
œÑ = ‚àí(XœÑ+Œ≥ ‚àíXœÑ)
(H.2.3)
However, we know that:
(XœÑ+Œ≥ ‚àíXœÑ) ‚àºN

0, œÉ 2Œ≥

(H.2.4)
So

XR
œÑ+Œ≥ ‚àíXR
œÑ

‚àº‚àíN

0, œÉ 2Œ≥


Appendix H: Brownian motion: more results
335
which means that:

XR
œÑ+Œ≥ ‚àíXR
œÑ

‚àºN

0, œÉ 2Œ≥

(H.2.5)
Since the left-hand sides of Eqs. (H.2.4) and (H.2.5) have the same distribution,
and Xt satisÔ¨Åes the three Brownian properties given in Section 2.1, we can write:
P

XR
t ‚©Ω2b ‚àíx

= P(Xt ‚©Ω2b ‚àíx) = N1
2b ‚àíx
œÉ‚àöt

Therefore:
P

mX
t ‚©Ωb, Xt ‚©æx

= N1
2b ‚àíx
œÉ‚àöt

H.3
Proof of Eq. (H.1.4)
From Eq. (H.1.3) 
Xt = ŒΩt + œÉ‚àötZt, Zt ‚àºN(0, 1).
So we can write:
P(
Xt ‚©ΩK) = P

ŒΩt + œÉ
‚àö
tZt ‚©ΩK

= P

Zt ‚©ΩK ‚àíŒΩt
œÉ‚àöt

= N1
K ‚àíŒΩt
œÉ‚àöt

,
Zt ‚àºN(0, 1)
H.4
Proof of Eq. (H.1.5)
We know that P(
Xt ‚©æK) = 1 ‚àíP(
Xt ‚©ΩK).
Substituting from Eq. (H.1.4) gives:
P(
Xt ‚©æK) = 1 ‚àíN1
K ‚àíŒΩt
œÉ‚àöt

Since 1 ‚àíN1(x) = N1(‚àíx) we obtain:
P(
Xt ‚©æK) = N1
ŒΩt ‚àíK
œÉ‚àöt

H.5
Proof of Eq. (H.1.6)
From Eq. (H.1.1):
dXt = œÉ
‚àö
dt dZt,
dZt ‚àºN(0, 1)

336
Computational Finance Using C and C#
This can be expressed as zero drift Brownian motion under probability mea-
sure P:
dXt = œÉ dW P,
dW P ‚àºN(0, dt)
(H.5.1)
or
Xt = œÉW P
t ,
W P
t ‚àºN(0, t)
Now we can choose another probability measure Q so that:
dW P = dW Q + ŒΩ
œÉ dt
(H.5.2)
where ŒΩ is a constant.
Under probability measure Q the motion in Eq. (H.5.1) is:
d
Xt = œÉ

dW Q + ŒΩ
œÉ dt

(H.5.3)
so
d
Xt = ŒΩ dt + œÉ dW Q
(H.5.4)
It can be seen from Section 2.4 that the transformation between measures
P and Q can be accomplished using k = ŒΩ/œÉ, and that the associated Radon‚Äì
Nikodym derivative is:
dQ
dP = exp

kW P
t ‚àí1
2k2t

= exp
 ŒΩ
œÉ W P
t ‚àí1
2
ŒΩ2t
œÉ

= exp
 ŒΩ
œÉ 2 Xt ‚àí1
2
ŒΩ2t
œÉ

(H.5.5)
where we have used the fact that under probability measure P we can write:
W P
t = Xt/œÉ.
Now
P

m
X
t ‚©Ωb, 
Xt ‚©æx

= EQ
I{m
Xt ‚©Ωb}I{
Xt‚©æx}

(H.5.6)
where I{condition} is an indicator function which takes unit value when condition
is satisÔ¨Åed and zero otherwise‚Äîfor example I{m
Xt ‚©Ωb} is one when m
X
t
‚©Ωb and
zero when m
X
t > b.
However (see for example Baxter and Rennie (1996)), we have:
EQ
I{m
Xt ‚©Ωb}I{
Xt‚©æx}

= EP

I{mXt ‚©Ωb}I{Xt‚©æx}
dQ
dP

(H.5.7)
So substituting for dQ
dP from Eq. (H.5.5) gives:
EQ
I{m
Xt ‚©Ωb}I{
Xt‚©æx}

= EP

I{mXt ‚©Ωb}I{Xt‚©æx} exp
ŒΩXt
œÉ 2 ‚àíŒΩ2t
2œÉ 2

(H.5.8)

Appendix H: Brownian motion: more results
337
Expressed in terms of the reÔ¨Çected Brownian motion, XR
t = 2b‚àíXt, Eq. (H.5.8)
can be written:
P

m
X
t ‚©Ωb, 
Xt ‚©æx

= EP

I{2b‚àíXRt ‚©æx} exp
ŒΩ(2b ‚àíXR
t )
œÉ 2
‚àíŒΩ2t
2œÉ 2

= exp
2ŒΩb
œÉ 2

EP

I{2b‚àíXt‚©æx} exp

‚àíŒΩXR
t
œÉ 2
‚àíŒΩ2t
2œÉ 2

(H.5.9)
Since
I{2b‚àíXRt >x} = I{‚àí2b+XRt <‚àíx} = I{XRt <2b‚àíx}
Equation (H.5.9) becomes:
P

m
X
t ‚©Ωb, 
Xt ‚©æx

= exp
2ŒΩb
œÉ 2

EP

I{Xt<2b‚àíx} exp

‚àíŒΩXt
œÉ 2 ‚àíŒΩ2t
2œÉ 2

(H.5.10)
where, for ease of notation, we now denote XR
t by Xt on the right-hand side of
Eq. (H.5.10).
Therefore:
P

m
X
t ‚©Ωb, 
Xt ‚©æx

= exp
2ŒΩb
œÉ 2
  Xt=2b‚àíx
Xt=‚àí‚àû
1
œÉ
‚àö
2œÄt
exp

‚àíX2
t
2œÉ 2t

exp
ŒΩXt
œÉ 2 ‚àíŒΩ2t
œÉ 2

dXt
=
1
œÉ
‚àö
2œÄt
exp
2ŒΩb
œÉ 2
  Xt=2b‚àíx
Xt=‚àí‚àû
exp

‚àí(X2
t + 2ŒΩXtt + ŒΩ2t2)
2œÉ 2t

dXt
=
1
œÉ
‚àö
2œÄt
exp
2ŒΩb
œÉ 2
  Xt=2b‚àíx
Xt=‚àí‚àû
exp

‚àí(Xt + ŒΩt)2
2œÉ 2t

dXt
If V = (Xt + ŒΩt)/(œÉ‚àöt) then dXt = œÉ‚àöt dV , Xt = 2b ‚àíx corresponds to
V = (2b ‚àíx + ŒΩt)/(œÉ‚àöt), and Xt = ‚àí‚àûcorresponds to V = ‚àí‚àû.
1
œÉ
‚àö
2œÄt
 Xt=2b‚àíx
Xt=‚àí‚àû
exp

‚àí(Xt + ŒΩt)2
2œÉ 2t

dXt
=
1
œÉ
‚àö
2œÄt
 V =(2b‚àíx+ŒΩt)/(œÉ‚àöt)
V =‚àí‚àû
exp

‚àíV 2
2

dV
= N1
2b ‚àíx + ŒΩt
œÉ‚àöt

We thus obtain:
P

m
X
t ‚©Ωb, 
Xt ‚©æx

= exp
2ŒΩb
œÉ 2

N1
2b ‚àíx + ŒΩt
œÉ‚àöt


338
Computational Finance Using C and C#
H.6
Proof of Eq. (H.1.7)
Since P(
Xt ‚©æx) = P(m
X
t ‚©æb, 
Xt ‚©æx) + P(m
X
t ‚©æb, 
Xt ‚©Ωx) we have:
P

m
X
t ‚©æb, 
Xt ‚©æx

= P(
Xt ‚©æx) ‚àíP

m
X
t ‚©æb, 
Xt ‚©Ωx

(H.6.1)
Substituting the results of Eqs. (H.1.4) and (H.1.6) into Eq. (H.6.1) yields:
P

m
X
t ‚©æb, 
Xt ‚©æx

= N1
ŒΩt ‚àíx
œÉ‚àöt

‚àíexp
2ŒΩb
œÉ 2

N1
2b ‚àíx + ŒΩt
œÉ‚àöt

H.7
Proof of Eq. (H.1.8)
We start by writing:
P

m
X
t ‚©Ωb

= P

m
X
t ‚©Ωb, 
Xt ‚©Ωb

+ P

m
X
t ‚©Ωb, 
Xt ‚©æb

However, P(m
X
t
‚©Ωb, 
Xt ‚©Ωb) = P(
Xt ‚©Ωb) since the probability that the
minimum is less than b and the Ô¨Ånal value 
Xt is less than b is the same as the
probability that the Ô¨Ånal value 
Xt is less than b. Therefore:
P

m
X
t ‚©Ωb

= P(
Xt ‚©Ωb) + P

m
X
t ‚©Ωb, 
Xt ‚©æb

Substituting for P(
Xt ‚©Ωb) from Eq. (H.1.4) gives:
P

m
X
t ‚©Ωb

= N1
b ‚àíŒΩt
œÉ‚àöt

+ P

m
X
t ‚©Ωb, 
Xt ‚©æb

(H.7.1)
From Eq. (H.1.6):
P

m
X
t ‚©Ωb, 
Xt ‚©æb

= exp
2ŒΩb
œÉ 2

N1
2b ‚àíb + ŒΩt
œÉ‚àöt

= exp
2ŒΩb
œÉ 2

N1
b + ŒΩt
œÉ‚àöt

(H.7.2)
Combining Eqs. (H.7.2) and (H.7.1) yields:
P

m
X
t ‚©Ωb

= N1
b ‚àíŒΩt
œÉ‚àöt

+ exp
2ŒΩb
œÉ 2

N1
b + ŒΩt
œÉ‚àöt

H.8
Proof of Eq. (H.1.9)
We start with:
P

m
X
t ‚©æb

= 1 ‚àíP

m
X
t ‚©Ωb


Appendix H: Brownian motion: more results
339
Substituting from (H.1.8):
P

m
X
t ‚©æb

= 1 ‚àíN1
b ‚àíŒΩt
œÉ‚àöt

+ exp
2ŒΩb
œÉ 2

N1
b + ŒΩt
œÉ‚àöt

(H.8.1)
But since 1 ‚àíN1(x) = N1(‚àíx), Eq. (H.8.1) can be expressed as:
P

m
X
t ‚©æb

= N1
ŒΩt ‚àíb
œÉ‚àöt

+ exp
2ŒΩb
œÉ 2

N1
b + ŒΩt
œÉ‚àöt

H.9
Proof of Eq. (H.1.10)
We will use Eq. (H.1.6) to compute ‚àÇP
‚àÇx , where P(m
X
t
‚©Ωb, 
Xt ‚©æx) is denoted
by P.
Letting Œò = (2b ‚àíx + ŒΩt)/(œÉ‚àöt) we obtain:
‚àÇP
‚àÇx = exp
2ŒΩb
œÉ 2
 ‚àÇ
‚àÇx

N1(Œò)

= exp
2ŒΩb
œÉ 2
 ‚àÇ
‚àÇŒò

N1(Œò)
‚àÇŒò
‚àÇx
= ‚àíexp
2ŒΩb
œÉ 2

1
œÉ‚àöt n(Œò)
= ‚àí
1
œÉ
‚àö
2œÄt
exp
2ŒΩb
œÉ 2

exp
(2b ‚àíx + ŒΩt)2
2œÉ 2t

(H.9.1)
Now since the probability P(m
X
t ‚©Ωb, 
Xt ‚©æx) decreases as x increases we have:
P

m
X
t ‚©Ωb, 
Xt ‚©æx

‚àíP

m
X
t ‚©Ωb, 
Xt ‚©æx + x

= ‚àí‚àÇP
‚àÇx x
(H.9.2)
and also:
P

m
X
t ‚©Ωb, 
Xt ‚©æx

‚àíP

m
X
t ‚©Ωb, 
Xt ‚©æx + x

‚àºp

m
X
t ‚©Ωb, 
Xt = x

x
(H.9.3)
where p(m
X
t ‚©Ωb, 
Xt = x) is the probability density function of P(m
X
t ‚©Ωb, 
Xt ‚©æ
x), and x ‚Üí0.
Combining Eqs. (H.9.2) and (H.9.3) we thus obtain
p

m
X
t ‚©Ωb, 
Xt = x

= ‚àí‚àÇP
‚àÇx x
So,
p

m
X
t ‚©Ωb, 
Xt = x

=
1
œÉ
‚àö
2œÄt
exp
2ŒΩb
œÉ 2

exp

‚àí(2b ‚àíx + ŒΩt)2
2œÉ 2t


340
Computational Finance Using C and C#
which means that:
p

m
X
t ‚©Ωb, 
Xt

|
X0

=
1
œÉ
‚àö
2œÄt
exp
2ŒΩb
œÉ 2

√ó exp

‚àí(2b ‚àí
Xt + ŒΩt)2
2œÉ 2t

(H.9.4)
where as usual we take 
X0 = 0. So Eq. (H.9.4) gives the probability density
for the Brownian motion which goes through the points 
X0 and 
Xt and has a
minimum value which is less than or equal to b.
Instead of considering the complete path of 
Xt from 
X0 we can move the
origin to the point 
Xt1, where t1 ‚©Ωt. Substituting into Eq. (H.9.4) we then
obtain:
p

m
X
t1,t ‚©Ωb, 
Xt

|
Xt1

=
1
œÉ‚àö2œÄ(t ‚àít1) exp
2ŒΩ(b ‚àí
Xt1)
œÉ 2

√ó exp

‚àí(2(b ‚àí
Xt1) ‚àí(
Xt ‚àí
Xt1) + ŒΩ(t ‚àít1))2
2œÉ 2(t ‚àít1)

=
1
œÉ‚àö2œÄ(t ‚àít1) exp
2ŒΩ(b ‚àí
Xt1)
œÉ 2

√ó exp

‚àí(2b ‚àí
Xt1 ‚àí
Xt + ŒΩ(t ‚àít1))2
2œÉ 2(t ‚àít1)

which can be re-expressed as:
p

m
X
t1,t2 ‚©Ωb, 
Xt2

|
Xt1

=
1
œÉ
‚àö
2œÄt
exp
2ŒΩ(b ‚àí
Xt1)
œÉ 2

√ó exp

‚àí(
Xt1 + 
Xt2 ‚àí2b ‚àíŒΩt)2
2œÉ 2t

where t2 ‚©æt1 and t = t2 ‚àít1.

Appendix I:
The Feynman‚ÄìKac formula
The Feynman‚ÄìKac formula provides a link between stochastic processes and
partial differential equations, which we will now illustrate.
In the risk neutral measure the equation followed by the asset price is:
dS = rS dt + œÉS dW
(I.1.1)
and that of the money account:
dB = Br dt
(I.1.2)
If f (S, t) is the value of a derivative then using Ito‚Äôs lemma we have:
df =
‚àÇf
‚àÇt + rS ‚àÇf
‚àÇS + œÉ 2S2
2
‚àÇ2f
‚àÇS2

+ ‚àÇf
‚àÇS œÉ dW
(I.1.3)
Since f is a tradable we know that the process ( f
B ) must be a martingale in the
risk neutral measure, and therefore have zero drift.
We will now evaluate d( f
B ) using the Ito quotient rule (see Eq. (2.6.4)):
d
X1
X2

=
X1
X2
dX1
X1
‚àídX2
X2

+ E
dX2
X2
dX2
X2

‚àíE
dX2
X2
dX1
X1

(I.1.4)
and rewrite Eqs. (I.1.2) and (I.1.3) as:
dX1 = ¬ØŒº1 dt + ¬ØœÉ1 dW
dX2 = X2 ¬ØŒº2 dt
where
d
X1
X2

= d
f
B

,
¬ØŒº1 =
‚àÇf
‚àÇt + œÉ 2S2
2
‚àÇ2f
‚àÇS2

¬ØœÉ1 = œÉ1
‚àÇf
‚àÇS ,
X1 = f,
X2 = B,
¬ØŒº2 = r
Evaluating Eq. (I.1.4) we obtain:
E
dX2
X2
dX2
X2

= E

¬ØŒº2
2 dt2
‚Üí0
E
dX1
X1
dX2
X2

= E
 ¬ØŒº1 dt + ¬ØœÉ1 dW
X1
X2 ¬ØŒº2 dt
X2

‚Üí0

342
Computational Finance Using C and C#
and therefore:
d
X1
X2

=
X1
X2
Œº1 dt + ¬ØœÉ1 dW
X1
‚àíX2 ¬ØŒº2 dt
X2

=
 ¬ØŒº1
X2
‚àí
X1
X2

¬ØŒº2

dt +
 ¬ØœÉ1
X2

= 1
X2
{ ¬ØŒº1 ‚àíX1 ¬ØŒº2} dt +
 ¬ØœÉ1
X2

(I.1.5)
Since ( X1
X2 ) is a martingale, the drift term in Eq. (I.1.5) is zero so:
¬ØŒº1 ‚àíX1 ¬ØŒº2 = 0
(I.1.6)
Therefore, substituting for ¬ØŒº1, X1 and ¬ØŒº2 in Eq. (I.1.6) we obtain:
‚àÇf
‚àÇt + rS ‚àÇf
‚àÇS + œÉ 2S2
2
‚àÇ2f
‚àÇS2 ‚àírf = 0
(I.1.7)
or
‚àÇf
‚àÇt + rS ‚àÇf
‚àÇS + œÉ 2S2
2
‚àÇ2f
‚àÇS2 = rf
(I.1.8)
which is the Black‚ÄìScholes partial differential equation, which we derived in
Chapter 4.
In general if an asset follows the process:
dS = ¬ØŒº dt + ¬ØœÉ dW
(I.1.9)
then the price of a derivative f (S, t) obeys the partial differential equation:
‚àÇf
‚àÇt + ¬ØŒº‚àÇf
‚àÇS + ¬ØŒº2
2
‚àÇ2f
‚àÇS2 = rf
(I.1.10)
or
 ‚àÇ
‚àÇt + ¬ØŒº ‚àÇ
‚àÇS + ¬ØŒº2
2
‚àÇ2
‚àÇS2

f = rf
(I.1.11)

Appendix J:
Answers to problems
Problem 1
Let Œ≤k
t = E[W k
t ], where Wt0 = 0.
(a) Show using Ito‚Äôs formula for k = 2, 3, 4, . . . that
Œ≤k
t = 1
2(k ‚àí1)
 t
s=0
Œ≤k‚àí2
s
ds
(b) Deduce that E[W 4
t ] = 3t2
(c) What is E[W 6
t ]
1(a)
Let œÜ(Wt) = W k
t ; using Ito‚Äôs formula we have:
dœÜ = ‚àÇœÜ
‚àÇWt
dWt + 1
2
‚àÇ2œÜ
dW 2t
dt
So
d

W k
t

= kW k‚àí1
t
dWt + 1
2k(k ‚àí1)W k‚àí2
t
dt
Integrating both sides
 t
s=0
d

W k
s

= k
 t
s=0
W k‚àí1
s
dWs + 1
2(k ‚àí1)
 t
s=0
W k‚àí2
s
ds
W k
t ‚àíW k
t0 = k
 t
s=0
W k‚àí1
s
dWs + 1
2(k ‚àí1)
 t
s=0
W k‚àí2
s
ds
Now
E

s=0
W k‚àí1
s
dWs

= 0
and using Fubini‚Äôs theorem
E
 t
s=0
W k‚àí2
s
ds

=
 t
s=0
E

W k‚àí2
s

ds

344
Computational Finance Using C and C#
Therefore
E

W k
t

‚àíE

W k
t0

= kE
 t
s=0
W k‚àí1
s
dWs

+ 1
2(k ‚àí1)
 t
s=0
E

W k‚àí2
s

ds
= 1
2(k ‚àí1)
 t
s=0
E

W k‚àí2
s

ds
Since E[W k
t0] = 0 we obtain
Œ≤k
t = 1
2(k ‚àí1)
 t
s=0
Œ≤k‚àí2
s
ds
1(b)
Since Wt is standard Brownian motion (zero drift and œÉ = 1)
E

W 2
t

= t
Substituting k = 4 in the relation from part (a) yields
E

W 4
t

= 4 √ó 3
2
 t
s=0
E

W 2
s

ds = 12
2
 t
s=0
s ds = 6t2
2 = 3t2
1(c)
Using the relation from part (a) with k = 6 yields
E

W 6
t

= 6 √ó 5
2
 t
s=0
E

W 4
s

ds = 6 √ó 5
2
 t
s=0
3s2 ds = 30
2
3t3
3 = 15t3
Problem 2
Solve
dXt = Xt dt + dWt
Rearranging we have
dXt ‚àíXt dXt = dWt
Using the integrating factor exp(‚àít) gives
exp(‚àít) dXt ‚àíXt exp(‚àít) dt = exp(‚àít) dWt
and
d

Xt exp(‚àít)

= ‚àíXt exp(‚àít) dt + exp(‚àít) dXt = exp(‚àít) dWt
So
d

Xt exp(‚àít)

= exp(‚àít) dWt

Appendix J: Answers to problems
345
Integrating both sides
 t
s=0
d

Xs exp(‚àís)

=
 t
s=0
exp(‚àís) dWs
and
Xt exp(‚àít) ‚àíXt0 =
 t
s=0
exp(‚àís) dWs
which means that
Xt = Xt0 exp(t) +
 t
s=0
exp(t ‚àís) dWs
Problem 3
Solve
dXt = ‚àíXt dt + exp(‚àít) dWt
Rearranging yields
dXt + Xt dt = exp(‚àít) dWt
Using the integrating factor exp(t) we obtain
exp(t) dXt + exp(t)Xt dt = dWt
and
d

exp(t)Xt

= exp(t) dXt + exp(t)Xt dt
which means that
d

exp(t)Xt

= dWt
and
 t
s=0
d

exp(s)Xs

=
 t
s=0
dWs
Integrating
Xt exp(t) ‚àíXt0 = Wt ‚àíWt0
Since Wt0 = 0
Xt exp(t) ‚àíXt0 = Wt
that is
Xt = Xt0 exp(‚àít) + Wt exp(‚àít)

346
Computational Finance Using C and C#
Problem 4
Prove
s=0
W 2
s dWs = 1
3W 3
t ‚àí
 t
s=0
Ws ds
Using Ito‚Äôs formula
d

W 3
t

= 3W 2
t dW + 6
2Wt dt
Therefore
 t
s=0
d

W 3
t

= 3
 t
s=0
W 2
s dWs + 3
 t
s=0
Ws ds
and
W 3
t ‚àíW 3
t0 = 3
 t
s=0
W 2
s dWs + 3
 t
s=0
Ws ds
Using Wt0 = 0 we obtain
W 3
t = 3
 t
s=0
W 2
s dWs + 3
 t
s=0
Ws ds
So
 t
s=0
W 2
s dWs = 1
3W 3
t ‚àí
 t
s=0
Ws ds
Problem 5
Solve dYt = r dt + Œ±Yt dWt where r and Œ± are real constants.
Use the integrating factor Ft = exp(‚àíŒ±Wt + Œ±2
2 t)
dYt ‚àíŒ±Yt dt = r dt
Multiplying by Ft
dYt exp

‚àíŒ±Wt + Œ±2
2 t

‚àíŒ±Yt exp

‚àíŒ±Wt + Œ±2
2 t

= r exp

‚àíŒ±Wt + Œ±2
2 t

dt
Using Ito‚Äôs formula
d

Yt exp

‚àíŒ±Wt + Œ±2
2 t

= dYt exp

‚àíŒ±Wt + Œ±2
2 t

‚àíŒ±Yt exp

‚àíŒ±Wt + Œ±2
2 t

dWt

Appendix J: Answers to problems
347
= r exp

‚àíŒ±Wt + Œ±2
2 t

dt
Integrating
 t
s=0
d

Ys exp

‚àíŒ±Ws + Œ±2
2 s

= r
 t
s=0
exp

‚àíŒ±Ws + Œ±2
2 s

ds
Yt exp

‚àíŒ±Wt + Œ±2
2 t

‚àíYt0 exp(‚àíŒ±Wt0) = r
 t
s=0
exp

‚àíŒ±Ws + Œ±2
2 s

ds
Using Wt0 = 0 yields
Yt exp

‚àíŒ±Wt + Œ±2
2 t

= Yt0 + r
 t
s=0
exp

‚àíŒ±Ws + Œ±2
2 s

ds
So
Yt = Yt0 exp

Œ±Wt ‚àíŒ±2
2 t

+ r
 t
s=0
exp

Œ±(Wt ‚àíWs) + Œ±2
2 (t ‚àís)

ds
Problem 6
6(a)
Solve
dXt = (m ‚àíXt) dt + œÉ dWt
where m and œÉ are constants.
Rearranging
dXt + Xt dt = m dt + œÉ dWt
Use the integrating factor exp(t)
d

Xt exp(t)

= exp(t) dXt + Xt exp(t) dt
= m exp(t) dt + œÉ exp(t) dWt
Integrating
 t
s=0
d

Xs exp(s)

= m
 t
s=0
exp(s) ds + œÉ
 t
s=0
exp(s) dWs
Xt exp(t) ‚àíXt0 = m

exp(t) ‚àí1

+ œÉ
 t
s=0
exp(s) dWs
which can be expressed as
Xt = m + (Xt0 ‚àím) exp(‚àít) + œÉ exp(‚àít)
 t
s=0
exp(s) dWs

348
Computational Finance Using C and C#
6(b)
Taking expectations of the expression for Xt derived in part (a)
E[Xt] = m + (Xt0 ‚àím) exp(‚àít)
where we have used
E
 t
s=0
exp(s) dWs

= 0
Var[Xt] = E

Xt ‚àíE[Xt]
2
= E

œÉ 2 exp(‚àí2t)
 t
s=0
exp(s) dWs
2
= œÉ 2 exp(‚àí2t)E
 t
s=0
exp(s) dWs
2
From Ito‚Äôs isometry
Var[Xt] = œÉ 2 exp(‚àí2t)E
 t
s=0
exp(2s) ds

= œÉ 2 exp(‚àí2t)
exp(2s)
2
t
s=0
= œÉ 2 exp(‚àí2t)
exp(2t)
2
‚àí1
2

which gives
Var[Xt] =
1
2œÉ 2

1 ‚àíexp(‚àí2t)

Problem 7
Consider the equation dSt = ŒºtSt dt + œÉtSt dWt where the value of St at time
t = 0 is denoted by S0.
(a) Show that the mean is
E

log(St)

= log(S0) +
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ
(b) Show that the variance is
Var

log(St)

=
 t
œÑ=0
œÉ 2
œÑ dœÑ

Appendix J: Answers to problems
349
7(a)
If œÜ = log(S) then using Ito‚Äôs formula we have
dœÜ = ‚àÇœÜ
‚àÇS dS + 1
2
‚àÇ2œÜ
‚àÇS2 E

(dS)2
= 1
S {ŒºtSt dt + œÉtSt dWt} ‚àí1
2
S2
S2 œÉt dt
So
d

log(St)

=

Œºt ‚àíœÉ 2
t
2

dt + œÉt dWt
and therefore
 t
œÑ=0
d

log(SœÑ)

=
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ +
 t
œÑ=0
œÉœÑ dWœÑ
which gives
log(SœÑ) ‚àílog(S0) =
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ +
 t
œÑ=0
œÉœÑ dWœÑ
Taking expectations we obtain
E

log(St)

‚àíE

log(S0)

= E
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ

+ E
 t
œÑ=0
œÉœÑ dWœÑ

Since
 t
œÑ=0(ŒºœÑ ‚àíœÉ 2
œÑ
2 ) dœÑ is deterministic
E
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ

=
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ
and using
E
 t
œÑ=0
œÉœÑ dWœÑ

= 0
and
E

log(S0)

= log(S0)
we Ô¨Ånally obtain
E

log(St)

= log(S0) +
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ
7(b)
Var

log(St)

= E

log(St) ‚àíE

log(St)
2
= E

log(S0) +
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ
+
 t
œÑ=0
œÉœÑ dWœÑ ‚àílog(S0) ‚àí
 t
œÑ=0

ŒºœÑ ‚àíœÉ 2
œÑ
2

dœÑ
2

350
Computational Finance Using C and C#
= E
 t
œÑ=0
œÉœÑ dWœÑ
2
Using Ito‚Äôs isometry we have:
E
 t
œÑ=0
œÉœÑ dœÑ
2
= E
 t
œÑ=0
œÉ 2
œÑ dœÑ

Since
 t
œÑ=0 œÉ 2
œÑ dœÑ is deterministic we can write
E
 t
œÑ=0
œÉ 2
œÑ dœÑ

=
 t
œÑ=0
œÉ 2
œÑ dœÑ
and Ô¨Ånally we obtain
Var

log(St)

=
 t
œÑ=0
œÉ 2
œÑ dœÑ
Problem 8
Prove that if œÜ = exp(tWt) then
dœÜ = œÜ

Wt + t2
2

dt + tœÜ dWt
From Ito we have
dœÜ = ‚àÇœÜ
‚àÇt dt + ‚àÇœÜ
‚àÇWt
dWt + 1
2
‚àÇ2œÜ
‚àÇW 2t
E

( dWt)2
Now
‚àÇœÜ
‚àÇt = Wt exp(tWt),
‚àÇœÜ
‚àÇWt
= t exp(tWt),
‚àÇ2œÜ
‚àÇW 2t
= t2 exp(tWt)
So
dœÜ = Wt exp(tWt) dt + t exp(tWt) dWt + t2
2 exp(tWt) dt
where we have used E[(dWt)2] = dt.
Therefore
dœÜ = œÜ

Wt + t2
2

dt + tœÜ dWt
Problem 9
Given
Zt = exp
 t
s=0
Œ∏s dWs ‚àí1
2
 t
s=0
Œ∏2
s ds


Appendix J: Answers to problems
351
Use Ito to prove that the process for Zt is dZt = ZtŒ∏t dWt.
9(a)
Let
Xt =
 t
s=0
Œ∏s dWs ‚àí1
2
 t
s=0
Œ∏2
s ds
so
dXt = Œ∏t dWt ‚àí1
2Œ∏2
t dt
We thus have:
Zt = exp(Xt)
Using Ito we have
dZt = ‚àÇZt
‚àÇXt
dXt + ‚àÇ2Zt
‚àÇX2t
(dXt)2
so
dZt = Zt

Œ∏t dWt ‚àí1
2Œ∏2
t dt

+ ZtE

Œ∏t dWt ‚àí1
2Œ∏2
t dt

Œ∏t dWt ‚àí1
2Œ∏2
t dt

Now
E

Œ∏t dWt ‚àí1
2Œ∏2
t dt

Œ∏t dWt ‚àí1
2Œ∏2
t dt

= E

Œ∏2
t dW 2
t

+ E
1
4Œ∏4
t dt2

‚àíE

Œ∏3
t dWt dt

Ignoring terms in dt of order higher than 1 using the fact that:
E

dW 2
t

= Œ∏2
t E

dW 2
t

= Œ∏2
t dt
and
E

Œ∏3
t Œ∏t dWt dt

= Œ∏3
t dt E[dWt] = 0
We have
dZt = Zt

Œ∏t dWt ‚àí1
2Œ∏2
t dt

+ 1
2ZtŒ∏2
t dt = ZtŒ∏t dWt
Hence we have shown that
dZt = ZtŒ∏t dWt

352
Computational Finance Using C and C#
Problem 10
Let St = S0 exp(Œºt + œÉWt) where Œº and œÉ are constants.
(a) Show by Ito‚Äôs lemma that
dSt =

Œº + œÉ 2
2

St dt + œÉSt dWt
(b) Show that
E[St] ‚àíE[S0] =

Œº + œÉ 2
2
  t
œÑ=0
E

S(œÑ)

dœÑ
(c) Show that
E[St] = S0 exp

Œºt + œÉ 2
2 t

10(a)
Let œÜ = S0 exp(Œºt + œÉWt).
Then using Ito‚Äôs formula:
dœÜ = ‚àÇœÜ
‚àÇt dt + ‚àÇœÜ
‚àÇWt
dWt + 1
2
‚àÇ2œÜ
‚àÇW 2t
E

(dWt)2
So
dœÜ = ŒºœÜ dt + œÉœÜ dWt + 1
2œÜœÉ 2 dt
where we have used ‚àÇ2œÜ
‚àÇW 2t = œÜœÉ 2 and E[(dWt)] = dt.
Therefore
dSt =

Œº + 1
2œÉ 2

St dt + StœÉ dWt
10(b)
From part (a) we have
 t
œÑ=0
dSœÑ =

Œº + 1
2œÉ 2
  t
œÑ=0
SœÑ dœÑ + œÉ
 t
œÑ=0
SœÑ dWœÑ
Therefore
St ‚àíS0 =

Œº + 1
2œÉ 2
  t
œÑ=0
SœÑ dœÑ + œÉ
 t
œÑ=0
SœÑ dWœÑ
Taking expectations we have
E[St] ‚àíE[S0] =

Œº + 1
2œÉ 2

E
 t
œÑ=0
SœÑ dœÑ

+ œÉE
 t
œÑ=0
SœÑ dWœÑ


Appendix J: Answers to problems
353
Using the fact that:
E
 t
œÑ=0
f (œÑ) dWœÑ

= 0
and from Fubini‚Äôs theorem:
E
 t
œÑ
S(œÑ) dœÑ

=
 t
œÑ
E

S(œÑ)

dœÑ
we thus Ô¨Ånally obtain:
E[St] ‚àíE[S0] =

Œº + 1
2œÉ 2
  t
œÑ=0
E[SœÑ] dœÑ
10(c)
From part (a) we know:
dSt =

Œº + 1
2œÉ 2

St dt + StœÉ dWt
Therefore
d

log (St)

=

Œº + 1
2œÉ 2

dt + œÉ dWt
 t
œÑ=0
d

log (SœÑ)

=

Œº + 1
2œÉ 2
  t
œÑ=0
dœÑ + œÉ
 t
œÑ=0
dWœÑ
So
log (St) ‚àílog (S0) =

Œº + 1
2œÉ 2

t + œÉ
 t
œÑ=0
dWœÑ
Taking expectations we obtain:
E

log(St)

‚àíE

log(S0)

=

Œº + 1
2œÉ 2

t + E

œÉ
 t
œÑ=0
dWœÑ

Since
E

œÉ
 t
œÑ=0
dWœÑ

= 0
and
E[S0] = S0
we have:
log
E[St]
S0

=

Œº + 1
2œÉ 2

t
which yields:
E[St] = S0 exp

Œº + 1
2œÉ 2

t


354
Computational Finance Using C and C#
Problem 11
Let œÜ = XtYt.
From Ito‚Äôs formula we obtain:
dœÜ = ‚àÇœÜ
‚àÇXt
dXt + E
‚àÇYt
‚àÇYt
dYt + 1
2
‚àÇ2œÜ
‚àÇXt ‚àÇYt
dXt dYt + 1
2
‚àÇ2œÜ
‚àÇYt ‚àÇXt
dYt dXt

Now
‚àÇ2œÜ
‚àÇXt ‚àÇYt
=
‚àÇ2œÜ
‚àÇYt ‚àÇXt
= 1,
‚àÇœÜ
‚àÇXt
= Yt
and
‚àÇœÜ
‚àÇYt
= Xt
We thus obtain:
dœÜ = Yt dXt + Xt dYt + E[dXt dYt]
Using
d(XtYt) = Yt dXt + Xt dYt + E[dXt dYt]
we have:
 t
s=0
d(XtYt) =
 t
s=0
Ys dXs +
 t
s=0
XsdYs +
 t
s=0
E[dXs dYs]
Therefore
XtYt ‚àíXt0Yt0 =
 t
s=0
YsdXs +
 t
s=0
XsdYs +
 t
s=0
E[dXs dYs]
Thus
 t
s=0
XsdYs = XtYt ‚àíXt0Yt0 ‚àí
 t
s=0
YsdXs ‚àí
 t
s=0
E[dXs dYs]

References
Abramowitz, M., and Stegun, I.A. (1968). Handbook of Mathematical Functions. Dover
Publications.
Bachelier, L. (1900). Th√©orie de la sp√©culation. Annales scientiÔ¨Åques de l‚Äô√âcole Normale
Sup√©rieure, 17:21‚Äì86.
Barone-Adesi, G., and Whaley, R.E. (1987). EfÔ¨Åcient Analytic Approximation of Ameri-
can Option Values. The Journal of Finance, 42(2):301‚Äì320.
Barraquand, J., and Martineau, D. (1995). Numerical Valuation of High Dimen-
sional Multivariate American Securities. Journal of Finance ad Quantitative Analysis,
30:383‚Äì405.
Baxter, M., and Rennie, A. (1996). Financial Calculus: An Introduction to Derivative
Pricing. Cambridge University Press.
Black, F. (1973). Fact and Fantasy in the Use of Options and Corporate Liabilities. Finan-
cial Analysts Journal, 31:36‚Äì41, 61‚Äì72. Journal of Political Economy, 81:637‚Äì657.
Boyle, P.P., and Tian, Y. (1998). An Explicit Finite Difference Approach to the Pricing of
Barrier Options. Applied Mathematical Finance, 5:17‚Äì43.
Box, G.E.P., and Muller, M.E. (1958). A Note on the Generation of Random Normal
Deviates. Annals of Mathematical Statistics, 29:610‚Äì611.
Boyle, P.P., Evnine, J., and Gibbs, S. (1989). Numerical Evaluation of Multivariate Con-
tingent Claims. The Review of Management Studies, 2(2):241‚Äì250.
Boyle, P.P., Broadie, M., and Glasserman, P. (1997). Monte Carlo Methods for Security
Pricing. Journal of Economic Dynamics and Control, 21:1267‚Äì1321.
Brigo, D., and Mercurio, F. (2001). Interest Rate Models ‚Äì Theory and Practice: With
Smile, InÔ¨Çation and Credit. Springer-Verlag.
Broadie, M., and DeTemple, J. (1996). American Option Valuation: New Bounds, Ap-
proximations, and a Comparison of Existing Methods. The Review of Financial Stud-
ies, 9(4):1211‚Äì1250.
Broadie, M., and Glasserman, P. (1997). Pricing American-Style Securities Simulation.
Journal of Economic Dynamics and Control, 21:1323‚Äì1352.
Brotherton-Ratcliffe, R. (1994). Monte Carlo Motoring. Risk, 7(12):53‚Äì58.
CaÔ¨Çisch, R.E., Morokoff, W., and Owen, A. (1997). Valuation of Mortgage-Backed Se-
curities Using Brownian Bridges to Reduce Effective Dimension. The Journal of Com-
putational Finance, 1(1):27‚Äì46.
Cox, D.R., and Miller, H.D. (1965). The Theory of Stochastic Processes. Methuen & Co
Ltd.
Cox, J.C., Ross, S.A., and Rubinstein, M. (1979). Option Pricing: A SimpliÔ¨Åed Ap-
proach. Journal of Financial Economics, 7:229‚Äì263.
Crank, J., and Nicolson, P. (1947). A Practical Method for Numerical Evaluation of
Solutions of Partial Differential Equations of the Heat Conduction Type. Proceedings
of the Cambridge Philosophical Society, 43:50‚Äì67.

356
Computational Finance Using C and C#
Einstein, A. (1905). On the Movement of Small Particles Suspended in a Stationary Liq-
uid Demanded by the Molecular-Kinetic Theory of Heat. Annalen der Physik, 17.
Evans, M., Hastings, N., and Peacock, B. (2000). Statistical Distributions, Third Edition.
Wiley.
Garman, M.B., and Kohlhagen, S.W. (1983). Foreign Currency Option Values. Journal
of International Money and Finance, 2:231‚Äì237.
Geske, R. (1979). A Note on an Analytic Valuation Formula for Unprotected American
Options on Stocks with Known Dividends. Journal of Econometrics, 7:375‚Äì380.
Geske, R., and Johnson, H.E. (1984). The American Put Options Valued Analytically.
Journal of Finance, 39:1511‚Äì1524.
Golub, G.H., and Van Loan, C.F. (1989). Matrix Computation. The John Hopkins Uni-
versity Press.
Grimmett, G., and Welsh, D. (1986). Probability: An Introduction. Oxford Science Pub-
lications.
Hager, W. (1988). Applied Numerical Linear Algebra. Prentice Hall.
Harrison, J.M., and Kreps, D. (1979). Martingales and Arbitrage in Multiperiod Securi-
ties Markets. Journal of Economic Theory, 20:381‚Äì408.
Harrison, J.M., and Pliska, D. (1981). Martingales and Stochastic Integrals in the Theory
of Continuous Trading. Stochastic Processes and Their Applications, 11:215‚Äì260.
Higham, N.J. (2002). Computing the Nearest Correlation Matrix ‚Äì A Problem from
Finance. IMA Journal of Numerical Analysis, 22(3):329‚Äì343.
Hull, J.C. (1997). Options, Futures and Other Derivatives, Third Edition. Prentice Hall.
Hull, J.C. (2003). Options, Futures and Other Derivatives, Fifth Edition. Prentice Hall.
Johnson, H. (1987). Options on the Maximum or the Minimum of Several Assets. Jour-
nal of Financial and Quantitative Analysis, 22(3):277‚Äì283.
Kamrad, B., and Ritchken, P. (1991). Multinomial Approximating Models for Options
with k State Variables. Management Science, 37(12):1640‚Äì1652.
Karatzas, I., and Shreve, S. (1991). Brownian Motion and Stochastic Calculus. Springer-
Verlag, New York.
Levy, P. (1939). Sur certains processus stochastiques homog√®nes. Compositio Mathemat-
ica, 7:283‚Äì339.
Levy, P. (1948). Processus stochastiques et mouvement brownien. Gauthier-Villar, Paris.
MacMillan, L.W. (1986). Analytic Approximation for the American Put Option. Ad-
vances in Futures and Options Research, 1:119‚Äì139.
Margrabe, W. (1978). The Value of an Option to Exchange one Asset for Another. Jour-
nal of Finance, 33(1):177‚Äì186.
Musiela, M., and Rutkowski, M. (1998). Martingale Methods in Financial Modelling.
Springer-Verlag.
Marchuk, G.I., and Shaidurov, V.V. (1983). Difference Methods and Their Extrapola-
tions. Springer-Verlag.
√òksendal, B. (2003). Stochastic Differential Equations: An Introduction with Applica-
tions. Springer-Verlag.
Perrin, J.B. (1909). Annales de Chimie et de Physique, 8me series, September 1909,
Translated by F. Soddy, as Brownian Movement and Molecular Reality, Taylor and
Francis, London, 1910.
Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery, B.P. (1992). Numerical
Recipes in C: The Art of ScientiÔ¨Åc Computing, Second Edition. Cambridge Univer-
sity Press.

References
357
Qi, H.D., and Sun, D. (2006). A Quadratically Convergent Newton Method for Com-
puting the Nearest Correlation Matrix. SIAM Journal on Matrix Analysis and Appli-
cations, 28(2):360‚Äì385.
Ramsbottom, J. (1932). Centenary of Robert Brown‚Äôs Discovery of the Nucleus ‚Äì
Exhibit at Natural History Museum. The Journal of Botany British and Foreign,
(January):13‚Äì16.
Rebonato, R., and J√§ckel, P. (1999/2000). The Most General Methodology for Creating a
Valid Correlation Matrix for Risk Management and Option Pricing Purposes. Journal
of Risk, 2(2).
Reiner, E. (1992). Quanto Mechanics. Risk, 5(3):59‚Äì63.
Roll, R. (1977). An Analytic Valuation Formula for Unprotected American Call Options
on Stocks with Known Dividends. Journal of Econometrics, 5:251‚Äì258.
Shreve, S., Chalasani, P., and Jha, S. (1997). Stochastic Calculus and Finance. Available
at: http://www.stat.berkeley.edu/users/evans/shreve.pdf.
Smith, G.D. (1985). Numerical Solution of Partial Differential Equations: Finite Differ-
ence Methods. Oxford University Press.
Stulz, R.M. (1982). Options on the Minimum or Maximum of Two Risky Assets. Journal
of Financial Economics, 10:161‚Äì185.
Tilley, J.A. (1993). Valuing American Options in a Path Simulation Model. Transactions
of the Society of Actuaries, 45:83‚Äì104.
Wiener, N. (1923). Differential Spaces. Journal of Mathematical Physics, 2:131‚Äì174.
Wiener, N. (1924). Un probl√®me de probabilit√© d√©nombrables. Bulletin de Soci√©t√© Math-
√©matique de France, 52:569‚Äì578.
Whaley, R.E. (1981). On the Valuation of American Call Options on Stocks with Known
Dividends. Journal of Financial Economics, 9:207‚Äì211.
Further reading
Aitchison, J., and Brown, J.A.C. (1966). The Lognormal Distribution. Cambridge Uni-
versity Press.
Andersen, L.B.G., and Brotherton-Ratcliffe, R. (1998). The Equity Option Volatility
Smile: An Implicit Finite-Difference Approach. Journal of Computational Finance,
1(2):5‚Äì37.
Anderson, T.W. (1984). An Introduction to Multivariate Statistical Analysis, Second Edi-
tion. Wiley, New York.
Berndt, E.K., Hall, B.H., Hall, R.E., and Hausman, J.A. (1974). Estimation and Infer-
ence in Nonlinear Structural Models. Annals of Economic and Social Measurement,
3/4:653‚Äì665.
Beyer, W.H. (1982). CRC Standard Mathematical Tables. CRC Press, Florida.
Black, F., and Scholes, M. (1973). The Pricing of Corporate Liabilities. Journal of Politi-
cal Economy, 81:637‚Äì657.
Bratley, P. (1986). Algorithm 647: Implementation and Relative EfÔ¨Åciency of Quasiran-
dom Sequence Generators. ACM Transactions on Mathematical Software, 12(4):362‚Äì
376.
Bratley, P., and Fox, B.L. (1988). Algorithm 659: Implementing Sobol‚Äôs Quasirandom
Sequence Generator. ACM Transactions on Mathematical Software, 14(1):88‚Äì100.

358
Computational Finance Using C and C#
Bratley, P., Fox, B.L., and Niederreiter, H. (1992). Implementation and Tests of Low-
Discrepancy Sequences. ACM Transactions on Modeling and Computer Simulation,
2(3):195‚Äì213.
Brennan, M.J., and Schwartz, E.S. (1978). Finite Difference Methods and Jump Processes
Arising in the Pricing of Contingent Claims: A Synthesis. Journal of Financial and
Quantitative Analysis, 13:462‚Äì474.
Chan, T.F., Golub, G.H., and Leveque, R.J. (1982). Updating Formulae and a Pair-
wise Algorithm for Computing Sample Variances. In: Caussinus, H.,, Tomassone,
R.,, Ettinger, P., eds.)Compstat 1982 Part 1: Proceedings in Computational Statistics.
Physica-Verlag, 1982.
Cotton, I.W. (1975). Remark on Stably Updating Mean and Standard Deviation of Data.
Communications of the ACM, 18(8):458.
Cox, D.R., and Hinkley, D.V. (1979). Theoretical Statistics. Chapman & Hall.
Craig, I.J.D., and Sneyd, A.D. (1988). An Alternating Direction Implicit Scheme for Par-
abolic Equations with Mixed Derivatives. Computers & Mathematics with Applica-
tions, 16(4):341‚Äì350.
Dickey, J.M. (1967). Multivariate Generalizations of the Multivariate t Distribution
and the Inverted Multivariate t Distribution. Annals of Mathematical Statistics,
38(2):511‚Äì518.
DufÔ¨Åe, D. (1996). Dynamic Asset Pricing Theory, Second Edition. Princeton University
Press.
Engle, R.F. (1995). ARCH: Selected Readings. Advanced Texts in Econometrics. Oxford
University Press.
Faure, H. (1982). Discr√©pance de suites associ√©es √† un syst√®me de num√©ration (en dimen-
sion s). Acta Arithmetica, 41:337‚Äì351.
Feller, W. (1971). An Introduction to Probability Theory and Its Applications, Vol. II.
Wiley.
Freedman, D. (1983). Brownian Motion and Diffusion. Springer-Verlag, New York.
Glasserman, P. (2004). Monte Carlo Methods in Financial Engineering. Springer-Verlag,
New York.
Glasserman, P., and Heidelberger, P. (2000). Variance Reduction Techniques for Value-
at-Risk with Heavy-Tailed Risk Factors. In: Joines, J.A., Barton, R.R., Kang, K., Fish-
wick, P.A. (eds.), Proceedings of the 2000 Winter Simulation Conference.
Goldberger, A.S. (1997). A Course in Econometrics. Harvard University Press.
Good, I.J. (1979). Computer Generation of the Exponential Power Distribution. Journal
of Statistical Computation and Simulation, 9(3):239‚Äì240.
Hamilton, J. (1994). Time Series Analysis. Princeton University Press.
Hanson, R.J. (1975). Stably Updating Mean and Standard Deviation of Data. Commu-
nications of the ACM, 18(1):57‚Äì58.
Haug, E.G. (1998). Option Pricing Formulas. McGraw Hill.
Hunt, P.J., and Kennedy, J.E. (2004). Financial Derivatives in Theory and Practice. Wiley.
J√§ckel, P. (2002). Monte Carlo Methods in Finance. Wiley.
Johnson, N.L., and Kotz, S. (1992). Distributions in Statistics: Continuous Multivariate
Distributions. Wiley.
Johnson, N.L., Kotz, S., and Kemp, A. (1992). Univariate Discrete Distributions. Wiley.
Johnson, N.L., Kotz, S., and Balakvishnam, N. (1994). Continuous Univariate Distribu-
tions, Second Edition. Wiley.
Johnson, R.A., and Wichern, D.W. (1999). Applied Multivariate Statistical Analysis.
Prentice Hall.

References
359
Jorion, P. (1997). Value at Risk. McGraw Hill.
Joshi, M.S. (2004). The Concepts and Practice of Mathematical Finance. Cambridge
University Press.
Kloeden, P.E., and Platen, E. (1999). Numerical Solution of Stochastic Differential Equa-
tions. Springer-Verlag.
Krzanowski, W.J. (2000). Principles of Multivariate Analysis: A User‚Äôs Perspective. Ox-
ford University Press.
Levy, G. (2004). Computational Finance: Numerical Methods for Pricing Financial In-
struments. Elsevier.
Mardia, K.V., Kent, J.T., and Bibby, J.M. (1988). Multivariate Analysis. Probability and
Mathematical Statistics. Academic Press, London.
Martellini, L., and Priaulet, P. (2001). Fixed-Income Securities: Dynamic Methods for
Interest Rate Risk Pricing and Hedging. John Wiley.
Merton, R.C. (1973). The Theory of Rational Option Pricing. The Bell Journal of Econ-
omy and Management Science, 4(1):141‚Äì181.
Markowitz, H.M. (1989). Mean-Variance Analysis in Portfolio Choice and Capital Mar-
kets. Blackwell.
McIntyre, R. (1999). Black‚ÄìScholes Will Do. Energy & Power Risk Management,
(November):26‚Äì27.
McKee, S., and Mitchell, A.R. (1970). Alternating Direction Methods for Parabolic
Equations in Two Space Dimensions with a Mixed Derivative. The Computer Journal,
13(1):81‚Äì86.
Mitchell, A.R., and GrifÔ¨Åths, D.F. (1980). The Finite Difference Method in Partial Dif-
ferential Equations. Wiley, New York.
Morokoff, W. (1999). The Brownian Bridge E‚ÄìM Algorithm for Covariance Estimation
with Missing Data. Journal of Computational Finance, 2(2):75‚Äì100.
Morgan, J.P. (1996). RiskMetrics ‚Äì Technical Document, Fourth Edition. New York.
Niederreiter, H. (1992). Random Number Generation and Quasi-Monte Carlo Methods.
SIAM.
Pelsser, A. (2000). EfÔ¨Åcient Methods for Valuing Interest Rate Derivatives. Springer-
Verlag.
Rebonato, R. (1998). Interest-Rate Option Models, Second Edition. Wiley.
Richardson, L.F. (1910). The Approximate Arithmetical Solution by Finite Differences
od Physical Problems Involving Differential Equations, with an Application to the
Stresses in a Masonry Dam. Philos. Trans. R. Soc. Lond. A, 210:307‚Äì357.
Richardson, L.F., and Gaunt, G.A. (1927). The Deferred Approach to the Limit. Philos.
Trans. R. Soc. Lond. A, 226:299‚Äì361.
Richardson, L.F. (1927). Philosophical Transactions of the Royal Society of London,
Series A, 226:299.
Rogers, L.C.G., and Talay, D. (1997). Numerical Methods in Finance. Cambridge Uni-
versity Press.
Schonbucher, P.J. (2003). Credit Derivatives Pricing Models: Model, Pricing and Imple-
mentation. Wiley.
Sobol, I.M. (1967). The Distribution of Points in a Cube and the Approximate Eval-
uation of Integrals. USSR Computational Mathematics and Mathematical Physics,
7(4):86‚Äì112.
Strang, G. (1976). Linear Algebra and Its Applications. Academic Press.
Stuart, A., and Ord, J.K. (1987). Kendall‚Äôs Advanced Theory of Statistics, Fifth Edition.
GrifÔ¨Ån.

360
Computational Finance Using C and C#
West, D.H.D. (1979). Updating Mean and Variance Estimates: An Improved Method.
Communications of the ACM, 22(9):532‚Äì535.
Wilmott, P., Howison, S., and Dewynne, J. (1995). The Mathematics of Financial Deriv-
atives. Cambridge University Press.

Index
A
Absolute pricing errors 162
American options 59, 97‚Äì179
call options 99‚Äì102
Black approximation 101, 102
with cash dividends 97‚Äì102
critical asset values 107‚Äì109
MacMillan‚ÄìBarone-Adesi‚Äì
Whaley method
105, 106, 112‚Äì114
pricing errors 135
Roll‚ÄìGeske‚ÄìWhaley
approximation 97‚Äì101
implied volatility 81
put options 179
critical asset values 109‚Äì111
MacMillan‚ÄìBarone-Adesi‚Äì
Whaley method
106, 107, 112‚Äì114
pricing errors 136
stochastic lattice 172‚Äì180
asset prices 173, 174
Monte Carlo estimate 177‚Äì180
option prices 174‚Äì176
simulation parameters 173
two assets 194‚Äì200
vanilla 97‚Äì111
call with cash dividends 97‚Äì102
grid methods 135‚Äì167
lattice methods 114‚Äì135
MacMillan‚ÄìBarone-Adesi‚Äì
Whaley method
102‚Äì107
numerical solution of critical
asset values 107‚Äì111
Amortization 212
Analytic pricing
down and out call options 86‚Äì88
up and out call options 88‚Äì91
Analytics_MathLib function 262‚Äì266
Annualized standard deviation 78
Arithmetic progression 323
Asset price, stochastic lattice 173, 174
Asset price index 161
Asset price movements, Brownian
motion 9, 10
Asset values 121, 122
Avogadro‚Äôs number 5
B
Back-substitution 146
Backwards iteration 123‚Äì125,
147‚Äì150
Barrier options 85‚Äì95, 118, 295‚Äì302
down and out call 86‚Äì88, 295‚Äì298
Monte Carlo pricing 91‚Äì95
equity 275‚Äì280
foreign exchange 284‚Äì288
up and out call 88‚Äì91, 298‚Äì301
Base currency 231
Basis swap 212‚Äì214
Bayes law 20, 93
BBS see binomial
Black‚ÄìScholes method
BBSR see binomial
Black‚ÄìScholes method, with
Richardson extrapolation
BEGKR method 185, 187‚Äì189
Binomial Black‚ÄìScholes method
131‚Äì133
with Richardson extrapolation
133‚Äì135

362
Index
Binomial lattice 81, 114‚Äì122
backwards iteration 123‚Äì125
with BBS and BBSR 131‚Äì135
computation of Greeks 125‚Äì129
construction and use 120‚Äì128
with control variate 129, 130
node asset values 121, 122
terminal node option payoff 122
values of constants 121
Black approximation 101, 102
black_scholes function 264
Black‚ÄìScholes equation 11, 37, 55
American options 129, 130
binomial 131‚Äì133
with Richardson
extrapolation 133‚Äì135
continuous dividends 72‚Äì74
derivation of 62‚Äì65
discrete dividends 74, 75
equity quanto options 240‚Äì243
European options 62‚Äì83, 129
multiasset option 65‚Äì67
foreign exchange 229‚Äì232
Greeks 75‚Äì77
historical volatility 78, 79
implied volatility 79‚Äì81
multiasset options 181, 182
see also grid methods;
MacMillan‚ÄìBarone-Adesi‚Äì
Whaley method
Black‚ÄìScholes Ô¨Ånite-difference
approximation 325‚Äì328
general case 325
log transformation 325‚Äì328
nonuniform grid method 148‚Äì155
uniform grid method 138‚Äì142,
160‚Äì162, 325‚Äì328
Boundary values 142, 143
lower asset 142
option maturity 142, 143
upper asset 142
Box‚ÄìMuller transformation 42‚Äì45, 52
Brownian bridge 19‚Äì21
alternative derivation 329‚Äì332
down and out call options 91‚Äì95
relation to Ornstein‚ÄìUhlenbeck
bridge 30, 31
Brownian model of asset price
movements 9, 10
Brownian motion 5‚Äì9, 86
asset price movements 9, 10
drift
changing see Girsanov‚Äôs theorem
constant 8
zero 8
geometric 10, 12, 181
Ito‚Äôs quotient rule 17, 18
multiasset geometric 13‚Äì15
one source of randomness 16, 18
proofs 333‚Äì340
properties of 6‚Äì9
scaled 22
time-transformed 21‚Äì24
Brown, Robert 5, 7
bs_opt function 82
bs_opt_barrier_downout_call
function 88
C
C# code 245, 246
C# portfolio pricing 245‚Äì288
equity deal classes 267‚Äì280
equity barrier option 275‚Äì280
generic equity basket option
270‚Äì275
single equity options 267
two-equity option 267‚Äì269
foreign exchange deal classes
280‚Äì288
FX barrier option 284‚Äì288
FX forward 280, 281
single FX option 281‚Äì284
market data Ô¨Åle 246
portfolio conÔ¨Åguration Ô¨Åle 246
portfolio deÔ¨Ånition Ô¨Åle 246
broad-investments 250‚Äì254
EQ-investments 249, 250,
253, 254
portfolio driver Ô¨Åle 249

Index
363
portfolio valuer application
248, 249
PricingUtils and Analytics_MathLib
262‚Äì266
storing/retrieving market data
254‚Äì262
CurrencyTable 255‚Äì259
EquityTable and
CorrelationTable 259‚Äì262
Call options
American 99‚Äì102
Black approximation 101, 102
with cash dividends 97‚Äì102
critical asset values 107‚Äì109
MacMillan‚ÄìBarone-Adesi‚Äì
Whaley method 105, 106,
112‚Äì114
pricing errors 135
Roll‚ÄìGeske‚ÄìWhaley
approximation 97‚Äì101
double knockout 166‚Äì171
down and in 85
down and out 85‚Äì88, 168
analytic pricing 86‚Äì88
Brownian bridge 91‚Äì95
Monte Carlo pricing 91‚Äì95
nonuniform grid method
153, 154
European 60, 61, 64, 65, 69, 73, 74,
76, 77, 79, 80, 82
multiasset
four assets 208
three assets 201, 204, 205
two assets 197, 198
up and in 85
up and out 85, 88‚Äì91
analytic pricing 88‚Äì91
vanilla
American 97‚Äì111
European 59, 69, 83, 84
Caplet, quanto 223‚Äì225
Central limit theorem 303, 304
Cholesky decomposition 48,
50, 52
Closed form solutions 181
Conditional mean 310, 311
Constant drift 8
Continuous dividends 61, 62, 72‚Äì74
Continuous hazard rate 233
Continuously compounded spot
rate 209
Control variate technique 129, 130
Correlated variates 47‚Äì58
correlation and covariance 46, 47
lognormal distribution 56‚Äì58
normal distribution 51‚Äì55
repairing correlation and covariance
matrices 48‚Äì51
Correlation 47
Correlation matrix 13, 47
optimally repaired 49‚Äì51
repair of 48‚Äì51
CorrelationTable 259‚Äì262
Coupon payment 211
early 217
Ô¨Çoating leg 212
late 217, 218
on time 215, 216
Covariance 307‚Äì309
estimation of 47
four variables 308
normal distribution 310, 311
n variables 308, 309
three variables 307, 308
two variables 307
unconditional 23, 24
Covariance matrix 182, 309
repair of 48‚Äì51
Covered interest arbitrage 228, 229
Cox‚ÄìRubinstein‚ÄìRoss binomial
model 188
Crank‚ÄìNicolson method 141,
159, 162, 163
Credit default swap 235, 236
Credit derivatives 232‚Äì237
credit default swap 235, 236
defaultable bond 235
hazard rate 232, 233
continuous 233

364
Index
estimation from market
observables 234, 235
total return swap 236, 237
Credit risk 2
Critical asset values, numerical
solution 107‚Äì111
CRR lattice 113
Cumulative normal distribution
function 322, 323
CurrencyTable 255‚Äì259
Current value 59
D
Defaultable bond 235
Delta 75, 119, 169
computation of 125
vanilla European options 291, 292
Depth Ô¨Årst procedure 177
Differential swaplet see
quanto, swaplet
Diff swaplet see quanto, swaplet
Discrete dividends 60, 61, 74, 75
Dividends
continuous 61, 62, 72‚Äì74
discrete 60, 61
Double knockout call option
166‚Äì171
Greeks 169
Down and in call options 85
Down and out call options 85‚Äì88,
168
analytic pricing 86‚Äì88
Brownian bridge 91‚Äì95
derivation of 295‚Äì298
Monte Carlo pricing 91‚Äì95
nonuniform grid method 153, 154
DownOutEquityOption-Deal 279
Drunkard‚Äôs walk see Brownian motion
E
Early coupon payment 217
Early exercise 147‚Äì150
Eigen decomposition 48
Equity barrier option 275‚Äì280
Equity deal classes 267‚Äì280
equity barrier option 275‚Äì280
generic equity basket option
270‚Äì275
single equity options 267
two-equity option 267‚Äì269
Equity derivatives 237‚Äì243
quantos 240‚Äì243
equity quanto forward 242, 243
quanto adjustment factor 241,
242
total return swap 237‚Äì240
equity leg 237, 238
equity swap 239, 240
Ô¨Çoating leg 238
payer equity 238, 239
EquityOptionDeal 265‚Äì267
Equity quanto forward 242, 243
EquityTable 259‚Äì262
European options 59‚Äì95
barrier options 85‚Äì95
down and out call options 86‚Äì88
Monte Carlo pricing of down and
out options 91‚Äì95
up and out call options 88‚Äì91
call options 60, 61, 64, 65, 69, 73,
74, 76, 77, 79, 80, 82
double knockout 166, 167, 169‚Äì
171
down and in 85
down and out 85‚Äì88, 155,
156, 168
two assets 197, 198
foreign exchange 229‚Äì232
implied volatility 79‚Äì81
martingale measure 59, 60
multiasset
four assets 207, 208
three assets 201, 204, 205
two assets 190‚Äì194
put call parity 60‚Äì62
continuous dividends 61, 62
discrete dividends 60, 61
put options 59
four assets 208
three assets 202, 204, 205

Index
365
two assets 197, 198
vanilla 59, 62‚Äì83, 85
Black‚ÄìScholes equation 62‚Äì65
call options 59‚Äì85
Greeks for 289‚Äì294
put options 59
volatility
historical 78, 79
implied 79‚Äì81
Exotic options 83, 97, 118, 129, 147,
168, 183
Explicit method 141
F
Faure sequence 41
Feynman‚ÄìKac formula 64, 341, 342
Filtration 6
Financial derivatives 1‚Äì3
Finite-difference approximation
see Black‚ÄìScholes Ô¨Ånite-difference
approximation
Floorlet, quanto 226
Foreign exchange call 231, 232
Foreign exchange deal classes
280‚Äì288
FX barrier option 284‚Äì288
FX forward 280, 281
single FX option 281‚Äì284
Foreign exchange derivatives 228‚Äì232
covered interest arbitrage 228, 229
European option 229‚Äì232
FX forward 229
Foreign exchange forward 1, 229
Foreign exchange option 2, 3
Forward rate agreement 210
Four asset options 205‚Äì208
FourEquityOptionDeal 273
Fubini‚Äôs theorem 26, 31
Fully implicit method 141
FX see foreign exchange
FX forward 229, 280, 281
G
Gamma 75, 119, 169
computation of 125
vanilla European options 290, 291
Gamma function 321, 322
Gaussian distribution see normal
distribution
General error distribution 319, 320
kurtosis 319, 320
shape parameter a 320
value of Œª for variance hi 319
generic equity basket option 270‚Äì275
GenericEquityBasketOptionDeal
270‚Äì275
Geometric Brownian motion 10,
12, 181
Geometric progression 323
Girsanov‚Äôs theorem 12, 13, 68, 72
Going short 63, 66
Greeks 119
binomial lattice 125‚Äì129
Black‚ÄìScholes equation 75‚Äì77
double knockout call option 169
vanilla European options 289‚Äì294
see also individual Greeks
Grid methods 135‚Äì167
double knockout call option
166‚Äì169
log transformation
nonuniform grids 162‚Äì165
uniform grids 156‚Äì163
nonuniform grids 148‚Äì159
down and out call option
153, 154
Ô¨Ånite-difference approximation
149‚Äì155
log transformation 162‚Äì165
uniform grids 136‚Äì150
backwards iteration and early
exercise 147‚Äì150
boundary conditions 142, 143
Ô¨Ånite-difference approximation
138‚Äì142
log transformation 156‚Äì163
option values 143‚Äì147
H
Hazard rate 232, 233

366
Index
continuous 233
estimation from market observables
234, 235
Hazard rate curve 233
Heavy tail distributions 183
Hedge statistics see Greeks
I
ICurve 257‚Äì259
Implicit method 141
implied_volatility function 81
Implied volatility
American options 81
European options 79‚Äì81
Independent variates 41‚Äì46
lognormal distribution 45, 46
normal distribution 42‚Äì44
Student‚Äôs t-distribution 46
Integrals
barrier option 295‚Äì302
down and out call 295‚Äì298
up and out call 298‚Äì302
standard 321
stochastic 33
Interest rate derivatives 209‚Äì227
continuously compounded spot rate
209, 210
forward rate agreement 210
quantos 223‚Äì227
caplet 223‚Äì225
Ô¨Çoorlet 226
swaplet 227
simply compounded spot rate 210
timing adjustment 218‚Äì223
Interest rate swap 211‚Äì218
amortization 212
basis swap 212‚Äì214
coupon payment 215‚Äì218
Ô¨Çoating leg 212
general payment timing 216, 217
swap rate 212
vanilla 211
Ito‚Äôs formula 10‚Äì12
multiasset geometric Brownian
motion 13‚Äì15
two-dimensional 67
Ito‚Äôs isometry 26, 32
Ito‚Äôs product rule 15, 16
n dimensions 18, 19
Ito‚Äôs quotient rule 16‚Äì18, 241
K
Knockin options 83
Knockout options 83, 92
L
Late coupon payment 217, 218
Lattice methods
binomial lattice 81, 114‚Äì122
backwards iteration 123‚Äì125
with BBS and BBSR 131‚Äì135
computation of Greeks 125‚Äì129
construction and use 120‚Äì128
with control variate 129, 130
node asset values 121, 122
terminal node option payoff 122
values of constants 121
multiasset options 185‚Äì189
stochastic lattice 172‚Äì180
asset prices 173, 174
Monte Carlo estimate 177‚Äì180
option prices 174‚Äì176
simulation parameters 173
Law of large numbers 303
Lockout periods 118
Lognormal distribution 45, 46, 55‚Äì58,
114, 315, 316
Lognormal mean 114
Lognormal variance 115
log transformation
nonuniform grids 162‚Äì165
uniform grids 160‚Äì163
London Inter Bank Offer Rate
(LIBOR) 213
Low discrepancy sequences 38
M
MacMillan‚ÄìBarone-Adesi‚ÄìWhaley
method 102‚Äì107, 112‚Äì114
see also Black‚ÄìScholes equation

Index
367
Main currency 214
MarketDataDictionaries 254, 255,
259‚Äì262
Market data Ô¨Åle 246
Market data, storing/retrieving
254‚Äì262
CurrencyTable 255‚Äì259
EquityTable and CorrelationTable
259‚Äì262
Market observables 233‚Äì235
Market rate dictionaries 250
Markov process 6
Martingale measure 6, 59, 60
Maturation 59
Mean 25
Ornstein‚ÄìUhlenbeck process 25
unconditional 23
Microsoft Excel
CALCULATE OPTIONS 83
NORMDIST 83
pricing options 82, 83
Moment generating functions 311,
312
Monte Carlo simulation 37, 172
American option 177‚Äì180
down and out options 91‚Äì95
multiasset options 183‚Äì185
with random numbers 40, 41
Multiasset geometric Brownian
motion 13‚Äì15
Multiasset options 181‚Äì208
Black‚ÄìScholes equation 65‚Äì67,
181, 182
four assets 205‚Äì208
lattices 185‚Äì189
Monte Carlo methods 183‚Äì185
three assets 201‚Äì205
two assets 190‚Äì201
American options 194‚Äì200
European exchange options
190‚Äì192
European options on maximum
or minimum 192‚Äì196
Multivariate distributions 41‚Äì46
generation of 47‚Äì58
lognormal distribution 45, 46
55‚Äì58, 114, 315‚Äì316
normal distribution see normal
distribution
Student‚Äôs t distribution 46, 317‚Äì318
N
Neiderreiter sequence 39, 40
Newton‚Äôs method 79, 80, 81, 98
Nonuniform grids 150‚Äì159
down and out call option 153, 154
Ô¨Ånite-difference approximation
149‚Äì155
log transformation 162‚Äì165
Normal distribution 11, 21, 42‚Äì44,
51‚Äì55, 313‚Äì315
conditional mean 310, 311
covariance 310, 311
cumulative function 322, 323
mean 314
variance 314, 315
Numeraire 60, 218‚Äì222
O
Obligation 1
Option payoff 122
Option prices 174‚Äì176
Option values 143‚Äì147
Ornstein‚ÄìUhlenbeck bridge 27‚Äì31
relation to Brownian bridge 30, 31
Ornstein‚ÄìUhlenbeck process 22‚Äì27
mean 25
unconditional mean 23, 25
unconditional variance/covariance
23, 24
variance 25, 26
P
Payer equity total return swap 238,
239
Payer interest rate swap 211
Payment timing 216, 217
Payoff 59
Portfolio conÔ¨Åguration Ô¨Åle 246
Portfolio deÔ¨Ånition Ô¨Åle 246

368
Index
broad-investments 250‚Äì253, 254
EQ-investments 249, 250, 253, 254
Portfolio driver Ô¨Åle 249
Present value 60
Pricing errors 135, 136
Pricing options, Microsoft Excel 82,
83
PricingUtils 262‚Äì266
Principal exchange 214
Pseudo-random sequences 38‚Äì41
Put call parity 77
continuous dividends 61, 62
discrete dividends 60, 61
Put options
American 179
critical asset values 109‚Äì111
MacMillan‚ÄìBarone-Adesi‚Äì
Whaley method 106, 107,
112‚Äì114
pricing errors 136
European 59
four assets 208
three assets 202, 204, 205
two assets 197, 198
multiasset
four assets 208
three assets 201, 204
two assets 194, 197, 198
Q
Quantos
equity 240‚Äì243
equity quanto forward 242, 243
quanto adjustment factor 241,
242
interest rate 223‚Äì227
caplet 223‚Äì225
Ô¨Çoorlet 226
swaplet 227
Quasirandom_Normal_LogNormal_
Correlated function 53‚Äì55
Quasi-random sequences 38‚Äì41
R
Radon‚ÄìNikodym derivative 12
Random variates 37‚Äì58
correlated variates 47‚Äì58
independent 41‚Äì46
lognormal distribution 45, 46
normal distribution 42‚Äì44
Student‚Äôs t-distribution 46
pseudo-random/quasi-random
sequences 38‚Äì41
Random walk see Brownian motion
Rate swap 211‚Äì218
amortization 212
basis swap 212‚Äì214
coupon payment
early 217
late 217, 218
on time 215, 216
Ô¨Çoating leg 212
general payment timing 216, 217
payer 211
receiver 211
swap rate 212
vanilla 211
Receiver interest rate swap 211
Return 9
Rho 75
vanilla European options 293
RiskFreeRate 257
Roll‚ÄìGeske‚ÄìWhaley approximation
97‚Äì101
S
Scaled Brownian motion 22
Siedentopf, Henry 5
Simply compounded spot rate 210
Single equity options 267
Single FX option 281‚Äì284
Sobol sequences 39, 41, 184, 185
Spot rate
continuously compounded 209
simply compounded 210
Standard deviation, annualized 78
Standard integrals 321
Stochastic integral, expectation of 33
Stochastic lattice 172‚Äì180
asset prices 173‚Äì174

Index
369
Monte Carlo estimate 177‚Äì180
option prices 174‚Äì176
simulation parameters 173
Stochastic processes 5‚Äì35
Brownian bridge 19‚Äì21
Brownian model of asset price
movements 9, 10
Brownian motion 5‚Äì9
time-transformed 21‚Äì24
Girsanov‚Äôs theorem 12, 13
Ito‚Äôs product
in n dimensions 18, 19
and quotient rules 15‚Äì18
Ito‚Äôs formula 10‚Äì12
multiasset geometric Brownian
motion 13‚Äì15
Ornstein‚ÄìUhlenbeck bridge 27‚Äì31
Ornstein‚ÄìUhlenbeck process 22‚Äì27
Strike price 59
Structured deal 239
Student‚Äôs t-distribution 46, 317, 318
Swaplets 211
quanto 227
Swap rate 212
T
Taylor expansion 10, 14, 151
Theta 75, 119, 169
computation of 125, 126
vanilla European options 292, 293
Three asset options 201‚Äì205
Time-transformed Brownian motion
21‚Äì24
Timing adjustment 218‚Äì223
Total return swap
credit 236, 237
equity 237‚Äì240
equity leg 237, 238
equity swap 239, 240
Ô¨Çoating leg 238
payer equity 238, 239
Trading days 78
Two asset options 190‚Äì201
American 197‚Äì200
European 190‚Äì192
maximum or minimum 192‚Äì194
Two-equity option 267‚Äì269
U
Unconditional mean 23
Unconditional variance 23, 24
Uniform grids 136‚Äì150
backwards iteration and early
exercise 147‚Äì150
boundary conditions 142, 143
Ô¨Ånite-difference approximation
138‚Äì142
log transformation 156‚Äì163
option values 143‚Äì147
Up and in call options 86
Up and out call options 83, 88‚Äì91
analytic pricing 88‚Äì91
derivation of 298‚Äì302
V
Vanilla options
American 97‚Äì111
call with cash dividends 97‚Äì102
grid methods 135‚Äì167
lattice methods 114‚Äì135
MacMillan‚ÄìBarone-Adesi‚Äì
Whaley method 102‚Äì107
numerical solution of critical asset
values 107‚Äì111
binomial lattice 81, 114‚Äì122
with BBS and BBSR 131‚Äì135
construction and use 120‚Äì128
with control variate 129, 130
European 59, 62‚Äì84
call 59, 69, 83, 85
Greeks for 289‚Äì294
put 59
grid methods 135‚Äì167
double knockout call option
166‚Äì169
nonuniform grids 148‚Äì159
uniform grids 136‚Äì150
interest rate swap 211
Variance 25, 26, 305‚Äì307
n variables 306, 307

370
Index
one variable 305
Ornstein‚ÄìUhlenbeck process 25, 26
three variables 306
two variables 305
unconditional 23, 24
Vega 76
computation of 126
vanilla European options 294
Visual Basic 82‚Äì84
bs_opt 84
bs_opt_barrier_downout_call 88
Volatility 7
historical 78, 79
implied 79‚Äì81
volatility smile 79
W
Wiener, Norbert 5
Wiener process see Brownian motion
Y
YieldCurve 257
Z
Zero coupon rate 257
Zero drift 8
Zsigmondy, Richard 5

Glossary
The notation used is as follows:
GBM Geometric Brownian motion
BM Brownian motion
Wt Brownian motion at time t
œÅ the correlation coefÔ¨Åcient
E[x] the expectation value of X
Var[X] the variance of X
Cov[X, Y] the covariance between X and Y
Cov[X] the covariance between the variates contained in the vector X
œÉ the volatility. Since assets are assumed to follow GBM it is com-
puted as the annualized standard deviation of the n continuously
compounded returns
N1(a) the univariate cumulative normal distribution function. It gives the
cumulative probability, in a standardized univariate normal distrib-
ution, that the variable x1 satisÔ¨Åed x1 ‚©Ωa
N2(a, b, œÅ) the bivariate cumulative normal distribution. It gives the cumulative
probability, in a standardized bivariate normal distribution, that the
variables x1 and x2 satisfy x1 ‚©Ωa and x2 ‚©Ωb when with correlation
coefÔ¨Åcient between x1 and x2 is œÅ
r the risk free interest rate
q the continously compounded dividend yield
Sit the ith asset price at time t
Inn the n by n unit matrix
(Œº, œÉ 2) a lognormal distribution with parameters Œº and œÉ 2. If y = log(x)
and y ‚àºN(Œº, œÉ 2) then the distribution for x = ey is x ‚àº(Œº, œÉ 2).
We have E[x] = exp(Œº+ œÉ 2
2 ) and Var[x] = exp(2Œº+œÉ 2)(exp(œÉ 2)‚àí1)
Continued on back cover

Glossary (Continued)
DF(t, T ) the discount factor between times t and T , where T ‚©æt. The price
of a nondefaultable zero coupon bond which matures at time T
is the expected value of DF(t, T ). In this book we assume that in-
terest rates are deterministic and thus DF(t, T ) is the value of a
nondefaultable zero coupon bond maturing at T
DF(t, T ) the discount factor (including the possibility of default) between
times t and T , where T ‚©æt: DF(t, T ) = S(t, T )DF(t, T ). The price
of a defaultable zero coupon bond which matures at time T is the
expected value of DF(t, T ). In this book we assume that interest
rates are deterministic and thus DF(t, T ) is the value of a default-
able zero coupon bond maturing at T
F(t, T1, T2) the forward rate at time t between times T1 and T2 where T2 ‚©æT1
and T1 ‚©æt
L(T1, T2) the simply compounded spot rate between times T1 and T2, where
T2 ‚©æT1
log(x) the natural logarithm of x
N(a, b) normal distribution, with mean a and variance b
dWt a normal variate (sampled at time t) from the distribution N(0, dt),
where dt a speciÔ¨Åed time interval e.g. dx = Œº dt + dWt
dZt a normal variate (sampled at time t) from the distribution N(0, 1).
Note: The variate dœà =
‚àö
dt dZt has the same distribution as dWt
IID independently and identically distributed
U(a, b) the uniform distribution, with lower limit a and upper limit b
|x| the absolute value of the variable x
PDF the probability density function of a given distribution
x ‚àßy the minimum of x and y, that is min(x, y)
S(t, T ) the survival probability between time t and T , T > t
‚à•A ‚àíB‚à•the distance between two matrices with the same dimensions. If A
and B both have n rows and m columns then this distance is:




n

i=1
m

j=1
{Ai,j ‚àíBi,j}2
where Ai,j and Bi,j refer to the element in the ith row and jth
column

