SAS
® 9.4
Graph Template Language
User’s Guide
SAS® Documentation

The correct bibliographic citation for this manual is as follows: SAS Institute Inc. 2013. SAS® 9.4: Graph Template Language: User's Guide . Cary,
NC: SAS Institute Inc.
SAS® 9.4:Graph Template Language: User's Guide
Copyright © 2013, SAS Institute Inc., Cary, NC, USA
ISBN 978-1-61290-652-2 (electronic book)
ISBN 978-1-61290-562-4
All rights reserved. Produced in the United States of America.
For a hard-copy book: No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by any means,
electronic, mechanical, photocopying, or otherwise, without the prior written permission of the publisher, SAS Institute Inc.
For a web download or e-book: Your use of this publication shall be governed by the terms established by the vendor at the time you acquire this
publication.
The scanning, uploading, and distribution of this book via the Internet or any other means without the permission of the publisher is illegal and
punishable by law. Please purchase only authorized electronic editions and do not participate in or encourage electronic piracy of copyrighted
materials. Your support of others' rights is appreciated.
U.S. Government Restricted Rights Notice: Use, duplication, or disclosure of this software and related documentation by the U.S. government is
subject to the Agreement with SAS Institute and the restrictions set forth in FAR 52.227–19, Commercial Computer Software-Restricted Rights
(June 1987).
SAS Institute Inc., SAS Campus Drive, Cary, North Carolina 27513.
ISBN 978-1-61290-652-2
Electronic book 1, July 2013
ISBN 978-1-61290-562-4
Printing 1, July 2013
SAS provides a complete selection of books and electronic products to help customers use SAS® software to its fullest potential. For more
information about our e-books, e-learning products, CDs, and hard-copy books, visit support.sas.com/bookstore or call 1-800-727-3228.
SAS® and all other SAS Institute Inc. product or service names are registered trademarks or trademarks of SAS Institute Inc. in the USA and other
countries. ® indicates USA registration.
Other brand and product names are registered trademarks or trademarks of their respective companies.

Contents
Recommended Reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . vii
Chapter 1 • ODS Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Overview of ODS Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Automatic Graphics from SAS Analytical Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . 2
Modifying Templates for Automatic Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
Editing Graphs Using the ODS Graphics Editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
Creating Graphs Using the SAS Statistical Graphics Procedures . . . . . . . . . . . . . . . . . . 4
Creating Graphs Using the SAS ODS Graphics Designer . . . . . . . . . . . . . . . . . . . . . . . . 4
The Graph Template Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
Sample of ODS Graphics Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
Chapter 2 • Quick Start . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
Steps for Creating a Graph Using GTL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
About the Examples in This Documentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
Creating a Graph Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
Executing the Template to Produce the Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
Managing the Graphical Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
Chapter 3 • Overview of Basic Statements and Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Introduction to GTL Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Categories of Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Features Supported by Layout, Legend, and Text Statements . . . . . . . . . . . . . . . . . . . . 34
Features Supported by Many Plot Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
Chapter 4 • Using a Simple Single-cell Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
About the Single-Cell Layouts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
The LAYOUT OVERLAY Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
Common Overlay Combinations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
How Plots Are Overlaid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
The LAYOUT REGION Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
Chapter 5 • Managing Axes in an OVERLAY Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
Introduction to Axis Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
Axis Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
How Plot Statements Affect Axis Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
Specifying Axis Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
Default Axis Construction and Related Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
LINEAR Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
DISCRETE Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
TIME Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
LOG Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
Axis Line versus Wall Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
Axis Appearance Features Controlled by the Current Style . . . . . . . . . . . . . . . . . . . . . 109
Chapter 6 • Managing Graph Appearance: General Principles . . . . . . . . . . . . . . . . . . . . . . . . 111
Default Appearance Features in Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
Evaluating Supplied Styles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Methods for Changing the Appearance of Your Plots . . . . . . . . . . . . . . . . . . . . . . . . . 116

Options That Override Attributes for Individual Plots . . . . . . . . . . . . . . . . . . . . . . . . . 117
Appearance of Non-grouped Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
Appearance of Grouped Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
Attribute Rotation Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
Data Skins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
Subpixel Rendering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
Recommendations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
Chapter 7 • Adding and Changing Text in a Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
Text Strings in Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
Text Properties and Syntax Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
Text Statement Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
Managing the String on Text Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
Using Options on Text Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
ENTRY Statements: Additional Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
Chapter 8 • Adding Legends to a Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
Introduction to Legend Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
General Legend Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
Features of Discrete Legends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
Features of Continuous Legends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
Chapter 9 • Using a Simple Multi-cell Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
The LAYOUT GRIDDED Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
Defining a Basic Grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
Building a Table of Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
Sizing Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
Chapter 10 • Using an Advanced Multi-cell Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
The LAYOUT LATTICE Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
Defining a Basic Lattice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
Creating Uniform Axes across Rows or Columns . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
Defining a Lattice with Additional Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
Adjusting the Graph Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
Chapter 11 • Using Classification Panels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
Introduction to Classification Panels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
Organizing Panel Contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
Setting Panel Axis Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
Controlling the Classification Headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
Using Sidebars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
Controlling the Interactions of Classifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
Using Non-computed Plots in Classification Panels . . . . . . . . . . . . . . . . . . . . . . . . . . 291
Adding an Inset to Each Cell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
Using PROC SGPANEL to Create Classification Panels . . . . . . . . . . . . . . . . . . . . . . 295
Chapter 12 • Using an Equated Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
The LAYOUT OVERLAYEQUATED Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
Basic Display Features of Equated Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Chapter 13 • Using 3-D Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
The LAYOUT OVERLAY3D Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
Basic Display Features of 3-D Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
Data Requirements for 3-D Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
Chapter 14 • Using Dynamics and Macro Variables to Make Flexible Templates . . . . . . . . . 327
iv
Contents

Introduction to Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Declaring Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Referencing Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328
Initializing Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
Special Dynamic Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
Chapter 15 • Using Conditional Logic and Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
Constructs Available for Run-time Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
Conditional Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
Chapter 16 • Using Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
SAS Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
Functions Defined Only in GTL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
GTL Summary Statistic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Chapter 17 • Adding Insets to a Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
Uses for Insets in a Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
Creating a Simple Inset with an ENTRY Statement . . . . . . . . . . . . . . . . . . . . . . . . . . 356
Creating an Inset as a Table of Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
Positioning an Inset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360
Creating an Inset with Values That Are Computed in the Template . . . . . . . . . . . . . . 363
Creating an Inset from Values That Are Passed to the Template . . . . . . . . . . . . . . . . . 364
Adding Insets to a SCATTERPLOTMATRIX Graph . . . . . . . . . . . . . . . . . . . . . . . . . 369
Adding Insets to Classification Panels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372
Creating Axis-Aligned Insets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380
Chapter 18 • Managing the Graph Appearance with Styles . . . . . . . . . . . . . . . . . . . . . . . . . . . 391
ODS Style Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391
Changing Fonts in a Style Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
Controlling ODS Search Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
Changing Box Plot Display . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
Chapter 19 • Adding Non-Data-Driven Graphics Elements to a Graph . . . . . . . . . . . . . . . . . . 405
Overview: Adding Non-Data-Driven Graphics Elements to a Graph . . . . . . . . . . . . . 405
Selecting the Drawing Space and Units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
How the Graphics Elements Are Anchored . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
Adding Graphics Elements to Your Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
Chapter 20 • Adding Data-Driven Annotations to a Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
Overview: Adding Data-Driven Annotations to a Graph . . . . . . . . . . . . . . . . . . . . . . . 417
Creating an Annotation Data Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
Rendering a Graph with Annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426
Subsetting Annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
Chapter 21 • Executing Graph Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Techniques for Executing Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Minimal Required Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
Managing the Input Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439
Initializing Template Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . 440
Managing the Output Data Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442
Chapter 22 • Managing Graphical Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
Introduction to ODS Graphics Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
Contents
v

SAS Registry Settings for ODS Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446
ODS Destination Statement Options Affecting ODS Graphics . . . . . . . . . . . . . . . . . . 447
ODS GRAPHICS Statement Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 449
Common Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
Creating Shared Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 473
Appendix 1 • Reserved Keywords and Unicode Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 475
Appendix 2 • Graph Style Elements Used by ODS Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . 479
About the Graphical Style Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
General Graph Appearance Style Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
Graphical Data Representation Style Elements (Non-Grouped Data) . . . . . . . . . . . . . 482
Graphical Data Representation Style Elements (Grouped Data) . . . . . . . . . . . . . . . . . 486
Display Style Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
Appendix 3 • Display Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
General Syntax for Attribute Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Attributes Available for the Attribute Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 494
Available Line Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 497
Appendix 4 • Tick Value Fit Policy Applicability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499
Appendix 5 • SAS Formats Not Supported . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
Using SAS Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
Unsupported Numeric Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
Unsupported Date and Time Formats Related to ISO 8601 . . . . . . . . . . . . . . . . . . . . . 504
Other Unsupported Date and Time Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504
Unsupported Currency Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
Appendix 6 • Memory Management for ODS Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507
SAS Options Affecting Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507
Managing a Java Out of Memory Error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507
Appendix 7 • ODS Graphics and SAS/GRAPH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523
vi
Contents

Recommended Reading
Here is the recommended reading list for this title:
•
SAS Graph Template Language: Reference
The recommended reading list from SAS Press includes the following titles:
•
Output Delivery System: The Basics and Beyond
•
Statistical Programming in SAS(R)
•
Survival Analysis Using SAS(R): A Practical Guide, Second Edition
•
Statistical Graphics in SAS(R): An Introduction to the Graph Template Language
and the Statistical Graphics Procedures
•
The Little SAS(R) Book: A Primer, Fifth Edition
For a complete list of SAS books, go to support.sas.com/bookstore. If you have
questions about which titles you need, please contact a SAS Book Sales Representative:
SAS Books
SAS Campus Drive
Cary, NC 27513-2414
Phone: 1-800-727-3228
Fax: 1-919-677-8166
E-mail: sasbook@sas.com
Web address: support.sas.com/bookstore
vii

viii
Recommended Reading



Chapter 1
ODS Graphics
Overview of ODS Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Automatic Graphics from SAS Analytical Procedures . . . . . . . . . . . . . . . . . . . . . . . . 2
Modifying Templates for Automatic Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
Editing Graphs Using the ODS Graphics Editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
Creating Graphs Using the SAS Statistical Graphics Procedures . . . . . . . . . . . . . . . 4
Creating Graphs Using the SAS ODS Graphics Designer . . . . . . . . . . . . . . . . . . . . . 4
The Graph Template Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
Overview of the Graph Template Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
Defining the Graph Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
Creating the Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
When GTL Is Needed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
Sample of ODS Graphics Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
Overview of ODS Graphics
ODS Graphics is a system for creating graphics that address the following requirements:
•
the need for a flexible syntax to create complex graphs
•
the need to create high quality graphical output.
Modern analytical graphs are an integral part of an analysis or a study. ODS Graphics
gives SAS analytical procedures the ability to create complex analytical graphs that
deliver the analysis results with clarity and without clutter. By enabling ODS Graphics,
SAS users get the relevant graphs automatically as part of the analysis process. In
addition, they have easy to use tools that can create related graphs for preview of the
data or for creating graphs from the results of multiple analyses.
ODS Graphics are driven by the Graph Template Language (GTL), which provides the
power and flexibility to create many complex graphs. Standard GTL templates are
delivered with SAS that are used to generate graphics output for the SAS analytical
procedures. Users can modify these templates in order to customize the appearance of
the graphics output of these procedures. Users can also create their own templates for
creating custom graphics. Whereas you can use GTL to modify the SAS analytical
procedure graphics output or to create custom graphics, its power and flexibility comes
with some complexity. For that reason, this document discusses the ways in which the
1

SAS System leverages the power of GTL to create graphics using other tools and
systems. You might find that these other tools meet all of your needs.
Automatic Graphics from SAS Analytical
Procedures
The SAS analytical procedures that support ODS Graphics can produce graphs
automatically when ODS Graphics is enabled. (See Table 1.1 on page 2.) When ODS
Graphics is enabled, the graphs defined as part of any procedure's output are written to
the active ODS destinations. You can control the specific graphs that are produced by
using the PLOTS= options on the procedure statement or by using the ODS SELECT
and ODS EXCLUDE statements. When ODS Graphics is disabled, these procedures do
no produce graphs.
In SAS 9.3 and later releases, ODS Graphics is enabled by default. To disable automatic
graphics, use the following statement:
ods graphics off </ options>;
To re-enable automatic graphics, use the following statement:
ods graphics <on> </ options>;
The procedures that support ODS graphics are listed in the following table.
Table 1.1
SAS Analytical Procedures That Support ODS Graphics
Product
Procedure Name
Procedure Description
Base SAS
CORR
FREQ
UNIVARIATE
See Base SAS Procedures
Guide: Statistical
Procedures.
SAS/ETS
ARIMA
SIMILARITY
AUTOREG
SYSLIN
ENTROPY
TIMESERIES
ESM
UCM
EXPAND
VARMAX
MODEL
X12
PANEL
See SAS/ETS User's
Guide.
SAS/HPF
HPF
HPFENGINE
See SAS High-
Performance Forecasting:
User's Guide.
SAS/QC
ANOM
PARETO
CAPABILITY
RELIABILITY
CUSUM
SHEWHART
MACONTROL
See SAS/QC User's
Guide.
2
Chapter 1
•
ODS Graphics

Product
Procedure Name
Procedure Description
SAS Risk
Dimension
RISK
See SAS Risk Dimensions:
Procedures Guide.
SAS/STAT
ANOVA
LIFEREG
PROBIT
BOXPLOT
LIFETEST
QUANTREG
CALIS
LOESS
REG
CLUSTER
LOGISTIC
ROBUSTREG
CORRESP
MCMC
RSREG
FACTOR
MDS
SEQDESIGN
FREQ
MI
SEQTEST
GAM
MIXED
SIM2D
GENMOD
MULTTEST
TCALIS
GLIMMIX
NPAR1WAY
TRANSREG
GLM
PHREG
TTEST
GLMSELECT
PLS
VARIOGRAM
KDE
PRINCOMP
KRIGE2D
PRINQUAL
See the primer and syntax
sections in the discussion
of statistical graphics
using ODS in SAS Graph
Template Language:
Reference.
Modifying Templates for Automatic Graphs
The graphs that are produced by the SAS analytical procedures are created from
compiled STATGRAPH templates that are written in GTL. For each graph that is
created by a procedure, a template has been defined by the procedure writers and
shipped with SAS. These templates can be found in the appropriate subfolder of the
Sashelp.Tmplmst item store (issue the ODSTEMPLATE command to open the
Templates window). Users wanting to make persistent changes to these automatic
graphics can do so by editing and recompiling these definitions of the graphs.
Understanding the structure of these templates requires knowledge of GTL, as described
in this guide. Changes to these templates should follow the guidelines presented in the
discussion on statistical graphics using ODS in the SAS/STAT User's Guide.
Editing Graphs Using the ODS Graphics Editor
After you create an ODS graph, you might want to edit and/or customize the graphical
output for presentation to your audience or for inclusion in other documents. These
changes could be something as simple as editing the graph title, or adding a footnote to
the graph. Although you could edit the associated template using GTL and then
regenerate the graph, you can use the ODS Graphics Editor to make simple, customized
changes to the ODS Graphics output. The ODS Graphics Editor is an interactive, GUI-
based tool that is specifically designed for this purpose. Using this tool, you can
•
edit or add titles and footnotes to the graphs
Editing Graphs Using the ODS Graphics Editor
3

•
change graph styles and visual attributes, such as marker shapes, line patterns,
colors, and so on
•
add free-form text, arrows, lines, and other graph elements to call out various
elements of the results.
Changes made to a graph with the ODS Graphics Editor do not affect the template that
defined the graph. For more information about the ODS Graphics Editor, see the SAS
ODS Graphics Editor: User's Guide
Creating Graphs Using the SAS Statistical
Graphics Procedures
As seen so far, you can obtain analytical graphs automatically from SAS analytical
procedures. Furthermore, you can edit or customize these graphs with the ODS Graphics
Editor, all without any need to learn the GTL syntax. However, frequently you might
need to get a better understanding of the data in a study or survey by creating
preliminary graphical views of the data. Such views might be necessary before a
decision can be made about the detailed analysis process. Also, your task might require
data analysis using multiple procedures and some custom data management. After such
analysis process, the results contained in the output data sets might need to be displayed
as custom graphs.
Many such graphs can be created using the SAS Statistical Graphics (SG) Procedures.
The SG procedures are a set of graphics procedures that leverage the power of GTL
behind the scenes to create commonly used graphs using a simple and concise syntax.
The following SG procedures are available with SAS:
•
The SGPLOT procedure for creating single-cell graphs.
•
The SGPANEL procedure for creating multi-cell classification panels.
•
The SGSCATTER procedure for creating multi-cell comparative scatter plots.
The SG procedures also provide additional data summarization features that are not
provided by GTL. For many users, these procedures are the right set of tools to use for
meeting their needs, without deploying the full power of GTL.
For more information about the SG procedures, see the SAS ODS Graphics: Procedures
Guide
Creating Graphs Using the SAS ODS Graphics
Designer
If you prefer to create custom graphs without having to know the details of GTL, you
can use the ODS Graphics Designer. The SAS ODS Graphics Designer is a graphical
application that enables you to design and create custom graphs interactively using its
point-and-click graphical user interface. The ODS Graphics Designer is based on GTL,
which is used by the SAS analytical procedures and the SAS ODS Graphics procedures.
However, you do not need to know the details of GTL to create graphs using the ODS
Graphics Designer.
Using the ODS Graphics Designer, you can design sophisticated graphs using a wide
array of plot types. You can design multi-cell graphs, classification panels, and scatter
4
Chapter 1
•
ODS Graphics

plot matrices. You can add titles, footnotes, legends, and other graphics elements to your
graphs. You can save your graphs as image files for inclusion in other documents, or as
ODS Graphics Designer (SGD) files that you can edit later using the ODS Graphics
Editor.
For more information about the SAS ODS Graphics Designer, see the SAS ODS
Graphics Designer: User's Guide.
The Graph Template Language
Overview of the Graph Template Language
The Graph Template Language is the heart of ODS Graphics. All of the graphs that are
created by the SAS analytical procedures and by the SAS Statistical Graphics
Procedures are generated using GTL. Users who need to go beyond the graphs created
by these SAS procedures can use GTL directly to design their graphs using the
TEMPLATE and SGRENDER procedures. To successfully create or modify GTL
templates, you need the information in this guide, which helps you understand important
concepts and offers many complete code examples illustrating often used features. You
also need access to the SAS Graph Template Language: Reference, which is the
language dictionary for GTL.
Creating a graph using GTL is a two step process:
1. Define the structure of the graph using the GTL syntax in a STATGRAPH template
that is specified in the TEMPLATE procedure. Compile and save this template.
2. Create the graph by running the SGRENDER procedure to associate the appropriate
data with the template.
Defining the Graph Template
GTL uses a structured "building-block" approach to defining a graph. The syntax
provides a set of layout, plot, and other statements to define the graph. Figure 1.1 on
page 5 shows a graph of car profiles by horsepower and the syntax necessary to
define the graph using GTL.
Figure 1.1
ODS Graph and the Template to Generate It
The template definition consists of the following parts:
The Graph Template Language
5

A. The GTL syntax block from BEGINGRAPH to ENDGRAPH.
B. The title for the graph.
C. The LAYOUT OVERLAY block. The results of the statements in this block are
overlaid in the graph.
D. A histogram of the Horsepower column.
E. A density plot of the Horsepower column.
Running the program in Figure 1.1 on page 5 creates the CARS template and saves it in
an item store.
Creating the Graph
To create the graph in Figure 1.1 on page 5, the SGRENDER procedure is run to
associate the appropriate data set with the compiled template:
proc sgrender data=sashelp.cars template=cars; run;
In the template definition, the Horsepower column is used explicitly for the
HISTOGRAM and DENSITYPLOT statements. The explicit reference in the template to
a column named Horsepower requires that the data set have a numeric column named
Horsepower. Chapter 14, “Using Dynamics and Macro Variables to Make Flexible
Templates,” on page 327 shows you how to make the template more flexible.
The GTL syntax supports a variety of layout, plot, and other statements to create a wide
range of graphs. Details on all these statements and options are covered in this guide and
in the SAS Graph Template Language: Reference.
When GTL Is Needed
•
The graphs that are created by the analytical procedures use predefined GTL
templates. These templates are designed by SAS procedure writers and shipped with
SAS. Every graph created by these procedures has a corresponding template stored
in the Sashelp.Tmplmst item store. To customize these templates, you must develop
a basic understanding of the GTL.
•
Often analysts need graphs of the data before an analysis can be started. Or, the
results of a complex analysis involving multiple procedures or DATA steps need to
be presented as graphs. Although many of these tasks can be accomplished using the
SG Procedures, those procedures do not provide many of the advanced layout
capabilities of GTL. To create such custom graphs, you must develop a basic
understanding of the GTL.
Sample of ODS Graphics Output
The following graphs provide a small sample of the diverse output that you can produce
with ODS Graphics:
6
Chapter 1
•
ODS Graphics

Figure 1.2
PROC LIFETEST (SAS/STAT) with ANALYSIS Style
Sample of ODS Graphics Output
7

Figure 1.3
PROC SGSCATTER (SAS) with LISTING Style
8
Chapter 1
•
ODS Graphics

Figure 1.4
Custom Template Rendered with PROC SGRENDER (SAS) and a Custom Style
Sample of ODS Graphics Output
9

10
Chapter 1
•
ODS Graphics

Chapter 2
Quick Start
Steps for Creating a Graph Using GTL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
About the Examples in This Documentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
Creating a Graph Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
Quick Look at a GTL Graph Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
More Detailed Look at a GTL Graph Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Compiling the Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
Executing the Template to Produce the Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
Managing the Graphical Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
Directing Output to ODS Destinations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
Modifying Graph Appearance with Styles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
Controlling Physical Aspects of the Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
Steps for Creating a Graph Using GTL
This chapter provides an overview of how graphs are created with the GTL and a brief
discussion of what is going on behind the scenes. All the examples are completely
coded. You can copy and paste these programs into an editor of a SAS Session
(beginning in SAS 9.2) and follow the steps as they are described.
As you learned in “Defining the Graph Template” on page 5, creating a graph using
GTL is a two-step process:
1. Use PROC TEMPLATE to define a STATGRAPH template with GTL syntax.
Compile and save this template.
2. Create the graph by running the SGRENDER procedure to associate the appropriate
data with the template.
About the Examples in This Documentation
The example programs that are shown in this document often provide all of the code that
you need to generate the graphs that are shown in the figures. We encourage you to copy
and paste the example code into your SAS session and generate the graphs for yourself.
We used the default HTMLBlue style for most of the graphs in this document. If you
11

generate the example graphs in the default HTML destination, they are typically be
rendered in 640 pixel by 480 pixel size using the HTMLBlue style. Some of the
examples show you how to change the graph size and style. The graphs shown for those
examples will be rendered in the specified size and style.
Because of size limitations, the graphs in this document are not shown in their default
size of 640 pixels by 480 pixels. They are scaled down to meet the size requirements of
our documentation production system. When graphs that are produced with ODS
graphics are reduced in size, several automatic processes take place to optimize the
appearance of the output. Among the differences between default size graphs and
smaller graphs are that the smaller graphs have scaled down font sizes. Also, their
numeric axes might display a reduced number of ticks and tick values. Thus, the graphs
that you generate from the example programs will not always look identical to the
graphs that are shown in the figures. However, both graphs will accurately represent the
data.
When you produce your own graphical output, you can change the graph size and
attributes, if needed. The “Managing Your Graphics” and " Controlling Graph
Appearance with Modified Styles" chapters explain how to set fonts, DPI, anti-aliasing,
and other features that contribute to producing professional-looking graphics of any size
in any output format.
Creating a Graph Template
Quick Look at a GTL Graph Definition
To illustrate the steps needed to create a graph, assume that we want to produce a graph
showing a linear regression fit for a set of data where Height is an independent variable
and Weight is a dependent variable.
proc template;
 define statgraph modelfit;
  begingraph;
   entrytitle "Regression Fit Plot";
   layout overlay;
     scatterplot x=height y=weight;
     regressionplot x=height y=weight;
   endlayout;
  endgraph;
12
Chapter 2
•
Quick Start

 end;
run;
proc sgrender data=sashelp.class 
              template=modelfit;
run;
You can submit this program to produce the graph. Let us now look in more detail into
what this program does.
More Detailed Look at a GTL Graph Definition
The TEMPLATE procedure can produce different types of templates, like STYLE,
TABLE, COLUMN, and STATGRAPH. The type of template to be created is specified
with a DEFINE statement.
The DEFINE STATGRAPH statement and its matching END statement indicate that a
graphics template named MODELFIT is to be created. The template name can be a
simple one-level name or a multi-level name such as GRAPHS.MODELFIT or
PROJECT.STUDY3.MODELFIT indicating the folder in which the MODELFIT
template is to be stored.
The BEGINGRAPH statement and its matching ENDGRAPH statement define the
outermost container for the graph. It supports options for sizing the graph. Within this
block, you can use various statements that define the content of the graph.
ENTRYTITLE and ENTRYFOOTNOTE statements can be used to specify graph title
lines and graph footnote lines, if needed.
Creating a Graph Template
13

The LAYOUT OVERLAY statement and its matching ENDLAYOUT statement define
the type of graphical layout to be used. The OVERLAY layout allows the contained
plots to be overlaid. It manages the plot layers and queries all contained plots to decide
the axis types, axis labels, and axis ranges.
Both the SCATTERPLOT and REGRESSIONPLOT statements specify Height for the X
variable and Weight for the Y variable. For the regression, X is always used for the
independent variable and Y for the dependent variable. By default, a linear regression is
used.
For more information about the types of layouts and plots in GTL, see Chapter 3,
“Overview of Basic Statements and Options,” on page 21.
Compiling the Template
When you submit your PROC TEMPLATE statements, the template syntax is checked.
If no syntax error is detected, a compiled template named MODELFIT is created and
stored physically in the Sasuser.Templat item store by default. This item store is chosen
by default because it is the first item store that can be updated in the current ODS path.
14
Chapter 2
•
Quick Start

It should be noted that STATGRAPH template syntax requires that any necessary
arguments be specified (X= and Y= arguments are required for both the
SCATTERPLOT and REGRESSIONPLOT statements), but no checking for the
existence of the assigned variables is performed at compile time. Also note that no
reference to an input data set appears in the template.
Compiling the template does not produce a graph—it only creates a compiled template
that can be executed to produce a graph.
To verify that the template was created, you can issue the ODSTEMPLATE command
(ODST, for short). This opens the Templates window where you view all item stores and
their contents. All STATGRAPH templates can be identified by the common icon shown
above.
You can also browse the source for any compiled template by double-clicking on its
name.
For more information about item stores and PROC TEMPLATE in general, see SAS
Output Delivery System: User's Guide.
Executing the Template to Produce the Graph
To produce a graph, use the SGRENDER procedure:
proc sgrender data=sashelp.class template=modelfit; run;
The SGRENDER procedure takes two required arguments: DATA= for the input data
set and TEMPLATE= for the STATGRAPH template to be used.
Executing the Template to Produce the Graph
15

SGRENDER produces the graph by
•
building a data object for the template. This data object contains only the requested
variables (Height and Weight) for the scatter points along with any other internally
computed values, such as the points on the regression line.
•
obtaining default color, line, marker, and font properties from the currently active
style.
This information, along with the GTL definition of the graph, is then passed to a
rendering module that assembles everything and produces an image, which is integrated
into the active ODS destination(s).
Minimally, one ODS destination must be open. By default, that destination is HTML.
For this destination, the default is to create a file that contains a PNG image and an
HTML file that displays the image in a browser window.
Graph output to the HTML destination is displayed automatically when you execute the
template.. To view the output at any time afterward, you can open the Results window
(choose View ð Results from the menu) and select it.
Display 2.1
Graph That Has Been Opened from the Results Window in MS Windows
16
Chapter 2
•
Quick Start

For more information about other features of SGRENDER, see Chapter 21, “Executing
Graph Templates,” on page 437.
Managing the Graphical Output
Directing Output to ODS Destinations
All ODS graphics are generated in industry standard formats (PNG, PDF, and so on),
depending on the settings for the active ODS destinations. The ODS HTML destination
is on by default, and the default image format for the HTML destination is PNG.
All ODS destinations such as HTML, PDF, RTF, LATEX, and PRINTER are fully
supported. The ODS destinations enable you to
•
manage the graphs that are generated by ODS Graphics
•
display the output in a variety of forms (HTML, PDF, RTF, ...)
•
control the location of stored output files and other features that are relevant for the
active destinations.
As discussed in “Compiling the Template” on page 14, a compiled template is stored in
an item store. Thus, without rewriting or resubmitting the template code, we can render
the graph as often as needed during the current SAS session or a future SAS session.
To generate ODS Graphics output for use on the web, we can direct the output to the
HTML destination, which generates an image file for the graph, and also an HTML file
that references the image. Thus, output that is generated in the HTML destination is
ready for display in a web browser.
The following ODS HTML statement stores the output files in the folder C:\myfiles
\mywebserver. The code first closes the LISTING destination to avoid creating extra
output:
ods html path="C:\myfiles\mywebserver" (url=none) file="modelfit.html" ;
proc sgrender data=sashelp.class template=modelfit; run;
ods html close; /* to close the output file */
ods listing; /* reopen the HTML destination for subsequent output */
•
The PATH= option specifies storage location C:\myfiles\mywebserver for
output files that are created by the SAS statements, including images from ODS
Graphics.
•
The FILE= option specifies that SAS output is written to the file modelfit.html,
which is saved in the location specified on PATH=.
•
The ODS HTML CLOSE statement closes the HTML destination, which enables
you to see your output. By default, the HTML destination uses the HTMLBLUE
style for graphics output (“Modifying Graph Appearance with Styles” on page 18
provides an introduction to ODS styles), which uses a gray background.
Managing the Graphical Output
17

See Chapter 22, “Managing Graphical Output,” on page 445 for more information about
the ODS destinations and the type of output that results from each destination.
Modifying Graph Appearance with Styles
GTL has been designed to be totally integrated with ODS styles.
Note: Although every appearance detail of a graph is controlled by the current style by
default, you can use GTL syntax options to change the appearance of the graph.
The following template code generates the histogram that was introduced in “Defining
the Graph Template” on page 5.
proc template;
  define statgraph cars;
    begingraph;
      entrytitle "Cars Profile";
      layout overlay;
        histogram horsepower;
        densityplot horsepower;
      endlayout;
    endgraph;
  end;
run;
Every ODS destination has a style that it uses by default. For the HTML destination, the
default style is HTMLBlue. To modify the appearance of the graph, you can change its
style by specifying the STYLE= option in the ODS destination statement before running
the SGRENDER procedure:
ods html style=analysis ;
proc sgrender data=sashelp.cars template=cars;
run;
18
Chapter 2
•
Quick Start

ods html style=journal ;
proc sgrender data=sashelp.cars template=cars;
run;
ods html style=meadow ;
proc sgrender data=sashelp.cars template=cars;
run;
For more information about how the appearance of the graph is determined and the ways
that you can modify it, see Chapter 6, “Managing Graph Appearance: General
Managing the Graphical Output
19

Principles,” on page 111 and Chapter 18, “Managing the Graph Appearance with
Styles,” on page 391.
Controlling Physical Aspects of the Output
The ODS GRAPHICS statement provides options that control the physical aspects of
your graphs, such as the graph size and the name of the output image file.
The HTML destination's default image size of 640 pixels by 480 pixels (4:3 aspect ratio)
for ODS Graphics is set in the SAS Registry. You can change the graph size using the
ODS GRAPHICS statement’s WIDTH= and/or HEIGHT= options. To name the output
image file, use the IMAGENAME= option.
The following ODS GRAPHICS statement sets a 320 pixel width for the graph and
names the output image modelfitgraph:
ods graphics / width=320px imagename=”modelfitgraph” ;
proc sgrender data=sashelp.class template=modelfit;
run;
ods graphics / reset ;
•
The WIDTH= option sets the image width to 320 pixels. Because no HEIGHT=
option is used, SAS uses the design aspect ratio of the graph to compute the
appropriate height. (The width of 320px is half the default width, so SAS will set the
height to 240px, which is half the default height.) In general, it is good practice to
specify only one sizing option without the other — just the WIDTH= option or just
the HEIGHT= option. That way SAS will maintain the design aspect ratio of the
graph, which might be important for many graphs.
•
The IMAGENAME= option in the first ODS GRAPHICS statement sets the name of
the output image file to modelfitgraph.
•
The RESET option in the second ODS GRAPHICS statement resets all ODS
GRAPHICS options to their default state. If the options are not reset, all subsequent
graphs would be 320 pixels wide and image names would be assigned incremental
names (modelfitgraph1, modelfitgraph2, and so on) every time a graph is produced.
For more information about the details of managing image name, image size, image
format, and DPI., see Chapter 22, “Managing Graphical Output,” on page 445.
20
Chapter 2
•
Quick Start

Chapter 3
Overview of Basic Statements
and Options
Introduction to GTL Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
Categories of Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Overview of GTL Statement Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Plot Statement Terminology and Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Legend Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
Text Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
Layout Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
Features Supported by Layout, Legend, and Text Statements . . . . . . . . . . . . . . . . 34
Backgrounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
Borders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
Padding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
Positioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
Features Supported by Many Plot Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
Plot Features to Be Displayed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
Plot Appearance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
Plot Transparency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
Plot Identification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
Labels for Plot Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Grouping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Axis Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Data Tips . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Introduction to GTL Statements
GTL encompasses a large number of statements and options. This chapter provides an
organizational framework to help you think about the language. Just as you can think of
the SAS language syntax in terms of Statements, Functions, Formats, and System
options, you can apply a classification scheme to GTL. A general understanding of the
GTL helps you write your templates with more confidence and efficiency. Some of the
terminology introduced here will appear often in other chapters.
Statements
All GTL statements have the following syntax:
KEYWORD(s) required argument(s) < / option(s)>
21

Examples:
/* This statement uses two keywords, no required arguments,
          and no options */
LAYOUT OVERLAY;
/* This statement uses one keyword and two required arguments */
SCATTERPLOT X=height Y=weight;
/* This statement specifies a required argument.
   Required arguments do not have to be name-value pairs. */
HISTOGRAM weight;
/* This statement uses one option.
   Options are specified after a slash (/) and are usually
   name-value pairs. */
SCATTERPLOT X=height Y=weight / GROUP=age;
Blocks
A block is a pair of statements that indicate the beginning and end of a syntax unit.
Typically, other statements are nested within the block. GTL has many specialized block
constructs.
Examples:
/* This is a valid block. No nested statements are required. */
LAYOUT OVERLAY;
ENDLAYOUT;
/* This block has no restrictions on the number of nested statements. */
LAYOUT OVERLAY;
  SCATTERPLOT X=height Y=weight;
  REGRESSIONPLOT X=height Y=weight;
ENDLAYOUT;
/* This block allows only nested ROWAXIS statements. */
ROWAXES;
  ROWAXIS / LABEL="Row 1";
  ROWAXIS / LABEL="Row 2";
ENDROWAXES;
/* Blocks support nested blocks */
CELL;
  CELLHEADER;
    ENTRY "Cell 1";
  ENDCELLHEADER;
  LAYOUT OVERLAY;
    HISTOGRAM weight;
    DENSITYPLOT weight;
  ENDLAYOUT;
ENDCELL;
Whenever blocks are nested, there exists a "Parent - Child" relationship. In the previous
example, the CELL block is the parent of the CELLHEADER block and LAYOUT
OVERLAY block. This is important because most blocks have rules about what
statements they might contain, and they also have nesting restrictions. For example, a
22
Chapter 3
•
Overview of Basic Statements and Options

CELLHEADER block, if used, must be the direct child of a CELL block. Only one
CELLHEADER block can be used per CELL block. To improve code readability, nested
blocks are indented in source programs.
Categories of Statements
Overview of GTL Statement Categories
GTL statements generally fall into two main categories:
•
Plot, Legend, and Text statements that determine what items are drawn in the graph.
•
Layout statements that determine how or where the items in the graphs are placed.
Plot Statement Terminology and Concepts
Overview of the GTL Plot Statements
GTL has numerous plot statements that can be combined with one another in many
different ways. In future releases of GTL, new layout and plot statements will be added
to supplement those now available. GTL has been designed as a high-level toolkit that
enables you to create a large variety of graphs by combining its constructs in different
ways. As you might imagine, not all combinations of statements are possible, and most
of the invalid combinations are caught during template compilation. Rather than trying
to create graphs by trial and error, it is recommended that you understand a few basic
"rules of assembly" to guide your efforts and make the language easier to work with. To
that end, some new terminology is useful.
Plot Terminology
Computed Plots
Computed plots internally perform computational transformations on the input data
and, as necessary, add new columns to a data object in order to render the requested
plot. For example, a LOESSPLOT requires two numeric columns of raw input data
(X=column and Y=column). A loess fit line is computed for these input point pairs, a
new set of points on a fit line is generated, and a new column that contains the
computed points is added to the data object. A smoothed line is drawn through the
computed points. Most computed plots have several options to control the
computation performed. Another form of computed plot is one with user-defined
data transformations. For example, you can use an EVAL( ) function to compute a
new column such as Y= eval(log10(column)). This transforms column values
into corresponding logarithmic values. Why is it important to know whether a plot is
computed? Certain layouts such as PROTOTYPE currently do not allow computed
plots to be included.
Parameterized Plots
Parameterized plots simply render the input data that they are given. They are useful
whenever you have input data that does not need to be preprocessed or that has
already been summarized (possibly an output data set from a procedure like FREQ).
For example, BARCHARTPARM draws one bar per input observation: the X=
column provides the bar tick value and the Y=column provides the bar length. So a
bar chart with five bars requires a data set with five observations and two variables.
A parameterized bar chart statement is useful when the computed BARCHART
statement does not perform the type of computation that you want, and you have
Categories of Statements
23

done the summarization yourself. Many parameterized plots have a "PARM" suffix
added to their name. Another common situation is when you want to draw a fit line
and a confidence band from a set of data that already has the appropriate set of (X,Y)
point coordinates. For these situations that you would use a SERIESPLOT statement
for the fit line and a BANDPLOT statement for the confidence band. Why is it
important to know whether a plot is parameterized? Parameterized plots ensure that
no additional computation takes place on the input data. Thus, input data that does
not meet the special requirements on the parameterized plot might result in bad
output or a blank graph.
Stand-alone Plots
A stand-alone plot is one that can be drawn without any other accompanying plot. In
general, a plot is stand-alone if its input data defines a range of values for all axes
that are needed to display the plot. For example, the observations plotted in a
SCATTERPLOT normally span a certain data range in both X and Y axes. This
information is necessary to successfully draw the axes and the markers. Why is it
important to know which plots are stand-alone? Because most layouts need to know
the extents of the X and Y axis to draw the plot.
Dependent Plots
A dependent plot is one that, by itself, does not provide enough information for the
axes that are needed to successfully draw the plot. For example, the
REFERENCELINE statement draws a straight line perpendicular to one axis at a
given input point on the same axis. Because there is only one point provided, there is
not enough information to determine the full range of data for this axis. Furthermore,
no information is provided for the data range of the second axis. Thus, a
REFERENCELINE statement does not provide enough information by itself to draw
the axes and the plot. Such a plot needs to work with another "Stand-alone" plot,
which provides the necessary information to determine the data extents of the two
axes.
Primary Plot
When you overlay two or more plots, the layout container determines the type of axis
to use, the data range of all axes, and the default format and label to use for each
axis. By default, the first encountered stand-alone plot is used to decide the axis type
and axis format and label. In some cases, you desire a certain overlay stacking and
must order your statements accordingly. This might result in undesirable axis
properties. By adding the PRIMARY=TRUE option to a stand-alone plot, you can
request that this plot be used to determine axis type and axis format and label. A
dependent plot cannot be designated as primary.
Graphics Types
GTL supports both 2-D and 3-D graphics. Currently there are only two 3-D plot
statements (SURFACEPLOTPARM and BIHISTOGRAM3DPARM). 3-D plot
statements must be used in a 3-D layout. 2-D plot statements cannot be used in a 3-D
layout, and 3-D plot statements cannot be used in a 2-D layout. For more information
about layouts, see “Layout Containers” on page 32.
Plot Statements Categorized by Type
Plot statements are generally categorized as stand-alone or dependent, computed or
parameterized, and 2-D or 3-D. The following tables show the distribution of plots in
these categories.
24
Chapter 3
•
Overview of Basic Statements and Options

Table 3.1
Stand-alone, 2-D, Computed Plots
2-D PLOTS: COMPUTED
Statement
Required Arguments
Comments
BARCHART
One column
Horizontal or vertical.
BOXPLOT
One numeric-column
Horizontal or vertical.
BUBBLEPLOT
Three numeric-columns
Plot of bubbles where a bubble is
placed at each X= and Y= crossing
and sized according to a response
variable. By default, the bubbles
appear as outlined circles.
DENDROGRAM
Three numeric-columns
Tree diagram that represents the
results of a hierarchical clustering
analysis.
DENSITYPLOT
One numeric-column
Theoretical distribution curve (for
example, NORMAL or KDE).
ELLIPSE
Two numeric-columns
Confidence or prediction ellipse
for a set of points.
HISTOGRAM
One numeric-column
Horizontal or vertical.
LINECHART
One column
Draws a chart that shows the
relationship of one variable to
another as trends.
LOESSPLOT
Two numeric-columns
Fit plot using loess.
PBSPLINEPLOT
Two numeric-columns
Fit plot using Penalized B-spline.
PIECHART
One column
Must be used within a LAYOUT
REGION block.
REGRESSIONPLOT
Two numeric-columns
Fit plot using linear, quadratic, or
cubic regression.
SCATTERPLOTMATRIX
Two or more numeric-
columns
Grid of scatter plots. Might include
computed ellipses, histograms,
density curves.
WATERFALLCHART
Two columns. Y must be
numeric
Waterfall chart consisting of bars
that represent an initial value of Y
and a series of intermediate bars
that are identified by X and that
lead to a final value of Y.
Categories of Statements
25

Table 3.2
Stand-alone, 2-D, Parameterized Plots
2-D PLOTS: NONCOMPUTED / PARAMETERIZED
Statement
Required Arguments
Comments
BANDPLOT
Three columns, at least
two numeric limits
Area bounded by two straight or
curved lines. The input data must
be sorted by the X or Y variable.
BARCHARTPARM
Two columns, Y must be
numeric
Horizontal or vertical.
Summarized data provided by
user.
BLOCKPLOT
Two columns
Strip of X- axis aligned
rectangular blocks containing text.
The X data must be sorted.
BOXPLOTPARM
One numeric-column and
one string-column
Horizontal or vertical. Needs
special data format.
CONTOURPLOTPARM
Three numeric-columns
Draws contour plot from pre-
gridded data. Basic "gridding"
feature is provided using an
option.
ELLIPSEPARM
Five numbers or numeric-
columns
Draws ellipse given center, slope,
semi-major, and semi-minor axis
lengths.
FRINGEPLOT
One numeric-column
Draws a short line segment of
equal length along the X or X2
axis for each observation's X
value.
HEATMAPPARM
Two columns | expressions
and one numeric-column |
expression
Draws a map of tiles that are
placed at each X= and Y= crossing
and colored based on a response
variable.
HIGHLOWPLOT
Three columns. HIGH,
and LOW must be numeric
Draws a high-low bar or line plot.
HISTOGRAMPARM
Two numeric-columns
Horizontal or vertical. The Y data
must be nonnegative.
MOSAICPLOTPARM
List of categorical columns
enclosed in parenthesis
and a numeric-column.
Creates a mosaic plot from pre-
summarized categorical data. The
numeric column must contain only
positive values.
NEEDLEPLOT
Two columns, Y must be
numeric
Draws parallel, vertical line
segments connecting data points to
a baseline.
26
Chapter 3
•
Overview of Basic Statements and Options

2-D PLOTS: NONCOMPUTED / PARAMETERIZED
Statement
Required Arguments
Comments
SCATTERPLOT
Two columns
Draws markers at data point
locations. The markers can be
sized according to the response
variable by using one or more
options.
SERIESPLOT
Two columns
Draws line segments to connect a
set of data points.
STEPPLOT
Two columns, Y must be
numeric
Draws stepped line segments to
connect a set of data points.
VECTORPLOT
Four numeric-columns, X
and Y origins can be
numeric constants.
Creates directed line segment(s)
based on pairs of data points.
Table 3.3
Stand-alone, 3-D, Parameterized Plots
3-D PLOTS: NONCOMPUTED / PARAMETERIZED
Statement
Required Arguments
Comments
BIHISTOGRAM3DPARM
Three numeric-columns
Bivariate histogram. The Z data
must be nonnegative.
SURFACEPLOTPARM
Three numeric-columns
Smooth surface.
Table 3.4
Dependent Plots
Statement
Required Arguments
Comments
DROPLINE
(X,Y) point location, two
columns, or one value and
one column
Draws a perpendicular line from a
data point to a specified axis.
LINEPARM
(X,Y) point location and
slope. The three values can
be provided in any
combination of number
and numeric-column
Draws line(s) given a data point
and the slope of the line.
MODELBAND
CLM or CLI name of
associated fit plot
Confidence bands. Used only in
conjunction with a fit plot.
REFERENCELINE
X or Y location, column
Draws line(s) perpendicular to an
axis.
Categories of Statements
27

Plot Concepts
To illustrate the use of the different types of plot statements, consider the following
template. In this template, named MODELFIT, a SCATTERPLOT is overlaid with a
REGRESSIONPLOT. The REGRESSIONPLOT is a computed plot because it takes the
input columns (Height and Weight) and transforms them into two new columns that
correspond to points on the requested fit line. By default, a linear regression
(DEGREE=1) is performed with other statistical defaults. The model in this case is
Weight=Height, which in the plot statement is specified with X=HEIGHT (independent
variable) and Y=WEIGHT (dependent variable). The number of observations generated
for the fit line is around 200 by default.
Note: Plot statements have to be used in conjunction with Layout statements. To
simplify our discussion, we will continue using the most basic layout statement:
LAYOUT OVERLAY. This layout statement acts as a single container for all plot
statements placed within it. Every plot is drawn on top of the previous one in the
order in which the plot statements are specified, with the last one drawn on top.
proc template;
  define statgraph modelfit;
    begingraph;
    entrytitle "Regression Fit Plot";
      layout overlay;
        scatterplot x=height y=weight /
                    primary=true;
        regressionplot x=height y=weight;
      endlayout;
    endgraph;
  end;
run;
proc sgrender data=sashelp.class 
              template=modelfit;
run;
The REGRESSIONPLOT statement can also generate sets of points for the upper and
lower confidence limits of the mean (CLM), and for the upper and lower confidence
limits of individual predicted values (CLI) for each observation. The CLM="name" and
CLI="name" options cause the extra computation. However, the confidence limits are
not displayed by the regression plot. Instead, you must use the dependent plot statement
28
Chapter 3
•
Overview of Basic Statements and Options

MODELBAND, with the unique name as its required argument. Notice that the
MODELBAND statement appears first in the template, ensuring that the band appears
behind the scatter points and fit line. A MODELBAND statement must be used in
conjunction with a REGRESSIONPLOT, LOESSPLOT, or PBSPLINEPLOT statement.
layout overlay;
  modelband "myclm" ;
  scatterplot x=height y=weight /
    primary=true;
  regressionplot x=height y=weight /
    alpha=.01 clm="myclm" ;
endlayout;
This is certainly the easiest way to construct this type of plot. However, you might want
to construct a similar plot from an analysis by a statistical procedure that has many more
options for controlling the fit. Most procedures create output data sets that can be used
directly to create the plot that you want. Here is an example of using non-computed,
stand-alone plots to build the fit plot. First choose a procedure to do the analysis.
proc reg data=sashelp.class noprint;
  model weight=height / alpha=.01;
  output out=predict predicted=p lclm=lclm uclm=uclm;
run; quit;
The output data set, Predict, contains all the columns and observations in Sashelp.Class
plus, for each observation, the computed columns P, LCLM, and UCLM.
Now the template can use simple, non-computed SERIESPLOT and BANDPLOT
statements for the presentation of fit line and confidence bands.
proc template;
Categories of Statements
29

  define statgraph fit;
    begingraph;
      entrytitle "Regression Fit Plot";
      layout overlay;
        bandplot x=height
          limitupper=uclm
          limitlower=lclm /
          fillattrs=GraphConfidence;
        scatterplot x=height y=weight /
          primary=true;
        seriesplot x=height y=p /
          lineattrs=GraphFit;
      endlayout;
    endgraph;
  end;
run;
proc sgrender data=predict template=fit;
run;
Legend Statements
GTL supports two types of legends: a discrete legend that is used to identify graphical
features such as grouped markers, lines, or overlaid plots; and a continuous legend that
shows the range of numeric variation as a ramp of color values. Legend statements are
dependent on one or more plot statements and must be associated with the plot(s) that
they describe. The basic strategy for creating legends is to "link" the plot statement(s) to
a legend statement by assigning a unique, case-sensitive name to the plot statement on its
NAME= option and then referencing that name on the legend statement.
Statement
Required Arguments
Comments
DISCRETELEGEND
Name(s) of associated
plot(s)
Traditional legend with entries for
grouped markers or lines, or overlaid
plots.
30
Chapter 3
•
Overview of Basic Statements and Options

Statement
Required Arguments
Comments
CONTINUOUSLEGEND
Name of an associated
plot
Shows a numeric scale with a color
ramp. Used in conjunction with
contours, surfaces, and scatter plots.
layout overlay;
  modelband "clm";
  scatterplot x=height y=weight /
    primary=true
    group=sex name="s" ; /* the name is case-sensitive */
  regressionplot x=height y=weight /
    alpha=.01 clm="clm";
  discretelegend "s" ;   /* case must match the case on NAME= */
endlayout;
For more information, see Chapter 8, “Adding Legends to a Graph,” on page 175.
Text Statements
GTL supports statements that add text to predefined locations of the graph. SAS Title
and Footnotes statements do not contribute to the graph. However, there are comparable
ENTRYTITLE and ENTRYFOOTNOTE statements. Like Title and Footnote
statements, multiple instances of these statements can be used to create multi-line text.
Statement
Required Arguments
Comments
ENTRYTITLE
String
Text to appear above graph. The
ENTRYTITLE statement is specified
inside the BEGINGRAPH block but
outside of the outermost layout.
Categories of Statements
31

Statement
Required Arguments
Comments
ENTRYFOOTNOTE
String
Text to appear below graph. The
ENTRYFOOTNOTE statement is
specified inside the BEGINGRAPH
block but outside of the outermost
layout.
ENTRY
String
Text to appear within graph. The
ENTRY statement is specified inside
a layout block.
layout overlay;
  modelband "clm";
  scatterplot x=height y=weight /
    primary=true;
  regressionplot x=height y=weight /
    alpha=.05 clm="clm";
  entry "Band shows 95% CLM" /
    autoalign=auto;
endlayout;
For more information, see Chapter 7, “Adding and Changing Text in a Graph,” on page
157.
Layout Containers
Layout statements, a key feature of the GTL, form "containers" that determine how the
plots, legends and texts items are drawn in the graph. GTL supports many different
layout statements that are suitable for different usage. However, these statements fall
into two main categories:
•
Single-cell layout statements, which place the plots, legends, and entries in a
common region. The statements that are placed within these "overlay" containers are
processed in order. Each plot is drawn on top of the previous plot, with the last one
drawn on top. See Chapter 4, “Using a Simple Single-cell Layout,” on page 45 and
Chapter 12, “Using an Equated Layout,” on page 299.
32
Chapter 3
•
Overview of Basic Statements and Options

•
Multi-cell layout statements, which partition the graph region into multiple smaller
"cells." Each cell can be populated by an individual plot, an overlay, or a nested
multi-cell layout. The layout of the "cells" is determined by the user, or by
classification variables. See Chapter 9, “Using a Simple Multi-cell Layout,” on page
211, Chapter 10, “Using an Advanced Multi-cell Layout,” on page 225, and Chapter
11, “Using Classification Panels,” on page 257.
Layout blocks always begin with the LAYOUT keyword followed by a keyword
indicating the purpose of the layout. All layout blocks end with an ENDLAYOUT
statement. The following table summarizes the available layouts.
Layout (Description)
Graphics
Allowed and
Cells
Produced
Comments
Example
OVERLAY
(Single Cell)
2-D
One cell
General purpose layout for
superimposing 2-D plots.
OVERLAYEQUATED
(Single Cell)
2-D
One cell
Specialized OVERLAY with
equated axes.
PROTOTYPE
(Single Cell)
2-D
One cell
Specialized LAYOUT used
only as child layout of
DATAPANEL or
DATALATTICE. Only 2–D
computed plots or 2–D plots
without expressions are
allowed.
REGION
(Single Cell)
2-D
One cell
Specialized LAYOUT used
only for graphs that do not
have an axis, such as a
PIECHART. Only one plot
statement can be used at a
time, but other statements
such as legends, entries and
nested layouts can be added.
OVERLAY3D
(Single Cell)
3-D
One cell
General purpose 3-D layout
for superimposing 3-D plots.
LATTICE
(Advanced Multi-cell)
2-D or 3-D
One or more
cells
All cells must be predefined.
Axes can be shared across
columns or rows, and they
can be external to the grid.
Many grid labeling and
alignment features.
GRIDDED
(Simple Multi-cell)
2-D or 3-D
One or more
cells
All cells must be predefined.
Axes independent for each
cell. Very simple multi-cell
container.
Categories of Statements
33

Layout (Description)
Graphics
Allowed and
Cells
Produced
Comments
Example
DATAPANEL
(Classification Panel)
2-D
One or more
cells
Displays a panel of similar
graphs based on data
subsetted by classification
variable(s). Number of cells
is based on crossings of n
classification variable(s).
Only one DATAPANEL
statement is allowed per
template.
DATALATTICE
(Classification Panel)
2-D
One or more
cells
Displays a panel of similar
graphs based on data
subsetted by classification
variable(s). Number of cells
is based on crossings of one
or two classification
variables. Only one
DATALATTICE statement is
allowed per template.
To learn more about layouts, refer to the appropriate chapter:
•
Chapter 4, “Using a Simple Single-cell Layout,” on page 45 (OVERLAY)
•
Chapter 12, “Using an Equated Layout,” on page 299 (OVERLAYEQUATED)
•
Chapter 13, “Using 3-D Graphics,” on page 309 (OVERLAY3D)
•
Chapter 9, “Using a Simple Multi-cell Layout,” on page 211 (GRIDDED)
•
Chapter 10, “Using an Advanced Multi-cell Layout,” on page 225 (LATTICE)
•
Chapter 11, “Using Classification Panels,” on page 257 (DATAPANEL,
DATALATTICE, PROTOTYPE)
Features Supported by Layout, Legend, and Text
Statements
All layout, legend, and text statements have a general set of features that include those
listed in the following tables. For more information about these and other options, see
the chapters specific to the layouts, text statements, and legends. Also see the SAS Graph
Template Language: Reference.
Backgrounds
Option
Description
OPAQUE= FALSE | TRUE
Specifies whether the background is transparent. By
default, OPAQUE=FALSE
34
Chapter 3
•
Overview of Basic Statements and Options

Option
Description
BACKGROUNDCOLOR= color
Specifies a color for the background when the
background is opaque.
Borders
Option
Description
BORDER= FALSE | TRUE
Specifies whether a border is displayed. By default,
BORDER=FALSE.
BORDERATTRS= ( line-options )
Specifies the properties of the border when a border is
displayed.
Padding
Option
Description
PAD= number
Specifies whether extra space is added inside the border.
By default, layouts and legends have PAD=0 while text
statements have PAD=(LEFT=3px RIGHT=3px) as the
default.
PAD=(<TOP=number>
<BOTTOM=number>
<LEFT=number>
<RIGHT=number>
OUTERPAD=AUTO | number
Specifies whether extra space is added outside the
border of layouts, legends, titles, and footnotes. The
default is AUTO, which specifies that the default
outside padding for the component is used.
OUTERPAD=(<TOP=number>
<BOTTOM=number>
<LEFT=number>
<RIGHT=number>
Positioning
Text
Option
Description
HALIGN= LEFT | CENTER |
RIGHT
Specifies the alignment for a text entry. For ENTRY
statements, a position can be specified relative to the
container. ENTRYTITLE and ENTRYFOOTNOTE
statements have fixed vertical positions but can be
adjusted horizontally.
VALIGN= TOP | CENTER |
BOTTOM
Features Supported by Layout, Legend, and Text Statements
35

Legends and Layouts
Option
Description
HALIGN= LEFT | CENTER |
RIGHT | value
Specifies the alignment for a legend or layout. For
legends, and for layouts that are nested within an
overlay type layout, a position can be specified relative
to the parent container. The values CENTER, LEFT,
RIGHT, TOP, and BOTTOM position the legend or
layout at fixed locations horizontally or vertically. You
can use value to express the position as a percentage of
the available vertical or horizontal space using any
numeric value between 0 and 1 inclusive. In order to use
these options on a layout block, the layout block must
be embedded in an overlay-type layout. Otherwise, the
HALIGN= and VALIGN= options are ignored. In that
case, a note is written to the SAS log. This restriction
does not apply to the legend statements.
Note the following equivalencies:
VALIGN=TOP is equivalent to VALIGN=1
VALIGN=BOTTOM is equivalent to VALIGN=0
HALIGN=RIGHT is equivalent to HALIGN=1
HALIGN=LEFT is equivalent to HALIGN=0
VALIGN= TOP | CENTER |
BOTTOM | value
Features Supported by Many Plot Statements
Plot Features to Be Displayed
All plots have a standard set of features to display. Most plots can show a different
feature set. For example, a HISTOGRAM can display bars that are outlined , filled, or
both outlined and filled. A SERIESPLOT displays a line and, if requested, point
markers.
Option
Description
DISPLAY=( feature …)
Specifies the plot features to be displayed. Features are
plot specific.
Plot Appearance
Depending on the display features, there are options to control the appearance of the
features.
Option
Description
MARKERATTRS=( marker-
options )
Specifies the symbol, size, color, and weight of markers.
36
Chapter 3
•
Overview of Basic Statements and Options

Option
Description
LINEATTRS= ( line-options )
Specifies the pattern, thickness, and color of lines.
TEXTATTRS= ( text-options )
Specifies the text color, font, font size, font weight, and
font style.
FILLATTRS= ( fill-options )
Specifies the fill color and transparency.
DATASKIN=(data-skin-name)
Specifies a skin to be applied to filled areas of a plot.
See “Data Skins” on page 151.
Plot Transparency
Transparency can be applied to plots that display markers, lines, or filled areas.
Option
Description
DATATRANSPARENCY= number
Specifies the degree of transparency. Default is 0 (fully
opaque). 1 is fully transparent.
layout overlay;
  modelband "cli" / display=(outline)
    outlineattrs=GraphPrediction
    datatransparency=.5 ;
  modelband "clm" / display=(fill)
    fillattrs=GraphConfidence
    datatransparency=.5 ;
  scatterplot x=height y=weight /
    primary=true;
  regressionplot x=height y=weight /
    alpha=.05 clm="clm" cli="cli"; endlayout;
Features Supported by Many Plot Statements
37

For more information, see Chapter 6, “Managing Graph Appearance: General
Principles,” on page 111.
Plot Identification
In GTL, legends and some dependent plots (for example, MODELBAND) require a
reference (association) with a plot. The association is established by 1) naming the plot,
and 2) referring to the plot name within the legend or dependent plot statement.
Option
Description
NAME= "string"
Specifies a unique name for a plot in order to associate
it with another statement.
LEGENDLABEL= "string"
Specifies a description of a plot to appear in a legend.
layout overlay;
  modelband "cli" / display=(outline)
    outlineattrs=GraphPrediction
    name="predict"
    legendlabel="95% Prediction Limits" ;
  modelband "clm" / display=(fill)
    fillattrs=GraphConfidence
    name="conf"
    legendlabel="95% Confidence Limits" ;
  scatterplot x=height y=weight /
    primary=true;
  regressionplot x=height y=weight /
    alpha=.05 clm="clm" cli="cli";
  discretelegend "predict" "conf" ;
endlayout;
For more information, see Chapter 8, “Adding Legends to a Graph,” on page 175.
38
Chapter 3
•
Overview of Basic Statements and Options

Labels for Plot Features
Most plots have one or more options that enable you to display descriptive labels or data
values for points, lines, bars, or bands.
Option
Description
DATALABEL= column
Specifies a column to label data points in a scatter plot,
series plot, needle plot, step plot, or vector plot.
DATALABELATTRS= text-
properties
Specifies text properties for data labels.
DATALABELPOSITION=TOPRIG
HT | TOP | TOPLEFT | LEFT |
CENTER | RIGHT |
BOTTOMLEFT | BOTTOM |
BOTTOMRIGHT
Specifies the position of the data labels relative to the
data points.
CURVELABEL= "string" | column |
expression
Specifies a string, column, or expression to label one or
more lines in a REFERENCELINE, DENSITYPLOT,
LINEPARM, REGRESSIONPLOT, LOESSPLOT,
PBSPLINEPLOT, SERIESPLOT, or STEPPLOT
statement.
CURVELABELUPPER= "string" |
column
CURVELABELLOWER= "string" |
column
Specifies a string or a string-column to label one or
more lines in a BANDPLOT or MODELBAND
statement.
CURVELABELATTRS= text-
properties
Specifies text properties for curve label(s).
CURVELABELLOCATION=
INSIDE | OUTSIDE
Specifies whether the curve label(s) are located inside or
outside the plot area.
Note: The CURVELABELLOCATION=OUTSIDE
option is not supported in the LATTICE,
DATALATTICE, and DATAPANEL layouts.
CURVELABELPOSITION=
Specifies positioning options for the curve label(s).
layout overlay;
  modelband "cli" / display=(outline)
    outlineattrs=GraphPrediction
    curvelabelupper="95% CLI"
    curvelabellower="95% CLI"
    curvelabelattrs=
    (color=GraphPrediction:Contrastcolor)
    curvelabellocation=outside ;
      
  modelband "clm" / display=(fill)
    fillattrs=GraphConfidence
    curvelabelupper="95% CLM"
Features Supported by Many Plot Statements
39

    curvelabellower="95% CLM"
    curvelabelattrs=
    (color=GraphConfidence:Color)
    curvelabellocation=outside ;
              
  scatterplot x=height y=weight / 
    primary=true datalabel=sex ;
  regressionplot x=height y=weight /
    alpha=.05 clm="clm" cli="cli"
    curvelabel="Fit"
    curvelabelattrs=
    (color=GraphFit:ContrastColor)
    curvelabellocation=outside ;
endlayout;
For more information, see Chapter 7, “Adding and Changing Text in a Graph,” on page
157.
For bar, curve, and data labels, many plots support options that enable you to split long
labels into multiple lines to avoid collisions. The following table lists these options.
Option
Description
BARLABELFITPOLICY=AUTO |
NONE
Specifies a policy for avoiding bar label collisions in a
vertical bar chart. When set to AUTO, the bar labels are
rotated when a collision occurs.
DATALABELSPLIT=TRUE |
FALSE
Specifies whether the data labels should be split into
multiple lines, if necessary, to fit the label in the
available space.
DATALABELSPLITCHAR="chara
cter-list"
Specifies one or more characters on which the data
labels can be split.
DATALABELSPLITCHARDROP=
TRUE | FALSE
Specifies whether the split characters on which a split
occurs are removed from the displayed data label.
40
Chapter 3
•
Overview of Basic Statements and Options

Option
Description
DATALABELSPLITJUSTIFY="jus
tification"
Specifies how each line of the split data labels is to be
justified.
CURVELABELSPLIT=TRUE |
FALSE
Specifies whether the curve labels should be split into
multiple lines, if necessary, to fit the label in the
available space.
CURVELABELSPLITCHAR="cha
racter-list"
Specifies one or more characters on which the curve
labels can be split.
CURVELABELSPLITCHARDROP
=TRUE | FALSE
Specifies whether the split characters on which a split
occurs are removed from the displayed curve label.
CURVELABELSPLITJUSTIFY="j
ustification"
Specifies how each line of the split curve labels is to be
justified.
VALUEFITPOLICY="fit-policy"
Specifies how block plot text values are adjusted to fit
within the containing block.
VALUESPLITCHAR="character-
list"
Specifies one or more characters on which the block
labels can be split when value splitting is used in a
block plot.
VALUESPLITCHARDROP=TRUE
| FALSE
Specifies whether the split characters on which a split
occurs are removed from the displayed block label when
value splitting is used in a block plot.
For axis labels, options are available that enable you to split long labels into multiple
lines to avoid truncation. The following table lists these options.
Option
Description
LABELFITPOLICY=AUTO |
SPLIT | SPLITALWAYS
Specifies a fit policy for the axis label. If the original
label is too long, AUTO specifies that the short label is
used instead (if specified), and SPLIT specifies that the
original label is split into multiple lines as needed to
make it fit the available. SPLITALWAYS specifies that
the original label is always split into multiple lines
regardless of the available space.
LABELSPLITCHAR="character-
list"
Specifies one or more characters on which the axis label
can be split when the SPLIT or SPLITALWAYS fit
policy is used.
LABELSPLITCHARDROP=TRUE
| FALSE
Specifies whether the split characters on which a split
occurs are removed from the displayed axis label when
the SPLIT or SPLITALWAYS fit policy is used.
LABELSPLITJUSTIFY="justificati
on"
Specifies how each line of the split axis label is to be
justified when the SPLIT or SPLITALWAYS fit policy
is used.
Features Supported by Many Plot Statements
41

Grouping
Many plots support a GROUP= option, which causes visually different markers, lines, or
bands to be displayed for each distinct data value of the specified column. You can vary
the appearance of group values with the INDEX= option. You can also use the
GROUPDISPLAY= option to change how groups are displayed.
Option
Description
GROUP= column
Specifies a group column, always treated as having
discrete values. For an example use, see the example for
“Legend Statements” on page 30.
INDEX= positive-integer-column
Specifies an integer column that associates each distinct
data value to a predefined graphical style element
GraphData1, GraphData2, …
GROUPDISPLAY=STACK |
CLUSTER | OVERLAY
Specifies whether group values for each category are
displayed as clusters of bars or as stacked bars for bar
charts, or as a cluster of markers or an overlay of
markers for other plot types.
For more information about using groups, see Chapter 6, “Managing Graph Appearance:
General Principles,” on page 111.
Axis Assignment
All 2-D plots have four potential axes: X, X2, Y, and Y2. You can choose the axes that
any plot uses. Axis options are typically specified in the LAYOUT statement that
contains the plot.
Option
Description
XAXIS= X | X2
Specifies whether the plot's X= column is displayed on
the X or X2 axis.
YAXIS= Y | Y2
Specifies whether the plot's Y= column is displayed on
the Y or Y2 axis.
For more information, see Chapter 5, “Managing Axes in an OVERLAY Layout,” on
page 63.
Data Tips
Data tips (or tooltips) are text balloons that appear in HTML pages when you move your
mouse pointer over a plot component such as a line, marker, or filled area of a graph. To
obtain default data tips, simply specify ODS GRAPHICS / IMAGEMAP; as well as the
ODS HTML destination. You can customize the data tip information.
42
Chapter 3
•
Overview of Basic Statements and Options

Option
Description
ROLENAME= ( role=column …)
Creates additional roles to customize data tips.
TIP= ( role-names )
Specifies which plot roles are used for data tips.
TIPFORMAT=(role=format …)
Specifies a format to be applied to the data for a plot
role.
TIPLABEL=( role="string" …)
Specifies a label to be applied to the column for a plot
role.
For more information and an example, see “Controlling Data Tips” on page 467.
Features Supported by Many Plot Statements
43

44
Chapter 3
•
Overview of Basic Statements and Options

Chapter 4
Using a Simple Single-cell Layout
About the Single-Cell Layouts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
The LAYOUT OVERLAY Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
Common Overlay Combinations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
How Plots Are Overlaid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
Statements Allowed in the Overlay Container . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
Restrictions on Allowed Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
Restrictions on Statement Combinations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
Avoiding Plot Conflicts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
Plots with Incompatible Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
The LAYOUT REGION Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
About the Single-Cell Layouts
The single-cell layouts provide a container for a single-cell 2-D graph. These containers
are created with the following statements:
LAYOUT OVERLAY
creates a single-cell graph container in which you can overlay the results of multiple
graph statements. Each graph is drawn in a separate layer in the order in which its
graph statement occurs in the layout block. The last graph in the block is drawn on
the top layer. For information about the LAYOUT OVERLAY statement, see “The
LAYOUT OVERLAY Statement” on page 46.
LAYOUT REGION
creates a single-cell graph container in which you can draw a single graph. The
container supports only graphs that do not have axes, such as pie charts. For
information about the LAYOUT REGION statement, see “The LAYOUT REGION
Statement” on page 59.
LAYOUT OVERLAYEQUATED
creates a single-cell container in which you can overlay the results of multiple graph
statements into a single axis area. Each graph is drawn in a separate layer in the order
in which its graph statement occurs in the layout block. The last graph in the block is
drawn on the top layer. The axes of this layout always have equal size units. For
information about the LAYOUT OVERLAYEQUATED statement, see “The
LAYOUT OVERLAYEQUATED Statement” on page 299.
45

The LAYOUT OVERLAY Statement
The LAYOUT OVERLAY statement builds a 2-D, single-cell graph by overlaying the
results of the statements that are contained in the layout block. This layout is one of
several possible layout containers in GTL. Other chapters provide detailed information
about the other layout types. It is recommended that you learn about this type of layout
first, because most of the other layout chapters contrast their feature sets with those of
the OVERLAY layout.
The outermost layout block of any template defines the content of the graphical area,
which is represented in the following schematic:
The graph in this next figure was defined by an OVERLAY layout with its border turned
on. The layout contains a simple scatter plot. The boundaries of the layout container are
shown by a light gray border. Everything within this border is managed by the layout.
The OVERLAY layout container controls
•
which statements (plot, legend, text) can be included in the layout block
•
which statements can be combined in the plot area bounded by the axes
•
various axis features
•
which axes are used (there are four available: X and Y, as well X2 and Y2)
•
which axis types are used (axis types are LINEAR, DISCRETE, LOG, and
TIME )
46
Chapter 4
•
Using a Simple Single-cell Layout

•
axis label, axis data range, ticks, and tick values
•
other axis features such as offsets
•
border, padding, and background properties
•
positioning and alignment of all contained plots, text, legends, and nested layouts
•
default appearance of the generated plots ( CYCLEATTRS= option).
•
the aspect ratio of the rectangular area of the plot wall (ASPECTRATIO= option)
The layout container also queries the contained statements for options that might change
the default internal rules for combining plots.
Common Overlay Combinations
After you become familiar with the plot statements GTL offers, you will see them as
basic components that can be stacked in many ways to form more complex plots. For
example, there is no "BARLINE" statement in GTL. You design this type of graph by
overlaying a SERIESPLOT on a BARCHART or BARCHARTPARM.
proc template;
  define statgraph barline;
    begingraph;
      entrytitle "Overlay of REFERENCELINE, BARCHARTPARM and SERIESPLOT";
      layout overlay; 
        referenceline y=25000000 / curvelabel="Target";
        barchartparm category=year response=retail / dataskin=matte
           fillattrs=(transparency=0.5)
           fillpatternattrs=(pattern=R1 color=lightgray);
        seriesplot x=year y=profit / name="series";
        discretelegend "series";
      endlayout;
    endgraph;
  end;
run;
/* compute sums for each product line */
proc summary data=sashelp.orsales nway;
  class year;
  var total_retail_price profit;
  output out=orsales sum=Retail Profit;
run;
/* close the ODS HTML destination */
ods html close;
/* open the LISTING destination and specify the JOURNAL3 style */
ods listing style=journal3;
/* generate the graph */
proc sgrender data=orsales template=barline;
  format retail profit comma12.;
run;
* close ODS LISTING and open ODS HTML */
ods listing close;
Common Overlay Combinations
47

ods html;
The output reflects the requested stacking order.
Chart Orientation. When creating a bar chart, it is sometimes desirable to rotate the
chart from vertical to horizontal. GTL does not provide separate statements for vertical
and horizontal charts—each is considered to be the same plot type with a different
orientation. To create the horizontal version of the bar-line chart, you need to specify
ORIENT=HORIZONTAL in the BARCHARTPARM statement:
proc template;
  define statgraph barline2;
    begingraph;       
      entrytitle "Overlay of REFERENCELINE, BARCHARTPARM and SERIESPLOT";
      layout overlay/* / yaxisopts=( reverse=true)*/; 
          referenceline x=25000000 / curvelabel="Target";
          barchartparm category=year response=retail / orient=horizontal
             dataskin=matte fillattrs=(transparency=0.5)
             fillpatternattrs=(pattern=R1 color=lightgray);
          seriesplot   x=profit y=year / name="series" 
          legendlabel="Profit in USD";
          discretelegend "series";
      endlayout;
    endgraph;
  end;
run;
/* compute sums for each product line */
proc summary data=sashelp.orsales nway;
  class year;
  var total_retail_price profit;
  output out=orsales sum=Retail Profit;  
run;
/* close the ODS HTML destination */
ods html close;
48
Chapter 4
•
Using a Simple Single-cell Layout

/* open the LISTING destination and specify the JOURNAL3 style */
ods listing style=journal3;
/* generate the graph */
proc sgrender data=orsales template=barline2;
format retail profit comma12.;
run;
/* close ODS LISTING and open ODS HTML */
ods listing close;
ods html;
Here, the Y axis becomes the category (DISCRETE) axis, and the X axis is used for the
response values. Both the REFERENCELINE and SERIESPLOT reflect this directly by
changing the variables that are mapped to the X and Y axes. The variable mapping for
BARCHARTPARM remains how it was, but we add the ORIENT=HORIZONTAL
option to swap the axis mappings. The data set up and SGRENDER step are unchanged.
This same strategy would be used to create a horizontal box plot or histogram. If you
wanted to reverse the ordering of the Y axis, you could add the REVERSE=TRUE
option to the Y-axis options:
layout overlay / yaxisopts=(reverse=true);
Multiple Axes. Sometimes you have equivalent data in different scales (currency,
measurements, and so on), or comparable data in the same scale that you want to display
on independent opposing axes.
The OVERLAY layout supports up to four independent axes where a Y2 axis opposes
the Y axis to the right and an X2 axis opposes the X axis at the top of the layout
container.
The following is a complete program to generate this type of graph. We would like to
display Fahrenheit temperatures on a separate Y2 axis from the Y axis used to display
Celsius temperatures. For this particular example, it is not necessary to have input
variables for both temperatures because an EVAL function can be used to compute a
new column of data within the context of the template.
Common Overlay Combinations
49

At this point, the most important concept to understand about template code is that an
independent axis can be created by mapping data to it. Notice that the SCATTERPLOT
statement uses the YAXIS=Y2 option. This causes the Y2 to axis to be displayed and
scaled with the computed variable representing Fahrenheit values. It is important to note
that multiple plots in an overlay share the same axis (such as the X-Axis). Hence, the
options to control the axis attributes are not found on the plot statements, but rather in
the LAYOUT statement. Most of the Y and Y2 axis options are included to force the tick
marks for the two different axis scales to exactly correspond. This example and many
other axis issues are discussed in detail in Chapter 5, “Managing Axes in an OVERLAY
Layout,” on page 63.
data temps;
  input City $1-11  Celsius;
datalines;
New York     11
Sydney       12
Mexico City  18
Paris         8
Tokyo         6
run;
proc template;
 define statgraph Y2axis;
  begingraph;
   entrytitle "Overlay of NEEDLEPLOT and SCATTERPLOT";
   entrytitle "SCATTERPLOT uses Y2 axis";
   layout overlay /
       xaxisopts=(display=(tickvalues))
       yaxisopts=(griddisplay=on offsetmin=0
         linearopts=(viewmin=0  viewmax=20
           thresholdmin=0 thresholdmax=0))
       y2axisopts=(label="Fahrenheit" offsetmin=0
         linearopts=(viewmin=32 viewmax=68
           thresholdmin=0 thresholdmax=0)) ;
     needleplot  x=City y=Celsius;
     scatterplot x=City y=eval(32+(9*Celsius/5)) / yaxis=y2
       markerattrs=(symbol=circlefilled);
50
Chapter 4
•
Using a Simple Single-cell Layout

   endlayout;
  endgraph;
 end;
run;
proc sgrender data=temps template=y2axis;
run;
Often, the input data's organization will affect your choice of plot statements in an
OVERLAY layout. In Chapter 3, “Overview of Basic Statements and Options,” on page
21, you saw that you would choose different plot statements for a fit plot, depending on
the nature of the input data for a fit plot.
Computed versus Paramterized Plots. If the data set has numeric columns for raw data
values of Height and Weight, the simplest way to create the fit line and confidence bands
is with a REGRESSIONPLOT, LOESSPLOT, or PBSPLINEPLOT statement and a
MODELBAND statement. All of these computed plot statements generate the values of
new columns corresponding to the points of the fit line and band boundaries.
layout overlay;  
  modelband "myclm";
  scatterplot    x=height y=weight / primary=true;
  regressionplot x=height y=weight / alpha=.01 clm="myclm";
endlayout;
If you have data computed by an analytic procedure that provides points on the fit line
and bands, you would choose a SERIESPLOT and BANDPLOT for the graph. This
technique is required when the desired fit line cannot be computed by the
REGRESSIONPLOT, LOESSPLOT, or PBSPLINEPLOT statement options.
layout overlay;
  bandplot x=height limitupper=uclm limitlower=lclm /
    fillattrs=GraphConfidence;
  scatterplot x=height y=weight / primary=true;
  seriesplot  x=height y=p / lineattrs=GraphFit;
endlayout;
Also, notice that additional options are used to set the appearance of the fit line and band
to match the defaults for REGRESSIONPLOT and MODELBAND.
Common Overlay Combinations
51

Grouped Data. Another common practice is to overlay series lines for comparisons. If
your data contains a classification variable in addition to X and Y variables, you could
use one SERIESPLOT statement with a GROUP= option:
proc template;
  define statgraph seriesgroup;
    begingraph;
    entrytitle "Overlay of SERIESPLOTs with GROUP=";
      layout overlay;            
        seriesplot x=date y=close / group=stock name="s";
        discretelegend "s";
      endlayout;
    endgraph;
  end;
run;
   
proc sgrender data=sashelp.stocks template=seriesgroup;
   where date between "1jan2002"d and "31dec2005"d;
run;
By default when you use a GROUP= option with a plot, the plot automatically cycles
through appearance features (colors, line styles, and marker symbols) to distinguish
group values in the plot. The default features that are assigned to each group value are
determined by the current style. For the following graph, the default colors and line
styles of the LISTING style are used:
Multiple Response Variables. If your data has multiple response variables, you could
create a SERIESPLOT overlay for each response. In such situations, you often need to
adjust the Y axis label.
proc template;
 define statgraph series;
  begingraph;
    entrytitle "Overlay of Multiple SERIESPLOTs";
    layout overlay / yaxisopts=(label="IBM Stock Price") ;
      seriesplot x=date y=high / curvelabel="High";
      seriesplot x=date y=low / curvelabel="Low";
    endlayout;
52
Chapter 4
•
Using a Simple Single-cell Layout

  endgraph;
 end;
run;
   
proc sgrender data=sashelp.stocks template=series;
   where date between "1jan2002"d and "31dec2005"d 
         and stock="IBM";
run;
Notice that, by default, each overlaid plot in this situation has the same appearance
properties.
Appearance Options. In cases when multiple plots have the same appearance, you can
use plot options to adjust the appearance of individual plots. For example, to adjust the
series lines from the previous example, you can use the LINEATTRS= option:
layout overlay / yaxisopts=(label="IBM Stock Price");
  seriesplot x=date y=high / curvelabel="High" lineattrs=GraphData1 ;
  seriesplot x=date y=low  / curvelabel="Low"  lineattrs=GraphData2 ;
endlayout;
You can also use the CYCLEATTRS= option, which is an option of the LAYOUT
OVERLAY statement that might cause each statement to acquire different appearance
features from the current style.
layout overlay / yaxisopts=(label="IBM Stock Price") cycleattrs=true ;
  seriesplot x=date y=high / curvelabel="High";
  seriesplot x=date y=low / curvelabel="Low";
endlayout;
Either coding produces the following graph:
Common Overlay Combinations
53

For additional information about how set the appearance features of plots, see Chapter 6,
“Managing Graph Appearance: General Principles,” on page 111 and Chapter 18,
“Managing the Graph Appearance with Styles,” on page 391.
How Plots Are Overlaid
The following sections explain in more detail how the overlay process works and why
some overlay constructs might not generate the graph that you expect.
Statements Allowed in the Overlay Container
If you were to randomly place GTL statements within a LAYOUT OVERLAY block,
you would often get compile errors. The following basic rules indicate which statements
can be used within the layout block:
•
all 2-D plot statements except SCATTERPLOTMATRIX
•
statements such as ENTRY, DISCRETELEGEND, and CONTINUOUSLEGEND
•
GRIDDED, LATTICE, REGION, and overlay-type layout blocks can be nested.
However, the following restrictions apply:
•
3-D plot statements cannot be included. Place these statements in a LAYOUT
OVERLAY3D block.
•
ENTRYTITLE or ENTRYFOOTNOTE statements cannot be included. Place these
statements outside the outermost layout block.
•
Other layout types such as PROTOTYPE, DATALATTICE, and DATAPANEL
layouts cannot be nested in an OVERLAY layout.
Restrictions on Allowed Statements
Even among the statements that are valid within an OVERLAY layout, some restrictions
apply to their use. For example, some dependent statements must be accompanied by at
54
Chapter 4
•
Using a Simple Single-cell Layout

least one stand-alone plot statement, such as SCATTERPLOT or SERIESPLOT, in order
to produce a usable graph. See Chapter 3, “Overview of Basic Statements and Options,”
on page 21 for lists of stand-alone and dependent statements.
For example, if you were to execute a template with the following layout block, it would
produce an empty graph at run time.
proc template;
  define statgraph test;
    begingraph;
      layout overlay;
        referenceline x=10;
      endlayout;
    endgraph;
  end;
run;
proc sgrender data=sashelp.class template=test;
run;
WARNING: A blank graph is produced. For possible causes, see the graphics
         template language documentation.
The GTL Reference documentation for the REFERENCELINE statement states an
important requirement that explains why this graph is empty:
A REFERENCELINE statement can be used only within 2-D overlay-type layouts
(OVERLAY, OVERLAYEQUATED, or PROTOTYPE). A stand-alone plot statement
that provides a sufficient data range for determining axis extents must be included in the
layout. For example, a REFERENCELINE statement can be used with a scatter plot or a
histogram statement.
Restrictions on Statement Combinations
Certain combinations of contained statements produce unexpected results. This section
examines why these combinations do not produce the expected graph.
Consider the following template code, which generates a warning in the log:
proc template;
  define statgraph test;
    begingraph;
      layout overlay;
        barchart category=age response=weight;
        regressionplot x=age y=weight;
      endlayout;
    endgraph;
  end;
run;
  
proc sgrender data=sashelp.class template=test;
run;
WARNING: REGRESSIONPLOT statement cannot be placed under a layout OVERLAY with a
         discrete axis. The plot will not be drawn.
When multiple statements that potentially contribute to axis construction are placed in
the layout, the layout must verify that all data that is mapped to a particular axis is of the
How Plots Are Overlaid
55

same type (all numeric, or all character, or all time). In addition, the layout must verify
that each plot can use the requested axis type(s). In this case, the first statement in the
layout is a BARCHART. Statements such as BARCHART and BARCHARTPARM
treat the CATEGORY=column as a categorical variable (regardless of data type) and
build a DISCRETE (categorical) axis. Therefore, because BARCHART is the first
statement in this example layout, it determines that the X axis is set to DISCRETE, and
subsequent plots must be compatible with a discrete axis.
Many computed plots, such as REGRESSIONPLOT, LOESSPLOT, and ELLIPSE,
require both X and Y axes to be of LINEAR type, which is a standard numeric interval
axis type. Had you specified a SCATTERPLOT instead of a REGRESSIONPLOT, there
would be no problem because a SCATTERPLOT can be displayed on either a
DISCRETE or LINEAR X and Y axis. The end result of this example is a graph
containing only the box plot output.
In this next example, the REGRESSIONPLOT and BARCHART statements have been
switched:
layout overlay;
  regressionplot x=age y=weight;
  barchart category=age response=weight;
endlayout;
WARNING: BARCHART statement has a conflict with the axis type. The plot will not 
be drawn.
In this case, the REGRESSIONPLOT (first plot) has fixed the type of the X axis to be
LINEAR. Now the BARCHART is blocked because it needs a DISCRETE X axis. The
end result of this example is a graph containing only the regression line.
Because a SCATTERPLOT can be included on either LINEAR or DISCRETE axes, you
might think the following combination is valid:
layout overlay;
  scatterplot x=age y=weight;
  barchart category=age response=weight;
endlayout;
WARNING: BARCHART statement has a conflict with the axis type. The plot will not 
be drawn.
In this case, the SCATTERPLOT (first statement) sets the X or Y axis type to LINEAR
if the variable for that axis is numeric—even though the data might be categorical in
nature. However, if the variable is character, the SCATTERPLOT must use a
DISCRETE axis. So, once again the BARCHART is not displayed. If you switch the
statements, both plots are drawn because after the X axis is fixed to be DISCRETE, the
SCATTERPLOT can display numeric values on a DISCRETE axis.
When a character variable is used, the axis-type conflict often does not arise. The
following combination works regardless of statement order. In either case, the
DISCRETE X axis will display a combination of AGE values with box plots above and
SEX values with scatter points above.
layout overlay;
  scatterplot x=sex y=weight;
  barchart category=age response=weight;
endlayout;
56
Chapter 4
•
Using a Simple Single-cell Layout

Avoiding Plot Conflicts
In GTL, it is important to know what types of axes a given plot requires or can support.
If you understand the basic ideas behind previous examples, you can use the following
additional GTL syntax to avoid some of the problems caused by the first plot statement
deciding the axis type:
•
use the PRIMARY=TRUE option on a plot statement to ensure that plot is used to
determine the axis type
•
declare an axis type on the layout block.
Most non-dependent plot statements support the PRIMARY= option. By default,
PRIMARY=TRUE for the first plot and PRIMARY=FALSE for the rest of the plots in
the layout. On a per-axis basis, only one plot in an overlay can use PRIMARY=TRUE.
If multiple plots specify PRIMARY=TRUE for the same axis, the last one encountered
is considered primary. The plot that is designated as primary by default defines the axis
types for the axes that it uses, regardless of its order within the layout block. This is
useful when you want a certain stacking order for the plots, but do not want the first plot
to set the axis features, such as axis type and default axis label.
In the following example, the BARCHART sets the X axis to be DISCRETE and the Y
axis to be LINEAR:
layout overlay;
  scatterplot x=age y=weight;
  barchart category=age response=weight / primary=true ;
endlayout;
All layouts that manage axes provide options that enable you to control the axis features.
The following example shows how to declare an axis type for the X axis. Any plot in the
layout that cannot support a discrete axis will be dropped. Also note that specifying an
axis type overrides the default axis type that is derived from the primary plot. Axis
options are discussed in detail in Chapter 5, “Managing Axes in an OVERLAY Layout,”
on page 63.
layout overlay / xaxisopts=(type=discrete) ;
  scatterplot x=age y=weight;
  barchart category=age response=weight;
endlayout;
Some plot combinations can never be used. A histogram and bar chart look similar, but
they have different data and axis requirements. The histogram must use a linear X axis
and the bar chart must use a discrete X axis. The two plot types can never be overlaid.
layout overlay;
  barchart category=age;
  histogram age;
endlayout;
WARNING: HISTOGRAM statement has a conflict with the axis type. The plot will 
not be drawn.
layout overlay;
  histogram age;
  barchart category=age;
endlayout;
How Plots Are Overlaid
57

WARNING: BARCHART statement has a conflict with the axis type. The plot will not 
be drawn.
Plots with Incompatible Data
All plot statements have required argument(s) that map input data column(s) to one or
more axes. Many plot statements have restrictions on the variable type (numeric or
character) that can be used for the required arguments.
For example, the HISTOGRAM statement accepts only a numeric variable for the
required argument. Consider the following template:
proc template;
  define statgraph test;
    begingraph;
      layout overlay;
        histogram sex;
      endlayout;
    endgraph;
  end;
run;
NOTE: STATGRAPH 'Test' has been saved to: SASUSER.TEMPLAT
If you were to create this template, you would not see a compilation error or warning
because no variables are checked at compile time. However, you would see warnings in
the log when the template is executed:
proc sgrender data=sashelp.class template=test;
run;
WARNING: Invalid data passed to BIN. Variable must be numeric.
WARNING: The histogram statement will not be drawn because one or more of the
         required arguments were not supplied.
WARNING: A blank graph is produced. For possible causes, see the graphics
         template language documentation.
In general, GTL produces a graph whenever possible. Plots in the overlay that can be
drawn will be drawn. Plots are not drawn if they have incompatible data for the required
arguments or if they cannot support the existing axis type(s). Hence, you might get a
graph with some or none of the requested plot overlays.
The same strategy extends to plot options that have incompatible data. In the following
example, the wrong variable name was used for the GROUP= option. In the data, the
column is named Sex, not Gender. This is not regarded as an error condition—the bar
chart will be drawn without groups.
layout overlay;
  barchart category=age / group=gender;
endlayout;
58
Chapter 4
•
Using a Simple Single-cell Layout

The LAYOUT REGION Statement
The LAYOUT REGION statement supports plots that have no axes, such as pie charts. It
also supports annotations such as text, lines, arrows, images, and geometric shapes, that
are generated with the draw statements. For information about adding annotations, see
Chapter 19, “Adding Non-Data-Driven Graphics Elements to a Graph,” on page 405.
The LAYOUT REGION statement allows only one plot statement. If you include more
than one, the additional plot statements are ignored. You can include
DISCRETELEGEND, CONTINUOUSLEGEND, and ENTRY statements with your
region plot statement. You can use a LAYOUT REGION statement to define a top-level
region container or to define a region container for a single cell in a LAYOUT
GRIDDED or LAYOUT LATTICE statement. You can also nest a REGION layout in
other layouts, such as GRIDDED, LATTICE, and overlay-type layouts. However, the
REGION layout cannot be nested in DATAPANEL and DATALATTICE layouts.
Note: When you nest a REGION layout in an overlay-type layout, you must include the
HEIGHT=, WIDTH=, VALIGN=, and HALIGN= options in your LAYOUT
REGION statement to specify the size and alignment of the plot.
Here is an example of a LAYOUT REGION statement that defines a top-level container
for the pie chart that is shown in the following figure.
Here is the SAS code that generates this chart.
proc template;
define statgraph region;
The LAYOUT REGION Statement
59

  begingraph;
     entrytitle "Sales By State";
     layout region;
        piechart category=state response=actual /
           dataskin=pressed datalabellocation=outside;
     endlayout;
  endgraph;
end;
run;
quit;
ods graphics on / reset outputfmt=static;
proc sgrender data=sashelp.prdsal2 template=region;
   where country eq "U.S.A.";
   format actual dollar12.0;
run;
quit;
Here is an example of a LAYOUT OVERLAY and a LAYOUT REGION statement that
are nested in a LAYOUT LATTICE block to create the charts shown in the following
figure.
Here is the SAS code that generates these charts.
/* Get sales data in millions from SASHELP.PRDSAL2. */
data sales;
   set sashelp.prdsal2;
   actualmils=(actual / 1000000);
run;
/* Create the graph template. */
proc template;
60
Chapter 4
•
Using a Simple Single-cell Layout

define statgraph region;
  begingraph;
     entrytitle "Sales By State";
     layout gridded / columns=1 rows=2;
        layout lattice / columns=2 rows=1;
           cell;
              /* Generate a bar chart of sales in millions. */
              cellheader;
                 entry "Sales in Millions";
              endcellheader;
              layout overlay / width=250px
                 xaxisopts=(display=none)
                 yaxisopts=(griddisplay=on display=(ticks tickvalues));
                 barchart category=state response=actualmils / 
                    group=state
                    orient=vertical
                    dataskin=pressed barwidth=0.8;  
              endlayout;
           endcell;
           cell;
              /* Generate a pie chart of percent of total sales. */
              cellheader;
                 entry "Percent of Total Sales";
              endcellheader;
              layout region / pad=10;
                piechart category=state response=actualmils /
                   name="salespct"
                   dataskin=pressed
                   datalabelcontent=(percent)
                   datalabellocation=inside labelfitpolicy=drop;
              endlayout;
           endcell;
        endlayout;
        discretelegend "salespct" / title="State" across=4;
     endlayout;
  endgraph;
end;
run;
quit;
/* Generate the graph. */
proc sgrender data=sales template=region;
   where country eq "U.S.A.";
   format actualmils dollar5.1;
run;
quit;
Notice that the LAYOUT OVERLAY statement defines the layout for the bar chart in
the first cell in the lattice, and that the LAYOUT REGION statement defines the layout
for the pie chart in the second cell. You can use the LAYOUT REGION statement with
other layout statements to combine region plots and other types of plots in a single
LAYOUT GRIDDED or LAYOUT LATTICE statement.
The LAYOUT REGION Statement
61

62
Chapter 4
•
Using a Simple Single-cell Layout

Chapter 5
Managing Axes in an OVERLAY
Layout
Introduction to Axis Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
Axis Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
How Plot Statements Affect Axis Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
Specifying Axis Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
Default Axis Construction and Related Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
Determine Axis Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
Apply Axis Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
Determine Axis Data Range . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
Determine Axis Label . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
Determine Axis Tick Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
Apply Axis Thresholds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
Apply Axis Offsets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
LINEAR Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
Setting the Axis Data Range and Tick Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
Formatting Axis Tick Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
Scaling Tick Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
Avoiding Tick Value Collisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
DISCRETE Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
Setting the Axis Tick Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
Avoiding Tick Value Collisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
Setting Alternating Wall Color Bands for Discrete Intervals . . . . . . . . . . . . . . . . . . 94
Offsetting Graph Elements from the Category Midpoint . . . . . . . . . . . . . . . . . . . . . 95
TIME Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
Overview of TIME Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
Setting the Tick Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
Formatting Axis Tick Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
Avoiding Tick Value Collisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
Setting the Axis Data Range . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
LOG Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
Overview of LOG Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
Setting the Log Base . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
Setting the Tick Intervals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
Setting the Tick Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
Axis Line versus Wall Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
Axis Appearance Features Controlled by the Current Style . . . . . . . . . . . . . . . . . 109
63

Introduction to Axis Management
When you write GTL programs, all axes are automatically managed for you. For
example, in a LAYOUT OVERLAY block, the overlay container decides the following
characteristics:
•
which axes are displayed
•
the axis type of each axis (linear, time, and so on)
•
the data range of each axis
•
the label of the axis
•
other axis characteristics, some of which are derived from the current style
Usually, the internal techniques that are used to manage axes produce good default axes.
Occasionally, you might find some feature that you want to change. Layout statements
provide many axis options that change the default axis behavior. This chapter shows
how axes are managed by default and the programming options that are available to you
for changing that behavior.
Note: This chapter discusses axis features that are specific to an OVERLAY layout
when it is the outermost layout and not nested in another layout. Nesting layouts
sometimes causes interactions that affect the axis features. You should read this
chapter before reading about other layout types because this chapter provides the
basic principles of axis management. Be aware, though, that the other layout types
(for example, OVERLAYEQUATED, OVERLAY3D, LATTICE, DATAPANEL,
and DATALATTICE) also control axes. Many of these layouts have similar
although not identical options to the OVERLAY layout. See the chapters on these
other layouts for detailed discussions on how they manage axes.
Axis Terminology
The OVERLAY container has up to four independent axes (X, Y, X2, Y2) that can be
used in various combinations. Each axis has the following features, which can be
selectively displayed using the option or setting that is shown in parentheses.
•
axis line (LINE)
•
axis label (LABEL)
•
tick marks (TICKS)
•
tick values (TICKVALUES)
•
grid lines drawn perpendicular to the axis at tick marks (GRIDDISPLAY=)
•
gaps at the beginning and end of the axis (OFFSETMIN= and OFFSETMAX=)
64
Chapter 5
•
Managing Axes in an OVERLAY Layout

How Plot Statements Affect Axis Construction
Primary and Secondary Axes. The LAYOUT OVERLAY container supports two
horizontal (X and X2) and two vertical (Y and Y2) axes. The bottom axis (X) and the
left axis (Y) are the default axes, referred to as the primary axes. The top axis (X2) and
the right axis (Y2) are referred to as the secondary axes and are displayed only if they
are requested. For example, consider this simple layout block:
layout overlay;
  scatterplot x=city y=fahrenheit;
endlayout;
Explicitly, the layout block means the following:
layout overlay;
  scatterplot x=city y=fahrenheit / xaxis=x yaxis=y ;
endlayout;
How Plot Statements Affect Axis Construction
65

The defaults result in an XY plot having only two axes, X and Y. However, you can
request that either the X or Y columns be mapped to the X2 or Y2 axis. The XAXIS=
option can be set to X or X2. Similarly, the YAXIS= option can be set to Y or Y2:
layout overlay;
  scatterplot x=city y=fahrenheit / xaxis=x2 yaxis=y2 ;
endlayout;
A single plot statement can activate one horizontal and one vertical axis. It cannot
activate both horizontal or both vertical axes. Thus, to see both a Y and Y2 axis based on
the same Y column, you could specify an additional plot statement:
layout overlay;
  scatterplot x=city y=fahrenheit / xaxis=x yaxis=y ;
  scatterplot x=city y=fahrenheit / xaxis=x yaxis=y2 ;
endlayout;
This layout could be more compactly written as follows:
layout overlay;
  scatterplot x=city y=fahrenheit;
  scatterplot x=city y=fahrenheit / yaxis=y2 ;
endlayout;
66
Chapter 5
•
Managing Axes in an OVERLAY Layout

Note that this coding produces two overlaid scatter plots, each with five markers.
Because the five (X,Y) value pairs and the five (X,Y2) value pairs are identical, the Y
and Y2 axes are identical and the markers are exactly superimposed. However, it is not
necessary to create a second plot when you want the secondary axis to be a duplicate of
the primary axis. A more direct way to accomplish this is shown in “Specifying Axis
Options” on page 68.
The next two examples show the independent nature of primary and secondary axes. In
each case, a different data column is mapped to the Y and Y2 axes.
layout overlay;
  seriesplot x=date y=price;
  needleplot x=date y=volume / yaxis=y2;
endlayout;
As the following figure shows, the primary and secondary Y axes are independently
scaled and there is not a necessary connection between the units or data ranges of either
axis.
In the next example, even though the Y and Y2 columns are different, the primary and
secondary Y axes represent the same data range in different units. In such cases, the
positioning of the tick values on each axis should be coordinated so that the grid lines
represent the same temperature on each axis. “Apply Axis Thresholds” on page 78
provides example code that shows how to coordinate the tick value positions.
layout overlay;
How Plot Statements Affect Axis Construction
67

  scatterplot x=city y=fahrenheit;
  scatterplot x=city y=celsius  / yaxis=y2 ;
endlayout;
Specifying Axis Options
To set axis options on the LAYOUT OVERLAY statement, you use the following
syntax. Notice that each axis has its own separate set of options, and that the option
specifications must be enclosed in parentheses. GTL frequently uses parentheses to
bundle options that modify a specific feature. These are called "option bundles."
layout overlay / xaxisopts =(options) yaxisopts =(options) 
  x2axisopts=(options) y2axisopts=(options);
If you specify the X2AXISOPTS= or Y2AXISOPTS= options but there is no data
mapped to these axes, the option bundles are ignored.
One of the basic options that you can set for any axis is DISPLAY= keyword | ( feature-
list ). Four features are available for the feature-list: LINE, TICKS, TICKVALUES, and
LABEL. The keywords STANDARD and ALL are equivalent to specifying the full list:
( LINE TICKS TICKVALUES LABEL ). You can also use DISPLAY=NONE to
completely suppress all parts of the axis.
Example: Some plots do not need TICKS on all axes. The follow axis option eliminates
the ticks on the X axis by omitting the TICKS value on the feature-list.
layout overlay / xaxisopts=( display=( line label tickvalues )  );
  barchartparm category=city response=fahrenheit; 
endlayout;
68
Chapter 5
•
Managing Axes in an OVERLAY Layout

We now return to the common situation where you want a duplicated Y2 axis. Here is
the most efficient way to do it:
layout overlay / yaxisopts=( displaysecondary=standard );
  barchartparm category=city response=fahrenheit; 
endlayout;
This specification creates the Y2 axis as a duplicate of the Y axis: all features are
displayed without having to map data to the Y2 axis. You can also restrict the secondary
axis features that are displayed by specifying a list of the features that you want to be
displayed. The values available for the DISPLAYSECONDARY= option are the same
as those of the DISPLAY= option. The following example specifies that the secondary
axis label is not to be displayed. It also requests that grid lines be displayed on the Y
axis:
layout overlay / xaxisopts=( display=( line label tickvalues ) )
    yaxisopts=( displaysecondary=( ticks tickvalues line )
      griddisplay=on );
  barchartparm category=city response=fahrenheit; 
endlayout;
Specifying Axis Options
69

Default Axis Construction and Related Options
Determine Axis Type
To determine axis types, the OVERLAY container examines all of the stand-alone plot
statements that are specified. It also examines whether an axis type has been specified
with the TYPE= setting on an axis option (for example, on XAXISOPTS=). If there is
only one stand-alone plot, or a plot is designated as PRIMARY, the rules are simple:
•
If the plot statement that is mapped to an axis treats data values as discrete (such as
the CATEGORY= column of the BARCHART or the X= column of the BOXPLOT
statement), the axis type is DISCRETE for that axis, regardless of whether the data
column that is mapped to the axis is character or numeric. A DISCRETE axis has
tick values for each unique value in a data column.
•
If the plot statement that is mapped to an axis bases the axis type on the data type of
the assigned values, a DISCRETE axis is created when the column type is character.
Otherwise, a TIME or LINEAR axis is created.
•
If the plot statement that is mapped to an axis specifies a numeric column and the
column has a date, time, or datetime format associated with it, the axis type is TIME.
See “TIME Axes” on page 97 for examples. Otherwise, the numeric axis type is
LINEAR, the general numeric axis type. See “LINEAR Axes” on page 84 for
examples.
•
A LOG axis is never automatically created. To obtain a LOG axis, you must
explicitly declare the axis type with the TYPE=LOG option. See “LOG Axes” on
page 102 for examples.
•
If a TYPE= axis-type option is specified, that is the type used. Plots that cannot
support that axis type are not drawn.
When the overlay container has multiple plots that generate axes, GTL can determine
default axis features for the shared axes, or you can use the PRIMARY= option on one
of the plot statements to specify which plot you want the GTL to use.
•
If no plot is designated as primary, the data columns that are associated with the first
plot that generates an axis are considered primary on a per-axis basis.
•
If PRIMARY=TRUE for a plot within an overlay-type layout, that plot's data
columns and type are used to determine the default axis features, regardless of where
this plot statement occurs within the layout block.
•
Only one plot can be primary on a per-axis basis. If multiple plots specify
PRIMARY=TRUE for the same axis, the last one encountered is considered primary.
Example: For the following layout block, the BARCHART is considered the primary
plot because it is the first stand-alone plot that is specified in the layout and no other plot
has been set as the primary plot. A BARCHART requires a discrete X-axis. You cannot
change the axis type. It does not matter whether Quarter is a numeric or character
column. Because the SERIESPLOT can use a discrete axis, the overlay is successful.
layout overlay;  
  barchart   category=quarter response=actualSales;
  seriesplot x=quarter y=predictedSales;
endlayout;
70
Chapter 5
•
Managing Axes in an OVERLAY Layout

Example: For the following layout block, the first SERIESPLOT is considered primary.
If the Quarter column is numeric and has a date format, then the X-axis type is TIME. If
the column is numeric, but does not have a date format, then the axis type is LINEAR. If
the column is character, then the axis type is DISCRETE.
layout overlay;
  seriesplot x=quarter y=predictedSales;
  seriesplot x=quarter y=actualSales;
endlayout;
Example: For the following layout block, the X-axis is DISCRETE because it was
declared to be DISCRETE and this does not contradict any internal decision about axis
type because both SERIESPLOT and BARCHART support a discrete axis. It does not
matter whether Quarter is a numeric or character column.
layout overlay / xaxisopts=(type=discrete);
  seriesplot x=quarter y=predictedSales;
  barchart   category=quarter response=actualSales;
endlayout;
Example: For the following layout block, the SERIESPLOT is the primary plot. If
Quarter is a character column, a discrete axis is used and the overlay is successful.
However, if Quarter is a numeric column, either a TIME or LINEAR axis is used, the
BARCHART overlay fails, and a message is written to the log.
layout overlay;
  seriesplot x=quarter y=predictedSales;
  barchart   category=quarter response=actualSales;
endlayout;
WARNING: BARCHART statement has a conflict with the axis type. The plot will not 
be drawn.
Apply Axis Options
Each of the four possible axes (X, Y, X2, Y2) can be managed with a set of options that
apply to axes of any type. In addition, option bundles are available for managing each
specific axis type. For example, the following syntax shows the option bundles that are
available on the LAYOUT OVERLAY statement's XAXISOPTS= option:
LAYOUT OVERLAY </ XAXISOPTS=(general-options LINEAROPTS=(options )
DISCRETEOPTS=(options ) TIMEOPTS=(options ) LOGOPTS=(options ) ) >;
These same bundles are available for the other axes using the following LAYOUT
OVERLAY options:
YAXISOPTS= (same-as-xaxisopts )
Y2AXISOPTS=(same-as-xaxisopts )
X2AXISOPTS=(same-as-xaxisopts )
You can specify as many type-specific option bundles as you want, but only the bundle
that corresponds to the axis type is used for a given template execution.
Determine Axis Data Range
After the type of each axis is determined in the layout, the data ranges of all plot
statements that contribute to an axis are compared. For LINEAR, TIME, and LOG axes,
the minimum of all minimum values and the maximum of all maximum values are
Default Axis Construction and Related Options
71

derived as a "unioned" data range. For a DISCRETE axis, the data range is the set of all
unique values from the sets of all values. The VIEWMIN= and VIEWMAX= options for
LINEAR, TIME, and LOG axes can be used to change the displayed axis range. For
examples, see “LINEAR Axes” on page 84, “TIME Axes” on page 97, and “LOG
Axes” on page 102.
Determine Axis Label
How Axis Labels Are Determined
The default axis label is determined by the primary plot. If a label is associated with the
data column, the label is used. If no column label is assigned, the column name is used
for the axis label. Each set of axis options provides LABEL= and SHORTLABEL=
options that can be used to change the axis label. By default, the font characteristics of
the label are set by the current style, but the plot statement's LABELATTRS= option can
be used to change the font characteristics. See “Axis Appearance Features Controlled by
the Current Style” on page 109. The following examples show how axis labels are
determined and how to set an axis label.
Consider the following data set, which contains information about bacteria and virus
growth:
data growth;
  do Hours=1 to 15 by .5; 
    Bacteria= 1000*10**( sqrt(Hours ));
    Virus= 1000*10**(log(hours));
    label bacteria="Bacteria Growth" virus="Virus Growth";
    output;
  end;
run;
To plot the growth trend for both Bacteria and Virus in the same graph, we can use a
simple overlay of series plots. Whenever two or more columns are mapped to the same
axis, the primary plot determines the axis label. In the following example, the first
SERIESPLOT is primary by default, so its columns determine the axis labels. In this
case, the Y-axis label is determined by the BACTERIA column.
layout overlay / cycleattrs=true;
  seriesplot x=Hours y=Bacteria/ curvelabel="Bacteria"; 
  seriesplot x=Hours y=Virus / curvelabel="Virus";
endlayout;
72
Chapter 5
•
Managing Axes in an OVERLAY Layout

If we designate another plot statement as "primary," its X= and Y= columns are used to
label the axes. The PRIMARY= option is useful when you desire a certain stacking order
of the overlays, but you want the axis characteristics to be determined by a plot
statement that is not the default primary plot statement. In the following example, the
second SERIESPLOT is set as the primary plot, so its columns determine the axis labels.
In this case, the Y-axis label is determined by the VIRUS column.
layout overlay / cycleattrs=true;
  seriesplot x=Hours y=Bacteria/ curvelabel="Bacteria";
  seriesplot x=Hours y=Virus / curvelabel="Virus" primary=true ;
endlayout;
Figure 5.1
Primary Plot Determines Default Axis Label
In the previous two examples, allowing the primary plot to determine the Y-axis label
did not result in an appropriate label because a more generic label is needed. To achieve
this, you must set the axis label yourself with the LABEL= option.
layout overlay / cycleattrs=true 
    yaxisopts=(label="Growth of Virus and Bateria Cultures") ;
  seriesplot x=Hours y=Bacteria/ curvelabel="Bacteria";
  seriesplot x=Hours y=Virus / curvelabel="Virus";
endlayout;
For computed columns, an axis label is manufactured from the input column(s) and the
functional transformation that is applied to the input column(s). For example, you can
use an EVAL expression to compute a new column that can be used as a required
argument as shown in the following example.
layout overlay;
  histogram eval(weight*height);
endlayout;
In this example, the manufactured label is BIN(WEIGHT*HEIGHT) as shown in the
following figure.
Default Axis Construction and Related Options
73

Overriding the Default Label
You can use the axis option LABEL= to override the default label for an axis with your
own label. In the case of a computed column, for example, you might want to replace the
manufactured label with a more appropriate label as shown in the following example.
layout overlay / xaxisopts=(label="Product of Weight and Height");
  histogram eval(weight*height);  
endlayout;
In this example, the manufactured label BIN(WEIGHT*HEIGHT) is replaced with
Product of Weight and Height.
Making Long Axis Labels Fit
If the data column's label is long or if you supply a long string for the label, the label
might be truncated if it does not fit in the allotted space. This might happen when you
create a small graph or when the font size for the axis label is large. The following figure
shows an example.
74
Chapter 5
•
Managing Axes in an OVERLAY Layout

As a remedy for these situations, you can specify a shorter alternate label with the
SHORTLABEL= option, or you can split the label into multiple lines by setting the
LABELFITPOLICY= option to SPLIT or SPLITALWAYS.
A short label is displayed whenever the default label or the LABEL= string does not fit
and label splitting is not enabled. Here is the previous example modified to specify a
short label.
layout overlay / cycleattrs=true
    yaxisopts=(label="Growth of Virus and Bacteria Cultures"
      shortlabel="Growth" );
  seriesplot x=Hours y=Bacteria/ curvelabel="Bacteria"; 
  seriesplot x=Hours y=Virus / curvelabel="Virus";
endlayout;
Because the specified label does not fit the allotted space, the short label is used instead.
Instead of a short label, you can enable label splitting, which automatically splits the axis
label into multiple lines. To enable label splitting, set LABELFITPOLICY= to SPLIT or
SPLITALWAYS. The SPLIT policy splits the label into multiple lines as needed to
make it fit in the available space. The SPLITALWAYS policy always splits the label
into multiple lines regardless of the available space. By default, the label is split on a
blank space.
Note: The SHORTLABEL= option is ignored when LABELFITPOLICY= is set to
SPLIT or SPLITALWAYS.
Default Axis Construction and Related Options
75

When LABELFITPOLICY= is set to SPLIT, by default, the label is split on a blank
space only where a split is needed to make the label fit. When this option is set to
SPLITALWAYS, the label is split on every occurrence of a blank space in the label. If
you want to split the label on a character other than a blank space, use the
LABELSPLITCHAR= option to specify one or more characters on which to split the
label. The list must be specified as a quoted string with no space between the characters.
The characters are case sensitive, and order is not significant. For example, to split a
label on a blank space, a comma, or a semicolon, specify:
labelsplitchar=" ,;"
A split character on which a split occurs is removed from the displayed label by default.
A split character on which a split does not occur remains in the displayed label. If you
want all of the split characters to remain in the displayed label, use the
LABELSPLITCHARDROP=FALSE option.
Each line of a split label is centered in the allotted space by default. You can use the
LABELSPLITJUSTIFY= option to justify each line of the label left or right for the X
and X2 axes, or top or bottom for the Y and Y2 axes.
Here is the previous example modified to use label splitting instead of a short label for
the Y axis label.
layout overlay / cycleattrs=true
  yaxisopts=(label="Growth of Virus and Bacteria Cultures"
    labelfitpolicy=split);                             
  seriesplot x=Hours y=Bacteria/ curvelabel="Bacteria"; 
  seriesplot x=Hours y=Virus / curvelabel="Virus";     
endlayout;
In this example, the SPLIT policy is used, which splits the label on a blank space only
where needed. In this case, only one split is needed after “and.” If the SPLITALWAYS
policy is used instead, the label is split on every occurrence of a blank space as shown in
the following figure.
76
Chapter 5
•
Managing Axes in an OVERLAY Layout

Positioning the Labels
By default, axis labels are centered in the axis area as shown in Figure 5.1 on page 73.
You can use the LABELPOSITION= option to change the position of the axis labels for
the OVERLAY, DATALATTICE, DATAPANEL, and LATTICE layouts. For the
OVERLAY, DATALATTICE, and DATAPANEL layouts, you can specify one of the
following values for LABELPOSITION=:
CENTER
centers the axis label in the axis area (default).
DATACENTER
for OVERLAY layouts, centers the axis label in the axis tick
display area. For DATALATTICE and DATAPANEL layouts,
this value repeats the axis label for each row or column and
centers each label in the axis tick display area of its row or
column.
TOP or BOTTOM
orients the label horizontally at the top or bottom of the axis
area.
LEFT or RIGHT
positions the label to the left or right of the axis area.
For the LATTICE layout, you can specify one of the following values for
LABELPOSITION=:
CENTER
centers the axis label in the axis area (default).
DATACENTER
centers each row or column axis label in its axis tick display
area.
In the following example, the Y-axis label is positioned at the top of the axis area, and
the X-axis label is positioned to the right of the axis area in an OVERLAY layout.
layout overlay / cycleattrs=true
  xaxisopts=(labelposition=right)
  yaxisopts=(labelposition=top);
  seriesplot x=Hours y=Bacteria/ curvelabel="Bacteria"; 
  seriesplot x=Hours y=Virus / curvelabel="Virus" primary=true;     
endlayout;
Default Axis Construction and Related Options
77

Using the LABELPOSITION= option can result in axis label collisions in some cases.
For example, in the previous example, if LABELPOSITION=BOTTOM is used for the
Y axis and LABELPOSITION=LEFT is used for the X axis, the axis labels collide.
When you select a position, make sure that it does not collide with any other labels.
Determine Axis Tick Values
The tick values for LINEAR and TIME axes are calculated according to an internal
algorithm that produces good tick values by default. This algorithm can be modified or
bypassed with axis options. For examples, see “LINEAR Axes” on page 84,
“DISCRETE Axes” on page 89, and “LOG Axes” on page 102.
By default, the font characteristics of the tick values are set by the current style, and the
tick mark values progress along the axis from the least value to the highest value. You
can set alternative font characteristics with the TICKVALUEATTRS= option. For more
information, see “Axis Appearance Features Controlled by the Current Style” on page
109.
Note: For large tick values on a linear axis, you can specify a scale for the values to
save space. See “Scaling Tick Values” on page 87.
Apply Axis Thresholds
For LINEAR and LOG axes only, part of the default axis construction computes a small
number of "good" tick values for the axis. This list might include "encompassing" tick
values that go beyond the data range on both the lower or upper side of the axis. The
THRESHOLDMIN= and THRESHOLDMAX= options of LINEAROPTS = ( ) can be
used to establish rules for when to add encompassing tick marks. In the following
example, the data range is 5 to 47. When the THRESHOLDMIN=0 and
THRESHOLDMAX=0, the lowest and highest tick marks are always at or inside the
data range. Notice that the lowest tick mark is 10 and the highest tick mark is 40.
78
Chapter 5
•
Managing Axes in an OVERLAY Layout

When the THRESHOLDMIN=1 and THRESHOLDMAX=1, the lowest and highest tick
marks are always at or outside the data range. Notice that the lowest tick mark is 0 and
the highest tick mark is 50.
When the thresholds are set to any value between 0 and 1, a computation is performed to
determine whether an encompassing tick is added. The default value for both thresholds
is .3. Notice that the highest tick mark is 50 and the lowest tick mark is 10. In this case,
an encompassing tick was added for the highest tick but not for the lowest tick.
At the high end of the axis, there is a tick mark at 40. The THRESHOLDMAX= option
determines whether a tick mark should be displayed at 50. The threshold distance is
calculated by multiplying the THRESHOLDMAX= value (0.3) by the tick interval value
(10), which equals 3. Measuring the threshold distance 3 down from 50 yields 47, so if
the highest data value is between 47 and 50, a tick mark is displayed at 50. In this case,
the highest data value is 47 and it is within the threshold, so the tick mark at 50 is
displayed.
At the low end of the axis, there is a tick mark at 10. The THRESHOLDMIN= option
determines whether a tick mark should be displayed at 0. The threshold distance is
calculated by multiplying the THRESHOLDMIN= value (0.3) by the tick interval value
Default Axis Construction and Related Options
79

(10), which equals 3. Measuring the threshold distance of 3 up from 0 yields 3, so if the
lowest data value is between 0 and 3, a tick mark is displayed at 0. In this case, the
lowest data value is 5 and it is not within this threshold, so the tick mark at 0 is not
displayed.
Thresholds are important when you want the Y and Y2 (or X and X2) axes to have ticks
marks located at equivalent locations on different scales. By preventing "encompassing"
ticks from being drawn, you can ensure that the axis ranges for the two axes correctly
align. The following example accepts the default minimum and maximum data values
for each axis. Notice that the five scatter points for each plot are superimposed exactly.
layout overlay /
  yaxisopts=(griddisplay=on
             linearopts=(integer=true thresholdmin=0 thresholdmax=0 ))
  y2axisopts=(linearopts=(integer=true thresholdmin=0 thresholdmax=0 ));
 scatterplot  x=city y=fahrenheit;
 scatterplot  x=city y=celsius / yaxis=y2;
endlayout;
In the following example, the axes have different but equivalent ranges that are
established with the VIEWMIN= and VIEWMAX= options (32F <==> 0C and 86F
<==> 30C).
layout overlay /
    yaxisopts= (griddisplay=on
                linearopts=(integer=true thresholdmin=0 thresholdmax=0
                            viewmin=32 viewmax=86 ))
    y2axisopts= (linearopts=(integer=true thresholdmin=0 thresholdmax=0
                             viewmin=0 viewmax=30 ));
  scatterplot  x=City y=Fahrenheit;
  scatterplot  x=City y=Celsius / yaxis=y2;
endlayout;
80
Chapter 5
•
Managing Axes in an OVERLAY Layout

This next example creates equivalent ticks for a computed histogram. We want to ensure
that the percentage and actual count correspond on the Y and Y2 axes.
layout overlay / yaxisopts=(linearopts=( thresholdmin=0 thresholdmax=0 ))
    y2axisopts=(linearopts=( thresholdmin=0 thresholdmax=0 ));
  histogram mrw  / scale=percent;
  histogram mrw  / scale=count yaxis=y2; 
endlayout;
Apply Axis Offsets
In addition to axis thresholds, there are also axis offsets. Offsets are small gaps that are
potentially added to each end of an axis: before the start of the data range and after the
end of the data range. Offsets can be applied to any type of axis. For example, axis
offsets are automatically added to allow for markers to appear at the first or last tick
without clipping the marker
Default Axis Construction and Related Options
81

For plots such as box plots, histograms, and bar charts, offset space is added to ensure
that the first and last box or bar is not clipped.
The OFFSETMIN= option on a layout statement controls the distance from the
beginning of the axis to the first tick mark (or minimum data value). The
OFFSETMAX= option controls the distance between last tick (or maximum data value)
and the end of the axis. Both OFFSETMIN= and OFFSETMAX= can be set to AUTO,
AUTOCOMPRESS, or a numeric range. The default offset is AUTO. AUTO
automatically provides enough offset to display markers and other graphical features.
AUTOCOMPRESS provides enough offset to keep the minimum and maximum tick
marks from extending beyond the axis length. The numeric range is a value from 0 to 1
that is used to calculate the offset as a percentage of the full axis length.
For some plots, the axis offsets are not desirable. To illustrate this, consider the contour
plot below. Notice that the entire plot area between minimum and maximum data values
is filled with colors that correspond to a Z value. The narrow white bands around the top
82
Chapter 5
•
Managing Axes in an OVERLAY Layout

and right edges of the filled area and the axis wall boundaries are due to the default axis
offsets.
layout overlay;  
  contourplotparm x=height y=weight z=density;
endlayout;
To eliminate the "extra" gaps at the ends of the axes, we can set axis offsets and
thresholds to zero. An offset is a value between 0 and 1 that represents a percentage of
the length of the axis.
layout overlay / xaxisopts=( offsetmin=0 offsetmax=0
                   linearopts=( thresholdmin=0 thresholdmax=0 ))
                 yaxisopts=( offsetmax=0 offsetmax=0
                   linearopts=( thresholdmin=0 thresholdmax=0 ));
  contourplotparm x=height y=weight z=density;
endlayout;
Default Axis Construction and Related Options
83

LINEAR Axes
Setting the Axis Data Range and Tick Values
For a LINEAR axis, you can set the tick values in several ways. If you use
TICKVALUELIST= (values) or TICKVALUESEQUENCE=(start end increment)
syntax, the values that you specify are used as long as those values are within the actual
range of the data. To extend (or reduce) the axis data range, you can use the VIEWMIN=
and VIEWMAX= suboptions of the LINEAROPTS= option. You can also use the
TICKVALUEPRIORITY=TRUE option, which automatically extends the axis range to
accommodate the values specified by the TICKVALUELIST= or
TICKVALUESEQUENCE= option.
Here is an example that uses the TICKVALUELIST= option to specify the tick values. It
uses the VIEWMIN= and VIEWMAX= options to extend the axis range to include the
specified values.
proc template;
   define statgraph heightchart;
      begingraph;
         entrytitle "Specifying Tick Values for Linear Axes";
         layout overlay /
            xaxisopts=(type=linear griddisplay=on
               gridattrs=(pattern=dot color=lightgray)
               linearopts=(minorticks=true))
            yaxisopts=(type=linear tickvaluehalign=left
               griddisplay=on gridattrs=(pattern=dot color=lightgray)
               linearopts=(viewmin=48 viewmax=78
                  tickvaluelist=(48 54 60 66 72 78)
                  minorticks=true));
            scatterplot x=weight y=height;
         endlayout;
      endgraph;
   end;
run;
proc sgrender data=sashelp.class template=heightchart;
run;
84
Chapter 5
•
Managing Axes in an OVERLAY Layout

Here is the output for this example.
With this method, if you change the values specified by the TICKVALUELIST= option,
you might have to change the VIEWMIN= and VIEWMAX= option values to
accommodate the new values. If you use the TICKVALUEPRIORITY=TRUE option
instead of the VIEWMIN= and VIEWMAX= options, the axis range is adjusted
automatically.
When you use the TICKVALUELIST= option, you can use the
TICKVALUEDISPLAYLIST= option to specify string values to display on the axis
instead of the specified tick values. You must specify the TICKVALUELIST= option in
order to use the TICKVALUEDISPLAYLIST= option. The string values specified by
the TICKVALUEDISPLAYLIST= option map one-to-one positionally to the values
specified by the TICKVALUELIST=. Thus, the number of string values that you specify
in the TICKVALUEDISPLAYLIST= option must exactly match the number of values
that you specify in the TICKVALUELIST= option. If you specify too many display
values, the excess values are ignored. If you specify too few, blank tick values result on
the axis.
Here is the previous example modified to use the TICKVALUEDISPLAYLIST= option
to display the height values in feet on the Y axis.
proc template;
   define statgraph heightchart;
      begingraph;
         entrytitle "Specifying Tick Display Values for Linear Axes";
         layout overlay /
            xaxisopts=(type=linear griddisplay=on
               gridattrs=(pattern=dot color=lightgray)
               linearopts=(minorticks=true))
            yaxisopts=(type=linear tickvaluehalign=left
               griddisplay=on gridattrs=(pattern=dot color=lightgray)
               linearopts=(tickvaluepriority=true minorticks=true
                  tickvaluelist=(48 54 60 66 72 78)
                  tickdisplaylist=("4 ft" "4.5 ft" "5 ft" "5.5 ft"
                     "6 ft" "6.5 ft")));
            scatterplot x=weight y=height;
         endlayout;
      endgraph;
   end;
run;
LINEAR Axes
85

proc sgrender data=sashelp.class template=heightchart;
run;
Notice that the TICKVALUELIST= and TICKVALUEDISPLAYLIST= options specify
the same number of values. Notice also that the values map positionally.
Here is the output for this example.
Formatting Axis Tick Values
Linear axes use special techniques that provide the generation of "good" tick values that
are based on the data range. If a tick value format is not specified, the column formats
provide a "hint" on how to represent the tick values, but those formats do not generally
control the representation or precision of the tick values.
To force a given format to be used for a linear axis, you can use syntax similar to the
following, where you specify any SAS numeric format:
    linearopts=(tickvalueFormat= best6. )
Note: GTL currently honors most but not every SAS format. For a list of supported
formats, see Appendix 5, “SAS Formats Not Supported,” on page 503.
If you simply want the column format of the input data column to be directly used,
specify the following:
    linearopts=(tickvalueFormat=data)
There are special options to control tick values. INTEGER=TRUE calculates good
integers to use as tick values given the range of the data.
Here is an example that overrides the dollar format on column Close in Sashelp.Stocks
with a decimal format.
proc template;
  define statgraph barchart;
    begingraph;
      entrytitle "Monthly Stock Performance in 2001";
      layout overlay /
        xaxisopts=(griddisplay=on gridattrs=(pattern=dot)
           timeopts=(tickvalueformat=monname3. viewmax='01DEC2001'd))
        yaxisopts=(griddisplay=on gridattrs=(pattern=dot)
           label="Closing Value (U.S. Dollars)"
           linearopts=(tickvalueformat=5.0));
86
Chapter 5
•
Managing Axes in an OVERLAY Layout

        seriesplot x=date y=close / name="scatter"
           display=all group=stock groupdisplay=cluster;
        discretelegend "scatter";
      endlayout;
    endgraph;
  end;
proc sgrender data=sashelp.stocks template=barchart;
   where year(date) = 2001;
run;
Scaling Tick Values
For large tick values on linear axes, you can specify a tick value scale in order to save
space. This feature applies to linear axes only. You can use a named scale such as
millions, billions, or trillions, or a scientific notation scale expressed as 10^n. To extract
a scale automatically from the tick values, include the EXTRACTSCALE=TRUE option
in the TICKVALUEFORMAT= option list. By default, for tick values of 999 trillion or
less, a named scale is used. For values over 999 trillion, a scientific notation scale is
used. For large tick values, the scale factor is set to ensure that the absolute value of the
largest value is greater than 1. For small fractional tick values, the scale factor is set to
ensure that the absolute value of the smallest value is greater than 1.
Note: The scale that is extracted by the EXTRACTSCALE= option is derived from the
English locale.
To specify a scientific notation scale for values less than 999 trillion, include the
EXTRACTSCALETYPE=SCIENTIFIC option in the TICKVALUEFORMAT= option
list. The scale that is used is appended to the axis label.
Here is an example that specifies the default scale for the growth example that is shown
in “Making Long Axis Labels Fit” on page 74.
layout overlay / cycleattrs=true
  yaxisopts=(label="Growth of Virus and Bacteria Cultures"
    shortlabel="Growth" linearopts=(tickvalueformat=(extractscale=true)));               
  seriesplot x=Hours y=Bacteria/ curvelabel="Bacteria"; 
LINEAR Axes
87

  seriesplot x=Hours y=Virus / curvelabel="Virus";     
endlayout;
Notice that the tick value scale name is automatically appended to the axis label, which
is the short label in this case.
Avoiding Tick Value Collisions
When the tick value text becomes too crowded, the tick values that are displayed on the
axes are scaled automatically for fit. For example, the axis below comfortably shows
eleven tick values:
If the size of the graph decreases or the font size for the tick values increases, the axis
ticks and tick values are automatically "thinned" by removing alternating ticks and tick
values. LINEAROPTS = (TICKVALUEFITPOLICY=THIN) is the default action for
linear axes:
For the X and X2 axes only, you can set TICKVALUEFITPOLICY=ROTATE or
TICKVALUEFITPOLICY=ROTATEALWAYS, which angles the tick value text 45
degrees by default:
88
Chapter 5
•
Managing Axes in an OVERLAY Layout

When you set TICKVALUEFITPOLICY=ROTATE or
TICKVALUEFITPOLICY=ROTATEALWAYS, you can set
TICKVALUEROTATION=VERTICAL to rotate the tick value text vertically instead of
diagonally:
Note: When the tick values are rotated vertically, they read from bottom up as shown.
Note: The ROTATE and ROTATEALWAYS policies, and the
TICKVALUEROTATION= option apply to the X and X2 axes only.
You can set TICKVALUEFITPOLICY=STAGGER, which creates alternating tick
values on two rows.
For the X and X2 axes, you can set TICKVALUEFITPOLICY to a compound policy
ROTATETHIN, STAGGERTHIN, or STAGGERROTATE. The compound policies
attempt the second policy if the first policy does not work. For the Y and Y2 axes, you
can set TICKVALUEFITPOLICY to NONE or THIN. For information about the tick
value fit policies that can be used with a linear axis in each of the applicable layouts, see
Appendix 4, “Tick Value Fit Policy Applicability,” on page 499.
DISCRETE Axes
Setting the Axis Tick Values
For a DISCRETE axis, you can include the TICKVALUELIST=(values) option in the
DISCRETEOPTS= list to set the axis tick values. The TICKVALUELIST= option
enables you to subset the tick values and to display the values in a specific order. The
values that you use with the TICKVALUELIST= option must be within the actual data
range and they must correspond to the formatted values of the data. Here is an example
of a template that uses the TICKVALUELIST= option to display the first six months of
annual failure data.
/* Create a test data set of annual failure data */
data failrate;
  do month=1 to 12 by 1; 
    failures=2*ranuni(ranuni(12345));
    label failures="Failure Rate (% of Units Produced)";
    output;
  end;
run;
DISCRETE Axes
89

/* Create a template to display the first six months of data */
proc template;
 define statgraph firsthalf;
  begingraph;
  entrytitle "Unit Failure Rate in First Half";
   layout overlay / 
      xaxisopts=(
         discreteopts=(tickvaluelist=("1" "2" "3" "4" "5" "6")));
    barchart category=month response=failures; 
   endlayout;
   endgraph;
 end;
run;
/* Plot the data */
proc sgrender data=failrate template=firsthalf;
run;
Note: This graph can also be accomplished by subsetting the data.
By default, the tick marks appear on the midpoints. You can include the
TICKTYPE=INBETWEEN option in the DISCRETEOPTS= option list to position the
tick marks between the midpoints instead of on the midpoints.
Avoiding Tick Value Collisions
Fit Policies for Discrete Axes
To avoid tick-value collisions, a DISCRETE axis uses several of the fit policies that a
LINEAR axis uses. These policies include THIN, ROTATE, ROTATEALWAYS,
STAGGER, ROTATETHIN, STAGGERTHIN, and STAGGERROTATE. For
information about these policies, see “Avoiding Tick Value Collisions” on page 88. A
DISCRETE axis supports additional fit policies that enable you to:
•
extract the axis values into a legend: EXTRACT and EXTRACTALWAYS. See
“Extracting Tick Values into a Legend” on page 90.
•
split the axis values into two or more lines: SPLIT and SPLITALWAYS. See
“Splitting the Tick Values” on page 92.
•
truncate the axis values: TRUNCATE. See “Truncating the Tick Values” on page
93.
A DISCRETE axis also supports the following additional compound fit policies:
ROTATEALWAYSDROP
SPLITTHIN
TRUNCATESTAGGER
SPLITALWAYSTHIN
STAGGERTRUNCATE
TRUNCATETHIN
SPLITROTATE
TRUNCATEROTATE
Extracting Tick Values into a Legend
For a large number of tick values, you can set TICKVALUEFITPOLICY=EXTRACT or
TICKVALUEFITPOLICY=EXTRACTALWAYS to move the axis values to an
AXISLEGEND. In that case, on the axis, the values are replaced with consecutive
integers, and an AXISLEGEND is added that cross references the integer values on the
axis to the actual axis values.
90
Chapter 5
•
Managing Axes in an OVERLAY Layout

Note: If the axis type is not DISCRETE, the TICKVALUEFITPOLICY=EXTRACT
and TICKVALUEFITPOLICY=EXTRACTALWAYS options are ignored.
When you set TICKVALUEFITPOLICY to EXTRACT or EXTRACTALWAYS, you
must also include the NAME= option in your axis option list and an AXISLEGEND
“name” statement in your layout block. In the AXISLEGEND statement, you must set
name to the value that you specified with the NAME= option in the axis options list.
Here is an example.
proc template;
define statgraph discretefitpolicyextract;
begingraph / border=false designwidth=450px designheight=400px;
entrytitle "Average MPG City by Make: Trucks";
Layout overlay /
    yaxisopts=(label="Average MPG")
    xaxisopts=(label="Make"
       name="axisvalues"
       tickvalueattrs=(size=9pt)
       discreteopts=(tickvaluefitpolicy=extract));
    barchart category=make response=mpg_city/orient=vertical stat=mean; 
    axislegend "axisvalues" / pad=(top=5 bottom=5) title="Makes";
endlayout;
endgraph;
end;
run;
proc sgrender data=sashelp.cars template=discretefitpolicyextract;
   where type="Truck";
run;
The following figure shows the resulting graph.
In this example, the name AXISVALUES is used to associate the AXISLEGEND
statement with the X axis. The graph size is set to 450 pixels wide by 400 pixels high.
DISCRETE Axes
91

Since there is not enough room on the X axis to fit the make names, the names are
extracted to an axis legend as shown.
In most cases, the EXTRACT policy moves the axis values to an axis legend only if a
collision occurs. If no collision occurs, the values are displayed on the axis in the normal
manner. In this example, if you increase the width of the graph to 650 pixels and rerun
the program, the legend disappears. In contrast, the EXTRACTALWAYS policy moves
the axis values to a legend regardless of whether a collision occurs.
Note: With the exception of TICKVALUEFITPOLICY=EXTRACTALWAYS, the
TICKVALUEFITPOLICY= is never applied unless a tick value collision situation is
present. That is, you cannot force tick values to be rotated, staggered, or moved to an
axis legend if there is no collision situation.
For information about the tick value fit policies that can be used with a discrete axis in
each of the applicable layouts, see Appendix 4, “Tick Value Fit Policy Applicability,” on
page 499.
Splitting the Tick Values
For long tick values, you can set the TICKVALUEFITPOLICY= option to SPLIT to
split the tick values, when necessary, to make them fit the available space. You can set
this option to SPLITALWAYS to always split the tick values regardless of the available
space. For the X and X2 axes, the amount of available space is the width allocated to
each midpoint value. For the Y and Y2 axes, it is the width allocated to the axis.
By default, the tick values are split at a blank space that occurs where a split is needed.
The value is split until the label is successfully fitted or no more blank spaces exist in the
value string. Each blank space on which a split occurs is dropped from the displayed
value. Blank spaces on which a split does not occur are retained in the displayed value.
Each line of the value is centered in the available space.
If you want to split the values on a character other than a blank space or on more than
one character, you can use the TICKVALUESPLITCHAR= option to specify a list of
one or more split characters. You must specify the list as a quoted string with no space
between the characters. The characters are case sensitive, and order is not significant.
For example, to split a tick value on a blank space, a comma, or a semicolon, specify:
tickvaluesplitchar=" ,;"
When you specify multiple characters, each character in the list is treated as a separate
split character unless they appear consecutively in the tick value. In that case, all of the
characters together are treated as a single split character.
If you want to change the justification of each split line from CENTER, you can use the
TICKVALUESPLITJUSTIFY= option to specify LEFT or RIGHT instead.
For example, consider the following axis values:
Davidson, Richard
Johnston, Miranda
McMillian, Joseph
Robertson, Mary Ann
Stenovich, Timothy
Notice that the last and first names are separated by a comma followed by a space. This
example will make the following changes:
•
split the last and first names into two lines
•
left-justify both lines
92
Chapter 5
•
Managing Axes in an OVERLAY Layout

•
retain the comma between the last and first names
•
discard the space that occurs after the comma
You can use the TICKVALUEFITPOLICY=SPLIT option to split the values on the
space and discard the space by default. However, to left-justify the names, we must
specify the TICKVALUESPLITJUSTIFY=LEFT option. The following figure shows the
result.
Notice that the value Robertson, Mary Ann splits only once even though there are two
occurrences of the split character in the value. By default, a split occurs on a split
character only if a split is needed at that character to fit the label. In this case, because a
split is not needed at the second blank character, it remains in the displayed value. If you
want to force a split at every occurrence of a split character, use the
TICKVALUEFITPOLICY=SPLITALWAYS option. In that case, the value Robertson,
Mary Ann, splits into three left-justified lines.
If you want to keep the split characters in the tick values, use the
TICKVALUESPLITCHARDROP=FALSE option. In that case, where each split occurs,
the split character remains as the last character in the current line, and the characters that
follow wrap to the new line.
The compound policies SPLITTHIN and SPLITALWAYSTHIN apply the split policy
first, and then apply the thin policy if the split policy does not work.
Truncating the Tick Values
You can set TICKVALUEFITPOLICY=TRUNCATE to shorten the tick values. Axis
values that are greater than 12 characters in length are truncated to 12 characters.
Ellipses are added to the end of the truncated values to indicate that truncation has
occurred. When there is sufficient room on the axis to fit the full axis values, no
truncation occurs. For example, suppose that we decide to truncate the values from the
previous example rather than split them. If we specify the
TICKVALUEFITPOLICY=TRUNCATE option and remove the
TICKVALUESPLITJUSTIFY=LEFT option, the values are truncated as shown in the
following figure.
The compound policies STAGGERTRUNCATE, TRUNCATEROTATE,
TRUNCATESTAGGER, and TRUNCATETHIN apply the first fit policy, and then
apply the second fit policy if the first policy does not work.
DISCRETE Axes
93

Setting Alternating Wall Color Bands for Discrete Intervals
For a discrete axis, you can use the COLORBANDS= option in your DISCRETEOPTS=
option list to specify alternating wall color bands for each of the discrete axis intervals.
The alternating bands can help improve the readability of complex plots. You can
specify attributes for the odd or even bands. The odd bands begin with the first axis
interval. The even bands begin with the second interval.
Note: If you specify the COLORBANDS option for more than one axis, such as both
the X and Y axes, in an overlay, you might get unexpected results.
Include the COLORBANDSATTRS= option in your DISCRETEOPTS= option list to
specify the fill color and transparency of the bars. You can specify either a style element
or a list of fill options. If you specify fill options, you must enclose the options in
parenthesis.
T I P
You can add a border around the color bands by including the
TICKTYPE=INBETWEEN option in the DISCRETEOPTS= option list and the
GRIDDISPLAY=ON and GRIDATTRS= options in the XAXISOPTIONS= or
YAXISOPTIONS= options list.
Here is an example that adds alternating light-gray color bands to the discrete Y axis of a
plot. The bands begin on the second (even) interval.
proc template;
  define statgraph colorbands;
    begingraph;
      entrytitle "MPG City - European Makes";
      layout overlay / 
        xaxisopts=(griddisplay=on)
        yaxisopts=(type=discrete offsetmin=0.07 offsetmax=0.07 
           discreteopts=(colorbands=EVEN
              colorbandsattrs=(transparency=0.6 color=lightgray)));
        scatterplot y=make x=mpg_city / name="sp"
           group=type groupdisplay=cluster;
        discretelegend "sp" / title="Vehicle Type";
      endlayout;
    endgraph;
  end;
run;
proc sgrender data=sashelp.cars template=colorbands;
   where origin="Europe";
run;
The following figure shows the resulting plot.
94
Chapter 5
•
Managing Axes in an OVERLAY Layout

Offsetting Graph Elements from the Category Midpoint
When you overlay plots that support discrete data, you can use the
DISCRETEOFFSET= option to offset the graph elements from the midpoints on the
discrete axis. Plots that support discrete data on one axis include:
BARCHART
BOXPLOTPARM
SCATTERPLOT
BARCHARTPARM
SERIESPLOT
DROPLINE
BOXPLOT
STEPPLOT
By default, the graph elements, such as bars or markers, are positioned on the midpoint
tick marks as shown in the following example. In this example, three bar charts are
drawn using transparency and varying bar widths so that you can see how the bars are
overlaid. The DATATRANSPARENCY= option is used to control the transparency, and
the BARWIDTH= option is used to control the bar widths.
DISCRETE Axes
95

Instead of overlaying the bars on each tick mark, you can use the DISCRETEOFFSET=
and BARWIDTH= options in the plot statement to move the bars away from the
midpoint and size them to form a cluster of side-by-side bars or overlapped bars on each
tick mark. The DISCRETEOFFSET= option can be set to a value ranging from –0.5 to
0.5. The value specifies the offset as a percentage of the distance between the midpoints
on the axis. Here is the previous example modified to use the DISCRETEOFFSET= and
BARWIDTH= options to form a cluster of side-by-side bars around each tick mark on
the X axis.
Here is the code that generates this graph.
/* Extract the sales data for each country from SASHELP.PRDSALE. */
data sales;
   set sashelp.prdsale(keep=country actual product);
   if (country eq "CANADA") then canada=actual;
   else if (country eq "GERMANY") then germany=actual;
   else if (country eq "U.S.A.") then usa=actual;
96
Chapter 5
•
Managing Axes in an OVERLAY Layout

run;
/* Create the graph template. */
proc template;
   define statgraph offset;
      begingraph;
      entrytitle "Product Sales by Country";
      layout overlay / cycleattrs=true
         xaxisopts=(display=(tickvalues)) yaxisopts=(label="Sales");
         barchart category=product response=canada / stat=sum name="canada"
            legendlabel="Canada" dataskin=sheen datatransparency=0.1
            barwidth=0.25 discreteoffset=-0.25;
         barchart category=product response=germany / stat=sum name="germany"
            legendlabel="Germany" dataskin=sheen datatransparency=0.1
            barwidth=0.25;
         barchart category=product response=usa / stat=sum name="usa"
            legendlabel="U.S.A." dataskin=sheen datatransparency=0.1
            barwidth=0.25 discreteoffset=0.25;
         discretelegend "canada" "germany" "usa" / title="Country:"
            location=outside;
      endlayout;
      endgraph;
   end;
run;
/* Generate the graph. */
proc sgrender data=sales template=offset;
run;
In this example, the DISCRETEOFFSET=–0.25 option in the first BARCHART
statement moves its bars to the left of each tick mark by 25% of the distance between the
tick marks. The second BARCHART statement uses the default offset (0), which
positions its bars on the tick marks. The DISCRETEOFFSET=0.25 option on the third
BARCHART statement positions its bars to the right of each tick mark by 25% of the
distance between the tick marks. The BARWIDTH=0.25 option in each of the
BARCHART statements sizes the bars to form a cluster with no space between the bars
as shown. You can adjust the DISCRETEOFFSET= and BARWIDTH= option values to
overlap the bars or add space between the bars in each cluster as desired.
TIME Axes
Overview of TIME Axes
TIME axes are numeric axes that display SAS date or time values in an intelligent way.
Such axes are created whenever the primary plot has a SAS date, time, or datetime
format associated with a column that is mapped to an axis. In the following example, the
Date column has a SAS date format associated with it. By default, the TIME axis
decides an appropriate tick value format and an interval to display. Notice that, in the
default case, when the X or X2 axis is a TIME axis, the space that is used for the tick
values is conserved by splitting the values at appropriate date or time intervals and
extracting larger intervals. In this example, the column format for the Date column could
be MMDDYY or any other date-type format. The actual format serves only as a hint and
is not used directly, unless requested.
TIME Axes
97

layout overlay; 
  seriesplot x=date y=close;
endlayout;
Note: In this example, the data range for DATE was from 1Jan2004 to 1Dec2005. The
TIME axis chose the interval of MONTH to display tick values. Had the data range
been larger, say 1Jan1998 to 1Dec2005, the TIME axis would choose a larger
interval, YEAR, to display by default.
Setting the Tick Values
You can use the INTERVAL= option to select different date or time intervals to display.
The default interval is AUTO, which chooses an appropriate interval, based on the data
and the column format.
Value on
INTERVAL=
Unit
Tick Interval
Default Tick Value
Format
AUTO
DATE, TIME, or
DATETIME
automatically chosen
automatically chosen
SECOND
TIME or
DATETIME
second
TIME8.
MINUTE
TIME or
DATETIME
minute
TIME8.
HOUR
TIME or
DATETIME
hour
TIME8.
DAY
DATE or
DATETIME
day
TIME9.
TENDAY
DATE or
DATETIME
ten days
TIME9.
WEEK
DATE or
DATETIME
seven days
TIME9.
98
Chapter 5
•
Managing Axes in an OVERLAY Layout

Value on
INTERVAL=
Unit
Tick Interval
Default Tick Value
Format
SEMIMONTH
DATE or
DATETIME
1st and 16th of each
month
TIME9.
MONTH
DATE or
DATETIME
month
MONYY7.
QUARTER
DATE or
DATETIME
three months
YYQC6.
SEMIYEAR
DATE or
DATETIME
six months
MONYY7.
YEAR
DATE or
DATETIME
year
YEAR4.
The following example specifies that tick values should occur at quarter intervals:
layout overlay / xaxisopts=( timeopts=(interval=quarter) );
By default, the tick values are split to conserve space when possible. The following table
shows the rules for splitting tick value.
Original Form
Split Form
DAY-MONTH-YEAR
DAY-MONTH
YEAR
QUARTER-YEAR
QUARTER
YEAR
MONTH-YEAR
MONTH
YEAR
TIME-DATE
TIME
DATE
TIME Axes
99

Original Form
Split Form
TIME only
original form
YEAR, QUARTER, MONTH, or DAY only
original form
International format
original form
You can turn off the splitting feature with the SPLITTICKVALUE=FALSE option.
Notice that each tick value uses more space.
layout overlay / xaxisopts=(timeopts=(interval=quarter
                                      splittickvalue=false ));
Formatting Axis Tick Values
As with LINEAR axes, you can force a specific format for tick values with the
TICKVALUEFORMAT= option, which also turns off the tick splitting feature. If you
specify TICKVALUEFORMAT=DATA, the format is associated with the column that is
used. Or you can specify a format:
layout overlay / xaxisopts=(timeopts=(interval=semiyear
                                      tickvalueformat=monyy. ));
100
Chapter 5
•
Managing Axes in an OVERLAY Layout

Avoiding Tick Value Collisions
As with LINEAR axes, you can specify a tick value fitting policy for a TIME axis. The
following policies are available: THIN, ROTATE, ROTATEALWAYS, STAGGER,
ROTATETHIN, STAGGERTHIN, and STAGGERROTATE when tick values are not
split. The default policy is THIN .
layout overlay / xaxisopts=(timeopts=(interval=month 
                                      splittickvalue=false
                                      tickvaluefitpolicy=rotate ));
For information about the tick value fit policies that can be used with a time axis in each
of the applicable layouts, see Appendix 4, “Tick Value Fit Policy Applicability,” on
page 499.
Setting the Axis Data Range
As with LINEAR axes, you can force specific tick values to be displayed with the
TICKVALUELIST= option. The VIEWMIN= and VIEWMAX= options control the
data range of the axis. If you specify TICKVALUEFORMAT=DATA, the format that is
associated with the column is used.
layout overlay / xaxisopts=(timeopts=( tickvalueformat=data
  viewmin="31Dec2002"d viewmax="31Dec2004"d
  tickvaluelist=("31Dec2002"d "30Jun2003"d
                 "31Dec2003"d "30Jun2004"d "31Dec2004"d) ));
TIME Axes
101

LOG Axes
Overview of LOG Axes
An axis displaying a logarithmic scale is very useful when your data values span orders
of magnitude. For example, when you plot your growth data with a linear axis, you
suspect that the growth rate is exponential.
layout overlay;
  seriesplot x=Hours y=Growth;
endlayout;
To confirm this, you can request a log axis, which is never drawn by default. Instead,
you must request it with the TYPE=LOG axis option. Any of the four axes can be a log
axis.
layout overlay / yaxisopts=(type=log);
The numeric data that is used for a log axis must be positive. If zero or negative values
are encountered, a linear axis is substituted and the following note is written to the log:
102
Chapter 5
•
Managing Axes in an OVERLAY Layout

NOTE: Log axis cannot support zero or negative values in the data range. The 
axis type will
      be changed to LINEAR.
Setting the Log Base
You can show a log axis with any of three bases: 10, 2 and E (natural log). The default
log base is 10. To set another base, use the BASE= suboption setting of the LOGOPTS=
option.
layout overlay / yaxisopts=(type=log logopts=(base=2) );
layout overlay / yaxisopts=(type=log logopts=(base=e) );
Setting the Tick Intervals
Log axes support the TICKINTERVALSTYLE= option, which provides different styles
for displaying tick values:
AUTO
A LOGEXPAND, LOGEXPONENT, or LINEAR representation is chosen
automatically, based on the range of the data. When the data range is small (within
an order of magnitude), a LINEAR representation is typically used. Data ranges that
LOG Axes
103

encompass several orders of magnitude typically use the LOGEXPAND or
LOGEXPONENT representation. AUTO is the default.
LOGEXPAND
Major ticks are placed at uniform intervals at integer powers of the base. By default,
a BEST6. format is applied to BASE=10 and BASE=2 tick values. This means that,
depending on the range of data values, you might see very large or very small values
written in exponential notation (10E6 instead of 1000000). The preceding examples
with a log axis show TICKINTERVALSYTLE=LOGEXPAND.
LOGEXPONENT
Major ticks are placed at uniform intervals at integer powers of the base. The tick
values are only the integer exponents for all bases.
LINEAR
Major tick marks are placed at non-uniform intervals, covering the range of the data.
When using TICKINTERVALSTYLE=LOGEXPONENT, it might not be clear what
base is being used. You should consider adding information to the axis label to clarify
the situation:
layout overlay / yaxisopts=(type=log label="Growth (Powers of 10)"
  logopts=(base=10 tickintervalstyle=logexponent));
When using TICKINTERVALSTYLE=LINEAR, it is visually helpful to turn on the grid
lines:
layout overlay / yaxisopts=(type=log  griddisplay=on
  logopts=(base=10 tickintervalstyle=linear));
104
Chapter 5
•
Managing Axes in an OVERLAY Layout

When using BASE=10 and TICKINTERVALSTYLE=LOGEXPAND or
TICKINTERVALSTYLE=LOGEXPONENT, you can add minor ticks to emphasize the
log scale:
layout overlay / yaxisopts=(type=log griddisplay=on
  logopts=(base=10 tickintervalstyle=linear minorticks=true ));
The data range of a log axis can be set with the VIEWMIN= and VIEWMAX= log
options. It can also be set with the TICKVALUELIST= option when
TICKVALUEPRIORITY=TRUE. See “Setting the Tick Values” on page 105.
If your input data has already been transformed into log values, you should always use a
LINEAR axis to display them, not a LOG axis.
layout overlay;
  seriesplot x=Hours y=eval(log10(growth));
endlayout;
Setting the Tick Values
You can use the TICKVALUELIST=(values) option on a log axis to specify the values
that are to appear on the axis. By default, the values in the list that are within the data
range or the range specified by the VIEWMIN= and VIEWMAX= options are displayed
on the axis. All other values in the list are ignored. If you want the values specified in
the list to take precedence, you can specify the TICKVALUEPRIORITY=TRUE. In that
LOG Axes
105

case, if the values are outside of the data range, the axis range is extended to include all
of the values in the list, and the VIEWMIN= and VIEWMAX= options are ignored.
The following example specifies the values 1, 10, 100, 1000, 10000, and 100000.
Because the data range is 10 to 100000, the TICKVALUEPRIORITY=TRUE option is
specified to extend the lower axis range down to 1.
layout overlay / 
   yaxisopts=(griddisplay=on type=log  
      logopts=(base=10 tickvaluepriority=true
      tickintervalstyle=logexpand
      tickvaluelist=(1 10 100 1000 10000 100000)
      minorticks=true));
   SeriesPlot x=Hours y=growth;
endlayout;
You can use the VALUETYPES= option to specify the TICKVALUELIST= option
values in a scale and format other than that specified by the TICKINVERVALSTYLE=
option. You can also use the VALUETYPES= option to specify VIEWMIN= and
VIEWMAX= values. For example, in the previous example, you can specify
VALUESTYPE=EXPONENT, and then list the TICKVALUELIST= option values as
exponents of 10 rather than expanded values as shown in the following example.
layout overlay / 
   yaxisopts=(griddisplay=on type=log  
      logopts=(base=10 tickvaluepriority=true
      tickintervalstyle=logexpand
      valuestype=exponent
      tickvaluelist=(0 1 2 3 4 5)
      minorticks=true));
   SeriesPlot x=Hours y=growth; 
endlayout;
The resulting graph is the same. This is particularly useful for large axis values. For
more information about using the VALUESTYPE= option, see VALUESTYPE=.
Axis Line versus Wall Outline
The area bounded by the X, Y, X2, and Y2 axes is called the Wall Area or simply the
Wall. The wall consists of a filled area (FILL) and a boundary line (OUTLINE). The
106
Chapter 5
•
Managing Axes in an OVERLAY Layout

display of the Wall is independent of the display of axes. When both are displayed, the
axes are placed on top of the wall outline. Most frequently, your plots use only the X and
Y axes, not X2 or Y2.
By default, you see lines that look like X2 and Y2 axis lines, but they are not axis lines.
They are the lines of the wall outline, which happens to be the same color and thickness
as the axis lines. This can be made apparent by assigning different visual properties to
the wall outline and the axis lines.
The GraphAxisLines style element controls the appearance of all axis lines, and the
GraphWalls style element controls the wall. The following example shows how you can
change the appearance of the axes and wall with a style definition. In the template code,
the PROC TEMPLATE block defines a style named AXIS_WALL, and then the ODS
HTML statements sets the AXIS_WALL style as the active style for output that is
directed to the HTML destination:
proc template ;
 define style axis_wall;
 parent=styles.htmlblue;
 style graphwalls from graphwalls /
   frameborder=on
   linestyle=1
   linethickness=2px
   backgroundcolor=GraphColors("gwalls")
   contrastcolor= orange;
 style graphaxislines from graphaxislines /
   linestyle=1
   linethickness=2px
   contrastcolor=blue;
 end;    
run; 
ods html style=axis_wall ;
If a simple GTL template containing the following layout block is executed while the
AXIS_WALL style is in effect, you would be able to see that the axis lines are distinct
from the wall outlines:
layout overlay / walldisplay=(fill outline); /* default walldisplay */
  scatterplot  x=City y=Fahrenheit / datatransparency=.5;
  entry textattrs=(color=green) "( Wall Area )";
endlayout;
Axis Line versus Wall Outline
107

Most styles set the axis lines and the wall outline to be the same color, line pattern, and
thickness, so it is impossible to see the difference. Sometimes you might not want to see
the wall outline, or you might want to change the wall color. These types of changes can
be set on a style or with the WALLDISPLAY= option on the LAYOUT OVERLAY
statement. For example, the GTL default for the wall is WALLDISPLAY=(FILL
OUTLINE).
The following code fragment shows how to use the style definition to turn off the wall
outline:
    style GraphWalls from GraphWalls /
       frameborder=off;
This next code fragment shows how to use GTL to turn off the wall outline:
    layout overlay / walldisplay=(fill);
108
Chapter 5
•
Managing Axes in an OVERLAY Layout

Axis Appearance Features Controlled by the
Current Style
The appearance of graphs produced with GTL is always affected by the ODS style that is
in effect for the ODS destination. From an axis perspective, the default appearance of the
axis line, ticks, tick values, axis label, and grid lines are controlled by predefined style
elements.
Style Element
Style Attributes
Values
Controls
GraphAxisLines
TickDisplay
"ACROSS"
"INSIDE"
"OUTSIDE"
Tick mark location
LineStyle
Integer: 1 to 49
Axis line pattern
LineThickness
Dimension
Axis line and tick
thickness
ContrastColor
Color
Axis line and tick
color
GraphGridlines
DisplayOpts
"AUTO" "ON"
"OFF"
When to display grid
lines
LineStyle
Integer: 1 to 49
Grid line pattern
LineThickness
Dimension
Grid line thickness
ContrastColor
Color
Grid line color
GraphLabelText
Color
Color
Axis label text color
Font
font-specification*
Axis label font
GraphValueText
Color
Color
Axis tick value text
color
Font
font-specification*
Axis tick value font
* A style font-specification includes attributes for FONTFAMILY, FONTWEIGHT, FONTSTYLE, and
FONTSIZE.
The following GTL axis options also control the appearance of axis features. When you
include these options, the corresponding information from the current style is
overridden.
Option
Overrides ...
GRIDDISPLAY=
DisplayOpts attribute of GraphGridLines
Axis Appearance Features Controlled by the Current Style
109

Option
Overrides ...
GRIDATTRS=
GraphGridLines
LABELATTRS=
GraphLabelText
TICKVALUEATTRS=
GraphValueText
TICKSTYLE=
TickDisplay attribute of GraphAxisLines
Example: Assure that the axis label text appears in bold.
layout overlay / xaxisopts=(labelattrs=(weight=bold))
                 yaxisopts=(labelattrs=(weight=bold));
Example: Display grid lines.
layout overlay / xaxisopts=(griddisplay=on)
                 yaxisopts=(griddisplay=on);
Example: Use a dot pattern for grid lines.
layout overlay / xaxisopts=(griddisplay=on gridattrs=(pattern=dot))
                 yaxisopts=(griddisplay=on gridattrs=(pattern=dot));
Example: Make ticks cross the axes lines.
layout overlay / xaxisopts=(tickstyle=across)
                 yaxisopts=(tickstyle=across);
For all of the preceding examples, you would add similar coding to the X2AXISOPTS=
and Y2AXISOPTS= options if the X2 or Y2 axes are used as independent scales. For
complete documentation on the axis options that are available, see the SAS Graph
Template Language: Reference.
110
Chapter 5
•
Managing Axes in an OVERLAY Layout

Chapter 6
Managing Graph Appearance:
General Principles
Default Appearance Features in Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
Evaluating Supplied Styles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Methods for Changing the Appearance of Your Plots . . . . . . . . . . . . . . . . . . . . . . 116
Options That Override Attributes for Individual Plots . . . . . . . . . . . . . . . . . . . . . 117
Overview of Graphical Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
LINEATTRS Option . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
MARKERATTRS Option . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
TEXTATTRS Option . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
Appearance of Non-grouped Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
Appearance of Grouped Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
Plots That Support Grouped Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
Using the Default Appearance for Grouped Data . . . . . . . . . . . . . . . . . . . . . . . . . . 123
Using Custom Styles to Control the Appearance of Grouped Data . . . . . . . . . . . . 125
Using Attribute Maps to Control the Appearance of Grouped Data . . . . . . . . . . . 127
Controlling the Appearance of Grouped Data for All Graphs in a Template . . . . . 132
Changing the Grouped Data Display . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
Including Missing Group Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
Changing the Grouped Data Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
Making the Appearance of Grouped Data Independent of Data Order . . . . . . . . . 142
Attribute Rotation Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
About the Attribute Rotation Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
The Default Attribute Rotation Pattern . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
The Color-Priority Attribute Rotation Pattern . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
Data Skins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
Subpixel Rendering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
Recommendations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
Default Appearance Features in Graphs
Graphs that are produced with GTL derive their general default appearance features
(fonts, colors, line properties, and marker properties) from the current ODS style. The
following three images show the same graph that is rendered with three different styles.
111

Figure 6.1
ods listing style=default;
Figure 6.2
ods listing style=meadow;
112
Chapter 6
•
Managing Graph Appearance: General Principles

Figure 6.3
ods listing style=journal;
An important point to note, here, is that the appearance of the graph changes when the
template is executed, not when it is compiled.
Fully one third of all GTL syntax addresses matters of appearance. Yet, most of the
examples in this document do not use the appearance syntax because the examples take
advantage of the pre-defined styles. Whenever the options in your graph template
explicitly change a color or font family, you are locking those decisions into the
compiled template. Appearance options in GTL always override any similar appearance
settings contained in the style. Thus, setting a fixed font or color appearance option
might yield satisfactory results with some styles but not with others. For that reason, the
compiled graph and table templates that are included with many SAS procedures do not
contain references to fixed fonts and colors.
This chapter shows "best practices" to follow so that your GTL programs integrate style
definitions to create the look that you desire in your graphics output. The coding strategy
that you use depends on how much style integration that you need. If you want to change
the appearance of all your plots or apply a custom style to them, you can define your
own style. For details, see Chapter 18, “Managing the Graph Appearance with Styles,”
on page 391.
Evaluating Supplied Styles
Over fifty ODS styles are available for use with ODS Graphics. These styles are stored
in the Sashelp.Tmplmst item store under the STYLES directory. To list the names of all
the supplied templates in the SAS Output window, you can submit the following
program:
proc template;
 path sashelp.tmplmst;
 list styles;
run;
Evaluating Supplied Styles
113

Listing of: SASHELP.TMPLMST
Path Filter is: Styles
Sort by: PATH/ASCENDING
Obs    Path                         Type
_________________________________________
 1     Styles                       Dir
 2     Styles.Analysis              Style
 3     Styles.Astronomy             Style
 4     Styles.Banker                Style
 (more )
You can also browse the styles interactively using the Templates window. To do so,
issue the ODSTEMPLATE command to open the Templates window, and then select
Styles under the Sashelp.Tmplmst item store.
Some of the ODS styles have been around for a long time, before the introduction of
ODS Graphics. All styles will work with ODS Graphics, but many of the older ones
have not been fully optimized for ODS Graphics. Below is a list of recommended styles
and a brief description of each.
Style
Example
LISTING
•
white background
•
white wall
•
sans-serif fonts
•
color used for lines, markers, and
filled areas
•
other colors the same as DEFAULT
style
114
Chapter 6
•
Managing Graph Appearance: General Principles

Style
Example
DEFAULT
•
gray background
•
white wall
•
sans-serif fonts
STATISTICAL
•
white background
•
white wall
•
sans-serif fonts
•
contrasting color scheme of blues,
reds, greens for markers, lines, and
filled areas
HTMLBLUE
•
white background
•
white wall
•
sans-serif fonts
•
table colors match the graph colors
•
group distinctions based on color
rather than marker or line styles
•
a lighter color scheme for HTML
content
ANALYSIS
•
light tan background
•
white wall
•
sans-serif fonts
•
muted color scheme of tans, greens,
yellows, oranges and browns for lines,
markers, and filled areas
Evaluating Supplied Styles
115

Style
Example
JOURNAL and JOURNAL3
•
white background
•
white wall
•
sans-serif fonts
•
gray-scale color scheme for markers,
lines, and filled areas
•
gray-scale pattern and color scheme
for bar fill patterns (JOURNAL3
only)
JOURNAL2
•
white background
•
white wall
•
sans-serif fonts
•
black-only scheme for markers, lines,
and bar fill patterns
•
no solid filled areas—a minimal ink
style
Methods for Changing the Appearance of Your
Plots
If you want to change the appearance of your plots from what the supplied styles
provide, there are several methods that you can use based on what you want to change.
The following table summarizes the available methods.
To Change...
Method
For Information, See...
the attributes of all plots that
use a specific ODS style
Use one of the other supplied
ODS styles or create a custom
ODS style.
Chapter 18, “Managing the
Graph Appearance with
Styles,” on page 391
the attributes of individual
plots to make them
independent of the current
style
Use the appropriate attribute
options in the plot statements.
“Options That Override
Attributes for Individual
Plots” on page 117
the attributes of all of the
plots in a specific template to
make them independent of the
current style
Use the appropriate attribute
options in the
BEGINGRAPH statement for
the template.
“Controlling the Appearance
of Grouped Data for All
Graphs in a Template” on
page 132
116
Chapter 6
•
Managing Graph Appearance: General Principles

To Change...
Method
For Information, See...
the attributes of group values
to make them independent of
the data order
Use a discrete attribute map
or the INDEX= option.
“Making the Appearance of
Grouped Data Independent of
Data Order” on page 142
the attributes of numeric
values based on numeric
ranges
Use a range attribute map.
“Range Attribute Maps” on
page 129
Options That Override Attributes for Individual
Plots
Overview of Graphical Properties
In GTL, the syntax for explicitly setting the properties of a graphical feature is a list of
name-value pairs that is enclosed in parentheses. For example, to set the X-axis
properties, you use the following option in the layout statement:
XAXISOPTS=(LABEL="string" TYPE=axis-type …)
The syntax for setting appearance options is similar. For example, in statements such as
SERIESPLOT, DENSITYPLOT, REFERENCELINE, and DROPLINE, you use the
LINEATTRS= option to specify the appearance of the line:
LINEATTRS= (COLOR=color PATTERN=line-pattern THICKNESS=line-thickness)
The properties of any line that you can draw in GTL are specified in exactly the same
way, possibly with a different option keyword.
In BANDPLOT and MODELBAND statements, you use the following option to specify
the appearance of the outline:
OUTLINEATTRS=(COLOR=color PATTERN=line-pattern THICKNESS=line-thickness)
In a BOXPLOT statement, you use the following options to specify the appearance of
the whiskers and median:
WHISKERATTRS=(COLOR=color PATTERN=line-pattern THICKNESS=line-thickness)
MEDIANATTRS=(COLOR=color PATTERN=line-pattern THICKNESS=line-thickness)
In BARCHART and BARCHARTPARM statements, you use the following options to
specify the appearance of the bar fill color and pattern:
FILLATTRS=(COLOR=color TRANSPARENCY=number)
FILLPATTERNATTRS=(COLOR=color PATTERN=pattern)
The list of properties in each of these options is sometimes called an "attribute bundle."
Some GTL statements provide other options that override the visual attributes of
graphical features for an individual graph. For more information, see SAS Graph
Template Language: Reference. The remainder of this section describes the most
commonly used options.
Options That Override Attributes for Individual Plots
117

LINEATTRS Option
The following syntax is the complete syntax for the LINEATTRS= option:
LINEATTRS = style-element | style-element (line-options) | (line-options)
For information about the attributes that you can specify with line-options, see “Line
Options” on page 494.
By default, a style-element is used for the LINEATTRS= setting. For the
REFERENCELINE and DROPLINE statements, the default style element is the
GraphReference element. What exactly does this mean?
If we look up the GraphReference element in the DEFAULT style (see Appendix 2,
“Graph Style Elements Used by ODS Graphics,” on page 479 for a complete list of all
elements and attributes and their defaults), we find the following:
style GraphReference /
  linethickness = 1px
  linestyle = 1
  contrastcolor = GraphColors('greferencelines');
This definition is ODS style syntax for an attribute bundle. The following table shows
how this definition's style attributes map to GTL options.
Style Attribute
Description
GTL Suboption
Description
LINETHICKNESS
dimension, most
often pixels
THICKNESS
dimension, most
often pixels
LINESTYLE
numeric; 1 to 46, 1
being a solid line
PATTERN
either 1 to 46 or a
pattern name, such as
SOLID, DASH, DOT
(see “Available Line
Patterns” on page
497 for examples of
available line
patterns)
CONTRASTCOLOR
color specification
COLOR
color specification
The default specification for REFERENCELINE and DROPLINE statements is
LINEATTRS=GraphReference, which is a shortcut meaning "initialize the three GTL
line properties with the corresponding attributes that are defined in a style element." This
can be explicitly expressed in GTL as follows:
LINEATTRS=( PATTERN  = GraphReference:LineStyle
            THICKNESS= GraphReference:LineThickness
            COLOR    = GraphReference:ContrastColor )
In GTL, a style reference is a construct of the form style-element : style-attribute. This
convention is the way to refer to a specific style attribute of a specific style element.
First, we will look at what it means to use a different style element for the
LINEATTRS= option.
When selecting a different style element, you should make sure that the style element
does set line properties (graph style elements do not necessarily define all possible
attributes). Some reasonable choices might be GraphDataDefault, GraphAxisLines,
118
Chapter 6
•
Managing Graph Appearance: General Principles

GraphGridLines. and GraphBorderLines. You might choose GraphGridLines to force a
reference line to match the properties of grid lines (if displayed). When you make this
type of assignment, you really do not know what actual line properties will be used
because they might change, depending on how a given style is defined. What you should
be confident of is that the grid lines and reference lines are identical in terms of line
properties.
Now we will assume that you want reference lines to be somewhat like a style element,
but different. This involves an override. Here are some examples:
1) LINEATTRS=GraphGridLines(THICKNESS=2px)
2) LINEATTRS=GraphAxisLines(PATTERN=DASH)
3) LINEATTRS=GraphReference(COLOR=GraphAxisLines:ContrastColor)
4) LINEATTRS=(COLOR=GraphAxisLines:ContrastColor)
5) LINEATTRS=(COLOR=BLUE)
In example 1, the reference line looks like a grid line (color and pattern), but be thicker
(assuming most styles define grid lines as 1px).
In example 2, the reference line looks like an axis line (color and thickness), but it uses
the DASH pattern.
In example 3, the reference line looks like a reference line (pattern and thickness), but it
has the color of axis lines.
Example 4 is a short form for example 3. Any time you do not supply a style element or
do not override all the suboptions, the suboptions not overridden come from the default
style references.
Example 5 shows how you can hardcode visual properties. This technique is a
straightforward way of getting what you want. The results might look good when the
DEFAULT or LISTING styles are in effect, but might not look good when the
ANALYSIS style is in effect because ANALYSIS does not use any blues in its color
scheme.
MARKERATTRS Option
Much of what is said about line properties in “LINEATTRS Option” on page 118 also
applies to marker properties. Some plot statements, such as SERIESPLOT, display a line
and can display markers. In those cases, you should use the DISPLAY=(MARKERS)
option to turn on the marker display, and also use the MARKERATTRS= option to
control the appearance of markers. (The BOXPLOT statement uses OUTLIERATTRS=
and MEANATTRS= options).
The following syntax is the complete syntax for the MARKERATTRS= option:
MARKERATTRS=style-element | style-element (marker-options) | (marker-options)
For information about the attributes that you can specify with marker-options, see
“Marker Options” on page 496.
The following table shows how the MARKERATTRS= style attributes map to GTL
options.
Style Attribute
Description
GTL Suboption
Description
CONTRASTCOLOR
color specification
COLOR
color specification
MARKERSIZE
dimension, most
often pixels
SIZE
dimension, most
often pixels
Options That Override Attributes for Individual Plots
119

Style Attribute
Description
GTL Suboption
Description
MARKERSYMBOL
string (for example, "
circle " or " square ")
SYMBOL
predefined keywords
such a CIRCLE,
SQUARE,
TRIANGLE
none
TRANSPARENCY
transparency
specification, which
ranges from 0
(opaque) to 1
(entirely transparent)
none
WEIGHT
NORMAL or BOLD
TEXTATTRS Option
The appearance of all text that appears in a graph can be controlled by the style or with
GTL syntax. Title and footnote text in a graph is specified with the ENTRYTITLE and
ENTRYFOOTNOTE statements. One or more lines of text can be displayed in the plot
area by using one or more ENTRY statements. Each of these statements provides the
TEXTATTRS= option for controlling the appearance of that text.
The following syntax is the complete syntax for the TEXTATTRS= option:
TEXTATTRS=style-element | style-element (text-options) | (text-options)
Most often the TEXTATTRS=(text-options) settings are used to control text font and
color properties.
Text can also be specified on numerous options that are available on plot statements and
layout statements, and also on various axis options. For example, most plot statements
that can display a line provide the CURVELABEL= for labeling the line. Axis options
that are available for the layout statements provide the LABEL= option for specifying an
axis label. The default appearance of the text in these cases is controlled by styles, but
GTL syntax provides the CURVELABELATTRS= and LABELATTRS= options for
overriding the defaults. The syntax and use for these options is similar to that of the
TEXTATTRS= option. For example, the following syntax is the complete syntax for the
LABELATTRS= option:
LABELATTRS=style-element | style-element (text-options) | (text-options)
Changing text attributes is fully discussed in Chapter 7, “Adding and Changing Text in a
Graph,” on page 157.
Appearance of Non-grouped Data
When you use statements such as SERIESPLOT, BANDPLOT, NEEDLEPLOT,
ELLIPSE, STEPPLOT, FRINGEPLOT, LINEPARM, and VECTORPLOT to draw plots
containing lines, the same style element, GraphDataDefault, is used for all line and
marker properties. You can think of these plots as "non-specialized," and they all have
the same default appearance when used in overlays
120
Chapter 6
•
Managing Graph Appearance: General Principles

In the graph that is produced by the following code, the series lines have the same
default appearance.
proc template;
  define statgraph series;
    begingraph;
      entrytitle "Overlay of Multiple SERIESPLOTs";
      layout overlay / yaxisopts=(label="IBM Stock Price");
        seriesplot x=date y=high / curvelabel="High";
        seriesplot x=date y=low /  curvelabel="Low";
      endlayout;
    endgraph;
  end;
run;
proc sgrender data=sashelp.stocks template=series;
   where date between "1jan2002"d and "31dec2005"d 
         and stock="IBM";
run;
To ensure that the series lines differ in appearance, you can use any style element with
line properties. A set of carefully constructed style elements named GraphData1 to
GraphDataN (where N=12 for most styles, some styles might have fewer) are normally
used for this purpose. These elements all use different marker symbols, line pattern, fill
colors (COLOR=) and line and marker colors (CONTRASTCOLOR=). All line and
marker colors are of different hues but with the same brightness, which means that all
twelve colors can be distinguished but none stands out more than another. Fill colors are
based on the same hue but have less saturation, making them similar but more muted
than the corresponding contrast colors.
In the following template code, the style elements GraphData1 and GraphData2 are used
to change the default appearance of the series lines in the graph.
layout overlay / yaxisopts=(label="IBM Stock Price");
  seriesplot x=date y=high / curvelabel="High" lineattrs=GraphData1 ;
  seriesplot x=date y=low /  curvelabel="Low"  lineattrs=GraphData2 ;
endlayout;
Appearance of Non-grouped Data
121

This same graph could also be achieved by specifying CYCLEATTRS=TRUE on the
LAYOUT OVERLAY statement and omitting the LINEATTRS= options on the plot
statements. In that case, the visual attributes for each plot in the overlay are rotated as
described in “Attribute Rotation Patterns” on page 145. The GraphDataN style elements
provide visual distinction. All of these elements vary color, line pattern, and marker
symbols to gain maximum differentiation.
Sometimes, you might not want to vary all properties at once. For example, to force only
the color to change but not the line pattern, you can override one or more properties that
you want to hold constant.
layout overlay / yaxisopts=(label="IBM Stock Price");
  seriesplot x=date y=high / curvelabel="High"
    lineattrs=GraphData1(pattern=shortdash) ;
  seriesplot x=date y=low / curvelabel="Low"
    lineattrs=GraphData2(pattern=shortdash) ;
endlayout;
Other statements such as DENSITYPLOT, REGRESSIONPLOT, LOESSPLOT,
PBSPLINEPLOT, MODELBAND, REFERENCELINE, and DROPLINE are
"specialized" in the sense that their default line appearance is governed by other style
elements such as GraphFit, GraphConfidence, GraphPrediction, GraphReference, or
122
Chapter 6
•
Managing Graph Appearance: General Principles

some other specialized style element. When these statements are used in conjunction
with the "non-specialized" plot statements, there are differences in appearance.
Appearance of Grouped Data
Plots That Support Grouped Data
The GROUP= column option is used to plot data when a classification or grouping
variable is available. Plots that support the GROUP= option include the following:
BANDPLOT
LOESSPLOT
SCATTERPLOTMATRIX
BARCHART
NEEDLEPLOT
SERIESPLOT
BOXPLOT
PBSPLINEPLOT
STEPPLOT
BUBBLEPLOT
PIECHART
VECTORPLOT
HIGHLOWPLOT
REGRESSIONPLOT
LINEPARM
SCATTERPLOT
Using the Default Appearance for Grouped Data
By default, the GROUP= option automatically uses the style elements GraphData1 to
GraphDataN for the presentation of each unique group value. Here is an example of a
series plot that displays grouped data using the default HTMLBLUE ODS style.
proc template;
  define statgraph group;
    begingraph;
      entrytitle "Tech Stocks 2002-2004";
      entryfootnote halign=left "Source: SASHELP.STOCKS";
      layout overlay;
        seriesplot x=date y=close / group=stock name="series"
          lineattrs=(thickness=2);
        discretelegend "series";
      endlayout;
    endgraph;
  end;
run;
 
proc sgrender data=sashelp.stocks template=group;
  where date between "1jan02"d and "31dec04"d;
run;
Appearance of Grouped Data
123

Attributes such as line color and pattern are used to display the group values. The
attributes are defined by the GraphData1–GraphDataN style elements for the style that is
in effect. The attributes are rotated for each group values as described in “Attribute
Rotation Patterns” on page 145. In the previous example, there are three unique values
of column Stock in the Sashelp.Stocks data set: IBM, Intel, and Microsoft. The line
colors and line patterns from the GraphData1–GraphData3 style elements of the
HTMLBLUE style are used for each of the three group values. Because the
HTMLBLUE style defines the AttrPriority="COLOR" style attribute, the color-priority
attribute rotation pattern is used. The ContrastColor attribute specifies the line color, and
the LineType attribute specifies the line pattern. See Appendix 2, “Graph Style Elements
Used by ODS Graphics,” on page 479 for information about the GTL style elements and
attributes. See “Attribute Rotation Patterns” on page 145 for information about how the
style attributes are rotated for group values.
The colors and patterns are assigned to the values in the order in which they occur in the
Sashelp.Stocks data set. In this case, GraphData1 is assigned to IBM, GraphData2 is
assigned to Intel, and GraphData3 is assigned to Microsoft. Other attributes such as fill
color, fill pattern, and marker color that are used in other plot types are assigned in a
similar manner. Here are some additional examples of the default grouped data
appearance for other plot types. All of the plots in these examples use the HTMLBLUE
style.
124
Chapter 6
•
Managing Graph Appearance: General Principles

To specify different colors and patterns that you can specify a different ODS style or you
can create a custom style. For information about creating custom styles, see “Using
Custom Styles to Control the Appearance of Grouped Data” on page 125. For many
plots and charts, you can also use attribute maps to override certain style attributes for
specific group values. For information about attribute maps, see “Using Attribute Maps
to Control the Appearance of Grouped Data” on page 127.
Using Custom Styles to Control the Appearance of Grouped Data
Each style potentially can change the style attributes for GraphData1–GraphDataN. If
you have certain preferences for grouped data items, you can create a modified style that
will display your preferences. The following code creates a new style named STOCKS
that is based on the supplied style STYLES.LISTING. This modification changes the
properties for the GraphData1–GraphData3 style elements. All other style elements are
inherited from LISTING.
proc template;
  define style Styles.stocks; 
    parent=styles.listing;
    style GraphData1 from GraphData1 /
      ContrastColor=blue
      Color=blue
      MarkerSymbol="CircleFilled"
      Linestyle=1;
    style GraphData2 from GraphData2 /
      ContrastColor=brown
      Color=brown
Appearance of Grouped Data
125

      MarkerSymbol="TriangleFilled"
      Linestyle=1;
    style GraphData3 from GraphData3 /
      ContrastColor=orange
      Color=orange
      MarkerSymbol="SquareFilled"
      Linestyle=1;
  end;
run;
In this style definition, the LINESTYLE is set to 1 (solid) for the first three data values.
Style syntax requires that line styles be set with their numeric value, not their keyword
counterparts in GTL such as SOLID, DASH, or DOT. See “Available Line Patterns” on
page 497 for the complete set of line patterns.
CONTRASTCOLOR is the attribute applied to grouped lines and markers. COLOR is
the attribute applied to grouped filled areas, such as grouped bar charts or grouped
ellipses. MARKERSYMBOL defines the same values that can be specified with the
MARKERATTRS=( SYMBOL=keyword ) option in GTL. See “SYMBOL=style-
reference | marker-name ” on page 496 for the complete set of marker symbol names.
After the STOCKS style is defined, it must be requested on the ODS destination
statement. No modification of the compiled template is necessary:
ods html style=stocks;
proc sgrender data=sashelp.stocks
              template=group;
 where date between 
      "1jan02"d and "31dec04"d;
run;
One issue that you should be aware of is that the STOCKS style only customized the
appearance of the first three group values. If there were more group values, other
unaltered style elements will be used, starting with GraphData4. Most styles define (or
inherit) GraphData1 to GraphData12 styles elements. If you need more elements, you
can add as many as you desire, starting with one more than the highest existing element
(for example, GraphData13) and numbering them sequentially thereafter.
126
Chapter 6
•
Managing Graph Appearance: General Principles

Using Attribute Maps to Control the Appearance of Grouped Data
Discrete Attribute Maps
A discrete attribute map enables you to consistently assign attributes to specific values of
a numeric or character column in a data set. The assignment of the attributes is based on
formatted data values and is independent of the position of the data in the data set. It is
typically used to visually highlight group values on a plot using marker symbols, fill
colors, line patterns, and so on. To create and use a discrete attribute map, you must do
the following:
•
Use a DISCRETEATTRMAP block with one or more VALUE statements to define
your attribute map.
•
Use a DISCRETEATTRVAR statement to create an attribute variable that associates
your attribute map with a data column in your plot data set.
•
Set the group option in your plot statement to the name of the attribute variable that
you created in your DISCRETEATTRVAR statement. The group option includes
GROUP=, COLORGROUP=, MARKERCOLORGROUP=, and so on, depending on
the plot statement. See SAS Graph Template Language: Reference for specific
information about the group options and whether they accept discrete attribute
variables.
The DISCRETEATTRMAP block includes one or more VALUE statements that
associate a single value to a set of graphic attribute options, such as LINEATTRS,
MARKERATTRS, TEXTATTRS, or FILLATTRS. Any column values that are not
accounted for in the VALUE statements are assigned the default visual properties that
would normally be assigned if an attribute map was not used. The
DISCRETEATTRMAP statement also includes a NAME= option that enables you to
specify a unique name for the map. The block must appear in the global definition area
of the template between the BEGINGRAPH statement and the first LAYOUT statement.
It cannot be nested within any other statement. An ENDDISCRETEATTRMAP
statement must be used to end the block.
The DISCRETEATTRVAR statement creates a named association between a
DISCRETEATTRMAP and a column in your plot data set. To create the attribute
variable, do the following:
•
Add a DISCRETEATTRVAR statement to the global definition area of your
template between the BEGINGRAPH statement and the first layout statement.
•
In the DISCRETEATTRVAR statement:
•
Set the ATTRVAR= option to a unique name for the attribute-map-to-data-set-
column association.
•
Set the ATTRMAP= option to the value of the NAME= option that you used in
your DISCRETEATTRMAP statement.
•
Set the VAR= option to the name of the numeric or character column in your plot
data set, an expression, or the name of a dynamic variable.
After you create the discrete attribute map and the attribute variable, in your plot
statement, set the GROUP= option or other roles that can accept a discrete attribute
variable to the value of the ATTRVAR= option that you used in your
DISCRETEATTRVAR statement.
Note: Do not use the attribute variable in an expression. Doing so might produce
unexpected results.
Appearance of Grouped Data
127

Note: The values and graphical attributes defined in a discrete attribute map cannot be
displayed by a CONTINUOUSLEGEND statement.
Here is an example that creates and applies a discrete attribute map to the values in
column Stock of the plot data set. It also creates a discrete legend and uses the STOCKS
style that was created in “Using Custom Styles to Control the Appearance of Grouped
Data” on page 125.
/* Create a stock data set for the year 2002 */
proc sort data=sashelp.stocks out=stocks;
   by stock date;
   where date between '01JAN02'd and '30DEC02'd;
run;
/* Create a template for IBM, Microsoft, and Intel stocks */
proc template;
define statgraph stocks;
begingraph;
  entrytitle "Trends for IBM, Intel, and Microsoft";
  discreteattrmap name="stockname" / ignorecase=true;
    value "IBM" /
       markerattrs=GraphData1(color=red  symbol=circlefilled)
       lineattrs=GraphData1(color=red pattern=solid);
    value "Intel" /
       markerattrs=GraphData2(color=green symbol=trianglefilled)
       lineattrs=GraphData2(color=green pattern=shortdash); 
    value "Microsoft" /
       markerattrs=GraphData3(color=blue symbol=squarefilled)
       lineattrs=GraphData3(color=blue pattern=dot);    
  enddiscreteattrmap;
  discreteattrvar attrvar=stockmarkers var=stock
     attrmap="stockname";
  layout overlay;
     seriesplot x=date y=close /
        group=stockmarkers
        display=(markers)
        name="trends";
    discretelegend "trends" / title="Stock Trends";
  endlayout;
endgraph;
end;
run;
/* Plot the stock trends  */
ods html style=stocks;
proc sgrender data=stocks template=stocks;
run;
quit;
This example overrides the attributes in the STOCKS style with different line and
marker attributes for the IBM, Intel, and Microsoft stock plot lines. In the example code,
notice that the NAME="stockname" option in the DISCRETEATTRMAP statement
provides a name for the discrete attribute map. Also notice that the
ATTRVAR=stockmarkers option in the DISCRETEATTRVAR statement provides a
name for the attribute-map-to-data-set-column association. The
ATTRMAP="stockname" and the VAR=stock options in the DISCRETEATTRVAR
128
Chapter 6
•
Managing Graph Appearance: General Principles

statement associate the attribute map stockname with the data set column Stock
respectively to create an attribute variable. In the SERIESPLOT statement, the
GROUP=stockmarkers option applies the attribute map to the specified group values.
This satisfies all of the requirements for using a discrete attribute map.
The following figure shows the resulting output.
In this example, the markers, line colors, and line patterns in the plot remain the same
regardless of the data, data order, or ODS style that is in effect. For example, if you run
this example with a different ODS style and without any data for IBM, the Intel and
Microsoft plot lines and markers remain the same.
Range Attribute Maps
A range attribute map enables you to map one or more colors to a range of values of a
specific numeric column in a plot data set. It is typically used to visually group values
into ranges where each range is depicted as a single color or color ramp.
Note: A RANGEATTRMAP can be used with a numeric column only.
To create and use a range attribute map, you must do the following:
•
Use a RANGEATTRMAP block with one or more RANGE statements to define
your range attribute map. Use the RANGE statement RANGECOLOR= or
RANGECOLORMODEL= option to specify a color or color ramp for each range.
•
Use a RANGEATTRVAR statement to create an attribute variable that associates
your range attribute map with a numeric data column in your plot data set.
•
Set the MARKERCOLORGRADIENT= or COLORRESPONSE= option in your
plot statement to the name of the attribute variable that you created in your
RANGEATTRVAR statement.
The RANGEATTRMAP block includes one or more RANGE statements that associate a
range of values with a single color or a color ramp. The syntax of the RANGE statement
is as follows:
RANGE low-value< < > – < < >high-value / options
The optional exclusion operator (<) can be placed after the low-value value or before the
high-value value to exclude that value from the range endpoint. The low-value and high-
value values can be an unformatted numeric value or a range keyword. For low-value,
keyword MIN, NEGMAX, or NEGMAXABS can be used instead of numeric value. For
Appearance of Grouped Data
129

high-value, keyword MAX or MAXABS can be used. For information about the range
keywords, see SAS Graph Template Language: Reference.
Note: If two ranges share a common endpoint, such as 10–20 and 20–30, and no
exclusion operator ( < ) is used, the common endpoint belongs to the lower range,
which is 10–20 in this case.
The RANGEATTRMAP statement also includes a NAME= option that enables you to
specify a unique name for the range attribute map. The RANGEATTRMAP block must
appear in the global definition area of the template between the BEGINGRAPH
statement and the first LAYOUT statement. It cannot be nested within any other
statement. An ENDRANGEATTRMAP statement is required to end the block. The
block must contain at least one RANGE statement.
The RANGEATTRVAR statement creates a named association between a range
attribute map and a numeric column in your plot data set. To create the range attribute
variable, do the following in your RANGEATTRVAR statement:
•
Add a RANGEATTRVAR statement to the global definition area of your template
between the BEGINGRAPH statement and the first layout statement.
•
In the RANGEATTRVAR statement:
•
Set the ATTRVAR= option to a unique name for range attribute map to data set
column association.
•
Set the ATTRMAP= option to the value of the NAME= option that you used in
your RANGEATTRMAP statement.
•
Set the VAR= option to the name of the numeric column in your plot data set
with which the range attribute map is to be associated.
After you create the range attribute map and the range attribute variable, in your plot
statement, set the value of the option that maps the column values to colors to the name
that you specified with the ATTRMAP= option in your RANGEATTRVAR statement.
Note: The values and graphical attributes defined in a range attribute map cannot be
displayed by a DISCRETELEGEND statement.
Here is an example of a template that creates and applies a range attribute map to the
Weight column of a SCATTERPLOT statement data set in order to color the markers in
the resulting plot by weight range. It also creates a continuous legend.
proc template;
define statgraph attrrange; 
   begingraph;
      /* Create the range attribute map. */ 
      rangeattrmap name="scale";
         range 0-70 / 
            rangealtcolor=black; /* 0 to 70 inclusive */
         range 70<-107 / 
            rangealtcolor=blue; /* 70 exclusive to 107 inclusive */
         range 107<-125 / 
            rangealtcolor=green; /* 107 exclusive to 125 inclusive */ 
         range 125<-200 / 
            rangealtcolor=red; /* 125 exclusive to 200 inclusive */ 
      endrangeattrmap; 
      /* Create the range attribute variable. */
      rangeattrvar attrvar=weightrange var=weight attrmap="scale";
      /* Create the graph. */
130
Chapter 6
•
Managing Graph Appearance: General Principles

      entrytitle "Weight Class"; 
      layout overlay /
         xaxisopts=(griddisplay=on gridattrs=(color=lightgray pattern=dot))
         yaxisopts=(griddisplay=on gridattrs=(color=lightgray pattern=dot));
         scatterplot x=weight y=height / markercolorgradient=weightrange 
            markerattrs=(symbol=circlefilled size=10) name='wgtclass';
         /* Add a continuous legend. */
         continuouslegend 'wgtclass'; 
      endlayout;
   endgraph;
end;
run;
/* Render the graph. */
ods graphics / width=4in height=3in;
proc sgrender data=sashelp.class template=attrrange;
run;
The following figure shows the resulting output.
In the example code, notice that the NAME=”scale” option in the RANGEATTRMAP
statement provides a name for the range attribute map. A RANGE statement specifies a
color for each of four ranges. Because the SCATTERPLOT statement uses the
ContrastColor style attribute for the marker colors in a grouped plot, the 
RANGEALTCOLOR= option is used in each RANGE statement to define the range
color. The ATTRVAR=weightrange option in the RANGEATTRVAR statement
provides a name for the attribute-map-to-data-set-column association. The
ATTRMAP=”scale” and the VAR=weight options in the RANGEATTRVAR statement
associate the attribute map scale with the data set column Weight respectively. In the
SCATTERPLOT statement, the MARKERCOLORGRADIENT=weightrange option
applies the range attribute map to the Weight column values and colors the plot markers
according to the ranges that are specified in the range attribute map. To add a legend that
displays the marker colors for the weight ranges, you can include a
CONTINUOUSLEGEND statement. For information about continuous legends, see
“Features of Continuous Legends” on page 204.
Appearance of Grouped Data
131

Controlling the Appearance of Grouped Data for All Graphs in a
Template
Options That Override Style Attributes for All of the Plots in a
Template
You can use options in the BEGINGRAPH statement to override various style attributes
for all of the plots that are defined in a template. The following table lists the options
that you can use.
BEGINGRAPH Option
Description
ATTRPRIORITY=
Specifies a priority for the cycling of the attributes from the
GraphData1–GraphDataN style elements. See “Attribute
Rotation Patterns” on page 145.
DATACOLORS=
Specifies the list of fill colors that replace the graph data
colors from the GraphData1–GraphDataN style elements.
DATACONTRASTCOLORS=
Specifies the list of contrast colors that replace the graph data
contrast colors from the GraphData1–GraphDataN style
elements.
DATASYMBOLS=
Specifies the list of marker symbols that replace the graph
data marker symbols from the marker symbols that are
defined in the GraphData1–GraphDataN style elements.
DATALINEPATTERNS=
Specifies the list of line patterns that replace the graph data
line patterns from the GraphData1–GraphDataN style
elements.
These options apply to all of the plots that are defined in the template. They affect the
attribute assignments when the following criteria are true:
•
the GROUP= option is used on a plot statement
•
attribute options such as LINEATTRS= or MARKERATTRS= reference a
graphData1–GraphDataN style element
•
the CYCLEATTRS=TRUE option is in effect in an overlay-type layout
You can override the attributes that are defined by these options on a per-plot basis by
using attribute options or a reference to an attribute map on the plot statement.
Overriding the Fill Colors
You can use the DATACOLORS=(color-list) option to override the fill colors that are
defined in the current style’s GraphData1–GraphDataN style elements. When you
specify the DATACOLORS= option, the fill colors rotate through the colors that are
specified in the color list rather than through the colors that are specified in the current
style’s GraphData1–GraphDataN style elements. This rotation pattern enables you to use
the same colors in your plots regardless of the style that is in effect.
Here is an example that specifies the fill colors very light red, very light green, and light
blue as the colors for the three group values of a grouped bar chart.
proc template;
132
Chapter 6
•
Managing Graph Appearance: General Principles

  define statgraph group;
    dynamic year;
    begingraph / datacolors=(verylightred verylightgreen lightblue);
      entrytitle "Stock Index Performance - " year;
      layout overlay / xaxisopts=(label="Month");
        barchart category=date response=close / group=stock name="barchart";
        discretelegend "barchart";
      endlayout;
    endgraph;
  end;
run;
 
proc sgrender data=sashelp.stocks template=group;
  where date between "1jan02"d and "31dec02"d;
  format date MONNAME3.;
  dynamic year="2002";
run;
The following figure shows the result.
If the number of unique colors needed exceeds the number of colors that are specified in
the color list, two new sets of colors are computed based on the original colors. The first
set is one shade lighter that the original colors, and the second set is one shade darker. In
the previous example, this pattern provides a maximum of nine unique colors. Beyond
nine values, the color pattern repeats, starting with the tenth value.
Overriding the Line Patterns and Line Colors
You can use the DATACONTRASTCOLORS= and DATALINEPATTERNS= options
to override the line patterns and line colors that are defined in the current style’s
GraphData1–GraphDataN style elements. In this way, you can use the same colors and
line patterns in your plots regardless of the style that is in effect. Here is an example that
specifies the contrast colors light red, orange, and medium blue as the colors for the
three group values of a grouped series plot. It also specifies the line patterns 2, 9, and 41
as the line patterns for the group values. (See “Available Line Patterns” on page 497.)
This example uses the HTMLBLUE style. In order to use a different line pattern for each
group value, the code must also include the ATTRPRIORITY=NONE option to ensure
that color does not take priority in the attribute rotation.
Appearance of Grouped Data
133

Here is the SAS code for this example.
proc template;
  define statgraph group;
    dynamic year;
    begingraph / attrpriority=none
                 datacontrastcolors=(lightred orange mediumblue)
                 datalinepatterns=(2 9 41);
      entrytitle "Stock Performance - " year;
      layout overlay / xaxisopts=(type=discrete label="Month");
        seriesplot x=date y=close / group=stock name="series";
        discretelegend "series";
      endlayout;
    endgraph;
  end;
run;
 
proc sgrender data=sashelp.stocks template=group;
  where date between "1jan02"d and "31dec02"d;
  format date MONNAME3.;
  dynamic year="2002";
run;
The following figure shows the result.
The colors and line patterns remain constant regardless of the style that is in effect.
Overriding the Marker Symbols and Marker Colors
You can use the DATACONTRASTCOLORS= and DATASYMBOL= options to
override the marker symbols and marker colors that are defined in the current style’s
GraphData1–GraphDataN style elements. In this way, you can use the same marker
symbols in your plots regardless of the style that is in effect. Here is an example that
specifies the marker symbols circle, square, and triangle for the three group values of a
grouped scatter plot. This example uses the HTMLBLUE style. In order to use a
different marker symbol for each group value, the code must also include the
ATTRPRIORITY=NONE option to ensure that color does not take priority in the
attribute rotation.
134
Chapter 6
•
Managing Graph Appearance: General Principles

Here is the SAS code for this example.
proc template;
  define statgraph group;
    dynamic year;
    begingraph / attrpriority=none
                 datasymbols=(circlefilled squarefilled trianglefilled)
                 datacolors=(lightred orange mediumblue);
      entrytitle "Stock Performance - " year;
      layout overlay / xaxisopts=(type=discrete label="Month");
        scatterplot x=date y=close / group=stock name="scatterplot";
        discretelegend "scatterplot";
      endlayout;
    endgraph;
  end;
run;
 
proc sgrender data=sashelp.stocks template=group;
  where date between "1jan02"d and "31dec02"d;
  format date MONNAME3.;
  dynamic year="2002";
run;
The following figure shows the result.
The marker symbols remain constant regardless of the style that is in effect.
Changing the Grouped Data Display
With many plots, you can use the GROUPDISPLAY= option to change how group
values are displayed. The following table summarizes the values that you can use with
this option and the plot statements that are applicable for each.
Appearance of Grouped Data
135

Table 6.1
GROUPDISPLAY Option Values and the Applicable Plots for Each
Value
Applicable Plot
Statements
Description
STACK
BARCHART
BARCHARPARM
Stacks each group value on a
single bar at the category
value on the axis.
CLUSTER
BARCHART
BARCHARPARM
BOXPLOT
BOXPLOTPARM
NEEDLEPLOT
SCATTERPLOT
SERIESPLOT
STEPPLOT
Displays the group values
side-by-side in a cluster that
is centered on the category
value on the axis.
Note: For NEEDLEPLOT,
SCATTERPLOT,
SERIESPLOT, and
STEPPLOT, the X axis must
be categorical.
Note: For SCATTERPLOT,
SERIESPLOT, and
STEPPLOT, you can use the
CLUSTERAXIS= option to
specify cluster grouping on
the Y axis, when applicable.
OVERLAY
BOXPLOT
BOXPLOTPARM
NEEDLEPLOT
SCATTERPLOT
SERIESPLOT
STEPPLOT
Overlays the group values at
the category value on the
axis.
For bar charts, by default, group values are stacked on each category bar. The following
figure shows an example using the STOCKS style.
136
Chapter 6
•
Managing Graph Appearance: General Principles

When GROUPDISPLAY=CLUSTER, the group values are shown as a cluster of bars,
one bar for each group value in the category value, centered over the category value as
shown in the following figure.
Here is the code that generated the previous plot.
/* Create a variable for the desired year. */
%let year=2002;
/* Create a data set of the first six months of the year. */
data stocks;
   set sashelp.stocks;
   where year(date) eq &year and month(date) le 6; 
   month=month(date);
run; 
/* Format the numeric months into 3-character month names. */
proc format;
   value month3char
      1="Jan" 2="Feb" 3="Mar" 4="Apr" 5="May" 6="Jun";
run;
/* Create the template. */
proc template;                                                                  
   define statgraph stocksgraph;                                                       
      begingraph;
       dynamic year;
         entrytitle "Stock Volume By Month for First Six Months of " year;
         layout overlay /
            yaxisopts=(griddisplay=on display=(line ticks tickvalues))
            xaxisopts=(display=(line ticks tickvalues));
            barchart category=month response=volume /
               name="total"
               dataskin=pressed
               group=stock
               groupdisplay=cluster;
            discretelegend "total";
Appearance of Grouped Data
137

         endlayout;
      endgraph;
   end;                                                                         
run;
/* Generate the bar chart using the bar template. */
ods graphics on / reset outputfmt=static;
ods html style=stocks;
proc sgrender data=stocks template=stocksgraph;
   dynamic year=&year;
   format month month3char.; 
run;
The STOCKS ODS style defines the graph appearance. (See “Using Custom Styles to
Control the Appearance of Grouped Data” on page 125.) The width of each cluster is
directly based on the number of category values on the axis. By default, the cluster width
is 85% of the midpoint spacing. You can use the CLUSTERWIDTH= option to adjust
the cluster width.
Within each cluster, by default, each bar occupies 100% of its available space. When a
cluster contains the maximum number of bars, no gap exits between the adjacent bars in
the cluster. You can use the BARWIDTH= option to add space between the bars in the
cluster.
For the remaining plot types (see Table 6.1 on page 136), the behavior of the
GROUPDISPLAY=CLUSTER option is similar to that of bar charts. That is, the group
values are clustered at the category value on the axis. You can also use the
CLUSTERWIDTH= option to vary the width of the clusters. For these plots, the clusters
include the following:
•
plot markers for series plots and scatter plots
•
step transitions and plot markers for step plots
•
boxes for box plots
This is useful if you want to overlay a grouped SERIESPLOT onto a grouped clustered
BARCHART, for example.
When GROUPDISPLAY=OVERLAY is used, each group value for a category is
positioned at the category value on the axis. If one or more values appear in the same
position, the symbol for the last value overlays the symbol for the previous value. Here
is an example of series plots that show the group cluster and overlay displays together
for comparison on discrete category axes.
Note: Style STOCKS was used to generate the series plots. See Table 6.1 on page 136.
138
Chapter 6
•
Managing Graph Appearance: General Principles

Notice in the cluster display that the three-symbol cluster for each category is centered
on the category value, while in the overlay display, all of the symbols are aligned on the
category value. Also notice that in the overlay display some of the symbols overwrite
others that appear in the same location. In the case of a scatter plot, the plot symbols
behave in the same manner.
Including Missing Group Values
By default, missing group values are excluded from the plot. If you want to include a
group for the missing values, use the INCLUDEMISSINGGROUP=TRUE option in
your plot statement. If you include a discrete legend, the missing group is also added to
the legend. For numeric values, the label for the missing group in the legend is a dot or
the character that is specified by the SAS MISSING option. For character values, the
label for the missing group is a blank. You can use a FORMAT statement to assign a
more meaningful label to the missing group category. Here is an example.
proc template;
 define statgraph survey;
   BeginGraph;
   entrytitle "Customer Survey Results";
   layout overlay / xaxisopts=(label="Store Location")
        yaxisopts=(label="Satisfaction Rating");
     barchart category=store response=rating / name="barchart" stat=mean
       group=purchase_method groupdisplay=cluster barwidth=0.9 
       includemissinggroup=true;
     discretelegend "barchart" / title="Purchase Method";
   endlayout;
EndGraph;
 end;
run;
The INCLUDEMISSINGGROUP=TRUE option creates a separate group in the plot for
any missing values of the PURCHASE_METHOD column. If there are no missing
values for PURCHASE_METHOD in the data, the group is not created. Here is an
Appearance of Grouped Data
139

example of how to use a FORMAT statement to create a label for the missing group and
how to apply the format in the PROC SGRENDER statement.
/* Create a format for the missing order-type values */
proc format;
   value $ordertypefmt " "="Not Specified";
run;
/* Generate the chart */
proc sgrender data=surveydata template=survey;
format purchase_method  $ordertypefmt.;
run;
ods graphics off;
Changing the Grouped Data Order
When unique group values are gathered, they are internally recorded in the order in
which they appear in the data. They are not subsequently sorted. As a result, the group
values appear in the plot in the order in which they occur in the data. Here is an example.
ods html style=stocks;
proc sgrender data= sashelp.stocks template=group;
 where date between
       "1jan02"d and "31dec04"d;
run;
Note: Custom style STOCKS was created in Table 6.1 on page 136.
In this example, the groups are ordered in the order in which they appear in the
Sashelp.Stocks data set. Assume that you want to arrange the groups in ascending order.
One way to do this is to use the SORT procedure to create a sorted data set to use with
your plot. Here is an example.
proc sort data=sashelp.stocks out=stocks;
   by descending stock;
run;
ods html style=stocks;
140
Chapter 6
•
Managing Graph Appearance: General Principles

proc sgrender data= stocks template=group;
 where date between
       "1jan02"d and "31dec04"d;
run;
Changing the order of the data changes the order in which the group values appear on
the plot. It also changes their association with the GraphData1–GraphDataN style
elements, which might change their appearance. This is apparent in the previous
example.
Another way to arrange your data is to use the GROUPORDER= option. For many plots,
you can instead use the GROUPORDER= option to change the order of the groups in
your plot without having to create a sorted data set or change the order of the data in the
original data set.
Note: The GROUPORDER= option is ignored if the GROUP= option is not used.
The GROUPORDER= option determines the default order of groups in the legend and
the order of the groups within each category. It does not change the association of the
GraphData1–GraphDataN style attributes with the group values. You can set
GROUPORDER= to one of the values that is shown in the following table.
Value
Description
DATA
Displays the group values in the order in
which they appear in the plot data (default)
ASCENDING
Displays the group values in ascending order
DESCENDING
Displays the group values in descending order
The attributes of the missing group value are determined by the GraphMissing style
element except when the MISSING= system option is used to assign a missing character
other than "." or when a user-defined format is applied to the missing group value. In
those cases, the attributes of the missing group value are determined by a GraphData1-
GraphdDataN style element based on data order instead of the GraphMissing style
element.
Appearance of Grouped Data
141

Note: Using the GROUPORDER=ASCENDING or GROUPORDER=DESCENDING
option performs a linguistic sort on the group items and has the same effect as
sorting the input data. However, the data is not changed.
Making the Appearance of Grouped Data Independent of Data Order
About Grouped Data Appearance and Data Order
When the input data source is modified, sorted, or filtered, the order of the group values
and their associations with GraphData1–GraphDataN might change. If you do not care
which line pattern, marker symbols, or colors are associated with particular group
values, this might not be a problem. However, there might be cases in which you want
the appearance of your plots to be consistent. For example, if you create several stock
market plots grouped by STOCK, you might want a consistent set of visual properties
for each stock name across all of the plots, regardless of the input data order.
There are two methods that you can use to achieve visual consistency regardless of the
data order: you can use a discrete attribute map to assign attributes to specific group
values or you can use the INDEX= option map group values to specific graphData1–
graphDataN style elements. This section shows you how to use both methods.
Using a Discrete Attribute Map to Achieve Data-Independent
Appearance for Grouped Plots
You can use a discrete attribute map to associate visual attributes to specific group
values, which enables you to make plots that are consistent regardless of the data order.
Here is an example of a stock plot that is visually consistent regardless of the order of
the data. This example plots the closing stock price for IBM, Microsoft, and Intel. In this
example, we want the plot to always use the attributes shown in the following table for
each plot.
Stock
Line Pattern
Marker
Line and Marker
Color
IBM
solid
filled circle
blue
Intel
solid
filled square
orange
Microsoft
solid
filled triangle
dark red
To enforce this consistency, we must create a discrete attribute map that maps the
desired attributes to the stock values. Here is the code for this example.
/* Define the graph template. */
proc template;
define statgraph groupindex;
   begingraph;
      /* Create an attribute map for this graph. */
      discreteattrmap name="stockname" / ignorecase=true;
         value "IBM" /
            markerattrs=GraphData1(color=blue  symbol=circlefilled)
            lineattrs=GraphData1(color=blue pattern=solid);
         value "Intel" /
            markerattrs=GraphData2(color=orange symbol=squarefilled)
            lineattrs=GraphData2(color=orange pattern=solid); 
142
Chapter 6
•
Managing Graph Appearance: General Principles

         value "Microsoft" /
            markerattrs=GraphData3(color=darkred symbol=trianglefilled)
            lineattrs=GraphData3(color=darkred pattern=solid);    
      enddiscreteattrmap;
      /* Create the attribute map variable. */
      discreteattrvar attrvar=stockmarkers var=stock
         attrmap="stockname";
      /* Define the graph. */
      entrytitle "Tech Stocks 2002-2004";
      entryfootnote halign=left "Source: SASHELP.STOCKS";
      layout overlay ;  
         seriesplot x=date y=close / group=stockmarkers 
            name="series" lineattrs=(thickness=2) display=(markers);      
         discretelegend "series"; 
      endlayout;
   endgraph;
end;
run;
 
/* Render the graph. */
proc sgrender data= sashelp.stocks template=groupindex;
 where date between "1jan02"d and "31dec04"D;  
run;
Note: Custom style STOCKS was created in Table 6.1 on page 136.
The following figure shows the output of this program.
Figure 6.4
Graph Using a Discrete Attribute Map
To verify that the plot attributes are consistent regardless of the data order, we can create
a temporary data set from the Sashelp.Stocks data set and sort it by date and stock name
as shown in the following code.
/* Sort the SASHELP.STOCKS data by date and stock name. */
proc sort data=sashelp.stocks out=work.stocks;
   by date descending stock;
run;
Appearance of Grouped Data
143

Next, we can generate the graph again using the sorted data set.
/* Render the graph. */
proc sgrender data= stocks template=groupindex;
 where date between "1jan02"d and "31dec04"D;  
run;
The following figure shows the output.
Figure 6.5
Graph with the Data in Descending Order
Notice that the colors, line patterns, and markers remain the same for each stock even
though the data order has changed. For more information about using discrete attribute
maps, see “Using Attribute Maps to Control the Appearance of Grouped Data” on page
127.
Using the INDEX= Option to Achieve Data-Independent Appearance
for Grouped Plots
You can use the INDEX= option to specify a column in your data set that maps
graphData1–graphDataN style elements to specific group values. This enables you to
make plots that are visually consistent regardless of the data order. Here is the example
in “Using a Discrete Attribute Map to Achieve Data-Independent Appearance for
Grouped Plots” on page 142 modified to use the INDEX= option instead of a discrete
attribute map to achieve the same result.
To enforce this consistency, we must:
•
add numeric column IDX to the data set that maps the stock values to a graphDataN
style element as follows:
1
IBM
2
Intel
3
Microsoft
•
specify the INDEX=IDX option in the SERIESPLOT statement. This will map
graphData1 to IBM, graphData2 to Intel, and graphData3 to Microsoft regardless of
the data order.
144
Chapter 6
•
Managing Graph Appearance: General Principles

Here is the code for this example.
/* Add the IDX column to the data set */
data stocks;
   set sashelp.stocks;
   if (stock="IBM") then idx=1;
   else if (stock="Microsoft") then idx=2;
      else if (stock="Intel") then idx=3;
run;
/* Create the template for the graph */
proc template;
define statgraph groupindex;
   begingraph;
      /* Define the graph. */
      entrytitle "Tech Stocks 2002-2004";
      entryfootnote halign=left "Source: SASHELP.STOCKS";
      layout overlay ;  
         seriesplot x=date y=close / index=idx group=stock
            name="series" lineattrs=(thickness=2) display=(markers);      
         discretelegend "series"; 
      endlayout;
   endgraph;
end;
run;
 
/* Render the graph using the custom style. */
ods _all_ close;
ods html style=stocks;
proc sgrender data= stocks template=groupindex;
 where date between "1jan02"d and "31dec04"D;  
run;
Note: Custom style STOCKS was created in Table 6.1 on page 136.
The output is the same as that shown in Figure 6.4 on page 143.
As described in “Using a Discrete Attribute Map to Achieve Data-Independent
Appearance for Grouped Plots” on page 142, if we sort the data and generate the graph
again, the visual attributes of the graph remain the same as that shown in Figure 6.5 on
page 144.
Attribute Rotation Patterns
About the Attribute Rotation Patterns
By default, attributes such as colors, marker symbols, fill patterns, and line patterns are
rotated for group values in a grouped plot or for each plot in an overlay when
CYCLEATTRS=TRUE. The attributes are derived from the GraphData1–GraphDataN
style elements for the style that is in effect. There are two distinct attribute rotation
patterns: the default pattern and the color-priority pattern. These patterns are described in
“The Default Attribute Rotation Pattern” on page 146 and “The Color-Priority Attribute
Rotation Pattern” on page 149.
Attribute Rotation Patterns
145

The rotation pattern that is used is determined by the AttrPriority attribute in the current
style, by the ATTRPRIORITY= option in the ODS GRAPHICS statement, or by the
ATTRPRIORITY= option in the BEGINGRAPH statement. The ODS GRAPHICS
statement ATTRPRIORITY= option value is AUTO by default, which enables the
AttrPriority attribute in the current style to determine the rotation pattern. In that case, if
the current style’s AttrPriority attribute specifies COLOR, the color-priority rotation
pattern is used. If the current style does not specify the AttrPriority attribute or specifies
AttrPriority="NONE", the default rotation pattern is used. The ODS GRAPHICS
statement ATTRPRIORITY= option can override the current AttrPriority style attribute
setting with NONE or COLOR. (See “ODS GRAPHICS Statement” in SAS Output
Delivery System: User's Guide.) The BEGINGRAPH statement ATTRPRIORITY=
option overrides the ODS GRAPHICS statement ATTRPRIORITY= option for all plots
in a BEGINGRAPH block. (See ATTRPRIORITY=.)
With both the default rotation pattern and the color-priority pattern, the plot appearance
is dependent on the data order. Any change in the data order can affect the appearance of
grouped plots.
T I P
To make the appearance of your grouped plots independent of data order, use a
discrete attribute map or the INDEX= option (where supported) to control the
appearance of your group values. See “Making the Appearance of Grouped Data
Independent of Data Order” on page 142.
The Default Attribute Rotation Pattern
The default rotation iterates through the lists of colors, marker symbols, fill patterns
(when supported), and line patterns as they are defined in the GraphData1–GraphDataN
style elements.
Note: Fill patterns are supported only by selected ODS styles such as JOURNAL2 and
MONOCHROMEPRINTER. For more information, see SAS Output Delivery
System: User's Guide.
For the contrast colors, marker symbols, fill patterns, and line patterns, when all of the
values in the list have been used, the values iterate through the list again. For the area fill
colors, when all of the values have been used, two new sets of colors are automatically
generated, which are based on the original colors. The first set is one shade lighter than
the original colors, and the second set is one shade darker.
The number of unique attribute combinations that are available depends on the ODS
style that is being used. The DEFAULT style, for example, defines the attributes that are
shown in the following table.
Table 6.2
Colors, Marker Symbols, and Line Patterns Defined in the DEFAULT Style
Style Element
Color*
Contrast Color*
Marker
Symbol**
Line Pattern***
GraphData1
cx7C95CA
cx2A25D9
CIRCLE
1
GraphData2
cxDE7E6F
cxB2182B
PLUS
4
GraphData3
cx66A5A0
cx01665E
X
8
GraphData4
cxA9865B
cx543005
TRIANGLE
5
GraphData5
cxB689CD
cx9D3CDB
SQUARE
14
146
Chapter 6
•
Managing Graph Appearance: General Principles

Style Element
Color*
Contrast Color*
Marker
Symbol**
Line Pattern***
GraphData6
cxBABC5C
cx7F8E1F
ASTERISK
26
GraphData7
cx94BDE1
cx2597FA
DIAMOND
15
GraphData8
cxCD7BA1
cxB26084
20
GraphData9
cxCF974B
cxD17800
41
GraphData10
cx87C873
cx47A82A
42
GraphData11
cxB7AEF1
cxB38EF3
2
GraphData12
cxDDD17E
cxF9DA04
* The colors are defined by GDATA1 through GDATA12, and the contrast colors are defined by
GCDATA1 through GCDATA12 in the style template.
** See the SYMBOL= option in “Marker Options” on page 496.
*** See “Available Line Patterns” on page 497.
These attribute definitions yield the following results:
•
36 unique area fill colors (12 base colors + 12 lighter colors + 12 darker colors)
•
84 unique marker symbol and color combinations (7 symbols x 12 contrast colors or
fill colors)
•
132 unique line color and line pattern combinations (11 patterns x 12 contrast colors)
When area fill colors are rotated, the colors first iterate through the 36 unique colors (the
12 base colors, the 12 lighter colors, and finally the 12 darker colors). The entire pattern
repeats starting with the 37th iteration. The following figure shows one complete fill
color rotation cycle for the DEFAULT style.
When marker symbol attributes are rotated, the marker symbols first iterate through the
seven symbols and the first seven contrast colors (unfilled markers). On the eighth
iteration, the first marker symbol (CIRCLE in this case) is repeated with the eighth
contrast color. The next four symbols are then repeated with the remaining three contrast
colors. On the 13th iteration, the first contrast color is repeated with the fifth marker
symbol (SQUARE in this case). This pattern continues for the remaining group values.
The entire pattern repeats, starting with the 85th iteration.
Note: For filled markers and outlined filled markers, the marker fill colors rotate
through the fill colors that are defined in the GraphData1–GraphDataN style
Attribute Rotation Patterns
147

elements. Unlike area fill colors, new lighter and darker colors are not generated for
the marker fills. The marker fill colors simply repeat.
The following figure shows the complete standard rotation of marker symbols and
symbol colors for the DEFAULT style.
When line attributes are rotated, the line patterns first iterate through the 11 line patterns
with the first 11 contrast colors. On the 12th iteration, the first line pattern (1) is repeated
with the 12th contrast color (see “Available Line Patterns” on page 497). On the 13th
iteration, the first contrast color is repeated with the second line pattern (4). This pattern
continues for the remaining group values. The entire pattern repeats, starting with the
133rd iteration.
The following figure shows the complete standard rotation of line styles and line colors
for the DEFAULT style.
Some styles such as JOURNAL2 provide fill pattern as an additional attribute. By
default, the fill patterns rotate as they are defined in the GraphData1–GraphDataN style
elements. The JOURNAL2 style, for example, provides 12 gray-scale fill colors and 15
unique fill patterns, which yield 180 unique fill color and fill pattern combinations. The
148
Chapter 6
•
Managing Graph Appearance: General Principles

following figure shows the default fill color and fill pattern rotation for the first 36
iterations using the JOURNAL2 style.
The Color-Priority Attribute Rotation Pattern
The color-priority rotation pattern alters the rotation of marker symbol and line
attributes, and fill patterns (when supported) only. Area fill-color rotation follows the
default rotation in the color-priority pattern. In the color-priority rotation pattern, the
marker symbol, line pattern, or fill pattern is held constant while each color in the list is
applied to the marker symbol, line, or area. The number of unique combinations is
unchanged from the default rotation pattern. The examples in this section use the
DEFAULT style to describe the color-priority rotation pattern so that you can compare
the two patterns. See Table 6.2 on page 146.
Note: Because the DEFAULT style does not define the AttrPriority="COLOR" style
attribute, in order to activate the color-priority rotation pattern, you must specify the
ATTRPRIORITY=COLOR option in an ODS GRAPHICS statement in your SAS
program or in the BEGINGRAPH statement in your template. See
ATTRPRIORITY=.
When marker attributes are rotated, the first symbol (CIRCLE in this case) is held
constant while the colors iterate through the entire list of contrast colors (unfilled
markers). On the 13th iteration, the marker symbol changes to the second symbol in the
list (PLUS in this case), which is held constant while the colors iterate again. This
pattern continues for the remaining group values. The entire pattern repeats, starting with
the 85th iteration.
Attribute Rotation Patterns
149

The following figure shows the complete color-priority rotation of marker symbols and
symbol colors for the DEFAULT style.
When line attributes are rotated, the first line pattern (1) is held constant while the colors
iterate through the entire list of contrast colors (see “Available Line Patterns” on page
497). On the 13th iteration, the line pattern changes to the second pattern (4), which is
held constant while the colors iterate again. This pattern continues for the remaining
group values. The entire pattern repeats, starting with the 133rd iteration.
The following figure shows the complete color-priority rotation of line styles and line
colors for the DEFAULT style.
When fill patterns are rotated, the first pattern is held constant while the fill colors rotate
through the entire list of fill colors. When all of the fill colors have been used, the next
fill pattern is held constant while the fill colors iterate again. This pattern continues for
the remaining fill patterns. The following figure shows the color-priority fill color and
fill pattern rotation for the first 36 iterations using the JOURNAL2 style.
150
Chapter 6
•
Managing Graph Appearance: General Principles

Data Skins
Data skins add a heightened visual effect to two-dimensional plots and pie charts that are
generated using the GTL. Each skin uses shading, highlighting, and shadowing to give
the appearance of contour and depth to certain elements of a graph, including the legend.
For plots, the effect is generated by filters and is applied to filled areas, markers, and
lines. When a data skin is applied to a filled area, it does not change the underlying fill
color and pattern of the area, but it does set the area fill outline color to black. In that
case, the outline color is controlled by the filters that generate the skin and is not
controlled by the ODS style attributes. As a result, when a data skin is applied, the area
fill outline is black regardless of the ODS style that is in effect or any custom outline
attributes that are specified.
Data skins can be specified in the following GTL plot statements:
BARCHART
HISTOGRAM
SCATTERPLOTMATRIX
BARCHARTPARM
HISTOGRAMPARM
SERIESPLOT
BOXPLOT
LINECHART
STEPPLOT
BOXPLOTPARM
NEEDLEPLOT
VECTORPLOT
BUBBLEPLOT
PIECHART
WATERFALLCHART
DROPLINE
REFERENCELINE
HIGHLOWPLOT
SCATTERPLOT
Data skins can be applied to filled areas, markers, and lines in a plot. The data skins
include SHEEN, GLOSS, PRESSED, CRISP, and MATTE. The following figure shows
each of the data skins applied to the filled areas of a bar chart and a pie chart.
Note: A display with no data skin applied is included for comparison.
Data Skins
151

The next figure shows each of the data skins applied to large HOMEDOWNFILLED
markers.
Finally, the next figure shows each of the data skins applied to lines.
152
Chapter 6
•
Managing Graph Appearance: General Principles

For all plots that support data skins, by default, the GraphSkin:DataSkin style element in
the active style specifies the data skin that is applied. For all of the plots in a template,
you can use the DATASKIN= option in the BEGINGRAPH statement to override the
data skin specified by the current style. For an individual plot, you can use the
DATASKIN= option in the plot statement to override the data skin that is specified by
the current style or the BEGINGRAPH statement’s DATASKIN= option. The style
GraphSkin:DataSkin element and the DATASKIN= options can be set to one of the
following values: NONE, SHEEN, GLOSS, PRESSED, CRISP, or MATTE.
Subpixel Rendering
You can specify subpixel rendering in order to generate smooth curves and more precise
bar spacing in plots that are generated using the following statements:
BANDPLOT
HIGHLOWPLOT
REGRESSIONPLOT
BARCHART
LINECHART
SERIESPLOT
BARCHARTPARM
LOESSPLOT
DENSITYPLOT
PBSPLINEPLOT
The SAS default rendering technology for ODS Graphics is used to render curved lines
for GTL plots. For the Java technology, for example, subpixel rendering is not used by
default. In that case, curved lines can appear slightly jagged. The following figure shows
a series plot with smoothed lines (SMOOTHCONNECT=TRUE) that was rendered with
Java technology, using the default line rendering.
Subpixel Rendering
153

Notice that the line curves appear slightly jagged.
To enable subpixel rendering, include the SUBPIXEL=ON option in your
BEGINGRAPH statement. In order to use subpixel rendering, anti-aliasing must also be
enabled. Anti-aliasing is enabled by default. If it is disabled, include the
ANTIALIAS=ON option in your ODS GRAPHICS statement.
T I P
For a large amount of data, anti-aliasing is disabled when the number of
observations exceeds the default maximum of 4000. In that case, subpixel rendering
is also disabled. To increase the maximum number of observations, include the
ANTIALIASMAX= option in your ODS GRAPHICS statement.
The next figure shows the same series plot generated with SUBPIXEL=ON, anti-aliasing
enabled and smoothed lines.
Notice that the line curves are much smoother. Here is the SAS code for the previous
graph.
/* Sort the SASHELP.STOCKS data by date. */
proc sort data=sashelp.stocks out=stocks;
   by date;
run;
154
Chapter 6
•
Managing Graph Appearance: General Principles

/* Create the template for the graph. */
proc template;
   define statgraph subpixelon;
       begingraph / subpixel=on; 
       entrytitle "Stock Index Performance: 2001";
       layout overlay / 
          xaxisopts=(label="Month" griddisplay=on
             gridattrs=(pattern=dot color=lightgray))
          yaxisopts=(label="Average Close" type=linear
             linearopts=(viewmin=10) griddisplay=on
             gridattrs=(pattern=dot color=lightgray));   
          seriesplot x=eval(put(date, monname3.)) y=close / 
             name="stocks"
             group=stock
             smoothconnect=true;
          discretelegend "stocks";
       endlayout;   
    endgraph;
 end;
 /* Render the graph for the year 2001. */
proc sgrender data=stocks template=subpixelon;
  where year(date) = 2001;
run;
Recommendations
The issue of when to use hardcoded values versus style references for overriding
appearance features is complex and basically boils down to what you are trying to
achieve with GTL. Here are some recommendations that are based on common use
cases:
•
You are creating a graph for a specific purpose and probably will not use the code
again.
Recommendation: Develop your template code with one style in mind and use
hardcoded overrides to make desired changes. One possibility is to use the
JOURNAL style as a starting point. It has a gray-scale color scheme. If you want to
introduce colors for certain parts the graph, there will not be much conflict with
blacks and grays coming from the style. You really do not care what the graph looks
like with another style.
•
You are creating a reusable graph template (without hardcoded variable names) that
can be used with different sets of data in different circumstances.
Recommendation: If style overrides are needed, use style-reference overrides, not
hardcoded overrides. This allows your graph's appearance to change appropriately
when you (or someone else) uses a different style.
•
You want all of your templates to produce output with the same look-and-feel,
possibly a corporate theme.
Recommendation: Spend time developing a new style that produces the desired
"look-and-feel" rather than making a lot of similar appearance changes every time
you create a new graph template to enforce consistency. Be sure to coordinate the
colors and fonts for the graphical style elements with tabular style elements. See
Recommendations
155

Chapter 18, “Managing the Graph Appearance with Styles,” on page 391 for more
information.
156
Chapter 6
•
Managing Graph Appearance: General Principles

Chapter 7
Adding and Changing Text in a
Graph
Text Strings in Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
Text Properties and Syntax Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
Text Statement Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
Using Titles and Footnotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
Using Text Entries in the Graphical Area . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
Managing the String on Text Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
Text Statement Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
Using Rich Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
Horizontally Aligning Text Items . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
Generating Text Items with Dynamics, Macro Variables, and Expressions . . . . . 164
Adding Subscripts, Superscripts, and Unicode Rendering . . . . . . . . . . . . . . . . . . . 165
Using Unicode Values in Labels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
Using Options on Text Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
Options Available on All Text Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
Setting Text Background, Borders, and Padding . . . . . . . . . . . . . . . . . . . . . . . . . . 167
Managing Long Text in Titles and Footnotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
ENTRY Statements: Additional Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
Features Available for ENTRY Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
Positioning ENTRY Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
Rotating ENTRY Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
Text Strings in Graphs
Using the GTL, you can add and control text that appears in your graph. The annotation
in the following diagram indicates some of the options and statements that are used to set
the text in a typical graph.
157

The following options, available on plot and legend statements, manage most of the text
that you can add to a graph:
Task
Statement
Option
label data points
plot statements that
display markers
DATALABEL=column
label a curve or a reference
line
plot statements that
display lines
CURVELABEL="string" | column
describe a plot in a legend
most plot statements
LEGENDLABEL="string"
add title to a legend
legend statements
TITLE="string"
label an axis
axis statement or layout
axis option
LABEL="string"
The GTL also provides the following text statements that can be used to add custom
information about the graph analysis or the graph display. This text is independent of the
text that is managed by the options on plot and legend statements:
ENTRYTITLE "string"
Defines title text for the entire graph.
ENTRYFOOTNOTE "string"
Defines footnote text for the entire graph.
ENTRY "string"
Defines text that is displayed in the graphical area.
158
Chapter 7
•
Adding and Changing Text in a Graph

This chapter focuses primarily on how to set text properties for any text. Additional
information about text-related features for axes, legends, insets, and multi-cell layouts is
available in other chapters:
•
For managing the text in axes, see Chapter 5, “Managing Axes in an OVERLAY
Layout,” on page 63.
•
For managing the text in legends, see Chapter 8, “Adding Legends to a Graph,” on
page 175.
•
For managing the text in insets, see Chapter 17, “Adding Insets to a Graph,” on page
355.
•
For managing the text in multi-cell layouts, see Chapter 10, “Using an Advanced
Multi-cell Layout,” on page 225 and Chapter 11, “Using Classification Panels,” on
page 257.
Text Properties and Syntax Conventions
All options or statements that define text strings have supporting text options that enable
you to set the color and font properties of the text. The following table shows some of
the supporting text options that are available:
Statement Type
Option
Supporting Text Option
plot statements
DATALABEL=
DATALABELATTRS=
CURVELABEL=
CURVELABELATTRS=
legend statements
TITLE=
TITLEATTRS=
layout or axis
statements
LABEL=
LABELATTRS=
text statements
TEXTATTRS=
The supporting text options all have similar syntax:
supporting-text-option = style-element | style-element ( text-options ) | ( text-options )
All supporting-text-options use a style element to determine their default characteristics.
Thus, when a different ODS style is applied to a graph, you might see different fonts,
font sizes, font weights, and font styles used for various pieces of text in the graph. See
“Options That Override Attributes for Individual Plots” on page 117 for a full discussion
of how style elements and override options work.
Any text that you add to the graph can have the following properties for the text-options:
Text Option
Value
Examples
COLOR=
color | style-reference
( color=black)
(color=GraphLabelText:color)
Text Properties and Syntax Conventions
159

Text Option
Value
Examples
FAMILY=
" font-name " | style-reference
(family="Arial Narrow")
(family=GraphLabelText:FontFamily)
SIZE=
dimension | style-reference
(size=10pt)
(size=GraphLabelText:FontSize)
WEIGHT=
NORMAL | BOLD | style-
reference
(weight=bold)
(weight=GraphLabelText:FontWeight)
STYLE=
NORMAL | ITALIC | style-
reference
(style=italic)
(style=GraphLabelText:FontStyle)
For more information about text-options, see “Text Options” on page 497.
Several style elements affect text in different parts of a graph. Each style element defines
attributes for all of its available text options. The following table shows some of the style
elements that are available for setting text attributes:
Style Element
Default Use
GraphTitleText
Used for all titles of the graph. This text typically uses the largest font
size among fonts in the graph.
GraphFootnoteText
Used for all footnotes. This text typically uses a smaller font size than
the titles. Sometimes, footnotes are italicized.
GraphLabelText
Used for axis labels and legend titles. This text generally uses a smaller
font size than titles.
GraphValueText
Used for axis tick values and legend entries. This text generally uses a
smaller font size than labels.
GraphDataText
Used for text where minimum size is necessary (such as point labels).
GraphUnicodeText
Used for adding special glyphs (for example α , ±, € ) to text in the
graph.
GraphAnnoText
Default font for text that is added as annotation (using the ODS
Graphics Editor).
For example, to specify that axis labels should have the same text properties as axis tick
values, you could specify the following:
layout overlay / xaxisopts=( labelattrs=GraphValueText ) 
                 yaxisopts=( labelattrs=GraphValueText );
Style elements can also be used to modify the display of grouped data. For example, by
default, the text color of the data labels for grouped markers in a scatter plot changes to
match the marker color for each group value. To specify that grouped data labels should
use the same color as non-grouped data labels, you could specify the following:
160
Chapter 7
•
Adding and Changing Text in a Graph

scatterplot x=height y=weight / group=age datalabel=name
  datalabelattrs=( color=GraphDataText:Color ) ;
To ensure that a footnote is displayed in bold italics, you could specify the following:
entryfootnote "Study conducted in 2007" /
  textattrs=( weight=bold style=italic ) ;
Because the other font properties are not overridden in this example, they are obtained
from the GraphFootnoteText style element.
Text Statement Basics
The ENTRYTITLE, ENTRYFOOTNOTE, and ENTRY statements add text to
predefined areas of the graph. The text that they add cannot be specified by the options
that are available in plot, axis, legend, or layout statements.
Using Titles and Footnotes
To add titles or footnotes to a graph, use one or more ENTRYTITLE or
ENTRYFOOTNOTE statements. These statements must appear inside the
BEGINGRAPH block, but outside any layout blocks. The following code shows the
typical placement of these statements:
begingraph;
  entrytitle "Title One";
  entrytitle "Title Two";
  layout overlay;
    scatterplot x=height y=weight;
  endlayout;
  entryfootnote "Footnote One";
  entryfootnote "Footnote Two";
endgraph;
However, the following statement placement yields the same result:
begingraph;
  entryfootnote "Footnote One";
  entrytitle "Title One";
  layout overlay;
    scatterplot x=height y=weight;
  endlayout;
  entryfootnote "Footnote Two";
  entrytitle "Title Two";
endgraph;
Text Statement Basics
161

Note: a light gray border was added to the graph area to indicate the boundaries between
the separate areas.
Unlike SAS TITLE and FOOTNOTE statements, the GTL statements are not numbered.
If you include multiple ENTRYTITLE or ENTRYFOOTNOTE statements, the titles or
footnotes will be stacked in the specified order —all ENTRYTITLE statements are
gathered and placed in the ENTRYTITLE area at the top of the graph, and all
ENTRYFOOTNOTE statements are gathered and placed in the ENTRYFOOTNOTE
area at the bottom of the graph.
You can add as many titles and footnotes as you want. However, the space that is needed
to accommodate the titles and footnotes always decreases the height of the graphical
area. For graphs with extensive titles or footnotes, you should consider enlarging the
graph size. For a discussion on sizing graphs, see “Controlling Graph Size” on page
455.
Using Text Entries in the Graphical Area
An ENTRY statement defines text within the graphical area. Here is a simple example
that places text in the upper left corner of the plot wall area:
layout overlay;
  scatterplot x=height y=weight;
  entry halign=left "NOBS = 19" /
        valign=top border=true;
endlayout;
162
Chapter 7
•
Adding and Changing Text in a Graph

You can use multiple ENTRY statements in conjunction with GRIDDED layouts to
create tables of text and complex insets.
This example is discussed in detail in Chapter 17, “Adding Insets to a Graph,” on page
355.
Managing the String on Text Statements
Text Statement Syntax
Options on the ENTRYTITLE, ENTRYFOOTNOTE, and ENTRY text statements
enable you to create simple or complex text constructs. The following syntax shows the
general form of these statements:
TEXT-STATEMENT text-item < … <text-item>> / <options>;
Any text-item is some combination of the following:
<prefix-option … <prefix-option>> "string" | dynamic | character-expression |
{text-command}
Managing the String on Text Statements
163

What this means is that the final text that is to be created can be specified in a series of
separate items, each with individual prefix options. Statement options can also affect the
final text. These possibilities are explained by the examples in the following sections.
Using Rich Text
"Rich text" describes text in which each character can have different text properties. The
following example creates rich text by separating the text into pieces and using prefix
options to set different text properties for each piece. Properties that are set this way stay
in effect for subsequent text items, unless changed by another TEXTATTRS= prefix
option.
entrytitle textattrs=(size=12pt color=red) "Hello "
           textattrs=(size=10pt color=blue style=italic) "World"; 
Here is the output.
For each horizontal alignment, the overall text for these statements is formed by the
concatenation of the text items. Notice that there is no concatenation operator and that
any spacing (such as word breaks) must be provided as needed within the strings ("Hello
" "World"). The space that separates the text-item specifications is never included in the
final text string.
Horizontally Aligning Text Items
Text items can have different horizontal alignments: LEFT, CENTER, or RIGHT. The
default alignment is CENTER. Text items with the same alignment are gathered and
concatenated.
entryfootnote halign=left textattrs=(weight=bold) "XYZ Corp."
              halign=right textattrs=(weight=normal) "30JUN08";
Here is the output.
Generating Text Items with Dynamics, Macro Variables, and
Expressions
Text items are not limited to string literals. Text items can also be defined as dynamics,
macro variables, or expressions. In the following example, SYSDATE is declared with
an MVAR template statement. As a result, this automatic macro variable is resolved to
today's date at run time.
entryfootnote halign=left textattrs=(weight=bold) "XYZ Corp."
              halign=right textattrs=(weight=normal) SYSDATE ;
164
Chapter 7
•
Adding and Changing Text in a Graph

Here is the output.
This next example shows how the GTL EVAL function causes an expression to be
evaluated at run time. In this case, the PUT function (same as the PUT function in the
DATA step) is used to convert a SAS date value into a string:
entryfootnote "Summary for "  eval(put(today(),mmddyyd.)) ;
Here is the output.
For more information about dynamics, macro variables, and EVAL expressions in GTL,
see Chapter 14, “Using Dynamics and Macro Variables to Make Flexible Templates,” on
page 327 and Chapter 15, “Using Conditional Logic and Expressions,” on page 337.
Adding Subscripts, Superscripts, and Unicode Rendering
You can build strings with subscripts or superscripts using the {SUB "string" } or {SUP
"string" } text commands. You can also use dynamics or macro variables for the string
portion of the text command.
entryfootnote "R" {sup "2"} "=.457"; 
entryfootnote "for the H" {sub "2"} "O Regression" ;
Here is the output.
Another way to form text is to use the {UNICODE "hex-value"x } text command. For
fonts that support Unicode code points, you can use the following syntax to render the
glyph (character) corresponding to any Unicode value:
entryfootnote  {unicode "03B1"x} "=.05" ;
In the code, the "03B1"x is the hexadecimal code point value for the lowercase Greek
letter alpha. Because Greek letters and some other statistical symbols are so common in
statistical graphics, keyword short cuts to produce them have been added to GTL syntax.
So another way of indicating "03B1"x is
entryfootnote  {unicode alpha} "=.05" ;
Here is the output.
For a complete list of keywords that can be used with the {unicode keyword}
notation, see Appendix 1, “Reserved Keywords and Unicode Values,” on page 475. For
rules regarding specifying Unicode and other special characters, see “Rules for Unicode
Managing the String on Text Statements
165

and Special Character Specifications” in Chapter 10 of SAS Graph Template Language:
Reference.
In addition, any Unicode glyph for currency, punctuation, arrows, fractions and
mathematical operators, symbols, and dingbats can be used. Fonts such as Arial
(comparable to SAS-supplied Albany AMT) have many, but not all, Unicode code
points available, and sometimes a more complete Unicode font such as Arial Unicode
MS (or SAS-supplied Monotype Sans WT J) needs to be specified. ODS styles have a
style element named GraphUnicodeText that can be safely used for rendering any
Unicode characters. The following example uses the GraphUnicodeText style element
for rendering a bar over the X:
entry  "X"{unicode bar}"=6.78" / textattrs=GraphUnicodeText;
Here is the output.
Using Unicode Values in Labels
The {UNICODE}, {SUB}, and {SUP} text commands apply only to the ENTRY,
ENTRYTITLE, and ENTRYFOOTNOTE statements. However, strings that are assigned
to axis labels, curve labels, legend labels, and so on, can present Unicode characters
using what is called "in-line formatting." To use this special formatting, you embed
within the string an ODS escape sequence followed by a text command. Specifically,
whenever you use an ODS ESCAPECHAR= statement to define an escape character,
and then include that escape character in a quoted string, it signals that the next token
represents a text command. Currently, only the {UNICODE} text command is
recognized, not {SUB} or {SUP}. For rules regarding specifying Unicode characters,
see “Rules for Unicode and Special Character Specifications” in Chapter 10 of SAS
Graph Template Language: Reference.
In the following example, the alpha value for the upper and lower confidence limits is
displayed using the Greek letter alpha:
ods escapechar="^"; /* Define an escape character */
proc template;
  define statgraph fit;
    begingraph;
      entrytitle "Regression Fit Plot with CLM Band";
      layout overlay;    
        modelband "clm" / display=(fill)  name="band"
          legendlabel="^{unicode alpha}=.05" ;
        scatterplot x=height y=weight / primary=true  ;
        regressionplot x=height y=weight / alpha=.05 clm="clm"
          legendlabel="Linear Regression" name="fit";
        discretelegend "fit" "band";
      endlayout;
    endgraph;
  end;
run;
proc sgrender data=sashelp.class template=fit;
run;
166
Chapter 7
•
Adding and Changing Text in a Graph

Using Options on Text Statements
Options Available on All Text Statements
The ENTRYTITLE, ENTRYFOOTNOTE, and ENTRY text statements provide options
that apply to all of the text-items that form the text string (unlike the prefix options,
which can be applied to pieces of the text).
TEXT-STATEMENT text-item < … <text-item>> / <options>;
The following options are available on all of the text statements:
BACKGROUNDCOLOR= style-reference | color
Specifies the color of the text background.
BORDER= boolean
Specifies whether a border line is displayed around the text.
BORDERATTRS= style-element | style-element (line-options) | (line-options)
Specifies the properties of the border line. For information about line-options, see
“Line Options” on page 494.
OPAQUE= boolean
Specifies whether the entry background is opaque.
TEXTATTRS=style-element | style-element (text-options) | (text-options)
Specifies the font attributes of all text. For information about text-options, see “Text
Options” on page 497. If a TEXTATTRS= prefix option is also used, it takes
precedence over this statement option.
Setting Text Background, Borders, and Padding
By default, the background of all text is transparent. To specify a background color, you
must specify OPAQUE=TRUE to turn off transparency, which then enables you to
specify a background color. In the following example, the fill color of the band is
specified for the background of the entry text. A border is also added.
Using Options on Text Statements
167

Note: Data points that are behind the entry text are obscured when OPAQUE=TRUE.
begingraph;
  entrytitle "Regression Plot";
  entryfootnote halign=right 
   "Prepared with SAS" {unicode "00AE"x} " Software" /  
    textattrs=(size=9pt); 
  layout overlay;  
    modelband "clm";
    scatterplot x=height y=weight;
    regressionplot x=height y=weight / clm="clm" alpha=.05;
    entry {unicode alpha} " = .05" / autoalign=auto border=true
      opaque=true backgroundcolor=GraphConfidence:color ;
  endlayout; 
endgraph; 
Notice that extra space appears between the entry border and the text. This space is
called padding and can be set with the PAD= option. The default padding is
ENTRY "string" / PAD=(LEFT=3px RIGHT=3px TOP=0 BOTTOM=0) border=true;
You can set the padding individually for the LEFT, RIGHT, TOP, and BOTTOM
directions, or you can set the same padding in all directions as follows:
ENTRY "string" / PAD=5px border=true;
Padding is especially useful when you want to add extra space between titles, or add
space between the last title (or first footnote) and the plot area in the graph:
begingraph;
  entrytitle "Regression Plot" / pad=(bottom=10px) ;
  entryfootnote halign=right 
   "Prepared with SAS" {unicode "00AE"x} " Software" /
    textattrs=(size=9pt) pad=(top=10px) ;
  layout overlay;
    modelband "clm";
    scatterplot x=height y=weight;
    regressionplot x=height y=weight / clm="clm" alpha=.05;
  endlayout;
endgraph;
168
Chapter 7
•
Adding and Changing Text in a Graph

Managing Long Text in Titles and Footnotes
When you change the size of a graph, the size of all fonts in the graph is scaled up or
down by default. However, when the graph size is reduced, even font scaling has limits
on what it can do with long text strings that are specified on ENTRYTITLE or
ENTRYFOOTNOTE statements. The following statement options are available to deal
with this situation:
TEXTFITPOLICY= WRAP | SHORT | TRUNCATE
SHORTTEXT= ( text-items )
By default, TEXTFITPOLICY=WRAP, and no default is defined for the
SHORTTEXT= option.
The text fitting policies take effect when the length of the text and/or its font properties
cause the text line to exceed the space available for it. The font properties include the
font family, font size, and font weight (BOLD or NORMAL). Thus, adjusting the length
of the text and/or changing its font properties are adjustments that you can make to fit
text in the available space. You can also use the TEXTFITPOLICY= and/or
SHORTTEXT= options.
The following long title uses the default fit policy, which is to wrap text that does not fit
on a single line:
entrytitle "This is a lot of text to display on one line";
Here is the output.
Notice that the current horizontal alignment (CENTER in this case) is used when text
wraps. Text is wrapped only at word boundaries (a space).
Using Options on Text Statements
169

Here is the output when the fit policy is set to TRUNCATE.
The ellipsis in the output text indicates where the truncation occurs. Rather than
truncating text, you can specify alternative "short" text to substitute whenever the
primary text does not fit without wrapping in the available space.
entrytitle "This is a lot of text to display on one line" / 
  textfitpolicy=short shorttext=("Short alternative text");
Here is the output.
ENTRY Statements: Additional Control
Features Available for ENTRY Text
ENTRY statements are more flexible than ENTRYTITLE or ENTRYFOOTNOTE
statements and support additional features for automatically positioning text, aligning
text vertically, and rotating text:
AUTOALIGN= NONE | AUTO | (location-list)
Specifies whether the entry is automatically aligned within its parent when nested
within an overlay-type layout.
ROTATE= 0 | 90 | 180 | 270
Specifies the angle of text rotation.
VALIGN= CENTER | TOP | BOTTOM
Specifies the vertical alignment of the text.
Positioning ENTRY Text
By default, any ENTRY statement that is defined within a 2-D overlay-type layout and
does not specify a location is placed in the center of the graph wall (HALIGN=CENTER
VALIGN=CENTER).
If you know where you want to place the text, one way to position it is to use the
HALIGN= and VALIGN= options, as shown in the following example:
layout overlay;
  scatterplot x=height y=weight;
  entry halign=left "NOBS = 19" /
        valign=top border=true;
endlayout;
170
Chapter 7
•
Adding and Changing Text in a Graph

Whenever you add text within the graph wall, you have to consider the possibility that
the text might appear on top of or behind data markers and plot lines. For this reason,
you should consider using the AUTOALIGN= option rather than the HALIGN= and
VALIGN= options for positioning the text.
The AUTOALIGN= option enables you to set a priority list that restricts the entry
location to certain locations. The priority list can include any of the keywords
TOPLEFT, TOP, TOPRIGHT, LEFT, CENTER, RIGHT, BOTTOMLEFT, BOTTOM,
and BOTTOMRIGHT.
In the following histogram, we know that the best location for an entry is either
TOPLEFT or TOPRIGHT, depending on the skewness of the data. With the following
coding, if the data were skewed to the right so that the entry text overlaps with the
histogram, the text would automatically appear at TOPLEFT.
layout overlay;
  histogram weight;
  entry  "NOBS = 19" /
    autoalign=(topright topleft)
    border=true;
endlayout;
When the parent layout contains only scatter plots, the ENTRY statement can use the
AUTOALIGN=AUTO setting to automatically position the text where it is the farthest
away from any scatter points. In all cases, even one like the following example where
many positions are available that might minimize data collision, the AUTO specification
selects the position for you and you have no further control over the text position.
layout overlay;
  scatterplot x=height y=weight;
  entry halign=left "NOBS = 19" /
        autoalign=auto border=true;
ENTRY Statements: Additional Control
171

endlayout;
Rotating ENTRY Text
ENTRY statements can appear in most layout types. For example, ENTRY statements
can be used to define the text that appears in a CELLHEADER block in a LATTICE
layout. You can also use ENTRY statements in SIDEBAR, ROWHEADERS, and
COLUMNHEADERS blocks.
In the following example, the ROWHEADERS block shows how to define rotated row
headers for a lattice layout. The complete code for this example is shown in “Defining a
Lattice with Additional Features” on page 240.
   rowheaders;
     layout gridded / columns=2;
       entry "Volume" / textattrs=GraphLabelText rotate=90 ;
       entry "(Millions of Shares)" / textattrs=GraphValueText rotate=90 ;
     endlayout;
     layout gridded / columns=2;
       entry "Price" / textattrs=GraphLabelText rotate=90 ;
       entry "(Adjusted Close)" / textattrs=GraphValueText rotate=90 ;
     endlayout;
  endrowheaders;
172
Chapter 7
•
Adding and Changing Text in a Graph

ENTRY Statements: Additional Control
173

174
Chapter 7
•
Adding and Changing Text in a Graph

Chapter 8
Adding Legends to a Graph
Introduction to Legend Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
Some of the Uses for a Legend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
Types of Legends in GTL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
General Syntax for Using Legends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
Example Legend Coding for Common Situations . . . . . . . . . . . . . . . . . . . . . . . . . 177
General Legend Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
Positioning Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
General Appearance Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
Features of Discrete Legends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
Placing the Legend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
Ordering the Legend Entries for a Grouped Plot . . . . . . . . . . . . . . . . . . . . . . . . . . 187
Ordering the Legend Entries for Non-grouped Plots . . . . . . . . . . . . . . . . . . . . . . . 190
Arranging Legend Entries into Columns and Rows . . . . . . . . . . . . . . . . . . . . . . . . 192
Controlling the Label and Item Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
Adding and Removing Items from a Discrete Legend . . . . . . . . . . . . . . . . . . . . . . 196
Merging Legend Items from Two Plots into One Legend . . . . . . . . . . . . . . . . . . . 198
Creating a Global Legend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
When Discrete Legends Get Too Large . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
Features of Continuous Legends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
Plots That Can Use Continuous Legends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
Positioning a Continuous Legend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
Using Color Gradients to Represent Response Values . . . . . . . . . . . . . . . . . . . . . . 207
Scaling the Legend Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
Introduction to Legend Management
Some of the Uses for a Legend
A graphical legend provides a key to the marker symbols, lines, and other data elements
that are displayed in a graph. Here are some of the situations where legends are useful:
•
when a plot contains grouped markers (scatter plots, for example)
•
when a plot contains lines that differ by color, marker symbol, or line pattern (series
plots or step plots, for example)
•
when a plot contains one or more lines or bands that require identification or
explanation
175

•
when series plots with different data are overlaid in the graph, or fit lines are
displayed with confidence bands, or density plots with different distributions are
generated
•
when markers vary in color to show the values of a response variable
•
when contour or surface plots use gradient fill colors to show the values of a
response variable.
GTL does not automatically generate legends for the above situations. However, the
mechanism for creating legends is simple and flexible.
Types of Legends in GTL
GTL supports two legend statements:
DISCRETELEGEND
legend that contains one or more legend entries. Each entry consists of a graphical
item (marker, line, ...) and corresponding text that explains the item. A discrete
legend would be used for the first two situations listed in “Some of the Uses for a
Legend” on page 175.
For details, see “General Legend Features” on page 179 and “Features of Discrete
Legends” on page 187.
CONTINUOUSLEGEND
legend that maps a color gradient to response values. A continuous legend would be
used for the last two situations listed in “Some of the Uses for a Legend” on page
175.
For details, see “General Legend Features” on page 179 and “Features of
Continuous Legends” on page 204.
General Syntax for Using Legends
Regardless of the situation, the basic strategy for creating legends is to "link" one or
more plot statements to a legend statement by assigning a unique, case-sensitive name to
the plot statement and then referencing that name on the legend statement:
plot-statement . . . / name="id-string1" ;
plot-statement . . . / name="id-string2" ;
legend-statement  "id-string1"  "id-string2"  < / options > ;
One way of thinking about this syntax is that you can identify any plot with a NAME=
option, and you can then selectively include plot names on a legend statement. This
176
Chapter 8
•
Adding Legends to a Graph

enables the legend to query the identified plots so that it can get the information that it
needs to build the legend entries.
Note: When the legend statement includes the name of a plot, it does not always mean
that the legend will include an entry for that plot. For example, a block plot with
FILLTYPE=ALTERNATE does not show up in a legend.
Example Legend Coding for Common Situations
Show Group Values in a Legend
The appearance of the markers is automatically determined by the current style. The
order of the legend entries is controlled by the data order.
layout overlay;
  scatterplot x=height y=weight / group=sex name="scatter";
  discretelegend "scatter";
endlayout;
Identify Overlaid Plots in a Legend
This example illustrates that more than one plot can contribute to a legend. The order of
the names in the DISCRETELEGEND statement controls the order of the legend entries.
For more information about the CYCLEATTRS= option, see “Ordering the Legend
Entries for Non-grouped Plots” on page 190.
layout overlay / cycleattrs=true;
  seriesplot x=month y=actual    / name="sp1";
  seriesplot x=month y=predicted / name="sp2";
  discretelegend "sp1" "sp2";
endlayout;
Introduction to Legend Management
177

In this case, the default legend entry text was determined by the label for the Y= variable
of each plot. You could set the legend entry text explicitly by specifying
LEGENDLABEL="string" on each plot statement.
Show Group Values and Identify Plots in a Legend
A legend can show group values for multiple groups and identify one or more plots.
layout overlay;
  scatterplot x=height y=weight / group=sex name="scatter";
  loessplot x=height y=weight / name="Loess";
  discretelegend "Loess" "scatter";
endlayout;
If a plot variable does not have a variable label, the case-sensitive plot name is used for
the legend label. In this case, because the Y= variable of the LOESSPLOT statement
does not have a variable label, the plot name "Loess" is used. You could also set the
legend entry text explicitly by setting LEGENDLABEL="string" in the LOESSPLOT
statement.
Show a Legend for a Continuous Response Variable (scatter plot)
This example shows how marker color in a scatter plot can represent the values of a
response variable (Weight in this case).
layout overlay;
  scatterplot x=age y=height / markercolorgradient=weight name="sc"
    markerattrs=(symbol=circlefilled);
178
Chapter 8
•
Adding Legends to a Graph

  continuouslegend "sc" / title="Weight";
endlayout;
Show a Legend for a Continuous Response Variable (contour plot)
This example shows how a fill color gradient in a contour can represent values of a
response variable (Density in this case)
layout overlay;
  contourplotparm x=height y=weight z=density /
    contourtype=gradient name="con";
  continuouslegend "con" / title="Density";
endlayout;
General Legend Features
The following sections discuss several features that are common to both discrete legends
and continuous legends.
General Legend Features
179

Positioning Options
Overview of the Legend Placement Options
You can include a legend statement in most layout blocks. Most of the time you would
simply like to ensure that the legend appears where you want in relation to the plot(s) of
the graph. The issues differ, depending on whether you define a single-cell graph or a
multi-cell graph. This section discusses single-cell graphs. The discussion of legend
placement for multi-cell layouts such as GRIDDED, LATTICE, DATALATTICE, and
DATAPANEL appears in the appropriate layout chapter:
•
Chapter 9, “Using a Simple Multi-cell Layout,” on page 211 (GRIDDED)
•
Chapter 10, “Using an Advanced Multi-cell Layout,” on page 225 (LATTICE)
•
Chapter 11, “Using Classification Panels,” on page 257 (DATAPANEL,
DATALATTICE, PROTOTYPE)
The following positioning options control a legend's location within its parent layout.
They are available only when the legend is nested within an overlay-type layout:
LOCATION= INSIDE | OUTSIDE
determines whether the legend is drawn inside the plot wall of the cell, or outside the
plot wall (and outside the axes). The default is OUTSIDE.
HALIGN = LEFT | CENTER | RIGHT
determines horizontal alignment. The default is CENTER.
VALIGN = TOP | CENTER | BOTTOM
determines vertical alignment. The default is BOTTOM.
Displaying Legends outside of the Plot Wall
When you place a legend statement in a single-cell layout such as OVERLAY,
OVERLAYEQUATED, or OVERLAY3D, the default legend appears outside the plot
wall but inside the layout border:
layout overlay;
  scatterplot X=Height Y=Weight /
    name="sp" group=sex;
  discretelegend "sp" /
    location=outside
    halign=center valign=bottom ;
endlayout;
180
Chapter 8
•
Adding Legends to a Graph

Using the HALIGN= and VALIGN= options, you can place a legend in eight positions
outside the plot wall. The only combination that is not supported is HALIGN=CENTER
and VALIGN=CENTER. To accommodate the legend, the size of the plot wall is
adjusted so that the legend(s) can be displayed.
Note: Sometimes with large legends, this size adjustment causes problems. Sizing issues
are discussed in “Arranging Legend Entries into Columns and Rows” on page 192
and “When Discrete Legends Get Too Large” on page 201.
The following example positions the legend in the outside center-right location.
layout overlay;
  scatterplot X=Height Y=Weight /
    name="sp" group=sex;
  discretelegend "sp" /
    halign=right valign=center ;
endlayout;
Displaying Legends inside the Plot Wall
A legend can be placed inside the plot wall (LOCATION=INSIDE) and positioned with
the HALIGN= and VALIGN= options. Nine inside positions are possible. The defaults
are HALIGN=CENTER and VALIGN=CENTER. The following example positions the
legend in the inside bottom right location.
layout overlay;
  scatterplot X=Height Y=Weight /
    name="sp" group=sex;
  discretelegend "sp" / location=inside
    halign=right valign=bottom ;
endlayout;
General Legend Features
181

One of the advantages of inside legends is that the plot wall does not shrink.
One of the disadvantages of inside legends with HALIGN= and VALIGN= positions is
that the legend might be placed on top of plot markers, lines, or filled areas (legends,
entries, and nested layouts are always stacked on top of plots, regardless of the statement
order in an overlay block).
Automatically Aligning an Inside Legend
When the plot statements are specified in a 2-D overlay-type layout, the AUTOALIGN=
option can be used to automatically position an inside legend. AUTOALIGN= selects a
position that avoids or minimizes collision with plot components.
The AUTOALIGN= option enables you to specify an ordered list of potential positions
for the legend. The list contains one or more of the following keywords: TOPLEFT,
TOP, TOPRIGHT, LEFT, CENTER, RIGHT, BOTTOMLEFT, BOTTOM, and
BOTTOMRIGHT. In the following example, we know that the best position for an
inside legend is TOPRIGHT or TOPLEFT. Because the AUTOALIGN= option specifies
a list of preferred positions, the first of the listed positions that does not involve data
collision is used. Had the histogram been skewed to the right, the TOPLEFT position
would be used.
layout overlay;
  histogram Weight / name="sp";
  densityplot Weight / kernel()
    legendlabel="Kernel Density"
    name="kde";
  discretelegend "kde" /
    location=inside
    autoalign=(topright topleft) ;
endlayout;
182
Chapter 8
•
Adding Legends to a Graph

When the parent layout contains only scatter plots, you can fully automate the selection
of an internal position by specifying AUTOALIGN=AUTO. This is a "smart" option that
automatically selects a position where there is no (or minimal) collision with plot
components. The AUTOALIGN=AUTO option selects a position for you. Note that
positions that are not possible with HALIGN= and VALIGN= might be used.
layout overlay;
  scatterplot X=Height Y=Weight / name="sp" group=sex;
  discretelegend "sp" / location=inside autoalign=auto ;
endlayout;
General Appearance Options
Using Background Transparency and Color
The following options control the appearance of the legend background:
OPAQUE = TRUE | FALSE
determines whether the legend background is 100% transparent or 0% transparent.
BACKGROUNDCOLOR= style-reference | color
determines legend background color. OPAQUE=TRUE must be set for the
background color to be seen. The GraphLegendBackground:Color style reference is
the default.
General Legend Features
183

By default, OPAQUE=FALSE when LOCATION=INSIDE. This minimizes the
potential for the legend to obscure the markers, lines, fills, and labels in the plot area.
when When LOCATION=OUTSIDE, OPAQUE=TRUE by default. This enables the
legend background color to appear. Typically, the default legend background color is the
same as the plot wall background color. The following graph illustrates the default
settings (the graph uses the DEFAULT style, which has a gray graph background):
The next graph illustrates how the graph looks when the default opacity is reversed.
With reverse opacity, the default background color of an inside legend is the same as the
fill color of the plot wall that is behind it. For outside legends, the default background
color is 100% transparent, so the graph background color shows through the legend.
When the legend background is opaque, you can use the BACKGROUNDCOLOR=
option to set its color. In the following example,
BACKGROUNDCOLOR=GraphAltBlock:Color for both the inside and outside opaque
legends. Other style references that you can use include GraphHeaderBackground:Color,
GraphBlock:Color, or any other style element with a COLOR= attribute. You can also
specify a specific color, such as BACKGROUNDCOLOR=white.
184
Chapter 8
•
Adding Legends to a Graph

Using a Legend Title and Title Border
By default, legends do not have titles. To add a title, you can use the TITLE= option.
You can also add a dividing line between the legend title and the legend body with the
TITLEBORDER=TRUE setting.
layout overlay;
  histogram Weight / name="sp";
    densityplot Weight / normal()
      legendlabel="Normal" name="norm"
      lineattrs=GraphData1;
    densityplot Weight / kernel()
      legendlabel="Kernel" name="kde"
      lineattrs=GraphData2;
    discretelegend "norm" "kde" /
      location=inside across=1
      autoalign=(topright topleft)
      title="Theoretical Distributions"
      titleborder=true ;
endlayout;
Legend Border
By default, a border is displayed around a legend. You can remove the border by
specifying BORDER=FALSE (which also removes the title border). The line properties
General Legend Features
185

of a legend border can be set by the BORDERATTRS= option. The following example
modifies the legend border so that it is thicker than the title border:
layout overlay;
  histogram Weight / name="sp";
    densityplot Weight / normal()
      legendlabel="Normal" name="norm"
      lineattrs=GraphData1;
    densityplot Weight / kernel()
      legendlabel="Kernel" name="kde"
      lineattrs=GraphData2;
    discretelegend "norm" "kde" /
      location=inside across=1
      autoalign=(topright topleft)
      title="Theoretical Distributions"
      titleborder=true
      borderattrs=(thickness=2) ;
endlayout;
Legend Text Properties
The TITLEATTRS= and VALUEATTRS= options control the text properties of the
legend. By default, the text properties come from the current style. The legend title uses
TITLEATTRS = GraphLabelText, and legend entries use VALUEATTRS =
GraphValueText. For visual consistency in the graph, the GraphLabelText style
element is also used for axis labels, and the GraphValueText style element is also used
for axis tick values. In general, style elements are used as needed in a graph to maintain
visual consistency.
The following example sets all legend text to gray. The font for the legend title is made
the same as the default font for the legend values by setting
TITLEATTRS=GraphValueText.
layout overlay;
  histogram Weight / name="sp";
    densityplot Weight / normal()
      legendlabel="Normal" name="norm"
      lineattrs=GraphData1;
    densityplot Weight / kernel()
      legendlabel="Kernel" name="kde"
      lineattrs=GraphData2;
    discretelegend "norm" "kde" /
      location=inside across=1
186
Chapter 8
•
Adding Legends to a Graph

      autoalign=(topright topleft)
      title="Theoretical Distributions"
      border=false valueattrs=(color=gray)
      titleattrs=GraphValueText(color=gray) ;
endlayout;
Features of Discrete Legends
Placing the Legend
You can use the AUTOALIGN, LOCATION=, HALIGN=, and VALIGN= options to
place your legend. Note the following about legend placement:
•
When a discrete legend is placed within the axis frame (LOCATION=INSIDE):
•
It is always placed on top of plot lines and markers.
•
Its background is fully transparent by default (OPAQUE=FALSE), meaning that
underlying lines, markers, and data labels will show through the legend.
•
Its position is controlled with the AUTOALIGN= option.
•
When a discrete legend is placed outside the axis frame (LOCATION=OUTSIDE):
•
Its background is fully opaque by default (OPAQUE=TRUE).
•
Its position is controlled with the HALIGN= and VALIGN= options.
•
When a discrete legend is placed within nested layouts, you might have to use the
ACROSS= and ORDER=ROWMAJOR options or the DOWN= and
ORDER=COLUMNMAJOR options to obtain the desired legend organization.
Ordering the Legend Entries for a Grouped Plot
Overview of the Group Value Default Order
When the GROUP=column option is used with a plot, the unique values of column are
presented in the legend in the order in which they occur in the data.
proc template;
Features of Discrete Legends
187

 define statgraph order;
  dynamic TITLE;
  begingraph;
   entrytitle TITLE;
   layout overlay;
    scatterplot x=height y=weight / name="sp"
      group=age ;
    discretelegend "sp" / title="Age";
   endlayout;
  endgraph;
 end;
run;
 
proc sgrender data=sashelp.class template=order;
  dynamic
    title="Default Order of Legend Entries"; 
run;
Sorting the Legend Items
You use the SORTORDER= option in your DISCRETELEGEND statement to perform
a linguistic sort on the legend items in ascending or descending order. By default,
SORTORDER=AUTO, which displays the items in the order in which they are provided
by the contributing plots.
Note: The SORTORDER= option overrides the ordering that is established by the
GROUPORDER= option in the legend's constituent plot statements. The
SORTORDER=ASCENDINGFORMATTED or
SORTORDER=DESCENDINGFORMATTED options combine the entries from the
contributing plots and orders them as a single list.
Here is an example that sorts the legend items in ascending order.
layout overlay;
   scatterplot x=height y=weight / name="sp"
      group=age;
   discretelegend "sp" / title="Age" sortorder=ascendingformatted;
endlayout;
188
Chapter 8
•
Adding Legends to a Graph

Alternatively, you can create a sorted data set, and then use the sorted data to generate
your graph. In that case, the legend values appear in the sorted order.
Formatting the Data
You can apply a format to a group column to change the legend entry labels or the
number of classification levels. The ordering of the legend entries is based on the order
of the pre-formatted group values. In the following example, the data is sorted in
ascending order, so the legend entry order is "Pre-Teen" "Teen" "Adult." Because there
are no adults, "Adult" does not appear in the graph. If the data were sorted in descending
age order the legend entry order would be reversed.
proc format; 
  value teenfmt 
  low-12  = "Pre-Teen" 
  13-19   = "Teen" 
  20-high = "Adult"; 
run; 
proc sort data=sashelp.class out=class;
  by age;
run;
proc sgrender data=class template=order;
  format age teenfmt.;
  dynamic
    title="Formatted Order of Legend Entries";
run;
Features of Discrete Legends
189

In a GTL template, the plot statement, not the legend statement, defines the association
of grouped data values with colors, symbols, and line patterns. The association is simply
reflected in the legend entries. To change the mapping between grouped data values and
the associated style elements, use the INDEX=column option on the plot statement. For a
discussion of the INDEX= option, see Chapter 6, “Managing Graph Appearance:
General Principles,” on page 111.
Ordering the Legend Entries for Non-grouped Plots
Ordering Entries from Overlaid Plots
When plots are overlaid and you want to distinguish them in a legend, you must assign
each plot a name and then reference the name in the legend statement. The order in
which the plot names appear on the legend statement controls the ordering of the legend
entries for the plots.
Varying Visual Properties
In the following examples, the CYCLEATTRS=TRUE setting is used as a quick way to
change the visual properties of each plot without explicitly setting it. When
CYCLEATTRS=TRUE, any plots that derive their default visual properties from one of
the GraphData elements are cycled through those elements for deriving visual properties.
So, the first plot gets its visual properties from the GraphData1 style element, the next
plot gets its properties from the GraphData2 style element, and so on. When plot lines
represent entities such as fit lines or confidence bands, it is recommended that you use
options such as LINEATTRS= or OUTLINEATTRS= and specify appropriate style
elements. For example, you might specify LINEATTRS=GraphFit or
OUTLINEATTRS=GraphConfidence.
layout overlay / cycleattrs=true
    yaxisopts=(display=(ticks tickvalues));
  seriesplot X=month Y=actual /  name="a";
  seriesplot X=month Y=predict / name="p";
 
  discretelegend "a" "p" /valign=bottom;
  discretelegend "p" "a" /valign=top;
endlayout;
190
Chapter 8
•
Adding Legends to a Graph

Assigning Legend Entry Labels
Every GTL plot type (except box plot) has a default legend entry label. For example, for
some X-Y plots, the default entry legend label is the label of the Y= column (or the
column name if no label is assigned).
To assign a legend entry label for a plot, you can use a LABEL statement with PROC
SGRENDER, or use the LEGENDLABEL="string" option on the plot statement.
layout overlay / yaxisopts=(label="Sales")
                 cycleattrs=true;
  seriesplot x=month y=actual / name="a"
             legendlabel="Actual" ;
  seriesplot x=month y=predict / name="p"
             legendlabel="Predicted" ;
  discretelegend "a" "p"/  valign=bottom;
endlayout;
Note: Other techniques are available for labeling plots without using a legend. Many
plots that render one or more lines support a CURVELABEL= option that places text
inside or outside of the plot wall to label the line(s). These plots include
SERIESPLOT, STEPPLOT, DENSITYPLOT, REGRESSIONPLOT, LOESSPLOT,
PBSPLINEPLOT, MODELBAND, BANDPLOT, LINEPARM, REFERENCELINE,
and DROPLINE. Additional options are available to control curve label location,
position, and text properties. For examples, see Chapter 6, “Managing Graph
Features of Discrete Legends
191

Appearance: General Principles,” on page 111 and Chapter 7, “Adding and Changing
Text in a Graph,” on page 157.
Arranging Legend Entries into Columns and Rows
Default Legend Item Arrangement
The arrangement of the entries in a legend is affected by the number of entries in the
legend, the length of the entry labels, and the size of the graph. When the graph is wide
enough, all legend information can fit into one row as shown in the following figure.
Note: When all the legend entries and the legend title fit in one row, the legend title is
drawn on the left as shown in the following graph. This is done to conserve the
vertical space that is used by the legend.
When the legend entries and the legend title cannot fit into one row, the legend title and
entries are wrapped into multiple rows in order to fit the allotted space. In the following
graph, the width of the graph is reduced to the point where it causes the legend entries to
wrap into an additional row. Because the legend needs this extra row, the height of the
plot wall must be reduced, leaving less room for the data display. Also, because the
legend entries and title do not fit in one row, the title is now drawn above the legend
entries.
192
Chapter 8
•
Adding Legends to a Graph

Options to Control Legend Wrapping
You can explicitly control the organization of legend entries with the following options
on the legend statement:
ORDER = ROWMAJOR | COLUMMAJOR
determines whether legend entries are wrapped on a column or row basis. Default is
ROWMAJOR.
ACROSS = number
determines the number of columns. Only used with ORDER=ROWMAJOR
DOWN = number
determines the number of rows. Use only with ORDER=COLUMNMAJOR
DISPLAYCLIPPED = TRUE | FALSE
determines whether to show a legend when there are too many entries to fit in the
available space
Organizing Legend Entries in a Fixed Number of Columns
For legends with left or right horizontal alignment, a vertical orientation of legend
entries works best because it allows the most space for the plot area. In such cases, you
typically want to set a small fixed number of columns for the legend entries and let the
entries wrap to a new row whenever necessary. This entails setting
ORDER=ROWMAJOR and an ACROSS= value. In the following example,
ACROSS=1 means "place all entries in one column, and start as many new rows as
necessary."
layout overlay;
  scatterplot x=Height y=Weight / name="sp"
    group=age;
  discretelegend "sp" / title="Age"
    halign=right valign=center
    order=rowmajor across=1 ;
endlayout;
Features of Discrete Legends
193

As you increase the number of columns, the plot area decreases. In the following
example, ACROSS=2 means "place all entries in two columns left to right, and start as
many new rows as necessary."
layout overlay;
  scatterplot x=Height y=Weight / name="sp"
    group=age;
  discretelegend "sp" / title="Age"
    halign=right valign=center
    order=rowmajor across=2 ;
endlayout;
Organizing Legend Entries in a Fixed Number of Rows
For legends with a top and bottom alignment, a horizontal orientation of legend entries
works best. In such cases, you typically want to set a small fixed number of rows for the
legend entries and let the entries wrap to a new column whenever necessary. This entails
setting ORDER=COLUMNMAJOR and a DOWN= value. In the following example,
DOWN=1 means "place all entries in one row, and start as many new columns as
necessary."
layout overlay;
  scatterplot x=Height y=Weight / name="sp"
194
Chapter 8
•
Adding Legends to a Graph

    group=age;
  discretelegend "sp" / title="Age"
    order=columnmajor down=1 ;
endlayout;
As you increase the number of rows, the plot area decreases. In the following example,
DOWN=2 means "place all entries in two rows top to bottom, and start as many new
columns as necessary."
layout overlay;
  scatterplot x=Height y=Weight / name="sp"
    group=age;
  discretelegend "sp" / title="Age"
    order=columnmajor down=2 ;
endlayout;
Controlling the Label and Item Size
To control the size of the labels in your legend, include the SIZE= option in the
VALUEATTRS= option list in the DISCRETELEGEND statement. By default, the size
of the items in the legend, such as markers, filled squares, and filled bubbles, remain
Features of Discrete Legends
195

fixed regardless of the label font size. When you increase the label font size, the labels
can appear out of proportion with the items. You can include the
AUTOITEMSIZE=TRUE option in your DISCRETELEGEND statement to
automatically size markers, filled squares, and filled bubbles in proportion to the label
font size. The AUTOITEMSIZE= option does not affect line items. When
AUTOITEMSIZE=TRUE, if you change the label font size, any markers, filled squares,
and filled bubbles in the legend are automatically resized to maintain proportion with the
resized labels. Here is an example that specifies a discrete legend that has 12-point labels
and markers that are sized proportionately to the labels.
layout overlay;
   scatterplot x=Height y=Weight / name="sp2" group=age;
   discretelegend "sp2" / title="Age"
      valueattrs=(size=12pt) autoitemsize=true;
endlayout;
Adding and Removing Items from a Discrete Legend
Adding Items to a Legend
You can use the LEGENDITEM statement to manually add items to your legend that do
not appear in your plot. This enables you to provide additional information about your
plot or to build a common legend that you can use with multiple plots. The syntax of the
LEGENDITEM statement is as follows:
LEGENDITEM TYPE=EntryType NAME=LegendName / options
You must place the LEGENDITEM statement in the global definition area of the
template between the BEGINGRAPH statement and the first layout statement. The
TYPE=EntryType option specifies the type of entry that you want to add to your legend.
EntryType can be one of the following:
LINE
MARKER
MARKERLINE
TEXT
Use options to set the desired appearance for the entry, such as color, pattern, font, and
so on. Note the following about the LEGENDITEM statement:
•
You can specify any supported set of attributes for a legend item regardless of its
type. However, sets of attributes that are not applicable to the legend item type are
ignored. For example, in the LEGENDITEM statement, if TYPE=FILL and the
MARKERATTRS=( ) option is specified, the MARKERATTRS=( ) option is
ignored.
•
When TYPE=TEXT, if the TEXT= option is not specified in the LEGENDITEM
statement, a blank space is used by default.
Here is an example of a LEGENDITEM statement that adds item 17 to the legend of a
height-to-weight chart that is grouped by age. The new item uses a red-filled star as a
marker.
proc template;
   define statgraph additem;
   dynamic legenditem;
      BeginGraph;
         entrytitle "Height vs. Weight By Age";
         legenditem  type=marker name="newitem" / label="17"
196
Chapter 8
•
Adding Legends to a Graph

            lineattrs=(color=red)
            markerattrs=(symbol=starfilled color=red);
         layout overlay;
            scatterplot x=height y=weight / group=age
               name="heightweight";
            discretelegend "heightweight" "newitem";
         endlayout;
      EndGraph;
   end;
run;
proc sgrender data=sashelp.class template=additem;
run;
Notice that the DISCRETELEGEND statement specifies the name specified in the
NAME= option in each of the SCATTERPLOT and LEGENDITEM statements. This
combines the new legend item and the automatically generated plot legend into one
legend. In this example, the new item 17 and its red-filled star marker are appended to
the existing items in the legend. You can include multiple LEGENDITEM statements to
add multiple items to your legend.
Removing Items from a Legend
To remove one or more items from your legend, use the EXCLUDE= option on your
DISCRETELEGEND statement. The EXCLUDE= specifies the label of each item that is
to be removed as follows:
EXCLUDE=("item1Label"< "item2Label" ...>)
Each item label is enclosed in quotation marks and must match the formatted string of
the data value. For two or more items, each label is separated by a space. String
matching is case sensitive. Here is an example that removes age groups 13 and 15 from
the legend.
proc template;
   define statgraph order;
      begingraph;
         layout overlay  ;
            scatterplot X=Height Y=Weight / name="sp" group=age; 
            discretelegend "sp" / title="Age" sortorder=ascendingformatted
            exclude=("13" "15");
         endlayout;     
      endgraph;
   end;
run;
proc sgrender data=sashelp.class template=order;
run;
Filtering Items That Are Contributed by Multiple Plot Statements
When multiple plot statements contribute to the legend, you can use the TYPE= option
in your DISCRETELEGEND statement to include only items of a specific type. You can
specify one of the following item types:
ALL
LINE
MARKER
FILL
LINECOLOR
MARKERCOLOR
FILLCOLOR
LINEPATTERN
MARKERSYMBOL
Features of Discrete Legends
197

Note: If no entries match the type specified by the TYPE= option, a legend is not drawn
in the plot.
Here is an example that includes only marker entries in a legend for a series plot that
displays both the lines and markers.
proc template;
define statgraph plots;
begingraph;
   entrytitle "Closing Price and Volume for 2002";
   Layout overlay;
       seriesplot x=date y=close / group=stock name="plot1" display=all;
       discretelegend  "plot1" / title="Stock" type=marker;
   endLayout;
endgraph;
end;
run;
proc sgrender data=sashelp.stocks template=plots;
   where date between '01JAN2002'd AND '31DEC2002'd;
run;
Merging Legend Items from Two Plots into One Legend
You can use the MERGEDLEGEND statement to merge the legend items from two
grouped plots into one legend. The basic syntax is as follows:
MERGEDLEGEND "graph1" "graph2" / options;
The options used with the MERGEDLEGEND statement are similar to those that are
used with the DISCRETELEGEND statement. The following restrictions apply to the
MERGEDLEGEND statement:
•
You must provide exactly two plot names.
•
Each plot name must be enclosed in quotation marks.
•
Only grouped plots are supported.
•
Only plots with line and marker overlays are supported.
During the merge process, the group values from both plots are compared. The legend
symbols for duplicate group values are combined into one legend item, which is then
combined with the unique items into one legend. If the items cannot be merged, the
following warning message appears in the SAS log:
WARNING: MERGEDLEGEND statement does not reference two plots whose legend
items can be properly merged. The legend will not be displayed.
If you receive this message, verify that both of the contributing plots are grouped plots
that use line and marker overlays. Here is an example that overlays a series plot and a
scatter plot, and combines the plot symbols into one merged legend and one discrete
legend that are displayed side-by-side for comparison.
proc template;
define statgraph plots;
begingraph;
   entrytitle "Closing Price and Volume for 2002";
   Layout overlay /
       xaxisopts=(griddisplay=on gridattrs=(color=lightgray pattern=dot))
       yaxisopts=(griddisplay=on gridattrs=(color=lightgray pattern=dot));
198
Chapter 8
•
Adding Legends to a Graph

       seriesplot x=date y=close / group=stock name="plot1";
       scatterplot x=date y=volume / group=stock name="plot2" yaxis=y2;
       discretelegend  "plot1" "plot2" / title="Discrete Legend"
          across=2 down=3 valign=bottom order=columnmajor halign=left;
       mergedlegend "plot1" "plot2" / title="Merged Legend"
          sortorder=ascendingformatted across=1 valign=bottom halign=right;
   endLayout;
endgraph;
end;
run;
proc sgrender data=sashelp.stocks template=plots;
   where date between '01JAN2002'd AND '31DEC2002'd;
run;
In this example, the SERIESPLOT statement creates a series plot of the closing stock
prices grouped by stock. The SCATTERPLOT statement creates a scatter plot of the
trading volume grouped by stock. Notice that both plots are grouped, and exactly two
plot names are used in the MERGEDLEGEND statement. As shown in this example, the
discrete legend consists of two entries for each stock, one from each of the plots.
Because SORTORDER= defaults to AUTO in this case, the items from each plot appear
in the order in which they occur in the data. In contrast, the merged legend consists of
only one entry for each stock, which is a combination (overlay) of the entries from both
plots. You can use the SORTORDER= option in the MERGEDLEGEND statement to
sort the items in the merged legend. In this case, because the data is already sorted,
SORTORDER=ASCENDINGFORMATTED and SORTORDER=AUTO have the same
effect.
Features of Discrete Legends
199

Creating a Global Legend
When multiple discrete legends are used, you can use a LAYOUT GLOBALLEGEND
block to combine all of the discrete and merged legends into one global legend. The
following restrictions apply to global legends:
•
Only one LAYOUT GLOBALLEGEND block is allowed for each template.
•
You must include the LAYOUT GLOBALLEGEND block in the BEGINGRAPH/
ENDGRAPH block.
•
Any DISCRETELEGEND or MERGEDLEGEND statements that appear outside of
the LAYOUT GLOBALLEGEND block are ignored.
•
The individual legends in the global legend can be arranged in a single row or a
single column only.
•
CONTINUOUSLEGEND statements are not supported.
To combine your legends into one global legend, include all of the DISCRETELEGEND
and MERGEDLEGEND statements in your LAYOUT GLOBALLEGEND block. The
resulting global legend is placed at the bottom of the graph just above the footnotes. You
can use the TITLE= option to add a title for the global legend. You can also use the
TITLE= option on each of the DISCRETELEGEND or MERGEDLEGEND statements
to add titles for the individual legends. Use the LEGENDTITLEPOSITION = option to
specify the position of the individual legend titles.
The TYPE= option specifies whether the legends are arranged in a column or a row.
When you specify TYPE=ROW, you can use the WEIGHTS= option to specify the
amount of space that is available for each of the legends. The WEIGHTS= option can be
one of the following values:
UNIFORM
specifies that all of the nested legends are given an equal amount of space (default).
PREFERRED
specifies that each nested legend is to be given its preferred amount of space.
weight-list
specifies a space-delimited list of PREFERRED or number keywords where each
keyword corresponds to a nested legend.
PREFERRED
indicates that the corresponding legend is to get its preferred size.
number
specifies a proportional weight for the corresponding legend, which determines
the percentage of the available space that the legend gets. The total of the values
does not need to be 1. When PREFERRED and number keywords are used
together, the PREFERRED legends are given their preferred space. The
remaining space is divided among the number legends based on their weighted
values.
For more information, see SAS Graph Template Language: Reference.
Here is an example that creates a global legend for two plots.
proc template;
define statgraph foo;
begingraph;
   layout lattice;
      entrytitle "Asian Makes - MSRP  Under $15,000";
200
Chapter 8
•
Adding Legends to a Graph

      Layout overlay / xaxisopts=(display=(ticks tickvalues line))
         yaxisopts=(griddisplay=on gridattrs=(color=lightgray pattern=dot));
         barchart category=type response=mpg_city / group=make name="bar"
            stat=mean groupdisplay=cluster barwidth=0.75;
      endLayout;
      Layout overlay / xaxisopts=(display=(ticks tickvalues line))
         yaxisopts=(griddisplay=on gridattrs=(color=lightgray pattern=dot));
         scatterplot x=make y=msrp / group=type name="scatter"; 
      endLayout;
   endlayout;
   layout globallegend / type=row weights=preferred legendtitleposition=top;
      discretelegend "bar" / across=3
         title="Make" titleattrs=(weight=bold);
      discretelegend "scatter" / sortorder=ascendingformatted
         title="Type" titleattrs=(weight=bold);
   endlayout;
endgraph;
end;
run;
proc sgrender data=sashelp.cars template=foo;
  where origin="Asia" && msrp <= 15000;
run;
The following figure shows the resulting plot.
When Discrete Legends Get Too Large
As a discrete legend gets more entries or as the legend entry text is lengthy, the legend
grows and the plot wall shrinks to accommodate the legend's size. At some point, the
plot wall becomes so small that it is useless. For that reason, whenever all the legends in
Features of Discrete Legends
201

a graph occupy more than 20% of the total area of the graph, the larger legends are
dropped as needed from the graph to keep the legend area at 20% or less of the graph
area. For example, the following code generates only one legend, but that legend would
occupy more than 20% of the total area of the graph, so the legend is dropped and the
plot is rendered as if no legend were specified.
proc template;
 define statgraph legendsize;
  begingraph / designwidth=495px designheight=220px;
    entrytitle "Legend Drops out with GROUP=NAME";
    layout overlay;
      scatterplot x=Height y=Weight / name="sp" group=name;
      discretelegend "sp" / title="Name" across=2 halign=right;
    endlayout;
  endgraph;
 end;
run;
 
proc sort data=sashelp.class out=class; by name; run;
 
proc sgrender data=class template=legendsize;
run;
When the legend is dropped from the graph, you see the following log note:
NOTE: Some graph legends have been dropped due to size constraints. Try adjusting
      the MAXLEGENDAREA=, WIDTH= and HEIGHT= options in the ODS GRAPHICS
      statement.
In such cases, you can use the WIDTH= and HEIGHT= options in the ODS GRAPHICS
statement to increase the graph area so that at some point the legend is displayed.
Another alternative is to use the MAXLEGENDAREA= option to change the threshold
area for when legends drop out. The following specification allows all legends to occupy
up to 40% of the graph area:
ods graphics / maxlegendarea=40;
proc sgrender data=class template=legendsize;
run;
However, changing the total area that is allotted to legends might not resolve the
problem if the specified legend organization does not fit in the existing size. In these
cases, the legend might not be displayed and you would see the following log message:
202
Chapter 8
•
Adding Legends to a Graph

WARNING: DISCRETELEGEND statement with DISPLAYCLIPPED=FALSE is getting clipped.
         The legend will not be drawn.
To investigate this problem, you can specify DISPLAYCLIPPED=TRUE in the
DISCRETELEGEND statement, which forces the legend to display so that you can
visually inspect it.
discretelegend "sp" / title="Name" across=2 halign=right displayclipped=true ;
In the current example, it is apparent that the height chosen for the output is not large
enough to display the title and all legend entries in two columns. The problem can be
fixed in any of the following ways:
•
increasing the graph height (HEIGHT= in the ODS GRAPHICS statement or
DESIGNHEIGHT= in the BEGINGRAPH statement)
•
relocating the legend and/or reorganizing it with the ACROSS= or DOWN= options
•
setting DISPLAYCLIPPED=TRUE if you are willing to see only a portion of the
legend
•
reducing the font size for the legend entries (and possibly the title).
To change the font sizes of the legend entries, use the VALUEATTRS= option on the
legend statement. To change the font size of the legend title, use the TITLEATTRS=
option. Normally, the legend entries are displayed in 9pt font, and the legend title is
displayed in 10pt font. The following example reduces the size of legend text:
discretelegend "sp" / title="Name" across=2 halign=right
                      valueattrs=(size= 7pt) titleattrs=(size= 8pt);
Features of Discrete Legends
203

Features of Continuous Legends
Plots That Can Use Continuous Legends
A continuous legend maps the data range of a response variable to a range of colors.
Continuous legends can be used with the following plot statements when the enabling
plot option is also specified.
Plot Statement
Enabling Plot Option
Related Plot Options
CONTOURPLOTPARM
CONTOURTYPE=
COLORMODEL=
REVERSECOLORMODEL=
NLEVELS=
NHINT=
HEATMAPPARM
COLORRESPONSE=
COLORMODEL=
SCATTERPLOT
MARKERCOLORGRADIENT=
COLORMODEL=
REVERSECOLORMODEL=
SURFACEPLOTPARM
SURFACECOLORGRADENT=
COLORMODEL=
REVERSECOLORMODEL=
A contour plot provides the CONTOURTYPE= option, which you can use to manage
the contour display. The following graph illustrates the values that are available for the
CONTOURTYPE= option.
All of the variations that support color, except for LINE and LABELEDLINE, can have
a legend that shows the value of the required Z= column. For example, the following
code generates a contour plot with CONTOURTYPE=FILL:
proc template;
 define statgraph contour;
  begingraph;
204
Chapter 8
•
Adding Legends to a Graph

   entrytitle "CONTOURTYPE=FILL";
   layout overlay / xaxisopts=(offsetmin=0 offsetmax=0)
                    yaxisopts=(offsetmin=0 offsetmax=0);
     contourplotparm x=Height y=Weight z=Density / name="cont"
       contourtype=fill ;
     continuouslegend "cont" / title="Density";
   endlayout;
  endgraph;
 end;
run;
 
proc sgrender data=sashelp.gridded template=contour;
 where height>=53 and weight<=225;
run;
If you change to CONTOURTYPE=GRADIENT you get the following output:
For a FILL contour, the Z variable is split into equal-sized value ranges, and each range
is assigned a different color. The continuous legend shows the value range boundaries
and the associated colors as a long strip of color swatches with an axis on it. The contour
options NHINT= and NLEVELS= are used to change the number of levels (ranges) of
the contour. NHINT=10 requests that a number near ten be used that results in "good"
intervals for displaying in the legend. NLEVELS=10 forces ten levels to be used.
contourplotparm x=Height y=Weight
  z=Density / name="cont" 
Features of Continuous Legends
205

  contourtype=fill nhint=10 ;
continuouslegend "cont" /
  title="Density";
You can think of a GRADIENT contour as a FILL contour with a very large number of
levels. A color ramp is displayed with an axis that shows reference points that are within
the data range. The number of reference points is determined by default.
When a CONTINUOUS legend is used with a plot that uses gradient color, the
VALUESCOUNT= and VALUESCOUNTHINT= options can be used to manage the
legend's gradient axis. These options are similar to the NLEVELS= and NHINT= plot
options.
continuouslegend "cont" /
  title="Density"
  valuecounthint=5 ;
continuouslegend "cont" /
  title="Density"
  valuecounthint=10 ;
206
Chapter 8
•
Adding Legends to a Graph

Positioning a Continuous Legend
The ACROSS= , DOWN=, and ORDER= options are not supported by the
CONTINUOUSLEGEND statement. However, you can position a continuous legend
with the LOCATION=, HALIGN=, VALIGN=, and ORIENT= options. By default,
LOCATION=OUTSIDE and ORIENT=VERTICAL when HALIGN=RIGHT or
HALIGN=LEFT.
Using Color Gradients to Represent Response Values
Contour plots, surface plots, and heat map plots support the use of color gradients to
represent response values. For example, the SURFACEPLOTPARM statement provides
the SURFACECOLORGRADIENT=numeric-column setting to map surface colors to a
continuous gradient and enable the use of a continuous legend. All surface types (FILL,
FILLGRID, and WIREFRAME) can be used. The COLORMODEL= and
REVERSECOLORMODEL= options also apply. For more information about surface
plots, see Chapter 13, “Using 3-D Graphics,” on page 309.
ods escapechar="^"; /* Define an escape character */
proc template;
  define statgraph surfaceplot;
   begingraph;
    entrytitle "SURFACECOLORGRADIENT=TEMPERATURE";
    layout overlay3d / cube=false;
      surfaceplotparm x=length y=width z=depth / name="surf"
        surfacetype=fill
        surfacecolorgradient=temperature
        reversecolormodel=true
        colormodel=twocoloraltramp ;
      continuouslegend "surf" / 
        title="Temperature (^{unicode '00B0'x}F)"
        halign=right ;
    endlayout;
   endgraph;
  end;
run;
 
data lake;
Features of Continuous Legends
207

  set sashelp.lake;
  if depth = 0 then Temperature=46;
  else Temperature=46+depth;
run;
 
/* create smoothed interpolated spline data for surface */     
proc g3grid data=lake out=spline;
   grid width*length = depth temperature / naxis1=75 naxis2=75 spline;
run;
proc sgrender data=spline template=surfaceplot;
run;
When you use VALIGN=BOTTOM or VALIGN=TOP instead of the HALIGN= option,
the default orientation of the legend automatically becomes ORIENT=HORIZONTAL:
ods escapechar="^"; /* Define an escape character */
continuouslegend "surf" /
  title="Temperature (^{unicode '00B0'x}F)" 
  valign=bottom ;
Notice the coding that is used to embed a degree symbol into the legend title. For more
information about using symbols in text, see Chapter 7, “Adding and Changing Text in a
Graph,” on page 157.
208
Chapter 8
•
Adding Legends to a Graph

Scaling the Legend Values
The EXTRACTSCALE= option enables you to extract a scale from the legend values in
order to save space. By default, a named scale (millions, billions, and so on) is used for
values of 999 trillion or less. A scientific notation scale (10^n) is used for values over
999 trillion. For large values, the scale factor is set to ensure that the absolute value of
the largest value is greater than 1. For small fractional values, the scale factor is set to
ensure that the absolute value of the smallest value is greater than 1. The
EXTRACTSCALETYPE= option enables you to specify a scientific notation scale for
values less than 999 trillion. The scale that is used is appended to the legend title.
Note: You must specify a title for the legend in order to use this feature.
For example, consider the legend in the following figure.
Because of the fractional density values, the legend takes up a significant amount of
space in the graph. To reduce the footprint of the legend, you can specify
EXTRACTSCALE=TRUE to automatically scale the density values. You can also use
the EXTRACTSCALETYPE= option to select the scale type. The following figure
shows the result.
Features of Continuous Legends
209

210
Chapter 8
•
Adding Legends to a Graph

Chapter 9
Using a Simple Multi-cell Layout
The LAYOUT GRIDDED Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
Defining a Basic Grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
Setting Grid Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
Setting Gutters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
Defining Cells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
Building a Table of Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
Using a Single Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
Using Nested Layouts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
Sizing Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
Row and Column Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
Adjusting Graph Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
The LAYOUT GRIDDED Statement
The GTL provides several layout types to organize your graph into smaller regions
(cells). The GRIDDED and LATTICE layouts support a regular grid of cells with a fixed
number of rows and columns. The DATALATTICE and DATAPANEL layouts generate
classification panels, which are graphs where the number of cells and the cell content are
determined by the values of one or more classification variables.
The GRIDDED layout differs from the classification panel layouts in that the number of
cells must be predefined and that you must define of the content of each cell separately.
GRIDDED is superficially similar to a LATTICE layout because it can create a grid of
heterogeneous plots. However, the LATTICE layout can automatically align plot areas
across columns and rows and has much more functionality. For more information about
the LATTICE layout, see Chapter 10, “Using an Advanced Multi-cell Layout,” on page
225.
Typical applications of GRIDDED layouts are to create:
•
a table of text, such as an inset (discussed in detail in Chapter 17, “Adding Insets to a
Graph,” on page 355)
•
a simple grid of plots (discussed in this chapter)
In a GRIDDED layout, each cell is independent. Contents of the cell can be specified by
a stand-alone plot statement or a nested layout. The following example shows a very
simple GRIDDED layout:
proc template;
211

  define statgraph intro;
    begingraph;
      entrytitle "Two-Cell Gridded Layout";
      layout gridded;
        barchart category=age;
        scatterplot x=height y=weight;
      endlayout;
    endgraph;
  end;
run;
proc sgrender data=sashelp.class template=intro;
run;
In this case, each plot statement is considered independent and is placed in a separate
cell. When no grid size is provided, the default layout creates a graph with one column
of cells, and it allots each cell the same amount of space. The number of rows in the grid
is determined by the number and arrangement of stand-alone plot statements and nested
layouts in the GRIDDED layout block.
Defining a Basic Grid
Although you can generate a nice looking graph in a default GRIDDED layout, in most
cases you will want more control over the grid, how it is populated, and the complexity
of the cell contents.
Setting Grid Dimensions
Assume you want a grid of five plots. Before starting to write code, you must first decide
what grid dimensions you want to set (how many columns and rows) and whether you
want to permit an empty cell in the grid. If do not want an empty cell, you must limit the
grid to five cells, which gives you two choices for the grid dimensions: five columns by
one row (5x1), or one column by five rows (1x5).
212
Chapter 9
•
Using a Simple Multi-cell Layout

To specify the grid size, you use the COLUMNS= or ROWS= option in the LAYOUT
GRIDDED statement. To use ROWS=, you must also specify
ORDER=COLUMNMAJOR.
Two explicit specifications could be used to create the following grid, which contains
one row and five columns:
layout gridded / columns=5;
  /* plot defintions */
endlayout;
When the number of columns is specified, you
place a limit on how many columns can be
displayed across a row. The COLUMNS= option is
honored only if ORDER=ROWMAJOR (the
default).
In the example code to the left, if you were to
include more than five plot definitions, additional
rows (with five columns) would be added
automatically to accommodate all of the cells that
are needed to display all specified plot definitions.
layout gridded / order=columnmajor
                              rows=1;
  /* plot definitions */
endlayout;
When the number of rows is specified, you place a
limit on how many rows can be displayed down a
column. The ROWS= option is honored only if
ORDER=COLUMNMAJOR.
In the example code to the left, if you were to
include more than five plot definitions, additional
columns would be added automatically, but the grid
would not wrap to a second row because the
ROWS= setting limits the grid to a single row.
If you are willing to have an empty cell in the grid, you could use a 2x3 or a 3x2 grid:
layout gridded / columns=3 ;
endlayout;
By default, the layout uses the ORDER=ROWMAJOR setting to populate grid cells.
This specification essentially means "fill in all cells in the top row (starting at the top
left) and then continue to the next row below." COLUMNS=1 by default when
ORDER=ROWMAJOR, so you must specify an alternative setting to increase the
number of columns in the grid:
layout gridded / columns=3 ;
  /* plot1 definition */
  /* plot2 definition */
  /* plot3 definition */
  /* plot4 definition */
  /* plot5 definition */
endlayout;
Defining a Basic Grid
213

Alternatively, you can specify ORDER=COLUMNMAJOR, which means "fill in all
cells in the left column and then continue to the next column to the right." ROWS=1 by
default when ORDER=COLUMNMAJOR, so you must specify an alternative setting to
increase the number of rows in the grid:
layout gridded / rows=2 order=columnmajor ;
  /* plot1 definition */
  /* plot2 definition */
  /* plot3 definition */
  /* plot4 definition */
  /* plot5 definition */
endlayout;
Setting Gutters
To conserve space, the default GRIDDED layout does not include a gap between cell
boundaries. In some cases, this might cause the cell contents to appear too congested.
You can add a vertical gap between all cells with the COLUMNGUTTER= option, and
you can add a horizontal gap between all rows with the ROWGUTTER= option. If no
units are specified, pixels (PX) are assumed.
layout gridded / columns=3 columngutter=5 rowgutter=5 ;
  /* plot1 definition */
  /* plot2 definition */
  /* plot3 definition */
  /* plot4 definition */
  /* plot5 definition */
endlayout;
Note that by adding gutters, you do not increase the size of the graph. Instead, the cells
shrink to accommodate the gutters. Depending on the number of cells in the grid and the
size of the gutters, you will frequently want to adjust the size of the graph to obtain
optimal results, especially if the cells contain complex graphs. For more information, see
“Sizing Issues” on page 218.
Defining Cells
Two valid techniques are available for indicating the contents of a cell:
214
Chapter 9
•
Using a Simple Multi-cell Layout

Technique
Example
Advantages
Disadvantages
stand-alone plot
statement or text
statement
scatterplot x= y=;
simplicity
cannot have overlays
cannot adjust axes,
borders, or
backgrounds (these
are layout options)
layout block
layout overlay;
 scatterplot x= y=;
 seriesplot x= y=;
endlayout;
cell can contain a
complex plot
axes can be adjusted
other layout types can
be used
more complexity
The following definition for a GRIDDED layout shows a simple example:
entrytitle "Simple 3x2 Lattice with Five Cells Populated";
layout gridded / columns=3;
  
  /* stand-alone plot statements define cells 1-3 */
  boxplot x=sex y=age;
  boxplot x=sex y=height;
  boxplot x=sex y=weight;
  /* overlay blocks define cells 4-5 */
  layout overlay; 
    scatterplot y=weight x=height;
    pbsplineplot y=weight x=height;
    entry halign=right "Spline" / valign=bottom;
  endlayout;
  layout overlay; 
    scatterplot y=weight x=height;
    loessplot y=weight x=height;
    entry halign=right "Loess " / valign=bottom;
  endlayout;
     
endlayout;
Defining a Basic Grid
215

Notice that some Y-axis labels are too close to their neighboring plots. You can use the
COLUMNGUTTER= and ROWGUTTER= options to add gutters between all columns
and rows. The following layout statement defines a grid with 30-pixel gutters:
layout gridded / columns=3 columngutter=30 rowgutter=30 ;
Notice that adding gutters visually separates graphs, but it does not increase the overall
graph size. To compensate for the gutters, the cells become smaller. This same behavior
is observed by other multi-cell layouts, as well.
216
Chapter 9
•
Using a Simple Multi-cell Layout

Building a Table of Text
Using a Single Layout
One of the most common applications of the GRIDDED layout is to build a table of text
or statistics using nested ENTRY statements.
layout gridded / columns=2 order=rowmajor
                 border=true columngutter=5px;
  /* row 1 */
  entry halign=left "N";
  entry halign=left "5203";
  /* row 2 */
  entry halign=left "Mean";
  entry halign=left "119.96";
  /* row 3 */
  entry halign=left "Std Dev";
  entry halign=left "19.98";
endlayout;
Tables like this can be organized many different ways. For more information about these
techniques, see Chapter 7, “Adding and Changing Text in a Graph,” on page 157 for
details about ENTRY statements, and see Chapter 17, “Adding Insets to a Graph,” on
page 355 for details about defining the tables.
Using Nested Layouts
When GRIDDED layouts are used to create tables of text, the tables often appear within
another layout. For example, the table might be used within the plot wall of an
OVERLAY layout, or within a SIDEBAR block of a LATTICE layout. When the table
is used within a LAYOUT OVERLAY, it is often necessary to position the table so that
it avoids collision with the plot. In the following example, the AUTOALIGN=(position-
list) option of the GRIDDED layout is used to dynamically position the table in the
TOPRIGHT or TOPLEFT position. TOPRIGHT is tried first, but TOPLEFT is used if
the TOPRIGHT position would cause the histogram to collide with the table.
proc template;
define statgraph inset2;
  begingraph;
    entrytitle "Auto-positioning the Inset Within the Plot Wall";
    layout overlay;
      histogram mrw;
      layout gridded / columns=1 border=true
                       columngutter=5px 
                       autoalign=(topright topleft);
Building a Table of Text
217

        entry  halign=left "N"       halign=right "5203";  
        entry  halign=left "Mean"    halign=right "119.96";
        entry  halign=left "Std Dev" halign=right "19.98";
      endlayout;
    endlayout;
  endgraph;
end;
run;
proc sgrender data=sashelp.heart template=inset2;
run;
In this example, the values for the statistics in the table are hardcoded. Obviously, you
would prefer that the statistics values be calculated in the template. Chapter 17, “Adding
Insets to a Graph,” on page 355 shows how these values can be computed in the
template or passed to the template using dynamic or macro variables.
Sizing Issues
Row and Column Sizes
Unlike the LATTICE layout, the GRIDDED layout offers no way to control column
sizes or row sizes. These sizes are determined by the contents of the cells. If only plots
are used in the cells, the grid is partitioned equally based on the graph size. However,
any individual cell in the grid might contain a legend or text. Consider the next two
examples, in which the sixth cell of the grid is populated with a legend.
layout gridded /  columns=3 rows=2 columngutter=10 rowgutter=10;
  /* standalone plot statements define cells 1-3 */
     boxplot x=sex y=age;
     boxplot x=sex y=height;
218
Chapter 9
•
Using a Simple Multi-cell Layout

     boxplot x=sex y=weight;
  /* overlay blocks define cells 4-5 */
     layout overlay; 
       scatterplot y=weight x=height / group=sex name="scatter" ;
       pbsplineplot y=weight x=height;
       entry halign=right "Spline" / valign=bottom;
         endlayout;
     layout overlay; 
       scatterplot y=weight x=height / group=sex;
       loessplot y=weight x=height;
       entry halign=right "Loess " / valign=bottom;
     endlayout;
  /* legend defines cell 6 */
     discretelegend "scatter" / title="Sex";
endlayout;
In this first case, the legend height and width are smaller than the default column and
rows sizes, so the legend fits nicely into the empty cell.
However, this second case demonstrates that if the legend is larger than the default
column width or row height, the legend size has precedence and the cell size is adjusted
to fit the legend. The same thing might happen when ENTRY statements with lengthy
strings are used in cells.
Sizing Issues
219

Because of this behavior, you should consider using a LATTICE layout whenever you
want to enforce uniform or user-defined column widths and row heights for the grid,
regardless of cell contents. If this layout were changed to a LATTICE, the legend would
be either omitted or clipped, depending on the setting of the DISPLAYCLIPPED=
option of the DISCRETELEGEND statement.
Even when the GRIDDED layout does not contain legend or text statements, the plot-
area size in a row or column in the grid might be changed by cell contents. Consider this
three-cell GRIDDED layout with OVERLAY layouts defining each cell.
Because the Y axes are duplicated across cells, you might try to conserve space by
turning off the Y axes for the second and third cells. You can do this with the
YAXISOPTS=( DISPLAY=NONE) option of the OVERLAY layout. Here is the result:
220
Chapter 9
•
Using a Simple Multi-cell Layout

Once again, the three cells have the same size, but the plot areas do not because the cells
that no longer display the Y axis have extended the plot areas into the space that
formerly displayed the axes. Rather than using the GRIDDED layout, you can use the
LATTICE layout to ensure that the three plot areas have the same size:
This graph was produced with LATTICE layout with an external axis. See Chapter 10,
“Using an Advanced Multi-cell Layout,” on page 225 for details.
Adjusting Graph Size
When defining the grid size, you will generally have some idea of a good overall aspect
ratio for the graph. For example, if you are creating a one row by three column grid, the
graph has a default aspect ratio of 4:3 and looks as follows:
Sizing Issues
221

The graph would look better if the graph height were smaller in relation to the width.
You can establish a good default graph size in the template definition by setting the
DESIGNWIDTH= and DESIGNHEIGHT= options in the BEGINGRAPH statement.
After some experimentation, you might decide that something closer to a 2:1 aspect ratio
looks good:
begingraph / designwidth=400px designheight=180px;
The DESIGNWIDTH= and DESIGNHEIGHT= options set the graph size as part of the
template definition so that if you later want a larger or smaller version of this graph, you
can use the ODS GRAPHICS statement rather than resetting the design size and
recompiling the template. You need only specify either a WIDTH= or a HEIGHT=
option in the ODS GRAPHICS statement. The other dimension is automatically
computed for you, based on the aspect ratio that is specified in the compiled template by
the DESIGNWIDTH= and DESIGNHEIGHT= options.
ods graphics / reset width=375px;
proc sgrender data=sashelp.cars template=fitcompare;
run;
222
Chapter 9
•
Using a Simple Multi-cell Layout

If you provide both the HEIGHT= and WIDTH= options in the ODS GRAPHICS
statement, you completely override the design aspect ratio. If the WIDTH= or HEIGHT=
options are not specified, the design size is in effect.
Setting the DESIGNHEIGHT= and DESIGNWIDTH= options is highly recommended
for all multi-cell layouts that contain plots. This recommendation applies to the
GRIDDED, LATTICE, DATAPANEL, and DATALATTICE layouts.
Sizing Issues
223

224
Chapter 9
•
Using a Simple Multi-cell Layout

Chapter 10
Using an Advanced Multi-cell
Layout
The LAYOUT LATTICE Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
Defining a Basic Lattice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
Setting Grid Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
Setting Gutters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
Defining Cells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
Adding Cell Headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
Creating Uniform Axes across Rows or Columns . . . . . . . . . . . . . . . . . . . . . . . . . . 234
Internal Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
Uniform Axis Ranges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
External Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
Defining a Lattice with Additional Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
Overview: Defining a Lattice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
Transforming the Input Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
Using External Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
Using Cell Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
Adding Sidebars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
Using Column or Row Headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
Adjusting the Sizes of Rows and Columns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
Adjusting the Graph Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
The LAYOUT LATTICE Statement
The LAYOUT LATTICE statement defines a multi-cell grid of graphs that can
automatically align plot areas and tick display areas across grid cells to facilitate data
comparisons among plots. The LATTICE layout differs from the classification panel
layouts in that the number of cells must be predefined and that you must define the
content of each cell separately. LATTICE is superficially similar to a GRIDDED layout
because it can create a grid of heterogeneous plots. However, the LATTICE has much
more functionality and supports the following:
•
adjustable column and row sizes
•
axis equalization on a row or column basis to facilitate comparisons
•
internal axes on a per-cell basis, or external axes for rows or columns of cells
•
internal labeling of cell contents (cell header)
•
external labeling of rows and columns (column and row headers)
225

•
external sidebars that span all columns (top and bottom) or rows (left and right).
Figure 10.1 on page 226 shows a four-cell grid (two rows and two columns). It was
produced with a LATTICE layout to illustrate the features of this layout type. The figure
contains definitions of four plots, which by default are treated independently.
A mixture of plot types or nested layouts could be used in the cells of the lattice. By
default, each plot manages its own axes internal to the lattice boundaries. In the figure, a
light gray border has been added to each plot to show its boundaries within the lattice.
The shaded areas represent the optional features that you can add to the lattice definition.
By default, these shaded areas are not used in the lattice and space is not reserved for
them. Thus, in the default case, the plot areas would expand to replace the shaded areas
in the cells.
Figure 10.1
LATTICE Layout with Internal Axes
The shaded areas that are shown in the figure are typically used as follows:
•
Cell Headers are commonly used to describe the contents of a cell. Notice that the
cell header, when present, has a separate space above the plot wall area. The cell
header can contain more than one line of text, but it is not restricted to displaying
text. For example, you could use this area to display a legend.
•
Sidebars are often used to present text or a legend that pertains to all rows or all
columns in the grid. Again, the sidebar is not limited to text or a legend. You could
place another plot in a sidebar.
226
Chapter 10
•
Using an Advanced Multi-cell Layout

•
Column Headers and Row Headers present text that pertains to individual columns
and rows. These header areas can also be used to display other components, like
legends and plots.
Figure 10.2 on page 227 shows how the lattice would look if you used additional
options to externalize the axes. The figure externalizes both the row and column axes,
but you could externalize the axes only for the rows, or only for the columns. When axes
are external to the cells, the scale of the data ranges that are displayed for the plots are
always unified in some form. Unifying the scale of the data ranges means taking the
minimum of all data minima and the maximum of all data maxima from a set of plots.
The following variations are available for unifying the axes:
•
the scale of the data ranges of all X-axes in a column can be unified on a per-column
basis, or unified across all columns. (See "Column 1 Axis" and "Column 2 Axis" in
Figure 10.2 on page 227.)
•
the scale of the data ranges of all Y-axes in a row can be unified on a per-row basis,
or unified across all rows. (See "Row 1 Axis" and "Row 2 Axis" in Figure 10.2 on
page 227.)
By default, external axes are displayed only on the primary axes (bottom and left). They
are not displayed on the secondary axes (top and right) unless requested. Notice that
external axes use less space and result in larger plot areas than internal axes. (Compare
Figure 10.2 on page 227 with Figure 10.1 on page 226, which is the same size.)
Figure 10.2
LATTICE Layout with External Axes
The LAYOUT LATTICE Statement
227

The following example shows a very simple LATTICE layout:
proc template;
  define statgraph intro;
    begingraph;
      entrytitle "Two-Cell Lattice Layout";
      layout lattice;
        barchart category=age;
        scatterplot x=height y=weight;
      endlayout;
    endgraph;
  end;
run;
proc sgrender data=sashelp.class template=intro;
run;
 
In a LATTICE layout, each plot statement is considered independent and is placed in a
separate cell. When no grid size is provided, the default layout creates a graph with one
column of cells, and it allots each cell the same amount of space. The number of rows in
the grid is determined by the number of stand-alone plot statements in the layout block.
Defining a Basic Lattice
Setting Grid Dimensions
Assume you want a grid of five plots. Before starting to write code, you must first decide
what grid dimensions you want to set (how many columns and rows) and whether you
want to permit an empty cell in the grid. If you do not want an empty cell, you must limit
the grid to five cells, which gives you two choices for the grid dimensions: five columns
by one row (5x1), or one column by five rows (1x5).
228
Chapter 10
•
Using an Advanced Multi-cell Layout

To specify grid size, you use the ROWS= and COLUMNS= options in the LAYOUT
LATTICE statement. These options can be used in three ways to create the following
grid, which contains one row and five columns:
layout lattice / columns=5 rows=1;
  /* plot definitions */
endlayout;
This makes the grid size explicit.
layout lattice / order=columnmajor
                 rows=1;
  /* plot definitions */
endlayout;
To specify only one grid row, also specify
ORDER=COLUMNMAJOR. In this case, there are
as many grid columns as there are plot definitions.
This is the recommended way to create a row of
plots.
layout lattice / columns=5;
  /* plot defintions */
endlayout;
When only the number of columns is specified, you
place a limit on how many plots can appear in one
row. If you were to include more than five plot
definitions, additional rows (with five columns)
would be added automatically because
ORDER=ROWMAJOR by default.
If you are willing to have an empty cell in the grid, you could use a 2x3 or a 3x2 grid:
layout lattice / columns=3 rows=2 ;
endlayout;
Note: The LAYOUT LATTICE statement honors the full specification of columns and
rows, unlike the LAYOUT GRIDDED statement, which honors only COLUMNS=
or ROWS=, depending on the ORDER= setting.
By default, the layout uses the ORDER=ROWMAJOR setting to populate grid cells.
This specification essentially means "fill in all cells in the top row (starting at the top
left) and then continue to the next row below":
layout lattice / columns=3 rows=2 ;
  /* plot1 definition */
  /* plot2 definition */
  /* plot3 definition */
  /* plot4 definition */
  /* plot5 definition */
endlayout;
Defining a Basic Lattice
229

Alternatively, you can specify ORDER=COLUMNMAJOR, which means "fill in all
cells in the left column and then continue to the next column to the right":
layout lattice / columns=3 rows=2 order=columnmajor ;
  /* plot1 definition */
  /* plot2 definition */
  /* plot3 definition */
  /* plot4 definition */
  /* plot5 definition */
endlayout;
Setting Gutters
To conserve space, the default LATTICE layout does not include a gap between cell
boundaries. In some cases, this might cause the cell contents to appear too congested.
You can add a vertical gap between all cells with the COLUMNGUTTER= option, and
you can add a horizontal gap between all rows with the ROWGUTTER= option. If no
units are specified, pixels (PX) are assumed.
layout lattice / columns=3 rows=2 columngutter=5 rowgutter=5 ;
  /* plot1 definition */
  /* plot2 definition */
  /* plot3 definition */
  /* plot4 definition */
  /* plot5 definition */
endlayout;
Note that by adding gutters, you do not increase the size of the graph. Instead, the cells
shrink to accommodate the gutters. Depending on the number of cells in the grid and the
size of the gutters, you will frequently want to adjust the size of the graph to obtain
optimal results, especially if the cells contain complex graphs. For more information, see
“Adjusting the Graph Size” on page 254.
Defining Cells
Several valid techniques are available for indicating the contents of a cell:
230
Chapter 10
•
Using an Advanced Multi-cell Layout

Technique
Example
Advantages
Disadvantages
stand-alone plot
statement
scatterplot x= y=;
simplicity
cannot adjust axes
cannot have overlays
cannot have cell
headers
layout block
layout overlay;
 scatterplot x= y=;
 seriesplot x= y=;
endlayout;
cell can contain a
complex plot
axes can be adjusted
other layout types can
be used
cannot have cell
headers
cell block
cell;
 layout overlay;
  scatterplot x= y=;
  seriesplot x= y=;
 endlayout;
endcell;
makes it easy to see
cell boundary in code
required if a cell
header is desired
adds to program
length when no cell
header is desired
The following code fragment for a LATTICE layout shows a simple example:
entrytitle "Simple 3x2 Lattice with Five Cells Populated";
layout lattice / columns=3 rows=2 columngutter=10 rowgutter=10;
  
  /* stand-alone plot statements define cells 1-3 */
  boxplot x=sex y=age;
  boxplot x=sex y=height;
  boxplot x=sex y=weight;
  /* overlay blocks define cells 4-5 */
  layout overlay;
    scatterplot y=weight x=height;
    pbsplineplot y=weight x=height;
    entry halign=right "Spline" / valign=bottom;
  endlayout;
  layout overlay; 
    scatterplot y=weight x=height;
    loessplot y=weight x=height;
    entry halign=right "Loess " / valign=bottom;
  endlayout;
     
endlayout;
Defining a Basic Lattice
231

In the examples shown to this point, a LATTICE layout produces the same result as a
GRIDDED layout. We can now look at features that are not available with the
GRIDDED layout.
Adding Cell Headers
To add cell headers to the grid, you must specify a CELL block that contains a nested
CELLHEADER block. The CELLHEADER block can contain one or more ENTRY
statements, or it can contain other statements (DISCRETELEGEND, for example).
entrytitle "Simple 3x1 Lattice with Cell Headers";
layout lattice / columns=3 rows=1;
   
  /* cell blocks cells 1-3 */
     cell;
       cellheader;
         entry "Spline Fit";
       endcellheader;
       layout overlay;
         scatterplot y=weight x=height;
         pbsplineplot y=weight x=height;
       endlayout;
     endcell;
     cell;
       cellheader;
         entry "Loess Fit";
       endcellheader;
       layout overlay;
         scatterplot y=weight x=height;
         loessplot y=weight x=height;
       endlayout;
     endcell;
232
Chapter 10
•
Using an Advanced Multi-cell Layout

     cell;
       cellheader;
         entry "Regression Fit";
       endcellheader;
       layout overlay; 
         scatterplot y=weight x=height;
         regressionplot y=weight x=height;
       endlayout;
     endcell;
endlayout;
You can enhance any cell header in the following way:
•
nest a GRIDDED layout in the CELLHEADER block
•
set BORDER=TRUE on the LAYOUT GRIDDED statement
•
add the ENTRY statement(s) to the GRIDDED layout.
Because the GRIDDED layout fills the cell header space above the plot wall, its border
aligns nicely with the plot.
You can further enhance the cell header by making the GRIDDED layout's background
opaque and setting a background color for it. To ensure that the color remains
coordinated with the current style, you could choose any of several style elements that
define light background colors, such as GraphHeaderBackground, GraphBlock, or
GraphAltBlock. Note that several style definitions set the GraphHeaderBackground
color to be the same as the GraphBackground color. For styles like LISTING and
JOURNAL, the background is white.
As a final enhancement, you could coordinate the text color for the cell headers with a
visual attribute in the plot. For example, if you are displaying a fit plot in the cell, you
could set the text color to match the color of the fit line. The TEXTATTRS= option in
the ENTRY statement can be used to set the text properties. The default settings for
TEXTATTRS= are derived from the GraphValueText style element. For more
information about ENTRY statements, see Chapter 7, “Adding and Changing Text in a
Graph,” on page 157.
The following code enhances the cell header block of the first cell. Similar code would
be used to enhance the header blocks of the other two cells:
cellheader;
  layout gridded / border=true opaque=true
                   backgroundcolor=GraphAltBlock:color;
    entry "Spline Fit" / textattrs=(color=GraphFit:contrastColor);
  endlayout;
endcellheader;
Defining a Basic Lattice
233

If you have a lengthy text description to add to a cell header, you should use multiple
ENTRY statements to break the text into small segments. Otherwise, the text might be
truncated. Also, for a given row, if the number of lines of text in the cell headers varies,
a uniform cell height is maintained across the row by setting all the row headers to the
height needed by the largest cell header.
Creating Uniform Axes across Rows or Columns
Internal Axes
By default, the plots in the cells of the LATTICE layout manage their own axes, as
demonstrated by the following example:
proc template;
 define statgraph internalaxes;
  begingraph;
   entrytitle "Internal (cell-defined) Axes";
   layout lattice / columns=2 columngutter=5px;
     histogram mpg_city;
     histogram mpg_highway;
   endlayout;
 endgraph;
end;
run;
proc sgrender data=sashelp.cars template=internalaxes;
run;
234
Chapter 10
•
Using an Advanced Multi-cell Layout

In this example, notice that the X and Y axes have different data ranges for each cell. In
cases where you want to facilitate comparisons of the cell contents, you can set uniform
axis scales across the rows in the grid, or across the columns, or across both.
Uniform Axis Ranges
To set a uniform scale on the X axis in each row of a lattice, use the
COLUMNDATARANGE= option on the LAYOUT LATTICE statement. Likewise, to
set a uniform scale on the Y axis in each row of the lattice, use the
ROWDATARANGE= option. These options accept one of the following values:
DATA
scales the axes independently for each cell. This is the default.
UNION
finds the minimum of the data minima and the maximum of the data maxima, on a
per-row or per-column basis, and sets this range on the appropriate axis for each cell
in a row or column.
UNIONALL
finds the minimum of the data minima and the maximum of the data maxima over all
rows or all columns, and sets this range on the appropriate axis for each cell.
layout lattice / columns=2 columngutter=5px
                 columdatarange=unionall
                 rowdatarange=union ;
  histogram mpg_city;
  histogram mpg_highway;
endlayout;
Creating Uniform Axes across Rows or Columns
235

Note: The default X-axis for a histogram shows ticks at bin midpoints or bin start and
end points. If the histograms happen to have the same bin width, it is possible to
create uniformly scaled X axes. However, when the bin widths are different, there
might not be any common midpoints. To handle this situation, the LATTICE layout
automatically switches to a LINEAR type axis so that the axis tick values can be
uniform, even though they might not be at bin midpoints or boundaries for all
histograms.
Some restrictions apply to the UNION and UNIONALL settings on any row or column
of the lattice:
•
all plots must have the same axis type: LINEAR, LOG, TIME, or DISCRETE
•
if a cell contains a LAYOUT OVERLAY3D or LAYOUT OVERLAYEQUATED
statement, the uniform axis ranges and external axes are not supported for that row or
column.
•
if you create a multipanel lattice with ROWDATARANGE=UNION in effect, the
axis range for each row might differ from panel to panel. The
ROWDATARANGE=UNION option does not extend across panels, which means
the axis range is computed on a per-row basis for each panel rather than across all of
the panels.
External Axes
Specifying External Axes
Whenever axis scales have been unified for a row or a column, you can replace the
individual cell axes in that row or column with a single axis that is external to the cells.
To externalize the X axis, use the following syntax:
COLUMNAXES;
COLUMNAXIS / options ;
<COLUMNAXIS / options ;>
ENDCOLUMNAXES;
To externalize the Y axis, use the following syntax:
236
Chapter 10
•
Using an Advanced Multi-cell Layout

ROWAXES;
ROWAXIS / options ;
<ROWAXIS / options ;>
ENDROWAXES;
Within the axes blocks, you should specify as many COLUMNAXIS or ROWAXIS
statements as there are columns or rows in the grid. The options that are available to
each statement are similar to those that are available for the XAXISOPTS= and
YAXISOPTS= options of a LAYOUT OVERLAY statement. The options that you
specify can differ from statement to statement.
Note: When a row or column external axis is used, all axis options on the internal axes
in that same dimension are ignored.
The following code fragment externalizes the Y axes:
layout lattice / columns=2 columngutter=5px
                 columndatarange=unionall
                 rowdatarange=union;
  histogram mpg_city;
  histogram mpg_highway;
  rowaxes;
    rowaxis / griddisplay=on;
  endrowaxes;
endlayout;
Displaying External Secondary Axes
The DISPLAYSECONDARY= option can be used in a ROWAXIS statement to display
a row axis at the right of the lattice. It can be used in a COLUMNAXIS statement to
display a column axis at the top of the lattice. These external secondary axes are
duplicates of the external primary axis and are not truly independent axes. However, you
can change the features that are displayed on the secondary axis. In the following
example, the ticks and tick values are repeated on the right side of the lattice, but the axis
label is suppressed by not listing it among the features that are requested on the
DISPLAYSECONDARY= option.
layout lattice / columns=2 columngutter=5px
                 columndatarange=unionall
                 rowdatarange=union;
  histogram mpg_city;
Creating Uniform Axes across Rows or Columns
237

  histogram mpg_highway;
  rowaxes;
    rowaxis / griddisplay=on displaysecondary=(ticks tickvalues);
  endrowaxes;
endlayout;
External Axes and Empty Cells
If a LATTICE layout generates empty cells and there are external axes, a row or column
axis might be displayed near one or more of those empty cells. The following example
shows the default case:
layout lattice / columns=2 rows=2
  rowgutter=5px columngutter=5px
  rowdatarange=unionall columndatarange=unionall;
  /* overlay blocks define cells 1-3 */
  layout overlay;
    entry "Spline Fit" / valign=top;
    scatterplot y=weight x=height;
    pbsplineplot y=weight x=height;
  endlayout;
  layout overlay;
    entry "Loess Fit" / valign=top;
    scatterplot y=weight x=height;
    loessplot y=weight x=height;
  endlayout;
  layout overlay;
    entry "Regression Fit" / valign=top;
    scatterplot y=weight x=height;
    regressionplot y=weight x=height;
  endlayout;
     
  rowaxes;
    rowaxis;
    rowaxis;
  endrowaxes;
  columnaxes;
    columnaxis;
238
Chapter 10
•
Using an Advanced Multi-cell Layout

    columnaxis;
  endcolumnaxes;
endlayout;
Adding the SKIPEMPTYCELLS=TRUE setting to the LAYOUT LATTICE statement
eliminates the space that is normally reserved for the empty cells. In that case, an
external axis that might have been displayed near an empty cell is displayed near a
populated cell instead:
layout lattice / columns=2 rows=2
  rowgutter=5px columngutter=5px
  rowdatarange=unionall columndatarange=unionall
  skipemptycells=true ;
Creating Uniform Axes across Rows or Columns
239

Defining a Lattice with Additional Features
Overview: Defining a Lattice
The following sections explain how to generate Figure 10.3 on page 241, which requires
the following tasks:
•
transforming the input data
•
using external axes instead of internal cell axes
•
adding sidebars that display descriptive text
•
using column headers
•
sizing rows.
240
Chapter 10
•
Using an Advanced Multi-cell Layout

Figure 10.3
Stock Plot
Transforming the Input Data
A common use for a lattice is to create a graph that shows different subsets of the same
input data. In some cases, those subsets are already defined in the input data. However,
you frequently have to transform the input data to make it suitable for the graph that you
are trying to create. This might require any or all of the following:
•
summarizing the data
•
transposing the data
•
scaling the data values
•
creating new variables that represent subsets of the data.
The graph that is shown in Figure 10.3 on page 241 is based on data from
Sashelp.Stocks, which contains several years of monthly stock information for three
companies. The data set contains columns Stock, Date , Volume, and AdjClose
(Adjusted Closing Price). However, it does not have the volume and price information in
the form that is needed for the graph. The LATTICE layout does not support subsets of
the input data on a per-cell basis. So, in order to make the cell content different, unique
variables must be created for each cell to provide the appropriate date, volume, and price
information. The following DATA step performs the necessary input data
transformations:
data stock;
  set sashelp.stocks;
  where stock eq "Microsoft" and year(date) in (2004 2005);
  format Date2004 Date2005 date.
         Price2004 Price2005 dollar6.;
  label Date2004="2004" Date2005="2005";
  if year(date) = 2004 then do;
Defining a Lattice with Additional Features
241

     Date2004=date;
     Vol2004=volume*10**-6;
     Price2004=adjclose;
  end;
  else if year(date)=2005 then do;
     Date2005=date;
     Vol2005=volume*10**-6;
     Price2005=adjclose;
  end;
  keep Date2004 Date2005 Vol2004 
       Vol2005 Price2004 Price2005;
run;
The data is filtered for Microsoft and for the years 2004 and 2005. Next, new variables
are created for each year and the Volume and Stock Price within each year. Because the
volumes are large, they are scaled to millions. This scaling is noted in the graph. This
coding results in a "sparse" data set, but it is the correct organization for the lattice
because observations with missing X or Y values are not plotted.
Obs   Date2004   Date2005   Price2004   Price2005   Vol2004   Vol2005
  1         .    01DEC05          .         $26       .       62.8924
  2         .    01NOV05          .         $27       .       71.4692
  3         .    03OCT05          .         $25       .       72.1325
  4         .    01SEP05          .         $25       .       66.9765
  5         .    01AUG05          .         $27       .       65.5300
  6         .    01JUL05          .         $25       .       69.0466
  7         .    01JUN05          .         $25       .       62.9567
  8         .    02MAY05          .         $25       .       62.6998
  9         .    01APR05          .         $25       .       77.0902
 10         .    01MAR05          .         $24       .       72.8997
 11         .    01FEB05          .         $25       .       75.9923
 12         .    03JAN05          .         $26       .       79.6428
 13   01DEC04          .        $26           .     84.4881     .
 14   01NOV04          .        $26           .     86.4461     .
 15   01OCT04          .        $25           .     65.7429     .
 16   01SEP04          .        $24           .     57.7253     .
 17   02AUG04          .        $24           .     52.1046     .
 18   01JUL04          .        $25           .     76.6667     .
 19   01JUN04          .        $25           .     77.0683     .
 20   03MAY04          .        $23           .     58.9425     .
 21   01APR04          .        $23           .     77.3867     .
 22   01MAR04          .        $22           .     77.1119     .
 23   02FEB04          .        $23           .     57.3859     .
 24   02JAN04          .        $24           .     63.6359     .
The key point to be aware of is that every plot in every cell must use variables that
contain just the information appropriate for that cell. You cannot use WHERE clauses
within the template definition to form subsets of the data.
The following initial template defines the lattice:
proc template;
define statgraph lattice1;
 begingraph;
   entrytitle "Microsoft Stock Performance";
   layout lattice / columns=2 rows=2;
     /* define row 1 */
242
Chapter 10
•
Using an Advanced Multi-cell Layout

     seriesplot y=price2004 x=date2004 / lineattrs=GraphData1;
     seriesplot y=price2005 x=date2005 / lineattrs=GraphData1;
     /* define row 2 */
     needleplot  y=vol2004 x=date2004 /
       lineattrs=GraphData2(thickness=2px pattern=solid);
     needleplot  y=vol2005 x=date2005 /
       lineattrs= GraphData2(thickness=2px pattern=solid);
   endlayout;
 endgraph;
end;
run;
proc sgrender data=stock template=lattice1;
run;
Note that because Date2004 and Date2005 have an associated SAS date format that a
TIME axis is used and the variable labels are used for X-axis labels.
Figure 10.4
Initial Lattice for the Graph
Using External Axes
Figure 10.4 on page 243 would benefit from externalizing the X and Y axes because the
external axes reduces the redundant X axis information and unify the data ranges in the
Y axes. We would also like to add grid lines to all axes. To conserve space along the X
axes, the automatic formatting of each TIME axis is turned off in the following template
code. The TICKVALUEFORMAT=MONNAME1. setting indicates how to format the
time axis tick values.
proc template;
Defining a Lattice with Additional Features
243

define statgraph lattice2;
 begingraph / designwidth=495px designheight=370px;
   entrytitle "Microsoft Stock Performance";
   layout lattice / columns=2 rows=2
                    rowdatarange=union columndatarange=union
                    rowgutter=3px columngutter=3px ;
     /* define row 1 */
     seriesplot x=date2004  y=price2004 / lineattrs=GraphData1;
     seriesplot x=date2005  y=price2005 / lineattrs=GraphData1;
     /* define row 2 */
     needleplot  x=date2004  y=vol2004 /    
         lineattrs=GraphData2(thickness=2px pattern=solid);
     needleplot   x=date2005 y=vol2005 /
         lineattrs= GraphData2(thickness=2px pattern=solid);
     rowaxes;
       rowaxis / griddisplay=on display=(label tickvalues)
                 label="Price"  labelattrs=(weight=bold);
       rowaxis / griddisplay=on display=(label tickvalues)
                 label="Volume" labelattrs=(weight=bold);
     endrowaxes;
     columnaxes;
       columnaxis / griddisplay=on display=(label tickvalues)
                    labelattrs=(weight=bold)
                    timeopts=(tickvalueformat=monname1.);
       columnaxis / griddisplay=on display=(label tickvalues)
                    labelattrs=(weight=bold)
                    timeopts=(tickvalueformat=monname1.);
     endcolumnaxes;
   endlayout;
 endgraph;
end;
run;
proc sgrender data=stock template=lattice2;
run;
244
Chapter 10
•
Using an Advanced Multi-cell Layout

Figure 10.5
Lattice with External Axes
Using Cell Axes
In most cases externalizing axes improves graph appearance and streamlines coding.
However, if there are some axis options that do not apply uniformly to all axes in a
column or row, you need to use the standard axis options on a cell basis instead of
external axes.
For example, if you wanted X-axis grid lines to appear on the top row of plots but not on
the second row of plots, you could not use external axes. Instead, you would enclose the
cell contents in an overlay-type layout block and add XAXISOPTS= options on the
layout statements. as shown in the following layout blocks:
/* overlay blocks define X-axis options for row 1 */
layout overlay / xaxisopts=(display=none  griddisplay=on);
  seriesplot x=date2004  y=price2004 / lineattrs=GraphData1;
endlayout;
layout overlay /  xaxisopts=(display=none griddisplay=on);
  seriesplot x=date2005  y=price2005 / lineattrs=GraphData1;
endlayout;
/* overlay blocks define X-axis options for row 2 */
layout overlay / xaxisopts=(display=(label tickvalues)
                            timeopts=(tickvalueformat=monname1.));
  needleplot  x=date2004  y=vol2004 /    
    lineattrs=GraphData2(thickness=2px pattern=solid);
endlayout;
layout overlay / xaxisopts=(display=(label tickvalues)
                 timeopts=(tickvalueformat=monname1.));
Defining a Lattice with Additional Features
245

  needleplot   x=date2005 y=vol2005 /
    lineattrs= GraphData2(thickness=2px pattern=solid);
endlayout;
Adding Sidebars
The graph in Figure 10.5 on page 245 is progressing well, but the ENTRYTITLE is
centered on the entire graph. It would look better if it were centered on the grid area.
This can be accomplished by removing the ENTRYTITLE statement and replacing it
with a SIDEBAR block. Four sidebar areas are available: two that span all columns (one
on the TOP and one on the BOTTOM), and two that span all rows (one on the RIGHT
and one on the LEFT).
sidebar / align=top;
  entry "Microsoft Stock Performance" /
    textattrs=GraphTitleText pad=(bottom=5px);
endsidebar;
Finally, we need a way of explaining that the prices in the first row represent an adjusted
close value. We also need to explain that the axis scaling for the second row is in
millions of shares. Two strategies are available for providing this information.
The first strategy is to create an external legend. For this strategy, we must define legend
text on two of the plot statements, and add a DISCRETELEGEND statement to the
BOTTOM sidebar.
seriesplot x=date2004  y=price2004 /
  lineattrs=GraphData2(thickness=2px pattern=solid)
  name="series" legendlabel="Adjusted Close";
needleplot  x=date2004  y=vol2004 /
  lineattrs=GraphData2(thickness=2px pattern=solid)
  name="needle" legendlabel="Millions of Shares";
sidebar / align=bottom;
  discretelegend "series" "needle" / border=off pad=(top=10px);
endsidebar;
The following graph shows what this modification looks like:
246
Chapter 10
•
Using an Advanced Multi-cell Layout

The other strategy is to add to the row information. At first glance, it would seem that
you could do this very simply by extending the axis label text:
rowaxes;
  rowaxis / griddisplay=on display=(tickvalues)
            label="Volume (Millions of Shares)" ;
  rowaxis / griddisplay=on display=(tickvalues)
            label="Price (Adjusted Close)" ;
endrowaxes;
The problem here is that the extra axis label text might not fit; depending on the text size
and the graph size, the text might be truncated. The axis option SHORTLABEL="string"
is available to handle truncation, but we want more text, not alternate text, and there is
no way to wrap the axis label to two lines. The solution is use row headers instead of
specifying axis labels.
Using Column or Row Headers
For the graph that is shown in Figure 10.5 on page 245, we want to explain that the axis
scaling in the first row is in millions of shares, and that the prices in the second row
represent an adjusted close value. The strategy that we used in “Adding Sidebars” on
page 246 was to create an external legend that displays that information. Another
strategy that we can use is to remove the label information from the row axes and
introduce a ROWHEADERS block, as shown in the following code:
rowaxes;
  rowaxis / griddisplay=on display=(tickvalues);
  rowaxis / griddisplay=on display=(tickvalues);
endrowaxes;
rowheaders;
  layout gridded / columns=1;
    entry "Volume" / textattrs=GraphLabelText;
    entry "(Millions of Shares)" / textattrs=GraphValueText;
Defining a Lattice with Additional Features
247

  endlayout;
  layout gridded / columns=1;
    entry "Price" / textattrs=GraphLabelText;
    entry "(Adjusted Close)" / textattrs=GraphValueText;
  endlayout;
endrowheaders;
By nesting the ENTRY statements in the GRIDDED layouts, we can have multiple lines
of text split exactly where we want and in any text style that we desire. Without the
GRIDDED layouts, only one ENTRY statement could be used per row.
To allow more space for the plots, we can rotate the row header text to make it appear to
be a row axis label. Notice that we must specify COLUMNS=2 for the GRIDDED
layouts.
rowaxes;
  rowaxis / griddisplay=on display=(tickvalues);
  rowaxis / griddisplay=on display=(tickvalues);
endrowaxes;
rowheaders;
  layout gridded / columns=2 ;
    entry "Price" / textattrs=GraphLabelText rotate=90 ;
    entry "(Adjusted Close)" / textattrs=GraphValueText rotate=90 ;
  endlayout;
  layout gridded / columns=2 ;
    entry "Volume" / textattrs=GraphLabelText rotate=90 ;
    entry "(Millions of Shares)" / textattrs=GraphValueText rotate=90 ;
  endlayout;
endrowheaders;
248
Chapter 10
•
Using an Advanced Multi-cell Layout

The clean look of the graph is achieved by removing redundant cell axis information and
moving it to external column and row locations. In this example, the use of row headers
provided the desired flexibility over row axis labels.
Adjusting the Sizes of Rows and Columns
By default, the rows and columns of the lattice are of the same depth and width. You can
use the ROWWEIGHTS= and COLUMNWEIGHTS= options on the LAYOUT
LATTICE statement to designate different row depths or column widths or both.
Consider the following settings:
LAYOUT LATTICE /  ROW=2 COLUMNS=2
  ROWWEIGHTS=(.6 .4) COLUMNWEIGHTS=(.45 .65) ;
Figure 10.6 on page 250 uses these settings. The ROWWEIGHTS= setting specifies that
the first row gets 60% of available row space, and the second row gets 40%. The
COLUMNWEIGHTS= setting specifies that the first column gets 45% of available
column space, and the second column gets 65%. Potentially, the settings on these
options affect the space that is allocated to cell headers and to row and column headers.
Defining a Lattice with Additional Features
249

Figure 10.6
LAYOUT LATTICE with Different Row and Column Sizes
In a traditional stock plot, the area devoted to price information is larger than the area
devoted to the volume information. Here is the adjustment made to the row depths:
layout lattice / columns=2 rows=2 rowweights=(.6 .4)
                 rowdatarange=union columndatarange=union
                 rowgutter=3px columngutter=3px;
250
Chapter 10
•
Using an Advanced Multi-cell Layout

Figure 10.7
LATTICE with Adjusted Row Depths
This next example shows another way that the ROWWEIGHTS= and
COLUMNWEIGHTS= options can be used. Figure 10.8 on page 252 shows a two row
by one column lattice that contains two-dimensional plots and a one-dimensional plot.
The first row is an overlay of a histogram, a density plot, a fringe plot (the short vertical
lines below the histogram) representing each observation, and a legend. The second row
contains a one-dimensional box plot. The X axes have a uniform scale to ensure that the
box plot aligns correctly with the histogram. By default, each row is apportioned an
equal share of the total height. However, because the space that is required to show the
second row (box plot) is so much less than the space that is required for the first row, the
option ROWEIGHTS= can be used to reapportion the row space. For example, the
ROWHEIGHTS=PREFERRED option can be used in this case to set the rows to an
appropriate height automatically as shown in the following example.
Defining a Lattice with Additional Features
251

Figure 10.8
Graph with ROWEIGHTS=PREFERRED
proc template;
  define statgraph distribution;
    begingraph;
      entrytitle "Distribution of Cholesterol";
      entryfootnote halign=left
                   "From Framingham Heart Study (SASHELP.HEART)";
      layout lattice / rowweights=PREFERRED
                       columndatarange=union rowgutter=2px;
        columnaxes;
          columnaxis / display=(ticks tickvalues);
        endcolumnaxes;
        layout overlay / yaxisopts=(offsetmin=.04 griddisplay=auto_on);
          discretelegend "Normal" / location=inside
            autoalign=(topright topleft) opaque=true;
          histogram Cholesterol / scale=percent binaxis=false;
          densityplot Cholesterol / normal( ) name="Normal";
          fringeplot Cholesterol / datatransparency=.7;
        endlayout;
        boxplot y=Cholesterol / orient=horizontal  boxwidth=.9;
      endlayout;
    endgraph;
  end; 
run;
proc sgrender data=sashelp.heart template=distribution;
run;
Note: For a generic version of this template, which can be used to show the distribution
for any continuous variable without redefining the template, see Chapter 14, “Using
Dynamics and Macro Variables to Make Flexible Templates,” on page 327.
252
Chapter 10
•
Using an Advanced Multi-cell Layout

The PREFERRED option is typically used to size rows and columns automatically when
a lattice contains a mix of two-dimensional and one-dimensional plots. In this example,
the system automatically sets the height of the second row to only what is necessary to
properly display the box plot. It then sets the height of the first row to the balance of the
available height. You can also use numeric weights to manually set the row heights, if
you prefer. For example, using the ROWHEIGHTS=(.9 .1) option instead of the
ROWHEIGHTS=PREFERRED option in the previous example produces a similar
result. It apportions 90% of the available height to the first row and 10% to the second
row.
If a row contains a mix of one-dimensional and two-dimensional graphs, the
PREFERRED option sets the row height to the maximum preferred height of the one-
dimensional plots in the row. For columns, it does the same for the column width. This
might produce undesirable results. For example, the following figure shows a simple two
column by one row lattice that uses the default row and column sizing. It contains two-
dimensional plots in the first column and a one-dimensional box plot in the horizontal
direction in the second column.
By default, the row height is set to the maximum available height as shown, which easily
accommodates all of the plots. If the row weight is set to PREFERRED, the row height
is set to the preferred height of the box plot in the second column, which compresses the
plots in the first column as shown in the following figure.
Defining a Lattice with Additional Features
253

The PREFERRED option should be used for rows and columns that contain only one-
dimensional plots. For a row or column that contains a mix of one-dimensional and two-
dimensional plots, use a numeric weight instead.
For more information about the ROWWEIGHTS=PREFERRED and
COLUMNWEIGHTS=PREFERRED options, see “LAYOUT LATTICE Statement” in
SAS Graph Template Language: Reference.
Adjusting the Graph Size
When defining the lattice grid size, you generally have some idea of a good overall
aspect ratio for the graph. For example, if you are creating a one row by three column
grid, the graph has a default aspect ratio of 4:3. It would look something like this:
254
Chapter 10
•
Using an Advanced Multi-cell Layout

The graph would look better if the graph's height were smaller in relation to its width.
You can establish a good default graph size in the template definition by setting the
DESIGNWIDTH= and DESIGNHEIGHT= options in the BEGINGRAPH statement.
After some experimentation, you might decide that a 2:1 aspect ratio looks good:
begingraph / designwidth=400px designheight=200px ;
The DESIGNWIDTH= and DESIGNHEIGHT= options set the graph size as part of the
template definition so that if you later want a larger or smaller version of this graph, you
can use the ODS GRAPHICS statement rather than resetting the design size and
recompiling the template. You need only specify either a WIDTH= or a HEIGHT=
option in the ODS GRAPHICS statement. The other dimension is automatically
computed for you, based on the aspect ratio that is specified in the compiled template by
the DESIGNWIDTH= and DESIGNHEIGHT= options.
ods graphics / reset width=300px;
proc sgrender data=sashelp.cars template=fitcompare;
run;
If you provide both the HEIGHT= and WIDTH= options in the ODS GRAPHICS
statement, you completely override the design aspect ratio. If the WIDTH= or HEIGHT=
options are not specified, the design size is in effect.
Setting the DESIGNHEIGHT= and DESIGNWIDTH= options is highly recommended
for all multi-cell layouts that contain plots. This recommendation applies to the
GRIDDED, LATTICE, DATAPANEL, and DATALATTICE layouts.
Adjusting the Graph Size
255

256
Chapter 10
•
Using an Advanced Multi-cell Layout

Chapter 11
Using Classification Panels
Introduction to Classification Panels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
Classification Panels in the GTL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
The LAYOUT DATAPANEL Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
The LAYOUT DATALATTICE Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
Coding Distinction between DATAPANEL and DATALATTICE . . . . . . . . . . . . 262
The LAYOUT PROTOTYPE Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
Organizing Panel Contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
Overview of What to Consider When Planning a Classification Panel . . . . . . . . . 263
Grid Dimensions and Cell Population Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
Gutters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
Graph Aspect Ratio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
Cell Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
Prototype Orientation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
Setting Panel Axis Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
Controlling Data Ranges of Rows or Columns . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
Setting Axis Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
Controlling the Classification Headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
Using Sidebars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
Controlling the Interactions of Classifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
Appearance of the Last Panel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
User Control of Panel Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
Sparse Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
Missing Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
Using Non-computed Plots in Classification Panels . . . . . . . . . . . . . . . . . . . . . . . . 291
Adding an Inset to Each Cell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
Using PROC SGPANEL to Create Classification Panels . . . . . . . . . . . . . . . . . . . . 295
Introduction to Classification Panels
Classification Panels in the GTL
A classification panel is a graph with one or more cells in which each cell shows a
common graph (called a prototype). The prototypes that are displayed in the cells result
257

from dividing input data into subsets that are determined by the values of one or more
classification variables. GTL provides two layouts that can produce classification panels:
LAYOUT DATAPANEL
supports a list of class variables. The number of rows and columns are controlled by
statement options. Each cell is labeled with the class variable values in the cell
header.
LAYOUT DATALATTICE
supports up to two class variables, one for a row variable and one for a column
variable. One row of cells is created for each value of the row class variable, and one
column is created for each value of the column class variable. The rows and columns
are labeled.
The LAYOUT DATAPANEL Statement
The example in this section uses the LAYOUT DATAPANEL statement to specify a list
of two classification variables: DIVISION (two distinct values) and PRODUCT (three
distinct values). Six combinations (crossings) of these unique values are possible, which
produces a panel with six cells.
Notice the following details about the LAYOUT DATAPANEL statement:
•
The CLASSVARS= option on the LAYOUT DATAPANEL statement can specify a
list of one or more classifiers.
•
In the resulting graph, the data crossings are identified by the cell headers.
The following template code generates Figure 11.1 on page 259.
proc template;
 define statgraph datapanel_intro;
  begingraph;
    entrytitle "Office Furniture Sales";
    layout datapanel classvars=(product division) / columns=2;
      layout prototype;
        seriesplot x=month y=actual;
      endlayout;
    endlayout;
  endgraph;
 end;
run;
258
Chapter 11
•
Using Classification Panels

Figure 11.1
Classification Panel Created with LAYOUT DATAPANEL
In the template code, notice the LAYOUT PROTOTYPE block, which is inside the
LAYOUT DATAPANEL block. This nested block, a required part of the DATAPANEL
layout, defines the graphical content of all of the cells. The COLUMNS=2 setting forces
a DATAPANEL layout to display the cells in a two-column organization. The actual
number of rows that are generated depends on the number of crossings that are in the
data.
For some data, the number of data crossings can be quite large. Thus, when rendering
the graph for a classification panel, it is common to use a WHERE expression to limit
the number of crossings:
proc sgrender data=sashelp.prdsale template=datapanel_intro;
  where country="U.S.A." and region="EAST" and
        product in ("CHAIR" "DESK" "TABLE") ;
  format actual dollar.;
run;
The following schematic shows the general organization of a graph that is produced with
the DATAPANEL layout. If the template code does not use the sidebar areas that are
shown in the schematic, that space is reclaimed in the graph. Also, the order in which
you specify the classification variables affects the cell ordering. The graph that is
represented by the schematic could be produced with CLASSVARS=(classvar1
classvar2).
Introduction to Classification Panels
259

The LAYOUT DATALATTICE Statement
The example in this section uses the LAYOUT DATALATTICE statement to specify
the same two classification variables: DIVISION and PRODUCT. Notice the following
details about the LAYOUT DATALATTICE statement:
•
One of the ROWVAR= or COLUMNVAR= arguments is required. Both can be
specified. Each specifies a single classification variable, enabling you to specify
either one or two classifiers for the graph.
•
In the resulting graph, the data crossings are identified by row or column headers.
•
The default number of columns equals the number of unique values for the
COLUMNVAR classifier.
•
The default number of rows equals the number of unique values for the ROWVAR
classifier.
The following template code generates Figure 11.2 on page 261.
proc template;
define statgraph datalattice_intro;
  begingraph;
    entrytitle "Office Furniture Sales";
    layout datalattice rowvar=product columnvar=division;
      layout prototype;
        seriesplot x=month y=actual;
      endlayout;
260
Chapter 11
•
Using Classification Panels

    endlayout;
  endgraph;
end;
run;
proc sgrender data=sashelp.prdsale template=datalattice_intro;
  where country="U.S.A." and region="EAST" and
        product in ("CHAIR" "DESK" "TABLE");
  format actual dollar.;
run;
Figure 11.2
Classification Panel Created with LAYOUT DATALATTICE
In this example, the grid dimensions are automatically determined by the number of
distinct values of the classifiers PRODUCT and DIVISION.
The following schematic shows the general organization of a graph that is produced with
the DATALATTICE layout. As with a DATAPANEL layout, if the sidebar areas are not
used, that space is reclaimed. Notice that the sidebar area is between the cells and the
row and column headers.
Introduction to Classification Panels
261

Coding Distinction between DATAPANEL and DATALATTICE
The primary difference between coding the DATAPANEL and DATALATTICE layouts
is the way that the classification variables are declared.
DATAPANEL takes one list of variables in parentheses. The number of class variables
in the list is unlimited, though the effectiveness of the graph decreases as the number of
class variables exceeds three or four. In such a case, it is better to use two class
variables, and use the other class variables in the BY statement of the SGRENDER
procedure.
layout datapanel classvars=(product division) / . . . ;
DATALATTICE, on the other hand, takes one variable for a row dimension and/or one
variable for a column dimension:
layout datalattice rowvar=product colvar=division /  . . .;
The LAYOUT PROTOTYPE Statement
In both the DATAPANEL and the DATALATTICE blocks, the nested PROTOTYPE
layout is similar to an OVERLAY layout, with the following major differences:
•
Multiple plots can be overlaid, but BARCHART is the only computed plot that can
be included in the prototype. This means that you cannot use BOXPLOT,
DENSITYPLOT, ELLIPSE, HISTOGRAM, REGRESSIONPLOT, LOESSPLOT,
PBSPLINE, or MODELBAND statements in the PROTOTYPE layout. See “Using
262
Chapter 11
•
Using Classification Panels

Non-computed Plots in Classification Panels” on page 291 for examples of how to
work around this limitation.
•
DISCRETELEGEND, CONTINUOUSLEGEND, ENTRY, ENTRYTITLE, and
ENTRYFOOTNOTE statements cannot be included in the PROTOTYPE layout, nor
can nested layouts. For information about adding a legend or other information
outside of the cells, see “Using Sidebars” on page 277.
•
Axis options for classification panels are specified on the LAYOUT
DATALATTICE or LAYOUT DATAPANEL statement, not on the LAYOUT
PROTOTYPE statement. For information about setting axis options for the layout,
see “Setting Panel Axis Features” on page 271.
Organizing Panel Contents
Overview of What to Consider When Planning a Classification Panel
When planning a classification panel, several factors will influence the layout
specification:
•
Grid dimensions (number of rows and columns)
•
Cell population order as the layout is rendered
•
Gutters between the cells
•
Graph aspect ratio
•
Cell size within the panel
•
Prototype orientation.
Grid Dimensions and Cell Population Order
Assume you want to create a DATAPANEL layout with one classification variable that
has five unique values. Before starting to write code, you must first decide what grid
dimensions you want to set (how many columns and rows) and whether you want to
permit empty cells in the grid. If do not want empty cells, you must limit the grid to five
cells, which gives you two choices for the grid dimensions: five columns by one row
(5x1), or one column by five rows (1x5). If you are willing to have empty cells in the
grid, you could have several grid sizes, such as a 2x3 or a 3x2 grid.
The easiest way to specify a grid dimension is to set both the COLUMNS= and ROWS=
options to the desired number of columns and rows. If one dimension is set, the other
dimension automatically grows to accommodate the number of classification levels. By
default, COLUMNS=1, and the ROWS= option is not set.
By default, the layout uses the ORDER=ROWMAJOR setting to populate grid cells.
This specification essentially means "fill in all cells in the top row (starting at the top
left) and then continue to the next row below." The following layout leaves the default
ORDER=ROWMAJOR setting in effect:
layout datapanel  classvars=(var) / columns=3 rows=2 ;
  layout prototype;
    ... plot statements ...
  endlayout;
endlayout;
Organizing Panel Contents
263

Alternatively, you can specify ORDER=COLUMNMAJOR, which populates the grid by
filling in all cells in the left column (starting at the top), and then continuing with the
next column:
layout datapanel classvars=(var) / columns=3 rows=2 order=columnmajor ;
  layout prototype;
    ... plot statements ...
  endlayout;
endlayout;
One last variation is to specify START=BOTTOMLEFT which produces the following
grids, depending on the setting for the ORDER= option:
layout datapanel classvars=(var) / columns=3 rows=2 start=bottomleft ;
  layout prototype;
    ... plot statements ...
  endlayout;
endlayout;
layout datapanel classvars=(var) / columns=3 rows=2
    order=columnmajor start=bottomleft ;
  layout prototype;
    ... plot statements ...
  endlayout;
endlayout;
264
Chapter 11
•
Using Classification Panels

Note: The ROWS=, COLUMNS=, and START= options are available on both the
DATAPANEL and DATALATTICE layouts. The ORDER= option is available only
on the DATAPANEL layout.
If the number of unique values of the classifiers exceeds the number of defined cells,
you automatically get as many separate panels as it takes to exhaust all the classification
levels (assuming that the PANELNUMBER= option is not used). So if there are 17
classification levels and you define a 2x3 grid, three panels are created (with different
names), and the last panel will have one empty cell. The effect that the classifier values
have on the panel display is illustrated in “Controlling the Interactions of Classifiers” on
page 280.
When you specify multiple classification variables, the crossings are always generated in
a specific way: by cycling though the last classifier, and then the next-to-last, until all
classifiers are exhausted. The following illustration assumes that classifier A has distinct
values a1 and a2, and that classifier B has distinct values b1, b2, and b3:
layout datapanel classvars=(A B) / columns=3 rows=2 ;
Gutters
To conserve space in the graph, the default DATAPANEL and DATALATTICE layouts
do not include a gap between cell boundaries in the panel. In some cases, this might
cause the cell contents to appear too congested. You can add a vertical gap between all
cells with the COLUMNGUTTER= option, and you can add a horizontal gap between
all rows with the ROWGUTTER= option. If no units are specified, pixels (PX) are
assumed.
layout lattice classvars=(var) / columns=3 rows=2
    columngutter=5 rowgutter=5 ;
  layout prototype;
    ... plot statements ...
  endlayout;
Organizing Panel Contents
265

endlayout;
Note that by adding gutters, you do not increase the size of the graph. Instead, the cells
shrink to accommodate the gutters. Depending on the number of cells in the grid and the
size of the gutters, you will frequently want to adjust the size of the graph to obtain
optimal results, especially if the cells contain complex graphs. The issues of graph size
and cell size are discussed in the following sections.
Graph Aspect Ratio
The default graph size is 640 pixels in width and 480 pixels in height, which sets a
default aspect ratio of 4:3 (640:480). Depending on your grid size, you might want to
adjust the aspect ratio to improve the appearance of the panel. The following example
uses a three column by one row grid with the default aspect ratio:
proc template;
 define statgraph onerow;
  begingraph;
    entrytitle "Yearly Profit for Sports Products";
    layout datapanel   classvars=(product_group) / rows=1 ;
      layout prototype;
        barchart category=year response=profit / stat=sum ;
      endlayout;
    endlayout;
  endgraph;
 end;
run;
proc sgrender data=sashelp.orsales template=onerow;
  where product_group in ("Golf" "Tennis" "Soccer");
run;
266
Chapter 11
•
Using Classification Panels

In this case, the height of the cells could be reduced to improve the appearance. To
adjust the size of the graph, use the DESIGNHEIGHT= and/or DESIGNWIDTH=
options in the BEGINGRAPH statement. The following panel is rendered with a 2:1
aspect ratio.
begingraph / designwidth=640px designheight=320px ;
   . . .
endgraph;
IThe DESIGNWIDTH= and DESIGNHEIGHT= options set the graph size as part of the
template definition so that if you later want a larger or smaller version of this graph, you
do not have to reset the design size and recompiling the template. Rather, you can
specify either a WIDTH= or a HEIGHT= option in the ODS GRAPHICS statement. The
other dimension is automatically computed for you, based on the aspect ratio that is
specified in the compiled template by the DESIGNWIDTH= and DESIGNHEIGHT=
options. For example, the following template produces a 5 inch by 2.5 inch graph (the
2:1 aspect ratio is maintained).
Organizing Panel Contents
267

ods graphics / reset width=5in ;
proc sgrender data=sashelp.orsales template=onerow;
  where product_group in ("Golf" "Tennis" "Soccer");
run;
The following template execution produces a 6 inch by 3-inch output (2:1 aspect ratio is
maintained).
ods graphics / reset height=3in ;
proc sgrender data=sashelp.orsales template=onerow;
  where product_group in ("Golf" "Tennis" "Soccer");
run;
Cell Size
You might think that the panel size can be varied to be as big or small as desired.
However, problems arise as the graph size shrinks. Several adjustments in the graph
enable small images to be produced:
•
Font sizes are reduced.
•
Axis tick values are thinned, rotated, or truncated.
•
Labels in the cell headers are truncated. (The options that are available for
controlling the cell header content and size are discussed in “Controlling the
Classification Headers” on page 275.)
For example, the following code sets a 420 pixel width for a classification panel:
ods graphics / reset width=420px ;
proc sgrender data=sashelp.orsales template=onerow;
  where product_group in ("Golf" "Tennis" "Soccer");
run;
This panel is approaching the limits of how small it can be. Reducing the size even more
would eventually produce log messages similar to the following:
268
Chapter 11
•
Using Classification Panels

Cell width 72 is smaller than the minimum cell width 100. All contents are 
removed from the layout.
NOTE: Listing image output written to SGRender.png.
NOTE: There were 48 observations read from the data set SASHELP.ORSALES.
      WHERE product_group in ('Golf', 'Soccer', 'Tennis');
NOTE: PROCEDURE SGRENDER used (Total process time):
      real time           0.50 seconds
      cpu time            0.28 seconds
Although an image is produced, it is empty. The GTL has an internal restriction on how
small a cell in the panel can be: 100 pixels by 100 pixels. Cell size is computed after all
titles, footnotes, and sidebar contents have been established. Thus, if we had additional
titles in the panel design, log messages similar to the one just shown would be issued,
even with a larger panel size.
The CELLWIDTHMIN= and CELLHEIGHTMIN= options on the LAYOUT
DATAPANEL or LAYOUT DATALATTICE statements can be used to specify smaller
cell sizes than 100 pixels:
proc template;
 define statgraph onerow;
  begingraph / designwidth=360px designheight=180px;
    entrytitle "Yearly Profit for Sports Products";
    layout datapanel classvars=(product_group) / rows=1
                     headerlabeldisplay=value
                     cellwidthmin=70 cellheightmin=70 ;
      layout prototype;
        barchart category=year response=profit / stat=sum;
      endlayout;
    endlayout;
  endgraph;
 end;
run;
 
proc sgrender data=sashelp.orsales template=onerow;
  where product_group in ("Golf" "Tennis" "Soccer");
run;
For graph templates that are intended for repeated use (such as the ones that are part of
other SAS products), the effort has been made to set the CELLWIDTHMIN= and
CELLHEIGHTMIN= option to the smallest values that produce a reasonable panel.
Other strategies produce smaller cells without truncating text or resulting in other
unwanted side effects. For example, you can change the orientation of the prototype
layout.
Organizing Panel Contents
269

Prototype Orientation
Rather than generating a graph with the default row orientation, you can present the
same information in a column-oriented format. To do so, you should change the design
size and also consider changing the orientation of the prototype plot. Prototype plots
with discrete axes often benefit from a horizontal orientation because the horizontal
alignment can display discrete axis tick values without rotation or truncation (although it
might eventually thin or stagger the ticks). The following template code sets a horizontal
orientation on a prototype graph.
proc template;
 define statgraph onecol;
  begingraph / designwidth=280px designheight=380px ;
    entrytitle "Yearly Profit for Sports Products";
    layout datapanel   classvars=(product_group) / columns=1
           headerlabeldisplay=value
           cellwidthmin=85 cellheightmin=85 ;
      layout prototype;
        barchart category=year response=profit / stat=sum 
                                   orient=horizontal ;
      endlayout;
    endlayout;
  endgraph;
 end;
run;
 
proc sgrender data=sashelp.orsales template=onecol;
  where product_group in ("Golf" "Tennis" "Soccer");
run;
270
Chapter 11
•
Using Classification Panels

Setting Panel Axis Features
The axes for classification panels are always external to the cells and displayed as axes
for the rows or columns.
Controlling Data Ranges of Rows or Columns
The strength of a classification panel presentation is that it makes it easy to visually
compare similar plots across data categories. In the following example, the profits for
Darts, Golf, and Baseball are compared:
proc template;
 define statgraph unionall;
  begingraph / designwidth=350px
               designheight=400px;
    entrytitle 
      "Yearly Profit for Sports Products";
    layout datapanel
        classvars=(product_group)/
        rowdatarange=unionall ;
      layout prototype;
        barchart category=year response=profit /
          stat=sum;
      endlayout;
    endlayout;
  endgraph;
 end;
run;
proc sgrender data=sashelp.orsales
              template=unionall;
  where product_group in 
       ("Golf" "Darts" "Baseball");
run;
Setting Panel Axis Features
271

By default, the minimum and maximum data ranges over all rows in all panels are used
to establish identical data ranges across for axes that appear in the rows. The same is true
for columns. The options that set these defaults are ROWDATARANGE=UNIONALL
and COLUMNDATARANGE=UNIONALL. In most cases, these settings simplify
quick comparisons because the axis for each row is scaled identically. Likewise, all
columns share a common scale. So the graph just shown does a good job of showing that
Golf products in general provide more profits than Darts or Baseball, but it does not do a
very good job of showing the yearly variation in Baseball profits because those profits
are so small relative to Golf profits.
To set independent axis scaling within each row, you can set
ROWDATARANGE=UNION. Similarly, to set independent axis scaling within each
column, you can set COLUMNDATARANGE=UNION. The following panel shows
independent axes for each row. Now only the data minimum and data maximum for the
cells in each row are considered in deciding the axis range.
layout datapanel classvars=(product_group)  /
                 rowdatarange=union ;
272
Chapter 11
•
Using Classification Panels

In this graph, the relative yearly trends for all product groups are equally apparent, but it
is harder to judge which product group is most profitable because bar lengths are
comparable only within each row.
Setting Axis Options
Classification panels use the ROWAXISOPTS=(axis-opts) and COLUMNAXISOPTS=
(axis-opts) options to set axis features. Options are available for all four axis types
(LINEAR, DISCRETE, LOG, and TIME), and most of the available axis options are a
slightly restricted set of the axis options that are available in an OVERLAY layout.
To demonstrate the use of axis options, the following example suppresses the row axis
label because the tick values are formatted with the DOLLAR format and the axis label
is therefore not needed. The column axis label is suppressed because the panel's title
indicates what the bars represent. Adding title information and eliminating axis labels is
a good way to make more space available to the panel's grid. Axis ticks on a discrete
axis (YEAR) are often not needed, so the example suppresses them. It also turns on grid
lines to make comparisons easier.
You have probably noticed in the examples with bar charts that the bars do not touch the
axis. This happens because a default minimum axis offset is applied to the axis to avoid
possible tick value collision with an adjacent cell. This example overrides the default
offset by setting OFFSETMIN=0, thus enabling the bars to touch the horizontal axis.
layout datapanel  classvars=(product_group)  /
  rowdatarange=union
  columnaxisopts=(display=(tickvalues))
  rowaxisopts=   (display=(tickvalues)
                  linearopts=(tickvalueformat=dollar12.)
                  griddisplay=on offsetmin=0) ;
Setting Panel Axis Features
273

Any DATAPANEL display that uses one or two classifiers can be converted to a
DATALATTICE display. When the ROWVAR= option is used on the LAYOUT
DATALATTICE statement, the cell headers automatically become row headers. When
the COLVAR= option is used, cell headers automatically become column headers. On
the following LAYOUT DATALATTICE statement, the ROWVAR= option is used,
and the values of the classifier are displayed as row headers:
layout datalattice rowvar=product_group  /
  rowdatarange=union
  rowgutter=5px
  columnaxisopts=(display=(tickvalues))
  rowaxisopts   =(display=(tickvalues)
                  linearopts= (tickvalueformat=dollar12.)
                  griddisplay=on offsetmin=0);
274
Chapter 11
•
Using Classification Panels

Controlling the Classification Headers
In many cases, it is not necessary to display the classification-variable name in the
classification headers. Often, just the classification value is sufficient. Both the
DATALATTICE and DATAPANEL layouts support the HEADERLABELDISPLAY=
option. By default, HEADERLABELDISPLAY=NAMEVALUE, which shows both the
variable name and the value. You can set HEADERLABELDISPLAY=VALUE to
display only the value or HEADERLABELDISPLAY=NONE to suppress the headers.
Row and column headers are unique to the DATALATTICE layout. By default,
COLUMNHEADERS=TOP, but you can set COLUMNHEADERS=BOTTOM or
COLUMNHEADERS=BOTH. Likewise, ROWHEADERS=RIGHT is the default
setting, but you can set LEFT or BOTH on the ROWHEADERS= option. The location
of the row or column axis information can be changed by using the
DISPLAYSECONDARY= axis option. In this next example, the row headers are
relocated to the left, and the axis information is relocated to the right. Note that
DISPLAY=NONE is also needed to remove the default row axis information from the
left side.
layout datalattice rowvar=product_group  /
  rowdatarange=union
  rowgutter=5px
  rowheaders=left
  headerlabeldisplay=value
  columnaxisopts=( display=(tickvalues) )
  rowaxisopts=   ( display=none displaysecondary=(tickvalues)
                  linearopts=(tickvalueformat=dollar12.)
Controlling the Classification Headers
275

                  griddisplay=on offsetmin=0 );
Both the DATAPANEL and DATALATTICE layouts support options that control the
background and text properties of the classification headers. By default, the background
of the cell headers is transparent (HEADEROPAQUE=FALSE).
To set a background color, you must set the HEADERBACKGROUNDCOLOR= option
to a fill color. In the following example, the color is set as a style reference. You must
also set HEADEROPAQUE=TRUE. You can use the HEADERLABELATTRS= option
to set the text properties of the classification headers. For example, if the classification
values are long, you can reduce their font size with HEADERLABELATTRS=
(SIZE=6pt), or use the smallest font in the current style by setting
HEADERLABELATTRS=GraphDataText. In the following example, the headers are set
to be bold.
layout datalattice rowvar=product_group  /
  rowdatarange=union
  rowgutter=5px
  rowheaders=left
  headerlabeldisplay=value
  headerlabelattrs=(weight=bold)
  headeropaque=true
  headerbackgroundcolor=GraphAltBlock:color
  columnaxisopts=(display=(tickvalues) )
  rowaxisopts=   (display=none displaysecondary=(tickvalues)
                  linearopts=(tickvalueformat=dollar12.)
                  griddisplay=on offsetmin=0);
276
Chapter 11
•
Using Classification Panels

Using Sidebars
Sidebars are useful for aligning information outside of the grid. In the following
example, a sidebar is used to display a graph title, rather than using an ENTRYTITLE
statement. The advantage of using sidebars for title and footnote information is that a
sidebar is always horizontally aligned on the grid itself, not on the complete graph width.
Of course, you have to specify the title text in an ENTRY statement, and then set the
appropriate text properties (TEXTATTRS= option), alignment (HALIGN= option), and
padding (PAD= option). Compare the default centering of the "title" in this example
with similar examples in this chapter that specify a title with the ENTRYTITLE
statement.
This example also uses a sidebar to display a legend. A legend can be placed in any of
the TOP, BOTTOM, RIGHT, or LEFT sidebars. The legend's alignment is based on the
grid size, not the graph size.
proc template;
 define statgraph sidebar;
   begingraph / designwidth=490px designheight=800px border=false;
  
     layout datapanel classvars=(product division) / columns=2
         columngutter=10  rowgutter=5
         headerlabelattrs=GraphLabelText(weight=bold)
         rowaxisopts=(display=(tickvalues))
         columnaxisopts=(display=(ticks tickvalues)
           offsetmin=0
           linearopts=(tickvalueformat=dollar6. viewmax=2000
Using Sidebars
277

           tickvaluelist=(500 1000 1500 2000)));
       sidebar / align=top;
         entry "Office Furniture Sales" /
           textattrs=GraphTitleText(size=14pt) pad=(bottom=5px);
       endsidebar;
       sidebar / align=bottom;
         discretelegend "actual" "predict";
       endsidebar;
       layout prototype;
         barchart category=month response=actual  /
           orient=horizontal fillattrs=GraphData1
             barwidth=.6 name="actual";
         barchart category=month response=predict /
           orient=horizontal fillattrs=GraphData2
             barwidth=.3 name="predict";
       endlayout;
     endlayout;
   endgraph;
 end;
run;
proc sgrender data=sashelp.prdsale template=sidebar;
   where country="U.S.A." and region="EAST" and
         product in ("CHAIR" "DESK" "TABLE");
run;
278
Chapter 11
•
Using Classification Panels

Using Sidebars
279

Controlling the Interactions of Classifiers
Whenever you have classifiers with a large number of unique levels, the potential exists
for generating a large number of cells in the panel. If you do not want to see all
classification levels, you can limit the crossings by using a WHERE expression when
creating the input data. Or, you can use a WHERE expression as part of the PROC
SGRENDER step that renders the graph.
Appearance of the Last Panel
If you set the ROWS= and COLUMNS= options to define a relatively small grid, PROC
SGRENDER automatically generates as many separate panels as it takes to exhaust all
the classification levels. Depending on the grid size and total number of classification
levels, one or more empty cells might be created on the last panel to complete the grid.
For example, if there are seven classification levels and you define a 2x2 grid, two
panels are created (with different names), and the last panel contains one empty cell:
layout datapanel classvars=(product_category) /
    rows=2 columns=2
    headerlabeldisplay=value
    rowaxisopts=(griddisplay=on offsetmin=0
    display=(tickvalues) linearopts=(tickvalueformat=dollar12.));
  layout prototype;
    barchart category=year response=profit / fillattrs=GraphData1;
  endlayout;
  sidebar / align=top;
    entry  "Profit for Selected Sports Items" /
      textattrs=GraphTitleText;
  endsidebar;
endlayout;
280
Chapter 11
•
Using Classification Panels

To eliminate empty cells on the last panel, you can specify
SKIPEMPTYCELLS=TRUE:
layout datapanel classvars=(product_category) /
    rows=2 columns=2
    skipemptycells=true
    headerlabeldisplay=value
    rowaxisopts=(griddisplay=on offsetmin=0
    display=(tickvalues) linearopts=(tickvalueformat=dollar12.));
The SKIPEMPTYCELLS= option also applies to a DATALATTICE layout. The
following output shows the last panel when Division has two levels and Product has
Controlling the Interactions of Classifiers
281

three levels, while ROWS=2 and COLUMNS=2. When SKIPEMPTYCELLS=FALSE,
the last panel will have a column of empty cells. Entire rows or columns of empty cells
can be removed by setting SKIPEMPTYCELLS=TRUE.
282
Chapter 11
•
Using Classification Panels

User Control of Panel Generation
It is possible to control the generation of panels. Consider the following output, in which
each panel displays in its upper right corner the current panel number and the total
number of panels:
Controlling the Interactions of Classifiers
283

284
Chapter 11
•
Using Classification Panels

Normally, when the number of cells to be created in a panel is greater than the defined
panel size in the template (rows * columns), then the SGRENDER procedure
automatically produces the number of panel graphs that are necessary to draw all of the
cells in the data. However, you can instruct the template to create only one panel, which
is specified by the PANELNUMBER= option. This feature can be used to control the
creation of the panels.
For example, the preceding panels were generated with the following template code,
which uses the NMVAR statement to declare macro variables that will resolve as
numbers. The PANELNUMBER=PANELNUM setting is a directive indicating which
panel to produce. The ENTRYTITLE statement changes as the panel number changes.
For more information about how to pass information to a template at run time, see
Chapter 14, “Using Dynamics and Macro Variables to Make Flexible Templates,” on
page 327.
proc template;
define statgraph panelgen;
  nmvar PANELNUM TOTPANELS ROWS COLS YEAR;
  begingraph;
    entrytitle halign=right "Panel " PANELNUM " of " TOTPANELS /
        textattrs=GraphFootnoteText;
    layout datapanel classvars=(product division) /
        rows=ROWS columns=COLS
        cellheightmin=50 cellwidthmin=50
        skipemptycells=true
        columnaxisopts=(type=time timeopts=(tickvalueformat=month.))
        rowaxisopts=(griddisplay=on)
        panelnumber=PANELNUM;
      layout prototype;
        seriesplot x=month y=actual / lineattrs=GraphData1;
      endlayout;  
Controlling the Interactions of Classifiers
285

      sidebar / align=top;
        entry "Office Furniture Sales for " YEAR /
          textattrs=GraphTitleText;
      endsidebar;
    endlayout;
  endgraph;
end;
run;
Now that the template is defined, a macro is needed to compute the number of panels
that will be generated, execute PROC SGRENDER an appropriate number of times, and
initialize the macro variables that are referenced in the template. The macro parameters
ROWS and COLUMNS allow different grid sizes to be used. The graph size changes
based on the grid size.
%macro panels(rows=1,cols=1,year=1994);
  %local div_vals prod_vals panels totpanels panelnumber;
  /* find the number of unique values for the classifiers */
  proc sql noprint;
    select n(distinct division) into: div_vals from sashelp.prdsale;
    select n(distinct product) into: prod_vals from sashelp.prdsale; 
  quit;
  /* compute the number of panels based on input rows and cols */
  %let panels=%sysevalf(&div_vals * &prod_vals / (&rows * &cols));
  %let totpanels=%sysfunc(ceil(&panels)); /* round up to next integer */
  ods graphics / reset ;
  ods html close;
  ods listing style=listing gpath="." image_dpi=200;
  %do panelnum=1 %to &totpanels;
     
    ods graphics / imagename="Panel&panelnum"
      width=%sysevalf(200*&cols)px height=%sysevalf(200*&rows)px;
    proc sgrender data=sashelp.prdsale template=panelgen;
      where country="U.S.A." and region="EAST" and year=&year;
    run;  
  %end;
  ods listing close;
  ods html;
%mend;
The three panels that are shown at the beginning of this section were produced with the
following macro call:
%panels(rows=2,cols=2)
If you invoke the macro with different grid dimensions, the number of panels is
recomputed and a new graph size is set. For example, if the following macro call is
issued, two panels are generated (only the last panel is shown here):
%panels(rows=2,cols=3)
286
Chapter 11
•
Using Classification Panels

Sparse Data
Multiple classifiers sometimes have a hierarchical relationship, which results in very
sparse data when the classifier values are crossed. For example, consider the following
LAYOUT DATAPANEL statement:
layout datapanel classvars=(state city) / rows=4 columns=5;
Assume that the data for the STATE and CITY classifiers contains information for 20
states and their capitals. How many panels would you expect to produce? One, or
twenty? Or 400?
The answer is one panel, which is the desired result. A single panel is produced because
even though the default DATAPANEL layout attempts to generate a complete Cartesian
product of the crossing values (400 STATE*CITY crossings in this case), it does not
create panel cells for crossings that have no data. The SPARSE= option controls whether
panel cells are created when you have no observations for a crossing, and by default
SPARSE=FALSE.
The DATALATTICE layout does not support a SPARSE= option. The DATALATTICE
creates a row / column for each unique value of the ROWVAR / COLUMNVAR. So a
cell is created for all crossings of the two variable values, thus creating 400 cells.
Sometimes there are unexpected gaps in the data when classification variables are
crossed. For example, suppose you are conducting a study where a number of subjects
each receives over time four treatments that might lower the subject's heart rate after
various amounts of physical activity. However, assume that Subject 101 did not get
Treatment 3, and Subject 102 did not get Treatment 2. In this case, when you create a
DATAPANEL layout presenting four treatments for three subjects per panel, the
expected alignment of the columns does not work:
Controlling the Interactions of Classifiers
287

In this situation, you can generate a placeholder cell whenever a subject misses a
treatment. To do so, specify SPARSE=TRUE for the layout panel.
288
Chapter 11
•
Using Classification Panels

proc template;
 define statgraph sparse;
  begingraph / designwidth=490px designheight=450px;
    entrytitle  "Heart Rates for Subjects";
    layout datapanel classvars=(subject treatment) /
        columns=4 rows=3 
        cellheightmin=50 cellwidthmin=50
        skipemptycells=true
        sparse=true
        columnaxisopts=(display=(tickvalues))
        rowaxisopts=(display=(label) offsetmin=0);
      layout prototype;
        barchart category=task response=heartrate / barlabel=true;
      endlayout;
    endlayout;
  endgraph;
 end;
run;
The SPARSE= option does not apply to DATALATTICE layouts because they are
inherently sparse. When you specify two classifiers, the DATALATTICE layout
manages this situation automatically.
Controlling the Interactions of Classifiers
289

proc template;
 define statgraph datalattice;
  begingraph / designwidth=490px designheight=400px;
    entrytitle  "Heart Rates for Subjects";
    layout datalattice rowvar=subject columnvar=treatment /
        rows=3  rowgutter=5px
        cellheightmin=50 cellwidthmin=50
        rowheaders=left
        skipemptycells=true
        columnaxisopts=(display=(tickvalues))
        rowaxisopts=(display=none displaysecondary=(label) offsetmin=0);
      layout prototype;
        barchart category=task response=heartrate / barlabel=true;
      endlayout;
    endlayout;
  endgraph;
 end;
run;
Missing Values
By default, missing class values are included in the classification levels for the panel.
When the data contains missing classification values, cells are created in the panel for
the missing classes. The classification headers for the missing values are either blank for
missing string values or a dot for missing numeric values. You can use the
INCLUDEMISSINGCLASS=FALSE option to ignore the missing values. If you prefer
to keep the missing values, you can create a format that specifies more meaningful
headings for the missing classes. Here is an example that creates a format for missing
product name and branch number classes.
proc format;
290
Chapter 11
•
Using Classification Panels

  value $prdfmt    " "="Missing Product";
  value branchfmt .="Missing Branch";
run;
The format is applied to the classification columns in the PROC SGRENDER statement.
For the missing data, the labels specified in the format statement are used as the
headings for the missing classes.
Using Non-computed Plots in Classification
Panels
So far the discussion has focused on how to set up the grid and axes of the panel using
simple prototype examples. However, complex prototype plots can also be specified,
although BARCHART is the only computed plot that can be used in the prototype. The
restriction of using only non-computed plots in the prototype is mitigated by the fact that
most computed plot types are available in a non-computed (parameterized) version—
BOXPLOTPARM, ELLIPSEPARM, and HISTOGRAMPARM. Also, the fit line
statements (REGRESSIONPLOT, LOESSPLOT, or PBSPLINEPLOT) can be emulated
with a SERIESPLOT, and the MODELBAND statement can be emulated with a more
general BANDPLOT statement, provided the appropriate variables have been created in
the input data. Many SAS/STAT and SAS/ETS procedures can create output data sets
with this information.
The following example uses PROC GLM to create an output data set that is suitable for
showing a panel of scatter plots with overlaid fit lines and confidence bands.
proc template;
define statgraph dosepanel;
 begingraph / designwidth=490px designheight=350px;
   layout datapanel classvars=(dose) / rows=1;
Using Non-computed Plots in Classification Panels
291

     layout prototype;
       bandplot    x=days limitupper=uclm limitlower=lclm / name="clm"
                     display=(fill)  fillattrs=GraphConfidence
                     legendlabel="95% Confidence Limits";
       bandplot    x=days limitupper=ucl limitlower=lcl / name="cli"
                     display=(outline) outlineattrs=GraphPredictionLimits
                     legendlabel="95% Prediction Limits";            
       seriesplot  x=days y=predicted / name="reg"
                     lineattrs=graphFit legendlabel="Fit";
       scatterplot x=days y=response /     primary=true
                     markerattrs=(size=5px) datatransparency=.5;
     endlayout;
     sidebar / align=top;
       entry  "Predicted Response to Dosage (mg) over Time" /
               textattrs=GraphTitleText pad=(bottom=10px);
     endsidebar;
     sidebar / align=bottom;
       discretelegend "reg" "clm" "cli" / across=3;
     endsidebar;
   endlayout;
  endgraph;
 end;
run;
The following procedure code creates the required input data set for the template. It uses
a BY statement with the procedure to request the same classification variable that is used
in the panel.
data trial;
 do Dose = 100 to 300 by 100;
   do Days=1 to 30;
     do Subject=1 to 10;
       Response=log(days)*(400-dose)* .01*ranuni(1) + 50;
     output;
   end;
  end;
end;
run;
proc glm data=trial alpha=.05 noprint;
 by dose;
 model response=days / p cli clm;
 output out=stats
        lclm=lclm uclm=uclm
        lcl=lcl ucl=ucl
        predicted=predicted;
run; quit;
 
ods html style=statistical;
proc sgrender data=stats template=dosepanel;
run;
The advantage of using a procedure to generate the data is that the statistical procedures
provide many options for controlling the model. A robust model enhances the output
data set and therefore benefits the graph.
292
Chapter 11
•
Using Classification Panels

Adding an Inset to Each Cell
You can define a unique inset for each cell of the classification panel with the INSET=
and INSETOPTS= options. The following graph builds on the last example by adding
insets:
proc template;
define statgraph panelinset;
 begingraph / designwidth=495px designheight=350px;
  layout datapanel classvars=(dose) / rows=1
         inset=(F PROB)
         insetopts=(textattrs=(size=7pt) halign=right valign=bottom) ;
    layout prototype;
      bandplot    x=days limitupper=uclm limitlower=lclm / name="clm"
                    display=(fill)  fillattrs=GraphConfidence
                    legendlabel="95% Confidence Limits";
      bandplot    x=days limitupper=ucl limitlower=lcl / name="cli"
                    display=(outline) outlineattrs=GraphPredictionLimits
                    legendlabel="95% Prediction Limits";
      seriesplot  x=days y=predicted / name="reg"
                    lineattrs=graphFit legendlabel="Fit";
      scatterplot x=days y=response /     primary=true
                    markerattrs=(size=5px) datatransparency=.5;
    endlayout;
    sidebar / align=top;
      entry  "Predicted Response to Dosage (mg) over Time" /
              textattrs=GraphTitleText pad=(bottom=10px);
    endsidebar;
    sidebar / align=bottom;
      discretelegend "reg" "clm" "cli" / across=3;
Adding an Inset to Each Cell
293

    endsidebar;
  endlayout;
 endgraph;
end;
run;
 
data trial;
 do Dose = 100 to 300 by 100;
  do Days=1 to 30;
   do Subject=1 to 10;
   Response=log(days)*(400-dose)* .01*ranuni(1) + 50;
   output;
   end;
  end;
 end;
run;
proc glm data=trial alpha=.05 noprint outstat=outstat ;
 by dose;
 model response=days / p cli clm;
 output out=stats
        lclm=lclm uclm=uclm lcl=lcl ucl=ucl predicted=predicted;
run; quit;
data inset;
  set outstat (keep=F PROB _TYPE_ where=(_TYPE_="SS1"));
  label F="F Value " PROB="Pr > F ";
  format F best6. PROB pvalue6.4;
run;
data stats2;
  merge stats inset;
run;
 
ods html style=statistical;
proc sgrender data=stats2 template=panelinset;
run;
In this template definition,
•
The INSET=(F PROB) option names two variables that contain the values for the F
statistic and its p value. The INSETOPTS= option positions the inset and sets its text
properties.
•
The OUTSTAT= option of PROC GLM creates a data set with several statistics for
each BY value.
•
The DATA INSET step selects the appropriate three observations from the
OUTSTAT data set. The F and PROB variables are assigned labels and formats.
•
The DATA STATS2 step creates a new input data set by performing a non-match
merge on the STATS and INSET data sets. It is important to structure the input data
in this fashion.
“Adding Insets to Classification Panels” on page 372 discusses this topic in detail and
shows the coding for another example in which the inset information must align
correctly in a multi-row and multi-column classification panel.
294
Chapter 11
•
Using Classification Panels

Using PROC SGPANEL to Create Classification
Panels
When creating a panel like the one shown in “Using Non-computed Plots in
Classification Panels” on page 291, you might find it easier to create the panel by using
PROC SGPANEL in SAS because the procedure does all the necessary data
computations for you. For example, the REGRESSIONPLOT, LOESSPLOT, and
PBSPLINEPLOT statements have been incorporated into the SGPANEL procedure as
REG, LOESS, and PBSPLINE statements. (SGPANEL can also generate other plot
types.) By default on PROC SGPANEL, the PANELBY statement creates a
DATAPANEL layout.
ods html style=statistical;
title "Predicted Response to Dosage (mg) over Time";
proc sgpanel data=trial;
  panelby dose / rows=1;
  reg x=days y=response / cli clm;
run;
Most, but not all, features of the DATALATTICE and DATAPANEL layouts are
provided in the SGPANEL procedure.
The SGPANEL procedure supports computed plot statements such as HISTOGRAM,
DENSITY, DOT, VBOX, and HBOX (vertical and horizontal box plots). The
PANELBY statement controls the layout, determining whether a DATAPANEL,
DATALATTICE, or other layout is used to produce the graph. ROWAXIS and
COLAXIS statements control the external axes, and the KEYLEGEND statement creates
legends, which are placed in sidebars for you.
Using PROC SGPANEL to Create Classification Panels
295

The SGPANEL procedure does not have a PROTOTYPE block because all of the plot
statements after PANELBY are considered part of the prototype. The SGPANEL
procedure generates GTL template code behind the scenes and executes the template to
create its output. See SAS ODS Graphics: Procedures Guide for details.
The following example shows additional features of SGPANEL:
ods html style=statistical;
title "Cholesterol Distribution by Gender and Weight";
proc sgpanel data=sashelp.heart;
  panelby sex weight_status /  layout=lattice onepanel novarname;
  histogram cholesterol;
  density cholesterol / name="density";
  refline 227 / axis=x name="ref" legendlabel="Overall Mean = 227";
  rowaxis  offsetmin=0 offsetmax=.1 max=30;
  keylegend  "density" "ref";
run;
296
Chapter 11
•
Using Classification Panels

Using PROC SGPANEL to Create Classification Panels
297

298
Chapter 11
•
Using Classification Panels

Chapter 12
Using an Equated Layout
The LAYOUT OVERLAYEQUATED Statement . . . . . . . . . . . . . . . . . . . . . . . . . 299
Basic Display Features of Equated Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Types of Equated Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Defining Axes for Equated Layouts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
The LAYOUT OVERLAYEQUATED Statement
Several SAS procedures create plots where the X and Y axes are scaled in the same
units. Here are some samples of such plots taken from the Examples section of the
procedure documentation.
Figure 12.1
Sample Plot from PROC PRINQUAL
299

Figure 12.2
Sample Plot from PROC LOGISTIC
Figure 12.3
Sample Plot from PROC PLS
Whenever the same units of measure are used on both axes, it is desirable that the
distance displayed between the same data interval be the same on both axes. To achieve
this effect, you must use an OVERLAYEQUATED layout.
300
Chapter 12
•
Using an Equated Layout

For specifying plot statements, the OVERLAYEQUATED layout is similar to the
OVERLAY layout: you can specify one or more 2-D plot statements within the layout
block. However, OVERLAYEQUATED imposes a restriction on the plot axes and
differs from OVERLAY in several ways. With OVERLAYEQUATED,
•
Both X and Y axes are always numeric (TYPE=LINEAR). Thus, plot types that have
discrete or binned axes (BOXPLOT, BOXPLOTPARM, BARCHARTPARM,
HISTOGRAM, and HISTOGRAMPARM ) cannot be used within this layout.
•
For equal data intervals on both axes, the display distance is the same. For example,
an interval of 2 units on the X axis maps to the same display distance as an interval
of 2 units on the Y axis.
•
The slope of a line in the display is the same as the slope in the data. In other words,
a 45° slope in data will be represented by a 45° slope in the display. The
EQUATETYPE= option offers different ways of presenting the data ranges while
preserving the 45° display slope. (See “Types of Equated Axes” on page 301).
The following figure illustrates how a series plot might be displayed when it is specified
within an OVERLAYEQUATED layout rather than an OVERLAY layout:
Basic Display Features of Equated Plots
Types of Equated Axes
The EQUATETYPE= option of the LAYOUT OVELAYEQUATED statement manages
the display of the axes. The following values are available:
FIT
X and Y axes have equal increments between tick values. The data ranges of both
axes are compared to establish a common increment size. The axes can be of
different lengths and have a different number of tick marks. Each axis represents its
own data range. One axis can be extended to use available space in the plot area.
This is the default.
Basic Display Features of Equated Plots
301

EQUATE
Same as FIT except that neither axis is extended to use available space in the plot
area.
SQUARE
Both the X and Y axes have the same length and the same tick values. The axis
length and tick values are chosen so that the minimum and maximum of both X and
Y appear in the range of values appearing on both axes.
The following example template uses the EQUATETYPE= option:
302
Chapter 12
•
Using an Equated Layout

proc template;
  define statgraph mpg;
    mvar TYPE;
    begingraph;
      entrytitle "Comparison of " TYPE " Vehicle Mileage by Origin";
      entryfootnote halign=right "SASHELP.CARS"; 
      layout overlayequated / equatetype=fit;
        scatterplot x=mpg_city y=mpg_highway / group=origin
          name="s" markerattrs=(size=7px);
        referenceline x=eval(mean(mpg_city)) /
          curvelabel=eval(put(mean(mpg_city),4.1));
        referenceline y=eval(mean(mpg_highway)) /
          curvelabel=eval(put(mean(mpg_highway),4.1));
        discretelegend "s";
        layout gridded / columns=1 halign=right valign=bottom;
          entry "Reference lines at";
          entry "average overall city";
          entry "and highway mileages";
        endlayout;
      endlayout;
    endgraph;
  end;
 run;
 
 %let type=SUV;
 proc sgrender data=sashelp.cars template=mpg;
   where type="&type";
 run;
Note: This program uses several features, such as run-time macro variable resolution,
EVAL expressions, and insets. All of these features are discussed in detail in other
chapters.
Basic Display Features of Equated Plots
303

Defining Axes for Equated Layouts
Axes for the OVERLAYEQUATED layout are similar to axes for the OVERLAY layout
with the following exceptions:
•
Both axes are always of TYPE=LINEAR.
•
Some axis options that always apply to both axes are specified in a
COMMONAXISOPTS= option. Some of the supported options are INTEGER,
TICKVALUELIST, TICKVALUESEQUENCE, VIEWMAX, and VIEWMIN.
•
XAXISOPTS= and YAXISOPTS= options are supported (with a different set of
suboptions from those of OVERLAY), but X2AXISOPTS= and Y2AXISOPTS=
options are not supported. Some of the supported options are DISPLAY, LABEL,
GRIDDISPLAY, DISPLAYSECONDARY, OFFSETMAX, OFFSETMIN,
THRESHOLDMAX, THRESHOLDMIN, and TICKVALUEFORMAT.
•
No independent secondary (X2, Y2 ) axes are available, although secondary axes
that mirror the primary axes can be displayed. The XAXIS= and YAXIS= options
are ignored.
Chapter 5, “Managing Axes in an OVERLAY Layout,” on page 63 discusses many of
the axis options that are available for managing graph axes.
To illustrate how to control axes for the equated layout, we will look at a simplified
version of the PPPLOT template that is supplied with PROC UNIVARIATE, which is
delivered with Base SAS. The following code shows a SAS program that can be used to
run PROC UNIVARIATE:
ods graphics on;
proc univariate data=sashelp.heart;
  var weight;
  ppplot / normal square;
run; 
quit;
When the code is run, it creates the following plot. The plot uses the PPPLOT template,
which is stored in the BASE.UNIVARIATE.GRAPHICS folder of the Sashelp.Tmplmst
item store:
304
Chapter 12
•
Using an Equated Layout

In PROC UNIVARIATE, the PPPLOT statement creates a probability-probability plot
(also referred to as a P-P plot or percent plot), which compares the empirical cumulative
distribution function (ecdf) of a variable with a specified theoretical cumulative
distribution function such as the normal. If the two distributions match, the points on the
plot form a linear pattern that passes through the origin and has unit slope. Thus, you can
use a P-P plot to determine how well a theoretical distribution models a set of
measurements.
The supplied PPPLOT template uses several dynamics to pass in values for options, but
in essence, the following template is equivalent. The dynamics for the title and axis
labels have been converted into literals appropriate for this set of data.
proc template;
define statgraph pp_plot;
  begingraph;
    entrytitle "P-P Plot for Weight";
    entryfootnote halign=right "Derived from PPPLOT template";
    layout overlayequated /  equatetype=square
            xaxisopts=(label="Normal(Mu=153.09 Sigma=28.915)"
                       thresholdmin=1 thresholdmax=1)
            yaxisopts=(label="Cumulative Distribution of Weight"
                       thresholdmin=1 thresholdmax=1)
            commonaxisopts=(viewmin=0.0 viewmax=1.0) ;
 
      scatterplot x=Theoretical y=Empirical;
      lineparm x=0 y=0 slope=1 / lineattrs=GraphFit;
    endlayout;
  endgraph;
end;
run;
This simplified template produces a similar plot if it is rendered with the same data as
the UNIVARIATE plot. An ODS OUTPUT statement can convert the output object
from UNIVARIATE into a SAS data set:
ods graphics on;
Basic Display Features of Equated Plots
305

ods select ppplot;
ods output ppplot=ppdata;
proc univariate data=sashelp.heart;
  var weight;
  ppplot / normal square;
run; 
quit;
                
proc sgrender data=ppdata
              template=pp_plot;
run;
The following template modifies the equated axes, as shown in the next graph:
 layout overlayequated /  equatetype=square
    xaxisopts=(label="Normal(Mu=153.09 Sigma=28.915)"
               thresholdmin=1 thresholdmax=1
               tickvalueformat=3.2
               display=(label tickvalues)
               displaysecondary=(tickvalues)
               griddisplay=on)
    yaxisopts=(label="Cumulative Distribution of Weight"
               thresholdmin=1 thresholdmax=1
               tickvalueformat=3.2
               display=(label tickvalues)
               displaysecondary=(tickvalues)
               griddisplay=on)
    commonaxisopts=(viewmin=0.0 viewmax=1.0
               tickvaluesequence=(start=0 end=1 increment=.25) );
306
Chapter 12
•
Using an Equated Layout

Basic Display Features of Equated Plots
307

308
Chapter 12
•
Using an Equated Layout

Chapter 13
Using 3-D Graphics
The LAYOUT OVERLAY3D Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
Basic Display Features of 3-D Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
Managing the Display of Cube Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
Displaying a Fill in the Graph Walls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Defining a Viewpoint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
Defining Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
Data Requirements for 3-D Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
Overview of the Data Requirements for 3-D Plots . . . . . . . . . . . . . . . . . . . . . . . . . 314
Producing Bivariate Histograms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
Producing Surface Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
The LAYOUT OVERLAY3D Statement
GTL has one layout for 3-D graphics: the LAYOUT OVERLAY3D statement. Two 3-D
plot statements can be placed within this layout: BIHISTO3DPARM and
SURFACEPLOTPARM. No 2-D plot statements can be used in this layout, although
text statements such as ENTRY can be used.
Typical applications of OVERLAY3D layout are to create a 3-D representation of a
surface or a bi-variate histogram (possibly overlaid together). The 3-D layout has
features that 2-D layouts do not have. For example, it can do each of the following:
•
generate axes for three independent variables (X, Y,and Z)
•
set a viewpoint of the graph (TILT=, ROTATE=, and ZOOM= options)
•
display lines that represent the intersection of axis walls (CUBE= option).
The following figure shows the basic anatomy of a 3-D graph:
309

Basic Display Features of 3-D Graphs
Managing the Display of Cube Lines
You can control whether the additional nine lines representing the intersection of all axis
planes are displayed with the CUBE= option in the LAYOUT OVERLAY3D statement.
The default is CUBE=TRUE.
layout overlay3d / cube=false ;
  surfaceplotparm x=height y=weight
                  z=density;
endlayout;
310
Chapter 13
•
Using 3-D Graphics

Displaying a Fill in the Graph Walls
By default, only the outlines of the walls bounding the XY, XZ, and YZ axis planes are
shown. You can display filled walls by including the WALLDISPLAY=(FILL) or
WALLDISPLAY=(FILL OUTLINE) settings in the LAYOUT OVERLAY3D
statement. You can change the wall color (when filled) with the WALLCOLOR=option.
When filled, the wall lighting is adjusted to give a 3-D effect, based on the graph
viewpoint.
layout overlay3d / cube=false
    walldisplay=(fill) ;
  surfaceplotparm x=height y=weight
                  z=density;
endlayout;
Basic Display Features of 3-D Graphs
311

Defining a Viewpoint
Representing a 3-D graph statically in two dimensions often obscures details that are
better viewed from a different viewpoint. Three options on the LAYOUT OVERLAY3D
statement can be independently set to obtain a different viewpoint.
Option
Value
Range
Default
Description
ROTATE=
-360 to 360
54
Specifies the angle of rotation. Rotation is
measured in a clockwise direction about a virtual
axis, parallel to the Z axis (vertical) and passing
through the center of the bounding cube. A
counterclockwise rotation can be specified with a
negative value.
TILT=
-360 to 360
20
Specifies the angle of tilt in degrees. Tilt is
measured in a clockwise direction about a virtual
axis parallel to the X axis (vertical) and passing
through the center of the bounding cube. A
counterclockwise tilt can be specified with a
negative value.
ZOOM=
> 0
1
Specifies a zoom factor. Factors greater than 1
move closer to the bounding cube (zoom in), less
than 1 move farther away (zoom out).
These options can be used in combination with each other to obtain a desired
perspective. The following figures show some examples. To generate the figures, a
LATTICE layout was used to "grid" a series of OVERLAY3D layouts of the same plot
with different viewpoints. The arrows on the X and Y axes indicate increasing X and Y
values.
312
Chapter 13
•
Using 3-D Graphics

Defining Axes
Axes for the OVERLAY3D layout are similar to axes for the OVERLAY layout,
although the following exceptions apply to OVERLAY3D layouts:
•
An additional ZAXISOPTS=( ) option is available for managing the Z axis.
•
All three axis types can be either LINEAR, LOG, or TIME. A DISCRETE axis is not
supported on OVERLAY3D layouts.
•
For a LOG axis, the LOGOPTS= option is not supported on OVERLAY3D layouts.
•
No secondary (X2, Y2, Z2) axes are available on OVERLAY3D layouts.
•
Axis tick values are automatically thinned. No other fitting policy for OVERLAY3D
layout is available.
•
For any axis, the location of the displayed axis features (line, ticks, tick values, and
label) might shift, based on the specified viewpoint.
The following layout specification displays grid lines and a label for the Z axis:
layout overlay3d / cube=false
Basic Display Features of 3-D Graphs
313

    zaxisopts=(griddisplay=on
    label="Kernel Density") ;
  surfaceplotparm x=height y=weight
                  z=density;
endlayout;
Data Requirements for 3-D Plots
Overview of the Data Requirements for 3-D Plots
Both of the plot statements that can be used in the OVERLAY3D layout are
parameterized plots.(See “Plot Statement Terminology and Concepts” on page 23). This
means that the input data must conform to certain prerequisites in order for the plot to be
drawn.
Parameterized plots do not perform any internal data transformations or computing for
you. So, in most cases, you will need to perform some type of preliminary data
manipulation to set up the input data correctly before executing the template. The types
of data transformations that you need to perform are commonly known as "binning" and
"gridding."
Producing Bivariate Histograms
A bivariate histogram shows the distribution of data for two continuous numeric
variables. In the following graph, the X axis displays HEIGHT values and the Y axis
displays WEIGHT values. The Z axis represents the frequency count of observations.
The Z values could be some other measure (for example, percentage of observations),
but they can never be negative.
314
Chapter 13
•
Using 3-D Graphics

As with a standard histogram, the X and Y variables in the bivariate histogram have
been uniformly binned, which means that their data ranges have been divided into equal
sized intervals (bins), and that observations are distributed into one of these bin
combinations.
The BIHISTOGRAM3DPARM statement, which produced this plot, does not perform
any binning computation on the input columns. Thus, you must pre-bin the data. In the
following example, the binning is done with PROC KDE (part of the SAS/STAT
product).
proc kde data=sashelp.heart;
  bivar height(ngrid=8) weight(ngrid=10) /
        out=kde(keep=value1 value2 count) noprint plots=none;
run;
In this program, the NGRID= option sets the number of bins to create for each variable.
The default for NGRID is 60. The binned values for Height are stored in VALUE1, and
the binned values for Weight are stored in VALUE2. This selection of bins produces 1
observation for each of the 80 bin combinations. Frequency counts for each bin
combination are placed in a Count column in the output data set.
Data Requirements for 3-D Plots
315

Notice that when you form the grid by choosing the number of bins, the bin widths
(about 3.5 for HEIGHT and about 26 for WEIGHT) are most often non-integer.
The following template definition displays this data. By default, the BINAXIS=TRUE
setting requests that X and Y axes show tick values at bin boundaries. Also, by default,
XVALUES=MIDPOINTS and YVALUES=MIDPOINTS, which means that the X and
Y columns represent midpoint values rather than lower bin boundaries (LEFTPOINTS)
or upper bin boundaries (RIGHTPOINTS). Not all of the bins in this graph can be
labeled without collision because the graph is small. Thus, the ticks and tick values were
thinned. The non-integer bin values are converted to integers
( TICKVALUEFORMAT=5. ) to simplify the axis tick values. DISPLAY=ALL means
"show outlined, filled bins."
proc template;
  define statgraph bihistogram1a;
    begingraph;
      entrytitle "Distribution of Height and Weight";
      entryfootnote halign=right "SASHELP.HEART";
      layout overlay3d / cube=false zaxisopts=(griddisplay=on)
          xaxisopts=(linearopts=(tickvalueformat=5.))
          yaxisopts=(linearopts=(tickvalueformat=5.));
        bihistogram3dparm x=value1 y=value2 z=count /
          display=all;
      endlayout;
    endgraph;
  end;
run;
proc sgrender data= kde template=bihistogram1a;
  label value1="Height" value2="Weight";
run;
Eliminating Bins that Have No Data. Notice that the bins of 0 frequency (there are
several) are included in the plot. If you want to eliminate the bins where there is no data,
you can generate a subset of the data. The subset makes it a bit clearer where there are
bins with small frequency counts versus portions of the grid with no data.
proc sgrender data= kde template=bihistogram1a;
316
Chapter 13
•
Using 3-D Graphics

  where count > 0;
  label value1="Height" value2="Weight";
run;
Displaying Percentages on Z Axis. To display the percentage of observations on the Z
axis instead of the actual count, you need to perform an additional data transformation to
convert the counts to percentages.
proc kde data=sashelp.heart;
  bivar height(ngrid=8) weight(ngrid=10) /
        out=kde(keep=value1 value2 count) noprint plots=none;
run;
data kde;
  if _n_ = 1 then do i=1 to rows;
    set kde(keep=count) point=i nobs=rows;
    TotalObs+count;
  end;
  set kde;
  Count=100*(Count/TotalObs);
  label Count="Percent";
run;
proc sgrender data= kde template=bihistogram1a;
   label value1="Height" value2="Weight";
run;
Data Requirements for 3-D Plots
317

Setting Bin Width. Another technique for binning data is to set a bin width and
compute the number of observations in each bin. In the DATA step below, 5 is the bin
width for HEIGHT and 25 for WEIGHT. With this technique that you do not know the
exact number of bins, but you can assure that the bins are of a "good" size.
data heart;
  set sashelp.heart(keep=height weight);
  if height ne . and weight ne .;
  height=round(height,5);
  weight=round(weight,25);
run;
After rounding, HEIGHT and WEIGHT can be used as classifiers for a summarization.
Notice that the COMPLETETYPES option forces all possible combinations of the two
variables to be output, even if no data exists for a particular crossing.
proc summary data=heart nway completetypes;
  class height weight;
  var height;
  output out=stats(keep=height weight count) N=Count;
run;
The template can be simplified because we know that the bin midpoints are equally
spaced integers. For this selection of bin widths, 6 bins were produced for HEIGHT and
10 for WEIGHT.
proc template;
  define statgraph bihistogram2a;
    begingraph;
      entrytitle "Distribution of Height and Weight";
      entryfootnote halign=right "SASHELP.HEART";
      layout overlay3d / cube=false zaxisopts=(griddisplay=on);
        bihistogram3dparm x=height y=weight z=count /
          display=all;
      endlayout;
    endgraph;
  end;
run;
318
Chapter 13
•
Using 3-D Graphics

proc sgrender data=stats template=bihistogram2a;
run;
If you prefer to see the axes labeled with the bin endpoints rather the bin midpoints, you
can use the ENDLABELS=TRUE setting on the BIHISTOGRAM3DPARM statement.
Note that the ENDLABELS= option is independent of the XVALUES= and
YVALUES= options.
In the following example, the bin widths are changed to even numbers (10 and 50) to
make the bin endpoints even numbers:
proc template;
  define statgraph bihistogram2a;
    begingraph;
      entrytitle "Distribution of Height and Weight";
      entryfootnote halign=right "SASHELP.HEART";
      layout overlay3d / cube=false zaxisopts=(griddisplay=on);
        bihistogram3dparm x=height y=weight z=count /
          binaxis=true endlabels=true display=all;
      endlayout;
    endgraph;
  end;
run;
data heart;
  set sashelp.heart(keep=height weight);
  height=round(height,10);
  weight=round(weight,50);
run;
proc summary data=heart nway completetypes;
  class height weight;
  var height;
  output out=stats(keep=height weight count) N=Count;
run;
proc sgrender data=stats template=bihistogram2a;
run;
Data Requirements for 3-D Plots
319

If you choose bin widths that are too small, "gaps" might be displayed among axis ticks
values, which might cause the following message:
WARNING: The data for a HISTOGRAMPARM statement is not appropriate.
         HISTOGRAMPARM statement expects uniformly-binned data. The
         histogram might not be drawn correctly.
Because BIHISTOGRAM3DPARM is a parameterized plot, you can use it to show the
3-D data summarization of a response variable Z, which must have nonnegative values,
by two numeric classification variables that are equally spaced (X and Y). That is, even
though the graphical representation is a bivariate histogram, the Z axis does not have to
display a frequency count or a percent.
data cars;
  set sashelp.cars(keep=weight horsepower mpg_highway);
  if horsepower ne . and weight ne .;
  horsepower=round(horsepower,75);
  weight=round(weight,1000);
run;
 
proc summary data=cars nway completetypes;
  class weight horsepower;
  var mpg_highway;
  output out=stats mean=Mean ;
run;
proc template;
  define statgraph bihistogram2b;
    begingraph;
      entrytitle
       "Distribution of Gas Mileage by Vehicle Weight and Horsepower";
      entryfootnote halign=right "SASHELP.CARS";
      layout overlay3d / cube=false zaxisopts=(griddisplay=on) rotate=130;
        bihistogram3dparm y=weight x=horsepower z=mean / binaxis=true
          display=all;
      endlayout;
    endgraph;
  end;
320
Chapter 13
•
Using 3-D Graphics

run;
proc sgrender data=stats template=bihistogram2b;
run;
Producing Surface Plots
A surface plot shows points that are defined by three continuous numeric variables and
connected with a polygon mesh. A polygon mesh is a collection of vertices, edges, and
faces that defines the shape of a polyhedral object, which simulates the surface. In order
for a surface to be drawn, the input data must be "gridded". That is, the X and Y data
ranges are split into uniform intervals (the grid), and the corresponding Z values are
computed for each X,Y pair. Smaller data grid intervals produce a smoother surface
because more smaller polygons are used but are more resource intensive because of the
large number of polygons that are generated. Larger data grid intervals produce a
coarser, faceted surface because the polygon mesh has fewer faces and is less resource
intensive.
The faces of the polygons can be filled, and lighting is applied to the polygon mesh to
create the 3-D effect. It is possible to superimpose a grid on the surface. The grid display
is a sampling of the data grid boundaries that intersect the surface. The grid display can
be thought of as a simpler see-through line version of the surface and can be rendered
with or without displaying the filled surface.
The default appearance of a surface is a filled polygon mesh with superimposed grid
lines.
surfaceplotparm x=length y=width z=depth;
Data Requirements for 3-D Plots
321

The SURFACEPLOTPARM statement assumes that the response/Z values have been
provided for a uniform X-Y grid. Missing Z values will leave a "hole" in the surface.
The observations in the input data set should form an evenly spaced grid of horizontal (X
and Y) values and one vertical (Z) value for each of these combinations. The
observations should be in sorted order of Y and X to obtain an accurate graph. The sort
direction for Y should be ascending. The sort direction of X can be either ascending or
descending.
In the following example, 315 observations in Sashelp.Lake are gridded into a 15 by 21
grid. The length of the grid is from 0 to 7 by .5, and the width of the grid is from 0 to 10
by .5 There are no missing Depth values.
Input data with non-gridded columns should be preprocessed with PROC G3GRID. This
procedure creates an output data set, and it allows specification of the grid size and
various methods for computed interpolated Z column(s). For further details, see the
documentation for PROC G3GRID in the SAS/GRAPH: Reference.
322
Chapter 13
•
Using 3-D Graphics

Using PROC G3GRID, the following code performs a Spline interpolation and generates
a surface plot. By increasing the grid size and specifying a SPLINE interpolation, a
smoother surface is rendered.
proc g3grid data=sashelp.lake out=spline;
  grid width*length = depth / naxis1=75 naxis2=75 spline;
run;
proc sgrender data=spline template=surfaceplotparm;
run;
The SURFACETYPE= option offers three different types of surface rendering:
FILLGRID
a filled surface with grid outlines (the default)
FILL
a filled surface without grid outlines
WIREFRAME
an unfilled (see through) surface with grid outlines
Data Requirements for 3-D Plots
323

Adding a Color Gradient. The surface can be colored with a gradient that is based on a
response variable by setting a column on the SURFACECOLORGRADIENT= option.
The following example uses the Depth column:
proc template;
  define statgraph surfaceplotparm;
    begingraph;
      entrytitle "SURFACECOLORGRADIENT=DEPTH";
      layout overlay3d / cube=false;
      surfaceplotparm x=length y=width z=depth /
        surfacetype=fill
        surfacecolorgradient=depth
        colormodel=twocolorramp
        reversecolormodel=true ;
      endlayout;
    endgraph;
  end;
run;
/* create gridded data for surface */
proc g3grid data=sashelp.lake out=spline;
  grid width*length = depth / naxis1=75 naxis2=75 spline;
run;
 
proc sgrender data=spline template=surfaceplotparm;
run;
The COLORMODEL=TWOCOLORRAMP setting indicates a style element. Four
possible color ramps are supplied in every style. The
REVERSECOLORMODEL=TRUE setting exchanges (reverses) the start color and end
color that is defined by the color model. The colors were reversed so that the darker
color maps to the lower depths.
Using Color to Show an Additional Response Variable. The
SURFACECOLORGRADIENT= option does not have to use the Z= variable. In the
next example, another variable, TEMPERATURE is used. Notice that it is possible to
display a continuous legend when you use the SURFACECOLORGRADIENT= option.
324
Chapter 13
•
Using 3-D Graphics

Several legend options can be used. Using other color ramps and continuous legends are
discussed in more detail in Chapter 8, “Adding Legends to a Graph,” on page 175.
ods escapechar="^"; /* Define an escape character */
proc template;
  define statgraph surfaceplot;
   begingraph;
     entrytitle "SURFACECOLORGRADIENT=TEMPERATURE";
     layout overlay3d / cube=false;
       surfaceplotparm x=length y=width z=depth / name="surf"
           surfacetype=fill 
           surfacecolorgradient=temperature
           reversecolormodel=true
           colormodel=twocoloraltramp ;
       continuouslegend "surf" /
           title="Temperature (^{unicode '00B0'x}F)" ;
     endlayout;
   endgraph;
  end;
run;
 
data lake;
  set sashelp.lake;
  if depth = 0 then Temperature=46;
  else Temperature=46+depth;
run;
 
/* create gridded data for surface */
proc g3grid data=lake out=spline;
   grid width*length = depth temperature / naxis1=75 naxis2=75 spline;
run;
proc sgrender data=spline template=surfaceplot;
run;
Data Requirements for 3-D Plots
325

326
Chapter 13
•
Using 3-D Graphics

Chapter 14
Using Dynamics and Macro
Variables to Make Flexible
Templates
Introduction to Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Declaring Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Referencing Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328
Initializing Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
Special Dynamic Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
Introduction to Dynamics and Macro Variables
If all of the variable names and options that are referenced in GTL templates had to be
"hard coded" in the compiled template, it would require that you redefine and recompile
the template every time you created the same type of graph with different variables. SAS
programmers are familiar with using SAS macros and macro variables to build
application code in which variables and other parameters can be specified by a calling
program. The same techniques, as well as other techniques unique to ODS templates,
can be applied in GTL to create reusable templates.
Declaring Dynamics and Macro Variables
Within the scope of a template definition, GTL supports the DYNAMIC statement for
declaring dynamic variables, and the MVAR and NMVAR statements for declaring
macro variables. These statements must appear after the DEFINE statement and before
the BEGINGRAPH block. The following syntax shows the overall template structure:
PROC TEMPLATE;
DEFINE STATGRAPH template-name;
DYNAMIC variable-1 <"text-1"> <…variable-n<"text-n">>;
MVAR variable-1 <"text-1"> <…variable-n<"text-n">>;
NMVAR variable-1 <"text-1"> <…variable-n<"text-n">>;
BEGINGRAPH;
GTL statements;
ENDGRAPH;
END;
327

RUN;
The difference between the MVAR and NMVAR declaration of macro variables is that
NMVAR always converts the supplied value to a numeric token (like the SYMGETN
function of the DATA step). Macro variables that are defined by MVAR resolve to
strings (like the SYMGET function of the DATA step).
Each of the DYNAMIC, MVAR, and NMVAR statements can define multiple variables
and an optional text string that denotes its purpose or usage:
dynamic YVAR "required" YLABEL "optional";
mvar LOCATE "can be INSIDE or OUTSIDE" SYSDATE;
nmvar TRANS "transparency factor";
Note: To make the template code more readable, it is helpful to adopt a naming
convention for these variables to distinguish them from actual option values or
column names. Common conventions include capitalization or adding leading or
trailing underscores to their names. The examples in this document use capitalization
to indicate a dynamic or macro variable.
Referencing Dynamics and Macro Variables
After dynamics and macro variables are declared, you can make one or more template
references to them by simply using the name of the dynamic or macro variable in any
valid context. These contexts include the following:
•
as argument or option values:
seriesplot x=date y=YVAR / curvelabel=YLABEL
  curvelabellocation=LOCATE datatransparency=TRANS;
•
as parts of concatenated text strings:
entrytitle "Time Series for " YLABEL;
entryfootnote "Created on " SYSDATE;
Dynamics and run-time macro variable references cannot be used in place of statement
or option keywords, or in place of punctuation that is part of the syntax (parentheses,
semicolons, and so on).
Note: If you precede a macro variable reference with an ampersand (&), the reference
will be resolved when the template is compiled, not when it is executed.
For example, it is permissible to define TRANS as an MVAR for use in the following
context:
proc template;
 define statgraph timeseries;
  dynamic YVAR YLABEL;
  mvar LOCATE TRANS;
  begingraph;
    layout overlay;
      seriesplot x=date y=YVAR  / curvelabel=YLABEL
        curvelabellocation= LOCATE datatransparency= TRANS ;
    endlayout;
  endgraph;
 end;
run;
328
Chapter 14
•
Using Dynamics and Macro Variables to Make Flexible Templates

This context is valid because an automatic, internal conversion using the BEST. format
will be performed (with no warning messages).
Initializing Dynamics and Macro Variables
The main difference between dynamics and macro variables is that they are initialized
differently.
For dynamics, use the DYNAMIC statement with PROC SGRENDER. Values for
dynamics that resolve to column names or strings should be quoted. Numeric values
should not be quoted:
proc sgrender data=financial template=timeseries;
  dynamic yvar="inflation" ylabel="Inflation Rate";
run;
For macro variables, use the current symbol table (local or global) to look up the macro
variable values at run time:
%let locate=inside;
%let trans=.3;
proc sgrender data=financial template=timeseries;
  dynamic yvar="inflation" ylabel="Inflation Rate";
run;
No initialization is needed for automatic macro variables like the system date and time
value SYSDATE.
It is the responsibility of the person or process that initializes the dynamics or macro
variables to ensure that the expected value type and value that is supplied is appropriate
for the substitution context. If necessary, you can use conditional logic to evaluate the
supplied values of dynamics or macro variables. Conditional logic is discussed in
Chapter 15, “Using Conditional Logic and Expressions,” on page 337.
If a dynamic is used to supply a GTL option with a specific value and the supplied value
is not valid or it is not initialized, then the option specification is ignored and the option's
default value is used. For example, the HALIGN= option accepts the values RIGHT,
CENTER, and LEFT. If the dynamic variable ALIGN is defined and then the template
code specifies HALIGN=ALIGN, the ALIGN dynamic must be initialized with one of
the values RIGHT, CENTER, or LEFT. If it is initialized with another value, TOP for
example, the HALIGN= specification in the template is ignored, the default setting for
HALIGN= is used, and you might see a warning in the SAS log.
If a dynamic is used to supply a required argument such as a column name, and the name
is misspelled or not provided, then a warning is issued and that plot statement drops out
of the final graph. A graph will still be produced, but it might be a blank graph, or it
might show the results of all statements except those that are in error.
The following example shows how to create a generalized template that can be used to
show the distribution of any numeric variable. The dynamic named VAR must be set,
but the other dynamics are optional: BINS (sets the number of histogram bins) and
FOOTNOTE. In the example, the DYNAMIC and MVAR variables are highlighted to
emphasize where they are being used.
proc template;
 define statgraph distribution;
  dynamic VAR BINS FOOTNOTE ;
  mvar SYSDATE ;
Initializing Dynamics and Macro Variables
329

  begingraph;
    entrytitle "Distribution of " VAR " with Normal Density Curve";
    entryfootnote halign=left FOOTNOTE halign=right "Created " SYSDATE ;
    layout lattice / rowweights=(.9 .1) columndatarange=union
                     rowgutter=2px;
      columnaxes;
        columnaxis / display=(ticks tickvalues);
      endcolumnaxes;
      layout overlay / yaxisopts=(offsetmin=.04 griddisplay=auto_on);
        histogram VAR / scale=percent nbins=BINS ;
        densityplot VAR / normal( ) name="Normal";
        fringeplot VAR / datatransparency=.7;
      endlayout;
      boxplot y=VAR / orient=horizontal primary=true boxwidth=.9;
    endlayout;
  endgraph;
 end;
run;
The following execution of the template initializes the dynamic variables VAR and
FOOTNOTE, but it does not initialize BIN:
proc sgrender data=sashelp.heart template=distribution;
  dynamic var="Cholesterol"
  footnote="From Framingham Heart Study (SASHELP.HEART)";
run;
In this case, the template option bins=BINS drops out because the BINS dynamic has
not been initialized.
This next execution of the template assigns values to each of the dynamics VAR, BIN,
and FOOTNOTE, using different values from the previous example:
proc sgrender data=sashelp.cars template=distribution;
  dynamic var="Invoice" bins=20 footnote="From SASHELP.CARS";
run;
330
Chapter 14
•
Using Dynamics and Macro Variables to Make Flexible Templates

The next example shows a simplified version of the previous graph, this time adding an
inset. The inset statistics are computed external to the template and passed into the
template at run time, using dynamics and macro variables. For more information about
coding insets in graphs, see Chapter 17, “Adding Insets to a Graph,” on page 355.
proc template;
 define statgraph inset;
  dynamic VAR FOOTNOTE; 
  mvar N MEAN STD;
  begingraph;
   entrytitle "Distribution of " VAR;
   entryfootnote halign=left FOOTNOTE;
   layout overlay / yaxisopts=(griddisplay=on);
    histogram VAR / scale=percent;
    layout gridded / columns=2
        autoalign=(topleft topright) border=true
        opaque=true backgroundcolor=GraphWalls:color;
      entry halign=left "N"; entry  halign=left N ;
      entry halign=left "Mean"; entry halign=left MEAN ;
      entry halign=left "Std Dev"; entry halign=left STD ;
    endlayout;
   endlayout;
  endgraph;
 end;
run;
We will now define a macro that can pass values to this template. For a given numeric
variable, the macro computes the number of observations, the mean, and the standard
deviation, storing these statistics in macro variables N, MEAN, and STD. The macro
variables are available to the SGRENDER step when the macro executes. Here is the
definition for the macro, which we will name HIST:
%macro hist(dsn,numvar,footnote);
  /* these macro variables are declared in the template */
  %local N MEAN STD;
Initializing Dynamics and Macro Variables
331

  proc sql noprint;
    select  put(n(&numvar),12. -L),
            put(mean(&numvar),12.2 -L),
            put(std(&numvar),12.2 -L) into :N, :MEAN, :STD
    from &dsn;
  quit; 
 
  /* remove trailing blanks */
  %let N=&N; %let MEAN=&MEAN; %let STD=&STD;
  proc sgrender data=&dsn template=inset;
    dynamic VAR="&numvar" FOOTNOTE="&footnote"; 
  run;
 
%mend;
Here are results of two executions of the macro with different input data. Notice the
placement of the inset might change on based on the amount of space that is available
and the setting for the AUTOALIGN= option.
%hist(sashelp.heart, cholesterol, From SASHELP.HEART)
%hist(sashelp.cars, Weight, From SASHELP.CARS)
332
Chapter 14
•
Using Dynamics and Macro Variables to Make Flexible Templates

If you are familiar with the macro facility, you can create macros that validate the
parameters before executing the template. It is also possible to validate the parameters
within the compiled template, using the conditional logic syntax of GTL. For more
information, see Chapter 15, “Using Conditional Logic and Expressions,” on page 337.
GTL supports user-defined computed expressions within compiled templates. This
means that the inset statistics could have been computed directly within template,
eliminating the need to pass them in with dynamics or macro variables. An example of
how to do this is also discussed in Chapter 15, “Using Conditional Logic and
Expressions,” on page 337.
For developers who would like to create a library of reusable templates, see the
discussion on creating shared templates in “Creating Shared Templates” on page 473.
Special Dynamic Variables
Several special predefined dynamic variables are available that you can use with your
templates. These special variables are listed in Table 14.1 on page 333.
Table 14.1
Special Dynamic Variables
_LIBNAME_
This variable represents the name of the library that contains the data set.
_MEMNAME_
This variable represents the name of the library member that contains the
data set.
_
BYFOOTNOTE_*
This variable is set to 1 when you specify a BY statement and the ODS
GRAPHICS BYLINE= option is set to FOOTNOTE. Otherwise, it is set
to 0 or is NULL. For more information about the ODS GRAPHICS
BYLINE= option, see SAS Output Delivery System: User's Guide.
Special Dynamic Variables
333

_BYLINE_
This variable represents the complete BY line when you specify a BY
statement.
_BYTITLE_*
This variable is set to 1 when you specify a BY statement and the ODS
GRAPHICS BYLINE= option is set to TITLE. Otherwise, it is set to 0 or
is NULL.
_BYVAR_
This variable represents the name of the first BY variable when you
specify a BY statement.
_BYVARn_
This variable represents the name of the nth BY variable when you
specify a BY statement with multiple variables.
_BYVAL_
This variable represents the first BY value when you specify a BY
statement.
_BYVALn_
This variable represents the value of the nth BY variable when you
specify a BY statement with multiple variables.
* This variable is set automatically only for analytical procedures that support ODS GRAPHICS. For a list
of these procedures, see “Automatic Graphics from SAS Analytical Procedures” on page 2. For all other
procedures, this variable is not set automatically (NULL).
To use a special variable in your template, you must define it in the DYNAMIC
statement in your template. However, you do not have to define and initialize the special
variable in your SGRENDER procedure statement. The special variables are defined and
initialized automatically at run time for the SGRENDER procedure.
Here is an example that shows you how special variables can be used in a template. This
example generates a graph of the monthly stock closing price for each year for the years
2000 through 2005. It uses a BY statement in the SGRENDER statement to generate the
graphs by year and provides the following options for displaying the BY value in each
graph:
•
display the BY line in the graph title
•
display the BY line in a footnote
•
display the BY value in the graph title
The _BYLINE_ variable is used to include the BY line in the graph title or in a footnote.
The _BYTITLE_ and _BYFOOTNOTE_ variables are used with the BYLINE= ODS
GRAPHICS option to select between displaying the BY line in the title or footnote.
When neither _BYTITLE_ nor _BYFOOTNOTE_ is set, the _BYVAL_ variable is used
to include the BY value in the graph title as the default behavior. Finally, before the
graph is rendered, the default BY line that is normally displayed when the BY statement
is used is disabled.
Here is the code for this example.
/* Add a YEAR column to the data set. */
data stocks;
   set sashelp.stocks;
   year=year(date);
   label year="YEAR";
run;
/* Sort the data by YEAR. */
proc sort data=stocks;
334
Chapter 14
•
Using Dynamics and Macro Variables to Make Flexible Templates

   by year;
run;
/* Create the template for the graph. */
proc template;
   define statgraph seriesgroup;
      begingraph;
         /* Define the special variables that will be used. */
         dynamic _BYVAL_ _BYLINE_ _BYTITLE_ _BYFOOTNOTE_;
         /* If BYTITLE is set, put the BY line in the graph title. */
         if (_BYTITLE_)
            entrytitle "Monthly Closing Price";
            entrytitle "(" _BYLINE_ ")";
         else
            /* If BYFOOTNOTE is set, put the BY line in a footnote. */
            if (_BYFOOTNOTE_)
               entrytitle "Monthly Closing Price";
               entryfootnote halign=right "(" _BYLINE_ ")";
            else
               /* Otherwise, include _BYVAL_ in the title. */
               entrytitle "Monthly Closing Price In " _BYVAL_;
            endif;
         endif;
         layout overlay / xaxisopts=(label="Month" type=discrete
            griddisplay=on gridattrs=(pattern=dot))
            yaxisopts=(griddisplay=on gridattrs=(pattern=dot));            
            seriesplot x=eval(month(date)) y=close / 
               group=stock name="s";
            discretelegend "s";
         endlayout;
      endgraph;
   end;
run;
   
/* Disable the default BY line. */
options nobyline;
/* Put the BY line in the graph title */
ods graphics / byline=title;
/* Generate the graph. */
proc sgrender data=stocks template=seriesgroup;
   by year;
   where year between 2000 and 2005;
run;
Notice that _BYVAL_, _BYLINE_, _BYTITLE_, and _BYFOOTNOTE_ are included
in the DYNAMIC statement of the template definition but are not declared or initialized
in the SGRENDER statement. Conditional logic is used to test whether the _BYTITLE_
or _BYFOOTNOTE_ variable is set and to place the BY line accordingly. If neither
variable is set, the conditional logicincludes the _BYVAL_ value in the graph title. The
BYLINE=TITLE option in the ODS GRAPHICS statement specifies that the BY line be
displayed in the graph title.
The following figure shows the first graph. As shown in the figure, the first BY line,
YEAR=2000, is included in the graph title.
Special Dynamic Variables
335

To display the BY line in a footnote, specify BYLINE=FOOTNOTE in the ODS
GRAPHICS statement. To display the BY value in the title instead, use the
BYLINE=NOBYLINE option in the ODS GRAPHICS statement or remove the ODS
GRAPHICS statement.
336
Chapter 14
•
Using Dynamics and Macro Variables to Make Flexible Templates

Chapter 15
Using Conditional Logic and
Expressions
Constructs Available for Run-time Programming . . . . . . . . . . . . . . . . . . . . . . . . . 337
Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
Conditional Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
Constructs Available for Run-time Programming
GTL has several constructs that can take advantage of run-time programming:
•
Dynamics and macro variables
•
Expressions
•
Conditional processing
This chapter discusses expressions and conditional processing. Dynamics and macro
variables are discussed in Chapter 14, “Using Dynamics and Macro Variables to Make
Flexible Templates,” on page 327.
Expressions
In GTL, as in Base SAS, an expression is an arithmetic or logical expression that
consists of a sequence of operators, operands, and functions. An operand is a dynamic, a
macro variable, a column, a function, or a constant. An operator is a symbol that requests
a comparison, logical operation, arithmetic calculation, or character concatenation.
Expressions can be used to set an option value that is any one of the following:
•
a constant (character or numeric)
•
a column
•
part of the text for ENTRYTITLE, ENTRYFOOTNOTE, and ENTRY statements.
In GTL, an expression must be enclosed in an EVAL function.
The following examples show how to specify an expression. This first example uses the
MEAN function to compute several constants:
/* create reference lines at computed positions */
referenceline y=eval(mean(weight)+2*std(weight)) / curvelabel="+2 STD";
337

referenceline y=eval(mean(weight)) / curvelabel="Mean";
referenceline y=eval(mean(weight)-2*std(weight)) / curvelabel="-2 STD";
This next example creates a new column:
/* create a new column as a log transformation */
scatterplot x=date y=eval(log10(amount));
This final example builds a text string:
/* create a date and time stamp as a footnote */
entryfootnote  eval(put(today(),date9.)||" : "||put(time(),timeampm8.));
Valid GTL expressions are identical to valid WHERE expressions. See the WHERE
statement documentation in Base SAS for a comprehensive list of operators and
operands. Unlike WHERE expressions, however, GTL expressions do not perform
operations that create subsets. For example, the difference between the result of a
WHERE expression and that of a logical GTL expression on a column is that the GTL
expression returns a Boolean value for each observation, without changing the number
of observations.
For example, the expression for the Y= argument below does not reduce the number of
observations that are plotted.
scatterplot x=name y=eval(height between 40 and 60);
Instead, the computed numeric column for the Y= argument consists of 0s and 1s, based
on whether each observation's HEIGHT value is between 40 and 60.
Whenever expressions are used to create new columns, a new column name is internally
manufactured so that it does not collide with other columns in use.
Expressions in Statement Syntax. Throughout GTL documentation, you see expression
used in statement documentation:
BOXPLOT X= column | expression
Y= numeric-column | expression </ option(s)>;
For the X= argument in this BOXPLOT syntax, expression means any
EVAL(expression) that results in either a numeric or character column. An expression
that yields a constant is not valid.
For the Y= argument, expression means any EVAL(expression) that results in a numeric
column. The expression cannot result in a character column or any constant.
REFERENCELINE X= x-axis-value | column | expression </ option(s)>;
For a single line in this REFERENCELINE syntax, the X= argument can be a constant
(x-axis-value). For multiple lines, it can be a column. In either case, the supplied value(s)
must have the same data type as the axis. Thus, EVAL(expression) can result in a
constant, or it can result in a numeric or character column. In either case, the data type of
the result must agree with the axis type.
Type Conversion in GTL Expressions. Although expressions that are used in a DATA
step perform automatic type conversion, GTL expression evaluation does not. Thus, you
must use one or more functions to perform required type conversions in an expression.
Otherwise, the expression generates an error condition without warning when the
template is executed.
For example, consider the following GTL expression:
if(substr(value, 1, 2) = "11")
This expression uses the SUBSTR function to determine whether the first two characters
from VALUE evaluate to the string value "11". If VALUE is a string, the expression
338
Chapter 15
•
Using Conditional Logic and Expressions

works fine. However, if VALUE is numeric, then the expression generates an error
condition. For a numeric, you must convert the value to a string before passing it to the
SUBSTR function. The following modification uses the CATS function to perform the
type conversion when necessary:
if(substr(cats(value, 1, 2)) = "11")
Conditional Logic
GTL supports conditional logic that enables you to include or exclude one or more GTL
statements at run time:
IF ( condition )
GTL statement(s);
ELSE
GTL statement(s);
ENDIF ;
The IF statement requires an ENDIF statement, which delimits the IF block. The IF
block can be placed anywhere within the BEGINGRAPH / ENDGRAPH block.
The condition is an expression that evaluates to a numeric constant, where all numeric
constants other than 0 and MISSING are true. The IF block is evaluated with an implied
EVAL( condition ), so it is not necessary to include an EVAL as part of the condition.
Note: Dynamic variables that are initialized to an ODS-recognized value, such as YES,
NO, TRUE, or FALSE, do not work as expected when used as an expression in an
IF-THEN statement. In that case, the expression is treated as a string, which always
evaluates to a positive integer value (FALSE).
Here are some examples:
/* test a computed value */
if (weekday(today()) in (1 7))
   entrytitle "Run during the weekend";
else
   entrytitle "Run during the work week";
endif;
/* test for the value of a numeric dynamic */
if ( ADDREF > 0 )
   referenceline y=1;
   referenceline y=0;
   referenceline y=-1;
endif;
/* test for the value of a character dynamic */
if ( upcase(ADDREF) =: "Y")
   referenceline y=1;
   referenceline y=0;
   referenceline y=-1;
endif;
/* test whether a dynamic is initialized */
if (exists(ADDREF))
Conditional Logic
339

   referenceline y=1;
   referenceline y=0;
   referenceline y=-1;
endif;
The GTL conditional logic is used only for determining which statements to render. It is
not used to control what is in the data object. In the following example, the data object
contains columns Date, Amount, and LOG10(AMOUNT), but only one scatter plot is
created.
if ( LOGFLAG )
  scatterplot x=date y=amount;
else
  scatterplot x=date y=eval(log10(amount));
endif;
For the conditional logic in GTL, it is seldom necessary to test for the existence of
option values that are set by columns or dynamics. Consider the following statement:
scatterplot x=date y=amount / group=GROUPVAR;
This SCATTERPLOT statement is equivalent to the following code because option
values that are set by columns that do not exist, or by dynamics that are uninitialized,
simply "drop out" at run time and do not produce errors or warnings:
if ( exists(GROUPVAR) )
  scatterplot x=date y=amount / group=GROUPVAR; 
else
  scatterplot x=date y=amount;
endif;
The GTL code that is specified in the conditional block must contain complete
statements and / or complete blocks of statements. For example, the following IF block
produces a compile error because there are more LAYOUT statements than
ENDLAYOUT statements:
/* produces a compile error */
if ( exists(SQUAREPLOT) )
  layout overlayequated / equatetype=square;
else 
  layout overlay;
endif;
    scatterplot x=XVAR y=YVAR;
endlayout;
The following logic is the correct conditional construct:
if ( exists(SQUAREPLOT) )
  layout overlayequated / equatetype=square;
    scatterplot x=XVAR y=YVAR;
  endlayout;
else
  layout overlay;
    scatterplot x=XVAR y=YVAR;
  endlayout;
endif;
GTL does not provide ELSE IF syntax, but you can create a nested IF/ ELSE block as
follows:
340
Chapter 15
•
Using Conditional Logic and Expressions

IF ( condition )
GTL statement(s);
ELSE
IF ( condition )
GTL statement(s);
ELSE
GTL statement(s);
ENDIF ;
ENDIF ;
The following example creates a generalized histogram that conditionally shows the
variable label and combinations of fitted distribution curves:
proc template;
  define statgraph conditional;
    dynamic NUMVAR "required" SCALE CURVE;
    begingraph;
      entrytitle "Distribution of  " eval(colname(NUMVAR));
      if ( colname(NUMVAR) ne collabel(NUMVAR) )
        entrytitle "(" eval(collabel(NUMVAR)) ")";
      endif;
      layout overlay / xaxisopts=(display=(ticks tickvalues line));
        histogram NUMVAR / scale=SCALE;
        if ( upcase(CURVE) in ("ALL" "NORMAL" ) )
          densityplot NUMVAR / normal() name="N"
            lineattrs=GraphData1 legendlabel="Normal Distribution";
        endif;
        if ( upcase(CURVE) in ("ALL" "KDE" "KERNEL") )
          densityplot NUMVAR / kernel() name="K"
            lineattrs=GraphData2 legendlabel="Kernel Density Estimate";
        endif;
        discretelegend "N" "K";
      endlayout;
    endgraph;
  end;
run;
•
The DYNAMIC statement identifies the dynamic variables.
•
The first IF block specifies an ENTRYTITLE statement that is conditionally
executed if the column name differs from the column label.
•
The next two IF blocks evaluate the value of the dynamic variable CURVE. If
CURVE is not used, the code in the conditional blocks is not executed. If CURVE is
initialized to one of the strings "all" or "normal" in any letter case, then the first
DENSITYPLOT statement is executed. If CURVE is initialized to one of the strings
"all", "kde", or "kernel" in any letter case, then the second DENSITYPLOT
statement is executed. Thus, the results of the conditional logic determine whether
zero, one, or two density plots are generated in the graph.
•
Constructing the legend does not require conditional logic because any referenced
plot names that do not exist are not used.
Conditional Logic
341

After submitting the template code, we can execute the template with various
combinations of dynamic values.
In this first execution, the NUMVAR dynamic is initialized with a column that has a
defined label, so two title lines are generated. The first title line displays the column
name, and the second title line displays the column label. The CURVE dynamic is not
initialized, so the template does not generate a density plot.
proc sgrender data=sashelp.heart template=conditional;
  dynamic numvar="mrw";
run;
In this next execution of the template, the NUMVAR dynamic is initialized with a
column that does not have a label, so only a single title line is displayed in the graph.
The CURVE dynamic is initialized with the value "kde", so in addition to the histogram,
the template generates a kernel density estimate.
proc sgrender data=sashelp.heart template=conditional;
  dynamic numvar="cholesterol" curve="kde";
run;
342
Chapter 15
•
Using Conditional Logic and Expressions

In this final execution of the template, the CURVE dynamic is initialized with the value
"all", so in addition to the histogram, the template generates a normal density estimate
and a kernel density estimate.
proc sgrender data=sashelp.heart template=conditional;
  dynamic numvar="cholesterol" scale="count" curve="all";
run;
The value of the SCALE dynamic does not need to be verified. If it is not one of
COUNT, DENSITY, PERCENT, or PROPORTION (not case sensitive), the default
scale is used with no warning or error.
Conditional Logic
343

344
Chapter 15
•
Using Conditional Logic and Expressions

Chapter 16
Using Functions
Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
SAS Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
SAS Functions That Can Be Used in a GTL Template . . . . . . . . . . . . . . . . . . . . . 345
SAS Functions That Can Be Used to Create Flexible Templates . . . . . . . . . . . . . 346
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346
Functions Defined Only in GTL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
Commonly Used GTL Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
GTL Summary Statistic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Commonly Used Summary Statistic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353
Overview
GTL supports a large number of functions, including:
•
SAS functions that can be used in the context of a WHERE expression
•
functions that are defined only in GTL
•
summary statistic functions
SAS Functions
SAS Functions That Can Be Used in a GTL Template
Any SAS function that can be used in a WHERE expression can be used in a GTL
template. These SAS functions include:
•
character handling functions
•
date and time functions
•
mathematical and statistical functions
345

Note: Not all SAS functions are available in WHERE expressions. Call routines and
other DATA-step-only functions (for example, LAG, VNAME, OPEN) are some
examples of functions that cannot be used.
For more information about SAS functions, see Chapter 2, “Dictionary of SAS
Functions and CALL Routines,” in SAS Functions and CALL Routines: Reference.
SAS Functions That Can Be Used to Create Flexible Templates
The following table shows some of the SAS functions can be used to increase the
flexibility of your template code.
SAS Function Name
Description
IFC(logical-expression, "true-value", "false-
value" <,"missing-value">)
returns the character value true-value if
logical-expression resolves to TRUE, false-
value if it resolves to FALSE, or missing-
value if it resolves to a missing value. The
TRUE, FALSE, and MISSING values must be
enclosed in quotation marks.
IFN(logical-expression, true-value, false-
value <,missing-value>)
returns the numeric value true-value if
logical-expression resolves to TRUE, false-
value if it resolves to FALSE, or missing-
value if it resolves to a missing value.
TYPEOF(column)
returns the character ‘N’ if column is a
numeric column or ‘C’ if it is a character
column.
Examples
Using the IFC and IFN SAS Functions
The IFC and IFN functions return one of two character or numeric values based on
whether a conditional expression resolves to TRUE or FALSE. They can also return an
optional third value if the conditional expression resolves to a missing value. These
functions enable you to specify a value based on a conditional expression, effectively
creating a new data column. In some cases, these functions can be used in place of IF-
THEN-ELSE statements in your template code. As with other functions, you must
enclose the IFC and IFN functions in the EVAL function.
Here is an example that uses both the IFN and IFC functions for creating a sales-based
commission chart for employees in a sales group. Each employee in the group works in
one of two sales units: Products and Services. The data for this example includes the
employee ID, total sales, and sales unit code for each member of the sales group. Here is
the data.
data sales;
   input empID totalSales salesUnit $18;
   format totalSales dollar9.;
datalines;
112876 129489.44 P
112421 169842.97 S
115331 108763.51 S
346
Chapter 16
•
Using Functions

110765 181009.22 P
113722 147688.78 P
;
The TotalSales column contains the total sales for each employee. The SalesUnit column
contains a code that identifies the sales unit in which each employee works. The codes
are P for the Products unit and S for the Services unit.
Here is the output for this example.
The two bar charts show the total sales and earned commission for each employee. The
IFN function is used to compute commission for each employee based on his or her total
sales. Employees that achieved a sales total of $120,000 or more earn a commission of
5% of their total sales. All other employees earn a commission of 2.5% of their total
sales.
An axis table along the X axis shows the sales unit for each employee. The IFC function
is used to convert the P and S SalesUnit codes into more descriptive values in the axis
table. Because only two sales unit codes are used in this case, we can use the IFC
function for this purpose. This saves us from having to add a new column to the data in a
DATA step or having to create and apply a custom format to the SalesUnit column.
Here is the SAS code that defines the template and generates the graph.
proc template;
   define statgraph commission;
      begingraph;
         entrytitle "Sales-Based Commission";
         layout overlay /
            xaxisopts=(label="Employee ID")
            yaxisopts=(label="Total Sales") 
            y2axisopts=(label="Commission"
               linearopts=(viewmax=15000 tickvalueformat=dollar9.));
            /* Generate the sales bar chart. */
            barchart category=empID response=totalSales /
SAS Functions
347

               name="Sales" legendlabel="Total Sales" barwidth=0.3 
               discreteoffset=-0.2 fillattrs=graphData1;
            /* Generate the commission bar chart. */
            barchart category=empID 
               /* Use IFN to compute the commission. */
               response=eval(ifn(totalSales >= 120000,
                  totalSales * 0.05,        /* 5% if TRUE */
                  totalSales * 0.025)) /    /* 2.5% if FALSE */
               name="Commission"  legendlabel="Commission"
               barwidth=0.3 yaxis=y2 discreteoffset=0.2
                  fillattrs=graphData2;
            /* Add an axis table that shows the sales unit for each
               employee. */
            innermargin / align=bottom;
               axistable x=empID 
                  /* Use IFC to convert the codes to meaningful 
                     values. */
                  value=eval(ifc(salesUnit = 'P',"Products", 
                     "Services")); 
            endinnermargin;
            discretelegend "Sales" "Commission";
         endlayout;
      endgraph;
   end;
run;
proc sgrender data=sales template=commission;
run;
Using the TYPEOF SAS Function
The TYPEOF function returns the type of a specified column at run time. It returns the
character ‘C’ if the specified column is a character column or ‘N’ if it is a numeric
column. You can use the TYPEOF function to take specific actions in your template at
run time based on the input data type. Here is an example that creates a graph of two
columns and uses the TYPEOF function to select a graph type that is appropriate for the
column types. The result returned by the TYPEOF function determines the graph type as
follows:
•
if both columns are numeric, it creates a scatter plot
•
if the X column is character and the Y column is numeric, it creates a vertical bar
chart.
•
if the X column is numeric and the Y column is character, it swaps the category and
response columns in the BARCHART statement and orients the chart horizontally
348
Chapter 16
•
Using Functions

Here is the output for the third case, a numeric X column and a character Y column.
Here is the SAS code.
/* Define the graph template. */
proc template;
   define statgraph plot;
      dynamic cat resp; /* Category and response columns. */
      begingraph;
         entrytitle "Graph of " eval(collabel(resp)) " and "
            eval(collabel(cat));
         layout overlay;
            /* If cat and resp are numeric, generate a scatter plot. 
               Otherwise, generate a bar chart.  */
            if (typeof(cat) = "N" and typeof(resp) = "N")
               scatterplot x=cat y=resp;
            else
               /* If cat is a character column, generate a vertical bar
                  chart. Otherwise, generate a horizontal bar chart. */
               if (typeof(cat) = "C")
                  barchart category=cat response=resp / stat=mean;
               else
                  barchart category=resp response=cat /
                     stat=mean orient=horizontal;
               endif;
            endif;
         endlayout;
      endgraph;
   end;
run;
proc sgrender data=sashelp.cars template=plot;
   dynamic cat="MPG_CITY" resp="TYPE";
run;
Note: See “Functions Defined Only in GTL” on page 350 for information about the
COLLABEL function.
SAS Functions
349

Functions Defined Only in GTL
Commonly Used GTL Functions
The following table shows some functions that are used only in GTL. As with other
functions, these must be enclosed within an EVAL. In all these functions, column can be
either the name of a column in the input data set or a dynamic / macro variable that
resolves to such a column.
Function Name
Description
COLNAME(column)
returns the case-sensitive name of the column.
COLLABEL(column)
returns the case-sensitive label of the column.
If no label is defined for the column, the case-
sensitive name of the column is returned.
EXISTS(item)
returns 1 if specified item exists, 0 otherwise.
If item is a column, it tests for the presence of
the column in the input data set. If item is a
dynamic / macro variable, it tests whether
there has been a run-time initialization of the
variable.
EXPAND(numeric-column, freq-column)
creates a new column as (numeric-column *
frequency-column) .
ASORT(column, RETAIN=ALL)
sorts all columns of the data object by the
values of column in ascending order. SORT is
an alias for ASORT.
Warning: if the RETAIN=ALL argument is
not included, column alone is sorted, not the
other columns, causing rowwise information
to be lost.
Limitation: only one sort operation (whether
an ASORT() or DSORT() function) can be
used within a single template definition.
DSORT(column, RETAIN=ALL)
sorts all columns of the data object by the
values of column in descending order.
Warning: if the RETAIN=ALL argument is
not included, column alone is sorted, not the
other columns, causing rowwise information
to be lost.
Limitation: only one sort operation (whether
an ASORT() or DSORT() function) can be
used within a single template definition.
NUMERATE(column)
returns a column that contains the ordinal
position of each observation in the input data
set (similar to an OBS column).
350
Chapter 16
•
Using Functions

Examples
/* arrange bars in descending order of response values */ 
barchartparm category=region response=eval(dsort(amount,retain=all));  
/* label outliers with their position in the data set */
/* it does not matter which column is used for NUMERATE() */
boxplot x=age y=weight / datalabel=eval(numerate(age));
/* add information about the column being processed,
   which is passed by a dynamic */
entrytitle "Distribution for " eval(colname(DYNVAR));
GTL Summary Statistic Functions
Commonly Used Summary Statistic Functions
The following functions return a numeric constant, based on a summary operation on a
numeric column. The results are the same as if the corresponding statistics were
requested with PROC SUMMARY. These functions take a single argument that resolves
to the name of a numeric column. These functions take precedence over similar multi-
argument DATA step functions.
number = EVAL(function-name(numeric-column))
Function Name
Description
CSS
Corrected sum of squares
CV
Coefficient of variation
KURTOSIS
Kurtosis
LCLM
One-sided confidence limit below the mean
MAX
Largest (maximum) value
MEAN
Mean
MEDIAN
Median (50th percentile)
MIN
Smallest (minimum) value
N
Number of nonmissing values
NMISS
Number of missing values
GTL Summary Statistic Functions
351

number = EVAL(function-name(numeric-column))
Function Name
Description
P1
1st percentile
P5
5th percentile
P25
25th percentile
P50
50th percentile
P75
75th percentile
P90
90th percentile
P95
95th percentile
P99
99th percentile
PROBT
p-value for Student’s t statistic
Q1
First quartile
Q3
Third quartile
QRANGE
Interquartile range
RANGE
Range
SKEWNESS
Skewness
STDDEV
Standard deviation
STDERR
Standard error of the mean
SUM
Sum
SUMWGT
Sum of weights
T
Student’s t statistic
UCLM
One-sided confidence limit above the mean
USS
Uncorrected sum of squares
VAR
Variance
352
Chapter 16
•
Using Functions

Example
The following example uses GTL summary statistic functions to dynamically construct
reference lines and a table of statistics for a numeric variable, which is supplied at run
time.
Here is the graph for this example.
Here is the SAS code.
proc template;
   define statgraph expression;
      dynamic NUMVAR "required";
      begingraph; 
         entrytitle "Distribution of  " eval(colname(NUMVAR));
         layout overlay / xaxisopts=(display=(ticks tickvalues line));
            histogram NUMVAR;
            /* create reference lines at computed positions */
            referenceline x=eval(mean(NUMVAR)+2*std(NUMVAR)) /
               lineattrs=(pattern=dash) curvelabel="+2 STD";
            referenceline x=eval(mean(NUMVAR)) /
               lineattrs=(thickness=2px) curvelabel="Mean";
            referenceline x=eval(mean(NUMVAR)-2*std(NUMVAR)) /
               lineattrs=(pattern=dash) curvelabel="-2 STD";
            /* create inset */
            layout gridded / columns=2 order=rowmajor
               autoalign=(topleft topright) border=true;
               entry halign=left "N";
               entry halign=left eval(strip(put(n(NUMVAR),12.0)));
               entry halign=left "Mean";
               entry halign=left eval(strip(put(mean(NUMVAR),12.2)));
GTL Summary Statistic Functions
353

               entry halign=left "Std Dev";
               entry halign=left eval(strip(put(stddev(NUMVAR),12.2)));
            endlayout;
         endlayout;
      endgraph;
   end;
run;
proc sgrender data=sashelp.heart template=expression;
  dynamic numvar="MRW";
run;
354
Chapter 16
•
Using Functions

Chapter 17
Adding Insets to a Graph
Uses for Insets in a Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
Creating a Simple Inset with an ENTRY Statement . . . . . . . . . . . . . . . . . . . . . . . . 356
Creating an Inset as a Table of Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
Positioning an Inset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360
Creating an Inset with Values That Are Computed in the Template . . . . . . . . . . 363
Creating an Inset from Values That Are Passed to the Template . . . . . . . . . . . . . 364
Overview of Importing Data into a Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364
Creating a Template That Uses Macro Variables . . . . . . . . . . . . . . . . . . . . . . . . . . 365
Defining a Macro to Initialize the Variables and Generate the Graph . . . . . . . . . . 367
Executing the Macro . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368
Adding Insets to a SCATTERPLOTMATRIX Graph . . . . . . . . . . . . . . . . . . . . . . 369
Adding Insets to Classification Panels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372
About Cell Insets in Classification Panels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372
Adding Insets By Using the Match-Merging Data Scheme . . . . . . . . . . . . . . . . . . 373
Adding Insets By Using the One-To-One-Merging Data Scheme . . . . . . . . . . . . . 376
Creating Axis-Aligned Insets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380
Creating an Axis-Aligned Inset with a Block Plot . . . . . . . . . . . . . . . . . . . . . . . . . 380
Creating an Axis-Aligned Inset with an Axis Table . . . . . . . . . . . . . . . . . . . . . . . . 387
Creating an Axis-Aligned Inset with the GTL Annotation Facility . . . . . . . . . . . . 390
Uses for Insets in a Graph
Insets are commonly strings or tables of text that are displayed in the plot area to
communicate relevant statistics, parameters, or other information relating to a graph. The
information presented in an inset might come from
•
text that appears in the template definition
•
values that are computed with expressions within the template
•
values that are passed externally to the inset by dynamics or macro variables
•
columns that are assigned to an INSET= option on statements that support the
option.
Inset information is often specified in ENTRY statements. However, the
SCATTERPLOTMATRIX statement and the classification panel layouts
355

(DATALATTICE and DATAPANEL layouts) provide options (for example, INSET=)
that enable you to construct and locate insets in multi-cell layouts, without using
ENTRY statements.
This chapter shows several techniques for adding insets to a graph. It assumes that you
are familiar with the concepts and techniques presented in Chapter 7, “Adding and
Changing Text in a Graph,” on page 157 and Chapter 9, “Using a Simple Multi-cell
Layout,” on page 211.
Creating a Simple Inset with an ENTRY Statement
You can use an ENTRY statement to create a simple inset within most layout blocks.
If you create the insets within a 2-D overlay-type layout, you can use each ENTRY
statement's AUTOALIGN= option or HALIGN= and VALIGN= options to position the
text within the plot area. The HALIGN= and VALIGN= options position the text in an
absolute position (such as HALIGN=LEFT and VALIGN=TOP). The AUTOALIGN=
option is used for dynamic positioning that is based on placement of the graphical
components in the plot area.
For example, to add an inset to an overlay of a scatter plot and an ellipse, you would like
for the text to appear where it does not collide with markers or the ellipse, if at all
possible. The AUTOALIGN=AUTO setting places the text in an area with the least
congestion.
begingraph;
  entrytitle "Simple One Line Inset";
  layout overlay;
    ellipse x=height y=weight / alpha=.1 type=predicted display=all;
    scatterplot x=height y=weight;
    entry "Prediction Ellipse (" {unicode alpha} "=.1)" /
      autoalign=auto ;
  endlayout;
endgraph;
356
Chapter 17
•
Adding Insets to a Graph

Note: The AUTO setting for the AUTOALIGN= option evaluates only the data points
of scatter plots to determine the ENTRY position. When other plot types are present,
their data representations are not evaluated and the ENTRY text might overlap a
graphics element in the plot area.
Creating an Inset as a Table of Text
Perhaps the most common use for an inset is to display a table of statistics within the
graph. This section shows how to construct that type of basic table. Later examples show
how to make the contents of the table more dynamic and how to integrate the table into
the graph.
The basic technique for constructing the table is to place several ENTRY statements in a
LAYOUT GRIDDED block. Each ENTRY statement becomes a cell of the grid.
ENTRY statement options and layout options are used to further organize the table.
Suppose you want to create the following table of text:
The simplest technique for creating the table is to construct a one-column, three-row
table. The following example uses three ENTRY statements: one for each row in the
table. The statistic name is left-justified in each row, and the statistic value is right-
justified:
layout gridded / columns=1  border=true;
  entry halign=left "N"       halign=right "5203" ;
Creating an Inset as a Table of Text
357

  entry halign=left "Mean"    halign=right "119.96" ;
  entry halign=left "Std Dev" halign=right "19.98" ;
endlayout;
Another technique is to create the table with two columns and three rows. This approach
places each statistic name and statistic value in its own cell. Although this technique
requires six ENTRY statements, it is a more flexible arrangement because each column
alignment can be set independently. The following example left-justifies the text for
each ENTRY statement:
layout gridded / columns=2  order=rowmajor border=true;
  /* row 1 */
    entry halign=left "N";
    entry halign=left "5203";
  /* row 2 */
    entry halign=left "Mean";
    entry halign=left "119.96";
  /* row 3 */
    entry halign=left "Std Dev";
    entry halign=left "19.98";
endlayout;
ORDER=ROWMAJOR means that cells are populated horizontally, starting from
column 1, followed by column 2, and then advancing to the next row. You should order
the ENTRY statements as shown. To add additional rows in the table, just add additional
pairs of ENTRY statements.
Of course, the LAYOUT GRIDDED statement enables you to organize cells by column,
so you can achieve this same effect with ORDER=COLUMNMAJOR. The following
code fragment populates the cells vertically down the columns by populating the first
cell in row 1, followed by the first cell in row 2, followed by the first cell in row 3, and
then advancing to the next column.
layout gridded / rows=3 order=columnmajor border=true;
  /* column 1 */
    entry halign=left "N";
    entry halign=left "Mean";
    entry halign=left "Std Dev";
  /* column 2 */
    entry halign=left "5203";
    entry halign=left "119.96";
    entry halign=left "19.98";
endlayout;
In both cases, an HALIGN=LEFT prefix option was added to each ENTRY statement to
left-justify its text (the default is HALIGN=CENTER). Note that the column widths in
the table are determined by the longest text string in each column on a per column basis.
The following example illustrates how to change the column justification and add extra
space between the columns with the COLUMNGUTTER= option. Borders have been
added to the ENTRY statements to show the text boundaries and alignment. Although it
358
Chapter 17
•
Adding Insets to a Graph

is not used in this example, the LAYOUT GRIDDED statement also provides a
ROWGUTTER= option to add space between all rows.
layout gridded / rows=3 order=columnmajor
                 columngutter=5px border=true;
  /* column 1 */
    entry halign=left "N"       / border=true;
    entry halign=left "Mean"    / border=true;
    entry halign=left "Std Dev" / border=true;
  /* column 2 */
    entry halign=right "5203"   / border=true;
    entry halign=right "119.96" / border=true;
    entry halign=right "19.98"  / border=true;
endlayout;
With the borders turned on in the layout, you should notice that there is spacing that
appears on the left and right of the ENTRY text. The space is called padding, and it can
be explicitly set with the PAD= option in the ENTRY statement. The default padding (in
pixels) for ENTRY statements is:
PAD=(TOP=0  BOTTOM=0  LEFT=3  RIGHT=3)
You can adjust that padding as desired.
To embellish the basic inset table with a spanning title, nest one GRIDDED layout
within another GRIDDED layout. In the following example, notice that the outer
GRIDDED layout has one column and two rows (the nested GRIDDED layout is treated
as one cell).
layout gridded / columns=1;
  entry textattrs=(weight=bold) "Stat Table";
  layout gridded / rows=3 order=columnmajor border=true;
  /* column 1 */
    entry halign=left "N";
    entry halign=left "Mean";
    entry halign=left "Std Dev";
  /* column 2 */
    entry halign=left "5203";
    entry halign=left "119.96";
    entry halign=left "19.98";
  endlayout;
endlayout;
Creating an Inset as a Table of Text
359

Positioning an Inset
If a table of text is used as an inset within a 2-D overlay-type layout, you can position
the table within the parent layout with options on the LAYOUT GRIDDED statement.
You can use the AUTOALIGN= option to automatically position the inset to avoid
collision with scatter points, lines, bars, and other plot components.
Alternatively, you can use the HALIGN= and VALIGN= options to position the table
absolutely. The combined values provide nine possible fixed positions. The disadvantage
of using the HALIGN= and VALIGN= options is that they do not attempt to avoid
collision with other plot components.
The following example uses the AUTOALIGN= option to restrict the table position to
one of the upper corners of the plot wall.
proc template;
define statgraph  ginset3a;
 begingraph;
  entrytitle "Auto-positioning the Inset Within the Plot Wall";
  layout overlay;
   histogram mrw;
   layout gridded / columns=1 border=true autoalign=(topleft topright) ;
     entry  halign=left "N"       halign=right "5203";
     entry  halign=left "Mean"    halign=right "119.96";
     entry  halign=left "Std Dev" halign=right "19.98";
   endlayout;
  endlayout;
 endgraph;
end;
run;
proc sgrender data=sashelp.heart template=ginset3a;
run;
360
Chapter 17
•
Adding Insets to a Graph

In this particular case there was not enough space to display the inset in the top left
position, so the next position was used because it has no collision. With a different set of
data, the inset might appear in the top left position. If both positions resulted in a
collision, the position with the least collision would be used. You can specify an ordered
list of up to nine positions for the AUTOALIGN list: TOPLEFT, TOP, TOPRIGHT,
LEFT, CENTER, RIGHT, BOTTOMLEFT, BOTTOM, and BOTTOMRIGHT. For a
scatter plot where "open" space is not predictable, you can specify
AUTOALIGN=AUTO, which selects a position that minimizes collision with the scatter
markers.
Note: The AUTO setting for the AUTOALIGN= option works best when the layout
contains only scatter plots. When other plot types are present, the ENTRY text might
overlap a graphics element in the plot area.
Outside Insets. An inset does not have to be placed inside the plot wall. This next
example positions an inset in the sidebar of a LATTICE layout.
proc template;
 define statgraph  ginset3b;
  begingraph / pad=2px;
    entrytitle "Positioning the Inset Outside the Plot Wall";
    layout lattice;
      layout overlay;
        histogram mrw;
      endlayout;
      sidebar / align=right;
        layout overlay / pad=(left=2px);
          layout gridded / columns=1  border=true;
            entry  halign=left "N"       halign=right "5203";
            entry  halign=left "Mean"    halign=right "119.96";
            entry  halign=left "Std Dev" halign=right "19.98";
          endlayout;
            endlayout;
      endsidebar;
    endlayout;
  endgraph;
 end;
run;
ods html style=default;
proc sgrender data=sashelp.heart template=ginset3b;
run;
Positioning an Inset
361

By default, the background of ENTRY statements and a GRIDDED layout are
transparent. So if the current style defines a background color and the inset does not
appear in the plot wall, the style's background color is seen through the inset. You can
make the background of the insert opaque and set its background color to match the plot
wall color, as shown in the following code fragment:
sidebar / align=right;
  layout overlay / pad=(left=2px);
    layout gridded / columns=1  border=true
           opaque=true  backgroundcolor=graphWalls:color ;
      entry  halign=left "N"       halign=right "5203";
      entry  halign=left "Mean"    halign=right "119.96";
      entry  halign=left "Std Dev" halign=right "19.98";
    endlayout;
  endlayout;
endsidebar;
362
Chapter 17
•
Adding Insets to a Graph

Creating an Inset with Values That Are Computed
in the Template
The examples presented so far have "hard coded" the statistic values in the compiled
template. Hardcoding the statistic values requires you to change and recompile the
template code whenever the column values change or you want to use different columns
for the analysis. A more flexible way to present a statistics table is to compute its content
as follows:
•
use GTL functions to calculate any required statistics
•
use dynamic variables as placeholders for column names in the template
•
at run time, initialize the dynamic variables so that they resolve to the names of
columns in the data object that is used to provide data values for the graph.
GTL supplies several functions that you can use to calculate the statistics, including
functions that match the statistic keywords used by PROC SUMMARY. GTL functions
are always specified within an EVAL function. To declare dynamic variables, you use
the DYNAMIC statement.
The following example uses the DYNAMIC statement to declare a dynamic variable
named VAR, which is used in the functions N, MEAN, and STDDEV to calculate the
statistics that are displayed in the statistics table:
proc template;
 define statgraph  ginset4a;
  dynamic VAR;
  begingraph;
    entrytitle "Two Column Inset with Computed Values";
    layout overlay;
      histogram VAR ;
      layout gridded / rows=3 order=columnmajor border=true
                       autoalign=(topleft topright);
       /* column 1 */
        entry halign=left "N";
        entry halign=left "Mean";
        entry halign=left "Std Dev";
       /* column 2 */
        entry halign=left eval(strip(put(n(VAR),12.0))) ;
        entry halign=left eval(strip(put(mean(VAR),12.2))) ;
        entry halign=left eval(strip(put(stddev(VAR),12.2))) ;
      endlayout;
    endlayout;
  endgraph;
 end;
run;
proc sgrender data=sashelp.heart template=ginset4a;
  dynamic VAR="mrw";
run;
•
Dynamic VAR is first referenced in the HISTOGRAM statement, where it is used to
represent the variable that provides numeric values for the histogram.
Creating an Inset with Values That Are Computed in the Template
363

•
Dynamic VAR is again referenced on each of the ENTRY statements that specify the
statistic values to use in the statistics table. Each of the ENTRY statements uses an
EVAL function to specify functions to calculate the statistic.
•
On each of the ENTRY statements, the STRIP function strips leading and trailing
blanks from the returned values. The PUT function on the first ENTRY statement
returns the statistics value with format 12.0, and the next two PUT statements return
values with format 12.2. The N, MEAN, and STDDEV functions return the number
of observations, mean, and standard deviation of variable VAR.
•
In the SGRENDER procedure, the DYNAMIC statement initializes dynamic VAR
so that it resolves at run time to column MRW from the Sashelp.Heart data set.
Because the dynamic resolves to a column name, the value that is assigned to it is
enclosed in quotation marks. (Values for dynamics that resolve to column names or
strings should be quoted. Numeric values should not be quoted.)
See Chapter 15, “Using Conditional Logic and Expressions,” on page 337 for more
information about the functions that can be used in the EVAL function. See Chapter 14,
“Using Dynamics and Macro Variables to Make Flexible Templates,” on page 327 for
more information about using dynamics and macro variables in GTL templates.
Creating an Inset from Values That Are Passed to
the Template
Overview of Importing Data into a Template
When the statistic that you want to display in an inset cannot be computed within the
template, you can create an output data set from a procedure and then use dynamics or
macro variables to "import" the computed values at run time.
The following discussion explains how to create and call a macro that can pass a data set
name and variable name to a previously compiled GTL template. To follow this
364
Chapter 17
•
Adding Insets to a Graph

discussion, you should understand the topics that are discussed in Chapter 14, “Using
Dynamics and Macro Variables to Make Flexible Templates,” on page 327.
For this example, we create a macro named HISTOGRAM that takes two arguments.
•
The first argument, DSN, passes a data set name.
•
The second argument, VAR, passes a variable name.
When invoked, the macro generates a histogram and model fit plot for the analysis
variable VAR. The graph also displays two insets that show the related statistics.
The following call to the HISTOGRAM macro uses the data set Sashelp.Heart to
generate a histogram for variable MRW (Metropolitan Relative Weight for subjects in a
heart study):
%histogram(sashelp.heart, mrw)
Figure 17.1
Passing Parameter Values to a Template
For more information about creating and calling macros, see the SAS Macro Language:
Reference.
Creating a Template That Uses Macro Variables
This section creates a GTL template that can generate the histogram and model fit plot
that is shown in Figure 17.1 on page 365.The template definition uses the MVAR
statement to define macro variables that provide run-time values and labels for the graph
insets. The MVAR statement also defines a macro variable named VAR, which is used
as the column argument for the histogram and overlaid normal density plot.
For this example, the inset statistics are calculated in the macro body, and the value for
macro variable VAR is passed as a parameter on the macro call.
Here is the GTL code for a template that we name GINSET:
proc template;
define statgraph  ginset;
  MVAR VAR NOBS MEAN STD TEST TESTLABEL STAT PTYPE PVALUE ;
  begingraph;
Creating an Inset from Values That Are Passed to the Template
365

    entrytitle "Histogram of " eval(colname(VAR));
    entrytitle "with Fitted Normal Distribution";
    layout overlay;
      histogram VAR ;
      densityplot VAR / normal();
 
      /* inset for normality test */
      layout gridded / columns=1  opaque=true
             autoalign=(topright topleft);
        entry TEST / textattrs=(weight=bold);
        entry "Test for Normality " TESTLABEL /
             textattrs=(weight=bold);
        layout gridded / columns=2   border=true;
          entry "Value"; entry PTYPE ;
          entry STAT;    entry  PVALUE ;
        endlayout;
      endlayout;
      /* inset for descriptive statistics */
      layout gridded / columns=2 border=true
             opaque=true autoalign=(right left);
        entry halign=left "Nobs";    entry halign=left NOBS ;
        entry halign=left "Mean";    entry halign=left MEAN ;
        entry halign=left "Std Dev"; entry halign=left STD ;
      endlayout;
    endlayout;
  endgraph;
end;
run;
•
The MVAR statement declares the macro variables that will be referenced in the
template.
•
The ENTRYTITLE statement specifies macro variable VAR as the argument on the
COLNAME function, which returns the case-sensitive name of the column. Thus,
the variable name that you pass on the macro call will be displayed in the graph title.
•
The HISTOGRAM and DENSITYPLOT statements specify macro variable VAR as
their column arguments. Again, the variable name that you pass on the macro call
will determine that column name.
•
The first LAYOUT GRIDDED block constructs a table to use as an inset. The inset
identifies the normality test that is used in the analysis, and it displays the related
probability statistic.
The first two ENTRY statements in the layout block specify a title for the inset.
Macro variable TEST, which will be initialized by the code in the macro body,
identifies the normality test that is applied to the data. As we will see later when we
create the macro, either of two normality tests will be used, depending on the number
of observations that are read from the data. Macro variable TESTLABEL provides
either of two test labels, depending on which test is used at run time.
The nested LAYOUT GRIDDED statement defines a two-column table for the
statistics table that is displayed in the first inset. Macro variable STAT in the first
column provides the normality value, and macro variables PTYPE and PVALUE
provide the probability statistics. These macro variables will be initialized by the
code in the macro body.
366
Chapter 17
•
Adding Insets to a Graph

•
The last LAYOUT GRIDDED statement constructs a two-column inset that shows
descriptive statistics for the analysis variable. Macro variables NOBS, MEAN, and
STD will be calculated by the code in the macro body and will resolve to the number
of observations in the data, the mean value, and the standard deviation.
Defining a Macro to Initialize the Variables and Generate the Graph
In “Creating a Template That Uses Macro Variables” on page 365 we created template
GINSET, which declared the following macro variables:
TEST
Identifies the normality test that is applied to the data.
TESTLABEL
Provides the label that is associated with the applied normality
test.
STAT
Provides the normality statistic that is calculated by the applied
normality test.
PTYPE and PVALUE
Provide the probability (type and value) for the applied
normality test.
NOBS, MEAN, and STD
Provide the number of observations, mean, and standard
deviation for the analysis variable.
To initialize these macro variables, we will now create a macro that calculates values for
them and also specifies an SGRENDER procedure that uses template GINSET. The
macro needs two parameters: one for passing a SAS data set name, and a second for
passing the name of a column in that data set.
The following macro code uses PROC UNIVARIATE to create two output data sets. A
DATA step then reads the output data sets, creates the required macro variables, and
assigns values to those macro variables in a local symbol table. When the macro runs the
SGRENDER procedure, the values of the macro variables are imported into the GINSET
template to produce a graph with insets, similar to the graph in shown in Figure 17.1 on
page 365. As mentioned earlier, the normality test that is performed on the analysis
variable will be based on the number of observations in that analysis variable.
Note: To make the following macro more robust, it could be designed to validate the
parameters.
%macro histogram(dsn,var);
/* compute tests for normality */
ods output TestsForNormality=norm;
proc univariate data=&dsn normaltest;
 var &var;
 output out=stats n=n mean=mean std=std;
run;
%local nobs mean std test testlabel stat ptype pvalue;
 
data _null_;
  set stats(keep=n mean std);
  call symputx("nobs",n);
  call symput("mean",strip(put(mean,12.3)));
Creating an Inset from Values That Are Passed to the Template
367

  call symput("std",strip(put(std,12.4)));
  if n > 2000 then /* use Shapiro-Wilk */
    set norm(where=(TestLab="D"));
  else /* use Kolmogorov-Smirnov */
    set norm(where=(TestLab="W"));
  call symput("testlabel","("||trim(testlab)||")");
  call symput("test",strip(test));
  call symput("ptype",strip(ptype));
  call symput("stat",strip(put(stat,best8.)));
  call symput("pvalue",psign||put(pvalue,pvalue6.4));
run;
 
proc sgrender data=&dsn template=ginset;
run;
%mend;
•
The %MACRO statement declares a macro named HISTOGRAM that takes two
parameters: DSN (for the data set name) and VAR (for the column name).
•
The ODS OUTPUT statement produces a SAS data set named NORM from the
TestsForNormality output object that will be generated by the UNIVARIATE
procedure (next statement). For more information about the ODS OUTPUT
statement, see the SAS Output Delivery System: User's Guide.
•
Deriving the input data set name from the DSN parameter and the analysis variable
name from the VAR parameter, the UNIVARIATE procedure calculates the number
of observations, mean, and standard deviation for the analysis variable. It writes the
values for these statistics to an output data set named STATS, storing the values in
variables named N, MEAN, and STD.
•
The %LOCAL statement creates a set of local macro variables to add to the local
symbol table.
•
The DATA step reads variables N, MEAN, and STD from the STATS data set.
•
The first three CALL SYMPUT routines use the data input variables to assign labels
and values to the local macro variables N, MEAN, and STD. On each CALL
SYMPUT, the first argument identifies the macro variable to receive the value, and
the second argument identifies the data input variable that contains the value to
assign to the macro variable in the symbol.
•
The IF/ELSE structure determines which normality test values to read from the
NORM data set that was created by the ODS OUTPUT statement. If there are fewer
than 2000 observations, the Shapiro-Wilk test values are used. Otherwise, the
Kolmogorov-Smirnov values are used.
•
The remaining CALL SYMPUT routines assign values to the rest of the macro
variables, using the values from variables in the NORM data set.
Executing the Macro
To execute the HISTOGRAM macro, we must pass it a data set name and the name of a
numeric column in the data.
The following macro call passes the data set name Sashelp.Heart and the column name
MRW. Because column MRW has more than 2000 observations, the Kolmogorov-
Smirnov test is used in the analysis.
%histogram(sashelp.heart, mrw)
368
Chapter 17
•
Adding Insets to a Graph

This next macro call passes the data set name Sashelp.Cars and the column name
Invoice. Because column Invoice has 2000 or fewer observations, the Shapiro-Wilk test
is used in the analysis.
%histogram(sashelp.cars,invoice)
Adding Insets to a SCATTERPLOTMATRIX Graph
The SCATTERPLOTMATRIX statement provides the following options for displaying
insets in the cells of the graph matrix. (See the documentation for the
SCATTERPLOTMATRIX statement in SAS Graph Template Language: Reference for
complete details about these options.)
Adding Insets to a SCATTERPLOTMATRIX Graph
369

INSET= (info-options)
Determines what information is displayed in an inset. Accepts one,
two, or all three of the following keywords:
NOBS
Number of observations
PEARSON
Pearson product-moment correlation
PEARSONPVAL
Probability value for the Pearson product-moment correlation
This option must be used to determine which inset information is
displayed in each cell. If this option is not used, the related
CORROPTS= and INSETOPTS= options are ignored.
CORROPTS=
(correlation-options)
Controls statistical options for computing correlations. These options
are similar to PROC CORR options. Accepts one or more of the
following keywords:
EXCLNPWGT=
specifies whether observations with non-positive weight values are
excluded from the analysis. Accepts TRUE (the default) or
FALSE.
NOMISS=
specifies whether observations with missing values are excluded
from the analysis that is displayed in the inset. Accepts TRUE (the
default) or FALSE. The NOMISS=TRUE option does not exclude
observations with missing values from the plot.
WEIGHT=
specifies a weighting variable to use in the calculation of Pearson
weighted product-moment correlation. The observations with
missing weights are excluded from the analysis. Accepts the name
of a numeric column.
VARDEF=
specifies the variance divisor in the calculation of variances and
covariances. Accepts one of the keywords DF (Degrees of
Freedom, the default, N - 1), N (number of observations), WDF
(sum of weights minus 1), WEIGHT (sum of weights).
370
Chapter 17
•
Adding Insets to a Graph

INSETOPTS=
(appearance-options)
Controls the inset placement and other appearance features.
AUTOALIGN=
specifies whether the inset is automatically aligned within the
layout. Accepts keywords NONE (no auto-alignment, the default),
AUTO (available only with scatter plots, attempts to center the
inset in the area that is farthest from any surrounding markers), or
a location list in parentheses that contains one or more keywords
that identify the preferred alignment (TOPLEFT TOP TOPRIGHT
LEFT CENTER RIGHT BOTTOMLEFT BOTTOM
BOTTOMRIGHT).
BACKGROUNDCOLOR=
specifies the color of the inset background. Accepts a style
reference or a color specification.
BORDER=
specifies whether a border is displayed around the inset. Accepts
TRUE or FALSE (the default).
HALIGN=
specifies the horizontal alignment of the inset. Accepts keywords
LEFT (the default), CENTER. or RIGHT.
OPAQUE=
specifies whether the inset background is opaque (TRUE) or
transparent (FALSE, the default).
TEXTATTRS=
specifies the text properties of the entire inset.
TITLE=
specifies a title for the inset.
TITLEATTRS=
specifies the text properties of the inset title.
VALIGN=
specifies the vertical alignment of the inset. Accepts keywords
TOP (the default), CENTER. or BOTTOM.
The following example uses all three of these options to display an inset in the cells of a
graph that is generated with the SCATTERPLOTMATRIX statement:
proc template;
 define statgraph spminset;
   begingraph;
     entrytitle "Scatter Plot Matrix with Insets Showing";
     entrytitle "Correlation Coefficients and P Values";
     layout gridded;
       scatterplotmatrix sepalwidth sepallength /
         rowvars=(petalwidth petallength)
         inset=(nobs pearson pearsonpval)
         insetopts=(autoalign=auto border=true opaque=true)
         corropts=(nomiss=true vardef=df)
         markerattrs=(size=5px);
     endlayout;
   endgraph;
 end;
run;
proc sgrender data=sashelp.iris template=spminset;
run;
Adding Insets to a SCATTERPLOTMATRIX Graph
371

Notice that the inset position might change from cell to cell in order to avoid obscuring
point markers.
Adding Insets to Classification Panels
This section requires familiarity with coding classification panels in the Graph Template
Language (GTL). If you are not familiar with classification panels, see Chapter 11,
“Using Classification Panels,” on page 257.
About Cell Insets in Classification Panels
The DATALATTICE and DATAPANEL layouts provide INSET= and INSETOPTS=
options for displaying insets in classification panels. The INSETOPTS= option supports
the same placement and appearance features as those documented for the
SCATTERPLOTMATRIX statement in “Adding Insets to a SCATTERPLOTMATRIX
Graph” on page 369. However, unlike the SCATTERPLOTMATRIX statement,
predefined information is not available for the DATALATTICE and DATAPANEL
layouts. Thus, for the INSET= option, you must create the columns for the information
that you want to display in the inset and merge it with the input data before the graph is
rendered. You can merge the inset data and analysis data by using match-merging (BY
statement) or by using a one-to-one merging (no BY statement). The manner in which
the data is merged is referred to as the data scheme for classification panel inset data.
The DATASCHEME= option is used to specify the data scheme that was used to merge
your inset and analysis data.
After you have merged the inset and analysis data, in your LAYOUT DATAPANEL or
LAYOUT DATALATICE statement, do the following:
•
use Usethe INSET= option to specify the name of one or more columns that contain
the information that you need for your insets.
372
Chapter 17
•
Adding Insets to a Graph

•
Use the DATASCHEME= option to specify the data scheme that you used to merge
your inset and analysis data as LIST (one-to-one merging) or MATCH (match-
merging).
Note: The match-merging data scheme is the preferred data scheme for merging the
inset and analysis data.
The following sections describe how to add insets by using match-merged and one-to-
one-merged data.
Adding Insets By Using the Match-Merging Data Scheme
The match-merging data scheme merges the inset data and analysis data according to
variables listed in a BY statement. It is the recommended method of generating data for
your insets. By default, the LAYOUT DATAPANEL and LAYOUT DATALATICE
statements assume that one-to-one merging was used to merge the data. To specify the
match-merging data scheme, you must include the DATASCHEME=MATCHMERGED
option in your LAYOUT DATAPANEL or LAYOUT DATALATICE statement. This
example shows you how to use the match-merging data scheme to merge your inset and
analysis data, and how to add the insets to your classification panel. This example uses
the Sashelp.Cars data set as the data source.
Here are the high-level steps that are performed in this example:
1. Generate the inset data from the Sashelp.Cars data set and write it to the Mileage
data set.
2. Sort the Sashelp.Cars data by Cylinders, Origin, and Type, and then write the sorted
data to the Cars data set.
3. Use match-merging to merge the Cars and Mileage data sets by Cylinders and
Origin, and then write the merged data to the AvgMileage data set.
4. Create the template for the classification panel.
5. Generate the graph by using the AvgMileage data.
Here is the SAS code that generates the inset data from the Sashelp.Cars data set, and
then writes it to the Mileage data set.
/* Generate the inset information and write it to data
   set MILEAGE.
*/
proc summary data=sashelp.cars completetypes;
   where type in ("Sedan" "Truck" "SUV") 
      and cylinders in (4 6 8);
   class cylinders origin;
   var mpg_city;
   output out=mileage MEAN=Mean N=Nobs / noinherit;
   TYPES CYLINDERS*ORIGIN;
run;
The SUMMARY procedure calculates the number of observations and the mean of
Mpg_City for each of the classification interactions listed in the TYPES statement.
Cylinder*Origin*Type is the crossing that each cell’s bar chart needs. The
COMPLETETYPES option creates summary observations even when the frequency of
the classification interactions is zero. In addition, the code creates subsets in the input
data to restrict the number of bars in each bar chart to at most three, and to reduce the
number cells in the classification panel. There are three values of Origin (Asia, Europe,
and USA) and three values of Cylinders (4, 6, and 8).
Adding Insets to Classification Panels
373

Here is the SAS code that sorts the data in Sashelp.Cars by Cylinders, Origin, and Type,
and then writes the sorted data to the Cars data set. This data order is required for the
match-merging that is completed in the next step.
/* Sort the analysis data by the variables that are
   used for the inset information: CYLINDERS, ORIGIN,
   and TYPE.
*/
proc sort data=sashelp.cars out=cars;
   by cylinders origin type;
run;
Here is the SAS code that performs the match-merging of Cars and Mileage data sets by
Cylinders and Origin, and then writes the merged data to the AvgMileage data set.
/* Match-merge the analysis data with inset data by
   CYLINDERS and ORIGIN.
*/
data avgmileage;
   merge cars mileage;
   BY CYLINDERS ORIGIN;
   format mean mpg_city 4.1;
run;
The template code in this example defines a template named PANEL. This template
requires that the input data contain separate columns for the items listed in the following
table.
classification variables
columnvar=origin rowvar=cylinders
inset information
inset=(nobs mean)
bar chart data
category=type response=mean
The INSET=(Nobs Mean) option in this template is used to reference input data columns
that are named Nobs and Mean. When the graph is rendered, the values that are stored in
these columns are displayed in the inset. In the inset display in this example, one row is
displayed for each column that is listed in the INSET= option, and each row has two
columns. The left column shows the column name (column label, if it is defined in the
data), and the right column contains the column value for that particular cell of the panel.
The number of values for these columns should match the number of cells in the
classification panel and the order of the values should correspond with the sequence in
which the cells are populated. The DATASCHEME=MATCHED suboption in the
INSETOPTS= option list specifies that the match-merging data scheme was used to
merge the inset and analytic data.
This template also adds a maximum row axis offset by using the OFFSETMAX=0.4
option to make room for the insets. In this case, OFFSETMAX=0.4 is sufficient, but the
setting will vary case-by-case. The first row of the classification panel with insets
appears as shown in the following figure.
374
Chapter 17
•
Adding Insets to a Graph

Here is the SAS code that creates template PANEL.
/* Create the graph template for the classification panel. */
proc template;
   define statgraph panel;
      begingraph;
         entrytitle "Average City MPG for Vehicles";
         entrytitle "by Origin, Cylinders and VehicleType";
         layout datalattice columnvar=origin rowvar=cylinders /
            columndatarange=unionall rowdatarange=unionall
            headerlabeldisplay=value
            headerbackgroundcolor=GraphAltBlock:color
            inset=(nobs mean)
            insetopts=(border=true datascheme=matched
            opaque=true backgroundcolor=GraphAltBlock:color)
            rowaxisopts=(offsetmax=.4 offsetmin=.1
               display=(tickvalues))
            columnaxisopts=(display=(label tickvalues)
            linearopts=(tickvaluepriority=true
            tickvaluesequence=(start=5 end=30 increment=5))
            griddisplay=on offsetmin=0 offsetmax=.1);
            layout prototype;
               barchart x=type Y=MPG_CITY / orient=horizontal 
                  STAT=MEAN barwidth=.5 barlabel=true;
            endlayout;
         endlayout;
      endgraph;
   end;
run;
Finally, here is the SAS code that renders the graph by using the data in the AvgMileage
data set.
/* Generate the graph using the AVGMILEAGE data. */
ods _all_ close;
ods html file="avgmileage.html" style=statistical;
proc sgrender data=avgmileage template=panel;
  where type in ("Sedan" "Truck" "SUV")
    and cylinders in (4 6 8);
run;
ods html close;
ods listing;
The following figure shows the output.
Adding Insets to Classification Panels
375

Figure 17.2
Classification Panel with Cell Insets
Adding Insets By Using the One-To-One-Merging Data Scheme
The one-to-one data scheme merges the inset data and the analysis data according to the
observations’ position in the data sets. No BY statement is used. By default, the
LAYOUT DATAPANEL and LAYOUT DATALATICE statements assume that one-to-
one merging was used to merge the inset data with the analysis data. In that case, the
inset for each cell is populated in data order. That is, the inset data in the first
observation is used for the cell 1 inset, the inset data for the second observation is used
for the cell 2 inset, and so on. This process requires that the inset data be placed first in
the data set and that it be ordered to correspond correctly with the cells in the
classification panel. Because of this requirement, the one-to-one merging data scheme
can be more complicated than the match-merging data scheme.
Note: The match-merging data scheme is the preferred method of merging your inset
data and analysis data. See “Adding Insets By Using the Match-Merging Data
Scheme” on page 373.
This example shows you how to use the one-to-one merging data scheme to merge your
inset and analysis data, and how to add the insets to your classification panel. The
Sashelp.Cars data set is used as the data source.
376
Chapter 17
•
Adding Insets to a Graph

Here are the high-level steps that are performed in this example:
1. Summarize the data in Sashelp.Cars for the cell insets (Cylinders*Origin) and the
cell bar charts (Cylinders*Origin*Type). Write the output to the Mileage data set.
2. Extract the cell summary data (_TYPE_=6) from the Mileage data set, rename the
columns, and write the data to the Overall data set.
Note: The columns must be renamed in order to prevent overwriting any values
when the data is merged in the next step.
3. Use one-to-one merging to merge the Mileage and Overall data sets to the
AvgMileage data set.
4. Create the template for the classification panel.
5. Generate the graph by using the AvgMileage data.
Here is the SAS code that summarizes the Sashelp.Cars data for the cells and bar charts.
/* Compute the BARCHART data and inset information */
 
proc summary data=sashelp.cars completetypes;
   where type in ("Sedan" "Truck" "SUV") and 
      cylinders in (4 6 8);
   class cylinders origin type;
   var mpg_city;
   output out=mileage(drop=_freq_) mean=Mean n=Nobs / noinherit;
   types cylinders*origin cylinders*origin*type;
run;
The SUMMARY procedure calculates the number of observations and the mean of
Mpg_City for each of the classification interactions listed in the TYPES statement.
Cylinders*Origin is the crossing needed for the cell summaries, and
Cylinders*Origin*Type is the crossing needed for each cell's bar chart. The
COMPLETETYPES option creates summary observations even when the frequency of
the classification interactions is zero. In addition, the code creates subsets in the input
data to restrict the number of bars in each bar chart to at most three, and to reduce the
number cells in the classification panel. There are three values of Origin (Asia, Europe,
and USA) and three values of Cylinders (4, 6, and 8).
For the insets to display accurate data, you must ensure that the order of the observations
in the data corresponds to the column order for the CLASS statement of the SUMMARY
procedure. Because the panel cells are populated across one row before proceeding to
the next row, the values of the panel's row variable (Cylinders) determine the panel
order. The values must be specified first in the SUMMARY procedure's CLASS
statement so that the values of Cylinders also determine the order for the statistics
calculations.
Adding Insets to Classification Panels
377

The following partial listing shows the order of the observations.
Output 17.1
Partial Listing of the Mileage Data Set
Obs    Cylinders    Origin    Type     _TYPE_      Mean     Nobs
  1        4        Asia                  6      25.8421     57
  2        4        Europe                6      23.4444     18
  3        4        USA                   6      24.0000     34
  4        6        Asia                  6      18.3000     60
  5        6        Europe                6      18.7632     38
  6        6        USA                   6      18.4754     61
  7        8        Asia                  6      15.2000     10
  8        8        Europe                6      16.1667     24
  9        8        USA                   6      15.5143     35
 10        4        Asia      SUV         7      21.4000      5
 11        4        Asia      Sedan       7      26.5102     49
 12        4        Asia      Truck       7      22.3333      3
 …
Notice that the first nine observations (where _TYPE_ equals 6) are the cell summaries.
The remaining 27 observations (where _TYPE_ equals 7) are for each cell's bar chart.
To create separate columns for the inset, you need to store the _TYPE_= 6 observations
in new columns. To do this, you must first extract the inset data into a separate data set
named Overall and rename the columns. You must rename the columns in order to
prevent overwriting any values when this data is merged with the Mileage data. Here is
the DATA step that writes the inset information to the Overall data set.
/* Extract the inset information, rename the columns,
   and write it to data set OVERALL.
*/
data mileage (drop=_type_)
   overall(keep=origin cylinders mean nobs 
      rename=(origin=cellOrigin cylinders=cellCyl mean=cellMean
         nobs=cellNobs ));
   set mileage; by _type_;  
   if _type_ eq 6 then output overall;
   else output mileage;
run;
Finally, you must merge the Mileage and Overall data sets into the Summary data set by
using one-to-one merging (no BY statement).
/* Merge MILEAGE and OVERALL and write to SUMMARY. */
data summary;
   merge mileage overall;
   label Mean="MPG (City)" CellNOBS="Nobs" CellMean="Mean"; 
   format mean cellMean 4.1; 
run;
378
Chapter 17
•
Adding Insets to a Graph

The following listing shows a sample of the merged data.
Output 17.2
Partial Listing of the Summary Data Set
Obs   Cylinders   Origin   Type    Mean   Nobs    Cyl   Origin   Mean   Nobs
  1       4       Asia     SUV     21.4     5      4    Asia     25.8    57
  2       4       Asia     Sedan   26.5    49      4    Europe   23.4    18
  3       4       Asia     Truck   22.3     3      4    USA      24.0    34
  4       4       Europe   SUV       .      0      6    Asia     18.3    60
  5       4       Europe   Sedan   23.4    18      6    Europe   18.8    38
  6       4       Europe   Truck     .      0      6    USA      18.5    61
  7       4       USA      SUV     20.5     2      8    Asia     15.2    10
  8       4       USA      Sedan   24.7    29      8    Europe   16.2    24
  9       4       USA      Truck   20.0     3      8    USA      15.5    35
 10       6       Asia     SUV     17.2    15      .               .      .
 11       6       Asia     Sedan   19.0    41      .               .      .
 12       6       Asia     Truck   15.5     4      .               .      .
 …
The template code in this example defines a template named PANEL. This template
requires that the input data contain separate columns for the items listed in the following
table.
classification variables
columnvar=origin rowvar=cylinders
inset information
inset=(cellNobs cellMean)
bar chart data
category=type response=mean
This template uses INSET=(CellNobs CellMean) to reference input data columns that
are named CellNobs and CellMean. When the graph is rendered, the values that are
stored in these columns are displayed in the inset. In the inset display in this example,
one row is displayed for each column that is listed on INSET=, and each row has two
columns. The left column shows the column name (column label, if it is defined in the
data), and the right column contains the column value for that particular cell of the panel.
The number of rows of data for these columns should match the number of cells in the
classification panel and the sequence in which the cells are populated. This template also
adds a maximum row axis offset using the OFFSETMAX=0.4 option to make room for
the insets.
Here is the code that creates the template in this example and that renders that graph.
proc template;
   define statgraph panel;
      begingraph;
         entrytitle "Average City MPG for Vehicles";
         entrytitle "by Origin, Cylinders and VehicleType";
         layout datalattice columnvar=origin rowvar=cylinders /
            columndatarange=unionall rowdatarange=unionall
            headerlabeldisplay=value
            headerbackgroundcolor=GraphAltBlock:color
            inset=(cellNobs cellMean)
            insetopts=(border=true datascheme=list
               opaque=true backgroundcolor=GraphAltBlock:color)
            rowaxisopts=(offsetmax=.4 offsetmin=.1 display=(tickvalues))
            columnaxisopts=(display=(label tickvalues)
Adding Insets to Classification Panels
379

               linearopts=(tickvaluepriority=true
                  tickvaluesequence=(start=5 end=30 increment=5))
            griddisplay=on offsetmin=0 offsetmax=.1);
            layout prototype;
               barchart category=type response=mean / orient=horizontal
                  barwidth=.5 barlabel=true;
            endlayout;
         endlayout;
      endgraph;
   end;
run;
ods html style=statistical;
proc sgrender data=summary template=panel;
run;
The output is shown in Figure 17.2 on page 376.
Creating Axis-Aligned Insets
Sometimes you want an inset to provide information about values along an axis. The
information is aligned with values on the axis. You can use a block plot or an axis table
to display information that is aligned with axis values.
Creating an Axis-Aligned Inset with a Block Plot
This section provides examples of how to create an axis-aligned inset using the
BLOCKPLOT statement. For information about the BLOCKPLOT statement, see
“BLOCKPLOT Statement” in SAS Graph Template Language: Reference. In the
following example, "events" have been defined over time and the inset information at the
top of the plot provides information about these events. The example uses a
BLOCKPLOT statement, which creates one or more strips of rectangular blocks
containing text values. The width of each block corresponds to specified numeric
intervals along the X-axis.
380
Chapter 17
•
Adding Insets to a Graph

Here is the output for this example.
Figure 17.3
An Axis-Aligned Inset Created Using a Block Plot
The input data for this example must contain data for both the series plot and the block
plot. The simplest way to construct the appropriate data is to match-merge the Microsoft
release data and the Microsoft stock data. The first step is to create data set Msevents,
which contains the Microsoft release dates. The next step is to sort the Microsoft stock
data by date, match-merge it with Msevents, and then write it to data set Events.
Example Code 17.1
SAS Code That Generates the Events Data Set
/* Create a data set of the release dates. */
data MSevents;
  input Date date9. Release $7.;
datalines;
09dec1987 2.0
22may1990 3.0
01aug1993 NT 3.1
24aug1995 95
25jun1998 98
17feb2000 2000
25oct2001 XP
;
run;
/* Sort the Microsoft stock data by date. */
proc sort data=sashelp.stocks(keep=date stock adjclose)
  out=MSstock;
  where stock="Microsoft"; 
  by date;
run;
/* Match-merge the release data and the stock data. */
data events;
Creating Axis-Aligned Insets
381

  merge MSstock MSevents;
  by date;
run;
Output 17.3
Partial Listing of the Events Data Set
Obs      Stock       Date      Close    Release
 …
 15    Microsoft    01OCT87    $0.30
 16    Microsoft    02NOV87    $0.27
 17    Microsoft    01DEC87    $0.33
 18                 09DEC87      .        2.0
 19    Microsoft    04JAN88    $0.34
 20    Microsoft    01FEB88    $0.36
 21    Microsoft    01MAR88    $0.34
 22    Microsoft    04APR88    $0.33
 23    Microsoft    02MAY88    $0.35
 24    Microsoft    01JUN88    $0.40
 …
As shown in the partial listing of the Events data set, the first release event occurs in
observation 18. In the observations for the release dates, the Stock and Close column
values are missing. In the Microsoft stock observations, the Release column value is
missing.
Here is the code that defines the template for this example and then renders the graph.
/* Create the template for the graph. */
proc template;
  define statgraph blockplot1;
    begingraph;
      entrytitle "Microsoft Share Prices";
      entrytitle "and Significant OS Releases";
      layout overlay / yaxisopts=(offsetmax=0.075);
        blockplot x=date block=release / 
          display=(outline values label)
          valuevalign=top valuehalign=left
          labelposition=top
          extendblockonmissing=true
          valueattrs=GraphDataText(weight=bold
            color=GraphData2:contrastcolor)
          labelattrs=GraphValueText(weight=bold
            color=GraphData2:contrastcolor)
          outlineattrs=(color=GraphGridLines:color);
        seriesplot x=date y=adjclose / lineattrs=GraphData1;
    endlayout;
   endgraph;
  end;
run;
/* Render the graph. */
proc sgrender data=events template=blockplot1;
   format date year4.;
run;
In the template code, the block plot is overlaid with a series plot to create an axis-aligned
inset. The OFFSETMAX= option is specified for the Y axis in order to reserve space for
the block plot values. Notice that the BLOCKPLOT statement requires two input
columns: one for the X= argument and another for the BLOCK= argument. The
382
Chapter 17
•
Adding Insets to a Graph

EXTENDBLOCKONMISSING=TRUE option extends the blocks across the missing
values of the Release column. The BLOCK= transition points control the boundary of
each block and the text that is displayed. In this case, a new block begins at each
nonmissing value of the Release column. The range of the X= values between two block
transition points determine the width of each block.
The BLOCKPLOT statement supports many options for controlling the content,
position, and appearance of the blocks and text information.
DISPLAY= ( <OUTLINE> <FILL> <VALUES> <LABEL> )
specifies the features to display
EXTENDBLOCKONMISSING=TRUE | FALSE
specifies whether the block continues with the previous nonmissing value or a new
block is started when a missing value is encountered in the Block column
VALUEVALIGN= TOP | CENTER | BOTTOM
specifies the vertical position of the text values within the blocks
VALUEHALIGN=LEFT | CENTER | RIGHT | START
specifies the horizontal position of the text values within the blocks
LABELPOSITION= LEFT | RIGHT | TOP | BOTTOM
specifies a position for the block label that applies to the block values
VALUEATTRS=style-element
specifies font properties for block the values
LABELATTRS=style-element
specifies font properties for the block label
The next example shows a different way to present the same information. Here the
outlines are removed and the blocks are filled with colors. The example uses the
following BLOCKPLOT options:
FILLTYPE= MULTICOLOR | ALTERNATE
specifies how the blocks are filled
DATATRANSPARENCY= number
specifies the degree of the transparency of the block fill and outline. The range for
number is from 0 (opaque) to 1 (entirely transparent).
Creating Axis-Aligned Insets
383

Here is the output for this example.
Here is the code that defines the template for this example and then renders the graph.
/* Create the template for the graph. */
proc template;
  define statgraph blockplot1a;
    begingraph; 
      entrytitle "Microsoft Share Prices"; 
      entrytitle "and Significant OS Releases";
      layout overlay / yaxisopts=(offsetmax=0.075); 
        blockplot x=date block=release / display=(fill values)
          valuevalign=top valuehalign=left
          labelposition=top
          extendblockonmissing=true
          valueattrs=GraphDataText(weight=bold)
          filltype=multicolor
          datatransparency=.5;
        seriesplot x=date y=adjClose / lineattrs=GraphData1;
    endlayout;
   endgraph;
  end;
run;
/* Render the graph. */
proc sgrender data=events template=blockplot1a;
   format date year4.;
run;
In this template, the FILLATTRS=MULTICOLOR setting ensures that the colors will be
obtained from the GraphData1 to GraphDataN style elements of the current style.
Transparency is added to fade the colors. The block label "Release" is suppressed, and
the horizontal alignment of the block values is left.
384
Chapter 17
•
Adding Insets to a Graph

The BLOCKPLOT statement can also create a table of inset information where the
columns are centered on discrete values along the X-axis and the rows represent
different statistics for each value of the X= variable. This technique for displaying inset
information is possible for plots with a discrete X-axis, such as box plots and bar charts.
The BLOCKPLOT statement supports a CLASS=variable option that creates a separate
block plot for each unique value of the CLASS= variable.
Figure 17.4
Axis-Aligned Multi-row Table Created Using a Block Plot
To create this graph, some data set up is necessary. First, we use PROC SUMMARY to
summarize the data in Sashelp.Cars and write it to data set Stats.
Example Code 17.2
SAS Code That Generates the Stats Data Set
/* Create summarized data with desired statistics */
proc summary data=sashelp.cars nway alpha=.05;
  class type;
  var mpg_highway;
  output out=stats(drop=_FREQ_ _TYPE_)
     n=N mean=Mean uclm=UCLM lclm=LCLM / noinherit;
run;
Output 17.4
Listing of Stats Data Set
Obs    Type        N      Mean       UCLM       LCLM
 1     Hybrid      3    56.0000    77.5133    34.4867
 2     SUV        60    20.5000    21.3620    19.6380
 3     Sedan     262    28.6298    29.1732    28.0863
 4     Sports     49    25.4898    26.3234    24.6562
 5     Truck      24    21.0000    22.6378    19.3622
 6     Wagon      30    27.9000    29.5478    26.2522
The Stats data set columns Type, Mean, UCLM, and LCLM will be used by a
BARCHARTPARM statement. However, the columns that are required for the
Creating Axis-Aligned Insets
385

BLOCKPLOT statement are not the same as those for the BARCHARTPARM
statement. The information must first be transposed.
/* Transpose data for use with BLOCKPLOT */
proc transpose data=stats
      out=blockstats(rename=(type=type2 _name_=statname col1=stat));
  by type; 
  attrib statname label=''; /* Remove the old label from statname */
  var n mean uclm lclm;
run;
The SAS log displays the following note when the procedure code is submitted:
Output 17.5
Partial Listing of the Blockstats Data Set
Obs    type2     statname      stat
  1    Hybrid      N           3.000
  2    Hybrid      Mean       56.000
  3    Hybrid      UCLM       77.513
  4    Hybrid      LCLM       34.487
  5    SUV         N          60.000
  6    SUV         Mean       20.500
  7    SUV         UCLM       21.362
  8    SUV         LCLM       19.638
  9    Sedan       N         262.000
 10    Sedan       Mean       28.630
 11    Sedan       UCLM       29.173
 12    Sedan       LCLM       28.086
 …
Finally, the data for the BARCHARTPARM and BLOCKPLOT statements must be non-
match merged into one input data set. Note that the Type and Type2 columns must be
distinct variables.
/* Combine summary data for BARCHARTPARM with tabular data for BLOCKPLOT */
data all;
  merge stats blockstats;
run;
Output 17.6
Partial Listing of the ALL Data Set
Obs   Type       N     Mean      UCLM      LCLM    type2    statname     stat
  1   Hybrid     3   56.0000   77.5133   34.4867   Hybrid     N          3.000
  2   SUV       60   20.5000   21.3620   19.6380   Hybrid     Mean      56.000
  3   Sedan    262   28.6298   29.1732   28.0863   Hybrid     UCLM      77.513
  4   Sports    49   25.4898   26.3234   24.6562   Hybrid     LCLM      34.487
  5   Truck     24   21.0000   22.6378   19.3622   SUV        N         60.000
  6   Wagon     30   27.9000   29.5478   26.2522   SUV        Mean      20.500
  7              .     .         .         .       SUV        UCLM      21.362
  8              .     .         .         .       SUV        LCLM      19.638
  9              .     .         .         .       Sedan      N        262.000
 10              .     .         .         .       Sedan      Mean      28.630
 11              .     .         .         .       Sedan      UCLM      29.173
 12              .     .         .         .       Sedan      LCLM      28.086
 …
Here is the code that creates the template for this example and then renders the graph.
/* Create the template for the graph. */
386
Chapter 17
•
Adding Insets to a Graph

proc template; 
   define statgraph blockplot2; 
     begingraph; 
       entrytitle "Highway Mileage for Vehicle Types";
       entryfootnote halign=left {unicode alpha} " = .05";
     layout overlay / xaxisopts=(label="Type"); 
         innermargin / align=top; 
           blockplot x=type2  block=stat /  class=statname 
             includemissingclass=false
             display=(values label outline) valuehalign=center 
             labelattrs=GraphDataText valueattrs=GraphDataText
             outlineattrs=(color=graphaxislines:color);
         endinnermargin; 
         barchartparm x=type y=mean /
           errorlower=lclm errorupper=uclm; 
       endlayout; 
     endgraph; 
   end; 
 run; 
 /* Render the graph. */
 proc sgrender data=all template=blockplot2; 
 run;
The template for this graph uses a BLOCKPLOT statement in an INNERMARGIN
block to create the inset. The INNERMARGIN block reserves sufficient space along the
top of the graph (ALIGN=TOP) for the BLOCKPLOT statement output. The
BLOCKPLOT statement specifies X=TYPE2 and BLOCK=STAT. By default, if there
are adjacent repeated values for the BLOCK= column, a new block does not begin until
the BLOCK value changes. The CLASS=STATNAME setting creates a row (block plot)
for each value of the Type2 column. By default, the values of the CLASS= variable
appear as row labels external to the block plot.
In order to blend the block plot with the graph, the block plot label and value text
attributes are set to GraphDataText. The outline color is set to GraphAxisLines:Color in
order to match the axis line and graph wall outline color.
Creating an Axis-Aligned Inset with an Axis Table
This section provides examples of how to create an axis-aligned inset with an
AXISTABLE statement. For information about the AXISTABLE statement, see
“AXISTABLE Statement” in SAS Graph Template Language: Reference The following
example generates a graph similar to that shown in Figure 17.3 on page 381. This
example uses an axis table instead of a block plot and the same data that was generated
for the box plot example. See Example Code 17.1 on page 381.
Creating Axis-Aligned Insets
387

Here is the output for this example.
Figure 17.5
An Axis-Aligned Inset Created Using an Axis Table
Here is the code that defines the template for this example and then renders the graph.
/* Create the template for the graph. */
proc template;
  define statgraph axistable1;
    begingraph;
      entrytitle "Microsoft Share Prices";
      entrytitle "and Significant OS Releases";
      layout overlay;
        seriesplot x=date y=adjClose / lineattrs=GraphData1;
        referenceline x=eval(ifn(release ne " ",date,.)) /
           lineattrs=(color=lightgray);
        innermargin / align=top opaque=true;
           axistable x=date value=release /
              display=(label)
              valueattrs=(color=GraphData2:contrastcolor weight=bold)
              labelattrs=(color=GraphData2:contrastcolor weight=bold);
        endinnermargin;
    endlayout;
   endgraph;
  end;
run;
/* Render the graph. */
proc sgrender data=events template=axistable1;
run;
The code defines a template named AXISTABLE1, which is used to create this graph. In
this template, an inner margin is placed at the top of the graph. The inner margin block
contains an AXISTABLE statement, which displays the release for each event date. The
inner margin automatically reserves space at the top of the graph for the axis table. A
388
Chapter 17
•
Adding Insets to a Graph

REFERENCELINE statement draws a light-gray reference line at each release date. The
IFN function is used to draw a reference line only at dates where the Release column
value is a nonmissing value. Because the OPAQUE=TRUE option is in the
INNERMARGIN statement, the reference lines do not pass through the axis table
values. The SERIESPLOT statement draws the plot.
The following example generates a graph similar to that shown in Figure 17.4 on page
385. The example uses an axis table instead of a block plot, and it uses the summarized
data that was generated for the box plot multi-row table example. For this example, you
do not need to transpose the summarized data in the STATS data set. You can use the
STATS data set as generated. See Example Code 17.2 on page 385.
Figure 17.6
Axis-Aligned Multi-row Table Created Using an Axis Table
Here is the code that defines the template for this example and then renders the graph.
/* Create the template for the graph. */
proc template;
  define statgraph axistable2;
    begingraph;
      entrytitle "Highway Mileage for Vehicle Types";
      layout overlay /  
        xaxisopts=(discreteopts=(colorbands=even 
           colorbandsattrs=(transparency=0.8)))
        yaxisopts=(offsetmax=0.25);
        barchartparm category=type response=mean /
           errorlower=lclm errorupper=uclm;
        axistable x=type value=n / position=0.95
           display=(label) labelattrs=GraphDataText;
        axistable x=type value=mean / position=0.90
           display=(label) labelattrs=GraphDataText;
        axistable x=type value=uclm / position=0.85
           display=(label) labelattrs=GraphDataText;
        axistable x=type value=lclm / position=0.80
           display=(label) labelattrs=GraphDataText;
Creating Axis-Aligned Insets
389

    endlayout;
   endgraph;
  end;
run;
/* Render the graph. */
proc sgrender data=stats template=axistable2;
run;
In this template, the AXISTABLE statements are not placed in an inner margin block.
The OFFSETMAX= option is used with the Y axis in order to reserve space at the top of
the graph for the axis table. One AXISTABLE statement displays a row of statistical
values in the table for each vehicle type. Four AXISTABLE statements are required to
build the table in this example. The POSITION= option is used in each AXISTABLE
statement to position each table row vertically. A simpler approach is to place one
AXISTABLE statement in an inner margin block and include the CLASS=STATNAME
option in the AXISTABLE statement. In that case, the INNERMARGIN statement
automatically reserves space for the table, and the CLASS= option automatically
generates one row for each statistic. However, the POSITION= option enables greater
control over the vertical spacing of the table rows.
Note: The POSITION= option is ignored when the AXISTABLE statement is placed in
an INNERMARGIN block.
Creating an Axis-Aligned Inset with the GTL Annotation Facility
You can use the GTL annotation facility to construct an axis-aligned inset. By using the
GTL annotation facility, you can position text and other graphics elements at specific
coordinates in the DATAVALUE drawing space along an axis. Although more complex,
the annotation facility provides a great deal of flexibility for creating custom insets. For
an example of using the GTL annotation facility to create axis-aligned insets, see
“Example 2: Displaying Subsets of Annotations in Axis-Aligned Insets” on page 431.
For information about the GTL annotation facility, see Chapter 14, “About The GTL
Annotation Facility,” in SAS Graph Template Language: Reference.
390
Chapter 17
•
Adding Insets to a Graph

Chapter 18
Managing the Graph Appearance
with Styles
ODS Style Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391
Changing Fonts in a Style Template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
Controlling ODS Search Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
Changing Box Plot Display . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
ODS Style Templates
It is often useful to create graphs with specific visual characteristics that do not have to
be hard coded into the GTL for every graph that you create. For example, you might
want to modify settings for the following graph features:
•
font or font sizes
•
line or marker properties
•
colors
•
display features for box plots, histograms, contours, and other chart types
•
a combination of features that are related to a publication or corporate presentation
scheme.
Because the default properties of nearly all GTL appearance-related options are obtained
from the current style (see Chapter 6, “Managing Graph Appearance: General
Principles,” on page 111), modifying an existing style is often the best way to enforce a
certain look-and-feel across many graphs.
Similar to graphics templates, ODS style templates are stored in SAS item stores. All
styles supplied by SAS are located in the STYLES directory of the Sashelp.Tmplmst
item store. Templates can be viewed from the Templates window (ODSTEMPLATE
command). The template source can be viewed by opening any template.
391

Although an ODS style can be constructed from scratch, it is much simpler to identify a
style that is fairly close to what you want and make limited changes to it. The following
styles are recommended starting points.
Style
Example
LISTING
•
white background
•
white wall
•
sans-serif fonts
•
color used for lines, markers, and
filled areas
•
other colors the same as DEFAULT
style
DEFAULT
•
gray background
•
white wall
•
sans-serif fonts
392
Chapter 18
•
Managing the Graph Appearance with Styles

Style
Example
STATISTICAL
•
white background
•
white wall
•
sans-serif fonts
•
contrasting color scheme of blues,
reds, greens for markers, lines, and
filled areas
HTMLBLUE
•
white background
•
white wall
•
sans-serif fonts
•
table colors match the graph colors
•
group distinctions based on color
rather than marker or line styles
•
a lighter color scheme for HTML
content
ANALYSIS
•
light tan background
•
white wall
•
sans-serif fonts
•
muted color scheme of tans, greens,
yellows, oranges and browns for lines,
markers, and filled areas
JOURNAL and JOURNAL3
•
white background
•
white wall
•
sans-serif fonts
•
gray-scale color scheme for markers,
lines, and filled areas
•
gray-scale pattern and color scheme
for bar fill patterns (JOURNAL3
only)
ODS Style Templates
393

Style
Example
JOURNAL2
•
white background
•
white wall
•
sans-serif fonts
•
black-only scheme for markers, lines,
and bar fill patterns
•
no solid filled areas—a minimal ink
style
Changing Fonts in a Style Template
Notice that all of the recommended styles use Sans-serif fonts. The following example
shows how to create a custom style that uses Serif fonts instead. The example uses the
STATISTICAL style as a starting point (parent) for the custom style.
The following PROC TEMPLATE code shows the beginning of the style definition for
the STATISTICAL style, which is delivered with the SAS System. Only the code to be
modified is shown.
proc template;
define style Styles.Statistical;
parent = styles.default;
style fonts /
 'TitleFont2'=("<sans-serif>, <MTsans-serif>, Helvetica,Helv",2,bold)
 'TitleFont'=("<sans-serif>, <MTsans-serif>, Helvetica,Helv",3,bold)
 'StrongFont'=("<sans-serif>, <MTsans-serif>, Helvetica,Helv",2,bold)
 'EmphasisFont'=("<sans-serif>, <MTsans-serif>, Helvetica,Helv",2,italic)
 'FixedFont'=("<monospace>, Courier",2)
 'BatchFixedFont'=("SAS Monospace, <monospace>, Courier, monospace",2)
 'FixedHeadingFont'=("<monospace>, Courier, monospace",2)
 'FixedStrongFont'=("<monospace>, Courier, monospace",2,bold)
 'FixedEmphasisFont'=("<monospace>, Courier, monospace",2,italic)
 'headingEmphasisFont'=("<sans-serif>, <MTsans-serif>, Helvetica,
       Helv",2,bold italic)
 'headingFont'=("<sans-serif>, <MTsans-serif>, Helvetica, Helv",2,bold)
 'docFont'=("<sans-serif>, <MTsans-serif>, Helvetica, Helv",2);
style GraphFonts /    
 'GraphDataFont'=("<sans-serif>, <MTsans-serif>",7pt)
 'GraphUnicodeFont'=("<MTsans-serif-unicode>",9pt)
 'GraphValueFont'=("<sans-serif>, <MTsans-serif>",9pt)
 'GraphLabelFont'=("<sans-serif>, <MTsans-serif>",10pt)
 'GraphFootnoteFont'=("<sans-serif>, <MTsans-serif>",10pt,italic)
 'GraphTitleFont'=("<sans-serif>, <MTsans-serif>",11pt,bold)
 'GraphAnnoFont'=("<sans-serif>, <MTsans-serif>",10pt);
394
Chapter 18
•
Managing the Graph Appearance with Styles

  /* more code */
end;
run;
We make the following changes:
•
Assign a name to a new style that identifies STATISTICAL as its parent style. It is
recommended that you create a new style of a different name so that access to the
existing style is not blocked. See discussion under “Controlling ODS Search Paths”
on page 397.
•
Change the Fonts style element (affects tables) so that it uses Serif fonts.
•
Change the GraphFonts style element (affects graphs) so that it uses Serif fonts.
Two style elements govern all fonts in a style: the Fonts element governs tables, and the
GraphFonts element governs graphs. When changing fonts in a style, be sure to make
consistent changes to both elements. In this case, we want to change from a sans-serif
font to a serif font. You can also change font size, weight, and style.
In style templates, the name of a font family normally appears as a quoted string.
However, ODS also supports an indirect reference to a font family. When a font name
appears between less than and greater than symbols, such as <sans-serif>, it means that
the font family sans-serif is defined in the SAS Registry. For the Windows Release of
SAS, here are some of the registry keys and values that are stored under ODS ð Fonts:
Display 18.1
Registry Keys and Values for Fonts in the Windows Release of SAS
The registry definition of MTsans-serif and MTserif refer to TrueType fonts that are
shipped with SAS and are similar to "Arial" and "Times New Roman." These "MT"
fonts (short for Monotype) can be used on any computer where SAS is installed. A
specific font family such as "Verdana" could be used instead. Note that fonts are
normally listed in a "most-specific" to "most generic" order so that reasonable
substitution can be made when a font cannot be located on the current computer.
Notice that several graph fonts affect different parts of a graph. The following table
shows some but not all features that are affected by the graph fonts:
GraphTitleFont
Used for all titles of the graph. Typically, this is the largest font.
Changing Fonts in a Style Template
395

GraphFootnoteFont
Used for all footnotes. Typically, this font is smaller than the title font.
Sometimes, footnotes are italicized.
GraphLabelFont
Used for axis labels and legend titles. Generally, this font is smaller
than the title font.
GraphValueFont
Used for axis tick values and legend entries. Generally, this font is
smaller than the label font.
GraphDataFont
Used for text where minimum size is necessary (such as point labels).
GraphUnicodeFont
Used for adding special glyphs (for example, α , ±, € ) to text in the
graph (see Chapter 7, “Adding and Changing Text in a Graph,” on page
157).
GraphAnnoFont
Default font for text added as annotation in the ODS Graphics Editor.
The SAS Output Delivery System: User's Guide provides information and examples of
all predefined style elements and attributes.
In our example, we will name our modified style template SerifStatistical , change all
occurrences of sans-serif to serif, change all occurrences of MTsans-serif to MTserif,
and change Helvetica and Helv (sans-serif fonts) to Times (a serif font):
proc template;
 define style Styles.SerifStatistical ;
  parent = styles.statistical;
   style fonts /
    'TitleFont2'=(" <serif> , <MTserif> , Times ",2,bold)
    'TitleFont'=(" <serif> , <MTserif> , Times ",3,bold)
    'StrongFont'=(" <serif> , <MTserif> , Times ",2,bold)
    'EmphasisFont'=(" <serif> , <MTserif> , Times ",2,italic)
    'FixedFont'=("<monospace>, Courier",2)
    'BatchFixedFont'=("SAS Monospace, <monospace>, Courier, monospace",2)
    'FixedHeadingFont'=("<monospace>, Courier, monospace",2)
    'FixedStrongFont'=("<monospace>, Courier, monospace",2,bold)
    'FixedEmphasisFont'=("<monospace>, Courier, monospace",2,italic)
    'headingEmphasisFont'=(" <serif> , <MTserif> , Times ",
             2,bold italic)
    'headingFont'=(" <serif> , <MTserif> , Times ",2,bold)
    'docFont'=(" <serif> , <MTserif> , Times ",2);
   style GraphFonts /
    'GraphTitleFont'=(" <serif> , <MTserif> ",11pt,bold)
    'GraphFootnoteFont'=(" <serif> , <MTserif> ",10pt,italic)
    'GraphLabelFont'=(" <serif> , <MTserif> ",10pt)
    'GraphValueFont'=(" <serif> , <MTserif> ",9pt)
    'GraphDataFont'=(" <serif> , <MTserif> ",7pt)
    'GraphUnicodeFont'=(" <MTserif-unicode> ",9pt)
    'GraphAnnoFont'=(" <serif> , <MTserif> ",10pt);
 end;
run;
Note: By assigning the parent to STYLES.STATISTICAL, we need to change only two
style elements. The rest of the elements are inherited.
396
Chapter 18
•
Managing the Graph Appearance with Styles

Controlling ODS Search Paths
Before you submit your modified style definition, you should consider whether this style
is for your use only or whether you want to share it with others. Your decision
determines where you store the style.
The ODS PATH statement determines the read and write locations for SAS item store
templates.
ods path show;
Current ODS PATH list is:
1. SASUSER.TEMPLAT(UPDATE)
2. SASHELP.TMPLMST(READ)
By default, modified templates are stored in Sasuser.Templat, which is appropriate for
your personal use. To store a modified template in this default location, you will see the
following note in the SAS Log after submitting the PROC TEMPLATE code:
NOTE: STYLE 'Styles.SerifStatistical' has been saved to:
SASUSER.TEMPLAT
You can then run your program with the new style:
ods rtf style=serifStatistical ;
ods graphics on;
proc reg data=sashelp.class;
  model weight=height;
quit;
ods rtf close;
To save a modified template to a location where others can access it, you cannot use the
default Sasuser.Templat location. Rather, store the template in a different library, using
the ODS PATH statement to set the search path:
libname common "u:\ODS_templates";
ods path common.dept(update)
         sasuser.templat(update)
         sashelp.tmpmst(read);
This ODS PATH statement establishes a new search path. The first item store
(common.dept) can be updated and will contain the new template
(Styles.SerifStatistical). It is important to include Sashelp.Tmplmst in the path because
the inherited parent style (Styles.Default) is in Sashelp.
After setting this new search path, you will see the following note in the SAS Log when
you submit the PROC TEMPLATE code:
NOTE: STYLE 'Styles.SerifStatistical' has been saved to:
COMMON.DEPT
For others to access this style definition, everyone needs to precede their programs with
the following code:
libname common "u:\ODS_templates" access=readonly;
Controlling ODS Search Paths
397

ods path sasuser.templat(update)
         common.dept(read)
         sashelp.tmpmst(read);
They can then run their program with the new style:
ods rtf style=serifStatistical;
ods graphics on;
proc reg data=sashelp.class;
  model weight=height;
quit;
ods rtf close;
The following figure shows a table and graph from the output.
Changing Box Plot Display
The SAS System defines many graphical style elements. Some have a very narrow
scope, such as those that control the display of box plots. Using these style elements as a
starting point, you can change the style attribute values to achieve a very different
appearance for your box plots. The same is true for histograms, contours, and some other
plot types.
398
Chapter 18
•
Managing the Graph Appearance with Styles

Using the DEFAULT style for an example, here is a portion of the style definition for
elements that are related to box plots:
proc template;
  define style Styles.Default;
  ...
  style GraphBox /
     capstyle = "serif"
     connect = "mean"
     displayopts = "fill caps median mean outliers";
  style GraphBoxMean / ... ;
  style GraphBoxMedian / ... ;
  style GraphBoxOutlier / ... ;
  style GraphBoxWhisker / ... ;
  ...
  end;
run;
Style Element
Purpose
GraphBox
general box plot properties (see the next table)
GraphBoxMean
marker properties of mean marker
(MARKERSYMBOL= , MARKERSIZE=, CONTRASTCOLOR=)
GraphBoxMedian
line properties of the median line
(LINESTYLE=, LINETHICKNESS=, CONTRASTCOLOR=)
GraphBoxOutlier
marker properties of outliers
(MARKERSYMBOL=, MARKERSIZE=, CONTRASTCOLOR=)
GraphBoxWhisker
line properties of whiskers and caps
(LINESTYLE=, LINETHICKNESS=, CONTRASTCOLOR=)
Attributes and Values for the GraphBox Style Element
Attribute
Value(s)
Description
CONNECT=
"MEAN" | "MEDIAN" | "Q1" | "Q3" |
"MIN" | "MAX"
statistic to connect with line
CAPSTYLE=
"SERIF" | "LINE" | "BRACKET"
shape at ends of whiskers
DISPLAYOPTS=
"<CAPS>
show caps at end of whiskers
<FILL>
show filled boxes
<MEAN>
show a marker for the mean
<MEDIAN>
show a line for the median
<OUTLIERS>
show markers for the outliers
Changing Box Plot Display
399

Attributes and Values for the GraphBox Style Element
Attribute
Value(s)
Description
<CONNECT>
show line connecting same
statistic on multiple boxes
<NOTCHES>"
show notched boxes
The DISPLAYOPTS attribute of GraphBox lists the general features to be displayed.
The following diagram shows the standard display for box plots, as defined by the
DEFAULT style. The keywords that are related to the appearance features are annotated:
The two display options that are not the default are CONNECT (show connect lines) and
NOTCHES.
400
Chapter 18
•
Managing the Graph Appearance with Styles

The STATISTICAL style is derived from the DEFAULT style and inherits the
GraphBox element from the parent DEFAULT style. The following code generates a
box plot for the STATISTICAL style:
proc template;
   define statgraph boxplotdef;
   begingraph;
      entrytitle "Statistical Style";
      layout overlay / xaxisopts=(label="Age" type=linear);
         boxplot x=ageatstart y=cholesterol / intervalboxwidth=40; 
      endlayout;
   endgraph;
end;
ods graphics on / outputfmt=static;
ods html style=statistical;
proc sgrender data=sashelp.heart template=boxplotdef;
   where ageatstart between 50 and 55;
run;
ods graphics off;
For this example, we want to change the following attributes on the default box plot:
•
By default, serif caps are displayed at the end of the fences. We want to remove
those caps from the fence lines.
•
By default, the boxes are filled. We want to display empty, notched boxes.
•
By default, the mean values are represented by hollow diamonds. We want to display
filled diamonds and slightly reduce their size.
•
By default, the marker symbols for the outliers are hollow black circles. We want to
change the size and shape of the marker symbols, and again reduce their size.
To make these changes, we can derive a new style from the STATISTICAL style and set
the attributes that we want to change. Any attribute settings that we do not change are
Changing Box Plot Display
401

inherited from the parent STATISTICAL style. The following style definition effects the
desired changes:
proc template;
  define style Styles.Boxplot;
  parent = styles.statistical;
    style GraphBox from GraphBox /
      capstyle = "line"
      displayopts = "caps median mean outliers notches";
    style GraphBoxMean from GraphBoxMean /
      markersymbol="diamondfilled"
      contrastcolor=GraphColors("gcdata1")
      markersize = 5px;
    style GraphOutlier from GraphOutlier /
      markersize = 5px
      markersymbol = "x"
      contrastcolor = GraphColors("gcdata2");
    end;
run;
•
The DEFINE STYLE statement assigns the name BOXPLOT to our new style, and
sets the STATISTICAL style as the parent style.
•
On the GraphBox style element, the CAPSTYLE= attribute is set to LINE, which
removes the serif caps from the end of the fences. The DISPLAYOPTS= attribute
drops the FILL value from the display list and adds the NOTCHES value; these
changes determine that the graph displays empty, notched boxes.
•
On the GraphBoxMean style element, the marker symbol is changed to a filled
diamond and the marker size is reduced to 5 pixels (the default is 9 pixels). The
CONTRASTCOLOR= attribute is set to GCDATA1 (the default is GCDATA).
•
On the GraphBoxOutlier style element, the marker symbol is changed to an X and
the marker size is reduced to 5 pixels (the default is 7 pixels). The
CONTRASTCOLOR= attribute is set to GCDATA2 (the default is GCOUTLIER).
The following code generates a box plot for the BOXPLOT style:
proc template;
   define statgraph boxplotdef;
   begingraph;
      entrytitle "Boxplot Style";
      layout overlay / xaxisopts=(label="Age" type=linear);
         boxplot x=ageatstart y=cholesterol / intervalboxwidth=40; 
      endlayout;
   endgraph;
end;
ods graphics on / outputfmt=static;
ods html style=Styles.Boxplot;
proc sgrender data=sashelp.heart template=boxplotdef;
   where ageatstart between 50 and 55;
run;
ods graphics off;
402
Chapter 18
•
Managing the Graph Appearance with Styles

When making such style changes remember that you are affecting all box plot displays
for all procedures that produce box plots when this style is in effect. It is possible to
change the box plot appearance for specific procedures, but to do this, a specific graph
template must be modified, not a style template.
For a comprehensive description of the style elements affecting ODS graphics, see the
section for the style elements affecting template-based graphics in the Appendix for
ODS Style Elements of the SAS Output Delivery System: User's Guide.
Changing Box Plot Display
403

404
Chapter 18
•
Managing the Graph Appearance with Styles

Chapter 19
Adding Non-Data-Driven
Graphics Elements to a Graph
Overview: Adding Non-Data-Driven Graphics Elements to a Graph . . . . . . . . . . 405
Selecting the Drawing Space and Units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
How the Graphics Elements Are Anchored . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
Adding Graphics Elements to Your Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
The Draw Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
Adding Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
Adding Arrows and Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
Adding Geometric Shapes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411
Adding Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415
Overview: Adding Non-Data-Driven Graphics
Elements to a Graph
The Graph Template Language (GTL) provides draw statements that enable you to draw
additional graphics elements on your graphs that are independent of the graph data. The
types of elements that you can draw include the following:
•
text
•
arrows and lines
•
geometric shapes, such as ovals, rectangles, polylines, and polygons
•
images
You can use the draw statements to add annotations that describe the non-data aspects of
your graph. You can also use them to create custom features on your graph, such as a
broken axis, that are difficult to create by other means. You can draw the elements in
one of the following drawing spaces on your graph: the data area, the wall area, the
layout area, or the graph area. For more information about the drawing spaces, see
“Selecting the Drawing Space and Units” on page 406. You can specify the location of
each element using Cartesian coordinates, and you can specify the axis to which the
coordinates are scaled. You can also specify other attributes of the graphics element,
such as line color and pattern, text font, and so on.
In addition to the drawing space and attributes, you can also choose the layer on which
your graphics elements are drawn. Two layers are available that are relative to the graph:
front and back. The front layer appears in front of the graph. The back layer appears
behind the graph wall for graphs that have axes or behind the graph for graphs that do
not have axes. By default, the graphics elements are drawn on the front layer. You can
405

use the LAYER=BACK option on your draw statement to draw the elements on the back
layer.
For plots that have axes, if the graph wall area is filled (default), graphics elements that
are drawn on the back layer are obscured by the wall fill. To make the elements visible
in that case, include the WALLDISPLAY=NONE or WALLDISPLAY=(OUTLINE)
option in your layout statement. You can also use the TRANSPARENCY= option in the
plot statement to adjust the transparency of the graph in order to allow the graphics
elements underneath to show through.
For information about using the draw statements to add graphics elements to your graph,
see “Adding Graphics Elements to Your Graph” on page 408.
Selecting the Drawing Space and Units
When you draw graphics elements, you can specify the drawing space and the drawing
units in your draw statements. The drawing space is the area of the graph in which the
elements are drawn, which can be data, wall, layout, or graph. The drawing areas are
described in the following table.
Drawing
Space
Description
Example
Data
The area of the graph in which the data
is displayed. The data area is indicated
by the shaded area in the figure on the
right. The origin of the drawing space
X and Y coordinates, (0,0), is in the
lower left corner as shown.
Note: The data area does not apply to
graphs that do not have axes, such as
pie charts, that must be drawn in a
REGION layout.
Wall
The area of the graph that is bound by
the X and Y axes, including the
secondary axes, if it is used.
Note: The wall area does not apply to
graphs that do not have axes, such as
pie charts, that must be drawn in a
REGION layout.
406
Chapter 19
•
Adding Non-Data-Driven Graphics Elements to a Graph

Drawing
Space
Description
Example
Layout
The entire area of the layout container
that is the immediate parent container
of the draw statement. The figure on
the right shows the case where a
LAYOUT OVERLAY is the parent.
Graph
The area in which the entire graph is
displayed.
Note: In a multi-cell layout such as
GRIDDED or LATTICE, the
GRAPHPERCENT and
GRAPHPIXEL units span the entire
graph, which includes all of the cells in
the layout.
The drawing space and units are specified in a single value that is in the following
format:
<DrawingSpace><Units>
DrawingSpace can be DATA, WALL, LAYOUT, or GRAPH. For the WALL,
LAYOUT, and GRAPH areas, Units can be PIXEL or PERCENT. For the DATA
drawing space, Units can be PIXEL, PERCENT, or VALUE. PIXEL indicates that the
coordinates are expressed in pixels in the drawing space. PERCENT indicates that the
coordinates are expressed as a percentage of the drawing space. For example,
DATAPERCENT indicates that the coordinates are expressed as a percentage of the
DATA drawing space.
For the DATA drawing space, VALUE indicates that the coordinates are expressed as
values along the axis. When you specify the DATA drawing space, you can use the
XAXIS=, YAXIS=, X1AXIS=, Y1AXIS=, X2AXIS=, and Y2AXIS= options in the
draw statement, as applicable, to specify the axis to which the coordinates are scaled.
Note: A draw statement is discarded if the XAXIS=, YAXIS=, X1AXIS=, Y1AXIS=,
X2AXIS=, and Y2AXIS= options specify an axis that does not exist in the plot. It is
also discarded if the DRAWSPACE=, XSPACE=, YSPACE=, X1SPACE=,
Y1SPACE=, X2SPACE=, and Y2SPACE= options specify a drawing space that is
not valid for the draw statement's layout container.
You can specify a common drawing space and units for all of the X and Y coordinates.
You can also specify a different drawing space and units for the coordinates
individually. To specify a common space and units, use the DRAWSPACE= option on
each draw statement or in the BEGINGRAPH statement. When you use the
DRAWSPACE= option on a draw statement, the space and units that you specify are
applied to the coordinates for that statement only. This includes the X and Y coordinates
or the X1, Y1, X2, and Y2 coordinates. When you use the DRAWSPACE= option in the
BEGINGRAPH statement, the space and units that you specify are applied to all of the
draw statements within the BEGINGRAPH/ENDGRAPH block.
Selecting the Drawing Space and Units
407

To specify the drawing space and units for the X and Y coordinates individually, use the
XSPACE=, YSPACE=, X1SPACE=, Y1SPACE=, X2SPACE=, and Y2SPACE=
options, as applicable, on each draw statement.
Note: The XSPACE=, YSPACE=, X1SPACE=, Y1SPACE=, X2SPACE, and
Y2SPACE= options override the DRAWSPACE= option.
How the Graphics Elements Are Anchored
When you specify the X and Y coordinates for a graphics element, the element is drawn
from an anchor point that is placed in the drawing area at the X and Y coordinates that
you specify. For lines and arrows, the anchor point is the starting point of the line or
arrow, which is specified with the X1 and Y1 options on the draw statement. For
elements that have height and width, the anchor point can be one of the points shown in
the following figure.
By default, the anchor point is CENTER. You can use the ANCHOR= option on the
draw statements to change the anchor point of your graphics elements.
Note: When you select the X and Y coordinates and the anchor point, make sure that
when the graphics element is drawn, it does not extend beyond the boundaries of the
drawing area. Any part of the element that is outside of the drawing area is clipped.
Adding Graphics Elements to Your Graph
The Draw Statements
The following table lists the GTL draw statement or statement block that you can use to
draw each type of element.
To Draw this Type of Graphics Element
Use this GTL Statement or Block
Text
DRAWTEXT
An arrow
DRAWARROW
A line
DRAWLINE
408
Chapter 19
•
Adding Non-Data-Driven Graphics Elements to a Graph

To Draw this Type of Graphics Element
Use this GTL Statement or Block
An oval or circle
DRAWOVAL
A square or rectangle
DRAWRECTANGLE
A polyline
DRAW statements within a
BEGINPOLYLINE block
A polygon
DRAW statements within a
BEGINPOLYGON block
An image
DRAWIMAGE
This guide provides an overview of how to use these statements. For detailed
information about these statements, see SAS Graph Template Language: Reference.
Adding Text
Use a DRAWTEXT statement to add a text element to your graph. The basic syntax is as
follows:
DRAWTEXT <TEXTATTRS=(text-options)> "text" / X=x Y=y <options>
In your DRAWTEXT statement, specify in “text” the text that you want to appear in
your text element. You must enclose the text in quotation marks. If you want to change
any attributes of the text such as the font family, font size, or font color, include the
necessary options in the TEXTATTRS= option in the DRAWTEXT statement.
Note: The TEXTATTRS= option must be placed before “text” in the DRAWTEXT
statement.
Use the X= and Y= options in the DRAWTEXT statement to specify the coordinates
where you want to place the text. By default, the coordinate units are
GRAPHPERCENT, and the text element is anchored on its center point at the specified
coordinates. In options , you can include the DRAWSPACE= option or the XSPACE=
and YSPACE= options to specify different units, and the ANCHOR= option to change
the anchor point.
If you want text to wrap within a specified area, include the WIDTH= option in options .
The WIDTH= option specifies the maximum width of the text area in PERCENT units
by default. You can include the WIDTHUNIT= option in options to specify PIXEL or
DATA units instead. If you want to add a border around your text, include the
BORDER=TRUE and the BORDERATTRS= options in options .
Here is an example of a DRAWTEXT statement that adds a 120-pixel-wide block of text
with a gray border.
drawtext "A text string that contains more than one line of text" /
   x=100 y=70 drawspace=graphpixel
   width=120 widthunit=pixel 
   anchor=left
   border=true borderattrs=(color=gray pattern=1);
The X= and Y= options specifies the coordinates of the anchor point as (100, 70) in
GRAPHPIXEL units. The ANCHOR= option specifies that the text is to be anchored at
the LEFT anchor point as shown in the following figure. The WIDTH= and
WIDTHUNIT= options specify the maximum width of the text block as 120 pixels.
Adding Graphics Elements to Your Graph
409

Adding Arrows and Lines
Use a DRAWARROW or DRAWLINE statement to draw an arrow or line on your
graph. The basic syntax is as follows:
DRAWARROW X1=x1 Y1=y1 X2=x2 Y2=y2 / <options>
The syntax for the DRAWLINE statement is similar.
The X1=, Y1=, X2=, and Y2= options on the DRAWARROW and DRAWLINE
statements specify the coordinates for each endpoint of the arrow or line. By default, the
coordinate units are GRAPHPERCENT. You can include the DRAWSPACE= option, or
the X1SPACE=, Y1SPACE=, X2SPACE=, and Y2SPACE= options in options to
specify different units. If you specify DATAVALUE as the units and you want to scale
your arrow or line to the secondary axis, you must also include the X1AXIS=X2,
Y1AXIS=Y2, X2AXIS=X2, and Y2AXIS=Y2 options.
For both arrows and lines, include the LINEATTRS= option in options to specify the
line pattern, thickness, and color. For arrows, open arrowheads that point in the outward
direction are the default. To change the arrowhead shape, include the
ARROWHEADSHAPE= option and specify CLOSED, FILLED, or BARBED. You can
also include the ARROWHEADSCALE= option to scale the arrowhead based on the
thickness of the arrow line. The scaling factor is 1 by default. You can scale the
arrowhead from a minimum of 0.5 to a maximum of 2.
To change the arrowhead direction, include the ARROWHEADDIRECTION= option in
options and specify IN or BOTH. The IN direction positions the arrowhead on the (X1,
Y1) endpoint and points it inward toward the (X1, Y1) endpoint. The BOTH direction
includes both IN and OUT arrowheads forming a two-way arrow.
Here is an example of a DRAWARROW statement that adds a two-way dashed arrow.
drawarrow x1=60 y1=70 x2=190 y2=70 / drawspace=graphpixel
   lineattrs=(pattern=3 thickness=1px)
   arrowheadshape=barbed arrowheadscale=2 arrowheaddirection=both;
The arrow is drawn from endpoint (60, 70) to endpoint (190, 70) in GRAPHPIXEL units
as shown in the following figure.
410
Chapter 19
•
Adding Non-Data-Driven Graphics Elements to a Graph

The LINEATTRS= option specifies a dashed line (PATTERN=3) that is one pixel wide.
The ARROWHEADSHAPE= option specifies a barbed arrowhead, and the
ARROWHEADSCALE= option specifies a scale factor of 2 (maximum size). The
ARROWHEADDIRECTION= option specifies a two-way arrow.
To draw a line, in your DRAWLINE statement, use the X1=, Y1=, X2=, and Y2=
options to specify the location of the endpoints. Include the LINEATTRS= option in
options to specify the line pattern, color, and thickness. Here is the previous example
modified to draw a dashed line instead of a dashed arrow at the same coordinates.
drawline x1=60 y1=70 x2=190 y2=70 / drawspace=graphpixel
    lineattrs=(pattern=3 thickness=1px);
Adding Geometric Shapes
Ovals
Use a DRAWOVAL statement to add ovals to your graph. The basic syntax is as
follows:
DRAWOVAL X=x Y=y WIDTH=width HEIGHT=height / <options>
The X= and Y= options in the DRAWOVAL statement specify the coordinates of the
oval anchor point. By default, the coordinate units are GRAPHPERCENT, and the oval
is anchored on its center point. You can include the DRAWSPACE= option, or the
XSPACE= and YSPACE= options in options to specify different units. If you choose
DATAVALUE as the coordinate units and you want to scale the oval to the secondary
axis, you must also include the XAXIS=X2 and YAXIS=Y2 options. You can include
the ANCHOR= option to change the anchor point.
The WIDTH= and HEIGHT= options in the DRAWOVAL statement specify the
dimensions of the oval in PERCENT units by default. You can include the
WIDTHUNIT= and HEIGHTUNIT= options in options to specify PIXEL or DATA
units instead.
You can change other attributes of the oval, such as the fill color, the outline color, and
the outline pattern. Include the FILLATTRS= option in options to change the fill color,
and include the OUTLINEATTRS= option to change the outline color and pattern.
Here is an example of a DRAWOVAL statement that adds a 90 pixel wide by 110 pixel
high oval at coordinates (115, 110) in GRAPHPIXEL units.
drawoval x=115 y=110 width=90 height=110 / drawspace=graphpixel
   widthunit=pixel heightunit=pixel
   anchor=center
   display=all
   fillattrs=(color=lightgray)
   outlineattrs=(color=blue pattern=shortdash thickness=1px);
Adding Graphics Elements to Your Graph
411

The ANCHOR= option sets the oval anchor point to CENTER, which centers the oval at
coordinates (115, 110). The DISPLAY=ALL option displays the outline and fill. The
FILLATTRS= option specifies a light gray fill, and the OUTLINEATTRS= option
specifies a blue dashed outline.
Rectangles
Use a DRAWRECTANGLE statement to add rectangles to your graph. The basic syntax
is as follows:
DRAWRECTANGLE X=x Y=y WIDTH=width HEIGHT=height / <options>
The X= and Y= options in the DRAWRECTANGLE statement specify the coordinates
of the anchor point of the rectangle. By default, the coordinate units are
GRAPHPERCENT, and the rectangle is anchored on its center point. You can include
the DRAWSPACE= option, or the XSPACE= and YSPACE= options in options to
specify different units. If you choose DATAVALUE as the coordinate units and you
want to scale the rectangle to the secondary axis, you must also include the XAXIS=X2
and YAXIS=Y2 options. You can include the ANCHOR= option to change the anchor
point.
The WIDTH= and HEIGHT= options in the DRAWRECTANGLE statement specify the
dimensions of the rectangle in PERCENT units by default. You can include the
WIDTHUNIT= and HEIGHTUNIT= options in options to specify PIXEL or DATA
units instead.
You can change other attributes of the rectangle, such as the fill color, the outline color,
and the outline pattern. Include the FILLATTRS= option in options to change the fill
color, and include the OUTLINEATTRS= option to change the outline color and pattern.
Here is an example of a DRAWRECTANGLE statement that adds a 60% wide by 40%
high rectangle. In this example, percent refers to the percentage of the drawing area, at
coordinates (80,80) in GRAPHPIXEL units.
drawrectangle x=80 y=80 width=60 height=40 / drawspace=graphpixel
   widthunit=percent heightunit=percent
   anchor=bottomleft
   display=all
   fillattrs=(color=lightgray)
   outlineattrs=(color=blue pattern=shortdash thickness=1px);
412
Chapter 19
•
Adding Non-Data-Driven Graphics Elements to a Graph

The ANCHOR= option specifies the rectangle anchor point as BOTTOMLEFT, which
positions the lower left corner at coordinates (80, 80). The DISPLAY=ALL option
displays the outline and fill. The FILLATTRS= option specifies a light gray fill, and the
OUTLINEATTRS= option specifies a blue dashed outline.
Polylines
Use a BEGINPOLYLINE block to add a polyline to your graph. The basic syntax is as
follows:
BEGINPOLYLINE X=origin-x Y=origin-y / <options>;
   DRAW X=x1 Y=y1;
   DRAW X=x2 Y=y2;
   ...more DRAW statements...
   DRAW X=Xn Y=Yn;
ENDPOLYLINE;
Use a BEGINPOLYLINE statement to open the block. In the BEGINPOLYLINE
statement, use the X= and Y= options to specify the coordinates of the beginning point
of the polyline. By default, the coordinate units are GRAPHPERCENT. You can include
the DRAWSPACE= option, or the XSPACE= and YSPACE= options in options to
specify different units. If you specify the units as DATAVALUE and you want to scale
the polygon to the secondary axis, you must also include the XAXIS=X2 and
YAXIS=Y2 options. To change the line color, pattern, or thickness, include the
LINEATTRS= option.
Following the BEGINPOLYLINE statement are the individual DRAW statements. Each
DRAW statement draws a straight line from the previous point to the endpoint that is
specified in the DRAW statement's X= and Y= options. For the first DRAW statement,
the previous point is the starting point that is specified in the BEGINPOLYLINE
statement. For subsequent DRAW statements, the previous point is the endpoint that is
specified in the previous DRAW statement. Add a DRAW statement for each segment in
your polyline. You can add as many segments as you need. After the DRAW statements,
add an ENDPOLYLINE statement to close the block.
Here is an example that draws a five-segment polyline beginning at the coordinates (30,
150). The coordinates are specified in GRAPHPIXEL units.
beginpolyline x=30 y=150 / xspace=graphpixel yspace=graphpixel
   lineattrs=(thickness=1px);
   draw x=110 y=150; /* Draw S1 */
   draw x=145 y=250; /* Draw S2 */
   draw x=170 y=50;  /* Draw S3 */
   draw x=205 y=150; /* Draw S4 */
Adding Graphics Elements to Your Graph
413

   draw x=285 y=150; /* Draw S5 */
endpolyline;
The following figure shows how this polyline is drawn.
The X= and Y= options in the BEGINPOLYLINE statement specify the starting point of
the polyline, (30, 150), in GRAPHPIXEL units. The first DRAW statement draws
segment 1 (S1) between the starting point (30, 150) and endpoint (110, 150). The second
DRAW statement draws S2 between the endpoint (110, 150) of the first DRAW
statement to endpoint (145, 250). This pattern continues for the remaining DRAW
statements in the block. The ENDPOLYLINE statement closes the block.
Polygons
Use a BEGINPOLYGON block to add a polygon to your graph. The basic syntax is as
follows:
BEGINPOLYGON X=origin-x Y=origin-y / <options>;
   DRAW X=x1 Y=y1;
   DRAW X=x2 Y=y2;
   ...more DRAW statements...
   DRAW X=origin-x Y=origin-y;
ENDPOLYGON;
Use a BEGINPOLYGON statement to open the block. In the BEGINPOLYGON
statement, use the X= and Y= options to specify the coordinates of the beginning point
of the polygon. By default, the coordinate units are GRAPHPERCENT. You can include
the DRAWSPACE= option, or the XSPACE= and YSPACE= options in options to
specify different units. If you specify the units as DATAVALUE and you want to scale
the polygon to the secondary axis, you must also include the XAXIS=X2 and
YAXIS=Y2 options. To change the line color, pattern, or thickness, include the
LINEATTRS= option.
Following the BEGINPOLYGON statement are the DRAW statements. Each DRAW
statement draws a straight line from the previous point to the endpoint that is specified in
the DRAW statement's X= and Y= options. For the first DRAW statement, the previous
point is the starting point that is specified in the BEGINPOLYGON statement. For
subsequent DRAW statements, the previous point is the endpoint that is specified in the
previous DRAW statement. Add a DRAW statement for each side of your polygon. You
414
Chapter 19
•
Adding Non-Data-Driven Graphics Elements to a Graph

can add as many sides as you need. The last DRAW statement typically ends at the
starting point of the polygon in order to close the polygon.
Note: If the last DRAW statement does not end at the starting point of the polygon, a
line is drawn automatically that connects the endpoint of the last DRAW statement to
the starting point in order to close the polygon.
After the DRAW statements, add an ENDPOLYGON statement to close the block.
Here is an example that draws a four-sided polygon that begins at the coordinates (40,
100). All of the coordinates are specified in GRAPHPIXEL units.
beginpolygon x=40 y=100 / xspace=graphpixel yspace=graphpixel
   display=all fillattrs=(color=lightgray)
   outlineattrs=(thickness=1px pattern=shortdash color=blue);
   draw x=30  y=220; /* Draw S1 */
   draw x=160 y=200; /* Draw S2 */
   draw x=180 y=80;  /* Draw S3 */
   draw x=40  y=100; /* Draw S4 */
endpolygon;
The following figure shows how the polygon is drawn.
The BEGINPOLYGON statement X= and Y= options specify the starting point of the
polygon, (40, 100). The DISPLAY=ALL option displays the outline and fill. The
FILLATTRS= option specifies a light gray fill while the OUTLINEATTRS= option
specifies a dashed blue outline. The first DRAW statement draws side 1 (S1) between
the starting point (40, 100) and endpoint (30, 220). The second DRAW statement draws
S2 between endpoint (30, 220) of the first DRAW statement to endpoint (160, 200). This
pattern continues for the remaining DRAW statements. The last DRAW statement
connects endpoint (180, 80) to the starting point, (40, 100), which closes the polygon.
The ENDPOLYGON statement closes the block.
Adding Images
Use a DRAWIMAGE statement to place a JPG or PNG image on your graph.
Note: The DRAWIMAGE statement supports the JPG and PNG image formats only.
The basic syntax is as follows:
DRAWIMAGE "image-file.ext" / X=x Y=x <options>
Adding Graphics Elements to Your Graph
415

The image file is specified as image-file.ext, which is an absolute or relative path to the
image file on the file system. The path must be enclosed in quotation marks, and it must
include the image filename and file extension, such as image.jpg or image.png.
Note: The image file must be accessible on the file system. URL access is not
supported.
The X= and Y= options in the DRAWIMAGE statement specify the coordinates of the
image anchor point. By default, the coordinate units are GRAPHPERCENT, and the
image is anchored on its center point. You can include the DRAWSPACE= option, or
the XSPACE= and YSPACE= options in options to specify different units. If you choose
DATAVALUE as the units and you want to scale the image to the secondary axis, you
must also include the XAXIS=X2 and YAXIS=Y2 options. You can include the
ANCHOR= option to change the anchor point.
You can use the HEIGHT= and WIDTH= options in the DRAWIMAGE statement to
create a bounding box in which the image is drawn. The default units for the height and
width are PERCENT. You can include the SIZEUNIT= option in options to specify
PIXEL or DATA units instead. You can also include the SCALE= option to specify how
the image is scaled within the bounding box. By default, the image is scaled to fit the
box. You can also fit the image by height or width, or you can tile the image. If you want
to draw a border around your image, you can include the BORDER=Y and
BORDERATTRS= options.
Here is an example that adds the SAS logo at coordinates (70, 60) in GRAPHPIXEL
units. The image is anchored at the bottom left corner, and a black border is drawn
around the image.
drawimage ".\images\saslogo.png" / x=70 y=60 drawspace=graphpixel
   anchor=bottomleft 
   border=true borderattrs=(thickness=1px);
The following figure shows how the image is placed on the graph.
416
Chapter 19
•
Adding Non-Data-Driven Graphics Elements to a Graph

Chapter 20
Adding Data-Driven Annotations
to a Graph
Overview: Adding Data-Driven Annotations to a Graph . . . . . . . . . . . . . . . . . . . . 417
Creating an Annotation Data Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
Adding Observations for Text Annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
Adding Observations for Arrows and Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
Adding Observations for Polylines and Polygons . . . . . . . . . . . . . . . . . . . . . . . . . 421
Adding Observations for Ovals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423
Adding Observations for Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424
Adding Observations for Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425
Rendering a Graph with Annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426
Subsetting Annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
Example 1: Creating Custom Labels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
Example 2: Displaying Subsets of Annotations in Axis-Aligned Insets . . . . . . . . 431
Overview: Adding Data-Driven Annotations to a
Graph
The Graph Template Language (GTL) provides an annotation facility that enables you to
add graphics elements to a graph by using graphics instructions that are stored in a SAS
data set. It is similar to the SAS/GRAPH Annotate facility. Unlike adding graphics
elements using the GTL draw statements, the annotation facility enables you to separate
the annotation graphics instructions from your template code. To modify your
annotations, you can specify a different annotation data set. You do not have to modify
your template code.
Like the GTL draw statements, you can use the annotation facility to add the following
graphics elements to your graphs:
•
text
•
arrows and lines
•
geometric shapes, such as ovals, rectangles, polylines, and polygons
•
images
You can draw the annotations in one of the following drawing spaces on your graph: the
data area, the wall area, the layout area, or the graph area. For more information about
the drawing spaces, see “Selecting the Drawing Space and Units” on page 406. You can
417

specify the location of each annotation using Cartesian coordinates, and you can specify
the axis to which the coordinates are scaled. You can also specify other attributes of the
annotations, such as line color and pattern, text font, and so on.
In addition to the drawing space and attributes, you can also choose the layer on which
your annotations are drawn. Two layers are available that are relative to the graph: front
and back. The front layer appears on top of the graph. The back layer appears behind the
graph, behind the background areas such as the layout or legend background. By default,
the annotations are drawn on the front layer. You can specify the LAYER=BACK option
for your annotations to draw the them on the back layer.
For plots that have axes, if the plot wall area is filled (default) or the layout background
is opaque (OPAQUE=TRUE), annotations that are drawn on the back layer are obscured
by the plot wall fill or by the layout background. To make the annotations visible in
either case, include the WALLDISPLAY=NONE or WALLDISPLAY=(OUTLINE)
option in your layout statement, or specify OPAQUE=FALSE for the layout. You can
also use the TRANSPARENCY= option in the plot statement to adjust the transparency
of the plot in order to allow the graphics elements underneath to show through.
To use the GTL annotation facility, you must complete the following tasks:
•
create a SAS data set that contains your annotation instructions
•
include at least one ANNOTATE statement in your graph template
•
include the SGANNO= option in your SGRENDER statement to specify the
annotation data set by name
For more information about these requirements, see Chapter 14, “About The GTL
Annotation Facility,” in SAS Graph Template Language: Reference.
Creating an Annotation Data Set
Adding Observations for Text Annotations
To add a text annotation to your annotation data set, you must, at a minimum, specify
TEXT in the Function column and the annotation text in the Label column. You can also
use the TEXTCONT function to continue the text for a text annotation by using different
text attributes. You can use the ODS escape sequence to include superscripts, subscripts,
and Unicode characters in the label as you would in quoted strings for a text command.
For more information, see “Using Text Commands” in Chapter 10 of SAS Graph
Template Language: Reference.
By default, the text is located in the center of the graph area and is anchored at
CENTER. You can add the X1 and Y1 columns to specify numeric coordinates or the
XC1 and YC1 columns to specify character coordinates for a new location. You can add
the Anchor column to specify a different anchor. The width of the text box is determined
by the system. You can add the Width column and specify a new width. You can add
other columns to specify other text attributes such as font, size, color, and so on. For
more information, see “TEXT Function” in SAS ODS Graphics: Procedures Guide and
“TEXTCONT Function” in SAS ODS Graphics: Procedures Guide.
Here is an example of a DATA step that creates three observations for a text annotation
that contains normal text, blue text, and red text that expresses a simple equation. The
equation contains a Unicode character and a superscript character.
data textdata;
   length function $9 label $60;
418
Chapter 20
•
Adding Data-Driven Annotations to a Graph

   function="text"; 
   drawspace="graphpixel"; x1=100; y1=70; 
   width=190; widthunit="pixel"; anchor="left"; 
   border="true"; linecolor="gray"; linepattern="solid";
   label="A text string that contains";
   output; /* Write normal-text observation. */
   function="textcont";
   textcolor="blue";
   label=" rich text with Unicode and superscript characters:";
   output; /* Write blue-text observation. */
   textcolor="red";
   label=" A = (*ESC*){unicode pi}R(*ESC*){sup 2}";
   output; /* Write red equation observation. */
run;
Here is a listing of TEXTDATA.
Obs function                         label                         drawspace
 1  text      A text string that contains normal text and          graphpixel
 2  textcont   rich text with Unicode and superscript characters:  graphpixel
 3  textcont   A = (*ESC*){unicode pi}R(*ESC*){sup '2'}            graphpixel
Obs  x1 y1 width widthunit anchor border linecolor linepattern textcolor
 1  100 70  190    pixel    left   true    gray       solid
 2  100 70  190    pixel    left   true    gray       solid      blue
 3  100 70  190    pixel    left   true    gray       solid      blue
In the first observation, the Function column specifies TEXT for a text annotation using
the default text attributes. The DrawSpace column specifies that all coordinates are
expressed in graph-area pixels. The X1 and Y1 columns specify the location as 100 on
the X axis and 70 on the Y axis. The Width, WidthUnit, and Anchor columns specify a
190-pixel-wide text box that is anchored on the left side. The Border, LineColor, and
LinePattern columns specify a solid gray border around the text box. The Label column
specifies the normal-text portion of the text for this annotation.
In the second observation, the Function column specifies the TEXTCONT function in
order to continue the text for this annotation. The TextColor column specifies blue for
the text color. The Label column specifies the text for this part of the annotation text. In
the third observation, the Function column remains TEXTCONT. The Label column
uses the ODS escape sequence, which is (*ESC*), with {UNICODE} and {SUP} to
specify the following equation:
A = πR 2
Here is how this annotation is placed in a graph.
Creating an Annotation Data Set
419

Adding Observations for Arrows and Lines
To add an arrow or line to your annotation data set, you must specify, at a minimum,
ARROW or LINE in the Function column, the coordinates of the arrow or line starting
point, and the coordinates of the arrow or line ending point. For an arrow, by default, the
arrowhead shape is OPEN and the arrow direction is OUT. You can add the Shape and
Direction columns to your observation to specify different values. You can add other
columns to specify other attributes of the arrow such as arrowhead scale, line color, line
pattern, line thickness, and so on. For information about other columns that you can add,
see “ARROW Function” in SAS ODS Graphics: Procedures Guide.
Here is an example of a DATA step that creates an observation for an arrow annotation.
data arrowdata;
   function="arrow";
   drawspace="graphpixel";
   x1=60; y1=70; x2=190; y2=70;
   shape="barbed"; scale=2; direction="both";
   linepattern="shortdash"; linethickness=1;
run;
Here is a listing of the observation.
Obs  function  drawspace   x1  y1   x2  y2  shape   scale
 1    arrow    graphpixel  60  70  190  70  barbed    2
Obs  direction    linepattern    linethickness
 1     both        shortdash           1
In this observation, the Function column specifies ARROW for an arrow annotation. The
DrawSpace column specifies that all coordinates are expressed in graph-area pixels. The
X1 and Y1 columns specify the arrow starting location as 60 on the X axis and 70 on the
Y axis. The X2 and Y2 columns specify the arrow ending location as 190 on the X axis
and 70 on the Y axis. The Shape and Scale columns specify the shape and size of the
arrowheads. The Direction column specifies the direction as BOTH. The LinePattern and
LineThickness columns specify the arrow line as a 2-pixel-wide short-dashed line.
Here is how this annotation is placed in a graph.
An observation for a line is similar to that of an arrow. At a minimum, you must specify
LINE in the Function column, the line starting coordinates, and the line ending
coordinates. You can add other columns to specify different attributes of the line, such as
color, pattern, and thickness. For information about other columns that you can add, see
“LINE Function” in SAS ODS Graphics: Procedures Guide.
420
Chapter 20
•
Adding Data-Driven Annotations to a Graph

Here is the previous arrow observation modified to draw a dashed line instead of an
arrow.
data linedata;
   function="line";
   drawspace="graphpixel";
   x1=60; y1=70; x2=190; y2=70;
   linepattern="shortdash"; linethickness=1;
run;
Here is a listing of the observation.
Obs function drawspace  x1 y1  x2 y2 linepattern linethickness
 1    line   graphpixel 60 70 190 70  shortdash        1
Adding Observations for Polylines and Polygons
Multiple observations are required to construct a polyline or polygon. The first
observation establishes the starting point of the polyline or polygon. The subsequent
observations specify the individual segments of the polyline or polygon. A polyline must
have at least one segment. A polygon is similar to a polyline except that the segments of
the polygon must form a closed shape. To specify the starting point, you must specify, at
a minimum, POLYLINE or POLYGON in the Function column, and the coordinates of
the polyline or polygon starting point. You can add other columns to specify attributes of
the lines, such as color, pattern, and thickness. For information about other columns that
you can add, see “POLYLINE Function” in SAS ODS Graphics: Procedures Guide and
“POLYGON Function” in SAS ODS Graphics: Procedures Guide.
For each segment of your polyline or polygon, you must add one observation for each
segment. Each segment observation specifies POLYCONT in the Function column and
the ending coordinates for that segment. For the first segment, this observation draws a
line from the beginning point to the ending point that is specified in the first segment
observation. For the second and subsequent segments, the observation draws a line from
the ending point of the previous segment to the ending point that is specified in the
current segment observation.
Here is an example of a DATA step that creates an observation for a five-segment
polyline annotation.
data polylinedata;
   function="polyline";
   drawspace="graphpixel";
   x1=30; y1=150;  /* Begin polyline */
   output;
   function="polycont";
   x1=110; y1=150; /* Draw Segment 1 */
   output;
   x1=145; y1=250; /* Draw Segment 2 */
   output;
   x1=170; y1=50;  /* Draw Segment 3 */
   output;
   x1=205; y1=150; /* Draw Segment 4 */
   output;
   x1=285; y1=150; /* Draw Segment 5 */
   output;
run;
Creating an Annotation Data Set
421

Here is a listing of the observation.
Obs    function    drawspace      x1     y1
 1     polyline    graphpixel     30    150
 2     polycont    graphpixel    110    150
 3     polycont    graphpixel    145    250
 4     polycont    graphpixel    170     50
 5     polycont    graphpixel    205    150
 6     polycont    graphpixel    285    150
Notice that the first observation is the POLYLINE function followed by one
POLYCONT function observation for each of the five segments. In all of the
observations, the DrawSpace column specifies that the coordinates are expressed in
graph-area pixels. In the first observation (POLYLINE), the X1 and Y1 columns specify
the coordinates of the polyline starting point. In the subsequent observations, the X1 and
Y1 columns specify the ending point for each segment.
Here is how this polyline is placed in a graph and how each segment is drawn.
The first segment (S1) is drawn from the polyline starting point to the ending point that
is specified in the first segment observation. The second segment (S2) is drawn from the
ending point of S1 to the ending point that is specified in the S2 observation. This
pattern repeats for the remaining segments.
A polygon is similar to a polyline except that the segments must form a closed shape. If
the segments that you specify result in an open shape, a segment is drawn automatically
from the ending point of the last segment back to the beginning point of the polygon in
order to close the shape.
Here is an example of a DATA step that creates an observation for a four-segment
polyline annotation.
data polygondata;
   length function $8;
   function="polygon";
   drawspace="graphpixel";
   x1=40; y1=100;  /* Begin polygon */
   display="all"; fillcolor="lightgray";
   linecolor="blue"; linepattern="shortdash";
422
Chapter 20
•
Adding Data-Driven Annotations to a Graph

   output;
   function="polycont";
   x1=30; y1=220;  /* Draw Segment 1 */
   output;
   x1=160; y1=200; /* Draw Segment 2 */
   output;
   x1=180; y1=80;  /* Draw Segment 3 */
   output;
   x1=40; y1=100;  /* Draw Segment 4 */
   output;
run;
Here is a listing of the observation.
Obs  function  drawspace    x1   y1  display  fillcolor  linecolor  linepattern
 1   polygon   graphpixel   40  100    all    lightgray    blue      shortdash
 2   polycont  graphpixel   30  220    all    lightgray    blue      shortdash
 3   polycont  graphpixel  160  200    all    lightgray    blue      shortdash
 4   polycont  graphpixel  180   80    all    lightgray    blue      shortdash
 5   polycont  graphpixel   40  100    all    lightgray    blue      shortdash
Because a polygon is a closed shape, you can add the FillColor column and specify a fill
color for the polygon. By default, only the polygon outline is displayed. To display the
fill, you must add the Display column and specify ALL or FILLED. For more
information about these columns and other columns that you can add, see “POLYGON
Function” in SAS ODS Graphics: Procedures Guide.
Here is how this polygon is placed in a graph and how each segment is drawn.
T I P
In this example, you can omit the observation for the fourth segment (S4). The
fourth segment is drawn automatically to close the shape.
Adding Observations for Ovals
To add an oval to your annotation data set, you must specify, at a minimum, OVAL in
the Function column, the coordinates of the center point, the width, and the height. By
default, the height and width are expressed in PERCENT units. To use different units
such as PIXEL, you can add the HeightUnit and WidthUnit columns to specify the new
Creating an Annotation Data Set
423

units. You can specify other attributes such as the line color, line pattern, line thickness,
and so on. For information about other columns that you can add, see “OVAL Function”
in SAS ODS Graphics: Procedures Guide.
Here is an example of a DATA step that creates an observation for a 90-pixel by 110-
pixel oval annotation.
data ovaldata;
   function="oval";
   drawspace="graphpixel";
   x1=115; y1=110;
   width=90; widthunit="pixel"; height=110; heightunit="pixel";
   display="all"; fillcolor="lightgray";
   linecolor="blue"; linepattern="shortdash";
run;
Here is a listing of the observation.
Obs    function    drawspace      x1     y1    width    widthunit    height
 1       oval      graphpixel    115    110      90       pixel        110
Obs    heightunit    display    fillcolor    linecolor    linepattern
 1       pixel         all      lightgray      blue        shortdash
In this observation, the Function column specifies OVAL for an oval annotation. The
DrawSpace column specifies that all coordinates are expressed in graph-area pixels. The
X1 and Y1 columns specify the oval center location as 115 on the X axis and 110 on the
Y axis. The Width and WidthUnit columns specify a width of 90 pixels, and the Height
and HeightUnit columns specify a height of 110 pixels. The FillColor column specifies a
fill color for the oval. By default, only the oval outline is displayed. The Display column
specifies ALL, which displays both the outline and the fill. The LineColor and
LinePattern columns specify a blue short-dashed outline.
Here is how this annotation is placed in a graph.
Adding Observations for Rectangles
To add a rectangle to your annotation data set, you must specify, at a minimum,
RECTANGLE in the Function column, the coordinates of the anchor point, the width,
and the height. By default, the height and width are expressed in PERCENT units. To
424
Chapter 20
•
Adding Data-Driven Annotations to a Graph

use different units such as PIXEL, you can add the HeightUnit and WidthUnit columns
to specify the new units. You can specify other attributes such as the anchor, line color,
line pattern, line thickness, and so on. For information about other columns that you can
add, see “RECTANGLE Function” in SAS ODS Graphics: Procedures Guide.
Here is an example of a DATA step that creates an observation for 60%-by-40%
rectangle annotation.
data rectangledata;
   function="rectangle";
   drawspace="graphpixel";
   x1=80; y1=80; width=60; height=40; anchor="bottomleft";
   fillcolor="lightgray"; display="all";
   linecolor="blue"; linepattern="shortdash";
run;
Here is a listing of the observation.
Obs    function     drawspace     x1    y1    width    height      anchor
 1     rectangle    graphpixel    80    80      60       40      bottomleft
Obs    fillcolor    display    linecolor    linepattern
 1     lightgray      all        blue        shortdash
In this observation, the Function column specifies RECTANGLE for a rectangle
annotation. The DrawSpace column specifies that all coordinates are expressed in graph-
area pixels. The X1 and Y1 columns specify the oval center location as 80 on the X axis
and 80 on the Y axis. The Width column specifies a width of 60% (default unit), and the
Height column specifies a height of 40%. The Anchor column specifies the anchor at the
bottom left corner of the rectangle. The FillColor column specifies a fill color for the
rectangle. By default, only the rectangle outline is displayed. The Display column
specifies ALL, which displays both the outline and the fill. The LineColor and
LinePattern columns specify a blue short-dashed outline.
Here is how this annotation is placed in a graph.
Adding Observations for Images
To add an image to your annotation data set, you must specify, at a minimum, IMAGE
in the Function column and the path to the file that contains the image in the Image
Creating an Annotation Data Set
425

column. By default, the image is located in the center of the graph area and is anchored
at CENTER. You can add the X1 and Y1 columns to specify numeric coordinates or the
XC1 and YC1 columns to specify character coordinates for a new location. You can add
the Anchor column to specify a different anchor. You can add other columns to specify
other attributes such as a border, the image height, width, scale, and so on. For
information about the columns that you can add, see “IMAGE Function” in SAS ODS
Graphics: Procedures Guide.
Here is an example of a DATA step that creates an observation for a SAS logo.
data imagedata;
   function="image";
   drawspace="graphpixel";
   x1=70; y1=60;
   anchor="bottomleft";
   border="true";
   image=".\saslogo.png";
run;
Here is a listing of the observation.
Obs   function   drawspace    x1   y1     anchor     border       image
 1     image     graphpixel   70   60   bottomleft    true    .\saslogo.png
In this observation, the Function column specifies IMAGE for an image annotation. The
DrawSpace column specifies that all coordinates are expressed in graph-area pixels. The
X1 and Y1 columns specify the location as 70 on the X axis and 60 on the Y axis. The
Anchor column specifies the anchor at the bottom left corner. The Border column
specifies a border around the image. The Image column specifies the relative path to the
image file.
Note: The image file must be accessible on the file system. URL access is not
supported.
Here is how this annotation is placed in a graph.
Rendering a Graph with Annotations
In order to render a graph with annotations, you must include at least one ANNOTATE
statement in the graph template. The ANNOTATE statement causes the annotations to
be read from the annotation data set and drawn on the graph. You can place an
ANNOTATE statement anywhere in the template. However, the drawing spaces that are
specified for the annotations must be valid in the context of the ANNOTATE statement
location. The order in which the annotations are drawn with respect to the graph
elements depends on the LAYER option for the annotations. By default, annotations are
426
Chapter 20
•
Adding Data-Driven Annotations to a Graph

always drawn on the front layer. In that case, the annotations are drawn after the graph
elements are drawn and appear on top of the plots and other graph elements. If you
specify BACK for the annotation layer, the annotations are drawn before the graph
elements are drawn and appear behind the plots and other graph elements.
When you render your graph, you must include the SGANNO= option in the
SGRENDER statement to specify the name of your annotation data set.For examples,
see “Example 1: Creating Custom Labels” on page 427 and “Example 2: Displaying
Subsets of Annotations in Axis-Aligned Insets” on page 431.
Subsetting Annotations
By default, the ANNOTATE statement draws all of the annotations that are stored in the
annotation data set. You can use the ANNOTATE statement ID= option to display a
subset of these annotations. Subsetting your annotations enables you to use one
annotation data set with multiple plots. To use the ID= option, the observations for the
annotations must contain an ID column. The ID column is a character column that stores
a unique character value that identifies the subset to which each annotation belongs.
When the ID="identifier" option is used in the ANNOTATE statement, only the
annotations with ID column values that match the identifier value are displayed. The
remaining annotations are ignored. For more information about the ANNOTATE
statement ID= option, see “ANNOTATE Statement” in SAS Graph Template Language:
Reference. For an example, see “Example 2: Displaying Subsets of Annotations in Axis-
Aligned Insets” on page 431.
Examples
Example 1: Creating Custom Labels
Overview
This example demonstrates how to use the Graphic Template Language (GTL)
annotation facility to create custom category labels for a horizontal bar chart. The bar
chart plots the average highway mileage (response) by vehicle type (category).
Ordinarily, the category labels for a horizontal bar chart appear on the Y axis to the left
of each bar. This example demonstrates how to print the labels on the left end of each
bar instead. This example also uses the sheen data skin on the bars. Because of the
reflection on the sheen data skin, the labels are raised slightly to center the label in the
reflection on each bar. Finally, the label text color uses the contrast color.
Example 1: Creating Custom Labels
427

The following figure shows the final graph.
Program
/* Summarize the highway mileage data in SASHELP.CARS. */
proc summary data=sashelp.cars nway;
   class type;
   var mpg_highway;
   output out=mileage mean(mpg_highway) = mpg_highway;
run;
/* Create the annotation data set. */
data anno;
   retain function "text" drawspace "datavalue"
      textfont "Arial" textweight "bold" 
      textcolor "GraphData1:contrastColor" 
      width 100 widthunit "pixel"
      anchor "left" x1 2
      discreteoffset 0.1;
   set mileage(keep=type);
   rename type=yc1;
   length label $12;
   label=type;
run;
/* Create the template. */
proc template;
   define statgraph barchart;
      begingraph;
         entrytitle "Average Highway Mileage by Vehicle Type";
         layout overlay / 
            yaxisopts=(display=(label)) 
            xaxisopts=(label="Average Highway MPG" offsetmax=0.05);
            barchartparm category=type response=mpg_highway /
               orient=horizontal dataskin=sheen;
            annotate;
         endlayout;
428
Chapter 20
•
Adding Data-Driven Annotations to a Graph

     endgraph;
  end;
/* Render the graph with the ANNO annotation data set */
proc sgrender data=mileage template=barchart sganno=anno;
run;
Program Description
Summarize the highway mileage data in Sashelp.Cars. Because a label is needed for
each unique value of vehicle type, the data in Sashelp.Cars is first summarized for the
Mpg_Highway column using the Type column as the class variable. This step generates
a data set that contains one observation for each unique value of Type. See “Listing of
the Mileage Data Set” on page 430.
/* Summarize the highway mileage data in SASHELP.CARS. */
proc summary data=sashelp.cars nway;
   class type;
   var mpg_highway;
   output out=mileage mean(mpg_highway) = mpg_highway;
run;
Create the annotation data set. The Mileage data set is used to create the annotation
data set Anno. The DATA step in the Anno data set reads the observations from the
Mileage data set. The Type column is used to set the Label column and is then renamed
to YC1. The remaining columns from the Mileage data set are then dropped. The X1
column is added and set to 2 in order to position the labels on the left end of each bar.
The DiscreteOffset column is added and set to 0.1 in order to center the labels in the
sheen data skin reflection on each bar. Additional columns are added to specify other
attributes of the labels. See “Listing of the Anno Data Set” on page 430.
/* Create the annotation data set. */
data anno;
   retain function "text" drawspace "datavalue"
      textfont "Arial" textweight "bold" 
      textcolor "GraphData1:contrastColor" 
      width 100 widthunit "pixel"
      anchor "left" x1 2
      discreteoffset 0.1;
   set mileage(keep=type);
   rename type=yc1;
   length label $12;
   label=type;
run;
Create the graph template and include an ANNOTATE statement. The
BARCHARTPARM statement is used to generate the horizontal bar chart from the
summarized mileage data. Because the annotation drawing space is DATAVALUE, the
ANNOTATE statement is placed in the BARCHARTPARM statement layout block in
the template. In this location, the DATAVALUE values are in the context of the
BARCHARTPARM data.
/* Create the template. */
proc template;
   define statgraph barchart;
      begingraph;
         entrytitle "Average Highway Mileage by Vehicle Type";
Example 1: Creating Custom Labels
429

         layout overlay / 
            yaxisopts=(display=(label)) 
            xaxisopts=(label="Average Highway MPG" offsetmax=0.05);
            barchartparm category=type response=mpg_highway /
               orient=horizontal dataskin=sheen;
            annotate;
         endlayout;
     endgraph;
  end;
Render the graph with the annotations. To render the graph with the annotations, the
SGANNO=ANNO option is included in the SGRENDER statement.
/* Render the graph with the ANNO annotation data set */
proc sgrender data=mileage template=barchart sganno=anno;
run;
Listing of the Mileage Data Set
Here is a listing of the Mileage data set.
                                                   mpg_
Obs    Type      _TYPE_    _FREQ_    mpg_city    highway
 1     Hybrid       1          3      55.0000    56.0000
 2     SUV          1         60      16.1000    20.5000
 3     Sedan        1        262      21.0840    28.6298
 4     Sports       1         49      18.4082    25.4898
 5     Truck        1         24      16.5000    21.0000
 6     Wagon        1         30      21.1000    27.9000
Listing of the Anno Data Set
Here is a listing of the Anno data set.
Obs  function   drawspace   textfont   textweight          textcolor
 1     text     datavalue    Arial        bold      GraphData1:contrastColor
 2     text     datavalue    Arial        bold      GraphData1:contrastColor
 3     text     datavalue    Arial        bold      GraphData1:contrastColor
 4     text     datavalue    Arial        bold      GraphData1:contrastColor
 5     text     datavalue    Arial        bold      GraphData1:contrastColor
 6     text     datavalue    Arial        bold      GraphData1:contrastColor
Obs  discreteoffset    width    widthunit    anchor    x1    yc1       label
 1         0.1          100       pixel       left      2    Hybrid    Hybrid
 2         0.1          100       pixel       left      2    SUV       SUV
 3         0.1          100       pixel       left      2    Sedan     Sedan
 4         0.1          100       pixel       left      2    Sports    Sports
 5         0.1          100       pixel       left      2    Truck     Truck
 6         0.1          100       pixel       left      2    Wagon     Wagon
430
Chapter 20
•
Adding Data-Driven Annotations to a Graph

Example 2: Displaying Subsets of Annotations in Axis-Aligned Insets
Overview
This example shows you how to subset annotations in an annotation data set and how to
display specific subsets of annotations in a graph. It also shows you how to create axis-
aligned insets outside of the plot wall area by using the GTL annotation facility. This
example creates a vertical bar chart of vehicle type and average curb weight by origin.
Above the bar chart, axis-aligned insets display the average city and highway mileages
for each vehicle type. The dynamic variable _BYVAL_ is used to specify the vehicle
origin.
The following figure shows the first graph.
The annotation data for this example requires a subset of data for each vehicle type. One
additional subset is required for the inset labels.
Program
/* Sort SASHELP.CARS by ORIGIN */
proc sort data=sashelp.cars out=cars;
   by origin;
run;
/* Summarize the mileage data by ORIGIN */
proc summary data=cars nway mean;
   class type;
   by origin;
   var mpg_city mpg_highway;
   output out=mileage mean(mpg_city mpg_highway) = mpg_city mpg_highway;
Example 2: Displaying Subsets of Annotations in Axis-Aligned Insets
431

run;
/* Create the city/highway mileage annotations */
data anno;
   toprowpos=80; /* Y position of insets (GRAPHPERCENT). */
   labelpos=16;  /* X position of inset labels (GRAPHPERCENT) */
   length ID function $10 label $12 border $5
      anchor justify $12 x1space y1space $15 xc1 $8;
   retain function "text" border "true" width 90
      y1space "graphpercent" x1space "datavalue";
   /* Base on MILEAGE data. */
   set mileage(keep=origin type mpg_highway mpg_city);
   /* On the first data step iteration, create observations 
      for the inset labels. */
   if (_N_ = 1) then do;
      x1=labelpos; x1space="graphpercent";y1=toprowpos+1;
      ID="ROWLABELS"; /* Inset label subset. */
      label="Avg. MPG"; border="false"; anchor="right"; justify="left";
      output;
      y1=toprowpos-3;label="(City/Hwy)";; 
      output;
      x1=.; /* Clear X1 so that XC1 can be used later. */
   end;
   /* Create observations for the city and highway mileage values. */
   ID=origin; /* Origin subset. */
   function="text"; x1space="datavalue"; xc1=type; y1=toprowpos;
   label=put(round(mpg_city), F2.0) || " / " || 
      put(round(mpg_highway), F2.0);
   border="true"; anchor="center"; justify="center";
   output;
   /* Drop the unneeded variables. */
   drop origin mpg_city mpg_highway toprowpos type labelpos;
run;
proc template;
   define statgraph barchart;
      dynamic _BYVAL_ _BYLINE_;
      begingraph / designwidth=450 designheight=360;
         entrytitle "Average Curb Weight by Vehicle Type";
         entrytitle "(" _BYLINE_ ")";
         layout overlay;
            layout overlay / pad=(top=40)
               yaxisopts=(label="Average Curb Weight (LBS)" offsetmax=0.2)
               xaxisopts=(label="Vehicle Type"
                  discreteopts=(colorbands=even 
                     colorbandattrs=(transparency=0.6)));
               /* Generate the mileage bar chart */
               barchart x=type y=weight / stat=mean 
                  dataskin=gloss;
               /* Draw the mileage annotations for this origin */
               annotate / ID="ROWLABELS"; /* Draw the inset labels. */
               annotate / ID=_BYVAL_;     /* Draw the value insets. */
432
Chapter 20
•
Adding Data-Driven Annotations to a Graph

            endlayout;
         endlayout;
      endgraph;
   end;
run;
/* Suppress the default BY line. */
options nobyline;
/* Render the graph by ORIGIN with the ANNO annotation data set */
proc sgrender data=cars template=barchart sganno=anno;
   by origin;
run;
/* Restore the default BY line. */
options byline;
Program Description
Summarize the mileage data in Sashelp.Cars. The data in Sashelp.Cars is first sorted
by Origin. Next, the sorted data is summarized for the Mpg_City and Mpg_Highway
columns by Origin, using Type as the class variable. This step generates a data set that
contains one observation for each unique value of Type and Origin. See “Listing of the
Mileage Data Set” on page 435.
/* Sort SASHELP.CARS by ORIGIN */
proc sort data=sashelp.cars out=cars;
   by origin;
run;
/* Summarize the mileage data by ORIGIN */
proc summary data=cars nway mean;
   class type;
   by origin;
   var mpg_city mpg_highway;
   output out=mileage mean(mpg_city mpg_highway) = mpg_city mpg_highway;
run;
Begin the DATA step for the annotation data set. Columns for the inset label X and Y
positions and for the inset text attributes are created. The data in the Mileage data set is
read in.
/* Create the city/highway mileage annotations */
data anno;
   toprowpos=80; /* Y position of insets (GRAPHPERCENT). */
   labelpos=16;  /* X position of inset labels (GRAPHPERCENT) */
   length ID function $10 label $12 border $5
      anchor justify $12 x1space y1space $15 xc1 $8;
   retain function "text" border "true" width 90
      y1space "graphpercent" x1space "datavalue";
   /* Base on MILEAGE data. */
   set mileage(keep=origin type mpg_highway mpg_city);
Create observations for the inset labels. Observations that draw the inset labels are
created on the first iteration of the DATA step to prevent duplication. The ID column for
these observations is set to ROWLABELS. The labels are positioned by
Example 2: Displaying Subsets of Annotations in Axis-Aligned Insets
433

GRAPHPERCENT values on the X axis by using the X1 column. After the observations
are written, the X1 column is cleared so that the XC1 column can be used later. (If both
the numeric and character columns are specified for a coordinate value, the numeric
column takes precedence, and the character column is ignored.)
   /* On the first data step iteration, create observations 
      for the inset labels. */
   if (_N_ = 1) then do;
      x1=labelpos; x1space="graphpercent";y1=toprowpos+1;
      ID="ROWLABELS"; /* Inset label subset. */
      label="Avg. MPG"; border="false"; anchor="right"; justify="left";
      output;
      y1=toprowpos-3;label="(City/Hwy)";; 
      output;
      x1=.; /* Clear X1 so that XC1 can be used later. */
   end;
Create observations for the city and highway mileage values. For each TYPE value,
observations that draw the city and highway mileage values are created. The ID column
for these observations is set to the TYPE value.
   /* Create observations for the city and highway mileage values. */
   ID=origin; /* Origin subset. */
   function="text"; x1space="datavalue"; xc1=type; y1=toprowpos;
   label=put(round(mpg_city), F2.0) || " / " || 
      put(round(mpg_highway), F2.0);
   border="true"; anchor="center"; justify="center";
   output;
   /* Drop the unneeded variables. */
   drop origin mpg_city mpg_highway toprowpos type labelpos;
run;
Create the graph template and include the ANNOTATE statements. Padding is added
to the top of the plot layout to reserve space for the mileage insets. The BARCHART
statement generates the vertical bar chart from the data in Sashelp.Cars. Because the
XSPACE for the annotations is DATAVALUE, the ANNOTATE statements are placed
in the layout block that contains the BARCHART statement. The first ANNOTATE
statement draws the inset table row labels. The second ANNOTATE statement draws the
mileage values for the origin that is specified by the _BYVAL_ dynamic variable. The
_BYLINE_ dynamic variable is used to display the BY-variable value inside the graph.
(The default BY line is suppressed in the next step.)
proc template;
   define statgraph barchart;
      dynamic _BYVAL_ _BYLINE_;
      begingraph / designwidth=450 designheight=360;
         entrytitle "Average Curb Weight by Vehicle Type";
         entrytitle "(" _BYLINE_ ")";
         layout overlay;
            layout overlay / pad=(top=40)
               yaxisopts=(label="Average Curb Weight (LBS)" offsetmax=0.2)
               xaxisopts=(label="Vehicle Type"
                  discreteopts=(colorbands=even 
                     colorbandattrs=(transparency=0.6)));
               /* Generate the mileage bar chart */
434
Chapter 20
•
Adding Data-Driven Annotations to a Graph

               barchart x=type y=weight / stat=mean 
                  dataskin=gloss;
               /* Draw the mileage annotations for this origin */
               annotate / ID="ROWLABELS"; /* Draw the inset labels. */
               annotate / ID=_BYVAL_;     /* Draw the value insets. */
            endlayout;
         endlayout;
      endgraph;
   end;
run;
Suppress the default BY line.
/* Suppress the default BY line. */
options nobyline;
Render the graph with the annotations. The SGANNO=ANNO option is included in
the SGRENDER statement. The BY statement is used to generate a graph for each value
of ORIGIN. Because the data must be sorted by the BY group variable, the Cars data set
is used, which is already sorted by ORIGIN.
/* Render the graph by ORIGIN with the ANNO annotation data set */
proc sgrender data=cars template=barchart sganno=anno;
   by origin;
run;
Restore the default BY line.
/* Restore the default BY line. */
options byline;
Listing of the Mileage Data Set
Here is a listing of the Mileage data set.
                                                             mpg_
Obs    Origin    Type      _TYPE_    _FREQ_    mpg_city    highway
  1    Asia      Hybrid       1         3       55.0000    56.0000
  2    Asia      SUV          1        25       17.3200    21.6800
  3    Asia      Sedan        1        94       22.8404    29.9681
  4    Asia      Sports       1        17       20.2353    26.6471
  5    Asia      Truck        1         8       17.8750    22.0000
  6    Asia      Wagon        1        11       22.3636    28.1818
  7    Europe    SUV          1        10       14.5000    18.7000
  8    Europe    Sedan        1        78       19.5128    27.1154
  9    Europe    Sports       1        23       17.6522    25.1304
 10    Europe    Wagon        1        12       19.2500    26.5833
 11    USA       SUV          1        25       15.5200    20.0400
 12    USA       Sedan        1        90       20.6111    28.5444
 13    USA       Sports       1         9       16.8889    24.2222
 14    USA       Truck        1        16       15.8125    20.5000
 15    USA       Wagon        1         7       22.2857    29.7143
Example 2: Displaying Subsets of Annotations in Axis-Aligned Insets
435

Partial Listing of the Anno Data Set
Here is a partial listing of the Anno data set.
Obs    ID           function      label      border    anchor    justify
  1    ROWLABELS      text      Avg. MPG      false     right     left
  2    ROWLABELS      text      (City/Hwy)    false     right     left
  3    Asia           text      55 / 56       true      center    center
  4    Asia           text      17 / 22       true      center    center
  5    Asia           text      23 / 30       true      center    center
  6    Asia           text      20 / 27       true      center    center
  7    Asia           text      18 / 22       true      center    center
  8    Asia           text      22 / 28       true      center    center
  9    Europe         text      15 / 19       true      center    center
 10    Europe         text      20 / 27       true      center    center
 …
Obs      x1space         y1space       xc1       width    x1    y1
  1    graphpercent    graphpercent                90     16    81
  2    graphpercent    graphpercent                90     16    77
  3    datavalue       graphpercent    Hybrid      90      .    80
  4    datavalue       graphpercent    SUV         90      .    80
  5    datavalue       graphpercent    Sedan       90      .    80
  6    datavalue       graphpercent    Sports      90      .    80
  7    datavalue       graphpercent    Truck       90      .    80
  8    datavalue       graphpercent    Wagon       90      .    80
  9    datavalue       graphpercent    SUV         90      .    80
 10    datavalue       graphpercent    Sedan       90      .    80
 …
436
Chapter 20
•
Adding Data-Driven Annotations to a Graph

Chapter 21
Executing Graph Templates
Techniques for Executing Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Minimal Required Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
Managing the Input Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439
Filtering the Input Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439
Performing Data Transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439
Initializing Template Dynamics and Macro Variables . . . . . . . . . . . . . . . . . . . . . . 440
Managing the Output Data Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442
Setting Labels and Formats for the Output Columns . . . . . . . . . . . . . . . . . . . . . . . 442
Setting a Name and Label for the Output Data Object . . . . . . . . . . . . . . . . . . . . . . 442
Viewing the Data Object Name and Label in the Results Window . . . . . . . . . . . . 443
Setting a Name for the Output Image File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
Converting the Output Data Object to a SAS Data Set . . . . . . . . . . . . . . . . . . . . . 444
Techniques for Executing Templates
Compiled graph templates can be executed using either the PROC SGRENDER
statement or a DATA step. Both techniques offer the same functionality but differ in
their syntax. The SGRENDER syntax is simpler, but any required data manipulations
must be completed before the PROC SGRENDER statement is used. The DATA step
syntax is more complex, but it can integrate data manipulations with the graph
execution.
Both PROC SGRENDER and a DATA step can be used to
•
specify the input template
•
specify the input data set
•
associate a label with one or more input variables by using a LABEL statement
•
associate a format with one or more input variables by using a FORMAT statement
•
filter input data using a WHERE statement or WHERE= input data set option
•
assign values to dynamic variables for substitution in the template
•
name the output data object
•
label the output data object.
The following sections show how to use both SGRENDER and a DATA step to generate
graphs from compiled GTL templates.
437

Minimal Required Syntax
Consider the following simple GTL template definition:
proc template;
define statgraph mygraphs.scatter;
  begingraph;
    layout overlay;
      scatterplot X=height Y=weight;
    endlayout;
  endgraph;    
end;
run;
Both PROC SGRENDER and the DATA step can be used to execute this template. Both
techniques minimally require you to specify the input data source and the template
name. Behind the scenes in both cases, an ODS data object is populated and bound to the
template. The data object is then passed to a graph renderer, which processes the data
and graph request to produce an output image.
The PROC SGRENDER syntax is simple. It uses the DATA= option to specify the data
source and the TEMPLATE= option to specify the template to use for rendering the
graph:
proc sgrender data=sashelp.class template=mygraphs.scatter; 
run;
The DATA step syntax is slightly more complex. To execute a GTL template, the
DATA step FILE and PUT statements provide syntax that is specific to ODS. You must
minimally specify the following:
data _null_;
  set sashelp.class;
  file print ods=(template="mygraphs.scatter");
  put _ods_;
run;
•
The DATA step uses keyword _NULL_ for the data set name so that the DATA step
executes without writing observations or variables to an output data set. The input
data source is defined with a SET statement. This approach is appropriate in the
current example, but the input data source can be defined with any appropriate
DATA step syntax (INPUT with DATALINES, INPUT with INFILE, SET,
MERGE, UPDATE, and so on).
•
FILE PRINT ODS directs output to ODS. PRINT is a reserved fileref that is required
when executing a GTL template. It directs output that is produced by any PUT
statements to the same file as output that is produced by SAS procedures. The
TEMPLATE= specification is required to specify the input template name.
•
The PUT _ODS_ statement, also required, writes the necessary variables to the
output object for each execution of the DATA step.
Note: The necessary columns for the output data object are the ones defined by the
graph template (in this case, Height and Weight), not the input data source. As with
other DATA step or procedure processing, if you know exactly which columns the
template uses, you can restrict the input columns with DROP= or KEEP= input data
set options for slightly more efficient processing.
438
Chapter 21
•
Executing Graph Templates

Managing the Input Data
Filtering the Input Data
If you do not need all of the variables or all of the data values from the input data source,
you can use WHERE statements or input SAS data set options (for example, OBS= or
WHERE=) to control the observations that are processed. The filtering techniques can be
used whether the GTL template is executed with PROC SGRENDER or with a DATA
step.
In the following example, the first PROC SGRENDER uses a WHERE statement to
select only female observations for the graph. The second PROC SGRENDER uses the
OBS= input data set option to limit the number of observations used in the graph.
/* plot only observations for females */
proc sgrender data=sashelp.class template=mygraphs.scatter;
   where sex="F";
run;
/* test the template */
proc sgrender data=sashelp.class( obs=5 )
              template=mygraphs.scatter;  
run;
Performing Data Transformations
When using PROC SGRENDER, any required data transformations or computations
must take place before a template is executed. The transformations therefore require an
intermediate step. For example, the following code performs data transformations on the
Height and Weight columns that are in the data set Sashelp.Class. The transformations
are stored in a temporary data set named Class, which is then used in the SGRENDER
statement to produce a graph:
data class;
  set sashelp.class;     
  height=height*2.54;
  weight=weight*.45;
  label height="Height in CM" weight="Weight in KG";
run;
proc sgrender data=class template=mygraphs.scatter;
run;
When executing a template with a DATA step, the same DATA step that builds the data
object can perform any required data transformations or computations. An intermediate
data set is not needed. This next example produces the same graph that the previous
example produced with the SGRENDER procedure:
data _null_;
  set sashelp.class;
  height=height*2.54;
  weight=weight*.45;
  label height="Height in CM" weight="Weight in KG";
  file print ods=(template="mygraphs.scatter");
  put _ods_;
Managing the Input Data
439

run;
Initializing Template Dynamics and Macro
Variables
A useful technique for generalizing templates is to define dynamics and/or macro
variables that resolve when the template is executed.
You can create new macro variables or use the automatic macro variables that are
defined in SAS, such as the system date and time value (SYSDATE). Both types of
macro variables must be declared before they can be referenced. Whereas automatic
macro variables do not require initialization, you must initialize any macro variables that
you create with the variable declarations. The macro variable values are obtained from
the current symbol table (local or global), so SAS resolves their values according to the
context in which they are used.
The following template declares the dynamic variables XVAR and YVAR, and the
macro variables STUDY and SYSDATE:
proc template;
define statgraph mygraphs.regfit;
  dynamic XVAR YVAR;
  mvar STUDY SYSDATE;
  begingraph;
    entrytitle "Regression fit for Model " YVAR " = " XVAR ;
    entryfootnote halign=left STUDY halign=right SYSDATE ;
    layout overlay;
       scatterplot X=XVAR Y=YVAR ;
       regressionplot X=XVAR Y=YVAR ;
    endlayout;
  endgraph;
end;
run;
•
The DYNAMIC statement declares dynamic variables XVAR and YVAR. On the
statements that later execute this template, you must initialize these dynamics by
assigning them to variables from the input data source so that they have values at run
time.
•
The ENTRYTITLE statement concatenates dynamic variables XVAR and YVAR
into a string that will be displayed as the graph title. At run time, the dynamics will
be replaced by the names of the variables that are assigned to the dynamics when
they are initialized.
•
The SCATTERPLOT and REGRESSIONPLOT statements each reference the
dynamics on their X= and Y= arguments. At run time for both plots, the variable that
has been assigned to XVAR will provide X values for the plot, and the variable that
has been assigned to YVAR will provide Y values.
•
The MVAR statement declares the macro variable STUDY. Because STUDY is not
a SAS automatic macro variable, it will be created for use in this template. On the
statements that later execute this template, you must initialize a value for STUDY.
The MVAR statement also declares the automatic macro variable SYSDATE. At run
time, the current system date and time will be substituted for this variable.
440
Chapter 21
•
Executing Graph Templates

•
The ENTRYFOOTNOTE statement references both of the macro variables STUDY
and SYSDATE. The value that you assign to STUDY will be displayed as a left-
justified footnote, and the run-time value of SYSDATE will be displayed as a right-
justified footnote.
As with all GTL templates, the MYGRAPHS.REGFIT template can be executed with
either a PROC SGRENDER statement or a DATA step. Either way, any dynamics
and/or new macro variables that are declared in the template must be initialized to
provide run-time values for them. The following example executes the template with
PROC SGRENDER:
%let study=CLASS dataset;
proc sgrender data=sashelp.class template=mygraphs.regfit;
  dynamic xvar="height" yvar="weight";
run;
•
The %LET statement assigns string value "CLASS data set" to the STUDY macro
variable.
•
PROC SGRENDER uses the DYNAMIC statement to initialize the dynamic
variables XVAR and YVAR. XVAR is assigned to the input variable HEIGHT, and
YVAR is assigned to the input variable WEIGHT.
The DATA step uses the DYNAMIC= suboption of the ODS= option to initialize
dynamics. Macro variables can be initialized from the existing symbol table. You can
update the symbol table during DATA step execution with a CALL SYMPUT or CALL
SYMPUTX routine. The following example executes the MYGRAPHS.REGFIT
template with a DATA step:
data _null_;
  if _n_=1 then call symput("study","CLASS data set") ;
  set sashelp.class;
  file print ods=( template="mygraphs.regfit"
                  dynamic=( xvar="height" yvar="weight" ) );
  put _ods_;
run;
•
The CALL SYMPUT routine initializes the macro variable STUDY with the string
value "CLASS data set." The macro variable only needs to be initialized once, so the
IF statement limits the initialization to the first observation (_N_ = 1).
•
The DYNAMIC= suboption initializes the dynamic variables XVAR and YVAR.
XVAR is assigned to the input variable HEIGHT, and YVAR is assigned to the input
variable WEIGHT.
Initializing Template Dynamics and Macro Variables
441

For a more complete discussion of this topic and additional examples, see Chapter 14,
“Using Dynamics and Macro Variables to Make Flexible Templates,” on page 327.
Managing the Output Data Object
Setting Labels and Formats for the Output Columns
By default, the columns in the output data object derive variable attributes (name, type,
label, and format) from the input variables. However, using the LABEL and FORMAT
statements, you can change the label and format of the corresponding output object
column.
The LABEL and FORMAT statements are available on PROC SGRENDER and on the
DATA step. The following example assigns labels to the HEIGHT and WEIGHT
variables that are used in the MYGRAPHS.SCATTER template. It also assigns a format
to the WEIGHT variable.
proc sgrender data=sashelp.class template=mygraphs.scatter;
  label height="Height in Inches" weight="Weight in Pounds";
  format weight 3.;
run;
Setting a Name and Label for the Output Data Object
When the output data object is created, it is assigned a name and a label. The following
table shows the default names and labels, depending on whether the corresponding GTL
template is executed with a PROC SGRENDER statement or a DATA step:
Option
Default Name with
PROC SGRENDER
Default Name with
DATA Step
OBJECT= name
SGRENDER
FilePrintn (each execution of the DATA
step increments the object name :
FilePrint1, FilePrint2, and so on)
OBJECTLABEL="string"
The SGRENDER
Procedure
same as object name
Using either PROC SGRENDER or a DATA step, you can use the OBJECT= option to
set a name for the output data object. You can use the OBJECTLABEL= option to set a
descriptive label for the data object. The following example sets the object name and
label on PROC SGRENDER:
/* Open the ODS LISTING destination */
ods _all_ close;
ods listing;
/* set object name and label on PROC SGRENDER */
proc sgrender data=sashelp.class template=mygraphs.scatter
              object=Scatter1
              objectlabel="Scatter Plot 1" ;
run;
442
Chapter 21
•
Executing Graph Templates

This next example sets the object name and label on a DATA step:
/* set object name and label on a DATA step */
data _null_;
  set sashelp.class;
  file print ods=( template="mygraphs.scatter"
                   object=Scatter2
                   objectlabel="Scatter Plot 2" );
  put _ods_;
run;
Viewing the Data Object Name and Label in the Results Window
When a GTL template is executed, an ODS data object is populated and bound to the
template. The data object is assigned a name, and that name can be used to reference the
object on various ODS statements, such as ODS SELECT, ODS EXCLUDE, and ODS
OUTPUT. The data object is also assigned a label.
Object names and labels appear in the Results window. To view them,
1. Open the Results window if it is not already open (choose View ð Results ).
2. Right-click on the graph and choose Properties to view the object properties.
The following figure shows the output objects that were created in “Setting a Name
and Label for the Output Data Object” on page 442. The Results window shows the
two objects that were created, and the Scatter2 Properties window shows the
properties for the second object, which was named Scatter2.
Setting a Name for the Output Image File
By default, the output image file is assigned the same name as the output data object.
You can use the IMAGENAME= option in the ODS GRAPHICS statement to assign an
alternative name to the output image file. For example, the following code assigns the
filename regfit_heightweight to the output image file:
ods graphics / imagename="regfit_heightweight";
proc sgrender data=sashelp.class template=mygraphs.regfit;
   dynamic xvar="height" yvar="weight";
Managing the Output Data Object
443

run;
Converting the Output Data Object to a SAS Data Set
A data object can be converted to a SAS data set with the ODS OUTPUT statement.
Generally, you identify the data object to convert, and assign it a data set name.
When a GTL template is executed with PROC SGRENDER, the output data object is
always named SGRENDER. Thus, you can identify the data object by that name in the
ODS OUTPUT statement. The following example converts the data object to a SAS data
set named REGFIT1:
ods output sgrender=regfit1;
proc sgrender data=sashelp.class template=mygraphs.regfit;
   dynamic xvar="height" yvar="weight";
run;
Because the output object name from the DATA step changes with each execution, it is
handy to use the OBJECT= option on the DATA step FILE statement to set the object
name so that it is easy to identify for the conversion.
The following example assigns the name DATAOBJ to the data object and uses that
name to convert the data object to a SAS data set named REGFIT2:
ods output dataobj=regfit2 ;
data _null_;
  if _n_=1 then call symput("study","CLASS dataset");
  set sashelp.class;  
  file print ods=( template="mygraphs.regfit"
                  dynamic=( xvar="height" yvar="weight" )
                  object=dataobj );
  put _ods_;
run;
444
Chapter 21
•
Executing Graph Templates

Chapter 22
Managing Graphical Output
Introduction to ODS Graphics Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
SAS Registry Settings for ODS Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446
ODS Destination Statement Options Affecting ODS Graphics . . . . . . . . . . . . . . . 447
ODS GRAPHICS Statement Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 449
Common Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
Controlling the Image Name and Image Format . . . . . . . . . . . . . . . . . . . . . . . . . . 451
Controlling the Image's Output Location . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 454
Controlling Graph Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455
Understanding Graph Scaling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
Controlling DPI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 460
Controlling Anti-Aliasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 462
Creating a Graph That Can Be Edited . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464
Creating a Graph to Include in MS Office Applications . . . . . . . . . . . . . . . . . . . . 467
Controlling Data Tips . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Creating a Graph with Drill-Down Links . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
Creating Shared Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 473
Introduction to ODS Graphics Output
Whenever you run a program that creates ODS Graphics output, several details are
handled by default. Among them are the following:
•
output file characteristics (file path and filename)
•
image characteristics (format, name, DPI, size)
•
ODS style used
•
when anti-aliasing is used
•
whether fonts and markers are scaled when graph size is changed
•
whether the graph that is created can be edited
•
whether data tips are produced.
In addition to the actual template code, you have a great deal of control over the
environment in which ODS graphs are produced. Knowing what options are available
and how to adjust these options gives you the maximum control in producing the best
possible graphs for your needs.
445

Three areas work in conjunction with each other to control all aspects of graph creation:
SAS Registry
Provides a repository of defaults for many options that affect
ODS Graphics
ODS Destination statement
Provides options specific to destinations, such as HTML, PDF,
and RTF
ODS GRAPHICS statement
Provides many global options that affect ODS graphics
You often need to add options to both the ODS destination statement and the ODS
GRAPHICS statement to get the desired output. Resetting SAS registry keys serves to
configure your default ODS Graphics environment.
SAS Registry Settings for ODS Graphics
The SAS Registry is a special SAS item store file that is stored in your SASUSER
storage location. It contains the default settings for many SAS products and their
features. You can browse or edit this hierarchical file with PROC REGISTRY, or with
the Registry Editor window. The window can be accessed with the global REGEDIT
command from a Display Manager session. When you issue the command, the main
Registry Editor window appears:
If you expand the ODS folder, you will see a subfolder for ODS GRAPHICS, which
contains three registry keys.
446
Chapter 22
•
Managing Graphical Output

Registry Key
Use
Default State
Determines whether the ODS Graphics environment is active by
default
Design Height
Determines the default height of a graph that is generated with
GTL
Design Width
Determines the default width of a graph that is generated with
GTL
If you were to change the Default State from Off to On, it would make the ODS
Environment active in every SAS session. This implies that if you run a procedure that
normally requires you to activate the ODS Graphics environment with the ODS
GRAPHICS ON; statement, you would not have to issue this statement—ODS graphs
would be automatically produced every time you run an ODS graphics-enabled
procedure such as UNIVARIATE, ARIMA, or REG.
Note: The SAS procedures such as SGRENDER, SGPLOT, SGPANEL, and
SGSCATTER only produce template-based graphics. They internally activate the
ODS Graphics environment if it is not active and are unaffected by the Default State
key value.
The Design Height and Design Width keys control the default graph size for all graph
templates. The 640px by 480px size represents a 4/3 aspect ratio. If you change these
values, any new or existing graph templates are affected unless you explicitly set a
DESIGNWIDTH= or DESIGNHEIGHT= option in the BEGINGRAPH statement in the
graph template definition. For details, see “Controlling Graph Size” on page 455.
ODS Destination Statement Options Affecting
ODS Graphics
Each ODS destination has options that govern aspects of your ODS Graphics output.
The following table shows the options for the most commonly used destinations.
ODS Destination Statement Options Affecting ODS Graphics
447

Table 22.1
ODS Destination Options That Affect ODS Graphics
ODS Destination
Options for ODS Graphics
Description
LISTING
Creates a stand-alone image. The
default image format is PNG.
(See also “Using a Universal Printer
with ODS LISTING to Control the
Image Format” on page 453.)
GPATH="directory-spec"
Indicates the directory where images
are created. The default is the current
working directory.
IMAGE_DPI=number
Specifies the image resolution in dots
per inch for output images.
IMAGE_DPI=96 is the default.
Note: For TIFF output, the DPI
property for the TIFF image might
show 100 DPI instead of the
IMAGE_DPI= setting. The actual
image resolution is the IMAGE_DPI=
setting.
STYLE= style-definition
Specifies the style to use.
STYLE=LISTING is the default.
SGE= OFF | ON
SGE=ON enables creation of
corresponding SGE file(s), which can
be edited with the ODS Graphics
Editor. The SGE file(s) have the same
name as the image file(s). SGE=OFF
is the default.
PDF
Creates embedded image(s) in a PDF
document. The default image format is
SVG.
DPI=number
Specifies the image resolution in dots
per inch for output images. DPI=150 is
the default.
STYLE= style-definition
Specifies the style to use.
STYLE=PRINTER is the default.
RTF
Creates embedded image(s) in RTF
document. The default image format is
PNG.
IMAGE_DPI=number
Specifies the image resolution in dots
per inch for output images.
IMAGE_DPI=96 is the default.
STYLE= style-definition
Specifies the style to use.
STYLE=RTF is the default.
448
Chapter 22
•
Managing Graphical Output

ODS Destination
Options for ODS Graphics
Description
HTML
Creates stand-alone image(s) and the
HTML page. Image(s) are referenced
in the HTML page. The default image
format is PNG.
GPATH="directory-spec"
Indicates the directory where images
are created. If not specified, the
PATH= "directory-spec" is used.
IMAGE_DPI=number
Specifies the image resolution in dots
per inch for output images.
IMAGE_DPI=96 is the default.
STYLE= style-definition
Specifies the style to use.
STYLE=DEFAULT is the default.
ODS GRAPHICS Statement Options
The ODS GRAPHICS statement is the primary statement that controls the run-time
environment for producing template-based graphs. In a sense, is it similar to the
GOPTIONS statement for GRSEG-based graphs, but completely independent of that
statement. The GOPTIONS statement does not affect template-based graphical output
and the ODS GRAPHICS does not affect GRSEG-based graphs.
All options for the ODS GRAPHICS statement are global to a SAS session, unless:
•
the graphics environment is disabled with the ODS GRAPHICS OFF; statement.
•
the RESET or RESET= option of the ODS GRAPHICS statement is used to return
the default state to all options or a specific option.
The following table shows some of the available options. For a complete and more
detailed explanation of all available options, see the documentation of the ODS
GRAPHICS statement in SAS Output Delivery System: User's Guide.
Table 22.2
Partial Listing of ODS GRAPHICS Statement Options
Task
Option
Specify the threshold for
allowing anti-aliasing.
ANTIALIASMAX= positive-integer
The default is 600 markers and/or lines.
Specify whether graph
rendering uses anti-aliasing.
ANTIALIAS= ON | OFF
The default is ON.
Specify whether to draw a
border around any graph.
BORDER= ON | OFF
The default is ON.
ODS GRAPHICS Statement Options
449

Task
Option
Increase the maximum number
of discrete values that are
allowed in a graph.
DISCRETEMAX=positive-integer
The default is 1000. If your graph data contains more than
1000 discrete values, your graph is not drawn and the
following warning appears in the SAS log:
WARNING: plot-name statement has too many discrete
values. The plot will not be drawn.
In that case, use the DISCRETEMAX= option to increase the
maximum number of discrete values that are allowed.
Specify the height of any
graph.
HEIGHT= dimension
Supported dimension units include SPX (special pixels), PX
(pixels), IN (inches), CM (centimeters), and MM
(millimeters). This option overrides the design height
specified by the template definition. The default unit is SPX.
It is recommended you always provide a unit such as PX, IN,
CM, or MM with the dimension value.
Specify the image format used
to generate image files.
OUTPUTFMT= STATIC | image-format
Supported formats include PNG, GIF, JPEG, WMF, TIFF,
PDF, EMF, PS, EPS, EPSI, PCL, SVG, and others. The
keyword STATIC is the default, which means to
automatically select the best format, based on the output
destination.
Note: The PDF, PS, EPS, EPSI, EMF, and PCL formats
support images in the vector graphics format.
Specify whether data tips are
generated.
IMAGEMAP= OFF | ON
The default is OFF.
Specify the base image
filename.
IMAGENAME= "file-name" (no path information)
The default is to use the invoking procedure name as the base
name.
Control whether legend(s) are
drawn.
MAXLEGENDAREA=n
Specifies an integer that is interpreted as the maximum
percentage that a legend can occupy in the overall graphics
area. The default integer is 20.
Reset one or more ODS
GRAPHICS options to its
default. RESET by itself is the
same as RESET=ALL.
RESET | RESET= option
The option can be ALL, HEIGHT, WIDTH, INDEX, and
other options.
By default, each time you run a procedure, new images are
created and numbered incrementally using a base name, such
as SGRender, SGRender1, SGRender2, and so on. RESET
will reset to the base name without the increment number.
This is handy if you run a PROC several times and are
interested only in the images from the last run (the previous
ones will be overwritten). This option is positional, so it
typically comes first.
450
Chapter 22
•
Managing Graphical Output

Task
Option
Specify whether the content of
any graph is scaled
proportionally.
SCALE = ON | OFF
The default is ON.
Specify whether the plot
markers are to be scaled with
the graph size.
SCALEMARKERS=YES | NO | ON | OFF
The default is ON. The scaling factor is based on the height
of the graph cells and the height of the graph.
Specify the maximum number
of distinct mouse-over areas
allowed before data tips are
disabled.
TIPMAX=n
The default number is 500.
Specify the width of any graph.
WIDTH= dimension
Supported dimension units include SPX (special pixels), PX
(pixels), IN (inches), CM (centimeters), and MM
(millimeters). This option overrides the design width
specified by the template definition. The default unit is SPX.
It is recommended you always provide a unit such as PX, IN,
CM, or MM with the dimension value.
Common Tasks
The following sections show the coding that is necessary to accomplish several common
tasks for managing ODS graphics output.
Controlling the Image Name and Image Format
Using the IMAGENAME= ODS Graphics Option to Control the Image
Name
For ODS Graphics output, by default, the ODS object name is used as the “root” name
for the image output file.
The following example creates a GIF image named REGPLOT:
ods graphics / imagename="regplot" outputfmt=gif;
The assigned name REGPLOT is treated as a "root" name and the first output created is
named REGPLOT. Subsequent graphs are named REGPLOT1, REGPLOT2, and so on,
with an increasing index counter. All graphs in this example will be GIF images.
If you are developing a template and it takes several submissions to get the desired
output, you might want to use the RESET or RESET= option to force each output to
replace itself:
ods graphics / reset=index ... ;
This specification causes all subsequent images to be created with the default or current
image name.
Common Tasks
451

Using the OUTPUTFMT= ODS Graphics Option to Control the Image
Format
Each ODS destination uses a default image format for its output. Depending on the
destination, the default image output format is Portable Network Graphics (PNG) or
vector graphics. See SAS Output Delivery System: User's Guide for more information.
You can use the OUTPUTFMT= option in the ODS GRAPHICS statement to change the
output format.
Unless you have a special requirement for changing the image format, we recommend
that you not change it. The default PNG or vector graphic format is far superior to other
formats, such as GIF, in support for transparency and a large number of colors. Also,
PNG and vector graphics images require much less disk storage space than JPEG or
TIFF formats. Additional advantages that are provided by vector graphics images
include scalability and multiple output formats, which are PDF, EMF, and SVG.
If you want to generate vector graphics images, you can use the ODS destination and
ODS GRAPHICS statement OUTPUTFMT= option combinations that are shown in
Table 22.3 on page 452.
Table 22.3
Generating Vector Graphics Images with ODS
ODS Destination
ODS GRAPHICS Statement
OUTPUTFMT= Option
ODS HTML
OUTPUTFMT=SVG
ODS LISTING
OUTPUTFMT=EMF
OUTPUTFMT=PDF
OUTPUTFMT=SVG
OUTPUTFMT=PS | EPS | EPSI
ODS PDF
(vector graphics images are generated by
default)
ODS PRINTER
OUTPUTFMT=EMF (for EMF output)
OUTPUTFMT=PCL (for PCL output)
OUTPUTFMT=PDF (for PDF output)
OUTPUTFMT=PS | EPS | EPSI (for
PostScript output)
OUTPUTFMT=SVG (for SVG output)
ODS RTF
OUTPUTFMT=EMF
If a vector graphics image cannot be generated for the image format that you specify, a
PNG image is generated instead and is embedded in the specified output file. The output
file format and extension are not changed in that case. Cases where a vector graphics
image cannot be generated include the following:
•
surface plots
•
bivariate histograms
•
graphs that use gradient contours
•
graphs that include continuous legends
452
Chapter 22
•
Managing Graphical Output

•
graphs that use data skins
•
graphs that use transparency (EMF and PS ODS destinations only)
•
graphs that contain one or more rotated images
See SAS Output Delivery System: User's Guide for more information.
Using a Universal Printer with ODS LISTING to Control the Image
Format
When you use the ODS LISTING destination, you can use the DEVICE= and
PRINTERPATH= system options to specify a Universal Printer to generate the image.
The Universal Printers can generate image files in formats other than PNG, such as
SVG, PDF, or EMF. For more information about the DEVICE= and PRINTERPATH=
system options, see SAS System Options: Reference.
To use a Universal Printer with the ODS LISTING destination to generate an image file:
1. Create a template to generate your graph if you have not already done so.
2. Use a FILENAME statement to create a file reference for your image output file.
3. Set the DEVICE= system option to SASPRTC.
Note: Alternatively, you can set the DEVICE= graphics option to SASPRTC.
4. Set the PRINTERPATH= system option to (printer-name fileref), where printer-
name is the name of the Universal Printer that you want to use to generate the output,
and fileref is the file reference that you created in Step 2.
Note: To see a list of the available printers, open the SAS Registry Editor, and then
select Core ð Printing ð Printers.
5. Open the ODS LISTING destination.
Note: You must use the ODS LISTING destination. This procedure does not work
with the other ODS destinations.
6. Use the SGRENDER procedure to generate your graph.
7. Close the ODS LISTING destination.
Here is an example that generates a graph in the SVG format using the ODS LISTING
destination.
/* Specify the current directory for the graphics output file */
filename imgout ".";
/* Create the graph template */
proc template;
  define statgraph barchart;
    begingraph;
      dynamic printer dev imagedpi;
      entrytitle "Average Mileage by Vehicle Type";
      layout overlay;
        barchart category=type  response=mpg_highway /
          stat=mean orient=horizontal;
      endlayout;
    endgraph;
  end;
run;
/* Set the DEVICE= and PRINTERPATH= system options */
Common Tasks
453

options device=sasprtc printerpath=(SVG imgout);
/* Specify a name for the output file */
ods graphics / reset imagename="average_mpg";
/* Open the ODS LISTING destination */
ods listing;
/* Generate the graph */
proc sgrender data=sashelp.cars template=barchart;
run;
/* Close the ODS LISTING destination */
ods listing close;
quit;
Resetting the Image Name and Format
The options in the ODS GRAPHICS statement are global to the SAS session. These
options are in effect until you:
•
disable the ODS graphics environment by submitting the following statement:
ods graphics off;
•
reset all options to their defaults by submitting the following statement:
ods graphics / reset;
•
reset specific options by submitting the following statement:
ods graphics / reset=option;
The DEVICE= and PRINTERPATH= system options are also global to the SAS session.
These options are in effect until you reset them. For information about changing these
options to a new value or back to their default value, see “Changing SAS System Option
Settings” in Chapter 1 of SAS System Options: Reference and “Resetting System Options
to the Default or Starting Value” in Chapter 1 of SAS System Options: Reference.
Controlling the Image's Output Location
To control the image location (path) for ODS Graphics output, use the PATH= or
GPATH= option on the ODS destination statement.
ods listing gpath="C:\ODSgraphs";
ods html gpath="C:\ODSgraphs";
For the HTML destination, the PATH= option is used to indicate whether the HTML
page is stored. If GPATH= is not used, images are stored at the PATH= storage location.
Use PATH= and GPATH= together when you want to store images in a different storage
location. The (URL= NONE | url-spec) suboption specifies a Uniform Resource
Locator for the PATH= or the GPATH= options.
For example, the following program will create an HTML page named
u:\public_html\report.html:
ods graphics / reset imagename="graph";
ods html style=statistical
         path="u:\public_html"
         gpath="u:\public_html" (url=none)
454
Chapter 22
•
Managing Graphical Output

         file="report.html";
 
/* Create the graph template */
proc template;
  define statgraph barchart;
    begingraph;
      dynamic mpgtype;
      entrytitle "Average " mpgtype " MPG by Vehicle Type";
       layout overlay;
        /* Generate graph based on MPG type */
        if (upcase(mpgtype) = "CITY")
           barchart category=type  response=mpg_city /
             stat=mean orient=horizontal;
        else
           barchart category=type  response=mpg_highway /
             stat=mean orient=horizontal;
        endif;
      endlayout;
    endgraph;
  end;
run;
/* Generate city MPG chart */
proc sgrender data=cars template=barchart
   des="Average City MPG by Type";
   dynamic mpgtype="City";
run;
/* Generate highway MPG chart */
proc sgrender data=sashelp.cars template=barchart
   des="Average Highway MPG by Type";
   dynamic mpgtype="Highway";
run;
ods html close;
ods html;
The graphs produced are named graph.png and graph1.png, and are stored in
u:\public_html\. The (URL=NONE) suboption prevents any path or URL information
from being included in the SRC=" " attribute of the <IMG> tag. This creates relative
references to the images in the HTML source:
<img alt="Average City MPG by Type" src="graph.png" style=" height: 480px;
   width: 640px;" border="0" class="c">
<img alt="Average Highway MPG by Type" src="graph1.png" style=" height:
   480px; width: 640px;" border="0" class="c">
For ODS destinations such as RTF or PDF, the image is embedded in the document that
is created by that destination.
Controlling Graph Size
Overview of Graph Size Control
By default, the size of the graph that you create with ODS Graphics is governed by the
following:
Common Tasks
455

•
settings for ODS Graphics in the SAS Registry
•
the size indicated by the DESIGNWIDTH= and DESIGNHEIGHT= options of the
BEGINGRAPH statement
•
the WIDTH= and HEIGHT= options of the ODS GRAPHICS statement.
BEGINGRAPH Statement
When creating a graphics template, you often want to control the design width and
design height, especially for multi-cell graphs.
BEGINGRAPH / DESIGNWIDTH= dimension   DESIGNHEIGHT= dimension;
In addition to specifying sizes in several units, you can also refer to the current registry
settings with the constants DEFAULTDESIGNWIDTH and
DEFAULTDESIGNHEIGHT.
In the following example, the intent is to produce a square graph (equal height and
width) in order to reduce unused graphical area. The design width is set to the default
internal height (DEFAULTDESIGNHEIGHT).
proc template;
  define statgraph squareplot;
    dynamic title xvar yvar;
    begingraph / designwidth=defaultDesignHeight;
      entrytitle title;
      layout overlayequated / equatetype=square;
         scatterplot x=xvar y=yvar;
         regressionplot x=xvar y=yvar;
      endlayout;
    endgraph;
  end;
run;
If this template were executed with the following SGRENDER specification, a 480px by
480px graph would be created:
proc sgrender data=mydata template="squareplot";
  dynamic title="Square Plot" xvar="time1" yvar="time2";
456
Chapter 22
•
Managing Graphical Output

run;
If a 550px width or height were set in an ODS GRAPHICS statement before the
template is executed with the SGRENDER procedure, a 550px by 550px graph would be
created, maintaining the 1:1 aspect ratio:
ods graphics / width=550px;
proc sgrender data=mydata template="squareplot";
  dynamic title="Square Plot" xvar="time1" yvar="time2";
run;
/* Setting a 550px height would create the same size graph */
ods graphics / height=550px;
proc sgrender data=mydata template="squareplot";
  dynamic title="Square Plot" xvar="time1" yvar="time2";
run;
When no DESIGNWIDTH= or DESIGNHEIGHT= option is specified in the
BEGINGRAPH statement, graphs are rendered with the registry defaults, unless
changed by the ODS GRAPHICS statement HEIGHT= or WIDTH= options.
Examples for sizing multi-cell graphs are discussed in Chapter 9, “Using a Simple
Multi-cell Layout,” on page 211, Chapter 10, “Using an Advanced Multi-cell Layout,”
on page 225, and Chapter 11, “Using Classification Panels,” on page 257.
Understanding Graph Scaling
ODS graphics uses style information to control the appearance of the graph. Style
definitions contain information about fonts, color, lines, and markers, and they also
contain settings such as font size and marker size. When a graph is rendered at a size
larger or smaller than its design size, scaling takes place by default.
ods graphics / width=440px height=340px scale=on ;
Common Tasks
457

If you turn off scaling, the font sizes, marker sizes, and so on, revert to the sizes that are
defined in the style. To accommodate the larger font sizes for the titles, footnotes, axis
labels, tick values, and data labels, the wall area and contained graphical components
automatically shrink.
ods graphics / width=440px height=330px scale=off ;
In general, having the fonts scale up or down as the graph size increases or decreases is
desirable. However, in some cases you might want greater control of the font sizes.
The examples in this document were created with different styles that varied only in the
font sizes that they used. In some cases, smaller graphs look better when rendered in a
smaller set of fonts. The style examples below use the HTMLBLUE style as a parent,
but you could use any style as the parent. The DOCIMAGE style keeps fonts close to the
default sizes and weights while the DOCIMAGE_SMALLFONT style reduces the font
sizes by a few points. See Chapter 18, “Managing the Graph Appearance with Styles,”
on page 391 for a discussion of defining your own styles and what parts of the graph are
affected by various style elements.
proc template;
  define style docimage;
    parent=styles.htmlblue;
    style GraphFonts from GraphFonts
         "Fonts used in graph styles" /
         'GraphDataFont' = ("<sans-serif>, <MTsans-serif>",8pt)
         'GraphUnicodeFont' = ("<MTsans-serif-unicode>",10pt)
         'GraphValueFont' = ("<sans-serif>, <MTsans-serif>",10pt)
         'GraphLabelFont' = ("<sans-serif>, <MTsans-serif>",11pt)
         'GraphFootnoteFont' = ("<sans-serif>, <MTsans-serif>",8pt)
         'GraphTitleFont' = ("<sans-serif>, <MTsans-serif>",12pt,bold);
  end;
  define style docimage_smallfont;
    parent=styles.htmlblue;
458
Chapter 22
•
Managing Graphical Output

    style GraphFonts from GraphFonts
         "Fonts used in graph styles" /
         'GraphDataFont' = ("<sans-serif>, <MTsans-serif>",6pt)
         'GraphUnicodeFont' = ("<MTsans-serif-unicode>",8pt)
         'GraphValueFont' = ("<sans-serif>, <MTsans-serif>",8pt)
         'GraphLabelFont' = ("<sans-serif>, <MTsans-serif>",9pt)
         'GraphFootnoteFont' = ("<sans-serif>, <MTsans-serif>",8pt)
         'GraphTitleFont' = ("<sans-serif>, <MTsans-serif>",10pt,bold);
  end;
run;
The previous two graphs were created the DOCIMAGE style. These next two graphs
were created with the DOCIMAGE_SMALLFONT style.
Common Tasks
459

In both of these graphs that use the DOCIMAGE_SMALLFONT style, the text in the
graph is still legible whether scaling is on or off. Also, more space is available to the
graphical elements in the output.
Controlling DPI
All ODS destinations use a default DPI (dots per inch) setting when creating ODS
Graphics output. By default, LISTING and HTML use 96 dpi, and RTF and PDF use
150 dpi. Graphs that are rendered at higher DPI have greater resolution and larger file
size. Although DPI can be set to large values such as 1200, from a practical standpoint,
settings larger than 300 dpi are seldom necessary for most applications. Also, setting an
unrealistically large DPI like 1200 could cause an out-of-memory condition. Note that
the ODS option for setting DPI is not the same for all destinations. For the LISTING and
HTML destinations, use the IMAGE_DPI= option. For the RTF and PDF destinations,
use the DPI= option.
ods graphics / width=440px height=330px scale=off;
ods html image_dpi=100 style=docimage_smallfont;
460
Chapter 22
•
Managing Graphical Output

ods graphics / width=440px height=330px scale=off;
ods html image_dpi=200 style=docimage_smallfont;
In these examples, the text in the 200 dpi graph is slightly more legible. Markers and
lines are also more legible.
Common Tasks
461

Controlling Anti-Aliasing
Anti-aliasing is a graphical rendering technique that improves the readability of text and
the crispness of the graphical primitives, such as the markers and lines. By default, ODS
Graphics uses anti-aliasing.
Note: Titles, footnotes, entry text, axis labels, tick values, and legend text is always anti-
aliased. Graphical components related to the data, such as markers, lines, and data
labels, are affected by the ANTIALIAS= and ANTIALIASMAX= options, as
discussed in this section.
To see how much the graph quality is improved with anti-aliasing, you can turn this
feature on and off with the ANTITALIAS= option in the ODS GRAPHICS statement.
ods graphics / antialias=on;
ods html image_dpi=100;
proc sgrender data=sashelp.class template=fitline;
run;
ods graphics / antialias=off ;
ods html image_dpi=100;
proc sgrender data=sashelp.class template=fitline;
run;
462
Chapter 22
•
Managing Graphical Output

The following image shows a zoomed-in view of a portion of the anti-aliased image
(100dpi). Notice that the text, markers, and line appear fuzzy because of the anti-aliasing
algorithm.
This next image shows a zoomed-in view of the image (100dpi) that has anti-aliasing
turned off. Notice that the text, markers, and line are not fuzzy but have a jagged
appearance.
If the image is created at 300dpi, the combination of anti-aliasing and higher resolution
produces a very high quality image.
Common Tasks
463

The non-anti-aliased image at 300dpi, is good but still has jagged edges.
To perform anti-aliasing requires additional computer resources (CPU, memory, and
execution time). Graphs that have a lot of markers, lines, and text use even more
resources. Filled or gradient 3-D surface plots might require even more resources.
Setting a higher DPI increases anti-aliasing resources. At some point, ODS Graphics
deems that anti-aliasing requires too many resources and it turns the feature off. When
this happens, you get a non-anti-aliased rendered graph and a message in the SAS log
similar to the following :
NOTE: Marker and line antialiasing has been disabled because the threshold has
      been reached. You can set ANTIALIASMAX=5700 in the ODS GRAPHICS
      statement to restore antialiasing.
If you want anti-aliasing for a graph that caused the anti-aliasing to be disabled, you
must set a higher threshold (at least 5700) for anti-aliasing with the ANTIALIASMAX=
option of the ODS GRAPHICS statement.
ods graphics / antialiasmax=5700;
The number that is specified on the ANTIALIASMAX= option represents the maximum
number of observations in the data to be anti-aliased before anti-aliasing is disabled.
Creating a Graph That Can Be Edited
SAS provides an application called the ODS Graphics Editor that can be used to post-
process ODS Graphics output. With the editor, you can edit the following features in a
graph that was created using ODS Graphics:
464
Chapter 22
•
Managing Graphical Output

•
Change, add, or remove titles and footnotes.
•
Change style, marker symbols, line patterns, axis labels, and so on.
•
Highlight or explain graph content by adding annotation, such as text, lines, arrows,
and circles.
For example, suppose the following template is used to create box plots in a graph and
you want to indicate that the labeled outliers are far outliers (more than 3 IQR above
75th percentile).
proc template;
  define statgraph boxplot;
    begingraph;
      entrytitle "Deceased Subjects in Framingham Heart Study";
      layout overlay;
        boxplot y=mrw x=bp_status / datalabel=deathcause
                spread=true labelfar=true;
      endlayout;
    endgraph;
  end;
run;
To create ODS Graphics output that can be edited, you must specify the SGE=ON option
in the ODS LISTING destination statement before creating the graph:
ods listing sge=on style=listing;
proc sgrender data=sashelp.heart template=boxplot;
  where status="Dead";
run;
When SGE=ON is in effect, an .SGE file is created in addition to the image file normally
produced. From the Results Window, you can open the .SGE file in the ODS Graphics
Editor by selecting Open in the icon. You can also open the .SGE file directly from the
Windows file system. The .SGE file is always created in the same location as the image
output. Here is the image output.
Common Tasks
465

The following figure shows the Graphical User Interface for the ODS Graphics Editor
after some of the annotation has been completed.
You can save your annotated graph as an .SGE file or as an image file. If you save it as
an .SGE file, you can open it again for further editing.
Note: Changes that are made in the ODS Graphics Editor do not affect the compiled
template code.
466
Chapter 22
•
Managing Graphical Output

After you are finished creating editable graphics, you should either close the ODS
destination (in this case LISTING) or specify SGE=OFF to discontinue producing .SGE
files and avoid the extra computational resources used to generate the extra .SGE files:
ods listing sge=off;
Creating a Graph to Include in MS Office Applications
The default height for a graph is 480 pixels. At a 100 dot per inch (DPI) setting, you can
consider the default height to be 4.8 inches. If you render a graph at 480 pixels and 100
DPI, insert it into a document like an MS Office application, and then print the page, the
graph height on paper will be 4.8 inches and all font sizes will look right in their point
weights. You can render the graph at a higher DPI to get higher quality graphs. As long
as the graph is then inserted in the document as a 4.8 inch graph, it will work as
expected.
To alter the graph size or DPI for a graph that you want to include in an MS Office
application, one technique that produces good results is to create a stand-alone image
that is sized appropriately and has high resolution, say 200 DPI or 300 DPI.
ods graphics / reset width=5in imagename="fitplot" outputfmt=png
    antialias=on;
ods listing gpath="\ODSgraphs" image_dpi=200 style=analysis;
proc sgrender data= . . . template= . . .;
run;
This code produces a 5 inch, 200 DPI image \ODSgraphs\fitplot.png, which can
be inserted into Word or PowerPoint documents. When only the WIDTH= or HEIGHT=
option is specified in the ODS GRAPHICS statement, the design aspect ratio of the
graph is maintained. Also, check the SAS log to ensure that anti-aliasing has not been
disabled. If it has been disabled, add the ANTIALIASMAX= option. (See “Controlling
Anti-Aliasing” on page 462 for a discussion of anti-aliasing.)
After inserting the graph into the MS Office document, you can change the picture size
with good results (while maintaining aspect ratio). If you find that the text in the graph is
too large or too small, re-create the graph with different font sizes using the techniques
discussed in “Understanding Graph Scaling” on page 457.
To create good looking graphs for a two-column MS Word document where each
column is about 3.5 inches wide, use a graph width of 3.5 inches. If the original graph
has a default width of 640 pixels, you can set WIDTH=3.5IN in the ODS GRAPHICS
statement to get a smaller graph with appropriately smaller fonts. In this case, the fonts
will not be exactly the right point size, but they will be scaled smaller using a non-linear
scaling factor.
Controlling Data Tips
Creating a Graph with Data Tips in an HTML Page
Data tips can be displayed by graphs that are included in HTML pages. When data tips
are provided, you can "mouse over" parts of a graph, and text balloons open to show
information (typically data values) that is associated with the area where the mouse
pointer rests. Nearly all plot statements in GTL create default data tip information.
However, this information is not generated unless you request it with the IMAGEMAP=
option in the ODS GRAPHICS statement:
ods html file=". . ." path=". . ." (url=none);
Common Tasks
467

ods graphics / reset width=5in imagemap=on ; 
 
proc sgrender data= . . . template= . . .;
run;
ods graphics / reset;
ods html close;
Using the following simple template, we can show how the default data tips look when
the mouse pointer is held over a data point:
layout overlay;
  scatterplot x=height y=weight / group=sex name="s";
  discretelegend "s";
endlayout;
Creating a Graph with Custom Data Tips in an HTML Page
GTL supports plot statement syntax that enables you to suppress or customize the default
data tip information. Here is an example:
layout overlay;
  /* scatter points have enhanced tooltips */
  scatterplot x=height y=weight / group=sex name="s"
    rolename=(tip1=name tip2=age)
    tip=(tip1 tip2 X Y GROUP)
    tiplabel=(tip1="Student Name")
    tipformat=(tip2=2.);
  discretelegend "s";
endlayout;
468
Chapter 22
•
Managing Graphical Output

The ROLENAME=, TIP=, TIPLABEL= and TIPFORMAT= options are common to
most plot statements in GTL.
ROLENAME defines one or more name / value pairs as role-name = column-name,
where column-name is some input data column that does not participate directly in the
plot. In this example, we want the Name and Age column values to show in the tip.
Notice that the choice of role names is somewhat arbitrary. The TIP1 and TIP2 role
names are added to the default role names X, Y, and GROUP.
The TIP= option defines a list of roles to be displayed, and it also determines their order
in the display. Notice that it is not necessary to request all default roles. For example, it
might be obvious from the legend that the GROUP role does not really need to be in the
data tip, so in that case you would specify:
tip=(tip1 tip2 X Y)
For any role, the default tip label is 1) the data label, or 2) the name of the column that is
associated with the role. If you want other label text displayed, use the TIPLABEL=
option:
tiplabel=(tip1="Student Name" group="Group")
For any role, you can assign a format to the display of tip values.
Creating a Graph with Drill-Down Links
For several types of plots, you can use the URL= option in the plot statement to add
drill-down links to your graphs for HTML presentations. The following plot statements
support the URL= option:
BARCHART
LINECHART
SCATTERPLOT
BARCHARTPARM
MOSAICPLOTPARM
SERIESPLOT
BUBBLEPLOT
NEEDLEPLOT
STEPPLOT
HEATMAPPARM
PIECHART
WATERFALLCHART
Common Tasks
469

Drill-down graphs provide a convenient means for your users to explore complex data.
In a drill-down graph, active links are created on certain elements of the graph. When a
user clicks a linked element, the linked resource appears in a new browser window by
default. The resource can be another web page or an image file that contains a
supporting graph. For example, consider the pie chart shown in the following figure.
To provide your users with sales information for each product, you can create a drill-
down pie chart in which each pie slice is linked to a bar chart that shows sales data for
that product. You can also add a footnote that prompts the user to click a pie slice for
more information. In this drill-down pie chart, if the user clicks the SOFA pie slice, a bar
chart showing the sales data for SOFA appears in a new browser window, as shown in
the following figure.
When the mouse pointer is positioned on a pie slice, the data tip appears, and the mouse
pointer changes to indicate an active link. The drill-down link target is a new browser
window by default. You can use the DRILLTARGET= option in your ODS GRAPHICS
statement to specify a different target, such as _SELF. In that case, the drill-down graphs
open in the same browser window. See SAS Output Delivery System: User's Guide for
more information about the ODS GRAPHICS DRILLTARGET= option.
In order to create a drill-down graph, you must do the following:
470
Chapter 22
•
Managing Graphical Output

•
Add a column that contains the URL of each link to the data set for the drill-down
graph.
•
Use the URL= option in the plot statement to specify the data column that contains
the link URLs.
•
Enable image mapping in ODS Graphics by using the IMAGEMAP=ON option in
the ODS GRAPHICS statement.
•
Write the graph output to the ODS HTML destination.
For example, to create the drill-down pie chart in the previous example, you must
complete the following steps:
1. Add the URLs for the supporting bar charts to a character column in the data set for
your main graph.
Note: You must set the column length appropriately for the expected URL values. If
a URL value exceeds the column length, the URL is truncated and the link does
not work.
2. Create the template for the supporting bar charts.
3. Generate the supporting bar charts.
4. Create the template for the main pie chart. In the plot statement for the pie chart,
include the URL=url-column-name option to specify the name of the column in the
data set that contains the drill-down link URLs.
5. Use the following statement to enable image mapping in ODS Graphics:
ods graphics / imagemap=on;
6. Generate the pie chart by using the ODS HTML destination.
Note: In order to support the drill-down links, you must use the ODS HTML
destination.
7. Use the following statement to disable image mapping in ODS Graphics:
ods graphics / imagemap=off;
Here is the SAS code for this example.
/* 1. Add a URL column for the drill-down links to the 
             SASHELP.PRDSALE data set. */
data sales;
   length url $30;
   set sashelp.prdsale;
   format actual dollar12.0;
   select (product);
      when ("SOFA")  url="sofa.html";
      when ("BED")   url="bed.html";
      when ("TABLE") url="table.html";
      when ("CHAIR") url="chair.html";
      when ("DESK")  url="desk.html";
      otherwise url=" ";
   end;
run;
/* 2. Create a template for the supporting graphs. */
proc template;
   define statgraph drilldown;
   begingraph;
Common Tasks
471

      dynamic product;
      entrytitle product " Sales Data";
      layout overlay /
         yaxisopts=(griddisplay=on gridattrs=(color=lightgray pattern=dot));
         barchart category=country response=actual /
            name="productsales"
            group=year
            groupdisplay=cluster
            barwidth=0.75
            dataskin=sheen;
         discretelegend "productsales" / title="Year:";
      endlayout;
   endgraph;
end;
run;
/* 3. Generate a supporting graph for each product. Because there are 
      several products, create a macro that generates a graph
      for a specific product. */
%macro genchart(product=);
   /* Specify the image output filename. */
   ods graphics / imagename="&product";
   /* Generate the graph using ODS LISTING. */
   ods _all_ close;
   ods html file="&product..html";
   proc sgrender data=sales template=drilldown;
      where product = "&product";
      dynamic product="&product"; /* Pass product to the template. */
   run;
   ods html close;
%mend genchart;
/* Use the macro to generate the supporting graphs. */
%genchart(product=SOFA);
%genchart(product=DESK);
%genchart(product=CHAIR);
%genchart(product=TABLE);
%genchart(product=BED);
/* 4. Create a template for the drill-down graph. */
proc template;
   define statgraph basechart;
   begingraph;
      entrytitle "Total Sales By Product";
      entryfootnote textattrs=(size=7pt) "Click a pie slice for
         product-specific sales data.";
      layout region;
         piechart category=product response=actual /
            datalabelcontent=(category response)
            datalabellocation=inside
            url=url
            tip=(category)
            dataskin=gloss;
      endlayout;
   endgraph;
472
Chapter 22
•
Managing Graphical Output

end;
run;
/* 5. Enable image mapping in the HTML output and specify
      a base image name. */
ods graphics / reset imagemap=on imagename="prodsales"
   antialiasmax=2000 tipmax=2000;
/* 6. Generate the drill-down graph using ODS HTML. */
ods _all_ close;
ods html file="sales.html";
proc sgrender data=sales template=basechart;
run;
ods html close;
/* 7. Disable image mapping. */
ods graphics / reset imagemap=off;
You can create multiple levels of drill-down graphs in your presentation. That is, your
supporting graphs can also be drill-down graphs in as many levels as needed.
Creating Shared Templates
When creating templates (especially with dynamics that generalize the usefulness of the
template), you typically want to enable several people to create graphs from the
template. To enable access to templates, you must store the "public" templates in a
directory that is accessible to others. PROC TEMPLATE can store templates in specified
SAS libraries and within specific item stores. By default, templates are stored in
Sasuser.Templat , but another library.itemstore can be specified with the STORE=
option in the DEFINE statement.
libname p "\\public\templates";
proc template;
  define statgraph graphs.distribution / store=p.templat ;
     ...
  end;
  define statgraph graphs.regression / store=p.templat ;
     ...
  end;
run;
When this template code is submitted, you see the following notes in the SAS log:
NOTE: STATGRAPH 'Graphs.Distribution' has been saved to:
PUBLIC.TEMPLAT
NOTE: STATGRAPH 'Graphs.Regression' has been saved to:
PUBLIC.TEMPLAT
After shared templates are compiled and stored, others can access them to produce
graphs.
libname p "\\public\templates" access=readonly;
ods path reset;
Creating Shared Templates
473

ods path (prepend) p.templat(read) ;
proc sgrender data= ... template=graphs.distribution;
  dynamic var="height";
run;
Manipulating the ODS search path is the best way to make the templates publicly
available.
Note that this code did not replace the path but rather added an item store at the
beginning of the path. This is done to allow access to all SAS supplied production
templates, which are stored in Sashelp.Tmplmst.
ods path show;
Current ODS PATH list is:
1. P.TEMPLAT(READ)
2. SASUSER.TEMPLAT(UPDATE)
3. SASHELP.TMPLMST(READ)
474
Chapter 22
•
Managing Graphical Output

Appendix 1
Reserved Keywords and Unicode
Values
Overview
The tables in this section show some of the reserved keywords and Unicode values that
can be used with the UNICODE text command. For information about rendering
Unicode characters, see “Managing the String on Text Statements” in Chapter 7 of SAS
Graph Template Language: User's Guide.
Note the following:
•
Keywords and Unicode values are not case-sensitive: "03B1"x is the same code point
as "03b1"x.
•
The word blank is the keyword for a blank space.
Lowercase Greek Letters
Keyword
Glyph
Unicode
Description
alpha
α
03B1
lowercase alpha
beta
β
03B2
lowercase beta
gamma
γ
03B3
lowercase gamma
delta
δ
03B4
lowercase delta
epsilon
ε
03B5
lowercase epsilon
zeta
ζ
03B6
lowercase zeta
eta
η
03B7
lowercase eta
theta
θ
03B8
lowercase theta
iota
ι
03B9
lowercase iota
kappa
κ
03BA
lowercase kappa
lambda
λ
03BB
lowercase lambda
475

Keyword
Glyph
Unicode
Description
mu
μ
03BC
lowercase mu
nu
ν
03BD
lowercase nu
xi
ξ
03BE
lowercase xi
omicron
ο
03BF
lowercase omicron
pi
π
03C0
lowercase pi
rho
ρ
03C1
lowercase rho
sigma
σ
03C3
lowercase sigma
tau
τ
03C4
lowercase tau
upsilon
υ
03C5
lowercase upsilon
phi
φ
03C6
lowercase phi
chi
χ
03C7
lowercase chi
psi
ψ
03C8
lowercase psi
omega
ω
03C9
lowercase omega
Uppercase Greek Letters
Table A1.1
Uppercase Greek Letters
Keyword
Glyph
Unicode
Description
alpha_u
Α
0391
uppercase alpha
beta_u
Β
0392
uppercase beta
gamma_u
Γ
0393
uppercase gamma
delta_u
Δ
0394
uppercase delta
epsilon_u
Ε
0395
uppercase epsilon
zeta_u
Ζ
0396
uppercase zeta
eta_u
Η
0397
uppercase eta
theta_u
Θ
0398
uppercase theta
476
Appendix 1
•
Reserved Keywords and Unicode Values

Keyword
Glyph
Unicode
Description
iota_u
Ι
0399
uppercase iota
kappa_u
Κ
039A
uppercase kappa
lambda_u
Λ
039B
uppercase lambda
mu_u
Μ
039C
uppercase mu
nu_u
Ν
039D
uppercase nu
xi_u
Ξ
039E
uppercase xi
omicron_u
Ο
039F
uppercase omicron
pi_u
Π
03A0
uppercase pi
rho_u
Ρ
03A1
uppercase rho
sigma_u
Σ
03A3
uppercase sigma
tau_u
Τ
03A4
uppercase theta
upsilon_u
Υ
03A5
uppercase upsilon
phi_u
Φ
03A6
uppercase phi
chi_u
Χ
03A7
uppercase chi
psi_u
Ψ
03A8
uppercase psi
omega_u
Ω
03A9
uppercase omega
Special Characters
Keyword
Glyph
Unicode
Description
prime
´
00B4
single prime sign
bar
̅
0305
combining overline*
bar2
̿
033F
combining double
overline*
tilde
̃
0303
combining tilde*
Reserved Keywords and Unicode Values
477

Keyword
Glyph
Unicode
Description
hat
̂
0302
combining
circumflex accent*
* This is an overstriking character that requires a Unicode font to render properly.
478
Appendix 1
•
Reserved Keywords and Unicode Values

Appendix 2
Graph Style Elements Used by
ODS Graphics
About the Graphical Style Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
General Graph Appearance Style Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
Graphical Data Representation Style Elements (Non-Grouped Data) . . . . . . . . . 482
Graphical Data Representation Style Elements (Grouped Data) . . . . . . . . . . . . . 486
Display Style Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
About the Graphical Style Elements
The style elements that are described in this appendix affect template-based graphics.
These style elements can be specified by Graph Template Language appearance options
or used in style definitions. The graphical style elements fall into the following
categories:
•
general graph appearance
•
graphical data representation (non-grouped data)
•
graphical data representation (grouped data)
•
display
The following sections list the graphical style elements that are in each of these
categories. For additional information about ODS style elements, see SAS Output
Delivery System: User's Guide
General Graph Appearance Style Elements
The following table lists the general graph appearance style elements.
479

Table A2.1
Graph Style Elements: General Graph Appearance
Style Element
Portion of Graph Affected
Recognized Attributes
Graph
Graph size and outer border
appearance
OutputWidth
OutputHeight
BorderColor
BorderWidth
CellPadding
CellSpacing
GraphAnnoLine
Annotation lines
ContrastColor
LineStyle
LineThickness
GraphAnnoShape
Annotation closed shapes such as
circles, and squares
Color
ContrastColor
LineThickness
LineStyle
Transparency
GraphAnnoText
Annotation text
Font
or font-attributes*
Color
MarkerSize
MarkerSymbol
GraphAxisLines
X, Y and Z axis lines
ContrastColor
LineStyle
LineThickness
TickDisplay
GraphBackground
Background of the graph
Color
Transparency
GraphBorderLines
Border around graph wall, legend
border, borders to complete axis frame
ContrastColor
LineThickness
LineStyle
GraphDataText
Text font and color for point and line
labels
Font
or font-attributes*
Color
GraphFootnoteText
Text font and color for footnote(s)
Font
or font-attributes*
Color
480
Appendix 2
•
Graph Style Elements Used by ODS Graphics

Style Element
Portion of Graph Affected
Recognized Attributes
GraphGridLines
Horizontal and vertical grid lines
drawn at major tick marks
ContrastColor
DisplayOpts
LineStyle
LineThickness
GraphHeaderBackground
Background color of the legend title
Color
GraphLabelText
Text font and color for axis labels and
legend titles
Font
or font-attributes*
Color
GraphLegendBackground
Background color of the legend
Color
GraphOutlines
Outline properties for fill areas such as
bars, pie slices, box plots, ellipses, and
histograms
Color
ContrastColor
LineStyle
LineThickness
GraphReference
Horizontal and vertical reference lines
and drop lines
ContrastColor
LineStyle
LineThickness
GraphTitleText
Text font and color for title(s)
Font
or font-attributes*
Color
GraphUnicodeText
Text font for unicode values
Font
orfont-attributes*
Color
GraphValueText
Text font and color for axis tick values
and legend values
Font
or font-attributes*
Color
GraphWalls
Vertical wall(s) bounded by axes
Color
FrameBorder
LineThickness
LineStyle
ContrastColor
* Font-attributes can be one of the following: FONTFAMILY=, FONTSIZE=, FONTSTYLE=, FONTWEIGHT=.
General Graph Appearance Style Elements
481

Graphical Data Representation Style Elements
(Non-Grouped Data)
The following table lists the graphical data representation style elements that affect non-
grouped data.
Table A2.2
Style Elements Affecting Graphical Data Representation
Style Element
Portion of Graph Affected
Recognized Attributes
GraphBoxMean
Marker for mean
ContrastColor
MarkerSize
MarkerSymbol
GraphBoxMedian
Line for median
ContrastColor
LineStyle
LineThickness
GraphBoxWhisker
Box whiskers and serifs
ConstrastColor
LineStyle
LineThickness
GraphConfidence
Primary confidence lines and bands,
colors for bands and lines
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
GraphConfidence2
Secondary confidence lines and bands,
color for bands, and contrast color for
lines
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
GraphConnectLine
Line for connecting boxes or bars
ContrastColor
LineStyle
LineThickness
482
Appendix 2
•
Graph Style Elements Used by ODS Graphics

Style Element
Portion of Graph Affected
Recognized Attributes
GraphDataDefault
Primitives related to non-grouped data
items, colors for filled areas, markers,
and lines
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
StartColor
NeutralColor
EndColor
GraphCutLine
Cutline attributes for a dendogram
Color
LineStyle
GraphDataDefault
Primitives related to non-grouped data
items, colors for filled areas, markers,
and lines
Color
ContrastColor
MarkerSymbol
MarkerSize
LineStyle
LineThickness
StartColor
NeutralColor
EndColor
GraphError
Error line or error bar fill,
ContrastColor for lines, Color for bar
fill
ContrastColor
Color
LineStyle
Transparency
GraphFit
Primary fit lines such as a normal
density curve
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
GraphFit2
Secondary fit lines such as a kernel
density curve
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
Graphical Data Representation Style Elements (Non-Grouped Data)
483

Style Element
Portion of Graph Affected
Recognized Attributes
GraphFinal
Final data for the waterfall chart.
Color applies to filled areas.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
GraphInitial
Initial data for the waterfall chart.
Color applies to filled areas.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
GraphMissing
Properties for graph items
representing missing values
ContrastColor
Color
MarkerSymbol
MarkerSize
LineStyle
LineThickness
Transparency
GraphOther
Other data for the graph. Color applies
to filled areas.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
GraphOverflow
Overflow data for the graph. Color
applies to filled areas. ContrastColor
applies to markers and lines.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
GraphOutlier
Outlier data for the graph
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
484
Appendix 2
•
Graph Style Elements Used by ODS Graphics

Style Element
Portion of Graph Affected
Recognized Attributes
GraphPrediction
Prediction lines
ContrastColor
Color
LineStyle
LineThickness
MarkerSize
MarkerSymbol
GraphPredictionLimits
Fills for prediction limits
ContrastColor
Color
MarkerSize
MarkerSymbol
GraphUnderflow
Underflow data for the graph. Color
applies to filled areas. ContrastColor
applies to markers and lines.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
TextColor
GraphSelection
For interactive graphs, visual
properties of selected item. Color for
selected fill area, ContrastColor for
selected marker or line.
ContrastColor
Color
MarkerSymbol
MarkerSize
LineStyle
LineThickness
ThreeColorAltRamp
Line contours, markers, and data
labels with segmented range color
response
StartColor
NeutralColor
EndColor
ThreeColorRamp
Gradient contours, surfaces, markers,
and data labels with continuous color
response
StartColor
NeutralColor
EndColor
TwoColorAltRamp
Line contours, markers, and data
labels with segmented range color
response
StartColor
EndColor
TwoColorRamp
Gradient contours, surfaces, markers,
and data labels with continuous color
response
StartColor
EndColor
Graphical Data Representation Style Elements (Non-Grouped Data)
485

Graphical Data Representation Style Elements
(Grouped Data)
The following table lists and describes the data-related style elements that effect grouped
data.
Table A2.3
Graphical Style Elements: Data Related (Grouped)
Style Element
Portion of Graph Affected
Recognized Attributes
GraphData1
Primitives related to 1st grouped data
items. Color applies to filled areas.
ContrastColor applies to markers and
lines.
Color
ContrastColor
FillPattern
LineStyle
MarkerSymbol
GraphData2
Primitives related to 2nd grouped data
items
Color
ContrastColor
FillPattern
LineStyle
MarkerSymbol
GraphData3
Primitives related to 3rd grouped data
items
Color
ContrastColor
FillPattern
LineStyle
MarkerSymbol
GraphData4
Primitives related to 4th grouped data
items
Color
ContrastColor
FillPattern
LineStyle
MarkerSymbol
GraphData5
Primitives related to 5th grouped data
items
Color
ContrastColor
FillPattern
LineStyle
MarkerSymbol
486
Appendix 2
•
Graph Style Elements Used by ODS Graphics

Style Element
Portion of Graph Affected
Recognized Attributes
GraphData6
Primitives related to 6th grouped data
items
Color
ContrastColor
FillPattern
LineStyle
MarkerSymbol
GraphData7
Primitives related to 7th grouped data
items
Color
ContrastColor
FillPattern
LineStyle
MarkerSymbol
GraphData8
Primitives related to 8th grouped data
items
Color
ContrastColor
FillPattern
LineStyle
GraphData9
Primitives related to 9th grouped data
items
Color
ContrastColor
FillPattern
LineStyle
GraphData10
Primitives related to 10th grouped
data items
Color
ContrastColor
FillPattern
LineStyle
GraphData11
Primitives related to 11th grouped
data items
Color
ContrastColor
FillPattern
LineStyle
GraphData12
Primitives related to 12th grouped
data items
Color
ContrastColor
FillPattern
Display Style Elements
The following table lists the display style elements.
Display Style Elements
487

Table A2.4
Style Elements Affecting Graphical Data Representation
Style Element
Portion of Graph Affected
Recognized Attributes
GraphBoxMean
Marker for mean
ContrastColor
MarkerSize
MarkerSymbol
GraphBoxMedian
Line for median
ContrastColor
LineStyle
LineThickness
GraphBoxWhisker
Box whiskers and serifs
ConstrastColor
LineStyle
LineThickness
GraphConfidence
Primary confidence lines and bands,
colors for bands and lines
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
GraphConfidence2
Secondary confidence lines and bands,
color for bands, and contrast color for
lines
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
GraphConnectLine
Line for connecting boxes or bars
ContrastColor
LineStyle
LineThickness
GraphDataDefault
Primitives related to non-grouped data
items, colors for filled areas, markers,
and lines
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
StartColor
NeutralColor
EndColor
488
Appendix 2
•
Graph Style Elements Used by ODS Graphics

Style Element
Portion of Graph Affected
Recognized Attributes
GraphCutLine
Cutline attributes for a dendogram
Color
LineStyle
GraphDataDefault
Primitives related to non-grouped data
items, colors for filled areas, markers,
and lines
Color
ContrastColor
MarkerSymbol
MarkerSize
LineStyle
LineThickness
StartColor
NeutralColor
EndColor
GraphError
Error line or error bar fill,
ContrastColor for lines, Color for bar
fill
ContrastColor
Color
LineStyle
Transparency
GraphFit
Primary fit lines such as a normal
density curve
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
GraphFit2
Secondary fit lines such as a kernel
density curve
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
GraphFinal
Final data for the waterfall chart.
Color applies to filled areas.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
Display Style Elements
489

Style Element
Portion of Graph Affected
Recognized Attributes
GraphInitial
Initial data for the waterfall chart.
Color applies to filled areas.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
GraphMissing
Properties for graph items
representing missing values
ContrastColor
Color
MarkerSymbol
MarkerSize
LineStyle
LineThickness
Transparency
GraphOther
Other data for the graph. Color applies
to filled areas.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
GraphOverflow
Overflow data for the graph. Color
applies to filled areas. ContrastColor
applies to markers and lines.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
GraphOutlier
Outlier data for the graph
ContrastColor
Color
MarkerSize
MarkerSymbol
LineStyle
LineThickness
GraphPrediction
Prediction lines
ContrastColor
Color
LineStyle
LineThickness
MarkerSize
MarkerSymbol
490
Appendix 2
•
Graph Style Elements Used by ODS Graphics

Style Element
Portion of Graph Affected
Recognized Attributes
GraphPredictionLimits
Fills for prediction limits
ContrastColor
Color
MarkerSize
MarkerSymbol
GraphUnderflow
Underflow data for the graph. Color
applies to filled areas. ContrastColor
applies to markers and lines.
Color
ContrastColor
LineStyle
LineThickness
MarkerSize
MarkerSymbol
TextColor
GraphSelection
For interactive graphs, visual
properties of selected item. Color for
selected fill area, ContrastColor for
selected marker or line.
ContrastColor
Color
MarkerSymbol
MarkerSize
LineStyle
LineThickness
ThreeColorAltRamp
Line contours, markers, and data
labels with segmented range color
response
StartColor
NeutralColor
EndColor
ThreeColorRamp
Gradient contours, surfaces, markers,
and data labels with continuous color
response
StartColor
NeutralColor
EndColor
TwoColorAltRamp
Line contours, markers, and data
labels with segmented range color
response
StartColor
EndColor
TwoColorRamp
Gradient contours, surfaces, markers,
and data labels with continuous color
response
StartColor
EndColor
Display Style Elements
491

492
Appendix 2
•
Graph Style Elements Used by ODS Graphics

Appendix 3
Display Attributes
General Syntax for Attribute Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Attributes Available for the Attribute Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . 494
Fill Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 494
Line Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 494
Marker Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 496
Text Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 497
Available Line Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 497
General Syntax for Attribute Options
Most statements provide options that enable you to specify attributes for the fills, lines,
data markers, or text that is used in the display. For example, many plots provide a
DATALABELATTRS= option that specifies the attributes of the data labels. This
appendix discusses the general syntax for those options and the valid values for they
accept.
A statement’s attribute options use the following general syntax:
ATTRSOPTIONNAME= style-element | style-element (options) | (options)
style-element
Name of a style element. Only style attributes relevant for rendering the fill, line,
data marker, or text are used. Example:
Example
ATTRSOPTIONNAME=GRAPHVALUETEXT
style-element (options)
Name of a style element, plus individual options to be used as style overrides. Any
options not specified are derived from the specified style-element.Example:
Example
ATTRSOPTIONNAME=GRAPHVALUETEXT(SIZE=10pt)
(options)
Individual options. Any options not specified are derived from the default style
element. Examples:
Example
ATTRSOPTIONNAME=(FAMILY="Arial" SIZE=10pt)
493

ATTRSOPTIONNAME=(FAMILY=GraphValueText:FontFamily)
Depending on the attribute option used, the options might be fill-options , line-options , 
marker-options , or text-options .
In general, any relevant attribute that is not specified default to some internal value,
typically those from the default style element of the style-element you specify for the
attributes. When choosing a style element, you should use an element of the correct type.
See SAS Output Delivery System: User's Guide for a list of style elements and their
types.
Attributes Available for the Attribute Options
Depending on the attribute option used on a statement, the available attributes might be 
fill-options , line-options , marker-options , or text-options .
Fill Options
When specifying the attributes for an area fill, the fill-options can be one or more of the
following settings. The option must be enclosed in parentheses and specified as a name
= value pair. The value can be a style-reference in the form style-element:style-attribute.
COLOR=style-reference | color
specifies the fill color . If you use a style-reference, the style-attribute should be a
valid attribute such as COLOR, CONTRASTCOLOR, STARTCOLOR, NEUTRAL,
ENDCOLOR. The convention is to use the COLOR attribute for fill areas.
If you use a color, SAS accepts color names, such as RED, or color codes, such as
CXFF0000 or #FF0000. Color names must not exceed 64 characters. Color codes
must not exceed 8 characters and must be in a valid SAS color-naming scheme, such
as RGB, CMYK, HLS, or HSV (HSB).
TRANSPARENCY=number
specifies the degree of the transparency of the filled area. This setting enables you to
set the transparency for the filled elements of some graph types. You can set just this
fill transparency, or set the fill independently of the other transparent elements in the
graph. For example, you can use this setting to set the transparency level for the
filled bars of a bar chart, and use the bar chart’s DATATRANSPARENCY= option
to set a different transparency level for the bar outlines.
Default
The same as the setting of the statement’s DATATRANSPARENCY=
option.
Range
0 (opaque) to 1 (entirely transparent)
Interaction
This setting overrides the statement’s DATATRANSPARENCY=
setting for the fills but not for the outlines.
Example
 fillattrs=(transparency=0.5) 
Line Options
When specifying the attributes for a line, the available line-options can be any one or
more of the following settings. The options must be enclosed in parentheses, and each
494
Appendix 3
•
Display Attributes

option is specified as a name = value pair. In all cases, the value can be a style-reference
in the form style-element:style-attribute.
COLOR=style-reference | color
specifies the line color. If you use a style-reference, the style-attribute should be a
valid attribute such as COLOR, CONTRASTCOLOR, STARTCOLOR, NEUTRAL,
ENDCOLOR. The convention is to use CONTRASTCOLOR for lines. If you
specify a style element that does not have a CONTRASTCOLOR attribute, the
element’s COLOR attribute is used.
If you use a color, SAS accepts color names, such as RED, or color codes, such as
CXFF0000 or #FF0000. Color names must not exceed 64 characters. Color codes
must not exceed 8 characters and must be in a valid SAS color-naming scheme, such
as RGB, CMYK, HLS, or HSV (HSB).
PATTERN=style-reference | line-pattern-name | line-pattern-number
specifies the line pattern. If you use a style-reference, the style-attribute should be
LINESTYLE.
Line patterns can be specified as a pattern name or pattern number.
Valid pattern numbers range from 1 to 46. Not all pattern numbers have names. See
“Available Line Patterns” on page 497 for a list of all possible line patterns. We
recommend that you use the named patterns because they have been optimized to
provide good discriminability when used in the same plot.
Note
Anti-aliasing might alter the appearance of some line patterns that have fine
detail such as line patterns 33 through 46. For example, if you specify the
color black and the pattern 33 for a line, and anti-aliasing is enabled, the line
might appear gray. In that case, you can use the following command to
disable anti-aliasing in order to show the line detail:
ods graphics / antialias=off;
THICKNESS=style-reference | dimension
specifies the line thickness. If you use a style-reference, the style-attribute should be
LINETHICKNESS.
Attributes Available for the Attribute Options
495

Marker Options
When specifying the attributes for a data marker, the available marker-options can be
any one or more of the following settings. The options must be enclosed in parentheses,
and each option is specified as a name = value pair. In all cases, the value can be a style-
reference in the form style-element:style-attribute.
COLOR=style-reference | color
specifies the color of the marker. If you use a style-reference, the style-attribute
should be a valid attribute such as COLOR, CONTRASTCOLOR, STARTCOLOR,
NEUTRAL, ENDCOLOR. The convention is to use CONTRASTCOLOR for
markers. For grouped data, this option keeps all markers the same color and the
marker symbol alone distinguishes the group values.
If you use a color, SAS accepts color names, such as RED, or color codes, such as
CXFF0000 or #FF0000. Color names must not exceed 64 characters. Color codes
must not exceed 8 characters and must be in a valid SAS color-naming scheme, such
as RGB, CMYK, HLS, or HSV (HSB).
SIZE=style-reference | dimension
specifies the marker size (both width and height). If you use a style-reference, the
style-attribute should be MARKERSIZE.
SYMBOL=style-reference | marker-name
specifies the name of the marker. If you use a style-reference, the style-attribute
should be MARKERSYMBOL. The following symbols are supported:
TRANSPARENCY=number
specifies the degree of transparency for the plot markers.
Default
The transparency that is specified by the DATATRANSPARENCY=
option, which is 0 by default.
Range
0 (opaque) to 1 (entirely transparent)
Interaction
This suboption overrides the DATATRANSPARENCY= option for the
plot markers only.
WEIGHT=NORMAL | BOLD
specifies the marker weight.
496
Appendix 3
•
Display Attributes

Text Options
When specifying the attributes for text, the available text-options can be any one or more
of the following settings. The options must be enclosed in parentheses, and each option
is specified as a name = value pair. In all cases, the value can be a style-reference in the
form style-element:style-attribute.
COLOR=style-reference | color
specifies the color of the text. If you use a style-reference, the style-attribute should
be a valid attribute such as COLOR, CONTRASTCOLOR, STARTCOLOR,
NEUTRAL, ENDCOLOR. The convention is to use COLOR for text.
If you use a color, SAS accepts color names, such as RED, or color codes, such as
CXFF0000 or #FF0000. Color names must not exceed 64 characters. Color codes
must not exceed 8 characters and must be in a valid SAS color-naming scheme, such
as RGB, CMYK, HLS, or HSV (HSB).
FAMILY=style-reference | "string"
specifies the font family of the text. If you use a style-reference, the style-attribute
should be FONTFAMILY.
SIZE=style-reference | dimension
specifies the font size of the text. If you use a style-reference, the style-attribute
should be FONTSIZE.
STYLE=style-reference | NORMAL | ITALIC
specifies the font style of the text. If you use a style-reference, the style-attribute
should be FONTSTYLE.
WEIGHT=style-reference | NORMAL | BOLD
specifies the font weight of the text. If you use a style-reference, the style-attribute
should be FONTWEIGHT.
Available Line Patterns
The following line patterns can be used with the Graphics Template Language. A line
pattern can be specified by its number or name. Not all patterns have names. We
recommend that you use the named patterns because they have been optimized to
provide good discriminability when used in the same plot.
Available Line Patterns
497

498
Appendix 3
•
Display Attributes

Appendix 4
Tick Value Fit Policy Applicability
Table A4.1 on page 500 provides a matrix of the tick value fit policies and the axes to
which each applies in the OVERLAY, LATTICE, DATALATTICE, DATAPANEL, and
EQUATED layouts. In the matrix, the notations V, H, and B are used to indicate the
axes to which each policy applies for a specific case. V indicates that the policy applies
to the vertical axis only (Y, Y2, and row axes). H indicates that the policy applies to the
horizontal axes only (X, X2, and column axes). B indicates that the policy applies to
both the horizontal and vertical axes.
499

Table A4.1
Tick Value Fit Policy Applicability Matrix
Fit Policy
LAYOUT OVERLAY
LAYOUT LATTICE
LAYOUT DATALATTICE
LAYOUT DATAPANEL
LAYOUT
EQUATED
Notes
Discrete
Axes
Linear
Axes
Time
Axes
Discrete
Axes
Linear
Axes
Time
Axes
NONE
V
V
No adjustment is attempted.
ROTATE
H
H
H
H
H
H
H
The tick values are rotated 45 degrees when a
collision occurs.
ROTATEALWAYS
H
H
H
H
H
H
H
The tick values are always rotated 45 degrees
regardless of whether a collision occurs.
ROTATEALWAYSDROP
H
H
The tick values are always rotated 45 degrees
regardless of whether a collision occurs. If
unsuccessful, the values are dropped.
ROTATETHIN
H
H
H
H
H
H
H
The ROTATE policy is attempted first. If
unsuccessful, the THIN policy is applied.
SPLIT
B
B
The tick values on a discrete axis are split into
multiple lines on blank spaces by default when a
collision occurs.
SPLITALWAYS
B
B
The tick values on a discrete axis are always split into
multiple lines on every blank space in the value by
default regardless of whether a collision occurs.
SPLITALWAYSTHIN
V
V
The SPLITALWAYS policy is attempted first. If
unsuccessful, the THIN policy is applied.
SPLITROTATE
H
H
The SPLIT policy is attempted first. If unsuccessful,
the ROTATE policy is applied.
500
Appendix 4
•
Tick Value Fit Policy Applicability

Fit Policy
LAYOUT OVERLAY
LAYOUT LATTICE
LAYOUT DATALATTICE
LAYOUT DATAPANEL
LAYOUT
EQUATED
Notes
Discrete
Axes
Linear
Axes
Time
Axes
Discrete
Axes
Linear
Axes
Time
Axes
SPLITTHIN
V
V
The SPLIT policy is attempted first. If unsuccessful,
the THIN policy is applied.
STAGGER
H
H
H
H
H
H
H
The tick values alternate between two rows.
STAGGERROTATE
H
H
H
H
H
H
H
The STAGGER policy is attempted first. If
unsuccessful, the ROTATE policy is applied.
STAGGERTHIN
H
H
H
H
H
H
H
The STAGGER policy is attempted first. If
unsuccessful, the THIN policy is applied.
STAGGERTRUNCATE
H
H
The STAGGER policy is attempted first. If
unsuccessful, the TRUNCATE policy is applied.
TRUNCATE
H
H
The tick values are shortened.
TRUNCATEROTATE
H
H
The TRUNCATE policy is attempted first. If
unsuccessful, the ROTATE policy is applied.
TRUNCATESTAGGER
H
H
The TRUNCATE policy is attempted first. If
unsuccessful, the STAGGER policy is applied.
TRUNCATETHIN
H
H
The TRUNCATE policy is attempted first. If
unsuccessful, the THIN policy is applied.
THIN
B
B
H
B
B
H
B
Some tick values are removed.
EXTRACT
B
B
The tick values are extracted to an axis legend only if
the values cannot be fit on the axis.
Tick Value Fit Policy Applicability Matrix
501

Fit Policy
LAYOUT OVERLAY
LAYOUT LATTICE
LAYOUT DATALATTICE
LAYOUT DATAPANEL
LAYOUT
EQUATED
Notes
Discrete
Axes
Linear
Axes
Time
Axes
Discrete
Axes
Linear
Axes
Time
Axes
EXTRACTALWAYS
B
B
The tick values are always extracted to an axis legend
even if the values can be fit on the axis.
502
Appendix 4
•
Tick Value Fit Policy Applicability

Appendix 5
SAS Formats Not Supported
Using SAS Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
Unsupported Numeric Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
Unsupported Date and Time Formats Related to ISO 8601 . . . . . . . . . . . . . . . . . . 504
Other Unsupported Date and Time Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504
Unsupported Currency Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
Using SAS Formats
SAS formats can be assigned to input data columns with the FORMAT statement of the
SGRENDER procedure. Also, several GTL statement options enable a SAS format as an
option value. Examples include the TICKVALUEFORMAT= option for formatting axis
tick values, and the TIPFORMAT= option for formatting data tips.
Not all SAS formats are supported in the GTL or with the SGPLOT, SGSCATTER,
SGPANEL, and SGRENDER procedures. The tables in the following sections show the
character and numeric SAS formats that are not supported.
When the GTL encounters an unsupported format, a note similar to the following is
written to the SAS log:
TICKVALUEFORMAT=bestx. is invalid. The format is invalid or unsupported. The 
default will be used.
Unsupported Numeric Formats
The following numeric formats are not supported in the GTL:
BESTD
BESTX
D
FLOAT
FRACT
FREE
IB
IBR
IEEE
IEEER
ODDSR
PCPIB
PD
PIB
PIBR
503

PK
RB
SSN
WORDF
WORDS
Z
ZD
Unsupported Date and Time Formats Related to
ISO 8601
The following date and time formats are not supported in the GTL:
$N8601B
$N8601BA
$N8601E
$N8601EA
$N8601EH
$N8601EX
$N8601H
$N8601X
B8601DA
B8601DN
B8601DT
B8601DZ
B8601LZ
B8601TM
B8601TZ
E8601DA
E8601DN
E8601DT
E8601DZ
E8601LZ
E8601TM
E8601TZ
IS8601DA
IS8601DN
IS8601DT
IS8601DZ
IS8601LZ
IS8601TM
IS8601TZ
Other Unsupported Date and Time Formats
The following date and time formats are not supported in the GTL:
HDATE
HEBDATE
JDATEMDW
JDATEMNW
JDATEWK
JDATEYDW
JDATEYM
JDATEYMD
JDATEYMW
JDATEYT
JDATEYTW
JNENGO
JNENGOT
JNENGOTW
JNENGOW
JTIMEH
JTIMEHM
JTIMEHMS
JTIMEHW
JTIMEMW
JTIMESW
MDYAMPM
MINGUO
NENGO
NLDATEYQ
NLDATEYR
NLDATEYW
NLDATMYQ
NLDATMYR
NLDATMYW
NLSTRMON
NLSTRQTR
NLSTRWK
PDJULG
PDJULI
TWMDY
XYYMMDD
YYQZ
504
Appendix 5
•
SAS Formats Not Supported

Unsupported Currency Formats
The following currency formats are not supported in the GTL:
EURFRATS
EURFRBEF
EURFRCHF
EURFRCZK
EURFRDEM
EURFRDKK
EURFRESP
EURFRFIM
EURFRFRF
EURFRGBP
EURFRGRD
EURFRHUF
EURFRIEP
EURFRITL
EURFRLUF
EURFRNLG
EURFRNOK
EURFRPLZ
EURFRPTE
EURFRROL
EURFRRUR
EURFRSEK
EURFRSIT
EURFRTRL
EURFRYUD
EURTOATS
EURTOBEF
EURTOCHF
EURTOCZK
EURTODEM
EURTODKK
EURTOESP
EURTOFIM
EURTOFRF
EURTOGBP
EURTOGRD
EURTOHUF
EURTOIEP
EURTOITL
EURTOLUF
EURTONLG
EURTONOK
EURTOPLZ
EURTOPTE
EURTOROL
EURTORUR
EURTOSEK
EURTOSIT
EURTOTRL
EURTOYUD
Unsupported Currency Formats
505

506
Appendix 5
•
SAS Formats Not Supported

Appendix 6
Memory Management for ODS
Graphics
SAS Options Affecting Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507
Managing a Java Out of Memory Error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507
SAS Options Affecting Memory
ODS Graphics uses Java technology to produce its graphs. Most of the time this fact is
transparent to you because the required Java Runtime Environment (JRE) and JAR files
are included with SAS software installation. Also, the Java environment is automatically
started and stopped for you. When Java is started, it allocates a fixed amount of memory.
The memory can grow up to the value set for the -Xmx suboption in the JREOPTIONS
option (discussed in a moment). This memory is independent of the memory limit that
SAS sets for the SAS session with its MEMSIZE= option.
Normally, the memory limit for Java is sufficient for most ODS Graphics applications.
However, some tasks are very memory intensive and might exhaust all available Java
memory, resulting in an OutOfMemoryError condition. You might encounter Java
memory limitations when
•
the product of the output size and the DPI setting results in very large output
•
a classification panel has a very large number of classifier crossings
•
a scatter plot matrix has a large number of variables
•
creating 3-D plots and 2-D contours, which are memory intensive to generate
•
a plot has a very large number of marker labels
•
a plot uses many character variables or has a large number of GROUP values
•
using the SG Editor to edit a graph with a large amount of data.
Managing a Java Out of Memory Error
If you encounter a Java OutOfMemoryError, you can try executing your program again
by restarting SAS and specifying a larger amount of memory for Java at SAS invocation.
To determine what the current Java memory settings are, you can submit a PROC
OPTIONS statement that shows the value of the JREOPTIONS option:
507

proc options option=jreoptions; 
run;
After you submit this procedure code, a list of JREOPTIONS settings is displayed in the
SAS log. The JREOPTIONS option has many suboptions that configure the SAS Java
environment. Many of the suboptions are installation and host specific and should not be
modified, especially the ones that provide installed file locations. For managing
memory, look for the -Xmx and -Xms suboptions:
JREOPTIONS=(/* other Java suboptions */ -Xmx128m -Xms128m)
-Xms
Use this option to set the minimum Java memory (heap) size, in bytes. Set this value
to a multiple of 1024 greater than 1MB. Append the letter k or K to indicate
kilobytes, or m or M to indicate megabytes. The default is 2MB. Examples:
-Xms6291456
-Xms6144k
-Xms6m
-Xmx
Use this option to set the maximum size, in bytes, of the memory allocation pool. Set
this value to a multiple of 1024 greater than 2MB. Append the letter k or K to
indicate kilobytes, or m or M to indicate megabytes. The default is 64MB. Examples:
-Xmx83886080
-Xmx81920k
-Xmx80m
As a general rule, you should set the minimum heap size (-Xms) equal to the maximum
heap size (-Xmx) to minimize garbage collections.
Typically, SAS sets both -Xms and -Xmx to be about 1/4 of the total available memory
or a maximum of 128M. However, you can set a more aggressive maximum memory
(heap) size, but it should never be more than 1/2 of physical memory.
You should be aware of the maximum amount of physical memory your computer has
available. Let us assume that doubling the Java memory allocation is feasible. So when
you start SAS from a system prompt, you can add the following option:
-jreoptions (-Xmx256m -Xms256m)
Alternatively, you might need to specify the setting in quotation marks:
-jreoptions '(-Xmx256m -Xms256m)'
The exact syntax varies for specifying Java options, depending on your operating
system, and the amount of memory that you can allocate varies from system to system.
The set of JRE options must be enclosed in parentheses. If you specify multiple
JREOPTIONS system options, SAS appends JRE options to JRE options that are
currently defined. Incorrect JRE options are ignored.
If you choose to create a custom configuration file, you would simply replace the
existing -Xms and -Xmx suboption values in the JREOPTIONS=(all Java options)
portion of the configuration file.
For more information, see the SAS Companion for your operating system.
508
Appendix 6
•
Memory Management for ODS Graphics

Appendix 7
ODS Graphics and SAS/GRAPH
SAS produces graphics using two very distinct systems: ODS Graphics and
SAS/GRAPH. ODS Graphics and the GTL produce graphics through the Output
Delivery System (ODS) using a template-based system. SAS/GRAPH produces graphics
using a device-based system. You can use both systems to generate your graphical
output. That is, you can use SAS/GRAPH to generate the output for some jobs, and ODS
Graphics to generate the output for others. To help you understand the differences
between the two systems in that case, here is a comparison:
•
The GTL does not produce GRSEGs or use device drivers. The output format that is
produced is specified by the OUTPUTFMT= option in the ODS GRAPHICS
statement. The GTL produces all output in industry standard output formats such as
PNG, GIF, JPEG, WMF, TIFF, PDF, EMF, PS, PCL, and SVG. Most SAS/GRAPH
procedures produce a GRSEG entry in a SAS catalog. Other output formats in
SAS/GRAPH, such as an image or metagraphics file, can be created by selecting an
appropriate device driver such as PNG, JPEG, or GIF.
•
The GTL has a layout-centric architecture. Each graph contains components such as
plots, insets, and legends that can be combined in flexible ways inside layout
containers to build complex graphs. Several layout types are available, some that
produce a graph in a single cell and others that produce a graph as a panel of cells. In
most cases, the components used in the single-cell graphs can also be used in the
multi-cell graphs.
•
The GTL global options are specified in the ODS GRAPHICS statement or in the
ODS destination statement. The GTL does not use the traditional SAS/GRAPH
global statements, such as SYMBOL, PATTERN, AXIS, LEGEND, and
GOPTIONS.
•
The GTL statements and options provide control over the visual properties of a
graph. The SAS/GRAPH global statements such as GOPTIONS, AXIS, LEGEND,
PATTERN, SYMBOL, and NOTE control the properties for text, markers, and lines.
•
The GTL controls the size, format, and name of output images with the HEIGHT=,
WIDTH=, OUTPUTFMT=, and IMAGENAME= options in the ODS GRAPHICS
statement. The ODS GRAPHICS statement is similar in purpose to the GOPTIONS
statement. SAS/GRAPH controls the size and format of graphical output with
options such as HSIZE=, VSIZE=, and DEVICE= in the GOPTIONS statement.
•
The GTL axes, backgrounds, titles, legends, and the other graph components are
managed by the layout containers and do not belong to an individual plot.
•
Titles and footnotes produced by the SAS TITLE and FOOTNOTE statements do
not appear in graphs that are generated using the GTL. The GTL has its own
statements for producing titles and footnotes. (However, the SGPLOT, SGPANEL,
and SGSCATTER procedures support the TITLE and FOOTNOTE statements. They
generate GTL behind the scenes.)
509

•
The GTL plot type is determined by the plot statement. A plot statement is provided
for each plot type. The SAS/GRAPH plot type is determined by global options for
some graphs. For example, the INTERPOL= option in the SYMBOL statement
might determine whether a graph is a scatter plot or a box plot.
•
The GTL graphical attributes for markers, lines, color, and so on, are derived by
default from the active ODS style, which cannot be turned off. SAS/GRAPH also
uses ODS styles by default. However, with SAS/GRAPH, the style can be turned off
and the appearance information that is specified in the device entries used instead.
For more information about ODS styles, see Chapter 6, “Managing Graph
Appearance: General Principles,” on page 111.
•
The GTL supports all of the ODS destinations. For the LISTING destination, an
image node is created for the graph in the Results tree. To view the graph, it must be
manually opened in an external viewer or in the ODS Graphics Editor. SAS/GRAPH
also supports all of the ODS destinations. However, for the LISTING destination,
SAS/GRAPH creates a GRSEG node in the Results tree, and the image appears in
the graph window automatically.
•
The GTL supports scaling of fonts and markers by default. This means that the sizes
of fonts and markers are adjusted as appropriate to the size of your graph. Font and
marker scaling is disabled by the NOSCALE option in the ODS GRAPHICS
statement. SAS/GRAPH does not support scaling of fonts and markers.
•
The GTL does not support the SAS/GRAPH Annotate facility. The GTL annotation
facility or the GTL draw statements can be used to add a variety of data-driven or
non-data-driven graphical elements to graphs. For information about using the GTL
annotation facility, see Chapter 20, “Adding Data-Driven Annotations to a Graph,”
on page 417. For information about using the GTL draw statements, see Chapter 19,
“Adding Non-Data-Driven Graphics Elements to a Graph,” on page 405. You can
also use the ODS Graphics Editor to add annotations to your graphs. See SAS ODS
Graphics Editor: User's Guide.
•
The GTL does not support RUN-group processing. SAS/GRAPH supports RUN-
group processing for some procedures.
510
Appendix 7
•
ODS Graphics and SAS/GRAPH

Glossary
anti-aliasing
a rendering technique for improving the appearance of text and curved lines in a
graph by blurring the jagged edges normally present. The degree of improvement is
relative to the nature of the graphical content (for example, vertical and horizontal
lines do not benefit from anti-aliasing). Extra processing is required to perform anti-
aliasing.
attribute bundle
a common collection of visual properties associated with a graphical primitive such
as a line, marker, or text. For example, all lines have visual properties of pattern,
thickness, and color. All markers have visual properties of symbol, size, weight, and
color. Attribute bundles can be associated with style elements in order to indirectly
assign visual properties.
axis
a line that represents the midpoints (for a discrete axis) or the scale (for a continuous
or interval axis) for graphing variable or data values. An axis typically consists of an
axis line with tick marks, tick values (or midpoint values), and a label.
axis offset
the gaps that normally appear at the ends of an axis line. The gaps enable markers,
bars, and other graphic primitives that are drawn at extreme data values to be
rendered without clipping. An offset can also be used to add extra space between an
axis line and visual elements in the graph.
axis threshold
a numerical bias from 0 to 1 that determines whether an extra tick is added at either
end of a non-discrete, interval axis. If the minimum and maximum thresholds are set
to 0, then no ticks are added beyond the actual data range. If both minimum and
maximum thresholds are set to 1, then the data range is completely bounded by the
first and last ticks.
axis tick mark
a short line segment perpendicular to the axis line. A tick can cross the axis line, or
be drawn from the axis inside or outside the wall.
axis tick value
a formatted data value represented by a tick mark.
511

axis type
a keyword that denotes axis functionality. For example, the axis type of interval axes
can be LINEAR, TIME, or LOG. The axis type of a discrete axis is DISCRETE.
axis viewport
the range of values displayed on an interval axis. This range can be larger or smaller
than the actual data range of the axis. An axis viewport that is larger than the data
range effectively zooms out from the plot or plots. An axis viewport that is smaller
than the data range zooms in on the plot or plots.
band plot
a plot that draws a horizontal band with two Y values for each X value, or that draws
a vertical band with two X values for each Y value. A band plot is typically used to
show confidence, error, prediction, or control limits. The points on the upper and
lower band boundaries can be joined to create two outlines, or the area between the
boundaries can be filled.
bin
one of multiple numeric intervals into which continuous numeric data can be
categorized.
binned data
data that has been summarized or transformed in some way to facilitate its rendering
by a parameterized plot. Continuous numeric data is typically binned by setting a bin
width (interval size) and then computing the number of bins, or by setting the
number of bins and computing the bin width.
block
See statement block
block plot
a plot that displays one or more rectangles (blocks) along an axis, where each
rectangle identifies a block of consecutive observations having the same value for a
specified block variable.
category variable
a classification variable with a finite number of distinct (discrete) values. These
variables are typically used to split data into subsets. For example, in a bar chart,
each unique value is displayed as a bar on a DISCRETE axis. In another example,
the variable payment mode can have two values, prepaid and postpaid. Customers
can be classified based on this variable as prepaid customers and postpaid customers.
cell
in ODS graphics, a distinct rectangular subregion of a graph that can contain plots,
text, or legends.
cell block
a block beginning with a CELL statement and ending with an ENDCELL statement
that defines the graphical content of a cell. The cell block is available only within a
LATTICE layout.
cell header
a graphical element (typically text or a legend) that is aligned at the top of a cell and
provides information about the cell contents. A cell header is defined within a cell
block, which is available only within a LATTICE layout.
512
Glossary

child block
a block that is contained within another block when two or more blocks are nested.
For example, a CELLHEADER block is always a child of a CELL block.
class variable
See classification variable
classification level
for a single classification variable, each unique value is regarded as a classification
level. For two or more variables, a classification level is one of the unique
combinations (crossings) of the unique values of each variable. For example, if three
variables have four, two, and three distinct values, there are 24 classification levels.
classification panel
a multi-cell graph in which the cell data is driven by the values of one or more
classification variables. The number of the cells is determined by the unique values
of the classification variables. Each cell of the panel has the same types of plots.
classification variable
a variable whose values are used to classify the observations in a data set into
different groups that are meaningful for analysis. A classification variable can have
either character or numeric values. Classification variables include group, subgroup,
category, and BY variables.
clip
to truncate a plot or graphical element (such as a line, marker, or band) when it
reaches a boundary such as a plot wall.
column
a set of layout cells that are stacked vertically and share the same alignment.
column axis
an external axis appearing above or below a column of cells and serving as a
common reference for the column of a multi-cell layout, such as a LATTICE,
DATAPANEL, or DATALATTICE layout.
column gutter
the space between columns of cells in a multi-cell layout.
column header
text that labels the column contents in a multi-cell layout. This text can be aligned
above or below the cells in a column. In a LATTICE layout, the column header is
not restricted to text (it can contain a plot or a legend, for example).
column major order
an order for populating cells of a layout or entries in a legend when the number of
rows is specified. By default, cells or entries are filled starting from the top left and
moving down. When the bottom row of the first column is filled, a new column
begins filling to the right of the previous column, and so on until all content items
have been placed in cells or entries. There might be empty cells or entries in the last
column.
column weight
in a LATTICE layout, the proportion of width allotted to a specific column of the
layout. The sum of all column weights is 1.
Glossary
513

computed plot
a plot in which input data is internally summarized or otherwise transformed to
create new data that is actually rendered by the plot. Examples of computed plot
statements are BARCHART, BOXPLOT, HISTOGRAM, ELLIPSE, and
REGRESSIONPLOT.
conditional logic
syntax that enables one set of statements or an optional alternate set of statements to
execute at run time.
continuous legend
a legend that shows a mapping between a color ramp or color segments and
corresponding numeric values. Plots that support a COLORMODEL= option can use
this type of legend.
crossing
a combination of the unique values of one or more classification variables.
cube
in three-dimensional graphics, the outlines formed by the intersection of three pairs
of parallel planes; each pair is orthogonal to the primary X, Y, and Z axes. The
display of the cube is optional.
data object
a transient version of a SAS data set created by ODS. When an input SAS data set is
bound to a compiled graph template, an ODS data object is created, based on all the
columns requested in the template definition and any new columns that have been
directly or indirectly computed. A data object can persist when used with the ODS
OUTPUT statement.
data tip
data or other detailed information that is displayed when a user positions a mouse
pointer over an element in a graph. For example, a data tip typically displays the data
value that is represented by a bar, a plot point, or some other element.
define block
in the TEMPLATE procedure, a define block (beginning with a DEFINE statement
and ending with an END statement) creates various types of templates, including
STATGRAPH, STYLE, and TABLE.
dependent plot
a plot that cannot be rendered by itself. Dependent plots must be overlaid with a
stand-alone plot. Dependent plots do not provide data ranges to establish axes.
REFERENCELINE, DROPLINE, and LINEPARM statements produce dependent
plots.
design size
the intended size of a graph that is specified in the graph template definition. The
DESIGNHEIGHT and DESIGNWIDTH options of the BEGINGRAPH statement
set the intended height and width, which are used to determine the scale factors when
the graph is resized. The intended height and width are used unless overridden by the
ODS Graphics statement HEIGHT or WIDTH options when the template is
executed.
514
Glossary

device-based graphic
a graph created with SAS/GRAPH software for which a user-specified or default
device (DEVICE= option) controls certain aspects of the graphical output.
discrete axis
an axis for categorical data values. The distance between ticks has no significance. A
bar chart always has a discrete axis.
discrete legend
a legend that provides values or descriptive information about graphical elements in
a grouped or overlaid plot.
dots per inch
a measure of the graph resolution by its dot density. Short form: DPI.
DPI
See dots per inch
drop line
a line drawn from a point in the plot area perpendicular to an axis.
dynamic variable
a variable defined in a template with the DYNAMIC statement that can be initialized
at template run time.
equated axes
in two-dimensional plots, axes that use the same drawing scale (ratio of display
distance to data interval) on both axes. For example, an interval of 2 on the X axis
maps to the same display distance as an interval of 2 on the Y axis. The aspect ratio
of the plot display equals the aspect ratio of the plot data. In other words, a 45-degree
slope in data will be represented by a 45-degree slope in the display. Equated axes
are always of TYPE=LINEAR. The number of intervals displayed on each axis does
not have to be the same.
external axis
an axis that is outside all cells of a layout. An external axis represents a common
scale for all plots in a row or column of a multi-cell layout.
fill
to apply a color within a bounded area. Many plots, such bar charts and band plots,
have bounded areas that can be filled or unfilled. When filled, a color is applied.
When unfilled, the areas are transparent.
fit policy
one of several algorithms for avoiding tick-value collision when space allotted to a
predefined area does not permit all the text to fit. For example, an axis might have a
THIN policy that eliminates the display of tick values for alternate ticks. A ROTATE
policy would turn the tick values at a 45-degree angle. A TRUNCATE policy would
truncate all long tick values to a fixed length and add an ellipsis (. . .) at the end to
imply truncation. A STAGGER policy would create two rows of tick values with
consecutive tick values alternating between rows. A compound policy such as
STAGGERROTATE could be used to automatically choose the best fit policy for the
situation.
Glossary
515

footnote area
the region below the graph area where text produced by ENTRYFOOTNOTE
statements appears.
frequency variable
in an input data set, a non-negative and non-zero integer variable that represents the
frequency of occurrence of the current observation, essentially treating the data set as
if each observation appeared n times, where n is the value of the FREQ variable for
the observation.
fringe plot
a plot consisting of short, equal-length line segments drawn from and perpendicular
to an axis. Each observation of a numeric variable corresponds to the location for a
line segment.
function
See SAS function
glyph
the most basic element (a grapheme or combination of graphemes) of a typeface or
font that is used to render text in a writing system.
graphics template
See ODS template
grid
a uniform arrangement of the rows and columns of a multi-cell layout.
gridded data
input that contains at least three numeric variables. Two of the variables are treated
as X and Y variables and the third variable Z is treated as if it were a function of X
and Y. The X and Y variable values occur at uniformly spaced intervals (although
the size and number of intervals might be different for X and Y). All X,Y pairs are
unique, and Z values are interpolated so that every X,Y pair has a Z value. Raw data
that has at least three numeric variables can be converted to gridded data with the
G3GRID procedure (in SAS/GRAPH). The procedure offers both bivariate and
spline interpolation methods for computing Z values.
group index
a numeric variable with positive integer values that correspond to values of a group
variable. The index values are used to associate GraphData1 GraphDataN style
elements with group values.
group variable
a variable in the input data set used to categorize chart variable values into groups. A
group variable enables the data for each distinct group value to be rendered in a
visually different manner. For example, a grouped scatter plot displays a distinct
marker and color for each group value.
image format
a file format that displays a graphical representation. PNG, GIF, TIFF, and JPEG are
examples of image formats, each with different characteristics.
inset
a graphical element such as a legend, line of text, or a table of text that is embedded
inside of a graph's plot area.
516
Glossary

interval axis
an axis where the distance between tick marks represents monotonically increasing
or decreasing numeric units of some scale (like a ruler). The standard interval axis is
called a LINEAR axis. Specialized interval axes include a TIME axis and a LOG
axis.
layout
a generic term for a rectangular container that lays out the positions and sizes of its
child components.
layout block
a block beginning with a LAYOUT statement and ending with an ENDLAYOUT
statement.
layout grid
a multi-cell layout arranged as a grid of cells in rows and columns.
layout type
a keyword indicating the functionality of the layout. For example OVERLAY,
LATTICE, and DATAPANEL are layout types.
legend entry
a combination of a graphical element such as a marker or line along with text
describing the value or use of the graphical element. A discrete legend can have
several legend entries.
legend title
text that explains how to interpret the legend.
line property
a value that defines the pattern, thickness, or color of a line. By default, the value for
a line property is derived from a style element in the current style.
linear axis
an interval axis with ticks placed on a linear scale.
log axis
an axis displaying a logarithmic scale. A log axis is useful when data values span
orders of magnitude.
marker
a symbol such as a diamond, a circle, or a triangle that is used to indicate the location
of, or annotate, a data point in a plot or graph.
marker property
a value that defines the symbol used as a marker, or its size, weight, or color. By
default, the value for a marker property is derived from a style element in the current
style.
multi-cell layout
a layout that supports a rectangular grid of cells, each of which can contain a
graphical element, such as a plot, a legend, a nested layout, and so on.
nested layout
a layout block that appears within the scope of another layout block.
Glossary
517

ODS
See Output Delivery System
ODS Graphics
an extension to ODS that is used to create analytical graphs using the Graph
Template Language.
ODS Graphics Editor
an interactive application that can be used to edit and annotate ODS Graphics output.
ODS template
a description of how output should appear when it is formatted. ODS templates are
stored as compiled entries in a template store, also known as an item store. Common
template types include STATGRAPH, STYLE, CROSSTABS, TAGSET, and
TABLE.
opaque
a property of a background. Opaque backgrounds are filled with a color. Non-opaque
backgrounds are transparent.
outlier
a data point that differs from the general trend of the data by more than is expected
by chance alone. An outlier might be an erroneous data point or one that is not from
the same sampling model as the rest of the data.
Output Delivery System
a component of SAS software that can produce output in a variety of formats such as
markup languages (HTML, XML), PDF, listing, RTF, PostScript, and SAS data sets.
Short form: ODS.
overlay
a plot that can be superimposed on another plot when specified within an overlay-
type layout. A common overlay combination is a fit line on a scatter plot.
overlay layout
a type of layout that supports the superimposition of graphical components, such as
plots, legends, and nested layouts.
panel
a graph with multiple cells.
parameterized plot
a non-computed plot that requires parameterized data. The Graph Template
Language offers several plots in both computed and parameterized versions, for
example, BARCHART and BARCHARTPARM. Some computed plots such as
REGRESSIONPLOT can be emulated with a SERIESPLOT if the input data
represented points on a fit line.
parent block
when two or more blocks are nested, any layout block that contains one or more
layout blocks is a parent of the contained blocks.
plot
a visual representation of data such as a scatter plot, needle plot, or contour plot.
518
Glossary

plot area
the space, bounded by the axes, where a visual representation of data, such as a
scatter plot, a series line, or a histogram, is drawn.
plot type
a plot family such as bar chart (which would include horizontal, vertical, and
grouped bar charts), or a classification scheme for plots based on some useful
criteria, such as whether the plots are computed or parameterized.
primary axis
the X or Y axis contrasted to the X2 or Y2 secondary axis.
primary plot
the plot in an overlay that determines axis features, such as axis type and axis label.
prototype layout
an overlay plot composite that appears in each cell of a classification panel. Each
instance of the prototype represents a different subset (classification level) of the
data.
regression plot
a straight or curved line showing a linear or higher order regression fit for a set of
points.
required argument
a variable or constant that must be specified in order to evaluate an expression or
render a plot, legend, text, or a layout. For example, a scatter plot has two required
arguments: X=column and Y=column.
role
a description of the purpose that a variable serves in a plot. For example, a series plot
has predefined roles named for X , Y, GROUP, and CURVELABEL.
row axis
an external axis appearing on the left or right of a row of cells in a multi-cell layout.
row gutter
space between rows of cells of a multi-cell layout.
row header
typically, the text that identifies the row contents in a multi-cell layout. This text can
be aligned to the right or left of the cells in a row. The row header is not restricted to
text (it can contain a plot or a legend, for example).
row major order
an order for populating cells of a layout or entries of a legend when the number of
columns is specified. For example, in the default case: Start at the top left and fill
cells or entries left-to-right. When the right-most column is filled, begin a new row
below the previous row. Continue this until all content items have been placed in
cells or entries. There might be empty cells/entries in the last row.
row weight
in a LATTICE layout, the proportion of height allotted to a specific row of the
layout. The sum of all row weights is 1.
Glossary
519

SAS function
a type of SAS language element that is used to process one or more arguments and
then to return a result that can be used in either an assignment statement or an
expression.
secondary axis
an X2 or Y2 axis, as contrasted with the primary axes X or Y.
SGE file
a file created in the ODS Graphics environment that contains an editable graph. Such
files have a .sge file extension and can be edited only with the ODS Graphics Editor.
You can edit SGE files from the SAS Results window or by opening the SGE file
from within the ODS Graphics Editor.
sidebar
an area of certain multi-cell layouts external to the grid of cells where text or other
graphical elements can appear. The LATTICE, DATAPANEL, and DATALATTICE
layout support four sidebar areas (TOP, BOTTOM, LEFT, and RIGHT).
single-cell layout
a layout type that supports only one cell. The OVERLAY, OVERLAY3D, and
OVERLAYEQUATED layouts are examples of single-cell layouts.
sparse data
in classification panels with two or more classifiers, some crossings of the
classification values might not be present in the input data. Such input data is called
sparse data. By default, a DATAPANEL layout does not generate cells for sparse
data, but if requested, it can produce empty cells as place holders for the non-existent
crossings.
stand-alone plot
a plot that has its own data range and can therefore appear by itself in a layout.
statement block
a group of statements that has both a logical beginning and ending statement. For
example, a LAYOUT statement along with its ENDLAYOUT statement and all
contained statements are a block. Some blocks can be nested within other blocks.
style
an ODS template that can be used to control the visual aspects (colors, fonts, lines,
markers, and so on) of a graph. A style consists of many style elements, and each
style element consists of style attributes.
style attribute
a visual property such as a color, line pattern, or font property that has a reserved
name. For example, COLOR, FONTFAMILY, FONTSIZE, FONTWEIGHT, and
FONTSTYLE are all attributes of style elements such as GraphTitleText,
GraphLabelText, and so on. Style attributes are collectively referenced by a style
element within a style definition.
style element
a named collection of style attributes that affects specific parts of ODS output. For
example, a style element might specify the color and font properties of title text or
other text in in a table or graph.
520
Glossary

style reference
a part of the Graph Template Language syntax that indicates the current value of a
specific attribute of a specific style element. For example,
SIZE=GraphTitleText:FontSize means to assign to SIZE the value of the FontSize
attribute of the GraphTitleText style element from the current style.
template compile time
the phase when the source program of a template definition is submitted. The syntax
of the definition is evaluated for correctness. If no errors are detected, the definition
is converted to a binary format and stored for later access.
template definition
the TEMPLATE procedure source program that creates a template. A template
definition can be generated from a compiled template. Also called the template
source.
template run time
the actions performed when a compiled template is bound to a data object and then
rendered to produce a graph. Run-time errors can occur that prevent a graph from
being produced.
template source
See template definition
template store
an item store that contains definitions that were created by the TEMPLATE
procedure. Definitions that SAS provides are in the item store Sashelp.Tmplmst. You
can store definitions that you create in any template store to which you have Write
access.
template-based graphic
graphical output produced by a compiled ODS template of the type STATGRAPH.
That is, a graph that is produced within the ODS graphics environment rather than in
the traditional device-based environment.
text properties
a common set of characteristics that can be specified for any text string: COLOR,
FAMILY, SIZE, WEIGHT, and STYLE. By default, values for these properties are
derived from a style element in the current style.
time axis
an axis type that displays only SAS date, time, or datetime values. Axis tick value
increments can be specified as time or date intervals, such as MINUTE, HOUR,
DAY, WEEK, MONTH, QUARTER, or YEAR.
title area
the region above the graph area where text produced by ENTRYTITLE statements
appears.
transparency
the degree to which a graphic element (such as a marker or filled area) is opaque or
transparent. Transparency is indicated with a number from 0 (completely opaque) to
1 (completely transparent).
Glossary
521

Unicode
a computing industry standard for the consistent encoding, representation and
handling of text expressed in most of the world's writing systems. Unicode includes
more than 109,000 characters covering dozens of scripts, plus standards for character
properties such as upper and lower case, for rendering bidirectional script, and a
number of related items.
viewport
See axis viewport
wall
the area bounded by orthogonal axis pairs. In two-dimensional graphs, there is one
wall bounded by the XY axes. In three-dimensional graphs, there are three walls,
bounded by the XY, YZ, and XZ axes. A wall has an optional outline and can be
opaque or transparent.
weight variable
a numeric variable that represents a weight (for example, costs) to be applied to
observations.
522
Glossary

Index
A
ACROSS= option
DISCRETELEGEND statement 193
advanced multi-cell layout
See LAYOUT LATTICE statement
alternating wall color bands
setting for discrete intervals 94
anchoring
elements drawn with draw statements
408
anti-aliasing
for graphics output 449, 462
ANTIALIAS= option
ODS GRAPHICS statement 449
ANTIALIASMAX= option
ODS GRAPHICS statement 449
appearance
of grouped data in graphs 123
of grouped data in various plot types
124
of non-grouped data in graphs 120
appearance of grouped data
controlling with a discrete attribute map
127
controlling with a range attribute map
129
arrows
drawing with DRAWARROW
statements 410
ASORT function 350
attribute maps
controlling the appearance of grouped
data with 127
discrete 127
range 129
AUTOALIGN= option
ENTRY statement 170, 356
LAYOUT GRIDDED statement 360
legend statements 182
AUTOITEMSIZE= option
DISCRETELEGEND statement 195
axis features
avoiding tick value collision 88, 101
axis line and wall outline 106
converting tick values to integers 86
data range on LINEAR axes 80
DISCRETE axes 70
displaying a secondary axis 69
displaying grid lines 69
displaying select features 68
equivalent primary and secondary axes
80
general principles 64
how affected by plot statements 65
how axis label is determined 72
how axis range is determined 71
how axis type is determined 70
how constructed 65, 70
how tick values are determined 78
label splitting 75
LINEAR axes 70, 84
LOG axes 70, 102
log axis with log data 105
mapping data columns to axes 65
offsets on axes 81
overlay-type layouts 64
OVERLAYEQUATED layouts 301
primary plot and 72
scaling the tick values 87
setting axis type 102
specifying alternate short label 75
specifying an axis label 73
specifying axis options 68
style elements that control features 109
suppressing the axis label 69
suppressing tick marks 68
terminology 64
thresholds on axes 78
TIME axes 70, 97
turning off the wall outline 108
axis labels
on computed plots 73
523

specifying an alternate short label 75
specifying on an axis 73
splitting into multiple lines 75
suppressing on an axis 69
why truncated 74
axis options
BASE= suboption 103
DISPLAY= option 68
DISPLAYSECONDARY= option 69
INTERVAL= option 98
OFFSETMAX= 81
OFFSETMIN= 81
THRESHOLDMAX= 78
THRESHOLDMIN= 78
TICKINTERVALSTYLE= option 103
TICKVALUEFITPOLICY= option 88
TYPE= 70, 102
VIEWMAX= 71
VIEWMIN= 71
X2AXISOPTS= 68
XAXISOPTS= 68
Y2AXISOPTS= 68
YAXISOPTS= 68
B
BACKGROUND= option
text statements 167
BACKGROUNDCOLOR= option
LAYOUT GRIDDED statement 362
layout statements 35
legend statements 183
BANDPLOT statement 51
and SERIESPLOT statement 29
categorized by plot type 26
used for a fit plot 29
BARCHART statement
categorized by plot type 25
BARCHARTPARM statement 47
categorized by plot type 26
with a BLOCKPLOT 385
BASE=
axis log base 103
BEGINGRAPH statement
See also templates
DEFAULTDESIGNHEIGHT keyword
456
DEFAULTDESIGNWIDTH keyword
456
DESIGNHEIGHT= option 222, 255,
267, 447, 456
DESIGNWIDTH= option 222, 255,
267, 447, 456
BEGINPLOYGON statement 414
BEGINPLOYLINE statement 413
BIHISTOGRAM3DPARM statement
and gaps among axis tick values 320
categorized by plot type 27
displaying percentages on Z axis 317
eliminating bins that have no data 316
labeling axes with endpoints 319
setting bin width 318
with PROC KDE 315
BLOCKPLOT statement
categorized by plot type 26
CLASS= option 385
creating an inset 380
DATATRANSPARENCY= option 383
DISPLAY= option 383
FILLTYPE= option 383
LABELATTRS= option 383
LABELPOSITION= option 383
VALUEATTRS= option 383
VALUEHALIGN= option 383
VALUEVALIGN= option 383
blocks
See layout blocks
See statements
BORDER= option
layout statements 35
legend statements 185
ODS GRAPHICS statement 449
text statements 167
BORDERATTRS= option
layout statements 35
legend statements 185
borders
for graphics output 449
BOXPLOT statement
categorized by plot type 25
BOXPLOTPARM statement
categorized by plot type 26
BUBBLEPLOT statement
categorized by plot type 25
C
CALL SYMPUT routine
on a DATA step 441, 444
using to create insets 367
CELL block
LAYOUT LATTICE statement 232
CELL HEADER block
LAYOUT LATTICE statement 232
CELLHEIGHTMIN= option
classification panels 269
CELLWIDTHMIN= option
classification panels 269
circles
drawing with DRAWOVAL statements
411
CLASS= option
524
Index

BLOCKPLOT statement 385
classification panels
adding gutters between panels 265
adding insets 293, 372
adjusting the graph size 267
and panel axis features 271
and the size of panel cells 268
CELLHEIGHTMIN= option 269
CELLWIDTHMIN= option 269
CLASSVARS= argument 258
COLUMNAXISOPTS= option 273
COLUMNDATARANGE= option 271
COLUMNGUTTER= option 265
COLUMNHEADERS= option
(DATALATTICE layout only) 275
COLUMNS= option 263
COLVAR= argument 260
controlling classification headers 275
controlling headers 280
difference between DATAPANEL and
DATALATTICE layouts 262
graph aspect ratio 266
HEADERBACKGROUNDCOLOR=
option 276
HEADERLABELATTRS= option 276
HEADERLABELDISPLAY= option
275
HEADEROPAQUE= option 276
INSET= option 293, 372
INSETOPTS= option 293, 372
LAYOUT DATALATTICE statement
258
LAYOUT DATAPANEL statement
258
LAYOUT PROTOTYPE statement 258
ORDER= option (DATAPANEL layout
only) 263
overview 257
PANELNUMBER= option 285
restrictions on the PROTOTYPE layout
262
ROWAXISOPTS= option 273
ROWDATARANGE= option 271
ROWGUTTER= option 265
ROWHEADERS= option
(DATALATTICE layout only) 275
ROWS= option 263
ROWVAR= argument 260
setting axis options 273
SKIPEMPTYCELLS= option 281
SPARSE= option (DATAPANEL
layout only) 287
START= option 264
using sidebars 277
with parameterized plots 275
classification values
including missing values 290
CLI= option
REGRESSIONPLOT statement 28
CLM= option
REGRESSIONPLOT statement 28
cluster width 138
CLUSTERWIDTH= option 138
COLLABEL function 350
COLNAME function 350
COLOR= attribute
for fills 494
for lines 495
for markers 496
for text 497
COLORBANDS= option
DISCRETEOPTS option 94
COLORBANDSATTRS= option
DISCRETEOPTS option 94
COLORMODEL= option
CONTOURPLOTPARM statement 204
SCATTERPLOT statement 204
SURFACEPLOTPARM statement 204,
324
COLUMNAXIS statement
LAYOUT LATTICE statement 236
COLUMNAXISOPTS= option
classification panels 273
COLUMNDATARANGE= option
classification panels 271
COLUMNGUTTER= option
classification panels 265
LAYOUT GRIDDED statement 214,
358
LAYOUT LATTICE statement 230
using to space inset text 358
COLUMNHEADERS= option
classification panels (DATALATTICE
layout only) 275
COLUMNHEIGHTS= option
PREFERRED keyword 251
COLUMNS= option
classification panels 263
LAYOUT GRIDDED statement 212
LAYOUT LATTICE statement 228
COLUMNWEIGHTS= option
LAYOUT LATTICE statement 249
COMMONAXISOPTS= option
LAYOUT OVERLAYEQUATED
statement 304
computed plots 51
conditional logic 339
confidence limits
generating with REGRESSIONPLOT
statement 28
on a fit plot 29
CONTINUOUSLEGEND statement
Index
525

See legends
CONTOURPLOTPARM statement
categorized by plot type 26
COLORMODEL= option 204
CONTOURTYPE= option 204
NHINT= option 204
NLEVELS= option 204
REVERSECOLORMODEL= option
204
CONTOURTYPE= option
CONTOURPLOTPARM statement 204
CORROPTS= option
SCATTERPLOTMATRIX statement
370
CSS function 351
CUBE= option
LAYOUT OVERLAY3D statement
310
CURVELABEL= option
labeling drop lines 158
labeling plot lines 158
labeling reference lines 158
plot statements 39
CURVELABELATTRS= option
plot statements 39
CURVELABELLOCATION= option
plot statements 39
CURVELABELLOWER= option
plot statements 39
CURVELABELPOSITION= option
plot statements 39
CURVELABELUPPER= option
plot statements 39
custom style
controlling grouped data appearance
with 125
creating 125
CV function 351
CYCLEATTRS= option
varying visual properties of overlaid
plots 190
D
DAT drawing space 406
data, input
filtering 439
generating with a procedure 29
transforming 439
data, output
See output data object
data object
building with SGRENDER procedure
16
data points
labeling 158
text properties for labels 159
data range
setting on LINEAR axes 80, 84
setting on TIME axes 101
data skins 151
appearance in bar and pie charts 151
appearance in scatter plots 152
DATA step
_NULL_ keyword 438
and the output data object 442
CALL SYMPUT routine 441, 444
executing GTL templates 437
FILE statement 438
filtering the input data 439
FORMAT statement 442
LABEL statement 442
OBJECT= option 443
OBJECTLABEL= option 443
OBS= option 439
ODS= option 441
PUT statement 438
syntax for executing GTL templates
438
transforming the input data 439
WHERE statement 439
data tips
for graphics output 450, 467, 468
setting maximum mouse-over areas 451
DATA= argument
SGRENDER procedure 15
DATA= option
SGRENDER procedure 438
DATALABEL= option
labeling data points 158
plot statements 39
DATALABELATTRS= option
plot statements 39
DATALATTICE layout
See classification panels
DATAPANEL layout
See classification panels
DATASKIN= option 153
DATATRANSPARENCY= option
BLOCKPLOT statement 383
plot statements 37
default appearance
grouped data 123
Default State
SAS Registry 447
DEFAULTDESIGNHEIGHT keyword
BEGINGRAPH statement 456
DEFAULTDESIGNWIDTH keyword
BEGINGRAPH statement 456
DEFINE statement
naming a GTL template 13
specifying type of template 13
526
Index

DENDROGRAM statement
categorized by plot type 25
DENSITYPLOT statement
categorized by plot type 25
dependent plot statements 27
descriptive text
See text
Design Height
SAS Registry 447
Design Width
SAS Registry 447
DESIGNHEIGHT= option
BEGINGRAPH statement 222, 255,
267, 447, 456
DESIGNWIDTH= option
BEGINGRAPH statement 222, 255,
267, 447, 456
discrete attribute maps 127
creating 127
discrete attribute variable
creating 127
DISCRETE axes 70
discrete legend
adding items to 196
controlling the label and item size in
195
filtering legend items contributed by
multiple plots 197
removing items from 197
sorting items in 188
DISCRETEATTRMAP block 127
DISCRETEATTRVAR statement 127
DISCRETELEGEND statement
See legends
DISCRETEOFFSET= option 95
display attributes
available line patterns 497
specifying fill color 494
specifying line color 495
specifying line pattern 495
specifying line thickness 495
specifying marker color 496
specifying marker size 496
specifying marker symbol 496
specifying marker weight 496
specifying text color 497
specifying text font family 497
specifying text size 497
specifying text style 497
specifying text weight 497
specifying transparency 494
DISPLAY= option
BLOCKPLOT statement 383
managing axis display 68
plot statements 36
primary-axis display features 68
DISPLAYCLIPPED= option
DISCRETELEGEND statement 193,
203
DISPLAYSECONDARY= option
displaying a secondary axis 69
secondary-axis display features 69
DOWN= option
DISCRETELEGEND statement 193
DPI= option
ODS PDF destination 448
DRAW statement
polygon block 414
polyline block 413
draw statements
DRAWARROW statement 410
DRAWIMAGE statement 415
drawing space and units 406
DRAWOVAL statement 411
DRAWRECTANGLE statement 412
DRAWTEXT statement 409
elements that can be drawn with 405
list of the statements and the elements
they draw 408
polygon block statements 414
polyline block statements 413
specifying anchor point in 408
DRAWARROW statement 410
DRAWIMAGE statement 415
drawing space
DATA 406
GRAPH 407
LAYOUT 407
specifying in draw statements 407
WALL 406
drawing space and units
See also DRAWSPACE= option
specifying for all draw statements 407
drawing units
specifying in draw statements 407
DRAWOVAL statement 411
DRAWRECTANGLE statement 412
DRAWSPACE= option 407
DRAWTEXT statement 409
drop lines
labeling 158
text properties for labels 159
DROPLINE statement
categorized by plot type 27
DSORT function 350
DYNAMIC statement
See dynamics
dynamic variables
See dynamics
dynamics
and quotation marks 329
declaring 327, 440
Index
527

initializing 329, 441
initializing on SGRENDER procedure
441
location in a template 327
overview 327
referencing 328, 440
syntax in a template 327
using in text 164
using on templates 440
using to create insets 363
E
edit-ready graphs
for graphics output 448, 464
ELLIPSE statement
categorized by plot type 25
ELLIPSEPARM statement
categorized by plot type 26
ENTRY statement
adding descriptive text to a graph 158,
162
adding text to a graph 31
AUTOALIGN= option 170, 356
controlling the text 163
creating an inset 356, 357
greek letters 475
HALIGN= option 170, 356, 357
horizontal alignment of text 164
LAYOUT LATTICE statement 232
PAD= option 359
reserved keywords  0
rich text for 164
ROTATE= option 248
subscripts and superscripts 165
text background, borders, and padding
167
Unicode codes 165
Unicode values  0
VALIGN= option 170, 356
ENTRYFOOTNOTE statement
adding a footnote to a graph 31, 161
and size of graphical area 162
controlling the text 163
greek letters 475
horizontal alignment of text 164
location in a template 161
reserved keywords  0
rich text for 164
SHORTTEXT= option 169
subscripts and superscripts 165
text background, borders, and padding
167
text properties for 158
TEXTATTRS= option 164
TEXTFITPOLICY= option 169
Unicode codes 165
Unicode values  0
ENTRYTITLE statement
adding a title to a graph 31, 161
and size of graphical area 162
controlling the text 163
greek letters 475
horizontal alignment of text 164
location in a template 161
reserved keywords  0
rich text for 164
SHORTTEXT= option 169
subscripts and superscripts 165
text background, borders, and padding
167
text properties for 158
TEXTATTRS= option 164
TEXTFITPOLICY= option 169
Unicode codes 165
Unicode values  0
EQUATETYPE= option
LAYOUT OVERLAYEQUATED
statement 301
EVAL construct
with functions 345
EVAL function
See expressions
EXCLUDE= option
DISCRETELEGEND statement 197
EXISTS function 350
EXPAND function 350
expressions
and type conversion 338
building a text string 338
compared to SAS WHERE expressions
338
computing a constant 337
creating a new column 338
meaning in statement syntax 338
overview 337
EXTRACTSCALE =
axis tick values 86
F
FAMILY= attribute
for text 497
FILE statement
on a DATA step 438
fill attributes
specifying fill color 494
specifying transparency 494
FILLATTRS= option
plot statements 37
FILLTYPE= option
BLOCKPLOT statement 383
528
Index

fit plot
with BANDPLOT statement 29
with confidence limits 29
with procedure-output data 29
with REGRESSIONPLOT statement 28
Fonts style element 395
footnotes
See ENTRYFOOTNOTE statement
FORMAT statement
on a DATA step 442
with the SGRENDER procedure 442
formats
See SAS formats
FRINGEPLOT statement
categorized by plot type 26
functions
ASORT 350
COLLABEL 350
COLNAME 350
CSS 351
CV 351
DSORT 350
EXISTS 350
EXPAND 350
GTL only functions 350
IFC 346
IFN 346
KURTOSIS 351
LCLM 351
MAX 351
MEAN 351
MEDIAN 351
MIN 351
N 351
NMISS 351
NUMERATE 350
P1 352
P25 352
P5 352
P50 352
P75 352
P90 352
P95 352
P99 352
PROBT 352
PUT 363
Q1 352
Q3 352
QRANGE 352
RANGE 352
SKEWNESS 352
STDDEV 352
STDERR 352
STRIP 363
SUM 352
summary statistics functions 351
SUMWGT 352
T 352
TYPEOF 346
types available 345
UCLM 352
using to create insets 363
USS 352
VAR 352
G
global legend
creating 200
GLOBALLEGEND statement 200
glyphs
lowercase Greek letters 475
special characters 477
uppercase Greek letters 476
GPATH= option
ODS HTML destination 449
ODS LISTING destination 448
output location for images 454
graph borders 449
GRAPH drawing space 407
graph scaling
graphics output 457
graph styles
See ODS styles
GraphAltBlock style element 184
GraphAnnoFont style element 396
GraphAnnoText element 160
GraphAxisLines style element 107
GraphBlock style element 184
GraphBox style element 399, 400
Displayopts attribute 400
GraphBoxMean style element 399
GraphBoxMedian style element 399
GraphBoxOutlier style element 399
GraphBoxWhisker style element 399
GraphData1 style element 190
GraphDataFont style element 396
GraphDataText element 160
GraphDataText style element 276
GraphFonts style element 395
GraphFootnoteFont style element 396
GraphFootnoteText element 160
GraphHeaderBackground style element
184
graphics output
and BEGINGRAPH statement 456
and SAS Registry 446
anti-aliasing 449, 462
edit-ready graphs 448, 464
font sizes 458
for MS Office applications 467
graph borders 449
Index
529

graph height 450
graph scaling 457
graph width 451
image DPI (dots per inch) 460
image format 450
image resolution 448, 467
imagemap for data tips 450, 467, 468
managing 445
naming output files 443, 450
ODS destination options 448
ODS styles 448
output destinations 445
output directory for images 448
REGEDIT command 446
reset ODS GRAPHICS options 450
scale graphs proportionally 451
setting an image name 451
setting image format 451
shared templates 473
text in a graph 157
GraphLabelFont style element 396
GraphLabelText element 160
GraphTitleFont style element 395
GraphTitleText element 160
GraphUnicodeFont style element 396
GraphUnicodeText element 160
GraphValueFont style element 396
GraphValueText element 160
GraphWalls style element 107, 362
grid lines
displaying on an axis 69
GRIDDED layout
See LAYOUT GRIDDED statement
group display 135
CLUSTER 136
OVERLAY 136
STACK 136
group values
including missing values 139
GROUP= option
plot statements 42
GROUPDISPLAY= option 135
grouped data
appearance in various plot types 124
appearance of in graphs 123
changing the order of 140
controlling appearance with custom
styles 125
default appearance in graphs 123
plots that support grouped data 123
grouped data appearance
making independent of data order 142
grouped data order
changing 140
GROUPORDER= option 140, 141
H
HALIGN= option
ENTRY statement 170, 356
LAYOUT GRIDDED statement 360
layout statements 35, 36
legend statements 180
on text statements 164
using to align insets 357
HEADERBACKGROUNDCOLOR=
option
classification panels 276
HEADERLABELATTRS= option
classification panels 276
HEADERLABELDISPLAY= option
classification panels 275
HEADEROPAQUE= option
classification panels 276
HEATMAPPARM statement
categorized by plot type 26
height
for graphics output 450
HEIGHT= option
ODS GRAPHICS statement 202, 222,
255, 267, 450, 457
HIGHLOWPLOT statement
categorized by plot type 26
HISTOGRAM statement
categorized by plot type 25
HISTOGRAMPARM statement
categorized by plot type 26
I
if-else statement
how and why used 340
nesting to form ELSE IF logic 340
overview 339
requirements for the conditional code
340
IFC function 346
IFN function 346
IMAGE_DPI= option
ODS HTML destination 449
ODS LISTING destination 448, 467
ODS RTF destination 448
image format
resetting to default 454
specifying 452
image name
resetting to default 454
IMAGEMAP= option
ODS GRAPHICS statement 450
IMAGENAME= option
ODS GRAPHICS statement 443, 450
images
default height in SAS Registry 447
530
Index

default width in SAS Registry 447
drawing with DRAWIMAGE statement
415
format for graphics output 450
height for graphics output 450
names for graphics output 443, 450
output location 454
resolution for graphics output 448
scale for graphics output 451
width for graphics output 451
INCLUDEMISSINGGROUP= option
139
INDEX= option
mapping grouped data values 190
plot statements 42
INSET= option
classification panels 293, 372
SCATTERPLOTMATRIX statement
370
INSETOPTS= option
classification panels 293, 372
SCATTERPLOTMATRIX statement
371
insets
adding to a classification panel 372
adding to a SCATTERPLOTMATRIX
graph 369
aligning on an axis 380
changing background fill 362
creating as table of text 217, 357
creating with a BLOCKPLOT statement
380
creating with an ENTRY statement
356, 357
creating with computed values 363
displaying title text for 359
overview 355
passing values to 364
positioning in a LATTICE layout 361
positioning in an OVERLAY layout
356, 360
INTEGER= option
formatting axis tick values 86
INTERVAL=
axis tick values 98
item stores
storing a template 14
J
java environment
See memory management
JREOPTIONS option
managing Java memory 507
K
KURTOSIS function 351
L
LABEL statement
on a DATA step 442
with the SGRENDER procedure 191,
442
LABELATTRS= option
BLOCKPLOT statement 383
LABELPOSITION= option
BLOCKPLOT statement 383
labels
for data points 158
for drop lines 158
for legends 158
for plot lines 158
for reference lines 158
text properties for 159
LATTICE layout
See LAYOUT LATTICE statement
layout blocks
BACKGROUNDCOLOR= option 35
BORDER= option 35
BORDERATTRS= option 35
compared 32
CYCLEATTRS= option 190
features supported 34
HALIGN= option 35, 36
OPAQUE= option 34
OUTERPAD= option 35
PAD= option 35
VALIGN= option 35, 36
layout containers
See layout blocks
LAYOUT DATALATTICE statement
See also classification panels
compared with other layouts 34
LAYOUT DATAPANEL statement
See also classification panels
compared with other layouts 34
LAYOUT drawing space 407
LAYOUT GRIDDED statement
adjusting graph size 221
and empty cells 213
AUTOALIGN= option 360
BACKGROUNDCOLOR= option 362
COLUMNGUTTER= option 214, 358
COLUMNS= option 212
compared with other layouts 33
creating an inset 217, 357
defining cells 214
displaying title text 359
HALIGN= option 357, 360
ORDER= option 212, 358
Index
531

overview 211
row and column sizes 218
ROWGUTTER= option 214
ROWS= option 212
setting grid dimensions 212
setting gutters 214
setting up a grid 212
sizing issues 218
VALIGN= option 360
LAYOUT LATTICE statement
adding cell headers 232
adding sidebars 246
adjusting graph size 254
and empty cells 229
and insets 361
background color in cell headers 233
cell axes 245
CELL block 232
CELL HEADER block 232
cell headers 226
column and row headers 227
COLUMNAXIS statement 236
COLUMNGUTTER= option 230
COLUMNS= option 228
COLUMNWEIGHTS= option 249
compared with other layouts 33
defining a basic lattice 228
defining cells 230
external axes 227, 236, 243
external axes, restrictions 236
external axes and empty cells 238
external secondary axes 237
internal axes 234
layout features 226
nested GRIDDED layout 233
ORDER= option 229
overview 225
rotating header text 248
ROWAXIS statement 236, 247
ROWDATARANGE= option 243
ROWGUTTER= option 230
ROWHEADERS block 247
ROWS= option 228
ROWWEIGHTS= option 249
setting grid dimensions 228
setting gutters 230
SIDEBAR block 246
sidebars 226
sizing issues 254
SKIPEMPTYCELLS= option 239
transforming the input data 241
uniform axis ranges 235
uniform axis ranges, restrictions 236
union of axes 227
using column or row headers 247
LAYOUT OVERLAY statement
and appearance options 53
and graph axes 64
and grouped data 52
and insets 356
and multiple axes 49
and plot axes 57
and primary plots 57
avoiding plot conflicts 57
common overlay combinations 47
compared with other layouts 33
computed plots 51
CYCLEATTRS= option 190
nested in a GRIDDED layout 220
overview 46
parameterized plots 51
plots with incompatible data 58
restrictions 54
specifying axis options 68
stacking order 48
statements allowed in layout 54
VIEWMAX= option 71
VIEWMIN= option 71
X2AXISOPTS= 68
XAXIS= option 65
XAXISOPTS= 68
Y2AXISOPTS= 68
YAXIS= option 65
YAXISOPTS= 68
LAYOUT OVERLAY3D statement
and bivariate histograms 314
and surface plots 321
compared with other layouts 33
CUBE= option 310
data requirements 314
defining a viewpoint 312
defining axes 313
displaying cube lines 310
displaying filled walls 311
overview 309
ROTATE= option 312
TILT= option 312
WALLDISPLAY= option 311
ZOOM= option 312
LAYOUT OVERLAYEQUATED
statement
axis features 304
COMMONAXISOPTS= option 304
compared to OVERLAY layout 301
compared with other layouts 33
display features 301
EQUATETYPE= option 301
overview 299
types of axes 301
when to use 300
XAXISOPTS= option 304
YAXISOPTS= option 304
532
Index

LAYOUT PROTOTYPE statement
See classification panels
LAYOUT REGION
as a top-level container 59
LAYOUT REGION statement 59
nesting in another layout 60
LCLM function 351
LEGENDITEM statement 196
LEGENDLABEL= option
labeling legends 158
plot statements 38
legends
ACROSS= option
(DISCRETELEGEND only) 193
adding to a graph 176
and a continuous response variable 178
and plot statements 30
and the ODS GRAPHICS statement
202
arranging entries into columns and rows
192
assigning legend entry labels 191
AUTOALIGN= option 182
automatically aligning an inside legend
182
BACKGROUNDCOLOR= option 183
BORDER= option 185
BORDERATTRS= option 185
borders for 185
changing entry font sizes 203
continuous legends 204
CONTINUOUSLEGEND statement
30, 176
controlling whether legend is drawn
450
discrete legends 187
DISCRETELEGEND statement 30,
176
DISPLAYCLIPPED= option
(DISCRETELEGEND only) 193,
203
displaying inside of plot wall 181
displaying outside of plot wall 180
DOWN= option (DISCRETELEGEND
only) 193
dropped legends 201
HALIGN= option 180
identifying overlaid plots 177
label for 158
legend wrapping 192
linking to plots 176
LOCATION= option 180
mapping grouped data values 190
NAME= option in plot statements 176
OPAQUE= option 183
options to control wrapping 193
ORDER= option (DISCRETELEGEND
only) 193
ordering entries for grouped plots 187
ordering entries for non-grouped plots
190
organizing entries in a fixed number of
columns 193
organizing entries in a fixed number of
rows 194
plots that can use continuous legends
204
positioning a continuous legend 207
positioning options 180
scaling legend values in a continuous
legend 209
showing group values 177
size issues in discrete legends 201
syntax 176
text properties for 186
text properties for legend titles 159
title borders 185
title for 158
TITLE= option 185
TITLEATTRS= option 186
TITLEBORDER= option 185
titles for 185
types of in GTL 176
using color gradients in a continuous
legend 207
VALIGN= option 180
VALUEATTRS= option 186, 203
line attributes
available line patterns 497
specifying line color 495
specifying line pattern 495
specifying line thickness 495
LINEAR axes 70
data range on 80
EXTRACTSCALE = option 86
formatting tick values 86
INTEGER = option 86
setting data range 84
setting tick values 84
LINEATTRS= option 118
map of attributes to GTL options 118
plot statements 37
LINEPARM statement
categorized by plot type 27
LINEPLOT statement
categorized by plot type 25
LOCATION= option
legend statement 180
LOESSPLOT statement
categorized by plot type 25
LOG axes 70
overview 102
Index
533

setting log base 103
setting tick intervals 103
M
macro variables
and ampersand (&) preface 328
and current symbol table 329, 440
automatic macro variables 329, 440
data type when resolved 328
declaring 327, 440
difference between MVAR and
NMVAR 328
finding runtime values 329
initializing 329, 441
location in a template 327
overview 327
passing values to insets 364
referencing 328, 440
syntax in a template 327
using in text 164
using on templates 440
marker attributes
specifying marker color 496
specifying marker size 496
specifying marker symbol 496
specifying marker weight 496
MARKERATTRS= option 119
map of attributes to GTL options 119
plot statements 36
MARKERCOLORGRADIENT= option
SCATTERPLOT statement 204
MAX function 351
MAXLEGENDAREA= option
ODS GRAPHICS statement 202, 450
MEAN function 351
MEDIAN function 351
memory management
in java environment 507
JREOPTIONS option 507
MERGEDLEGEND statement 198
merging legends 198
MIN function 351
missing classification values 290
missing group values 139
MODELBAND statement 51
and REGRESSIONPLOT statement 28
categorized by plot type 27
MOSAICPLOTPARM statement
categorized by plot type 26
MS Office applications
graphics output for 467
multi-cell layout, advanced
See LAYOUT LATTICE statement
multi-cell layout, simple
See LAYOUT GRIDDED statement
MVAR statement
See macro variables
N
N function 351
NAME= option
plot statements 38, 176
naming graphs 20
NEEDLEPLOT statement 50
categorized by plot type 26
NHINT= option
CONTOURPLOTPARM statement 204
NLEVELS= option
CONTOURPLOTPARM statement 204
NMISS function 351
NMVAR statement
See macro variables
non-grouped data
appearance of in graphs 120
NOTES statement
syntax 327
NUMERATE function 350
O
OBJECT= option
DATA step 443
SGRENDER procedure 442
OBJECTLABEL= option
DATA step 443
SGRENDER procedure 442
OBS= option
on a DATA step 439
SGRENDER procedure 439
ODS destinations 17
and graphics output 448
DPI= option 448
GPATH= option 448
HTML destination 17, 449
IMAGE_DPI= option 448, 467
LISTING destination 16, 448
PDF destination 448
RTF destination 448
SGE= option 448, 465
STYLE= option 18, 448
ODS Graphics
default state in SAS Registry 447
managing java memory 507
modifying shipped templates 3
ODS Graphics Designer (GUI-based
designer) 4
ODS Graphics Editor (GUI editor) 448
ODS Graphics Editor (GUI-based
editor) 3
ODS GRAPHICS statement 2
534
Index

SAS/STAT 2
SG procedures 4
ODS GRAPHICS statement 2
and graphics output 449
ANTIALIAS= option 449
ANTIALIASMAX= option 449
BORDER= option 449
HEIGHT= option 202, 222, 255, 267,
450, 457
IMAGEMAP= option 450
IMAGENAME= option 20, 450
MAXLEGENDAREA= option 202,
450
naming an output image file 443
OFF option 449
OUTPUTFMT= option 450
RESET= option 20, 222, 449, 450
SCALE= option 451, 457
TIPMAX= option 451
WIDTH= option 20, 202, 222, 255,
267, 451, 457
ODS LISTING statement
STYLE= option 18
ODS PATH statement
controlling ODS search paths 397
ODS styles
and legend background color 184
appearance in graphs 111
assigning a style to a graph 18
COLOR= text property 159
defining a style for axis walls 107
defining a style for box plots 398
defining a style for fonts 394
elements that control axis features 109
FAMILY= text property 160
Fonts style element 395
GraphAltBlock style element 184
GraphAnnoFont style element 396
GraphAnnoText element 160
GraphAxisLines style element 107
GraphBlock style element 184
GraphBox style element 399
GraphBoxMean style element 399
GraphBoxMedian style element 399
GraphBoxOutlier style element 399
GraphBoxWhisker style element 399
GraphData1 style element 190
GraphDataFont style element 396
GraphDataText element 160, 276
GraphFonts style element 395
GraphFootnoteFont style element 396
GraphFootnoteText element 160
GraphHeaderBackground style element
184
GraphLabelFont style element 396
GraphLabelText element 160
GraphTitleFont style element 395
GraphTitleText element 160
GraphUnicodeFont style element 396
GraphUnicodeText element 160
GraphValueFont style element 396
GraphValueText element 160
GraphWalls style element 107, 362
ODS PATH statement 397
ODS search paths 397
ODSTEMPLATE command 391
parent styles 394
recommended parent styles 392
registry keys for fonts in MS Windows
395
SIZE= text property 160
style elements available 479
STYLE= text property 160
STYLES directory of Sashelp.Tmplmst
391
supplied with SAS 113
text properties in 159
viewing a template's source code 391
WEIGHT= text property 160
ODS= option
on a DATA step 441
ODSTEMPLATE command
finding a compiled template 15
opening the Templates window 391
viewing a style definition 391
OFF option
ODS GRAPHICS statement 449
Office (MS) applications
graphics output for 467
OFFSETMAX=
axis offsets 81
OFFSETMIN=
axis offsets 81
offsets
on axes 81
OPAQUE= option
layout statements 34
legend statements 183
ORDER= option
classification panels (DATAPANEL
layout only) 263
DISCRETELEGEND statement 193
LAYOUT GRIDDED statement 212,
358
LAYOUT LATTICE statement 229
OUTERPAD= option
layout statements 35
output
See graphics output
output data object
and template execution 438
converting to a SAS data set 444
Index
535

default label 442
default name 442
labeling 442
naming 442
setting data-column formats 442
setting data-column labels 442
viewing in the Results window 443
OUTPUTFMT= option
ODS GRAPHICS statement 450, 452
ovals
drawing with DRAWOVAL statements
411
OVERLAY layout
See LAYOUT OVERLAY statement
OVERLAY3D layout
See LAYOUT OVERLAY3D statement
OVERLAYEQUATED Layout
See LAYOUT OVERLAYEQUATED
statement
P
P1 function 352
P25 function 352
P5 function 352
P50 function 352
P75 function 352
P90 function 352
P95 function 352
P99 function 352
PAD= option
ENTRY statement 359
layout statements 35
text statements 168
using to space inset text 359
PANELNUMBER= option
classification panels 285
parameterized plots 51
PATH= option
output location for graphics output 454
PATTERN= attribute
for lines 495
PBSPLINEPLOT statement
categorized by plot type 25
PIECHART statement
categorized by plot type 25
plot lines
labeling 158
text properties for labels 159
plot statement
using procedure output data 29
plot statements
and legends 30
axis labels on computed plots 73
BANDPLOT 26, 51
BARCHART 25
BARCHARTPARM 26, 47, 385
BIHISTOGRAM3DPARM 27
BIHISTOGRAM3DPARM statement
315
BLOCKPLOT 26, 380
BOXPLOT 25
BOXPLOTPARM 26
BUBBLEPLOT 25
categorized by type 24
computed plots 23
concepts for using 28
CONTOURPLOTPARM 26
controlling text in a graph 157
CURVELABEL= option 39
CURVELABELATTRS= option 39
CURVELABELLOCATION= option
39
CURVELABELLOWER= option 39
CURVELABELPOSITION= option 39
CURVELABELUPPER= option 39
DATALABEL= option 39
DATALABELATTRS= option 39
DATATRANSPARENCY= option 37
DENDROGRAM 25
DENSITYPLOT 25
dependent plots 27
DISPLAY= option 36
DROPLINE 27
ELLIPSE 25
ELLIPSEPARM 26
features supported 36
FILLATTRS= option 37
FRINGEPLOT 26
graphics types 24
GROUP= option 42
HEATMAPPARM 26
HIGHLOWPLOT 26
HISTOGRAM 25
HISTOGRAMPARM 26
how they affect axis features 65
INDEX= option 42
LEGENDLABEL= option 38
LINEATTRS= option 37
LINECHART 25
LINEPARM 27
LOESSPLOT 25
MARKERATTRS= option 36
MODELBAND 27, 51
MOSAICPLOTPARM 26
NAME= option 38
NEEDLEPLOT 26, 50
overview 23
parameterized plots 23
PBSPLINEPLOT 25
PIECHART 25
plots with incompatible data 58
536
Index

primary plots 24
REFERENCELINE 27, 47
REGRESSIONPLOT 25, 51
ROLENAME= option 43
SCATTERPLOT 27, 50
SCATTERPLOTMATRIX 25
SERIESPLOT 27, 380
stand-alone, 2-D, computed 25
stand-alone, 2-D, parameterized 26
stand-alone, 3-D, parameterized 27
stand-alone plots 24
STEPPLOT 27
SURFACEPLOTPARM 27
SURFACEPLOTPARM statement 321
TEXTATTRS= option 37
TIP= option 43
TIPFORMAT= option 43
TIPLABEL= option 43
VECTORPLOT 27
WATERFALLCHART 25
XAXIS= option 42
YAXIS= option 42
primary plots
avoiding plot conflicts 57
determining axis features 73
overview 24
PRIMARY=
axis features 72
PRIMARY= option
avoiding plot conflicts 57
PROBT function 352
PROC SGRENDER statement
See SGRENDER procedure
PROC TEMPLATE statement
See templates
programming features, runtime 345
PROTOTYPE layout
See classification panels
PUT function
using to create insets 363
PUT statement
on a DATA step 438
Q
Q1 function 352
Q3 function 352
QRANGE function 352
R
range attribute maps 129
controlling graph appearance with 129
creating 129
range attribute variable
creating 130
RANGE function 352
RANGEATTRMAP block 129
RANGEATTRVAR statement 130
rectangles
drawing with DRAWRECTANGLE
statements 412
reference lines
labeling 158
text properties for labels 159
REFERENCELINE statement 47
categorized by plot type 27
REGEDIT command
opening Registry Editor window 446
Registry Editor window
settings for ODS Graphics 446
REGRESSIONPLOT statement 51
and MODELBAND statement 28
and SCATTERPLOT statement 28
categorized by plot type 25
CLI= option 28
CLM= option 28
generating confidence limits 28
used for a fit plot 28
RESET= option
ODS GRAPHICS statement 222, 449,
450
Results window
viewing graphics output 16
REVERSECOLORMODEL= option
CONTOURPLOTPARM statement 204
SCATTERPLOT statement 204
SURFACEPLOTPARM statement 204,
324
ROLENAME= option
plot statements 43
ROTATE= option
ENTRY statement 248
LAYOUT OVERLAY3D statement
312
ROWAXIS statement
LAYOUT LATTICE statement 236,
247
ROWAXISOPTS= option
classification panels 273
ROWDATARANGE= option
classification panels 271
LAYOUT LATTICE statement 243
ROWGUTTER= option
classification panels 265
LAYOUT GRIDDED statement 214
LAYOUT LATTICE statement 230
ROWHEADERS block
LAYOUT LATTICE statement 247
ROWHEADERS= option
classification panels (DATALATTICE
layout only) 275
Index
537

ROWHEIGHTS= option
PREFERRED keyword 251
ROWS= option
classification panels 263
LAYOUT GRIDDED statement 212
LAYOUT LATTICE statement 228
ROWWEIGHTS= option
LAYOUT LATTICE statement 249
runtime programming constructs
GTL 337
runtime programming features 345
S
SAS formats
error message in log 503
unsupported currency formats 505
unsupported date and time formats 504
unsupported numeric formats 503
using 503
SAS Registry
and graphics output 446
Default State for ODS Graphics 447
Design Height for ODS Graphics 447
Design Width for ODS Graphics 447
opening with REGEDIT command 446
SAS/STAT 2
Sasuser.Templat item store
storing templates 14
SCALE= option
ODS GRAPHICS statement 451, 457
scaling graphs proportionally
for graphics output 451
SCATTERPLOT statement 50
and REGRESSIONPLOT statement 28
categorized by plot type 27
COLORMODEL= option 204
MARKERCOLORGRADIENT= option
204
REVERSECOLORMODEL= option
204
SCATTERPLOTMATRIX statement
adding an inset to the graph 369
categorized by plot type 25
CORROPTS= option 370
INSET= option 370
INSETOPTS= option 371
SERIESPLOT statement
and BANDPLOT statement 29
categorized by plot type 27
with a BLOCKPLOT 380
SGE= option
ODS LISTING destination 448, 465
SGPANEL procedure 4
SGPLOT procedure 4
SGRENDER procedure 20
and the data object 16
and the output data object 442
DATA= argument 15
DATA= option 438
DYNAMIC statement 441
executing a compiled template 15
executing GTL templates 437
filtering the input data 439
OBJECT= option 442
OBJECTLABEL= option 442
OBS= option 439
syntax for executing GTL templates
438
TEMPLATE= argument 15
TEMPLATE= option 438
transforming the input data 439
WHERE statement 439
with a FORMAT statement 442
with a LABEL statement 191, 442
SGSCATTER procedure 4
SHORTTEXT= option
titles and footnotes 169
SIDEBAR block
LAYOUT LATTICE statement 246
simple multi-cell layout
See LAYOUT GRIDDED statement
simple plot layouts
See LAYOUT OVERLAY statement
SIZE= attribute
for markers 496
for text 497
sizing graphs 20
SKEWNESS function 352
skins
See data skins
SKIPEMPTYCELLS= option
classification panels 281
LAYOUT LATTICE statement 239
sorting functions 350
SORTORDER= option
DISCRETELEGEND statement 188
SPARSE= option
classification panels (DATAPANEL
layout only) 287
squares
drawing with DRAWRECTANGLE
statements 412
stand-alone plot statements 25
START= option
classification panels 264
statements
blocks 22
categories of 23
general syntax for 21
layout blocks 32
nested blocks 22
538
Index

overview 21
parent-child relationships 22
plot statements 23
STATGRAPH statement
See templates
Statistical Graphics (SG) procedures 4
SGPANEL procedure 4
SGPLOT procedure 4
SGSCATTER procedure 4
STDDEV function 352
STDERR function 352
STEPPLOT statement
categorized by plot type 27
STRIP function
using for insets 363
style elements
See ODS styles
style-reference
fill options 494
line options 494
marker options 496
text options 497
STYLE= attribute
for text 497
STYLE= option
ODS HTML destination 449
ODS LISTING destination 448
ODS LISTING statement 18
ODS PDF destination 448
ODS RTF destination 448
styles
See ODS styles
subscripts and superscripts 165
SUM function 352
SUMWGT function 352
SURFACECOLORGRADENT= option
SURFACEPLOTPARM statement 204
SURFACECOLORGRADIENT= option
SURFACEPLOTPARM statement 324
SURFACEPLOTPARM statement
and missing Z values 322
categorized by plot type 27
COLORMODEL= option 204, 324
default features 321
REVERSECOLORMODEL= option
204, 324
SURFACECOLORGRADENT= option
204
SURFACECOLORGRADIENT=
option 324
SURFACETYPE= option 323
with PROC G3GRID 322
SURFACETYPE= option
SURFACEPLOTPARM statement 323
SYMBOL= attribute
for markers 496
SYMPUT
See CALL SYMPUT routine
T
T function 352
TEMPLATE procedure
defining a style template for fonts 394
DYNAMIC statement 327
MVAR statement 327
NMVAR statement 327
NOTES statement 327
TEMPLATE statement
See templates
template store
for shared templates 473
TEMPLATE= argument
SGRENDER procedure 15
TEMPLATE= option
SGRENDER procedure 438
templates
anti-aliasing 449
BEGINGRAPH statement 13
browsing the compiled source 15
compiling 14
creating 12
DATA step 437
DEFINE block 13
directing output 17
dynamics on 327
edit-ready graphs 448, 464
executing 15, 437
filtering the input data 439
finding in an item store 15
formatting output columns 442
graph block 13
graph borders 449
graph footnotes 161
graph height 447, 450
graph titles 161
graph width 447, 451
image format 450
image resolution 448, 467
imagemap for data tips 450, 467, 468
labeling output columns 442
layout block 14
macro variables on 327
managing graphics output 445
modifying graph appearance 18
modifying shipped templates 3
naming 13
naming output files 17, 20, 450
ODS destinations 16, 17, 448
ODS styles 18, 448
ODSTEMPLATE command 15
output directory for images 448
Index
539

overview 11
reset ODS GRAPHICS options 450
Results window 16
runtime programming constructs 337
Sasuser.Templat item store 14
scaling graphs proportionally 451
SGRENDER procedure 15, 20, 437
shared templates 473
sizing graphs 20
specifying graph contents 14
STATGRAPH statement 11
style elements available 479
transforming the input data 439
viewing graphics output 16
Templates Browser window
browsing a compiled template 15
Templates window
finding a compiled template 15
text
adding and changing in a graph 157
BACKGROUND= option 167
BORDER= option 167
COLOR= property 159
CURVELABEL= option 158
DATALABEL= option 158
drawing with DRAWTEXT statement
409
ENTRY statement 158, 162
ENTRYFOOTNOTE statement 161
ENTRYTITLE statement 161
FAMILY= property 160
GraphAnnoText element 160
GraphDataText element 160
GraphFootnoteText element 160
GraphLabelText element 160
GraphTitleText element 160
GraphUnicodeText element 160
GraphValueText element 160
horizontal alignment of 164
LABEL= option 158
LEGENDLABEL= option 158
PAD= option 168
positioning entry text 170
rich text for strings 164
SIZE= property 160
special characters 477
STYLE= property 160
subscripts and superscripts 165
text properties for 159
TITLE= option 158
Unicode codes 165
using dynamics and macro variables
164
WEIGHT= property 160
text attributes
specifying text color 497
specifying text font family 497
specifying text size 497
specifying text style 497
specifying text weight 497
TEXTATTRS= option 120
on text statements 164
plot statements 37
TEXTFITPOLICY= option
titles and footnotes 169
THICKNESS= attribute
for lines 495
THRESHOLDMAX=
axis thresholds 78
THRESHOLDMIN=
axis thresholds 78
thresholds
on axes 78
tick marks
suppressing on an axis 68
tick value fit policy applicability  0
tick values
avoiding collision 88, 90, 101
converting to integers 86
fit policies 90
fit policy applicability  0
formatting on LINEAR axes 86
formatting on TIME axes 100
how determined on an axis 78
scaling 87
setting on LINEAR axes 84
setting on TIME axes 98
TICKINTERVALSTYLE=
axis tick intervals 103
TICKVALUEFITPOLICY
axis tick values 88
TICKVALUEFORMAT =
axis tick values 86, 100
TICKVALUEFORMAT=
XAXISPOTS= option 243
TICKVALUELIST= option 84, 101
DISCRETEOPTS option 89
TILT= option
LAYOUT OVERLAY3D statement
312
TIME axes 70
formatting tick values 100
overview 97
setting data range 101
setting tick values 98
TIP= option
plot statements 43
TIPFORMAT= option
plot statements 43
TIPLABEL= option
plot statements 43
TIPMAX= option
540
Index

ODS GRAPHICS statement 451
TITLE= option
defining a title for a legend 158
legend statements 185
TITLEATTRS= option
legend statements 186
TITLEBORDER= option
legend statements 185
titles
See ENTRYTITLE statement
TRANSPARENCY= attribute
for fills 494
type conversion
expressions 338
TYPE=
axis type 70, 102
TYPE= option
DISCRETELEGEND statement 197
TYPEOF function 346
U
UCLM function 352
Unicode codes 165
Unicode values
greek letters, lower case 475
greek letters, upper case 476
hexadecimal values  0
keywords  0
special characters 477
USS function 352
V
VALIGN= option
ENTRY statement 170, 356
LAYOUT GRIDDED statement 360
layout statements 35, 36
legend statements 180
VALUEATTRS= option
BLOCKPLOT statement 383
legend statements 186, 203
VALUEHALIGN= option
BLOCKPLOT statement 383
VALUEVALIGN= option
BLOCKPLOT statement 383
VAR function 352
vector graphics
cases that are not supported 452
vector graphics output
generating 452
VECTORPLOT statement
categorized by plot type 27
VIEWMAX=
axis data range 71, 80
VIEWMIN=
axis data range 71, 80
W
WALL drawing space 406
WALLDISPLAY= option
LAYOUT OVERLAY3D statement
311
WATERFALLCHART statement
categorized by plot type 25
WEIGHT= attribute
for markers 496
for text 497
WHERE statement
on a DATA step 439
SGRENDER procedure 439
width
for graphics output 451
WIDTH= option
ODS GRAPHICS statement 202, 222,
255, 267, 451, 457
X
X2AXISOPTS= option
DISCRETEOPTS= 71
general syntax 68
LINEAROPTS= 71
LOGOPTS= 71
TIMEOPTS= 71
XAXIS= option
mapping data columns 65
plot statements 42
XAXISOPTS= option
DISCRETEOPTS= 71
general syntax 68
LABELSPLIT= 75
LAYOUT OVERLAYEQUATED
statement 304
LINEAROPTS= 71
LOGOPTS= 71
SHORTLABEL= 75
TIMEOPTS= 71
VIEWMAX= 80
VIEWMIN= 80
XAXISPOTS= option
TICKVALUEFORMAT= 243
Y
Y2AXISOPTS= option
DISCRETEOPTS= 71
general syntax 68
LINEAROPTS= 71
LOGOPTS= 71
TIMEOPTS= 71
Index
541

YAXIS= option
mapping data columns 65
plot statements 42
YAXISOPTS= option
DISCRETEOPTS= 71
DISPLAY= 220
general syntax 68
LAYOUT OVERLAYEQUATED
statement 304
LINEAROPTS= 71
LOGOPTS= 71
TIMEOPTS= 71
Z
ZOOM= option
LAYOUT OVERLAY3D statement
312
542
Index



