
MEAP Edition 
Manning Early Access Program 
Julia as a Second Language 
Version 8
Copyright 2022 Manning Publications 
For more information on this and other Manning titles go to 
manning.com 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

welcome 
Thank you for purchasing the MEAP for Julia as a Second Language. I wrote this book because I wanted Julia to 
reach a wider audience. Julia is almost like a hidden gem primarily used by scientists and mathematicians today. 
But Julia has the potential to transform the lives of so many programmers in every field, that I believe there needs 
to be a Julia book for people who are not already deep into machine learning, differential equations, and data 
analysis, even if those are fields Julia excels at. 
With Julia, programmers no longer have to make tradeoffs. They can have high performance, ease of use and high 
productivity all in one language. In the last few years, it has become apparent that Julia also excels at software 
engineering. One of the most dramatic examples is probably the Julia implementation of Apache Arrow which 
managed to achieve more functionality in 5,000 lines of Julia code than 300,000 lines of C++ code. This is a 
testament to Julia's excellent ability to reuse and combine existing code. 
Add advanced meta-programming facilities and you got a language I believe is the future of programming. I’m 
writing this book to appeal to every programmer, even the inexperienced ones. My goal has been to write a fun 
book, not by cracking jokes but by doing fun code examples such as simulating space rockets, simulating battle 
between medieval warriors, analyzing pizza sales, or creating a password keeper using the encryption algorithm 
Caesar used to send secret messages to his generals. 
These code examples have been carefully designed to teach important concepts in Julia such as data modeling, type 
hierarchies, multiple dispatch, and functional programming. I know we live in a world where object-oriented 
programming dominates. The book is written with the assumption that many readers will have an object-oriented 
programming background. Thus I take care to show readers how they can reuse their existing object-oriented 
programming skills and how they adapt to the more functional programming nature of Julia. 
Throughout the book we explore Julia and code examples using interactive programming techniques, known as 
REPL-based development (read-evaluate-print-loop). This powerful way of developing software makes possible rapid 
iteration of software. It helps build software in a more organic fashion which old-school LISP and Scheme 
programmers should be familiar with. 
Some concepts such as my coverage of multiple-dispatch may seem overly detailed for a book targeting 
inexperienced developers. However, this important topic frequently confuses programmers new to Julia. I believe it 
is worth going too deep than too shallow. 
I look forward to getting your feedback, so I can make sure this book can appeal to a broad range of developers 
whether they are interested in general purpose programming, automation or creating a foundation to later explore 
the field of machine learning and data science. 
If you have any questions, comments, or suggestions, please share them in Manning’s liveBook Discussion forum 
for my book. 
—Erik Engheim 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

brief contents 
  1  Why Julia? 
PART 1:   BASICS 
  2  Julia as a calculator 
  3  Control flow 
  4  Julia as a spreadsheet 
  5  Working with text 
  6  Storing data in dictionaries 
PART 2:   TYPES 
  7  Understanding types 
  8  Building a rocket 
  9  Conversion and promotion 
10  Representing unknown values 
PART 3:   COLLECTIONS 
11  Working with strings 
12  Understanding Julia collections 
13  Working with sets 
14  Working with vectors and matrices 
PART 4:   SOFTWARE ENGINEERING 
15  Functional programming in Julia 
16  Organizing and modularizing your code 
PART 5:   GOING IN DEPTH 
17  Input and output 
18  Defining parametric types 
APPENDIX 
 A  Installing and configuring Julia environment 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 

1
This chapter covers
You can choose from hundreds of programming languages, many of them far better known than
Julia. So, why pick Julia?
How would you like to write code faster than you have done before? Not enough? How about
building systems with the fraction of the number of lines of code you normally require? Surely,
such productivity will come at the cost of deplorable performance and high memory
consumption? Nope. In fact, Julia is the language of choice for next-generation climate models,
which have extreme performance and memory requirements.
I know such accolades may come across as a bad sales pitch from a used car salesman, but there
is no denying that Julia in many ways is a revolutionary programming language. You may ask: If
Julia is so great, then why aren’t everybody using it? Why are so many people still using the C
programming language? Familiarity, packages, libraries, and community matter. Mission-critical
software built up in large organizations don’t just transition to the latest and greatest
programming language on a whim.
Many of you reading this book may not care about having the more efficient and productive
programming language. Instead, what you care about is what you can build with it. The simple
answer is: Anything. Julia is a general purpose programming language.
That may not be a satisfactory answer. You could build anything with JavaScript too, in
Why Julia?
The type of problems Julia solves
The benefits of a fast dynamically typed language
How Julia increases programmer productivity
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
1

principle. Yet, we know JavaScript dominates front-end web development. You could write
anything with Lua as well, but it is mostly used as a scripting language for computer games.
Reading this book, your primary interest may be in what kind of job Julia can land you.
Presently the Julia community is strongest within scientific computing, data science and machine
learning. But learning Julia is also a bet on the future. A language with such strong capabilities
does not remain within a small niche. If you read on, it will become clearer what Julia is and why
it has such potential. I will also cover areas where Julia is not ideal.
Julia is a general-purpose, multi-platform programming language that is:
Suited for numerical analysis and computational science
Dynamically typed
High performance and Just-in-Time compiled (JIT)
Using automatic memory management (garbage collection)
Composable
Okay, that’s a lot, and some of these things sound like contradictions. So how can Julia be a
general-purpose language and also tailored towards numerical programming? It’s
general-purpose because, like Python, Julia can be used for almost anything. It’s numerical
because, like Matlab, Julia is well suited for numerical programming. But it isn’t limited to
numerical programming; it’s good for other uses.
By 
, we mean that Julia makes it easy to express many object-oriented and functional
composable
programming patterns facilitating code reuse.
Let’s focus on one aspect of Julia: the fact that it’s dynamically typed. Usually programming
languages are divided into two broad categories:
Dynamically typed
Statically typed
In static languages, expressions have types; in dynamic languages, values have types.
– Stefan Karpinski Julia Creator
Examples of statically typed languages are C/C++, C#, Java, Swift, Go, Rust, Pascal, and
Fortran. In a statically typed language, type checks are performed on all your code before your
program is allowed to run.
Examples of dynamically typed languages are Python, Perl, Ruby, JavaScript, Matlab, and LISP.
Dynamically typed languages perform type checks while the program is running. Unfortunately,
1.1 What is Julia?
1.1.1 Pros and cons of statically and dynamically typed languages
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
2

dynamically typed languages tend to be very slow.
In dynamic languages, values such as numbers, characters, and strings have attached tags that
say what type they are. These tags allow programs written in a dynamically typed language to
check type correctness at runtime.
Julia is unusual in that it is both a dynamically typed language and high performance. To many,
this is a contradiction. This unique trait of Julia is made possible because the language was
explicitly designed for just-in-time (JIT) compilation and uses a feature called multiple-dispatch
for all function calls. Languages such as C/C++ and Fortran use ahead-of-time (AOT)
compilation. A compiler translates the whole program into machine code before it can run. Other
languages, such as Python, Ruby, and Basic, use an interpreter. With interpreted languages, a
program reads each line of source code and interprets it at runtime to carry out the instructions
given.
SIDEBAR
LANGUAGE DESIGN AND JIT COMPILATION
In principle, a programming language is decoupled from the method used to
run it. Yet you will find that I talk about Julia as a JIT-compiled language and
Fortran as an AOT compiled language. Strictly speaking, this is imprecise. For
instance, Julia can run through an interpreter as well. However, most
languages have been designed for a particular form of execution. Julia was
designed for JIT compilation.
Now that you have some idea of what kind of language Julia is, we can begin talking about the
appeal of Julia.
While performance is one of the key selling points of Julia, what caught my attention back in
2013 when I first discovered Julia was how well-thought-out, powerful, and easy to use it was. I
had a program I had rewritten in several languages to compare how expressive, easy to use, and
productive each was. With Julia, I managed to make the most elegant, compact, and easily
readable variant of this code ever. Since then, I have tried many programming languages but
have never gotten close to what I achieved with Julia. Here are some one-liners giving some
sense of the expressiveness of Julia.
Listing 1.1 Julia one-liners
Having been programming since the 1990s, I have had periods where I have felt I had enough of
programming. Julia helped regain the joy of programming. Part of the reason is that once you
1.2 Julia combines elegance, productivity and performance
filter(!isempty, readlines(filename)) # strip out empty lines
filter(endswith(".png"), readdir())   # get PNG files
findall(==(4), [4, 8, 4, 2, 5, 1])    # find every index of the number 4
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
3

master Julia, you will feel that you have a language that works on your team rather than against
you. I think many of us have had the experience of working on a problem where we have a good
idea of how to solve it, but the language we are using is getting in our way. The limitations of the
language force us to add one hack after another. With Julia, I can build software the way I want
without the language putting up obstacles.
Another aspect that adds to your productivity and sense of fun is that Julia comes bundled with a
rich standard library. You hit the ground running. You can get a lot done without hunting all over
the web for some library to do what you want. Julia has you covered whether you want to do
linear algebra, statistics, HTTP, string manipulation, or working with different date formats. And
if the capability you want isn’t in the standard library, Julia has a tightly integrated package
manager that makes adding third-party libraries a walk in the park.
Programming Julia almost makes you feel guilty or spoiled because you can build rich and
elegant abstractions without taking a performance hit.
Another essential advantage of Julia is that it is easy to learn. This ease of learning can help Julia
gain a larger community over time. To understand why Julia is easy to learn, consider the famous
"hello world," program written in Julia:
When run, this code writes the text "hello world," to the screen. While trivial, many languages
require a lot of complex scaffolding to do something that simple. This is a Java program which
does the same thing:
That exposes the beginner to a lot more concepts all at once, which can be overwhelming for the
beginner. Julia is easier to learn because we can focus on learning one concept at a time. You can
learn to write a function without ever seeing a type definition. With a lot of functionality
available out of the box, you don’t even need to know how to import external libraries to write
helpful code.
To truly understand what Julia brings to the table, we need to understand better 
 Julia was
why
created in the first place. The creators of the Julia programming language wanted to solve what
they have called the 
.
two-language problem
It refers to the fact that a lot of software is written using two different programming languages,
1.3 Why Julia was created
print("Hello world")
public class Main {
    public static void main(String[] args) {
        System.out.print("hello world");
    }
}
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
4

each with different characteristics. In the scientific domain, machine learning and data analysis
dynamic languages are often preferred. However, these languages usually don’t give good
enough performance. Thus solutions often have to be rewritten in higher performance statically
typed languages. But why does this preference exist? Why not write everything in a traditional
high-performance statically typed language?
Scientists began writing software such as large weather simulations in Fortran  and neural
1
networks  in C or C++ . These languages offer the kind of performance you need to tackle these
2
3
problems. However, these languages come at a price. They tend to be rigid and verbose and lack
expressiveness, all of which reduce programmer productivity.
The fundamental problem, however, is that these languages are not suited for interactive
. What do I mean by that? The ability to write code and get immediate feedback.
programming
Interactive programming matters a lot in data science and machine learning. In a typical data
analysis process, data is explored by a developer loading large amounts of data into an
interactive programming environment. Then the developer performs various analyses of this
data. It could be finding averages and maximum values. It could be plotting a histogram. The
results of the first analysis tell the programmer what the next steps should be.
Figure 1.1 shows this process in a dynamically typed language. You start by running the code,
which loads the data, which you can then observe. However, you don’t have to go through this
whole process after you change the code. You can change the code and observe changes
immediately. You don’t need to load massive amounts of data over again.
1.3.1 Scientists need the interactive programming that dynamically typed
languages offer
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
5

1.  
2.  
Figure 1.1 In dynamically typed languages we can ping-pong between coding and observing. Large data
sets do not need to be reloaded into memory.
Let’s contrast this experience with the use of a statically typed language such as Fortran, C/C++
or Java . The developer would write some code to load the data and explore it, without knowing
4
anything about what the data looks like. They would then have to wait for the program to
Compile.
Launch, then load a large amount of data.
At this point the developer sees a plot of the data and statistics, which gives the developer the
information they need to choose the next analysis. But choosing the next analysis would require
repeating the whole cycle over again. The large blob of data has to be reloaded on every
iteration. This makes each iteration exceedingly slow. This slows down the whole analysis
process. This is a static non-interactive way of programming.
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
6

Figure 1.2 Statically typed languages requires the whole loop to be repeated.
However, this problem isn’t unique to scientists. Game developers have long faced the same
problem. What we call a game engine is usually written in a language such as C and C++ that
can compile to fast machine code. This part of the software often does well-understood and
well-defined things such as drawing objects on the screen and checking if they collide with each
other.
Like a data analyst, a game developer has a lot of code which will need numerous iterations to
work satisfactory. Specifically developing good game play requires a lot of experimentation and
iteration. One has to tweak and alter code for how characters in the game behave. The layout of a
map or level has to be experimented with repeatedly to get it right. For this reason, almost all
game engines use a second language which allows on the fly change of code. Frequently this is
languages such as Lua , JavaScript, and Python .
5
6
With these languages, the code for game characters and maps can be changed without requiring a
recompile and reloading of maps, levels, and characters. Thus one can experiment with game
play, pause, make code changes, and continue straight away with the new changes.
Machine learning professionals face similar challenges. They build predictive models, such as
1.3.2 Developers in other fields also need the interactivity that a dynamically
typed language offers
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
7

neural networks, which they feed large amounts of data to train. This is often as much of a
science as an art. Getting it right requires experimentation. If you need to reload training data
every time you modify your model, then that will slow down the development process. For this
reason dynamically typed languages such as Python, R, and MATLAB became very popular in
the scientific community.
However, because these languages aren’t very fast, they get paired with languages such as
Fortran and C/C++ to get good performance. A neural network made with TensorFlow  or
7
PyTorch  is made up of components written in C/C++. Python is used to arrange and connect
8
these components. Thus at runtime we can rearrange these components using Python without
reloading the whole program.
Climate models and macro economic models may get developed in a dynamic language first and
tested on a small dataset while being developed. Once the model is finished, many organizations
would hire C/C++ or Fortran developers to rewrite the solution in a high-performance language.
Thus we get an extra step, complicating the development processes and adding costs.
To solve the problem of having to use two languages, Julia was created. It makes it possible to
combine the flexibility of a dynamically typed language with the performance of a statically
typed language. That is why we like to say that:
Julia walks like Python. Runs like C.
– Popular saying in Julia community
Using Julia, developers within many fields can write code with the same productivity as with
languages such as Python, Ruby, R, and Matlab. Because of this, Julia has had a profound impact
on the industry. In the July 2019 edition of 
, you can read interviews of various scientists
Nature
about their use of Julia.
For instance, at the University of Melbourne, they have seen an 800x improvement by porting
computational models from R to Julia.
You can do things in an hour that would otherwise take weeks or months.
– Michael Stumpf Systems Biologist UOM
Jane Herriman, Materials Science Caltech, reports seeing tenfold-faster runs since rewriting her
Python code in Julia.
At the International Conference for Supercomputing in 2019 (SC19), Alan Edelman, one of the
Julia creators, recounts how a group at the Massachusetts Institute of Technology (MIT) rewrote
part of their Fortran climate model into Julia. They determined ahead of time that they would
tolerate a 3x slowdown of their code. That was an acceptable tradeoff to get access to a
1.4 Julia’s higher performance solves the two-language problem
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
8

high-level language with higher productivity in their view. Instead, they got a 3x speed boost by
switching to Julia.
These are just a few of the many stories that abound today about how Julia is revolutionizing
scientific computing and high-performance computing in general. By avoiding the two language
problems, scientists can work much faster than before.
These stories can give the false impression that Julia is a language for brainiacs in white lab
coats. But nothing could be further away from the truth. It turns out that a lot of the traits that
make Julia great language for scientists also make it an excellent language for everybody else.
Julia offers
Strong facilities for modularizing and reusing code
A strict type-system that helps catch bugs in your code when it runs
A sophisticated system for reducing repetitive boilerplate code (metaprogramming )
9
A rich and flexible type system that allows you to model a wide variety of problems
A well-equipped standard library and various third-party libraries to handle various tasks
Great string processing facilities. This ability is usually a key selling point for any
swiss-army knife style of programming language. It is what initially made languages such
as Perl, Python, and Ruby popular
Easily interface with a variety of other programming languages and tools
While Julia’s big selling point is that it fixes the two-language problem, that does not mean the
need to interface with existing Fortran, C or C++ code is alleviated. The point of fixing the
two-language problem is to avoid having to write Fortran or C code each time you hit a
performance problem. You can stick with Julia the whole way.
However, if somebody has already solved a problem you have in another language, it may not
make sense for you to rewrite that solution from scratch in Julia. Python, R, C, C++, and Fortran
have large packages that have been built over many years. The Julia community can’t replace
those overnight. To be productive, Julia developers need to be able to take advantage of existing
software solutions.
In the long term, there is an obvious advantage in transitioning legacy software to Julia.
Maintaining old Fortran libraries will often require a lot more developer effort than maintaining a
Julia library.
The greatest benefit is probably in the combinatorial power Julia gives. There are certain types of
problems that require the construction of large monolithic libraries. Julia, in contrast, is
exceptionally well suited towards making small libraries that can easily be combined to match
the functionality offered by large monolithic libraries in other languages. Let me give one
example.
1.5 Julia is for everyone
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
9

Machine learning, a hot topic, powers self-driving cars, face recognition, voice recognition, and
many other innovative technologies. The most famous packages for machine learning are
PyTorch and TensorFlow. These packages are enormous monoliths maintained by large teams.
There is no code sharing between them. Julia has a multitude of machine learning libraries such
as Knet, Flux
, and Mocha
. These libraries are tiny in comparison. Why? Because the
10
11
capabilities of PyTorch and TensorFlow can be matched by combining multiple small libraries in
Julia. Explaining more about why this works is a complex topic that requires a much deeper
knowledge of Julia and how neural network libraries work.
Many small libraries are an advantage with general application. Anyone building any kind of
software will benefit from the ability to reuse existing pieces of software in a multitude of new
ways instead of having to reinvent the wheel. With legacy programming languages, one often has
to repeatedly implement the same functionality. TensorFlow and PyTorch, for instance, have a
lot of duplicate functionality. Julia avoids duplication by putting a lot more functionality in
libraries shared between many machine learning libraries. As we work through the chapters in
this book, it will become increasingly clear to you how Julia can pull this off and why this
capability is hard to achieve in many other languages.
In principle, you can use Julia can be used to build anything. However, every language has an
eco-system of packages and a community that may push you more towards other types of
development than others. Julia is no different.
Julia has a strong presence in the sciences. It is used, for example, in
Computational biology
Statistics
Machine learning
Image processing
Computational calculus
Physics
But Julia covers many more areas. For instance, it’s used in energy trading. The American
Federal Reserve uses it to build complex macroeconomic models. Nobel Laureate Thomas J.
Sargent founded QuantEcon, a platform that advances pedagogy in quantitative economics using
both Julia and Python. He is a strong proponent of Julia, seeing as how the big problems in
macroeconomics will be difficult to solve with other programming languages.
In interviews with Lukas Biewald, Peter Norvig, a famous artificial intelligence (AI) researcher
working at Google, has expressed how he thinks the machine learning world would benefit
1.6 What can I build with Julia?
1.6.1 Julia in the sciences
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
10

greatly from switching to Julia.
I Would Be Happier If Julia were the Main Language for AI.
– Peter Norvig Author of Artificial Intelligence: A Modern Approach
Life sciences is another obvious area for Julia. By 2025, 2-40 exabytes of human genome data
will be collected every year. Most mainstream software cannot handle data at that scale. You will
need a high-performance language such as Julia that can work with a variety of formats on a
variety of hardware at the highest possible performance.
At the time of writing this chapter, COVID19 is still a major challenge in the world. The Julia
package Pathogen is used to model infectious disease and thus used by COVID19 researchers.
What about the non-science parts? Julia also has a multitude of packages for other interests:
Genie - A full-stack MVC web framework
Blink - Let’s you make Electron GUI apps in Julia
Gtk - Making Julia GUI application using the popular Linux GUI toolkit Gtk
QML - Let you create cross-platform GUIs using the QML markup language used in the
Qt GUI toolkit
GameZero - Game development for beginners
Luxor - Drawing vector images
Miletus - Write financial contracts
TerminalMenus - Allows interactive menus in the terminal
Gumbo - Parsing HTML pages
Cascadia - A CSS selector library. One can use this for web scraping, extracting useful
information from web pages
QRCode - Create images of QR codes popular with ads to show machine-readable URLs
As you can see, Julia has packages for general-purpose programming.
In principle, Julia can be used for almost anything, but being a young language means the
selection of libraries is not equally comprehensive in every area. For example, the selection of
packages for web development is limited. Building something like a mobile application would
not work well with Julia. It is also not great for small, short-running scripts, the kind you often
write in Bash, Python, or Ruby. The reason for this is that Julia is JIT-compiled.
That means Julia programs start more slowly than, for example, Python or Bash programs but
begin to run much faster once the JIT compiler has converted critical parts of the code to
1.7 Where Julia is less ideal
1.6.2 Non-science uses of Julia
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
11

1.  
2.  
3.  
4.  
5.  
machine code. There is an ongoing effort in the Julia community to reduce this problem. There is
a myriad of ways of tackling this problem, from better caching of previous JIT compilation to
being more selective about when something is JIT-compiled.
Julia is also not ideal for real-time systems. In a real-time system, the software has to respond to
things that happen in the real world. You can contrast this with, for instance, a weather simulator.
With a weather simulator, it doesn’t matter what happens in the world outside the computer
running the simulation.
However, if your program has to process data arriving from a measuring instrument every
millisecond, then you can’t have sudden hiccups or delays. Otherwise, you risk losing important
measurements. Julia is a garbage-collected language. That means data no longer used in your
program gets automatically recycled for other purposes. The process of determining what
memory to recycle tends to introduce small random delays and hiccups in program execution.
This problem should not be overstated. Robotics that require real-time behavior are being done
in Julia. Researchers at MIT have simulated real-time control of the Boston Dynamics Atlas
humanoid robot balancing on flat ground. This was to prove that Julia can be used for online
control of robots by tweaking how Julia allocates and releases memory.
Julia is not well suited for embedded systems with limited memory. The reason is that Julia
achieves high performance by creating highly specialized versions of the same code. Hence
memory usage for the code itself would be higher in Julia than for, say, C or C++ or Python.
Finally, just like Python, Ruby, and other dynamic languages, Julia is not suited for typical
systems programming such as making database systems or operating system kernels. These tasks
tend to require detailed control of resource usage, which Julia does not offer. Julia is a high-level
language aimed at ease of use, which means many details about resource usage gets abstracted
away.
If you already program in another language, this book is for you. Every programming language
has a unique set of features, tools, and communities. In this book, I focus on Julia’s unique
characteristics as a language and on the tools and programming community built up around Julia.
I emphasize several integral aspects of Julia as a language and community:
Interactive programming using a REPL (read-evaluate-print-loop)
.
12
Science- and mathematics-oriented code examples.
Julia’s unique 
 feature and type system.
multiple-dispatch
Functional programming and how it compares with object-oriented programming.
Package-oriented development over app-oriented development.
1.8 What you will learn in this book
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
12

REPL-based development means that I can launch the Julia command-line tool and start typing
Julia expressions, which get evaluated when I press 
.
Enter
I follow this approach through most of the book. It may be unfamiliar to readers who come from
languages such as C/C++, Java, and C#, but in the Julia community, this development style is
often favored. The REPL environment is used both for experimentation, testing, and debugging.
Because Julia is used heavily in data science, machine learning, mathematics, and science, I use
many science- and math-oriented examples in this book, such as calculating sine values or
simulating a rocket launch, rather than building a website or inventory system. I keep the
mathematics at a high school level.
In this book, you will find in-depth coverage of Julia’s multiple-dispatch system and type
system. These systems matter because they are a crucial reason Julia achieves such high
performance. Because many Julia beginners are confused about these systems, I go into
somewhat more detail on these topics.
Because the software industry is still dominated by object-oriented programming languages, it
can be disorienting to jump into the more functional programming style of Julia. Thus I have
devoted space to show how the same problems can be solved in a functional and object-oriented
style. Many of the preferred functional programming practices are used throughout the book.
When working through this book, you will not see a lot of applications made; that is, the kind
where you click an icon, and it launches. Nor will you see command-line tools made in Julia that
can be run from the console. This choice will be new to, for example, Ruby and Python
developers, who are very accustomed to building software as command-line tools.
The Julia community is instead very package-oriented. The Julia community wants to encourage
you to build packages over standalone applications as these can more easily be shared with
others and reused rather than applications. This preference is reflected in the Julia toolchain and
package manager.
Julia doesn’t prevent you from building applications, but this book will get you into the
package-first mindset. Build a package first and then turn that into an application.
The package-oriented mindset is visible in how Julia’s tools tend to be delivered. The package
manager and debugger are handled by loading particular packages into the Julia interactive
julia> reverse("abc")
"cba"
julia> 3+5
8
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
13

environment and issuing commands there instead of in the shell. This way of working might be
familiar to Matlab and R users. One tends to focus on packages rather than applications in these
two languages.
A typical statistician, scientist, or data analyst using Julia is going to load up favored packages
into their Julia environment and execute Julia commands rather than clicking on some
application made using Julia. The Julia REPL will typically be an integral part of most Julia
workflows.
Static typing makes it easier to construct high-performance programming languages and
catch type mistakes before the program is run
Dynamic typing make it possible to make highly interactive programming languages. For
programming which requires rapid iteration, this is an advantage
Development of scientific code often requires the ability to experiment on large datasets
easily. This requires interactive programming offered by dynamically typed languages
Scientific code often needs high performance, which dynamically typed languages
normally cannot offer
Julia is able to solve this contradiction by offering a high-performance dynamically typed
language. This ability drives the adoption of Julia in performance-demanding fields such
as climate modeling, astronomy, and macro-economic simulations
Julia is not limited to science but is also an excellent general-purpose programming
language
1.9 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
14

Part-1
These chapters try to cover as much of the whole language as possible at a basic level. The other
parts will then expand on and go into more depth on the topics covered in Basics.
We learn about how to work with numbers, arrays, if-statements, for loops, text strings, basic I/O
and storing and retrieving data from dictionaries.
Basics
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
15

2
This chapter covers
Even if you never end up using Julia as your primary language, you may still value it as a
replacement for your desk calculator. Julia can even double as an advanced high school graphing
calculator. As a bonus, it’s completely free to use.
Remember you have to walk before you can run, and exploring numbers is a great way to get
introduced to the core concepts of Julia. Since Julia is not just a general-purpose programming
language but specifically tailored towards numerical computing, manipulating numbers plays a
unique role in Julia.
Julia as a calculator
Working with integers, floating-point numbers, and fractions
Using variables to store long numbers
Create reusable calculations by defining functions
The most basic types in Julia
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
16

Figure 2.1 iOS Calculator application. Can we replace this with Julia?
In this chapter, we will look at the aspects of Julia that let you do the same kinds of things in
Julia that you would do with a calculator. Of course, you may object that you don’t intend to use
Julia as a calculator, but this is simply a way to give you the foundation to understand the more
complex topics.
If you have Julia properly installed and configured (see appendix), you can type Julia at your
terminal prompt to start the Julia read-evaluate-print-loop (REPL). This interactive
command-line program reads your input much like a calculator and prints out the result as soon
as you hit enter. The REPL is a place for testing your code, looking up documentation, and
installing third-party software.
In this chapter, we will focus on evaluating mathematical expressions in the REPL. The next
code example demonstrates how we launch the Julia command line from the terminal (console)
application. After it has launched, we type in 2 + 3 and hit enter. Julia evaluates this expression
and prints 5.
2.1 The Julia command Line
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
17

We can do far more complex operations than adding two single-digit numbers. In the next
example, we perform some of the most common mathematical operations, including getting the
logarithm, sine, and square root. 
 is a mathematical function that evaluates to a random
rand
number between 0 and 1.
Complex expressions can be nested with parentheses.
Exponents. Taking two to the power of three.
The natural logarithm of 2.71, also known as Euler’s number .e
Get sine of /2 radians.
The square root of 9.
Generate a random number from 0 to 1.
Remembering all the digits in numbers such as 3.1415926… (π) or number 2.71828… (Euler’s
number ) is tedious. In fact, it is impossible since both numbers are what we call 
e
irrational
, which means they have an 
 number of digits. Therefore, it is much better to give
numbers
infinite
each number a name. Or, to be more accurate, an 
.
identifier
2.2 Using constants and variables
$ julia
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.6.0 (2021-03-24)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |
julia> 2 + 3
5
julia> 4 * 5
20
julia> (1.5 + 3.5)*4 
20.0
julia> 2^3 
8
julia> log(2.71828^4) 
3.999997309389128
julia> sin(3.1415926/2) 
0.9999999999999997
julia> sqrt(9) 
3.0
julia> rand() 
0.14765146459147327
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
18

IMPORTANT
Variables and 
 define areas in memory in which values (data) are
constants
stored. Think of memory as a long list of numbered mailboxes, each holding a
value. To avoid remembering the number of the mailbox containing a value,
we affix a named identifier.
You can change the value of a variable after it has been created, but not
the value of a constant.
Identifiers can be used to give names to constants, variables, types, and functions in Julia. 
 (π),
pi
 (φ), and Euler’s number  are identifiers used to refer to numerical 
. Both
golden
e
constants
constants and variables simplify remembering long, complicated numbers.
Make common mathematical constant available to Julia. 
 is always available but
pi
not the other ones.
Euler’s number is used a lot with logarithms.
The golden ratio is often used in arts for aesthetic reasons and appears in nature,
such as the spiral arrangement of leaves.
Catalan’s constant.
With these constants, it becomes more convenient to write mathematical expressions. We also
get more accurate results because it isn’t possible to write Euler’s number  or π with enough
e
digits. These are irrational numbers with an infinite number of digits. Mathematicians don’t
actually know if Catalan’s number is irrational, but it is modeled as an irrational number in Julia.
You are, however, not limited to using built-in constants. You can define your own in Julia with
the 
 keyword and use them in calculations instead of number literals 
:
const
13
julia> using Base.MathConstants 
julia> pi
 = 3.1415926535897...
julia> e 
 = 2.7182818284590...
julia> golden 
 = 1.6180339887498...
julia> catalan 
catalan = 0.9159655941772...
julia> log(e^4)
4.0
julia> sin(pi/2)
1.0
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
19

What is up with the funny-looking names 
, 
 and 
? These are nonsense words
foo
bar
qux
commonly used in code examples to inform the reader that they can pick 
 word they
whatever
like in this case. That is different from words like 
, 
, 
 and 
, which are
if while const
function
reserved words. You are not allowed to use them as variable names.
When writing Julia identifiers, you can mix and match cases. 
 and 
 are equally
foObAr
FOObar
valid. But Julia is case sensitive, so they will be treated as 
 identifiers.
different
TIP
Julia’s identifiers are case sensitive. 
, 
 and 
 will not be treated as
foo Foo
FOO
the same identifiers by Julia. That is standard practice in most modern
programming languages today.
You can add numbers as long as they are not at the start of the word. Thus 
 is valid but 
f00bar
 is not. However, if you have used any other programming language, this should not
1oobar
surprise you.
Julia is unusual in the frequent use of Greek letters such as π, θ, α, and Δ in Julia code. The
reason for this is that mathematics is usually written using greek letters. When a mathematical
equation is implemented in code, it becomes easier to read the code if it looks similar to the
equation.
To accommodate this, the Julia creators built-in special features in the Julia REPL and Julia
editor plugins to make writing greek letters and other Unicode characters easy. For example, in
the REPL environment, you write a backlash, the name of the character you want, and hit tab.
After I hit the 
 key, this turns into:
tab
Here is an overview of some popular greek letters and Unicode characters you may like to use in
your code, with some comments on what they usually mean. Note there is no shortcut for writing
julia> const foo = 3481
3481
julia> const bar = 200
200
julia> foo + bar
3681
julia> const qux = 8
8
julia> qux + 2
10
julia> \pi
julia> 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
20

 as a greek letter.
golden
We have to look at constants, but what makes variables different? Creating variables is very
similar, except we don’t use the 
 keyword.
const
So what exactly is the difference? This REPL interaction demonstrates the difference.
In this example, we made  a constant and  a variable. Notice how Julia warns us that we are
x
y
trying to change the value of a constant. While this may indeed work, Julia makes no guarantees
that it will, which is why Julia gives you a warning. Never make your code rely on undefined
behavior.
NOTE
Useful hotkeys
Use Ctrl-D to exit Julia. Ctrl-C to break execution of some code that has gotten
stuck. Clearing the terminal screen varies between operating systems. On
Mac, you use Command-K to clear the terminal. Linux uses Ctrl-L.
Restart Julia to make all identifiers available again.
Character
Tab Completion
Usage
\pi
Circle equations
\theta
Angles
\Delta
A difference or change in something
e
\euler
Euler’s number. Important in logarithms.
\sqrt
operator to get the square root of a number
julia> y = 7
7
julia> z = 3
3
julia> y + z + 2
12
julia> const x = 9
9
julia> y = 7
7
julia> x = 12
WARNING: redefinition of constant x. This may fail, cause incorrect answers,
or produce other errors.
12
julia> y = 8
8
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
21

The  operator is used to assign a value to a variable in Julia. Comparing two expressions for
=
equality is done with a double equal sign 
. However, to be accurate, what Julia does is not an
==
assignment but binding. To better understand how binding works, we will look at a code
example where the variable  is first bound to the value 2. Next, it is rebound to the value 
.
x
x + 3
Set initial value of  to 0.
x
Increment  with two.
x
If this code example had been a language such as C/C++, Fortran or Pascal then the system
would have put aside a slot of memory to hold the  variable. Each time you assign a new value
x
to variable , the number stored in this memory location would be changed.
x
With binding, it works differently. You have to think about each calculation as producing a
number that gets put in a different memory location. Binding involves moving the  label itself
x
to a new memory location. The variable moves to the result rather than the result is moving to
the variable. The illustration below with the step-by-step explanation should help clarify how this
works.
2.2.1 Assigning and binding values to variables
julia> x = 2 
2
julia> x = x + 3 
5
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
22

1.  
2.  
3.  
Figure 2.2 Binding variable  to different memory locations.
x
The value 2 is stored in memory cell number 2. We attach the label  to this value. That
x
is equivalent to our initial assignment statement 
.
x = 2
Julia begins to evaluate 
 in the expression 
. It stores the result of this
x + 3
x = x + 3
calculation at memory cell number 4.
To complete the evaluation of the 
 statement, Julia moves the  label to
x = x + 3
x
memory cell 4.
But why do Julia and other dynamically typed languages perform binding rather than
assignment? With a language such as C/C++ you can write statements such as:
Listing 2.1 Assignment in C/C++
int x = 4;
x = 5;
char ch = 'A';
ch = 'B';
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
23

This works because the compiler will make sure you never attempt to put a value that cannot fit
inside the memory slot set aside for the variable  and variable 
. In a dynamically typed
x
ch
language, any value can be assigned to , and thus, it cannot have a predefined size in a
x
predefined location in memory.
There is a special variable in Julia that only exists when you use Julia interactively called ans
(answer). The Julia REPL assigns the value of the last expression you evaluate to it. Expressions
in normal programs are not assigned to it.
Many people will be familiar with a similar variable if they have used advanced calculators. ans
is a variable that always holds the result of the last calculation. This behavior is practical as it
allows us to easily use the result from the last calculation in the next calculation.
If you read mathematics, you may have noticed that something like 3 × x + 2 × y would be
written as 3x + 2y. Julia lets you write a multiplication in the same manner. We refer to this as
literal coefficients. It is just a shorthand for multiplication between a number literal and a
constant or variable.
Literal coefficients only work for actual number literals. π,  and φ, for instance, are not number
e
literals. You can write 2π but not π2, because the latter would imply an identifier.
There is a subtle difference between using literal coefficients and performing multiplication. See
if you can make sense of the following example?
2.2.2 Using the 
 variable
ans
julia> 3 + 2
5
julia> ans*4
20
julia> ans
20
julia> ans - 8
12
2.2.3 What is a literal coefficient?
julia> x = 3
3
julia> 2x
6
julia> 2*(3+2)
10
julia> 2(3+2)
10
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
24

What is going on here? 
 is interpreted as 
. Literal coefficients have higher
1/2x
1/(2*x)
precedence than division.
Julia has a variety of different number types such as signed integers, unsigned integers and
floating-point numbers with different bit-lengths. If these concepts are unfamiliar to you, we
advise you to read about different number types in Appendix B.
Let us focus on what is particular to Julia. In Julia, signed integers are named 
, 
, 
Int8 Int16
, 
, and 
. The number suffix indicates the bit-length of the number. Unsigned
Int32 Int64
Int128
integers type names are formed by prefixing with a , which gives us 
, 
, 
, 
U
UInt8 UInt16 UInt32
, and 
.
UInt64
UInt128
While running code, it is often practical to know the minimum and maximum value a particular
integer type. We can use the 
 and 
 functions to discover minimum and
typemin
typemax
maximum values. For instance, 
 returns -128 because an 8-bit integer cannot
typemin(Int8)
represent smaller values than -128. 
 will return 127.
typemax(Int8)
The default bit-length of a Julia number literal is a signed 64-bit integer. We can easily verify
that, using the 
 function, which returns the type of the input argument.
typeof
How do we form numbers of other bit-lengths, then? If you want to create a signed 8-bit number,
you write 
, where  is the number you would like to turn into an 8-bit number. This
Int8(x)
x
works for any number type. Naturally, if you try to input a number which is too large for the
bit-length, you will get an error message.
2.3 Different number types and their bit-length in Julia
julia> x = 5
5
julia> 1/2x
0.1
julia> 1/2*x
2.5
julia> typemax(Int8)
127
julia> typemin(Int8)
-128
julia> typeof(1)
Int64
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
25

You should know that unlike other popular dynamically typed languages such as Python, Ruby,
and R Julia doesn’t automatically pick a number type which is large enough to hold the result of
an arithmetic operation. In Julia, if you add two 
 values, then the result will always be an 
Int8
 value.
Int8
Other dynamic languages would have upgraded to an 
 if the result is too large to represent
Int16
as an 8-bit integer. In Julia, you will instead get an overflow. Read Appendix B if the concept of
integer overflow is unfamiliar to you.
Sometimes even 
 isn’t large enough to hold a value. In these cases we use 
 which
Int128
BigInt
can hold an integer of arbitrary size. This flexibility is paid for in higher memory consumption
and lower performance, so only use 
 when you have to.
BigInt
How do you write a number and how that number is actually stored in memory are two different
things. The numbers 
, 
 and 
 are stored as exactly the same binary number in
0b1101 0x0d
13
computer memory. Julia defaults to showing all signed numbers in decimal format and unsigned
numbers such as 
 in hexadecimal format.
UInt8
Hexadecimal numbers are popular in low-level bit-oriented programming, but why is that? The
reason is that four bits can be represented by exactly one hexadecimal digit. Octal numbers are
also popular because exactly 3 bits can be used to represent one octal digit.
julia> y = Int8(42)
42
julia> typeof(y)
Int8
julia> typeof(Int16(4))
Int16
julia> UInt8(256)
ERROR: InexactError: trunc(UInt8, 256)
2.3.1 Writing numbers using different number formats
julia> Int(0b1101)
13
julia> Int(0x0d)
13
julia> UInt8(13)
0x0d
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
26

SIDEBAR
HEXADECIMAL AND OCTAL NUMBERS
Decimal numbers are created by combining digits from 0 to 9. Octal numbers
are created by combining digits from 0 to 7. Thus the number 8, would be
written as 10 in the octal number system.
With hexadecimal numbers, we have a problem because the digits in the
hexadecimal number system have to cover values from 1 to 15. However, we
only have symbols for digits 0 to 9. The solution has been to use letters for
digits beyond 9. Thus the value ten, is represented as A, eleven as B, and so
on. F stands for 15.
The largest value that an 8-bit unsigned integer can hold is 0xff, which
translates to 255 in decimal.
To write an octal number, you use the 
 prefix. Please note that you don’t need to understand
0o
this very well. The point is to make you aware of the fact that there are different ways of
representing the same number. This is to avoid confusion when playing with 
 integers in
unsigned
this chapter, as Julia defaults to displaying them in hexadecimal form.
Like integers you have floating-point numbers of different bit-length. In Julia the default size is
64-bit, which means each floating point number consumes 8 bytes of memory. By using more
bits we can not only represent larger numbers but also represent numbers with higher precision.
However precision is not always important. For scientific calculations precision is important.
However when calculating e.g. computer graphics, precision matters less. One pixel out of
millions which is slightly wrong in position or color does not matter much. The most common
floating-point types 
 and 
 can be written as number literals.
Float64
Float32
2.4 Floating-point numbers
julia> 0o5 == 0b101
true
julia> 0o6 == 0b110
true
julia> 0o7 == 0b111
true
julia> 0o10 == 0b1000
true
julia> Int(0o10)
8
julia> Int(0o23)
19
julia> 2 * 8 + 3
19
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
27

A 64-bit floating-point literal. We can verify that with typeof
A 32-bit floating-point number.
Notice the use of the 
 suffix to make the number of a 32-bit floating-point number. Why not
f0
just an  like in Java and C/C++? The reason for this is due to the literal coefficients feature. If
f
you look at the REPL session below you may be able to figure out what is going on.
You see if we try to write a 32-bit floating point number like in Java or C/C++, then Julia thinks
you are trying to multiply a number with the variable . In the first case this fails because we
f
have not yet defined the  variable. In the second case it works because  has been defined.
f
f
How about other floating-point values such as 16-bit values? In these cases you need to perform
an explicit conversion.
Convert 64-bit floating point value to a 16-bit one.
Mixing numbers of different bit-length cause Julia to pick the largest type to store
the result in.
julia> 42.98 
42.98
julia> typeof(ans)
Float64
julia> 34.23f0 
34.23f0
julia> typeof(ans)
Float32
julia> 0.5f
ERROR: UndefVarError: f not defined
julia> f = 2
2
julia> 0.5f
1.0
julia> 2f
4
julia> x = Float16(3.5) 
Float16(3.5)
julia> typeof(x)
Float16
julia> z = Float16(4) + 5f0
9.0f0
julia> typeof(z) 
Float32
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
28

While you can do many of the same operations on floating point out integer numbers, the
operations don’t always have the same kind of results. And there are operations which only work
on certain number types.
For instance the  division operator gives floating-point numbers as result. That is not always
\
what you want. When working with integers you often want the quotient and remainder instead.
This is achieved with the 
 and 
 functions.
div
rem
Regular division operator gives floating-point result.
Integer division which gives an integer result.
However you also get a remainder, which you obtain with % the operator.
You’ve already been exposed to some functions such as 
, 
 and √. These are functions that
sin cos
you can find on a regular calculator. They take a number as input and they give you a number as
output. But what is the fundamental idea behind functions? And secondly are functions in
mathematics and in Julia the same kind of thing? The details differ but conceptually they are the
same kind of thing. Functions have zero or more inputs called arguments. We talk about them as
returning a value or evaluating to a value.
Figure 2.3 Volume of a sphere
2.5 Defining functions
2.4.1 Performing operations on integers and floating point numbers
julia> 4/2 
2.0
julia> 5/2 
2.5
julia> 5.0/2.0 
2.5
julia> div(5,2) 
2
julia> rem(5,2) 
1
julia> 5%2 
1
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
29

Consider the volume of a sphere. How good are you at remembering exactly how this calculation
is performed? I often have to look it up. You could perform this calculation in Julia by writing
this code.
The radius of the sphere.
Storing the volume of the sphere in variable .
V
Variables and constants make it easy to remember long complicated numbers. In many ways you
can think of functions as an extension of this idea. They allow you to remember complicated
calculations. Instead of remembering what numbers to multiply and divide, you only need to
remember the name of a function.
Define the 
 function, which takes a single argument , specifying
sphere_volume
r
the radius of the sphere.
Use previously defined sphere function to calculate the volume of a sphere with
radius 2.
The volume of a sphere with a radius 4.
Notice that when you define a function, unlike a variable, you specify one or more arguments.
Arguments are variables in your calculation that you want to change each time you perform a
calculation. E.g. when calculating the volume of a sphere we want the value of π to be the same
each time. Hence π is not an argument to the function. The radius however is an argument
because we are interested in calculating the volume of spheres of different radii.
Above you see a simple function definition. It’s a function with the name 
, taking three
foo
different arguments named ,  and . You could have few or more arguments. The rules for
x y
z
how you name them are the same as for any Julia identifier.
julia> r = 4.5 
4.5
julia> V = 4*pi*r^3/3 
381.7035074111598
julia> sphere_volume(r) = 4*pi*r^3/3 
sphere_volume (generic function with 1 method)
julia> sphere_volume(2) 
33.510321638291124
julia> sphere_volume(4) 
268.082573106329
julia> sphere_volume(1)
4.1887902047863905
foo(x, y, z) = 2x + 4y - z
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
30

Writing the definition of every function you want to use in the Julia REPL every time you restart
Julia would be impractical. Instead we store function definitions inside separate source code
files.
NOTE
Code comments with #
You can write comments in your code to remind yourself what various parts of
your code does. Comments start with a hash or pound sign . Anything after
#
the hash symbol is ignored by the Julia compiler.
This file can then later be loaded into the Julia REPL when the functions contained within are
needed. Let me demonstrate with an example. We will create a file called 
. Inside
volumes.jl
we store functions to calculate the volume of a sphere, a cylinder and a cone.
Listing 2.2 volumes.jl source code file
We can get the code in this file into Julia in three different ways. The least sophisticated is
perhaps the simply copy paste the text into the Julia command line. Or we could load the file
when we start Julia:
However the more flexible solution is to use the 
 function. This removes the need for
include
restarting your Julia REPL session.
Loads the code in the given file into our current session.
Run one of the functions defined in the file loaded into current session.
2.5.1 Storing function definitions in a file
# Volume calculations
sphere_volume(r)      = 4*r^3/3
cylinder_volume(r, h) = *r^2*h
cone_value(r, h)      = *r^2*h/3
$ julia -i volumes.jl
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.6.0 (2021-03-24)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |
julia> cone_value(2, 4)
16.755160819145562
julia> include("volumes.jl") 
cone_value (generic function with 1 method)
julia> cylinder_volume(1, 2) 
6.283185307179586
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
31

You can make changes to the code in this file and reload it using 
 to capture changes in
include
the function implementations.
Once complex calculations have been stored inside functions, we can easily reuse those
calculations. But how do we deal with a large number of functions? The Julia REPL offers many
ways to help us.
If you start typing the first letters in a function and hit tab, then Julia will attempt to complete the
function name. As if you start typing 
, then hit the 
 key, Julia will complete this to 
sphere
tab
. Sometimes there are many possible completions. In these cases we can hit tab
sphere_volume
twice and get a full list of possible completions.
Hit 
 twice here and get the full list of functions starting with the word 
.
tab
find
On the web page of the Julia programming language you can also find a manual which gives you
a complete list of all the functions built-in to the Julia standard library. This is found at: 
.
docs.julialang.org/en/v1`
Functions are central to Julia. In fact even common mathematical operators are defined as
functions in Julia. Let me give you some examples.
Looks like we are using an operator, but is actually a function call written on infix
form.
Operators called like regular functions. This is called 
 form.
prefix
The benefit of using  as a function is that you can use more than two arguments.
+
E.g. you can use it to add up multiple values.
2.5.2 Working with functions in the REPL
julia> find 
findall   findlast   findmax!   findmin!   findprev
findfirst findmax    findmin    findnext
2.5.3 Functions everywhere
julia> 5 + 3 
8
julia> +(5, 3) 
8
julia> 8 - 2 
6
julia> -(8, 2) 
6
julia> +(2, 3, 5) 
10
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
32

To describe placement of identifiers we use the terms: prefix, infix and suffix. Thus +(3, 4)
would be considered a 
 form, while 
 would be the equivalent 
 form.
prefix
3 + 4
infix
How do we know if we can use a function on infix form? Easy, the function name needs to be a
symbol. For instance you could not use a function named 
 on infix form. Let us make some
foo
of our own to demonstrate it.
Here we made a function named  (write \times) and because it takes two arguments and is a
×
symbol, you can use it on infix form. The simplest way to get a symbol is to write the LaTeX
name and hit tab. Symbol completion will work in the Julia REPL and many Julia code editors.
We have already seen a number of functions which you can use to operate a numbers but Julia
has a large collection of them. I would like to show some of the more useful ones in particular
when working with integers and floating-point numbers. Previously I showed some operations
on integers, and floating-point numbers. However now you know that operations are really just
functions. All of these variants are equivalent:
The principle in Julia is that you should never 
 use special Unicode symbols. Operations
have to
such as integer division can also be performed with simple functions.
In fact if you hit the  key and write an integer division, you will get the built-in help system
?
julia> ×(a, b) = a^2 + b^2
× (generic function with 1 method)
julia> ×(4, 10)
116
julia> 4 × 10
116
julia> 2 × 3
13
2.5.4 Functions to work with numbers
julia> 9 % 6
3
julia> %(9, 6)
3
julia> rem(9, 6)
3
julia> 9÷4
2
julia> ÷(9, 4)
2
julia> div(9, 4)
2
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
33

showing you that 
 has two names:
div
It is very useful to know how to round numbers in different ways. Julia has the functions 
, 
floor
 and 
 for this purpose.
ceil
round
Always rounds downwards.
Always rounds upwards.
Rounds to the closest whole number.
But if we are rounding to integers, then we probably wants integer types.
The native approach to get an integer.
The intended and most efficient approach. You provide the type you want as output
as the first argument.
help?> div(9, 4)
  div(x, y)
  ÷(x, y)
The quotient from Euclidean division. Computes x/y, truncated to an integer.
julia> floor(3.2) 
3.0
julia> floor(3.6) 
3.0
julia> ceil(3.2) 
4.0
julia> ceil(3.8) 
4.0
julia> round(3.2) 
3.0
julia> round(3.5) 
4.0
julia> Int(round(3.5)) 
4
julia> round(Int64, 3.5) 
4
julia> round(Int8, 3.5)
4
julia> typeof(ans)
Int8
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
34

1.  
2.  
A lot of the details covered here are not things you need to think about when doing normal
coding. I don’t want you do pack your brain with too many unnecessary details. The key point
here is to give you an understanding of how numbers work in Julia. This is not unique to Julia,
but may be unfamiliar to developers coming from other dynamic languages such as Python, R or
Ruby.
To make things easy for yourself, here are some simple rules to follow:
Just use the default integer and floating-point sizes. Only consider smaller or larger
numbers when performance or the nature of your problem demands it.
Prefer signed integers to unsigned. It is very easy to screw up using unsigned numbers.
To make it easy for yourself, stick with signed numbers most of the time.
Julia supports different kinds of numbers but the two most important types are integer
numbers and floating point numbers
Unlike numbers used by mathematicians, numbers used in programming have particular
bit-lengths. This determines how large and small values we can store. For instance a
signed 8-bit integer cannot store numbers smaller than -128 or larger than 127
Variables give names to numbers. Functions give names to calculations dependent on
zero or more arguments
Assigning a value to a variable means sticking an identifier on that value. Reassigning
another value to the same variable means moving the sticker to the new value. This is
called binding
Two numbers which look identical in memory, can look different on your screen because
they are of different type
You can input numbers using a variety of different formats: binary, decimal and
hexadecimal. Unless you do systems programming, decimal will usually be the preferred
format
2.6 How to use numbers in practice
2.7 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
35

3
This chapter covers
Control flow is what separates a computer from a mere calculator. Calculators are for computing
single expressions. Computers have the ability to repeat the same calculations with different
inputs numerous times without human intervention. Computers can choose to perform one
calculation over another based on whether a condition holds true or not.
In this chapter we will explore code examples oriented around producing mathematical tables.
We will explore tables for trigonometric functions as such tables are well known and of
historical importance.
Later we will explore conditional execution to help count the growth of rabbits using a method
developed by Italian mathematician Fibonacci 800 years ago.
In the age of sail the use of mathematical tables became more widespread, and a need to develop
ways to automate the calculation of these tables developed. E.g. navigation is based around the
calculation of angles and the sides of triangles. This means using trigonometric functions such as
sine, cosine and tangent.
Control flow
Using Boolean values in conditions
Running the same code multiple times using while and for-loops
Deciding what code to run with an if-statement
Looping over ranges of numbers
Defining functions spanning multiple lines of code
Implementing control flow using recursion or iteration
3.1 Navigation and Trigonometry
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
36

Figure 3.1 A captain on a ship could use a sextant to measure angle  between horizon and top of
lighthouse.
Nautical maps contain heights of different lighthouses. Thus if you want to know your position at
sea while close to shore, you could measure the angle between the horizon and the top of a
lighthouse of known height. This would give you the distance to that lighthouse.
However all of these calculations requires calculating trigonometric functions such as sine and
cosine, and sea captains of the 1700s did not have pocket calculators.
Instead they used mathematical tables. Large printed tables detailing the value of sine, cosine and
tangent for different angles.
Table 3.1
A simple trigonometric table
m
angle
0°
30°
45°
60°
90°
sin
0.000
0.500
0.707
0.866
1.000
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
37

Figure 3.2 A right triangle with sides of length a, b and h. The longest side h is called the hypotenuse
and an angle .
Let me just refresh your highschool math if you have not used trigonometric functions in a while.
If you look at the triangle above then sine, cosine and tangent is defined as follows:
So e.g. the sine of an angle is equal to the length of the opposing side divided by the longest side
(the hypothenus) in a right tringle (one angle is 90°). Today you use a calculator to calculate
these trigonometric functions. But what if you lived before 1972 
? How would you do these
14
calculations by hand? There is in fact no canonical way of calculating sine and cosine. Instead
we have various methods of 
. A popular method of calculating sine is called the
approximation
Taylor’s series:
We can write this in a more compact and generalized form as:
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
38

But mathematical tables are not limited to trigonometric functions. Tables are useful for many
other functions to reduce the amount of hand calculations required.
Figure 3.3 A part of Charles Babbage’s Difference Engine. A precursor to the Analytical Engine, the first
mechanical general purpose computer.
This spurred Charles Babbage to begin the construction of a massive mechanical calculating
machine called the Difference Engine in 1819. It could calculate multiple values for tables by
repeating the same calculation many times over. In modern programming terms it was creating
the tables using loops. Loops are based on evaluating (running) the same code multiple times as
long as a given condition holds true. In all programming languages we use Boolean expressions
to define conditions. We will follow in Babbage’s footsteps by creating such loops in Julia.
Our goal is to implement trigonometric functions in Julia using Taylor series. Before that is
possible we need to develop and understanding of boolean expressions which make it possible to
understand while-loops, for-loops and if-statements. We will develop this understanding through
a number of smaller code examples printing out numbers, adding numbers and converting from
degrees to radians.
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
39

One of the first things we learn in elementary school is about Boolean expressions. Ironically
most students never practice using them for anything. Nobody tells us that they are one of the
most important parts of any programming language. We have already looked at numerical
expressions such as 
. These evaluate to a number. Boolean expressions in contrast evaluate
3 + 5
to 
 or 
. They are easier to grasp with some practical examples:
true
false
Is three larger than five?
Eight larger than tree?
Check if values are equal. Not assignment operator.
Less than or equal.
In the example we use a Unicode version of the 
 operator. Several Boolean
less than or equal
operators have Unicode variants. The following table shows you how to write some of them in
the Julia REPL.
Boolean expressions return Boolean values. There are only two Boolean values 
 and 
.
true
false
Remember how I said everything is numbers inside a computer? Boolean values are no different.
3.2 Boolean Expressions
julia> 3 > 5 
false
julia> 8 > 3 
true
julia> 8 == 5 + 3 
true
julia> 3 == 5 
false
julia> 3  3 
true
julia> 3 <= 3 
true
Character
Tab Completion
Description
\leq
less than or equal <=
\geq
greater than or equal >=
\ne
not equal !=
\approx
isapprox(x, y)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
40

Boolean expressions give values of type 
.
Bool
The 
 value is stored as a zero.
false
 is stored as a one.
true
Unlike many other programming languages, Julia actually allows you to perform arithmetic on
Boolean values. In arithmetic Boolean values are treated as 0 or 1.
For clarity it is best to avoid using Boolean values as numbers. However there are cases where
this is very useful. Julia developers frequently use it to count how many things are true. In
chapter four we will see an example of this.
Booleans expressions can be combined with the 
 and 
 operators. These perform what we
||
&&
call logical 
 and logical 
 operations. Thus given a variable , I could ask e.g. if it is
OR
AND
x
smaller than 4 
 larger than 10.
or
Alternatively would could ask if  is larger than 4 
 smaller than 10.
x
and
julia> typeof(7 > 3) 
Bool
julia> typeof(false)
Bool
julia> reinterpret(UInt8, false) 
0x00
julia> reinterpret(UInt8, true) 
0x01
julia> true + true
2
julia> 3true + true
4
julia> true + false + true
2
julia> false + false
0
3.2.1 Compound Statements
julia> x = 3
3
julia> x < 4 || x > 10
true
julia> x = 5
5
julia> x < 4 || x > 10
false
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
41

Next we will use Boolean expressions to define conditions for repeating the same code multiple
times.
The simplest looping construct in any programming language is the while-loop. It allows you to
repeat the same code over and over again, as long as a Boolean condition is true. Here is an
example:
Listing 3.1 A simple while-loop
All the code between the keywords 
 and 
 gets repeated over and over again as long as
while
end
the condition 
 is true.
i < 5
You could copy-paste this code into your Julia REPL but you would not see any output. Why?
Because while-end is an expression which evaluates to 
. That may sound a bit abstract
nothing
so let me give an example. 
 is an expression which evaluates to 7. You could store the
3 + 4
value of an expression in variables like this:
Pointless while-loop which terminates immediately.
The Julia REPL does not print 
 values.
nothing
Our while-loop example illustrates a couple of different things. The loop itself evaluates to a
value, just like 
. We store this value in variable . However you cannot see the value in the
3 + 4
y
REPL because it is of type 
.
Nothing
Also notice that it is perfectly possible to place a while-loop on a single line. Whitespace is not
significant in Julia, the way it is in Python. In Python you must remember to indent statements
3.3 Looping
julia> x > 4 && x < 10
true
julia> x = 12
12
julia> x > 4 && x < 10
false
i = 0
while i < 5
    i = i + 1
end
julia> x = 3 + 4
7
julia> y = while false end 
julia> typeof(y) 
Nothing
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
42

belonging to a loop. But whitespace does play a role in Julia. If you want to place multiple
statements on a single line, you have to separate them with semicolon. Consider these three
assignments:
If you want them on a single line you need to separate them with a semicolon.
You might wonder why I stored the value of the while-expression in a variable. I do that purely
for teaching purposes, to make you aware of the fact that nearly everything in Julia is an
expression that evaluates to a value. Even an assignment evaluates to a value. While this may
sound like a theoretical curiosity of no interest to you, it does have many practical consequences.
It makes the REPL show what value you gave a variable in an assignment statement.
Listing 3.2 Assignments evaluates to a value
You will also see the benefit of treating everything as an expression when we discuss
if-statements later in the chapter.
NOTE
Calling an assignment a statement is technically wrong because everything in
Julia is an expression. However I will use the word 
 about many
statement
expressions in this book. The reason is that it makes it easier to distinguish
assignments and control-flow such as if-statements and while-loops from
more mathematical expressions.
The REPL will always show the value of the outer expression and not the inner expression. For
instance if you evaluate 
, you will never see  printed, because that is the value of
1 + (3+2)
5
sub-expression 
. Likewise you will not see 
 inside a loop. To 
 the value of 
3+2
i = i + 1
see
i
for every iteration, we need to explicitly tell Julia to print the value to the console. This is done
with the 
 and 
 functions.
print
println
x = 4
y = 8
z = 3
x = 4; y = 8; z = 3
julia> z = 3 + 2
5
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
43

From these examples you can probably tell the difference. 
 is short for 
. It
println
print line
prints a variable on a separate line. You can use 
 and 
 to explicitly print values,
print
println
outside of loops but that is rarely needed.
Text doesn’t visualize the control flow of a program very well. You have to know the semantics.
Thus what used to be very popular in the past was flowchart diagrams. They show the flow of a
programs with boxes and arrows.
Figure 3.4 Standard flowchart boxes
In the past students would get taught to design their programs as flowcharts and then write the
code. The popularity of object-oriented programming caused flowcharts to fall out of use as they
cannot model object relations. However flowchart diagrams are still very useful in teaching
control flow in a program. If you are not familiar with loops, flowcharts can help you develop an
intuition for how they work.
julia> i = 0
0
julia> while i < 5
           i = i + 1
           print(i)
       end
12345
julia> i = 0
0
julia> while i < 5
           i = i + 1
           println(i)
       end
1
2
3
4
5
julia> print(3 + 4)
7
julia> print(i)
5
3.3.1 Flowchart
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
44

Figure 3.5 Visualization of the control flow in a while-loop
The square boxes represents actions performed, while e.g. the diamond shaped boxes represent
decisions where the flow of control branch into different directions. If the condition is i < 5 ?
is true, then the flow will follow the arrow marked with 
. Otherwise control flow would
yes
follow the 
 arrow.
no
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
45

We now have all the basic building blocks to repeat what Charles Babbage’s Difference Engine
did: Calculating mathematical tables. To keep things simple let us just begin by printing out
angles.
Listing 3.3 Loop printing out angles in increments of 15
You could copy paste this code into your Julia REPL and you will get this result printed out.
Before calculating the sine of these angles we need to convert them to radians, as sine, cosine,
and tangent functions generally don’t work with degrees from 0° to 360°, but rather radians from
0 to 2π.
The following illustrations shows how 1 radian is defined. If you have a circle with radius  and
r
draw an arch  of length  along the perimeter of the circle, then the pie slice has an angle equal
s
r
to 1 radian.
Figure 3.6 Relationship between one radian and the radius of a circle
The circumference  and arc length  of a circle is defined as:
C
s
3.3.2 Making a Sine Mathematical Table
angle = 0
while angle <= 90
    println(angle)
    angle = angle + 15
end
0
15
30
45
60
75
90
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
46

From this we can derive a function 
 to convert from degrees to radians.
deg2rad
Listing 3.4 Converting degrees to radians
In fact you don’t have to write this function because Julia already comes with it in its standard
library. But with this we can what we need to modify our loop to produce a table of sine values.
Listing 3.5 Loop printing out a sine table
When you run this you will get the following output:
When reading normal Julia code you will find that looping based on conditions is in fact not the
normal approach. Instead loops tend to be defined using range objects. We construct ranges with
the  operator. We can do a number of things with ranges such as checking whether a particular
:
value is within the given range. In this example we will get the first and last part of a range,
before querying whether a particular number is within a given range.
deg2rad() = (/360)*2
angle = 0
while angle <= 90
    rad = deg2rad(angle)
    x = sin(rad)
    println(x)
    angle = angle + 15
end
0.0
0.25881904510252074
0.49999999999999994
0.7071067811865475
0.8660254037844386
0.9659258262890683
1.0
3.3.3 Range Objects
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
47

Construct a range object, and store it in variable . Or more correctly bind the label
r
 to the range object.
r
Get the start of the range.
Get the end of the range.
Check if 1 is within the range 2 to 4. Since 1 is outside of the range this will
evaluate to false.
Check if 3 is within the range. It is.
Normally you can only use Unicode symbols in infix form, but 
 is an exception. 
in
 is equivalent to 
.
3 in r
in(3, r)
Range objects are commonly used in for-loops, but before showing a for-loop example let me
just show you how you might use it in a while-loop. The loop is repeated as long as the i in
 condition remains 
.
0:4
true
Listing 3.6 While-loop using a range
This is such a common and useful idiom, that for-loops are made to remove a lot of the
boilerplate. The following code, is equivalent in behavior.
Listing 3.7 For-loop over a range
julia> r = 2:4 
2:4
julia> first(r) 
2
julia> last(r) 
4
julia> in(1, r) 
false
julia> in(3, r) 
true
julia> 3 in r 
true
3.3.4 For-Loop
i = 0
while i in 0:4
    println(i)
    i = i + 1
end
for i in 0:4
    println(i)
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
48

What about cases where we don’t want to increment by 1 on each iteration? When we calculated
angles we did it in increments of 15. Is that possible to do with a for-loop? No problem, ranges
allow you to define a step size.
Listing 3.8 For-loop with stepped range
When you run this code you get the following output:
Objects which you can use in a for-loop, such as range objects are what we call 
. There
iterable
are many different objects in Julia which are iterable, and which we will explore in later
chapters.
The functions we have used up until now have been define on just a single line. That is quite
limiting. More complex problems require multiple lines of code. How do you do that? We need a
way to mark the beginning and the end of the code that should be included in the function. The
for-loop and while-loop may already give you a hint at how you would do that. A multiline
function starts with the keyword 
 and ends with the keyword 
.
function
end
In the following example code we are using a loop to print out the sine value for all angles from
0 to 
 with an angle increment.
max_angle
Listing 3.9 Code for creating a sine table stored in a function
Notice how we have replaced our 15 and 90 degree angles with function arguments. Thus users
can easily change the table they produce. E.g. they can produce sine values with 1 degree
increments, with 
.
print_sin_table(1, 90)
3.4 Multiline Functions
for angle in 0:15:90
    println(angle)
end
0
15
30
45
60
75
90
function print_sin_table(increment, max_angle)
    angle = 0
    while angle <= max_angle
        rad = deg2rad(angle)
        x = sin(rad)
        println(x)
        angle = angle + increment
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
49

So how does this relate to the Difference Engine made by Charles Babbage? With the Babbage
solution, his equivalent of 
 would not have written numbers on a computer screen but to
println
a sort of printer. The Difference Engine was meant to be attached to a machine which would
imprint numbers on metal plates. These could then be used for printing number tables in books.
We could also send the numbers we produce to other devices, but this will be covered in later
chapters on input and output.
Now that we have loops and multiline functions, we actually have all the building blocks to build
our own 
 function. We can replicate what a calculator does. We look at the Taylor series
sin
calculating the 
 earlier.
sin(x)
This can be written as a summation.
I am not going to prove mathematically how we arrive at this definition. Our interest here is just
demonstrating how computers can be used to solve such problems which became a real problem
to compute by hand in the 1800s as the importance of mathematics and science expanded.
If you are unfamiliar with mathematical notation, let me demonstrate in code how the ∑ operator
works. Let us start with a simple case.
3.4.1 Implementing The Sine trigonometric Function
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
50

The bottom and top half of the ∑ symbol basically defines a range. We are stating that we will
iterate over the variable  from 1 to . You can think of the ∑ operator as performing a loop. It
x
n
iterates across a range and adds up values of the expression it iterates over. We can mimic this
behavior with a for-loop:
Listing 3.10 How the sum operator works
For storing the total sum.
A shorthand for total = total + 2x + 1
Return value.
A function evaluates to the value of its last expression. In other languages this is typically called
the return-value. In many other languages, the last expression would have been written:
This is 
 valid in Julia, but only used when you need to exit a function early. Otherwise 
also
 is usually omitted in Julia functions.
return
This previous code example should help you understand how we can use the Taylor series to
implement a sine function.
Listing 3.11 Sin implemented using Taylor series
You could place this function in a separate file e.g. 
 along with other trigonometric
trig.jl
functions you implement. That could be a good exercise for the reader. Implement cosine and
tangent as well. You can Google their Taylor series definition. We can then load this file into
Julia and compare with the built-in 
 function.
sin
function f(n)
    total = 0 
    for x in 1:n
        total += 2x + 1 
    end
    total 
end
return total
function sine(x)
    n = 5
    total = 0
    for i in 0:n
        total += (-1)^i*x^(2i+1)/factorial(2i + 1)
    end
    total
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
51

1.  
2.  
3.  
You can see that the results are quite similar despite the fact that we only iterate up to 
.
n = 5
The accurate definition implies that 
, which is naturally impractical to implement in code.
n = 
Try with different values of  to see if you can get as accurate result as the built-in 
 function.
n
sin
Our 
 function uses the built-in 
 function. The factorial of a number  means
sine
factorial
n
multiplying every number from 1 up to . So the factorial of five would be 
.
n
5 × 4 ×3 × 2 × 1
How would we implement this ourselves? There are many approach. We will look at some of
them:
Use the built-in 
 function.
prod
Using a while-loop to perform multiple multiplications.
Multiply repeatedly by combining recursion with an if-statement.
The 
 function is able to multiply all the numbers in a range:
prod
Define our own 
 function named 
, implemented with 
factorial
fac
prod
Check that 
 and 
 gives the same result.
fac
factorial
Experiment with both of these functions to make sure you get the same result. We could do this
by using a loop as before:
3.5 Implementing Factorial
julia> sine(0.5)
0.4794255386041834
julia> sin(0.5)
0.479425538604203
julia> sine(1.0)
0.841470984648068
julia> sin(1.0)
0.8414709848078965
julia> fac(n) = prod(1:n) 
julia> fac(5) 
120
julia> factorial(5) 
120
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
52

Listing 3.12 Factorial implemented using a loop
On each iteration in the loop we decrease the value of  by one until the condition 
 no
n
n >= 1
longer holds true and exit with the product 
 of all numbers in the range  to 1.
15
n
There is another way we can achieve looping without using the 
 and 
 loops, called 
while
for
. Check out the code below:
recursion
Listing 3.13 Broken factorial function implemented using recursion
Try running this. It doesn’t quite work. You get the error message:
This is because the 
 function keeps calling 
 indefinitely. Or more specifically it calls 
fac
fac
fac
79984 times in my example, until it blows up by running out of memory. This produces a 
 error message. The reason is that we keep calling 
 even when the  argument
stackoverflow
fac
n
has become less than 1. Somehow we need to make a check if  has become less than 1 and exit.
n
We are lucky, because Julia’s if-statement can help us do that.
Let us rewrite our recursive 
 function to use an if-statement. The following code is the first
fac
attempt. We will expand on this code until the factorial function handles all edge cases such as 
.
fac(0)
Listing 3.14 Almost working factorial function implemented using recursion
3.6 Factorial with Recursion
3.7 If-Statement
function fac(n)
    prod = 1
    while n >= 1
        prod *= n
        n -= 1
    end
    prod
end
fac(n) = n*fac(n-1)
ERROR: StackOverflowError:
Stacktrace:
 [1] fac(n::Int64) (repeats 79984 times)
function fac(n)
    if n <= 2
        return n 
    end
    n*fac(n-1) 
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
53

We exit the 
 function using the 
 statement if the  argument is less or
fac
return
n
equal to 2. We explicitly call 
 here to do an early return, rather than waiting
return
until we get to the last expression in the function.
Call 
 again but with 
 and multiply returned result with . Remember the last
fac
n-1
n
expression in a Julia function does an implicit return.
Instead of using the 
 statement to exit the function early, we can choose between two
return
different blocks of code to execute by adding an 
 clause like this:
else
Listing 3.15 If-else-statement
If the 
 condition is not 
, we will evaluate the code between the else-end block. The
n <= 2
true
whole if-else statement, like all other statements in Julia, are expressions which evaluate to a
value. Which one you ask? To the value of the code block which was evaluated. You can try this
out in the Julia REPL yourself. Experiment with different values for  and see how the value of 
x
y
changes.
However our 
 function doesn’t actually work correctly yet.
fac
3.7.1 If-Else Statement
function fac(n)
    if n <= 2
        n
    else
        n*fac(n-1)
    end
end
julia> x = 4
4
julia> y = if x > 3
           6
       else
           4
       end
6
julia> y
6
julia> factorial(0)
1
julia> factorial(-1)
ERROR: DomainError with -1:
`n` must not be negative.
julia> fac(0)
0
julia> fac(-1)
-1
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
54

fac(0) returns 0, but it should return 1. Next 
 with 
 should not even be allowed.
fac(n)
n < 0
Thus we need handle the case where 
 and 
 differently.
n == 0
n < 0
The 
 clause comes to our rescue. You can add several of these clauses to any if-statement.
elseif
Below we have done just that, to handle all the unique cases. Go ahead and test in the REPL if 
 and 
 behaves correctly with this update.
fac(0)
fac(-1)
Listing 3.16 If-else-statement
Return 1 if  is zero.
n
Create an 
 object. These are used to store information about an error that
exception
occurred.
Report an error indicating that  is not allowed to be negative.
n
Each 
 clause adds another condition check. First we check if 
, then if it is 
.
elseif
n > 2
n > 0
We continue performing every 
 check until we hit a condition which evaluates to 
. If
elseif
true
no condition is true we evaluate the 
 clause which reports an error.
else
3.7.2 Elseif Clause
function fac(n)
    if n > 2
        n*fac(n-1)
    elseif n > 0
        n
    elseif n == 0 
        1
    else
        err = DomainError(n, "`n` must not be negative.") 
        throw(err) 
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
55

1.  
2.  
3.  
Figure 3.7 If statement with elseif and else
Before discussing error handling further, let me end by clarifying the rules for writing an
if-statement:
There must be exactly one 
 keyword used, and it has to be at the start.
if
else is optional but it can only be used once, and only at the very end.
You can write any number of 
 clauses but they have to come after the 
 clause.
elseif
if
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
56

In programming-speak, functions 
 values, but 
 exceptions. In Julia this is used to
return
throw
handle programmer mistakes. As a programmer you should not provide negative numbers to 
.
fac
However mistakes happen and have to be dealt with. The idea is to report a problem as early as
possible, as soon as you have discovered it. This makes it easier to diagnose problems when you
are developing and testing your software.
How is throwing an exception different from returning a value? Let me explain with an example.
Figure 3.8 Difference between regular returns and throwing exceptions
If function 
 calls 
 which calls 
, then we get what is called a 
. The call
alpha
beta
gamma
call stack
stack is a place in memory storing the location of function calls. Why is this needed? When your
CPU finishes processing instructions in 
, it needs to get back to the location in 
 where
gamma
beta
 was called initially. This location is stored in memory. We call it the 
.
gamma
return address
Likewise we need to remember how to return to 
 from 
. These nested function calls
alpha
beta
create a stack of return addresses. This is the 
.
call stack
As the illustration above show, 
 carries you back the same way you came. 
 is
return
throw
different. It allows you to skip many steps in the call stack. 
 skips every function called
throw
until it reaches a point where there is a 
 defined.
catch
Defines a block of code, where somewhere in the callstack an exception may
occur.
If an exception does occur it will be caught and this block of code is meant to
cleanup or handle the exception.
3.8 Throwing Exceptions to Handle Errors
function alpha()
   try 
      beta()
   catch e  
      # handle exception
   end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
57

Information about the error is stored in an exception object, which was passed to the throw
function. The variable  gets set to this object. Thus the 
 block is able to access
e
catch
information about the error that occurred. At this point we cannot discuss exceptions more in
detail as it requires a firmer understanding of the Julia type system, which we have not yet
covered.
You can however experiment with this in the REPL yourself to get a feel for how exceptions
break the normal flow of control.
Remember almost everything in Julia is an expression, including try-catch blocks.
Now that we have looked at different forms of control flow, it might be easier to give you an
intuition about the word 
. It may help to grasp the concept by comparing control
control flow
flow with data flow. Consider this simple code snippet:
There are two different perspectives to look at this code. You can think about it in terms of flow
of data. A message stored in 
 flows 
 the 
 function. A cipher text object flows 
bob
into
encrypt
out
of the function.
3.9 Control Flow vs Data Flow
julia> y = try
           fac(3)
       catch e
           42
       end
6
julia> y = try
           fac(-3)
       catch e
           42
       end
42
julia> fac(-3)
ERROR: DomainError with -3:
`n` must not be negative.
alice = encrypt(bob)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
58

Figure 3.9 Contrasting data flow and control flow
With data flow you got data flowing along the arrow between the boxes. In the previous
illustration the light boxes are sources and sinks and the dark box is a filter. It transforms
incoming data into another type of data.
In a control flow diagram (such as a flowchart), arrows don’t represent movement of data, but
transition of control. Control flow is about how control flows from one box to the other and how
that flow can be altered and redirected.
In the this example you can either think of how control is passed from the 
 function to the 
alpha
 function and finally to the 
 function. There is a flow of control. In a data flow
beta
gamma
perspective we think of data flowing into 
, out of it and into 
.
alpha
beta
When analyzing complex code, sketching out a data flow diagram can be useful. By labeling
arrows with the type of data going in and out of functions (filters) you can get a better overview
of complex data flows through your code.
y = gamma(beta(alpha(x)))
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
59

1.  
2.  
3.  
4.  
In a lot of programming books you will find an implementation of the 
 function. 
 is short
fib
fib
for Fibonacci. Why is this function so popular in programming? And why should we care?
It is a simple way of demonstrating transformation of a mathematical definition into
code.
Implementing it allows us to contrast solving problems through 
 and 
recursion
iteration
(loops).
Fibonacci numbers pop up in all sorts of real life circumstances: In the number of flower
petals, spirals on a sunflower, or nautilus shell, and fractions that appear in phyllotaxis.
It is a simple demonstration of how you build a models of real world phenomena.
This is what the number sequence looks like. The sequence goes on towards infinity.
Each of the numbers in this sequence is called a Fibonacci number. Mathematicians like to refer
to each of these numbers using the letter . The first number in the sequence is , the second 
F
F
F
and so on. In other words the indexing starts at zero. Mathematically Fibonacci numbers are
defined as follows:
This may seem as enlightening as a wikipedia page, so let us try to give some intuition behind
this mathematical definition with a concrete example: The growth of a rabbit population. In fact,
this is how Fibonacci numbers were discovered. Leonardo of Pisa, also known as Fibonacci was
wondering some 800 years ago how a rabbit population would grow each month. He asked the
hypothetical question:
If we got one pair of rabbits at the start of the year, how many will there be at the end of the
year?
To answer this question we have to build models of reality. When we build models we try to
extract the most important features of the specific traits we are trying to model. For instance, we
don’t care about how the rabbits spread out, what they look like, what they eat or how they
obtain food. Our model is only concerned with how their population grows. All models are built
for a particular purpose. If you want to check how well a new cellphone will fit in somebody’s
pocket, then the model doesn’t need to be anything more advanced than a block of wood. The
3.10 Counting Rabbits
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
60

only thing you need to mimic is the physical dimensions of the phone, not the color of the
exterior or crispness of the screen.
Models thus always involve major 
 of reality. In Fibonacci’s model of rabbit
simplifications
growth we deal with immortal rabbits. They never actually die. They are born, and 1 month after
birth they start reproducing. We always model them as pairs. One pair of rabbits produce another
pair of rabbits every month as soon as they reach reproductive age.
Figure 3.10 Rabbit population growth each month as illustrated by Mathigon.
Mathigon is an excellent online source demonstrating interactively how rabbit populations grow
according to the Fibonacci number sequence. The hexagons in the screenshot shows how many
rabbit pairs exist for a given month. In the first month we only have 1 pair, while in the sixth
month we have 8 pairs.
When we implement the 
 function to calculate Fibonacci numbers, it works like this: 
fib
fib(1)
is the same as , 
 corresponds to .
F fib(n)
F
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
61

Listing 3.17 Calculating a Fibonacci number
The mathematical definition says 
, which is expressed here.
F = 0, F = 1
For all other values of  they are equal to the two preceding Fibonacci numbers.
n
This expresses a 
. The 
 function is calling itself with another
recursion
fib
argument.
Let us try to walk through how this function works in practice. What happens when you try to
evaluate 
? This sets 
. Whenever 
 the following line is evaluated:
fib(3)
n = 3
n > 1
This will get evaluated over and over again, but the argument  is reduced by 1 and 2 each time,
n
meaning sooner or later the first conditions of the 
 function becomes true. The result then
fib
bubbles back up completing earlier requests. Thus we have a sort of double recursion in this
case. These REPL examples give a sense of how the Fibonacci function works:
To avoid the recursion running until we consume all our stack memory, we need to define the 
. This is the if-statement which lets us exit the recursion at some point.
base case
Listing 3.18 Calculating a Fibonacci number
function fib(n)
    if n == 0 
        0
    elseif n == 1 
        1
    else
        fib(n-1) + fib(n-2) 
    end
end
fib(n-1) + fib(n-2)
julia> fib(3) == fib(2) + fib(1)
true
julia> fib(4) == fib(3) + fib(2)
true
julia> n = 5
5
julia> fib(n) == fib(n-1) + fib(n-2)
true
3.10.1 Base Case
function fib(n)
    if 0 <= n <= 1 
        n
    else
        fib(n-1) + fib(n-2)
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
62

Check if  is within the range 0 to 1. Is it equal or lager to zero, as well as smaller
n
or equal to one?
The 
 condition defines the base condition or exist point. You need something
0 <= n <= 1
similar for every recursive function. A recursive function is a function which calls itself.
Earlier we have demonstrated that recursion is just one of many ways to solve a problem. It is
never a requirement. A recursion can always be replaced by an iteration. By iteration I mean
looping using e.g. a for-loop or while-loop. E.g. with the code below we are 
 over the
iterating
range 0 to 4.
If you can solve the same problem with iteration then why use recursion? Let us look at the
iteration solution to discuss the pros and cons.
Listing 3.19 Calculating a Fibonacci number using iteration
Early exit. To avoid deep nesting we use the 
 keyword to exit the function
return
immediately with the value .
n
 is used to represent 
prev
fib(n-2)
To hold the final result 
.
fib(n)
This is shorthand for 
 which is equivalent to the 
x = x + prev
fib(n-1) +
 calculation.
fib(n-2)
While this code may be easier conceptually, you can notice that iteration makes everything a lot
messier. We get a lot more bookkeeping, meaning we get more variables to maintain and update
properly. While creating this example code I spent markedly longer time, while making several
mistakes in the initial version. The recursive variant in contrast I wrote correctly on first attempt.
Thus while recursion may take some time getting accustomed to, it frequently makes your code
3.10.2 Iteration vs Recursion
for i in 0:4
    println(i)
end
function fibi(n)
    if 0 <= n <= 1
        return n 
    end
    prev = 0 
    x    = 1 
    for i in 2:n
        tmp = x
        x += prev 
        prev = tmp
    end
    x
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
63

much simpler. One downside is that recursion is often slower. Thus often you will implement
your solution through recursion first and if it turns out to be too slow, you rewrite it to use
iteration.
The last example used a 
 statement to perform an early exit from the function. This is also
return
optional, but as you can see, writing the code without 
 can make it harder to read. The
return
reason is that you can end up with deep nesting of control-flow statements as seen below:
Listing 3.20 Calculating a Fibonacci number without early return
There are no hard rules here. You will just have to use common sense and rely on your own
sense of good taste. As a rule of thumb I try to avoid nesting deeper than three levels. However
avoid turning this into strict rules. An obsession with rules carved in stone has always plagued
the software industry. It is better to be flexible and use common sense. Julia itself is a language
which tries to be pragmatic.
Control flow statements use conditions which are composed using Boolean expressions.
Loops repeat as long as condition remains true
Even control flow statements are expressions in Julia, meaning they evaluate to a value.
In Julia even 
 is a value
nothing
The ability of computer to repeat similar calculations a large number of times make them
suited for computations which are hard to do by hand such as calculating trigonometric
functions
A recursive function, is a function which calls itself. Recursive functions must have a 
, or it will never terminate execution
base case
Recursion and iteration can solve the same problems. Recursion often makes the code
easier to write, while iteration usually gives better performance
3.11 Summary
3.10.3 To Return or Not Return
function fibi(n)
    if 0 <= n <= 1
        n
    else
        prev = 0
        x    = 1
        for i in 2:n
            tmp = x
            x += prev
            prev = tmp
        end
        x
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
64

4
This chapter covers
In the second chapter we discussed how to work with Julia as a calculator. However people
working with numbers today, don’t usually use desk calculators. They use spreadsheet tools such
as Microsoft Excel or Apple Numbers.
In these applications numbers are stored in tables. We work with whole columns of numbers. All
serious scientific work involves working with large tables of data. Scientists and data analysts
get survey data or measurements they want to analyze. Julia is excellent for this type of work.
We are not literally working with a graphical spreadsheet tool but we are manipulating data in
table form, much like a modern spreadsheet application.
We will only scratch the surface of what is possible to do in this chapter. Instead the main
purpose is to introduce the 
 and 
 datatypes. Because these are containers for other
Array
Tuple
values, we will also touch upon the 
 (character) and 
 (text string) types to have
Char
String
something interesting to put in our arrays and tuples.
In fact we are going to put numbers, characters, text strings and Boolean values into these two
collection types.
Julia as a spreadsheet
Working with collections of numbers using the 
 and Tuple` types
Array
Useful types to put into collections such as numbers, characters and text strings
Performing statistics
Transforming lists of numbers with map
Using predicates with the 
 function
filter
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
65

Figure 4.1 Apple Numbers, a spreadsheet application for working with rows and columns of numbers.
To better understand the purpose of different 
 operations, I will use an example of pizza
Array
sales. Below is a table of different types of pizza sold in different amounts at different prices. We
are going to explore how Julia code can be used to answer question such as:
How many pizzas was sold in total?
How much revenue did we get in total from our pizza sales?
What was the average price of pizzas sold?
What was the average number of pizzas in each category sold?
4.1 Analyzing pizza sales
Table 4.1
Pizza sales data
m
Pizza
Amount
Price
Pepperoni
4
15.0
Margherita
1
11.5
BBQ Chicken
5
13.0
Hawaiian
3
12.75
Prosciutto
2
14.25
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
66

An array in Julia can represent a row, column or table of numbers. In fact arrays can contain any
type of elements, not just numbers. You could have arrays of Booleans, characters, or text strings
e.g. Elements in an array are ordered. You can ask for elements at a specific position, such as
"give me the third element in array A."
Let us create column of numbers, to hold the amount of pizzas sold. Notice how the numbers are
listed vertically. This is Julia’s way of telling you that you just made a 
. When
column vector
creating a column vector we separate each element with a comma.
It is also possible to create a 
 instead, by separating each element with a space.
row vector
Each of the values in the vector have an associated 
 as illustrated in the following
element index
diagram. The index of the first element is 1.
Figure 4.2 Illustration of how elements are organized in a row vector
The word 
 is commonly used to refer to one-dimensional arrays, while a two-dimensional
vector
array is called a 
. You can think of a matrix as the same as a table in a spreadsheet
matrix
4.2 Different types of arrays
julia> amounts = [4, 1, 5, 3, 2]
5-element Vector{Int64}:
 4
 1
 5
 3
 2
julia> row = [4 1 5 3 2]
1×5 Matrix{Int64}:
 4  1  5  3  2
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
67

application. In Julia you can construct tables by stacking row vectors on top of each other. Notice
how we separate each row with a semi-colon. Here we have a table with the 
 and 
amounts
 columns.
prices
Please note that the newlines are not required. It just makes it easier to read the code. You would
have gotten exactly the same matrix by writing this:
To conceptualize how columns and matrices are organized, you can look at the following
illustration. With one-dimensional vectors we normally talk about element indices, but for a
matrix both the rows and the columns are numbered.
Figure 4.3 Comparison of column vectors and a matrix
julia> pizzas = [4 15.0;
                 1 11.5;
                 5 13.0;
                 3 12.75;
                 2 14.25]
5×2 Matrix{Float64}:
 4.0  15.0
 1.0  11.5
 5.0  13.0
 3.0  12.75
 2.0  14.25
pizzas = [4 15.0; 1 11.5; 5 13.0; 3 12.75; 2 14.25]
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
68

In this chapter however we will focus primarily on column vectors. They correspond most
closely to what is called arrays in other languages. Multidimensional arrays are not a central
feature in other languages like they are in Julia.
Lists of numbers isn’t very interesting unless it allow you to do something useful. Fortunately
many functions operate on arrays. For instance Julia’s 
 function can be used to add up all the
sum
elements in an array. Here we calculate the total number of pizzas sold:
If we want to find out how many elements there are in amounts, we can use 
. This also
length
allows us to calculate the average number of pizzas sold of each type:
Let us put the prices in a variable, to have something to experiment with.
To make it easier to get an overview of the different prices we have, we could sort the prices:
Sorted prices stored in 
.
sorted
 did not modify 
.
sort
prices
When you call 
 you create a new vector. The 
 vector is not modified. By convention
sort
prices
4.3 Performing operations on arrays
julia> no_pizzas_sold = sum(amounts)
15
julia> length(amounts)
5
julia> avg = sum(amounts) / length(amounts)
3.0
julia> prices = [15.0, 11.5, 13.0, 12.75, 14.25]
5-element Vector{Float64}:
 15.0
 11.5
 13.0
 12.75
 14.25
julia> sorted = sort(prices) 
5-element Vector{Float64}:
 11.5
 12.75
 13.0
 14.25
 15.0
julia> prices 
5-element Vector{Float64}:
 15.0
 11.5
 13.0
 12.75
 14.25
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
69

Julia functions never modify any of their inputs. Sometimes it is necessary to modify inputs to a
function. Julia developers have established the convention of tacking on an exclamation mark (!)
on the name of any function which modifies its input. Hence many Julia functions which don’t
modify their inputs have sibling functions which do. For instance the 
 function will sort its
sort!
input vector rather than returning a new sorted version.
 were modified by 
prices
sort!
What if you live in a country with value added tax? To figure out the sticker price on your
pizzas, you need to add the sales tax. If you live in Norway, the value added tax is 25%. Let us
calculate new prices with taxes:
But what if we want to find out how much money we made on each type of pizza? We could try
to multiply the 
 with the 
.
amounts
prices
Don’t worry about the error message, we will explain the concepts you need to grasp to read it in
later chapters.
For now, what you need to know is that there is no obvious definition of what a multiplication
between two columns of numbers should produce. One can imagine numerous ways of
interpreting this. Thus we have to explicitly tell Julia that we want elementwise operations. This
is done by adding a dot to the mathematical operator. , ,  and  are for performing arithmetic
+ - *
/
on individual numbers (scalars). To perform elementwise operations on arrays of numbers you
need to use the 
, 
, 
 and 
 operators.
.+ .- .*
./
julia> sort!(prices)
5-element Vector{Float64}:
 11.5
 12.75
 13.0
 14.25
 15.0
julia> prices 
5-element Vector{Float64}:
 11.5
 12.75
 13.0
 14.25
 15.0
julia> prices = [15.0, 11.5, 13.0, 12.75, 14.25];
julia> prices_with_tax = prices * 1.25
5-element Vector{Float64}:
 18.75
 14.375
 16.25
 15.9375
 17.8125
julia> amounts * prices
ERROR: MethodError: no method matching *(::Vector{Int64}, ::Vector{Float64})
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
70

We can feed this result to the 
 function to compute our total profit from selling pizza:
sum
Professionals doing statistics and data analysis, usually works with tables of data. We can easily
implement our own functions to perform statistics on individual columns of data. Below a basic
example of an 
 function.
average
Listing 4.1 Calculating arithmetic mean
But instead of reinventing the wheel, we can use ready made statistical functions. These are
bundled with Julia, but placed in the 
 module
. Modules will be covered more
Statistics
16
extensively later, but you can think of them as bundles of pre-made functionality made by others
which you can use in your programs. To use a module we write:
This will cause the functions, types and constants defined in the module to be loaded and made
available to you. It will also make available documentation for the module. Remember you go
into Julia’s documentation mode by writing a question mark (?) at the beginning of the line.
To get an overview of what types and functions exist in the module write the module name, a dot
and press Tab key twice. That will show all possible completions (I have edited out some of the
4.4 Working with the statistics module
julia> amounts .* prices
5-element Vector{Float64}:
 60.0
 11.5
 65.0
 38.25
 28.5
julia> sum(amounts .* prices)
203.25
average(A) = sum(A) / length(A)
using Statistics
julia> using Statistics
help?> Statistics
search: Statistics
  Statistics
  Standard library module for basic statistics functionality.
help?> middle(3, 4)
  middle(x, y)
  Compute the middle of two numbers x and y, which is equivalent in both
  value and type to computing their mean ((x + y) / 2).
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
71

results for clarity).
Let us explore some of the statistics functions in the REPL.
Compute arithmetic mean of 
.
amounts
The middle value when values are sorted.
Standard deviation.
mean and 
 are both used to compute averages but work slightly different. With 
 you
median
mean
add upp all the values and divide by the number of values. If there are a few extreme values the
average can get heavily skewed. Thus when for instance calculating the average income of a
family, we usually use the 
. Median income would be calculated by sorting all the
median
household incomes and then picking the income in the middle of the sorted list. That way a few
ultra-rich families would not skew the result.
With the 
 function we find the standard deviation in a collection of values. The standard
std
deviation is a measure of how much values differ. If every element is the same then the standard
deviation will be zero.
Thus far we have looked at how to deal with arrays as a whole, but to be able to build your own
functionality processing arrays, you need to know how to access individual elements in the array.
julia> Statistics.
corm           mean            realXcY
corzm          mean!           sqrt!
cov            median          std
cov2cor!       median!         stdm
covm           middle          unscaled_covzm
covzm          quantile        var
eval           quantile!       varm
include        range_varm      varm!
julia> mean(amounts) 
3.0
julia> mean(prices)
13.3
julia> median(amounts) 
3.0
julia> median(prices)
13.0
julia> std(amounts) 
1.5811388300841898
julia> std([3, 3, 3])
0.0
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
72

Every element in a Julia array is numbered starting from one. This is called 1-based indexing and
is very common with numerical and mathematically oriented languages. However mainstream
languages such as Python, C, C++ and Java use 0-based indexing.
SIDEBAR
1-BASED VS 0-BASED INDEXING
The best way to index arrays is a topic developers love to argue about. In
mathematics it is a common convention to number elements, rows and
columns using 1-based indexing. When discussing hardware details such as
computer memory addresses it is more common to use 0-based indexing.
Thus languages with a numerical focus have tended to use 1-based indexing
while languages closer to the hardware, such as C, have used 0-based
indexing.
We use square brackets to define array literals but also to access individual elements by index.
Access the first element in the 
 array.
amounts
Get the fifth element (last) in the 
 array.
amounts
We use square brackets both to define an array literal and to access individual elements. Of
course we also want to be able to change individual elements. This is done in identical fashion:
4.5 Accessing elements
julia> amounts = [4, 1, 5, 3, 2]
5-element Vector{Int64}:
 4
 1
 5
 3
 2
julia> amounts[1] 
4
julia> amounts[2]
1
julia> amounts[5] 
2
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
73

1.  
2.  
Each time I change and element, you can see I print it out to show what the array current looks
like. All these examples are kind of neat and tidy. What happens if I try to access an element
with an invalid index?
The array 
 has only two values, so you cannot attempt to set the third element.
xs
Julia checks if you use valid indices.
Elements start at index 1. There are no values at index 0.
The behavior you see here is common across most mainstream languages. However some older
popular langauges allow you to set elements at any index regardless of how large you made the
array in advance.
There are some challenges with the the way we have accessed elements in these examples.
You don’t always know the index of the last element, as arrays can have different sizes
and can be grown.
While 1-based indexing is the standard, it is possible to construct 0-based arrays in Julia.
To deal with the fact that you cannot always know where an array starts or ends we use the 
 and 
 keywords, to access the first element and the last element respectively.
begin
end
julia> xs = [2, 3]
2-element Vector{Int64}:
 2
 3
julia> xs[1] = 42
42
julia> xs
2-element Vector{Int64}:
 42
  3
julia> xs[2] = 12
12
julia> xs
2-element Vector{Int64}:
 42
 12
julia> xs[3] = 5 
ERROR: BoundsError: attempt to access 2-element Vector{Int64} at index [3]
julia> xs[0] 
ERROR: BoundsError: attempt to access 2-element Vector{Int64} at index [0]
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
74

Access the first element. 
 and 
 is identical.
[1]
[begin]
Last element. 
 and 
 in this example is the same.
[5]
[end]
By subtracting we can do things like accessing the second last element.
Thus far we have created arrays using array literals. An array literal means you literally list each
element an array is composed of. E.g. 
 and 
 are both
[4, 8, 1]
[false, false, true]
examples of array literals. The variable 
 may refer to an array, but it is not an array literal.
xs
However, array literals are not a very effective at creating large arrays. We have a number of
functions, such as 
, 
, 
 and 
, which makes it easier to quickly create arrays
zeros ones fill
rand
containing particular values.
For instance, what if you want an array containing 50 elements all with the value zero? For this
we can use the 
 function:
zeros
It is so common to initialize vectors elements to 1, that we have a function, 
, to do that
ones
explicitly. The function creates an array of specified length with every element set to the value
one.
4.6 Creating arrays
julia> amounts[1] 
4
julia> amounts[begin] 
4
julia> amounts[5] 
2
julia> amounts[end] 
2
julia> amounts[4] 
3
julia> amounts[end-1] 
3
julia> xs = zeros(50)
50-element Vector{Float64}:
 0.0
 0.0
 0.0
 
 0.0
 0.0
 0.0
 0.0
julia> length(xs)
50
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
75

But it is possible to fill a large array with any value using the 
 function. Here we create an
fill
array with six elements, each set to the value 42.
In many situations we need arrays with large number of random values. 
 creates a vector
rand(n)
holding  random numbers between 0 and 1.
n
When we create arrays, you will see the description of the array made in the Julia REPL looks
something like this:
This says that the vector we have made contains five elements, and each of those elements are of
type 
. But what if we want elements of a different type? Say I want 8-bit signed integers
Float64
instead. How do I do that? The 
, 
 and 
 functions allow you to specify element
ones zeros
rand
type. Here are some examples:
julia> ones(5)
5-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
julia> fill(42, 6)
6-element Vector{Int64}:
 42
 42
 42
 42
 42
 42
julia> rand(3)
3-element Vector{Float64}:
 0.5862914538673218
 0.8917281248249265
 0.37928032685681234
5-element Vector{Float64}
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
76

Make an array containing signed 8-bit integers with the value 1. Notice description
of the vector says 
.
Vector{Int8}
Create four zeros of type unsigned 8-bit. Notice how zero is written in hexadecimal
form, as that it default way of formatting unsigned integers in Julia.
Create 3 random 8-bit signed integer values. The values will be randomly picked
from the full range from -128 to 127.
Even array literals allow you to specify the element type. Thus we can indicate that we want a
vector of 8-bit signed integers:
The array literal is prefixed with the type we want for each element, 
 in this case. If you
Int8
don’t prefix with the type Julia will infer the element type. The details of how that works will
become apparent when we discuss types in chapter 7.
If you want to actually check what type each element in an array is, you can use the eltype
(short for element type) function:
julia> ones(Int8, 5) 
5-element Vector{Int8}:
 1
 1
 1
 1
 1
julia> zeros(UInt8, 4) 
4-element Vector{UInt8}:
 0x00
 0x00
 0x00
 0x00
julia> rand(Int8, 3) 
3-element Vector{Int8}:
 -50
 125
  58
julia> xs = Int8[72, 69, 76, 76, 79]
5-element Vector{Int8}:
 72
 69
 76
 76
 79
julia> eltype(xs)
Int8
julia> eltype([3, 4, 5])
Int64
julia> eltype([true, false])
Bool
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
77

We can do more than simply adding and multiplying values. Across all programming languages
which support functional style programming you will find the a trio of functions called 
, 
map
 and 
. Let us explore the 
 function first by revisiting our earlier sine table
reduce
filter
map
calculations. Do you remember this function?
Listing 4.2 Code for creating a sine table stored in a function
However, instead of printing out the table of sine values, we can create an array of all the sine
values. For this we use the 
 function, which is designed to transform a collection of values
map
into another array of values. Here an array of degrees is transformed to an array of radians using 
. 
 applies the 
 function to every element in the input arrays
map map
deg2rad
map is what we call a 
. These are functions which take other functions as
higher order function
argument and/or return functions. This is different from the functions you have seen thus far
which take numbers as arguments exclusively. The basic form of 
 takes a function  as first
map
f
argument and applies that function to every element in a collection 
, producing a new
xs
collection 
 as output.
ys
The second argument representing a collection, does not need to be an actual array. It could be
anything one can iterate over and get multiple elements. Thus you can also use a range object.
Here we use a range from 0 to 90 with 15 degrees as as step value:
4.7 Mapping values in an array
function print_sin_table(increment, max_angle)
    angle = 0
    while angle <= max_angle
        rad = deg2rad(angle)
        x = sin(rad)
        println(x)
        angle = angle + increment
    end
end
julia> degs = [0, 15, 30, 45, 60];
julia> rads = map(deg2rad, degs)
5-element Vector{Float64}:
 0.0
 0.2617993877991494
 0.5235987755982988
 0.7853981633974483
 1.0471975511965976
ys = map(f, xs)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
78

We can combine this to create a sine table like this:
However this is not normally how you do it. Instead we collect all transformations we want to do
into a single function. This is more memory efficient as every call to 
 produces a new array.
map
You could however avoid multiple memory allocations by using the mutating version of map
named 
.
map!
Allocate array to hold results
Input and destination array must have equal length.
However this is not an elegant way of writing the code, and mutating function calls are best
avoided as they make analyzing data flow much harder. Thus we collect all transformations into
one function. That reduces the number of memory allocations the code has to do and is often
easier to read.
The first line is just a one-liner function definition. You could have used a multi-line definition
instead, but that takes more space.
A great way of understanding built-in functions is to implement them yourself. To better
understand 
 we will create our own map function called 
. It contains new concepts
map
transform
julia> map(deg2rad, 0:15:90)
7-element Vector{Float64}:
 0.0
 0.2617993877991494
 0.5235987755982988
 0.7853981633974483
 1.0471975511965976
 1.3089969389957472
 1.5707963267948966
julia> map(sin, map(deg2rad, 0:15:90))
7-element Vector{Float64}:
 0.0
 0.25881904510252074
 0.49999999999999994
 0.7071067811865475
 0.8660254037844386
 0.9659258262890683
 1.0
result = zeros(Float64, length(0:15:90)) 
map!(deg2rad, result, 0:15:90) 
map!(sin, result, result) 
degsin(deg) = sin(deg2rad(deg))
map(degsin, 0:15:90)
function degsin(deg)
    sin(deg2rad(deg))
end
map(degsin, 0:15:90)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
79

which we will discuss in more detail.
Listing 4.3 Knock off version of the built-in map function
An empty array to hold our final result.
Add a transformed element to our result array 
.
ys
Return final result.
transform takes two arguments 
 and 
, where the former is a function and the latter is an
fun
xs
array or other iterable collection object. Functions can be store in variables and used. Here is a
simple demonstration:
Calling the 
 function.
sin
Remember the plus operator in Julia is a function.
This is why we can use 
 as a function and call it, despite it being an argument to the 
fun
 function. The next part which needs some further explanation is:
transform
This function adds the element  to the array 
. Remember the exclamation mark warns you
x
xs
that the 
 function potentially alters its inputs. In this case the 
 argument is modified.
push!
xs
You must add the exclamation mark to call the right function. The exclamation mark is part of
the function name. 
 and 
 would count as two different function names. In Julia there
push
push!
is no function named 
. If it had existed we could imagine that it would have returned a new
push
array with an extra element.
function transform(fun, xs)
    ys = [] 
    for x in xs
        push!(ys, fun(x)) 
    end
    ys 
end
julia> sin(1.0)
0.8414709848078965
julia> g = sin
sin (generic function with 13 methods)
julia> g(1.0) 
0.8414709848078965
julia> add = + 
+ (generic function with 190 methods)
julia> add(2, 3)
5
push!(xs, x)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
80

There is no requirement to add the exclamation mark to functions you define, but you should get
in the habit of doing it to aid fellow developers reading your code. This way it is easy to see
where a variable is potentially modified (mutated).
TIP
To a beginner mutating functions may not seem like a big deal. However,
when writing larger programs you will start to notice that functions which
mutate inputs often make programs harder to read and follow. The
exclamation mark helps reduce mental load when reading source code.
Without it every function call could potentially modify its input making code
analysis much harder.
Here is a simple demonstration of how 
 works. We create an empty array 
 and add
push!
ys
numbers to it. Each time we can see how the array grows larger.
Create an empty array.
Add the number 3 to the array.
Thus far we have worked almost exclusively with numbers, but our pizza table contains more
than just numbers. The table contains text such as the name of the pizzas. How do we work with
text in Julia?
Let us start with the most basic building block. Text is made up of characters, and a single
character is represented by the 
 type in Julia. In computer memory, everything is a number,
Char
including characters. Here is a little challenge: Look at the example below and see if you can
make sense of it.
4.8 Introducing characters and strings
julia> ys = [] 
Any[]
julia> push!(ys, 3) 
1-element Vector{Any}:
 3
julia> push!(ys, 8)
2-element Vector{Any}:
 3
 8
julia> push!(ys, 2)
3-element Vector{Any}:
 3
 8
 2
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
81

Creating an 8-bit signed integer number from the 64-bit number with value 65.
Create a character from the number 65.
A character literal.
Create an 8-bit number from a character literal.
We put single quotes around individual characters to create a character literals
. 
 and 
17 'A'
'Y'
are both character literals.
What I am trying to get across with this code example, is that characters in Julia are just numbers
with a different type. Remember how an 
 and 
 consume the same number of bits and
UInt8
Int8
can hold the same data but interpret it differently? The same thing holds true for characters.
While in memory they look the same, the type determines what you can do with them. For
instance you cannot add two characters but you can add a number to a character:
We can create arrays of characters just like we can create arrays of numbers or Booleans.
NOTE
To improve readability and clarity, I do occasionally edit the REPL output. E.g.
will remove the 
 description tacked on
(category Lu: Letter, uppercase)
characters as it creates a lot of visual noise.
A text string is just characters joined together. Notice from the output that text strings are
julia> x = Int8(65) 
65
julia> ch = Char(65) 
'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)
julia> ch = Char(66)
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)
julia> 'A' 
'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)
julia> Int8('A') 
65
julia> 'A' + 'B'
ERROR: MethodError: no method matching +(::Char, ::Char)
julia> 'A' + 3
'D': ASCII/Unicode U+0044 (category Lu: Letter, uppercase)
julia> chars = ['H', 'E', 'L', 'L', 'O']
5-element Vector{Char}:
 'H': ASCII/Unicode U+0048
 'E': ASCII/Unicode U+0045
 'L': ASCII/Unicode U+004C
 'L': ASCII/Unicode U+004C
 'O': ASCII/Unicode U+004F
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
82

identified with double quotes, while individual characters are identified with single quotes.
join can take any iterable object (objects you can use in a for-loop) as input. Hence we can
actually provide a range of characters as well.
Skip every other character by using a step size of two in the range object.
You can collect the individual characters in a text string, so you can get back an array of
characters:
collect is a versatile function, which can turn any object which allows iterating over many
values into an array. Thus we can collect ranges as well:
Strings and characters are very useful to represent pizza data. Let us look at how we can bundle
together information about each pizza.
To do this we will use a close sibling to arrays called tuples. To write them you replace the
square brackets 
 with parentheses 
. Below is an example of a tuple describing sales info
[]
()
about pepperoni pizza. It says a small (S) Hawaiian pizza was sold for $10.5.
4.9 Storing pizza data in tuples
julia> join(chars)
"HELLO"
julia> join('A':'G')
"ABCDEFG"
julia> join('A':2:'G')
"ACEG"
julia> collect("HELLO")
5-element Vector{Char}:
 'H': ASCII/Unicode U+0048
 'E': ASCII/Unicode U+0045
 'L': ASCII/Unicode U+004C
 'L': ASCII/Unicode U+004C
 'O': ASCII/Unicode U+004F
julia> collect(2:5)
4-element Vector{Int64}:
 2
 3
 4
 5
 julia> collect('B':'D')
3-element Vector{Char}:
 'B': ASCII/Unicode U+0042
 'C': ASCII/Unicode U+0043
 'D': ASCII/Unicode U+0044
pizza_tuple = ("hawaiian", 'S', 10.5)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
83

Since a number of popular languages such as Python and JavaScript use both single quotes and
double quotes to denote strings, it is worth reminding the reader that in this example 
 denotes
'S'
a character and not a string. You cannot write strings in Julia using single quotes.
Thus there is an important distinction between 
 and 
. The latter is a string, which you
'S'
"S"
must think of as a collection of characters. The difference is similar to the difference between the
number 42 and the array 
.
[42]
Instead of writing a tuple to contain pizza data we could use an array:
So, what exactly is the difference? Arrays are meant for homogenous data. Every element has to
be of the same type. But clearly in this case they are 
 of the same type. The result is that the
not
element type of the array becomes the 
 type.
Any
We will explore the Julia type system more in detail later. For now you can think of 
 as
Any
meaning that anything goes. You can put any kind of value into the array. This would not have
worked if the element type was more specific, such as an 
:
Int64
Julia infers that each element is of type 
.
Int64
Julia doesn’t know how to turn a string into a number.
Pizza arrays in contrast are completely indiscriminate (they don’t care about the object type).
You can assign anything to the individual elements, because the element type of the pizza array
is 
.
Any
julia> 'hawaiian'
ERROR: syntax: character literal contains multiple characters
pizza_array = ["hawaiian", 'S', 10.5]
julia> pizza = ["hawaiian", 'S', 10.5]
3-element Vector{Any}:
   "hawaiian"
   'S': ASCII/Unicode U+0053
 10.5
julia> eltype(pizza)
Any
julia> xs = [4, 5, 3]
3-element Vector{Int64}: 
 4
 5
 3
julia> xs[1] = "hi"
ERROR: MethodError: Cannot `convert` an object of type String to an object
of type Int64 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
84

Tuples on the other hand are much stricter. A tuple keeps track of the type of every element. You
can see this if you perform a 
 on a tuple:
typeof
Secondly tuples are 
, meaning they cannot be changed. You can only read values from
immutable
them. You cannot change the values.
In other aspects tuples are very similar to arrays. You can loop over a tuple just like an array or
range:
You can pass them to functions such as 
 
 and 
 given that they actually contain
sum median
mean
numbers.
We are going to look at how we can create a list of pizza sales data by combining tuples and
arrays. This is the data we want to store in Julia:
julia> pizza[3] = true
true
julia> pizza[1] = 42
42
julia> pizza
3-element Vector{Any}:
   42
     'S': ASCII/Unicode U+0053
 true
julia> pza = ("hawaiian", 'S', 10.5)
("hawaiian", 'S', 10.5)
julia> typeof(pza)
Tuple{String, Char, Float64}
julia> pza[1]
"hawaiian"
julia> pza[1] = "pepperoni"
ERROR: MethodError: no method matching
  setindex!(::Tuple{String, Char, Float64}, ::String, ::Int64)
julia> for item in pza
           println(item)
       end
hawaiian
S
10.5
julia> nums = (3, 4, 1)
(3, 4, 1)
julia> sum(nums)
8
julia> median(nums)
3.0
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
85

We want to be able to process this data and find out things such as how much we made in total,
or how many large pizzas we sold. We can represent this in Julia in the following manner:
We are using floating-point numbers to represent currency data. That is a bad choice. If you
build software for customers handling currency data, you should always use fixed-point numbers
, but we are keeping things simple for educational purposes.
18
To make it easier to process pizza data we will define 
 functions 
 for different
accessor
19
properties. We will call the accessor for pizza size 
 because Julia already has a function
portion
called 
 in the standard library.
size
These are just regular functions. Here I use the Julia one-liner syntax for function definitions.
But I could have used the multi-line definition as well:
Remember that the last expression in a Julia function is the return value. You don’t have to write 
.
return pizza[3]
What type are these 
 arguments? Are they tuples or arrays? Actually it doesn’t matter what
pizza
they are because index access works on both in identical fashion.
These accessor functions are useful with map, because they allow us to do things such as getting
the names of all the pizzas:
Pizza
Size
Price
Hawaiian
S
10.5
Sicilian
S
12.25
Hawaiian
L
16.5
BBQ chicken
L
20.75
BBQ chicken
M
16.75
julia> sales = [
           ("hawaiian", 'S', 10.5),
           ("sicilian", 'S', 12.25),
           ("hawaiian", 'L', 16.5),
           ("bbq chicken", 'L', 20.75),
           ("bbq chicken", 'M', 16.75)
       ]
name(pizza)    = pizza[1]
portion(pizza) = pizza[2]
price(pizza)   = pizza[3]
function price(pizza)
    pizza[3]
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
86

What we did above was to apply the 
 function to every element in the 
 array and
name
sales
collect all the result values into a new array.
With some useful data to work with, I can introduce you to the next 
 function:
higher order
The 
 function takes a collection of values 
 and returns a subset 
 of those values.
filter
xs
ys
Which values from 
 which get included in the result 
 is determined by the predicate . What
xs
ys
p
is a predicate you ask?
NOTE
Definition
A predicate is a function which takes some value and always returns a
Boolean values such as 
 or 
.
true
false
Julia has a number of predicate functions bundled with its standard library. Here are some
examples:
Check if numbers are even (dividable by two).
Are numbers odd? (not dividable by two).
Predicates are not limited to numbers. There are also predicates for characters:
4.10 Filter pizzas based on predicates
julia> map(name, sales)
5-element Vector{String}:
 "hawaiian"
 "sicilian"
 "hawaiian"
 "bbq chicken"
 "bbq chicken"
ys = filter(p, xs)
julia> iseven(3) 
false
julia> iseven(2) 
true
julia> isodd(3) 
true
julia> isodd(4) 
false
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
87

Is provided character an uppercase letter?
Is character space? E.g. X is a letter an not blank space.
Predicates are very useful with the 
 function. Here is an example of getting even numbers
filter
from a range:
But to work with our pizza data we will define our own predicates, which allows us to get sales
of a particular pizza size or type.
This way we can combine 
, accessors, 
 and predicates to find out how much money
map
filter
we made selling large pizzas or how much we made selling BBQ chicken pizzas. First we find
the large pizzas:
Next we get the price of the large pizzas:
Using 
 we can figure out how much money we made selling large pizzas:
sum
julia> isuppercase('A') 
true
julia> isuppercase('a') 
false
julia> isspace(' ') 
true
julia> isspace('X') 
false
julia> filter(iseven, 1:10)
5-element Vector{Int64}:
  2
  4
  6
  8
 10
issmall(pizza)  = portion(pizza) == 'S'
islarge(pizza)  = portion(pizza) == 'L'
isbbq(pizza)    = name(pizza) == "bbq chicken"
4.10.1 Combining higher order functions
julia> filter(islarge, sales)
2-element Vector{Tuple{String, Char, Float64}}:
 ("hawaiian", 'L', 16.5)
 ("bbq chicken", 'L', 20.75)
julia> map(price, filter(islarge, sales))
2-element Vector{Float64}:
 16.5
 20.75
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
88

In the final example we determine how much money was made selling BBQ chicken pizzas.
It turns out that in programming, mapping a bunch of values to another set of values and then
reducing all these values to one, is such a common thing to do that it has its on name: mapreduce
.
In the last case we where mapping BBQ chicken sales items to sales prices and then adding them
up. Adding up all the numbers is in functional programming speak called a 
.
reduction
With the 
 function, we could have written the last part as a single function call:
mapreduce
mapreduce is composed of two 
 functions: 
 and 
. To demonstrate how
higher order
map
reduce
this works we will create our own variant of 
 called 
 to avoid naming
mapreduce
mapcompress
conflict.
Let me clarify how 
 works: It takes some 
 function  as first argument, which is
reduce
binary
g
used to combined the elements in the collection 
 provided as second argument.
xs
Unlike 
, 
 requires an input function taking 
 arguments. That is why we call it a 
map reduce
two
 function. Regular mathematical operators such as ,  and  are binary functions in Julia.
binary
+ -
*
Thus we can use them with 
 perform the equivalent of 
 and 
:
reduce
sum
factorial
4.11 Mapping and reducing an array
julia> sum(map(price, filter(islarge, sales)))
37.25
julia> bbq_sales = filter(isbbq, sales)
2-element Vector{Tuple{String, Char, Float64}}:
 ("bbq chicken", 'L', 20.75)
 ("bbq chicken", 'M', 16.75)
julia> sum(map(price, bbq_sales))
37.5
julia> mapreduce(price, +, bbq_sales)
37.5
mapcompress(f, g, xs) = reduce(g, map(f, xs))
g(x, y) = ...
y = reduce(g, xs)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
89

NOTE
Many developers find the naming of the function 
 unintuitive.
reduce
Potentially better names would have been accumulate, aggregate or
 In some languages it is called 
.
compress.
inject
The sine function itself is in fact a classic case of mapping and reducing. For each argument to 
 we get an infinite sequence of numbers which we reduce to one value by adding them.
sin(x)
This is how we implemented our own sine function called 
 to not conflict with the built-in 
sine
 function.
sin
Listing 4.4 Sin implemented using Taylor series
We can express this calculation more elegantly using the 
 higher order function.
mapreduce
Listing 4.5 Sin through mapreduce on a Taylor series
Here we do a new thing: Inside the 
 function we are defining a new function called 
sinus
taylor
, which takes a single argument . The function is used to calculate a term in the taylor series. By
i
that we mean one of the numbers in the taylor series which gets added up. It is perfectly possible
to define function inside other functions.
But why not define this function outside? The reason is that it uses the  variable, and the value
x
of  would not be known outside of the 
 function definition. If this makes your heads spin,
x
sinus
julia> sum(2:4)
9
julia> reduce(+, 2:4)
9
julia> factorial(4)
24
julia> reduce(*, 1:4)
24
4.11.1 Sine table with map and reduce
function sine(x)
    n = 5
    total = 0
    for i in 0:n
        total += (-1)^i*x^(2i+1)/factorial(2i + 1)
    end
    total
end
function sinus(x)
   n = 5
   taylor(i) = (-1)^i*x^(2i+1)/factorial(2i + 1)
   mapreduce(taylor, +, 0:n)
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
90

don’t worry. These concepts will be revisited many times later in the book and will likely make
more sense at this point.
mapreduce(taylor, +, 0:n) will first apply the 
 function to every value in the range 
taylor
. This will produce an array of values which will then be combined with the  operator,
0:n
+
which is the second argument to the 
 function.
mapreduce
In chapter three I mentioned that it can be useful to treat Boolean values at integers 0 or 1. Now
that you have been exposed to array we can give a concrete example of that.
Listing 4.6 Counting pizzas matching predicates
Since we are combining a 
 and a 
 higher order function we could replace this with a
map
sum
single call to 
. However adding elements after mapping is so common that Julia’s 
mapreduce
sum
function allows mapping and adding. This gives us an elegant way to calculate the number of
large pizzas, how many are BBQ chicken etc.
sum will transform all the pizza sales into Boolean values by applying the first argument as a
predicate. That will produce an array of zeros and ones which are added up by 
.
sum
With the completion of this chapter we have managed to cover the most fundamental concepts in
programming. Without Control-flow and collections of data, programming wouldn’t be very
useful. The ability to easily work with multiple elements of data is what makes computers so
versatile and powerful.
4.12 Counting matches with Boolean arrays
julia> matches = map(islarge, sales)
5-element Vector{Bool}:
 0
 0
 1
 1
 0
julia> sum(matches)
2
julia> sum(islarge, sales)
2
julia> sum(isbbq, sales)
2
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
91

Julia supports many different kinds of arrays. A 
 is a one-dimensional array, while
vector
a 
 is a two-dimensional array
matrix
Both in mathematics and in Julia one distinguishes between 
 and 
column vectors
row
. Column vectors most closely resemble what is called arrays in other
vectors
programming languages
Julia represents row vectors as a matrix with only one row, which is why row vectors are
very different from one-dimensional arrays in other languages
Arrays in Julia default to 1-based indexing. That means the first element starts at index 1
Mathematical operation can be performed on whole arrays on every element. To do this
we prefix the normal math operators with a dot: 
, 
, 
 and 
.+ .- .*
./
Operations on arrays can be described as either a mapping, filtering or reduction. E.g. 
 and 
 perform a reduction, since multiple values are reduced to one
sum
mean
The functions 
, 
, 
 and 
 make it easy to create arrays with large
zeros ones fill
rand
number of elements
An array of 
 objects is not quite the same as a 
. Characters must be joined
Char
String
together to form a string. However strings behave similar to arrays
Tuples have similar behavior to arrays, but are immutable (you cannot change them)
4.13 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
92

5
This chapter covers
This chapter will focus on practical aspects of working with text in Julia, such has how do you
show text on the screen, read or write it to a file. We will also look at simple interactive
application where the user writes responses to questions.
However first we will focus on different ways of displaying text on the screen. We will revisit
our our pizza sales and sine table examples. The tables we created before was not very readable.
How about creating a neat display like this?
Working with text
Representing text with the 
 type
String
Formatting text with 
 and 
lpad
rpad
Reading text from a keyboard or a file
Writing text to the screen or a file
Creating a simple interactive program
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
93

Here sine and cosine values are neatly arranged in separate columns. Likewise would it not be
better to neatly organize information about pizza sales into clearly separated columns, as seen
below?
We are going to use the 
 function for coloring our text and the 
 and 
printstyled
rpad
lpad
functions for formatting the output. We will use the  operator to repeat characters. Next we will
^
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
94

use the 
 function to allow us to use 
 and 
 for writing text output to files. To
open
print
println
read and process input we will use the 
, 
 and 
 functions.
readline split
parse
We will start by looking at the final result. The code we want to write, and then work our way
backwards to explain how we got there. The code should not be entirely alien, but there are some
new concepts which we need to explain.
Listing 5.1 Creating a pretty table of pizza sales
For instance we have new functions: 
, 
 and 
 which needs further
printstyled
rpad
lpad
exploration and explanation. To get the 
 function to work, we also need the 
print_pizzatable
 functions we defined in chapter 4. All of these functions take a 
 tuple, such as 
accessor
pizza
, as an argument and return one of the elements in the tuple.
("bbq chicken", 'L', 20.75)
Listing 5.2 Pizza tuple accessor functions
I will cover each function used inside 
 in more detail with some simple
print_pizzatable
examples. We only briefly covered 
 and 
 in the past, so let us get into more
print
println
details.
These are versatile functions which can be used to write text to your screen or even files or a
network connection. In chapter 18 we will get much deeper into this. Let us look at some simple
examples to demonstrate how these functions work:
5.1 Making a pretty pizza sales table
function print_pizzatable(pizzas)
    print(" ")
    printstyled(rpad("name", 12), color=:cyan)
    print("  ")
    printstyled("size", color=:cyan)
    print("  ")
    printstyled(rpad("price", 5), color=:cyan)
    println(" ")
    for pz in pizzas
         print(" ",  rpad(name(pz), 12))
         print("  ", rpad(portion(pz), 4), "  ")
         println(lpad(price(pz), 5), " ")
    end
end
name(pizza)    = pizza[1]
portion(pizza) = pizza[2]
price(pizza)   = pizza[3]
5.1.1 Print, println and printstyled
julia> println("hello world")
hello world
julia> print("hello world")
hello world
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
95

Huh? Are they not doing the exact same thing? No, but it isn’t easy to see with this example.
Instead we will use semicolon  to separate statements on a single line. That will help make the
;
difference clearer.
What this shows you is that 
 is just short for 
 with a newline character 
 added to
println
print
\n
the end. Julia like many other languages allow you to express non-visible control characters like
a newline by using backslash with different letter combinations.
Double quotation marks is not a control character but since we use it to mark the start and end a
string, we need to use an escape sequence to represent it. But what is the utility of knowing the
hex value? We can use these directly to create characters. Here a new line is created with the 
 hex value.
0x0a
Let us look at more examples of the effect of using these different escape sequences combined
with regular text.
julia> println("hello"); println("world")
hello
world
julia> print("hello"); print("world")
helloworld
julia> print("hello\n"); print("world\n")
hello
world
Escape sequence
Hex value
Effect
\n
0x0A
Newline
\t
0x09
Horizontal tab
\v
0x0B
Vertical tab
\r
0x0D
Carriage return
\b
0x08
Backspace
\\
0x5C
Backslash
\"
0x22
Double quotation marks
julia> newln = Char(0x0a)
'\n': ASCII/Unicode U+000A
julia> print("hi"); print(newln); print("world")
hi
world
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
96

This uses a vertical tab 
 as opposed to the more widely known horizontal tab 
.
\v
\t
Carriage return moves cursor to start of line. Hence the word "world" overwrites
"hello" written initially.
This requires some context. Why do characters in your text strings cause the cursor to move
around? The reason has to do with the history of the text printing system we have today. When
the Unix operating system was first developed, there was no electronic displays, like the ones we
use today. Instead computer users used electro-mechanical devices called teletypes. A teletype is
very similar to an old fashion typewriter in operation.
These also served as your screen. If the computer wanted to give you some information, it had to
send characters to your typewriter, which would cause it to print the characters sent onto paper.
This created a need for control characters. Meaning characters that bossed around your teletype.
Telling it to create a new line, move the caret down or back.
julia> println("hello \v world") 
hello
       world
julia> println("hello \n world")
hello
 world
julia> println("hello \r world") 
 world
julia> println("ABC\n\tABC\n\tABC")
ABC
    ABC
    ABC
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
97

Figure 5.1 Teletype Siemens & Halske - Telemuseet, Norway
The terminal application you use today, are simulators of these old teletypes. This was so
programs written to work with teletypes could still work. Unix commands such as 
, 
, 
ls cp cat
and 
 have no idea they are running on modern computers with electronic displays. As far as
echo
they are concerned they are interacting with a good old teletype.
Eventually these paper based terminals were replaced by electronic terminals. At this point one
expanded the control characters with new ones to represent colors. For instance when an
electronic terminal would receive the escape sequence 
, it would switch to writing
\u001b[33m
yellow letters. If it got 
 it would write red letters. So to write 
 in
\u001b[31m
hello world
yellow letters you can write the following:
However remembering these escape sequences for different colors is cumbersome. Thus Julia
provides the 
 function which lets you specify color to use by name. Color is
printstyled
specified with the 
 
.
keyword argument color
julia> print("\u001b[33m hello world")
 hello world
julia> printstyled("hello world", color = :cyan)
hello world
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
98

This statement produces 
 in cyan color. You can lookup the help for 
hello world
printstyled
to get overview of what colors you can use. Just move the to the beginning of the line (Ctrl-A)
and and hit ? to go into help mode.
All the colors are given as 
. A symbol is very similar to a text string. It is often used for
symbols
text strings which only matter to programmers and not users of your program. You can
programmatically create symbol objects:
All the print functions are quite versatile in what they allow you to print and how many elements
you can print.
Numbers and Boolean values get converted to text strings when passed as arguments to the
various 
 functions. It is worth knowing that the 
 function works exactly the same
print
string
way, except it returns a 
 instead of printing to the screen.
String
This allows us to use a single 
 statement to display information about one pizza. Notice
println
the use of accessor functions defined earlier.
help?> printstyled("hello world", color = :cyan)
  printstyled([io], xs...; bold=false, color=:normal)
  Print xs in a color specified as a symbol or integer,
  optionally in bold.
  color may take any of the values :normal, :default,
  :bold, :black, :blink, :blue, :cyan, :green, :hidden,
  :light_black, :light_blue, :light_cyan, :light_green,
  :light_magenta, :light_red, :light_yellow, :magenta,
  :nothing, :red, :reverse, :underline, :white, or :yellow
  or an integer between 0 and 255 inclusive. Note that not
  all terminals support 256 colors. If the keyword bold is
  given as true, the result will be printed in bold
julia> sym = Symbol("hello")
:hello
julia> sym == :hello
true
5.1.2 Printing multiple elements
julia> print("abc", 42, true, "xyz")
abc42truexyz
julia> string("abc", 42, true, "xyz")
"abc42truexyz"
julia> pizza = ("hawaiian", 'S', 10.5)
("hawaiian", 'S', 10.5)
julia> println(name(pizza), " ", portion(pizza), " ", price(pizza))
hawaiian S 10.5
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
99

We can use this functionality to write out a simple table over pizza sales.
Listing 5.3 Primitive pizza table printing
The problem with this code is that the name, size and price columns don’t get aligned but end up
like this:
To perform alignment we need left padding and right padding with the 
 and 
 functions.
lpad
rpad
With the Julia padding functions you can specify that a text string should always be of a given
length. If the text you supply is smaller it will get padded with a chosen character. If no character
is specified, then the padding character defaults to space.
Padding on the left.
Right side padding.
First we pad with the  character on the left side until the whole string is 6 characters long.
-
The second example is identical except we pad on the right side with the  character.
-
5.1.3 Printing multiple pizzas
pizzas = [
   ("hawaiian", 'S', 10.5),
   ("mexicana", 'S', 13.0),
   ("hawaiian", 'L', 16.5),
   ("bbq chicken", 'L', 20.75),
   ("sicilian", 'S', 12.25),
   ("bbq chicken", 'M', 16.75),
   ("mexicana", 'M', 16.0),
   ("thai chicken", 'L', 20.75),
 ]
for pz in pizzas
    println(name(pz), " ", portion(pz), " ", price(pz))
end
hawaiian S 10.5
mexicana S 13.0
hawaiian L 16.5
bbq chicken L 20.75
sicilian S 12.25
bbq chicken M 16.75
mexicana M 16.0
thai chicken L 20.75
5.1.4 Align with lpad and rpad
julia> lpad("ABC", 6, '-') 
"---ABC"
julia> rpad("ABC", 6, '-') 
"ABC---"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
100

With 
 and 
 we can define how wide each column in our table should be an add padding
lpad
rpad
such as spaces wherever the supplied text string is shorter. In this example we’ll do it simple and
check what width the widest strings in each column would be:
Width for pizza name column.
For size column.
Price column.
Let us modify the initial code to use padding. You could just paste this code into your terminal or
store it in a file you load into the terminal with e.g. 
. Notice in the code that we don’t
include
specify the padding character. If you don’t specify it will default to a space.
Listing 5.4 Simple aligned pizza table
We use cyan color for the header describing each column.
Numbers are padded on the left so the decimals align.
We can test this in the terminal:
julia> length("thai chicken") 
12
julia> length("size") 
4
julia> max(length("16.75"), length("price")) 
5
function simple_pizzatable(pizzas)
    pname  = rpad("name", 12)
    psize  = rpad("size", 4)
    pprice = rpad("price", 5)
    printstyled(pname, " ",
                psize, " ",
                pprice,
                color=:cyan) 
    println()
    for pz in pizzas
        pname  = rpad(name(pz), 12)
        psize  = rpad(portion(pz), 4)
        pprice = lpad(price(pz), 5) 
        println(pname, " ", psize, " ", pprice)
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
101

Notice how the points are not aligned. There are many ways to solve that, but in the next
example with trigonometric tables we will make sure each number has the same number of
decimals after the point.
Adding separating lines is actually quite simple. We use the symbol for a long vertical line 
.
''
This is Julia’s way of telling us that this character is represented by the hexadecimal value 
. Thus you could get this character in two different ways:
0x2502
In fact there is a whole bunch of useful characters to make tables:
To draw lines it is useful to know how to easily repeat characters. In Julia the exponent ^
operator is used to repeat characters:
julia> simple_pizzatable(pizzas)
name         size price
hawaiian     S     10.5
mexicana     S     13.0
hawaiian     L     16.5
bbq chicken  L    20.75
sicilian     S    12.25
bbq chicken  M    16.75
mexicana     M     16.0
thai chicken L    20.75
5.1.5 Adding lines
julia> ''
'': Unicode U+2502 (category So: Symbol, other)
julia> Char(0x2502)
'': Unicode U+2502
julia> '\U2502'
'': Unicode U+2502
julia> collect("")
3-element Vector{Char}:
 '': Unicode U+251C
 '': Unicode U+2500
 '': Unicode U+253C
 '': Unicode U+2524
julia> "A2"^3
"A2A2A2"
julia> "-"^4
"----"
julia> ""^2
""
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
102

We can reuse what we have learned to create a trigonometry table. This code uses many of the
same functions as you have seen already: 
, 
, 
 and 
. Don’t try to run
print printstyled lpad
rpad
this function yet, I am just giving you an overview.
Listing 5.5 Creating a trigometric table
Start writing the header for each column of numbers.
Loop to write trig values for every angle.
Line 2 to 10 we write out the header of the table, while from line 12 to 22 we write out a row for
each angle. You can see how we increment the angle at line 21 on each iteration.
There is not a lot of new ideas in this code. We covered the core logic in chapter 3. However,
numbers need special handling to align the decimal point. We need equal number of digits after
the point on every number, and we don’t want too long numbers. If we use results as they are we
get way too many digits:
Instead we want something like this:
5.2 Printing a trigonometric table
function print_trigtable(inc, maxangle)
    print(" ") 
    printstyled("  ", color=:cyan)
    print("  ")
    printstyled(rpad("cos", n),
                color=:cyan)
    print("  ")
    printstyled(rpad("sin", n),
                color=:cyan)
    println(" ")
    angle = 0
    while angle <= maxangle 
        rad  = deg2rad(angle)
        cosx = format(cos(rad))
        sinx = format(sin(rad))
        print(" ")
        print(lpad(angle, 3), "  ",
              lpad(cosx, 6),  "  ",
              lpad(sinx, 6))
        println(" ")
        angle += inc
    end
end
julia> rads = map(deg2rad, 0:15:90);
julia> map(sin, rads)
7-element Vector{Float64}:
 0.0
 0.25881904510252074
 0.49999999999999994
 0.7071067811865475
 0.8660254037844386
 0.9659258262890683
 1.0
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
103

To achieve this we have made a helper function you can see in the main code listing named 
.
format
Listing 5.6 Helper function for formating numbers
Round down to 3 decimals.
If we have a negative number then we must allow for an extra character for the -
sign.
n stores the maximum character width of a number. I am basically using a worst case, such as a
negative number to get the max characters needed for the number string.
You can see in the example above, that when we use negative numbers we must allow more
characters. Later we are printing with 
 using spaces, which means the total width doesn’t
lpad
change whether the number is negative or not.
julia> print_trigtable(15, 180)
     cos     sin    
   0   1.000   0.000 
  15   0.966   0.259 
  30   0.866   0.500 
  45   0.707   0.707 
  60   0.500   0.866 
  75   0.259   0.966 
  90   0.000   1.000 
 105  -0.259   0.966 
 120  -0.500   0.866 
 135  -0.707   0.707 
 150  -0.866   0.500 
 165  -0.966   0.259 
 180  -1.000   0.000 
n = length("-0.966")
function format(x)
    x = round(x, digits=3) 
    if x < 0
        rpad(x, n, '0') 
    else
        rpad(x, n-1, '0')
    end
end
julia> format(3.1)
"3.100"
julia> format(-3.1)
"-3.100"
julia> lpad(format(4.2), 6)
" 4.200"
julia> lpad(format(-4.2), 6)
"-4.200"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
104

The data we have been dealing with thus far is in table format, exactly what a spreadsheet
application has been designed to deal with. A very common file format for exchanging data
between various types of spreadsheet applications and scientific applications, is called CSV,
which is short for 
. We will implement a 
 function
Comma Separated Values
store_pizzatable
to write pizza data in CSV format to a file and a 
 function to read the same
load_pizzatable
CSV file. Below is an example of the pizza data CSV file format both functions will work with.
The first line is referred to as the 
. It gives a name to each column in the file. For each row
header
we separate each value with a comma. Below is an example of loading such a CSV file into
Apple Numbers.
5.3 Reading and writing pizza sales to CSV files
name,size,price
hawaiian,S,10.5
mexicana,S,13.0
hawaiian,L,16.5
bbq chicken,L,20.75
sicilian,S,12.25
bbq chicken,M,16.75
mexicana,M,16.0
thai chicken,L,20.75
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
105

Say you produce lots of useful calculations you want to share, examine in a table or plot
graphically, then exporting to CSV format helps. Julia already has built in functions for this and
very good external libraries, such as csv.juliadata.org[CSV].
However our focus will be on learning the basics of reading and writing to files, thus we will not
be using external packages or functions.
We will define a simple function 
, which outputs pizza sales data as comma
store_pizzatable
separated values.
5.3.1 Writing pizza sales to a file
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
106

Listing 5.7 Function for exporting pizza sales data as comma separated values.
Write out the CSV header.
A line for each pizza sold.
This function should look familiar to you. What is new is the fact that the 
 function is
println
taking a new first argument named 
. Here there are some gotchas so let me use this function
io
wrong at first.
This is predictable. It just writes out the 
 object as a regular text string. But if the first
io
argument is of a special type, not a string, not a number, not Boolean but an 
 object then you
IO
alter where the 
 and 
 functions write their output to.
print
println
println("hello") is actually short for 
. What is 
? It is
println(stdout, "hello")
stdout
short for 
, which represents a destination for your printing. 
 represents the
standard out
stdout
default destination for anything printed. The default is your terminal window. However the
destination could be a file or even a network connection.
When can try using 
 instead of the string 
, although the result will be rather
stdout
"--->"
boring:
It gets more interesting when we provide a file as a destination. To do that we need to create an 
 object representing a file.
IO
function store_pizzatable(io, pizzas)
    println(io, "name,size,price") 
    for pz in pizzas 
        println(io, name(pz), ",",
                portion(pz), ",",
                price(pz))
    end
end
julia> store_pizzatable("-->", pizzas[1:3])
-->name,size,price
-->hawaiian,S,10.5
-->mexicana,S,13.0
-->hawaiian,L,16.5
julia> store_pizzatable(stdout, pizzas[1:3])
name,size,price
hawaiian,S,10.5
mexicana,S,13.0
hawaiian,L,16.5
julia> io = open("pizza-sales.csv", "w") 
IOStream(<file pizza-sales.csv>)
julia> store_pizzatable(io, pizzas) 
julia> close(io) 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
107

Open the file 
. The second argument 
 tells Julia that we want
pizza-sales.csv
"w"
to open it for writing. Hence the file will be created if it doesn’t already exist.
Use the 
 object to write pizza sales data to the open file.
io
The "connection" to the file has to be closed when you are done. Reading and
writing to a file can be buffered. Hence unless you close, not all data may have
actually gotten written yet.
You can go into shell mode by writing a semicolon  at the beginning of the line. Whenever you
;
want to go back to the Julia mode, you can hit backspace at the start of the line. Go into shell
mode and look at the file we created by using the Unix 
 command.
cat
More commonly we have a CSV file downloaded from the internet which we want to read from.
A lot of statistical data for anything from school results, unemployment to GDP per capita can be
downloaded as a CSV file.
We will open the 
 file and try to read from it. There are lots of clever ways of
pizza.sales.csv
doing this which we will cover in more detail in the chapter 17. Here we will keep it simple, and
use the 
 function. It reads one line at a time.
readline
The source it reads from doesn’t need to be a file. As we talked about earlier, you terminal
window is treated as an 
 object called 
. There is a corresponding 
 object representing
IO
stdout
IO
your keyboard called 
. This gives us a way of reading keyboard input.
stdin
shell> cat pizza-sales.csv
name,size,price
hawaiian,S,10.5
mexicana,S,13.0
hawaiian,L,16.5
bbq chicken,L,20.75
sicilian,S,12.25
bbq chicken,M,16.75
mexicana,M,16.0
thai chicken,L,20.75
5.3.2 Reading pizza sales from a file
julia> io = open("pizza-sales.csv")
IOStream(<file pizza-sales.csv>)
julia> line = readline(io)
"name,size,price"
julia> line = readline(io)
"hawaiian,S,10.5"
julia> s = readline(stdin)
hello 
"hello" 
julia> print(s)
hello
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
108

The text I wrote, and which got captured by readline
The value stored in . Notice use of quotation marks to indicate this value is a
s
string.
To get a feel for how that works, it is best to try it yourself. We will make a simple application
that utilizes this shortly.
Anyway, let us get back to our pizzas. How do you turn a comma-separated string into a pizza
tuple or array? For this we can use the 
 function. It allows you to split a string into multiple
split
parts and collect the parts into an array.
There is however a number of problems with treating this as a pizza. Say I want to add value
added tax of 25%. That will not work.
The reason for this problem is that the price  isn’t actually a number but a string, (or more
p
specifically a substring, but lets us not get bogged down in details):
This applies to anything we read from a file. Julia will treat it as text. It cannot know that you
might want part of the file to be represented as numbers, Boolean values or something else.
However Julia has a function called 
 which allows us to convert a text string to anything
parse
else. Below you can see conversion to a number
You see we parse the number 42 twice. In the first case we turn it into a integer while in the
second case we turn it into a floating point number. Thus the same text can be interpreted in
many different ways. It is your choice how to interpret it.
julia> pizza = split(line, ',')
3-element Vector{SubString{String}}:
 "hawaiian"
 "S"
 "10.5"
julia> p = price(pizza)
"10.5"
julia> p*1.25
ERROR: MethodError: no method matching *(::SubString{String}, ::Float64)
julia> typeof(p)
SubString{String}
julia> parse(Int, "42")
42
julia> parse(Float64, "42")
42.0
julia> parse(Bool, "true")
true
julia> parse(Bool, "1")
true
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
109

And there are entirely different text strings which can be interpreted as the same object. E.g. both
 and 
 can be parsed as the Boolean value 
. With these building blocks we can put
"true"
"1"
true
together a pizza loading function.
Listing 5.8 Load pizza sales data
A place to store a list of pizzas.
Skip the header 
.
name,size,price
 is short for 
. This function will be true when there is nothing more
eof
End of File
to read.
Turn the price text string into an actual number with 
.
parse
Add an entry to our list of pizzas. Notice 
. This is our way of turning a string
sz[1]
such as 
 into the character 
.
"M"
'M'
If you try this function in the REPL you should get a result similar to this:
Let us make an interactive application demonstrating the utility of being able to read user input
through 
. This one was inspired by a simple application I made to help my children
stdin
practice their multiplication table.
5.4 Interacting with the user
function load_pizzatable(io)
    pizzas = [] 
    readline(io) 
    while !eof(io) 
      pz = split(readline(io), ',')
      pr = parse(Float64, price(pz)) 
      sz = portion(pz)
      push!(pizzas, (name(pz), sz[1], pr)) 
    end
    pizzas
end
julia> io = open("pizza-sales.csv");
julia> pizzas = load_pizzatable(io)
8-element Vector{Any}:
 ("hawaiian", 'S', 10.5)
 ("mexicana", 'S', 13.0)
 ("hawaiian", 'L', 16.5)
 ("bbq chicken", 'L', 20.75)
 ("sicilian", 'S', 12.25)
 ("bbq chicken", 'M', 16.75)
 ("mexicana", 'M', 16.0)
 ("thai chicken", 'L', 20.75)
julia> close(io)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
110

The app repeatedly asks the user to multiply two numbers and checks the answer. At the end you
get a summary of how many correct answers you got. Let us look at the implementation of the 
 function.
practice
Listing 5.9 Practice multiplication. Asks user to write  answers
n
Keep track of how many answers the user got right.
Random numbers in the range 2 to 9.
Convert the number the user wrote to an integer.
Check if the user got the answer right.
You can start this program by invoking the 
 function from the REPL. Say we want to
practice
practice on 8 different multiplications. Then we write:
function practice(n)
    correct = 0 
    for i in 1:n
        x = rand(2:9) 
        y = rand(2:9)
        print(x, " * ", y, " = ")
        answer = readline(stdin)
        z = parse(Int, answer) 
        if z == x*y 
            correct += 1
        else
            printstyled("Wrong, it is ", x*y, color = :red)
            println()
        end
    end
    println("Correct: ", correct, " of ", n)
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
111

Whenever you deal with more complex functions which you try to understand, you can explore
how they work by simply copying and pasting lines of code you want to understand better like
this:
The benefit is that you can see the value of every expression. This allows you to see how a value
gets transformed in multiple steps. E.g. we can explore why comparing the answer directly
doesn’t work:
To cement your understanding you can experiment with improving this program. Here are some
ideas: Time yourself. Record how long time you spend answering the questions. You can use the 
 function for this purpose. Record the time before asking questions and after you are
time()
done. Look at the difference. You might want to round to nearest second with the round()
function. Use the Julia help system to see how to best use these functions.
You might also want to provide the range used with 
 as an argument to the 
rand
practice
function. There might be particular range of numbers you want to practice more on.
It could also be fun experimenting with creating nice tables using the ,,  and  symbols.
julia> practice(8)
julia> x = rand(2:9)
3
julia> y = rand(2:9)
6
julia> print(x, " * ", y, " = ")
3 * 6 =
julia> answer = readline(stdin)
18
"18"
julia> z = parse(Int, answer)
18
julia> answer == x*y
false
julia> z == x*y
true
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
112

print, 
 and 
 can all be used to send text to a destination such as a
println
printstyled
terminal window or a file
In a terminal one can use special control character sequences to write colored text. 
 simplifies this task, so you only have to remember the names of different
printstyled
colors
To write to files or read from them, you need to 
 them. When you are done, you
open
need to 
 them
close
While reading a file, you can check if you are done with eof
The 
 and 
 functions help us align text in columns. This is done by padding with
lpad
rpad
a chosen character either on the left or right side until desired string width is achieved
Text can be written or read from 
 objects. 
 objects are placeholders for real physical
IO
IO
things such as files on a hard drive, a keyboard, network connection or terminal window.
It could even be a teletype
Text strings can be converted to a variety of objects using the 
 function
parse
5.5 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
113

6
1.  
2.  
3.  
This chapter covers
We will look at a new data type called a 
. In some other languages this datatype is also
dictionary
referred to as a 
. In dictionaries values are looked up by keys, as opposed to an array where
map
values are looked up exclusively using integer indices. In the next code example the following
happens:
Look up the 42nd value  in array 
. Values in arrays are ordered. However 
 could
x
xs
xs
have been a dictionary as well, since dictionary keys can be anything including integers.
Looking up a value  in dictionary 
 with the key 
.
y
ys
"foo"
Using a character 
 rather than a string as key in dictionary 
 to lookup value .
'D'
zs
z
We will demonstrate the utility of dictionaries by working through a code example involving
conversion of Roman numerals to decimal values and back. A dictionary will be used to keep
track of what value a letter such as I, V and X corresponds to in the decimal system.
Storing data in dictionaries
Storing values on keys in dictionaries
Working with pair objects
Using tuples to create dictionaries
Comparing dictionaries and arrays
Comparing named tuples and dictionaries
x = xs[42]
y = ys["foo"]
z = zs['D']
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
114

While Roman numerals are not very practical to use today, they are useful to learn about in order
to understand number systems. In particular when programming you will encounter various
number systems.
Both Roman numerals and the binary, system used by computers, may seem very cumbersome to
use. However it often appears that way because we don’t use the numbers as they were intended.
It is hard to make calculations using Roman numerals with pen and paper compared to Arabic
numerals (which is what we use). However the Romans did not use pen and paper to perform
calculations. Rather they performed their calculations using a Roman abacus.
Figure 6.1 A Roman abacus with pebbles representing different values. The column decides how much
value each pebble is given.
It is divided into multiple columns. Going from the right, you can see columns of pebbles
marked as I, X and C. They each contain four pebbles. Each of these pebbles represent a
different value depending on what column they are in:
In the I column every pebble is a 1
In X, every pebble represent 10
In C, every pebble represent 100
The columns above contain a single pebble each. These columns are called V, L and D and
6.1 Parsing Roman numerals
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
115

represent the values 5, 50 and 500 (On Roman abacus depicted here you cannot actually see the
VLD letters).
NOTE
The beauty of the Roman system is that you can quickly write down exactly
what the pebbles on the abacus say. Likewise it is quick to arrange pebbles
on a Roman abacus to match a Roman numeral you have read. For this
reason Roman numerals were used all the way into the 1500s in Europe, long
after Arabic numerals had been introduced.
Let us look at how we can use this knowledge to parse Roman numerals and turn them into
Arabic numerals. Put the following code into a text file and save it. Don’t worry about the new
syntax we will cover that.
Listing 6.1 Parsing and converting Roman numerals to decimal numbers
Load this file into the Julia REPL environment to test it out. This is an example of using 
 with different Roman numerals as input.
parse_roman
Let us go through how the code works.
roman_numerals =
    Dict('I' => 1, 'X' => 10, 'C' => 100,
         'V' => 5, 'L' => 50, 'D' => 500,
         'M' => 1000)
function parse_roman(s)
    s = reverse(uppercase(s))
    vals = [roman_numerals[ch] for ch in s]
    result = 0
    for (i, val) in enumerate(vals)
        if i > 1 && val < vals[i - 1]
            result -= val
        else
            result += val
        end
    end
    result
end
julia> parse_roman("II")
2
julia> parse_roman("IV")
4
julia> parse_roman("VI")
6
julia> parse_roman("IX")
9
julia> parse_roman("XI")
11
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
116

We map or translate the Roman letter I, V, X etc to numbers using what is called a dictionary. A
dictionary is made up of multiple pairs. Pairs are constructed using the arrow operator 
. We
=>
cannot use equals , because it is used for assignment. 
 assigns the value of  to variable ,
=
x = y
y
x
while 
, creates a pair of the values in  and .
x => y
x
y
A pair of the letter X and the number 10.
Pairs can be stored in a variable and examined later.
 allows us to look at the fields of any value.
dump
Extracting the first value in the pair.
Pairs are composite objects with the fields 
 and 
. These fields allow us to access
first
second
both values given when the pair was constructed. However you should consider that an
implementation detail and access the fields of pairs with 
 and 
 accessor functions.
first
last
This behavior makes pairs very similar to range objects we covered in chapter 3 and tuples
covered in chapter 4.
In this code example I made a little twist and accessed several values in one line by separating
them with comma. That produced a tuple with three values.
6.2 Using the Dict type
julia> 'X' => 10           
'X' => 10
julia> pair = 'X' => 10    
'X' => 10
julia> dump(pair)          
Pair{Char,Int64}
  first: Char 'X'
  second: Int64 10
julia> pair.first          
'X': ASCII/Unicode U+0058 (category Lu: Letter, uppercase)
julia> pair.second
10
julia> range = 2:4
2:4
julia> pair = 8=>9
8 => 9
julia> tuple = (3, 'B')
(3, 'B')
julia> first(range), first(pair), first(tuple)
(2, 8, 3)
julia> last(range), last(pair), last(tuple)
(4, 9, 'B')
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
117

It may seem confusing that the 
 field of a pair is accessed with the function 
. The
second
last
reason is that last element also exist for arrays and tuples. Hence 
 generalize better across
last
multiple collection types.
NOTE
A dictionary dump produces gibberish?!
Out of curiosity you may try to use the 
 function on a dictionary object. It
dump
has fields such as 
, 
, 
 etc, which will not make a lot of
slots idxfloor maxprobe
sense to you. That is because 
 exposes implementation details. As a user
dump
of a datatype you should not need to know what fields it has, only which
function you can use to operate on it.
We provide a list of these pairs to create a dictionary. The code below shows how we create a
dictionary to map letters used by Roman numerals to their corresponding decimal value.
When used in a dictionary we refer to the first values in each pair as the 
 in the dictionary.
keys
The second values in each pair form the 
 of the dictionary. So I, X and C are keys, while 1,
values
10 and 100 e.g. are values.
We can ask a dictionary for the value corresponding to a key. This takes a Roman letter and
returns the corresponding value.
We can use this dictionary to help us convert Roman letters to corresponding values. At line 8 in
the 
 function we do this conversion with what is called an 
.
parse_roman
array comprehension
We iterate over every character 
 in the string 
. On each iteration we evaluate 
ch
s
. All of these values get collected into an array.
roman_numerals[ch]
6.3 Looping over characters
julia> roman_numerals =
           Dict('I' => 1, 'X' => 10, 'C' => 100,
                  'V' => 5, 'L' => 50, 'D' => 500,
                  'M' => 1000)
Dict{Char,Int64} with 7 entries:
  'M' => 1000
  'D' => 500
  'I' => 1
  'L' => 50
  'V' => 5
  'X' => 10
  'C' => 100
julia> roman_numerals['C']
100
julia> roman_numerals['M']
1000
vals = [roman_numerals[ch] for ch in s]
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
118

A comprehension is like a for-loop where a value is evaluated on each iteration and added to a
collection. You can create a comprehension for any collection including dictionaries.
But in our Roman numerals code the comprehension for-loop is used to build an array. To better
understand how an 
 works we will look at a regular 
 doing the exact
array comprehension
for-loop
same thing. In this example we start with Roman numerals "XIV" which we want to convert.
"XIV" is turned into the array of values 
 named 
. However the job is not quite
[10, 1, 5]
vals
done. Later we need to combine these values into one number.
Before converting input strings, our code turns every letter into uppercase. "xiv" would not get
processed correctly, because all the keys to our dictionary are uppercase.
I will walk you through the mechanics of the process, and save the explanation for why we
perform these steps for last.
We reverse the order of the letters, so we can process numerals conveniently from right to left in
a loop.
julia> Dict('A'+i=>i for i in 1:4)
Dict{Char, Int64} with 4 entries:
  'C' => 2
  'D' => 3
  'E' => 4
  'B' => 1
julia> s = "XIV"
"XIV"
julia> vals = Int8[]
Int8[]
julia> for ch in s
           push!(vals, roman_numerals[ch])
       end
julia> vals
3-element Vector{Int8}:
 10
  1
  5
julia> s = "xiv"
"xiv"
julia> s = reverse(uppercase(s))
"VIX"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
119

When processing a value 
 in the loop I want to be able to compare with the preceding value. I
val
could have accomplished that with a variable, say 
, store value from previous iteration.
prev
Instead I am choosing to use the 
 function to get the index  of each value 
 being
enumerate
i
val
processed. The value preceding 
 is then simply 
.
val
vals[i-1]
To better understand how 
 works, let me use use some examples focused exclusively
enumerate
on 
:
enumerate
Okay, that wasn’t very useful at all. The reason is that 
 is 
. You don’t get any
enumerate
lazy
values out because this expression doesn’t actually need any values to be evaluated. But we can
use the 
 function to collect all the values 
 would have produced into an array.
collect
enumerate
A simple example of collecting a range:
More interesting is how we collect values from an enumeration:
The 
 function will simulate looping over something, just like a for-loop. Except it will 
collect
 all the values encountered into an array, which it returns. So you can see with 
collect
enumerate
you get a pair of values upon each iteration: an integer index and the value at that index.
6.4 Enumerating values and indices
for (i, val) in enumerate(vals)
    if i > 1 && val < vals[i - 1]
        result -= val
    else
        result += val
    end
end
julia> enumerate([4, 6, 8])
enumerate([4, 6, 8])
julia> collect(2:3:11)
4-element Vector{Int64}:
  2
  5
  8
 11
julia> collect(enumerate(2:3:11))
4-element Vector{Tuple{Int64, Int64}}:
 (1, 2)
 (2, 5)
 (3, 8)
 (4, 11)
julia> collect(enumerate([4, 6, 8]))
3-element Vector{Tuple{Int64, Int64}}:
 (1, 4)
 (2, 6)
 (3, 8)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
120

We cannot simply add up the individual Roman letters converted to their corresponding values.
Consider the Roman number XVI. It turns into 
. We could add that and get the
[10, 5, 1]
correct result 16. However XIV is supposed to mean 14, because with Roman numerals when
you got a smaller value in front of a larger one, such as IV, then you subtract the smaller value
from the larger.
So we cannot just sum up the corresponding array 
. Instead we reverse it and work
[10, 1, 5]
our way upwards. At every index we ask if the current value is lower than the previous one. If it
is, we subtract from the result. Otherwise we add.
That is what 
 does. It compares the current value val, to the previous value 
val < vals[i - 1]
. 
 is used to accumulate the value of all the individual Roman letters.
vals[i -1] result
Now that we have looked at a practical code example utilizing the dictionary type 
 in Julia,
Dict
let us explore some more ways of interacting with a dictionary.
There are a multitude of ways to create a dictionary. Here are some examples. Multiple
arguments, where each argument is a pair object:
Pass an array of pairs to the dictionary constructor (a function named the same as the type it
makes instances of).
Pass an array of tuples to the dictionary constructor. Unlike pairs, tuples may contain more than
two values. For dictionaries they must only contain a key and a value though.
6.5 Explaining the Conversion Process
6.6 Using Dictionaries
if i > 1 && val < vals[i - 1]
    result -= val
else
    result += val
end
6.6.1 Creating Dictionaries
julia> Dict("two" => 2, "four" => 4)
Dict{String,Int64} with 2 entries:
  "two"  => 2
  "four" => 4
julia> pairs = ["two" => 2, "four" => 4]
2-element Vector{Pair{String, Int64}}:
  "two" => 2
 "four" => 4
julia> Dict(pairs)
Dict{String,Int64} with 2 entries:
  "two"  => 2
  "four" => 4
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
121

How do I know which variant to use? That depends on the problem you are trying to solve. For
instance when we read pizza data in chapter 5, we got an array of tuples back:
You might want to put this data into a dictionary to quickly lookup price for a given pizza:
However if keeping pizza data in order is not important you could define this dictionary directly
instead:
Sometimes you need an empty dictionary which you later fill up. One example would be loading
from file straight into a dictionary. Instead of appending values to the end of an array, you could
insert them into a dictionary.
Notice the 
 part. This describes what Julia has inferred is the type of the key and
{Any, Any}
value in the dictionary. However when we created our pizza dictionary, you would have noticed
that Julia described it as having the type 
. 
 refers to the type of
Dict{String, Float64} String
the keys into the dictionary and 
 the type of the values. We can however specify the
Float64
type of the key and values for an empty dictionary as well:
julia> tuples = [("two", 2), ("four", 4)]
2-element Vector{Tuple{String, Int64}}:
 ("two", 2)
 ("four", 4)
julia> Dict(tuples)
Dict{String,Int64} with 2 entries:
  "two"  => 2
  "four" => 4
pizzas = [
   ("mexicana", 13.0),
   ("hawaiian", 16.5),
   ("bbq chicken", 20.75),
   ("sicilian", 12.25),
 ]
julia> pizza_dict = Dict(pizzas)
Dict{String, Float64} with 4 entries:
  "sicilian"    => 12.25
  "bbq chicken" => 20.75
  "mexicana"    => 13.0
  "hawaiian"    => 16.5
julia> pizza_dict["mexicana"]
13.0
Dict(
  "sicilian"    => 12.25,
  "bbq chicken" => 20.75,
  "mexicana"    => 13.0,
  "hawaiian"    => 16.5)
julia>  d = Dict()
Dict{Any, Any}()
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
122

What is the benefit of specifying the type of the key and the value? It makes it easier to catch
wrong usage of the dictionary at runtime. If you try to use values of the wrong type for key and
value, Julia will throw an exception to indicate error. In this case we are trying to use an integer
5, as key when a text string key is expected.
Types will become clearer in the next chapter on types.
Sometimes you get keys and values in separate arrays. However you can still combine them into
pairs, to create dictionaries using the 
 function.
zip
We have already looked at one way of getting and setting dictionary elements. But what happens
if we try to retrieve a value for a key that does not exist, such as 
?
"seven"
We get an error. We can of course simply add it:
julia> d = Dict{String, Float64}()
Dict{String,Int64} with 0 entries
julia> d["hawaiian"] = 16.5
16.5
julia> d[5] = "five"
ERROR: MethodError: Cannot `convert` an object of type Int64
to an object of type String
julia> words = ["one", "two"]
2-element Vector{String}:
 "one"
 "two"
julia> nums = [1, 2]
2-element Vector{Int64}:
 1
 2
julia> collect(zip(words, nums))
2-element Vector{Tuple{String,Int64}}:
 ("one", 1)
 ("two", 2)
julia> Dict(zip(words, nums))
Dict{String,Int64} with 2 entries:
  "two" => 2
  "one" => 1
6.6.2 Element Access
julia> d["hawaiian"]
16.5
julia> d["seven"]
ERROR: KeyError: key "seven" not found
julia>  d["seven"] = 7;
julia> d["seven"]
7.0
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
123

But how do we avoid producing an error when we are not sure if a key exists? One solution is the
 function. If the key does not exist, a sentinel value is returned instead. The sentinel can be
get()
anything.
NOTE
What is a sentinel value?
In computer programming, a sentinel value (also referred to as a flag value,
trip value, rogue value, signal value, or dummy data) is a special value in the
context of an algorithm which uses its presence as a condition of termination,
typically in a loop or recursive algorithm.
This is a strategy followed in many programming languages, when working with dictionaries.
The example below uses -1.
Or we could simply ask the dictionary if it has the key.
In principle you could use an array to do the conversion of Roman numerals to decimal numbers.
Here is an example of how you could do that.
Listing 6.2 Lookup a value by key in an array of key-value pairs
Pull out the key  and value  of each pair in the array.
k
v
Found a matching key, so return the corresponding value.
If iterating over all the pairs didn’t find a matching key, then we are unable to
return anything and must throw an exception instead. The 
 exception is
KeyError
convention to use in Julia in cases where keys are missing.
6.7 Why Use a Dictionary?
julia> get(d, "eight", -1)
-1
julia> haskey(d, "eight")
false
julia> d["eight"] = 8
8
julia> haskey(d, "eight")
true
function lookup(key, table)
   for (k, v) in table 
       if key == k
           return v 
       end
   end
   throw(KeyError(key)) 
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
124

We could define the lookup table as an array of pairs instead of a dictionary.
With this we could do lookup of values based on keys in similar fashion to an dictionary.
A demonstration of looking up a key which doesn’t exist, producing an exception.
We avoid arrays when doing key based lookup because the time to perform a lookup grows
linearly with the size of the array. Looking up an element among 30 entries is going to take on
average 3 times as long time as looking up an entry among 10 elements. It is not hard to see how
this does not scale well with large arrays. Looking for an element among 1 million elments will
take a thousand times longer than locating it among one thousand elements.
Dictionaries in contrast are made so that the lookup time is 
 of how many elements
independent
the dictionary contains. Looking up an element among one hundred is similar to doing it among
one million.
SIDEBAR
WHY ARE DICTIONARY LOOKUPS SO FAST?
Why dictionaries allow fast lookup of a value given a key, is outside the scope
of this book. Books about data structures and algorithms usually cover this
topic in detail. And a dictionary refers more to the interface to the data, rather
than the actual data structure used to achieve fast lookups. In Julia hash
 are used to allow fast lookups, but it is also possible to implement a
tables
dictionary using a 
 data structure.
binary search tree
But don’t discount arrays. Short arrays are very fast to search. Faster than a dictionary of
comparable size. Thus while the number of elements are less than one hundred, arrays are still a
viable choice.
Then why did I use a dictionary in our Roman numeral code example? Because dictionaries are
really convenient to work with when dealing with key based lookup, and you never have to
worry about performance taking a nosedive because you added too many elements.
However there are special cases where using an array can work really well. E.g. if you never
modify the array. If elements are never added or removed you can simply keep the array sorted.
numerals = ['I' => 1, 'X' => 10, 'C' => 100,
            'V' => 5, 'L' => 50, 'D' => 500,
                                 'M' => 1000]
julia> lookup('X', roman_numerals)
10
julia> lookup('D', roman_numerals)
500
julia> lookup('S', roman_numerals) 
ERROR: KeyError: key 'S' not found
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
125

A sorted array can be searched very fast using Julia’s 
 function. In fact our
searchsortedfirst
Roman numeral code example is well suited for this approach since the mapping between
numerals and decimal values is fixed. We do this by keeping the keys and values in separate
arrays sorted by the key values.
Listing 6.3 Array of sorted keys with matching array of values
With 
 I can find the index of a particular key.
searchsortedfirst
We have made sure that the value for key  is located at the same index  in the 
 array:
I
i
vals
Another example:
Before rounding off this chapter I want to show you another neat trick which allows you to write
more readable code with better performance. You have already seen tuples where we can access
elements by index. What you have not seen is accessing tuple values by key, just like a
dictionary.
Remember we created a pizza tuple like this: 
. It is possible to give
("hawaiian", 'S', 10.5)
names to each value. The names we give will not be text strings but Julia 
 (built-in Julia
symbols
type to represent identifiers). Remember we used symbols such as 
, 
, and 
 in
:cyan :green
:red
chapter 5 to specify color of printed text. We can access individual values in the pizza tuple with
symbols such as 
 and 
.
:name
:price
6.8 Using named tuples as dictionaries
keys = ['C', 'D', 'I', 'L', 'M', 'V', 'X']
vals = [100, 500, 1, 50, 1000, 5, 10]
julia> i = searchsortedfirst(keys, 'I')
3
julia> vals[i]
1
julia> j = searchsortedfirst(keys, 'V')
6
julia> vals[j]
5
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
126

Notice how we use a shortcut in the last two expressions. 
 is equivalent to
pizza[:price]
writing 
. This way of working with data will look familiar to JavaScript
pizza.price
developers.
Keep in mind that symbols are a lot more limited in functionality compared to strings. In most
cases they are treated as atomic values. You cannot access individual characters in a symbol or
combine and manipulate them like strings. Fortunately it is easy to convert back and forth
between keys and strings:
Create a symbol from a string.
Create a string from a symbol.
With this knowledge we can rewrite our parse_roman function from listing 6.1 to use a named 
tuple instead of a dictionary. Observe that we have to change the lookup roman_numerals[ch] 
to roman_numerals[Symbol(ch)], because roman_numerals no longer have characters as 
keys but symbols.
julia> pizza = (name = "hawaiian", size = 'S', price = 10.5)
(name = "hawaiian", size = 'S', price = 10.5)
julia> pizza[:name]
"hawaiian"
julia> pizza[:price]
10.5
julia> pizza.name
"hawaiian"
julia> pizza.size
'S': ASCII/Unicode U+0053
julia> s = "price"; t = :name;
julia> Symbol(s) 
:price
julia> string(t) 
"name"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
127

Listing 6.4 Parsing roman numerals using named tuples
Changed from dictionary to named tuple.
Lookup with 
 instead of 
.
Symbol(ch)
ch
Named tuples look very similar to dictionaries, so what is the point of having them? All types of
tuples are immutable, meaning you cannot change them. You cannot add values to a tuple after
you have created it, nor can you modify existing values. In contrast, both arrays and dictionaries
allow you to add values. Dictionaries are a lot more flexible in the keys they let you work it. A
named tuple only allows you to use symbols as keys.
The benefit of any tuple type over an array or a dictionary is that the Julia JIT compiler will
know exactly which elements will be in the tuple at any given time. That allows for more
aggressive optimizations. Thus you can assume that a tuple will generally give you equal or
better performance than an array or a dictionary.
While only using symbols as keys is a limitations, that also allows named tuples to offer more
convenient syntax for accessing values. 
 is easier to write and read than 
pizza.name
.
pizza[:name]
With this chapter we have covered all the key types any programmer should know. With
numbers, ranges, strings, arrays, tuples and dictionaries you can do almost anything. However
we have not yet said much about a 
 a type actually is or how we can make our own custom
what
types. This is crucial to facilitate the construction of larger more feature-rich applications. That
will be the focus of the next two chapters.
roman_numerals = 
           (I = 1, X = 10, C = 100,
            V = 5, L = 50, D = 500,
            M = 1000)
function parse_roman(s)
    s = reverse(uppercase(s))
    vals = [roman_numerals[Symbol(ch)] for ch in s] 
    result = 0
    for (i, val) in enumerate(vals)
        if i > 1 && val < vals[i - 1]
            result -= val
        else
            result += val
        end
    end
    result
end
6.8.1 When do you use a named tuple?
6.8.2 Tying it all together
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
128

Dictionaries hold key-value pairs, where the key has to be unique
Key-value pairs can quickly be looked up, added or removed from a dictionary. This
differs from large arrays which may require time consuming searches
Arrays give better performance when the number of elements is small, or you do index
based rather than key based access
In Julia, keys and values are typed. Hence Julia is able to catch at runtime the usage of
keys which are of the wrong type, as well as attempt of inserting values of the wrong type
Named tuples work like an immutable version of dictionaries. You can look up values but
you cannot modify them or add new entries
6.9 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
129

Part-2
In the Basics part we looked a type in a very superficial manner. This part goes into the Julia
type system in more detail by building up various examples such as rockets which demonstrate
how the type system works and what benefits it gives.
This part is what really introduces what makes Julia special. The more in-depth coverage of the
type system also allows us to explain how functions and methods work in Julia. In particular it
allows us to give a proper explanation of multiple-dispatch which is the killer feature in Julia.
Multiple-dispatch is at the heart of what makes Julia such an expressive and high-performance
language.
Types
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
130

7
Understanding type hierarchies
Difference between abstract and concrete types
Combining primitive types to make composite types
Harness the power of multiple-dispatch to solve complex tasks elegantly
How multiple-dispatch differs from single-dispatch in object-orientedlanguages20
All objects in Julia are of a particular type. Remember you can use 
 to discover the type
typeof
of any object:
The type decides what you can do with an object. For example, a dictionary allows you to look
up a value by key, while an array stores elements in order. An expression evaluating to a Bool
value such as 
 or 
 can be used in if-statement and while-loops while expressions
true
false
evaluating to a floating-point value can’t:
Thus, if you want to create objects with different behavior and features, you need to define new
types. In programming, we often try to mimic the real world:
Banking apps will have types representing bank accounts, customers, and transactions
Video games will have objects representing monsters, heroes, weapons, space ships,
traps, etc
Understanding types
julia> typeof(42)
Int64
julia> typeof('A')
Char
julia> typeof("hello")
String
julia> if 2.5
           print("this should not be possible")
       end
ERROR: TypeError: non-boolean (Float64) used in boolean context
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
131

A graphical user interface will have objects representing buttons, menu entries, pop-up
menus, and radio buttons
In a drawing application, we have objects representing different shapes, strokes, colors,
and drawing tools
So whatever type of application you want to make, you will need to know how to create relevant
types to the application you are making. This chapter and the next one will define types relevant
to model behavior in a video game and a rocket simulator.
Let us start with the basics. Integers, characters, and floating-point numbers are all examples of
primitive types. You cannot break them further down into smaller parts. In some languages, such
as LISP, these are aptly named atoms. With the 
 we can check if a type is
isprimitivetype
primitive or not.
We can combine primitive types to create composite types. Composite types can even be made
out of other composite types. For example, a string is a composite type made up of multiple
characters, which are primitive types.
Let us demonstrate this with a concrete example by defining a composite type that could be
useful in a video game to represent an archer shooting arrows on opponents.
Listing 7.1 Definition of a composite type
The name of the archer, say Robin Hood.
Health points left.
Arrows left in the quiver.
Think of types as templates or cookie cutters, which you use to stamp out multiple objects. The
objects we make from a type are called 
.
instances
7.1 Creating Composite Types From Primitive Types
julia> isprimitivetype(Int8)
true
julia> isprimitivetype(Char)
true
julia> isprimitivetype(String)
false
struct Archer
    name::String 
    health::Int 
    arrows::Int 
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
132

WARNING
To object-oriented programmers
Julia composite types may look very similar to classes in Java, C++ or Python
but they are not the same thing. They don’t support implementation
inheritance and don’t have methods attached.
Below we create instances of the 
 type. You may also hear people use phrases such as
Archer
"Instantiate an Archer object."
Access the 
 field of the robin object.
name
 field of robin object.
arrows
The definition of a composite type has some similarities with using a dictionary. For example,
we define fields for storing values that can be accessed through their field name. However,
unlike a dictionary, we can specify a different type for each field using a 
.
type annotation
IMPORTANT
In Julia the 
 is used to annotate variables and expressions with their type. 
::
 means variable  should have type . It helps Julia figure out how many
x::T
x
T
bytes are needed to hold all fields in a 
.
struct
To clarify this point, let me define a dictionary to hold information about an archer.
Listing 7.2 Using a dictionary to store information about an archer
Dictionary with 
 key and where value is of type 
.
String
Any
julia> robin = Archer("Robin Hood", 30, 24)
Archer("Robin Hood", 30, 24)
julia> william = Archer("William Tell", 28, 1)
Archer("William Tell", 28, 1)
julia> robin.name 
"Robin Hood"
julia> robin.arrows 
24
julia> robin = Dict("name"   => "Robin Hood",
                    "health" => 30,
                    "arrows" => 24)
Dict{String, Any} with 3 entries: 
  "name"   => "Robin Hood"
  "health" => 30
  "arrows" => 24
julia> robin["name"] 
"Robin Hood"
julia> robin["arrows"]
24
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
133

Accessing value stored for name key.
A problem with using a dictionary is that it requires every value to be of the same type. But, wait
a minute, how can this be the case? 
 and 
 are entirely different types?
name
arrows
The short answer is that the values in the dictionary are of type 
. That means you can store
Any
values of any type. The keys are more restrictive as they are defined to be of type 
. But to
String
really understand how this works we need to explore Julia type hierarchies.
If you are familiar with object-oriented languages, then you should be familiar with class21
inheritance hierarchies. In Julia, we also have type hierarchies, but a significant difference is that
these hierarchies also exist for primitive types. For example, in a language such as Java or C++,
an integer or a floating-point number is just one concrete type. However, in Julia, even numbers,
collections, and strings are part of deeper type hierarchies.
7.2 Exploring type hierarchies
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
134

Figure 7.1 Type hierarchy for numbers, showing abstract and concrete types in blue and gray.
We can explore these hierarchies with the 
 and 
 functions. Let me show you
supertype
subtypes
how you can recreate the type-hierarchy for numbers which I have shown above. You could start
at the top and find subtypes:
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
135

Find immediate subtypes of the 
 type.
Number
Discover subtypes of real numbers.
Integers can be signed or unsigned.
But how do know that the root of the number hiearchy is the 
 type? You could work your
Number
way upwards from number types you already know:
Store the type of 42 in variable .
T
Lookup supertype of 
 and store in .
Int64
T
We can even continue pass the root of the number hierarchy, until we get to the root of the whole
Julia type hierarchy. Once you reach 
 you know that you have reached the top of the type
Any
hierarchy because the supertype of 
 is also 
.
Any
Any
It is essential to realize that Julia’s types are first-class objects that you can pass around as
arguments or store in variables. For example, here we are storing the type of the integer 42 in a
julia> subtypes(Number) 
2-element Vector{Any}:
 Complex
 Real
julia> subtypes(Real) 
4-element Vector{Any}:
 AbstractFloat
 AbstractIrrational
 Integer
 Rational
julia> subtypes(Integer) 
3-element Vector{Any}:
 Bool
 Signed
 Unsigned
julia> T = typeof(42) 
Int64
julia> T = supertype(T) 
Signed
julia> T = supertype(T)
Integer
julia> T = supertype(T)
Real
julia> T = supertype(T)
Number
julia> T = supertype(T)
Any
julia> T = supertype(T)
Any
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
136

variable called . It is a convention in many languages to use  as a name for an arbitrary type.
T
T
Let us explore the type hierarchy with some simple functions:
Listing 7.3 Find the root of the type hierarchy
Check if supertype of  is the same as .
T
T
This is a recursive
 function which we can use to find the top of the type hierarchy:
22
We can see that the type hierarchy stops at 
 since the supertype of 
 is 
. So what is the
Any
Any
Any
significance of these type hierarchies? How do they help you as a programmer?
Let me give you this example in the REPL to give a hint:
Define an array which can hold 
 value.
Any
Define an array to hold 
 values.
Integer
Putting a string into 
 array works fine.
anything
The 
 array will not accept strings.
integers
function findroot(T)
    T2 = supertype(T)
    println(T)
    if T2 != T 
        findroot(T2)
    end
end
julia> findroot(typeof(42))
Int64
Signed
Integer
Real
Number
Any
julia> supertype(Any)
Any
julia> anything = Any[42, 8] 
2-element Vector{Any}:
 42
  8
julia> integers = Integer[42, 8] 
2-element Vector{Integer}:
 42
  8
julia> anything[2] = "hello" 
"hello"
julia> integers[2] = "hello" 
ERROR: MethodError: Cannot `convert` an object
       of type String to an object of type Integer
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
137

Since every object in Julia conforms to the 
 type, you can put any object into an array where
Any
you have specified that each element must be of type 
. However, not every Julia object is of
Any
type 
. Thus, putting a text string such as 
 into an array where each element
Integer
"hello"
must be of type 
 will not work.
Integer
How do we know what types are compatible? The value you try to store has to be of a type
which is a subtype of the allowed element type. It turns out you can check this programmatically
with the 
 operator:
<:
Listing 7.4 Examining which types are subtypes of each other
A string is not a kind of integer.
 is a number but not an integer.
Float64
You can see from this example that types cannot be merely somewhat related such as
floating-point numbers and integers. 4.5 e.g. is a floating-point number but not an integer.
However both 
 and 
 are integer numbers. They are subtypes of 
.
Int8(4)
Int32(5)
Integer
That should give you a hint of the advantages of defining composite types to hold related data
over using a dictionary. Each field can have a different type. That gives better type checking at
runtime.
To further explore these concepts, we will develop a simple simulator of battles between
different warriors as frequently done in board games, card games, and video games.
Many computer games work on the rock-paper-scissors principle. Let me clarify: We have
archers, knights, and pikemen in our game. We want the game set up so that:
Archers beat pikemen
Knights beat archers
Pikemen beat knights
That is roughly how these units worked historically. Archers would fire arrows at slow-moving
pikemen and beat them before they could get close enough to attack the archers. This strategy
7.3 Creating a Battle Simulator
julia> String <: Any
true
julia> String <: Integer 
false
julia> Int8 <: Integer
true
julia> Float64 <: Integer 
false
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
138

would fail with knights who could ride up to the archers before they managed to loosen many
arrows and cut them down. However, the knights could not use this strategy against pikemen, as
a wall of spears would prevent the knights from charging the pikemen lest they get skewered.
We are going to implementing the following in code:
An abstract type 
 for all warrior types
Warrior
Concrete warrior types 
, 
 and 
Archer Pikeman
Knight
Explain relation between concrete and abstract types
Add behavior to each warrior type by defining functions such as 
 and 
shoot!
mount!
Add 
 function to simulate one warrior attacking another
attack!
Implement 
 function to simulate two warriors repeatedly attacking each other
battle!
until one is victorious or both perish.
Make a file named, e.g. 
 to store the code we will develop. We start with a
warriors.jl
definition of the types we will use:
Listing 7.5 Definition of types in battle simulator
Defines an abstract type 
.
Warrior
 defined as a mubtable subtype of 
.
Archer
Warrior
Knights can be mounted on a horse or on foot.
The code above is creating a type hierarchy illustrated below. In these hierarchies we make
distinctions between abstract and concrete types. 
, 
 and 
 are examples of
Archer Pikeman
Knight
concrete types, while 
 is an example of an abstract type. You can create objects of a
Warrior
concrete type, but not of an abstract type:
7.3.1 Defining warrior types
abstract type Warrior end 
mutable struct Archer <: Warrior 
    name::String
    health::Int
    arrows::Int
end
mutable struct Pikeman <: Warrior
    name::String
    health::Int
end
mutable struct Knight <: Warrior
    name::String
    health::Int
    mounted::Bool 
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
139

The purpose of abstract types is to help build type-hierarchies.
Figure 7.2 Warrior type hierarchy. Gray boxes are concrete types.
In figure 7.2 I have added 
 and 
 to the 
 type box. However this is just to
name
health
Warrior
clarify that all subtypes are required to have these fields. Julia offers no syntax to enforce this.
Instead this is something we would do by convention.
In Julia, if you define a type as 
 it cannot have any fields. Only concrete types
abstract type
can have fields or a value. A composite type is a concrete type with fields, while a primitive type
is a concrete type with a single value.
We use the subtype operator 
 is not only used to check if a type is a subtype of another, but
<:
also to define a type as subtype:
This code snippet defines type  as a subtype of type . In Julia you cannot subtype concrete
B
A
types. If you have used popular object-oriented languages such as Java, C++, C#, Python or
Ruby this will likely come as a surprise to you. If you consider the number hierarchy we have
just covered this makes sense. You know how much space an 
 or 
 needs but how
Int32
Float64
many bytes of storage would you need to hold an 
 or a 
 number? You cannot know
Integer
Real
that. That is why most of the number types are abstract.
julia> robin = Archer("Robin Hood", 34, 24)
Archer("Robin Hood", 34, 24)
julia> Warrior()
ERROR: MethodError: no constructors have been defined for Warrior
struct B <: A
  ...
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
140

Warriors containing only data isn’t exciting. So we are going to add behavior to them by
defining several functions with accompanying methods. Add these to the 
 source
warrior.jl
code file.
All these functions have an exclamation mark in their name because they modify a field
(remember, it is only a convention). That is why our composite types have the 
 keyword
mutable
added to their definitions. If a 
 type is not defined as mutable, it will not support
struct
functions that modify a field. Without the 
 keyword, a composite type will default to
mutable
being 
.
immutable
Listing 7.6 Add behavior to warrior types
Here is a short description of what each function does:
shoot! - Archer shoots an arrow. Depleet number of arrows by one
resupply - Simulate that archer gets a resupply of 24 arrows
mount! - Change state of knight to be mounted on a horse
dismount! - Dismount knight, to make ready for foot combat
SIDEBAR
MUTABLE VS IMMUTABLE TYPES
An important insight developed within the functional programming
community was: If objects cannot be modified, your program will be less likely
to have bugs. Objects which cannot be modified are called 
. If they
immutable
can be modified, they are referred to as 
.
mutable
In older languages, objects have tended to be mutable by default. Julia
follows a modern trend: to make objects 
 unless explicitly marked
immutable
as 
.
mutable
With the 
 function we can simulate how the archer will spend arrows in battle. Usually a
shoot!
7.3.2 Adding behavior to warriors
function shoot!(archer::Archer)
    if archer.arrows > 0
        archer.arrows -= 1
    end
end
function resupply!(archer::Archer)
    archer.arrows = 24
end
function mount!(knight::Knight)
    knight.mounted = true
end
function dismount!(k::Knight)
    knight.mounted = false
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
141

medieval archer would have 24 arrows in a quiver. When those had been spent he would have to
get a resupply.
Archer created with 24 arrows.
Number of arrows left.
Twentytwo arrows left.
We can improve the 
 function with a trick I use frequently when developing Julia
shoot!
software: I return the object which is most useful to see displayed when running a function in the
REPL. When calling functions which modify an object, it is very useful to see what that object
looks like after the modification. Thus it is a good habit to return the modified object in mutating
functions.
Listing 7.7 Modify mutating functions to be REPL-friendly
Returns the archer object modified.
This makes it easier to test functions you are developing and seeing that they perform the correct
operations:
julia> robin = Archer("Robin Hood", 34, 24) 
Archer("Robin Hood", 34, 24)
julia> shoot!(robin)
23 
julia> shoot!(robin)
22 
julia> robin
Archer("Robin Hood", 34, 22) 
function shoot!(archer::Archer)
    if archer.arrows > 0
        archer.arrows -= 1
    end
    archer 
end
function resupply!(archer::Archer)
    archer.arrows = 24
    archer 
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
142

Show how the number of arrows is decremented.
Number of arrows have been increased to 24.
We can use these functions to construct new functions to simulate that a warrior attacks another.
Again we add this code to the 
 file. It looks as if we defined 
 twice. How
warriors.jl
attack!
is that possible?
Listing 7.8 Two methods for simulating battle between archers and knights
Simulate an archer attacking another archer.
Archer attacking a knight.
Cannot attack if we are out of arrows.
Roll a six-sided dice (d6) to compute arrow damage.
Use 
 to avoid ending up with negative health.
max
If this was a regular dynamic language such as JavaScript, Python, Ruby or Lua, the last
definition of 
 would have overwritten the first one. If this was a statically typed
attack!
language such as Java, C# or C++ we would have created something called function overloading
julia> robin = Archer("Robin Hood", 34, 24)
Archer("Robin Hood", 34, 24)
julia> shoot!(robin)
Archer("Robin Hood", 34, 23) 
julia> shoot!(robin)
Archer("Robin Hood", 34, 22) 
julia> shoot!(robin)
Archer("Robin Hood", 34, 21) 
julia> resupply!(robin)
Archer("Robin Hood", 34, 24) 
function attack!(a::Archer, b::Archer) 
    if a.arrows > 0 
        shoot!(a)
        damage = 6 + rand(1:6) 
        b.health = max(b.health - damage, 0) 
    end
    a.health, b.health
end
function attack!(a::Archer, b::Knight) 
    if a.arrows > 0 
        shoot!(a)
        damage = rand(1:6) 
        if b.mounted
            damage += 3
        end
        b.health = max(b.health - damage, 0) 
    end
    a.health, b.health
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
143

. But in Julia something entirely different happens.
23
In Julia we are not actually defining two functions but rather two 
 attached to the 
methods
 function. Yes, I know this sounds confusing so let me break it down in more detail. In
attack!
Julia you actually define functions like this:
Listing 7.9 Function definitions in Julia without methods
Functions are just names. Unless you attach methods to them, they cannot do anything. Startup a
fresh Julia REPL and paste in these function definitions and the definitions of the 
, 
Warrior
 and 
 types (listing 7.5), and create some objects to work with:
Archer
Knight
Now we can try to do things with these objects, and see what happens:
Trying to call a function with no defined methods.
Attempt to call an undefined function.
You can see from the errors above that Julia distinguishes between functions you have not
defined at all, such as 
 and functions which are defined such as 
 and 
, but
mount!
shoot!
attack!
which have no methods. But how do we know they don’t have any methods? Julia has a function
called 
 which allows us to inspect how many methods are attached to a function.
methods
Show that 
 is a function with no methods.
attack!
 cannot be found by Julia.
mount!
7.3.3 Using Multiple Dispatch to Invoke Methods
function shoot! end
function resupply! end
function attack! end
julia> robin = Archer("Robin Hood", 34, 24)
Archer("Robin Hood", 34, 24)
julia> white = Knight("Lancelot", 34, true)
Knight("Lancelot", 34, true)
julia> attack!(robin, white) 
ERROR: MethodError: no method matching attack!(::Archer, ::Knight)
julia> shoot!(robin) 
ERROR: MethodError: no method matching shoot!(::Archer)
julia> mount!(white) 
ERROR: UndefVarError: mount! not defined
julia> methods(attack!) 
# 0 methods for generic function "attack!":
julia> methods(mount!) 
ERROR: UndefVarError: mount! not defined
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
144

We can see that Julia reports to us that 
 doesn’t have any methods. Let us compare this
attack!
result with loading the 
 file into the REPL.
warriors.jl
Loads the code into the Julia REPL.
Figure 7.3 illustrates what we see in the REPL. Internally Julia has a list of functions. Every
function entry points to another list containing the methods for the corresponding function entry.
Methods can span different types as they are not attached to types but to functions. Nothing
prevents you from adding a 
 method which operates on a dictionary or array type.
shoot!
Figure 7.3 How methods are attached to functions.
julia> include("warriors.jl") 
julia> methods(shoot!)
# 1 method for generic function "shoot!":
[1] shoot!(archer::Archer)
julia> methods(attack!)
# 2 methods for generic function "attack!":
[1] attack!(a::Archer, b::Archer)
[2] attack!(a::Archer, b::Knight)
julia> methods(mount!)
# 1 method for generic function "mount!":
[1] mount!(knight::Knight)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
145

Let us create some objects to allows us to play around a bit.
With some objects we can experiment with using objects of different type when invoking the 
 function.
attack!
Attack knight with archer.
Health points left for attacker and defender.
Let archer attack an archer.
Knight attacks knight.
Method with closest match to our attempted call.
I advise you to experiment a bit with this yourself. You can look at how health points get
depreciated with different attacks. To make it easier to keep track of how health points change,
each method is set up to return a tuple with the health points of the attacker and defender at the
end of the fight.
The interesting point here is the last part where we try to have a battle between two knights. You
might have noticed that we have not added a method yet dealing with a fight between two
knights, but we could add it.
Listing 7.10 Method for simulating an attack by a knight against another knight.
julia> robin = Archer("Robin Hood", 34, 24)
Archer("Robin Hood", 34, 24)
julia> tell = Archer("William Tell", 30, 20)
Archer("William Tell", 30, 20)
julia> white = Knight("Lancelot", 34, true)
Knight("Lancelot", 34, true)
julia> black = Knight("Morien", 35, true)
Knight("Morien", 35, true)
julia> attack!(robin, white) 
(34, 30) 
julia> attack!(robin, white) 
(34, 26) 
julia> attack!(tell, robin) 
(30, 22) 
julia> attack!(black, white) 
ERROR: MethodError: no method matching attack!(::Knight, ::Knight)
Closest candidates are:
  attack!(::Archer, ::Knight) 
function attack!(a::Knight, b::Knight)
    a.health = max(a.health - rand(1:6), 0)
    b.health = max(b.health - rand(1:6), 0)
    a.health, b.health
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
146

You can add this method to the 
 file and reload it. Instead of reloading everything
warriors.jl
you could just paste the definition into the REPL. Afterwards you will notice that having the
black knight Sir Morien attack the white knight Sir Lancelot, works fine.
And you will notice that Julia reports that the 
 function has 3 methods now:
attack!
Let us add another 
 method to allow archers to attack pikemen. Then you can look
attack!
yourself at how the number of methods have changed.
Listing 7.11 Archer attacking pikeman
Only allow an attack if archer has more than zero arrows.
When you invoke 
, Julia will find the type of every argument to find a tuple of
attack!(a, b)
all the argument types:
Julia will use this tuple of argument types to look through the list of all methods to find the one
matching. Remember functions don’t have code in Julia. Methods have code. If a function
doesn’t have any methods, you cannot run that function. We can illustrate this process with a
diagram.
7.4 How Julia selects method to call
julia> attack!(black, white)
(33, 22)
julia> methods(attack!)
# 3 methods for generic function "attack!":
[1] attack!(a::Archer, b::Archer)
[2] attack!(a::Archer, b::Knight)
[3] attack!(a::Knight, b::Knight)
function attack!(a::Archer, b::Pikeman)
    if a.arrows > 0 
        shoot!(a)
        damage = 4 + rand(1:6)
        b.health = max(b.health - damage, 0)
    end
    a.health, b.health
end
argtypes = (typeof(a), typeof(b))
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
147

1.  
2.  
3.  
4.  
5.  
Figure 7.4 How methods are attached to functions.
We assume in this example that an archer is attacking a pikeman, so the  is an 
 and the 
a
Archer
b
is a 
. Let us look at what happens step by step:
Pikeman
Julia tries to evaluate (execute) the 
 expression in your program.
attack!(a, b)
It takes the name of the function 
 and looks through a table of all functions, until
attack!
it finds the entry for 
.
attack!
Julia does the equivalent of 
 to get the tuple (Archer,
(typeof(a), typeof(b))
Pikeman). Julia scans the list of methods stored on the 
 function from top to
attack!
bottom, until it finds a match at the 4th entry.
Julia locates the method. The method is encoded as an abstract syntax tree (AST). This is
a common data structure
 in dynamic languages
 for representing functions/methods at
24
25
runtime.
The Julia just-in-time compiler converts the AST to machine code
 which gets executed.
26
The compiled machine code gets stored in the methods table so next time the 
 gets looked up it can just execute cached machine code.
attack(Archer, Pikeman)
Understanding all of this fully would require a deep dive into compiler and interpreter theory
which would be outside the scope of this book. This the best way for you to think about this is
that we are done at step 4. Somehow we find a representation of our method that we can run.
The last steps are mainly interesting to those interested in understanding why Julia has such high
performance, compared to other languages.
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
148

SIDEBAR
ASTs for the Curious
This is not a book about compiler concepts such as abstract syntax trees. But
let me give a little bit of information about them to help you understand Julia.
Consider an expressions such as:
When a compiler or interpreter reads such code it will usually turn it into a
tree structure called an AST, like this:
Figure 7.5 Abstract Syntax Tree (AST) of expression y = 4*(2 + x)
In Julia every method is turned into such a tree structure. The methods table
for each function keeps track of each of these tree structures. The Julia
compiler use these to create actual machine code that the computer
understands.
Multiple-dispatch is often confusing to developers with a background in object-oriented
programming languages. Thus I will try to contrast the Julia approach with how object-oriented
languages work. In an object-oriented language method, implementations to execute are picked
based on a single argument type. That is why we call the approach 
.
single dispatch
In an object-oriented language you would not write 
 but:
attack!(archer, knight)
y = 4*(2 + x)
7.4.1 Contrasting Julia’s Multiple-Dispatch With Object-Oriented Languages
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
149

Listing 7.12 Syntax if Julia was an object-oriented language
While we cannot write Julia code like that we can simulate this behavior in Julia.
Listing 7.13 Single dispatch in Julia
Handle all the cases where the attacker is an 
.
Archer
All cases where the attacker is a 
.
Knight
That illustrates the limitations of single-dispatch. Because 
 methods can only be picked
attack!
based on the first argument type, we need a long list of if-else statements to deal with opponents
of different types. Let me clarify how single-dispatch works with a step-by-step explanation.
archer.attack!(knight)
archer.shoot!()
knight.mount!()
function attack(archer::Archer, opponent) 
    if typeof(opponent) == Archer
        ...
    elseif typeof(opponent) == Knight
       ...
    elseif typeof(opponent) == Pikeman
    end
end
function attack(knight::Knight, opponent) 
    if typeof(opponent) == Archer
        ...
    elseif typeof(opponent) == Knight
       ...
    elseif typeof(opponent) == Pikeman
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
150

1.  
2.  
3.  
4.  
Figure 7.6 How a method is invoked using single-dispatch
When 
 is evaluated, we lookup the object referred to by .
a.attack!(b)
a
On this archer object, there is a hidden field, 
, which points to the type of the archer
isa
object.
The type 
 is an object itself with various fields. It has fields for each method: 
Archer
, 
 etc. It is like a dictionary, where we use the function name 
 to
shoot! attack!
attack!
look up the correct method.
The method is an Abstract Syntax Tree (AST) which we can evaluate.
So the key difference with Julia to realize is that in most mainstream languages, methods are
stored on the type of an object, while in Julia methods are stored on functions.
Statically typed languages such as Java, C# and C++ have something called function
overloading, which look superficially the same as multiple-dispatch.
The key difference is that with function overloading, the correct method to call is decided at
compilation time, which means a method like the one shown below isn’t possible in a statically
typed language:
7.4.2 How is Multiple-Dispatch Different from Function Overloading?
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
151

Listing 7.14 Write out outcome of a battle between two warriors
 and  must be a subtypes of the 
 type.
a
b
Warrior
Add this method to your 
 source code file. Reload everything and recreate the
warriors.jl
usual suspects 
 and 
 to test out 
 in the REPL. Robin Hood attacks Sir
white
robin
battle!
Lancelot multiple times until the health points of Lancelot drops low enough that 
 prints
battle!
out that he has been defeated.
When you call 
 Julia will look for a method with the signature 
battle!(robin, white)
, 
but 
this 
cannot 
be 
found. 
However 
battle!(a::Archer, 
b::Knight)
 is a valid match, because both 
 and 
 are
battle!(a::Warrior, b::Warrior)
Knight
Archer
subtypes of 
.
Warrior
When the Julia compiler compiles the 
 method, it cannot know what concrete type
battle!
argument  and  will have. It can only know that they are some subtype of 
. Thus the 
a
b
Warrior
 cannot pick the correct 
 method to call. This decision can only be made at
compiler
attack!
runtime. That is what makes this different from function overloading. Function overloading, as
found in Java and C++, relies on the compiler being able to pick the correct method.
function battle!(a::Warrior, b::Warrior) 
    attack!(a, b)
    if a.health == 0 && b.health == 0
        println(a.name, " and ", b.name, " destroyed each other")
    elseif a.health == 0
        println(b.name, " defeated ", a.name)
    elseif b.health == 0
        println(a.name, " defeated ", b.name)
    else
        println(b.name, " survived attack from ", a.name)
    end
end
julia> battle!(robin, white)
Lancelot survived attack from Robin Hood
julia> battle!(robin, white)
Lancelot survived attack from Robin Hood
julia> battle!(robin, white)
Robin Hood defeated Lancelot
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
152

Numbers in Julia are part of an elaborate type hierarchy
In a type hierarchy, only the leaf nodes can be concrete types. All other types are abstract
The 
, 
 and 
 functions can be used to explore type hierarchies
typeof supertype
subtypes
A function is just a name. Without attached methods, they cannot do anything. Code is
always stored inside methods. The type of the arguments determine which method will
get executed at runtime
Object-oriented languages use single-dispatch, meaning only the type of the first function
argument decides what method is selected. Julia is multiple-dispatch meaning all
arguments influence which method gets selected
A composite type, unlike a primitive type, is composed of zero or more fields. The 
 keyword is used to define a composite type
struct
By adding the 
 keyword to a 
 definition, we allow individual fields in the
mutable
struct
composite to be modified at runtime
7.5 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
153

8
This chapter covers
In our last chapter, we made some simple composite types to represent different types of
warriors. However, in more realistic applications, you will have to combine many different types
of objects into more complex data structures.
To explore this topic, we will be building a rocket in code. Why a rocket? Because rockets are
made up of many different parts. That gives us an opportunity to build composite types out of
other composite types and show different ways in which abstract types can be used in Julia to
facilitate the construction of complex data structures.
This rocket example will be used to explore many other topics later in the book, such as how
Julia represents collections of objects.
Our code example will start by defining a simple rocket 
 consisting of a 
, 
Rocket
Payload Tank
and an 
 object. Later we will modify our simple type definition to create a more complex
Engine
multi-staged rocket made up of multiple 
 objects.
StagedRocket
Next we will modify our code further to add a type 
 representing a cluster of rocket
Cluster
engines which can be attached to any rocket stage.
At the end we will define a function 
 to simulate the launch of a multi-stage rocket.
launch!
Building a rocket
Building complex data structures made up of many different objects of different types
Abstracting away differences between different but related types
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
154

Let us start by modeling a simple space rocket in code. This is a single stage rocket, made up of
the following parts from bottom to top:
A rocket engine providing propulsion
A propellant tank containing matter expelled by engine
Payload such as a capsule or satellite
The payload is the useful stuff we want to move around in space. It could be a crew module for
astronauts or a probe with instruments to explore other planets.
Figure 8.1 The parts a rocket is made of
Such a rocket could be defined by a composite type. But don’t type this out yet. This is just to get
you to think about the types we will need to define. We are going to implement different types
for tanks and engines. Then we will add different attributes and behavior, such as refilling tanks
and consuming propellant.
Listing 8.1 First definition of a simple rocket
8.1 Building a simple rocket
struct Rocket
    payload::Payload
    tank::Tank
    engine::Engine
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
155

Instead we will focus our attention on the propellant tank. Propellant is the matter a rocket engine
expels to move forward. In its simplest form, it is a compressed gas being released. In real space
rockets, however, it is a combination of a fuel such as kerosene or hydrogen and an oxidizer such
as liquid oxygen (LOX). However, these are details we don’t have to include in our model.
Instead, what we care about is:
Dry mass - Mass of an empty tank
Total mass - Mass of a full tank
Propellant mass - Propellant currently left in the tank
Mass - Dry mass plus propellant currently left
I will show some different way of modeling this in Julia, and talk about pros and cons of these 
different approaches.
To make it easier to organize the code we write in this chapter, you can spread it over multiple 
files and then have one file e.g., Rockets.jl, which includes all of them. That way, you can 
load just this file into your REPL to get all the code imported. In the code listing 8.2 we assume 
you have already made the thanks.jl, engines.jl and payloads.jl files and want to load all 
of them in one go.
Listing 8.2 Rockets.jl
This is just a suggestion, you can dump all the code into one file if you find that more practical.
IMPORTANT
When changing the definition of a type in your source code, you will need to
restart your Julia REPL completely and load your code anew. Changing
functions, however, only requires pasting the new code into the REPL to take
effect.
To allow a rocket to contain many different types of tanks, we will make 
 an abstract type.
Tank
Since the medium and large tanks defined below are subtypes of 
 they can be inserted into
Tank
any field expecting a 
 object.
Tank
include("tanks.jl")
include("engines.jl")
include("payloads.jl")
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
156

Listing 8.3 Defining different propellant tanks with fixed capacity
Make 
 an abstract type.
Tank
Mutable to allow propellant mass to change.
 and 
 are not stored.
drymass
totalmass
With these tanks access their dry mass and total mass is tied to the type of the tank. However we
could also make flexible tank where you can set dry mass and total mass to whatever you like:
Listing 8.4 Propellant tank with flexible capacity
At the moment our tanks are just dumb containers of information. They don’t do anything useful,
so let us add useful behavior.
abstract type Tank end 
mutable struct SmallTank <: Tank  
    propellant::Float64
end
mutable struct MediumTank <: Tank 
    propellant::Float64
end
mutable struct LargeTank <: Tank 
    propellant::Float64
end
# Accessor functions (getters)
drymass(::SmallTank) = 40.0 
drymass(::MediumTank) = 250.0 
drymass(::LargeTank) = 950.0 
totalmass(::SmallTank) = 410.0 
totalmass(::MediumTank) = 2300.0 
totalmass(::LargeTank) = 10200.0 
mutable struct FlexiTank <: Tank
    drymass::Float64
    totalmass::Float64
    propellant::Float64
end
# Accessors (getters)
drymass(tank::FlexiTank) = tank.drymass
totalmass(tank::FlexiTank) = tank.totalmass
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
157

Listing 8.5 Adding Propellant tank abilities and behavior
Accessors for the propellant field.
Check if the tank is empty.
Calculate current total mass of a tank.
Refill tank with propellant.
Make changed tank state available to the REPL.
Consume propellant.
Let us make some tanks to demonstrate the behavior of these functions.
Make a small tank with 50 kg of propellant.
Consume 10 kg of propellant.
# Accessors (setters and getters)
propellant(tank::Tank) = tank.propellant 
function propellant!(tank::Tank, amount::Real) 
    tank.propellant = amount
end
isempty(tank::Tank) = tank.propellant <= 0 
mass(tank::Tank) = drymass(tank) + propellant(tank) 
# Actions
function refill!(tank::Tank) 
    propellant!(tank, totalmass(tank) - drymass(tank))
    tank 
end
function consume!(tank::Tank, amount::Real) 
    remaining = max(propellant(tank) - amount, 0)
    propellant!(tank, remaining)
    remaining
end
julia> small = SmallTank(50) 
SmallTank(50.0)
julia> consume!(small, 10) 
40.0
julia> consume!(small, 10) 
30.0
julia> small 
SmallTank(30.0)
julia> refill!(small)
SmallTank(370.0)
julia> flexi = FlexiTank(5, 50, 0) 
FlexiTank(5.0, 50.0, 0.0)
julia> refill!(flexi)
FlexiTank(5.0, 50.0, 45.0)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
158

Check what the tank contains.
5 kg dry mass, 50 kg total mass and 0 kg propellant.
In the code example, we are using two different tanks, a small tank and a flexi tank. Although 
 and 
 have only been written to deal with the 
 type, we can use these
consume!
refill!
Tank
functions for both 
 and 
 because we have implemented 
 and 
SmallTank
FlexiTank
drymass
 for all concrete subtypes of 
.
totalmass
Tank
propellant and 
 is implemented on the assumption that all 
 subtypes have a 
propellant!
Tank
 field. That may not always be the case. However, this is not a problem. If you
propellant
define 
 accessor functions for a concrete 
 subtype, these will always take
propellant
Tank
precedence. When Julia searches through the method list of a function, it always looks for the
methods with the most concrete argument types.
NOTE
Accessor functions in Julia
In object-oriented languages, accessors functions, also known as setters and
getters are important. For instance in Java if a type has 
 field, you
propellant
might write a 
 and 
 method. In Julia the
GetPropellant
SetPropellant
equivalent is 
 for getting a value and 
 for setting a
propellant
propellant!
value. However Julia is not an object-oriented language so avoid overusing
this pattern.
We can use the 
 methods to have tanks automatically filled to the max when
refill!
constructed.
Listing 8.6 Extra constructors making it easy to create full tanks
Our code examples have shown that there are different ways of modeling a propellant tank. How
do you decide which approach to use in your own code? The first approach of having specific
types for each capacity, such as having a 
, 
, and 
, potentially
SmallTank MediumTank
LargeTank
saves memory if you are creating a lot of these objects. The number of bytes an object requires to
function SmallTank()
    refill!(SmallTank(0))
end
function MediumTank()
    refill!(MediumTank(0))
end
function LargeTank()
    refill!(LargeTank(0))
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
159

be stored in memory is dependent on the number of fields it has and the size of each field. A 
 field only consumes a byte, but a 
 field would consume eight bytes. Each 
Int8
Int64
FlexiTank
object consumes three times as much space in memory as the fixed tank objects.
However, in the code we are writing, this is of no concern. We don’t have very many tanks. Even
if we had thousands of tanks, it would not matter. The 
 would be a better option as it
FlexiTank
offers more flexibility in usage. So why did we create the fixed tanks then?
By contrasting these different approaches to modeling a tank, we get a better sense of what is
possible with Julia’s type system. There will be cases where this kind of tradeoff is worth it. For
example, imagine simulating a city of millions of people. Each person might have attributes such
as position, hunger, tiredness, money in pocket, clothes, shoes, etc. When dealing with that many
objects, you might want to think harder about reducing the size of your objects.
An important concept when writing code is 
. Invariants are things which must always
invariants
be true during execution of your whole program or during some portion of it. This will probably
sound very abstract so let me motivate the need to express invariants by implementing a
function, 
, which sets the quantity of propellant in a tank.
propellant!
Dry mass 5 kg, total mass 50 kg and 10 kg of propellant.
Set propellant mass to 100 kg.
What is wrong here? We set the mass of the propellant to be larger than the max total mass of the
tank. That should not be possible. At any time the following tank invariant should be true:
One way to make sure this remains true is to modify the 
 setter method to throw an
propellant!
exception if the inputs are wrong.
8.2 Maintaining invariants in your code
julia> tank = FlexiTank(5, 50, 10) 
FlexiTank(5.0, 50.0, 10.0)
julia> propellant!(tank, 100) 
100
julia> totalmass(tank)
50.0
julia> mass(tank)
105.0
0 <= propellant(t) + drymass(t) <= totalmass(t)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
160

Listing 8.7 Propellant setter maintaining tank invariant
Check if the new propellant amount breaks tank invariant.
Signal a domain error, by throwing an exception.
DomainError is an exception type defined in Julia’s standard library. Domain refers to the set of
legal input values for a function argument. Thus providing an amount larger than the totalmass
is a domain error.
However this is not the only way that we can end up breaking our tank invariant. Here we are
making a tank with 90 kg propellant, while the total mass can only be 50 kg.
Dealing with these problems forces us to learn about how composite objects are created in Julia.
When you define a composite type, Julia creates a special function called a 
 with the
constructor
same name as your type. A constructor is responsible for making an instance (object) of the type
it is associated with. Julia adds a two method to the constructor function which takes the same
number of arguments as you have fields. One method use type annotations for its arguments as
specified for each field in the 
. The other take arguments of 
 type.
struct
Any
However, you can add methods to this constructor function in the same manner as with any other
function. We can add methods which create a full tank if the amount of propellant is not
specified.
Listing 8.8 Create full tanks when amount of propellant is not specified
8.3 Making objects with constructor functions
function propellant!(tank::Tank, amount::Real)
    if 0 <= amount + drymass(tank) <= totalmass(tank) 
        tank.propellant = amount
    else
        msg = "Propellant mass plus dry mass must be less than total mass"
        throw(DomainError(amount, msg)) 
    end
end
julia> t = FlexiTank(5, 50, 90)
FlexiTank(5.0, 50.0, 90.0)
julia> mass(t), totalmass(t)
(95.0, 50.0)
function FlexiTank(drymass::Number, totalmass::Number)
    FlexiTank(drymass, totalmass, totalmass - drymass)
end
MediumTank() = refill!(MediumTank(0))
LargeTank() = refill!(LargeTank(0))
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
161

If we use 
, we can see that a third method has been added to e.g. 
:
methods
FlexiTank
Existing methods defined by Julia.
New method added by us.
Here is an example of using these new methods to create full tanks:
Automatically filled up with 45 kg of propellant.
Filled up with 2050 kg of propellant.
But, what do we do if we don’t want users of our types to set propellant mass independently?
Perhaps we want to reduce the chance of breaking the important tank invariant discussed earlier.
Is there perhaps a way of preventing Julia from making its own constructor methods?
What we have just covered is called outer constructors, when using Julia terminology. The
constructors are defined 
 of the composite type definition. Outer constructors add methods
outside
to the built-in ones.
If instead, we want to replace Julia’s constructor methods with our own, we need to define the
constructor functions inside the 
 definition, like this:
struct
Listing 8.9 Defining an inner constructor for FlexiTank
Notice 
 replaces 
new
FlexiTank
8.4 Difference between outer and inner constructors
julia> methods(FlexiTank)
# 3 methods for type constructor:
[1] FlexiTank(drymass::Float64, totalmass::Float64, propellant::Float64) 
[2] FlexiTank(drymass::Number, totalmass::Number) 
[3] FlexiTank(drymass, totalmass, propellant) 
julia> FlexiTank(5, 50)
FlexiTank(5.0, 50.0, 45.0) 
julia> MediumTank()
MediumTank(2050.0) 
julia> LargeTank()
LargeTank(9250.0)
mutable struct FlexiTank <: Tank
    drymass::Float64
    totalmass::Float64
    propellant::Float64
    function FlexiTank(drymass::Number, totalmass::Number)
        new(drymass, totalmass, totalmass - drymass) 
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
162

Inner constructors introduce us to a special function called 
. It is only available inside an
new
inner constructor, nowhere else. We need it because creating an inner constructor, removes all
constructor methods created by Julia. In other words, we can no longer call any of them.
new is very similar to the default constructor methods provided by Julia with some important
differences: You can supply 
 with zero or more arguments, but never more arguments than
new
the number of fields in your composite type. What happens to the fields you don’t provide a
value for? These fields get a random value.
How do we know that our inner constructor replaces all Julia provided constructor methods? We
can reload our REPL environment and test.
Julia can no longer find a method accepting a third argument.
Check number of methods attached to constructor.
You can now see that 
 only report a single method for the 
 constructor.
methods
FlexiTank
Let us switch gears and talk about the payload we want to send into space and the rocket engines
that will provide the rocket’s propulsion. The payload could be a probe, a satellite, a crew
capsule, or I suppose a Tesla Roadster if you are Elon Musk.
Listing 8.10 Defining rocket payload
This may seem simplistic but remember we are creating models. Models only contain properties
required to answer questions of interest. E.g. an initial model of smart phone may just be a block
of wood, no buttons, screen or color scheme. Why? Because initially the questions you want
answered are:
Is this this shape or size comfortable to carry in my pocket? How much space do we have
available to create a screen and electronics inside? _
8.5 Modeling rocket engines and payloads
julia> t = FlexiTank(5, 50)
FlexiTank(5.0, 50.0, 45.0)
julia> t = FlexiTank(5, 50, 150) 
ERROR: MethodError: no method matching FlexiTank(::Int64, ::Int64, ::Int64)
Closest candidates are:
  FlexiTank(::Number, ::Number)
julia> methods(FlexiTank) 
# 1 method for type constructor:
[1] FlexiTank(drymass::Number, totalmass::Number)
struct Payload
    mass::Float64
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
163

1.  
2.  
3.  
The same applies to designing and building a rocket. Initially we are only interested in mass
budgets. We want to know things such as:
How much propellant do I need?
How big payload can I launch into orbit?
How far can a given rocket go?
To answer such questions we 
 need to include in our model what sort of instruments exist
don’t
on the space probe or what kind of batteries or solar cells it has. Important attributes of a rocket
engine are mass, thrust and Isp (specific impulse). You can think of thrust as how powerful the
engine is and Isp is how fuel efficient it is.
Listing 8.11 Defining a custom rocket engine
Mass of rocket engine in kg.
Thrust exerted by rocket engines. Measured in Newton.
Specific impulse (propellant efficiency).
We can also define types for specific engines with known properties such as the Rutherford
engine used in the Electron rocket and the Merlin engine used in the Falcon 9 rocket.
Listing 8.12 Defining the Rutherford and Merlin rocket engines
Engines are empty structs.
Use accessor functions to get engine properties.
thrust is the force produced by the rocket engine. If we know the total mass of the rocket this
helps us calculate how much the whole rocket accelerates once the rocket engines are fired up.
abstract type Engine end
struct CustomEngine <: Engine
    mass::Float64 
    thrust::Float64 
    Isp::Float64 
end
mass(engine::CustomEngine) = engine.mass
thrust(engine::CustomEngine) = engine.thrust
Isp(engine::CustomEngine) = engine.Isp
struct Rutherford <: Engine end 
struct Merlin <: Engine end 
mass(::Rutherford) = 35.0 
thrust(::Rutherford) = 25000.0 
Isp(::Rutherford) = 311.0 
mass(::Merlin) = 470.0
thrust(::Merlin) = 845e3
Isp(::Merlin) = 282.0
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
164

We get this from Newton’s second law, which states that force  is proportional to mass  times
F
m
acceleration a
However to know how much mass we are pushing at any given time, we need to know how
much propellant the engine consumes each second. Thrust alone cannot tell us that. For that we
need specific impulse (Isp). A high Isp engine is more propellant efficient, meaning it will
consume less propellant for the same amount of thrust.
NOTE
In physics we usually denote impulse with an I. Thus Isp, clarifies that it is 
.
SPecific Impulse
Isp is analogous to gas mileage for a car. However, unlike a car on the road, a rocket in outer
space continues moving even without thrust, so you cannot measure fuel efficiency (or propellant
efficiency) by how far one kg of propellant gets you. Instead, we measure it in terms of how
many seconds a unit of propellant can sustain a force of 1 G (the force of gravity on earth).
This allows us to calculate mass flow (consumption of propellant per second).
m/s² acceleration of gravity on earth
Amount of mass exiting engine is measured in kg/s
We can e.g. use this to calculate the propellant consumed per second in a Falcon 9 rocket. It has
nine Merlin 1D engines, each with a specific impulse of 282 s and thrust of 845 kN.
So we get that a Falcon 9 rocket consumes an estimated 2.7 tons of propellant each second.
g = 9.80665 
function mass_flow(thrust::Number, Isp::Number) 
    thrust / (Isp * g)
end
julia> engine_thrust = 845e3
845000.0
julia> isp = 282
282
julia> thrust = engine_thrust * 9
7.605e6
julia> flow = mass_flow(thrust, isp)
2749.979361594732
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
165

1.  
2.  
Now we have all the pieces to assemble our rocket.
Listing 8.13 Rocket with payload, tank and engine
Let the rocket building start! We will make a rocket resembling the Electron rocket,
manufactured by Rocket Lab
. It can put a payload into low Earth orbit weighing 300 kg. We
27
will make one stage of this rocket with a small tank and a Rutherford engine. The Rutherford
engine, a small rocket engine, used in the first and second stage of the Electron rocket.
For compactness I have instructed the REPL to not print the value of the first three assignments
by tacking on a semicolon . You can try to remove the semicolon to see the difference.
;
If you know a bit about rocketry, you may realize there are multiple problems with the previous
rocket configuration:
The real world Electron rocket has nine Rutherford engines not just one.
Space rockets have multiple stages, which separate as the rocket goes higher. Our rocket
only has a single stage.
Let us fix these problems. An important insight is to realize that a multi-staged rocket is a bit like
a Russian Matryoshka doll
. You could make the payload of rocket another rocket. The payload
28
of this next rocket could be another rocket and so on. The illustration below may give you a
better idea:
8.6 Assemble a simple rocket
8.7 Creating a rocket with multiple stages and engines
struct Rocket
    payload::Payload
    tank::Tank
    engine::Engine
end
julia> payload = Payload(300);
julia> tank = SmallTank();
julia> engine = Rutherford();
julia> rocket = Rocket(payload, tank, engine)
Rocket(Payload(300.0), SmallTank(370.0), Rutherford())
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
166

1.  
2.  
3.  
Figure 8.2 rocket stages
The picture shows a multi-stage rocket where we keep popping off the top to expose the rocket’s
payload. Let me cover each numbered stage:
The whole multi-staged rocket with all parts is called a 
. The first stage is
space vehicle
called the 
.
booster
Pop open the space vehicle, and the 
 rocket is exposed.
second stage
The payload of the second stage is the 
.
third stage
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
167

4.  
5.  
The third stage is protected by a 
, a protective shell for the payload (our model will
fairing
ignore the fairing).
When the launch is finished, the final payload is delivered into space. This payload will
be a 
 such as a satellite, moon lander, or capsule.
space craft
To make it possible to put rockets inside rockets, we will change 
 to an abstract type and
Rocket
define new concrete subtypes:
Listing 8.14 Allow a rocket itself to be payload of another rocket
Make 
 an abstract type.
Rocket
Turn 
 into a subtype of 
.
Payload
Rocket
Rename 
 to 
 for clarity
payload
nextstage
Allow use of old constructor.
But before we build a rocket, we need some more adjustments. The real-life Electron rocket has
nine Rutherford engines in the first stage, what we call the booster. We currently have no way to
add more than one engine. To solve this, we will define a new engine subtype called 
.
Cluster
This new type is designed to model a cluster of many identical engines.
abstract type Rocket end 
struct Payload <: Rocket 
    mass::Float64
end
struct StagedRocket <: Rocket
    nextstage::Rocket 
    tank::Tank
    engine::Engine
end
function Rocket(payload::Rocket, tank::Tank, engine::Engine) 
    StagedRocket(payload, tank, engine)
end
thrust(r::Payload) = 0.0  # no engines
thrust(r::StagedRocket) = thrust(r.engine)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
168

Figure 8.3 A UML diagram of relations between different parts of a rocket
The diagram doesn’t show every type. For instance I could only get space for the MediumTank
and 
 under the abstract 
 type.
FlexiTank
Tank
The diagram shows with the hollow arrows how 
 and 
 are subtypes of the
StagedRocket
Payload
abstract type 
. The filled arrow shows that 
 has a field, 
, which
Rocket
StagedRocket
nextstage
points to another 
 object.
Rocket
Let us look at how we can implement the 
 type. The UML diagram says it is both a
Cluster
subtype of 
 and points to another engine through the 
 field.
Engine
engine
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
169

Listing 8.15 Define a cluster of rocket engines
Number of identical engines in cluster.
You will notice that the specif impulse does not change. Fuel efficiency does not change just
because you add more engines. However adding more engines will increase the mass of the
cluster as well as the total thrust.
NOTE
What about a heterogenous engine cluster?
Could we make an cluster of engines of different types? The challenge is
deciding how to calculate the Isp of a cluster where each engine has a
different specific impulse. We will however make a heterogenous cluster of
engines in chapter 12.
We can use these abstractions to define a function 
, which takes care of depleting
update!
propellant as we simulate our rocket flying. We simulate by performing small time steps .
t
That is a common strategy employed when writing simulations of real-time systems. When
simulating something complex with many parts, it becomes too complicated to perform an
analytical solution by solving a single math equation. Computer games are made like this as
well. Every object moving around in a game will have an 
 function akin to the one
update!
shown below.
Listing 8.16 Update propellant mass after t time has elapsed
I want to make a three staged Electron rocket. The third stage is tiny and thus only needs a very
tiny engine. The company developing the Electron rocket is making a tiny engine named Curie
for this purpose. The full specifications for this engine is not yet known, so we will define this
engine based on some guesswork:
struct Cluster <: Engine
    engine::Engine
    count::Int 
end
Isp(cl::Cluster) = Isp(cl.engine)
mass(cl::Cluster) = mass(cl.engine) * cl.count
thrust(cl::Cluster) = thrust(cl.engine) * cl.count
function update!(r::StagedRocket, t::Number, t::Number)
    mflow = mass_flow(thrust(r), Isp(r.engine))
    consume!(r.tank, mflow * t)
end
# Payload has no tanks with propellant to consume
update!(r::Payload, t::Number, t::Number) = nothing
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
170

Listing 8.17 Define a tiny engine for third stage
The only known specification.
Mass and Isp had to be guessed.
We now have enough functionality to define an Electron rocket composed of multiple stages.
Later, when performing physics calculations, it is helpful to abstract away how a property, such
as mass, is determined for a rocket or part of a rocket.
Listing 8.18 Calculate total mass of a staged rocket
You can see the benefits of abstraction of mass in how 
 is defined.
mass(r::StagedRocket)
Implementing this function we don’t have to concern ourselves with details of the payload (
). It could be a payload or another staged rocket with 20 stages. You don’t have to
nextstage
know. The differences is abstracted away.
Likewise we don’t have to concern ourselves with whether we are getting the mass of a single
engine or an engine cluster. Imagine we had implemented this function 
 creating the 
before
 type. We would not need to change this implementation, because as long as 
 is
Cluster
Cluster
struct Curie <: Engine end
mass(::Curie) = 8.0 
thrust(::Curie) = 120.0 
Isp(::Curie) = 317.0 
julia> payload = Payload(300)
Payload(300.0)
julia> thirdstage = Rocket(payload, SmallTank(), Curie())
StagedRocket(Payload(300.0), SmallTank(370.0), Curie())
julia> secondstage = Rocket(thirdstage, MediumTank(), Rutherford())
StagedRocket(StagedRocket(Payload(300.0),
                          SmallTank(370.0),
                          Curie()),
             MediumTank(2050.0),
             Rutherford())
julia> booster = Rocket(secondstage, LargeTank(), Cluster(Rutherford(), 9))
StagedRocket(StagedRocket(StagedRocket(
                            Payload(300.0),
                            SmallTank(370.0),
                            Curie()),
                         MediumTank(2050.0),
                         Rutherford()),
             LargeTank(9250.0),
             Cluster(Rutherford(), 9))
mass(payload::Payload) = payload.mass
function mass(r::StagedRocket)
    mass(r.nextstage) + mass(r.tank) + mass(r.engine)
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
171

of type 
 and has implemented 
, everything works.
Engine
mass
The 
 function allows us to keep track of propellant consumption. When called it gives us
update!
the remaining propellant left. When this quantity has reached zero we know our rocket cannot fly
any higher.
We will implement a new function 
, which figures out the altitude our rocket reaches
launch!
before it runs out of propellant, as well as how much time has passed when that occurs.
The rocket is pushed up with a certain force determined by the thrust of the engines . However
T
this force has to work against the forces of gravity. Gravity exerts force on a rocket proportional
to the mass  of the rocket and the acceleration  of gravity on Earth.
m
g
From this we can determine the acceleration of the rocket when it is launched.
Remember from when discussing 
 that we are simulating the launch as a set of small
update!
time increments 
. For one small time increment we can find how much the velocity changes for
Δt
that small time increment.
These observations are the basis for how we implement the 
 function. We add up
launch!
changes in velocity, 
 over many small time increments. For every increment we assume
Δv
velocity is constant and use that to calculate distance traveled 
. Adding up all the
Δh = v × Δt
distances traveled across every little increment we get the total distance traveled .h
This calculation can be visualized with a plot. Every bar is equal to 
, because each bar is 
Δh
Δt
wide and  tall. Thus adding up the area of all the bars is equal to the distance traveled. The
v
smaller we make the increments 
, the more accurate the calculation would become.
Δt
8.8 Launching a rocket into space
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
172

In mathematical terms we are performing an approximation of the integral of the velocity. The
following code is an implementation of these ideas.
NOTE
The code uses a cutoff point of 1000 seconds. The rocket may not have
consumed all fuel within that time in case you use large tanks. You could use
a while-loop instead but then you risk an infinite loop.
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
173

Listing 8.19 Simulate a rocket launch and determine max altitude of rocket
We stop the simulation at 1000 seconds.
Mass changes because propellant is consumed.
Return time spent and distance traveled.
Use velocity from previous time increment.
I put the 
 function into a file called 
, but you can just paste it into the
launch!
simulate.jl
REPL. We can then construct a rocket and launch it:
From the output we can see that our rocket spent 45 seconds to get to an altitude of around 31
kilometers. For real rockets this will be different because they have to deal with air resistance.
We basically launched this rocket on an Earth without atmosphere.
We can see that all the fuel in the tank has been spent.
As an exercise, you can try launching the rocket with different payload sizes and different size of
tanks. Do you notice that larger tanks don’t always get you further? Why is that?
Larger tanks don’t always work because they case the gravitational pull on your rocket to
function launch!(rocket::Rocket, t::Real)
    g = 9.80665  # acceleration caused by gravity
    v = 0.0      # velocity
    h = 0.0      # altitude (height)
    for t in 0:t:1000 
        m = mass(rocket) 
        F = thrust(rocket) - m*g
        remaining = update!(rocket, t, t)
        # Any propellant and thrust left?
        if remaining == 0 || F <= 0
            return (t, h) 
        end
        h += v*t 
        a = F/m
        v += a*t
    end
end
julia> engine = Rutherford();
julia> tank = SmallTank();
julia> payload = Payload(300);
julia> rocket = Rocket(payload, tank, engine)
julia> launch!(rocket, 0.5)
(45.0, 31117.8036364191)
julia> tank
SmallTank(0.0)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
174

increase. Thus the force of gravity may end up stronger than the force of thrust from your rocket
engine.
This simulated launch has a number of limitations. It is not just that we don’t consider air
resistance but it is also unable to deal with staged rockets.
You can define your own custom constructors, to make sure objects are initialized with
valid values.
An 
 replaces the default constructor provided by Julia. 
inner constructor
outer
 are just convenient constructors defined outside the composite type
constructors
definition.
We define an abstract type with e.g. 
. Abstract types
abstract type Payload end
cannot have fields, and you cannot make objects of them (you cannot instantiate an
abstract type).
Both abstract and concrete types can be a subtype of another abstract type. However, no
concrete type can be a subtype of another concrete type. 
 is the subtype operator.
<:
Using abstract types and combining them with multiple-dispatch, we can abstract away
differences between related types, so they can be used interchangeably.
8.9 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
175

9
This chapter covers
Julia and other mainstream programming languages handle arithmetic involving different
number types so effortlessly, that most of us likely don’t pay much attention to this fact.
Numbers in expression converted to floating-point.
All integers converted to Int128
In reality, doing this involves quite a lot of complexity. Under the hood, most programming
languages have defined a set of 
, which says what should be done if you combine
promotion rules
numbers of different types. Promotion rules make sure all the numbers are converted to a
sensible common number type which can be used in the final calculation. Don’t confuse number
conversion with parsing text strings to produce numbers.
You might ask why you should care about these concepts? However, mastering Julia’s
promotion and conversion system opens the door to a deeper insight into how numbers work in
Julia. That will make you capable of doing a wide variety of tasks, such as:
Conversion and promotion
Conversion of one related type to another
How promotion finds least common denominator among related types in an expression
Exploring the Julia standard library using the 
 macro
@edit
julia> 3 + 4.2 
7.2
julia> UInt8(5) + Int128(3e6) 
3000005
julia> 1//4 + 0.25
0.5
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
176

Defining custom number types
Defining a physical units system and perform conversions between different units
The main programming example in this chapter will do just that: Define a unit system for
different types of angles such as degrees and radians. We will then demonstrate how the Julia
promotion and conversion system can combine different angle types in the same expression.
But why create numbers with units? Why not let numbers be numbers? Because a lot of mistakes
happen in software development because feet, meters, and other units get mixed up. By using
numbers with units you can reduce the number of bugs in your software.
In many cases in Julia it doesn’t matter what order the arguments are. For instance if we want to
check if two geometric objects overlap then 
 should give the
overlap(circle, triangle)
same result as 
. We could imagine a similar situation when
overlap(triangle, circle)
simulating battle between different types of warriors in a computer game. The Julia promotion
system shows an elegant technique for handling such cases without implementing the same
algorithms twice.
Inside a microprocessor, mathematical operations are always performed between identical types
of numbers. A microprocessor does not have an instruction to add an integer to a floating-point
number. Microprocessors always perform arithmetic operations between identical number types.
Thus when dealing with expressions composed of different numbers types, all higher-level
programming languages have to convert all arguments in the expression to the same number
type. But what should this common number type be? Figuring out this common type is what
promotion is all about.
We express it as promoting arguments of mathematical operators to a common type.
In most mainstream languages, the mechanisms and rules governing number promotion are
hardwired into the language and detailed in the specifications of the language.
NOTE
What about type coercion?
You will see the term 
 used in other programming languages.
type coercion
Coercion is implicit conversion carried out by the compiler. Julia’s compiler
does not do that, and thus we don’t talk about 
 in Julia.
coercion
Julia takes a radically different approach. In Julia, numbers are first-class objects. They are not
special types with unique hardwired rules. Julia promotion rules are defined in the standard
library, not in the internals of the Julia just-in-time compiler. That has the benefit that you, as a
9.1 Exploring Julia’s number promotion system
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
177

developer, can extend the conversion and promotion system yourself. You can add new number
types and add new rules.
But, doesn’t this risk that developers mess up the number type system? No, because you extend
the existing system, you don’t 
 it.
modify
Promotion rules are handled by plain old Julia functions. Hooking into the existing system is
simply a matter of adding your own methods to existing functions. We can explore the Julia
source code for promotion using the 
 macro.
@edit
SIDEBAR
JULIA ENVIRONMENT VARIABLE SETUP
For the 
 macro to work you need to have set the 
@edit
JULIA_EDITOR
environment variable. This will depend on your operating system. E.g. I use
the fish shell. It requires modifying the startup configuration 
, by adding the following line:
$HOME/.config/fish/config.fish
If you use the bash shell you would modify the 
 file instead.
$HOME/.profile
Both examples work on macOS and Linux. Windows users would use a GUI
dialog to modify the 
 environment variable. Alternatively
JULIA_EDITOR
Windows users can install a Unix shell.
Below we are adding an integer and floating point number. By prefixing with the 
 macro
@edit
Julia jumps to the definition of the function being called to handle this expression, allowing you
to have a look at the source code.
SIDEBAR
EVERYTHING IS A FUNCTION!
It is worth being aware that almost everything in Julia is a function call. When
you write 
, that is syntactic sugar for calling a function named  like this
3 + 5
+
. Every function using a symbol such as , ,  etc supports being
+(3, 5)
+ - *
used in prefix form.
The following code shows how every arithmetic operation on some 
 in Julia first calls 
Number
 before performing the actual arithmetic operation.
promote
set -x JULIA_EDITOR mate
export JULIA_EDITOR=mate
julia> @edit 2 + 3.5
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
178

Listing 9.1 Definition of arithmetic operations on numbers in Julia standard library
The 
 is called the "splat" operator. You use it to turn arrays or tuples into function arguments.
...
So 
 is the same as 
. We use it because we want to turn the
foo([4, 5, 8]…)
foo(4, 5, 8)
tuple returned by 
 into arguments to the various arithmetic functions , ,  etc.
promote
+ - *
We can perform some experiments in the Julia REPL to better understand how the promote
function works.
This shows that 
 returns a tuple of numbers converted to the most appropriate common
promote
type. However, for everyday programming you can use 
 instead to figure out what an
typeof
expression will get promoted to.
Number conversion means converting from one type of number to another. This should not be
confused with parsing. For instance a text string can be parsed to produce a number, but a string
and a number are not related types, hence you should not call it a conversion.
The recommended and simplest way of doing conversion in Julia is to use the constructor of the
type you want to convert to. So if you have a value  you want to convert to some type , then
x
T
just write 
. Let me give some examples:
T(x)
9.2 Understanding number conversion
+(x::Number, y::Number) = +(promote(x,y)...)
*(x::Number, y::Number) = *(promote(x,y)...)
-(x::Number, y::Number) = -(promote(x,y)...)
/(x::Number, y::Number) = /(promote(x,y)...)
julia> promote(2, 3.5)
(2.0, 3.5)
julia> typeof(1//2), typeof(42.5), typeof(false), typeof(0x5)
(Rational{Int64}, Float64, Bool, UInt8)
julia> values = promote(1//2, 42.5, false, 0x5)
(0.5, 42.5, 0.0, 5.0)
julia> map(typeof, values)
(Float64, Float64, Float64, Float64)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
179

Keep in mind that a conversion is not always possible to perform:
An 8-bit number cannot hold values larger than 255 (
), and integers cannot represent
2 -1
decimals.
In many cases conversions are done implicitly by Julia. Julia use the 
 function to
convert
achieve this, not the constructor. However we are free to call 
 explicitly ourselves. Here
convert
is a demonstration:
Convert floating-point number 5.0 to integer 5.
Convert integer 5 to floating-point number 5.0.
Notice the first argument in these function calls: 
, 
 etc. These are type objects.
Int64 Float64
Types are first class objects in Julia, meaning they can be handled like any other object. You can
pass them around, store them and define methods that operate on them. Type objects even have a
type. The type of 
 would be 
 and for 
 it is 
.
Int64
Type{Int64}
Float64
Type{Float64}
8
julia> x = Int8(32)
32
julia> typeof(x)
Int8
julia> Int8(4.0)
4
julia> Float64(1//2)
0.5
julia> Float32(24)
24.0f0
julia> Int8(1000)
ERROR: InexactError: trunc(Int8, 1000)
julia> Int64(4.5)
ERROR: InexactError: Int64(4.5)
julia> convert(Int64, 5.0) 
5
julia> convert(Float64, 5) 
5.0
julia> convert(UInt8, 4.0)
0x04
julia>  1//4 + 1//4
1//2
julia>  convert(Float32, 1//4 + 1//4)
0.5f0
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
180

Number 3 is of type Int64
Type Int64 is of type Type{Int64}
Type Int64 is not of type Type{String}
You can think of this as feeding 
 a type parameter  gives back the type of . Don’t worry if
Type
T
T
this does not make sense. It is a complex topic and we explain this topic more thoroughly in the
next chapter.
The 
 function is called implicitly when performing various types of assignments:
convert
Assigning to an array element
Setting the value of the field of a composite type
Assigning to local variables with a type annotation
Returning from a function with a type annotation
Let us look at some examples demonstrating implicit conversion.
We assign an 
 value to an array element defined to be 
. This causes 
Int64
Int8
 to be called.
convert(Int8, x)
Setting the field of a composite type defined with 
:
struct
julia> 3 isa Int64 
true
julia> Int64 isa Type{Int64} 
true
julia> "hi" isa String
true
julia> String isa Type{String}
true
julia> Int64 isa Type{String} 
false
julia> values = Int8[3, 5]
2-element Vector{Int8}:
 3
 5
julia> typeof(values[2])
Int8
julia> x = 42
42
julia> typeof(x)
Int64
julia> values[2] = x 
42
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
181

Causes 
 to be called
convert(Float64, Int8(10))
Here we add a type annotation to a function to make sure the return value is of a certain type. If it
is not, a conversion is attempted with 
.
convert
Next we will get more into the details of how conversion and promotion is done using a larger
code example.
A lot of calculations within science can easily go wrong if we mix up units. For instance in the
petroleum industry, mixing feet and meters is easy because coordinates of an oil well is usually
given in meters while the depth of the well is given in feet.
A famous example is the 
], a robotic space probe launched by NASA,
[Mars Climate Orbiter
which was lost due to NASA and Lockheed using different units of measure. NASA was using
metric units and Lockheed used US customary units, such as feet and pound. Thus there is an
advantage in designing code where one does not accidentally mixup units.
In this example we will demonstrate working with different units for angles. In mathematics
angles are usually given as radians, while people navigating using maps will tend to use degrees.
When using degrees we split up the circle in 360 degrees. One degree is thus 1/360th of the
circumference of that circle.
With radians in contrast we deal with how many times the radius of a circle is duplicated along
the circumference to get that angle. So 1 radian is the angle you get when you mark off a
distance along the circumference equal to the radius of the circle.
9.3 Defining custom units for angles
julia> mutable struct Point
           x::Float64
           y::Float64
       end
julia> p = Point(3.5, 6.8)
Point(3.5, 6.8)
julia> p.x = Int8(10) 
10
julia> foo(x::Int64) :: UInt8 = 2x
foo (generic function with 1 method)
julia> y = foo(42)
0x54
julia> typeof(y)
UInt8
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
182

Figure 9.1 Definition of a radian
Degrees in contrast are more strongly tied to navigation, in particular celestial navigation. Each
day the earth moves about 1 degree around the sun, since the year is made up of 365 days. An
angle is further divided into 60 arcminutes, and an arcminute is divided into 60 arcseconds.
Figure 9.2 How degrees, arcminutes and arcseconds are subdivided
Actually you can work with both metric degrees and degrees-minutes-seconds (DMS), but we
are working with DMS here to keep things interesting.
In this code example we are going to implement the following functionality:
Radian and 
 types to represent different types of angle units
DMS
Constructors to make it easier to construct angle objects given degrees, arcminutes and
arcseconds
Operations on angle types such as addition and subtraction
Accessors to extract degrees, minutes and seconds
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
183

Extend 
 function to create pretty display of different angle units
show
Extend 
 function to support conversion from one angle unit to another
convert
Override 
 and 
 functions to only work with angle units
sin
cos
Couple together some clever tricks to make pretty number literals for angle units
Extend 
 function so different angle units can be used in the same
promotion_rule
expression
Let us start by implementing the 
 and 
 angle types.
Radian
DMS
Listing 9.2 Define Radians and Degrees as subtype of abstract Angle type
Similar to our rocket example, we have defined an abstract type 
, which all our concrete
Angle
angle units are subtypes of. The benefits of this will become clear later.
That degrees-minutes-seconds are stored as seconds should be regarded as an implementation
detail and not exposed to the user. Hence users should not use that constructor directly. Instead
we will define more natural constructors:
Listing 9.3 Angle constructors for degrees, minutes and seconds
To be able to actually run these constructors we need to be able to add together 
 numbers.
DMS
The code snippet 
 basically does a 
Degree(deg) + Minute(min)
DMS(deg, 0, 0) + DMS(0,
. However  operator has not been defined for 
 types. Nor have we defined them for
min, 0)
+
DMS
radians so lets do both:
abstract type Angle end
struct Radian <: Angle
    radians::Float64
end
# Degrees, Minutes, Seconds (DMS)
struct DMS <: Angle
    seconds::Int
end
9.3.1 Defining angle constructors
Degree(degrees::Integer) = Minute(degrees * 60)
Degree(deg::Integer, min::Integer) = Degree(deg) + Minute(min)
function Degree(deg::Integer, min::Integer, secs::Integer)
    Degree(deg, min) + Second(secs)
end
function Minute(minutes::Integer)
    DMS(minutes * 60)
end
function Second(seconds::Integer)
    DMS(seconds)
end
9.3.2 Defining arithmetic operations on angles
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
184

Listing 9.4 Arithmetic for DMS and Radian angles
Let me clarify how this works. As discussed in chapter 7 section 3.3, defining a method in Julia
will automatically create a function if no corresponding function already exists. E.g. if the +
function is not imported, Julia will not know that it already exist when you define  
.
+ methods
Thus Julia will create an entirely new  function and attach your angle specific methods to it.
+
IMPORTANT
The Main and Base modules
All Julia types and functions belong to a module. You can think of a module as
a namespace or library. Most of the functionality which comes bundled with
Julia is in the module called 
. Previously you have used the 
Base
Statistics
module. Functions and types which you have not explicitly made part of a
named module become part of the 
 module. Every function and type you
Main
create in the Julia REPL is part of the 
 module.
Main
If you then try to evaluate 
, Julia will attempt a lookup of matching methods on this newly
3 + 4
defined  function. But it has no methods dealing with regular numbers, only for angles. Thus if
+
you had forgotten to write 
, you would have gotten this error message:
import Base: +
Essentially you end up shadowing the  function defined in 
 and its attached methods. By
+
Base
doing import, we are essentially telling Julia that we want to add methods to a function defined
in an existing module, such as 
. If you don’t do that that then your newly defined  function
Base
+
will become part of the 
 module. Everything defined in the REPL which has not been
Main
imported from somewhere else is made part of the 
 module.
Main
import Base: -, +
+(::DMS, ::DMS) = DMS(.seconds + .seconds)
-(::DMS, ::DMS) = DMS(.seconds - .seconds)
+(::Radian, ::Radian) = Radian(.radians + .radians)
-(::Radian, ::Radian) = Radian(.radians - .radians)
julia> 3 + 4
ERROR: MethodError: no method matching +(::Int64, ::Int64)
You may have intended to import Base.+
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
185

Listing 9.5 Degree and minute accessors for DMS objects
We can use these functions to provide a custom display of these angles on the Julia REPL. To
write that the angle is 90 degrees, 30 arcminutes and 45 arcseconds we would use the notation 
.
90° 30' 45''
If you use the constructors now, the display you get out of the box isn’t very good. It exposes the
internal representation of DMS degrees as being made up of arcseconds.
Figure 9.3 Shadowing of functions which occur when you don’t import functions before extending them.
Figure 9.3 is an illustration of the shadowing problem. Function list A is what you get when you 
don’t import + and - from Base before adding methods to these functions. The result is two 
separate method tables for each operator, one for Base and another one for Main. In the B 
example we have imported + and - and thus our methods get added to the method table defined 
by Base, rather than creating a new method table in the Main module.
9.3.3 Defining accessors to extract degrees, minutes and seconds
Given an angle in DMS, we want to be able to know the degree, minute and seconds part.
function degrees(dms::DMS)
    minutes = dms.seconds ÷ 60
    minutes ÷ 60
end
function minutes(dms::DMS)
    minutes = dms.seconds ÷ 60
    minutes % 60
end
seconds(dms::DMS) = dms.seconds % 60
9.3.4 Displaying degrees-minutes-seconds angles
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
186

We can define an alternative view by adding a method to the Julia 
 function. The Julia
show
REPL environment uses the 
 to display data of some specific type to the
show(io::IO, data)
user. Remember in Julia you can define methods to work on generic abstract types. However you
can add methods dealing with more concrete types. That is what we want to do.
Listing 9.6 Define string representation of Radian and DMS objects
We will look more closely at 
 and 
 objects in chapter 11. But for now, this gives a nice
show
IO
way of looking at DMS angles.
Now that we got the basics in place, we want to be able to do something useful with these angles.
You would want to use them with functions such as 
 and 
 but these just take plain
sin
cos
numbers which are radians. We need to define conversions so that DMS angles can be turned
into radians.
julia>  = Degree(90, 30, 45)
DMS(325845)
julia> degrees()
90
julia> minutes()
30
julia> seconds()
45
julia>  = Degree(90, 30) + Degree(90, 30)
DMS(651600)
julia> degrees()
181
julia> minutes()
0
import Base: show
function show(io::IO, dms::DMS)
   print(io, degrees(dms), "° ", minutes(dms), "' ", seconds(dms), "''")
end
function show(io::IO, rad::Radian)
   print(io, rad.radians, "rad")
end
julia>  = Degree(90, 30, 45)
90° 30' 45''
julia>  = Degree(90, 30) + Degree(90, 30)
181° 0' 0''
9.3.5 Defining type conversions
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
187

Listing 9.7 Definining methods for direct and indirect type conversion
Convert 
 value to 
 value.
DMS
Radian
Convert 
 value to 
 value.
Radian
DMS
This contains a number of new things we need to discuss more in detail to clarify. Notice that the
 method definitions don’t specify the name of the argument, only its type. This is similar
convert
to our rocket example where we defined the mass of a Rutherford engines as:
You could have written 
, but what would the point be? The 
engine::Rutherford
Rutherford
composite type did not have any fields you could access. Likewise 
 and 
Type{Radian}
 don’t have any fields we are interested in accessing in the 
 definition.
Type{DMS}
convert
With these conversions in place we can implement versions of 
 and 
 which take numbers
sin
cos
with units as arguments.
Listing 9.8 Override standard sin and cos functions to use DMS and Radian
In this case we are not importing 
 and 
 before creating the methods. The reason is
sin
base
because we actually want to shadow the "real" 
 and 
 functions since we don’t want
sin
base
people to accidentally call the these functions we plain numbers. We want them use radians or
degrees explicitly.
import Base: convert
Radian(dms::DMS) = Radian(deg2rad(dms.seconds/3600))
Degree(rad::Radian) = DMS(floor(Int, rad2deg(rad.radians) * 3600))
convert(::Type{Radian},  dms::DMS)    = Radian(dms) 
convert(::Type{DMS},     rad::Radian) = DMS(rad) 
mass(::Rutherford) = 35
sin(rad::Radian) = Base.sin(rad.radians)
cos(rad::Radian) = Base.cos(rad.radians)
sin(dms::DMS) = sin(Radian(dms))
cos(dms::DMS) = cos(Radian(dms))
julia> sin(/2)
ERROR: MethodError: no method matching sin(::Float64)
You may have intended to import Base.sin
julia> sin(90)
ERROR: MethodError: no method matching sin(::Int64)
You may have intended to import Base.sin
julia> sin(Degree(90))
1.0
julia> sin(Radian(/2))
1.0
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
188

Now you cannot accidentally use an angle as input to a trigonometric function without having
specified whether it is given in radians or degrees.
This is nice, but it would look a lot better if you could write 
 instead of 
sin(90°)
 and 
 instead of 
.
sin(Degree(90))
sin(1.5rad)
sin(Radian(1.5))
In fact we can achieve this. Observe that Julia interprets 
 as 
. Thus be defining
1.5rad
1.5*rad
multiplication of regular scalars with units of degrees or radians we have magically solved the
problem.
Listing 9.9 Operations and constants to allow pretty angle literals
The last two lines show the secret sauce. It means 
 is read by Julia as 
90°
90 * Degree(1)
which when computed will result in 
.
Degree(90)
The simple but labour intensive way of adding support for doing arithmetic with different angle
units would mean defining lots of functions with all possible combinations. Imagine we had
another angle type, 
. It would quickly cause a combinatorial explosion:
MetricDegree
9.3.6 Making pretty literals
import Base: *, /
*(coeff::Number, dms::DMS) = DMS(coeff * dms.seconds)
*(dms::DMS, coeff::Number) = coeff * dms
/(dms::DMS, denom::Number) = DMS(dms.seconds/denom)
*(coeff::Number, rad::Radian) = Radian(coeff * rad.radians)
*(rad::Radian, coeff::Number) = coeff * rad
/(rad::Radian, denom::Number) = Radian(rad.radians/denom)
const ° = Degree(1)
const rad = Radian(1)
julia> sin(90°)
1.0
julia> sin(1.5rad)
0.9974949866040544
julia> cos(30°)
0.8660254037844387
julia> cos(90°/3)
0.8660254037844387
julia> sin(3rad/2)
0.9974949866040544
9.3.7 Type promotions
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
189

Listing 9.10 Combinatorial explosion of arithmetic operations
I have not even shown all the combinations. The point I am making is that you get a lot of
combinations which are hard to manage. Instead the solution is to define generic functions for
different units as follows:
Listing 9.11 Simplify arithmetic operations by utilizing promotion
The only remaining problem is that we have not told 
 how to promote angle types. It
promote
only knows about 
 types. A first guess of how to add the temperature type would be to
Number
add another 
 method, but that is not how it works. Instead 
 does its job by
promote
promote
calling a function called 
. We need to register our types by defining 
promote_rule
 methods for 
 types. This will look like:
promote_rule
our
Listing 9.12 Defining type promotion of Radian and DMS
These methods are unusual, as all the arguments are type objects. Nor have we given a name to
any of the arguments, because the type objects are not used for anything but getting multiple
dispatch to select the correct method of the 
 function.
promote_rule
The 
 function takes two type objects as arguments and returns another type
promote_rule
object:
We can define the promotion rule as: Given two different types, what type should they all be
promoted to? Now we have put all the pieces in place. We have plugged into the Julia convert
and promote machinery, by implementing methods for the 
 and 
convert
promote_rule
functions.
+(::DMS, ::Radian)  = Radian() + 
+(::MetricDegree, ::DMS)  =  + MetricDegree()
+(::Radian, ::MetricDegree)  =  + Radian()
+(::Radian, ::DMS)  =  + Radian()
+(::Angle, ::Angle) = +(promote(, )...)
-(::Angle, ::Angle) = -(promote(, )...)
import Base: promote_rule
promote_rule(::Type{Radian}, ::Type{DMS}) = Radian
julia> promote_rule(Int16, UInt8)
Int16
julia> promote_rule(Float64, UInt8)
Float64
julia> promote_rule(Radian, DMS)
Radian
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
190

1.  
2.  
3.  
This example gives a hint of the advantages of using a multiple-dispatch language such as Julia.
Implementing this behavior using object-oriented programming is harder and gets increasingly
hard as you add more types into the mix. If you defined each angle as a class, you would have to
have several methods for every operation, one for each type.
And there are more practical problems with the object-oriented approach. Should you ever need
to add another angle unit, this will require:
Adding another class with 4 methods for each operator.
Modify every other angle class, including the base class 
, by adding a version of
Angle
each operator handling the new angle unit.
Add another constructor in each class to handle the new angle unit (to allow conversion).
This obviously does not scale, and it breaks the 
 in object-oriented
open-close principle
programming:
Open for extension, closed for modification.
If angle units were provided as a library you could not extend it with other units, without
modifying the library itself. That is obviously impractical.
Julia elegantly solves this by 
 making functions a part of the types. Thus you can add new
not
constructor functions to a type without modifying the type definition itself. Adding 
 and 
convert
 functions does not require modification of the library providing the types which
promote_rule
you seek to define promotion rules and conversion for.
julia> sin(90° + 3.14rad/2)
0.0007963267107331024
julia> cos(90° + 3.14rad/2)
-0.9999996829318346
julia> 45° + 45°
90° 0' 0''
julia> Radian(45° + 45°)
1.5707963267948966rad
julia> 45° + 3.14rad/4
1.5703981633974484rad
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
191

Type promotion is handled in Julia by defining promotion rules. This is done by adding
methods to the 
 function
promote_rule
Conversion of a value  to a type  is accomplished with two different approaches 
x
T
T(x)
and 
. The latter is used when dealing with implicit conversions
convert(T, x)
An object  can have a type , but what is the type of the type? 
 is the type of a
x
T
Type{T}
type object . This knowledge helps you to add methods to the 
 function
T
convert
correctly
By defining your own promotion rules and conversion functions you can add new
number types to Julia or add units such as degrees, meters, feet, celsius or fahrenheit to
Julia numbers. Units help make numerical code more robust. New number types can help
improve accuracy in calculations, reduce memory requirements or improve performance
To add methods to a function defined in another module you need to explicitly import
those functions from the module. If you don’t, you will end up shadowing those
functions, which will usually not be what you want
9.4 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
192

10
This chapter covers
An important thing to deal with in any programming language is to represent the absence of a
value. For a long time, most mainstream programming languages such as C/C++, Java, C#,
Python, and Ruby would have a value called 
 or 
 which is what a variable would contain
null
nil
if it did not have any value. More accurately phrased: 
 or 
 indicates that a variable is not
null
nil
bound to a concrete object.
When would this be useful? Let us use Julia’s 
 function as an example. It locates the
findfirst
first occurrence of a substring.
Substring 
 found.
"hello"
Substring 
 not found.
"foo"
But how do we indicate that a substring cannot be found? Languages such as Java, C#, or Python
would use the 
 or 
 keywords to indicate this. However, it is not without reason its
null
nil
inventor, British computer scientist Tony Hoare, called the null pointer his billion-dollar mistake.
It makes it difficult to write safe code because any variable could be null at any given time. In
Representing unknown values
Understanding how 
 are used
undefined values
Representing the absence of a value with the 
 type
Nothing
Dealing with values that exist but which are unknown using the 
 type
Missing
julia> findfirst("hello", "hello world") 
1:5
julia> findfirst("foo", "hello world") 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
193

programs written using languages supporting null, we need a lot of boilerplate code performing
null checks. That is because it is unsafe to perform operations on null objects.
For this reason, modern languages have tended to avoid having null objects or pointers. Julia
does not have a generic null object or pointer. Instead, Julia has a variety of types representing
unknown or absent values. This chapter will teach you more about these different types: How to
use them and when to use them.
The closest thing to null, which Julia has, is the 
 object of type 
. It is a simple
nothing
Nothing
concrete type defined in Julia as:
Listing 10.1 Nothing type and nothing constant as defined by Julia
The 
 object is an instance of the type 
. However, every instance of 
 is
nothing
Nothing
Nothing
the same object. You can test that yourself in the REPL:
However, there is nothing magical going on here. When you call the constructor of a composite
type with zero fields, you always get the same object returned. To state this in more formal
terms: For a type  with no fields, every instance  of type  is the same object. This example
T
t
T
should help clarify:
Instances of different empty composite types are however considered different. Hence Empy()
does not return the same object as 
.
Nothing()
10.1 The Nothing object
struct Nothing
    # look, no fields
end
const nothing = Nothing()
julia> none = Nothing()
julia> none == nothing
true
julia> Nothing() == Nothing()
true
julia> struct Empty end
julia> empty = Empty()
Empty()
julia> none = Empty()
Empty()
julia> empty == none
true
julia> Empty() == Empty()
true
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
194

Empty composite types make it easy to make special-purpose objects in Julia, which you want to
assign special meaning. By convention, Julia uses 
 to indicate that something could not
nothing
be found or does not exist.
Our staged rocket is similar to a more generic data structure called a linked-list. Just like with our
rocket example it can often be useful to chain together multiple objects. We could use this to
represent a train made up of multiple wagons holding some cargo. The definition below will not
work. Try contemplating why?
Listing 10.2 Defining an infinite train
Tons of cargo in train wagon.
Next wagon linked to this one.
Caclulate total cargo in all wagons
There is no way of of building a train made out of these wagons with the definition we have
given. Let me clarify with an example:
There is no way to end this chain of wagons. Every 
 constructor requires a wagon object as
Wagon
its second argument. To illustrate an infinite chain of wagons I inserted 
 in the code example.
….
10.2 Using Nothing in data structures
julia> Empty() == Nothing()
false
julia> empty = Empty()
Empty()
julia> empty == nothing
false
julia> findfirst("four", "one two three four")
15:18
julia> findfirst("four", "one two three")
julia> typeof(ans)
Nothing
julia> findfirst("four", "one two three") == nothing
true
struct Wagon
     cargo::Int 
     next::Wagon 
end
cargo(w::Wagon) = w.cargo + cargo(w.next) 
train = Wagon(3, Wagon(4, Wagon(1, Wagon(2, ....))))
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
195

The 
 field always has to be a 
. But what if we made 
 an abstract type instead?
next
Wagon
Wagon
That is one possible solution which we already employed with staged rockets.
Remember not every 
 subtype had a next stage field. However in this chapter I will
Rocket
introduce a more generic solution to this problem utilizing 
. This will just cover
parameteric types
the basics, since chapter 18 is completely devoted to parametric types.
IMPORTANT
Why you must understand parametric types
Parametric types may look like an add-on feature only of interest to advanced
Julia programmers. However, I have deliberately minimized usage of
parametric types in our code examples. Real-world Julia code use parametric
types extensively. Parametric types are crucial to type correctness,
performance and in reducing code duplication.
You have already been exposed to parametric types, when we defined ranges and pairs. If P{T}
is a parametric type , then  is the type parameter. I know this sounds very abstract, but it will
P
T
become a lot clearer with some examples:
Parametric type 
 with type parameter 
.
Vector
Char
Parametric type 
 with type parameter 
.
UnitRange
Int64
Parametric type 
 with type parameter 
.
Rational
UInt8
You can think of 
 as a template to make an actual type. To make an actual concrete
Vector
vector we need to know the type of the elements in the vector. In the first example the type
parameter is 
, because each element is a character. For 
, the type parameter
Char
UnitRange
represents the type of the start and the end of the range. While for 
 the type parameter
Rational
specifies the type of the nominator and denominator in a fraction.
Type parameters are to parametric types what values are to functions. You input a value to a
function and get a value out.
10.2.1 What is a parametric type?
julia> ['A', 'B', 'D']
3-element Vector{Char}: 
 'A'
 'B'
 'D'
julia> typeof(3:4)
UnitRange{Int64} 
julia> typeof(0x3//0x4)
Rational{UInt8} 
y = f(x)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
196

We input  to function  and get value  out. We can make the same analogy for parametric
x
f
y
types.
We input the type  to  and get the type  out. We can demonstrate this with some actual Julia
T
P
S
types:
Create a range type called 
.
IntRange
Make a range type based on floating-point numbers.
Construct a range using the custom range type.
In this example you can see how types can be treated much like objects. We make new type
objects and bind them to variables 
, 
 and 
. These custom types are
IntRange FloatRange
NumPair
then used to instantiate different types of objects.
Union is a parametric type. We can supply it with multiple type parameters to construct a new
type. What is special about union types is that they can serve as placeholders for any of the types
listed as type parameters. Alternatively we can think of union types as a way of combining two
or more types into one type.
Say you have types named 
, 
, and 
. You can create a union of these types by writing 
T1 T2
T3
. This create a new type which can be a placeholder for any of those types.
Union{T1, T2, T3}
This means if you wrote a method with the signature 
, then this
f(x::Union{T1, T2, T3})
particular method would get called whenever  was of type 
, 
 or 
.
x
T1 T2
T3
Let us look at a concrete example:
S = P{T}
julia> IntRange = UnitRange{Int} 
UnitRange{Int64}
julia> FloatRange = UnitRange{Float64} 
UnitRange{Float64}
julia> IntRange(3, 5)
3:5
julia> FloatRange(3, 5) 
3.0:5.0
julia> NumPair = Pair{Int, Float32}
Pair{Int64, Float32}
julia> NumPair(3, 5)
3 => 5.0f0
julia> 3 => 5
3 => 5
10.2.2 Using union types to end the wagon train
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
197

The last example fails because  is a floating point number, and we have only defined a method
x
for function  taking a union of 
 and 
. 
 is not included.
f
Int
String Float64
Every type included in a type union will be counted as a subtype of that union. We use the <:
operator to either define a subtype or test if a type is a subtype.
Type parameter order does not matter.
The ordering of type parameters in a 
 definition does not matter, as shown with the last
Union
evaluated expression.
Armed with union types we can solve our problem with infinite trains.
Listing 10.3 Defining a finite train
The next linked wagon can be nothing.
Values which are not wagons have no cargo.
Reload your Julia REPL and paste in the new type-definition. This code will allow you to create
a finite chain of wagons. Notice how we have defined two 
 methods. We got two different
cargo
julia> f(x::Union{Int, String}) = x^3
f (generic function with 1 method)
julia> f(3)
27
julia> f(" hello ")
" hello  hello  hello "
julia> f(0.42)
ERROR: MethodError: no method matching f(::Float64)
Closest candidates are:
  f(!Matched::Union{Int64, String}) at none:1
julia> String <: Union{Int64, String}
true
julia> Int64 <: Union{Int64, String}
true
julia> Float64 <: Union{Int64, String}
false
julia> Union{Int64, String} == Union{String, Int64} 
true
struct Wagon
     cargo::Int
     next::Union{Wagon, Nothing} 
end
cargo(w::Wagon) = w.cargo + cargo(w.next)
cargo(w) = 0 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
198

cases to deal with since 
 can be either a 
 or 
.
next
Wagon
nothing
Attempt to use 42 as next wagon.
The last example is just thrown in to demonstrate that due to our 
 definition, 
 can only
Union
next
be a 
 or a 
 object. Therefore, setting 
 to an integer such as 42 is not legal. It
Wagon
Nothing
next
causes the Julia type-system to protest loudly by throwing an exception.
Missing values are represented in Julia with the 
 object which is of type 
. This
missing
Missing
seems very similar to 
, so why do we need it?
nothing
This comes about because Julia aims to be a good language for academics doing scientific
computing, statistics, big data etc. In statistics missing data is an important concept. It happens
all the time because in almost any data collection for statistics there will be missing data. For
instance you may have participants filling out forms and some of them fail to fill out all the
fields.
Some participants may leave a study before it is finished, leaving those who conduct the
experiment with incomplete data. Missing data can also exist due to errors in data entry. So
unlike the concept of 
, missing data actually exists out there in the real world. We
nothing
simply don’t know what it is.
Specialized software for statisticians such as 
 and 
 has long time ago established that
R
SAS
missing data should propagate rather than throw exceptions. This means that if a missing value is
introduced in any part of a larger calculation, the whole calculation evaluates to 
. Julia
missing
has chosen to follow this convention as well. Let us look at what that means in practice:
10.3 Missing values
julia> train = Wagon(3, Wagon(4, Wagon(1, nothing)))
Wagon(3, Wagon(4, Wagon(1, nothing)))
julia> cargo(train)
8
julia> train = Wagon(3, Wagon(4, Wagon(1, 42))) 
ERROR: MethodError: Cannot `convert` an object of type Int64
to an object of type Wagon
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
199

Listing 10.4 Comparison of the behavior of 
 and 
 in mathematical
missing
nothing
expressions
What we see in the code above is that every mathematical operation involving a 
 value
missing
evaluates to 
 unlike 
 which causes exceptions to be thrown. The rational for this
missing
nothing
is that a lot of serious mistakes have been made in statistical work in the past from not catching
that there are missing values. Since 
 spreads like a virus in Julia, an unhandled 
missing
missing
value will quickly get caught.
Missing can be handled explicitly. For instance if we want to calculate the sum or averages of an
array which may contain missing values, we can use the 
 function to avoid
skipmissing
attempting to include missing values in the result.
The presence of a 
 value pollutes the whole calculation causing the result
missing
to be 
.
missing
We skip the missing values so we can add up the non-missing values.
Somewhat related to missing values is the floating point number 
 (not a number). We get
NaN
NaN as a result when result of an operation is undefined. This typically pops up as an issue when
dividing zero by zero.
10.4 Not a number
julia> missing < 10
missing
julia> nothing < 10
ERROR: MethodError: no method matching isless(::Nothing, ::Int64)
julia> 10 + missing
missing
julia> 10 + nothing
ERROR: MethodError: no method matching +(::Int64, ::Nothing)
julia> using Statistics
julia> xs = [2, missing, 4, 8];
julia> sum(xs) 
missing
julia> sum(skipmissing(xs)) 
14
julia> median(skipmissing(xs))
4.0
julia> mean(skipmissing(xs))
4.666666666666667
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
200

In this case 
 stands for infinity and is what you get when dividing a number different from
Inf
zero by zero. This makes some sense. As the divisor approaches zero, the result tends to grow
larger.
It is tempting to consider 
 as similar to 
 and that they are interchangeable. After all 
NaN
missing
 also propagates through all calculations:
NaN
Listing 10.5 Propagation of NaN in mathematical operations
Although comparisons return false. Here is why you should 
 use 
 for 
 values: If
not
NaN
missing
you have a mistake in your algorithm, that causes a 
 to happen, you will get 
. This will be
0/0
NaN
indistinguishable from having 
 values as input.
missing
Listing 10.6 Cannot distinguish between calculation causing NaN or input being NaN
You may falsely believe your algorithm is working because it is removing missing values in the
calculation, thus masking a defect in your algorithm. E.g. in the code above we are not checking
if the input  is zero before dividing. Thus when  is 0, we get a 
 as result. If pass 
 as
x
x
NaN
NaN
input to indicate a missing value, then we are unable to make this distinction.
julia> 0/0
NaN
julia> 1/0
Inf
julia> -1/0
-Inf
julia> NaN + 10
NaN
julia> NaN/4
NaN
julia> NaN < 10
false
julia> NaN > 10
false
julia> calc(x) = 3x/x;
julia> calc(0)
NaN
julia> calc(NaN)
NaN
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
201

Undefined data is something you rarely encounter in Julia but it is worth being aware of it. It
happens when a variable or field of a struct has not been set. Usually Julia tries to be smart about
this. Thus if you define a struct with number fields, Julia will automatically initialize them to
zero, if you don’t do anything.
However if you define a 
 without telling Julia what the type of its fields are, Julia has no
struct
way of guessing what the fields should be initialized to.
Listing 10.7 Defining a composite type, instantiated with undefined values
Julia allows construction of composite objects with uninitialized fields. However it will throw an
exception if you try to access an uninitialized field. There are no benefits to having uninitialized
values, but it helps catch programmer mistakes.
Keeping these different concepts of nothing apart can be a bit daunting, so let me summarize
briefly the differences. 
 is the 
 kind of null. It is what a programmer wants
nothing
programmer’s
when something does not exist.
missing is the 
 type of null. What they want when a value is missing in their input
statistician’s
data.
NaN is to indicate that somewhere in your code there was an illegal math operation. In other
words this has to do with calculations and not with statistical collection of data.
Undefined is when you, the programmer, forgot to do your job and initialize all used data. Most
likely it points to a bug in your program.
As a final reminder: Julia does 
 have 
 in the common sense because you need to
not
null
explicitly allow for a 
 value using type unions. Otherwise a function argument cannot
nothing
accidentally pass a nothing value.
10.5 Undefined data
10.6 Putting it all together
julia> struct Person
           firstname
           lastname
           Person() = new()
       end
julia> friend = Person()
Person(#undef, #undef)
julia> friend.firstname
ERROR: UndefRefError: access to undefined reference
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
202

Unknown values in Julia are represented by 
, 
, 
 and undefined
nothing missing NaN
nothing is of type 
 and indicates something doesn’t exist. Use as return value
Nothing
when a find function fails or in data structures, e.g. to terminate a linked list
missing is data which exists but which is missing, such as in a survey. It is of type 
. When implementing code which reads in statistical from a file, use 
 as
Missing
missing
a placeholder for data which is missing
NaN is the result of illegal math operations. Should your function return 
, you should
NaN
investigate whether you have made a programming mistake Are you making sure 0/0
never happens in your code?
Undefined is when a variable was not initialized to a known value
Neither 
 nor 
 are built in values in the language, but defined as
nothing
missing
composite types without any fields
The 
 parameterized type is practical to use with 
 and 
 types. For
Union
Nothing
Missing
instance if a field can be either a string or nothing, define the type as Union{Nothing,
String}
10.7 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
203

Part-3
Collections are objects that store and organize other objects. In this part we look at unique
features and capabilities of collections such as arrays, sets and strings. However, we also delve
into what is common across all collections, such as iterating over all the elements in a for loop or
higher order functions such as map, filter and reduce.
We briefly covered collections in the part 1, Basics, but here we go deeper on each topic.
Collections
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
204

11
This chapter covers
We had had some hands-on experience working with strings in earlier chapters. However to
correctly use text strings there are many details worth knowing about. In this chapter we will
examine these details more closely. As long as you are working with letters from A-Z, things are
simple. However there are a multitude of languages in the world with their own unique set of
characters which Julia needs to be able to deal with.
That means a minimal required knowledge to work effectively with Julia strings requires some
knowledge of Unicode. Unicode is the international standard for mapping numbers (code points)
to characters.
Julia also has support for special string literals to aid in performing a variety of tasks. E.g. there
are special strings called 
 which allow you to check whether another string
regular expressions
matches a particular pattern, such as an email address, IP address or Zip code.
Text strings in Julia are Unicode, encoded in UTF-8 format. What does that mean, and should
you even care? Let me walk you through a simple example to motivate your need to understand
Unicode better.
Working with strings
Understand relation between 
, 
, and 
 encoding
Unicode code points
UTF-8
Compare strings, convert them to lowercase and perform other string operations
When and how to use raw strings
Learn about different kinds of 
: Regular expressions, MIME types, 
string literals
BigInt
literals
11.1 UTF-8 and Unicode
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
205

"Æser," is the plural of norse gods in Norwegian. It is a 4 letter word as confirmed with the 
 function:
length
But when attempting to access individual characters in the word, you will notice something
strange.
Works as expected.
We get an exception. Trying to access the character 's' at index 2 apparently
doesn’t work.
Instead the second character is at index 3. Does this not seem strange?
How about another word? "Þrúðvangr," is the name of the realm of the norse god Thor.
It is a 9 character word, but the character at index 9 is the 6th character 
. What is going on
'a'
here? To understand that, you need to understand Unicode and how Julia strings support it
through the UTF-8 encoding.
 is encoded with 5 bytes.
Æser
 is encoded with 12 bytes.
Þrúðvangr
In UTF-8 every character is encoded into 1-4 bytes. Normal letters such as A, B and C will take
just one byte. While letters such as Æ, Þ and ð which are not used in the english language, will
typically require more than 1 byte to encode.
julia> length("Æser")
4
julia> "Æser"[1] 
'Æ': Unicode U+00C6 (category Lu: Letter, uppercase)
julia> "Æser"[2] 
ERROR: StringIndexError("Æser", 2)
julia> "Æser"[3] 
's': ASCII/Unicode U+0073 (category Ll: Letter, lowercase)
julia> "Æser"[4]
'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)
julia> length("Þrúðvangr")
9
julia> "Þrúðvangr"[9]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia> sizeof("Æser") 
5
julia> sizeof("Þrúðvangr") 
12
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
206

1.  
2.  
However before we delve further into how Julia deals with this, it is useful to understand some
key concepts in Unicode, which are not specific to the Julia programming language.
Unicode and character encodings are complex topics many developers will struggle with at some
point. Understanding some of the histories of why Unicode and UTF-8 exist in their current form
lowers the barrier to understanding.
Both standards evolved from the older ASCII standard, which encoded every character as 8-bit.
Numbers from 65 to 90 would encode the letters from A-Z. Numbers from 97 to 122 would
encode lowercase letters a-z.
Listing 11.1 Relation between characters and numbers
To deal with different languages, one would operate with different interpretations of these
numbers from 1 to 255. However this quickly became impractical. You could not e.g. mix text
written using different alphabets on the same page. The solution was Unicode, which aimed to
give a unique number to every character in the world, not just those in the latin alphabet but also
for Cyrillic, Chinese, Thai and all the various Japanese character sets.
The number given to each character is called a 
 in Unicode terminology. Originally
code point
one believed 16 bits would be enough to store every Unicode code point. 16 bits gives 2¹ - 1 =
 unique numbers. Thus one of the first Unicode encodings 
 used 16 bits (2 bytes) to
65 535
UCS
encode every Unicode code point (character).
Later it was determined that this would not be enough and we would need 4 bytes (32 bits) to
encode every possible Unicode character. At this point the UCS approach started to look flawed:
UCS was already incompatible with 8-bit ASCII code.
Four bytes for every character would consume a lot of space.
UTF-8 encoding solved this problems by using variable number of bytes per character. That way
frequently used characters could be encoded with a single byte saving space. The 1-byte
characters were intentionally made backwards compatible with ASCII.
With variable length character encoding we need to make a distinction between the 
 of
code point
a character and the 
 required to encode the character. Every Unicode character has one
code units
number, the code point, which identifies it. Code units are used to store these code points in
memory. UTF-8 requires a variable number of code units to do that.
11.1.1 Understanding relation between code points and code Units
julia> Char(65)
'A': ASCII/Unicode U+0041
julia> Char(90)
'Z': ASCII/Unicode U+005A
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
207

Figure 11.1 Unicode code points encoded to UTF-8 code units
UCS, in contrast, has fixed-sized code units. Each UCS code unit is 16-bit. Figure 11.1 
illustrates the relationship between characters, code points, and code units. Every gray block for 
the code points represents 4 bytes. A variable number of code units are required for each 
character. Thus, they have been stacked to show which bytes are related to the same character. 
The blue balls give the byte index of some of the code units making up the characters.
To help clarify these concepts, we will have some hands on experimentation with Unicode 
characters in the Julia REPL:
Get the code point of the letter A in hexadecimal form.
The code point of A as a decimal number.
Number of code units required to encode the code point for the letter A.
Is this letter part of the original ASCII standard?
Let us explore characters which are not part of the original ASCII standard. They should have
julia> codepoint('A') 
0x00000041
julia> Int(codepoint('A')) 
65
julia> ncodeunits('A') 
1
julia> isascii('A') 
true
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
208

more than one code unit and not return true when 
 is called.
isascii()
You need two bytes to encode an Æ character in the UTF-8 standard used by Julia.
Æ is not part of the original ASCII standard.
Code point for a smiley.
A smiley emoji requires 4 bytes to encode.
There is no 
 function, because every Julia character is a Unicode character. 
isUnicode
isascii
is simply a way to test if a given Unicode character is 
 part of the original ASCII standard.
also
Just typing letters at the REPL will also give you useful information, when the character literal is
evaluated.
Notice how it tells us what the Unicode code point number is.
julia> codepoint('Æ')
0x000000c6
julia> ncodeunits('Æ') 
2
julia> isascii('Æ') 
false
julia> codepoint('') 
0x0001f60f
julia> ncodeunits('') 
4
julia> isascii('')
false
julia> 'A'
'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)
julia> 'Æ'
'Æ': Unicode U+00C6 (category Lu: Letter, uppercase)
julia> ''
'': Unicode U+1F60F (category So: Symbol, other)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
209

TIP
How to quickly write emojis
You use backlash  and tab key to easily write unusual characters not present
\
on your keyboard. For instance to write , you would type 
 in the Julia
\:smirk:
REPL and hit tab, to get a completion.
You can even hit tab after writing just 
 to get a full list of possible
\:
emojis. Norwegian letters such as 
 that I occasionally use in my examples,
ÆØÅ
can easily be written on a Mac by simply holding down the option key and
hitting 
 respectively (English keyboard layout).
'OA
For other operating systems switch to Norwegian keyboard layout or copy
the letters.
Unicode code points can be written explicitly in Julia in various ways:
You can combine these with 
 to create various ranges. For instance a range does not need to
map
be merely written as numbers. 
 is a perfectly valid range.
'A':'F'
And we can of course go the opposite direction:
julia> '\U41'
'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)
julia> Char(0x41)
'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)
julia> '\U00c6'
'Æ': Unicode U+00C6 (category Lu: Letter, uppercase)
julia> Char(0xc6)
'Æ': Unicode U+00C6 (category Lu: Letter, uppercase)
julia> '\U01f60f'
'': Unicode U+1F60F (category So: Symbol, other)
julia> Char(0x01f60f)
'': Unicode U+1F60F (category So: Symbol, other)
julia> map(lowercase, 'A':'F')
6-element Vector{Char}:
 'a'
 'b'
 'c'
 'd'
 'e'
 'f'
julia> map(codepoint, 'A':'F')
6-element Vector{UInt32}:
 0x00000041
 0x00000042
 0x00000043
 0x00000044
 0x00000045
 0x00000046
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
210

Given that the number of characters and their index are not entirely correlated, we must take care
when working with strings and indices. You should use the 
 and 
 functions
lastindex
nextind
which also work for non-strings.
Listing 11.2 Safe way to use indices in a while-loop
Get index of first element. Thus we don’t have to assume the first element is at
index 1. You can make Julia arrays with different start index.
Check if we have reaced the last index.
Finds the index of the element following index  in array 
i
xs
You can see if we do this with a string, the logic is entirely the same.
Listing 11.3 Iterate over character in a string using a while-loop
julia> map(Char, 65:70)
6-element Vector{Char}:
 'A'
 'B'
 'C'
 'D'
 'E'
 'F'
julia> xs = [4, 5, 3]
julia> i = firstindex(xs) 
1
julia> while i <= lastindex(xs) 
           println((i,xs[i]))
           i = nextind(xs, i) 
       end
(1, 4)
(2, 5)
(3, 3)
julia> s = "Þrúðvangar"
julia> i = firstindex(s)
1
julia> while i <= lastindex(s)
           println((i, s[i]))
           i = nextind(s, i)
       end
(1, 'Þ')
(3, 'r') 
(4, 'ú')
(6, 'ð') 
(8, 'v')
(9, 'a')
(10, 'n')
(11, 'g')
(12, 'a')
(13, 'r')
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
211

Notice we skip from index 1 to 3 going from Þ to r.
Going from ð to v requires skipping index 7.
By using these functions we abstract away the difference between strings and regular arrays. You
can see this in how e.g. 
 is implemented in the standard library. For arrays it is just a
nextind
simple increment:
For strings this is a much more complex operation. I will only show parts of the implementation
edited for clarity.
Listing 11.4 Excerpt of Base implementation of 
 for strings
nextind
For normal code you don’t need to deal with 
 and 
. Instead we use for-loops
nextind
lastindex
since they will automatically fetch a whole character on each iteration.
If you need the indices of each character, then you use the 
 function:
eachindex
Working with text is such a common thing to do, that it pays to be aware of the possibilities that
exist in the language. My intention is not to show every single string operation that exists but
give an idea of what is possible.
I tend to use Julia a lot as an assistant when working with other programming languages. I would
use Julia for transforming code in different ways.
11.2 String operations
nextind(::AbstractArray, i::Integer) = Int(i)+1
function nextind(s::String, i::Int)
    i == 0 && return 1
    n = ncodeunits(s)
    between(i, 1, n) || throw(BoundsError(s, i))
    l = codeunit(s, i)
    (l < 0x80) | (0xf8 =< l) && return i+1
    if l < 0xc0
        i' = thisind(s, i)
        return i' < i ? nextind(s, i') : i+1
    end
    …
end
julia> for ch in "Þrúðvangar"
           print(ch, " ")
       end
Þ r ú ð v a n g a r
julia> for i in eachindex(s)
           print(i, s[i], " ")
       end
1Þ 3r 4ú 6ð 8v 9a 10n 11g 12a 13r
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
212

Let me walk you through an example of doing this. In many programming languages it is
common to see these sorts of variations in text formatting of identifiers:
FooBar - Pascal case (upper camel case) frequently used style for types or classes.
Sometimes used for constants.
foo_bar - Snake case often use for the name of variables, methods and functions.
fooBar - Camel case (lower camel case) frequently used for methods and variable
names.
FOO_BAR - Upper snake case, often used for constants and enum values.
foo-bar - Kebab case. You will find this in LISP programs and configuration files.
We will look at ways of converting between these styles and how you can turn this into handy
utility functions for aiding your programming.
Here is my typical process for developing a simple function to do something. Since you are not
certain about how an unfamiliar function works, you try it out. Then you gradually combine it
with more function calls to get what you want. Eventually you have enough to implement your
function.
Listing 11.5 Iterative development of a camel case function
Now we have a function that will do the conversion, but often we want to be able to do this
quickly. We select some text in our code editor which is in snake case, and which we want to
turn into camel case and paste back in.
This is where Julia’s 
 function becomes handy. It can both read from and write to
clipboard()
the clipboard. The clipboard is what we call the place where everything you copy-paste reside.
julia> s = "foo_bar"
"foo_bar"
julia> split(s, '_')
2-element Vector{SubString{String}}:
 "foo"
 "bar"
julia> uppercasefirst("foo")
"Foo"
julia> map(uppercasefirst, split(s, '_'))
2-element Vector{String}:
 "Foo"
 "Bar"
julia> join(["Foo", "Bar"])
"FooBar"
julia> join(map(uppercasefirst, split(s, '_')))
"FooBar"
julia> camel_case(s::AbstractString) = join(map(uppercasefirst,
                                                split(s, '_')))
camel_case (generic function with 1 method)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
213

1.  
2.  
3.  
4.  
IMPORTANT
Using clipboard on Linux
On Linux the 
 function will not work unless you have the 
 or 
clipboard
xsel
 commands installed. On Debian or Ubuntu you can install with:
xclip
On Red Hat or Fedora Linux you can install with:
We add a method to our 
 function, which does not take any string arguments, but
camel_case
instead reads the clipboard. Just mark some text and copy it before running 
. I
clipboard()
marked the first part of this paragraph.
Listing 11.6 Turn text on clipboard into camel case
clipboard() will get the contents of the clipboard while 
 stores the content of 
clipboard(s)
s
on the clipboard. Whenever you are coding and want to change a snake case text to camel case,
you can follow these steps:
Copy the text.
Switch to your open Julia REPL.
Start typing 
 and hit up-arrow , this should complete to 
 if you
came….
camel_case()
called it before. Alternatively hit tab.
Go back to editor and paste the result.
$ sudo apt-get install xsel
$ sudo yum install xsel
julia> s = clipboard()
"HiHowAreYou"
julia> function camel_case()
            s = camel_case(clipboard())
            clipboard(s)
            s
        end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
214

NOTE
Keys to make you more productive
To work quickly with Julia it is important to become accustomed to all the
hotkeys.  key is used to quickly search through your history. If you start writing
a few letter first it will filter that history to only match history beginning with
those first letters.
The tab key is used to complete a word matching a function Julia knows
about. That could be a built-in one or one you have defined yourself.
Ctrl-A and 
 is used to jump to the beginning and end of a line in
Ctrl-E
the Julia REPL. Say you just wrote:
And you want to alter this to:
Hit , to get back the line you just wrote. Press 
, to jump to beginning of
Ctrl-A
line. Write 
. Finally press 
 to jump to the end and write a 
join(
Ctrl-E
)
Let us look at code for going the other direction. In this case using the 
 function will not
split
work, but why? In our case we cannot split on a specific character, however 
 can take
split
functions instead of characters to decide where to split. To split on whitespace we would use 
. So we could try to use the 
 function. It checks whether a
split(s, isspace)
isuppercase
character is uppercase or not. That is useful since we split where characters are uppercase.
As you can see this does not work, because 
 strips away the character we use for splitting.
split
Instead what we will use is one of Julia’s many find functions. If you write 
 in the REPL
find
and hit tab, you will see a number of possible choices.
map(uppercasefirst, split(s, '_'))
join(map(uppercasefirst, split(s, '_')))
11.2.1 Camel case to snake case
julia> isuppercase('a')
false
julia> isuppercase('A')
true
julia> s = "oneTwoThreeFour"
"oneTwoThreeFour"
julia> split(s, isuppercase)
4-element Vector{SubString{String}}:
 "one"
 "wo"
 "hree"
 "our"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
215

findfirst finds the first occurrence of a match, while 
 finds all of them. Let’s look at
findall
an example to clarify.
We can loop over all the indices of the uppercase letters and capture the substrings using ranges.
Listing 11.7 Print out each capitalized word
This is just a demonstration of how we gradually develop the function. In this case we are using 
 to make sure we are getting the correct output. You can see we are using ranges 
println
i:j-1
to extract a substring.
Here is a complete example. We have removed the 
 and added an array of strings called 
println
 to store each individual word that is capitalized.
words
julia> find
findall   findfirst  findlast
findmax    findmax!   findmin
findmin!   findnext   findprev
julia> s = "The quick brown fox";
julia> findfirst(isspace, s)
4
julia> indices = findall(isspace, s)
3-element Vector{Int64}:
  4
 10
 16
julia> s[indices]
"   "
function snake_case(s::AbstractString)
   i = 1
   for j in findall(isuppercase, s)
       println(s[i:j-1])
       i = j
   end
   println(s[i:end])
end
julia> snake_case("oneTwoThreeFour")
one
Two
Three
Four
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
216

Listing 11.8 Turn a camel cased string into a snake cased string
Once we have collected the words in the array we join them into one string using join(words,
. The second argument 
 causes each word to be joined with  as a separator.
'_')
'_'
_
In chapter 5 we got input from the user. Whether input comes from the keyboard or a file, it
usually comes in the form of text strings. However you may need the input numbers.
We looked at the 
 function to deal with this. Let us look at it more in detail. You provide a
parse
type-object as first argument, to specify what sort of number type you want to parse to. This
could be anything from different types of integers to floating point numbers.
42 in hexadecimal form. See chapter 2.
We can even specify the base. Julia assumes base 10 as default when parsing numbers. That
means digits running from 0 to 9. However we could parse the numbers as if they were binary,
base 2, if we wanted. That assumes we only have the digits 0 and 1 to form numbers.
Interpret string "101" as a decimal number
As a binary number (base 2)
Parse "101" as if it represented a hexadecimal number.
function snake_case(s::AbstractString)
    words = String[]
    i = 1
    for j in findall(isuppercase, s)
       push!(words, lowercase(s[i:j-1]))
       i = j
    end
    push!(words, lowercase(s[i:end]))
    join(words, '_')
end
11.2.2 Converting between numbers and strings
julia> parse(UInt8, "42")
0x2a 
julia> parse(Int16, "42")
42
julia> parse(Float64, "0.42")
0.42
julia> parse(Int, "101") 
101
julia> parse(Int, "101", base=2) 
5
julia> parse(Int, "101", base=16) 
257
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
217

These conversions can also be done in reverse. You can take a number and decide what base you
want to use when converting to a text string.
Create a text string with binary number digits from decimal number 5.
Turn decimal number 17 into a string in hexadecimal form.
Convert to a string using decimal number system.
From the previous string chapter you may remember the named argument 
. Here
color=:green
we have another named argument 
. This is a typical case of named argument usage,
base=2
because we are specifying something which only occasionally needs to be specified.
Sticking with the rocket theme, we will be doing some string manipulations involving the
RD-180 rocket engine made by Energomash.
julia> string(5, base=2) 
"101"
julia> string(17, base=16) 
"11"
julia> string(17, base=10) 
"17"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
218

Figure 11.2 RD-180 rocket engine
Strings can be combined in a myriad of ways in Julia. We will compare some different ways of
doing it. Often we have objects such as numbers we want to turn into text strings. So we define
some variables of different types to use in our string examples.
11.2.3 String interpolation and concatenation
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
219

Here we used the 
 function to perform concatenation of strings and converting
string()
non-strings to strings. We could also use the string concatenation operator . If you come from
*
other languages you may be more familiar with  operator being used for string concatenation.
+
Julia has instead opted for the operator commonly used to denote concatenation in mathematical
notation.
When dealing with lots of variables it is usually better to use string interpolation. String
interpolation is done with the  sign.
$
Observe that you often need to use 
 instead of 
, when there is no
$(variable)
$variable
whitespace that can clearly distinguish the variable name from the surrounding text. The same
applies if you are trying to interpolate an expression rather than a variable. For instance consider
the case where we want to write 3830kN without the space.
julia> engine = "RD-180"
"RD-180"
julia> company = "Energomash"
"Energomash"
julia> thrust = 3830
3830
julia> string("The ", engine,
  " rocket engine, produced by ",
  company,
  " produces ", thrust,
  " kN of thrust")
"The RD-180 rocket engine, produced
 by Energomash produces 3830 kN of thrust"
julia> "The " * engine *
  " rocket engine, produced by " *
  company *
  " produces " *
  string(thrust) *
  " kN of thrust"
"The RD-180 rocket engine, produced by Energomash
produces 3830 kN of thrust"
julia> "The $engine rocket engine, produced by $company produces
$thrust kN of thrust"
"The RD-180 rocket engine, produced by Energomash produces 3830 kN
of thrust"
julia> "produces $thrustkN of thrust"  # Don't work
ERROR: UndefVarError: thrustkN not defined
julia> "produces $(thrust)kN of thrust"
"produces 3830kN of thrust"
julia> "two engines produces $(2 * thrust) kN of thrust"
"two engines produces 7660 kN of thrust"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
220

If you are familiar with C programming you may be familiar with the 
 and 
printf
sprintf
functions. Julia has macros called 
 and 
 which mimic these functions. Unlike
@printf
@sprintf
string interpolation, these macros allow you to specify in more detail how a variable should be
displayed.
NOTE
Macros vs Functions
Macros are distinguished from Julia functions with the  prefix. A macro is
@
akin to a code generator. The call site of a macro gets replaced with other
code. Macros allow advanced metaprogramming which this book will not
cover.
For instance you can specify the number of digits which should be used when printing a decimal
number. 
 outputs the result to the console. 
 and 
 are not in the Julia
@printf
@sprintf
@printf
base module which is always loaded. Thus to use these macros we need to include the Printf
module, which explains the first line.
Here is a short overview of some common formatting options:
%d integer numbers
%f floating point numbers
%x integers shown in hexadecimal notation
%s show argument as string
With each of these formatting options you can specify things like number of digits, decimals or
padding. First let us do some examples of the base formatting options.
I put the bars  in front of and behind the numbers so that when looking at these next examples
|
of how to do padding, it is easier to see.
11.2.4 sprintf formatting
julia> using Printf
julia> @printf(" = %0.1f", pi)
 = 3.1
julia> @printf(" = %0.2f", pi)
 = 3.14
julia> @printf(" = %0.5f", pi)
 = 3.14159
julia> @sprintf("|%d|", 29)
"|29|"
julia> @sprintf("|%f|", 29)
"|29.000000|"
julia> @sprintf("|%x|", 29)
"|1d|"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
221

Notice padding can be applied to either the right side or left side. Right padding is achieved by
adding a . Padding is useful if you want to display columns of numbers which you want
-
aligned. You can add padding as zeros instead of space by prefixing the padding number with 0.
The padding doesn’t say how many spaces or zeros to add, but rather how many characters the
numbers should fill in total. If the padding is two and the number has two digits, then nothing
will happen. However if the padding if four, we get two spaces added resulting in a total of four
characters.
We can create small utility functions with what we just learned.
In this example we will generate C++ code. Julia may not be your primary work language.
Instead you could be using a more verbose language such as C++ or Java at work. But Julia can
be used as a companion to make your job easier.
Let me take you through an example of how a C++ developer could simplify their work, by
taking advantage of the Julia programming language.
The Visualization Toolkit (VTK) is an amazing C++ library for visualization of scientific data.
You can use it to create vidualizations like the one seen in Figure 11.3.
11.3 Using string interpolation to generate code
julia> @sprintf("|%2d|", 42)
"|42|"
julia> @sprintf("|%4d|", 42)
"|  42|"
julia> @sprintf("|%-2d|", 42)
"|42|"
julia> @sprintf("|%-4d|", 42)
"|42  |"
julia> @sprintf("|%02d|", 42)
"|42|"
julia> @sprintf("|%04d|", 42)
"|0042|"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
222

Figure 11.3 From the Visualization Toolkit VTK
Unfortunately writing VTK C++ code is tedious, due to all the typical boilerplate needed in C++.
Below is an example of some of the C++ code used in VTK to define a geometric line. It is not
important that you understand what the code below does. I have edit it to remove unnecessary
details for our example code.
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
223

Listing 11.9 Line class in Visualization Toolkit
Compare this to the next block of code for defining a polygon. You will notice a lot of repetition.
This goes for all VTK code written to define geometric primitives.
Listing 11.10 Polygon class in Visualization Toolkit
Imagine that you frequently write new C++ classes (types) like this for different geometric types.
It is tedious to repeat all this boilerplate. Fortunately we can make small Julia utility functions to
help us.
When generating text consisting of multiple lines it is practical to use triple quotation marks 
.
"""
It allows you to write strings across multiple lines.
#ifndef vtkLine_h
#define vtkLine_h
class VTKCOMMONDATAMODEL_EXPORT vtkLine : public vtkCell
{
public:
  static vtkLine *New();
  vtkTypeMacro(vtkLine,vtkCell);
  void PrintSelf(ostream& os, vtkIndent indent) override;
  int GetCellType() override {return VTK_LINE;};
protected:
  vtkLine();
  ~vtkLine() override {}
private:
  vtkLine(const vtkLine&) = delete;
  void operator=(const vtkLine&) = delete;
};
#ifndef vtkPolygon_h
#define vtkPolygon_h
class VTKCOMMONDATAMODEL_EXPORT vtkPolygon : public vtkCell
{
public:
  static vtkPolygon *New();
  vtkTypeMacro(vtkPolygon,vtkCell);
  void PrintSelf(ostream& os, vtkIndent indent) override;
  int GetCellType() override {return VTK_POLYGON;};
protected:
  vtkPolygon();
  ~vtkPolygon() override;
private:
  vtkPolygon(const vtkPolygon&) = delete;
  void operator=(const vtkPolygon&) = delete;
};
#endif
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
224

Listing 11.11 VTK C++ code generator in Julia code
Here is an example of using this function to create a Hexagon class. Notice in the last two lines
above, that we are also storing the generated code on the clipboard.
Listing 11.12 Use Julia go generate a C++ Hexagon class
function create_class(class::AbstractString)
    s = """
        #ifndef vtk$(class)_h
        #define vtk$(class)_h
        class VTKCOMMONDATAMODEL_EXPORT vtk$class : public vtkCell
        {
        public:
          static vtk$class *New();
          vtkTypeMacro(vtk$class,vtkCell);
          void PrintSelf(ostream& os, vtkIndent indent) override;
          int GetCellType() override {return VTK_$(uppercase(class));};
        protected:
          vtk$class();
          ~vtk$class() override;
        private:
          vtk$class(const vtk$class&) = delete;
          void operator=(const vtk$class&) = delete;
        };
        #endif
        """
    clipboard(s) # So we can easily paste class into code editor
    println(s)
end
julia> create_class("Hexagon")
#ifndef vtkHexagon_h
#define vtkHexagon_h
class VTKCOMMONDATAMODEL_EXPORT vtkHexagon : public vtkCell
{
public:
  static vtkHexagon *New();
  vtkTypeMacro(vtkHexagon,vtkCell);
  void PrintSelf(ostream& os, vtkIndent indent) override;
  int GetCellType() override {return VTK_HEXAGON;};
protected:
  vtkHexagon();
  ~vtkHexagon() override;
private:
  vtkHexagon(const vtkHexagon&) = delete;
  void operator=(const vtkHexagon&) = delete;
};
#endif
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
225

In many programming languages there are useful objects such as dates, regular expressions,
MIME types and numbers which start their life as strings.
For instance you cannot express very large numbers as number literals in Julia, so you have to
express them as a string which gets parsed. For instance floating-point number literals are 64-bit
in Julia and that is not enough to hold a number such as 
. There are types in Julia such
1.4e600
as 
 and 
 which can hold arbitrarily large numbers. But how do you create such
BigInt
BigFloat
an number when number literals are limited to 64-bit floating-point values? The solution is to
parse a string containing the number definition.
Another example is from working with dates. We may be reading a number of dates from a file
and we want to parse them. To do that we specify a date format such as yyyy-mm-dd. This date
format says that years come first and days last, and that each component is separated by a hyphen
. Here is an example of converting from one date format to another (we will cover the date
-
formatting options later).
Listing 11.13 Converting from one dataformat to another
If you run this code you will get the output:
This date formatting code illustrates a problem with all objects derived from strings. If we write
the code in a natural fashion we end up parsing the same string over and over again. On every
loop iteration we parse the strings 
 and 
. But this should not be necessary. Those
"dd/mm"
"E-u"
strings are the same on every iteration, only the date strings themselves change.
To avoid having to parse strings to create objects such as 
, and 
, Julia
BigFloat
DateFormat
11.4 Working with non-standard string literals
julia> 1.4e600
ERROR: syntax: overflow in numeric constant "1.4e600"
julia> x = parse(BigFloat, "1.4e600")
1.3999…9994e+600
julia> typeof(x)
BigFloat
using Dates
dates = ["21/7", "8/12", "28/2"];
for s in dates
    date = Date(s, DateFormat("dd/mm"))
    dstr = Dates.format(date, DateFormat("E-u"))
    println(dstr)
end
Saturday-Jul
Saturday-Dec
Wednesday-Feb
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
226

provides special string literals such as 
 and 
.
big"1.4e600"
dateformat"dd/mm"
When the Julia parses your program code and encounters these strings it does not create String
objects but rather 
, 
 or 
 objects. The benefit of this approach is that
BigInt BigFloat
DateFormat
objects are created when the code is parsed and not when it is run.
That may sound like a geeky detail of no significance. However this does make a significant
difference. Julia will parse the code for a for-loop in your program once. But it will potentially
execute the code inside the loop many times. Thus by creating objects such as 
 at
DateFormat
parse time rather than runtime we improve performance.
I will cover each non-standard string literal in turn in separate sections. By reading through these
sections it will become clearer what this strategy implies.
Let us revisit the 
 example. In other programming languages if we want to avoid the
DateFormat
performance overhead of parsing date format strings multiple times, we might restructure the
code like this:
Listing 11.14 Optimized but less readable date formatting code
From a performance perspective this works. The problems is that the code becomes less clear.
Glancing at the lines parsing the dates and formatting them we cannot immediately see what kind
of format is used. For readability it is much nicer to be able to put the date format definition right
where it is used. With the 
 string literal we can do just that:
dateformat
Listing 11.15 Optimized and readable date formatting code
We haven’t talked about exactly how you specify a date format string. Fortunately the Julia
11.4.1 DateFormat strings
using Dates
informat  = DateFormat("dd/mm")
outformat = DateFormat("E-u")
dates = ["21/7", "8/12", "28/2"]
for s in dates
    date = Date(s, informat)
    dstr = Dates.format(date, outformat)
    println(dstr)
end
using Dates
dates = ["21/7", "8/12", "28/2"]
for s in dates
    date = Date(s, dateformat"dd/mm")
    dstr = Dates.format(date, dateformat"E-u")
    println(dstr)
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
227

online help system gives a great overview. Just go into helpmode (?) and write 
. It
DateFormat
will give you are list of all the letters you can use and what they mean. Basically you use letters
such as ,  and  to represent year, month and day. If you want to to write years as four digits,
y m
d
you specify that as 
. A few code examples in the REPL should give you a sense of how this
yyyy
works:
Not all formats deal with numbers.  and  give the name of the month such as January and
u
U
February.  and  gives the name of the day such as Monday and Tuesday.
e
E
One issue with regular Julia strings is that characters such as  and 
 have special meaning. For
$
\n
particular kinds of text this can be cumbersome. We can solve it by using the escape character \\
, thus  would be written as 
 and 
 as 
. However if we don’t want to do that, and don’t
$
\$
\n
\\n
need string interpolation, we can use raw strings.
In this case the non-standard string literal doesn’t create a new type of object. Instead it interprets
the contents of the string literal differently when constructing a string object.
Regular expressions is a kind of mini-language which you can use to specify text to match.
Regular expressions are widely used in Unix text processing tools and in many coding editors.
You can use regular expressions e.g. to search for a particular text string in your code.
In this example we have some Julia source code stored in the variable . We have decided we
s
want to change the name of the 
 type to 
. We can use the function 
Rocket
SpaceCraft
replace
julia> d = Date(2022, 8, 28)
2022-08-28
julia> Dates.format(d, dateformat"dd-mm-yyyy")
"28-08-2022"
julia> Dates.format(d, dateformat"mm-yy")
"08-22"
julia> Dates.format(d, dateformat"yy/m")
"22/8"
julia> Dates.format(d, dateformat"e u yyyy")
"Sun Aug 2022"
julia> Dates.format(d, dateformat"E U yyyy")
"Sunday August 2022"
11.4.2 Raw strings
julia> thrust = 3830
3830
julia> raw"produces $thrust kN of thrust" # Don't work
"produces \$thrust kN of thrust"
11.4.3 Using regular expressions to match text
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
228

to locate some text to replace.
Some source code text where we imagine a string substitution is needed.
Replace occurence of "Rocket" with "SpaceCraft"
As you remember from chapter 6, we use the 
 operator to create a pair. This was used to create
=>
key-value pairs to store in the dictionary. In this case the pair represents text to find and
substitution text. So 
 means locate 
 and replace it with 
"Rocket"=>"SpaceCraft"
"Rocket"
.
"SpaceCraft"
However as we see from the example, this does not do exactly what you would have expected. 
 also gets replaced with 
. However we only want the 
"RocketEngine"
"SpaceCraftEngine"
 type to be changed. With regular expressions it is easier to be more specific about what
Rocket
we are looking for.
In regular expressions 
 means any character. 
 means any character from 'A' to 'D'.
"."
[A-D]
While writing 
 means any character 
 in the range 'A' to 'D'. So 
[^A-D]
not
"Rocket[^A-Za-z]"
would mean finding the word "Rocket", and where the first succeeding character is 
 a letter.
not
julia> s = """
       struct RocketEngine
           thrust::Float64
           Isp::Float64
       end
       mutable struct Rocket
           tank::Tank
           engine::RocketEngine
       end
       """; 
julia> result = replace(s, "Rocket"=>"SpaceCraft"); 
julia> println(result)
struct SpaceCraftEngine
    thrust::Float64
    Isp::Float64
end
mutable struct SpaceCraft
    tank::Tank
    engine::SpaceCraftEngine
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
229

Listing 11.16 Text substitution using regular expressions
In this example we turn the string we are searching for into a regular expression by prefixing it
with a . That means it will not be a string object. We can demonstrate this in the REPL.
r
This regular expression object is created during parsing, not at runtime. Thus just like 
 we avoid parsing the same regular expression multiple times during runtime.
DateFormat
There is a lot of good documentation on regular expression syntax, so I will only give an
overview of the most basic characters used in regular expressions. The following is list of what
we call character classes.
We also have special characters which influence how the matching of character classes is done.
We call these quantifiers. They can say how many times a character class should be repeated e.g.
More complex interaction with the Julia regular expression system would involve working with 
 objects. In this example we want to pick out a number with mulitple digits 
 and
RegexMatch
\d+
a word composed of multiple letters 
. We do this with the 
 function which will return a 
\w+
match
 object containing all the matches.
RegexMatch
julia> result = replace(s, r"Rocket[^A-Za-z]"=>"SpaceCraft");
julia> println(result)
struct RocketEngine
    thrust::Float64
    Isp::Float64
end
mutable struct SpaceCraft
    tank::Tank
    engine::RocketEngine
end
julia> rx = r"Rocket[^A-Za-z]"
r"Rocket[^A-Za-z]"
julia> typeof(rx)
Regex
Character
Meaning
Example
\d
Match any digit
"387543"
\w
Match any alphanumeric word with underscore
"foo_bar_42"
\s
Match any whitespace, tabs, linefeed, space
" "
.
Match any character
"aA ;%4t"
Character
Meaning
*
Repeat character 0 or more times
+
Repeat one or more times
?
Zero or one time
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
230

Define regular expression.
Match regex against a string.
Access first and second match.
Notice how some parts of the regular expression contains parenthesis. That is to capture that part
of the string. We have setup our regular expression object 
 to capture a number and a word.
rx
We can access these captures through integer indices such as 
 and 
.
m[1]
m[2]
For more complex regular expressions it can get hard to keep track of the position of each
capture. Fortunately regular expressions allow you to name your captures. Say want to capture
hours and minutes from the string 
. We could use the regular expression 
.
11:30
r"(\d+):(\d+)"
Instead we will name each match using 
, where  would be the name of the capture.
?<s>
s
RegexMatch objects act a lot like Julia collections so you can iterate over a 
 object
RegexMatch
with a for-loop. When naming your regular expression captures the 
 object works
RegexMatch
with many of the same functions which are applicable to dictionaries.
While regular expression are extremely powerful and versatile it is easy to end up overusing
them. Rob Pike, one of the creators of the Go programming language and the Plan 9 operating,
julia> rx = r"\w+ (\d+) (\w+) \d+" 
julia> m = match(rx, "foo 123 bar 42") 
RegexMatch("foo 123 bar 42", 1="123", 2="bar")
julia> m[1] 
"123"
julia> m[2] 
"bar"
julia> rx = r"(?<hour>\d+):(?<minute>\d+)"
r"(?<hour>\d+):(?<minute>\d+)"
julia> m = match(rx, "11:30 in the morning")
RegexMatch("11:30", hour="11", minute="30")
julia> m["minute"]
"30"
julia> m["hour"]
"11"
julia> keys(m)
2-element Vector{String}:
 "hour"
 "minute"
julia> haskey(m, "hour")
true
julia> haskey(m, "foo")
false
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
231

UTF-8,and many other popular technologies in systems programming, has repeatedly warned
against the overuse of regular expressions. Regular expressions can get complex and difficult to
modify as new requirements arise.
Personally I rarely use them. In Julia you get very far with basic string and character functions
such as 
, 
, 
, 
, 
 and 
.
split endswith startswith isdigit isletter
isuppercase
A literal syntax exists for most number types, as shown with these examples:
In the cases where it does not exist, you can do a conversion like this 
, which takes a
Int8(42)
64 bit signed integer and turns it into a 8 bit signed integer. When writing integers of arbitrary
precision (any number of digits) you can do this as well by writing 
, however this
BigInt(42)
causes potentially some inefficiency. Everywhere this is encountered an integer has to be
converted to a big int. Instead if you write 
 the big integer is created when the program
big"42"
is parsed and not each time it is run.
This isn’t built into the language. Anyone can define a number literal. Here is an example of
adding support for writing 
 to create 42 at parse time as a signed 8-bit integer. We can
int8"42"
use this as an example to also demonstrate that macros unlike functions only get called once.
Listing 11.17 Defining string literal for 8-bit signed integer
For a string literal with prefix 
 such as 
 you write 
.
foo
foo"42"
foo_str
By writing out a message each time macro is called, we can see how often it is
called.
Parsing the number string and returning an 8-bit number.
11.4.4 Making large integers with BigInt
julia> typeof(42)
Int64
julia> typeof(0x42)
UInt8
julia> typeof(0x42000000)
UInt32
julia> typeof(0.42)
Float64
julia> typeof(0.42f0)
Float32
julia> typeof(3//4)
Rational{Int64}
macro int8_str(s) 
    println("hello") 
    parse(Int8, s) 
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
232

Now we can try it out in a loop. If macros worked like functions we should get a function call
each time we add to the 
 in the loop.
total
However you only see 
 written once, instead of four times. That is all I will say about
hello
macros as it is a too big topic to cover an a beginner’s book. However it is useful to be aware of
some of the more powerful features that exist in Julia, even if you will be unlikely to need them
for your first Julia programs.
Various operating systems have different systems for keeping track of the type of its files.
Windows e.g. famously use a 3-letter filename extension to indicate the type of a a file. The
original macOS stored the file type in special attributes.
However to send files of different types between computers on the internet one needs a common
standard, to identify what the filetypes are. This is what MIME types are. They are typically
described as a type and subtype separated by a slash. HTML pages are denoted as text/html
while JPEG images are denoted as 
. A PNG file type would be written as 
image/jpeg
 and so on.
image/png
You can create a MIME type object in Julia with:
So a MIME type object 
 would have the type 
.
MIME("foo/bar")
MIME{Symbol{"foo/bar"}}
This will look somewhat cryptic until we cover Parametric Types in chapter 18. 
 is long and cumbersome to write, which is why Julia offers the
MIME{Symbol{"foo/bar"}}
shortcut 
.
MIME"foo/bar"
This is easy to mixup. 
 and 
 are 
 the same thing. The first
MIME("foo/bar")
MIME"foo/bar"
not
case is an object. The latter is the type of this object. Here is a simple example of how you could
use this to create methods giving different outputs for different MIME types.
julia> total = 0
0
julia> for _ in 1:4
           total += int8"10"
       end
hello
julia> total
40
11.4.5 MIME types
julia> MIME("text/html")
MIME type text/html
julia> typeof(ans)
MIME{Symbol("text/html")}
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
233

This is useful because it allows us to define functions in Julia which can give different formatted
textual outputs for different contexts.
Julia code executing in a graphical notebook style environment such as 
 would get passed
Jupyter
an HTML MIME type, so graphs and tables can be rendered as HTML.
Julia strings are encoded in UTF-8 which means that each 
 is encoded as a
code point
variable number of code units
parse is used to convert strings to other types such as numbers
string can be used to convert numbers into strings
Julia strings can be combined with other object types using the either string interpolation
with the  symbol or 
 function with variable number of arguments
$
string
Strings can be concatenated with the multiplication operator *
Formatted output to 
 is done with 
 macro. Use 
 to get a string
stdout
@printf
@sprintf
value returned instead. Both are in the 
 module
Printf
String literals in Julia are extendible, but it comes with several built-in ones: raw strings,
big integers and regular expresions
11.5 Summary
say_hello(::MIME"text/plain") = "hello world"
say_hello(::MIME"text/html") = "<h1>hello world</h1>"
julia> say_hello(MIME("text/plain"))
"hello world"
julia> say_hello(MIME("text/html"))
"<h1>hello world</h1>"
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
234

12
This chapter covers
We have already looked at collections such as arrays and dictionaries, but there are many other
types of collections: Sets, linked lists, heaps, stacks, and binary trees.
In this chapter, we will cover what is common among different types of collections. Common to
all collections is that they organize and store multiple elements. Each collection type may offer
unique ways of accessing these elements. For example, with a dictionary, you can access
elements by providing a key, while an array requires an index.
However, collections also have core functionality that all collections must support, such as being 
. If something is iterable, you can access the individual elements in a for-loop or use a
iterable
higher-order function such as map or filter.
What exactly makes something a collection? What are the differences and similarities between
different collection types, and how would you make your own?
We are going to explore these questions by expanding on our multi-stage rocket example from
chapter 8. Because the rocket is made up of many different parts, it is possible to turn it into
something Julia will recognize as a collection.
In this chapter we will add code to the 
 abstract type to show how interfaces are defined. We
Tank
will modify the engine 
 type to support iterating over engines. In the final example we
Cluster
Understanding Julia collections
Understanding how collections are categorized according to the type of operations they
support
Turning staged rockets into an iterable collection
Common operations supported by various collection types
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
235

will modify the 
 type to support iteration over a multi-staged rocket.
StagedRocket
What exactly is an interface? It helps to contrast interfaces with implementations. When you
interact with a computer, you use a mouse and a keyboard. That is the interface to your
computer. You don’t need to know how the particular computer you use is built. You can use the
same mouse and keyboard with many different computers which are built in very different ways.
Regardless of how much memory or what microprocessor your computer has you can interact
with it by clicking the same icons and moving around the same windows. In other words there is
a shared interface between many computer models which insulates you from the specific
hardware implementation of each computer.
Figure 12.1 A computer does not need to know how an input device works
Separating components with clearly defined interfaces allows us to build large complex
structures. The various parts making up your system does not need to know details of
implementation as long as each part uses a well defined interface. Let us relate this to how you
program Julia.
Arrays and ranges are both subtypes of 
 as shown in the next diagram.
AbstractArray
12.1 Defining Interfaces
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
236

Figure 12.2 Type hierarchy for arrays and ranges
Thus, if you have defined a function operating on an 
, you don’t have to deal
AbstractArray
with the difference between an array and a range. I can make a function 
 which works
addup
regardless whether I pass an array or a range as argument.
Listing 12.1 Function for adding up elements in an abstract array
Store the total.
Return total.
function addup(xs::AbstractArray)
    total = 0 
    for x in xs
        total += x
    end
    total 
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
237

Let us call this function with different arguments. Notice it is very similar in function to the sum
function, except it does not allow us to add up a tuple of values? Why is that?
Adding a range of values.
Adding an array of values.
Attempt to add a tuple of values
If you look at figure 12.2, you would see that the 
 type is nowhere to be found in the 
Tuple
 type hierarchy, and thus values of type 
 are not valid arguments to 
.
AbstractArray
Tuple
addup
Another example of a common interface is how we can access elements by index both for ranges
and arrays. Keep in mind that the first element of Julia arrays is at index 1.
Define similar looking range and array.
Accessing the second element looks the same.
Summing a range and an array works the same.
A range doesn’t have elements. Elements exist implicitly. However, we can abstract away that
difference by giving range and array a similar-looking interface. That allows us to define
functions such as 
 to work for both types without creating two different methods.
sum
julia> addup(3:5) 
12
julia> addup([3, 4, 5]) 
12
julia> addup((3, 4, 5)) 
ERROR: MethodError: no method matching addup(::Tuple{Int64, Int64, Int64})
julia> sum((3, 4, 5))
12
julia> r = 3:5 
3:5
julia> r[2] 
4
julia> sum(r) 
12
julia> a = [3, 4, 5] 
3-element Vector{Int64}:
 3
 4
 5
julia> a[2] 
4
julia> sum(a) 
12
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
238

In an object-oriented language such as Java, C++ or C# interfaces for an 
 would
AbstractArray
be defined explicitly. The type definition would have included a list of methods that subtypes
must implement. Failing to do so would produce a compiler error.
However, in Julia, interfaces are 
 defined. Therefore, there is no compiler telling you
informally
that you implemented an interface wrong.
To clarify how we define and work with interfaces in Julia, we will take a look at our propellant
tank example from chapter 8. Say you are supplying a propellant tank interface which other
developers can use. You want to enable them to create their own 
 subtypes which they can
Tank
use when assembling rockets.
Listing 12.2 Defining an abstract propellant tank
Fill propellant tank to the max.
Now imagine that another developer tries to create a concrete 
 subtype to use in our rocket
Tank
simulation. The developer writes this code:
Listing 12.3 Defining a propellant tank subtype
The developer wants to try out his/her new tank and writes the following code in the Julia REPL:
Julia has no idea what 
 is.
totalmass
This error message makes it difficult for somebody trying to implement the 
 interface to
Tank
know what they are supposed to do. The Julia convention to solve this problem is to define the
12.2 Propellant Tank Interface Example
abstract type Tank end
propellant(tank::Tank) = tank.propellant
function refill!(tank::Tank) 
    propellant!(tank, totalmass(tank) - drymass(tank))
    tank
end
mutable struct FlexiTank <: Tank
    drymass::Float64
    totalmass::Float64
    propellant::Float64
end
julia> tank = FlexiTank(10, 100, 0)
FlexiTank(10.0, 100.0, 0.0)
julia> refill!(tank)
ERROR: UndefVarError: totalmass not defined 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
239

functions in the interface and document them.
When looking at the code in listing 12.4, you may ask: Why is this focusing on documenting the
code? Where is the interface defined? What is the syntax for defining an interface? The answer is
that there is none. That is why I say interfaces in Julia are 
 defined. Hence
informally
documentation  a key part of defining a Julia interface.
is
Remember from chapter 7 that in Julia, methods are attached to functions and not types. You
cannot associate functions with any particular type. The only reason 
, 
, and 
totalmass drymass
 belong to the 
 interface is because we said so in the documentation. It is all
propellant
Tank
make believe.
Listing 12.4 Defining a well documented interface to propellant tanks
The Julia documentation system works by prefixing a function or type definition with a regular
Julia text string. Inside this text string you document your function or type using markdown29
syntax. In markdown you indent lines which you want formatted as source code. To highlight
individual words as code you use backticks .
`
"Stores propellant for a rocket"
abstract type Tank end
"""
    totalmass(t::Tank) -> Float64 
Mass of propellant tank `t` when it is full.
"""
function totalmass end
"""
    drymass(t::Tank) -> Float64 
Mass of propellant tank `t` when it is empty.
"""
function drymass end
"""
    propellant(t::Tank) -> Float64 
Get remaining propellant in tank. Propellant is fuel plus oxidizer
"""
propellant(tank::Tank) = tank.propellant
"""
    refill!(tank::Tank) -> Tank 
Fill propellant tankt to the max. Returns full tank
"""
function refill!(tank::Tank)
    propellant!(tank, totalmass(tank) - drymass(tank))
    tank
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
240

TIP
Writing documentation in the REPL
Sometimes you want write function definitions right in the Julia REPL.
However, when you hit enter after the end of the documentation string it gets
evaluated before you can write your function definition. How do you fix this? If
you hold down the 
 or 
 key when you hit 
, Julia will allow you to
alt
option
enter
continue writing code.
To add documentation to your functions, you can use double quoted or triple-quoted strings (  or
"
). Please keep in mind that this is different from adding a comment with the hash  symbol.
"""
#
Comments don’t get stored in the Julia help system.
Triple quotation and double quotation work slightly different. For instance if I want to use
double quotes inside a double quoted text I have to 
 the quotes by using a backlash. That
escape
is not necessary for triple quotation.
Your documentation does not need to match Julia syntax. For instance we have used an arrow in
the documentation to inform readers what sort of object the functions return:
Put this new definition of 
 in a file together with 
 and reload you Julia REPL
Tank
FlexiTank
with it. You can organize this almost whatever way you like. I use a file called 
. It looks like this (removed documentation strings for compactness):
tank-interface.jl
Let us explore what error messages we get this time when we attempt to refill our flexi tank.
julia> print("file \"foo.txt\" not found")
file "foo.txt" not found
julia> print("""file "foo.txt" not found""")
file "foo.txt" not found
"drymass(t::Tank) -> Float64"
abstract type Tank end
function totalmass end
function drymass end
propellant(tank::Tank) = tank.propellant
function refill!(tank::Tank)
    propellant!(tank, totalmass(tank) - drymass(tank))
    tank
end
mutable struct FlexiTank <: Tank
    drymass::Float64
    totalmass::Float64
    propellant::Float64
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
241

In this case, we get a better error message. Julia lets us know that 
 is indeed a
totalmass
function, but it lacks a method for the 
 type. By checking which methods exist, we
FlexiTank
can deduce that we need to add a method dealing with the 
 type.
FlexiTank
To enter the Julia help system, you hit the  key, as we discussed in chapter 2.
?
Usually, you would provide a guide to your library to explain how developers should use it. This
guide should explain what interfaces exist and how you implement these interfaces.
In a statically typed language such as Java, the compiler and a sophisticated IDE
 can inform
30
developers about the required methods to implement and their arguments. Since Julia is a
dynamically typed language, we don’t have this luxury. We must adequately document our
functions, so other developers know what arguments are expected and what the functions should
return.
As the following example shows, you can hit the tab-key before you have completed writing a
function call to get a list of methods and their arguments that match what you have written.
Hit tab and available methods pop up above.
However, this strategy is useless for 
 and 
 as these functions don’t have any
totalmass
drymass
attached methods. That is why it is essential to document required arguments to these functions.
julia> t = FlexiTank(10, 100, 0)
FlexiTank(10.0, 100.0, 0.0)
julia> refill!(t)
ERROR: MethodError: no method matching totalmass(::FlexiTank)
julia> methods(totalmass)
# 0 methods for generic function "totalmass":
help?> totalmass
search: totalmass
  totalmass(t::Tank) -> Float64
  Mass of propellant tank t when it is full.
refill!(tank::Tank)
julia> refill!( 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
242

Not all interfaces in Julia are connected to a specific abstract type as demonstrated in our
previous example. For instance there is a 
 interface. If you implement this interface, you
iteration
will be able to iterate over your collection using a for-loop. It will also make it possible to use it
with functions such as 
, 
 and 
 which operate on iterable collections.
map reduce
filter
The iteration interface is not represented by any particular abstract type you need to implement.
Rather it is informally described. You are at a minimum expected to extend the iterate
function for your collection type with these methods:
There are several of these methods, which are documented thoroughly in the official Julia
documentation. These are the more useful ones:
I will cover two different rocket-related examples where we will implement some of these
methods. In the first example, we will iterate over the engines a cluster. In the second, we will
iterate over the stages in a multi-staged rocket.
In chapter 8, we defined a cluster of engines like this:
Listing 12.5 Old definition of rocket engine cluster
With this definition all the engines in the cluster have to be of the same type. But what if we
want a mix of different types of engines? Some rockets actually do have a mix of engines and we
cannot model such rockets with our type definitions. To solve this, we will turn 
 into an
Cluster
abstract type instead. This abstract type will have two concrete subtypes:
A 
 representing identical engines
UniformCluster
A 
 representing a mix of different engines
MixedCluster
12.3 Interfaces By Convention
12.4 Implementing Engine Cluster Iteration
Required Methods
Purpose
iterate(iter)
First item and initial state
iterate(iter, state)
Current item and next state
Optional Methods
Purpose
IteratorSize(IterType)
Indicate if collection has known length
eltype(IterType)
Type of each element
length(iter)
The number of items in collection
struct Cluster <: Engine
    engine::Engine
    count::Int
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
243

But why introduce a second level of abstraction? Why cannot 
 and 
UniformCluster
 be direct subtypes of 
? As we develop our code the benefits of this layer
MixedCluster
Engine
of abstraction will become clear. Open the source code for your 
 type from chapter 8
Cluster
and modify it to the following code:
Listing 12.6 Redesigned cluster type hierarchy
A vector of elements which are subtypes of 
.
Engine
Define function checking if engine  is the same as first engine.
e
Check if all engines are of the same type.
Return a 
 if all engines are of the same type.
UniformCluster
Return a 
 if engines are of different types.
MixedCluster
We add 
 methods which looks at the types of engines passed as arguments to determine
Cluster
whether a uniform or mixed cluster should be created. We use a couple of new tricks here.
The 
 function is defined inside our 
 constructor. This means it has access to
sametype
Cluster
the 
 argument without having to pass it as an argument. Why is a benefit? Because 
 is
engine
all
a higher order function expecting a function taking a single argument and returning 
 or 
true
. Her is some examples to give you an idea:
false`
abstract type Cluster <: Engine end
struct UniformCluster <: Cluster
    engine::Engine
    count::Int
end
struct MixedCluster <: Cluster
   engines::Vector{Engine} 
end
function Cluster(engine::Engine, count::Integer)
    UniformCluster(engine, count)
end
function Cluster(engine::Engine, engines::Engine...)
    sametype(e) = (typeof(engine) == typeof(e)) 
    if all(sametype, engines) 
        UniformCluster(engine, length(engines) + 1) 
    else
        MixedCluster([engine, engines...]) 
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
244

Listing 12.7 Demonstrating usage of the 
 function
all
Every number is even in this case.
The number 3 is not even.
By hiding what type we use to represent a cluster, we can create the illusion that there is only one
 type. That we use two different types internally becomes an implementation detail. Let
Cluster
us demonstrate how this works in the Julia REPL.
Since all arguments are of the same type we get a 
.
UniformCluster
Need a mixed cluster to hold a merlin and rutherford engine.
We will need to redefine our 
, 
, and 
 methods with these changes. Remember in
Isp mass
thrust
chapter 8 these functions got defined as:
We will implement an 
 interface on these cluster types to allow us to write only one
iterable
implementation of 
 and 
, which works for both cluster types.
mass
thrust
You can try to iterate over a cluster as it is currently defined but it will not work:
julia> iseven(3)
false
julia> iseven(4)
true
julia> all(iseven, [4, 8, 10]) 
true
julia> all(iseven, [3, 8, 10]) 
false
julia> Cluster(Rutherford(), Rutherford())
UniformCluster(Rutherford(), 2) 
julia> Cluster(Rutherford(), Merlin())
MixedCluster(Engine[Rutherford(), Merlin()]) 
Isp(cl::Cluster) = Isp(cl.engine)
mass(cl::Cluster) = mass(cl.engine) * cl.count
thrust(cl::Cluster) = thrust(cl.engine) * cl.count
12.4.1 Making Clusters Iterable
julia> cl = Cluster(Rutherford(), 3)
UniformCluster(Rutherford(), 3)
julia> for engine in cl
           println(mass(engine))
       end
ERROR: MethodError: no method matching iterate(UniformCluster)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
245

The Julia Just-In-Time (JIT) compiler will convert this for-loop into a lower level while-loop
which looks like this:
Listing 12.8 For-loop implementation in Julia
Begin iteration.
Check if we reached the end of the iteration.
Extract values in 
 tuple.
next
Advance to next element in collection.
So the reason our for-loop does not work is that we have not yet implemented the required 
 methods.
iterate
Listing 12.9 Implement iteration interface for MixedCluster
Add methods to 
 function defined in 
 module.
iterate
Base
Used to start iteration.
Advance to next element in collection.
Return 
 to indicate we reached the end.
nothing
Current element and index of next element.
Importing the 
 function from 
 is important since the for-loop is made to use 
iterate
Base
 from 
 and not an 
 function of the same name defined in another module.
iterate
Base
iterate
When we start iteration we need to return the very first element and the index of the next
element. Thus when we start iteration we must return the index of the second element. That is
cluster = Cluster(Rutherford(), 3)
next = iterate(cluster) 
while next != nothing 
    (engine, i) = next 
    println(mass(engine))
    next = iterate(cluster, i) 
end
import Base: iterate 
function iterate(cluster::MixedCluster) 
    cluster.engines[1], 2
end
function iterate(cluster::MixedCluster, i::Integer) 
    if i > length(cluster.engines)
        nothing 
    else
        cluster.engines[i], i+1 
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
246

why we return 
. We can call 
 manually to get a sense of how
cluster.engines[1], 2
iterate
it works:
Listing 12.10 Performing manual iteration on a cluster
Get initial state.
Extract engine and next index from 
 tuple.
next
Fetch next engine.
Reached end so 
 equals 
next
nothing
Now the implementation of iteration for 
 should make more sense:
UniformCluster
Listing 12.11 Implement iteration for UniformCluster
You can see that this implementation is simpler, because we are always returning the same
engine. The  index is only used to keep track of whether we have reached the end of the
i
iteration.
Because both 
 types now support iteration, we can implement 
 and 
 in terms
Cluster
mass
thrust
of iteration:
cluster = Cluster(Rutherford(), Merlin());
julia> next = iterate(cluster)  
(Rutherford(), 2)
julia> (engine, i) = next 
(Rutherford(), 2)
julia> next = iterate(cluster, i) 
(Merlin(), 3)
julia> (engine, i) = next 
(Merlin(), 3)
julia> next = iterate(cluster, i) 
   
import Base: iterate
function iterate(cluster::UniformCluster)
    cluster.engine, 2
end
function iterate(cluster::UniformCluster, i::Integer)
    if i > cluster.count
        nothing
    else
        cluster.engine, i+1
    end
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
247

Listing 12.12 Define 
 and 
 for clusters
mass`
thrust
How does this work? The 
 function iterates over the collection supplied as the second
sum
argument. 
 will apply the function provided as the first argument to each element it iterates
sum
over. 
 is equivalent to writing 
. Neither
sum(thrust, cluster)
sum(map(thrust, cluster))
call will work until we implement 
 for clusters, otherwise Julia cannot figure out how
length
large the result vector should be before starting iteration.
Listing 12.13 Give Julia a way to figure out how many engines are in a cluster
Extend 
 function to support our cluster types.
length
Remember there are 
 methods which take both one and two arguments. For 
 we cannot
sum
Isp
sum values, rather we would have to find an average.
Listing 12.14 Calculate specific impulse of a cluster of engines
This code also lets our collection support 
, which is sensible for most collections to
length
support. Developers naturally want to be able to check how many elements are contained within
a collection.
With these changes, it should be more apparent why we made 
 an abstract type. It
Cluster
allowed us to share our implementation of 
, 
, and 
 across multiple cluster types.
mass Isp
thrust
The usage of abstract types is a good way of achieving code reuse.
Next, we will explore how we can iterate across rocket stages. This will be a bit different since
you cannot access rocket stages by index.
In chapter 8, we defined a rocket stage like this:
12.5 Implementing Rocket Stage Iteration
mass(cluster::Cluster)   = sum(mass, cluster)
thrust(cluster::Cluster) = sum(thrust, cluster)
import Base: length
length(cluster::UniformCluster) = cluster.count 
length(cluster::MixedCluster) = length(cluster.engines) 
Isp(cl::Cluster) = sum(Isp, cl)/length(cl)
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
248

Listing 12.15 Definition of a rocket stage
You can see that we don’t have a vector from which we can pull individual stages. Thus the
element in the tuple we return from 
 will not be an integer index.
iterate
Listing 12.16 Initiate iteration of a staged rocket
This code handles two different cases:
A staged rocket which actually has a payload
All other rockets are not staged and thus have no 
 element
next
This means that you don’t have to add 
 for every possible subtype of 
. Instead
iterate
Rocket
we make 
 types default to not supporting iteration.
Rocket
We also need to support advancing through the collection of stages. That is what these 
 methods will do:
iteration
Listing 12.17 Advance to next stage in rocket
Called when next stage is also a staged rocket.
Default handling of iterating to next stage.
We have defined these new methods such that we default to ending the iteration. That is
accomplished by specifying the type of 
 as 
. Then we make an exception for
current
Rocket
when 
 is of type 
. In this case we know there is a 
 field which
current
StagedRocket
nextstage
we can access to advance to the next element in the collection.
Thus while the first example with the 
 type made it look as if 
 is an integer
Cluster
current
index, that is not really true. The second argument to 
 does not need to be an integer. It
iterate
struct StagedRocket <: Rocket
    nextstage::Rocket
    tank::Tank
    engine::Engine
end
import Base: iterate
iterate(r::StagedRocket) = (r, r.nextstage)
iterate(r::Rocket) = nothing
function iterate(first::StagedRocket, current::StagedRocket) 
    current, current.nextstage
end
function iterate(first::StagedRocket, current::Rocket) 
    nothing
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
249

can be any data that helps you remember your current position in a collection you are iterating
over.
We can test iteration with a small program. You can put this in the REPL or in a file which you
load into the REPL.
Listing 12.18 Iterating over rocket stages
Make sure you have loaded your rocket code into your REPL first. When you run this program
you should get the following output:
This shows that iteration within a for-loop works. However we cannot use it with functions such
as 
, 
 and 
.
sum map
collect
Listing 12.19 Failed attempt at using 
 and 
map
collect
Making this work will be the next step.
map and 
 fail because we lack implementation of a 
 method for the 
 type.
collect
length
Rocket
To develop an understanding of this problem, we will first look at a naive solution:
payload = Payload(300)
thirdstage = Rocket(payload, SmallTank(), Curie())
secondstage = Rocket(thirdstage, MediumTank(), Rutherford())
booster = Rocket(secondstage, LargeTank(), Cluster(Rutherford(), 9))
for rocket in booster
    println("Mass of rocket: ", mass(rocket))
    println("Thrust of rocket: ", thrust(rocket))
    println()
end
Mass of rocket: 13568.0
Thrust of rocket: 225000
Mass of rocket: 3053.0
Thrust of rocket: 25000
Mass of rocket: 718.0
Thrust of rocket: 120
julia> map(mass, booster)
ERROR: MethodError: no method matching length(::StagedRocket)
julia> collect(booster)
ERROR: MethodError: no method matching length(::StagedRocket)
12.5.1 Add support for map and collect
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
250

Listing 12.20 Calculate number of stages in staged rocket
While this works, it has poor performance characteristics. The time it takes to calculate the
length of a stage rocket is proportional to its length. We refer to such algorithms as linear or 
 in Big-O notation.
O(n)
NOTE
Big-O Notation
In computer science, we often talk about data structures and algorithms in
terms of memory requirements and processing power in what is called Big O
. If the time it takes to find an item with an algorithm is linear, say it
Notation
depends on the number of elements in a collection then we write that as O(n)
. The  refers to  elements in your whole collection. Thus if  doubles, then an
n
n
n
 algorithm will take twice the amount of time to finish.
O(n)
An algorithm that uses a for-loop to look at every element would be 
.
O(n)
An algorithm with constant time is written as 
.
O(1)
Julia gives us a way of telling its iteration machinery that there is no effective way of
determining the length of the collection we iterate over. We do that by implementing a 
 method:
IteratorSize
Listing 12.21 Add the 
 trait to the 
 subtypes
SizeUnknown
Rocket
This is not easy to grasp at first glance. What is going on here? This is what we call the holy
. Patterns in programming refer to particular ways of solving problems which get
traits pattern
reused in many different contexts. In Julia we use the 
 to add traits to types. A 
holy traits pattern
 is like an ability or characteristic. For instance an archer and a crossbowman might have the 
trait
 trait. A knight could have the 
 trait. A horse archer such as a mongol warrior
CanShoot
CanRide
would have both the 
 and 
 trait.
CanShoot
CanRide
import Base: length
length(::Rocket) = 0
length(r::StagedRocket) = 1 + length(r.nextstage)
import Base: iterate, IteratorSize
IteratorSize(::Type{<:Rocket}) = Base.SizeUnknown()
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
251

Figure 12.3 The IteratorSize trait and its subtypes
Iterable Julia collections can have different traits. One of these traits is 
. How
IteratorSize
exactly does this work? When you call 
, this gets translated to the following
collect(rocket)
code:
Listing 12.22 Implementation of the 
 function
collect
Attached to the 
 function there are several different methods to deal with collections
_collect
with different traits. We can see here that the behavior of 
 depends on two different
collect
traits: 
 and 
. We don’t always have register traits for our
IteratorEltype
IteratorSize
collections because the defaults are fine. This is how the default for 
 is defined:
IteratorSize
Listing 12.23 Default 
 for Julia collections
IteratorSize
When the 
 trait is defined as 
, Julia will call 
 to determine the
IteratorSize
HasLength
length
size of the result array produced from 
. When we define this trait as 
, Julia
collect
SizeUnknown
will instead use an empty array for output that grows as needed.
In Julia, traits are defined as abstract types. The values a trait can have is a concrete subtype. 
 and 
 are both subtypes of 
. You may recognize a similar
HasLength
SizeUnknown
IteratorSize
pattern from chapter 9, covering conversion and promotion. Both the 
 and 
convert
 functions take types as arguments. However, in this case we do a little twist by
promote_rule
describing the argument type as 
.
Type{<:Rocket}
The subtype operator 
 is used to indicate that 
 subtypes of 
 have the value 
<:
all
Rocket
 for the 
 trait. I know this is a mouthful, but fortunately, this is
SizeUnknown
IteratorSize
something you typically look up when needed. It is more important to be aware of traits than to
remember exactly how they work.
_collect(rocket, IteratorEltype(rocket), IteratorSize(rocket)).
IteratorSize(x) = IteratorSize(typeof(x))
IteratorSize(::Type) = HasLength()
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
252

Having defined the 
 trait for 
, we can now use 
, 
, and other
IteratorSize
Rocket
map
sum
higher-order functions operating on collections:
Remember to define second and third state if you haven’t already.
Get the mass of every stage.
Add up the thrust of all engines on the staged rocket.
The most basic operation a collection needs to be able to support is iteration. We have looked at
how that is achieved on two different types of collections. The rocket clusters behave mostly like
arrays. However, our staged rocket behaves more like a data structure called a 
. In the
linked list
next section, we will compare linked lists and arrays to understand better how different
collection types give different tradeoffs.
The way we link stages to each other through 
, is the same as how a 
 works.
nextstage
linked list
They are often contrasted with arrays. With an array, you can quickly determine the length or
look up an arbitrary element given an index. We will add support for index based lookup to our 
 subtypes and later contrast with our linked list of rocket stages.
Cluster
Remember how for-loops actually gets turned into while-loops. We have a similar case when
accessing and replacing elements in an array. Say we have created cluster where we access
elements.
Listing 12.24 Index based access
Read first element.
Change second element.
This code will be translated by the Julia compiler through several stages. One of these stages
called lowering, turns this code into:
12.6 Comparison of Linked Lists and Arrays
julia> booster = Rocket(secondstage,
                        LargeTank(),
                        Cluster(Rutherford(), 9)); 
julia> map(mass, booster) 
3-element Vector{Float64}:
 13568.0
  3053.0
   718.0
julia> sum(thrust, booster) 
250120
cluster = Cluster(Rutherford(), Merlin())
engine = cluster[1] 
cluster[2] = Rutherford() 
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
253

Listing 12.25 Index based access under the hood
Thus to make our 
 subtypes support accessing elements by index, we need to add
Cluster
methods to the 
 and 
 functions found in the 
 module. These are the
getindex
setindex!
Base
functions used to implement element access with square brackets 
.
[]
Listing 12.26 Add index based access to rocket clusters
Get the i-th element in cluster.
Set the i-th element in cluster to 
.
egn
We don’t care about index for a UniformCluster
We can see some differences between 
 and 
. You can easily
MixedCluster
UniformCluster
support getting elements form a 
 because every element is the same. However
UniformCluster
we cannot support setting an element because then it would no longer be uniform. Hence we
have not added a method for 
 dealing with the 
.
setindex!
UniformCluster
While you could define index-based access for a linked list, it isn’t very efficient, as shown in
the following example.
Listing 12.27 Access rocket stage by index
 is used when we don’t care about the name of a variable.
_
Such a lookup is an 
 operation (linear). The more stages we have, the more times the
O(n)
cluster = Cluster(Rutherford(), Merlin())
engine = getindex(cluster, 1)
setindex!(cluster, Rutherford(), 2)
import Base: getindex, setindex!
function getindex(cluster::MixedCluster, i::Integer) 
    cluster.engines[i]
end
function setindex!(cl::MixedCluster, egn::Engine, i::Integer) 
    cl.engines[i] = egn
end
function getindex(cluster::UniformCluster, _) 
    cluster.engine
end
import Base: getindex
function getindex(r::StagedRocket, i::Integer)
    for _ in 1:i-1 
        r = r.nextstage
    end
    r
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
254

for-loop has to be repeated. A lookup in an array, in contrast, is a 
 operation. That is another
O(1)
way of saying a constant operation. The time to look up an element in an array with three
elements is exactly the same as in an array with 1 million elements.
However we can add support for other types of operations which work faster. Let us look at
some of the common operations supported in Julia for adding elements to collections.
Arrays allow us to add elements to the front and back of the array as well as remove elements
from both ends. Notice in the examples how 
 and 
 allow you to add more than
push!
pushfirst!
one element in a single function call.
Create array 
 with one element 7.
xs
Add 9 and 11 to the back of array.
Add 3 and 5 to the front of array.
Remove last element.
Remove first element.
The following illustration may help to clarify how these operations work.
12.6.1 Adding and Removing Elements
julia> xs = Int[7] 
1-element Vector{Int64}:
 7
julia> push!(xs, 9, 11) 
3-element Vector{Int64}:
  7
  9
 11
julia> pushfirst!(xs, 3, 5) 
5-element Vector{Int64}:
  3
  5
  7
  9
 11
julia> pop!(xs) 
11
julia> popfirst!(xs) 
3
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
255

Figure 12.4 Adding and removal of elements from an array
For linked lists it is effective to remove and add elements to the front. Thus we can support
operations like 
 and 
. However we need to make some adjustments and
pushfirst!
popfirst!
preparations to make it more convenient to implement these functions.
Figure 12.5 Terminated linked list of staged rockets
When dealing with linked list it is useful to have something obvious to terminate a chain of
objects. Often this will be a 
 object, but with our staged rocket an 
 would
nothing
emptypayload
be a natural fit.
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
256

Listing 12.28 An empty payload object to terminate a list of rocket stages
No fields.
Every instance is the same objects as with 
.
nothing
Implement 
 interface.
Rocket
Having a representation of an empty payload buys us a number of advantages, such as having a
sensible default constructor for a single staged rocket as shown in the preceding code example.
We are however not quite done. We need addition of a new type and modification to an existing
one. 
 was initially made immutable. That will hinder e.g. 
 from
StagedRocket
popfirst!
working as we need to modify the 
 field. You cannot modify fields on an immutable
nextstage
objects (objects which cannot be changed).
IMPORTANT
Whenever you change a type definition such as making a struct mutable you
need to re-start the Julia REPL. The reason is because Julia types are fixed.
They cannot be modified at runtime like many other dynamic languages.
We are also going to introduce the 
 type. The following illustration shows how it
SpaceVehicle
conceptually related to other rocket parts.
struct EmptyPayload <: Rocket end 
const emptypayload = EmptyPayload() 
mass(::EmptyPayload) = 0.0 
thrust(r::EmptyPayload) = 0 
update!(r::EmptyPayload, t::Number, t::Number) = nothing 
function Rocket(tank::Tank, engine::Engine)
    StagedRocket(emptypayload, tank, engine)
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
257

Figure 12.6 Rocket terminology overview
The 
 is the whole thing with all the rocket stages. This is useful to wrap around
SpaceVehicle
our stages, so we can keep track of where the first rocket stage starts. This is useful when
implementing 
 and 
, because it allows us to add and remove stages
pushfirst!
popfirst!
relative to something else.
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
258

Listing 12.29 New and modified type definitions
Change 
 to 
.
StagedRocket
mutable
Want 
 to be changeable.
nextstage
Wrapper around rocket stages.
Stage with the engines currently firing.
With these type definitions in place, we have the foundation to implement our 
 and 
popfirst!
 methods. Because there are standard functions for Julia collections, we import them
pushfirst!
from 
 to extend them with methods dealing with our specific collection: 
.
Base
SpaceVehicle
Listing 12.30 Removing stage from the bottom
Check if more stages are left.
Not allowed to pop stages from an empty space vehicle.
Discard bottom stage.
Unchain discarded stage.
Next stage becomes active stage.
Show what stage was discarded in REPL.
The 
 function requires some explanation. We add two methods: One to handle a 
tail
 and another for subtypes of 
. It is a simple way to check whether there are
StagedRocket
Rocket
mutable struct StagedRocket <: Rocket 
    nextstage::Rocket 
    tank::Tank
    engine::Engine
end
mutable struct SpaceVehicle 
    activestage::Rocket 
end
import Base: popfirst!, pushfirst!
tail(r::StagedRocket) = r.nextstage
tail(r::Rocket) = nothing
function popfirst!(ship::SpaceVehicle)
    r = tail(ship.activestage)
    if r == nothing 
        throw(throw(ArgumentError("no rocket stages left"))) 
    else
        discarded = ship.activestage 
        discarded.nextstage = emptypayload 
        ship.activestage = r 
    end
    discarded 
end
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
259

any stages left on the 
. Since the 
 field of 
 is of type 
SpaceVehicle
activestage
SpaceVehicle
, we cannot be guaranteed that a 
 exists. Why not make it a 
Rocket
nextstage
StagedRocket
then? Because we want to allow stages to be detached until we have only a payload representing
a satellite or crew capsule left.
Listing 12.31 Add stage to the bottom
Current stage becomes next stage.
New stage become current stage.
With 
 we put a new stage  in front of the existing active stage. The old active stage
pushfirst!
r
changes its role to become the next stage of our new active stage. Make all these edits and
modifications and spin up a new REPL to get a feel for hose these new functions work. To help
make it more visually distinct I will make a rocket with stages named ,  and . Each stage has
a b
c
bigger tanks and bigger engine than the previous one.
We begin by creating a space vehicle with just a small 40 kg payload:
Next we use 
 to add stages to this space vehicle.
pushfirst!
function pushfirst!(ship::SpaceVehicle, r::StagedRocket)
    r.nextstage = ship.activestage 
    ship.activestage = r 
    ship
end
julia> a = Rocket(SmallTank(), Curie());
julia> b = Rocket(MediumTank(), Rutherford());
julia> c = Rocket(LargeTank(), Merlin());
julia> ship = SpaceVehicle(Payload(40));
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
260

I have edited the REPL output by adding whitespace and indentation to more clearly show the
structure we are creating as we are adding more stages. You can see how the smallest stage is at
the deepest indentation level. That is because it is nested deepest. The booster stage with the
large engine and tank, is at the bottom.
We can knock off all these stages again using the 
 function.
popfirst!
On each pop, we return the stage that was discarded. Notice how the largest stage with the 
 engine comes off first. Next, we get to the stage with the medium-sized tank. Finally, the
Merlin
top stage with the small tank comes last. Finally we are left with the space vehicle only
containing the initial 40 kg payload.
A linked list isn’t used often in actual code as arrays are more versatile and have better
performance most of the time. However, linked lists are useful to understand as the principles
applied here apply to more complex data structures. Tree structures and graphs also link together
elements.
12.7 Utility of Custom Types
julia> pushfirst!(ship, a)
SpaceVehicle(StagedRocket(Payload(40.0), SmallTank(370.0), Curie()))
julia> pushfirst!(ship, b)
SpaceVehicle(StagedRocket(
                StagedRocket(
                    Payload(40.0),
                    SmallTank(370.0),
                    Curie()),
                MediumTank(2050.0),
                Rutherford()))
julia> pushfirst!(ship, c)
SpaceVehicle(StagedRocket(
                StagedRocket(
                    StagedRocket(
                        Payload(40.0),
                        SmallTank(370.0),
                        Curie()),
                    MediumTank(2050.0),
                    Rutherford()),
                LargeTank(9250.0),
                Merlin()))
julia> popfirst!(ship)
StagedRocket(EmptyPayload(), LargeTank(9250.0), Merlin())
julia> popfirst!(ship)
StagedRocket(EmptyPayload(), MediumTank(2050.0), Rutherford())
julia> popfirst!(ship)
StagedRocket(EmptyPayload(), SmallTank(370.0), Curie())
julia> ship
SpaceVehicle(Payload(40.0))
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
261

While you are unlikely to spend much time writing completely generic data structures such as
arrays, linked lists, and dictionaries, you will find it helpful to turn custom data structures (rocket
stages) into collections. Once a data structure implements the interface of a well-established
category of types, such as a collection, you make a host of functions applicable to them. E.g. by
making a staged rocket iterable, we can suddenly use 
, 
, 
, 
, 
, and
map reduce filter sum collect
other functions with it for free.
For-loops and index access with square brackets both translate to Julia function calls such
as 
, 
, and 
iterate getindex
setindex!
Collections must as minimum support iterations. That is done by implementing two 
 methods for your collection type—one to start the iteration and another to get
iterate
the next element
Julia types can be configured with different capabilities using the holy traits pattern. Julia
collections can be configured with different traits such as 
 and 
IteratorSize
IteratorEltype
Collections where it is slow to calculate the number of elements should configure 
 to 
IteratorSize
SizeUnknown
Arrays offer fast access of elements at any index but don’t allow quick insertion of
elements except at the end of the array
Linked lists have slow access of elements by index but fast insertion and removal of
elements at the front
Implementing well established Julia interfaces can make your own data types more
versatile. E.g. by turning your data structure into a Julia collection you can leverage many
of the prebuilt Julia collection related functions
12.8 Summary
©Manning Publications Co. To comment go to liveBook 
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion 
262

13
This chapter covers
It does not take much time to explain what a set is and show what operations you can do on
them. What does take time is developing an understanding or intuition about what sort of
problems you can solve with sets.
Many problems related to organizing and locating data can be solved beautifully by utilizing sets
and set operations. But that is not always apparent.
In this chapter, we will go through both what sets are and what you can do with them and look at
various realistic examples showing the power of storing data in sets.
A lot of software requires organizing large amounts of data. Some examples are:
Photo albums
Email clients
Bug tracking systems
Online shopping
Software development projects
Specialist software like modeling software for geologists
Working with sets
Comparing differences between sets and arrays
Creating sets in different ways
Using union and intersect operations to locate items in different types of software
Understanding tradeoffs between usings sets and search operations
13.1 What kind of problems can sets help solve?
263
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

For a long time the most popular way of organizing data was tree structures. To find an item you
would drill down into subcategories until you found what you where looking for. The problem
with this approach is that many items can potentially exist underneath multiple subcategories not
just one.
A webshop such as McMaster-Carr, which sells a huge number of mechanical components, is a
great example of this problem.
Figure 13.1 McMaster-Carr webshop showing how screws can be categorized in multiple ways
264
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

On the side you can see various categories for screws:
System of measurement - Is the screw dimensions given in inches or metric?
Thread size - Actual measurement of the threads and the threads per inch
Material - Is the screw made of steel, plastic or wood?
Length - From under the screw head to end of threads
Head type - Is it flat, rounded or hex shaped?
There are far more categories than I have shown here. The point however is that you cannot turn
this into a tree hierarchy. Both a plastic screw and a steel screw can have a rounded head e.g.
Another case is photo albums. How do you organize them? You could organize pictures by every
family member, so that your wife, and each child get their own album. Or maybe albums based
on events such as visiting Barcelona or Hawaii makes more sense? Or maybe one wants more
activity based organization such as albums for particular type of attractions such as technical
museums or zoos.
Organization is difficult, so let us look at how sets and set operations can help us achieve this
task.
A set is a collection type just like arrays or dictionaries. Here is an example of creating a set:
Symbols instead of strings.
Attempted to add duplicates.
13.2 What is a Set?
julia> fruits = Set(["apple", "banana", "pear", "orange"])
Set{String} with 4 elements:
  "pear"
  "orange"
  "banana"
  "apple"
julia> fruits = Set([:apple, :banana, :pear, :orange]) 
Set{Symbol} with 4 elements:
  :pear
  :apple
  :banana
  :orange
julia> odds = Set([1, 3, 5, 7, 9])
Set{Int64} with 5 elements:
  5
  7
  9
  3
  1
julia> nodups = Set([3, 3, 3, 1, 2]) 
Set{Int64} with 3 elements:
  2
  3
  1
265
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

1.  
2.  
In the first case we create a set of fruits, where each fruit is represented by a string. The second
case is similar but we use symbols instead of strings to represent fruits. It is a useful example
since symbols are often used in Julia to represent keys.
Sets are like the keys of a dictionary, no element occurs twice. Notice with our last example, 
, we tried adding 3 multiple times. Like a dictionary, the elements don’t exist in any
nodups
particular order. When you iterate over a set, elements will appear in a specific order. However,
you have no control over this order. If you add or remove elements the order can change.
That behaviour is different from say an array where you have full control over how the adding
and removal of elements affect the order of the array. If you add an element to an array using 
 then every element stays in the same position as before. Every element can be accessed
push!
with the exact same index as previously.
We can get a better sense of what a set is by comparing its properties with that of an array.
Two desirable properties offered by sets are:
Sets are guaranteed to not have any duplicate elements.
Very quick to check if a set contains a specific object.
Arrays in contrast don’t offer a quick way of checking whether they contain a specific object,
because determining whether an array contains an element or not requires looking at every
element in the array. So looking for a particular element in an array of two million elements will
on average take twice as long as looking for it in an array of one million elements.
We call this a 
 relationship. However for a set the number of operations required to locate
linear
an element does not grow with the size of the set. There is no linear relationship.
Although sets can be implemented in different ways, thus in some variants it requires log(n)
checks on average to lookup an element in set of  elements.
n
To help you better understand the benefits of using sets, let us make some comparisons of sets
with arrays for different types of operations which sets are optimized for.
13.2.1 Comparing properties of sets and arrays
Table 13.1
Differences and similarities between sets and arrays
m
Property
Sets
Arrays
Duplicates allowed
No
Yes
Elements ordered
No
Yes
Random access
No
Yes
Quick membership test
Yes
No
Iterable
Yes
Yes
266
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

In a sorted array you can perform a 
. Here is a quick idea of how that works.
binary search
Consider the sorted array of numbers below:
It has 9 numbers. Say you are looking for the number 18. The number is somewhere in the range 
 (index range). Normally finding the number would require 8 comparisons, but with binary
1:9
search you begin in the middle 
 and ask if 
 or if 
.
A[5] == 11
18 > 11
18 < 11
Because the array is sorted, we can conclude 18 is somewhere in the upper half of the array, or
more specifically the index range 
. This search process is repeated by checking the middle of
6:9
this range. Since we don’t have a middle in this range we could round down the index to A[7]
. We find that 18 is above this value. Hence in 3 comparisons rather than 8 we locate the
== 15
answer.
Julia has several functions for doing this type of search:
The downside of using sorted arrays is that the programmer has to make sure the array is sorted
at all times. It makes insertions slow, as you must re-sort the array each time. Sets have the
benefit that they allow not only fast checks on membership (is this element in the set?), but also
fast insertion and removal.
We can turn the array  into a set . Both support membership test with 
 or its greek letter
A
S
in
equivalent . You can also use  or 
 to check if multiple elements are members.
issubset
SEARCHING A SORTED ARRAY
A = [2, 7, 9, 10, 11, 12, 15, 18, 19]
julia> searchsorted(A, 18)
8:8
julia> searchsortedfirst(A, 18)
8
julia> searchsortedlast(A, 18)
8
PERFORMING OBJECT MEMBERSHIP TESTS
julia> S = Set(A);
julia> 18 in S
true
julia> 18  A
true
julia> [11, 15]  A
true
julia> issubset([11, 15], S)
true
267
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Arrays look similar in behavior, but these operations will happen faster on a set. The exception is
for small collections. With few elements, no collection is as fast as an array. Once you go above
30-40 elements a set will start outperforming an unsorted array on membership tests.
However it is still advisable to use sets for small collections if maintaining a unique set of
elements is important and order isn’t. It helps 
 to the reader of your code, how it is
communicate
supposed to work.
Using more sophisticated collection types such as 
 or 
 really starts to pay off
Dictionary
Set
once you have large number of elements.
What happens when you attempt to create a 
 with duplicates.
Set
Duplicates are allowed in arrays but not in sets.
We will create a set and an array, with the same elements to demonstrate how random access and
ordering is entirely different.
If we use 
 or 
 they will iterate over the collections. You can see the order is
collect
foreach
different. The order is not guaranteed and can change between different versions of Julia.
SETS DON’T ALLOW DUPLICATES
julia> apples = ["apples", "apples", "apples"]
3-element Vector{String}:
 "apples"
 "apples"
 "apples"
julia> appleset = Set(apples)
Set(["apples"])
julia> length(appleset)
1
julia> numbers = [1, 1, 1, 2, 2, 2, 3, 3];
julia> length(numbers)
8
julia> S = Set(numbers)
Set([2, 3, 1])
julia> length(S)
3
RANDOM ACCESS AND ORDERING OF ELEMENTS
A = [3, 5, 7]
S = Set(A)
268
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

I am able to use brackets to access array elements by index.
But this is not possible to do with a set.
With an array 
 add each elements to a predictable location.
push!
However for sets, the element can end up anywhere.
With an array, 
 will remove the last element added.
pop!
However with a 
 this operation is best avoided, as you have no control over what element
Set
you actually end up removing.
In this case it may have been more appropriate for Julia to throw an exception, rather than letting
the user perform 
.
pop!
julia> collect(S)
3-element Vector{Int64}:
 7
 3
 5
julia> collect(A)
3-element Vector{Int64}:
 3
 5
 7
julia> foreach(print, S)
735
julia> foreach(print, A)
357
julia> A[2]
2
julia> S[2]
ERROR: MethodError: no method matching getindex(::Set{Int64}, ::Int64)
julia> push!(A, 9)
4-element Vector{Int64}:
 3
 5
 7
 9
julia> push!(S, 9)
Set([7, 9, 3, 5])
julia>  pop!(A)
9
julia> pop!(S)
7
269
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Set operations are used to combine sets to create new sets.
However set operations are not actually limited to sets. You can perform set operations between
arrays as well. The difference is that sets where designed to support it while arrays are not.
Arrays only perform set operations efficiently for small collections of elements.
Set operations allow you to answer questions such as:
Give me the pictures of Bob when he visited Spain and Greece
If 
 represents all images in your Photos application of your uncle Bob and 
 is a set of
Bob
Spain
all your Spain pictures and 
 is a set of all your pictures from Greece, then such a question
Greece
can be answered with either of these two equivalent expressions:
This demonstrates the usage of the the union and intersect operations. These can also be 
written using the  and  symbols.
The best way to visualize the behavior of the different set operations is to use Venn diagrams31.
Figure 13.2 Venn diagrams helping explain set operations
The two circles in each example represents the sets A and B. These are overlapping sets,
meaning some of the elements in A also exist in B.
The colored area shows which elements are included in the set resulting from the set operation.
For instance with a 
, all the elements in A and B are included in the result. For 
set union
set
13.3 How to use set operations
S = Bob  (Spain  Greece)
S = intersect(Bob, union(Spain, Greece))
270
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

 however only elements shared between A and B are part of the result. You might
intersection
recognize an analogy with the AND 
 and OR 
 operators used in Boolean logic. With 
&&
||
union
the elements must be in set A 
 in set B. With 
 they must be in set A 
 set B.
or
intersection
and
With 
 the order is important. 
 returns the elements in A which
set difference
setdiff(A, B)
remain when you 
 elements in A, which also exist in B.
remove
Let us look at a practical example of how this is used. We imagine having some sets of photo
captions.
So we have three people Bob, Joe and Eve who have been on various vacations abroad where
they have taken pictures. In this case we are representing those pictures as their caption text.
We want to use set operations to find pictures where they have been together. 
 is a set of all
bob
pictures Bob has been in, while 
 is a set of all pictures Joe has been etc.
joe
This code finds pictures where Bob and Joe where together on vacation.
Perhaps Eve broke up with Joe, and don’t want pictures with Joe in them. Eve can then use 
 to exclude Joe pictures.
setdiff
Perhaps Joe wants to find all vacations he spent together with somebody else?
Sets can of course contain any kind of object. Let us do some slightly less exciting set operations
with numbers.  is a set of mostly even numbers, while  contains mostly odd numbers.
A
B
We can get the set intersection in two different ways:
bob = Set(["Bob in Spain", "Bob in Greece", "Joe and Bob in Florida"])
joe = Set(["Joe in Texas", "Joe and Eve in Scotland", "Joe and Bob in Florida"])
eve = Set(["Eve in Wales", "Joe and Eve in Scotland", "Eve in Spain"])
julia> bob  joe
Set{String} with 1 element:
  "Joe and Bob in Florida"
julia> setdiff(eve, joe)
Set{String} with 2 elements:
  "Eve in Wales"
  "Eve in Spain"
julia> (bob  eve)  joe
Set{String} with 2 elements:
  "Joe and Eve in Scotland"
  "Joe and Bob in Florida"
A = Set([1, 2, 4, 6])
B = Set([1, 3, 5, 6])
271
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

And how about the set union:
And finally we can get the set difference of  and .
A
B
As you can see order matters with set difference.
The basic operations of sets are not hard to learn. What takes more time to get a sense of is when
you can use sets in your code.
Many times I have been surprised by how sets can often provide powerful and elegant solutions
to difficult problems. It is very easy to forget that sets are lying in your toolbox.
In the following sections we will look at problems which can be solved using sets. We will also
contrast using sets with other solutions.
We will first create sets for different product categories using the 
 constructor. Afterwards we
Set
13.4 How to use sets in your code
julia> A  B
Set{Int64} with 2 elements:
  6
  1
julia> intersect(A, B)
Set{Int64} with 2 elements:
  6
  1
julia> A  B
Set{Int64} with 6 elements:
  5
  4
  6
  2
  3
  1
julia> union(A, B)
Set{Int64} with 6 elements:
  5
  4
  6
  2
  3
  1
julia> setdiff(A, B)
Set{Int64} with 2 elements:
  4
  2
julia> setdiff(B, A)
Set{Int64} with 2 elements:
  5
  3
272
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

You may want a flat one if you want the screw flush with the surface. Headless screws are used
for things like set screws for axel-collars. Although for our purpose it is not important to know
what all these different head types are for.
The screw can have a drive style, which indicates what kind of tip you need to have on your
screwdriver to turn the screw around.
Material should be obvious:
Now these are list of of categories. Each item in the list is actually a 
. The set contains a
Set
product number uniquely identifying that screw. For practical reasons we are just going to invent
some 3-digit product numbers.
We will use ranges to quickly create a large number of product numbers.
If you look carefully at the numbers, you will see that they are overlapping. E.g some of the
will find screws matching different criteria by using the intersect and setdiff operations. 
The alternative solution will be based on defining a Screw composite type with different 
properties. We will use the filter function to find Screw objects matching desired criteria.
13.5 Searching for products using set operations
When dealing with products in say a Web-shop, we would typically use an SQL32 database. 
However conceptually what is being done is very similar to set operations, which is why we will 
expand on the example of buying screws from an online hardware shop.
A screw can have different head types:
head_type = [rounded, flat, headless, tslot]
drive_style = [hex, phillips, slotted, torx]
material = [aluminium, brass, steel, plastic, wood]
rounded = Set(100:4:130)
flat    = Set(101:4:130)
headless = Set(102:4:130)
tslot   = Set(103:4:130)
hex
= Set(100:108)
phillips = Set(109:115)
slotted  = Set(116:121)
torx     = Set(122:129)
aluminium = Set(100:3:120)
brass
= Set(101:3:120)
steel
= Set(102:3:120)
plastic   = Set(121:2:130)
wood
= Set(122:2:130)
273
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

aluminum product numbers are the same as the hex product numbers.
With these sets defined I can ask various useful questions such as:
Give me the screws in your product catalog which have a rounded head, made of wood and
which I can fasten with a torx screwdriver.
Answering this requires just a simple set operation:
Or how about getting all steel screws which can be fastened with a Phillips screwdriver?
Or maybe you just want to know whether t-slot screws which are not made of plastic exists.
This is one way of using sets, but you can accomplish the same with entirely different designs
not utilizing sets at all. Instead we could define a screw as a richer data type with properties for
each attribute.
Instead of dealing with screws as just a number, we have a data type with properties, which we
can potentially attempt to match some given search criteria.
You can see we have made the various properties to be represented by custom types 
, 
HeadType
 and 
. We could have made these strings or symbols, but instead we made
DriveStyle
Material
them particular types to catch cases where you assign an illegal category to any of the attributes.
julia> intersect(rounded, torx, wood)
Set{Int64} with 2 elements:
  124
  128
julia> intersect(phillips, steel)
Set{Int64} with 2 elements:
  114
  111
julia> setdiff(tslot, plastic)
Set{Int64} with 5 elements:
  107
  103
  115
  111
  119
struct Screw
    prodnum::Int
    headtype::HeadType
    drivestyle::DriveStyle
    material::Material
end
274
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

To represent different categories we use enumerations, or 
 for short. Enumerations exist in a
enum
number of different languages. In Julia they are a bit peculiar because they are defined using
macros.
Restart Julia as we already defined these variables, otherwise you will get complaints about
variables already being defined.
The giveaway is the  prefix. You can think of 
, 
 and 
 as instances of the 
@
hex slotted
torx
 type. In fact you can use the 
 constructor to create them.
DriveStyle
DriveStyle
However you can see the added type-safety in the last example. It is not possible to create other
values for 
 than the ones specified when the 
 was defined.
DriveStyle
enumeration
To demonstrate how we can use this type to locate screws with different properties we need to
create some test data to operate on.
This code create an array of screws with product numbers in the range 100 to 150. We pick
values for each property at random. The 
 function returns an array of every possible
instances
value for an enumeration.
13.5.1 Defining and using enumerations
@enum HeadType rounded flat headless tslot
@enum DriveStyle hex phillips slotted torx
@enum Material aluminum brass steel plastic wood
julia> DriveStyle(2)
slotted::DriveStyle = 2
julia> DriveStyle(3)
torx::DriveStyle = 3
julia> DriveStyle(4)
ERROR: ArgumentError: invalid value for Enum DriveStyle: 4
13.5.2 Creating test data to perform queries on
function make_screw(prodnum)
    headtype = rand(instances(HeadType))
    drivestyle = rand(instances(DriveStyle))
    material = rand(instances(Material))
    Screw(prodnum, headtype, drivestyle, material)
end
screws = map(make_screw, 100:150)
julia> instances(DriveStyle)
(hex, phillips, slotted, torx)
julia> instances(Material)
(aluminium, brass, steel, plastic, wood)
275
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

First we found screws matching our desired criteria using set operations. Now we will find
desired screws by searching through all the screws in an array and checking each screw if it
matches all our desired criteria. We will do that by specifying predicate functions. A predicate
function will take a screw as an argument and return 
 or 
 depending whether the
true
false
criteria the predicate function test for was met. 
 will test if the given screw has
isroundwood
rounded heads made of wood.
We can then use this predicate (function returning a Boolean value) to filter screws:
How about finding what non-plastic t-slot screws are offered in the store?
The best solution for your case is not always easy to determine. But it is worth knowing about
different approaches. Sometimes it makes sense to combine solutions. You can put these screw
objects into sets as well.
We can use the 
 function to produce sets which can be reused later.
filter
13.5.3 Searching for screws
function isroundwood(screw)
    screw.headtype == rounded &&
    screw.material == wood
end
julia> roundedwood = filter(isroundwood, screws)
3-element Vector{Screw}:
Screw(100, rounded, torx, wood)
Screw(113, rounded, slotted, wood)
Screw(129, rounded, torx, wood)
julia> function isnonplastic(screw)
screw.headtype == tslot &&
screw.material != plastic
end
julia> nonplastic = filter(isnonplastic, screws)
15-element Vector{Screw}:
Screw(105, tslot, hex, wood)
Screw(106, tslot, hex, wood)
Screw(107, tslot, hex, brass)
Screw(108, tslot, phillips, steel)
Screw(117, tslot, phillips, wood)
Screw(118, tslot, hex, wood)
Screw(125, tslot, phillips, wood)
Screw(128, tslot, phillips, wood)
Screw(130, tslot, phillips, wood)
Screw(131, tslot, torx, brass)
Screw(133, tslot, hex, wood)
Screw(134, tslot, slotted, wood)
Screw(138, tslot, hex, steel)
Screw(141, tslot, phillips, steel)
Screw(146, tslot, torx, brass)
13.5.4 Putting screw objects into sets
276
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

We can then use these sets in set operations.
However this solution can be further improved upon.
Frequently buyers know the product number of the screw they want, and want to lookup the
screw using this number rather than a complex search critera. By storing screws in a dictionary,
where the key is the product number we can solve this use case.
This code change allows us to get back to the original solution where we use product numbers in
our sets. Let us first make some new sets based on product numbers.
julia> issteel(screw) = screw.material == steel;
julia> steel_screws = Set(filter(issteel, screws));
julia> ishex(screw) = screw.drivestyle == hex
julia> hex_screws = Set(filter(ishex, screws))
julia> steel_screws  hex_screws
Set(Screw[
    Screw(126, headless, hex, steel),
    Screw(115, headless, hex, steel),
    Screw(121, flat, hex, steel),
    Screw(107, headless, hex, steel),
    Screw(108, flat, hex, steel)
])
13.5.5 Looking up screws using dictionaries
julia> screwdict = Dict(screw.prodnum => screw for screw in screws)
Dict{Int64,Screw} with 51 entries:
  148 => Screw(148, rounded, hex, brass)
  124 => Screw(124, rounded, hex, aluminium)
  134 => Screw(134, tslot, slotted, wood)
  136 => Screw(136, rounded, torx, aluminium)
  131 => Screw(131, tslot, torx, brass)
  144 => Screw(144, rounded, slotted, steel)
  142 => Screw(142, flat, slotted, steel)
  150 => Screw(150, rounded, hex, steel)
  ...
julia> screwdict[137]
Screw(137, headless, phillips, aluminium)
julia> screwdict[115]
Screw(115, flat, phillips, aluminium)
prodnums = keys(screwdict)
function isbrass(prodnum)
    screw = screwdict[prodnum]
    screw.material == brass
end
brass_screws = Set(filter(isbrass, prodnums))
function istorx(prodnum)
    screw = screwdict[prodnum]
    screw.drivestyle == torx
end
torx_screws = Set(filter(istorx, prodnums))
277
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Now we are back to the elegance of using set operations to pick desired products, based on
product keys in sets.
When developing larger pieces of software, particularly in a team, companies will usually use
some form of bug tracking tool. Commonly these are web applications which allow testers to
submit descriptions of bugs.
Managers or product specialists may then review these bugs and assign priorities and severity,
before the bugs finally gets assigned to software developers.
Some common attributes recorded with a bug might be:
Project - What software project is it part of?
Priority - How important is this bug to fix?
Severity - Is it a minor annoyance or a crash in critical functionality?
Component - Is this in a user interface, client, server etc?
Assignee - Who is assigned to deal with the bug currently?
Just like with products, bugs will usually be uniquely identified by a bug number. Thus much the
same kind approach as described before can be used. You can have bugs in dictionaries where
the keys are the bug numbers.
We can define sets composed of different bug numbers. Here are some questions we can imagine
being solved using sets.
What are the most critical bugs assigned to Bob in the Lunar Lander project?
It may not be practical to have names for each set like this, and we want sets organized more
according to the fields in the bug tracker. We could use dictionaries to group related sets.
When doing the set operation on multiple objects, it may be more practical to not use the
operator symbols. This is equivalent:
13.6 Search in bug tracker using sets
julia> brass_screws  torx_screws
Set([100, 122, 144])
julia> [screwdict[pn] for pn in brass_screws  torx_screws]
3-element Vector{Screw}:
Screw(100, rounded, torx, brass)
Screw(122, tslot, torx, brass)
Screw(144, flat, torx, brass)
bob  critical  lunar_lander
assignees["Bob"]  severity[:critical]  projects["Lunar Lander"]
278
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

A manager may ask:
What top priority bugs are being handled by Bob and Eve?
We could have looked at many more examples. But hopefully this gives you a good idea of how 
you could use sets to simplify problems in your applications.
13.7 Relational databases and sets
If you have worked with SQL and relational databases before, then a lot of what you have seen 
in this chapter might look familiar. In the SQL database query language, one can perform many 
operations similar to set operations. What is called an inner join in the database world is 
equivalent to a set intersection.
Relational databases are built upon a branch of mathematics called relational algebra, which is 
about modeling data and queries on it.
In this chapter, we have explored set theory, which is more basic. With relational databases, you 
can create tables of data with multiple columns which have relations to other tables. The Julia
data structure most similar to database tables is called a DataFrame 33 and exists in the 
DataFrames package34.
For in-depth coverage of the DataFrames package, see Bogumił Kaminski’s Julia for Data 
Analysis(Manning, 2022.
intersect(assignees["Bob"], severity[:critical], projects["Lunar Lander"])
assignees["Bob"]  assignees["Bob"]  priorities[:top]
279
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Sets can help you organize data such as photo albums, defects in a bug tracking tool or
items sold in a web shop
Sets don’t have duplicates and allow very quick membership tests unlike arrays of
elements
Elements in sets have no well defined order, unlike arrays. Elements cannot be inserted at
specific positions in the set
Create a set by providing an array of elements such as Set([4, 8, 10])
Combine sets using set operations such as 
, 
 and 
union intersect
setdiff
Check if an element  is in a set  with 
 function. Can be written as 
 or 
x
S
in
in(x, S)
x in
S
Create an enum type with the 
 macro. 
, creates an
@enum
@enum Fruit apple banana
enum type 
 with legal values 
 and 
Fruit
apple
banana
We can achieve operations similar to set operation using 
 on an array. However
filter
performance will not be equally good for large datasets
Set theory and relational algebra (used in relational databases) allow you to do similar
operations. However sets deal with values while relational database deal with tables and
their relations
13.8 Summary
280
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

14
This chapter covers
In chapter 4 we explored basic operations such as 
 on one-dimensional arrays, called
push!
vectors. In this chapter we will focus more on how work with multi-dimensional arrays such as
matrices.
What can you use a matrix and vector for? They can be combined to solved a great number of
problems. It is popular to use vectors in an geometric interpretation. In this case they represent
points in space. You can use matrices to move and rotate these points.
You can even use matrices to solve mathematical equations. They are also very popular in
machine learning. A matrix can be used to represent an image. Every element in a matrix can
represent the color of a single pixel. Each of these topics would deserve their own chapters or
books, so in this chapter we will only cover the essentials of working with vectors and matrices.
A matrix or a vector is not just a dumb container of numbers. For instance in mathematics, sets,
tuples, and vectors may all look like a list of numbers and hence seem similar. But what you can 
 with them is different.
do
The study of vectors and matrices is part of the field of mathematics called 
. In
linear algebra
linear algebra we call single values such as 1, 4, and 8 
. While multiple values in a row or
scalars
Working with vectors and matrices
Working with numbers in matrices, and performing calculations 
Slicing and dicing arrays Extracting subsections of an array. 
Concatenating arrays along different dimensions to form larger arrays
14.1 Vectors and matrices in mathematics
281
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

column are 
, tables are 
 and if the data is arranged in a 3D-array it may be
vectors
matrices
referred to as a 
. Vectors can further be divided into column vectors and row vectors.
cube
Figure 14.1 Arrays of different dimensions
A matrix can be constructed either by specifying multiple rows stacked on top of each other or
by columns lined up, one after the other. When constructing a matrix from row vectors, we
separate each row with a semicolon . Notice how you don’t separate individual elements with a
;
comma. If you have forgotten about this then review the discussion of row vectors and column
vectors in chapter 4.
To create a matrix from multiple columns, we can define each column separately and then
combine them into a matrix.
14.2 Constructing a matrix from rows and columns
julia> table = [2  6 12;
                3  4 12;
                6  2 12;
                12 1 12]
4×3 Matrix{Int64}:
  2  6  12
  3  4  12
  6  2  12
 12  1  12
282
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

This is identical to writing the column vectors inline like this:
Notice how Julia gives us a summary of what kind of 
 we are getting as a result with the
Array
line 
. This tells us that Julia made an array with 4 rows and 3 columns,
4×3 Matrix{Int64}
where each element is of type 
.
Int64
You can query an arbitrary array about these properties. 
 gives us the type of each
eltype
element in the array. 
 tells us the number of dimensions, while 
 tells us the number of
ndims
size
components (elements) along each dimension. Normally we think of dimensions as length,
height and depth, but in this case we will normally speak of rows and columns.
Type of each element in array.
Number of rows and columns.
Number of dimensions.
The next illustration helps clarify what these different properties means. It shows vectors and
matrices of different shapes. They have different number of rows and columns. Different
orientation and dimensions.
julia> x = [2, 3, 6, 12]
julia> x = [6, 4, 2, 1]
julia> x = [12, 12, 12, 12]
julia> table = [x x x]
4×3 Matrix{Int64}:
  2  6  12
  3  4  12
  6  2  12
 12  1  12
table = [[2, 3, 6, 12] [6, 4, 2, 1] [12, 12, 12, 12]]
julia> eltype(table) 
Int64
julia> size(table) 
(4, 3)
julia> ndims(table) 
2
283
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Figure 14.2 Properties of arrays of different shape
If you come from other programming languages it can be easy to confuse these array concepts:
size - The dimensions of an array
length - Total number of elements in array
norm - Magnitude of vector
We created a table with 4 rows and 3 columns, giving a total of 12 elements.
14.3 The size, length and norm of an array
julia> length(table)
12
284
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

The 
 function is trickier to grasp. To explain it we will use a small vector, with the elements
norm
3 and 4.
Looking at a right-angled triangle will help you visualize what 
 is doing. You can think of
norm
the elements of the vector as the sides  and  in the triangle. 
 gives us the length of the
a
b
norm
longest side, the 
.
hypotenuse
Figure 14.3 A right-angled triangle with sides of length a, b and h
The 
 tells us the relationship between all the sides in a right-angled triangle.
Pythagoras' theorem
You can think of 
 as applying the Pythagorean theorem to figure out the length of the 
norm
.
hypotenuse
Julia has great support for selecting slices of arrays of different dimensions. This flexibility
comes from the fact that the 
 and 
 functions which are invoked when we
setindex!
getindex
use square brackets 
 to access elements or assigning to them. We are going to explore how this
[]
slicing works.
We begin simple by first looking at accessing individual elements on a 1-dimensional array.
Figure 14.1 illustrate how one or more elements can be selected in on-dimensional arrays. While
14.4 Slicing and dicing an array
julia> using LinearAlgebra
julia> norm([3, 4])
5.0
Table 14.1
Relation between element access and Julia function calls
m
Syntax sugar
Translates to
Description
xs[i]
getindex(xs, i)
Get element at index i
xs[i,j]
getindex(xs, i, j)
Get element at row  and column 
i
j
xs[i] = 42
setindex!(xs, 42, i)
Set element at index i
xs[i,j] = 42
setindex!(xs, 42, i, j)
Set element at row  and column 
i
j
285
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

the figure shows selections within row vectors, the same principles apply to column vectors.
You can use 
 and 
 within square brackets to refer to the first or last element in a vector,
begin
end
along a row or column. In Julia the first element in an array is at index 1 by default. However it
is possible to create arrays with any start index in Julia. That makes the 
 keyword very
begin
useful.
Figure 14.4 Slicing a 1-dimensional array  in different ways.
A
Notice how there are many different ways of accessing the same elements. Say we have an array 
, then 
 and 
 would represent the exact same element.
A
A[3]
A[begin+2]
For an array with four elements, as in the first two examples, 
 and 
 refers to the same
A[4]
A[end]
element. Likewise 
 and 
 grabs the same array element.
A[3]
A[end-1]
We can experiment with these concepts in the Julia REPL:
286
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

If you don’t care about the specific index at all but just want all the elements you can write 
.
A[:]
How is that different from just writing  you may ask? All slice operations return copies of data.
A
This example will help clarify:
Do you see how the second element of 
 got changed but not the second element of ? Had you
B`
A
written 
 instead of 
 then the second element would have been changed in  as
B = A
B = A[:]
A
well since  and  would have referred to exactly the same array object.
A
B
But what if we want to select a slice of an array an not make a copy? Especially when working
with very large amounts of data it can kill performance to frequently copy thousands of elements
julia> A = collect('A':'F')
6-element Vector{Char}:
 'A'
 'B'
 'C'
 'D'
 'E'
 'F'
julia> A[begin+1]
'B': ASCII/Unicode U+0042
julia> A[end-1]
'E': ASCII/Unicode U+0045
julia> A[2:5]
4-element Vector{Char}:
 'B'
 'C'
 'D'
 'E'
julia> A[begin+1:end-1]
4-element Vector{Char}:
 'B'
 'C'
 'D'
 'E'
julia> A = [8, 1, 2, 7];
julia> B = A[:];
julia> B[2] = 42
42
julia> B
4-element Vector{Int64}:
  8
 42
  2
  7
julia> A
4-element Vector{Int64}:
 8
 1
 2
 7
287
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

in some tight inner loop. In these cases we can create what is called a 
 into a subsection of
view
the array. In these cases the slices are not copies of elements of an array but those elements
themselves. We turn a slice into a view by using the 
 macro:
@view
The last result shows that changing the second element of  caused the forth element of  to be
B
A
changed.
A lot of these examples should be relatable since we have worked with one-dimensional arrays
in many previous chapters. It gets more interesting when we are dealing with slices for
multi-dimensional arrays, such as matrices.
Let us create a 2D matrix  to experiment on, using Julia’s 
 function. 
 takes an 
A
reshape
reshape
 as input. We input the range 
, which is a valid 
 object.
AbstractArray
1:12
AbstractArray
Julia sees this as a 1-dimensional array with 12 elements. We rearrange these elements to
become a matrix with 3 rows and 4 columns. Also called a 3x4 matrix.
We are going to slice this matrix in different ways, but first I like to give you some practical
advice on how to think about slicing, so it makes more sense to you.
IMPORTANT
Matrix Shape
The shape of a matrix is how many rows and columns it has. Hence the 
function for changing the number of rows and columns is called reshape in 
Julia. Keep in mind that the length of the matrix cannot be changed by 
reshape. You can reshape an array A of six elements to a 3x2 or 2x3 matrix 
but you cannot reshape it to a 3x3 matrix as that contains nine elements. See 
figure 14.5
julia> B = @view A[3:end]
2-element view(::Vector{Int64}, 3:4) with eltype Int64:
 2
 7
julia> B[2] = 1331
1331
julia> A
4-element Vector{Int64}:
8
    1
    2
 1331
julia> A = reshape(1:12, 3, 4)
3×4 reshape(::UnitRange{Int64}, 3, 4) with eltype Int64:
 1  4  7  10
 2  5  8  11
 3  6  9  12
288
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Figure 14.5 An array can be reshaped to matrices with the same number of elements. Red cross
indicate that you cannot reshape an array of six elements to one with nine elements.
I like to think about array slicing in terms of the set intersection operation ∩. Thus 
 can
A[2, 3]
be read as:
Give me the intersection of all the elements for row 2, and all the elements of column 3.
Figure 14.2 visualize this idea. The light blue represents the row and columns we have selected,
and the 
 represent the intersection between these row and column selections.
darker blue
289
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Figure 14.6 Slicing 2-dimensional arrays.
This conceptualization makes it easier to understand the selection 
. We can read
A[2:3, 2:4]
this as:
Give me the intersection of all the elements in row 2 to 3, and columns 2 to 4.
Following this logic it becomes apparent how you would select an entire row, or entire column in
a matrix. We can experiment with this in the REPL:
julia> A[1, 2]
4
julia> A[3, 4]
12
julia> A[:, 4]
3-element Vector{Int64}:
 10
 11
 12
julia> A[2, :]
4-element Vector{Int64}:
  2
  5
  8
 11
290
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

It is also worth noting that even multidimensional arrays can be treated as 1-dimensional ones.
Data does not always come in the shape and form you like to perform matrix operations on them.
You may have  vectors but really wanted a matrix with  columns instead.
n
n
Fortunately Julia has a number of functions for concatenating matrices. This first example shows
how we can concatenate two row vectors either horizontally using 
 or vertically using 
.
hcat
vcat
Figure 14.7 Horizontal and vertical concatenation of row vectors
The 
 function allows you to specify along which dimension you are concatenating. This is
cat
useful if you are dealing with higher dimension arrays.
14.5 Combining matrices and vectors
julia> A[1]
1
julia> A[4]
4
291
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

We can perform similar operations with column vectors.
Figure 14.8 Horizontal and vertical concatenation of column vectors
The same principles applies to when combining matrices. We can concatenate along any
dimension. Horizontal and vertical concatenation have their own functions 
 and 
hcat
vcat
because they are done so frequently.
292
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Figure 14.9 Horizontal and vertical concatenation of matrices
These concatenation functions can take any number of argument. You are not limited to two.
293
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

When working with matrices we often need special kinds of matrices. Creating matrices with
only zeros or ones is so common that we have special functions to do that:
Notice how you can optionally specify as the first argument what type you want each element to
be. If you don’t specify type, then it will default to 
.
Float64
Creating a whole array of random numbers is also often practical. For instance in deep learning,
large matrices with random values are frequently used. Often we use use random values to create
test data.
Sometimes you just want to fill a whole matrix with a specific value:
14.6 Creating matrices
julia> x = [1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3
julia> y = [8, 6, 4]
3-element Vector{Int64}:
 8
 6
 4
julia> hcat(x, y, x, y)
3×4 Matrix{Int64}:
 1  8  1  8
 2  6  2  6
 3  4  3  4
julia> hcat(x, 2y, 2x, 3y)
3×4 Matrix{Int64}:
 1  16  2  24
 2  12  4  18
 3   8  6  12
julia> zeros(Int8, 2, 3)
2×3 Matrix{Int8}:
 0  0  0
 0  0  0
julia> ones(2, 3)
2×3 Matrix{Float64}:
 1.0  1.0  1.0
 1.0  1.0  1.0
julia> rand(UInt8, 2, 2)
2×2 Matrix{UInt8}:
 0x8e  0x61
 0xcf  0x0d
julia> fill(12, 3, 3)
3×3 Matrix{Int64}:
 12  12  12
 12  12  12
 12  12  12
294
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Vectors and matrices is a huge topic and if we had more time we would have looked at the
geometric interpretation of vectors and matrices. What are some possible uses? We could have
represented the orientation of our rocket with a matrix and its position as a vector. We could
have used matrices to rotate or move the rocket around in the coordinate system.
If you want to get more in depth coverage of how to work with matrices then a great book to
expand your Julia knowledge is Julia for Data Analysis(Manning, 2022) by Bogumił Kaminski’s.
Arrays can be used to define column vectors, row vectors, and matrices.
Matrices are two-dimensional arrays which can be constructed in many ways. Most
common is to define it as a set of rows, but it is also possible to define matrices as a set of
columns.
Arrays have properties such as 
, 
 and 
. These describe the number of
ndims size
length
dimensions, number of elements along each dimension, and total number of elements in
the array.
Arrays can be sliced by specifying ranges, which also generalizes to matrices. You can
give ranges for rows and columns to cut out a submatrix.
Slices are copies of data. If you don’t want slices to be copies but directly reference data
in the original array then you can create a slice view with the 
 macro.
@view
Matrices and vectors can be combined horizontally and vertically using 
 and 
.
hcat
vcat
For arrays of higher dimensions, we would use 
 and specify the dimension to
cat
concatenate along as an argument.
Matrices can quickly be created with functions such as 
, 
, 
, and 
.
rand fill ones
zeros
14.7 Summary
295
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Part-4
Software engineering is about how we organize and structure larger programs so they are easier
to maintain, modify and evolve.
Functional programming helps create more maintainable software and gives new perspectives on
how to write code.
Chapter 16 focuses on the physical organization of software into modules, directories and files. It
also ties in with dependency management. Large software will be composed of many packages
made by different teams. We need a solid system to handle versioning of software packages that
depend on each other.
Software engineering
296
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

A
This appendix covers downloading and installing Julia on macOS, Linux, and Windows. We will
also look at how you can configure your Julia environment to improve your ability to work
efficiently with Julia.
The instructions rely on your understanding of concepts like the path for command utilities and
knowing how to set it. These things will vary depending on operating system. For Unix-like
systems such as macOS and Linux, you configure the search path by editing configuration files
such as 
, 
 or 
. In these files, we can set
.zshrc
.profile
.config/fish/config.fish
environment variables such as 
, 
 and 
. If you are unfamiliar with
PATH EDITOR
JULIA_EDITOR
using the Unix command line, here are some resources:
erikexplores.substack.com/p/unix-crash-course
erikexplores.substack.com/p/unix-pipes
erikexplores.substack.com/p/unix-shells-and-terminals
Installing and configuring Julia 
environment
297
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

1.  
2.  
1.  
2.  
1.  
Figure A.1 The Julia homepage. Click the green download button.
Go to the website julialang.org/downloads
Select the right Julia version for your operating system. We recommend Julia 1.7 or
higher.
Open your downloaded 
 file named something like 
.
.dmg
julia-1.7.3-mac64.dmg
Drag and drop the Julia application bundle to your 
 folder.
/Applications
This completes the installation. It is that easy. The next step is for convenience. It makes it
possible to launch Julia by simply typing 
 in the terminal, rather than having to click the
julia
Julia application icon.
Open the 
 console application.
Terminal.app
A.1 Download Julia
A.2 Install on Mac
298
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

2.  
1.  
2.  
Create a symbolic link from installation location to a directory in your path, such as 
.
/usr/local/bin
There are many different Linux distributions, but in the instructions here, I am assuming there is
a 
 directory where you store downloaded files. Adjust command given based on
Downloads
where you store downloads on your Linux.
Unpack the 
 file named something like 
.
.tar.gz
julia-1.7.3-linux-x86_64.tar.gz
Move unpacked directory to 
. If 
 does not exist, create it.
/opt
/opt
Next, to be able to easily run Julia from the terminal, we will make a symbolic link.
You will get an 
 file as the download, which is installed like any other Windows software
.exe
by double-clicking it.
To a make it easy to run Julia from the terminal, it is useful to configure your shell environment
for Julia. If your shell is the Z shell, 
, you need to edit the 
 in your home directory. If
zsh
.zshrc
you use Bourne Again Shell, 
, you need to edit the 
 file instead. Z shell is
bash
.profile
currently the standard on macOS.
Here is an example of configuring Julia for use with bash shell on Linux, where 
, 
,
Sublime subl
is used as the text editor for Julia code.
You may use a custom shell. For instance, I use the fish shell, which is a modern user-friendly
shell for all Unix-like systems. In this case, we edit the 
 in our
.config/fish/config.fish
home directory. Here, I am configuring my Mac to use the VS Code editor, which is launched
with the 
 command.
code
A.3 Install on Linux
A.4 Install on Windows
A.5 Configure on Mac and Linux
$ ln -s /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia /usr/local/bin/julia
$ sudo mkdir /opt
$ cd $HOME/Downloads
$ sudo mv julia-1.7.3 /opt
$ sudo rm /opt/bin/julia # remove any old link
$ sudo ln -s /opt/julia-1.7.3/bin/julia /opt/bin/julia
# ~/.zshrc file
export JULIA_EDITOR=subl
export PATH=/usr/opt/bin:$PATH
299
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

On Windows, environment variables are configured through the graphical user interface shown
in figure A.2
Figure A.2 Dialog for configuring Windows binary search path
The 
 environment variable is not necessary to set on Windows, as the operating
JULIA_EDITOR
system will open a dialog and ask you what editor to use when needed. Windows will then
associate an application with 
 files.
.jl
Configuring the shell environment is likely less needed on Windows than on Linux/macOS
because command line interfaces are not as frequently used by Windows developers. Developers
interested in the command line on Windows may prefer to use the Window Subsystem for Linux
.
(WSL)
A.6 Configure on Windows
# ~/.config/fish/config.fish file
set -x JULIA_EDITOR code
set -x PATH /usr/local/bin $PATH
300
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

Now that Julia is installed and configured, we can try to run it. Either click on the Julia
application icon or open a terminal window and type 
 followed by enter.
julia
When Julia starts, you enter what is called the Julia REPL (read-evaluate-print-loop). The Julia
REPL is a program which accepts Julia code, evaluates it and then prints the result of evaluating
that code.
Each line of code is usually referred to as an expression. When you press enter you evaluate the
expression and Julia shows what value the expression evaluates to.
NOTE
How do you exit Julia?
You can interrupt anything you are doing in Julia by holding down the 
 key
Ctrl
and pressing . We write this as 
. To exit Julia you hold down 
,
C
Ctrl-C
Ctrl-D
or type ` exit()`.
The Julia REPL can be in different modes indicated by the prompt currently showing. A green
prompt with the name 
 means you are in the standard Julia mode. Here are the other
julia>
modes you will see in code examples:
help?> Lookup help about a function or type. Enter with question mark .
?
pgk> Package mode is for installing and removing packages. Enter package mode with
square bracket .
]
shell> Shell mode allows you to issue Unix shell commands such as 
, 
 and 
.
ls cp
cat
Enter with semicolon .
;
You can exit a mode by going to the start of the prompt and pressing backspace. That will take
A.7 Running Julia
A.8 Julia REPL Modes
$ julia
_
   _
_ _(_)_
|  Documentation: https://docs.julialang.org
  (_)
| (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.7.2 (2022-02-06)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |
julia> print("hello world")
hello world
julia> 3 + 2
5
julia> reverse("ABCD")
"DCBA"
301
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

you back to Julia mode.
When reading this book, look at the prompt to determine what mode we are in. If you don’t put
the REPL in the correct mode, then the commands you issue will not work. Here is an example
of being in help mode. The prompt will be yellow then:
There are several packages which, while not necessary, can improve your workflow. Enter
package mode to install them:
You load the package into the Julia environment with the 
 keyword:
using
The 
 package gives syntax highlighting and better history search in the REPL. 
OhMyREPL
 allows you to step through code with 
 macro. For instance, this will step into
Debugger
@enter
the execution of the 
 function. You step with  and exit with 
.
titlecase
n
Ctrl-D
The most interesting and useful package is Revise, which allows you to monitor code changes.
Normally, you load the code of a single file into the Julia REPL with the 
 function. If
include
you use the 
 function from the Revise package instead, then the code in the file will be
includet
monitored. Say you create a file 
 with the code:
hello.jl
We can load this file in the Julia REPL using Revise:
You can modify the source code file to say "hello Mars" and this change will be picked up
without needing to explicitly loading the file again:
A.9 Installing third party packages
help?> 4 / 2
  /(x, y)
  Right division operator: multiplication of x by the inverse of y on the right. Gives 
  floating-point results for integer arguments.
(@v1.7) pkg> add Revise, OhMyREPL, Debugger
   Resolving package versions...
julia> using Revise, OhMyREPL, Debugger
julia> @enter titlecase("hello")
greet() = "hello world"
julia> includet("hello.jl")
julia> greet()
"hello world"
julia> greet()
"hello Mars"
302
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

1.mFortran is an old language for scientific computing
2.mNeural networks are a kind of algorithm inspired by the workings of the human brain.
3.mC and C++ are two related and widely used statically typed languages for systems programming
4.mJava is used for a lot of web server software and on Android phones
5.mLua was originally made as a configuration language but is today primarily used to write computer games
6.mPython is one of the most popular languages for data science and machine learning today
7.mTensorFlow is popular machine learning library and platform for Python.
8.mPyTorch is a popular machine learning framework for Python.
9.mMetaprogramming is code which writes code. An advanced concept not covered in this book.
10.mLearn more about the Flux machine learning library here: https://fluxml.ai
11.m
Mocha 
is 
a 
Julia 
Machine 
learning 
library 
created 
by 
MIT: 
https://developer.nvidia.com/blog/mocha-jl-deep-learning-julia/
12.m
REPL stands for read-evaluate-print-loop and refers to an interactive command line for a programming
language
13.mA number literal is made up of digits from 0 to 9 instead of being expressed as a named variable.
14.mIn 1972 Hewlett-Packard released HP-35, the first calculator with sine and consine functions.
15.mProduct is the result of multiplying numbers. In contrast to sum which is the result of addition.
16.mRead more about Julia’s Statistics module at https://docs.julialang.org/en/v1/stdlib/Statistics/
17.mA character literal is a character from A to Z rather than e.g. a variable or constant containing a character.
18.mLookup the FixedPointDecimals.jl or CurrenciesBase.jl to work with currency data.
Notes
303
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

19.m
Functions used to set and get values within a more complex data structure, are referred to as accessor
functions, or simply accessors.
20.m
Most mainstream languages today are object-oriented. They are designed to couple behavior into types and
reuse functionality through what we call inheritance.
21.m
A class in object-oriented programming is a type that can be part of a type-hierarchy and has associated
functions called methods.
22.mA recursive function is a function which calls itself, as opposed to using a loop.
23.m
Function overloading is a feature of many statically typed languages. It allows defining the same function
multiple times with arguments of different types. When the code gets compiled, the compiler picks the right
function.
24.m
A data structure is a particular way of organizing data in a computer program. Arrays, strings, binary trees,
linked lists, hash tables are examples of data structures. But almost any composite type could be thought of a
defining a data structure.
25.m
In a dynamic language you don’t have a compiler analyzing type correctness before a program is allowed to
run. Julia has a compiler but it is invoked at runtime.
26.m
A microprocessor doesn’t understand programming languages such as Julia or Java. It only understands
machine code.
27.m
Rocket Lab is a space company originating in New Zealand which launches small satellites into orbit of a
few hundred kg.
28.m
A Matryoshka is a Russian nesting doll. Each doll has a smaller wooden doll inside. See:
wikipedia.org/wiki/Matryoshka_doll
29.mMarkdown is a lightweight markup language for creating formatted text using a plain-text editor.
30.mIDE is short for Integrated Development Environment. Visual Studio and IntelliJ IDEA are some examples.
32.m Structured Query Language (SQL), is a specialized language for formulating database queries. A query is a
request for data in a database matching one or more criteria.
33.mA dataframe has multiple named columns. Each column can contain different types of data.
34.mDataFrames package dataframes.juliadata.org/
31.mVenn diagrams are usually used to illustrate the logical relationships between two or more sets of items.
304
©Manning Publications Co. To comment go to liveBook  
https://livebook.manning.com/#!/book/julia-as-a-second-language/discussion

