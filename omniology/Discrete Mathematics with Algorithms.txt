DISCRETE MA THEMA TICS 
WITH ALGORITHMS 
Michael O. Albertson 
Joan P. Hutchinson 
Smith College 
[I] 
WILEY 
JOHN WILEY & SONS 
New York 
Chichester 
Brishane 
Toronto 
Singapore 

Copyright © 1988, by John Wiley & Sons, Inc. 
All rights reserved. Published simultaneously in Canada. 
Reproduction or translation of any part of 
this work beyond that permitted by Section 
107 or 108 of the 1976 United States Copyright 
Act without the permission of the copyright 
owner is unlawful. Requests for permission 
or further information should he addressed to 
the Permissions Department, John Wiley & Sons. 
Library III Clingre.H Cataloging in Publication Data: 
Albertson, Michael O. 
Discrete mathematIcs with algorithms. 
Includes indexes. 
I. Mathematics- 1961-
2. Electronic data 
processing-- Mathematics. 
I. Hutchinson, Joan P. 
II. Title. 
l)A39.2.A43 
19X8 
~ 10 
X8·235 
ISBN 0-471·K4902·1 
Printed in the United States of America 
10 ~ K 7 h 5 J J 2 

CONTENTS 
Chapter I SETS AND ALGORITHMS: AN INTRODUCTION 
I 
I : I 
Introduction 
1:2 
Binary Arithmetic and the Magic Trick Revisited 
5 
1 :3 
Algorithms 
8 
1 :4 
Between Decimal and Binary 
15 
1 :5 
Set Theory and the Magic Trick 
~O 
1:6 
Pictures of Sets 
~5 
1 :7 
Subsets 
29 
1 :8 
Set Cardinality and Counting 
35 
1 :9 
Functions 
40 
1: 10 Boolean Functions and Boolean Algebra 
51 
1:11 A Look Back 
59 
Chapter 2 ARITHMETIC 
65 
2: I 
Introduction 
65 
2:2 
Exponentiation, A First Look 
6R 
2:3 
Induction 
71 
2:4 
Three Inductive Proofs 
80 
2:5 
Exponentiation Revisited 
88 
2:6 
How Good Is Fast Exponentiation? 
<)1 
xi 

CONTENTS 
2:7 
How Logarithms Grow 
2:8 The "Big Oh" Notation 
2:9 2n i= O(p(n)): Proof by Contradiction 
2: 10 Good and Bad Algorithms 
2: 11 Another Look Back 
Chapter 3 ARITHMETIC OF SETS 
3: 1 Introduction 
3:2 Binomial Coefficients 
3:3 Subsets of Sets 
3:4 Permutations 
3:5 An Application of Permutations: The Game of 
Mastermind 
3:6 The Binomial Theorem 
3:7 Important Subsets 
Chapter 4 NUMBER THEORY 
4: 1 Greatest Common Divisors 
4:2 Another Look at Complexities 
4:3 The Euclidean Algorithm 
4:4 Fibonacci Numbers 
4:5 The Complexity of the Euclidean Algorithm 
4:6 Congruences and Equivalence Relations 
4:7 An Application: Public Key Encryption Schemes 
4:8 The Dividends 
Chapter 5 GRAPH THEOR Y 
xii 
5: I Building the LAN 
5:2 Graphs 
5:3 Trees and the LAN 
5:4 A Good Minimum-Weight Spanning Tree Algorithm 
5:5 An Ode to Greed 
5:6 Graphical Highlights 
97 
102 
110 
118 
122 
127 
131 
141 
153 
161 
168 
176 
181 
181 
186 
190 
197 
206 
211 
222 
234 
239 
239 
241 
251 
263 
1'"71 
_1-
279 

CONTENTS 
Chapter 6 SEARCHING AND SORTING 
283 
6: 1 Introduction: Record Keeping 
283 
6:2 Searching a Sorted File 
290 
6:3 Sorting a File 
295 
6:4 Search Trees 
302 
6:5 Lower Bounds on Sorting 
310 
6:6 Recursion 
317 
6:7 MERGESORT 
325 
6:8 Sorting It All Out 
331 
Chapter 7 RECURRENCE RELA nONS 
339 
7: 1 Beginnings of Sequences 
339 
7:2 Iteration and Induction 
346 
7:3 Linear Homogeneous Recurrence Relations with 
Constant Coefficients 
353 
7:4 LHRRWCCs with Multiple Roots: More About Rabbits 
364 
7:5 Divide-and-Conquer Recurrence Relations 
372 
7:6 Recurring Thoughts 
381 
Chapter 8 MORE GRAPH THEORY 
389 
8: 1 Minimum-Distance Trees 
389 
8:2 Eulerian Cycles 
399 
8:3 Hamiltonian Cycles 
410 
8:4 Minimum-Weight Hamiltonian Cycles 
425 
8:5 Graph Coloring and an Application to 
Storage Allocation 
431 
SOLUTIONS TO QUESTIONS 
<151 
INDEX 
538 
ALGORITHMS AND PROCEDURES 
543 
NOTA. TlONS 
545 
xiii 

1 
SETS AND ALGORITHMS: 
AN INTRODUCTION 
1:1 INTRODUCTION 
The four cards labeled A, B, C, and D in Figure 1.1 are part of a magic trick 
played by Player 1 upon Player 2. The trick is played as follows: 
A 
8 
9 
10 
11 
12 
13 
14 
15 
Figure 1.1 
II 
4 
5 
6 
7 
12 
13 
14 
15 
Pla)'er I 
Pick a whole number 
between 0 and 15. 
Got it? 
Is it on card A~ 
Is it on card B? 
Is it on card C? 
Is it on card D') 
The number you picked is 9. 
2 
6 
10 
14 
c 
3 
7 
11 
15 
Player ] 
Yes. 
Yes. 
No. 
No. 
Yes. 
That's amazing! 
5 
9 
13 
How did you do that? 
And so fast! 
/! 
3 
7 
11 
15 

SETS AND ALGORITHMS: AN INTRODUCTION 
Now let's play again only this time you'll be player 1. I have a whole number 
between 0 and 15. It appears on cards A, C, and V and does not appear on card 
B. What number am I thinking of? 
Question I... (Figure it out before you read any further.) If you are at a loss for 
what to do, ask yourself the following questions. Can it be 0'1 Can it be I? ... Can 
it be 15'1 
Now it can't be 0 because 0 doesn't appear on any of the cards and the number 
I'm thinking of appears on three cards. It can't be 1 because even though I does 
appear on card D, it does not appear on cards A or C, and the number I'm thinking 
of appears on both cards A and C. If this magic trick is well designed, meaning 
that it is always possible for player 1 to guess player 2's number correctly, then 
there must be a unique number that corresponds with any possible sequence of 
answers provided by player 2. In this case the number I am thinking of is 11. It 
is easy to check that 11 appears on the cards A, C, and D but does not appear 
on the card B. It seems less obvious that 11 is the only such number. 
Question 1.2. 
What would you need to do to check that this trick will always 
work? 
Question 1.3. 
Design a pair of cards that will serve to distinguish the numbers 
0, 1, 2, and 3. Is there more than one way to do this? Why can't two cards dis-
tinguish the numbers 0, 1, 2, 3, and 4'1 
Understanding why two cards can distinguish four numbers and why four 
cards can distinguish 16 numbers is fundamental to seeing how to design this 
game as well as how to play it well. Eaeh card that player 1 shows to player 2 
elicits one of two responses, either a "yes" or a "no." A game with two cards has 
foul' possible responses from player 2. These are "no, no," "no, yes," "yes, no," 
and "yes, yes." How many responses has a game with four cards? Justice seems to 
suggest that you respond 16. That is correct. Now let's see Why. 
MultiplicatiolJ Principle. 
Suppose that a counting procedure can be divided into 
two successive stages. If there are r outcomes for the first stage, and if for each 
of these outcomes for the first stage, there are s outcomes for the second stage 
(where rand s are positive integers), then the total number of possible outcomes 
equals the product of rand s, rs. 
Example 1.1. 
At tea one afternoon you are offered your choice of a bagel, a corn 
muffin, or a croissant with either cream cheese or lightly salted butter. How many 
different choices do you have? (Reread the multiplication principle,) At the first 
stage you can choose whether to have a bagel, muffin, or croissant. There arc three 
2 

1:1 
INTRODUCTION 
different outcomes (r = 3). At the second stage you can choose cheese or butter. 
There are two different outcomes (s = 2). By the multiplication principle as well 
as by a direct count you have 6 (= rs) choices. 
Example 1.2. 
In the magic trick, how many different responses are there to the 
four cards? (Reread the multiplication principle.) First consider cards A and B. As 
we've already seen, there are four distinct responses to these two cards (r = 4). 
Next look at cards C and D. It doesn't matter what the responses to the A and 
B cards were. There are four distinct responses to these two cards (s = 4). Thus 
there are 16 (= rs) distinct responses in all to the four cards. Note that these 16 
responses could have been counted in four stages with two responses at each of 
these stages. The multiplication principle works analogously for any number of 
stages. (See Exercises 7 and 8.) 
Question 1.4. 
How many different seven-digit telephone numbers are there begin-
ning with the digits 584? 
Now returning to the magic trick, you see that player 1 could perform the 
trick by memorizing the 16 different responses that player 2 might give in order 
to successfully "guess" player 2's number. The possible responses are listed in 
Table 1.1. 
Table 1.1 
Player ]'s 
Number 
Card A 
0 
no 
no 
2 
no 
3 
no 
4 
no 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
Question 1.5. 
Complete Table 1.1. 
Responses 
Card B 
no 
no 
no 
no 
yes 
Card C 
no 
no 
yes 
yes 
no 
Card D 
no 
yes 
no 
yes 
no 
3 

1 SETS AND ALGORITHMS: AN INTRODUCTION 
EXERCISES FOR SECTION 1 
l. Design a set of three cards that will distinguish the numbers O. L 2 ..... 7. 
Suppose that we only wished to distinguish the numbers O. 1,2 ..... 5. C,)uld 
your three cards be modified to play this game'? Could your three cards be 
modified to play the game with the numbers 0, 1,2, ... ,8? 
2. Suppose that the local ice cream store offers 12 different flavors of ice cream 
and 5 different types of topping (chocolate, butterscotch. strawberry, blueberry. 
and raspberry). How many different dishes of ice cream plus topping are 
possible? Suppose that you can turn these dishes of ice cream piLlS topping 
into special sundaes by adding one kind of nuts (walnuts. almonds. or hazel-
nuts) and whipped cream if you like. How many different types of special 
sundaes can you order at this ice cream store'! 
3. A certain fast food chain offers a one-price meal consisting of a burger, an 
order of potatoes. a salad, a dessert. and a beverage. There are seven different 
kinds of burgers, three different kinds of potatoes, five different kinds of salads, 
and four different kinds of desserts. The restaurant advertises that you can 
eat one meal here every day for four years without ever having the same 
meal twice. What can you say about the number of beverage choices that 
the restaurant offers? 
4. Often, when you sign onto a time-sharing computer, you are asked to specify 
the room you are in and the kind of terminal that you are using. Suppose 
that there are 13 different room categories and 16 different kinds of termmals. 
How many different pairs of answers is it possible to give as you sign on'! 
5. In the context of the preceding problem it is typically the case that not all 
answers are possible. since there are not 16 different kinds of terminals in every 
room. If every room contains four different kinds of terminals, how many 
different answers are possible? 
6. Even the idea in the last problem might not be correct. since the kind and 
number of terminal types may vary from place to place. Suppose that we 
consider only five rooms and that they contain the following kinds of ter-
minals: Every room contains a Digital VT terminal; Tektronix machines are 
located in the Social Science Room and in the Science Lab; IBM PCs are 
found in the Graphics Lab and in the Library Terminal Room: and\pple 
Macintoshes are available in the Library Terminal room and in the Hu-
manities Computer Room. How many pairs of responses are now possible 
to send to the computer when you sign on'! 
7. Here is an extension of the multiplication principle: Suppose that a counting 
procedure can be divided into four successive stages. If there are fJ outcomes 
for the tirst stage. if for each of these outcomes for the first stage. there are 
r outcomes for the second stage, if for each pair of these first two outcomes. 

1:2 
BINARY ARITHMETIC AND THE 'VlAGIC TRICK REVISITED 
there are s outcomes for the third stage. and finally if for each of these first 
three outcomes. there are t outcomes for the fourth stage (where p. r. s. and 
t are positive integers), then the total number of possible outcomes equals 
the product prst. Explain why this is valid. using the original form (two-stage) 
of the multiplication principle. 
8. State and explain a multiplication principle that is valid for three stages. and 
then do the same for five stages. 
9. Suppose that we have a rather primitive computer that can receive only 
strings of zeros and ones as input. Furthermore. these strings must contain 
exactly eight digits. How many different input strings are there? 
10. Suppose that the machine in the preceding problem can receive strings with 
one to eight digits. and suppose that the machine disregards initial zeros. Thus. 
for instance. 1001 is the same input as the string of eight digits. 00001001. 
Now how many different input strings are possible'? 
11. How many different seven-digit phone numbers are there that begin 584 and 
contain no zero? How many phone numbers are there that begin 584 and 
contain at least one zero? 
12. How many different seven-digit phone numbers are there that begin 58_-
_~ and contain seven different digits? How many of these contain no zero? 
How many do contain a zero? How many different phone numbers are there 
that begin with 58_. but contain no two identical consecutive digits" 
13. Recently, a new telephone area code was introduced for the area of 'Jew 
York that contains Brooklyn and Queens because all seven-digit phone num-
bers had been used up. Assuming that none of the first three digits in a 
phone number can be either a 0 or a L what can you say about the number 
of phone lines in this area'? 
14. In the lottery game called Megabucks a player selects six different numbers 
between 0 and 35. How many different such selections are there? Before an-
swering, specify when two selections are the same and when they are ditTerent. 
1:2 BINARY ARITHMETIC AND 
THE MAGIC TRICK REVISITED 
The magic trick of Section I was based on each of four questions receiving either 
a "yes" or a "no" answer. Thus a seemingly complex task. in this case deciding 
which number player 2 had chosen. could be broken down into a sequence ()f 
smaller tasks associated with each of the cards. This fundamental yes-no. true-r'alse. 
or on-off dichotomy pervades most of the mathematics associated with computers. 
It even is fundamental to how computers ·'think" about numbers. We now model 
how a computer stores an integer using binary numbers. 
5 

SETS AND ALGORITHMS: AN INTRODUCTION 
A number in binary notation is just a finite list (sequence or string) of zeros 
and ones. For example, 1, 101, 111001. and 1011 are all binary numbers. For the 
moment don't be concerned about which numbers these sequences are. We'll get 
to that shortly. Rather. think in the familiar decimal system. The number 37, for 
instance, can be thought of as 3 tens together with 7 ones, 
37 = 3 . 10 + 7. 
The number 234 is 2 hundreds plus 3 tens plus 4 ones, 
234 = 2 . 100 + 3 . 10 + 4. 
The decimal number system is so named because successive columns when reading 
from the right represent consecutive powers of ten. We'll use the same device for 
the binary system. Specifically, let the rightmost column of a number written in 
binary represent the ones. We call this the Oth column or the one's column. The 
next column to the left represents the twos. This is called the 1st column or the 
two's column. The third column from the right represents the fours, the fourth 
column from the right represents the eights, and so on. So the pth column from 
the right (starting with p = 0) in the binary representation of a number represents 
the pth power of 2. 
Example 2.1. 
The binary number I is the same number as the decimal number 
1. The binary number 101 consists of lone, no twos, and 1 four. It is equivalent 
to the (decimal) number 5. Similarly, the binary number 111001 is equivalent to 
the decimal number 57, since 57 = lone + 0 twos + 0 fours + 1 eight + 1 
sixteen + I thirty-two (see Figure 1.2\. 
-~ "~-~----------- .. ----------------- -
-.-----------~-----
.----~--------
." 
I~-'''---'-~'-' 
, 
BINARY NUMBER 
I 
DECIMAL NUMBER 
I 
101 
I 
5 
1'4+0'2+1 
! 
= 1 . 32 + 1 . 16 + 1 . 8 + 1 . 1 = 
57 
I 
111001 
'---_______________________ 
.. -----..l 
Figure 1.2 
Question 2.1. 
Find the decimal equivalents of the following binary numbers: 
(a) lO1OL (b) 100101, and (c) 11010. Given a binary number, how would you 
decide whether it is an even number or an odd number? 
Question 2.2. 
Construct a table with all the numbers from 0 to 15 written in 
binary. C)mpare your results with the table that you completed for Question 1.5. 
6 

1:2 BINARY ARITHMETIC AND THE MAGIC TRICK REVISITED 
Question 2.3. 
List all the numbers from 0 to 15 that have a 1 in the four's column 
of their binary representation. 
After doing the previous question. you should note that the numbers you 
obtain appear familiar. In fact they are just the numbers that appear on card B 
in the magic trick. You should check that the numbers that appear on card A are 
just those numbers between 0 and 15 whose binary representation has a 1 in the 
eight's column. those on card C are just those with a 1 in the two's column, and 
those on card D are just those with a 1 in the one's column. This suggests a quick 
way for player 1 to perform the magic trick. Player 1 should remember the number 
in the upper left-hand corner of every card to which player 2 says "yes" and add 
these numbers up. Thus in our original play the yes to card A produces an 8. and 
the yes to card D produces a 1 for a total of 9. 
At the moment we have used binary representations of numbers to produce 
a simple procedure for player 1 to perform the magic trick. It is easy to proceed 
from the binary representation of a number to its decimal equivalent. What about 
the other direction, that is, given a number in decimal form how should we arrive 
at its binary equivalent? 
Question 2.4. 
Write the following (decimal) numbers III binary: (a) 6, (b) 19. 
(c) 52, (d) 84. and (e) 232. 
You have already done part (a) in previous questions. Part (b) you probably see. 
To write 52 and 84 in binary, you might require pencil and paper. By the time 
you get to 232, you will be glad the question stops. Surely you realize that given 
any positive integer of moderate size, you could find its binary representation with 
enough time, motivation, and paper. Still if the method that you have used is, 
basically trial and error, you might wish for an alternative. What you need in the 
jargon of discrete mathematics is a "good algorithm." We shall introduce you to 
this language in the next section. 
EXERCISES FOR SECTION 2 
1. List all numbers from 0 to 15 that have a 1 in the eight's column. Then list 
all of these numbers that have a 1 in the two's column. Why is it precisely 
the odd numbers that have a [ in the zero's column'? 
2. Without listing all the numbers. give a characterization of the numbers from 
o to 31 that have a 1 in the sixteen's column. Then characterize those num-
bers from () to 3 [ that have a [ in the eight's column. Finally, describe all 
numbers from 0 to 31 whose binary expansion ends with the digits 01. 
3. What decimal numbers do the following binary numbers represent') (a) [101 1. 
(b) 10101 L (c) 10001, and (d) 11000. 
7 

1 SETS AND ALGORITHMS: ,\N INTRODUCTIOi'oi 
4. Find the binary representation of the following decimal numbers: (a) 28. 
(b) 43. (c) 100. and (d) 81. 
5. Suppose that you are given a decimal number m that has the property that 
when m is divided by 8 there is a remainder of 2. What can you say about 
the binary representation of m'? 
6. Suppose that you are given a decimal number m that has the property that 
when m is divided by -+ there is a remainder of 3. What can you say about 
the binary representation of m'! 
7. Suppose that you are given a decimal number In that has the property that when 
In is divided by 16 there is a remainder of 6. What can you say about 
the binary representation of m'? 
8. What is the maximum number of integers that a six-card magic trick could 
distinguish? If the six cards were designed as in the original trick from Section 
1 and the responses were yes. no. yes. yes, no, no; what number was selected? 
9. Given two binary numbers, how could you tell (without converting them into 
decimal) which is bigger? 
10. A binary fraction is a finite sequence of zeros and ones that follows what is 
called the binary point. For example 0.101 is a binary fraction. The column 
immediately to the right of the binary point represents the halves, the next 
column the quarters. the third column the eighths, and so on. Thus 0.101 = 
± + ~ = ~. Make a table of all four-bit binary fractions. 
11. Express each of the following in binary: (a) 3;, (b) ~~, (c) 
.:~l. (d) ~3. 
17~ 
and (e) It. 
1:3 ALGORITHMS 
Definition. 
An algorithm is a finite sequence of well-described instructions with 
the following properties. 
1. There is no ambiguity in any instruction. 
2. After performing a particular instruction, there is no ambiguity about which 
instruction is to be performed next. 
3. The instruction to stop is always reached after the execution of a tinite 
number of instructions. 
Example 3.1. 
Here are the instructions inscribed on a metal plate attached to 
the front of a video game: 
STEP I. Insert L\ uarter into slot on side of machine. 
STEP:. Press green hutton on top ,)f machine when ready to begin. 

1:3 
ALGORITlIMS 
This is a finite sequence of well-described instructions. There is no ambiguity in 
any instruction. It is always clear what to do next. There is no explicit Instruction 
to stop, but we overlook this, since it is clear that each instruction is executed 
just once for each play. Thus we may call this an algorithm: ft is an algorithm to 
begin playing a video game. 
Example 3.2. 
Suppose that we add an instruction to the previous example. 
STEP 3. When each game is over, type your initials and press red button on 
top of machine to record score for posterity. 
Step 3 fulfills the role of a stop instruction provided games don't go on for-
ever and provided you cannot play an additional game on your initial quar:er. 
Example 3.3. 
Suppose we insert the following instruction. 
STEP 4. For each 10.000 points you accumulate you will win a free game. 
When current game is over, if you have won a free game, go to 
step 2. 
This has changed the nature of the instructions. The first two examples are known 
as sequential algorithms. By that we mean that each step (or instruction) is exe-
cuted exactly once and that the next step on the list is the next instruction 1.0 be 
executed. Step 4 adds the possibility of executing an instruction many times. Indeed 
since there is no reason to suppose that the winning of free games couldn't go on 
forever the list of instructions in Example 3.3 is not an algorithm. You might 1 hink 
of this by reinterpreting instruction 4 as saying, 
"If score 2:: 10,000, then go to instruction 2." 
This logical structure is known as a loop. Although this particular loop has made 
the sequence of instructions fail to be an algorithm, a loop need not forc;: the 
execution of an infinite number of steps. 
Example 3.4. 
Suppose that we modify instruction -+ so that our instructlOm now 
say: 
STEP l. Insert quarter into slot on side of machine. 
STEP 2. 
Press green button on top of machine when ready to begin. 
STEP 3. 
When each game is over, type your initials and press red hutton un 
top of machine to record ocore for posterity. 
STEP 4. 
For each [0,000 points you accumulate. you will win a free game up 
to a maximum Df I () free games for each paid game. When current 
play is over. if you have won a free game, go to step 2. 
() 

1 SETS AND ALGORITHMS: AN INTRODUCTION 
The modification in step 4 can be described as adding a counter to the loop in 
order to insure that the loop is executed a finite number of times. 
The logical structure of Example 3.3 illustrates one of the most common mis-
takes made by beginning programmers. that of an infinite loop. Example 3.4 shows 
a typical quick fix. 
Reread the definition o{alqorithm! Given a sequence of instructions. how could 
it fail to be an algorithm? First. it might be the case that at least one of the 
instructions is ambiguous. In other words, some instruction might be poorly 
specified so that you. the reader. do not know how to carry out the instruction 
or so that a computer programmer does not know how to translate the instruction 
into a suitable computer language. An instruction that is clear to one person may 
be full of ambiguities for another. For example. an instruction like. "Start the 
airplane engine and take off on runway 4," might be unambiguous to trained 
pilots. 
A sequence of instructions might fail to be an algorithm because after executing 
a particular instruction, it might not be clear which instruction is to be executed 
next. Some instructions will clearly indicate the next instruction. such as " ... and 
then go to step~-." If no such direction is given. we always move to the next step 
as given in the sequence of instructions. Finally, we would not have an algorithm 
if the execution of the sequence of instructions did not terminate in all instances. 
If a sequence of instructions does satisfy the definition of an algorithm. it still 
might not be a correct algorithm to perform the desired task. To illustrate this 
possibility, we introduce an example from the kitchen. (It seems that most expo-
sitions about algorithms revert to cooking recipes at some time.) 
Example 3.5. 
Consider the following sequence of instructions. 
STEP 1. 
Place one cup of water in the top of a double boiler. 
STEP 2. Place one cup of quick oatmeal in the bottom of a double boiler. 
STEP 3. Turn on a stove burner to medium. 
STEP 4. Place double boiler on burner and heat for 10 minutes. 
STEP 5. Remove pot. 
STEP 6. Turn off burner. 
You may verify that the instructions satisfy the definition of algorithm. How-
ever. you would be unlikely to enjoy eating the results of this recipe. This example 
illustrates that a particular algorithm is designed in response to a particular prob-
lem. [n this case the problem (which while not explicitly ,tated) can reasonably 
be inferred to be to make oatmeal. This sequence of instructions is not a correct 
algorithm for making oatmeal. 
10 

1:3 
ALGORITHMS 
Question 3.1. 
Rewrite the steps in Example 3.5 so that the resulting algorithm 
correctly instructs us to make oatmeal. 
Notice that writing a correct algorithm may be significantly more ditIlcult 
than checking whether a given sequence of instructions is a valid algorithm. Cre-
ating an algorithm requires expertise with the subject matter. To give a correct 
algorithm for making quick oatmeal, you need to know (or read on the box) the 
proper proportions of water and oatmeal, the cooking time, and so on. To play 
a video game requires knowledge of the rules and object of the game. For the 
more mathematical algorithms of this book we need to develop the language and 
techniques of the subject before we can use. let alone create, new algorithms. 
Sometimes it may be difficult to decide if a given sequence of instructions will 
necessarily terminate in a finite number of steps. The obvious cases might always 
stop, but how can we know if we have tested all possibilities? 
Example 3.6. 
Consider the following algorithm. 
Algorithm(?) COLLATZ 
STEP 1. Input: a positive integer 
STEP 2. If: is even. replace: by :/2 
STEP 3. If: = 1. then output: and stop. 
STEP 4. If: is odd. replace:: by 3z + 1 
STEP 5. Go to step ::. 
This will be an algorithm if it stops. This will happen if : eventually equals 
I. Whether or not this will happen for every positive integer: is a famous unsolved 
problem known as the Collatz Problem. 
Question 3.2. 
Run COLLATZ for the following initial values of :: (a) 
(b) :: = 20. and (c) : = 7. 
I. 
An algorithm will typically need input to begin and will produce output :.It 
the end. Input is the data or material needed to start the algorithm. like a quarter, 
water and oatmeal. or a positive integer :. The output is the result of the algorithm. 
derived from the particular input, like a score stored on a video game. burned 
oatmeal. or the number: = I. General-purpose algorithms. which are the most 
useful. will draw input values from a set of possibilities. like all positive integers 
or all quick-cooking hot cereals. For each input there will be exactly one ;et of 
()utput. (The word set will be explained more fully in Section 5.) 
Given a finite sequence of instructions that is in fact an algorithm. we now 
address the question of what Ljualities make this algorithm "good." Algorithms 
11 

I SETS AND ALGORITHMS: AN INTRODUCTION 
are created to solve problems. The term correct is used to label algorithms that 
produce correct solutions to a particular problem. Thus the sine qua non of a 
good algorithm is that the output must be correct for all possible input data. A 
great deal of effort within computer science is expended proving that programs 
(implementations of algorithms) are correct. 
What properties might distinguish two correct algorithmic solutions to a par-
ticular problem? One might be easier to understand. One might provide internal 
consistency checks to assure that the algorithm was being carried out correctly. 
One might be easier to implement in your favorite programming language. Most 
commonly, one algorithm is said to be better than another if it requires fewer 
resources to implement. These resources may consist either of time (the number 
of steps required until the algorithm terminates) or space (the amount of memory 
req uired to implement the algorithm). In the next section we illustrate these notions 
with several different responses to the problem 'Jf taking a number written in 
decimal and translating it into binary. 
EXERCISES FOR SECTION 3 
1. Here are two approaches to making whipped cream. Discuss whether these are 
or are not algorithms. 
Approach 1 
STEP 1. 
Buy a pint of whipping cream. 
STEP 2. Chill cream and beaters until cold. 
STEP 3. Add a small amount of sugar and vanilla extract to cream. 
STEP 4. Whip cream until stiff but not dry. 
STEP 5. Wash dishes and stop. 
A. pprollch :; 
STEP 1. 
Buy a can of Readi-Whip. 
STEP 2. Shake 30 times. 
STEP J. Invert can. 
STEP 4. 
Press nozzle. 
STI'P 5. Stop. 
2. Here are two algorithms that calculate the sum of the integers from 1 (0 100. 
Cl)mment on the relative efficiency of the two responses. 
12 

1:3 
.\LGORITH\1S 
Response 1 
STEP L Sum the integers from 1 to 100 and store the result in the variable 
Answer. 
STEP 2. 
Print out the value of Answer. 
STEP 3. Stop. 
Response :: 
STEP I. Store each of the integers from 1 to 200 in different memory locatic·ns. 
STEP 2. Sum the integers from 1 to 200 and store the result in the variable 
Answer. 
STEP 3. Sum the integers from 101 to 200, subtract the sum from the number 
in Answer. and retain the difference in Answer. 
STEP 4. 
Print out the values of all 200 integers and also the value of Answer. 
STEP S. Stop. 
3. Each of the following fails to be an algorithm: what rule or rules do they violate? 
Attempt 1 
STEP 1. Set Sum equal to 
STEP 2. 
Set X equal to 2 
STEP 3. Give Sum the value Sum + X 
STEP 4. If Sum is even. then go to Step 5: 
if Sum is odd, go to Step 3 
STEP 5. 
Print out the value of Sum and stop. 
Attempt :: 
STEP 1. Set Sum equal to 
STEP 2. Set X equal to 2 
STEP 3. Give Sum the value Sum + X 
STEP 4. [f Sum is even, then stop. 
4. Give a tinite sequence of well-described instructions that never stops: that is. 
give an example l)f a pseudo-algorithm that fails to meet the third property 
needed to be an algorithm. 
13 

1 SETS AND ALGORITHMS: AN INTRODUCTION 
5. In each of the following decide whether or not the sequence of instructions is 
an algorithm. If not, explain why not. If yes, figure out what the algorithm pro-
duces as an answer. 
Algorithm A 
STEP 1. Set j = 0 
STEP 2. Set Answer = 0 
STEP 3. Give Answer the value Answer + 2j 
STEP 4. 
Add 1 to j 
STEP 5. 
1f j is less than 5, go to step 3 
STEP 6. Output Answer 
STEP 7. Stop. 
Algorithm B 
STEP 1. Set j = 0 
STEP 2. Set Answer = 0 
STEP 3. Give Answer the value Answer + 2j 
STEP 4. 
Add 1 to j 
STEP 5. 
If j is not zero, go to step 3 
STEP 6. Output Answer 
STEP 7. Stop. 
Algorithm C 
STEP 1. Set j = 0 
STEP 2. Set Answer = () 
STEP 3. Give Answer the value (Answer) (2i) 
STEP 4. 
Add 1 to j 
STEP 5. Ifj is less than 5. go to step 3 
STEP 6. Output Answer 
STEP 7. Stop. 
6. Find a more efficient algorithm that produces the same output as the one given 
here. 
14 

1:4 
BETWEEN DECIMAL AND BINARY 
Algorithm FUN 
STEP t. 
Input:, an integer between 100 and 300 
STEP 2. 
Let u = 3: 
STEP 3. 
Let w be u written twice [so 345 becomes 345,345] 
STEP 4. 
Let y be w with an extra zero on the end 
STEP 5. 
Let a be y divided by 2 
STEP 6. 
Let b be a divided by 3 
STEP 7. 
Let c be b divided by 5 
STEP 8. 
Let d be c divided by 7 
STEP 9. 
Let e be d divided by II 
STEP 10. Let I be e divided by 13 
STEP II. Let y be I plus 1 
STEP 12. Output?J and stop. 
1:4 BETWEEN DECIMAL AND BINARY 
In Section 2 we discussed the problem of changing numbers from decimal to binary, 
and vice versa. Example 2.1 outlines a procedure for changing a binary number 
into its decimal equivalent. We shall soon make this procedure precise. First we 
digress to introduce some convenient notation that we shall use to present various 
algorithms. 
The symbol ": ="' is used for assignment. Specifically, the statement a = b 
means that the current value of the variable b is assigned to the variable a. We can 
use this to form instructions that do not represent equalities in the normal arith-
metic sense. For instance, the statement 
a:=a+l 
does not mean that II = 11 + L an assertion that is never true. Rather it means that 
the value assigned to the variable a should have I added to it, and the resulting sum 
should be reassigned to the variable ll. 
The symbol "'*" is used for multiplication. Specifically, the expression II * h 
means the product of the numbers a and h. The symbol "/" is used for division. 
Specifically, a/h means that a is divided by h. Thus the statement 
a: = aih + .23 
15 

I SETS AND ALGORITHMS: AN INTRODUCTION 
will divide the value of a by the value of h. add 8 to this quotient. and storc thc 
result in the variable a. For this instruction to make sense. the variables a and h 
must have been previously assigned values. 
Problem. 
Given a binary number s as a string of zeros and ones, convert this 
into its decimal equivalent. 
(To add clarity to our algorithmic instructions, we shall often insert comments 
inside braces as in [COMMENT: ... j). 
Alyorithm BtoD 
16 
STEP l. Set j : = 0 
: j will stand for the binary column with which we are currently work-
ing. We label the columns from right to left beginning with 0.: 
STEP 2. Set m:= 0 
: In will contain the final decimal number.: 
STEP 3. If there is no jth entry of s, then stop. 
STEP 4. If the jth entry of s is a 1. add 2j to m 
:We write this as In: = m + 2j.: 
STEP 5. 
Increase the value of j by 1. that is. set j : = j + I 
STEP 6. Go to step 3 
Table 1.2 
Value Assigned to the Given Variahle 
Step 
In 
1011 
() 
~ 
lOll 
0 
0 
-
1 
LOll 
0 
() 
4 
lOll 
() 
1 
5 
1011 
I 
6 
1011 
4 
1011 
:; 
5 
1011 
2 
-, 
4 
lOll 
, 
3 
-
5 
lOll 
, 
-' 
-+ 
lOll 
:; 
II 
5 
lOll 
4 
II 
-' 
STOP 
'>;'::~ 

1:4 
BETWEEN DECIMAL AND BINARY 
Example 4.1. 
Table 1.2 is a detailed look at what happens when this algorithm 
is applied to the binary number 1011. Such a tabulation is called a trace of the 
algorithm. We record the values of the variables at the end of each step. 
Question 4.1. 
Apply BtoD to the binary numbers 10101, 11010, and 100101. 
Do you get the same answers and are you carrying out the same procedure as in 
Question 2.1'~ 
Next we return to the harder Question 2.4: Given a number written in decimal. 
how should we find its binary equivalent? Several sequences of instructIons bsted 
in order of increasing quality follow. First the problem is formalized. 
Prohlem. 
Find the binary representation of a positive integer m. 
Response I 
STEP I. Write down a finite sequence of zeros and ones. 
STEP 2. Take the binary number you wrote down in step 1 and tramlate 
it into decimal using Algorithm BtoD. given above. 
STEP 3. If the number you obtain in step 2 equals m. then stop. Otherwi~e go 
to step 1. 
Question 4.2. 
Why is Response 1 not an algorithm? 
Response :! 
STEP 1. Set k:= 1 
: k will denote the number of binary digits in the number under 
consideration. : 
STEP 2. 
List all possible sequences of zeros and ones with Ii- digits in increas-
ing order 
:Forexample.ifk= 1.0< l.andifk=2.00<OI < 10< 11.: 
STEP 3. For each sequence from step 2. find its decimal equivalent using 
A.lgorithm BtoD 
STEP..J.. If one of the numbers that you obtain in ~tep 3 equals 111. then stop. 
STEP S. 
J.:: = k + 1 
STEP A. Go to ~tep .2 
The binary digits. leros and ones. in a binary number are called bits. 
17 

I SETS AND ALGORITHMS: AN INTRODUCTION 
Question 4.3. 
Why is the sequence of steps listed in Response 2 a correct algorithm 
for solving the problem'! Use this algorithm to find the binary representation of 19. 
What makes this algorithm low quality? 
Response 3 
STEP 1. 
Find the largest power of :2 that is less than or equal to Ill. If this is 
the rth power of 2. place a I in the rth column (reading from the right 
and beginning with 0) 
STEP 2. Subtract the power of :2 obtained in step 1 from rn and set the result 
equal to m, or in symbols, set m : = In - 2'. If In equals zero. fill in 
the remaining columns with zeros and stop. 
STEP 3. Go to step 1 
Question 4.4. 
Why does the sequence of steps listed in Response 3 necessarily 
stop? Use this algorithm to tind the binary representation of 182. 
Response 4 (ALGORITHM DtoB) 
STEP l. Set j : = 0 
r j will indicate the column in the binary representation of In on 
which we are working.} 
STEP 2. Divide m by :2 to obtain the quotient If and the remainder r 1 neces-
sarily either 0 or Ii; place r in the jth column of the answer l reading 
from the right J 
STEP 3. If q = 0, then stop. 
STEP 4. Set m:= q 
STEP 5. Setj :=j + I 
STEP 6. Go to step 2 
Example 4.2. 
Table 1.3 is a trace of the algorithm DtoB, run on the decimal 
number 21. 
Question 4.5. 
Why does the sequence of steps listed in Response 4 necessarily 
stop? Use this algorithm to find the binary representation of 395. Compare the 
algorithms in Responses 3 and 4. 
The algorithm given in Response 4 is one that we shall use again and so we 
have named it Algorithm DtoB. In the exercises you are asked to work with the 
:.ligorithms and ideas of this section. Here and throughout the book you will be 
asked to write algorithms. How should you create an algorithm from scratch? Here 
are some ideas, but there is no all-purpose algorithm to create an algorithm! Fir~t 
18 

I 
1:4 BETWEEN DECIMAL AND BINARY 
Table J.3 
Values Assigned to the Variable After the 
Execution of the Given Step. 
Step 
m 
'I 
Answer 
0 
21 
2 
0 
21 
10 
4 
0 
10 
10 
5 
I 
10 
10 
::: 
10 
5 
() 
Ot 
4 
5 
0 
5 
2 
5 
5 
0 
2 
::: 
5 
~. 
tOt 
4 
::: 
::: 
5 
3 
::: 
::: 
3 
::: 
0 
OlOl 
4 
3 
0 
5 
4 
0 
2 
4 
0 
lO10t 
3 
STOP 
figure out how to solve the problem at hand. Then ask yourself what your steps 
were and try to write them down so that another person or a computer could 
understand and follow them. Then analyze these steps, as we have in this section. 
to see whether your steps are a correct algorithm. This task is always challenging. 
Sometimes you will have seen algorithms in the text and exercises that you can 
modify and build upon; other times you need to jump in and follow your own 
logical path to a solution. 
EXERCISES FOR SECTION 4 
1. Apply BtoD to the following binary numbers: (a) 11, (b) 101, (c) 1101. (d) 1011, 
(e) Ill!, and (f) 10101010. 
2. Suppose that the decimal number D is expressed in binary as a sequence S of 
zeros and ones. [f a zero is placed at the right end of S. how does the decimal 
value of the resulting number compare with D? If a one were placed at the 
right end of S, how would the decimal value change? 
3. Suppose that S is a string of zeros and ones that corresponds with the even 
decimal number D. If the last entry of S on the right is erased, express the 
value of the new decimal number in terms of D. Repeat if D is odd. 
4. Apply DtoB to the decimal numbers 17 and 59. Then apply BtoD to the re-
~ulting binary numbers. Next apply BtoD to (he binary numbers 10001 and 
110110. Then apply DtoB to the resulting decimal numbers. 
19 

I SETS AND ALGORITHMS: AN INTRODl'CTlON 
5. A 16-bit computer allocates 16 spaces or bits to store an integer. The tlrst blt 
designates whether the number is positive or negative and the remaining bilS 
contain either a Lero or a one, expressing the integer in binary. How many 
different integers can you store in 16 bits'! What is the decimal value of the 
largest and of the smallest integer that can be stored using 16 bits? 
6. Numbers written in base 3 can use only the digits 0, 1. :md 2. Thus the decimal 
numbers 0, I, and 2 are expressed in base 3 in the same way, but to write 3 in 
base 3 we must write 10 = 1 . 3 l + O· 3°. Write the (decimal) numbers from 
4 to 12 in base 3. The base 3 representation of a number is also called its 
ternary representation. 
7. For each of the following numbers written in base 3, determine its decimal 
equivalent: (a) 22, (b) 20102, (c) 1212L (d) 20010, and (e) 1121. 
8. Translate each of the following decimal numbers into a base 3 representation: 
(a) 13, (b) 15, (c) 21, (d) 27, (e) 30, and U) 80. 
9. Find the base 3 representation of the number 20 and then translate that ba,.e 
3 number back into decimal notation. Similarly, begin with the base 3 number 
Ill, find the decimal number that it represents, and change that decimal num-
ber back into base 3. 
10. Given a number .Ii expressed in base 3 as a string of Os, I sand 2s, write down 
an algorithm that will convert s into its decimal equivalent. (Hint: Look at 
Algorithm BtoD.) 
11. How can you tell if a given number written in base 3 is even? 
12. Given a decimal number n, write down an algorithm that will express II in 
base 3 as a string of Os, I s, and 2s. 
13. What can you say about the base 3 representation of a decimal numher that 
when divided by 9 leaves a remainder of 7? 
14. Create an algorithm that will input a binary fraction (see Exercise 2.10) and 
output the fraction in standard form. Run your algorithm with input (a) 0.1101, 
(b) O.OOIOI, and (e) 0.101010. 
15. Create an algorithm lhat will input a positive integer IJ and a rational number 
:: with 0 < :: < I and output II bits of ::'s hinary representation. Run your 
algorithm for II = 6 and (a) :: =tb' (b) :: = 3
7
2' (e) :: = t and (d) :: = It. 
16. Why can't there be an algorithm to input a fraction:: with () < :: < I and 
lJUtput :;'s binary representation? 
1:5 SET THEORY AND THE MAGIC TRICK 
When we think about the magic trick presented in Section I, the numbers 
n, 1. 2 .... , 15 are all of the nbjects with which we are concerned. The totality .)f 
these objects we call our universe or underlying set. The eIght numbers that appear 

t:5 SET THEORY AND THE MAGIC TRICK 
on card A are called a set of objects. More generally, given any universe of objects 
we use the word set to denote any well-specified collection of objects from the 
universe. We have included the descriptive "well-specified" in order tl) make it 
clear that there can be no ambiguity as to what is in and what is not in the set. 
Given two sets, say .4 and B, of objects from the same universe, .~ is said to 
be a subset of B, denoted by A C;; B, provided every object that is contained il1 .4 
is also contained in B. Every set is necessarily a subset of the universal set, and 
the empty set or null set, the set with no objects, is a subset of every set. The 
empty set is often denoted by 0. The objects in a set arc also called elements of 
the set. Two sets A and B are said to be equaL written A = B. if they contain 
precisely the same objects lor elements). Note that A = B if and only if.1 C;; Band 
B C;; A. 
Example 5.1. 
Let Z denote the integers. We can list the objects in Z by wnting 
0, L - L 2, - 2, .... For this example Z will be the underlying set or universe. 
Let N denote the natural numbers, that is, N can be listed as 0, 1,2,3, .... 
The natural numbers are objects in Z and there is no ambiguity about which ob-
jects are in N, so the natural numbers are a set in the universe of the integers. 
Let P denote the set of prime numbers. An integer greater than one is called 
prime if it cannot be factored into the product of two smaller positive integers. 
Thus 5 is prime while 6 = 2 . 3 is not prime. P can be listed as 2,3,5,7, I L. . , . 
P is a subset of N. Note that for a large integer it might be computationally dif-
tlcult to decide whether the integer is prime or not. Nevertheless, the elemen~s in 
P are well specified. 
Example 5.2. 
Let the universe consist of the students enrolled in mathematics 
courses this semester. If S denotes the set of students who are enrolled in Dis-
crete Mathematics and A denotes the set of students who will earn As in Discrete 
Mathematics, then .4 is (we hope) a nonempty subset of S. 
Typically, we shall use capital letters to denote sets and small letter;; to 
denote the objects, when this is possible. If .-1 is a set and s an elemen. of 
A, we write sEA; read "3 is an clement of ..t." If S is not an element of A. we 
write s rt A. When specifying a set, we shall occasionally list all objects within a 
pair of curly braces; however. the order in which the objects are so listed is im-
material. The set : 1,2.3: is the same set as ; 3, 1,2: and : 1,3,2:, since each con-
tains precisely the same objects. More frequently, we shall place within the curly 
braces the property or properties that specify the set. 
Example 5.3. 
The numbers that appear on card .1 in the magic trick i"orm a set 
that we could denote by .-1 = : 8, Y, 10, I I, 12, 13. 14, 15: o[ by 
A = : x: () ~ x :s; 15 and the binary form of x 
contains a 1 in the third column. l"cading from 
the right and heginning with 0:. 
11 

I 
SETS AND ALGORITHMS: A:-.I INTRODUCTION 
Read the above line as ",4 equals the set of x such that zero is less than or equal 
to x, which is less than or equal to 15, and the binary form of x contains a 1 in 
the third column .... " It is often the case that some contextual information is left 
out of the specification of the set. Here, we did not note that the objects in the 
universe are all integers. Such information may be omitted provided that it does 
not lead to any confusion on your part. 
Question 5.1. 
Let the universe consist of the positive integers less than 30. Below 
we list several sets that are well specified by the properties that their elements 
must satisfy. For each such set list the elements in the set. 
(a) A =:x: x is not prime}. 
(b) B = : x: x is a square, that is, for some integer )', x = l j. 
(c) C = {x: x is divisible by a square greater than one]. 
Given a set A consisting of some objects from the universe U, the complement 
of A, denoted by A
C
, is the set of objects from the universe that are not elements 
of A. In the curly brace notation 
A
C = [x is in U: x is not in A] 
:xEU:x~A}. 
Question 5.2. 
Find the complements of each of the sets from the preceding 
question. 
Question 5.3. 
For the six sets you found in the preceding two questions determine 
which are subsets of each other. 
From two sets of elements in the same universe, say A and B, we can derive 
two new sets, the union of A and B and the intersection of A and B. The union 
of A and B, denoted by A u B, consists of all the elements of U that are either in 
A or in B (or in both). Note that in English "or" often means exclusive or: For 
lunch I shall eat a pizza or a grinder (but not both). Here we use "or" in the 
inclusive sense: mathematics majors usually study statistics or computer science 
(or both). The intersection of A and B, denoted by A rI B, consists of all the 
elements of U that are in both A and B. In curly brace notation 
and 
22 
A u B = : x: x is in A or x is in B or x is in both A and B] 
.1 rI B = : x: x is in A and x is in B: 
= : x: x E A and x EO B}. 

1:5 SET THEORY AND THE MAGIC TRICK 
Question 5.4. 
Find the pairwise unions and intersections of the sets you found 
in Question S.l. 
Example 5.4. 
Let A. B. C. and D denote the sets of numbers on the cards of the 
magic trick. For instance. suppose that player 2 is thinking of the number 6. This 
number appears on cards Band C and does not appear on cards A and D. When 
player 2 says yes to card B and yes to card C. player 1 knows that player 2's 
number is in the set labeled B and in the set labeled C. In the language just in-
troduced player 2's number is in B n C. Now 
Bn c= ~4.S.6,7.12,13.14.1S} n [2.3.6.7.10,11,14,lS} = [6.7.14,IS). 
Let us do the analogous set theory for the no responses. When player 2 ~.ays 
no to card A, player 1 knows that the number is not on card A. If a nurrber 
is not in A but is in the universe, then it must be in the complement of A. Similarly. 
player 2's number must be in the complement of D. In the language of set theory. 
A
C = {O, 1.2,3.4.S,6,7}, DC = [0.2.4,6,8, lO,l:~.141. so 
Ae n DC = (0,2,4,6]. 
Player 2's responses mean that the number chosen must be in AC, B, C, and DC. 
What number is it'? 
...Ie n B n C n DC = (B n C) n tA
C n DC) = i6. 7.14.1S} n [0,2A.6} = [6J. 
In general, one way to explain why the magic trick always works is to notice.hat 
if the set S is either A or A
C
, the set T either B or Be. V either C or C, and W 
either D or DC, then S n T n V n W contains exactly one number. 
EXERCISES FOR SECTION 5 
I. Let the universe consist of all two-letter "words," that is. all sequences of IWO 
alphabetic characters twhich don't have to form a real English word). Let A 
consist of all of these words that begin with an "a." and B those that end with 
a "b." Let C be those that contain no "e," D those that contain no vowel, and 
E those that contain only vowels. 
(a) Describe the complementary set in each case. 
(b) List or describe 1 n B. A. u B. A (\ C. A u C. AnD. A (, E. BiD. 
BuD. C rI D. CuE. and DuE. 
2. Let the universe consist of ali two-digit numbers: 
: x: lOS; x ~ YY l. 

SETS AND ALGORITHMS: AN INTRODUCTION 
Let A be the set of two-digit numbers that begin with a t, B those that end 
with a 9. C those that are multiples of 3. D tho~e in which both digits are even. 
and E those that are even. 
(a) Among these sets, find two such that one is contained in the other. 
(b) Are there three sets whose intersection is empty. but such that the inter-
section of any two is not empty? 
(e) Construct a set with half as many elements as A using A .. ... E. their 
complements, unions, intersections. and so on. 
(d) List the following sets: A n IB u C), A u (D n E). (A n B) u (D n E), C (' 
D n E. A u CuD .. ~ n B n C n D n E, A n C n E, and C n (D u E) 
3. Using the universe and sets A. B .. .. , E of the previous problem. identify the 
following sets and then show that the indicated identity is valid: 
(a) (D u E). IC n 0), IC n E): 
C n (D u E) = (C n 0) u IC n £). 
(b) III u C), (A n E), (C n E): 
(A u C) n E = (A n E) u (C n El. 
(e) (B u 0), Be, DC: 
(B u D)e = Be n DC. 
(d) (A n E), Ae. EC: 
(A n E)e = A
C u e. 
(e) (B n E), (A u B), (.4 u E): 
Au (B n E) = (A u B) n (A u E). 
4. Suppose that you are designing a version of the magic trick with the numbers 
0.1 ..... 7. Furthermore. you have already constructed two cards labeled E and 
F where in the notation of set theory 
and 
F = :3.4,5.6). 
Construct a single card G that will enable you to successfully perform the trick. 
[s G uniquely determined. that is. is there choice about what numbers can b.; 
put on G') 
5. Suppose that you are again designing a version of the magic trick with th(~ 
numbers O. 1. .... 7. What set theoretic properties must two cards E and F 
satisfy ,0 that it is possible to construct a third card G with which the magic 
trick can be played? 
6. From a universe of seven objects. find seven sets each containing three object; 
such that each object is contained in three sets and the intersection of any pair 
of sets consists of one object. 
7. Let the universe consist of all five-bit binary rractions. Suppose that .-t =, 
::x:::x: ::: 1). B = ix: x has a 1 in its} columni. C = :x: x has an odd number 
of 1 s in its representation:, D = : x: the last two bits of .\ :ue 0:' and f. =, 
::x:: ± < x < ii. 
(a) Describe the complementary set in each case. 
(b) List or describe .-1 Ii B .
.. ~ u B . .-I Ii C. .. ~ U C .. -1 n D,~ n E. B II D. 
BuD. enD. CuE. and D ') E. 
8. Using the universe and sets .-I. B, . ... E of the previous problem. identify the 
following sets and then ,how that the indicated identity is valid. 
14 

1:6 
PICTliRES OF SETS 
(a) (D u E), (C n D), (C n E): 
C n (D u E) = (C n D) u (C n E). 
(b) (A u C), (A n E), (C n E): 
(A u C) n E = (A n E) u (C n E). 
(c) (B u D), B
C
• DC: 
(B u Dlc = Be n DC. 
(d) (A n E), A
C
• 1::": 
(A n E)e = A
C u Ee. 
(e) (B n E), (A u E), (A u E): 
A u (B n E) = (A u B) n (A u E). 
1:6 PICTURES OF SETS 
Given two sets, A ~nd B, in the s~me universe we c~n form their union ~nd 
intersection ~s indic~ted in Section 5. We can also form their difference. which is 
defined as follows: 
A - B = ix: x E A and x rf: B}. 
Thus A - B is ~ subset of A and is sometimes called the relative complement of 
B with respect to .4. This is because if you narrow your viewpoint to think of A 
as the whole universe, then it is natural to restrict B to A n B. Now. in the /1-
universe, Be = A-B. Notice also that this provides us with ~n alternative v.ay 
to represent A
C as U - A, where U is the universe under consideration. 
Example 6.1. 
Let A and B be defined as in the original card trick. 
A -
B = : x: x E A and x rf: B 1 = [8. 9, 10, I I : . 
~ote that 
B-04= :x:xEBandxrf:A] = :4,5,6,7]. 
We shall study relations between sets and shall want to establish the validity 
of certain assertions. For example, we claim that it is ~Iways true that A - B J.nd 
B - A are disjoint. that is. they have no element in common; in symbols 
(A -
B) n iB - .4) = 0. 
How can we be sure that this statement is always true'! It was true in the case of 
Example 6.1. but we need a general proof like the following. Suppose that '( is an 
element of (A -
B). Then '( is in A, but not in B. Consequently, x is not in Band 
cannot be an element of (B -
.4), which is a subset of B. Thus the set 1,4- B) 1as 
no element in common with the set (B ---I), and so the intersection is empty. 
Writing a correct proof is more complicated than working nut a specific ex-
ample. The reason for this complexity is that it is necessary to chase down all the 
definitions and all possible cases. English is a somewhat clumsy vehicle with which 
to do this. These sorts of logical arguments arc made easier both to construct and 
to read when accompanied by a pIcture. 
.!5 

I 
SETS AND ALGORITHMS: AN INTRODUCTION 
B 
la) 
If A and B have common elements. 
(b) 
If A and Bare disloint. 
A 
B 
Ie) 
If B is a subset of A. 
Id) 
If A is a subset of B. 
Figure 1.3 
To obtain a picture of a particular statement concerning sets, we represent 
the sets in question as regions of the plane. For example, the set A can be con-
veniently thought of as all points that are inside of or on the boundary of a circular 
region. Thinking of B in the same way, we can pIcture these two sets at the same 
time with one of the diagrams in Figure 1.3. 
We concentrate on the tirst picture, since in some sense it represents the most 
general situation for two sets. We label the various regions of the plane with thl! 
sets they represent (Figure 1.4). These pictures are called Venn diagrams. Fre-
quently, they are made more useful by appropriate shading of the basic regions. 
fA UB)'" 
A-B 
B-A 
Figure 1.4 
26 

1:6 PICTURES OF SETS 
A 
13 
Figure 1.5 
Example 6.2. 
Given sets A, B, and C Figure 1.5 shows a shaded Venn diagram 
that highlights the set A rI (B u C). 
Question 6.1. 
Draw shaded Venn diagrams for the following: (a) (A u B)e, 
(b) Ae u Be, (c) (A rI B)", (d) .4" rI Be, (e) .4 u ((B rI en, and (f) (A u B)e rI 
(A u ej". 
Again we choose to draw the circles as mutually and partially overlapping. 
If we knew more about specific properties of the sets, for example. that A <;:: B 
or that Brie is empty, then we could incorporate these properties in the pic I ure. 
but when the sets are unspecified the drawing in Figure 1.5 is most useful. 
From the Venn diagram in Figure I.S you might notice. for example, th,it 
A rI (B u C) = (.4 rI B) u (.4 rI C). 
The Venn diagram convinces us of this equality but does not prove the result. 
For example, does the equality still hold when A rI B is empty or B <;:: C? TD be 
certain of this statement, we construct an abstract and fully general proof. 
There is a straightforward strategy to prove that two apparently different sets 
are equal. If the two sets are called V and W. first take an element in V and 
show that it must be in W: thus V <;:: W. Then take an element in Wand show 
that it must be in V. Then W <;:: V. and we conclude that V = W. 
We follow this strategy here. Let x be in A rI (B u e). Then x is in .4 and 
in addition x is in either B or C (or both). Thus either x is in A and B or x 
is in A and C that is, x is in (.4 rI B) u (A rI e). Conversely. if x is in \ A rI B) u 
(A n C). then x is in A (1 B or x is in A rI C. Since both Band C are subsets of 
B u C we have '( is in A rI B <;:: A n (B u C) or x is in .1 rI e <;:: A.I (B '.J C) 
as desired. 
27 

SETS AND ALGORITHMS: AN INTRODUCTION 
We have completed a proof of the following theorem. We mark the end of 
a proof with a square box. It often helps to announce that what was supposed 
to be proved has been proved. 
Theorem 6.1. 
If A. B. and C are sets in a universe U. then 
A n (B u C) = (A n B) u (A n C). 
Question 6.2. 
From your Venn diagrams of Question 6.1 what other pairs of 
seemingly different sets are in fact the same? Prove that these sets are equal. 
EXERCISES FOR SECTION 6 
1. Draw a Venn diagram of your three-card magic trick from Exercise 5.4. Label 
points with the integers O. 1, .... 7 and show in which region each of these 
points lies. 
2. Copy the Venn diagram in Figure 1.4 and explain why 
(A u B) = (A -
B) u (B -.4) u (A n B). 
Explain why each pair of the sets (A -
B), (B -
A), and (A n B) is disjoint. 'We 
say that A u B is the disjoint union of (A -
B), (B -
A). and (A n B), and that 
these three sets partition A u B. 
3. Draw a Venn diagram that portrays arbitrary sets A. B, and C. and shane 
the region that represents the set A u (B n C). Then on a separate Venn dia-
gram shade in the sets .4 u B and A u C. and show that 
.4 u (B n C) = (A u B) n (A u C). 
Finally, give a proof that the last equality holds for all sets ..t, B, and C. 
4. Draw shaded Venn diagrams for each of the following: 
(a) (;I n B n C)". 
(b) (A u B u Cl". 
(c) .4." u B" u C. 
(d) 
I" u (B"" Cl. 
(e) A" n (B
C u C''L 
(f) .1" n B" n C. 
From these diagrams find pairs of sets that are equal. 
5. Draw shaded Venn diagrams for each of the following: 
(a) (A -
B) n C. 
(b) A u (B -
C). 
(e)i II (B - C). 
(d) (A -
B) u C. 
(e) (A n C) -
(B n C). 
en IA u C) - IB "J C). 
(g) (A '0 B)- (A I~ C). 
(h) IA n 13) -IA n C). 
18 

1:7 SUBSETS 
6. Suppose that ,1. B. and e are three sets such that A c;; Band B n e is tne 
empty set. Draw a Venn diagram that illustrates this situation. Next draw a 
Venn diagram that illustrates the case when .4 c;; B and A n e is the empty set. 
7. Suppose that .-1, B, C and D are four sets in the same universe with the 
property that A and D do not intersect while both Band e intersect both 
A and D as well as each other. Draw a Venn diagram that pictorially repre-
sents this situation: label it and shade in the region (4 u D) n (B n C). 
8. Given sets A. B. and e in the same universe, draw a Venn diagram to indi-
cate the set D. where 
D = (B II (A u e)) u (e II ,4). 
Give a proof that A II Bile r:; D. 
1:7 SUBSETS 
In the previous section we saw how two or three sets. say A. B. and C could be 
combined to form new sets like A-B. A II (B u e), and (A II Bf Beginning with 
only one set A, we can also derive a variety of different sets, for example. Ae Jnd 
the subsets of A. 
If A = Z. the integers, there are intlnitely many subsets of Z. F o[ instance, C,)I1-
sider all sets of the form : i. i -j- I: for i in Z. But if the set .~ contains a finite 
number of objects. then there can only be a finite number of different subset~ of 
..t. If A contains 11 objects. A is called an If-set. We investigate now how many 
subsets an II-set has and how we can go about finding all of them. 
Example 7.1. 
Suppose that F is the set of fruit in my refrigerator at this moment; 
F consists of one apple, one banana. and one cantaloupe. Expressed more briefly. 
F = ia.h.c). 
Then the subsets of F consist of the choices I have in selecting fruit for dessert. 
and these choices vary from the extremes of the empty set (i.e .. no fruit for dessert) 
to the whole set F (i.e .. eating all three pieces of fruit.) 
Question 7.1. 
Show that there are eight possible fruit desserts in Example 7.1 by 
listing all subsets of F. 
A setl with only one dement has exactly two subsets: itself and the empty 
set. But if ,t = : iI. h:, then we tind four subsets: /1. : Ll:, : h:. and the empty set 
29 

1 SETS AND ALGORITHMS: AN INTRODVCTION 
From your work in Question 7.t it should seem plausible that if A is any set con-
taining three objects, then there are eight subsets of A. In general if A is an f)-set. 
then A has 2" subsets, a result we shall demonstrate later in this section and prove 
rigorously in Chapter 2. We want to study such a general f)-set A, where Il is a 
positive integer. Typically, we describe the set by 
where a 1,Ll2"" ,an stand for the 11 elements in A. These may be the num-
bers 
~ 1, 2, ... ,ilL or they may stand for a different set of numbers like 
: 1,5,17,25, ... ,94)' or they may stand for names of pieces of fruit as in 
: apple, banana .... , quince]. Here are two methods to list all subsets of a general 
set like A. 
Problem. 
Given an Il-set A = (Ll l' Ll2,' .. , an;' list all 2n subsets of A. 
Response 1 
STEP 1. List the empty set 
STEP 2. Set j : = 1 
STEP 3. List all subsets of A that contain j elements 
STEP 4. If j < n, set j : = j + [ and go to step 3; otherwise, go to step 5 
STEP 5. Stop. 
Is it clear how to carry out step 37 For example, if A contains [7 element~. 
and j = 9 we must list all subsets that contain exactly 9 elements. But how? (A 
subset containing j elements is known as a j-subset. In Chapter 3 we'll study tht: 
problem of counting and constructing .i-subsets of an Il-set, for j an arbitrary inte·· 
ger between 0 and 11.) For now Response [ is too imprecise for us to call it an 
algorithm or to use it effectively. 
The idea of the next response is to begin by listing all subsets of : a 1 : ; we've 
seen above how to do this. Then we add to the list those subsets of : U I' a,} that 
have not been listed so far, namely those subsets that contain Ll2' Then we list 
additional subsets of : a l' a 2' a3 } that contain a 3 and therefore have not been listed 
so far. More generally, once we've listed all subsets of : ai' il 2 , ...• a j:' then we just 
need to add in the subsets of : aI' ... , a j' Uj + I) that contain the last dement a j + I' 
Response'; I Algorithm SUBSET) 
30 
STEP 1. 
List the empty set 
STEP 2. Set j : = I 

1:7 SUBSETS 
STEP 3. For each subset B listed so far, create and list the subset B u : a i: 
[At this point we've listed all subsets of :a1,'" ,aj].] 
STEP 4. If j < 11, set j : = j + I ;.tnd go to step 3; otherwise go to step 5 
STEP S. Stop. 
Example 7.2. 
WeapplythealgorithmSUBSETtotheset.4 = [a 1,a:;] withn == 2. 
In Table 1.4 we trace for each step the value of the variable.i and show the subsets 
as they are produced. 
Table 1.4 
Stf!P 
2 
3 
4 
3 
4 
5 
Value AssiiJlled to.i 
List of Subsets 
o 
2 
o u {a2} = {U2} 
;at ~ u {al} = ~al~(2) 
]. 
STOP 
Question 7.2. 
With A = [a 1,a2,a 3 } use SUBSET to list all of A's subsets. 
How do we know SUBSET is a correct solution? We don't. We only have 
evidence from the examples we've done, 11 = 2 and 3. Perhaps we have confidence 
that this approach will continue to work for larger n. To be certain of the validity 
of SUBSET, we need a proof of its correctness: however, we must defer the proof 
until Chapter 2 where we'll develop more proof techniques. 
One additional important set that is constructed from a single set is kn.)wn 
as the C;.trtesian product. We have been stressing that order in sets and subsets 
does not matter, but there are many instances when order does matter. For ex-
ample, in the magic trick an answer "yes, yes, no, yes" gives us information about 
a number on cards .4, B, C, and D (in that order), and it is important to the game 
that the responses ;.tre given in the correct order. Similarly, in the binary number 
IIO! and the decimal number 29 the order in which the digits are presented is 
crucial to our representation of the numbers. The Cartesian product is exactly the 
idea that we need. 
If A is any set, we define the Cartesian product A x A to be the set of all 
ordered pairs (s, t) such that sand t are clements of A. Symbolically, 
A x A = :(s,r):sandtEA}. 
31 

1 SETS .\ND ALGORITHMS: AN INTRODLICTION 
Notice that we have called these ordered pairs; that is, we consider (s, t) to be dif-
ferent from the pair (t, s) because the order of the dements matters in this setting. 
Also notice that we may have a pair of the form (s, s) as well as (s, t) with s 1= t. 
Similarly, we define 
A x A x A = :(s.t,u):s.t,anduEA), 
and, in general, for any positive integer 11 we define the Il-fold Cartesian product 
.4 >< A x ... x A = A" 
= :((/1'(/2' .... '(/11): ii, E A for i = 1, ... ,11]. 
An element of Ax A:< A is often called an ordered triple and an element of A" 
is known as an (ordered) n-tuple. 
Example 7.3. 
Let.4 = : 0, 1]. Then A x A consists of the four ordered pairs (0,0), 
(0, 1). ( 1,0), and (\, 1). We may associate with each of these a binary number with 
exactly two digits. A" consists of all n-tuples of zeros and ones and thus corre-
sponds with all binary numbers of length 11. 
Without listing elements. we could have seen that A x A contains four pairs 
by the multiplication principle: In each pair (s. t) there are two choices for sand. 
independent of these choices. there are two choices for t. The multiplication principle 
also tells us A x A x A contains '2' 2 . 2 = 8 triples and that A x .4 x A x A 
contains 16 4-tuples. Generalizing this prOl:ess to A". A" contains '2"Il-tuples. From 
this we conclude also that there are 2" binary numbers of length II. 
Question 7.3. 
If 04= :0.1.'2.3.4.5.6,7.8.9]. describe A x A . .4 x A x .CandA" 
for 11 an arbitrary positive integer. 
Question 7.4. 
If A =:a.b.cl. list all elements of Ax A. If A contains r objects. 
how many objects does A x A contain'? How many does A x .4 x .4 contain'? A"'.' 
Example 7.4. 
Let A = Z. Then Z x Z is the set of ordered pairs (i.i), where i and 
j are integers. We often think l)f these as points in the coordinate plane with both 
coordinates being integers. If A = R. (he real numbers. then R x R gives liS the 
real, 2-dimensional coordinate plane and R x R x R or R3 is (real) 3-dimensional 
coordinate space. 
When A = : o. 1:, the Cartesian products A x .1. A x A x4 ..... and .. j" are. 
perhaps surpnsingly, related (0 subsets of a 2-set. 'iubsets of a 3-set. .... and 
subsets of an l1-set. Suppose that S is an II-set. and that its elements are listed in 
32 

1:7 SUBSETS 
a fixed order, say x, y,.::, ' ... For each suhset T of S we may construct an Il-tuple 
of Os and Is (an element of A") whose first entry is a 1 if and only if\, the first 
element of S, is contained in T. ~ext, the second entry in the n-tuple is a 1 if and 
only if y, the second element of S, is in the subset T. and so on. Thus each subset 
is described by the Il-tuple or the string of binary digits as derived above. (The 
II-tuple is also called the bit vector or the characteristic function of the subset.) A 
subset containing exactly i elements corresponds to an II-tuple containing i ones 
and In -
i) zeros. Conversely, every n-tuple of A" corresponds to a unique subset 
of S: For j = L 2, ... ,11 the subset contains the ith element of S if and cmly if the 
.ith entry of the II-tuple equals 1. 
Question 7.5. 
Given the universal set S = : u, L" lV, x, y,,:: j, explain why the bit 
vector of T = : u, [" y 1 is 1100 I O. Then find the bit vectors of the subsets : u, w,.::: 
and:.'(, y,.:::. Explain why the subset corresponding to the string 000001 is :.:::. 
Then find the subsets corresponding to the strings 000010 and 111100. 
Now we see why there are 2" subsets of an II-set. We know from Example 7.3 
that there are 2" elements in A". Each Il-tuple of A" corresponds to one subset of 
an n-set, and every subset of an Il-set corresponds to exactly one Il-tuple. Thus 
there are as many subsets of an II-set as there are II-tuples in A" = :0,1 :". 
Cartesian products also generalize to different sets. Specifically, we define 
A x B = : (s, r): SEA and t E B: 
and 
A x B x C = :eu,u): sEA, 1 E B, and 11 E C:. 
An ordered list of elements taken from one I)r several sets is called by a variety 
of names. We have previously called a binary number a string and a sequenGe of 
zeros and ones. We shall also call an II-tuple a vector and an array, depending 
upon the convention in the particular example. 
The Cartesian product is familiar from coordinate geometry of real 2- and 
3-dimensional space. This product is important in computer science and arises, 
for example, in presentations of abstract conceptions of computers, called Tllring 
machines. 
EXERCISES FOR SECTION 7 
1. Let .. ~ = : 11, h, L, Ii, L':. List all subsets that contain one element. then all sunsets 
with two elements, next all subsets containing three elements, and finally all 
subsets that contain four elements. How many subsets have you listed? 
33 

1 SETS AND ALGORITHMS: AN INTRODUCTION 
2. Given a set with II elements, A = [a l ,a 2, ... ,LI,,;, explain why A has exactly 
n subsets that contain one element. Then write an algorithm that will list all 
subsets of A containing just one element. 
3. A subset of an n-set A that contains n -
I elements can be formed by omitting 
just one element of A. Explain why A contains IJ subsets with n - 1 elements 
and then explain how to list them. 
4. List and count all subsets of A that contain two elements when A = (a l' il 2 , a 3 j, 
when A = {a1,u2,u3,Ll4}. and when A = (a1oa2,a3,a4,a5]' 
5. Explain why, for a positive integer 11, the set A = {Lll' a2" .. , an] contains 
n(1l -
1)/2 subsets with two elements. 
6. Given the set A as in Exercise 5, design an algorithm that will list all subsets 
of A that contain exactly two elements. 
7. If A = [a t, a 2" .. ,an}, determine a formula for the number of subsets of A 
that contain n -
:2 elements. 
8. If A is an II-set, determine a formula for the number of subsets of .4 that 
contain exactly three elements. 
9. In Exercise 5.1 we considered the universe of all two-letter "words." Find a 
set S such that this universe can be described also as S x S. Then find a set 
T such that the subset D of that problem can be described as TxT. Is there 
a set V such that the subset .4 can be described as V x V? 
10. List all four-digit binary numbers. Then associate each with a subset of 
A = [a, b, c, d} and check that all subsets of A have been listed once and only 
once. 
11. Suppose that A = [d,e./) and B = [U,h). List all elements of Ax B. If A 
contains r elements and B contains s elements, how many elements are con-
tained in A x B? Justify your answer. If, in addition. C contains t elements, 
determine the number of clements in A x B x C. 
12. Canadian zip codes are always six symbols long, alternating between letters 
and digits, beginning with a letter; for example, H4V-2M9 is a valid zip code. 
Find sets A and B and express the universe of all possible Canadian zip codes 
as the Cartesian product of As and Bs. How many zip codes are possible? 
13. Massachusetts license plates are six symbols long and each symbol may be 
either a letter or a digit. Express the universe of all possible license plates as 
a Cartesian product of an appropriate set or sets. How big is this universe? 
14. Suppose that my refrigerator contains four pieces of fruit: two apples, one 
banana, and one cantaloupe. List all possible fruit desserts. By a fruit dessert 
I mean a collection lJf rruit (possibly empty). Next suppose that I have five 
pieces of fruit: two apples. one banana, one cantaloupe, and one damson plum. 
34 

1:8 SET CARDINALITY AND COCNTING 
List and count all possible fruit desserts. In general, given the so-called multiset 
with the first element repeated, find a formula for the number of different 
subsets of A. The two copies of a 1 are considered to be indistinguishable. 
1:8 SET CARDINALITY AND COUNTING 
A set A is said to be finite if it consists of a finite number of objects. An In-set A 
is a finite set containing In objects for In, a positive integer. We also say that A has 
cardinality m and write 1,..11 = rn. In our original magic trick the universe has car-
dinality 16 while each of the sets .4, B, C and D has cardinality 8. 
Example 8.1. 
Let the universe consist of the positive integers less than 30. If 4 = 
[x: x is even], B = {x: x is divisible by 3], and C = [x: x is divisible by 5}, :hen 
1,.11 = 14, IBI = 9, and Iq = 5. 
Example 8.2. 
Suppose that we wanted to know the cardinality of A u B from the 
previous example. A u B = (x: x is divisible by 2 or 3}. We list the elements of 
Au B. 
Au B = :2,3,4,6,8.9.10,12,14,15,16,18.20.21,22,24,26.27,28). 
Note that the cardinality of A u B equals 19. This, at first. may seem somewhat 
strange. We took the union of a 14-e1ement set and a 9-element set and came up 
with a 19-e1ement set. 
Question 8.1. 
In the context of Example 8.1. find IA u ct and IB u q. 
Question 8.2. 
In the original magic trick what is the cardinality of each unil)fi of 
two cards? 
We shall frequently have occasion to count the number of elements in particular 
sets. and often these sets can be written as the union (or intersection) of simpler 
sets. The counting question becomes: Given the cardinalities of two sets A and B. 
what is the cardinality of their union (or intersection)'? 
Question 8.3. 
If possible. find as-set .4 and a 3-set B whose union is a set of 
cardinality la) 4. Ib) 5, IC) 6, Id) 7. Ie) 8, and if) 9. 
35 

I SETS AND ALGORITHiVIS: AN INTRODUCTION 
In trying to answer the above question, you probably came up with ~ome 
conclusions about the possible cardinalities of the union of two sets. If you look 
back at Example 8.2 and Questions 8.1 and 8.2. the following result seems plausible. 
Theorem 8.1. 
Given sets A and B in the same universe. 
lA '.~ BI = IAI-I- IBI-IA I. BI· 
Example 8.2 (continued). 
We know that IAI = 14 and IBI = 9. 
A n B = 
~ x: x is divisible by both 2 and 3) 
=~ x: x is divisible by 6} =, {6, 12, 18,24). 
Thus IA n BI = 4. In this particular instance we verify Theorem 8.1 by noting that 
14+9-4=19. 
Proof' o( Theorem 8.1. 
We must show that each element of A u B contributes 
exactly one to IAI + lBI -[A n BI (see Figure 1.6) 
A 
B 
Figure 1.6 
Case i. 
Suppose that x is a member of only one set, say A. Then x is counted if 
IAI, but not in IBI nor in !A n BI, since A nBs B. Thus x contributes a count 0' 
one to iAI + iBI - IA n BI. If x is in B. but not in A, a similar argument suffices. 
Case ii. 
Suppose that, is an element of both .,.{ and B. Then x is counted once 
in 1,11, once in IB\, and <)!lee in 1,,4 n BI. Thus it contributes 1 + 1 - 1= 1 to 
, 
I 
I 
I 
'AI + !BI- iA II BI, just as we wanted. 
Example 8.3. 
How many ,even-digit telephone numbers are there that begin 
584- and contain at least one 0 and at least one I'? Suppose that we let A be the 
36 

1:8 SET CARDINALITY .\ND COUNTING 
set of all such numbers that contain a 0 and B be the set of all numbers that 
contain a 1. The telephone numbers we're looking for are in both .1 and 13. Thus 
we want IA n 131. By Theorem S.I, iA n 131 = IAI + [BI- iA uBI. First let's find 
1,.11. ISee Exercise Ll1.) There are 10" possible telephone numbers, since there are 
10 choices for each of -+ numbers. If we exclude 0, then there are <) choices for 
each of 4 numbers. Thus there are 94. numbers that contain no O. Thus IAI = 
104. - 94 . Similarly, 1131 = 104. -
9-+. What about IA uBI'? There are 84. nu~bers 
that contain neither a 0 nor a I and so IA u BI = 104. -
S4.. Thus 
Question 8.4. 
A joint meeting of Discrete Mathematics and Introductory Com-
puter Science had 232 students. If 146 students are enrolled in the mathematics 
course and 205 students are enrolled in the computer science course, how many 
students are enrolled in both courses at once'? 
We present a formula that generalizes the pattern of Theorem S.l from two 
sets to three sets; the proof is similar. See Exercise 12. 
Theorem 8.2. 
Given sets .-/, B, and C in the same universe, then 
I See Figure 1.7.) 
Figure 1.7 
37 

I SETS AND ALGORITHMS: AN INTRODUCTION 
Example 8.4. 
Let A. B. and e be the sets from the original magic trick. Then 
Au B u e =:2.3.4.5.6.7,8,9.10. II, 12.13, 14.15} contains 14 elements. As we 
have seen IAI = IBI = ICi = 8. We have also noted that the intersection of any two 
of these sets has cardinality equal to 4. You can check that A (I B (I e =: 14, IS}. 
Then 
IA u B u Ci = 8 + 8 + 8 - (4 + 4 + 4) + 2 = 14. 
The Principle of I nclusiOIl and Exclusion. 
Theorems 8.1 and 8.2 are both instances 
of a general counting result known as the Principle of Inclusion and Exclusion 
or P.LE. for short. The same type of counting formula applies for 4 or 5 or k. an 
arbitrary number, sets. See Exercise 13. 
EXERCISES FOR SECTION 8 
1. Refer to the sets in Exercise 5.1. Determine the indicated set cardinalities and 
then check the validity of Theorem 8.1: 
(a) IA u BI = IAI + IBI-IA (I BI· 
(b) IA u CI = IAI + ICi - iA (I Ci· 
(c) IB u DI = iBI + IDI-IB (I DI· 
(d) ID u EI = IDI + IEI-ID (I EI· 
2. Refer to the sets in Exercise 5.2. Determine the indicated set cardinalities and 
then check the validity of Theorem 8.2: 
(a) IA u e u DI=iAI+ICi+IDI-IA (I Ci-IA (I DI-IC (I DI+IA (I C (I D!. 
(b) Ie u D u EI=iCi+IDI+IEI-IC (I DI-IC (I EI-ID (I EI+IC (I D i' EI. 
3. Of the 876 students living in the Quadrangle. 530 have completed Introductory 
Computer Science. 364 have completed Calculus II. and 287 have completed 
Chemistry I. Of course. lots of students take more than one of these courses. 
In fact. 213 have completed both mathematics and computer science. 164 have 
completed both mathematics and chemistry. 116 have completed chemistry 
and computer science. and 103 have completed all three courses. How many 
students living in the Quad have completed none of these three courses? 
4. There were 184 students enrolled in Introductory Computer Science last fall. 
Of these 112 will take Data Structures. 84 will take Foundations of Computer 
Science. and 46 will take Assembly Language. Of the total. 66 will take both 
Foundations and Data Structures. 37 will take Assembly Language and Data 
Structures. and 30 will take Assembly Language and Foundations. If 4S of 
the original students take no additional computer science. how many students 
take all three of the intermediate courses? 
5. The registrar informs us that three years ago I 19 students enrolled in 1 ntro-
Juctory Computer Science. In the following semester, of these I 19 students, l)6 
38 

1:8 SET CARDrNALlTY AND COUNTING 
took Data Structures. 53 took Foundations, and 39 took Assembly Language. 
Also 38 took both Data Structures and Foundations. 31 took both F ounda-
tions and Assembly Language. 32 took both Data Structures and Assembly 
Language. and 22 brave souls took all three courses. We claim that the registrar 
must have made an error. Why? 
6. How many seven-digit telephone numbers are there that begin with 584- and 
that contain a O. a I, and a 2'; 
7. Suppose that A and B are sets in the universe U. Find a way to express the 
cardinality of the set ;Ie u Be in terms of the cardinality of U . .4, B. and com-
binations of these sets. 
8. Consider the universe of all possible strings of six letters made from the letters 
a. b, c, d, e,f with no repetitions of letters. How many such strings are there in 
total? How many of these are such that the first letter is neither "(/" nor "h" 
and the last letter is neither "e" nor 'T'? (Hint: Let A be the set of all t1ese 
words that do begin with an a or band B the set of those that end with an 
e or f. Then we are looking for the cardinality of Ae (\ Be.) 
9. A group of 100 students was surveyed to determine the students' intere:;t in 
winter sports. It was found that 69 liked downhill skiing, 38 liked cross-country 
skiing, 75 liked skating, and 15 liked none of these sports. On further ques-
tioning it was determined that 35 liked both kinds of skiing, 30 liked cross-
country skiing and skating, and 42 liked downhill skiing and skating. How 
many like to ski, either downhill or cross-country? How many like all three 
sports? 
10. [n a sample of 100 students. 43 like avocados, 71 like radishes, and 36 like 
olives in their salad. Each student liked at least one vegetable. If 26 stucents 
like both avocados and radishes, 16 students like avocados and olives while 
22 like radishes and olives. how many students like all the ingredients in an 
avocado, radish, and olive salad? 
II. Here is an alternative proof of Theorem S.I. Give reasons for each of the fol-
lowing steps: 
STEP I. If A (\ B = 0. then 14 u BI = 1.11 + iBI 
STEP 2. 
B = (.4 (\ B) u (B -n 
STEP 3. IBI = IA n BI + :B - .11. 
STEP 4. :B - AI = iBI - 1.4 n BI. 
STEP 5. 
A u B = .-1 u (B - 4). 
STEP 6. :A u BI =.41 + IB - AI. 
= !AI + IBI- ill n BI· 
STEP 7. :A!J BI = iAi + iBI - !rl (\ BI. 
.39 

I SETS .\NO ALGORITHMS: AN INTROOLCTION 
12. Prove Theorem 3.2. (Hillt: Ld c be an element of A u B u C. Show that c's 
contribution is exactly one. Divide the proof into three cases depending on 
how many of 4. B. and C contain c.) 
13. Find an expression for the cardinality of the union of four sets in terms of 
the cardinalities of the sets and various intersections. 
1:9 FUNCTIONS 
The concept of a function is fundamental to both mathematics and computer 
science and will be Llsed throughout this book. 
Definition. 
A function f is a mapping from a set D to a set T with the property 
that for every clement d in D. f maps d to a unique clement. denoted I(d). of T. 
Here D is called the domain of I. and T is called the target of f. We write 
f: D ...... T. We also say that f(d) is the image of d under J. and we call the set 
of all images the range R of f. In set notation 
R. = [f(d): d E Dj. 
Note that R ~ T. 
A mapping might fail to be a function if it is not defined at every clement 
of the domain or if it maps an element of the domain to two or more elements 
in the range. Figure 1.8 illustrates these ideas. 
To detine a function f. we must specify its domain D and a rule for how it 
operates. If the domain is changed. we consider that a new function is formed. 
fa) A function. 
~ 
\~~ 
'('I 
l\1ot a function. 
Figure 1.8 
Ihl A function. 
lel) 
Not a function. 

1:9 FUNCTIONS 
For example, f{x) = x2 with D equal all real numbers and g(x) = x 2 with D equal 
all reals greater than one are different functions. They have different graphs. for 
instance. Given a function f with domain D. the range R is determined. How-
ever, in a specific instance, it might take some effort to decide what the range is. 
In the preceding example the range of f is all nonnegative real numbers and the 
range of g is all reals greater than one. In contrast the target of a function is not 
uniquely determined. It is often useful to designate a target T that is a large and 
familiar set containing the range. Thus we stated that the functions f and 9 above 
have the real numbers as target. We could also have picked the nonnegative 
reals as the target. 
In this section we shall consider repeatedly the functions that map a binary 
number to its decimal equivalent and a natural number to its binary equivalent. 
We don't have formulas for these functions, like f(x) = x 2 , but we can think about 
these mappings, and we have algorithms to compute these functions whenever 
necessary. 
Example 9.1. 
Let B be the set of all binary numbers, or equivalently all finite 
strings of zeros and ones, and let N be the set of all natural numbers expressed 
in decimal notation. Then f, g, h, and j given below are functions from B to N. 
For sin B, 
and 
f{s) equals the decimal equivalent of s. 
g(s) equals the number of bits in s, 
l1(s) equals the number of ones in s, 
j(s) equals the ones bit of s. 
For instance, ifs = 110010, thenf(s) = 50, g(s) = 6, l1(s) = 3, andj(s) = 0. The range 
of f, g, and h is in each case all of N. To see this, let m be any decimal number 
in N. If s is m's binary equivalent, then f{s) = m. If r is the binary number con-
sisting of m ones, then g(r) = h(r) = m. However, the range of j is [0, 1). 
and 
Here are two mappings from B to N that are not functions. For s in B, 
k(s) equals the fifth bit in s, counting from the left, 
{
I if s ends with 1 
/(s) = 
2 if s ends with 0 
4 if s ends with 00. 
41 

1 SETS AND ALGORITHMS: AN INTRODUCTION 
The mapping k is not defined on all of B, only on those with five or more digits, 
and I specifies two different images for strings ending with two zeros. 
Question 9.1. 
Suppose that Band N are as in the preceding example. Define 
b: N ---+ B by b(r) = s if s is the binary equivalent of the decimal number r. Ex-
plain why the range of b is all of B. 
Question 9.2. 
Which of the following is a function from N to 8, where Nand 8 
are as defined in Example 9.1? For r in N, 
and 
I1 (r) equals the number of digits of r, 
{o 
if r is even 
J2(r) = 1 
if r is odd, 
J~(r) equals the string of r ones, 
if 2 di vides r 
if 3 divides r 
if neither 2 nor 3 divides r. 
For each that is a function, specify its range. 
A function is said to be onto or an onto function if its range equals its target, 
R = T. Thus functions f, g, and h of Example 9.1 are onto, but j is not. In Fig-
ure 1.8 the first function shown is onto whereas the second is not onto. We also 
say that two functions f and g are equal if they have the same domain D and 
f(d) = g(d) for every d in D. 
Sometimes the domain of a function is a set of sets. 
Example 9.2. 
If U = {a 1,u2"" ,an}, let P(U) be the set of all subsets of U. We 
know that P(U) contains 2" subsets. We define the complementation function 
c:P(U) ---+ P(U) by c(A) = A
C for every A in P(U). Then c is an onto function, 
because for every set Bin P(U) we have 
If we define n:P(U) -> P(U) by n(A) = 0 for every A in P(U), then n is not onto. It 
is evident that the functions c and n have the same domain, but they are not equal. 
Question 9.3. 
Which of the functions in Questions 9.1 and 9.2 are onto? 
42 

1:9 FUNCTIONS 
A function is said to be one-to-one lor 1-1) if it maps distinct elements of the 
domain to distinct elements of the range. In other words, if d of. d', then f(d) of. 
f(d'). A diagram of different function properties is shown in Figure 1.9. 
(a) 
One-to-one and onto function. 
(b) 
One-to-one but not onto function. 
(c) 
Not one-to-one function. 
(d) 
Not a function. 
Figure 1.9 
Example 9.1 (continued). 
Here again are the functions defined in Example 9.1. 
For s in B, 
and 
I(s) equals the decimal equivalent of s, 
yls) equals the number of bits in s, 
hIs) equals the number of ones in s, 
)(s) equals the ones bit of s. 
The function f is one-to-one because if s J= s', then their decimal equivalents 
will be different. However, y is not one-to-one because, for example, y(lO!) = 3 = 
y(III). Neither II norj is one-ta-one, since II(lO!) = h(1lO) = 2, and j(101) = 
)(11) = I. 
Question 9.4. 
Let the functions h, j~, and /3 be as defined in Questions 4.1 and 9.2. 
Which of these functions is one-la-one and why? 
43 

1 SETS AND ALGORITHMS: AN INTRODUCTION 
Question 9.5. 
Let U = (a"a 2 , ...• an}. Is c:P(U) -> P(U) defined by cIA) = .·t
C a 
one-to-one function? 
Suppose that a function f:D -> T is not one-to-one. Then we know that there 
is an element t and two elements d =1= d' in D such that f(d) = f(d') = t. The next 
result gives a condition under which a function is surely not one-to-one. 
The Pigeonhole Principle. 
If f is a function with finite domain D and target T. 
where IDI > ITI, then I is not one-to-one. In particular, there is some element t 
in T that is the image of at least two different elements of D. 
Why is this so? The function f is either one-to-one or it isn·t. Since R ~ T for 
any function f. it follows that IRI ::;; ITI. If IDI > IT! and f were one-to-one, then 
IRI = IDI and so IRI > ITI, a contradiction. Thus I cannot be one-to-one. 
This principle has far-reaching applications in combinatorics. Its name derives 
from the following flightful application: If more than n pigeons fly into n pigeon-
holes, then some pigeonhole must contain at least two pigeons. 
Example 9.3. 
Let S be a set of 11 or more binary numbers. Then at least 2 ele-
ments of S must have the same last digit when expressed in decimal notation. The 
pigeonhole principle shows why: Define f* to be the function with domain Sand 
target T = {O, 1, ...• 9}, where for s in SJ*(s) equals the last digit of s when s is 
expressed in decimal notation. Since lSI> 10 = ITI, there must be two numbers 
in S that map to the same element of T. 
For further examples see Exercises 20~23 and Supplementary Exercises 11 
and 12. 
Often a function maps one set into the same set. that is, T = D. This was the 
case in Example 9.2 and Question 9.5. When T = D and the function is one-to-one 
and onto, it is called a permutation. The examples in Figure 1.10 illustrate per-
;z:: 
0 
.. 
0 
0 
.. 
0 
0 
.. 
0 
0 
.. 0 
0 
.. 
0 
>< 
0 
.. 
0 
0 
" 
0 
Identity 
Figure 1.10 
Permutations 

1:9 
FUNCTiONS 
mutations. One important, but easy, permutation is called the identity map or 
identity permutation. We define it by i:D -> D, where i(d) = d for every d in D. This 
map doesn't do much, but it is one-to-one and onto; soon we'll see that it plays 
an important role. 
When T = D, the properties of being one-to-one and onto are closely related. 
Theorem 9,1. 
Let D be a finite set and let I:D -> D be a function. Then f is 
one-to-one if and only if f is onto. 
Proof. If D has 11 elements and f is one-to-one, then R, the range of f, has n ele-
ments also. Since R c;; D and they have the same (finite) cardinalities, R = D and 
so f is onto. On the other hand, if f is onto but not one-to-one, then some pair 
of elements in D gets mapped by f to the same element. Consequently, the remain-
ing n - 2 elements of the domain must be mapped to n -
1 elements of the range. 
Then some element must have two images, contradicting the definition of a func-
tion. Thus f must be one-to-one. (See Exercise 24 for another look at this idea.) 
o 
Just as we can combine sets to form new sets, so can we combine functions to 
form new functions, Suppose that f: D -> T and y: T -> Ware such that the range 
of f is contained in the domain of y. Then we define the composite of y with f. 
denoted Y' f, to be the function 
y" I:D -+ W, 
where y. f(d) = y(f(d» 
for all d in D. In words this means that for d in D, we first map d to Tusing f, and 
then we map the result, f(d), to W using y. This process of combining two func-
tions is known as composition. Noti.ce that in the composition y' f, it is f that 
gets performed first even though it is y that is on the left and thus read first. This 
idea is illustrated in Figure 1.11. 
Figure 1.11 
.'!' / is shown in dashed lines. 
45 

1 SETS AND ALGORITHMS: AN INTRODlJCTION 
Example 9.4. 
If I: B -> ;V is defined as before with I(s) = In, where In is the deci-
mal equivalent of s, and if g: N -> N is defined by 
g(t) = {~ 
if t is even 
if t is odd, 
then we can define g " I: B -> N by 
y 'I(s) = gU(s)) 
= {~ 
iff(s) is even 
if I(s) is odd. 
Thus {j " I = j, where j is defined in Example 9.1. 
Now suppose that I: D -> T and {j: T -> D; that is, the domain of {j is the target 
of I, and vice versa. Then 
{jof:D->D, 
and the composite function takes us back where we started from. 
Sometimes {j' I does even more than that. If y 0 f = i, the identity map i(d) = d, 
then y is called the inverse of f. Specifically, if 
yo f(d) = y(f(d)) = d 
for every d in D, then 9 undoes the work of f, and 9 is the inverse of f. Similarly, 
if we compose the other way around, I' y: T -> T and get 
f ' y(t) = f(y(t)) = t 
for all t in T, then f is called the inverse of y. (See Figure 1.12, where f is shown 
with a solid line, its inverse by a dashed line.) 
Figure 1.12 
46 

1:9 FUNCTIONS 
Example 9.1 (continued again). 
Let f(5) = m and b(m) = 5 be defined as in Exam-
ple 9.1 and Question 9.1. Then b 0 f: B ~ B maps a binary number to its decimal 
equivalent and back to its binary equivalent. Thus b 0 f = i, and b is the inverse 
of f. Also f 
.~ b = i, since translating decimals to binary and then back to decimals 
returns the original decimal number. Thus f is also the inverse of b. Note that 
the two identity functions of this e:xample are different, since they have different 
domains. 
Example 9.4 (continued). 
Let f be as already given, and g: N ~ B be defined by 
g(t) = 0 or 1 according as t is even or odd. Then 9 <) f:B ~ Band f" U:N ~ N, 
but neither composite mapping is the identity. For instance, 9 0 f(101) = g(5) = 1, 
and f 
0 g(2) = f(O) = o. 
It is not by chance that in the latest continuation of Example 9.1 f and 9 
were inverses of each other. 
Theorem 9.2. 
Suppose that both f: D ~ T and g: T ~ D are onto functions. Then 
f is the inverse of 9 if and only if 9 is the inverse of f. 
Proof. 
Suppose that f is the inverse of g, that is, f " 9 = i. We must show that 
9 is the inverse of f, that is, we must show that go f(d) = d for all d in D. For 
any element d in D, since g: T ~ D is onto, there is an element t in T such that 
g(t) = d. Then 
9 C) f(d) = 9 "f(g(t)) = y(I(y(t))) 
= gU 'g(t)) 
= y(i(t)) 
= ytt) = d. 
by definition of y " f 
by definition off· y 
sincef· y = i 
The remaining proof, that if y is the inverse of f, then f is the inverse of q, goes 
the same way. 
C 
Question 9.6. 
Let U be a finite set, P(U) the set of all subsets of U, and c:P(U) ~ 
P(U) be defined by erA) = A". Then explain why c is its own inverse, that is, why 
c" c = i. 
In summary, a function, like an algorithm, has input and output, dements of 
the domain and range, respectively. So what is the difference between a function 
and an algorithm? An algorithm may have as input values for several variables, 
say x, q, and n. If x can be from the set A, q from B, and n from C, then the input 
to the algorithm can he thought of as one dement in the Cartesian product 
47 

I SETS AND ALGORITHMS: AN INTRODUCTION 
.4 x B x C. Similarly, the output of the algorithm can be thought of as an element 
from a Cartesian product. In short every algorithm is a function. Conversely, the 
functions in this book (though not all functions) are mappings that can be com-
puted by algorithms. sometimes by several different algorithms. 
There is. however, a striking difference in the contexts in which these concepts 
get used. When we think of an algorithm. we are vitally concerned with the 
mechanism by which a domain element d gets mapped to its corresponding range 
element f(d). In contrast, when we think of a function it is the correspondence 
itself that matters. not how f(d) is computed. One of the main goals of discrete 
mathematics is to supply the tools which enable a rational choice among various 
algorithms that evaluate a function. 
EXERCISES FOR SECTION 9 
I. Let N be the set of all nonnegative integers. Which of the following are func-
tions with domain and target N? 
(a) f(n) = II + 1. 
(b) f(n) = 2n + 1. 
. 
11 
(e) f(n) = ~ + 1. 
(e) f(n) = n2 + 1. 
. 
1 
(9) j (tl) = - + 1. 
11 
(d) f(ll) = n -
1. 
(f) f(n) = ,in + 1. 
(h) I(n) = n3 . 
(j) f(n) equals the remainder when 11 is divided by 3. 
Of those that are functions with domain and target N. find their range and 
determine whether or not they are onto. 
2. Let R be the set of all real numbers. Which of the following are functions 
with domain and target R? 
(a) f(x) = 2x + I. 
(e) f(x) = x-I. 
I 
(e) f(x) =- + 1. 
x 
(9) f(x) = lxi, where Ixl stands for 
the absolute value of x. 
x 
(b) f(x) = ., + I. 
(d) f(x) = ,/~ + I. 
(f) f(x) = x 2 -
3x + 2. 
Of those that are functions, find those that are one-to-one. 
3. Give an example of a function. with domain and target the positive integers. 
that is onto and is not the identity map. 
48 

1:9 
FUNCTIO,,"S 
4. If two functions are not equal, they are called different. Suppose that A = 
[al,a2, ... ,an]' How many different functions are there with domain A and 
target [0, I:? How many of these are onto and how many of these are 
one-to-one? 
5. For each of the following conditions give an example of a function I:Z ~ Z, 
where Z is the set of all integers, that satisfies the condition: 
(i) .f is onto and one-to-one. 
(ii) .f is onto but not one-to-one. 
(iii) .f is one-to-one but not onto. 
(iv) / is neither one-to-one nor onto. 
(v) Every integer is the image of exactly two integers. 
(vi) .f has an inverse g. 
(vii) / does not have an inverse g. 
6. Let U = {a l ,aZ,a3} and let S =, {all. For every set A in U we define the map 
/:P(U) ~ P(U) by /(A) = A n S and the map g:P(U) ~ P(U) by g(AI = 
A u S. Write down the image I(A) and fl(A) for every subset A. fs either I 
or 9 onto'? 
7. Let U = t a1, . .. , an}, and for S a fixed subset of U define I(A) = A n Sand 
g(A) = A u S for every subset A of U. For what sets S is I an onto function 
and for what sets S is y onto'? [s either f or y one-to-one? 
8. Fix a finite universal set U. The size function s: P( U) ~ N, where N is the set 
of all nonnegative integers, is given by s(A) = IAI for all subsets A of U. What 
is the range of s'? fs it one-to-one? 
9. The characteristic function of a set S, a fixed subset of the universe U, is given 
by Xs(x): U ~ N, where 
if x is not in S 
if x is in S. 
For a fixed subset S of U, let h: U ~ N be given by h(x) = I [xJ I, SI. Ex-
plain why XS and h are equal functions. 
10. Suppose that A and B are finite sets and A c:; B. Explain why A = B if and 
only if IAI = IBI· 
11. Suppose that f: D ~ D is a function with the same domain and target. Then 
we can define Il = I . f as the composition of I with itself. For each of the 
following, write down a simple expression for 12: 
(i) f:R ~ R, f(xj = x. 
(ii) J:R ~ R.f(x) = x 2 . 
(iii) I:N ~ N,f(i) = i + 1. 
(iv) I:N ~ N,f(j) = 2j + 1. 
~9 

1 SETS AND ALGORITHMS AN INTRODUCTION
(v) j-:lyu) -+ P(u), -f(~)= ~c.
(vi) j’:P(U) + P(U), f(A)= @.
12. If j’:D -+ D, then we can also define ~3 = ~ (f2)  = ~ ~~ (~ ~~ f) and fq =
.f “ (./’3) = j’ J [~ J (~ ~~ j’)]. Determine ,f3 and j_4 for each of the functions
in Exercise 11.
13. If~:D + D, we define j“, where n is a positive integer, by fl = f, f
2 = f J f,
and, in general, j’” = ~ ~~ (f”- 1 ). For each of the functions in Exercise 11 find
an expression for ~n in terms of n.
14. Let A = {al, a2,. . . . a.} and form the Cartesian product ~ x ~. Define two
projection functions, PI and P2: A x A + A by Pl(ui, aj) = ai and P2(~i, ~j) =
aj. Is either of these functions one-to-one or onto’?
15. Suppose that we define a function b:.4 ~ A x A by b(ai) = (ai, a ~). Then is
b the inverse of either of the projection functions P ~ or P2? 1s either P ~ or
P2 the inverse of b?
16. Show by example that Theorem 9.1 is false if D is not finite.
17. Suppose that j’ and g are functions such that f: D + 7’, g: T + D, a n d
j’ ~~ g = i. Prove that j’ is onto.
18. Suppose that ~: D + T is a one-to-one function and its domain D is tinite.
Then prove that there is a function g that is ~’s inverse.
19. For each of the following, find the inverse off. Let Z stand for the integers,
N the nonnegative integers, R the real numbers, and U = {al, a2, . . . . an}.
(i) /’:2 -+ Z,~(x.) = x + 1.
(ii) f:l? – {0} -+ R,./”(x)= ~.
(iii) f: N + R, f(x)= J~.
(iv) f: U + N, f(ai) = i.
(V) f:U + U, f(Ui)
 = U“-,.
20. Suppose that j’:D + T, where IDI > ITI. Can you conclude any of the follow-
ing? Explain.
(a) There are at least two elements t ~ and t2 of T that are each the image of
two or more domain elements.
(b) Every r in T is the image of at least two domain elements.
(c) There is an element t in T and three distinct elements dl, d2, and d3 in D
such that ,f(dl) = f(d2) = f(d3) = t.
21. Explain why a set of 16 numbers selected from {2,. . . . 50} must contain two
with a common  divisor greater than one.
22. Explain why a subset of 51 numbers taken from ~ 1,2,. ... 100} must contain
two numbers. where one is a divisor of the other.
50

1:10 
BOOLEAN FUNCTIONS AND BOOLEAN ALGEBRA 
23. Let f be a function with domain D and target T. If IDI = d and I TI = n, then 
explain why there is an element t of T that is the image of at least din elements 
of D. 
24. Here is a stronger version of Theorem 9.1. If f: D ---> T is a function, where 
IDI = I TI, then f is one-to-one if and only if f is onto. Prove that this is so 
and explain why this is more general than Theorem 9.1. 
25. Suppose that f and g are functions such that f: D ---> T and g: T ---> D, but 
one of them is not onto. Then is the conclusion of Theorem 9.2 still true; that 
is, is it still the case that f is the inverse of g if and only if 9 is the inverse of 
f? 
1: 10 BOOLEAN FUNCTIONS AND 
BOOLEAN ALGEBRA 
We return to the dichotomies mentioned in Section 2 and concentrate on functions 
with two-element targets: T = {O, l} or {True, False} or {yes, no}, and so on; With-
out loss of generality we assume that T = to, I}. Such functions are central to 
computer science and related mathematics. In this section we develop algebraic 
properties of these functions, characterize their fundamental forms, and consider 
an easily stated, but unresolved, research problem, known as the Satisfiability 
Problem. 
Definition. 
Let 22 = to, 1}. A function f:(2 2r ---> 2 2, with domain a Cartesian 
product of 22 and target 2 2, is called a Boolean function. 
Example 10.1. 
Here are three fundamental Boolean functions. 
\0 
I. NOT: 22 -> 22 defined by 
NOT(x) = 
~ 
11 
This is usually written NOT (x) = 
~. x. 
2. 
AND:(2z)2->2z definedby 
AND(x,y)=g 
This is usually written AND (x, y) =, x;\ y. 
3. 
OR: (2 2)2 -> 22 defined by 
OR(x,y) = {~ 
This is usually written OR(x,y) = xv y. 
if x = l 
if x = O. 
if x = y = l 
otherwise. 
if x = y = 0 
otherwise. 
These three functions represent: so-called "logical operations." If we associate 
"False" with ° 
and "True" with I, then NOT(x) is "True" (or I) if and only if x 
is "False" (or 0). Furthermore, AND (x, y) is "True" precisely when both x and y 
are "True," and 0 R (x, y) is "True" precisely when either x or y is "True" or hoth 
are "True." 
51 

1 SETS AND ALGORITHMS: AN INTRODUCTION 
Example 10.2. 
The functions of Example 10.1 can be combined to make more 
complex functions. For example, 
. 
{O 
!(x,y) = -(X;\Y)== 1 
and 
o(x V .:) = (x ;\ v) ;\.: =, {I 
.1 
'.' 
• 
0 
if x = y = 1 
otherwise, 
if x = y =:: = 1 
otherwise. 
How can we check that functions like those of Example 10.2 take on the values 
claimed? Or how can we determine the values of a new function? One foolproof 
method is to construct a table of all domain values and the resulting function 
values. 
Example 10.3. 
The values of f*(x, y) == (~x) v (~ y) are listed in Table 1.5. 
Table 1.5 
'( 
v 
~x 
~. y 
j*(x. y) = ( ~ x) v ( ~ y) 
() 
0 
0 
0 
1 
1 
0 
0 
1 
0 
0 
0 
Notice that the function f* agrees with the function f of Example 10.2 and so the 
two functions are equal. In other words, we have shown that 
~ (x ;\ y) == I ~ x) v ( ~ y). 
Question 10.1. 
Show that (a) 
~ Ix v Y) = (~x);\ (~y) and (b) (x;\ y);\::: = 
x ;\ (Y ;\ ::). 
The equalities of Example 10.3 and Question 10.1 (a) are known as de Morgan's 
laws. 
Example 10.4. 
Another useful function is known as "'exclusive or," abbreviated 
XOR. It is a function that is "True" if x or y is "True", but not hoth. In Boolean 
52 

1: 10 
BOOLEAN FUNCTIONS AND BOOLEAN ALGEBRA 
notation 
XOR(x,y) = {~ 
The function XO R is also written as XO R (x, y) = x EB y. 
if x = y 
otherwise. 
Question 10.2. 
By checking all domain elements, verify that XOR can also be 
expressed by 
XO R (x, y) = (x v y) (\ ~ (x (\ V), or equivalently 
= [x (\ ( ~ V)] v [( ~ x) (\ y J. 
Boolean functions model digital networks and electronic circuits well. In these 
models, the voltage is either high (1) or low (0), and switches are either ON (lor 
OFF(O). For example, consider the problem of adding two binary numbers, say 
o + 1. In a computer this is carried out by a circuit in which high voltage (I) 
together with low voltage (0) is combined to produce high voltage (I). Such circuit 
combinations can be imitated by Boolean functions as follows. Define 
ADD(x, I) -
. 
. , _ {O 
if x = Y = 0 or x = y = I 
. 
I 
otherWIse, 
and 
51 if x = \' = I 
MULT(x, v) = 
'. 
. 
lO 
otherWIse. 
Notice that MUL T is simply the AND function, x (\ y, and ADD is the XOR 
function, x EB y. Then for one-digit binary numbers x and y, M U L T (x, v) = .\ . Y 
and ADD (x, y) = x + y except that I + I = 10 in binary. A "carry" bit is needed 
to complete the latter addition. 
Example 10.5. 
Here are Boolean functions that produce the sum of':;' two-digit 
binary numbers. Let x I' XO, Y 1 and Yo be in Z'2 so that x I Xo and Y I Yo both represent 
two-digit binary numbers. Then their sum is :: 2: I Zo, where 
z() = ADD(xo,Yo) = Xo EB Yo· 
\(x 1 EB \"1) EB I 
if Xo = .\'0 = 1 
: l == 
0( (fx 1 EB rt! EB 0 
otherwise. 
53 

I SETS AND ALGORITHMS: AN INTRODUCTION 
(In other words, the two's digit in : 22 l'~O is the sum of x 1 and Y 1 plus 1 if the I 
is "carried over" from the addition of .'1:0 and Yo.) There is a carry if and only if 
:1:0 = Yo = 1, and so 
Finally, :2' the four's digit of the sum, is 0 unless there is a carry from the second 
addition. There will be a carry from the second addition if either Xl = Y 1 = 1 or 
if there is a carry from the first addition and either x 1 or Y 1 is 1. [n symbols 
There are a few more rules of arithmetic concerning Boolean functions that 
are summarized in the next result. Two other useful rules of arithmetic are de 
Morgan's laws (see after Question 10.1). 
Theorem 10.1. 
The functions AND and OR satisfy the following properties: 
1. XAy = yAX 
2. xvy=yvx 
3. (x A Y) A::: = x A (y A :) 
4. (x v y) v z = x v (y v z) 
5. x A (y V z) = (x A y) V (x A z) 
6. x v (y A z) = (x v y) A (x v :::) 
Commutative law 
Commutative law 
Associative law 
Associative law 
Distributive law 
Distributive law 
Notice that part 3 has been verified in Question 10.1. A consequence of parts 3 
and 4 is that we may write x A y A::: and x v Y v .: (i.e., without parentheses) without 
ambiguity. 
Question 10.3. 
Verify parts 1 and 4. 
Proo{o{part 5. 
The straightforward way to check this is to substitute all eight 
possible choices of Os and 1 s for x, y, and .:. For example, 0 A (0 V 1) = 0 A 1 = 
0= OvO = (OAO)V(OA 1). 
Here is another type of proof. Think of the (True, False} ...... [ 1, O} correspon-
dence. Then the statement x A (y v.:) is true if and only if x is true and either y 
or Z is true, that is, if and only if either x and yare true or x and.: are true, that 
is, if and only if (x A y) v (x A z) is true. 
[J 
Optional Material 
You might notice that every Boolean function considered in this section has been 
expressed in terms of NOT, AND, OR, and/or XOR (and XOR can be expressed 
54 

I: 10 
BOOLEAN FUNCTIONS AND BOOLEAN ALGEBRA 
in terms of the first three by Question 10.2). This is the case for all Boolean func-
tions; in addition, the form of the expressions can be specified. 
Definition. If x I' x: .. .. ,xn are variables, then for i = 1,2, ... ,n both Xi and ~ Xi 
are called literals. An expression of the form LI v L2 V' .. v Lj , where each Li is 
a literal for i = 1,2, ... , j is called a clause. A function f: (Z 2t --+ Z 2 is said to be 
in conjunctive normal form (or CNF) if it is of the form 
where Ci is a clause for i = 1,2, ... ,k. 
Example 10.2 (reexamined.) f(x, y) = ~(x /\ y) is not in CNF, but we know 
that fIx, y) = I*(x. y) = ( - x) v ( - y) by Question 10.1, which is in CNF with 
f*(x,y) = C I , where C I = LI V L 2 , LI = -.X: and L2 = - y. Then g(x,y) = 
(x /\ y) /\ Z is in CNF with C I = X, Cz == y, and C 3 = Z. 
Question 10.4. 
Which of the functions that determine 2 2 , zl' and Zo in Example 
10.5 are in CNF? 
Although the function f of Example 10.2 was not in CNF, we found that it 
was equal to a function, f*. that was in CNF. 
Theorem 10.2. 
Every Boolean function is equal to a function in CNF. 
Prool. 
Let f: (Z 2t --+ Z 2' Imagine writing out the table of all 2n elements of (Z 2t 
and the corresponding values off. Suppose that h = (hi' h2 , . .. ,h,,) in (Z:t is such 
that f(h) = O. Create a clause C of the form C = LI V Lz v ... v Ln, where 
if hi = 0 
if hi = 1. 
Notice that when, for i = 1.2, ... ,II, hi is substituted for Xi in the clause C, the 
value is O. Furthermore. h is the only element of (Z 2)n which when substituted 
yields 0; since C = L 1 V L2 V ... v Ln, C assumes the value of one when some Li 
is one and some Li is one unless all are zero, precisely the value at h. 
Next we form clauses C 1, C 2" .. ,Ck, one for each b in (Z 2)" for which fIb) = O. 
Then we let q be defined by 
We claim that f = u. Suppose that h in (Zzt is such that f(h) = O. Then there is 
a clause Ci in q corresponding to h; when h is substituted in Ci, a value of 0 results. 
55 

[ SETS AND ALGORITHMS: AN INTRODUCTION 
From the formula for y we see that g(b) = O. Suppose that b = (b b b2 ,· ..• bn) is 
such that feb) = 1. Consider what happens when, for i = 1,2, ... ,11; bi is substituted 
for Xi in any clause C. As we have already seen, a 1 results, since C corresponds 
to an element d i= b for which fed) = O. Since every clause in U equals 1 upon 
input of b, by definition of g, 9(b) = 1. 
0 
Example 10.6. 
We use the technique of the proof of Theorem 10.2 to find a func-
tion equal to f, but in CNF. where 
f(x, y,:) = ~ [(x i\ y) v (x i\ :)]. 
The elements of (Z2)3 on which I is 0 are precisely (1,1,0), (1,0,1) and (1,1,1). 
We form the clauses C 1 =(~x)v(-vy)v:, C 2 =(~x)vyv(~:), and C 3 = 
(~x)v(~y)v( ~:), and let?f = C 1 i\ C 2 i\ C 3 . 
Two types of Boolean functions merit special names. A Boolean function is 
called a tautology if its range is { 1 J; in other words, the function assumes the value 
"True" upon all input. A Boolean function is called a contradiction if its range is 
{O}; that is, it is always "False." For example, the function 
fix) = x v ( ~ x) 
is a tautology whereas 
is a contradiction. 
Question 10.5. 
Decide if the following are tautologies, contradictions, or neither. 
(a) (x v y) i\ [( ~ x) i\ yJ i\ [x i\ (~ y)] i\ [(- x) v (~y)]. 
(b) (x!\ y) v [( ~ x)!\ .1'] v [x i\ ( ~ .1')] v [( ~ x)!\ ( ~ .1')]. 
(e) (xvYV:)V(Ny). 
A Boolean function is not a contradiction if upon some input b the value of 
the function is 1. Then we say that f is satisfied by band f is satisfiable. Suppose 
that we are given a function, expressed as a huge combination of ANDs. ORs. 
and NOTs, like 
f(v, W,X,Y,:::) = (( ~x) i\ Y)'!:) i\ ( 
~x)!\ p)!\ (( ~ y) V p) i\ wi. 
It certainly could be a lot of work to check whether this is a tautology or a con-
tradiction, but suppose that all we want to know is whether there is some value 
h for which feb) = I. This is an instance of the following important problem. 
56 

1: 10 
BOOLEAN FUNCTIONS AND BOOLEAN ALGEBRA 
The Satisjiahility Prohlem. 
Given a Boolean function f, is there a h in the domain 
for which fib) = I? 
How might we proceed to solve the Satisfiability Problem? For a specific 
function f we could check all domain elements in f. If the domain of f is (Zzt, 
this checking might require all 2" binary strings before we find, say, that the last 
string satisfies f or that no string ~atisfies f. Using the ideas of Chapter 2, we 
shall make this process precise, as an algorithm, and we shall see that this parti-
cular process is a very slow and time-consuming one. But surely there must be 
some "tricks of the trade," some techniques with which to attack this problem 
without trying all possibilities. In fact, it is an open research problem whether 
there is a "fast" and "efficient" process by which to determine whether an arbitrary 
Boolean function is satisfiable; these terms will be defined precisely in Chapter 2. 
For the time being we repeat that this simply stated problem is at the heart of 
some very hard, unresolved research questions that are actively being studied by 
the research community. 
EXERCISES FOR SECTION 10 
1. Which of the following tables represent a Boolean function? 
Function 
Function 
Function 
Domain 
Value 
Domain 
Value 
Domain 
Value 
10,0) 
I 
10,1) 
° 
(0,0) 
il 
10, I) 
I 
10,2) 
I 
(0, I) 
I) 
(1,0) 
11,0) 
0 
11.O)E 
12,0) 
I 
(1, I) 
(j 
2. Give an example ofa Boolean function from(Z2)3 onto Z2' How many Boolean 
functions from (Z2)" to Z2 are onto? How many are one-to-one? 
3. Write out a table of values for the following functions. Then identify all pairs 
of functions that are equal. 
(a) fl(X,y)=(~x)vy. 
(c) j3(x,y)=yi\Xi\(~y). 
(e) j~(x, y) = X i\ (~y). 
(g) /7(X, y) = y v x. 
(b) 
j~(x,y) = (~x)v y)AX. 
(d) j~(x,y) = ~(x v (~x). 
(f) f~(x,y) = ~(x A (~y». 
(h) 18(x, y) = x A y. 
4. Show that the function A NO (x, y) = x i\ Y is equal to a function using only 0 Rs 
and NOTs. Show that the function 0 R (x, y) = x v y is equal to a function 
using only ANDs and NOTs. [s the function fix. y) = 
~(x i\ y) equal to a 
function that uses only ANDs and ORs, but no NOTs? 
57 

1 SETS AND ALGORITHMS: AN INTRODUCTION 
5. If x[xO and YtYo are two-digit binary numbers, find the functions that give 
their product in binary. 
6. Verify parts 2 and 6 of Theorem 10.1. 
7. For each of the following, find an equal function expressed in CNF. 
(a) fl(x,y,.::) = (~X)V(YA:). 
(b) f2(X,y,Z) = xV«~Y)A'::). 
(c) J3(X, y,:) = ~ (x v Y v z). 
(d) 14(X, Y,:) = ~ (x A Y A:). 
(e) f5(.'(' y, z) = (x A y) V (x A z). 
(f) 16(X, y, z, W) = (x A y) v (z A w). 
8. A function is said to be in disjunctive normal form (or DNF) if it is in the form 
where, for i = 1,2, ... ,k, Di is of the form L[ A L2 A ... A Lj with each Li a 
literal for i = 1,2, ... , j. Find all functions in Exercises 3 and 7 that are in DNF. 
9. Find an example of a function that is in neither CNF nor DNF. 
10. For each of the following, find an equal function expressed in DNF. 
(a) fl(X,y,z)=(~X)A(YVZ). 
(b) 1~(x,y,Z)=XA[(~Y)V:]. 
(c) f 3(x,y,:) = ~(XAYAZ). 
(d) f4(X,y,.:) = ,,-,(xvyvz). 
(e) f 5(x, y, z) = (x v y) A (x v:;). 
(f) 16(X, y, z, w) = (x v y) A (z V w). 
11. Is each of the following satisfiable'? 
(a) I(x,y,z) = yv ~[,:v(",x)]. 
(b) f(x,y,z,w) = [xv ~(yv ~z)]v ~{xv ",[yv "'(ZAW)]}. 
(c) f(x, y) = (x A y) V « '" x) A y). 
(d) f(x,y) = xv ",{xv ~[yv(~x)]}. 
(e) I(x,y) = (XAY)A(XA(~Y)). 
12. For n = 2, 3, and 4 find Boolean functions /:(Z2)" -+ Z2 that are tautologies. 
13. For n = 2, 3, and 4 find Boolean functions f:(Z2)" -+ Z2 that are contra-
dictions. 
14. Identify which of the following are tautologies. 
(a) g(x,y) = yv ~([yv(~x)] A(YV x)} 
58 
(b) g(x,y) = [( ~x)v y] v (y v x). 
(c) g(x,y) = xv ~{YV[(~X)AY]}. 
(d) y(x,y) = x v [~(x v yJ]. 
(e) Y(X,YI = (~X)V:yA [(~y)vl~x)]). 
(f) ~f(X, y) = [x A (~y)] v [y v (~x)]. 
(g) y(x,y,,:) = [':V(~v)]v ~[Z\I ~(XAY)]. 
(h) g(x,y,z) = :v(~x)v [(~Z)A(XAY)J. 

1:11 
A LOOK BACK 
15. A mathematical statement of the form "If A, then B" is said to be true if when-
ever A is true, then so is B. When A is false, then it doesn't matter whether B 
is true or false. Thus "If A, then B" is logically equivalent to the statement that 
either A is false or B is true. We define a new function 
IMPLIES (x,y):(Z2)2 --> Z2 defined by IMPLIES (x,y) = (~x)v y. 
Determine the value of (Z 2)2 on which IMPLIES is 1. Interpreting 1 as "True," 
explain why this is analogous to "If A, then B." 
16. A mathematical statement of the form" A if and only if B" is true if whenever 
A is true then so is B and whenever A is false then so is B. Find a Boolean func-
tion EQUIVALENT (x, y) that is the appropriate analogue of" A if and only 
if B." 
1:11 A LOOK BACK 
We began this chapter with a particular problem (admittedly one of only small 
import) and introduced some substantial mathematics in order to understand the 
problem and its solutions. There are a number of ideas that you should be com-
fortable with before you proceed to the next chapter. Foremost among the impor-
tant concepts discussed is the notion of algorithm. This course will be oriented 
toward the solution of problems. Typically, a problem will be to find a mathe-
matical object with a particular property. Often the problem is fairly easy in small 
instances. However, larger cases may be quite difficult. Such problems frequently 
have algorithmic solutions and it will be on these that we concentrate. The algo-
rithmic solutions provide us with systematic ways to solve problems, so systematic 
that we could easily turn the algorithm over to a computer, or more realistically 
to a computer programmer. Although computers can handle many large numbers 
quickly, there are limits to computer size and speed. One of the principal themes 
of the rest of this course will be the analysis of the correctness and efficiency of 
algorithms and the search for such effective algorithms. 
This chapter also contains an introduction to set theory, an important tool 
because our mathematical objects will usually be described in the language of ,ets. 
We need to distinguish between contexts where the order of objects is not im-
portant, as with subsets, versus those where order is important, as in Cartesian 
products. We have also begun to develop counting techniques, the multiplication 
principle and P.LE. This material is significant because of its applications to the 
analysis of algorithms. In particular, these mathematical techniques will be neces-
sary tools in the evaluation of the quality of particular algorithms. 
Functions are also important mathematical tools because they describe trans-
formations and relations between sets. Often it will be important to know whether 
59 

I 
SETS AND ALGORITHMS: AN INTRODUCTION 
a particular function is one-to-one or onto or whether it has an inverse. For exam-
ple, in Chapter 3 we shall study the one-to-one functions called permutations in 
depth. We have noted that algorithms and functions are similar. They take input 
and domain elements, respectively, and transform these in a well-defined and 
unique manner into output and range elements. We shall use algorithms to study 
functions, and vice versa. In the next chapters two central problems will be to find 
algorithms that compute functions efficiently and to find and study functions that 
measure the efficiency of algorithms. The special case of Boolean functions is suffi-
ciently important and applicable to warrant extra study. These functions model 
well how computers work. They may be thought of as mapping from complicated 
sets to the values of "True" and "False." and so they also model how logical think-
ing and proofs work. The Satisfiability Problem is introduced not only because it 
is an unsolved research problem, but also because it is computationally equivalent 
to other famous problems. some of which will arise in Chapters 5 and 8. 
We have begun to see proofs. Understanding these proofs is crucial to the 
development of this course. We have left some important facts unproved in this 
chapter, for example, that the algorithms BtoD, DtoB. and SUBSET work cor-
rectly in all cases. One of the main goals of this book is to develop proof technique~ 
and skill in their application to mathematical and algorithmic problems. 
The concept of algorithm is pervasive throughout computer science and is 
increasingly important in abstract mathematics. A beginning computer science 
student is tempted to attack problems by writing computer code directly, trying 
out the resulting program on reasonable examples of data and correcting obvious 
problems as they arise. Instead, especially with complicated problems and pro-
grams, it will become essential to plan ahead carefully, to outline the entire attack 
on the problem. An algorithm is just such a precise outline of the approach to be 
made on the problem. In mathematical work students are always searching fer 
concrete guidelines for ways to solve specified problems. In the past mathemati-
cians would often prove that a problem could be solved, but then fail to addre~s 
explicitly how to solve the problem. Now many mathematicians are revising the~r 
philosophical ideas about mathematics and are turning to algorithmic approaches 
to problems. Indeed, some would say that a problem hasn't been solved even in 
theory unless an algorithmic solution has been found. Thus although the problems 
that we consider in this book are beginning ones in the study of discrete mathe-
matics and algorithms, the philosophy is central to current approaches and research 
in these areas. 
SUPPLEMENTARY EXERCISES FOR CHAPTER 1 
l. Suppose that a computer program contains two Boolean variables, Done and 
Correct. That is. each of these variables can assume the value either True ,)r 
False. How many different pairs of values can the two variables (Done, Correct) 
60 

SUPPLEMENTARY EXERCISES FOR CHAPTER I 
assume? Suppose that JEQUALSONE is another Boolean variable. How 
many different values can the triple (Done, Correct. JEQUALSONE) assume? 
Suppose that we had n Boolean variables called Xl' X 2' X 3" .. ,X". Deter-
mine a formula for the number of different values the n-tuple (X t, X 2" .. , X n) 
can assume. 
2. Problem. 
Given a positive integer n, calculate and print the sum of the 
integers from 1 to n. Is the following an algorithm that correctly solves this 
problem? 
Response 
STEP l. Read in n, a positive integer 
STEP 2. Calculate n(n + 1 )/2 and print this out 
STEP 3. Stop. 
3. Describe an algorithm to change a number written in base four to an equiva-
lent number expressed in decimal. 
4. Describe an algorithm to change a number from decimal to base four. 
5. Describe an algorithm to convert between binary and base four that does not 
use decimal representations. 
6. A numerical representation system often used in calculators is known as BCD 
or binary coded decimal. In this system each digit in a decimal number is 
converted to binary and stored in four consecutive bits, lined up in the same 
order as the original decimal digits. Thus the number 139 is stored as 
000100111001. Convert the following numbers into BCD: (a) 12, (b) 19, (c) 25, 
(d) 28. and (e) 77. 
7. How many bits does an r-digit decimal number require to be stored in BCD? 
Given 16 bits with the first bit reserved for sign designation, what is the largest 
decimal number that can be stored in BCD in the remaining 15 bits? 
8. Write an algorithm to convert a decimal integer into BCD. and vice versa. 
9. Write an algorithm that inputs A =: at, a2 , . .. ,an] and outputs all elements 
of the Cartesian product A x 4. 
10. Suppose that A = [a l , ... • an] and T = :f l ,t2,.·. ,tmJ. How many functions 
are there with domain A and target F! How many of these functions are (lne-
to-one? (Hint: Consider separately the cases when n < 111, 11 = 111, and n > m.) 
1 L How many numbers must you pick from the set : L 2, .... III so that there 
must be two with a common divisor greater than one? 
12. Explain why a subset of(n + I) numbers taken from: 1,2, ... ,211) must con-
tain two numbers where one divides the other. Is the same true if 1he subset 
contains only IJ numbers? 
61 

SUPPLEMENTARY EXERCISES FOR CHAPTER 1 
13. A hiker is lost in the mountains but stumbles into an area where it is known 
that all inhabitants are either True-tellers or Liars, meaning that an individual 
either always tells the truth or always lies. She meets a man at a fork in the 
road and wants to learn the way to the nearest village by asking only one 
question. Explain why she will not learn the way to the village by asking any 
of the following questions: 
(a) Are you a truth-teller'? 
(b) Are you a truth-teller and does the left fork lead to the village? 
(e) 
Are you a truth-teller or does the left fork lead to the village? 
(d) If you are a truth-teller, does the left fork lead to the village? 
(e) Are you a truth-teller if and only if you are a liar? 
(J) If the left fork leads to the village, are you a liar? 
14. Devise one question with which the hiker. in the predicament of the pre-
ceding exercise, can determine the way to the village. 
15. Deborah receives $1 million from an anonymous friend. She suspects that 
either Alice, Bob, or Catherine gave it to her. When she asks each of them, 
they respond as follows: 
(a) Alice says. "I didn't do it. Bob is an acquaintance of yours. and Catherine 
is an especially good friend of yours." 
(b) Bob says, "I didn't do it. I've never met you before, and I've been out of 
town for the past month." 
(e) Catherine says, "r didn't do it. I saw Alice and Bob in the bank on the 
day you received the check so it must be one of them." 
Assuming that the two who didn't give Deborah the money are telling the 
truth and that the donor is lying, who gave Deborah the money? 
16. There is a very simple programming language known as TRIVIAL. In this 
language only the following six types of instructions are allowed: 
(a) Input X, a natural number 
(b) Go to step # --
(e) Set X : = X + ! 
(d) If X = 0, then go to step # ---
(e) If X > 0, then set X : = X -
I 
(f) Stop. 
Suppose that a program must begin with the instruction Input X and end 
with the instruction Stop. How many different programs are there. written 
in the language TRIVIAL if the program is two steps long? Three steps long? 
12 steps long? 11 steps long? 
17. Suppose that a TRIVIAL program can begin with one or more statements 
Input X. where X may be any letter of the alphabet; for exampk we may 
begin with Input A and then follow with Input B. Then we allow state-
ments of the form A : = A + 1. and if B > 0, then set B : = B-1, and so on. 
62 

SUPPLEMENTARY EXERCISES FOR CHAPTER 1 
provided that A and B are input variables. If a TRIVIAL program begins 
by reading in two variables A and B, then how many different TRIVIAL pro-
grams are there using three steps? Four steps? n steps? 
18. Write a program in the language TRIVIAL that upon input of X and y, posi-
tive integers, calculates the sum X + Y and leaves the result stored in X. 
Note that X: = X + Y is not a valid statement in TRIVIAL. 
19. Suppose that we allow two output statements: "X is even" and "X is odd." 
Write a program in TRIVIAL that upon the input of X, a positive integer, 
determines whether X is even or odd, outputs the correct message, and stops. 
20. Open Mathematical Problem: The Busy Beaver N-game. In this version we 
eliminate the Input X statement and assume instead that every variable begins 
with the value O. Then we can do the equivalent of reading in a positive 
integer i for X by writing i consecutive" X : = X + I" statements. The score 
of a TRIVIAL program is defined to be the sum of the values of all vari-
ables when the program stops or 0 if the program never stops. Then the Busy 
Beaver n-game is the problem of determining a TRIVIAL program with n 
instructions with the highest possible score among all TRIVIAL programs 
with 11 instructions. We call that maximum score BB(n). Thus B8(1) "" 0, 
since the only TRIVIAL program with one line is 
STEP 1. Stop. 
A two-step program could be 
STEPl. SetX:=X+! 
STEP 2. Stop. 
Thus BB(2) = I, since X begins at 0 and is increased only to 1. Explain 
why BB(n) ;:::: (n -
1). Then show that BB(3) = 2 and BB(4) = 3. Find a value 
of 11 such that BB(n) > (n -
l)~ you will need to use at least two variables. 
Very little is known about the Busy Beaver n-gamc for even small values of 
n. It is known that there is no simple function that expresses BB(n) as a func-
tion of n. It has been shown that BB(20) ;:::: 4(4(4
4
»), but the actual value of 
BB(20) is unknown. 
63 

2 
ARITHMETIC 
2:1 INTRODUCTION 
In Chapters 2 and 4 we take a new look at arithmetic. Some of the probiems 
we shall consider will be more advanced than that which the word arithmetic 
usually conjures up. However, our principal goal will be algorithmic thinking. We 
shall be especially concerned with the quality of the methods discussed and the 
mathematics that is necessary to understand what makes one method hetter than 
another. We concentrate on the question of exponentiation, that is, of calculating 
xn. Although this problem is more important than the magic trick that formed 
the theme of the previous chapter, it is the methods rather than the solutions to 
any particular problem that are worth learning. We introduce the important proof 
techniques of induction and contradiction to analyze the correctness and efficiency 
of algorithms. 
Here is an appetizer. Suppose that we have two variables, say x and y, that 
have been assigned the values 5 and 2, respectively. It is a common task to switch 
the values of the variables, that lS, to arrange it so that x = 2 and v = 5. We 
want a procedure that will work no matter what the values assigned to x and J' 
are. 
Example 1.1. 
Using the ": =" notation, we can suggest a way to trade the values 
of the variables assigned to x and y. 
STEP I. x: = y 
STEP 2. y: = x 
STEP 3. Stop. 

2 ARITHMETIC 
At first glance this seems reasonable, since step 1 assigns to x whatever is as-
signed to y and step 2 assigns to y whatever is assigned to x. [f we trace what 
happens to the values assigned to the variables x and y, we get Table 2.1. 
Table 2.1 
Before step 1 
After step 1 
After step 2 
Value Assigned to x 
5 
2 
2 
Value Assigned to y 
2 
2 
2 
What happened to the 5? After step 1 it has been forgotten. We wanted to assign 
the old value of x to the variable y; however, the old value of x has been written 
over. 
Question 1.1. 
Here is a sequence of instructions that will perform the desired 
switch of values. 
STEP 1. xold:= x 
STEP 2. yold:= y 
STEP 3. y:= xold 
STEP 4. x:= yold 
STEP 5. Stop. 
As in the preceding example trace what happens when x is initially assigned the 
value 5 and y is initially assigned the value 2. 
It turns out that only four of the five steps just listed are necessary. Exercise 
asks you to figure out which step can be safely omitted. Thus there is a four-
step algorithm that will switch values between two variables; this algorithm re-
quires the use of a supplementary storage location. 
Example 1.2. 
Here is an algorithm that will switch the values of x and y without 
the use of an extra storage location. Note that there are more steps and that we 
are required to do some arithmetic. 
STEP 1. x:= x + y 
STEP 2. v:= y-x 
STEP 3. x:= x + y 
STEP 4. y:= -
y 
STEP 5. Stop. 
66 

2: 1 INTRODUCTION 
As in our previous example we trace what is assigned to each of the variables 
(Table 2.2). 
Table 2.2 
Value ofx 
Value ofy 
Before step 1. 
5 
2 
After step 1. 
7 
2 
After step 2. 
7 
-5 
After step 3. 
2 
-5 
After step 4. 
2 
5 
We have just seen two algorithmic solutions to the problem of switching the 
values assigned to two variables. The first requires four steps and a supplementary 
memory location. The second requires five steps and no extra storage. Further-
more, the steps are arithmetic operations rather than just assignment statements. 
This is typical. Frequently, a problem will have various algorithmic solutlons. 
and one will be faster while a second might require less space. In general, we shall 
favor algorithms that have fewer steps over those that require less storage. In 
Sections 2 and 5 we shall consider exponentiation algorithms that are similarly 
related. 
EXERCISES FOR SECTION 1 
1. Which of the following four-step algorithms succeed in trading the values of 
x and y? For each, trace what happens. 
(a) 
STEP 1. 
yold:= y 
(b) 
STEP 1. 
:'Wld:= x 
(c) 
STEP l. xold:=x 
STEP 2. 
y:= x 
STEP 2. y:= xold 
STEP 2. 
yold:= y 
STEP 3. x:= yold 
STEP 3. x:= y 
STEP 3. 
y:= :wld 
STEP 4. 
Stop. 
STEP 4. 
Stop. 
STEP 4. 
Stop. 
2. Suppose that x 2: y 2: O. Find an algorithm that interchanges the value~ of x 
and y and has the properties that no supplementary storage is required and 
at no stage is a negative number stored in either location. 
3. Find a four-step algorithm that interchanges the values of x and \' and does 
not require a supplementary storage location. 
4. Suppose that the three variables x, y, and::: are each assigned values. Find an 
algorithm that will cyclically ~witch the assigned values so that the old value 
of x will be assigned to y, the old value of y will be assigned to :, and the old 
67 

2 ARITHMETIC 
value of:: will be assigned to x. Can this be accomplished with no arithmetic 
and just one extra storage location? 
5. Suppose that you are given 11 variables labeled X 1'X 2 ' ... 'X n each of which 
has been assigned a value. Construct an algorithm that will take the value as-
signed to Xn and store it in Xl' take the old value of Xl and store it in x2' take 
the old value of X 2 and store it in X 3 , . .. , and take the old value of xn- 1 and 
store it in xn-
6. Here is an algorithm whose goal is. upon input of numbers X and y, to calculate 
their sum and store it in x, and calculate their difference and store it in y. Is 
this algorithm correct? 
STEP l. Input X and y 
STEP 2. x: = X + y 
STEP 3. y: = X - Y 
STEP 4. Stop. 
If it is incorrect, rewrite the algorithm correctly. 
7. Design a four-step algorithm that upon input of numbers X and y calculates 
xy and xiy and stores these in the variables x and y, respectively. If possible, 
use no supplementary storage location. 
2:2 EXPONENTIATION, A FIRST LOOK 
We begin with the problem of computing the 11th power of x, given a real number 
x and a natural number 11. How do computers calculate powers of numbers? The 
basic arithmetic operations of computers are addition, subtraction. multiplication. 
and division. Using these operations, we want to develop correct and efficient 
ways to calculate xn. There is a straightforward solution to this problem, namely, 
multiply x by itself (n -
I) times. If n were fixed, then there would be no difficulty 
in writing down a correct algorithm to solve this problem. For example, if IJ were 
always 5 we could calculate 
answer : = x . x . x . x . x. 
The situation when n is allowed to vary is slightly more complicated. Now we list 
an algorithm that finds xn 
Algorithm EXPONENT 
611 
STEP I. 
Input x, IJ : 11 a natural number I 
STEP 2. i: = 0, ans : = 1 

STEP 3. 
While i < it do 
Begin 
STEP 4. ans: = ans * x 
STEP 5. i: = i + 1 
End {step 3) 
STEP 6. Output ans and stop. 
2:2 
EXPONENTIATION, A FIRST LOOK 
COMMENTS. 
In Section 1.4 we used "Go to" statements to create loops within 
algorithms. Here we use the more modern "While ... do" construction, wherein 
the steps within the loop are executed in order as long as the while condition 
is satisfied. Note that the loop is indented for ease of reading. When a loop has 
more than one step, we will signal the beginning of the loop by "Begin" and the 
end of the loop by ·'End." The statements within the loop will not be executed if 
it = O. However, the output of the algorithm will still be correct since xl) = 1 for 
all x. 
This algorithm is sufficiently complicated that you might wonder whether it 
does what it claims (in all cases). 
A Fundamental Problem. 
How can you be sure that the algorithm listed above 
(or, more generally, any algorithmic solution to a problem) is correct'? 
A first response to this problem is to implement the algorithm. If the algorithm 
is written in a programming language, then the algorithm could be tested by run-
ning the program. If, as above, the algorithm is written in a pseudo-code (i.e .. in 
English with a structure similar to a programming language), then the algorithm 
can be tested by a person tracing the algorithm's commands. In this setting ~he 
person acts as a computer. We shall do this for the algorithm listed above, but 
before we do, it is appropriate to consider what will be learned from such a tt:st. 
Presumably, we shall run the algorithm on input for which we already know 
the answer. If the algorithm's answer is wrong, then we can discard the algorithm. 
In one sense this is satisfactory, since we know without a doubt that the algorithm 
is incorrect. If the algorithm's answer agrees with the already known answer. what 
does that prove'? It does show that the algorithm performs correctly on at least 
one set of input data. If we run the algorithm for a variety of inputs and each run 
gives a correct answer, then we can increase our confidence in the algorithm. Unless 
the :llgorithm only runs on a tinite set of inputs, such a strategy cannot demon-
strate that the algorithm will always work. 
Example 2.1. 
If x = 5 and II = 3, then x" = 53 = 125. In Table 2.3 we trace 
EXPONENT with this input. 
69 

2 ARITHMETIC 
Table 2.3 
Current Step Completed 
2 
3 
4 
5 
4 
5 
4 
5 
6 STOP 
? 
o 
o 
Answer 
o 
5 
5 
25 
2 
2S 
2 
125 
3 
125 
3 
125 
Question 2.1. 
Trace the executive of EXPONENT for x = 3 and n = 4. 
After completing the above question, you probably believe that EXPONENT 
correctly produces the value of xn when n is a positive integer. Your belief is based 
upon the fact that you have witnessed one experiment and performed one ad-
ditional experiment. This is similar to what you might do in a chemistry class. In 
the next section we discuss the principle of mathematical induction that will en-
able us to prove that the algorithm EXPONENT works for all input. 
EXERCISES FOR SECTION 2 
1. Trace Algorithm EXPONENT for 
(a) x = 17 and n = 1. 
(b) x = 2 and n = 5. 
(c) x = - 2 and /l = 3. 
(d) x = 5 and n = 0. 
2. Construct an algorithm that will input a real number x and an integer n, which 
may be positive, negative, or zero, and output "n. Trace your algorithm for 
(a) x = 3 and n = 3. 
(b) x = 3 and n = - 3. 
(c) x = ° and n = - 5. 
(d) x = - 1 and n = O. 
3. If Algorithm EXPONENT is run with x = 5 and n = 7, how many multipli-
cations are performed? If 11 = 132, how many multiplications are done? 
4. Suppose that we have a computer that can perform addition but not multi-
plication. Devise an algorithm that, upon input of a real number x and an inte-
ger n ~ 0, calculates and outputs the product nx. How many additions does 
your algorithm use? 
5. Construct an algorithm NEWEXP to compute x" for n, a positive integer. The 
first step. after x and I! are input. should be to compute and store:: = x 2 . At 
subsequent steps the variable ans (which will contain the answer) is multiplied 
by :: unless that would make ans too large. in which case ans is multiplied by x. 
70 

Trace NEWEXP for 
(a) x = 3 and II = 7. 
(c) x = 3 and n = 10. 
(b) x = 3 and II = 16. 
2:3 INDUCTION 
6. Determine how many multiplications NEWEXP requires to find (a) x\ (b) x 12 , 
(c) x13, and finally (d) xn, where n = 2t for t, any positive integer. 
7. Construct an algorithm NEWEREXP whose first two steps, after x and n are 
input, is to compute and store: = x 2 and w = :2. At subsequent steps the vari-
able ans (which will contain the answer) is multiplied by w unless that would 
make ans too large, in which case ans is multiplied by x until ans is xn. Trace 
NEWEREXP for 
(a) x = 3 and n = 12. 
(c) x = 3 and II = 19. 
(b) x = 3 and 11 = 16. 
8. Determine how many mUltiplications NEWEREXP requires to find (a) X10, 
(b) x 16, (c) X 25 , and finally (d) xn, where n = 4t for t, any positive integer. 
9. Write an algorithm that calculates I1X (as requested in Exercise 4) using fewer 
than 11 -
I additions. 
2:3 INDUCTION 
Mathematics has distinguished itself from other human endeavors because the 
truths of mathematics are known with greater certainty than the truths of other 
subjects. This is because assertions in mathematics must be proved before they 
are regarded as valid. Although this does not eliminate the possibility of error 
(mathematicians are, after all, human beings who can and do make mistakes), the 
necessity of providing proofs greatly diminishes the potential for error. 
Example 3.1. 
The most famous open problem in all of mathematics concerns the 
positive integers and is very simply stated. It goes as follows: Do there exist posi-
tive integers x, y, :, and n with n > 2 such that 
The restriction that n > 2 is there because, for instance, 
and 
provide easy affirmative answers to the question. The assertion that for 11 bigger 
than 2, there do not exist integers with the required relationship is known as 
71 

2 
ARITHMETIC 
"Fermat's Last Theorem." The name is misleading, since the assertion is still un-
proved; however, Fermat scribbled in the margin of a book that he had found a 
proof but had no room to write it down. This note was found after his death! It 
has been proved that no such integers exist if II ==, 3, that is, there do not exist 
integers x, y, and;:; with x 3 + y3 = .:3. Indeed, Fermat's Last Theorem has been 
proved to be true for all exponents of reasonable size, in fact for 11 ::; 125,080. The 
philosophical question 
"Is Fermat's Last Theorem true'!" 
suggests itself. Certainly, mathematicians would be surprised ifit turned out to be 
false. However, no mathematician would consider the assertion of Fermat's Last 
Theorem to be a mathematical truth until a valid proof is found, no matter how 
much numerical evidence is marshaled in support of it. 
The complex programs and structures of computer science have certain fea-
tures analogous to the state of our knowledge concerning Fermat's Last Theorem. 
It is a common occurrence for programs (or algorithms) to work correctly on 
some inputs without working correctly on all inputs. Even if a program always 
has worked correctly, that is no guarantee that it always will work correctly. Be-
cause of this, computer scientists frequently require proofs that their assertions 
and programs are correct. How does one construct a proof that an algorithm (or 
a program) is correct? The most common technique is mathematical induction. 
Principle of Mathematical Induction. 
Suppose that we wish to prove that a cer-
tain assertion or propOSItIOn is true. Further suppose that the statement of the 
proposition explicitly depends on a positive integer, say 11. We denote the proposi-
tion emphasizing the dependence on the integer n by Pw Our goal will be to prove 
that P n is true for all values of n. 
Frequently, it will be easy to prove that the proposition Pn is true for certain 
(usually small) values of 11. The first step in applying an induction proof is to verify 
the proposition directly for one value of n. This is called checking the base case. 
This one value will usually be n = 1 or 11 = O. The next step in applying an induc-
tion proof is analogous to climbing a ladder. We must demonstrate that whenever 
the proposition P k is true, then so is the proposition P k + l' 
Here is a formal statement of the Principle of Mathematical Induction: 
Let P n be a proposition that depends upon the integer 11. Then Pn is true for 
all positive n provided that 
(i) PI is true, 
and 
(ii) if Pk is true, then so is PH I' 
72 

2:3 INDUCTION 
Soon you will see examples of proofs using induction. Before looking at these. 
let's see why the principle is valid. Note that when we say the principle is valid, 
we mean that if assertions (i) and (ii) are both verified, then the proposition P" is 
proved true for all n. 
To begin with, P l is true by (i). Since P l is true, setting k = 1 in (ii) shows 
that P 2 is true. Then we can repeat (ii) with k = 2. Since we've just demonstrated 
that P 2 is true, we get the result that P 3 is true, and so on. Is P 17 true? We won't 
do all the details, but we could work our way up to 17 using (ii) repeatedly, 
building upon the known results Pj for smaller values ofj. In general, we can work 
our way up to the truth of P" for any integer n. 
The way that we go about establishing an assertion by induction is quite 
algorithmic. In fact, here are the key steps. 
Alqorithm INDUCTION 
STEP l. (The base case). Verify that PI is true. 
STEP 2. (The inductive hypothesis). Assume that Pk is true for an arbitrary 
value of k. 
STEP 3. (The inductive step). Verify that Pk + l is true, using the assumption 
that Pk is true. 
We illustrate proofs by induction with three typical examples. 
Example 3.2. 
The following is an important identity that will reappear several 
times in this book. 
n(n + 1) 
1+2+3+"'+11= 
J 
. 
(A) 
Suppose that we wish to prove this using induction. The statement already has 
an explicit dependence on the posItive integer n: P" is the statement that equation 
(A) is true. 
First we check the base case when n = l. For n = 1 the left-hand side of equa-
tion (A) is I, while the right-hand side equals 1(1 + 1 )/2 = l. (Although we've done 
the base case, we'll get a better feel for the problem if we check at least one more 
case. If the equation were not true, it could be a real time-sink to try to prove it!) 
For n = 2 the left-hand side of (A) equals I + 2 = 3, while the right-hand side 
equals 2(2 + 1)/2 = 3. For II = 3 we check that the two sides of (A) both equal 6. 
Now we come to the inductive hypothesis (step 2). We assume that 
k(k + 1) 
1 + 2 + ... + k = --:;---. 
(8) 
73 

2 
ARITHMETIC 
We want to prove that 
(k + 1)(k + 2) 
1+2+···+k+(k+l)=· 
") 
. 
(Bt) 
Note that equation (Bt) agrees with (A) after substituting k + 1 for n. How can 
we proceed? We want the sum of k + 1 integers and what we have to build upon 
is the sum of k integers. So we use associativity to obtain 
(1 + 2 + ... + 1<) + (I< + n 
k(1< + 1) 
k 
1 
= 
2 
+( + I 
by inductive hypothesis 
= (k + l)G + I) 
by factoring 
(k + 1)(1< + 2) 
2 
by algebra. 
o 
Question 3.1. 
Prove by induction that 2 + 4 + ... + 2n = n(n + 1). (Hint: Mimic 
the preceding example.) 
Example 3.3. 
The following formula gives the sum of a (finite) geometric series: 
if x =1= 1 
if x = 1. 
It is a polynomial identity that holds true for every real number x and for every 
integer n ::::: O. This can be proved by induction on n. Instead we prove the slightly 
more complex formula for the sum of an alternating geometric series in the next 
example. You will be asked to imitate the latter proof in Question 3.3 to verify 
Example 3.3. 
Example 3.4. 
Here we use induction to verify that for every integer n > 0 the 
following polynomial identity is valid. 
if x =1= - 1 
if x = -1. 
(e) 
By a polynomial identity we mean an equation that is valid for every substitution 
of a real number for the variable x. 
74 

2:3 INDUCTION 
If X = -1, the left-hand side of (C) consists of n + I terms, each of which is 
1. Thus the sum is n + 1. If x f= -
1, then the identity has an explicit dependence 
on the positive integer n: Pn is the statement that equation (C) is true for all posi-
tive integers n when x is any real number other than - 1. First we check the base 
case when n = 1. For II = 1, the left-hand side of (C) equals 1 - x. With n = L 
the right-hand side of (C) is 
1-(-xl2 
l-x 2 
---- = ---- = 1 - x. 
1 + x 
1 + x 
Question 3.2. 
Check that (C) holds for both n = 2 and n = 3. 
Now we come to the inductive hypothesis (step 2). We assume that 
We want to prove that 
k 
l_Xk+l 
l-x+"'+(-x) =---
l+x 
1 - (_X)k + 2 
1 -
x + ... + ( _ x)k+ 1 = - ___ _ 
l+x 
(0) 
(0') 
Note that equation (0') agrees with (C) by substituting k + 1 for 11. We use 
associativity to obtain 
1 - x + ... + (-xl k + (_x)k+ 1 
1 - ( - x)k+ 1 
k + 1 
= 
1 
+(-x) 
+x 
L - ( - x)k + 1 + ( _ X)k + 1 + x( _ X )k + 1 
I+x 
1 + x( -:d+ 1 
1 + x 
1 - (-xl( _x)k+ 1 
l+x 
L _ (_x)k+ 2 
l+x 
by inductive hypothesi~ 
by making common 
denominators 
by algebra 
by algebra 
by algebra. 
Question 3.3. 
Prove by induction on n that the sum of a geometric series is as 
given in Example 3.3. 
75 

2 ARITHMETIC 
Example 3.3 (another look). 
Here is another way to verify this identity. We have 
established that the identity of line (C) is valid for all x. Thus we may substitute 
the expression - x in every instance of the variable x and the identity remains 
valid. Upon substitution we get 
1- (-xl + (_x)2 - ( __ x)3 + ... + [-(-x)]" 
1
1- [_(_X)]"+l 
= 
1+(-x) 
11 + 1 
if -x i= -1 
if --x = -1 
This simplifies to 
1 + x + x 2 + x 3 + ... + xn 
{
~~ 
= 
1 -- x 
11+1 
if x # 1 
if x = 1. 
, 
u 
Example 3.5. 
Choose n + 2 distinct points from the circumference of a circle. ff 
consecutive points along the circle are joined by line segments creating a polygon 
with 11 + 2 sides. then the sum of the interior angles of the resulting polygon equals 
180n degrees (see Figure 2.1). Even though the assertion to be proved depends on 
Il in an obvious way, we still need to be careful with the statement P n' Specifically, 
we insist that the assertion holds no matter which n + .2 points are selected. 
A 
I! + 2 = 8, so Il = 6. 
Figure 2.1 
The sLIm of angles ,I + B + 
o 
• 
0 +- Ii = I 80 0 6 = I 080" 0 
76 

2:3 
INDUCTION 
The base case, when n = I, asserts that no matter how three points are selected 
from the circumference of a circle, then the resulting triangle contains three inte-
rior angles that total 180°, a result known from plane geometry. 
The inductive hypothesis asserts that no matter how k + 2 points are selected 
from the circumference of a circle, then the resulting polygon contains I< + 2 inte-
rior angles that total 1801< degrees. Suppose that we are given I< + 3 [note that 
k + 3 = (I< + I) + 2J points chosen from the circumference of a circle. The in-
scribed I< + 3 sided polygon P is shown in Figure 2.2(a). To use the inductive 
hypothesis, we need to ignore one of the selected points and consider the resulting 
k + 2 sided polygon P' shown in Figure 2.2(h). 
(aJ 
(bJ 
Figure 2.2 
P can be obtained from P' by attaching the triangle T as shown. The sum of 
the interior angles of P equals the sum of the interior angles of P' together with 
the interior angles of T. Thus 
angles of P = angles of P' + angles of T 
1801< 
+ 
180 
= 180(k + l). 
Example 3.2 (revisited). 
There are numerous proofs of equation (A) that do not 
require the technique of mathematical induction. We present here two especially 
beautiful ones for your pleasure. 
77 

2 ARITHMETIC 
First a geometric proof: We shall represent the left-hand side of (A) as the 
area of a plane figure. For example, if n = 2 we think of the sum 1 + 2 as the 
area of two rows of unit squares one with one square and one with two squares 
as shown in Figure 2.3. 
1+2=8:=J. 
Figure 2.3 
2(1+2)= 8J + ca 
Figure 2.4 
Eftl 
If we double the area under consideration, we get the following figure (Figure 
2.4). The figure on the right is a 2 x 3 rectangle whose area is 6. In general, 1 + 
2 + ... + n is represented by 11 rows of unit squares. If we double this value and 
piece the two areas together as shown in Figure 2.5, we get an 11 x (n + 1) rectangle 
whose area is n(n + 1). 
C 
2(1 + ... + n) = 
+ 
=n(n+ 1). 
Figure 2.5 
The third proof is even simpler although it is divided into two cases. The first 
case is when n is even. that is, n = 2r for some integer r. We begin with the left-
hand side of equation (A), where 2r has been substituted for n. Next we add the 
711 

2:3 
INDUCTION 
largest and smallest terms, then the second largest and second smallest, and so on, 
as shown in the following equation. 
1 + 2 + 3 + ... + (2r -
2) + (2r -
1) + 2r 
= (1 + 2r) + (2 + 21' -
1) + (3 + 2r- 2) + ... 
= (2r + 1) + (2r + 1) + (2r + 1) + ... 
(2 
) 
(2r)(2r + 1) 
=r r+l =----
2 
by regrouping 
by arithmetic 
by algebra 
n(n + I) 
=---
2 
by substitution. 
[J 
Exercise 4 asks you to complete this proof for the case when n is odd. 
EXERCISES FOR SECTION 3 
1. Give a noninductive proof that 2 + 4 + ... + 2r = r(r + 1). 
2. Show that 1 + 3 + 5 + ... + (2r -
I) = 1'2 in two different ways, one of which 
must be induction. 
3. Prove that 1 + 4 + 7 + ... + (3n - 2) = (311 2 -
n)/2. 
4. Complete the third proof of equation (A) for the case /1 = 2r + I. You can do 
this by temporarily ignoring either the last term or the middle term. 
5. Use induction to show that 
1 + 5 + 9 + ... + (411 + 1) = (n + 1)(211 + 1). 
6. Here is another argument that proves the result in Exercise 5. 
1 + 5 + 9 + ... + (4n + 1) = (4 . 0 + 1) + (4 . 1 + 1) + (4 . 2 + 1) + ... 
+(4'n+l) 
= (4 . 0 + 4· 1 + 4 . :2 + ... + 4· n) 
+ (1 + 1 + ... + 1) 
= 4 . (0 + 1 + 2 + ... + 11) + (11 + 1) . 1. 
Use known results to simplify the right-hand side and to deduce that the ~um 
is the same as is given in Exercise 5. 
7. Prove, by any method you like, that 
(a) 2 + 6 + 10 + ... + (4n + 2) = 2/1 2 + 4n + 2. 
(b) 2 + 5 + g + ... + (3r -
1) = (3r2 + /')/2. 
79 

2 ARITHMETIC 
8. Express the following sums as simply as possible: 
(a) 1 + 3 + 9 + ... + 3". 
1 
1 
1 
1 
(b) '2 + :j: + 8 + ... + 2"' 
(c) 1 -
4 + 16 -
64 + ... + (-1)'" 4n. 
9. Find a formula for the following sums: 
J" 
' 
(a) 1 + :c + x + ... + ,,_no 
I 
1 
1 
(b) 1 + - + -,- + ... + -. 
x 
,,-
x" 
10. Use induction to show that n2 -
n is always even. 
11. Use induction to show that /1"" + /13 -
2/1 2 is always even. 
12. Use induction to show that /l"" + 113 -
2112 is always divisible by 4. 
13. Find a formula for the sum In + (m + 1) + (m + 2) + ... + 11: your answer will 
be in terms of the variables 111 and 11. Use induction to show that your formula 
is correct. 
14. Suppose that n distinct points are selected from the circumference of a circle. 
Let Cn denote the maximum number of line segments joining two distinct 
points that can be drawn so that no two segments intersect. Find a formula 
for Cn and verify your guess by induction. 
2:4 THREE INDUCTIVE PROOFS 
It would be difficult to overemphasize the importance of mathematical induction 
to the mathematician and computer scientist. Believing that the best way to learn 
is by studying and doing, we offer some more examples and problems. 
Example 4.1. 
Look back at the assertions and algorithms about the number of 
subsets of a set given in Chapter L We claimed that if A is a set with 11 elements. 
then there exist 2" distinct subsets of the set A. We can prove this assertion now 
by induction. 
Precisely, we formulate PII to be the statement that a set with n elements has 
exactly 2" subsets. First we check the base case with n = 1. P l' But we have already 
checked that PI' P 2 , and P-, are true in Chapter I. We saw there that a I-set has 
two subsets, a 2-set has four subsets. and a 3-set has eight subsets. Thus we have 
accomplished step 1. 
Now we get to steps .2 and 3. which are. of course. the heart of the matter. 
We assume the truth of the statement I\: specifically that any set with k elements 
has :k subsets. Then we move to step: and examllle P k+ I' 
so 

2:4 THREE INDlJCTlVE PROOFS 
Suppose that A is a set with k + 1 elements. We want to show that there exist 
exactly 2k + l subsets of A. What we are allowed to use is the assumption that :\ 
is true. The trick here is to overlook one of the elements of the set A in order to 
obtain a set with k clements. Let x be an element of A and define B to be A - [x}. 
We illustrate in Table 2.4 where, with A = [x, y,,:, IV), we list the subsets of Band 
the subsets of A that contain x. 
Table 2.4 
.4 =:x,y,:. w) 
Subsets of A That Contain x 
~x: 
:x,y:· 
ix . .:] 
\x,w; 
lx,y,::} 
:x.y.wl 
~x . .:. w} 
t x, y,,:. w} 
B = A -:x: = lY,;;, w: 
Subsets of B 
o 
:y} 
r ~ I 
r - I 
:w} 
jy . .:} 
jy,w} 
::, IV] 
(y,.:,w} 
In the specific example above k = 3. B has 23 subsets, each of which is a subset 
of A. A has 23 subsets containing the specific element x. Each of these subsets 
could be obtained from a subset of B by adding the element x. Each of the 24-
subsets of A can be constructed in this manner. 
The general argument is the same. If A has k + 1 elements, B has k dements. 
Thus we know by step 2. the inductive hypothesis. that there exist 2k subsets of 
B. Each of these subsets of B is also a subset of A. Thus we know that there exist 
2k subsets of A, none of which contains the element x. From each of these subsets 
that don't contain x we can create a new subset of A that does contain x. Specifically. 
if S c;; B. define 5' to be S u : x:. Now 5' is a subset of A. Furthermore. since 5' 
contains x, it is not a subset of B. 
Finally. every subset of A either contains x or it doesn't. If a subset. sa) T, 
of .4 does not contain x. then T is a subset of B. If. on the other hand, T does 
contain x, then T -
: x: is a subset of B. Either way T has been accounted for. 
Then we see that 
#(subsets of.4) = #(subsets containing x) + #(subsets not containing x) 
= (1 + 1)· 2k 
= 2· 2k 
by inductive hypothesis 
by factoring 
by algebra 
by laws of exponents. 
~1 

2 ARITHMETIC
We have proved the following theorem using the Principle of Induction.
Theorem 4.1.
If .4 is a set containing n objects, then ,4 has 2“ subsets.
The proof of Theorem 4.1 suggests an algorithm for listing all subsets of a
given set. Suppose that we want to list all subsets of the set .4 = [al, a2,. . . . t~lo}.
Then the idea is, picking x = Ulo, to list all subsets of B = {Ul, u2,. ~,%] ~nd then
to repeat each subset with element a ~ ~ odded in. How do we get all subsets of B?
We could list all of the subsets of [al.. . . . ~s) and . . . . Woit  a minute.  Let’s W
forward rather than backward. We know that the set {a 1 } has two subsets, the
‘. From these subsets we can get all subsets of {a ~, a2} by
empty subset md {a 1,
repeating those just listed and adding U2 to get the additional sets [UZ ] and {a 1, a~ ].
This procedure should sound familiar. Reread algorithm SUBSET in Chapter 1
and see that the algorithm uses exactly this idea of adding in elements ~j to
previously formed subsets.
QUESTION 4.1. A set is said to be even if it has an even number of elements.
Note that the empty set has zero elements and is thus an even set. If .4 is a set
with n elements, guess a formula for the number of even subsets of A. Prove your
formula by induction. (Hint: How many odd subsets does A have’?)
Example 4.2. We now return to the algorithm presented at the beginning of
Section 2 and use induction to prove that the algorithm does compute x“. Here
is the algorithm listed again with a comment between step 5 and step 6. (To avoid
two different uses of the integer n the algorithm now calculates x’.)
Algorithm EXPONENT
S TEP 1. Input x, r [r a natural number]
STEP2. i:=(),ans:=l
S TEP 3. While i < r d o
Begin
S TEP 4. ans : = ans * x
STEP5. i:=i+l
{Comment: Right now ans has the value x’.]
End ~ step 3}
S TEP 6. Output ans and stop.
This example is more complicated than previc)us ones because the proposition
we need to verify, the P., is not explicitly presented. What we will do is use
induction to show that the comment inserted between step 5 and step 6 is true.
Before we do this, note that if the comment is always true, then it will he true
the last time it is encountered. The variable i is assigned the value O at step 2, und

2:4 THREE INDUCTIVE PROOFS 
this value is incremented by 1 each time through the loop. This continues until 
i = r, when the algorithm, upon returning to step 3. discovers that the condition 
"While i < r" is no longer true. Hence the algorithm proceeds to step 6 in which 
it outputs the value of ans. If the comment is true at i = r, the value of ans equals 
xr, which is what the algorithm was supposed to produce. 
The Pn then is the statement that the nth time the comment is encountered 
it is true. First we verify the base case. If n = 1, then we have just finished step 5 
for the first time. At step 2 the value of 0 was assigned to the variable i. This 
remains unchanged until step 5 when the value assigned to i was increased by 1. 
Thus the first time the comment is encountered the value of 1 is assigned to the 
variable i. Similarly, at step 2 the value of 1 was assigned to the variable ans. This 
remains unchanged until step 4 when the value of ans is multiplied by x. Thus the 
first time the comment is encountered the value of x = xl is assigned to the variable 
ans and thus P 1 is true. 
Now for the inductive hypothesis. We assume that the comment is true the 
kth time it is encountered. To accomplish the inductive step, we must use this 
assumption and show that the (k + I )st time the comment is encountered it is still 
true. The value assigned to i at the (k + 1)st encounter with the comment is the 
value assigned at the kth encounter plus one. This value is k + 1. The value as-
signed to ans at the (k + 1 )st encounter equals the value assigned at the kth en-
counter times x. The value assigned to ans at the kth encounter equals xk by the 
inductive hypothesis. Thus 
ans {after k + 1 encounters} = x . ans {after k encounters} 
= x' Xk 
= Xk+ I. 
Question 4.2. 
Consider the following algorithm: 
Algorithm SUM 
STEP 1. Input r, set ans : = 0 
STEP 2. For j = I to r do 
STEP 3. Set ans : = ans + j {Comment: Right now ans has the value 
jU + 1)/2.) 
STEP 4. Output ans and stop. 
COMMENT. 
Step 2 "For j = I to r do Step 3" is similar to the "While' .. do" loop 
of Example 4.2, only more compactly written. It means that first we set j = I and 
execute step 3; then we set j = 2 and carry out step 3, ... ; until finally we set j = r 
and execute step 3. 
Use induction to show that this algorithm outputs r(r + 1 )/2. 
83 

2 ARITHMETIC 
Example 4.3. 
We now verify that the algorithm DtoB. which tinds the binary 
representation of a number, is correct. For convenience we list the algorithm once 
again. 
Algorithm DtoB 
STEP 1. Set): = ° 
STEP 2. Divide m by 2 to obtain the quotient q and the remainder r; place r into 
the )th column of the answer (reading from the right and starting at 
zero) 
STEP 3. If q = 0, then stop. 
STEP 4. Set m:= q 
STEP 5. Set): = ) + 1 
STEP 6. Go to step 2 
The proof will be by induction. Thus we need a statement Pn with which to work. 
Let n denote the number of bits in the binary representation of the integer m. The 
statement P" will be that the algorithm correctly finds the binary representation 
of all integers whose representation has exactly II bits. 
First we check the base case P l' There is just one positive integer whose binary 
representation has exactly one bit, namely m = 1. In this case at step 2, q will 
equal 0, r will equal I, and the base case holds. Back in Chapter 1 you undoubtedly 
checked many other cases, so the result seems reasonable. 
Now for the inductive hypothesis. We assume that whenever m is an integer 
whose binary representation has k bits. then OtoB correctly finds these k bits. The 
inductive step says that we must prove the same for an integer with (k + I) bits: 
Suppose that In is such an integer. Take In and step through the algorithm until 
we get to step 6 for the first time. If m is even, r will be 0 and q will be m(2. If m 
is odd, r will be 1 and q will be (m -
1)/2. Consider the number q. We assert that 
it has one fewer binary digits than In. 
Question 4.3. 
How many bits are there in the binary representation of (a) 14, 
(b) 7, (c) 13, and (d) 6? How can you get the binary representation of 14 from that 
of 7? How can you get the binary representation of 13 from that of 6? 
We may assume (by the inductive hypothesis) that the algorithm will correctly 
produce the binary representation for q, since it has k bits. If we begin working 
the algorithm on q, we shall get exactly the same sequence of remainders beginning 
with j equal to 0 that we would have obtained from m beginning at the second 
encounter of step 2 with j = 1. 
If m is even, m = 2q. When a number in binary is multiplied by 2, its digits 
are just shifted one space to the left and a zero, the tirst remainder, is attached ut 
the end. Consequently, the algorithm will produce the correct binary representation 
for m. If m is odd, then m = 2q ..j.. 1. Here the binary representation for In can be 
:-14 

2:4 THREE INDUCTIVE PROOFS 
obtained from the binary representation for q by shifting each digit one space to 
the left and atttaching a 1 as the last digit. If In is odd, the first remainder is one, 
so the algorithm will once again produce the correct binary representation. 
D 
EXERCISES FOR SECTION 4 
1. Compare the idea for an algorithm contained in Example 4.1 with that of 
Algorithm SUBSET in Section 1.7. In what ways do they agree and in what 
ways do they differ'? 
2. Prove by induction that the number of 2-subsets of an .n-set A equals 
11(11- ll/2. [Hillt: Let x be any object of A and B = A - {xl. Then a 2-subset 
of A is either a 2-subset of B or a I-subset of B. Count the number of subsets 
in each case.] 
3. Prove by induction that the number of 3-subsets of an n-set equals 
n(1l -
l)(n - 2)/6. (Hint: Do Exercise 2 first.) 
4. Consider the following algorithm: 
Algorithm ODDSUM 
STEP 1. Input II, set ans : = 0 
STEP 2. For j = 1 to Il do 
Begin 
STEP 3. Set t:= 2 *j- I 
STEP 4. Set ans : = ans + t 
{Comment: Right now ans has the value p.] 
End 
STEP 5. Output ans and stop. 
Use induction to show that this algorithm outputs n2 . 
5. Consider the following algorithm: 
Algorithm FOU RSUM 
STEP l. Input 11, set ans : = 0 
STEP 2. For j = 1 to 11 do 
Begin 
STEP 3. Set I : = 4 *j - 3 
STEP 4. Set ans : = ans + t 
End 
STEP 5. Output ans and stop. 
Use induction to show that this algorithm outputs 11(211 -
1). 
85 

2 
ARITHMETIC 
6. How many binary digits do each of the following pairs of numbers have? 
(i) 6 and 3. 
(ii) 10 and 5. 
(iii) 12 and 6. 
(iv) 5 and 2. 
(v) 7 and 3. 
(vi) 11 and 5. 
7. What is the relationship between the pairs of decimal numbers whose binary 
representations follow'? 
(i) 10 and 100. 
(iii) 101 and 1010. 
(v) 11 and Ill. 
(ii) 11 and 110. 
(iv) 10 and 101. 
(vi) 101 and 1011. 
8. Suppose that m is a decimal number with binary representation s. Describe 
the binary representation of the numbers n 0= 4m, p = 4m + 1, q = 4m + 2, 
and r = 4m + 3 in terms of s. 
9. Reread Algorithm SUBSET in Section 1.7. Let Pk be the statement that the 
kth time the comment after step 3 is encountered, it is correct. Prove that Pk 
is true for all positive integers k. 
10. Design an algorithm to list all even subsets of an n-set and prove by induction 
that the algorithm is correct. 
11. Consider the following algorithm. 
Algorithm SQU ARESUM 
STEP 1. Input n, set ans : = 0 
STEP 2. For) = 1 to n do 
Begin 
STEP 3. Set k : = j * j 
STEP 4. Set ans : = ans -4- k 
{Comment: Right now ans has the value )(j + 1 )(2) + 1)/6.; 
End {step 2} 
STEP 5. Output ans and stop. 
Use induction to show that this algorithm outputs n(n + 1)(2n + 1)/6. 
12. Consider the following algorithm. 
86 
Algorithm MAX 
STEP l. Input n, a positive integer, and XI" .. ,xj " .. ,Xn , real numbers. 
STEP 2. Set max:= Xl 
STEP 3. For j = 2 to 11 do 
STEP 4. If Xj > max, then max: = Xi 
STEP 5. Output max and stop. 
Use induction to show that this algorithm outputs the maximum of the 
numbers X 1'X 2 ' ... ,xn' 

2:4 THREE INDUCTIVE PROOFS 
13. Consider the following algorithm. 
Algorithm BUBBLES 
STEP 1. Input n, a positive integer, and Xl"" ,Xj , ... ,Xn, real numbers 
STEP 2. For j = 1 to n - 1 do 
STEP 3. If Xj > Xj + 1, then do 
Begin {Trade the values of Xj and Xj+ d 
STEP 4. Set temp: = Xj 
STEP 5. Set Xj: = Xj+ 1 
STEP 6. Set Xj + 1 : = temp 
End {step 3} 
STEP 7. Output Xn and stop. 
Figure out what this algorithm does. Prove your guess by induction. 
14. Find a formula for the sum I -- 2 + 3 - 4 + ... + (-ltn. Then prove that 
your formula is correct. 
15. Here is a general statement of the Multiplication Principle: Suppose a counting 
procedure can be divided into n independent and successive stages. If there 
are C 1 outcomes for the first stage, and for each of these there are c 2 outcomes 
for the second stage. and for each of these initial outcomes there are c3 out-
comes for the third stage, and ... , and finally for each of these there are en 
outcomes for the final stage. then the total number of possible outcomes equals 
C1 . C2 ..... Cn' Prove this principle by induction on n. 
16. Here is a short algorithm. 
STEP 1. Input n (n a positive integer) 
STEP 2. Set i : = n, set ans : = 0 
STEP]. While i > 0 do 
Begin 
STEP 4. ans:= ans + i 
STEP 5. i: = i-I 
End 
STEP 6. Output ans and stop. 
(a) If the input is 4. what answer does this algorithm produce? 
(b) Explain why this algorithm will always stop regardless of what positive 
integer /I is used as the input. 
(c) In general, what is the answer (in terms of n) produced by this algorithm? 
Express this answer as simply as possible. 
17. Use induction to prove that] divides n3 + ]n 2 + 2n for every nonnegative 
integer n. 
87 

-
-
-
2 ARITHMETIC 
2:5 EXPONENTIATION REVISITED 
The algorithm EXPONENT, verified by induction in the preceding section, cor-
rectly computes xn. We discuss briefly the resources needed for implementation. 
There are four memory locations required, for x, i, ans, and n. It is possible to 
construct an exponentiation algorithm similar to EXPONENT that does not re-
quire separate memory locations for both nand i; however, the resulting procedure 
is not as clear as the one we have presented. 
Time is the other resource to assess, but what does that mean? If we run an 
algorithm on a big, fast computer, then we require less time than on a small, slow 
machine. If we run an algorithm on a time-sharing minicomputer, the time re-
quired depends upon the number of users and what they are computing. Maybe 
if we program the algorithm in FORTRAN, it will run faster than in Pascal. 
In this course we do not want to be concerned with specific machines (hardware) 
or specific languages (software). Instead we concentrate on a theoretical (but useful) 
measure of time. 
The fundamental operations that occur in our algorithms are assignment 
statements (: =), comparisons (If j < n, then ... ), additions and subtractions 
(+ and -), and multiplications and divisions (* and /). In a more advanced course 
you may study the time required for each of these operations. We'll assume that 
assignments happen instantaneously, that comparisons, additions, and subtrac-
tions each require a modest amount of time, and that multiplications and divi-
sions are the most time-consuming operations. These assumptions certainly hold 
true when human beings make these calculations! We also assume that one mul-
tiplication and one division require the same amount of time. In fact, that is 
essentially the case for computations on computers. 
Now look at Algorithm EXPONENT. We focus on step 4, since it is the only 
step that involves (time-consuming) multiplications. That is, we estimate the time 
needed to run this algorithm by counting the number of multiplications. Step 4 
is executed once for each integer between 0 and (n -
1) inclusive. Thus exactly n 
multiplications are executed. At first blush you might think that any algorithm 
that computes x" must require this many multiplications, but that is not the case. 
Example 5.1. To form X4 using EXPONENT requires four multiplications. Al-
ternatively, we could form x2 with one multiplication and then multiply x2 by 
itself to obtain X4 with just two multiplications. We can denote this by 
X4 = 1 . x . x . x . x = (x . xl . (x . x) = x 2 . x 2. 
There are four multiplications in the original algorithm. If you look at the second 
expression, you see three multiplications; however, the quantities within the two 
pairs of parentheses are identical. Consequently, we can compute X4 with two 
multiplications. Similarly, we can find x 5 with just three multiplications as indi-
88 

-
-
-
2:5 EXPONENTIATION REVISITED 
cated by 
x 5 = [(x' x) . (x . x)] . x = X4 . X. 
For x6 we require only three multiplications as follows. 
x6 = [(x' x) . (x . x)] . (x . x) = X4 . Xl. 
In English, it takes one multiplication to form Xl, one additional multiplication 
to form X4, and one final multiplication to combine these two products. 
Question 5.1. 
Using the ideas suggested by the preceding example, how many 
multiplications do you need to form xn for n = 7, 11, 12, and 16? 
Answering the previous question suggests that efficient evaluation of xn is 
related to the binary expansion of the integer n. Thus, for example, since n = 25 = 
16 + 8 + 1 we could write 
use three multiplications to obtain x 8 , one additional multiplication to obtain X 16 
and two more multiplications to combine the three factors. Thus it seems natural 
to suspect that there is an efficient algorithm to produce xn that contains an 
algorithm to find the binary representation of the integer n. We use the Algorithm 
DtoB whose validity we have verified at the end of the previous section. For 
convenience we repeat the algorithm here and trace another instance. 
Algorithm DtoB 
STEP 1. Set j : = ° 
STEP 2. Divide m by 2 to obtain the quotient q and the remainder r; place 
r in the jth column of the answer (reading from the right) 
STEP 3. If q = 0, then stop. 
STEP 4. Set in:= q 
STEP 5. Set j : = j + 1 
STEP 6. Go to step 2 
Example 5.2. If we use the algorithm DtoB to compute the binary representation 
of m = 25, we get the following table of the values (Table 2.5). 
To jazz this algorithm up so it will produce the value of xm, we need to add 
three additional steps. First we need 
STEP 0. Input x, m, set ans : = 1 
89 

,-
-
-
2 ARITHMETIC 
Table 2.5 
Variables 
j 
m 
q 
r 
Values after step 2 
0 
25 
12 
1 
12 
6 
0 
2 
6 
3 
0 
3 
3 
1 
4 
0 
to initialize the algorithm. Next, where necessary, we need to multiply the inter-
mediate result into the answer. We insert 
STEP 2.5. If r = 1, set ans : = ans * x 
Finally, we need to insert a step that doubles the exponent on x. 
STEP 5.5. Set x:= x * x 
To see how this works, we trace the new algorithm leaving x unspecified. 
Example 5.3. The trace of the algorithm to find x 25 is shown in Table 2.6. 
Table 2.6 
Variables 
j 
m 
q 
r 
x 
ans 
Values after 2.5 
0 
25 
12 
1 
x 
x 
1 
12 
5 
0 
x 2 
X 
2 
6 
3 
0 
X4 
X 
3 
3 
1 
x 8 
x 9 
4 
0 
x 16 
x 25 
Notice that four multiplications are required to compute the powers of x cor-
responding with each power of 2. Three multiplications are required to multiply 
the various factors together, and there is an additional cost of five divisions to 
form the binary representation. 
Question 5.2. Trace the result of applying the above algorithm to find x 37 . How 
many multiplications and divisions does the algorithm make? Do the same for 
X 52. 
The straightforward algorithm to produce xm required m multiplications. This 
new algorithm based on binary representation seems to do much better. In the next 
section we shall study just how good this algorithm is and introduce the mathe-
matics and jargon needed to discuss this question. 
90 

-
-. 
-
2:6 HOW GOOD IS FAST EXPONENTIATION? 
EXERCISES FOR SECTION 5 
1. Modify the algorithm EXPONENT so that upon input x and an integer n ~ 0, 
xn is computed using only n - 1 multiplications. (Be sure to cover the case 
when n = 0.) 
2. Modify the algorithm EXPONENT so that it uses only three memory locations 
for x, n, and ans. 
3. Among the integers n with 16 < n < 33, which integer requires the most mul-
tiplications to form xn using the new algorithm from this section? 
4. For each of the following integers n, find a factorization of xn that will allow 
its computation by few multiplications (a) n = 28, (b) n = 48, (c) n = 53, and 
(d) n = 56. 
5. TraceJhe result of applying the algorithm presented in this section to the prob-
lem of finding 210. 
6. Notice that x 18 = x 16 . x2 = (x6 )3. Which factorization provides the more 
efficient evaluation of X 18? 
7. Notice that x 6 = (x . x . x)2 and that x 9 = (x . x . X)3. Do these factorizations 
lead to more efficient computations than using the methods of this section? 
8. Look back at your algorithm in Exercise 2.4 designed to evaluate nx using 
only addition. Find a way, using the binary expansion of n, to calculate nx 
using fewer additions. 
2:6 HOW GOOD IS FAST EXPONENTIATION? 
In Example 5.3 we saw that computing X 25 based on binary representation re-
quired 12 multiplications and divisions while the traditional method would require 
25 multiplications. In this section we investigate just how fast this binary exponen-
tiation method is. We list the algorithm once again, named in anticipation of the 
analysis of its running time: 
Algorithm FASTEXP 
STEP 0. 
STEP 2. 
STEP 2.5. 
STEP 3. 
STEP 4. 
STEP 5.5. 
STEP 6. 
Input x, m, set ans : = 1 
Divide m by 2 to obtain quotient q and remainder r 
If r = 1, set ans : = ans * x 
If q = 0, then stop. 
Set m:= q 
Set x:= x * x 
Go to step 2 
Question 6.1. 
Why have we omitted steps 1 and 5? 
91 

-
-
-
2 ARITHMETIC 
To compare the time of F ASTEXP with that of EXPONENT, we count the 
number of multiplications and divisions. Thus given an integer m, how many mul-
tiplications and divisions will F ASTEXP require to form xm? Notice that every 
time step 2 is executed, there will be exactly one division. Similarly, every time 
step 5.5 is executed, there will be exactly one multiplication. Now look at step 2.5. 
Sometimes this step results in a multiplication and sometimes it doesn't. We have 
two options. We can either think hard and try to figure out exactly how many 
times step 2.5 requires a multiplication. Or we can be blase and say that in the most 
time-consuming case step 2.5 will require a multiplication every time it is executed. 
The most time-consuming case is also called the worst case. Thus for the worst-case 
analysis we count one multiplication every time that step 2.5 is encountered. 
For this particular algorithm we can carry out both the precise and the blase 
or worst-case analyses. For more complex procedures the worst-case analysis 
is commonly used and gives an upper bound on the time of the exact counting 
analysis. 
The Worst-Case Analysis. The number of multiplications and divisions required 
to implement F ASTEXP is no more than the number of times steps 2, 2.5, and 
5.5 are encountered. Since we never execute steps 2.5 and 5.5 without having first 
executed step 2, we know that the number of multiplications and divisions is no 
more than three times the number of times step 2 is encountered. So the analysis 
depends on the number of times 2 can be divided into m. This is essentially the 
logarithm of m. 
Logarithms. Given integers p and q with 2P = q, then p is said to be the logarithm 
to the base 2 of the number q. We shorten this to p = log (q). Here is the defining 
relationship in symbols: 
p"= log(q) if and only if 2P = q. 
Note that while base 10 is common in high school algebra and base e is typically 
used in calculus, in discrete mathematics and computer science logs are always 
assumed to be base 2 unless otherwise specified. 
Example 6.1. If p = 3, then 23 = 8. Consequently, log (8) = 3. Similarly, 
log(32) = 5 and log (1) = O. 
Question 6.2. 
Calculate the following: 
log (210) 
i
og (8) 
Question 6.3. 
Explain why log (2P) = p and iOg(q) = q. 
92 

-
-
-
2:6 HOW GOOD IS FAST EXPONENTIATION? 
Remember that if n is a positive integer, then Tn = 1/(2n). Thus if q = 1/(2n), 
then log(q) = -no 
We can mimic the definition of logarithm given above for some numbers that 
are not integers. Suppose that y is a rational number; that is, y = alb, where a 
and b are integers. Then 
log (x) = y, 
where 
In English, 2 to the y is the bth root of2 to the a. For example, 22/3 is the cube root 
of 4 while 23/2 is the square root of 8. Notice that x = 2Y is always a positive num-
ber for all rational numbers y. Thus the domain of the function f(x) = log (x) con-
tains only positive numbers. 
Here are two rules that help us work with exponents: 
(A) 
and 
(B) 
What do these rules tell us about logarithms? They are equivalent to the fol-
lowing properties, which are convenient for manipulating logarithms. 
log (a b) = log(a) + log (b), 
(A') 
and 
log (ah) = b log (a). 
(B') 
Here's why (A') is true in general. Suppose that n = log (a) and m = log (b). Then 
a = 2n and b = 2m. Thus 
This means that 
ab = 2n. 2m 
= 2n+m. 
log (ab) = n + m 
= log (a) + log (b). 
Property (B') follows similarly from (B). (See Exercise 2.) 
by (A). 
o 
93 

-
-. 
-
2 ARITHMETIC 
It would take us too far afield to attempt to define 2Y rigorously for arbitrary 
real numbers y or log (x) for arbitrary positive real numbers x. Luckily, it is not 
necessary. What we are really interested in is the integers that are near to log (x). 
Floor Function. 
Given a real number x, the floor function of x, denoted by Lx j, is 
defined to be the largest integer that is less than or equal to x. For example, L 3 j = 3, 
L3.l1j = 3, LI5.773j = 15, and L -4.15j = -5. 
Ceiling Function. 
Given a real number x, the ceiling function of x, denoted by 
r x 1, is defined to be the smallest integer that is greater than or equal to x. For 
example, r31 = 3, r3.111 = 4, rI5.7731 = 16, and r -4.151 = -4. 
Note that for any number x, LxJ ~ x ~ r x 1-
Question 6.4. 
Find 
l137 j, r275 1, Llog (8)j, pog (13)1, L -
194 j, flog (25)1, and 
Llog(13.73)J. 
We now have the vocabulary to answer the question of how many times we 
encounter step 2 in the execution of F ASTEXP. Essentially, we want to know how 
many binary digits there are in the representation of the number m. For example, 
the two binary numbers with exactly two digits are 10 and 11; these represent the 
decimal numbers 2 and 3, respectively. Similarly, the decimal numbers 4, 5, 6, and 
7 are all represented by three-digit binary numbers. In general, the decimal number 
m will be represented by a binary number with exactly r digits if and only if 
2r- 1 ~ m < 2r. 
Since 0 < c < d if and only if log (c) < log (d), we can take logs of the previous 
inequality to get 
log (2r - 1) ~ log (m) < log (2') 
which simplifies to 
r -
1 ~ log (m) < r. 
The floor function allows the convenient representation 
r -
1 = Llog(m)j 
or 
r = 1 + Llog(m)j. 
What we have learned is summarized in Figure 2.6. 
Thus in using FASTEXP to find xm, step 2 will be executed exactly 1 + Llog(m)j 
times. So in the worst case the algorithm will require 3(1 + Liog (m)j) ~ 3 + 310g (m) 
multiplications and divisions. 
94 

-
-
-
2:6 HOW GOOD IS FAST EXPONENTIATION? 
Decimal number +----+ Number of binary digits 
m 
1 + [log (m)j 
2'-1 S; m < 2' 
r. 
Figure 2.6 
There are two differences between the worst-case analysis and the exact count. 
First F ASTEXP terminates at step 3 when q = o. Thus step 5.5 is executed once 
less than step 2. The second difference occurs because the multiplication in step 2.5 
is not executed as often as step 2 is encountered. A little thought will convince 
you that the number of times this multiplication is made equals the number of Is 
in the binary representation of the number m. Thus the exact number of multi-
plications and divisions required by F ASTEXP equals 
2(1 + LIog(m)J) - 1 + #(1 bits in m). 
(C) 
At times this exact count may be useful, but on the whole the upper bound given 
by the worst-case analysis is easier to work with. 
Now let us contrast these two algorithms. EXPONENT requires n multiplica-
tions to compute x
R
• Such an algorithm is called linear. The name is appropriate 
because if one plots the number of multiplications as a function of the exponent, 
the result is a straight line. Any such linear algorithm has the property that if one 
doubles the problem size, then the number of steps required (and thus the amount 
of time required) approximately doubles. 
Example 6.2. 
Suppose that a particular algorithm reads in an integer nand 
requires 3n + 7 steps. If n = 100, the number of steps is 307. If n is doubled to 
200, then the number of steps equals 607. Notice that this is almost double the 
original 307 steps. 
That doubling the input size to a linear algorithm does not exactly double the . 
number of steps is a consequence of the fact that not all straight lines go through 
the origin. Thus how much the doubling rule is off depends on the y-intercept. In 
general, if the size of n is large compared to the y-intercept, then the doubling 
rule will be fairly accurate. 
FASTEXP requires no more than 310g (n) + 3 multiplications and divisions to 
compute x
R
• [Notice that 310g (n) + 3 is more convenient to work with than the 
more precise result in (C).] Such an algorithm is called logaritbmic. If we plot the 
number of steps as a function of the input size, we get a logarithmic curve. A log-
arithmic algorithm has the significant property that one must square the size of the 
input before the number of steps (and thus the time) approximately doubles. 
95 

-
-
-
2 ARITHMETIC 
Example 6.3. Suppose that a particular algorithm has an integer n as input and 
requires no more than 9110g (n)j steps. As in the preceding example if we input 
n = 100, the number of steps is no more than 9 Llog(100)j. Since 26 = 64 and 
27 = 128, Llog(100)j = 6. Thus the number of steps is no more than 9 . 6 = 54. If 
we double the input size to n = 200, the number of steps is no more than 9 . 7, since 
Llog (200)j = 7. If we square the input size to n = 10,000, the number of steps is 
now no more than 9110g (lO,OOO)j = 9 . 13 = 117. 
The contrast of the two preceding examples illustrates why logarithmic al-
gorithms are much preferred to linear algorithms. In the next section we shall 
examine the logarithm function and others in more detail. 
EXERCISES FOR SECTION 6 
1. Calculate the following. Then match up the answers from the left-hand column 
that agree with one from the right-hand column. 
log(2 . 2) 
log(2 ·4) 
log(2·8) 
log (4 . 8) 
log (22) 
log(82) 
log(164 ) 
log(2) + log (4) 
log(4) + log(8) 
4Iog(16) 
2Iog(2) 
2 log (8) 
log (2) + log (8) 
2. Explain why log (ab) = blog(a). 
3. Find Llog(n)j if n = (a) 10, (b) 100, (c) 1000, and (d) 10,000. 
4. Decide whether each of the following is true or false. 
(a) log(256) = 56. 
(b) i og (3) = log (3). 
(c) log (2 . 3) = log (3). 
(d) log (t) = -1. 
(e) Llog(17)j = 4. 
(f) log(23) = 4. 
(g) log( -2) = -1. 
(h) log (i) = log(3)/3. 
(i) log(!) = -2 log (3). 
Correct those that are false. 
S. Show that log (lOt) < 4t for all positive integers t. 
6. Find the smallest integer k such that log (lOOt) < kt for all positive integers t. 
7. Find (a) Liij, (b) nn (c) U~j, (d) pog(73)l, (e) Llog(73)j, (f) L INJ, 
(g) pog(49n, and (h) Llog«23)4)J. 
8. Suppose that f(n) = 7n + 11. Find the quotient f(2n)/f(n) if (a) n = 100, 
(b) n = 200, and (c) n = 1000. 
96 

-
-
-
2:7 HOW LOGARITHMS GROW 
9. Suppose that f(n) = 3n2 + 4n + 5. Find the quotient f(2n)/f(n) if (a) n = 100, 
(b) n = 200, and (c) n = 1000. 
10. Suppose thatf(n) = 4Llog(n)J + 13. Find the quotientf(n2)/f(n) if (a) n = 100, 
(b) n = 200, (c) n = 10,000, and (d) = 20,000. 
11. (a) Show that if f(n) is a linear function of the form f(n) = a' n, where a is a 
constant, then f(2n) = 2f(n). Find an equation expressing f(n2) in terms of 
f(n). 
(b) Suppose that g(n) is a logarithmic function of the form g(n) = blog(n). 
Then express both g(2n) and g(n2) in terms of g(n). 
12. Use induction to show that FASTEXP is correct. (Hint: Reread the proof that 
DtoB is correct.) 
13. How many multiplications and divisions are performed if F ASTEXP is used 
to compute X 89? 
14. For each of the following values of m and r, verify that m has r binary digits, 
where r = 1 + Llog(m)J: 
(a) m = 2, r = 2. 
(b) m = 3, r = 2. 
(d) m = 7, r = 3. 
(e) m = 8, r = 4. 
(g) m = 37, r = 6. 
(h) m = 100, r = 7. 
(c) m = 4, r = 3. 
(f) m = 15, r = 4. 
15. Is the following true or false? The number of binary digits in the number m 
is r = pog(m)l Explain. 
16. Calculate 2(3
2
) and (23)2. Explain, in general, why aW ) does not equal (abf 
17. Does log(ab) equal (log (a))b? Explain. 
18. The Post Office now charges 25 cents for a letter weighing up to 1 ounce and 
then 20 cents for each additional partial or whole ounce. If x is the weight 
of a letter in ounces and x ~ 1, then find a formula· for the cost of mailing 
that letter. 
19. Suppose that R(x) is the function that takes a real number x and rounds it 
to the nearest integer. If x = j + .5, where j is an integer, then R(x) = j + 1; 
that is, R rounds up. Find a formula for R(x) using the floor and/or ceiling 
functions. 
2:7 HOW LOGARITHMS GROW 
In the previous section we distinguished between EXPONENT and F ASTEXP 
by looking at the functions that count the maximum number of divisions and 
multiplications that each would perform for a given input. This kind of analysis 
is crucial to any comparison of algorithms. 
97 

-
-
-
2 ARITHMETIC 
To appreciate fully the advantages of a logarithmic algorithm over a linear 
algorithm, we must have a thorough understanding of the logarithm function. Our 
first observation about the logarithm function is that it gets arbitrarily large. By 
that we mean that given any positive integer M, no matter how large, once n is 
sufficiently large f(n) = log(n) will be larger than M. To see this, note that 
log (2M) = M by definition. Thus 
if n > 2M , then log (n) > M. 
Many functions get arbitrarily large, for example, f(n) = n, g(n) = n2 and the 
square root function h(n) = In. Note that g(n) = n2 grows more rapidly thanf(n) = 
n, which grows more rapidly than h(n) = In. How fast does the logarithm function 
grow in comparison with these functions? Our principal result about the logarithm 
function is that its growth is very slow, in fact, even slower than the square root 
function. The remainder of this section is devoted to this property. We begin with 
the following fact about exponents. 
Lemma 7.1. If r is an integer greater than 5, then 2r > (r + 1)2. 
Mathematicians call a particular mathematical statement a lemma if it doesn't 
appear very interesting but is useful in proving something else. Notice that the 
conclusion of the above lemma is false for r = 1, 2, 3, 4, and 5 as shown in Table 
2.7. 
Table 2.7 
r 
2' 
(r + 1)2 
1 
2 
4 
2 
4 
9 
3 
8 
16 
4 
16 
25 
5 
32 
36 
6 
64 
49 
7 
128 
64 
8 
256 
81 
Lemma 7.1 will be proved by induction. The proposition Pr will be that 2' > 
(r + 1)2. The base case will be r = 6, and we shall show that the truth of P k 
implies the truth of P k + 1 . 
Proof. We have the base case from Table 2.7. Next we assume that 2k > (k + 1)2 
and use this to show that 2k + 1 > [(k + 1) + 1]2. Now 
98 

-
-
-
2:7 HOW LOGARITHMS GROW 
2k+ 1 = 2. 2k 
> 2(k + 1)2 
= 2k2 + 4k + 2 
= k2 + 4k + 4 + (k2 - 2) 
= (k + 2)2 + (k2 -
2) 
> (k + 2)2 
by algebra 
by inductive hypothesis 
by algebra 
by algebra 
by algebra 
by ignoring (k2 - 2), which 
is positive for k > 1. 
D 
We use Lemma 7.1 to show that the logarithm function is eventually smaller 
than the square root function. 
Theorem 7.2. If n 2 64, then -Jii > log (n). 
Proof. 
Suppose that k is the largest integer with 2k :=; n, that is, k = LIog(n)J. 
Then by definition 
These two inequalities will produce the proof. First, if 
2k + 1 > n, 
then, by taking logs of both sides, we get 
k + 1 > log (n). 
(A) 
Second, if n 2 64, then k 2 6 and Lemma 7.1 applies. Thus 
Taking square roots of the two ends, we get 
-Jii>k+1. 
(B) 
Combining inequalities (A) and (B) gives -Jii > log (n). 
D 
Question 7.1. 
Using a calculator, find the smallest integer N such that IN > 
10g(N). Does this contradict Theorem 7.2? (Comment: if your calculator does not 
work in base 2, see Supplementary Exercises 9 and 10.) 
Corollary 7.3. If n 2 64, then n/log (n) > -Jii. 
99 

-
--
--
2 ARITHMETIC 
r-------~~------~r_--------------------------_,~ 
0 -
100 
\ 
\ 
\ 
\ 
\ 
\ 
I 
I 
I 
I 
I 
I 
I 
I 
I , 
I 
I 
\ 
I 
\ 
I 
\ 
\ 
\ 
\ 
'. 
I~ 
>< 
OJ) 
.2 
II 
---
~ 
..::: 
---
L>;, 
~ 
OJ) 
.2 
<.0 -
0 
l"-
N 
Q,j .. = 
~ 
ii: 

-
--
-
2:7 HOW LOGARITHMS GROW 
Proof. 'Since n 2 64 implies ~ 
> log (n), then if n 2 64, 
o 
Corollary 7.4. The function hen) = n/log (n) gets arbitrarily large. 
Proof. 
As above we mean that given any (large) integer M, if n is big enough, 
then hen) is bigger than M. Suppose that M 28. Then if n > M2, by the previous 
corollary, 
hen) > ~ 
> JM2 = M. 
o 
Mathematicians use the word corollary for a statement whose proof almost 
immediately follows from a previous result. Corollary 7.4 looks inconsequential, 
but we shall have an important need for it later in this chapter. 
We illustrate the growth of these functions in Figure 2.7; however, we shift 
our point of view on the domain of these functions. Until now we have been in-
terested in counting problems, involving integers and functions evaluated at inte-
gers. Thus we write functions like fen) = log (n), gem) = .j;., and her) = r2, where 
n, m, and r represent integers. Furthermore, we think of our functions as having 
integer domains, usually the nonnegative or positive integers. On the other hand, 
most of the functions we are using can be defined for domains of real numbers. 
For ,example, f(x) = log (x) has domain all positive reals, g(x) = Fx has domain 
all nonnegative reals, and hex) = x2 has domain all real numbers. When we specify 
a function in terms of the variable x, we mean that x may take on any real value 
in its domain; in general, the context will make the appropriate domain evident. 
For graphical illustration we choose to consider the functions x/log (x), Fx and 
log (x) as functions of real variables and to graph them as continuous curves as 
in Figure 2.7, rather than just plot the functions at integer values. 
In the next section we develop the standard notation for comparing functions 
and their growth rates. 
EXERCISES FOR SECTION 7 
1. Find an integer N such that if n 2 N, then n/log(n) > 100. 
2. Find the smallest integer m such 2m > m2 . Then show that if r is any integer 
at least as large as m, then 2' > r2. 
3. Find the smallest integer q such that 2q > (q + 1)3. Use induction to show 
that if r is any integer with r 2 q, then 2' > (r + 1)3. 
101 

-
-
-
2 ARITHMETIC 
4. 
5. 
6. 
7. 
8. 
Use the preceding exercise to show that the cube root function is eventually 
larger than the log function. 
In Question 7.1 you found the least integer N such that IN > log (N). Prove 
that if n ~ N, then -!ii > log (n). 
Show that -!ii/log (n) gets arbitrarily large. 
What is the largest value that iog(n)/J/\ can achieve for any positive integer n? 
Suppose thatf(n) = log(n) and g(n) = log (f(n)). The following table lists some 
values for n, fen), and g(n). Determine the values that correctly replace the 
question marks. 
n 
f(n) 
g(n) 
0 
2 
1 
0 
4 
2 
? 
4 
? 
? 
? 
4 
? 
? 
8 
9. With g(n) defined as in Exercise 8 comment on the remark, "For practical 
purposes, log (g(n)) < 8." 
10. The function g(n) of Exercise 8 is sometimes written as g(n) = log log (n). Find 
a simple expression for log log (22"). Explain why log log (n) is defined only 
for n > 1. Then explain why loglog(n) gets arbitrarily large for large values 
of n. 
11. Which function is larger: log (n) or log log (n)? Explain. 
12. For what function men) is it true that log log (m(n)) = 210g log (n)? 
2:8 THE "BIG OH" NOTATION 
In Section 2.7 we began, to explore a hierarchy of functions that might appear in 
the analysis of algorithms. We saw that log(n) < -!ii < n/log(n) < n, provided that 
n is large enough. Consequently, we would prefer an algorithm that used -!ii steps 
to one that used n/log(n) steps on a problem with input size n. Since most algo-
rithms are analyzed on a worst-case basis, we don't want our distinctions to be too 
finely drawn. Computer scientists and mathematicians have come to use what is 
called the "big oh" notation when discussing the efficiency of algorithms. 
102 

-
-. 
-
2:8 THE "BIG OH" NOTATION 
Definition 1. 
Let f(n) and g(n) be functions whose domains are the positive inte-
gers and whose ranges are the positive reals. Then we write 
f(n) = O(g(n)) 
or 
f = O(g) 
(read "/ of n is big oh of g of n" or "/ is big oh of g") if there is a positive constant 
C such that 
f(n) ~ C . g(n) 
for all positive integers n. 
Example 8.1. 
Suppose that f(n) = 5n and g(n) = n. To show that f = O(g), we 
have to show the existence of the constant C in Definition 1. The best way to 
show the existence of such a C is to actually produce it. Here the example has 
been cooked up so that the constant C is staring us in the face. For if we choose 
C = 5, thenf(n) actually equals C . g(n). Notice that we could have selected a larger 
number for C. For instance, if we choose C = 6, thenf(n) = 5n < 6n = c· g(n). So 
we write f(n) = O(n). 
Example 8.2. 
Suppose that f(n) = 5n + 8. To show that f(n) = O(n), we must 
produce a constant C such that f(n) ~ C . n for all n. If we try C = 5, this doesn't 
work, since f(n) = 5n + 8 is not less than 5n [e.g., f(l) = 13 > 5 = 5 ·1]. We need 
C to be at least 13. To see that C = 13 will work, note that 8 ~ 8n. Thus 
5n + 8 ~ 5n + 8n = 13n. 
Let's look at a function that is not linear. 
Example 8.3. 
Suppose thatf(n) = n2 . We show thatf(n) is not big oh ofn, denoted 
f(n) =F O(n). To accomplish this, we must show that there cannot exist a constant 
C that satisfies the big oh definition. Suppose that there were such a constant C. 
We would need 
for all n. However, if n > C, 
n2 > c· n. 
Combining these two inequalities shows that for n > C, 
Thus no C can work. 
103 

-
-
2 ARITHMETIC 
Example 8.4. 
Suppose that fen) = n2 + 3n -
1. Then 
fen) = n2 + 3n -
1. 
< n2 + 3n, 
since subtraction makes things smaller 
::;; n2 + 3n2, 
since n ::;; n2 for integer n 
= 4n2 . 
Thus, letting C = 4, we have fen) = O(n2). 
Question 8.1. 
Show that fen) = 12n2 - 11 and hen) = 3n2 + 4n + 11 are both 
O(n2). 
These examples illustrate the big oh notation for linear and quadratic functions. 
Each time we find a simple function that is an upper bound on the original func-
tion. We emphasize that it is the growth of the functions that is of interest to us. 
Any linear function! has the property that f(2n) is almost double fen). Furthermore, 
the larger n is, the more exact this rule. In contrast a quadratic function h has the 
property that h(2n) is almost quadruple hen). Similarly, the larger n is, the more 
exact this rule. 
We call an algorithm linear (or quadratic) if there is a function fen) that counts 
the number of the most time-consuming steps the algorithm performs, given a 
problem of size n, and fen) = O(n) (or O(n2)). Let us see how this idea might help 
us decide which algorithm to select in a given situation. 
Example 8.5. 
Suppose that we have two algorithms, say Land Q that each 
correctly solves a particular problem. L is linear and takes 20 minutes on a problem 
of size 10; Q is quadratic and takes 5 minutes on the same problem of size 10. 
Suppose that we have a problem of size 100. Which should we use? L ought to 
take about 200 minutes to solve the problem, and Q ought to take about 500 
minutes to solve the problem. Why the difference? Because a tenfold increase in 
problem size ought to produce a hundredfold increase in running time for a 
quadratic algorithm while only a tenfold increase in running time for a linear 
algorithm. 
Question 8.2. 
Suppose that L is a linear algorithm that solves a problem of size 
100 in 8 minutes while C is a cubic algorithm that solves a problem of size 100 
in 2 minutes. For a problem of size 200 which algorithm would you use? How 
about a problem of size 1000? {First you will have to decide what we mean by a 
cubic algorithm.} 
It might be that, say, an algorithm we have called linear is faster than linear, 
that is, fen) = O(n) and fen) = O(g(n)) for some function g(n) smaller than n. It 
might be'that it is our analysis that is weak and only demonstrates fen) = O(n). 
We shall discuss this in more detail in the next section. 
104 

-
-
-
2:8 THE "BIG OR" NOTATION 
Since there are linear, quadratic, and cubic algorithms, you should not be 
surprised to learn that this hierarchy generalizes to arbitrary exponents. 
Example 8.6. If f(n) = nl 7 + 3n15 - 7nlO + 20n6 -
lOn, then we show that 
f(n) = O(nl7). 
f(n) < n17 + 3nl5 + 7nlO + 20n6 + lOn, 
since for n > 0, changing negative coefficients to positive makes the function larger; 
:::; nl7 + 3nl7 + 7nl7 + 20nl7 + 10nl7, 
since making exponents larger makes the function larger; 
= (1 + 3 + 7 + 20 + 10)nl7 
= 41nl7. 
Question 8.3. 
Show that f(n) = 2n 7 -
6n5 + 10n2 -
5 = O(n7). 
The first theorem of this section says that any polynomial is big oh of its term 
of highest degree. The proof mimics the previous example. We let aj denote the 
coefficient of the term of degree j in the following theorem. 
Theorem 8.1. 
Let f(n) = ad' nd + a d - l . nd - 1 + ... + a l . n + ao, where d is a 
positive integer and ad, ad _ 1, ... ,al and ao are constants. Then f(n) = O(nd). 
Proof. 
First we change all the coefficients of f to positive numbers. This can only 
increase the value of f(n) for positive integers n. Next we note that nj :::; nd if j :::; d. 
Thus 
d 
d 
1 
. 
f(n) = ad' n + ad-1 . n -
+ ... + a j ' n1 + ... + a o 
:::; ladl' nd + ... + lajl' nj + ... + lao I 
:::; ladl' nd + ... + lajl' nd + ... + laol' nd 
= (Iadl + ... + lajl + ... + laol)' nd 
= C' n
d 
provided that C is equal to the sum of the absolute values of the coefficients in 
the original polynomial. 
0 
The big oh notation has certain peculiar features. For example, when we write 
f = O(g) we are not writing down an equation of the usual sort. It does not express 
a symmetric relation; that is, we do not write O(g) = f nor does it follow that 
9 = OU), although it might in some instances. Here are some basic properties 
about big oh that are helpful in manipulations. 
105 

-
-
-
2 ARITHMETIC 
Theorem 8.2. If f = O(g), then for any constant a, 
(i) a' f = O(g). 
If, in addition, h = O(k), then 
(ii) f + h = O(g + k), 
and 
(iii) f' h = O(g . k). 
Finally, if f = O(g) and g = O(h), then 
(iv) f = O(h). 
Example 8.7. 
Suppose that f(n) = 5n3 + 2n. Then f(n) = O(n3) by Theorem 8.1. 
Next consider w(n) = 15n3 + 6n = 3f(n). By (i) of Theorem 8.2 (as well as by 
Theorem 8.1.), w(n) = O(n3). 
Example 8.8. 
Suppose that f(n) = 3n + 7 and h(n) = 2n2 - n + 8. We know that 
f = O(n) and that h = O(n2) by Theorem 8.1. By (ii) of Theorem 8.2 f + h = 
O(n + n2). Since n + n2 = O(n2), we can use part (iv) of the Theorem 8.2 to obtain 
f + h = O(n2). This result also follows from Theorem 8.1, since f(n) + h(n) = 
2n2 + 2n + 15. 
Example 8.9. 
Suppose that f(n) = n2 + 3n + 7 and h(n) = n3 + 17. Since f = 
O(n2) and h = O(n3), by part (iii) f· h = O(n 5 ). Notice that we didn't multiply out 
f . h, but if we had, the result would be a polynomial of degree 5. 
Question 8.4. If f(n) = 3n 5 + 13n3 - 10 and g(n) = 2n4 + 3n2, find h(n) and k(n) 
such that f + g = O(h) and f· g = O(k). Justify. 
Proof of Theorem 8.2. 
We prove the second assertion leaving the remaining three 
proofs for Exercise 6. Suppose that C and C are constants such that f(n) s; c· g(n) 
and h(n) s; C . k(n). Let D equal the larger of C and C. Then 
106 
f(n) + h(n) S; C . g(n) + C . k(n) 
S; D . g(n) + D . k(n) 
= D . (g(n) + k(n)) 
= O(g(n) + k(n)). 
o 

-
-
-
2:8 THE "BIG OH" NOTATION 
Here is a summary of what we know about comparisons between functions. 
First, for all positive n 
Thus we also have these big oh results: 
and in general, 
1 = O(0t), 
0t = O(n), 
n = O(n2 ), 
n2 = O(n3), 
if i ~ j. 
You may have noticed that we have been avoiding the log function. Partly, 
this is because 10g(1) = 0 and so the log function doesn't have range the positive 
reals and thus does not fit into the big oh definition. However, we know that if n 
is large enough (n ;;::: 16), then log(n) ~ 0t. Furthermore, as shown in Table 2.8 
and Exercise 8, log(n) is always less than twice 0t. Thus we want to say that 
log(n) = O(0t). 
Table 2.8 
n 
log(n) 
1 
0 
2 
4 
2 
5 
2.32" . 
6 
2.58" . 
7 
2.80" . 
8 
3 
9 
3.16' .. 
10 
3.32" . 
16 
4 
32 
5 
64 
6 
We would also like to say that 
)";r 
1.4 ... 
2 
2.23" . 
2.44" . 
2.6" . 
2.8" . 
3 
3.16' .. 
4 
5.6" . 
8 
1 = O(log(n)); 
log (n)/)";r 
o 
0.7" . 
1 
1.03· .. 
1.05· .. 
1.06· .. 
1.06· .. 
1.05· .. 
1.05· ., 
1 
0.8" . 
0.75 
107 

-
-
-
2 ARITHMETIC 
however, this also doesn't satisfy our present definition of big oh. Since log(l) = 0, 
there is no constant C such that 1 s Clog (n) for all n. For n z 2, it is the case 
that 1 s log (n), and so the constant C = 1 will work for n sufficiently large (larger 
than 1). What this suggests is that we need a stronger definition of big oh. 
Definition 2. 
Let fen) and g(n) be functions with domain the positive integers. 
Then we say 
f(n) = O(g(n» 
or 
f = O(g) 
if there are positive constants C and N such that 
fen) s C . g(n) 
for all integers n z N. 
With this more general definition we can say that 1 = O(log(n», since C = 1 
and N = 2 work. Also log(n) = O(Jil) using C = 2. We shall need this stronger de-
finition only when we want to show that an algorithm performs fen) = O(log(n» 
steps on a problem of size n. Such an algorithm is called logarithmic. 
Definition 2 is the standard definition of the big oh machine. We have em-
phasized the simpler form because it is almost as widely applicable and it is easier 
to use. Furthermore, any pair of functions f and g with f = O(g) in the first defi-
nition also has f = O(g) in the second definition. 
Our hierarchy of functions now looks like 
This hierarchy of functions is worth remembering. In a typical analysis you 
will have a (complicated) functionf(n) and will need to find g(n), as small and simple 
as possible, so thatf = O(g). The best candidates for g are the functions listed above. 
Example 8.10. Suppose that fen) = log(n)· # . sin(n). We want to find g from 
the list of basic functions above so that f = O(g). First, recall that the value of the 
sine function never exceeds 1. Next we note that # = n . In. Thus 
108 
fen) slog (n) . R 
=log(n)·n·Jn 
= O(log(n)· In. n) 
= O(Jn· In. n) = O(n2). 

-
-
-
2:8 THE "BIG OH" NOTATION 
In many of the examples of this section whenf = O(g), it has also been the case 
that g = O(f). This is a common occurrence in problems about polynomials but 
will not generally be true. We know from Example 8.3 that n = 0(n2), but n2 #- O(n). 
Also, in the preceding example, although f(n) = 0(n2), it is not true that n2 = 
O(f(n)), although we shall not go into the tricky details. 
EXERCISES FOR SECTION 8 
1. Find a constant C that demonstrates that f(n) = O(g(n» for each of the 
following. 
(a) f(n) = 17n + 31, g(n) = n. 
(b) f(n) = 21n -
13, g(n) = n. 
(c) f(n) = 12n2 + 3n + 15, g(n) = n2. 
(d) f(n) = 3n2 - 4n + 5, g(n) = n2. 
(e) f(n) = 2n2 - n - 1, g(n) = n2. 
(f) f(n) = 0.2n + 100,000, g(n) = n. 
(g) f(n) = n3 + 3n2 + 5n + 11, g(n) = n3 . 
(h) f(n) = n3 + 3n2 + 5n + 11, g(n) = n4. 
2. Which of the following is True and which False? 
(a) n = O(n), (b) n = 0(n2), (c) n = 0(n3), (d) n2 = O(n), (e) log(n) = O(n), 
(f) n = O(log(n», (g) n = O(n . log (n», (h) n ·log(n) = 0(n2), and 
(i) 1/(n2 + 1) = 0(I/n2). 
For each true statement, find a C that demonstrates the big oh definition. 
3. Here is the functional hierarchy: for n sufficiently large. 
Add all the following to this hierarchy. (a) l/n, (b) 1/(n2 ), (c) n3/2 , 
(d) n/log(n), (e) n2jlog(n), (f) n/(log(n»2, and (g) the cube root of n, n1f3. 
4. Answer the following with explanations for your answers: 
(a) Is f(n) = 0.5n . log(n) + 3n + 15 = 0(n2)? O(n)? 
(b) Is f(n) = (3n2 + 5n -
13)2 = 0(n5)? 
(c) Is f(n) = (3 log (n) + n)2 = 0(n2)? 
(d) Is f(n) = 1/(n2 + 1) = 0(1)? 
(e) Is 4Iog (n
2
) = O(log(n) + I)? 
(f) Is (4Iog (n
2)2 = 0(n3)? 
5. Some functions f(n) are listed in column A of the following table. Some func-
tions g(n) are listed in column B. For each f in column A find the smallest 
g in column B with the property that f = O(g). 
109 

-
-
-
2 ARITHMETIC 
7 + 32n + 14n2 
17 + log (n4) 
log (nn) 
(log (nn»2 
sin (n 2) 
2nl(n + 1)3 
A 
(n2 + n' log (n»2 
2nlnn 
(log (n»O.5 
In 'log(n) 
Jn3 
Jn 3 + 3n2 
41og (n) 
10gWl) 
n1og(n) 
(n + .jri.)2 
(n + 1)/(n2 + 1) 
(log (n»4In 
5 + (log(n»2 - nl2n + om + n3 
1 + 4 + 9 + ... + n2 
1 
1 
1 
1+-+-+"'+-
2 
4 
2" 
(log (n)/n)" 
6. Prove parts (i), (iii), and (iv) of Theorem 8.2. 
B 
log(n) 
.jri. 
n' (log (n» 
lin 
7. Suppose that 9 is a function such that g(n) > 0 for all n. Express f(n) - g(n) 
as big oh of some combination of f(n) and/or g(n). Then prove your answer. 
Can you deduce a similar result for f(n)!g(n)? 
8. Fill in the values of Table 2.8 for n = 11,12, ... ,15. See Supplementary Exer-
cises 9 and 10 about computing log (x). 
9. Show that n3 is not 0(n2). 
10. Show that 2n2 + 5n is not O(n). 
11. Is it true that for every pair of functions f and 9 either f = O(g) or 9 = O(f)? 
2:9 2""# O(p(n»: 
PROOF BY CONTRADICTION 
We have seen that the polynomials form a natural hierarchy of functions against 
which we can compare the counting functions that really interest us. Is it the case 
that.all our counting functions are O(p(n)) for some polynomial p(n)? No! The first 
natural example is the function 2" that counts the number of subsets of a set with 
n elements. Here we have a negative (and significant) result. 
no 

-
-
-
2:9 
2ft -:f;: O(p(n)): PROOF BY CONTRADICTION 
Theorem 9.1. If r is a constant bigger than 1, then the function rn is not O(p(n)) 
for any polynomial p(n). 
What does it mean to say that a functionf(n) is not big oh of the polynomial 
p(n)? Well, if f were O(p), then there would exist constants C and N such that 
f(n) ~ C . p(n) for all n ~ N. If f is not O(p), then there are no such constants. 
Specifically, there is no constant C such that f(n) ~ C . p(n) for all sufficiently large 
n. Such a fact can be harder to demonstrate than the fact that one function is big 
oh of another. 
The proof of Theorem 9.1. will employ the technique of proof by contradiction. 
This technique is frequently used without notice if the statement to be proved is 
simple enough. We did it, for instance, in Chapter 1 in Theorem 9.1 and in (this 
chapter's) Example 8.3. The technique is almost as important as Mathematical 
Induction, but isn't as completely specified. We digress to explain. 
Proof by Contradiction. We pause first to think a bit about what a mathematical 
proof is. Although a proof can be described precisely in logical terms with axioms, 
truth tables, and rules of inference, we choose to be more informal. The aim of a 
proof is to establish the validity of some assertion A. It may be a simple statement 
like "14 is an even integer," or it may be in the form of an implication, like "If 
n ~ 2, then log(n) ~ 1," or it may be in another form, like "There is an integer 
that is divisible by both 3 and 7." In a (usual) direct proof, we begin working with 
known mathematical truths and proceed logically until we deduce the truth of 
assertion A. For example, look back at the proof that log (a . b) = log (a) + log (b) 
in Section 6. This was a straightforward, direct proof. 
A proof by contradiction follows a different pattern. Suppose that we want 
to prove an assertion A. In a proof by contradiction we begin by assuming that 
assertion A is false. Then we argue using that assumption until we come to a 
contradiction. The contradiction will be the denial of some mathematical fact. For 
example, we might deduce that 0 = 1 or that 5 is an even number. But now what? 
The absolute world of mathematics assumes that every statement is either true or 
false. Thus our original assertion A is either true or false. We assumed that it was 
false and deduced a contradiction. Thus it must be that assertion A is true. 
To begin a proof of assertion A by contradiction, we must formulate the 
negation of A, that is, we must know what it means for A to be false. If assertion 
A is simple enough, its negation is easily formed. We emphasize that exactly one 
of assertion A and its negation is true, but for the moment we don't care which. 
Instead we concentrate on formulating the negation of a given statement A. 
Example 9.1. 
Recall that an integer greater than 1 is called a prime if it cannot be 
written as the product of two smaller positive integers. The assertion that "7,891,011 
is a prime number" is negated by the assertion that "7,891,011 is not a prime 
number" or "There are integers c and d with 1 < c ~ d and c' d = 7,891,011." 
111 

-
-
2 ARITHMETIC 
Question 9.1. 
Write down the negation of each of the following assertions. 
(a) 353 is not a prime number. 
(b) 238 is an even integer. 
In contrast, if assertion A is complicated, care might be required to correctly 
obtain the negation of A. We illustrate with several examples. 
Example 9.2. 
Consider the assertion that "n 3 + 3n2 + 2n is always divisible by 
3." (This can be proved by induction on n: see Exercise 4.17.) What this statement 
says precisely is that for every integer n, the quantity n3 + 3n 2 + 2n is a multiple 
of 3. The negation of this assertion is that there is at least one integer, say m, with 
the property that m3 + 3m2 + 2m is not a multiple of 3. 
In general, an assertion of the form "For every instance, something happens" 
is negated by "There is at least one instance where that something doesn't happen." 
Question 9.2. 
Negate each of the following assertions. 
(a) Every integer greater than one has a prime divisor. 
(b) Every integer of the form 4n + 1 is a prime. 
(c) Every prime greater than 2 is odd. 
Example 9.3. 
The assertion that "For some integer n, n2 + n + 1 is divisible by 
3" can be negated by the assertion that "For every integer n, n2 + n + 1 is not a 
multiple of 3." 
In general, an assertion of the form "There exists at least one instance when 
something happens" is negated by an assertion of the form "for every instance, 
that something doesn't happen." 
Question 9.3. 
Negate each of the following assertions. 
(a) For some integer n, 3n + 1 is a prime number. 
(b) For some integer n, log(n) > n. 
(c) For some integer n, n2 > 2n. 
Many mathematical assertions are of the form "If statement H is true, then 
statement C is true." We frequently use the shorter form IF H, THEN C. Statement 
H is called the hypothesis and statement C is called the conclusion. Some assertions 
that do not appear to be in this form of hypothesis and conclusion can be rephrased 
as such. For example, the assertion "For every integer n, n(n + 1)/2 is an integer" 
can be rephrased, "Ifn is an integer, then n(n + 1)/2 is an integer." Here H represents 
the assertion that n is an integer while C represents the assertion that n(n + 1)/2 
is an integer. 
112 

--
--
--
2:9 2ft #- O(p(n»: PROOF BY CONTRADICTION 
Example 9.4. 
The assertion "If n is prime, then n2 + 1 is even" has as its hypothesis 
that n is prime and as its conclusion that n2 + 1 is even. The negation of this 
assertion is that there exists a prime n with the property that n2 + 1 is not even. 
What is the negation of the assertion 
"IF H, THEN C"? 
The negation of this is the assertion that statement H is true and statement C is 
false. We shorten this to 
"H AND (NOT C)." 
Question 9.4. 
Identify the hypothesis and conclusion of each of the following 
assertions. Then negate each. 
(a) If n is even, then n2 + n + 1 is prime. 
(b) If n2 + n + 1 is prime, then n is even. 
(c) The integer n2 is divisible by 4 whenever n is divisible by 6. 
If we want to construct a proof by contradiction for the assertion "IF H, 
THEN C," we begin by assuming its negation, namely that both statement H is 
true and statement C is false, "H AND (NOT C)." We then work logically until 
we reach the sought-after contradiction. 
To illustrate the technique of proof by contradiction, we present an easy 
version of Theorem 9.1: If r > 2, then rn =1= 0(1). 
Proof. We begin by assuming that "H AND (NOT C)," specifically that r> 2 
and rn = 0(1). From the (first) definition of big oh there is a constant C such 
that for all n 
Since r > 2, 
Now we combine these two inequalities and choose n to be an integer greater than 
C. This yields 
This provides a contradiction, since 2n > n for every integer n. 
o 
We now construct a proof by contradiction for Theorem 9.1. To make the 
arithmetic go a little easier, we shall prove the statement "2n is not O(p(n)) for 
113 

.-
--
--
2 ARITHMETIC 
any polynomial p(n)." This is the same statement as in Theorem 9.1, except that 
r = 2 has been substituted. A similar proof would work for any constant r > 1. 
Proof of Theorem 9.1. 
The negation of the assertion to be proved is "There exists 
a polynomial p with 2n = O(p)." Thus we begin by assuming this fact. By Theorem 
8.1 there is an integer a such that p = O(na), and so by part (iv) of Theorem 8.2 we 
have that 2n = O(na). By definition, there is a constant C with 
for all positive integers n. Taking logarithms of both sides of this inequality, we get 
or 
n ::;; 10g(C) + log (na) 
by properties of log, 
or 
n::;; 10g(C) + a 'log(n) 
by properties of log. 
We divide by log (n) to get 
Since for n :2: 2, log (n) :2: 1, 
_n_ < log (C) + a. 
log(n) - log(n) 
n 
-1 -) ::;; 10g(C) + a. 
og(n 
The right-hand side of this last inequality is a constant number, and by 
Corollary 7.4 the left-hand side is a function that grows arbitrarily large. These 
two statements form a contradiction, as we had hoped. We conclude that 2n is 
not O(p) for any polynomial p. 
0 
In practice, a proof of an "IF H, THEN C" assertion often begins with the 
logically equivalent "IF (NOT C), THEN (NOT H)." We digress briefly to explain 
and begin with an analogy. 
Example 9.5. 
Imagine that you are sitting in an ice cream parlour. There is a 
sign in front of you that says, "Try our scrumptious butterscotch raspberry syrup. 
114 

-
2:9 2ft ¢ O(p(n»: PROOF BY CONTRADICTION 
Only on top of creamy French vanilla ice cream." Before you lose too much 
concentration, let's rephrase this sign in a more mathematically structured way. 
If you want b. r. syrup, then you have to have F. v. ice cream. More simply, IF 
B R SYRUP, THEN F V ICE CREAM. Here the syrup is analogous to the 
mathematical statement H and the truth of H corresponds to your having the 
special syrup. The ice cream is analogous to the mathematical statement C and 
the truth of C corresponds to your having the vanilla. What about the statement 
H AND (NOT C)? This translates into b. r. syrup without F. v. ice cream and 
negates the original sign. 
Example 9.5 (continued). 
Suppose that as you get up to leave the ice cream 
parlour you notice a sign on the back wall that says. "If you don't have our 
French vanilla ice cream, then you can't have our butterscotch raspberry syrup." 
Recall that the sign in the front says IF B R SYRUP, THEN F V ICE CREAM, 
while this one say IF NO F V ICE CREAM, THEN NO B R SYRUP. A little 
reflection will convince you that these signs mean the same thing. 
As suggested by the previous example, given the assertion IF H, THEN C 
we can form what is called its contrapositive by negating both statements and 
reversing their order. Thus the contrapositive of the original 
IF H, THEN C 
(1) 
is the assertion 
IF NOT C, THEN NOT H. 
(2) 
As in the ice cream example a statement and its contrapositive are logically 
equivalent, that is, either both are true or both are false. 
What other possibilities could there be? Well, it might be that the statement 
in (1) is true and the statement in (2) is false, or vice versa. Let's see why neither 
of these cases can happen. First suppose that the statement of line (2) is true and 
the statement of line (1) is false, that is, 
H AND (NOT C) 
(3) 
is a true statement. Combining (3) and (2), we get 
H AND (NOT H), 
which is a contradiction. Next suppose that statement (1) is true and statement (2) 
is false, that is, 
(NOT C) AND NOT(NOT H) 
115 

---
2 ARITHMETIC 
or 
(NOT C) AND H 
(4) 
is a true statement. Combining statements (1) and (4) yields 
(NOT C) AND C, 
another contradiction. We conclude that statements (1) and (2) are either both 
true or both false. In other words, they are logically equivalent. 
Example 9.6. 
Recall that a function is one-to-one if whenever d =P d', then fed) =P 
fed'). The condition that specifies this one-to-one property is of the form IF H, 
THEN C, where H is the statement "d =P d'" and C is the statement "f(d) =P f(d')." 
Thus this property is the same as the property IF NOT C, THEN NOT H. In 
other words, a function is one-to-one if whenever fed) = fed'), then d = d'. This 
second, but equivalent, definition is often easier to check, since working with 
equalities can be easier than with inequalities. 
Given an assertion IF A, THEN B, we can also form its converse, namely 
the assertion IF B, THEN A. In the following example we illustrate that the truth 
of a particular assertion does not determine the truth of the converse. 
Example 9.7. 
The ice cream parlour does allow a customer to have plain French 
vanilla ice cream, that is, B is true but A is false. 
Question 9.5. 
Form the converse and the contrapositive of each of the assertions 
from the preceding question as well as Lemma 7.1 and Theorem 7.2. 
Sometimes it is the case that both an assertion and its converse are true, that 
is, both "IF A, THEN B" and "IF B, THEN A" are true. In that event we say 
that A is true if and only if B is true, which is abbreviated A IFF B. We shall 
see examples of this sort of assertion in Chapter 4. 
EXERCISES FOR SECTION 9 
1. Write out a detailed proof that 4n is not O(p) for any polynomial p. 
2. Regardless of the truth or falsehood of the following, write the negation of 
the following assertions. 
(a) 14 is even. 
(b) 6 is prime. 
(c) 1 + 2 + ... + n = n(n + 1)/2. 
116 

-
-
-
2:9 2""# O(p(n»: PROOF BY CONTRADICTION 
(d) There is an integer divisible by 3 and by 7. 
(e) For every integer n, n(n + 1)/2 is also an integer. 
(f) Every set has more 2-subsets than I-subsets. 
(g) Every even number has an even number of Is in its binary representation. 
(h) If f(n) = O(g(n)), then f(n) :::; g(n). 
(i) There is a set that is larger than its complement. 
(j) If x 2 is odd, then x 6 is odd. 
(k) If x 6 is divisible by 8, then x is divisible by 2. 
(I) 1728 is a sum of four cubes. 
(m) Every even composite number is the sum of two primes. 
3. Determine for which of the following functions g(n) it is true that 2n = O(g(n)). 
(a) g(n) = n2 , (b) g(n) = 2n, (c) g(n) = n10, (d) g(n) = lon, (e) g(n) = 2m, 
(f) g(n) = 21og (n), and (g) g(n) = 2(n
2
). 
4. For each of the following statements identify the hypothesis H and the con-
clusion C, rewriting the statements if necessary: 
(a) If n ::::: 2, then n :::; n2 -
2. 
(b) A set with n elements has 2n - 1 even subsets. 
(c) x" can be calculated with exactly log(n) + 1 multiplications when n is a 
power of 2. 
(d) 1 + 3 + ... + (2r -
1) = r2. 
(e) All quadratic polynomials are O(n2). 
(f) Every even composite number is the sum of two primes. 
(g) Every even number has an even number of Is in its binary representation. 
S. Write the negation, the converse, and the contrapositive of each statement in 
the preceding problem. 
6. (Another Analogy) Many serious hikers have a cardinal principle that they 
won't hike if they aren't wearing two pairs of socks. Break this principle up 
into statements Hand C and rephrase it in the IF H, THEN C paradigm. 
Form the negation. 
7. Form the contrapositive and the converse of the hikers and socks assertion 
that you created in the preceding exercise. 
8. Each of the following allegations can be put into the form IF H, THEN C. 
After identifying the statements that are Hand C, form the converse and the 
contrapositive of each. 
(a) If n is even, then n/2 is an integer. 
(b) If n = p . q (where 1 < p, q < n), then n is not a prime. 
(c) If r is odd and s is odd, then r + s is odd. 
(d) x 2 is divisible by 2. provided that x is divisible by 2. 
(e) x an odd integer implies (x + 1)/2 an odd integer. 
For each statement above, decide whether it is true or false. Do the same with 
the converses and the contra positives. 
117 

-
-
2 ARITHMETIC 
9. Identify the IFF statements in the preceding problem, that is, those allegations 
for which both the statement and the converse are true. 
10. Beginning with the assertion, "If r > 2, then rn = 0(1}," use definition 2 of big 
oh to reach a contradiction. 
11. Prove Theorem 9.1 using definition 2 of big oh. 
2:10 GOOD AND BAD ALGORITHMS 
We have introduced a variety of algorithms, some correct, some incorrect, some 
efficient, some inefficient, some transparent, some quite complex. We have also 
begun to talk about what is known as the space and time complexity of an 
algorithm, that is, the number of variable memories needed and the time needed 
to run the algorithm (or at least an upper bound on the number of key operations 
like multiplication). In this section we shall formulate what is meant by a good 
algorithm. 
Our description of "good" will depend upon the efficiency of the algorithm, 
but we must always remember that an algorithm must be correct to be "good" in 
any sense of the word. We can easily write efficient algorithms, like the following. 
Algorithm SPEEDY 
STEP 1. Stop. 
This is the world's shortest algorithm and in that sense the most efficient; however, 
this algorithm has no relevance to any problem in the real world! 
Space resources are important. We need enough space to read in the problem 
addressed by the algorithm, and we shall try to be conservative with additional 
memory needed for new variables. For example, in Section 2.1 we saw how we 
could interchange the values of two variables without using an additional memory 
location. However, our first priority will be to minimize running time and then 
secondly to minimize storage. The time requirement is a parameter commonly 
studied and one that leads to a rich and important theory in computer science. 
We have already stated that we do not want to analyze time in terms of specific 
computers or programming languages. We want a procedure for comparing two 
algorithms that (correctly) solve the same problem. But we want a fair com-
parison. For example, if we run algorithm EXPONENT with x = 2 and n = 3, it 
certainly would be quicker than algorithm FASTEXP with x = 10,000,000 and 
. n = 123,456,789, and yet we have claimed that the latter algorithm is faster or 
more efficient. Or think of just one algorithm. Of course, it runs faster when we 
enter few and small pieces of data rather than larger ones. For example, we can 
much more quickly list all subsets of a 2-set than of a 20-set. 
Thus we must compare execution times on the same data set or at least on 
data sets of the same cardinality. We do this by introducing a parameter that 
118 

-
2:10 GOOD AND BAD ALGORITHMS 
measures the size of the data set. How we measure this size depends upon the 
problem at hand. For instance, we could describe the size of the data for the 
algorithms DtoB and BtoD by stating the number of digits in the given decimal 
or binary number. In SUBSET we could describe the size of the problem by giving 
the size of the set all of whose subsets we want to list. In EXPONENT and 
F ASTEXP we could specify n, the power to which we are raising x, or the number 
of bits needed to store n. 
Typically, we shall begin by supposing that the data or the input to the algo-
rithm is of size n. This may mean that we have n bits of information or that the 
integer n is the crucial variable. Then we shall estimate the time of running the 
algorithm in terms of the variable n. Often we shall denote the time as some func-
tion fen) that counts the number of multiplications or the number of comparisons 
or the number of some time-consuming operation. This function will be known 
as the (time) complexity of the algorithm. Sometimes we shall be able to determine 
fen) explicitly; other times we shall make a worst-case analysis and get an upper 
bound on fen). Most frequently, we shall be happy to determine that f = O(g) for 
some hice function g. 
Our goal is simplistic: We want to divide correct algorithms into one pile 
called "good" and another pile called "bad." Just as philosophers who study la~­
guage arrive at the meaning of the word good through comparisons, so shall we. 
Suppose that we have two correct algorithms to solve a particular problem, say 
A and B. Let a(n) denote the complexity of A and ben) denote the complexity of 
B. Assume that we know a = O(f) and b = O(g). [Of course, if we know a(n) and 
ben) explicitly we can compare them directly.] 
Definition. If an algorithm A has complexity a(n) = O(f(n)) and an algorithm B 
has complexity ben) = O(g(n)), we say that A "appears to be" as efficient as B if 
f = O(g). If, in addition, g = O(f) we say that A "appears to be" equivalent to B. 
Otherwise, iff = O(g) and g is not O(f) we say that A "appears to be" more efficient 
than B. 
In practice, we shall replace "appears to be" with "is" in the above definitions. 
You might think that our definition is overly wishy-washy; however, restraint is 
forced on us by the big oh comparisons. The problem is that it might be difficult 
to bound the complexity of one or both of the algorithms in question. For example, 
we might be able to prove that a(n) = O(n3) and that ben) = O(n4). In that instance 
we would say that A appears to be more efficient than B, since n3 = O(n4) and 
n4 is not O(n3). In reality, it might be the case that a(n) = nll/4 while ben) = n5 /2 
in which case B is actually more efficient than A. Thus the quality of our com-
parison depends on how good a big oh estimate we have. 
Example 10.1. Suppose that the time complexity function of algorithm A is given 
by a(n) = n2 - 3n + 6 and that of algorithm B by ben) = n + 2. Then A is a O(n2) 
algorithm while B is a O(n) algorithm. In this case we would naturally say that B 
is more efficient than A. 
119 

-
-
-
2 ARITHMETIC 
Thus we measure the efficiency of algorithms using the hierarchy of functions 
developed in the preceding sections. An algorithm with complexity ni will be more 
efficient than an algorithm with complexity ni if and only if i < j. An n log (n) algo-
rithm is more efficient than a quadratic algorithm but less efficient than a linear 
algorithm, since for n large enough, 
n ~ n log (n) ~ n.,fo ~ n2 . 
Let's go back to our original question of what constitutes a good algorithm. 
Of course, if we have two different algorithms to solve the same problem, then we 
shall consider one better if it is more efficient in the sense described above. But 
we make a global judgment now about what is known in computer science circles 
as a "good" algorithm. 
Definition. 
Suppose that A is a correct algorithm with complexity function a(n). 
Then A is called good (or polynomial) if there exists a polynomial pen) with a = O(p). 
A is called bad if a is not O(p) for any polynomial p. If a(n) 2 rn for some constant 
r (with r > 1), then A is called exponential. A problem that does not have a good 
algorithmic solution is called intractable. 
There are some important ideas here. An algorithm will be called good regard-
less of what polynomial gives the bound on a(n). It might be that the polynomial 
is huge, and so the algorithm takes a long time to run. That would not be a very 
"good" situation from the point of view of efficiency, but in theory at least the 
situation is not as bad as having a(n) = 2n, an exponential function. 
Now we see the relevance of Theorem 9.1. It states that rn #- O(p(n)) for any 
polynomial p(n). Thus if we find an algorithm with complexity 2n or 3n or even 
1.000005n, this is an exponential algorithm, not a polynomial one. 
For example, look at the algorithm SUBSET. Our input to the algorithm is 
a set of n elements, and we want as output all 2n subsets. The size of the input 
data is n. We systematically create and list all subsets of the n-set. Since there are 
2n subsets, our list making will need 2n steps and the complexity will be at least 
2n, an exponential function. Thus SUBSET is an exponential algorithm, and the 
problem of listing all subsets of an n-set is intractable. 
But why do we make such a harsh judgment about an exponential algorithm? 
As we all know from the news media, exponential growth is considered to be very 
fast growth into large numbers, perhaps dangerously out of control when related 
to, for example, population. Is this also the case for algorithms? Does this mean 
that exponential algorithms are too large or take too long? Surely, modern com-
puters can handle large amounts of calculation extraordinarily quickly. 
Let's do some arithmetic that is specific to an IBM PC but that would be 
approximately the same for any microcomputer. The PC can perform about 17,800 
single-digit multiplications in a minute. Suppose that we compare seven algorithms 
that do multiplications and whose complexities are given by the functions log (n), 
120 

-
-
-
2:10 GOOD AND BAD ALGORITHMS 
j;t, n, n2, n3, 2n, and Ion. What size problems could we reasonably solve on the 
PC? Table 2.9 shows various values of n, the seven complexity functions, and 
roughly the amount of time needed to run the algorithms. (We stop filling in the 
table once the numbers become inhumanly large!) 
Table 2.9 
n 
log(n) 
..j~ 
n 
n2 
n3 
2" 
10" 
8 
0.01 sec 
0.01 sec 
0.027 sec 
0.216 sec 
1.73 sec 
0.863 sec 
3.9 days 
16 
0.013 sec 
0.013 sec 
0.054 sec 
0.863 sec 
13.8 sec 
3.7 min 
10,689 cent. 
24 
0.015 sec 
0.017 sec 
0.081 sec 
1.94 sec 
46.6 sec 
15.7 hr 
32 
0.017 sec 
0.019 sec 
0.108 sec 
3.45 sec 
1.84 min 
168 days 
64 
0.02 sec 
0.027 sec 
0.216 sec 
13.8 sec 
14.7 min 
19,717,160 
cent. 
128 
0.024 sec 
0.038 sec 
0.43 sec 
55 sec 
2 hr 
256 
0.027 sec 
0.054 sec 
0.86 sec 
3.7 min 
16 hr 
Thus we see that we will be in trouble as soon as we have at least 24 pieces 
of data on which we must run an exponential algorithm. Of course, we could 
switch over to minicomputers, which typically run about 100 times as fast, but 
our problem size still demands too much computing with data of size 32 or larger. 
Thus there really is a problem when we must do an exponential amount of com-
puting on even a moderate amount of material. 
EXERCISES 'FOR SECTION 10 
1. Suppose that algorithm A has complexity function a(n) and algorithm B has 
complexity function b(n). In each of the following cases decide whether the 
algorithms are equivalent or if not, which is more efficient. 
(i) a(n) = 36. 
(ii) a(n) = n2 . 
(iii) a(n) = n2 . 
(iv) a(n) = 2n2 . 
(v) a(n) = n2 + 2n. 
ben) = 2n -
10. 
ben) = n. 
ben) = n - 6. 
ben) = 3n2 . 
ben) = n2 + n. 
2. Explain why nn # O(rn) for any constant r. 
3. Find a function that is not O(nn). 
4. In Exercise 1.7.6 you designed an algorithm that lists all n(n -
1)/2 subsets of 
size 2 of a set A containing n elements. Suppose that you count as one step 
the formation and output of a single subset. Is your algorithm good or bad? 
121 

-
-
-
2 ARITHMETIC 
5. Suppose that A contains n objects and we have an algorithm that outputs all 
elements of the Cartesian product An. Counting one step as the formation and 
output of one element of the Cartesian product, is this algorithm good or 
exponential? 
6. Show that the algorithm to settle the Satisfiability Problem for a Boolean 
function (see Section 1.10), which consists of trying all possibilities, is bad. 
2:11 ANOTHER LOOK BACK 
By far the most important ideas in this chapter have been the proof techniques of 
induction and contradiction. Their use permeates all of mathematics and computer 
science. Indeed the practitioners of these disciplines regularly apply these methods 
without acknowledgment. We have met typical instances of proofs using these 
techniques. 
Induction proofs work well on set theory problems, on summation formulas, 
and on algorithmic problems, that is, in proving that an algorithm does what it is 
supposed to do in all cases. The Principle of Induction gives us a three-step format 
that allows us to set up and attack problems in a straightforward way. This doesn't 
mean that proof by induction will always be easy and automatic. We shall still 
need to think carefully and creatively about each instance. 
Proofs by contradiction arise naturally for statements of the form, "Object A 
does not have property P." Often we can begin with the assumption that A has 
property P; do some algebra or a logicai argument, and arrive at a contradiction. 
Often some experimentation is needed to find a reasonable argument, leading to, 
say, 0 = 1. Probably, the best advice for both kinds of proofs is to study the ex-
amples and theorems in the text and to try to imitate these in the exercises. 
This chapter also presents the central computer science and mathematical 
ideas about the analysis of algorithms. We now have a sequence of tasks to per-
form when we look for an algorithmic solution to a problem. Not only must we 
come up with the algorithm, but we must also prove that it is correct in all cases 
and we must analyze its time and space requirements. The worst-case analysis is 
commonly used, since we can often estimate an upper bound on the maximum 
number of the most time-consuming steps. Notice that these upper bounds may 
be crude, too large, and it may be that our algorithm works more efficiently. 
Of course, even if we know an exact analysis of the number of steps performed, 
we have no guarantee th'at there isn't a faster algorithm. For example, how do 
we know that computing xn can't be done by an algorithm faster than F ASTEXP, 
, that is, by an algorithm that is faster than logarithmic? We haven't discussed this 
issue at all. There are other ways to analyze algorithms. For example, we might 
ask for typical or average-case behavior. Or we might be more demanding and 
count all kinds of steps: multiplication, division, addition, subtraction, com pari-
122 

-
-
-
SUPPLEMENTARY EXERCISES FOR CHAPTER 2 
sons, assignment statements, and so on. Such details are suitable for more advanced 
courses in theoretical computer science. 
Most algorithms presented in the computer science literature include a dis-
cussion of worst-case behavior, and this discussion inevitably entails use of the 
big ohjargon. The big oh definitions are subtle yet important; it is well worth doing 
lots of exercises on this concept. It is the primary way that computer scientists and 
mathematicians distinguish between the quality of algorithms. There are a number 
of important problems (including searching and sorting, which we will consider in 
Chapter 6, and the fast Fourier transform, which we will not consider) that have 
naive algorithms that are O(n2) and better algorithms that are O(n log (n)). The 
existence of the better algorithms greatly expands the size of the problems that 
are feasible to solve. One further satisfactory point about the O(n log (n)) sorting 
algorithms is that we can also prove that every algorithm (of a certain type) that 
solves a sorting problem must use at least cn log (n) steps for some constant c. That 
tells us that we've found essentially the very best algorithm. 
In the SUBSET problem and algorithm we realized that every algorithm must 
form and list all 2" subsets, and so is necessarily exponential. We have a lower 
bound on the number of steps needed; often it is difficult to obtain such lower 
bounds. The distinction between polynomial and exponential algorithms is the 
most actively researched area within computer science. We shall soon see many 
problems for which every known algorithm is exponential, but no one has proved 
that there is no polynomial algorithm. (The Satisfiability Problem of Section 1.10 
is one such example.) Thus upper bounds, but not lower bounds, are known, and 
it is not yet known whether the problems are inherently intractable. This leads 
to the heart of some fascinating, unsolved problems in computer science. 
SUPPLEMENTARY EXERCISES FOR CHAPTER 2 
1. Show that if there is a counterexample to Fermat's Last Theorem, then there 
exists a counterexample in which no pair of the integers x, y, and z has a 
common factor. Use this fact to show how large z must be in any counter-
example. 
2. It was claimed that Fermat's Last Theorem is known to be true for n ::;; 125,080. 
From the previous problem you know that z can't be 1 (for instance). Suppose 
that you wanted to write down the digits in this hypothesized counterexample. 
If you could write 100 digits a minute for the rest of your life (with no resting 
time), would you be able to transcribe this example? 
3. (a) The distinguished mathematician Gauss was a child prodigy. Legend 
has it that at the age of 10 he was asked to add the integers 81,297 + 
81,495 + 81,693 + ... + 100,899. Almost immediately he wrote one num-
ber, 9,109,800, on his slate. Was he correct? 
123 

-
-
-
2 ARITHMETIC 
(b) Let a and b be constants. Show that the sum of the arithmetic progression 
a + (a + b) + (a + 2b) + ... + (a + nb) is given by (n + l)(a + nb/2). 
4. Prove by induction that if b is a number such that 1 ~ b ~ n(n + 1)/2, then 
there is a subset of {I, 2, ... ,n} whose sum equals b. 
5. Prove by induction that if a =P b, then 
an + an - 1 . b + ... + aj · bn - j + ... + bn 
an+ 1 _ bn+ 1 
a-b 
6. Consider the following algorithm: 
STEP 1. Input r, s {r and s positive integers} 
STEP 2. While s > ° do 
Begin 
STEP 3. r: = r - s 
STEP 4. s: = s - 1 
End {step 2} 
STEP 5. Output r, then stop. 
(a) Trace through this algorithm when 12 and 3 are input for rand s, 
respectively. 
(b) Show that this algorithm must terminate no matter what positive integer 
values of rand s are input. 
(c) What is the output in terms of rand s? 
7. Given the sum t + 2(t -
1) + ... + j(t - j) + ... + t, guess a formula in terms 
of t for this sum. Use induction to prove that your guess is correct. 
8. Determine the sums: 12,22 - 12,32 - 22 + 12, and 42 - 32 + 22 -
12. Then 
deduce and prove a general formula for the sum 
9. Your calculator probably has logarithms to the base 10 or to the base e. 
Here's how to change from base 10, written 10glO (x), to base 2, log (x): 
. 
10glO(X) 
log(x) = 10glO(2) = 3.321910g10 (x). 
Prove the above identity. [Hint: Begin with x = iog(X).] 
10. Find a formula for changing natural logarithms, logs to the base e, to base 
2 logarithms. Justify your formula. 
124 

-
-
-
SUPPLEMENTARY EXERCISES FOR CHAPTER 2 
11. Count the number of comparisons made in the algorithm MAX of Exercise 
4.12 and in BUBBLES in 4.13. Which is more efficient? Count the number 
of assignment statements in the two algorithms. Which is more efficient from 
the assignment point of view? Suppose that an assignment can be done in 1 
second and a comparison in 2 seconds, then which algorithm is more efficient? 
12. Suppose that you have a computer that can only perform addition, subtrac-
tion, and multiplication. Write an algorithm that upon input x, a positive real 
number, calculates and outputs L JX J. 
13. Suppose that you have a computer that can perform addition, subtraction, 
and multiplication, but not division. Design an algorithm that upon input of 
real numbers x and y (with x =I- 0) calculates and outputs Ly/x J. 
14. Show that if f = O(g), then 2f = 0(2g). Is the converse true? Give a proof or 
counterexample. 
15. Here is one of the oldest and most famous results in all of mathematics. 
Theorem. There are infinitely many primes. 
(a) What is the negation of this theorem? 
(b) If the theorem is false, suppose that t equals one plus the product of all 
the primes. Is t prime? 
(c) Is the t you formed in part (b) divisible by 2? 3? 5? Any prime? 
(d) Prove the Theorem by contradiction. 
16. Every positive integer can be expressed in the form 3n, 3n + 1, or 3n + 2 for 
some integer n. 
(a) Explain why every prime number greater than 3 is of the form 3n + 1 or 
3n + 2. 
(b) Explain why a number of the form 3n + 2 must have a prime divisor of 
the form 3n + 2. 
(c) Prove that there are infinitely many primes of the form 3n + 2. [Hint: 
Suppose that Pl'PZ" .. ,Pk are all the primes of the form 3n + 2. Then 
consider 3(Pl . Pz ..... Pk) + 2.] 
17. Here we prove that (x + 1)z does not equal xZ + 2x + 1. The proof is by 
contradiction, so we begin by assuming the negation: 
(x + 1)z = X Z + 2x + 1. 
We subtract 2x + 1 from both sides to obtain 
Next we subtract x(2x + 1) to get 
(x + 1)z - (2x + 1) - x(2x + 1) = x 2 -
x(2x + 1), 
125 

-
--
-
2 ARITHMETIC 
which by factoring becomes 
(x + 1)2 -
(x + 1)(2x + 1) = X 2 -
x(2x + 1). 
Next we add (2x + 1)2/4 to both sides: 
(x + 1)2 - (x + 1)(2x + 1) + (2x + 1f/4 
= x 2 -
x(2x + 1) + (2x + 1)2/4. 
Since both sides are perfect squares, we can factor them into 
[ 
1) 
(2x + 1)J2 _ [ 
(2x + 1)J2 
(x + 
-
-
x -
. 
2 
2 
Taking square roots of both sides, we obtain 
( 
(2x + 1) 
(2x + 1) 
x + 1) -
2 
= x -
2 
(x + 1) = x 
1 = O. 
This contradiction forces us to conclude that (x + 1)2 does not equal 
x2 + 2x + 1. What is wrong with this proof? 
18. Prove Theorem 9.1 for arbitrary r > 1. 
19. There are functions f(n) such that f(n) i= O(p(n)) for any polynomial p(n) and 
f(n) < rn for every positive r and sufficiently large n. Find such a function. 
20. Here is another exponentiation algorithm. 
126 
STEP O. 
Input x and m {m a positive integer} 
STEP 1-6. Algorithm DtoB {assume that the output is in string s, a U + 1)-
bit binary number} 
STEP 7. 
STEP 8. 
STEP 10. 
ans:= x 
For i:= (j -
1) down to 0 do 
STEP 9. 
If the ith entry of s is 1, 
then set ans : = x * ans * ans 
Otherwise, set ans : = ans * ans 
Output ans and stop. 
[COMMENT: "For i : = (j -
1) down to 0 do" means that i successively takes on 
the values (j - 1), (j - 2), ... ,0 and for each value performs step 9.] Run this 
algorithm on some data to check that it correctly calculates xm for m, a positive 
integer. Then compare the efficiency of this algorithm with that of F ASTEXP. 

-
-
-
3 
ARITHMETIC OF SETS 
3:1 INTRODUCTION 
College Hall has decided to automate the internal mail system. Although the 
administrators communicate easily by electronic mail, they also need to circulate 
documents, such as memos, reports, and minutes of meetings, among their offices. 
They have hired an outside consultant who suggests that the flow of paper will 
be improved by the use of robotlikemail carts, called Mailmobiles. These carts 
can be programmed to travel through office corridors, to pause at designated 
points (or if the bumper hits anything!), and to stop at a location where they 
can be reprogrammed for another journey. Although most college administration 
buildings are irregularly shaped, let's think about a simple floor plan, the rec-
tangular grid shown in Figure 3.1. We have marked the Mail Room with M and 
the President's Office with P. Each line segment indicates a corridor, and the 
corridor intersections are possible stopping points for the mailmobile. 
Here are some questions that occur to the consultant while planning for the 
mailmobile. 
1. A shortest trip from M to P requires the traversal of 11 corridors. In how many 
different ways can the mailmobile make a trip of shortest length from M to P? 
2. Is it possible to visit every stopping point exactly once on a trip (necessarily 
of longer length) from M to P? If so, in how many different ways can such a 
trip be planned? 
3. Is it possible to travel along every corridor exactly once on a trip from M to 
P? If so, in how many different ways can such a trip be planned? 
127 

-
--
-
3 ARITHMETIC OF SETS 
P 
M 
Figure 3.1 
A 6 x 5 rectangular grid. 
Question 1.1. 
Answer the preceding three questions on the 3 x 2 rectangular grid 
in Figure 3.2. 
1 I 
I I 
Figure 3.2 
A 3 x 2 rectangular grid. 
In this chapter we focus on the first of the three questions posed above. The 
second and third questions will be studied in depth in Chapter 8. 
Let's consider some of the shortest trips between M and P in Figure 3.1. Such 
a trip is shortest if and only if it covers exactly 11 corridors. Think of Figure 3.1 
as being a map, oriented with north at the top of the figure. Then we could describe 
a shortest trip from M to P, for example, by 
E,E,E,E,E,E,N,N,N,N,N, 
where N stands for moving north along a corridor and E for moving east. Two 
other shortest trips are 
E,E,E,E,E,N,E,N,N,N,N, 
and 
N,N,N,N,E,E,E,E,E,E,N. 
In fact, to move from M to P in a shortest path we must travel six units east and 
five units north. Furthermore if we write down any sequence of five Ns and six Es, 
then these give instructions for a shortest path from M to P. 
128 

-
--
3:1 INTRODUCTION 
Question 1.2. 
Why does a sequence of five Ns and six Es always stay inside the 
rectangle of Figure 3.1? Why does such a sequence describe a path that always 
reaches P, starting at M? Describe all sequences of Ns and Es that correspond 
with a trip from M to P in Figure 3.2. 
One way to describe these shortest paths from M to P in Figure 3.1 is as a 
subset of {N, E} 11 (recall the Cartesian product from Chapter 1). Specifically, the 
set of all shortest paths corresponds with the subset consisting of all of the 11-tuples 
that contain exactly five Ns. 
Has the introduction of the Ns and Es helped us count the number of shortest 
paths from M to P or to find these paths? So far, not at all! We have only found 
another way to look at the problem. We shall construct an algorithm to list all 
suitable Nand E sequences; however, there is a simple formula for the number 
of shortest paths, to which the work in this chapter will lead. 
The diagrams in Figures 3.1 and 3.2, although they may not be representative 
of building or office floor plans, are ones that arise repeatedly in mathematics and 
computer science. A grid that has (m + 1) vertical lines and (n + 1) horizontal lines 
is known as an m x n rectangular grid; a picture of the m x n grid is given in 
Figure 3.3. This grid might represent streets in a city (like New York); it might 
represent the intricate connections on layers of silicon on a computer chip; or it 
might represent the pixels on a computer monitor. Thus this configuration is 
studied for a variety of reasons. 
n-:I 
1 
1 
=R 
:1 
I 
I 
B 
M 
1 
2 
m-l 
m 
Figure 3.3 
Question 1.3. 
Estimate the number of shortest paths from M to P in Figure 3.1: 
Choose the interval from the following list that most likely contains the correct 
number. 
(a) Less than 25. 
(b) Between 25 and 50. 
129 

-
-
-
3 ARITHMETIC OF SETS 
(c) Between 50 and 100. 
(d) Between 100 and 250. 
(e) Between 250 and 500. 
(f) Between 500 and 1000. 
(g) Between 1000 and 1500. 
(h) More than 1500. 
EXERCISES FOR SECTION 1 
1. Here are four rectangular grids. For each draw all possible shortest paths 
from M to P. 
r-----~-------p 
~-----.-------p 
M~I 
(a) 2 x 2 grid. 
M-------'------~ 
(b) 
2 x 3 grid. 
,----,----r--- p 
r------r----r---r---p 
M--'--~---' 
M---'----'----.1.----' 
(c) 
3 x 3 grid. 
(d) 4 x 3 grid. 
2. For each of the four grids in Exercise 1, describe a shortest path from M to 
P in terms of Es and Ns. 
3. Among the following grids, which has the largest number of shortest paths 
from M to P? 1 x 5, 2 x 4, 3 x 3, 4 x 2, and 5 x l. 
4. EXl?lain why the number of shortest paths from M to P in an m x n grid is 
the,same as the number of shortest paths from M to P in an n x m grid. 
5. What are the dimensions of the rectangular grid on which the sequence 
N, N, E, E, N, E, E, N, N, E, N, N, E gives a path from M to P? 
6. Check that the number of sequences of Ns and Es of length six containing 
exactly two Ns equals the number of six-digit binary numbers with exactly 
130 

-
-
-
3:2 BINOMIAL COEFFICIENTS 
two ones. Is the same result true if there are three Ns and if the binary 
numbers have three ones? Is the same true if the sixes in these statements are 
all changed to sevens? Explain why. 
7. In the four grids of Exercise 1, find a path from M to P that passes through 
every intersection point exactly once, or else deduce that there is no such path. 
In which grids is there more than one such path? 
8. Make a conjecture about what values of m and n are such that an m x n grid 
contains a path from M to P that passes through every intersection point 
exactly once. 
9. Explain why in the grids of Exercise 1 it is impossible to travel from M to P 
traveling along every corridor (or line segment) exactly once. Are there values 
of m and n for which such a path exists? 
10. Show that an m x n rectangular grid with M at the lower left corner and P 
at the upper right corner contains no more than 2m +n shortest paths from 
M to P. When n = 1, determine exactly how many shortest paths there are 
from M to P. 
3:2 BINOMIAL COEFFICIENTS 
This section introduces the important factorial function and a counting device from 
the seventeenth century known as Pascal's triangle. With theSe we can readily cal-
culate the number of shortest paths from the lower left-hand corner to the upper 
right-hand corner of any m x n grid. In addition, the factorial function and Pascal's 
triangle lead to the study of subsets of sets and related algorithms. 
We return to rectangular grids. Figure 3.4 presents the m x n grid with each 
point in the grid labeled with its Cartesian coordinates. The point M is placed at 
the origin (0,0) and P lies at the point (m, n). 
Next we define a function f whose domain is the set of points of the grid; 
let f(i,j) equal the number of shortest paths from M = (0,0) to (i,j). Although we 
were originally looking only for the value f(P), we'll find this number using the 
other function values. 
Let's figure out some values of f. We say that f(O, 0) = 1 because there is only 
one shortest way to travel from M to M, that is, by doing nothing! Now f(l, 0) = 
f(O, 1) = 1, and f(l, 1) = 2, since we can reach (1,1) via (0,1) or (1,0). 
Question 2.1. (a) Show thatf(O, 2) = f(2, 0) = 1,J(1, 2) = f(2, 1) = 3, andf(2, 2) = 6. 
(b) Determine the values of f(O, 3), f(l, 3),j(2, 3), f(3, 2), f(3, 1), and f(3, 0). 
Question 2.2. 
Explain why in the m x n rectangular grid f(i,O) = 1 for i = 
0, 1, ... ,m and f(O,j) = 1 for j = 0, 1, ... ,n. 
131 

-
-
3 ARITHMETIC OF SETS 
(0, n)--(l, n)--(2, n)--
1 
I 
I 
(0, n - 1) - (1, n - I)--
I 
I 
I 
I 
I 
(0,3)--(1,3)--(2,3)--
I 
I 
I 
(0,2)--(1,2)--(2,2)--
I 
I 
I 
(0,1)--(1,1)--(2, I)--
I 
I 
I 
(0,0)--(1,0)--(2,0)--
=M 
Figure 3.4 An m x n grid. 
(m-l, n)--(m, n) = P 
I 
I 
(m-l, n-l)-(m, n-l) 
I 
I 
I 
--(m, 3) 
I 
--(m,2) 
I 
--(m, l) 
I 
--(m, 0) 
Consider a point (i,j) some place out in the middle of the grid shown in 
Figure 3.5. There are exactly two ways to arrive at (i,j) along a shortest path. 
Either we approach it from the point to the left (i - l,j) or from the point below 
(i,j -
1). Thus the number of shortest paths from (0,0) to (i,j) is the number of 
shortest paths to (i -
l,j) plus the number of shortest paths to (i,j -
1), that is, 
f(i,j) = f(i - l,j) + f(i,j -
1). 
I 
I 
(i-1,j)----(i,j)------1 
I 
I 
(i-l,j-l) 
(i,j-l)----~ 
Figure 3.5 
This relationship provides a method for calculating all the f values in a given 
grid. We know from Question 2.2 that f(i, 0) = f(O,j) = 1 for all i and j. From these 
initial values we can fill in the remaining values, moving from the lower left up to 
132 

-
-
-
3:2 BINOMIAL COEFFICIENTS 
the upper right: 
f(I,I) =f(O,I) +f(I,O) = 1 + 1 =2 
f(I,2) = f(0,2) + f(1, 1) = 1 + 2 = 3 
f(2, 1) = f(l, 1) + f(2, 0) = 2 + 1 = 3 
f(l, 3) = f(O, 3) + f(l, 2) = 1 + 3 = 4 
f(2,2) = f(I,2) + f(2, 1) = 3 + 3 = 6, 
and so on. Eventually, f(m, n) can be computed as the sum of f(m -
1, n) and 
f(m,n -
1). 
Question 2.3. 
Show that f(3, 3) = 20 and that f(4, 2) = 15. 
This process would be tedious on the 6 x 5 grid and hopeless for much larger 
grids. We haven't yet found the promised simple formula for the number of shortest 
paths. 
We now uncover Pascal's famous triangle. Suppose that we redraw Figure 3.4, 
omitting the coordinate labels and the line segments and writing instead the values 
off at each point [see Figure 3.6{a)]. Next we rotate the figure 135° (= 3n/4 radians) 
clockwise so that M is at the top and P at the bottom. Then Pascal's triangle 
emerges as shown in Figure 3.6(b). A larger version appears in Figure 3.7. 
1 4 
10 20 
1 
1 
1 3 
6 
10 
1 
2 
1 
1 2 
3 
4 
1 3 3 
1 
1 
1 
1 
1 
1 4 
6 
4 
1 
(aj 
(b) 
Figure 3.6 Pascal's triangle 
The numbers in Pascal's triangle are organized by rows; numbers on the kth 
horizontal row (starting with k = 0) are said to form the kth row of Pascal's tri-
angle. For example, here are the first rows: 
the Oth row: 
1, 
the 1st row: 
1, 
the 2nd row: 
2 
1, 
the 3rd row: 
3 3 
1, 
133 

-
-
-
3 ARITHMETIC OF SETS 
and 
the 4th row: 
1 4 6 4 
1. 
Exactly as in the shortest path problem (once we account for the rotation), each 
row of Pascal's triangle begins and ends with a 1, and in the middle the entries 
are the sum of the two numbers immediately above. 
Question 2.4. Calculate the 5th row of Pascal's triangle. Then determine the co-
ordinates of all points in the m x n grid that end up, after the 135° rotation, on the 
5th row of Pascal's triangle. Compare their f values with the entries of the 5th row. 
We want to determine explicitly the numbers that lie on the kth row of Pascal's 
triangle for an arbitrary positive integer k. These in turn will give us the f values 
needed in the shortest path problem. To do this, we introduce the factorial function: 
For each natural number n, we define n!, read "n factorial," by 
n! = n(n - 1)(n - 2) ... 3 . 2 . 1 
if n is positive, 
and 
O! = 1. 
The definition of O! may be surprising, but as you'll see, it's useful to have O! de-
fined in this way. From the definition we see that 
1! = 1, 
2! = 2· 1 = 2, 
and 3! = 3·2· 1 = 6. 
Question 2.5. Calculate n! for n = 4,5,6, 7, and 8. Then find a value of n such 
that n! is greater than 1,000,000. 
Notice that the values of n! grow rapidly as n increases. 
Here's a useful property of n factorial that follows immediately from the 
definition: 
n! = n[(n - 1)!]. 
Now we can solve many mysteries of Pascal's triangle and of shortest paths 
within a grid. We define the bino~ial coefficients e). read "k choose i" or "k above 
i': or "k pick i" fqr all natural numbers k and i with 0 :::;; i :::;; k by 
( k) 
k! 
i = i!(k - i)! . 
134 

3:2 BINOMIAL COEFFICIENTS 
-
2 
3 
3 
4 
6 
4 
5 
10 
10 
5 
6 
15 
20 
15 
6 
7 
21 
35 
35 
21 
7 
8 
28 
56 
70 
56 
28 
8 
9 
36 
84 
126 
126 
84 
36 
9 
10 
45 
120 
210 
252 
210 
120 
45 
10 
11 
55 
165 
330 
462 
462 
330 
165 
55 
11 
Figure 3.7 Pascal's Triangle, Rows 0-11. 
Example 2.1. 
Here are a few binomial coefficient values: 
and 
(2) 
2! 
1 = (1! . 1!) = 2. 
Question 2.6. 
Determine the following binomial coefficients 
-
Then determine all binomial coefficients of the form 
and 
for 0 ~ i ~ 4 and 0 ~ j ~ 5. 
Question 2.7. 
Explain why the following facts are true for all positive k. 
(~) = (~) = 1 
and 
Notice that the assignment of the value 1 to O! allows (~) and G) to be defined. 
135 
-

-
-
-
3 ARITHMETIC OF SETS 
Theorem 2.1. 
The nth row of Pascal's triangle consists of the binomial coefficients 
Proof. The proof is by induction on n. Some of the rows of the Pascal triangle 
are listed in Figure 3.7 and for n < 6 agree with the results of Example 2.1 and 
Question 2.6. Thus we assume that the kth row of Pascal's triangle consists of the 
binomial coefficients e) for i = 0,1, ... ,k. In Figure 3.8 we display this row and 
label the unknown values in the (k + 1)st row with variables Xl' x2' . .. ,xk, whose 
values we must now determine. 
Figure 3.8 
We know that the zeroth and (k + l)st entries of the (k + l)st row equal l. 
We also know that each entry equals the sum of the two numbers above. Thus 
Xl must equal the sum 
(~) + G) = 1 
+ k = e : 1} 
Question 2.8. Show that X2 = e ; 
I} 
In general, we see that 
( k) (k) 
k! 
k! 
Xi = i-I + i = (i - l)!(k - i + I)! + i!(k -
i)! 
k! 
[1 
1J 
k! 
i + (k - i + 1) 
= (i -
1)!(k - i)!· k - i + 1 + i = (i - l)!(k - i)!· i(k - i + 1) 
(k + 1)! 
(k + 1) 
= i!(k - i + I)! = 
i 
. 
Thus the ith element in the nth row of Pascal's triangle is (~). 
o 
136 

--
--
3:2 BINOMIAL COEFFICIENTS 
Corollary 2.2. e 
~ 1) = C 
~ 1) + C) for all 1 :s; i :s; k. 
Proof. 
This was exactly the central calculation in the induction proof of Theo-
rem 2.1. 
0 
Why do we want to know all these facts about rows of the Pascal triangle? First 
of all, they provide the solution to the shortest path problem. We began this section 
with an effort to calculate f(P), the number of shortest paths from M to P in the 
6 x 5 rectangular grid. The point P lies on the 11 th row of Pascal's triangle and is 
the 6th entry, counting beginning with 0. Thus by Theorem 2.1, 
f(P) = (11) = ~ 
= 11 . 10 . 9 . 8 . 7 = 462. 
6 
6! . 5! 
5 . 4 . 3 . 2 . 1 
In the case of the general m x n rectangular grid, the point P = (m, n) lies on the 
(m + n)th row of the Pascal triangle and is the mth entry. Thus in this case 
f(P) = (m + n) = (m + n)! , 
m 
mIn! 
an explicit formula for the number of shortest paths. 
Question 2.9. 
How many shortest paths are there from (0,0) to (4,3) in a rec-
tangular grid? 
Look back at Pascal's triangle in Figure 3.7 and notice that there is a great 
deal of symmetry in the binomial coefficients. For a fixed value of k the numbers 
(~}G} ... ,G}··· ,G) begin with 1, first increase as i increases, and then 
decrease through the same values back to 1. In other words, the second half of 
this sequence is a mirror image of the first half. The largest value occurs in the 
middle. 
Theorem 2.3. C) = (k ~ i) for all i = 0, 1, ... , k. 
Proof. 
(
k) 
k! 
k! 
i = i!(k - i)! = (k - i)!i! 
k! 
( k ) 
= (k - i)!(k - (k - i))! = 
k -
i . 
o 
137 

-
-
-
3 ARITHMETIC OF SETS 
The largest value of e) for fixed k occurs when i = k/2 if k is even and when 
i = (k - 1)/2 and (k + 1)/2 if k is odd. 
Theorem 2.4. 
Given natural numbers k and i with i ::;; (k - 1)/2, 
Proof. 
Given i ::;; (k - 1)/2, we multiply both sides by 2 to get 2i ::;; k -
1. Next 
we add 1 and subtract i to get i + 1 ::;; k -
i. Taking reciprocals, we get 
Now 
1 
1 
--<--. 
k-i-i+1 
(
k) 
k! 
1 
k! 
i 
= i!(k - i)! = (k - i) . i!(k - i-I)! 
which after substituting (*) yields 
( k) 
1 
k! 
( 
k ) 
i 
::;; (i + 1) . i!(k - i-I)! = i + 1 . 
Corollary 2.5. For natural numbers k and j with j ;;:: (k - 1)/2 
(*) 
o 
Proof. 
Sincej;;:: (k - 1)/2, (k - j -
1)::;; k - (k - 1)/2 - 1 = (k - 1)/2. Applying 
Theorem 2.4 with i = k - j -
1, we have 
Applying Theorem 2.3, we get 
o 
Theorem 2.4 and Corollary 2.5 combine to tell us that the largest value among 
138 

-
-
-
3:2 
BINOMIA~ COEFFICIENTS 
occurs at 
Theorems 2.3, 2.4, and Corollary 2.5 are attractive and interesting, and they are 
also useful. We need these results for the analysis of the complexity of the next 
major algorithm, which generates all k-subsets of an n-set. 
EXERCISES FOR SECTION 2 
1. Fill in the f value for every point on the 4 x 4 rectangular grid. 
2. In rotating the rectangular grid into Pascal's triangle, the vertical and hori-
zontal rows of the grid become diagonals in the triangle. Even more important, 
it is the diagonals from the point (0, i) to the point (i,O) that become the 
rows of Pascal's triangle. Determine the coordinates of all the points in the 
grid that end up on the 3rd row of Pascal's triangle. Then do the same for 
the 4th row. 
3. Find the integer coordinates of all the points in the rectangular grid that end 
up on the kth row of Pascal's triangle. On what row of Pascal's triangle 
does the point (i,j) end up? 
4. Is the following statement true or false: Every number on the kth row of 
Pascal's triangle, except for the first and last, is divisible by k. If true, explain 
why. If false, characterize the rows for which it is a true statement. 
5. Calculate the sum of the kth row of the Pascal triangle for k = 3, 4, 5, and 6. 
Formulate a conjecture about the sum of the kth row of the triangle. 
6. Calculate the following binomial coefficients: 
7. Verify Corollary 2.2 by calculating the following sums and checking that the 
corollary is correct in these cases: 
(~) + (!), 
(~) + (~), (!) + (~). 
8. Find the largest binomial coefficient of the form C:) and (~5). 
9. The number 10 equals at least four different binomial coefficients: 
and 
139 

-
-
-
3 ARITHMETIC OF SETS 
Are there any other values of k and j such that 10 = G)? Find a number 
n > 1 that equals at least five different binomial coefficients, and then find a 
number k that equals only the two binomial coefficients G) and (k ~ 1} 
10. Construct an algorithm FACTORIAL that upon input of a positive integer j, 
calculates and outputs j!. 
11. How many zeros does 15! end in? Find the smallest value of n! that is divisible 
by 1,000,000. 
12. Notice that 2 = 2!, 3 = 2! + I!, 4 = 2· 2!, and 5 = 2 . 2! + I!. Express 6, 7, 8, 
9, and 10 as sums of multiples of factorials in the following form: 
n = aj . j! + aj-l . (j -
1)! + ... + al . 1! 
where aj' aj-I" .. ,al are integers satisfying ai .::;; i for i = 1,2, ... ,j. This form 
is called the factorial representation of the integer n. (See Supplementary 
Exercises 8 and 9.) 
13. Determine whether the following are true or false. Give reasons for your 
answers. 
(a) n! = O((n + I)!) 
(c) n! = O«n - I)!) 
(e) 1! + 2! + 3! + ... + n! = O(n!). 
(b) n! + 5 = O(n!) 
(d) n! + (n -
I)! = O(n!) 
14. If p is a prime, show that each of the following numbers is a composite 
number. (A number that is not prime is called composite.) 
p! + 2, p! + 3, ... ,p! + p. 
Describe how to obtain 1000 consecutive composite numbers. If p is not a 
prime, can you use the same construction to obtain rn consecutive composites 
for any integers p and m? 
15. Prove Theorem 2.3 using the grid path formulation of binomial coefficients. 
16. Each row of Pascal's triangle is called symmetric because the ith entry equals 
the (k - i)th. Each row is called unimodal, since the numbers increase to a 
maximum and then decrease. Find an example of a sequence of 10 numbers 
that is symmetric but not unimodal. Then find an example of a sequence of 
10 numbers that is unimodal but not symmetric. 
17. Explain why 
140 

-
-
-
3:3 SUBSETS OF SETS 
Then express (~) in terms of binomials coefficients of the form" k - 3 choose 
something." Interpret these identities in the grid. 
18. How many shortest paths proceed from (0,0) to (6,9) in the rectangular grid? 
How many of these go through the point (4,5)? 
19. How many shortest paths proceed from (0,0) to (m, n) through the point (r, s) 
if 0 < r < m and 0 < S < n? 
20. Suppose that k is odd. Explain why Theorem 2.3 and Corollary 2.4 imply 
that 
for all 0 :::;; i :::;; k. 
Then when k is even, explain why for all 0 :::;; i :::;; k 
3:3 SUBSETS OF SETS 
This section considers the problems of counting and generating all the j-subsets 
of an n-set. 
Example 3.1. 
Suppose that we want to know how many 3-subsets there are in a 
6-set. One method would be to list them all. We now do this for the 6-set 
A = {al,a2,a3,a4,aS,a6}: 
tal' a2, a3}' 
{al , a2, a6}' 
{al,a3,a6}, 
{al ,aS,a6}, 
{a2,a3,a6}, 
{a2,aS,a6}, 
{a3,aS,a6}, 
{a l ,a2,a4}, 
{a l,a3,a4}' 
{a l , a4, as}, 
{a2,a3,a4}, 
{a2,a4,aS}, 
{a3,a4,aS}, 
{a4,aS,a6}· 
{a l ,a2,aS} 
{a l ,a3, as} 
{a l ,a4,a6} 
{a2,a3,aS} 
{a2,a4,a6} 
{a3,a4,a6} 
Thus there are 20 3-subsets of a 6-set. Notice that 20 = G)' 
141 

-
-
-
3 ARITHMETIC OF SETS 
In this problem we asked for the number of 3-subsets. We would have been 
content to have the number 20 without the list of subsets. 
Exercises 1.7.2 and 1.7.3 asserted that n equals both the number of 1-subsets 
of an n-set and the number of (n - 1)-subsets of an n-set. Notice that 
Similarly, the number of 2-subsets and the number of (n - 2)-subsets of an n-set 
equals (;) as seen in Exercises 1.7.5 and 1.7.7. Thus in these cases the exact subset 
count is given by a binomial coefficient. 
Question 3.1. If A = {aI' az, a3' a4' as, a6}' check that the number of 4-subsets of 
A is (!) and the number of 5-subsets is (~). 
Specific examples all point toward the truth of the following theorem. The 
idea of the proof is similar to the proof by induction that an n-set has 2n subsets, 
given in Section 2.4. 
Theorem 3.1. 
For j = 0,1, ... , n, the number of j-subsets of an n-set equals the 
binomial coefficient (;). 
Proof. The proof of this theorem is by induction on n. For n = 0 and j = 0, there 
is only one subset of the empty set (itself) and 1 = (~).When n = 1, there is 
G) O-subset, the empty set, and G) 1-subset, the entire set. 
We assume that the theorem is valid for n = k and try to prove it for n = k + 1. 
Suppose that A = {a1> az, ... , ak+ d, and consider all j-subsets of A. We divide 
these into two piles, those that contain the last element ak + 1 and those that don't. 
Question 3.2. 
Divide the 3-subsets of the 6-set given in Example 3.1 into two piles 
depending on whether a6 is contained in the 3-subset or not. 
Let A' = A - {ak+ d. See Figure 3.9. If S is a j-subset of A that contains 
ak+ 1> then S -
{ak + d is a (j - 1 )-subset of the k-set A'. By the inductive hypothesis 
we know that there are C 
~ 1) of these (j - 1)-subsets of A'. Thus there are 
142 

3:3 SUBSETS OF SETS 
I 
A' 
A 
Figure 3.9 
( . k ) j-subsets of A that contain ak + l' If S is a j-subset of A that does net 
} -
1 
contain ak + l' then S is a j-subset of A'. By the inductive hypothesis there are 
G) of these subsets. Thus the total number of j-subsets of A is given by 
C 
~ 1) + G)' By Corollary 2.2 this sum equals e 7 
1). 
0 
Question 3.3. 
Use Theorem 3.1 to determine the number of k-subsets of an n-set, 
where (a) k = 3, n = 6; (b) k = 5, 11 = 11; and k == 9, 11 = 17. 
Theorem 3.1 will enable us to prove a varif:ty of results. For example, 1001( 
back at Figure 3.7 and Exercise 2.5 and notice that the sum of the numbers in 
one row of Pascal's triangle seems to be a power of 2. It appears that for fixed n, 
the binomial coefficients of the form (~) sum to ::n. This result is an easy corollary 
of Theorem 3.1 once we look at the problem in the right way. 
Corollary 3.2. 
For every natural number n 
( ~) + C) + ... + C) + ... + C) = 2n. 
Proof'. 
As we've seen, the number of subsets of an l1-set is 2n. This number of 
subsets also equals the number of O-subsets plus the number of I-subsets plus' .. 
plus the number of i-subsets plus' .. plus the number of l1-subsets. By Theorem 3.1 
this sum is exactly the left-hand side of the equation and so the two expressions 
are equal. 
[] 
Example 3.2. 
Consider an n-digit number in binary. We can also think of this as 
an l1-bit sequence of zeros and ones. How many l1-bit sequences are there that 
contain exactly i ones, for i an integer between 0 and n? To answer this question. 
we need to recall a discussion about subsets and "bit vectors" of zeros and ones 
143 

3 
ARITHMETIC OF SETS 
presented in Chapter L Section 7 (see Question 7.5.) There it was shown that every 
n-bit sequence with i ones corresponds to a unique i-subset of an n-set, and con-
versely. Thus the number of Il-bit sequences with i ones equals the number of i-
subsets of an n-set, (~) for 0 sis n. 
Example 3.3. 
From Section 3.1 the number of shortest paths from M to P in 
the 6 x 5 grid equals the number of sequences of I J Es and Ns with exactly 6 Es, 
and we know that this number equals C61). Now we can see directly why there 
are C6
1
) sequences of 6 Es and 5 Ns. Suppose that we take any sequence of Es 
and Ns and replace every E by a one and every N by a zero. Then we have an 
II-bit sequence with 6 ones: from Example 3.2 we know that there are (161) of these. 
Furthermore, every II-bit sequence with 6 ones can be transformed back into 
a sequence of 6 Es and 5 Ns. In fact, Es and Ns or ones and zeros are two ways 
to represent exactly the same idea. Thus there are the same number of these two 
types of sequences. 
Question 3.4. 
How many I J -letter sequences of Ns and Es are there that contain 
3 Es?, 4 Es?, 7 Es'? What is the total number of all possible II-letter sequences 
of Es and Ns? 
Problem. 
Given positive integers j and n with j S n, list all .i-subsets of 
p, 2, 3, ... ,Il}. 
We know the number ofj-subsets of an n-set without listing them all. However, 
we may wish to list all subsets of a certain size. We turn to the construction of an 
algorithm that upon input of natural numbers nand j with j s 11 will list all j-
subsets of an n-set. Up until now we've used the generic l1-set A = ; (/ l' (/2" .. , UII }. 
We simplify the notation and consider the n-set In = : 1, 2 .... , n land itsj-subsets. 
This change merely saves on writing: the j-subsets of A and In correspond exactly. 
We agree to always write the j-subset with its entries in increasing order. 
Question 3.5. 
Describe how to transform a j-subset of A into a j-subset of In' 
and conversely. In particular, find the 4-subset of In that corresponds with 
l a l' <1 2 , a4 , Un - 1] and the 5-subset of A that corresponds with iI, 2, 3, 5, 8). 
For small, fixed values of j, the problem of creating an algorithm to list all 
j-subsets is not hard, and we begin with some specific cases. Exercise 14 asks you 
to design the straightforward algorithms to list all O-subsets and all I-subsets ()f 
In = : 1, 2 ..... 11 : • 
144 

3:3 SUBSETS OF SETS 
Example 3.4. 
Here is an algorithm that lists all 2-subsets of III = [L 2, ... ,11 J. 
(This also was Exercise 1.7.6.) 
Algorithm PAl R 
STEP I. Input n, a positive integer 
STEP 2. For i = 1 to (n -
1) do 
Begin 
STEP 3. For j = (i + 1) to n do 
STEP 4. List Ii,}} 
End 
STEP 5. Stop. 
COMMENTS. 
Section 2.4 contained examples of this form of a loop, often called 
a "do loop." Recall that the instructions, "For i = 1 to (n -
1) do, Begin, ... , 
End," mean that first i should be set equal to 1 and the instructions between 
the Begin and End statements should be executed. Next, i is set equal to 2 and 
the Begin ... End statements are executed. We repeat these steps, increasing 
i by one each time until i is set equal to (n -
1), the Begin ... End statements 
are executed for the last time, and then we move on to the next statement, here 
step 5. This is also our first example of a loop within a loop; such pairs of loops 
are called nested. For each assignment of a value to i, step 3 is repeated several 
times, once for each of the values j = (i + 1), (i + 2), ... , and n. Then i is assigned 
its next value and} runs through its sequence of values. 
The output of PAIR has the following properties. The subset f i,n is always 
listed with its smaller element first. The first subsets listed are those that contain 
1; next the subsets that contain 2 (but not l) are listed; then those with 3: and so 
on. Here is how the output looks: 
(1,2]' 
[l,3}, 
[l,4}, ... , 
[I,n\, 
:2,3}, 
:2,4), 
: 2, Il], 
l3,4}, 
[3,n}, 
: n - 2, n - I], 
: 11 -
2, Il }, 
:n -
I,n). 
This ordering is known as lexicographic or dictionary order. 
The idea behind PAIR could be generalized to generate all 3-subsets of an 
l1-set by having 3 nested loops. However, if we want to list all j-subsets, where j 
is part of the input to the algorithm, then this idea won't work, since we can't 
have the correct number of loops programmed in advance. rnstead we generalize 
the idea of lexicographic order for arbitrary j > 2 and use this order to list all 
j-subsets. 
145 

3 ARITHMETIC OF SETS 
We approach lexicographic ordering in two ways. First we describe to you. 
a human, which of any two j-subsets of an Il-set should be listed before the other. 
Next we need to explain this order to a computer, that is, in language sufficiently 
precise so that it can be implemented as an algorithm. We need to know exactly 
how, once the algorithm has created and listed a j-subset S, to move on and pro-
duce the next j-subset T. At the same time we must explain why lexicographic 
order as described for humans is the same as the order described for computers. 
We begin our description for humans with an example. 
Example 3.5. 
Here are the 3-subsets of 15 = (1,2,3,4, 5} listed in lexicographic 
order: P,2,3}, {l,2,4}, {I,2,5}, {l,3,4}, (J,3,5}, [1,4,5}, {2,3,4}, {2,3,5J, [2,4,5}, 
{3, 4, 5}. 
One way to think about lexicographic order is to disregard all the set notation 
that accompanies each subset and just list the integers in the order in which they 
appear. Then we see 
123 < 124 < 125 < 134 < 135 < 145 < 234 < 235 < 245 < 345, 
and the ordering is the same as the "less than" order on the natural numbers. 
Question 3.6. 
Place the following sets of 18 in lexicographic order. {I, 3,4, 7}, 
{3,6,7,8}, 12,3,4,7}, {4,6,7,8}, [2,3,5,6}, and {l,3,5,6}. 
This description would suffice for humans and computers except for the fact 
that if 11 > 9, we might see sets like [2,3,45,678} and {2, 34, 56, 78}. This could be 
salvaged if we were willing to do arithmetic in base n, but since n is part of the 
input, there are still problems with this approach. 
Here is a way for humans and computers to decide which of two j-subsets, S 
and T, to list first. Suppose that S = {SI"" ,sJ and T = [t 1, .. · .tJ. If SI < t\, 
then S is listed before T. [f S 1 > t l' then T is listed before S. The only other 
alternative is that s 1 = t 1 in which case we compare the second element of each 
set. In general, if s 1 = t l' S2 = t 2 ,· .. , Si - 1 = ti _ l' and Si < tio then we list S before 
T, and if Si > ti we list T before S. In English, S appears before T if in the first 
place the two sets differ, the element of S is smaller than the element of T. 
Example 3.6. 
[2, 3,4,7, 8, 9} is listed after (2,3,4,6 .. 8, 9}, since the sets agree until 
the fourth entry at which point 7 > 6. 
When listing all subsets of a set, if S is listed immediately before T, we should 
expect that Sand T agree as much as possible. Furthermore, we should expect 
that at the location where Sand T first disagree, the entry in T is just one larger 
than the corresponding entry in S. 
146 

3:3 SUBSETS OF SETS 
Example 3.5 (revisited). 
A second way to view lexicographic ordering of the 3-
subsets of {I, 2, 3, 4, 5} is to start with the "first" set {1, 2, 3}. Then we let the la ~t 
entry increase by 1 and we get {l,2,4}. Repeating this, we get [l,2,5}. So Ollr 
listing begins 
{ 1, 2, 3 }, 
{ 1, 2, 4}, 
{1, 2, 5}. 
Now the last entry is as big as it can be. So we agree to increase the second to 
last entry by 1 and make every other entry as small as it can be. Thus after (1,2,5} 
we get {l,3,4}. Now we return our attention to the last entry, which can once 
again be incremented. Thus the list continues 
{1,3,4}, 
{l,3,5}, {l,4,5}. 
Now our second to last entry is as big as it can be, so we have to increment our 
third to last (here the same as the first) entry. We finish with 
{2,3,4}, 
[2,3,5}, 
{2,4,5}, 
{3,4,5}. 
Question 3.7. 
List all 3-subsets of 16 = {1, 2, 3,4,5, 6} in lexicographic order. 
Thus, in general, the idea of lexicographic order is to begin with the j-subset 
{1, 2, ... ,j -
I,j} and then to let the last entry increase through all possible values 
until we reach the subset {L 2, ... , j -
L Il}. Next we move back to the second 1.0 
last entry, increase it by one, and let the last entry take on all larger values. J n 
general, after a subset S = {Slo'" ,Sh,'" ,Sj} is listed, we search from right to left 
in S looking for the first entry that can be increased by one. Suppose that Sh can 
be increased to Sh + 1, but no Sk with k > h can be increased. Then we produce 
the new subset T= {S1,'" 
,Sh-1,Sh + I,sh + 2,Sh + 3, ... J. 
Example 3.7. 
Here is how these ideas apply when listing all 4-subsets Df 
{ 1,2, ... , 8} in lexicographic order. 
(1,2,3,4}, 
p,2,3,5}, 
[l,l,3,8}, 
[1,2,4,5}, 
(1,2,4,6}, 
{l,2,4,8}, 
:1,2,5,6}, 
:1.2,5,7}, 
{t, 2, 5, 8}, 
(l,2,6,7}, 
{1, 2, 6, 8}, p, 2, 7, 8}, 
: 1,3,4, 5}, 
: 1, 3,4, 6}, 
r I, 3,4, 8}, 
p, 3, 5, 6}, ... , {1, 6, 7, 8}, 
(2,3,4,5}, 
:2,3,4,6l, .. ' , 
{5,6,7,8}. 
We know that we are finished, since no entry can be increased. 
147 

3 ARITHMETIC OF SETS 
Question 3.8. 
List all 3-subsets of 17 = [1,2, ... ,7] in lexicographic order. 
Notice that in Example 3.1 if the set 16 = p, 2, 3, 4, 5, 6l is substituted for .4 
and the corresponding 3-subsets of .4 are replaced by those of 16 , then the subsets 
are listed in lexicographic order. 
This work gives us the ideas for an algorithm to list all j-subsets of an l1-set 
for a general value of j and 11. The only imprecision left is how, after a j-subset S 
is listed, to find the entry Sh that can be increased to Sh + 1. Note that the jth 
entry in a j-subset can be no larger than 11, the (j - 1 )st entry can be no larger 
than 11 -
1, and in general the ith entry can be no larger than 11 + i - j. Thus we 
read from right to left until we find Sh such that Sh < Il + h - j. We replace Sh by 
Sh + 1 and fill in the remaining subset entries with Sh + 2, Sh + 3, .... The algo-
rithm stores each subset in an array {b 1, b2 ,· .. , bJ 
Algorithm .J SET 
STEP 1. Input j and Il with 1 ~ j ~ 11 
STEP 2. Set [b 1,b 2 , ... ,bjJ := (1,2, ... ,j) and list this set 
STEP 3. Set h :=j + I and FOUND:= FALSE 
{Next we determine which entry to increase by l. When we find the 
entry, we set FOUND to be TRUE.} 
STEP 4. While h > I and FOUND = FALSE do 
Begin 
STEP 5. h: = h -
I 
STEP 6. If bh < Il + h -j, set FOUND:= TRUE 
End 
: Right now the value assigned to h is the rightmost entry that can 
be increased. If FOUND = FALSE. then we are finished listing all 
subsets. } 
STEP 7. 
If FOUND = FALSE, then stop. 
Else 
Begin 
STEP 8. 
STEP 9. 
STEP 11. 
STEP 12. 
End 
Set bh : = bh + I 
For k : = h + 1 to j do 
STEP 10. Set bk : = bk. _ 1 + I 
List [hl,h2"" .hJ} 
Go to step 3 
COMMENTS. 
We introduce the so-called Boolean variable FOUND. (See also Sec-
tion 10 of Chapter 1.) A Boolean variable can be assigned only two values, either 
TRUE or FALSE. We initialize FOUND to be FALSE and change its value if 
the correct entry to increment has been located. Before repeating the steps inside 
148 

3:3 SUBSETS OF SETS 
the While do loop at step 4, two conditions must be satisfied. It must be the case 
that both h > 1 and FOUND = FALSE. If either condition is contradicated, then 
we proceed to step 7. In general, Boolean variables are useful in the design of 
loops when the number of iterations through the loop is not known in advance. 
With j = 3 and n = 5, JSET lists the subsets as shown in Example 3.5 and 
with j = 4 and n = 8 as in Example 3.7. 
Question 3.9. 
Run JSET with j = 4 and n = 6, 
We conclude with an informal analysis of the complexity of JSET. The input 
is j and n with j :::;; n; so we use n as a measure of the input size. We let fin) equal 
the maximum number of time-consuming operations performed in JSET and carry 
out a worst-case analysis. We hope to find a simple function gin) [like log (n), '1 2 , 
or 2n] such that f(nl = O(g(n)). Instead of counting all the additions, assignments, 
and comparisons in JSET, we choose to define a basic, time-consuming operation 
to be the creation and listing of a j-subset. (For a more precise analysis see Exercise 
23.) Since C) j-subsets are produced, fin) = G)' Is JSET good? That depends 
on the value of). For example, when) = 2, the complexity of JSET is 
and in this case JSET is a good algorithm. 
Question 3.10. 
Show that JSET is a good algorithm when) = 3. 
Question 3.11. Show that ifj is a fixed constant less than 11/2, then 
(n) 
. 
) 
= O(n}). 
However, there are cases in which JSET is an exponential algorithm. We have 
seen in Section 3.2 that (r~) is largest when) =, Lnl2 J. We shall show in the next 
J, 
theorem that (Ln
l;2J) is exponential in n [thus not O(p(n)) for any polynomial p l 
Does that mean that we have failed to be sufficiently clever in our algorithm 
design? No, because when j = L nl2 J, there is an exponential number of i-subsets, 
and any j-subset algorithm will be exponential. since each of these must he listed. 
Thus although this algorithm is exponential and not good, it is nonetheless more 
or less as efficient as possible and so we'll use lt when needed. 
149 

3 ARITHMETIC OF SETS 
Theorem 3.3 
For n even ( ~'l) 2 ('1/2)". 
11/_ 
Proof 
C~2) = In/2)! (;!- n/2)! = (11/2)~~11/2)! 
n(11 -
l)(n -
2) ... (n/2 + 1) 
(n/2)(n/2 -
1)(n/2.-
.. ··2· I 
n 
n -
I 
n/2 11/2 - 1 
11 - j 
n/2 -.I 
n/2 + I 
-----
1 
Next we consider an arbitrary factor in the above expression. 
l1-j 
n-j 
n--j 
---= 
=2'-->2. 
n/2 - j 
(11 - 2j) 
n -- 2j -
2 
Thus each of these factors is at least 2. Since there are n/2 factors, the product is 
at least 2n/2 = (J2)n. 
0 
EXERCISES FOR SECTION 3 
1. For i = 0, I, .... 6 calculate the number of i-subsets of a 6-set. Check that 
these numbers sum to 26. 
2. For i = 0,2,4,6,8 calculate the number of i-subsets of an 8-set. Check that 
these numbers sum to 27. 
3. The number of j-subsets of an n-set equals (;), and the number of (11 - j)-
subsets equals ( n .). Give a set theory argument to show that these two 
n - J 
numbers are equal. 
4. From a class of 14 students, a committee of 5 students is formed. In how many 
different ways can this committee be chosen'? How many of these committees 
contain one particular student, Sue, and how many committees do not contain 
her? 
5. Suppose that a class is composed of eight freshmen and six sophomores. 
150 
How many committees are there that consist of three freshmen and two 
sophomores? 

3:3 SUBSETS OF SETS 
6. Suppose that two committees with no members in common are to be selected 
from a class of 14 students. First a committee of 5 students is selected and 
then a committee of 3 students. In how many ways can these two committees 
be formed? Is the answer to the last question the same as the number of ways 
to form first a committee of 3 students and then second a committee of 5 
students? 
7. The local Pizza Factory produces pizzas topped with tomato sauce and cheese. 
Optional items are mushrooms, green peppers, olives, onions, anchovies, 
pepperoni, and hamburger. The prices are $3.00 for plain pizza, $3.50 for one 
extra item, $4.00 for two items, and $4.50 for three. How many different kinds 
of pizza cost $3.50? $4.00? $4.50? 
8. The ice cream parlor in town offers 10 different kinds of ice cream daily plus 
toppings of fudge sauce, butterscotch sauce, raspberry sauce, walnuts, M&Ms, 
Heath Bar Crunch, and whipped cream. How many different ways are there 
to make a sundae if (by definition) a sundae consists of one kind of ice cream 
plus at least one topping? How many kinds of sundae are there that have 
exactly 3 toppings? That have no more than 3 toppings? 
9. Prove by induction on n that 
10. If n is even, show that 
Then find and justify a similar formula when n is odd. 
11. List all seven-bit vectors with exactly two ones. Then list all sequences of Es 
and Ns that contain exactly five Ns and two Es. 
12. For j = 2,3, ... ,7 calculate the binomial coefficients G) and find their sum. 
Then find a formula in terms of n that compactly expresses the sum 
G) + G) + ... + G)' 
13. Design an algorithm to create and list all bit vectors of length n. 
14. Describe an algorithm that will list all O-subsets of In = i I, 2, ... , n 1. Then 
describe an algorithm that will list all I-subsets of I no 
15. (a) Modify the algorithm PAIR to list all bit vectors oflength It that contain 
exactly 2 ones. 
151 

3 ARITHMETIC OF SETS 
(b) Modify PAIR to list all sequences of Es and Ns that contain exactly 2 Es 
and n - 2 Ns. 
16. How many 2-subsets of an n-set contain the element I? How many 2-subsets 
contain the element 2 but not I? How many contain 3 but neither I nor 2'1 
In general. how many 2-subsets contain the element i but no smaller number'? 
Then add up all these answers for i = 1,2, ... , (n -
I) and explain why that 
sum adds up to (;), the total number of 2-subsets of an n-set. 
17. List all 2-subsets of {l, 2, ... ,6} in lexicographic order. Then list all 5-subsets 
of the set : 1,2, 3,4, 5, 6, 7} in lexicographic order. 
18. We defined lexicographic order of subsets of numbers by saying that we list a 
subset S before a subset T "if in the first place the two sets differ, the element 
of S is smaller than the element of T." If we consider now subsets of a set A = 
{a, b, c, d, eJ} and use alphabetical ordering of letters, how should we define 
lexicographic order of subsets of A? List all 2-subsets of A in lexicographic 
order. Then check that in your list, when a is replaced by 1, b by 2, ... ,and 
f by 6, that the 2-subsets are still listed in lexicographic order (for numbers). 
19. Run the algorithm lSET with 
(a) j = 1 and n = 6. 
(b) j = 3 and n = 6. 
(c) j = 3 and n = 7. 
20. Is lSET a good algorithm when j = n - 2? When j = n -
I? 
21. If n is odd, show that 
( 
11 
) > I'" 
(n -
I) 
-
1 
for some I' > 1. 
22. Show that 
for all j. 
23. Give a more detailed, worst-case complexity analysis of lSET by counting 
the number of additions, subtractions, comparisons, and assignments. Note 
that the While do loop of step 4 is executed at most j times and the For do 
loop of step 9 at most (j -
1) times. Show that the total number of these 
152 
operations is 0 (j (n)} Then explain why this analysis shows lSET to be a 
\} 
/ 
polynomial algorithm for j a constant number, but for j arbitrary lSET is 
exponential. 

3:4 PERMUTATIONS 
3:4 PERMUTATIONS 
When we were generating all the j-subsets of the n-set In in Section 3, it was crucial 
to be able to arrange the elements within each subset in increasing order. The 
reason we could do this is that in sets, the order of presentation of the elements 
does not matter and so we could choose an algorithmically useful presentation. 
In contrast we have seen some cases earlier where the given order is important 
and we cannot rearrange elements. Examples include applications of the Multi-
plication Principle and Cartesian products. We turn now to another area where 
order is crucial. 
Given a set A = {a 1 ,Ll 2 , ... ,an} containing n distinct elements, an ordered 
list of these n elements is called a permutation of A. Often, but not always. we shall 
use the set In = {I, 2, ... ,Il} as the generic set with n elements. We distinguish sets. 
which will continue to be denoted by 
~ ... J, from permutations, which will be sur-
rounded by <- . -). 
Example 4.1. 
If 16 = {l, 2,3.4, 5,6}, then (1 2 3 4 5 6), <2 1 4 3 6 5), hnd 
(l 3 5 2 4 6) are three permutations of 16 ; however, < 1 2 4 5) is not a 
permutation of 16 , neither is < 1 2 3 4 5 5) nor < 1 2 3 4 5 7). 
Within the permutation <2 1 3 5 4 6) we say that 2 is in the first position, 
1 in the second position, 3 in the third position, and so on. 
Example 4.2. 
Here are all permutations on { l. 2,3}: 
(123), (132), (312), (213), (231), (321). 
Notice there are 6 = 3! such permutations. 
Question 4.1. 
List all 4! permutations on the four numbers : 1,2,3, -+:. 
The Multiplication Principle shows us why the factorial function counts per-
mutations of an Il-set. Since a permutation is an ordered list, we may count the 
ways to fill in the n blanks: 
-- "'-> 
First we see that we have n choices for the element to place in the first position of 
the permutation. After that we have only (n -
1) choices for the entry in the second 
position, then (n -
2) for the third position, and so on. At the next to last position 
we have two choices remaining and then one choice for the last position. Thus the 
number of permutations on n elements is 
11(n -
I)(n -
2) .... 1 . I = Il!. 
153 

3 ARITHMETIC OF SETS 
This argument proves the next theorem. One proof is sufficient for any theorem, 
but we choose to present a second proof using induction because it will cause us 
to think about generating permutations algorithmically. 
Theorem 4.1. 
There are n! permutations of a set containing n distinct elements. 
Proof. 
First we check the base cases for n = 1 and 2: < 1) is the only permutation 
on one number and < 1 2) and (2 1) are the two permutations on two numbers. 
In Example 4.2 and Question 4.1 we checked the cases for n = 3 and 11 = 4. 
Our inductive hypothesis is that there are k! permutations of any set with k 
elements. Using this hypothesis, we need to show that any set with k + 1 elements 
has (k + 1)! permutations. Let Ik + 1 = [1,2, ... ,k,k + l}. As usual we remove an 
element, setting Ik = Ik+ 1 -
{k + I} = (1,2, ... ,k}. Pick any permutation of Ik : 
for instance, 
<2 1 3 4 ... k). 
Each such permutation of Ik generates k + 1 different permutations of Ik+ 1 be-
cause the element (k + 1) can be inserted in k + 1 different positions. From the 
permutation above we create 
< 2 
3 
k 
k + I), 
< 2 
3 
k + 1 
k ), 
< 2 
3 
k+1 
k ), 
< 2 
k+1 
3 
k ), 
< 
') 
1<+1 
3 
I< 
), 
"-
and 
<I< + 1 
.2 
3 
I< 
). 
Thus the number of permutations of Ik + 1 equals k + 1 times the number of per-
mutations of I k, or (k + I)(k!) = (k + I)!. 
'.J 
Remember this proof because it suggests how to write an algorithm to generate 
all permutations. 
Example 4.3. 
Suppose that we start with the permutation <2 1 3 4). We can 
insert the element 5 in anyone of five different positions to obtain <2 1 J 4- 5), 
(2 1 3 5 4), (2 1 5 3 4), <2 5 1 J 4), and <5 .2 1 J 4). 
154 

3:4 PERMUTATIONS 
Permutations give us another way to see that an n-set has (~) j-subsets for 
o :::; j :::; n. A 2-subset of the set In = [1,2, ... '. n} can be formed by filling in two 
blanks: {_, _}. By the Multiplication Princ:iple there are n choices for the first 
blank and (n -
1) choices for the second; however, once the set is filled in, every 
permutation of the elements in the set will give the same set. On two elements there 
are 21 = 2 permutations and so in the n(n -
1) choices, each set is listed twice. Thus 
there are n(n -
1)/2 = C) 2-subsets. 
Question 4.2. 
Use the Multiplication Principle and permutations to show that 
there are n(n -
l)(n - 2)/31 different 3-subsets of an n-set. 
Next consider the case of counting the number of j-subsets of an n-set for an 
arbitrary value ofj between 0 and n. To create aj-subset, begin by filling inj empty 
blanks: {_, _, ... ,_}. There are n choices for the first blank, then (n -
1) choices 
for the second blank, and eventually for the jth blank, there are n - (j -
1) = n -
j + 1 choices remaining. Thus there are 
nl 
n(n -
1)' .. (n - j + 1) = --. 
(n - ]l! 
choices for filling in j empty blanks. But each subset with j elements can arise in j! 
different orders, one for each of the permutations on j elements. Thus the total 
number of subsets of size j is given by 
n! 
(n) 
(n - j)lj! = 
j . 
Now we turn to the algorithmic question of generating all permutations We 
displayed all permutations on three elements in Example 4.2, and you were asked 
to do the same for four elements in Question 4.1. For n > 4, nl is larger than 100, 
and listing all permutations is clearly a task suitable for computers rather than 
humans. 
Problem. 
Given an integer n > 0, list all permutations of [ 1, ... , n}. 
Look back at the proof of Theorem 4.1. It tells us that from each permutation 
on (n -
1) elements, we get n permutations on n elements by moving the element 
n through all possible positions in the (n -
1) permutation. To use this idea, we need 
to begin at the base case of our inductive proof. We first write down all permuta-
tions on one element: < 1). Then we use the idea of the inductive step to generate 
all permutations on two elements: < 1 2) and <2 1). How about three elements? 
First we expand < 1 2) into the three permutations < 1 2 J), ~ 1 J 2) and (J 1 2). 
155 

3 ARITHMETIC OF SETS 
Then we expand the permutation (2 1) into (2 1 3), (2 3 1), and (3 " 1). 
Here is an algorithm that works exactly in this way. 
Algorithm PERM 
STEP 1. Set j : = 1 and write down the permutation (1) 
STEP 2. Set j : = j + 1 
STEP 3. For each permutation (a l (/2' .. aj _ l ) on j -
1 elements do 
Begin 
STEP 4. Create and list P:= (al(/2 ... (/j- ti) 
STEP 5. For i = j -
1 down to 1 do 
STEP 6. Set P : = P with the values assigned to positions i 
and (i + 1) switched, and list P 
End [step 3} 
STEP 7. If j < 11, then go to step 2; otherwise, stop. 
COMMENTS. 
There are some new features in this algorithm and some old. The 
first new feature is the form of step 5, "For i = j -. I down to 1 do." This indicates 
a do-loop; here the variable i will decrease from j- 1. Thus initially i eq ualsj -
I 
and step 6 is executed; then i equals} - 2 for step 6, ... , until finally i equals I for 
the last execution of step 6, at least for this round. 
We have previously seen an example (in PAIR) of a "nested loop," a loop 
within a loop. Step 3 is an instruction that causes steps 4 and 5 to be executed 
for each permutation on j -
1 elements. Also, step 5 instructs us to carry out 
step 6 j -
I times for each time step 5 is encountered. Actually, the algorithm also 
has a third loop that sends us back to step 2 repeatedly. We do not specify step 
6 precisely, but notice that it requires the switching of the values of two variables. 
exactly the task that we learned to do in Section 2.1. 
Example 4.4. 
In Table 3.1 we trace through algorithm PERM in the case of n = 3 
Table 3.1 
Values lit) 
2 
156 
Permutatiuns 
(1) 
<,I 2) 
<2 I> 
< I :: 3) 
; I 3 2) 
() I 2) 
{2 I J) 
., 
'o- 3 I) 
n 2 I) 

3:4 
PERM(jTATIO~S 
Question 4.3. 
Use Algorithm PERM to generate all permutations on 14- = 
[1,2,3.4]. 
Our next task is to analyze the complexity of PERM. We do even fewer kinds 
of time-consuming operations than in JSET. The algorithm mainly assigns. 
reassigns, and lists permutations, n! of these, in fact. 
To analyze PERM, we need to study the factorial function and relate it to 
our hierarchy of functions: we know that for sufficiently large /1, 
We shall find that not only is Il! # O(p(ll)) for any polynomial /1, but even more. 
in Theorem 4.2 we prove that for any positive integer r > 0 and any constant C, 
Il! > C . rn for Il sufficiently large. Thus the correct position for Il! in the hierarchy 
is at the end (so far): 
... ~ IOn ~ ... :S; Ill. 
We count the formation and listing of each permutation as the fundamental 
time-consuming operation. PERM performs n! of these steps and is thus not a 
polynomial algorithm. However, PERM accomplishes even more than it was asked 
to do. Besides generating all permutations on [1,2, ... ,11}, it also generates all 
permutations on the smaller sets (1,2 .... , i) for each i = 1,2, ... ,11 -
1. Thus 
PERM really performs I! + 2! + ... + 11! steps and its complexity is consequently 
even larger than 111. 
Also notice that in PERM we must store all (i -
I)! permutations on i-.I 
numbers before creating the permutations on i numbers. Hence this algorithm 
requires more than an exponential amount of storage as well as more than an 
exponential amount of time, and so it is bad with respect to both time and space. 
the worst of both worlds. 
Generating permutations is always time-consuming; however. there are ways 
to generate permutations on 11 elements without first generating all permutations 
on smaller sets. Also there are ways to create a "next" permutation from a given 
permutation (as in the algorithm JSET) so that in an application the permutations 
can be produced one after the other without storing previous permutations. Some 
of the ideas behind these algorithms are presented in the exercises. 
But why is Il! such a fast growing function? Why does it belong at the end of 
the function hierarchy? Suppose that we add the function III to Table 2.9 in Chapter 
2. That is. suppose that we perform II! single digit multiplications on an IBM Pc. 
The time involved for differing values of II is listed in Table 3.2. 
The numerical evidence is dear that the function II! grows even faster than 
IOn. Suppose as with multiplication on the PC, we could tigure out and write 
157 

3 ARITHMETIC OF SETS 
Table 3.2 
11 = 8 
11 = 11 
11! 
2.27 min 
37.4 hr 
11 = 16 
2236 yr 
11 = 24 
663,178,306.400 
cent 
11 = 32 
down 17,800 permutations per minute (and this would be working pretty fast!) 
Then Table 3.2 tells us that using PERM in, say, a 24-hour run we could only 
hope to list all permutations for 11 ~ 10. 
Here is theoretical evidence that also points to the rapid growth of Ill. 
Theorem 4.2. 
11! i= O(r") for any positive integer r. 
Proof. 
The theorem states that it is not the case that given a positive integer r, 
there is a constant C such that 11! ~ C . r" for all sufficiently large integers n. Thus 
given an integer r we must show that for every constant C, n! > C . r" for n 
sufficiently large. So pick a constant C and suppose that n > C . rr. (This number 
is cooked up because we found that it made the proof work easily!) We know that 
r = rand r + 1 > r, and r + 2 > r, and ... , n -
I > r. Thus we have 
n!=n(n-l)"'(r+ l)r"'2'1 
?: n(n -
1)·· . (r + I)r 
>n·r· .. · '1"1' 
> (C . rr) . r' ... . r . r 
= C' r
U 
by definition 
by ignoring the last factors 
(a product of (n -
1') r's) 
by choice of n 
Question 4.4. 
Theorem 4.2 says that n! # 0(2"). Find an integer N so that for 
n ?: N, n! > 10·2". 
We state without proof a result that gives some feeling for the size of nL 
Stirling's Formula. 
n! is approximately equal to the function 
where e = 2.71828 ... is the base of the natural logarithm. 
158 

3:4 PERMUTATIONS 
We do not define what "approximately equal" means, but a consequence ,)f 
Stirling's formula is that both 
and 
(
l1)n 
__ 
~ In = O(nl). 
By all accounts, nl quickly becomes humongous. 
We have used the word permutation previously in Chapter 1 in the study of 
functions. We said that a one-to-one and onto function f, f: D -+ D, is called a 
permutation. When D is a finite set, such as In = (1,2, ... ,n}, then, the two defini-
tions are really the same. If f: In -+ In is a one-to-one function (which is necessarily 
onto by Theorem 9.1 from Chapter 1), then we get a permutation, in the sense 
of this section, from the listing <f(1) f(2) ... /(n). Conversely, given a permuta-
tion of In <at a2 ... , an), this defines a one-to-one function /: In -4 In by setting 
f(i) = ai for i = 1, ... ,n. 
Example 4.5. 
Corresponding to the permutation <1 3 2 5 4 6) is the one-to-
one function / defined by f(l) = 1, /(2) = 3, /(3) = 2, f(4) = 5, f(5) = 4, and 
f(6) = 6. Corresponding to the one-to-one function f defined by f{i) = 7 - i for 
i = 1,2 .... ,6, is the permutation <6 5 4 3 2 I). 
Permutations occur in many mathematical and computer science contexts. In 
this course we shall meet them again in a game in the next section as well as in 
later chapters. In other courses they occur in diverse settings such as linear algebra, 
sorting and searching problems, in a variety of games and path traversing questions, 
and even in English bell ringing. The goal in English bell ringing, called change 
ringing, is to ring all permutations on however many bells are in the tower. For-
tunately, most towers have at most 8 or 10 bells. 
EXERCISES FOR SECTION 4 
1. List all permutations of r x, y, .:} and of [a, b, c, J }. 
2. Find the least integer n such that nl > 3n. Then find any integer 11 such that 
nl > 4". 
3. English bell ringers, called change ringers, ring tower and hand bells following 
sequences of permutations; however, one of the requirements of change ringing 
is that a permutation p may be followed by a permutation p' only if for i = 
2,3, ... ,n -
1, the number in position i of p is in position i-I, i or i + 1 
of p'. The number in position 1 of p may stay in position 1 or move to position 
2, and the number in position n may stay in position n or move to position 
n -
1 of p'. Thus the following sequence of three permutations is legal from 
159 

3 ARITHMETIC OF SETS 
the perspective of bell ringmg: (1 2 3), (1 3 2), (3 1 2), but the next 
permutation (as produced by PERM) (2 1 3) is not a legal follow-up to 
(3 1 2), since number 3 jumped from the front to the back. Find a sequence 
of all 3! permutation on : L 2, 3} that is suitable for bell ringing. Do the same 
for the 4! permutations on :L2,3,4}. 
4. Which is larger nvn or ('.i~)"? 
5. Prove that nvn = 0(2"). Either prove or disprove the statement (,/;~)" = 0(2"). 
6. Prove that n' II i= O( p(n)) for any polynomial p(n). 
7. Prove that r" = O(n!). 
8. Prove the following corollary of Theorem 4.2: For every real number 1', 
n! i= 0(1'"). 
9. Check the accuracy of Stirling's formula: For n = 5,6, ... , 10 use a calculator 
to evaluate .j2nn(n/e)" using e = 2.71828 and compare these values with ilL 
10. Let f be the one-to-one function defined on [1,2, ... ,6} by f(l) = 2,/"(2) = 1, 
f(3) = 4, f(4) = 3, I(5) = 6, and f(6) = 5. Show that f2 = I 0 I is the identity 
mapping. Find a one-to-one function y on the same domain for which l is 
not the identity. For this y find the least integer i such that ~/ (a composed 
with itself i times) is the identity. Then write down the i permutations: 
(g(1) ... y(6), «y(l))2 ... (y(6))2), ... , and «(y(1))i ... (y(6))i). Are these all 
of the possible permutations on six numbers',' 
11. Given a permutation p = (a[ a2 ... an), an adjacent transposition is the 
switching of two items in positions i and (i + 1) for some value of i = 
1, 2, ... , 11 -
1. For example, (a2 Ll t 
, .. a,,) is the result of applying an 
adjacent transposition to p as is (a[ (/2 ... an (/n-[)' Given permutatiom 
p and pi we define the distance between them to be the minimum number of 
adjacent transpositions needed to transform one into the other; we denote thi~ 
by dip, pi). Determine the following values of dip, pi): 
(a) p=(1 234) 
p'=(43 2 I) 
(b) p = (1 2 3 4) 
pi = (3 1 4 2) 
(e) p=(3 214) 
p'=(1 324). 
12. We define a permutation p to be either even or odd according as dip, p*) i~ 
an even or an odd number when p* is the identity permutation < 1 2 3 .,. n). 
Determine which of the four nonidentity permutations of the previous problem 
are even and which are odd. 
13. For which permutation p on : 1,2,. .. ,n} is d(p,p*) the largest when p* is the 
identity permutation? Also, what is the value of £1(1', p*) for this permutation? 
14. How many even and how many odd permutations are there on : 1,2, ... , Il :.) 
Prove your answer. 
15. Modify the algorithm PERM so that it outputs only even permutations. 
160 

3:5 AN APPLICATION OF PERMUTATIONS: THE GAME OF MASTERMIND 
16. Design an algorithm that upon input n, a positive integer, lists all permutations 
of [ 1,2 .... ,II: without first listing all permutations on { 1,2, ... ,n -
I}. (Hint: 
Look at the order of the output of PERM and see if there is a way to move 
directly from one permutation to the next.) 
17. Prove that III :0; nil and thus show that nil is a new candidate for the biggest 
function in the hierarchy. 
18. Find a function I(Il) such that I(Il) i= O(nll). 
19. Let P be the positive integers and suppose that we define a permutation of 
P to be a reordering of P. If f is a function with domain and target p, what 
properties must I have so that a listing of its range <I( I) I(2) ... ) ;5 a 
permutation (or reordering) of P? 
20. There are nl different ways to make a straight line of 11 people. Suppose in-
stead that 11 people are seated at a circular table and two seating arrangements 
are considered the same if everyone has the same person on their left side and 
the same person on their right side. How many different seating arrangements 
are there? Suppose that two arrangements are considered the same if everyone 
has the same set of two people on their left and right, but which side doesn't 
matter. Then how many different seating arrangements are there? 
3:5 AN APPLICATION OF PERMUTATIONS: 
THE GAME OF MASTERMIND 
We turn to some colorful "near" permutations that arise in the game of Master-
mind. Mastermind is a two-person guessing game that is usually played without 
special knowledge of permutations and set theory. As you read this section, you 
might consider whether mathematical training helps in playing this game. 
Mastermind is played as follows. The first player secretly writes down a list 
or code of four colors, chosen from red, yellow, green, blue. purple, and white. We 
denote the set of colors by 
C =: r, y, q, h, p, wi 
where each initial stands for the color beginning with the same letter. Repetitlons 
of colors in the secret list are allowed. Then the second player tries to guess the 
colors and their order in the secret list. 
For example, suppose that I choose 
as my secret list. Then when you guess a list of four colors, I must tell you two 
pieces of information. First I must tell you how many of your colors are correct 
and in the right position. Next I compare the remaining colors in my secret code 
161 

3 ARITHMETIC OF SETS 
Table 3.3 
Guess 
r b r b 
b y b II 
Position and Color 
Correct 
C%r Correct: 
Position Incorrect 
o 
and in your guess and tell you how many of these colors match correctly but are 
in the wrong position. Two guesses and responses are listed in Table 3.3. 
To use the language of set theory, both the secret code and all guesses come 
from the Mastermind universe, which is the Cartesian product C4 . When player 
2 makes a guess, that is, selects an element from C4 , player 1 produces f(guess), 
where f is a function whose domain is C4 and whose target is to, 1,2, 3,4}2 Thus 
the image of qny particular guess is an ordered pair of integers as described above. 
Example 5.1. 
The answers to some possible guesses of a secret code are listed in 
Table 3.4. 
Table 3.4 
Guess 
r r r r 
y y y y 
if g II if 
b b h b 
p p p P 
IV IV IV IV 
Position and C%r 
Correct 
() 
1 
() 
Color Correct: 
Position Incorrect 
() 
o 
() 
() 
o 
() 
Question 5.1. 
Figure out the four colors involved in the secret code of Example 
5.1. Can you tell what their order is? 
Example 5.1 (continued). 
Some more guesses and answers about the secret code 
in Example 5.1 are shown in Table 3.5. 
Table 3.5 
r v h IV 
1 
r y 
IV h 
() 
4 
r w y h 
3 
IV r 
V h 
() 
4 
162 

3:5 AN APPLICATION OF PERMUTATIONS: THE GAME OF ;vtASTERMIND 
Question 5.2. 
Can you determine from the information in Example 5.1 what the 
secret code is? If not, try to figure out as many of the correct color positions as 
possible from these answers. 
Question 5.3. 
Find a classmate, roommate, or any willing souL and play six games 
of Mastermind in three of which you pick the secret code and in three of which 
you try to guess the secret code. How many guesses were needed in each game? 
Experienced Mastermind players can figure out the secret code in four or 
five guesses. Their strategy combines a knowledge of good initial guesses plus close 
logical analysis of the responses to these. We develop some strategies of our own 
now. One strategy would be to repeatedly pick elements of C4 at random until 
an answer of (4, 0) results. Since there are six colors and four positions to fill with 
repetitions possible, there are 64 = 1296 different possible Mastermind codes. Thus 
random guessing will not be an effective playing strategy! We shall describe a 
method that can determine the list of colors with only six guesses. 
An effective playing strategy for this game (and any game) is just an algorithm 
that tells us what to do in any possible situation. We shall develop three different 
strategies for Mastermind. We begin with one that comes from the idea behind 
the guesses used in Example 5.1. 
Problem. 
To determine the secret list of colors in a Mastermined game. 
Algorithm 1 
STEP l. For each color x in {r,y,g,b,p, w} guess x x x x. 
STEP 2. (Now that you know the colors in the list) guess all possible lists 
using the four (or fewer) colors involved. 
Notice that both steps 1 and 2 really involve several steps. Step I is shorthand 
for six steps or six guesses. 
Question 5.4. 
Suppose that you learn in step I that the colors involved are green, 
blue, purple, and white. How many different secret codes are there involving these 
colors? How could you go about writing down all of these possible lists? 
In fact, when we discover that the code involves four different colors. then the 
code is one of the permutations of these colors. But what happens when there are 
repeated colors? 
Example 5.2. 
Suppose that the colors involved in the secret code are green. olue. 
and purple and that green occurs twice. Then the code will be a "near" permutation 
of [g, g, D, p}, that is, an ordered list of these letters including two !J's. (A "~eal" 
163 

3 ARITHMETIC OF SETS 
permutation is an ordered list of distinct elements.} A set with repeated elements 
is known as a multiset. However, our counting and algorithmic techniques will 
solve this case too. In each code word the g's will occupy two positions, for ex-
ample, the first and the third position. We associate their positions with the 2-subset 
(in this instance [1,3}) of the four possible positions P = [1,2,3,4}. Conversely, 
every 2-subset of P gives us a prescription for where to place the g's. Thus there 
are (~) ways to fill in the ~/s into a color code. The remaining two places can be 
filled with first b and then p or with first p, then b. Thus the total number of codes 
'.r 
b 
\. (4) ') 
I') 
usmg 19, g, 
, P J IS 
2 . - = 
~. 
Furthermore, PAIR and JSET, with It = 4 and j = 2, provide a list of all 
2-subsets of the 4-set P, and from these we position the g's. Then each of these 
leads to two code words by filling in band q in the two possible orders. For ex-
ample {1,2} leads to 9 9 b p and 9 9 P b. 
Question 5.5. 
List all possible codes formed from [g, g, b, p}. 
Question 5.6. 
Look back at Algorithm 1. What is the maximum number of steps 
or guesses that you will need in step 2'! 
The total number of guesses needed in Algorithm 1 is rather large, and you 
probably can think of better ways to play. Here is another approach that may 
more closely resemble how you and most people play Mastermind. The idea is to 
focus on the set of all possible codes, then on a subset of this set, and on a subset 
of the subset until the subset is pared down to one code. 
Algorithm .: 
STEP 1. 
Let L = [all possible Mastermind codes J 
STEP 2. Repeat 
Begin 
STEP 3. Pick an element from L to be your guess 
STEP 4. Update L [remove from L all those codes that are incon-
sistent with the response to your guess: 
End 
Until your guess is correct 
STEP 5. Stop. 
COMMENT. 
The form of step 2, "Repeat ... Until .. ." is like the While ... do loop, 
only the condition for ending the loop is checked at the end of the execution of the 
loop. 
164 

3:5 AN APPLICATION OF PERMUTATIONS: THE GAME OF :vIASTERMIND 
Algorithm 2 requires a lot of work. Initially, the list L in step 1 has 1296 codes 
in it, and the checking and updating will be time-consuming. Neither this approach 
nor that of Algorithm 1 would be so bad for a computer to implement, since we 
can use the computer's large memory and quick access to it to play the game 
effectively. 
Here is a third approach, possibly effective for use by both humans :md 
computers. 
Algorithm 3 
STEP 1. Make the following four guesses: 
r r y y 
r !J r y 
h h p P 
h w h w 
STEP 2. Create L, a list of all possible Mastermind codes that are consistent 
with the answers you receive from the first four guesses 
STEP 3. Repeat 
Begin 
STEP 4. 
Pick an element from L to be your guess 
STEP 5. U pdateL: remove from L all those codes that are inconsis-
tent with the response to your guess} 
End 
Until your guess is correct 
STEP 6. Stop. 
Try playing a few games using this algorithm. You will be surprised at how 
small the list L is that you create in step 2. In fact, we claim that after at most 
one more guess you can always figure out the secret list: so, in a total of six 
guesses you will have the answer nailed down. (See Supplementary Exercise 15.) 
There are a few ideas that can be derived from thinking about and pla)ing 
Mastermind. At first you might wonder why we bother to create a formal algorithm 
to play the game. We all can quickly learn effective guesses to make, and so why 
not play just using these hunches and logical deductions? In fact. that's how most 
of us do play this and many other games. But as soon as we turn the process 
around so that the computer is making the guesses, then it becomes essential to 
have an algorithm so that the computer has a way to proceed. If we stan to 
analyze how we play the game, we soon see that we have lots of different strategies 
that we adapt according to the responses. It would he quite a feat to design an 
algorithm that would accommodate all the different possibilities that the mind 
thinks up. In fact, it is quite impressive how clever and logical the human mind is. 
165 

3 ARITHMETIC OF SETS 
Instead of trying to simulate the logical working of a human brain, we have 
chosen very straightforward algorithms that could be programmed easily and that 
will lead to success with a relatively small number of guesses. We have also 
exploited the fact that the computer can do lots of checking rather quickly. You 
are invited to write (or find a friendly computer programmer to write) a program 
using Algorithms 2 or 3, and then to race the computer to see who is faster! 
EXERCISES FOR SECTION 5 
1. Find a solution to each of the following Mastermind games given the indicated 
guesses and answers: 
Position and Color 
Color Correct: 
Guess 
Correct 
Position Incorrect 
(a) 
r b r b 
0 
0 
w y w y 
0 
0 
fJ P 9 P 
3 
0 
9 9 P 9 
0 
:2 
(b) 
r b r b 
:2 
0 
w w y y 
0 
:2 
r b y w 
1 
3 
Y b ,. w 
0 
4 
(c) 
r y w b 
9 b p w 
0 
r y p w 
:2 
0 
y 9 b p 
0 
0 
w r w r 
I 
2 
(d) r r y y 
0 
0 
r 9 r 
(j 
0 
0 
b b p p 
:2 
0 
b w b w 
w p w p 
:2 
2 
(e) 
b (j p r 
0 
4 
r p 9 b 
2 
2 
r 9 p b 
I 
3 
r p b fJ 
I 
3 
r b fJ P 
0 
4 
2. Explain why there are no solutions to the following guesses and answers: 
(a) 
r b r h 
0 
Y fJ .II !J 
0 
P w P w 
() 
I 
r v p w 
3 
166 

3:5 AN APPLICATION OF PERMUTATIONS: THE GAME OF MASTERMI;\IO 
(b) 
r 9 h h 
2 
:2 
b 9 r b 
1 
3 
9 r h h 
0 
4 
(c) 
b r 9 b 
0 
3 
Y v P w 
() 
y r 9 b 
:2 
r b y b 
:2 
3. Suppose you learn that there are two colors, green and blue, in the code word. 
How many code words are possible? List them all. 
4. Write a list of four Mastermind guesses and responses for which there are (a) 
no solutions, (b) one solution, and (c) two or more solutions. 
5. How many Mastermind codes begin with r'? How many Mastermind codes 
begin with r and contain no other r? How many Mastermind codes begin with 
r and contain another r? 
6. How many possible codes are there for which the response to the guess 
r b b b is 0 (color and position correct) and 1 (color but not position correct)? 
7. List all Mastermind codes formed from:p,p,y,b}. Then do the same for 
{p,p,y,y}. 
8. Associated with the game of Mastermind is a function f: C4 --> : 0, 1,2,3,4-} 2 
as described in this section. What is the range of f? 
9. Answer the following questions (without listing all possibilities.) Suppose that 
we playa version of Mastermind in which we pick a code of length 5 from 
the same set of six colors. Otherwise, all the rules are the same. 
(a) How many possible code words are there? 
(b) How many code words are there in which the five colors {r, b, g, y, p} each 
appear once? 
(c) How many code words are there if the colors {r, b, g} each appear once and 
w appears twice? 
(d) How many code words are there if the colors [r, b} each appear once and 
p appears three times? 
to. How many code words are consistent with the following set of guesses and 
responses? 
r r y y 
I 
() 
r q r 9 
0 
0 
h h p p 
() 
h w h w 
:2 
1 
11. Define a new game called Trivialmind in which only three colors are used 
(red, blue, and white) and the secret code consists of a list of only two colors. 
How many different secret color codes are there in Trivialmind? 
167 

3 
ARITHMETIC OF SETS 
12. Describe a variation on Algorithm I that will work for Trivialmind. What is 
the maximum number of guesses that will be made using this algorithm'? 
13. Describe a variation on Algorithm 3 that will work for Trivialmind. Using this 
new version of Algorithm 3, how many guesses will player 2 need to guarantee 
a correct guess? 
14. Show that no algorithm will in all cases correctly solve Trivialmind with three 
or fewer guesses. 
15. The point of this exercise is to improve Algorithm 1. In step I we guessed 
x x x x for each x in {r.y,g,b,p, w}. Figure out a way to reduce these six 
questions to five. Now suppose that we know the colors present in the secret 
code and their frequency. Suppose that the color x is present (at least once) 
and that the color::: is missing. Notice that at least two colors must be missing. 
What can you learn from the following four questions: 
- - - x 
- - -
- - x -
- -
-
- x ::: 
::: 
-
x - - -? 
- -
Can you learn this same information with only three guesses? Using these 
ideas, try to devise an algorithm along these lines with as few guesses as pos-
sible. How many guesses do you make in general? 
16. Pick a mastermind code and apply Algorithm 3. How large is your initial 
list L? 
17. Suppose that you guess r h r b. How many different responses are possible? 
If you guess r b r IV, how many different responses are there? What is the 
minimum number of different responses to any Mastermind guess? What are 
the guesses that produce this minimum? What is the maximum number of dif-
ferent responses to any Mastermind guess? What are the guesses that produce 
this maximum? 
3: 6 THE BINOMIAL THEOREM 
This chapter concludes with a result that unifies a variety of facts about binomial 
coefficients. We know, for example, that the sum of the binomial coefficients C;) 
for i = 0,1, ... ,n equals 2n, and from Exercise 3.10 we know that the sum of the 
"'even" binomial coefficients (;j) for j = 0, I, ... , Ln/2 j equals 2n -
I There are 
many other similar identities lurking around, waiting to be discovered. 
168 

3:6 THE BINOMIAL THEOREM 
Question 6.1. 
For 11 = 3,4. and 5 verify that 
(~) -G) + C) -C) + ... + ( - l)i C) + ... + ( - 1)" C) = o. 
Question 6.2. 
Verify that 
G) + G) + G) = G)' 
In general, the sum of the binomial coefficients 
G) + G) + ... + G) + ... + C) 
can be expressed as a single binomial coefficient G)' For 11 = 5 and 6 find such 
a binomial coefficient C). Then for arbitrary 11 find ~ and j so that 
G) + G) + ... + G) + ... + G) = G)' 
(Here j will be a constant and k will depend upon 11.) 
Example 6.1. 
We review some polynomial arithmetic: 
(1 + x)2 = I + 2x + x 2 
(l + x)3 = I + 3x + 3x2 + x J 
(1 + xf = I + 4x + 6x2 + 4x 3 + x". 
Notice that the coefficients in the expansion above of (1 + .'d are exactly the 
numbers in the kth row of Pascal's triangle. Thus the coefficient of Xi in (1 + x)" 
appears to be the binomial coefficient C;) for () :s; i :s; 11. 
Example 6.1 sets us on the right track. We prove the suggested result and 
find that the answers to Questions 6.1 and 6.2 and much more follow from the 
so-called Binomial Theorem. 
Theorem 6.1. The Binomial Theorem. 
For 11. a natural number. 
(11') 
(11\) 
(11)' 
(11) . 
(Il) 
(1 + X)" = ,0 + \ '. x + 2 x- + ... + \ i 
Xl + ... + Il x". 
169 

3 ARITHMETIC OF SETS 
Proof. 
We prove this theorem by induction on n. When n = 0, 
(l + x)o = 1 = (~). 
When n = 1. 
(l +X)l =(1 +X)=G)+C)x. 
(You might check the cases of 11 = 2 and 3 to make sure that the statement of the 
theorem is clear.) 
The inductive hypothesis is that 
From this we must determine (1 + x)k + 1. By factoring, 
by the inductive hypothesis, 
by multiplying first by 1 and then by x. 
Now we must collect like terms together. That is, first we find the constant 
term, the coefficient of xo. It is just C) = 1 = e 
~ I). since all terms in the 
k) 
second bracket involve x. What are the terms involving xl = x'? We have (I x 
and (~) x, from the first and second bracket, respectively, or 
('k\ 
(k\ 
(ik + I) 
\I)x+ \ojx=(k+!)x= \ 1 
x. 
170 

3:6 THE BINOMIAL THEOREM 
In general, what are the coefficients of xi? In the first bracket we have (~) Xi and 
in the second bracket we have. 
XL. Thus III the sum we have 
( 
k ) . 
. 
1-1 
by Corollary 2.2. 
Finally, the term Xk+ 1 appears only in the second bracket and we have 
(k) 
k + 1 _ 
k + 1 _ (k + 1) k + 1 
k x 
-x 
-
k+l x 
. 
For comparison we offer the following. 
Second proof of Theorem 6.1. 
We want to determine the expansion of (l + x)n 
as a polynomial: 
(1 + x)" = ao + a l x + ... + a/ + ... + anxn. 
That is, we want to determine the coefficients elO,a 1, •.. ,an. Now 
(1 + x)n = (l + x)(1 + x) ... (l + x), 
a product of n identical factors. A term in the product results from every way of 
selecting one element (either 1 or xl from each pair of parentheses and multiplying 
them together. For example, if we select 1 from the first parenthesis, x from the 
second and third, and 1 from all the rest, we multiply these to get the product x 2 . 
Thus this selection contributes 1 to el 2 , the coefficient of x 2 . Suppose that we 
designate this choice by an n-vector with a zero in the entries where we select a 
1 (= xO), and a one in the entries wher;e we select an x (= Xl). Thus in our example 
we designate our selection by the vector (0, 1, 1,0,0, ... ,0). Then the number of 
ways to choose elements one from each parenthesis, to multiply together and get 
x 2 is the same as the number of bit vectors with two ones and (n -
2) zeros. From 
Example 3.2 we know that the n urn ber of such vectors equals (;), and so a 2 = (;). 
In general, ai' the coefficient of XL in the expansion of (1 + x)n equals the num-
ber of ways to select i xs and (n -
i) 1 s, one from each of the Il sets of parentheses. 
This number equals the number of bit vectors with i ones and (n -
i) zeros or (: ~) 
as we saw in Example 3.2. 
IJ 
171 

3 ARITHMETIC OF SETS 
Notice that Theorem 6.1 gives us a polynomial identity, that is, an equation 
that is true upon substitution of any real value of x. We now substitute different 
values for x and see what happens. 
Example 6.2. 
Substituting x = 1 in the Binomial Theorem shows that 
2/1 = (1 + 1)/1 
(Il) 
(11) 
(n) 2 
(11) 
II 
= 0 + 11+ 21 + ... + 
11 1 
= C) + e) + ... + C)' 
the same result as in Corollary 3.2. 
Example 6.3. 
Substituting x = - 1 in the Binomial Theorem leads to 
o = (1 -
1)" 
if n > 0 
= (~) + G)( -1) + C)( _1)2 + ... + (;:) -1)/1 
= (~) - C) + C) -C) + ... + ( - I)" (;:), 
a phenomenon we observed in Question 6.1. Notice that we may rearrange the 
last equation to read 
(~) + C) + C) + ... = C) + C) + G) + .... 
Since the sum of the left-hand side plus the right-hand side equals 2/1, we see that 
each side separately equals (1)(2") = 2"-1, a result that we noted in the first para-
graph of this section. 
How does Question 6.2 relate to the Binomial Theorem'? We can't obtain the 
result suggested there by merely substituting in a number for x. but we can use the 
Binomial Theorem to derive it. We have previously seen in Chapter 2, Example 3.3, 
another polynomial identity that gives the sum of a (finite) geometric series: 
I 
/1+1 
., 
i 
tI 
-
x 
I +x+:c+"'+x +"'+x = .-~~­
I-x 
Since this is an identity that holds true for all x, except for x = I, we can substitute 
both values and expressions for x, and the equation still holds true. For example. 
172 

3:6 THE BINOMIAL THEOREM 
if we substitute (1 + x) for x everywhere in the geometric series we get the re:;ult 
that 
1 + (l + x) + (1 + X)2 + ... + (l + xli + ... + (1 + x)" 
l-(I+xt+ 1 
1 - (I + x) 
1 - (I + x)n+ 1 
-x 
(1 +x)"+I-1 
provided x i= 0 
for x i-' O. 
(*) 
This result tells us that if we multiply out both the right-hand side and the left-
hand side of equation (*), then the resulting polynomials are the same. 
In particular, let's look at the x 2 term on both sides of equation (*). On the 
left-hand side at first there are no x 2 terms, but then x2 appears in the expansion 
of all the terms from (1 + .xl' on up to (1 + XI". By the Binomial Theorem, here 
are the x 2 terms: 
_ 
., 
j 
') 
I., 
11.., 
(
'"' \ 
. 
~ ) 
( .) 
( ) 
2 J:c + (2 :c + ... + 2 x· + ... + 2 x· 
= [G) + G) + ... + G) + ... + (;) lx
2
. 
The x 2 term on the right-hand side of (*) will result from dividing the .x.l term of 
the numerator by the x in the denominator. By the Binomial Theorem the x 3 term 
(
II + I) 
of [(1 + x)"+ 1 -
lJ is \ 
3 
x3. Thus 
Since 1*) gives two expressions for the same underlying polynomial, the co-
efficient of x 2 on the left and on the right must be the same, that is, 
or 
(2) (/3\ 
('i) 
('n') 
('iJ+l\ 
2. + 2) + ... + 2 + ... + \2. = 
. 3 j' 
173 

3 
ARITHMETIC OF SETS 
There is another more general form of the Binomial Theorem that gives the 
expansion of a polynomial with two variables: 
This result can be proved in essentially the same way as Theorem 6.1. 
A common problem in combinatorial mathematics is to count objects with 
specified properties, for example, to count the number of j-subsets of an n-set. 
Sometimes a neat formula can be obtained; other times the answer can be derived 
from a polynomial identity. One often can deduce that the answer to the problem 
is, say, the coefficient of x j in a certain polynomial. We have seen that the number 
ofj-subsets of an n-set is the coefficient of xj in the polynomial (1 + .\f Such poly-
nomial solutions are known as generating functions. The use of generating func-
tions is a powerful technique with wide application. In this section we have seen 
an introduction to the methods and use of generating functions. 
EXERCISES FOR SECTION 6 
1. Expand (1 + x)5 and (1 + x)6 and check that the coefficients are the binomial 
coefficients promised by Theorem 6.1. [Reminder: Do you really have to mul-
tiply (1 + x) by itself four and five times, respectively?] 
2. (a) Find a simple formula for 
and for 
('n) (n\ 
(11) 
,(n) , 
('11') 
0-
1)2+ \2
4 -"'+(-1)' I 2'+"'+(-I)n\1l 2n. 
(b) Prove that if 11 is even, then 
(11) 
(11) 
('11) 
(n\r 
0+\2 4 + 4
16 +"'+ n)4
n11 =-2-' 
3. Use the Binomial Theorem to derive the expansion of (l + l/x)n. 
4. [n each of the following, first verify the equation by selecting a value for r, n, 
and m and checking the equation for these values. Then prove the general 
result about sums of binomial coefficients. 
174 

3:6 THE BINOMIAL THEOREM 
5. (a) For r S 5, verify that 
(b) Now we want to show, in general, that for r less than or equal to both 
m and 11, 
It is clear that (1 + ;IT(l + xt = (1 + x)m+n. Use the Binomial Theorem 
to find the coefficient of xr in (1 + x)m+n. Then use the Binomial Theorem 
to expand (1 + x)m and (1 + x)n and determine the coefficient of xr in the 
product 
From these results, conclude that the previous equation holds. 
6. Explain why 
xn 
1 )n 
+ -
and 
x 
Then find the constant term (the coefficient of xo) in (1 + x)n (I 
(1 + '()zn 
tind the constant term in the expansIOn of 
n 
. See Supplementary 
x 
Exercise 17 for an application. 
7. Prove the general form of the Binomial Theorem that gives the expansion of 
(y + xJ". 
175 

3 ARITHMETIC OF SETS 
8. Find a simple formula for the sum of the binomial coefficients 
G) + G) + ... + G) + ... + C)' 
Next prove the formula using the ideas of the solution to Question 6.2. Then 
find and prove a formula for the sum 
(k) (" + 1) 
(i\ 
(11) 
,,+ 
" 
+ ... + k) + ... + " 
for k ::;; n. 
3:7 IMPORTANT SUBSETS 
The most important ideas in this chapter are those about sets: j-subsets, permuta-
tions. and the counting of these sets. It is worth repeating that this set theory 
along with that in Chapter 1 is a crucial element in all further study of mathematics. 
computer science. and algorithms. The new counting functions, the factorial and 
the binomial coefficients. will appear frequently. Already the latter have given us 
the number of j-subsets of an n-set, the number of shortest paths in a rectangular 
grid, the number of n-bit sequences with a specified number of ones. and the 
coefficients in the expansion of (1 + X)". We shall meet these functions in every 
future chapter; we shall use the subset and permutation ideas repeatedly and with-
out further ado. To be honest. Mailmobiles haven't caught on with quite the 
popularity initially expected. but the path counting problem is a classic. 
The algorithms of this chapter. JSET and PERM, are of more than illustrative 
value. They are used repeatedly, for example. in Mastermind and in more serious 
applications in Chapter 5. In these algorithms we introduced nested loops and 
Boolean variables. Although these algorithms and algorithmic techniques are more 
complex than those of the previous chapter. they were selected for their relative 
simplicity. The "state of the art" algorithms for generating subsets and permuta-
tions are more sophisticated and a little more efficient. However, no amount of 
trickery can get around the fact that generating all permutations of an n-set and 
all subsets of size LI1/2 J requires an exponential amount of work. 
This study of counting, generating, and listing objects of a certain size provides 
an introduction to the areas of combinatorial analysis and combinatorial algor-
ithms. In these modern and fast-growing fields. a typical problem involves counting 
all objects with a particular structure and listing them in a certain order. The 
counting task is often solved using functions like the binomial coefficients and 
techniques like generating functions. The listing is frequently done by imposing 
an order on the structure such as lexicographic order. 
176 

SUPPLEMENT ARY EXERCISES FOR CHAPTER 3 
In Chapter 5 we shall focus on finite sets and their 2-subsets, an area known 
as graph theory. The study of orderings. both constructing them and searching 
them, is the subject of Chapter 6. 
SUPPLEMENTARY EXERCISES FOR CHAPTER 3 
1. Given the rectangular grid shown here how many different shortest paths 
join the vertices labeled Rand S? How many different shortest paths are there 
from R to S that do not go through the vertex labeled P? How many shortest 
paths are there from R to S that do not go through either the vertex labeled 
P or the vertex labeled Q? 
s 
Q 
p 
R 
2. How many 4-subsets of p, ... ,8} contain the number 3'1 How many contain 
5? How many 4-subsets contain either 3 or 57 
3. Count the number of to-digit ternary numbers (i.e., numbers that use only 
the digits 0, Land 2). How many of these contain exactly four zeros? How 
many contain exactly four ones? How many contain three zeros and three 
ones? 
4. Find a formula for the number of II-digit ternary numbers that contain i zeros 
and (n -
i) ones and twos (combined). How many contain exactly i zeros and 
j ones when i and j are positive integers with i + j ::; II? 
5. The number of n-Ietter "words" made up from the letters ii, /J, and c is the 
same as the number of IJ-digit ternary numbers-why? How many 11-letter 
words are there with i a's, i h's and (n -
i - j) c's'? 
6. (a) Is the following true or false'! (2n)! = 2" . Il! Explain. 
(b) For an odd number (2n -
I) we define the odd factorial 
(211 -
1)0! = (2n -
1)(2n - 3)'" 
. 3· 1. 
Thus (3)0! = 3 . I = 3, and (5)0! = 5·3· I = IS. Calculate (7)0' and (9)0!. 
177 

3 ARITHMETIC OF SETS 
(c) Explain why the following new formula is correct: 
(
211) = 2n . (211 - 1 )O! . 
11 
II! 
(d) Show that (2n - 1 )0!/11! < 2n and then deduce that Cl1n) = OW). 
7. Define the even factorial (2n)E! in a way analogous to the odd factorial 
(2n -
1)01. Then find a formula that relates (2n)E! and 11!. 
8. Reread Exercise 2.12 where the factorial representation of a number is defined. 
Then prove that every positive integer has a unique factorial representation. 
9. Find an algorithm that with input n, a positive integer, outputs the factorial 
representation of n (see Exercise 2.12 and the previous exercise). 
10. In checkers, how many different paths (of legal moves) are there from the 
rightmost square in your back row, to your opponent's back row? Recall that 
checkers is played on an 8 x 8 board; your pieces begin only on the black 
squares and your pieces can only move forward on a diagonal. 
11. (a) Recall that each j-subset of {I, 2, ... ,n} corresponds with a binary se-
quence with n bits, exactly j of which are Is. Given two subsets, say Sand 
T, with S listed before T in lexicographic order, which of the binary se-
quences is larger (when considered as numbers)? 
(b) Design an algorithm that will produce all the j-subsets of an n-set in lexico-
graphic order by manipulating the bit vectors. 
12. Let In = {I, ... ,n} and j be fixed. Define 
u = {B: B is a j-subset of In that contains 1) 
and 
v = (B: B is a j-subset of In that does not contain I}. 
Which of U and V is the larger set? 
13. Let Io = {I, 2, 3, 4,5,6}. How many permutations of Io have the even numbers 
in their correct positions (i.e., 2 is in the second position, etc.)? How many 
permutations of Io have the even numbers in even-numbered positions'! 
14. How many numbers from 1000 to 3000 have their digits all in the set 
[1,2,3,4,5}? How many such numbers have no repetitions in their digits? 
15. Show that Algorithm 3 from Section 5 will always work in at most six guesses. 
(Hint: One way to verify this is using a computer search.) 
16. Find an algorithm for Mastermind that uses at most live questions in all cases. 
178 

SUPPLEMENTARY EXERCISES FOR CHAPTER J 
(Warniny: The solution to this problem is hard enough so that it has been 
written up in a journal.)* 
17. Guess a formula for (~r + cr + ... + (~r· Prove your guess. 
18. How many multiplications are needed to calculate n!? How many multiplicJ.-
tions and divisions are needed to calculate C)? 
(n) 
19. For j s L n/2 J, find a way to calculate j 
using at most 2j - 2 multiplications 
and divisions. 
20. Prove the following identity: C) = (n/i) C = n· Here IS another way to 
calculate C): 
(
n - i + 1) 
. 
1 
= n -
I + 1, 
(n - ~ + 2) = n - ~ + ~ (n - ~ + 1) 
(n - ~ + 3) = n - ~ + 3 C -~ + 2) 
(n - i + i) (n) 
. (11 - 1) 
. 
. 
=. = (n/I) 
. 
I 
I 
I-I 
, 
, 
using no multiplications or 
divisions 
by the identity above 
by the same identity 
by repeated application of the 
identity 
Using this approach, determine the number of multiplications and divisions 
used to calculate (~). Compare this result with your answers in the previous 
two exercises. 
21. Use the results of Exercise 4 to find the expansion of (1 + x + y)", That is, 
write this as a polynomial of two variables: 
ao,O + al,Ox + aO,lY + at.lxy 
+ a? 
X2 + (/ 
112 + ... + a. x j vk + ... 
_.0 
O.V 
1,k 
. 
and find a formula for each coefficient (/j,k' where j + k :::;; n. 
* Donald Knuth. "The Computer as Master Mind", Journal oj Recreational Mathematics, 
Vol. 9(1),1976-17, pp. 1-6. 
179 

3 ARITHMETIC OF SETS 
22. If (I + , + ,2t is expanded as 
then find an expression for each coefficient hi' 
23. Reread the definition of even and odd permutations in Exercises 4.11 and 
4.12. Prove that for a permutation p, dip, p*), where p* is the identity permuta-
tion, is even if and only if every number of transpositions that transform p 
into p* is even. 
24. If p = (51 05 2 '" 
sn) is a permutation, we define Inv(p), called the number 
of inversions of p, to be the number of pairs (Si'S) such that i <j and Si > Sj 
for 1 ::;; i <j::;; n. Determine Inv(p) for each of the following; 
(a) (I 2 3 4 5 6) 
(b) (2 1 3 4 5 6) 
(c) (2 1 4 3 6 5) 
(d) (6 5 4 3 2 I) 
25. Prove that Inv(p) is an even number if and only if p is an even permutation. 
180 

4
NUMBER THEORY
4:1 GREATEST COMMON DIVISORS
In this chapter seemingly elementary questions from integer arithmetic lead to
surprising and elegant ‘mathematics. We shall look at divisibility properties of
integers, the greatest common divisor of two integers, and the Fibonacci  numbers.
These topics have aesthetic appeal and are applicable, as ‘we shall see, in crypto-
graphy.
Here are two problems on which we spent many (dull?) hours in elementary
school. Recall that a fraction a/b is simplified (or reduced) if a. and b have no
common factor greater than 1.
Problem 1.
Is the fraction a/b simplified? If not, simplify it.
Problem 2. Compute a/b + c/d and leave the answer simplified.
34567 Add and
Question 1.1. Simplify, if possible, th: following A, %1, %, S9 i,o I I.
simplify the following $ + ~, * + ~, D + 6
15.
You might wonder why we did these exercises in elementary school as well
as how we did them. Probably being dutiful and bright students, we just did them.
But why bother? Certainly, calculators remove the need to simplify fractions.
Try an experiment. Add ~ to itseff three times on a calculator. You might get
1 or you might get ,99999999 (depending on your calculator). In either case sub-
tract 1 from your total. Surprisingly enough you won’t get zero (unless your cal-
culator is fancy or broken). There are instances (you will see one in Section 7)
181

4 NUMBER THEORY
when we know quantities to be integers and want to retain the accuracy and
precision of integer arithmetic. Most computer languages give us the option of
exact arithmetic with integers, provided that the integers are not too large.
How did we do Problems 1 and 2? To find the sum of two fractions, most of
US would compute
ad + bc
;+;=
bd
and then simplify this fraction. Both problems require the ability to simplify frac-
tions. As a practical technique, most people would simplify the fraction a/b by
searching for integers that are divisors of both a and b. When such an integer, say
c, is found, they cancel c from both the numerator and the denominator to obtain
the smaller problem of reducing (a/c) /(b/c). This is fine if the numbers a and b
are smail or have common divisors that are easy to find, for instance, if both a
and b are even or both end in O or 5.
A slightly more sophisticated approach is to look for common divisors among
the primes, for if two numbers have a common divisor, then they have a common
prime divisor. An even better description of how to proceed is to find the greatest
common divisor of a and b and then cancel that number. Although this is better
as a description, if the numbers a and b are at ail large, we might be at a loss in
finding the greatest common divisor or, for that matter, any common divisor.
Question 1.2. Find the greatest common divisor of the pairs (a) (65, 130),
(b) (48, 88), and (c) (34567, 89101 1).
In this section we work out a straightforward, although slow, procedure for
finding the greatest common divisor of two integers. A more efficient algorithm
will be presented in a later section.
We begin with some precise definitions pertaining to integer arithmetic. If b
and c are integers, we say that b divides c (b is a divisor of c, and c is a multiple
of b) if c/b is an integer. Then as the name implies, the greatest common divisor
of two positive integers b and c is the largest integer that is a divisor of both b
and c. We denote the greatest common divisor of b and c by gcd (b, c).
Does every pair have a greatest common divisor? Any pair of positive integers
has 1 as a common divisor, and the largest number that could possibly be a
common divisor of b and c is the minimum of b and c. Thus the greatest common
divisor always exists and lies somewhere between 1 and the minimum of b and c.
Question 1.3. Find b and c (with b < c) such that (i) gcd (b, c) = 1, (ii) 1<
gcd (b, c) c b, and (iii) gcd (b, c) = b. Why is it impossible for gcd (b, c) to be larger
than the minimum of b and c?
182

4:1 GREATEST COMMON DIVISORS
Our first gcd algorithm, a brute force search, looks for gcd (b, c) starting with
the largest possibility, the minimum of b and C, and then checks each smaller
integer in turn until a common divisor is found. The first common divisor found
will be the greatest. The algorithm must stop, since 1 is a common divisor.
Algorithm GCD1
STEP 1. Input b, G set g := minimum of b and c
STEP 2. While g >1 do
Begin
STEP 3. If b/g and c/g are both integers, then output g and stop.
STEP4. Setg:=g–1
End
STEP 5. Output gcd = 1 and stop.
Question 1.4. Carry out GCD1 on the pairs (3,4), (3, 12), and (6, 20)
We judge the efficiency of this algorithm by the number of divisions (which
occur only in step 3). The exact number will depend upon b and c, and so we
carry out a worst-case analysis to obtain an upper bound. Our input to GCD 1 is
two integers b and c; suppose that b < c. We measure the size of the input by c
and let the complexity function ~(c) count the maximum number of divisions car-
ried out for any pair of numbers b < c. Two divisions are performed every time
step 3 is encountered. Step 3 will be executed with g = b, then g = (b – 1), then
g = (b – 2), and so on, until g has decreased down to the real gtd. Thus step 3
will happen most often when the gcd is 1. In this event we would encounter step
3 a total of b – 1 times, performing 2(b – 1) divisions. Then
f(C) < 2(b – 1)< 2(c – 1)< 2C
so f(c) = o(c).
We see that the number of divisions in GCD1 is linear in the size of the input,
and thus it seems to be an efficient algorithm.
Question 1.5. Find two positive integers b and c such that when GCD1 is applied
to them we find the following.
(a) The number of divisions is exactly 2(b – 1).
(b) The number of divisions is less than 2(b – 1).
(c) The number of divisions is as small as possible.
With GCD1 we can respond precisely to Problems 1 and 2. With a more
efficient gcd algorithm, we could upgrade our responses by replacing GCD 1. Here
is a solution to Problem L
183

4 NUMBER THEORY
Algorithm SIMPLIFY
STEP 1. Input a and b {The fraction a/b is to be simplified.}
STEP 2. Use GCD1 and set g:= gcd (a, b)
STEP 3. Set a’ := a/g and b’ := b/g
STEP 4. Output the fraction a’/b’ and stop.
Question 1.6. Write an algorithm ADDFRACT1 that solves Problem 2. Upon
the input of fractions a/b and c/d, it should calculate their sum and output that
sum as a simplified fraction. You may use the algorithm SIMPLIFY within
ADDFRACT1.
Question 1.7. Count the number of multiplications and divisions performed by
SIMPLIFY and by ADDFRACT1, including those in GCD1.
Previously, we have called linear algorithms fast and claimed that they were
more efficient than, say, quadratic algorithms. Although GCD 1 performs at most
O(c) divisions, it seems slow and inefficient on hand calculations. In fact, it is not
the approach that many humans would take to find the gcd of two integers, and
it doesn’t use any properties of integers that might speed up the process. In the next
sections we shall reexamine the complexit y of GCD 1 and the way we perform com-
plexity analyses. We shall find that GCD 1 is not an efficient algorithm, but we shall
develop a good gcd algorithm, one that performs O(log (c)) divisions in the worst
case upon input of integers b and c with b < c.
EXERCISES FOR SECTION 1
L Simplify the following fractions: (a) ~, (b) %, (c) ~, and (d) ~.
2. Combine the following into one simplified fractiom (a) & – ~ and
(b) & +&.
3. If both a/b and cjd are simplified, is (ad + bc)/(bd)  simplified?
4. If a/b is simplified, is a2/b2 simplified?
5. If a2/b2 is simplified, is a/b simplified?
6. Suppose that we find the lowest common denominator of a/b + cjd to be e,
and with this denominator we get a/b + c/d = f/e for some integer f. Is f/e
always a simplified fraction?
7. Trace GCDI on the following pairs: (a) (4, 7), (b) (4, 6), (c) (8, 10), (d) (8, 12),
(e) (15,35), and (j) (18,42).
184

4:1 GREATEST COMMON DIVISORS
8. Algorithm GCD 1 begins with g equal to the minimum of b and c and then
decreases g, searching for a common divisor of b and c. Design an algorithm
that instead begins with g = 1 and then increases g until the gcd is found. How
does the efficiency of this algorithm compare with that of GCD1?
9. Suppose that a, b, and c are three positive integers with a < b < c. We de-
fine gcd (a, b, c) to be the largest integer that divides all three numbers, a, b,
and c. Explain why gcd (a, b, c) < a. Design an algorithm that upon the input
of a, b, and c finds gcd (a, b, c). Find gcd (24, 68, 128), gcd (28,70, 98), and
gcd (1 12,148, 192).
10. Find pairs (b, c) such that when GCD1 is applied, the number of divisions is
exactIy (a) 12, (b) 16, and (c) b/2.
11. Given two integers b and c, the least common multiple of b and c, denoted by
Icm (b, c), is the smallest integer that is a multiple of both b and c. Find a pair
of integers b and c with b < c such that (i) lcm (b, c) = bc and (ii) lcm (b, c) = c.
Then explain why in all cases c < lcm (h, c) < bc.
12. Find the following Icm (2, 3), lcm (3,4), and lcm (6, 8). Then add and simplify
the fractions: $ + ~, ~ + ~, and $ + ~.
13. Calculate the following
(u) gcd(5, 7) and Icm (5, 7).
(b) gcd (4,9) and Icm (4, 9).
(c) gcd (6, 10) and lcm (6, 10).
(d) gcd (6,9) and lcm (6, 9).
(e) gcd (8, 12) and lcm (8, 12).
(~) gcd(5, 10) and lcm(5, 10).
14. Here is a proof that lcm (b, c). gcd (b, c) = bc. Give reasons for each step. {Let
g = gcd (b, c), b’ = b/g, c’ = c/g, and m = lcm (b, c).}
1. be/g is a multiple of b and a multiple of c
2. lcm (b, c) < be/g
3. gcd (b, c) ~ lcm (b, c) < bc
4. be/m divides both b and c
5. gcd (b, c) > be/m
6. gcd (b, c)” Icm (b, c) > bc
7. gcd (b, c) ~ Icm (b, c) = bc.
15. Given the following pairs of integers b and c, find g = gcd (b, c), b’ = b/g, c’ =
c/g, and lcm (b, c). Then check that lcm (b, c) = b’c’g. (a) 3 and 4, (b) 6 and 8,
(c) 4 and 6, (d) 3 and 9, and (e) 8 and 20.
16. Prove that lcm (b, c) = b’c’g, where b’, c’, and g are as defined in Exercise 15.
17. Find pairs (b, c) such that gcd (b, c) equals (a) 3, (b) 8, (c) b/2, (d) b/3, and
(e) V. Find pairs (b, c) such that lcm (b, c) equals (a) 14, (b) 29, (c) 2b, (d) 3b,
and (e) bz.
185

4 NUMBER THEORY
18. What can be said about the relation between gcd (a, b) and gcd (at, bt) where t
is any positive integer?
19. Prove that if a and b are positive integers and x and y are nonzero integers
such that ax + by = 1, then
gcd (a, b) = gcd (a, y) = gcd (x, b) = gcd (x, y) = 1.
Show that exactly one of the numbers x and y must be negative. [We can
define gcd (c, d), where one or both of c and d are negative with exactly the
same definition as for positive integers.]
20. If a, b, x, and y are nonzero integers such that ax + by = 2, is it true that
gcd (a, b) = 2?
21. Prove that if gcd (a, b) = 1 and if c divides b, then gcd (a, c) = 1.
22. Suppose that a = qb + r, where a, b, q, and r are integers. Is it true that
gcd (a, b) = gcd (a, r)? Is gcd (a, r) = gcd (b, r)? Explain your answers.
23. Here is the idea for another algorithm to add the fractions a/b and c/d. Set
g:= gcd (b, d), b’:= b/g, d’ := d/g, and m:= lcm (b, d). First calculate m by
m = bd[g. Then a/b = ad’[m and c/d = cb’/m (Why?) and a/b + c/d =
(ad’ + cb’)/m. Finally, simplify this last fraction. Implement these ideas as an
algorithm ADDFRACT2. How many variables does ADDFRACT2 use?
Count the number of multiplications and divisions performed, including those
of GCD 1.
24. Compare the algorithms ADDFRACT1 and ADDFRACT2 with respect to
number of variables used and number of multiplications and divisions per-
formed. Which uses less space and which is quicker?
4:2 ANOTHER LOOK AT COMPLEXITIES
We want to reexamine the complexity of algorithms, especially those from number
theory. In a formal analysis of an algorithm the size of the input should be mea-
sured by the number of bits (zeros and ones) needed to represent the input. For
number theory algorithms whose input is typicaily one or more positive integers,
the size of the input should be the total number of zeros and ones needed to
represent the input integers in binary notation. As before, we count the number
of time-consuming operations performed in the worst case of the algorithm (usually
multiplications and divisions for number theory algorithms) and express the result-
ing upper bound as a function of the number of input bits. In this section we
discuss the effects of this change of perspective on complexity analysis.
186

4:2 ANOTHER LOOK AT COMPLEXITIES
Why the change? There is a certain (bureaucratic-style) inefficiency built into
our previous approach to the analysis of algorithms. We measured how efficient
an algorithm was by estimating the number of steps it required as a function of
the input size. The problem with this is that if we are careless about measuring
the size of the input, that is, if we let it be artificially large, then the algorithm
might appear to take a correspondingly small number of steps. This is just what
happened in our study of GCD1 and the exponentiation algorithms of Chapter 2.
Measuring input size in terms of bits leads to complexities that reflect actual
running times.
Changing the input measure, to bit size, is not hard. Suppose that an integer
n is the input to an algorithm. As we saw in Section 2.6 the number of bits needed
to represent n is precisely
B = Llog(n)j + 1.
This formula gives the translation from n to B, and it implies the following useful
relationships.
log (n) < B < log(n)+ 1
<2 log(n)
for n >2.
(1)
Example 2.1. Suppose that algorithm A performs at most Clog(n) time-consum-
ing operations upon input of an integer n for some constant C. Then what can
be said about the complexity function as a function of B, the number of bits needed
to represent n? By (1)
Clog (n) < CB = O(B).
Thus in terms of the variable B, the number of time-consuming operations is a
linear function.
Look back in Section 2.6 at the complexity analysis of FASTEXP. There we
found that no more than 3 log(n) + 3 multiplications and divisions are needed to
compute x“. Using (1), we see that
310g(n)+3  <3B+3 = O(B).
In terms of input bits FASTEXP is a linear algorithm and so deserving of its name.
Question 2.1. Suppose that algorithms R, S, and T each have an integer n as
input, and their complexity functions are, respectively, (log (n) )
2, log (n2), and
log (log (n)). Find an upper bound on their complexity functions in terms of B, the
number of bits needed to represent n.
187

4 NUMBER THEORY
Example 2.2. Suppose that algorithm A performs at most C n time-consuming
operations upon input of an integer n for some constant C. Then what can be said
about the complexity function as a function of B, the number of bits needed to
represent n?
C n = C 210g ‘
n)
by properties of log
<C2B
using (1)
= 0(29.
Thus in terms of the variable B, the number of time-consuming operations is big
oh of an exponential function. Furthermore, if there are instances when .4’ uses
all C n operations, then
C n = C 2i0g ‘
n)
by properties of log
> c 2@/2)
using (1)
= C(J)B
> C(l.414)J3.
Thus A’ is an exponential algorithm.
The analysis in Example 2.2 shows why both the algorithms GCD 1 and
EXPONENT of Chapter 2 are bad algorithms. Since GCD1 has integers b and c
input, the number of bits needed to express b and c in binary is given by
log (c) < B = Llog (b)] + 1 + Llog(c)] + 1
<2 log (b) + 2 log (C)
forb>2
<4 log (c).
(2)
We know that GCD1 performs at most 2C divisions. From Example 2.2 we know
that 2C < 2(2B), giving an exponential upper bound. In addition, when b = c – 1,
gcd (b, c) = 1 (see Exercise 2). In that case GCD1 performs exactly 2(b – 1)= 2C – 4
divisions.
2C – 4 = 2(21”g@) – 4
by properties of log
> 2(2@/4) – 2)
from (2)
~ 2(2(W – I ) )
when B z 8
—— 2(*/A)
= (2(1/A))~
> (1.189)B.
188

4:2 ANOTHER LOOK AT COMPLEXITIES
Thus in the worst case GCD1 performs an exponential number of divisions in
terms of the input bit size.
Question 2.2. In Section 2.5 it was observed that EXPONENT always performs
n multiplications. If B is the number of bits needed to represent n in binary, explain
why EXPONENT is an exponential algorithm.
Since GCD 1 is now recognized to be bad, it is clear why we continue to
search for a faster algorithm. From now on we shall measure the input size by
the number of bits needed. This approach is standard in the study of algorithms
using Turing Machines.
EXERCISES FOR SECTION 2
1.
2.
3.
4.
Comment on the following statement: “Most of the time Llog(n)j  =
[log(n)l -1.”
Explain why gcd (c – 1, c) = 1 for all integers c > 1.
Let B = Llog (n)j + 1. For each function ~ listed in the table find the smallest
function g such that f(n) < g(n).
f(n)
g(B)
210g(n) – n
&m)
$&?))’ + 2 log(n)+ 1
Jog (.)
Jn
3n+3
n log(n)
n
2
n
3—n
2“
@
B
2B
B2
10B
2
&B
2
B
2(B+3)
B(2B)
22B
~B
~B
2(B2)
2(2B)
Let the input to algorithm A be an integer n. Thus the number of bits needed
is B = Llog(n)J + 1. Suppose that the complexity function for algorithm A is
a(n) = g(B).
189

4 NUMBER THEORY
(a) Show that if g(B)= O(p(B)), then a(n)= O(p(n)).
(b) Show that if a(n) # O(p(n)) for any polynomial p, then g(l?) # O(q(B)) for any
polynomial q.
(c) If a(n)= O(p(n)) for some polynomial p, is it true that g(n) = O(q(B)) for some
polynomial q?
5. In the algorithms SUBSET, JSET, and PERM we measured the input by the
integer variable n. If we translate now to the number of bits input, B =
Llog(n)j  + 1, do these algorithms remain exponential in the variable B using
the worst-case analysis? (See Exercise 4.)
6. Suppose that the input to an algorithm A is an integer n and suppose the size
of the input is measured by the number of decimal digits needed to express n.
Would this change of measure of input size change whether or not A is a good
algorithm?
4:3 THE EUCLIDEAN ALGORITHM
We have developed the simplistic (but bad) algorithm GCD1 to determine gcd (b, c).
Fortunately, there is a much more efficient algorithm that appeared in 300 B.C. in
Euclid’s Elements. This Euclidean algorithm is probably the oldest algorithm still
in use today. The Babylonians wrote down some precise arithmetic procedures
about 1500 years before Euclid, but these have all been replaced by more efficient
methods. The amazing fact about the Euclidean algorithm is that, except for
minor variations, it is the best (most efficient) aigorithm for calculating the greatest
common divisor of two integers. In this section we’ll learn the algorithm and in
subsequent sections the mathematics needed to determine its complexity.
Here is the idea behind the aigorithm.  Suppose that we are given positive
integers b < c and want to calculate gcd (b, c). If d divides both b and c [i.e., d is
a candidate for gcd (b, c)], then d divides c – b. Indeed if d divides c – b and b,
then it divides c also. What is the advantage of working with b and c – b instead
of b and c? Very simply, c – b is smaller than c.
Question 3.1. Find gcd (18, 30), gcd (18, 48), and gcd (18, 66).
If c – b is better than c, then c – 2b should be better still. While we’re at it, there
is c – 3b, c – 4b, and so on, to consider. Indeed why not subtract off as many bs
as possible subject to the condition that the remaining value is not negative?
Question 3.2. For each pair (b, c), find the maximum integer q such that c – qb >0.
(a) (24, 36), (b) (36, 120), and (c) (34, 170).
This question illustrates the general rule that the right number of bs to sub-
tract from c is the floor function of the quotient c/b. Thus we divide c by b to
190

4:3 THE EUCLIDEAN ALGORITHM
obtain an integer quotient ql and a remainder rl, where
11
c
91= ;
and
i =91+;.
We rewrite the previous equation in the form
c = qlb + r l,
(A)
and note that the remainder r ~ must satisfy O < rl < b. We call ql the quotient
and r ~ the remainder of the division c/b.
Here is an important fact about the numbers in (A).
Lemma 3.1. If b, c, q, and r are integers such that c = @ + r, then gcd (b, c) =
gcd (b, r).
Proof. Since an integer that divides b and c also divides b and r, gcd (b, c) divides
both b and r and so is at most gcd (b, r). Thus
gcd (b, c) < gcd (b, r).
An integer that divides b and r also divides c. Thus
gcd (b, r) < gcd (b, c),
and the lemma follows.
c1
Applying the lemma to line (A) @ves gcd (b, c) = gcd (rl, b).
Question 3.3. For each of the following pairs of numbers, determine q ~ and rl.
Check that (A) holds and that O < rl < b. Finally, compute gcd (b, c) and gcd (rl, b).
(a) (3, 12), (b) (13, 121), (c) (233, 377), and (d) (34567, 891011).
Notice that if in (A) rl = O, then c = qlb and gcd (b, c) = b. But if rl >0, then
we don’t have the gcd at our fingertips and consequently must do more work.
The problem is simpler now because we have smaller numbers. This technique of
replacing c by a smaller number, the remainder, worked once. Let’s do it again.
Thus we divide b by rl, a number smaller than b, to obtain a new integer quotient
qz and a new remainder rz:
b = q2rl + rz
with O < r2 < rl.
191

4 NUMBER THEORY
If rz = O, then rl divides b and so rl = gcd (rl, b) = gcd (b, C) by Lemma 3.1. More
generally (even when r2 # O), we have by Lemma 3.1 that
gcd (b, c) = gcd (rl, b) = gcd(rz, rl).
Next we divide rl by rz, then i-z by r~, and keep dividing each remainder by the
next until we reach a remainder of zero. Here is the sequence of divisions spelled
out precisely; for future reference we call these the Euclidean equations. Note that
every variable assumes only integer values.
The Euclidean Equations
c=qlb+rl
with O<rl<b
b = qzrl + rz
with O < r2 < rl
rl = q3r2 + r3
with O < r3 < r2
. . .
ri_2 ‘qiri–~ +ri
with O<ri<ri–l
. . .
r~-~ ‘q~-~r~_z  +rk_~
with O < rk-~ < rk_~
rk–z ‘q#k_~ +0
with rk = O.
The claim made by Euclid is that rk _ ~, the last nonzero remainder, equals
gcd @, c). Before we verify this, how do we know that this algorithm stops? That is,
how do we know that eventually we shall find a remainder of zero? Notice that
the remainders satisfy
b>rl>r2> r3>”. >ri_l>ri> .“>r k-l,
and all the remainders are nonnegative integers. Eventually, a remainder must
equal zero, certainly after no more than b remainders.
Example 3.1. Let’s carry out the Euclidean algorithm on the numbers 26 and 32:
32=1.26+6
26=4.6+2
6=3” 2+0.
We know that gcd (26, 32)= 2, the last nonzero remainder.
192

4:3 THE EUCLIDEAN ALGORITHM
Next we try 233 and 377:
377 = 1 “ 233 + 144
233=1.144+89
144=1.89+55
89=1” 55+34
55=1” 34+21
34=1” 21+13
21=113+8
13=18+5
8=1” 5+3
5=1” 3+2
3=1”2+1
2=2” 1+0
(That took a while!) This calculation implies that gcd (233, 377)= 1. To check this,
note that 233 is a prime while 377 = 13.29.
Question 3.4. Use the Euclidean algorithm to calculate the following (a)
gcd (12, 20), (b) gcd (5, 15), (c) gcd (377,610), and (d) gcd (34567,89101 1). Check
that the gcd divides each remainder in the Euclidean equations. In each instance
count the number of divisions needed to find the gtd.
In our development of the Euclidean algorithm the concurrent explanation
can readily be turned into a proof that the algorithm is correct. We now give such
a proof.
Theorem 3.2. Given positive integers b and c, the last nonzero remainder pro-
duced by the Euclidean algorithm equals gcd (b, c).
Proof. Suppose that b and c produce the Euclidean equations as listed above.
We must prove that rk - ~ = gcd (b, c). The last equation tells us that rk - ~ is a
divisor of rk _ ~, since rk _ Jrk - ~ is the integer qk. Thus
rk_l = gcd(rk-z,rk–~).
(B)
Applying Lemma 3.1 to the next to last equation, we get
gcd(rk_~,rk–~)=  gcd(rk-~,rk-1)
 =  rk-1
by (B).
193

4 NUMBER THEORY
Continuing and repeatedly applying Lemma 3.1, we get
gcd (b, C) = gcd (b, rl)
= gcd (rl , rJ
= gcd(rz, r3)
. . .
= gcd(rk-2, rk_J
= rk_l
by (B).
K
Corollary 3.3. If g = gcd (b, c), then there are integers x and y such that g =
xb + YC.
Proof. Look at the Euclidean equations. Notice that rl can be expressed as
rl = c — qlb. If g = rl, then we have demonstrated this result. If not, we can use
the second Euclidean equation to express
r2 = b — q2r1
= b – q2(c – qlb)
by substitution
=(1 + ~lgJb – qzc
simplifying and factoring.
We continue this process until we reach
g=rk_l= rk_3–qk_1rk_2
and can substitute in expressions for rk _ ~ and rk _ ~ found earlier, to express
g = rk _ ~ in the form xb + yc.
K
We say that the resulting equation expresses the gcd as a Iinear combination
of b and c. This result will be useful in Section 7; other applications are explored
in the exercises.
Example 3.1 (continued). We found that gcd (26, 32) = 2. Now we use the
Euclidean equations to express 2 as a linear combination of 26 and 32. From
the first Euclidean equation we have
6=1”32– 1.26.
From the second equation
2=1”26–4”6.
194

4:3 THE EUCLIDEAN ALGORITHM
We substitute the first equation into the second to get
2=1.26 –4(1”32–  126)= 5” 26-4 32.
The same procedure applied to 233 and 377 yields
1 =(–144)”  233 + 89.377,
but we spare you the 11 equations needed to derive this. Notice that once derived,
it is easy to check that the values of x and y work.
Now we write the Euclidean algorithm in pseudocode. Note that the Euclidean
equations all are in the same form.
Algorithm EUCLID
STEP1. Input band c{O<b<c}; set r:= b
STEP 2. While r >0 do
Begin
STEP 3. Set q : = Lc/bJ
STEP4. Setr:=c–q*b
STEP 5. If r = O, then output gcd = b
else
setc:=bandb:=r
End {step 2}
STEP 6. Stop.
Question 3.5. Run EUCLID on the following pairs of integers and express the
gcd as a linear combination of the pair of numbers. (a) (6,20), (b) (3, 4), and
(C) (55, 89).
What can we say about the complexity of EUCLID? We begin as we did
with GCD1. Let e(c) count the maximum number of divisions and multiplica-
tions performed in the algorithm upon input of numbers b < c. Not surprisingly,
there are lots of these operations. One division occurs in step 3 and one multiplica-
tion in step 4. Every time we execute step 3 we immediately execute step 4. Thus
e(c) = 2m, where m is the number of times that step 3 is executed. Another way
to count this is to notice that e(c) equals twice the number of Euclidean equations
needed to caicuiate gcd @, c). This is so, since we do one division to get the quotient
and one multiplication to get the remainder in each new equation.
Thus e(c) = 2k, where k is the number of Euclidean equations used upon the
pair b and c. We search for an upper bound on k that will give us an upper bound
on e(c). Since the remainders in the equations decrease, we know that in the
worst case we can have no more than b equations. For this to occur, the remainders
195

4 NUMBER THEORY
must be precisely (b – 1), @ – 2),. . . . 1, and O. Then
e(c) < 2b < 2C = O(c),
a complexity result no better than that of GCD 1.
We shall see in the next sections that the remainders cannot behave in such
a perverse manner and that EUCLID is considerably more efficient than GCD 1.
In fact, we shall see that as a function of the size of the bit input, EUCLID is a
linear algorithm.
EXERCISES FOR SECTION 3
1. Use EUCLID to find the gcd of the following pairs: (a) (10, 14), (b) (14, 35),
(c) (24, 42), (d) (128, 232), (e) (98, 210).
2. For each of the pairs in Exercise 1, express the greatest common divisor as a
linear combination of the given numbers.
3. Suppose that you EUCLID the pair (b, c) and then the pair (tb, m) for some
integer constant t. What is the relationship between the two sets of Euclidean
equations? What is the relationship between the pairs of integers x and y that
express b and c and tb and tc as linear combinations of their gcd’s?
4. Suppose that u = bc + d. Which of the following are true and which false?
Explain.
(i) If e divides a and b, then e divides d.
(ii) If e divides a and c, then e divides d.
(iii) If e divides a and d, then e divides b.
(iv) If e divides c and d, then e divides a.
(v) If e divides b and d, then e divides a.
(vi) If e divides b and c, then e divides a.
(vii) gcd (a, c) = gcd (c, d).
(viii) gcd (a, c) = gcd (b, d).
(ix) gcd(a, b) = gcd (b, d).
( X )  gcd(a,  C) = gcd(b,  C ) .
5. Find a number c such that with b = 3< c, the remainders in the Euclidean
equations are precisely the numbers 2, 1, and O. Is there a number c such that
with b = 4< c the remainders are (all) the numbers 3, 2, 1, and O? Can you
find a pair of numbers b and c with 4< b < c such that the remainders in the
Euclidean algorithm are all the numbers (b – 1), (b – 2),. .. ,1, and O?
6. Suppose that d divides b and c – sb, wheres is an integer such that c – sb <0.
Is it still true that d divides c?
7. What is the maximum number of Euclidean equations you can have if (a) b =
4, (b) b = 5, and (c) b = 6?
196

8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
4:4 FIBONACCI NUMBERS
What is the maximum number of Euclidean equations you can have if (a) c = 7,
(b) c =9, and (c)c= 10?
Rewrite the Euclidean algorithm so that all qs and rs are stored in arrays
as they are calculated. Then extend this algorithm so that it also calculates x
and y such that g = xb + yc.
Construct a modified Euclidean algorithm incorporating the following idea.
Given the Euclidean equation c = qb + r, if r < b/2, set c: = b – r and b:= r.
Otherwise, set c:= r and b : = b – r. Show that the gcd of the new b and c is
equal to the gcd of the old b and c. Call the resulting algorithm MODEUCLID.
Use MODEUCLID to find the gcd of the following pairs: (a) (42, 136),
(b) (18, 324), (c) (148,268), (d) (233, 377), and (e) (324,432).
Discuss the efficiency of MODEUCLID.
For each pair (b, c) below characterize IC(b, c), the set of integer combinations
of b and c, defined by
IC(b, c) = {mb + nc: m, n are integers}.
In each case determine the smallest positive integer in lC(b, c). [Note that in
the definition of IC(b, c) m and n do not have to be positive integers.]
(a) (2, 4)
(b) (6, 8)
(C) (6, 9)
(d) (12, 15)
(e) (9, 14)
(f) (59 7)
(g) (13, 18)
(h) (21, 54).
What is the relationship between the Euclidean equations with input (b, c) and
those with input (c – b, c)?
Prove that given integers b and c, there are integers x and y such that 1 =
xb + yc if and only if gcd (b, c) = 1.
Find integers a and b such that gcd (a, b) = 3. Then explain why for these
values of a and b there are no integers x and y such that 2 = ax + by. Com-
ment on the following statement: “If h # gcd (a, b), then there are no integers x
and y such that h = ax + by.”
Is the following true or false? Given integers b and c, there are integers x and
y such that d = xb + yc if and only if gcd (b, c) = d. Explain your answer.
Write a formal induction proof of Corollary 3.3.
4:4 FIBONACCI NUMBERS
We digress to a seemingly unrelated topic, the Fibonacci numbers, because the
mathematics associated with them is interesting and because (surprisingly) they
are intimately related with the complexity analysis of the Euclidean algorithm.
197

4 NUMBER THEORY
Here are the first 16 Fibonacci numbers:
0 1 1 2 3 5 8 1 3 2 1 3 4 5 5  
8 9 1 4 4 2 3 3 3 7 7 6 1 0 .
The convention is to start numbering at zero, so that we have listed the Oth, the
Ist, ..., and the 15th Fibonacci  number. We denote the nth Fibonacci  number by
Fn for each nonnegative integer n.
Question 4.1. Compute F.-l + F.-2 for n = 2, 3,4, 5, 6, 11, and 13.
Your answer to the previous question should suggest that there is an easy method
for obtaining the Fibonacci  numbers. First, F. = O, F1 = 1, and then for all n >2,
In fact, this is an inductive sort of a definition. Once you know the two base cases,
F. and Fl, then you can find all the others, one at a time, by adding successive
values.
Question 4.2. Calculate FI~,FI~,F18, F19, and F20. Then compare F“ with 2“.
Which seems to be (or is) larger? I
Since the nth Fibonacci number is defined in terms of smaller Fibonacci  num-
bers, it is natural to try to build proofs about these numbers using induction.
However, the nth Fibonacci number is not defined solely in terms of its immediate
predecessor, but rather in terms of two predecessors. Consequently, we need a
strengthening of our induction machine.
Mathematical Induction Revisited.
First we repeat the form of induction that we
have used so far.
Algorithm INDUCTION
STEP 1. Verify the base case.
STEP 2. Assume that Pk is true for an arbitrary value of k.
STEP 3. Verify that P~ + ~ is true, using the assumption that Pk is true.
Sometimes the truth of P~ + ~ depends on the truth of more than one of the pre-
ceding Pj’s or depends on the truth of Pj, where j < k. There is still hope for the
method of induction if we use the following principle, which is known as Complete
Induction.
198

4:4 FIBONACCI NUMBERS
The Principle of Complete Induction.
Suppose that Pn is a proposition that de-
pends upon the positive integer n. Then Pn is true for all n > N, (where N is some
fixed integer) provided that
(i) P~ is true,
and
(ii) if P~, P~+l,. ... and P~ are all true, then so is P~ + ~.
There are two changes here. First we’ve introduced an unspecified constant
N. In the original version of induction we always mentioned the base case PI
although we admitted that the base case might start off at Po. Lemma 7.1 from
Chapter 2 was only true for n > 5; we used this to show that J is bigger than
log (n) if n is bigger than 64. For situations like this we would like to have the
flexibility to begin proofs by induction at different starting points. The variable
N allows us this flexibility and tells us what the starting point for the proposition
P. should be. It also tells us the first value of n for which we should check the
base case, namely n = N.
The second difference between induction and complete induction is in the
inductive hypothesis. In this second version we assume that PN, P~ + ~,. . ., and P~
are all true. Since we assume more, it should be easier to use this form.
Question 4.3. Look back at the informal explanation of the Principle of Induc-
tion in Section 2.3. Write out a similar argument to explain why the Principle of
Complete Induction is valid.
Here is the algorithmic version of complete induction.
Algorithm INDUCTION
STEP 1. (The base cases). Verify that P~, P~ + ~,. . . . l’N + j are valid for some
constants N and j (depending upon the problem).
SmP 2. (The inductive hypothesis). Assume that PN, P~ + ~,. . . . and P~ are
all true for an arbitrary value of k.
SmP 3. (The inductive step). Verify that P~ + ~ is true, using the inductive
hypothesis.
There is one more change, introduced in this algorithm, namely the constant
j in Step 1. At times we shall need to check more than one base case, depending
on the proof we construct, to show that pk + ~ is true. The value of j depends upon
the number of P~,P~+ ~,. . . . P~ that we refer back to in our verification of l’k + ~.
199

4 NUMBER THEORY
We shall point out explicitly the values of j in each case, but as a rule of thumb
you should get in the habit of checking at least two base cases.
Here is an initial example of the use of complete induction.
Example 4.1. Theorem.
Every integer n >1 has a prime divisor.
Proof. The statement gives the starting point of the proposition N = 2. This
statement is true for n = 2, since 2 is a prime number and divides itself. Similarly,
the statement is valid for n = 3, since 3 is a prime. We check that it is also true
fern =4=22.
The inductive hypothesis tells us to assume the truth of the statement for
n = 2,3, ..., k, for some arbitrary value of k. To accomplish the inductive step, we
must prove the result that the integer (k + 1) has a prime divisor. Now either
(k + 1) is a prime or it isn’t. If (k + 1) is a prime, then it has itself as a prime divi-
sor. If (k + 1) is not a prime, then k + 1 = bc, where b and c satisfy 1< b < (k + 1)
and 1 < c < (k + 1). Consider b. By the inductive hypothesis, since 1< b < (k + 1),
we may assume that b has a prime divisor, say p. Then
k+l 
bc 
~c
== 
.
PPP
We see that (k + 1)/p is an integer, since it is expressed as the product of two
integers. This means that p is a divisor of (k + 1) and so (k + 1) has a prime divisor,
namely p.
K
Note that we could not have used the standard form of induction in this
problem because the truth of the assertion P~ + ~ depends not on the truth of Pk,
but on the truth of Pb, where b is less than k. Since our proof depends upon only
one earlier case, P~ with 1 < b < (k + 1), our base case needed only one value,
namely N = 2 and j = O, although to get a feel for the problem we checked three
base cases.
We now use complete induction to establish some facts about the Fibonacci
numbers.
Example 4.2. From the examples calculated in Question 4.2, the following was
observed. Theorem. F. < 2“.
We prove this for all nonnegative integers n using complete induction. For the
base cases we notice that F. = O <1 = 2°, and that F1 = 1<2 = 21. We require
base cases with two consecutive integers because in our proof we use the fact that
F~ + ~ can be written in terms of its two immediate predecessors. (Thus j = 1 in
this example). We shall use complete induction and so assume that Fi < 2
i for all
k + I But we know exactly what ‘k+ 1
0 s i < k. Then we must prove that Fk+ ~ <2 .
200

4:4 FIBONACCI NUMBERS
equals:
F~+~=F~+F~.~
by definition
<2k+2k-1
by the inductive hypothesis
.
2k-1. .2+2k-l
by algebra
=Zk-l.(z+l)
by factoring
<2k-14
since (2 + 1) <4
—— .2k-l. z2
=Zk+l
by laws of exponents.
K
Example 4.2 might cause us to ask whether F. = O(p) for some polynomial ~
however, this is not the case. The result of the next question shows that the Fibonacci
numbers grow exponentially.
Question 4.4. Find an integer N such that F~ > (~)N. Prove by induction that
F. > ($)” for all n > N.
Before we do more magic, rabbit-out-of-the-hat tricks with the Fibonacci
numbers, let’s learn where they come from and why. The Fibonacci numbers first
appeared in the book Liber Abaci published in 1202 by Leonardo of Piss (also
known as Leonardo Fibonacci,  since he was the son of Bonacci). Although Leo-
nardo was mainly interested in their mathematical properties, he also noted the
following application.
Example 4.3. A pair of rabbits requires one month to mature to the age when
it can reproduce. Suppose that the rabbits then mate and produce another pair
in every subsequent month, and that the pair of offspring is always conveniently
one male and one female, who then form a new breeding pair. If in the first month
we have one pair of rabbits, how many pairs do we have at the beginning of the
nth month? For simplicity, we assume no death or loss of fertility. We call the
resulting number R..
At the beginning of the first month we have one pair, so RI = 1. At the
beginning of the second month we still have one pair, but during the second month
they produce a pair of bunnies. Thus Rz = 1 and R3 = 2. During the third month
the original pair produces another pair of bunnies, but the new pair of bunnies
doesn’t reproduce yet. So R4 = 3. Then R5 = 5.
We might as well argue the general case That is, let’s determine R. in terms
of previous values of R. At the beginning of the nth month we have all the rabbit
pairs that we had at the beginning of the (n – l)st month, R.-~, plus some new
bunny pairs. The number of new bunny pairs is the number of rabbit pairs that
are at least one month old. The rabbit pairs that are this old are precisely those
201

4 NUMBER THEORY
that were around in the (n – 2)nd month, R._ ~. In symbols then
Now we see that the R. are exactly the same as the Fibonacci numbers and that
R. = F. for all positive n.
Fibonacci numbers arise in other natural settings. For example, the spacing
of leaves on some plants and some arrangements of flower petals and seeds are
closely related to the Fibonacci  numbers. Mollusk shells spiral in curves derived
from Fibonacci  numbers. Ratios of successive Fibonacci numbers, like ~, ~, and
& are considered aesthetically pleasing. The squares in Figure 4.1 each have sides
equal to a Fibonacci number. They combine to make rectangles with sides in
ratios of 34 to 21, 21 to 13, 13 to 8, 8 to 5, 5 to 3, 3 to 2, and 2 to 1.
In fact, for large values of n, F./Fn _ ~ gets arbitrarily close to a constant
~=l+fi
2
’
known as the golden ratio; @ is approximately equal to 1.618. The Fibonacci
numbers are even thought to be useful in predicting highs and lows on the stock
market. These numbers have so many interesting and varied properties that there
is a mathematics research journal, the Fdxmacci  Quarterly, dedicated to results
—
about Fibonacci  numbers.
Fibonacci  Squares
5
8
lJ_
3
2
21
13
34
Figure 4.1.
202

4:4 FIBONACCI NUMBERS
The defining property is useful for proving results about Fibonacci numbers
by induction. But one thing seems missing from our knowledge. Is there a formula
for F.? Or to calculate, say, F1 ~ must we determine all the smaller Fibonacci  num-
bers? Yes and maybe no, respectively. We shall write down a formula for F., but
we stress that in most situations the inductive definition that F. = F.-~ + F._ ~
is the most helpful fact to know. In Chapter 7 we shall do a more systematic study
of sequences of numbers and their formulas.
Question 4.5.
Show that ~ = (1 + ~)/2 has the property that its reciprocal is itself
minus one. Find all solutions to the equation x – 1 = l/x.
The two solutions to the equation in Question 4.5 are @ = (1 + ~)/2 and the
closely related @’ = (1 – &)/2. These can be found by rewriting x — 1 = I/x as
x’ - x — 1 = O and then solving using the quadratic formula. The relationship
between @ and ~’ and the Fibonacci numbers is given in our next result.
Theorem 4.1.
For nonnegative integers n, F.= (~” – @’n)/$.
ProoJ The proof will be by complete induction. First we check the base cases.
As above we need to verify the truth of the theorem for two consecutive integers,
since we shall use the crucial fact that F~ + ~ = Fk + Fk _ ~. First we substitute
n = O, to obtain
4°-@O=l-l=o=F
$ 
3 
0“
Next, for n = 1 we get
q5’-@’=(l  +ti)/2-(l  -fi)/2=1=F
&
8
1.
Using complete induction, we assume that the given formula is correct for Fo, Fl,
. . . .Fk _ ~ and Fk. We IIIUSt prove that the fOHINda k correct for Fk + ~. we write
‘k+ I using smaller values:
Fk+l=Fk+Fk_l
=~k–$’k+~k-’_  #k-’
$
&
= f#-1(~  + 1) @’k-l (#’ + 1)
d-a”
203

4 NUMBER THEORY
Since @ is a root of the equation X
2 —x–l=O, wegetq52 =@+ l. Simi-
Iarly, ~’2 = @ + 1. We substitute these into the equation above to get
and that’s exactly what we wanted to show.
Question 4.6. Check the formula for F2 given in Theorem 4.1.
Corollary 4.2. F. is approximately equal to @n/fi. Specifically,
$ -1< F”<5+1
Proof We begin by noting that ~’ is approximately equal to – 0.618. What we
need is not its exact value but the fact that its absolute value is less than 1. Con-
sequently, & will be less than 1 in absolute value for all positive integers n and
0’”/$ will be less than 1 in absolute value for all nonnegative integers n. Thus
The other inequality is proved similarly; see Exercise 17.
We now have two ways to calculate F. for any fixed n. One involves many
additions:
F2=F1+FO=1+O=1
F3=F~+F1=l+l=2
. . .
F“=Fn_l +F. -2.
Thus F. could be calculated with (n – ,1) additions.
Question 4.7. To calculate F. by adding as shown above appears to require that
we store all of FO, Fl,. . . . F._ ~. Is it possible to calculate F. by addition without
storing all the previous values in n different memory locations? What is the mini-
mum number of memory locations that you need to calculate F. in this way?
204

4:4 FIBONACCI NUMBERS
The second way we now have to calculate F. is using the formula proved in
Theorem 4.1. This requires two exponentiations, one division and one subtraction
as well as an approximation of the square root of 5. There are a variety of addi-
tional methods known for calculating F., including an addition method that is
analogous to the FASTEXP algorithm developed in Chapter 2, that is, one that
does not require the determination of ail intermediate Fibonacci numbers. (See
Exercises 13 and 14.)
For years applications of Fibonacci numbers have been found throughout
mathematics. For example, a very famous open problem posed by David Hilbert
in 1900, known as Hilbert’s tenth problem, was finally solved in 1970 when the
mathematicians Martin Davis, Yuri Matiasevic,  Hilary Putnam, and Julia Robin-
son thought to examine the Fibonacci numbers carefully. Applications of Fibonacci
numbers are also pervasive in computer science. Efficient ways to approximate the
local maximum and the local minimum of a function or to merge files can use
Fibonacci numbers. In Chapter 8 we shall study problems concerning shortest
paths. Recent results have shown “Fibonacci  heaps” and “Fibonacci  trees” (what-
ever they are!) to be crucial in developing fast algorithms to solve these problems.
Our interest is to turn now to the complexity analysis of the Euclidean algo-
rithm, where we shall encounter Fibonacci  numbers.
EXERCISES FOR SECTION 4
1. Find a sequence of numbers G, that satisfies the equation G. = G._ ~ + Gn
. ~
for all n but differs from the sequence of Fibonacci  numbers.
2. Let HO = Oand Hl = l.Fern >1 define H. byH. = H.-l + 2Hn-’2. List the
first 11 terms of the H sequence. What happens to the quotient HJH. - ~ as
n gets big? Prove that Hn = [2” + (– 1)”- lj/3.
3. Show that Fl+F2+”””+F”=F.  +2 –1.
4. Show that F1 +F3 +“. ” +F2n_1 =Fz..
5. Show that FO+F2+’  .”+ F2. =F2”+l –1.
6. Show that every positive integer can be written as the sum of distinct, positive
Fibonacci  numbers. Is the choice of numbers for a given sum unique?
7. Suppose that GO = O, GI = 1, and for all n >2, G. = 2GH_ ~ + G._z. Find
G2, G3,. . . . G8. Determine which of the following assertions are true.
(a) G.= 0(n2).
(b) G“ > 2“
- 1 if n is large enough.
(c) G.< 3“ if n is large enough.
(d) Gn is even if and only if n is even.
8. Knowing FO and Fl, one might believe for consistency’s sake that F- ~ should
be that number with the property that F_ ~ + F. = F1. Since FO = O and
205

4 NUMBER THEORY
F’l = 1, I’_l ought to equal 1. Determine F_2, F_3,. . . ,F_7.  What is F_.
in terms of F.?
9. Show that F.+ ~Fn_ ~ – F; = (– 1)”.
10. Show that F1F2 + F2F3 + “ ~ . + F2n_1F2. = Fin.
11. Show that F1F2 + F2F3 + “ “ “ + F2.F2.+1 = F~n+l – 1.
12. Find all natural numbers n such that F. = n. Prove that you have found all
such numbers.
13. (a) Show that F2. = Fn(FH + 2F, _ J.
(b) Find a similar formula for Fzn + ~ in terms of Fn + ~ and smaller Fibonacci
numbers.
14. Using the results of Exercise 13, design an algorithm to determine Fn. Then
count the number of multiplications and additions needed in this approach
and compare with those discussed at the end of this section.
15. In Example 4.2 and Question 4.4, induction was used to show that (~~ <
F“ < 2“ provided that n is large enough.
(a) Find a number b <2 so that a similar argument will show that F. < b“
provided that n is large enough. What is the smallest b your argument
will support?
(h) Find a number c > ~ so that Cn <F. provided that n is large enough.
What is the largest c your argument will support?
16. Are the following equations true or false?
F“ = rqb”/~1.
F. = LqY’/fiJ.
17. Finish the proof of Corollary 4.2 by showing that F. > @/~ – 1.
18. Find all pairs of numbers (x, y) such that x + y = 1 and xy = – 1.
4:5 THE COMPLEXITY OF THE
EUCLIDEAN ALGORITHM
The question before us is to determine the complexity of the Euclidean algorithm
when, given b < c, it computes gcd (b, c). To begin with, we let e(c) denote the max-
imum number of multiplications and divisions performed in EUCLID when c is
the larger of the two input integers. Later we shall convert e(c) to a function of
the number of bits needed to represent b and c in binary. We shall show that
e(c) = O(log (c)); that is, for all pairs of integers b < c, the Euclidean algorithm
requires at most O(log (c)) divisions and multiplications. Consequently, if B denotes
206

4:5 THE COMPLEXITY OF THE EUCLIDEAN ALGORITHM
the number of bits of input needed to encode the integers b and c, then EUCLID
will be linear in B.
Look back in Section 3 and notice that we determined that e(c) = 2k, where
k is the number of Euclidean equations produced by b and c. Thus we shall search
for an upper bound fork in terms of b and c. Before we find such an upper bound,
we investigate some pairs for which EUCLID seems to take a long time. Example
3.1, Question 3.4, and some of the exercises point toward the Fibonacci  numbers.
So let’s see what happens if we let b and c be consecutive Fibonacci  numbers.
Lemma 5.1. In the Euclidean equations if c = Fn and b = Fu _ ~ with n 24, then
rl =F”_2.
Proof. The defining relation for the nth Fibonacci number is
Since O s F._ ~ < F.-~ for n >4, this gives the first Euclidean equation with
ql = 1. Thus rl = F,_z.
K
Theorem 5.2. If EUCLID is run with c = F~ + ~ and b = Fk + ~ with k >1, then
there are exactly k Euclidean equations.
Proof. The proof is by (ordinary) induction on k. If k = 1, then c = F~ + ~ = F3 = 2
and b = F~+ ~ = F2 = 1. Given c = 2 and b = 1, EUCLID produces just one
equation, specifically,
2=2” 1+0.
Now we assume that if c = F~ + ~ and b = F~ + ~ with k >1, then there are exactly
k equations, and try to show that if c = F~ + ~ and b = Fk + z, then there are exactly
(k+ 1) equations. Now, if c = F~+ ~ and b = Fk+2, k + 3>4 and by Lemma 5.1
our first Euclidean equation is
Fk+3 ‘Fk+2  +Fk+l.
(A)
Next we divide F~ + z by F~ + ~, but this is the same as if we began the Euclidean
algorithm with c = F~ + z and b = Fk + ~. By the inductive hypothesis we get k
Euclidean equations from this starting point. Hence, in total, (A) is the first of
(k + 1) Euclidean equations.
K
Question 5.1. Construct the Euclidean equations for (i) c = F8 and b = F, and
(ii) c = Flo and b = F9.
207

4 NUMBER THEORY
Question 5.2. For O < b < c s 5, what is the maximum number of equations and
for what integers does that maximum occur?
What we have done is analyze the complexity of EUCLID for a restricted
set of inputs. Specifically, if b = F~ + ~ and c = F~ + ~, then e(c) = 2k. Indeed a much
stronger statement is true. The smallest integer c that produces as many as k
Euclidean equations is c = F~ + ~ and given this c, the only integer b that will
(together with c) produce as many as k Euclidean equations is b = F~ + ~. So the
Fibonacci numbers provide the worst possible input to EUCLID. We shall not
prove this theorem, due to Lame in about 1845 (but you may prove it in Supple-
mentary Exercise 14). However, we shall show that the worst-case behavior is of
the same order of magnitude as that on the Fibonacci numbers.
We begin by investigating the relationship between c = F~ + ~ and k, where
k z 1. Thus c >2. Corollary 4.2 and some algebra imply that
(7Y+2) < (c + 1)$.
Taking logs (and noting that V < 4), we see that
(k+ 2)log(~)  < log(c + 1)+ log($)< log(c + 1)+2.
Next we solve for k by dividing by log(@) and subtracting 2 to get
~<_2+log(c+l)+2
l o g  (~)
If we estimate log (~) by log (1.618) > ~ we get
k<–2+2(log(c  +l)+2)=210g(c+l)+2
<2 log (2C) + 2
since c >2
=210g(c)+4<610g(c)
since c >2.
In short, we have that when c = F~ + z and b = Fk + ~, the number of Euclidean
equations that occur, k, is O(log (c)). In Exercise 11 we ask you to use Corollary
4.2 to bound k from below.
We shall now show that for any inputs b and c, the number of Euclidean
equations is no larger than logarithmic in c. To accomplish this, we need a closer
look at the Euclidean equations.
Theorem 5.3. If e(c) counts the maximum number of multiplications and divisions
in the Euclidean algorithm with input b s c, then
e(c) = O(log (c)).

4:5 THE COMPLEXITY OF THE EUCLIDEAN ALGORITHM
Proof. Suppose that we consider the first two Euclidean equations
C=qlb+rl
and
b = q2r1 + r2.
We know that b > rl > r2. From these inequalities r2 might be as large as b – 2.
In fact, we shall obtain the much better estimate that r2 < b/2. This estimate is
better in the sense that it allows us to conclude that r2 is smaller than we otherwise
knew. If r2 is smaller, then we expect to use fewer Euclidean equations.
Example 5.1. In the Euclidean equations of Example 3.1,
b = 233 and r2 = 89< b/2,
rh = 34< r2/2,
r~ = 13< rJ2,
r8 = 5 < r6/2,
rlo = 2 < r8/2,
and
r12 = O < rlo/2.
Question 5.3. Show that the Euclidean equations with b = 77 and c = 185 have
rz < ~.
To show that r2 is less than b/2 in general, we look first at rl. If rl s b/2,
then r2 < rl implies that r2 < b/2. If, on the other hand, rl > b/2, then 2r1 > b.
Thus in the second Euclidean equation q2 = 1 and we have that
b=r1+r2.
By solving for r2, we get
rz=b —rl
<b_~=~
b
2
2
since rl > –.2
So in either case we have r2 less than b/2. By doing the same thing to the next
two Euclidean equations, we can show that
r2
b
‘4< T<Z”
209

4 NUMBER THEORY
Let’s be careful at this next step so that the pattern becomes clear. As above we
argue that
Thus, in general, we have
How long can this go on? If b/(2t) <1, then by the preceding equation the remain-
der rz, equals zero. But b/(2t) <1 implies that log(b) < t. Thus once t 2 log(b) or
equivalently once t = (log (b)l, then
and from (B) we get r21 = O. Thus k, the number of Euclidean equations, is at
most 2t, where t = [log (b)l. Thus
e(c) = 2ks 2(2t) = 2(2(log (b)l)s 4rlog (c)l = O(log (c)).
Question 5.4. Look at the Euclidean equations from Example 3.1. For each integer
t compute r2t + 2/r2t.
In conclusion we have that the Euclidean algorithm is a good algorithm. Look
back in Section 2 at the inequalities of line (2):
log (c) < B = Llog(b)j + 1 + Llog(c)j +.1.
Since it requires B bits to input b and c in binary, the number of muhiplications
and divisions is bounded by
e(c) = O(log (c)) = O(B).
Thus EUCLID is a linear algorithm.
EXERCISES FOR SECTION 5
1. Show that if c = F~ + z and b > F~ + ~ in the Euclidean equations, then
rl < F~.
210

4:6 CONGRUENCES AND EQUIVALENCE RELATIONS
I
2. In the Euclidean equations, if c = F~ + ~ and b < F~ + ~, is rl < Fk?
3. Construct the Euclidean equations if c = Fg and b = F,.
4. If c = Fk + ~ and b = F~ + ~, what can you say about the number of Euclidean
equations?
5. Suppose that GO = 4, GI = 7, and for n >1, Gn = G._ ~ + G.. ~. Exhibit Gn
fern= 2,3,...,8.
6. Exhibit the Euclidean equations with c = G8 and b = G7. (G. is defined in
Exercise 5.)
7. How many Euclidean equations are there if c = G~ + ~ and b = G~ + ~? (Gn is
defined as above.)
8. In the Euclidean equations we know that rb < b/4. Is r~ < b/4?
9. Choose a value oft so that in the Euclidean equations r8 < rJt.
0
10. Suppose that C. is a sequence of nonnegative integers with the property that
C, < C.- ~/4. If Cl = M, for what value z can you guarantee that C= = O?
11. Use Corollary 4.2 to find a constant D such that if c = F~ + ~, then k > D log(c).
12. The complexity of EUCLID was shown to be O(B), where B equals the number
of bits needed to represent the integers b and c. Thus the number of multi-
plications and divisions performed is at most SB + t for some integers s and
t. Find integers s and t that give an upper bound on the number of these
arithmetic operations that is as small as possible based on the analysis in this
section.
4:6 CONGRUENCES AND
EQUIVALENCE RELATIONS
Integer arithmetic is fundamental to the mathematical field of number theory and
to the computer science field of cryptography. The particular kind of arithmetic
used in these fields is known as modular or congruence arithmetic. In this section
we introduce the basics of arithmetic modulo n and develop simultaneously the
concept of an equivalence relation. In the next section we apply this work to en-
cryption schemes.
Definition. If n is a positive integer and a and b any two integers, we define
a = b (mod n)
(read “a is congruent to b modulo n“) if (a – b) is divisible by n. We let [a] denote
the set of all integers congruent to a modulo n,
[a] = {x: a a x (mod n)}.
211

4 NUMBER THEORY
This is called the equivalence class containing a.
Example 6.1. Let n = 12. Then 1-13 (mod 12), 1 =25  (mod 12),13 -25 (mod 12),
1- –11 (mod 12), and
[1] ={..., –23, –11,1,13,25,. ..}
= {1 + 12k: k an integer}.
If “#” means “not congruent to,” then 1 #O(mod 12), 1 E 1 (mod 12), 1 # 2
(mod 12), and 1 # i(mod 12) for i =3, 4,...,12.
We are used to working “modulo  12,” since that is how our clocks and some
of our measurements work, If it is 11 A.M. and I have an appointment in 3 hours,
then since 11 + 3 = 14 = 2 (mod 12), the appointment is for 2 P.M.
Question 6.1, Determine which of the following are true and which false: (a) 2 s
3 (mod 12), (b) 2 = 4 (mod 12), (c) 2-10 (mod 12), (d) 2 s 14 (mod 12), (e) 2 s
– 10 (mod 12), and (f) – 10- – 22 (mod 12). Describe all integers x that are con-
gruent modulo 2 to O. Working modulo 3, list six elements of [1] and then describe
the entire set precisely.
Question 6.2. Let n be a positive integer and i an integer such that O s i < n.
What is the least integer j > i such that i = j (mod n)? What is the largest negative
number m such that i - m (mod n)?
Congruences modulo n behave like equalities.
Lemma 6.1.
Let n be a positive integer and a, b, and c arbitrary integers. Then
(i) a a a (mod n),
(ii) If a z b (mod n), then b = a (mod n), and
(iii) If a = b (mod n) and b - c (mod n), then a a c (mod n).
Proof. We prove part (iii). If a - b (mod n), then n divides (a – b) and so there
is an integer i such that a – b = in. If b = c (mod n), then there is an integer j such
that b – c = jn. Thus
a–c=(a– b)+(b–c)=in+jn =(i+j)n,
and (a – c) is divisible by n, that is, a = c (mod n).
G
Question 6.3. Prove parts (i) and (ii) of Lemma 6.1.
Here’s a vocabulary to highlight the similarities between relationships like
= (mod n),” and others. We say that a relation “ -” is defined on a set S
.’ _,,”_
— ,
212

4:6 CONGRUENCES AND EQUIVALENCE RELATIONS
(finite or infinite) if for each pair of elements (a, b) in S, a - h is either true or
false. Colloquially, if a - b is true, then we say a is related to b. A more formal
way to describe a relation on S is to say that N corresponds to a function
T: S x S + {True, False}
such that T(a, b) = True if and only if a - b is true (or equivalently a is related
to b).
Example 6.2. Let S be the set Z of all integers. Then equality gives us a relation
on Z by defining i - j to be true for integers i and j if and only if i = j. Simi-
larly, for a fixed positive integer n, congruence modulo n is a relation on Z if we
define i - j to mean that i = j (mod n).
Question 6.4. Which of the following defines a relation on the given set S?
(a) S = Z and - stands for <; (b) S = all subsets of Z and w stands for s; and
(c) S = all real numbers and r w s means that (r – s) is even.
Definition. A relation N defined on a set S is said to be an equivalence rela-
tion if it satisfies the following three properties. If a, b, and c are arbitrary ele-
ments of S, then
(i)a~a
(reflexive property)
(ii) If a N b, then b N a
(symmetric property)
(iii) If a -band b-c, then a-c
(transitive property).
Lemma 6.1. says that the relation “congruence modulo n“ defined on Z is an
equivalence relation.
Example 6.3. Let U = {1, 2,. ... n} and let P be the set of all subsets of U. If
A, B, C s U, then (i) A G A is true for every subset A, and (iii) if A ~ B and B ~ C,
then A = C, but it is not true that (ii) if A G B, then B ~ A. Thus the relation of
containment is not an equivalence relation on P.
Example 6.1 (continued). Working modulo 12, we saw that 1 is not congruent
modulo 12 to 0,2,3,. ... or 11. Let us look at the equivalence classes [0], [1],
[2], . . . [11].
[0]={ . . . –24, –12,0, 12,24,36.. }
[1]={ . . . –23, –11,1,13,25,37.. }
[2]= {... –22, -10,2,14,26,38 ...}
. . .
[11] ={... –25,–13,–1,11,23,35...}.
213

4 NUMBER THEORY
Notice that no two of these sets intersect and that every integer is in precisely one
of these sets.
Definition. If w is an equivalence relation on the set S, then we define for a in
S, the equivalence class containing a to be
[a] = {x in S: u w x}.
Then just as in the case of congruence of integers modulo n, the collection of all
distinct equivalence classes of S divides up S into disjoint subsets. Such a division
is called a partition of S.
Lemma 6.2. If w is an equivalence relation on a set S, then
(i) a is in [a] for alla in S,
(ii) [a] = [b] if and only if a N b, and
(iii) if [a] # [b], then [a] n [b]= 0.
Proof. (i) a is in [a], since a - u by the reflexive property of equivalence
relations.
(ii) If [a] = [b], then a in [a] implies that a is in [b] and so b w a by definition.
By the symmetric property, a w b. Conversely, suppose that a N b and let x be in
[a]. Then a - .x and x w a, and by the transitive property x = b and so b - x. Thus
x is in [b] and [u] G [b]. The proof that [b] ~ [a] is carried out in the same way.
(iii) Suppose that [a] n [b] # 0 so that there is an element x in [a] n [b].
Then a-xand b-x. By the symmetric property x - b and by the transitive
property a - b. Using part (ii), we have that [a] = [b]. We have proved the con-
trapositive of (iii).
D
Fix a positive integer n. When working with the integers modulo n, there are
many ways to express the same equivalence class. For example, [0] = [n] =
[– n] = [17n]. It is often convenient to represent an equivalence class [i] using
the least nonnegative integer to which i is congruent modulo n. We can find that
integer by dividing i by n:
i=qn+r
with OSi-<n
and so [i] = [r].
Definition.
If i = qn + r with O s r < n, then r is called the least nonnegative
residue of i modulo n.
This process also shows that every integer i is in one of the classes [0], [1],. . . .
[n – 1] modulo n. Furthermore, no two of the equivalence classes [0], [1],...,
214

4:6 CONGRUENCES AND EQUIVALENCE RELATIONS
[n – 1] are equal, for if [i]= [j], then i -j (mod n) by Lemma 6.2 (part ii). But
since O < i, j < n, then n cannot divide (i — j) unless i = j. Thus it is not the case
that [i] = [j] when O < i <j < n. The equivalence classes [0], [1],. . . . [n – 1]
are a complete (and useful) set of equivalence classes of the integers modulo n.
Example 6.1 (continued). When working modulo 12, we use the equivalence
classes [0], [1],. . . . [11].
We can also do arithmetic with the equivalence classes modulo n: addition,
subtraction, multiplication, exponentiation, and sometimes division.
Definition.
The equivalence classes {[0], [1],. . . . [n – 1]} are called the integers
modulo n and are denoted by Z..
Lemma 6.3. If a a b (mod n) and c - d (mod n), then
(i) a+c=b+d(modn),
(ii) a – c = b – d (mod n), and
(iii) ac - bd (mod n).
Proof. We prove part (iii). Since a - b (mod n), there is an integer i such that
a — b = in or equivalently a = b + in. Since c = d (mod n), there is an integer j
such that c = d + jn. Thus
uc = (b + in)(d + jn)
– bd + bjn + din + ijnz
—
= bd + (bj + di + ijn)n.
Thus (ac – bd) is divisible by n, and ac a bd (mod n).
Question 6.5. Verify the first two parts of Lemma 6.3.
Thus we can define arithmetic modulo n on equivalence classes as follows.
[a] + [b]= [a + b], [a] - [b]= [a - b],
[a] ~ [b] = [ah], and [a]
k = [a
k] fork a positive integer.
These definitions look sensible, but there are some important points to be
checked. We must check that addition and multiplication are “well defined by
these equations. (Subtraction is just addition of negative numbers, and exponen-
tiation is just repeated multiplication, so we concentrate on the other two opera-
tions.) What this means is that if x is any element of [a] and y is any element of
215

4 NUMBER THEORY
[b], then
[x+y]=[a+b]
and
[xy] = [ah].
We now show that addition of equivalence classes modulo n is well defined. If x
is in [a] and y is in [b], then
a - x (mod n)
and
b = y (mod n).
By Lemma 6.3
a+ b-x+y (modn)
and
[x+y]=[a+b].
Question 6.6. Show that multiplication of equivalence classes is well defined.
Example 6.1 (once more).
Working with the integers modulo 12, we want to add
and multiply in the following way:
[1] + [1]= [2], [1]+ [2]= [3], [8]+ [9]= [17]= [5],
[-5] + [10]= [5], [3] ~ [0] = [0], and [5]. [6]= [30]= [6].
But is this consistent? We know that [1] = [25], since 1 = 25 (mod 12). Thus it
should be the case that
[1] + [25]= [1]+ [1]= [2],
Fortunately, [1] + [25] = [26] = [2], since 2 = 26 (mod 12). Similarly, [17] = [5]
and [– 6] = [6]. Thus
[17] . [-6]= [-102]= [6]= [5] ~ [6].
When can we do division or cancel modulo n?
Lemma 6.4. If ab s cd (mod n) and a = c (mod n), then b s d (mod n) provided
that gcd (a, n) = 1.
Proof. By assumption there are integers i and j such that
ab—cd=in
and
a—c=jn,
Substituting c = a – jn in the first equation yields
ab – (a – jn)d = in.
216

4:6 CONGRUENCES AND EQUIVALENCE RELATIONS
Thus
ab—ad=in–jdn
and
a(b – d) = (i –jd)n.
(A)
Since n divides the right-hand side of (A), n also divides the left-hand side, a(b – d).
Since a and n have gcd 1 and thus no factors in common, n must divide (b – d).
Thus b R d (mod n).
K
Question 6.7. Pick five distinct integers a, b, c, d, and n such that gcd (a, n) = 1,
a = c (mod n), and ab - cd (mod n). Verify that b = d (mod n). Then find integers
a, b, c, d, and n such that gcd (a, n) # 1, a - c (mod n), ab E cd (mod n), but
b # d (mod n).
Now what would it mean to say that we can do division with the integers
modulo n? Division by a number x is the same as multiplying by l/x, and I/x has
the property that x(l/x) = 1.
Definition.
Given [a] in the integers modulo n, we say that [a] has a multiplica-
tive inverse if there is another equivalence class [b] such that
[a] . [b]= [1].
Thus [b] is playing the role of” l/[a]” and is called the multiplicative inverse of
[a]. If [a] “ [b] = [1], then [b] “ [a] = [1] and so [a] is also the multiplicative
inverse of [b].
Similarly, if a and b are two integers with O < a, b < n such that ab -1 (mod n),
then we say that a and b are each other’s multiplicative inverses.
Corollary 6.5. Let n be a positive integer. Then the equivalence class [a] has a
multiplicative inverse if and only if gcd (a, n) = 1.
Pmo~. If 1 = gcd (a, n), Corollary 3.3 says there are integers x and y such that
l=xa+yn.
Thus
1 = xa (mod n),
217

4 NUMBER THEORY
and so
[1] = [xa] = [x] ~ [a].
Thus [x] is the multiplicative inverse of [a].
Conversely, if
[a] . [x]= 1,
then
ax=l+kn
for some integer k.
Thus any common divisor of a and n must also divide 1, and so gcd (a, n) = 1.
K
Two integers a and b are said to be relatively prime if gcd (a, b) = 1. Thus an
integer a has a multiplicative inverse modulo n if and only if a and n are relatively
prime.
Example 6.1 (again). In ZI ~, only 1, 5, 7, and 11 are relatively prime to 12. Here
are their multiplicative inverses:
[1] . [1]= [1], [5] ~ [5] = [25]= [1],
[7] . [7]= [49]= [1], and [11]. [11]= [121]= [1].
In other words, each of 1, 5, 7, and 11 is its own multiplicative inverse. Here
is a brute force check that [2] does not have a multiplicative inverse:
[2] . [0]= [0],
[2] ~ [1]= [2],
[2] . [2]= [4],
[2] ~ [3]= [6],
[2] . [4]= [8],
[2] . [5]= [10],
[2] . [6]= [0],
[2] . [7]= [2],
[2] ~ [8]= [4],
[2] ~ [9]= [6],
[2] . [10]= [8],
[2] o [11]= [10].
Question 6.8. Find multiplicative inverses for all elements of 25 and of 210 that
have inverses. Which elements of ZI ~ have multiplicative inverses?
Finding inverses will be important in the application presented in Section 7,
as will a variation on the next theorem, known as Fermat’s little theorem. This
one he really did prove.
218

4:6 CONGRUENCES AND EQUIVALENCE RELATIONS
Theorem 6.6. If p is a prime number and gcd (a, p) = 1, then
a‘-1 = 1 (modp).
Proof. Notice that for any integer i, gcd (i, p) is either 1 or p, the only divisors
of p. Thus gcd (i, p) = 1 if and only if p does not divide i, that is, if and only if
i # O (mod p). Thus by assumption a # O (mod p). Consider the equivalence classes
[a], [2a], [3a],. . . . [(p - l)a].
(B)
We claim that none of these is [0] and that no two of them are equal.
First if it were the case that
[is] = [0]
where 1 s i < p,
then
ia = O (mod p).
Thus p divides ia, and since gcd (a, p) = 1, p divides i, a contradiction, since 1 s
i < (p – 1). Thus none of the equivalence classes in (B) equals [0].
Next suppose that
[is] = [ja]
where 1 < i, j < p.
Then
ia - ja (mod p)
by Lemma 6.2 (part ii), and
i a j (mod p)
by Lemma 6.4,
a contradiction, since both i and j are positive integers less than p. Thus the (p – 1)
equivalence classes listed in (B) are the same as the equivalence classes [1], [2],
[3],..., [p – 1], although probably listed in a different order. Then 
~
[a] ~ [2a] . ~ ~ [(p- l)a]=[l][2]- [p-1]
[a(2a) . ~ . ((p - l)a)] = [(p - l)!]
multiplying equivalence
classes
a(2a) ~ ~ ~ ((p – l)a) -(p – 1)! (mod p)
by Lemma 6.2 (part ii)
UP- ‘(P – 1)! z (p – 1)! (mod P)
simplifying
up-l = 1 (modp)
by Lemma 6.4
since gcd (p, (p – l)!) = 1.
D
219

4 NUMBER THEORY
Question 6.9. Pick a prime p and an integer b such that gcd (b, p) = 1, write down
the equivalence classes [b], [2b],..., [(P – l)b] modulo p, and verify that they are
the same as the classes [1], [2],. . . . [p – 1]. Check that bp
 -1 e 1 (mod p). Find
c, an integer with gcd (c, p) # 1, and show that Cp
 – 1 # 1 (mod p).
This has been a brief introduction to arithmetic modulo n and to the ideas
of equivalence relations. We shall use this in an application to cryptography (the
art of secret messages) in the next section.
EXERCISES FOR SECTION 6
1. In each of the following find the least nonnegative integer i such that
(a) 4
30- i (mod 19).
(b) 2
3’- i (mod 377).
(c) 2’ E 1 (mod 17).
(d) 2“3’3  E i(mod7).
(Hint: After each multiplication replace the result by its least nonnegative
residue modulo n.)
2. Explain why it is always true that n5 - n (mod 10) or, in other words, why
n5 and n always have the same last digit.
3. Prove that for every integer n, either nz = O (mod 4) or n
2 = 1 (mod 4). Use
this to show that there are no integers x and y such that X
2 + y
2 = 1987.
4. The set {0, 1,. . . , n — 1} is called a complete residue system modulo n because
every integer is congruent modulo n to exactly one of these numbers.
(a) Find a complete residue system modulo n in which all numbers are
negative.
(b) Find a complete residue system modulo n in which all numbers have
absolute value at most n/2.
5. Is either the relation “<” or “s” an equivalence relation on the integers?
6. Which of the following define an equivalence relation on the integers? Explain
your answer.
(a) a N b if a divides b.
(b)a-bifu  <b.
(c) a - b if Ial < Ibl.
(d) a - b if a and b begin with the same (decimal) digit.
(e) a - b if when a and b are expressed as a = 2is and b = 2jt with i and j
nonnegative integers and s and t odd integers, then s = t.
U) a w b if when a and b are expressed as in part (e), then i = j.
220

4:6 CONGRUENCES AND EQUIVALENCE RELATIONS
7. Prove that the following is an equivalence relation defined on the integers:
a N b if a and b have the same number of prime divisors, counting multi-
plicity (e.g., 18 = 2 “ 3
2 has three prime divisors). For this equivalence relation
are addition and multiplication of equivalence classes well defined by
[a] + [b] = [a+ b] and [a] ~ [b] = [ah]? Explain.
8. Give an example of a relation on a set that has the following properties.
(a) Reflexive and symmetric, but not transitive.
(b) Reflexive and transitive, but not symmetric.
(c) Symmetric and transitive, but not reflexive.
9. (a) Write down the elements of 22. Then write down an addition and multi-
plication table for 22; that is, write down all possible sums [a] + [b] and all
possible products [u] ~ [b].
(b) Do the same for 23.
(c) Do the same for 24.
10, Rewrite the Euclidean equations using congruences.
11. Prove that if [i] and [j] are equivalence classes modulo n such that [i] = [j],
then gcd (i, n) = gcd (j, n).
12. A relation w on a set S is called a total (or linear) ordering if
(i) for all a and b in S, exactly one of the following holds:
a- b,a=b, or b-a, and
(ii) for elements a, b, and c in S, if a - b, and b N c, then a = c.
Do either < or s define a total ordering on the integers? Explain.
13. Give an example of an equivalence relation on the integers that is not a total
ordering. Explain which properties of a total order hold for your example
and which don’t.
14. Explain why, in general, if - is a total ordering on a set S, then - is not an
equivalence relation on S. Conversely, explain why if - is an equivalence re-
lation on S, then - is not a total ordering.
15. Prove that if p is a prime number, then for every integer n,
np = n (mod p).
16. Investigate whether or not the following is true: If gcd (u, n) = 1, then
a“-1 -1 (modn).
17. Suppose that p is a prime number and gcd (a, p) = 1. Then explain why [u
p- 2]
is the multiplicative inverse of [a] modulo p. For each i = 2, 3, ..., p – 1,
find an expression for the multiplicative inverse of [a
i] modulo p.
18. We define an equivalence relation on ordered pairs of integers, Z x (Z – {O}),
(i.e., on all ordered pairs with the second entry nonzero) by (a, b) - (c, d) if
ad = be.
221

4 NUMBER THEORY
(i) Prove that this is an equivalence relation.
(ii) Describe the equivalence classes [(1, 2)], [(1, l)], [(4, 2)], and [(2, 3)].
(iii) In generaI, describe [(r, s)] and compare this with the rational number r/s.
(iv) Which equivalence classes [(i-, s)] have multiplicative inverses? If [(r, s)]
has a multiplicative inverse, what is it?
4:7 AN APPLICATION PUBLIC KEY
ENCRYPTION SCHEMES
Although our discussion of the greatest common divisor problem has been couched
in modern terminology, most of what we have presented in this chapter is ancient.
It was developed without any thought of computing machines like those we now
possess and with no anticipation of future applications. It is a truism in mathe-
matics that the purest (i.e., most theoretical and seemingly least applicable) ideas
from one generation of mathematicians frequently become indispensable took of
the applied mathematicians of subsequent generations. The application of the
Euclidean algorithm and related number theory that we are about to present
exemplifies this phenomenon.
The problem that we confront is that Bob wants to send Alice a message, the
content of which is to remain a secret from Eve. The message will be a sequence
of integers, M1, M2,. . . . Mk with O< Mi<N for i=l,2,. ... k, where N is a
number chosen with which to work modulo N. We’ll see how Alice chooses N
later. Such a representation of a message by numbers is no restriction. For exampie,
this book has been prepared electronically, and each character of the keyboard
of the computer terminal has associated with it a unique decimal number, in this
instance called its ASCII code. For use in this chapter we include the ASCII code
for capital letters in Table 4.1.
Table 4.1
Lettec A, B, C, D, E, F, G, H, I, J, K, L, M, N O, P,
code 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80
Q, R, S, T, U, V, W, X, Y, Z, blank
81 82 83 84 85 86 87 88 89 90 32
Thus the assumption that Bob’s message is a sequence of decimal numbers is
not restrictive. Sending a message might be by telephone or electronic mail or
ahnost anything else. Crucial to the model is that Eve has the technology to inter-
cept the message. This turns out to be surprisingly realistic. Thus if Bob just sends
Alice the ASCII code of the real message, we assume that Eve can intercept and
correctly interpret its content.
222

4:7 AN APPLICATION PUBLIC KEY ENCRYPTION SCHEMES
So what can Bob do? Very simply he must devise a way to disguise his message,
to encrypt it so that after Eve, or anyone else, intercepts the disguised message,
she will not be able to figure it out. Of course, if Bob does too good a job en-
crypting the message, maybe Alice won’t be able to figure it out either. So Bob
and Alice agree on an encryption scheme. When Bob has a message to send Alice,
he pulls out his encryption book (or maybe calls his encryption computer pro-
gram) and encrypts his message. Alice, having the appropriate decryption book
(or computer program), can unscramble or decrypt the message. This is fine unless
Eve obtains a copy of Bob’s encryption procedure. Then it may be that the message
is no longer secure. (If Eve obtains Alice’s decrypting procedure, presumably Eve
can decrypt any message that Alice can decrypt.) We shall describe here a method
that will tell Bob exactly how to encrypt his message. It will tell Alice exactly how
to decrypt the received message. Finally, (and this is truly magical), even if Eve
knows Bob’s method of encryption, Eve will not be able to decipher the message.
There is a family of related methods that will accomplish the above goals.
These are known as public key encryption schemes, and they use so-called trapdoor
functions. (The analogy is that encrypting information like opening a trapdoor from
above is easy, but decrypting like opening a trapdoor from below when one is
stuck in the trap is hard.) The scheme we present uses the Euclidean algorithm
and modular arithmetic and is known as the RSA scheme for Rivest, Shamir, and
Adleman, the inventors of the scheme. There are other schemes based on a wide
variety of mathematical ideas, and there is a great deal of research being done
on the question of just how secure these trapdoor schemes are.
Suppose that Bob wants to send a message with j letters, including blanks
between words. Using Table 4.1, this becomes a decimal number with 2j digits
when we replace each letter by the corresponding two digits of the ASCII code.
If Bob simply transmits the ASCII code equivalent, Eve will be able to look up
the ASCII code in a table and understand the message.
Example 7.1. The message “HELLO” becomes 7269767679.
Question 7.1. Translate the message “HOWDY” into its ASCII code equivalent.
Decipher the message 83858270327383328580.
Actually, most messages, like those just medtioned,  will turn into numbers that
are far too large to work with. Thus we agree in advance to break the 2j digits of
the message up into blocks of length B and then send k messages M 1, Afz,. . . . Mk,
each of length at most B.
Example 7.1 (continued). Let B = 4. Then we send the encryption of HELLO as
three messages: 7269, 7676, and 7932, with a blank added at the end to fill out
the last block.
223

4 NUMBER THEORY
Question 7.2. With B = 4, the largest code that can be sent using capital letters
is 9090. What letters produce this code? What is the smallest possible decimal
number that we can transmit with B = 4?
Now it’s time for Alice to get sneaky. She picks an integer N and announces
that all work will be done modulo N. In particular, the transmitted messages will
lie between O and N. (Then a convenient choice of block length B is one less than
the number of decimal digits in N.) The sneaky part is that Alice picks N to be
the product of two nearby, large prime numbers P and q. SO N = pq with P # q.
Now it is easy and quick to multiply two prime numbers or any two numbers,
even if they are very large. What is very difficult to do, given an integer N, is to
determine its prime factors.
(Note: All steps in this process are summarized at the end of the section in the
algorithm RSA.)
Exercise 14 gives a simple algorithm DIVISORSEARCH that searches for the
divisors of an integer N. (A more sophisticated algorithm for finding prime divisors
is presented in Supplementary Exercise 4.) DIVISORSEARCH finds divisors by
checking whether the integers 2,3,. ... up to ~ divide N. If N = pq, then either p
or q must be at most LfiJ. If, say, p is discovered to be a divisor, then q is found
as N/p.
So why not use this algorithm? DIVISORSEARCH is slow. (In Exercise 15
you are asked to verify that DIVISORSEARCH is exponential.) Faster ones have
been derived, using very deep mathematics, but all the known algorithms for fac-
toring a number have nonpolynomial  running time. For example, whereas we can
easily multiply together two 30-digit numbers to get a 60-digit number, if we are
given N with 60 digits it takes much longer to unscramble it into its prime factors.
If N is either a prime or the product of two large primes that are near one another,
then an algorithm as in Supplementary Exercise 4 would have to run about a year
before this fact is discovered. That’s no problem for this application Alice will
choose new values of p and q with N = pq every 6 months before Eve is abie to
find (or to run a computer program to find) the factors of N.
Question 7.3. Each of the following are of the form pq for primes p and q. Try to
factor each 323,4087, and 8633.
However, Alice has more tricks up her sleeve. After selecting N = pq,
she selects an integer e >1, known as the exponent, with the property that
gcd (e, (p – l)(q – 1)) = 1. Remember that the gcd of two numbers is easy and
quick to calculate. Alice can just try random numbers between O and N and run
the Euclidean algorithm on them to find an e relatively prime to (p – l)(q – 1).
Question 7.4. Let N = 7 11 = 77. Then search through 2,3,4,. . . to find four
numbers e that are relatively prime to 6 ~ 10 = 60.
224

4:7 AN APPLICATION: PUBLIC KEY ENCRYPTION SCHEMES
Example 7.2. Suppose that N = 9991 = 97 ~ 103, where 97 and 103 are both
prime. (These are not particularly large prime numbers but will keep us occupied
with calculations by hand.) Let us check that e = 11 meets the requirements for
an exponent by calculating gcd (1 I, 96. 102) = gcd(11, 9792).
9792 =890  ”11+2
11=5” 2+1
2=2” 1+0.
Once Alice has determined e, she will perform one more calculation, described
later, but then she may destroy the factors of N or else she must guard them
closely as they are the key to the security of this system.
However, Alice can be quite open with the numbers e and N. In fact, she
sends them to Bob without any secrecy. Maybe she even lists them in a phone
book or publishes them in the newspaper. These numbers will tell Bob (and for
that matter anyone who cares to send a message to Alice) how to securely encrypt
their message. The procedure goes as follows.
Here’s what Bob does to encrypt the message. First the original message is
turned into ASCII code using Table 4.1 and then the resulting huge number is
broken into blocks of length B. Each block is one of the messages M 1, M2,. . . . M~
to be sent. Next Bob must check that each message Mi, for i = 1,2,. ... k, is
relatively prime to N. If not, in the gcd calculation he will discover that their
common divisor is either p or q. In that case he announces to Alice and to the
world that he has found a factor of N and it is time to change their protocol (i.e.,
to change the values of e and N). However, most messages and numbers are
relatively prime to N as shown in Exercise 9.
Then for each message Mi, i = 1,2,. ... k, Bob calculates Ri, where
Ri = M; (mod N)
and
O< Ri <N.
Precisely, he can divide by N and find the remainder Ri
M~=QN+Ri
with O < Ri < N.
Then he will transmit the encrypted message R 1, R2,. . . . Rk.
Now My will often be a large number, but one that can be determined quickly
using FASTEXP however, there are additional ways in modular arithmetic to
keep the numbers relatively small. Recall that by Lemma 6.3, if a - b (mod N),
then ae = be (mod N). Thus when we need Mi, M?, M:, and so on for FASTEXP,
we can repeatedly replace the numbers by their least nonnegative residues modulo
N, as shown in the next example. This replacing process is also known as reducing
modulo N.
225

4 NUMBER THEORY
Examples 7.1 and 7.2 (continued). With N = 9991 and e = 11, we begin the
encryption of the message “HELLO” from its ASCII code 726976767932:
Ml = 7269
M2 = 7676
M3 = 7932.
First we check that gcd (7269, 9991) = 1. Then since M ~ 1 = MYM~M1,
we calculate
M; -52838361-5953 (mod 9991)
M; = (5953)
2 (mod 9991)
-35438209 (mod 9991)
= 132 (mod 9991)
My = (132)
2 (mod 9991)
e 17424 (mod 9991)
= 7433 (mod 9991).
Thus the first message RI that we want to send is
M~l -7433 ~ 5953 “ 7269 (mod9991)
a 44248649 “ 7269 (mod 9991)
-8501  “ 7269 (mod 9991)
-61793769 (mod 9991)
-9425 (mod 9991).
Question 7.5. Show that M2 = 7676 and M3 = 7932 are relatively prime to
9991 and then determine either R2 or R3 for these messages.
This procedure to encrypt a message could be implemented easily in a com-
puter program; see algorithm RSA.
There are two questions that require an answer. First, how is Alice to recover
the content of the original message? Second, assuming that Eve receives the
encrypted message and possesses the numbers e and N, why can’t she discover
the hidden message?
We answer the second question first. We assume that Eve intercepts the
message RI, R2, . . . . R~ with O < Ri < N for i = 1,2, . . . ,k. How might she find
M~, M2,. ... M~? Why can’t she just take the eth root of Ri to get Mi? Or why
not try all possible messages M, raise each to the eth power and reduce modulo N
until the correct messages are found?
Examples 7.1 and 7.2 (continued).
The 1 lth root of 9425 is 2.2977 ..., and so
this is not much help. The problem is that we took the 1 lth power of 7269 modulo
9991 and now we would need the 1 lth root modulo 9991, whatever that means.
226
.“

4:7 AN APPLICATION: PUBLIC KEY ENCRYPTION SCHEMES
The straightforward approach of trying everything would tell us to calculate
I’(mod 9991), 2e(mod 9991), 3e(mod 9991), and so on. But checking with the
ASCII code Table 4.1 we can be more clever. The encrypted word is a four-digit
number of the form:
3232,
32WZ (65 < WZ < 90), WZ32 (65 s WZ < 90),
or
UUWZ  (65 S UU, WZ < 90),
a total of 729 possible ASCII codes. Now for any integer i, ill requires five multi-
plications: three to form i
2, i
4, and i
8, and two more to combine these into il 1.
If at each stage one reduces modulo 9991, then five more divisions and five more
multiplications are needed. Thus in the worst case, after 10,935 multiplications
and divisions Eve can uncover which message &fi produced the transmitted
message Ri. In Chapter 2, Table 2.9, we assumed that a personal computer can
perform 17,800 single-digit multiplications or divisions in a minute. Since multi-
plying two 4-digit numbers requires at most 16 single-digit multiplications (plus
some additions), it will take Eve 10,935” 16/17,800 or about 10 minutes to recover
the messages (once she’s written the appropriate computer program on her PC).
That’s not so bad, but as we mentioned eadier, in this example we are really
working with small numbers compared with those used in real life.
More generally, one block of a transmitted message may have B < N decimal
digits, not just 4. Let’s figure out how long it will take Eve to decrypt a B-digit
number if she tries all possibilities. If we allow the ASCII code for all charac-
ters, not just for capital letters, then the B-digit number will lie between O and
10B+ 1 – 1. Suppose that the modulus N is roughly 10B
 + 1 and so exponentiation
by e, where 1< e < N, might use as many as O(log(N))  multiplications and divi-
sions. Thus a systematic search will invoive
o(log(lo~+ 1)1 OB+ 1) = O((B + l)lOB+ 1)
operations, clearly an exponential amount of work for Eve.
Question 7.6. Suppose that the modulus is N = 10
B + 1 and the B-digit numbers
can be any number between O and N and also e = 11. Then using the figures
from Examples 7.1 and 7.2, find the minimum value of B such that Eve must cal-
culate for a month before she can figure out all possible messages.
There is an interesting sidelight to the above phenomenon. When we say that
Eve has an exponential amount of work to do, in general, we are stating an
empirical fact about the worst-case scenario. At present there is no theorem that
227

4 NUMBER THEORY
says that Eve will need to examine all or even a large fraction of all numbers.
Thus it is conceivable that a clever idea would enable Eve to break this encryp-
tion scheme with an efficient decryption scheme. There are other variations on this
scheme with the same uncertainty, namely that there is no theorem that says de-
cryption must be exponential in the worst case, and yet no one has determined
how to “crack” these schemes with polynomial-time algorithms. This state of un-
certainty has prompted a great deal of research on the mathematics behind public
key encryption. The state of the art seems to be that encryptors have the upper
hand at the moment; however, the decrypters have made some progress that has
resulted in the encryptors having to work harder.
If Eve has such a difficult time decrypting the message, then how can Alice
successfully decrypt the message? Remember that Alice calculated one additional
piece of information about e and N = pq before she destroyed or hid the values
of p and q. Since e and (p – l)(q – 1) have gcd one, she used Corollaries 6.5
and 3.3 and secretly found the multiplicative inverse d of e modulo (p – l)(q – 1),
that is,
ed -1 (mod(p – I)(q – 1))
with O < d < (p – l)(q – 1).
The pair (d, N) is called the decrypting key.
Example 7.1 and 7.2 (yet again). With e = 11 and N = 9991, we find the multi-
plicative inverse d using the Euclidean algorithm. In one part of Example 7.2 we
checked that gcd (11, 9792) = 1 and we use these Euclidean equations as in Corol-
lary 3.3:
1=11–5”2
=11–5(9792-890”  11)
=4451 ” 11-59792.
Thus 4451 is the multiplicative inverse of 11 modulo 9991.
Decryption now is easy for Alice because she knows a theorem that implies
that
fori= 1,2,. ... k. Thus all she has to do is to calculate R:, replace it by the least
nonnegative residue modulo N and that’s the message Ali. And again she pulls out
a computer program that can quickly perform this exponentiation.
Examples 7.1 and 7.2 (concluded). The message 7269 was encrypted as 9425. Here
is a summary of the calculation of (9425)
4451:
9425
4451 = 9425
40969425
2569425
649425
329425
29425.
228

4:7 AN APPLICATION: PUBLIC KEY ENCRYPTION SCHEMES
With 12 multiplications we find
9425
2
-644 (mod 9991)
9 4 2 5
32 = 1975 (mod 9991)
942564
-4135  (mod9991)
9425
256 G 5202 (mod 9991)
9425
4096-1225 (mod 9991).
Then with 5 more multiplications we find
9425
4451-1225 ~ 5202.4135 
~ 1975.644”9425 (mod9991)
= 7269 (mod 9991),
just as we claimed.
Question 7.7. Suppose that N = 15 = 3 ~ 5 and let e = 7. Find d such that ed s
1 (mod 2” 4). Then encrypt each of the messages 2 and 7 using the exponent e and
then decrypt them using d.
Why does Alice’s decryption scheme work? The reason is the following theo-
rem, notice its similarity with Fermat’s little theorem, Theorem 6.6. They are both
cases of a more general result due to EuleL see Supplementary Exercises 23 and 24.
Theorem 7.1.
If p and q are distinct primes, n = pq, and gcd (a, n) = 1, then
a(p-l)(’-l) -1 (modn).
Why does this explain Alice’s decryption procedure? Alice knows that
R i - My (mod N).
Thus
R: E (M~)d (mod N)
= M;d (mod N)
= Mj+’(’-’)l)-l)  (modN)
for some integer k, since ed = 1 (mod (p – l)(q – 1))
= Mi(M~p
- ‘)(’- ‘))’ (mod N)
- Milk (mod N)
229

4 NUMBER THEORY
by Theorem 7.1, since gcd (Mi, N) = 1
= Mi.
Remember that Bob checked that gcd (Mi, N) = 1 for i = 1,2,. ... k and if not,
announced the need for a change of modulus N and exponent e. Now we see
that it is vital that Mi and N be relatively prime for the decryption scheme to work.
Proof of Theorem 7.1. (Notice the similarities between this proof and that of
Theorem 6.6.) Let Z. be the integers modulo n:
Z. = {[0], [1], [2],. . . ,[n – 1]}
and let A be the subset defined by
A = {[x] in 2“: gcd(x, n) = 1}.
First we count the number of elements in A by specifying and counting the
elements in Zn – A. Now for any [i] in 2., gcd (i, n) is 1, p, q, or pg. The only
element [x] for which gcd (x, n) = pq is x = O. Which elements [x] have gcd (x, n) =
p? Exactly x = p, 2p,. ... (q – l)P, and that’s all since n = pq. Which ones have
gcd (x, n) = q? Exactly x = q, 2q,. . . . (p – l)q. Notice that no two of these numbers
x are equal. For example, if ip = jq with 1 < i < (q – 1), 1 < j < (p – 1), then
p divides jq. Since p and q are distinct primes, p divides j, a contradiction since
j<(p– 1).
Thus the equivalence classes [p],. . . . [(q – l)p], [q],..., [(p – I)q] are all
distinct, and so there are 1 + (q – 1) + (p – 1) elements in Zn – A. Then A
contains
n–l–(p- 1)-(q-l)=pq-p–  q+l=~–l)(q–1)
elements. We list the elements of A as
A = {[rI], [rJ.. ., [r.]},
where 0<rl<r2 <””” <r, <n, s=(p–l)(q– 1).
Lemma 7.2. If gcd (a, n) = gcd (b, n) = 1, then gcd (ah, n) = 1.
Proof (of lemma). We prove the contrapositive. Suppose that
gcd(ab, n) = d >1.
230

4:7 AN APPLICATION: PUBLIC KEY ENCRYPTION SCHEMES
By Example 4.1, d has a prime divisor, say p. Thus p divides both n and ab and
thus at least one of a and b. So either a or b share a common prime divisor with
n contradicting our hypothesis.
n
We now use this lemma. Take any number a such that gcd (a, n) = 1 and look
at the equivalence classes
S = {[arl], [arz], . . . . [ar,]}.
By Lemma 7.2 gcd (ari, n) = 1 for i = 1,2,. . . ,s. In addition,
gcd(r1r2. . . r,, n) = 1.
(*)
We claim that the equivalence classes of S are the same as those of A, only
perhaps listed in a different order. Since gcd (ari, n) = 1, [ari] is in ,4 and so [ari] =
[rj] for some value of j. Furthermore, no two of the classes in S are equal if
[LVJ = [ar,]
for some values of i and k with ri # r~, then
ari a ark (mod n )
r i z r~
(mod n)
by Lemma 6.4
r i = rk
since ri, rk < n,
a contradiction. Thus S = A, and
since multiplication is well defined. Thus,
rlrz” “ “r~ G ar1ar2” “ “ar~
(mod n)
by Lemma 6.2
z asrlrz. “ “r~
(mod n)
1 = c? (mod n)
by Lemma 6.4 and (*)
= a(p- 1)(’- 1) (mod n).
n
Why can’t Eve find the decrypting pair (d, N)? Precisely because d is the multi-
plicative inverse of e modulo (p – l)(q – 1), and she doesn’t know the values of
p and q. As we saw before, factoring N to obtain p and q would require an ex-
ponential amount of work for her, unless she can think of something new and
clever. Perhaps Eve’s best bet is to study number theory and cryptography and
to search for an efficient decrypting algorithm. However, she should be aware that
231

4 NUMBER THEORY
Alice could do the same. Alice might even someday come up with a provably
secure system, that is, a system for which one can prove there is no polynomial-
time algorithm to decrypt messages.
Question 7.8. For either R2 or R3, calculated in Question 7.5, check that
R4451 = Mi.
t
We conclude with a summary of the steps needed in the RSA encryption and
decryption scheme.
Algorithm RSA
STEP 1. (Numerical calculations by receiver)
(a) Pick primes p and q, and let N = pq.
(b) Find e such that gcd(e, (p – l)(q – 1)) = 1.
(c) Find d such that ed = 1 (mod (p – l)(q – 1)) with
O<d<(p–l)(q– 1).
(d) Throw away p and q.
(e) Announce N and e to the world.
STEP 2. (Encryption)
(a) Translate the message into ASCII code using Table 4.1.
(b) Pick an integer B less than the number of digits in N.
(c) Break the ASCII coded message into blocks of B digits each;
call these MI, M2, . . . ,Mk.
(d) For i = 1,2,. ... k make sure that gcd (Mi, N) = 1; if not, announce
that the code is “broken” and return to step 1.
(e) Fori=l,2,..., k let Ri - M: (mod N) with O < Ri < N.
(f) Transmit the encrypted messages Rl, R2,. . . . R~.
STEP 3. (Decryption)
(a) For i = 1,2,..., k calculate Mi a R! (mod N) with 0< Mi <N.
(b) Fori=l,2,..., k translate Mi from ASCII code using Table 4.1.
EXERCISES FOR SECTION 7
1. Using Table 4.1 give the ASCII code for the following: (a) RIGHT ON, (b)
THE TRUTH, (c) ENCRYPT ME, and (d) FOREVER.
2. What do the following ASCII codes stand for in English?
(a) 7279 3272 8577.
(b) 7079 8287 6582 6832.
(C) 7879 3287 6589.
(d) 8479 3266 6932 7982 3278 7984 3284 7932 6669,
232

4:7 AN APPLICATION: PUBLIC KEY ENCRYPTION SCHEMES
3. Determine which of the following are the product of two distinct primes:
(a) 801, (b) 803, (c) 807, (d) 809, (e) 161, (~) 1631, and (g) 17,947.
4. For each of the following values of N = pq (from Question 7.3), find an integer
e such that gcd (e, (p — l)(q — 1)) = 1 and find the multiplicative inverse of e
(a) 323, (b) 4087, and (c) 8633.
5. If N = 77, e = 7, and B = 4, explain why Bob cannot send the message
PEACE to Alice.
6. Using blocks of four digits (B = 4), N = 8633 = 89.97, and e = 5 encrypt the
message CHEERS.
7. Using N = 95 and e = 29, decrypt the message (with B = 2)
53 29 02 51 29.
8. Let p be an odd prime and e an integer such that gcd (e, p – 1) = 1. Suppose
that a message M is encrypted as C, where
C E Me (mod p)
where O s C < p.
If d is the multiplicative inverse of e modulo p, then prove that
Cd E M (mod p).
9. Show that the number of numbers i such that O s i < n = pq and gcd (i, n) #
1 is q + p – 1. Then deduce that the probability of picking such an i is
1
1
–+––~.
P 
q u?
30 then show that the probability of choosing, at random, an
Ifp, q>10 ,
integer not relatively prime to n is less than 10 
– 29.
10. Write down in pseudocode an algorithm ENCRYPT that upon input of a
message MI, M2, . . . . Mk and N and e, encrypts the message using the RSA
scheme.
11. Write down in pseudocode an algorithm DECRYPT that upon input of a
received message Rl, R2,. . . . Rk, two primes p and q (where N = pq) and the
exponent e, decrypts this message.
12. Determine the number of multiplications and divisions performed in the worst
case of ENCRYPT and DECRYPT. (You may count each multiplication and
division as one, regardless of the number of digits.)
13. Prove the converse of Lemma 7.2.
14. Here is an algorithm to find divisors of an integer N.
233

4 NUMBER THEORY
Algorithm DIVISORSEARCH
STEP 1. Input N
STEP 2. For i:= 2 to L@J do
STEP 3. If i divides N, then output “i is a divisor of N“
STEP 4. If no divisors have been output, then output “N is a prime”
STEP 5. Stop.
Explain why this algorithm correctly determines when N is a prime. Ex-
plain why, if N is not a prime, this algorithm finds all, except possibly one,
prime divisors of N.
15. Explain why, in the worst case, there is a number r >1 such that the algorithm
DIVISORSEARCH performs at least r~ divisions, where D equals the number
of bits needed to express N in binary. Find as large a value of r as is possible
with your argument.
16. Modify the algorithm DIVISORSEARCH so that its output includes all prime
divisors of N. How many divisions does this perform in the worst case?
4:8 THE DIVIDENDS
The overall aim of this chapter has been to introduce the counting and algorithmic
ideas of discrete mathematics within number theory. In addition, this chapter
introduced specific results from number theory with indications of their applica-
bility in mathematics and computer science.
The chapter has focused on algorithms to determine the greatest common
divisor of two integers. In the text and exercises we found straightforward algo-
rithms to solve the gcd problem and then developed the less obvious Euclidean
algorithm. From the point of view of bit input, the straightforward algorithms are
bad and exponential, but EUCLID is a good and linear algorithm. The worst-case
complexity analysis of the latter algorithm is different from that of previous algo-
rithms in that it comes in two stages. First we show that if we use the Euclidean
algorithm on two successive Fibonacci numbers, then the number of multiplica-
tions and divisions is logarithmic in the input numbers. Next we show that in the
worst case of the Euclidean algorithm with arbitrary input b s c, O(log (c)) opera-
tions are performed. Thus the Fibonacci  numbers exhibit this worst-case behavior
and so the worst-case analysis really does reflect what may happen. What is also
true, but we do not prove it, is that the Fibonacci numbers are actually the worst-
case input for the Euclidean algorithm. In conclusion, we observe that O(log (c)) =
O(B), where B is the number of bits needed for the input.
Two important general ideas were introduced in this chapter. The first is
Complete Induction, which gives us more flexibility at the cost of more checking
234

4:8 THE DIVIDENDS
of base cases. Also we presented the idea that the size of the input to an algorithm
ought to be measured in terms of bits. Thus an integer n requires B [roughly
log (n)] bits, and it is in terms of this parameter B that we should be determining
and analyzing the complexity functions of algorithms. With this perspective we
look back to EXPONENT and FASTEXP of Chapter 2 and see that they are
exponential and linear algorithms, respectively.
A substantial amount of elementary number theory appears in Section 6.
Modular arithmetic and equivalence relations are central to much of mathematics
and computer science. For example, the theory of groups and rings involves
generalizations of Zn, the integers modulo n. Many computer languages come
with the ability to do arithmetic modulo n; this arithmetic is important in, for
instance, random number generation. Equivalence relations will be crucial in fur-
ther courses in theoretical computer science and mathematics. Thus the lemmas,
theorems, and corollaries of Section 6 are worth studying because they will come
up again both in applications and in other branches of mathematics and computer
science.
There is a variety of different encryption schemes in use today; each uses
different aspects of number theory. The approach we pursue relies on the Euclidean
algorithm and Fermat’s little theorem, but its effectiveness comes from the fact
that it is apparently difficult to factor a number into its prime factors. In fact, it
has recently been shown that the difficulty of “cracking” a variation of the RSA
scheme is computationally  equivalent to factoring a number n into two primes.
However, there is no known theorem that says it is hard to decrypt a message
sent using the RSA scheme or that it is hard to factor a number. A closely related
algorithmic problem is that of determining whether a given number is prime. Re-
cent fast, so-called random algorithms have been developed that can test whether
“most” numbers are prime, and there is a primality-testing algorithm that has been
shown to run in polynomial time on all integers, provided that a famous open
problem, the extended Riemann hypothesis, is true. No one has proved the latter
result, but most mathematicians believe it is true. Thus if you are tempted to set
up an encryption service along the lines of this chapter, take heed. It may be that
soon a mathematical or algorithmic breakthrough will occur and destroy the effec-
tiveness of the RSA encryption scheme.
Number theory is an excellent training ground for logical analysis and deduc-
tion. It is accessible: Small examples can be explored numerically, general patterns
deduced, and proofs constructed by induction and contradiction. The Fibonacci
numbers are a sample of the kinds of intriguing problems in the field. Others
include prime numbers, modular arithmetic, and solutions of equations. Number
theory also gives an introduction to the mathematical discipline of abstract algebra
and the computer science discipline of arithmetic and algebraic computations.
Especially if the ideas in this chapter interest you, these are fields worthy of
further study.
235

4 NUMBER THEORY
SUPPLEMENTARY EXERCISES FOR CHAPTER 4
1. Design a gcd algorithm called GCD2 that is based on the following idea. If
2 divides b and c, then 2 is a factor of gcd (b, c). Furthermore, we may carry
out the division and consider the smaller problem of finding the gcd (b/2, c/2).
If 2 does not divide b or c, try 3, . . . . try j. Note that the maximum value
ofj that you need to check is no more than b or &. Why?
2. Use GCD2 to find the gcd of the following pairs: (a) (8, 12), (b) (24, 32), and
(C) (72, 96).
3. In the worst case how many divisions will GCD2 need?
4. Design an algorithm that upon input m will find all prime numbers between
1 and m. (Hint: Use the idea behind GCD2. This idea is attributed to the
Greek mathematician Eratosthenes of the third century B.C. The method is
known as the Sieve of Eratosthenes:  First cross out all multiples of 2 except
for 2 itself. Next cross out all multiples of 3 except for 3 itself, . . . . and so
on. How far do you have to keep going with this crossing out process?)
5. Use your Sieve of Eratosthenes algorithm to find all prime numbers between
1 and 200.
6. Let U be the set of positive integers less than 49. Set A = {x e U: x is divisible
by 2}, B = {x= U: x is divisible by 3}, and C = {x= U: x is divisible by 5}.
Find IAI, IBI, and ICI. Find 1A u B u Cl. (Hint: Look at PIE from Chapter 1.)
Use the results of this problem to calculate the number of primes less than 50.
7. Two couples are camping in Hawaii with a pet parrot. They collect a pile
of macadamia nuts, but during the night one woman gets up, divides the pile
of nuts into four equal piles and finds one nut left over, which she gives to
the parrot to keep it quiet. She hides one pile, combines the other three piles
into one, and goes back to sleep. Then her husband wakes up, looks suspi-
ciously at the pile, divides the (remaining) nuts equally into four with one extra
nut for the parrot, hides one pile, and goes back to sleep. The same thing
happens two more timey each time the remaining nuts divide evenly into four
equal piles with one nut left over, which is given to the parrot, and one pile
is hidden. In the morning the four graciously divide the remaining nuts into
four equal piies and find they have one macadamia nut left over for the parrot.
What is the minimum number of nuts that they could have had at the start
of the evening’?
8. Look back at the definition of IC(b, c) in Exercise 3.13. Prove that gcd (b, c) =
min {lC(b, c)}.
9. Design an algorithm EXTENDEDEUCLID that first finds the gcd of b and
c as in the algorithm E~CLID and then expresses the gcd as a linear combina-
tion of b and c. The algorithm should use only a constant number of variables,
say 10 at most.
236

SUPPLEMENTARY EXERCISES FOR CHAPTER 4
10. (a) Suppose that n is even. Then the following sum equals a Fibonacci num-
ber. Which one is it?
(J+(n~1)+(n~2)+ (n~3)+””+(2)
(b) Find a similar sum of binomial coefficients that equals a Fibonacci num-
ber when n is odd.
11. Prove the results you obtained in Exercise 10. Hint: Use induction and the
fact that
(n~k)=((n-n+r-: =~-?
12. If the Euclidean algorithm is applied to c = F~ + ~ and b = Fk + ~, what can
you say about the number of Euclidean equations?
13. Suppose that the algorithm EUCLID is modified so that in step 3 the vari-
able q is set equal to the nearest integer to c/b. Run some examples of this
algorithm, including some Fibonacci numbers. Then anaiyze the complexity
of the algorithm in terms of c. Is this version more efficient than EUCLID?
14. Prove Lam&s Theorem: In the Euclidean algorithm the smallest values of c
that produces k Euclidean equations is c = Fk + ~.
15. Prove that if as -1 (mod n) and a’ E 1 (mod n), then agcd(s”) - 1 (mod n).
16. For ordinary integers, xy = O if and only if either x or y equals O. Give
examples to show that this is false in Z., that is, for equivalence classes modulo
n it is not true that
[x] [y]= [0]
if and only if [x] = [0] or
[Y] 
= [01.
17. Prove the following about equivalence classes modulo n. Given [x] # [0],
there is a [y] # [0] such that [x] “ [y] = [0] if and only if gcd (x, n) # 1.
18. Consider Z., the integers modulo n, where n = s t with gcd (s, t) = 1. Show
that there are at least four different equivalence classes [i] modulo n such
that [i]2 = [i]. For example, [0]
2 = [0
2] = [0].
19. If n = pq, then explain why the following are true:
p+q=n–(p–l)(q–  1)+1
P–q=/(p+q)2–4n.
Suppose that an algorithm were discovered that given an integer n = pq, a
product of two primes, could quickly calculate (p – l)(q – 1). Then use the
237

4 NUMBER THEORY
facts that
P=*((P+d+(P-d)
9=+((P+9)–(P–  9))
and the results of the previous equations to argue that there would be a fast
algorithm to factor n into its two prime divisors.
20. We define @(m) to be the number of integers i in {1, 2,. ... m} such that
gcd (i, m) = 1. Determine ~(6), 4(7), @(9), 4(10), d(p), and @(p2), where p is a
prime, and ~(pq), where p and q are distinct primes.
21. Prove Wilson’s theorem: If p is a prime, then p divides ((p – 1)! + 1). [Hint:
Show that (p – 2)! -1 (mod p) by pairing numbers with their multiplicative
inverses.]
22. Here are some ideas for an alternative proof of Fermat’s little theorem, which
states that bp
 – 
1 z 1 (mod p) if gcd (b, p) = 1. First show that if strings of beads
of Iength p are formed using b different colors of beads, then the number of
such strings that are not all one color is bp — b. (You should assume that
there is an unlimited supply of beads of each color.) If the ends of each string
are tied together to form a bracelet, explain why the number of different
colored braceIets is (b
p – b)/p. (For example, the string of red, blue, and green
beads forms the same bracelet as the string of blue, green, and red beads.)
23. A theorem due to Euler states that if gcd (u, m) = 1, then
s
o(m) = 1 (mod m),
where the function q5 is defined in Exercise 20. Verify that this theorem is true
for m a prime or a product of two primes.
24. Prove Euler’s theorem (of Exercise 23) using the following hints: Let A =
{[sl], [s~],. . . . [s@(~)]}, where the ~i are all the integers in {1,2,..., m} that
are relatively prime to m. Let S = {[as 1], [asZ],. . . . [aso(~)]}.  Then proceed
as in the proof of Theorem 7.1.
238

5 
GRAPH THEORY 
5:1 BUILDING THE LAN 
A college's minicomputers, terminals, and microcomputers are joined in a Local 
Area Network (LAN for short). The advantages include the potential to connect 
terminals and microcomputers with any minicomputer. the capacity to support 
more terminals on campus, and rapid transmission of data between terminals 
and minicomputers. The first step in the installation of the LAN was to link the 
basement of every building on campus using coaxial cable. This does not mean 
that each pair of buildings is joined by a cable. What it does mean is that it is 
possible to send electrical signals via the cable from any building on campus 
to any other building perhaps using one or more intermediate buildings. How 
should we, or the LAN designers, decide which pairs of buildings to join directly 
by coaxial cable'? 
Stoddard Hall 
College Hall 
D 
l=[j 
McConnell Hall 
Ainsworth Gym 
Figure 5.1 
Campus map. 
Example 1.1. 
Suppose that we want to connect College Hall (e), Ainsworth 
Gymnasium (A), and McConnell Hall (M) by coaxial cable. Which pairs of build-
139 
• ..1', i i \ 

5 GRAPH THEORY 
ings should be directly connected? See Figure 5.1. If we connect C directly to i'vi 
and M directly to A. then there is no need to connect C directly to A, since it is 
already possible to send electronic signals from C to A through M. There are three 
possible direct connections to make. Choosing any two makes the third unnec-
essary. 
Question 1.1. 
Suppose that Ainsworth Gym (A), College Hall (C), McConnell 
Hall (M), and Stoddard Hall (S) are buildings on campus to be connected by the 
LAN. See Figure 5.1. How many pairs of possible direct connections are there 
among the four buildings? How many direct connections do you need to install 
so that communication (though not necessarily direct) is possible between each 
pair of buildings? Will any set of this many direct connections work? Answer the 
same questions if five buildings are to be joined. 
Tn Example 1.1 why should any particular pair of connections be selected 
in preference to any other pair? In practice, such decisions are made to minimize 
the total installation cost. 
Example 1.2. 
Suppose that it costs $85,000 to install a cable between McConnell 
Hall and College Hall, $78,000 to install a cable between Ainsworth and 
McConnelL and $87.000 to install a cable between Ainsworth and College Hall. 
Which two direct cable links have minimum cost? The MC and AM links have a 
total cost of $163,000; the MC and AC links have a total cost of $172,000; and 
the AC and AM links have a total cost of $165,000. 
Question 1.2. 
Suppose that the cost of joining S with C is $30,000. the cos~ of 
joining S with M is $51.000, and the cost of joining S with A is $67,000. Using 
the data from Example 1.2, determine which pairs of A, C. lvi, and S should be 
directly linked in order to minimize the total cost. Compare your answer with 
that of the preceding example. 
What should be evident is that if there are only a few buildings. then Ihese 
calculations can be carried out by hand and the minimum cost plan can be found. 
If the number of buildings to be linked is at all large, then we need a good algorithm 
to figure out how to do it. In the next two sections we provide the mathematical 
framework with which to consider this kind of problem. Then we contrast bad 
and good algorithms to find these special pairs of buildings. 
EXERCISES FOR SECTION 1 
1. Neilson Library (N) is (0 be included on the LAN with McClmnell. Ainsworth. 
240 
Stoddard. and College Hall. The cost to join Neilson with the other buildings 
is given oy S20.000 to join N with S. S27.000 to join tv With C. S45,OOO (0 join 

5:2 
GRAPHS 
N with M. and $75.000 to join N with A. The other costs are the same as in 
Example 1.2 and Question 1.2. Which pairs of these five academic buildings 
should be directly linked in order to minimize the total cost? 
2. Suppose that there are six buildings. say A, E, C D, E. and F, that are to be 
joined in a LAN system. How many pairs of buildings are there that mi~;ht 
be joined by cable? How many pairs will you need to join in order to establish 
the LAN? The estimated costs (in tens of thousands of dollars) are given in 
the following table. What should be the pairs of the LAN system? 
A 
B 
C 
D 
E 
F 
.4 
() 
2.7 
3.8 
2.9 
7.8 
9.3 
B 
2.7 
() 
.U) 
5.2 
8.4 
6.9 
C 
3.8 
4.8 
0 
3.5 
4.6 
5.7 
D 
2.9 
5.2 
3.5 
() 
6A 
7.1 
E 
7.8 
RA 
4.6 
6.4 
() 
3.9 
F 
9.3 
6.9 
5.7 
7.1 
3.9 
0 
3. Suppose that you wanted to connect [our buildings in a communications systl~m 
so that there are two different ways to send messages from any building to ;my 
other building. How many pairwise connections would you need? Answer I.he 
same question for five buildings. 
4. Suppose in Question 1.2 that we require a direct link between McConnell Hall 
and College Hall. Otherwise. we still wish to find the least expensive LAN 
connections. Which additional direct connections should we add? 
5. Repeat Exercise I with the two constraints that McConnell Hall and College 
Hall must be directly linked, as must Neilson Library and Stoddard Hall. 
6. Draw the 3 x 2 and 6 x 5 rectangular grid (see Section 3.1). Suppose lhat e"ch 
line represents a street and at each street intersection there is a fire hydrant. 
[n each grid find a subset of the ~;treets that connects up all fire hydrants lo 
the lower left-hand corner and whose total length is as short as possible. 
5:2 GRAPHS 
The LAN of the preceding section can be modeled using what mathematicians 
and computer scientists call a graph (not to be confused with the graph of a fu 1C-
lion). For this problem the sets that we consider are the set of huildings and he 
set of pairs of buildings. 
Graph Theory Definitions. 
A graph consists of a t1nite set of vertices logetl1er 
with a finite set of edges. Each edge consists of a distinct pair of distinct vertices. 
If the edge e consists of the vertices: u.!":, we often write e = \11. c) and say that II 
241 

5 GRAPH THEORY 
is joined to v (also that v is joined to tt) and that tt and v are adjacent. We also say 
that both tt and [J are incident with the edge e. 
Although graphs are frequently stored in a computer as lists of vertices and 
edges, humans have a more picturesque way to thmk about graphs. Typically. we 
shall represent the vertex set of a graph as a set of points in the plane. An edge 
will be represented by a line segment or an arc (not necessarily straight) joining 
the two vertices incident with it. 
Example 2.1. 
Figure 5.2 exhibits two typical graphs. The vertices and edges of 
the graph in Figure S.2(b) are labeled so that we can reinforce the above definitions. 
In this graph x and:: are adjacent as are y and r .. and so on. The edge I = \2, y) 
is incident with both 2 and y, and y and IV are incident with the edge h. Note that 
r is not adjacent to IV. However, if the edges of this graph represent the direct 
cable connections in a Local Area Network, then IV and r are connected in the 
sense that an electronic message could be sent from IV to r going through y. 
Look back at Chapter 3 and notice that we were really doing a graph theory 
problem there, only we didn't call it by that name. We now call the diagrams orthat 
chapter by their usual names: grid graphs. Figure 5.3 shows the 3 x 2 grid graph. 
x 
e 
z 
f 
y 
'\ 
w 
(aj 
Ib) 
Figure 5.2 
Figure 5.3 
Some Notation. 
In a graph G the vertex set will be denoted by V(G) and the 
number of vertices by )VIG)i = V (if there is no ambiguity as to which graph we 
are talking about). Similarly, the edge set will be denoted by £(G) and the number 
242 

5:2 
GRAPHS 
of edges by IE(G)I = E. Often the vertices of a graph will be labeled so that they 
can be distinguished or named according to the intended application. 
Example 2.i(again). 
In Figure 5.2(b), V(G) = (x,y . .:, w,r: and V = 5. Alw. 
E(G) = [e, J. g, 11, iJ =: (.x . .:), (y, .:j, (x, w), (y, wi, (y, r)} and E = 5. 
Question 2.1. 
Draw a graph with V = 4 and E = 3. Is there more than one such 
graph? 
Another Definition. 
The degree of a vertex x IS the number of vertices adjacent 
to x (or equivalently, the number of edges incident with x). Within a graph G we 
denote the degree of x by deg (x, G) or deg (x) if there is no confusion as to which 
graph G we refer to. 
One way to think about a graph is as if ir were constructed of buttons and 
thread: The buttons represent the vertices and the thread represents the edges. In 
this model the degree of a vertex is the number of strands of thread emanatmg 
from the corresponding button. 
Example 2.1 (once more). 
In Figure 5.2(b), deg(x) = 2 = deg(z) = deg(w), while 
deg (y) = 3 and deg (r) = 1. 
Question 2.2. 
For the graph shown in Figure 5.4 determine V. E, and the degree 
of each vertex. Find the sum of the degrees of all the vertices. 
Figure 5.4 
In the preceding question you might have noticed that the sum of the degrees 
was exactly twice the number of edges. That this happens in general is our hrst 
result. 
Theorem 2.1. 
If V(G) = [XI"" .xv}, then 
deg(xd + ... + deg(xv) = 2E. 
Proof'. 
Since the degree of a vertex is the number of edges incident with that 
vertex, the sum of the degrees counts the total number of times an edge is incident 
with a vertex. Since every edge is incident with exactly two vertices, each edge 
gets counted twice, once at each end. Thus the sum of the degrees equals twice 
the number of edges. 
r-' 
243 

5 GRAPH THEORY 
Question 2.3. 
A vertex whose degree is odd is called odd. Show that in any graph 
there is an even number of odd vertices. 
To answer the second part of Question 2.1 with assurance you need to know 
how to decide if two graphs are the same or different. 
Definition. Two graphs, say G and Fl, are said to be isomorphic· there exists a 
function f: V( G) ---> V(m such that 
(i) f is both one-to-one and onto, 
(ii) I preserves adjacencies, and 
(iii) I preserves nonadjacencies. 
Isomorphic is a fancy mathematical word meaning fundamentally the same. 
Two graphs that are not isomorphic are also called different. Properties (ii) and 
(iii) can be formalized as 
(ii') If (x,y) is in E(G), then U(xl,f(y)) is in E(H) and 
(iii') [f (x, y) is not in E( G), then U(x),)'(y)) is not in E(H). 
The function f that shows the correspondence between the vertices of G and 
the vertices of H is called an isomorphism. [n practice. it is displayed by label-
ing the vertices of G and If with letters or numbers and then explicitly writing 
out the function values fix) for each x in V(G). Or the vertices of G and H can 
be labeled so that if x is labeled A in G, then I(x) is labeled A in H. 
Example 2.2. 
The graphs G and H in Figure 5.5 are isomorphic as are the graphs 
K and M. Note that in the figure both G and Fl have four vertices and five edges 
while K and :vI both have four vertices and four edges. In general. if G and Hare 
isomorphic graphs. then by property (i), \V(G)I = \V(H)I and by properties (ii) and 
(iii), IE(G)I = IE(H)I. Furthermore. degtx. G) = deg(f(x), H) for every x in V(G), 
lISl
2 
"[21' 
((1) ::: h 
/(2) = a 
/(3) = d 
(4) = (' 
3 
4 
{' 
d 
(; 
ii 
"Db 
(' 
" 
"~<r 
iJ 
(' 
K 
,11 
Figure 5.5 
244 

5:2 GRAPIIS 
Example 2.3. 
Figure 5.6 shows the six different graphs on two and three vertices. 
(Note that a graph need not be connected in the sense of the LAN.) 
o 
o 
I 
o 
o Iv 
I 
o 
o 
'a) 
Ib) 
Ie) 
(d! 
(e) 
If) 
Figure 5.6 
Question 2.4. 
Find the 11 different graphs on 4 vertices. 
Question 2.5. 
Note that the graphs C and H shown in Figure 5.7 have identical 
degrees. Show that they are not isomorphic. 
G 
H 
Figure 5.7 
[t is an open question whether there exists a good algorithm to determine if 
two graphs are isomorphic. This question is of considerable interest to. for instance. 
chemists. They model chemical molecules using graphs, where vertices repre~ent 
the individual atoms and edges represent the chemical bonds. It is sometimes dif-
ficult given two molecules with identical atomic constituents to determine whether 
they are the same. If chemists synthesize a particular molecule in the laboratory 
and want to find out what is known about it, they need some method of recognizing 
when the chemical is discussed in the literature. that is. they want to be able to 
test graph isomorphism. Supplementary Exercises 6 to l) ask you to construct md 
analyze straightforward graph isomorphism algorithms. 
There is a notable connection between graphs and relations, as detined in Sec-
tion 4.6. Given a symmetric relation ~ on a finite set S, we may create a graph C 
with V(C) = S and for ll, hE S an edge (a, h) f:' E(G) if and only if Ll ~ h is true. 
Conversely, a graph G and its edges define a relation on the elements of V(G). See 
Exercises 24 to 27 and Supplementary Exercises 32 to 34. 
We dose this introductory section on graphs by defining and presenting some 
special classes of graphs. 
245 

5 GRAPH THEORY 
Definition. 
A graph in which every pair of distinct vertices is joined by an edge 
is called complete. A complete graph with r vertices is also called an "-clique and 
is denoted by K ... 
Example 2.4. 
Figure 5.8 exhibits K4. and K 5' Note that these graphs have 6 and 
10 edges, respectively. 
K4 
Figure 5.8 
Theorem 2.2. 
An r-clique contains exactly r(r -
1)/2 edges. 
We present four proofs. It is worthwhile to understand all four, since they 
represent different ways of thinking about the problem. 
Proof 1. 
We proceed by induction. A one-clique is a vertex without any edges. 
which satisfies the formula. In Figures 5.6 and 5.8 we see that K 2 , ... ,Ks have 
the correct number of edges. Thus the base case is safely accounted for. Suppose 
that the theorem is true for r = k. We must show that it is then true for r = k + l. 
Given a (k + 1 i-clique. pick a vertex. say x. If we erase x and all edges incident 
with x from our graph, we are left with a k-clique, which has k(k - 1)/2 edges by 
the inductive hypothesis. In our original graph the vertex ,'( was incident with" 
edges, one to each of the other vertices. Thus the total number of edges in the 
(k + I)-clique equals 
k(k -
1) + k = k(~~ + I) = k(k + 1) =(k + I){(k + 1) -
Ii 
2 
2 
2 
2' 
which is what we needed to prove. 
I~ 
Proof::. 
Let's draw Kyo adding one vertex at a time. When we draw the first 
vertex. we need no edges. When we add the second vertex. we need to draw one 
edge to connect the two vertices. When we add the third vertex. we must join it 
to the two previously created vertices. so we need to draw two more edges. In 
general, when we add the kth vertex. we need to draw k -
I new edges. Thus the 
246 

5:2 GRAPHS 
total number of edges we need to draw is 
1 + 2 + 3 + ... + (I' -
1). 
We have seen that this sum equals (I' -
1) {(I' -
1) + 1 }/2 in Section 2.3. 
'-.1 
Proof 3. 
In Kr each vertex has degree r -
1. Thus the sum of the degrees equals 
r(r -
I). By Theorem 2.1, this sum also equals 2E. Thus 2E = 1'(1' -
1) and E = 
r(r -
1)/2. 
.:::J 
Proof 4. 
The number of edges in Kr equals the number of 2-subsets of an r-set, 
which equals (;) as we saw in Chapter 3. 
=:J 
Question 2.6. 
How many edges are there in K 7'? 
Corollary 2.3. 
For any graph, E::;; V(V -
1)/2. 
A graph is said to be bipartite if its vertex set can be partitioned into two sets, 
say Rand B, with the property that every edge joins a vertex in R with a vertex 
in B. Such graphs are also called 2-colorable, since you can think of the vertices 
in R as being painted red while the vertices in B are painted blue. With this paint-
ing no vertex is joined by an edge to a vertex with the same color. A bipartite graph 
is said to be a complete bipartite graph if every red vertex is joined by an edge 
to every blue vertex. The complete bipartite graph with p red vertices and if blue 
vertices is often denoted by Kp,q' (Notice that this definition cries out for an 
algorithm to decide if a graph is bipartite. and if it is, to construct the sets Rand 
B; see Supplementary Exercise 10.) 
Example 2.5. 
Each of the graphs in Figure 5.9 is bipartite. The graph in Figure 
S.9(c) is the complete bipartite graph K 3•3 . 
R 
R 
R 
R 
B 
H 
B 
B 
R 
B 
R 
R 
B 
B 
/3 
H 
fa) 
• C) 
H 
R 
(6) 
Figure 5.9 

5 GRAPH THEORY 
Question 2.7. 
Which of the graphs in Figure 5.10 are bipartite'? [f a graph is 
bipartite, color its vertices red and blue so that no edge joins two vertices of the 
same color. [f it is not bipartite. explain why its vertices cannot be so colored. 
(a) 
Figure 5.10 
EXERCISES FOR SECTION 2 
(6) 
1. Draw a graph with five vertices that illustrates your LAN connections from 
Exercise 1.1. 
2. Draw a graph with 6 vertices and to edges. 
3. For the following graphs find V. E, and the degree of each vertex. 
fa) 
(h) 
Ie) 
~. Find all the different graphs with five vertices and two edges. How about 
three edges? What is the maximum number of edges a graph on live vertices 
can have'? 
5. Suppose that G is a graph with V vertices. What is the largest possible degree 
of a vertex in G? 
6. Suppose that G is a graph with V vertices and E = V -
I edges. Prove that 
G contains a vertex of degree 0 or I. 
248 

5:2 
GRAPHS 
7. Prove Theorem 2.1. using induction on E. 
8. At the beginning of a business meeting some of the participants are introduced 
to each other. In an introduction A is introduced to Band B is introduced 
to A for some pair A and B. Show that the number of individuals who have 
been introduced to an odd number of other individuals is even. 
9. A graph in which every vertex has degree r is called regular of degree r. Fnd 
examples of graphs that are not cliques but are regular of (a) degree 1, (b) 
degree 2, and (c) degree 3. 
10. For each of the following sequences either find a graph whose vertices have 
exactly these degrees or show that such a graph cannot exist. 
(a) 3,3,1,1. 
(b) 3,2,2,1. 
(c) 5,4,4,2,2,2. 
(d) 3,3,2,2. L 1. 
(e) 4, \.1.1,1. 
(f) 2,2,2,1, l. 
(g) 7,3,3.3,2,2. 
(h) 5,5,5,2,2,2,2, 1. 
11. (a) Find all different graphs with 6 vertices and 15 edges. 
(b) Find all different graphs with 6 vertices and 14 edges. 
(c) Find all different graphs with 6 vertices and 13 edges. 
12. Which of the following pairs of graphs are: isomorphic? For each isomorphic 
pair, exhibit the isomorphism. 
fa) 
(6) 
Ie) 
Id) 
249 

5 GRAPH THEORY 
13. Find two nonisomorphic graphs with six vertices both of which are regular 
of degree 3. 
14. Explain why a regular graph with V vertices and E edges must have all vertices 
of degree 2E/V. (See Exercise 9.) 
15. Which of the following graphs are bipartite? Label the vertices of the bipartite 
graphs with Rand B so that no edge joins two vertices with the same label, 
and explain why the others cannot be so labeled. 
(a) 
Ib) 
[ 
(e) 
(d) 
16. Draw Kh and K 7 . What is the smallest value of n such that Kn has at least 
1000 edges? 
17. Is there a bipartite graph with 10 vertices that is regular of degree 3'1 If so, 
find one; if not. explain why not. 
18. Exhibit all the different graphs with 6 vertices and 3 edges. and 6 vertices and 
12 edges. 
19. Find a formula for the number of edges in K p,q' Prove your formula in two 
different ways, one of which must be by induction. 
20. If G is a bipartite graph on 12 vertices, what is the largest number \)1' edges 
that G might have? 
21. If G is a bipartite graph on V vertices, what 1S the largest number of edges 
that G might have? 
250 

5:3 TREES AND THE LAN 
22. The generalized cubes Qn are graphs defined as follows: The vertices of QII 
consist of all binary sequences of length 11, that is, V(QIIJ = [0, I) ". Two verti~es 
in Qn are joined by an edge precisely if the corresponding binary sequences 
differ in exactly one entry. Thus the vertices of Q 1 are 0 and 1 and then: is 
an edge joining them. The graph Q2 follows. Draw Q3 and Q4' How m"ny 
vertices and how many edges does Qn have? 
0111
11 
ooL 10 
23. Show that for all 11, Qn [defined in Exercise 22} is bipartite. 
24. Let S = [0,1,2, ... ,9} and suppose that for X,Y E S, X ~ Y is true if and only 
if x and yare both even or both odd. Draw the corresponding graph. 
25. Let G = K 3•3 . Specify the corresponding relation on V(G) = {1,2,3.4,5.6}. 
Do the same for G = K 6 • 
26. Are the relations in Exercise 25 reflexive or transitive? 
27. If G is a graph, explain why the corresponding relation ~ is necessarily a 
symmetric relation. 
5:3 TREES AND THE LAN 
In our model of cable connections for the LAN system we wanted to be able to 
send an electrical signal from any building to any other building. This property 
corresponds with the notion of connectivity. Here is an informal description. With 
the button and thread image from the previous section, a graph is connected if 
whenever you pick up a button and walk out of the room. the entire graph comes 
with you. If only some of the graph comes with you, the part that comes with 
you is called a (connected) component. 
Example 3.1. 
In Figure 5.11, G is connected while H has three components. 
1r 
o 
G 
H 
Figure 5.11 
251 

5 GRAPH THEORY 
Even though this informal definition of connectivity captures the spirit of the 
concept correctly, we need a less "seamy" definition to enable us to prove theorem~; 
about connected graphs. 
Definition. 
Given a graph G with vertices x and y, a path from x to y of length 
k is a sequence of k distinct edges, e1,e2"" ,eko such that 
and finally, 
Frequently, we just list the vertices that are incident with the edges of the path, 
like x, X1, x 2 , . .. , Xj _ l' X j " .. ,Xk _ [0 y. We may say that there is a path of length 
zero from a vertex x to itself. A path from x to itself of length k is called a k-cycle. 
Example 3.2. 
In the graph of Figure 5.12 the vertices a, b, c, d, and e form as·· 
cycle. There is a path from a to : of length four using the vertices h, c, and r as 
well as a path from a to : of length three using the vertices e and d. In the latter 
path e 1 = (a,e), e2 = (e,d), and e.l = (d,:). 
p 
d 
z 
/ 
o D 
a 
Ii 
c 
r 
Figure 5.12 
Question 3.1. 
[n the graph of Figure 5.13, tind a path of length live from <t to h, 
a path of length three from: to r, and a 4-cycle lhrough h. 
Recall that we used this terminology when discussing grids in Chapter 3. For 
example, in the 6 x 5 grid graph we were searching for paths l)f length I I from 
Ithe vertex) M to (the vertex) P. 
252 

5:3 TREES AND THE LAN 
a 
c 
d 
b 
e 
'O---~, 
l 
z 
x 
w 
Figure 5.13 
Definition. 
The graph that consists of a path of length k from one vertex to 
another vertex with no repeated vertices is called P k' The graph that is a k-cyde 
with no repeated vertices is called C k' 
Example 3.3. 
The graphs P -' and C 5 arc shown in Figure 5.14. 
Figure 5.14 
We use the concept of path to define connectivity precisely. 
Definition. 
A graph G is said to be connected if for every pair of vertices x: and 
y, there exists a path from x to y. The distance between x and .II, denoted d(x, y), 
is the smallest number of edges in a path from x to y. Given a vertex x withir: a 
graph G. the component of G containing x consists of the set of vertices and the 
set of edges in G that are a part of some path beginning at x. 
We emphasize that this does not mean that in a connected graph every pair 
of vertices is joined by an edge. 
If we construct a graph to model the LAN. the vertices will represent (he 
buildings of the campus and the edges will represent the pairs of buildings that 
are directly joined by a coaxial cable. We want this graph to be connected. On 
the other hand. we don't want to include unnecessary connections. These proper-
ties suggest the following definitions. 
Definition. 
A forest is a graph with no cycles. (Such a graph is also called acyclic.) 
A connected graph with no cycles is called a tr,ee. 
Trees are the most widely applicable type 001' graph. We shall explore some of 
their properties in the remainder of this section and use them (0 settle the LAN 
question. 
253 

5 
GRAPH THEORY 
o 
I L C ~ 
Figure 5.15 
Example 3.4. 
Figure 5.15 exhibits all the different trees on fewer than 5 vertices. 
The union of these graphs forms a forest with 5 components and 14 vertices. Figure 
5.16 shows a tree whose bark is worse than its bite. 
Figure 5.16 
Question 3.2. 
Find the three different trees on five vertices. 
Question 3.3. 
How many edges does a tree on six vertices contain? Does the 
answer depend upon the tree or is the answer the same for all trees on six vertices? 
Theorem 3.1. 
If T is a tree with V vertices and E edges, then 
E=V-l. 
Proof. 
We proceed by induction on the number of vertices. You can consult 
Figure 5.15 to see that the result is true for V = 1, 2, 3, and 4. We assume that 
the result is true for all trees with fewer than V vertices. Consider an arbitrary 
tree T with V vertices and an edge e = (x, y). What happens if we remove the edge 
e from T? We illustrate in Figure 5.17. 
x 
y 
y 
T 
T' 
]''' 
Figure 5.17 
~54 

5:3 TREES AND THE LAN 
The resulting graph is a forest made up of two trees, one containing the vertex 
x and the other containing the vertex y. Let T' denote the tree containing x and T" 
denote the tree containing y. Suppose that the number of vertices in T' is V' 
and the number of edges in T' is E'. Similarly, the number of vertices in T' is V" 
and the number of edges in T" is E". Since both T' and T" are trees that have 
fewer vertices than T, we can assume by the inductive hypothesis that 
E' = V' -
1 
and 
E"= V" -1. 
The number of edges in T is one more than E' + E" (since e is in T) while :he 
number of vertices in T equals V' + V". Thus 
E = E' + E" + 1 
= (V' -
1) + (V" -- 1) + 1 
= V' + V" - 1 
=V-l. 
c 
Question 3.4. 
If you want to join every pair of buildings on a campus with 40 
buildings, how many different coaxial cables do you need? What is the minimum 
number of cables that must be installed to sustain a LAN system connecting these 
40 buildings? 
Question 3.5. 
(a) Let C denote the number of component trees in the forest shown 
in Figure S.lS. Show that E = V - C. (b) More generally, show that if F is any 
forest with V vertices, E edges, and C component trees, then E = V -
C. [Hint: 
Suppose that for i = 1, ... , C, the ith component tree contains Vi vertices and Ei 
edges.] (See also Exercises 24 and 2S.) 
That a tree on V vertices has exactly V-I edges is fundamental. Indeed this 
property can be exchanged with either of the two defining properties of a tree. This 
is shown in the next theorem and the questions that follow it. 
Theorem 3.2. 
{f G is an acyclic graph with V vertices and V-I edges, then G is 
a tree. 
Proof". 
If G is acyclic, then G is by definition a forest. By the result in Question 
3.S a forest with V vertices, E edges, and C component trees necessarily has 
E=V-C. 
:55 

5 GRAPH THEORY 
Solving for C and substituting for E yields 
Thus C = 1 and G is a tree. 
C=V-E 
=V-(V-ll=1. 
Question 3.6. 
Show that if G is a connected graph containing a cycle and if e is 
any edge of the cycle, then G - e is connected. (By G - e we mean the graph ob-
tained from G by erasing e, that is, removing e from the edge set while leaving e's 
incident vertices in the vertex set.) (Hint: Pick a pair of vertices in G, say x and y, 
and describe a path from x to )' in G -
e.) 
Question 3.7. 
Show that a connected graph with V vertices and V-I edges is a 
tree. (Hint: Use the result of Question 3.6.) 
We now have most of the mathematical machinery necessary to construct an 
algorithm to pick the pairs of buildings that ought to be 'joined directly by coaxial 
cables in the LAN system. In our model of the campus buildings we wanted enough 
cables to be installed so that the graph that represents the cable connections is a 
tree. Recall the two defining properties of trees: They are connected and acyclic. 
We need the connectivity because that is just the property that mimics the "real 
world requirement" that electrical signals can be sent between any pair of buildings. 
If the cable graph had a cycle, then by Question 3.6, it would remain connected 
if some cable in the cycle were removed. Consequently, in seeking a minimum cost 
connected graph we are inexorably led to a tree (provided that no edge has a 
negative cost, i.e., no one is willing to pay us to install an extra cable connection). 
We need just a few more definitions to be able to t1nish the task. 
Definitions. 
Suppose that V(G) and E(G) denote the vertex and edge sets of a 
graph G. If H is a graph with the properties that 
(I) V(H) s V(G), 
(2) E(H) s E(G), and 
(3) every edge of E(H) has both its incident vertices in V(H), 
then H is called a subgraph of G. If V(H) = V(C), then H is called a spanning sub-
graph of G. If in addition H is a tree, then H is called a spanning tree of G. 
Example 3.5. 
Let G be the graph shown in Figure 5.18. If V( H) = : L 2, 3l and 
E(H) = :(1. 2)), then H is a subgraph. If V(H) = : I, 3,..J.} and £(H) = [(1. 2)}, then 
H is not a subgraph. If V(H) =: 1,2, 3,..J., 5} and E(H) = :(1.2),(2,3),(3,4),(4,5), 
(l,5)}, then H is a spanning subgraph. If V(H) = : 1,2,3,..J.,5} and E(H) = [(1,2), 
(2, -'), (3, ..J.), (4,5)}, then H is a spanning tree. 
156 

5:3 TREES AND THE LAN 
5 
2 
V\l 
4 
::I 
Figure 5.18 
Question 3.8. 
Find a spanning tree of the graph in Figure 5.19. 
Figure 5.19 
Does every graph have a spanning tree and how can we find a spanning tree 
in a graph with one? In Exercise 13 you are asked to prove that a graph contains 
a spanning tree if and only if it is connected. If a graph is disconnected, it con-
tains a spanning tree for each connected component; such a collection of trees is 
called a spanning forest. In Exercise 19 we present an algorithm SPTREE that 
produces a spanning tree of a connected graph. The algorithm SPTREE actually 
does more than promised and produces a spanning forest of a disconnected graph. 
We return to the LAN problem. We improve our graph theory model to 
incorporate the costs of installing the cables. 
Weighty Definitions. 
Let R + denote the set of positive real numbers. A graph G 
together with a function w:E(G) ~ R + is called a weighted (or an edge-weighted) 
graph. If e is in E(G), then w(e) will be the weight of e. If F s; E(G), then w(F), the 
weight of F, is defined to be the sum of the weights of the edges in F. 
Typically, the numbers assigned to the edges will represent costs, capacities, 
lengths, or some parameter of real-world interest. 
Example 3.6. 
Given the weighted graph G shown in Figure 5.20, the graph H is 
a (weighted) spanning tree of G whose total weight is 37. 
3 
8 5rn 
3 
2 
71 
6] 
( 
7 
5 
3 
4 
5 
1 
7 
4 
5 
7 
(; 
H 
Figure 5.20 
257 

5 GRAPH THEORY 
Question 3.9. 
Given the weighted graph shown in Figure 5.21, find all the span-
ning trees of this graph and the weight of each. 
3 
4 
5 
6 7 
8 
Figure 5.21 
Our LAN problem can now be formalized as follows. Given the weighted 
graph G with vertices representing the buildings, edges representing the possible 
direct cable connections, and edge weights representing the installation costs of 
the corresponding cables: find H, a minimum weight spanning tree of the graph 
G. It is important to distinguish the edges of G that represent the possible direct-
cable connections from those of H that represent the actual direct-cable connec-
tions. We shall examine two different algorithmic solutions to this question. Firs1 
we state the problem succinctly. 
Problem. 
Given a weighted graph G, find a spanning tree H with minimum total 
weight. 
The idea of our initial, naive algorithm is that every subset of V -
ledge~ 
of a graph that forms a connected or an acyclic subgraph gives a spanning tree 
by Theorem 3.2 and Question 3.6. 
Algorithm BADMINTREE 
STEP 1. Input the weighted graph G 
STEP 2. Use algorithm ]SET from Chapter 3 to find all subsets of the edge.,; 
of G that contain exactly V-I edges 
STEP 3. If a (V -
I)-subset of E(G) forms a tree, compute its weight 
STEP 4. If there are no trees in step 3, output the fact that there is no spanning 
tree; otherwise, select and output a spanning tree of minimum weight; 
then stop. 
Question 3.10. 
Run the algorithm BADMINTREE on the weighted graph in 
Figure 5.22. 
258 

3 
6 
5 
3 
Figure 5.22 
5:3 TREES AND THE LAN 
4 
The name of this algorithm gives away the quality of its performance. We 
know that JSET performs at least (~) steps to find all j-subsets of a set with E 
elements; here it's the set of E edges whose (V -
I )-subsets we list. Each edge rep-
resents the potential installation of a cable. Since, in general, we cannot eliminate 
any of these possibilities, by Theorem 2.3, E = V(V -
I )/2. Thus the numbt.:r of 
steps is at least 
(
V(V - 1)/2) 
(V -
1) 
. 
Question 3.11. 
Evaluate (*) for V = 3,4,5,6,7. 
(*) 
This binomial coefficient evidently grows rapidly. Exercise 23 asks you to find 
lower bounds. In the next section we shall find a much more efficient way to ~olve 
the LAN Problem. 
EXERCISES FOR SECTION 3 
1. Find all trees with six vertices. Find a graph with six vertices and five edges 
that is not a tree. Can you find such a graph that is also acyclic? 
2. For what values of n is en bipartite? 
3. Show that trees are bipartite. 
4. How many different 5-cycles are there in the following graph? Before amwer-
ing, specify what it means for two 5-cycles to be different. 
a 
h 
c 
d 
259 

5 GRAPH THEORY 
5. Give an example of a graph G and a subgraph H of G that is not a spanning 
subgraph. Give an example of a spanning subgraph of G that is not a spanning 
tree. 
6. The average degree of a graph is the sum of the degrees of all the vertices of 
the graph divided by the number of vertices. Show that the average degree 
of a forest is less than 2. 
7. Which of the following pairs of trees are isomorphic? 
(b) 
(c) 
8. Find the longest path and the longest cycle that is a sub graph of the following 
graphs and give their lengths. Then find the largest value of) and k such that 
Pj and Ck are subgraphs of the given graph. 
fa) 
Ib) 
9. Let x and y be two vertices in the r-clique, K,.. Explain why there are paths 
of length 1.2 ..... and (r ~ \) joining x and y. For each r > 3, describe a graph 
other than a clique that contains I' vertices. some pair of which are joined by 
paths of all possible lengths. 
260 

5:3 TREES AND THE LAN 
10. Identify the components in the following graphs. 
(a) 
G 
(b) H where V(H) = p, .... lO} and E(H) = [(1. 2), (3,4), (5.6), (7,8), (9, 10), 
(3,5), (5,8), (1,9), (4, 10), (6,9)} 
11. If G is a connected graph and x, y, and .: are vertices, is it always true that 
d(x, y) + d(y,,:) ;::: d(x, .:)? Give a proof or counterexample. 
12. Given the weighted graph shown here. find all of the spanning trees of this 
graph and the weight of each. 
7 
') 
,ITJs 
10 
11 
13. (a) Prove that a graph is connected if and only if it has a spanning tree. 
(b) Prove that every graph contains a spanning forest that consists of a 
spanning tree of each component. 
14. Determine whether the following are true or false. Prove each true statement 
and give a counterexample for each false statement. 
(a) A graph with E ;::: V is connected. 
(b) A graph with E ;::: V contains a cycle. 
(e) A graph with E ::;; V -
.2 is not connected. 
(d) A graph with E::;; V - 2 is acyclic. 
(e) A graph with two components has at most V - 2 edges. 
(f) A graph with E = V - 2 has at least two components. 
(g) A graph with E = V -
.2 has exactly two components. 
(h) If G is a connected graph containing a cycle, then the removal ()f any 
edge of the graph leaves the graph connected. 
261 

5 GRAPH THEORY 
(i) Every spanning subgraph H of a connected graph G has iE(Hli = 
W(Hli- 1. 
(j) A graph with E = V + 1 contains at least two cycles. 
(k) A graph with E = V + 1 contains exactly two cycles. 
15. Are two <ees with the same sequence of degrees necessarily isomorphic? 
Give a proof or a counterexample. 
16. Find a spanning forest of the following graph. 
17. A subgraph H of a graph G is called an induced subgraph if whenever x and 
y in V(H) are joined by an edge e in G, then e is also in H. Determine which 
of the following subgraphs of G are induced: 
V(G) = {1,2,3,4,5,6} 
(a) V(H) = 
1,2, 3} 
(b) V(H) = 
1, 2, 4, 5} 
(e) V(H) = 
1,3,4, 6} 
E(G) = {(I, 2), (1,4), (1, 5U2, 3), (2,5), (2,6), 
(3,6), (4,5), (5, 6l} 
E(H) = {( 1,2), (2,3)} 
E(H) = {( 1. 2), (1,4), 1),5), (4, 5)} 
E(H) = {(l,4),(3,6)} 
18. Suppose that G is a connected graph and T is a spanning tree of G. When 
is it the case that T is an induced subgraph of G? 
19. Here is an algorithm that finds (if possible) a spanning tree of the input 
graph. 
262 
Algorithm SPTREE 
STEP 1. Input the graph G with V vertices and edge list e1, ez, . .. ,eE 
STEP 2. Fori = 1 to E do 
STEP 3. Add edge ej to the spanning tree T if it creates no cycle 
with the edges already in T 

5:4 A GOOD MINIMUM-WIEIGHT SPANNING TREE ALGORITHM 
STEP 4. If T contains V-I edges. then output T as the desired spanning 
tree and stop; otherwise, declare that G contains no spanning tree and 
stop. 
Run the algorithm SPTREE on the following graph. 
20. Prove that SPTREE stores a spanning tree' in T if and only if G is connected. 
21. Prove that SPTREE stores a spanning forest in T in all cases. Modify 
SPTREE so that it always outputs T and determines the number of connected 
components of G. (Hint: See Question 3 . .5.) 
22. Show that in a tree, every pair of vertices is joined by a unique path. I~ the 
converse true, that is, if G is a graph in which every pair of vertices is joined 
by a unique path, then is G a tree? Give a proof or a counterexample. 
23. Find N such that if V > N, then the binomial coefficient given in (*) is greater 
than 2v. Show that, in any case, the binomial coefficient is greater than 
(V~lr-l. 
24. (An alternate solution to Question 3.5). Using induction on the number of 
components, show that if F is a forest with V vertices, E edges, and C com-
ponent trees, then E = V -
C. 
25. (Another alternate solution to Question 3.5). Given a forest F with V vertices. 
E edges, and C component trees labeled T 1, ... , Te, for i = 1, ... ,C -
1, 
add an edge from some vertex of Ti to some vertex of Ti + l' Use the resulting 
graph to prove that E = V -
C. 
5:4 A GOOD MINIMUM-WEIGHT SPANNING 
TREE ALGORITHM 
We now present an algorithm that is dramatically better than BADMINTREE. 
It is universally known as Kruskal's algorithm. Kruskal did write the tirst paper 
developing this particular algorithm in 1956. However, there are earlier algorithms 
263 

5 GRAPH THEORY 
that correctly and efficiently find minimum-weight spanning trees. The earliest 
known such algorithm is due to Otakar Boruvka, who as an electrical engineer, 
was working on the problem of the electrification of Southern Moravia about 60 
years ago. 
We are seeking a spanning tree of small weight. A lightweight spanning tree 
contains lightweight edges. Thus we build our tree using the lightest possible edge 
at each stage. It is plausible that such a strategy might produce a reasonably light 
tree. It is surprising (as we discuss in the next section) that this strategy is guaran-
teed to produce a minimum-weight spanning tree. The following algorithm works 
on the graph G assuming that its edge list is arranged so that the weights are 
increasing [i.e., for all 1 ::; i < j ::; £, w(ei) ::; w(e)]. 
Algorithm KRUSKAL 
STEP 
l. 
STEP 
'") -. 
STEP 3. 
STEP 4. 
STEP 5. 
Input the weighted graph G {Assume that G has V vertices and £ 
edges and that the edge list of G is in increasing order, by weight.} 
Set j : = I U will index the edges of G.] 
Set T to be empty [T will contain the edges of the minimum-weight 
spanning tree. J 
Set k : = 0 {k records 1£( T)I. ] 
Repeat 
Begin 
STEP 6. [f T + ej is acyclic. then do {add ej to tree} 
Begin 
STEP 7. 
T:= T + ej 
STEP 8. k: == k + 1 
End [step 6} 
STEP 9. j: = j + 1 
End : step 5} 
Until either k = V-lor.i > £ 
STEP 10. If k = V-I report success, output T, and stop. Otherwise. report 
failure and stop. 
COMMENT. 
We use" +." as in T + e j, to denote set theoretic union. 
Theorem 4.1. 
If G is weighted graph, then KRUSKAL outputs a minimum-weight 
spanning tree if and only if G is connected. 
Example 4.1. 
We run KRUSKAL on G shown in Figure 5.23 to obtain the 
minimum-weight spanning tree T. 
Question 4.1. 
Run KRUSKAL on the weighted graphs shown in Figure 5.24. 
264 

5:4 A GOOD MINIMUM-WEIGHT SPANNING TREE ALGORITHM 
4 
G 
Figure 5.23 
(a) 
Figure 5.24 
6 
6 
4 
8 
6 
T 
7 
8 
3 
(b) 
Proof of Theorem 4.1. 
First let's see that if KR USKAL reports success. then the 
graph in T is a tree. In step 7 the edge ej is added to the set T precisely when 
T + ej is acyclic. Thus the subgraph formed by T must always be acyclic. IfKRUS-
KAL returns success, then T has V-I edges. By Theorem 3.2 we know that an 
acyclic graph with V-I edges is necessarily a tree. Consequently, if KRUSKAL 
returns success, then the edges stored in T are the edges of a tree. 
Next let's see that if KRUSKAL returns failure. then G does not contain a 
spanning tree. For KR USKAL to return failure, after examining all the edges of 
the graph, the set T does not contain V-I edges but still forms an acyclic sub-
graph. Thus T is a forest. By Question 3.5 if the number of edges in T is V -- C, 
then C equals the number of components of T. Since T contains fewer than V-I 
edges, T contains more than one component. Suppose that Q is a component of 
T. If the whole graph G were connected, then there would be an edge in G, 
say e, that joins a vertex of Q with a vertex of another component of T. When 
KRUSKAL examined the edge e. it would have found that T + e was acyclic and 
thus T would have contained e. Since e did not make it into T. G must not have 
been connected. Thus KRUSKAL reports a failure when G is disconnected. 
A more difficult thing to verify is that the tree returned by KRUSKAL is a 
minimum-weight spanning tree. We begin with a lemma. 
Lemma 4.2. 
Suppose that T 1 and T 2 are two different spanning trees of a .:;on-
nected graph G and that c is an edge of T 1 but not of T'2' Then there is an <::dge 
d of T 2 but not of T 1 such that T 2 + c - d is a spanning tree of G. 
265 

5 GRAPH THEORY 
Proof. 
Suppose that T b T 2' and c are as given in the lemma. Consider the sub-
graph whose edges are T 2 + c. Since T 2 is a spanning tree, T 2 + c is a connected, 
spanning subgraph of G with V edges. Thus T 2 + c must contain a cycle C (using 
the contrapositive of Theorem 3.1). C is not contalined in T l' since T 1 is acyclic. 
Thus there is an edge d of C that is in T 2 but not in T 1. Consider T 2 + c - d, a 
subgraph with (V -
1) edges. Since d is an edge in a cycle of T2 + c, its removal 
does not disconnect the subgraph by Question 1.6. Thus T 2 + c - d is a con-
nected subgraph with (V -
1) edges. By Question 3.7 it is a spanning tree of G. 
o 
Question 4.2. 
In the graph G with spanning trees T 1 and T 2 given in Figure 
5.25, find an edge c and the corresponding edge d whose existence is guaranteed 
by Lemma 4.2. 
z 
G 
Figure 5.25 
To finish the proof that if KRUSKAL reports success, then the spanning tree 
in T is of minimum weight. we assume that the edge weights of G are all distinct. 
(You can complete the general proof in Supplementary Exercise 31.) The proof 
will be by contradiction. We negate the conclusion we are seeking to prove and as-
sume that T is not a minimum-weight spanning tree. Thus there exists a minimum-
weight spanning tree, say F, with w(F) < w( T). Since T i= F, there exists an edge 
in T that is not in F. Let e denote the lightest-weight such edge. We apply Lemma 
4.2 with T 1 = T, T 2 = F, and c = e. Thus there exists an edge, say f, such that f 
is in F but not in T. By the lemma F = F + e - f is a spanning tree. If w(e) < w(f), 
then w(F) < w(F), contradicting the assumption that F is a minimum-weight span-
ning tree. On the other hand, suppose that wU) < w(e). Since e was the lightest-
weight edge in T, but not in F, all the edges selected by KRUSKAL before e are 
also in F. Thus f would have been added to T inste:ad of e, another contradiction. 
We conclude that T is a minimum-weight spanning tree. 
I., 
There are two steps within KR USKAL that should provoke comment. The 
first is the requirement that the edges of G be input in increasing order. There is 
a straightforward way to do this. Specifically, we could examine the edge list of 
266 

5:4 A GOOD MINIMUM-WE:IGHT SPANNING TREE ALGORITHM 
G to find an edge with the smallest weight and list it first. We could then find a 
second smallest edge and list it second, and so on. We shall see in the next chapter 
that this procedure would perform 0(E2) comparisons to list the E edges of (; in 
increasing order. This method is analogous to the algorithm MAX, presented in 
Exercise 2.4.12. We shall also see that there are more efficient ways to do this 
sorting. 
The second difficulty with KRUSKAL as presented above occurs in step 6. 
Specifically, how should we decide, given an acyclic set of edges T and an edge 
ej , whether T + ej is acyclic? In small examples we can obviously "eyeball" the 
set of edges for cycles. One way to check for cycles in larger and more general 
examples is to keep track of the connected components of T at each stage of its 
creation. If ej joins the two vertices x and y, then the addition of ej creates a cycle 
if and only if x and yare in the same component of T. 
Example 4.1 (continued). 
Initially, T is empty, and we consider every vertex to 
be a separate component of T. First we added the edges of weights 2 and 3 because 
not only are they the lightest-weight edges, but also they join vertices in different 
components of T. Now T has a component consisting of these two edgesmd 
three vertices as well as three additional components, each consisting of an isolhted 
vertex. The next edge of weight 4 is rejected because it joins two vertices in a 
component, whereas the edge of weight 5 joins two vertices in different components 
and is accepted in T. 
It is not hard to estimate the complexity of KRUSKAL. The principal opera-
tions in this and most graph theory algorithms are comparisons. In KRUSKAL 
we first compare edge weights so that the edges are rearranged in increasing order. 
As mentioned previously, ordering the edges might take 0(E2) comparisons. The 
loop at step 5 is repeated no more than E times. Testing T + ej for cycles requires 
that we keep track of the components of T at each stage, so with one comparison 
we can tell whether ej joins two vertices in the same component. However when 
ej does not form a cycle and is added to T, we need to update the components 
of T because the addition of ej causes two components to be joined into one. This 
updating can be done with at most V comparisons. (For more details, see Exercises 
11 to 13.) Thus there are O(V) comparisons done within the loop beginning at 
step 5 and no more than OrE V) comparisons after the ordering of the edges. Thus 
the total number of comparisons and assignments is 0(E2) + orE V). 
A careful analysis of a more efficient implementation could achieve the result 
that the algorithm including an efficient sorting routine in step I is O(E log (E». 
Notice that this bound and the previous one can also be expressed in terms of 
(only) V, since by Corollary 2.3, E :::;; V(V -
1)/2 = 0(V2). 
Question 4.3. 
Express O(E 2 ) + O(E V) and O(Elog(E)) as O(f(V), where f is a 
function of V but not of E. 
267 

5 
GRAPH THEORY 
A formal analysis of any graph algorithm must consider how to input the 
graph G as a string of zeros and ones. One convenient method uses what is called 
the adjacency matrix of a graph. A matrix is a rectangular array of entries. usually 
numbers; an r x s matrix consists of r . s entries arranged in r rows and s columns. 
There are exactly s entries in every row and exactly r entries in every column. 
Example 4.2. 
Here is a 2 x 3 matrix: 
3J 
6 . 
Suppose that G is a graph with V vertices that are labeled 1, .... V. We define 
A(G), the adjacency matrix of G, to be the V x V matrix that has a one in the ith 
row and jth column if the vertex labeled i is adjacent to the vertex labeled j. All 
other entries of A( G) equal zero. 
Example 4.3. 
Here is a graph given first by its edge list and then by its adjacency 
matrix: 
Edge List 
Adjace/Jc Y jl,jf lltrix 
[1.2J 
() 
1 
1 
1 
:1,3} 
() 
1 
() 
0 
() 
: 1,4} 
1 
() 
0 0 
0 
: 1. 5} 
() 
() 
0 
0 
0 
: 1,6} 
() 
() 
0 
() 
() 
!) 11 
1-'.)5 
() 
() 
0 
() 
0 
Question 4.4. 
Find the adjacency matrix of each graph in Figure 5.26. 
1 
2 n 
3 
4 
5 
fa) 
Figure 5.26 
2 
6 
(hi 
3 
7 
Question 4.5. 
Draw the graphs whose adjacency matrices are as follows. 
268 

5:4 A GOOD MINIMUM-WEIGHT SPANNING TREE ALGORITHM 
(b) 
0 
1 
1 0 
o 
000 
1 0 
0 
o 
0 
o 0 
1 0 
1 
000 
0 
This form of representing a graph has advantages and disadvantages. Notice 
that it gives us a way to input a graph into an algorithm as a string of V2 zeros 
and ones obtained by laying out the matrix, row by row, as one long string. 
Example 4.4. 
Here is the string of V2 = 36 zeros and ones that represents the 
graph of Example 4.3. 
011111 lO 1000110000100000100000100000 
Thus the number of bits needed to input the adjacency matrix of a graph with V 
vertices is given by B = V 2. 
Question 4.6. 
Suppose that f(n) counts the number of comparisons made in the 
worst case of a graph algorithm and suppose that f(n) = O(nk) for some positive 
integer k. If B = n2, find a big oh bound on the number of comparisons made in 
terms of B. 
The result of Question 4.6 indicates that ilf we determine the complexity ;)f a 
graph theory algorithm to be bounded by a polynomial in V, then it is also bounded 
by a polynomial in B and hence is a good algorithm. The converse is also true, 
that if an algorithm requires an exponential number of steps in terms of V, then 
it also requires a nonpolynomial number in terms of B and is a bad algorithm. 
(See Supplementary Exercise 30.) In particular, KRUSKAL is a good algorithm 
and BADMINTREE is not. 
EXERCISES FOR SECTION 4 
1. Run KRUSKAL on the following weighted graphs. 
3 
123 
2 
3[71 
2 
lal 
269 

5 GRAPH THEORY 
2. Suppose that G is the weighted graph with V = 7 and E = 10 whose edges 
are (in lexicographic order) (1,2), (1,5), (1,6), (2,3), (2,6), (2,7), (3,4), (4,5), 
(5,6) and (6, 7). The weights are given by 1,1,2, ::., 1,2,3,2, I, and 3, respectively. 
Run KRUSKAL on this graph. Find all minimum-weight spanning trees of 
this graph. 
3. Is the following variation on Lemma 4.2 true or false? Suppose that HI and 
H 2 are two different spanning subgraphs of G that are themselves connected 
graphs. Suppose that e is an edge of HI but not of H 2' Then there exists an 
edge.f of H 2 but not HI such that H 2 + e - f is a connected spanning sub-
graph of G. Explain. 
4. Find adjacency matrices for the graphs in Exercises 1 and 2. You will have to 
label the vertices of the graphs from 1 to V. 
5. Suppose that a graph G has adjacency matrix 
0 
0 
1 
1 0 
1 0 
1 
0 
1 0 
0 
0 
0 
0 
0 
Without drawing G determine the number of edges of G and the degree of 
each vertex. Describe, in general, how to obtain the degrees of the vertices 
from the adjacency matrix. 
6. Suppose that G is a weighted graph with V vertices. Find a way to describe 
G including the weights as a V x V matrix. 
7. Which of the following is the adjacency matrix of a graph? Explain. 
(a) 
0 
1 0 
0 
I 
(b) 
0 
I 
1 1 1 
(c) 
0 
1 0 
0 
0 
1 0 
0 
0 
I 
0 
1 0 
1 
0 
0 0 
0 
I 
0 
I 
() 
1 0 
() 
0 
0 
1 0 
0 
1 
1 0 
0 
0 0 
0 
0 
0 
0 0 
0 
8. Find an example of a weighted graph G whose edge weights include negative 
numbers and with the property that a minimum-weight connected spanning 
subgraph is not a tree. 
9. Suppose that in Exercise 2 we require that edges e, and e lO be included in a 
spanning tree, but otherwise the spanning tree should be as light-weight as 
possible. Describe informally how to select the other edges of the spanning 
tree. 
10. Describe an algorithm that, upon input of a weighted graph G and a desig-
nated subset S ~)f E(G), finds a minimum-weight subgraph of G that is a con-
nected and spanning subgraph that contains all the edges of S. 
270 

5:4 A GOOD MINIMUM-WEIGHT SPANNING TREE ALGORITHM 
11. Here are more details on how to test algorithmically for cycles in KRUSKAL. 
Initially, in step 4.5, we define the component number of vertex i, denoted 
cn(i), to be equal to itself, i. 
STEP 4.5. For i = 1 to V do 
cn(i): = i 
Then in the new step 6, to test an edge e j = (x j, y) we compare cn(x j) and 
cn(yJ The edge ej forms a cycle if and only if these component numbers are 
equal. If they are not equal, we add ej to T and reset the component numbers 
of the new component. This is accomplished by the Procedure Renumber. 
STEP 6. {Suppose ej = (xj,y).} 
If cn(x) -=I cn( y), then do 
Begin 
STEP 7. T:= T + ej 
STEP 8. k: = k + 1 
STEP 8.5. Call Procedure Renumber (x j , y) 
End {step 6} 
Here is the procedure: 
Procedure Renumber (a, b) 
STEP 1. Set bigcn : = max(cn(a), cn(b)), 
set smallen: = min(en(a), cn{b)) 
STEP 2. For i = 1 to V do 
STEP 3. If cn(i) = bigen, then 
en(i) : = smallen 
STEP 4. Return 
Run KRUSKAL with these additional steps and this procedure on the 
example in Exercise 2. Keep track of the component numbers at each vertex. 
Do you get the same spanning tree? 
12. Run the extended version of KRUSKAL as given in Exercise lion the follow-
ing graph. Keep track of the component numbers at each vertex. 
2 
3 
4 
5 
6 
13. Explain why step 6 of the extended KRUSKAL now performs V + .3 = O(V) 
comparisons and why step 5 performs OrE V) comparisons. 
271 

5 GRAPH THEORY 
14. Within a tree, the eccentricity of a vertex x is defined to be the number of 
edges in a longest path that begins at x. (Or equivalently, it is the maximum 
value of d(x, v) taken over all vertices v.) For each of the following trees find 
the eccentricity of each vertex. 
(a) 
(h) 
(e) 
15. The center of a tree is the set of vertices whose eccentricities are as small as 
possible. Find the center of each of the trees in Exercise 14. 
16. Given a tree T with more than one edge, let p(T) denote the tree obtained 
from T by erasing all of the leaves of T and their incident edges. For each 
tree from Exercise 14 lind p( T). {Within a tree a vertex of degree one is called 
a leaf. We could say that p(T) is obtained from T by pruning all of T's 
leaves. : 
17. If you know the eccentricities of every vertex in a tree T. what can you say 
(with proof) about the eccentricities of the vertices in piT) [where p( T) is as 
defined in Exercise 16J? 
18. If T is a tree with more than one edge, show that the center of T equals the 
center of P( T). 
19. Prove that every tree has a center that consists of either one or two vertices. 
20. Construct an algorithm that will, upon input of a tree T. find the center of T. 
21. Let G be a weighted and connected graph. For x and yin V(G) we define the 
distance from x to y. d(x. y), to be the lengtb of the shortest path from x to 
y. where by shortest path we mean that the sum of the edge weights along 
that path is a minimum among all paths from x to y. Find d(x. y) for eacb 
pair of distinct vertices in the graph in Exercise 2. 
22. Suppose that T is a minimum-weight spanning tree in G. a weighted and con-
nected graph. Then for x and y in V(G), there is a unique path in T from .\ 
to y. We define the tree distance. dT(x. y), to be the sum of tbe edge weights 
on that path. Find examples where dT(x. y) = d(x. y), where d(x, y) is as defined 
in Exercise 21. Tben find examples where dT(x, y) =!= d(x. y). 
5:5 AN ODE TO GREED 
The problem of finding a minimum-weight spanning tree of a graph is typical of 
a large number of problems in discrete mathematics. In a more general context 
there is a set of objects with positive numbers assigned to them. The subsets \If 
272 

5:5 
AN ODE TO GREED 
these objects are partitioned into desirable subsets and undesirable subsets. We 
assume that if S is a desirable subset and T is a subset of S, then T is desirable. 
This property is known as the hereditary property. In the particular tree problem 
of this chapter the objects are the weighted edges. The desirable subsets are those 
that when considered as subgraphs are acyclic. The undesirable subsets are those 
that contain cycles. The property of being acyclic is hereditary. 
The problem is to find a maximal desirable subset of the objects whose total 
value is a minimum (or in some cases a maximum). The word maximal means 
that the subset cannot be extended to a larger desirable subset. So a maximal 
desirable subset of a given set S is first of all a subset of S, second of all it is 
desirable, and finally it is not properly contained in any desirable subset of S. In 
the context of the tree problem, a maximal desirable subset of the edges of a graph 
G is a subset of the edges that is acyclic and not contained in any larger acyclic 
subgraph. If G is connected, a maximal desirable subset is just a spanning tree. If 
G is not connected, a maximal desirable subset is a spanning forest, composed of 
spanning trees of each connected component. 
Problem. 
Given a set of weighted objects E and a partition of the subsets at E 
into desirable subsets and undesirable subsets such that the property of being 
desirable is hereditary, find a minimum-weight maximal desirable subset of E . 
. Algorithm GREEDYMIN 
STEP 1. Order the objects of E in order of increasing weight; assume E con-
tains m objects e I" .. ,em 
STEP 2. Set j : = 1 U will index the objects.; 
STEP 3. Set T to be empty {T will contain the desirable subset being created.: 
STEP 4. Repeat 
Begin 
STEP 5. 
If T + ej is desirable, set T: = T + ej 
STEP 6. j: = j + I 
End 
Untilj> m 
STEP 7. Output T and stop. 
This algorithm is called greedy because at each stage it tries to do as well as 
it can without regard to what will happen at future steps. Notice that if E is the 
set of weighted edges in a graph and if desirability is defined as being acyclic, thw 
GREEDY MIN is identical with KRUSKAL. iActually, KRUSKAL containslll 
additional stopping criterion that was possible because we knew exactly how many 
edges a tree has.; 
Question 5.1. 
Construct GREEDYMAX, a greedy algorithm to find a rnaximum-
weight, maximal desirable subset of E. If E is the set of weighted edges in a graph 
273 

5 GRAPH THEORY 
and if desirability is defined as being acyclic, does GREEDYMAX produce a 
maximum-weight spanning tree? 
Example 5.1. 
Suppose that we greedily attempt to find not a minimum-weight 
spanning tree but a minimum-weight spanning path. Specifically, we implement 
GREEDYMIN with desirability defined as follows. S is said to be desirable if S 
is contained in some path Pv _ 1 within the graph G on V vertices. We show in 
Figure 5.27 a weighted graph G whose greedily chosen path is heavier than the 
minimum-weight spanning path. 
2 
3 
3 
8 
G 
GREEDY path 
Minimum-weight path 
Figure 5.27 
This example illustrates the important fact that being greedy does not always 
produce a best answer, that is, greed does not always pay. In fact, researchers in 
the field of combinatorial optimization are actively seeking an understanding of 
just how bad an answer GREEDY will produce for specific applications. 
Question 5.2. 
Suppose that G is a complete weighted graph on V vertices. Further 
suppose that you wanted to find a minimum-weight cycle Cv as a subgraph of G. 
Formulate a greedy algorithm to "solve" this problem. Find an example where 
your algorithm fails to produce the minimum-weight cycle. 
This last question is not just whimsy. A variation of this is known as the 
Traveling Salesrepresentative Problem. Suppose that the vertices of G represent a 
collection of cities and the weight on each edge represents the cost of flying between 
the two cities. Then an economy-minded salesrepresentative might wish to visit all 
the cities in a cyclic tour but wants a tour of minimum cost. In fact, no good 
algorithm is known to solve this problem, or the graph theoretical version in 
Question 5.2. It is also not known that the problem requires an exponential algo-
rithm. In fact, the problem is computationally equivalent to the Satistiability 
Problem introduced in Section 1.10. This area is an active and important one in 
computer science, operations research, and combinatorics. In Chapter 8 we shall 
use KRUSKAL to give an approximate solution to this problem. 
274 

5:5 
AN ODE TO GREED 
EXERCISES FOR SECTION 5 
1. Here is a new algorithm: 
STEP 1. Input the weighted graph G with edges et,e 2 ,··· ,eE with w(eIl:::: 
w(e2) :::: ... :::: W(eE) > 0 
STEP 2. For j = 1 to E do 
STEP 3. If G - ej is connected, set G:= G - ej 
STEP 4. Output G and stop. 
Run this algorithm on the graphs of Exercises 4.1 and 4.2. 
2. Describe, in general, for any weighted graph G, the output of the algorithm in 
Exercise 1. Is this a greedy algorithm? 
3. A graph is said to be unicyclic if it contains exactly one cycle. Suppose that, 
given a weighted graph G, we wanted to find a minimum-weight, connected, 
unicyclic subgraph of G. Does greed pay? 
4. Suppose you attempt to find a minimum-weight path using a greedy algorithm 
with the following criterion of desirability: S is said to be desirable if its edges 
form a path. Is this GREEDYMIN different from the GREEDYMIN in 
Example S.l? If not prove that the two are the same. If they are different, deter-
mine whether this GREEDYMIN produces a minimum-weight path. 
5. Recall that a property P is called hereditary if whenever S has property P 
and T is a subset of S, then T has property P. Decide which of the following 
properties are hereditary: 
(a) P is the property that the subset is nonempty. 
(b) P is the property that the subset contains an even number of elements. 
(e) P is the property that the subset S satisfies lSI = L 
n/2 J, where the universe 
has n elements. 
(d) P is the property that S is such that lSI < nj2, where the universe has 11 
clements. 
(e) 
P is the property that S does not contain a fixed element x. 
(f) P is the property that S contains a fixed element x. 
(g) P is the property that S contains at most one of the two elements x 
and y. 
6. Call a subgraph of G desirable if by itself it is a connected graph. In this in-
stance is desirability hereditary? Describe the maximal desirable subgraphs 
of G. 
7. We list some properties that a graph G might have. In each instance if H is 
a subgraph of G, does H necessarily have the specified property? (That is, is 
the property hereditary?) 
(a) The maximum degree of a vertex in G is less than 7. 
(b) G is bipartite. 
275 

5 GRAPH THEORY 
(c) G is a forest. 
(d) G contains a cycle. 
(e) G is a complete graph. 
8. A graph G is said to be triangle-free if G does not contain a 3-clique as a 
subgraph. Show that being triangle-free is hereditary. 
9. Some subgraphs of a graph are induced subgraphs (see Exercise 3.17 for the 
definition.) Is this a hereditary property? 
10. Suppose that you wanted to find a maximum-weight, triangle-free subgraph. 
Does greed pay? 
11. Let G be a graph with V( G) = {A, B, C, D, E, F, H]. Suppose that G is complete 
and its edges (in lexicographic order) have weights 1,4, 14,4, 15,21,2,3,2,3,3, 
t, 3. 5, 2, 2, 2, 5, 2, 17, 1. Find a minimum-weight spanning cycle C 7 that begins 
and ends at A. What is the cycle that the greedy algorithm produces? 
12. Call a subset of E(G) desirable if it is contained in a spanning cycle of G. Show 
that with this definition of desirable GREEDY will not produce a minimum-
weight spanning cycle. 
5:6 GRAPHICAL HIGHLIGHTS 
Graph theory is a rapidly expanding mathematical discipline. It is important in its 
own right. as the mathematical basis of many applications, and as a fertile ground 
for logical and.algorithmic thinking. Like the number theory of the previous chap-
ter, graph theory is accessible and concrete. Pictures of graphs make small exam-
ples workable; computer programs make large examples tractable. Examples lead 
to conjectures and ideas for·proofs and counterexamples. In fact, this is the effective 
learning process for both students and research mathematicians. 
It may seem as if this chapter contains an overwhelming number of definitions. 
Each is there for a reason relevant to our work. Most definitions are needed im-
mediately to understand Kruskal's algorithm. Others are needed for wide-ranging 
applications that mathematics and computer science students will meet. A tree may 
be thought of as the basic underlying structure on which the rest of a connected 
graph hangs. Trees also arise as a structure used for information storage. These 
so-called data structures, when formed as a tree, allow for quick retrieval of stored 
information. For example. most computer operating systems allow for directories. 
subdirectories, and so on, that are organized by the vertices of a tree. 
Our modeling of the Local Area Network with graphs is a true-to-life depiction 
of how the problems of linking computers and terminals are now being attacked. 
In fact, computer scientists and electrical engineers regularly look to graphs and 
their properties to aid them in network design. Telephone companies use graphs. 
for example. to design systems of switching stations. Their goals are to have short 
distances between vertices while still having each vertex of small degree. Kruskal's 
276 

SUPPLEMENTARY EXERCISES FOR CHAPTER 5 
algorithm and other minimum-weight spanning tree algorithms are used in a whole 
spectrum of applications dealing with transportation systems, commodity flows, 
and efficient robot manufacturing, as well as the cable connection problem we've 
seen here. The tree minimizing problem of this chapter provides an introduction 
to the area of combinatorial optimization. fn this field it is now well understood 
when greedy algorithms work. On the other hand, the search for effective methods 
to find a minimum-weight spanning cycle in a weighted graph is one of the central 
problems of mathematics and computer science. Of seemingly intermediate diffi-
culty, the graph isomorphism problem has so far resisted satisfactory solution, yet 
workers in the field expect this problem to be solved in the near future. 
In Chapter 8 we consider more graph theory, both abstract and applied to 
optimization problems. We also present some approximation algorithms, that is, 
algorithms that work efficiently but only produce a near-optimal answer. 
SUPPLEMENTARY EXERCISES FOR CHAPTER 5 
l. Given a graph G, define G
C
, the complement of G, to be the graph that has 
V(G
C
) = V(G) and E(G
C
) = ((x,y): (x,y) i E(G)}. Find the complement of each 
of the following graphs. 
D 
(a) 
(b) 
ie) 
Id) 
Ie) 
2. If G is isomorphic to H, is G
C isomorphic to W? Give a proof or counterexample. 
3. If d I' d]" . .. ,dv are the degrees of G, a graph on V vertices, what are the 
degrees of G
C? 
4. What is the largest clique contained in the complement of Q 3? Q4-'? (For a 
definition of Qn see Exercise 2.19.) 
5. We define the diameter of a graph to be the maximum value of d(x. v) among 
all pairs of vertices x and y. Show that if G has diameter 4 or more, then G
C 
has diameter :2 or less. 
6. Suppose that G is a graph with V vertices and E edges and with vertices labeled 
: 1, 2 .... , V). Then we can list the edges in lexicographic order, as defined in 
Section 3.3: If each edge ei is given as a pair of vertices (xj, Yi), then the edges 
are numbered and listed in the order e l' ez,' .. ,t!E subject to the restrictions 
that for all i and j with I :s; i, j :s; E. 
(1) Xi :s; Vi; 
(2) i < j implies that Xi :s; X i; and 
(3) i <j and Xi = Xj implies that Yi :s; I'j' 
277 

5 GRAPH THEORY 
(a) Explain why the edge list e1 = (1,2), e2 = (1,3) and e3 = (3,4) is in 
lexicographic order, but the list I1 = (1,2),.12 = (2,4), and.l~ = (2,3) is not 
in lexicographic order. 
I 
(b) The following edge list is not in lexicographic order. Rearrange it so that 
conditions (1), (2), and (3) are met 
e 1 =(l,2) 
e2 =(1,3) 
e3 = (2,3) 
e4 = (5,4) 
e5 = (5, 1) 
e6 = (4, I). 
7. Here is an algorithm to solve the so-called Labeled Graph Isomorphism 
Problem. 
278 
Algorithm LABGPHISO 
STEP 1. Input G and H with edges in lexicographic order; let ei denote the 
ith edge of G and j; the ith edge of H [Assume iV(G)i = iV(H)i = V; 
the vertices are labeled with 1,2, ... , V, and iE(G)i = iE(H)i = E.} 
STEP 2. For j = 1 to E do U indexes the edges} 
STEP 3. If e j #- .Ii j as ordered pairs}, then output "no" and stop. 
STEP 4. Output "yes" and stop. 
(a) Run LABGPHISO on the labeled graphs G and H in the following figure. 
(Make sure your edge lists are in lexicographic order.) 
2 
2 
3 
4 
G 
4 
H 
3 
2 
2 
3 
4 
3 
4 
H 
(b) Explain why the number of comparisons made in LABGPHISO is at 
most 2E = OrE). 

SUPPLEMENTARY EXERCISES FOR CHAPTER 5 
8. Here is an idea for solving the more difficult problem of determining graph 
isomorphism for unlabeled graphs: Fix a labeling of the vertices of G with 
1,2, ... , V. Then run through all permutations of labels of H, and for each 
permutation run the algorithm LABGPHISO. Design an algorithm GPHISO 
that uses these ideas. (You may use the algorithms PERM from Chapter 3 
and LABGPHISO within your algorithm, without repeating it in its entirety.) 
Is your algorithm good or bad? 
9. Here is an idea to try to speed up the algorithm GPHISO. As seen in Example 
2.2 vertices with the same labels must have the same degrees. Thus, for exam-
ple, if S is the set of all vertices of degree 3 of G and T all vertices of degree 
3 of H, then we need to check only ITI! permutations of the labels of T. (The 
same is true for each degree of vertices in G and H.) Use this idea to rede~ign 
GPHISO and then analyze whether this speeds up the algorithm in some or 
all cases. 
10. Suppose that we are given a graph G with V( G) = (x 1" .. , Xv} and edge list 
E(G) = {(Xl' Xl), . .. }. Suppose that we want to decide if G is bipartite. Be-
gin by placing X 1 in R. Next place each of xl'S neighbors in 8, and so on. 
Construct a precise algorithm BIPARTITE. How many comparisons GOes 
BIPARTITE make? 
11. What is the maximum number of edges a graph on V vertices can have and 
still not be connected? 
12. For each of the following sequences, either draw a tree whose vertices have 
these degrees or show that such a tree cannot exist. 
(a) (4,\,\,1,\). 
(b) <6,2,2, 1, 1, 1, 1, 1). 
(c) (5,2,2,1,1,1,1,1). 
(d) (4,3,2,1, I, L 1, 1). 
(e) 0,2,2,2,2,2,2,2. 1). 
(f) (3,3.3.1.1, L 1, 1). 
13. Give an algorithm that will, given a sequence of positive integers ell"" .dv 
with d 1 + ... + dv = 2 V - 2, construct a tree whose vertices have the given 
sequence as its sequence of degrees. 
14. Show that in any gathering of people, some pair of people have the same 
number of acquaintances. (Hint: Assume that if A knows B. then B kno\\s A. 
Think of the graph that could represent acquaintances and try a proof by 
contradiction.) 
15. Prove that if d equals the maximum degree of a vertex in a tree T, then T 
contains at least d vertices of degree 1. 
16. Find all graphs G such that both G and G
C are trees. 
17. Let G be a connected graph with edge weights any real numbers. For vertices 
u and v of G, prove that there is a shortest path between u and p if and only 
279 

5 
GRAPH THEORY 
if no path from u to L' contains a cycle, the sum of whose edge weights is 
negative. 
18. Here is the idea of Boruvka's original minimum-weight spanning tree 
algorithm. 
STEP I. Input G, a connected weighted graph with n vertices 
STEP 2. Set T equal to the II vertices of G 
STEP 3. 
Repeat 
STEP 4. For each component C of T do 
STEP 5. Select a minimum-weight edge joining a vertex of 
C with a vertex of G - C and add it to T 
Until T is a spanning tree of G 
STEP 6. Output T and stop. 
Prove that this algorithm produces a minimum-weight spanning tree of 
G. Compare this algorithm with KRUSKAL. Find examples where it pro-
duces the same and where it produces different minimum-weight spanning 
trees. What is its complexity? 
19. Here is another version of a minimum-weight spanning tree algorithm due 
to Prim. 
STEP 1. Input G, a weighted connected graph with n vertices 
STEP 2. Set T = (L'}, where u is a vertex of G 
STEP 3. For i = 1 to 11 -
1 do 
STEP 4. Select a minimum-weight edge e joining a vertex x not in T 
with a vertex in T: set T = T + e + x 
STEP 4. Output T and stop. 
Prove that this algorithm produces a minimum-weight spanning tree of 
G, Compare the algorithm with KRUSKAL Clnd with Boruvka's algorithm 
of Exercise 18. What is the complexity of this algorithm? 
20. A subset I of the vertex set of a graph G is said to be independent if no two 
vertices in I are joined by an edge in G. The independence number of a graph 
G, denoted by x(G), is defined to be the maximum number of vertices in an 
independent set in G. Find a(G) for each of the following graphs: 
1 
(b) 
Ie) 
280 

SUPPLEMENTARY EXERCISES FOR CHAPTER 5 
Ie) 
(d) 
21. Show that if F is a forest, then x(F) ::::: V /2. Find an example of a forest with 
V = 10 and x = 5. 
22. Here is an algorithm to find an independent set. 
Algorithm IN D 
STEP 1. Input G; set I to be empty 
STEP 2. While G is nonempty do 
Begin 
STEP 3. Find a vertex x with deg (x, G) 'minimum 
STEP 4. Set 1:= I + [x} 
STEP 5. 
Set G:= G - [x} -
Iy: (x,y) E E(G)} 
End (step 2] 
STEP 6. Output I and stop. 
Run INO on each of the following graphs. 
EE 
(a) 
(b) 
Ie) 
23. Prove that Algorithm INO works, that is, it finds an independent set n a 
graph G. 
24. Find an example where INO does not find a maximum independent set. 
25. Show that if the input to Algorithm fNO is a forest, then the output I will 
be a maximum independent set. 
26. Let A be the V x V adjacency matrix of a graph. What information doe~ the 
matrix ,42, the product of A with itself, contain about the graph? 
27. Let A be the adjacency matrix of a graph G and let i and j be in V(G). Then 
prove that the least integer k such that ,4k contains a positive entry in the 
(i,j)th position equals d(i,j), the distance between i and j. 
281 

5 GRAPH THEORY 
28. Suppose that G is a regular graph (i.e., for some fixed constant 1', every vertex 
has degree rl. Then the degree of each vertex is the average of the degrees of 
all adjacent vertices. Prove the converse: Suppose that for every vertex v of 
a connected graph G 
d (l 
deg(xtl + ... + deg(xrl 
eg v = 
, 
deg(v) 
where the xl" .. , xr are all of the vertices adjacent to u. Then prove that G 
is regular. 
29. Suppose that f is a function with domain V(G) and target the real numbers 
for some connected graph G, and that f satisfies the following property: For 
every vertex v of V(G) 
{(v) = f(xd + ... + f(x;), 
. 
deg(u) 
where the sum is taken over all vertices x adjacent to v. Then prove that f 
is a constant function, that is, flu) = c for some constant c for all v in V(G). 
Is the result true if G is not connected? 
30. Suppose that the number of comparisons made in a graph algorithm .4 is 
given by g(V) and that y( V) > rV for some positive constant r. [f B = V 2, then 
show that r(BI/2) is a lower bound on the number of comparisons made in the 
algorithm A. Prove that the function h(B) = r(BI
12
) is not O(p(B)) for any poly-
nomial p and that h(B) = O(SB) for s > I. What can you conclude about whether 
or not A is a good algorithm in terms of the input size B? 
31. (a) Specify where the proof of Theorem 4.1 fails if the edge weights are not 
all distinct. 
( b) Prove Theorem 4.1 in the case that edge weights are not all distinct. (H ints: 
Assume that the edges of any tree produced by KRUSKAL are numbered 
in the order in which they were selected., Further suppose that F is a 
minimum-weight spanning tree that has the greatest initial agreement 
with T. Then complete the proof along the lines of the proof of Theo-
rem 4.1.) 
32. Suppose that G is a graph and" the corresponding relation on V(G) (as 
defined in Section 2). For what graphs G is - symmetric? Transitive'! 
33. The transitive closure of a graph G is defined to be the graph G' with VIG') = 
V(G), E(G) s;; E(G'), and additional edges of E(G') given by: Whenever (a, iJ) 
and (b, c) E E( G), then (a, c) E E( G'). Explain why the corresponding relation -
defined on V(G) is a transitive relation. 
34. Characterize all graphs G such that there is an equivalence relation - on a 
,et S whose corresponding graph is G. 
282 

SEARCHING AND SORTING
6:1 INTRODUCTION RECORD KEEPING
A college’s financial aid office has just created the job of Director of Student
Employment. The responsibilities of this position include the organization of stu-
dent employment information. Until now this information has been kept in the
following fashion. Each student employee has been assigned a record card on
which is written payroll information, including the student’s social security num-
ber. These record cards are organized in a file drawer arranged in alphabetical
order of the students’ last names. Each time the treasurer’s office issues a payroll
check the director receives a memo containing the payee’s social security number,
the total amount of the check, and the amount withheld for various taxes. Of
course, she wishes that these memos also contained the payee’s name; however,
the particular computer program that the treasurer’s office uses to cut checks
doesn’t have that capability. When a payroll memo arrives, the director examines
each record card in turn to determine if the social security number on the card is
identical to the number on the memo.
Question 1.1. Suppose that there were 20 cards in the director’s file drawer.
(a) When a payroll memo arrives, what is the minimum number of cards that the
director might have to check? (b) What is the maximum number 6f cards that the
director might have to check? (c) About how many cards (on average) would you
expect the director to have to check?
Question 1.2. Suppose that each of the 20 students whose cards are in the file
drawer receives exactly one payroll check each week. (a) What is the total number
of social security number comparisons that the director will have to make to
283

6 SEARCHING AND SORTING
record all of the payroll transactions? (b) If it takes 2 seconds to make a com-
parison and lminute torecord alltheinformation onafile card, will the director
spend more time making comparisons or recording information?
Now let’s answer the previous questions if there are n record cards in the
director’s drawer. The minimum possible number of comparisons occurs when the
payee happens to be the individual whose card is first in the file, the one whose
name is alphabetical] y first. In this instance there is just one comparison to make.
The largest number of comparisons occurs when the payee is the individual whose
card is last in the file. In this case there would be n comparisons to make. R is
plausible to think that the average number of comparisons should be the average
of the smallest number and the largest number. Here that number would be
(n + 1)/2. In fact, this is correct as we see by the following explicit computation.
If every individual in the file is paid exactly once, we can count the total num-
ber of comparisons in the following manner. First, note that the payee who is
listed first alphabetically will require just one comparison to locate. We don’t
know which memo corresponds to this first payee, but whichever one it is, it will
still take just one comparison. Similarly, the payee who is listed second alphabet-
ically will take exactly two comparisons to locate. In general, the payee who is
listed kth alphabetically will take exactly k comparisons to locate (regardless of
when this memo is processed). Thus the total number of comparisons will be
n(n + 1)
l+2+3+””+k+””+n=  
z 
.
Since the total number of comparisons needed is n(n + 1)/2, the average number
of comparisons needed will be this total divided by the number of payees. This
yields (n + 1)/2 comparisons on average. The total time needed for comparisons
will be n(n + 1) seconds while the time required to record the payroll information
will be 60n seconds. Thus if n >60, more time will be spent finding the correct
file than writing information to it.
Let’s formalize the director’s task.
Problem. Given an array A = (al, a2,. . . . an) and an object S, determine S’s posi-
tion in A, that is, find an index i such that ai = S (if such an i exists).
Algorithm SEQSEARCH
STEP 1. Input A and S.
STEP 2. For i = 1 to n do
STEP 3. If ai = S, then output i and stop.
STEP 4. Output “S not in A“ and stop.
2$4

6:1 INTRODUCTION RECORD KEEPING
If we count the comparisons in step 3, then the worst case will occur either
if S is not in A or if S = an. In this instance SEQSEARCH requires n comparisons.
Thus the complexity of this algorithm is O(n). Note that in our particular example
with social security numbers, S and the elements in the array A are numbers;
however, all that is required for this algorithm to work is that we can determine
whether ai = S. Thus SEQSEARCH would work equally well when the entries of
A are words.
The director decides that record keeping would be more efficient if the record
cards were kept in order of their social security numbers. The director begins the
sorting process by finding the card with the smallest social security number. She
does this by comparing the number on the first card with the number on the
second. She keeps the smaller of the two and then compares it with the number
on the third card. She picks the smaller and now has the smallest number from
the first three cards.
Question 1.3. In a drawer of 20 record cards, how many comparisons would be
required to be certain of finding the card with the smallest social security number?
We formalize the problem and the response.
Problem. Given an array of numbers A = (al, az,. . . . an), sort these numbers
into increasing order, that is, arrange the numbers within the array so that a 1 <
a25a3s”””<an.
Algorithm SELECTSORT
STEP 1. Input A, an array of n numbers
STEP 2. For i = 1 to n – 1 do {Find the correct ith number.]
Begin
STEP 3. Set TN:= ai {TN = temporary number}
S T E P4. Forj=i+l tondo
STEP 5. If aj < TN, switch aj and TN
STEP 6. Set ai := TN
End {Step 2}
STEP 7. Output A and stop.
Example 1.1. Table 6.1 gives a trace of SELECTSORT applied to the array A =
(4, 7,3). Notice that all the action occurs at step 5.
Since the smallest remaining element is repeatedly selected, this method is
called Selection sort. See Exercises 11 to 13 for a comparison with the sorting
algorithm known as Bubblesort.
285

6 SEARCHING AND SORTING
Table 6.1
Step No.
i
j
at
a2
a3
TN
3
1
?
4
7
3
4
5
1
2
4
7
3
4
5
1
3
4
7
4
3
6
1
3
3
7
4
3
3
2
3
3
7
4
7
5
2
3
3
7
7
4
6
2
3
3
4
7
4
Question 1.4. Apply SELECTSORT to the array A = (6,4,2, 3). Exhibit the
values assigned to i, j, TN, and each location in A after every execution of step 5.
Theorem 1.1. SELECTSORT is a 0(n2) algorithm.
Proof. We count the comparisons, which only occur in step 5. When i is assigned
the value 1, j varies from 2 to n. Thus there are n – 1 different values assigned to
j and n – 1 comparisons when i = 1. When i is assigned the value 2, j varies from
3 to n. Thus there are n – 2 comparisons. For general i, j varies from i + 1 to n.
In this case there are (n – (i + 1) + 1) = n – i comparisons. Hence the total number
of comparisons equals
(n–l)+(n –2)+”+( n-i)++ l=n(n J 1)= O(n2).
•1
L
A bit analysis of SELECTSORT would begin by noting that each of the n
numbers in the input array could be represented by M bits. Thus the total input
size would be nlkf. Every comparison of two M bit numbers would require, in the
worst case, M bit comparisons. Thus the total number of bit comparisons would
be Mn(n – 1)/2. If M is constant, then SELECTSORT is quadratic in the bit
analysis also.
Notice that SELECTSORT could work equally well on arrays of words using
alphabetical ordering. In a subsequent section we shall see that SELECTSORT
can operate on sets with more general orderings. We’ll also find that there are
more efficient algorithms to perform sorting as well as searching however, for
small arrays SEQSEARCH and SELECTSORT are worth using, in part because
they are so simple.
Here is the terminology we shall use throughout the rest of the chapter. Each
unit of information to be sorted is called a record. The set of records is called a
file. The element in the record with which the sorting is done is called the key.
286

6:1 INTRODUCTION RECORD KEEPING
Thus in the employment director’s office, her drawer contains the file. Each card
in the file is a record and the key is the social security number on the card. To
keep numerical examples simple, we shall often consider a record that consists
only of the key, but in applications the record will contain more information.
Consequently, interchanging two records in a file will be a more time-consuming
process than that of switching two numbers. If the records are stored in computer
memory and accessed by a language that admits the use of pointers, then the
pointers will be changed rather than the records.
EXERCISES FOR SECTION 1
1. Apply SEQSEARCH to the following arrays and objects $ record the output
of the algorithm.
(a) A=(1,2,3,...,17  ),S= 15.
(b) A = (1,2,3,... ,17), S = 12.5.
(c) A = <apple, banana, cantaloupe, kiwi, mango, papaya), S = strawberry.
(d) A=(a, b,c,.. .,z), S=h.
(e) A=(a, b,c,.. .,z), S=&.
U) A= (1,2,3, a,b, c, #,$, %A), S=$.
(Note: In Exercises 2 to 7 we assume that, as in Questions 1.1 to 1.3, the record
cards are listed alphabetically and the payroll memos come identified by social
security number.)
2. Suppose that there are 40 student employees who each receive 2 checks per
month. How many comparisons does the director make in a month using
SEQSEARCH? If it takes 2 seconds to make a comparison and 1 minute to
record the payroll information, which requires more time, comparing or re-
cording information?
3. Suppose that there are 20 student employees and exactly 10 receive a check
in any given week. What is the minimum and maximum number of compari-
sons that the director might make in a week?
4. Suppose that there are n student employees who each receive k checks per
month. How many comparisons will the director make in one month?
5. Suppose that there are 2n student employees and that exactly n of these
students receive a check in a given week. What is the minimum and maximum
number of comparisons that might be performed? What can be said about
the average number of comparisons that will be made?
6. Suppose that there are n student employees who each receive one check per
week. If it takes 3 seconds to make a comparison and 30 seconds to record the
287

6 SEARCHING AND SORTING
salary information, for what values of n is more time spent on comparisons
than on recording?
7. Suppose that there are n student employees who each receive one check per
week. If it takes x seconds to make a comparison and y seconds to record
information, then for what values of x and y do comparing and recording
take the same amount of time? For what values of x and y does comparing
take more time than recording?
8. Apply SELECTSORT to the arrays (1,2, 3), <3,2,1), and (3, 1,2, 1). Trace
out the values assigned to i,j, TN, and every location in A after each execution
of step 5.
9. Write an algorithm that, given an array of numbers, (a) selects the largest
number and places it in the last position, (b) selects the next largest number
and places it in the next to last position, and (c), in general, finds the largest
remaining number and places it in the last unfilled position. Analyze the com-
plexity of your algorithm.
10. Write an algorithm that finds the largest and the smallest entry in A =
(al, az,. . . , an), an array of real numbers. Count the number of comparisons
made in the worst case.
11. Look back at the algorithm BUBBLES, Exercise 2.4.13. Recall that this algo-
rithm found the largest entry in an array of n elements and placed it in the
last location. BUBBLES can be readily transformed into a procedure that can
be repeatedly called to sort the entire array. Here is an algorithm that does
just this.
Algorithm BUBBLESORT
STEP 1. Input m, a positive integer, and the array X = (Xl,. . ., XJ
STEP 2. For n = m down to 2 do
STEP 3. Call BUBBLES (n, xl,. . . . Xn)
STEP 4. Output <xl, X2,. ... XJ and stop.
Apply BUBBLESORT to the following arrays, exhibiting the values of
the array, n and j (the index in BUBBLES) throughout.
(a) ‘4= (4, 7, 3).
(b) B = (2, 1,4,3,6, 5).
(C) C = (4,3,2, 1).
12. Count the number of comparisons made by BUBBLESORT. Compare the
number of comparisons made in BUBBLESORT and SELECTSORT. Is one
algorithm more efficient than the other?
13. How might you modify BUBBLESORT to recognize when the array X was
already in order?
288

6:1 INTRODUCTION: RECORD KEEPING
14. One way a record can contain more than the key, is using a 2-dimensional
array A=(ui,j: i=l,. ... nZ, j= 1,. . ., n). This can be pictured as a matrix
with m rows and n columns:
al,l
a1,2 
“ 
“ 
.
al,j . . .
al,n
a2,1
a 2, 2 “ . .
a2,j . . .
a2,n
. . .
Ui, ~
ai,z 
““” 
,
Uij 
““’ 
Ui,n
. 
. 
.
Each row might represent the record of one student, and different columns
contain different types of information. Suppose that the key for each record
is stored in the first column so that the key for ith record is the entry ai, ~ for
i= 1,2,. ... m Use the idea of SELECTSORT to design an algorithm to sort
the array A so that the rows of A are rearranged to have their first entries
(the keys) listed in increasing order al,l < a2,1 s . “ “ < a~,l. How many com-
parisons does the algorithm use? In the worst case how many assignment
statements are there? Your answers will depend on n and m.
15. Write an algorithm that finds the second smallest entry in an array A =
(al, az,. . . . a.) of real numbers. Count the number of comparisons made.
16. Here is the idea for an algorithm to find the kth smallest entry in an array
A of n numbers: Find the smallest entry of A, then find the second smallest
entry, and so on, until the kth smallest entry is found. Write an algorithm
that implements this idea and count the number of comparisons; your answer
will be in terms of n and k.
17. Here is another algorithmic solution to the problem of finding the kth smallest
entry in an array A (see Exercise 16) First order the array using SELECT-
SORT and then find the kth entry of the sorted array. Compare the number
of comparisons made by this algorithm with that of Exercise 16, which is
more efficient?
18. Suppose that you have a balance scale with which you can determine which
(if either) of a pair of given coins is lighter in weight. Given n supposedly
identical coins, but such that one weighs less than the others, give a technique
suggested by SELECTSORT to find the light coin. How many comparisons
will your technique require in the worst case?
19. Suppose that you have 16 supposedly identical coins, exactly one of which
weighs less. Using a balance scale, each pan of which can hold as many coins
as you like, how can you find the light coin with only 4 weighings?
289

6 SEARCHING AND SORTING
6:2 SEARCHING A SORTED FILE
We return to the employment director’s problem of transcribing payroll informa-
tion. We assume that there are n employees whose record cards are filed now in
the order of increasing social security number. When a memo arrives from the
payroll office, the director searches for the record whose social security number
is the same as the one on the memo. Suppose she selects the rnth record from
the file, or drawer, and compares the two social security numbers. If the two
numbers are equal, then the director writes the information on the selected record.
If the number on the memo is less than the number on the mth record, then the
correct record must be located in the front portion of the file. Otherwise, the
correct record must be located behind the mth record.
Of course, the director hopes to pick the correct record on the first try. How-
ever, she does not believe in her own good luck. Furthermore (with a touch of
pessimism), the director believes that when she picks a record to compare with the
payroll memo, the record she really wants will be in the larger part of the re-
maining records. Thus the director wants to choose a record in the mth position
so that there are about as many records in front of the mth record as there are
behind the mth record. If the drawer has n records, the director picks the record
roughly in the middle, the record in the rnth position, where m = L(n + 1)/2J. The
director has, of course, assumed a worst-case scenario.
Question 2.1. Find m = L(n + 1)/2] if n = 136, 68, 34, 17, 9, 5, and 3.
Question 2.2. If the drawer contains n records and the mth record is selected,
where m = L(n + 1)/2], when is it the case that there are exactly the same number
of records before and after the mth record? When these two numbers differ, by
how much do they differ? After examining this mth record, what is the largest
number of records that still must be searched?
Let’s assume for the moment that the director has selected m and the number
on the memo is less than the number on the mth record. Then she begins the
search all over again, confining her attention to that portion of the file that is in
front of the mth record. In pseudocode she sets n : = m – 1 and then chooses m
to be (as before) L(n + 1)/2]. On the other hand, if the number on the memo is
greater than the number on the mth record, then the correct record must be in
position j, where (m + 1) <j s n. As above she begins the search all over again,
concentrating on the records in positions m + 1,. ... n. The next record to select
is the one that, as nearly as possible, divides the remaining records into equal
piles.
Question 2.3. For the following pairs (i,j) find the number that will be the index
of the entry that, as nearly as possible, divides (ai,. . . . aj) into two equal pieces:
(6, 8), (10, 17), (18, 33), (35,67), and (69, 136).
290

6:2 SEARCHING A SORTED FILE
In general, as the director progresses, she narrows down the possible records
that might correspond with the memo to a subarray (ai, ui + 1,. ... aj) of the
original array A. She wants to select the “middle” record of this subarray. The
index of the “middle” record is essentially the average of the indices of the end
records. We say essentially because the average might not be an integer. How-
ever, a record that, as nearly as possible, divides the subarray into two equal
pieces has index m = L(i + j)/2J. With this insight we can now formulate the
director’s algorithm.
Problem. Given an array A = (al, a2,. . . . a.) whose elements are numbers listed
in increasing order and a number S, determine S’s position in A, that is, find an
index i (if it exists) such that ai = S.
Algorithm BINAR YSEARCH
STEP 1.
STEP 2.
STEP 3.
STEP 7.
Input A, an array of n numbers in increasing order, and a number S
Set first:= 1, last:= n
While first s last do
Begin
STEP 4. Set mid:= L(first + last)/2]
STEP 5. If S = a~i~, then output “found S at location mid and
stop.
STEP 6. If S K a~i~, then set last : = mid – 1,
Else set first : = mid + 1
End {Step 3}
Output “S is not in A“ and stop.
Note that in step 6 exactly one of two assignment statements is executed, de-
pending on the result of the comparison in that step.
Example 2.1. Table 6.2 is a trace of BINARYSEARCH, where A= (3,4,6,7,9,11)
and S = 9. We begin after the first encounter with step 4.
Table 6.2
Step No.
jhst
last
mid
amid
4
1
6
3
6
5
1
6
3
6
6
4
6
3
6
4
4
6
5
9
5
4
6
5
9
Question 2.4. Trace BINARYSEARCH if A consists of the first eight primes in
increasing order and (a) S = 5, (b) S = 10, and (c) S = 17. In each case how many
elements in the array do you examine?
291

6 SEARCHING AND SORTING
BINARYSEARCH can find S without examining all the entries in A because
the elements of A are numbers listed in increasing order. Actually, this algorithm
will work on any set that is totally ordered. See Exercises 4.6.12 to 4.6.14. Since
A is totally ordered, either S z a~i~ or amid < S. Consequently, the value of
(last-first) decreases with each loop and so BINARYSEARCH must terminate.
Furthermore, the transitive property allows the algorithm to check S against amid
and discard about half of the ordered list at each pass through the loop. Exer-
cise 6 asks you to modify BINARYSEARCH so that it works on the set of all
English words in alphabetical order.
Theorem 2.1. BINARYSEARCH requires at most 3 hog (n)J + 4 comparisons to
search an ordered array of n numbers.
Proof. First note that each of steps 3, 5, and 6 requires exactly one comparison.
Thus each time we execute the loop beginning at step 3, we use no more than
three comparisons. The proof will be by induction on the number of elements in
the array. We begin with the base case n = 1. Given the array A = <al), the
algorithm uses two comparisons if S = al. If S # al, then the algorithm cycles
through the loop once and executes step 3 one additional time. Thus a total of
four comparisons is needed in this case.
The inductive hypothesis will be that BINARYSEARCH can search any
ordered array oft elements with at most 3L10g (t)J + 4 comparisons for any t z n.
We suppose that A is an ordered array with n elements. If we find equality the
first time at step 5, we are done, using 2 comparisons. Otherwise, we return to
step 3 with a smaller array, having performed three comparisons. The new array
contains no more than half of the elements of the original array. (See Question 2.2.)
By the inductive hypothesis it takes at most 3Llog (n/2)] + 4 comparisons to search
the new array. Thus the total number of comparisons needed to search the original
array is at most
3 +(3 l_log (n/2)J  +4)= 7 + 3Llog (n) – 1]
= 4 -t 3Llog (n)J.
K
Question 2.5. For each of n = 2, 3, and 4 find two examples of arrays and a num-
ber S, one that requires a full 3Llog (n)J + 4 comparisons and one that requires
fewer.
Question 2.6. Suppose that the director’s file has 1000 records in it. In the worst
case, how many comparisons will it take to find a record with a particular social
security number on it if (a) SEQSEARCH is used and (b) BINARYSEARCH is
used?
How did we originally find the bound 3Llog (n)] + 4 of Theorem 2.1? This ex-
pression works in the inductive proof, but why? Suppose that B(n) denotes the
292

6:2 SEARCHING A SORTED FILE
maximum number of comparisons made by BINARYSEARCH on an array of n
elements. Then in the worst case we perform three comparisons (in steps 3, 5, and
6) and then face a smaller array with Ln/2J elements in which to search for S. B(Ln/2J
denotes the maximum number of comparisons needed to search this smaller array
and so
B(n) = 3 + B(Ln/2J)
and
B(l) = 4.
(*)
This fact doesn’t solve the problem immediately but can lead to a solution as out-
lined in Exercises 13 to 15. In Chapter 7 we pursue a systematic study of how,
given an equation like that of line (*), we can find an expression for the number
of comparisons (or other significant operations) performed in the worst case of an
algorithm.
From Theorem 2.1 we can get an estimate of the amount of work the director
must do each week. If each week one memo arrives for each of the n student em-
ployees, then the next result gives an upper bound on the number of comparisons
necessary.
Corollary 2.2. BINARYSEARCH requires at most
3n[log (n)] + 4n = O(n log(n))
comparisons to search an ordered array for each of the n files located in it.
This result is an immediate consequence of Theorem 2.1; however,
3nLlog (n)~ + 4n is really an overestimate. A tighter upper bound on the number
of comparisons, but one that is still O(n log(n)), is derived in Exercises 9 to 11. In
any case the worst-case behavior of BINARYSEARCH is significantly better than
that of SEQSEARCH. Indeed the worst-case performance of BINARYSEARCH
is better than the average-case performance of SEQSEARCH. The average-case
performance of BINARYSEARCH is analyzed in Exercise 12. In its defense it
should be emphasized that SEQSEARCH will work on any set in an array A re-
gardless of whether or not the elements of A form a totally ordered set.
In the next section we use the ideas of binary search to construct a more
efficient sorting algorithm.
EXERCISES FOR SECTION 2
1.
2.
Let A=(l,2,. . .,7), B = (2,4,6,. ... 16), and C = <1,3,7, 15,31,63). Trace
BINARYSEARCH to find (a) S = 3 in A, (b) S = 8 in A, (c) S = 6 in B,
(d) S=7in B,(e) S=31in  C,and(~)S= 14in C.
Suppose that the number on the director’s memo is less than that on the
L(n + 1)/2Jnd record. What is the index of the next record she consults? Express
293

6 SEARCHING AND SORTING
this as a function of n. If the number is greater than that on the L(n + 1)/2Jnd
record, what is the index of the next record she consults?
3. Find all values of n for which SEQSEARCH uses fewer comparisons in the
worst case than 131NARYSEARCH,
4. Find a value of N such that SEQSEARCH uses at least twice as many com-
parisons in the worst case as BINARYSEARCH. Show that for every n > N
SEQSEARCH will always use at least twice as many comparisons in the worst
case as BINARYSEARCH.
5. In the worst case, how many subintervals of the form (afir~t,. . . . ala~t) does
BINARYSEARCH examine in an array with n entries?
6. Suppose that A is an array containing n words, where each word is a (finite)
sequence of letters taken from the English alphabet. Suppose further that your
computer can answer the following questions:
given words w and w’, does w = w’?
does w precede w’ alphabetically?
Write a version of BINARYSEARCH that upon input of ,4, an array of words
listed in alphabetical order, and a word w, searches for w in ,4.
7. Suppose that we are searching an ordered array of n elements for an element
that is in position k (but we don’t know that). For what values of k will
SEQSEARCH use fewer comparisons than BINARYSEARCH?
8. Modify BINARYSEARCH so that, given an array A with entries in increasing
order (al s . .
“ s an) and a number S, it finds all indices i such that ai = S.
9. Let n = 2
k – 1. Suppose that payroll memos for n students come into the
financial aid office in random order and that records for these n students
are arranged by increasing social security number. For each memo BINARY-
SEARCH is used to locate the appropriate record. At some point, the memo
for the L(n + 1)/2Jnd student arrives and requires only two comparisons to
find the correct record. Memos for two other students will require exactly five
comparisons.
(a) Which numbered students are these?
(b) How many memos require exactly eight comparisons to locate their
records?
(c) What is the next smallest number of comparisons needed and how many
students need this many?
(d) For each possible value of i, determine the number of memos that re-
quire exactly i comparisons.
10. Prove that
1“2+2”5+4”  8+””. +2i–l(3i  –1)+””-+2~-l(3k–1)  =(3k–4)2k +4.
294

6:3 SORTING A FILE
11. Suppose that n = 2
k – 1. Then explain why using BINARYSEARCH to search
an ordered array for each of n records requires
(3k – 4)2’ + 4 = 3nLlog(n)J – n + 3Llog(n)j + 3
= O(n log(n))
comparisons. Is this bound on the number of comparisons better than that
given in Corollary 2.2?
12. Use the results of the preceding exercises to obtain the average number of
comparisons used per record in BINARY SEARCH in the case n = 2
k – 1.
Compare this average with that of SEQSEARCH.
13. Suppose that
B(n) = B(Ln/2J) + 3
for n >1,
(*)
and
B(1) =4.
Determine the value of B(n) for n = 2, 3,4, 5, 8, and 16.
14. Suppose that n = 2
k. Use (*) repeatedly to determine a formula for B(n). Prove
your formula correct by using induction and the equation in (*).
15. Verify that f(n) = 3Llog (n)] + 4 gives the same values as those obtained for
B(n) in Exercise 14. Then prove by induction that B(n) = f(n) satisfies the
equation in (*).
6:3 SORTING A FILE
We have seen that searching for one record in an unsorted file with n records in
it requires O(n) comparisons in the worst case. This contrasts with a worst case of
O(log (n)) comparisons in searching a sorted file. A natural question to ask is
whether or not it’s better to sort before searching or not. For the moment let’s
return to the problem of searching the file for each of the n records during every
payroll period. If there are t payroll periods and the file remains unsorted, the
total number of comparisons required will be 0(tn2). On the other hand, if the
director uses SELECTSORT to place the file in order, then the total number of
comparisons will be
O(FF) + O(tn log (n)).
(A)
If, for example, there were n payroll periods (so t = n), then the number of
comparisons would be 0(n3) without sorting and 0(n
2 log(n)) with sorting. Thus,
if the number of payroll periods is large, sorting before searching pays off. Sup-
pose, for contrast, that the number of payroll periods is a small constant. Is it
295

6 SEARCHING AND SORTING
better to sort before searching or not? If the only sorting algorithm available were
SELECTSORT, then both solutions be 0(n2). However, if there were a better
sorting algorithm, then one could expect sorting before searching to be faster.
SEQSEARCH requires, on average (n + 1)/2 comparisons to position a record
correctly within a file containing n records. To sort more economically, we need
a way to position a record correctly using fewer comparisons. BINARYSEARCH
provides just such a mechanism.
Problem. Given an ordered array of numbers A = (al, a2,. . . . a,) with al <
azs..
“ s a, and a number D, insert D in the ordered list.
We develop the procedure BININSERT that will insert a number D into its
correct position in an ordered array. The parameters of the procedure are
(r, al,..., ar,a,+l ). We assume that upon calling the procedure the r numbers
al, ..., ar are in order and that ar + ~ equals D. Upon return al, . . . . ar + ~ should
be in order. Within the procedure we repeatedly compare D with the midpoint of
a subarray in order to find its correct location. Once D’s correct location is deter-
mined, the elements that should follow it are shifted over one space in order to
make room for D. We make this algorithm a procedure, since we shall use it within
BINARYSORT, which will be our first efficient sorting routine.
Procedure BININSERT(r,  al,. . . . a,, a, + ~)
{The initial segment of the procedure finds the correct location for a,+,.]
STEP 1. Set first : = 1, last := r
STEP 2. While first s last do
Begin
STEP 3. Set mid:= L(first + last)/2]
STEP 4. If ar + I z amid> then set last:= mid — I,
Else set first : = mid + 1
End {Step 2}
{At this point first equals last +1, and first gives the correct position for ar+l.
The next segment creates a space for and inserts a,+ ~.}
STEP 5.
If first = r + 1, then Return. {a,+ ~’s place is correct.}
STEP 6.
Set temp: = a,+ ~ {save a,+ ~}
STEP 7.
Forj = r + 1 down to (first + 1) do
S TEP 8. aj := aj_l
STEP 9.
Set afi~,~ : = temp
STEP 10. Return.
Example 3.1. Table 6.3 is a trace of the procedure BININSERT given the
array A = (3,5,8, 10, 14), r = 5, and D = 11.
296

6:3 SORTING A FILE
Table 6.3
Step No.
jirst
last
mid
amid
j
A
3
4
3
4
3
4
8
9
1
4
4
5
5
5
5
5
5
3
8
(3,5,8, 10,14, 11)
5
3
8
5
4
10
5
4
10
5
5
14
4
6
(3, 5,8,10,14, 14)
6
(3, 5,8,10,11, 14)
Question 3.1. Trace BININSERT if A = (2,5,7,9, 13,15, 19) and D = (a) 1, (b) 4,
(c) 14, and (d) 23.
Notice the similarity between BINARYSEARCH and BININSERT. The test
for equality has been eliminated because if ar + 1 = amid, this procedure correctlY
inserts a,+ ~ in position mid + 1 or higher. Exercise 12 outlines a proof that
BININSERT works correctly.
Question 3.2. If.4 = <2,5,7,9,13,15, 19), trace BINARYSEARCH and BININ-
SERT with S = D = 16. Compare the two algorithms.
Before discussing the complexity of BININSERT, we use this procedure to
develop an algorithm to totally order an array.
Problem. Given an array of n numbers (al, a2,. . . . a.), place them in increasing
order.
Algorithm BINAR YSORT
SmP 1. Input n and an array (al,. . . ,a. )
STEP 2. For m = 2 to n do {insert mth item}
SmP 3. Call BININSERT ((m – 1), al,. . . . am)
STEP 4. stop.
Question 3.3. Given the array (13, 23,17,19,18, 28) trace out the algorithm
BINARYSORT.
Once we determine the complexity of the procedure BININSERT, the com-
plexity of algorithm BINARYSORT will be easy to analyze, since BININSERT
is used n — 1 times in BINARYSORT. The steps in BININSERT are either as-
signments or comparisons. We count the latter.
297

6 SEARCHING AND SORTING
Theorem 3.1.
BININSERT requires at most 2Llog (r)j + 4 comparisons to insert
the (r + l)st term into an already sorted list of r items.
Proof. The only steps containing comparisons are steps 2, 4, and 5, and each of
these executes exactly one comparison. We proceed by induction. If r = 1, then
after the first execution of step 4, either first = 1 and last = O or first = 2 and
last = 1, depending on whether az is less than al or not. Step 2 is repeated to check
this. Step 5 is required to rearrange the array. Thus four comparisons are used
in total.
The induction hypothesis will be that for t K r BININSERT requires at most
2Llog (t)j + 4 comparisons to insert the (t + l)st item into any already sorted list
with t items.
We suppose that A is an ordered array with r elements and a,+ ~ = D is to be
inserted. It takes two comparisons to execute through step 4 the first time. After
the first execution of step 4, if a, + ~ K a~i~ then last is assigned the value mid – 1.
Thus we restrict our attention to (al,. . . . amid_ ~, a, + ~ ). There are mid – 1
ordered values in this array. Now
‘id-l= l:l-l=l=l<~
After the first execution of step 4 if a,+ ~ > amid, then first is assigned the value
mid + 1. Thus we restrict our attention to (amid+ 1, . . . , a,, a,+ ~). The number
of elements in this smaller ordered array is (r – (mid + 1) + 1) = r – mid. Now if
r = 2j,
r—mid=r  —
=2j–
On the other hand, if r = 2j + 1,
r— mid = 2j
l+r
2
.–1H
l+2j =2j–j=j=~.
2
+ 1 — 11+:+11
=2j+l–(j+l)=j K~.
Thus in either case the smaller ordered array has no more than r/2 entries. By
the inductive hypothesis we can insert D into the new array using at most
2110g(r/2)j + 4 comparisons. Thus the total number of comparisons required will
298

6:3 SORTING A FILE
be at most
2 + (2Llog (7-/2)J +4) = 2Llog (r) – lj + 6 ‘
= 2Llog (r)] + 4.
K
Question 3.4. For each of the examples in Question 3.1 count the number of
comparisons and verify that these are each no more than 2Llog (7)J + 4.
The formula 2Llog (n)] + 4 in the preceding complexity analysis appears out
of the blue. That BININSERT and BINARYSEARCH have similar complexity
analyses is not surprising. To motivate the particular formula we obtain, we
examine the proof of Theorem 3.1. If C(n) denotes the maximum number of com-
parisons made when BININSERT inserts a number into a sorted array of length
n, then
c(n) = C(Ln/2J) + 2,
since two comparisons are performed, and then the algorithm proceeds to work
on an array containing at most Ln/2J entries. This equation for C(n) is like that of
line (*) of Section 6.2 and can be used to derive the formula C(n) = 2Llog (n)] + 4.
This derivation will be discussed in depth in Chapter 7.
Theorem 3.2. The number of comparisons required by BINARYSORT to order
an array of n numbers is O(n log(n)).
Proof. The only comparisons in BINARYSORT are performed within the
BININSERT procedure. BININSERT is called n – 1 times. The number of com-
parisons in each call is at most 2Llog (n – l)j + 4. Thus the total number of
comparisons will be no more than
(n - 1)(21-log(n – 1)] +4) K n {2(log (n)) + 4}
s 6n log(n).
K
BINARYSORT is thus considerably more efficient than SELECTSORT, a O(n2)
algorithm.
Question 3.5. Count the number of comparisons made in Question 3.3 and com-
pare this number with (n – l)(2Llog (n – 1)] + 4) for n = 6.
It is instructive to contrast the analyses presented in Theorems 3.1 and 3.2.
We showed that BININSERT required at most 2Llog (n)] + 4 comparisons to
insert the (n + l)st item into an already sorted array. In Exercises 9 and 10 you
299

6 SEARCHING AND SORTING
will see that this bound is sharp. We mean that there are problem instances where
2Llog (n)J + 4 comparisons are, in fact, required. Thus there can be no upper
bound for the number of comparisons that is always better than the one given in
Theorem 3.1.
Notice that our analysis of BINARYSORT was not so sharp. In particular,
we assumed that each call to BININSERT needed the full 2Llog (n – l)J + 4 com-
parisons whereas we really need only 2Llog (l)] + 4 comparisons for the first in-
sertion, 2Llog (2)] + 4 comparisons for the second, and, in general, 2 Llog (i)] +.4
comparisons for the ith insertion. Thus the total number of comparisons we per-
form is at most
(2 Llog(l)J + 4) + -.. + (2L10g(n – 1)] + 4)
<(210g(l)  +4)+ ”””+ (210g(n–1)  +4)
=4(n– l)+2{log(l)+ ““” +log(n– 1)}
= 4(n – 1) + 210g((n – l)!).
(B)
Exercise 13 asks you to use equation (B) to provide a smaller upper bound
than the one obtained so far for BINARYSORT. However, no analysis of the com-
plexity of BINARYSORT can demonstrate that it is more efficient than O(n log (n)).
The goal of Section 5 is to show that SELECTSORT, BINARYSORT, and every
sorting method that uses comparisons must perform at least a constant times
n log(n) comparisons in the worst case. Before we get to that, we shall see in the
next section that trees provide an illustrative model of these searching and sorting
algorithms.
What effect does BINARYSORT have on the employment director’s work
load, as presented in the first paragraph of this section? If she first sorts the
employment file using BINARYSORT, using O(n log(n)) comparisons, and then
during t time periods processes information using BINARYSEARCH with
O(tn log(n)) comparisons, then the total number of comparisons is
O(n log(n)) + O(tn log(n)) = O(tn log(n)).
(c)
Comparing the results of (C) with those of (A), we see that the latter process is at
least as efficient as the former and for some values of t is more efficient.
EXERCISES FOR SECTION 3
1. Trace BININSERT on the following data:
(a) A = (1,2,3), D = 2.5.
(ZJ) A= (1,2,3 ), D=0.
(C) A = <1,2,4), D = 2.
(d) A = (2,3,5,7, 11,13,17, 19), D = 12.
(e) A = (2,4,6,8, 10), D = 5.
300

6:3 SORTING A FILE
2. Count the number of comparisons made in each part of Exercise 1. Compare
this number with 2Llog (r)] + 4 for the appropriate values of r.
3. Here is another algorithm to search for D in an array A:
STEP O. Input A = (al, a2,. . .,a,), set ar+l := D
STEP 1. Set first := 1, last := r
STEP 2. While first z last do
Begin
STEP 3. Set mid:= L(first + last)/2J
STEP 4. If a,+ ~ s amid, then set last : = mid
Else set first: = mid + 1
End
STEP 5. If afi,~, = a,+ ~, then output “found D at location first” and stop.
Else output “D is not in A“ and stop.
Run this algorithm and BINARYSEARCH on A = <1,2,3,4,5,6,7) with
D = 1.5, 2, and 2.5.
4. Compare the algorithm BINARYSEARCH and that given in the preceding
exercise. Determine which one performs fewer comparisons.
5. Suppose that the employment director uses SEQSEARCH on an unsorted
file of n records to register n students’ payroll data during t time periods,
making f(n, t) comparisons as described in the first paragraph of this section.
Let g(n, t) denote the number of comparisons made if the file is first sorted
using SELECTSORT and then the same recordings are made using BINA-
RYSEARCH [see line (A) in text]. Find the smallest value of t such that
g(n, t) K f(n, t).
6. Let g(n, t) be as defined in the preceding problem and let h(n, t) be the number
of comparisons made if the file is first sorted using BINARYSORT and then
the memos are recorded for n students on n records in t time periods using
BINARYSEARCH. Compare g(n, t) and h(n, t).
7. Run BINARYSORT on each of the following (a) A = (1,2, 3), (b) A =
(2,1,3), (c) A = (3, 1,2), and (d) A = <3,2, 1).
8. Count the number of comparisons made in the preceding exercise and com-
pare this number with (n – l)(2Llog (n – 1)] + 4) for the appropriate value
of n.
9. For an n of your choice find an example of an array A of n numbers and
a number D on which BININSERT performs exactly 2Llog (n)] + 4 com-
parisons.
10. Let n = 2
k with k an arbitrary positive number. Describe an array A of n
numbers and another number D on which BININSERT performs exactly
2Llog (n)J + 4 = 2k + 4 comparisons.
301

6 SEARCHING AND SORTING
11.
12.
13.
14.
Explain why BINARYSORT will always perform fewer than 6n log(n) com-
parisons when sorting an array of length n. Will BINARYSORT perform
fewer than (n – l)(2Llog (n – l)J +4) comparisons on any or all arrays of
length n?
Prove that BININSERT works correctly by proving each of the following
statements.
(a) While first s last, a,+, should be stored in one of the entries afi,,t,
Ufirst+l, . . . , or al~~t + ~. In particular, check that this is so when ar + 1 =
amid.
(b) Eventually either last equals first or first+ 1.
(c) If last equals first or first+ 1, then BININSERT places a,+ ~ in the
correct position.
Stirling’s formula, discussed in Chapter 3, implies that
( ())
n
n!= O&~ 
.
Use this result together with equation (B) to derive an upper bound on the
number of comparisons made in BINARYSORT. How does this upper bound
compare with the upper bound derived in the text?
Suppose that A is an array of n elements that is already sorted (but we may
no; ‘know that in advance). Which algorithm works faster on A, SELECT--
SORT or BINARYSORT? Explain.
6:4 SEARCH TREES
Suppose that we search an ordered array A = <a ~, az,. . . . a~ ) for a particular
object S. BINARYSEARCH would have us first compare S with a~. There are
three possible outcomes of such a comparison. If S = a~, we’re done. If S K a~
and S is in A, then it must be one of al, az, or as. Finally, if S > ag and S is in
A, then it must be one of as, a~, or a,. In this section we show how to use a tree
structure to illuminate these logical alternatives.
Recall from Chapter 5 that we can think of a graph as a set of points in the
plane and a set of line segments or arcs joining pairs of these points. A graph that
is both connected and acyclic is called a tree.
Here is how BINARYSEARCH as applied to the seven-element set A = (al,
az, ..., a~ ) can be modeled by a path within a tree of seven vertices. Begin with
a single vertex labeled a~. Think of two edges coming out of a~, one labeled by
“K” and the other labeled by “ > .“ (See Figure 6.1.) The K edge joins a~ with az
and the > edge joins a~ with a~. In terms of BINARYSEARCH if S equals a~,
we stay at the vertex labeled al and we are done. If S < a~ we proceed along the
302

6:4 SEARCH TREES
a4
<
a2
<
al
a3
a5
a7
Figure 6.1
edge labeled z to the vertex labeled Uz. If S > a~ we proceed along the edge
labeled > to the vertex labeled a~. The vertices Uz and a~ each have two additional
edges coming out of them labeled with K and >. The new edge from az labeled
< terminates at a ~ while the new edge from az labeled > terminates at as. Simi-
larly, the new edges from a~ terminate at as and a7. For example, if S = a5,
BINARYSEARCH would examine a~, followed by a6 and then’ a5. If S is not
present in A, we should also perform comparisons, for example, with a4, ab, and
a ~ and then deduce that S was not in A. In all cases these comparisons correspond
to a path within the so-called search tree shown in Figure 6.1.
Question 4.1. Draw a search tree to illustrate a binary search of an array of 15
elements.
Recall that within a graph the degree of a vertex is the number of edges
incident with that vertex. In a tree or forest a vertex of degree 1 is called a leaf.
Definition. A tree is called binary if
(1) it possesses a distinguished vertex called the root whose degree is either 2
or O, and
(2) every vertex of the tree other than the root has degree either 3 or 1.
Note that the tree in Figure 6.1 is binary. It is customary to draw a binary tree
“upside down” with the root at the top, as in Figure 6.1. From the root (if its
degree is not O) there is a left edge down and a right edge down. Similarly, every
other vertex that is not a leaf has a left and a right edge down. One of the nice prop-
erties that binary trees with three or more vertices have is that if the root and
its incident edges of a binary tree are erased, then two smaller binary trees are
formed. These are called the left and right subtrees of the original tree.
Example 4.1. Figure 6.2 exhibits a binary tree with five vertices.
303

6 SEARCHING AND SORTING
root
Figure 6.2
Question 4.2. (a) Draw all binary trees with fewer than eight vertices; (b) draw all
binary trees with two, three or four leaves.
Question 4.3. Draw the left and right subtrees that are formed when the root and
its two incident edges are deleted from (a) the tree in Figure 6.1; (b) the tree in
Figure 6.2; and (c) every tree with two or three leaves (see Question 4.2).
Definition.
In any tree with a designated root the depth or level of a vertex x is
the number of edges in the unique path from x to the root. The depth of the tree
is the maximum depth of any vertex in the tree. Alternatively, it is the length of
a longest path from the root.
In the tree shown in Figure 6.1, aq, the root, is at level Q a2 and U6 are at
level 1; and al, as, as, and a7 are all at level 2. Thus the tree has depth 2.
Question 4.4. If T is a binary tree of depth d >0 and T’ is the left subtree  of T,
what can you say about the depth of T’?
Theorem 4.1. A binary tree has at most 2
d vertices at depth d.
Proof. The proof is by induction on d. The root is the only vertex at level O. By
definition there are either two or zero vertices adjacent to the root, and these
vertices are at level 1. We assume that there are no more than 2
k vertices at level k
in a binary tree. Consider level k + 1. Every vertex at this level must be adjacent
to exactly one vertex at level k by the definition of tree (see Exercise 1). Since each
vertex at level k has degree 1 or 3, it is adjacent to either zero or two vertices at
level k + 1. Thus the number of vertices at level k + 1 can be no more than twice
the number of vertices at level k. If N~ denotes the number of vertices at level k,
we have
‘k+l ~ zNk < 2(2k) = 2k+l.
K
304

6:4 SEARCH TREES
Corollary 4.2. A binary tree of depth d contains at most 2
d + 1 – 1 vertices.
Proof. A binary tree of depth d has vertices at levels 0,1,. ... d. By the preceding
theorem there are at most 2
k vertices at level k. Thus the total number of vertices
in the tree is at most
~_2d+l
1+2+4 +.+2k+”. ”+2d= ~_2
by Question 2.3.3
=2d+l_l
K
A binary tree of depth d with 2d~ 1 – 1 vertices is called a full binary tree.
Question 4.5. Determine the depth and the number of vertices in the smallest
full binary tree that has n or more leaves.
Now we specify the connection between binary trees and our problem of
searching a sorted array. Suppose that the array A contains n = 2
k — 1 elements
in order. Then the corresponding binary tree will be a full binary tree of depth
k – 1 with n vertices. In BINARYSEARCH the first element of the array ,4 with
which we compare S is the element a~i~. Note that mid = 2
k -1. The element a~i~
will label the root of the binary tree that we are about to search. If we find that
S = a~i~ (in step 5), then the algorithm stops. We can similarly stop searching the
tree. If S < a~i~, we set
last: =mid–1=2k-1–1
and
‘id:= P~1ast)l=2k-2
This corresponds with traversing the edge from the root of the binary tree
down to the root of the left subtree; this vertex is labeled with the new a~id =
azk-2. Similarly, if S > amid, we traverse an edge to the right subtree. If we have
not found S, we repeat this process. Each time we examine a new amid it will be
the root of a subtree of the original binary tree. Each such subtree will contain
2j – 1 vertices for some j. In the end either we find S and terminate our path
down from the root of the tree or we reach a leaf without finding S and stop. The
number of comparisons made in BINARYSEARCH is the same as the number
of vertices visited on the corresponding path in the tree.
More generally, if A contains n elements where
2k-1<n<2k,
305

6 SEARCHING AND SORTING
then
k– 1 <log(n) <k,
and
k – 1 = Llog (n)].
Set
n’=2k —l.
We model the search of A by a search of the full binary tree of depth k – 1
containing n’ vertices, labeled as before. If n’ > n, some of the labels of vertices,
namely an+ l,. . ., a.,, do not correspond with array elements.
Question 4.6. Compute n’ if n = 15, 26, and 31. Show that, in general, n’ > n.
Question 4.7. Draw and label the tree that corresponds with a binary search of a
23-element ordered array.
One advantage of the binary tree model of BINARYSEARCH is that it sup-
ports a simple complexity analysis. Suppose that we are searching an ordered
d – 1 < n < 2
d, then the elements of the array correspond
array of n elements. If 2 –
with some of the vertices of a full binary tree of depth d – 1. Comparing S with
array elements corresponds with visiting vertices in the tree. Since each time we
traverse an edge to the root of a new subtree, the depth of the visited vertex in-
creases, we shall in the worst case visit vertices at depth O, 1, . . . . and (d – 1).
Correspondingly, we need to compare S with no more than d elements of the array.
Since a search tree with n vertices has depth Llog (n)J, we can determine whether S
is present in an ordered array of n elements by examining no more than Llog (n)J
elements of the array. If it takes just a constant number of steps for each such
examination, then it is immediate that BINARYSEARCH is O(log (n)). In contrast
in Exercise 15 we explore how SEQSEARCH can be modeled by searching a graph
that is just a path.
It is possible to think of a binary tree model of the first four steps of
BININSERT in much the same way. Recall that these steps determine the location
of the next element to be inserted. Continuing the model is awkward because the
insertion of a single element can cause a radical change in the binary tree. Exer-
cise 13 illustrates this.
Although it is difficult to use trees to model BINARYSORT, there is an ele-
gant sorting method called TREESORT that is based on binary trees. Suppose
that we want to sort A = <al,. . . , an), where the entries of A are distinct. (See
Exercise 20 for the case of repeated elements.)
306

6:4 SEARCH TREES
7
13
41
20
16
9
M
M
Figure 6.3
Algorithm TREESOR T
STEP 1. Set k = [log (n)l and construct the full binary tree of depth k. {As
you saw in Question 4.5, this tree has at least n leaves.} Assign each
element in the array to a leaf. Pick a number M that is greater than
any element in the array and assign M to every blank leaf.
Example 4.2. Given A = (7, 13,41,20, 16,9), k = [log (6)] = 3. Figure 6.3 exhibits
the full binary tree of depth 3 with its leaves labeled.
STEP2. Forj=k–1  down toO do
Assign to each vertex at level j the minimum of the two values as-
signed to its neighbors at level j + 1.
Example 4.2 (continued). We show in Figure 6.4 the full binary tree after step 2.
(At this stage the minimum value in the array is assigned to the root of the binary
tree.)
STEP 3.
STEP 4.
STEP 9.
Set b ~ : = value assigned to the root
For i =
Begin
STEP 5.
STEP 6.
STEP 7.
STEP 8.
End
stop.
2 tondo
Erase every occurrence of bi _ ~ from nodes of the tree.
Assign M to the leaf that originally was labeled with bi - ~
Forj=k–ldown toO do
Assign to the vertex at level j that used to be labeled bi _ ~
the minimum of the two values assigned to its neighbors at
level j + 1
Set bi : = value assigned to the root
Example 4.2 (continued again). We exhibit in Figure 6.5 the labeled tree after the
first execution of step 7; ~1 = 7.
307

6 SEARCHING AND SORTING
7
Figure 6.4
9
Figure 6.5
After the execution of step 7 the ith smallest value in the array is assigned to
the root and thus in step 8 is assigned to bi.
Question 4.8. Complete this execution of TREESORT.
Exercises 17 to 19 ask you to show that TREESORT is a O(n log (n)) algorithm.
Binary trees are useful models for many topics in combinatorics and computer
science, for example, see Exercises 5 and 6. We shall use binary trees again in the
following sections and in Chapter 8.
EXERCISES FOR SECTION 4
1.
2.
In the proof of Theorem 4.1 we claimed that every vertex at level k + 1 is
adjacent to exactly one vertex at level k. Why is this so?
If x is a vertex in a rooted tree, let l(x) denote the level of x, Show that if u is
adjacent to u’, then 1(u) = l(u’) + 1 or l(v) = l(u’) — 1. Give a proof or a counter-
example to the converse of this statement.
308

6:4 SEARCH TREES
3. If T is a binary tree of depth d, what is the smallest number of vertices that T
might have at level k (for k = 1,. ... d)?
4. What is the smallest number of vertices that a binary tree of depth d might
have?
5. For what integers n is there no binary tree with exactly n vertices? For what
integers n is there no binary tree with exactly n leaves? Prove your answers
by induction.
6. We can also represent the subsets of a set (al, U2,. . . . u.) with a full binary
tree. Suppose that we label the root of the tree with @, the empty set. Then
the left subtree will correspond with subsets not containing al and the right
subtree subsets containing al. Similarly, the left subtree within the left subtree
will correspond with subsets containing neither al nor a2, whereas its right
subtree will correspond with subsets containing az but not al. Each node can
be labeled with a subset, representing the choices of elements made along the
path from the root to that node. Using this idea, construct the binary tree
associated with all subsets of a 3-set and of a 4-set.
7. In a full binary tree there are 2
k vertices at level k. Find a correspondence
between the subsets of a k-set and the vertices at the kth level of a full binary
tree.
8. Prove Theorem 4.1 by “erasing the root.”
9. Prove Corollary 4.2 by “erasing the root.”
10. Suppose that n = 2
k – 1 and consider a full binary tree with vertices labeled
with the elements of an array A = <al, . . , an ) corresponding with BINARY-
SEARCH. Which elements label vertices at depth 1? At depth 2? What are
the labels of the leaves?
11. Repeat Exercise 10 in the case of arbitrary n. How can you tell from i and j
if ai and aj label vertices at the same level?
12. Trace out the path corresponding to BINARYSEARCH when this algorithm
is applied to the following arrays, modeled by binary trees, and elements S:
(a) A as in Figure 6.1, S = al.
(b) A as in Figure 6.1, as K S K aq.
(c) A as in Question 4.7, S = al~.
(d) A as in Question 4.7, S = a23.
(e) A as in Question 4.7, al~ z S z al~.
13. Suppose that you want to insert D = 31 into the sorted array .4 =
(3, 6,9,12,15,18,21,24,27, 30,33, 36). Construct a binary tree to model the
sorted array A both before and after the insertion of D. In how many locations
do these two trees differ?
14. If T is a binary tree with q leaves, how many vertices of degree 3 does T have?
309

6 SEARCHING AND SORTING
15. Explain how the algorithm SEQSEARCH can be modeled by traversing a
graph that is a path.
16. Run TREESORT on the following arrays, showing the binary tree and its
node values at the end of each execution of steps 3 and 8: (a) A = <1,2, 3);
(b) A = (2, 1,3); and (c)A= (1,5,2,6,3,4).
17. How many comparisons are performed in step 2 of TREESORT?
18. In TREESORT how may bi _ ~’s get erased the ith time through the loop?
How many comparisons will you need to relabel the tree?
19. Show that TREESORT is a O(n log(n)) algorithm.
20. Rewrite TREESORT so that it sorts arrays with repeated entries.
6:5 LOWER BOUNDS ON SORTING
A new employment director wants to improve the efficiency of the student employ-
ment office. After conversations with the previous director, the new director is
convinced that she should sort her payroll drawer at the beginning of the year.
She learns that the previous director originally used the quadratic algorithm
SELECTSORT and then switched to the n log(n) algorithm BINARYSORT, but
the new director does not want to keep switching algorithms each year when the
local algorithm experts come up with new and faster (and possibly more complex)
sorting algorithms. She decides she would like once and for all to find a fastest
sorting algorithm and guesses that there must be a linear algorithm, one that runs
in O(n)-time  on an array of n elements. So she calls her friends taking the computer
science course on algorithms and asks for such a linear-time sorting algorithm.
The algorithm students report that they haven’t learned about such an algo-
rithm yet, but maybe they will later in the semester. In the meantime they suggest
that the director might like to try Treesort, Shakersort, or Mergesort. These are
all n log(n) algorithms. The director rejects these offers. She is trying to run an
efficient office and is not interested in becoming an algorithmic specialist herself.
However, she decides that she will, on her own, search for a linear-time sorting
algorithm or else prove that there is no such algorithm.
The new director has studied some discrete mathematics and begins with small
examples of arrays. If she has an array like <al, az, a3), then in how many different
orders might the array appear? For example, the array might be “in order” so that
al s az < as or “out of order” with al s as < a2 or a 2 s as s al, and so on.
How many comparisons must be made to sort these elements into increasing
order? The element a 1 can be compared with az and with a3, and the eiements
az and a3 can be compared with each other. Are all these comparisons necessary?
Question 5.1. For n = 3, 4, and 5, given an array of n distinct items A =
(al, a2,. . . . an) decide in how many different possible orderings these elements
310

6:5 LOWER BOUNDS ON SORTING
might appear. Then determine the total number of pairwise comparisons that can
be made among the members of the set.
Proposition 5.1. There are at most n! different possible orderings of an array of n
elements. In such an array there are n(rz – 1)/2 distinct pairs of items that might
be compared.
Proof. If the array entries are distinct, there are the same number of orderings as
permutations of an n-set. If the entries are not distinct, the number of different
orderings is less than n!, since some permutations produce the same ordering. (See
also Exercises 2 and 3.) In either case the number of possible comparisons between
pairs is the same as the number of 2-subsets of an n-set or (equivalently) the number
of edges in an n-clique.
K
Proposition 5.1 tells us (and the employment director) that if we make all possible
comparisons, we have a O(n2) algorithm, an algorithm as slow as SELECTSORT.
We know we can use cn log(n) comparisons for some constant c, but can we use
even fewer than this?
Any sorting algorithm that uses comparisons contains a sequence of com-
parisons, say Cl, C2,. . . . C~. Regardless of the particular sorting algorithm used,
what can we say about the value of k, the number of comparisons, in the worst
case? We model the problem with a binary search tree.
Example 5.1. Given three distinct objects, say al, az, and aq, we make a binary
search tree labeled with possible comparisons and possible outcomes. Suppose that
we begin by comparing a ~ and a2. There are two possible outcomes, either a 1 s
a2 or al > az. We label the root of the binary tree with (a ~: a.J for this comparison;
the edge from the root to the left subtree is labeled”s” to denote the first possible
outcome and the edge to the right subtree is labeled “>” for the second outcome.
See Figure 6.6. Suppose that we next compare al with as and label the two nodes
on level 1 with (a 1: a3) and their left edges with”s” and their right edges with”> .“
Notice that in two of the four possibilities we know the correct ordering and have
written that in as a leaf of the tree, but in the remaining two cases we need to
make the additional comparison of az with a3.
The results of Example 5.1 show that at least with this order of comparisons
three comparisons are needed in the worst case.
Question 5.2. As in Example 5.1 construct and label a binary search tree when
comparisons are made in the following ordec
(a) al with az, a2 with a3, al with a3.
(b) al with as, al with a2, az with a3.
311

6 SEARCHING AND SORTING
al: a2
alGag Ga3
a1<a3<a2
a2<a3<a1
a3<a2Ca,
Figure 6.6
The results of Example 5.1 and Question 5.2 convince the employment director
that three comparisons are needed to sort a three-element array. This finding is
inconclusive from the complexity point of view, since all possible comparisons are
needed in the worst case. On the other hand, three comparisons for a three-element
array might indicate the possibility of a linear-time algorithm.
Example 5.2. Suppose that we sort A = <al, a2, a3, aJ. Here is part of the search
tree (Figure 6.7). Notice that once it is known that as z al < aJ, then it is imPos-
a3<a1Ga2<a4
Figure 6.7
312

6:5 LOWER BOUNDS ON SORTING
sible to have az < as. The path corresponding to this impossibility terminates with
a leaf labeled with the empty set.
The director also realizes that she can analyze any sorting algorithm using the
binary tree structure. If any algorithm makes comparisons Cl, C2,. . . . Ck in that
order, then we represent this algorithm as a binary search tree of depth k. The
root is labeled c 1, the two nodes at depth 1 are labeled  C2, and, in general, the
nonleaf nodes at depth i are labeled Ci + 1 for i = O,. . . . k — 1. The leaves are
each labeled with either the empty set or with one of the n! possible orderings of
the array. The label on a leaf at the end of a path from the root is the ordering
specified by the series of s and >s on that path; as in Example 5.2 there may be
no such ordering. If k comparisons are made in the worst case, then the binary
tree representing these comparisons has depth k. By Theorem 4.1 there are at most
2
k leaves in such a tree. Thus we must have
2
k > n!, 
or
k > log(n!).
K
We have proved the following theorem.
Theorem 5.2. It requires at least log (n!) comparisons to sort an n-element set
in the worst case.
Another approach to the proof of this theorem, using a game and binary
numbers, is given in Exercises 16 and 17.
The director realizes now that an algorithm that performs sorting by com-
parisons must in the worst case do at least log (n!) comparisons. Her next goal is
to determine the size of log (n!) or at least a lower bound on log (n!). The next
arithmetic lemma will lead to a lower bound on log (n!).
Lemma 5.3. If n > i >1, then i(n + 1 – i) > n.
Proof. Since n > i and (i – 1) >0, we have
(i – l)n > (i – l)i.
Adding n to both sides and subtracting (i – l)i yields
in–i(i —l)>n,
which simplifies to
i(n —i+l)>n.
K
313

6 SEARCHING AND SORTING
We now use the lemma to estimate log (n!).
log(n!) =log(n(n–  1)... .3 .2.1)
= log {[(n) l][(n – l)2][(n – 2)3] “ ~ “ [(n – i + l)i] “ . “}
by regrouping factors
=log[(n)l]  +log[(n –l)2]+”””+log[(rl  –i+l)i]  +”””
(A)
by the additive property of logs
>log(n)  +log(n)  +””” + log(n)+””
(B)
by Lemma 5.3.
Note that if n is even, the sum in (A) ends with log [((n/2) + l)(n/2)]. Hence
there are n/2 terms and so (B) equals (n/2) log(n). Thus
()
log (n!) > ~ log(n).
(For the case of n odd, see Exercise 9.)
Corollary 5.4. If S(n) is defined to be the number of comparisons needed in the
worst case to sort a file with n items using comparisons, then
S(n) > log(n!)
and
n log(n) = O(S(n)).
Corollary 5.4 is often referred to as the information theoretic lower bound on
sorting. What it means is that there cannot be a sorting method based on pairwise
comparisons whose complexity is of order less than n log (n). In other words, every
such sorting algorithm will be big oh of some function in the functional hierarchy
(as developed in Chapter 2) that is at least as big as n log (n). So far, we have seen
three sorting procedures, one that is O(n2) and two that are O(n log(n)).
Example 5.3. Suppose that we want to sort A = (al, az, as, a~}. As we have
already seen, three elements in an array can be sorted with three or fewer com-
parisons. Suppose that we find that al < az s as and we want to find the position
of a~. We could compare a~ with each of the first three to find its position or we
could use the idea of BINARYSORT. Then we would compare a~ with a2. If
a4 < a2, we compare a4 with al. If aa > a2, then we compare a4 with aj and so
determine the final order. In total, five comparisons have been made in the worst
case. Since [log (4!)1 = 5, Corollary 5.4 tells us that a file with four items cannot
be sorted using fewer than five comparisons.
314

6:5 LOWER BOUNDS ON SORTING
Question 5.3. Draw the binary search tree for a four-element array when the
comparisons are made as suggested in Example 5.3. Count the number of com-
parisons in the worst case. (Note that to parallel Example 5.3 we allow different
nodes on the same level of the binary tree to receive different comparison labels.)
Notice that we talk repeatedly about “sorting by comparisons.” How else
might a sorting algorithm proceed? In fact, in some special cases comparisons
are not necessary  these ideas are explored in Section 8 and in Supplementary
Exercises 29 to 32. For example, the algorithm BUCKETSORT is a linear-time
sorting algorithm but is of limited applicability because of its excessive storage
requirements.
The director is now convinced that there is no algorithm that uses com-
parisons and is essentially better than BINARYSORT, and so she decides to stick
with this n log(n) algorithm. However, due to increased tuition and decreased
financial aid the number of student employees doubles and then grows to triple
the original number of students.
Question 5.4. Suppose that the number of student employees increases from
600 to 1200. If the employment director first sorts her file with n log(n) com-
parisons and then performs n log(n) more comparisons for each of the four payroll
periods in one semester, how many comparisons are performed for 600 and for
1200 students? And for 1800 students?
The employment director finds she can’t keep up with the explosion of work
in her office as the number of employees doubles and then triples. She petitions
the president’s office for an assistant. The petition is granted, and the president
even offers, if need be, to provide a second assistant. The next sections will present
ways in which the director can use her assistants effectively.
EXERCISES FOR SECTION 5
1. Given an array of n distinct elements, we have said that there are n! possible
initial orderings of the n elements. For n = 3 and n = 4, give examples of n!
arrays, one corresponding to each of the possible orderings.
2. Suppose that in the array A = (al, az, as, aq) it is known that as = aq. Then
how many different possible (unsorted) orderings are there?
3. Suppose that it is known that in the array A = (al, az,. . . . an) two elements
are the same but otherwise the elements are distinct. How many different
(unsorted) orderings are there?
4. Suppose that we have an array (al, az, aq ) and ask the questions
“Is a~ < az?
and
Is a2 < al?’
315

6 SEARCHING AND SORTING
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
Give an example of values for al, a2, and a3 for which the answers to these
two questions do determine the order correctly. Then give an example of
values for which the answers are not sufficient to determine the order
correctly.
Suppose that we have an array (al, az, a~, aJ. Find four questions that
sometimes do and sometimes do not determine the correct order.
If an algorithm makes k comparisons, explain why the corresponding binary
tree has depth k.
Given an array containing n elements, is it ever possible to ask n – 2 or
fewer questions of the form “ls ai s aj?” and from the answers to learn the
correct order? Explain.
Suppose you have an n-element array and ask the n – 1 questions “Is
al s az?,” “1S a2 s as?,” . . . . “Is a._ ~ s a.?.” If it is possible to determine
the order of the array from the answers to these questions, what can you say
about the entries in the array?
Find a lower bound for log (n!) in the case that n is odd, similar to the one
found in the text when n is even.
Stirling’s formula from Chapter 3 tells us that
Use this to obtain a lower bound on log (n!). Does this lead to a better (larger)
lower bound than that derived in the text?
Draw a binary tree for sorting A = (al, az, as, a~) that begins by comparing
al with az, then a~ with a3, and a3 with a4, and that has depth as small as
possible. (As in Question 5.3 you may make different comparisons at different
nodes on the same level.)
Suppose that a binary search tree for A = (al,. . . . as ) begins with the com-
parisons al with a2, then al with a3, then al with a~ and al with as. How
many leaves are there at depth 4? Give an example of a leaf at depth 5. Give
an example of a leaf at depth 6 or more.
Suppose that m log(n) comparisons are made on records for n student em-
ployees during t time periods. If n is doubled to 2n, does the number of
comparisons double? Does it triple? Suppose that the number of students
triples from n to 3n? How many times the original number of comparisons is
the new number of comparisons?
If J(n) = n log(n), find k such that for n sufficiently large
kn log(n) s 2n log (2n) s (k + l)n log(n).
316

6:6 RECURSION
15. Corollary 5.4 says that a file with five items in it cannot be sorted with fewer
than [log (5!)1 = 7 comparisons. If one sorts a file with five records by first
sorting four records and then inserting the fifth record, it takes a total of eight
comparisons. First five comparisons are needed to correctly sort four records
and then three more to insert the fifth item into the ordered list of four items.
Decide whether the minimum number of comparisons that will necessarily
sort a file with five items is seven or eight.
16. Here is a sorting game, played by two players on an array .4 = (al,. . . . an).
Player 1 picks two elements ai and aj and asks player 2 to compare these
values and to say which is smaller. Player 2 then assigns values to ai and aj
in any way and answers, for example, that ai s aj. Player 1 next picks another
pair to compare, and player 2 again assigns values and reports the answer.
(Once player 2 has picked and used a value for some ai, the value cannot be
changed, but values do not need to be selected until player 1 brings them up.)
Player 1‘s goal is to determine the order as quickly as possible; player 2’s goal
is to keep the order obscure as long as possible. Play the sorting game for
both n = 4 and n = 5. How many comparisons can player 2 force player 1 to
make?
17. In the sorting game if player 1 asks for the results of k comparisons, then
player 2 must give k different pieces of information, in this case either “<”
or “ > .“ There are 2
k different patterns of answers that player 1 may receive
from player 2. Use this to explain why to sort a set of n objects with k com-
parisons, it must be the case that 2
k > n!.
6:6 RECURSION
The director of the student employment office hopes that with an assistant she
can delegate more of the routine work. For example, at the beginning of the year
she might sort half of the student records, give the other half to an assistant and
then merge the two sorted files into one.
To train an assistant with an easy comparison task, the director begins with
the job of finding the minimum entry of A = (a ~, az, . . . . an), an array of real num-
bers. She asks the assistant to find the minimum entry of A’ = (al, az,. . . . an _ ~ )
because she knows she can compare the assistant’s minimum with a. to find the
overall minimum of A. Now the assistant catches on quickly and realizes that he
can use another assistant to find the minimum of A“ = (al, az,. . ., an – z ) and
then compare that minimum with an_ ~ to find the minimum of A’. If each of the
assistants has an assistant (or a friend to help with the work), each assistant can
pawn off the work of finding the minimum of a smaller array. Eventually, the
array under consideration will have just one entry, which will be the minimum
value of that array. This minimum value will be passed up and probably changed
until the director receives the correct minimum of A’ and then with one comparison
finds the minimum of A.
317

6 SEARCHING AND SORTING
This fanciful idea is an example of what is known as a recursive algorithm or
recursive procedure. The word recur means to show up again, and that’s exactly
what happens in a recursive procedure: The procedure shows up again, or is used,
within itself.
We now formalize a recursive procedure that carries out the idea described
above. The procedure MIN will find the minimum entry in an array A. The input
to MIN is A and n, the length of A, and the output from A is k, the value of the
index of the minimum entry of A.
Procedure MIN(A, n, k)
STEP 1. Ifn= l, then set k:= 1
Else
Begin
STEp2. n:=n–1
STEP 3. Procedure MIN(A, n, k)
S~p4. Ifan+l KUk, then k:=n+l
End {step 1}
STEP 5. Return.
In step 3 we call the procedure MIN, but on an array of smaller size. This
is the essence of a recursive procedure. We repeatedly call MIN until n = 1. When
n = 1, the array has one element and we actually find the minimum, successfully
completing step 3. Every time step 3 is completed, we proceed to step 4 with the
value of k just received and with the value of n equal to what it was when that
instance of the procedure MIN was called.
Example 6.1. Table 6.4 is a trace of MIN with A = (4.2, 2.1, 3.5,0.9),
When n = 1, we set k:= 1 and return to (C)to complete steps 4 and 5. Notice
that when we then return to @), n is reset to 2, its value at the time of this
execution of step 3.
Question 6.1. Trace the procedure MIN on the array (4,3,2,1, 5).
There are two properties essential for a recursive procedure to be correct.
These are dictated by the requirement that an algorithm must terminate after a
finite number of steps. At each call of the procedure within the procedure, the value
assigned to some variable, say P (P = n = number of elements in the array in
Example 6.1) must decrease. When the value assigned to this variable is sufficiently
small, there must be a “termination condition” that instructs the procedure what
to do in this final case. It is common to think of a recursive procedure as operating
on different levels. If the procedure begins with the parameter P initially assigned
the value q, one might think of beginning at the qth story of a building. With
318

6:6 RECURSION
TabIe 6.4
Step No.
n
k
ak
an+l
1.
2.
3.
1.
2.
3.
1.
2.
3.
1.
5.
4.
4
{Call ~IN((4.2,2.1,  3.5), 3,k)}
3
{Call ;IN((4.2,2.1),2,  k)}
2
{Call ~IN((4.2), 1, k)}
{Retur~ to (C);
1
1
4.2
1
2
5. {Return to (B)}
2
2
2.1
4.
5. {Retu;  to (,4)?
3
2
2.1
4.
5. {Retur; with k
4= 4}.
(A)
(B)
(c)
2.1
3.5
0.9
each call the value assigned to P is decreased, and one descends to a lower story
until, say, P is assigned the value 1. On the first floor some real calculation or
comparison is performed and the message is sent back up through the floors to
the qth story, where the final answer is assembled.
A recursive program is also analogous to an induction proof. The “termination
condition” corresponds to checking the base case. The call of tlie procedure within
itself corresponds to using the inductive hypothesis.
Example 6.2. Here is an example of a recursive procedure that calculates the nth
Fibonacci number (see Section 4.4).
Procedure FIB(n, F) {This procedure has n as input and F as output.}
STEP 1.
STEP 7,
Ifnsl, then F:=n
Else
Begin
STEP 2. Procedure FIB(n – 1, F’)
STEP 3. Procedure FIB(n – 2, F“)
S T E P4. F:= F+F’
End {step 1}
Return.
319

6 SEARCHING AND SORTING
In step 1 we use the fact that FO = O and F’l = 1. Notice that we can call FIB
with input n — 1 or n – 2; the parameter n does not have to be decreased before the
call, as was done in MIN. And the answers will be stored in F’ and F“ as directed.
Another classic example of the use of recursive procedures is in calculating
the greatest common divisor of two integers (see Algorithm EUCLID from
Chapter 4). The next procedure is based on the fact that gcd (b, c) = gcd (r, b), where
r = c – Lc/bjb. The procedure takes b and c as input and produces g = gcd (b, c)
as output.
Procedure GCD(b, c, g)
S TEP 1. If b= O,theng:=c
Else
Begin
STEP2. r:=c– Lc/bJ*b
STEP 3. Procedure GCD(r,  b, g)
End {step 1}
STEP 4. Return.
COMMENT.
The values of b and c used in computing r in step 2 come from the
input parameters of the procedure. They equal the original b and c only in the first
execution of step 2.
Question 6.2. Trace GCD with b = 13 and c = 21. How many recursive calls does
it make?
In the exercises you will see examples and problems on recursive procedures
for the algorithms SUBSET, JSET, PERM, BtoD, among others. Some of these
will be more efficient than before, others no more so.
We conclude with a recursive version of SELECTSORT based on an exten-
sion of MIN. The plan is to use basically the same ideas as in SELECTSORT,
only to allow a director-sorter to delegate work to assistants. First we rewrite
MIN so that upon input of an array A and two integers start s finish, it
proceeds recursively to find the index k of the minimum entry in the subarray
(a,,a,,,a,,a,,+ I,..., afi~i,~).
Procedure MIN(A, start,jinish,  k)
STEP 1. If start = finish, then k:= start
Else
Begin
STEP 2. Procedure MIN(A, start, finish – 1, k)
STEP 3. If afini,~ K a~, then k : = finish
End {step 1}
STEP 4. Return.
320

6:6 RECURSION
Question 6.3. Trace MIN on A = ( – 1,0.333,5.2, – 10,6.001, 17) for:
(a) start =2, finish = 3; (b) start = 3, finish = 6; and (c) start= 1, finish = 6.
Algorithm R-SELECTSORT
STEP 1.
STEP 2.
STEP 5.
Input an array A and its length n
For start:= 1 ton– 1 do
Begin
STEP 3. Procedure MIN(A, start, n, k)
STEP 4. If k # start, then switch the values of a,,.,, and ak
End {step 2}
stop.
We don’t claim that R-SELECTSORT is an improvement over SELECT-
SORT, but it is good training for the recursive sorting algorithm in the next
section. In fact, R-SELECTSORT performs about twice as many comparisons as
SELECTSORT as we shall see in the following discussion.
First we count the number of comparisons performed by MIN on an array
of n elements, that is, when n = finish – start + 1; denote this number by M(n).
Then M(l) = 1. For n >1, first one comparison is performed in step 1, then MIN
is applied to an array with one fewer entry, and finally one additional comparison
is made in step 3. Thus
M(n) = M(n – 1) +2.
(D)
In other words, each additional array entry requires two more comparisons. Thus
M(2) = M(l) + 2 = 3,
M(3) = M(2) + 2 = 5,
and apparently M(n) = 2n – 1. To be sure, we prove that this formula is correct
by induction. Since M(l) = 1, the base case is cdrrect. Then
M(n) = A4(n – 1) + 2
by (D)
=2(n–1)– 1+2
by the inductive hypothesis
=2n–1.
Complexity results for recursive procedures are often similarly established using
induction.
Now in R-SELECTSORT  we call the procedure MIN(A, start, n, k) for
start= 1,. ... n — 1. Thus the total number of comparisons performed is
(2n–l)+ (2n–3)+ ”+3=n2-l=O(n2),
(see Exercise 14), giving the same big oh complexity as for SELECTSORT. Com-
paring the more precise count of comparisons (see Theorem 1.1) shows the re-
cursive version to be less efficient.
321

6 SEARCHING AND SORTING
EXERCISES FOR SECTION 6
1. Trace (the second version) of MIN(A, 1, n, k) if
(a) A=<–3, –2, –l), n=3.
(h) A=(–lO,lO, –3,3), n=4.
(c) A = (1,2,3,5,7), n = 5.
2. Trace GCD if
(a) b=3, c=5.
(b) b=l, c= 10.
(c) b=o, c=5.
(d) b=3, c= 14.
3. (a) Write a recursive procedure MINMAX(A, n, rein, max) to find the mini-
mum and maximum entry of an array of n numbers.
(b) Determine the number of comparisons made in the worst case.
4. Using the fact that n! = n(n – 1)! write a recursive procedure FACT(n, F) that
upon input of a nonnegative integer n, calculates F = n!. Trace the procedure
for n =4.
5. What do the following recursive procedures compute?
(a) Procedure NUMl(n,  ans)
SmP 1. If n = O, then ans := O
Else
Begin
SmP 2. Procedure NUMl(n  + 1, ans)
Smx 3. ans := ans – (n + 1)
End
SmP 4. Return.
(b) Procedure ZVUM2(n, ans)
SmP 1. If n = O, then ans:= O
Else
Begin
SmP 2. Procedure NUM2(n – 1, ans)
Smm 3. ans := ans + n
End
SmP 4. Return.
(c) Procedure NUM3(n, ans)
SmP 1. If n = O, then ans := O
Else Procedure NUM3(n – 2, ans)
SmP 2. Return.
322

6:6 RECURSION
6.
7.
8.
9.
10.
11.
12.
,\ (oand(ws’
Find an equation relating the two binomial coefficients
()
n
this to write a recursive procedure that calculates
, . What is the termina-
.,
tion condition?
Here is the classic relation between binomial coefficients:
c)=(n~’)+(~=:)
()
Use this to write a recursive procedure to calculate ~ ; you may need to
use more than one termination condition.
Compare the algorithms in Exercises 6 and 7 by counting multiplications,
divisions, additions, and the number of calls to the procedure. Which is more
eficient?
Trace FIB with n = 5. Count the number of recursive calls. Comment on the
efficiency of this method of calculating Fibonacci  numbers as compared with
methods learned in Chapter 4.
Suppose that A(n) equals the number of additions performed in FIB(n, F).
Then A(O) = A(l) = O and A(2) = 1.
(a) Show that A(n) = A(n – 1)+ A(n – 2) + 1.
(b) Compute A(n) for n =3,4,5,6,7,8.
(c) Compare these values with the nth Fibonacci numbers for n = 2,3,...,8.
(d) Determine a formula for A(n) and then prove that FIB(n, F) performs this
many additions.
(e) Is FIB a polynomial algorithm?
Suppose that we define l’~ = O, F~ = 1
F“ _ ~ + F’n - ~ + F._ ~. Write a recursive
lates F: and stores it in F #.
and F? = 1, and for n >2, F; =
procedure FIB #(n, F # ) that calcu-
Here is an attempt to improve the efficiency of the procedure FIB; to deter-
mine the nth Fibonacci number the numbers n, s = O, and t = 1 should be
input and F will be the output, containing the nth Fibonacci number.
Procedure FlB2(n, s, t, F)
STEP1. Ifn=O, then F:=.s
Else Procedure FIB2(n – 1, t,s + t, F)
STEP 2. Return.
Run this procedure with n = 1,2,3,4,5. Then explain why FIB2(n, 0,1, F)
correctly returns F as the nth Fibonacci number.
323

6 SEARCHING AND SORTING
13. Compare the number of recursive procedure calls made by FIB2 and by FIB.
14. Prove that (2n–l)+(2n–3)+.  ”+3 =n2–1.
15. Prove that the number of multiplications and divisions performed by the re-
cursive version of GCD on b and c is at most 4Llog (b)J. (Hint: Reread the
complexity analysis of the algorithm EUCLID given in Chapter 4.)
16. Here is a recursive procedure to form a list L of all subsets of an n-set ,4,
Procedure R-S UBSET(A, n, L)
STEP 1. If n = O, then L := {0}
Else
Begin
Procedure R-SUBSET(A, n – 1, L)
STEP 2. For each set S in L, add S u {a(n)} to L
End
STEP 3. Return.
(a) Trace this algorithm on A = (1, 2,..., n) for n = 2,3, and 4.
(b) Explain why the algorithm works correctly.
(c) If a step is considered to be the formation of a set, prove by induction
that R-SUBSET(A, n, L) performs 2* steps.
17. Here is a recursive version of the algorithm JSET, presented in Chapter 3.
This procedure receives n and j and then stores all j-subsets of the n-set
{1,2,..., n} in the list L.
Procedure R-,JSET(n,j, L)
STEP 1. Ifj = O, then L := {@}
Else ifj = n, then L:= {{1,2,. . . ,n}}
Else
Begin
STEP 2. Procedure R-JSET(n – l,j, Ll)
STEP 3. Procedure R-JSET(n – l,j – 1, L2)
STEP 4. For each set S in L2,
set S:= Su {n}
S T E P5. L:=LI UL2
End
STEP 6. Return.
Run R-JSET on the following data: (a) n = 2, j = 1; (b) n = 3, j = 1;
(c)n= 3,j=2; (d)n=4, j=2; and(e)n= 5,j=3.
18. What is the mathematical idea behind R-JSET that makes it work correctly?
Count the number of assignment statements made in R-JSET. Is it a good
algorithm?
19. Write a recursive version of TREESORT.
324

6:7 MERGESORT
6:7 MERGESORT
In this section we present an efficient, recursive sorting algorithm, known as
MERGESORT. This algorithm is particularly well suited to the situation when
a set of records must be added to a large already sorted set of records. It has the
disadvantage that to sort an array of n elements an additional array of size n is
used to keep the programming simple and the element shuffling to a minimum.
Here is the idea of MERGESORT from the point of view of the employment
director. Suppose that there is now enough work to employ two assistants. At the
beginning of the semester the director receives a large file from the payroll office,
containing one card for each student employee, listed in alphabetical order. She
wants to sort these by social security number. To divide up the work, she splits
the file, giving half to each assistant to sort. The director will then merge the two
smaller sorted files into one large sorted file.
Algorithms that proceed by dividing the problem in half, working on one or
both halves, and then constructing the final solution from the solutions to the
smaller problems are known as divide-and-conquer algorithms. The algorithms
BINARYSEARCH and BININSERT also follow this approach.
Back in the employment office, the assistants remember the principle of re-
cursion. If they each have two assistants or friends, they will give half of their file
to each for sorting and then merge the resulting sorted files. The halves or pieces
to be sorted will get smaller until an array of one element is reached, say <ai),
and this array is sorted as it is. Notice that this process can be modeled by a
binary tree with the root labeled with the director, the roots of the left and right
subtrees labeled with the assistants, and so on.
Question 7.1. Let A be an array containing eight numbers. Using the ideas of
the preceding paragraphs, draw the corresponding binary tree for this case. What
is the depth of the tree? How many vertices does it contain? In total, how many
assistants are employed in the task?
This approach will be good, provided that we can efficiently merge two sorted
files into one sorted file. We shall see that such a merger can be performed in time
linear in the total number of elements to be merged.
Here specifically is how to merge two sorted files. Assume that we have an
array C such that c 1,. . . , c~id is in sorted order as is c~id + 1, ..., Cn. (If we had
two separate, sorted arrays A and B, we could place them in C with A listed before
B.) The goal is to rearrange C so that it becomes a sorted array. We use an auxil-
iary array D into which we sort the elements of C; in the end we transfer the sorted
D back into C.
First we compare the first entries in the sorted subarrays, c1 and c~id + ~, and
place the smaller in dl. Next, depending on the outcome of the first comparison,
we compare Cz with c~id + ~ or c1 with c~id + z, placing the Smaller  h d2. We COn-
tinue until either the first subarray or the second has been entirely placed in D.
325

6 SEARCHING AND SORTING
Then we fill up D with the remaining elements of the other subarray and finally
copy D into C.
Procedure MERGE (C, start, mid, jnish) {C is an array with entries %,t,
cstart + ~,. . ., Cmid in increasing order and entrieS c~id + 1,. . ., cfini~h also in increas-
ing order.}
STEP 1.
Set i : = start and j : = mid + 1 {i and j index the entries of C being
compared}
Set k:= start {k indexes the entry of D being filled}
STEP 2.
While (i s mid) and (j < finish) do
STEP 3. If ci < cj, then do
Begin
S~~P 4. dk ; = ci
S T E PS. i:=i+l
S T E P6. k:=k+l
End
Else
Begin
Sl13P 7. dk := cj
S T E P8. j:=j+l
S T E P9. k:=k+l
End
{Right now one of the subarrays is in D}
STEP 10. If i > mid, then do {Transfer remaining entries into D}
For index : = j to finish do
Begin
STEP 11. dk : = cind~x
STEP 12. k:=k+l
End
Else
For index := i to mid do
Begin
f3TEP 13. d~ : = cindex
STEP 14. k:=k+l
End
STEP 15. For index := start to finish do {transfer D to C}
d
Cindex 
: = i n d e x
STEP 16. Return.
Example 7.1. Table 6.5 is a trace of MERGE run on the array C = (1,2,3,4,
– 2,0,2,4, 6) with start = 1, mid = 4, and finish = 9. We show the array D after
the completion of each execution of step 3.
326

6:7 MERGESORT
Table 6.5
Step No.
i
j
k
D
1
1
5
1
3
1
6
2
1
7
3
2
7
4
3
7
5
3
8
6
4
8
7
5
8
8
10
15
c=<–2,0,1,2,2>  3,4>4>6).
(–2,...
<–2,0,...
(–2,0,1,...
(–2,0,1,2,...
(–2,0,1,2,2,...
(–2,0,1,2,2,3,...
(–2,0,1,2,2,3,4,...
<–2,0,1,2,2,3,4,4>6)
Notice that when equal entries occur, the entry of the first half is inserted in D first.
Question 7.2. Trace MERGE on C = (0.1, 0.2,0.3,0,0.09, 0.19,0.29,0.39,0.49).
How eilicient is MERGE? Three comparisons occur at every execution of steps
2 and 3, except for the final time when only the two comparisons in step 2 occur.
These steps happen at most n times, where n is the length of the array. Then count-
ing the additional comparison of step 10, at most 3n = O(n) comparisons are
performed in total. MERGE is a linear algorithm.
With MERGE and the assurance of its efficiency, we plan MERGESORT.
We begin with an unsorted array C of length n. We divide C at roughly the
midpoint, setting mid equal to Ln/2j. We sort the first half of C recursively and
the second half of C recursively and then use MERGE to combine them in sorted
order. This will be accomplished by calling the recursive procedure below with
start = 1 and finish = n.
Procedure MERGESORT(C,  start, jinish)
STEP 1. If start = finish, then Return.
Else
Begin
STEP 2. Set mid:= L(start + finish)/2]
STEP 3. Procedure MERGESORT (C, start, mid)
STEP 4. Procedure MERGESORT (C, mid + 1, finish)
STEP 5. Procedure MERGE (C, start, mid, finish)
End {step 1]
STEP 6. Return.
The main trick in tracing a procedure like this is to remember where to return
upon the completion of a procedure and what the values assigned to the variables
327

6 SEARCHING AND SORTING
are at the return. For example, if we call MERGESORT(C, i,j) in step 3, the
procedure receives as input whatever subarray is currently stored in entries i
through j of C, sorts it and returns it at the end of step 3 to the same subarray
of C. All this bookkeeping is done for us in a programming language like Pascal.
Example 7,2. Table 6.6 is a trace of MERGESORT on C = (0.3,0.1, 0.2). The
results of the procedure MERGE are just written under the call statement, since
we have seen how this works before.
Procedure MERGESOR7’((0.3, 0.1,0.2), 1, 3)
Table 6.6
Step No.
c
start
mid
jinish
1,2
(0.3,0.1,0.2)
1
2
3
3
{Call MERGESORT(C,  1, 2)}
(A)
1,2
(0.3,0.1)
1
1
2
3
{Call MERGESORT(C, 1, 1)}
(B)
1
(0.3)
1
1
Return to (B)
1
1
2
4
{Call MERGESORT(C, 2, 2)}
(c)
1
<0.1)
2
2
Return to (C)
1
1
2
5
{Call MERGE(C, 1,1, 2)}
(0.1,0.3)
Return to (A)
(0.1,0.3, 0.2)
1
2
3
4
{Call MERGESORT(C, 3, 3)}
(D)
1
<0.2)
3
3
Return to (D)
1
2
3
5
{Call MERGE(C, 1,2, 3)}
(0.1, 0.2, 0.3)
6
Ret urn.
Question 7.3.
Trace MERGESORT on
(a) C = <1, O) with start= 1 and finish= 2.
(b) C = (22,24, 23) with start = 1 and finish= 3.
(c) C = <1.1, 3.3,2.2,4.4) with start= 1 and finish= 4.
We now verify the efficiency of MERGESORT. The origins of this complexity
bound are explored in Exercise 7.
Theorem 7.1. MERGESORT is a O(n log(n)) algorithm.
328

6:7 MERGESORT
Proof. We begin by proving that if n = 2
k, then the number of comparisons
executed by MERGESORT is 3n log(n) + 2n — 1. The proof is by induction on k.
If k = O, then C contains one entry and with one comparison in step 1 the proce-
dure is finished. Since 1 = 3 ~ 1 log(1) + 2”1 – 1, the base case is established.
We assume that the result holds for all exponents less than k and consider
an array C with 2
k entries. Then initially mid equals 2
k -1, and in steps 3 and
4 MERGESORT is called on arrays of n’ = 2
k -1 entries each. By the inductive
hypothesis MERGESORT performs
3n’log(n’)+2n’–  1 = 3“2 k–llog(zk–l )+z.zk-l–l
.
3.2k-l(k  _l)+2.2k-l_l
—
— 2k-1(3k– 1)– 1
comparisons on each smaller array. The total number of comparisons is 1 (from
step 1) plus the number performed on the first half of C plus the number per-
formed on the second half of C plus 3n, the number of comparisons used by
MERGE, or
2(2k-l(3k –l)–l)+ 3n+l=2k(3k–1)  +3”2k–1
—— 2k3k+22k-l-
= 3nlog(n)  + 2n – 1.
Now suppose that C is an array of n elements, where n is not necessarily
a power of 2. Set r == (log (n)l and m = 2’. We know
n<rn=2r <2’0g(”)+1=2n.
Create C, an array of m elements by appending m – n new elements to the end
of C. Suppose that all these elements are assigned a very large value, a number
larger than all entries in C. When MERGESORT is applied to C we know that the
number of comparisons is at most
3mlog(nz) + 2rn – 1<3 .(2n)log(2n) + 2. (2n) – 1 = 6n(log(n) + 1) + 4n – 1
= 6nlog(n) -t- 10n – 1
s 16n log(n) = O(n log (n)).
Now C’ and C have been sorted with O(n log(n)) comparisons; had we applied
MERGESORT to C alone, perhaps fewer comparisons would have been per-
formed.
K
329

6 SEARCHING AND SORTING
An alternative, tighter upper bound on the number of comparisons in
MERGESORT is outlined in Supplementary Exercises 27 and 28.
Question 7.4. Look at Question 7.3(a) and (c) and verify that exactly 3n log(n) +
2n – 1 comparisons were performed.
Question 7.5. Verify that the number of comparisons MERGESORT performs
on an array of size 3 is 20. Is this number less than 3n log (n) + 2n – 1 with
n = 3? Show that this number is less than 6n log(n) + 10n — 1 when n = 3.
EXERCISES FOR SECTION 7
1. Trace MERGE on the following data. In each case count the number of com-
parisons made and compare with 3n, where n is the length of the array.
(a) C = (1,1,3, 5), start= 1, mid= 1 and finish= 4.
(b) C = (0.1, 0.2,0.3,0,0.2, 0.4,0.6), start= 1, mid= 3 and finish= 7.
(c) C = (1,2, 3,4,1,2, 3,4), start= 1, mid= 4 and finish= 8.
(d) C = (5, 1,2,3,4), start= 1, mid= 1 and finish= 5.
(e) C = (1,2,3,4, 5), start= 1, mid= 4 and finish= 5.
(~) C
 = (1,2, 3,4,0), start = 1, mid = 4 and finish = 5.
2. What happens if you run MERGE with the subarray c1,. . . . c~i~ not sorted?
3. Trace MERGESORT on each of the following arrays:
(a) A = (2,4, 6,8, 10).
(Z)) A = (10,8,6,4,2).
(C) A = (2,6,4, 10, 8).
(d) A = <1,3, 1,5,4,5).
(e) A = (2,2, 2,2,2).
4. Draw a binary tree that corresponds to the divisions into subarrays in Ex-
ample 7.2 and Question 7.3. In general, for what arrays of length n is the cor-
responding tree a full binary tree?
5. Count the number of comparisons made in each case of Exercise 3. Com-
pare these numbers with 3n log(n) + 2n – 1 and with 6n log(n) + 10n – 1 for
appropriate values of n.
6. From the numerical evidence of Questions 7.4 and 7.5 and Exercise 3, con-
jecture whether the following is true or false: MERGESORT performs at most
3n[10g (n)l + 2n – 1 comparisons to sort an array of n elements. (See also
Supplementary Exercises 27 and 28.)
7. Let M(n) denote the maximum number of comparisons made in MER-
GESORT, applied to an array of n elements, and suppose that n = 2
k. Then
M(l) = 1 and for n >1 MERGESORT proceeds by calling itself on two arrays
330

6:8 SORTING IT ALL OUT
of size nf2 = 2
k -1 and then MERGE-ing the two sorted arrays with 3n ad-
ditional comparisons. Thus
M(n) = 2A4(n/2) + 3n + 1.
Use this relation to determine M(n) for n = 2,4,8, and 16.
Then find an expression for ‘M(n) in terms of &f(n/4) and in terms of
A4(n/8). Explain why this leads to the formula
M(n) = 2~M(l) + k3n + n – 1
= 3nlog(n)+2n–  1
(still assuming that n = 2’).
8. Suppose that A is an array containing 2n numbers. If the array is divided
in half for each of two assistants to sort and if they each divide their half
in half for two additional assistants to sort, and so on, until finally the assis-
tants receive arrays of length one, then how many assistants in all are used?
How many levels of assistants are used?
9. Answer the same question as in Exercise 8 when the array contains m numbers,
where 2
n s m K 2“ 
+ 1 for some integer n.
10. Write a procedure that inputs an array A = <al, a2,. . . . an) (not necessarily
sorted) and rearranges A so that if mid = L(l + n)/2] and S = a~i~, then all
entries preceding S are less than or equal to S and all entries following S
are greater than or equal to it. (Note that S may need to be moved to a dif-
ferent position.)
11. Write a sorting algorithm that splits the input array A using the preceding
exercise and then recursively sorts the parts preceding and following S.
12. Write an algorithm 4-MERGE that takes four sorted arrays and merges them
into one sorted array. Compare the complexity of your algorithm with that of
using MERGE three times to combine these four arrays into one.
6:8 SORTING IT ALL OUT
The art of searching and sorting is an extremely important and highly developed
one in computer science and applications. These are processes used in almost all
record-keeping tasks. Not only do telephone companies, banks, the IRS, and so
forth, perform these tasks repeatedly, but now even writers find these tasks in-
dispensable in their word processing programs. For example, searching was done
repeatedly in the preparation of this text. Every time a theorem, a question, an
example, or an exercise was renumbered, a search was run to find all occurrences
of the changed number. A spelling checker program also searches for spelling
331

6 SEARCHING AND SORTING
errors and is equally useful because it picks up most typing mistakes. Sorting is
also important, for example, in alphabetizing the index of a book.
One important theme of this chapter is the difference between O(n2) and
O(n log(n)) algorithms. Both kinds are good algorithms, but the latter are notice-
ably more efficient. Except for cases with small data sets (small like most that
we’ve considered in examples and exercises), the faster algorithms make a signifi-
cant difference in general real-life applications. Of course, there are exceptions to
every rule, and two such exceptions are BUBBLESORT (Exercises 1.11 to 1.13)
and INSERTIONSORT (Supplementary Exercise 7). In the worst case these are
O(n2) algorithms, but when given a nearly sorted array, they can run in linear
time. For example, when an array is nearly sorted except that some adjacent pairs
of elements are transposed, both BUBBLESORT and INSERTIONSORT are
able to benefit from the nearly sorted arrangement. In contrast an algorithm like
BINARYSORT will perform the same number of comparisons on a nearly sorted
array as on a randomly ordered array.
Another theme of this chapter is the difference between algorithms with the
same big oh complexity. When sorting files with large individual records, algo-
rithms should be used that minimize record transfers; for example, SELECTSORT
would be perferred to BUBBLESORT if a 0(n2) algorithm were being used.
MERGESORT should be avoided if the file length is so long or the records so
large that there is not room for a duplicate array. However, MERGESORT is a
good choice when two smaller sorted files are to be sorted into one. No algorithm
using comparisons can be faster than O(n log(n)), and the number of different
n log(n) algorithms confirms that these must have been designed for varying needs.
TREESORT uses the most sophisticated data structure among the algorithms
we’ve seen. This algorithm and algorithms based on storing data in tree structures
have wide applicability in these and other combinatorial settings.
We have alluded to the existence of a linear-time sorting algorithm, known
as BUCKETSORT or “distribution counting.” If we want to sort an array of n
elements whose entries are integers from O to M for some small number M, like
M = O(n), then we can make one pass through the array and can store the record
with key ai in the aith entry of a new array. (More picturesquely, we think of
tossing the record in the aith “bucket.”) Then in one additional sweep through
the new array, we can pick up the elements in order. We have performed n + M
assignments and no comparisons. This algorithm has limited applicability; for ex-
ample, using this algorithm the employment director would store the record cards
of, say, 600 students in a new array of length 999,999,999, since there are this
many possible social security numbers. This approach would necessitate an inap-
propriately large array. More sophisticated versions of such an algorithm are
known as hashing.
Finally, the concept of recursive procedures is an important one. This is the
computer scientists’ analogue  of induction. In Chapter 7 we shall study solutions
of recurrence relations and counting problems that arise from recursive procedures.
332

SUPPLEMENTARY EXERCISES FOR CHAPTER 6
This chapter has been only an introduction to a deep and well-understood theory,
which merits further study. 1
SUPPLEMENTARY EXERCISES FOR CHAPTER 6
1. Devise an algorithm TRISECTSEARCH that upon input of an array A of n
numbers in increasing order and a number S, searches by thirds of A for S.
Specifically, first the algorithm should see whether S equals the L(n + 1)/3jrd
entry in A. If not and S is smaller, then it begins again with the first third of A.
If S is larger than this entry, it compares S with the L2(n + 1)/3Jrd entry. If S
is smaller, it proceeds with the middle third of .4; if S is larger, it proceeds with
the last third of A. Determine the worst-case complexity of your algorithm.
2. Write an algorithm that upon input of an ordered array A of n numbers and
a number S, searches for S and if found, deletes it. Determine the worst-case
complexity of your algorithm.
3. Write an aigorithm that upon input of an ordered array A of n numbers and
a number S, searches for S and if it is not found, inserts it in the correct order.
Determine the worst-case complexity of your algorithm.
4. Rewrite a version of BININSERT, called BININSERT2, that tests whether
a,+ ~ = amid after step 3, and if so, immediately inserts a,+ ~ at the (mid)th
entry of the array. Are there arrays on which BININSERT2 will run faster
than BININSERT? Are there arrays on which BININSERT2 will run slower
than on BININSERT? Determine the worst-case complexity of BININSERT2.
5. Use BININSERT2 to form a new version of BINARYSORT, called
BINARYSORT2. Run both BINARYSORT and BINARYSORT2 on
<1,5,1, 1,1) and compare the efficiency of these algorithms on this array.
6. In this exercise you are asked to compare the number of assignment statements
in SELECTSORT and in BINARYSORT. The significant assignment state-
ments are those involving array elements, not just index counters in loops.
(a) Rewrite SELECTSORT so that step 5 is expanded and actually carries
out the details of switching aj and TN. Call this X-SELECTSORT.
(b) Count the number of assignments of elements ai and TN in the worst
case in X-SELECTSORT.
(c) In the procedure BININSERT with r = 1,2,3, and 4 find examples in
which r + 2 assignments of elements ai and temp are made.
(d) Explain why the maximum number of assignments of elements ai and
temp in BININSERT is r + 2.
1 A good next source is a large book on the subject  D, E. Knuth,  Sorting and ,Searclring, Volume 3
of The Art of Computer Programming, Addison-Wesley, Reading, Mass., 1973.
333

6 SEARCHING AND SORTING
(e) Use the result of part (d) to determine the maximum number of assign-
ment statements performed in BINARYSORT.
(j) ~~w} of X-SELECTSORT and BINARYSORT performs more assign-
7. INSERTIONSORT is another sorting algorithm; it is based on the idea of how
one often sorts a hand of playing cards: with the left end of the hand sorted,
the remaining cards are inserted in order, one at a time.
(a) Write a procedure INSERT(r, al,. . . . a,, a,+ 1) that has a sorted array of
length r, (al, az,. . . , ar), and an element ar + 1 as input and that outputs
the array (al,. . . . a,+ ~ ) in sorted order. The procedure should search
through the input array sequentially until the position for inserting a,+ 1
is found; then a,+ ~ should be inserted there.
(b) Here is the algorithm INSERTIONSORT:
Algorithm INSERTIONSORT
STEP 1. Input n and an array (al, az,. . . ,an)
STEP 2. For m = 2 to n do {insert mth entry}
STEP 3. Procedure INSERT ((m – 1), al,. . . . aJ
STEP 4. Stop.
Trace this on (1,3,2,5,4, 6).
(c) Compare this sorting algorithm with SELECTSORT and BINARY-
SORT. Describe arrays on which INSERTIONSORT works more eiTi-
ciently than the others and arrays on which it is less efficient.
(d) Determine the complexity of INSERTIONSORT.
8. A sorting algorithm is said to be stable if whenever ai = aj for some indices
i z j, then in the sorted array ai precedes aj. Is either SELECTSORT or
BINARYSORT stable? Explain. If not, can they be rewritten (easily) so that
they are stabie?
9. Is INSERTIONSORT a stable sorting algorithm?
10. Suppose that A is a sorted array of n elements. How does the speed of
INSERTIONSORT on A compare with the speed of SELECTSORT and
BINARYSORT?
11. Suppose that you have an (unsorted) array with n items and another item
D. What is the minimum number of comparisons necessary to determine
whether D is contained in the array or not?
12. Looking up a telephone number in a directory is an example of a typical
search through a large ordered list. If the name you are looking for is, say,
Smith, you wouldn’t turn to the exact middle of the directory despite the high
quality of BINARYSEARCH. The reason is that you have some knowledge
concerning how the names in the directory are distributed. If you are Iooking
334

SUPPLEMENTARY EXERCISES FOR CHAPTER 6
for the name Smith, you will look more toward the back of the book because
you expect that more names come before Smith than after it. You might use
a strategy like the following: Since S is the 19th letter of the alphabet, you
might look at the page numbered m, where m = ~19n/26J and n is the total
number of pages in the directory. Develop an algorithm, called weighted binary
search, that exploits this idea. When should you use weighted binary search
and when should you definitely avoid it? (This kind of approach is also known
as interpolated search.)
13. Here is a recursive version of the algorithm DtoB from Chapter 1 that upon
input of a nonnegative integer m determines its binary expansion s.
Procedure R-DtoB(m, s)
STEP 1. If m s 1, then set s := m
Else
Begin
STEP 2. Procedure R-DtoB(Lm/2], s)
STEP 3. If m is even, then sets equal to s with a O added at the end,
Else set s equal to s with a 1 added at the end
STEP 4. Return.
(a) Trace this algorithm for m = 1,3,6,8.
(b) Show that this algorithm is correct.
(c) Prove by induction that the number of divisions in R-DtoB is at most
log (m).
14. Reread the algorithm EXPONENT in Chapter 2. Then use the fact that
x“ = x ~ x“ 
-1 to write a recursive version of EXPONENT. Compare the
number of multiplications in EXPONENT and the recursive version.
15. Write a recursive version of FASTEXP, called R-FASTEXP(X, n, ans) that
upon input of x and n will calculate X
n and store it in ans. Is this version
faster or slower than FASTEXP?
16. Look back in Chapter 3 at the algorithm PERM. Write a recursive version
of this algorithm.
17. Does the following correctly compute the greatest common divisor of b and c?
Explain.
Procedure GCD3(b, c, g)
STEP1. If b=c, then g:=b
Else if b s c – b, then Procedure GCD3(b, c – b, g)
Else Procedure GCD3(C – b, b, g)
STEP 2. Return.
335

6 SEARCHING AND SORTING
18. Here is an idea for a recursive version of BINARYSEARCH: Given an array
(ai,. . . . aj) of numbers and a number S, determine whether S is less than
the middle entry of the array and, if so, search the first half. If not, search
the second half. Write a recursive version of BINARYSORT.
19. Suppose that we have a sorted array A of length n and an unsorted array
B of length m that we wish to merge into A to form a final sorted array A
of length n + tn. Here are some different approaches:
(a) Add B to the end of the array A and then use BINARYSORT on this
array.
(b) Add B to the end of the array A and then use MERGESORT on this
array.
(c) Add B to the end of the array A and then use INSERTIONSORT (see
Exercise 7), replacing step 2 with “For m = n + 1 to n + m do.”
(d) Use MERGESORT on B and then use MERGE on A and B.
Comment on the pros and cons of these approaches. In particular, decide
which one you would pick for best efficiency.
20. Compare the efficiency (i.e., number of comparisons performed) of SELECT-
SORT, BINARYSORT, and MERGESORT on the following types of arrays:
(a) A sorted array.
(b) An array listed in reverse order.
(c) An array that is nearly sorted except for the interchange of some adjacent
pairs of numbers (like (1,3,2,5,4, 6)).
(d) An array with many repeated numbers.
(e) An array with its first half sorted and its second half sorted.
21. Is MERGESORT a stable sorting algorithm? (See Exercise 8.)
22. Develop the following idea into an algorithm to sort A = (al, az,. . . . a.).
(1) Find the least integer i such that <al,..., ai) is sorted, but (al,..., % ai+ 1)
is not.
(2) Find the next least integer j such that (aj ~ ~,. . . . aj) is sorted, but
<ai+l,. ... (.Zj, Uj+  ~) is not.
(3) Merge (al,. . . . ai) and (ai+ ~,. . . ,aj).
(4) Set i:= j and if j K n, go to line 2.
Implement this as an algorithm and run it on the following data:
(a) A = (1, 3,2,5,4,6>.
(b) A = (1,2,3, 5,4,6).
(c) A = (2,4,6,3,5, 7).
(d) A = (1,2,3,4,5,6).
(e) A = (6,5,4, 3,2, 1).
Determine the worst-case complexity of your algorithm.
23. Here is an alleged sorting algorithm that is supposed to take an array of
length n with start = 1 and finish = n and to rearrange A in increasing order:
336

24.
25.
26.
27,
SUPPLEMENTARY EXERCISES FOR CHAPTER 6
Procedure M YSTER Y(A, start, jinish)
S~E~ 1.
STEP 13.
Run this
If start < finish, then
Begin
STEP 2.
test : = a,ta,t
S’TE~ 3.
i:= start+ 1
STEP 4.
j : = finish
STEP 5.
Repeat
Begin
S T E P6. While test <aj, setj:=j–l
STEP7. While test >aiandizfinish,  set i:=i+ 1
STEP 8. Switch ai and aj
Until j s i {end of step 5}
STEP 9.
Switch ai and aj {undoing the last switch}
STEP 10. Switch a,t,,t and aj
STEP 11. Procedure MYSTERY(A, start,j – 1)
STEP 12. Procedure MYSTERY(A,j + 1, finish)
End {step 1}
Return.
algorithm on a variety of arrays and then answer the following
equations:
(a) MYSTERY finds an index j, places some entry in it, and then recursively
goes to work on the array in front of j and behind j. What value of j does
it determine and what entry is placed in aj?
(b) Describe in words how MYSTERY works.
(c) Determine the worst-case complexity of MYSTERY.
Why does BINARYSEARCH require more comparisons than BININSERT
in the worst case?
Rewrite BINARYSEARCH so that the maximum number of comparisons it
performs in searching an array of n items is 2 log(n) + c, where c is a constant.
In the complexity analysis of BINARYSORT we proved that the maximum
number of comparisons performed on an array of n elements is 4(n – 1) +
210g((n – l)!). First prove that for i = 1,. . . ,n – 1,
i(n+l-i)<(~;l)’
Then use this to derive an upper bound on log ((n – l)!) that is O(n log(n)).
Let T(n) denote the maximum number of comparisons performed by MERGE-
SORT on an array of n entries. Then explain why
T(n) = T(ln/2]) + 7’([n/21)  + 3n + 1
forn>l
337

6 SEARCHING AND SORTING
and
T(1) = 1.
Calculate T(i) for i s 8 and compare these results with those of Questions 7.4
and 7.5 and Exercise 7.5.
28. Use the results of the previous exercise to prove that
T(n) s 3n[log (n)l + 2n – 1.
29. Suppose that a file of n records is to be sorted and the keys of these records
are known to be precisely the numbers 1,2,. ... n. Here is an algorithm to
accomplish a sort on the keys ai:
Algorithm BUCKETSORT
STEP 1. Input A = <al, uz,. . . . an) containing distinct entries from 1,2,. ... n
STEP2. For i:= 1 to n d o
STEP 3. B(ai) : = ai
S T E P4. Fori:=l ton do
STEP 5. ai : = B(i)
STEP 6. Output (al, az,. . . . a.).
Run a trace on this algorithm with input A = (2,1,5,4,3,6, 7).
30. Count the number of assignment statements made in BUCKETSORT when
run on an array of size w in this algorithm these are the most time-consuming
statements.
31. Write an algorithm BUCKETSORT2 that has as input an array A of n distinct
numbers whose entries lie between O and some constant M. The algorithm
should first do a “bucketsort” of A into an array B of length M and then
transfer the sorted elements back into A. Count the number of assignment
statements made in BUCKETSORT2.
32. Suppose that a comparison takes twice as long as an assignment statement.
Compare the time needed to run BUCKETSORT2 when M = 2n, kn for some
constant k, n log(n), and n
2 with the time needed for BINARYSORT.
33. The Pancake Problem asks the following Given a stack of pancakes of varying
diameters, rearrange them into a stack with decreasing diameter (as you move
up the stack) using only “spatula flips.” With a spatuia flip you insert the
spatula and invert the (sub)stack of pancakes above the spatula. Design an
algorithm that correctly solves the pancake problem for a stack of n pan-
cakes with at most 2n flips. Count exactly how many flips your algorithm uses
in the worst case.
338

7 
RECURRENCE RELATIONS 
7:1 BEGINNINGS OF SEQUENCES 
A few years ago an advertisement on the London subway (or tube) system read 
as follows: 
"If you can determine the next number in each of the following lists before 
you arrive at your stop, come in and we'll offer you a job! 
1 2 
4 8 
16 
32 
0 
1 3 
6 
10 
15 
1 2 
3 
5 8 -
2 
9 
28 
65 
126 
2 3 5 
7 
11 
13 
" 
-
Question l.l. Find a plausible next entry in as many of the above lists as you can. 
This chapter explores intrinsic properties of lists or sequences of numbers. 
Given a partial list, we would like to determine: its next entry. More generally, we 
would like to find a formula for the nth number on the list. From this we can 
determine the growth rate of the sequence, that is, we can discover whether the 
11th number in the sequence grows like a polynomial or an exponential function 
of 11. Many of the sequences we shall study have appeared before in the course; 
others are important in combinatorics and algorithms. 
Definition. 
A sequence is a function whose domain is the positive integers and 
whose target is the real numbers. A sequence whose target is the integers is called 
an integer sequence. 
339 

7 RECURRENCE RELA nONS 
In the London subway puzzle we see initial segments of five integer sequences. 
We represent a sequence 
by listing the values of the sequence at the integers 1, 2, 3, .... Even though a 
sequence is a function, it is common and convenient to use the subscript notation. 
We call al the first term of S, (/2 the second term, and in general an the nth term 
of the sequence. Occasionally, we shall extend the domain of a sequence to include 
zero (e.g., Fibonacci numbers). In this case we talk about the Oth term of a sequence. 
Example 1.1. 
Here are two common sequences: 
S 1: 1, 2, 3,4,5,6, ... , 
S2: 2, 4,8,16,32,64, .... 
For these sequences a formula for the 11th term is not hard to guess: for 5 l' an = n 
and for S2' an = 2n. In many situations a formula for a sequence may not be 
immediately apparent. 
Example 1.2. 
In the London subway problem, you probably recognized the Fi-
bonacci numbers~ let 53 be this sequence: 
53 :1,1,2,3,5,8, .... 
We know that each Fibonacci number (after the first two) is the sum of its two 
immediate predecessors. Knowing this pattern, we can in principle calculate any 
Fibonacci number. However, the formula for the nth term is not obvious. Recall 
that, in Chapter 4, we verified this formula by induction but deferred until this 
chapter how such a formula could be discovered. 
Question 1.2. 
Here are the initial segments of some (possibly familiar) integer 
sequences: 
54: 1,2,6,24,120, .. . 
5 5 :0,1,3,6,10,15, .. . 
56: \,3,7,15,31, .. . 
S7:2,3, 5, 7,11, 13. \7 ... . 
S8: 1,4,9,16,25,36, .. . 
S'):I, -3,9. -27,81, .. . 
For at least two of the sequences S4 to Sq, lind a formula that generates the initial 
segment of the sequence as listed above. 
340 

7: I 
BEGINNINGS OF SEQUENCES 
Notice that there might be ambiguity when we see only the initial segment of 
a sequence. We can't be sure about the numbers that appear in the ... until we 
have a precise description of the sequence. 
Example 1.3. 
Here are three different functions that each generate the initial seg-
ment of S4: 
j~ = /1! 
Ull = (2[4)[(11 -
2)(11 -
3)(/1 - 4)(11 -
5) -
8(/1 -
1)(/1 -
3)(/1 - 4)(/1 -
5) 
+ 36(/1 -
1)(11 - 2)(/1 - 4)(/1 -
5) -
96(n -
1)(/1 -
2)(/1 -
3)(/1 -
5) 
+ 120(n -
1)(/1 -
2)(n -
3)(/1 - 4)J 
{try it!] 
I 
II1! 
if /1 ::;; 5 
In = \0 
l 
if II > 5. 
Question 1.3. 
Find two functions that each produce the first three values of the 
sequence: 5,9,17, .... 
Formulas are not the only way to describe sequences. Look at S7: A moment's 
reflection leads one to conjecture that this is the sequence of all prime numbers. 
Although this description is exact, we cannot write down a formula for a function 
that generates the primes. On the other hand, we could write down an algorithm 
using the Sieve of Eratosthenes (as described in Supplementary Exercise 4 of 
Chapter 4) to determine the next prime. 
Another way that words can describe a sequence is by identifying patterns 
within the sequence. We know that each Fibonacci number is the sum of the two 
preceding ones: 
and this pattern completely specifies the Fibonacci numbers once we know ~he 
first two values. Such a pattern is known as a recurrence relation.' 
Example 1.4. 
Notice that in S 5: 0, 1,3,6, 10, 15, ... , the difference of successive 
terms is 1, 2, 3, and so on. In symbols, 
for n> I. 
iA) 
Thus, like the Fibonacci numbers, the sequence S 5 is completely determined once 
we specify this pattern and the fact that LI[ = O. 
Question 1.4. 
For the sequence S 1 find an equation that relates all and an ~ [. Then 
do the same for S,. 
341 

7 RECURRENCE RELA nONS 
Example 1.5. 
Suppose that an algorithm SECRET performs M n steps upon input 
of a positive integer n. Trial runs show that M 1 = 1, M 5 = 3, and M 8 = 4. Suppose 
that by analyzing SECRET we find the following pattern or recurrence relation: 
(B) 
Is SECRET good or exponential? The known values of M n together with others 
we could calculate specify the start of a sequence; however, we don't know a 
formula for M no In Section 5 we shall discover such a formula and deduce that 
SECRET is a good algorithm. 
Question 1.5. 
Starting with a 1 = 0, use equation (A) to calculate Q2" .. ,Q6' Then 
use equation (B) to calculate M 1" .. ,M 8' 
Question 1.6. 
Here are two different recurrence relations for a sequence known 
as the harmonic numbers. 
1 
Let H'1 = 1, and for 11 > t let H;, = H~ - 1 + -. 
n 
Let H'{ = 1, and for 11 > 1 let 
1 
H~ = ~ [H~ _ 1 + H~ - 2 + ... + H'{] + 1. 
Determine the first five values of H~ and H~. 
Question 1.7. 
Let C 1 = 1, and for n > 1 let 
Determine the first five values of Cn" These are known as the Catalan numbers. 
This chapter will present techniques to discover and verify formulas for the 
nth term of a sequence given an initial segment and a recurrence relation. 
EXERCISES FOR SECTION 1 
1. Give an example of a function that is not a sequence. Give an example of a 
sequence that is not an integer sequence. 
2. Which of the following prescribes a sequence'.' 
(a) 2,4,6,8, ... ,2n, .... 
(b) 
j~ = 3n -
1. 
342 

7: I 
BEGINNINGS OF SEQUENCES 
(c) 
gn = 1/11. 
(d) hn = -!:. .. In. 
. 
1 
(e) in = 11 3 _ 14112 + 6411 - 90· 
(f) G1 = 1, G2 = 2 and Gn = Gn - 1 + 2Gn - 2 for 11 23. 
(g) H n = H 11 - 1 + H 11 - 2· 
(h) A list of all positive integers that are perfect cubes. 
(i) The set of all real numbers. 
3. Which of the sequences in the preceding problem are integer sequences? 
4. Match the following initial segments of sequences and formulas: 
(a) 
1 3 
12 
60 
360 ... 
(i) j~ = n2 -
6n + 8 
(b) 336915 24 
(ii)j~=1I2-6n+1O 
(c) 
2 
4 
8 
14 
(d) 
4 
0 
I 
(e) 
I 
4 
10 
20 
(f) 0 
2 
6 
14 
(g) 
8 
27 
64 
(h) 
5 
2 
2 
22 
32 
4 ... 
35 
30 
125 
5 
(iii) j~ = n2 + II -
:2 
(iv) j~ = 112 -
11 + :2 
(v) f~ = 2F II' where FII is the 11th 
Fibonacci number 
(vi) f~ = 3F" 
.. 
(11) 
(VII) I~ = 2 2 
(viii) III = 2" -
I 
(ix) In = (11 ; 2) 
(x) f~ = 112 
(xi) ;;, = (II + 1)!/2 
(xii) j~ = :2n! 
(xiii) I;, = 112 
(xiv) I;, = (11 -
3)2 
(xv) til = 311 2 
(xvi) 
j~ = 11! 
(xvii) j~ = II] 
(xviii) 
(xix) 
(xx) 
(xxi) 
I~ = 2n-! 
I~ = 2" - 2 
I~ = (_1),,-1·3,,-1 
I~ = (112 - 11)/2 
5. For each of S4, S'i' S6' SR, and Sq in Question 1.2 find a formula among 
those listed in Exercise 4 that generates the sequence. 
343 

7 
RECURRENCE RELATIONS 
6. For how many of their first entries do '/;, = n3 - 3n2 + 2n and !i" = /l+ -
13n3 + 56n 2 - 92n + 48 agree? 
7. The recurrence relation F" = F" _ 1 + F n _ 2 produces the Fibonacci numbers 
with the initial values F 1 = F 2 = 1. Give an example of initial values that pro-
duce a different sequence. Then find initial values that produce some Fibonacci 
numbers, but not all of them. Characterize the initial values that produce a 
sequence whose entries are each a Fibonacci number. 
8. Define the extended Fibonacci numbers by G l = 1, G2 = I, G3 = 2, and for 
n>3 
Are the following statements true or false about Gn'? 
(i) For 12 ?:: 2. Gn = C) + 1. 
(ii) For 12 > 3, Gn *" FIl • 
(iii) G" is a Fibonacci number, but not necessarily F". 
(iv) G" = FIl + G,,-3 for IJ > 3. 
(v) Gn = 0(2n). 
9. Here is a famous sequence of letters; identify the pattern: 
() 
ffssclltc···. 
10. Find two functions f and !i such that It == ift = 3 and f~ = if3 = 5. but 
f~ *"?h 
11. For each of the following, find a formula that expresses the nth term .in as a 
function of 11: 
(i) /1 = I,f~ =f~-1 + 2 for n > l. 
(ii) j~ = 2. In = f;, _ 1 + 2n - 1 for II > 1. 
(iii) II = I. '/;, = j~_ 1 + 211 for 11 > l. 
12. Verify that for il = 1. 2, ... ,5. H" = 1 + (1/2) + ... + (1/11) satisfies both 
recurrence relations in Question 1.6. Use induction to show that this formula 
works III general. 
13. If H" is the nth harmonic number, then show that 
344 
In 
[{2 m ?:: 1 + J' 

7: 1 BEGINNINGS OF SEQUENCES 
Explain why for every positive integer lvI there is an integer IV such that 
Hn :;:: M for all n :;:: N. Show also that 
14. Let Hn be the nth harmonic number. Show that 
(n + 1) 
H <---
n -
" 
in two different ways: (i) by induction using the recurrence relation for H~ 
and (ii) using the formula for Hn given in Exercise 12. 
Llog(I1)J 
. 
15. Show that 1 + 
2 
~ Hn ~ 1 + Llog(n)J tor n > O. 
16. The Catalan numbers of Question 1.7 satisfy the formula 
en = ~ (211 _. 2). 
II 
11 - 1 
Verify this for 11 ~ 5. 
17. Show that ~ (211 - 2) is always an integer. 
11 11-1 
18. The Bernoulli numbers are defined by Bo == 1 and for 11 > 0, 
1 [(11 + I) 
(11 + t) 
(11 + 1) ] 
Bn =-11+1 
11-1 Bn -
1 + 
11-:~ Bn - 2 +"'+ 
0 
Bo· 
Determine the next five values of Bn-
19. Check that 8 7 = B9 = O. 
20. Find the first Bernoulli number that is greater than t. 
21. Although the Bernoulli numbers start out smaiL the even ones grow very 
quickly. It can be shown that 
and that 
(211)! 
"2--211 = 0(IB 2nl)· 
( n) 
345 

7 RECURRENCE RELA nONS 
Use the bounds on n! derived from Stirling's formula (in Section 3.4) to obtain 
bounds on the growth rate of IB2nl. 
7:2 ITERATION AND INDUCTION 
In this section we begin to explore ways to deduce a formula for a sequence given 
a recurrence relation that the terms of the sequence satisfy. 
When we look at the London subway puzzles or the sequences SI to S9' listed 
in the previous section, we can, without too much difficulty, find patterns in the se-
quence entries. We found that the sequence S5 satisfies the recurrence relation, 
n> 1. 
(A) 
In Question 1.4 you determined that for SI 
and for S2 
Here is more precisely what we are looking for. 
Definition. 
Suppose that S is the sequence 
If the nth term of S can be expressed as a function of previous terms in the 
sequence: 
(B) 
then equation (B) is called a recurrence relation, and we say that the sequence S 
satisfies that recurrence relation. 
The function in (B) may depend on only some of the previous entries or it may 
depend upon all of them. The former happens frequently, but Questions 1.6 and 
1.7 illustrate the latter possibility. 
In a sense, once we have found a recurrence relation underlying a sequence 
we are done. We can use this relation to find the next (or any subsequent) term. 
However, it might get tedious to calculate 11\ 00' It is important to look for a 
formula that would give us 11n directly. 
346 

7:2 
ITERATION AND INDUCTJON 
Example 2.1. 
Let S10 be the sequence 
S10: 1,3,4,7,11,18, ... , 
where, like the Fibonacci numbers, each term is the sum of the preceding two 
terms. Thus a sequence is not completely specified by its recurrence relation. 
Question 2.1. 
Find recurrence relations for the sequences S6: 1, 3, 7, 15,3 L ... , 
and S9: 1, - 3, 9, - 27, 81, .... In each case, find a different sequence satisfying the 
same recurrence relation. 
Once we have enough initial values of a sequence together with the recurrence 
relation, the sequence is determined. For example, if a sequence begins with a 1 = I 
and a2 = I and then obeys 
(C) 
we get the Fibonacci numbers; however, if a1 = 1 and a2 = 3 then the sequence 
S10 results. 
Definition. 
Let k be the least integer such that once values are assigned to 
ai' a2" .. ,ak> then (B) prescribes a unique value for each an with n > k. Then the 
values of ai' a2,' .. ,ak are called the initial conditions of the recurrence relation. 
We say that the recurrence relation together with its initial conditions generates 
the seq uence 
Typically, a recurrence relation will be given in the form 
for n > k, 
where k is some fixed integer. The bound .on > k" specifies the range over wClich 
the recurrence relation holds, and the initial conditions that must be assigned are 
the values of ai' a2, ... , and ak' 
Example 2.2. 
The recurrence relation (A) requires only one initial condition the 
value of a1. If a1 = 0, the sequence generated is that given in S5' If ill = 2. the 
sequence generated is 
2,3,5,8, 12,. .. 
(which is not a subsequence of Fibonacci numbers!). The recurrence relation 
for n > 4 
347 

7 RECURRENCE RELATIONS 
expresses aM in terms of two previous values but requires four initial conditions 
before all values of the sequence are uniquely defined. 
Question 2.2. 
In the recurrence relation an = aM -- 4 + (/,,-2' why are fewer than 
four initial conditions not enough to define an for all larger 11? If (/1 = (/2 = (/3 = 
a4 = 1, find the first 10 terms of the sequence determined by this recurrence rela-
tion. Describe the resulting sequence. Then determine an explicit formula for all' 
Question 2.3. 
For each of the following, determine the number of initial condi-
tions that must be assigned so that a unique sequence is generated: 
(i) an = l1an- 2 
(ii) an = an - 1 + an - 3 
(iii) an = 2a[n/2]' 
Example 2.3. 
Consider the recurrence relation (A) with initial condition al = O. 
Repeated application of (A) will lead to a formula. Since an _ 1 = all _ 2. + (11- 2). 
substitution in (A) yields 
an = an - 2 + (11 -
2) + (11 -
1). 
(01 
Since an _ 2 = an _ 3 + (n -
3), substitution in (D) yields 
an = an - 3 + (n -
3) + (n -
=~) + (II -
1). 
Continuing until we reach a1 = 0, we get 
an = a 1 + 1 + :2 + ... + (n -
2) + (n -
1) 
= 0 + 1 + 2 + ... + (n -
=~) + (n -
I) 
n(n -
1) 
2 
(see Example 2.3.2) 
a formula for the nth term of the sequence S5' 
The process used in Example 2.3 is known as iteration and in straightforward 
cases will lead to a formula for the sequence. 
Question 2.4. 
Use iteration on each of the following recurrence relations and 
initial conditions to obtain a formula for the sequence they generate: 
(i) an = l1a,,-l for 11 > I, a l = 1. 
(ii) hn = hn - l + 2 for 11 > 1, hl = 1. 
It seems clear that the formulas we come up with using iteration are correct, 
but to be certain we need to use induction. In Example 2.3 we decided that 
an = n(11 -
1 )/2; now we prove that this formula is correct. 
348 

7:2 
ITERATION .\ND INDUCTION 
Example 2.3 (continued). 
Here is an inductive proof. 
Theorem. 
an = n(1l -
1)/2 satisfies (A) with initial condition a 1 = O. 
First the base case: a1 = 1 . 0/2 = O. We want to use the assumption that 
ak = k(k - 1 )/2 to prove that 
(k + l)(k + I -
1) 
(k + I)k 
ak,. 1 = 
To accomplish this. we begin with the recurrence relation: 
k(k -
1) 
= 
+1< 
2 
by the inductive hypothesis 
= I< [(k ; 1) + 1 ] 
by arithmetic 
k(k + 1) 
just as we wanted. 
Question 2.5. 
Prove by induction that the formulas you obtained in Question 2.4 
are correct. 
Definition. 
A recurrence relation is called homogeneous if it is satisfied by the 
sequence that is identically zero (i.e., an = 0 for all 11). Otherwise. it is called 
inhomogeneous. 
Example 2.4. 
To test whether a recurrence relation is homogeneous, replace every 
a; with zero and see if, for all 11, a valid identity remains. For example, LIn = 
a n - 1 + (/n-2 becomes 0 = 0 + 0 and so is homogeneous, but an = (In- 1 + (n- 1) 
becomes 0 = 0 + n - 1 and is consequently inhomogeneous. 
Question 2.6. 
Which of the recurrence relations of Questions 2.3 and 2.4 are 
.homogeneous and which inhOJ;nogeneous? 
Our only suggestion for solving inhomogeneous recurrence relations is the 
method of iteration and induction. If that fails, then it is time to consult a book 
specializing in recurrence relations. 
349 

7 
RECURRENCE RELATIONS 
How well does iteration and induction work on homogeneous recurrence 
relations'? Let's try to use it to obtain the formula for the Fibonacci numbers 
knowing that they satisfy (Cl with initial conditions a1 = a2 = 1. Since iln - 1 = 
an - 2 + an - 3 , and an -2 = (/n-3 + an - 4 , we substitute these into (C) to obtain 
(El 
No formula is yet apparent, so let's keep substituting in the right-hand side of (E) 
using 
and 
We get 
(/n - 2 = an - 3 + an - 4, 
an - 3 = an - 4 + an - 5, 
an = an - 3 + (/n-4 + 2(an -4 + an -5) + (/n-5 + an - 6 
= (/n-3 + 3an -4 + 3an - 5 + an -6' 
Still no formula has emerged, although the coefficients seem familiar. In fact, con-
tinuing in this vein never leads to the correct formula. 
In summary, we have learned one technique that sometimes obtains a formula 
for a sequence. Given a sequence we first find a recurrence relation that it satisfies. 
Then we try iteration and induction to derive a formula for the sequence and to 
prove it correct. This technique is most likely to work for inhomogeneous recur-
rence relations. In Section 5 we shall use this technique to solve recurrence relations 
related to algorithms from Chapter 6. If iteration does not work (easily!) on a 
homogeneous recurrence relation, then we can use the techniques of the next 
sections. 
EXERCISES FOR SECTION 2 
1. Write down three new recurrence relations and specify the number of initial 
conditions. Which are homogeneous? 
2. Here are two recurrence relations and initial conditions: 
(i) en = 2Cn _ 1 for n > I. c 1 = I. 
(ii) Un = Un - 1 -
Un - 2 for /I > 2, il, = L il2 = 2. 
350 

7:2 ITERATION AND INDUCTION 
For each. find different initial conditions that produce a sequence that i:; a 
subset of the original sequence. Then find initial conditions that produce a 
sequence that has no number in common with the original sequence. 
3. For each of the following, determine the number of initial conditions: 
(i) an = 2an - I an - 2 
(ii) an = an - 2 -
an - 3 
(iii) an = al + 2n 
{
3an/3 
if 3 divides II 
(iv) an = 
2a(n-I)/3 
if 3 divides (II -
1) 
a(n-2)/3 
if 3 divides (II -
2). 
4. Use iteration on each of the following recurrence relations to obtain a formula 
for the sequence they generate: 
(i) hn = 2hn - 1 for n > 1, hi = 1. 
(ii) en = en _ I + (211 -
2) for 11 > 1. e 1 = o. 
(iii) dn = 2dn _ 1 + 2 for 11 > 1, d1 = 1. 
(iv) en = en- I + (2n- 1) for n > 1, e l = 1. 
(v) j~ =j~_1 + 3n for 11 > l,fl = 3. 
(vi) Yn = Yn-l + k for n > 0 and k constant, go = 1. 
(vii) hn = hn- I + (_1)n+ 111 for n > 1, hi = 1. 
(viii) jn = (11 - 2);n-1 for j > 2,jl = S.h == 10. 
(ix) kn = (4n 2 -
211)kn - 1 for n > 0, ko = 1. 
(x) In = In-Iln- 2 for 11 > 2.11 = 12 = 2. 
(xi) mn = mn- I + (11- 1)2 for 11 > 1, m l = O. 
5. Prove by induction that your formulas in the preceding exercise are correct. 
6. Notice that if the formula for the nth term of a sequence is known, then it is 
easy to detect recurrence relations for the sequence. For example if an = n!. 
then an = nan- I' Explain why the following equations give a means of finding 
recurrence relations from formulas: 
an 
an = --an-I' 
Un - 1 
an = an- I + (an - an- d· 
7. Each of the following formulas generates an integer sequence. For each 'ind 
a recurrence relation that is satisfied by the sequence. 
(i) an = n(n -
I). 
(ii) an = 211 -
1. 
(iii) an = :n + 3n. 
(iv) an = 2n -
1. 
351 

7 RECURRENCE RELATIONS 
8. Find recurrence relations that are satisfied by the sequences formed from (he 
following functions: 
(i) an = n2 -
6n + 8. 
(ii) LIn = n!/IS!. 
(iii) an = n!/[15!(n -
IS)!J for n> 14. 
(iv) all = C), where j is a fixed integer between 0 and II. 
(v) an = 11 3 + 311 2 + 3n + t. 
9. Which of the recurrence relations in Exercises 2, 3. and 4 are homogeneous 
and which inhomogeneous? 
10. Sometimes iteration works on homogeneous recurrence relations. Use this 
technique to find formulas satisfying the following: 
(i) an = an - 1 for 11 > 1, Lll = 1. 
(ji) hn = 2hn - 1 for /I> 1, /)1 = 2. 
Then prove that your formulas are correct. 
11. At the end of this section we saw that the Fibonacci numbers satisfy all the 
following equations: 
FII = FII - 1 + F,,-2' 
FII = F,,-2 + 2FII - 3 + 1',,-4' 
and 
Find a similar expression for F II in terms of FII _ 4' F" _ 5' ... , FII _ 8' Then for 
k, an arbitrary positive integer less than n, lind and prove a formula that 
expresses FII in terms of F" _ k and smaller Fibonacci numbers. 
12. 
(i) Suppose that Tn = Tlnl2J + 2 for II> I, Tl = I. If 11 is a power of 2, use 
iteration to deduce a formula for Til" Is this formula also valid for values 
of 11 that are not powers of 2? If so, prove your result if not, tind and 
prove a formula that is valid for these values of II. 
(ii) Repeat for Sn = 2SI"121 for 11 > \, SI = 1. 
(iii) Repeat for Vn = 2VIII/ 21 + 2 for 11 > \, U 1= 2. 
13. Given II lines in the plane no two of which are parallel and no three of which 
intersect in a point, how many regions do these lines create"! 
14. Let H,,=Hn-t+H,,-z+1 for 11>2, HI=H2=1. Find H3,.··,Hp,. 
Guess a relationship between Hn and Fn, then prove it by induction. 
15. Let Qn = QII-l + QII-2...j.. 2 for 11 > 2, QI = Q2 = 1. Find Q3,'" ,Q8' Gues> 
a relationship between Q" and PII , Ihen prove it by induction. 
352 

7:3 
LINEAR HOMOGENEOUS RECURRENCE RELATIONS 
7:3 LINEAR HOMOGENEOUS RECURRENCE 
RELATIONS WITH CONSTANT COEFFICIENTS 
The title of this section is a mouthful that describes the kind of recurrence relatlOn 
that the Fibonacci numbers satisfy. 
Definition. 
A recurrence relation of the form 
for 11 > r, 
tA) 
where k l' k 2" .. , kr are constants is called a linear homogeneous recurrence relation 
with constant coefficients. We denote these by LHRRWCC. We assume that kr #- 0 
and call r the order of the recurrence relation. 
Here's what all these words mean. First linear refers to the fact that every 
term containing an ai has exactly one such factor and it occurs to the first power. 
We introduced homoyeneo!ls in the previous section. The words (onstant COt-jji-
cients mean that each of the ki s is a constant. Tn contrast. the recurrence relation 
an = (/; _ 1 is not linear although it is homogeneous. and the recurrence relation 
bn = nbn _ 1 does not have constant coefficients. but it is a first-order linear homo-
geneous recurrence relation. 
The sequences S2 and S6 satisfy first- and second-order LHRRWCCs, re-
spectively: 
S::. : 2, 4, 8, 16 •... 
S6: 1,3.7,15,31, ... 
for n > 1 
an = 3an - 1 -
2an - 2 
for 11 > 2. 
(By the way, can you now guess a formula for the 11th term of 56"? If not, try 
comparing S6 with S2') 
Question 3.1. 
Which of the following arc LHRRWCCs'? For those that are ;1Ot. 
explain why they fail to satisfy the definition. 
(i) Un = an _ 1 -r 1 for 11 > l. 
(ii) an = a n - 4 (/n-2 for /1 > 4. 
(iii) (/n = all _ 1 + /12 for II > l. 
Given a sequence that satisfies a LHRR WCe. we can find an explicit formula 
for the 11th term of the sequence. The derivation seems magical, so we begin by 
working out the details for the sequences S::. dnd S6' 
Example 3.1. 
The sequence S2: 2, 4.~, 16, ... ;atisfies the recurrence relation 
all = 2an - 1 
for IJ > L 
(8) 
353 

7 
RECURRENCE RELATIONS 
a first-order LHRR wee, and also satisfies the formula all = 2n. Note that 2 i~. 
the root of the equation 
x - 2 = o. 
It is also a root of the equation obtained from the previous one by multiplying 
every term by x" - I: 
x" - 2X"- 1 = 0 
or 
x" = 2xn - l . 
(C) 
Notice the similarities between (B) and (e). One involves subscripts and as 
while the other involves superscripts and x s. Is this coincidence? 
Example 3.2. 
The sequence S6:1,3,7,15,31, ... satisfies the second-order 
LHRRWee 
n > 2, 
(0) 
and has nth term' formula 
a difference of two exponentials. Now 2 and 1 are roots of the equation 
(x - 2)(x -
1) = () 
or 
x2 -
3x + 2 = O. 
Multiplying by x"- 2, we get 
xn _ 3xn - I + 2xn - 2 = 0 
or 
xn = 3X"- 1 _ 2xn - 2 . 
(E) 
Again, notice the similarities between equations (D) and (E). These are not hy 
chance. We turn now to the theory that connects LHRRWees, polynomial equa-
tions. and their roots. 
354 

7:3 
LINEAR HOMOGENEOUS RECURRENCE RELATlOI'S 
Given a LHRRWee (A) we create the corresponding equation 
v" _ k v" - 1 _ k v" - 2 _ ... _ k v" - r = 0 
., 
1·' 
2-' 
I"'· 
Next we divide through by the common factor xn - r to get 
(F) 
Why do we do this? Because (F) will be helpful in solving (A). 
Definition. 
Given a LHRR wee (A), the equation (F) is called the characteristic 
equation of the recurrence relation. The left-hand side of the characteristic equation 
is a polynomial (often called the characteristic polynomial) whose degree equals 
the order of the recurrence relation. This polynomial has r roots q b Q2,· .. , qr 
(either real or complex numbers) called the characteristic roots of the recurrence 
relation. 
Notice that no characteristic root qi is zero. This is because we assume in (A) 
that kr is not zero. Thus x = ° is not a root of (F). 
Example 3.2 (continued). 
Using the recurrence relation for S6: 
we form the characteristic equation as follows: 
xn = 3xn - 1 _ lxn - 2 
xn _ 3xn - 1 + 2xn - 2 = ° 
x 2 -
3x +:::. = 0, 
which is the desired equation. [n this case we easily find the characteristic roots, 
since (as we saw before) 
x 2 -
3x + :::. = (x -
I.)(x -
2). 
Thus the characteristics roots are Lll = 1 and (/2 = 2. 
Question 3.2. 
For each of the following LHRRWees find the characteristic equa-
tion and the characteristic root or roots: 
(i) Lln = 2an _ 1 
(ii) an = Lln -
1 + 6an - 2 
(iii) an = 2an- 1 c- Lln- 2· 
355 

7 RECURRENCE RELA nONS 
The next theorem demonstrates that the results of Examples 3.1 and 3.2 were 
not just coincidence. 
Theorem 3.1. 
Let q be a nonzero real or complex number. Then 
is a solution (also called a basic solution) to the recurrence relation (A) if and only 
if q is a characteristic root of the recurrence relation (i.e., a root of the characteristic 
polynomial). 
Proof. 
The sequence Un = qn is a solution to (A) 
if and only if 
if and only if 
n - r[ r 
k r - I 
k ] 
q 
q -
I if 
- ... -
r 
= O. 
Since q is not zero, the last equation holds if and only if 
r 
k r-l 
k 
0 
q -
lq 
- ... -
r =, . 
This last equation is true if and only if q is a characteristic root of the recurrence 
~~~ 
C 
Example 3.1 (continued). 
Sl :2, 4, 8,16, ... satisfies the LHRRWCC 
which has (from Question 3.2) the characteristic equation 
and characteristic root if 1 = 2. By Theorem 3.1, un = 2" is a basic solution to this 
recurrence relation, and that's just what we've known all along! 
Example 3.2 (continued). 
We can now find formulas that satisfy the recurrence 
relation 
(0) 
356 

7:3 
LINEAR HOMOGENEOUS RECURRENCE RELATIONS 
By the previous version of Example 3.2 we know that the characteristic roots of 
this recurrence relation are q 1 = 1 and (12 = 2. By Theorem 3.1 both a" = 1 n = 1 
and an = ::;n are basic solutions to the recurrence relation. But neither of these 
solutions gives a formula that generates the sequence given by 56' Notice, however. 
that if we were to use (0) with initial condition at = a2 = 1, then we would get 
the sequence 1,1,1,. ... and the formula for this is clearly all = Ill. If we were to 
use the initial conditions a 1 = 2 and (/2 = 4. then we would get ::;,4, 8, ... and the 
formula for this is a" = 2". the other formula uncovered by Theorem 3.1. The point 
is that had the initial conditions been different than they are in 56' we might have 
found the generating formula. We have more work to do in this example. 
Our goal is to find a formula for a sequence generated by a given recurrence 
relation with any set of initial conditions. The technique will be to combine basic 
solutions. 
Theorem 3.2. If j~ and gil both satisfy the recurrence relation (A), then for any 
constants c and d so does 
Proof. 
Since f and g are each solutions to (A), we have that 
j~ = klj~- 1 + ... + krj~-r' and 
gIl = ktgn- 1 + ... + krYn-r' 
If we multiply the first equation by c and the second by d and then add them, we 
get 
cf~ + dYn = C[klj~-l + ... + krJ~-rJ 
+ d[k1Yn- 1 + ... + kryn-rJ 
= kl[cf~-l + dqn-l] + ... + kr[cf~-r + a'qn-r], 
and this shows that an = C/;, + dqn is a solution to (A). 
More generally, it can be proved by induction that if f~ J~, ... J~ are all 
solutions of (A), then so is 
for any constants (" 1" .. ,c,. (See Exercises 14 and 15.) In this event Un is said to 
be a linear combination of the fs. Usually, the Is will be basic solutions. 
357 

7 RECURRENCE RELATIONS 
Example 3.2 (continued again). 
Theorem 3.2 says that the basic solutions a" = 1 
and an = 2n to the recurrence (D) can be combined so that an = c I + d2" is also 
a solution for any constants c and d. To produce a formula that yields the specific 
sequence 
S6:1,3, 7,15,31, ... , 
we need to find the correct values of c and d. The sequence S6 comes with the 
initial conditions at = 1 and a2 = 3. We use this information to find c and d. If 
the correct formula for this sequence is given by an ,= c I + d2
1l
, then we must have 
I = a l = C + d2 1 = C + 2d, 
and 
3 = az = C + d2 2 = C + 4d. 
If we subtract the tirst equation from the second, we get 2 = 2d. From this d = 1 
and then c = - 1. Thus an = 2n -
1 is a formula that meets the initial conditions 
and gives a solution to the recurrence relation. 
Question 3.3. 
Prove by induction that an = 2n -
I satisfies the recurrence relation 
an = 3an - 1 - 2an - z with initial conditions a l = 1 and az = 3. 
Here is a summary of when the procedure followed in Example 3.2 works. It 
does not succeed in all cases. Given a recurrence' relation as in (A), we tind the 
characteristic equation 
r 
k 
,.-1 
X -
\ X 
- ... -
kr = 0. 
The general theory of equations tells us that this equation has r real or complex 
roots, and so the equation can be factored into 
Ix - q\)(x - qz)' .. (x -
qr) = 0, 
where ql>q~, ... ,qr are the roots. For example, we might get, 
(x -
I)(x -
2) = 0, 
(x -
3)(x -
3)(x - 4) = 0, 
or 
(x -
i)(x + i) = 0, 
where i is the imaginary number, V - I. In the first and third examples the roots 
are distinct, but in the second example the root 3 appears twice. It is then called 
a multiple root and the root 3 is said to have multiplicity 2. It turns out that we 
must treat the two cases differently. 
358 

7;3 LINEAR HOMOGENEOUS RECURRENCE RELATIONS 
Theorem 3.3. 
Suppose that the LHRR wee as shown in (A) has r distinct cbar-
acteristic roots q l' qz, . .. ,qr· Then every solution to (A) is a linear combination 
of the basic solutions: 
(G) 
The proof of this theorem essentially requires knowing that if all the roots of 
(F) are distinct, then it is possible to solve r equations in r unknowns to lind 
the constants C l' cz, ... 'Cr. The equations are determined by substituting )1 = 
1,2, ... ,r into (G). We see 
a 1 = clql + czqz + ... + crqr 
2 
2 
Z 
az = Clql + czqz + ... + crqr 
In these equations the unknowns are c 1' ... ,c,. A complete proof of Theorem 3.3 
requires knowledge of linear algebra and so is omitted. 
Sometimes (like now) the arithmetic involved in solving for the constantf (' l' 
('2' ... 'Cr will be simplified if we consider sequences that begin with a zeroth term, 
Any sequence can be transformed into this type by working backward with the 
recurrence relation to find a value for ao that is consistent. For example, look at 
Example 3.2. Since 
we want the value of ao to be such that 
or 
3 = 3·1 - 2ao. 
If we give ao the value of 0, then the sequence 
s~:o, 1,3,7,15,31,. .. 
satisfies the same recurrence relation but with initial conditions ao = ° 
and a 1 = 1. 
It also has the same formula an = 2n -
I. By beginning at 0, the arithmetlc in 
solving r equations in r unknowns might be easier. This can be especially ;':00-
venient when doing small examples by hand. 
359 

7 
REClJRRENCE RELATIONS 
Question 3.4. 
Suppose the recurrence relations in Question 3.1 have the following 
initial conditions: 
(i) a1 = 1. 
(ii) ai = 2 for all i :s; 4. 
(iii) a1 = 1. 
In each caSe determine a value for ao that satisfies the same recurrence relation. 
Example 3.3. 
The Fibonacci formula (at last!). Let's use the machine we've just 
built to discover the formula for the Fibonacci numbers that appeared out of the 
blue in Section 4.4. These numbers satisfy the recurrence relation 
for 11 > 1 
with initial conditions (/0 = 0 and (/1 = 1. The characteristic equation of the 
LHRRWCC is 
.'(2 _.'( _ 1 = 0, 
and this has distinct characteristic roots lil = (1 + . ./5)/2, which we called (p, and 
(j2 = (1 - y5)/2, called <jJ'. Thus the general formula that solves this recurrence 
relation is 
an = c C-+2 ,./5)" + d C---=~ J5)" 
= C(pn + d(<jJ')n 
for some constants c and d. Notice that this looks like the Fibonacci formula 
we had earlier, but we need to determine the constants c and d from the initial 
conditions. (Here's where beginning at 0 makes life easier.) 
0= ao = c<jJ° + d(<jJ')o = c + d 
I = (/1 = Upl + d(<jJ')l 
1 + ..)5 
I -
)~; 
= c --- + d -----
~ 
~. 
-
-
From the first equation we get that c = -d. Substituting into the second equa-
tion, we get that 
c= 
and 
360 
-1 
d= 
y5 

7:3 LINEAR HOMOGENEOUS RECURRENCE RELA nONS 
In conclusion we have the formula for the Fibonacci numbers as 
Question 3.5. 
For each of the following recurrence relations find the formula for 
the sequence of numbers generated if the characteristic equation has distinct roots. 
(These are recurrence relations from Question 3.2.) 
(i) an = an- 1 + 6an- 2 for II > I, ao = 2, a 1 = 1. 
(ii) an = an _ 1 + 6an _ 2 for 11 > I, ao = 1, a 1 = 3. 
(iii) an = 2an _ 1 -
an _ 2 for n > I, ao = 2, a 1 = -
1. 
In the next section we consider LHRRWCCs whose characteristic equations 
have multiple roots. The techniques will be similar. 
EXERCISES FOR SECTION 3 
1. 
(i) Give an example of a LHRRWCC. 
(ii) Give an example of a linear homogeneous recurrence relation with co-
efficients that are not constant. 
(iii) Give an example of a linear recurrence relation with constant coefficients 
that is inhomogeneous. 
(iv) Give an example of a homogeneous recurrence relation with constant 
coefficients that is not linear. 
2. Which of the following are LHRRWCCs? For those that are not. explain 
why they fail to satisfy the definition. 
(i) lin = 2an _ 1 for 11 > 1. 
(ii) Un = 2an _ 1 + 1 for n > 1. 
(iii) a" = U,,-4 -
an -
2 for /1 > 4. 
(iv) an = U~_I + 3an -2 for n > 2. 
(v) an = an- 1 + Ut for 11 > 1 and u t a constant. 
(vi) a" = an- 4 - (/n-3 + 1In- 2 - an - 1 for 11 > 4. 
(vii) (/n = 6an- 1 -
lla,_ 2 + 6an_ 3 for 11 > 3. 
For each LHRRWCC determine its order and find its characteristic 
equation. 
3. Ld f(x) be the fourth degree polynomial 
f(x) = (x -
l)(x + 2)(x -
3)(x + 4). 
What are the roots of f? Are they distinct? 
361 

7 RECURRENCE RELATIONS 
4. Find LHRRWees with each of the following characteristic equations: 
(i) f(x) = (x -
l)(x + 2)(x -
3). 
(ii) g(x) = (x + 3)(x -
3). 
(iii) h(x) = (x -t)(x + ~). 
5. Find a cubic polynomial whose roots are 5, - 1, and 3. Then tind a 
LHRR wee with this characteristic polynomial. 
6. 
(i) For the LHRRWCC of the preceding exercise find initial conditions such 
that an = 5n is the formula for the sequence produced by the recurrence 
relation. 
(ii) Repeat part (i) finding initial conditions for the formula an = 5n + ( - 1)" 
(iii) Repeat part (i) finding initial conditions for the formula an = 5n + 
2( -1)" - 3n. 
7. Prove that the quadratic equation 
-b + ,/b2 - 4c 
has roots ------
2 
x 2 + bx + c = 0 
and 
-b-,Ih2~ 
2 
8. Find a formula for the roots of the equation 
.'(4 + bx 2 + c = o. 
9. Suppose that the recurrence relations in Exercise 2 have the following initial 
conditions. Find values of ao that satisfy the same recurrence relation. 
(i) a1 = o. 
(ii) a1 = 1. 
(iii) al = a'2 = 1, a 3 = a4 = 2. 
(iv) at = - L a2 = - 2. 
(v) at = 3. 
(vi) a1 = t, a2 = -1, a3 = -~La4 = 1. 
(vii) al = 1, (12 = 2, a 3 = 4. 
10. Find the characteristic equation and characteristic roots of the following 
362 
relations: 
(i) an = 4an- 1 -
4an- 2 • 
(ii) an = - an - 1 . 
(iii) an = 5an- 2. 
(iv) an = -8an - 3 . 
(v) an = 2an- 2 - an- 4 . 
Which of the above relations have distinct roots and which have multiple 
roots? 

7:3 LINEAR HOMOGENEOUS RECURRENCE RELATIONS 
11. Is the following statement true or false? 
If both an = j~ and Un = qn are formulas that satisfy a given linear inho-
mogeneous recurrence relation with constant coefficients, then so is all = 
c j~ + d qn for every choice of constants c and d. 
Either explain why this is true or find a counterexample. 
12. If possible, for each situation listed give an example of a fourth-degree poly-
nomial with 
(i) Four distinct roots. 
(ii) Two distinct roots, one of which has multiplicity one and the other 
multiplicity three. 
(iii) Exactly two distinct roots, one of multiplicity one and one of multiplicity 
two. 
(iv) Two distinct roots, each of multiplicity two. 
(v) One root of multiplicity four. 
(vi) One root of multiplicity two and one root of multiplicity three. 
13. Find a recurrence relation that is satisfied by both 
(i) an = 1 and an = 3n, 
(ii) Un = (- l)n and an = 2", 
(iii) an = 2n and an = 3 . 2n + 2 . 3n. 
14. Prove that if j~, gn and hn are three functions that each satisfy 
then for any constants L. d, and e, the function 
Sn = cj~ + d gn + e hn 
also satisfies this recurrence relation. 
15. Prove by induction (onj) that iff~ J;, ... ,f~ are j functions that each satisfy 
then for any constants ('1,(2"" ,Cj, the function 
also satisfies this recurrence relation. 
16. Find a formula for a function an that satlsfies the following recurrence rela-
tion with given initial conditions: 
(i) an = -(/n- t for 11 > 0, Uo = 1. 
(ii) an = 4an- 2 for 11 > 1, ao = 0, (/1 = I. 
(iii) an = -i'Sun- J for 11 > 2, Uo = u t = a= = 1. 
363 

7 RECURRENCE RELA nONS 
17. The recurrence relation a" = (/,,_ 1 + an - 2 -
Lin - 3 with ao = 2, a 1 = Land 
(/2 = 4 has characteristic roots t and - 1. Show that the generating formula 
is not of the form 
j~ = cl n + d( _ 1)". 
18. The Lucas numbers are defined by L 1 = 1. and 
Ln = FII + 1 + F,,-l 
[orn>l, 
where Fn is the nth Fibonacci number. Find the first eight Lucas numbers. 
Find a recurrence relation for the Lucas numbers and then find a formula for 
Lno 
19. Is the following proof correct? Explain your answer. 
Theorem. 
For all positive II. Ln = F1l' 
Proof' (hy induction): Ll = F J = 1. 
Assuming that the result is true for 
It ::; k, we examine Lk -j- 1 : 
Lk + 1 = Lk + Lk - 1 
= Fk + Fk - 1 
= Fk + 1 
from the recurrence relation found in Exercise 18 
by induction 
by definition. 
20. Suppose that Til = 12Tn _ 1 -
35Tn - 2 for n> 1 while To = 0 and Tl = ') 
Find a formula for Til' 
21. How many II-bit binary sequences have no two consecutive zeros'? 
22. 
Suppose that the second floor of the firehouse has two poles to the first floor. 
Suppose that every higher floor of the firehouse has five poles. Two of these 
poles go down one floor while the remaining three poles go down two 1100rs. 
If you slide down a pole that goes down two noors. you cannot get off at the 
intermediate floor. How many different ways are there to get from the /lth 
/ioor to the first floor? 
7:4 LHRRWCCS WITH MULTIPLE ROOTS: 
MORE ABO UT RABBITS 
We reconsider the rabbit breeding model from Chapter 4 that led to the Fibonacci 
numbers. Suppose that each pair of newborn rabbits produces exactly one pair 
of bunnies after one month and this is all of their offspring. If rabbits are still 
assumed to be immortal. how many pairs of rabbits are there at the end of each 
364 

7:4 LHRRWCCS WITH MULTIPLE ROOTS: MORE ABOUT RABBITS 
month? Let the number of pairs of rabbits at the end of 11 months be denoted by 
hn. Thus hI = L he. = 2, h3 = 3 (since only the younger pair produces a new pair 
of bunnies), and h4 = 3 + (3 -
2) = 4. In generaL the number of rabbit pairs at 
time 11 equals the number of pairs at time (11 -
1) plus the number of new bunny 
pairs produced in the year (11 -
1). Thus 
h" = /)" - 1 + (b" - 1 -
hi.,- 2) 
for 11 > 2, 
a second-order LHRRWee with initial conditions bl = 1 and /)2 = 2. 
Question 4.1. 
Give an inductive proof that h" = 11. 
Although we have the solution to this rabbit problem, we continue the exam-
ple, since it illustrates the case of LHRRWees with multiple roots. The recurrence 
relation (A) is a LHRR wee whose characteristic equation is 
Xl -
2,X + I = 0 
or 
Thus I is a root of multiplicity 2, and from Theorem 3.1 we know that hn = \" ,= \ 
is a basic solution to (A). This does not satisfy the initial conditions of the current 
problem. Since there are no other roots to the characteristic equation, it must be 
the case that the solution to the recurrence takes a form different from that of :he 
previous section. Here is the pertinent result for characteristic equations 'With 
multiple roots. 
Theorem 4.1. 
Suppose that the following LHRRWee has a characteristic root 
q of multiplicity 111 > 1: 
for 11 > 1'. Then the following are (basicl solutions to (8): 
an = q" 
an = I1qtl 
an = 112q" 
(8) 
Note that each root of (8) supplies as many basic solutions as its multiplicity. 
Thus there will be a total of /' basic solutions to (B\. Once again the number of 
basic solutions equals the order of the recurrence relation. 
365 

7 
RECURRENCE RELATIONS 
Proof'. 
We prove the result for In = 2. Theorem 3.1 gives that all = q" is a solution 
to (B). Thus we must show that 
is also a solution. If t(x) denotes the characteristic polynomial of the recurrence 
relation (B), set p(x) = t(x)x"- r . Thus 
() 
n 
[k 
/I -
I 
k 
II - 2 
k 
II - rJ 
P X = X-I X 
+. 2X 
+ ... + rX 
. 
Since q is a root of mUltiplicity 2 for t(x), the characteristic polynomial, q is also 
a root of multiplicity 2 for pix). Set 
pix) -
p(q) 
D(x) = 
. 
x-q 
(For those of you with a calculus background, D(x) is the difference quotient that 
leads to the derivative.) Since q is a root of pix), the quantity p(q) is just a fancy 
way to write zero. Furthermore, since q is a mUltiple root of p(x), when we divide 
(x - q) into p(x) we are left with a polynomial that still has q as a root. Thus 
D(q) = O. This is the heart of the proof. What is left is an algebraic rearrangement 
of D(x) after which we substitute x = q and find that an = n' q" is a solution of (B). 
First we collect the terms from Dix) that have the same exponent to get: 
x" - q" 
xn - I _ (t - 1 
D(x) = ---- - kl ~~~~- - ... 
x-q 
x-q 
n-j 
n-j 
- k
X 
-
q 
I 
X _ q 
(e) 
Question 4.2. 
Construct D(x) if pix) = x 2 -
2x + l. Be sure to leave the charac-
teristic root as q (rather than substitute its value). Simplify D(x) by dividing x -
4 
into each term. (Here n = r = 2.) 
We simplify (C) term by term. From Exercise 5 in the Supplementary Exer-
cises for Chapter 2 (or by multiplying out the right-hand side), we note that 
Notice that there is a convenient factor of x - q in the above expression and that 
the exponents of each term sum to 11 -
I. Thus 
-" 
n 
~_-=-.!{_ = x" - I + ... +\" - I - ; (/ + ... + (/' - I . 
(E) 
X -
(I 
366 

7:4 LHRRWCCS WITH MULTIPLE ROOTS: MORE ABOUT RABBITS 
The right-hand side of (El is just one term in the expansion of D(x). We eventually 
want to compute D(q), so we substitute x = q into the right-hand side of (E) just 
to see what happens. Every term becomes q"- 1. Since the exponent on x decreases 
from 11 -
1 to 0 in steps of 1, there are 11 terms and so the total contribution from 
(E) will be I1qn - 1. 
Next we simplify the general term in (C): 
n-j 
n-j 
k 
k x 
- q 
-
-
j 
[ 
11- j 
11- j] 
-
j--~------
x 
-q 
x-q 
x-q 
-kJ. 
[n-'-l 
1I-'-I-ii 
J 
= -- (x _ q) X 
) 
+ ... + X 
) 
q + .... 
x-q 
(F) 
Notice that there is a convenient factor of x - q in this expression and that 
the exponents of each term sum to 11 - j -
1. As above we substitute x = q into 
the right-hand side of (F). Every term becomes qn- j -l. Since the exponent on x 
decreases from 11 - j - 1 to 0 in steps of 1, there are 11 - j terms and so the total 
contribution from (F) will be 
(G) 
Thus D(q) contains a term (G) for each j with 0 :::;; j :::;; r. Since D(q) = 0, we get 
O 
n-1 
[k( 
1)"-" 
k( 
.)n- j -l 
] 
= I1q 
-
1 n -
q 
- + ... + j n - } q 
+ . .. . 
We multiply both sides of (H) by q and rearrange the terms to obtain 
Finally, (Il is the same as (B) after substituting 
. n-j 
an - j = (n - j)q 
(I) 
for j = 0, .... r. Thus an = nqn is a solution to the original recurrence relatIOn. 
We stop the proof of Theorem 4.1 with the completion of the case In = 2. For 
m > 2 a proof using calculus is outlined in Supplementary Exercises It) and 20. 
Example 4.1. 
We analyze the rabbit recurrence (Aj. The characteristic equation is 
Ix -
1)2 = 0, 
367 

7 
RECURRENCE RELATIONS 
so by Theorem 4.1 both h" = 1 and hn = Ill" = IJ are basic solutions to this recur-
rence relation. The initial conditions hi = 1 and b2 = 2 show that the second 
solution, b" = 11, is exactly the one we want. 
Question 4,3. 
Find the characteristic equation and root or roots of the second-
order recurrence relation 
b" = 4h,,_1 - 4h,,_2 
for Il ?: 2. 
Check that both hn = 2" and hn = 172" are solutions to this. 
Question 4.4. 
Show that the characteristic equation of 
for II ?: 3 
has - 1 as a characteristic root of multiplicity 3. Check that each of Cn = ( - 1 )". e" = 
n( -
1)11 and CII = 1l2( -
1)11 is a solution to this recurrence relation. 
Example 4.1 (altered). 
Suppose that we want to solve the recurrence relation 
given in (A) with initial conditions hi = 1 and h2 = 3. As before, both h" = 1 and 
h" = n are basic solutions. Theorem 3.2 (which isn't restricted to recurrence rela-
tions whose characteristic roots are distinct) tells us that 
is also a solution for all constants c and d. Using the initial conditions. we lind that 
I = hi = cl + ell 
3 = h2 = C 1 + d2. 
Subtracting the first equation from the second. we deduce that 
c = -1, 
d = 2. 
and 
h" = 2n -
1. 
Question 4.5. 
Find a solution to the recurrence relation of Question 4.4 with 
initial conditions ao = 1. a 1 = - '2 and (/2 = l. 
Finally, we reach the generalization of Theorem 3.3 (which we also do not 
prove). 
Theorem 4.2. 
Given a 
sequence S:al"" ,(l"" .. whose 
terms 
satisfy 
a 
LHRRWCC of order r, then an is a linear combination of the r basic 'iolutions 
given by Theorems 3.1 and 4.1. 
368 

7:4 LHRRWCCS WITH MULTIPLE ROOTS: MORE ABOUT RABBITS 
Example 4.2. 
Suppose that we have a recurrence relation of order 6 ISO ,. =" 6 
and the characteristic equation has degree 6) and suppose that we (luckily) find 
that the characteristic equation factors as 
fix) = (x - l)\, + Ir~(x -
17). 
Then by Theorem 4.1 we have the following basic solutions to the recurrence 
relation: 
I" 
1" 
21" 
all = 
,an = 11. all = IJ 
, 
all = ( - 1 )", all = n( -- 1)", 
and 
Using Theorem 4.2, we see that every solution is of the form 
an = cil + C211 + C3/1 2 + c4(-I)" + c5/1(-I)" + co l7". 
In a concrete situation we would use the six initial conditions and solve six equa-
tions to find ('I"" ,CO' 
Exercises 9 through 12 present other variations of the rabbit-breeding model. 
However. the study of LHRRWCCs has not been developed for the interest of 
rabbit breeders. There are important uses of recurrence relations in combinatorics 
and in computer science. Often the complexity analyses of recursive algorithms 
lead to recurrence relations that must be solved. In the next section we'll meet a 
type of recurrence relation that occurs frequently in the "divide-and-conquer" 
algorithms. 
EXERCISES FOR SECTION 4 
1. Write down equations of degree 2, 3, and 4. each with a multiple root. 
Specify the root and its multiplicity. Then write down an equation that has 
one root of multiplicity I. one root of muitiplicity 2. one root of multiplicity 
3. and no other roots. 
2. Which of the following equations have multiple roots'? 
(i) fix) = x 2 -
1. 
(ii) t'ix)=x 2 +2x+ I. 
(iii) /(x) = x 2 + X -
12. 
(iv) {(x) = x 2 -
6x + 9. 
( 
"( 
+..,.: 
I 
v) / x) = x -.;.x + . 
(vi) fix) = x+ + 2X2 + I. 
(vii) fix) = x+ + 2x J -
3x':: - 4x + 4, 
369 

7 RECURRENCE RELATIONS 
3. For each of the functions in Exercise 2 write down a recurrence relation with 
characteristic equation fix) = O. Then find a formula that satisfies the recur-
rence relation. 
4. Show that the recurrence relation 
an = lOan - t - 40an - 2 + 80an - 3 - 80an - 4 + 32an 5 
has the characteristic equation (x - 2)5 = O. Then check that an = 2", an = n2"_ 
an = n22n, an = n32n and an = n42n all satisfy the recurrence relation. 
5. For each of the following, find a recurrence relation with initial conditions 
that has this as a solution: 
(i) an = 3n + n3n. 
(ii) an = 3n + 2n3n. 
(iii) an = 2n -
1 + 2n. 
(iv) an = 1 + ( - I)n + 2n. 
(v) an = 4(W + 8n(W· 
6. For each recurrence relation in list A find its characteristic equation in list B: 
370 
List A 
(i) an = San - 2 + 4an - 4' 
(ii) an = 7 an - 1 -
17 an - 2 + 17 an - 3 -
6an - 4' 
(iii) an = 8an- 1 -
23an-2 + 28an- 3 -
12an_4 · 
(iv) an = 9an- 1 - 29an-2 + 39an-3 -
18an_ 4 · 
(v) an = 6an- 1 -
13an-2 + 12an-3 - 4an- 4 · 
(vi) an = 5an- 1 - 9an-2 + 7an -3 -
2an - 4 · 
(vii) an = 7an - 1 -
18an-2 + 20an -3 -
8an- 4 ·, 
List B 
(a) f(x) = X4 -
x 3 + x 2 -
X + 1. 
(b) fix) = (x - l)(x - 2)(x - 3)(x -
4). 
(e) fix) = X4 + IOx 3 + 25x 2 + 20x + 4. 
(d) fix) = X4 -
8x 3 -
23x2 -
28x -
12. 
(e) fix) = X4 -
8xJ + 23x 2 -
28x + 12. 
(f) fix) = (x -
l)2(,\: -
2)2(X - 3). 
(g) fix) = (x + 1)2(x + 2)2. 
(h) f(x) = (x + I )2(X -
2)2. 
(i) f(x) = (x -
1)2(x -
2)2. 
(j) fix) = x4 + 7x J + 18x2 + 20x + 8, 
(k) fix) = (x -
1 )(x -
2)3, 
(l) fix) = (x -
l)(x -
3)2, 
(m) f(x) = Ix - 1 )3(x -
2). 
(n) fix) = X4 + 7x 3 _ 17x2 + 17x - 6. 

7:4 LHRRWCCS WITH MULTIPLE ROOTS: MORE ABOUT RABBITS 
(0) fix) = (X -
1)(x + l)(x - 2)(x + 2). 
(p) fix) = (x -
1)2(x - 2)(x - 3). 
(q) fix) = (x -
1)(x - 2)(x - 4f. 
(r) fix) = (x - 2)(x - 3)(x - 4)2. 
(s) 
fix) = (x - 2)(x - 3)2(X - 4). 
',t) 
fix) = (x -
2)2(x -
3)(x - 4). 
(u) fix) = (x -
1 \(x - 2)(x - 3)2. 
Then for each recurrence relation in list A find the most general form of a so-
lution to it. 
7. Use Theorems 4.1 and 4.2 to find solutions as general as possible to the 
following recurrence relations: 
(i) Un = 2an - 1 -
un - 2' 
(ii) un = 3an - 1 -
3an - 2 + an - 3' 
(iii) an = 4an - 1 -
5an - 2 + 2an - 3' 
8. Find a formula for the solution of the following recurrence relations: 
0) an = 3an- 1 - 3an- 2 + an- 3 for n > 4 with ao = a1 = a2 = 1. 
(ii) an = 4an- 1 -
5an-2 + 2an 3 for n > 4 with ao = 3, a1 = 4 and az = 7. 
9. Suppose that at the end of each month a rabbit pair produces a pair of 
bunnies, but that after two sets of offspring they produce no more. Write 
down the recurrence relation with initial conditions that describes this model, 
beginning with one pair. 
10. Suppose that at the end of one month a rabbit pair produces one pair of 
bunnies, but that during the next month the (older) rabbit pair dies. Beginning 
with one pair, write down the number of rabbit pairs at the end of each month 
for the first five months. Then write down a recurrence relation for the num-
ber of rabbit pairs at the end of each month. 
11. Suppose that at the end of each month a pair of rabbits produces one new 
bunny pair, but that rabbits die during their third month after having pro-
duced bunnies twice. Write down the recurrence relation that decribes '.his 
model and the initial conditions assuming that we begin with one pair. 
12. We return to the original Fibonacci model ofrabbit breeding: A pair of rabbits 
requires a month to mature to the age of reproduction and then they mate 
and produce two bunnies. We now do not assume that these are one male 
and one female, and furthermore we assume that whatever sex they ar~, a 
mate is found for each from another warren of rabbits. Thus at the beginning 
of the first and second months we have one pair, but at the beginning of the 
third month we have three pairs of rabbits, one old and two new young pairs. 
How many pairs do we have at the beginning of the fourth and fifth months? 
Write down a recurrence relation with initial conditions that describes this 
model. 
371 

7 
RECURRENCE RELATIONS 
13. For each of the following determine whether a" = 0(2") and whether 2" = O( a"): 
(i) a" = 2a"_1 - a"-2, al = I, a2 = 2. 
(ii) a" = 2a" _ l' a 1 = 1. 
(iii) u" = 4a"-1 - 4a,,-2, ao = 0, al = 2. 
(iv) a" = an-I + a,,-2- UI = a2 = 1. 
14. Is the following true or false? Explain. 
A formula (/" that satisfies a LHRR WCC will always be exponential in 
17: that is, there wtll always be constants 1 <: r <: s such that r" = O(an ) and 
an = O(S"). 
15. Find solutions to the following recurrence relations: 
an = 4an - I -
an _ 2 for 11 > 1 with aa = ° 
and a 1 = 1. 
bn = 4hn - 1 - hll _ 2 for 11 > 1 with ha = 2 and hI = 4. 
16. Prove by induction that the sequences a" and b" of Exercise 15 satisfy 
and 
7:5 DIVIDE-AND-CONQUER RECURRENCE 
RELATIONS 
The goal of this section is to formulate and solve recurrence relations that generate 
the complexity functions of divide-and-conquer algorithms like the searching and 
sorting procedures from Chapter 6. 
Example 5.1. 
In the algorithm BINARYSEARCH we are given an ordered array 
of length 11 and an element 5 to search for. We begin by comparing 5 with the 
middle entry of the array. If these are not equal, we search half of the original 
array. This leads to the recurrence relation 
BII = 3 + 81nl21 for II > 1, 
8 1 = 4, 
(A.) 
where Bn denotes the maximum number of comparisons needed ill BINAR Y-
SEARCH with input an array of 11 elements. (Reread Section 6.2.) 
1 For an application of Ihe results of Exercises 15 and 16 10 the Lucas-Lehmer test for Mersenne 
J1f1mes. see D. E. Knuth. Seminumerical Ali/or/thms. Volume 2 of The Art ot" CompUler Prowamminq, 
Addison-Wesley, Reading. Mass .. 1973. J1p. 356 - .159. 
372 

7:5 
DIVIDE-AND-CONQUER RECURRENCE RELATIONS 
Question 5.1. 
Explain why (A) is a recurrence relation for Bn. Use (A) to obtain 
Bn for II = 2, 3, 4. and 5. Compare these numbers with the derived complex tty 
result, 3Llog(II)J + 4. 
Example 5.2. 
The idea behind BININSERT is similar to that of BINARY-
SEARCH. The input to the procedure is an array of 11 + 1 entries with the first 
11 in increasing order. The goal is to insert the (/I + 1 )st entry into the correct 
position of the array. Again we compare with the middle entry and then search 
half of the array. We repeat this process until we find the correct position. After 
shifting elements, the (11 + l)st entry is inserted in the correct position. 
This leads to the recurrence relation 
Cn = C1n!21 + 2 for n > L 
C 1 = 4, 
(B) 
where Cn is the number of comparisons performed by BININSERT on an array 
of length n. [Reread Section 6.3 to remind yourself why (B) is the recurrence 
relation for Cn-J 
Example 5.3. 
In the algorithm MERGESORT we begin with an unsorted list of 
n elements, divide the list in half, sort each half, and then merge the two parts. 
Thus if M n denotes the number of comparisons performed in the worst case of 
MERGESORT, then in the case that n = 2k 
Mn = 2Mn/2 + (311 + I) for n > 1. 
Ml = 1, 
(C) 
gives the recurrence relation for Mn-
Question 5.2. 
Explain why (C) is a recurrence relation for M n- Use (C) to obtain 
Mn for n = 2.4. and 8. Compare these numbers with the complexity bound derived 
for the case 11 = 2k. namely 311 log (/7) + 211 -
I. 
Each of the above algorithmic problems is solved by dividing it into smaller 
problems. solving the smaller problems and then combining these solutions; we 
have called these divide-and-conquer algorithms. Suppose that an is the number 
of steps in the worst case of a divide-and-conquer algorithm. Then (/In!21 or (/tn/dl 
gives the maximum number of steps needed to solve a problem of half or one !lth 
the size. The number of steps needed to solve some or all of the smaller problems 
plus the number needed to combine these solutions into a final one is given by a 
so-called divide-and-conquer recurrence relation like 
an = k atnldt + en + e. 
(0) 
where c, d, e. and Ii. are constants. We shall not solve the most general version of 
(0); however. the text and the exercises contam the most important cases. 
373 

7 RECURRENCE RELATIONS 
Question 5.3. 
Find constants to show that (A), (B), and (C) are special cases of 
(D). 
Question 5.4. 
Suppose that we have the recurrence relation 
How many initial conditions must be specified before this relation gives a value 
for all positive values of n? Then using the recurrence for an' specify a set of initial 
conditions and determine the resulting values of an for all n ::; 7. 
Notice that the presence of the floor function in these recurrence relatiom 
could lead to some computational awkwardness. For instance, if we want to show 
that Bn = 3Llog(n)J + 4, then working with B ln/2 ] would require consideration of 
two cases depending on the parity of n. One way to avoid this problem is to 
consider the special case of n = 2i (or n = di) and then to try to generalize the 
solution to the arbitrary case. 
Example 5.4. 
Consider a recurrence relation of the form 
where c is a constant. We'll try iteration and induction, since this is an inhomo-
geneous recurrence relation, and we'll experiment with the special case when II = 2i. 
since n/2 is an integer 
= at + ie 
= at + log(n)e. 
Question 5.5. 
Prove by induction that an = at + log (n)e is a solution of the 
recurrence relation an = (/[nI21 + c if 11 = 2i. 
Example 5.4 worked out nicely using iteration because we assumed that Il = 2
J
, 
and it seems reasonable to conjecture that this bound is correct for all values of 
11. Thus we attempt to prove the same result for arbitrary n by induction. To avoid 
374 

7:5 
D1VIDE-AND-CONQUER RECURRENCE RELATIONS 
problems with the floor function, we'll shift now to inequalities. That is, we lise 
the fact that LxJ :::; x. This will lead to upper bounds on the solution function, like 
Bn :::; 3Llog (nlj + 4; however, such an upper bound is often satisfactory, since it 
leads to big oh results, like Bn = O(log (n)). 
Theorem 5.1. 
If Un is the nth term of an integer sequence that satisfies 
where c is a constant, then 
Proof. 
(We do not assume that n is a power of 2.) The base case holds with n =: 1: 
The inductive hypothesis is that 
for all 11 < k, and we try to obtain the same bound for Uk' We know that 
Uk = (/lk/21 + c 
:::; c 110g ( L k/2 j) j + a 1 + c 
:::; c Llog (k/2)j + al + c 
= cLlog(k) -
lj + (/1 + C 
= cLlog(k)j - c + (/1 + C 
= cLlog(klj + £1 1, 
by induction 
since L k/2 J :::; k/2 
Notice that we obtain a slightly smaller bound by using Llog (k)j in place of 
log(k). 
Example 5.1 (concluded). 
When the results of Theorem 5:1 are applied to the re-
currence relation [or Bn with c = 3, and Bl = 4. we have that Bn :::; 3Llog(lI)j + 4 = 
O(log (n)), just as in Theorem 2.1 of Chapter 6. 
Question 5.6. 
Apply Theorem 5.1 to (B) and compare the result with that of 
Theorem 3.1 in Chapter 6. 
375 

7 
RECURRENCE RELA nONS 
The exercises ask you to solve a number of special cases of the generic divide-
and-conquer recurrence relation (0). Here is one more case that will yield an alter-
native analysis of MERGESORT. 
Example 5.3 (varied). 
Suppose that /1 = 2k for some integer k. Then the recur-
rence relation in (C) holds for MERGESORT: 
Mil = 2MII12 + (311 + 1), 
with M 1 = 1. 
Instead of solving the above recurrence, we consider an inequality version: 
(C') 
since (3/1 + 1) ::S: 4n for 11 ;::: 1. This will be easier to solve and will lead to an upper 
bound on l'vln- In the next theorem we solve a more general form of recurrence 
relation of which this is a special case. 
Question 5.7. 
Use iteration and induction to verify that for the case n = 2k, Mil ::S: 
4n log (n) + AI 1/1 satisfies (C). 
More generally, if we use a divide-and-conquer algorithm that solves d smaller 
problems each of which is (l/dth) of the original, then the complexity analysis 
might involve a recurrence relation of the form 
or 
(E) 
where c and d are constants. d > 1. Manipulation of (E) is simplified if we use the 
logarithm to the base d, denoted by logd' 
Theorem 5.2. 
If e and Ii are constants with d > 1 and 
a" ::S: d alnld] + en. 
then 
Proof. 
We prove this by induction on 11. For the base case we have that al S 
() + a l I. We assume that the theorem is true for all 11 < k and we examine a". 
376 

7:5 
D1VIDE-AND-CONQUER RECURRENCE RELATIONS 
~ d [C l 
~ }Ogd (l ~ J) + all ~ JJ + ck 
~ d[CO}Ogd0) + al (~) J + ck 
= cklogd (~) + alk + ck 
= ck [logd(k) -
IJ + a l k + ck 
= cklogd(k) + a l k. 
by induction 
. lkJ 
k 
smce d ~ d 
by algebra 
by properties of logd 
by algebra 
[] 
Example 5.3 (last thoughts). If Ii = 2 and c = 4, Theorem 5.2 gives the following 
bound on the complexity of MERGESORT. 
Mn ~ 4nlog(n) + n. 
Note that the recurrence relations (C) and (C) and hence this bound hold only 
when n = i. You should check that this is a larger upper bound than that of 
Theorem 7.1 from Chapter 6. 
In the most general divide-and-conquer recurrence relation 
we have just seen that if k = d and e = 0, then an = O(n log (n)). Exercise 11 demon-
strates that if k < d, then an = O(n). In contrast Exercise 12 shows that if k > d. 
then an = O(nq), where q = logd (k). Thus the complexity of a recursive procedure 
is quite sensitive to small changes in the constants. 
EXERCISES FOR SECTION 5 
1. Suppose that ao = I is the initial condition for each of the following rt:cur-
renee relations. Then list the first five terms of the sequence generated. 
(i) an = (/[n!2\ + 1. 
(ii) an = il[nI3\ -
l. 
(iii) Un = al nI 5\. 
(iv) an = 2a\n/2\' 
(v) an = 3atnl31 + 1. 
(vi) an = u\n/41 + 1. 
(vii) an = 5a\nI5\ -
Il. 
(viii) an = a lnl 3\ + 3n. 
377 

7 RECURRENCE RELA TrONS 
2. How many initial conditions are needed for each of the following recurrence 
relations'! 
(i) an = a1n/ 2j + (lln/4j' 
(ii) an = a1n/4j + 1. 
(iii) an = a n - 1 + aln/ 2 j' 
(iv) an = an - 2 + a[n/2j' 
3. 
(i) Suppose that hn = 2hlnl2j + s, where s is a constant. Use iteration and in-
duction to solve this recurrence relation in the case that n = i. 
(ii) For arbitrary n find an upper bound on hn-
4. Consider the recurrence relation an = a1n/dj + c, where C and d are constants, 
d> 1. Show that if n = el', then an = a1 + c!ogd(n). What happens for arbi-
trary It? 
5. Suppose that n = di, d > 1. Use iteration and induction to deduce that the 
recurrence relation 
is satisfied by 
Then explain why 
(
C) 
C 
an = a 1 + --
n -- --. 
d-l 
el-l 
6. Given the recurrence zn = k Zlnldj with el > 1, solve for Zn-
7. Explain why Theorem 5.2 and the preceding exercises contain the condition 
that d > 1. 
8. Why is the following not a valid proof? 
378 
Theorem. If an is the nth term of a sequence that satisfies 
for some constants C and d with Ii > 1, then 
an = 0(11). 
Proo/'. 
We must show that an ~ SI) for some constant s. Let s = Lll so that 
the base case is met: Lll ~.>1 = (/1' Then assume that for alln < k, an ~ sn. 

7:5 
D1VIDE-AND-CONQUER RECURRENCE RELATIONS 
From the recurrence relation we have 
dsn 
<-+c 
-
d 
= sn + c 
= O(n). 
by induction 
9. Prove the Theorem of the preceding exercise (correctly). (Hint: Use the result 
from Exercise 5.) 
10. Use iteration and induction to find a function j~ such that an = O(f~) for each 
of the following: 
(i) an = k a[n/d] + c, where c, d, and k are constants such that ,i= d and 
1 < d. 
(ii) an = a[n/d] + log (n), where d is a constant greater than 1. 
(iii) an = d a[nldl + n2, where 1 < d. 
11. Show that if c, d, and k are constants such that k i= d, and 
then 
where s is a constant. 
12. Show that if an is as given in the previous problem and k < d, then 
an = O(n). 
13. For each of the recurrence relations in Exercise 1 find a function j~ such that 
an = O(f~). 
14. For each of the following recurrence relations decide whether an = 0(1), 
O(logn(n)), O(nl, O(niog(n)), 0(n 2 ) or 0(2"): 
(i) an = a[n/31' ao = 1. 
(ii) an = a[n/41 + L ao = 1. 
(iii) an = u{nld 1 -
1 for some constant d > 1, a o = l. 
(iv) an = 3aln131' ao = 3. 
(v) an = 3a[n;31 + 3, ao = 3. 
379 

7 RECURRENCE RELATIONS 
(vi) an = a[n(31 + 3n, ao = 1. 
(vii) an = 3a[n/31' ao = 2. 
(viii) an = 3a[n/31 + L ao = O. 
(ix) an = 3a[n(3J + n, ao = 1. 
(x) an = 2a[n/3J' (/0 = 1. 
(xi) an = 2a[n/3J + 1, ao = 1. 
(xii) an = 2a[n(3J -
1, ao = 1. 
(xiii) an = 4a[n/3J' ao = 1. 
(xiv) an = 4a[II/3J + 1, ao = l. 
15. Reread Example 1.5 and explain why SECRET is a good algorithm. 
16. Let the recurrence relation for P n be defined by 
for n > 1 with P 1 = C, some constant. Is this a LHRR WCC? If so, write down 
its characteristic equation. In any case, determine the first eight values of P n, 
in terms of c. Then guess and prove a formula for P n as a function of n 
and c. 
17. Here is the algorithm MAX from Exercise 4.12 of Chapter 2. Given an array 
of n real numbers, it tinds the maximum number and stores it in the variable 
max. 
Algorithm MAX 
STEP 1. Input n, a positive integer, and -'1, ... '-'j" .. ,-'n, real numbers 
STEP 2. Set max: = Xl 
STEP 3. Forj = 2 to n do 
STEP 4. If -'j > max then max: = -'j 
STEP 5. Output max and stop. 
Explain why MAX always make (n -
1) = O(n) comparisons. 
18. In comparison with MAX, here is the idea for a recursive divide-and-conquer 
algorithm to find the maximum entry in an array of 11 numbers. If the list 
has one element, then max equals this entry. Otherwise, we divide the list in 
half: 
380 
L 1 = Xl, ... '-'[nnl 
L2 = X[n/21+ [, ... ,X", 
Let ml be the maximum entry in LI and 1»2 the maximum in L 2 . Then we 
compare 1»1 and ml, and the larger is the overall maximum. If ,\1 n is the 
number of comparisons performed using this idea on a list of length II. then 

7:6 
RECURRING THOUGHTS 
find a divide-and-conquer recurrence relation that Mn satisfies. What are the 
values of M [, .... A{ s? 
19. Solve the recurrence relation of the preceding exercise. (Hint: first let n = :k. 
Otherwise, use the trick of MERGESORT to extend the array to one with 
2k entries.) Is this algorithm more efficient than MAX? 
7:6 RECURRING THOUGHTS 
In this chapter recurrence relations have come up in the definitions of integer 
sequences, in mathematical models. and in the complexity analysis of algorithms. 
With naturally specified initial conditions, the goal is to find a formula (or at 
least an upper bound) for the nth term of the sequence. Once we have found such 
a formula, then it is not difficult to prove this result by induction. In fact. recurrence 
relations are ideally suited to inductive proofs. using either ordinary or complete 
induction, because they give the nth term as a function of preceding terms. Thus 
the hard question is generally to find the solution to the recurrence relation. 
The first commonsense approach is to use iteration. This technique works 
well on inhomogeneous recurrence relations, especially on the divide-and-conquer 
recurrence relations. In general, it does not work so well on homogeneous recur-
rence relations. 
For the special case of linear homogeneous recurrence relations with constant 
coefficients, we have presented a complete solution using characteristic equations 
and their roots. In theory, we can find the solution of any LHRRWCC. 
The general technique used to solve LHRRWCCs is an important one with 
wider application in mathematics. We look for "basic" or "Iinearly independent" 
solutions and combine them in "linear combinations" to derive all possible s,)lu-
tions. This technique is used whenever the underlying mathematical structure is 
a "linear space." For example, the field of linear algebra deals with the solution 
of homogeneous systems of linear equations, and the field of differential equatlons 
studies the solution of linear homogeneous differential equations. It is not by 
chance (or bad planning) that the same words appear repeatedly in different fidds; 
the underlying ideas and solution techniques are really the same. 
Iteration and induction is the technique of choice for the divide-and-conquer 
recurrence relations. Typically, we use iteration on a simplified case, as when 11 ,= :k 
or 11 = dk , and then lind that the resulting formula gives a bound for a solution 
of the general recurrence relation. We can solve lJr get tight upper bounds on 
essentially all recurrence relations of the form 
where c, d, e, and k are constants. These techniques will also work on other, more 
irreguiar recurrence relations. 
J8J 

7 RECURRENCE RELATIONS 
SUPPLEMENTARY EXERCISES FOR CHAPTER 7 
1. Let L be the list of all positive integers that begin with a 7, listed in increasing 
order. Write down the first 12 entries of L. Can you (within. say. 5 minutes) 
find a formula L" that give the 11th entry of L as a function of n? 
2. Suppose that n points are placed around a circle and that every pair of points 
is joined by a line. either straight or curved. but drawn so that at most two 
lines cross each other at the same point. Into how many regions is the interior 
of the circle divided? Call this number R". Does R" = 2" - 1 for all positive n? 
3. Let S" be defined by S" = S" 
1 + 1 /n2 for n > 1, with S 1 = 1. Use iteration 
and induction to find a formula for S". 
4. Let SR" be defined by SR" = SR"_ 1 + 1/ In for n> 1, with SRl = 1. Find 
and justify a formula for SR". 
5. Refer to the definitions of S" and SR" in the preceding exercises. Which of 
the following are true and which false'! Justify. 
(i) S" = 0(1) 
(ii) SR" = O( 1) 
(iii) 1 = O(S") 
(iv) 1 = O(SR") 
(v) S" = O(log (n)) 
(vi) SR" = O(log (n)) 
(vii) log(n) = O(S") 
(viii) log(n) = O(SR") 
(ix) S" = O(n) 
(x) SR" = O(n) 
(xi) Il = O(S") 
(xii) n = O(SR") 
6. The Towers of Hanoi puzzle consists of a board with three pegs rising from 
the base. On one peg there are six circular disks of differing size. The largest 
disk is on the bottom and the others are stacked above it in order of decreasing 
size. These disks are to be transferred, one at a time, onto another peg so 
that at no time is a larger disk placed above a smaller one. What is the 
minimum number of moves needed to move the six disks? 
7. We consider the abstract n-fold Tower of Hanoi puzzle in which we suppose 
that n disks are stacked on one peg and must be moved to another peg, 
as described in Exercise 6. Let H" denote the minimum number of moves 
required to transfer the 11 disks. Then HI = 1 and H 2 = 3. Find a recurrence 
relation that expresses H" in terms of H" _ l' the number of moves needed 
to move the top (n -
I) disks. Then find a formula for H" and prove that it is 
correct. 
382 

SUPPLEMENTARY EXERCISES FOR CHAPTER 7 
8. Suppose that we consider a variant on the Tower of Hanoi puzzle in which 
there are four pegs with 11 disks stacked on one peg. Let I'v! n denote the mini-
mum number of moves needed to move the stack of n disks to another peg. 
Calculate M n for 11 = 2, 3, 4, and 5. Do these values agree with those of H n'? 
Find a recurrence relation for Mn and find as small a function J;, as possible 
such that M n = O(j~). 
9. Explain why the polynomial 
has a root s if and only if p(x) can be factored as 
p(x) = (x -
s)q(x), 
where q(x) is a polynomial of degree (r -
1). [Hint: Suppose that when pix) 
is divided by (x -
s), q(x) is the quotient and r(x) the remainder. In other 
words, pix) = (x - s)q(x) + r(x).] 
10. The complex (or imaginary) number i has the property that 
Explain why (_i)2 = -\ and (-i)i = + 1. What is the value of i3. (_i)3. i4 
and ( 
i)4? In' general, what is the value of i 2n - 1, ( _ i)2n - 1, i 2n and ( _ i)2n.) 
11. (i) The sequence 2,0, - 2,0,2,0, - 2, 0, ' , . satisfies 
Use the methods of Section 3 to find a formula for the 11th term of ,his 
sequence. By inspection we can see that the following is also a formula for 
the nth term of the sequence: 
Do these agree? 
r 
2 
fn = 1 ° 
1-" 
if 4 divides 11 
if 4 divides (11 -
\) or (n -
3) 
if 4 divides (n -
2). 
(ii) Repeat the problem in part Ii) with the sequence 
J,3i, -1, -3i, \,3i, -I, -3i, ... 
What formula can you derive for this by inspection? Does it agree with your 
formula obtained through a recurrence relation'? 
383 

7 
RECURRENCE RELATIONS 
12. A generalized Fibonacci number is defined as follows: For k a fixed integer 
greater than 2. 
F~ = F~ _ 1 + F~ - 2 + ... + F~ - k 
for n;:;: k 
with initial conditions F~ = F1 = ... = F~ _ 2 = 0 and F~ _ l = l. 
(i) For k = 3. 4, and 5 write out the first 10 generalized Fibonacci numbers. 
(ii) For k = 3, 4. and 5 find the characteristic equation of F~. 
(iii) For k = 3 find the approximate values of the characteristic roots. 
13. 
(i) Let Yn denote the number of strings of length n. containing Os. Is and 
(-I)s with no two consecutive Is and no two consecutive (-1)s. Deter-
mine Yj , Y2 , and Y3 by listing all such strings. 
(ii) Find a recurrence relation for Yn- Then, if possible, solve it using the initial 
conditions found in part (i). 
14. Let an be the recurrence relation defined by 
for 11 ? 2 
with initial conditions (/0 = 0 and (/1 = 2. Find a formula for an expressed in 
terms of F n' the 11th Fibonacci number. 
15. For m a fixed positive integer, consider 
an = Un _ l + an _ 0 + (Il) 
-
In 
for 11 ? 2 
with initial conditions ao = 0 and a l = l. 
(i) For m = 5. find the first 10 entries of the sequence Un' Express each entry 
in terms of Fibonacci numbers. (Recall that (;~) is equal to 0 when m > II.) 
(ii) For arbitrary m. find a formula for Un' expressed in terms of F II , the nth 
Fibonacci number. 
16. Suppose that q = r/s is a rational number that is a root of 
where gcd (r, s) = I and where h. c, and d are all integers. Explain why s = 1 
and r is a divisor of d. Then explain why when searching for a rational root 
of a cubic equation of the form above. one needs to check only the divisors 
of d. 
17. Find all rational roots of the following equations. 
(i) xJ - 2x-' + x - 2 = O. 
(ii) .'(3 -i- .'(2 + .'( - 3 = O . 
.184 

SUPPLEMENTARY EXERCISES FOR CHAPTER 7 
(iii) X3 -
3X2 + 2x = O. 
(iv) X 3 + X 2 + X + 1 = O. 
(V) XJ -
4x2 + X + 6 = O. 
(vi) x 3 + 2X2 -
3x + 7 = O. 
18. Explain why every cubic polynomial has some real number as a root. 
CAVEAT. 
The following problems, 19 and 20, require some knowledge of calculus, 
specifically knowing how to find the derivative of a polynomial and the product 
rule. 
19. By definition we know that if s is a root of a polynomial p(x) of multiplicity 
m > I, then pix) can be factored as 
pix) = (x - stq(x), 
where q(x) is a polynomial. Prove that if s is a root of p(x) of multiplicity 
m > 1, then s is also a root of p'(x) of multiplicity (m -
1), where p'(x) is the 
derivative of pix). 
20. This exercise is a general proof of Theorem 4.1. If the LHRRWCC 
for n > r 
(A) 
.' has a characteristic root q of multiplicity m > 1, then the following are all 
solutions to the recurrence relation: 
an = qn 
an = nqn 
an = n2q" 
From the text we know that LIn = q" and LIn = nqn are solutions. 
CASE 1. 
We repeat the case where m = 2, since the technique here generalizes 
more readily than the one given in the text. Let pix) be the characteristic poly-
nomial of (A). Calculate the function xp'(X), where p'(x) is the derivative of 
pix). Show that q is a root of xp'(x) and determine its multiplicity. From this 
deduce that an = nq" is a solution to (A). 
CASE 2 (m > 2). 
Calculate the function x(xp'(x)'. Using the results of Ca~e 1, 
show that q is a root of this function and ti.nd its multiplicity. Then deduce 
that an = 1J2qn is a solution of (A). 
385 

7 RECURRENCE RELATIONS 
CASE 3 (m > 3). 
Let Pi(x) be the polynomial obtained from PIx) by i times 
repeating the process of taking the derivative of p(x) and mUltiplying by x, 
then taking the derivative of this new function and multiplying by x: 
P1(x) = Xpl(X), 
P2(x) = X(Xpl(X)J', 
and so on. Calculate P3(x) and P 4(X) starting with p(x) the characteristic equa-
tion of (A). Then write out the general form of Pi(X). Prove by induction on 
i that if q is a root of the characteristic equation of (A) of multiplicity m :2: i :2: 1, 
then q is a root of multiplicity (m -
i) of P;(x). From this deduce that for 
i = 1, ... ,m -
1, an = niqn is a solution of (A). 
21. Reread Exercises 6 to 8 about the Tower of Hanoi puzzle. Suppose as in 
Exercise 8 that the puzzle has four pegs with the disks on the first peg, and 
suppose that we move the disks as follows: 
(a) Move the top L n/2 J disks to the second peg, one by one following the 
rules of the puzzle. 
(b) Move all but the last of the remaining disks to the third peg by a legal 
series of moves. 
(c) Move the largest disk to the fourth peg. 
(d) Move the bottom half from the third peg to the fourth peg. 
(e) Move the top half from the second peg to the fourth peg. 
If H~ denotes the minimum number of moves needed to transfer n disks in 
this version of the Tower of Hanoi puzzle, then find a recurrence relation for 
H~ and solve for H~. 
'\IOTE. 
From Section 1 it seems that the odd-indexed Bernoulli numbers are zero. 
starting with B3 . Here is a sequence of exercises that shows why B2k ,.1 = 0 for 
k :2: 1. 
22. A function is called even if f(x) = I( - x) for all values of :(, Which of the 
386 
following functions are even? 
(i) f(x) = c, c a constant. 
(ii) f(x) = x. 
(iii) f(x) = x 2. 
(iv) f(x) = x 3 . 
(v) f(x) = X4. 
(vi) f(x) = .'(5 
(vii) f(x) = x2n. 
(viii) f(x) = x2n + 1 
(ix) fix) = 2x._ 
(x)f(x)=-v x . 

SUPPLEMENTARY EXERCISES FOR CHAPTER 7 
23. Prove that the function 
. 
x 
x 
j(x) = k~ - 1) + 2 
is even. 
24. An infinite polynomial of the form 
p(x) = Co + C1X + ... + cnx" + .... 
where Co. C b ...• Cn , . •. are constants, is said to be even if p(x) = p( - x). Ex-
plain why p(x) is even if and only if all the odd-indexed terms C1, C3,' .. ,e2k + 1 
are zero. 
25. Use the results of the preceding two exercises to explain why every other 
Bernoulli number starting with B3 is zero. 
26. One form of the so-called "Ballot problem" asks what the probability is that 
in an election between candidates A and B the number of votes for A always 
exceeds that for B until the last ballot is cast when the votes are tied. Suppose 
that a vote for A is denoted by + I and a vote for B by - 1. Then there must 
be an even number of voters, say 2m. We want to determine the number of 
strings of m + I sand m - Is such that every partial sum, from I to i < 2m is 
positive. Write down all such strings for m = I, 2, and 3. Then check that the 
number with a final tie is given by the mth Catalan number as defined in 
Question 1.7. 
NOTE. 
The Catalan numbers arise in a number of fundamental problems of com-
puter science including the problem of having a computer evaluate an arithmetic 
expression: Exercises 27 - 29 explore these connections. To a computer each of the 
operations +, -, *. /, and - is a "binary operation." Each operation require~ two 
numbers upon which to act. Parentheses tell us exactly which two numben are 
to be combined into one by each operation. 
27. Explain why the addition of parentheses makes a difference in the following 
expressions. 
(i) a - b -
c. 
(ii) x/y/z. 
(iii) r". 
28. Calculate the number of ways to parenthesize expressions with three, four. 
and five variables by listing all possibilities. Show that these numbers are 
given by the corresponding Catalan numbers. 
29. Suppose that we have an expression combining n variables. like 
387 

7 RECURRENCE RELATIONS 
where '? stands for one of the usual arithmetic operations. Show that the 
number of different parenthesizations of an expression with 11 variables satis-
fies the Catalan recurrence relation. 
30. Use the fact that 
_ 1 
(211 - 2) 
Cn ---
11 
11-1 
to derive a recurrence relation for CII in terms of CII ._ 1. using no other Catalan 
number. 
31. Show that 
for all positive 11. Is there a positive integer k such that CII = O(nk)? 
32. A tree is called a planted planar tree if one vertex of degree 1 is designated 
as the root r and then the tree is drawn in the plane. For example, the 
following diagram shows all different planted planar trees with 1, 2. and 3 
edges. Let PTn denote the number of different planted planar trees with 11 
edges. Determine PT4 and PTs, and for n = 1.2, ... ,5 show that PTII = C. 
1 
r 
r 
388 

8 
MORE GRAPH THEORY 
8:1 MINIMUM-DISTANCE TREES 
This chapter discusses five real-world problems that can be solved using graphs. 
Reflecting the current state of knowledge concerning graph algorithms, some of 
our problems have good solutions, while others have no known good algorithmic 
solution. In the latter case we present exponential algorithms. In Section 4 we 
present an approximation algorithm, that is, an algorithm that runs in polynomial 
time but doesn't necessarily give a best possible answer. 
Our first application is plowing snow off the streets of a city. We envision lwo 
problems. The first consists of clearing roads conpecting important city serVices 
along shortest routes. The second consists of findi~g a route that traverses every 
remaining street at least once but that is overall as short as possible. In a varia-
tion we seek a shortest route that visits a designated set of points in a city. As 
a fourth problem we design a program to position a laser bit to drill thousand, of 
holes in a sheet of material. Finally, we consider storage allocation in computer 
memory. 
To begin the first snowplowing problem, imagine that we are in charge of 
plowing the snow off the streets of a city all of whose essential services (c. g., 
police, fire protection, ambulance, and snowplow) are located in one building caJled 
City Hall. Within the city there are special facilities (e.g., hospitals and schools) 
that we would like to be able to reach with the: essential services. How should we 
plow the streets to enable our vehicles to reach the special facilities as quickly as 
possible? 
At first glance it seems reasonable to think of trees. In a tree every pair of 
distinct vertices is joined by a unique path. Here too it seems that we don't need 
more than one clear route joining different locations; however, a minimum-weight 
spanning tree (defined in Section 5.3) is not what we want. (See also Exercise 12.) 
389 

8 MORE GRAPH THEORY 
In particular, the snowplowing problem has a distinguished location, City 
Hall. Hence our graph model needs a distinguished vertex called the root. The 
remaining vertices of the graph correspond with principal intersections within the 
city. For simplicity assume that each of the special facilities is at one of these in-
tersections. Two vertices of the graph wiJl be joined by an edge if there is a direct 
road connection between the corresponding intersections. The weight attached to 
an edge will represent the length of that connection. Thus the resulting weighted 
graph models the streets of the city, and as a plan for emergency snowplowing we 
want a spanning tree of this graph with the property that the distance from the 
root to each of the special facility vertices along edges of the spanning tree is 
minimized. In fact, we find a spanning tree that contains a minimum-distance path 
from the root to every vertex. Such a subgraph is called a minimum-distance 
spanning tree. 
Here are precise formulations of ideas from the preceding paragraph. Recall 
from Section 5.3 that the weight of a path P, denoted by w(P), is the sum of the 
weights of all edges in P; we call this the length of P. Recall also that each edge 
of a weighted graph has positive weight. 
Definition. 
In a weighted connected graph G, the distance between two vertices 
x and y, denoted by d(x, y), is the minimum value of w(P), taken over all paths 
P from x to y. (Informally, the distance from x to y is the length of the shortest 
path between them.) A minimum-distance spanning tree in a weighted connected 
graph G with root r is a tree T such that for each vertex v of G, the length of the 
unique path in T from r to v equals d(r, v). 
Example 1.1. 
In Figure 8.1 we show weighted graphs G and H with root r, their 
minimum-distance spanning tree, and their minimum-weight spanning tree. Note 
that the two types of trees may differ. 
Problem. 
Given a weighted connected graph G and a root vertex r, find a min-
imum-distance spanning tree of G. 
Question 1.1. 
For each vertex v -# r in the graph shown in Figure 8.2, find the 
shortest path from v to r. Does the union of these paths form a minimum-distance 
spanning tree? Pick a different vertex for the root and find all shortest paths to this 
new vertex. Does the union of these paths form the same tree? 
There is a good algorithm to solve the minimum-distance problem, due to 
E. W. Dijkstra. It is not obvious that every connected weighted graph contains a 
minimum-distance spanning tree; it is conceivable that the union of shortest paths 
from r to different vertices contains a cycle. However, one consequence of Dijkstra's 
algorithm and the proof that it works is that minimum-distance spanning trees 
always exist. The fundamental idea is simple (and in a sense greedy). We shall 
390 

G 
Figure 8.1 
8:1 
MINIMUM-DISTANCE TREI~S 
x 
z 
Minimum-distance 
spanning tree 
4 
5 
Minimum-distance 
spanning tree 
'M 
3 
8 
4 
7 
5 
Figure 8.2 
6 
r 
4 
2 
x 
3 
Minimum-weight 
spanning tree 
2 
5 
Minimum-weight 
spanning tree 
z 
3 
6 
describe the algorithm informally and leave details of implementation to the 
exercises. 
Begin with the root r. If we examine the edges incident with r and select one 
of smallest weight, say e = (r, x), then the shortest path from r to x is the edge 
e, since we assume that all edge weights are positive. So far the minimum-distance 
tree consists of e and the vertices rand x. Next we want to extend this tree so 
that it remains a minimum-distance spanning tree for a subgraph of G. There are 
two kinds of edges that we might pick to add to the tree. We might select an edge 
of the form f = (r, y) or ?J = (x, z). Among the edges incident with r assume that 
f has minimum weight (other than el. Among the edges incident with x assume 
that g has minimum weight. A naive choice would be to select whichever of f and 
g has minimum weight. Unfortunately, this will not work in all cases. 
~91 

8 MORE GRAPH THEORY 
Example 1.2. 
Suppose that G is as in Figure 8. ;1. The first edge we choose is 
(r, x), since it has minimum weight. If we then select (x,':;) because its weight is less 
than the weight of (r, .:;), then the distance (within the tree) from r to z would be 
5. [n G the distance from r to z is 4. The minimum-distance spanning tree should 
consist of the edges (r, x) and (I', z). 
What we should do, instead of adding an edge of smallest weight, is to pick 
a new edge that creates a minimum-distance path to a new vertex. That is, we want 
to find an edge e = (y, z) such that y is in the minimum-distance spanning tree 
created so far. z is as close to the root as any vertex not in the tree, and a shortest 
path from z to the root ruses e and edges already in the tree. This idea is in-
corporated into step 4 of the following algorithm. 
Algorithm DIJ KSTRA 
STEP I. fnput the weighted graph G and the root vertex r [Assume that G 
is connected.: 
STEP 2. Set T:= [rl 
STEP 3. For j = 1 to V -
I do 
Begin 
STEP 4. Find z, a vertex in G -
T whose distance from r is minimum; 
let e be the edge from z to T in some minimum-distance 
path from z to r 
STEP 5. Set T: = T + z + e 
End 
STEP 6. Output T and stop. 
Step 4 in DIJKSTRA might raise a question. Suppose that z is a closest vertex 
of G -
T to r. How do we know that there is an edge e joining z to a vertex of 
T? Maybe the shortest path from z to r uses different vertices than those (so far) 
in T? That this problem will not arise is a conseq uence of the proof of Theorem 1.1. 
Example 1.3. 
We trace Dijkstra on the graph shown in Figure 8.3. See Table 8.1. 
u 
11 
w 
Figure 8.3 
392 

8: I 
MINIMUM-DISTANCE TREES 
Table 8.1 
--~----
Step No. 
j 
;: 
VITI 
E(T) 
-.~-~---~ 
2 
') 
{r} 
0 
4 
x 
5 
x 
{r, x} 
{(r,x): 
4 
2 
5 
2 
{r,x,s) 
{(I", x), (I", .Ill 
4 
3 
11 
5 
3 
tI 
[r, x, .I, u) 
[(r, x), (I", .I), (x, tI): 
4 
4 
v 
5 
4 
v 
[r . .'C, .I, u, v} 
((I". x), (I", .I), (x, U), (x. v)) 
4 
5 
IV 
5 
5 
IV 
1r. x, s, u, 1.\ w} 
{(r, x), (r. 5), (x, u), (x. vl, (t" IV): 
Note that when we have a choice, as between 11 and v in the third application of 
step 4, we may choose either vertex. 
Question 1.2. 
Given the weighted graph in Figure 8.4 with root r as shown, use 
DIJKSTRA to find the minimum-distance tree .. 
a 
5 
b 
4 
p 
q 
Figure 8.4 
Theorem 1.1. 
DIJKSTRA produces a minimum-distance spanning tree T 0' a 
connected weighted graph G with root r. 
Proof'. 
We must prove that T is a spanning tree and that for each vertex v of G 
the distance from v to the root r along the edges of T equals d(r, v), the length 
of a shortest path in G joining rand v. We prove by induction on I V(T)I that at 
each stage T is a tree containing a minimum-distance path from each vertex of 
T to the root r. Thus when DUKSTRA stops and IV(T)I = V = iV(G)I, T is a 
minimum-distance spanning tree. 
Example 1.3 (reexamined). 
Look at T after the: third completion of step 5. T con-
tains four vertices and three edges and is a minimum-distance spanning tree of lhe 
subgraph of G that contains the vertices {r, x, s, u} and the edges (r, x), (r, s) and (x. ul. 
393 

8 MORE GRAPII THEORY 
Initially, W(T)I = I since V(Tl = {r}. In step 5 we add the edge e = (r, x) of 
least weight and the vertex x to 1'. Then T is a tree with two vertices and one 
edge, and this edge provides the shortest path from x to r. Thus the base case is 
safely accounted for. 
Assume that T is a tree containing minimum-distance paths whenever I V(TlI < 
k, and suppose that I V(T)! = k. T received a kth vertex, say v, and a (k -
I )st edge, 
say e, in step 5. Then 1" = T - v - e was stored as T in the previous execution 
of step 5. Since 1" contains (k -
I) vertices, by the inductive hypothesis it is a tree 
that contains minimum-distance paths from each of its vertices to r. At the next 
occurrence of step 4, the vertex v in G -
T was selected as a vertex of minimum 
distance to r. Since v is not in T, the addition of v and e does not create a cycle 
and T remains acyclic. 
Suppose that P = <v, x, ... .r) is a minimum-distance path from v to r in G 
beginning with edge e. Since x is closer to r than v, x is in 1". Otherwise, DIJKSTRA 
would have selected x before v. Then we add v and e = (v, x) to 1", and T = 1" + 
v + e is acyclic and connected, hence a tree. Furthermore, the shortest path from 
x to r in 1" plus e will be a shortest path from v to r in 1'. (See also Exercise II.) 
This proves the inductive step. Thus the tree output by DIJKSTRA is a minimum-
distance spanning tree. 
0 
Question 1.3. 
Where in DIJKSTRA is the connectivity of the graph G essential? 
Find at least two places in the proof of Theorem 1.1 where we use the fact that 
edge weights are positive. What are the problems with running DIJKSTRA on 
the graph shown in Figure 8.5'1 
", 
2 
ro-----o 
-1 
-1 
Figure 8.5 
We now show that the complexity of DIJKSTRA is O(V' E). We need to per-
form comparisons and additions to find the minimum-distance paths; however, as 
in other graph complexity results we count only comparisons. The loop at step 3 
occurs V-I times. In step 4 we need to check at most E edges that join a vertex 
of T with one in G -
T to find the next shortest path and the vertex :. Thus there 
are no more than (V -
l)E comparisons needed in total. In Exercises 19 to 21 a 
more detailed version of DIJKSTRA is presented, and in that version we can see 
that only O( V) comparisons are needed within the equivalent of step 4 so that 
DIJKSTRA has an overall complexity of O(V2). This was the original complexity 
394 

8:1 
MINIMUM-DISTANCE TREES 
bound obtained by Dijkstra. There has been considerable interest in this minimum-
distance spanning tree problem, and variations of this algorithm using more 
sophisticated data structures have been developed, including one that has com-
plexity O(Elog(V)). 
With a slight change DIJKSTRA can be applied to unweighted graphs. Recall 
that distance in an unweighted graph has been defined to be the fewest number 
of edges in a path joining two vertices. (See Section 5.3.) Thus if we assign a 
weight of 1 to each edge of an unweighted connected graph and choose a root r, 
DIJKSTRA will find a minimum-distance spanning tree. In this context the result-
ing tree is known as a breadth-first-search (or BF'S) spanning tree. Notice that when 
DIJKSTRA is applied to an unweighted graph. first it "visits" and adds in to the 
tree T all vertices adjacent to the root r. Next it "visits" and adds in all vertices 
adjacent to vertices adjacent to r, that is, it "visits" all vertices at distance 2 frem 
r, and then successively "visits" all vertices at distance .i from r for j = 3,4, .... 
"Visiting" vertices in a graph in this order is known as breadth-first search. 
Example 1.4. 
Figure 8.6 shows a graph G and two BFS spanning trees of G. 
Working on the tree G with each edge weight L DIJKSTRA first adds edges (r,2) 
and (r,6) to the tree, since vertices 2 and 6 are at distance 1 from the root r. Next 
the vertices 3 and 5 at distance 2 from r are added to the tree; there is a choice 
of edges here. Finally, vertex 4 at distance 3 from r is added. Two possible breadth-
first-search spanning trees are shown in Figure 8.6. 
2 
3 
IT] 
6 
5 
G 
Figure 8.6 
4 
2 
3 
r 
2 
3 
rn r== 
6 
5 
4 
6 
5 
4 
One BFS spanning tree 
Another BFS tree 
Here is a breadth-fIrst-search algorithm, modeled upon DIJKSTRA. The set 
T contains the vertices and edges of the BFS tree. 
Algorithm BREADTHFlRSTSEARCH (BFS) 
STEP 1. Input the unweighted graph G and root r 
STEP 2. T:={r} 
STEP 3. For.i = 1 to V - I do 
STEP 4. For each vertex v in G -
T adjacent to a vertex at distance 
(j -
1) from r do 
STEP 5. Select w, one neighbor of v in T; 
set T:= T + (v,w) + v 
STEP 6. Output T and stop. 
395 

H MORE GRAPH THEORY 
Notice that when applied to a disconnected graph, BFS visits and constructs 
a spanning tree on precisely the vertices in the same component as the root r. In 
applications it is common for BFS to perform some calculation when it visits a 
vertex and to output more than just the spanning tree. Breadth-first search is an 
important algorithmic technique that will be used again in Section 5. 
EXERCISES FOR SECTION 1 
1. Find a minimum-distance tree for each of the following graphs. 
root 3 
7 
root 
5 
3 
4 
root 
4 
6aJ 
~ 
7 
11 
4 
3 
4 
2 
3 
5 
2 
5 
(a) 
(b) 
(c) 
2. There do not exist direct flights from Bradley Field to all other airports in 
the United States. If you wish to fly from Bradley to, for example, Eugene, 
Oregon, you will have to change planes at least once. The graph indicates 
some of the possible connecting flights that you might choose. The vertices 
of the graph are labeled with the names of the corresponding cities. An edge 
represents a direct flight between the two corresponding cities. The weight on 
the edge indicates the cost of the flight. Assume that the cost to fly from A 
Portland 
140 
Braclley 
Chicago 
r 
100 
110 
San 
San Diego 
396 

8: I 
MINIMUM-DISTANCE TREES 
to C changing planes at B equals the cost to fly from A to B plus the cost to 
fly from B to C. Find a minimum-cost trip from Bradley to Eugene. 
3. Rewrite DIJKSTRA so that upon input ofa weighted connected graph G and 
two vertices x and y, it finds a shortest path from x to y. Is your algorithm 
necessarily more efficient than (the original version of) DIJKSTRA? 
4. Find an unweighted connected graph G so that every spanning tree of G is a 
minimum-distance spanning tree for some choice of the root. 
5. Find a weighted graph G so that no matter what vertex is chosen for the root 
of G, the minimum-distance spanning tree is heavier than the minimum-weight 
spanning tree (i.e., for every vertex v the sum of the edge weights of a minimum-
distance spanning tree with root v is larger than the weight of a minimum-
weight spanning tree). 
6. Rewrite DIJKSTRA so that it finds a minimum-distance spanning tree if the 
graph is connected, or else reports that the graph is not connected. 
7. Here is a table of costs of some intercity flights; a zero indicates no direct 
flight. Find the cost of a cheapest trip between every pair of cities. 
c[ 
Cz 
C3 
C4 
Cs 
C[ 
100 
0 
150 
210 
C2 
100 
0 
90 
0 
C 3 
0 
0 
SO 
280 
C" 
150 
90 
50 
0 
Cs 
210 
0 
280 
0 
8. Run the unweighted version of DIJKSTRA on each of the graphs in Exerci~e 
1 with the edge weights discarded (i.e., run it on the underlying unweighted 
graphs.) 
9. A new commuter airline called Capital Cities offers flights between the capitJI 
cities of every pair of states that share a border. So, for example, there is a 
flight from Pierre, South Dakota, to Bismark, North Dakota, since these t\\O 
states share a common boundary. Each such flight costs $25. Using Capitdl 
Cities, what is the cost of a cheapest trip from Boston to Sacramento? Bismark 
to Trenton? 
10. Suppose that G is a weighted connected graph and that one path P = 
<x l' x 2,· .. , Xj, r) to the root is designated as top priority. Rewrite DIJKSTRA 
so that it finds a spanning tree that includes P. For every vertex v not in p, the 
algorithm should find as short a path from v to r as possible. 
11. Suppose that P = <x, J', ... ,r) is a shortest path from the vertex x to the root 
r. Explain why the same path, minus x and starting at y, <}" ... ,r), is a 
397 

8 MORfi: CRAPH THEORY 
shortest path from y to r. Suppose that PI is a shortest path from a vertcx x 
to a vertex;; and P 2 is a shortest path from::. to r. Is PI followed by P 2 a 
shortest path from x to r'! 
12. Suppose that a city wants a snowplowing plan to connect City Hall with cach 
of the designated special facilities; however, the plowing budget is greatly over-
spent. If the sole criterion for choosing plowing routes is that the total plowing 
cost should be a minimum, then cxplain why a minimum-weight spanning tree 
rather than a minimum-distance spanning tree: provides the best plan. 
13. Prove that at the end of the algorithm BFS precisely those vertices in the 
same component as the root r are contained in T. 
14. Rewrite BFS so that the vertices are assigned a number giving the order in 
which they become visited. (Note: This ordering is not unique but depends on 
arbitrary choices made within the algorithm.) 
15. Verify that BFS performs at most O( V2) comparisons given a graph with V 
vertices. 
16. Rewrite BFS so that it performs a breadth-first search on each connected com-
ponent of G. 
17. Construct a BFS algorithm that given a graph computes the eccentricity of 
every vertex. The eccentricity is defined in Exercise 5.4.14. 
18. The radius r(G) and diameter d(G) of a graph G are respectively the minimum 
and maximum value of the eccentricity (see the preceding exercise). Construct 
an algorithm that, given a graph G, outputs the radius and diameter of G. 
Show that d(G)/2 :S r(G) :S d(G) for any graph G. Find graphs to show that 
there are no better bounds than those given by the inequality above. 
19. Here is a detailed version of DIJKSTRA that specifies the equivalent of 
step 4. 
398 
Algorithm DIJ KSTRA2 
STEP 1. 
Input the weighted graph G and the root vertex r {Assume that G 
is connected.] 
STEP 2. 
Set d(r) = 0 {d(x) denotes the distance of x from the root in the 
partial tree. J 
STEP 3. 
Set V(T):= [r); E(T) = 0 [These will contain, respectively, the 
vertices and edges of T.] 
STEP 4. 
For j = 1 to V-I do 
Begin 
STEP 5. 
For each (t.x) in E(G) wIth t in VeT) and x 111 
V(G) -
VeT) do 
STEP 6. 
Set c(t. x) : = d(r) + w(t. x) 

8:2 
EULERIAN CYCLES 
{At this point crt, x) indicates the length of the path from r to x using a path 
in T together with the edge (I, x).) 
STEP 7. 
Set emin : = minimum value of crt, x) 
STEP 8. 
Set xmin and tmin equal to the vertices that achieve the 
minimum of step 7 
STEP 9. 
Set V(T) : = V(T) + Xmin 
STEP 10. Set £(T) : = E(T) + (tmin' Xmin) 
STEP 11. Set d(xmin) : = ('min 
End {step 4} 
STEP 12. Output E(T) and stop. 
Run DIJKSTRA2 on each of the graphs in Exercise 1. 
20. Explain why in DIJKSTRA2 when a vertex xmin and the edge (lmin' xmin) are 
added to the tree T, T is a tree containing a minimum-distance path from 
xmin to r. 
21. Count the maximum number of additions and comparisons performed in 
DIJKSTRA2 and show that each is 0(V2 ). 
22. In the remarks following DIJKSTRA's algorithm we asserted that there is an 
algorithm for the minimum-distance spanning tree problem that runs in time 
OrE log (V)). For what graphs is this a better bound than the 0(V2) com-
plexity bound that is obtained in the preceding exercise? 
23. Modify DIJKSTRA2 so that the shortest path from each vertex to r is main-
tained as well as the distance of that path. 
24. Using BFS construct an algorithm to check whether a connected graph is 
bipartite or not. (See Section 5.2 for the definition of bipartite. See also Supple-
mentary Exercise 10 of Chapter 5.) 
25. Modify DIJKSTRA so that for every pair of distinct vertices v and w in a 
weighted connected graph, the shortest path between v and wand its length 
is found. This is known as the All Pairs Problem. Show that the complexity 
of the All Pairs Problem is at most O( V) times the complexity of the minimum-
distance spanning tree problem. 
8:2 EULERIAN CYCLES 
We continue with snowplowing. To repeat the setting, suppose that a weighted 
graph is drawn to model city streets. Each vertex represents an intersection, and 
two vertices are joined by an edge if the corresponding intersections are joined 
by a direct road connection. The weight of an edge is the length of the road. The 
problem is to plow the streets efficiently (or if. as in the preceding section, certain 
streets are already clear, to plow the remaining streets efficiently). More precisely, 
~99 

8 
MORE GRAPH THEORY 
the problem is to devise a plan to travel along each unplowed street at least once 
in as short a trip as possible, beginning and ending at City Hall. Of course, it 
would be most efficient to plow the streets with no repetitions. Is this possible, and 
if so, how can such a plan be found? 
Example 2.1. 
Consider Figure 8.7. The graph G contains it cycle {for example 
(r,x,c,y,x,b,a,r») that traverses every edge exactly once. Although the graph H 
contains no such cycle, it does contain the path (r., 11, S, u, r, s) that traverses cvery 
edge exactly once. The graph I is a 3 x 2 grid graph. In Chapter 3 we saw that 
it was impossible to traverse each edge of this graph exactly once. 
a 
b 
c 
u 
s 
[2] 
x 
y 
v 
G 
H 
I 
Figure 8.7 
Definition. 
A path or cycle that includes every edge of a graph exactly once is 
called Eulerian. A graph that contains an Eulerian cycle is called an Eulerian graph. 
Question 2.1. 
(a) Find an Eulerian graph with four vertices. (b) Find a graph with 
eight vertices that is not Eulerian but contains an Eulerian path. (c) Find a con-
nected graph with six vertices that does not contai.n an Eulerian path. 
The problem of characterizing the graphs that contain Eulerian paths led to 
the first graph theory paper, written in 1736 by Leonhard Euler. Euler was visiting 
Konigsberg, a town with seven bridges and demonstrated that it was impossible 
to take a walk crossing every bridge exactly once, 
Question 2.2. 
Which of the graphs in Figure 8.8 are Eulerian? Which contain 
Eulerian paths but not Eulerian cycles? 
o rn ITIJ 
Figure 8.8 
400 

8:2 
EULERIAN CYCLES 
Theorem 2.1 (Euler's Theorem). 
A connected graph is Eulerian if and only if every 
vertex has even degree. 
Euler's theorem tells the snowplow planners that they can plow each street 
exactly once if and only if an even number of streets comprise every intersection. 
Note that one can think of an Eulerian cycle as starting and ending at any vertex, 
in particular City Hall. Our proof of Euler's theorem will lead to an efficient algo-
rithm for finding Eulerian paths and cycles. Then we shall consider ways to modify 
this algorithm to be useful in diverse settings. 
Proof of" Euler's theorem. 
First notice that an Eulerian graph must be connected. 
Let C be an Eulerian cycle in a graph G. Pick an arbitrary vertex of G, say x. We 
can assume that C begins at x, leaving on an edge, say e l' and at some point 
returns to x on, say ez. If that is the end of C, then deg(x) = 2, an even number. 
Otherwise, C leaves x again on, say e3, and later returns on, say e4' Each time 
that C leaves x on an edge ei, it returns on a different edge ei+ l' Since the edges 
at x can be paired, el with ez, e3 with e4 , and so on, there must be an even number 
of them. Thus deg (x) is even. Since x was chosen arbitrarily, every vertex of G 
must have even degree. 
Next we prove the converse, that a connected graph with all vertices of even 
degree contains an Eulerian cycle. We prove this by induction on V. If V = I, 
then the graph contains no edges and vacuously satisfies the conclusion. A con-
nected graph with V = 2 consists of one edge and so does not have vertices of 
even degree. If V = 3, then the only connected graph with all vertices of even 
degree is the 3-clique, K 3 , and this graph contains an Eulerian cycle. 
Question 2.3. 
Find every connected graph with four or five vertices all of whose 
degrees are even. Show that each such graph is Eulerian. 
Assume that every connected graph with fewer than k vertices all of whose 
degrees are even contains an Eulerian cycle. Let G be a connected graph with k 
vertices ali of even degree. Pick a vertex, say x .. and create a path P beginning at 
x. Extend P, appending incident unused edges at its end, until this is no longer 
possible. We claim that P is a cycle, ending at x. Since every vertex of G has eyen 
degree, when P arrives at a vertex v =1= x there is always an unused edge on which 
to leave v. Thus P must end at x; hence we rename P as C, since it is a cycle If 
C traverses every edge of G, then it is the sought-after Eulerian cycle. 
Example 2.2. 
Consider the graph shown in Figure 8.9. The cycle C' = <r. 2. 5, 6. r) 
can be extended further at r. The cycle C = <r, 2, 5, 6, r, 7.8, r) cannot be extencled 
further at r; however, C is not an Eulerian cycle. 
~Ol 

8 MORE GRAPH THEORY 
7 
6 
5 
4 
tlJL1 
8 
2 
3 
Figure 8.9 
If C is not an Eulerian cycle, then we construct G' from G by erasing all edges 
of C. Since C is a cycle, we erase an even number of edges at each vertex. Since 
all vertices had even degree originally, their degree remains even in G'. In G' the 
vertex x has degree o. Thus each connected component of G' contains fewer than 
k vertices and is consequently an Eulerian graph. 
Question 2.4. 
Let C be as in Example 2.2. Identify the graph G' obtained by 
deleting the edges of c. 
If H is a component of G', there is a vertex h of H that is also in C, since G 
was connected. By the inductive hypothesis an Eulerian cycle D can be found on 
H, beginning and ending at h. Then the original cycle C can be extended by 
inserting D at the vertex h. This extension can be done for each component of G'. 
The resulting cycle will traverse every edge of G and so is an Eulerian cycle. 
0 
Example 2.3. 
In the graph shown in Figure 8.10 let C = <r, 6, 7, r) and let H be 
the component consisting of the four vertices {3, 4,5, 6} and their incident edges. 
Then with h = 6 let D = <6,3,4,5,6), an Eulerian cycle on H. This can be merged 
with C to form the larger cycle C' = <r, 6, 3, 4, 5, 6, 7, r). 
2 
3 
4 
DLIJ 
8 
7 
6 
5 
Figure 8.10 
Theorem 2.1 also leads to conditions under which a graph contains an 
Eulerian path but not an Eulerian cycle. One such example was the graph H in 
Figure 8.7. 
Corollary 2.2. 
A connected graph contains an Eulerian path, but not an Eulerian 
cycle, if and only if exactly two vertices have odd degree. 
Proof. 
Suppose that x and yare the end vertices of the Eulerian path. Let G' 
be the graph obtained from G by creating a vertex r adjacent to x and y but to 
402 

8:2 
EULERIAN CYCLES 
no other vertex. If G contains an Eulerian path, then this path together with the 
two edges incident with r form an Eulerian cycle. Since by Theorem 2.1 G' has 
all vertices of even degree, G has exactly two vertices of odd degree. Conversely, 
if G is a connected graph with exactly two vertices of odd degree, then G', formed 
by adding a vertex r adjacent to the two vertices of odd degree, is connected and 
has every vertex of even degree. By Theorem 2.1 G' has an Eulerian cycle. We can 
imagine that this cycle begins at x and proceeds to /' and then y. In G this cycle 
becomes an Eulerian path from y to x. 
I:J 
Question 2.5. 
The graph in Figure 8.11 contains exactly two vertices of odd degree. 
Create an Eulerian graph as in the proof of Corollary 2.2. Find an Eulerian cycle 
on the larger graph and from that an Eulerian path on the original graph. 
2 
3 
5 
6 
7 
Figure 8.1 t 
The proof of Theorem 2.1 is constructive. That is, it gives us the idea for an 
efficient algorithm for finding an Eulerian cycle. 
Algorithm EULER 
STEP 1. 
Input G, a connected graph with all vertices of even degree; .;et 
C:= <x) {x arbitrary in V(G)} 
STEP 2. While IE(G)I > 0 do 
Begin 
STEP 3. 
Pick x in V( C) with deg (x, G) > 0 
STEP 4. Create a maximal cycle D beginning at x {D cannot be 
made longer by appending edges at its end.} 
STEP 5. Set E(G) : = E(G) - E(D) 
STEP 6. Set C : = cycle obtained from C by inserting D at x 
End 
STEP 7. Output C and stop. 
Example 2.3 (again). 
Here is a trace (Table 8.2) of EULER, run on the graph 
shown in Figure 8.12. 
403 

s 
MOR~: GRAPH THEORY 
Table 8.2 
Step No. 
.\: 
c 
D 
(I') 
3 
r 
4 
(r.6.7,r) 
6 
(1'.6.7,1") 
3 
6 
4 
(6.3.4.5.6) 
6 
(I', 6.l4. 5. 6, 7,1") 
3 
7 
4 
(7,2. 1,8,7) 
6 
(1',6,3.4.5,0,7,2.1,8,7. r) 
2 
3 
4 
DLiJ 
8 
7 
6 
5 
Figure 8.12 
Notice that the cycles C and D can be created in any way consistent with the 
algorithm. For example, the initial cycle C might be <r, 7, 8,1,2,7, 6,r) and the 
first cycle D might be <6,5,4.3,6). If this algorithm were implemented on a 
computer, which particular cycles C and D are created depends on how the graph 
G is stored. When tracing these cycles by hand, we can choose edges however we 
wish as long as a cycle is formed. 
Question 2.6. 
Trace the algorithm EULER on the graph in Figure 8.13. 
Figure 8.13 
404 

8:2 
EULERIAN CYCLES 
We have already proved that EULER works correctly, since it follows the 
proof of EULER's theorem. 
Of course, to use EULER on an arbitrary graph G we would need to verify 
that G is connected. Since G is connected if and only if it contains a spanning tree 
by Exercise 5.3.13, connectivity could be checked using the algorithm SPTREE 
of Exercise 5.3.19 or KRUSKAL or BFS (of Section 8.1.) If G is connected, we 
could then determine if its vertex degrees are all even. If so, we could run EULER. 
Before returning to the snow plowing problem, we consider the complexity of 
the algorithm EULER. We choose to count comparisons and note that step 4 is 
the critical step to examine. Suppose that the graph is input as an adjacency ma-
trix. Creating cycle D in step 4 can be accomplished one edge at a time by finding 
a 1 in the row of the matrix that corresponds with the current vertex. It will take 
no more than V such comparisons to find the next edge. Thus step 4 may require 
O(V' E) comparisons. Actually, with appropriate data structures EULER can be 
made linear in E. (Details appear in Exercise 12.) 
The algorithm EULER is designed to run on un weighted graphs. In the orig-
inal snowplowing problem the related graph was a weighted one. The theory and 
algorithm so far deal only with a special case, when all vertices of the graph 
derived from the street system have even degree. In this case we can plow each 
city street exactly once, and regardless of the street lengths (or edge weights) we 
have found a minimum-weight cycle without any repetition. 
Otherwise, what are the possibilities? Question 2.3 of Chapter 5 states that 
every graph contains an even number of vertices of odd degree. Thus there cannot 
be just one vertex of odd degree, but there might be exactly two vertices of odd 
degree in the graph of the streets. Suppose that City Hall is located at one vertex 
of odd degree. Then we could use an Eulerian path algorithm (see Exercise 13) 
to plow each street exactly once, ending at the other vertex of odd degree; call 
it z. To conclude, the plows would travel home from z to City Hall on a shortest 
path. This shortest path from z to City Hall could be found using DIJKSTRA 
with z as the root. In Exercises 8 to 10 you are asked to verify that this scheme 
does produce the overall most-efficient plowing plan when there are only two 
vertices of odd degree. 
When there are four or more vertices of odd degree, the most-efficient snow-
plowing plan involves paths between pairs of these vertices of odd degree. (See 
Exercises 5 to 7). In fact, there is an efficient algorithm to solve this problem in 
full generality. It consists of pairing up the vertices of odd degree so that the sl1m 
of the distances of the minimum-distance paths between pairs is minimized. This 
is known as the Minimum Weight Matching Problem or the Chinese Postman 
Problem (named after the Chinese mathematician, M-K. Kwan, who first con-
sidered this problem.) The solution is complex, beyond the scope of this chapter. 
But wait-there's something unsatisfactory about the snowplowing model. 
Most snowplows don't plow streets just once, but rather twice, once in each difi~c­
tion to clear both sides of the street. Can we devise an algorithm to traverse each 
405 

8 MORE GRAPH THEORY 
edge of a graph in this more realistic way? The answer is yes, quite easily, given 
our experience with Eulerian graphs. 
We model this new situation with a directed graph, that is, a graph in which 
each edge is given an orientation or direction from one incident vertex to the 
other. In directed graphs paths and cycles must traverse each edge in its given 
orientation. 
Definition. 
A directed graph G consists of a finite set V( G) of vertices and a finite 
set E( G) of edges (also called arcs) such that each edge consists of an ordered pair 
of distinct vertices of V(G). We think of the edge e = (x,y) as being directed from 
x to y. 
Example 2.5. 
Figure 8.14 shows some directed graphs. 
2 
1 
2 
2 
D D ~ 
3 
4 
3 
4 
3 
4 
Figure 8.14 
Definition. 
A path in a directed graph G from x to y is a sequence of distinct 
edges, e l' ez, ... ,ek, such that e 1 = (x, XI), ez = (xlo X2)' ... ,ek = (Xk- l' y) for some 
vertices XI' X 2' ... 'Xk _ l' A cycle in a directed graph is a path from a vertex to 
itself. An Eulerian path (respectively, Eulerian cycle) is a path (respectively, cycle) 
that includes every edge exactly once. 
Question 2.7. 
For each graph in Example 2.5 find an Eulerian path or cycle if 
there is one. 
Theorem 2.3. 
A directed graph whose underlying undirected graph is connected 
contains an Eulerian cycle if and only if at every vertex v the number of edges 
directed in to v equals the number of edges directed out of v. 
Proof. 
Follow the same proof as given for Theorem 2.1. 
Theorem 2.3 can be applied to solve the snowplow problem completely. If 
G is the (undirected) graph derived from the city street plan, let D be the directed 
graph created by replacing every edge of G by two directed edges, one in each 
direction. Then an efficient snowplowing plan would be an Eulerian cycle on D. 
406 

8:2 
EULERIAN CYCLES 
Since each edge in G is replaced by two directed edges in D, a vertex of degree 
k in G becomes a vertex in D with k edges directed in to it and k edges directed 
out of it. Hence the conditions of Theorem 2.3 are met and D contains an Eulerian 
cycle. How do we find an Eulerian cycle'? Exercise 18 asks you to modify EULER 
so that it works on directed graphs. 
EXERCISES FOR SECTION 2 
1. Which of the following graphs are Eulerian'? 
~l 
(b) 
(a) 
I r\J\J\J 
Ie) 
(d) 
2. Can an Eulerian graph contain an odd number of edges? Either find an 
example or prove that there is none. 
3. Suppose that C = (Xl,X2,'" ,Xk,XI) is a cycle in an Eulerian graph G with 
no repeated vertices (except for the start and finish at x d. Show that tb.ere 
is an Eulerian cycle on G that visits the vertices XI,X2,'" ,Xk in the S,lme 
order as in C, that is, for each i = 1,2, ... ,k -
1, vertex Xi is reached before 
vertex Xi + l' 
4. An Eulerian graph is called arbitrarily traceable at a vertex x if every cycle 
beginning and ending at x can be extended to an Eulerian cycle by continuing 
the cycle at x. Prove that G is arbitrarily traceable if and only if every cycle 
of G passes through x. 
5. Show that the following graphs can have their edges divided into two paths, 
each joining two vertices of odd degree. 
la) 
(b) 
407 

8 MORE GRAPH THEORY 
6. Show that any graph with exactly four vertices of odd degree can have its 
edges divided into two paths, one path joining a pair of the vertices of odd 
degree and the other path joining the other pair. 
7. Show that a graph with exactly 2k vertices of odd degree can have its edges 
divided into k paths, each path joining a different pair of vertices of odd 
degree. 
8. In the following graph, show that the shortest "snowplowing plan" that tra-
verses each edge at least once consists of an Eulerian path from r to :; and 
then a minimum-distance path from:; to r. 
t&"7!\ZSJ 
lrl 
4 
3 
zl 
9. Suppose that G is a connected (unweighted) graph that contains an Eulerian 
path but not an Eulerian cycle. Let rand s be the vertices of odd degree. Show 
that the "trail" that traverses every edge of G at least once, starting and ending 
at r, and uses the fewest edges, consists of an Eulerian path from r to s plus 
a shortest path back from s to r. (Hint: Let C be a minimum trail that traverses 
every edge at least once, and let G # be the graph formed by adding an edge 
for each repeated use of an edge by C. Thus C is an Eulerian cycle on the 
graph G #. Study the graph formed from the new edges in G #. Actually, G # 
will be a multigraph, i.e., some pairs of vertices can be joined by more than 
one edge.) 
10. Answer the same question as in Exercise 9, only assume that the graph G is 
weighted and path length, as usual, is the sum of the edge weights of edges 
in the path. 
11. Suppose that G is a connected weighted graph with exactly two vertices of odd 
degree and let u be an arbitrary vertex of G. Describe a shortest trail on G 
that begins and ends at u and covers each edge at least once. Prove that your 
trail is the shortest. 
12. Here is a closer look at the complexity of EULER with an expanded version 
of the algorithm. Suppose that for each vertex u, Nhor(u) initially contains a 
list of all vertices adjacent to D. 
408 
Algorithm EULER 
STEP l. Input G, a connected graph with all vertices of even degree and E 
edges; set C = <x) {x arbitrary in V(Gl} 

8:2 
EULERIAN CYCL~:S 
STEP 2. While IE(G)I > 0 do 
Begin 
STEP 3. 
Pick x in V( C) with deg (x. G) > 0 
STEP 4. Call Trace (D,x) (The procedure Trace finds a maximal c)-
cle D beginning at xl 
STEP 5. Set C : = cycle obtained from C by inserting D at .\ 
End 
STEP 6. Output C and stop. 
Procedure Trace ( D, x) 
STEP 1. Set::: = x 
STEP~. While Nbor(z) #- 0 do 
Begin 
STEP 3. 
Pick win Nbor(z) 
STEP 4. Add IV to D 
STEP 5. 
Nbor(z):= Nbor(::) ~:IV); Nbor(w):= Nbor(w) ~ (::) 
STEP 6. 
E(G): = E(G) ~ (z, w) 
STEP 7. Set z:= w 
End 
STEP 8. 
Return 
In this version comparisons are made in steps 2 and 3 in the main program 
and in step 2 of Trace. Suppose that the algorithm cycles through (the main) 
step 2 s times, creating the cycles D l' D 2 , ... , Ds' which together form the 
Eulerian cycle. Find an upper bound on s in terms of £ and then show that 
the total number of comparisons is 0(£). 
13. Modify EULER so that upon input of a connected graph with exactly two 
vertices of odd degree, x and y, it traces an Eulerian path, beginning at x and 
ending at y. 
14. Find conditions under which a directed graph contains an Eulerian path but 
not an Eulerian cycle. Prove your result. 
15. Prove that an undirected graph G is Eulerian if and only if there is a w ly 
to direct its edges so that the resulting directed graph contains an Eulerian 
cycle. 
16. Give an example of an undirected Eulerian graph G and then a direction 1m 
each of its edges so that the resulting directed graph does not contain ,m 
Eulerian cycle. 
17. Explain how a directed graph can be stored in a V x V adjacency matrix. 
18. Rewrite the algorithm EULER so that upon input of a directed graph, whose 
underlying undirected graph is connected, it finds an Eulerian cycle if there is 
one. 
409 

8 
MORE GRAPH THEORY 
19. A spanning in-tree of a directed graph G with root r is defined to be a spanning 
tree of the underlying undirected graph such that each path P from a vertex 
y to r within the spanning tree is a directed path from y to r in C. Find 
examples of directed graphs that do and do not contain a spanning in-tree. 
Find an example of a graph G with root r that has a spanning in-tree but such 
that with some other vertex s as root there is no spanning in-tree. 
20. Explain why in a spanning in-tree with root r, each vertex, except for r, has 
exactly one edge of the tree directed out of the vertex. 
21. Let G be a directed graph that contains an Eulerian cycle and r an arbitrary 
vertex. Prove that G has a spanning in-tree with root r. 
22. Devise an algorithm that upon input of a directed graph that contains an 
Eulerian cycle finds a spanning in-tree. 
23. Suppose that G is a directed graph that contains an Eulerian cycle. Explain 
why the following is a valid algorithm for finding an Eulerian cycle in such 
a graph. First find a spanning in-tree with root r, as in the previous exercise. 
Then construct a cycle by appending incident, unused edges in any way except 
that at each vertex v # r the unique out-directed edge in the spanning in-tree 
should be saved for the last exit from v. 
24. A directed graph is called strongly connected if for every pair of vertices x 
and y there is a path from x to y and a path from y to x. A directed graph 
is called connected if for every pair of vertices x and y there is a path from 
one to the other. A directed graph is called wellkly connected if the underlying 
undirected graph is connected. Find examples of the following types of directed 
graphs. 
(a) The graph is strongly connected. 
(b) The graph is connected but not strongly connected. 
(c) The graph is weakly connected but not connected. 
(d) The graph satisfies none of the connectivity definitions. 
25. Explain why a graph that is strongly connected is also connected and why 
a graph that is connected is also weakly connected. 
26. Prove that a directed graph that contains an Eulerian cycle is strongly con-
nected. Is the same true for a directed graph that contains an Eulerian path? 
If so, explain why; if not, find additional conditions which when met by the 
graph ensure that it is strongly connected. 
8:3 HAMILTONIAN CYCLES 
Suppose that a mail carrier wants to pick up mail from every mailbox in town. 
or an inspector wants to check the traffic signals at every intersection. Can these 
jobs be accomplished efficiently by visiting each location exactly once'! These 
410 

8:3 HAMILTONIAN CYCLES 
problems are modeled by constructing an appropriate graph with a vertex for 
each location and two vertices joined by an edge if there is a street connection 
that passes through no intermediate location. The problem is to find a cycle that 
passes through each vertex of the graph exactly once. 
This graph theory problem is known as the Hamiltonian cycle problem, named 
for Sir W. R. Hamilton, the inventor of a related game (see Exercise 3). It is one 
of graph theory's most demanding unsolved problems. In this section we search 
for conditions that guarantee the existence of a Hamiltonian cycle and an efficient 
algorithm to find such a cycle. We also learn the important algorithmic technique 
of depth-first search. This can be used to solve the Hamiltonian cycle problem for 
an arbitrary graph, although not efficiently. In the following section we turn to 
the equally challenging problem of finding a minimum-weight Hamiltonian cycle 
in a weighted complete graph. 
Question 3.1. 
Which of the graphs in Figure 8.15 contains a cycle that visits e,lch 
vertex exactly once? 
2 
2 
50---02 
4 
3 
4 
3 
Figure 8.15 
4 
3 
Definitions. 
In a graph G with V vertices, a path (or cycle) that contains exactly 
V-I (respectively, V) edges and spans G is called Hamiltonian. A graph is called 
Hamiltonian if it contains a Hamiltonian cycle. 
Problem. 
Given a graph G, is it Hamiltonian? If so, find a Hamiltonian cycle. 
Notice how similar this problem seems to be to that of Eulerian cycles (of 
Section 8.2.) In that case we found necessary and sufficient conditions for a con-
nected graph to be Eulerian. In the case of Hamiltonian graphs life is not so sirr.ple 
and no such nice characterization is known (or likely to be discovered). 
First we remark that since a Hamiltonian graph must contain a spanning 
cycle, every vertex must have degree at least 2. Exercises 4 and 5 develop more 
involved conditions that a graph must satisfy in order to be Hamiltonian. 
Question 3.2. 
Find an example of a connected graph that is not Hamiltonian but 
does not contain any vertices of degree I. 
411 

8 MORE GRAPH THEORY 
The r-clique, with r 2: 3, contains a Hamiltonian cycle, namely < 1,2, ... ,r, I). 
More generally, graphs with all vertices of relatively high degree contain Hamil-
tonian cycles as seen in the first theorem. 
Theorem 3.1. 
If G has V 2: 3 vertices and every vertex has degree at least V/2, 
then G is Hamiltonian. 
Proof. 
The proof is constructive and will lead to an algorithm HAMCYCLE. 
There are two principal steps. In the first we take a maximal path (i.e., a path that 
cannot be extended at either end) and find a cycle on the same set of vertices. In 
the second step we take any vertex not on the cycle and construct a maximal path 
using it and all of the vertices of the cycle. This new path will be longer than 
the original one. We continue alternating these two steps until all of the vertices 
of the graph are in the maximal path whence the next cycle we create will be 
Hamiltonian. 
We first note that any maximal path must contain more than half the vertices 
of the graph. Suppose that <x = Xl' X2" .. 'Xk = y) forms a maximal path within 
the graph G. Since the path is maximal, x cannot be adjacent to any vertex off 
the path. Thus x has at most k -
I neighbors. Since the degree of x is at least 
V/2, we know that 
V 
k-I>-
- 2 
or 
Now we want to find a cycle whose vertex set is the same as that of the 
maximal path. If x is adjacent to y, then the vertices of the path form a cycle in 
their natural order. If there exist vertices Xi and Xi + 1 such that x is adjacent to 
X i + 1 and y is adjacent to Xi' then <X,Xi+l,Xi+2,,,.,y,xi,Xi~1,,,,,X2'X) is a 
cycle containing all the vertices of the original path. See Figure 8.16. On the other 
hand, if there were no such pair Xi and Xi + l' then whenever X is adjacent to Xi + l' 
Y is not adjacent to Xi' Since the path is maximal. neither x nor y can be adja-
cent to any vertex off the path. Thus if deg (x) = s, then deg (y) :S k - 1 -
s. Since 
deg (x) 2: V/2 and deg (y) 2: V/2, 
V :S deg (x) + deg (y) :S s + (k -
1 -- s) = k -
1 < V, 
a contradiction. 
o 
••• 
Xi 
x! + 1 
Figure 8.16 
412 

8:3 HAMILTONIAN CYCLES 
Thus we can create a cycle on any vertex set from a maximal path; we relabel 
vertices so that the resulting cycle is (x 1" .. ,Xk , Xl)' 
To justify the second step, let;; be any vertex not contained in (he cycle 
(x[, ... ,xk'X j ), Since, as we saw above, 
and 
V 
deg(z) ;:::: 2' 
;; must be adjacent to at least one vertex on the cycle. [f ;; is adjacent to Xi' then 
forms a path in C with k + 1 vertices. This can be extended to a maximal path. 
Here is an algorithm suggested by the proof of Theorem 3.1. 
Alyorithrn HAMCYCLE 
STEP 1. Input C, a graph with V vertices all of degree;:::: V/2 
STEP 2. Set P:= 0 
STEP 3. Repeat 
Begin 
LJ 
STEP 4. 
Pick z in V(C) -
V(P); Se:t P : = a maximal path containing 
V(P) and z 
STEP 5. Find C a cycle on V(P) 
End 
until \V(C)\ = V 
STEP 6. Output C and stop. 
Example 3.1. 
Table 8.3 is a trace of HAMCYCLE as applied to the graph in 
Figure 8.17. 
Table 8.3 
Step No. 
: 
P 
c 
:2 
0 
4 
x 
(x. ['.1. IV • .1') 
5 
(X.I.W.y,u,X) 
4 
II 
(u.t.w.),.['.x) 
5 
(u.lV.y,v,x,t,U) 
413 

8 MORE GRAPII THEORY 
u 
Figure 8.17 
Question 3.3. 
Trace HAMCYCLE on the graph in Figure 8.18. 
u 
Figure 8.18 
How efficient is HAMCYCLE? It is a O(V2 ) algorithm; here's why. Construct-
ing the first maximal path in step 4 will require fewer than V comparisons to add 
each vertex and thus fewer than V2 comparisons in total. The path has length at 
least V/2 and so the Repeat ... Until loop repeats at most V/2 times. In sub-
sequent executions of step 4 the addition of the vertex z will require no more than 
one comparison for each vertex in P and so fewer than V in total. Constructing 
a maximal path in step 4 requires fewer than V comparisons for each additional 
vertex. Thus the total number of comparisons in step 4 is V2 + (V/2)(V + V) = 
2V2. Finding C in step 5 can be accomplished with no more than two compari-
sons for each edge in P and thus fewer than 2 V for the step. Thus the total number 
of comparisons in step 5 is V2 and HAMCYCLE is O(V2 ). 
Suppose that we want to find a Hamiltonian cycle in an arbitrary graph, one 
with all sorts of different degrees. We might try to list all cycles in the graph, 
but that certainly sounds like the basis of an exponential algorithm. (Recall that 
algorithms that list all possible subsets, like J-SET and BADMINTREE, are ex-
ponential.) Why don't we just try to build as long a path as possible, and then 
check that it can be completed to a cycle? (The phrase, "Why don't we just ... ," 
is a famous one in algorithms. Often there seems to be a simple way to proceed, 
but the heart of the matter is then proving that the resulting algorithm always 
works and is efficient.) 
We pursue the idea of hunting for a longest path. This technique, known as 
depth-first search (or DFS), is a method for systematically visiting all vertices of 
a graph by traversing paths that are as long as possible. 
414 

8:3 HAMILTONIAN CYCLES 
Example 3.2. 
Suppose that we want to visit all vertices in the graph shown in 
Figure 8.19. 
2 
3 
6 
5 
4 
G 
Figure 8.19 
2 
3 
Jl 
6 
5 
One DFS 
spanning tree 
4 
6 
2 
5 
Another DFS 
spanning tree 
3 
4 
Beginning at vertex 1 we might create a path P = (1,2,3,4). From verlex 
4 we can visit no additional new vertices. We backup to vertex 3 from which we 
also cannot visit new vertices. Then we backup to vertex 2 and visit vertices 5 and 
then 6. If we keep track of the edges traversed in this process, we find a spanning 
tree. This tree is known as a depth-first-search (or DFS) spanning tree. As with 
breadth-first search, a DFS spanning tree is not uniquely determined. 
First we present this technique as an algorithm, designed to visit vertices and 
to construct a spanning tree if possible; in latl~r applications we shall embellish 
upon this fundamental depth-first-search procedure. As vertices are visited, they 
and their adjoining edges are placed in T and E(T), the vertices and edges of a 
DFS tree. We may use the edges in E(T) to backup if need be. 
Algorithm DEPTHFIRSTSEARCH (DFS) 
STEP 1. Initialize 
Input G, a graph with vertices 1, ... , V and edge set E(G) 
Set J : = 1 {J will index the vertex currently visited.) 
Set T: = {I} {T will contain the visited vertices.} 
Set E(T) : = 0 {E(T) will contain the edges of the DFS tree.} 
STEP 2. While I TI < V do 
STEP 3. If there is a K in G -
T such that (J, K) is in E( G), then do 
Begin 
STEP 4. T: = T + K 
STEP 5. E(T): = E(T) + (J, K) 
STEP 6. J:= K 
End 
415 

8 
MORE GRAPH THEORY 
Else l no such K) 
STEP 7. If J i= I, then do [backup] 
Find (l,J) in E(T) and set J := I 
Else [J= I: 
STEP 8. Output T, E(T) and stop. 
STEP 9. Output E(T) and stop. 
Example 3.3. 
Table 8.4 is a trace of DFS run on the graph in Figure 8.20. 
2 
3 
4 
~J 
8 
7 
6 
5 
Figure S.20 
Table S.4 
Step No. 
J 
K 
T 
E(T) 
o 
3 
2 
4-6 
2 
2 
: 1,2) 
3 
2 
3 
4-6 
3 
3 
: !, 2. 3) 
:(1.2), (2,3)) 
3 
3 
4 
46 
4 
4 
: 1,2, 3.4) 
[(I. :!), (2,3), (3,4)] 
3 
4 
5 
4-6 
5 
5 
: 1,2,3,4.5) 
: (!,:!), (2,3), (3,4), (4. 5)} 
3 
5 
:no K} 
7 
4 
3 
4 
:no K) 
7 
3 
3 
3 
6 
46 
6 
6 
: 1,2.3. 4, 5. 6) 
[( I, 2). (2.3), (3. 4), (4,5), (3. 6l) 
3 
6 
:no K) 
7 
3 
3 
3 
:no K: 
7 
2 
3 
2 
7 
4-6 
7 
7 
: 1. 2, J. 4. S, 6, 7) 
it!,:!). (2,3), (3.4), (4,5), (3.6), (2,7)) 
3 
7 
8 
4-6 
8 
8 
:(U), (2,3), (3,4), (4.5), (3.6). (2.7). (Un 
9 
Stop. 
416 

8:3 HAMILTONIAN CYCLES 
123 
234 
W 
17 17 
5 
4 
6 
5 
Figure 8.21 
Question 3.4. 
Trace DFS on the graphs in Figure 8.21. 
Theorem 3.2. 
DEPTHFIRSTSEARCH terminates with T containing precisely 
those vertices that are in the same component as vertex I. The algorithm performs 
O(V2) comparisons. 
Proof. 
Note that if vertex v is not in the same component as vertex L then there 
is no path connecting 1 and u and so [l cannot be added to the tree T. 
Conversely, suppose that v is a vertex in G that is in the same component as 
the vertex I, yet u is not in T after 0 FS is executed. There is a path from 1 tc u. 
Assume that the edge (u, v) is on that path and that u is in T. (Otherwise, replace 
v by u in this argument.) Since v is never added to T, I TI < V and the algorithm 
terminates in step 8. Yet whenever DFS examines the vertex u in step 3, there is a 
vertex K available, namely K = v, and so DFS must add u to T before J is de-
creased back to 1 in step 8. 
To count comparisons in DFS, we first note that the loop at step 2 is executed 
fewer than V times. Each pass through the loop requires one comparison at steps 
2 and 7 and fewer than V comparisons at step 3. Thus DFS requires fewer than 
V(V + 2) = O(V2) comparisons in total. 
D 
In contrast we also offer a recursive version of DFS; here the internal backng 
up (in step 7 of DFS) is managed by the recursive calls. 
Procedure R-DFS( J) 
[The procedure begins a depth-first search at vertex 1.J 
STEP 1. T: = T + 1 
STEP 2. For each edge (J, K) do 
STEP 3. If K is in G -
T, then do 
Begin 
STEP 6. 
Return. 
STEP 4. EfT): = E(T) + (l, K) 
STEP 5. Call Procedure DFS(K) 
End 
Then a depth-first search is performed by the following. 
417 

II 
MORE GRAPH THEORY 
Alyorithm R-DEPTHFIRSTSEARCH 
STEP 1. Input the graph G 
STEP 2. T:= 0: E(T):= 0 
STEP 3. Call Procedure DFS(I) 
STEP 4. Output T, E(T), and stop. 
More analysis of this recursive approach is contained in Exercise 21. 
Our immediate aim is to use DEPTHFIRSTSEARCH (or R-DEPTHFIRST-
SEARCH) to try essentially all possible ways to construct a Hamiltonian cycle. 
First we create as long a path as possible. If this can be completed to a Hamiltonian 
cycle, we are done. If not, we backup, throwing away vertices on the path and 
trying to find another way to extend. 
Example 3.4. 
Here is the idea of a depth-first search for a Hamiltonian cycle on 
the graph shown in Figure 8.22. We begin creating as long a path as possible: 
(1,2,3,4). This cannot be completed to a cycle. We backup to 3, but there is no 
way to make a new path. When we backup to 2, we can start a new path (1,2,4), 
which gets completed to the Hamiltonian cycle (1,2,4,3,1). 
2 
3 
4 
Figure 8.22 
In this variation on depth-first search, the variable PATH will contain the 
vertices of a path that we hope can be completed to a Hamiltonian cycle; entries 
are initialized as O. When we backup, we must delete vertices from PATH, resetting 
entries to O. The procedure BUILD is used to find the next entry to be added to 
PATH. As long as vertices are being added to PATH the variable FORWARD 
equals TRUE, but when backing up FORWARD is FALSE. 
Algorithm DFS-HAMCYCLE 
418 
STEP 1. Initialize 
Input G, a graph with vertices I, ... , V 
Set PATH(1):= I, PATH(I):= 0 for I = 2, .... V + 1 
Set J : = 2 [J indexes the entry of PATH that is currently sought.) 
Set FORWARD:= TRUE 
STEP 2. While J < V + 1 do 
Begin 
STEP 3. If FORWARD = TRUE do 
Call Procedure BUILD 

8:3 HAMILTONIAN CYCLES 
Else {FORWARD = FALSE] 
Begin 
STEP 4. PATH()): = 0 
STEP 5. ): = ) - 1 
STEP 6. If J #- 1, then 
Call Procedure BUILD 
Else {.J = I) 
Output "No Ham cycle" and stop. 
End {step 3} 
STEP 7. If J = V + 1, then do 
STEP 8. If (I, PATH(V)) is in E(G), then 
PATH()):= 1 
Else 
FORWARD:= FALSE 
End {step 2} 
STEP 9. Output PATH and stop. 
Procedure BUILD 
STEP 1. Find smallest K > PATH(J) such that K #- PA TH(J) for J < ) and 
(PATH(J -
1), K) is in E(G) 
STEP 2. If there is no such K, then 
Else 
End. 
Set FORWARD:= FALSE 
Begin 
STEP 3. PATH()):= K 
STEP 4. J: = J + 1 
STEP 5. FORWARD:= TRUE 
End {step 2} 
Note that this algorithm parallels DFS; however, the K chosen in step 1 of 
the procedure is specified. 
Example 3.5. 
Table 8.5 is a trace of DFS-HAMCYCLE on the graph from Figure 
8.22. 
Question 3.5. 
Trace DFS-HAMCYCLE on one graph of Figure 8.15. 
In Exercises 13 and 14 you are asked to show that DFS-HAMCYCLE is 
correct. It would be nice if it were O(Vl). Unfortunately, the seemingly small 
changes from DEPTHFIRSTSEARCH make the algorithm no longer a poly-
nomial algorithm. (See Exercise 24.) 
The Hamiltonian cycle problem of this section is not just an exercise in frustra-
tion for the reader-it is equally frustrating for researchers in graph theory and 
419 

!I 
MORE GRAPH THEORY 
Table 8.5 
Step No. 
.I 
Main 
2 
BUILD 
2 
3 
2 
4 
3 
5 
BUILD 1 
3 
3 5 
4 
BUILD 1 
4 
3-5 
5 
Main 
7, X 
5 
Main 
4 
5 
5 
4 
BUILD 1 
4 
2 
Main 
4 
4 
5 
3 
BUILD 1 
3 
3-5 
4 
BUILD 1 
4 
3-5 
5 
Main 
7,8 
5 
Main 
9 
STOP 
K 
3 
3 
4 
4 
:no Kl 
4 
4 
3 
3 
FORWARD 
TRUE 
TRUE 
TRUE 
TRUE 
FALSE 
FALSE 
TRUE 
TRUE 
PATH 
< 1, 0, 0, 0, 0) 
<1,2,0,0,0) 
< 
1, 2, 3, 0, 0) 
<1,2,3,4,0) 
< 1.2, 3, 4, 0) 
< 1.2, 3, 0, 0) 
< 
1, 2, 4, 0, 0) 
<1,2,4,3,0) 
(1,2,4,3,1) 
graph algorithms! This is one of a collection of problems for which there is no 
known polynomial algorithm and for which it has not been proved that there 
cannot be a polynomial algorithm, as yet undiscovered, The question of the com-
plexity of the Hamiltonian cycle problem has been shown to be equivalent to 
a large collection of similarly unsolved problems:: these are known as the NP-
Complete problems, Two other NP-Complete problems are the Traveling Sales-
representative Problem, mentioned in Section 5.5, and the Satisfiability Problem 
of Section 1.10. The NP-Complete problems are equivalent in the sense that if a 
good algorithm is found for one of these problems, then there are good algorithms 
for all NP-Complete problems. Conversely, if one of these problems is intractable, 
then the same is true for all the NP-Complete problems. The NP-Complete prob-
lems are intensively studied, and rumors of proofs (and of false proofs!) circulate 
through the research community. There is an expectation that the issue should be 
resolved soon. Most algorithmics experts would be surprised if there were good 
algorithms for the NP-complete problems. (We place no bets on how soon or which 
way these problems will be resolved .... ) 
In the next two sections we shall discuss instances of two other NP-Complete 
problems and shall demonstrate different ways of coping with the unsettled state 
of affairs. 
420 

8:3 HAMILTONIAN CY(U:S 
EXERCISES FOR SECTION 3 
l. Which of the following graphs contain a Hamiltonian cycle? Which conlain 
a Hamiltonian path but not a Hamiltonian cycle? Give reasons for your 
answers. 
2. Find examples of the following types of graphs: 
(a) Eulerian and Hamiltonian. 
(b) Eulerian but not Hamiltonian. 
(c) Hamiltonian but not Eulerian. 
(d) connected but neither Hamiltonian nor Eulerian. 
3. Here is the original graph on which Hamilton based his game; find a Hamil-
tonian cycle in this graph. One version of the original game consisted of one 
player selecting a path with five vertices and the second player attempting to 
421 

8 MORE GRAPH THEORY 
extend the path to a Hamiltonian cycle. Is there a path with five vertices that 
cannot be extended to a Hamiltonian cycle? 
4. Show that if G, a connected graph. contains a vertex L' whose removal leaves 
a disconnected graph. then G is not Hamiltonian. Is the converse true? 
5. Let S be a set of vertices of a graph G and let c(G - S) denote the number 
of connected components in the graph obtained by deleting the vertices of S 
and all incident edges. Prove that if G is Hamiltonian, then for every nonempty 
subset S, c( G -
S) ::=:; W(S)i. Is the converse true'? 
6. Show that the complete bipartite graph Kr,s is Hamiltonian if and only if I' = s. 
7. Can a connected bipartite graph with an odd number of vertices be Hamil-
tonian? Is every connected bipartite graph with an even number of vertices 
Hamiltonian? 
8. Imagine the graph that consists of two copies of KV/2 (where V is even) joined 
by exactly one edge. Use this graph to argue that the hypothesis of Theorem 
3,1 (that the degrees are at least Vj2) cannot be weakened and still have the 
conclusion hold, 
9. Explain why a graph with V vertices and all vertices of degree at least V/2 
is connected. 
10. Suppose that G is a graph with V vertices such that for every pair of non-
adjacent vertices, say x and y, the degree of x plus the degree of y is at least 
V. Show that G is Hamiltonian. Compare this result with Theorem 3.1. 
11. Where in the proof of Theorem 3.1 is the assumption that V;::: 3 needed? 
12. Where does the algorithm HAMCYCLE use the fact that all vertices have 
degree at least Vj2? Can this number be replaced by Vj2 -
1 or by any smaller 
number, like 2 VjS or 3 VjS? 
13. Prove that DFS-HAMCYCLE is correct when it outputs the edges of a 
Hamiltonian cycle. 
14. Prove that if DFS-HAMCYCLE terminates without finding a Hamiltonian 
cycle, then G does not contain such a cycle. (Hint: Try a proof by contradiction,) 
15. Here is an another algorithm to find a Hamiltonian cycle in a graph with all 
vertices of degree at least V/2. 
422 
Algorithm HAMCYCLE2 
STEP I. 
Input G with V vertices, all of degree;::: Vj2, label each edge with 
a 0, set label: = 1 and H : = G 
STEP 2. 
While H contains nonadjacent vertices x and y do 
Begin 
STEP 3. 
Set H : = H + (x, y) 

8:3 HAMILTONIAN CYCLES 
STEP 4. 
STEP S. 
End 
Label (x, y) with the value of label 
Set label: = label + I 
STEP 6. 
Find C a Hamiltonian cycle in H and let k be the largest label on 
an edge of C 
STEP 7. 
Repeat 
Begin 
STEP 8. 
Find the edge (x. y) of label Ie 
STEP 9. 
Renumber the vertices of C as 
C=(X=X I.X2.··· • .'CV=y) 
STEP 10. Find an index i such that x is adjacent to Xi and; IS 
adjacent to Xi - 1 
STEP II. Set 
c:= (x = Xj'Xi,X i + 1"" ,xv = y,Xi - 1,Xi - 2 ,··· .X 1 ) 
STEP 12. Delete the edge (x, y) 
STEP 13. Set k : = largest label on an edge of C 
End 
Until Ie = 0 
STEP 14. Output C and stop. 
Run HAMCYCLE2 on the two following graphs. 
8 
3 
50--+-+---03 
7 
4 
4 
6 
5 
16. Prove that HAMCYCLE2 always produces a Hamiltonian cycle in a gr.lph 
with all vertices of degree V/2 or more. 
17. Is HAMCYCLE2 more efficient than HAMCYCLE? 
18. Find an example such that the spanning trees created by breadth-first search 
and depth-first search differ. 
423 

8 
MORE GRAPH THEORY 
1 
2 
3 
2 
3 
2 
[IJ 
4 
5 1 
6 
5 
4 
4 
3 
7 
8 
19. Run DEPTHFIRSTSEARCH on the following graphs. 
20. (a) Modify DEPTHF1RSTSEARCH so that it outputs a spanning tree if the 
graph is connected and a spanning forest otherwise. 
(b) Modify DFS further so that it identifies and outputs the vertices in each 
connected component of the graph. 
21. (a) Run R-DEPTHFIRSTSEARCH on the graphs of Exercise 19. 
(b) Prove the analogue of Theorem 3.2 for R·DEPTHFIRSTSEARCH. 
22. Run DFS-HAMCYCLE on the following graphs. 
1 
2 
2 
3 
4 
3 
rsJ 
o 
3 
4 
1\ 
4 
2 
23. Construct an algorithm that uses depth-first search to find a Hamiltonian path 
in a graph or else reports that there is none. 
24. Find a family of (possibly disconnected) graphs on V vertices such that DFS-
HAMCYCLE creates more than (V -
3)! paths, none of which extend to a 
Hamiltonian cycle. 
25. Write a recursive program that searches for a Hamiltonian path in a graph. 
26. Write a recursive program that searches for a Hamiltonian cycle in a graph. 
27. If G is a graph. we define the line graph of G, denoted L(G), to be the graph 
formed with a vertex in L(G) for every edge of G and two vertices adjacent in 
L(G) if the corresponding edges of G are incident. Prove that if a graph G is the 
line graph of an Eulerian graph (i.e., there is an Eulerian graph H such that 
L(H) = G), then G is Hamiltonian. Find examples of such graphs G and H. 
28. Find an example of a graph G that is not the line graph of any other graph: 
that is. there is no graph H such that G = L(II). 
29. Show that if G is Eulerian. then so is L(G). 
424 

8:4 
MINIMUM-WEIGHT HAMILTONIAN CYCLES 
30. Prove that G is the line graph of some graph if and only if the edges of G can 
be divided into a disjoint collection of maximal complete subgraphs. 
31. Three mutually adjacent vertices T in a graph G arc said to form an even triangle 
if every vertex of G is adjacent to zero or two vertices of T. Otherwise, three 
mutually adjacent vertices are said to form an odd triangle. Prove that a gr,lph 
G is the line graph of another graph if and only if (i) G does not contain two 
odd "overlapping" triangles of the form {a, h, c} and la, h, d 1 and (ii) G does not 
contain K 1,3 as an induced subgraph. 
8:4 MINIMUM-WEIGHT HAMILTONIAN CYCLES 
A common manufacturing task is drilling holes in a sheet of plastic using a laser. 
Think of the plastic as being in a fixed location in the horizontal plane. The drill 
is movable and must be located immediately above the target hole while drill ng. 
The time it takes to fabricate one unit equals the time it takes to drill the holes 
together with the time it takes to move the drill. With a given drill and plastic sheet, 
the drilling time will be a (small) constant. The time it takes to position the drill 
will depend on the distance the drill must travel. Thus the manufacturer would 
like to drill the holes in an order that minimizes the total distance the drill tra\els. 
Question 4.1. 
Suppose that the drill is initially located above the origin in the x-y 
plane and that after drilling four holes the drill must return to the origin. Suppose 
the holes are located at (0.0), (l,0), (0,1), and (1, I). Find all possible drilling 
sequences and for each find the total distance that the drill travels. 
Efficient fabrication leads to the following graph theory problem. Construd a 
complete graph whose vertices correspond with the locations of the holes. Since 
this graph is complete, it contains lots of Hamiltonian cycles. We want a shortest 
one. Assign to the edge (x, y) a weight that represents the distance from the ~ole 
labeled x to the hole labeled y. A minimum-weight Hamiltonian cycle in this graph 
corresponds with a most efficient ordering of the vertices for drilling. 
Problem. 
Given a weighted complete graph, find a Hamiltonian cycle whose total 
weight is minimum. 
The only known algorithms for this probkm are exponential (see Exercise 3). 
A typical manufacturing application might have hundreds or even thousand~; of 
holes to drill. Thus a nonpolynomial algorithm for finding a minimum-weight 
spanning cycle would be impossibly slow. Still in practice the drilling is done with 
the holes processed in some order. 
This section presents a good approximation algorithm for the laser drilling 
problem. Specifically, given a weighted complete graph whose edge weights repre-
sent distances in the plane. the algorithm will produce a Hamiltonian cycle whose 
425 

8 MORE GRAPH THEORY 
total weight is no morc than twice the minimum. Before giving the algorithm 
formally, we discuss and analyze the major steps in the approximation. 
Given a weighted complete graph G, let H(G) denote a minimum-weight 
Hamiltonian cycle and let PIG) denote a minimum-weight Hamiltonian path. Of 
course, we don't know a good way to find these subgraphs. However, we can usc 
KRUSKAL (see Section 5.4) to find instead T(G), a minimum-weight spanning 
tree of G. This will be the first major step in the approximation algorithm. 
Example 4.1. 
Suppose that the vertices of G correspond with the points (0,0), 
(1,1), (2,0), and (0,2). Figure 8.23 exhibits T(G)., P(G), and H(G). Note that 
w(T(G)) = 3ji, w(P(G)) = 2 + 2l5., and w(H(G)) == 4 + 2.)2. 
(0,2) 
(0,2) 
(0,2) 
X, 
~I 
~I 
(0,0) 
(2,0) 
(0,0) 
(2,0) 
(0,0) 
(2,0) 
T(G) 
P(O) 
H(G) 
Figure 8.23 
Question 4.2. 
Given the points (0, 0), (1, 1), (1, - 1), ( - 1, 1) and ( - 1, - 1), construct 
G, T(G), P(G), and H(G) as in the preceding example. Find the weights of each of 
these graphs. 
Proposition 4.1. 
w(T(G)):::;; w(P(G)) < w(H(G)). 
Proof. 
A Hamiltonian path can be obtained from a Hamiltonian cycle by re-
moving an edge (necessarily of positive weight). Thus w(P(G)) < w(H(G)). Since P(G) 
is a path, it is a connected acyclic graph and thus a tree. Since T(G) is a minimum-
weight spanning tree of G, its weight can be no more than that of P(G). Thus 
w(T(G)) :::;; w(P(G)). 
0 
Note that Proposition 4.1 is true for any weighted graph whose edge weights 
are positive. In particular, the edge weights don't have to correspond with dis-
tances in the plane. 
Our second major step will be to find an Eulerian cycle, using material from 
Section 8.2. (For an alternate explanation, independent of that section, see Exer-
cise 12.) Given any tree T, create a directed graph D(T) by replacing each edge e 
of T with two directed edges, one in each direction and both of weight w(e). By 
construction every vertex of D(T) has an equal number of edges directed in and 
out. By Theorem 2.3 D(T) contains a (directed) Eulerian cycle. We could use either 
426 

8:4 MINIMUM-WEIGHT HAMILTONIAN CYCLES 
a modified version of EULER or a depth-first search to create such a cycle. Evi-
dently, w(D(T)) = 2w(T). Let D denote an Eulerian cycle in D(T). 
Example 4.1 (continued). 
Figure 8.24 shows the graph D(T). D might consist of 
<r, c, b, c, d, c, r). 
(0,2) = d 
~)=' 
r = (0,0) 
(2,0) = h 
Figure 8.24 
Question 4.3. 
If G is the weighted graph from Question 4.2, find D(T) and some 
Eulerian cycle D. 
The third major step in our approximation algorithm will be to transform D 
into a Hamiltonian cycle, denoted by C. We need some bookkeeping and a standard 
look ahead device. Initially, set C : = D, and let r denote the first vertex of C. Begin 
traversing C, noting each visited vertex. Continue until you reach a vertex x and 
an out-directed edge (x, y) such that y is an already visited vertex. Suppose that 
within D, the edge (x, y) is followed by the edge (y, z). Modify C by replacing (x. y) 
and (y, z) with (x, z). If z is already visited and (x, z) is followed by (z, w), then 
replace (x, z) and (z, w) by (x, w), and so on. If the edge (x, y) is not followed by .. m-
other edge, then y = r, and C is the desired Hamiltonian cycle. 
Example 4.1 (once again). 
C initially consists of <r, c, b, c, d, c.r). Note that (b. c) 
visits c for the second time. Thus (b,c) and (c,d) are replaced by (h,d). At this 
stage C = <r,c,b,d,c,r). Now (d,c) visits c for the second time. Thus (d,c) and 
(c,r) are replaced by (d,r), and C = <r,c,b,d.r). Although (d,r) visits r for a second 
time, it is not followed by another edge. Thus (d, r) is the final edge in the Hamil-
tonian cycle. Figure 8.25 exhibits the Hamiltonian cycle thus obtained. Note that 
w(C) = 2 + 4J2,. 
d 
lA 
b 
Figure 8.25 
427 

8 
MORE GRAPH THEORY 
Question 4.4. 
Using the Eulerian cycle from Question 4.3, find a Hamiltonian 
cycle C. Determine w( C) and using the results of Question 4.2 verify that 
w(C) < 2w(H(G)). 
Proposition 4.2. 
After the edge replacements are complete (as described in the 
previous paragraph), C is a Hamiltonian cycle and w(C) < 2w(H(G)). 
Proof. 
Initially, D is an Eulerian cycle in the directed graph D( T). Since T is a 
spanning tree of G, D must visit every vertex of G. After all the edge replacements 
are complete, transforming D to C, no vertex is visited twice other than r. Thus 
C is a Hamiltonian cycle. By construction 
w(D) = w(D(T)) = 2w(T(G)) < 2w(H(G)) 
by Proposition 4.1. 
If w( C) s; w(D), then the proof is complete. Suppose that (x, y) and (y, z) in D 
are replaced by (x, .:-). Since w(x,.:-) equals the distance from x to :: and w(x. y) + 
wry, z) equals the distance from x to y plus the distance from y to .:-, the triangle 
inequality of plane geometry implies 
w(x,::) ::;; w(x, y) + wry, ::). 
Thus every time two edges are replaced by one, :the weight of the cycle cannot 
increase. Thus w(C) ::;; w(D). 
D 
Note that we have solved the minimum-weight Hamiltonian cycle problem 
not only in the case where edge weights represent distances in the plane, but also 
for every weighted complete graph such that w(x,::) ::;; w(x, y) + w(y,.:-) for every 
triple of vertices x, y, and .:-. (See also Exercise 7.) 
Algorithm APPRO X HAM 
428 
STEP 1. Input G, a weighted complete graph 
STEP 2. Use KRUSKAL to obtain T, a minimum-weight spanning tree of G 
STEP 3. Create the digraph D(T) by replacing every edge of T by two oppo-
sitely directed edges 
STEP 4. 
Use EULER, modified as in Exercise 2.18, to obtain D an Eulerian 
cycle in D(T) (Suppose that D = (e l , .... e2V-2) and for allj, ej = 
(xj,y).: 
STEP 5. Set C : = <x I> and mark x 1 visited 
STEP 6. For j = I to 2 V -
3 do 
STEP 7. If Yj is not marked visited, set C : = C followed by .vj: mark Yj 
visited 
STEP 8. Set C : = C followed by x l' 
STEP 9. Output C and stop. 

8:4 MINIMUM-WEIGHT HAMILTONIAN CYCLES 
Notice that APPROXHAM is a polynomial algorithm: Both KRUSKAL and 
EULER are polynomial algorithms and the comparisons in step 6 arc few. (See 
also Exercise 10.) Thus APPROXHAM is efficient and guarantees a spanning 
cycle that is at most twice as long as the shortest one. The ideas of this algorithm 
have been extended so that a spanning cycle within 50 percent of optimal is al-
ways produced. The extended algorithm is more complex and uses the so-called 
Minimum-Weight Matching algorithm alluded to in Section 8.2. 
These results may sound weak, but in practice APPROXHAM is considered 
useful. Considerable experimental work has been done on APPROXHAM, and on 
average it appears to produce a cycle fairly close to the shortest. However, there 
are no theoretical results that establish the quality of its average-case behavior. 
Another useful approximation algorithm is the greedy algorithm: At each point 
visit the nearest unvisited neighbor. £t also seems to work well on average, but 
in the worst case it is known only to produce a cycle C for which w(C)::; 
(f! + log(V)l/2)w(H(G)) if G is a graph with V vertices (see also Exercise 6.) 
EXERCISES FOR SECTION 4 
1. Suppose that you are required to drill holes at (0,0), (I, 1), (3,0), (2,2), (1,2), 
(3,3), (I. 3), and (0,2). Assuming that your drill starts and finishes at the origin, 
find an optimum drilling schedule. 
2. For each of the weighted graphs shown, find a minimum-weight Hamiltonian 
cycle. 
3 
7 
4 
6 
3 
4~ 
2 
8 
3 
4 
3 
7 
4 
3 
2 
2 
(a) 
(b) 
(e) 
3. Construct an algorithm that wilL given a weighted complete graph, Jse 
PERM (see Section 3.4) to generate all possible Hamiltonian cycles and thus 
find a minimum-weight one. Run your algorithm on the graph shown in part 
(a) of the preceding problem. Discuss the complexity of your algorithm. 
4. Two Hamiltonian cycles on the n-clique Kn are considered the same if ont; is 
a cyclic rotation of the other or if one is the reverse of the other. Expl.\in 
why KII contains (11 ~ 1 )!/2 different Hamiltonian cycles. 
~29 

8 MORE GRAPH THEORY 
5. With the same understanding of when two Hamiltonian cycles are different 
as in the previous problem. determine the number of difTerent Hamiltonian 
cycles on the complete bipartite graph K",,,. 
6. Find a set of points in the plane for which the greedy algorithm (sec the 
last paragraph of this section and Section 5.5) does not produce a minimum-
weight Hamiltonian cycle. Here the weight of an edge is the distance between 
the corresponding vertices. 
7. Find a weighted graph G such that w(C) > 2w(H), where C is the Hamiltonian 
cycle produced by APPROXHAM and H is a minimum-weight Hamiltonian 
cycle. 
8. Suppose that G is a weighted graph that represents cities serviced by an airline 
and where the weight of an edge (x. y) represents the cost of i1ying from x to 
y. Explain why the triangle inequality might not hold for this graph. 
9. Use APPROXHAM to find Hamiltonian cycles in the graphs whose under-
lying point sets are 
(a) ((O,O),(2,O),(4,O),(3,1),(I,3)} 
(b) [(0,0),(3,0),(2, 1),(1,2),(0,3)} 
(c) {(O, 0), (5, 1),(6,3),(4,4),(2,7),(1,8),(3,4)) 
10. Find an integer d such that APPROXHAM uses O(Vd) comparisons when 
finding a Hamiltonian cycle on a set of V points in the plane. 
11. Find an example of a weighted graph that has two different minimum-weight 
spanning trees such that starting with these two APPROXHAM produces 
different-weight Hamiltonian cycles. 
12. Here is an alternative explanation for the second major step of APPROX-
HAM, Imagine a tree T drawn with a circle C surrounding it. Then imagine 
that C is a balloon, which when popped collapses in and surrounds T tightly. 
Explain how a clockwise traversal of the collapsed cycle creates a cycle D 
on T that traverses every edge of T twice, once in each direction. 
13. Turn the idea of the preceding exercise into a precise algorithm suitable, in 
particular, for use within APPROXHAM. 
14. Here is an algorithm called NEARINSERT that finds a short Hamiltonian 
cycle in a weighted complete graph G. Let C 1 = (r) an arbitrary vertex. In 
general, if Cj is a)-cycle, let v be some vertex in V(G) -
VIC) that is as close 
as possible to some vertex in Cj , say u, Create Cj + 1 by inserting v into Cj im-
mediately following u. Run NEARINSERT on the graphs of Exercise 9. 
15. Create an algorithm F ARINSERT that parallels the algorithm from the pre-
ceding exercise except that the vertex to be inserted is as far as possible from 
the already created cycle. Run FARINSERT on the graphs of Exercise 9. 
16. Suppose that you arc given n points in the plane that are contained in a 
",;--;; by viz square. It has been conjectured that on average the minimum-weight 
430 

8:5 GRAPH COLORING AND AN APPLICATION TO STORAGE ALLOCATION 
spanning cycle has length at most 4~. Discuss why this is a plausible conjec-
ture and investigate the examples of this section to see if they support this 
conjecture. 
17. Construct an algorithm that finds a Hamiltonian cycle in a weighted com-
plete graph KII by l'irst greedily discarding as many heavy edges as possible 
subject to the condition that the degree of each incident vertex exceeds n12. 
and then uses HA MCYCLE from the previous section to find a Hamiltoman 
cycle. Run your algorithm on the graphs from Exercise 9. 
8:5 GRAPH COLORING AND AN APPLICATION 
TO STORAGE ALLOCATION 
The algorithms of this book have been presented following the format of the Pascal 
programming language. Pascal is a "high level" language whose statements can 
be translated by a compiler into machine language statements. These are the in-
structions that the central processing unit (cpu) executes. To execute the prognm 
the computer must store the machine language instructions plus the values of all 
variables used in the program. While the program occupies a constant block of 
memory, there is choice in the storage of variables. Efficient use and reuse of 
memory locations can save significantly on the total amount of memory needed. 
Example 5.1. 
Consider an algorithm that, among other things, calculates the vol-
ume of a rectangular box. 
Algorithm VOLUME 
STEP 1. Input Length. Width. Height 
STEP i. 
Area: = Length * Width 
STEP j. 
Volume: = Area * Height 
The values of the variables Length. Width. Height. Area. and Volume c011ld 
be stored in. say, memory locations 0 through 4, respectively. In a more efficient 
storage allocation scheme the variable Volume could be assigned to either memory 
location 0 or I. provided that there is no use for the variables Length or Width 
after step j. 
The compiler assigns variables to memory locations. Two different variables 
can be assigned to the same memory location, provided that both variables ~tre 
never needed in the program at the same time. Thus the mapping of the variables 
~31 

l! 
:YIORE GRAPH THEORY 
to memory locations need not be a one-to-one functllOn, but when appropriate two 
or more variables can double up in one location. 
Definition. 
Two variables in a program (or algorithm) are said to be non inter-
fering if, regardless of the input values, at no instant during the execution of the 
program are both variables needed at that instant or needed in memory for the 
execution of some subsequent step. Otherwise, the two variables are said to be 
interfering. 
Example 5.1 (continued). 
The variables Volume and Length are non interfering 
variables. as are Volume and Width. Length and Width are clearly interfering 
variables. So are Length and Height, since the value of Height must be kept in 
memory for use in step j. 
Example 5.2. 
Suppose that the Post Office otTers a choice of rates to magazine 
publishers. The cost of mailing is a function of either the product of the area of 
the mailing envelope and its weight, or twice the volume of the envelope. 
Algorithm POSTAGE 
STEP 1. 
STEP 2. 
STEP 3. 
STEP 6. 
STEP 7. 
STEP 8. 
STEP 9. 
STEP 12. 
Input Length. Width, Weight 
Area: = Length * Width 
Costl : = Area * Weight 
{Some steps that use only Cost 1.] 
Input Height 
Volume: = Area * Height 
Weight:= 2 
Cost2 : = Volume * Weight 
[Some steps that use only Cost2.: 
Print Cost 1. Cost2. Volume 
Notice that Height and Weight are noninterfering variables. since Height is 
only used in steps 6 and 7 whereas Weight is needed in steps 1. 2. 3, 8, and 9. 
However, Costl and Height are interfering variables. since the value of Cost I must 
be maintained from step 3 to step 12. 
Question 5.1. 
For the variables Length. Width. Height. Weight. Area. Volume. 
Cost!. and Cost2 from the preceding example. determine which pairs are non-
interfering and which interfering. Find a set of four variables. every pair of which 
is interfering. Are there other sets of four mutually interfering variables? Are there 
any sets of li.ve variables with every pair interfering? 
Ideally, how should the compiler assign variables to memory locations'! We 
assume that all values of a variable should be assigned to just one location during 
432 

8:5 
GRAPH COLORING AND AN APPLICATION TO STORAGE ALLOCATION 
the execution of the program. Next the storage allocation scheme used by the 
compiler should usc as few memory locations as possible. In addition. it should 
determine the allocation of memory quickly. There is a graph naturally associated 
with this problem. and we shall see that storage allocation can be accomplished by 
"coloring" the vertices of this graph. Furthermore, once the corresponding graph 
is created, allocation can be determined quickly if there is a good algorithm to do 
the related graph coloring. 
The corresponding graph is called the interference graph. Specifically, this 
graph has a vertex for each variable in the program, and two vertices are joined 
by an edge if they are interfering. 
Example 5.2 (continued). 
Figure 8.26 exhibits the interference graph where the 
vertices are labeled with abbreviations of the names of the corresponding variables. 
Wt 
W 
A 
Cl 
C2 
Figure 8.26 
Question 5.2. 
Construct the interference graph for the program from Example 5.1. 
Before we proceed with graph coloring, it is appropriate to interject more 
realism in our storage allocation model. In fact, it is a complex task for a com-
piler (or for a human) to decide whether or not two variables are interfering. This 
would involve the potentially infinite task of checking whether or not two variables 
interfere during the program given any possible input. However, it is possible for 
a compiler to determine quickly that certain pairs of variables are always non-
interfering. These are declared to be noninterfering, and then to be on the s,Je 
side all other pairs are declared to be interfering. Thus the "interference grapl" 
derived and used by the compiler may have more edges than the true interference 
graph. In the simple examples in this section (both algorithms without loops Jr 
branching), it is straightforward to determine the real interference graph. 
We shift now to graph "colorings." Graph colorings began with the Four-ColJr 
Problem. a "puzzle" that asks whether every map can have its countries colofl~d 
with one of four colors so that no two countries with a border in common recei ve 
the same color. This problem intrigued mathematicians for more than a century 
until it was solved in 1976. (The answer is yes, every map can be 4-colored. The 
proof due to Kenneth Appel and Wolfgang Haken is long and intricate and in-
cludes a computer check of over 1400 cases.) 
433 

!l 
MORE GRAPH THEORY 
Definition. 
For k a positive integer, a graph G is said to be k-colored (or k-
colorable) if each vertex is (or can be) assigned one of Ie colors so that no two 
adjacent vertices receive the same color. The chromatic number of G, denoted by 
X(G), is the minimum number Ie such that G can be Ie-colored. The clique number 
of a graph G, denoted c1(G), is the largest number r such that G contains an r-cliqu~ 
as a subgraph. 
We have seen 2-colorability before in Section 5.2: There a 2-colorable graph 
was called bipartite. 
Example 5.3. 
The graphs G and H in Figure 8.27 are colored with A, B, C. and 
D. The graph G can be 3-colored (replace the D with a B) as well as 2-colored (in 
addition replace C by an A); however, H cannot be 2-colored because it contains 
three mutually adjacent vertices. The clique numbers of these graphs are 2 and 3, 
respectively. 
ABC 
OJ 
B 
A 
G 
Figure 8.27 
D 
A 
B 
D 
B 
C 
A 
H 
c 
Storage allocation problems can be translated into problems about coloring~; 
of the interference graph. Associate a different color with each memory location 
Then the interference graph receives a coloring by assigning a vertex, labeled b) 
a variable, the color of the memory location to which the variable is assigned 
Conversely, a graph coloring (with the same colors as associated with memor) 
locations) prescribes a memory allocation for variables. In both these assignments 
the graph is correctly Ie-colored if and only if an assignment of k memory locations 
is made in which pairs of variables that are interfering are assigned to different 
memory locations. 
Here are some central problems in the theory of graph colorings. 
Problem A. 
Construct an algorithm that, given a graph G and an integer k, deter-
mines if G can be Ie-colored, and if so finds a k-coloring. 
Problem B. 
Construct an algorithm that, given a graph, determines its chromatic 
number and finds a corresponding coloring. 
Problem C. 
Does the chromatic number of a graph equal its clique number? 
434 

R:5 
GRAPH COLORING AND AN APPLICATION TO STORAGE ALLOCATION 
These problems translate to important ones for storage allocation. Given a 
program, suppose that the compiler has declared certain pairs of variables to ')C 
noninterfering and all others to be interfering. In this context, Problem A asks 
for an algorithm to determine if k memory locations are sufficient. and if so, to find 
such an allocation. Problem 8 asks for an algorithm to determine the minimum 
number of storage locations needed, and Problem C asks whether the answer to 
Problem 8 is the same as the maximum number of mutually interfering variables. 
(Look back at Question 5.1.) 
Question 5.3. 
The "intcrference graph" G created by the compiler may have mere 
edges than the true interferences graph H. Explain why X(G) z X(H). If the compiler 
assigns k = X(G) memory locations to a program based on a coloring of G, explain 
why two "truly" interfering variables will not be assigned the same memory locaticon. 
Question 5.4. 
Determine the chromatic number and the clique number of ea.:h 
graph shown in Figure 8.28. 
Figure 8.28 
(v) 
Question 5.5. 
Solve Problem A for k = 1. 
Problem A for k = 2 is not difficult. It is a frequent circumstance that good 
algorithms follow from insightful theorems. Theorem 5.1, a characterization of 2-
colorable graphs, is just such an instance. It should be clear from Example 5.3 
and Question 5.4 that a graph containing a cyc:le with an odd number of vertices 
cannot be 2-colored. (See Exercise 4.) Thus a 2-colorable graph cannot contain 
an odd cycle. Surprisingly, this is the only condition needed to ensure that a graph 
is 2-colorable. 
Theorem 5.1. 
A graph G is 2-colorable if and only if G contains no odd cycle. 
Proof'. 
We prove that if G contains no odd cycle, it is 2-colorable. Select any 
vertex r to be the root and color it red. For each vertex x in G if the distance 
from r to x is even, color x red. Otherwise, color x blue. If G is not connected, 
pick a root in each component and repeat. This procedure places 2 colors on the 
vertices of G, but does each edge join vertices of different colors'? 
435 

II 
MORE GRAPH THEORY 
Example 5.4. 
In the two graphs of Figure 8.29 each vertex, besides the root r, 
is labeled with its distance from r and the color it receives in the procedure 
described above. 
r, R 
1, B 
2,R 
r, R 
1, B 
1, B 
2,R 
3, B 
1, B 
2,Ri 
2, R 
2, R 
2,R 
3,B 
4, R 
2,R 
3, B 
3,B 
G 
H 
Figure 8.29 
To return to the proof, suppose that two vertices, say x and y, with the same color 
are joined by an edge, If Px denotes a shortest path from r to x and Py denotes 
a shortest path from r to y, then Ipxl and IP yl are either both even or both 
odd. In either case their sum is even. The cycle consisting of P x followed by the 
edge (x, y) followed by P v (in reverse order) is an odd cycle unless Px and P y have 
edges in common. In this case these paths are easily seen to contain an odd cycle. 
This contradiction forces us to conclude that there is no such edge joining two 
vertices of the same color, that is, every edge joins two vertices that received dif-
ferent colors and so the graph is 2-colored. 
iJ 
Since the distance from any vertex to the root can be determined by a breadth-
first search as described in Section 8.1, this proof suggests an efficient algorithm 
using BFS to test for 2-colorability (see Exercises 8 and 9). 
It would be reasonable to think that there should be an analogue of Theorem 
5.1 and the accompanying algorithm for 3-colorable graphs. In fact, there is no 
known characterization of 3-chromatic graphs or any efficient 3-coloring algo-
rithm. Furthermore, it is unlikely that any will be discovered. 
In the remainder of this section we present two algorithms that attempt to 
k-color a graph, where k is any positive integer. Th.e idea of the first algorithm, 
known as Sequential Coloring, is to dive in and start coloring using as few colors 
as possible. We consider the vertices from I up to V in order and to each vertex 
v we assign the first available color not already assigned to a neighbor of v. 
Algorithm SEQUENTIALCOLOR 
STEP 1. Input G with V vertices x to· .. ,xv 
{Let the potential colors be 1,2., .. , V,: 
~36 

8:5 
GRAPH COLORING AND AN APPLlC\TlON TO STORAGE ALLOCATION 
STEP 2. 
For I = I to V do 
STEP 3. Create LJ = <1,2, .... f) :L[ is the list of colors that mi.~ht 
get assigned to x I' : 
STEP 4. For I = I to V do 
Begin 
STEP 5. Set c[ : = first color in Lr : c[ is the color assigned to x I : 
STEP 6. 
For each J with I < J and (x [, x,) in E( G) do 
End 
STEP 7. Set L,: = L, -
c[ 
: x, cannot receive the same 
color as Xl': 
STEP 8. Output each vertex, the color it received, and the total number of 
colors used; then stop. 
Example 5.5. 
Table 8.6 is a trace of SEQUENTIAL COLOR applied to the graph 
in Figure 8.30. With the given ordering of the vertices SEQUENTIALCOLOR 
produces the coloring as shown. 
Table 8.6 
Step No. 
3 
3 
3 
3 
5 
7 
5 
7 
5 
7 
3 
2 
0>-------<0>-------<0)------<0 
xl 
x4 
X3 
x2 
Figure 8.30 
LI 
J 
<I) 
2 
<1,2) 
3 
(1,2,3) 
4 
(1,2,3,4) 
4 
2 
2 
3 
3 
2 
3 
4 
4 
3 
LI 
(2.3,4 ) 
(2,3) 
<3. 4) 
Question 5.6. 
Run SEQUENTIALCOLOR on the labeled graphs shown In 
Figure 8.31. 
SEQUENTIALCOLOR clearly places different colors on adjacent vertices; 
however, sometimes it uses more than the minimum number of colors. This point 
is important-we cannot be sure that the results of SEQUENTIALCOLOR .He 
437 

8 
MORE GRAPH THEORY 
Figure 8.31 
the best possible. But does it use just one extra color or just a "'few" extra colors 
(whatever that means)? The answer is no; this algorithm might use far too many 
colors. Precisely, for every positive integer m there are graphs of chromatic number 
k on which SequentialColor uses k + m colors. Exercise 29 illustrates this phenom-
ena on 2-chromatic graphs. Thus looking back at the basic coloring problems, 
this algorithm might or might not solve Problem A (can a graph be k-colored?). 
How efficient is SEQUENTIALCOLOR? Here the news is good. The loop 
in step 2 requires no more than V2 assignments. The loop at step 4 has two pur-
poses. The coloring (step 5) requires one assignme.nt for each vertex. Updating 
the lists of possible colors requires one comparison and one assignment for each 
edge in the graph. Since E::;; V2, SEQUENTIALCOLOR is an O(V2) algorithm 
(counting either comparisons or assignments or both.) 
However, SEQUENTIALCOLOR can be used to find the chromatic number 
of a graph and hence to answer Problem B. As you saw in the preceding question, 
the number of colors used by SEQUENTIALCOLOR depends on the numbering 
of the vertices not on the graph alone. (The chromatic number depends only on 
the graph.) If we try every possible numbering of the vertices and with each num-
bering run SEQUENTIALCOLOR, then the chromatic number of the graph will 
be the minimum number of colors used in all these runs. This is the content of 
the next theorem. 
Theorem 5.2. 
Let x( G) be the chromatic number of a graph G. Then there is a 
labeling of the vertices ofG with X 1'X 2 ' ... ,Xv such that SEQUENTIALCOLOR 
run on G with this labeling uses x( G) colors. 
Proof'. 
Suppose that G is colored with colors 1, ... ,R. Label the vertices of G 
so that if I < J, then every vertex colored I receives a label before any vertex 
colored J. One way to accomplish this is to label all the vertices colored 1 (in any 
order you like), followed by all the vertices colored :2 (in any order you like), con-
tinuing until all vertices are labeled. If SEQUENTIALCOLOR is applied to G 
438 

8:5 GRAPII COLORING AND AN APPLICATION TO STORAGE ALLOCATION 
with this labeling, then all the vertices originally colored 1 get colored 1. The 
vertices originally colored 2 might be colored with either 1 or 2. In general, 1 he 
vertices that were originally colored I will be colored with one of 1, .. " I. Thus 
no more than R colors are used by SEQUENTIALCOLOR. When R = X(G), 
exactly R colors will be used, by definition of X(G). 
U 
The consequence of Theorem 5.2 is that SEQUENTIALCOLOR will tlnd the 
chromatic number of a graph if all possible orderings of the vertices are tried. 
There are V! such numberings and so the number of steps of this approach is 
more than V!, making this a slow algorithm. However, we next consider a modifI-
cation of this approach known as Backtracking. This will be more efficient, but 
how much more we don't divulge yet. 
Suppose that we want to know whether a given graph is 3-colorable. The idea 
of Backtracking is to try systematically all possible 3-colorings of the graph. The 
algorithm begins by trying to 3-color the graph using SEQUENTIALCOLOR, 
but if a fourth color is needed, it discontinues this approach. The algorithm back-
tracks (or backs up) to the last vertex, where there was choice in the coloring, and 
makes a different choice. 
Example 5.6. 
Figure 8.32 shows a graph that can be 3-colored, but with the given 
vertex numbering SEQUENTIALCOLOR will 4-color it. A partial 4-colorinr IS 
given in Figure 8.32. 
Xl, 1 
xs,4 
X4, 3 
x 2, J 
x6 
x7 
x3,1 
Figure 8.32 
Once a fourth color is needed on x 5, we backtrack to X 4 . There is no choice 
for its color if we are to 3-color the graph. However, if we backtrack to X3' it can 
be recolored with 3. Then colors 1 and 3 are available for x4 and x s, respectively. 
Furthermore, this partial coloring extends to a 3-coloring of the whole graph by 
placing colors 3 and 1 on X6 and X 7, respectively. 
In this process of backtracking either a 3-coloring is discovered or all possible 
3-colorings fail,. 
Here are some details of the algorithm BACKTRACKCOLOR. The number 
of colors that may be used is denoted by N. The possible colors are denoted 
1,2, ... ,N. The vertices are denoted by .\),.\2,'" ,Xv, and CI contains the COlor 
that is used on the vertex XI' Without loss of generality we may assume that 
439 

!I 
MORE GRAPH THEORY 
vertex x 1 gets color 1; initially, C( = 0 for I = 2, ... , V to denote that these vertices 
are not colored. The algorithm parallels SEQUENTIALCOLOR: The vertices arc 
colored in increasing numerical order, but if it ever is the case that the coloring 
cannot be extended to other vertices, the algorithm moves back one vertex and 
tries to recolor it with the next larger available color. The algorithm repeats this 
backtracking until either a vertex is found that can receive another color or until 
it finds that no vertex can be recolored. In the former case the algorithm begins 
again, trying to extend the partial coloring; in the latter case essentially all color-
ings fail, that is, the graph cannot be colored with N colors. The variable FOR-
WARD keeps track of when the coloring is being extended (and FORWARD is 
TR UE) or when backtracking is occurring (and FORWARD is FALSE.) 
Algorithm BACKTRACKCOLOR. 
STEP I. 
Initialize 
Input G with V vertices and a positive integer N (The algorithm will 
determine if G can be N -colored.] 
Set C 1 := 1 (X1 gets color I.] 
Set Ci : = 0 for i = 2, ... , V 
Set 1 : = 2 {1 will index the vertex currently being colored.] 
Set FORWARD:= TRUE 
STEP 2. 
While 1 < V + 1 do 
STEP 3. If FORWARD = TRUE then 
Call Procedure COLOR 
Else (FORWARD = FALSE) 
Begin 
STEP 4. c]:= 0 
STEP 5. 1: = 1 -
1 
STEP 6. 
If 1 =I I, then 
Call Procedure COLOR 
Else :1 = 1) 
Output "There is no N -coloring of G" and stop. 
end {Step 3} 
STEP 7. Output the coloring and stop. 
Procedure COLOR 
440 
STEP l. Find smallest K > c, such that if 1< 1 and (x[,xJ) is in E(G), then 
c[ 1= K 
STEP 2. If K ~ N, then 
Begin 
STEP 3. Set Cf : = K 
STEP 4. Set 1 : = 1 + I 

8:5 GRAPII COLORING AND AN APPLICATION TO STORAGE ALLOCATION 
STEP 5. Set FORWARD: = TRUE 
End 
Else [K > N] 
STEP 6. Set FORWARD:= FALSE 
End. 
Note the similarity between BACKTRACKCOLOR and the algoriti1m 
DFS-HAMCYCLE of Section 8.3. 
Example 5.6 (continued). 
Table 8.7 is a trace of BACK TRACKCOLOR applied 
to the graph in Figure 8.32 with N = 3. 
Table 8.7 
Step No. 
.J 
K 
FORWARD 
e[l, 2, 3,4, 5,6, 7J 
Main 
2 
TRUE 
[1,0,0,0,0,0, OJ 
COLOR 1 
2 
2 
35 
3 
2 
[1,2,0,0,0,0,OJ 
COLOR 1 
3 
3 5 
4 
TRUE 
[1,2, LO,O,O,OJ 
COLOR 1 
4 
3 
3 5 
5 
TRUE 
[1,2, U,O,O,OJ 
COLOR 1 
5 
4 
6 
5 
FALSE 
Main 
4 5 
4 
[1,2, U,O,O,OJ 
COLOR 1 
4 
4 
6 
4 
FALSE 
Main 
4-5 
3 
[1,2,1.0,0,0,OJ 
COLOR 1 
3 
3 
3-5 
4 
TRUE 
[1.2,3,0,O,O,OJ 
COLOR 1 
4 
3 -5 
5 
TRUE 
[1,2, 3, I, 0, 0, 0 J 
COLOR 1 
5 
3 
3··5 
6 
TRUE 
[1,2,3, 1,3, 0, OJ 
COLOR 1 
6 
3 
3-5 
7 
TRUE 
[1,2,3,1,3,3,OJ 
COLOR 1 
7 
3 5 
~ 
TRUE 
[1,2, 3, 1,3, 3, 1 J 
Main 
7 Slop. 
Question 5.7. 
Trace BACKTRACKCOLOR applied to the complete graph 1\.4 
with N = 3. 
That BACKTRACKCOLOR is not a good algorithm can be seen by imJg-
ining an attempt to (Il -
I)-color K" for any 11 > I. To begin with. the colors 
-441 

II 
MORE GRAPH THEORY 
1,2, ... ,(n -
1) are assigned to Xl" .. ,Xn _ 1; however, this coloring cannot be 
completed. Backtracking to Xn -2' we find that it can be recolored with n -
1 and 
Xn _ 1 with n - 2. but still there is no color left for vertex n. In general. the 
algorithm will backtrack to Xl with / > 1 and try all colors not on vertices 
Xl, ••. , Xl _ [. Since these vertices receive / -
1 distinct colors, there are 
(n-I)-(l-1)=n-/ 
colors that are tried on x I for every fixed coloring of the Xl" .. 'Xl _ [. This means 
that precisely 
(n -
2)(n -
3) ... (n -
1) ... ·2· 1 = (n - 2)! 
colorings are tried before the algorithm reports that K n cannot be (n -
I)-colored. 
Thus BACKTRACKCOLOR is exponential in the worst case. 
Exercises 40 and 41 ask you to verify that BACKTRACKCOLOR is correct. 
Exercise 43 suggests a recursive version of this coloring scheme. 
All known algorithms for deciding whether a graph can be k-colored (for 
k > 2) are exponential. Thus the coloring problem is in the same unresolved state 
as the Hamiltonian cycle problem, the Traveling Salesrepresentative problem, and 
the Satisfiability problem. It is also one of the NP-Complete problems (as defined 
in the end of Section 8.3), which means that there is a polynomial algorithm for 
one of these four problems if and only if there is a polynomial algorithm for all 
four of them. However, graph coloring is an important problem with applications 
to timetable scheduling, routing problems, circuit board testing as well as to stor-
age allocation. Thus coloring algorithms are used in practice. There are ways to 
seemingly improve the typical running time of these algorithms. For example. 
vertices of large degree are in some sense the hardest to color, and so numbering 
the vertices of largest degree with the smallest numbers may lead to a reasonable 
labeling on which to run sequential coloring. In some applications characteristics 
of the graphs can be incorporated to increase the efficiency of the algorithm. A 
variation is considered in Exercise 39. 
Curiously, there are no known efficient approximate coloring algorithms. like 
the approximation algorithm of Section 8.4. Precisely, there is no known algorithm 
that will color a graph G with 0(;«( G)) colors. The best that is known is that there 
is an algorithm that will color a graph G with O({V/log(V)}X(G)) colors, where 
V is the number of vertices of G. Furthermore, it has been shown that the question 
of whether a graph is (cX(G))-colorable for any c less than 2 is also an NP-Complete 
problem. Thus in the worst case, approximations for graph-coloring algorithms 
are also very hard. 
Look back at Problem C of our fundamental graph-coloring problems: this 
problem asked whether the chromatic number of a graph equals the size of the 
largest clique in it. Immediately, we saw that the chromatic number could be 
greater than the clique number. The clique number of a graph gives a lower bound 
442 

8:5 GRAPH COLORING AND AN APPLICATION TO STORAGE ALLOCATION 
on the chromatic number and so if an algorithm, like SEQUENT[ALCOLOR, 
ever achieves a coloring with cl( G) colors, then the numbers of colors used is the 
minimum possible. However, determining the: clique number of a graph is also 
one of the NP-Complete problems. A graph G is called perfect if X(H) = cl(H) for 
every H that is an induced subgraph of G. It has recently been shown that there 
is a polynomial algorithm to determine whether a perfect graph can be k-colored; 
this algorithm uses the recent Ellipsoid Method of Linear Programming. On the 
other hand, there is no known polynomial algorithm to determine whether an 
arbitrary graph is perfect. 
Despite all this bad news from the standpoint of efficient algorithms, the 
storage allocation problem, with which we began this section, is one that musl be 
confronted by compilers and their designers. In the past, coloring algorithms have 
been used and modified for special needs, and in these cases they were etfectivG in 
solving storage allocation problems. Recently, progress has been made by Jeanne 
Ferrante who has used a process known as "renaming" to get a better algorithm 
that runs in polynomial time and is applicable in all cases. [n renaming, a new 
variable is created and assumes the value of an old variable at some points in the 
program. This increases the number of variables (and the number of assignment 
statements), but the new number of variables remains a polynomial in the number 
of original variables; the necessary program rewriting can be accomplished in 'me 
pass through the program. With this change there is a good algorithm for storage 
allocation that assigns the minimum possible number of memory locations, which 
is the maximum number of variables with every pair interfering at some poin: in 
the program. The latter number is called Maxlive. [n graph theory terms, seme 
vertices of the interference graph are split so that the total number of vertices is 
a polynomial of the original V, and then there is a good algorithm that colors the 
new graph G' in Maxlive colors. Since Maxlive= cl( G) s X( G) for every interference 
graph G, we see that G' has been colored with the minimum number of colors. 
(See also Exercise 2.) 
If, in addition, a compiler can reorder the statements of a program, then it 
may be possible to reduce the value of Maxlive and hence the amount of mem;)ry 
needed. 
Example 5.7. 
The following reordering reduces Maxlive from 2 to 1. 
Program One: Maxlive = 2 
I. Define A 
2. Define B 
3. Use A 
4. Use B 
Program Two: Maxlive = I 
I. Define A 
,.., 
Use A 
3. Define B 
4. Use B 
However. it has been shown that determining the order of a program for which 
Maxlive is a minimum is an NP-Complete problem! No matter where you look, 
there are hard unsolved algorithmic problems .. 
443 

8 MORE GRAPH THEORY 
EXERCISES FOR SECTION 5 
I. Here is an algorithm that interchanges the values of two variables (from 
Chapter 2.) 
STEP 1. xold: = x 
STEP 2. x: = y 
STEP 3. y: = xold 
Construct the interference graph for this algorithm, find a coloring of the 
graph with the minimum possible number of colors, and fInd a storage alloca-
tion scheme using this many memory locations. 
2. Construct the interference graph G of the following algorithm 
STEP 1. 
Input A, B 
STEP 2. A: = A * B 
STEP 3. C:= A2 
STEP 4. D:= C 2 
STEP 5. E:= D2 
STEP 6. B: = 3 
STEP 7. E: = E * B. 
Determine X(G) and e1(G). Find a way to "rename" at least one variable so 
that if G' is the resulting interference graph and X(G') memory locations are 
used, then X( G') = e1( G'). 
3. Here is one possible algorithm for storage allocation. Assign each variable 
to a different memory location. Thus, if a program has Y/ variables. say 
V[,V2 , ... ,Vn, for i= 1,2, .... Y/, assign V; to memory Mi - 1. Explain why 
this allocation is quick and avoids all conflicts. What is the disadvantage of 
this algorithm? 
4. Let C j be a cyele withj vertices. Find X(C) and el(C) for allj. 
5. Find a 4-coloring of the following graphs if possible. For each graph deter-
mine whether its chromatic number is four or not. 
6. Explain why X(G) :::0: e1(G) for every graph G. Describe an infinite set of graphs 
for which X(G) = el(G) and an infinite set for which X(G) > el(G). 
444 

8:5 
GRAPH COLORING AND AN APPLICATION TO STORAGE ALLOCATJON 
7. Explain why a graph with V vertices can always be V-colored. Characterize 
those graphs on V vertices for which x( G)= v. If G is a graph with V vertices 
and X(G) = V-I, what can you say about cI(G)? 
8. Write out the details of a BFS algorithm that tries to 2-color a graph. Run your 
algorithm on the following graphs. 
9. Show that the complexity of the algorithm from the preceding problem IS 
O(V 2 ). 
10. Prove that if G is a graph with maximum degree d, then x( G) :s; d + I. 
11. Prove that if G is a connected graph with maximum degree d (d > 2), then 
X(G) :s; d unless G = Kd + 1. 
12. For k = 1,2.3. and 4 find examples of graphs with maximum degree d sllch 
that X(G) = d -
k. 
13. Suppose that 'X( G) denotes the largest set of vertices of a graph. no twc of 
which are adjacent. (See also Chapter 5, Supplementary Exercises 20 to 25.) 
Then prove that if G is any graph with V vertices, then x( G) :::::: Vlrx( G). 
14. If G is a graph with V vertices and maximum degree d, prove that X(GI :::::: 
V/(V - d). 
15. If G
C is the complement of the graph G (as defined in Chapter 5, Supplemen-
tary Exercise I), prove that X( G) + x( G'") ~; V + I, where V is the number of 
vertices of G. 
16. Color the following map with three colors so that no two regions with a 
border in common receive the same color. Can fewer colors be used? 
Find a map that can be 2-colored and one that can be 4-colored but not 
3-colored. 
...45 

II MORE GRAPH THEORY 
17. (a) Draw a map. From this construct a graph as follows: Create a vertex for 
every region of the map and join two vertices by an edge if the corre-
sponding regions have a border in common. Show that the graph can be 
drawn so that no two edges cross. The graph is called the dual of the 
original map. 
(b) Next pick a graph G drawn so that no two edges cross. Find a map such 
that the dual of the map is the graph G. 
18. In general, let M be a map and G(M) the dual graph derived from it (as de-
fined in Exercise 17.) Explain why X(G(M)) is precisely the minimum number 
of colors needed to color every region of M so that no two regions with a 
border in common receive the same color. 
19. A graph is called planar if it can be drawn in the plane so that no two edges 
cross. Prove that if G is a connected. planar graph, drawn with F faces (in-
cluding the outside face) then V -
E + F = 2. This result is known as Euler's 
formula. (Hint: First prove this for trees. Then use induction on the number 
of edges of the graph.) 
20. Prove that neither Ks nor K 3 ,3 is a planar graph. (Hint: Use Euler's formula.) 
21. Prove that for a planar graph the average degree, 2EjV, is less than 6. Use 
this to conclude that every planar graph contains a vertex of degree 5 or less. 
22. Prove that every planar graph can be 6-colored. 
23. Prove that every planar graph can be 5-colored. 
24. There once was a farmer with a large (square) tract of farm land. The farmer 
had five children and decided to divide the land into five pieces. one for each 
child, but to facilitate communication she wanted each piece to have a border 
in common with all other four pieces. Is such a division possible? If so, give 
an example of such a division (the pieces don't need to be the same size.) If 
not, find a division with each piece having at least a corner (or vertex) in 
common with every other piece. 
25. Let G be a connected planar graph, drawn in the plane. Prove that G is 
Eulerian if and only if the resulting map can have its regions 2-colored. (Or 
in the notation of Exercises 17 and 18, if G is drawn in the plane and M 
is the resulting map, then G is Eulerian if and only if G(M) is bipartite.) 
26. Prove that if G is a planar Eulerian graph such that every region of the graph 
in the plane has exactly three sides. then G can be 3-colored. 
27. Design an algorithm that upon input of a graph will find a cycle in the graph 
with an odd number of vertices or else report that there is none. Then design 
an algorithm to search for cycles of even length. Compare the complexities 
of your algorithms. 
28. Run SEQUENTIALCOLOR on each of the following labeled graphs. Does 
the algorithm use the minimum possible number of colors? 
446 

8:5 GRAPH COLORING AND AN APPLICATION TO STORAGE ALLOCATION 
5 
2 
3 
4 
6 
7 
9 
6 
3 
7 
6 
4 
2 
5 
2 
29. Run SEQUENTIALCOLOR on the following graphs. 
2 
3 
4 
5 
3 
5 
7 
9 
6 
7 
8 
9 
10 
2 
4 
6 
8 
10 
30. Generalize the examples of the preceding problem to show that for ever) k 
there are 2-chromatic graphs that when suitably labeled cause SEQUENTIAL-
COLOR to use 2 + k colors on them. 
31. Here are some graphs; find the chromatic number of each graph and then find 
a labeling of them so that SEQUENTIALCOLOR uses that many colors .m 
them. 
D 
447 

8 
MORE GRAPH THEORY 
32. Determine the chromatic number and the clique number of the following 
graphs. 
33. Find an example of a 4-colorable graph and a labeling so that SEQUENTI A L-
COLOR uses more than four colors on it. 
34. Run BACKTRACKCOLOR with the indicated values of N on the following 
graphs. 
3 
2 
3 
35. Redesign BACKTRACKCOLOR so that it finds all colorings of a graph with 
N colors. 
36. Design an algorithm to determine diG) and determine the complexity of the 
algorithm. 
37. Here is a variation on BACKTRACKCOLOR: First use DEPTHFIRST-
SEARCH to visit and label all vertices in the order they are visited. Then run 
BACKTRACKCOLOR. Find an example of a graph on which the resulting 
algorithm is more efficient than BACKTRACKCOLOR and one on which 
they do exactly the same work. [n generaL on what graphs will this revised 
algorithm be more efficient and on what graphs equally efficient? Is it ever less 
efficient? 
38. Comment on whether the algorithm SEQUENTIALCOLOR is a greedy 
algorithm. 
448 

8:5 
GRAPH COLORING A:-.IJ) AN APPLICATION TO STORAGF: ALLOCATION 
39. Design an algorithm that l'trst numbers the vertices of a graph by decrea,ing 
degrees (i.e .. the vertices of highest degree are numbered tirst) and then run 
SEQUENTIALCOLOR. This is known as Largestfirst. Find sets of graphi on 
whieh this version is more efficient and seJ:s on which this is no more ctncient. 
40. Prove that if BACKTRACKCOLOR outputs a coloring, then it has found 
an N-coloring of C. 
41. Prove that if BACKTRACKCOLOR reports "No N-coloring," there i, no 
N-coloring of C. (Hint: Proceed by contradiction. Assume that G has an N-
coloring and show that BACKTRACKCOLOR must find it.) 
42. Find a function g( V) such that BACKTRACKCOLOR requires at most 
O(g( V)) comparisons when run on a graph with V vertices. 
43. Write a recursive version of backtrack coloring. (Hint: Just as BACK TRACK-
COLOR resembles the algorithm DFS-HAMCYCLE, so should the recursive 
implementations.) 
449 

SOLUTIONS TO QUESTIONS
IN CHAPTER 1
SECTION 1
1.1 The only number that appears on .4, C, and D but not on B is 11. This can
be verified by trial and error for each of 0,1,2,3,4,...,15.
1.2 This trick will always work if no two numbers appear on exactly the same set
of cards. For example, if both 11 and 5 appeared on cards A, C, and D but
not on B, then player 1 could not know which answer, 11 or 5, was correct.
1.3 There is more than one way to design such a pair of cards. Two (of many)
examples follow
Two cards cannot be used to distinguish the numbers 0,1,2,3, and 4. The
reasoning is as follows: Write down all possible yes/no responses to a set of
two cards:
Card I
Card 2
no
no
no
yes
yes
no
yes
yes
451

SOLUTIONS TO QUESTIONS IN CHAPTER 1
1.4
1.5
To make the trick work, we must assign to each of these four responses one
of the numbers O, 1,2,3, and 4. There are five numbers to assign to four
responses, and so two numbers will elicit the same response.
10,000. There are 4 digits to be assigned with 10 choices for each digit
(0,1,..., 9). We apply the Multiplication Principle: There are 10 ~ 10 = 100
choices for the first two digits. Regardless of these choices there are 100
choices for the last two digits. Using the Multiplication Principle a second
time, there are 100 100 = 10,000 choices for all 4 digits.
Responses
Player 2‘s Number
Card A
Card B
Card C
Card D
o
no
no
no
no
1
no
no
no
yes
2
no
no
yes
no
3
no
no
yes
yes
4
no
yes
no
no
5
no
yes
no
yes
6
no
yes
yes
no
7
no
yes
yes
yes
8
yes
no
no
no
9
yes
no
no
yes
10
yes
no
yes
no
11
yes
no
yes
yes
12
yes
yes
no
no
13
yes
yes
no
yes
14
yes
yes
yes
no
15
yes
yes
yes
yes
SECTION 2
2.1 (a) 10101 = 1 + 4 + 16 = 21. (h) 100101 = 1 + 4 + 32 = 37, and
(c) 11010 = 2 -t- 8 + 16= 26. An even number expressed in binary ends with
a O and an odd number ends with a 1.
452

SOLUTIONS TO QUESTIONS IN CHAPTER 1
2.2 Decimal Number
Binary Representation
o
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
0
1
10
11
100
101
110
111
1000
1001
1010
1011
1100
1101
1110
1111
If we make each of the binary representations four digits long by adding
0s to the left and replace each O with a “no” and each 1 with a “yes,” then
this table would become the same as that in Question 1.5.
2.3 4(=100),5 (=101),6(=110),7(=111),
 12(=1100),13(=1101),  14(=1110),
and 15 (=1111).
2.4 Decimai Number
Arithmetic
Binary Representation
6
2+4
110
19
1 + 2 + 1 6
10011
52
4+16+32
110100
84
4+16+64
1010100
232
8+32+64+128
11101000
453

SOLUTIONS TO QUESTIONS IN CHAPTER 1
SECTION 3
3.1 Step 1. Place one cup of water in the bottom of a double boiler.
Step 2. Place one cup of water in the top of a double boiler.
Step 3. Place one cup of quick oatmeal in the top of the double boiler.
Step 4. Turn on stove burner to medium.
Step 5. Place double boiler on burner and heat for 10 minutes.
Step 6. Remove pot.
Step 7. Turn off burner.
3.2 The successive values assigned to z follow.
(a) 1. (b) 20, 10,5, 16,8,4,2, 1.
(C) 7,22,11,34,17,52,26, 13,40,20,10,5,16,8,4,2, 1.
SECTION 4
4.1 (a) Algorithm BtoD run on s = 10101.
Is there a jth
1,s thejth  entry
Step 
No. 
j
m
entry in s?
equal to 1?
1
o—
2
0
0
3
0
0
yes
4
0
1
yes
5
1
1
3
1
1
yes
4
1
1
no
5
2
1
3
2
1
yes
4
2
5
yes
5
3
5
3
3
5
yes
4
3
5
no
5
4
5
3
4
5
yes
4
4
21
yes
5
5
21
3
5
21
no STOP
Result: m = 21.
454

SOLUTIONS TO QUESTIONS IN CHAPTER 1
(b) Algorithm BtoD run on s = 11010.
Is there a jth
Is the jth entry Step
Step No.
j
m
entry ins?
equal to 1?
1
2
3
4
5
3
4
5
3
4
5
3
4
5
3
4
5
3
0
0
0
0
0
0
0
1
0
1
0
1
2
2
2
2
2
2
2
3
2
3
2
3
10
4
10
4
10
4
26
5
26
5
26
yes
no
yes
yes
yes
no
yes
yes
yes
yes
no STOP
ResulC m = 26.
455

SOLUTIONS TO QUESTIONS IN CHAPTER 1
(c) Algorithm BtoD run on s = 100101.
Is there a jth
Is the jth entry
Step No.
j
m
entry ins?
equal to 1?
1
2
3
4
5
3
4
5
3
4
5
3
4
5
3
4
5
3
4
5
3
o—
0
0
0
0
0
1
1
1
1
1
1
1
2
1
2
1
2
5
3
5
3
5
3
5
4
5
4
5
4
5
5
5
5
5
5
37
6
37
6
37
yes
yes
yes
no
yes
yes
yes
no
yes
no
yes
yes
no STOP
4.2
4.3
4.4
ResulL m = 37. These are the same answers as those of Question 2.1.
Response 1 is not an algorithm because the instruction to stop might not
be reached in a finite number of steps, since the binary representation of m
might never be written down in step 1.
Response 2 is an algorithm because (a) the instructions are clear; (b) after
performing an instruction, there is no ambiguity about which instruction is
to be performed next; and (c) the instruction to stop will be reached after
a finite number of instructions. Unlike Response 1, Response 2 finds binary
numbers in increasing order (as opposed to at random) so that the mth binary
number produced will be the binary representation of the decimal number m.
The algorithm is slow because it will consider all n-bit binary numbers, n <5,
before concluding that 10011 is 19 in binary.
The algorithm must stop because eventually m must equal zero. Response
3 run on m = 182:

SOLUTIONS TO QUESTIONS IN CHAPTER 1
Largest power of
Is m
Step No.
m
2 that is s m
r
equal to O?
Result
1
182
2
54
1
54
2
22
1
22
2
6
1
6
2
2
1
2
2 STOP O
2
7 = 128
7
1
no
2
5 = 32
5
l–l—
no
2
4= 16
4
l_ll———
no
22=4
2
1–11-1—
no
‘21=’2
1
lL1l-l L
yes
10110110
4.5 The algorithm must stop because it repeatedly decreases the value of m.
Therefore, the value of m must eventually be O.
Here is algorithm DtoB run on m = 395; the values shown are those assigned
to the variables after the execution of the given step:
Step No.
j
m
q
r
Answer
1
0
395 
— 
—
.
2
0
395
197
1
1
4,5
1
197
197
1
2
1
197
98
1
11
4,5
2
98
98
1
2
2
98
49
0
011
4,5
3
49
49
0
2
3
49
24
1
1011
4,5
4
24
24
1
2
4
24
12
0
01011
4,5
5
12 
12
0
2
5
12
6
0
001011
4,5
6
6
6
0
2
6
6
3
0
0001011
4,5
7
3
3
0
2
7
3
1
1
10001011
4, 5
8
1
1
1
2
8
1
0
1
11 OOO1O11
3 STOP
o
Result: The binary representation of m = 395 is 110001011. Response 4
(DtoB) is easier to use than Response 3 because the user does less and easier
arithmetic.
457

SOLUTIONS TO QUESTIONS IN CHAPTER 1
SECTION 5
5.1
5.2
5.3
5.4
(a) A = {1,4,6, 8,9,10,12,14,15,16, 18,20,21,22,24,25,26,27,28},
(b) B = {1,4,9, 16,25}, and (c) C = {4,8,9, 12,16, 18,20,24,25,27,28}.
(a) A’= {2,3, 5,7,11,13,17, 19,23,29}
(b) B’= {2,3,5,6,7,8, 10,11,12,13,14,15,17, 18, 19,20,21,22,23,24,26,27,
28, 29}
(C) CC= {1,2,3,5,6,7,10, 11,13,14,15,17, 19,21,22,23,26,29}
Every set is a subset of itself. In addition B G A, C G A, A’ G B’, A’ q Cc.
Since BqA, AwB=Aand An B= B. Simdarly, A u C = A a n d  A n C =
C. B u C = {1,4,8,9, 12,16, 18,20,24,25,27,28} and B n C = {4,9, 16,25}.
SECTION 6
6.1
(a)
(b)
(c)
(a)
(d)
(b)
(c)
458
(d)

SOLUTIONS TO QUESTIONS IN CHAPTER 1
(e)
6.2 (i)
(e)
(Au B)c=Acn  Bc
(f)
(f)
Prooj_. Let x be in (A u B)
c. Then by the definition of complement, x is not
in A u B. Thus x is not in A and x is not in 1?. If x is not in A, then x is in A’.
Similarly, if x is not in B, then x is in F. Consequently, x is in A’ n F.
Conversely, if x is in xl’ n B’, then x is in A’ and x is in l?’. In other
words, x is not in A and x is not in B. Thus x is not in A u B. Consequently,
x is in (A u B)
c.
We have shown that (A u By G A’ n B’, and that A’ n F G (A u B)
c.
Thus (A u B)
c = A’ n B’, as desired.
K
(ii) (A n B)
c = A’ u B’
Proof. Let x be in (A n B)
c. Then x is not in A n B, which means that x is
not in A or x is not in B (or both). Then x is in A’ or x is in B’ (or both). Thus
x is in A’ u B’.
Conversely, let x be in A’ u B’. Then x is not in A or x is not in B (or
both), which means that x is not in A n B. Thus x is in (A n B)
c.
We have shown that (A n BY G A’ u E. and that A’ u F G (A n B)c.
Thus 
(A n B)c = A’ u F, as desired. ‘
SECTION 7
7.1 ~, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, and {a, b,c}.
7.2 Algorithm SUBSET run on A = {a ~, a2, a3} with
‘o
n = 3 .
459

SOLUTIONS TO QUESTIONS IN CHAPTER 1
Step No.
j
List of Subsets
7.3
7.4
7.5
1
@
2
1
3
1
{a,}
4
2
3
2
{az}, {al, az}
4
3
3
3
{as}, {al,a~}, {az,a~}, {al, a2,a3}
5
3 STOP
A x A = {(O, O), (O, 1),. ... (O, 9), (1, O),. ... (9,9)}. We can associate each of
these ordered pairs with a unique decimal integer from O to 99. Similarly,
with each element of A x A x A we can associate the decimal numbers from
O to 999. In general, the set An is the set of all ordered n-tuples with entries
from A= {0,1,2,.. ., 9}. Each element corresponds with a unique number
from O to 10” – 1.
(a) A x A = {(a, a), (a, b), (a, c),@, a), (b, b),@, c), (c, a), (c, b), (c, c)}, (b) r2,
(c) r
3, and (d) r
n.
(a) The bit vector of T is 110010, since the elements of T are the first, second,
arid fifth elements in the list of S, (b) 101001 and 000111, (c) z is the sixth
element in the list of S, and (d) {y} and {u, v, w, x}.
SECTION 8
8.1
8.2
8.3
8.4
lAu Cl=17and]Bu  C\= 13.
The cardinality of each union of two cards is 12.
(a) 1A u Ill never equals 4, since 
A ~ A u R For b) to e) set A =
{1,2,3,4,5} and (b) B= {1,2,3}, (c) B= {1,2,6}, (d) B= {1,6,7}, and
(e) B = {6,7, 8}. (f) 1A u BI never equals 9, since 1A u BI is the largest when
A and B are disjoint and then IA u B\ = IAI + IBI = 8.
Let A = {students enrolled in Discrete Mathematics} and B = {students
enrolled in Computer Science}. We are given IAI = 146, IBI = 205, and
IA u B[ = 232. From Theorem 8.1
lAn Bl=lAl+lB1-/Au B[
= 146 + 205 – 232
= 119 students in both courses.
460

SOLUTIONS TO QUESTIONS IN CHAPTER I
SECTION 9
9.1
9.2
9.3
9.4
9.5
9.6
The range of b is all of B because if q is any binary number and t its decimal
equivalent, then b(t) = q.
The map jl is not a function from N to B because its range is not contained
in B. The map ~z i: a function, since a binary number is either even or odd
but never both. The range of ~z is {O, 1}. The map ~~ is a function, since for
each natural number r there is precisely one string with r 1s. The range of
~~ is all binary numbers that contain no zero. The map ~~ is not a function,
since, for example, ~4(6) should equal O because 2 divides 6, and yet jJ6)
should equal 1 because 3 divides 6.
The function b k onto, since the range of b k all of B (see Question 9.1). The
function ~z is not onto, since {0,1} does not include all binary numbers. The
function ~~ is not onto, since the range does not include binary numbers
containing zeros.
The function b k one-to-one because if n # n’ are two different numbers, then
their binary representations differ and so b(n) # b(n’). The function fz is not
one-to-one because, for example, ~2(2) = ~2(4) = O. The function ~~ is
one-to-one because if r # r’, then ~~(r) and ~~(r-’) are strings of ones of different
length.
Yes, since A #A’ implies that c(A) # c(A’).
If X is in P(U), then c o c(X) = c(X7 = (X
c)
c = X. Thus c 0 c = i and c is its
own inverse.
SECTION 10
10.1 
(a) 
x y
Xvy
-(xvy)
-
x
- Y
( - x )  A(-y)
o
0
0
1
1
1
1
0
1
1
0
1
0
0
1
0
1
0
0
1
0
1
1
1
0
0
0
0
(b) Note that (x A -v) A z = 1 if and ordy if all of x, y, and z equal 1. Simi-
larly, x A (y A z) = 1 if and only if all of x, y, and J equal 1.
461

SOLUTIONS TO QUESTIONS IN CHAPTER 1
10.2 
x y
x@Y
X v y
-(XAY)
(xvy)A(-(x Ay))
( x A  ‘ y )  V(-XAy)
0
0
0
0
1
0
0
0
1
1
1
1
1
1
1
0
1
1
1
1
1
1
1
0
1
0
0
0
10.3 (a) x A y = 1 if and only if both x and y equal 1 if and only if y A x = 1.
(b) (xv y) v z = O if and only if all of x, y, and z equal O if and only
ifxv(yvz)=O.
10.4 None.
10.5 (a) is a contradiction while both (b) and (c) are tautologies.
462

SOLUTIONS TO QUESTIONS
IN CHAPTER 2
SECTION 1
1.1
Value
Value
Value
Value
Assigned
Assigned
Assigned
Assigned
to x
to y
to xold
to yoid
Before step 1
5
2
?
?
After step 1
5
2
5
?
After step 2
5
2
5
2
After step 3
5
5
5
2
After step 4
2
5
5
2
SECTION 2
2.1 Algorithm EXPONENT run with x = 3, n = 4.
Step No.
i
ans
2
0
1
4
0
3
5
1
3
4
1
9
5
2
9
4
2
27
5
3
27
4
3
81
5
4
81
6 STOP 4
81
463

SOLUTIONS TO QUESTIONS IN CHAPTER 2
SECTION 3
3.1 P.:2 +4+” + 2n = n(n + 1) for all positive integers n. Proof by induction
on n.
Step 1 (the base case): PI is the statement 2 “ 1 = 2 = 1 (1 + 1).
Step 2 (the inductive hypothesis): Assume that Pk is true. Pk is the statement
2+4+. ”.+2k=k(k+ l).
Step 3 (the inductive step): Verify that Pk + ~ is true. Pk + ~ is the statement
2 +4+... + 2 k + 2 ( k  + l ) = ( k + l ) ( k  + 2 ) .
2+4+” +2k+2(k+l)
=(2++ 2k)+2(k+l)
by associativity
=k(k+l)+2(k+l)
by inductive hypothesis
= (k + l)(k + 2)
by factoring.
Therefore, Pk + ~ is true, and Pn is true for all positive n.
K
3.2 Suppose that n = 2. If x = –1, then 1 – x +X2 = 3. If x # –1, then
~_x+x2=  (l–x+x2)(l  +x)
1+X
1 + X
3
—— 1+X”
Suppose that n = 3. If x = – 1, then 1 – x + X
2 – X
3 = 4. If x # –1, then
1–X+X2–X3= (1–X+X2–X3)(1+X)
1+X
1 – X
4
—— 1+X”
{
(1 – x“+’)/(l  – x)
3 . 3  Pn:l+x+x2+”””+xn=  n+l
ifx#l
ifx=l
First notice that when x = 1, the left-hand side of the equation of Pn is the
sum of (n + 1) terms, each equal to 1, and so the equation is valid. Now we
focus on the case when x # 1. Proof by induction on n.
Step 1 (the base case):
P. is the statement 1 = l–xO+l
l – x
l – x  ‘ l – x
which is true, since x # 1.
464

SOLUTIONS TO QUESTIONS IN CHAPTER 2
PI is the statement 1 + x = ~
l – x ”
This statement is also true since
1 – X
2
(1 – X)(l +x)
—
 
.
l – x
l – x
– 1 + X ,
—
for x # 1.
Step 2 (the inductive hypothesis) Assume that Pk is true. Pk is the statement
l–xk+l
l+x+x2+”.  ”+xk= ~_x
ifx #l.
Step 3 (the inductive step) Show that Pk + ~ is true. pk + ~ is the statement
1 –xk+2
l+x+x2+ .””+xk+xk+l=  ~_x
ifx #l,
l+x+. ..+xk+xk+l
=(l+”””+xk)+xk+’
by associativit  y
l–xk+l
k+l
= l–x 
‘x
by inductive hypothesis
l–xk+l + (1 – x)xk+l
.
l – x
with common denominator
l–xk+l+xk+l–xxk+l
—
—
by algebra
l – x
l–xk+2
——
l – x
by more algebra.
Hence Pk + ~ is true, and Pn is true for all positive integers n.
SECTION 4
@
4.1 If A contains one element, then it has one even subset, the empty set. If A
contains two elements, then it has two even subsets, the empty set and the
whole set ,4. You should check that a 3-set has four even subsets. Thus it
seems as if whenever ,4 is a set with n elements, then the number of even
subsets of A is 2“
 – 1. We prove this by induction on n.
465

SOLUTIONS TO QUESTIONS [N CHAPTER 2
Step 1 (the base case) PI is the statement that a set A with one element
has exactly 21-1 = 2° = 1 even subset. We just checked that this is true.
Step 2 (the inductive hypothesis) We assume that Pk is true. Pk is the statement
that a set A with k elements has exactly 2
k -1 even subsets.
Step 3 (the inductive step): We must verify that pk + ~ is true. Pk + ~ is the
statement that a set A with k + 1 elements has exactly 2
k + 1-1 = 2
k even
subsets.
Consider a set A with k + 1 elements. We must show that A has exactly
2
k even subsets. Let x be an element in A and define B to be A – {x}. By
Example 4.1 we know that B has exactly 2
k subsets. We build upon these
subsets to obtain all even subsets of A. Namely, let S be an even subset of
A. If S does not contain x, then S is an even subset of B. If S does contain
x, then S — {x} is an odd subset of B, where by an odd subset we mean one
containing an odd number of elements. Furthermore, every subset of B is
either even or odd. An even subset of B is aIso an even subset of A, and an
odd subset T of B turns into an even subset of A by forming T u {x}. The
number of even subsets of B is 2
k – 1 by the inductive hypothesis. The number
of odd subsets of B is the total number of subsets (2
k) minus the number
k – 1 Thus the number of odd subsets of B is
of even subsets (2
k - 1), or 2
k – 2 .
zk _ Zk-1 = 2k-1(2 – 1)
= Zk-1
Thus #(even subsets of A) = #(even subsets not containing x)
+ #(even subsets containing x)
. #(even subsets of B) + #(odd subsets of B)
=~k-l+zk-l
by inductive hypothesis and
the argument given above
=2.2k-~
.
Zk,
Thus pk + ~ is established, and Pn is true for every positive integer n. C
4.2 Pn is the proposition that the nth time the comment in algorithm SUM is
encountered, it is correct. The last time the comment is encountered j will
have the value r, and if the comment is correct, then ans will have the value
r(r + 1)/2 and the output will be as claimed.
Step 1 (the base case): We check PI. The variable ans is initially equal to O,
but the first time the comment is encountered, ans has been incremented by
j = 1 so ans equals 1. The comment asserts that the value of ans is 1 ~ 2/2 = 1
and so the comment is correct. You might check also that Pz is valid.
466

SOLUTIONS TO QUESTIONS IN CHAPTER 2
Step 2 (the inductive hypothesis): We assume P~, which states that the kth
time the comment is encountered, it is true.
Step 3 (the inductive step): We must prove P~ + ~, which states that the
(k+ l)st time the comment is encountered it is valid. Now the kth time that
the comment is reached j has the value of k and by the inductive hypothesis
the value in ans is k(k + 1)/2. The next time j has the value (k + 1) and ans
has been increased by this value of j:
ans {after k + 1 encounters} = j + ans {after k encounters}
k(k + 1)
=(k+ 
l)+ 
z
= (k + 1)(1 + k/2)
(k+ l)(k + 2)
.
2
’
which is the assertion of P~ + ~. Thus P~ is true for all positive n.
K
4.3 (a) 4, (b) 3, (c) 4, and (d) 3. The binary representation of 14 can be
obtained from that of 7 by adding a O at the right. The binary representation
of 13 can be obtained from that of 6 by adding a 1 at the right.
SECTION 5
5.1 n = 7:
four multiplications, since x’ = (x4)(x2)x.
n = 11: five multiplications, since xl 1 = (x8)(x2)x
n = 12: four multiplications, since xl
 2 = X
8X
4
n = 16: four multiplications, since xl 6 = (X
8)(X
8)
5.2 Revised Algorithm DtoB used to find X
37:
No. Multiplications
Variables
I
m
4
r
x
ans
and Divisions
Values
o
37
18
1
.x
.x
~
After
1
18
9
0
x
~
Step 2.5
2
9
4
1
x: 
;’
3
3
4
~
o
X8
X
5
~
4
2
1
0
~16
X5
~
5
1
0
1
X32
X37
3
Total No. 14
467

SOLUTIONS TO QUESTIONS IN CHAPTER 2
Revised Algorithm DtoB used to find X
52.
No. Multiplications
Variables
j
m
q
r
x
ans
and Divisions
Values
o
52
26
o
x
1,
I
After
1
26
13
0 
X
2
2
Step 2.S
2
13
6
1
x4
;4
3
3
6
3
0 
X
8
X
4
2
4
3
1
1
x 1 6
x 2 0
3
5
1
0
1
X32
x 52
3
Total No. ~
SECTION 6
6.1 Steps 1 and 5 were bookkeeping steps in DtoB and are not needed in
FASTEXP because of step 2.5.
6.2 log(22) = log (4)=2
log (2
3) = log (8)= 3
log(25) = log (32)= 5
log(210) = 10
‘21W2) = 21 = ‘2
‘21OE(4)  = ‘y = 4
2@(@ = 22.58A. . . = ? (Do the next question and then return to finish this.)
21w (s) —— 23=8
63 By the definition of logarithm if log (29 = h, then 2b = 2P. This implies that
h = p. Thus log (2P) = p. If log(q) = t, then by definition 2’ = q and by sub-
stitution 2
10s ‘~) = 21 = q.
6.4 L&J = 5, [~1 =4, L10g(8)] = 3, [log (13)l =4, L –*J = –2, [log (25)1 = 5,
and ilog(13.73)J  = 3.
SECTION 7
7.1 N = 17: fi = 4.1231...>4.0874. . . = log (17). This does not contradict
Theorem 7.2, but says that more is true than is stated in the theorem. Namely,
it is true that if n >17 (see Exercise 7.5), then& > log(n). (The bound n >64
was used for ease of calculation and proof argument.)
468

SOLUTIONS TO QUESTIONS IN CHAPTER 2
SECTION 8
8.1 Note that j(n) = 12n2 – 11< 12n2, since subtraction makes things smaller.
Thus letting C = 12, we have ~(n) = O(n2). Similarly,
h(n) =3r12+4n+ll
< 3n2 + 4n
2 + lln2, since n < n
2 and 1 < n2
= 18n
2.
Thus letting C = 18, we have h(n)= 0(n2).
8.2 An algorithm will be called cubic if there is a function, say f(n), that counts
the number of operations given a problem of size n and f(n) = 0(n3).  Both L
and C ought to take about 16 minutes to solve a problem of size 200. On a
problem of size 1000, L should take about 80 minutes and C should take
about 2000 minutes.
8.3 f(n) = 2n
7 – 6n
5 + 10n2 – 5
< 2n
7 + 6n
5 + 10n2 + 5
< 2n7 + 6n
7 + 10n7 + 5n
7 =  2 3 n
7.
Thus with C = 23, ~(n) = 0(n7).
8.4 By Theorem 8.1 J = 0(n5) and g = 0(n4).  Thus by Theorem 8.2
f + g = 0(n
5 + n’)= O(n’),
and
f . g = 0(n5n4)  = O(n’).
SECTION 9
9.1 (a) 353 is a prime number,
(b) 238 is not an even integer (or 238 is an odd
integer).
9.2 (a) There exists an integer greater than one that does not have a prime divisor.
(b) There exists an integer of the form 4n + 1 that is not a prime. (c) There
exists a prime greater than 2 that is not odd.
9.3 (a) For every integer n, 3n + 1 is not a prime number. (b) For every integer
n, log(n) < n. (c) For every integer n, n
2 s 2“.
469

SOLUTIONS “rO QUESTIONS IN CHAPTER 2
9.4
9.5
(a) The hypothesis is that n is even; the conclusion is that n
2 + n + 1 is
prime. The negation is that there is some even integer n such that n
2 + n + 1
is not prime.
(b) The hypothesis is that nz + n + 1 is prime; the conclusion is that n is
even. The negation is that there exists an integer n such that n
2 + n + 1 is
prime and n is not even.
(c) The hypothesis is that n is divisible by 6; the conclusion is that n
2 is di-
visible by 4. The negation is that there is an integer n that is divisible by 6
but n
2 is not divisible by 4.
(a) The converse of 9.4(a) is 9.4(b). The contrapositive of 9.4(a) is that if
n
2 + n + 1 is not prime, then n is not even.
(b) The converse of 9.4(b) is 9.4(a). The contrapositive  of 9.4(b) is that if n is
not even, then n
2 + n + 1 is not prime.
(c) The converse of 9.4(c) is that if n
2 is divisible by 4, then n is divisible by
6. The contrapositive of 9.4(c) is that if n
2 is not divisible by 4, then n is not
divisible by 6.
(d) The converse of Lemma 7.1 is that if 2’> (r + 1)
2, then r is greater than
5. The contrapositive of Lemma 7.1 is that if 2’ <(r + 1)
2, then r is no
greater than 5.
(e) The converse of Theorem 7.2 is that if ~~ > log (n), then n >64. The
contrapositive of Theorem 7.2 is that if J < log(n), then n <64.
470

SOLUTIONS TO QUESTIONS
IN CHAPTER 3
SECTION 1
1.1 (1) There are 10 such paths:
G 

T
P
M
.**
1P
4.0
M
G 

1
P
I
A
G 
O*
A
T-1
G **
P
G 
*d.
M
G 
F
P
G
G
d..
M
‘Tp
1 
. 
. 
.
M
J
G 
*
P
8*
G
G
M-r
G
P
G
G 
0
G 
*
M
“ l--p
!-
G 
*
A.m.
M
I
G **
G . 
.
M
471

SOLUTIONS TO QUESTIONS IN CHAPTER 3
1.2
1.3
(2) There are 4 such paths:
n5
P
M
(3) There are no such paths.
r2_l
P
M
m
P
M
To get outside the rectangle of Figure 3.1 would require either more than
5 Ns or more than 6 Es (or both). Since P is 6 units to the right of M and
5 units above M, any sequence of 6 Es and 5 Ns will correspond with a path
from M to P. Any sequence consisting of exactly 3 Es and 2 Ns corresponds
with a trip from M to P in Figure 3.2 and any such trip corresponds with
such a sequence.
Read on to learn the true answer.
SECTION 2
2.1 (a)
f(o, 2) = 1:
T
1
f(l, z) = 3:
_l
G
G
.
f
G
f(2,0). 1: —
472

SOLUTIONS TO QUESTIONS IN CHAPTER 3
f(z, 1)= 3:
.9
I
G
 T
T
f(2, 2) = 6:
G 

T
. 
.
1
f
G 

-r
G
G
G
G
1.0
(b) j(O, 3) = I = ~(3,0), f(l, 3) = 4 = j(3, 1), and ~(2, 3) = 10 = ~(3, 2).
2.2 There is just one shortest path from (O, O) to (i, O), a straight line consisting
of a path of i Es. Thus ~(i, O) = 1. Similarly, j(O,j) = 1.
23 Use the fact that ~(i,j) = ~(i – 1, j) + ~(i, j – 1):
~(3, 3) =~(2,3) + ~(3,2) = 10+ 10= 20.
j(4,2) = ~(3,2) + ~(4, 1) = 10+ j“(4, 1)
=lo+f(3,1) +f(4,0)=lo+4+l=  15.
2.4 The fifth row: 1 5 10 10 5 1. The coordinates of all points that end up on
the fifth row of Pascal’s triangle is {(i, j) i + j = 5}. The ~ values of these
points are exactly the corresponding entries of Pascal’s triangle.
2.5 4! = 24, 5! = 120, 6! = ‘720, 7! = 5040, and 8! = 40,320. The first n such that
n! > 1,000,000 is n = 10. This can be determined by continuing to calculate
9! = 362,880 and 10! = 3,628,800>1,000,000. Any value greater than 10
would also do.
2-6 (~)=(:) =1y(:)=(~)=3c)and( ;)turnOuttObe`hef 0urthand
fifth row of Pascal’s triangle; see Figure 3.7.
()
2.7 Use the definition of ~ :
0
k
k!
~=l=kJ= 
k !
(
)
k
o
=  o!(k _ o)!
 =  k!
k!
k!(k – k)! 
= k “
473

SOLUTIONS TO QUESTIONS IN CHAPTER 3
Similarly,
()
k
k!
k!
= k =
(
)
k
k – 1
=  (k – l)!(k – (k – l))!
l!(k _ 1)! = 1 “
2.8 We use the fact that X2 is the sum of the two numbers above:
() ()
kk
k!
=k+k(k–l) 
k(k+l)
(
)
k+l
X2 =
1
‘
2
= k + 2!(k _ 2)!
2
=
2
=
2
()
(4+ 3)!
2,9 Use the formula ~(P) = 
m ~ n = ~ = & = 35.
SECTION 3
3.1 The fifteen 4-subsets of A are
{al, az, a~, al}
{al, a2, a3, a,}
{al, a2, a3, a6}
{al, az, a~, a,}
{al, az, aa, aG}
{a~,a~,as,~G}
{al, a3, a4, a,} {al, as, aA, aG}
{a1,a3, a5,aJ
{al,a~,as,a(j}  
{Uz,as,a’t,as}
{az,a~,a~,a~}
{U29%,%,U6)
{a2, a4, a5, a6}
{a3,a4,a5,a6}
Note that
()
6
6!
4
— = 15,
=
 4!2!
The six 5-stibsets  of A are
{a,, a2,a3,a4,a5} 
{a,,a2,a3,a4,a6}
{al, a2, a3, a5, %j}
{a1,a2,fz4,a5,a6}
{al, a3, a4, a5, a6}
{a2~a3~a4~a5~a6}
Note that
()
6
6!
5
— - = 6 .
=
 5!1!
474

SOLUTIONS TO QUESTIONS IN CHAPTER 3
3.2
3-subsets of A containing afj
{a~,a~,aG}
{a~,a~,aG}
{a,, a@a(j}
{a~,a~,aG}
{a~,a~,~(j}
{az, U4, a~}
{az,a~,ab}
{a~,aq,aG}
{a~, a,, a~}
{a~, a~, afj}
Remaining 3-subsets of A
{a,, a2, u3}
{al, a2, a4}
{al, a2, a,}
{al, a~, az}
{al, a3, a5}
{al, a~, a,}
{az, a,, aA}
{a,, a~, a,}
{az, a~, a,}
{a,, a~, a,}
()
6
3.3 
(a) 
~
(
)
11
= 6!/(3!3!) =20 (b) ~ = 11!/(5!6!) = 462
()
(c) 1:
= 17!/(9!8!) = 24,310.
()
11
3.4 There are 
3
= 1651 l-letter sequences of Ns and ES with exactly 3 Es.
()
11
There are 4
= 3301 l-letter sequences of Ns and Es with exactly 4 Es.
‘ndthere:rw=c)
= 330 1 l-letter sequences of Ns and Es with
exactly 7 Es. There are 211 = 2048 sequences of Es and Ns containing 11
letters.
3.5 We can transform a j-subset of A to a j-subset of 1. by renaming each element
ai of A as the integer i. Similarly, we can transform a j-subset of 1. to a
j-subset of A by renaming the element i of 1“ as ai. The 4-subset of 1. that
corresponds with {al, az, aq, a“ _ ~} is {1,2,4, n – 1}. The 5-subset of A that
}
corresponds with {1,2,3,5, 8} is {al, a2, a3, a5, a8 .
3.6 {1, 3,4,7}, {1,3, 5,6}, {2, 3,4,7}, {2,3, 5,6}, {3,6, 7, 8}, {4,6,7,8}
. .
3.7 {1,2,3}, {1,2,4}, {1,2,5}, {1,2,6}, {1,3,4}, {1,3,5}, {1,3,6}, {1,4,5}, {1,4,6},
{1, 5,6}, {2, 3,4}, {2, 3,5}, {2,3,6}, {2,4,5}, {2,4, 6}, {2, 5, 6}, {3,4,5}, {3,4,6},
{3, 5,6}, {4, 5,6}.
3.8 {1,2,3}, {1,2,4}, {1,2,5}, {1,2,6}, {1,2,7}, {1,3,4}, {1,3,5}, {1,3,6}, {1,3,7},
{1,4,5}, {1,4,6}, {1,4,7}, {1,5,6}, {1,5,7}, {1,6,7}, {2,3,4}, {2,3,5}, {2,3,6},
{2, 3,7}, {2,4,5}, {2,4,6}, {2,4,7}, {2,5,6}, {2, 5, 7}, {2,6, 7}, {3,4, 5}, {3,4,6},
{3,4,7}, {3, 5,6}, {3, 5,7}, {3,6, 7}, {4, 5,6}, {4, 5,7}, {4, 6, 7}, {5,6,7}.
475

SOLUTIONS TO QUESTIONS IN CHAPTER 3
3.9 Algorithm JSET run on j = 4 and n = 6:
Step 
No. 
h 
bh
n+h —j
FOUND
k
b~
SUBSET
2
3
4,5,6
8
9-12
3
4,5,6
8
9-12
3
4,5,6
8
9, 10
11, 12
3
4,5,6
8
9–12
3
4, 5,6
8
9, 10
11, 12
3
4,5,6
8
9, 10
11, 12
3
4,5,6
8
9-12
3
4, 5,6
8
9-12
5
4
4
5
4
4
5
4
3
3
5
4
4
5
4
3
3
5
4
3
2
2
5
4
4
5
4
3
3
4
5
5
6
6
3
4
5
6
6
5
5
6
5
2
3
5
6
6
4
5
6
6
6
5
6
6
5
6
5
4
6
6
5
false
true
false
true
false
false
true
false
true
false
false
true
false
false
false
true
false
true
false
false
true
5
5
4
5
4
3
4
5
4
{1,2,3,4}
{1,2,3,5}
{1,2,3,6}
5
{1,2,4,5}
{1,2,4,6}
6
{1,2,5,6}
4
5
{1,3,4,5}
{1,3,4,6}
6
{1,3,5,6}
476

SOLUTIONS TO QUESTIONS IN CHAPTER 3
3.9 (continued)
Step 
No. 
h 
bh
n+h —j
FOUND 
k
b~
SUBSET
3
4, 5,6
8
9-12
3
4, 5,6
8
9-12
3
4, 5,6
8
9-12
3
4, 5,6
8
9-12
3
4,5,6
8
9-12
3
4,5,6
8
9-12
3
4,5,6
7
5
4
3
2
2
5
4
3
2
1
1
5
4
4
5
4
3
3
5
4
3
2
2
5
4
3
2
1
1
5
4
3
2
1
6
5
3
4
6
5
4
1
2
5
6
6
4
5
6
5
3
4
6
5
4
2
3
6
5
4
3
6
5
4
6
5
4
3
6
6
5
6
5
4
6
5
4
3
6
5
4
3
false
false
false
true
false
false
false
false
true
false
true
false
false
true
fake
fake
false
true
false
false
false
fake
true
false
false
false
false
false
false
3
2
5
4
3
2
STOP
5
3
6
5
4
{1,4,5,6}
{2, 3,4, 5}
{2,3,4,6}
{2,3, 5,6}
{2, 4,5, 6}
{3,4, 5,6}
477

SOLUTIONS TO QUESTIONS IN CHAPTER 3
()
3.10 The algorithm JSET produces ~
= n(n – l)(n – 2)/6 = 0(n3) subsets when
j=3.
(
)
3.11 
Note 
n = n(n–l)(n  –2)”(n-j +l)<~=O(nj)
1
j!
‘j! 
“
SECTION 4
4.1 The 4! permutations of the set {1,2,3,4} are
( 1 2 3 4 ) ,  ( 1 2 4 3  ) , ( 1 4 2 3  ) ,  < 4 1 2  3 ) ,  < 1 3 2 4 ) ,
( 1 3 4 2 ) ,  ( 1 4 3 2 ) , ( 4 1 3 2 ) ,  ( 3 1 2 4 ) , ( 3 1 4 2 ) ,
( 3 4 1 2 ) , ( 4 3 1 2 ) , ( 2 1 3 4 ) , ( 2 1 4  
3 ) , ( 2 4 1 3 ) ,
( 4 2 1 3 ) ,  ( 2 3 1 4 ) ,  ( 2 3 4 1 ) ,  < 2 4 3 1 ) ,  ( 4 2 3 1 ) ,
( 3 2 1 4 ) ,  ( 3 2 4 1 ) , ( 3 4 2 1 ) ,  ( 4 3 2 1 ) .
4.2 A 3-subset can be formed by filling in the three blanks {_, _,_} with dis-
tinct elements of the n-set. There are n choices for the first blank, n – 1 choices
for the second blank, and n – 2 choices for the third blank. By the Multip-
lication Principle, there are a total of n(n – l)(n – 2) ways to fill in the blanks.
However, once a subset is “filled in,” then every permutation of the elements
in that set will produce the same set. There are 3! permutations of each set and
so in the total of n(n — l)(n — 2), each set is listed 3! times. Thus there are
n(n – l)(n — 2)/6 different 3-subsets of an n-set.
43 Trace of algorithm PERM run on S = {1,2,3,4}:
Values ofj
Permutations
1
(1)
~
<1 2) <2 1)
3
( 1 2 3 ) ( 1 3 2 ) ( 3 1 2 )
( 2 1 3 ) ( 2 3 1 ) ( 3 2 1 )
4
( 1 2 3 4 ) ( 1 2 4 3 ) ( 1 4 2 3 ) ( 4 1 2  3)
( 1 3 2 4 ) ( 1 3 4 2 ) ( 1 4 3 2 ) ( 4 1 3  2)
( 3 1 2 4  > ( 3 1 4 2 ) ( 3 4 1 2 )  < 4 3 1  2)
( 2 1 3 4  ) ( 2 1 4 3  )  < 2 4 1 3 ) ( 4 2 1  3 )
( 2 3 1 4  ) ( 2 3 4 1  )  < 2 4 3 1 ) ( 4 2  3 1 )
( 3 2 1 4 ) ( 3 2 4 1 ) ( 3 4 2 1 ) ( 4 3 2  1 )
478

SOLUTIONS TO QUESTIONS IN CHAPTER 3
4.4 To find an integer N so that for n > N, n! >10” 2
n, proceed as in the
proof of Theorem 4.2: Suppose that N = Crr = 10”22 = 40. Then for
n >40, we know that n! > 10 2“.
SECTION 5
5.1 The four colors of the code are r, y, b, and w. It is not possible to determine
their order.
5.2 We may assume, by Question 5.1, that the colors in the code are r, y, b, and
w. The secret code can be determined from the guesses given in Example 5.1
by the following reasoning
Guesses and
Deduction
Deductions Used
1. r and y are not in the first and second positions,
Guess 2
respectively
2. Either b is in the third position or w is in the fourth
Guess 1 and Guess 2
position (but not both)
3. Either w is in the second position or y is in the third
Guess 2 and Guess 3
position (but not both)
4. w is in the second position
Deduction 3 and Guess 4
5. b is in the third position
Deductions 2 and 4
6. r is in the fourth position
Deductions 1,4, and 5
7. y is in the first position
Deductions 1,4, 5, and 6
Resulti Code = y w b r
Note that this reasoning is only one of many ways to arrive at the above
result.
5.3 Left to the reader.
5.4 The number of codes is 4! = 24. Use PERM or the results of Question 4.3.
5 . 5 g g b p g g p b g b g p g  pgbgpbggbpg
bggppggbpgbgbgpgp  bggbpgg
5.6 We have seen that if the code has 4 colors, then there are 24 possible codes,
and if the code has 3 colors, there are 12 codes (see Question 5.5). If there
are just 2 colors, there are 4 ways to have 3 of one color and 1 of the other
()
4
color, and there are
= 6 ways to have 2 colors occurring twice each.
2
If there is one color, there is only one possible code. Thus the maximum
479

,.
+ 
II
II
l-.
+u
+
?
s+.
w
II
E
II
0
I
0
+
U
I
F
II
0
I
I
++
I
I

SOLUTIONS TO QUESTIONS
IN CHAPTER 4
SECTION 1
1.1
1.2
1.3
1.4
&= *,*IS simplified, & = ~, and ~394i~06171
is simplified. ~ + ~ = &
14+$=&, and&+ &=~.
(a) 65, (b) 8, and (c) 1.
(a) gcd(5, 7) = 1, (b) gcd(4, 6) = 2, and (c) gcd (5, 10)=5. Since gcd(b, c)
must divide both b and c, it cannot be larger than either.
Algorithm GCD1 run on the pair (3,4):
Are both b/g
Step No.
b
c
and c/g integers?
9
gcd
1
3
4
3
3,4
3
4
no
2
3,4
3
4
no
1
5 STOP 
3
4
1
481

SOLUTIONS TO QUESTIONS IN CHAPTER 4
Algorithm GCD1 run on the pair (3, 12)
Are both b/g
Step No.
b
c
and clg integers?
c1
gcci
1
3
12
3
3 
STOP 
3
12
yes
3
3
Algorithm GCD1 run on the pair (6, 20):
Are both b/g
Step No.
b
c
and cJg integers?
9
gcd
1
6
20
6
3,4
6
20
no
5
3,4
6
20
no
4
3,4
6
20
no
3
3,4
6
m
no
2
3 
STOP 
6 
20
yes
2
1.5
1.6
1.7
482
(a) (5, 7) or any pair for which gcd = 1, (b) (4,6) or any pair with 1< gcd,
and (c) (4, 12) or any pair where gcd = b.
Algorithm ADDFRACTI
STEP 1.
STEP 2.
STEP 3.
STEP 4.
Input a, b, c, d {The sum a/b + c/d is to be calculated and output
as a simplified fraction. }
Setnumer:=  a*d+b*c; setdenom  :=b*d
Use SIMPLIFY on the pair (numer, denom)
Output the result of step 3 and stop.
Let m = minimum {a, b}. Then upon input of a and h, the algorithm
SIMPLIFY performs (at most) 2(tn – 1) divisions (in GCD1) plus two divi-
sions (in step 3). Let m’ = minimum [(ad — be), bd}. AD DFRACT1 performs
three multiplications ,in step 2 for a total of 2m’ + 3 multiplications and
divisions.

SOLUTIONS TO QUESTIONS IN CHAPTER 4
SECTION 2
2.1 Using log (n) < B, (a) (log (n))
z < B2, (b) log (n2) = 2 log(n) <25 and
(c) log (log(n)) < log(B).
2.2 Since by (l), log(n) > B/2, n = 210g(n) a 2B/2 = ~~.
SECTION 3
3.1 gcd(18, 30)= gcd(12, 18) = gcd(6, 12)= gcd(O, 6) = 6; gcd(18,48) =
gcd(18, 30)= 6; and gcd(18, 66) = gcd(18,48) = 6.
3.2 (a) 1, (b) 3, and (c) 5.
3.3 (a) ql = 4, rl = O, and gcd(3, 12) = gcd(O, 3) = 3. (b) ql = 9, rl = 4, and
gcd(13, 121)= gcd(4, 13) = 1. (c) ql = 1, rl = 144, and gcd(233,377)  =
gcd (144,233) = 1. (d) ql = 25, rl = 26,836, and gcd (34,567; 891,011)=
gcd (26,836; 34,567)= 1. (See solution to Question 3.4(d).)
3.4 (a) (12,20) 20 = 1 “ 12 + 8
12=1” 8+4
8=2”4+0
SO gcd (12, 20) = 4.
It took three divisions to find that gcd (12, 20) = 4.
(b) (5,15): 15=3 ”5+0
SO gcd (5, 15) = 5.
It took one division to find that gcd (5, 15) = 5.
(C) (377,610) 610 = 1 377+ 233
377=1233+144
The remaining equations are identical to those in the second part of
Example 3.1, so gcd (377, 610) = 1. It took 13 divisions to find that
gcd (377, 610) = 1.
483

SOLUTIONS TO QUESTIONS IN CHAPTER 4
(d) (34,567; 891,01 1): 891,011 =25 34,567 + 26,836
34,567 = 1 ~ 26,836 + 7731
26,836 = 3 ~ 7731 + 3643
7731 = 2 ~ 3643 + 445
3643=8445+83
445=5.83+30
83=2” 30+23
30=1” 23+7
23=3” 7+2
7=32+1
2=2’ 1+0
SO gcd (34,567; 891,011) = 1.
It took 11 divisions to find that gcd (34,567; 891,011) = 1.
3.5 (q) Algorithm EUCLID run on the pair (6, 20)
Step No.
b
c
q
r
gcd
1
6
20
6
3,4
3
2
5
2
6
3,4
3
0
5
~
6 STOP
The Euclidean equations are 20 = 3.6 + 2 and 6 = 3 2 + O. Using the
first equation, we obtain 2 = – 3 ~ 6 + 1 ~ 20.
(h) Algorithm EUCLID run on the pair (3,4):
Step No.
b
c
q
r
gcd
1
3
4
3
3,4
1
1
5
1
3
3,4
3
0
5
1
6 STOP
484

SOLUTIONS TO QUESTIONS IN CHAPTER 4
The Euclidean equations are 4 = 1 ~ 3 + 1 and 3 = 3 1 + O. Using the
first equation, we obtain 1 = – 1 ~ 3 + 1 ~ 4.
(c) Algorithm EUCLID run on the pair (55, 89):
Step No.
b
c
q
r
gcd
1
3,4
5
3,4
5
3,4
5
3,4
5
3,4
5
3,4
5
3,4
5
3,4
5
3,4
5
6 STOP
55
89
55
1
34
34
55
1
21
21
34
1
13
13
21
1
8
8
13
1
5
5
8
1
3
3
5
1
2
2
3
1
1
1
2
2
0
1
The Euclidean equations are
1.89=155+34
2.55=134+21
3.34= 1” 21+13
4.21=113+8
5.13= 1” 8+5
6 .  8=15+3
7 .  5=13+2
8. 3=12+1
9 .  2=2” 1+0.
485

SOLUTIONS TO QUESTIONS IN CHAPTER 4
We must start with equation 8 and work our way backward to express
the gcd as a linear combination of 55 and 89:
1=–1”2+ 1.3= –l. (–l .3+15) +1.3
using equation 7
=23- 1” 5=2.(-1.5+1.8)-1.5
using equation 6
=–35+2.8=-3.(-1.8+1.13)  +28
using equation 5
=58-3.13=5.(-113+1.21)-  313
using equation 4
=–8” 13+521=-8.(-121+1.34)  +521
using equation 3
=13. ~1–8.34= 13. (_l .34+1.55)_  8.34
using equation 2
=–21.34+1355=-21.(-1.55  +1.89)  +13. 55usingequationl
– 34.55 – 21.89.
—
SECTION 4
4.1
4.2
4.3
4.4
n
2 
3 
4 
5 
6 
11 
13
Fn_2 
O 
1 
1 
2 
3 
34 
89
Fn_l 
1 
1 
2 
3 
5 
55 
144
sum
1
2
3
5
8
8
9
233
n
16
17
18
19
20
Fn_2
377
610
987
1,597
2,584
Fn_l
610
987
1,597
2,584
4,181
sum = F.
987
1,597
2,584
4,181
6,765
2
n
65,536
131,072
262,144
524,288
1,048,576
In each case listed above, F“ < 2“.
We claim that the Principle of Complete Induction is valid, by which we
mean that if assertions (i) and (ii) are both verified, then the proposition P“
is proved for all n 2 N: Suppose that we verify (by hand) that P~, P~ + ~,. . .,
and P~ + ~ are all true. Then setting k = N + i in (ii) shows that Pk + ~ =
P~ + i + ~ is true. Then we can repeat (ii) with k = N + i + 1. Since we’ve just
demonstrated that Piv,. . . . P
N  + ~ + I = all true> we get that ‘ N +  ~ + z is true,
and so on. In general, we can work our way up to the truth of P. for any
integer n > N.
Using a calculator, one can check that
Flo = 55< (~)l” < (~)11 < Fll = 89.
We must prove for n >11 that Fn > (;)”: For the base cases we notice that
Fll=89> (;)ll =86.4...
486

SOLUTIONS TO QUESTIONS IN CHAPTER 4
and
F12 = 144> (2)12 = 129.7 . . . .
As in Example 4.2 we require base cases with two consecutive integers
(or j = 1) because the proof uses the fact that F~ + ~ = F~ + F~ _ ~. We use
complete induction and so assume that PI ~, PI ~,. . . . Pk are all true for some
arbitrary value of k. That is, Fi > (~)i for all 11 s i s k. Notice that i > 11,
since otherwise the claim that Fi > (~)i is not true. We must prove that
F~+l > (~)k+l.
Fk+l = Fk + Fk-1 > (;)k +(;)k-l
by inductive hypothesis
= (;)k-’(;  + 1)> ($)k-’ “ (:) = (:)k+’.
Thus F. > (~)” for all n >11.
4.5 We begin with the equation x – 1 = l/x and multiply both sides by x to
obtain X
2 – x = 1 or X
2 – x – 1 = O. Using the quadratic formula, we find
the roots to be (1 + &)/2 = @ and (1 – fi)/2 = ~’. Since these are not zero,
they are also solutions to the original equation. Alternatively,
1
2
2(1 –&)
T=l+J3=(l+~)(l–~)
=2(1–&l–&  
–l+fi
_— .
1 – 5
– 2
2
_l+~
— —–1=~–l.
2
46 42+2= ((1 + fi)/2)’ – ((1 – @2)2
.
d
&
_(l+2fi+ 5)/4-(1-2&+5)/4
—
4
4&/4
. —=1=F2.
4
4.7 The algorithm segment
Set C:=A+B
Set B:=A
Set A:=C
487

SOLUTIONS TO QUESTIONS IN CHAPTER 4
placed inside the appropriate loop will calculate Fibonacci  numbers if A and
B are initially assigned the values FI and FO, respectively. This uses three
memory locations. It is possible to use only two memory locations with the
segment
Set B:=A+B
Set A:=A+B
placed inside the appropriate loop.
SECTION 5
5.1 (i)c=F8= 21andb=FT  =13
21=1” 13+8,
ql=l, rl=8
13=1.8+5,
q2=l, r2=5
8=1” 5+3,
q3=l, r3=3
5=1.3+2,
q4=l, r4=2
3=1,2+1,
q5=l, r5=l
2=2” 1+0,
q6=2, r6=0
(ii) c= F10=55andb=F9  =34
55=1” 34+21,
ql=l, rl =21
34=1.21+13,
q2=l, r2 =13
21=1.13+8,
q3=l, r3=8
. . . as in the preceding part.
5.2 The maximum number of Euclidean equations occurs when b = 3 and c = 5,
and this number is three.
5.3 If b = 77 and c = 185, the first two Euclidean equations are
1.185 =2” 77+31,
ql=2, rl =31
2 .  77=2” 31+15,
q2=2, rz =15
5.4 (When b = 26 and c = 32. there is no value Of t such that rlt + z and r~t are
defined.) When b = 233 and c = 377, the largest integer t for which r2t + z is
defined is t = 5. Thus we compute the quantity rzt + JrZ, for t = L 2,3.4.5:
r4/r2 = ~, r6/r4 = ~, r8/r6 = ~, rlo/r8  = ~, and r12/rlo = O. These frac-
tions are all less than ~.
488

SOLUTIONS TO QUESTIONS IN CHAPTER 4
SECTION 6
6.1 (a) False, (b) False, (c) False, (d) True, (e) True, and
($) True.
An integer is congruent to O modulo 2 if and only if it is even.
[1] = {1,4, –2, 7, –5, 10,...} = {1 + 3k: k is an integer}.
6.2 (a) n+ i, (b) –n+ i.
6.3 (i) a - a (mod n):
Proof. a – a = O = O” n. Since a – a is divisible by n, we have a = a (mod n).
n
(ii) If a - b (mod n), then b = a (mod n)
Proof. If a - b (mod n), then there is an integer i such that (a – b) = in. But
then (b – a) = – in, which implies that b – u is divisible by n. Thus
b - a (mod n).
K
6.4 Both s and ~ are relations on Z and on all subsets of Z, respectively. If
two numbers are called related when their difference is even, then this gives
a relation on Z, but not on R, since we do not know what it means for an
arbitrary real number to be even.
6.5 (i) Given that a E c (mod n) and b - d (mod n), we know that there exist
integers i and j such that a = c + in and b = d + jn. Thus
a+ b=c+d+in+jn=c+d+ (i+j)n.
Thus a + b – (c + d) is divisible by n and so a + b E c + d (modn).
(ii) Proceedings in(i) we have a – b = c – d + in – jn. Thus a – c – (b – ~
is divisible by n and so a – c - b – d (mod n).
El
6.6 If x is in [a] and y is in [b], then
aax (modn)_
and
b = y (mod n).
By Lemma 6.3, part (iii)
ab = xy (mod n)
Thus multiplication is well defined.
6.7 (i)a=3, b=4, c=8, d=9, a n d
and
[ah] = [xY].
n = 5 .  Note that a’b =34=12-
2“(mod 5) and that c. d = 8 ~ 9 = 72-2 (mod 5). Further, 3 = 8 (mod 5) and
gcd (3,5) = 1. Finally, 4-9 (mod 5).
(ii) u=3, b=4, c= 15, d = 8 ,  and n= 12. Note that a b = 3 . 4 -
0 (mod 12) and that c” d = 15.8 = 120= O (mod 12). Further, gcd (3, 12) = 3.
and 4 # 8 (mod 12).
489

SOLUTIONS TO QUESTIONS IN CHAPTER 4
6.8
6.9
(a) All nonzero elements of Z, have multiplicative inverses: [1][1] = [I],
[2][3] = [3][2] = [6] = [1], and [4][4] = [16] = [I]. (b) Since 10 is not
a prime number, only numbers relatively prime to 10 have multiplicative
inverses, namely 1,3,7,9: [1][1] = [1], [33[7] = [7][3] = [21] = [1], and
[9][9] = [81] = [I]. (c) The elements of 21 ~ that have inverses are the
numbers relatively prime to 18: [1], [5], [7], [11], [13], [17].
If p = 11 and b =4, the equivalence classes (mod 11) are r41, r2 .41 =
[8], [3 ~ 4] = [12] = [1], [4 ~ 4] = [16] = [5], [5 ~ 4] = [20] =-[9], 16. 4j =
[24] = [2], [7 ~ 4] = [28] = [6], [8 ~ 4] = [32] = [10], [9 ~ 4] = [36] = [3],
[10 ~ 4] = [40]= [7]. We also note that
411-1 = 410 = 1,048,576= 1 + 95,325.11 = 1 (mod 11).
Finally, if c = 11, 1110 a O (mod 11).
SECTION 7
7.1
7.2
7.3
7.4
7.5
7.6
490
In ASCII “HOWDY” = 7279876889. The message 83858270327383328580
represents “SURF IS UP.”
ZZ produces 9090. With B = 4 the smallest number is 3232.
(a) 323 = 17 “ 19, (b) 4087=61 “ 67, and (c) 8633=89 “ 97.
Here are all numbers between 2 and 76 that are relatively prime to 607,11,
13,17,19,23,29,31,37,41,43,47,49, 53,59,61,67,71,73.
We know that 9991 = 97 “ 103. To show that gcd (7676, 9991) = 1 and that
gcd (7932, 9991) = 1 we check that neither 97 nor 103 divides 7676 or 7932.
Next we calculate R2 and R3:
R2 = M~l - M2M~M~ (mod 9991).
M: s 7676
2 G 58920976 = 4049
M: ~ 4049
2-16394401-9161
M; z 9161
2 = 83923921 = 9512
Thus R2 a 7676 “ 4049-9512 = 9884 (mod9991).
R3 s M\l z M3M$M~ (mod 9991).
M; E 7932
2 G 62916624 s 3297
(mod 9991).
(mod 9991).
(mod 9991).
(mod 9991).
M: a 3297
2 = 10870209 = 1 (mod 9991).
M: =12=1
(mod 9991).
Thus R3 = 7932 ~ 3297 “ 1-5357 (mod9991).
Assume that there are 30 days = 30.24.60 = 43,200 minutes in a month.
Then to check all N B digit numbers from O to N with e = 11 requires roughly

SOLUTIONS TO QUESTIONS IN CHAPTER 4
N15B2 = 10
B + 115B2 single-digit operations. The problem can be restated
as follows: For what value of B is 10B
 + 1 15B2/17,800 > 43,200? The answer
is B >6. Thus in order to keep Eve calculating for a month, the value of N
must be at least 10
7.
7.7 The multiplicative inverse (mod 8) of e = 7 is d = 7. The encryption of 2:
2
7 = 128 s 8 (mod 15). The decryption of 8:87 = 2097152-2 (mod 15). The
encryption of 7: 7
7 = 823543 s 13 (mod 15). The decryption of 13: 137 =
62748517 = 7 (mod 15).
7.8 First we show that R~45 1 - M2:
R~51 - (9884
4096) (9884256)(988464)(988432)(98842)(9884)
With a total of 12 multiplications we find
9884
2 = 97693456-1458 (mod9991)
98~44 = 1458
2 (mod 9991)
-2125764 (mod 9991) -7672  (mod 9991)
9884
8 = ?6722 (mod 9991)
= 58859584 (mod 9991) -2603 (mod 9991)
9884
16-26032 (mod 9991)
a 6775609 (mod 9991) = 1711 (mod 9991)
9 8 8 4
32 ~ 1711
2 (mod9991)
s ~927521 (mod 9991) ~ 158 (mod 9991)
988464 a 158
2 (mod 9991)
= 24964 (mod 9991) -4982  (mod 9991)
9 8 8 4
128 e 4982
2 (mod9991)
= 24820324 (mod 9991) -2680  (mod 9991)
9884
256-268
0
2 (mod 9991)
= 7182400 (mod 9991) -8862  (mod 9991)
9884
512-8862
2 (mod 9991)
= 78535044 (mod 9991) -5784  (mod 9991)
9884
1024 = 5784
2 (mod 9991)
= 33454656 (mod 9991)= 4788 (mod 9991)
9884
2048 a 4788
2 (mod 9991)
R 22924944 (mod 9991) E 5590 (mod 9991)
9884
4096-55
9
02 (mod 9991)
a 31248100 (mod 9991)= 6243 (mod 9991)
491

SOLUTIONS TO QUESTIONS IN CHAPTER 4
With five more multiplications we find
9884
4451 ~ 6243 “ 8862 “ 4982.158 “ 1458 9884 (mod 999I)
= (6243 ~ 8862) ~ (4982 ~ 158) ~ (1458 ~ 9884) (mod 9991)
= 5299 “ 7858 “ 3850 (mod 9991)
= (5299 ~ 7858) .3850 (mod 9991)
= 7045 “ 3850 (mod 9991)
= 27123250 (mod 9991)
= 7676 (mod 9991)
= M2.
Next we show that R~
451 z M3:
Rf451 = (5357
4096)(5357
256)(5357
64)(5357
32)(5357
2)(5357)
With a total of two multiplications we find that
5357
2 = 28697449 = 3297 (mod 9991)
5357
4 a 3297
2 (mod 9991)
a 10870209 (mod 9991)= 1 (mod 9991)
All of the remaining powers of 5357 will equal 1 modulo 9991. Then with
one more multiplication we find that
451 _
R: 
= 5357
445’ (mod 9991)
= 1 ~ 1 1.1.3297.5357 (mod9991)
—
= 17662029 (mod 9991)
= 7932 (mod 9991)
= M3.
492

SOLUTIONS TO QUESTIONS
IN CHAPTER 5
SECTION 1
1.1 There are
(
)
4
= 6 pairs of possible direct connections among the four build-
2
ings A, C, M, and S. At
-lea
st three direct connections are needed so that
communication is possibIe between every pair of buildings. Not every set of
three direct connections will ensure tha~ each pair of buildings can communi-
cate. See the following illustrations.
S
cI
MA
.
Sc
L
o
M
A
There are
( )
5
= 10 pairs of possible direct connections among five build-
2
ings. At least four direct connections are required to ensure communications
among every pair of buildings. Not every set of four direct connections will
guarantee communications between each pair of buildings. See the following
illustrations.
493

SOLUTIONS TO QIJESTIONS IN CHAPTER 5
s
c
s
c’
M
A
M
A
1.2 There are 16 possible LAN configurations. Four of these have one building
directly linked to each of the other three buildings. In the remaining 12 the
buildings are linked in a path of three cables. By checking all possibilities,
one can determine that joining Stoddard with each of the other three buildings
has a minimum total cost of $148,000. Note that the total cost with Stoddard
is less than the cost without it.
SECTION 2
2.1 Here are three graphs with V = 4 and E = 3.
LI
kc
2.2 We display the graph in Figure 5.4 with each vertex labeled with its degree:
V = 8, E = 10, and the sum of the degrees of all the vertices is 20.
1
3
4
3
2
0
2
2
2.3 From Theorem 2.1 the sum of all of the degrees is an even number. The con-
tribution to this sum made by the vertices of even degree is even. Therefore
the contribution to this sum made by the vertices of odd degree also must
be even. The only way this can occur is if the number of odd vertices is even.
494

SOLUTIONS TO QUESTIONS IN CHAPTER 5
2.4 The 11 different graphs on 4 vertices are as follows. (Note that in the solution
to Question 2.1 we listed all different graphs with V = 4 and E = 3.)
HL III
2.5 We show the graphs, G and H, from Figure 5.7 with each vertex labeled,
and then ------2  . . .. Al- -- -J:-------  ,. —-..---,
2t1~ UIIKX1  L.
1
2
“(2’3 ‘Qc
5
4
G
e
d
H
If ~ were an isomorphism from G to H, it would satisfy the relation
deg (x, G) = deg (jlx), H) for each vertex x of G. Thus we must have that
~(l) = g or c and J(5) = c or g. Without loss of generality, we choose ~(l) = g
and j“(5) = c. The question is, what is ~(6)? (This is where we get stuck and
can conclude that G and H are not isomorphic.) In order to preserve ad-
jacency, ~ must map the vertex 6 to a vertex in H that is adjacent to both
495

SOLUTIONS TO QUESTIONS IN CHAPTER 5
2.6
2.7
~(l) = g and ~(5)= c. But there is no vertex in H that is adjacent to both
g and c. Thus we cannot find f: V(G) ~ V(H) that satisfies property (ii) of
the definition of isomorphic. Therefore, G is not isomorphic to H.
From Theorem 2.2, K, contains 7(7 – 1)/2 = 21 edges.
The graph shown in (a) is bipartite. The vertices are labeled with R and B.
To see why the graph in (b) is not bipartite, attempt to label the vertices with
R and B. There is essentially only one way of doing this, by alternating R
with B around the outside cycle. When we do this, we see that some Rs are
adjacent to other Rs.
(a) Bipartite
(b) Not bipartite
SECTION 3
3.1
A path of length 5 from a to b is given by <a, x, r, e, w, b). A path of length
3 from z to r is given by (z, a, x, r). A 4-cycle ‘through b is given by
(b, w,c, z, b).
3.2 The three different trees on five vertices are
D
-L-u
3.3 A tree on six vertices must contain five edges, regardless of the particular
tree. (Move on to Theorem 3.1 for a proof of this fact.)
3.4 A set of 40 buildings with every pair connected by coaxial cable can be
thought of as a 40-clique. From Theorem 2.2, a 40-clique contains
40(40 – 1)/2 = 780 edges, or in this case, cables. A good guess as to the
minimum number of cables needed to connect 40 buildings is 39. The rea-
soning behind this guess is as follows: A graph that models the LAN (i) should
be connected (since every pair of buildings must be able to communicate),
and (ii) should not contain any cycles (since these introduce unnecessary
496

SOLUTIONS TO QUESTIONS IN CHAPTER 5
connections). Thus the model for the LAN that uses the fewest number of
edges is a tree with 40 vertices, which necessarily has 39 edges.
3.5 (a) The forest in Figure 5.15 contains 5 components, 14 vertices and 9
edges. Thus E = V – C. (b) Let the component trees be labeled Tl,
T2,. ... Tc with the number of vertices and edges of each component given
by Vl, V2,. ... Vcand El, E2,. ... Ec, respectively. Then, in total, E = El +
Ez+”” .+ Ecand  V= Vl+V2+”
“ + Vc. Since each component is a tree,
we know that Ei = Jj – 1 for i = 1,2,. ... C. Our goal is to compute E, the
total number of edges in the forest F, and we hope the result will be that
E =  V – C :
E= EI+E2 +”” +EC=(V1– 1)+( V2–l)+””+(VC –1)
=V1+V2+ ..”+ VC–(l+l+””” +1) =V–c.
3.6 We shall show that after the removal of edge e, every pair of vertices in
the graph G – e is still connected by some path, and thus the graph G – e
is connected.
Proof. Suppose that e is an edge of the cycle C. Pick two vertices, say z
and w in V(G). Since G is connected, there is a path P = P(z, w) from z to
w. If P does not include e, then there is a path from z to w in G — e.
Otherwise, P uses e and thus intersects with C. Suppose that u is the first
vertex of P that is a vertex of C and u is the last vertex of P that is a
vertex of C. Thus P consists of three segments, P(z, u) from z to u, P(u, u)
from u to U, and P(LI, w) from v to w. If u = o, then we can construct a new
path P’ consisting of P(z, u) followed by P(v, w). P’ is a path from z to w in
G – e. If u # v, then within C there is a path P x that joins u with v but
does not contain the edge e. Let P’ consist of P(z, u) followed by P# followed
by P(IJ, w). P’ is a path from z to w in G – e. Thus G – e is connected. K
3.7 A connected graph with V vertices and V – 1 edges is a tree.
Proof. If G is acyclic, then by definition, G is a tree. If G contains a cycle,
by the preceding question it is possible to remove an edge from G, leaving
a connected graph. Continue removing edges from cycles until you are left
with a connected, acyclic graph. Such a graph has V — 1 edges, the original
number of edges. Thus no edges were removed, there can be no cycle in G,
and G is a tree.
K
3.8 One possible spanning tree of the graph in Figure 5.19 is as follows.
497

SOLUTIONS TO QUESTIONS IN CHAPTER 5
3.9 All spanning trees of the graph shown in Figure 5.21, along with the weight
of each, are as follows.
,~~’: 
,1 
, 
,[LO
wt=20
wt.23
‘u
wt.24
‘Lu’!l
wt.26
?
3
3
4
0
/’
?
1
0
5
3.10
/7
L
8
/
wt=23
5
8
0
i
wt=21
6
f!
vh=18
Algorithm BADMINTREE run on the graph in Figure 5.22:
Steps 2 and 3. A list of all subsets of the edges of the graph in Figure 5.22
498

SOLUTIONS TO QUESTIONS IN CHAPTER j
with exactly three edges follows. For those graphs that are trees, we give the
total weight:
N T1 ‘u’ ‘c 34
wt=13
wt=l.2
Wt=lo
‘m’ ‘hi’ i Y’ ‘N
wt =13
wt.15
Wt.11
rit=12
Wt=l’
Step 4. The spanning tree of minimum weight is the tree shown above whose
weight is 10.
3.11 J“ = 3:
(3@::12)=(;3=3
V=4:
(4(:::/2)=(:)=20
V=5:
(5(;::2)=(:)=2,0
v=,: ~:y2)=(y)=3003
v=~: (7(;~~12)=(;)=54,(j4
SECTION 4
4.1 (a) The result of running KRUSKAL on the first graph in Figure 5.24,
499

SOLUTIONS TO QUESTIONS IN CHAPTER 5
4.2
4.3
4.4
4.5
500
(b) The result of running KRUSKAL on the second graph in Figure 5.24
is a spanning forest. KRUSKAL reports failure, since the graph is not con-
nected.
,~:] 
or ~-;
3
3
We show TI and T2 labeled with c and d, respectively, and then we exhibit
the graph T2 + c – d. (Note that this is only one of several ways of choosing
c and d.)
ZOLZ
TI
Tz
T2+c–d
Since
E = O(V2),
0(E2) + O(E V) = O((V2)2) + O(V2V) = 0(V4)  +
O(V3) = O(V4). Similarly, O(E log(E)) = O(V
2 log(V2)) = O(V
2 log(k’)).
[1
( a )  011 O ( b )
1
0
0
1
1
0
0
0
0
1
0
0
(a)
0
1
0
1
1
0
0
7
1
0
1
1
0
1
0
0
1
0
0
0
1
1
1
1
0
0
1
1
0
1
0
0
1
0
0
0
0
1
1
1
0
0
1
0
0
1
0
0
1
0
d
5
4
3
(b)

4.6 If j“(n) = O(nk), there
SECTION 5
SOLUTIONS TO QUESTIONS IN CHAPTER 5
are constants C and N such that
~(n) S Cnk
for all n > N
= C(BUz)k
since B = n
2
—— C(Bk12)
.
0(Bk12).
5.1 Algorithm GREED YMAX
STEP 1.
STEP 2.
STEP 3.
STEP 4.
STEP 7.
Order the objects of E in order of decreasing weight assume E
contains m objects el,. . . . em
Set j:= 1 {j will index the objects.}
Set T to be empty {T will contain the desirable subset being
created.}
Repeat
Begin
STEP 5. If T + ej is desirable, set T : = T + ej
S T E P6. j:=j+l
End
Until j > m
Output T and stop.
If E is the set of weighted edges in a graph and desirability is defined as
being acyclic, then the ~gorithm- GREEDYMAX adds the heaviest weight
edges to T unless a cycle is formed. Thus at the end T contains a maximum
weight spanning forest.
5.2 Algorithm GREED YCYCLE
STEP 1.
STEP 2.
STEP 5.
STEP 6.
Set C to be empt~ set j: = O
Repeat
Begin
STEP 3. Find the lightest edge e such that C + e is a path; set
C:=C+e
S’rEp4. Setj:=j+l
End
Until j=V–1
Set C : = C + (x, y), where x and y are the end vertices of the path
of c
Output C and stop.
501

SOLUTIONS TO QUESTIONS IN CHAPTER 5
An example of a weighted K4 followed by the result of running
GREEDYCYCLE on this K4 with V = 4 is shown in the following figure.
The final graph shown is the true minimum weight 4-cycle.
lx!’ X c!’
K4
Result of
True minimum-
GREEDYCYCLE
weight 4-cycle
502

SOLUTIONS TO QUESTIONS
IN CHAPTER 6
SECTION 1
1.1 (a) 1, the social security number might be first in the card file. (b) 20, the
social security number might be last in the card file. (c) On average you
might expect the director to check about one-half or (1 + 20)/2 = 10.5 cards.
1.2 (a) To find the card with the social security number that is alphabetically
first in the card file, the director must make one comparison. To find the
card with the social security number that is alphabetically second in the card
file, the director must make two comparisons. In general, to find the card
that is alphabetically in the ith position in the card file, the director must
make i comparisons. In total, the director must make
20(20 + 1)
1+2+ 3+”” .+19+20= z =210 c o m p a r i s o n s .
(b) It takes 420 seconds = 7 minutes to make all the comparisons. It takes
20 minutes to record all the information. Thus the director spends more time
recording than comparing.
1.3 The director will have to examine all cards to be certain of finding the one
with the smallest social security number. Thus it will require 19 comparisons
if she compares the first card with the second, the smaller with the third, the
smallest with the fourth, and so o-n.
503

SOLUTIONS TO QUESTIONS IN CHAPTER 6
1.4 Trace of Algorithm SELECTSORT run on {6,4,2, 3):
Step No.
i
j
al
a2
a3
a4
TN
4
5
4
5
4
5
6
2, 3, 4
5
4
5
6
2, 3, 4
5
6
7 STOP
1
2
6
1
2
6
1
3
6
1
3
6
1
4
6
1
4
6
1
4
2
2
3
2
~
3
2
2
4
2
2
4
2
~
4
~
3
4
2
3
4
2
3
4
~
4
2
3
6
2,
3
6
2
3
6
4
3
6
4
3
6
4
3
6
4
3
6
4
3
6
6
3
6
6
3
6
6
4
3
6
4
3
6
4
3
6
6
3
4
6
6
4
4
2
2
2
2
6
4
4
3
3
6
4
4
SECTION 2
2.1
n= 
136 
68 
34 
17 
9 
5 
3
L(n+l)/2J =68 
34 
17 
9 
5 
3 
2
2.2 If n is odd, then there are exactly (n – 1)/2 records before and after the mth
record. Otherwise, if n is even, there are n,i2 – 1 records before the rnth record
and n/2 after it. The largest number of records that still must be searched is
no more than n/2.
2.3 pair = (6,8)
(lo, 17)
(18,33)
(35,67)
(69, 136)
mid = 7
13
25
51
102
504

SOLUTIONS TO QUESTIONS IN CHAPTER 6
2.4 A = (2,3,5,7,11,13, 17,19)
(a) Trace of algorithm BINARYSEARCH run with S = 5:
Step No.
jirst
last
mid
amid
4
1
8
4
7
5
1
8
4
7
6
1
3
4
7
4,5
1
3
~
3
6
3
3
2
3
4
3
3
3
5
5 Found S at location 3 and STOP.
We examined and compared S with three entries of A.
(h) With S = 10:
Step No.
jirst
last
mid
amid
4, 5
1
8
4
7
6
5
8
4
7
4,5
5
8
6
13
6
5
5
6
13
4, 5
5
5
5
11
6
5
4
5
11
7 S is not in A and STOP.
We examined three elements in A.
(c) With S = 17:
Step No.
jirst
last
mid
amid
4,5
1
8
4
7
6
5
8
4
7
4,5
5
8
6
13
6
7
8
6
13
4
7
8
‘i’
17
5 Found S at location 7 and STOP.
We compared S with three entries of A.
505

SOLUTIONS TO QUESTIONS IN CHAPTER 6
2.5 
n 
S
3Llog (n)] + 4
Array
No. of Comparisons Required
2
3
7
<1,2)
7
2
1
7
(1,2)
2
3
4
7
(1,2,3)
7
3
~
7
(1,2,3)
2
4
5
10
(1,2,3,4)
10
4
2
10
(1,2,3,4)
2
2.6 (a) Because SEQSEARCH sequentially searches the card file, 1000 compari-
sons are required in the worst case, the case where the card being searched
for is last in the file. (b) From Theorem 2.1, BINARYSEARCH requires at
most 3Llog (1000)] + 4 = 31 comparisons.
SECTION 3
3.1 Trace of algorithm BININSERT run on A = (2,5,7,9, 13,15, 19)
(a) With D = 1
Step No.
jirst
last
mid
amid
A
1
3
4
3
4
3
4
8
9
1
1
1
1
1
1
1
1
1
7
?
?
(2,5,7,9,13,15,19,1)
7
4
9
3
4
9
3
~
5
1
2
5
1
1
2
0
1
2
(2,2,5,7,9, 13,15, 19)
(1,2,5,7,9, 13, 15,19)
(b) With D = 4
Step No.
jirst
last
mid
%id
A
1
3
4
3
4
3
4
8
9
7
?
?
(2,5,7,9, 13,15, 19,4)
7
4
9
3
4
9
3
~
5
1
2
5
1
1
2
1
1
~
(2, 5,5.7,9,13,15. 19)
<2,4,5,7,9,13,15, 19)
506

SOLUTIONS TO QUESTIONS IN CHAPTER 6
(c) With D = 14
Step No.
jirst
last
mid
amid
A
1
3
4
3
4
3
4
8
9
1
1
5
5
5
5
6
6
6
7
?
?
(2, 5,7,9,13,15,19, 14)
7
4
9
7
4
9
7
6
15
5
6
15
5
5
13
5
5
13
(2,5,7,9, 13,15,15, 19)
(2,5,7,9, 13,14,15, 19)
(d) With D =23
Step No.
jirst
last
mid
amid
A
1
3
4
3
4
3
4
5
1
1
5
5
7
7
8
8
7
?
?
(2, 5,7,9,13,15, 19,23)
7
4
9
7
4
9
7
6
15
7
6
15
7
7
19
7
7
19
(2,5,7,9, 13,15,19,23>
3.2 Trace of BININSERT with A = (2,5,9, 13,15,19, 16):
Step No.
first
last
mid
amid
A
1
3
4
3
4
3
4
8
9
1
1
5
5
7
7
7
7
7
7
?
‘J
(2,5,7,9, 13,15,19, 16)
7
4
9
7
4
9
7
6
15
‘7
6
15
7
7
19
6
7
19
(2,5,7,9, 13,15,19, 19)
(2,5,7,9,13,15,16,19)
507

SOLUTIONS TO QUESTIONS IN CHAPTER 6
3.3
3.4
Trace of BINARYSEARCH with A = (2,5,7,9, 13,15, 19) and S = 16:
Step No.
jirst
last
mid
amid
4,5
1
7
4
9
6
5
7
4
9
4,5
5
7
6
15
6
7
7
6
13
4,5
7
7
7
19
6
7
6
7
19
7 Sisnot inA
The algorithm BININSERT is an extended version of BINARY-
SEARCH. The variables in the algorithm take on exactly the same values
and similar comparisons of elements are made. However, instead of just
announcing that “S is not in A,” BININSERT continues by shifting part of
A and inserting S into the array A.
Trace of BINARYSORT with A = (13, 23,17,19,18, 28):
Step No.
m
n
A
1
2
3
2
3
2
3
2
3
~
3
?
6
<13,23,17,19, 18,28)
2
(13,23, 17,19, 18,28)
3
(13,17,23,19,18,28)
4
(13, 17,19,23, 18,28)
5
(13, 17,18, 19,23,28)
6
(13, 17,18, 19,23,28)
In BININSERT every execution of step 2, except for the final one, forces an
execution of step 4. Steps 2 and 4 each require one comparison. The final
execution of step 2 requires one additional comparison and step 5 requires
one additional comparison. In total then, BININSERT requires 2(the number
of executions of step 4) + 2. In each part of Question 3.1, step 4 is executed
three times. Thus the total number of comparisons is 2 ~ 3 + 2 = 8. Further,
8~2[log(7)]  +4=2.2+4=8.
508

SOLUTIONS TO QUESTIONS IN CHAPTER 6
3.5 In Question 3.3, BINARYSORT is performed on an array of size 6. Within
BINARYSORT, the procedure BININSERT is called five times on arrays of
sizes 2,3,4,5 and 6, respectively. From Theorem 3.1 we have that BININSERT
requires at most 2110g(r)] + 4 comparisons to insert the (r + 1 )st item into
a sorted array of r items. Thus the total number of comparisons in Question
3.3 is given by
(2 Llog(1)J + 4) + (2 Llog(2)j + 4) + (2 Llog(3)J + 4)
+(2110g (4)J-t- 4)+(2 Llog(5)] +4)=4+6+6+8+8=32.
Note that when n = 6, (n – l)(2L10g (n – 1)] +4)= 5(2 Llog(5)] +4) = 40.
SECTION 4
4.1 A search tree illustrating a binary search of an array of 15 elements follows.
a8
4.2 (a) 
O
‘P’(X
(b) There is one binary tree with two leaves: the one above with three vertices.
There are two binary trees with three leaves: These are the binary trees with
509

SOLUTIONS TO QUESTIONS IN CHAPTER 6
five vertices. There are five binary trees with four leaves: These are the binary
trees with seven vertices.
4.3 (a)
Left subtree
al
a3
(b) Left subtree
(C) Left subtree
0
(d) Left subtree
(e) Left subtree
0
Right subtree
a5
a7
Right subtree
o
Right subtree
o
Right subtree
o
Right subtree
A
4.4 The depth of the left subtree is d – 1 or less.
4.5 From Theorem 4.1, a full binary tree has 2
k vertices at depth k. In particular,
a full binary tree with H or more leaves and depth k must have n < 2k or
log (n) s [log (n)l = k. Thus a full binary tree of depth [log (n)l will have n or
more leaves and by Corollary 4.2 will contain exactly 2r10g ‘n)’+ 1 – 1 vertices.
4.6 n
k = Llog(n)j + 1
n’=j-j
15
Llog(15)J + 1 = 4
24–1=15
26
Liog(26)J  + 1 = 5
25–1=31
31
L10g(31)J  + 1 = 5
25 –-1=31
We must show in general that n’ > n. We know that n < 2
k, or
510

4.7
SOLUTIONS TO QUESTIONS IN CHAPTER 6
For convenience, we replace the label q with i. A binary search tree for a
23-element array follows. Note that the tree must have 31 vertices (see Ques-
tion 4.6).
4.8 Labeled tree after the second execution of step 7:
13
Labeled tree after the third execution of step 7:
16
511

SOLUTIONS TO QUESTIONS IN CHAPTER 6
Labeled tree after the fourth execution of step 7:
20
M
M
M
M
Labeled tree after the fifth execution of step 7:
41
41
M
M
M
41
M
M
M
M
M
Result: B = (bl, b2, b3, b4, b5, b6) = (7,9, 13, 16,20,41).
SECTION 5
5.1 There are 3! = 6 orderings of the array A = ((J ~, a2, U3 ), one for each per-
( )
3
mutation on three elements, and
= 3 possible pairwise comparisons.
2
For an array with four distinct elements, there are 4! = 24 possible orderings
()
4
with
= 6 possible pairwise comparisons. Finally, an array with five
2
0
5
distinct elements can be ordered in 5! = 120 different ways with ~ = 10
possible pairwise comparisons.
512

5.2 (a)
SOLUTIONS TO QUESTIONS IN CHAPTER 6
al : ap
(b)
(a)
(b)
5.3 The graph shows a subtree of the binary search tree for a four-element
array as specified by Example 5.3. ln particular, the root of the subtree is
labeled with a4: a2 and we have assumed that al < a2 < a3. If the whole
binary search tree were drawn, it would look like the tree in Figure 6.6,
only this subtree would be hanging in place of the leaf labeled “al < a2 <
a3 .“ And a similar subtree would be hanging under every other leaf. In the
worst case five comparisons will be made.
a4: a2
513

SOLUTIONS TO QUESTIONS IN CHAPTER 6
5.4 A total of 5n log(n) comparisons are made or roughly 27,000 comparisons
when n = 600, roughly 61,000 comparisons with n = 1200, and roughly
97,000 comparisons with n = 1800.
SECTION 6
6.1 Trace of procedure MIN on the array <4,3,2,1, 5):
Step No.
n
k
a k
%+1
1
5
2
3
{Call MIN((;,  3,2, l),4,k)}
1
4
2
3
{Call MIN((;,  3,2), 3,k)}
1
3
2
3
{Call MIN((;, 3),2,/c)}
1
2
2
3
{Call MIN((;), l,k)}
1
5
{Return to (D;}
1
4
5
{Return to (C;}
2
4
5
{Return to (B;}
3
4
5
{Return to (A;}
4
4
5
{Return with; =4}
1
1
4
2
3
2
4
4
1
4
(A)
(B)
(c)
(D)
3
2
1
5
514

SOLUTIONS TO QUESTIONS IN CHAPTER 6
6.2 Trace of procedure GCD run on b = 13 and c = 21:
Step No.
b
c
r
9
1
13
21
?
?
2
13
21
x
3
{Call GCD(8, 13,g)}
2
8
(A)
13
3
5
{Call GCD (5,8, g)}
2
(B)
8
3
3
{Call GC;(3, 5,9)}
2
(c)
5
3
2
{Call GC;(2, 3, g)}
2
2
(D)
3
1
3
{Call 
GCD(l, 2,9)}
 
- 
-
2
(E)
2
3
0
{Call GC;(O, 1, 9)}
1
(F)
1
{Return to (F)}
1
{Return to (E)}
1
{Return to (D)}
1
{Return to (C)}
1
{Return to (B)}
1
{Return to (A)}
1
Result: gcd(13, 21) = 1. Note that the procedure GCD is called six times.
515

SOLUTIONS TO QUESTIONS IN CHAPTER 6
6.3 Trace of MIN on the array .4 = ( – 1,0.333,5.2, – 10,6.001, 17)
(a) With start =2, finish = 3
Step No.
start
finish
Ufinish
k
ak
1
3
2
{Call MI;(A. 2,2, k)}
(A)
1
2
2
4
{Return to2(A)}
2
3
5.2
2
0.333
3
3
5.2
~
0.333
4
{Return w?th k = 2}
Result: The index of the smallest entry in <a2, a~) is 2.
(b) With start =3, finish =6, A = (– 1,0.333,5.2, – 10,6.001, 17)
Step No.
start
jinish
afini~h
k
‘k
1
2
1
2
1
2
1
4
3
4
3
4
3
4
{Call MI;(,4, 3, 5,k)}
{Call MI;(A, 3,4, k)}
{Call MI;(,4, 3, 3,k)}
{Return to3(C)}
3
{Return to3(B)}
3
3
{Return to (A)}
3
{Return w?th k = 4}
6
(A)
5
(B)
4
3
4
4
5
5
6
6
(c)
3
– 10
3
5.2
– 10
4
– 10
6.001 
4
– to
6.001 
4
– 10
17
4
– 10
17
4
– l o
ResulC The index of the smallest entry in (as, al, as, a~) is 4,
516

SOLUTIONS TO QUESTIONS IN CHAPTER 6
(c) With start = 1, finish = 6
Step No.
start
finish
‘ f i n i s h
k
a k
1
2
1
2
1
2
1
2
1
2
1
4
1
{Call MIN (A, 1,5, k)}
1
{Call MIN (A, 1,4, k)}
{Call MI;(,4, 1,3, k)}
{Call MI;(,4, l,2,k)}
{Call MIN1(.4, 1, l,k)}
{Return tol(E)}
6
(A)
(B)
(c)
(D)
(E)
–1
–1
– 1
–1
– 1
– 10
– 10
– 10
– 10
– 10
5
4
3
2
1
1
2
2
0.333
0.333
1
1
1
1
{Return to (D)]
3
4
3
3
5.2
5,2
1
1
1
{Return tol(C)}
1
{Return tol(B)}
1
1
{Return to (A)}
1
3
4
4
4
– l o
– 10
1
4
3
4
5
5
6.001
6.001
4
4
3
4
6
6
17
17
4
4
3
4
{Return w;th k = 4}
Result: The index of the smallest entry in the array ,4 is 4.
517

SOLUTIONS TO QUESTIONS IN CHAPTER 6
SECTION 7
7.1 Each vertex of the following tree is labeled with the subarray of A to be sorted
at that vertex.
Director
<a~,a~, . . . ,a*>
<al, q, u3, a4>
<a5, a6, a7, a8>
<al, a2>
<al>
<a2>
<a~>
<a4>
< a 5 >
<at>
<a7>
<ag>
The tree above has depth 3 and 15 vertices. Every vertex except the root
corresponds with one assistant.
7.2 Trace of MERGE run on C = (0.1, 0.2,0.3,0,0.09,0.19, 0.29,0.39, 0.49) with
start = 1, mid = 3, and finish = 9.
Step No.
i
j
k
D
1
1
4
1
3
1
5
~
(0,...
1
6
3
(o, 0.09,...
2
6
4
<0,0.09,0.1,...
2
7
5
<0,0.09,0.1,0.19,..,
3
7
6
(0,0.09, 0.1,0.19,0.2,...
3
8
7
<(), 0.09,0.1,0.19,0.2,0.29, .
4
8
8
(O, 0.09,0.1,0.19,0.2,0.29, 0.3,...
10
(o, 0.09,0.1,0.19,0.2,0.29, 0.3,0.39, 0.49)
15
C = (0,0.09,0 .t, 0.19,0.2,0.29,0  .3,0.39,0.49).
518

SOLUTIONS TO QUESTIONS IN CHAPTER 6
7.3 (a) Trace of procedure MERGESORT run on the array C = (1, O) with
start = 1 and finish = 2:
Step No.
c
start
mid
jinish
1, ~
(1,0)
1
1
2
3
{Call MERGESORT(C,  1, 1))
(A)
1,2
(1)
1
1
{Return to (A)}
1
1
~
4
{Call MERGESORT(C,2, 2)}
(B)
1,2
(o)
2
2
{Return to (B)}
1
1
2
5
{Call MERGE (C, 1, 1,2)}
1
1
2
(o, 1)
6
Return.
(b) Trace of procedure MERGESORT run on the array C = (22,24, 23)
with start = 1 and finish = 3:
Step No.
c
start
mid
jnish
1,2
3
1,2
3
1,2
4
1,2
5
4
1,2
5
6
<22,24, 23)
{CaIl MERGESORT(C, 1, 2)
(22, 24)
{Call MERGESORT(C, 1, 1)}
(22)
{Return to (B)}
{Call MERGESORT(C,2,2)}
<24)
{Return to (C)}
{Call MERGE (C, 1,1, 2)}
(22, 24)
{Return to (,4)}
{Call MERGESORT (C, 3, 3)}
(23)
{Return to (D)}
{Call MERGE (C, 1,2, 3)}
(22, 23, 24)
Return.
1
1
1
1
1
1
3
1
1
2
1
1
1
1
‘-i.
2
3
3
(D)
3
3
~
519

SOLUTIONS TO QUESTIONS IN CHAPTER 6
(c) Trace
of procedure MERGESORT run on the array C =
(1.1, 3.3,2.2, 4.4) with start = 1 and finish= 4:
Step No.
c
start
mid
jinish
1,2
3
1,2
3
1,2
4
1,2
5
4
1,2
3
1,2
4
1,2
5
5
6
(1.1,3.3,2.2,4.4)
{Call MERGESORT(C, 1,2)}
<1.1,3.3)
{Call MERGESORT (C, 1, 1)}
<1.1)
{Return to (B)}
{Call MERGESORT(C,2,2)}
(3.3)
{Return to (C)}
{Call MERGE(C, 1, 1,2)}
(1.1,3.3)
{Return to (A)}
{Call MERGESORT(C, 3,4)}
(2.2, 4.4)
{Call MERGESORT(C, 3, 3)}
(2.2)
{Return to (E)}
{Call MERGESORT (C, 4, 4)}
(4.4)
{Return to (F)}
{Call MERGE (C, 3, 3,4)}
(2.2, 4.4)
{Return to (D)}
{Call MERGE (C, 1,2, 4)}
<1.1,2.2,3.3,4.4)
Return.
1
1
1
1
1
2
1
1
1
3
3
3
4
3
3
1
1
1
1
1
1
~
3
3
4
(A)
2
(B)
1
2
2
(c)
2
2
2
4
(D)
4
(E)
3
4
(F)
4
4
4
4
4
7.4 (a) Since Mergesort was called three times and Merge once on an array of size 
-
2, 3 + 3 ~ 2 = 9 comparisons were performed. 9 = 3 “ 2 “ log(2) + 2 “ 2 – 1.
(c) Since Mergesort was called seven times and Merge three times on arrays
of sizes 2, 2, and 4, 7 + 3(2 + 2 + 4) = 31 comparisons were performed.
31=3” 4.10g(4) +24-1.
7.5 As in Question 7.3 (b) Mergesort is called five times and Merge is called twice
on arrays of sizes 2 and 3. Thus 5 + 3(2 + 3) = 20 comparisons are performed.
3“3”log(3)  +2.3–1< 20<63. log(3) +103-1.
520

SOLUTIONS TO QUESTIONS
IN CHAPTER 7
SECTION 1
1.1
1.2
1.3
1.4
1.5
(a) 64, (b) 21, (c) 13, (d) 217, (e) 17.
(a) S4:fn  = n!,
(
)
(b) S5:gn = ;
(c) s~:hn =2”– 1,
[
n+l
ifl SnS2
2 n – 1
( d )  ~7:L = Zn + ~
if3snS4
if5sns6
2n+3
ifn=7
is one of many “creative” solutions to the problem of finding a function that
generates the first seven prime numbers. (e) S8: kn = n
2,
u) %:rnn =(–1)’-’3”-1
The functions ~~ = 2“ 
+ 1 + 1 and g. = 2n2 – 2n + 5 are two of many that
produce the values fl = gl = 5, f2 = g2 = 9 and f3 = g3 = 17.
Sl:an=a, _l+l
with al = 1
S2:an = 2an_l
with al = 2
n= 1234
5
6
7
8
au=O 1 3 6 10 15
h’ffn=l 2 2 3
3
3
3
4
521

SOLUTIONS TO QUESTIONS IN CHAPTER 7
1.6
n=l 
2 
3 
4 
5
Hn=l~+$~++f
H;=l$++~*
Weseethat forn=l,2,. ..,5, NH= W;.
1.7
n= 
1 2 3 4 5
Cn=l 1 
2 
5 
14
SECTION 2
2.1
2.2
2.3
2.4
S6 satisfies an = 2an _ ~ + 1 as does 9, 19, 39, 79, 159, . . . . S9 satisfies
a. = (–3)an_l  as does –6, 18, –54, 162, –486, . . . .
If one of al and aq is unspecified, then as and all subsequent “odd entries
of the sequence will be undefined. Similarly, if one of a2 and ab is unspecified,
then ab and all subsequent “even” entries will be undefined.
n=12345678!3  
10
“’an = 1
1
1
1
2
2
3
3
5
5
The sequence listed above can be obtained from the Fibonacci  sequence
by listing each term twice. Since, by Theorem 4.3.1,
~=+”-w
n
fi”
where
1+J5
4=7
1–$
and q!i = —-----,
% =F,n,2, = #’”’’’;@’’”/:,
(i) 2, (ii) 3, and (iii) 1.
( i )  a. = nan_l =n(n - l)an_2  =n(n– l)(n–2)a~_3  = .
=n(n–l)(n –2). .(n- (n- 2))al=n(n  –l)(n —2) ...2 .l= n!.
522

SOLUTIONS TO QUESTIONS IN CHAPTER 7
(ii) bn=bn-l+  2= bn-2+2+2=bn-~+2  +2+2=”
=bn-(n-l) +2+2+ ”””+2
{n -1 2 s }
=bl+(n– l)2=l+2n–2=2n–1.
2.5 (i) For the base case we have al = 1! = 1. Then
ak+l =(It+ I)ak
= (k + l)k!
by the inductive hypothesis
= (k + l)!,
as desired.
(ii) For the base case we have bl = 2.1 – 1 = 1. Then
bk+l=bk+2
=(2k–  1)+2
by the inductive hypothesis
=2k+l=2(k+l)–1,
as desired.
2.6 The relations an = na~- ~, a. = an_ ~ + a._ ~, a. = 2aLH,21, and an = nan _ ~
are all homogeneous, since each is satisfied by the sequence that is identically
O. The relation bn = bn _ ~ + 2 is inhomogeneous,  since when we replace each
bj with O, the result, O = O + 2, is not valid.
SECTION 3
3.1 (i) Not: inhomogeneous;  (ii) not: not linear and (iii) not inhomogeneous.
3.2 (i) The characteristic equation is x – 2 = 0’ and the characteristic root is
q ~ = 2. (ii) The characteristic equation is X2 – x – 6 = O and the charac-
teristic roots are q ~ = 3 and qz = – 2. (iii) The characteristic equation is
X
2 – 2x + 1 = O and the characteristic root is ql = 1.
3.3 The base cases are al = 2
1 – 1 = 1 and U2 = 22 – 1 = 3. The inductive hy-
pothesis is that ak = 2
k – 1. We substitute this in the given recurrence relation
ak+l = 3a~—2a~_l
—— 3(2~ – 1) – 2(2~-1 – 1)
—— 3.2k–3–2k+2
—— 2
k(3 – 1) – 1
. 2k+l_~ ,
as desired.
3.4 (i) a. = O, (ii) a. = 1, and (iii) a. = O.
523

SOLUTIONS TO QUESTIONS IN CHAPTER 7
3.5 (i) From Question 3.2 the characteristic equation for an = an-~ + 6aH _ ~ is
X
2 — x – 6 = O with characteristic roots ql = 3 and qz = –2. Thus the gen-
eral formula that solves this recurrence relation is given by an = c3* + d( – 2)”
for some constants
initial conditions:
c and d. We determine the constants c and d from the
2=ao=c30+ d(–2)0=c+d
1 =al =c31 +d(–2)1  =3c–2d.
Adding twice the first equation to the second, we obtain 5C = 5. Thus c = 1
and then d = 1 by substitution. Thus a. = 3* + ( – 2)”.
(ii) We have accomplished most of the work for this part of the problem
abovq the only difference is in the initial conditions. Hence we have
l=ao=c30+  d(–2)0=c+d
3 =al =C31 +d(–2)1  = 3c–2d.
Again adding twice the first equation to the second we obtain 5C = 5. Thus
c=landd  =0. Thusan=3n.
(iii) From Question 3.2, the characteristic equation for an = 2a~ _ ~ – a._ ~ is
X2 — 2X + 1 = O, which has a root of multiplicity 2.
SECTION 4
4.1 For the base cases we have b ~ =
b~+l=2bk–bk-l
=2k–(k–1)
=k+l,
1 and bz = 2. Then
the given recurrence
by the inductive hypothesis
as desired.
4.2 For p(x) = X
2 – 2x + 1, we construct II(x) as follows
~–2x+l–(q~–2q+l)
D(x) = 
x
x - q
_(x2–q2)  –2(x–q)+(l–1)
—
by regrouping
x — q
_(x–q)(x+q)–2(x–q)
—
by algebra
x — q
=x+q —2
by division.
524

SOLUTIONS TO QUESTIONS IN CHAPTER 7
4.3 The characteristic equation of b. = 4b.. ~ – 4b. - ~ is X2 – 4x + 4 = O and
its characteristic root is ql = 2. lf bk = 2
k, then
4bn-1–4b. _2=4”2n-1–42 n-2
. 2n+l–2” =2n(2–l)=2n= b..
If bk = k2
k, then
4bu_l – 4b”_2 = 4(n – 1)2”-1 –4(n– 2)2n-2
= 2“[2(n  – 1) – (n – 2)] = n2
n = b..
4.4 The characteristic equation of C. = – 3c. _ ~ – 3CR _ z – c._ 3 is
X3+3X2+3X+1=(X+1)3=0
and the characteristic root is q 1 = – 1 which has multiplicity y 3.
If c~ = (– l)k, then
–Jcn-l–  JCn-2–  C”.3= –3(_l)n-l_J(_l)”-2_(_l)n-3
=(_ly-3[–3(- 1)2- 3(–1)-1]
=(–1)”-3[-3+3-1]
=(–ly-s(–l)  =(–1)”-z=(–ly=c”.
If ck = k( – I)
k, then
–3cu_l  – 3C._Z ‘ e n - 3
= –3(?I–  1)(–1)”-1 –3(n–2)(–  1)’’ -(rlrl– 3)(–1)”-3
=(–l)n-3[–3(n–  1)(-1)
2 –3(n - 2)(-1 )-(n– 3)]
=(–1)”-3[–3n +3+3n–6–n+3]
=(–l)n-3[–n] =n(–1)”-2 = n(–l)”=cu.
Finally, if ck = kz( – l)k, then
–3cn-~–3cn_2–c”-3
= –3(n – 1 )
2(–1)’
-1 – 3(n – 2)2(–1)”-2  –(n – 3 )
2( – 1 ) ”
- 3
=(–l)n”3[–3(n2  –2n+l)+ 3(n2–4n  +4)–(n2–6n +9)]
=(–1)”-3[–  3n2+6n–  3+3n2–12n  +12–n2+6n–9]
=(–1)”-’[–n2]  =(–1)”-%2  = n2(–ly=cn.
525

SOLUTIONS TO QUESTIONS IN CHAPTER 7
4.5 From Theorem 4.2, a solution of the recurrence relation given in Question
4.3 is of the form
a. = Cl(–l)n + czn(– 1)” + c3n2(–l)n.
With the initial conditions a. = 1, al = – 2 and az = 1, we can solve for the
constants cl, C2, and C3:
l=tZ~=C~+OCz+OC3
–2=al=–cl–c2–c3
l=a2=cl+2c2+4c3
The solution to this system of equations is c1 = 1, C2 = 2, and C3 = – 1.
Thus a solution to the recurrence relation with the given initial conditions
is a. =(–1)” + 2n(–1)” – n2(–l)n.
SECTION 5
5.1 Reread Section 6.2.
n =  
2 3 4 5
Bn=7 7 10 
10
We note for n = 2, 3, 4, and 5 that B. = 3Llog (n)j + 4.
5.2 Reread Exercise 7 in Chapter 6, Section 7.
n=2 
4 
8
Mn = 9
31 87
3nlog(n)+2n–  1 =9 31 87
5 . 3  (a)k=l, d=2, c= Oande  =3. (b)k=l, d=2, c= Oande  =2.
(c)k= 2,d=2, c=3ande=l.
5.4 1 initial condition. If a. = 1, then
n= 1234567
an=2 
2
3
3
3
3
3
5.5 The proof is by induction on i, where n = 2i. The base case is i = (1 a20 =
al + Iog(l)c  = al + O = al. Assuming the result for i = k, let i = k + 1.
526

5.6
5.7
SOLUTIONS TO QUESTIONS IN CHAPTER 7
an=a~k+l
sincen = 2
i= 2k+1
=
 a[n/2] +C
by the recurrence relation
‘a~k+c
since n/2 = 2
k
= al + log(2k)c + c
by the inductive hypothesis
=al+kc+c=al+(k+l)c
= al + log(2k+’)c
by properties of log
– al + log(n)c.
—
With c = 2, Theorem 5.1 implies that C. s 2Llog (n)] + 4. This is the same
result as Theorem 3.1 from Chapter 6.
Mzk ~ 2M[2q,2 + 4 “ 2
k
by (C)
= 2M2jc., + 2kh2.
s 2(2M2k-z + 2k+l) + 2k+2
. 22 M2k-, + 2k~2 + 2k+2
.
22 M2, -2+2 .2k~2
. . .
~ 2iM2k-, + i2kh2
. . .
S zk&f2k-k  i- k2kf2
. 2kMl + 4(2k)k
Since log (2
k) = k and n = 2
k, the previous expression can be rewritten
as nM 1 + 4n log(n). Next we verify this formula by induction on k, where
tl = 2
k. That is, if n = 2
k and M. satisfies (C’), then we must show that
M. < 4n log(n) + Ml n. For the base case k
A41s4”l  ”O+M1.l= A41. We assume
n = Zk+l.
M. = Mz,. i
<2M2k+4”2k+l
by (C’)
<2(4” 2kk+M12k)+4.2k+l
—— 4.7k~lk+M12k~~+4.~k~~
—— 4.2k+l(k+ 1)+ A412k~l
= 4nlog(n) + Min.
=Oandn= 2°=l. Then Mn=.
the result for n = 2
k and check
by the inductive hypothesis
527

SOLUTIONS TO QUESTIONS
IN CHAPTER 8
SECTION 1
1.1 The union of shortest paths forms a minimum-distance spanning tree, shown
in (a). With the root specified to be 5, we obtain the different tree shown in (b).
‘b/I ‘u
3
4
5
3
4
5 = root
(a)
(b)
1.2 Here is a trace of DIJKSTRA on the weighted graph from Figure 8.4.
528

SOLUTIONS TO QUESTIONS IN CHAPTER 8
Step 
No. 
j 
z
V(T)
E(T)
2
4
5
4
5
4
5
4
5
4
5
4
5
4
5
~
?
It
It
2
b
2
b
3
s
3
s
4
C
4C
5
a
5
a
6
q
6
q
7
p
7
p
{r}
{r, t}
{r, t, b}
{r, t, b,s}
{r, t, b,s, c}
{r, t, b,s, c, a}
{r, t, b, S,C, a,q]
{r, t, b,s,c, a, q, p}
D
{(r, t)}
{(r, t), (r, b)}
{(r, t), (r, b), (t, s)}
{(r, t), (r, b), (t, s), (r, c)}
{(r, t), (r, b), (t,s), (r, c), (b, a)}
{(r, t), (r, b), (t,s), (r, c), (b,a), (a, q)}
{(r, t), (r, b), (t, s), (r, c), (b, a), (a, q), (q, p)}
1.3 If G is not connected, then step 4 cannot be executed V – 1 times as required.
If some edge weights were negative, then the minimum distance from the
root to the first attached vertex x might be less than the weight of the first
edge e = (r, x). Thus the tree T in the base case might not have a shortest
path in it. Later in the proof, when we add the edge (u, x), we claim that x is
closer to the root than U. This would not be true if the weight of (u, x) were
negative. If DIJKSTRA is run on the graph in Figure 8.5, then the distance
from the root to any of the other vertices is not well defined, since every time
you traverse a cycle around the triangle you add a total of – 1 to your path
length.
SECTION 2
2.1 The graph shown in (a) is the only Eulerian  graph with four vertices. The
graph in (b) has an Euierian path from x to y but is not Eulerian. The simplest
such graph would just be a path with eight vertices.
D ‘my T
(a)
(b)
(d
529

SOLUTIONS TO QUESTIONS IN CHAPTER 8
2.2
2.3
,
The first and last graphs are Eulerian (See Theorem 2.1). The second and
fourth contain Eulerian  paths but not Eulerian cycles.
A graph with four vertices all of whose degrees are even must have every
degree either O or 2. To be connected there cannot be any vertices of degree
O. There is only one graph, the 4-cycle, which is Eulerian. Similarly, a graph
with five vertices must have every degree either 2 or 4.
with one Eulerian cycle.
L
2
1
2
1
2
3
<1,2, 4, 5, 3, 1,
<1,2,4,3,5, 1>
<1,2, 3, 5, 2,4, 1>
4,3,2,5, 1>
2.4
2.5
7
6
5
4
0
0
0 A
G’
o
OCLJ
8,23
The vertices 3 and 4 have odd degree. To construct
adjacent to 3 and 4 as shown in the following figure.
r
1
2
3
5
6
7
We list them together
1
2
Bid
3
4
5
<1,3,2,4, 1, 5,2, 1>
G’ we create vertex r .
(4, r, 3,6,7,5,2,1,5,4,7,3, 1, 4) is an Eulerian cycle in G’. Removing r and its
incident edges produces an Euierian  path from 3 to 4.
530

SOLUTIONS TO QUESTIONS IN CHAPTER 8
2.7
2.6 For convenience we label the graph.
L
4
1
6
(1,2,3,  1,4,6,7,8, 1)
<1>2>3>L4,6,7,8,1)
3
2
4
2
6
(2, 4,8, 6,2)
(1,2,4,8,6,2,3 >1,4,6,7>8>1)
3
3
4
6
(3, 5,7, 3)
(1,2,4,8> 
6,2,3,5,7,3,1,4,6,7,8,1)
(1, 2,4, 3,1) is an Eulerian cycle in the first graph. The second graph does not
contain an Eulerian path or cycle. (2,3, 1,2,4,3) is an Euletian path in the
third graph as is (2,4,3, 1,2, 3). The fourth graph contains lots of Eulerian
cycles, for example, (1, 2,1,3,4,2,4,3,1 ).
SECTION 3
3.1 The first and third do; (1, 4, Z 3,1 ) and (1,2,3,4,5,1), respectively.
3.2
m
531

SOLUTIONS TO QUESTIONS IN CHAPTER 8
3.3
3.4
Step No.
~
P
c
2
0
4
x
{X, 1,  t, W, y)
5
(x, v, t, w, y, x)
4
u
{u, v, t, w, y,x)
5
{u, L w, y>% V,u)
First graph
Step No.
J
K
T
E(T)
1
1
3
1
4–6
2
3
2
4-6
3
3
3
4-6
4
3
4
7
3
3
3
7
~
3
2
4-6
5
9 STOP
‘z
2
{1,2}
{(1,2)}
3
3
{1,2,3}
{(1,2), (2, 3)}
4
{1,2,3,4}
{(1,2), (2, 3), (3,4)}
{no4K}
{no K}
5
5
{1,2,3,4,5}
{(1, 2), (2, 3), (3, 4), (2, 5)}
Second graph
Step No.
J
K
T
E(T)
1
1
3
1
4-6
2
3
~
4-6
6
3
6
7
2
3
~
7
1
3
1
8 STOP
{1}
%
2,
?
{1,2}
{(1,2)}
i
6
{~,2,6}
{(L ~)> (2, 6))
{no K}
[no K}
{1.2,6}
{(1,2), (2,6)}
532

SOLUTIONS TO QUESTIONS IN CHAPTER 8
3.5 First graph
Step No.
J
K
FOR WARD
PATH
Main 1
2
Build 1
2
3-5
3
Build 1
3
3-5
4
Build 1,2
4
Main 4, 5
3
Build 1
3
3–5
4
Build 1, 2
4
Main 4, 5
3
Build 1, 2
3
Main 4, 5
2
Build 1
~
3–5
3
Build 1
3
3-5
4
Build 1
4
3-5
5
Main 7, 8
Main 9 STOP
2
2
3
{no3K}
4
4
{no K}
3
3
2
~
4
4
TRUE
TRUE
TRUE
FALSE
TRUE
FALSE
FALSE
TRUE
TRUE
TRUE
(1,0,0,0,0)
(1,2,3,0,0)
(1,2,3,0,0)
(l~,4,(),o)
(1,3,0,0,0)
<1,3,2,0,0)
(1,3,2,4,0)
(1,3,2,4,1)
Second graph
Step No.
J
K
FOR WARD
PATH
Main 1
Build 1
3-5
Build 1
3–5
Build 1,2
Main 4, 5
Build 1
3-5
Build 1, 2
Main 4, 5
Build 1,2
.Main 4, 5
2
2
3
3
4
4
3
3
4
4
3
3
~
4
4
{no K}
TRUE
(1.0,0,0,0)
TRUE
(l, ~,(), ()q())
TRUE
(1,2,3,0,0)
FALSE
(1,2,3,0.0)
TRUE
<1,2,4,0,0)
FALSE
(1, ~,4, (),())
FALSE
(1,2,0,0,0)
continued
533

SOLUTIONS TO QUESTIONS IN CHAPTER 8
Second graph (continued)
Step No.
J
K
FOR WARD
PATH
Build 1
2
4
3-5
3
4
Build 1
3
2
3-5
4
~
Build 1
4
3
3-4
5
3
Main 7, 8
Main 4, 5
4
Build 1,2
4
{no K}
Main 4, 5
3
Build 1,2
3
{no K}
Main 4, 5
2
Build 1, 2
2
{noK}
Main 4, 5
1
Main 6 NO HAM CYCLE, STOP
TRUE
<1,4,0,0,0)
TRUE
(1,4,2,0,0)
TRUE
<1,4,2,3,0)
FALSE
(1,4,2,3,0)
FALSE
(1,4,2,0,0)
FALSE
<1,4,0,0,0)
FALSE
(1,0,0,0,0)
SECTION 4
4.1 Denote the locations by O = (0, O), P = (1, O), Q = (O, 1), and R = (1, 1). Since
the drill must start and end at O, there are 3! = 6 possible drilling sequences:
OPRQ and OQRP have total distance 4, OPQR and ORQP have total dis-
tance 2 + 2* as do ORPQ and OQPR. Note that the second sequence of each
of the preceding pairs is the reverse of the first.
4.2 (-1, 1)
(–1, 1)
~:, 
~(:: 
‘~](:1)
(-1, 
-1) 
‘
(–1,–1) 
‘
(-1, 
-1) 
‘
T(G)
P (G)
H(G)
4 V’7
4+2v~
6+2V5
534

SOLUTIONS TO QUESTIONS IN CHAPTER 8
4.3 D might consist of (0, P, O, Q, O, S, O, R, 0).
P
Q
D(T) z
x
o
R
s
4.4 The Hamiltonian  cycle C produced from D is <0, P, Q, S, R, O).
W(c) = 6 + 24= w(H(G)).
SECTION 5
5.1
5.2
5.3
5.4
5.5
See Figure 8.26: Each interfering pair of variables is represented by an edge
of this graph. Sets of four mutually interfering variables: {L, W, Wt, A},
{Wt, Vol, A, Cl}, {Ht, A, Cl, Vol}, {Wt, Vol, Cl, C2}. There is no set of five
mutually interfering variables.
Length
Height
lx!)
Volume
Width
Area
Adding edges may increase the chromatic numbe~ If x and y are not adjacent
in H, but are adjacent in G, then a coloring of H is a coloring of G unless
x and y are assigned the same color. In that case, an additional color may
be needed to color G. If the compiler assigns k = x(G) memory locations to a
program based on a coloring of G, then no two variables, joined by an edge
in G, receive the same color and so are not assigned to the same memory
location. Edges join every pair of “truly” interfering variables and maybe
more.
(i) 2(G) = cl (G) =2; (ii) x(G)= c1 (G) = 3; (iii) Z(G)= c1 (G) =3; (iv) Z(G)= 3,
cl (G) = 2; and (v) X(G) = cl (G) = 4.
A graph is 1-colorable if and only if it does not contain an edge. An aigorithm
to l-color could check that the graph contains no edges and then assign the
color 1 to every vertex.
535

SOLUTIONS TO QUESTIONS IN CHAPTER 8
5.6 
(a) 
Step 
No. 
I 
C[ J
Lj
5
7
7
7
5
7
7
5
7
7
5
7
7
5
7
7
5
7
5
1
1
1
~
1
6
1
7
‘)
~
2
3
2
7
3
1
3
4
3
7
4
2
4
5
4
7
5
1
5
6
5
7
6
2
6
7
7
3
(~)
(2, 3,4, 5,6)
<2,3,4,5,6, 7)
(1,3)
<3,4,5,6, 7)
(2,3,4)
(3,4, 5,6, 7)
(1,3,4,5)
(3,4,5,6,7)
(2, 3,4, 5,6)
(3,4> 5,6,7)
(3,4,5,6,7)
(b) 
Step 
No. 
I 
c, 
J
LJ
5
7
7
7
5
7
7
7
7
7
5
7
7
5
7
5
5
7
5
1
1
1
~
1
5
1
6
?2
~
2
3
2
4
2
5
2
6
2
7
3
1
3
4
3
7
4
3
4
5
5
4
6
3
6
7
7
4
(2)
(2, 3,4, 5)
<2,3,4, 5,6)
(1,3)
<1,3,4)
(3,4,5)
(3,4, 5,6)
<1,3,4,5,6,7)
(3, 4)
(3,4,5,6,7)
<4, 5)
<4,5,6, 7)
536

SOLUTIONS TO QUESTIONS IN CHAPTER 8
5.7 Here is a trace of BACKTRACKCOLOR applied to K4 with N = 3. Let the
vertices be x ~, .X2, X3, and X4.
Step No.
J
K
FOR WARD
C[l, 2, 3,4]
Main 1
~
TRUE
[1,0,0,0]
Color 1
7
7
3–5
i;
TRUE
[1,2,0,0]
Color 1
3
3
3-5
4
3
TRUE
[1,2,3,0]
Color 1
4
4
6
4
4
FALSE
Main 4,5
3
[1, 2, 3,0]
Color 1
3
4
6
3
4
FALSE
Main 4,5
2
[1,2,0,0]
Color 1
2
3
3-5 
3
3
TRUE
[1,3,0,0]
Color 1
3
2
3-5
4
2
TRUE
[1,3,2,0]
Color 1
4
4
6
4
4
FALSE
Main 4,5
3
[1,3,2,0]
Color 1
3
4
6
3
4
FALSE
Main 4,5
2
[1,3,0,0]
Color 1
~
4
6
~
4
FALSE
Main 4,5
1
[1,0,0,0]
6 THERE IS NO 3-COLORING OF G, STOP
537

INDEX
Acyclic graph, 253
Adjacency matrix, 268
Adjacent transportation, 160
Adjacent vertices, 242
Algorithm, 8. See afso Algorithms and
Procedures following Index.
approximation, 389
bad, 120
complexity, 119, 186–187
correct, 12
cubic, 104, 469
divide-and-conquer, 325
efficient, 118
exponential, 120
good, 11-12, 120
greedy, 273
input to, 11
linear, 95, 104
logarithmic, 95, 108
output, 11
polynomial. 120
quadratic, 104
recursive, 318
relative efficiency, 119
All Pairs Problem, 399
Arithmetic:
congruence, 211
modular, 211
modulo n, 211
Arithmetic progression, 124
Array, 33
2-dimensional, 289
ASCII code, 222
Backtracking, 439
Bad algorithm, 120
Ballot problem, 387
Base case of proof by induction, 72
Basic solution of recurrence relation, 356
Base 3 representation, 20
Bernoulli numbers, 345, 386-387
“Big oh” notation:
definition 1, 103
definition 2, 108
Binary:
coded decimal, 61
fraction, 8, 20
notation, 6
number, 6
tree, 303
full, 305
Binomial coefficient, 134
Binomial theorem, 169
Bipartite graph, 247
complete, 247
Bit (binary digit), 17
vector, 33
Boolean function, 51
AND, 51
associative law, 54
538

INDEX
commutative law, 54
distributive law, 54
NOT, 51
OR, 51
satisfiable, 56
variable, 148
XOR (exclusive or), 52
Breadth-first-search, 395, 436
spanning tree, 395
Busy Beaver N-game, 63
Cartesian product, 31
Catalan numbers, 342, 387-388
Ceiling function, 94
Center of a tree, 272
Characteristic equation, 355
Characteristic function, 33, 49
Characteristic polynomial, 355
Characteristic root, 355
Chromatic number of graph, 434
Clause, 55
Clique:
in graph, 246
number of graph, 434
CoIlatz problem, 11
Complement of graph, 277
Complete bipartite graph, 247
Complete graph, 246
Complete residue system, 220
Complexity of algorithm, 119, 186-187
Component of graph, 251, 253
Composite number, 140
Composition of functions, 45
Conclusion, 112
Congruent numbers, 211
Conjunctive normal form (CNF), 55
Connected directed graph, 410
strongly, 410
weakly, 410
Connected graph, 251, 253
Contradiction, 56
Contrapositive, 115
Converse, 116
Cube, generalized, 251
Cycle, 252
in directed graph, 406
Decimal number, 6
Decrypting key, 228
Decryption, 223
Degree of vertex, 243
De Morgan’s laws, 52
Depth:
of tree, 304
of vertex, 304
Depth-first search, 414
spanning tree, 415
Diameter of graph, 277
Difference quotient, 366
Directed graph, 406
Disjoint union, 28
Disjunctive normrd form (DNF), 58
Distance:
in graph, 253
in weighted graph, 272
Divisor, 182
Do 100P, 83
nested, 145
Domain of function, 40
Dual graph, 446
Eccentricity of vertex, 272
Edge of graph, 241
Encryption, 223
Equivalence class:
of equivalence relation, 214
modulo n, 211–212
Equivalence relation, 213
Euclidean algorithm, 190-193, 223
Euclidean equations, 192
Eulerian cycle, 400
in directed graph, 406, 426
Eulerian graph, 400
arbitrarily traceable, 407
Eulerian path:
in directed graph, 406
Euler phi function, 238
Euler’s formula, 446
Euler’s theorem, 238, 401
Exclusive or (XOR), 52
Exponent of encryption scheme, 224
Exponential algorithm, 120
Exponentiation, 68
Factorial function, 134
Factorial representation, 140
Fermat’s last theorem, 71-72
Fermat’s little theorem, 218-219, 238
Fibonacci numbers, 198, 360
and complexity of Euclidean algorithm, 206-
210
File, 286
Floor function, 94
For do loop, 83
539

INDEX
For 
down 
to 
do, 
156
Forest, 253
Four Color Problem, 433
Function(s), 40
characteristic, 33, 49
domain, 40
equal, 42
image, 40
inverse, 46
one-to-one (or l-l), 43
onto, 42
range, 40
target, 40
Generating function, 174
Geometric series, 74
alternating, 74
Good algorithm, 11-12, 120
Graph, 241
connected, 251, 253
directed, 406
Eulerian, 406
grid, 242
Hamiltonian, 411
isomorphism, 244
k-colorable, 434
k-colored, 434
perfect, 443
planar, 446
regular, 249
2-colorable, 247, 435
Greatest common divisor (gcd), 182, 185
Grid:
graph, 242
rectangular, 129
Hamiltonian cycle, 411
minimum-weight, 425
Hamiltonian graph, 411
Hamiltonian path, 411
Harmonic numbers, 342
Hereditary property, 273
Hierarchy of functions, 108
Hilbert’s tenth problem, 205
Hypothesis, 112
i (~), 358
Identity map (or permutation), 45
If and only if, 59, 116
Incident vertex and edge, 242
Independence number, 280
Independent set of vertices, 280
Induced subgraph, 262
Induction, 72
complete, 198
Inductive hypothesis, 73
Inductive step, 73
Information theoretic bound (on sorting), 314
Integers modulo n, 215
Interference graph, 433
Intractable problem, 120
Inverse function, 46
Isomorphic graphs, 244
Isomorphism:
of graphs, 244
of labeled graphs, 278
Iteration, 348
j-subset, 30
Key, 286
Kruskal’s algorithm, 264, 426
LamL’s theorem, 208
Leaf (in a tree), 272
Least common multiple (lcm), 185
Level of vertex, 304
Lexicographic ordering, 145-148
LHRRWCC (linear homogeneous recurrence
relation with constant coefficients), 353
Linear combination, 194, 357
Linear ordering, 221
Line graph, 424
Literal, 55
Local area network (LAN), 239
Logarithm (to the base 2), 92
Logically equivalent, 115
Loglog(rz),  102
Loop, 9
do, 83
nested, 145
for 
do, 
83
down to, 156
repeat . until, 164
while 
do, 
69
Lucas numbers. 364
Magic trick, 1
Mastermind, 161
Mathematical induction, 72
complete, 198
Matrix, 268
Maximal subset, 273
Mhrimum-distance spanning tree, 390
Minimum-weight matching problem, 405
Minimum-weight spanning tree, 258, 264
540

INDEx
Modular arithmetic, 211
Modulo n, 211
Multigraph, 408
Multiple:
of an integer, 182
root, 358
Multiplication principle, 2
generalization, 87
Multiplicative inverse modulo n, 217
Multiplicity of root, 358
Mrdtiset, 35, 164
Natural numbers, 21
Negation, 111
NP-Complete problem, 420
n-set, 29
n-tuple, 32
Null set, 21
One-to-one function, 43
Onto function, 42
Ordered pair, triple, 32
Pancake problem, 338
Partition, 28, 214
Pascal’s triangle, 133-134
Path, 252
in directed graph, 406
length, 252, 390
Permutation(s), 44, 153
distance between, 160
and English change ringing, 159– 160
even, 160
identity, 45
inversions, 180
odd, 160
Pigeonhole principle, 44
Polynomial algorithm, 120
Polynomird identity, 74
Prime number, 21
Principle of inclusion and exclusion, 38
Procedure, 296
Proof by contradiction, 110
Public key encryption scheme, 223
Quadratic formula, 362
Quotient, 191
Radius of graph, 398
Range of function, 40
Record, 286
Recurrence relation, 346
constant coefficient, 353
divide-and-conquer, 373
homogeneous, 349
inhomogeneous,  349
initial conditions, 347
linear, 353
order, 353
Recursive algorithm, procedure, 318
Reducing modulo n, 225
Reflexive property of relation, 213
Relation, 212-213
graph of symmetric, 245
Relatively prime integers, 218
Remainder, 191
Repeat . . . until, 164
Residue, least nonnegative, 214
Root of tree, 303
RSA scheme. 223
Satisfiability problem, 57, 122
Search tree, 303
binary, 311
Sequence, 339
integer, 339
nth term, 340
symmetric, 140
unimodal, 140
Set(s), 21
cardinality, 35
complement, 22
difference, 25
disjoint, 25
element, 21
empty, 21
equality, 21
finite, 35
intersection, 22
null, 21
relative complement, 25
subset(s), 21
number, 80
number of j-subsets of n-set, 142
union, 22
Sieve of Eratosthenes, 236
Simplified fraction, 181
Spanning forest, 257
Spanning-in-tree, 410
Spanning subgraph, 256
Spanning tree, 256
Stable sorting algorithm, 334
Stirling’s formula, 158
Storage allocation scheme, 432-433
Subgraph, 256
induced, 262
541

INDEX
Subtrees (left and right), 303
Symmetric property of relation, 213
Target of function, 40
Tautology, 56
Ternary representation, 20
Total ordering, 221
Towers of Hanoi. 382
Trace of an algorithm, 17
Transitive closure of a graph, 282
Transitive property of a relation, 213
Trapdoor function, 223
Traveling Salesrepresentative Problem, 274
Tree, 253
binary, 303
planted planar, 388
search, 303
Trivial programming language, 62–63
Universe, 20
Variables:
Boolean, 148
interfering, 432
noninterfering, 432
Vector, 33
Venn diagram, 26
Vertex of a graph, 241
Weighted graph, 257
Well defined operation, 215
While 
do, 
69
Wilson’s theorem, 238
Worst-case analysis, 92
542

ALGORITHMS AND
PROCEDURES
ADDRACT1 , 482
APPROXHAM, 428
BACKTRACKCOLOR, 440-441
BADMINTREE, 258
BINARYSEARCH, 291
BINARYSORT, 297
BININSERT, 296
Borihka’s algorithm, 280
BREADTHFIRSTSEARCH (BFS), 395
BtoD, 16
BUBBLES, 87
BUBBLESORT, 288
BUCKETSORT, 332, 338
COLLATZ, 11
DEPTHFIRSTSEARCH (DFS), 415
DFS-HAMCYCLE, 418-419
DIJKSTRA, 392
DIJKSTRA2, 398-399
DIVISORSEARCH, 234
DtoB, 18, 84, 89
EUCLID, 195
EULER, 408-409
EXPONENT, 68, 82, 188-189
FASTEXP, 91, 187
FIB, 319
FIB2, 323
FOURSUM, 85
FUN, 15
GCD, 320
GCD1 , 183, 187-188
GCD3, 335
GREEDYCYCLE, 501
GREEDYMAX, 501
GREEDYMIN, 273
HAMCYCLE, 413
HAMCYCLE2, 422-423
IND, 281
INDUCTION, 73
INDUCTION, 199
INSERTIONSORT, 334
JSET, 148
KRUSKAL, 264, 426
LABGPHISO, 278
MAX, S6
MERGE, 326
MERGESORT, 327
543

ALGORITHMS AND PROCEDURES
MIN, 318, 320
MYSTERY, 337
ODDSUM, 85
PAIR, 145
PERM, 156
POSTAGE, 432
Prim’s, 280
R-DEPTHFIRSTSEARCH, 417-418
R-DtoB, 335
R-JSET,  324
RSA, 232
R-SELECTSORT, 321
R-SUBSET, 324
SELECTSORT, 285
SEQSEARCH. 284
SEQUENTIALCOLOR, 436-437
SIMPLIFY, 184-.
SPEEDY, 118
SPTREE, 262-263
SQUARESUM, 86
SUBSET, 30-31
SUM, 83
TREESORT, 307
VOLUME, 431
544

NOTATIONS
K end of proof, 27-28
Algorithmic:
: = assignment statement, 15
* multiplication symbol, 15
/ division symbol, 15
Set theory:
A x A, An A x B Cartesian product, 31-
33
~ containment, 21
A’ the complement of A, 22
{...} curly brace notation for sets, 21
A–B difference, 25
e element of, 21
@ empty set, null set, 21
n
intersection, 22
(a1,a2,. . . ,an) n-tuple, 31
(a,b) ordered pair, 31
(a,b,c) ordered triple, 31
(...) permutation, 153
array, 284
u
union, 22
Functions:
(!) binomial coefficient. 135
Boolean functions:
A AND, 51
v OR, 51
- NOT, 51
@ XOR, 53
[ ] ceiling function, 94
x, characteristic function, 49
(g 0 ~) composition of functions, 45
f’,f’, f”, 49-50
~! factorial function, 134
( J floor function, 94
log(n) logarithm to the base, 2, 92
log,(n) logarithms to the base d, 124, 376
O(g) big oh of g, 103, 108
Number theory:
~ ~ b (mod n) equivalence modrdo n, Z I I
[x] equivalence class modulo n, 211
F, kth Flbonacci  number, 198
gcd(b,c) greatest common divisor, 182
gcd(a, b,c), 185
Icm(b,c) least common multiple, 185
6 phi, 202
+, ~03
6(M) Euler phi function. 238
- relation, 212–213
Z. integers modulo n. 215
Graph theory:
a(G) independence number of G, 280
A(G) adjacency matrix, 268
C, k-cycle, 253
x(G) chromatic number of G, 434
545

NOTATIONS
Graph theory (Continued)
cl(G) clique number of G, 434
deg(x), deg(x, G) degree of vertex x, 243
d(G) diameter of the graph G, 398
d(x,y) distance from x toy, 253, 272
E(G) the set of edges of the graph G, 242
G’ the complement of G, 277
K. the complete graph on r vertices, 246
K ~,~ the complete bipartite graph, 247
L(G) line graph of G, 424
Nbor(u) neighbor of the vertex u, 408
P, k-path, 253
Q. generalized cube or n-cube, 251
r(G) radius of G, 398
V(G) the set of vertices of the graph G,
242
w(e) weight of an edge e, 257
w(T) weight of a tree T, 257
546

