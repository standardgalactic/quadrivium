
iii 
 
 
 
 
The Unofficial Guide to LEGO® MINDSTORMS™ Robots 
 
 
 
Jonathan B. Knudsen 
 
 
 
O’REILLY 
 
 
 
 
 
Beijing • Cambridge • Farnham • Köln • Paris • Sebastopol • Taipei • Tokyo 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

iv 
The Unofficial Guide to LEGO® MINDSTORMS™ Robots 
by Jonathan B. Knudsen 
 
 
 
Copyright: © 1999 O'Reilly & Associates, Inc. All rights reserved. 
Printed in the United States of America. 
 
Published by O'Reilly & Associates, Inc., 101 Morris Street, Sebastopol, CA 95472. 
 
Editor: Mike Loukides 
 
Production Editor: Nicole Arigo 
 
Printing History: 
 
October 1999: First Edition. 
 
This book is published solely by O'Reilly & Associates, Inc., and its purpose is to enable you to creatively program 
LEGO® MINDSTORMS™ brand robots. This book is not sponsored by The LEGO® Group. 
 
Nutshell Handbook, the Nutshell Handbook logo, and the O'Reilly logo are registered trademarks of O'Reilly & Associates, Inc. The 
association of the image of a mechanical toy rabbit with the topic of LEGO® MINDSTORMS™ robots is a trademark of O'Reilly & 
Associates, Inc. LEGO® is a registered trademark of The LEGO® Group. MINDSTORMS™ and Robotics Invention System™ are 
trademarks of The LEGO® Group. All other trademarks, service marks, and the like are the property of their owners. 
 
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those 
designations appear in this book, and O'Reilly & Associates, Inc. was aware of a trademark claim, the designations have been printed in caps 
or initial caps. 
 
While every precaution has been taken in the preparation of this book, the publisher assumes no responsibility for errors or omissions, or for 
damages resulting from the use of the information contained herein. 
 
ISBN: 1-56592-692-7 [12/99] 
[M] 

vii 
Table of Contents 
 
Preface xi 
 
1. Welcome to MINDSTORMS 1 
 
 
 
What Is a Robot? 2 
 
 
Mobile Robots 2 
 
 
What Is MINDSTORMS? 6 
 
 
What Now? 11 
 
 
Online Resources 11 
 
2. Hank, the Bumper Tank 14 
 
 
About the Building Instructions 14 
 
 
 
Building Instructions 16 
 
 
A Simple Program 25 
 
 
Wheels 27 
 
 
Bumpers and Feelers 31 
 
 
Gears 31 
 
 
Multitasking 36 
 
 
Online Resources 37 
 
3. Trusty, a Line Follower 39 
 
 
Building Instructions 40 
 
 
Some Tricky Programming 44 
 
 
The Light Sensor 48 
 
 
Idler Wheels 50 
 
 
Using Two Light Sensors 50 
 
 
Online Resources 52 
 
4. Not Quite C 53 
 
 
A Quick Start 54 
 
 
RCX Software Architecture 55 
 
 
NQC Overview 58 
 
 
Trusty Revisited 77 
 
 
Online Resources 81 
 
 
 
 
 
 
 

viii 
5. Minerva, a Robot with an Arm 82 
 
 
Building Instructions 83 
 
 
Programming 103 
 
 
Directional Transmission 107 
 
 
Pulleys 109 
 
Mechanical Design 110 
 
 
Two Sensors, One Input 112 
 
 
Where Am I? 113 
 
 
Online Resources 115 
 
6. pbFORTH 116 
 
 
Replacement Firmware 116 
 
 
pbFORTH Overview 117 
 
 
About Forth 121 
 
 
pbFORTH Words 126 
 
 
An Expensive Thermometer 137 
 
 
Minerva Revisited 138 
 
 
Debugging 142 
 
 
Online Resources 143 
 
7. A Remote Control for Minerva 145 
 
 
Two Heads Are Better Than One 145 
 
 
The Allure of Telerobotics 146 
 
 
Building Instructions 147 
 
 
Programming the Remote Control 151 
 
 
Programming Minerva 154 
 
 
Online Resources 157 
 
8. Using Spirit.ocx with Visual Basic 159 
 
 
You May Already Have Visual Basic 159 
 
 
About Spirit.ocx 160 
 
 
Calling Spirit.ocx Functions 161 
 
 
Immediate and Delayed Gratification 163 
 
 
Programs, Tasks, and Subroutines 164 
 
 
Tips 165 
 
 
Retrieving the Datalog 168 
 
 
Online Resources 171 

ix 
9. RoboTag, a Game for Two Robots 173 
 
 
Building Instructions 174 
 
 
Subsumption Architecture 179 
 
 
Online Resources 188 
 
10. legOS 189 
 
 
About legOS 189 
 
 
Development Tools 190 
 
 
Hello, legOS 192 
 
 
Function Reference 193 
 
 
New Brains for Hank 204 
 
 
Development Tips 211 
 
 
Online Resources 213 
 
11. Make Your Own Sensors 216 
 
 
Mounting 216 
 
 
Passive Sensors 219 
 
 
Powered Sensors 221 
 
 
Touch Multiplexer 224 
 
 
Other Neat Ideas 226 
 
 
What About Actuators? 226 
 
 
Online Resources 227 
 
A. Finding Parts and Programming Environments 230 
 
B. A pbFORTH Downloader 235 
 
C. Future Directions 240 
 
Index 242 

xi 
Preface 
 
This is a book for people who build and program LEGO® robots with the Robotics Invention System (RIS)™ set. This book is the answer to 
the question, "How can I push this thing as far as it will go?" Once you've built a few robots and written a few programs, you'll probably be 
itching for more: more complex robots, more powerful programming environments, more sensors, and more fun. This book will take you 
there. 
 
About This Book 
 
For many of us, plastic LEGO bricks are the best toy money can buy. When I was five and broke my leg, a little LEGO set was the high 
point of my six-week convalescence. I grew up building spaceships and planetary rovers, wearing grooves in the ends of my fingernails from 
endlessly putting together and taking apart my creations. In high school, I shifted into the TECHNIC™ product line—what could be better 
than cars with real shifting and pistons that worked? 
 
In the Fall of 1998, The LEGO Group released the Robotics Invention System (RIS), a set that was part of a new product line called 
MINDSTORMS™. This set entered the world like a lightning bolt—finally, the chance to make LEGO models that moved, sensed, and 
thought! The LEGO Group made 80,000 of these sets in 1998 and sold every one. Although The LEGO Group was aiming for young adults, 
11 and older, the RIS has also hypnotized many people in their 20s, 30s, and beyond. 
 
A vibrant, inventive online community sprang up around MINDSTORMS robots. In some ways, this book is an introduction to the most 
important developments in that community—alternate programming environments and advanced building techniques. But this book goes 
farther than that, painting a backdrop of the theories and practices of mobile robotics. 

xii 
Building and programming robots is exhilarating. It's fun to build something that moves and thinks, in a sense; at the same time, you're 
learning a lot about how things work, mechanically, and how to write programs that can deal with the real world. This book is designed to 
take you to the next level of building and programming, all in the spirit of fun and learning. 
 
This book's chapters come in two basic flavors. Five chapters have robot projects, complete with building instructions and programs. Four 
chapters describe various programming environments for LEGO MINDSTORMS robots, including code examples and debugging tips. The 
first and last chapters don't fit in either category. 
 
Here's a description of each chapter in this book: 
 
Chapter 1, Robotics and MINDSTORMS, introduces the field of mobile robotics and describes how the LEGO MINDSTORMS Robotic 
Invention System fits in the larger picture of the field. 
 
Chapter 2, Hank, the Bumper Tank, is the first building project—a tank-style robot that avoids obstacles in its path. This chapter discusses 
basic mechanical features like gears and bumpers. 
 
Chapter 3, Trusty, a Line Follower, covers a slightly trickier robot—a line-follower. It uses a light sensor to follow a black line on the floor. 
 
Chapter 4, Not Quite C, introduces the Not Quite C (NQC) language. NQC is an excellent environment for programming robots. The chapter 
includes descriptions of NQC's functions as well as many examples. 
 
Chapter 5, Minerva, a Robot with an Arm, contains another building project—by far the most complex robot in the book. You'll learn about 
directional transmissions and other neat stuff. 
 
Chapter 6, pbFORTH, discusses an innovative programming environment based on a language called Forth. 
 
Chapter 7, A Remote Control for Minerva, is another project-based chapter. Using a second robot kit, you can build a remote control for the 
robot from Chapter 5. 
 
Chapter 8, Using Spirit.ocx with Visual Basic, talks about how to control and program your robots using Microsoft's Visual Basic. 
 
Chapter 9, RoboTag, a Game for Two Robots, shows how to create a pair of robots that play tag. 
 
Chapter 10, legOS, discusses legOS, a programming environment that enables you to program your robots with C, C++, or assembly code. 
 
Chapter 11, Make Your Own Sensors, describes how you can build sensors for your robots easily and inexpensively. 

xiii 
Appendix A, Finding Parts and Programming Environments, describes various parts you can get to expand your RIS set and where to find 
them. It also includes a summary of the programming environments that are available for RIS. 
 
Appendix B, A pbFORTH Downloader, contains the source code for a program that downloads Forth code to your robots. It's a supplement 
to Chapter 6. 
 
Appendix C, Future Directions, describes some interesting emerging technologies related to LEGO robots. These are ideas or projects that 
weren't fully baked as this book went to press. 
 
About the Examples 
 
Versions 
 
This book covers a handful of rapidly evolving technologies. The versions used in this book are as follows: 
 
RCX 
Version 1.0 
 
NQC 
Version 2.0b1 
 
pbFORTH 
Version 1.0.7 
 
legOS 
The March 30, 1999 build, a patched version of 0.1.7 
 
Downloading 
 
All of the examples in this book can be downloaded from http://www.oreilly.com/catalog/lmstorms/ . This site also provides a listing of the 
"Online Resources" that appear at the end of each chapter. 
 
Font Conventions 
 
Constant width is used for: 
 
• Function and subroutine name 
 
• Source code 
 
• Example command-line sessions—the input you type is shown in boldface 

xiv 
Italic is used for: 
 
• Pathnames and filenames 
 
• New terms where they are defined 
 
• Internet addresses, such as domain names and URLs 
 
Boldface is used for the names of buttons. 
 
     
                                                                                                          
This is a note with information that supplements the text.
 
 
  
This is a warning with a cautionary message for the reader.
 
Request for Comments 
 
If you find typos, inaccuracies, or bugs, please let us know. You can reach O'Reilly by mail, telephone, fax, or email: 
 
 
O'Reilly & Associates, Inc. 
 
101 Morris Street 
 
Sebastopol, CA 95472 
 
(800) 998-9938 (in the U.S. or Canada) 
 
(707) 829-0515 (international or local) 
 
(707) 829-0104 (fax) 
 
bookquestions@oreilly.com
 
Please let us know what we can do to make the book more helpful to you. We take your comments seriously, and will do whatever we can to 
make this book as useful as it can be. 
 
Acknowledgments 
 
This book is the result of a crazy idea I had in mid-1998, when I first heard that the Robotics Invention System was coming. LEGO robots 
sounded like something O'Reilly readers would like to play with—why not write a book about them? I'd like to thank Mike Loukides and 
Tim O'Reilly for having the vision to believe in this book. Thanks to Mike, again, for excellent help and feedback. 

xv 
I'd like to thank my parents for buying me LEGO sets when I was a kid. Did you ever expect something like this? 
 
Many thanks go to my wife, Kristen, for helping to create this book. She first suggested its project-oriented organization; she gave me 
excellent feedback on many of its chapters; she got me RolyKits to help organize my pieces; she is able to keep a straight face when we tell 
people I'm writing a book about LEGO robots; she stayed up late nights helping me finish the book. 
 
I'm grateful to my daughter, Daphne, who finally believes that building LEGO robots is part of my job. ''Want to see Daddy," she said one 
day. Kristen explained, "No, no, sweetheart, Daddy's working right now." With tears in her eyes, Daphne said, "Daddy's not working. Daddy 
play LEGOs." Someday, I promise, I'll let Daphne play with the whole set, not just the bendy purple things. And thanks to my sons, Luke 
and Andrew, just for being great guys. You can build robots someday too, if you wish. 
 
The building instructions in this book were a special challenge. I first sketched out the building instructions with photos from a digital 
camera. Once these were finished, Kristen took over 475 photographs with a regular camera. We selected the best and sent them off to the 
O'Reilly illustration department. These photographs were scanned in and meticulously touched up, cropped, edited, and manipulated to 
produce the instructions that you see in the book. I owe many thanks to Rob Romano for his hard work on these instructions. 
 
This book has had an excellent set of technical reviewers. Ralph Hempel, Todd Lehman, Russel Nelson, Suzanne Rich, John Tamplin, 
ActivMedia Robotics ( http://www.activrobots.com/ ), and Ben Williamson provided insightful and authoritative feedback on a draft of this 
book. Thanks also to Stephan Somogyi for encouraging me to include more information about using a Macintosh with MINDSTORMS. 

 
1
1 
Welcome to MINDSTORMS 
 
 
In this chapter: 
 
 
• What Is a Robot? 
 
 
• Mobile Robots 
 
 
• What Is MINDSTORMS? 
 
 
• What Now? 
 
 
• Online Resources 
 
 
This is a book about creating robots with the LEGO® MINDSTORMS™ Robotic Invention System (RIS)™. If you've always 
dreamed of building and programming your own robots, this is your big chance—the RIS set makes it easy to get started. 
There are a lot of enthusiastic RIS owners out there already: other people have built robots that pick up empty soda cans; 
robots that seek light; robots that play tag; walking robots with two, four, six, or even eight legs; robots that can be controlled 
over the Internet; working computer peripherals like a plotter and an optical scanner; and robots that simulate a Tsunami and a 
tornado.∗ You can build anything you can imaging. RIS gives you a chance to breathe life into LEGO creations, making them 
move and respond to their surroundings. You can create a tank that scurries into the dark, or a monorail car that traverses your 
living room on a string. You can create robots that hop, walk, and drive around with a mind of their own. 
 
Furthermore, by owning the RIS set, you become part of a worldwide community of enthusiasts. The RIS set is a common 
ground for building robots; if you build something cool, other people will be able to build it too. Similarly, you can build and 
modify other people's creations. LEGO bricks, therefore, are a kind of lingua franca for mechanical design. 
 
You have many options when it comes to building and programming robots. LEGO bricks, of course, can be assembled in 
many different ways. Part of this book is about building robots; it includes five projects that you can build yourself. But you 
also have lots of options for programming your robot. Aside from the "official" software that comes with RIS, the inventive 
MINDSTORMS community  has produced a bevy of other options. The most important ones are described in this book. 
 
∗ Internet links to pictures of some of these robots are included in the "Online Resources" section at the end of this chapter. 

 
2
This chapter describes the basic concepts of robotics and creates a backdrop for the MINDSTORMS product line. I'll also 
cover different approaches to programming mobile robotics. Finally, I'll describe the RIS set itself. If you're in a hurry to start  
building something, skip ahead to Chapter 2, Hank, the Bumper Tank. 
 
What Is a Robot? 
 
A robot is a machine whose behavior can be programmed. This is a broad definition—it includes things like VCRs and 
microwave ovens, a far cry from the talking androids you might be thinking  of. Robots have five fundamental components: 
 
1. A brain controls the robot's actions and responds to sensory input. Usually the brain is a computer of some kind. 
 
2. A robot's body is simply the physical chassis that holds the other pieces of the robot together. 
 
3. Actuators allow the robot to move. These are usually motors, although there are many other possibilities, such as  hydraulic 
pistons. 
 
4. Sensors give a robot information about its environment. A touch sensor, for example, can tell a robot that it has come in 
contact with something else. 
 
The last component is not always obvious: 
 
5. A power source supplies the juice needed to run the brain, actuators, and sensors. 
 
For example, think about a robot that spraypaints cars in a factory. Its brain is probably a garden-variety desktop computer. 
The body is a big arm with a paint sprayer at the end. The actuators are motors or pneumatic pistons that move the arm around. 
Position and rotation sensors are used so the robot knows where the sprayer is and what direction it's pointing. The whole thing 
is plugged into a wall socket for power. 
 
Mobile Robots 
 
Mobile robots present special challenges. These robots can move their bodies around from place to place. Why is this 
capability difficult? Many more things can go wrong if your robot is free to move around rather than being bolted to one place. 
Being mobile multiplies the number of situations your robot needs to be able to handle. 

 
3
Mobile robots actually come in two varieties: tethered and autonomous. A tethered robot "cheats" by dumping its power 
supply and brain overboard, possibly relying on a desktop computer and a wall outlet. Control signals and power are run 
through a bundle of wires (the tether) to the robot, which is free to move around, at least as far as the tether will allow. 
 
Autonomous mobile robots are even more challenging. These robots need to bring everything along with them, including a 
power supply and a brain. The power supply is typically an array of batteries, which adds a lot of weight to the robot. The brain 
is also constrained because it has to fit on the robot, not weigh a ton, and be frugal about sucking power out of the batteries. 
 
This Is Tough Stuff 
 
The field of autonomous mobile robotics is extremely challenging. Have you ever seen an autonomous mobile robot, besides in 
the movies? Probably not. If you have been lucky enough to see such a robot, was it doing something useful? Probably not. If 
the robot was supposed to do something useful, did it work? Probably not. 
 
If it wasn't so hard to make autonomous mobile robots, the world would be full of them. Wouldn't it be nice to have a robot do 
your laundry or drive you to the airport? But the cold truth is that it's unbelievably difficult to make a robot that can do even 
the simplest of tasks. It all comes down to one fact: it's very hard to deal with the real world. 
 
To understand this, think about how you might try to make a robot to vacuum your living room. This is a pretty simple task to 
describe: basically you just want to move the vacuum back and forth over the rug until the whole thing is clean. Suppose you 
modify your vacuum cleaner so that it can move around on its own, by adding more motors and a small computer brain. Just 
consider the staggering complexity: 
 
• How does the robot keep from getting tangled up in its own power cord, assuming it's a tethered robot? If it's not tethered, 
you need to find a power supply that will run the robot for long enough to clean at least one room. 
 
• How does the robot know where it's been already? How does the robot know where it is? How does it know where to go 
next? 
 
• How does the robot navigate around obstacles like table legs and furniture? 
 
• How does the robot recognize things it shouldn't vacuum, like money, or toys, or your cats? 
 
You can answer these questions, but not well, not simply, and not cheaply. After years of sweat and expense, you might 
produce a robot that could vacuum a room, but only under very closely controlled conditions. Add a rocking chair, or drop a 
child's toy in the middle of the room, and you'd probably have to start all over again. 
 

 
4
Another reason that robotics is so challenging is that it spans many different disciplines. Suppose that you want to go down in 
your basement and build a mobile robot. Without some sort of kit, you'd probably need to take along a team of highly 
educated, highly paid engineers, including: 
 
• An electrical engineer chooses the brain, sensors, and maybe the actuators, and wires them all together. This person  probably 
selects the power supply, as well. 
 
• A mechanical engineer designs the body and possibly selects the actuators. The mechanical person needs to be familiar with 
the other components of the robot (brain, sensors, actuators, and power supply) so that everything fits together mechanically. 
 
• A computer programmer writes the software for the robot. This task usually requires intimate knowledge of the brain, 
sensors, and actuators that the electronics and mechanical people have chosen.  
 
• For specialized designs, you might even want to have a chemical engineer to select or design the power supply. 
It is very rare for a single person to be knowledgeable in all of these fields. Designing a mobile robot, then, is often a  
collaborative effort, which makes it even more complex. 
 
Autonomous mobile robots, for the most part, are still confined to the research programs of colleges, universities, and 
governments. This research is divided into two camps: the big robot people and the little robot people. 
 
Big Is Beautiful 
 
The big robot people believe that the robot should understand its environment and "think," more or less the same way that a 
human does. This is the traditional Artificial Intelligence (AI) approach to robotics. In this approach, the robot takes input from 
its sensors and tries to build a map of its surroundings. This process alone is very complicated: the robot might use a pair of 
video cameras or some more exotic sensors to examine its surroundings, while heavy-duty computers analyze all the sensor 
data and attempt to build a map. Finally, in a process called task planning, the robot tries to figure out how it will accomplish 
an objective—getting from one point to another, or picking up an object, or some other simple task. In this respect, again, the 
robot is expected to think like a human being. The heavy computing requirements of the AI approach consume a lot of power, 
which implies a bulky, heavy power supply. Hence, the robot can be pretty big and expensive, too. 
 

 
5
 
 
He Ain't Heavy, He's My Robot 
 
A good example of the "big iron" approach to mobile robots is Ambler,  
developed by Carnegie Mellon University and the Jet Propulsion Laboratory.  
This behemoth stands about 5m (16.4ft) tall, is up to 7m (23.0ft) wide,  
and weights 2500 kg (5512 lb). It moves at a blistering 35 cm (13.8 in) per  
minute. Just sitting still, it consumes 1400 W of power. Ask it to walk and  
it sucks up just about 4000 W. You can see a photograph of Ambler at  
http://ranier.oact.hq.nasa.gov/telerobotics_page/Photos/Ambler.jpg . 
 
Small Is Beautiful 
 
Little robot people like to tease the big robot people for building tremendously large, tremendously expensive machines that 
don't have the dexterity of a six-month-old baby. The little robot people make small mobile robots based around inexpensive, 
off-the-shelf parts. They like to see themselves as mavericks, achieving decent results at a fraction of the cost and complexity 
of big robotics. 
 
One of the interesting ideas behind small robot research is the idea that quantity might get the job done rather than quality. 
Instead of building a single bulky, complex robot to explore the surface of Mars, why not send a thousand robots the size of 
mice to do the same job? So what if a few of them fail? Small robots offer a new and innovative way to approach big 
problems. 
 
The small robotics approach reduces the number of engineers you need in your basement. It makes robotics accessible to 
sophisticated hobbyists—people with technical knowledge and some extra time and money. If you take the small robot 
approach, you'll probably use standard batteries for power, which eliminates the need for a chemical engineer to design a 
power supply. Small robots are usually based on an existing, cheap microprocessor, which makes the electrical engineer's job a 
little easier. But you still need quite a bit of expertise: 
 
• The electrical engineer still has to select sensors and actuators and wire them to the microprocessor. These parts are 
inexpensive and can be bought from hobby stores or electronics part stores. 
 
• The computer programmer still needs a pretty low-level understanding of the microprocessor and the attached sensors and 
actuators. 
 
• You still need a mechanical engineer to design the robot's body. 

 
6
The sophisticated hobbyist can do all of these things alone. But you have to be determined and have a lot of free time and 
money. There are a couple of ways to make things easier: 
 
• You could buy a prebuilt robot brain. Some companies sell kits that are designed specifically to be used as robot brains. This 
approach saves you the trouble of selecting a microprocessor and getting it running, but you still have to select sensors and 
actuators and attach them to the brain somehow. 
 
• You could use a modular construction kit to build the robot's body. LEGO® bricks are one possibility—in fact, researchers 
and students at the Massachusetts Institute of Technology (MIT) have been using LEGO bricks for mechanical prototyping for 
over a decade.  
 
An even better simplication, of course, is the MINDSTORMS™ Robotics Invention System itself. 
 
What Is Mindstorms? 
 
MINDSTORMS is the name of a product line sold by The LEGO Group. The LEGO Group has a handful of product lines that 
cater to different age groups, some of which are shown in Table 1-1. 
 
Table 1-1. Representative LEGO Product Lines 
 
Product Line Name Suggested Ages 
 
LEGO® PRIMO™ 3 months to 24 months 
 
LEGO® DUPLO™ 18 months to 6 years 
 
LEGO® SYSTEM™ 3 years to 12 years 
 
LEGO® TECHNIC™ 7 years to 16 years 
 
LEGO® MINDSTORMS™ 11 years and older 
 
The centerpiece of MINDSTORMS is the Robotics Invention System (RIS), a set for building robots. It makes the challenges 
and excitement of mobile robotics accessible to anyone with $200US and a desktop computer (PC). It gives you a chance to 
solve problems in innovative ways. Best of all, it's a lot of fun. 
 
The RIS set eliminates many of the difficulties of building mobile robots: 
 
• The set comes with a robot brain called the RCX.∗ The RCX is a small computer that is neatly packaged in a palm-sized 
LEGO brick. 
 
∗ Some people think RCX stands for Robotic Controller X. According to the MINDSTORMS web site, RCX stands for 
Robotic Command Explorer. 

 
7
 • Two touch sensors and one light sensor are included in the RIS set. Wiring the sensors to the RCX is as simple as snapping 
LEGO bricks together. 
 
• The set also includes two motors. Like the sensors, they can be connected to the RCX by just snapping LEGO bricks 
together. 
 
• The RCX uses six standard AA batteries for power. It also includes a power jack. You can supply power in either polarity, 
even AC, from 9V to 12V. 
 
• The set includes more than 700 LEGO pieces that you can use to build the body of the robot. 
 
• You can write programs for the brain using an intuitivé, highly visual programming environment on your PC. Programs are 
sent to the RCX over an infrared (IR) data link. The set includes an IR tower that attaches to one of the serial ports on your PC. 
Just point the tower at the RCX, and you're ready to download programs. 
 
You don't need an electrical engineer anymore because the brain, sensors, and actuators that come with the RIS set are easy to 
hook up. You don't need a computer programmer anymore because the programming environment is easy to use. And you 
don't need a mechanical engineer because building a body is as simple as building a LEGO model. 
 
Figure 1-1 illustrates the basic setup. Building a robot using MINDSTORMS consists of four steps: 
 
1. Build the robot's body. 
 
2. Write a program for the robot using software tools on your PC. 
 
3. Download the program to the robot. 
 
4. Run the program. 
 
This is only a sketch of the process, of course; it's likely you'll repeat the steps many times as you gradually improve the 
mechanical design and software of your robot. 
 
You can create a program on your PC using the MINDSTORMS software. Then you need to download it to the RCX using the 
IR link. Once the program is downloaded, your robot is ready to go. 
 
Is it a good deal? Yes. You could build a comparable setup by buying the pieces separately, but it would cost more and would 
not be nearly as easy to use. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
8
Meet the RCX 
 
The RCX is a robot brain in the form of a bulky LEGO brick. Figure 1–2 shows a photograph of the top of the RCX. 
 
 
 
Figure 1-1. 
Basic MINDSTORMS setup 
 
 
 
Figure 1-2. 
The RCX, a robot brain 
 
The RCX is a small computer with the following features: 
 
outputs 
Three output ports, labeled A, B, and C, are located near the center of the brick. The robot's actuators (motors or lights) can be 
attached to these ports. 
 
inputs 
Three input ports, labeled 1, 2, and 3, are provided. Various types of sensors can be attached to these ports to allow the RCX to 
find out about its environment. 

 
9
screen 
The RCX includes a small LCD screen. This screen displays helpful information such as sensor readings and output port  
settings. 
 
sound 
The RCX is capable of producing beeps of different frequencies. 
 
front panel buttons 
Four buttons are provided to control the RCX. You can select a program, start it, and stop it. You can also view the values of 
attached sensors or check the settings on output ports. 
 
IR communications link 
The RCX communicates with your PC through the IR (infrared) link, similar to that on a television remote control. It can also 
communicate with other RCXs through this link. 
 
About the Software 
 
The CD-ROM that comes with RIS contains a lot of software. Basically it can all be distilled down to three pieces: 
documentation 
 
The RIS software includes extension tutorials about setting up and programming the RCX. These include animations, movies, 
and detailed, step-by-step instructions. When you first begin using the software, it is in guided mode, which means the software 
tells you what to do next. This is a good way to get used to the software and the RCX. 
 
programming environment 
The RIS software includes an environment you can use to write programs that will run on the RCX. In the computer world, this 
technique is called cross-compiling, meaning you write a program on one computer that you intend to run on another. In this 
case, you use your PC to write a program that will be run on the RCX. As you'll see, there are many ways to write programs 
for your RCX; the official environment that comes with RIS is only one of them. This book will introduce you to four powerful 
alternate programming environments. 
 
program downloader 
Once you've written a program for the RCX, you need to know how to run it. The RIS software includes a program 
downloader for this purpose. The program downloader is a special application that runs on your PC. It knows how to transmit 
your robot programs into the RCX using the IR link. 

 
10
What About MacOS and Linux? 
 
Currently, the software that comes with RIS runs only on Windows. If you have MacOS or 
Linux, however, you can still program your robots, just not with the official software. The 
best option, at least to get started, is NQC, which is described in Chapter 4. Appendix A, 
Finding Parts and Programming Environments, lists the different packages that are 
available. If you really want visualstyle programming (like RCX Code), you can purchase 
ROBOLAB, which provides a similar (but more powerful) environment on MacOS. 
There's one final wrinkle if you want to program from MacOS: you'll need a suitable cable. 
The following web page describes the issues of programming the RCX from MacOS, 
including cables: http://www.enteract.com/~dbaum/lego/macmind/index.html . 
 
You can purchase a Macintosh IR tower cable from Pitsco LEGO DACTA for $15US. See Appendix A for details. 
 
Expansion Sets 
 
Aside from the basic RIS set, the MINDSTORMS product line also includes expansion sets. These sets provide additional 
parts and software to supplement the RIS set. Two such sets exist, each selling for about $50US : 
 
Extreme Creatures 
This set comes with about 150 LEGO pieces and is designed so you can add decorative jaws and claws to your robots. It 
includes a light that can be attached to one of the output ports of the RCX. 
 
Robosports 
This expansion set includes about 90 LEGO pieces, two balls, two pucks, and an additional motor. It's oriented towards robots 
that can play different sports. 
 
A third expansion set, Exploration Mars, should be released sometime in 1999. 
 
Among LEGO enthusiasts, the consensus is that the expansion sets are not as good a value as the RIS set itself. If you're 
looking for extra pieces, it might be better to buy a LEGO TECHNIC set instead. If you're looking for additional sensors and 
motors, by themselves, there are other ways to get these. See Appendix A, Finding Parts and Programming Environments, for 
details. 
 
Other Sets 
 
RIS isn't the only game in town. In 1999, two new MINDSTORMS sets were released: the Droid Developer Kit and the 
Robotics Discovery Set. Both sets are based on the same technology as RIS. They have more limited capabilities than RIS with 
the intent of making them easier to use. 

 
11
What Now? 
 
Now that you have some background in mobile robots and LEGO MINDSTORMS, what should you do? Play. 
Read the manuals, follow the instructions on the MINDSTORMS CD, and have fun with your new toy. When you're thirsty for 
more, come back and read the rest of this book. It will tell you everything you need to know to push your MINDSTORMS set 
as far as it can go. 
 
Online Resources 
 
One of the most exciting things about MINDSTORMS is the online community that supports it. On the one hand, LEGO's 
official MINDSTORMS site provides some interesting information as well as a chance for RIS owners to exchange designs 
and ideas. But in the months since the release of MINDSTORMS, many unofficial sites have appeared. These cover a broad 
range of topics: clever mechanical designs, novel sensors, alternate programming environments, even a new operating system 
for the RCX. I'll list references to online resources at the end of each chapter in this book; my lists are also available online at 
http://www.oreilly.com/catalog/Imstorms/  There's a lot of information out there. 
 
LEGO MINDSTORMS 
 
 
http://www.legomindstorms.com/
This is the official site of MINDSTORMS. It contains handy tips and mildly informative articles. If you own a 
MINDSTORMS RIS set, you can sign up for your own little corner of this web site, where you can post pictures of your 
creations and even the programs that run them. 
 
LEGO Worlds 
 
http://www.lego.com/
Tis is the official site of The LEGO Group. It's a good place to go to browse through different product lines and to get a sense 
of the entire company's product offerings. 
 
Robotics 
 
http://www.lugnet.com/robotics/
LUGNET (the international fan-created LEGO Users Group Network) forms the hub of the online LEGO universe. LUGNET 
hosts many useful discussion groups; a whole hierarchy of them is devoted to robotics. This URL will take you to the top level 
of the LEGO robotics discussion groups, which is further subdivided into more specific interests. LUGNET is an outstanding, 
searchable resource. 
 

 
12
Lego Mindstorms Internals 
 
http://www.crynwr.com/lego-robotics/
This page, maintained by Russell Nelson, contains many fascinating nuggets of information about RIS and the things you can 
do with it. 
 
RCX Internals 
 
http://graphics.stanford.edu/~kekoa/rcx/
This page presents the results of Kekoa Proudfoot's reverse engineering efforts on the RCX, which enabled the development of 
interesting technologies like NQC. pbFORTH, and legOS. For hardcore geeks, this page is fascinating reading. Kekoa is, to 
quote Russell Nelson, a ''minor deity" in the online MINDSTORMS world. 
 
LEGO on my mind: Roboworld 
 
http://homepages.svc.fcj.hvu.nl/brok/legomind/robo/
This comprehensive unofficial site contains a helpful section that introduces MINDSTORMS RIS and its TECHNIC  
doppelgänger, CyberMaster™. 
 
LEGO MINDSTORMS WebRing 
 
http://members.tripod.com/~ssncommunity/webrings/legoms_index.html
A web ring is a set of sites that are all linked to each other. You can traverse forward or backward through the entire ring if you 
wish, or visit sites in a random order. Browsing the MINDSTORMS web ring is a good way to acquaint yourself with the 
MINDSTORMS online community. 
 
LEGO MindStorms Gallery 
 
http://member.nifty.ne.jp/mindstorms/
This Japanese web site, maintained by someone named Joe, includes photographs and descriptions of many, many different 
robots, including several flavors of walkers. The text is mostly in Japanese, but the pictures are fascinating, even if you can't 
read the text. 
 
Ben's Lego Creations 
 
http://www.pobox.com/~benw/lego/
Ben Williamson is a very gifted mechanical designer. This visually clean web site details Ben's creations, including a working 
plotter, a treaded robot with a grabber arm, an intelligent truck, and other pearls. 
 
Lego 
 
http://www.mop.no~simen/lego.htm
Simen Svale Skogsrud maintains this fascinating site. It contains, among other interesting things, a detailed description of a 
MINDSTORMS-based optical scanner. 

 
13
Lego 
 
http://www.fischer-mellbin.com/Marcus/Lego/lego.html
This web site belongs to Marcus Fischer-Mellbin, a ten-year-old with a penchant for natural disasters. Along with other 
models, you'll find photographs and descriptions of a MINDSTORMSbased Tsunami and tornado. 
 
The Epistemology and Learning Group 
 
http://el.www.media.mit.edu/groups/el
The Epistemology and Learning Group (E&L group) at MIT's prestigious Media Lab basically developed the RCX that is the 
centerpiece of MINDSTORMS. This web site provides an overview of the E&L group and describes its aspirations and current 
projects. 
 
The MIT Programmable Brick 
 
http://el.www.media.mit.edu/groups/el/projects/programmable-brick/
The MIT Programmable Brick is the forerunner of the RCX. Looking through this site is like leafing through the RCX's family 
photograph album. 
 
Crickets: Tiny Computers for Big Ideas 
 
http://fredm.www.media.mit.edu/people/fredm/projects/cricket/
If MINDSTORMS robots aren't small enough for you, take a look at Crickets, another project from the fine people at MIT. 
Hardly larger than a nine-volt battery, Crickets are a very tiny mobile robot platform. Crickets are not publically available, but 
this site can give you the inspiration to build your own tiny robots. 
 
What's New at Eureka 
 
http://www.eureka.com/whatsnew/robotvac.htm
I'm not the only one who doesn't want to vacuum the floor. This page at Eureka describes the Eureka Robot Vac, a kind of 
concept car in the world of vacuum cleaners. Supposedly it will navigate through a room, around obstacles and over electrical 
cords, vacuuming as it goes. My favorite part: "Switch on the robot vac and you'll hear a robotic tone" What's a robotic tone? 

 
14
2 
Hank, the Bumper Tank 
 
 
In this chapter: 
 
• About the Building  
Instructions 
 
• Building Instructions 
 
• A Simple Program 
 
• Wheels 
 
• Bumpers and Feelers 
 
• Gears 
 
• Multitasking 
 
• Online Resources 
 
 
Hank is the first robot we'll be building. He is a friendly robot who explores the floor of a room. Whenever he bumps into an 
obstacle, like a chair leg or a shoe, he backs up, turns away from the obstacle, and goes forward again. This chapter includes 
complete building and programming instructions so that you can build Hank yourself. Hank is a fairly simple robot that will 
serve as a good jumping-off point to discuss: 
 
• Various means of locomotion 
 
• Bumper design 
 
• The use of gears 
 
• Motors 
 
• Software multitasking 
 
Figure 2-1 shows a picture of the completed robot. I suggest you begin by building and programming Hank. Let him run 
around your floor for a while. Then come back and read the rest of the chapter, where I'll talk about some of Hank's interesting 
features. 
 
About the Building Instructions 
 
The building instructions for the robots in this book are comprised of pictures, with a little bit of explanation here and there. 
Each step shows you the parts you need as well as how they fit together. There are, however, some names with which you 
should be familiar, so that I don't end up describing everything as a ''doo-hickey" or a "little gray thingy." The parts you need 
to know are beams, plates, shafts, gears, bushings, and wire bricks. 
 

 
15
 
 
Figure 2-1. 
Hank, a friendly robot 
Beams, plates, and shafts are characterized by their leng
s, at least, this corresponds to how many studs (bumps) 
are on the beam. Figure 2-2 shows a p
 their corresponding lengths. The "u" 
stands for "units." 
 
th. For beam
hotograph of some beams, plates, and shafts with
 
 
 
Figure 2-2. 
Some beams, plates, and shafts and their lengths 
 
Gears, for the most part, are described by the number of teeth they have. A 24t gear, for example, has 24 teeth. (The "t" stands 
for "teeth.") Figure 2-3 shows a photograph of the various types of gears that come with the RIS kit. 
 
There are two types of bushings in the RIS kit: regular and half-size. Both fit on shafts and are used for securing a shaft in 
place or for spacing. Figure 2-4 shows the bushings. 

 
16
 
 
Figure 2-3. 
Gears 
 
 
 
Figure 2-4. 
Full and half-size bushings 
 
Finally, the term wire brick refers to the part shown in Figure 2-5. This piece is used to make an electrical connection between 
a sensor or motor and the RCX. 
 
 
 
Figure 2-5. 
A wire brick 
 
 

 
17
Building Instructions∗ 
 
 
 
Create Hank's main chassis as shown in the next two steps; this will hold the RCX, the motors, and the bumpers. 
Attach the shafts as shown. Hank's treads will be mounted on these shafts. The front pair do not rotate, while the rear pair  
should. Don't push the front pair all the way in; you'll need to fit the tread wheel and another bushing on the end. 
 
∗ The parts included with RIS 1.5 are slightly different than those in RIS 1.0. If you're building Hank using RIS 1.5, you 
should use two bushings instead of the green pieces in Step 2. 

 
18
 
 
The back tread wheels are anchored to the shafts with the 16t gears. 
 
 

 
19
 

 
20
Next, start building support for the drive motors. 
 
  
 

 
21
 
 
Place the wire bricks on the motors, then anchor them down with the yellow plates.  
The wires themselves will fit into the grooves on the top of the motors. 
 
 

 
22
Attach the motor wires to output A and output C. 
 
 
 
ext, build the platform for the front bumpers. 
N
 
 
 
 
 
 

 
23
 
 
The touch sensors are attached only by the shaft that runs through them. 
 

 
24
Hank's left bumper is next. A light touch on the bumper pushes the touch sensor. 
 
 
 
Hank's right bumper works exactly the same way. 
 
 
 
The bushings are pushed onto the plate in the next step. Note that the bushings are not  
symmetrical; one side will push into the plate, and the other side won't. 

 
25
 
 
Finish Hank by attaching the bumper touch sensors to input 1 and input 3. Slide the blue  
rubber bands onto the bumpers and anchor them to the bushings from the last step.  
he rubb
T
er bands keep the bumpers from swinging forward. 
 
 
 
A Simple Program 
 
Now that you've built a robot, you need a program to make it work. Hank's mission in life is to explore the world. 

 
26
His basic program works something like this: 
 
go forward 
if I've bumped into something 
back up 
turn away from the obstacle 
his program translates pretty simply into the RIS programming environment, as shown in Figure 2-6. The program assumes 
otors are attached to outputs A and C, while the touch sensors should be attached to inputs 1 and 3. 
start over 
 
T
that the two m
 
 
 
Figure 2-6. 
Hank's program 
 
To create this program, enter the RIS software. Choose Program RCX from the main menu, then RCX Code. Use the menus 
on the left side of the screen to click and drag out different program ''blocks." If you're not familiar with this process, you 
should probably go back and take a look at LEGO's official documentation, either the printed material or the computer-based 
tutorial. 
 
Once you have created the program, download it and run it. (You can download or save a program by right-clicking on the 
main program block.) If everything goes right. Hank should amble around on your floor, trying to avoid things he bumps into. 
If you have pets, this would be a good time to introduce them to your new toy. 

 
27
Hank is a pretty simple robot, but you still may run into trouble: 
 
• If your robot spins in place or goes backward instead of forward, you may need to adjust the wires that connect the motors to 
the outputs. Remove one of the wires and turn it 180° around. This will reverse the direction of the attached motor. If the robot 
is moving backward instead of forward, turn both wires around. 
 
• Hank may not run well on very thick carpet, because there's not much space between the bottom of the body and the floor. 
Once you've got things running smoothly, read on. I'll describe Hank's most interesting features in the rest of this chapter. 
 
Locomotion 
 
Hank gets around in the world on a pair of treads, like a tank or a bulldozer. This is just one approach to the general problem of 
locomotion. Different designs have different merits - you should choose a locomotion method based on what kind of terrain 
you're expecting your robot to encounter. 
reads 
 
Hank's treads have some interesting properties. Fo
o turning radius, which is a fancy way of saying 
ifferential Drive 
Treads are a special kind of differential drive, in whic
 each driven by a motor. The wheels are mounted on 
either side of the robot, like the treads. Figure 2-7 shows
ch a robot. 
 
Independent drive wheels behave a lot like treads. If you run them both forward at the same speed, the robot moves forward. 
Run the drive wheels in opposite directions, and the robot will spin in place. This design also exhibits zero turning radius, but 
without the slipping of the treads. 
 
T
remost among these is zer
that a treaded robot can turn around in one place. (I'll explain why it's a radius a little later.) Each tread is driven by one of the 
motors, so all you need to do to turn is move the treads in opposite directions at the same speed. This turning, however, is 
accomplished with a good deal of friction. Both treads slip on the driving surface. Tanks in Veteran's Day parades can really 
hew up roads this way. 
c
 
The large surface of the treads is one of their other assets. Treads are good for driving on jagged or slippery terrain. Hank 
ould do pretty well driving over uneven obstacles, like a small pile of LEGO bricks. 
sh
 
D
 
h two wheels are
 a top view of su

 
28
 
 
In
s 
he idler wheels don't drive or steer the robot. They exist to keep the robot from tipping over. They can turn freely to point in 
whatever direction the rest of the robot is moving. Figure 2-8 sho s a typical idler wheel. 
 
Figure 2-7. 
dependent drive wheel
 
Zero turning radius is nice in robots that measure how far each wheel travels. (You could do this using rotation sensors.) Once 
you know how far each wheel on a differential drive robot has traveled, you can calculate with a fair degree of accuracy the 
location of the robot relative to its starting point. 
 
T
w
 
 
Figure 2-8. 
An idler wheel 

 
29
Cars 
 
Modern automobiles demonstrate another popular approach to locomotion. Cars have four wheels, two in front and two in 
 
ows how this looks. 
back. The back wheels drive the robot (or car) forward and reverse, while the front wheels are used for steering. Figure 2-9
sh
 
 
 
Figure 2-9. 
Car-style locomotion 
 
Rear-wheel drive is simpler because it decouples the drive mechanism from the steering mechanism. But you could obviously 
build front-wheel drive robots, with enough parts. Whichever
stem you choose, this design does not have a zero turning 
radius. (You can't spin in place in your car.) The term tu
 what happens when a car-style robot drives 
in circles, as shown in Figure 2-10. 
 
 sy
rning radius comes from
 
 
Figure 2-10. 
Turning radius of a car 
 
This type of design can be difficult to maneuver, as you'll know if you've ever tried to parallel park a car. The other subtlety of 
this design involves the back drive wheels. When the car turns, the back wheels must turn at different speeds. Consider Figure 
2-10 again—the inside back wheel has a smaller distance to go than the outside wheel. 

 
30
This means that you can't simply connect the two drive wheels with a shaft and hook it up to a motor. You need something 
trickier, called a differential (not the same as differential drive). 
 
A simple variation on the car design is the tricycle design. In this design, a single wheel, instead of a pair, is used for steering. 
here are three other interesting drives that should be mentioned. The first of these is synchro drive. In this scheme, the robot 
tical wheels. Each of the wheels pivots on its vertical center. All of the wheels point in the same 
irection. as shown in Figure 2-11. 
 
Exotic Drives 
 
T
has three or more iden
d
 
 
 
Figure 2-11. 
 
o turn, the robot swivels the wheels to point in a new direction. This has the interesting side effect that the robot can change 
n even though its body stays oriented the same. This property could be useful for robots that need to communicate with 
e computer over the IR link. The key to building synchro drive robots is a piece called a large turntable. You can order these 
s another interesting idea. Figure 2-12 shows a side view of a tri-star robot and a close-up of the wheel 
sembly. 
Synchro drive 
 
T
directio
th
pieces from Pitsco® LEGO DACTA®; see Appendix A, Finding Parts and Programming Environments, for details. 
 
The tri-star wheel i
as
 
 
 
Figure 2-12. 
Side view of the tri-star design 

 
31
Each wheel assembly is actually composed of three wheels arranged in a triangular fashion. The robot drives these wheels to 
move. When a large obstacle (like a step) is encountered, the entire wheel assembly rolls on its center axis. In essence, the 
tire wheel assembly acts like a large triangular wheel. This large wheel size enables the tri-star design to drive over large 
obstacles. 
 
Killough's platform is an interesting variation on the wheels-within-a-wheel concept. It's really too exotic to describe here; the 
"Online Resources" lists two web pages that contain photographs and diagrams of this platform. 
 
Bumpers and Feelers 
 
Hank uses the touch sensors to figure out when he bumps into something. But it's not really enough to put a touch sensor just 
on the front of your robot, because then it could be activated only in one specific spot. Instead, Hank uses a pair of bumpers to 
detect touches across the entire front of the robot. 
 
The idea of a bumper is to make a large area sensitive to touch so that the robot can detect collisions with a wide variety of 
objects - chair legs, walls, pets, rocks, trees, and so forth. 
 
Hank uses bumpers that rest lightly against the touch sen
bumper is pressed anywhere along its length, the touch 
sensor is then also pressed. A slightly different 
hat is held tightly against the sensor. When the 
bumper collides with something, the sensor actually turns off instead of on. 
he trick with bumpers is to make them sensitive but not too sensitive. The bumper needs to trigger the touch sensor when the 
mechanica devices that can be used to trade speed for power or to translate motion from one axis to another. 
 gear, in essence, is a disk with teeth on its edge. It has a space in its center where you can put a shaft. Gears have three 
. You can trade speed for power by using a small gear to drive a larger gear. The shaft on the larger gear will turn more 
. The opposite effect—trading power for speed—occurs if you use a large gear to drive a smaller gear. The shaft on the 
er gear, but with less power. 
en
sors. When the 
approach is to make a bumper t
 
T
robot bumps into something. On the other hand, it should not trigger the touch sensor when the robot starts or stops moving 
abruptly or when it's driving over a bumpy surface. 
 
Gears 
 
Gears are clever 
l 
A
primary purposes: 
 
1
slowly but more powerfully than the shaft on the smaller gear. 
 
2
smaller gear will turn faster than the one on the larg

 
32
3. You can use gears to transfer motion from one axis to another. The gears in Hank's body transfer motion from the motors to 
the drive axles of the treads, as shown in Figure 2-13. 
 
 
 
Figure 2-13. 
EGO offers an impressive array of gears. The LEGO community has adopted names for these gears, which I will use 
th
ughout this book. Refer back to Figure 2-3; it shows the gears that come with RIS and their names. For the most part, gears 
e named based on the number of teeth they have. The 40t gear, for example, has 40 teeth. The number of teeth is directly 
pecialty Gears 
 
 
You're probably comfortable with the 8t, 16t, 24t, and 40t gears. They can be put together to transfer rotational motion from 
ne axis to another. In particular, these gears are used to transfer motion between parallel axes. 
r axes. Two of these are bevel 
1.
hile the other gears attach firmly to the shaft, the worm gear can slide freely along the shaft. If you want it to stay in one 
lace, you'll need to anchor it down somehow. 
 
2. The worm gear really works only one way: you drive the worm gear, and it drives another gear. There's no way to turn the 
ther gear and have it translate to motion in the worm gear. 
Using gears to transfer motion 
 
The Palette of LEGO Gears 
 
L
ro
ar
proportional to the gear's radius, so the 24t gear has a radius exactly three times as large as the 8t gear. 
 
S
o
 
The gears in the bottom row of Figure 2-3 can be used to transfer motion between perpendicula
and crown gears. 
 
The worm gear is a real character, for two reasons: 
 
 W
p
o

 
33
 
 
 
 
 
 
 
 
 
 
Do the Math 
 
ere's the equation for torque, which is a measure of the power in a turning shaft: 
The mathematics of gears can be described in a high school physics class. The two  
important equations have to do with torque and angular velocity. 
 
H
 
Fr
=
τ
 
 
In this case, τ is torque, F is force, and r is the distance from the center of the rotation  
to the point where the force is applied. For a gear, this is the distance from the center  
(where the shaft ru
Suppose, then, th
ns through) to the teeth. This is the same as the radius of the gear.  
at you have an 8t gear driving a 24t gear. 
 
The equation for the torque of the 8t gear's shaft is this: 
 
Fr
=
8
τ
 
 
The radius of the 24t gear is exactly three times the radius of the 8t gear. The force is the  
me where the teeth of the two gears meet. Therefore, the torque on the shaft on the 24t  
three times the torque on the 8t gear's shaft: 
sa
gear is exactly 
 
8
24
3
3
τ
τ
=
= Fr
 
 
Angular velocity is the measure of how fast a shaft rotates. The angular velocity of a shaft  
can be expressed in terms of the velocity of a point on the 
 
gear as follows: 
r
v
=
ω
 
 
Here, ω is the angular velocity, v is the velocity of the point on the gear, and r is the distance  
between the point and the center of the gear. For the example I just described (an 8t gear driving 
a 24t gear), the angular velocity of the 24t gear is exactly one third of the angular velocity of  
the 8t gear. You can figure this out because the velocities of the gear teeth must be the same: 
 
r
v
=
8
ω
 
 
3
3
8
24
ω
ω
=
= r
v
 
 
In general, then, it's easy to figure out the ratios of torque and angular velocity for two mating gears,  
just by figuring out the ratios of gear teeth. If you use an 8t gear to drive a 40t gear, you'll end up with  
fives times the torque and one fifth the angular velocity. 

 
34
Of Geared and Ungeared Motors 
ost electric motors turn too fast and with too little power to be 
seful. Gears are usually used to swap speed for power until a good balance is achieved. This process is called gearing down or 
actually contains an electric motor and 
d with a reasonable amount of power. 
s of the RCX: 
andard motor 
 motor, which means its output 
rk with it, you'll probably have to 
icro motor 
. They are internally geared so that the output shaft has enough 
ower to drive your robot around. They are more efficient than the standard motor. The geared motor is shown in Figure 2-14. 
 
There's one more topic related to gears that's important. M
u
gear reduction. 
 
The motors that come with RIS are internally geared, which means that the motor case 
some number of gears. The output shaft is already adjusted to turn at a reasonable spee
This means you can attach wheels directly to these motors to drive your robot around. 
 
The LEGO group makes four different kinds of motors that can be driven from the output
 
st
This has been the standard motor of the LEGO TECHNIC line for many years. It is an ungeared
shaft rotates very rapidly, with little power, when electricity is applied. To do any useful wo
use gears to reduce its output speed. 
 
m
This is a tiny motor with low speed and low power. You probably can't use this motor to move your robot, but it could be 
useful for lighter tasks. It's harder to find than the other motors. 
 
geared motor 
Two of these motors come with the MINDSTORMS RIS kit
p
 
 
 
Figure 2-14. 
otor 
The geared m

 
35
train motor 
LEGO sells an entire line of train sets. The train motor can be controlled by your RCX; as a matter of fact, you can make an 
s to each other. When you turn the shaft of one motor, 
he other motor's shaft will turn simultaneously. What's going on here? Just as you can  
ans very little energy is lost in converting mechanical energy to  
ectrical energy and vice versa. 
 strong enough for most tasks. 
How can you get more motors? RIS comes with two motors, but there are three outputs on the RCX. You can get another 
motor in the RoboSports expansion set, but it'll cost you $50. 
 
You can order extra motors from the LEGO Shop-at-Home service, one of The LEGO Group's best-kept secrets. This service 
is available in the United States at (800) 835-4386. They have a variety of sets and spare parts—the item numbers for the 
motors are as follows: 
 
• Standard motor, item 5114 
 
• Micro motor, item 5119 
 
• Geared motor, item 5225 
 
• Train motor, item 5300 
 
You can also order the first three motors from Pitsco LEGO DACTA: (800) 362-4308. 
 
For more information on extra parts and ordering, see Appendix A. 
"intelligent" train by mounting the RCX in one of the cars. 
 
 
 
 
 
 
 
 
 
 
 
For a Rainy Day 
 
To see exactly how efficient the geared motors are, try this experiment. Use one of the  
"wire bricks" to attach two motor
 t
supply power to make the motor turn, turning the motor with your hand generates power.  
This power is transferred to the other motor, where it's converted back to the movement  
of the shaft. 
 
Of course, you haven't actually built anything useful. But it's a good demonstration of the  
efficiency of these motors. The shaft on the second motor turns at nearly the same speed as  
the first motor, which me
el
 
If you have a choice of motors, you'll probably always use a geared motor. It is more efficient, more convenient, and less bulky 
than the standard motor. The micro motor is hard to find and not
 

 
36
Multitasking 
 
Don't be fooled by the simplicity of the RIS programming environment—it hides some pretty messy details. Hank's simple 
program demonstrates a powerful feature of the RCX software: multitasking. This is a term from the computer world—it just 
means that the RCX can do more than one thing at a time. Each of the two instruction sequences hanging off the touch sensor 
watchers is a separate task, and they can actually execute at the same time. To see this in action, touch one of Hank's bumpers 
 Tasks 
d subroutines are declared explicitly in NQC, one of the alternate programming environments for the RCX. See Chapter 4, 
e multitasking nature of the RCX can get you into trouble. The figure shows an alternate program for 
ank. At first glance, it makes sense. The main program starts Hank moving forward. When one of the bumpers is touched, the 
to trigger the first task, then touch the other bumper shortly afterward. (To really see this effect, you could try putting in longer 
delay times in Hank's program.) 
 
The sensor watchers in RCX Code exhibit another interesting property. If you trigger a sensor watcher, the code for that  
watcher begins executing. If you trigger the same sensor watcher again, while the watcher code is still executing, the watcher 
code starts over again from the beginning. 
 
The relationship between the programs you create in RCX Code and the tasks that run on the RCX is not always clear.
an
Not Quite C, for details. 
 
Figure 2-15 shows how th
H
robot backs up, waits, turns, waits, and starts going forward. 
 
 
 
Figure 2-15. 
A slightly dangerous program 

 
37
A serious problem occurs if the same bumper is quickly hit twice. Suppose the bumper on input 1 is hit once. It begins 
xecuting its sensor watcher code by reversing the direction of the motors. 
en output A reverses direction and the robot spins in place. Suppose, now, that 
er routine will begin 
ain, reversing the direction of both the motors. Hank, therefore, will begin spinning the other direction instead of moving 
hen output A's direction reverses, and the robot moves forward. Finally, output C's direction reverses, and the robot spins in 
here are two solutions to this problem. First, you can be more explicit about controlling outputs. Instead of just reversing the 
 sensor watcher routines, you could specifically set the directions and turn on the motors. This technique 
 shown in Hank's first program, in Figure 2-6. It doesn't matter if the sensor watchers are interrupted before they finish, 
rs are always set explicitly. The other solution is to structure your program differently. If 
he Art of LEGO Design 
p://cherupakha.media.mit.edu/pub/people/fredm/artoflego.pd
e
The robot travels backwards for half a second, th
the bumper on input 1 is triggered again, before output C's direction is reversed again. The sensor watch
ag
backwards. 
T
place again, instead of moving forward. 
 
T
output directions in the
is
because the directions of the moto
your sensor watchers don't have any delays built into them, for example, they will be much less likely to be interrupted. 
 
Online Resources 
 
T
 
ft
This is an outstanding paper about building with LEGO parts. It includes helpful tips on making strong structures and using 
 recommend this paper, especially if you are having trouble getting things to fit together. 
me Page 
/6270/
gears. The paper is written by Fred Martin, one of the people at the MIT Media Lab whose programmable brick work formed 
the basis of the RCX. I highly
 
Fred's 6.270 Ho
 
http://lcs.www.media.mit.edu/people/fredm/projects
For a deeper treatment of many aspects of small mobile robotics, read the course guide for MIT's famous 6.270 class. In this 
class, students build robots from the ground up. The 6.270 Robot 
Builder's Guide was written by Fred Martin; it is a real bonanza of information and advice. 
 
Doug's LEGO Technic Tri-Star Wheel ATV and Robotics page 
 
http://www.net-info.com/~dcarlson/
Doug Carlson's fascinating page is full of pictures of his implementations of the tri-star design, synchro drive, and the Killough 
platform. For sheer mechanical finesse, this page is hard to beat. 

 
38
Killough's mobile robot platform 
ttp://carol.wins.uva.nl/~leo/lego/killough.html
 
h
This part of Leo Dorst's acclaimed site gives some background and explanation of the Killough platform. 
ynchronicity 
m/jknudsen/Synchronicity/Synchronicity.html
 
S
 
ttp://members.xoom.co
h
This page has photographs of
 
 my own synchro drive robot, which has three wheels and a compact design. 
itsco LEGO DACTA 
ttp://www.pitsco-legodacta.com/
P
 
h
This is the offi
isted online, bu
cial home page of Pitsco LEGO DACTA. Many of the interesting things that Pitsco LEGO DACTA sells are not 
t you can call and order a catalog. Make sure you get the LEGO DACTA catalog, as Pitsco has an entirely 
ifferent catalog that doesn't have anything to do with LEGO. This is the place to order the Robolab software that allows you 
 a Macintosh. 
tsco 
ttp://www.ee.nmt.edu/~jmathis/dacta.html
l
d
to program your RCX from
 
Dacta Spares from Pi
 
h
This unofficial site contains images of some of the interesting pages in the Pitsco LEGO DACTA catalog, including the pages 
with the motors and sensors. 
 
LEGO Motors 
 
http://www.enteract.com/~dbaum/lego/motors.html
This page contains a concise description of the three kinds of m ors. 
ot

 
39
3 
Trusty, a Line Follower 
In this chapter: 
 
 
Building Instructions 
 
 
Some Tricky Programming 
 
 
The Light Sensor 
 
 
Idler Wheels 
 
 
Using Two Light Sensors 
 
 
Online Resources 
 
 
In this chapter, you'll build Trusty, a simple robot that exhibits a behavior called line following. This means that Trusty, shown 
in Figure 3-1, can drive along a sort of ''track" defined by a thick black line on the floor. Your RIS kit includes a "Test Pad," 
which is simply a large piece of white paper with some black lines and other marks on it. Trusty will follow the large black 
oval on this paper faithfully until he runs out of battery power. 
 
 
 
 
 
Figure 3-1. 
Trusty, a line follower 
 
As you can see in Figure 3-1, Trusty's main feature is a downward pointing light sensor. This sensor is the key to line 
following. The light sensor can distinguish between the white background of the Test Pad and the black line drawn on it. As 

 
40
you'll discover, this feature doesn't make line following easy to program; but it does make it possible. 
 
Building Instructions 
 

 
41
 
 
In Step 4, make sure the top bushing allows the idler wheel to rotate freely by putting the round
side next to the plate. If you put it on the other way, the idler wheel will be locked in place. 
 
  
 
 
Be sure to attach the wire bricks to the motors before putting them on Trusty. 

 
42
 
 
Next, build the support for the light sensor. 
 

 
43
The 2u beams between the motors will hold the ends of the drive shafts.  
Make sure that you can see the holes. 
 

 
44
 
 
Flip the robot over and attach the wires as shown. The motors are attached to output A  
and output C, while the light sensor is attached to input 2. 
 
 
 
Some Tricky Programming 
hapter 1, Robotics and MINDSTORMS.) 
 
The simplest way to describe the program is this: 
 
It's surprisingly hard to convince our robot to follow a black line on the floor. (A lot of things in mobile robotics are  
urprisingly hard, as we discussed in C

 
45
if I'm on the line, go straight forward 
if I'm off the line, find the line and start over 
 
It's the "find the line" part that's difficult. When Trusty's light sensor goes off the black line, Trusty has no way of knowing if 
eft side of the line. Ideally, Trusty would turn back to the line and start going straight again. He would 
roceed in a zigzag fashion along the line. 
 good guess. If he knows he drove off the left 
de of the line last time, it's a pretty good bet he'll drive off the right side the next time. Figure 3-2 shows a likely path as 
he's on the right or the l
p
 
State 
 
Even if Trusty doesn't know which side of the line he's on, he can make a pretty
si
Trusty tries to stay on the line. 
 
 
 
Figure 3-2. 
Trusty zigz
 black line 
With this in mind, Trusty's algorithm can be
 
if I'm on the line, go straight forward 
if I'm off the line { 
turn back the opposite direction from the way I turned last time 
if I still don't find the line, turn farther back the other direction 
} 
 
Another way of looking at this is to say that Trusty now has two possible states: 
 
1. Just turned left (turn right next) 
 
2. Just turned right (turn left next) 
 
By keeping track of this state, Trusty can figure out the best way to turn the next time he drives off the black line. 
 
Could I Please Have a Variable? 
 
Some kind of variable is needed if Trusty is to keep track of his state. Said another way, Trusty needs some kind of memory to 
remember which way he last turned. This highlights one of the weak points of RCX Code (the RIS programming 
environment), its lack of variables. 
ags along the
 
 more specific: 

 
46
The environment does provide a counter, which we'll use in lieu of a variable to hold the turning direction. Although you can't 
assign values directly to the counter, you can do two things: reset it to zero and add one to it. Trusty will use just two values, 0 
d 1, to mean turn left and turn right, respectively. 
cularly if the black line has curves in it. What Trusty needs is some way 
ut if he's turning 
e wrong way, away from the line instead of toward it. For this purpose, we'll use a timer. If Trusty doesn't find the line within 
he Program 
 
Figure 3-3 shows Trusty's basic program. It begins by setting the two motors to the forward direction at speed 4. The central 
decision point is the light sensor watcher. If the sensor sees the black line, Trusty moves straight ahead. If the sensor sees the 
white background, then the program resets the timer and calls a subroutine called toggle. This subroutine turns the robot left 
or right, alternating each time it is called. 
 
an
 
Coping with Failure 
 
Our basic assumption about Trusty is that he will drive off the black line on alternating sides. But this probably won't really 
happen all the time, parti
to figure o
th
a certain time interval, we'll have him switch state and turn back the other way. 
 
The real world is a very challenging place. You should always assume that bad things will happen to your robot and try to 
create a program that responds appropriately. 
 
T
 
 
Figure 3-3. 
A top-level view of Trusty's software 

 
47
Use your own values for the thresholds of the light sensor watcher. The values shown in Figure 3-3 are calibrated to my  
articular light sensor and may not work with yours. 
ay from the line. The timer is used to limit this behavior. If Trusty is turning and the timer goes off, then Trusty 
tomatically turns back the other way. Figure 3-4 shows the timer watcher, which calls the same toggle subroutine if the 
om the line, he can be pretty sure he's missed it after a half second. A line-follower with a different mechanical 
esign might need a different timer value. 
p
 
The timer is used in case Trusty happens to turn the wrong way. Suppose, for example, that he runs off the right side of the 
black line twice in a row. The first time, he would turn left to find the line again. The second time, however, he would turn 
right, aw
au
robot is still off the line. 
 
You might be wondering why the timer counts for one half second. Why not three quarters of a second, or a full second?  
Remember that the timer keeps Trusty from turning around completely. 
The timer value is based on observation—if Trusty is turning toward the line, he will find it within a half second. If he is 
turning away fr
d
 
 
 
Figure 3-4. 
 Trusty's software 
Details of
 
-4 also sh
es is examine the value of the counter. If it's 0, then the rob
Figure 3
ot is 
set to turn left an
t time toggle is called, the robot turns right and the counter 
value is reset to 0. It's useful to have toggle as a subroutine because it is called from two places in Trusty's program. 
ows the toggle subroutine itself. All it do
d the counter value is changed to 1. The nex

 
48
The Light Sensor 
 
Working with the light sensor can be a little tricky. As measured by the RCX, the light sensor outputs a value from 0 (dark) to 
100 (bright). However, the signal generated by the sensor has some noise in it, which means the value jumps around 
unpredictably. To use a light sensor effectively, then, you need
 figure out what the interesting values are and how to respond 
to them. 
 
Testing Light Sensor Values 
 try the green area of the Test Pad, and try all the measurements with the room both dark and light. This should 
 feel for the values that are important. 
e conditions with the same RCX. 
 
The Light Sensor Watcher 
 
What's going on with that sensor watcher in Figure 3-3? It's actually two sensor watchers rolled into one. The following 
pseudocode shows how it works: 
 
if the sensor value is in the range from 0 to 35 (but wasn't previously), 
execute the "dark" commands 
if the sensor value is in the range from 40 to 100 (but wasn't previously), 
execute the "bright" commands 
 to
 
The easiest way to figure out what values your light sensor is generating is to use the RCX's View button. Press View 
repeatedly until a little arrow appears under the input with the sensor. The RCX's screen should show the value of the sensor. 
You can place Trusty so the light sensor is over the line, and then observe the value. Now see what values you get when Trusty 
is off the line. 
 
You should also
ive you a good
g
 
The View button only works if the input is configured to measure a light sensor. To have the input configured correctly, you'll 
either have to run a program that sets it up or use the Test Panel, in the RCX Code section of the RIS software. Click on the 
appropriate input until the light sensor appears. Then click on the Get Sensor Values button to get the current readings. 
 
The choice of 35 and 40 in Trusty's program is based on my measurements; you may want to adjust these values for your 
specific conditions. 
 
Don't expect to get the same readings from two different light sensors, even under the sam
Always test the values before you use them in a program. 

 
49
Figure 3-5 sh
th the times when the dark and bright commands will 
be executed. Nothing happens until the sensor value enters eith
e dark or bright value ranges. 
ows a hypothetical graph of the light sensor value, along wi
er th
 
 
 
 
ns some tasks at the same time. If the dark commands and bright commands both take a while to 
xecute, it's possible they may overlap. If the light sensor reading gets into the bright range and abruptly drops back into the 
o 
ey won't overlap. 
mbient Light 
receives. This includes the reflected light from 
the red light that's part of the sensor as well as room light and sunlight.∗ In a line-following robot like Trusty, you really want 
to measure only the reflected light. In this case, it's in your interests to block out the room lighting, sunlight, light from your 
kid brother's flashlight, and anything else distracting. The light level that's present in a certain place is called the ambient light. 
In a robot like Trusty, you might try surround the light sensor with dark bricks to block out the ambient light. This can improve 
the accuracy of your sensor measurements. In this particular case, I didn't think it was necessary, but you might like to give it a 
whirl. 
 
∗ The light sensor is even sensitive to the infrared light that is produced from the IR port. 
Figure 3-5. 
The sensor watcher 
Remember that the RCX ru
e
dark range, the dark commands will start running while the bright commands are still in progress. You should be aware of this 
possibility and structure your code to deal with it. In Trusty's program, the dark and bright commands both execute quickly s
th
 
A
 
You have to be careful with the light sensor; its value depends on all the light it 

 
50
 
 
Where's That Red Light Coming From, Anyhow? 
 
Isn't it odd that the light sensor, an input device, has a red light on it? How did that happen? 
And how is that possible with only two wires connecting the sensor to the RCX? 
 
The basic role of the RCX's inputs is to measure the value of the sensor. For certain types of  
sensors, like the light sensor, the RCX also provides power to the sensor. It does this by  
very quickly alternating between providing power and taking a measurement. The RCX sends  
power to the light sensor for about 3 ms (thousandths of a second) and takes a measurement  
for about .1 ms. It repeats this cycle over and over. (These timings only apply to the standard  
firmware. In an alternate firmware such as legOS, the timings are entirely different.) Inside the 
light sensor, an electronic circuit smooths out the pulses and provides steady power to the red light. 
 
Idler Wheels 
 
Trusty's two main drive wheels determine whether he moves forward, backward, or turns. But without at least one more wheel, 
Trusty can't balance and will tip forward or backward. Trusty's third wheel is a good example of an idler wheel. An idler wheel 
provides support for the robot but doesn't constrain its motion. It does this by rotating freely on a vertical axis. The front 
heels on shopping carts are idler wheels, as are the casters under furniture. Ideally, an idler wheel can easily swivel in 
onse to changes in the robot's direction. You've alread
y's idler wheel in Figure 2-8. 
 
Make your idler wheels sturdy! One of Trust
just fine. But after about a minute of back-
and-forth turning, the idler wheel broke off the bottom, and Tru
g on his back, twitching. 
 Sensors 
e one that's already there. You can leave the original one attached to 
ows how to do this. 
w
resp
y seen Trust
y's early designs 
uld follow a line 
co
sty was left lyin
 
sing Two Light
U
 
You can buy more light sensors for about $20US each (see the ''Online Resources" section at the end of this chapter). By 
adding one more light sensor to Trusty, we can simplify his program and make his movement along the black line smoother. 
 
Adding the Sensor 
 
To add the second light sensor to Trusty, just move over th
put 2 and just add the second one to input 3. Figure 3-6 sh
in

 
51
 
 
Figure 3-6. 
 
rithm is pretty simple. If both sensors are on the line, we just drive forward. If 
 
This logic can be represented by a simple map from the sensor values to the motor settings, as shown in Table 3-1. 
 
Table 3-1. Mapping from Sensor Inputs to Motor Outputs 
 
Left Light 
Right Light Left Motor(A) Right Motor(C)  
Result 
Sensor (2) 
Sensor (3) 
 
dark   
 
dark 
  
 
forward   
 
forward   
 
 
Go forward 
 
dark   
 
bright   
 
stop   
 
 
forward   
 
 
Turn left 
 
bright   
 
dark   
 
forward   
 
stop   
 
 
 
Turn right 
 
bright   
 
bright   
 
-   
 
 
 
-   
 
 
 
 
No change 
 
It's cumbersome to implement this algorithm in RCX Code. Figure 3-7 shows the program, which is based around two sensor 
watchers. But go ahead and try it out; it works well even if it looks kind of strange. In Chapter 4, I'll show you how this 
algorithm (as well as the single-light-sensor Trusty) can be reprogrammed in NQC. 
 
The program centers around two sensor watchers, one for each light sensor. Whenever either sensor sees light or dark, the 
value of the other is examined. Based on the values of the two sensors, the motors are set according to Table 3-1. 
Adding a second light sensor to Trusty 
 
Programming 
 
With two side-by-side light sensors, Trusty's algo
only one of the sensors is on the line, we simply turn back to the line. If both sensors go off the line, we don't do anything; the 
robot must already be turning and should return to the line soon.  

 
52
 
 
 
Figure 3-7. 
Programming Trusty with two light sensors 
 
 
EGO World Shop 
ttp://www.legoworldshop.com/
Online Resources 
 
L
 
h
The RIS kit itself is available at this online store, although you can probably get it cheaper at a local retailer. However, the 
ttp://www.plazaearth.com/usr/gasperi/lego.htm
online store also carries items you won't find locally, like extra motors, touch sensors, light sensors, and even a remote control 
that sends messages to the RCX's IR port. You can even buy an extra RCX, although it's a much better value to spring for a 
whole RIS kit. 
 
LEGO MINDSTORMS Sensor Input 
 
h
This is the authoritative resource for RCX sensor information. It describes how the sensors work, how you can modify sensors, 
d how you can build your own sensors. It includes schematic diagrams, handy graphs, and photographs. 
an
 
LEGO Light Sensor 
 
http://www.plazaearth.com/usr/gasperi/light.htm
For the real skinny on LEGO's light sensor, check out this page. It includes a photograph of the circuit board inside the sensor, 
 schematic diagram, and graphs of the sensor's response with and without the LED. 
a

 
53
4 
Not Quite C 
 this chapter: 
RCX Software Architecture 
NQC Overview 
d 
nce you've written a few programs in RCX Code, it feels a little constrictive. For one thing, there aren't any variables. It 
g a variable is the counter. Back in Chapter 3, Trusty, a 
ne Follower, I used the counter to remember which way to turn. The counter was always a 0 or a 1, indicating whether the 
bot sh
h going, and if you try anything more complicated, the counter is not going to get 
the job d
 
The lack
ne of the limitations of RCX Code. Two other important limitations are: 
 
• Although you 
ou can't call one subroutine from another. Likewise, a 
subroutine can't c
 
• You can't control the RC
be really nice, for debugging purposes, to be able to show values on 
the display. 
 
The LEGO Group aimed the Robo
eople who had never programmed before. For this group, RCX 
Code is a gentle way to get started
le robots. But RIS is exceedingly popular with programmers and 
other technically savvy people, wh
tations of RCX Code. If you're reading this chapter, this probably 
includes you. 
 
Since RIS was released 
MS community has produced an amazing stream of clever, 
innovative software designed to ov
ode. Most of this software is available, free of charge, on 
the Internet. In this chapter, I'll de
ackages: Not Quite C (NQC). NQC allows you to write 
programs for your RCX with a text
be the syntax and commands of this language, with copious 
 
 
In
 
 
• A Quick Start 
 
 
• 
 
 
• 
 
 
• Trusty Revisite
 
 
• Online Resources 
 
 
O
would be nice if your robot could remember things, like how many obstacles it's encountered or what the temperature was 
three minutes ago. In RCX Code, the only thing remotely resemblin
Li
ro
ould turn left or right. But it's toug
one. 
 of variables is only o
can define subroutines (called "My Commands"), y
all itself. 
X's display very well. It would 
tics Invention System at p
 with programming mobi
o are frustrated by the limi
in the Fall of 1998, the MINDSTOR
ercome the limitations of RCX C
scribe one of the most popular p
-based language. I'll descri

 
54
examples. If you've programmed in C, NQC will look familiar. If you have never programmed in C, don't worry; NQC is easy 
 learn. 
is 
 four steps: 
. To g
u started with NQC, this chapter begins with a simple example. 
 NQC works, you need
erstand the software that's running on the RCX. This chapter describes the 
portan
es of the RCX's software architecture. 
3. T
commands, with examples. 
 F
his chapter contains software for Trusty written in NQC. 
d Windows. Navigate to the NQC web site (http://www.enteract.com/~dbaum/lego/nqc/
to
 
Th
 
chapter presents NQC in
1
et yo
 
2. To understand how
 to und
t piec
im
 
his chapter provides a detailed listing of NQC's 
 
4.
inally, t
 
A Quick Start 
 
Let's get right to the good stuff with a working example. First, you'll need to download and install NQC. It's available for 
MacOS, Linux, an
 ), and follow the 
structions to download and install the latest version. The examples in this book were written with the NQC version 2.0b1. 
nce it's installed, enter the following program using a text editor. This program operates Hank, the robot from Chapter 2, 
#define BACK_TIME 50 
#define TURN_TIME 80 
 
task main() { 
SetSensor(SENSOR_1, SENSOR_TOUCH); 
SetSensor(SENSOR_3, SENSOR_TOUCH); 
OnFwd(OUT_A + OUT_C); 
while (true) { 
if (SENSOR_1 == 1) { 
PlayTone(440, 50); 
OnRev(OUT_A + OUT_C); 
Wait(BACK_TIME); 
OnFwd(OUT_A); 
Wait(TURN_TIME); 
OnFwd(OUT_C); 
} 
if (SENSOR_3 == 1) { 
PlayTone(880, 50); 
OnRev(OUT_A + OUT_C); 
Wait(BACK_TIME); 
OnFwd(OUT_C); 
Wait(TURN_
OnFwd(OUT_A); 
} 
} 
} 
in
 
O
Hank, the Bumper Tank. Save the program in a file called Hank.nqc. 
 
TIME); 

 
55
Now compile the source code using the nqc command: 
 
C:\>nqc Hank.nqc 
 
C:\> 
c -d Hank.nqc 
Downloading Program:…..complete 
 
 
If you made a mistake typing in the program, nqc gives you a list of errors. Otherwise, you're ready to download the program 
with the -d option: 
 
c:\>nq
 
c:\> 
 
(If you need to specify a serial port different from the default, use the -S option.) 
 
Go ahead and run the program. When you're done playing, come back and get some background on the software that runs the 
RCX. 
 
RCX Software Architecture
 
Writing a program for the RCX involves a handful of software layers, both on the development PC and on the RCX itself. 
Figure 4-1 shows an overview of the important pieces. 
 
 
Figure 4-1. 
RCX software architecture 
 
 
ROM 
 
The RCX is a small computer that is based on a Hitachi H8/3292 microcontroller. The RCX contains two kinds of memory: 
Read Only Memory (ROM) and Random 

 
56
Access Memory (RAM). As its
t be written. It is programmed at the factory and cannot be changed. 
AM, on the other hand, can be written and read as many times as you want, with one catch: it needs power. If you take the 
s, however, the batteries preserve 
routines know a little bit about 
antly, the ROM routines know how 
nd place it in RAM. 
are is, essentially, an operating 
 the IR port and store it in RAM. 
 processing the ROM routines. It shows a clock on the display of the RCX. It can 
cognize an respond to the View button. Most importantly, it can receive robot programs over the IR port and run them. 
the same kind of animal, this is not the case. The 
rmware is actual Hitachi H8 machine code. Together with the H8 machine code in ROM, the firmware defines an operating 
y for programs to be downloaded, 
l called bytecode. Whereas the H8 
re very rudimentary, such as "move this value to register 1," bytecode instructions are more powerful, 
ch as "turn output 2 on with full power." The firmware interprets the bytecode and performs the appropriate action. 
n the PC side, a piece of software called Spirit.ocx handles interaction with the RCX via the IR link. Spirit.ocx can execute 
, download new programs to the RCX, download firmware to the RCX, and receive data from 
e RCX. 
he RCX Code programming environment sits on top of Spirit.ocx. It provides the click-and-drag programming environment 
load 
e programs to the RCX. 
, which means its functions are accessible from programming languages like Visual 
asic and Visual C++. 
 name implies, ROM canno
R
batteries out of your RCX, the contents of the RAM are erased. Under normal circumstance
the contents of the RAM. 
 
When you first get your RCX, it has some stuff in ROM and an empty RAM. The RCX's ROM 
the RCX's hardware. These routines can run the motors or access the sensors. Most import
to receive code from the IR port a
 
Firmware 
 
One of the first things you have to do with your RCX is download the firmware. The firmw
system for your RCX. The routines in ROM know how to download a set of firmware from
The firmware is capable of more than just
re
 
Although at first it sounds like the firmware and the robot programs are 
fi
system for the RCX. It provides access to the RCX's inputs and outputs. It also provides a wa
stored, started, and stopped. 
 
The actual robot programs are not H8 machine code. They are defined at a higher leve
machine instructions a
su
 
About Spirit.ocx 
 
O
bytecode commands on the RCX
th
 
T
that you're already familiar with. RCX Code converts these graphic programs into bytecode and uses Spirit.ocx to down
th
 
Spirit.ocx is a regular ActiveX control
B

 
57
Spruce Up That Resume 
g means that you are  
ntain embedded systems. Modern cars contain dozens of  
mbedded systems, as well. 
ompiler running on a PC. You would write source code (probably in C or assembly language)  
ce the machine code on  
me sort of programmable memory chip. 
he RIS software simplifies this process in two important ways. First, it provides a graphic  
oss-compilation step is a little different, too, because RCX programs are bytecode  
ther than machine code. But it's still cross-compilation: the end result is bytecode rather  
e Life of a Program 
rogra
ecode. 
3. The program is now available in RAM. When you run it, the firmware interprets the bytecode in your program and performs 
the appropriate tasks. 
 
Writing programs for the RCX is an example of cross-compiling for an embedded system, a  
phrase that is bound to sound good on your resume. Cross-compilin
writing programs on one computer (your PC) that will run on another computer (the RCX).  
An embedded system is a computer that is part of some other device. For example, microwave  
ovens and mobile phones both co
e
 
The usual way to develop software for a chip like the Hitachi H8 would be to use a cross  
c
on your PC and use the cross-compiler to create H8 machine code from the source. Then you  
would probably use a special PC peripheral, called a burner, to pla
so
 
The final step would be to physically place the memory chip in the embedded system. 
When the embedded system boots up, the software you just wrote will run. 
 
T
programming environment that's very accessible, particularly for people who haven't  
programmed before. Second, programs are downloaded to the RCX over the IR link and  
stored in RAM. This feature eliminates the complexity of dealing with memory chips and 
burners yourself. 
 
The cr
ra
than H8 machine code. 
 
A Day in th
 
Let's examine the typical life of a robot program: 
 
1. The program's life begins when you create something in RCX Code. RCX Code compiles your p
m to byt
 
2. RCX Code uses Spirit.ocx to download the program to one of the RCX's five program slots. The compiled bytecode is 
transferred to the RCX via the IR link. 
 

 
58
NQC Overview 
 
Where does NQC fit in? NQC is a replacement for the software on the PC, both RCX Code and Spirit.ocx. NQC source code is 
stored in simple text files, just like C, C++, or Java source code. 
QC compiles these source files to bytecode and can download them to the RCX using the IR tower. NQC is a good way to 
ations of RCX Code. But because it produces bytecode programs, it's still subject to the limitations of the 
able. NQC runs on MacOS (using 
PW), Linux, and of course Windows 95, 98, and NT. RCX Code, by contrast, only runs on Windows.∗ 
N
overcome the limit
firmware's bytecode interpreter. 
 
Because NQC talks to the IR tower directly, without depending on Spirit.ocx, it is very port
M
 
NQC was developed by Dave Baum, who maintains the official web site at http://www.enteract.com/~dbaum/lego/nqc/. 
 His web site also includes pithy documentation for the language. 
 on Windows, you might want to also use RCX Command Center (RcxCC). RcxCC is a Windows 
 Although NQC is fairly easy to use all by itself, RcxCC gives 
hapter for a URL and more information. 
the important commands of NQC. If you have a background in C programming, the syntax and control 
 worry: NQC is easy to learn. I've included lots of 
ustively; several excellent web pages detail the 
 the "Online Resources" section at the end of this chapter for details. 
ply some set of instructions that execute in order. A task is 
e program may consist of several tasks that execute at the 
 is the only 
ne
utomatically run by the RCX. I'll 
 abo
i
ow you can run NQC 
 
If you're using NQC
application that wraps around NQC. It provides a syntax-colored program editor, push-button compilation and downloading, 
real-time control of the RCX, and a host of other useful features.
you an even smoother ride. See the "Online Resources" at the end of this c
 
This chapter covers 
structures will look familiar. If you don't have a background in C, don't
xample programs to demonstrate how things work. I won't cover NQC exha
e
entire language. See
 
ain 
m
 
NQC programs are organized into one or more tasks. A task is sim
 singl
analogous to a thread in other programming environments. A
me time. 
sa
 
Tasks have names. Every program should have a special tasks called main. When the Run button is pressed, the RCX begins 
the program by running main. If you define other tasks, you have to explicitly start and stop them. The main task
 that is a
explain more
ut starting and stopp ng tasks later. 
o
 
∗ As this book goes to press, a standalone MacOS version of NQC is being released in beta test form. N
on MacOs without MPW. 

 
59
Output Commands 
 
several comm
NQC includes 
ands for controlling the outputs of the RCX. You've already seen one of these, OnFwd, in our first 
y adding them together, as shown in the first example. When an output is 
rned on, its current power and direction are consulted to determine what actually happens. 
is co
e specified outputs, putting them in brake mode. For motors, this means that the motor shaft will be 
hard
 
Float(con
Float()
t to the output, but the shaft of an attached motor will turn freely. 
This is a u
 a stop. 
You can s
e following three commands: 
 
Fwd(
Use t
command to set the direction of the specified outputs to forward. 
d sets the direction of the specified outputs to reverse. 
o fully determine an output's actions, y
, direction
plicitly. By default, all three outputs are 
 "combination" commands: 
ts) 
his command turns on the specified outputs in the forward direction. 
This command turns on the specified outputs in the reverse direction. 
simple example. 
 
On(const outputs) 
This command turns on the specified outputs. The outputs should be some combination of the constant values OUT_A, OUT_B, 
and OUT_C. Multiple outputs can be specified b
tu
 
Off(const outputs) 
Th
mmand turns off th
 to turn. 
st outputs) 
is really a variation of 
 
Off(). No power is sen
seful option if you want your robot to coast to
et the direction of outputs with th
const
s 
 outputs) 
hi
 
Rev(const outputs) 
This comman
 
Toggle(const outputs) 
To switch the direction of one or more outputs, use this command. 
To determine the output power, use the following command: 
 
SetPower(const outputs, expression speed) 
This command sets the power of the given outputs. Any expression that evaluates to a value from one to seven can be used as 
the speed. You may use the constant values OUT_LOW (1),  OUT_HALF (4), and OUT_FULL (7) if you desire. 
 
T
ou should set its mode
, and power ex
set to full power and the forward direction. Therefore, calling On()is enough to get the motors running. 
 
NQC provides two handy
 
OnFwd(const outpu
T
 
OnRev(const outputs) 

 
60
These commands set the mode and direction of the outputs in one fell swoop, but you should still set the power level explicitly 
 time) 
his command turns on the specified outputs for the given time, measured in hundredths of a second. Then the given outputs 
A an C
n re
rses outputs A and C. After another second, 
 + OUT_C, 100); 
o
Rev
d
r
ly shorthand for these lower-level output 
onst outputs, const mode) 
 for the given outputs. The outputs are specified in the same way as in the Fwd() and Rev() 
his command determines the direction of the supplied outputs. The direction parameter should be OUT_FWD, 
, or OUT_TOGGLE. OUT_TOGGLE is a special value that sets the direction of the output to the opposite of its 
current value. 
 
In gener
end you don't call SetDirection() with the OUT_TOGGLE value. If you explicitly set the directions 
f your outputs, your program will be clearer. Furthermore, in programs with more than one task, your program is more likely 
 behave as you expect. 
 provides a command that does just this: 
with a call to SetPower(). 
 
For timed actions, the following command will come in handy: 
 
OnFor(const outputs, expression
T
are turned off (in brake mode, not in float mode). 
 
The following example runs outputs 
d  forward, waits one second, the  ve
e outputs are turned off. 
th
 
task main() { 
SetPower(OUT_A + OUT_C, OUT_HALF); 
 
Fwd(OUT_A + OUT_C); 
OnFor(OUT_A
Rev(OUT_A + OUT_C); 
 
OnFor(OUT_A + OUT_C, 100); 
} 
 
he On(), Off(), Fl at(), Fwd(), 
(), and Toggle() comman s a e real
T
commands: 
 
SetOutput(c
This command sets the mode
commands. The value of mode should be one of the constants OUT_ON, OUT_OFF, and OUT_FLOAT. 
 
etDirection(const outputs, const direction) 
S
T
OUT_REV
al, I recomm
o
to
 
Input Commands 
 
Before you can read a value from one of the RCX's inputs, you need to tell the RCX what type of sensor is attached to the 
input. NQC

 
61
SetSensor(expression sensor, const configuration) 
his command tells the RCX how to configure the given input. Valid values for sensor are SENSOR_1, SENSOR_2, and 
s are detailed in Table 4-1. See Appendix 
, Finding Parts and Programming Environments, which lists the sensors that are available for the RCX. 
 
Table 4-1. NQC Sensor Modes 
 
Configuration   
 
 
Sensor  
 
 
Type Input   
 
 
 
 
 
Value ClearSensor() 
 
SENSOR_TOUCH   
 
Touch   
 
 
1 (pressed) or 0 (not pressed)   
- 
 
SENSOR_LIGHT   
 
Light   
 
 
0 (dark) to 100 (bright)   
 
 
- 
 
SENSOR_ROTATION   
Rotation   
 
16 units per full rotation  
 
 
yes 
 
SENSOR_CELSIUS   
Temperature   
Celsius degrees times 10  
 
 
- 
 
 
SENSOR_FAHRENHEIT  Temperature   
Fahrenheit degrees times 10  
 
 - 
 
 
 
ENSOR_PULSE   
 
Touch   
 
 
Count of presses  
 
 
 
 
 yes 
 
Touch   
 
 
Count of state transitions  
 
 
yes 
nput's configuration and are described in Table 4-1. 
T
SENSOR_3, which represent the three inputs of the RCX. The sensor configuration
A
S
 
SENSOR_EDGE   
 
The actual sensor value can be read using SENSOR_1, SENSOR_2, and SENSOR_3. These are shorthand for the following 
command: 
 
SensorValue(const input) 
This command returns the current value of the given input, which should be 0, 1, or 2, for input 1, input 2, and input 3 
respectively. The values returned from an input depend on the i
 
 
  
 
 
   
  
                                                                                     
 
              
 
 
The SENSOR_PULSE and SENSOR_EDGE configurations are variations on SENSOR_TOUCH. The SENSOR_PULSE 
configuration counts the times the touch sensor has been pressed, while SENSOR_EDGE counts the transitions from on to off 
and from off to on. When you read the value of an input in one of these configurations, the input value is the accumulated 
count. 
 
The configurations that keep a count can be reset with a call to ClearSensor() (as shown in Table 4-1): 
 
ClearSensor(expression sensor) 
This command resets the current count for the given input to 0. 
 
nd SENSOR_3 actually have a dual  purpose in life.  Their  first  purpose is to 
 
 
mmands like  
 
SetS
o
rieve values from the inputs. Thus, there are two distinct uses for 
SENSOR_1, SENSOR_2, and SENSOR_3. 
 
 
SENSOR_1, SENSOR_2, a
 
identify the inputs on the RCX to co
ens r(). Their second purpose is to  ret

 
62
Edges and Pulses 
 
If you examine the output of a touch sensor, over time, it looks something like this: 
 
 
 
The transitions from 0 to 1 and from 1 to 0 are called edges. A transition from 0 to 1 is a rising edge, while a transition from 1 
 0 is a falling edge. 
he 
configuration counts all edges, rising or falling. SENSOR_PULSE is a little more selective—it counts 
 sensor. It begins by configuring input 1 to count 
R
U
configuration. Then it enters an endless loop, repeatedly testing the value of input 1. 
t 1 is reset. 
at the same time. The input type describes the 
ached sensor, while the mode determines how the sensor values are interpreted. If you need 
to
 
T
SENSOR_EDGE 
sing edges only. 
ri
 
he following example plays a sound after every fourth press on the touch
T
touch presses with the SENSO _P LSE 
, a sound is played, and the count for inpu
If it is 4
 
task main() { 
SetSensor(SENSOR_1, SENSOR_PULSE); 
while(true) { 
if (SENSOR_1 == 4) { 
PlaySound(SOUND_DOWN); 
ClearSensor(SENSOR_1); 
} 
} 
} 
 
The SetSensor() command actually configures an input's type and mode 
lectrical characteristics of the att
e
finer control over the inputs than you can get from SetSensor(), use the SetSensorType() and SetSensorMode() 
commands: 

 
63
SetSensorType(expression sensor, const type) 
This command specifies the type of sensor attached to the given input. Input types are listed in Table 4-2. This command 
NSOR_TYPE_LIGHT type, for example, supplies 
ype Constant   
 
 
 
 
 
Sensor Type 
ENSOR_TYPE_TOUCH   
 
 
Touch sensor 
and is used to specify the 
 
t value should be processed. 
_MODE_RAW    
 
Raw sensor value from 0 to 1023 
_EDGE   
 
Counts transitions from 1 to 0 and vice versa 
 
CENT   
Percent from 0 to 100 
ENSOR_MODE_CELSIUS   
Celsius temperature 
ENSOR_MODE_FAHRENHEIT  Fahrenheit temperature 
ted to the input values that your 
rogram sees by a process that depends on the input mode. Three of the modes count events: SENSOR_MODE_EDGE, 
ULSE, and SENSOR_MODE_ROTATION. The other modes perform a mathematical scaling operation on 
 
For example, if the input mode is SENSOR_MODE_PERCENT, the RCX converts the raw value into a percent according to the 
equation: 
specifies how the RCX should treat an input, electrically speaking. The SE
power to the sensor. (I described this back in Chapter 3.) 
 
Table 4-2. Input Type Constants 
 
T
 
S
 
SENSOR_TYPE_TEMPERATURE  Temperature sensor 
 
SENSOR_TYPE_LIGHT   
 
 
Light sensor (powered) 
 
SENSOR_TYPE_ROTATION   
 
Rotation sensor (powered) 
 
SetSensorMode(expression sensor, const mode) 
se this command to set the mode of the given input. While the SetSensorType() comm
U
electrical characteristics of the input, the SetSensorMode() command specifies how the inpu
he modes are listed in Table 4-3. 
T
 
able 4-3. Input Mode Constants 
T
 
ode Constant   
 
 
 
 
Description 
M
 
ENSOR
S
 
SENSOR_MODE_BOOL   
 
Either 1 or 0 
 
 
SENSOR_MODE
 
SENSOR_MODE_PULSE   
Counts transitions from 1 to 0 
 
SENSOR_MODE_PER
 
S
 
S
 
SENSOR_MODE_ROTATION   
Shaft angle, 16 counts per full revolution 
 
Internally, input values initially have a raw value from 0 to 1023. Raw values are conver
p
SENSOR_MODE_P
the raw input value. 

 
64
If you wanted to attach a temperature sensor to input 2 and measure Celsius values, you would do the following: 
he SetSensor() command, which I described first in this section, is a convenient way of specifying both an input type 
 mode. Table 4-4 shows what types and modes correspond to the configurations that SetSensor() recognizes. 
put Configuration   
Input Type   
 
 
 
 
 
 
Input Mode 
  
 
SENSOR_TYPE_TOUCH   
 
 
SENSOR_MODE_PULSE 
ENSOR_LIGHT   
 
SENSOR_TYPE_LIGHT   
 
 
SENSOR_MODE_PERCENT 
 
SEN
 
SENSOR_FAHRENHEIT  SENSOR_TYPE_TEMPERATURE  SENSOR_MODE_FAHRENHEIT 
 
SEN
YPE_ROTATION   
 
SENSOR_MODE_ROTATION 
 
Time
 
The 
ur internal timers, numbered 0, 1, 2, and 3. They count in increments of 100 ms, or once every 1/10 seconds. 
NQC
ds for interacting with the timers: 
 
Timer(con
This return
hould be 0, 1, 2, or 3. The number returned is the number of 1/10 seconds 
since the timer 
 
ClearTimer(const n) 
his
mand resets the value of the given timer to 0. The timer begins counting up again immediately. 
 
NQC has a simple command for creating random numbers. Random numbers are often useful in robot programming. For 
example, a robot that tries to drive around obstacles can easily get stuck in a corner if it always backs up and turns exactly the 
same way to get away from an obstacle. A robot that backs up for a random amount of time and turns for a random amount of 
time is less likely to get stuck in this way. The command for generating random numbers is: 
 
Random(const n) 
This command returns a random number between 0 and n. 
 
SetSensorType(SENSOR_2, SENSOR_TYPE_TEMPERATURE); 
SetSensorMode(SENSOR_2, SENSOR_MODE_CELSIUS); 
 
T
and an input
 
Table 4-4. Input Configurations, Types, and Modes 
 
In
 
SENSOR_TOUCH   
 
SENSOR_TYPE_TOUCH   
 
 
SENSOR_MODE_BOOL 
 
SENSOR_PULSE 
 
SENSOR_EDGE   
 
SENSOR_TYPE_TOUCH   
 
 
SENSOR_MODE_EDGE 
 
S
SOR_CELSIUS   
SENSOR_TYPE_TEMPERATURE  SENSOR_MODE_CELSIUS 
SOR_ROTATION   
SENSOR_T
rs 
X has fo
RC
 includes two comman
st n) 
s the value of the specified timer, which s
was cleared. 
T
 com
 
Random Numbers 

 
65
Program Flow 
less they can make 
ecisions and repeat actions. In this section, I'll sketch out NQC's program control commands. NQC supports a standard set of 
e ever programmed in other languages (particularly C), this will look familiar. 
aiting 
QC includes a command that tells the robot to do nothing for a certain amount of time. 
aybe the robot needs to move forward or turn 
r a little while, or you want to give a sound ti
mmand is: 
 hundredth
call to Wait(100) will pause the 
sk for a full second. Note that this only applie
rrent task—other tasks will continue to execute. I'll talk more about 
va
of waiting for an event, like a press on a touch sensor, or a certain time of day. The 
follo
to become true: 
 
l
ion) [statements] 
 this command to wait for the given condition to become true. You could, for example, wait for the value of input 1 to 
until (SENSOR_1 == 4); 
pty body, which means it won't do anything each time the condition is tested—it simply 
waits until the condition is true. The following program beeps every half second until you press a touch sensor on input 1 
 
SetSensor(SENSOR_1, SENSOR_PULSE); 
= 4) { 
Wait(50); 
mpare values and = to assign values. 
 
You've seen how to control the RCX's outputs and inputs. But robot programs aren't very interesting un
d
conditional branches and loops; if you'v
 
W
Although it might not seem important, N
This is often useful if you need to allow some time for something to happen—m
me to play. The co
fo
 
Wait(expression ticks) 
This command causes the current task to pause for the supplied
s of a second; a 
s to the cu
ta
tasks a little later. 
 
A 
riation on this theme is the concept 
wing c
condition 
ommand waits for a 
unti
se
 (boolean condit
U
become 4 like this:∗ 
 
 
This 
l has an em
particular unti
four times: 
task main() { 
until (SENSOR_1 =
PlaySound(SOUND_CLICK); 
} 
} 
 
∗ As in C, conditional expressions are very different from evaluations. Use == to co

 
66
Loops 
 
A loop is a series of commands that you want to be executed repeatedly. NQC offers three flavors of loop: 
 
repeat (expression value) [statements] 
is command simply repeats the given statements value times. 
) [statements] 
This loop 
ents until condition is no longer true. 
 
do [statements]
 
This loop is sim
t the statements are executed before the condition is tested. The statements will always 
be executed
ich is not true for a while loop. 
 
's
 at an example. The following code plays a sound every half second while a light sensor attached to input 3 sees dark: 
(50); 
tic
y braces are used to bracket the statements that belong to the while loop. If you have only one command in 
e b
, you can omit the braces like this: 
To test a condition, use the if command. 
ts only if condition is true. 
 (bo
ion) [statements] else [statements] 
and. If the condition is false, the statements after the else are executed. 
e 
e turns different directions depending on the value of input 2: 
T_FULL); 
Th
 
while (boolean condition
repeats the supplied statem
 while (boolean condition)
ilar to while bu
 at least once, wh
Let  look
 
while (SENSOR_3 < 35) { 
PlaySound(0); 
Wait
} 
 
No
e how curl
ody of the while
th
 
while (SENSOR_3 < 35) 
Wait(50); 
 
Conditionals 
 
 
if (boolean condition) [statements] 
his command executes the given statemen
T
 
if
olean condit
This is a simple variation on the basic if comm
 
Th following exampl
 
SetPower(OUT_A + OUT_C, OU
if (SENSOR_2 < 50) { 
Fwd(OUT_A); 
Rev(OUT_C); 
} 
else { 
 
Rev(OUT_A);
Fwd(OUT_C); 
} 
(OUT_A + OUT_C); 
On

 
67
Variables 
 
To use a variable, you simply need to declare its name. Only integer variables are supported. Once a variable is declared, you 
can assign the variable values and test it in the body of the program.  
Here's a simple example: 
 
int i; 
 
task main() { 
i = 0; 
} 
 
This e
ble, i, is declared in the very first line: 
 
 
Values
g the = operator: 
 
i = 
 
You can al
ables, like this (not part of the example): 
 
= 
 
In th
llowing line, one is added to the value in variable : 
 for the following: 
turn, is shorthand for this: 
i = i + 1; 
d Macros 
 can be assig
ul names using #define. This is a idiom that will be familiar to C programmers. 
re is an example: 
 
} 
 
NQC replaces every occurrence of POWER with 5 in your source code before compiling it. Although this may not seem like a 
big deal, it is; #define lets you create 
while (i < 10) { 
PlaySound (0); 
Wait(5 ∗ i); 
i += 1; 
}  
xample beeps at successively longer intervals. The varia
int i; 
 are assigned to the variable usin
0; 
so assign input values to vari
i 
SENSOR_2; 
e fo
i
 
i++; 
 
This is really shorthand
 
i += 1; 
 
The += operator, in 
 
 
Using #define for Constants an
 
Constant values
ned meaningf
He
 
#define POWER 5 
task main() { 
SetPower(OUT_A + OUT_C, POWER); 
On(OUT_A + OUT_C);

 
68
readable names for things that might otherwise be cryptic. It also lets you define things that might need to be adjusted 
roughout your program in one place. Your program, for example, might have multiple places where it set the outputs to 
 all the way through your program, you can use the constant value POWER. If you 
ter decide you want the power level to be 7, you just have to change the definition of POWER, instead of finding all the places 
 he  t
 o
s set. 
macro is a kind of miniature program. Usually you'll define a macro for 
mething you want to do frequently. The following program uses three macros: 
T
 power); \ 
#define right(power) \ 
 power); \ 
forward(OUT_FULL); 
y 
Soun
 
Your
ged sounds, using the following command: 
 
Play
nd(const n) 
This
und represented by n. NQC includes constant names for each available sounds, as detailed in Table 
4-5. 
 
Table 4-5.
 
Sound Na
 
SOUND_C
 
SOUND_D
 
(table cont
th
power level 5. Instead of explicitly putting 5
la
in your program w
re he utput power i
 
You can also create macros with #define. A 
so
 
#define forward(power) \ 
SetPower(OU _A + OUT_C,
OnFwd(OUT_A + OUT_C); 
#define left(power) \ 
SetPower(OUT_A + OUT_C, power); \ 
OnRev(OUT_A); OnFwd(OUT_C); 
SetPower(OUT_A + OUT_C,
OnFwd(OUT_A); OnRev(OUT_C); 
 
task main() { 
Wait(100); 
left(OUT_HALF); 
Wait(100); 
right(OUT_HALF); 
Wait(100); 
Off(OUT_A + OUT_C); 
} 
 
The preceding example shows off two features of macros. First, each macro has a parameter, power, that is used in the bod
 the macro. Second, the macros are split out to multiple lines by using a backslash. 
of
 
ds and Music 
 RCX can play various prepacka
Sou
 command plays the so
 RCX System Sounds 
me  
 
 
 
Description 
LICK   
 
Short beep 
OUBLE_BEEP  Two medium beeps 
inued on next page) 

 
69
(table cont
 
Table 4-5.
 
Sound Na
 
SOUND_D
eggio 
 
SOUND_U
 
SOUND_L
 
 
SOUND_F
UND_UP but faster) 
 
If you'd pr
u can play individual notes with the PlayTone() command: 
 
PlayTone(
This comm
fied duration. The frequency is in Hz, so 440 is the pitch of 
the A abo
hs of a second. You can only specify integer values for the 
frequency
 exactly in tune. No one expects your little robot to sound like Pavorotti. 
 
If you wan
ave to be a little tricky about it. Each time you call PlayTone(), the command 
returns alm
equested to finish playing. The tone you've requested is put 
in a 
e
utes. If you call PlayTone() repeatedly, the queue will 
fill u
will not fit on the queue and the tones you've requested will not be played. The queue is 
 eight tones. If you want to play a sequence longer than this, you should insert calls to Wait() in your 
nstrates this technique; it plays part of Quando men vo, from Giacomo Puccini's La Bohème. 
#define SIXTH 12 
ne HALF 3∗SIXTH 
#define GRACE 6 
 2∗BEAT); 
∗BEAT + 2∗SIXTH); 
ayTone(115, SIXTH); 
∗
PlayTone(247, SIXTH); 
inued from previous page) 
 RCX System Sounds (continued) 
me  
 
 
 
Description 
OWN   
 
 
Descending arp
P   
 
 
 
Ascending arpeggio 
OW_BEEP   
Long low note
AST_UP   
 
Quick ascending arpeggio (same as SO
efer to make your own music, yo
const frequency, const duration) 
and plays a note with the given frequency for the speci
duration is in hundret
ve middle C on a piano. The 
, so don't expect the pitches to be
t to play a sequence of notes, you h
ost immediately, with-out waiting for the sound you've r
; the system plays it while the rest of your program exec
queu
p. 
Subsequent calls to PlayTone() 
ng enough to hold
lo
program so that the queue has time to empty out as notes are played. 
 
The following example demo
 
#defi
#define BEAT 2∗HALF 
 
task main() { 
PlayTone(330,
Wait(2
Pl
PlayTone(208, SIXTH); 
PlayTone(247, SIXTH); 
PlayTone(330, SIXTH); 
PlayTone(311, 2 BEAT); 
Wait(4∗SIXTH + 2∗BEAT + 2∗SIXTH); 
PlayTone(115, SIXTH); 
PlayTone(208, SIXTH); 

 
70
PlayTone(311, SIXTH); 
∗BEAT); 
TH + 3∗BEAT + HALF); 
11, HALF); 
30, HALF); 
11, HALF); Wait (2∗HALF); 
77, HALF); 
30, HALF); 
20, HALF); 
0, 2∗BEAT); 
∗HALF + 2∗BEAT + HALF); 
7, HALF); 
0, GRACE); 
 
; 
PlayTone(208, 2 BEAT); 
t(GRACE + 5∗HALF + 2∗BEAT + HALF); 
} 
our robot can send and receive data over its IR port. In NQC, three commands handle sending and receiving data: 
n byte of data out the IR port. 
learMessage() 
e 
isplay directly in NQC, you can configure it to some degree: 
 
SelectDisp
This comm
ted by v on its display. The legal values for v are shown in 
View button on the front of the RCX to show the state of the 
lectDisplay() command allow you to do this as part of a program. 
PlayTone(277, 3
Wait(4∗SIX
PlayTone(277, HALF); 
PlayTone(3
PlayTone(370, GRACE); 
PlayTone(3
PlayTone(3
PlayTone(2
PlayTone(3
PlayTone(2
PlayTone(22
Wait(GRACE + 5
PlayTone(24
PlayTone(277, HALF); 
PlayTone(33
PlayTone(311, HALF); 
PlayTone(277, HALF); Wait (2∗HALF);
PlayTone(247, HALF); 
PlayTone(311, HALF)
PlayTone(208, HALF); 
∗
Wai
 
IR Communication 
 
Y
 
SendMessage(expression m) 
This command sends the give
 
Message() 
Use this command to return the last byte of data received on the IR port. 
 
C
This command clears the incoming message. You may want to do this after responding to an incoming message, to avoid 
responding more than once. 
 
Th Display 
 
Although you can't control the d
lay(expression v) 
and tells the RCX to show the data source represen
You can achieve the same results by pressing the 
Table 4-6. 
inputs or outputs, but the Se

 
71
Table 4-6. Disp
 
Value   
c
 
0   
System clock 
 
 
4   
View Output A 
 
5   
View Output B 
 
6   
View Output C 
 
You 
t the clock in the RCX using the following macro: 
 
SetW
const hours, const minutes) 
Use t
acro to set the current time of the RCX's clock. Unfortunately, only constant values can be used. 
 
The 
 
With
efault firmware, your RCX supports an interesting option called a dtalog. The datalog is simply a list of numbers. 
You can create a new datalog and put numbers into it. Datalogs can be uploaded to your PC for analysis or display. The 
datalog commands are: 
 
Crea
log(const size) 
This
and tells the RCX to make space for the given number of elements. There is only one datalog, so this command will 
erase
vious datalog. 
llowing example waits for a touch sensor on input 1 to be pressed. For each press, the value of timer 0 is stored in the 
, which holds 20 values in this example: 
SetSensor(SENSOR_1, SENSOR_TOUCH); 
 
 
 
count = 0; 
until (count == 20) { 
until(SENSOR_1 == 1); 
AddToDatalog(Timer(0)); 
lay Values 
Des ription 
 
 
1   
 
View Input 1 
 
2   
 
View Input 2 
 
3  
 
View Input 3 
 
 
 
can se
atch(
his m
Datalog 
 the d
teData
 comm
 any pre
 
AddToDatalog(expression v) 
This command adds a value to the datalog. It's up to you to keep track of how many values are in the datalog. If you try to add 
values after the datalog is full, nothing happens. 
 
The fo
atalog
d
 
int count; 
 
 
task main() { 
CreateDatalog(20); 
ClearTimer(0); 

 
72
count++; 
== 0); 
} 
hen you run this program, you'll notice the RCX shows the status of the datalog on the right side of the display. It looks kind 
o upload a datal
e PC, you can use nqc's -datalog option, which simply dumps the values to the screen: 
 
 
8 
12 
16 
19 
23 
25 
27 
29 
 
68 
71 
75 
 
C:\>
 
The datalo
y value. If you use a tool like RCX Command Center, it can show you the source 
of each val
ith Visual Basic, I'll show you how to write your own program in 
Visual Ba
 
Tasks 
 
NQC give
and subroutines. Each of the RCX's five programs is made up of one or more 
tasks. The
another way of saying that the RCX is multitasking. 
 
Tasks are 
nd. Every program must have a main task which is executed when the program is 
first starte
stopped explicitly: 
until(SENSOR_1 
} 
 
W
of like a pie; as you add values to the datalog the pie fills up. 
 
og to th
T
C:\>nqc -datalog
31 
33
39 
47 
52 
56 
9 
5
62 
65 
 
g actually stores the source of ever
ue in the datalog. In Chapter 8, Using Spirit.ocx w
atalog. 
sic to retrieve the contents of the d
s you powerful control over tasks 
se tasks can execute at the same time, which is 
defined using the task comma
d. Other tasks must be started and 

 
73
start taskn
This comm
 
stop taskn
Use this co
 
The follow
 from main and uses another task, sing, to play some music. The sing task has 
to be starte
ands will never be executed. 
 
task
OnFwd(OUT_A); 
#define GRACE 6 
, 2∗BEAT); 
 + 2∗SIXTH); 
PlayTone(115, SIXTH); 
SIXTH); 
IXTH); 
∗BEAT); 
2∗BEAT + 2∗SIXTH); 
IXTH); 
IXTH); 
 
 
PlayTone(277, 3∗BEAT); 
(330, HALF); 
PlayTone(311, HALF); Wait (2∗HALF); 
PlayTone(277, HALF); 
PlayTone(330, HALF); 
PlayTone(220, HALF); 
PlayTone(220, 2∗BEAT); 
Wait(GRACE + 5∗HALF + 2∗BEAT + HALF); 
PlayTone(247, HALF); 
ame 
and starts the named task. 
ame 
mmand to stop the named task. 
ing program controls its outputs
d from main; otherwise, its comm
 main() { 
start sing; 
while (true) { 
OnRev(OUT_C); 
Wait(100); 
OnFwd(OUT_C); 
OnRev(OUT_A); 
Wait(100); 
} 
} 
 
#define SIXTH 12 
#define HALF 3∗SIXTH 
#define BEAT 2∗HALF 
 
task sing() { 
PlayTone(330
Wait(2∗BEAT
PlayTone(208, SIXTH); 
PlayTone(247, 
PlayTone(330, S
PlayTone(3
∗
11, 2
Wait(4 SIXTH + 
PlayTone(115, S
08, S
PlayTone(2
PlayTone(247, SIXTH);
PlayTone(311, SIXTH);
Wait(4∗SIXTH + 3∗BEAT + HALF); 
PlayTone(277, HALF); 
PlayTone(311, HALF); 
PlayTone(370, GRACE); 
PlayTone

 
74
PlayTone(277, HALF); 
PlayTone(330, GRACE); 
PlayTone(311, HALF); 
BEAT); 
Wait(GRACE + 5∗HALF + 2∗BEAT + HALF); 
stop main; 
hen
 playing music, it stops the main task with the stop command. Then it turns the motors off. 
The 
d off the motors and then stopped the main task, it's possible that main would turn on the 
motors ag
ed. Multithreaded programming is powerful but tricky. 
 
Each RCX
 to ten tasks. 
 
Subroutin
 
A su
t
at you will execute frequently. Subroutines offer a way to clean up your source code 
and 
ce the size of compiled programs. Subroutines in NQC are defined in much the same way as tasks. The following 
} 
 
sub 
OnRev(OUT_A); 
 wiggle() was replaced with 
the commands it contains. The nice thing about subroutines is that their code is defined once, but you can call it as many times 
as you like from other places in your program. You could accomplish the same sorts of things with subroutines and macros, but 
subroutines are more 
PlayTone(277, HALF); Wait (2∗HALF); 
PlayTone(247, HALF); 
PlayTone(311, HALF); 
PlayTone(208, HALF); 
PlayTone(208, 2∗
Float(OUT_A + OUT_C); 
} 
 
W
 the sing task is done
order is critical. If we turne
ain before it was stopp
 program can have up
es 
brou
u
ine is a group of commands th
red
program has one subroutine, called wiggle(). The main task shows how this subroutine is called: 
 
task main() { 
wiggle(); 
Wait(200); 
wiggle(); 
wiggle() { 
OnFwd(OUT_A); 
OnRev(OUT_C); 
Wait(20); 
OnFwd(OUT_C); 
Wait(20); 
Off(OUT_A + OUT_C); 
} 
 
Subroutines execute as part of the task from which they are called. It works just as if the call to

 
75
efficient because the code is just compiled once. With a macro, the entire macro body would be placed at each point where it 
as called. 
e RCX imposes three crippling restrictions on subroutines. First, you can't call another subroutine from within a subroutine. 
, you can't pass parameters to a subroutine or get a return value. 
han eight subroutines can be defined for a single program. These limitations are imposed by the RCX's 
 get around restrictions like these, you'll need to use a different 
OS or pbForth. 
another interesting option, the inline subroutine. In source code, it looks a lot like a subroutine except with a  
void wiggle() { 
); 
} 
 
Inlines are
le
es. The compiler actually places the code of the inline wherever it is called, almost 
like 
c
nstant definition. This actually makes inlines appear a little more capable than subroutines: they can call 
other
ersion 2.0, for example, you can define inlines with a parameter, like this: 
 
d
leTime(int waitTime) { 
OnFwd(OUT_A); 
lines are really an example of syntactic sugar, 
etter efficiency. 
Argu
assed in four different ways. Table 4-7 summarizes the options. 
w
 
Th
As a consequence, a subroutine also cannot call itself. Second
ird, no more t
Th
bytecode interpreter, which is defined in the firmware. To
rmware, like leg
fi
 
lines 
In
 
QC does offer 
N
C-style return type (always void): 
 
OnFwd(OUT_A); 
OnRev(OUT_C); 
Wait(20); 
OnFwd(OUT_C
OnRev(OUT_A); 
Wait(20); 
Off(OUT_A + OUT_C); 
 cal
ro or co
d the same way as subroutin
a ma
 inlines or even subroutines. In NQC v
voi  wigg
OnRev(OUT_C); 
Wait(waitTime); 
OnFwd(OUT_C); 
OnRev(OUT_A); 
Wait(waitTime); 
Off(OUT_A + OUT_C); 
} 
 
You can have more than one argument, if you wish. Just remember that in
something that makes your source code look pretty but doesn't necessarily result in b
 
ments to inlines can be p

 
76
Table 4-7. Argument Passing for Inlines 
nt   
 
 
by value   
 
 
 
 
 
 
yes 
onst int  by value   
 
 
 
 
 
 
no 
ns
ference   
 
 
 
 
 
no 
 
If yo
 the parameter's value is copied into a temporary variable (from the pool of 31) and used in the 
inlin
 value, but the value must be a constant at compile time. 
CK); 
Wait(count ∗ 20); 
e 
sed when you want to pass a value that should not be changed. This is great for things 
like 
xample, you might have an inline like this: 
 
void forward(const int& power) { 
SetPower(OUT_A + OUT_C, power); 
OnFwd(O
} 
 
With this inline, you
 d
 a variable or constant: 
 
int power = 6; 
w
d(power); 
 
forward(Message()); 
 
You can basically accomplish the same stuff with int parameters and const int& parameters. The advantage of const 
int& is that no temporary variables are used. 
 
Type   
 
 
By Value or By Reference?   
Temporary Variable Used? 
 
i
 
c
 
int&   
 
by reference   
 
 
 
 
 
no 
 
co
t int& by re
u pass int by value,
e. const int passes by
 
If you pass by reference, the variable that is passed in can actually be modified in the inline. In this code, for example, a 
count variable is incremented in the body of an inline: 
 
task main() { 
int count = 0; 
while (count <= 5) { 
PlaySound(SOUND_CLI
increment(count); 
} 
} 
void increment(int& n) { 
n++; 
} 
 
Th last option, const int &, is u
Sens
 For e
or() and Timer().
UT_A + OUT_C); 
 can o normal things, like passing
for
 
ar
forward(OUT_HALF); 
 
But you can also do trickier stuff, like this: 

 
77
Trusty Revisited 
 
You'
 examples of NQC code. Now I'll show you how Trusty can be programmed using NQC. You'll be able 
 co
he RCX Code programs from Chapter 3. 
New
 
As y
ounter to keep track of Trusty's state. The counter value was used to decide if Trusty would turn 
left o
ht sensor left the black line. In NQC, we can store Trusty's state in a real variable. Plus, we'll 
use symbolic constants to represent state values. 
 
 
 
Trusty's p
value of the light sensor. If it is over the black line, the robot is 
set to mov
 
whil
 
The 
re determined using #defines; this means it's easy to fiddle with their values, and our 
prog
 
The second tas
t sensor leaves the black line. Whenever the robot leaves the line, the 
toggle() su
gle() starts the robot turning. Then we wait a little while; if the robot is still not on 
the black line, w
 the other way: 
 
task lightW
while (
NSOR_2 > LIGHT2) { 
toggle(); 
Wait(TIMEOUT); 
if (SENSOR_2 > LIGHT2) { 
ggle(); 
T ∗ 2); 
} 
} 
 
The togg
s two important functions. First, it makes Trusty turn, based on the value of the state 
variable. Secon
of state; if it was RIGHT, it will be LEFT, and vice versa. 
ve seen some small
mpare the NQC programs to t
to
 
 Brains For Trusty 
ou may recall, we used a c
r right the next time the lig
int state; 
 
#define LEFT 0
#define RIGHT 1 
rogram has two tasks. The first task (main) tests the 
e forward: 
e (true) { 
if (SENSOR_2 < DARK2) 
Fwd(OUT_A + OUT_C); 
On
} 
DARK2 and POWER constants a
ram is easy to read. 
k takes care of things when the ligh
broutine is called. tog
e call toggle() again to turn back
atcher() { 
ue) { 
tr
(SE
if 
to
Wait(TIMEOU
} 
} 
le() subroutine perform
d, it updates the value 

 
78
 Here is the whole program: 
 
int state; 
 
#define LEFT 0 
#define RIGHT 1 
 
#define POWER 7 
_2, SENSOR_LIGHT); 
 OUT_C, POWER); 
task
T ∗ 2); 
} 
} 
e == LEFT) { 
(OUT_A); 
; 
; 
state = LEFT; 
} 
} 
 
The main task performs three important initializations which I haven't mentioned yet. First, main initializes the value of the 
state variable. It just uses LEFT 
#define DARK2 35 
#define LIGHT2 40 
 
 
#define TIMEOUT 50 
 
task main() { 
state = LEFT; 
SetSensor(SENSOR
SetPower(OUT_A +
start lightWatcher; 
while (true) { 
if (SENSOR_2 < DARK2) 
OnFwd(OUT_A + OUT_C); 
} 
} 
 
 lightWatcher() { 
while (true) { 
 > LIGHT2) { 
if (SENSOR_2
toggle(); 
Wait(TIMEOUT); 
if (SENSOR_2 > LIGHT2) { 
 
toggle();
Wait(TIMEOU
} 
} 
 
sub toggle() { 
if (stat
OnRev
OnFwd(OUT_C); 
state = RIGHT; 
} 
else { 
OnFwd(OUT_A)
OnRev(OUT_C)

 
79
arbit
s input 2 for a light sensor. Finally, it starts the lightWatcher task. 
 
Usin
 
In th
ks with the two light sensor version of Trusty. As you may recall, 
prog
Code was cumbersome. 
 
The 
 NQC. It's pretty straightforward to translate Table 3-1 into source code. The basic strategy 
is to
esent the four states of the robot, represented by the four lines of Table 3-1. Then one task 
exam
variable. Another task examines the state variable and sets the motors appropriately. 
 
The f
epresented by constant values. A fifth value, INDETERMINATE, is used when one or both of the 
light
ark or light range: 
 
#def
#define
#define
#define
#define INDETERMINATE 255 
 
The main tas
riable and sets the motors accordingly. No action is taken for 
BOTH_OFF an
 
whil
(true
(state == BOTH_ON) 
OnFwd(OUT_A + OUT_C); 
else if (state == LEFT_ON) { 
A se
ines the light sensor values and sets the state variable. Here is the entire source code for 
the two se
 
int state; 
 
 
// "ON"
f
// sens
// the 
#define BOT
#define LEF
rarily. Next, main configure
g Two Light Sensors 
is section, I'll present an NQC program that wor
ramming this robot in RCX 
programming is a lot cleaner in
 use a state variable to repr
ines the sensors and updates the state 
our possible states are r
 sensor values is not in the d
ine BOTH_ON 3 
 LEFT_ON 1 
 RIGHT_ON 2 
 BOTH_OFF 0 
k simply tests the value of the state va
d IND
 
ETERMINATE:
e 
if 
) { 
Off(OUT_A); 
OnFwd(OUT_C); 
} 
else if (state == RIGHT_ON) { 
Off(OUT_C); 
; 
OnFwd(OUT_A)
} 
} 
 
parate task, watcher, exam
nsor version of Trusty: 
 re ers to whether the light 
or is on the line. If it is, 
light sensor is seeing black. 
H_ON 3 
T_ON 1 

 
80
#define RIGHT_ON 2 
#define BOTH_OFF 0 
ETERMINATE 255 
 
d dark. 
#define LIGHT3 45 
#define POWER 4 
if (state == BOTH_ON) 
A + OUT_C); 
else if (state == LEFT_ON) { 
else if (state == RIGHT_ON) { 
task watcher() { 
while (true) { 
if (SENSOR_2 < DARK2) { 
if (SENSOR_3 < DARK3) state = BOTH_ON; 
else if (SENSOR_3 > LIGHT3) state = LEFT_ON; 
else state = INDETERMINATE; 
} 
else if (SENSOR_2 > LIGHT2) { 
if (SENSOR_3 < DARK3) state = RIGHT_ON; 
else if (SENSOR_3 > LIGHT3) state = BOTH_OFF; 
else state = INDETERMINATE; 
} 
else state = INDETERMINATE; 
} 
} 
#define IND
// Thresholds for light an
#define DARK2 35 
#define LIGHT2 40 
#define DARK3 40 
 
 
task main() { 
initialize(); 
while (true) { 
OnFwd(OUT_
Off(OUT_A); 
OnFwd(OUT_C); 
} 
Off(OUT_C) 
OnFwd(OUT_A); 
} 
} 
} 
 
sub initialize() { 
SetSensor (SENSOR_2, SENSOR_LIGHT); 
SetSensor (SENSOR_3, SENSOR_LIGHT); 
SetPower(OUT_A + OUT_C, POWER); 
OnFwd(OUT_A + OUT_C); 
start watcher; 
} 
 

 
81
Online Resources 
QC—Not Quite C 
ct.com/~dbaum/lego/nqc/
 
N
 
http://www.entera
This is the official site for NQC. You can download the current release, read the documentation, or browse a FAQ. Dave Baum 
as packed a lot of useful information into this site, including such gems as how to create a cable to connect your Macintosh to 
so includes the definitive NQC documentation. 
X Command Center 
ttp://www.cs.uu.nl/people/markov/lego/rcxcc/
h
the IR tower. This site al
 
Lego Robots: RC
 
h
RCX Command Center (RcxCC), developed by Mark Overmars, is built on top of NQC. It's a Windows application that 
rovides a friendly graphic interface to the features of NQC. It includes a syntax-colored program editor, real-time control of 
tilities for making your RCX play music, and useful help files. I highly recommend this application. 
C Tutorial] 
ttp://www.cs.uu.nl/people/markov/lego/
p
the RCX, u
 
Lego Robot Pages [NQ
 
h
Mark Overmars, creator of RcxCC (the previous entry), has written a detailed introduction to NQC. It's available off his main 
eb page as PDF, Word97, PostScript, or RTF. This document is a gentle and thorough introduction to NQC. 
QC Reference Page 
saddi/mindstorms/nqc-reference.html
w
 
evin Saddi's N
K
 
http://home1.gte.net/k
This page provides a distilled view of NQC. It's very handy when you can't remember the input type constants, or you'd like to 
see NQC's commands organized by function. Single-line code samples are also included. 
 
Hitachi Single-Chip Microcomputer H8/3297 Series… 
 
http://semiconductor.hitachi.com/products/pdf/h33th014d2.pdf
This PDF document has all the crufty details on the Hitachi H8 that forms the heart of the RCX. The specific model is the 
H8/3292, which is covered in the manual. This information is n
r casual browsing—you probably won't need to look here 
nless you start writing your own firmware. (Hitachi's web site is a little flakey. If you're having trouble with this URL, try 
starting at the URL http://semiconductor.hitachi.com/h8/
ot fo
u
 
 for the H8/3292.) 
and searching

 
82
5 
Minerva, a Robot with an Arm 
 this chapter: 
 
• Pulleys 
 
 
• Mechanical Design 
 
 
• Two Sensors, One Input 
 
 
• Where Am I? 
 
 
• Online Resources 
 
 
Minerva is a mechanical marvel. Although she has the same wheel layout as Trusty, Minerva's drivetrain is radically different. 
In addition, she has a simple arm with a grabber, which allows her to pick up and drop small objects. Best of all, Minerva can 
be built with the pieces from the RIS alone. The grabber arm is operated by a single motor. The other motor powers the 
drivetrain, which moves the robot forward or spins it in place. Figure 5-1 shows a picture of this remarkable robot. 
 
 
In
 
 
• Building Instructions 
 
 
• Programming 
 
 
Directional Transmission 
• 
 
 
 
 
Figure 5-1. 
Minerva, a mechanical masterpiece 
 
When you run Minerva's program, she drives straight forward. When the light sensor (mounted on the end of the grabber arm) 
sees something dark, Minerva stops driving. She uses the arm to try to pick up whatever the light sensor saw.  

 
83
Then she turns around and drives back to her starting point. She puts down whatever she's carrying, turns around and is ready 
to start again. 
 
Building Instructions 
 
If there's one lesson to be learned from Minerva, it is that mechanical design is hard. I had to build this robot five times to get it 
right. And I don't mean I moved a few pieces around—I actually disassembled and rebuilt the robot that many times. The 
drivetrain alone took four tries before I got it right.∗ 
 
Directional Transmission and Drivetrain 
 
The long gray piece in Step 1 swivels freely on the shaft. 
 
 
 
∗ Minerva uses almost all of the gears that come with RIS 1.0. Unfortunately, RIS 1.5 comes with fewer gears (five 12t gears 
instead of eight). To get the extra gears you'll need for Minerva, you can order the #5229 Gears & Differentials parts pack from 
the LEGO Shop At Home Service, (800) 453–4652. Cost is $4.50 including shipping. 

 
84
The 8u shaft in Step 2 is loose and may fall out. It will be anchored in the next step. The 6u beam, like the long gray piece from 
Step 1, swivels freely on its shaft. 
 
 

 
85
 
 
Make sure the bump on the long pin is up against the 4u beam. 
 
 
 
Before you put all of Step 7 together, make sure the swiveling parts from Steps 1 and 2 are pointing up, as shown. 
 

 
86

 
87

 
88
Step 11 is tricky. You'll need to slide the 8u shaft into the structure, adding bushings and gears as you go. The swiveling pieces 
fr
 Steps 1 and 2 are now anchored. 
om
 

 
89
 
 
Step 14 is similar to Step 11; take a deep breath and go slowly. 
 
 

 
90
Grabber Arm 
 
 
In Step 17, the half-bushings go between the center block and the cams (pear-shaped pieces). 
 
 

 
91

 
92
 
Make sure that the two sides are at the same angle. They should mirror each other. 
 

 
93

 
94
 
 
Structural Support 
 
 

 
95
 
 
Idler Wheel 
 
 
 

 
96

 
97
Drive Motor 
 
 
While you're putting the motor in, hold on to the worm gear so it doesn't slip off. 

 
98
 
 
Grabber Arm Motor 
 

 
99

 
100
RCX 
 
 
 
Attach the RCX on both sides as shown. 

 
101
 
 
Wiri
 
 
First, attach the left motor, which powers the arm, to output A. Then use a wire brick to attach the right motor (the drive motor) 
to ou
 
ng
tput C. 
 

 
102
Attac
t of the arm. The wire attaches to Minerva's side as shown. 
 
h the light sensor to the fron
 
 
Next, use 
onger wire brick to attach both wires to 
input 3. 
 
a wire brick to attach the touch sensor to the light sensor wire. Then use a l
 

 
103
Programm
 
Minerva's 
forward: 
 
nd
ng it back to the starting point 
ility to 
ive
here's no way to do this in RCX Code. Minerva's program also does 
me
CX Code. 
 sensor and grabber light sensor. 
T); 
L); 
UMBER_OF_SAMPLES 10 
int runningTotal; 
int threshold; 
ing 
basic program is straight
fi
bri
 something to pick up 
 
The program assumes that the objects to pick up will be dark and that the surface Minerva is driving on is light. To return to 
the starting point, Minerva measures how long it has to drive forward to pick something up. Then it turns around and drives 
back for the same amount of time. Here's a slightly exploded version of Minerva's program: 
 
drive forward until the light sensor sees something dark 
pick it up with the grabber 
turn around 
drive back to the starting point 
drop whatever's in the grabber 
 
I've written Minerva's program in NQC (see Chapter 4, Not Quite C). You could create a program in RCX Code (the 
vironment that comes with RIS), but you wouldn't be able to implement some key features. In particular, Minerva's ab
en
dr
 back just as far as she drove forward is crucial. T
 sensor calibration that would also be impossible in R
so
 
Here's the whole program: 
 
#define TURNAROUND_TIME 425 
 
int i; 
 
task main() { 
// Arm limit
SetSensor(SENSOR_3, SENSOR_LIGH
SetPower(OUT_A + OUT_C, OUT_FUL
 
calibrate() ; 
i = 0; 
while (i < 5) { 
retrieve(); 
1; 
i += 
} 
OFF(OUT_A + OUT_C); 
} 
 
#define N

 
104
sub calibrate() { 
// Take an average light reading. 
i = 0; 
l = 0; 
_SAMPLES) { 
i += 1; 
runningTotal / NUMBER_OF_SAMPLES; 
OnFwd(OUT_A); 
ENSOR_3 == 100); 
off from the switch. 
); 
00); 
til (SENSOR_3 == 100); 
 Back off from the switch. 
 
grab(); 
 
// Turn around (roughly). 
OnRev(OUT_C); 
Wait(TURNAROUND_TIME); 
 
// Drive back. 
OnFwd(OUT_C); 
ClearTimer(0); 
until (Timer(0) >= returnTime); 
Off (OUT_C); 
runningTota
while (i < NUMBER_OF
runningTotal += SENSOR_3; 
Wait(10); 
} 
threshold = 
} 
 
void grab() { 
// Run the motor until we hit the limit switch. 
until (S
// Back 
OnRev(OUT_A
until (SENSOR_3 != 1
Off(OUT_A); 
} 
void release() { 
// Run the motor until we hit the limit switch. 
OnRev(OUT_A); 
un
//
OnFwd(OUT_A); 
until (SENSOR_3 != 100); 
Off(OUT_A); 
} 
 
int returnTime; 
 
sub retrieve() { 
// Drive forward until we see something. 
OnFwd(OUT_C); 
ClearTimer(0); 
until (SENSOR_3 < threshold - 3); 
Wait(20); // Move up on it a little. 
returnTime = Timer(0); 
Off(OUT_C); 

 
105
release(); 
 
// Turn around. 
; 
Wait(TURNAROUND_TIME); 
. All they 
o is run the arm motor in one direction until the limit sensor is pressed. Running the motor forward causes the arm to descend, 
the grabber to close, and the arm to lift again. Running the moto in reverse makes the arm descend, the grabber open, and the 
m lift again. The mechanics of the arm take care of everything, as I'll explain later in the chapter. All we have to do is wait 
e arm to lift, which presses the switch when it's f
 might have noticed that the light sensor and the touch 
sensor are both attached to the 
be aware that it's necessary for 
grab() and release() to m
 
able threshold. The retrieve() subroutine uses this value to figure out if it's looking at an 
bject that should be picked up. Specifically, it tests if the light sensor value is a little less than the original average: 
alibrating the sensor in this way frees us from hard-coding a light sensor threshold value into Minerva's program. It also 
r able to deal with different lighting conditions. 
 (by turning output C on) until it finds 
mething dark to pick up. While it's driving forward, timer 0 is ticking away, measuring how long it takes until something is 
until (SENSOR_3 < threshold - 3); 
 dark object is found, Minerva moves forward a little farther to position the grabber over the object. She records the 
forward movement time for the return trip. Finally, Minerva turns off output C to stop the robot's forward motion: 
 
Wait(20); // Move up on it a little. 
returnTime = Timer(0); 
Off(OUT_C); 
 
Having found something interesting, Minerva picks it up: 
 
grab(); 
OnRev(OUT_C)
} 
 
Let's look at the simple parts first. The grab() and release() inline subroutines take care of the grabber arm
d
r 
ar
for th
inished. You
same input. I'll talk about how this works later. For now, just 
ove away from the touch sens r to use the light sensor. 
o
The calibrate() subroutine examines the values coming from Minerva's light sensor. It computes an average value, 
which is stored in the vari
o
 
until (SENSOR_3 < threshold - 3); 
 
C
makes Minerva bette
 
The retrieve() subroutine is the heart of Minerva's program. It drives forward
so
found: 
 
OnFwd(OUT_C); 
ClearTimer(0); 
 
Once a

 
106
Now she wants to turn around and return to her starting point. To turn around, she simply reverses the direction of output C for 
the duration given by TURNAROUND_TIME: 
 
OnRev(OUT_C); 
Wait(TURNAROUND_TIME); 
 
Now she drives back to her starting point, using the returnTime value, which was saved earlier: 
 
OnFwd(OUT_C); 
ClearTimer(0); 
until (Timer(0) >= returnTime); 
Off(OUT_C); 
 
Finally, the retrieve() subroutine drops the object that Minerva's carrying and turns around again: 
 
release(); 
 
OnRev(OUT_C); 
Wait(TURNAROUND_TIME); 
he main task configures Minerva's inputs and then calls retrieve() five times in a row. If everything works perfectly, 
Try It Out! 
 
To take Minerva out for a spin, I suggest using the back o
d that comes with RIS. It acts as a mostly uniform bright 
surface. Put the Test Pad on a hard,
esults. In particular, you may need 
to adjust the TURNAROUND_TIME constant to make Minerva spin around 180°. Scatter some black blocks on the back of the 
. Minerva may not ''see" the dark blocks to pick them up. I found that I got better results after the RCX was on for a minute or 
2. Minerva's wheels may stumble on the blocks, throwing her off course. Instead of driving and returning on a straight line, 
Minerva will now be pointing in a different direction. She probably won't bring blocks back to her original starting point. 
 
3. The grabber doesn't always pick up the block Minerva is aiming for. 
 
T
which it probably won't, Minerva finds five dark objects and brings them back to her starting point. In the next section, I'll 
explore some of the things that can confuse Minerva. 
 
f the Test Pa
 flat surface. Different surfaces will give you different r
Test Pad and start Minerva running. If you're lucky, she'll go pick up some blocks and bring them back to her starting point. 
 
There are quite a few things that can go wrong: 
 
1
two—the sensor values depend on the battery power, which stabilizes after the RCX is on for a while. 
 

 
107
Some of the challenges Minerva faces are discussed later in this chapter. First, I'm going to talk about Minerva's amazing 
mechanical features. 
 
Directional Transmission 
 
Minerva uses a single motor to drive forward and to turn. This mechanical magic is accomplished with the aid of a  directional 
transmission. A directional transmission does different things depending on whether you run a motor shaft forward or in 
reverse. Functionally, you can think of it as a box with an input shaft and two output shafts, as shown in Figure 5-2. 
 
 
 
ast two ways to build a directional transmission with the parts included in your RIS. The first design uses a pair 
nding on which direction the input shaft turns, the beam swings to the left or right; the top gear on the 
, frictionless world, this design would never 
work. 
Figure 5-2. 
A directional transmission will drive one of two output shafts 
 
 
If you rotate the input shaft clockwise, one of the output shafts will rotate. If you rotate the input shaft counterclockwise, the 
ther output shaft rotates. 
o
 
here are at le
T
of gears on a swinging arm. The second design uses a worm gear. Minerva uses the worm gear design, but I'll briefly explain 
the fundamental ideas of both types of directional transmission. 
 
Swing-Arm Design 
 
A cutaway view of a swing-arm directional transmission is shown in Figure 5-3. 
 
The bottom shaft is the input. A 24t gear mounted on this shaft drives another gear that is mounted on a beam that rotates on 
e input shaft. Depe
th
beam engages the gear on either the far left or far right. These gears are on the output shafts. You could create variations on 
this configuration, using different combinations of gears, but the idea is the same. 
 
This design relies on friction to swing the arm in the right direction. In an ideal

 
108
 
 
Figure 5-3. 
Cutaway view of a swing-arm directional transmission 
orm Gear Design 
 
W
 
Minerva's drivetrain is based on a worm gear directional transmission. The basic design of the worm gear directional 
transmission is quite simple. A cutaway view is shown in Figure 5-4. 
 
 
 
Figure 5-4. 
Cutaway view of a worm gear directional transmission 
 
The input shaft drives the worm gear, which slides freely along the shaft. In fact, it's easier for the worm gear to slide on its 
shaft than to turn one of the output shafts. Depending on which way the input shaft turns, the worm gear slides as far as it can 
in one direction or the other. When it can't slide any more (because it's hit a beam), the worm gear will turn one of the output 
shafts. 
 
Minerva actually uses a modified version of this design with four outputs. The worm gear engages two outputs at a time, as 
shown in Figure 5-5. 

 
109
 
 
Figure 5-5. 
Minerva's direction
 has four outputs 
The basic directional transmission designs I've described are quite simple. Try to use one of these to drive a robot, however, 
ne sucks up all of the 8t 
ears, all of the 16t gears, and most of the 24t gears that come with RIS. If you decide directional transmissions are useful for 
ulleys are an interesting alternative to gears. A pulley is simply a slotted wheel, like the ones used with outdoor clotheslines. 
r, a twisted band will rub on itself, which may significantly reduce its life span. 
ulleys also give you the flexibility to transmit motion between two perpendicular shafts. Figure 5-6 shows three different 
in used pulleys to replace several gears. Although pulleys are useful for light-
uty work, like the grabber arm, they don't work very well for drivetrains. Unless the band that connects two pulleys is very 
al transmission
 
and things get a little more complicated. Minerva, as you've seen, is a gear hog. The drivetrain alo
g
your robot, you may want to have some extra gears handy from other sets. 
 
Pulleys 
 
P
The RIS comes with a handful of rubber bands that can be used to link pulleys together. This type of linkage is similar to using 
gears to transmit motion from one shaft to another. By using pulleys of different sizes, you can achieve the same power and 
speed tradeoffs as with gears. The only difference is that pulleys connected by a band turn in the same direction, while two 
gears meshed together turn in opposite directions. If you twist the band around once, you can get the pulleys to move in 
opposite directions, just as with gears. Howeve
P
pulley arrangements. 
 
One of the early designs of Minerva's drivetra
d
tight, it's likely to slip if it's used to do heavy work, like moving an entire robot. 

 
110
 
 
Figure 5-6. 
Linking shafts with pulleys and a band 
 
se pulley slippage to your advantage. If part of your robot should have a limited range of motion, 
hat this band does not slip, in general. Its motion is geared down so far 
Grabber Arm 
 
Minerva's grabber arm is operated by a single motor. If you run the motor in one direction, the arm lowers, the grabber grabs, 
and the arm rises again. Run the motor in the opposite direction and the arm lowers, the grabber relaxes, and the arm rises once 
again. This mechanical sorcery is based on the FetchBot, created by Ben Williamson (see the "Online Resources" section for 
details). A cutaway view of the arm is shown in Figure 5-7. 
 
The entire arm is controlled by the main drive shaft. A motor linked to a worm gear drives the 40t gear on the main drive shaft. 
On the other hand, you can u
like a trap door that opens and closes, a pulley can be very useful. You can run the motor for longer than it actually takes to 
open or close the door—when the door has gone as far as it can go, the pulley band will simply slip. 
 
In the final design, a pair of pulleys is used to link the arm motor to the arm worm gear shaft. You can see this arrangement on 
he top of Minerva—just look for the white band. Note t
t
that the arm is likely to break apart before the pulley starts to slip. 
 
Mechanical Design 
 
Several thorny mechanical issues complicate the design and construction of Minerva. In this section, I'll talk about some of 
Minerva's more interesting mechanical features. 
 

 
111
 
 
Figure 5-7. 
Cutaway view of the grabber arm 
 
he key to understanding how the arm works is that it moves up and down for two separate reasons: 
. When the grabber grips something, the geartrain that controls the grabber locks up. When the main drive shaft continues 
oves the entire arm up and down. 
rtrain becomes stationary with respect to the arm. The main drive shaft keeps rotating, 
raising the entire arm with the closed grabber. 
 
A single touch sensor can be used to detect when the arm is fully raised, either with the gripper open or the gripper closed. 
Picking up an object is simply a matter of running the motor in the right direction and waiting for the touch sensor to be 
pressed. Releasing an object is just as simple. 
 
The "fingers" of the gripper need to pick up objects. Ideally, they should be slightly pliable and tacky rather than smooth. 
Minerva uses two of the rubber wheels as fingers, which work reasonably well. 
T
 
1. The cams on the lower shaft push the arm up and let it move back down. 
 
2
turning, it m
 
Suppose Minerva begins with her arm raised and the grabber open. When the main drive shaft starts turning counterclockwise, 
the lower shaft turns clockwise. The cams rotate down, allowing the arm to lower. (At the same time, the rotation of the main 
shaft closes the grabber a little bit.) As the main drive shaft continues turning, the grabber closes. When it is fully closed, either 
on an object or itself, the grabber gea

 
112
The arm also needs to be strong, as its parts are under a fair amount of stress. You may notice, as you use Minerva, that the 
ieces of the arm loosen up after time. You could make the arm stronger, but it would also be bulkier. See Ben Williamson's 
s is balance. The grabber arm sticks out in front of Minerva. Without some kind of 
unterbalance, Minerva falls right on her face. One way to fix this is to move the drive wheels closer to the front of Minerva. 
ver, the directional transmission and the grabber arm gearing would not have enough space to coexist. 
inerva solves the problem of balance by mounting the RCX near the back of the robot. The weight of the RCX (the batteries, 
imple, Minerva's drivetrain is a little more complex. When the motor runs 
ne way, the two drive wheels both turn forward. When the motor runs the other way, the drive wheels turn in opposite 
 correct wheel movements. Only one of the outputs drives a wheel directly. 
 Input 
 
ne way to move beyond the three-input barrier: attaching more than one sensor to a single input. Minerva, for example, has a 
here are two common variations on the theme of attaching multiple sensors to one input, both of which are discussed here. 
he first and easiest possibility is to attach multiple touch sensors to a single input. With the input configured for a touch 
p
FetchBot (in the "Online Resources" section) for the original arm design, which is stronger and larger than Minerva's. 
 
Balance 
 
One of the fundamental issues Minerva face
co
In this case, howe
M
mostly) more than compensates for the weight of the grabber arm. 
 
Drivetrain 
 
Although the directional transmission is relatively s
o
directions, causing Minerva to spin in place. Minerva uses a fairly complex system of gears to translate the outputs of the 
directional transmission into the
 
Two Sensors, One
 
You might think that the RCX's three inputs limit you to designing robots with only three sensors. In this section, I'll describe
o
touch sensor and a light sensor attached to a single input. If you have ambitious plans (and parts) for expanding Minerva, 
you've got two inputs, not just one, with which to play. 
 
T
 
Multiple Touch Sensors 
 
T
sensor, a press on any one of the attached sensors will produce a value of 1 on the input. 

 
113
This might be useful, for example, in a robot with a "skirt" touch sensor that runs around the entire robot. Different parts of the 
irt might trigger different touch sensors. By putting all the skirt sensors on one input, you could easily detect any collision 
ight and Touch 
inerva uses a light sensor and a touch sensor on one input. The input is configured for a light sensor. When the touch sensor 
ect on the light sensor reading. When the touch sensor is pressed, the input gives a value of 100; the 
urrent value of the light sensor becomes irrelevant. 
 
nditions around the sensor. You'll rarely see a real light sensor reading of 100 unless you point some very bright light 
. In general, it's safe to assume that readings of 100 correspond to the touch sensor being pressed. 
 the two sensors being attached to one input. In particular, the touch sensor must normally 
ay briefly so the touch sensor is no longer 
ressed. This allows Minerva to observe values from the light sensor. 
here Am I? 
 
Timing 
 
Minerva uses a fairly unreliable technique, called timing, to determine her current position. She moves forward for some 
amount of time until she finds something to pick up. Then she turns around by spinning in place for a length of time defined in 
TURNAROUND_TIME. Then she drives back to her starting point by moving forward for as much time as she moved forward 
before. If Minerva drives forward for 
sk
with the skirt, anywhere around the robot. 
 
The downside, of course, is that you don't know which touch sensor is being pressed. There's a way around this problem, of 
course, but it involves using a soldering iron. I'll explain how it works in Chapter 11, Make Your Own Sensors. 
 
L
 
M
is not pressed, it has no eff
c
 
Usually the light sensor shows values in the range of 30 to 70, roughly speaking; the readings depend on the lighting
co
directly into the sensor
 
Minerva's program must account for
be not pressed. In the grab() and release() subroutines, for example, the grabber arm motor is run forward or in 
reverse until the touch sensor is triggered. Then the motor must be run the other w
p
 
W
 
You've probably discovered that Minerva gets lost easily. If she drives over anything, or if her wheels slip in any way, she can't 
find her way back to her starting point. Minerva, basically, is trying to answer the question "Where am I?" Unfortunately, she 
can't answer it very well. 

 
114
five seconds, she assumes she can reach her starting point by turning around and driving forward for five seconds again. 
iming is not a very accurate technique. Variations in battery power, the material Minerva is driving on, and other 
npredictable factors will mess things up. Turning around, in particular, is not very reliable: Minerva almost never heads back 
 she came. Minerva's directional transmission makes things more complicated, as well, because it takes a 
ttle time for the transmission to shift from one direction to the other. This affects the timing of Minerva's forward motion, as 
orded. 
a should have some feedback about how far she's traveled and how far she's turned. You could, for example, 
on sensors and attach them to inputs 1 and 2. If you put the rotation sensors on Minerva's two main wheels, you 
ould know exactly how many times, and in what direction, each wheel had turned. By assuming that the wheels didn't slip on 
d get a very accurate idea of where Minerva was, relative to her starting position. You wouldn't have to 
orry about the directional transmission any more. 
ected terrain like driving over blocks would likely throw this method of navigation off as well. 
till, it's a step up from timing. 
avigation Tools 
ral generic navigation tools that you might consider attaching to your RCX to answer the question of location: 
ass would give a good indication of what direction Minerva was pointing. Feedback from the compass 
ading would allow Minerva to turn around with much better accuracy. The interface between the compass and Minerva's 
rtunately, garden variety GPS is only accurate to 100 
't get accurate enough information 
 
T
u
precisely the way
li
the shifting time is also rec
 
Rotation Sensors 
 
Ideally, Minerv
buy some rotati
w
the ground, you coul
w
 
Wheels do slip, sadly, so unexp
S
 
N
 
here are seve
T
 
1. A magnetic comp
re
inputs, of course, is entirely up to you and would probably require a bit of electronics hacking. 
 
2. Triangulation is a commonly used navigation technique. Suppose you mounted three radio transmitters around the area 
where Minerva was going to drive. By listening to the three signals, Minerva could determine her position relative to the radio 
transmitters. Again, this is pretty high-tech, serious electronics.∗ 
 
 An obvious choice might be the Global Positioning System (GPS). Unfo
∗
m or so. Unless you're the US military, or willing to spend some serious money, you won
om GPS to help your robot navigate. 
fr

 
115
Why Should I Care? 
 
Before you tear your hair out tr
S n
 to your RCX, think about what you're trying to do. Do you really 
eed to know precisely where the robot is? Using precise positioning and having the robot build a map of its world are both 
rti
 mobile robotics. The RCX is not very powerful. If you just 
ant to avoid table legs and walls, build a bumper and back up when you hit something. After all, you probably won't be able 
ramming environment you use. 
ying to get a GP  u it to talk
n
techniques of the big-metal a
ficial intelligence (AI) approach to
w
to build a map of the world in your RCX, no matter what prog
 
Online Resources 
 
Directional Transmission 
 
http://www.sonic.net/~rci/transmission.htm
This page, created by Michael Powell, describes the basic principle of the directional transmission with detailed photographs. 
 
Ben's Lego Creations 
 
http://www.pobox.com/~benw/lego/
This page contains some fascinating robots created by Ben Williamson. A modified version of Ben's FetchBot arm was used as 
Minerva's grabber arm. These robots are mechanically superlative; check them out. 
 
"Where am I?"—Systems and Methods for Mobile Robot Positioning 
 
http://www-personal.engin.umich.edu/~johannb/position.htm
Johann Borenstein's book about mobile robot navigation can be downloaded from this site as an Adobe Acrobat PDF file. The 
whole book is 13 Mb, which is a little hefty for my dial-up Internet connection, but a free book is a free book. It's gotten good 
reviews from the MINDSTORMS online community. 

 
116
6 
pbFORTH 
 
 
On
he limitations of RCX Code, the 
rogramming environment that comes with RIS. Even NQC, however, has its limitations. Even though you finally have the use 
 the memory, display, and other resources in the RCX. pbFORTH allows you to program your robots using Forth, an 
established language that is suitable for small systems like the RCX. 
 
This chapter will get you up and running with pbFORTH by covering the following topics: 
 
• An overview of the pbFORTH software architecture 
 
• Obtaining and installing pbFORTH 
 
• A brief description of Forth 
 
• Listings of RCX-specific words defined in pbFORTH 
 
• Example programs 
 
Replacement Firmware 
 
Later, in Chapter 10, legOS, I'll talk about another popular programming environment. legOS and pbFORTH are both 
replacement firmware, which means they actually replace the software on the RCX. This is the next level of power and 
complexity beyond NQC. If you're considering this move, which should you choose? It all depends, of course, on what you're 
trying to do and what programming you've already done. Table 6-1 compares pbFORTH and legOS in several important areas. 
 
In this chapter: 
 
• Replacement Firmware 
 
 
• pbFORTH Overview
 
 
 About Forth 
•
 
 
• pbFORTH Words 
 
 
• An Expensive Thermometer 
 
 
• Minerva Revisited 
 
 
• Debugging 
 
 
line Resources 
• 
 
 
In Chapter 4, Not Quite C, I described how NQC allows you to get around many of t
p
of variables, you're limited to 31 of them. Furthermore, you can't put your own data on the display, which would be very useful 
for debugging. In this chapter, I'll talk about pbFORTH (Programmable Brick Forth), a piece of software that gives greater 
access to

 
117
Table 6-1. pbFORTH and legOS Compared, Briefy 
 
pbFORTH   
 
legOS 
rogramming language   
Forth   
 
 
 
C or C++ 
teractive?   
 
 
 
 
Yes   
 
 
 
No 
rogramming tool   
 
 
Terminal emulator  C compiler, either gcc or egcs 
pment environment, pbFORTH excels in two areas: 
 
Ther
certain amount of pain, the startup cost, associated with learning and using a new development environment. For 
bFOR
his startup cost is low. The software tools you'll need on the PC side are simple and commonly available. Compare 
erminal emulator or some other simple software that talks to the RCX's IR port. You can 
teract
RTH from a Windows terminal emulator, a Java application running on Linux, or even a custom-developed 
pli
mPilot. 
 
development cycle 
RTH, this sequence of 
ps is farily short. Basically, yo
r type your program into pbFORTH via a terminal emulator running on your PC. 
y available to run. With legOS, you need to compile the program on your PC and download the 
, which takes a couple of minutes. 
ftware, but there are only a few good tools for working with it. As of this writing, 
terminal sessions to program your RCX with pbFORTH. 
C, it's not NQC that limits your robot programs; 
QC just reflects the limitations of the RCX firmware. Remember, NQC is a replacement for software on the PC only. It 
 have to replace the RCX 
mware itself. Figure 6-1 shows a block diagram, similar to Figure 4-1, that shows how pbFORTH replaces the RCX's 
w
 
P
 
In
 
Development OS  
 
 
 
Any   
 
 
 
Unix, Linux, or similar 
 
P
 
As a develo
 
startup cost
e's a 
TH, t
p
this with legOS, which requires some heavy-duty development tools that can be tricky to install and configure. pbFORTH is 
very openended; all you need is a t
in
ap
 with pbFO
cation on a Pal
A development cycle is the sequence of steps you need to follow to write and run a program. With pbFO
u upload o
ste
The program is immediatel
e thing to the RCX
whol
 
However, before you get all fired up about pbFORTH, remember some caution is in order. pbFORTH itself works well, 
especially considering it's relatively new so
you will have to put up with ugly-looking 
 
bFORTH Overview 
p
 
Although I'm describing pbFORTH as a way around the limitations of NQ
N
generates bytecodes, just like RCX Code, that are downloaded and interpreted on the RCX itself. NQC's limitations are the 
result of the limitations of the bytecode interpreter on the RCX. To break through this barrier, you
fir
firm are. 

 
118
 
 
Figure 6-1. 
pbFORTH software architecture 
 
orth is an interpreted language, which
F
Y
 means you can type commands to pbFORTH and have the robot respond immediately. 
ou don't have to compile and download programs; you simply type them directly to the interpreter. 
 
Installing pbFORTH 
 
Installing pbFORTH is a simple process: 
 
1. Obtain pbFORTH from http://www.hempeldesigngroup.com/lego/pbFORTH/ . It's available as an archive that contains the 
pbFORTH replacement firmware, the source code, and example scripts. 
 
2. Install pbFORTH on the RCX. To do this, you'll need a firmware downloader. The firmware downloader is a piece of 
software that knows how to transmit firmware over the IR link to the RCX. Two freely available firmware downloaders are 
nqc (described in Chapter 4) and firmdl, available in C source code at http://graphics.stanford.edu/~kekoa/rcx/tools.html 
.Downloading firmware to the RCX takes a couple of minutes, so be prepared to wait. 
 
To download pbFORTH using nqc, for example, you use the -firmware option, like this: 
 
nqc -firmware pbforth.srec 
 
When the download is complete, your RCX's screen will go entirely blank. Although the RCX looks dead, don't be fooled. 
pbFORTH is running, and you will be able to talk to it as 
the next section. 
 
pbFORTH will remain running on your RCX as long as the batteries are good. It replaces the regular MINDSTORMS 
hout reinstalling the regular firmware. To 
remove 
described in 
firmware entirely, so you won't be able to program with RCX Code or NQC wit

 
119
pbFORTH from your RCX, you'll need to remove the batteries to clear the memory. Then you can use nqc or firmdl to 
download a different set of firmware. If you want to reinstall the default firmware, you can use the RIS software. 
indows users can use the HyperTerminal application that comes with Windows. Linux users can use minicom or 
imilar. You'll need to point your emulator at whatever serial port has the IR tower attached. The other relevant 
ttings are 2400 Baud, 8 data bits, 1 stop bit, and no parity. 
 
To g
uick start with pbFORTH, let's turn on one of the outputs. First, you'll need to initialize the RCX like this (the stuff 
you 
 type is shown in bold): 
 
To tu
output, use the MOTOR_SET command, which will be covered later. Type the following: 
 2 0 MOTOR_SET 
m
 Return after you enter the whole line. Depending on your terminal settings, you will see the letters you 
type 
es in a row, like this: 
 
77 22 00 MMOOTTOORR__SSEETT 
 
I have rem
d the extra letters in the examples in this chapter, for clarity. To minimize the repeated characters as you type in 
e e
e sure "local echo" is disabled in your terminal emulator. 
se (represented by 2) with full power 
CX is about to drive off your desk, you can turn off the output like this: 
 
Talking to pbFORTH 
 
To interact with pbFORTH, you need to use a terminal emulator to exchange data with the RCX over the IR link. 
 
W
something s
se
 
Once you've got your emulator running, press Enter on your keyboard a couple of times. pbFORTH should respond with ''ok" 
messages: 
 
ok 
k 
o
et a q
should
RCX_INIT 
Ok 
 
rn on an 
 
7
ok 
 
Re ember to press
two or three tim
ove
xamples, mak
th
 
The MOTOR_SET line turns on output A (represented in the code by 0) in rever
(represented by 7). If your R
 
7 3 0 MOTOR_SET 
ok 

 
120
This is the same as the previous example, except the 2 is now a 3. The 3 tells pbFORTH to turn the output off. I'll get to the 
details of MOTOR_SET later, after I've introduced you to the Forth language itself. 
separate everything with spaces. pbFORTH reads different words by assuming that they're all separated by 
hitespace, either spaces or returns. If you miss a space, pbFORTH wil
d and complain that it can't find a word 
FORTH is also case sensitive. While MOTOR_SET is a defined word, Motor_Set is not, nor is motor_set or  
MOTOR_SEt. 
 
Send
es 
 
For s
ent, you'll want to create your source code in a text file and send the whole file to pbFORTH when you're 
eady
an do this with many terminal emulators, although you have to set it up correctly. 
in Figure 6-2. 
 
Make sure you 
w
l get confuse
definition. 
 
pb
ing Fil
erious developm
 to test. You c
r
 
First, the terminal emulator needs to know how long to wait after sending each character. In HyperTerminal (in Windows 95, 
98, or NT), this setting is available in the File > Properties menu option. In the window that appears, choose the Settings tab 
and press the ASCII Setup button. You should set the Line delay to 100 milliseconds and the Character delay to 20 
milliseconds, as shown 
 
 
Figure 6-2. 
Setting character delays for sending files 
 
To u
e to pbFORTH, choose Transfer → Send Text File from the menu. 
pload a fil

 
121
There are other options, as well. Appendix B, A pbFORTH Downloader, contains source code for a Java-based program 
downloader. Furthermore, the pbFORTH web site has pbFORTH tools written in Tcl/Tk. 
 
Abo
 
In th
 I'll briefly describe the Forth language itself. Then I'll detail pbFORTH's RCX-specific words and present some 
ve the top item. Adding an 
item
e stack is a push. Retrieving the top item is a pop. A pop always returns the last item that was pushed. 
 
Assu
 this works. Let's begin by pushing a number 
on th
onds with a friendly "ok": 
77 
 single period and press return. The period pops a value off the stack and prints it out to the console, along with that 
u 
separating them with spaces. Similarly, you can pop more than one value off the 
stack
If yo
you know almost everything there is to know about Forth. 
e 
 is simply a list of words and what they mean. A word is a simply a 
prog
ut Forth 
is section,
short examples of robotic programming with pbFORTH. 
 
The Stack 
 
Forth is a simple but powerful language. It is based around the idea of a stack. A stack is just what it sounds like, like a stack of 
trays in one of those spring-loaded carts at a cafeteria. You can add something to the stack or remo
 to th
ming 
ready gotten pbFORTH running on your RCX, let's see how
you've al
e stack. Type a number into your terminal emulator and hit return. pbFORTH resp
 
ok 
 
ow type a
N
ubiquitous "ok": 
 
. 
77 ok 
 
Yo can push multiple values on the stack by 
 more than one period, like this: 
 with
 
77 12 55 
ok 
. . 
55 12 ok 
. 
77 ok 
 
u understand the stack, 
 
Words and the Dictionary 
 
Th other important concept in Forth is the dictionary. This
ith a name. To run it, 
ram w

 
122
you just type its name. Many programs expect to find input values on the stack and may place their results on the stack when
they're done. 
 
ilt-in words 
Forth
 the dictionary. DUP, for example, duplicates the top element of the 
stack
ee how this works: 
 
77 77 ok 
able 6-2 lists some of the important built-in words in Forth. The table shows the stack before ("Initial Stack") and after 
 
Tabl
ds 
 
Wor
 
Mean
 
 
 
 
 
 
 
 
Initial Stack   
 
Ending Stack 
P
 on the stack   
 
x    
 
 
 
x x 
 
VE
Copies the second stack item   
 
 
 
x1 x2   
 
 
x1 x2 x1 
 
SWA
e top two stack items   
 
 
x1 x2   
 
 
x2 x1 
 
 
x2 x3 x1 
DRO
rds the top item on the stack   
 
 
x 
 
 the stack and leave their result at the top of 
 
You can change the number base you're working in using the HEX and DECIMAL words. For example, if you wanted to work 
in hexidecimal (base 16), you would type HEX. Base 10 is represented by DECIMAL. Most of the numbers in this chapter will 
be base 16. 
 
Bu
 
 has a number o
. You can easily s
f simple words that are built in to
77 
ok 
DUP 
ok 
. . 
 
T
("Ending Stack") the word runs. By convention, the top is shown on the right. For example, x1 x2 shows a stack with x2 at 
the top and x1 as the second item. This seems confusing at first, but it makes sense after a while (and it's the convention in 
Forth documentation). 
e 6-2. Forth Built-in Wor
d  
ing   
 
 
DU    
Duplicates the top item
O
 
R  
PICK  Copies the nth stack item (n is zero-based)  … n   
 
 
 
… xn 
P  Switches th
 
OT   
Moves the third stack item to the top   
 
x1 x2 x3  
R
 
P  Disca
Forth also supports mathematical operators, which operate on the top two items of
the st
k. For example, you can divide two numbers like this: 
ac
84 2 / 
ok 
. 
42 ok 
 
Bitwise operators are also defined: AND, OR, XOR. 
 

 
123
BASE is a word (a variable, which I'll talk about soon) that contains the current number base. To print out the current number 
ase, for example, do this: 
10 ok 
 the current base with 
SE @ 
 seem like a 
ointless exercise, but it's useful if you want to save the current base away to be restored at some later time. 
 you want to work in a number system other than HEX or DECIMAL, you can use BASE ! to store any base number. The 
hows two ways you can use Forth to convert numbers between different bases: 
 
32 ok 
16 ok 
arenthesis ( is used to indicate a comment. The pbFORTH interpreter simply ignores the rest of the line after it 
es the (. 
ing words 
ng programs in Forth is a matter of defining your own words in the dictionary. Word definitions begin with a colon and 
 
The 
ter that the words that follow define a new word for the dictionary and should be stored to run 
later
e, threeTimes in this example, which is supplied immediately after the colon. Subsequent 
word
d when the new word is executed. The semicolon tells the interpreter that the new word definition has 
ende
Times duplicates the top item on the stack twice, so there are three copies of it, then adds them all together. 
15 ok 
ons: 
b
 
BASE @ . 
 
Interestingly, the current base is printed in terms of the current base, so it will always be 10. Suppose you're working in base 8. 
If you print out the current base, 8, in base 8, it's expressed as 10. Retrieving
BA
may
p
 
If
following example s
HEX 20 DECIMAL . (20 in base 16 is 32 in base 10) 
8 BASE ! 20 DECIMAL . (20 in base 8 is 16 in base 10) 
 
The open p
se
 
efin
D
 
riti
W
end with a semicolon. Here's a simple example: 
 
: threeTimes DUP DUP + + ; 
ok 
colon tells the Forth interpre
eeds a nam
. The new word n
l be execute
s wil
d. three
Now that you've defined a new word, you can use it like any other Forth word: 
 
5 threeTimes . 
 
nd you can, of course, use it in subsequent definiti
A
 
: nineTimes threeTimes threeTimes ; 
ok 
5 nineTimes . 
45 ok 

 
124
Here's another simple example that demonstrates how to print messages from within a word. Be careful about the spacing: the 
actual string to be printe
 and 
d is framed by the .“
” words, which 
e se
Hello, world. ok 
: helloWorld ." Tag, Welt. " ; 
lloWorld ok 
You 
in Forth that represent numerical values. These words are called constants; you can use the word 
anyw
ean the number it represents. This is really handy for making programs more readable. To define a 
cons
7 CONSTANT FULL 
SET 
VARIABLE 
k 
tack with the @ word: 
t the specified address. Similarly, the @ word expects to find an 
ddr
 with the value at that address. When you declare a variable with the VARIABLE 
ord
address (determined by the Forth interpreter) to a name. 
ar
 
parate from the string. 
: helloWorld ." Hello, world. " ; 
ok 
helloWorld 
 
If you define a word that already exists, it will be redefined: 
 
redefine he
 
Constants and Variables 
 
can define words 
here you really m
tant, push its value on the stack. Then use the word CONSTANT and supply a name. like this: 
 
ok 
 
You can the use FULL anywhere you really mean 7, like this: 
 
FULL 2 0 MOTOR_
ok 
 
ariables are even easier to define. Just use the word 
and supply a name: 
V
 
VARIABLE z 
ok 
Values are stored in variables using the ! word, pronounced "store": 
 
12 z ! 
o
 
he value of a variable can be retrieved and placed on the s
T
 
z @ . 
12 ok 
 
There's some tricky stuff going on here that I'll briefly discuss. A variable is really an address in memory. The ! word expects 
o find an address and a value on the stack; it stores the value a
t
a
ess on the stack. It replaces the address
, all you're really doing is assigning an 
w

 
125
Conditionals and Loops 
 
Fo
com
rth
 statement, though the order is switched around from what you might be used to. The IF word 
e
s: 
he IF word lo
e condition on
. If the condition is true, the body between IF and THEN is executed. 
hat are available. 
atical Condition Words 
top two items on the stack; replaces them with true if the second item is less than the top item, false otherwise 
em with true if they are equal, false otherwise 
e stack; replaces them with true if the second item is greater than the top item, false 
Replaces the top item of t
k with true if it is equal to zero; false otherwise 
e 
 out a message if the top item on the stack is less than 0: 
 
: negative 0< IF ." less than zero " THEN ; 
The 
 value on the stack. The result of this comparison is examined by the IF word. If it is true, the 
body
RTH to print text to the console, up until the ” word. Finally, THEN 
mark
 
Ther
 
E falseBody THEN 
ore, except words between ELSE and THEN will be executed if the condition is false. 
 
limit start DO words LOOP 
This loop performs the given words limit - start times. Internally, a loop index is given the value start. Each time 
through the loop, the index is increased by one. When it is equal to limit, the loop ends. You can put the 
 supports a standard IF
s in two different varietie
 
condition IF body THEN 
oks at th
 the stack
T
Table 6-3 lists some of the mathematical condition words t
 
Table 6-3. Mathem
 
Word Description 
 
< Compares the 
 
= Compares the top two items on the stack; replaces th
 
> Compares the top two items on th
otherwise 
 
0< Replaces the top item of the stack with true if it is less than zero; false otherwise 
 
he stac
0= 
 
Th following example prints
ok 
-2 negative 
less than zero ok 
2 negative 
ok 
 
0< word examines the top
 of the IF is executed. The .“ word tells pbFO
s the 
f the body of the IF. 
end o
e's als
lightly more complicated IF word: 
o a s
condition IF trueBody ELS
his is the same as bef
T
 
Forth also includes some simple loops, including: 

 
126
value of the loop index on the stack with the I word. For example, the following shows how to define a word that prints the 
O I . LOOP ; 
8 9 10 ok 
 
his variation on the basic DO LOOP adds the given delta value to the loop index instead of always adding one. You can 
o p 
 backwards by supplying a negative delta. 
his loop performs its body until a false condition is left on the stack. The following example waits for the View button to be 
ff we haven't covered just yet): 
ok 
ok 
 the body of this loop we push 
on the stack and duplicate it. Then we call BUTTON_GET, which retrieves the 
rre
he value of RCX_BUTTON is retrieved (with @) and 
omp
When this condition is true, the loop ends and 
BEG
his variation on BEGIN UN
, executing its body each time through the loop. 
bFORTH Words 
bFORTH includes 34 words that perform RCX-specific funct
 section, I'll describe them all for you. Each word's 
ith the starting and ending state of the stack, like this: 
 
SWAP (x1 x2 -- x2 x1) 
p of the stack is shown on the right side. If you push x1 on the 
stack, then x2 and x3, then the stack would be shown like this: x1 x2 x3. The top of the stack is x3. The MOTOR_SET 
word, for example, takes three values off the top of the stack: 
 
MOTOR_SET (power mode index --) 
 
numbers from 1 to 10. 
 
: oneToTen 11 1 D
ok 
oneToTen 
1 2 3 4 5 6 7 
limit start DO words delta +LOOP 
T
use this type of l o to count
 
BEGIN body UNTIL 
T
pressed (using some stu
 
BUTTON_INIT 
: waitForViewButton BEGIN RCX_BUTTON DUP BUTTON_GET @ 2 AND UNTIL ; 
 
In
cu
RCX_BUTTON 
nt state of the buttons into the RCX_BUTTON variable. Then t
ared to 2, which corresponds to the View button on the RCX. 
c
WaitForViewButton is done. 
 
IN body AGAIN 
T
TIL loops forever
 
p
 
ions. In this
p
name is listed along w
WORD_NAME (startStack -- endStack) 
 
For example, the SWAP word would be listed like this: 
 
 
The starting stack and ending stack are shown such that the to

 
127
After MOTOR_SET runs, the stack is empty. The first thing you need to push on the stack is power; the last thing is 
. 
7 2 0 MOTOR_SET 
 
In this case, 7 is power, 2 is mode, and 0 is index. 
 
 -
ters off the stack. The power parameter should be 1 to 7, where 7 is 
output should be turned on going forward (1) or in reverse (2), or if it 
, the motor shaft resists turning; in float mode, it turns 
index
tput A, B, or C, respectively. 
or example, to turn on output 3 in full reverse, do this: 
7 2 2 MOTOR_SET 
emember that constants can make this kind of code a lot nicer. For example: 
on
 
pbFORTH provides two words that allow you to examine which front panels are pressed. 
index
In your code, it comes out in the same order: 
 
The very first pbFORTH word initializes the RCX: 
 
RCX_INIT ( -- ) 
This word starts the input and output handlers, system timers, and performs other important initializations. After you load 
pbFORTH on the RCX, call this word before you try to do anything with the inputs, outputs, buttons, or other RCX services. 
 
utput Control 
O
 
ne word is devoted to controlling the RCX's outputs: 
O
 
OTOR_SET (power mode index - ) 
M
This word turns an output on or off. It pops three parame
ll power. The mode parameter indicates whether the 
fu
should be turned off in "brake" (3) or "float" (4) modes. In brake mode
eely. The top parameter, 
, should be 0, 1, or 2, representing ou
fr
 
F
 
 
R
 
7 CONSTANT OUT_FULL 
ok 
2 CONSTANT FORWARD 4 CONSTANT FLOAT 
ok 
2 CONSTANT OUT_3 
ok 
OUT_FULL FORWARD OUT_3 MOTOR_SET 
ok 
OUT_FULL FLOAT OUT_3 MOTOR_SET 
Ok 
 
Fr
t Panel Buttons 

 
128
BUTTON_INIT ( -- ) 
This word initializes pbFORTH's button-handling system. Make sure to call it once before you try to call BUTTON_GET. 
UTTON_GET (address -- ) 
t button state into the variable address. pbFORTH provides a variable, RCX_BUTTON, that you 
n use for this purpose. The value placed in the variable tells which buttons are pressed and is a combination (boolean OR) of 
6-4. 
un   
 
 
 
1 
iew   
 
 
 
2 
rgm   
 
 
 
4 
or example, if the Run and Prgm buttons are pressed simultaneously, the flags returned from BUTTON_GET will be 5. 
ere's a word definition that retrieves the button state and places it on the top of the stack: 
: buttonState RCX_BUTTON DUP BUTTON_GET @ ; 
uilding on this, here's a handy word definition that tests if the Run button is pressed: 
: isRunButtonPressed buttonState 1 AND ; 
emember, you have to call 
before you use this word; otherwise is won't work. 
On-Off 
word, described later in this chapter. 
ws because you can display the results of your 
lay can be controlled individually; this includes the 
 you might never have seen otherwise), and the large 
ments lit up. 
ay numbers, or clear the entire display. For changes to 
 
B
This word places the curren
ca
the values shown in Table 
 
Table 6-4. BUTTON_GET Return Values 
 
Button Name  
 
Value 
 
R
 
V
 
P
 
F
 
H
 
 
B
 
 
R
BUTTON_INIT 
 
To test the state of the 
button, you'll need to use the POWER_GET 
 
LCD Display Words 
 
pbFORTH provides direct control of the RCX's display. This is exciting ne
programs or even intermediate values. Every segment of the LCD disp
"little man," the input and output arrows, the datalog indicators (which
numbers in the center. Figure 6-3 shows the display with most of its seg
 
pbFORTH offers words that show and hide individual segments, displ
actually take effect, however, you must call LCD_REFRESH: 

 
129
LCD_REFRESH ( -- ) 
Use this word after making changes to the display. The state of the display will not change until you call LCD_REFRESH. 
 
 
Figure 6-3. 
y a number from the stack with the following word: 
number value on the display. The decimal parameter controls the location of the decimal point, if 
signed parameter determines whether value is shown as signed or unsigned. The acceptable values 
 
Description 
 
No decimal point 
Three digits after the decimal point 
signed
d Parameter of LCD_NUMBER 
n 
  
 
 
Description 
  
 
 
 
 
 
Signed, no leading zeros 
  
 
 
 
Unsigned with leading zeros 
  
 
Single digit on the right of the display (ignores decimal) 
ber -4198, use the following: 
3002 -1066 3001 LCD_NUMBER LCD_REFRESH 
The RCX's display 
 
pbFORTH can displa
 
CD_NUMBER (decimal value signed -- ) 
L
This word shows the 
here is one, while the 
t
of decimal and signed are shown in Table 6-5 and Table 6-6. 
 
Table 6-5. Values for the decimal Parameter of LCD_NUMBER 
 
Value (in hexadecimal)  
 
 
3002   
 
 
 
 
 
 
 
3003   
 
 
 
 
 
 
 
One digit after the decimal point 
 
3004   
 
 
 
 
 
 
 
Two digits after the decimal point 
 
3005   
 
 
 
 
 
 
 
 
any value   
 
 
 
 
 
 
Single digit on the right of the display (use 3017 for 
) 
 
Table 6-6. Values for the signe
 
Value (i
hexadecimal)
 
3001
 
 
 
 
301F  
 
 
 
 
 
3017
 
 
 
 
 
 
 
 
For example, to display the num
 

 
130
Note that we've specified the value in hexadecimal (-1066) but the display always shows decimal (-4198). 
 hide individual display segments, basically everything except the numbers: 
O
- ) 
_
D
) 
hese words show or hide the given display segment. Valid values are shown in Table 6-7. The values that are flagged as a 
 called to update the display automatically. For example, the datalog indicator (3018) consists of 
ur quarters of a circle. The first time you show 3018, you'll see one quarter. Show 3018 again, and a second quarter lights up. 
ird quarter lights up, the fourth quarter lights up, and then all the quarters go blank and the 
able 6-7. LCD Segment Numbers 
egment Number (Hex) 
 
Sequence?   
Description 
006   
 
 
 
 
 
 
no   
 
 
 
Standing figure 
007   
 
 
 
 
 
 
no   
 
 
 
Walking figure 
008   
 
 
 
 
 
 
no   
 
 
 
Input 1 selected 
009   
 
 
 
 
 
 
no   
 
 
 
Input 1 active 
00A   
 
 
 
 
 
 
no   
 
 
 
Input 2 selected 
00B   
 
 
 
 
 
 
no   
 
 
 
Input 2 active 
00C  
 
 
 
 
 
 
no   
 
 
 
Input 3 selected 
00D   
 
 
 
 
 
 
no   
 
 
 
Input 3 active 
00E   
 
 
 
 
 
 
no   
 
 
 
Output A selected 
0F
   
 
 
 
Output A backward 
3010 
   
 
 
 
Output A forward 
 
3011
 
 
 
Output B selected 
 
3012 
 
 
 
Output B backward 
 
3013
 
 
Output B forward 
 
3014   
 
 
 
 
 
 
no   
 
 
 
Output C selected 
 
 
no   
 
 
 
Output C backward 
018   
 
 
 
 
 
 
yes (4)  
 
 
Datalog indicator segments 
301A   
 
 
 
 
 
 
yes (5)  
 
 
Data transfer segments (descending) 
 
301B   
 
 
 
 
 
 
no   
 
 
 
Low battery indicator 
 
301C   
 
 
 
 
 
 
no   
 
 
 
Short range download indicator 
 
(table continued on next page) 
 
pbFORTH provides two words that show or
 
LCD_SH W (segment -
 
LCD HI E (segment -- 
T
sequence can be repeatedly
fo
Do this three more times, and the th
sequence begins again. 
 
T
 
S
 
3
 
3
 
3
 
3
 
3
 
3
 
3
 
3
 
3
 
30
 
   
 
 
 
 
 
 
no
 
no
 
 
 
  
 
 
   
 
 
 
 
 
 
no   
 
 
 
  
 
 
 
no   
   
 
 
 
 
 
 
no   
 
 
3015  
 
 
  
 
 
3016   
 
 
 
 
 
 
no   
 
 
 
Output C forward 
 
3
 
3019   
 
 
 
 
 
 
yes (5)  
 
 
Data transfer segments (ascending) 
 

 
131
(table continued from previous page) 
 
Table 6-7. LCD Segment Numbers (continued) 
egment Number (hex)  
 
Sequence?   
Description 
020   
 
 
 
 
 
 
no   
 
 
 
All segment (LCD_SHOW only) 
is 
pu
efore you configure inputs or read values from them, you should initialize p
t system with the following word: 
ENSOR_INIT ( -- ) 
TH's input system. Call it once before working with inputs. 
 remember that the RCX's inputs may be powered. The light sensor, for example, is powered from an input. 
hese types of sensors are called active, all others are passive. In pbFORTH, the following words determine whether an input 
dex -- ) 
) 
) or passive. The index value should be 0, 1, or 2, 
orresponding to input 1, 2 or 3. 
his word sets the type of an input, which describes the electrical characteristics of the sensor you. plan to attach. The values 
As before, index should be 0, 1, or 2. 
able 6-8. Input Type Values 
 
0   
 
Raw 
 
1   
 
Touch senso 
 
2   
 
Temperature sensor 
 
(table continued on next page) 
 
S
 
301D   
 
 
 
 
 
 
no   
 
 
 
Long range download indicator 
 
3
 
Conveniently, you can clear the entire display with a single word: 
 
LCD_CLEAR ( -- ) 
Th
 
word clears the RCX's display so that no segments are lit. 
t Control Words 
In
 
bFORTH's inpu
B
 
S
This word initializes pbFOR
 
Configuring inputs 
 
You probably
T
is active or passive: 
 
SENSOR_ACTIVE (in
 
SENSOR_PASSIVE (index -- 
These words set the input described by index to be active (powered
c
 
You can configure an input for a particular type and mode, just as in NQC: 
 
SENSOR_TYPE (type index -- ) 
T
for type are shown in Table 6-8. 
 
T
 
Value   
Description 

 
132
(table continued from previous page) 
or 
   
 
Rotation sensor 
lean, either 1 or 0 
dge counting) 
 1 to 0 (pulse counting) 
  
 
0   
 
 
 
temperature 
0   
 
 
 
 
Shaft angle, 16 counts per full revolution 
ld configure input 3 for a light sensor: 
 
SENSOR_INIT 
Reading input values in pbFORTH is a two-step process. First, you need to tell pbFORTH to go and read the input values: 
SENSOR_READ (index -- code) 
 
This word tells pbFORTH to read the value of the specified input. The actual value can be retrieved with a call to  
SENSOR_GET, which is described later. A status code is placed on the stack. If code is 0, then the read was successful. 
Values other than 0 indicate that the RCX was busy and could not read the input value. 
 
Table 6-8. Input Type Values (continued) 
 
Value   
Description 
 
3   
 
Light sens
 
4
 
SENSOR_MODE (mode index -- ) 
This word sets the mode of the given input. An input's mode determines how the sensor values will be interpreted. The modes 
are shown in Table 6-9. 
 
Table 6-9. Input Mode Values 
 
Value (hex)  
 
Description 
 
0   
 
 
 
 
Raw sensor value from 0 to 1023 
 
20   
 
 
 
 
Boo
 
40   
 
 
 
 
Counts transitions from 1 to 0 and vice versa (e
 
60   
 
 
 
 
Counts transitions from
 
80   
 
 
 
 
Percent from 0 to 100 
 
A0
 
 
 
 
Celsius temperature 
C
 
Fahrenheit 
 
E
 
The following example shows how you cou
 
2 CONSTANT INPUT_3
ok 
ok 
INPUT_3 SENSOR_ACTIVE 
ok 
3 INPUT_3 SENSOR_TYPE 
ok 
80 INPUT_3 SENSOR_MODE 
ok 
 
Reading input values 
 

 
133
Having read an input value, you are now ready to retrieve it using one of the following words: 
his word returns the value of the given input. The range of the returned value is determined by the mode of the input. 
ENSOR_RAW (index--value) 
nput described by index. The raw value will always be in the range from 0 to 
023. 
ENSOR_BOOL (index--value) 
e given input as a Forth-style boolean. 
p
 r
his: 
 
Strict
 
inally, the curren
 input can be reset with the following word: 
 0 using SENSOR_CLEAR. 
dex on the stack. 
here are also 10 timers with a hundredth-second resolution. These timers have an index from 0 to 9; they count down instead 
timer
This word places the current value of the timer described by index on the stack. 
 
SENSOR_VALUE (index--value) 
T
 
S
Use this word to obtain the raw value of the i
1
 
S
This word returns the current value of th
 
For exam le, to ead the value of the sensor on input 3, you would do t
 
: read 2 SENSOR_READ 2 SENSOR_VALUE . ; 
ly speaking, of course, you should really check the return code from SENSOR_READ to make sure it was successful. 
t value of an
F
 
SENSOR_CLEAR (index--) 
Some of the input modes count values, like the edge counting, pulse counting, and rotation modes. For these modes, the current 
count of an input can be reset to
 
RCX Timers 
 
The RCX has 14 timers that you can use in your programs. Four of these timers count in tenth-of-a-second intervals. Each of 
these timers is identified by an index, from 0 to 3. The timers count up once every tenth of a second and have values from 0 to 
7FFF (hexadecimal): 
 
TIMER_SET (value index--) 
This word sets the timer described by index to the supplied value. 
 
TIMER_GET (index--value) 
This word places the current value of the timer described by in
T
of up and stop when they reach 0: 
 
timer_SET (value index--) 
This word sets the timer described by index to the supplied value. 
 
_GET (index--value) 

 
134
Pow
 
pbFO
tually turn off 
mpletely; it just goes into a low
ption mode until you press the On-Off button to turn it on. This is exactly the 
me
FORTH are related to power: 
 
POW
This 
 
OWER_OFF (--) 
mode; you should probably do this if you're going to stop using 
FORTH for a 
 overnight. 
POW
 
This
epending on the value of code. The result is placed in the variable represented by address. 
pbFO
ER variable for use with this word. The possibilities are shown in Table 6–10. 
de (hex)   
Value 
000
s not pressed 
 
4001
 
The 
 
 
Soun
 
Fina
 arbitrary 
notes
 
SOU
his
Soun
 
0   
 
 
1   
 
 
 
 
Two medium beeps 
 
(table continued on next page) 
er Management 
RTH includes a simple power management scheme that allows you to turn the unit off. It doesn't ac
 power consum
co
sa
 behavior as with the default RCX firmware. Three words in pb
ER_INIT (--) 
ord initializes pbFORTH's power management. 
w
P
Use this word to turn the RCX off. Note that this does not clear the display, turn off active inputs, or turn off running outputs. 
It does, however, put the interpreter in a kind of sleep 
while, say
pb
 
ER_GET (address code--)
 word serves two purposes, d
RTH provides the RCX_POW
 
Table 6-10. POWER_GET Code and Value Possibilities 
 
Co
 
4
   
 
 
On-Off button state: 0 is pressed, 2 i
   
 
 
Current battery level 
llowing example shows how to print out the current battery level: 
fo
RCX_POWER DUP 4001 POWER_GET @ . 
11E ok 
ds 
, pbFORTH can play the built-in beep sounds of the RCX, although it does not offer the possibility of playing
lly
. The two words related to sound are: 
ND_PLAY (sound code--) 
 word plays the sound described by the sound parameter, which can have the values shown in Table 6-11. 
T
 
able 6-11. SOUND_PLAY Sounds 
T
 
d Number   
Description 
 
 
 
 
Short beep

 
135
(table continued from previous page) 
 
Table 6-11. SOUND_PLAY Sounds (continued) 
escending arpeggio 
  
 
 
Ascending arpeggio 
 
4   
 
5   
 
 
 
Quick ascending arpeggio (same as 3 but faster) 
 
ueued. Unqueued sounds will be played right away if no sound is currently 
s currently playing (i.e., the sound system is already busy), then the unqueued sound will not be 
ed at all. A queued sound, on the other hand, waits for the sound system to finish whatever it's doing and then plays. 
ed (4003) or unqueued (4004). 
 
SOUND_GET
 
This
ent state of the sound system to the given variable. You can use the pbFORTH-supplied variable 
RCX
. A zero indicates that the sound system is not busy. Any other value means that the sound system 
is bu
. 
 
Coop
 
pbFO
0.5 introduced words that support cooperative multitasking. Cooperative multitasking allows multiple 
tasks to ap
lity, each task must voluntarily yield control to the next task in line. The other kind 
of multita
C and will see again in legOS, is called preemptive multitasking. With preemptive 
multitaski
le bits of time to each task, interrupting each task to give control to the next task. Cooperative 
multitaski
gram because each task needs to explicitly yield control to the other tasks. If your robot has 
a task that
cessing, the task needs to be structured so that it can yield control frequently. 
 
The 
eb page has more information on cooperative multitasking. Take a look at the tortask.txt example, which is a 
good
n of the use of multiple tasks in pbFORTH. 
 
llocate space for each task using the ALLOT_TASK word. This includes space for user variables and 
 
Sound Number   
Description 
 
2   
 
 
 
 
D
 
3 
 
 
 
 
 
 
Long low note 
 
The sounds can be either unqueued or q
playing. If a sound i
play
The value of code determines if a sound is queu
 (address --)
 curr
 word returns the
for this
_SOUND 
 word
sy playing another sound
erative Multitasking 
RTH version 1.
pear to run simultaneously. In rea
ich you've seen in NQ
sking, wh
ng, the system gives litt
ng is a little tricky to pro
 is going to do any lengthy pro
pbFORTH w
onstratio
 dem
The basic procedure for running a multitasking program has four steps: 
 
. First, you need to a
1
space for a parameter and return stack. Here's a sample from tortask.txt:  
 
0 32 CELLS 32 CELLS ALLOT_TASK MOTOR_TASK 

 
136
The CELLS word simply converts a number on the stack from cells, which are the fundamental units of Forth memory, 
to bytes. The line above allocates no space for user variables and 32 cells each for the parameter stack and return stack. 
The name of t
OTOR_TASK
three other tasks are allocated in the same way: 
ALLOT_TASK 
riable definition. 
MOTOR_TASK BUILD 
BUILD 
 UPDATE_MOTORS PAUSE AGAIN 
e task is in UPDATE_MOTORS, a word that examines some other values in the system and sets the 
 The PAUSE word is the key to cooperative multitasking-it passes control to the next task in the list. 
 with MOTOR_TASK, we need another special word, ACTIVATE: 
ACTIVATE BEGIN UPDATE_MOTORS PAUSE AGAIN ; EXECUTE 
 ACTIVATE word associates MOTOR_TASK with the rest of the NONAME definition, which is simply the endless 
loop. To link the code into the task list, the NONAME definition is executed. (The combination of 
xecute a defined word just one time. Because it doesn't have a name, you can't 
 tortast.txt example sets up its other three tasks in the same way: 
NAME TIMER_TASK ACTIVATE BEGIN UPDATE_TIMERS PAUSE AGAIN ; EXECUTE 
ENSOR_TASK ACTIVATE BEGIN UPDATE_SENSORS PAUSE AGAIN ; EXECUTE 
ASK ACTIVATE BEGIN UPDATE_DISPLAY PAUSE AGAIN ; EXECUTE 
 
4. To
is: 
 
PLAY_TASK AWAKE 
SENSOR_TASK AWAKE 
TIMER_TASK AWAKE 
MOTOR_TASK AWAKE 
he new task is M
. In tortast.txt, 
 
0 32 CELLS 32 CELLS ALLOT_TASK TIMER_TASK 
0 32 CELLS 32 CELLS ALLOT_TASK SENSOR_TASK 
0 32 CELLS 32 CELLS ALLOT_TASK DISPLAY_TASK 
 
f the new task is specified after the 
word, almost like a va
Notice how the name o
 
2. Next, each task must be built into a list. When one task voluntarily gives up control (cooperates), the next task in the list will 
get control. The BUILD word assembles tasks into a list: 
 
TIMER_TASK 
SENSOR_TASK BUILD 
DISPLAY_TASK BUILD 
 
3. Next, you need to actually define what each task does. This is done with the ACTIVATE word, which can be used only 
inside a definition. Consider, for example, the MOTOR_TASK. Basically, we want it to look like this: 
 
BEGIN
 
The real work of th
rs.
state of the moto
To associate this loop
 
:NONAME MOTOR_TASK 
 
The
BEGIN AGAIN 
and 
NONAME 
EXECUTE allows you to e
ord again later.) The
execute the defined w
 
NO
:
:NONAME S
:NONAME DISPLAY_T
 actually start the tasks running, use AWAKE, like th
DIS

 
137
To d
 little more, check out the whole tortask.txt example at the pbFORTH web site. 
 
An E
 
This section contains an example that will help you get your feet wet with pbFORTH. We'll build a simple Celsius 
therm
ensor. Hook the sensor up to input 2 and enter the following (I've omitted pbFORTH's ''ok" 
respo
 
N_GET @ ; 
sRunButtonPressed buttonState 1 AND ; 
ture 
ER 
; 
REFRESH ; 
ENSOR_INIT 
ttonPressed 
To ru
 use the thermometer word. The LCD display will show the temperature read by the sensor until you 
press
 Run button. 
 
The 
ssed word simply tests to see if Run has been pressed, using the buttonState word. This is 
how 
mperature takes the top item on the stack and shows it on the 
displ
s. The clear word simply erases the entire display using the 
LCD
ive into this a
xpensive Thermometer 
ometer using a temperature s
nses for clarity): 
HEX 
: buttonState RCX_BUTTON DUP BUTTO
 
: i
 
: showTempera
  3003 SWAP 3001 LCD_NUMB
  LCD_REFRESH 
 
: clear LCD_CLEAR LCD_
 
: thermometer 
  RCX_INIT 
  S
  BUTTON_INIT 
  2 1 SENSOR_TYPE 
  A0 1 SENSOR_MODE 
  BEGIN 
BEGIN 
1 SENSOR_READ 0= 
UNTIL 
1 SENSOR_VALUE 
showTemperature 
isRunBu
  UNTIL 
  clear 
; 
 
n this program,
 the
isRunButtonPre
thermometer knows to stop running. ShowTe
cimal point placed to show tenth
ay with the de
_CLEAR word. 

 
138
The 
m, thermometer, begins by initializing the RCX and the input and button systems. It then configures input 
1 for
ensing using the temperature type (2) and the Celsius mode (A0). 
 
The 
value from the input and shows it on the display. To 
retrie
AD. This call is inside its own BEGIN UNTIL loop that waits for 
SEN
cess. Then the actual input value is read using SENSOR_VALUE. A call to 
showTemperature puts the input value on the display. Each time through the loop we call isRunButtonPressed; if 
the b
n is pressed, we fall out of the loop. A call to clear cleans up the display, and then 
the
 done. 
 
If yo
ensor, you now have yourself a $225 digital thermometer. Chapter 11, Make Your Own 
Sens
our own temperature sensor. You could use that code to make a digital thermometer for 
only
. 
 
Min
 
To really put pbFORTH through its paces, let's rewrite Minerva's software in pbFORTH. (For a full description of this robot, 
see C
a Robot with an Arm.) As with any other language, the challenge with Forth is to break the large 
prob
 are small enough to be understood easily. Here's a set of words that will run Minerva. They are 
defin
fashion, such that the most sophisticated words are at the end. 
 
 
e 
CTIVE 
YPE 
MODE 
; 
main progra
 a temperature s
main part of temperature is a BEGIN UNTIL loop that reads a 
ve the input value we first have to call SENSOR_RE
 to return 0, indicating suc
SOR_READ
utto
rmometer is
u bought LEGO's temperature s
how you can build y
ors, shows 
ut $202
 abo
erva Revisited 
hapter 5, Minerva, 
s that
lem into piece
ed in bottomup 
HEX 
: initializ
  RCX_INIT 
T 
  SENSOR_INI
_A
  2 SENSOR
  3 2 SENSOR_T
SENSOR_
  80 2 
; 
 
: showValue 
  3002 SWAP 3001 LCD_NUMBER 
  LCD_REFRESH 
 
: sleep 
  0 0 TIMER_SET 
  BEGIN DUP 0 TIMER_GET = UNTIL 
  DROP 
; 

 
139
DECIMAL 
 
42 CONSTANT TURNAROUND_TIME 
 NUMBER_OF_SAMPLES 
IABLE threshold 
VARIABLE returnTime 
; 
MPLES 0 DO 
nsorValue + 
SET ; 
 ; 
 3 2 MOTOR_SET ; 
IN 2 sensorValue 100 = UNTIL 
: re
N 2 sensorValue 100 = UNTIL 
TIME sleep 
  stop 
; 
10 CONSTANT
 
VAR
 
: sensorValue 
  BEGIN DUP SENSOR_READ 0= UNTIL 
  SENSOR_VALUE 
 
: calibrate 
  0 
  NUMBER_OF_SA
2 se
1 sleep 
  LOOP 
  NUMBER_OF_SAMPLES / 
  threshold ! 
  threshold @ showValue 
; 
 
: forward 7 1 2 MOTOR_
7 2 2 MOTOR_SET
: spin 
stop 7
: 
 
: armGrab 7 1 0 MOTOR_SET ; 
: armRelease 7 2 0 MOTOR_SET ; 
: armStop 7 3 0 MOTOR_SET ; 
 
: grab 
mGrab 
  ar
  BEG
  armRelease 
  BEGIN 2 sensorValue 100 < UNTIL 
  armStop 
; 
 
lease 
  armRelease 
 BEGI
 
  armGrab 
  BEGIN 2 sensorValue 100 < UNTIL 
  armStop 
; 
 
: turnAround 
  spin 
  TURNAROUND_

 
140
: seek 
  forward 
  BEGIN 2 sensorValue threshold @ 3 - < UNTIL 
  stop 
 
  forward 
  ca
  5 
    
  LO
 
The pbFO
entation of Minerva's program closely resembles the NQC version of the program presented in Chapter 
5. By
e more complex words are simply combinations of the earlier ones. Keep 
this i
rogram starting at the end and returning to the beginning. 
 
The main 
nerva, pretty much describes itself. It initializes the RCX, which includes configuring input 3 as 
a lig
t. Then it calls calibrate to take an average reading of the light sensor. Finally, it loops five times, 
and look for an object to pick up. Then 
grab is called to grab the object. Minerva turns around and heads back to her starting point with turnAround and 
return. Then she drops the object, with release, and turns around again with turnAround. With the simpler words 
defined correctly, retrieve is a highly readable piece of programming: 
 
: retrieve 
  seek 
  0 1 TIMER_SET 
  2 sleep 
  1 TIMER_GET returnTime ! 
; 
: return 
  returnTime @ sleep 
  stop 
; 
 
: retrieve 
  seek 
  grab 
  turnAround 
  return 
  release 
  turnAround 
; 
 
: Minerva 
  initialize 
librate 
0 DO 
retrieve 
OP 
; 
RTH implem
 the time all the simpler words are defined, th
mind—I'll describe the words in Minerva's p
n 
program
sor inpu
 word, Mi
ht sen
calling retrieve to go pick up something and bring it back. 
 
The retrieve word is also pretty self-explanatory. It calls seek to drive forward 

 
141
      grab 
  turnAround 
return 
do want to cover the more interesting ones. First, let's take a look at 
eek and return. The interesting thing about seek is that it uses one of the RCX's timers to figure out how long Minerva 
re finding something to pick up. Timer 1 is used for this purpose; the sleep word uses timer 0. seek 
rst sets timer 1 to 0 like this: 
0 1 TIMER_SET 
returnTime ! 
urnTime, we just need to drive back for the stored 
nother interesting word is calibrate, which takes ten readings of the light sensor and calculates an average value. This 
ensor "sees" something that can be picked up or not. We begin by pushing the current 
nning total on to the stack. To begin with, the total is zero: 
hen we just run in a loop from 0 to the constant value NUMBER_OF_SAMPLES. Each time through the loop, we read the 
d it to the running total on the stack. This is done every tenth of a second, by calling 1 sleep: 
1 sleep 
LOOP 
 
Once this is done, calculating an average is a simple matter of division: 
 
NUMBER_OF_SAMPLES / 
 
Then the average value is stored in the threshold variable: 
 
threshold ! 
  
  release 
  turnAround 
; 
 
I won't describe every word in Minerva's program, but I 
s
moves forward befo
fi
 
 
Then Minerva moves forward until she "sees" something to pick up. The current timer value is recorded in a variable, 
returnTime, like this: 
 
1 TIMER_GET 
 
When it's time for Minerva to drive back to her starting point, in ret
amount of time: 
 
: return 
  forward 
  returnTime @ sleep 
  stop 
; 
 
A
value is used to determine if the light s
ru
 
: calibrate 
  0 
 
T
value of input 3 and ad
 
NUMBER_OF_SAMPLES 0 DO 
2 sensorValue + 

 
142
Finally, as an added bonus, the average value is shown on the RCX's display: 
old, is used
word to find a dark object to pick up. seek drives forward until the 
ght sensor returns a reading that is 3 less than the average: BEGIN 2 sensorValue threshold @ 3 - < UNTIL 
ebugging 
1. The interactive nature of the pbFORTH interpreter can really help. You can, for example, make changes in a word by 
redefining it. With legOS (see Chapter 10), by contrast, you'd have to compile and download a whole new version of your 
software. With pbFORTH, you can simply make new definitions for the words that aren't working.∗ 
 
Furthermore, you can interactively test every word in your program. This makes it easy to drill down from the higher 
layers to the lower layers of your program to identify problems. Any word that is defined can be interactively tested. This 
is powerful medicine indeed. 
 
2. On the other hand, you need to be very careful about endless loops. If you do get stuck executing an endless loop, there's no 
way to stop pbFORTH short of removing the batteries. In this case, you will have to use your firmware download utility to 
reload pbFORTH.  
 
If you entered all of the Minerva source code, you can interactively test any of its words. For example, to show a number on 
the display, do something like this: 
 
RCX_INIT 
  ok 
42 showValue 
ok 
To pause for half a second, you could do this: 
5 sleep 
  ok 
To test out the calibrate word, try this: 
 
initialize 
  ok 
 
∗ Interestingly, new definitions don't replace the old ones, they just mask them out. If you want to return to an earlier 
 
threshold @ showValue 
 
The average value, thresh
 in the seek 
li
 
D
 
When you're writing your own programs, there are two things you should keep in mind when you are debugging: 
 
definition, You should use the MARKER word. See the pbFORTH web site for details. 

 
143
calibrate 
 
y now, you are probably getting a feel for this software. The main thing to keep in mind is to break your programs into small 
 easily tested and debugged. Interestingly, you can't retrieve a word definition from pbFORTH. The best way 
 program with pbFORTH is to put your program in a text file on your PC. When you're ready to give it a try, download the 
t. You can modify the text source file to make changes or fix bugs and redownload the new 
want to test the program. 
nline Resources 
orth for Mindstorms 
roup.com/lego/pbFORTH/
  ok 
B
pieces that can be
to
file to pbFORTH and test it ou
 definitions each time you 
word
 
O
 
F
 
ttp://www.hempeldesigng
h
This is the center of the pbFOR
 can also get the source
TH universe. Ralph Hempel, creator of pbFORTH, offers the current version of pbFORTH 
 code, sample Forth programs (including tortask.txt), and helpful advice and pointers. 
bFORTH rcxTk GUI 
ttp://www.hempeldesigngroup.com/lego/pbFORTH/rcxTkGUI.html
here. You
 
p
 
h
This page describes 
cl/Tk. 
some tools created by Ralph Hempel to make it easier to work with pbFORTH. The tools are based on 
T
 
Forth Interest Group Home Page 
 
http://www.forth.org/
This site is a good jumping-off point for all sorts of interesting information about the Forth language. If you want to learn more 
ature/rtfv5.pdf
about Forth, this is a great place to start. 
 
Tim Hendtlass's Real Time Forth Book 
 
ftp://ftp.taygeta.com/pub/Forth/Liter
This is one of the resources available from the Forth Interest Group Home Page (see the previous entry). It is a tutorial 
introduction to Forth. Although it describes a specific version in some detail, it's a good general introduction to the language 
itself (see its chapters 1 through 5). 
 
NQC—Not Quite C 
 
http://www.enteract.com/~dbaum/lego/nqc/index.html
This is the home page for NQC. It's listed here because nqc can be used to download the pbFORTH firmware to the RCX. 

 
144
firmdl.c 
 
http://graphics.stanford.edu/~kekoa/rcx/firmdl.c
Another popular firmware downloader is firmdl. Written by Kekoa Proudfoot, the source code is available in C and should 
compile on most platforms. 
 
LEGO World Shop 
 
http://www.legoworldshop.com/
This online store offers various useful items like the temperature sensor used in this chapter. You can also get touch sensors, 
light sensors, rotation sensors, more motors, and extra RCX's. 

 
145
7 
A Remote Control for Minerva 
 
 
In this chapter: 
 
 
• Two Heads Are Better Than 
One 
 
 
• The Allure of Telerobotics 
 
 
• Building Instructions 
 
• Programming Minerva 
 
 
• Online Resources 
 
 
In Chapter 5, Minerva, a Robot with an Arm, you read about a mechanically complex robot that could be built from one RIS 
kit. One of Minerva's shortcomings, however, is that she isn't very smart about searching out things to pick up. She simply 
drives forward, looking with her light sensor for something dark. 
 
One way to improve Minerva's performance is to have a human being control her. This is called teleoperation or telerobotics. 
This chapter describes the construction and programming of a remote control for Minerva. It is based on a second RCX, which 
sends IR messages to Minerva. Minerva also needs a new program that will respond to incoming IR messages. 
 
Two Heads Are Better Than One 
 
If you're a MINDSTORMS enthusiast, you're probably always hoping to get more stuff: more motors, more sensors, and a 
better programming environment than RCX Code. A second RIS set is a great investment, if you can afford it or if you can 
convince somebody to buy it for you. If you're on a tighter budget, you can buy a single RCX, by itself, for about $120US. If 
you have a friend with a MINDSTORMS set, of course, you can always pool your resources. 
 
There are several interesting things you can do with two RCXs: 
 
1. Build a giant robot. The two RCXs can coordinate their actions by communicating over the IR port. With two RCXs, of 
course, you can build a robot with six outputs and six inputs. 
 
2. Build leader and follower robots. One robot tells the other robot what to do by issuing commands over the IR port. This 
chapter illustrates this technique by describing how to build a remote control for Minerva. 
 
 
• Programming the Remote 
Control 
 
 

 
146
3.
e a robot competition. In Chapter 9, RoboTag, a Game for Two Robots, I'll talk about one possible robot competition. 
here are many other types of competitions. You and a friend could build robots to accomplish a specific task. Then you could 
hapter lists some existing competitions. 
 actually complicates things considerably. 
essy with three or more RCXs. How do you 
ssage is destined for a specific RCX? A simple solution is to assign a specific range of message values to 
pathways. For example, with three RCXs, named RCX1, RCX2, and RCX3, you might assign the message 
numbers as shown in Table 7-1. 
 
Table 7-1. Sample Message Assignments for Three-way RCX 
Communication 
 
Message Numbers   
 
Message Pathway (Two-way) 
 
0 to 9   
 
 
 
 
 
RCX1 to RCX2 
 
10 to 19   
 
 
 
 
RCX1 to RCX3 
 
20 to 29   
 
 
 
 
RCX2 to RCX3 
 
A more general solution may someday be supplied by the LEGO Network Protocol, a work in progress in the online 
MINDSTORMS community (see the "Online Resources" for more information). 
 
The Allure of Telerobotics 
 
Replacing the function of your robot's brain with that of a human brain is appealing in many situations. It's easy to program a 
robot to do the same task over and over again. However, if the task changes or if the enviro
ent changes, the robot may have 
hard time adjusting. Humans are much better at adapting to new conditions. 
eating. Part of the point of autonomous mobile robots is that you can set them 
running and forget about them until they're done with whatever they're doing. If you build a robotic vacuum cleaner, you want 
to set it running and forget about it until it's done cleaning your floors. If you used a teleoperated robotic vacuum cleaner, you'd 
spend just as much time cleaning as with a conventional vacuum cleaner. 
 
In the simplest form of telerobotics, the human can see the robot and can control it much as you might play with a radio control 
car. This is basically how the remote control for Minerva works: you can see Minerva and control it by sending IR messages 
from the remote control. 
 Hav
T
see whose robot performs better. The "Online Resources" section at the end of this c
 
You might think that having three or more RCXs would be even better, but it
ts m
Although IR communication between two RCXs is fairly straightforward, it ge
know if an IR me
arious message 
v
nm
a 
 
On the other hand, telerobotics is a kind of ch

 
147
M re sophisticated telerobots have a video camera that sends pictures back to a human operator. The operator can see what the 
bot sees and can send commands to control the robot. 
ote robot are separated by a very large distance, such as the 
distance between Mars and the Earth. In this case, the video signals from the robot take a long time to reach the operator, and 
the control signals from the operator take a long time to reach the robot. What the operator sees is really a second or two 
behind what's actually happening, so it's very hard to control the robot with any precision. 
 
Fortunately, you don't have to worry about this with Minerva. Because the remote and the robot communicate with IR light, 
there must always be a line-of-sight between them. If you can control the robot, you can see it—there's no video connection to 
add confusion. 
 
Building Instructions 
 
The controls for the remote are built on the bottom of the RCX. This was a conscious design decision—it orients the IR port of 
the remote in the best place to broadcast commands to Minerva. 
 
o
ro
 
eleoperation does not work well if the human operator and the rem
T

 
148
 
 
Attach the light sensor and wire bricks as shown. The light sensor goes on input 1, 
while the two wire bricks (which will be attached to the touch sensors) go to input 2  
and input 3. If you get these two wires backwards, you'll know when you push the 
joystick backward and the robot moves forward. You can easily swap the two 
connectors later. 
 
 
 
The two touch sensors are triggered by a joystick-like lever contraption. Only one 
of the sensors will ever be triggered at a time. 

 
149
 
 
The 
ally a simple lever. 
 
next step shows the joystick, which is re
 

 
150
Put the joy
emblies from Step 6. Fasten it together with 
the two ye
hing on the remote assembly. When you 
wiggle the
hes one or the other touch sensor. 
 
stick, from Step 5, into the ass
llow plates. Then put the whole t
 pus
 joystick back and forth, it
 
 
Step
uch, but it's important. It's the slider that controls 
Minerva'
he light sensor, presenting either a yellow or a black 
brick
RCX knows if you've moved the slider. 
 
 8 might not look like m
s arm. It slides past t
 to the sensor. This is how the 
 
 
In Step 9, the slider g
ote 
that it's upside-down
 construction. The orientation of 
the yellow and black
w the arm is 
controlled. If you do
lways 
switch it around
ets mounted on the remote. Make sure it slides freely, and n
 with respect to the rest of the
 bricks in the slider will make a difference in ho
n't like how it works when it's all together, you can a
r. 
 late

 
151
 
 
Programming the Remote Control 
 
The remote control doesn't really have to do much. It responds to its sensors by sending commands to Minerva. The joystick 
control triggers the two touch sensors; the remote responds to these by telling Minerva to move forward or spin. The slider 
control is used to move Minerva's arm up or down. 
 
One final feature is a ''heartbeat"—a special message that the remote periodically sends to Minerva. If Minerva doesn't hear 
this message, it knows it has lost contact with the remote. 
 
The remote uses three different tasks to get everything done. One task monitors the touch sensors, one task monitors the light 
nsor, and the third task s
se
 
ends the heartbeat signal. Here is the code for those tasks: 
task main() { 
SetSensor(SENSOR_1, SENSOR_LIGHT); 
SetSensor(SENSOR_2, SENSOR_TOUCH); 
SetSensor(SENSOR_3, SENSOR_TOUCH); 
#define FORWARD_MESSAGE 16 
#define SPIN_MESSAGE 17 
#define STOP_MESSAGE 18 
#define GRAB_MESSAGE 19 
#define RELEASE_MESSAGE 20 
#define HEARTBEAT_MESSAGE 21 
 
#define HEARTBEAT_TIME 20 

 
152
start lightWatcher; 
start touchWatcher; 
her() { 
while (true) { 
essage (FORWARD_MESSAGE); 
Wait(10); 
P_MESSAGE); 
SAGE); 
E 3 
nt; 
Watcher() { 
current = SENSOR_1; 
if (current < minimum) minimum = current; 
; 
midline = minimum + (maximum - minimum) / 2; 
 
if (SENSOR_1 <= (midline - TOLERANCE) && 
  lastArmMessage != RELEASE_MESSAGE) { 
PlayTone(494, 10); 
PlayTone(660, 10); 
SendMessage (RELEASE_MESSAGE); 
lastArmMessage = RELEASE_MESSAGE; 
} 
if (SENSOR_1 >= (middle + TOLERANCE) && 
     lastArmMessage != GRAB_MESSAGE) { 
PlayTone(660, 10); 
PlayTone(494, 10); 
SendMessage(GRAB_MESSAGE); 
lastArmMessage = GRAB_MESSAGE; 
} 
start heartbeat; 
} 
task touchWatc
if (SENSOR_2 == 1) { 
SendM
until (SENSOR_2 == 0); 
SendMessage (STO
} 
if (SENSOR_3 == 1) { 
SendMessage (SPIN_MESSAGE); 
Wait(10); 
until (SENSOR_3 == 0); 
SendMessage (STOP_MES
} 
} 
} 
 
#define TOLERANC
int curre
int minimum; 
int maximum; 
int midline; 
 
int lastArmMessage; 
 
task light
minimum = 100; 
 
maximum = 0; 
while (true) { 
if (current > maximum) maximum = current

 
153
} 
} 
task heartbeat() { 
while (true) { 
SendMessage (HEARTBEAT_MESSAGE); 
} 
The 
es the inputs on the remote control and starts up the other tasks. 
 
The 
rly straightforward. It listens for a touch on either touch sensor. When one is detected, the 
remo
mmand to Minerva to go forward or to spin in place. Then the task waits for the touch sensor to be 
relea
 
The call t
ore mention; it's an example of a technique called debouncing. Debouncing is a way of 
making to
al) work reliably. The basic problem occurs just at the point where you press the 
touch sens
rom off to on. Tiny motions or electrical variations can cause the touch sensor's 
outp
 
 between on and off. This effect is called bounce, and it occurs while you're 
press
or releasing the switch, between the steady states of off and on. Bounce can be eliminated with an electronic circuit or 
by sp
. The call to Wait(10)gives the touch sensor signal a chance to settle down before 
tou
ease of the touch sensor. 
 
The slider on th
htWatcher is the task that monitors the light sensor. If 
the sensor valu
rva to release the grabber. A dark-to-light transition causes 
the remote to send a 
a. 
 
Just what exact
e. I had originally hard-coded light values, but then the 
remote had to b
light or at night. Instead, the remote uses a scheme 
to calibrate itself on
f its minimum and maximum light readings in the minimum and maximum 
variables, as sh
 h
 
current
if (current < minimum) minimum = current; 
if (current > maximum) maximum = current; 
midline = minimum + (maximum - minimum) / 2; 
 
Then lightWatch
int of the minimum and maximum values. This value is used to determine exactly 
what light and dark 
e to fire commands to Minerva. lightWatcher also keeps track of the last 
grabber arm co
mand twice. 
 
Wait (HEARTBEAT_TIME); 
} 
 
main task configur
touchWatcher task is fai
te sends out an IR co
sed and sends a stop command to Minerva. 
o Wait(10) deserves m
uch sensors (and buttons in gener
or enough to make its state change f
switch back and forth very quickly
ut to
g 
in
ecial programming, as I've done here
chWa
for the rel
tcher starts looking 
e remote changes the value of the light sensor. lig
e chan
rk, the remote tells Mine
ges from light to da
grab command to Minerv
ly what "light" and "dark" are is a little tricky to defin
e repr
g on whether I was using it in day
ogrammed dependin
 the fly. It keeps track o
ere: 
own
 = SENSOR_1; 
er calculates the midpo
values cause the remot
mmand it sent to avoid unnecessarily sending the same com

 
154
To provid
 human operator, lightWatcher plays tones when it sends the grab or release commands. 
 
The hear
ly sends the heartbeat command to the IR port. 
 
Programm
 
Minerva's
 listen for incoming messages on the IR port and respond to them. This is fairly simple, but it's 
comp
te
 
1. M
e heartbeat commands from the remote. If she doesn't hear them, she should stop what she's 
doin
 
2. The hum
e to change the direction of the arm as it is moving, without waiting for an entire grab or 
release cy
ever, should not interfere with Minerva's ability to stop the arm when it moves 
up as far a
 
Minerva's 
s: 
 
message W
The 
s
sk examines the IR port for incoming messages. When one arrives, it is examined and the 
appr
e action is taken. 
 
grab
The grab
 messageWatcher to control Minerva's arm. They are separate tasks so 
that message
mands from the remote while the arm is moving. You could, for 
example, start drivin
g. grab and release have the ability to interrupt each other, so 
you can change the d
. 
 
heartbeatWatcher 
This task keeps coun
 a heartbeat, it subtracts one from a tally of 
missing heartbeats, k
heartbeatWatcher adds one to this count; if it's ever more 
than one, heartbe
tact with the remote. It then stops the messageWatcher task and 
shuts down the r
s heard again, heartbeatWatcher starts up messageWatcher 
once again. 
 
Here's the
r
details after the listing. 
e some feedback to the
beat task is very simple. It repeated
ing Minerva 
 program, then, must
lica d by two things: 
inerva should listen for th
g until the IR link is established again. 
an operator should be abl
cle to be completed. This feature, how
s it can go. 
program is split into four primary task
atcher 
agewatcher ta
mes
riat
op
 and release 
 and release tasks are kicked off by
Watcher can continue to receive com
abbin
g forward while the arm was gr
 as it's moving
irection of the arm
t of missing heartbeats. When messageWatcher receives
ble. The 
ept in the missedBeats varia
as lost con
atWatcher assumes it h
obot's motors. When the heartbeat i
 enti e program. I'll describe more of the 

 
155
#define FORWARD_MESSAGE 16 
#define SPIN_MESSAGE 17 
#define STOP_MESSAGE 18 
 
#define HEARTBEAT_TIME 20 
start messageWatcher; 
atcher() { 
e == FORWARD_MESSAGE) { 
(); 
} 
{ 
e(); 
start grab; 
ClearMessage(); 
} 
else if (message == RELEASE_MESSAGE) { 
start release; 
ClearMessage(); 
} 
else if (message == HEARTBEAT_MESSAGE) { 
missedBeats = missedBeats - 1; 
ClearMessage(); 
} 
} 
} 
task grab() { 
until (armLock == 0); 
#define GRAB_MESSAGE 19
#define RELEASE_MESSAGE 20 
#define HEARTBEAT_MESSAGE 21 
 
 
int message; 
int armLock; 
int missedBeats; 
 
task main() { 
SetSensor (SENSOR_3, SENSOR_LIGHT); 
armLock = 0; 
missedBeats = 0; 
start heartbeatWatcher; 
} 
 
task messageW
while (true) { 
message = Message(); 
if (messag
OnFwd(OUT_C); 
ClearMessage
} 
else if (message == SPIN_MESSAGE) { 
OnRev(OUT_C); 
ClearMessage(); 
else if (message == STOP_MESSAGE) 
 
Off(OUT_C);
ssag
ClearMe
} 
else if (message == GRAB_MESSAGE) { 

 
156
stop release; 
OnFwd(OUT_A); 
OR_3 == 100); 
armLock = 1; 
until (SENSOR_3 != 100); 
 
until (armLock == 0); 
stop grab; 
OnRev(OUT_A); 
00); 
until (SENSOR_3 != 100); 
armLock = 0; 
Off(OUT_A); 
ySound (SOUND_DOWN); 
PlaySound(SOUND_UP); 
missedBeats = 0; 
cher; 
The grab and release tasks, as I said, have the ability to interrupt each other. They use a variable, armLock, to avoid 
potentially dangerous situations. For example, suppose that release is  running. It drives the arm motor in reverse until the 
arm is up and the limit touch sensor is pressed. Then the motor is run forward to release the touch sensor. Before the touch 
sensor is released, however, suppose grab starts up. It stops release and runs the motor forward until the touch sensor is 
pressed. It's already pressed, so grab starts running the motor in reverse, waiting for the touch sensor to be released. Since 
the arm is already at the top of its travel, running the arm motor in reverse creates pressure on the gears and will either break 
the arm apart or cause the gears to skip. 
until (SENS
OnRev(OUT_A); 
armLock = 0; 
Off(OUT_A); 
} 
task release() { 
until (SENSOR_3 == 1
armLock = 1; 
OnFwd(OUT_A); 
} 
 
task heartbeatWatcher () { 
while (true) { 
if (missedBeats > 1) { 
Pla
stop messageWatcher; 
Off(OUT_C); 
until (armLock == 0); 
Off(OUT_A); 
until (Message () == HEARTBEAT_MESSAGE); 
start messageWat
} 
missedBeats = missedBeats + 1; 
Wait(HEARTBEAT_TIME); 
} 
} 
 
Don't Break That Arm 
 

 
157
Using the armLock variable enables grab and release to complete the press-release cycle of the arm limit switch 
 and release wait for armLock to be 0 before interrupting the other task, like this: 
he 
and 
tasks set armLock to 1 before doing the sensitive press-release cycle. This means Minerva 
 arm. 
tayin' Alive 
he heartbeatWatcher task also deserves some mention. It adds one to the missedBeats variable just as often as it 
eartbeat. Remember that just as heartbeatWatcher is adding to missedBeats, the 
btracting from missedBeats every time it hears the heartbeat message. If missedBeats 
rtbeatWatcher shuts Minerva down. This shutdown is not as straightforward as you might 
nd is played (the descending arpeggio). This lets the human operator know that contact with the 
n lost. Then heartbeatWatcher shuts down the  messageWatcher task and turns off Minerva's drive 
otor: 
und(SOUND_DOWN); 
stop messageWatcher; 
f(OUT_C); 
eartbeatWatcher also wants to shut down Minerva's arm motor, but it respects the armLock variable so the arm is 
te: 
ock == 0); 
Off(OUT_A); 
UP); 
missedBeats = 0; 
without being interrupted. Both grab
 
until (armLock == 0); 
 
T
grab 
release 
should never break her own
 
S
 
T
expects the remote to send a h
essageWatcher task is su
m
is ever greater than one, hea
think, however. First, a sou
remote has bee
m
 
PlaySo
Of
 
h
not left in an uncertain sta
 
until (armL
 
Now heartbeatWatcher waits to regain the heartbeat signal from the remote. If it is regained, heartbeatWatcher 
plays another sound (the ascending arpeggio), resets missedBeats, and starts up messageWatcher again: 
 
until (Message() == HEARTBEAT_MESSAGE); 
PlaySound(SOUND_
start messageWatcher; 

 
158
Online Resources 
 
LEGO Network Protocol 
 
legOS: 180[LEGO Network Protocol discussion thread] 
 
http://www.lugnet.com/robotics/rcx/legos/?n=180&t=i&v=c
Although  the  LEGO  Network Protocol is not yet mature, you can view its genesis in the discussion groups at LUGNET. This 
RL points to a lengthy exchange from the middle of 1999. 
vents 
ttp://www.lugnet.com/robotics/events/
U
 
Challenges and Competitions 
 
E
 
h
This is the home page for the robotics events discussion group at LUGNET. To keep up on community activity related to 
challenges and competitions, check back here often or subscribe to the lugnet.robotics.events newsgroup. 
 
programs 
 
http://www.thamesscience.org/program1.html
The Thames Science Center, in Newport, Rhode Island, hosts monthly challenges for robot builders of all ages. Each challenge 
consists of an objective; to participate, you build a robot to accomplish the objective. Then bring in your robot and see how it 
compares to other designs. You can register online. 
 
FIRST LEGO LEAGUE 
 
http://www.legomindstorms.com/first/
FIRST LEGO LEAGUE (FLL) is an organization for kids from 9 to 14. Teams can register to be a part of FLL, which includes 
a robotic challenge and competition. 
 
RCX Challenge 
 
http://home.connect.net/joel/Challenge.html
Designed by Joel Shafer, the challenge is to build a robot that can navigate a room to pick up empty soda cans. If you're 
considering hosting your own robot competition, you might want to check out Joel's rules. 
 
Lego Mindstorms Robot Arena 
ttp://www.azimuthmedia.com/RobotArena/mainframe.html
 
h
The Robot Arena is another robot competition in the San Francisco Bay area. 

 
159
8 
Using Spirit.ocx with Visual Basic 
 
 
In this chapter: 
eady Have  
isu
 
 
• Ab
layed  
Tips 
art of the appeal of the programming environments described in Chapter 4, Not Quite C, and Chapter 6, pbFORTH, is that 
per
 
Visual Basic and your 
robots is a file called Spirit.ocx, which is installed as part of the standard RIS software. In this chapter, I'll show you how to use 
Visual Basic and Spirit.ocx to control and program your robots. 
 
If you are running windows, chances are good that you already have Visual Basic somewhere, as I'll describe in the next 
section. Because VB is so widespread in the Windows world, I won't attempt to describe the language itself. There are several 
good online tutorials, including information and examples at Microsoft's site. (See the "Online Resources" section at the end of 
this chapter for references.) Instead, this chapter focuses on how you can use VB to write programs for your RCX. 
 
You May Already Have Visual Basic 
 
Visual Basic is a programming language made by Microsoft. You can purchase it as a separate product. The "Learning 
Edition" is $109US. A "Professional Edition," 
 
• You May Alr
V
al Basic 
out Spirit.ocx 
 
 
• Calling Spirit.ocx Functions 
 
 
• Immediate and De
Gratification 
 
 
• Programs, Tasks, and  
ubroutines 
S
 
 
• 
 
 
 Retrieving the Datalog 
•
 
 
• Online Resources 
 
 
P
they don't tie you down to using Windows on your development PC. The programming environment that comes with RIS, 
RCX Code, is a Windows-only solution, which is distressing to people who prefer other operating systems. Aside from 
providing better capabilities than RCX Code, NQC and pbFORTH also allow you to develop RCX software using your 
ating system of choice.
o
 
In this chapter, I'll describe a Windows-only solution— programming your robots using Visual Basic (VB). Visual Basic is a 
language developed by Microsoft and included with many of their other products. The link between 

 
160
with more bells and whistles, is available for $279Us. If you have more money to burn, try the "Enterprise Edition," for 
$1299US. 
 
Don't be alarmed by the price tags. You may alre
ut knowing it. The applications in the Microsoft 
Office software include a limited version of Visual Basic, called Visual Basic for Applications (VBA); Word, Excel, and 
BA in Microsoft Word 97, but you could just as eas
on't have VB or VBA, you can use a very similar environment called BrickCommand. BrickCommand allows 
o
C
can also be used from Visual C++ (VC++). If you're familiar with VC++, you can do this 
mmonly available. 
ady have Visual Basic witho
Access all include VBA. In Word, for example, there's a Visual Basic Editor menu item in the Macro submenu of the Tools 
menu. The examples in this chapter were developed with V
ily use one of 
e other incarnations of VB or VBA. 
th
 
ven if you d
E
you to program the RCX via Spirit.ocx, much the same way as you would using VB or VBA. Several similar packages are 
available online; see the "Online Resources" section for details. 
 
Ab ut Spirit.ocx 
 
Spirit.ocx is the glue that links Windows applications to the RCX. If you installed the software from the RIS kit, you already 
have Spirit.ocx on your computer. In essence, Spirit.ocx is a collection of functions that send commands to the RCX, ask the 
RCX for information, or create programs on the R X. Figure 8-1 shows the software architecture, which is quite similar to 
igure 4-1 in Chapter 4. Spirit.ocx 
F
fairly easily. This chapter describes VB because it is simple and co
 
 
 
Figure 8-1. 
RCX software architecture 

 
161
Like NQC, Spirit.ocx uses the default firmware that is loaded on the RCX and makes more features of the bytecode interpreter 
ailable than RCX Code. Unlike NQC, Spirit.ocx is a Windowsspecific piece of software. 
he goal of this chapter is to enable you to call Spirit.ocx functions directly from VB or VBA with code like this: 
.InitComm 
 10 
.On 
 
All you need to
 Spirit.ocx control. This process is described in the next few sections. 
 
First Things F
 
To begin with, 
r VBA environment. If you have a full version of VB installed, just start it up. If 
you have any o
cations, you can use VBA. In Word, for example, choose Tools > Macro > Visual 
Basic Edi
 
howing
cx in the Tool Palette 
 put it in a user form. Create a new form by choosing Insert > UserForm. A  new  form 
ppears, along with a tool palette labeled Toolbox. 
 
Spiri
 it, choose Tools > Additional Controls. In the window that appears, 
scroll down to 
trol in the list of available controls.∗ Click on the box to its left to select it, then click on OK. 
You only have 
once. When you use VB again later, the Spirit.ocx control will automatically show up 
in your tool pal
 
A new item with the
 now be in your tool palette. Select this item and place it on the form you just 
created. We won't u
cept as a place to keep the Spirit.ocx control. Change the name to something 
like DummySpirit
 a default name of Spiritil, which is just fine for our purposes. 
 
∗ The Spirit C
ly if you have already installed the LEGO MINDSTORMS software. During 
av
 
Calling Spirit.ocx Functions 
 
T
 
.PlayTone 440,
.SetWatch Hour (Now), Minute (Now) 
"01" 
 do is let VB know about the
irst 
you should enter your VB o
ffice appli
f the Microsoft O
tor. 
S
 Spirit.o
 
To reference Spirit.ocx we first need to
a
t.ocx does not appear in the tool palette. To add
find Spirit Con
to follow this procedure 
ette, as shown in Figure 8-2. 
 familiar LEGO logo should
se the form for anything ex
Form. The control itself has
ontrol item appears in the list on
this installation
stered with the system in such a way that VB or VBA can find it later. 
, Spirit.ocx is regi

 
162
 
 
Figure 8-2. 
Spirit.ocx in the tool palette 
 
You should glance over Spiritl's
roperty to be sure you'll be talking to
 properties to make sure they're set up properly. In particular, check the ComPortNo 
 the right serial port. 
mm 
stemSound 0 
DummySpiritForm.Spiritl.CloseComm 
End Sub
 
To run this simple s
 your RCX is on. Then click on the play button in the toolbar. If all goes well, you 
should hear your RCX play a simple beep. 
 
It's little cumbersome to always refer to the full name of the Spirit.ocx control. A simpler syntax, using With, looks like this: 
 
Sub HelloSpiritII () 
With DummySpiritForm.Spirit1 
.InitComm 
.PlaySystemSound 0 
.CloseComm 
End With 
End Sub 
p
 
Hello, Spirit 
 
Now that you've placed a Spirit.ocx control on a form, let's write some code to use it. Choose the Insert > Module menu item 
to create a new code module. In the window that appears, type the following to create a new subroutine: 
 
Sub HelloSpirit 
 
To call functions in Spirit.ocx, you need to reference the control by name. The dummy form you created is 
DummySpiritForm. It contains a Spirit.ocx control called Spiritl. The full name of the control, then, is 
ummySpiritForm.Spirit1. 
D
 
Fill out the body of the HelloSpirit subroutine as follows: 
 
Sub HelloSpirit () 
DummySpiritForm.Spiritl.InitCo
Dumm
m.Spiritl.PlaySy
ySpiritFor
 
ubroutine, make sure

 
163
Immediate and Del
 
The functions i
ediate, delayed, or both. An immediate function executes as soon as you call it. Delayed 
functions can be plac
d later. For example, Onis both an immediate and delayed function. You 
can call it to turn on some
 can call it to add it to a program that will be executed later. 
 
The following subroutine 
PlayTone function in its immediate mode: 
 
Sub Charge() 
With Dummy
.InitCo
.Pl
 10 
0 
0 
.Pl
.Pl
.CloseC
End With 
End Sub 
 
Instead of execut
X immediately, you can store them for later. The following subroutine redefines Program 
5 on the RCX t
ng: 
 
Sub ChargeProgram() 
SpiritForm.Spirit1 
nitComm 
e 392, 10 
.PlayTone 523, 10 
.PlayTone 659, 10 
End Sub 
Loop 
End Sub 
ayed Gratification 
n Spirit.ocx can be imm
ed inside a program and execute
 outputs immediately, or you
plays a little song using the 
SpiritForm.Spirit1 
mm 
 10 
ayTone 392,
23,
.PlayTone 5
.PlayTone 659, 1
.Pla
, 2
yTone 784
ayTone 659, 10 
ayTone 784, 20 
omm 
ing 
o play the same so
things on the RC
With 
.I
Dummy
.SelectPrgm 4 
.BeginOfTask 0 
.PlayTon
.PlayTone 784, 20 
.PlayTone 659, 10 
.PlayTone 784, 20 
.EndOfTask 
Pause 1 
.CloseComm 
End With 
 
Sub Pause(ByVal duration As Integer) 
Start = Timer 
Do While Timer < Start + duration 

 
164
When you run ChargeProgram, you won't hear anything. But when you select Program 5 and press the Run button, you'll 
hear the song. You have just downloaded a program to the RCX from Visual Basic! 
 
This example uses SelectPrgm to select the RCX's current program number. Se
Prgm expects a zer
presenting the R
lect
o-based number, 
om zero to four, re
CX's programs from one through five. Calling SelectPrgm 4 tells the RCX to switch 
 final tweak I should mention. ChargeProgram uses a helper subroutine, Pause, to give Spirit.ocx a chance to 
aded. 
Prog
d Subroutines 
 
Each
e to ten tasks and zero to eight subroutines. This structure is dictated by the 
RCX
 exactly the same structure that I described for NQC in Chapter 4. 
 
Subr
 that tasks are defined, by framing some set of function calls with the 
eg
The same restrictions on subroutines in NQC apply here; subroutines cannot call 
e GoSub function. 
s yo
rogram is the task that is run when you press the Run button on the RCX. It's 
up t
 you've defined. Spirit.ocx provides StartTask, StopTask, and 
StopAll
ithin a program. 
 
The follow
ly runs the other tasks, using StartTask. Task 1 sings a song, over 
and o
 2 runs the motors forward and reverse ad infinitum. 
 
ectPrgm 3 
fr
to Program 5. 
 
The next unfamiliar Spirit.ocx function in this example is BeginOfTask. I'll explain more about tasks a little later; for now, 
just keep in mind that task 0 is run when you press the Run button on the RCX. Everything between the BeginOfTask and 
EndOfTask is stored as the task itself. 
 
here's one
T
download the program to the RCX before calling CloseComm. It simply waits for a second before shutting down the 
communication link to the RCX. Without this pause, the program does not get fully downlo
 
rams, Tasks, an
 of the RCX's five programs is made up of on
 firmware, and hence is
outines are defined much the same way
B
ot
inOfSub and EndOfSub functions. 
her subroutines or themselves. Within a task, you can call a subroutine with th
 
A
u learned in the last example, task 0 in a p
o tha
 to start whatever other tasks
t task
Tasks for controlling the execution of different tasks w
ing example defines three tasks. Task 0 simp
ver, while task
Sub MultiTaskingProgram() 
With DummySpiritForm.Spirit1 
.InitComm 
.Sel
.BeginOfTask 0 
.StartTask 1 

 
165
.StartTask 2 
.EndOfTask 
.BeginOfTask 1 
.While 0, 0, 2, 0, 0 
 392, 10 
.PlayTone 523, 10 
.PlayTone 659, 10 
.PlayTone 784, 20 
.PlayTone 659, 10 
.PlayTone 784, 20 
.Wait 2, 80 
.Wait 2, 80 
.EndWhile 
.EndOfTask 
k 2 
.On "02" 
.Wait 2, 50 
Task
hile to loop forever. Task 1 plays a song over and over, while task 2 runs the 
outp
 
Tips 
 
You'
t.ocx exposed in NQC. Although the syntax in Visual Basic is different, 
the basic f
nical Reference Document (see the ''Online Resources") does a good job 
describing the s
ocx commands; I won't attempt to duplicate that work. Instead, this section contains down-to-
earth informatio
 
Retrieving Inpu
 
Although the T
e Document makes it clear how to reset timer values and how to configure the RCX's inputs, 
you may 
 to retrieve the value of an input or timer. The answer is a versatile function called Poll. 
Pol
ues from the RCX, including input values (in several different forms), timer values, variable values, 
the c
of the R X's o
d the last value recei
over the IR port. 
.PlayTone
.BeginOfTas
.While 0, 0, 2, 0, 0 
.SetFwd "02" 
.SetRwd "02" 
.Wait 2, 50 
.EndWhile 
sk 
.EndOfTa
Pause 5 
.CloseComm 
End With 
End Sub 
 
EndW
s 1 and 2 both use While and 
uts in forward and reverse. 
ve already seen a lot of the functionality of Spiri
unctio
e. LEGO's official Tech
ns are the sam
of Spirit.
yntax 
n on using Spirit.ocx. 
t and Timer Values 
echnical Referenc
ing how
be left wonder
 many val
l can return
ent status 
urr
C
utputs, an
ved 

 
166
Poll accepts a Source and a Number that, taken together, describe the value you want to retrieve. The key to 
nderstanding  Poll is the Parameter Table in the Technical Reference Document. This table simply lists out the possible 
ing
 
As you m
our Visual Basic code can make Source and Number values a lot 
easier to read. The Technical Reference Document even includes a set of constant definitions, RCXDat.bas (also available 
online). You ca
as part of your Visual Basic project, but the constant names are not very descriptive 
(SENVAL and 
 
You can easily 
onstants in the (Declarations) section of your code module. For example, you might add 
the following d
s beginning with a single quotation mark are comments): 
 
nst VARIABLE = 0 
written like this: 
Result = .Poll(SENSOR_VALUE, SENSOR_2 
Result = .Poll (VARIABLE, 11) 
' …
End 
's a
adable with the symbolic constants. If you ever have to look at the code at some later date, you'll really 
s going on. 
u
values for Source and Number and how they are interpreted. For example, a call to Poll 9, 1 would return the value 
of input 2. A call to Poll 0, 11 would return the value of the twelfth variable. 
 
Us
 Constants 
ight have guessed, symbolic constants in y
n incorporate this file 
VAR, for example). 
define your own c
efinitions (the line
' Source
ublic Co
s 
P
Public Const SENSOR_VALUE = 9 
' Sensor names 
Public Const SENSOR_1 = 0 
Public Const SENSOR_2 = 1 
Public Const SENSOR_3 = 2 
 
sing these constants, the above Poll functions could be re
U
 
With DummySpiritForm.Spirit1 
' … 
 
With 
 
 lot more re
It
appreciate knowing what'
 
Using If and While 
 
The Parameter Table is likewise the key to understanding the If and While functions. In essence, If compares two Poll 
values, each described by a Source and a Number. In the following example, the If statement tests to see if the value of 
nput 3 is less than the constant value 100: 
i
 
If 9, 2, 1, 2, 100 

 
167
The value of input 3 is represented by the first 9, 2; the constant value 100 is represented by 2 100. What's that 1 in the 
iddle? That's the operator that's used 
. The available operators are shown in Table 8-1. As you might have 
ble 8-1. Operators for If and While 
Num
' Sources 
IABLE = 0 
NSTANT = 2 
SOR_VALUE = 9 
 = 0 
 = 1 
Public Const EQUAL = 2 
NSTANT, 100 
re. 
.CloseComm 
End With 
End Sub 
 
Once you've mastered If, the While loop is easy. Like If, it compares two values using an operator. The body of the 
While (until an EndWhile) is executed until the comparison is false. The body of the following loop, for example, would 
be executed as long as the value of input 3 was less than 100: 
 
While SENSOR_VALUE, SENSOR_3, LESS, CONSTANT, 100 
' Loop body 
EndWhile 
m
for comparison
guessed, you can define constants to make these easier to understand. 
 
Ta
 
ber   
Meaning 
 
0   
 
 
> 
 
1   
 
 
< 
 
2   
 
 
= 
 
3   
 
 
!=(not equal) 
 
A good set of constants makes the If statement a lot easier to read: 
 
Public Const VAR
Public Const CO
Public Const SEN
' Sensor names 
Public Const SENSOR_1
 SENSOR_2
Public Const
Public Const SENSOR_3 = 2 
' Operators 
Public Const GREATER = 0 
Public Const LESS = 1 
Public Const NOT_EQUAL = 3 
 
Sub UsingConstants( 
With DummySpiritForm.Spirit1 
.InitComm 
' … 
, SENSOR_3, LESS, CO
.If SENSOR_VALUE
' Do stuff he
.EndIf 
' … 

 
168
Other Nuggets 
 
Spirit.ocx offer
 NQC. One of these is the ability to turn off the RCX, using 
PBTurnOff. In
mmediately or inside a program. The following Visual Basic 
code defines an
 
Sub Tur
.En
Pau
.Cl
End Wit
End Sub 
 
By itself, of course, i
ne how it might be useful, though: shouldn't your robot turn itself 
off when it's accomplished
 
You can also use Spirit.ocx 
rrent battery charge. The PBBattery function returns the current 
battery voltage in mi
es, you should get a reading of 9000. The following example shows how 
you can retrieve and 
current battery power level: 
 
Sub Sho
With DummySpiritForm.Spirit1 
BBattery() 
 
Retr
 
Back in C
d the datalog, a special set of data in the RCX that your programs can use. It's easy to create a 
datalog an
 NQC, but how to you get that data back? Although you can retrieve the datalog using a tool like 
nqc or R
ter, it may not be in exactly the format you'd like. In this section I'll show you how to write a 
prog
o extract the datalog from the RCX. You can modify this program to suit your needs. 
 
The 
ns with the RCX, extracts the datalog 
values, an
ed values. It's all pretty straightforward, except that the RCX will 
s some interesting capabilities that go beyond even
terestingly, this function can be executed either i
 RCX program that turns itself off: 
nOffProgram() 
With DummySpiritForm.Spirit1 
.InitComm 
.SelectPrgm 2 
.BeginOfTask 0 
.PBTurnOff 
dOfTask 
se 1 
oseComm 
h 
t's a pretty silly program. You can imagi
 its mission, to conserve battery power? 
to 
lts (mV). For fresh batteri
query the RCX for the cu
lliVo
splay the 
di
wBattery() 
.InitComm 
attery = .P
b
.CloseComm 
tery) 
MsgBox (bat
End With 
End Sub 
ieving the Datalog 
hapter 4
d add
, I describe
 values to it in
and Cen
CX Comm
ram in Visual Basic t
main p
eDatalog. It opens up communicatio
art of the program is a subroutine, Sav
d writes them into a file of comma-separat

 
169
only upload fifty datalog values at a time. If you have larger datalog, it must be uploaded in pieces. 
 
The relevant Sp
log
akes a starting index and a length. The first (zero-th) item of the 
datalog contain
ing SaveDatalog reads: 
 
Datalog(0, 1) 
he actual data
ess than the reported length, because the zeroth item is not a data point. 
he data returned from 
is an array. Each datalog item is represented by three numbers. The first two 
and number have exactly the same meaning here as they do for 
ber is the actual value stored in the datalog. 
and value for each datalog item out to a text file. Each line of the text file 
e, the source, number, and value of the item are separated by commas. This 
 value, then converts it to a descriptive string before writing it out to the file. The output 
 
ed of three parts. The SaveDatalog subroutine does most of the work. It uses the min function to 
function to convert the datalog item source number to a descriptive string: 
 
With DummySpiritForm.Spirit1 
irit.ocx function is UploadData
, which t
s the length of the datalog. It's the first th
d
le
ata = .Upload
ngth = data(2, 0) -1 
 
T
 length is one l
 
T
UploadDatalog 
numbers indicate the source and number of the value; source 
Poll. The third num
 
SaveDatalog writes the source, number, 
represents one item from the datalog. On each lin
example interprets the source of each
file will look something like this (depending, of course, on the contents of the datalog): 
 
Variable, 1, 2 
Timer, 0, 543 
Variable, 2, 8 
Variable, 8, 368 
Sensor value, 1, 33
Watch, 0, 7 
 
A plain text file of comma-separated values is usually pretty easy to import into a spreadsheet or statistical analysis program. 
You can use your robot to gather data, use this example program to upload it to your PC, and then use some other program to 
analyze or graph the data. Some people have built optical scanners based on RIS using these techniques. 
 
The example is compris
calculate a minimum and the getTypeString 
 
Sub SaveDatalog(filname As String) 
Dim data As Variant 
Dim index, length, stepSize As Integer 
Dim line As String 

 
170
' Open the output file. 
out = FreeFile 
open filename For Output As #out 
 
.InitComm 
get item zero, which describes the length of the datalog. 
data = .UploadDatalog(0, 1) 
2, 0) - 1 
While (index < length) 
he remaining items or 50. 
stepSize = min(length - index, 50) 
For i = o To stepSize -1 
getTypeString(data(0, i)) + "," + _ 
a(2, i)) 
Close #out 
End With 
End Sub 
Function min(n1 As Integer, n2 As Integer) As Integer 
If n1 < n2 Then 
min = n1 
Else 
min = n2 
End If 
End Function 
Function getTypeString(ByVal code As Integer) As String 
getTypeString = Switch( _ 
code = 0, "Variable", _ 
code = 1, "Timer", _ 
code = 2, "Constant", _ 
code = 3, "Motor status", _ 
code = 4, "Random", _ 
code = 8, "Program number", _ 
code = 9, "Sensor value", _ 
code = 10, "Sensor type", _ 
code = 11, "Sensor mode", _ 
code = 12, "Sensor raw", _ 
' First 
length = data(
 
' Now upload 50 items at a time. 
index = 0 
' Find the smaller of t
' Get the data. 
data = .UploadDatalog(index + 1, stepSize) 
 
' Write it out to a file. 
line = 
Str (data(1, i)) + "," +_ 
Str (dat
Print #out, line 
Next I 
 
index = index + stepSize 
Wend 
 
.CloseComm 
 
' Close the file. 

 
171
 
code = 13, "Sensor boolean", _ 
code = 14, "Watch", _ 
code = 15, "IR message" _ 
End Function 
 is really just a jumping-off point. You may want to make the following enhancements: 
Datalog into a form to create a user-friendly application. 
utput file format to suit your own needs. 
EGO Programmable Bricks Reference Guide 
) 
 
his example, of course,
T
 
• Integrate Save
 
• Modify the o
 
Online Resources 
 
L
 
http://www.legomindstorms.com/sdk/
This official document from LEGO describes Spirit.ocx in detail. Although LEGO calls it a Software Development Kit (SDK), 
's not really a big deal. There's a PDF file of the Technical Reference Document, which is 112 pages of reference material 
EGO on my mind: Roboworld 
it
describing every function in Spirit.ocx. There are also some Visual Basic files that you can download and experiment with, 
including a file of handy constant definitions. 
 
L
 
http://homepages.svc.fcj.hvu.nl/brok/legomind/robo/
This is the robotics area of Eric Brok's excellent site. There are actually two relevant resources here. The first is an outstanding 
troduction (the "Spirit programming" link) to using Spirit.ocx from Visual Basic. The second resource is "Mind Control" a 
ego Robotics Course 
in
programming environment that interprets Visual Basic-like programs and can download them to the RCX. 
 
L
 
http://emhain.wit.ie/~p98ac25/
This tutorial, created as a course handbook at the Waterford Institute of Technology in Ireland, provides a gentle introduction 
to Visual Basic and programming with Spirit.ocx. It's available as a PDF file, either in one big chunk or in separate pieces. The 
document describes how to work in the Visual Basic environment, how to use VB to talk to the RCX, and even includes 
several sets of instructions for building robots that you then program with VB. 
 
Bot-Kit 
 
http://www.object-arts.com/Bower/Bot-Kit/Bot-Kit.htm
Bot-Kit, developed by Andy Bower, is glue that allows you to program your RCX using Smalltalk, a popular object-oriented 
programming language. To use Bot-Kit, you will need Dolphin Smalltalk, which is a Smalltalk implementation for Windows. 
Links are provide on the Bot-Kit web site for obtaining Dolphin 

 
172
Smalltalk, which is available for free. Bot-Kit itself is free, although you'll need to join a related mailing list in order to install 
e software. As with VB, you can write Smalltalk programs that run on your PC and control the RCX, or you can write 
Smalltalk programs and download them to the RCX. If you are interested in learning Smalltalk, this would certainly be a fun 
way to do it. The documentation is excellent. 
 
The BrainStorm Web Page 
 
http://www.netway.com/~rmaynard/
th
BrainStorm is a version of the Logo programming language adapted to work with MINDSTORMS robots. Developed by 
Richard Maynard, BrainStorm is a work in progress and currently stands at version 0.1. Richard wrote BrainStorm using 
Visual C++ to communicate with Spirit.ocx. The source code is available. 
 
IGUANO Entertainment Lego Page [BrickCommand] 
 
http://www.geocities.com/Area51/Nebula/8488/lego.html
BrickCommand is a programming environment for MINDSTORMS that is similar to Visual Basic. It opens up the full power 
of Spirit.ocx for your programming pleasure. It includes other  goodies like a piano keyboard for playing music on the RCX, an 
interactive motion controller, and the ability to call single Spirit.ocx functions interactively. 
 
BotCode RCX Development System 
 
http://www.desktopmusic.com/botcode.htm
BotCode is another alternative to VB. It opens up the power of Spirit.ocx but doesn't have as many extras as BrickCommand. 
Furthermore, it's shareware ($20US), whereas BrickCommand is entirely free. 
 
LEGO MINDSTORMS: GORDON'S BRICK PROGRAMMER 
 
http://www.umbra.demon.co.uk/gbp.html
Gordon's Brick Programmer is yet another alternative to VB. Like BrickCommand and BotCode, it's a programming 
environment built on top of Spirit.ocx. 

 
173
9 
oboTag, a Game for Two Robots 
In this chapter: 
 
 
• Building Instructions 
 
 
• Subsumption 
 
 
Architecture 
 
 
• Online Resources 
 
 
RoboTag is a game for two robots. The robots drive around in a simple arena; the edge of the arena is marked by a black line.  
When one robot bumps into the other robot, it shouts "Tag!" by sending a message out its IR port. The tagged robot must sit 
still for a while, and then the game continues. 
 
The two robots are identical. Each has two motor-driven treads. Each robot has a bumper on its front and a downward pointing 
light sensor. The light sensor is used to detect the edge of the playing arena. When the light sensor "sees" the edge, the robot 
backs up and turns to stay inside the arena. 
 
When the bumper is triggered, the robot assumes it bumped into the other robot and shouts "Tag!" It waits for an 
acknowledgement from the other robot (in the form of another IR message). If the acknowledgment is received, the robot adds 
one to its current score. 
 
When one of the robots receives the "Tag!" message from the other robot, it is obliged to send an acknowledgement and then 
sit still for a short time. Then it starts up again, wandering around to tag the other robot. 
 
RoboTag is the creation of Matthew Miller, who teamed up with a friend, Paul Stauffer, to build and program the first 
RoboTag contestants. In this chapter, I'll use RoboTag as a way to explain subsumption architecture, an important paradigm in 
robotics programming. 
R
 
 

 
174
Building Instructions 
 
 

 
175
 
 
The 16t gears are nestled inside the tread wheels. 
 

 
176
 

 
177
 
 
 
Attach the motors to output A and output C as shown. 

 
178
 
 
The light sensor, which is mounted on the bumper, is attached to input 2. The touch sensor  
goes on input 1. 
 
 

 
179
 
 
bsumption Architecture 
Su
 
The t
 programming has been to emulate human thought processes. First, the robot processes its 
senso
or updates a model of the world. Then it decides how to act. This 
deliberativ
duty processing power and may not work properly anyway. 
 
Overview 
chitecture is simple 
a
the concept. Imagine a robot that has a bumper (a touch sensor) on its front. When the robot 
bum
uld back up and turn around. With subsumption architecture, the robot will use two behaviors. 
The 
ise and simply moves the robot forward. Figure 9-1 shows a diagram of this behavior. It controls 
the m
ve forward. 
 
To avoid obstac
, avoid. This behavior will become active when it detects a bump on the 
touch sensor. It will 
raditional approach to r
r data
obot
. Based on the sensor data, the robot constructs 
quires heavy-
e approach is very complicated; it re
 
Subsumption architecture is a radically different paradigm for robot programming developed by Rodney Brooks at MIT in the 
late 1980s. In this reactive approach, several robot behaviors run at the same time. Input from sensors is used to determine 
which behavior controls the robot at any given time. Depending on the sensor values, higher-level behaviors completely take 
ver control of the robot, subsuming (replacing) lower-level behaviors. As you'll see, subsumption ar
o
enough to be implemented on inexpensive hardware, including the RCX. 
 
A b sic example will clarify 
 into something, it sho
ps
first behavior is cru
otors to make the robot mo
les, th
ther behavior
e robot needs ano
completely take 

 
180
 
 
Figure 9-1. 
Cruise, a simple robot behavior 
over control of the r
he cruise and avoid behaviors. The circle with an ''S" 
indicates that the av
or. 
 
 
 shows a diagram with both t
obot. Figure 9-2
oid behavior can take control of the motors from the cruise behavi
 
Figure 9-2. 
 
e. Our implementation of subsumption architecture is written in NQC. 
e 
avior is a separate task. The behaviors all run simultaneously, trying to control the robot 
co
ne additional task decides which behavior is in charge and then sends its commands to the 
b
 
The r
viors, shown in Figure 9-3. The basic cruise behavior is the same 
 be
ides with the other robot, the bumper is pressed. This causes the tag 
he playing field, the reading from the light sensor 
or is tagged. This behavior is triggered if the robot 
The avoid behavior takes control of the robot when the bumper is pressed 
 
There won't always be a one-to-one relationship between inputs and behaviors. It's entirely possible that one behavior will be 
triggered by some combination of inputs. Likewise, a single input might trigger multiple behaviors, depending on the input's 
value. 
 
Implementation 
 
It's fairly easy to implement subsumption architecture on a system that includes preemptive multitasking. As you'll recall, the 
CX's default firmware supports this featur
R
Th
basic idea is that each beh
rding to their own rules. O
ac
motors. 
 
Ro oTag behaviors 
obots in RoboTag actually need four different beha
fore—it moves the robot forward. If one robot coll
as
behavior to take control of the robot. If the robot drives over the edge of t
auses the avoid behavior to assert itself. Finally, the top level behavi
c
has been tagged by the other robot. 

 
181
 
 
Figure 9
RoboTag beh
-3. 
aviors 
I'll start by examinin
 about how a behavior is selected and how the motors are 
controlled. In the nex
 
The cruise behav
 
int cruiseC
task cr
e
Command = COMMAND_FORWARD; 
le (true) Wait(100); 
cruise
 the 
cru
ld the desired motor output. In this simple case, cruise always wants the robot to move 
forw
ow this variable is used to determine what actually happens to the robot. 
 
The ne
, tag has its own motor output variable, tagCommand: 
 
int tagComm
 
task tag() 
while(t
if (BUMP_SENSOR == 1) { 
SendMessage(MESSAGE_TAG); 
// Coast to a stop. 
tagCommand = COMMAND_FLOAT; 
Wait(20); 
// Check to see if we got an acknowledgement. 
if (Message() == MESSAGE_ACKNOWLEDGE) { 
 
 for each behavior. Then I'll talk
g the NQC code
t section, I'll present the entire source code for RoboTag. 
ior is simple: 
ommand; 
() { 
uis
ise
cru
whi
} 
 
cruise sets the cruiseCommand variable to the value COMMAND_FORWARD and then loops forever.∗ Each behavior 
ask) has an associated command variable that holds the desired motor output. 
, for example, uses
(t
iseCommand variable to ho
er on, I'll show you h
ard. Lat
xt behavior is tag. Like cruise
and; 
{ 
rue) { 
// Say tag! 
 
∗ The endless loop isn't strictly necessary, but it makes cruise look more like the other behaviors. 

 
182
PlaySound(3); 
SetPower(OUT_B, score); 
_B); 
score < 7) score = score + 1; 
Wait(50); 
// Turn left or right for a random duration. 
if (Random(1) == 0) tagCommand = COMMAND_LEFT; 
} 
mper is pressed. Otherwise, it sets tagCommand to a special value, COMMAND_NONE, which 
n controlling the robot. 
If ta
s one to its score. There's a bit of a hack here to keep score. 
The powe
t score. The initialization code for RoboTag (presented later) 
tells the R
 
Sele
 
All tag does i
ut B to show the current score on the display: 
 
SetP
On(O
if (score < 7) score = score + 1; 
 
Of course,
 7. 
 
If tag se
 do anything. The lack of a reply can mean two things: 
either the 
ped into an obstacle, not the other robot. In the 
origi
Ro
a contained no obstacles, so it was safe to assume that the other robot didn't 
"hear" the tag message. The tagging robot would then spin in place shouting "Tag!" repeatedly, hoping to get in range of the 
On(OUT
if (
} 
else PlaySound(2); 
ClearMessage(); 
// Back up. 
COMMAND_REVERSE; 
tagCommand = 
else tagCommand = COMMAND_RIGHT; 
Wait(Random(200)); 
tagCommand = COMMAND_NONE; 
else tagCommand = COMMAND_NONE; 
} 
} 
 
ag acts only if the bu
t
indicates that tag is not interested i
 
When the bumper is pressed, tag sends out an IR message, using SendMessage(), to the other robot. Then it waits for a 
reply by repeatedly calling Message(). The robot also backs up and turns to the left or right to move around the robot it has 
st tagged. This movement is accomplished by setting the tagCommand variable. 
ju
 
g receives an acknowledgement from the other robot, it add
r settin
the robot's curren
g of output B is used to contain 
CX to view the output B setting: 
ctDisplay(5); 
s set the power of outp
ower(OUT_B, score); 
UT_B); 
 the counter runs from only 1 to 7, so the maximum score is
nds out a tag message but doesn't receive a reply, it doesn't
R tag message, or the robot bum
other robot did not receive the I
boTag by Matthew Miller, the aren
nal 
other robot's IR port. 

 
183
In our design, tag doesn't do anything if a reply is not received. This opens up the possibility of adding physical obstacles to 
the arena. If the robot bounces into something that doesn't respond to the tag message, it must be an obstacle. 
 
The next behavior is avoid, which helps the robot to avoid the edge of the playing arena. It is triggered by the light sensor. 
task avoid() { 
Wait(20); 
avoidCommand = COMMAND_REVERSE; 
// Turn left or right for a random duration. 
m(1) == 0) avoidCommand = COMMAND_LEFT; 
and = COMMAND_RIGHT; 
); 
OMMAND_NONE; 
The 
which is triggered when the IR port receives notification that the robot has been 
tagge
bot to send an IR acknowledgement, play a sad sound, and sit still for eight seconds. 
 
aggedCommand = COMMAND_STOP; 
age(MESSAGE_ACKNOWLEDGE); 
; 
Command = COMMAND_NONE; 
Arbi
 
As m
 additional task is needed to link the robot's behaviors to its motors. In this implementation, a task 
calle
mines the output command variable of each behavior. If it is not COMMAND_NONE, it is used to set 
the current motor command. 
This behavior backs up and turns to move away from the edge, much like tag. 
 
int avoidCommand; 
 
while(true) { 
if (LIGHT_SENSOR < averageLight - 3) { 
// Back away from the border. 
avoidCommand = COMMAND_FLOAT; 
Wait(50); 
if (Rando
else avoidComm
Wait(Random(200)
avoidCommand = C
} 
} 
} 
 
ghest-level behavior is tagged, 
hi
d. This behavior tells the ro
int taggedCommand; 
 
task tagged() { 
while(true) { 
if (Message() == MESSAGE_TAG) { 
t
SendMess
PlaySound(4); 
Wait(800)
ClearMessage(); 
tagged
} 
} 
} 
 
tration 
entioned earlier, an
d arbitrate exa

 
184
int motorCommand; 
 
task ar
whi
COMMAND_NONE) motorCommand = cruiseCommand; 
E) motorCommand = tagCommand; 
mmand != COMMAND_NONE) motorCommand = avoidCommand; 
 = taggedCommand; 
} 
} 
 
Note that the order i
ill overwrite the value of motorCommand and are 
thus higher-leve
haviors. For example, if both the cruise and tagged behaviors are attempting to control the robot, the 
tagged beha
uming the lower-level behavior, cruise. 
 
In this implem
motorCommand will be unchanged, and the robot will just 
continue doing
e, since cruiseCommand is always COMMAND_FORWARD. 
However, in a 
fault action at the beginning of the while 
loop in arbit
 
Where the rub
 
The arbitra
ntrolling the motors to a subroutine called motorControl(). 
All motorCon
orCommand and set the motors accordingly. Here it is: 
 
 
torControl() { 
if (motorCommand == COMMAND_FORWARD) 
+ OUT_C); 
ommand == COMMAND_REVERSE) 
 + OUT_C); 
OnF
} 
else if (motorCommand == COMMAND_RIGHT) { 
OnFwd(OUT_A); 
OnR
} 
else if
Off(OUT
else if (motorCommand == COMMAND_FLOAT) 
Float(OUT_A + OUT_C); 
} 
The 
tionship between arbitrate and motorControl is important. At first glance, you might think it makes sense to 
impl
 separate 
bitrate() { 
le(true) { 
if (cruiseCommand != 
if (tagCommand != COMMAND_NON
if (avoidCo
if (taggedCommand != COMMAND_NONE) motorCommand
motorControl(); 
s important. The commands in the end of the list w
l be
vior takes precedence by subs
entation, if no behavior asserts control, then 
id before. This isn't an issu
 whatever it d
different program, you might want to set motorCommand to a de
rate(). 
ber meets the road 
te task hands off the actual dirty work of co
trol() has to do is examine the value of  mot
sub mo
OnFwd(OUT_A 
orC
else if (mot
OnRev(OUT_A
else if (motorCommand == COMMAND_LEFT) { 
OnRev(OUT_A); 
wd(OUT_C); 
ev(OUT_C); 
 (motorCommand == COMMAND_STOP) 
_A + OUT_C); 
 
a
rel
ement motorControl as a

 
185
task. However, if 
lem is that arbitrate changes the value of 
motorCommand s
e it loops. As the value changes, motorControl responds by changing the 
motors' directions. 
 
We're really in
es
 at the end of each loop in arbitrate. Therefore, 
motorCo
o
is implemented as a subroutine and is called once each time at the end of the arbitrate loop. 
 
The RoboTag Program 
 
ce
 of implementing subsumption architecture, the rest of the programming is pretty simple. The 
bo
task to start up all the behavior tasks and, of course, arbitrate. It also uses the light 
senso
inerva (see Chapter 5, Minerva, a Robot with an Arm) to calculate a baseline value for the 
light senso
e edge of the 
arena. 
 
Here is the enti
 
 
// M
o
f
e COMMAND_NONE -1 
fine COMMAND_FORWARD 1 
E 2 
#def
#def
#def
 
// I
#define MESSAGE_TAG 33 
#define MESSAGE_ACKNOWLEDGE 6 
 
#def
#define LIGHT_SENSOR SENSOR_2 
 
int 
int 
 
int 
 
task cruise() { 
 COMMAND_FORWARD; 
100); 
} 
 
int tag
 
task ta
you do this, the robot "jiggles" badly. The prob
everal times each tim
ter
l 
ted only in the value of motorCommand
ntr
On
Ro
 you get through the details
Tag program uses its main 
r init
M
ialization code from 
r. When the light sensor reads lower than the average, the RoboTag robot can assume it's reached th
re code for RoboTag. You should download this program to both of the robots that will be playing.
ot
in
r commands. 
#de
de
#
#define COMMAND_REVERS
#define COMMAND_LEFT 3 
ine COMMAND_RIGHT 4 
ine COMMAND_STOP 5 
ine COMMAND_FLOAT 6 
R messages. 
ine
NSOR_1 
 BUMP_SENSOR SE
score; 
averageLight; 
cruiseCommand; 
cruiseCommand =
while (true) Wait(
Command; 
g() { 

 
186
while(true) { 
if (BUMP_SENSOR == 1) { 
// Say tag! 
SendMessage(MESSAGE_TAG); 
 to a stop. 
MMAND_FLOAT; 
 got an acknowledgement. 
PlaySound(3); 
re); 
e < 7) score = score + 1; 
} 
ack up. 
MMAND_REVERSE; 
dom duration. 
 = COMMAND_LEFT; 
ommand = COMMAND_RIGHT; 
Wait(Random(200)); 
} 
else tagCommand = COMMAND_NONE; 
} 
e) { 
if (LIGHT_SENSOR < averageLight - 3) { 
ay from the border. 
FLOAT; 
 COMMAND_REVERSE; 
Wait(50); 
// Turn left or right for a random duration. 
if (Random(1) == 0) avoidCommand = COMMAND_LEFT; 
else avoidCommand = COMMAND_RIGHT; 
Wait(Random(200)); 
avoidCommand = COMMAND_NONE; 
} 
} 
} 
 
int taggedCommand; 
 
task tagged() { 
while(true) { 
if (Message() == MESSAGE_TAG) { 
taggedCommand = COMMAND_STOP; 
// Coast
tagCommand = CO
Wait(20); 
// Check to see if we
if (Message() == MESSAGE_ACKNOWLEDGE) { 
SetPower(OUT_B, sco
On(OUT_B); 
if (scor
else PlaySound(2); 
ClearMessage(); 
// B
tagCommand = CO
Wait(50); 
// Turn left or right for a ran
1) == 0) tagCommand
if (Random(
else tagC
tagCommand = COMMAND_NONE; 
} 
 
int avoidCommand; 
task avoid() { 
while(tru
// Back aw
avoidCommand = COMMAND_
Wait(20); 
avoidCommand =

 
187
SendMessage(MESSAGE_ACKNOWLEDGE); 
PlaySound(4); 
Wait(800); 
ClearMessage(); 
taggedCommand = COMMAND_NONE; 
} 
orCommand; 
te() { 
) { 
iseCommand != COMMAND_NONE) motorCommand = cruiseCommand; 
tagCommand != COMMAND_NONE) motorCommand = tagCommand; 
if (taggedCommand != COMMAND_NONE) motorCommand = taggedCommand; 
OnFwd(OUT_A + OUT_C); 
e if (motorCommand == COMMAND_LEFT) { 
OnRev(OUT_A); 
OnFwd(OUT_A); 
OnRev(OUT_C); 
Off(OUT_A + OUT_C); 
} 
 
task main() { 
initialize(); 
 
cruiseCommand = COMMAND_NONE; 
tagCommand = COMMAND_NONE; 
avoidCommand = COMMAND_NONE; 
taggedCommand = COMMAND_NONE; 
 
start cruise; 
start tag; 
start avoid; 
start tagged; 
 
start arbitrate; 
} 
} 
} 
 
int mot
 
task arbitra
while(true
if (cru
if (
if (avoidCommand != COMMAND_NONE) motorCommand = avoidCommand; 
motorControl(); 
} 
} 
 
sub motorControl() { 
if (motorCommand == COMMAND_FORWARD) 
else if (motorCommand == COMMAND_REVERSE) 
OnRev(OUT_A + OUT_C); 
els
OnFwd(OUT_C); 
} 
else if (motorCommand == COMMAND_RIGHT) { 
} 
else if (motorCommand == COMMAND_STOP) 
else if (motorCommand == COMMAND_FLOAT) 
Float(OUT_A + OUT_C); 

 
188
sub initialize() { 
SetSensor(BUMP_SENSOR, SENSOR_TOUCH); 
SetSensor(LIGHT_SENSOR, SENSOR_LIGHT); 
ClearMessage(); 
score = 0; 
Fwd(OUT_B); 
} 
 runningTotal; 
 
void calibrateLightSensor() { 
// Take an average light readin
i = 0; 
runningTotal = 0; 
 < NUMBER_OF_SAMPLES) { 
ingTotal += LIGHT_SENSOR; 
 
Online Resources 
 
mattdm's Mindstorms stuff 
http://www.mattdm.org/mindstorms/
SelectDisplay(5); 
calibrateLightSensor(); 
 
#define NUMBER_OF_SAMPLES 10 
int i; 
int
g. 
while (i
runn
Wait(10); 
i += 1; 
} 
averageLight = runningTotal / NUMBER_OF_SAMPLES; 
} 
This is the original RoboTag web page, created by Matthew Miller. It contains the original source code and a couple of movies 
of RoboTag in action. 
 
Brooks' Subsumption Architecture 
http://ai.eecs.umich.edu/cogarch3/Brooks/Brooks.html
This page has some background on subsumption architecture. If you really want to learn more, however, you should look up 
Brooks' papers; they're an excellent read. 

 
189
10 
legOS 
 
 
In this chapter: 
 
• About legOS 
 
• Development Tools 
OS 
 powerful development tool available for the RCX.∗ If programming environments were cars, RCX Code 
-
er 
 your RCX in assembly language, C, or 
ur RCX, here's your chance. With legOS, you have direct 
s a lot of power here. 
he flip side, of course, is that legOS is harder to use than any of the other programming environments. Unless you're already 
 this chapter, I'll talk about what software you need to develop legOS programs and what alternatives are available. I'll 
 services and present some sample code. I won't attempt to describe C, which is well-documented in other 
ublications. If you don't already know C, you might want to work your way through a tutorial before reading this chapter. 
e that LEGO gives you. Like pbFORTH, it 
ffers full control of the RCX. If you're already familiar with C, you may be more comfortable running legOS than pbFORTH. 
 
Hello, leg
• 
 
• Function Reference 
 
• New Brains For Hank 
 
• Online Resources 
 
 
legOS is the most
would be a plastic tricycle, NQC would be a comfortable sport/utility vehicle, and pbFORTH would probably be an eco
conscious alcohol-burning car with a Grateful Dead bumper sticker. legOS would be a fire-breathing, smoke-snorting monst
truck with a roaring engine and no muffler. legOS offers you the ability to program
C++, If you've been wanting to implement a neural network on yo
control of the inputs and outputs, display, IR port, and memory of the RCX. There'
 
T
running Linux and using GNU development tools, you'll have to spend some time configuring your system to support legOS 
development. 
 
In
describe the legOS
p
 
About legOS 
legOS is replacement firmware that completely replaces the default RCX firmwar
o
 
∗ For updated information on legOS, please see http://www.oreilly.com/catalog/Imstorms/ . 

 
190
legOS is more of a library than an OS, in some ways. The programs you write are compiled with the legOS source code to 
roduce a firmware. To run your program you need to download the whole thing to the RCX. This makes for a clumsy 
inal emulator. 
 of tools so that you can leave legOS on the RCX and download 
new user programs to it. For now, though, no such facility exists. 
piler compiles your code with the legOS 
rmware downloader tool, like nqc or 
ever program you have created. 
p
development cycle: even though you're only changing your own code, you need to recompile with legOS and download the 
whole firmware each time. pbFORTH, by contrast, is an interpreter. You only have to download it once to the RCX; after that, 
you can program it using a term
 
As time passes, someone will probably write a rudimentary set
 
Figure 10-1 shows the architecture of legOS. On the PC side, some kind of cross com
code to produce a firmware. To get your program on the RCX, you need to use a fi
firmdl. Once downloaded, the firmware lives in the RAM of the RCX, running what
 
 
 
ve
 
You'
tools to work with legOS. (There is another possibility, as described in the sidebar, ''An 
Inno
ews is that the tools are free. The basic tool you need is a cross compiler, a tool that runs 
on one pla
table files for another. In this case, you want a cross compiler that runs on your PC and 
produces f
Figure 10-1. 
legOS software architecture 
 
De
lopment Tools 
ll need some heavy-duty 
vative Alternative.") The good n
u
tform but produces exec
. 
irmware for the RCX

 
191
legOS is built using egcs, the open-source successor to the GNU gcc compiler. To build legOS, you'll also need GNU's 
binutils package. These 
n for the RCX. I'll ex
tools are present on most Linux systems, but they must be reconfigured to support cross-
mpilatio
plain this process soon. 
 you're not
ng Linux, don't despair. On a Unix-like operating system, you can probably build egcs and binutils 
binutils. 
Cygwin 
ws instead, there is a way to make 
 GNU tools to Windows 95, 98, and 
ressed. If you're a Linux enthusiast 
 "Online Resources" section has more 
. You can recompile 
itself to make it into a cross compiler. 
 download someone else's binary version of the egcs cross compiler. 
OS involves running some Perl. You'll need to have Perl installed on your computer to make legOS 
ownloading Firmware 
co
 
If
 runni
yourself, or find someone who has binaries for your platform. See the "Online Resources" section later in this chapter for 
information on obtaining egcs and 
 
 
What if you're not running Linux or a Unix-like operating system? If you have Windo
Windows act like Linux. The Cygwin package from Cygnus Solutions is a port of many
NT. Like lots of GNU stuff, it's a little bulky. A full download is about 13 MB, comp
trapped in a Microsoft world, though, you'll definitely want to check this out. (The
information on obtaining Cygwin.) 
 
Setting Up egcs 
 
To compile legOS, you're going to need to configure egcs as a cross compiler for the RCX. There are two ways to do this: 
 
1
egcs 
 
2. You can
 
Obviously, the second option is a lot easier, if you can find somebody who's created the cross compiler for your particular 
platform. The "Online Resources" section at the end of this chapter lists web sites that contain instructions for recompiling 
egcs as well as the locations of popular binaries of the cross compiler. 
 
Oh, and Perl Too 
 
Part of compiling leg
programs. As before, Linux users probably have Perl lying around already. If you've installed Cygwin on your Windows 
machine, you'll need to go get Perl. See "Online Resources" for more information. 
 
D
 
Once you have successfully compiled something in legOS, you will need to download it to your RCX to run it. To do this, you 
need a small utility that's called a 

 
192
firmware downloader. This piece of software uses the IR tower to transfer firmware to your RCX. 
 
Two firmware downloaders are readily available. Dave Baum's nqc. described in Chapter 4, Not Quite C, is capable of 
 
 
 
 
 
 
 
 
An Innovative Alternative 
 
 the complexity of setting up tools for legOS is making you sad, there's a creative 
ou the result, which you can then download to your RCX. This completely sidesteps 
oss compiler. This solution is useful even for 
latforms that don't support the GNU tools. As long as you have a web browser, you  
mpilers are here: 
om/web-legOS.html
downloading firmware files to the RCX, using the -firmware option. Another option is Kekoa Proudfoot's firmdl, which 
is available as a C source file. 
 
 
If
solution. Two kind individuals have set up web-based legOS compilers. All you do is 
submit your source code. Across the Internet, a machine compiles the code and sends 
y
 the whole problem of obtaining a cr
p
can compile legOS programs. 
 
The web-based cross co
 
http://www.dwarfrune.c
 
pile-legOS.html
https://vheissu.mersenne.com/~dbm/com
 
ls are working and give you a first taste of 
display briefly: 
 
delay(1000) ; 
return 0; 
} 
 
To run this example, first compile it. If you have the cross compiler installed locally, you just need to edit the legOS Makefile 
so that the TARGET line points to 
There are some downsides to this approach, as well: 
 
1. You have to fit your program into a single source file. 
 
2. You have to depend on someone else to keep the compiler running. 
 
3. You can't apply patches and tweak other things yourself. 
 
ello, legOS 
H
 
Let's begin with something simple. This will allow you to verify that your too
rogramming with legOS. The following program displays "Hello" on the RCX's 
p
 
#include "conio.h" 
 
int main(void) { 
cputs("Hello") ; 
lcd_refresh() ;

 
193
your source code.∗ For example, if you saved the source code above in a file called /projects/HellolegOS.cyou would edit the 
ectly, you'll end up with a HellolegOS.srec file in the 
me directory as the source file. 
re starting to c
ke a deep 
n do is look at LUGNET, http://www.lugnet.com
Makefile's TARGET like this: 
 
TARGET=/projects/HellolegOS 
 
Then type make at the command line. If everything is installed corr
sa
 
 
Trouble with Make 
 
If you can't make HellolegOS.c, and you'
urse at your computer, ta
breath. legOS has a strong online community; people will help if you ask. The "Online 
Resources" section of this chapter has pointers to helpful sites. One of the best things you 
ca
/, and search through the discussion 
grou
lem you're having. There are at least as many 
mess
he legOS development tools as there are about actually 
rogramming in legOS. 
py
 the web page and press the compile button. If there are no 
S program. 
e source file is compiled, you will then
e .srec file to the RCX, using either nqc or 
u just wrote, press the Run button. The display will show "Hello" for a second or so, then show two zeros. The 
ft number shows the result returned from our main() function. Control has now returned to legOS; you can use the On-
e RCX off and on. When the RCX is on, you can press Run again to see the "Hello'' message again. 
p archives for the particular prob
ages about configuring t
p
 
If you're using one of the online compilers,just co
 the source into
errors, you will get back an .srec file representing your compiled legO
 
Regardless of how th
 need to download th
firmdl. 
 
When the download is complete, your RCX will display the string "legOS" to indicate that legOS is running. To actually run 
the program yo
le
O
S
ff button to switch th
how your friends and family; they will be awed and inspired. 
 
Function Reference 
Once you've seen one RCX development environment, you've seen them all—to some degree, at least. If you've been reading 
through this book in order, you've probably noticed that NQC and pbFORTH have similar commands but different syntax. 
Likewise, legOS has a set of functions that looks a lot like pbFORTH and 
 
∗ Make sure you've edited Makefile.common. The TOOLPREFIX and LEGOS_ROOT lines should point to the appropriate 
directories on your system, as described in the comments. Make sure you put a trailing slash on the LEGOS_ROOT directory. 

 
194
NQC, but the syntax and usage is slightly different. In this section, I'll describe the important functions of legOS and 
emonstrate how they are used. 
here are, of course, different levels at which you can use legOS. I'll describe the "user-level" functions, meaning the functions 
ut what's inside legOS. If  you're looking for even more power, the full source code of 
gOS is freely available; you can read it, debug it, or reprogram it as much as you'd like.∗ 
sing the Display 
gOS is surprisingly capable when it comes to managing the disp
 the RCX. A
laying
bers, you 
can a
 
umbers and symbols (r
ost of the useful display functions are defined in rom/lcd.h. The first function you should learn is lcd_refresh(): 
id lcd_refresh(void) 
n. After you call any other display function, you must call lcd_refresh(): to 
tually update the display. 
 
To d
) 
e this function to show a number, i, on the display. The number style is one of sign, unsign or digit. Signed and 
g
the main display area, while digitshows a single digit on the right side of the display. The 
comm
(for use with the digit number style), e0, e_1, e_2 or e_3, indicating the number of 
digit
directly; rom/lcd.h includes definitions for four macros that simplify 
u) 
ue. Leading digits are padded with zero if necessary—for example, 123 is shown 0123. 
 code is subject to the Mozilla Public License (MPL), which is fully described at the following URL: 
d
 
T
you can call without knowing much abo
le
 
U
 
le
lay on
side from just disp
 num
sk legOS to approximate a text string using the display, as we did in the HellolegOS.c example. 
om/lcd.h) 
N
 
M
 
vo
This is the function that makes it all happe
ac
isplay a number, use lcd_number(): 
 
void lcd_number(int i, lcd_number_style n, lcd_comma_style c
Us
unsi ned numbers are shown in 
a style is digit_comma 
s to the right of the decimal point. 
 
In many cases, you won't need to call lcd_number () 
the process of displaying numbers: 
 
lcd_int(i) 
Use this macro to display a signed integer. Values over 9999 are shown as 9999. 
 
lcd_unsigned(
This macro displays an unsigned val
 
∗ The source
http://www.mozilla.org/MPL/ . 

 
195
lcd_c
This m
 display. The supplied number is shown as a time, with the decimal point 
betw
 
se this macro to display a single digit on the right side of the display. 
he RCX's display contains many symbols, as well— indicators for the outputs, inputs, datalog, battery level, download status, 
ontrolled individually: 
void 
Show
he lcd_segment enumeration is defined inrom/lcd.h; the comments in 
that 
e describe each segment type. To show the low battery indicator, for example, you would do this: 
_show(battery_x); 
lcd_refresh(); 
 
oid l
inally, to clean up when you're done playing, use lcd_clear(): 
oid lcd_clear(void) 
on clears the entire display. (You still have to call lcd_refresh() afterwards.) 
ogram is running, legOS will try to animate the running man. Keep this in mind as it may modify your display 
nexpectedly. 
 
Text
) 
ing text on the RCX: 
his function displays the supplied string, as nearly as possible. Only the first five characters of the string are shown. Letters 
 overall this is a great function for debugging. 
void 
se this method to display a character at the given position. Valid positions are 0 through 4, where 0 is the right-most position 
left-most position. 
his function displays the supplied value as four hexadecimal digits. 
lock(t) 
acro simulates showing a digital clock on the
e first two and last two digits. 
een th
lcd_digit(d) 
U
 
T
and others. Each display segment can be c
 
lcd_show(lcd_segment segment) 
 a single display segment with this function. T
fil
 
lcd
v
cd_hide(lcd_segment segment) 
This function hides a specific display segment. 
F
 
v
This functi
 
As your pr
u
, kind of (conio.h
 
The conio.h file defines several functions that are handy for display
 
void cputs(char ∗s) 
T
like "w" and "m" don't come out very well, but
 
cputc(char c, int pos) 
U
(the single digit at the right of the display) and 4 is the 
 
void cputw(unsigned word) 
T

 
196
Controlling Outputs (direct-motor.h) 
 
Controlling the outputs with legOS is very easy. All you need to do is give the output a direction and a speed. 
 
void motor_a_dir(Mo
 
 
et the direction of the RCX's outputs. The 
value can be 
, 
, 
, and 
. The 
ed char speed) 
ed char speed) 
id 
 
ED and MAX_SPEED if you wish. 
o
or_a_speed(MAX_SPEED); 
ork
irect-sensor.h) 
 
In le
hat nice input value processing in NQC and pbFORTH? In legOS, 
you 
and rotation sensors. The following macros return the raw value of 
the inp ts:
 
SEN
 
SEN
_2 
value of the corresponding input. BATTERY returns an indication of the battery 
ors to use the full range of raw input values. You might think a touch sensor would produce a value of 
0x0000 when it's pressed and 0xffff when it's not pressed, but the actual values are not as extreme. The rule of thumb for 
testing touch sensors is to test if the value falls below 0xF000, like this: 
 
∗ If you're accustomed to working with NQC, don't get confused here: off in legOS is the same as Float() in NQC, while 
torDirection dir) 
void motor_b_dir(MotorDirection dir)
 
void motor_c_dir(MotorDirection dir) 
 
These functions s
dir 
fwd rev brake
off
off 
mode is the same as Float() in NQC.∗ 
 
void motor_a_speed(unsign
 
void motor_b_speed(unsign
 
vo
motor_c_speed(unsigned char speed) 
These functions set the speed for the outputs. Of course, the speed only really matters when the output direction is fwd 
or rev. Values range from 0 to 255. You can use the handy constants MIN_SPE
 
T
 
o set outputs A and C running forward at top speed, do this: 
motor_a_dir(fwd); 
r_c_dir(fwd); 
mot
mot
motor_c_speed(MAX_SPEED); 
 
W
ing with Inputs (d
gOS, support for inputs is rudimentary. Remember all t
have t
for light 
o deal with the raw input values, except 
 
u
SOR_1 
SOR
 
SENSOR_3 
 
BATTERY 
 
Use these macros to retrieve the raw 
level. The raw values are in the range from 0x0000 to 0xffff. 
 
Don't expect sens
brake in legOS is the same as Off() in NQC. 

 
197
if (SENSOR_1 < 0xf000) { 
// Touch sensor is pressed. 
sors, legOS does offer some help. First, you can set inputs to be active or passive: 
sensors; 
mple, to set input 2 to be active, you would 
o produce a light sensor reading in the range from 0 to approximately 
LIGHT_MAX. 
 
legOS also supports rotation sensors with the following functions: 
 
void ds_rotation_
(unsigned∗ const sensor) 
 
void ds_rotation_off(unsigned∗ const sensor) 
 
These functions turn on or off rotation counting for the specified input. 
 
void ds_rotation_set(unsigned∗ const sensor, int pos) 
 
This function sets the current rotation count of the given input. 
 
Once you get the input set up for rotation, you can retrieve the rotation value with one of the following macros: 
 
ROTATION_1 
 
ROTATION_2 
 
ROTATION_3 
 
These macros return the rotation count for each of the inputs. 
 
Setting up input 3 for a rotation sensor, then, looks something like this: 
 
ds_active(&SENSOR_3); 
ds_rotation_on(&SENSOR_3); 
ds_rotation_set(&SENSOR_3, 0); 
 
To actually read the rotation value, you would just use the ROTATION_3 macro. 
} 
 
If you're working with light or rotation sen
 
void ds_active(unsigned∗ const sensor) 
 
void ds_passive(unsigned∗ const sensor) 
 
Use these functions to set the specified sensor to active or passive mode. The light and rotation sensors are active 
the touch and temperature sensors are passive. 
 
he argument to these functions is the address of one of the sensor values. For exa
T
do this: 
 
ds_active(&SENSOR_2); 
 
Processed light sensor values can be retrieved with the following macros: 
 
LIGHT_1 
 
LIGHT_2 
 
LIGHT_3 
 
These macros process raw input values t
on

 
198
 
 The rotation sensor code does not work in the March 30, 1999 build of legOS 0.1.7 
 
irect-button.h) 
nitions to describe the state of the front panel buttons: 
dicates the state of the RCX's four buttons. Use the following macros to interpret the 
state 
button
BUTTON_ONOFF, BUTTON_RUN, BUTTON_VIEW, and BUTTON_PROGRAM. 
For e
 of the View button: 
 
ate(), BUTTON_VIEW)) { 
 
To te
result of button_state(), like this: 
 
int 
state = button_state(); 
if (PRESSED (state, BUTTON_VIEW)) { 
// View button is pressed. 
} 
if (PRESSED(state, BUTTON_PROGRAM) ) { 
ton is pressed. 
} 
The 
ared Port (direct-ir.h) 
 
To s
tion: 
 
size_t dir_
 
This
ti
bytes of data from the supplied buffer out the IR port. It returns the number of bytes written or -1 if 
there is an error. 
Using the Buttons (d
 
gOS provides one function and some other handy defi
le
 
t button_state(void) 
in
This function returns a value that in
returned value. 
 
PRESSED(state, button) 
 
ELEASED(state, button) 
R
 
These macros return a boolean value indicating if the specified button was pressed or not. To use these macros, pass the 
result of button_state() as the 
parameter and the name of a button for 
. Buttons names are 
 
xample, the following code tests the state
if (PRESSED(button_st
// View button is pressed. 
} 
st the state of more than one button, it makes sense to store the 
state; 
// Program but
 
fr
In
end da
st use the dir_write() func
ta out the IR port, ju
write(void∗ const buf, size_t len) 
on writes len 
 func

 
199
. 
Th
 
Two functions are provided for reading data from the IR port: 
 
size_t dir_read(void∗ buf, size_t len) 
his method reads len bytes of data into the supplied buffer. It returns the number of bytes read or -1 if there is an error. 
ows it on the RCX's display. You can 
) 
pported in legOS through a reduced version of the standard Unix libraries. The basic idea is to set up some 
lf must be started with a call to tm_start(). 
ng the argc and argv parameters. The new task has 
T
 
void dir_fflush(void) 
The IR input is buffered, which means incoming data is placed in a buffer. When it fills up, it is made available to 
dir_read(). To force the contents of the input buffer to be available to dir_read(), first call dir_fflush(). 
 
ne of the legOS demos is tm-and-ir.c. This program listens for incoming IR data and sh
O
type into a terminal emulator on your PC and see the data show up on the display. 
 
Multitasking in legOS (unistd.h and sys/tm.h
 
Multiple tasks are su
number of tasks using the execi() function. Then the task manager itse
 
pid_t execi(int (∗code_start)(int, char∗∗), 
∗∗
 int argc, char 
argv,priority_tpriority, size_t stack_size) 
This function starts the task described by code_start. Don't worry about the nasty-looking syntax above; all you have to do 
s pass the name of a function. You can pass information to the task usi
i
the given priority and stack size. Lower priorities take precedence over higher priorities. In general, you can pass 0 for the 
priority and DEFAULT_STACK_SIZE as the stack size. This function returns a process identification number (PID). You can 
op a task, as you'll see later, using this number. 
st
 
e dir_write() function does not work in the March 30, 1999 build of legOS 0.1.7 
o  execi() is  too  small, all  sorts of weird behavior results. If your program 
e of the first things you should check. 
r, a function's return addresses and automatic variables (declared in the scope of the function) are 
 calls, or many automatic variables, or large arrays as 
  
If the stack size you pass t
 
  
crashes, this is on
 
 
 
 
Remembe
 
 
 
stored on the stack. If you have many levels of function
 
automatic variables, you may overrun your stack. 

 
200
void tm_start(v
Use this fu
o
 manager. 
 
Once
 running, new tasks can be started (with execi()), and running tasks can be stopped with this 
funct
 
void kill(p
 this function to stop the task represented by pid. 
You 
wing two functions: 
 
unsig
d in
This funct
 
unsigned i
d int msec) 
This 
ct
ution for the given number of milliseconds (ms). 
 
Here is a si
e that uses two tasks. The first task shows "Hello" and "nurse" on the display. The second task just 
waits
k ends, and control returns 
to legOS. 
 
nc
h" 
nc
-button.h" 
nc
td.h" 
c
tm.h" 
1) { 
ts("Hello"); 
} 
while (!PRESSED (button_state(), BUTTON_RUN)); 
d); 
} 
 
int main() { 
pid = execi(&display_task, 0, NULL, 0, DEFAULT_STACK_SIZE); 
execi(&stop_task, 0, NULL, 0, DEFAULT_STACK_SIZE); 
oid) 
n to start up the task
ncti
 the task manager is
ion: 
id_t pid) 
Use
 
can suspend tasks for a given amount of time with the follo
ne
t sleep(unsigned int sec) 
ion suspends execution for the given number of seconds. 
nt msleep(unsigne
fun ion suspends exec
mple exampl
 for the 
button
Run 
 to be pressed. When it is pressed, the first task is stopped, the second tas
#i
lude "conio.
lude "direct
#i
#i
lude "unis
lude "sys/
#in
 
pid-t pid; 
 
int display_task(int argc, char ∗∗argv) { 
while(
cpu
lcd_refresh(); 
sleep(1); 
cputs("nurse"); 
lcd_refresh(); 
sleep(1); 
} 
return 0; 
 
int stop_task(int argc, char ∗∗argv) { 
msleep(200); 
kill(pi
return 0; 

 
201
tm_start(); 
 
return 0; 
} 
and stop_task(). The process ID of th
splay task is saved away in the pid variable so that it can 
e stopped later. The last thing main() does is call tm_start() to start the task manager, which actually handles running 
Run button to be pressed. When the button is pressed, stop_task() calls kill() to 
op the display process. What's that call to msleep() at the beginning of stop_task()? When legOS first boots on the 
tton to be pressed. As soon as it is, your program is started. It's very possible that 
efore you have a chance to take your finger off the Run button. The call to 
ive you a chance to release the Run button. 
 It alternates between displaying "Hello" and "nurse" on the display, looping 
 c aner ay o
): 
a) 
y wakeup is called, with data as a parameter, until it 
) will return. 
following is a rewrite of the previous 
ent() instead of a while loop: 
#include "conio.h" 
#include "direct-button.h" 
 "unistd.h" 
 "sys/tm.h" 
isplay_task(int argc, char ∗∗argv) { 
hile(1) { 
(1); 
 
Let's start at the bottom and work our way up. The main() method uses execi() to start the two tasks: 
display_task() 
e di
b
the tasks. 
 
The stop_task() waits for the 
st
RCX, it's waiting for the Run bu
stop_task() will already be running b
sleep() simply delays a little while to g
m
 
The display_task() is straightforward.
forever until it is killed by stop_task(). 
 
Waiting (unistd.h) 
 
For a le
w
 t  wait for specific events, consider wait_event(
 
wakeup_t wait_event(wakeup_t (∗wakeup)(wakeup_t), wakeup_t dat
se this function to wait for a specific event. The function pointed at b
U
returns a non-zero result. At this point, wait_event(
 
It's not hard to use wait_event(), but it's certainly not obvious. It helps to look at some of the examples that come with 
legOS. The 
example that uses wait_ev
 
#include
#include
 
pid_t pid; 
 
int d
w
cputs("Hello"); 
lcd_refresh(); 
sleep
cputs("nurse"); 
lcd_refresh(); 

 
202
sleep(1);  
} 
} 
wakeup_t button_press_wakeup(wakeup_t data) { 
SSED(button_state(),data); 
 
int stop_task(int argc, char ∗∗argv) { 
 
wait_event(&button_press_wakeup, BUTTON_RUN); 
 
; 
previous example was replaced with a call to  
en function, button_press_wakeup(), does the dirty work of checking the state of the button. 
 should have about 26K left for your program and its data. 
nnot be allocated, NULL is returned. 
id ∗calloc(size_t nmemb, size_t size) 
ach size bytes long. It also sets each byte of the 
emory to zero. Like malloc(), it returns NULL if something goes wrong. 
When you are done with memory you've allocated, you should free it using this function. 
return 0; 
 
return PRE
}
 
msleep(200); 
kill(pid); 
return 0; 
} 
 
int main() { 
pid = execi(&display_task, 0, NULL, 0, DEFAULT_STACK_SIZE); 
execi(&stop_task, 0, NULL, 0, DEFAULT_STACK_SIZE); 
 
tm_start(); 
 
return 0
} 
 
ll that happened in this code was that the while loop from the 
A
wait_event. The giv
 
Memory (stdlib.h) 
 
You can request chunks of memory in the RCX using the familiar malloc() and calloc() functions. LegOS, by itself, 
kes up about 5K or 6K of the RCX's 32K of RAM. You
ta
 
void ∗malloc(size_t size) 
This function allocates a chunk of memory of the given size (in bytes). A pointer to the memory is returned. If the memory 
ca
 
vo
This function allocates enough memory for nmemb chunks of memory, e
located m
al
 
void free(void ∗ptr) 

 
203
 Sound (rom/sound.h and direct-sound.h) 
 
You can play one of the RCX's built-in ''system" sounds with the following function: 
 
void sound_system(unsigned nr) 
This function plays one of the system sounds of the RCX. The nr parameter describes the sound; it can be any of the values 
shown in Table 10-1. 
 
Table 10-1. sound_system() Sound Numbers 
 
Sound Number   
Description 
 
0   
 
 
 
 
Short beep 
 
1   
 
 
 
 
Two medium beeps 
 
2   
 
 
 
 
Descending arpeggio 
 
3   
 
 
 
 
Ascending arpeggio 
 
4   
 
 
 
 
Long low note 
 
5   
 
 
 
 
Quick ascending arpeggio (same as 3 but f ster) 
a
 
 
urthermore, you can play any sound you want using this function: 
F
 
void ds_play(unsigned char ∗sample, unsigned length) 
 
This function plays the sound data described by sample, using length bytes of data. The sample data should be 1 bit, 8 
Hz data. 
k
 
. 
 
Othe
 
legO
sting features. In this section, these functions are organized by the header file in which 
they 
 
In st
 
legO
er generator with the following two functions: 
 
long
This
 number. 
 
void 
Use t
e pseudorandom number generator. 
_system() nor ds_play() works in the March 30, 1999 build of legOS 0.1.7
Unfortunately, neither sound
r Goodies 
S has a grab-bag of other intere
e defined. 
ar
dlib.h 
S supports a simple random numb
 int random(void) 
 function returns a pseudorandom
srandom(unsigned int seed) 
his function to provide a new seed for th

 
204
In st
 
Ther
 text strings: 
 
char
rcpy(char ∗dest, const char ∗src) 
 
int strlen(const char ∗s) 
 
int strcmp
 
These are t
 
In time.h 
 
You can retrieve the 
d up using the sys_time variable. It's got a limited 
range; the coun
e
 
In rom/system.
Your programs have
X off or even obliterate legOS and your program from 
memory, using these 
 
void power_off(void)
This function p
h
ode. 
 
void 
 
This
 the RCX to its out-of-the-box state, essentially blowing away legOS and your program. This is really only 
usefu
you want to load some new firmware on the RCX. Use with care! 
 
New
In th
ram. It's a program for a slightly modified version of Hank, the robot from 
Chap
 to do is mount the light sensor on the front of Hank and attach it to input 2. 
This light
ers allow him to avoid obstacles. Figure 10-2 shows a 
picture of 
 
Hank
e
ing subsumption architecture. The basic structure of the program is similar 
to th
bsumption architecture example presented in Chapter 9, RoboTag, a Game for Two Robots, although the syntax is 
some
 
Hank
 is produced by the interaction of three behaviors: 
 
• cr
 
• seek_e
es of the light sensor. If the values are decreasing, generally speaking, this 
behavior a
t. 
ring.h 
e are also functions for working with
∗ st
(const char ∗s1, const char ∗s2) 
he standard string copy, length, and compare functions. 
number of milliseconds since the RCX was powere
ts once every 49.7 days. 
t res
h 
 tremendous power in legOS. You can turn the RC
functions: 
 
e RCX into its low power consumption "off" m
uts t
rom_reset(void)
ctions resets
 fun
if 
l 
 Brains for Hank 
is section I'll present a longer example prog
r 2, Hank, the Bumper Tank. All you need
te
 sensor will allow Hank to search for light, while the bump
Hank, newly fitted with the light sensor. 
's n
su
w legOS program will be implemented us
e 
what different. 
's light-seeking proclivity
uise, as in the RoboTag program, constantly tries to move forward. 
nlightenment() examines the valu
to turn Hank back toward the ligh
ttempts 

 
205
 
 
Figure 10-2. 
Hank, retrofitted with a light sensor 
 
• avoid() is the hi
rs and does the standard back-up-and-turn. 
 
Convincing Hank 
our own algorithm in 
seek_enlighten
u can concentrate solely on light-seeking 
behavior in seek_e
y programmed in a different behavior and 
will subsume the ligh
 
Without further ado, here'
 
#include "coni
#include "dire
#include "dire
#include "direct-sensor.h" 
#include "u
#include "s
 
#define
 
pid_t pid[MAX_TASKS]; 
int task_index; 
efine BACK_TIME 500 
 
#def
ghest-level behavior. It is triggered by the bumpe
to seek light is surprisingly hard. You can, of course, implement y
ment(). It's a neat feature of subsumption architecture that yo
tacle avoidance behavior is alread
nlightenment(). The obs
t-seeking behavior as necessary. 
s the entire program, LightSeeker.c: 
o.h" 
ct-button.h" 
ct-motor.h" 
nistd.h" 
ys/tm.h" 
 MAX_TASKS 32 
 
#d
#define TURN_TIME 800
 
// Motor commands. 
#define COMMAND_NONE -1 
1 
ine COMMAND_FORWARD 

 
206
#define COMMAND_REVERSE 2 
efine COMMAND_LEFT 3 
#def
 
int avoid_command; 
 
int avo
v) { 
avoid_command = COMMAND_NONE; 
while(1
MAND_REVERSE; 
MAND_RIGHT; 
); 
MMAND_NONE; 
} 
if (SENSOR_3 < 0xf000) { 
OMMAND_REVERSE; 
MAND_LEFT; 
mmand = COMMAND_NONE; 
} 
} 
return 0; 
} 
 
#define RAW_DARK 0x7c00 
#define RAW_LIGHT 0x6000 
int process_light(int raw) { 
 
long big = 100 ∗ (long)raw - RAW_LIGHT); 
long percent = big / (RAW_DARK - RAW_LIGHT); 
return 100 - (int)percent; 
} 
 
int seek_command; 
 
#define FUDGE 5 
 
int wait_for_better(int baseline, unsigned long milliseconds) { 
int current; 
int saved_time = sys_time; 
do { 
msleep(50); 
current = process_light(SENSOR_2); 
lcd_int(current ∗ 100 + baseline); 
lcd_refresh(); 
} while (sys_time < (saved_time + milliseconds) 
&& current < (baseline + FUDGE)); 
if (current >= (baseline + FUDGE)) return current; 
return -1; // Timed out. 
} 
#d
#define COMMAND_RIGHT 4 
ine COMMAND_STOP 5 
id(int argc, char ∗∗arg
) { 
if (SENSOR_1 <0xf000) { 
avoid_command = COM
msleep(BACK_TIME); 
avoid_command = COM
msleep(TURN_TIME
avoid_command = CO
avoid_command = C
msleep(BACK_TIME) 
avoid_command = COM
msleep(TURN_TIME); 
avoid_co

 
207
int seek_enlightenment(int argc, char ∗∗argv) { 
int baseline, current, loop_count, result; 
 
seek_command = COMMAND_NONE; 
 
// Get a baseline. 
baseline = process_light(SENSOR_2); 
 
loop_count = 0; 
 
while(1) { 
msleep(50); // Slow things down a little. 
// Every so often, increase the baseline. 
if (++loop_count == 5) { 
if (baseline < 100) baseline++; 
loop_count = 0; 
} 
current = process_light(SENSOR_2); 
lcd_int(current ∗ 100 + baseline); 
lcd_refresh(); 
// If the current value is somewhat less than the baseline… 
if (current < (baseline - FUDGE)) { 
// Set the baseline from the current value. 
baseline = current; 
// Search for something better. 
if (sys_time % 2 == 0) seek_command = COMMAND_LEFT; 
else seek_command = COMMAND_RIGHT; 
result = wait_for_better(baseline, 1000); 
if (result == -1) { 
// If that timed out, search back the other direction. 
if (seek_command == COMMAND_LEFT) seek_command = COMMAND_RIGHT; 
else if (seek_command == COMMAND_RIGHT) seek_command = 
COMMAND_LEFT; 
result = wait_for_better(baseline, 2000); 
if (result != -1) baseline = result; 
// If there's nothing better, bail. 
} 
// Set the new baseline. 
else baseline = result; 
} 
// Relinquish control. 
seek_command = COMMAND_NONE; 
} 
return 0; 
} 
 
int cruise_command; 
 
int cruise(int argc, char ∗∗argv) { 
cruise_command = COMMAND_FORWARD; 
while (1) sleep(1); 
return 0; 
} 

 
208
int motor_command; 
 
void motor_control() { 
motor_a_speed(MAX_SPEED); 
motor_c_speed(MAX_SPEED); 
 
switch (motor_command) { 
case COMMAND_FORWARD: 
motor_a_dir(fwd); 
motor_c_dir(fwd); 
break; 
case COMMAND_REVERSE: 
motor_a_dir(rev); 
motor_c_dir(rev); 
break; 
case COMMAND_LEFT: 
motor_a_dir(rev); 
motor_c_dir(fwd); 
break; 
case COMMAND_RIGHT: 
motor_a_dir(fwd); 
motor_c_dir(rev); 
break; 
case COMMAND_STOP: 
motor_a_dir(brake); 
motor_c_dir(brake); 
break; 
default: 
break; 
} 
} 
 
int arbitrate(int argc, char ∗∗argv) { 
while(1) { 
if (avoid_command != COMMAND_NONE) cputc('a', 0); 
else if (seek_command != COMMAND_NONE) cputc('s', 0); 
else if (cruise_command != COMMAND_NONE) cputc('c', 0); 
else cputc(' ', 0); 
lcd_refresh(); 
 
if (cruise_command != COMMAND_NONE) motor_command = cruise_command; 
if (seek_command != COMMAND_NONE) motor_command = seek_command; 
if (avoid_command != COMMAND_NONE) motor_command = avoid_command; 
motor_control(); 
} 
} 
 
int stop_task(int argc, char ∗∗argv) { 
int i; 
 
msleep(200); 
while (!PRESSED(button_state(), BUTTON_RUN)); 
 
for (i = 0; i < task_index; i++) 

 
209
kill(pid[i]); 
return 0; 
} 
 
void exec_helper(int (∗code_start) (int,char∗∗)) { 
pid[task_index++] = execi(code_start, 0, NULL, 0, DEFAULT_STACK_SIZE); 
} 
 
int main() { 
task_index = 0; 
 
exec_helper(&avoid); 
exec_helper(&seek_enlightenment); 
exec_helper(&cruise); 
 
exec_helper(&arbitrate); 
 
execi(&stop_task, 0, NULL, 0, DEFAULT_STACK_SIZE); 
 
tm_start(); 
 
return 0; 
} 
 
LightSeeker.c is a relatively large program, but it consists of easily understandable pieces. As before, I'll start at the bottom and 
work backwards through the source code. 
 
The main() function simply serves to start the other tasks in the program. A helper function, exec_helper(), is used to 
start the three behavior tasks, avoid(), seek_enlightenment (), and cruise(). exec_helper() is also used to 
start the arbitrate() task, which examines the output of the three behaviors and sends the appropriate command to the 
motors. The exec_helper() function simply starts each task using execi() and stores the returned process ID in an 
array. Back in main(), stop_task() is also started. When the Run button is pressed, stop_task() simply goes 
through the process ID array that exec_helper() built and kills each process. 
 
arbitrate() examines the output commands of each behavior. If the command is not COMMAND_NONE, the current motor 
command is set from the behavior. The later behaviors, of course, will overwrite the motor command. The last behavior, 
avoid(), is at the highest level. If it chooses to control the robot, Seek_enlightenment() and cruise() have 
nothing to say about it. 
 
To make it clearer what's going on while the robot is running, arbitrate() writes a character to the display that indicates 
which behavior is currently active. A "c" on the right side of the display indicates that cruise() has control, an "s" stands 
for seek_enlightenment(), and an "a" shows that the avoid() behavior is controlling the robot. 

 
210
When arbitrate() has determined the motor command, it uses motor_control() to interpret the command and to 
actually set the direction and speed of the outputs. This design is very similar to the design of the NQC RoboTag program, 
from Chapter 9. 
 
The cruise() behavior is simple; it just sets its command variable to COMMAND_FORWARD ad infinitum. 
 
The next behavior, seek_enlightenment(), is not so simple. The basic idea, however, goes like this: 
 
if I'm seeing darker stuff than I've just been seeing 
look to either side for something brighter 
 
seek_enlightenment() implements this with the idea of a baseline. The initial baseline is taken straight from the light  
sensor reading: 
 
baseline = process_light(SENSOR_2); 
 
The behavior then enters an endless loop, examining the value of the light sensor. If it falls too far below the baseline, 
seek_enlightenment() asserts control and searches for brighter light: 
 
current = process_light(SENSOR_2); 
if (current < (baseline - FUDGE)) { 
 
To search for brighter light, seek_enlightenment() first sets a new baseline from the current light value: 
 
baseline = current; 
 
Then the robot turns left or right, more or less randomly using the system clock: 
 
if (sys_time % 2 == 0) seek_command = COMMAND_LEFT; 
else seek_command = COMMAND_RIGHT; 
 
A helper function, wait_for_better(), is used to wait for a brighter light than the new baseline: 
 
result = wait_for_better(baseline, 1000); 
 
It's entirely possible that the robot will not find any brighter light. In this case, it times out (after 1000 milliseconds) and returns 
-1. In this case, the robot will turn back in the opposite direction and search for brighter light: 
 
if (result == -1) { 
if (seek_command == COMMAND_LEFT) seek_command = COMMAND_RIGHT; 
else if (seek_command == COMMAND_RIGHT) seek_command = COMMAND_LEFT; 
 
The wait_for_better() helper function is again used with a longer timeout: 
 
result = wait_for_better(baseline, 2000); 

 
211
In either search, if a better value is found, it is used as the new baseline: 
 
if (result != -1) baseline = result; 
} 
else baseline = result; 
} 
 
That's the basic algorithm. There is one extra feature that makes everything run a little smoother: every so often the baseline 
value is incremented. This means that if the robot is stuck in a dark corner, it will eventually get dissatisfied (because of the 
increasing baseline) and look for something better. 
 
To communicate with the outside world about what's going on, seek_enlightenment() shows the current light value as 
well as the current baseline on the display. The current value is shown in the first and second digits of the display, while the 
baseline is shown in the third and fourth digits. (Remember that the letter on the right side of the display tells you which 
behavior is currently active.) You can actually see the baseline increasing slowly as the program runs. 
 
I've implemented my own light sensor processing in process_light(). I didn't use legOS's LIGHT_2 macro because the 
values I was getting from it were not in the range from 0 to 100. Perhaps this is a bug that will be fixed in an upcoming release. 
At any rate, I implemented my own sensor data processing to produce a value from 0 to 100. You may need to adjust the 
RAW_DARK and RAW_LIGHT constants for your particular light sensor. 
 
The avoid() behavior is very simple. It just checks the touch sensors on inputs 1 and 3. If one of the touch sensors is 
pressed, avoid() backs the robot up and turns it a little. 
 
Development Tips 
 
legOS has serious programming power, but it has its rough spots, too. This section contains some helpful advice based on my 
own experience developing with legOS. 
 
Development Cycle 
 
legOS's development cycle is a little clumsy. You write a program, compile it with the legOS source code, then download the 
whole thing to the RCX. It's the downloading that takes a long time.  
Here are some tips to make things go smoother: 
 
1. Always include code that terminates your own program. If your program can stop itself, control returns to legOS. When 
legOS has control, you can turn the RCX on and off and even reinitialize the firmware, as described next. 

 
212
2. When legOS has control of the RCX, you can press and hold the Prgm button, then press the On-Off button. This blows 
away legOS (and your program) and returns control of the RCX to the ROM. You'll need to do this before you can download a 
new set of firmware to the RCX. 
 
3. If your program doesn't stop itself and give control back to legOS, you'll need to erase the firmware by removing a battery. 
If your program has a bug and does not terminate, you'll need to remove a battery to reset the RCX. 
 
4. Sometimes, through a bug in legOS or in your program, the RCX cannot be initialized by removing the batteries for just a 
few seconds. You will need to remove the batteries from your RCX and wait for a minute or so before the firmware is erased. 
Some circuitry keeps the RCX's memory alive; in some cases, you need to wait for the circuitry to drain completely before the 
firmware will be erased. 
 
If the endless code-compile-download-reset cycle is getting you down, you might consider using an emulator. An emulator is a 
special program that runs on your development PC but acts like an RCX. You can test your programs on the emulator much 
faster than you can test them on an actual RCX. Currently one legOS emulator exists; see the "Online Resources" section for 
details. 
 
Debugging 
 
The display is your best friend when it comes to debugging. legOS offers an impressive array of display functions. You can 
show words that indicate which part of your program is executing or display the contents of variables. Of course, there's not a 
lot of space to work with, but you could easily display a series of values for a short time. You could even write debugging code 
that lets you cycle through data by pressing a button. 
 
Unexpectedly Static Variables 
 
One of the craziest things about legOS development is that global variables retain their value from one time you run your 
program to the next. This is very important—it means that variables you initialize at declaration time are initialized only once, 
when your program is first loaded on the RCX. Use the following program to convince yourself: 
 
#include "conio.h" 
int x = 44; 
int main(void) { 
lcd_int(x); 
lcd_refresh(); 

 
213
x++; 
delay(1000); 
return 0; 
} 
 
The value shown on the display will be 44 the first time the program is run, but it goes up by one each subsequent time, even 
when you turn the RCX off and on again. This interesting property was the source of several bugs in the original LightSeeker.c 
program.  
 
If you really want to initialize a variable each time your program is run, you should do it explicitly in the code somewhere, like 
this: 
 
#include "conio.h" 
 
int x; 
 
int main(void) { 
x = 44; 
lcd_int(x); 
lcd_refresh(); 
x++; 
delay(1000); 
return 0; 
} 
 
If you look back at LightSeeker.c, you'll see that all the variable initialization is done explicitly. In general, it should ring a 
warning bell in your head when you see variables that are initialized at declaration time. 
 
Online Resources 
 
legOS 
 
legOS 
 
http://www.noga.de/legOS/
This is the official home page of legOS, written by Markus Noga. You can download files, browse the documentation, see 
installation instructions, and browse related web pages. 
 
LegOS HOWTO 
 
http://arthurdent.dorm.duke.edu/legos/HOWTO/HOWTO.html
Luis Villa has created a comprehensive set of information about legOS at this site. It covers the tools you'll need, where to get 
them, and how to install them. It also talks about programming in legOS and includes useful links to the online 
MINDSTORMS community. 

 
214
Another Low-level Tool 
 
RCX Tools 
 
http://graphics.stanford.edu/~kekoa/rcx/tools.html
This page contains a link to librcx, a C library for interacting with the RCX's ROM routines. It was developed by Kekoa 
Proudfoot, who did most of the original reverse engineering work on the RCX. 
 
Development Tools 
 
egcs project home page 
 
http://egcs.cygnus.com/
This is the home page for egcs, the compiler you'll need for legOS. The full package is 11 MB (compressed!). 
 
Binutils—GNU Project—Free Software Foundation (FSF) 
 
http://www.gnu.org/software/binutils/binutils.html
This is the home page for binutils, which you'll also need to compile legOS. Compressed, it's about 5 MB;  uncompressed, 
it's around 25 MB. 
 
Cygwin 
 
http://sourceware.cygnus.com/cygwin/
If you want to make Windows look like Linux, try the Cygwin package from Cygnus Solutions. Like egcs and binutils, 
it's free. 
 
Perl.com—Acquiring Perl Software 
 
http://www.perl.com/pub/language/info/software.html
This is the place to visit if you need Perl for your system. It has links to versions of Perl for most platforms. 
 
emulegOS 
 
http://www.geocities.com/~marioferrari/emulegos.html
Originally developed by Mario Ferrari, this legOS emulator has been enhanced by Mark Falco and Marco Beri. It comes in two 
versions. The Windows version requires Borland's C++ Builder 3.0. The Linux version uses Tcl/Tk. Like legOS, this is not for 
the faint of heart, but it looks like it could be very useful. 
 
Installation Help for Windows Users 
 
Lego Knees 
 
http://www.beesknees.freeserve.co.uk/lego/
Gavin Smyth wrote this helpful page about installing the legOS development tools under Windows 95, 98, or NT. It includes 
links to various files you'll need. 

 
215
Installing legOS—the unauth, unofficial Lego RCX firmware 
 
http://ex.stormyprods.com/lego/legOS.html
This page, created by Brain Stormont, also details the steps you'll need to follow to install a legOS development environment 
under Windows 95. It includes useful links to the relevant software. 
 
Web-Based Cross Compilers 
 
Web-LegOS 0.1 
 
http://www.dwarfrune.com/web-legOS.html
This page, maintained by Shawn Menninga, compiles your source code. The resulting.srec file can be displayed as HTML or 
emailed to you. 
 
Compile legOS RCX code 
 
https://vheissu.mersenne.com/~dhm/compile-legOS.html
This is Dave Madden's web-based legOS compiler. 
 
Firmware Downloaders 
 
firmdl.c 
 
http://graphics.stanford.edu/~kekoa/rcx/firmdl.c
One popular firmware downloader is firmdl. Written by Kekoa Proudfoot, the source code is available in C and should 
compile on most platforms. 
 
NQC—Not Quite C 
 
http://www.enteract.com/~dbaum/lego/nqc/index.html
This is the home page for NQC. It's listed here because nqc can be used to download legOS programs. 

 
216
11 
Make Your Own Sensors 
 
 
If you're not afraid of a soldering iron, you can create your own robot sensors. Although you can buy the ''official" sensors 
from the LEGO online store or LEGO DACTA (see the Appendix A, Finding Parts and Programming Environments), there's 
not a very wide selection. Furthermore, they are expensive—$10US for the touch sensor, $20US for a light sensor, $15US for 
the rotation sensor, and $25US for the temperature sensor. Building your own sensors is a great way to expand your robot's 
capabilities without spending a lot of money. 
 
This chapter describes different ways of fitting sensors into LEGO bricks, provides discussions of various types of sensors you 
can build, and considers some innovative possibilities for putting multiple sensors on one RCX input. 
 
Mounting 
 
The first thing you should think about is how you are going to attach your new sensors to the LEGO world. There are two 
goals to consider here: 
 
1. The sensor, ideally, should be a LEGO brick itself so you can easily attach it to your robots. The sensors that come with RIS 
exhibit this property: the touch sensors and the light sensor are simply specialized bricks. 
 
2. The sensor needs to connect electrically to the RCX. Somehow the electrical connections from the sensor circuit will need to 
mate with the RCX's input connections. There are four basic approaches—cut wire, copper tubing, machine screws, and a 
conductor plate—which are described in the following sections. 
 
In this chapter: 
 
• Mounting 
 
 
• Passive Sensors 
 
 
• Powered Sensors 
 
 
• Touch Multiplexer 
 
 
• Other Neat Ideas 
 
 
• What About Actuators? 
 
 
• Online Resources 
 
 

 
217
Cut Wire 
 
The simplest approach to attaching a new sensor is to cut one of the wire bricks that comes with RIS. Figure 11-1 shows half of 
one of these wire bricks. 
 
 
 
Figure 11-1. 
A wire brick yields two connectors like the one shown here 
 
You can wire the cut end directly to your sensor. Each wire brick therefore yields two connectors that you can use to make 
your sensors compatible with the RCX. If you don't want to ruin your perfect set, you can order additional wires from Pitsco 
LEGO DACTA (800-362-4308), although you'll pay dearly for them. 
 
Copper Tubing 
 
The studs (or "bumps") on LEGO bricks are exactly 3/16 inch in diameter. You can use 3/16" copper tubing, available at 
hobby stores, to replace studs in a regular LEGO brick. In essence, the tubing acts as an electrically conductive LEGO stud. 
Using the tubing, you can build a sensor into a brick and use the regular "wire bricks" that come with RIS to attach the sensor 
to the RCX. 
 
The basic procedure is to drill out two of the studs in a regular brick. The n you push the tubing through the holes up as far as a 
regular stud. The sensor or sensor circuit can be soldered to the part of the tubing that's inside the brick. You should place the 
tubing in diagonally opposite studs; this ensures that an electrical connection is made no matter which way the sensor is 
attached to the RCX. 
 
Michael Gasperi's excellent web site describes this technique clearly. For details, see the "Online Resources" section at the end 
of this chapter. 
 
Machine Screws 
 
Using machine screws is a variation on the copper tubing method. Instead of replacing studs with tubing, you replace them 
with 4/40 machine screws, which 

 
218
have a head that is 3/16" in diameter. You can use pan head or round head machine screws, but the pan head is shaped more 
like a LEGO st d. Instead of drilling out the stud, just shave off the top of it, so that it's level with the surface of the brick. 
Then you can drill a hole and thread the screw down into the brick. An example of this technique is shown at 
http://www.kabai.com/lego/lego.htm
u
 . Again, you should replace diagonally opposite studs so that the sensor will be connected 
to the RCX, regardless of the orientation of the wire brick. 
 
You'll see an example of this technique later. In the meantime, here are some construction tips: 
 
1. Begin by shaving off two diagonally opposite studs on the brick. A hobby tool like a Dremel™ rotary tool or Black and 
Decker Wizard™ works well for this purpose if you have cutting disks for it.  
 
2. Now make sure the screw heads are the right size. Some 4/40 machine screws have heads that are larger than a LEGO stud. 
You can adjust the diameter of the screw by mounting it in a drill (with the head facing out). Turn on the drill and use a file to 
reduce the diameter of the head. With round head machine screws, you may also need to flatten the top of the head. You can 
test your modifications by trying to place the head of the screw in the bottom of a wire brick. You should only have to push it a 
little bit to get it to fit. 
 
3. Solder a short wire to the tip of each screw before you put the screws in the brick. There are two very good reasons for this. 
It takes a lot of heat to solder on to the screws, so you don't want to either melt the plastic around the screws by soldering them 
in-place, or burn out the sensor you're mounting by soldering it directly to the screws. 
 
4. Thread the wires you just soldered to the screws into the holes in the top of the brick. Now turn the screws into the brick—
they should thread nicely into the holes. 
 
5. Now you're ready to mount your sensor in the brick and solder its leads to the screw wire from Step 3. Make sure to use heat 
sinks so you don't undo your previous work or damage the sensor. 
 
Conductor Plate 
 
Another technique for attaching sensors to the RCX's inputs is based on special conductive plates. These plates are available as 
an accessory pack, #5037, from the LEGO Shop-at-Home service (800-453-4652). The kit, which is $6.75US, comes with 
several plates to which you can attach your sensor electronics. This technique is fully described at: 
http://www.akasa.bc.ca/tfm/lego_temp.html . 

 
219
Passive Sensors 
 
There are several simple passive sensors that attach directly to the inputs of the RCX. These are the simplest do-it-yourself 
sensors because you don't need any interface circuitry to make their output comprehensible to the RCX. 
 
A Peaceful Demonstration 
 
To really understand passive sensors, it's helpful to see a diagram of one input of the RCX in passive mode: 
 
 
 
In passive mode, the sensor connected to the input is essentially a resistance. It forms a 
voltage divider with Rinput. The A/D converter in the RCX converts the analog voltage to a 
digital raw input value from 0 to 1023. The A/D converter itself has a resistance, Rad, but 
it's so small you probably don't have to worry about it. The two diodes limit the voltage that 
can be seen by the A/D converter; this makes it hard to damage the RCX by hooking 
something up incorrectly. 
 
Touch Sensors 
 
Touch sensors are the easiest kind of sensors to make. Any kind of contact switch is appropriate, and no special circuit is 
necessary. All you need to do is attach the switch leads to the input somehow. 
 
Browse the pages of a catalog from Jameco (800-831-4242) or Digi-Key (800-344-4539) and you'll find a dizzying array of 
contact switches. 
 
Another interesting possibility is using a mercury switch as a touch sensor. A mercury switch has a sealed bulb that contains a 
drop of mercury. When the switch is oriented the right way, the mercury drop connects the two switch leads together. Figure 
11-2 shows a photograph of a mercury switch; you may have seen ones with clear bulbs in your thermostat. The LEGO brick is 
shown for scale. 

 
220
 
 
Figure 11-2. 
A mercury switch 
 
The mercury switch works just like a contact switch. When the switch is correctly oriented, the two leads are shorted together. 
It's basically a primitive angle sensor. In a thermostat, for example, the mercury switch is used to indicate two states: either it's 
less than the desired angle or greater than the desired angle. The desired angle in a thermostat corresponds to the temperature 
setting you've chosen. 
 
Light Sensors 
 
The light sensor that comes with RIS is a powered device; it emits light using an LED, and senses light with a phototransistor. 
The phototransistor responds to changes in light, but it must be powered. A slightly simpler device, a photoresistor, can be 
used to build a passive light sensor. The photoresistor responds to changes in light by changing its resistance. This is a perfect 
candidate for an RCX sensor. Basically all you have to do is hook up the leads of the photoresistor to one of the RCX inputs. 
 
Radio Shack sells Cadmium Sulfide (CdS) photoresistors that work well as robot sensors. Figure 11-3 shows a photograph of 
one such photoresistor mounted in a brick using the machine screw mounting method. 
 
 
 
Figure 11-3. 
A CdS photoresistor mounted in a brick 
 
The machine screws were mounted on the brick as described previously. All that remained was to mount the photoresistor 
itself in the brick. To do this, two holes were made for the leads of the photoresistor. Then the leads were threaded through to 
the inside of the brick and soldered to the wires that were already there. These wires were previously attached to the screws. 
The extra wire can be pushed up inside the brick. Figure 11-4 shows a photograph of the bottom of the same photoresistor 
sensor. 

 
221
 
 
Figure 11-4. 
A bottom view of the CdS photoresistor sensor 
 
You can make holes for the sensor leads using a small drill. If you don't have one of these, you can heat a wire with a soldering 
iron and push it through the side of the brick, creating a small hole. 
 
Although LEGO's light sensor is a powered device, the CdS photoresistor is a passive device. This means that you can't blindly 
configure the photoresistor input as a light sensor input. You should, instead, make sure the sensor is not powered and read the 
raw input values. 
 
In NQC, for example, you can configure the input as follows: 
 
SetSensorType (SENSOR_1, SENSOR_TYPE_TOUCH); 
SetSensorMode (SENSOR_1, SENSOR_MODE_RAW); 
 
You'll have to experiment to find out what kind of values you get for different lighting conditions. Darker lighting will produce 
higher sensor readings, while bright lighting produces lower sensor readings. 
 
Temperature Sensors 
 
A simple device called a thermistor can be used to make a temperature sensor. The thermistor has a resistance that changes 
according to the temperature. By measuring the resistance of the thermistor, you can figure out the temperature. 
 
Thermistors are widely available and cost only a couple of dollars each. Chances are, however, that your device won't have the 
same electrical characteristics as the official temperature sensor. Thus, your temperature readings will be off slightly. If you are 
concerned about correct temperature readings, rather than just sensing increases and decreases in temperature, you may want to 
convert raw sensors readings into temperature values yourself. 
 
Powered Sensors 
 
It's a little harder to attach a powered circuit to the RCX. Remember, there are only two wires connecting the RCX to each of 
its sensors. For powered sensors, these wires alternately power the sensor and read its value. 

 
222
Active Sensor Magic 
 
The designers of the RCX pulled some magic out of their electrical engineering bag to 
enable active sensors. The following figure shows a diagram of an RCX input in active 
mode: 
 
 
 
The active mode circuit looks a lot like the passive mode circuit, except for the 8V power 
supply. Conceptually, at least, there's a switch S that closes for three milliseconds at a time 
to supply power to the sensor. At the end of every power intervals, the switch opens for 0.1 
millisecond, and the RCX takes a reading from the input. 
 
The 8V that is supplied to the active sensor is an approximate number; the actual value 
depends on the juice in your batteries. The difference between fresh and used batteries can 
produce any voltage in the range from about 6.5V to 8.5V. Many electronic circuits are 
happy with 5V or more, so this may not be an issue for you. But it's something you should 
be aware of. 
 
Signal Splitter 
 
The input wires carry power and sensor signals at the same time. Furthermore, the polarity of the signals may be reversed, 
depending on how the sensor is attached to the RCX. Remember how the direction of the motors depended on how they were 
attached to the RCX? The same problem applies to sensors and sensor circuits, but a special circuit makes it irrelevant which 
way the sensor is hooked up. 
 
Six diodes are sufficient to separate out the power and signal on an input. These six diodes make up a circuit called a signal 
splitter. The circuit makes sure that all the electrons go in the right directions so your sensor circuit gets power and the RCX 
gets a sensor reading. Diodes are used to steer the electrons the correct way 

 
223
so that it doesn't matter which way the active sensor is attached to the input on the RCX. Figure 11-5 shows how to set up the 
diodes.∗ 
 
 
 
Figure 11-5. 
A signal splitter 
 
Remember, power is only applied for 3 ms at a time, punctuated by .1 ms sensor readings. You will need to smooth out the 
power supply with a capacitor, as shown in Figure 11-5. 
 
The Touchless Touch Sensor 
 
This section describes how to build an interface circuit for a Hall effect sensor. A Hall effect sensor is triggered by the 
presence of a magnetic field. If you place a small magnet near the sensor in the proper orientation, it will trigger. The sensor 
itself is very small and looks like a transistor. Figure 11-6 shows a photograph of a Hall effect sensor. 
 
 
Figure 11-6. 
A Hall effect sensor 
 
 
∗The signal splitter is really a combination of two circuits, a bridge rectifier and a current router. The bridge rectifier ensures 
that power is correctly supplied to the active sensor; it consists of the left four diodes in Figure 11-5. The current router ensures 
that the sensor signal is supplied with the correct polarity to the input on the RCX. The right two diodes in Figure 11-5 make 
up the current router. 

 
224
Not all Hall effect sensors are created equal. Some have on-board circuitry that processes the sensor's signal and converts it to 
a boolean electrical signal. Some respond to one polarity of magnetic field; some respond to both. Read the fine print closely 
when you buy a Hall effect sensor. 
 
The circuit presented in this section is built around a "sticky" Hall effect sensor (Digi-Key part number DN6847SE-ND). This 
sensor responds to both magnetic polarities. One polarity turns the sensor on, and the other turns it off. The on or off setting 
"sticks" until the opposite magnetic field is applied. The processing circuitry is all built into the sensor. Hooking up the sensor 
to the RCX is a matter of applying the signal splitter circuit from the previous section, as shown in Figure 11-7. 
 
 
Figure 11-7. 
A Hall effect sensor circuit 
 
 
Once the sensor is hooked up, you can read boolean values from the appropriate input. Remember, though, you need to 
configure the input for a powered sensor. In NQC, it looks like this: 
 
SetSensorType(SENSOR_3, SENSOR_TYPE_LIGHT); 
SetSensorMode(SENSOR_3, SENSOR_MODE_BOOL); 
 
How you use this sensor is, of course, up to you. You could build the Hall effect sensor and the signal splitter circuit into a 
large LEGO brick. Then you could build small permanent magnets into other LEGO bricks. This would give you a flexible 
system, suitable for building limit switches, counters, or anything you can imagine. 
 
Touch Multiplexer 
 
No matter what software you're running, the RCX still has only three inputs and three outputs. Short of using another RCX, 
what can you do if you want to use 

 
225
more than three inputs or outputs? On the input side, at least, there are some tricks. Chapter 5, Minerva, a Robot with an Arm, 
describes some ways of putting more than one sensor on a single input. It's possible to put multiple switches on a single input, 
but you can't tell which of them was pressed when a touch occurs. 
 
A simple circuit allows you to hook up four switches to a single input and detect them individually. This circuit is called a 
touch multiplexer, because it mashes three input signals into one. This idea was originally suggested by Paul Haas; one 
implementation is documented nicely at Michael Gasperi's web site. 
 
Note that this method uses regular switches, not the LEGO touch sensors. The touch sensors that come with RIS provide a 
varying resistance as they are pressed. A garden variety switch is much more of a binary device, which is better suited to our 
touch multiplexer. 
 
The touch multiplexer is based on a fundamental concept in electronics: the combination of different resistances. Michael 
Gasperi's design combines resistors in parallel. The touch multiplexer I'll describe here combines resistors in series, which 
simplifies the math.∗ The basic circuit is shown in Figure 11-8. 
 
 
 
Figure 11-8. 
The touch multiplexer circuit 
 
Pressing a single switch shorts out the corresponding resistance, which reduces the raw input value. Because each touch sensor 
has a different resistance, the touch sensors each reduce the raw input readings by recognizable amounts. Note that the resistors 
roughly double in value as you move from left to right. This makes it easier to interpret the results of the touch multiplexer. 
 
Each combination of switches produces a unique resistance, which results in a unique raw input value. By examining the raw 
input values in your robot's program, you can figure out which touch sensors were pressed. 
 
You can convert the raw value to a resistance with the following equation, where raw is the raw input value: 
 
 
 
∗John Tamplin deserves the credit for this idea. 

 
226
Once you've got the resistance, and assuming you have a binary progression of resistors, you can convert the input resistance to 
a bitmask of switch presses with this equation: 
 
 
 
The bitMask will contain four bits of information, one for each switch. Each bit is 0 when the switch is closed (pressed) and 
1 otherwise. 
 
The raw input value depends on the battery voltage. As the batteries drain, the raw reading will become lower, which means 
that the calculated value of R becomes lower. Adding 1/2 in the previous equation (and rounding to an integer) helps 
compensate for this and allows the touch multiplexer to work until the batteries are about half-drained. 
 
Other Neat Ideas 
 
This chapter has presented some simple sensors you can build yourself, but there are many other possibilities. Michael 
Gasperi's web site (listed in the ''Online Resources") has several outstanding ideas. Once you've built the signal splitter (Figure 
11-5), you can attach any old electronic circuit to the RCX's inputs. Michael Gasperi has built several interesting sensors based 
around the use of operational amplifiers (op amps). 
 
The first of these is sound sensor. This sensor can detect sounds like hand claps; you can program your robot to respond to 
sound. Basically, this circuit uses an op amp to amplify the signal from a microphone. 
 
Michael has also built a differential light sensor. This sensor actually contains two photoresistors and some circuitry. The 
circuitry interprets the signals from the two photoresistors and sends a signal to the RCX that indicates the balance of light 
between the two photoresistors. This process allows you to easily build a robot that seeks light. 
 
What About Actuators? 
 
I've talked a lot about building sensors; why not build actuators too? LEGO only offers two actuators: motors and lights. The 
lights aren't very practical and usually serve only a decorative purpose, although it's possible you could use them to signal 
other robots. 

 
227
Outside the tidy world of LEGO MINDSTORMS, however, robots have all sorts of different actuators. Three good  
possibilities for do-it-yourself actuators are servo motors, solenoids, and Shape Memory Alloy (SMA) wire: 
 
servo motors 
Servo motors are special motors that are used in radio controlled cars and airplanes. They are actually an assembly of a motor, 
some gearing, and some electronics. In response to an electronic signal, they rotate an output shaft to a certain angle. 
Interfacing a servo motor to the RCX is a matter of making the RCX produce the right signal. You'll probably also need a 
power supply for the servo. 
The bottom line, however, is that you can get just as much done with a LEGO motor and a LEGO rotation sensor. The whole 
point of a servo is that it rotates to a precise angular position; but that's just as easy to do with a motor coupled to a rotation 
sensor. As a matter of fact, the LEGO-only solution is more flexible. While a servo has only a limited range of angular motion, 
the motor and rotation sensor have no such constraints. 
 
solenoids 
A solenoid converts electrical power into a small linear motion. You can harvest solenoids from discarded fax machines and 
cassette players, or buy them new from a supplier like Jameco. 
 
SMA wire 
Shape Memory Alloy is a special kind of metal that changes shape dramatically when it's heated. You can buy wires that 
contract when they are heated. Conveniently, you can heat SMA wires by passing current through them. SMA wire should be 
simple to interface to the RCX's outputs. Note, however, that heated SMA wire can melt LEGO bricks—mounting the SMA 
wire may be a challenge. 
 
Online Resource 
 
General Information 
 
Mindstorms Sensor Input 
 
http://www.plazaearth.com/usr/gasperi/lego.htm
This is the definitive online resource on the inputs of the RCX. It contains a wealth of information about the inputs themselves, 
the official LEGO sensors, and sensors you can build yourself. It's full of schematic diagrams, graphs, explanations, and links 
to other people's RCX sensor web pages. 

 
228
Toy building block with electrical contacting portions (US4552541) 
 
http://www.patents.ibm.com/details?pn=US04552541
This is the patent that describes the clever scheme used by the input and output connectors on the RCX, the sensors, the 
motors, and the wire bricks. Did you ever wonder why you can attach wires and sensors in any orientation and still make a 
connection? This patent explains the system. 
 
Mounting Methods 
 
Homebrew Temperature Sensor 
 
http://www.plazaearth.com/usr/gasperi/temp.htm
Michael Gasperi's temperature sensor uses the copper tubing method of sensor mounting. This page has a clear description of 
the technique. Putting the tubing on diagonally opposite studs would make this sensor more generally useful. However, the 
basic technique is very well illustrated. 
 
LEGO 
 
http://www.kabai.com/lego/lego.htm
This page has brief instructions for building a sound sensor for the RCX. It demonstrates the machine screw mounting method. 
However, the screws are not mounted on diagonally opposite studs, which would make them more useful. 
 
TFM's Lego Page - Lego Mindstorms Compatible Temperature Sensor 
 
http://www.akasa.bc.ca/tfm/lego_temp.html
This page describes the construction of a temperature sensor using the conductor plate mounting method. 
 
Tools 
 
Black and Decker 
 
http://www.blackanddecker.com/powertools.htm
Black and Decker makes a tool called the Wizard. With a cutting disk, it's useful for shaving the studs off LEGO bricks. 
 
Welcome to Dremel International 
 
http://www.dremel.com/
Dremel makes hand tools that are good for working with small things like LEGO bricks. 

 
229
Electronics Parts Suppliers 
 
Jameco Electronics: Home 
 
http://www.jameco.com/
This is the web site of Jameco, where you'll find goodies like switches, Hall effect sensors, bend sensors, diodes, resistors, and 
other great stuff. 
 
Digi-Key Corporation Home Page 
 
http://www.digikey.com/
If there's something you can't find at Jameco (thermistors, for example), try Digi-Key instead. They have a huge selection and 
good service. 
 
Mouser Electronics, Distributor of Electronic Components 
 
http://www.mouser.com/
Here's another good supplier; their web site is a little easier to use than Digi-Key's. 

 
230
A 
Finding Parts and Programming Environments 
 
You can order sensors, motors, and other robot parts from several sources. Although you can probably find the Robotics 
Invention System (RIS) at a local toy store, you'll hardly ever see extra motors and sensors. 
 
LEGO Sources 
 
Table A-1 lists three places where you can get RIS accessories. 
 
Table A-1. Sources for LEGO Parts 
 
Name   
 
 
 
 
 
Telephone   
 
 
 
 
Web Site 
 
LEGO World Shop   
 
-   
 
 
 
 
 
 
 
http://www.legoworldshop.com/
 
LEGO Shop-at-Home   
Service (800) 453 – 4652 
  
- 
 
 
Pitsco LEGO DACTA   
(800) 362 - 4308   
 
 
 
http://www.pitsco-legodacta.com/
 
Pitsco LEGO DACTA sells LEGO's educational products, including RIS, a programming environment called ROBOLAB, 
classroom packages, and a fine assortment of spare parts. 
 
Parts 
 
Table A-2 lists the parts you may wish to buy along with their prices at the three sources shown in Table A-1. This information 
is current as of mid-1999. (LWS is LEGO World Shop, S@H is LEGO Shop-at-Home Service, and Pitsco is Pitsco LEGO 
DACTA.) Note that the Shop-at-Home Service does not charge extra for shipping, so the list is not exactly comparing apples to 
apples. 

 
231
Table A-2. Parts and Prices, in US Dollars 
 
Part   
 
 
 
 
 
 
 
Item   
Pitsco Item   
LWS   
 
S@H   
 
Pitsco 
 
 
Robotics Invention System   
 
9719   
N979719   
 
$219.00   
$219.00   
$219.00 
 
RoboSports expansion set   
 
9730   
-   
 
 
 
$49.99  
 
$54.00  
 
- 
 
Extreme creatures expansion set  9732   
-   
 
 
 
$49.99  
 
$54.00  
 
- 
 
 
RCX   
 
 
 
 
 
 
 
9709   
N979709   
 
$129.99   
$129.00   
$120.00 
 
IR cable for Macintosh   
 
 
-   
 
4119830   
 
-   
 
 
-   
 
 
$15 
 
Light sensor   
 
 
 
 
 
9758   
N979890   
 
$19.99  
 
$19.75  
 
$27.75 
 
Touch sensor   
 
 
 
 
 
9757   
-   
 
 
 
$9.99   
 
$11.00  
 
- 
 
Touch sensor (two wire bricks)   
-   
 
N779911   
 
-   
 
 
-   
 
 
$11.00 
 
Temperature sensor   
 
 
 
9755   
N979889   
 
$24.99  
 
$24.00  
 
$27.75 
 
Rotation sensor   
 
 
 
 
9756   
N979891   
 
$14.99  
 
$16.50  
 
$27.75 
 
Geared motor  
 
 
 
 
 
5225   
N775225   
 
$18.25  
 
$17.50  
 
$15.75 
 
Micro motor   
 
 
 
 
 
5119   
N775119   
 
-   
 
 
$11.00  
 
$10.00 
 
Standard motor   
 
 
 
 
5114   
N775114   
 
-   
 
 
$17.50  
 
$15.75 
 
 
Train motor   
 
 
 
 
 
5300   
-   
 
 
 
-   
 
 
$27.50  
 
- 
 
 
Remote control   
 
 
 
 
9738   
-   
 
 
 
$19.99  
 
$19.75  
 
- 
 
Electric plates  
 
 
 
 
 
5037   
N779886   
 
-   
 
 
$6.75   
 
$6.00 
 
Wire brick, 128 cm   
 
 
 
5111   
-   
 
 
 
-   
 
 
$4.50   
 
- 
 
Wire brick set  
 
 
 
 
 
-   
 
N779897   
 
-   
 
 
-   
 
 
$12.50 
 
Large turntables   
 
 
 
 
-   
 
N779876   
 
-   
 
 
-   
 
 
$9.75 
 
Other Suppliers 
 
Table A-3 lists suppliers for electronics parts. These are useful sources for the electronics described in Chapter 11, Make Your 
Own Sensors. 
 
Table A-3. Sources for LEGO Parts 
 
Name   
 
Telephone   
 
Web Site 
 
Jameco   
(800) 831 – 4242   
http://www.jameco.com/ 
 
Digi-Key   
(800) 344 – 4539   
http://www.digikey.com/  
 
Mouser   
(800) 346 – 6873  
http://www.mouser.com/
 
Programming Environments 
 
Table A-4 summarizes the development environments that are available for the RCX. 

 
232
Table A-4. RCX Development Environments (continued) 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   Replacement 
Name  
 
 
URL  
 
 
 
 
 
 
 
 
 
   Language  
Firmware? Price Host OS Tools Neededa 
 
Gordon´s Brick http://www.umbra.demon.co.uk/gbp.html  
   VB-like  
 
no  
 
 
Free 
Win32  
- 
 
 
 
 
 
 
 
MindControl  
http://homepages.svc.fcj.hvu.nl/brok/  
   VB-like  
 
no  
 
 
free 
Win32  
- 
legomind/robo/mindcontrol.html 
 
 
PRO-RCX 
 
http://prelude.psy.umontreat.ca/~cousined/  VB-like  
 
no  
 
 
free 
Win32  
- 
lego/robot/rcx/rcx_command/l  
 
 
 
 
 
 
 
BotCode  
 
http://www.desktopmusic.com/botcode.htm  VB-like  
 
no  
 
 
$20 
Win32  
- 
 
a. This column assumes you've installed the RIS software. Most of the Win32 packages work with Spirit.ocx, which is installed with the RIS 
software. 
 
b. Win32 means Windows 95, 98, or NT. 
 
c. VB-like means similar to Visual Basic. Function names are modeled on Spirit.ocx. 
 
 

 
233
Table A-4. RCX Development Environments 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Replacement 
Name  
 
   URL 
 
 
 
 
 
 
 
 
 
 
 
  Language Firmware? Price Host OS Tools Neededa 
 
RCX Code 
   -  
 
 
 
 
 
 
 
 
 
 
 
    (visual)  
no  
 
 
- 
 
Win32b 
- 
 
 
 
 
 
 
 
Not Quite C    http://www.enteract.com/~dbaum/lego/nqc/     NQC  
 
no  
 
 
free 
MacOS,  - 
(NQC)  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Linux, 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Win32 
 
 
 
 
 
 
 
MacNQC  
   http://www.enteract.com/~dbaum/lego/nqc     NQC  
 
no  
 
 
free 
MacOS 
 
 
 
 
   /macnqc/ 
 
 
 
 
 
ROBOLAB    http://www.lego.com/dacta/robolab  
 
    (visual)  
no  
 
 
$50 
MacOS, - 
   /defaultjava.htm   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Win32 
 
 
 
 
   http://www.ceeo.tufts.edu/graphics/robolab.html 
 
 
 
 
 
 
 
 
 
 
 
pbFORTH 
   http://www.hempeldesigngroup.com/lego/  
 Forth  
 
yes  
 
 
free 
Any 
 
Terminal  
   pbFORTH/  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
emulator 
 
 
 
 
 
 
 
legOS  
 
   http://www.netway.com/~rmaynard/   
 
    C,C++ 
 
yes  
 
 
free 
Linux,  
GNU egcs and
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Unix 
 
BrainStorm    http://www.netway.com/~rmaynard/  
 
    UCBLogo 
no  
 
 
free 
Win32  
UCBLogo 
 
 
 
 
 
 
 
Bot-Kit 
 
  http://www.object-arts.com/Bower/Bot-Kit/      Smaltalk  
no  
 
 
free 
Win32  
Dolphin  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Small-talk 
 
TclRCX  
   http://www.demailly.com/tcl/rcx/  
 
 
    Tcl 
 
 
no  
 
 
free 
MacOS,   
Linux,  
Unix 
Win32 
 
 
 
 
 
 
 
BrickCommand http://www.geocities.com/Area51/Nebula/    VB-likec  
no  
 
 
free 
Win32  
- 
 
 
 
 
 
8488/lego.html 
 
a. This column assumes you've installed the RIS software. Most of the Win32 packages work with Spirit.ocx, which is installed 
with the RIS software. 
 
b. Win32 means Windows 95, 98, or NT. 
 
c. VB-like means similar to Visual Basic. Function names are modeled on Spirit.ocx. 

 
234
Table A-4. RCX Development Environments 
 
Name URL Language 
 
a. This column assumes you've installed the RIS software. Most of the Win32 packages work with Spirit.ocx, which is installed 
with the RIS software. 
 
b. Win32 means Windows 95, 98, or NT. 
 
c. VB-like means similar to Visual Basic. Function names are modeled on Spirit.ocx. 

 
235
B 
A pbForth Downloader 
 
pbFORTH is a interesting, funky programming environment, but there are not many tools available for it. This appendix 
contains source code for a program downloader, written in Java. A program downloader enables you to develop your 
pbFORTH programs in a text editor and download them all at once to the RCX. This means you have a saved copy of your 
program that is easy to browse and modify. 
 
The program downloader presented here is a "smart" one; it analyzes the responses from pbFORTH to see if any errors occur 
as the download is progressing. If pbFORTH complains about something, the downloader tells you about it. 
 
System Requirements 
 
To compile and run this program, you'll need the Java Development Kit (JDK) version 1.1 or later (see 
http://java.sun.com/products/jdk/1.2/  for the latest version). You'll also need the Communications API, a standard extension 
API that enables Java programs to use the serial and parallel ports of a computer (see http://java.sun.com/products/javacomm/). 
 
Usage 
 
The program downloader is called Download. It's very simple to use—you just need to supply the name of the Forth source 
code file. For example, you can download a file like this: 
 
c:\>java Download thermometer.f 
............................ 
c:\> 

 
236
Download prints a period for each line of the file it downloads to the RCX. If there's an error, you'll hear about it like this: 
 
c:\>java Download thermometer.f 
.... 
Line 5: Error: redefine isRunButtonPressed RbuttonState ? undefined word 
c:\> 
 
By default, Download uses the COM1 port. If you are not running Windows, or if you have your IR tower attached to a 
different port, you can tell Download to use a different port like this: 
 
C:\>java Download -port COM3 thermometer.f 
 
Source Code 
 
 
import java.io.∗; 
 
import java.util.∗; 
 
 
import javax.comm.∗; 
 
 
public class Download { 
 
 
public static void main (String[] args) { 
 
 
 
String filename = args[args.length - 1]; 
 
 
 
String portName = "COM1"; 
 
 
 
 
for (int i = 0; i < args.length - 2; i++) { 
 
 
 
 
if (args[i].equals("-port")) portName = args[i + 1]; 
 
 
 
} 
 
 
 
 
try { new Download (filename, portName); } 
 
 
 
catch (NoSuchPortException nspe) { 
 
 
 
System.out.println("Sorry, I don't know about the " + 
 
 
 
 
portName + " port. "); 
 
 
 
} 
 
 
 
catch (PortInUseException piue) { 
 
 
 
 
System.out.println("Sorry, somebody else is using " + 
 
 
 
 
 
portName + "."); 
 
 
 
} 
 
 
 
catch (UnsupportedCommOperationException ucoe) { 
 
 
 
 
System.out.println(ucoe); 
 
 
 
} 
 
 
 
catch (IOException ioe) { 
 
 
 
 
System.out.println("An IOException occurred: " + ioe); 
 
 
 
} 
 
} 
 
 
private SerialPort mPort; 
 
private Reader mFileIn; 
 
private Writer mOut; 
 
private PortListener mPortListener; 
 
 
 
private static final int kCharSleep = 20; 

 
237
 
private static final int kTimeOut = 800; 
 
 
public Download(String filename, String portName) 
 
 
 
throws NoSuchPortException, PortInUseException, 
 
 
 
UnsupportedCommOperationException, IOException { 
 
 
initialize(portName); 
 
 
mFileIn = new FileReader (filename); 
 
 
run(); 
 
} 
 
 
protected void initialize(String portName) 
 
 
 
throws NoSuchPortException, PortInUseException, 
 
 
 
UnsupportedCommOperationException, IOException { 
 
 
CommPortIdentifier id = 
 
 
 
 
CommPortIdentifier.getPortIdentifier(portName); 
 
 
mPort = (SerialPort)id.open("Download", 1000); 
 
 
mPort.setSerialPortParams( 
 
 
 
 
2400, 
 
 
 
 
SerialPort.DATABITS_8, 
 
 
 
 
SerialPort.STOPBITS_1, 
 
 
 
 
SerialPort.PARITY_NONE 
 
 
); 
 
 
Reader in = new InputStreamReader(mPort.getInputStream()); 
 
 
mPortListener = new PortListener (in); 
 
 
mOut = new OutputStreamWriter(mPort.getOutputStream()); 
 
} 
 
 
public void run() { 
 
 
int c, n = 1; 
 
 
try { 
 
 
 
sendReturn(); 
 
 
 
sendReturn(); 
 
 
 
while ((c = mFileIn.read()) != -1) { 
 
 
 
 
if (c == '\r') { 
 
 
 
 
 
sendReturn(); 
 
 
 
 
 
if (mPortListener.isComplete() == false) { 
 
 
 
 
 
 
throw new DownloadException("Timed out waiting " + 
 
 
 
 
 
 
 
"for a response from the RCX."); 
 
 
 
 
 
} 
 
 
 
 
 
else if (mPortListener.isError() == true) { 
 
 
 
 
 
 
throw new DownloadException("Error: " + 
 
 
 
 
 
 
 
mPortListener.getLastLine()); 
 
 
 
 
 
} 
 
 
 
 
 
System.out.print("."); 
 
 
 
 
 
n++; 
 
 
 
 
} 
 
 
 
 
else if (c != '\n') { 
 
 
 
 
 
mPortListener.reset(); 
 
 
 
 
 
mOut.write(c); 
 
 
 
 
 
mOut.flush(); 
 
 
 
 
 
Thread.sleep(kCharSleep); 
 
 
 
 
} 
 
 
 
} 
 
 
 
sendReturn(); 

 
238
 
 
 
sendReturn(); 
 
 
} 
 
 
catch (InterruptedException ie) { System.out.println(ie) ; } 
 
 
catch (DownloadException de) { 
 
 
 
System.out.println(); 
 
 
 
System.out.println("Line " + n + ":"); 
 
 
 
System.out.println(" " + de.getMessage()); 
 
 
} 
 
 
catch (IOException ioe) { System.out.println(ioe); } 
 
 
 
// Regardless of what happened, try to clean up. 
 
 
try { 
 
 
 
mPortListener.stop(); 
 
 
 
mFileIn.close(); 
 
 
 
mOut.close(); 
 
 
 
mPort.close(); 
 
 
} 
 
 
catch (IOException ioe) {} 
 
 
System.exit(0); 
 
} 
 
 
protected void sendReturn() throws IOException, InterruptedException { 
 
 
mOut.write('\r'); 
 
 
mOut.flush(); 
 
 
Thread.sleep(kCharSleep); 
 
 
// Wait for response, or time out. 
 
 
long savedTime = System.currentTimeMillis(); 
 
 
boolean trucking = true; 
 
 
while (trucking) { 
 
 
 
if (mPortListener.isComplete()) trucking = false; 
 
 
 
long currentTime = System.currentTimeMillis(); 
 
 
 
if (currentTime - savedTime > kTimeOut) trucking = false; 
 
 
 
Thread.sleep(20); 
 
 
} 
 
} 
 
 
public class PortListener 
 
 
 
implements Runnable { 
 
 
private Thread mThread; 
 
 
private BufferedReader mIn; 
 
 
private boolean mComplete = false; 
 
 
private boolean mError = false; 
 
 
private String mLastLine; 
 
 
 
public PortListener (Reader in) { 
 
 
 
mIn = new BufferedReader(in); 
 
 
 
mThread = new Thread(this); 
 
 
 
mThread.start(); 
 
 
} 
 
 
 
public void run() { 
 
 
 
String line; 
 
 
 
try { 
 
 
 
 
while((line = mIn.readLine()) != null) { 

 
239
 
 
 
 
 
line = line.trim(); 
 
 
 
 
 
mLastLine = line; 
 
 
 
 
 
if (line.indexOf("ok") != -1) mComplete = true; 
 
 
 
 
 
if (line.indexOf("redefine") != -1) mComplete = true; 
 
 
 
 
 
if (line.indexOf("undefined") != -1) mComplete = mError = true; 
 
 
 
 
 
if (line.length() == 0) mComplete = true; 
 
 
 
 
} 
 
 
 
} 
 
 
 
catch (IOException ioe) { 
 
 
 
 
System.out.println("PortListener: ioe " + ioe); 
 
 
 
} 
 
 
} 
 
 
 
public void stop() throws IOException { 
 
 
 
mThread.interrupt(); 
 
 
} 
 
 
 
public void reset() { mComplete = false; mError = false; } 
 
 
public boolean isComplete() { return mComplete; } 
 
 
public boolean isError() { return mError; } 
 
 
public String getLastLine() { return mLastLine; } 
 
 
} 
 
 
public class DownloadException 
 
 
 
 
extends IOException { 
 
 
 
public DownloadException (String message) { super (message); } 
 
 
} 
 
} 
 

 
240
C 
Future Directions 
 
This appendix mentions several interesting technologies related to LEGO robots that didn't make it into the rest of the book. 
These are things either that weren't quite fully complete as the book went to press or that aren't entirely relevant to a general 
book on LEGO robots. 
 
RIS 1.5 
 
The first thing to look for, of course, is RIS 1.5. As of this writing (August 1999), there's been only a whisper of it, an off-hand 
mention in the discussion forums at the official LEGO MINDSTORMS web site. It's supposed to be released in the Fall of 
1999, but what actually comprises RIS 1.5 is anybody's guess. One person at LEGO technical support did say it is a 
softwareonly upgrade, not a change to the RCX. At this point, though, it's all rumors and speculation; keep your eyes peeled 
for real announcements. 
 
Java for the RCX 
 
You can program your RCX in C, C++, Smalltalk, Tcl, and Visual Basic; why not Java? The RCXJVM project aims to build a 
small Java Virtual Machine (JVM) and supporting classes for the RCX. It's based on a JVM developed for a different 8-bit 
microcontroller, the Motorola 68HC11. (That JVM reportedly was only 6k, which would certainly fit fine in the RCX's 32K of 
RAM.) 
 
LEGO Robots as JINI Devices 
 
JINI™ is a Java™-based standard from Sun Microsystems™. The basic premise of JINI is that devices should be able to 
connect and disconnect from networks seam- 

 
241
lessly. You should, for example, be able to plug your laptop computer into a hotel network jack somewhere and be able to use 
the printer, without going through a lot of network configuration gobbledygook. The network vision extends beyond these 
traditional devices, however, to things like mobile telephones, pagers, Personal Digital Assistants, and, of course, LEGO 
robots. A detailed article on this demonstration (including source code) is here: 
 
http://developer.javasoft.com/developer/technicalArticles/ConsumerProducts/JavaTanks/Javatanks.html
 
At one of the keynote speeches for the 1999 JavaOne conference, in fact, a demonstration of JINI included LEGO robots as 
JINI devices. Unfortunately, JINI doesn't actually run on the RCX. A proxy system is used instead, such that a JINI proxy runs 
on a PC, which, in turn, communicates with the robot over the IR link. However, it still makes for an interesting technology 
blend.Independent of the JavaOne demonstration, Jan Newmarch has written a JINI tutorial that includes examples with LEGO 
robots. You can read it for yourself here: 
 
http://pandonia.canberra.edu.au/java/jini/tutorial/jini.xml
 
LEGO Network Protocol 
 
LEGO Network Protocol (LNP) would allow two or more RCXs to communicate via their IR ports without prior configuration. 
While it is possible to exchange messages between multiple RCXs by reserving blocks of message numbers for specific RCX-
to-RCX conduits, it's not a generalized solution. LNP is a more general approach, but it's still a work in progress. For more 
information, see the discussion lists at LUGNET. Here's a discussion from mid-1999: 
 
http://www.lugnet.com/robotics/rcx/legos/?n=180&t=i&v=c
 

 
242
Index 
 
A 
 
actuators, 8 
 
building, 227 
 
AI (Artificial Intelligence), robotics and, 4 
 
ambient light, 49 
 
angular velocity, 33 
 
arbitration, 184 
 
architecture, subsumption, 204 
 
web site, 188 
 
arms 
 
grabber, 156 
 
mechanical, 105 
 
swing, 107 
 
Artificial Intelligence (AI), robotics and, 4 
 
autonomous robots, 3 
 
B 
 
balancing robots, 112 
 
batteries, retrieving current charge, 168 
 
beams, 15 
 
bevel gears, 32 
 
binutils package, 191 
 
web site, 214 
 
BotCode web site, 234 
 
Bot-Kit web site, 171 
 
bouncing, 153 
 
BrainStorm web site, 233 
 
BrickCommand, 233 
 
web site, 172 
 
building projects (see projects) 
 
bumpers, 31 
 

 
243
bushings, 15-16 
 
buttons, legOS functions for, 198 
 
C 
 
cars, 29-30 
 
conductor plate, attaching sensors with, 218 
 
constants, 166 
 
copper tubing, attaching sensors with, 217 
 
Crickets web site, 13 
 
cross-compiling, 191 
 
web sites, 215 
 
Cygwin package, 191 
 
web site, 214 
 
D 
 
datalog, 71 
 
retrieving, 168-171 
 
debouncing, 153 
 
delayed functions, 163 
 
differential, 30 
 
differential drives, 27 
 
differential light sensor, 226 
 
directional transmission, 107 
 
web site, 115 
 
display 
 
configuring 
 
NQC, 70 
 
pbFORTH, 128 
 
functions (legOS), 194-195 
 
drives 
 
differential, 27 
 
synchro, 30 
 
web site, 38 
 

 
244
tri-star, 37 
 
drivetrains, 112 
 
Droid Developer Kit, 10 
 
E 
 
egcs compiler, 191 
 
web site, 214 
 
E&L Group (Epistemology and Learning Group) web site, 13 
 
emulegOS web site, 214 
 
Epistemology and Learning Group (E&L Group) web site, 13 
 
Eureka web site, 13 
 
expansion sets, 10 
 
Exploration Mars, 10 
 
Extreme Creatures, 10 
 
F 
 
feelers (see touch sensors) 
 
firmdl, 144 
 
firmware, 116 
 
downloader, 192-193 
 
web sites, 215 
 
Forth programming language, 121-126 
 
FTP sites, 37 
examples in this book, xiii 
 
functions 
 
legOS, 194-204 
 
Spirit.ocx, 163 
 
G 
 
gear reduction, 34 
 
geared motors, 34 
 
gearing down, 34 
 
gears, 31-35 
 
worm, 108 
 
 

 
245
grabber arms, 156 
 
web sites, 115 
 
H 
 
Hall effect sensor, 223-224 
 
Hank, the Bumper Tank, 27-38 
 
instructions for building, 16-25 
 
programming, 204-211 
 
Hitachi web site, 81 
 
I 
 
idler wheels, 50 
 
If function (Spirit.ocx), 166-167 
 
immediate functions, 163 
 
infra-red data link, 7 
 
legOS, 198-199 
 
inlines, 75 
 
inputs 
 
input values, retrieving, 165-166 
 
legOS, 196-197 
 
web site, 227 
 
instructions for building 
 
Hank, the Bumper Tank, 16-25 
 
Minerva, 83-102 
 
remote control, 147-150 
 
RoboTag, 174-179 
 
thermometer, 137-138 
 
Trusty, a Line Follower, 40-44 
 
internal gearing, 34 
 
IR (infra-red) link, 7 
 
communications 
 
NQC, 70 
 
pbFORTH, 119 
 

 
246
J 
 
Java for RCX, 240 
 
JINI devices, robots as, 240 
 
K 
 
Killough platform web sites, 38 
 
-L 
 
Large Turntable piece, 30 
 
 
LEGO Group web site, 11 
 
LEGO Network Protocol web site, 157 
 
LEGO Shop at Home, 35 
 
LEGO Users Group Network (LUGNET) web site, 158 
 
legOS, 233 
 
debugging, 212 
 
development cycle, 211 
 
emulator, web site for, 214 
 
functions, 194-204 
 
static variables, 212 
 
web sites, 213 
 
light sensors, 113 
 
adding a second, 50 
 
building, 220-221 
 
differential, 226 
 
legOS, 197 
 
programming, 51 
 
in NQC, 79-80 
 
LightSeeker.c program, 205-211 
 
line following, 39 
 
Linux, 233 
 
locomotion, 27-35 
 
LUGNET (LEGO Users Group Network) web site, 158 
 
 
 

 
247
M 
 
machine screws, attaching sensors with, 217 
 
Macintosh platform, 233 
 
magnetic compasses, 114 
 
memory, requesting (legOS), 202 
 
micro motors, 34 
 
MindControl web site, 234 
 
MINDSTORMS, 6 
 
history of, xi 
 
web sites, 11 
 
Minerva 
 
instructions for building, 83-102 
 
programming, 103-107 
 
pbFORTH, 138-142 
 
remote control, 154-157 
MIT Programmable Brick web site, 13 
 
mobile robots, 2-6 
 
web sites, 37 
 
wheels, 27-35 
 
motors, 34-35 
 
servo, 227 
 
web sites, 38 
 
mounting sensors, 217-218 
 
multitasking, 36-37 
 
in legOS, 199-203 
 
NQC, 72-74 
 
music, 68-70 
 
N 
 
navigation, 114 
 
 
web site, 115 
 
Not Quite C (NQC), 233 
 
 

 
248
downloading, 54 
 
web sites, 143 
 
O 
 
online resources (see FTP sites; web sites) 
 
operators for If and While functions, 167 
 
outputs, controlling in legOS, 196 
 
P 
 
parts, ordering, 232 
 
(see also web sites) 
 
passive sensors, 219-221 
 
pbFORTH (Programmable Brick FORTH), 233 
 
debugging, 142-143 
 
program downloader, 235-239 
 
web sites, 143 
 
words, 126-137 
 
PBTurnOff function (Spirit.ocx), 168 
 
Perl, 191 
 
web site, 214 
 
Pitsco LEGO DACTA web sites, 38 
 
plates, 15 
 
Poll function (Spirit.ocx), 165-166 
 
power management, pbFORTH, 134 
 
powered sensors, 221-224 
 
program downloader, 9 
 
Programmable Brick FORTH (see pbFORTH) 
 
programming 
 
debugging, 142-143 
 
Hank, the Bumper Tank, 204-211 
 
legOS (see legOS) 
 
light sensors, 51 
 
 
 

 
249
Minerva, 103-107 
 
pbFORTH, 138-142 
 
remote control, 154-157 
 
multitasking, 72-74 
 
cooperative multitasking, 135-137 
 
in legOS, 199-203 
 
NQC (see NQC) 
 
pbFORTH (see pbFORTH) 
 
random numbers, 64 
 
remote control, 151-154 
 
RoboTag, 180-188 
 
Trusty, a Line Follower, 77-80 
 
projects 
 
Hank, the Bumper Tank, 204-211 
 
Minerva, 82-115 
 
projects (continued) 
 
remote control, 147-154 
 
RoboTag, 174-188 
 
Trusty, a Line Follower, 39-51 
 
pulleys, 109 
 
R 
 
random numbers, 64 
 
legOS, 203 
 
 
RCX Code, limitations of, 53 
 
RCX Command Center (RcxCC), 58 
 
web site, 81 
 
RCX (Robotic Command Explorer), 145-146 
 
programming environment, 9 
 
software architecture, 55-57 
 
turning off, 168 
 
web sites, 214 
 

 
250
RCXJVM, 240 
 
remote control 
 
instructions for building, 147-150 
 
programming, 151-154 
 
RIS (Robotics Invention System), 6-7 
 
history of, xi 
 
software, 9 
 
version 240 
 
web sites, 12 
 
Robolab software, 38 
 
Robosports, 10 
 
RoboTag, 173-188 
 
instructions for building, 174-179 
 
programming, 180-188 
web site, 188 
 
Robotic Command Explorer (see RCX) 
 
robotics 
 
Artificial Intelligence (AI) and, 4 
 
behaviors, 180 
 
small approach, 5 
 
web sites, 11 
 
Robotics Discovery Set, 10 
 
Robotics Invention System (see RIS) 
 
robots, 2-6 
 
balancing, 112 
 
rotation sensors, 114 
 
legOS, 197 
 
S 
 
SaveDatalog function (RCX), 168 
 
sensor watchers, 36 
 
 
 
 

 
251
sensors, 216 
 
legOS, 197 
 
mounting, 217-218 
 
passive, 219-221 
powered, 221-224 
 
web site, 52 
 
(see also light sensors; touch sensors) 
 
servo motors, 227 
 
shafts, 15 
 
Shape Memory Alloy (SMA) wire, 227 
 
signal splitter, 222 
 
SMA (Shape Memory Alloy) wire, 227 
 
Smalltalk web site, 171 
 
solenoids, 227 
 
sounds 
legOS, 203 
 
pbFORTH, 134 
 
playing, 68-70 
 
sensors, 226 
 
building, web site, 228 
 
Spirit.ocx, 159-171 
 
web sites, 171 
 
standard motors, 34 
 
subroutines, 164 
 
subsumption architecture, 204 
 
web site, 188 
 
symbolic constants, 166 
 
synchro drives, 30 
 
web site, 38 
 
T 
 
tasks, 164-165 
 
behaviors, 180 
 

 
252
telerobotics, 145-147 
 
(see also remote control) 
 
temperature sensors 
building, 221 
web site, 228 
 
Test Panel, 48 
 
tethered robots, 3 
 
thermistor, 221 
 
thermometer, building instructions, 137-138 
 
timing, 113 
 
timer values, retrieving, 165-166 
 
torque, 33 
 
touch multiplexer, 224-226 
 
touch sensors, 112 
 
building, 223-224 
train motors, 35 
 
treads, 27 
 
triangulation, 114 
 
tri-star wheels, 30 
 
web sites, 37 
 
Trusty, a Line Follower 
 
instructions for building, 40-44 
 
programming, 44-47 
 
in NQC, 77-80 
 
turning radius, 29-30 
 
(see also zero turning radius) 
 
U 
 
Unix, 233 
 
UploadDatalog function (Spirit.ocx), 169 
 
V 
 
View button (RCX), 48 
 
Visual Basic, 159-171 
 
 

 
253
Visual C++, 160 
 
W 
 
web sites 
 
challenges and competitions, 158 
Hitachi H8, 81 
 
Killough platform, 38 
 
LEGO Group, 11 
 
legOS, 213 
 
LUGNET, 11 
 
MINDSTORMS, 11 
 
NQC, 143 
 
parts, 115 
 
electronic, 229 
sensors, 228 
 
pbFORTH, 143 
 
Pitsco LEGO DACTA, 38 
 
RCX, 214 
 
RcxCC, 81 
 
RIS, 12 
 
RoboTag, 188 
 
Spirit.ocx, 171 
 
Windows platform, 214-215 
 
wheels, 27-35 
 
idler wheels, 50 
 
While function (Spirit.ocx), 166-167 
 
Windows platform, 233 
 
legOS and, web site for, 214-215 
 
wire brick, 16 
 
attaching sensors, 217 
 
worm gears, 108 
 
worms, bevel, 32 
 
 
 

 
254
Z 
 
zero turning radius, 27 
 
(see also turning radius) 
 

 
255
About the Author 
 
''Java" Jonathan B. Knudsen is a staff writer for O'Reilly & Associates. He is the author of Java™ 2D Graphics and 
Java™ Cryptography, and has contributed to Java™ Swing, Java™ AWT Reference, and the second and third editions of 
Exploring Java™. He also writes a monthly online column called "Bite-Size Java." 
 
This book represents one of Jonathan's lifelong goals: getting paid to play with LEGO® bricks. He hopes this is the start of 
something big. 
 
Jonathan works at home with his wife, Kristen, and their children, Daphne, Luke, and Andrew. 
 
Colophon 
 
Our look is the result of reader comments, our own experimentation, and feedback from distribution channels. Distinctive 
covers complement our distinctive approach to technical topics, breathing personality and life into potentially dry subjects. 
 
The image on the cover of The Unofficial Guide to LEGO® MINDSTORMS™ Robots is a mechanical toy rabbit or automaton, 
an automated machine. Biological automata, or androids, are imitations of living beings, animal or human, and have captured 
the imagination, fears, and hopes of inventors and spectators for many centuries. Especially notable in the long history of 
automata are the Chinese and Greek cultures. During the Renaissance, European automata and their mechanics or creators 
were viewed as mystical and magical—conjuring lifelike beings through suspect means. Machinery progressed from water-
operated to weight-operated to clockwork structures, incorporating such well-known specimens as dolls who can say "Mama" 
and "Papa" (c. 1823) and the bejeweled, enameled eggs created by Russian Court Jeweler Carl Fabergé 
 
Mechanical toys have affected the progress of industry and been intertwined with myth, magic, and literature, from 
Prometheus to Asimov, in the process raising philosophical questions about the nature of life and humanity and the many 
implications of creating lifelike toys. 
 
Nicole Arigo was the production editor and proofreader for The Unofficial Guide to LEGO® MINDSTORMS™ Robots. 
Melanie Wang and Jane Ellin provided quality control reviews. Nancy Crumpton wrote the index. 
 
Edie Freedman designed the cover of this book, using a 19th-century engraving from the Dover Pictorial Archive. Kathleen 
Wilson produced the cover layout with 
 
QuarkXPress 3.3 using Adobe's ITC Garamond font. Alicia Cech designed the interior layout based on a series design by 
Nancy Priest. Whenever possible, our books use RepKover™, a durable and flexible lay-flat binding. If the pagecount exceeds 
RepKover's limit, perfect binding is used. 
 
The book was implemented in FrameMaker by Mike Sierra. The text and heading fonts are ITC Garamond Light and 
Garamond Book. The illustrations that appear in the book were produced by Robert Romano using Macromedia FreeHand 8 
and Adobe Photoshop 5. All photos were taken by Jonathan and Kristen Knudsen. This colophon was written by Nancy 
Kotary. 
 

