Graph Theory with Algorithms and its Applications

Santanu Saha Ray
Graph Theory
with Algorithms
and its Applications
In Applied Science and Technology
123

Santanu Saha Ray
Department of Mathematics
National Institute of Technology
Rourkela, Orissa
India
ISBN 978-81-322-0749-8
ISBN 978-81-322-0750-4
(eBook)
DOI 10.1007/978-81-322-0750-4
Springer New Delhi Heidelberg New York Dordrecht London
Library of Congress Control Number: 2012943969
 Springer India 2013
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations,
recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or
information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar
methodology now known or hereafter developed. Exempted from this legal reservation are brief
excerpts in connection with reviews or scholarly analysis or material supplied speciﬁcally for the
purpose of being entered and executed on a computer system, for exclusive use by the purchaser of the
work. Duplication of this publication or parts thereof is permitted only under the provisions of
the Copyright Law of the Publisher’s location, in its current version, and permission for use must always
be obtained from Springer. Permissions for use may be obtained through RightsLink at the Copyright
Clearance Center. Violations are liable to prosecution under the respective Copyright Law.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this
publication does not imply, even in the absence of a speciﬁc statement, that such names are exempt
from the relevant protective laws and regulations and therefore free for general use.
While the advice and information in this book are believed to be true and accurate at the date of
publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for
any errors or omissions that may be made. The publisher makes no warranty, express or implied, with
respect to the material contained herein.
Printed on acid-free paper
Springer is part of Springer Science+Business Media (www.springer.com)

This work is dedicated to my grandfather late
Sri Chandra Kumar Saha Ray, my father late
Sri Santosh Kumar Saha Ray, my beloved
wife Lopamudra and my son Sayantan

Preface
Graph Theory has become an important discipline in its own right because of its
applications to Computer Science, Communication Networks, and Combinatorial
optimization through the design of efﬁcient algorithms. It has seen increasing
interactions with other areas of Mathematics. Although this book can ably serve as
a reference for many of the most important topics in Graph Theory, it even
precisely fulﬁlls the promise of being an effective textbook. The main attention lies
to serve the students of Computer Science, Applied Mathematics, and Operations
Research ensuring fulﬁllment of their necessity for Algorithms. In the selection
and presentation of material, it has been attempted to accommodate elementary
concepts on essential basis so as to offer guidance to those new to the ﬁeld.
Moreover, due to its emphasis on both proofs of theorems and applications, the
subject should be absorbed followed by gaining an impression of the depth and
methods of the subject. This book is a comprehensive text on Graph Theory and
the subject matter is presented in an organized and systematic manner. This book
has been balanced between theories and applications. This book has been orga-
nized in such a way that topics appear in perfect order, so that it is comfortable for
students to understand the subject thoroughly. The theories have been described in
simple and clear Mathematical language. This book is complete in all respects. It
will give a perfect beginning to the topic, perfect understanding of the subject, and
proper presentation of the solutions. The underlying characteristics of this book are
that the concepts have been presented in simple terms and the solution procedures
have been explained in details.
This book has 10 chapters. Each chapter consists of compact but thorough
fundamental discussion of the theories, principles, and methods followed by
applications through illustrative examples.
All the theories and algorithms presented in this book are illustrated by
numerous worked out examples. This book draws a balance between theory and
application.
Chapter 1 presents an Introduction to Graphs. Chapter 1 describes essential and
elementary deﬁnitions on isomorphism, complete graphs, bipartite graphs, and
regular graphs.
vii

Chapter 2 introduces different types of subgraphs and supergraphs. This chapter
includes operations on graphs. Chapter 2 also presents fundamental deﬁnitions of
walks, trails, paths, cycles, and connected or disconnected graphs. Some essential
theorems are discussed in this chapter.
Chapter 3 contains detailed discussion on Euler and Hamiltonian graphs. Many
important theorems concerning these two graphs have been presented in this
chapter. It also includes elementary ideas about complement and self-comple-
mentary graphs.
Chapter 4 deals with trees, binary trees, and spanning trees. This chapter
explores thorough discussion of the Fundamental Circuits and Fundamental Cut
Sets.
Chapter 5 involves in presenting various important algorithms which are useful
in mathematics and computer science. Many are particularly interested on good
algorithms for shortest path problems and minimal spanning trees. To get rid of
lack of good algorithms, the emphasis is laid on detailed description of algorithms
with its applications through examples which yield the biggest chapter in this
book.
The mathematical prerequisite for Chapter 6 involves a ﬁrst grounding in linear
algebra is assumed. The matrices incidence, adjacency, and circuit have many
applications in applied science and engineering.
Chapter 7 is particularly important for the discussion of cut set, cut vertices, and
connectivity of graphs.
Chapter 8 describes the coloring of graphs and the related theorems.
Chapter 9 focuses specially to emphasize the ideas of planar graphs and the
concerned theorems. The most important feature of this chapter includes the proof
of Kuratowski’s theorem by Thomassen’s approach. This chapter also includes the
detailed discussion of coloring of planar graphs. The Heawood’s Five color the-
orem as well as in particular Four color theorem are very much essential for the
concept of map coloring which are included in this chapter elegantly.
Finally, Chapter 10 contains fundamental deﬁnitions and theorems on networks
ﬂows. This chapter explores in depth the Ford–Fulkerson algorithms with neces-
sary modiﬁcation by Edmonds–Karp and also presents the application of maximal
ﬂows which includes Maximum Bipartite Matching.
Bibliography provided at the end of this book serves as helpful sources for
further study and research by interested readers.
viii
Preface

Acknowledgments
I take this opportunity to express my sincere gratitude to Dr. R. K. Bera, former
Professor and Head, Department of Science, National Institute of Technical
Teacher’s Training and Research, Kolkata and Dr. K. S. Chaudhuri, Professor,
Department of Mathematics, Jadavpur University, for their encouragement in the
preparation of this book. I acknowledge with thanks the valuable suggestion
rendered by Scientist Shantanu Das, Senior Scientist B. B. Biswas, Head Reactor
Control Division, Bhaba Atomic Research Centre, Mumbai and my former
colleague Dr. Subir Das, Department of Mathematics, Institute of Technology,
Banaras Hindu University. This is not out of place to acknowledge the effort of my
Ph.D. Scholar student and M.Sc. students for their help to write this book.
I, also, express my sincere gratitude to the Director of National Institute of
Technology, Rourkela for his kind cooperation in this regard. I received consid-
erable assistance from my colleagues in the Department of Mathematics, National
Institute of Technology, Rourkela.
I wish to express my sincere thanks to several people involved in the prepa-
ration of this book.
Moreover, I am especially grateful to the Springer Publishing Company for
their cooperation in all aspects of the production of this book.
Last, but not the least, special mention should be made of my parents and my
beloved wife, Lopamudra for their patience, unequivocal support, and encour-
agement throughout the period of my work.
I look forward to receive comments and suggestions on the work from students,
teachers, and researchers.
Santanu Saha Ray
ix

Contents
1
Introduction to Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
Definitions of Graphs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Some Applications of Graphs . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.3
Incidence and Degree. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.4
Isomorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.5
Complete Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.6
Bipartite Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.6.1
Complete Bipartite Graph . . . . . . . . . . . . . . . . . . . . . .
7
1.7
Directed Graph or Digraph . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
2
Subgraphs, Paths and Connected Graphs . . . . . . . . . . . . . . . . . . .
11
2.1
Subgraphs and Spanning Subgraphs (Supergraphs) . . . . . . . . . .
11
2.2
Operations on Graphs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
2.3
Walks, Trails and Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
2.4
Connected Graphs, Disconnected Graphs, and Components . . . .
15
2.5
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
3
Euler Graphs and Hamiltonian Graphs . . . . . . . . . . . . . . . . . . . .
25
3.1
Euler Tour and Euler Graph . . . . . . . . . . . . . . . . . . . . . . . . . .
25
3.2
Hamiltonian Path. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
3.2.1
Maximal Non-Hamiltonian Graph . . . . . . . . . . . . . . . . .
27
3.3
Complement and Self-Complementary Graph . . . . . . . . . . . . . .
31
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
4
Trees and Fundamental Circuits. . . . . . . . . . . . . . . . . . . . . . . . . .
35
4.1
Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
4.2
Some Properties of Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
xi

4.3
Spanning Tree and Co-Tree . . . . . . . . . . . . . . . . . . . . . . . . . .
40
4.3.1
Some Theorems on Spanning Tree . . . . . . . . . . . . . . . .
40
4.4
Fundamental Circuits and Fundamental Cut Sets . . . . . . . . . . . .
41
4.4.1
Fundamental Circuits. . . . . . . . . . . . . . . . . . . . . . . . . .
41
4.4.2
Fundamental Cut Set . . . . . . . . . . . . . . . . . . . . . . . . . .
42
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
5
Algorithms on Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
5.1
Shortest Path Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
5.1.1
Dijkstra’s Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . .
49
5.1.2
Floyd–Warshall’s Algorithm. . . . . . . . . . . . . . . . . . . . .
57
5.2
Minimum Spanning Tree Problem . . . . . . . . . . . . . . . . . . . . . .
66
5.2.1
Objective of Minimum Spanning Tree Problem . . . . . . .
67
5.2.2
Minimum Spanning Tree . . . . . . . . . . . . . . . . . . . . . . .
68
5.3
Breadth First Search Algorithm to Find the Shortest Path. . . . . .
78
5.3.1
BFS Algorithm for Construction of a Spanning Tree. . . .
79
5.4
Depth First Search Algorithm for Construction
of a Spanning Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
6
Matrix Representation on Graphs . . . . . . . . . . . . . . . . . . . . . . . .
95
6.1
Vector Space Associated with a Graph. . . . . . . . . . . . . . . . . . .
95
6.2
Matrix Representation of Graphs . . . . . . . . . . . . . . . . . . . . . . .
96
6.2.1
Incidence Matrix. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
96
6.2.2
Adjacency Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . .
101
6.2.3
Circuit Matrix/Cycle Matrix . . . . . . . . . . . . . . . . . . . . .
105
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
112
7
Cut Sets and Cut Vertices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
7.1
Cut Sets and Fundamental Cut Sets . . . . . . . . . . . . . . . . . . . . .
115
7.1.1
Cut Sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
7.1.2
Fundamental Cut Set (or Basic Cut Set) . . . . . . . . . . . .
116
7.2
Cut Vertices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
116
7.2.1
Cut Set with respect to a Pair of Vertices . . . . . . . . . . .
117
7.3
Separable Graph and its Block . . . . . . . . . . . . . . . . . . . . . . . .
118
7.3.1
Separable Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
118
7.3.2
Block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
118
7.4
Edge Connectivity and Vertex Connectivity . . . . . . . . . . . . . . .
119
7.4.1
Edge Connectivity of a Graph . . . . . . . . . . . . . . . . . . .
119
7.4.2
Vertex Connectivity of a Graph . . . . . . . . . . . . . . . . . .
119
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
123
xii
Contents

8
Coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
125
8.1
Properly Colored Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
125
8.2
Chromatic Number . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
126
8.3
Chromatic Polynomial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
8.3.1
Chromatic Number Obtained by
Chromatic Polynomial . . . . . . . . . . . . . . . . . . . . . . . . .
127
8.3.2
Chromatic Polynomial of a Graph G . . . . . . . . . . . . . . .
128
8.4
Edge Contraction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
131
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
133
9
Planar and Dual Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
9.1
Plane and Planar Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
9.1.1
Plane Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
9.1.2
Planar Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
9.2
Nonplanar Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
136
9.3
Embedding and Region . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
136
9.3.1
Embedding. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
136
9.3.2
Plane Representation . . . . . . . . . . . . . . . . . . . . . . . . . .
137
9.4
Regions or Faces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
9.5
Kuratowski’s Two Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
9.5.1
Kuratowski’s First Graph . . . . . . . . . . . . . . . . . . . . . . .
138
9.5.2
Kuratowski’s Second Graph . . . . . . . . . . . . . . . . . . . . .
138
9.6
Euler’s Formula. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
138
9.7
Edge Contractions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
143
9.8
Subdivision, Branch Vertex, and Topological Minors. . . . . . . . .
143
9.9
Kuratowi’s Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
146
9.10 Dual of a Planar Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
149
9.10.1 To Find the Dual of the Given Graph . . . . . . . . . . . . . .
149
9.10.2 Relationship Between a Graph and its Dual Graph . . . . .
151
9.11 Edge Coloring. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
153
9.11.1 k-Edge Colorable . . . . . . . . . . . . . . . . . . . . . . . . . . . .
153
9.11.2 Edge-Chromatic Number . . . . . . . . . . . . . . . . . . . . . . .
153
9.12 Coloring Planar Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
154
9.12.1 The Four Color Theorem . . . . . . . . . . . . . . . . . . . . . . .
154
9.12.2 The Five Color Theorem . . . . . . . . . . . . . . . . . . . . . . .
155
9.13 Map Coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
156
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
157
10 Network Flows. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
159
10.1 Transport Networks and Cuts . . . . . . . . . . . . . . . . . . . . . . . . .
159
10.1.1 Transport Network . . . . . . . . . . . . . . . . . . . . . . . . . . .
159
10.1.2 Cut . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
161
Contents
xiii

10.2 Max-Flow Min-Cut Theorem . . . . . . . . . . . . . . . . . . . . . . . . .
162
10.3 Residual Capacity and Residual Network . . . . . . . . . . . . . . . . .
165
10.3.1 Residual Capacity . . . . . . . . . . . . . . . . . . . . . . . . . . . .
165
10.3.2 Residual Network . . . . . . . . . . . . . . . . . . . . . . . . . . . .
166
10.4 Ford-Fulkerson Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . .
166
10.5 Ford-Fulkerson Algorithm with Modification
by Edmonds-Karp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
167
10.5.1 Time Complexity of Ford-Fulkerson Algorithm . . . . . . .
167
10.5.2 Edmonds-Karp Algorithm . . . . . . . . . . . . . . . . . . . . . .
167
10.6 Maximal Flow: Applications. . . . . . . . . . . . . . . . . . . . . . . . . .
175
10.6.1 Multiple Sources and Sinks . . . . . . . . . . . . . . . . . . . . .
175
10.6.2 Maximum Bipartite Matching. . . . . . . . . . . . . . . . . . . .
175
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
176
Appendix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
179
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
209
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
211
xiv
Contents

About the Author
Dr. S. Saha Ray is currently working as an Associate Professor at the Department
of Mathematics, National Institute of Technology, Rourkela, India. Dr. Saha Ray
completed his Ph.D. in 2008 from Jadavpur University, India. He received his
MCA degree in the year 2001 from Bengal Engineering College, Sibpur, Howrah,
India. He completed his M.Sc. in Applied Mathematics at Calcutta University in
1998 and B.Sc. (Honors) in Mathematics at St. Xavier’s College, Kolkata, in 1996.
Dr. Saha Ray has about 12 years of teaching experience at undergraduate and
postgraduate levels. He also has more than 10 years of research experience in
various ﬁeld of Applied Mathematics. He has published several research papers in
numerous ﬁelds and various international journals of repute like Transaction
ASME Journal of Applied Mechanics, Annals of Nuclear Energy, Physica Scripta,
Applied Mathematics and Computation, and so on. He is a member of the Society
for Industrial and Applied Mathematics (SIAM) and American Mathematical
Society (AMS). He was the Principal Investigator of the BRNS research project
granted by BARC, Mumbai. Currently, he is acting as Principal Investigator of a
research Project ﬁnanced by DST, Govt. of India. It is not out of place to mention
that he had been invited to act as lead guest editor in the journal entitled
International Journal of Differential equations of Hindawi Publishing Corpora-
tion, USA.
xv

Chapter 1
Introduction to Graphs
1.1 Deﬁnitions of Graphs
A graph G ¼ ðVðGÞ; EðGÞÞ or G ¼ ðV; EÞ consists of two ﬁnite sets. VðGÞ or V;
the vertex set of the graph, which is a non-empty set of elements called vertices
and EðGÞ or E; the edge set of the graph, which is a possibly empty set of elements
called edges, such that each edge e in E is assigned as an unordered pair of vertices
ðu; vÞ; called the end vertices of e.
Order and size: We deﬁne jVj ¼ n to be the order of G and jEj ¼ m to be the
size of G:
Self-loop and parallel edges: The deﬁnition of a graph allows the possibility of
the edge e having identical end vertices. Such an edge having the same vertex as
both of its end vertices is called a self-loop (or simply a loop).
Edge e1 in Fig. 1.1b is a self-loop. Also, note that the deﬁnition of graph allows
that more than one edge is associated with a given pair of vertices, for example,
edges e4 and e5 in Fig. 1.1b. Such edges are referred to as parallel edges.
Simple graph: A graph, that has neither self-loops nor parallel edges, is called
a simple graph. An example of a simple graph is given in Fig. 1.1a.
Multigraph: A multigraph G is an ordered pair G ¼ ðV; EÞ with V a set of
vertices or nodes and E a multiset of unordered pairs of vertices called edges. An
example of a multigraph is given in Fig. 1.1b.
Finite and Inﬁnite graph: A graph with a ﬁnite number of vertices as well as
ﬁnite number of edges is called a ﬁnite graph; otherwise it is an inﬁnite graph as
shown in Fig. 1.1c.
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_1,  Springer India 2013
1

1.2 Some Applications of Graphs
Graph theory has a very wide range of applications in engineering, in physical, and
biological sciences, and in numerous other areas.
Königsberg Bridge Problem: The Königsberg Bridge Problem is perhaps the
best known example in graph theory. It was a long-standing problem until solved
by Euler in 1736 by means of a graph. Euler wrote the ﬁrst research paper in graph
theory and then became the originator of the theory of graphs. The problem is
depicted in Fig. 1.2.
The islands C and D formed by the river in Königsberg were connected to each
other and to the banks A and B with seven bridges, as shown in Fig. 1.2. The
problem was to start at any of the four land areas of the city A, B, C, and D walk
over each of the seven bridges exactly once and return to the starting point. Euler
represented this situation by means of a graph in Fig. 1.3. The vertices represent
the land areas and the edges represent the bridges.
Graph theory was born in 1736 with Euler’s famous graph in which he solved
the Königsberg Bridge Problem. If some closed walk in a graph contains all the
edges of the graph exactly once then (the walk is called an Euler line and) the
graph is an Euler graph.
Remarks A given connected graph G is an Euler graph if and only if all the
vertices of G are of even degree.
(a)
(b) 
(c)
e1
e2
e7
v5
v2
v4
e6
v3
e3
v1
e4
e5
Fig. 1.1 a Simple graph,
b multigraph, and c inﬁnite
graph
2
1
Introduction to Graphs

Now looking at the graph of the Königsberg Bridges, we ﬁnd that not all its
vertices are of even degree. Hence, it is not an Euler graph. Thus, it is not possible
to walk over each of the seven bridges exactly once and return to the starting point.
Shortest Path Problem: A company has branches in each of six cities where
cities are C1; C2; C3; C4 ; C5; and C6. The airfare for a direct ﬂight from Ci to Cj is
given by the ði; jÞth entry of the following matrix (where 1 indicates that there is
no direct ﬂight). For example, the fare from C1 to C4 is USD 50 and from C2 to C3
is USD 15.
c1
c2
c3
c4
c5
c6
c1
c2
c3
c4
c5
c6
0
50
1
50
0
15
1
15
0
1
20
10
1
1
1
10
25
1
1
1
10
20
1
25
10
1
1
0
10
25
10
0
55
25
55
0
2
666666664
3
777777775
The company is interested in computing a table of cheapest fares between pairs
of cities. We can represent the situation by a weighted graph (Fig. 1.4). The
problem can be solved using Dijkstra’s algorithm.
Fig. 1.2 Pictorial representation of Königsberg bridge problem
Fig. 1.3 A graph
representing Königsberg
bridge problem
1.5
Complete Graph
3

1.3 Incidence and Degree
When a vertex vi is an end vertex of some edge ej, vi, and ej are said to be incident
with (to or on) each other.
A graph with ﬁve vertices and seven edges is shown in Fig. 1.5. Edges e2, e6,
and e7 are incident with vertex v4.
Adjacent: Two nonparallel edges are said to be adjacent if they are incident on
a common vertex. For example, e2 and e7 are adjacent. Similarly, two vertices are
said to be adjacent if they are the end vertices of the same edge. In Fig. 1.5, v4 and
v5 are adjacent, but v1 and v4 are not.
Degree: Let v be a vertex of the graph G. The degree d v
ð Þ of v is the number of
edges of G incident with v, counting each self-loop twice. The minimum degree
and the maximum degree of a graph G are denoted by dðGÞ and DðGÞ, respectively.
For example, in Fig. 1.5, dðv1Þ ¼ 3 ¼ dðv3Þ ¼ dðv4Þ; dðv2Þ ¼ 4 and dðv5Þ ¼ 1
d v1
ð
Þ þ d v2
ð
Þ þ . . .. . . þ d v5
ð
Þ ¼ 14 ¼ twice the number of edges:
Fig. 1.4 The weighted graph
representing airfares for
direct ﬂights between six
cities
Fig. 1.5 A graph
(multigraph) with ﬁve
vertices and seven edges
4
1
Introduction to Graphs

Theorem 1.1 For any graph G with e edges and n vertices v1, v2, v3…… vn
Pn
i¼1 dðviÞ ¼ 2e:
Proof Each edge, since it has two end vertices, contributes precisely two to the
sum of the degrees of all vertices in G. When the degrees of the vertices are
summed each edge is counted twice.
h
Odd and even vertices: A vertex of a graph is called odd or even depending on
whether its degree is odd or even.
In the graph of Fig. 1.5, there is an even number of odd vertices.
Theorem 1.2 (Handshaking lemma) In any graph G, there is an even number of
odd vertices.
Proof If we consider the vertices with odd and even degrees separately, the
equation
Pn
i¼1 dðviÞ ¼ 2e can be expressed as equation
X
n
i¼1
dðviÞ ¼
X
even
d vj
 
þ
X
odd
dðvkÞ
Let W be the set of odd vertices of G, and let U be the set of even vertices of
G. Then for each u 2 U; d(u) is even and so P
u2U dðuÞ; being a sum of even
numbers, is even.
However,
P
u2U
dðuÞ þ P
w2W
dðwÞ ¼ P
v2V
d v
ð Þ ¼ 2e; by Theorem 1.1
Thus,
P
w2W
d w
ð Þ ¼ 2e  P
u2U
d u
ð Þ; is even. (being the difference of two even numbers)
As all the terms in P
w2W dðwÞ are odd and their sum is even, there must be an
even number of odd vertices.
h
Isolated vertex: A vertex having no incident edge is called an isolated vertex.
Figure. 1.1a has an isolated vertex.
Pendant vertex: A vertex of degree one is called a pendant vertex. In Fig. 1.1b,
vertex v5 is a pendant vertex.
Null graph: If E = Ø, in a graph G = (V, E), then such a graph without any
edges is called a null graph.
1.4 Isomorphism
A graph G1 ¼ V1; E1
ð
Þ is said to be isomorphic to the graph G2 ¼ V2; E2
ð
Þ if there
is a one-to-one correspondence between the vertex sets V1 and V2 and a one-to-one
correspondence between the edge sets E1 and E2 in such a way that if e1 is an edge
1.3
Incidence and Degree
5

with end vertices u1 and v1 in G1 then the corresponding edge e2 in G2 has its end
vertices u2 and v2 in G2 which corresponds to u1 and v1 , respectively. Such a pair
of correspondence is called a graph isomorphism.
In other words, two graphs G and G0 are said to be isomorphic if there is a one-
to-one correspondence between their vertices and between their edges such that the
incidence relationship is preserved.
Example 1.1 Show that the following two graphs in Fig. 1.6 are isomorphic.
Solution:
We see that both the graphs G and G
0 have equal number of vertices and edges.
The vertex corresponds are given below:
u1 $ v1, u2 $ v3, u3 $ v5, u4 $ v2, u5 $ v4, u6 $ v6 or u5 $ v6, u6 $ v4.
Hence, the two graphs are isomorphic.
Example 1.2 Check whether the graphs in Fig. 1.7 are isomorphic.
Solution:
The graphs in Fig. 1.7a and b are not isomorphic. If the graph 1.7a were to be
isomorphic to the one in 1.7b, vertex x must correspond to y; because there are no
other vertices of degree three. Now in 1.7b, there is only one pendant vertex w
adjacent to y; while in 1.7a there are two pendant vertices u and v adjacent to x:
Fig. 1.6 Two isomorphic graphs G and G0
Fig. 1.7 Two non-isomorphic graphs
6
1
Introduction to Graphs

1.5 Complete Graph
A complete graph is a simple graph in which each pair of distinct vertices is joined
by an edge. In other words, a simple graph in which there exists an edge between
every pair of vertices is called a complete graph. If the complete graph has vertices
v1; v2;….vn; then the edge set can be given by
E ¼ fðvi; vjÞ : vi 6¼ vj;
i; j ¼ 1; 2; 3. . .ng
It follows that the graph has nðn  1Þ=2 edges (since there are n - 1 edges
incident with each of the n vertices, so a total of nðn  1Þ; but divide by 2 since
ðvj; viÞ ¼ ðvi; vjÞ).
Corollary The maximum number of edges in a simple graph with n vertices is
nðn  1Þ=2. Given any two complete graphs with the same number of vertices, n;
then they are isomorphic.
The complete graph of n vertices is denoted by Kn:
Figure 1.8 shows K1; K2; K3 and K4:
Trivial graph: An empty (or trivial) graph is a graph with no edges.
1.6 Bipartite Graph
Deﬁnition Let G be a graph. If the vertex set V of G can be partitioned into two
non-empty subsets X and Y (i.e., X [ Y = V and X \ Y = Ø) in such a way that,
each edge of G has one end in X and other end in Y, then G is called bipartite. The
partition V = X [ Y is called a bipartition of G.
Figures 1.9 and 1.10 cite examples of Bipartite graphs.
1.6.1 Complete Bipartite Graph
Deﬁnition A complete Bipartite graph is a simple bipartite graph G, with
bipartition V = X [ Y in which every vertex in X is adjacent to every vertex of
Y. If X has m vertices and Y has n vertices, such a graph is denoted by Km;n:
Fig. 1.8 Complete graphs K1, K2, K3, and K4
1.5
Complete Graph
7

Corollary Any complete bipartite graph with a bipartition into two sets of m and
n vertices is isomorphic to Km;n:
Since each of the m vertices in the partition set X of Km;n is adjacent to each of the
n vertices in the partition set Y, Km;n has m * n edges.
Figure 1.11 shows complete bipartite graphs.
Fig. 1.9 Complete bipartite graph K2,2
Fig. 1.10 A bipartite graph
Fig. 1.11 Complete bipartite graphs K1,8 and K3,3
8
1
Introduction to Graphs

k-Regular: If for some positive integer k; dðvÞ ¼ k for every vertex v of the
graph G, then G is called k-regular.
A regular graph is one that is k-regular for some k:
For example, the graph K2;2 shown in Fig. 1.9 is 2-regular. The complete graph
Kn is (n - 1)-regular. The complete bipartite graph Kn;n on 2n vertices is n-
regular.
1.7 Directed Graph or Digraph
A digraph (or a directed graph) G ¼ ðVG; EGÞ consists of the two sets:
1. A vertex set VG; nonempty set, whose elements are called vertices or nodes.
2. An edge set or arc set EG; possibly empty set, whose elements are called
directed edges or arcs, such that each directed edge in EG is assigned an order
pair of vertices ðu; vÞ; i.e., EG  VG  VG:
For u; v 2 VG; an arc or a directed edge e ¼ ðu; vÞ 2 VG is denoted by uv and
implies that e is directed from u to v. Here, u is the initial vertex and v is the
terminal vertex. Also, we say that e joins u to v; e is incident with u and v; e is
incident from u and e is incident to v; and u is adjacent to v and v is adjacent from
u. For example, Fig. 1.12 shows a directed graph or digraph.
In-degree and Out-degree: The in-degree and the out-degree of a vertex are
deﬁned as follows:
1. In a digraph G, the number of edges incident out of a vertex v is called the out-
degree of v. It is denoted by degreeþðvÞ or dþðvÞ:
2. In a digraph G, the number of edges incident into a vertex v is called the in-
degree of v: It is denoted by degreeðvÞ or dðvÞ:
The total degree (or simply degree) of v is dðvÞ ¼ degreeþðvÞ þ degreeðvÞ:
In this case, we have the following Handshaking Lemma.
Lemma 1.1 Let G be a digraph. Then
X
v2G
degreeþðvÞ ¼ EG
j
j ¼
X
v2G
degreeðvÞ
1.6
Bipartite Graph
9

Example 1.3 Find the in-degree and out-degree of each vertex of the following
directed graph. Also, verify that the sum of the in-degrees (or the out-degrees)
equals the number of edges.
Solution:
For the graph G in Fig. 1.12
degreeþ v1
ð
Þ ¼ 2
degree v1
ð
Þ ¼ 5
degreeþ v2
ð
Þ ¼ 3
degree v2
ð
Þ ¼ 3
degreeþ v3
ð
Þ ¼ 6
degree v3
ð
Þ ¼ 1
degreeþ v4
ð
Þ ¼ 3
degree v4
ð
Þ ¼ 5
Here, we see that
X
v2G
degreeþðvÞ ¼
X
v2G
degreeðvÞ ¼ 14 ¼ the number of edges of G:
Fig. 1.12 A directed graph
or digraph
10
1
Introduction to Graphs

Chapter 2
Subgraphs, Paths, and Connected Graphs
2.1 Subgraphs and Spanning Subgraphs (Supergraphs)
Subgraph: Let H be a graph with vertex set V(H) and edge set E(H), and similarly
let G be a graph with vertex set V(G) and edge set E(G). Then, we say that H is a
subgraph of G if V(H) ( V(G) and E(H) ( E(G). In such a case, we also say that
G is a supergraph of H.
In Fig. 2.1, G1 is a subgraph of both G2 and G3 but G3 is not a subgraph of G2.
Any graph isomorphic to a subgraph of G is also referred to as a subgraph of G.
If H is a subgraph of G then we write H ( G. When H ( G but H = G, i.e.,
V(H) = V(G) or E(H) = E(G), then H is called a proper subgraph of G.
Spanning subgraph (or Spanning supergraph): A spanning subgraph (or
spanning supergraph) of G is a subgraph (or supergraph) H with V(H) = V(G),
i.e. H and G have exactly the same vertex set.
It follows easily from the deﬁnitions that any simple graph on n vertices is a
subgraph of the complete graph Kn. In Fig. 2.1, G1 is a proper spanning subgraph
of G3.
Fig. 2.1 G1 is a subgraph of G2 and G3
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_2,  Springer India 2013
11

2.2 Operations on Graphs
The union of two graphs G1 ¼ V1; E1
ð
Þ and G2 ¼ V2; E2
ð
Þ is another graph G3 ¼
V3; E3
ð
Þ denoted by G3 ¼ G1 [ G2, where vertex set V3 ¼ V1 [ V2 and the edge
set E3 ¼ E1 [ E2:
The intersection of two graphs G1 and G2 denoted by G1 \ G2 is a graph G4
consisting only of those vertices and edges that are in both G1 and G2.
The ring sum of two graphs G1 and G2, denoted by G1  G2; is a graph
consisting of the vertex set V1 [ V2 and of edges that are either in G1 or G2; but
not in both.
Figure 2.2 shows union, intersection, and ring sum on two graphs G1 and G2:
Three operations are commutative, i.e.,
G1 [ G2 ¼ G2 [ G1;
G1 \ G2 ¼ G2 \ G1;
G1  G2 ¼ G2  G1
If G1 and G2 are edge disjoint, then G1 \ G2 is a null graph, and G1  G2 ¼
G1 [ G2: If G1 and G2 are vertex disjoint, then G1 \ G2 is empty.
For any graph G, G \ G ¼ G [ G ¼ G and G  G = a null graph.
If g is a subgraph of G, i.e., g ( G, then G  g = G - g, and is called a
complement of g in G.
Fig. 2.2 Union, intersection, and ring sum of two graphs
12
2
Subgraphs, Paths and Connected Graphs

Decomposition: A graph G is said to be decomposed into two subgraphs G1 and
G2, if G1 [ G2 ¼ G and G1 \ G2 is a null graph.
Deletion: If vi is a vertex in graph G, then G  vi denotes a subgraph of
G obtained by deleting vi from G. Deletion of a vertex always implies the deletion
of all edges incident on that vertex. If ej is an edge in G, then G  ej is a subgraph
of G obtained by deleting ej from G. Deletion of an edge does not imply deletion
of its end vertices. Therefore, G  ej ¼ G  ej (Fig. 2.3).
Fusion: A pair of vertices a, b in a graph G are said to be fused if the two vertices
are replaced by a single new vertex such that every edge, that was incident on either
a or b or on both, is incident on the new vertex. Thus, fusion of two vertices does not
alter the number of edges, but reduces the number of vertices by one (Fig. 2.4).
Induced subgraph: A subgraph H  G is an induced subgraph, if EH ¼
EG \ E VH
ð
Þ: In this case, H is induced by its set VH of vertices. In an induced
subgraph H  G; the set EH of edges consists of all e 2 EG, such that e 2 E VH
ð
Þ:
To each nonempty subset A  VG; there corresponds a unique induced subgraph
G½A ¼ A; EG \ E A
ð Þ
ð
Þ (Fig. 2.5).
Fig. 2.3 Vertex deletion and edge deletion from a graph G
Fig. 2.4 Fusion of two vertices a and b
2.2
Operations on Graphs
13

Trivial graph: A graph G ¼ V; E
ð
Þ is trivial, if it has only one vertex. Otherwise
G is nontrivial.
Discrete graph: A graph is called discrete graph if EG ¼ /.
Stable: A subset X  VG is stable, if G[X] is a discrete graph.
2.3 Walks, Trails, and Paths
Walk: A walk in a graph G is a ﬁnite sequence
W  v0e1v1e2    vk1ekvk
whose terms are alternately vertices and edges such that for 1  i  k; the edge ei
has ends vi1 and vi.
Thus, each edge ei is immediately preceded and succeeded by the two vertices
with which it is incident. We say that W is a v0  vk walk or a walk from v0 to vk:
Origin and terminus: The vertex v0 is the origin of the walk W, while vk is
called the terminus of W. v0 and vk need not be distinct.
The vertices v1; v2; . . .; vk1 in the above walk W are called its internal vertices.
The integer k, the number of edges in the walk, is called the length of W, denoted
by W
j
j.
In a walk W, there may be repetition of vertices and edges.
Trivial walk: A trivial walk is one containing no edge. Thus for any vertex v of
G, W : v gives a trivial walk. It has length 0.
Fig. 2.5 Spanning subgraph and induced subgraph of a graph G
14
2
Subgraphs, Paths and Connected Graphs

In Fig. 2.6, W1  v1e1v2e5v3e10v3e5v2e3v5 and W2  v1e1v2e1v1e1v2 are both
walks of length 5 and 3, respectively, from v1 to v5 and from v1 to v2 , respectively.
Given two vertices u and v of a graph G, a u–v walk is called closed or open,
depending on whether u = v or u = v.
Two walks W1 and W2 above are both open, while W3  v1v5v2v4v3v1 is closed
in Fig. 2.6.
Trail: If the edges e1; e2; . . .; ek of the walk W  v0e1v1e2v2       ekvk are
distinct then W is called a trail. In other words, a trail is a walk in which no edge is
repeated. W1 and W2 are not trails, since for example e5 is repeated in W1, while e1
is repeated in W2. However, W3 is a trail.
Path: If the vertices v0; v1; . . .; vk of the walk W  v0e1v1e2v2    ekvk are dis-
tinct then W is called a path. Clearly, any two paths with the same number of
vertices are isomorphic.
A path with n vertices will sometimes be denoted by Pn.
Note that Pn has length n - 1.
In other words, a path is a walk in which no vertex is repeated. Thus, in a path
no edge can be repeated either, so a every path is a trail. Not every trail is a path,
though. For example, W3 is not a path since v1 is repeated. However, W4 
v2v4v3v5v1 is a path in the graph G as shown in Fig. 2.6.
2.4 Connected Graphs, Disconnected Graphs,
and Components
Connected vertices: A vertex u is said to be connected to a vertex v in a graph G if
there is a path in G from u to v.
Connected graph: A graph G is called connected if every two of its vertices are
connected.
Disconnected graph: A graph that is not connected is called disconnected.
Fig. 2.6 A graph with ﬁve vertices and ten edges
2.3
Walks, Trails, and Paths
15

It is easy to see that a disconnected graph consists of two or more connected
graphs. Each of these connected subgraphs is called a component. Figure 2.7
shows a disconnected graph with two components.
Theorem 2.1 A graph G is disconnected iff its vertex set V can be partitioned into
two non-empty, disjoint subsets V1 and V2 such that there exists no edge in G
whose one end vertex is in subset V1 and the other in subset V2.
Proof Suppose that such a partitioning exists. Consider two arbitrary vertices
a and b of G, such that a 2 V1 and b 2 V2: No path can exist between vertices
a and b; otherwise there would be at least one edge whose one end vertex would be
in V1 and the other in V2: Hence, if a partition exists, G is not connected.
Conversely, let G be a disconnected graph. Consider a vertex a in G. Let V1 be
the set of all vertices that are connected by paths to a. Since G is disconnected, V1
does not include all vertices of G. The remaining vertices will form a (non-empty)
set V2: No vertex in V1 is connected to any vertex in V2 by path. Hence the
partition exists.
h
Theorem 2.2 If a graph (connected or disconnected) has exactly two vertices of
odd degree, there must be a path joined by these two vertices.
Proof Let G be a graph with all even vertices except vertices v1 and v2, which are
odd. From Handshaking lemma, which holds for every graph and therefore for
every component of a disconnected graph, no graph can have an odd number of
odd vertices. Therefore, in graph G, v1 and v2 must belong to the same component,
and hence there must be a path between them.
h
Theorem 2.3 A simple graph with n vertices and k components can have at most
(n - k)(n - k ? 1)/2 edges.
Fig. 2.7 A disconnected graph with two components
16
2
Subgraphs, Paths and Connected Graphs

Proof Let the number of vertices in each of the k components of a graph G be
n1; n2; . . .; nk. Thus, we have
n1 þ n2 þ    þ nk ¼ n
where ni 	 1
for
i ¼ 1; 2; . . .; k:
Now, Pk
i¼1 ni  1
ð
Þ ¼ n  k
)
P
k
i¼1
ni  1
ð
Þ

2
¼ n2 þ k2  2nk
)
n1  1
ð
Þ þ n2  1
ð
Þ þ    þ nk  1
ð
Þ
½
2¼ n2 þ k2  2nk
) P
k
i¼1
ni  1
ð
Þ2þ2
P
k
i;j¼1;i6¼j
ni  1
ð
Þ nj  1


¼ n2 þ k2  2nk
) P
k
i¼1
ni
ð Þ22 P
k
i¼1
ni þ k þ 2
P
k
i;j¼1;i6¼j
ni  1
ð
Þ nj  1


¼ n2 þ k2  2nk
) P
k
i¼1
n2
i  2n þ k þ 2
P
k
i;j¼1;i6¼j
ni  1
ð
Þ nj  1


¼ n2 þ k2  2nk
) P
n
i¼1
n2
i þ 2
P
k
i;j¼1;i6¼j
ni  1
ð
Þ nj  1


¼ n2 þ k2  2nk þ 2n  k:
Since each ni  1
ð
Þ 	 0:
X
n
i¼1
n2
i  n2 þ k2  2nk þ 2n  k ¼ n2 þ k k  2n
ð
Þ  k  2n
ð
Þ
¼ n2  k  1
ð
Þ 2n  k
ð
Þ
Now, the maximum number of edges in the ith component of G is ni ni  1
ð
Þ=2.
Since the maximum number of edges in a simple graph with n vertices is
n(n -1)/2 therefore, the maximum number of edges in G is
1
2
P
k
i¼1
ni ni  1
ð
Þ
¼ 1
2
P
n
i¼1
n2
i  n
2
 1
2 n2  k  1
ð
Þ 2n  k
ð
Þ
½
  n
2
¼ 1
2 n2  2nk þ 2n þ k2  k  n
½

¼ 1
2
n  k
ð
Þ2þ n  k
ð
Þ
h
i
¼ 1
2 n  k
ð
Þ n  k þ 1
ð
Þ
h
2.5 Cycles
Cycle: A nontrivial closed trail in a graph G is called a cycle if its origin and
internal vertices are distinct. In detail, the closed trail
2.4
Connected Graphs, Disconnected Graphs, and Components
17

C  v1v2    vnv1 is a cycle if
1. C has at least one edge and
2. v1; v2; . . .; vnare n distinct vertices.
k-Cycle: A cycle of length k; , i.e., with k edges, is called a k-cycle. A k-cycle is
called odd or even depending on whether k is odd or even.
Figure 2.8 cites C3; C4; C5; and C6. A 3-cycle is often called a triangle. Clearly,
any two cycles of the same length are isomorphic.
An n-cycle, i.e., a cycle with n vertices, will sometimes be denoted by Cn:
In Fig. 2.9, C  v1v2v3v4v1; is a 4-cycle and T  v1v2v5v3v4v5v1 is a non-trivial
closed trail which is not a cycle (because v5 occurs twice as an internal vertex) and
C0  v1v2v5v1 is a triangle.
Fig. 2.8 Cycles C3, C4, C5 and C6
Fig. 2.9 A graph containing
3-cycles and 4-cycles
18
2
Subgraphs, Paths and Connected Graphs

Note that, a loop is just a 1-cycle. Also, given parallel edges e1 and e2 in Fig. 2.10
with distinct end vertices v1 and v2; we can ﬁnd the cycle v1e1v2e2v1 of length 2.
Conversely, the two edges of any cycle of length 2 are a pair of parallel edges.
Theorem 2.4 Given any two vertices u and v of a graph G, every u–v walk
contains a u–v path.
Proof We prove the statement by induction on the length l of a u–v walk W.
Basic step: l ¼ 0; having no edge, W consists of a single vertex (u = v). This
vertex is a u–v path of length 0.
Induction step: l 	 1: We suppose that the claim holds for walks of length less
than l: If W has no repeated vertex, then its vertices and edges form a u–v path. If
W has a repeated vertex w, then deleting the edges and vertices between appear-
ances of w (leaving one copy of w) yields a shorter u-v walk W0 contained in W.
By the induction hypothesis, W0 contains a u–v path P, and this path P is contained
in W (Fig. 2.11). This proves the theorem.
h
Theorem 2.5 The minimum number of edges in a connected graph with n vertices
is n - 1.
Proof Let m be the number of edges of such a graph. We have to show m 	 n  1:
We prove this by method of induction on m. If m = 0 then obviously n = 1
(otherwise G will be disconnected). Clearly, then m 	 n  1: Let the result be true
for m ¼ 0; 1; 2; 3; . . .; k: We shall show that the result is true for m = k ? 1. Let
G be a graph with k ? 1 edges. Let e be an edge of G. Then the subgraph G - e has
Fig. 2.10 A 2-cycle
Fig. 2.11 A walk W and a shorter walk W0 of W containing a path P
2.5
Cycles
19

k edges and n number of vertices. If G - e is also connected then by our hypothesis
k 	 n  1, i.e., k þ 1 	 n [ n  1.
If G - e is disconnected then it would have two connected components. Let the
two components have k1; k2 number of edges and n1; n2 number of vertices,
respectively. So, by our hypothesis, k1 	 n1  1 and k2 	 n2  1. These two imply
that k1 þ k2 	 n1 þ n2  2, i.e., k 	 n  2 (since, k1 þ k2 ¼ k; n1 þ n2 ¼ n), i.e.,
k þ 1 	 n  1.
Thus, the result is true for m = k ? 1.
h
Theorem 2.6 A graph G is bipartite if and only if it has no odd cycles.
Proof Necessary condition:
Let G be a bipartite graph with bipartition X; Y
ð
Þ, i.e., V ¼ X [ Y:
For any cycle C : v1 ! v2    ! vkþ1 ¼ v1
ð
Þ of length k; v1 2 X ) v2 2 Y; v3 2
X ) v4 2 Y    ) v2m 2 Y ) v2mþ1 2 X: Consequently, k þ 1 ¼ 2m þ 1 is odd
and k ¼ C
j j is even. Hence, G has no odd cycle.
Sufﬁcient condition:
Suppose that, all the cycles in G are even, i.e., G be a graph with no odd cycle.
To show: G is a bipartite graph. It is sufﬁcient to prove this theorem for the
connected graph only.
Let us assume that G is connected. Let v 2 G be an arbitrary chosen vertex.
Now, we deﬁne,
X ¼ x dG v; x
ð
Þ
j
is even
f
g;
i.e., X is the set of all vertices x of G with the property that any shortest v  x path
of G has even length and Y ¼ y dG v; y
ð
Þ
j
is odd
f
g, i.e., Y is the set of all vertices y
of G with the property that any shortest v  y path of G has odd length.
Here,
dG u; v
ð
Þ ¼ shortest distance from the vertex u to the vertex v
¼ min k : u !
k v
n
o
[If the graph G is connected then this shortest distance should be ﬁnite, i.e.,
dG u; v
ð
Þ\1 for 8u; v 2 G. Otherwise, G is disconnected]
Then clearly, since the graph G is connected V ¼ X [ Y and also by deﬁnition
of distance X \ Y ¼ ;.
Now, we show that V ¼ X [ Y is a bipartition of G by showing that any edge of
G must have one end vertex in X and another in Y:
Suppose that u; w 2 V G
ð Þ are both either in X or in Y and they are adjacent.
Let P : v !

 u and Q : v !

 w be the two shortest paths from v to u and v to w,
respectively.
Let x be the last common vertex of the two shortest paths P and Q such that
P ¼ P1P2 and Q ¼ Q1Q2 where P2 : x !

 u and Q2 : x !

 w are independent
(Fig. 2.12).
20
2
Subgraphs, Paths and Connected Graphs

Since P and Q are shortest paths, therefore, P1 : v !

 x and Q1 : v !

 x are
shortest paths from v to x.
Consequently, P1
j
j ¼ Q1
j
j
Now consider the following two cases.
Case 1: u; w 2 X, then P
j j is even and Q
j j is even (Also, P1
j
j ¼ Q1
j
j)
Case 2: u; w 2 Y, then P
j j is odd and Q
j j is odd (Also, P1
j
j ¼ Q1
j
j)
Therefore, in either case, P2
j
j þ Q2
j
j must be even and so uw 62 E G
ð Þ. Other-
wise, x !

 u ! w !

 x would be an odd cycle, which is a contradiction.
Therefore, X and Y are stable subsets of V: This implies X; Y
ð
Þ is a bipartition
of G: Therefore, G½X and G½Y are discrete induced subgraphs of G:
Hence, G is a bipartite graph.
If G is disconnected then each cycle of G will belong to any one of the
connected components of G say G1; G2; . . .; Gp.
If Gi is bipartite with bipartition
Xi; Yi
ð
Þ; then
X1 [ X2 [ X3 [       [ Xp;

Y1 [ Y2 [       [ YpÞ is a bipartition of G.
Hence, the disconnected graph G is bipartite.
h
Exercises:
1. Show that the following two graphs are isomorphic (Fig. 2.13).
Fig. 2.13
Fig. 2.12 Two shortest paths P and Q
2.5
Cycles
21

2. Check whether the following two graphs are isomorphic or not (Fig. 2.14).
Fig. 2.14
3. Show that the following graphs are isomorphic and each graph has the same
bipartition (Fig. 2.15).
Fig. 2.15
4. What is the difference between a closed trail and a cycle?
5. Are the following graphs isomorphic? (Fig. 2.16).
22
2
Subgraphs, Paths and Connected Graphs

Fig. 2.16
6. Prove that a simple graph having n number of vertices must be connected if it
has more than n  1
ð
Þ n  2
ð
Þ=2 edges.
7. Check whether the following two given graphs G1 and G2 are isomorphic or
not (Fig. 2.17).
Fig. 2.17
8. Prove that the number of edges in a bipartite graph with n vertices is at
most n2=2
ð
Þ.
9. Prove that there exists no simple graph with ﬁve vertices having degree
sequence 4; 4; 4; 2; 2.
10. Find, if possible, a simple graph with ﬁve vertices having degree sequence
2; 3; 3; 3; 3.
11. If a simple regular graph has n vertices and 24 edges, ﬁnd all possible values
of n:
2.5
Cycles
23

12. If d G
ð Þ and D G
ð Þ be the minimum and maximum degrees of the vertices of a
graph G with n vertices and e edges, show that
d G
ð Þ  2e
n  D G
ð Þ
13. Show that the minimum number of edges in a simple graph with n vertices is
n  k; where k is the number of connected components of the graph.
14. Find the maximum number of edges in
(a) a simple graph with n vertices
(b) a bipartite graph with bipartition
X; Y
ð
Þ where
X
j j ¼ m and
Y
j j ¼ n;
respectively.
24
2
Subgraphs, Paths and Connected Graphs

Chapter 3
Euler Graphs and Hamiltonian Graphs
3.1 Euler Tour and Euler Graph
Euler trail: A trail in G is said to be an Euler Trail if it includes all the edges of
graph G. Thus a trail is Euler if each edge of G is in the trail exactly once.
Tour: A tour of G is a closed walk of G which includes every edge of G at least
once.
Euler tour: An Euler Tour of a graph G is a tour which includes every edge of
G exactly once. In other words, a closed Euler Trail is an Euler Tour.
Euler graph: A graph G is called Eulerian or Euler graph if it has an Euler Tour.
For example, the graphs G1 and G2 of Fig. 3.1 have an Euler trail and an Euler
tour, respectively. In G1, an Euler trail is given by the sequence of edges
e1; e2; e3; e4; e5; e6; e7; e8; e9; e10;
while
in
G2
an
Euler
tour
is
given
by
e1; e2; e3; e4; e5; e6; e7; e8; e9; e10; e11; e12:
In G1: it has an Euler trail but not Euler tour because it is not closed.
In G2: all the vertices are even degree. Hence, it is Eulerian which implies it
contains the Euler tour. Since G2 contains Euler Tour so it is Eulerian.
Fig. 3.1 G1 is not an Euler graph, but G2 is an Euler graph
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_3,  Springer India 2013
25

Theorem 3.1(Euler Theorem) A connected graph G is Eulerian (Euler graph) iff
every vertex has an even degree.
Proof Necessary condition:
Let the graph G be Eulerian.
Let W : u !
 u be an Euler tour and v be any internal vertex such that v 6¼ u.
Suppose, v appears k times in this Euler tour W: Since every time an edge arrives
at v, another edge departs from v, and therefore, dG v
ð Þ ¼ 2k (Even). Also, dG u
ð Þ is
2, since W starts and ends at u.
Hence, the graph G has vertices of all even degree.
Sufﬁcient condition:
Let us assume G is a non-trivial connected graph such that for all vertex
v 2 VðGÞ; dGðvÞ is even.
To show: G is Eulerian.
Let W ¼ e1. . .en : v0 !
 vn; where ei ¼ vi1vi and W be the largest trail in G. It
follows that all e ¼ vnw 2 E G
ð Þ are among the edges of W; otherwise We would
be the longer than W in G, which is a contradiction. In particular, v0 ¼ vn;i.e., the
trail W is a closed trail. Indeed if v0 6¼ vn then vn may appear k times in the trail W;
then d vn
ð
Þ ¼ 2 k  1
ð
Þ þ 1 ¼ 2k  1 (Odd), which is a contradiction. So W should
be closed trail.
If W is not an Euler tour, then since G is connected, there exists an edge
f ¼ viu 2 EðGÞ for some i; such that f is not inW: Then, eiþ1. . .. . .ene1. . .eif is a
trail in G and it is longer than W: This contradiction to the choice of W proves the
claim. So, W is a closed Euler tour. Hence G is a Euler graph.
h
Theorem 3.2 A connected graph has an Euler trail iff it has at most two vertices
of odd degree.
Proof Necessary condition:
Let the graph G has an Euler trail u !
 v. Let w be any vertex which is different
from u and v, i.e., w 6¼ u; v. If w is a vertex different from the origin and terminus of
the trail, the degree of w is even. Since if w occurs k times then d w
ð Þ ¼ 2k(even).
Thus the only possible odd vertices are the origin and terminus of the trail.
If uðor vÞ occurs k times in W, then d u
ð Þ ¼ d v
ð Þ ¼ 2 k  1
ð
Þ þ 1 which is odd.
Hence G has at most two vertices of odd degree.
Sufﬁcient condition:
LetusassumeGtobeaconnectedgraphandGhasatmosttwoverticesofodddegree.
To show: G has an Euler trail.
If G has no odd degree vertices then G has an Euler trail. (just follows from
previous Euler theorem). Otherwise, by the Handshaking Theorem, every graph
has an even number of odd vertices. So, the graph G has exactly two such vertices
of odd degree say u and v. Let H be a graph obtained from G by adding a vertex w
and the edges uw and vw. So in graph H, every vertex has an even degree. Then,
according to Euler theorem H has a Euler tour say u !
 v ! w ! u: Here, the
beginning part u !
 v is an Euler trail of G.
Hence the theorem is proved.
h
26
3
Euler Graphs and Hamiltonian Graphs

3.2 Hamiltonian Path
Hamiltonian Path: A Hamiltonian path in a graph G is a path which includes every
vertex of G.
Hamiltonian Cycle/Circuit: A Hamiltonian cycle in a graph G is a cycle which
includes every vertex in G.
Hamiltonian Graph: A graph G is called Hamiltonian if it has a Hamiltonian
cycle.
In Fig. 3.2, G1 has no Hamiltonian path, G2 has a Hamiltonian path but no
Hamiltonian cycle, while G3 has a Hamiltonian cycle.
It is obvious that each complete graph Kn has a Hamiltonian cycle whenever
n  3: Consequently, Kn is Hamiltonian for n  3: Also, Km;n is Hamiltonian iff
m ¼ n  2:
3.2.1 Maximal Non-Hamiltonian Graph
A simple graph G is called maximal non-Hamiltonian if it is not Hamiltonian but
in addition to it, any edge connecting two nonadjacent vertices forms a Hamil-
tonian graph.
Theorem 3.3 (Dirac’s Theorem 1952) If G is a simple graph with n vertices
where n  3 and dðvÞ  n=2 for every vertex v of G, then G is Hamiltonian.
Proof We suppose that the result is not true. So, the graph G is Non-Hamiltonian.
Then for some value of n  3; there is a non-Hamitonian graph in which every
vertex has degree at least n=2: Any proper spanning supergraph also has every
vertex with degree at least n=2 because any proper spanning supergraph can be
obtained by introducing more edges in G. Thus, there will be a Maximal Non-
Hamiltonian graph of G with n vertices and dðvÞ  n=2 for every vertex v in G. But
the graph G cannot be complete, since if G is complete graph Kn then it would be a
Hamiltonian graph (for n  3). Therefore, there are two nonadjacent vertices u and
Fig. 3.2 G1 has no Hamiltonian path, G2 has a Hamiltonian path, and G3 has a Hamiltonian cycle
3.2
Hamiltonian Path
27

v in G. Let G þ uv be the supergraph of G obtained by introducing an edge uv:
Then, since G is Maximal Non-Hamiltonian graph, G þ uv must be a Hamiltonian
graph. Also, if C is a Hamiltonian cycle of G þ uv then C must contain the edge
uv: Otherwise it will be a Hamiltonian cycle in G. Thus, choosing such a cycle
C  v1v2. . .vnv1;where v1 ¼ u and vn ¼ v ðthe edge vnv1 is just vu i:e: uvÞ: So, the
cycle C contains the edge uv: Now let,
S ¼ vi 2 C : there is an edge from u to viþ1 in G
f
g
and
T ¼
vj 2 C : there is an edge from v to vj in G


Then, vn 62 T; since otherwise there would be an edge from v to vn ¼ v; i.e., a loop,
which is impossible because G is simple graph. Also, vn 62 S(interpreting vnþ1 as
v1), since otherwise we would again get a loop, this time from u to v1 ¼ u: Thus,
vn 62 S [ T. Let Sj j; T
j j and S [ T
j
j denote the number of elements in S; T; and
S [ T, respectively. Therefore,
S [ T
j
j\n
ð3:1Þ
Also, for every edge incident with u; there corresponds precisely one vertex vi in S:
Thus,
Sj j ¼ dðuÞ
ð3:2Þ
Similarly,
T
j j ¼ dðvÞ
ð3:3Þ
Moreover, if vk is a vertex belonging to both S and T; there is an edge e joining u to
vkþ1 and an edge f joining v to vk: This would give
C0  v1vkþ1vkþ2. . .vnvkvk1. . .v2v1
as a Hamiltonian cycle in G, which is a contradiction, since G is non-Hamiltonian
(Fig. 3.3). This shows that there is no vertex vk in S \ T, i.e., S \ T ¼ /. Thus,
S [ T
j
j ¼ Sj j þ T
j j: Hence, from Eq. (3.1), (3.2), and (3.3), we have
d u
ð Þ þ d v
ð Þ ¼ Sj j þ T
j j ¼ S [ T
j
j\n
This is impossible. Since, in G, dðuÞ  n=2 and dðvÞ  n=2; and therefore, d u
ð Þ þ
dðvÞ  n: This contradiction leads to the conclusion that we have wrongly assumed
the result to be false.
h
Theorem 3.4 Let G be a simple graph with n vertices and let u and v be non-
adjacent vertices in G such that d u
ð Þ þ dðvÞ  n: Let G þ uv denote the supergraph
of G obtained by joining u and v by an edge. Then, G is Hamiltonian iff G þ uv is
Hamiltonian.
28
3
Euler Graphs and Hamiltonian Graphs

Proof Suppose that G is Hamiltonian. Then from the previous Theorem 3.3, the
supergraph G þ uv must also be Hamiltonian. Conversely, suppose that G þ uv is
Hamiltonian. Then if G is not Hamiltonian, just as in proof of Theorem 3.3, we can
obtain the inequality d u
ð Þ þ d v
ð Þ\n: However, by hypothesis, d u
ð Þ þ dðvÞ  n:
Hence, G must also be Hamiltonian, as required.
h
The following theorem due to Ore generalizes an earlier result by Dirac (1952).
Ore’s Theorem (1962)
Theorem 3.5 A simple graph with n vertices (where n [ 2) is Hamiltonian if the
sum of the degrees of every pair of nonadjacent vertices is at least n.
Proof: Suppose a graph G with n vertices satisfying the given inequality con-
dition is not Hamiltonian. So it is a subgraph of the complete graph Kn with fewer
edges. We recursively add edges to the graph by joining nonadjacent vertices until
we obtain a graph H such that the addition of one more edge joining two non-
adjacent vertices in H will produce a Hamiltonian graph with n vertices. Let x and
y be two nonadjacent vertices in H. Thus they are nonadjacent in G also.
Since dðxÞ þ dðyÞ  n in G.
) dðxÞ þ dðyÞ  n in H as well.
If we join the nonadjacent vertices x and y, the resulting graph is Hamiltonian.
Hence, in graph H, there is a Hamiltonian path between the vertices x and y. If we
write x ¼ v1 and y ¼ vn, this Hamiltonian path can be written as
Fig. 3.3 A Hamiltonian cycle C0
1v
2v
...
1
−
iv
iv
1
+
iv
...
1
−
nv
nv
Fig. 3.4 A Hamiltonian path from v1 to vn
3.2
Hamiltonian Path
29

Suppose the degree of v1 is c in graph H. If there is an edge between v1 and vi in
this graph, the existence of an edge between vi1 and vnwill imply that H is Ham-
iltonian. So whenever vertices v1 and vi are adjacent in H, vertices vn and vi1 are not
adjacent (Fig. 3.4). This is true for 1 \ i \ n. Hence, dðvnÞ  ðn  1Þ  c; since the
degree of v1 is c: This implies that the sum of the degrees of the two nonadjacent
vertices in G is less than n; which contradicts the hypothesis. So any connected graph
satisfying the given condition is Hamiltonian (Figs. 3.5 and 3.6).
Example 3.1 If Km;n be a complete bipartite graph with bipartition (X, Y), then
X and Y contains the same number of vertices in Km;n, i.e., X
j j ¼ Y
j j
Solution:
Let Km;n has a bipartition (X,Y), where X
j j ¼ m and Y
j j ¼ n: Now, each cycle in
Km;n has even length as the graph is bipartite and thus the cycle visits the sets X and
Y equally many times, since X and Y are stable subsets. But then necessarily
X
j j ¼ Y
j j ¼ n:
Example 3.2 If G = (V, E) is a bipartite graph with bipartition (X,Y), where
X
j j ¼ Y
j j ¼ n and if the degree of each vertex is more than n/2, G is Hamiltonian.
Fig. 3.5 A Hamiltonian cycle v1viviþ1. . .vnvi1. . .v1
Fig. 3.6 Another representation of Hamiltonian cycle v1viviþ1. . .vnvi1. . .v1
30
3
Euler Graphs and Hamiltonian Graphs

Solution:
Suppose G is not Hamiltonian. Add as many edges as possible joining vertices in
X and Y until we obtain a graph H that will become Hamiltonian if one more such
edge is added. That is, H is maximal non-Hamiltonian graph. H cannot be com-
plete bipartite Kn;n: If the degree in G of each vertex is more than n/2, the degree of
each vertex in H is also more than n/2. Let u 2 X and v 2 Y be two nonadjacent
vertices in H. Obviously, there is a Hamiltonian path (Fig. 3.7) from u to v where
vi 2 X; iff i is odd. If there is an edge joining v1 and vi there cannot be an edge
joining vi1 and v2n; since H is non-Hamiltonian. Since dðuÞ [ n=2; we ﬁnd that
dðvÞ\n  n
2 ; which contradicts the hypothesis.
[Note: If vertex vi is adjacent to u then vi1 is not adjacent to v: So, if there are r
number of such vertices vi adjacent to u; there must be also r number of vertices
vi1 which are not adjacent to v: Now, there are n vertices in X which may be
adjacent to v: Therefore,
dðvÞ\n  dðuÞ ) dðvÞ\n  n
2 ; where dðuÞ [ n=2:
3.3 Complement and Self-Complementary Graph
Complement: Let G be a simple graph with n vertices. The complement G of G is
deﬁned to be the simple graph with the same vertex set as G and where two
vertices u and v are adjacent precisely when they are not adjacent in G. Intuitively,
the complement of G can be obtained from the complete graph Kn by deleting all
the edges of G. Figure 3.8 shows a graph G and its complementary graph G:
1
u =
2v
…
1
−
iv
iv
1
+
iv
…
v
n =
2
in H 
v
v
Fig. 3.7 A Hamiltonian path from u to v in H
Fig. 3.8 A graph G and its complementary graph G
3.2
Hamiltonian Path
31

Self-complementary: A simple graph is called self-complementary if it is iso-
morphic to its own complement. In Fig. 3.9, the graph G1 is self-complementary.
Example 3.3 Prove that if G is a self-complementary graph with n vertices then n
is either 4m or 4m þ 1 for some positive integer m:
Solution:
Let G be the complement of G. Then G þ G is a complete graph. The number of
edges in complete graph G þ G is nðn  1Þ=2:
Since G is self-complementary graph G must have nðn  1Þ=4 number of edges.
Therefore, n is congruent to 0 or 1 (modulo 4).
Hence, either n ¼ 4m or n ¼ 4m þ 1 where m is a positive integer.
Exercises:
1. Find the complements of the following graphs (Fig. 3.10)
Fig. 3.10
Fig. 3.9 A self-
complementary graph G1
32
3
Euler Graphs and Hamiltonian Graphs

2. Show that the following graphs are self-complementary (Fig. 3.11)
Fig. 3.11
3. Let G be a simple graph with n vertices and let G be its complement. Then
prove that for each vertex v in G; dG v
ð Þ þ dG v
ð Þ ¼ n  1:
4. Prove that a graph G with n vertices always has a Hamiltonian path if the sum
of the degrees of every pair of vertices vi; vj in G satisﬁes the condition
d vi
ð Þ þ d vj
 
 n  1
5. Show that the graph G1; of Fig. 3.12 is a Hamiltonian and that the graph G2 has
a Hamiltonian path but not a Hamiltonian cycle.
Fig. 3.12
6. Let G be a bipartite graph with bipartition V ¼ X [ Y:
(a) Show that if G is a Hamiltonian then X
j j ¼ Y
j j:
3.3
Complement and Self-Complementary Graph
33

(b) Show that if G is not Hamiltonian but has a Hamiltonian cycle then
X
j j ¼ Y
j j  1:
7. Let G be a simple k-regular graph with 2k  1 vertices. Prove that G is
Hamiltonian.
8. The Closure cðGÞ of a graph G of order n is obtained from G by recursively
joining pairs of nonadjacent vertices whose degree sum is at least n until no
such pair exists. Show that every graph has a unique closure.
9. Show that a graph is Hamiltonian if and only if its closure is Hamiltonian.
10. Show that a graph is Hamiltonian, if its closure is complete.
11. Give an example of a complete Hamiltonian Bipartite graph.
34
3
Euler Graphs and Hamiltonian Graphs

Chapter 4
Trees and Fundamental Circuits
4.1 Trees
Acyclic graph: A graph with no cycle is acyclic.
Tree: A tree is a connected acyclic graph.
Leaf: A leaf is a vertex of degree 1 (Pendant vertex). A leaf node has no
children nodes.
Rooted Tree: The root node of a tree is the node with no parents. There is at
most one root node in a rooted tree.
Depth and Level: The depth of a node v is the length of the path from the root to
the node v: In a rooted tree, a vertex v is said to be at level lðvÞ if v is at a distance
of lðvÞ from the root. The set of all nodes at a given depth is sometimes called a
level of the tree. The root node is at depth zero. Thus the root is at level 0.
Depth or Height of a tree: The depth or height of a tree is the length of the path
from the root to the deepest node in the tree. A (rooted) tree with only one node
(the root) has a depth of zero.
Forest: A forest is an acyclic graph, which is a collection of trees (Fig. 4.1).
Minimally connected graph: A connected graph is said to be minimally con-
nected if the graph becomes disconnected when one edge is removed (Fig. 4.2).
Fig. 4.1 The trees with at most three vertices
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_4,  Springer India 2013
35

Binary Tree: A tree in which there is exactly one vertex of degree two and each
of the other vertices is of degree one or three is called a binary tree (Fig. 4.3).
Since, the vertex of degree two is distinct from all other vertices, this vertex
serves as a root. Thus every binary tree is a rooted tree.
Some important properties of binary tree:
1. The number of vertices n in a binary tree is always odd.
2. Let p be the number of pendant vertices in a binary tree T. Then p ¼ ðn þ 1Þ=2:
3. The number of internal vertices in a binary tree is one less than the number of
pendant vertices.
[Hint: Let, q be the number of internal vertices except the root. 1 þ p þ q ¼ n
and 2 þ p þ 3q ¼ 2ðn  1Þ: Hence, p ¼ ðn þ 1Þ=2 and the number of internal
vertices 1 þ q ¼ n  p ¼ nþ1
2  1].
Fig. 4.2 a A minimally connected graph and b the graph which is not minimally connected
Fig. 4.3 The second tree is only Binary tree among the four trees
36
4
Trees and Fundamental Circuits

4. The minimum height of a n-vertex binary tree is equal to
log2 n þ 1
ð
Þ  1
d
e
(The ceiling function ceiling(x) = x
d e is the smallest integer not less than x).
Proof Let l be the height of the binary tree.
Therefore, the maximum level of any vertex of the tree is l:
If ni denotes the number of vertices at level i; then
n0 ¼ 1; n1  2; n2  22; n3  23; . . .; nl  2l:
Therefore,
n ¼ n0 þ n1 þ n2 þ    þ nl  1 þ 2 þ 22 þ    þ 2l
This implies
n  2lþ1  1
Consequently,
l  log2 n þ 1
ð
Þ  1
Hence, the minimum value of l ¼ log2 n þ 1
ð
Þ  1
d
e
5. The maximum height of a n-vertex binary tree is equal to ðn  1Þ=2.
Proof Let l be the height of the binary tree.
To construct a binary tree with n-vertex such that the farthest vertex is as far as
possible from the root, we must have exactly two vertices at each level, except at
the root, i.e., at the 0 level.
If ni denotes the number of vertices at level i, then
n0 ¼ 1; n1 ¼ 2; n2 ¼ 2; . . .; nl ¼ 2:
Therefore,
n ¼ n0 þ n1 þ n2 þ    þ nl ¼ 1 þ 2l
Hence, the maximum value of l ¼ ðn  1Þ=2:
4.2 Some Properties of Trees
Theorem 4.1 Every pair of vertices in a tree is connected by one and only one
path.
4.1
Trees
37

Proof Let T be a tree; A, B be an arbitrary pair of vertices. Since, T is a connected
graph so A and B are connected by a path. Let if possible, A and B be connected by
two distinct paths. These two paths together form a circuit and then T cannot be a
tree. So, there is only one path connecting A and B.
h
Theorem 4.2 (Converse of theorem 4.1) If there is one and only one path between
every pair of vertices in a graph G, then G is a tree.
Proof Existence of a path between every pair of vertices assures that G is con-
nected. Let, if possible, G posses a circuit. So, there exists at least one pair of
vertices say A, B such that there are two distinct paths between A and B. This
contradicts the hypothesis. So G does not have any circuit. Hence G is a tree. h
Theorem 4.3 A connected graph is a tree if and only if addition of an edge
between any two vertices in the graph creates exactly one circuit.
Proof If G is tree, it is connected and acyclic. If any two non-adjacent vertices are
joined by an edge, the unique path in G between the two vertices and the edge
together form a unique cycle.
Conversely, suppose G is connected. There cannot be a cycle in G since the
supergraph G0 of G, obtained by joining two non-adjacent vertices in G, has a
unique cycle. So, G is a tree.
h
Theorem 4.4 Any tree with two or more vertices contains at least two pendant
vertices.
Proof Any two vertices in a tree is connected by one and only one path. Since, the
tree is supposed to be a ﬁnite graph, so there exists a longest path P:
v0e0v1e1. . .vm1em1vm in the tree. Since, the tree has at least two vertices so
v0 6¼ vm:
Let, if possible, d v0
ð
Þ 6¼ 1: Since degree of vertices of a tree with at least two
vertices cannot be zero, so dðv0Þ [ 1: So there must be another edge e 6¼ e0 joining
v0 to a vertex v of T. If v ¼ vi for some i then the path v0e0v1e1. . .. . .vievo forms a
circuit. This is impossible, since T cannot have any circuit. If v is not equal to any
vi of the path P then v e v0e0v1e1. . .vm1em1vm becomes a path of length m ? 1.
This is again a contradiction, since the longest path in T has length m.
Thus, d v0
ð
Þ ¼ 1:
Similarly, we can show that dðvmÞ ¼ 1:
So, we see that v0 and vm are pendant and they are distinct. This completes the
proof.
h
Theorem 4.5 A tree with n number of vertices has n  1 number of edges.
Proof Let, T be a tree. The theorem will be proved by method of induction on
n. Clearly, the result is true for n = 1, 2.
We assume that, the result is true for k number of vertices whenever k\n. In
T (Fig. 4.4), let e be an edge with end vertices A and B. Since, two vertices in a tree
are connected by only one path so there is no other path between A and B. e is the
only path joining A and B. So, T  e , i.e., the graph obtained from T by deleting the
38
4
Trees and Fundamental Circuits

edge e becomes a disconnected graph. Now the graph T  e has exactly two
components say T1 and T2, such that T1 contains A and T2 contains B, respectively.
Let T1 and T2 contain n1 and n2 number of vertices. So, n ¼ n1 þ n2: If the com-
ponent T1contains a circuit then T would have a circuit which is not possible. So, T1
is a tree. Similarly, T2 is also a tree. So by the hypothesis, T1 has n1  1 and T2 has
n2  1 number of edges. Thus, T  e consists of ðn1  1Þ þ ðn2  1Þ ¼ n1 þ n2 
2 ¼ n  2 number of edges. Hence, T has n  2 þ 1 ¼ n  1 edges.
h
Theorem 4.6 (Converse of theorem 4.5) A connected graph with n vertices and
n - 1 edges is a tree.
Proof Let G be a connected graph with n vertices and n - 1 edges. Let, if pos-
sible, G be not a tree. Then G contains a circuit. Let e be an edge of this circuit.
Then the subgraph G - e is still connected. G - e has n - 2 edges and n verti-
ces. This is not possible since we know that a connected graph with n vertices has
at least n - 1 edges. This completes the proof.
h
Theorem 4.7 A graph is a tree if and only if it is minimally connected.
Proof Let T be a tree having n vertices. So, T has n  1 edges.
If one edge is removed from T then it has n  2 edges. Then, T becomes dis-
connected since a connected graph with n vertices must have at least n  1 number of
edges. Thus T is a minimally connected graph. Conversely, let T be a minimally
connected graph with n number of vertices. Since, T is connected graph, so number of
edges of T  n  1: Let, if possible, T not be a tree. Then, T contains a circuit.
T becomes still connected if one edge of this circuit is removed from T. This con-
tradicts our hypothesis that T is a minimally connected graph. Hence T is a tree. h
Theorem 4.8 A graph with n number of vertices, n  1 number of edges and
without any circuit is connected.
Proof Let G be a graph. Let, if possible, G be disconnected. Then G has two or
more components. Without loss of generality, suppose G1 and G2 be two such
components. Since, G1 and G2 are subgraphs of G they also do not contain any
circuit. Let vj and vk be two vertices in the components G1 and G2 , respectively.
Add an edge e between vj and vk (Fig. 4.5).
Fig. 4.4 A tree T with minimally connected edge e
4.2
Some Properties of Trees
39

Since there is no path between vj and vk in G, so adding e would not create a
circuit. Thus, the graph G together with e ði:e:G [ eÞ becomes a connected acyclic
graph, i.e., a tree. We see this tree is having n number of vertices and ðn  1Þ þ
1 ¼ n number of edges. This contradicts the fact that a tree having n vertices must
have n  1 edges. Hence, G is a connected graph.
h
4.3 Spanning Tree and Co-Tree
A tree T is called a spanning tree of a connected graph G if T is a subgraph of
G and if T contains all the vertices of G.
In other words, a spanning tree of a graph G is a spanning subgraph of G that is
a tree.
Branch of a tree: An edge of a tree is called a branch of the tree. For example,
a, c, f, and h are branches of T, in Fig. 4.6.
Chord of a tree: An edge of G that is not in T is called a chord of T in G. In Fig.
4.6, g is a chord of the spanning tree T in G.
Co-Tree: The complement of a spanning tree T in a connected graph G is called
Co-Tree of T. It is denoted by T. It is illustrated in Fig. 4.6.
4.3.1 Some Theorems on Spanning Tree
Theorem 4.9 A graph G has a spanning tree iff G is connected.
Fig. 4.6 A connected graph G, its spanning tree T, and co-tree T
Fig. 4.5 A connected graph G + e
40
4
Trees and Fundamental Circuits

Proof Let G be a connected graph. If G has no circuit then it is its own spanning
tree. If G contains a circuit then delete an edge from that circuit. Then the graph is
still connected. If the graph has no circuit then it becomes a spanning tree of
G. Otherwise, repeat the operation till an edge removed from the last circuit yields
a connected graph without any circuit. This left out graph contains all vertices of
G, because no vertices are removed in the above deletion process. So, this left out
tree is a spanning tree of G. Thus, G has a spanning tree.
Conversely, let G be a graph having a spanning tree, say T. Let v1 and v2 be two
arbitrary vertices of G. Since, T contains all the vertices of G, therefore v1 and
v2 2 T: Since, T is a tree, therefore T is connected and so v1 and v2 are connected
by a path. So, G is connected.
h
Theorem 4.10 Let, T be a spanning tree in a connected graph G. G has n vertices
and e edges. Then T has n - 1 branches and e – n ? 1 chords.
Proof This follows from the deﬁnition of branch and chord and from the fact that
a tree with n vertices contains n - 1 edges.
4.4 Fundamental Circuits and Fundamental Cut Sets
4.4.1 Fundamental Circuits
A circuit, formed by adding a chord to a spanning tree of a graph, is called a
fundamental circuit of the graph with respect to the spanning tree.
The circuit EGDBCFE in Fig. 4.7c is a fundamental circuit of the graph 4.7a
with respect to 4.7b. This fundamental circuit is obtained by adding the chord EF
to the spanning tree.
Fig. 4.7 A graph having a spanning tree with corresponding Fundamental circuit EGDBCFE
4.3
Spanning Tree and Co-tree
41

Note: if we add an edge between any two vertices of a tree, a circuit is created.
This is because of the fact that there already exists one path between any two
vertices of a tree (see Fig. 4.8); adding an edge between them creates an addi-
tional path and hence a circuit is formed.
Theorem 4.11 Let T be a spanning tree in a connected graph G. G has n vertices
and e edges, then 9 e  n þ 1 number of fundamental circuits formed by T.
Proof T has e  n þ 1 number of chords. Hence the theorem follows.
4.4.2 Fundamental Cut Set
Consider a spanning tree T of a connected graph G. In Fig. 4.9, the spanning tree
T is represented by the solid lines. Let us take any branch b in T. Since, {b} is a cut
set in T, {b} partitions all vertices of T into two disjoint sets. Consider the same
partition of vertices in G and the cut set S in G that corresponds to this partition.
Fig. 4.8 A tree (connected acyclic graph)
Fig. 4.9 A connected graph showing a spanning tree in solid lines
42
4
Trees and Fundamental Circuits

Cut set S will contain only one branch b of T, and the rest (if any) of the edges in
S are chords with respect to T. Such a cut set S containing exactly one branch of a
tree T is called a fundamental cut set with respect to T.
Example 4.1 How many fundamental circuits and cut sets are there in a graph
G with respect to any spanning tree with 10 vertices and 13 edges.
Solution: Spanning tree with 10 vertices has 9 edges. So, there are 9 fundamental
cut sets and there are 13 – 9 = 4 fundamental circuits.
Example 4.2 Find fundamental circuits for the graph shown below in Fig. 4.10.
Fig. 4.10
Solution: We have to ﬁnd a spanning tree and all the corresponding fundamental
circuits. First delete all loops and parallels. Consider, the circuit v2  v3  v4  v2.
Deleting the edge ðv2; v3Þ, we get the graph G1 (Fig. 4.11).
4.4
Fundamental Circuits and Fundamental Cut Sets
43

Fig. 4.11
Next, consider the circuit v3  v4  v5  v3. Delete ðv3; v5Þ and we get the
graph G2 (Fig. 4.12).
Fig. 4.12
44
4
Trees and Fundamental Circuits

Next, consider the circuit v2  v4  v7  v2. From this delete ðv2; v4Þ and we get
the graph G3 (Fig. 4.13).
Fig. 4.13
Next, consider the circuit v4  v7  v5  v4: From this delete ðv4; v5Þ and we
have the graph G4 (Fig. 4.14).
Fig. 4.14
4.4
Fundamental Circuits and Fundamental Cut Sets
45

Finally, delete the edge v5; v6
ð
Þ from the circuit v5  v6  v7  v5 and we get a
spanning tree as G5 (Fig. 4.15)
Now, the number of edges of the given graph, after converting it into a simple
one, e = 11, number of vertices n = 7. So there are e – n ? 1 = 11 – 7 ? 1 = 5
fundamental circuits which are v2  v4  v7  v2; v2  v3  v4  v7  v2; v4 
v5  v7  v4; v5  v6 v7  v5; v3  v4  v7  v5  v3:
Exercises:
1. Find the spanning tree of the following graph in Fig. 4.16. Hence ﬁnd out the
fundamental circuits and fundamental cut sets.
Fig. 4.16
Fig. 4.15 A spanning tree
G5
46
4
Trees and Fundamental Circuits

2. Prove that any tree with at least two vertices is a bipartite graph.
3. Let T be a tree and let u and v be two vertices of T which are not adjacent. Let
G be the supergraph of T obtained from T by joining u and v by an edge.
Prove that G contains a cycle.
4. Let T be a tree with n vertices, where n  4, and let v be a vertex of maximum
degree in T.
(a) Show that T is a path if and only if dðvÞ ¼ 2:
(b) Prove that if dðvÞ ¼ n  2 then any other tree with n vertices and maxi-
mum vertex degree n  2 is isomorphic to T.
(c) Prove that if n  6 and dðvÞ ¼ n  3 then there are exactly 3 non-iso-
morphic trees which T can be.
5. Let T be a tree with n vertices, where n  3. Show that there is a vertex v in T
with dðvÞ  2 such that every vertex adjacent to v, except possibly for one, has
degree 1.
6. Let T be a tree and let v be a vertex of maximum degree in T, say dðvÞ ¼ k.
Prove that T has at least k vertices of degree 1.
7. Let T be a tree with at least k edges, k  2: How many connected components
are there in the subgraph of T obtained by deleting k edges of T ?
8. Let G be a connected graph which is not a tree and let C be a cycle in G. Prove
that the complement of any spanning tree of G contains at least one edge of C.
9. Let G be a graph with exactly one spanning tree. Prove that G is a tree.
10. An edge e (not a loop) of a graph G is said to be contracted if it is deleted and
then its end vertices are fused. The resulting graph is denoted by G  e
illustrated in Fig. 4.17.
(a) Prove that if T is a spanning tree of G which contains e then T  e is a
spanning tree of G  e.
(b) Prove that if T0 is a spanning tree of G  e then there is a unique spanning
tree T of G which contains e and is such that T0 ¼ T  e.
11. Show that a Hamiltonian path is a spanning tree.
Fig. 4.17 A graph G showing edge deleted subgraph G -e and contracted subgraph G * e
4.4
Fundamental Circuits and Fundamental Cut Sets
47

Chapter 5
Algorithms on Graphs
5.1 Shortest Path Algorithms
Weighted network: A weighted network ðV; E; CÞ consists of a node set V, an edge
set E, and the weight set C specifying weights cij for the edges ði; jÞ 2 E:
5.1.1 Dijkstra’s Algorithm
We determine the shortest route or shortest distance along with the shortest path
between any two ﬁxed pair of vertices of a directed or undirected graph.
One of the most important and useful algorithm is Dijkstra’s shortest path
algorithm, a greedy algorithm that efﬁciently ﬁnds shortest paths in a graph. A
greedy algorithm for an optimization problem always makes the choice that looks
best at the moment and adds it to the current subsolution. It builds a solution by
repeatedly selecting the locally optimal choice among all options at each stage.
Because graphs are able to represent many things, many problems can be cast as
shortest-path problems, making Dijkstra’s algorithm a powerful and general tool.
5.1.1.1 Applications of Dijkstra’s Algorithm
• Dijkstra’s algorithm is applied to automatically ﬁnd directions between physical
locations, such as driving directions on websites like Mapquest or Google Maps.
• In a networking or telecommunication applications, Dijkstra’s algorithm has
been used for solving the min-delay path problem (which is the shortest path
problem). For example in data network routing, the goal is to ﬁnd the path for
data packets to go through a switching network with minimal delay.
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_5,  Springer India 2013
49

• It is also used for solving a variety of shortest path problems arising in plant and
facility layout, robotics, transportation, and very large-scale integration (VLSI)
design.
Dijkstra’s algorithm solves shortest path problem to ﬁnd the shortest path from
a given node s, called a starting node or an initial node, to all other nodes in the
network. This algorithm solves only the problems with non-negative costs
(weights), i.e., cij  0 for all ði; jÞ 2 E:
The algorithm characterizes each node by its state. The state of a node consists
of two features: distance value and status label.
• Distance value of a node is a scalar representing an estimate of its distance from
node s.
• Status label is an attribute specifying whether the distance value of a node is
equal to the shortest distance to node s or not.
(a) The status label of a node is Permanent if its distance value is equal to the
shortest distance from node s
(b) Otherwise, the status label of a node is Temporary
The algorithm maintains and step-by-step updates the states of the nodes.
At each step one node is designated as current.
5.1.1.2 Notations for Dijkstra’s Algorithm
• Label of a vertex: The label of a vertex v is deﬁned as length of the shortest
distance from the source vertex s to the corresponding vertex v and it is denoted
by lðvÞ:
• P or T denotes the status label of a node, where P stands for permanent and T
stands for temporary.
• cij is the cost (weight w i; j
ð
Þ or wij) of traversing link
i; j
ð
Þ as given by the
problem
The state of a node v is the ordered pair of its distance value lðvÞ and its status
label.
Dijkstra’s Algorithm:
Algorithm 5.1 Step 1: Set l sð Þ ¼ 0 and mark the label of s as permanent. And for
all the vertices v 6¼ s (non starting vertices), assign a temporary label l v
ð Þ ¼ 1
[The state of node s is ð0; PÞ and the state of every other node is ð1; TÞ] and
set u ¼ s ðDesignate the node s as the current node).
Step 2: If u be a vertex with permanent label, then for every edge e ¼ uv
incident with u, if l v
ð Þ [ l u
ð Þ þ wðeÞ
where w e
ð Þ is the weight of the edge
ð
e ¼ uv
ð
ÞÞ
and
v
is
the
temporary
label
vertex
then
½Update the label
ðdistance valuesÞof these nodes
set l v
ð Þ ¼ l u
ð Þ þ wðeÞ and predecessor v
ð Þ ¼ u:
50
5
Algorithms on Graphs

Step 3: Let k be a temporary label vertex for which lðkÞ is minimum. If no such
k vertex exists then 9 no shortest path from source vertex s to destination vertex t
(say). Otherwise go to step 4.
Step 4: Make the label of k as permanent. If k ¼ t then stop. Otherwise set u ¼ k
½Designate this node as the current node then go to step 2.
h
Dijkstra’s algorithm starts by assigning some initial values for the distances
from node s and to every other node in the network. It operates in steps, where at
each step the algorithm improves the distance values. At each step, the shortest
distance from node s to another node is determined.
5.1.1.3 Complexity
Dijkstra’s algorithm solves shortest path problem in OðjVj2Þ time. The algorithm
contains an outer loop executed jVj  1 times and inner loops, to ﬁnd the closest
vertex and update distances, executed O V
j j
ð
Þ times for each iteration of the outer
loop. Its time-complexity is therefore OðjVj2Þ, i.e., Oðn2Þ, where V
j j ¼ n.
Example 5.1 Apply Dijskra’s Algorithm, to ﬁnd the shortest route from node 1 to
6 of Fig. 5.1.
Fig. 5.1
Solution:
Initially, assign label 0 to the starting node 1 and make it permanent. Other non-
starting nodes must be assigned label 1 and temporary status (Table 5.1).
Table 5.1
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
1
1
1
1
1
Status ðvÞ
P
T
T
T
T
T
Predecessor ðvÞ
–
–
–
–
–
–
5.1
Shortest Path Algorithms
51

The temporary label vertices 2 and 4 are adjacent to 1. In Table 5.2, we update
the label of these vertices and also the predecessor of them must be 1.
We
search
the
minimum
among
temporary
labeled
vertices.
Min
18; 1; 15; 1; 1
ð
Þ ¼ 15 for which temporary labeled vertex 4 becomes permanent
in Table 5.3.
The temporary labeled vertices adjacent to vertex 4 are 2, 3, and 5. For the
vertex 2, l 4
ð Þ þ w 4; 2
ð
Þ ¼ 15 þ 6 ¼ 21, but in Table 5.3, label of node 2 was 18.
So, no change is required. In Table 5.4, we update the label of vertices 3 and 5 and
also the predecessor of them must be 4.
Again,
we
search
the
minimum
among
temporary
labeled
vertices.
Min ð18; 29; 22; 1Þ ¼ 18 for which temporary labeled vertex 2 becomes perma-
nent in Table 5.5.
Only vertex 3 is adjacent to 2. Since, l 2
ð Þ þ w 2; 3
ð
Þ ¼ 27. In Table 5.6, the new
label of 3 will be 27 and the corresponding predecessor will become 2.
Table 5.3 Minimum temporary labeled vertex 4 becomes permanent
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
1
15
1
1
Status ðvÞ
P
T
T
P
T
T
Predecessor ðvÞ
–
1
–
1
–
–
Table 5.2 Adjacent vertices of 1 are 2 and 4
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
1
15
1
1
Status ðvÞ
P
T
T
T
T
T
Predecessor ðvÞ
–
1
–
1
–
–
Table 5.4 Adjacent vertices of 4 are 2, 3, and 5
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
29
15
22
1
Status ðvÞ
P
T
T
P
T
T
Predecessor ðvÞ
–
1
4
1
4
–
Table 5.5 Minimum temporary labeled vertex 2 becomes permanent
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
29
15
22
1
Status ðvÞ
P
P
T
P
T
T
Predecessor ðvÞ
–
1
4
1
4
–
Table 5.6 Adjacent vertex of 2 is only 3
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
27
15
22
1
Status ðvÞ
P
P
T
P
T
T
Predecessor ðvÞ
–
1
2
1
4
–
52
5
Algorithms on Graphs

Since, the minimum among temporary labeled vertex is 5, it becomes perma-
nent in Table 5.7.
The temporary labeled vertices adjacent to vertex 5 are 3 and 6.
In Table 5.8,
1. For the vertex 3, l 5
ð Þ þ w 5; 3
ð
Þ ¼ 22 þ 10 ¼ 32: But in Table 5.7, label of
vertex 3 was 27. Consequently no change is required, since min (27, 32) = 27.
2. For the vertex 6, we update the new label of 6 and also update the predecessor
of it accordingly.
In Table 5.9, here, min (27, 58) = 27. So, label of 3 has been made permanent.
Only
vertex
6
is
adjacent
to
3.
In
Table 5.10,
for
the
vertex
6,
l 3
ð Þ þ w 3; 6
ð
Þ ¼ 27 þ 28 ¼ 55, but from the Table 5.9, min (55, 58) = 55.
Therefore, the new label of 6 is 55 and the updated predecessor will be 3.
Table 5.7 Minimum temporary labeled vertex 5 becomes permanent
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
27
15
22
1
Status ðvÞ
P
P
T
P
P
T
Predecessor ðvÞ
–
1
2
1
4
–
Table 5.8 Adjacent vertices of 5 are 3 and 6
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
27
15
22
58
Status ðvÞ
P
P
T
P
P
T
Predecessor ðvÞ
–
1
2
1
4
5
Table 5.9 Minimum temporary labeled vertex 3 becomes permanent
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
27
15
22
58
Status ðvÞ
P
P
P
P
P
T
Predecessor ðvÞ
–
1
2
1
4
5
Table 5.10 Adjacent vertex of 3 is 6
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
27
15
22
55
Status ðvÞ
P
P
P
P
P
T
Predecessor ðvÞ
–
1
2
1
4
3
Table 5.11 The destination vertex 6 becomes permanent
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
0
18
27
15
22
55
Status ðvÞ
P
P
P
P
P
P
Predecessor ðvÞ
–
1
2
1
4
3
5.1
Shortest Path Algorithms
53

Since, the destination vertex 6 becomes permanent, we shall stop here.
The required shortest distance from node 1 to 6 is 55 units, which is the
permanent label of the destination node.
To determine the shortest path, we backtrack from the destination node 6 to
starting node 1. From Tables 5.11, 5.9, and 5.5, we see that the predecessor of 6 is
3, predecessor of 3 is 2 and predecessor of 2 is 1 respectively.
Hence, the required shortest path is 1–2–3–6.
Moreover, it can be veriﬁed from the network in Fig. 5.1, the sum of the
weights of edges along the shortest path is 55.
Alternative approach:
Following the same argument as discussed above the Table 5.12 can be
constructed.
Table 5.12
Vertex ðvÞ
1
2
3
4
5
6
0
?
?
?
?
?
0
18
?
15
?
?
0
18
29
15
22
?
0
18
27
15
22
?
0
18
27
15
22
58
0
18
27
15
22
55
In Table 5.12, the permanent labels of the vertices are enclosed by the squares.
Since, the destination vertex 6 becomes permanent, we shall stop here.
The required shortest distance from vertex 1 to 6 is 55 units, which is the
permanent label of the destination vertex.
To determine the shortest path, we backtrack from the destination vertex 6 to
starting vertex 1. From Table 5.12, we see that label of vertex 6 changes to 55
from that row in which the permanent labeled vertex is 3. So, the predecessor of 6
is 3.
Again, label of vertex 3 changes to 27 from that row in which the permanent
labeled vertex is 2. Therefore, the predecessor of 3 is 2.
According to similar argument, the predecessor of 2 is 1.
Hence, the required shortest path is 1–2–3–6.
Example 5.2
A truck must deliver concrete from the ready-mix plant to a construction site. The
network in Fig. 5.2 represents the available routes between the plant and the site.
The distances from node-to-node are given along the route lines. Use Dijkstra’s
Algorithm, to determine the best route from plant to site.
54
5
Algorithms on Graphs

Fig. 5.2
Solution:
Initially, assign label 0 to the starting vertex 2 and make it permanent. Other non-
starting vertices must be assigned label 1 and temporary status (Table 5.13).
Table 5.13
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
1
0
1
1
1
1
Status ðvÞ
T
P
T
T
T
T
Predecessor ðvÞ
–
–
–
–
–
–
The temporary label vertices 3, 4, and 5 are adjacent to 2. We update the label
of these vertices and also the predecessor of them must be 2 (Table 5.14).
We
search
the
minimum
among
temporary
labeled
vertices.
Min
ð1; 1; 2; 7; 1Þ ¼ 1 for which temporary labeled vertex 3 becomes permanent in
Table 5.15.
The temporary label vertices 5 and 6 are adjacent to 3.
For the vertex 5, l 3
ð Þ þ w 3; 5
ð
Þ ¼ 1 þ 5 ¼ 6, but in Table 5.14, label of node 5
was 7. Since, min (7, 6) = 6, the new label of vertex 5 will be 6 in Table 5.16.
For the vertex 6, l 3
ð Þ þ w 3; 6
ð
Þ ¼ 1 þ 6 ¼ 7, and min ð1; 7Þ ¼ 7.
We update the label of vertex 6 and the predecessor of them must be 3 in
Table 5.16.
3
4
1
2
7
5
3
4
5
6
Plant
1
2
3
6
4
5
Site
Table 5.14 Adjacent vertices of 2 are 3, 4, 5
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
1
0
1
2
7
1
Status ðvÞ
T
P
T
T
T
T
Predecessor ðvÞ
–
–
2
2
2
–
Table 5.15 Minimum temporary labeled vertex 3 becomes permanent
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
1
0
1
2
7
1
Status ðvÞ
T
P
P
T
T
T
Predecessor ðvÞ
–
–
2
2
2
–
5.1
Shortest Path Algorithms
55

Again, we search the minimum among temporary labeled vertices. Min
ð1; 2; 6; 7Þ ¼ 2 for which temporary labeled vertex 4 becomes permanent
(Table 5.17).
The vertices 5 and 6 are adjacent to 4.
For the vertex 5, l 4
ð Þ þ w 4; 5
ð
Þ ¼ 2 þ 3 ¼ 5, but in Table 5.17, label of node 5
was 6. Since, min (6, 5) = 5, the new label of vertex 5 will be 5.
For the vertex 6, l 4
ð Þ þ w 4; 6
ð
Þ ¼ 2 þ 5 ¼ 7, and so, no change is required.
We update the label of vertex 5 and the predecessor of it must be 4
(Table 5.18).
Again, we search the minimum among temporary labeled vertices. Min
ð1; 5; 7Þ ¼ 5 for which temporary labeled vertex 5 becomes permanent in
Table 5.19.
Only vertex 6 is adjacent to 5. Since, l 5
ð Þ þ w 5; 6
ð
Þ ¼ 5 þ 4 ¼ 9. The label of 6
will remain unchanged. Consequently, Table 5.19 will be unaltered.
Now, we search the minimum among temporary labeled vertices. Min ð1; 7Þ ¼
7 for which temporary labeled vertex 6 becomes permanent in Table 5.20.
Table 5.16 Adjacent vertices of 3 are 5 and 6
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
1
0
1
2
6
7
Status ðvÞ
T
P
P
T
T
T
Predecessor ðvÞ
–
–
2
2
3
3
Table 5.17 Minimum temporary labeled vertex 4 becomes permanent
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
1
0
1
2
6
7
Status ðvÞ
T
P
P
P
T
T
Predecessor ðvÞ
–
–
2
2
3
3
Table 5.18 Adjacent vertices of 4 are 5 and 6
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
1
0
1
2
5
7
Status ðvÞ
T
P
P
P
T
T
Predecessor ðvÞ
–
–
2
2
4
3
Table 5.19 Minimum temporary labeled vertex 5 becomes permanent
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
1
0
1
2
5
7
Status ðvÞ
T
P
P
P
P
T
Predecessor ðvÞ
–
–
2
2
4
3
56
5
Algorithms on Graphs

Since, the destination vertex 6 becomes permanent, we shall stop here.
The required shortest distance from vertex (Plant) 2 to (Site) 6 is 7 units, which
is the permanent label of the destination vertex.
To determine the shortest path, we backtrack from the destination vertex 6 to
starting vertex 2. From Tables 5.20, and 5.15, we see that the predecessor of 6 is 3,
and predecessor of 3 is 2 respectively.
Hence, the required shortest path is 2–3–6.
Moreover, it can be veriﬁed from the network in Fig. 5.2, the sum of the
weights of edges along the shortest path is 7.
Alternative approach:
Following the same argument as discussed above the following table can be con-
structed.InTable 5.21,thepermanentlabelsoftheverticesareenclosedbythesquares.
Table 5.21
Vertex ðvÞ
1
2
3
4
5
6
?
0
?
?
?
?
?
0
1
2
7
?
?
0
1
2
6
7
?
0
1
2
5
7
?
0
1
2
5
7
Since, the destination vertex 6 becomes permanent, we shall stop here.
The required shortest distance from vertex 2 to 6 is 7 units, which is the
permanent label of the destination vertex.
To determine the shortest path, we backtrack from the destination vertex 6 to
starting vertex 2. From Table 5.21, we see that label of vertex 6 changes to 7 from
that row in which the permanent labeled vertex is 3. So, predecessor of 6 is 3.
Again, label of vertex 3 changes to 1 from that row in which the permanent
labeled vertex is 2. So, predecessor of 3 is 2.
Hence, the required shortest path is 2–3–6.
5.1.2 Floyd-Warshall’s Algorithm
The problem of ﬁnding the shortest path between all pairs of vertices on a graph is
akin to making a table of all of the distances between all pairs of cities on a road map.
The
Floyd-Warshall
All-Pairs-Shortest-Path
algorithm
uses
a
dynamic-
programming methodology to solve the All-Pairs-Shortest-Path problem. It uses a
Table 5.20 Minimum temporary labeled vertex 6 becomes permanent
Vertex ðvÞ
1
2
3
4
5
6
Label ðvÞ
1
0
1
2
5
7
Status ðvÞ
T
P
P
P
P
P
Predecessor ðvÞ
–
–
2
2
4
3
5.1
Shortest Path Algorithms
57

recursive approach to ﬁnd the minimum distances between all nodes in a graph.
The striking feature of this algorithm is its usage of dynamic programming to
avoid redundancy and thus solving the All-Pairs-Shortest-Path problem in Oðn3Þ:
This algorithm is more general than Dijkstra’s Algorithm because it determines
the shortest route between any two nodes or vertices in the network.
5.1.2.1 Applications of Floyd-Warshall’s Algorithm
The Floyd-Warshall’s Algorithm can be used to solve the following problems,
among others:
1. Shortest paths in directed graph.
2. Transitive closure of directed graphs.
3. Finding a regular expression denoting the regular language accepted by a ﬁnite
automaton (Kleen’s Algorithm).
4. Inversion of real matrices (Gauss Jardon Algorithm).
5. Optimal routing. In this application one is interested in ﬁnding the path with the
maximal ﬂow between two vertices.
6. Testing whether an undirected graph is bipartite.
To determine the shortest route between every pair of vertices in the network,
this algorithm requires two matrices, viz.
1. Distance Matrix D
and
2. Node Sequence Matrix S
Floyd-Warshall’s Algorithm:
Algorithm 5.2 Initial step: Deﬁne the initial distance matrix Dð0Þ and initial node
sequence matrix Sð0Þ as follows:
1. Set all diagonal elements of Dð0Þ to 0.
That is dð0Þ
ii
¼ 0;
i ¼ 1; 2; . . .; n
2. And also, set all elements of Sð0Þ to zero. i.e., sð0Þ
ij
¼ 0
8i; j ¼ 1; 2; . . .; n.
Then set k = 1.
Step-k: ð1  k  nÞ
If the condition dðk1Þ
ij
[ dðk1Þ
ik
þ dðk1Þ
kj
ðfor i; j ¼ 1; 2; . . .; n: Provided i 6¼
k ; j 6¼ k; i 6¼ jÞ is satisﬁed (Fig. 5.3)
1. Create DðkÞ by replacing dðk1Þ
ij
in Dðk1Þ with dðk1Þ
ik
þ dðk1Þ
kj
.
2. Create node sequence matrix SðkÞ by replacing sðk1Þ
ij
in Sðk1Þ with k.
Then, set k ¼ k þ 1, repeat step k until k ¼ n.
58
5
Algorithms on Graphs

After n steps, we can determine the shortest route between vertices i and j from
the two matrices DðnÞ and SðnÞ using the following rules:
1. From DðnÞ; dðnÞ
ij
gives the shortest distance between vertices i and j.
2. From SðnÞ, determine the intermediate vertex k ¼ sðnÞ
ij
which yields the route
i  k  j. If k ¼ 0, then stop. Otherwise, repeat the procedure between vertices i
and k and vertices k and j.
h
For a path P  v1  v2. . .  vl, we say that the vertices v2; v3; . . .; vl1 are the
intermediate vertices of this path. Note that a path consisting of a single edge has
no intermediate vertices. We deﬁne dðkÞ
ij to be the distance along the shortest path
from i to j such that any intermediate vertices on the path are chosen from the set
f1; 2; . . .; ng, as cited in Fig. 5.3. In other words, we consider a path from i to j
which either consists of the single edge ði; jÞ, or it visits some intermediate vertices
along the way, but these intermediate can only be chosen from f1; 2; . . .; ng. The
path is free to visit any subset of these vertices, and to do so in any order.
Fig. 5.3
5.1.2.2 Complexity
With three nested loops of general Step k, Floyd’s algorithm runs in OðjVj3Þ-time.
Therefore, the time Complexity of this algorithm is Oðn3Þ, where V
j j ¼ n.
Example 5.3 Applying Floyd-Warshall’s Algorithm, determine the shortest route
from node 1 to 4 and from node 2 to 4 of the following Network (Fig. 5.4).
5.1
Shortest Path Algorithms
59

Fig. 5.4
Solution:
Initial step:
1
2
3
4
1
2
3
4
Dð0Þ ¼
1
2
3
4
0
8
1
1
1
0
1
1
4
1
0
1
1
2
9
0
2
6664
3
7775; Sð0Þ ¼
1
2
3
4
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
2
6664
3
7775
At each Step kðk ¼ 1; 2. . .; n ¼ 4Þ, node k is considered as intermediate node
between every pair of nodes. The kth row, kth column, and diagonal elements of
Dðk1Þ and Sðk1Þ will remain unchanged in Step k.
Step-1:
1
2
3
4
1
2
3
4
Dð1Þ ¼
1
2
3
4
0
8
1
1
1
0
1
1
4
12
0
5
1
2
9
0
2
6664
3
7775;
Sð1Þ ¼
1
2
3
4
0
0
0
0
0
0
0
0
0
1
0
1
0
0
0
0
2
6664
3
7775
Step-2:
1
2
3
4
1
2
3
4
Dð2Þ ¼
1
2
3
4
0
8
9
1
1
0
1
1
4
12
0
5
1
2
3
0
2
6664
3
7775;
Sð2Þ ¼
1
2
3
4
0
0
2
0
0
0
0
0
0
1
0
1
0
0
2
0
2
6664
3
7775
60
5
Algorithms on Graphs

Step-3:
1
2
3
4
1
2
3
4
Dð3Þ ¼
1
2
3
4
0
8
9
1
5
0
1
6
4
12
0
5
7
2
3
0
2
6664
3
7775;
Sð3Þ ¼
1
2
3
4
0
0
2
0
3
0
0
3
0
1
0
1
3
0
2
0
2
6664
3
7775
Step-4:
1
2
3
4
1
2
3
4
Dð4Þ ¼
1
2
3
4
0
3
4
1
5
0
1
6
4
7
0
5
7
2
3
0
2
6664
3
7775;
Sð4Þ ¼
1
2
3
4
0
4
4
0
3
0
0
3
0
4
0
1
3
0
2
0
2
6664
3
7775
Now, from matrices Dð4Þ and Sð4Þ, we can now determine the shortest route
between every pair of nodes.
The shortest distance from node 1 to node 4 is dð4Þ
14 ¼ 1 unit.
To determine the associated path, we determine the intermediate node
k ¼ sð4Þ
14 ¼ 0, which indicates that there is no intermediate node between 1 and 4.
Therefore, the shortest path is 1–4.
Again, the shortest distance from node 2 to node 4 is dð4Þ
24 ¼ 6 units. To
determine the associated path, we determine the intermediate node k ¼ sð4Þ
24 ¼ 3
between nodes 2 and 4, yields the route 2–3–4. Since, sð4Þ
23 ¼ 0; no further inter-
mediate node exists between nodes 2 and 3. From Sð4Þ, we determine the inter-
mediate node sð4Þ
34 ¼ 1 between nodes 3 and 4, yields the route 3–1–4. But, since,
sð4Þ
31 ¼ 0 and sð4Þ
14 ¼ 0, so no further node exists between nodes 3 and 1 and also
between nodes 1 and 4, respectively.
The combined result now gives the shortest path as 2–3–1–4. The associated
length of the route is 6 units.
Example 5.4 Using Floyd-Warshall’s Algorithm, determine the shortest route
from node 1 to 5 of the following Network (Fig. 5.5).
5.1
Shortest Path Algorithms
61

Fig. 5.5
Solution:
Initial step:
1
2
3
4
5
1
2
3
4
5
Dð0Þ ¼
1
2
3
4
5
0
3
10
1
1
3
0
1
5
1
10
1
0
6
15
1
5
6
0
4
1
1
1
4
0
2
6666664
3
7777775
;
Sð0Þ ¼
1
2
3
4
5
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
2
6666664
3
7777775
At each Step kðk ¼ 1; 2. . .; n ¼ 5Þ, node k is considered as intermediate node
between every pair of nodes. The kth row, kth column, and diagonal elements of
Dðk1Þ and Sðk1Þ will remain unchanged in Step k.
Step-1:
1
2
3
4
5
1
2
3
4
5
Dð1Þ ¼
1
2
3
4
5
0
3
10
1
1
3
0
13
5
1
10
13
0
6
15
1
5
6
0
4
1
1
1
4
0
2
6666664
3
7777775
;
Sð1Þ ¼
1
2
3
4
5
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
2
6666664
3
7777775
Step-2:
1
2
3
4
5
1
2
3
4
5
Dð2Þ ¼
1
2
3
4
5
0
3
10
8
1
3
0
13
5
1
10
13
0
6
15
8
5
6
0
4
1
1
1
4
0
2
6666664
3
7777775
;
Sð2Þ ¼
1
2
3
4
5
0
0
0
2
0
0
0
1
0
0
0
1
0
0
0
2
0
0
0
0
0
0
0
0
0
2
6666664
3
7777775
62
5
Algorithms on Graphs

Step-3:
1
2
3
4
5
1
2
3
4
5
Dð3Þ ¼
1
2
3
4
5
0
3
10
8
25
3
0
13
5
28
10
13
0
6
15
8
5
6
0
4
1
1
1
4
0
2
6666664
3
7777775
;
Sð3Þ ¼
1
2
3
4
5
0
0
0
2
3
0
0
1
0
3
0
1
0
0
0
2
0
0
0
0
0
0
0
0
0
2
6666664
3
7777775
Step-4:
1
2
3
4
5
1
2
3
4
5
Dð4Þ ¼
1
2
3
4
5
0
3
10
8
12
3
0
11
5
9
10
11
0
6
10
8
5
6
0
4
12
9
10
4
0
2
6666664
3
7777775
;
Sð4Þ ¼
1
2
3
4
5
0
0
0
2
4
0
0
4
0
4
0
4
0
0
4
2
0
0
0
0
4
4
4
0
0
2
6666664
3
7777775
Step-5:
1
2
3
4
5
1
2
3
4
5
Dð5Þ ¼
1
2
3
4
5
0
3
10
8
12
3
0
11
5
9
10
11
0
6
10
8
5
6
0
4
12
9
10
4
0
2
6666664
3
7777775
;
Sð5Þ ¼
1
2
3
4
5
0
0
0
2
4
0
0
4
0
4
0
4
0
0
4
2
0
0
0
0
4
4
4
0
0
2
6666664
3
7777775
Now, from matrices Dð5Þ and Sð5Þ, we can now determine the shortest route
between every pair of nodes. For instance, let us consider the nodes 1 and 5.
The shortest distance from node 1 to node 5 is dð5Þ
15 ¼ 12.
To determine the associated route, we determine the intermediate node
k ¼ sð5Þ
15 ¼ 4, which yields the route 1–4–5.
Again, we determine the intermediate node k ¼ sð5Þ
14 ¼ 2 between nodes 1 and 4,
yields the route 1–2–4. Since, sð5Þ
12 ¼ 0, no further intermediate node exists between
nodes 1 and 2. Similarly, no intermediate node exists between nodes 2 and 4.
Again, since, sð5Þ
45 ¼ 0, no further intermediate node exists between nodes 4 and
5.
The combined result now gives the shortest route as 1–2–4–5. The associated
length of the route is 12 units.
Example 5.5 Using Floyd-Warshall’s Algorithm, determine the shortest route
between all pair of vertices of the following Network (Fig 5.6).
5.1
Shortest Path Algorithms
63

Fig. 5.6
Solution:
Initial step:
1
2
3
4
5
1
2
3
4
5
Dð0Þ ¼
1
2
3
4
5
0
8
3
5
1
8
0
2
1
5
1
1
0
3
4
6
1
1
0
7
1
5
1
1
0
2
6666664
3
7777775
;
Sð0Þ ¼
1
2
3
4
5
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
2
6666664
3
7777775
At each Step kðk ¼ 1; 2. . .; n ¼ 5Þ, node k is considered as intermediate node
between every pair of nodes. The kth row, kth column, and diagonal elements of
Dðk1Þ and Sðk1Þ will remain unchanged in Step k.
Step-1:
1
2
3
4
5
1
2
3
4
5
Dð1Þ ¼
1
2
3
4
5
0
8
3
5
1
8
0
2
13
5
1
1
0
3
4
6
14
9
0
7
1
5
1
1
0
2
6666664
3
7777775
;
Sð1Þ ¼
1
2
3
4
5
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
2
6666664
3
7777775
Step-2:
1
2
3
4
5
1
2
3
4
5
Dð2Þ ¼
1
2
3
4
5
0
8
3
5
13
8
0
2
13
5
9
1
0
3
4
6
14
9
0
7
13
5
7
18
0
2
6666664
3
7777775
;
Sð2Þ ¼
1
2
3
4
5
0
0
0
0
2
0
0
0
1
0
2
0
0
0
0
0
1
1
0
0
2
0
2
2
0
2
6666664
3
7777775
64
5
Algorithms on Graphs

Step-3:
1
2
3
4
5
1
2
3
4
5
Dð3Þ ¼
1
2
3
4
5
0
4
3
5
7
8
0
2
5
5
9
1
0
3
4
6
10
9
0
7
13
5
7
10
0
2
6666664
3
7777775
;
Sð3Þ ¼
1
2
3
4
5
0
3
0
0
3
0
0
0
3
0
2
0
0
0
0
0
3
1
0
0
2
0
2
3
0
2
6666664
3
7777775
Step-4:
1
2
3
4
5
1
2
3
4
5
Dð4Þ ¼
1
2
3
4
5
0
4
3
5
7
8
0
2
5
5
9
1
0
3
4
6
10
9
0
7
13
5
7
10
0
2
6666664
3
7777775
;
Sð4Þ ¼
1
2
3
4
5
0
3
0
0
3
0
0
0
3
0
2
0
0
0
0
0
3
1
0
0
2
0
2
3
0
2
6666664
3
7777775
Step-5:
1
2
3
4
5
1
2
3
4
5
Dð5Þ ¼
1
2
3
4
5
0
4
3
5
7
8
0
2
5
5
9
1
0
3
4
6
10
9
0
7
13
5
7
10
0
2
6666664
3
7777775
;
Sð5Þ ¼
1
2
3
4
5
0
3
0
0
3
0
0
0
3
0
2
0
0
0
0
0
3
1
0
0
2
0
2
3
0
2
6666664
3
7777775
The shortest route between all pair of vertices of the given network can be
obtained from the above matrices Dð5Þ and Sð5Þ, where the shortest distance between
each pair of vertices can be found from Dð5Þ and the shortest path can be found from
Sð5Þ respectively. Table 5.22 shows the shortest route between all pair of vertices.
Table 5.22
Starting node to destination node
Shortest distance
Shortest path
1–2
4
1–3–2
1–3
3
1–3
1–4
5
1–4
1–5
7
1–3–5
2–1
8
2–1
2–3
2
2–3
2–4
5
2–3–4
2–5
5
2–5
(continued)
5.1
Shortest Path Algorithms
65

Table 5.22 (continued)
Starting node to destination node
Shortest distance
Shortest path
3–1
9
3–2–1
3–2
1
3–2
3–4
3
3–4
3–5
4
3–5
4–1
6
4–1
4–2
10
4–1–3–2
4–3
9
4–1–3
4–5
7
4–5
5–1
13
5–2–1
5–2
5
5–2
5–3
7
5–2–3
5–4
10
5–2–3–4
5.1.2.3 Comparison Between Floyd-Warshall’s Algorithm
with Dijkstra’s Algorithm
The all-pairs-shortest-path problem is generalization of the single-source-shortest
path problem, so we can use Floyd’s Algorithm or Dijkstra’s Algorithm (Varying
the source node over all nodes)
1. The time complexity of Floyd’s Algorithm is O
V
j j3


i:e: O n3
ð
Þ, where
V
j j ¼ n.
2. The time complexity of Dijkstra’s Algorithm with an adjacency matrix is
Oðn2Þ. So, varying over n source nodes, it is Oðn3Þ.
3. The time complexity of Dijkstra’s Algorithm with an adjacency list (the rep-
resentation of all edges in a graph as a list) is OðE:log V
j jÞ. So, varying over n
source nodes, it is Oð V
j jE log V
j jÞ.
For large sparse graph, Dijkstra’s Algorithm is preferable.
5.2 Minimum Spanning Tree Problem
Consider the following example of laying telephone cable in a locality as shown in
Fig. 5.7a.
66
5
Algorithms on Graphs

Fig. 5.7
Figure 5.7a summarizes the distance network of the locality. The number on
each edge represents the distance between the nodes connected by that edge.
5.2.1 Objective of Minimum Spanning Tree Problem
The objective of the minimum spanning tree problem is to connect the nodes of the
network by a set of edges such that the total length of the edges is minimized. In
process of constructing the minimum spanning tree, it should be taken care that
there is no cycle in it. With reference to the telephone cable laying example, the
objective is to connect all the nodes by a set of edges such that the total length of
the telephone cable to be laid is minimized.
In this section, the following algorithms for the minimum spanning tree
problem are presented,
• Prim’s Algorithm
• Kruskal’s Algorithm
5.2
Minimum Spanning Tree Problem
67

5.2.2 Minimum Spanning Tree
Let G be a weighted graph in which each edge e has been assigned a real number
wðeÞ, called the weight of the edge e. If H be a subgraph of a weighted graph, the
weight wðHÞ of H, is the sum of the weights w e1
ð
Þ þ w e2
ð
Þ þ    þ wðekÞ where
fe1; e2; . . .; ekg is the set of edges of H.
A spanning tree T of a weighted graph G is called a minimal spanning tree if its
weight is minimum. That is w T
ð Þ is minimum where w T
ð Þ ¼ w e1
ð
Þ þ w e2
ð
Þ þ
   þ wðekÞ and fe1; e2; . . .; ekg is the set of edges of T.
Many optimization problems involves ﬁnding in a suitable weighted graph, a
certain type of subgraph with minimum weight. To illustrate, let G be the graph
whose vertex set is the set of cities and in which uv be an edge if and only if it is
possible to build a pipeline joining the cities u and v. We can then consider G as a
weighted graph by assigning to each edge the cost of constructing the corre-
sponding pipeline. For example, suppose that there are six cities A; B; C; D; E; F
and we get the weighted graph G as shown in Fig. 5.7b.
Absence of an edge from B to D indicates that it is not possible to build a
pipeline from B to D. The number (weight) ﬁve assigned to the edge from F to
D indicates the cost of building a pipeline from F to D.
Since the problem is to ensure that every city is supplied with water from the
source city, we are looking for a connected spanning subgraph of G. Moreover,
since we want to do this in the most economical way, such a spanning subgraph
should have no cyles, because the deletion of an edge (a pipeline) from a cycle in a
connected spanning subgraph still leaves us with a connected spanning subgraph.
Therefore, we are looking for a spanning tree of G. Moreover the economical
factor implies that we want the cheapest such spanning tree, i.e., a spanning tree
with minimum weight.
Here, we now present two algorithms, due to Kruskal and Prim, for ﬁnding a
minimal spanning tree for a connected weighted graph where no weight is
negative.
5.2.2.1 Kruskal’s Algorithm
Let G ¼ ðV; EÞ be a weighted connected graph.
Step-1: Select one edge ei of G such that its weight wðeiÞ is minimum.
Step-2:
1. If the edges e1; e2; . . .; ek have been chosen then select an edge ekþ1 such that
ekþ1 6¼ ei for i ¼ 1; 2; . . .; k
2. The edges e1; e2; . . .; ek; ekþ1 does not form a circuit.
3. The weight of wðekþ1Þ is as small as possible subject to the condition number 2
of step-2 above.
68
5
Algorithms on Graphs

Step-3:
Stop, when all the vertices of G are in T which is the required spanning tree of
G with n  1 edges.
Example 5.6 Use Kruskal’s Algorithm, to ﬁnd the minimum spanning tree of the
graph in Fig. 5.8
Fig. 5.8
Solution:
Sl. number
Edge
Weight
Corresponding graph
1
(1,2)
10
2
(6,3)
15
3
(4,6)
20
4
(2,6)
25
(continued)
5.2
Minimum Spanning Tree Problem
69

5
(3,5)
35
The required Minimal Spanning tree is
Total Weight ¼ 10 þ 15 þ 20 þ 25 þ 35 ¼ 105 units which is minimum
weight of the Spanning Tree in Fig. 5.9.
Example 5.7 Apply Kruskal’s Algorithm, to ﬁnd the minimum spanning tree of
the graph in Fig. 5.10
Fig. 5.10
Fig. 5.9 A minimal
spanning tree
70
5
Algorithms on Graphs

Solution:
Sl. number
Edge
Weight
Corresponding graph
1
FG
4
2
CD
4
3
FD
6
4
EB
6
5
EF
6
6
AB
12
5.2
Minimum Spanning Tree Problem
71

Total Weight ¼ 4 þ 4 þ 6 þ 6 þ 6 þ 12 ¼ 38 units which is minimum weight
of the Spanning Tree appears in Sl. No. 6.
5.2.2.2 Prim’s Algorithm
Let T be a tree in a connected weighted graph G represented by two sets: the set of
vertices in T and set of edges in T.
Step-1: Start with a vertex v0 (say) in G and no edge such that T ¼ fv0g; /
f
g
Step-2: Find the edge e1 ¼ ðv0; v1Þ in G such that the end vertex v0 is in T and
its weight is minimum, i.e., wðe1Þ is minimum. Adjoin v1 and e1 to T, i.e.,
T ¼
v0; v1
f
g; e1
f
g.
Step-3: Choose the next edge eij ¼ ðvi; vjÞ in such a way that end vertex vi is in
T and end vertex vj is not in T and weight of eij is as small as possible. Adjoin vj
and eij to T.
Step-4: Repeat step-3 until T contains all the vertices of G. The set T will give
minimal spanning tree of G.
Example 5.8 Apply Prim’s Algorithm, to ﬁnd the minimum spanning tree of the
graph in Fig. 5.10.
Solution:
The Adjacency matrix XðGÞ, see Chap. 6, is
A
B
C
D
E
F
G
XðGÞ ¼
A
B
C
D
E
F
G
0
12
1
1
14
1
20
12
0
12
10
6
1
1
1
12
0
4
1
1
1
1
10
4
0
1
6
1
14
6
1
1
0
6
8
1
1
1
6
6
0
4
20
1
1
1
8
4
0
2
666666666664
3
777777777775
Sl.
no.
Tree T
Corresponding tree T
1
T ¼ ffAg; /g
Minimum weight in the row of A is
12 corresponding to the column
of vertex B. We include vertex B
and edge ðA; BÞ to T
2
T ¼ ffA; Bg; fðA; BÞgg
Minimum weight in the rows of A and B
is 6 corresponding to the column
of vertex E. We include vertex E and
edge ðB; EÞ to T
(continued)
72
5
Algorithms on Graphs

(continued)
Sl.
no.
Tree T
Corresponding tree T
3
T ¼ ffA; B; Eg; f A; B
ð
Þ; ðB; EÞgg
Minimum weight in the rows of A; B and E
is 6 occurs in the row of corresponding to the
column of vertex F. We include vertex F and
edge ðE; FÞ to T
4
T ¼ ffA; B; E; Fg; f A; B
ð
Þ; B; E
ð
Þ; ðE; FÞgg
Minimum weight in the rows of A; B; E
and F is 4 occurs in the row
of F corresponding
to the column of vertex G. We include
vertex G and edge ðF; GÞ to T
5
T ¼
A; B; E; F; Gg; f A; B
ð
Þ;
f
f
B; E
ð
Þ; E; F
ð
Þ; F; G
ð
Þgg
Minimum weight in the rows
of A; B, E; F and
G is 4. But the corresponding vertices F and
G are already present in T. The next minimum
is 6 occurs in the row of F corresponding
to the column of vertex D. We include
vertex D and edge ðF; DÞ to T
(continued)
5.2
Minimum Spanning Tree Problem
73

Total Weight ¼ 12 þ 6 þ 6 þ 4 þ 6 þ 4 ¼ 38 units which is the minimum
weight of the Spanning Tree appears in Sl. No. 7.
(continued)
Sl.
no.
Tree T
Corresponding tree T
6
T ¼ ffA; B; D; E; F; Gg; f A; B
ð
Þ; B; E
ð
Þ;
E; F
ð
Þ; F; G
ð
Þ; ðF; DÞgg
Minimum weight in the rows
of A; B; D; E; F; and G is 4, in the row
of D corresponding to the column of vertex C.
We include vertex C and edge ðD; CÞ to T.
7
T ¼
A; B; C; D; E; F; G
f
g;
A; B
ð
Þ; B; E
ð
Þ;
f
f
E; F
ð
Þ; F; G
ð
Þ; F; D
ð
Þ; D; C
ð
Þgg
74
5
Algorithms on Graphs

Example 5.9 Apply Prim’s Algorithm, to ﬁnd the minimum spanning tree of the
graph in Fig. 5.11.
Fig. 5.11
Solution:
The Adjacency matrix XðGÞ is
1
2
3
4
5
6
XðGÞ ¼
1
2
3
4
5
6
0
2
4
2
0
7
4
7
0
1
11
8
1
1
1
1
1
1
1
1
1
11
1
1
8
1
1
0
6
1
6
0
9
1
9
0
2
666666664
3
777777775
Sl.
no.
Tree T
Corresponding tree T
1
T ¼ ff1g; /g
Minimum weight in the row
of 1 is 2 corresponding to the
column of vertex 2. We include
vertex 2 and edge (1, 2) to T.
2
T ¼ ff1; 2g; fð1; 2Þgg
Minimum weight in the rows
of 1 and 2 is 4 (next to 2) in
the row of 1, corresponding
to the column of vertex 3.
We include vertex 3 and edge (1, 3) to T.
(continued)
5.2
Minimum Spanning Tree Problem
75

(continued)
Sl.
no.
Tree T
Corresponding tree T
3
T ¼
1; 2; 3
f
g;
1; 2
ð
Þ; 1; 3
ð
Þ
f
g
f
g
Minimum weight in the rows of
1, 2, and 3 is 1 in the row of 3,
corresponding to the column of vertex 6.
We include vertex 6 and edge (3, 6) to T.
4
T ¼
1; 2; 3; 6
f
g;
1; 2
ð
Þ; 1; 3
ð
Þ; 3; 6
ð
Þ
f
g
f
g
Minimum weight in the rows of 1, 2,3, and 6
is 8 in the row of 3, corresponding
to the column of vertex 4. Since, the
other vertices corresponding to the
minimum than 8 are already
present in T.
We include vertex 4 and
edge (3,4) to T.
(continued)
76
5
Algorithms on Graphs

Total Weight ¼ 2 þ 4 þ 1 þ 8 þ 6 ¼ 21 units which is minimum weight of the
Spanning Tree appears in Sl. No. 6.
(continued)
Sl.
no.
Tree T
Corresponding tree T
5
T ¼
1; 2; 3; 6; 4
f
g;
1; 2
ð
Þ;
f
f
1; 3
ð
Þ; 3; 6
ð
Þ; 3; 4
ð
Þgg
Minimum weight in the rows
of 1, 2, 3, 6, and 4 is 6 in the
row of 4, corresponding
to the column of vertex 5.
Since, the other
vertices corresponding
to the minimum
than 6 are already present in T.
We include vertex 5 and
edge (4, 5) to T.
6
T ¼
1; 2; 3; 6; 4; 5
f
g;
f
1; 2
ð
Þ; 1; 3
ð
Þ; 3; 6
ð
Þ;
f
3; 4
ð
Þ; 4; 5
ð
Þgg
5.2
Minimum Spanning Tree Problem
77

5.3 Breadth First Search Algorithm to Find the Shortest Path
Let G be an unweighted graph. We can ﬁnd the shortest path from vk tovp.
Input: Connected graph G = (V, E) in which one vertex is denoted by vk and
one by vp and each edge (i, j) has length lij ¼ 1: Initially, all vertices are unlabeled.
Output: A shortest path vk ! vp in G = (V, E).
Step 1: Label the starting vertex vk with 0.
Step 2: Set i = 0.
Step 3: Find all unlabeled vertices in G which are adjacent to the vertices
labeled i. If there are no such vertices then 9 no path from vk to vp. Otherwise go to
step 4.
Step 4: Label the vertices just found with i ? 1.
Step 5: If vertex vp is labeled. Stop. The value of the label of vp is the shortest
distance from vk to vp. Otherwise go to step 3.
Now, we use the following backtracking process to ﬁnd the shortest path from
vp to vk: Let the destination vertex vp is labeled r ? 1. Then ﬁnd a vertex adjacent
to vp whose label is r. Continue this process until the initial vertex vk is reached. h
Example 5.10 Find by BFS method the shortest path from the vertex v2 to v6 in the
following graph (Fig 5.12).
Fig. 5.12
Solution:
According to BFS Algorithm, the shortest path is v2  v1  v7  v6. So, the
shortest distance from v2 to v6 is 3.
Figure 5.13 shows the Breadth ﬁrst tree which is also a spanning tree.
v2v1v3v7v8v4v6v5 is called Breadth ﬁrst traversal.
78
5
Algorithms on Graphs

5.3.1 BFS Algorithm for Construction of a Spanning Tree
Discard all the parallels and loops from the given graph.
Choose any vertex vk of the graph. In this algorithm, label this vertex as 0. Then
we proceed stage by stage by labeling a new vertex at every stage according to the
following rule:
Find all unlabeled vertex in G which is adjacent to the vertices labeled i. Label
those vertices as i ? 1 and get them joined (with i labeled vertex) by edges so that
no circuit is formed. This stage to stage labeling and joining stops when all vertices
are labeled. All the vertices and the successive joining edges form the required
spanning tree.
h
Example 5.11 Find by BFS algorithm a spanning tree in the following graph
(Fig 5.14).
Fig. 5.14
Solution:
After discarding the self-loop and the parallel edges, the resultant graph is shown
in Fig. 5.15.
Fig. 5.13
Breadth ﬁrst tree
5.3
Breadth First Search Algorithm to Find the Shortest Path
79

Fig. 5.15
Using BFS Algorithm, a breadth First Tree (Spanning Tree) has been obtained
as shown in Fig. 5.16.
Fig. 5.16
5.4 Depth First Search Algorithm for Construction
of a Spanning Tree
Discard all parallels and loops from the given graph.
Choose any vertex vk of the resultant graph. Make a path starting from vk as
long as possible by successively adding edges and vertices. Let this path be
P1 : vk ! vp:
80
5
Algorithms on Graphs

Now backtrack (along P1) from vp and Let va be the ﬁrst vertex starting from
which we can make a path (as long as possible) as P2 containing no vertices of P1
so that it does not form a circuit.
Let vb be the next vertex reached along this tracking from which we can make
another path (as long as possible) say P3 containing no vertices of P1 and P2.
Continuing this process, we get paths P4; P5; . . . and so on: We stop at that stage
when each of the vertices of the graph is included in some of the paths
P1; P2; P3; . . .. These paths together form the required spanning tree.
h
Example 5.12 Find by DFS algorithm a spanning tree in the following graph
(Fig 5.17).
Fig. 5.17
Solution:
After discarding all loops and parallels, we have the following graph in Fig. 5.18.
Fig. 5.18
Choose arbitrarily the vertex G. Make a path starting from G as long as possible
by
successively
adding
edges
and
vertices.
This
path
be
P1 : G  C
F  E  H  I. Now backtrack from I to H. We get no path starting from H. Next
we backtrack from H to E, we get a path P2 : E  D, noting that P2 does not make
any circuit with the path P1 (Fig. 5.19).
5.4
Depth First Search Algorithm for Construction of a Spanning Tree
81

Again, from E we re-track to F and then to C. There exists a path from C, say,
P3 : C  B  A so that all of its vertices are not included in the previous two paths.
Since the three paths P1; P2 and P3 contain all the vertices of the graph, we can
stop at this stage.
Example 5.13 Find by DFS the spanning tree of the following graph (Fig. 5.20).
Fig. 5.20
Solution:
In Fig. 5.21, all the vertices are included in the path P: 1  2  3  6  10  9 
8  7  5  4 which is the required spanning tree obtained by DFS.
Fig. 5.19 Spanning tree obtained by DFS
82
5
Algorithms on Graphs

Example 5.14 Find the fundamental circuits of the following graph
Fig. 5.22
Solution:
After discarding the parallel edge of Fig. 5.22, we obtain the following graph in
Fig. 5.23.
Fig. 5.23
Fig. 5.21 Spanning tree obtained by DFS
5.4
Depth First Search Algorithm for Construction of a Spanning Tree
83

Figure 5.24 shows the spanning tree obtained by DFS.
From the simple graph Fig. 5.23, we see that there are e  n þ 1 ¼ 11  7 þ
1 ¼ 5 fundamental circuits with regard to the chords v2  v4, v3  v5, v2  v7,
v4  v7 and v7  v5 which are shown in Fig. 5.24 by dotted lines.
Fundamental circuit
Corresponding chord
1
v2  v3  v4  v2
v2  v4
2
v3  v4  v5  v3
v3  v5
3
v2  v3  v4  v5  v6  v7  v2
v2  v7
4
v4  v5  v6  v7  v4
v4  v7
5
v7  v6  v5  v7
v7  v5
Example 5.15 Find the fundamental circuits of the following graph.
Fig. 5.25
Solution:
After discarding the parallel edge of Fig. 5.25, we obtain the following graph in
Fig. 5.26.
Fig. 5.24 Fundamental
circuits represented by ﬁve
dotted chord lines
84
5
Algorithms on Graphs

Fig. 5.26
Figure 5.27 shows the Spanning tree obtained by DFS viz. the path P:
A  B  D  G  E  F  C.
From the simple graph Fig. 5.26, we see that there are e  n þ 1 ¼ 12  7 þ
1 ¼ 6 fundamental circuits with regard to the chords AC; BC; BF; BE; DE; and
GF.
Note: Let T be a spanning tree in a connected graph G. Adding any one chord to
T will create exactly one circuit. Such a circuit, formed by adding a chord to a
spanning tree, is called a fundamental circuit.
Exercises:
1. Apply Dijkstra’s Algorithm, to ﬁnd the shortest route from node 3 to 4 of the
following network in Fig. 5.28.
Fig. 5.27 Spanning tree obtained by DFS
5.4
Depth First Search Algorithm for Construction of a Spanning Tree
85

Fig. 5.28
2. Use Dijkstra’s Algorithm, to determine the shortest route between the fol-
lowing cities: (Fig. 5.29)
Fig. 5.29
(a) Cities 1 and 8.
(b) Cities 4 and 8.
(c) Cities 2 and 6.
3. Apply Dijkstra’s Algorithm, to ﬁnd the shortest route between node 1 and
each of the remaining nodes (Fig. 5.30).
Fig. 5.30
86
5
Algorithms on Graphs

4. Apply Breadth First Search (BFS) Algorithm, to ﬁnd a Spanning tree of the
following graph and hence ﬁnd all Fundamental Circuits for the following
graph in Fig. 5.31.
Fig. 5.31
5. Apply Depth First Search (DFS) Algorithm, to ﬁnd a Spanning tree of the
following graph and hence ﬁnd all Fundamental Cut sets for the graph in
Fig. 5.31.
6. By BFS Algorithm, ﬁnd a shortest path from vertex A to Z in the following
two graphs (Fig. 5.32).
Fig. 5.32
7. Find by Kruskal’s Algorithm a minimal spanning tree from the following
graph G (Fig. 5.33).
5.4
Depth First Search Algorithm for Construction of a Spanning Tree
87

Fig. 5.33
8. Use DFS Algorithm to ﬁnd a spanning tree of the following graph (Fig. 5.34).
Fig. 5.34
9. Table 5.23 shows the distances, in kilometers, between six villages in India.
Find a minimal spanning tree connecting the six villages using Prim’s
Algorithm.
Table 5.23
A
B
C
D
E
F
A
–
5
6
12
4
7
B
5
–
11
3
2
5
C
6
11
–
8
6
6
D
12
3
8
–
7
9
E
4
2
6
7
–
8
F
7
5
6
9
8
–
88
5
Algorithms on Graphs

10. By Prim’s Algorithm, ﬁnd a minimal spanning tree in the following graphs
and ﬁnd the corresponding minimum weight. (Fig. 5.35).
Fig. 5.35
11. Find the shortest distance matrix and the corresponding shortest path matrix
for all the pairs of vertices in the directed weighted graph given in Fig. 5.36,
using Floyd-Warshall’s algorithm.
Fig. 5.36
5.4
Depth First Search Algorithm for Construction of a Spanning Tree
89

12. Use Prim’s Algorithm to ﬁnd a minimum spanning tree for the weighted graph
given in Fig. 5.37.
Fig. 5.37
13. Find the minimum spanning tree for the weighted graph shown in Fig. 5.38,
by using Kruskal’s algorithm.
Fig. 5.38
14. Use Kruskal’s algorithm, to ﬁnd a minimum spanning tree for the weighted
graph as shown in Fig. 5.39.
90
5
Algorithms on Graphs

Fig. 5.39
15. Consider the network given below, to ﬁnd the minimum spanning tree using
Prim’s Algorithm (Fig. 5.40).
Fig. 5.40
16. Consider the following network and ﬁnd the minimum spanning tree using
(a) The Prim’s Algorithm
(b) The Kruskal’s Algorithm (Fig. 5.41)
5.4
Depth First Search Algorithm for Construction of a Spanning Tree
91

Fig. 5.41
17. Find the minimum spanning tree of the following network using Kruskal’s
Algorithm (Fig. 5.42).
Fig. 5.42
18. Prove that if G is a connected weighted graph in which no two edges have the
same weight then G has a unique minimum spanning tree.
19. Using Floyd-Warshall’s Algorithm determine the shortest route between all
pair of vertices of the following graph (Fig. 5.43).
Fig. 5.43
92
5
Algorithms on Graphs

20. Using Floyd-Warshall’s Algorithm determine the shortest route between all
pair of vertices of the following graph (Fig. 5.44).
Fig. 5.44
21. By using Kruskal’s Algorithm, ﬁnd a Minimal Spanning Tree in the following
graph and ﬁnd the corresponding minimum weight (Fig. 5.45).
Fig. 5.45
5.4
Depth First Search Algorithm for Construction of a Spanning Tree
93

Chapter 6
Matrix Representation on Graphs
6.1 Vector Space Associated with a Graph
Let us consider a graph G in Fig. 6.1 with four vertices and ﬁve edges
e1; e2; e3; e4; e5: Any subgraph H of G can be represented by a 5-tuple.
X ¼ x1; x2; x3; x4; x5
ð
Þ
such that
xi ¼ 1; if ei is in H
and xi ¼ 0; if ei is not in H
For instance, the subgraph H1 in Fig. 6.1 will be represented by 1; 0; 1; 0; 1
ð
Þ:
There are 25 ¼ 32 such 5-tuples possible, including the zero vector 0 ¼
0; 0; 0; 0; 0
ð
Þ which represents a null graph and 1; 1; 1; 1; 1
ð
Þ which is G itself.
The ring-sum operation between two subgraphs corresponds to the modulo 2
addition between the two 5-tuples representing the two subgraphs.
For example, consider two subgraphs
H1 ¼ e1; e3; e5
f
g represented by 1; 0; 1; 0; 1
ð
Þ
and H2 ¼ e2; e3; e4
f
g represented by 0; 1; 1; 1; 0
ð
Þ
Fig. 6.1 Graph G and its two subgraphs H1 and H2
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_6,  Springer India 2013
95

The ring sum
H1  H2 ¼ e1; e2; e4; e5
f
g represented by ð1; 1; 0; 1; 1Þ
which is clearly modulo 2 addition of the 5-tuples for H1 and H2.
There is a vector space WG associated with every graph G and this vector space
consists of
1. Galois ﬁeld modulo 2 ðGFð2ÞÞ, i.e., the set
0; 1
f
g with operation addition
modulo 2 and multiplication modulo 2.
2. 2e vectors (e-tuples), where e is the number of edges of G.
3. An
addition
operation
between
two
vectors
X ¼ x1; x2; . . .; xe
ð
Þ; Y ¼
ðy1; y2; . . .; yeÞ in this space, deﬁned by the vector sum
X  Y ¼ ðx1 þ y1; x2 þ y2; . . .; xe þ yeÞ
where ? is the addition modulo 2:
4. And a scalar multiplication between a scalar c in GF(2) and a vector X ¼
x1; x2; . . .; xe
ð
Þ in this space, deﬁned as
c:X ¼ ðc:x1; c:x2; . . .; c:xeÞ:
where  is the multiplication modulo 2:
Basis vectors of a graph:
Let WG be the vector space associated with a graph G. Corresponding to each
subgraph of G, there exists a vector in WG; represented by an e-tuple. The standard
basis for this vector space WG is a set of e linearly independent vectors, each
representing a subgraph consisting of one edge of G. For instance, for the graph in
Fig. 6.1, the set of the following ﬁve vectors forms a basis for WG.
1; 0; 0; 0; 0
ð
Þ; 0; 1; 0; 0; 0
ð
Þ; 0; 0; 1; 0; 0
ð
Þ; 0; 0; 0; 1; 0
ð
Þ; 0; 0; 0; 0; 1
ð
Þ
f
g
Any of the possible 32 subgraphs, including G itself as well as the null graph,
can be represented by a suitable linear combination of these ﬁve basis vectors.
6.2 Matrix Representation of Graphs
6.2.1 Incidence Matrix
Let G be a graph with n vertices, e edges, and no self-loops. We deﬁne a matrix
A ¼ aij


ne where n rows correspond to the n vertices and the e columns cor-
respond to the e edges, as follows:
96
6
Matrix Representation on Graphs

aij ¼ 1; if jth edge ej is incident on ith vertex vi
¼ 0; otherwise
This matrix A is called incidence matrix of G. Sometimes it is written as AðGÞ:
Example 6.1 Find the incidence matrix of the following graph
Fig. 6.2
Solution:
The incidence matrix A G
ð Þ of the graph G in Fig. 6.2 is as follows:
e1 e2 e3 e4
e5 e6 e7 e8
A G
ð Þ ¼
v1
v2
v3
v4
v5
v6
v7
1
0
0
1
1
0
0
1
1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
0
1
1
0
0
0
1
1
2
666666664
3
777777775
Example 6.2 Determine the graph where incidence matrix is
e1
e2 e3 e4 e5 e6
v1
v2
v3
v4
v5
0
1
0
1
0
1
1
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
0
1
1
1
0
1
0
0
2
66664
3
77775
Solution:
Let the given incidence matrix AðGÞ be
6.2
Matrix Representation of Graphs
97

e1 e2 e3 e4 e5 e6
A G
ð Þ ¼
v1
v2
v3
v4
v5
0
1
0
1
0
1
1
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
0
1
1
1
0
1
0
0
2
66664
3
77775
The desired graph G is shown in Fig. 6.3.
Fig. 6.3
Properties of Incidence matrix:
1. Each column of A has exactly two 1’s, since every edge is incident on exactly
two vertices.
2. The number of 1’s in each row equals the degree of the corresponding vertex.
3. A row with all 0’s represents an isolated vertex.
4. Parallel edges in a graph produce identical columns in its incidence matrix.
5. If a graph G is disconnected and consists of two components G1 and G2; the
incidence matrix AðGÞ of graph G can be written in a block diagonal form as
A G
ð Þ ¼
AðG1Þ
0
0
AðG2Þ


where AðG1Þ and AðG2Þ are the incidence matrices of components G1 and G2:
6. Permutation of any two rows or columns in an incidence matrix simply cor-
responds to relabeling the vertices and edges of the same graph.
98
6
Matrix Representation on Graphs

Incidence Matrix of a connected Digraph:
Let G be a Digraph with n vertices, e edges. Suppose that G contains no self-
loops. We deﬁne a matrix A ¼ ðaijÞn  e whose rows correspond to the vertices
and columns corresponds to the edges, as follows:
aij ¼1; if jth edge is incident out of ith vertex
¼  1; if jth edge is incident into ith vertex
¼ 0; if jth edge is neither incident out nor incident into ith vertex
Example 6.3 Find the incidence matrix of the following digraph in Fig. 6.4
Fig. 6.4
Solution:
The incidence matrix of the given graph G in Fig. 6.4 is as follows:
e1
e2
e3
e4
e5
e6
e7
e8
A G
ð Þ ¼
v1
v2
v3
v4
1
0
0
1
1
0
0
1
1
0
0
1
1
1
0
0
1
0
0
1
0
0
0
1
0
1
0
1
0
1
1
1
2
6664
3
7775
Theorem 6.1 If AðGÞ is an incidence matrix of a connected graph G with n
vertices, the rank of AðGÞ is n  1.
Proof Let G be a graph and let AðGÞ be its incidence matrix. Now each row in
AðGÞ is a vector over GFð2Þ in the vector space of graph G. Let the row vectors be
denoted by A1; A2; . . .; An: Then,
A G
ð Þ ¼
A1
A2
..
.
An
2
6664
3
7775
6.2
Matrix Representation of Graphs
99

Since there are exactly two 1’s in every column of A, the sum of all these
vectors is 0 (this being a modulo 2 sum of the corresponding entries). Thus vectors
A1; A2; . . .; An are linearly dependent. Therefore, rank A\n:
Hence; rank AðGÞ  n  1
ð6:1Þ
Now, consider the sum of any m of these row vectors, m  n  1. Since G is
connected, AðGÞ cannot be partitioned in the form
A G
ð Þ ¼
AðG1Þ
0
0
AðG2Þ


such that AðG1Þ has m rows and AðG2Þ has n-m rows.
Thus, there exists no m  m submatrix of A(G) for m  n  1; such that the
modulo 2 sum of these m rows is equal to zero.
As there are only two elements 0 and 1 in this ﬁeld, the additions of all vectors
taken m at a time for m ¼ 1; 2; . . .; n  1 exhausts all possible linear combina-
tions of n  1 row vectors.
Thus no linear combinations of m row vectors of A, for m  n  1; is zero.
Therefore; rank AðGÞ  n  1
ð6:2Þ
Combining Eqs. (6.1) and (6.2), it follows that rank A G
ð Þ ¼ n  1:
h
Remark If G is a disconnected graph with k components, then it follows from the
above theorem that rank of AðGÞ is n  k:
Reduced incidence matrix: Let G be a connected graph with n vertices and
m edges. Then the order of the incidence matrix AðGÞ is n  m: Now, if we remove
any one row from AðGÞ; the remaining ðn  1Þ by m submatrix is of rank ðn  1Þ:
Thus, the remaining ðn  1Þ row vectors are linearly independent. This shows that
only ðn  1Þ rows of an incidence matrix are required to specify the corresponding
graph completely, because ðn  1Þ rows contain the same information as the entire
matrix. This follows from the fact that given ðn  1Þ rows, we can construct the
nth row, as each column in the matrix has exactly two 1’s. Such an ðn  1Þ  m
matrix of A is called a reduced incidence matrix and is denoted by Af : The vertex
corresponding to the deleted row in Af is called the reference vertex. Obviously,
any vertex of a connected graph can be treated as the reference vertex.
The following result gives the nature of the incidence matrix of a tree.
Theorem 6.2 The reduced incidence matrix of a tree is nonsingular.
Proof A tree with n vertices has n  1 edges and also a tree is connected.
Therefore, the reduced incidence matrix is a square matrix of order n  1; with
rank n  1: Thus the result follows.
Now a graph G with n vertices and n  1 edges which is not a tree is obviously
disconnected. Therefore, the rank of the incidence matrix of G is less than n  1:
Hence, the ðn  1Þ  ðn  1Þ reduced incidence matrix of a graph is nonsingular if
and only if the graph is a tree.
h
100
6
Matrix Representation on Graphs

Theorem 6.3 Let AðGÞ be an incidence matrix of a connected graph G with n
vertices. An ðn  1Þ  ðn  1Þ submatrix of AðGÞ is nonsingular iff the ðn  1Þ
edges corresponding to the ðn  1Þ columns of this matrix constitute a spanning
tree in G.
Proof Every square submatrix of order n  1 in AðGÞ is the reduced incidence
matrix of the some subgraph in G with n  1 edges and vice versa. A square
submatrix of AðGÞ is nonsingular iff the corresponding subgraph is a tree. The tree
in this case is a spanning tree, since it contains n  1 edges of the n vertex graph.
Hence, ðn  1Þ  ðn  1Þ submatrix of AðGÞ is nonsingular iff the ðn  1Þ
edges corresponding to the ðn  1Þ columns of this matrix forms a spanning tree.
h
Permutation Matrix:
A permutation matrix is a square binary matrix that has exactly one ‘1’ in each
row and column.
Theorem 6.4 Two graphs G1 and G2 are isomorphic iff their adjacency matrices
XðG1Þ and XðG2Þ differs only by permutations of rows and columns.
Proof Suppose XðG1Þ and XðG2Þ are the adjacency matrices of two isomorphic
graphs. Then, one of these matrices can be obtained from the other by rearranging
rows and then rearranging the corresponding columns. Now rearranging rows of
XðG1Þ is equivalent to premultiplying by a permutation matrix P yielding the
product matrix PXðG1Þ The subsequent rearrangement of corresponding columns
is equivalent to postmultiplying PXðG1Þ by P1 (since P is nonsingular matrix).
Thus XðG2Þ ¼ PXðG1ÞP1:
Conversely, if XðG2ÞP ¼ PXðG1Þ; XðG2Þ can be obtained from XðG1Þ by
rearranging columns and then rows, yielding that two graphs are isomorphic.
6.2.2 Adjacency Matrix
The adjacency matrix of a graph G with n vertices and no parallel edge is an n by
n symmetric binary matrix X ¼ ðxijÞnn deﬁned over the ring of integers such that
xij ¼ 1; if there is an edge between ith and jth vertices
¼ 0; if there is no edge between them
To illustrate, consider the graph G as shown in Fig. 6.10.
The adjacency matrix XðGÞ of G is given by
6.2
Matrix Representation of Graphs
101

v1
v2 v3
v4 v5
v6
X G
ð Þ ¼
v1
v2
v3
v4
v5
v6
0
1
0
1
0
0
0
0
0
0
1
1
1
1
0
1
0
0
0
1
1
1
1
0
1
0
0
0
1
1
1
0
0
1
0
0
2
6666666664
3
7777777775
If a graph G is disconnected and has two components g1 and g2 iff its adjacency
matrix XðGÞ can be partitioned as
X G
ð Þ ¼
Xðg1Þ
0
0
Xðg2Þ


where Xðg1Þ is the adjacency matrix of the component g1 and Xðg2Þ is the adja-
cency matrix of the component g2:
Theorem 6.5 Let X be the adjacency matrix of a simple graph G. Then the ijth
entry of Xk is the number of different vi  vj walks in G of length k.
Proof We shall prove the result by using induction on k. The result is true for
k ¼ 0 and 1: For k ¼ 2; the off diagonal entry in X2; i.e., ijth entry in
X2ði 6¼ jÞ = number of different vi  vj walks of length two.
Thus the result is true for k ¼ 2:
For k ¼ 3; the off diagonal entry in X3; i.e., ijth entry in X3 = number of
different vi  vj walks of length three.
The theorem holds for k ¼ 1; 2; 3:
It can be proved for any positive integer r.
Assume that, it holds for k ¼ r; then evaluate the ijth entry in Xrþ1 with the help
of the relation
Xrþ1 ¼ Xr: X
We have, Xrþ1
½
ij¼ Xr:X
½
ij¼ P
n
l¼1
Xr
½
il X
½ lj¼ P
n
l¼1
Xr
½
ilxlj. Now, every vi  vj walk
of length r þ 1 consists of a vi  vl walk of length r, followed by an edge vlvj.
Since, there are ½Xril such walks of length r and xlj such edges for each vertex vl;
the total number of all vi  vj walks of length r þ 1 is P
n
l¼1
Xr
½
ilxlj. This completes
the proof for r þ 1 also.
h
Theorem 6.6 Let G be a graph with n vertices v1; v2; . . .; vn and let X be the
adjacency matrix of G. Let Y ¼ ðyijÞnn be the matrix such that
102
6
Matrix Representation on Graphs

Y ¼ X þ X2 þ . . . þ Xn1 in the ring of integers
ð
Þ
Then G is a connected graph iff for every entry ði; jÞ; we have yij 6¼ 0 , i.e., iff Y has
no zero entries off the main diagonal.
Proof Let xðkÞ
ij
denote the ði; jÞth entry of Xk; for each k ¼ 1; 2; . . .; n  1:
Then yij ¼ xð1Þ
ij þ xð2Þ
ij þ . . . þ xðn1Þ
ij
Now we know that, xðkÞ
ij denotes the number of distinct walks of length k from vi
to vj and so
yij ¼ðnumber of different vi  vj walks of length 1)
+ (number of different vi  vj walks of length 2)+ ...
+ (number of different vi  vj walks of lengthðn  1ÞÞ:
i.e., yij is the number of different vi  vj walks of length less than n.
Now suppose that G is connected then for every pair of vertices there is a path
from vi to vj. Since G has only n vertices, this path goes through at most n vertices
and so it has length less than n, i.e., there is at least 1 path from vi to vj of length
less than n. Hence, yij 6¼ 0 for each i; j with i 6¼ j; as required.
Conversely, suppose that for each distinct pair i, j we have yij 6¼ 0: Then, from
above there is at least one walk (of length less than n) from vi to vj. In particular, vi
is connected to vj; since every u  v walk contains a u  v path. Thus, G is a
connected graph, as required.
Example 6.4 Check whether the graph G having the following adjacency matrix
X is connected or not.
XðGÞ ¼
0
1
1
1
1
1
1
0
1
0
0
0
1
1
0
1
0
0
1
0
1
0
1
0
1
0
0
1
0
1
1
0
0
0
1
0
2
6666664
3
7777775
Solution:
To check whether the given graph G is connected or not.
We need to ﬁnd
Y ¼ X þ X2 þ X3 þ X4 þ X5
6.2
Matrix Representation of Graphs
103

Here, X ¼
0
1
1
1
1
1
1
0
1
0
0
0
1
1
0
1
0
0
1
0
1
0
1
0
1
0
0
1
0
1
1
0
0
0
1
0
2
6666664
3
7777775
; X2 ¼
5
1
2
2
2
1
1
2
1
2
1
1
2
1
3
1
2
1
2
2
1
3
1
2
2
1
2
1
3
1
1
1
1
2
1
2
2
6666664
3
7777775
Since, X2 has all off diagonal entries nonzero.
Therefore, Y should also have all off diagonal entries nonzero.
Hence, the given graph G is connected.
Example 6.5 Show that the graph G having the following adjacency matrix X is
connected.
X ¼
0
0
1
0
0
0
0
0
1
0
1
0
0
0
1
0
1
0
0
1
0
0
1
1
0
2
66664
3
77775
Solution:
Here; Y ¼ X þ X2 þ X3 þ X4
¼
3
1
3
1
4
1
3
1
3
4
3
1
7
5
4
1
3
5
7
4
4
4
4
4
8
2
6666664
3
7777775
Since, all off diagonal entries of Y are nonzero.
Hence, G is connected.
Veriﬁcation:
The graph associated with matrix X is connected which is shown in Fig. 6.5.
Fig. 6.5 A connected graph
104
6
Matrix Representation on Graphs

Example 6.6 Check whether the graph G having the following adjacency matrix is
connected or not.
X ¼
0
1
0
0
0
1
0
0
0
1
0
0
0
1
0
0
0
1
0
0
0
1
0
0
0
2
66664
3
77775
Solution:
Here,
X ¼
0
1
0
0
0
1
0
0
0
1
0
0
0
1
0
0
0
1
0
0
0
1
0
0
0
2
6666664
3
7777775
;
X2 ¼
1
0
0
0
1
0
2
0
0
0
0
0
1
0
0
0
0
0
1
0
1
0
0
0
1
2
6666664
3
7777775
X3 ¼
0
2
0
0
0
2
0
0
0
2
0
0
0
1
0
0
0
1
0
0
0
2
0
0
0
2
6666664
3
7777775
;
X4 ¼
2
0
0
0
2
0
4
0
0
0
0
0
1
0
0
0
0
0
1
0
2
0
0
0
2
2
6666664
3
7777775
Now, Y ¼ X þ X2 þ X3 þ X4
Therefore, we have,
Y ¼
3
3
0
0
3
3
6
0
0
3
0
0
2
2
0
0
0
2
2
0
3
3
0
0
3
2
66664
3
77775
Since, in Y, there exists at least one off diagonal zero entry.
Hence, the given graph G is not connected.
One component of G consists of v1; v2; v5 and other component consists of v3; v4:
6.2.3 Circuit Matrix/Cycle Matrix
Let the number of different circuits in a graph G be k and the number of edges in
G be e. Then a circuit matrix B ¼ bij


ke is a binary matrix deﬁned as follows:
bij ¼1; if ith circuit includes jth edge
¼0; otherwise
6.2
Matrix Representation of Graphs
105

It is usually denoted by BðGÞ:
Illustration: Consider the graph G1 given in Fig. 6.6
Fig. 6.6 Two graphs G1 and G2
The
graph
G1
has
four
different
circuits
C1 ¼ fe1; e2g; C2 ¼
fe3; e5; e7g; C3 ¼ fe4; e6; e7g and C4 ¼ fe3; e4; e6; e5g:
The circuit matrix is
e1
e2
e3
e4
e5
e6
e7
e8
B G1
ð
Þ ¼
C1
C2
C3
C4
1
1
0
0
0
0
0
0
0
0
1
0
1
0
1
0
0
0
0
1
0
1
1
0
0
0
1
1
1
1
0
0
2
6664
3
7775
The graph G2 of Fig. 6.6 has seven different circuits, namely,
C1 ¼ fe1; e2g;
C2 ¼ fe2; e7; e8g;
C3 ¼ fe1; e7; e8g;
C4 ¼ fe4; e5; e6; e7g;
C5 ¼ fe2; e4; e5; e6; e8g;
C6 ¼ fe1; e4; e5; e6; e8g
and
C7 ¼ fe9g:
The cycle matrix is given by
e1
e2
e3
e4
e5
e6
e7
e8
e9
B G2
ð
Þ ¼
C1
C2
C3
C4
C5
C6
C7
1
1
0
0
0
0
0
0
0
0
1
0
0
0
0
1
1
0
1
0
0
0
0
0
1
1
0
0
0
0
1
1
1
1
0
0
0
1
0
1
1
1
0
1
0
1
0
0
1
1
1
0
1
0
0
0
0
0
0
0
0
0
1
2
666666666664
3
777777777775
106
6
Matrix Representation on Graphs

We have the following observations regarding the circuit matrix BðGÞ of a
graph G,
1. A column of all zeros corresponds to a non-cycle edge, that is, an edge which
does not belong to any cycle.
2. Each row of BðGÞ is a cycle vector.
3. A cycle matrix has the property of representing a self-loop and the corre-
sponding row has a single 1.
4. The number of 1’s in a row is equal to the number of edges in the corresponding
circuit.
5. If the graph G is separable (or disconnected) and consists of two blocks (or
components) H1 and H2; then the circuit matrix BðGÞ can be written in a block-
diagonal form as
BðGÞ ¼
BðH1Þ
0
0
BðH2Þ


;
where BðH1Þ and BðH2Þ are the circuit matrices of H1 and H2: This follows from
the fact that circuit in H1 have no edges belonging to H2 and vice versa.
6. Permutation of any two rows or columns in a circuit matrix corresponds to
relabeling the circuits and the edges.
7. Two graphs G1 and G2 are 2-isomorphic if and only if they have circuit cor-
respondence. Thus two graphs G1 and G2 have the same circuit matrix if and
only if G1 and G2 are 2-isomorphic.
For example, the two graphs given in Fig. 6.7 have the same circuit matrix.
They are 2-isomorphic, but are not isomorphic.
Fig. 6.7 2-isomorphic graphs
The following result relates the incidence and circuit matrix of a graph without
self-loops.
Theorem 6.7 If G is a graph without self-loops, with incidence matrix A and
circuit matrix B whose columns are arranged using the same order of edges, then
every row of B is orthogonal to every row of A, that is ABT ¼ BAT 	 0 ðmod 2Þ;
where AT and BT are the transposes of A and B, respectively.
Proof Let G be a graph without self-loops and let A and B respectively, be the
incidence and circuit matrix of G.
6.2
Matrix Representation of Graphs
107

We know that in G for any vertex vi and for any cycle Cj, either vi 2 Cj or
vi 62 Cj. In case vi 62 Cj, then there is no edge of Cj which is incident on vi and if
vi 2 Cj, then there are exactly two edges of Cj which are incident on vi:
Now, consider the ith row of A and the jth row of B (which is the jth column of
BT). Since the edges are arranged in the same order, the rth entries in these two
rows are both nonzero if and only if the edge er is incident on the ith vertex vi and
is also in the jth cycle Cj:
We have ½ABTij ¼ P½Air½BTrj ¼ P½Air½Bjr ¼ P airbjr
For each er of G, we have one of the following cases.
i. er is incident on vi and er 62 Cj: Here air ¼ 1; bjr ¼ 0:
ii. er is not incident on vi and er 2 Cj: In this case, air ¼ 0; bjr ¼ 1:
iii. er is not incident on vi and er 62 Cj, so that air ¼ 0; bjr ¼ 0.
All these cases imply that the ith vertex vi is not in the jth cycle Cj and we have
ABT
½
ij ¼ 0 	 0 ðmod 2Þ:
iv. er is incident on vi and er 2 Cj:
Here we have exactly two edges, say er and et incident on vi so that air ¼
1; ait ¼ 1; bjr ¼ 1; bjt ¼ 1: Therefore, ABT
½
ij ¼ P airbjr ¼ 1 þ 1 	 0 ðmod 2Þ:
h
We illustrate the above theorem with the following example in Fig. 6.8
Fig. 6.8
108
6
Matrix Representation on Graphs

Clearly,
ABT ¼
0
0
0
1
0
1
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
0
1
1
1
1
0
1
0
0
0
0
0
1
1
0
0
1
0
1
1
0
0
0
0
0
0
2
666666664
3
777777775
1
0
0
0
1
0
0
0
0
1
0
1
0
0
1
1
0
1
0
1
0
0
1
1
0
1
1
0
0
0
0
0
2
66666666666664
3
77777777777775
¼
0
0
2
2
0
2
2
2
0
0
0
0
2
2
0
2
0
2
2
2
2
0
0
0
2
666666664
3
777777775
	 0 ðmod 2Þ
Again,
BAT ¼
1
1
0
0
0
0
0
0
0
0
1
0
1
0
1
0
0
0
0
1
0
1
1
0
0
0
1
1
1
1
0
0
2
6664
3
7775
0
0
0
1
0
1
0
0
0
1
0
1
0
0
0
1
1
0
1
0
0
0
1
0
0
1
0
1
0
0
1
1
0
0
0
0
0
1
0
0
1
0
0
1
1
0
0
0
2
66666666666664
3
77777777777775
¼
0
0
0
2
0
2
0
2
0
2
2
0
2
2
0
0
2
0
2
2
0
2
2
0
2
6664
3
7775 	 0 ðmod 2Þ
6.2.3.1 Fundamental Circuit Matrix
A submatrix (of a circuit matrix) in which all rows correspond to a set of funda-
mental circuits is called a fundamental circuit matrix Bf :
6.2
Matrix Representation of Graphs
109

The graph G of Fig. 6.9 has three different fundamental circuits with regard to
the chord e2; e3 and e6 viz. C1 ¼
e1; e2; e4; e7
f
g; C2 ¼
e3; e4; e7
f
g and C3 ¼
e5; e6; e7
f
g
Fig. 6.9
The fundamental circuit matrix Bf of Fig. 6.9 is as follows
e2
e3
e6
e1
e4
e5
e7
Bf ¼
C1
C2
C3
1
0
0
0
1
0
0
0
1
j
1
1
0
1
j
0
1
0
1
j
0
0
1
1
2
64
3
75
A matrix Bf thus arranged can be written as
Bf ¼
Il
j
Bt


ð6:3Þ
where Il is an identity matrix of order l ¼ e  n þ 1 and Bt is the remaining
l  ðn  1Þ submatrix, corresponding to the branches of the spanning tree.
From Eq. (6.3), we have
Rank of Bf ¼ e  n þ 1:
Since, Bf is a submatrix of the circuit matrix B,
Rank of B  e  n þ 1
ð6:4Þ
Theorem 6.8 If B is a circuit matrix of a connected graph G with e edges and n
vertices
Rank of B ¼ e  n þ 1
110
6
Matrix Representation on Graphs

Proof The set of all circuit vertices in WG forms a subspace WC: This subspace
WC is called the circuit subspace. Every row in circuit matrix B is a circuit vector
in WC:
Rank of matrix B = Number of linearly independent rows in B.
But the number of independent rows in B  number of linearly independent
vectors in WC and consequently, the number of linearly independent vectors in
WC  (dimension of WC)1 = l ¼ e  n þ 1: Since, the set of circuit vectors,
corresponding to the set of fundamental circuits with regard to any spanning tree,
forms a basis for the circuit subspace WC and the number of circuit vectors
(including zero vector 0) in WC is 2l:
Therefore; Rank of B  e  n þ 1:
ð6:5Þ
Again, in Eq. (6.4) we have just shown that
Rank of B  e  n þ 1:
Hence, combining Eqs. (6.4) and (6.5), we have
Rank of B ¼ e  n þ 1:
h
Theorem 6.9 The determinant of every square submatrix of the incidence matrix
A of a digraph is 1, -1 or 0.
Proof Consider a k by k submatrix M of A. If M has any column or row consisting
of all zeros, det M is clearly zero. Also, det M ¼ 0 if every column of M contains
the two non-zero entries 1 and -1. (since, in this case, row sum of M is zero). Now
if det M 6¼ 0 (i.e. M is nonsingular). Then the sum of entries in each column of
M cannot be zero. Therefore, M must have a column in which there is a single non
zero element that is either +1 or -1.
Let this single element be in the ði; jÞ th position in M. Thus
det M ¼ 
 det Mij
where Mij is the submatrix of M with its ith row and jth column deleted. The
ðk  1Þ by ðk  1Þ submatrix Mij is also nonsingular (because M is nonsingular).
Therefore, it must also have at least one column with a single non-zero entry say in
the ðm; nÞth position in Mij. Expanding det Mij about this element in the ðm; nÞth
position, det Mij ¼ 
 (determinant of a nonsingular ðk  2Þ by ðk  2Þ submatrix
of M). Repeated application of this procedure yields
det M ¼ 
 1
Hence, the theorem is proved.
h
1 A vector space is n-dimensional if the maximum number of linearly independent vectors in the
space is n. If a vector space V has a basis b ¼
b1; b2; . . .; bn
f
g; then any set in V containing
more than n vectors must be linearly dependent.
6.2
Matrix Representation of Graphs
111

Exercises:
1. Determine the graph whose incidence matrix is
e1
e2
e3
e4
e5
v1
v2
v3
v4
v5
v6
0
0
1
1
1
0
0
0
0
1
0
0
0
1
0
0
0
1
1
1
0
0
0
0
0
1
0
0
1
0
2
666666664
3
777777775
2. Find the graph whose incidence matrix is
e1 e2
e3 e4
e5
v1
v2
v3
v4
v5
1
1
1
0
0
0
1
0
0
0
1
0
1
0
0
0
0
0
1
1
0
0
0
1
1
2
6666664
3
7777775
3. Determine the incidence matrix of the following graph (Fig. 6.10)
Fig. 6.10
112
6
Matrix Representation on Graphs

4. Using the incidence matrices, ﬁnd whether the two graphs G1 and G2 are
isomorphic or not (Fig. 6.11).
Fig. 6.11 Two graphs G1 and G2
5. Show that, the following two graphs are not isomorphic but they are 2-iso-
morphic (Fig. 6.12).
Fig. 6.12 Two non-isomorphic graphs
6. Show that, the determinant of every square submatrix of the incidence matrix A,
of the following digraph in Fig. 6.13, is either 1, -1 or 0.
Fig. 6.13 A digraph
7. Prove that, a graph is bipartite if and only if for all odd k, every diagonal entry
of Ak is zero.
8. Check whether the graph G having the following adjacency matrix is connected
or not
6.2
Matrix Representation of Graphs
113

XðGÞ ¼
0
1
1
0
0
0
0
0
1
0
1
0
0
0
1
0
1
0
0
1
0
0
1
1
0
2
66664
3
77775
9. Establish the isomorphism of the two graphs given in the following ﬁgures by
considering their adjacency matrices (Fig. 6.14)
Fig. 6.14 Two graphs G1 and G2
114
6
Matrix Representation on Graphs

Chapter 7
Cut Sets and Cut Vertices
In this chapter, we ﬁnd a type of subgraph of a graph G where removal from
G separates some vertices from others in G. This type of subgraph is known as cut
set of G. Cut set has a great application in communication and transportation
networks.
7.1 Cut Sets and Fundamental Cut Sets
7.1.1 Cut Sets
In a connected graph G, the set of edges is said to be a cut set of G if removal of the
set from G leaves G disconnected but no proper subsets of this set does not do so.
In the graph shown in Fig. 7.1, the set of edges fe2; e5; e9; e10g is a cut set of the
graph. In Fig. 7.1, it is represented by a dotted curve. It can be noted that the edge
set fe2; e5; e4g is also a cut set of the graph. fe1g is a cut set containing only one
edge. Removal of the set fe2; e5; e4; e9; e10g disconnects the graph but it is not cut
set because its proper subset fe2; e5; e4g is a cut set.
Fig. 7.1 A cut set
fe2; e5; e9; e10g of the graph
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_7,  Springer India 2013
115

Corollary
(1) Every edge of a tree is a cut set of the tree.
(2) A cut set is a subgraph of G.
7.1.2 Fundamental Cut Set (or Basic Cut Set)
Let T be a spanning tree of a connected graph G. A cut set S of G containing
exactly one branch of T is called a Fundamental cut set of G with regard to T.
In Fig. 7.2, T ¼ fAB; BC; CD; DE; EFg is a spanning tree (shown by bold
lines). The set of edges fBD; BCg is a cut set containing one branch BC of T. So,
fBD; BCg is a Fundamental cut set of G w.r.t T. In the same graph the set
fBD; CD; EFg (as shown by dotted curve in Fig. 7.2) is a cut set but not a Fun-
damental Cut set with regard to T because it contains two edges of T.
7.2 Cut Vertices
A vertex v of a connected graph G is said to be a cut vertex if its deletion from
G (together with the edges incident to it) disconnects the graph.
Fig. 7.2 fBD; CD; EFg is a
cut set but not a fundamental
cut set
116
7
Cut Sets and Cut Vertices

In the graph G shown in Fig. 7.3a removal of the vertex A (together with the
edges incident to it) leaves a disconnected graph shown in Fig. 7.3b. So, A is a cut
vertex, we note that C is also a cut vertex. But F is not a cut vertex of this graph.
Corollary
(1) Every vertex (with degree greater than one) of a tree is cut vertex.
(2) A graph may have no cut vertex at all. For example, the graph in Fig. 7.4 has
no cut vertex. Another examples are K2; K3; K4, etc. They have no cut vertex.
7.2.1 Cut Set with respect to a Pair of Vertices
If a cut set puts two vertices v1 and v2 into two different components. Then, it is
called a cut set with regard to v1 and v2.
In the graph shown in Fig. 7.3a, fACg is a cut set with regard to the vertices
B and E. This is not a cut set with regard to A and B.
Fig. 7.4 A disconnected
graph with two connected
components
Fig. 7.3 a Vertex A is a cut
vertex of the graph, b
Disconnected graph after the
removal of vertex A
7.2
Cut Vertices
117

7.3 Separable Graph and its Block
7.3.1 Separable Graph
A connected graph (or a connected component of a graph) is said to be separable if
it has a cut vertex.
On the other hand, a connected graph (or a connected component of a graph)
which is not separable is called non-separable graph.
The graph in Fig. 7.3a is separable. On the other hand, each of the two con-
nected components of the graph in Fig. 7.4 is non-separable. Again each of the two
components in Fig. 7.3b is nonseparable.
7.3.2 Block
A separable graph consists of two or more non-separable subgraphs. Each of these
non-separable subgraphs is called a Block. The graph in Fig. 7.3a has the fol-
lowing Blocks shown in Fig. 7.5.
It can be noted that each of these blocks has no cut vertex.
But between the following two subgraphs of Fig. 7.3a shown in Fig. 7.6, ﬁrst
one is not a block because it is further separable as A is cut vertex of it.
Fig. 7.5 Three Blocks of the
graph in Fig. 7.3a
Fig. 7.6 The ﬁrst subgraph
of Fig.7.3a is not a Block
whereas the second subgraph
is a Block
118
7
Cut Sets and Cut Vertices

7.4 Edge Connectivity and Vertex Connectivity
7.4.1 Edge Connectivity of a Graph
Let G be a graph (may be disconnected) having k components. The minimum
number of edges whose deletion from G increases the number of components of
G is called edge connectivity of G. It is denoted by kðGÞ.
In Fig. 7.4, a graph having two components is shown. We see that if one edge is
deleted from the graph, the number of its components still remains 2. But if two
particular edges, say e and f are deleted then number of components becomes 3.
So, the edge connectivity of the graph is 2.
Corollary
(1) The number of edges in the smallest cut set of a graph is its edge connectivity.
(2) The edge connectivity of a tree is 1.
7.4.2 Vertex Connectivity of a Graph
Let G be a graph (may be disconnected). The minimum number of vertices
(together with the edges incident to it) whose deletion from G increase the number
of components of G is called vertex connectivity of G. It is denoted by jðGÞ.
k-connected and k-edge connected: A graph G is k-connected if j G
ð Þ ¼ k, and
G is k-edge connected if k G
ð Þ ¼ k
For Example, the vertex connectivity of the graph in Fig. 7.7 is 2.
Corollary
(1) The vertex connectivity of tree is 1.
(2) The vertex connectivity of a connected separable graph is 1.
Theorem 7.1 Every cut set in a connected graph contains at least one branch of
every spanning tree of the graph.
Fig. 7.7 The vertex
connectivity of the graph is 2
7.4
Edge Connectivity and Vertex Connectivity
119

Proof Let, S be a cut set of G. Let T be a spanning tree of G. Suppose that, S does
not contain any branch of T. Then all edges of T are present in G  S. It means that
G  S is connected graph. It implies that S is not a cut set. Hence a cut set must
contain at least one branch of a spanning tree of G.
h
For example, in Fig. 7.8, a; c
f
g is not a cut set, so it should contain one branch
of T to become a cut set.
Theorem 7.2 A vertex v in a connected graph G is a cut vertex if and only if there
exists two vertices a and b distinct from v in G such that every path connecting a
and b passes through v.
Proof If v is a cut vertex of G, G  v is a disconnected graph. Let us select two
vertices a and b in two different components of G  v. Then there exists no path
from a to b in G  v. Since, G is connected graph there exists a path P from a to
b in G. If the path does not contain the vertex v, then removal of v from G will not
disconnect the vertices a and b, which is a contradiction to the fact that a and b lies
in two different components of G  v. Hence every path between a and b passes
through v.
Conversely, if every path from a to b contains the vertex v then removal of
v from G disconnects a and b. Hence, a and b lies in different components of
G which implies that G  v is disconnected graph. Therefore, v is cut vertex of
G.
h
Theorem 7.3 The edge connectivity of a graph B the smallest degree of all
vertices of the graph.
Proof Let vk be the vertex with smallest degree in G. Let dðvkÞ be the degree of vk.
Vertex vk can be separated from G by removing the dðvkÞ edges incident on vertex
vk. Therefore, removal of dðvkÞ edges disconnects the graph. Hence, the edge
connectivity of a graph cannot exceed the smallest degree of all vertices of the
graph.
h
Theorem 7.4 In any graph, the vertex connectivity B the edge connectivity.
Proof Let k denote the edge connectivity of G. Therefore, there exists a cut set
S in G containing k edges.
Then, S partitions the vertices of G into two subsets V1 and V2 such that every
edge in S joins a vertex in V1 to a vertex in V2: By removing at most k vertices
Fig. 7.8 A tree G and its
spanning tree T
120
7
Cut Sets and Cut Vertices

from V1 or V2 on which the edges of S are incident, we will be able to remove
S (together with all other edges incident on these vertices) from G. Thus, removal
of at most k vertices from G will disconnect the graph. Hence, the vertex con-
nectivity is less than or equal to k.
h
Corollary Every cut set in a non-separable graph with more than two vertices
contains at least two edges.
Proof A graph is nonseparable if its vertex connectivity is at least two. In view of
Theorem 7.4, edge connectivity C vertex connectivity. Hence, edge connectivity
of a non-separable graph is at least two which is possible if the graph has at least
two edges.
h
Theorem 7.5 The maximum vertex connectivity of a connected graph with n
vertices and e edges ðe  n  1Þ is the integral part of the number 2e=n, i.e.,
b2e=nc. (The ﬂoor function ﬂoor(x) = bxc is the largest integer not greater than x)
Proof We know that every edge in G contributes two degrees. Thus the sum of
degrees of all the vertices is 2e. Since, this sum 2e is divided among n vertices,
therefore, there must be at least one vertex in G whose degree is less than or equal
to the number 2e=n:
Therefore, using Theorem 7.3, the edge connectivity of G  2e=n.
Consequently, it follows from Theorem 7.4, vertex connectivity B edge con-
nectivity  2e=n.
Hence, maximum vertex connectivity possible is b2e=nc.
h
Theorem 7.6 (Whitney’s Inequality) For any graph G; jðGÞ  kðGÞ  dðGÞ i.e.
vertex connectivity B the edge connectivity B the minimum degree of the graph G
Proof We shall ﬁrst prove kðGÞ  dðGÞ.
If G has no edges, then k ¼ 0 and d ¼ 0. If G has edges, then we get a
disconnected graph, when all edges incident with a vertex of minimum degree are
removed. Thus, in either case, kðGÞ  dðGÞ.
Now, from Theorem 7.4, it follows that jðGÞ  kðGÞ. Hence, it is proved. h
Example 7.1 Find the edge connectivity, vertex connectivity and minimum degree
of the following graph in Fig. 7.9
Fig. 7.9
7.4
Edge Connectivity and Vertex Connectivity
121

Solution:
The vertex connectivity of the given graph is three because removal of v1; v2; v3 or
v4; v5; v6 disconnects the graph.
The edge connectivity of this graph is four. S ¼ fe1; e2; e3; e4g is one such cut
set. It can be observed that the degree of each vertex is at least four.
Therefore, j G
ð Þ ¼ 3; k G
ð Þ ¼ 4 and d G
ð Þ ¼ 4:
Example 7.2 Find the edge connectivity, vertex connectivity and minimum degree
of the following graph in Fig. 7.10.
Fig. 7.10
Solution:
The vertex connectivity of the given graph is two because removal of at least two
vertices are required to disconnect the graph.
The edge connectivity of this graph is three because removal of at least three
edges are required to disconnect the graph. It can be observed that the degree of
each vertex is at least four.
Therefore, j G
ð Þ ¼ 2; k G
ð Þ ¼ 3 and d G
ð Þ ¼ 4:
Example 7.3 Show that, the edge connectivity k G
ð Þ, vertex connectivity j G
ð Þ,
and minimum degree d G
ð Þof the following graph in Fig. 7.11 are equal. Is the
given graph separable?
Fig. 7.11
Solution:
The vertex connectivity of the given graph is two because removal of at least two
vertices are required to disconnect the graph. So, j G
ð Þ ¼ 2
The edge connectivity of this graph is two because removal of at least two
edges are required to disconnect the graph. Therefore, k G
ð Þ ¼ 2
122
7
Cut Sets and Cut Vertices

It can be observed that the degree of each vertex is at least two.
Therefore, j G
ð Þ ¼ k G
ð Þ ¼ d G
ð Þ ¼ 2:
Moreover, the given graph in Fig. 7.11 is nonseparable, since it has no cut
vertex.
Example 7.4 Find the fundamental cut sets of the graph in Fig. 7.1
Solution:
The Fig. 7.12 shows the spanning tree obtained by DFS.
From the simple graph Fig. 7.1, we see that there are n  1 ¼ 7  1 ¼ 6 fun-
damental cut sets with regard to the branches e1; e3; e4; e7; e8 and e9 of the span-
ning tree in Fig. 7.12.
Fundamental cut sets
Corresponding branch
fe2; e6; e7g
e7
fe2; e5; e4g
e4
fe2; e6; e8; e10g
e8
fe2; e5; e9; e10g
e9
fe1g
e1
fe3g
e3
Exercises:
1. Prove that a vertex v of a tree T is a cut vertex if and only if dðvÞ [ 1.
2. Let T be a tree with at least three vertices. Prove that there is a cut vertex v of
T such that every vertex adjacent to v, except for possibly one, has degree 1.
3. Let v be a cut vertex of the simple connected graph G. Prove that v is not a cut
vertex of its complement G.
4. Let G be a simple connected graph with at least two vertices and let v be a
vertex in G of smallest possible degree, say k.
(a) Prove that jðGÞ  k where jðGÞ is called vertex connectivity of G. It is the
smallest number of vertices in G whose deletion from G leaves either a
disconnected graph or K1:
(b) Prove that j G
ð Þ  2e=n, where e is the number of edges and n is the number
of vertices in G.
Fig. 7.12 A spanning tree
obtained by DFS
7.4
Edge Connectivity and Vertex Connectivity
123

5. Let G be a Hamiltonian graph. Show that G does not have a cut vertex.
6. Find the edge connectivity and vertex connectivity of the following graph in
Fig. 7.13.
Fig. 7.13
124
7
Cut Sets and Cut Vertices

Chapter 8
Coloring
Coloring of a graph
Proper coloring: A proper coloring or coloring of a graph G assigns colors
usually denoted by 1, 2, 3, … etc., to the vertices of G; one color per vertex, so that
the adjacent vertices are assigned different colors. For example, Fig. 8.1 shows
proper coloring of a graph.
8.1 Properly Colored Graph
A graph in which every vertex has been assigned a color according to a proper
coloring is called a properly colored graph.
k-Colorable: A k-coloring of G is a coloring which consists of k different colors
and in this case, the graph G is said to be k-colorable.
Fig. 8.1 A properly colored
graph
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_8,  Springer India 2013
125

8.2 Chromatic Number
The minimum number n, for which there is an n-coloring of the graph G, is called
chromatic number or chromatic index of the graph G. It is denoted by vðGÞ.
If vðGÞ ¼ k, then the corresponding graph G is called k-chromatic. For
example, the graph in Fig. 8.1 is 4-chromatic.
Theorem 8.1 Let G be a non-empty graph. Then vðGÞ ¼ 2 , i.e.,. 2-chromatic if
and only if G is bipartite.
Proof Let G be a bipartite graph with bipartition V ¼ X [ Y.
Now, we assign color 1 to all the vertices in X and assign color 2 to all the
vertices in Y. Then it gives a 2-coloring for G and so, since G is nonempty,
vðGÞ ¼ 2:
Conversely,
suppose that vðGÞ ¼ 2, i.e., the graph G is 2-chromatic. Then, G has a 2-
coloring.
To show: The graph G is bipartite.
Let X be the set of all vertices with color 1 and Y be the set of all vertices with
color 2.
Since, the graph G is properly colored, no two vertices in X are adjacent to each
other. Similarly, no two vertices in Y are adjacent to each other.
So, since G is nonempty, every edge of G has one end vertex in X and another
end vertex in Y. Therefore, G is a bipartite graph with bipartition V ¼ X [ Y. h
Theorem 8.2 Let G be a graph then vðGÞ  3 if and only if G has an odd cycle.
Proof Let G be a non-empty graph with at least two vertices, then G is bipartite if
and only if it has no odd cycle. Then from the previous Theorem 8.1, vðGÞ ¼ 2 if
and only if G has no odd cycle.
Now, if the graph G has an odd cycle then the chromatic number of G should be
greater than 2; since the graph has at least two vertices the chromatic number of G
cannot be less than 2 , i.e., vðGÞ 6¼ 1. Moreover, we would require at least three
colors just for that odd cycle in G. So, vðGÞ  3 if and only if the graph G has an
odd cycle.
h
Theorem 8.3 A graph with at least one edge is 2-chromatic if and only if it has no
odd cycles.
Proof It follows from Theorem 8.1, since we know that if G has a non-empty
graph with at least two vertices, then G is bipartite if and only if G has no odd
cycles.
h
Theorem 8.4 Every tree with two or more vertices is 2-chromatic.
Proof Consider the vertex v be the root of the tree T as shown in Fig. 8.2.
126
8
Coloring

Now color the root vertex v with 1 then color all the vertices which are adjacent
to the root vertex v with color 2. Again color the vertices adjacent to these vertices
using color 1. Continue this process until all the vertices in T has been properly
colored.
From the tree T, we can see that all the vertices at odd distances from the root
vertex v have color 2, while v and the vertices at even distances from v have color 1.
Now consider any path in the tree T, the vertices along that path are alternating
colored. Since there is one and only one path between any two vertices in a tree, no
two adjacent vertices have the same color. Thus, T has been properly colored with
two colors, viz. vðTÞ ¼ 2. So, T is 2-chromatic. Hence, it is proved.
h
8.3 Chromatic Polynomial
In general, a given graph G with n vertices can be properly colored in many
different ways using a sufﬁciently large number of colors. This property of a graph
can be expressed elegantly by means of a polynomial. This polynomial is called
the Chromatic Polynomial of G.
Deﬁnition: The chromatic polynomial gives the value which indicates the
number of different ways of properly coloring the graph G with n-vertices using at
most k colors (k or fewer numbers of colors). It is usually denoted by vGðkÞ or
v G; k
ð
Þ:
8.3.1 Chromatic Number Obtained by Chromatic Polynomial
The smallest positive integer value of k, such that vGðkÞ is not equal to zero, is the
Chromatic Number of G.
Fig. 8.2 A Properly colored
tree
8.2
Chromatic Number
127

So, v G
ð Þ ¼ min f k 2 ZþjvGðkÞ 6¼ 0g.
For example, if the graph be K2 and if there are k colors available, one of the
vertices can be colored in k different ways and the other can be colored in ðk  1Þ
different ways. So, vK2 k
ð Þ ¼ kðk  1Þ. The smallest positive integer value of k
such that vK2 k
ð Þ ¼ kðk  1Þ 6¼ 0 is 2, which is the Chromatic Number of K2.
More generally,
vKn k
ð Þ ¼ k k  1
ð
Þ k  2
ð
Þ    ðk  n þ 1Þ
8.3.2 Chromatic Polynomial of a Graph G
Suppose that, there are fðrÞ different ways of partitioning the vertex set of a graph
G into r independent (A set of vertices in a graph G is independent if no two of
them are adjacent.) non-empty subsets (In other words, it is the number of different
ways of partitioning the vertex set of G so that the vertices of G can be properly
colored using r colors). Then for each such partition, the number of different ways
of properly coloring the vertices of G is kðrÞ, where kðrÞ ¼ k k  1
ð
Þ k  2
ð
Þ   
ðk  r þ 1Þ (which is called Factorial Function).
[If n is any positive integer, then the factorial n th power of k is denoted by
½kn or kðnÞ and is deﬁned by kðnÞ ¼ k k  1
ð
Þ k  2
ð
Þ    ðk  n þ 1Þ. In particular,
kð0Þ ¼ 1 and kð1Þ ¼ k]
Consequently,
vG k
ð Þ ¼
X
r
fðrÞkðrÞ
If the order of G be n , i.e., G has n vertices, f rð Þ ¼ 0 whenever r [ n.
Thus, vG k
ð Þ is a polynomial in k, which is known as Chromatic Polynomial of
degree n with integer co-efﬁcients. In this polynomial, the co-efﬁcient of the
leading term kn is 1, since fðnÞ ¼ 1, i.e., there is only one way of partitioning the
vertex set of n vertices into n non-empty independent subsets. Moreover, f 0
ð Þ ¼ 0;
therefore the constant term in the Chromatic polynomial is 0. It can be observed
that the co-efﬁcients in the polynomial alternate in sign.
128
8
Coloring

Example 8.1 Find the chromatic polynomial of the graph in Fig. 8.3.
Fig. 8.3
Solution:
Let f rð Þ be the number of different ways of partitioning the vertex set V ¼
f1; 2; 3; 4; 5g into r independent subsets. Hence, there is at least one edge in the
graph. So, f 1
ð Þ ¼ 0. It is not possible to partition V into two independent subsets.
So, f 2
ð Þ ¼ 0. In fact, the vertex set V cannot be partitioned into one or two
independent subsets so that the vertices of G can be properly colored using one or
two colors, respectively.
There are two ways of partitioning V into three independent subsets, viz.
f 3
f g; 1; 4
f
g; f2; 5gg and f 4
f g; 1; 3
f
g; f2; 5gg. So, f 3
ð Þ ¼ 2. Consequently, there
are two ways of partitioning V so that the vertices of G can be properly colored
using precisely three colors.
Similarly, there are three ways of partitioning V into four independent subsets,
viz. {{1},{3},{4},{2,5}}, f 2
f g; 3
f g; 5
f g; f1; 4gg and {{2},{4},{5},{1,3}}. So,
f 4
ð Þ ¼ 3. This implies that there are three ways of partitioning V so that the
vertices of G can be properly colored using precisely four colors. Finally,
f 5
ð Þ ¼ 1. Thus,
vG k
ð Þ ¼ 2k k  1
ð
Þ k  2
ð
Þ þ 3k k  1
ð
Þ k  2
ð
Þ k  3
ð
Þ
þ k k  1
ð
Þ k  2
ð
Þ k  3
ð
Þ k  4
ð
Þ
¼ k k  1
ð
Þ k  2
ð
Þðk2  4k þ 5Þ
¼ k5  7k4 þ 19k3  23k2 þ 10k
Hence, the Chromatic number v G
ð Þ ¼ 3, i.e., the given graph G is 3-Chromatic.
8.3
Chromatic Polynomial
129

Example 8.2 Find the chromatic polynomial of the graph in Fig. 8.4.
Fig. 8.4
Solution:
Let f rð Þ be the number of different ways of partitioning the vertex set
V ¼ f1; 2; 3; 4; 5g into r independent subsets. Since, there is at least one edge in
the graph. So, f 1
ð Þ ¼ 0. It is not possible to partition V into two independent
subsets. So, f 2
ð Þ ¼ 0. In fact, the vertex set V cannot be partitioned into one or two
independent subsets so that the vertices of G can be properly colored using one or
two colors, respectively.
There are two ways of partitioning V into three independent subsets, viz.
f 1; 5
f
g; 2; 4
f
g; f3gg and f 1; 4
f
g; 2; 5
f
g; 3
f gg. So, f 3
ð Þ ¼ 2. Consequently, there
are two ways of partitioning V so that the vertices of G can be properly colored
using precisely three colors.
Similarly, there are four ways of partitioning V into four independent subsets,
viz.
f 2
f g; 3
f g; 4
f g; f1; 5gg,f 1
f g; 3
f g; 5
f g; f2; 4gg, f 1
f g; 3
f g; 4
f g; f2; 5gg
and
{{2},{3},{5},{1,4}}. So, f 4
ð Þ ¼ 4. This implies that there are four ways of par-
titioning V so that the vertices of G can be properly colored using precisely four
colors. Finally, f 5
ð Þ ¼ 1. Thus,
vGðkÞ ¼ 2kðk1Þðk2Þþ4kðk1Þðk2Þðk3Þþkðk1Þðk2Þðk3Þðk4Þ
¼ kðk1Þ2ðk2Þ2
Hence, the Chromatic number v G
ð Þ ¼ 3, i.e., the given graph G is 3-Chromatic.
Theorem 8.5 A graph with n vertices is a complete graph if and only if its
Chromatic Polynomial is vG k
ð Þ ¼ k k  1
ð
Þ k  2
ð
Þ    ðk  n þ 1Þ.
Proof Using k colors, there are k different ways of coloring any selected vertex of
the graph. A second vertex can be properly colored in exactly ðk  1Þ ways, the
third vertex in ðk  2Þ ways, the fourth in ðk  3Þ ways,. . . and therefore, the n th
vertex in ðk  n þ 1Þ ways if and only if every vertex is adjacent to each other. It is
possible if and only if the graph G is complete.
h
130
8
Coloring

8.4 Edge Contraction
Let G be a graph with e ¼ uv 2 EðGÞ and let x ¼ xðuvÞ be a new contracted
vertex. The graph G  e on
VðG  eÞ ¼ V G
ð Þ  u; v
f
g
ð
Þ [ fxg
is obtained from G by contracting the edge e.
Here,
E G  e
ð
Þ ¼ fjf 2 E G
ð Þ; f has no end u or v
f
g [ wxjwu 2 E G
ð Þ or wv 2 E G
ð Þ
f
g
Hence, G  e is obtained by introducing a new vertex x as shown in Fig. 8.5, and
by replacing all edges wu and wv by wx, and the vertices u and v are deleted.
Theorem 8.6 If T be a tree with n vertices then its Chromatic Polynomial is
vT k
ð Þ ¼ k k  1
ð
Þn1
Proof We shall use induction on n. For n  2, the claim is obvious. Suppose that,
n  3 and let us assume that the result is true for all trees with n  1 vertices. Let
e ¼ uv 2 EðTÞ, where v is a leaf of T. A proper k coloring of T is a proper k
coloring of T  e if and only if the end vertices u and v of e have distinct colors.
Therefore, we can obtain the proper k coloring of T by subtracting from proper
k coloring of T  e, the number of proper k coloring of T  e in which u and v
have the same color. Now, colorings of T  e in which u and v have the same color
correspond directly to proper k coloring of T  e, in which the color of the con-
tracted vertex is the common color of u and v (Fig. 8.6).
Fig. 8.5 An edge contracted
graph G  e obtained from G
8.4
Edge Contraction
131

Now, T  e is a tree with n  1 vertices, and thus by induction hypothesis,
vTe k
ð Þ ¼ k k  1
ð
Þn2
Again, the graph T  e consists of the isolated vertex v and a tree with n  1
vertices. Therefore, since isolated vertex v can be colored in k different ways
vTe k
ð Þ ¼ k:k k  1
ð
Þn2
Now,
vT k
ð Þ ¼ vTe k
ð Þ  vTeðkÞ
¼ k:k k  1
ð
Þn2k k  1
ð
Þn2
¼ k k  1
ð
Þn1
Hence, it is proved.
h
Critical graphs: A k-chromatic graph G is said to be k-critical, if vðHÞ\k for
all H  G with H 6¼ G.
Theorem 8.7 If G is k-critical for k  2, then it is connected, and dðGÞ  k  1.
Proof We can see that for any graph G with the connected components
G1; G2; :::; Gm, vðGÞ ¼ maxfvðGiÞji 2 ½1; mg. Connectivity claim follows from
this observation.
Fig. 8.6 a A tree T with an
edge e, b Disconnected graph
T-e after deleting the edge e,
and c Tree T  e after
contracting edge e
132
8
Coloring

Then let G be k-critical, but dðGÞ ¼ dðvÞ  k  2 for v 2 G. Since G is critical,
there is a proper ðk  1Þ-coloring of G  v. Now v is adjacent to only
d G
ð Þ\k  1vertices. But there are k colors, and hence there is an available color i
for v. If we recolor v by i, then a proper ðk  1Þ-coloring is obtained for G;
a contradiction. Hence the theorem is proved.
h
Exercises:
1. Find the chromatic polynomial of the graph in Fig. 8.7 and hence ﬁnd the
chromatic number of the given graph.
Fig. 8.7
2. Show that if G contains exactly one odd cycle, then v G
ð Þ ¼ 3:
3. If G is a graph in which any pair of odd cycles have a common vertex, then
prove that vðGÞ  5:
4. Determine the chromatic number of the graphs in Fig. 8.8
5. If G is k-regular, prove that vðGÞ 
n
n  k.
6. Show that, the chromatic polynomial of a graph consisting of a single circuit of
length n is vG k
ð Þ ¼ ðk  1Þn þ ðk  1Þð1Þn.
7. Show that, the chromatic polynomial of a graph of n vertices satisﬁes the
inequality vG k
ð Þ  kðk  1Þn1.
8. Show that, the absolute value of the second coefﬁcient of kn1 in the chromatic
polynomial vG k
ð Þ of a graph equals the number of edges in the graph.
Fig. 8.8 Herschel and Grötzsch graphs
8.4
Edge Contraction
133

Chapter 9
Planar and Dual Graphs
9.1 Plane and Planar Graphs
9.1.1 Plane Graph
Deﬁnition A graph is called a plane graph if it can be drawn on a plane in such a way
that any two of its edges either meet only at their end vertices or do not meet at all.
9.1.2 Planar Graph
Deﬁnition A graph which is isomorphic to a plane graph is called a planar graph.
Fig. 9.1 a A planar graph G1 and plane graphs G2 and G3 and b A planar graph G4 and plane
graph G5
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_9,  Springer India 2013
135

Illustration: In Fig. 9.1, G1 is a planar graph, since it is isomorphic to G2 and
G3 which are plane graph. Here, G1 and G4 are not plane graph. But G4 is
isomorphic to G5 which is a plane graph. So, G4 is a planar graph.
9.2 Nonplanar Graph
A graph which is not planar is called nonplanar graph.
The graph shown in Fig. 9.2 cannot be redrawn without crossing over the
edges. So, this graph is a nonplanar graph.
Observation
To declare a graph as a planar graph we must see whether the given graph can be
redrawn on a plane so that no edges intersect each other. If it is not possible then
the graph is nonplanar graph.
It is clear that plane graph is always planar graph.
9.3 Embedding and Region
9.3.1 Embedding
A drawing of a geometric representation of a graph on any surface is called
embedding such that no edges intersect each other. Therefore, to declare a graph G
as a nonplanar graph, we must see, out of all possible geometric representations of
the graph G, none can be embedded on a plane.
A graph G is said to be a planar graph if there exists a graph isomorphic to G
such that it is embedded on a plane. Otherwise, the graph G is nonplanar.
Fig. 9.2 A nonplanar graph
136
9
Planar and Dual Graphs

9.3.2 Plane Representation
An embedding of a planar graph G on a plane is called a plane representation of G.
Example In Fig. 9.1, G5 is a plane representation of G4.
9.4 Regions or Faces
A plane representation of a graph divides the plane into regions or faces. A region
is characterized by the set of edges forming its boundary.
For example: In Fig. 9.3a, there are four regions. On the other hand, Fig. 9.3b
has six regions.
Inﬁnite Region: The portion of the plane lying outside the graph embedded on
a plane is called inﬁnite region for that particular plane representation.
For example, in Fig. 9.3a, region 4 is inﬁnite in its extent.
A region is not deﬁned in a nonplanar graph or even in a planar graph not
embedded on a plane. For example, the planar graph shown in Fig. 9.3a has no
region.
9.5 Kuratowski’s Two Graphs
The complete graph K5 and the complete bipartite graph K3;3 are called Kura-
towski’s graphs, after the polish mathematician Kazimierz Kuratowski, who
found that K5 and K3;3 are nonplanar.
Fig. 9.3 a A planar graph K4
and its corresponding plane
graph and b A plane graph
citing its six regions
9.3
Embedding and Region
137

9.5.1 Kuratowski’s First Graph
The complete graph with ﬁve vertices, i.e., K5 is called Kuratowski’s First graph.
In Fig. 9.4, K5 is nonplanar since plane representation of it is not possible.
9.5.2 Kuratowski’s Second Graph
The complete bipartite graph K3;3 is called Kuratowski’s second graph. It is also
nonplanar, since plane representation of K3;3 is not possible. Figure 9.5 shows
Kuratowski’s second graph K3;3 and its corresponding isomorphic graph.
9.6 Euler’s Formula
Theorem 9.1 A connected planar graph G with n vertices and e number of edges
has f ¼ ðe  n þ 2Þ number of regions or faces.
Proof We shall prove this theorem using induction on region f.
If f ¼ 1; then G has only one region which is the only inﬁnite region. So, G
cannot have any circuit because a circuit bounds a region. So, G is a tree. Now, G
has n vertices and ðn  1Þ edges.
Fig. 9.4 Kuratowski’s ﬁrst
graph K5
Fig. 9.5 Kuratowski’s second graph K3,3
138
9
Planar and Dual Graphs

Therefore, n  e þ f ¼ n  ðn  1Þ þ 1 ¼ 2
Hence, the theorem is proved for f ¼ 1:
Now, let f [ 1 and the theorem is true for all connected planar graph having
less than f regions. Since, f [ 1; G is not a tree. G has at least one circuit.
Let d be an edge of a circuit. Then ðG  dÞ is still a connected graph. Since
ðG  dÞ is a subgraph of planar graph G, so ðG  dÞ is also a planar graph because
every subgraph of a planar graph is also a planar graph.
Now, due to removal of an edge d the two regions of the graph G will be
combined into one region and so, the number of regions in ðG—dÞ is ðf  1Þ and
the number of edges of ðG  dÞ is ðe  1Þ.
Therefore, by induction hypothesis, the theorem is true for ðG  dÞ. So, in case
of ðG  dÞ, we can get
n  ðe  1Þ þ f  1 ¼ 2
i:e:
n  e þ f ¼ 2:
Hence, by induction, the theorem is true for all connected planar graphs.
h
The above Fig. 9.6 shows two faces combines when a cycle edge is deleted in G.
Theorem 9.2 In any simple planar graph G with f regions, n vertices and e edges
where n  3 the following inequalities must hold
(i) e  3f=2
(ii) e  3n  6
Proof We ﬁrst assume that the graph G is connected.
Case I: If n ¼ 3 then the graph G must have at most three edges, i.e., e  3 this
implies e  3  3  6 ¼ 3n  6. Therefore, the result is true for n ¼ 3.
Fig. 9.6 Graph G with four faces and Graph G—d with three faces
9.6
Euler’s Formula
139

If G has exactly 3 edges then G has 2 regions, otherwise G has one region, i.e.,
if G has e ¼ 3 number of edges then f ¼ 2; and also if G has e ¼ 2 number of
edges then f ¼ 1 (since, G is simple graph). In either case e  3f=2.
Case II:
We now assume that n  4.
If G is a tree then G has e ¼ ðn  1Þ edges and f ¼ 1, since G is a tree having
one
region.
So,
e ¼ n  1  4  1 ¼ 3
2  2 [ 3
2  1 ¼ 3
2  f.
Consequently,
e  3f=2.
If G is not a tree then there exists at least one circuit whose edges are the
boundary of the inﬁnite region. Now, since G is a simple graph so the number of
boundary edges of each region of G  3.
Therefore the sum of the number of boundary edges of all regions of
G  3f
ð9:1Þ
Consequently, the total number of boundary edges of all regions of G  2e. In
fact, each edge is counted twice since each edge belongs to exactly two regions.
So, from Eq. (9.1) we get
3f  2e
) e  3
2 f
ð9:2Þ
By Euler’s formula, we know that f ¼ e  n þ 2
Here,
e  3
2 f
) e  3ðe  n þ 2Þ=2
) 2e  3e  3n þ 6
) e  3n  6
Now, if possible, suppose G is a disconnected graph. Then G has G1; G2; . . .; Gk
connected components.
Let ni and ei be the number of vertices and number of edges of the ith com-
ponent Gi, where 1  i  k; and also, n ¼ Pk
i¼1 ni; and e ¼ Pk
i¼1 ei: From the
above argument, we can obtain for the ith component of the graph, i.e., Gi;
ei  3ni  6
ðsince; Gi is connectedÞ
)
X
k
i¼1
ei  3
X
k
i¼1
ni  6k
) e  3n  6k  3n  6
Hence, the theorem is proved.
h
140
9
Planar and Dual Graphs

Corollary 1 Prove that K5 is a nonplanar graph.
Proof The graph K5 is a complete graph with ﬁve vertices. Here, n ¼ 5,
e ¼ nðn  1Þ
2
¼ 10
From the above theorem 9.2,
e  3n  6
) e  3  5  6 ¼ 9
It is a contradiction, since here e ¼ 10: So, K5 is a nonplanar graph.
h
Corollary 2 Prove that K3;3 is a nonplanar graph.
Proof Here, the number of vertices n ¼ 6; and the number of edges e ¼ 9:
From the above theorem 9.2,
e  3n  6 ¼ 3  6  6 ¼ 12
Since, e ¼ 9. e  3n  6 implies that 9\12: So, the inequality holds in this
case.
But still K3;3 is a nonplanar graph.
We know that K3;3 is a complete bipartite graph and so it has no odd cycle. In
particular, it has no 3-cycle. It follows that every region of a plane drawing of K3;3,
if such exists, must have at least four boundary edges. Therefore the number of
boundary edges of each region of K3;3  4.
Consequently, the sum of number of boundary edges of all regions of
K3;3  4f:
ð9:3Þ
Now, the sum of number of boundary edges of all regions of K3;3  2e; since,
each edge is counted twice.
Therefore; 4f  2e
i:e:
f  e=2 ¼ 9=2:
ð9:4Þ
Now, Suppose K3;3 is a planar graph; therefore, the plane representation of K3;3
is possible.
By Euler’s formula, we know f ¼ e  n þ 2. This implies f ¼ 9  6 þ 2 ¼ 5
which is a contradiction in view of Eq. (9.4).
Hence, K3;3 is a nonplanar graph.
h
Example 9.1 Removal of one edge or vertex makes Kuratowski’s ﬁrst graph a
planar graph.
9.6
Euler’s Formula
141

Solution:
Removal of one edge
In Fig. 9.7a, G represents the Kuratowski’s ﬁrst graph. G  e is the graph
obtained after removal of edge e from G shown in Fig. 9.7b. Finally, Fig. 9.7c
shows the plane representation of the graph G  e. So, G  e is a planar graph.
Removal of one vertex
Removal of vertex v1 from G in Fig. 9.7a results in a graph G  v1 shown in
Fig. 9.8a. G  v1 is redrawn below without any crossover of edges. Figure 9.8b
shows the plane representation of G  v1: This shows that G  v1 is a planar graph.
Fig. 9.7 a Nonplanar graph G, b Planar graph G–e, and c Plane representation of G–e
Fig. 9.8 a Planar graph G - v1 and b Plane representation of G - v1
142
9
Planar and Dual Graphs

9.7 Edge Contractions
Let G be a multigraph, and let e be an edge of G with distinct endpoints x and y.
The Contraction G  e or Gje can be deﬁned by modifying G as follows:
We remove the edge e and identify its endpoints x and y to obtain one vertex ve
as shown in Fig. 9.9.
If e0 ¼ ux is an edge in G with x as an endpoint, it is replaced by the edge uve in
Gje, and likewise for edges with y as an endpoint. Loops at one of x or y become
loops at ve. This may also introduce new loops or parallel edges.
In fact, if G is planar, then Gje is also planar.
9.8 Subdivision, Branch Vertex, and Topological Minors
Let G; H be multigraphs, and e 2 EðGÞ.
Subdivision of edge: The subdivision of edge e ¼ xy is the replacement of e with
a new vertex z and the two new edges xz and zy.
Subdivision: A (multi-)graph H0 is a subdivision of H, if one can obtain H0 from
H by a series of edge subdivisions (Fig. 9.10)
Fig. 9.9 Graphs showing edge contraction
Fig. 9.10 A subdivision of
K3,3
9.7
Edge Contractions
143

Branch Vertices: Vertices of H0 with degree at least three are called branch
vertices.
Minor: If H can be obtained from G by a sequence of contractions and (edge/
vertex) deletions, then H is called a minor of G.
Topological Minors: If G contains a subdivision of H, then H is called a
topological minor of G.
A topological minor is a minor, but not vice versa.
Characterization of Planar Graphs:
The Polish Mathematician Kazimierz Kuratowski discovered an interesting
property of planar and nonplanar graphs. In his honor, the two graphs K5 and K3;3
are called Kuratowski’s ﬁrst graph and Kuratowski’s second graph, respectively.
It has been proved that the complete graph K5 and the complete bipartite graph
K3;3 are nonplanar. K5 and K3;3 do not embed in the plane. In fact, these are the
crucial graphs and lead to a characterization of planar graphs known as Kuratowski’s
theorem.
The following result is used in proving Kuratowski’s theorem.
Theorem 9.3
i. If Gje contains a subdivision of K5, then G contains a subdivision of K5 or K3;3.
ii. If Gje contains a subdivision of K3;3, then G contains a subdivision of K3;3:
Proof Let G0 ¼ Gje be a graph obtained by contracting the edge e ¼ xy of G. Let
w be the vertex of G0 obtained by contracting e ¼ xy.
i. Let Gje contains a subdivision of K5, say H. If w is not a branch vertex of H,
then G also contains a subdivision of K5, obtained by expanding w back into the
edge xy, if necessary, as shown in Fig. 9.11.
Fig. 9.11
Assume w is a branch vertex of H and each of x; y is incident in G to two of the
four edges incident to w in H. Let u1 and u2 be the branch vertices of H that are at
the other ends of the paths leaving w on edges incident to x in G. Let v1; v2 be the
branch vertices of H that are at the other ends of the paths leaving w on edges
incident to y in G (Fig. 9.12a).
144
9
Planar and Dual Graphs

Fig. 9.12
By deleting the u1  u2 path and v1  v2 path from H, we obtain a subdivision
of K3;3 in G, in which y; u1, u2 are branch vertices for one partite set, and x; v1; v2
are branch vertices of the other.
ii. Let Gje contains a subdivision of K3;3, say H. If w is not a branch vertex of H,
then G also contains a subdivision of K3;3, obtained by expanding w back into
the edge xy, if necessary (Fig. 9.12b).
Now, assume that w is a branch vertex in H and at most one of the edges incident
to w in H is incident to x in G. Then w can be expanded into xy to lengthen that path
and y becomes the corresponding branch vertex of K3;3 in G (Fig. 9.12c).
h
9.8
Subdivision, Branch Vertex, and Topological Minors
145

9.9 Kuratowi’s Theorem
This theorem was independently given by Kuratowski in 1930. In 1954, Dirac and
Schuster found a poof that was slightly shorter than the original proof. The proof
given here is due to Thomassen (1981).
Theorem 9.4 A graph is planar if and only if it does not have any subdivision of
K5 or K3;3.
Proof Necessity: Let G be a planar graph. Then any of its subgraphs is neither K5
nor K3;3 nor does it contain any subdivision of K5 or K3;3.
Sufﬁciency: It is enough to prove sufﬁciency for 3-connected graphs. Let G be a
3-connected graph with n vertices. We prove that the 3-connected graph G either
contains a subdivision of K5 or K3;3 or has a convex plane representation. This we
prove by using induction on n: Since G is 3-connected, therefore, n  4. For n ¼ 4;
G ¼ K4 and clearly G has a plane representation.
Now, let n  5: Assume the result to be true for all 3-connected graphs with
fewer than n vertices. Since G is 3-connected, G has an edge e such that Gje is 3-
connected. Let e ¼ xy:
If Gje contains a subdivision of K5 or K3;3; then G also contains a subdivision of
K5 or K3;3.
Therefore, let Gje ¼ H have a convex plane representation. Let z be the vertex
obtained by contraction of e ¼ xy. The plane graph obtained by deleting the edges
incident to z has a region containing z (this may be the exterior region). Let C be
the cycle of H  z bounding this region.
Since we started with a convex plane representation of H, we have straight
segments from z to all its neighbors. Let x1; x2; :::; xk be the neighbors of x in that
order on C.
If all the neighbors of y belong to a single segment from xi to xiþ1 on C, then we
obtain a convex plane representation of G by putting x at z in H, and putting y at a
point close to z in the wedge formed by xxi and x xiþ1.
If all the neighbors of y do not belong to any single segment xi xiþ1 on C
ð1  i  k; xkþ1 ¼ x1Þ, then we have the following cases as shown in Fig. 9.13.
Fig. 9.13
146
9
Planar and Dual Graphs

1. y shares three neighbors with x. In this case C together with these six edges
involving x and y form a subdivision of K5.
2. y has two u, v in C that are in different components of the subgraph of C
obtained by deleting xi and xiþ1, for some i. In this case, C together with the
paths uyv, xixxiþ1, and xy form a subdivision of K3;3.
h
Homeomorphic Graphs: Two graphs are said to be homeomorphic if one graph
can be obtained from the other by the creation of edges in series or by the merging
of edges in series.
Equivalently, two graphs are homeomorphic if they are both subdivisions of
some graph.
For Example:
The three graphs in Fig. 9.14a are homeomorphic to each other. Similarly, all
the graphs in Fig. 9.14b are homeomorphic to each other.
Applications of Kuratowski’s Theorem:
Formally, we can state Kuratowski’s theorem as:
A graph G is planar if and only if G does not contain either of the Kuratowski’s
two graphs or any graph homeomorphic to either of them.
Remarks If the contracted graph Gje contains a subdivision of K3;3 then so does G.
If Gje contains a subdivision of K5 then G contains a subdivision of K5 or K3;3 (It
does not need to contain a subdivision of K5).
A further result is that:
A graph is planar if and only if it contains no subgraph contractible to K5 or K3;3
by removing edges from the subgraph and merging the adjacent vertices into one.
For example, we can contract the Petersen graph as shown below, thus proving
the Petersen graph to be nonplanar (Fig. 9.15).
Fig. 9.14 Homeomorphic graphs
9.9
Kuratowi’s Theorem
147

Example 9.1 Using Kuratowski’s theorem, check if the following graphs in
Fig. 9.16 are nonplanar.
Solution:
The graph G1 has a subgraph G2 and clearly G2 is Homeomorphic to K3;3.
Therefore, according to Kuratowski’s theorem, the given graphs G1 and G2 are
nonplanar graphs.
Example 9.2 Using Kuratowski’s theorem, check that the following graphs are
nonplanar (Fig. 9.17).
Fig. 9.15 Petersen graph which is Homeomorphic to K5
Fig. 9.16 Petersen graph G1 and its subgraph G2 which is Homeomorphic to K3,3
Fig. 9.17 Two nonplanar
graphs G1 and G2
148
9
Planar and Dual Graphs

Solution:
The graph G1 is isomorphic to G2 and it can be shown that G2 is Homeomorphic to
K3;3. So according to Kuratowski’s theorem, the given graphs both G1 and G2 are
nonplanar graphs.
Example 9.3 If Kn is a complete graph with n vertices then ﬁnd all integral values
of n  2 for which Kn is a planar graph.
Solution:
If n ¼ 2; 3 then K2; K3 are planar graphs respectively.
Similarly,
If n ¼ 4, then K4 is a planar graph as shown in Fig. 9.3a.
Now, if n ¼ 5; then we have proved that K5 is a nonplanar graph.
If n ¼ 6; then according to Kuratowski’s theorem, the graph K6 is a nonplanar
graph since K6 contains K5 as a subgraph (Fig. 9.18).
Similarly, according to Kuratowski’s theorem, K7 is nonplanar since K7 also
contains K5 as a subgraph, and so on.
Hence, the required integral values of n are 2, 3, and 4.
9.10 Dual of a Planar Graph
The following Fig. 9.19a shows the plane representation of a graph G with six
regions or faces F1; F2; F3; F4; F5; and F6:
9.10.1 To Find the Dual of the Given Graph
First: Let us place six points P1; P2; . . .; P6 one in each of the regions, as shown in
Fig. 9.19b.
Fig. 9.18 Nonplanar
complete graph K6
9.9
Kuratowi’s Theorem
149

Second: Let us join these 6 points according to the following procedure.
Construction of dual graph: If two regions Fi and Fj are adjacent (i.e., have a
common edge), draw a line joining the points Pi and Pj such that the line joining
these points intersect the common edge between the regions Fi and Fj exactly
once. For example, in Fig. 9.19c, F3 and F4 are adjacent. So, we join P3 and P4 by
an edge.
If there is more than one edge common between Fi and Fj, draw one line
between points Pi and Pj for each of the common edges. For example, in
Fig. 9.19c, there are two edges common between F1 and F2. So, we draw one edge
between P1 and P2 for each of the common edges.
If an edge e lies entirely in one region say Fk, a self-loop is to be drawn at the
point Pk intersecting the edge e exactly once. So, we draw a loop at the point P1
intersecting the edge e exactly once.
By this procedure, we obtain a new graph G from the given graph G consisting
of six vertices P1; P2; . . .; P6 corresponding to the regions F1; F2; . . .; F6 of G and
the edges joining these six vertices P1; P2; . . .; P6. Such a graph G is called a dual
of the graph G.
Fig. 9.19 Graph G and its
Dual graph G*
150
9
Planar and Dual Graphs

9.10.2 Relationship Between a Graph and Its Dual Graph
1. There is a one-to-one correspondence between the edges of the graph G and its
dual G, since one edge of G intersects one edge of G exactly once.
2. Dual graph is possible only for planar graph. Dual of G is the original graph G.
3. An edge forming a self-loop in G yields a pendant edge in G. A pendant edge
is an edge incident on a pendant vertex. A pendant edge in G yields a self-loop
in G.
4. Edges that are in series in G produce parallel edges in G. Parallel edges in G
produce edges in series in G.
5. The number of vertices of G is equal to number of regions of G.
6. The number of edges of G is equal to number of edges of G, since one edge of
G intersects one edge of G exactly once.
7. The number of regions of G is equal to number of vertices of G.
Example 9.4 Show that the given two plane graphs G1 and G2 are isomorphic but
their dual are not isomorphic.
Solution:
From Fig. 9.20, we see that the number of edges and the number of vertices are the
same in G1 and G2. Also, incidence property is preserved.
Therefore, G1 ﬃG2
Dual of G1 and G2:
The dual graphs G
1 and G
2 are not isomorphic because the incidence property is
not preserved (Fig. 9.21).
Fig. 9.20 Two isomorphic
graphs G1 and G2
Fig. 9.21 Dual graphs G1
* and G2
*
9.10
Dual of a Planar Graph
151

Example 9.5 Using Kuratowski’s theorem, show that the following graphs below
are nonplanar (Fig. 9.22).
Solution:
The graph in Fig. 9.23a has a subgraph shown in Fig. 9.23b which is K3;3:
Therefore, by Kuratowski’s theorem, the graph in Fig. 9.23a is nonplanar.
Fig. 9.23
Figure 9.24a has a subgraph shown in Fig. 9.24b. Now, Fig. 9.24b is homeo-
morphic to Fig. 9.24c. Again, Fig. 9.24c is isomorphic to Fig. 9.24d which is K3;3:
Therefore, by Kuratowski’s theorem, the graph in Fig. 9.24a is nonplanar.
Fig. 9.22 Two nonplanar graphs
152
9
Planar and Dual Graphs

Fig. 9.24
9.11 Edge Coloring
Assignment of colors to the edge of a graph G, so that no two adjacent edges
receiving the same color is called an Edges coloring of G. k-edge coloring of a
graph G is an assignment of k-colors to the edge of G such that no two edges of G
receive the same color.
9.11.1 k-Edge Colorable
A graph G is said to be k-edge colorable, if there exists k-edge coloring of G.
9.11.2 Edge-Chromatic Number
The minimum number k, such that a graph G has k-edge coloring is said to be the
edge-chromatic number of G. The edge-chromatic number of a graph G is denoted
9.10
Dual of a Planar Graph
153

by v0ðGÞ. Thus, v0ðGÞ denotes the minimum number of colors required to color the
edges of the graph G, such that no two adjacent edges of G receive the same color.
9.12 Coloring Planar Graph
The most famous problem in the history of graph theory is that of the chromatic
number of planar graphs. The problem was known as the 4-Color Conjecture for
more than 120 years, until it was solved by Appel and Haken in 1976; if G is a
planar graph, then vðGÞ  4. The 4-color Conjecture has had a deep inﬂuence on
the theory of graphs during the last 150 years. The solution of the 4-color Theorem
is difﬁcult, and it requires the assistance of a computer.
Four-Color Problem:
The 4-color problem states that every plane map however complex, can be
colored with four colors in such a way that two adjacent regions get different
colors. This problem was solved by Appel and Haken in 1976.
Four-Color Conjecture:
Every planar graph is 4-colorable.
Illustration:
The graph K4 is a planar graph and K4 is 4-colorable as shown in Fig. 9.25.
9.12.1 The Four Color Theorem
The Four Color Theorem states that given any separation of a two-dimensional
area into connected regions, called a map, the regions can be colored using at most
four colors so that no two adjacent regions have the same color.
Note: It is important to realize that two regions are called adjacent only if they
share a border segment, and not just a point.
The now famous theorem was ﬁrst conjectured in 1852, but was not proven
until 1976, by Appel and Haken. They determined that there are 1936 ways to
draw a map (all others being equivalent to one of them), and that after thousands of
hours of computation they had reached the conclusion that in each case only four
colors are needed. Needless to say, many were skeptical of this method of proof,
but after the 400 pages of microﬁche output were independently checked, it was
declared as being valid. Thus the proof, unlike most proofs in mathematics, is
Fig. 9.25 A planar graph
with its four regions colored
154
9
Planar and Dual Graphs

technology dependent; that is, it uses computers in an essential way and depended
on the development of high-speed computers.
9.12.2 The Five Color Theorem
We prove Heawood’s result (1890) that each planar graph is properly 5-colorable.
The proof of the following theorem 9.6 is partly geometric in nature.
Theorem 9.5 (Heawood 1890) If G is a planar graph, then dðGÞ  5:
Proof If n  2, then there is nothing to prove. Suppose n  3. By the Handshaking
lemma and theorem 9.2
d G
ð Þ:n 
X
v2G
d v
ð Þ ¼ 2e  6n  12\6n
It follows that d G
ð Þ  5.
h
Theorem 9.6 (Heawood (1890)) (Five Color Theorem) Every planar graph is 5-
colorable, i.e., if G is a planar graph, then vðGÞ  5:
Proof It is equivalent to prove that no 6-critical planar graph exists. From theo-
rems 8.7 and 9.5, it follows that 6-critical graph G must have dðGÞ  5 and planar
graph must have dðGÞ  5. We can then assume G has a degree 5 vertex with
neighbors using all 5 colors in consecutive order. Denoting these neighbors
v1; v2; v3; v4; v5. Then we may switch color 1 to 3 on v1 and make any necessary
corrections. If v3 needs correction, then there must be a 1, 3 path connecting them;
but then we can change color 2 to 4 on v2 and never gets to v4. Therefore, G cannot
be 6-critical.
h
The ﬁnal word on the chromatic number of planar graph was proved by Appel
and Haken in 1976.
Theorem 9.7 (4-Color Theorem) Every planar graph is 4-colorable, i.e., if G is a
planar graph, then vðGÞ  4.
By the following theorem, each planar graph can be decomposed into two
bipartite graphs.
Theorem 9.8 Let G ¼ ðV; EÞ be a 4-chromatic graph, vðGÞ  4. Then the edges
of G can be partitioned into two subsets E1 and E2 such that ðV; E1Þ and ðV; E2Þ
are both bipartite.
Proof Let Vi ¼ a1ðiÞ be the set of vertices colored by i in a proper 4-coloring a
of G. We deﬁne E1 as the subset of the edges of G that are between the sets
V1 and V2;
V1 and V4;
V3 and V4: Let E2 be the rest of the edges, that is, they
are between the sets V1 and V3;
V2 and V3;
V2 and V4: It is clear that ðV; E1Þ
and ðV; E2Þ are bipartite, since the sets Vi are stable.
h
9.12
Coloring Planar Graph
155

9.13 Map Coloring
The 4-color conjecture was originally stated for maps. In the map-coloring
problem we are given several countries with common borders, and we wish to
color each country so that no neighboring countries obtain the same color.
A border between two countries is assumed to have a positive length—in
particular, countries that have only one point in common are not allowed in the
map coloring.
Formally, we deﬁne a map as a connected planar (embedding of a) graph with
no bridges [a bridge (also known as a cut-edge) is an edge whose deletion
increases the number of connected components]. The edges of this graph represent
the boundaries between countries. Hence a country is face of the map, and two
neighboring countries share a common edge (not just a single vertex). We deny
bridges, because a bridge in such a map would be a boundary inside a country.
The map-coloring problem is restated as follows:
How many colors are needed for the faces of a plane embedding so that no
adjacent faces obtain the same color.
Let F1; F2; . . .; Fn be the countries of a map M; and deﬁne a graph G with
VG ¼ fv1; v2; . . .; vng such that vivj 2 EG if and only if the countries Fi and Fj are
neighbors. It is easy to see that G is a planar graph. Using this notion of a dual
graph, we can state the map-coloring problem in a new form: What is the chro-
matic number of a planar graph? By the 4-Color theorem it is at most four.
Example: If we look at the map of the United States below, we see that only
four colors are used to color the states (Fig. 9.26).
Fig. 9.26 Map of United States
156
9
Planar and Dual Graphs

Note: We can use only three colors for many maps, a fourth being needed when
a region has common borders with an odd number of neighboring regions. A basic
example is given below: (Fig. 9.27).
Exercises:
1. Show that all circuit graphs are homeomorphic to C3.
2. Show that K3 is homeomorphic to K2;2.
3. Suppose G1 has v1 vertices and e1 edges and that G2 has v2 vertices and e2
edges and that G1 is homeomorphic to G2. Show that e1  v1 ¼ e2  v2 .
4. If G is Eulerian and H is homeomorphic to G, is H Eulerian?
5. If G is Hamiltonian and H is homeomorphic to G, is H Hamiltonian?
6. Use Kuratowski’s theorem to show that Kn is nonplanar for n  5.
7. Using Kuratowski’s theorem, show that the following graphs are nonplanar
(Fig. 9.28).
Fig. 9.28
Fig. 9.27 A map with its
regions colored with four
colors
9.13
Map Coloring
157

8. Find the dual of the following two graphs (Fig. 9.29).
Fig. 9.29
9. Give an example of a graph G, the dual of whose dual is again G. [Hint:
complete graph K4 is self-dual].
10. If G is a planar graph with n vertices, e edges, f regions, and k components
then prove that n  e þ f ¼ k þ 1.
11. Prove that if G is self-dual (i.e. G and Gare same or isomorphic) with n
vertices and e edges then e ¼ 2n  2.
12. Let G be a connected simple planar graph. Prove that if dðviÞ  5 for all vertex
vi of G, then there are at least 12 vertices of degree 5 in G.
13. If every region of a simple planar graph with n vertices and e edges embedded
in a plane is bounded by k edges, show that e ¼ kðn2Þ
ðk2Þ .
14. Find a simple graph G with degree sequence [4,4,3,3,3,3] such that
(a) G is planar.
(b) G is nonplanar.
15. Show that a set of fundamental circuits in a planar graph G corresponds to a
set of fundamental cut sets in its dual G.
158
9
Planar and Dual Graphs

Chapter 10
Network Flows
Let us consider a network of pipelines of oil, gas, water, and so on. If we consider
the case of network of pipes having values allowing ﬂows only in one direction. It
is important to note that each pipe has capacity. This type of network is repre-
sented by weighted connected graph in which stations are represented by vertices
or nodes and lines through which given item such as oil, gas, water, electricity,
etc., ﬂows through by edges and capacities by weights. We also assume that ﬂow
cannot accumulate at an intermediate level. It is assumed that at each intermediate
vertex, the total rate of commodity entering (in-ﬂow) is equal to the rate of leaving
(out-ﬂow). One most important thing that will arise in many applications, what is
the maximal (or maximum) ﬂow from source vertex (source station) to sink vertex
(destination station) in all these types of transmission network.
10.1 Transport Networks and Cuts
10.1.1 Transport Network
A simple, connected, weighted, digraph (directed graph) G is called a Transport
Network (Flow Network) if the weighted associated with every directed edge in
G is a non-negative number. In a Transport Network, this non-negative number
represents the capacity of the edge and it is denoted by cij for the directed edge (i,
j) in G.
To illustrate, Fig. 10.1 shows a Transport network with source vertex s and sink
vertex t. The ﬂows are shown in Fig. 10.2. In Fig. 10.2, the net ﬂow out of source
s is 10 ? 3 ? 11 = 24 units.
In the maximum-ﬂow problem, we are given a Transport Network or Flow
Network G with source s and sink t, and we wish to ﬁnd a ﬂow of maximum value
from s to t.
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4_10,  Springer India 2013
159

Flow:
In a given Transport Network G, a ﬂow is an assignment of a non-negative
number fij to every directed edge (i, j) such that the following conditions are
satisﬁed:
1. For every directed edge (i, j) in G
fij  cij
ð10:1Þ
This condition implies that ﬂow through any edge does not exceed its capacity.
2. For the source vertex s in G
X
i6¼s
fsi 
X
i6¼s
fis ¼ w
ð10:2Þ
where the above summations are taken over all vertices in G and w is called value
of the ﬂow.
This condition states that the net ﬂow out of the source vertex s is w.
3. For the sink vertex t in G
X
i6¼t
fti 
X
i6¼t
fit ¼ w
ð10:3Þ
This condition states that the net ﬂow into the sink vertex t is w.
Fig. 10.2 A transport
network showing ﬂows and
corresponding capacities of
edges
Fig. 10.1 A transport
network or ﬂow network
160
10
Network Flows

4. All other vertices, apart from source vertex s and sink vertex t, are called
intermediate vertices. For each such intermediate vertex j
X
i6¼j
fij ¼
X
i6¼j
fji
ð10:4Þ
The above condition implies that the ﬂow is conserved at each intermediate vertex.
Saturated edge:
An edge (i, j) is said to be saturated if the ﬂow fij in edge (i, j) is equal to its
capacity cij, i.e. fij = cij.
Flow Pattern:
A set of ﬂows fij for all edge (i, j) in G is called a Flow Pattern.
Maximal Flow Pattern:
A ﬂow pattern that maximizes the quantity w, which is the value of the ﬂow
from source vertex s to sink vertex t, is called a Maximal Flow Pattern.
10.1.2 Cut
A cut is a partition of vertices in G into two non-empty subsets P and P, where
P always contains s and P always contains t. It is usually denoted by P; P


.
Capacity of a Cut:
The capacity of a cut
P; P


, denoted by c P; P


, is deﬁned as the sum of
capacities of those edges directed from the vertices in set P to the vertices in set P.
It is given by
c P; P


¼
X
i 2 P
j 2 P
cij
ð10:5Þ
Theorem 10.1 In a given Transport Network G, the value of the ﬂow w from
source vertex s to sink vertex t is less than or equal to the capacity of any cut in G
that separates source vertex s from sink vertex t.
Proof Let, P; P


be any arbitrary cut in G such that the source vertex s 2 P and
the sink vertex t 2 P.
From Eq. (10.4), for all intermediate vertices j 2 P
X
i6¼j
fji 
X
i6¼j
fij ¼ 0
ð10:6Þ
And from Eq.(10.2), we have
X
i6¼s
fsi 
X
i6¼s
fis ¼ w
ð10:7Þ
10.1
Transport Networks and Cuts
161

Adding Eqs. (10.6) and (10.7), we get
X
k 2 P
i 2 G
fki 
X
k 2 P
i 2 G
fik ¼ w
ð10:8Þ
The Eq. (10.8) can be rewritten as
X
k 2 P
i 2 P
fki þ
X
k 2 P
i 2 P
fki 
X
k 2 P
i 2 P
fik 
X
k 2 P
i 2 P
fik ¼ w
ð10:9Þ
Since, the ﬂow is conserved at each intermediate vertex.
X
k 2 P
i 2 P
fki 
X
k 2 P
i 2 P
fik ¼ 0;
ð10:10Þ
Therefore,
X
k 2 P
i 2 P
fki 
X
k 2 P
i 2 P
fik ¼ w
ð10:11Þ
Since, P
k 2 P
i 2 P
fik is always a non-negative quantity.
We obtain w  P
k 2 P
i 2 P
fki  P
k 2 P
i 2 P
cki ¼ c P; P


. Hence it is proved.
h
10.2 Max-Flow Min-Cut Theorem
Theorem 10.2 In a given Transport Network G, the maximum value of the ﬂow,
from source vertex s and sink vertex t, is equal to the minimum value of the
capacities of all cuts in G that separate source vertex s from sink vertex t. It is
given by
Max w ¼ min f c P; P


j P; P


is any cut in Gg
Proof Using Theorem 10.1, we have
w 
X
k 2 P
i 2 P
fki 
X
k 2 P
i 2 P
cki ¼ c P; P


ð10:12Þ
162
10
Network Flows

We need only to prove that there exists a ﬂow pattern in G from source vertex
s to sink vertex t such that the value of the ﬂow w*, from source vertex s to sink
vertex t, is equal to c P; P



, which is the capacity of some cut c P; P



sepa-
rating source vertex s from sink vertex t.
Let, there be some ﬂow pattern in G such that the value of the ﬂow, from source
vertex s to sink vertex t, attains its maximum possible value w*.
We deﬁne a vertex set P* in G recursively as follows:
1.
s 2 P
2. If vertex i 2 P and either fji \ cij or fji [ 0, then j 2 P: If any vertex not in P*,
then it belongs to P
.
Now, vertex t is always contained in P
. If it can not be contained in P
, then
there would be a path P1 from s to t, say s; v1; v2; . . .; vj; vjþ1; . . .; vr; t for which in
every edge either ﬂow fvjvjþ1\cvjvjþ1 or fvjþ1vj [ 0.
In path P1 an edge (vj, vj+1) directed from vj to vj+1 is interpreted as a forward
edge and an edge (vj+1, vj) directed from vj+1 to vj is interpreted as a backward
edge.
In path P1, let b1 be the minimum of all differences cvjvjþ1  fvjvjþ1 in forward
edges and let, b2 be the minimum of all ﬂows in backward edges. Let
b ¼ min ðb1; b2), since b1 and b2 are positive quantities. Then the ﬂow in the
Network G can be increased by increasing the ﬂow in each forward edge and
decreasing the ﬂow in each backward edge by an amount b. This contradicts the
assumption that w* was the maximum ﬂow.
Thus t must be in the vertex set P
. In other words, the cut P; P



separates
s from t. Again, according to condition (2) for each vertex k in P* and i in P
, we
have fki ¼ cki and fik ¼ 0.
Therefore, from Eq. (10.11), we get the value of the ﬂow as
w ¼
X
k 2 P
i 2 P

fki 
X
k 2 P
i 2 P

fik
¼
X
k 2 P
i 2 P

cki ¼ cðP; P
Þ
Hence, the theorem is proved.
h
Example 10.1 Consider the Transport Network in Fig. 10.3, determine the Max-
imal Flow from source vertex s to sink vertex t.
10.2
Max-Flow Min-Cut Theorem
163

Solution:
There are 3 intermediate vertices between source vertex s and sink vertex t. So,
the given Transport Network has 23 = 8 Cuts that separate source vertex s from
sink vertex t, since there are two ways for each intermediate vertex to be either
included in P or in P:
Sl. no.
Cut P; P


Capacity c P; P


1.
P ¼ fsg; P ¼ fx; y; z; tg
4 ? 1 = 5
2.
P ¼ fs; xg; P ¼ fy; z; tg
1 ? 2 ? 1 = 4
3.
P ¼ fs; yg; P ¼ fx; z; tg
4 ? 4 ? 2 ? 1 = 11
4.
P ¼ fs; zg; P ¼ fx; y; tg
4 ? 2 ? 4 = 10
5.
P ¼ fs; x; yg; P ¼ fz; tg
1 ? 1 ? 2 ? 2 = 6
6.
P ¼ fs; x; zg; P ¼ fy; tg
2 ? 4 = 6
7.
P ¼ fs; y; zg; P ¼ fx; tg
4 ? 4 ? 2 ? 4 = 14
8.
P ¼ fs; x; y; zg; P ¼ ftg
2 ? 4 = 6
The minimum capacity among these Cuts occurs for the Cut (P; P) where
P ¼ fs; xg, P ¼ fy; z; tg. Therefore, according to Max-Flow Min-Cut theorem, the
maximal ﬂow, from source vertex s to sink vertex t, is 4 units.
Example 10.2 Consider the Transport Network in Fig. 10.4, determine the Max-
imal Flow from source vertex s to sink vertex t.
Fig. 10.4 A transport
network
Fig. 10.3 A transport
network
164
10
Network Flows

Solution:
There are 3 intermediate vertices between source vertex s and sink vertex t. So, the
given Transport Network has 23 = 8 Cuts that separate source vertex s from sink
vertex t, since there are two ways for each intermediate vertex to be either included
in P or in P:
Sl. no.
Cut P; P


Capacity c P; P


1.
P ¼ fsg; P ¼ fb; c; d; tg
4 ? 5 = 9
2.
P ¼ fs; bg; P ¼ fc; d; tg
2 ? 5 ? 5 = 12
3.
P ¼ fs; cg; P ¼ fb; d; tg
4 ? 5 ? 6 ? 4 = 19
4.
P ¼ fs; dg; P ¼ fb; c; tg
4 ? 1 ? 2 = 7
5.
P ¼ fs; b; cg; P ¼ fd; tg
5 ? 2 ? 4 = 11
6.
P ¼ fs; b; dg; P ¼ fc; tg
5 ? 2 ? 1 ? 2 = 10
7.
P ¼ fs; c; dg; P ¼ fb; tg
4 ? 6 ? 4 ? 2 = 16
8.
P ¼ fs; b; c; dg; P ¼ ftg
2 ? 4 ? 2 = 8
The minimum capacity among these Cuts occurs for the Cut (P; P) where
P ¼ fs; dg, P ¼ fb; c; tg. Therefore, according to Max-Flow Min-Cut theorem, the
maximal ﬂow, from source vertex s to sink vertex t, is 7 units.
Using Max-Flow Min-Cut Theorem, we can be able to determine the Maximal
ﬂow in the Transport Network from source s to sink t. But it does not explicitly
provide the Maximal ﬂow pattern. Moreover, it becomes cumbersome if the
number of intermediate vertices between s and t is large. Therefore, we need an
efﬁcient method to ﬁnd the Maximal Flow as well as Maximal Flow Pattern. Next,
we present the Ford-Fulkerson method for solving Maximal Flow problem. The
Ford-Fulkerson method is iterative. The Ford-Fulkerson method depends upon
three important factors and these are relevant to many ﬂow algorithms and
problems: residual capacity, residual network, and augmenting path.
10.3 Residual Capacity and Residual Network
10.3.1 Residual Capacity
Given a Transport Network or Flow Network G = (V, E) with source vertex s and
sink vertex t. Consider a pair of vertices u, v in G. The amount of additional net
ﬂow, that can be transferred from u to v without exceeding the capacity c(u, v), is
called the residual capacity of the edge (u, v). It is denoted by cf u; v
ð
Þ and given by
cf u; v
ð
Þ ¼ c u; v
ð
Þ  fðu; vÞ
10.2
Max-Flow Min-Cut Theorem
165

Indeed, the residual capacity cf u; v
ð
Þ of an edge (u, v) must be always non-
negative, i.e. cf u; v
ð
Þ  0. When cf u; v
ð
Þ ¼ 0, the corresponding edge (u, v) is said
to be saturated edge.
10.3.2 Residual Network
Given a Transport Network or Flow Network G = (V, E) and a ﬂow f. The
residual network of G induced by f is Gf ¼ ðV; Ef Þ, where
Ef ¼
u; v
ð
Þ 2 V  Vjcf u; v
ð
Þ [ 0 and ðu; vÞ 2 E


Clearly,
V G
ð Þ ¼ VðGf Þ and Ef  E. So, Gf is a spanning subgraph of G. Of course, the
graph G is itself residual network, since it is spanning subgraph of itself.
Augmenting Path:
An augmenting path P is a simple path from source vertex s to sink vertex t in
the residual network Gf.
Residual Capacity of Augmenting Path:
The maximum amount of net ﬂow that can be transferred along the edges of an
augmenting path P is called the residual capacity of augmenting path P. It is
denoted by cf(P) and given by
cf P
ð Þ ¼ min cf u; v
ð
Þj u; v
ð
Þ is an edge on P


10.4 Ford-Fulkerson Algorithm
Initial Step:
For each edge ðu; vÞ 2 EðGÞ,
Set f u; v
ð
Þ ¼ 0
Step 1:
While there exists an augmenting path P from source vertex s to sink vertex t in
the residual network Gf then
Compute
cf P
ð Þ ¼ min cf u; v
ð
Þj u; v
ð
Þ is an edge on P


Step 2:
For each edge (u, v) on augmenting path P
Set f u; v
ð
Þ ¼ f u; v
ð
Þ þ cf P
ð Þ
Step 3:
If there exists no an augmenting path P from source vertex s to sink vertex t in
the residual network Gf, then Stop. Otherwise, go to Step 1.
h
166
10
Network Flows

At each iteration, we increase the ﬂow value by ﬁnding an ‘‘augmenting path’’,
along which we can send more ﬂow and then augmenting the ﬂow along this path.
We repeat this procedure until no augmenting path can be found.
The value of the maximal ﬂow will be
X
cf Pi
ð
Þ; for all Pi 2 Maximal flow pattern
where
Maximal flow pattern ¼ PijPi is an augmenting path in residual network
f
g
10.5 Ford-Fulkerson Algorithm with Modiﬁcation
by Edmonds-Karp
10.5.1 Time Complexity of Ford-Fulkerson Algorithm
The Ford Fulkerson Method does not specify how to ﬁnd the augmenting paths.
For example, we can use either BFS or DFS to ﬁnd the augmenting paths. In fact,
without further knowledge on how to ﬁnd the augmenting path, the best bound we
have on the time complexity is Oð E
j j  f Þ, where |E| is the number of edges in the
graph and f* is the maximum ﬂow. This is based on the observation that it takes
O(|E|) time to ﬁnd an augmenting path and every augmenting path increases the
ﬂow by at least 1. Finally, it should be noted that the Ford Fulkerson Method does
not guarantee that it will terminate—there are some special cases involving irra-
tional capacity where we will keep ﬁnding augmenting path with smaller capac-
ities. However, if it does terminate (as it will in the case of integer capacities), it
will return the correct answer. If we use BFS to ﬁnd the augmenting path, then it is
known as the Edmonds-Karp Algorithm.
10.5.2 Edmonds-Karp Algorithm
This algorithm is a variation on the Ford-Fulkerson method which is intended to
increase the speed of the ﬁrst algorithm. The idea is to try to choose good aug-
menting paths. In this algorithm, the augmenting path suggested is the augmenting
path with the minimum number of edges [We can ﬁnd this using Breadth First
Search (BFS)]. The bound on Ford-Fulkerson method can be improved if we
implement the computation of the augmenting path in Ford-Fulkerson method with
BFS, i.e. if the augmenting path is a shortest path from source vertex s to sink
vertex t in the residual network Gf. The total number of iterations of the algorithm
using this strategy is O(|V||E|). Thus, its running time is O(|V||E|2). we can actually
prove that the algorithm will terminate in O(|V||E|2) time, a much tighter bound
than what we have before.
10.4
Ford-Fulkerson Algorithm
167

Example 10.3 Using Ford-Fulkerson Algorithm, ﬁnd the maximal ﬂow of the
following Transport Network in Fig. 10.5.
Solution:
Initially, we assign zero ﬂow to every edge in the given Transport Network.
The ﬁrst residual network is the original Transport Network itself. We need to
ﬁnd the augmenting path from source vertex 1 to sink vertex 6. According to
Edmonds-karp algorithm, the augmenting path is the shortest path using BFS from
1 to 6 (Fig. 10.6).
The Breadth First Tree:
Therefore, the augmenting path, which is the shortest path obtained by BFS, is P1:
1–2–4–6. The residual capacity of this path is cf (P1) = 12. Augmenting the above
path by pushing 12 units of ﬂow along the path, the following augmented network
and the corresponding residual network have been obtained in Fig. 10.7. In
residual network, the residual capacity of an edge from node u to node v is simply
its unused capacity which is the difference between its capacity and its ﬂow. It is
shown in the direction of the edge. In the opposite direction from v to u, the value
indicates the ﬂow of the edge (Fig. 10.7).
Fig. 10.5 A transport network
Fig. 10.6 Breadth First Tree
168
10
Network Flows

Again, we ﬁnd the augmenting path from source vertex 1 to sink vertex 6 in the
residual network of Fig. 10.7. According to Edmonds-Karp algorithm, the aug-
menting path is the shortest path using BFS from 1 to 6.
The Breadth First Tree:
Here, the augmenting path, which is the shortest path obtained by BFS, is P2: 1–
3–5–6. The residual capacity of this path is cf(P2) = 4. So, pushing 4 units of ﬂow
along the path, the following augmented network and the corresponding residual
network have been obtained in Fig. 10.9.
Fig. 10.7 Augmented network and its corresponding residual network
Fig. 10.8 Breadth First Tree
10.5
Ford-Fulkerson Algorithm with Modiﬁcation by Edmonds-Karp
169

Next, we again ﬁnd the augmenting path using BFS from 1 to 6 in the residual
network of Fig. 10.9. The following Fig. 10.10 shows the Breadth First Tree
obtain by BFS.
The Breadth First Tree:
Now, the augmenting path, which is the shortest path obtained by BFS, is P3: 1–3–
5–4–6. The residual capacity of this path is cf(P3) = 7. After, pushing 7 units of
ﬂow along the path, the following augmented network and the corresponding
residual network have been obtained in Fig. 10.11.
Fig. 10.9 Augmented network and its corresponding residual network
Fig. 10.10 Breadth First
Tree
170
10
Network Flows

At this stage, there are no more shortest paths from 1 to 6. So, there exists no
augmenting path from 1 to 6 in the residual network of Fig. 10.11. Consequently,
the algorithm stops executing.
Therefore, the Maximal ﬂow is cf P1
ð
Þ þ cf P2
ð
Þ þ cf P3
ð
Þ ¼ 12 þ 4 þ 7 ¼ 23
units. The corresponding Maximal ﬂow pattern is
P1; P2; P3
f
g.
h
Now, the above value for Maximal ﬂow can be veriﬁed in the following way.
Let us consider the set of vertices that are reachable from source 1 in the residual
network of Fig. 10.11. This set includes vertices 2, 3 and 5. Now, we consider the
cut
P; P


, where P ¼ 1; 2; 3; 5
f
g, P contains those vertices which are reachable
from source 1 and P ¼ 4; 6
f
g. From Fig. 10.5, the capacity of this cut is
12 ? 7 ? 4 = 23, which is the required Maximal Flow. Hence, it is veriﬁed.
Example 10.4 Using Ford-Fulkerson Algorithm, ﬁnd the maximal ﬂow of the
following Transport Network in Fig. 10.12.
Fig. 10.11 Augmented network and its corresponding residual network
Fig. 10.12 A transport
network
10.5
Ford-Fulkerson Algorithm with Modiﬁcation by Edmonds-Karp
171

Solution:
Initially, we assign zero ﬂow to all edges in the given Transport Network.
The ﬁrst residual network is the original Transport Network itself. We need to ﬁnd
the augmenting path from source vertex s to sink vertex t. According to Edmonds-karp
algorithm, the augmenting path is the shortest path using BFS from s to t (Fig. 10.13).
The Breadth First Tree:
Therefore, the augmenting path, which is the shortest path obtained by BFS, is
P1 : s  x  t. The residual capacity of this path is cf P1
ð
Þ ¼ 2. Augmenting the
above path by pushing 2 units of ﬂow along the path, the following augmented
network and the corresponding residual network have been obtained in Fig. 10.14.
In residual network, the residual capacity of an edge from node u to node v is
Fig. 10.13 Breadth First
Tree
Fig. 10.14 Augmented
network and its
corresponding residual
network
172
10
Network Flows

shown in the direction of the edge. In the opposite direction from v to u, the value
indicates the ﬂow of the edge (Fig. 10.14).
Again, we ﬁnd the augmenting path from source vertex s to sink vertex t in the
residual network of Fig. 10.14.
The Breadth First Tree:
Here, the augmenting path, which is the shortest path obtained by BFS, is
P2 : s  z  t. The residual capacity of this path is cf P2
ð
Þ ¼ 1. So, pushing 1 unit
of ﬂow along the path, the following augmented network and the corresponding
residual network have been obtained in Fig. 10.16.
Fig. 10.15 Breadth First
Tree
Fig. 10.16 Augmented
network and its
corresponding residual
network
10.5
Ford-Fulkerson Algorithm with Modiﬁcation by Edmonds-Karp
173

Next, we again ﬁnd the augmenting path using BFS from s to t in the residual
network of Fig. 10.16. The following Fig. 10.17 shows the Breadth First Tree
obtain by BFS.
The Breadth First Tree:
Now, the augmenting path, which is the shortest path obtained by BFS, is
P3 : s  x  z  t. The residual capacity of this path is cf P3
ð
Þ ¼ 1. After, adding 1
unit of ﬂow along the path, the following augmented network and the corre-
sponding residual network have been obtained in Fig. 10.18.
Fig. 10.17 Breadth First
Tree
Fig. 10.18 Augmented
network and its
corresponding residual
network
174
10
Network Flows

At this stage, there are no more shortest paths from s to t. So, there exists no
augmenting path from s to t in the residual network of Fig. 10.18. Consequently,
the algorithm halts.
Therefore, the Maximal ﬂow is cf P1
ð
Þ þ cf P2
ð
Þ þ cf P3
ð
Þ ¼ 2 þ 1 þ 1 ¼ 4
units. The corresponding Maximal ﬂow pattern is
P1; P2; P3
f
g.
h
Let us consider the set of vertices that are reachable from source s in the
residual network of Fig. 10.18. This set includes only vertex x. Now, we consider
the cut
P; P


, where P ¼ s; x
f
g, P contains those vertices which are reachable
from source s and P ¼ fy; z; tg. From Fig. 10.12, the capacity of this cut is
2 ? 1 ? 1 = 4, which is the required Maximal Flow obtained in example 10.1.
Hence, it is veriﬁed with the Max-Flow Min-Cut result.
10.6 Maximal Flow: Applications
10.6.1 Multiple Sources and Sinks
This can be converted to a single source, single sink situation, so far discussed
above, by introducing
1. a new vertex s0 (super source or dummy source) from which there is an edge to
each source, capacity of the new edges is ?.
2. a new vertex t0 (super sink or dummy sink). There is an edge from each target to
t0, capacity of the new edges is ? (Fig. 10.19).
10.6.2 Maximum Bipartite Matching
Consider the problem, we have n people and m jobs. We know what jobs can be
done by which person.
Our problem is to ﬁnd a job assignment of at most one job to one person so that
the maximal number of jobs done. This can be represented by a bipartite graph.
Fig. 10.19 Transport network with multi-source and multi-sink
10.5
Ford-Fulkerson Algorithm with Modiﬁcation by Edmonds-Karp
175

Bipartite Graph:
• Suppose we have a set of people L ¼ p1; p2; p3; p4
f
g and set of jobs
R ¼ j1; j2; j3; j4; j5
f
g.
• Each person can do only some of the jobs.
• This problem can be model in the following bipartite graph as shown in
Fig. 10.20a.
An Optimal Job Assignment is equivalent to Maximum Bipartite Matching
problem.
Bipartite Matching:
(i) A matching gives an assignment of people to tasks.
(ii) We wish to get as many tasks done as possible.
(iii) So, we need a maximum matching: one that contains as many edges as
possible.
This problem can be converted into a maximal ﬂow problem.
We introduce a source connected to all persons and a sink connected to all jobs
with all capacities 1, shown in Fig. 10.20b.
There is an integral solution of the ﬂow giving maximal matching.
Exercises:
1. Apply Ford-Fulkerson Algorithm with modiﬁcation by Edmonds-Karp to ﬁnd
the maximal ﬂow for the following network in Fig. 10.21.
Fig. 10.20 (a) Bipartite graph showing Bipartite matching, (b) Bipartite matching transferred
into maximal network ﬂow problem
176
10
Network Flows

Fig. 10.21
2. Apply Edmonds-Karp Algorithm to ﬁnd the maximal ﬂow from source s to sink
t for the following networks (Fig. 10.22).
Fig. 10.22
3. Use Ford-Fulkerson Algorithm to ﬁnd the maximal ﬂow from source s to sink
t for the following network. Find a cut with capacity equal to this maximal ﬂow
(Fig. 10.23).
10.6
Maximal Flow: Applications
177

Fig. 10.23
4. Find all possible
P; P


cuts in the transport network shown in Fig. 10.22a.
Hence, determine the maximal ﬂow using Max-Flow Min-Cut Theorem.
5. Show that a maximum ﬂow in a network G ¼ ðV; EÞ can always be found by a
sequence of at most |E| augmenting paths.
178
10
Network Flows

179
S. Saha Ray, Graph Theory with Algorithms and its Applications,
DOI: 10.1007/978-81-322-0750-4,  Springer India 2013
Appendix
C++ Program 1: The Dijkstra’s Algorithm has been implemented in the following 
C++ program.
DIJKSTRA.CPP
#include<iostream.h>
#include<fstream.h>
#include<conio.h>
#include<math.h>
#define START 1  // Starting vertex
#define END 6    // Ending vertex
#define P 1   // Permanent
#define T 0   // Temporary
#define INFINITY 9999
ifstream in("dijk_in.txt");
ofstream out("Dij_Out.txt");
struct node
{
double label;       // label of the vertex
int status;         // status of the vertex P or T
int pred;           // Predecessor of the vertex
}
vertex[50];        // vertex array with three attributes
double a[50][50];   // Weight matrix for the edges
int n;              // number of vertices
int e;              // number of edges
main()
{

Appendix
180
int i,j,u,v;
int path[50];
double d;
double dijkstra(int s,int t);
void short_path(int v);
clrscr();
in>>n>>e;
 out<<"The number of vertices: "<<n<<endl;
 out<<"The number of edges: "<<e<<endl;
for(u=0;u<=n;u++)
 for(v=0;v<=n;v++)
   a[u][v]=INFINITY;
do
{
in>>u>>v>>d;
a[u][v]=d;
}
while(!in.eof());
in.close();
out<<"\nThe Adjacency matrix(Weight matrix):"<<endl;
     for(i=1;i<=n;i++)
{
      for(j=1;j<=n;j++)
	
out<<a[i][j]<<"  ";
	
out<<endl;
	
}
if(dijkstra(START,END))
{
out<<"\nThe shortest distance from "<<START<<" to "<<END<<" : 
"<<dijkstra(START,END)<<endl;
out<<"\nThe shortest path : ";
     short_path(END);
}
else
out<<"There is no path:"<<"\n";
cin.get();
return 0;
}
double dijkstra(int s,int t)
{
int i,j,k;
double min;
for(j=1;j<=n;j++)
{
vertex[j].label=INFINITY;

Appendix
181
vertex[j].status=T;
  }
vertex[s].label=0;
vertex[s].status=P;
vertex[s].pred=0;
k=s;
do
{
for(j=1;j<=n;j++)
{
if((vertex[j].status==T)&&(a[k][j]!=INFINITY))
{
  if(vertex[j].label>vertex[k].label+a[k][j])
{
       vertex[j].label=vertex[k].label+a[k][j];
       vertex[j].pred=k;
	
 }
       }
     }
  k=0;
  min=INFINITY;
  for(i=1;i<=n;i++)
{
    if((vertex[i].status==T)&&(vertex[i].label<min))
{
	
min=vertex[i].label;
	
k=i;
	
}
      }
	
vertex[k].status=P;
    if(k==0)
      return(0);
 }
while(k!=t);
    return(vertex[t].label);
  }
  void short_path(int v)
{
    int a,i,u,l=0;
    int pred[50];
    static int path[50];   // Shortest Path array
    u=v;
   for(u=END;u!=0;u=vertex[u].pred)

Appendix
182
	
path[++l]=u;
    for(i=l;i>1;i--)
    out<<path[i]<<"->";
       out<<END;
     }
Example 1: Consider the network as shown in Fig. 5.1. In the above program, the 
input stream read data from input file “dijk_in.txt” and output stream write data 
to a output file “DIJ_OUT.TXT”.   The first line of the input file “dijk_in.txt” is the 
number of vertices and edges. The rest is the adjacency matrix or distance matrix 
of the network shown in Fig. 5.1. 
dijk_in.txt
6 9
1 2 18
1 4 15
2 3 9
3 6 28
4 2 6
4 3 14
4 5 7
5 3 10
5 6 36
After the execution of the program “DIJKSTRA.CPP”, the following output file 
“DIJ_OUT.TXT” is generated. The output shows the shortest route from the start­
ing vertex 1 to the ending vertex 6.
DIJ_OUT.TXT
The number of vertices: 6
The number of edges: 9
The Adjacency matrix(Weight matrix):
9999  18  9999  15  9999  9999  
9999  9999  9  9999  9999  9999  
9999  9999  9999  9999  9999  28  
9999  6  14  9999  7  9999  
9999  9999  10  9999  9999  36  
9999  9999  9999  9999  9999  9999  

Appendix
183
The shortest distance from 1 to 6 : 55
The shortest path : 1->2->3->6
C++ Program 2: The Floyd’s Algorithm has been implemented in the following C++ 
program.
FLOYD.CPP
#include <iostream.h>
#include <fstream.h>
#include <conio.h>
#include <stdio.h>
ifstream in("floyd.txt");
ofstream out("fld_out.txt");
float d[50][50];     // Distance Matrix
int s[50][50];       // Node Sequence Matrix
main()
{
float dist;
int n;  // number of vertices
int u,v,i,j,k;
char ch;
void floyd(int n);
void short_path(int,int);
clrscr();
 in>>n;
 out<<n<<endl;
for(i=1;i<=n;i++)
  for(j=1;j<=n;j++)
      s[i][j]=0;
      for(i=1;i<=n;i++)
	
for(j=1;j<=n;j++)
	
  if(i!=j)
	
   d[i][j]=9999;
	
  else
	
   d[i][j]=0;
       while(!in.eof())
	
      {
	
in>>i>>j>>dist;
	
d[i][j]=dist;
	
      }

Appendix
184
	
    in.close();
   out<<"\nThe Adjacency matrix(Weight matrix):"<<endl;
     for(i=1;i<=n;i++)
{
      for(j=1;j<=n;j++)
	
out<<d[i][j]<<"  ";
	
out<<endl;
	
}
floyd(n);
do
{
cout<<"Enter the vertices:";
cin>>u>>v;
out<<"\nThe Shortest Distance from "<<u<<" to "<<v<<": "<<d[u][v]<<endl;
out<<"\nThe Shortest Path: ";
out<<u;
short_path(u,v);
out<<"->"<<v<<endl;
cout<<"\nPress ENTER to continue..."<<endl;
cout<<"\nOtherwise press any key to quit..."<<endl;
cin.sync();
}
while(cin.get()=='\n');
return 0;
}
void floyd(int n)
{
int i,j,k;
   for(k=1;k<=n;k++)
{
     out<<"-----------------------------------------"<<endl;
     out<<"Step:"<<k<<endl;
     for(i=1;i<=n;i++)
      for(j=1;j<=n;j++)
      if(i!=k && j!=k && i!=j)
	
  if(d[i][j]>d[i][k]+d[k][j])
                 {
	
     d[i][j]=d[i][k]+d[k][j];
	
     s[i][j]=k;
	
	
}
     out<<"\nDistance Matrix"<<endl;
       for(i=1;i<=n;i++)
{

Appendix
185
	
for(j=1;j<=n;j++)
	
 out<<d[i][j]<<"  ";
	
 out<<endl;
	
    }
     out<<"\nNode Sequence Matrix"<<endl;
       for(i=1;i<=n;i++)
{
	
for(j=1;j<=n;j++)
	
 out<<s[i][j]<<"  ";
	
 out<<endl;
	
    }
	
  }  //end of k loop
	
   out<<"-----------------------------------------"<<endl;
      }
void short_path(int i,int j)
{
int k;
k=s[i][j];
if(k!=0)
{
  short_path(i,k);
  out<<"->"<<k;
  short_path(k,j);
    }
}
Example 2: Consider the network as shown in Fig. 5.6. In the above program, the 
input stream is used to read data from input file “floyd.txt” and output stream is 
used to write data to a output file “FLD_OUT.TXT”.   The first line of the input file 
“floyd.txt” is the number of vertices. The rest is the adjacency matrix or distance 
matrix of the network shown in Fig. 5.6. 
floyd.txt
5
1 2 8
2 1 8
2 5 5
5 2 5
3 2 1
2 3 2
1 3 3
1 4 5

Appendix
186
4 1 6
3 4 3
4 5 7
3 5 4
After the execution of the program “FLOYD.CPP”, the following output file 
“FLD_OUT.TXT” is generated. The output shows the shortest routes from node 1 
to node 5, node 4 to node 2, node 5 to node 4 and node 4 to node 3.
FLD_OUT.TXT
5
The Adjacency matrix(Weight matrix):
0  8  3  5  9999  
8  0  2  9999  5  
9999  1  0  3  4  
6  9999  9999  0  7  
9999  5  9999  9999  0  
-----------------------------------------
Step:1
Distance Matrix
0  8  3  5  9999  
8  0  2  13  5  
9999  1  0  3  4  
6  14  9  0  7  
9999  5  9999  9999  0  
Node Sequence Matrix
0  0  0  0  0  
0  0  0  1  0  
0  0  0  0  0  
0  1  1  0  0  
0  0  0  0  0  
-----------------------------------------
Step:2
Distance Matrix
0  8  3  5  13  
8  0  2  13  5  
9  1  0  3  4  
6  14  9  0  7  
13  5  7  18  0  

Appendix
187
Node Sequence Matrix
0  0  0  0  2  
0  0  0  1  0  
2  0  0  0  0  
0  1  1  0  0  
2  0  2  2  0  
-----------------------------------------
Step:3
Distance Matrix
0  4  3  5  7  
8  0  2  5  5  
9  1  0  3  4  
6  10  9  0  7  
13  5  7  10  0  
Node Sequence Matrix
0  3  0  0  3  
0  0  0  3  0  
2  0  0  0  0  
0  3  1  0  0  
2  0  2  3  0  
-----------------------------------------
Step:4
Distance Matrix
0  4  3  5  7  
8  0  2  5  5  
9  1  0  3  4  
6  10  9  0  7  
13  5  7  10  0  
Node Sequence Matrix
0  3  0  0  3  
0  0  0  3  0  
2  0  0  0  0  
0  3  1  0  0  
2  0  2  3  0  
-----------------------------------------
Step:5
Distance Matrix
0  4  3  5  7  
8  0  2  5  5  

Appendix
188
9  1  0  3  4  
6  10  9  0  7  
13  5  7  10  0  
Node Sequence Matrix
0  3  0  0  3  
0  0  0  3  0  
2  0  0  0  0  
0  3  1  0  0  
2  0  2  3  0  
-----------------------------------------
The Shortest Distance from 1 to 5: 7
The Shortest Path: 1->3->5
The Shortest Distance from 4 to 2: 10
The Shortest Path: 4->1->3->2
The Shortest Distance from 5 to 4: 10
The Shortest Path: 5->2->3->4
The Shortest Distance from 4 to 3: 9
The Shortest Path: 4->1->3
C++ Program 3: The Breadth First Search Algorithm has been implemented in the 
following C++ program. This program uses two data structures to implement the 
Breadth First Traversal: a color marker for each vertex and a queue. In the begin­
ning all vertices are coloured white. White vertices are undiscovered vertices not 
yet in the queue. We will colour the vertices gray when we enqueue(add to the 
end of the queue) them. The gray vertices are discovered but have undiscovered 
adjacent vertices. We will colour the vertices black when we dequeue(remove 
from the front of the queue) them. The black vertices are discovered and are 
adjacent to only other black or gray vertices. While the queue is not empty, we 
run the loop of the Breadth First Search. The algorithm proceeds by removing a 
vertex u from the queue and examining each out-edge (u,v). If an adjacent vertex 
v is not already discovered, it is colored gray and placed in the queue. After all 
of the out-edges are examined, vertex u is colored black and deleted from the 
queue. This process is repeated. After the loop has finished, all nodes reachable 
from the starting vertex are black. The unreachable vertices are still white.

Appendix
189
BFS.CPP
#include <iostream.h>
#include <fstream.h>
#include <conio.h>
//Basic Definitions
#define WHITE 0
#define GRAY 1
#define BLACK 2
#define MAX_NODES 100
#define INFINITY 9999
#define START 1
#define END 6
//Declarations
int n;  // number of nodes
int e;  // number of edges
int ad[MAX_NODES][MAX_NODES]; // adjacency matrix
int color[MAX_NODES]; // needed for breadth-first search
int pred[MAX_NODES];  // array to store shortest path
int k;  // level
    ifstream in("BFS.TXT");
    ofstream out("BFS_OUT.TXT");
//A Queue for Breadth-First Search
int head,tail;
int q[MAX_NODES+2];
void bfs (int start, int target);
void enqueue (int x) 
{
    q[tail] = x;
    tail++;
}
int dequeue () 
{
    int x = q[head];
    head++;
    return x;
}
//Breadth-First Search

Appendix
190
void bfs (int start, int target)
 {
  void short_path(int,int);
    int u,v;
    for (u=1; u<=n; u++) 
{
	
color[u] = WHITE;
    }
    head = tail = 0;
    k=0;
    enqueue(start);
    pred[start] = -1;
    while (head!=tail) 
{
	
u = dequeue();
	
// Search all adjacent white nodes v.
	
// enqueue v.
	
for (v=1; v<=n; v++) 
{
	
    if (color[v]==WHITE && ad[u][v]>0) 
{
	
	
color[v] = GRAY;
	
	
pred[v] = u;
	
	
enqueue(v);
	
	
	
 }
	
	
    }
	
       color[u]=BLACK;
	
       out<<u<<" ";
	
	
       }
	
       out<<"\n";
    // If the color of the target node is black now,
    // it means that we reached it.
   if(color[target]==BLACK)
{
     short_path(END,0);
     out<<endl;
	
    }
}
//Reading the input file and the main program
void read_input_file() 
{

Appendix
191
    int a,b,c,i,j;
    // read number of nodes and edges
     in>>n>>e;
     out<<"The number of nodes: "<<n<<endl;
     out<<"\nThe number of edges: "<<e<<endl;
    // initialize empty adjacency matrix
    for (i=1; i<=n; i++) 
{
	
for (j=1; j<=n; j++)
 {
	
    ad[i][j] = 0;
	
}
    }
    // read adjacency matrix
    while(!in.eof())
{
    for (i=0; i<e; i++) 
{
    in>>a>>b>>c;
	
ad[a][b] = c;
	
}
    }
    in.close();
     out<<"\nThe Adjacency matrix:"<<endl;
     for(i=1;i<=n;i++)
{
      for(j=1;j<=n;j++)
	
out<<ad[i][j]<<"  ";
	
out<<endl;
	
}
}
int main () 
{
    clrscr();
    read_input_file();
    out<<"\n"<<"The Breadth First Traversal: ";
    bfs(START,END);
    getch();
    return 0;
}

Appendix
192
void short_path(int t,int l)
{
 int i,u,v;
 static int path[50];
 v=t;
 u=pred[v];
 path[l++]=u;
if(u!=START)
 short_path(u,l);
else
  {
  out<<"\nThe shortest Distance: "<<l<<endl;
  out<<"\nThe shortest Path: ";
 for(i=l-1;i>=0;i--)
  out<<path[i]<<"->";
  out<<END;
    }
  }
Example 3: Consider the graph as shown in Fig. 5.15. In the above program, the 
input stream read data from input file “bfs.txt” and output stream write data to a 
output file “BFS_OUT.TXT”.   The first line of the input file “bfs.txt” is the number 
of vertices and edges. The rest is the adjacency matrix of the graph shown in Fig. 
5.15. 
bfs.txt
8 10
1 2 1
2 1 1
2 3 1
3 2 1
2 4 1
4 2 1
3 4 1
4 3 1
3 5 1
5 3 1
4 5 1
5 4 1
4 6 1
6 4 1

Appendix
193
4 7 1
7 4 1
6 8 1
8 6 1
1 8 1
8 1 1
After the execution of the program “BFS.CPP”, the following output file “BFS_OUT.
TXT” is produced. The following output shows the shortest path as well as dis­
tance from vertex 1 to vertex 6.
BFS_OUT.TXT
The number of nodes: 8
The number of edges: 10
The Adjacency matrix:
0  1  0  0  0  0  0  1  
1  0  1  1  0  0  0  0  
0  1  0  1  1  0  0  0  
0  1  1  0  1  1  1  0  
0  0  1  1  0  0  0  0  
0  0  0  1  0  0  0  1  
0  0  0  1  0  0  0  0  
1  0  0  0  0  1  0  0  
The Breadth First Traversal: 1 2 8 3 4 6 5 7 
The shortest Distance: 2
The shortest Path: 1->8->6
C++ Program 4: The Prim’s Algorithm has been also implemented in the follow­
ing C++ program. Prim’s algorithm is a greedy algorithm that finds the minimum 
spanning tree of a graph.  

Appendix
194
PRIM.CPP
#include<iostream.h>
#include<fstream.h>
#include<conio.h>
ifstream in("Prim.txt");
ofstream out("Prim_Out.txt");
int Prim(int wt[50][50],int n)
	
     {
int visited[50]={0},min=9999,minwt=0;
int a,b,u,v,i,j,w;
int ne=0;    //number of edges in minimum spanning tree
     visited[1]=1;
     while(ne!=n-1)
    {
       for(i=1,min=9999;i<=n;i++)
	
for(j=1;j<=n;j++)
	
  if(wt[i][j]<min)
	
     if(visited[i]==1 && visited[j]==0)
	
     {
	
     min=wt[i][j];
	
     a=u=i;
	
     b=v=j;
	
     }
    if(visited[u]==0 || visited[v]==0)
    {
    out<<"\n"<<++ne<<". Edge"<<"  ("<<a<<","<<b<<") "<<"Weight "<<min<<endl;
    minwt+=min;
    visited[b]=1;
    }
    }
    return(minwt);
}
void main()
{
int Prim(int wt[50][50],int n);
int i,j;
int n;            // number of vertices
int wt[50][50];   // weight of the edges
int w;
int minwt;        // minimum weight
clrscr();
in>>n;

Appendix
195
out<<"The number of Vertices:"<<n<<endl;
for(i=1;i<=n;i++)
 for(j=1;j<=n;j++)
     wt[i][j]=9999;
     while(!in.eof())
    {
       in>>i>>j>>w;
       if(w==0)
       wt[i][j]=9999;
       else
       wt[i][j]=w;
       }
     in.close();
	
out<<"\nThe Adjacency matrix(Weight matrix):"<<endl;
     for(i=1;i<=n;i++)
{
      for(j=1;j<=n;j++)
	
out<<wt[i][j]<<"  ";
	
out<<endl;
	
}
	
out<<"\nThe Spanning Tree contains the following Edges:"<<endl;
    minwt=Prim(wt,n);
    out<<"\nMinimum Weight="<<minwt<<endl;
    cin.get();
    }
Example 4: Consider the graph as shown in Fig. 5.11. In the above program, the 
input stream read data from input file “prim.txt” and output stream write data 
to a output file “PRIM_OUT.TXT”.   The first line of the input file “prim.txt” is the 
number of vertices. The rest is the adjacency matrix or weight matrix of the graph 
shown in Fig. 5.11. 
prim.txt
6
1 1 0
1 2 2
1 3 4
2 1 2
2 2 0
2 3 7
2 4 11 
3 1 4

Appendix
196
3 2 7
3 3 0
3 4 8
3 6 1
4 2 11
4 3 8
4 4 0
4 5 6
5 4 6
5 5 0
5 6 9
6 3 1
6 5 9
6 6 0
After the execution of the program “PRIM.CPP”, the following output file 
“PRIM_OUT.TXT” is produced. The following output shows the Minimum 
Spanning Tree with Minimum Weight.
PRIM_OUT.TXT
The number of Vertices:6
The Adjacency matrix(Weight matrix):
9999  2  4  9999  9999  9999  
2  9999  7  11  9999  9999  
4  7  9999  8  9999  1  
9999  11  8  9999  6  9999  
9999  9999  9999  6  9999  9  
9999  9999  1  9999  9  9999  
The Spanning Tree contains the following Edges:
1. Edge  (1,2) Weight 2
2. Edge  (1,3) Weight 4
3. Edge  (3,6) Weight 1
4. Edge  (3,4) Weight 8
5. Edge  (4,5) Weight 6
Minimum Weight=21

Appendix
197
C++ Program 5: The Kruskal’s Algorithm has been also implemented in the fol­
lowing C++ program. This program of Kruskal’s algorithm for ﬁnding a minimum 
spanning tree uses a data structure for maintaining a collection of disjoint sets. 
It supports the following three operations:
• makeset(x) -  create a new set containing the single element x.
• merge(x,y) - replace the two sets containing x and y by their union.
• find(x) - returns the representative of the set containing x.
KRUSKAL.CPP
#include<iostream.h>
#include<fstream.h>
#include<conio.h>
#define MAX 100
ifstream in("krus_in.txt");
ofstream out("Krus_Out.txt");
struct edge_info
  {
    int u, v, weight;
  } 
edge[MAX];
int wt[MAX][MAX];
int tree[MAX][3], set[MAX];
int n;
int readedges();
void makeset();
int find(int);
void merge(int, int);
void arrange_edges(int);
void spanningtree(int);
int readedges()
{
	
int i, j, k, w;
	
k = 1;
	
out << "\nThe number of Vertices in the Graph : ";
	
in>>n;
	
out<<n<<endl;
     for(i=1;i<=n;i++)
      for(j=1;j<=n;j++)
	
wt[i][j]=9999;
     while(!in.eof())

Appendix
198
{
       in>>i>>j>>w;
       edge[k].u = i;
       edge[k].v = j;
       if(w==0)
       {
       wt[i][j]=9999;
	
 }
       else
	
 {
       if(j>i)
       edge[k++].weight=w;
       wt[i][j]=w;
	
 }
       }
     in.close();
    out<<"\nThe Adjacency matrix(Weight matrix):\n"<<endl;
     for(i=1;i<=n;i++)
{
      for(j=1;j<=n;j++)
	
out<<wt[i][j]<<"  ";
	
out<<endl;
	
}
	
return (k - 1);
}
void makeset()
{
	
int i;
	
for (i = 1; i <= n; i++)
	
	
set[i] = i;
}
int find(int vertex)
{
	
return (set[vertex]);
}
void merge(int v1, int v2)
{
	
int i, j;
	
if (v1 < v2)

Appendix
199
	
	
set[v2] = v1;
	
else
	
	
set[v1] = v2;
}
// sort set of edges in non-decreasing order by weight(applying bubblesort)
void arrange_edges(int k)
{
	
int i, j;
	
struct edge_info temp;
	
for (i = 1; i < k; i++)
	
	
for (j = 1; j <= k - i; j++)
	
	
	
if (edge[j].weight > edge[j + 1].weight)
	
	
	
{
	
	
	
	
temp = edge[j];
	
	
	
	
edge[j] = edge[j + 1];
	
	
	
	
edge[j + 1] = temp;
	
	
	
}
}
void spanningtree(int k)
{
	
int i, t, sum;
	
arrange_edges(k);
	
t = 1;
	
sum = 0;
	
out<<"\nThe sorted set of edges in non-decreasing order by weight(after 
applying bubblesort)"<<endl;
	
for (i=1;i<=k;i++)
{
	
out<<edge[i].u<<" "<<edge[i].v<<" "<<edge[i].weight<<endl;
	
}
	
cin.get();
	
for (i = 1; i < k; i++)
	
	
if (find (edge[i].u) != find (edge[i].v))
	
	
{
	
	
	
tree[t][1] = edge[i].u;
	
	
	
tree[t][2] = edge[i].v;
	
	
	
tree[t][3] = edge[i].weight;
	
	
	
merge(edge[t].u, edge[t].v);
	
	
	
t++;
	
	
}
	
out << "\nThe Edges of the Minimum Spanning Tree are\n\n";

Appendix
200
	
for (i = 1; i < n; i++)
{
	
	
out <<i<<". "<<"Edge "<<tree[i][1] << " - " << tree[i][2] <<" 
Weight: "<<tree[i][3]<<endl;
	
	
sum+=tree[i][3];
	
	
}
	
	
out << "\nThe Weight of the Minimum Spanning Tree is : " << 
sum;
}
int main()
{
	
int num_edge;     /* number of edges in minimum spanning tree */
        int min_weight;   /* weight of minimal spanning tree */
	
clrscr();
	
num_edge = readedges();
	
makeset();
	
spanningtree(num_edge);
	
return 0;
}
Example 5: Consider the graph as shown in Fig. 5.11. In the above program, the 
input stream read data from input file “krus_in.txt” and output stream write data 
to a output file “KRUS_OUT.TXT”.   The first line of the input file “krus_in.txt” is 
the number of vertices. The rest is the adjacency matrix or weight matrix of the 
graph shown in Fig. 5.11. 
krus_in.txt
6 
1 1 0
1 2 2
1 3 4
2 1 2
2 2 0
2 3 7
2 4 11 
3 1 4
3 2 7
3 3 0
3 4 8
3 6 1
4 2 11

Appendix
201
4 3 8
4 4 0
4 5 6
5 4 6
5 5 0
5 6 9
6 3 1
6 5 9
6 6 0
After the execution of the program “KRUSKAL.CPP”, the following output 
file “KRUS_OUT.TXT” is produced. The following output shows the Minimum 
Spanning Tree with Minimum Weight.
KRUS_OUT.TXT
The number of Vertices in the Graph : 6
The Adjacency matrix(Weight matrix):
9999  2  4  9999  9999  9999  
2  9999  7  11  9999  9999  
4  7  9999  8  9999  1  
9999  11  8  9999  6  9999  
9999  9999  9999  6  9999  9  
9999  9999  1  9999  9  9999  
The sorted set of edges in non-decreasing order by weight(after applying 
bubblesort)
3 6 1
1 2 2
1 3 4
4 5 6
2 3 7
3 4 8
5 6 9
2 4 11
The Edges of the Minimum Spanning Tree are
1. Edge 3 - 6 Weight: 1
2. Edge 1 - 2 Weight: 2
3. Edge 1 - 3 Weight: 4
4. Edge 4 - 5 Weight: 6
5. Edge 3 - 4 Weight: 8

Appendix
202
The Weight of the Minimum Spanning Tree is : 21
C++ Program 6: The Ford-Fulkerson’s (with modification by Edmonds-Karp) 
Algorithm has been implemented in the following C++ program.
MAXFLOW.CPP
//The Ford-Fulkerson Algorithm in C++
#include <iostream.h>
#include <fstream.h>
#include <conio.h>    
//Basic Definitions
#define WHITE 0
#define GRAY 1
#define BLACK 2
#define MAX_NODES 100
#define INFINITY 9999
#define START 1
#define END 6    
//Declarations
int n;  // number of nodes
int e;  // number of edges
int capacity[MAX_NODES][MAX_NODES]; // capacity matrix
int flow[MAX_NODES][MAX_NODES];     // flow matrix
int color[MAX_NODES]; // needed for breadth-first search
int pred[MAX_NODES];  // array to store augmenting path
int k=0;  // number of augmenting paths
    ifstream in("MF.TXT");
    ofstream out("MF_OUT.TXT");
int min (int x, int y) {
    return x<y ? x : y;  // returns minimum of x and y
}
//A Queue for Breadth-First Search
int head,tail;
int q[MAX_NODES+2];
void enqueue (int x) 
{
    q[tail] = x;
    tail++;
}

Appendix
203
int dequeue () 
{
    int x = q[head];
    head++;
    return x;
}
//Breadth-First Search for an augmenting path
int bfs (int start, int target) 
{
  void short_path(int,int);
    int u,v;
    for (u=1; u<=n; u++) 
{
	
color[u] = WHITE;
    }
    head = tail = 0;
    enqueue(start);
    pred[start] = -1;
    while (head!=tail) 
{
	
u = dequeue();
	
// Search all adjacent white nodes v. If the capacity
	
// from u to v in the residual network is positive,
	
// enqueue v.
	
for (v=1; v<=n; v++) 
{
	
    if (color[v]==WHITE && capacity[u][v]-flow[u][v]>0) 
{
	
	
color[v] = GRAY;
	
	
pred[v] = u;
	
	
enqueue(v);
	
	
	
 }
	
	
    }
	
       color[u]=BLACK;
	
	
       }
    // If the color of the target node is black now,
    // it means that we reached it.
   if(color[target]==BLACK)
{
     out<<"\n"<<++k<<"."<<"The Augmenting Path: ";
     short_path(END,0);

Appendix
204
     out<<endl;
	
    }
    return color[target]==BLACK;
}
//Ford-Fulkerson Algorithm
int max_flow (int source, int sink) 
{
    int i,j,u;
    // Initialize empty flow.
    int max_flow = 0;
    for (i=1; i<=n; i++) 
{
	
for (j=1; j<=n; j++) 
{
	
    flow[i][j] = 0;
	
}
    }
    out<<"\nThe Maximal Flow Pattern is the collection of all Augmenting 
Paths:"<<endl;
    // While there exists an augmenting path,
    // increment the flow along this path.
    while (bfs(source,sink)) 
{
	
// Determine the amount by which we can increment the flow.
	
int increment = INFINITY;
	
for (u=n; pred[u]>=1; u=pred[u]) 
{
	
    increment = min(increment,capacity[pred[u]][u]-flow[pred[u]][u]);
	
}
	
out<<"\n  The Residual Capacity of the Augmenting Path: 
"<<increment<<endl;
	
// Now increment the flow.
	
for (u=n; pred[u]>=1; u=pred[u]) 
{
	
    flow[pred[u]][u] += increment;
	
    flow[u][pred[u]] -= increment;
	
	
	
    }
	
max_flow += increment;
    }
    // No augmenting path anymore. Stop.

Appendix
205
    return max_flow;
}
//Reading the input file and the main program
void read_input_file() 
{
    int a,b,c,i,j;
    // read number of nodes and edges
     in>>n>>e;
     out<<"The number of nodes: "<<n<<endl;
     out<<"\nThe number of edges: "<<e<<endl;
    // initialize empty capacity matrix
    for (i=1; i<=n; i++) 
{
	
for (j=1; j<=n; j++) 
{
	
    capacity[i][j] = 0;
	
}
    }
    // read edge capacities
    while(!in.eof())
{
    for (i=0; i<e; i++) 
{
    in>>a>>b>>c;
	
capacity[a][b] = c;
	
}
    }
    in.close();
    out<<"\nThe Adjacency matrix(Capacity matrix):"<<endl;
     for(i=1;i<=n;i++)
{
      for(j=1;j<=n;j++)
	
out<<capacity[i][j]<<"  ";
	
out<<endl;
	
}
}
int main () 
{
    clrscr();

Appendix
206
    read_input_file();
    out<<"\n"<<"The Maximal flow: "<<max_flow(1,n);
    getch();
    return 0;
}
void short_path(int t,int l)
{
 int i,u,v;
 static int path[50];
 v=t;
 u=pred[v];
 path[l++]=u;
if(u!=START)
 short_path(u,l);
else
{
 for(i=l-1;i>=0;i--)
  out<<path[i]<<"->";
  out<<n;
    }
  }
Example 6: Consider the graph as shown in Fig. 10.5. In the above program, the 
input stream is used to read data from input file “MF.TXT” and output stream is 
used to write data to a output file “MF_OUT.TXT”. The first line of the input file 
“MF.TXT” is the number of vertices and edges. The rest is the adjacency matrix or 
capacity matrix of the graph shown in Fig. 10.5. 
MF.TXT
6 10
1 2 16
1 3 13
3 2 10
2 3 4
4 3 9
2 4 12
3 5 14
5 4 7
4 6 20
5 6 4

Appendix
207
After the execution of the program “MAXFLOW.CPP”, the following output file 
“MF_OUT.TXT” is produced. The following output shows the Maximal Flow 
Pattern as well as the Maximal Flow from source vertex 1 to sink vertex 6.
MF_OUT.TXT
The number of nodes: 6
The number of edges: 10
The Adjacency matrix(Capacity matrix):
0  16  13  0  0  0  
0  0  4  12  0  0  
0  10  0  0  14  0  
0  0  9  0  0  20  
0  0  0  7  0  4  
0  0  0  0  0  0  
The Maximal Flow Pattern is the collection of all Augmenting Paths:
1.The Augmenting Path: 1->2->4->6
  The Residual Capacity of the Augmenting Path: 12
2.The Augmenting Path: 1->3->5->6
  The Residual Capacity of the Augmenting Path: 4
3.The Augmenting Path: 1->3->5->4->6
  The Residual Capacity of the Augmenting Path: 7
The Maximal flow: 23

References
Appel K, Haken W. Every planar map is four colorable. Bull Amer Math Soc. 1976;82:711–2.
Appel K, Haken W. Every planar map is four colorable. Part I. Discharging. Ill J Math.
1977a;21:429–90.
Appel K, Haken W. Every planar map is four colorable. Part II. Reducibility. Ill J Math.
1977b;21:491–567.
Balakrishnan R, Ranganathan K. A textbook of graph theory. New York: Springer; 2000.
Clark J, Holton DA. A ﬁrst look at graph theory. Singapore: World Scientiﬁc; 1991.
Corman TH, Leiserson CE, Rivest RL, Stein C. Introduction to algorithms. 2nd ed. Cambridge:
The MIT Press; 2001.
Deo N. Graph theory with applications to engineering and computer science. New Delhi: PHI;
1974.
Dharwadkar A. A new proof of the four color theorem. 2002 http://www.geocities.com/(2002).
Dharwadker A, Pirzada S. Graph theory. India: Orient Longman and Universities Press of India;
2008.
Dharwadker A, Pirzada S. Applications of graph theory. J Korean Soc Ind Appl Math (Ksiam).
2007;11(4): .
Dijkstra EW. A note on two problems in connexion with graphs. Numer Math. 1959;1:269–71.
Diestel R. Graph theory. In: Graduate texts in mathematics, vol. 173. New York: Springer; 1997
(2nd ed. 2000).
Dirac GA, Schuster S. A theorem of Kuratowski. Nederl Akad Wetensch Proc Ser A.
1954;57:343–8.
Euler L. Solutio problematics ad geometriam situs pertinents. Comment Academiae Sci 1
Petropolitanae. 1736;8:128–140.
Euler L. The Konigsberg bridges. Sci Amer. 1853;189:66–70.
Floyd RW. Algorithm 97: shortest path. Comm ACM. 1962;5:345.
Ford LR, Fulkerson DR. Flows in networks. Princeton: Princeton University Press; 1962.
Foulds LR. Graph theory applications. New York: Springer; 1992.
Harary F. A characterization of block graphs. Can Math Bull. 1931;6:1–6.
Harary F. Graph theory. Reading: Addison-Wesley; 1969.
Harary F, Frisch LT. Communication, transmission and transportation networks. Reading:
Addison-Wesley; 1971.
Harary F, Hedetniemi S. The achromatic number of a graph. J Combin Theory B 1970; pp. 154–161.
Harary F, Hedetniemi S, Robinson RW. Uniquely colorable graphs. J Combin Theory.
1969;6:264–70.
S. Saha Ray, Graph Theory with Algorithms and Its Applications,
DOI: 10.1007/978-81-322-0750-4,  Springer India 2013
209

Harary F, Nash-Williams C St JA. On Eulerian and Hamiltonian graphs and line graphs. Can
Math Bull. 1965;8:701–10.
Heawood PJ. Map color theorem. Qurat J Pure Appl Math. 1890;24:332–8.
Hopcroft
JE,
Tarjan
RE.
Efﬁcient
algorithms
for
graph
manipulation.
Comm
ACM.
1973;16(6):372–8.
Kuratowski C. Sur le probleme des courbes gauches en topologie. Fund Math. 1930;15:271–83.
Moore EF. The shortest path through a maze. In: Proceedings of the international symposium on
the theory of switching. Cambridge: Harvard University Press; 1959. pp. 285–292.
Map of USA with state names.svg––Wikipedia, the free encyclopedia http://en.wikipedia.org/
wiki/File:Map_of_USA_with_state_names.svg.
Ore O. Note on Hamilton circuits. Amer Math Monthly. 1960;67:55.
Ore O. The four color problem. New York: Academic; 1967.
Ore O. Theory of graphs. Amer Math Soc Colloq Publ Providence. 1962;38.
Parthasarathy KR. Basic graph theory. New Delhi: Tata McGraw-Hill; 1994.
Saaty TL, Kainen PC. The four color problem. New York: McGraw-Hill; 1977.
Tanenbaum AS. Computer networks. Upper Saddle River: Prentice Hall Inc.; 1988.
Taha HA. Operations research: an introduction. Upper Saddle River: Prentice Hall Inc.; 2003.
Trudeau RJ. Introduction to graph theory. New York: Dover Publications; 1993.
Thomassen C. Kuratowskis theorem. J Graph Theory. 1981;5:225–41.
Warshall S. A theorem on Boolean matrices. J ACM. 1962;9:11–2.
West DB. Introduction to graph theory. Englewood Cliffs: Prentice Hall Inc; 1996.
Whitney H. A theorem on graphs. Annals Math. 1931;32:378–90.
Whitney H. Congruent graphs and the connectivity of graphs. Amer J Math. 1932;54:150–68.
Whitney VKM. Algorithm 422: minimal spanning tree. Comm ACM. 1972;15(4):273.
210
References

Index
2-Isomorphism, 107, 113
4-Color conjecture, 154, 156
4-Color theorem, 154–156
5-Color theorem, 155
A
Acyclic, 35, 38, 40, 42
Adjacency matrix, 66, 72, 75,
101–104, 113
Adjacent, 4, 6–9, 20, 27, 29, 31
Augmented network or graph, 168, 169
Augmented path, 165–167
B
Basis vectors, 96
Binary tree, 36
Bipartite, 7, 20, 126, 137, 176
Bipartite graphs, 7, 155
Bipartition, 7, 30, 126
Block, 118
Branch, 40, 116
Branch vertex, 143
Breath ﬁrst search algorithm, 78, 188
Breath ﬁrst tree, 78, 168
C
Capacity, 159
Capacity of cut, 159, 161, 163–165
Chord, 40
Chromatic index, 126
Chromatic number, 126
Chromatic polynomial, 127
Closed walk, 2, 25
Closure, 34
Coloring, 125
Complete graph, 7, 11
Complement, 12, 31
Co-tree, 40
Circuit matrix or cycle matrix, 105
Commutative, 12
Complete bipartite graph, 7, 30, 137, 144
Complexity
Dijkstra’s algorithm, 51
Floyd’s algorithm, 59
Ford-Fulkerson’s algorithm, 167
Component, 15, 17, 20, 39, 98, 107, 117
Connected, 2, 15, 20, 26, 35, 38–42, 68, 72,
78, 99, 100, 103, 104, 110, 115–117,
119, 132, 138
Connected graph, 15, 19, 20, 26, 30, 35,
38–42, 68, 78, 85, 99, 100, 102, 103,
116, 117, 119, 120, 139
Connectivity, 119–123
Contracted, 47, 131, 147
Contracted vertex, 131
Contraction, 131, 143, 146
Critical graphs, 132
Cut (in a network), 159, 161–165,
171, 175
Cut set, 42, 43, 115–122
Cut vertex, 116–120, 122, 123
Cycle, 17–21, 30, 35, 38, 67, 107, 126,
141, 146
D
Decomposition, 13
Degree, 2–6, 9, 10, 16
Deletion, 13
Depth, 35
Depth-ﬁrst search algorithms, 80
S. Saha Ray, Graph Theory with Algorithms and Its Applications,
DOI: 10.1007/978-81-322-0750-4,  Springer India 2013
211

Digraph. See Directed graph, 9, 99, 159
Dijsktra’s algorithm, 49, 50
Dirac’s theorem, 27
Disconnected graph, 15, 16, 21, 39, 100, 117,
120, 121, 140
Discrete graph, 14
Distance matrix, 58, 182, 183, 185
Dual graph, 150, 151
E
Edge, 1
chromatic number, 153
coloring, 153
connectivity, 119
contraction, 131, 143
Edmonds-Karp algorithm, 167
Embedding, 136, 156
Empty graph, 5
End vertex, 4
Euler
formula, 138
graph, 25, 26
line, 2
theorem, 26
trail, tour, 25
Eulerian graph, 25, 26
Even cycle, 18
Even vertex, 5
F
Face, 1, 137, 138, 149
Find (x), 197
Finite graph, 1, 38
Five-color theorem, 155
Flow network, 159, 165, 166
Floyd-Warshall’s algorithm, 57, 58
Ford-Fulkerson
algorithm, 166, 167
Forest, 35
Four color conjecture, 154
Four-color theorem, 154
Fundamental
circuit matrix, 109
circuits, 41
cut sets, 115, 116
Fusion, 13
G
Galois ﬁeld, 96
Greedy algorithm, 49, 193
H
Hamiltonian
cycle, 27
graph, 25, 27
path, 27
Handshaking lemma, 5
Height, 35
Homeomorphic, 147
I
Incidence, 4
Incidence matrix, 96–112
In-degree, 9, 10
Induced subgraph, 13, 21
Inﬁnite graphs, 1
Inﬁnite regions, 137, 138, 140
Intersection, 12
Isolated vertex, 5, 98, 132
Isomorphic, 5, 6, 11, 15, 18, 32, 101, 135, 136,
138, 149, 152
Isomorphism, 5, 6
K
Königsberg bridge problem, 2, 3
Kruskal’s algorithm, 68
Kuratowski
ﬁrst graph, 138
second graph, 138
Kuratowski’s theorem, 144, 146
k-Chromatic, 126, 132
k-Colorable, 125
k-Connected, 119
k-Connected graph, 119
k-Cycle, 18
k-Edge colorable, 153
k-Edge connected, 119
k-Regular, 9
L
Leaf, 35
Level, 35
Loop, 1, 19
212
Index

M
Makeset (x), 197, 198
Map coloring, 156
Maximal ﬂow, 58, 163–168, 171, 175
Maximal ﬂow pattern, 161, 165–167, 171, 175
Maximal non-Hamiltonian graph, 27, 28
Maximum bipartite matching, 175, 176
Max-ﬂow min-cut theorem, 162, 165, 175
Merge (x, y), 197–199
Minimally connected graph, 35, 39
Minimal spanning tree, 68–70, 72, 200
Minimal weight, 68, 70
Minor, 143, 144
Multigraph, 1, 143
N
Network, 49, 159
Node (vertex), 1
Node sequence matrix, 58
Nonplanar graph, 136, 144
Nontrivial graph, 14
Null graph, 5, 12, 95
O
Odd cycle, 18, 20, 126
Odd vertex, 5
Open walk, 15
Order of a graph, 1
Ore’s theorem, 29
Origin, 14
Out-degree, 9
P
Parallel edges, 1, 19, 98, 151
Partition, 7, 8, 16, 42
Path, 14, 15
Pendant edge, 151
Pendant vertex, 5, 6, 35, 151
Permutation matrix, 101
Petersen graph, 147, 148
Planar graph, 135–138, 149, 151
Plane graph, 135–137, 146, 151
Plane representation, 137, 141, 142, 146, 149
Prim’s algorithm, 71
Proper coloring, 125
Properly colored graph, 125
R
Reduced incidence matrix, 100, 101
Reference vertex, 100
Region, 136–141, 146, 149–151, 154, 157
Regular graph, 9
Residual capacity, 165, 166
of an augmenting path, 166
Residual network, 166
Ring sum, 12, 95
Root, 35, 36, 127
Rooted tree, 35, 36
S
Saturated edge, 161, 166
Self-complementary, 31, 32
Self-loop, 1, 4
Separable graph, 118, 119
Shortest path, 20, 49
Shortest path problem, 3
Simple graph, 1
Sink, 159–169, 172, 173, 175
Size of a graph, 1
Source, 50, 51, 66, 159–173, 175–177
Spanning subgraph, 11, 40, 68
supergraph, 11, 27
tree, 40
Stable, 14, 21, 30, 155
Subdivision, 143–147
Subgraph, 11
Super sink, 175
Super source, 175
T
Terminus, 14
Topological minor, 143
Tour, 25
Trail, 15
Transport network, 159
Tree, 35
Trivial graph, 7
Trivial walk, 14
U
Union, 12
Index
213

V
Value of a ﬂow, 160
Vector space of a graph, 95, 111
Vertex
coloring, 125
connectivity, 119
W
Walk, 2, 14
closed, 2, 15, 25
length, 14
Weighted graph, 3, 68
Weighted network, 49
214
Index

