Introduction to 
Secure Outsourcing 
Computation
Xiaofeng Chen
Elisa Bertino & Ravi Sandhu, Series Editors
MORGAN&CLAYPOOL PUBLISHERS
SyntheSiS LectureS on  
information Security, Privacy, and truSt


Introduction to
Secure Outsourcing Computation

Synthesis Lectures on
Information Security, Privacy,
& Trust
Editors
Elisa Bertino, Purdue University
Ravi Sandhu, University of Texas, San Antonio
e Synthesis Lectures Series on Information Security, Privacy, and Trust publishes 50- to 100-page
publications on topics pertaining to all aspects of the theory and practice of Information Security,
Privacy, and Trust. e scope largely follows the purview of premier computer security research
journals such as ACM Transactions on Information and System Security, IEEE Transactions on
Dependable and Secure Computing and Journal of Cryptology, and premier research conferences,
such as ACM CCS, ACM SACMAT, ACM AsiaCCS, ACM CODASPY, IEEE Security and
Privacy, IEEE Computer Security Foundations, ACSAC, ESORICS, Crypto, EuroCrypt and
AsiaCrypt. In addition to the research topics typically covered in such journals and conferences, the
series also solicits lectures on legal, policy, social, business, and economic issues addressed to a
technical audience of scientists and engineers. Lectures on signiﬁcant industry developments by
leading practitioners are also solicited.
Introduction to Secure Outsourcing Computation
Xiaofeng Chen
2016
Database Anonymization: Privacy Models, Data Utility, and Microaggregation-based
Inter-model Connections
Josep Domingo-Ferrer, David Sánchez, and Jordi Soria-Comas
2016
Automated Software Diversity
Per Larsen, Stefan Brunthaler, Lucas Davi, Ahmad-Reza Sadeghi, and Michael Franz
2015
Trust in Social Media
Jiliang Tang and Huan Liu
2015

iii
Physically Unclonable Functions (PUFs): Applications, Models, and Future Directions
Christian Wachsmann and Ahmad-Reza Sadeghi
2014
Usable Security: History, emes, and Challenges
Simson Garﬁnkel and Heather Richter Lipford
2014
Reversible Digital Watermarking: eory and Practices
Ruchira Naskar and Rajat Subhra Chakraborty
2014
Mobile Platform Security
N. Asokan, Lucas Davi, Alexandra Dmitrienko, Stephan Heuser, Kari Kostiainen, Elena Reshetova,
and Ahmad-Reza Sadeghi
2013
Security and Trust in Online Social Networks
Barbara Carminati, Elena Ferrari, and Marco Viviani
2013
RFID Security and Privacy
Yingjiu Li, Robert H. Deng, and Elisa Bertino
2013
Hardware Malware
Christian Krieg, Adrian Dabrowski, Heidelinde Hobel, Katharina Krombholz, and Edgar Weippl
2013
Private Information Retrieval
Xun Yi, Russell Paulet, and Elisa Bertino
2013
Privacy for Location-based Services
Gabriel Ghinita
2013
Enhancing Information Security and Privacy by Combining Biometrics with Cryptography
Sanjay G. Kanade, Dijana Petrovska-Delacrétaz, and Bernadette Dorizzi
2012
Analysis Techniques for Information Security
Anupam Datta, Somesh Jha, Ninghui Li, David Melski, and omas Reps
2010
Operating System Security
Trent Jaeger
2008

Copyright © 2016 by Morgan & Claypool
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in
any form or by any means—electronic, mechanical, photocopy, recording, or any other except for brief quotations
in printed reviews, without the prior permission of the publisher.
Introduction to Secure Outsourcing Computation
Xiaofeng Chen
www.morganclaypool.com
ISBN: 9781627057912
paperback
ISBN: 9781627057929
ebook
DOI 10.2200/S00701ED1V01Y201602SPT016
A Publication in the Morgan & Claypool Publishers series
SYNTHESIS LECTURES ON INFORMATION SECURITY, PRIVACY, & TRUST
Lecture #16
Series Editors: Elisa Bertino, Purdue University
Ravi Sandhu, University of Texas, San Antonio
Series ISSN
Print 1945-9742
Electronic 1945-9750

Introduction to
Secure Outsourcing Computation
Xiaofeng Chen
Xidian University, China
SYNTHESIS LECTURES ON INFORMATION SECURITY, PRIVACY, &
TRUST #16
C
M
&
cLaypool
Morgan
publishers
&

ABSTRACT
With the rapid development of cloud computing, the enterprises and individuals can outsource
their sensitive data into the cloud server where they can enjoy high quality data storage and com-
puting services in a ubiquitous manner. is is known as the outsourcing computation paradigm.
Recently, the problem for securely outsourcing various expensive computations or storage has at-
tracted considerable attention in the academic community. In this book, we focus on the latest
technologies and applications of secure outsourcing computations. Specially, we introduce the
state-of-the-art research for secure outsourcing some speciﬁc functions such as scientiﬁc compu-
tations, cryptographic basic operations, and veriﬁable large database with update. e construc-
tions for speciﬁc functions use various design tricks and thus result in very eﬃcient protocols for
real-world applications.
e topic of outsourcing computation is a hot research issue nowadays. us, this book will
be beneﬁcial to academic researchers in the ﬁeld of cloud computing and big data security.
KEYWORDS
cloud computing, veriﬁable computing, outsourcing paradigm, privacy preserving,
security model

vii
Dedicated to my precious wife and lovely daughter


ix
Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi
Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1
Outsourcing Paradigm in Cloud Computing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2
Secure Challenges in Outsourcing Computation . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3
Formal Security Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.1 Security Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3.2 Adversarial Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.4
General Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2
Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.1
Number-eoretic Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2
Bilinear Pairings (Groups of Prime Order) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.3
Bilinear Pairings (Groups of Composite Order) . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.4
Sparse Matrix and Dense Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.5
Vector Commitments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.6
Algebraic Pseudorandom Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.7
Bloom Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3
Secure Outsourcing of Scientiﬁc Computations . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.1
Matrix Multiplication. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.1.1 A Basic Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.1.2 An Enhanced Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
3.2
Matrix Inversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.3
Large-scale Linear Equations Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3.1 New Secure Outsourcing Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.3.2 Security Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

x
4
Secure Outsourcing of Cryptographic Operations. . . . . . . . . . . . . . . . . . . . . . . . 29
4.1
Security Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2
Two Untrusted Program Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.3
Secure Outsourcing of Single Modular Exponentiation . . . . . . . . . . . . . . . . . . . 33
4.3.1 e Proposed Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
4.3.2 Security Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.3.3 Comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.4
Secure Outsourcing of Simultaneous Modular Exponentiation . . . . . . . . . . . . . 38
4.4.1 Outsourcing Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.4.2 Eﬃciency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.5
Secure Outsourcing of Bilinear Pairings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.5.1 Outsourcing Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.5.2 Improved Outsourcing Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
5
Secure Outsourcing of Large Database With Updates . . . . . . . . . . . . . . . . . . . . 45
5.1
Security Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.1.1 Security Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
5.1.2 Forward Automatic/Backward Substitution Update Attack . . . . . . . . . . 48
5.2
VDB Construction From Delegating Polynomial Functions . . . . . . . . . . . . . . . 49
5.2.1 Delegating of Polynomial Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
5.2.2 Benabbas-Gennaro-Vahlis VDB Construction . . . . . . . . . . . . . . . . . . . . 50
5.3
VDB Framework Based on Vector Commitment . . . . . . . . . . . . . . . . . . . . . . . . 51
5.3.1 e General Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
5.3.2 Security Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
5.4
VDB Framework From Binding Vector Commitment . . . . . . . . . . . . . . . . . . . . 54
5.4.1 A Concrete VDB Scheme. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.4.2 Security Analysis of the VDB Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
5.5
Incremental VDB Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
5.5.1 Incremental Encryption Based on Bit Flipping . . . . . . . . . . . . . . . . . . . . 59
5.5.2 Inc-VDB Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5.5.3 A Concrete Inc-VDB Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
6
Conclusion and Future Works . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
Author’s Biography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

xi
Preface
Cloud computing, the new term for the long dreamed vision of computing as a utility, oﬀers plenty
of beneﬁts for real-world applications, such as on-demand self-service, ubiquitous network access,
location independent resource pooling, rapid resource elasticity, usage-based pricing, outsourcing,
etc. e most outstanding beneﬁt of cloud computing is the so-called outsourcing paradigm. at
is, the users with resource-constraint devices can outsource heavy computation workloads into the
cloud server and enjoy the unlimited computing resources in a pay-per-use manner. As a result,
the enterprises and individuals can avoid large capital outlays in hardware/software deployment
and maintenance. Despite these beneﬁts, the outsourcing paradigm also inevitably suﬀers from
some new security challenges due to untrusted cloud servers. us, how to securely outsource
prohibitively expensive computations is a hot issue in academic research community.
e general construction for securely outsourcing arbitrary functions has been proposed
based on the primitives of garbled circuit and full homomorphic encryption. In this sense, the
problem of secure outsourcing computation has been theoretically solved. However, this gen-
eral solution is ineﬃcient for most real applications and thus it is meaningful to seek eﬃcient
outsourcing protocols for various speciﬁc functions. is book addresses the advances of secure
outsourcing computations. More speciﬁcally, we focus on the state-of-the-art techniques of se-
cure outsourcing computations for diﬀerent speciﬁc functions based on diﬀerent design tricks.
In Chapter 1, we give a brief introduction for secure outsourcing computation, including its se-
curity challenges and formal security deﬁnitions. In Chapter 2, we present some preliminaries
which will be used in this book. Chapter 3 presents in detail some recent research for securely
outsourcing scientiﬁc computations. In Chapter 4, we present some recent techniques for securely
outsourcing cryptographic operations, such as modular exponentiations and bilinear parings. Re-
cent progress in veriﬁable outsourcing very large databases with eﬃcient updates is presented in
Chapter 5. Finally, we conclude and discuss future research directions in Chapter 6.
Xiaofeng Chen
February 2016


xiii
Acknowledgments
Parts of the content of this lecture are results of research projects funded by the National Natural
Science Foundation of China (No. 61572382) and Program for New Century Excellent Talents
in University (No. NCET-13-0946).
I sincerely express my gratitude to Prof. Attila Yavuz at Oregon State University and
Prof. Fang-Yu Rao at Purdue University for their invaluable suggestions to improve this book.
I would also like to thank my three Ph.D. students, Jianfeng Wang, Hui Huang, and Zhiwei
Zhang, for their help when the book was being written.
Xiaofeng Chen
February 2016


1
C H A P T E R
1
Introduction
In this chapter, we present the security challenges and formal deﬁnitions of secure outsourcing
computation. We also introduce the general outsourcing framework of an arbitrary function in-
troduced by Gennaro, Gentry, and Parno [74].
Let us consider some scenarios in the real applications. For example, if you want to travel
the world by air, would you like the idea of buying a very expensive Boeing 737? I guess that the
overwhelming majority of people would not because the plane is too expensive. Of course, it is
another thing if you are Jackie Chan. Fortunately, most of us need not buy a Boeing 737, but
a ﬂight ticket for traveling. In this example, we can outsource a very expensive task to a service
provider (e.g., an airline company) and just enjoy the service in a pay-per-use manner.
Nowadays, we always encounter some prohibitively expensive computation tasks. For ex-
ample, the sieving for factoring a 768-bit RSA modulus took almost two years on many hundreds
of machines. However, on a single core 2.2 GHz AMD Opteron processor with 2 GB RAM,
performing this algorithm would have taken about 1,500 years [89]. Trivially, in order to accom-
plish this kind of computation task, the resource-limited client has no choice but to outsource it
to servers with rich resources.
In some cases, even if we can aﬀord certain expensive tasks, they are not worthy it. For
example, would you like to buy a $10,000 wedding dress that you will wear only once in your life?
From the viewpoint of a rational economic person, the right thing is to rent it from a wedding
dress store. at is, we could outsource this kind of expensive task to a service provider.
From the above examples, we could have an informal deﬁnition for outsourcing computa-
tion. at is, the clients with resource-constraint devices delegate the heavy computation work-
loads into the powerful servers and pay for the services. Trivially, outsourcing computation can
oﬀer signiﬁcant beneﬁts to IT enterprises, especially in the period of ﬁnancial crisis, since large
capital outlays on hardware/software deployment and maintenance are avoided. However, we ar-
gue that outsourcing computation is not a panacea to solve all problems in the environment of
limited resources. e reason is that we should not only consider the computational resources
in the outsourcing paradigm, but also other types of resources, such as storage, communication
(bandwidth), and energy (electric power). Recently, Chen and Sion [59] explored the relationship
between the costs and security aspects in cloud computing, and pointed out that secure outsourc-
ing computation is only meaningful in some special scenarios. Indeed, there are always hidden
costs of bandwidth, which are costlier than computation itself, as well as energy consumption.
erefore, we must carefully evaluate the tool of outsourcing computation and utilize it correctly.

2
1. INTRODUCTION
roughout this book, we only consider the “challenge-response” type of outsourcing pro-
tocols. at is, the client sends the computation task and then the server responds with the result.
ese kinds of protocols require only one round of interaction between the client and the server.
We argue that the protocols with multiple rounds of interaction are impractical in real applica-
tions.
1.1
OUTSOURCING PARADIGM IN CLOUD COMPUTING
Cloud computing, the new term for the long dreamed vision of computing as a utility, enables
ubiquitous, convenient, and on-demand network access to a centralized pool of conﬁgurable com-
puting resources [110]. Cloud computing oﬀers many beneﬁts, such as fast deployment, pay-per-
use, low-costs, rapid elasticity, ubiquitous network access, etc. One of the fundamental advan-
tages of cloud computing is the so-called outsourcing paradigm, where the clients with resource-
constraint devices can outsource the heavy computation workloads into untrusted cloud servers
and enjoy the unlimited computing resources in a pay-per-use manner. at is, the computation
resources are now viewed as an infrastructure and platform to provide for the paying clients as a
service.
Generally, we can view any computation task as a function F W D ! M on a domain D such
that F.D/  M. Given any x 2 D, the goal is to compute F.x/. In the outsourcing paradigm, an
honest but resources-contained client C wants to delegate the computation task F.x/ to a cloud
server S that is not fully trusted by C. Firstly, C may outsource the encoding of F and x to C
(that is, the information about F and x should be kept secret to S in some scenarios). Secondly,
C returns the computation result based on the input (note that the output is not F.x/). e client
Finally, C eﬃciently veriﬁes that the output provided by S is valid and then computes the ﬁnal
result F.x/ by himself. e outsourcing paradigm in cloud computing is illustrated in Fig. 1.1
(note that we have implicitly presented three security requirements of outsourcing computation
which will be given in more detail below).
Secure outsourcing computation is also termed as veriﬁable computation or delegation of
computation. Secure outsourcing computation is closely related to the primitive of secure mul-
tiparty computation (MPC), in which a set of players P1; P2; : : : ; Pn securely compute a given
function F on the inputs x1; x2; : : : ; xn [38]. Deﬁne F.x1; x2; : : : ; xn/ D .y1; y2; : : : ; yn/. e
security in MPC means that each player Pi can only learn the information of yi. is is very
similar to the input/output secrecy of outsourcing computation. e main diﬀerence between the
two notations is that the computational resources of each player in MPC is assumed to be (al-
most) the same. While in the outsourcing computation paradigm, the client is assumed to have
insuﬃcient resources to accomplish the computation of F . Besides, each party in MPC aims to
obtain a corresponding computation result. However, in the outsourcing computation, only the
client really cares about the computation result. Even if some server is also curious about the re-
sult, this is not the part of the protocol. Finally, in the outsourcing computation, the computation

1.2. SECURE CHALLENGES IN OUTSOURCING COMPUTATION
3
R
Checkability
R
Checkability
Client
Server
D
Secrecy
Data
R
Secrecy
Response
F: DĮM
Efficiency
Efficiency
Figure 1.1: Secure outsourcing paradigm in cloud computing.
is viewed as a service and the client must pay the server for the service. While in MPC, no party
will be paid by others.
1.2
SECURE CHALLENGES IN OUTSOURCING
COMPUTATION
With the availability of cloud services, the techniques for securely outsourcing the expensive com-
putaions to untrusted cloud servers are getting more and more attention in the scientiﬁc com-
munity [1, 7, 13, 45, 49, 50, 92]. However, on the other hand, the outsourcing paradigm also
inevitably introduces some new security concerns and challenges [111, 125]. Basically, there are
three security challenges as shown below.
Firstly, the cloud servers can only be assumed to be semi-trusted, while the computation
tasks often contain some sensitive information that should not be exposed to the cloud servers.
us, the ﬁrst security challenge is the secrecy of the outsourcing computation: the cloud servers
should not learn anything about what it is actually computing (including the secret inputs and the
outputs). We argue that the encryption can only provide a partial solution to this problem since
it is very diﬃcult to perform meaningful computations over the encrypted data. Note that fully
homomorphic encryption could be a potential solution to this problem, but the existing schemes
are not practical yet for real-world applications.
Secondly, the semi-trusted cloud servers may return some invalid results. For example, the
servers might contain a software bug that will fail on a constant number of invocations. Moreover,
the servers might decrease the amount of the computations due to ﬁnancial incentives and then
return computationally indistinguishable (invalid) results. erefore, the second security challenge

4
1. INTRODUCTION
is the checkability of the outsourcing computation: the client should have the ability to detect any
failures if the cloud servers misbehave.
Finally, the last challenge is the eﬃciency of the outsourcing computation. at is, the ver-
iﬁcation algorithm is very eﬃcient and should never require some other complicated computa-
tions. Otherwise, the outourcing will become meaningless. At least, the (computation and stor-
age) overload of the client must be much less than that for accomplishing the computation task
itself. Besides, the communication overload should also be considered as a factor of eﬃciency in
outsourcing protocols. at is, the outsourcing protocols should not require multiple rounds of
interactions between the client and servers.
In general, we can achieve the secrecy by means of special encryption or disguise (also
known as blinding) techniques. us, the remaining issue is how to eﬃciently verify the com-
putation results. Without loss of generality, there are three kinds of approaches to achieve the
veriﬁability of outsourcing computations. e ﬁrst one is mostly suitable for the case that the ver-
iﬁcation itself is not involved in any expensive computations. For example, for the “inversion of
one-way function” class of outsourcing computations [22, 45, 61, 62, 79], the client can directly
verify the result since the veriﬁcation is just equivalent to compute the one-way functions. e
second approach is that the client uses multiple servers to achieve veriﬁability [45, 58, 82]. at
is, the client sends the random test query to multiple servers and it accepts only if all the servers
output the same result. Trivially, the approach can only ensure the client to detect the error with
probability absolutely less than 1. e last approach is based on one malicious server and might
leverage some proof systems [73, 87, 88, 96]. Obviously, an essential requirement is that the client
must verify the proofs eﬃciently.
1.3
FORMAL SECURITY DEFINITION
Gennaro, Gentry, and Parno [74] presented a formal deﬁnition for securely outsourcing compu-
tation, which consists of the following algorithms:
• KeyGen .F; / ! .PK; SK/: e randomized key generation algorithm generates a public
key PK that encodes the target function F with the security parameter , which is used by
the server to compute F. en a corresponding secret key SK is generated and kept private
by the client.
• ProbGen SK.x/ ! .x; x/: e problem generation algorithm uses the secret key SK to
encode the function input x as a public value x which is given to the server to compute
with, and a secret value x is kept private by the client.
• Compute PK.x/ ! y: Using the public key PK and the encoded input x, the server
computes an encoded version y of the output y D F.x/.

1.3. FORMAL SECURITY DEFINITION
5
• Verify SK.x; y/ ! y [ ?: Using the client’s secret key SK and the secret “decoding” x,
the veriﬁcation algorithm converts the server’s encoded output y into the output of the
function, e.g., y D F.x/, or outputs ? if y is invalid.
Trivially, a secure outsourcing computation scheme should be correct. at is, the compu-
tation result y by an honest server will always be successfully veriﬁed and the algorithm Verify
outputs y. In this sense, we say that C S correctly implements the function F.
1.3.1
SECURITY REQUIREMENTS
In the following, we introduce some security requirements for outsourcing computation [74, 82].
e ﬁrst requirement is the privacy for the input/output of the computation task. Infor-
mally, it means that the server cannot learn anything from its interaction in the protocol in the
sense of an indistinguishability argument.
Deﬁnition 1.1
(privacy) Given a security parameter k, a pair of algorithms .C; S/ achieves the
privacy for the input/output of F if for any probabilistic polynomial time (PPT) adversary A,
AdvC S
A .F; k/  negl.k/;
where AdvC S
A .F; k/ D j Pr Œb D b0   1
2j is deﬁned as the advantage of A in the experiment as
follows:
.PK; SK/
R
 KeyGen.F; k/I
.x0; x1/  APubProbGenSK./.PK/
.0; 0/  ProbGenSK.x0/I
.1; 1/  ProbGenSK.x1/I
b
R
 f0; 1gI
b0  APubProbGenSK./.PK; x0; x1; b/:
During the above experiment, the adversary A is allowed to request the encoding of any in-
put he desires. e oracle PubProbGenSK.x/ calls ProbGenSK.x/ to obtain .x; x/ and returns
only the public part x. Trivially, the output of PubProbGenSK.x/ is probabilistic.
e second requirement is the eﬃciency of outsourcing algorithms. at is, the local com-
putation done by client C should be substantially less than that to accomplish the original com-
putation by itself (i.e., without outsourcing). Note that the local computation consists of the
computational overload of algorithms ProbGen and Verify. However, it does not include the

6
1. INTRODUCTION
computation of KeyGen which may be prohibitively heavy since it can be amortized over plenty
of diﬀerent input computations.
Deﬁnition 1.2
(˛-eﬃciency) A pair of algorithms .C; S/ is said to be an ˛-eﬃcient implemen-
tation of F if (1) C S correctly implements F and (2) for 8 x 2 D, the running time of C is no
more than an ˛-multiplicative factor of the running time of F, where 0 < ˛ < 1.
e last requirement is the checkability (also known as veriﬁability) of outsourcing algo-
rithms. at is, the output by the server must be checked for correctness. More precisely, the
invalid output given by any malicious server cannot pass the veriﬁcation and client C will detect
the error with a non-negligible probability.
Deﬁnition 1.3
(checkability) Given a security parameter k, a pair of algorithms .C; S/ achieve
the checkability for F if for any probabilistic polynomial time (PPT) adversary A,
AdvC S
A .F; k/  negl.k/;
where AdvC S
A .F; k/ D PrŒExp.F; k/ D 1 is deﬁned as the advantage of A in the experiment Exp
as follows:
.PK; SK/
R
 KeyGen.F; k/I
For i D 1; 2; : : : ; l D poly.k/I
xi  A.PK; x1; 1; : : : ;xi 1; i 1/
.i; i/  ProbGenSK.xi/I
.i; Oy/  A.PK; x1; 1; : : : ; xl; l/I
Oy  VerifySK.i; Oy/
If Oy ¤? ^ Oy ¤ F.xi/; output 010I else 000I
Also, we can deﬁne the magnitude of checkability in a secure outsourcing scheme. at is,
a pair of algorithms .C; S/ is said to be a ˇ-checkable implementation of F if (1) C S correctly
implements F and (2) for 8 x 2 D, if a malicious S0 deviates from its advertised functionality
during the execution of C S0.x/, C will detect the error with probability no less than 0 < ˇ  1.
1.3.2
ADVERSARIAL MODEL
In this section, we introduce four kinds of adversarial models for secure outsourcing computation.
Note that the adversary is the untrusted server(s) in all models.
• Honest-but-curious Model
e “honest-but-curious model” (also-called the semi-honest model) was ﬁrstly introduced
by Goldreich et al. [78]. In this model, both the client C and the server S are guaranteed

1.3. FORMAL SECURITY DEFINITION
7
to properly execute a prescribed protocol, but, at the end of it, S can use its own view of
the execution to infer about C’s input. erefore, S will honestly send the computation
results to C. But he will try his best to retrieve some sensitive information such as the secret
input/output of C. Note that the computation results (i.e., the output of S) are diﬀerent
from the output of C (i.e., the real computation aim of C).
• Lazy-but-honest Model
e “Lazy-but-honest model” was ﬁrst introduced by Golle and Mironov [79], which is
suitable for the inversion of the one-way function class of outsourcing computations. Sim-
ilarly, in this model, S will also honestly send the computation results to C if and only if
he has accomplished the computation. However, S is viewed as a rational economic person
and will try to minimize the amount of computation overload in order to save the compu-
tational resources. In the worst case, S will send a computational indistinguishable or even
random result to C. As a result, C should be able to verify the result eﬃciently.
• Two Untrusted Program Model
Hohenberger and Lysyanskaya [82] ﬁrst introduced the “two untrusted program model”
for outsourcing cryptographic computations. e two untrusted program model, in brief, is
the model that there are two non-colluding servers S1 and S2, and we assume at most one
of them is adversarial while we cannot know which one. Besides, the misbehavior of the
dishonest server can be detected with an overwhelming probability. is model is suitable
for designing the secure outsourcing scheme for the expensive operations in a cryptographic
algorithm such as modular exponentiation or bilinear pair.
• Refereed Delegation of Computation Model
e “refereed delegation of computation model” was ﬁrst introduced by Canetti et al. [58],
where the client C delegates the computation to n  2 servers S1; S2; : : : Sn under the as-
sumption that at least one of the servers is honest. In case the servers make contradictory
claims about the computation results, C can engage in a protocol with each of the servers,
at the end of which C can eﬃciently determine the true claim under the assumption that at
least one of the servers is honest (while the client does not know which is honest). Obviously,
the two untrusted program model can be viewed as a special case of refereed delegation of
computation model when the number of servers n D 2.
• Amortized Model
Gennaro, Gentry, and Parno [74] ﬁrstly introduce the “amortized model” to construct ef-
ﬁcient veriﬁable computation protocols. By introducing an expensive pre-processing stage,
the client C can outsource some computation-intensive tasks to the server S in an eﬃcient
manner. Although C needs to perform a one-time complicated computation in the pre-
processing stage, the computation overload is amortized over all future executions. Note

8
1. INTRODUCTION
that the pre-processing is performed only once, C could outsource it to a trusted server or
perform it in an oﬄine manner.
1.4
GENERAL CONSTRUCTION
In 2010, Gennaro, Gentry, and Parno [74] ﬁrst formalized the deﬁnition for secure outsourcing
computation (they called it the notion of veriﬁable computation) and presented a milstone theo-
retic framework for secure outsourcing arbitrary computation functions as shown in Fig. 1.2. e
framework mainly uses two building blocks of garbled circuit [130, 131] and fully homomorphic
encryption [69, 70, 118, 124].
SK
FHE
 Encryption
FHE 
Compution
SK
FHE 
Decryption
Garble 
Circuit
Figure 1.2: General construction.
In this section, we give a brief introduction to Gennaro et al.’s general outsourcing frame-
work. e main idea is as follows: Our task is to compute y D F.x/. Firstly, the client converts
the target function F as a garbled circuit C using Yao’s protocol. e client keeps all the wire
values fwig as his private key SK and the ciphertexts fig on each gate g as his public key PK.
Now, there is a one-to-one correspondence between some wire values wi and the binary expres-
sion of x. Note that wi is the secret key and could not exposed to the servers. us, the client
should encrypt wi and this is accomplished by using a fully homomorphic encryption scheme
FHE with the public/secret key pair .PKE; SKE/. As we know, there are two encryption opera-
tions in FHE. e client performs the ﬁrst operation and encrypts wi with the public key PKE
and sends the ciphertext x to the server. On the other hand, the client outsources the second
(expensive) operation Evaluate to the server and let the ciphertext be y. Due to the property
of fully homomorphic encryption, we know that y should be the ciphertext of !0
i, where !0
i is
the wire values representing y D C.x/ D F.x/ in binary. Trivially, the client can decrypt y with

1.4. GENERAL CONSTRUCTION
9
SKE and obtain !0
i. Finally, the client uses the private key SK to map !0
i to the computation
result y.
e general construction consists of the following algorithms:
• KeyGen.F; / ! .PK; SK/: Represent F
as a garbled circuit C using Yao’s cir-
cuit construction. Choose two random values !0
i ; !1
i  f0; 1g for each wire !i. For
each gate g, compute the four ciphertexts .g
00; g
01; g
10; g
11/. e public key PK  
[g.g
00; g
01; g
10; g
11/, and the secret key SK  [i.!0
i ; !1
i /.
• ProbGenSK.x/ ! x: Run the key generation algorithm of a fully homomorphic en-
cryption scheme to create a new key pair .PKE; SKE/  KeyGenE./. Let !x  SK
be the wire values representing the binary expression of x. Set the public value x  
EncE.PKE; !x/ and the private value x  SKE.
• ComputePK.x/ ! y: Construct a circuit  that on input !; !0;  outputs D!.D!0.//,
where D is the decryption algorithm corresponding to the encryption E used in Yao’s
garbling (therefore  computes the appropriate decryption in Yao’s construction). Cal-
culate EvaluateE.; EncE.PKE; !x/; EncE.PKE; i// repeatedly, to decrypt your way
through the ciphertexts, just as in the evaluation of Yao’s garbled circuit. e result is
y  EncE.PKE; !0
i/, where !0
i is the wire values representing y D F.x/ in binary.
• VerifySK.y/ ! y [ ?: Decrypt y with SKE to obtain !0
i. Use SK to map the wire values
to an output y. If the decryption or mapping fails, then output ?.
ough the above solution allows a client to outsource the computation of an arbitrary
function, it is ineﬃcient for practical applications due to the complicated fully homomorphic en-
cryption techniques. Besides, another disadvantage of the schemes based on fully homomorphic
encryption is that the client must repeat the expensive pre-processing stage if the malicious server
tries to cheat and learns a bit of information, i.e., the client has accepted or rejected the compu-
tation result. In this sense, even the problem of outsourcing computation has been theoretically
solved, it is still meaningful to seek secure and eﬃcient outsourcing computation protocols for
speciﬁc functions.
In the remainder of this book, we mainly focus on the concrete constructions of secure
outsourcing computation for speciﬁc functions using various design tricks.


11
C H A P T E R
2
Preliminaries
In this chapter, we introduce some preliminaries for this book. We assume that the readers have
some basic knowledge of number theory, basic algebra, and cryptography and thus will not present
them here.
2.1
NUMBER-THEORETIC PROBLEMS
Let G be a cyclic multiplicative group of prime order p, and g is a generator of G. We introduce
some intractable problems in G, and intractability means that by far there is no polynomial time
algorithm to solve these problems with non-negligible probability.
• Discrete Logarithm Problem (DLP): Given two elements .g; h/ as inputs, to ﬁnd an integer
x 2 Z
p such that h D gx whenever such an integer exists. We say that the DL assumption
holds in G if for every probabilistic polynomial time algorithm A, there exists a negligible
function negl./ such that PrŒA.1k; g; h/ D x  negl.k/ for all security parameter k.
• Computational Diﬃe-Hellman Problem (CDHP): Given a triple .g; gx; gy/ for any
x; y 2R Zp as inputs, output gxy.
• Square Computational Diﬃe-Hellman Problem (Squ-CDHP): Given .g; gx/ for x 2R Zp
as inputs, output gx2. It has been proved that the Squ-CDH assumption is equivalent to
the classical CDH assumption [10].
• Decisional Diﬃe-Hellman Problem (DDHP): Given a triple .g; gx; gy; gz/ for any
x; y; z 2R Zp as inputs, to decide whether z  xy mod p:
• Strong Diﬃe-Hellman Problem (SDHP): Given a tuple .g; gx; gx2;    ; gxl/ for any x 2R
Zp as inputs, output a pair .c; g
1
xCc /.
• Strong
Decisional
Diﬃe-Hellman
Problem
(SDDHP):
Given
two
tuples
.g; gx; gx2;    ; gxl/ and .g; gx1; gx2;    ; gxl/ for any x; x1;    ; xl 2R Zp as inputs, to
decide which is the random tuple.
2.2
BILINEAR PAIRINGS (GROUPS OF PRIME ORDER)
Let G1, G2, and GT be three cyclic multiplicative groups of prime order p. Let g1 and g2 be a
generator of G1 and G2, respectively. Deﬁne an isomorphism  W G2 ! G1 with  .g2/ D g1 and

12
2. PRELIMINARIES
its inverse   1 W G1 ! G2. A bilinear pairing is a map e W G1  G2 ! GT with the following
properties:
1. Bilinear: e.ua; vb/ D e.u; v/ab for all u 2 G1, v 2 G2, and a; b 2 Z
p.
2. Non-degenerate: e.g1; g2/ ¤ 1:
3. Computable: ere is an eﬃcient algorithm to compute e.u; v/ for all u 2 G1, v 2 G2:
e examples of such groups can be found in certain algebraic varieties or curves over ﬁnite
ﬁelds, and the bilinear pairings can be derived from the Weil or Tate pairings and some variants
thereof. For more details, see [11, 27, 36, 81]. It has been proved that the CDHP and DDHP
are not equivalent in the group G1 and thus called a gap Diﬃe-Hellman (GDH) group. More
precisely, we call G1 a GDH group if the DDHP can be solved in polynomial time but there is
no polynomial time algorithm to solve the CDHP with non-negligible probability.
Using the terminology of [81], we can separate the bilinear pairings into the following three
types.
• Type 1: G1 D G2 or, both  and   1 are eﬃciently computable.
• Type 2: G1 ¤ G2 and, either  or   1 is eﬃciently computable but not both.
• Type 3: G1 ¤ G2 and, neither  nor   1 is eﬃciently computable.
Note that G1 and G2 are cyclic groups of the same order, thus  ;   1 certainly exist. Also,
as argued in [81], “not eﬃciently computable” does not necessarily mean “infeasible to compute.”
2.3
BILINEAR PAIRINGS (GROUPS OF COMPOSITE
ORDER)
Generally, we often use bilinear pairings on groups of prime order. Recently, pairings on groups
of composite order have been used to design new cryptographic schemes such as non-interactive
zero-knowledge proofs [75, 76], attribute-based encryption [32, 91], and database with eﬃcient
update [18].
e primitive of bilinear pairings over composite order groups was ﬁrst introduced by
Boneh, Goh, and Nissim [17]. e deﬁnition for bilinear groups with composite order is al-
most the same as that with prime order. e only diﬀerence is that the order of the groups are a
composite n D pq where the factorization of n is kept secret. As remarked in [81], it seems that
the academic community generally uses the Type 1 setting for bilinear groups of composite order.
Let G1 and GT be two cyclic multiplicative groups of composite order n D pq. A bilinear
pairing is a map e W G1  G1 ! GT that satisﬁes the properties of bilinear, non-degenerate, and
computable. Bilinear groups of composite order are pairs of groups .G1, GT / that are equipped
with the map e. In the following, we introduce the subgroup decision problem in .G1, GT /.

2.4. SPARSE MATRIX AND DENSE MATRIX
13
• Subgroup Decision Problem: Let n D pq where p; q are two large primes. Let .G1; GT ; e/
be bilinear groups of order n. Given an element x 2 G1, output ‘1’ if the order of x is p and
output ‘0’ otherwise; that is, without knowing the factorization of n, decide if an element
x 2 G1 is in a subgroup of G1. We say that the subgroup decision assumption holds if for
every PPT distinguisher A there exists a negligible function neg(.) such that for all ,
jPrŒA.n; G1; GT ; e; x/ D 1   PrŒA.n; G1; GT ; e; xq/ D 1j  neg./
Informally, the assumption indicates that the uniform distribution on G1 is indistinguishable
from the uniform distribution on a subgroup of G1.
ere is an interesting property for pairings over composite order groups: Let Gp and Gq be
subgroups of G1 of orders p and q, respectively. For any u 2 Gp and v 2 Gq, we have e.u; v/ D
1GT . Note that this property holds for every pairing over composite order groups. e reason is
as follows:
Let g be a generator of G1. en gp generates Gq and gq generates Gp. So there exist
some a; b that satisfy u D .gq/a and v D .gp/b. en we can deduce that
e.u; v/ D e.gaq; gbp/ D e.ga; gb/n D 1GT :
For the practical application, note that the size of n should be at least 1,024 bits. Besides, in
order to achieve the equivalent level of security, the size of a prime-order bilinear groups is only
about 160 bits. us, the operations in composite-order bilinear groups are much slower than
that in prime-order bilinear groups. is illustrates why the prime-order bilinear groups are the
optimal choice for pairing-based schemes unless they fail to work.
2.4
SPARSE MATRIX AND DENSE MATRIX
e word “matrix” means something that contains the essence of a thing [85]. In linear algebra, a
matrix is a rectangular array of numbers, symbols, or expressions, arranged in rows and columns.
e individual items in a matrix are called its elements or entries.
A major application of matrices is to solve the solution of systems of linear equations. e
reason is that matrices can be used to compactly represent systems of linear equations. For ex-
ample, let A D .aij / be an m  n matrix, x00 be a column vector (i.e., n  1 matrix) of n variables
x1; x2;    ; xn, and b00 be an m  1 column vector, then the matrix equation Ax00 D b00 is equiv-
alent to the system of linear equations:
8
ˆˆˆ<
ˆˆˆ:
a1;1x1 C a1;2x2 C    C a1;nxn D b1
a2;1x1 C a2;2x2 C    C a2;nxn D b2
:::
:::
am;1x1 C am;2x2 C    C am;nxn D bm
(2.1)

14
2. PRELIMINARIES
In many real-world applications, some additional information about the matrices is known
beforehand. For example, the predominant entries of a matrix are zero. is kind of matrix is
called sparse matrix. By contrast, if most of the entries of a matrix are non-zero, then the matrix
is dense. e fraction of zero entries over the total number of elements in a matrix is called the
sparsity. Large-scale sparse matrices play an important role in solving partial diﬀerential equations
in scientiﬁc or engineering applications. Besides, when A is sparse, it is easier and faster to solve
the systems of linear equations Ax00 D b00.
We list some facts for sparse matrices without proof. Interested readers could give a proof.
In the following, we assume that both M and N are two large n  n square matrices.
• If both M and N are dense, it is well known that the computational complexity of MN is
O.n3/. While if M is sparse and N is dense, the computational complexity is only O.n2/.
• Even if both M and N are sparse, we could not know the sparsity of MN. Actually, MN
may be sparse or extremely dense!
• If M is a sparse matrix, then M may be singular or non-singular (i.e., invertible).
• If M is a sparse matrix, then the inverse matrix M  1 (if it exists) may be extremely dense.
at is, the computational complexity of M  1 is O.n3/ in some cases. us, it is not wise
to solve linear equations with M  1. Actually, we should never solve linear equations with
the inverse matrix.
• Both iterative and direct methods can be used to solve systems of linear equations whether
the matrix is sparse or not.
2.5
VECTOR COMMITMENTS
Commitment is a fundamental primitive in cryptography and plays an important role in almost
all security protocols, such as voting, identiﬁcation zero-knowledge proof, etc. Intuitively, a com-
mitment scheme can be viewed as the digital equivalent of a sealed envelope. In the commitment
stage, the sender places a message in the sealed envelope and gives it to the receiver. In the opening
stage, the sender reveals the message to the receiver. On the one hand, no one except the sender
could open the envelope to learn the message from the commitment (this is called hiding). On
the other hand, the sender could not change the message anymore (this is called binding).
Recently, Catalano and Fiore [41] proposed a new primitive called Vector Commitment,
which is closely related to zero-knowledge sets [40, 48, 95, 103]. Informally speaking, a vector
commitment scheme allows one to commit to an ordered sequence of values .m1; : : : ; mq/ in
such a way that the committer can later open the commitment at speciﬁc positions. Furthermore,
anyone should not be able to open a commitment to two diﬀerent values at the same position
(this is called position binding). Furthermore, the vector can be required to be hiding. at is,
any adversary cannot distinguish whether a commitment was created to a sequence .m1; : : : ; mq/

2.6. ALGEBRAIC PSEUDORANDOM FUNCTIONS
15
or to .m0
1; : : : ; m0
q/, even after seeing some openings at some positions. Besides the properties of
position binding and hiding, vector commitment needs to be concise, i.e., the size of the com-
mitment string and the opening are both independent of q. In the following, we present a formal
deﬁnition of vector commitment [41].
Deﬁnition 2.1
A vector commitment scheme VCD(VC.KeyGen, VC.Com, VC.Open, VC.Veri,
VC.Update, VC.ProofUpdate) consists of the following algorithms:
• VC.KeyGen.1k; q/: On input the security parameter k and the size q D poly.k/ of the com-
mitted vector, the key generation algorithm outputs some public parameters PP which also
implicitly deﬁne the message space M.
• VC.ComPP.m1;    ; mq/: On input a sequence of q messages .m1;    ; mq/ 2 Mq, and the
public parameters PP, the committing algorithm outputs a commitment string C and an
auxiliary information aux.
• VC.OpenPP.m; i; aux/: is algorithm is run by the committer to produce a proof i that m
is the i-th committed message.
• VC.VeriPP.C; m; i; i/: e veriﬁcation algorithm outputs 1 only if i is a valid proof that C
is a commitment to a sequence .m1;    ; mq/ such that m D mi.
• VC.UpdatePP.C; m; i; m0/: is algorithm is run by the original committer who wants to up-
date C by changing the i-th message to m0. It takes as input the old message m at the
position i, the new message m0, outputs a new commitment C 0 together with an update
information U .
• VC.ProofUpdatePP.C; U; m0; j; j /: e algorithm can be run by any user who holds a proof
j for some message m at the position j w.r.t. C. It allows the user to compute an updated
proof 0
j (and the updated commitment C 0) such that 0
j is valid w.r.t C 0 which contains
m0 as the new message at the position i. Basically, the value U D .m; m0; i/ contains the
update information which is needed to compute such values.
2.6
ALGEBRAIC PSEUDORANDOM FUNCTIONS
An
algebraic
pseudorandom
function
(PRF)
consists
of
three
algorithms
PRF
=
fKeyGen; F; CFEvalg. Given a security parameter 1n and a parameter m 2 N, the algorithm
KeyGen determines the domain size of the PRF and outputs a pair .K; param/ 2 Kn, where
Kn is the key space for security parameter n, K is the secret key of the PRF, and param encodes
the public parameters. e algorithm F takes as input a key K, public parameters param, an
input x 2 f0; 1gm, and outputs a value y 2 Y , where Y is some set determined by param.
An algebraic pseudorandom function should satisfy the following properties [18]:

16
2. PRELIMINARIES
• Algebraic: PRF is algebraic if the range Y of FK./ for every n 2 N and .K; param/ 2 Kn
forms an abelian group. Given param, the group operation on Y should be eﬃciently
computable.
• Pseudorandom: PRF is pseudorandom if for every PPT adversary A, and every polyno-
mial m./, there exists a negligible function neg: N ! N, such that for all n 2 N:
jPrŒAFK./.1n; param/ D 1   PrŒAR./.1n; param/ D 1j  neg.n/
where .K; param/  R KeyGen.1n; m.n//, and R W f0; 1gm ! Y is a random function.
• Closed form eﬃciency: Let N be the order of the range sets of F for security parameter n.
Let z D .z0;    ; zl/ 2 .f0; 1gm/lC1; k 2 N, and an eﬃciently computable h W Zk
N ! Zl
N
with h.x/ D< h0.x/;    ; hl.x/ >. We say that .h; z/ is closed form eﬃcient for PRF if
there exists an algorithm CFEvalh;z such that for every x 2 Zk
N,
CFEvalh;z.x; K/ D
lQ
iD0
ŒFK.zi/hi.x/
and the running time of CFEval is polynomial in n; m; k but sublinear in l. When z D
.0;    ; l/, we will omit it from the subscript, and write CFEvalh.x; K/ instead.
e last condition provides a much more eﬃcient way to compute a “weighted prod-
uct” of l PRF values. at is, given .param; h; x; FK.z/, one can always compute the value
lQ
iD1
ŒFK.zi/hi.x/ in time linear in l (this follows from the algebraic property of the PRF).
In the following, we introduce a concrete construction of small domain algebraic PRFs
from strong decisional Diﬃe-Hellman (SDDH) assumption. Let G be a computational group
scheme. We deﬁne PRF as an algebraic PRF with polynomial sized domains.
• KeyGen(1n; m): Generate a group description .p; g; G/  R G.1n/, where n is a security
parameter. Choose k0; k1 2R Zp. Output param D .m; p; g; G/; K D .k0; k1/.
• FK.x/: Interpret x as an integer in f0;    ; D D 2mg where D is polynomial in n. Compute
and output gk0kx
1 .
• CFEvalh.x; K/: Deﬁne CFEvalh.x; K/=g
k0.1 kdC1
1
xdC1/
1 k1x
.
We now show an eﬃcient closed form for PRF for polynomials of the form:
p.x/ D FK.0/ C FK.1/x C    C FK.d/xd, where d  D.
Let h W Zp ! ZdC1
p
be deﬁned as h.x/
def
D .1; x;    ; xd/. Let .z0;    ; zd/ D .0;    ; d/. en we
have

2.7. BLOOM FILTER
17
CFEvalh.x; K/ D
dQ
iD0
ŒFK.zi/hi.x/ D
dQ
iD0
Œgk0ki
1xi D gk0
Pd
iD0 ki
1xi D g
k0.1 kdC1
1
xdC1/
1 k1x
.
is proves the correctness of CFEvalh.x/.
2.7
BLOOM FILTER
e Bloom ﬁlter, proposed by Bloom [24] in 1970, is a space-eﬃcient data structure for ap-
proximately representing a large set S subject to insertion operations and membership queries.
A Bloom ﬁlter (BF ) consists of a hash table B containing m single-bit cells which are initially
set to 0, together with k random hash functions hi W f0; 1g? ! Œ1; m for 1  i  k. Note that
the hash function is not the traditional one such as SHA-1. In the initial phase, all positions of
the array are set to 0. To add an element to the set, feed it to each of the k hash functions and
obtain k array positions. en set the bit value for each position to 1, i.e., BŒhi.x/:bit D 1 for
i D 1; 2;    ; k.
In order to test whether an element x in S or not, we must ensure that there is no i 2
f1; 2    ; kg such that BŒhi.x/:bit D 0. at is, if there exists some i 2 f1; 2    ; kg such that
BŒhi.x/:bit D 0, then x is deﬁnitely not in S. Otherwise, we can deduce that x is a member of
S with a probability of false positive.
An instance of Bloom ﬁlter is shown in Fig. 2.1. It is easy to see that the element z does
not belong to the set S. In the case of element w, though all the corresponding positions are 1,
it does not belong to S. It is called as false positive. In [4], the authors analyze the relationship
among the size of the Bloom ﬁlter m, the number of hash functions k, the number of elements
n, and the probability of false positive Pf . Speciﬁcally, for given m and n, Pf D .1   e kn=m/k.
Also, when k D ln2  .m=n/, Pf reaches the minimum value .0:6185/m=n.
1
1
1
0
0
0
0
0
1
0
1
1
{x  y}
，
z
w
Figure 2.1: A toy Bloom ﬁlter construction.
Some variants of Bloom ﬁlter consist of the counting Bloom ﬁlter (CBF), invertible Bloom
ﬁlter (IBF) [28, 65]. For example, CBF is a variant of Bloom ﬁlter by replacing each bit cell of B
with a counter cell called count (initialized to 0 for each cell). An insertion/deletion of element x
amounts to incrementing/decrementing each BŒhi.x/:count by 1 for i D 1; 2;    ; k. Similarly,

18
2. PRELIMINARIES
testing for the membership of x in S amounts to testing that there is no i 2 f1; 2    ; kg such
that BŒhi.x/:count D 0. However, it is still very diﬃcult to ﬁnd (not just test) the members of a
set represented by a CBF.
We believe that these primitives play an important role in designing veriﬁable database
schemes with eﬃcient updates and will present in our future work [54].

19
C H A P T E R
3
Secure Outsourcing of
Scientiﬁc Computations
In this chapter we focus on secure outsourcing some scientiﬁc computations. e theoretical com-
puter science community has devoted considerable attention to the problem of how to securely
outsource diﬀerent kinds of expensive computations. Abadi et al. [2] ﬁrst proved the impossibility
of secure outsourcing an exponential computation while locally doing only polynomial time work.
erefore, it is meaningful only to consider outsourcing expensive polynomial time computations.
Atallah et al. [7] presented a framework for secure outsourcing of scientiﬁc computations
such as matrix multiplications and quadrature. However, the solution used the disguise technique
and thus allowed leakage of private information. Atallah and Li [3] investigated the problem
of computing the edit distance between two sequences and presented an eﬃcient protocol to
securely outsource sequence comparisons to two servers. Blanton et al. proposed a more eﬃcient
scheme for secure outsourcing sequence comparisons [23]. Benjamin and Atallah [8] addressed
the problem of secure outsourcing for widely applicable linear algebra computations. However, the
proposed protocols required the expensive operations of homomorphic encryptions. Atallah and
Frikken [1] further studied this problem and gave improved protocols based on Shamir’s secret
sharing. Some other works [93, 100] also used Shamir’s secret sharing to perform homomorphic
computations over the cloud. Trivially, the protocols based on secret sharing require at least two
non-colluding servers. Wang et al. [123] presented eﬃcient mechanisms for secure outsourcing
of linear programming computations. However, the solution requires matrix-matrix operations
(cubic-time computational burden). Recently, Wang et al. [126] proposed a secure outsourcing
mechanism for solving large-scale systems of linear equations based on the iterative methods.
However, it requires multi-round interactions between the client and the cloud server.
In the following, we introduce the protocols for securely outsourcing matrix multiplication,
matrix inversion, and large-scale system of linear equations, respectively.
3.1
MATRIX MULTIPLICATION
In this section, we introduce two classical protocols for outsourcing matrix multiplication [7]. at
is, given two n  n matrices M1 and M2, the goal of the client C is to compute the product M1M2.
Since the inputs should not be revealed to the server S, the main trick in these protocols is how
to eﬃciently disguise the matrices. In some references, the disguising is also-called blinding (a

20
3. SECURE OUTSOURCING OF SCIENTIFIC COMPUTATIONS
typical example is blind signature [33]). From the viewpoint of cryptography, blinding is actually
a kind of one-time encryption, i.e., the blind factor should not be re-used.
Now we consider the problem of matrix multiplication and we only foucs on the dense ma-
trix. A straightforward solution to disguise a matrix is to multiply a random matrix. However, the
problem is that the computational complexity for multiplying two random n  n dense matrices
is O.n3/. Note that we assume that the resource-limited client cannot perform O.n3/ operations.
Atallah et al. [7] presented the following two ways to eﬃciently disguise a dense matrix by using
the random permutations and (special) sparse matrices. More precisely, the sparse matrices (e.g.,
P1 below) in the constructions are not random chosen sparse ones. Actually, they are the product
of some elementary matrices! Also, the inverse of these matrices could be computed easily, while
the sparse matrices used in [51] are random ones and computing the inverse is a prohibitively
expensive task for the client. Besides, another issue is that the client cannot verify the validity
of result in both schemes [7]. us, the construction should be given in the honest but curious
model.
3.1.1
A BASIC SOLUTION
Let ıx;y be the Kronecker delta function that equals 1 if x D y and 0 if x ¤ y. e ﬁrst out-
sourcing protocol consists of the following steps:
1. C generates three random permutations 1, 2, and 3 of the integers f1; 2;    ; ng,
and three sets of non-zero random numbers f˛1; ˛2;    ; ˛ng, fˇ1; ˇ2;    ; ˇng and
f1; 2;    ; ng. Deﬁne P1.i; j / D ˛iı1.i/;j, P2.i; j / D ˇiı2.i/;j, P3.i; j / D iı3.i/;j.
Note that these matrices are readily invertible, e.g., P  1
1 .i; j / D .˛i/ 1ı 1
1
.i/;j.
2. C
computes the matrices X D P1M1P  1
2
and Y D P2M2P  1
3 , where X.i; j / D
.˛i=ˇj /M1.1.i/; 2.j //, and Y.i; j / D .ˇi=j /M2.2.i/; 3.j //.
3. C sends X and Y to S. en S computes the product
Z D XY D .P1M1P  1
2 /.P2M2P  1
3 / D P1M1M2P  1
3
and sends Z back.
4. C computes the matrix M1M2 D P  1
1 ZP3 locally in O.n2/ time.
In order to determine M1 (or M2), S must guess two permutations (from .nŠ/2 possible
choices) and 3n numbers (˛i; ˇi; i). us, it is secure enough in many applications when n is
suﬃciently large (while not in the sense of cryptography).¹ Also, the disguise requires O.n2/ local
computation, and the outsourced computations require O.n3/ operations.
Note that this disguise technique is not a perfect disguise since the data in the matrix
is not fully blind. e matrix M1 is transformed into X as X D P1M1P  1
2 , where X.i; j / D
¹is indicates that the disguise could not achieve the cryptographic security since n is at most polynomial size.

3.1. MATRIX MULTIPLICATION
21
.˛i=ˇj /M1.1.i/; 2.j//. e non-zero number a in M1 will be transformed into ˛ia=ˇj, and
the location is changed according to the two random permutations .1.i/; 2.j //. However, the
number 0 in M1 is still 0 even though the location is changed. Hence, this disguise technique
cannot protect the number 0 in M1.
3.1.2
AN ENHANCED SOLUTION
e second outsourcing protocol enhances the security compared with the ﬁrst one (while the
eﬃciency is reduced). e main trick consists of two steps: e ﬁrst one is to hide a matrix by
the sparse random matrices Pi or their inverse P  1
i
just as above. e second one is to hide the
resulting matrix by adding a dense random matrix.
1. C computes matrices X D P1M1P  1
2
and Y D P2M2P  1
3
as in the ﬁrst outsourcing pro-
tocol in Section 3.1.1
2. C generates four random numbers ˇ; ; ˇ0; 0 such that
.ˇ C /.ˇ0 C 0/.0ˇ   ˇ0/ ¤ 0:
3. C selects two random n  n matrices S1 and S2 and computes the six matrices
X C S1; ˇX   S1; ˇ0X   0S1;
Y C S2; ˇY   S2; ˇ0Y   0S2:
en C outsources the three matrix multiplications to S
W D .X C S1/.Y C S2/
U D .ˇX   S1/.ˇY   S2/
U 0 D .ˇ0X   0S1/.ˇ0Y   0S2/
which are returned.
4. C computes the matrices
V D .ˇ C / 1.U C ˇW /
V 0 D .ˇ0 C 0/ 1.U 0 C ˇ00W /
Observe that V D ˇXY C S1S2 and V 0 D ˇ0XY C 0S1S2.
5. C computes XY D .0ˇ   ˇ0/ 1.0V   V 0/.
6. C computes M1M2 D P  1
1 XYP3.

22
3. SECURE OUTSOURCING OF SCIENTIFIC COMPUTATIONS
3.2
MATRIX INVERSION
In this section, we introduce a secure outsourcing protocol for matrix inversion which uses the
secure matrix multiplication protocol above as a subroutine [7]. e aim of this protocol is to
compute the inversion matrix M  1 of an n  n matrix M .
1. C selects a random n  n matrix N. If N is non-invertible, then the following Step 4 below
sends us back to Step 1.
2. e client outsources
OM D MN to S using the secure matrix multiplication protocol in
Section 3.1. Trivially, the server could know neither M, nor N, nor OM.
3. C generates ﬁve matrices P1; P2; P3; P4; P5 using the same method as in Section 3.1. at
is, P1.i; j / D aiı1.i/:j ; P2.i; j / D biı2.i/:j ; P3.i; j / D ciı3.i/:j ; P4.i; j / D diı4.i/:j,
and P5.i; j / D eiı5.i/:j, where 1; 2; 3; 4; 5 are random permutations, and where
the ai; bi; ci; di; ei are random numbers. C computes the matrices
Q D P1 OMP  1
2 I R D P3NP  1
4 :
4. C outsources the computation of Q 1 to S. If it succeeds, S returns Q 1. Otherwise, S
returns “non-inertible.” en we know that at least one of N or M (possibly both) is non-
invertible. C performs the following procedure:
• C ﬁrstly obtains ON D N1NN2 where N1 and N2 are matrices already known to be
invertible and then outsources ON to the server for inverting. Note that the computation
of ON should also be outsourced to S by running the subroutine of matrix multiplication
twice.
• If S can invert ON (note that C really cares not about the value ON but whether ON
is invertible or not), then N is invertible. Hence, we know that M is not invertible.
Otherwise, ON is not invertible and thus N is not invertible. In this case, return to Step
1.
5. C computes the matrix T D P4P  1
2 Q 1P1P  1
5
and outsources S the computation of Z D
RT using the secure matrix multiplication protocol in Section 3.1.
6. C computes M  1=P  1
3 ZP5 since Z D P3M  1P  1
5 .
e security of the above protocol follows from the facts that the calculations of OM and Z
are done using secure matrix multiplication. Also, the usage of matrices P1; : : : ; P5 for computing
Q; R; T is never repeated (that is, the random blinding factor should be never re-used). Another
important fact is that the random permutations and numbers used for secure matrix multiplication
subroutine in Steps 2 and 5 must be independently generated from Step 3.

3.3. LARGE-SCALE LINEAR EQUATIONS SYSTEMS
23
One disadvantage of this protocol is that it must run the subroutine of matrix multiplication
four times and matrix inversion (at least) one time. at is, it requires at least ﬁve rounds of
interaction between C and S. is is really ineﬃcient for real applications. Another disadvantage
of this protocol is that C must choose lots of random permutations and numbers (even worse
in the case of non-invertible N). Finally, we point out that the protocol is only valid under the
assumption of honest-but-curious server. C could not check the validity of results given by S in
Steps 2, 4, and 5.
3.3
LARGE-SCALE LINEAR EQUATIONS SYSTEMS
e large-scale system of linear equations Ax D b is one of the most basic algebraic problems in
the scientiﬁc community [20, 68]. ere are a lot of real-world computation problems that would
result in a large-scale system of linear equations with up to thousands or even millions of unknown
variables. For example, a typical double-precision 50,000  50,000 system matrix resulted from
electromagnetic application would easily occupy up to 20 GBytes storage space. erefore, the
storage requirements for such a system coeﬃcient matrix may easily exceed the available memory
of the customer’s computing device, such as a modern portable laptop. Besides, it is ineﬃcient
to perform computations on such a huge system coeﬃcient matrix. Plenty of researchers have
devoted a considerable amount of eﬀort on seeking eﬃcient algorithms for the task.
e problem for securely outsourcing large-scale systems of linear equations can be formu-
lated as follows: e client C seeks the solution to a large-scale system of linear equations Ax D b,
where A 2 Rnn is a real coeﬃcient matrix with rank n, and b 2 Rn is a coeﬃcient vector. Due
to the lack of computing resources, it could be infeasible for C to carry out such expensive com-
putation as O.n/ for 2 <   3 locally. erefore, C will outsource the computation workloads
to cloud server S in a pay-per-use manner. Note that we only consider the case that A is a general
nonsingular dense matrix. For the case of (extremely) sparse matrices, there may be other more
eﬃcient methods to solve the linear equations.
Atallah et al. [7] presented an outsourcing protocol for a system of linear equations based
on the above outsourcing techniques of matrix multiplication and inversion. e main trick is
to hide the solutions into a matrix through random permutations and scalings and then use the
technique of matrix inversion. We give a brief overview as below.
1. C selects a random n  n matrix B and a random number j 2 f1; 2;    ; ng. en, C re-
places the j-th column of B by b, i.e., B D ŒB1;    ; Bj  1; b; Bj C1;    ; Bn.
2. C generates three matrices P1; P2; P3 as in Section 3.1. at is, P1.i; j / D aiı1.i/;j,
P2.i; j / D biı2.i/;j, P3.i; j / D ciı3.i/;j, where 1; 2; 3 are random permutations, and
where the ai; bi; ci are random numbers.
3. C computes the matrices

24
3. SECURE OUTSOURCING OF SCIENTIFIC COMPUTATIONS
OA D P1AP  1
2 I OB D P1BP  1
3 :
4. C outsources OA; OB to S in order to get the solution of the linear system OA OX D OB. If the
server returns that OA is singular, then C also returns that A is singular. Otherwise S returns
OX D OA 1 OB:
5. C compute X D P  1
2
OXP3 which equals A 1B.
6. e answer x is the j-th column of X, i.e., x D Xj.
e security of this process follows from the fact that b is hidden through the expansion
to a matrix B, and then A and B are hidden through random scalings and permutations. Also,
it uses the interactive matrix inversion in Section 3.2 as a building block, and thus the scheme is
also interactive and complicated.
3.3.1
NEW SECURE OUTSOURCING PROTOCOL
In the following, we introduce a new protocol LE [51] for securely outsourcing large-scale systems
of linear equations in the fully malicious model. at is, the computation is delegated to only one
server who may be lazy, curious, and dishonest. e main trick is to use two random sparse matrices
to hide A. More precisely, C chooses two random sparse matrices M; N 2 Rnn and computes
T D MAN. e reason to use sparse matrices is that the computational complexity for two dense
matrices’ multiplication is O.n3/. Now we analyze the case that a sparse matrix M multiplies a
dense one A. Without loss of generality, we assume that there are at most  ( << n) non-zero
elements for each row of M. Obviously, it takes at most n2 multiplications to calculate MA
and the computational complexity is O.n2/ since the constant  << n. us, C can eﬃciently
compute T D MAN with the complexity of O.n2/.
e input of LE is a coeﬃcient vector b 2 Rn and a coeﬃcient matrix A 2 Rnn. e
output of LE is a coeﬃcient vector x 2 Rn such that Ax D b. e proposed protocol LE is given
as follows:
1. KeyGen.F; / ! .PK; SK/: Given the security parameter  and the target function F W
Ax D b, C picks a random blinding coeﬃcient vector r 2 Rn and two random blinding
sparse matrices M; N 2 Rnn. Note that .M; N; r/ are one-time blinding factors that must
be generated each time for diﬀerent linear equations. en, we have PK D n and SK D
.M; N; r/.
2. ProbGenSK.x/ ! .x; x/: Given the input x D .A; b/, C ﬁrstly computes c D Ar C b.
Trivially, the original linear equations can be rewritten as A.x C r/ D c. en, C computes
T D MAN and d D Mc. Without loss of generality, we denote y D N 1.x C r/, where

3.3. LARGE-SCALE LINEAR EQUATIONS SYSTEMS
25
N 1 is the inverse of matrix N. We emphasize that no party needs to compute N 1 in this
algorithm. It appears here only for representing the form of y. Note that
Ty D MAN  N 1.x C r/ D MA.x C r/ D Mc D d:
erefore, x D .T; d/, and x D .M; N; r/.
3. ComputePK.x/ ! y: C sends x to S, and S responds with the solution y D y such
that Ty D d.
4. VerifySK.x; y/ ! y [ ?: C veriﬁes whether the equations Ty D d hold. If not, C out-
puts ? and claims the misbehavior of S. Otherwise, C computes x D Ny   r as the result of
function y D F.x/. e computational complexity for the veriﬁcation is still O.n2/. is is
due to the fact that it requires at most n2 multiplications to compute Ty for any (even totally
dense) matrix T and any coeﬃcient vector y. Furthermore, C can detect the misbehavior of
S with the probability 1.
e protocol LE only requires one round of communication between C and S. is is
diﬀerent from Wang et al.’s protocol [126] that requires multi-round communication between
C and S. More precisely, it may require dozens (or even hundreds) of iterations for a diﬀerent
matrix A by using the iteration methods. As a result, it also requires dozens (or even hundreds)
of rounds of communications between C and S. erefore, the scheme could be impractical for
real-world applications.
Some further (implicit) observations on LE are listed as below:
1. Note that the sparse matrices M and N must be invertible (also-called nonsingular). By
Lévy-Desplanques eorem (see theorem 6.1.10 of [83]), we know that a strictly diagonally
dominant matrix A 2 Rnn is deﬁnitely nonsingular. erefore, in the real applications, we
could choose sparse and row diagonally dominant matrix A such that P
j ¤i jaij j < jaiij
for all 1  i  n: On the other hand, neither C nor S needs to compute N 1. Otherwise,
the protocol LE is totally impractical. e reason is twofold: Firstly, though N is a sparse
matrix, the inverse matrix N 1 may be extremely dense. As a result, the computation and
storage cost for N 1 will be very expensive. Secondly, the computation complexity of N 1 is
O.n3/ if we use the naive Gaussian elimination or Gauss-Jordan elimination method.² is
contradicts the assumption that C cannot carry out such expensive computation as O.n/
for 2 <   3.
2. Given T and d, S can solve the systems of linear equations Ty D d in any desired methods
such as elimination methods, decomposition (factorization) methods, iterative methods,
²e complexity of the Strassen algorithm is still O.n2:807/. Coppersmith and Winograd presented the state-of-the-art
record which stands at O.n2:376/. However, the programming of the two algorithms is so awkward and thus neither of them
is suitable for practical applications.

26
3. SECURE OUTSOURCING OF SCIENTIFIC COMPUTATIONS
etc. However, as pointed out in [20], for the systems comprising hundreds of millions or
even billions of equations in as many unknowns, iterative methods may be the only option
available (unless the iteration does not converge). Furthermore, we argue that it does not
require the interactive protocol between C and S in our proposed solution. As a result, S
can eﬃciently compute y using the iterative methods.
3.3.2
SECURITY ANALYSIS
In the following, we prove that the algorithms .C; S/ in LE can achieve the three security prop-
erties deﬁned in Section 1.3.
eorem 3.1
In the fully malicious model, the algorithms .C; S/ in LE achieve the privacy for A, b,
and x.
Proof. We ﬁrst prove the privacy for input b and output x of LE. Note that the adversary A can
only know T and d throughout the whole algorithm LE. Besides, we have b D M 1d   Ar, and
x D Ny   r. Since r is a random blinding coeﬃcient vector in Rn, both b and x are blinded by r
in the sense of computational indistinguishability.
We then prove the privacy for input A of LE. Let M D .mij /, N D .nij /, M0 D .m0
ij /, and
N0 D .n0
ij / be four random nonsingular sparse matrices generated by C. Given two nonsingular
dense matrices A D .aij / and A0 D .a0
ij / which are chosen by the adversary A, C computes T D
MAN D .tij / and T0 D M0A0N0 D .t0
ij /, where
tij D
n
X
lD1
n
X
kD1
mik  akl  nlj
and
t0
ij D
n
X
lD1
n
X
kD1
m0
ik  a0
kl  n0
lj :
Note that the numerical value and position of all non-zero elements of four matrices
M; N; M0, and N0 are randomly chosen by C, thus the two values tij and t0
ij are computationally
indistinguishable. us, the advantage of A to distinguish between T and T0 is negligible.

Remark 1. Note that we currently cannot prove the privacy for any input A of LE (this is not
essential in LE since we only focus on the case that A is a nonsingular dense matrix). For ex-
ample, if the adversary A chooses a nonsingular matrix A and a singular one A0, then he can
distinguish between T D MAN and T0 D M0A0N0 with an overwhelming probability since T0 is
always singular.
Even in some special case that both A and A0 are nonsingular, e.g., let A be a nonsingu-
lar dense matrix and A0 be the identity matrix that is extremely sparse, it seems to be diﬃcult

3.3. LARGE-SCALE LINEAR EQUATIONS SYSTEMS
27
to eﬃciently distinguish between T and T0 with a non-negligible probability.³ Actually, there is
a paradox between the privacy and eﬃciency of the outsourcing scheme for any input A. More
precisely, in order to achieve privacy for any input A, the blinding matrix M (and N) for mask-
ing A should also be a random one (and thus may be a dense one). However, it requires O.n3/
computational overhead to compute T (or T0) in this case. is makes the outsourcing totally
meaningless. We left it as an open problem.
eorem 3.2
In the fully malicious model, the algorithms .C; S/ in LE are an O. 1
n/-eﬃcient im-
plementation of LE.
Proof. In the proposed algorithm LE, C needs to perform four matrix-vector multiplication (we
omit the vector-addition operations), which takes O.n2/ computations. Besides, C also needs to
compute T D MAN, which also takes O.n2/ computations. On the other hand, it takes O.n3/
computations in order to solve the linear equations directly. erefore, the algorithms .C; S/ are
an O. 1
n/-eﬃcient implementation of LE.

eorem 3.3
In the fully malicious model, the algorithms .C; S/ in LE are a 1-checkable implemen-
tation of LE.
Proof. Given a solution y, C can verify whether the equations Ty D d hold eﬃciently because
the computational complexity for Ty is O.n2/. erefore, if S misbehaves during any execution
of LE, it will be detected by C with probability ˇ D 1.

³Note that the product of extremely sparse matrices can be complete dense [132], thus C could choose suitable M0 and N0 to
ensure that T0 D M0N0 is a dense matrix. Obviously, it is impossible to distinguish T and T0 only based on the sparsity of a
matrix.


29
C H A P T E R
4
Secure Outsourcing of
Cryptographic Operations
In this chapter, we consider the problem of secure outsourcing expensive cryptographic operations
in public key cryptography (PKC).
e idea of PKC was introduced by Diﬃe and Hellman [63] 40 years ago (just the same
as my age) and it is really a milestone in the history of cryptology. Plenty of PKC schemes were
broken soon after their birth (even some inventors may claim that their constructions could not
be broken forever!). Nowadays, only two kinds of number-theoretic-based cryptographic systems
are believed to be secure and eﬃcient, i.e., the integer-factorization-based system and discrete-
logarithm-based system. Some well-known concrete constructions include the RSA system, El-
Gamal system, ECC system, etc.
e ﬁrst decade belongs to the RSA system, one of the most commonly used PKC systems
in the world. Many cryptographers presented much security analysis on the RSA (see Boneh’s
survey [21]), however, no eﬃcient attacks are successful if we choose the parameters of RSA
carefully. e second decade belongs to the elliptic curve cryptography (ECC) system, which was
invented by Koblitz and Miller in 1985. Compared to the RSA system, one signiﬁcant advantage
of the ECC system is to oﬀer the same level of security with much shorter parameters. For exam-
ple, a 160-bit ECC key oﬀers more or less the same level of security as a 1,024-bit RSA key [94].
Note that the main operation in both RSA and ECC systems is the exponentiation modulo a very
large integer. As Goldwasser and Micali pointed out, “even schemes like RSA are considered too
slow for many practical applications. In particular, these signature schemes require performing
modular exponentiation with a large modulus...” [66]. at is, the practicality of PKC schemes is
closely related to the eﬃciency of modular exponentiation.
e next decade is the time of bilinear pairings, which initiated some completely new ﬁelds
in cryptography. Due to this new powerful tool, it became possible to realize many cryptographic
primitives that were previously unknown or impractical, such as one-round tripartite key agree-
ment protocol, ID-based encryption schemes, and short signature schemes. However, the com-
putations of modular exponentiation and bilinear pairings are considered to be prohibitively ex-
pensive operations in embedded devices, such as RFID tag, and smart cards. us, the problem
of securely outsourcing such expensive computations has been well studied in the cryptography
community.

30
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
In 1992, Chaum and Pedersen [34] introduced the notion of “wallets with observers,”
a piece of secure hardware installed on the client’s computer to perform some expensive
computations—a prototype of outsourcing computation. In 2005, Hohenberger and Lysyanskaya
[82] proposed the ﬁrst outsource-secure algorithm for modular exponentiations based on the two
previous approaches of precomputation [31, 115] and server-aided computation [71, 97]. In their
algorithm, the client needs to do some logic split on the parameters before sending them to the
two untrusted servers. Depending on the results that are returned by the two servers, the client can
verify the correctness of the result with probability 1
2. Chevallier-Mames et al. [37] presented the
ﬁrst algorithm for secure delegation of elliptic-curve pairings based on an untrusted server model.
Besides, the client could detect any failures with probability 1 if the server misbehaves. However,
an obvious disadvantage of the algorithm is that the client should carry out some other expensive
operations such as point multiplications (or called scalar multiplications) and exponentiations.
erefore, the algorithm is not practical for real-world applications in this sense.
4.1
SECURITY DEFINITIONS
Informally, we say that C securely outsources some computations to S, and .C; S/ is an outsource-
secure implementation of a cryptographic algorithm Alg if (1) C and S implement Alg, i.e., Alg D
C S and (2) suppose that C is given oracle access to an adversary S0 (instead of S) that records
all of its computation over time and tries to act maliciously, S0 cannot learn anything interesting
about the input and output of C S0.
In the following, we introduce the formal deﬁnitions for secure outsourcing of a crypto-
graphic algorithm [82].
Deﬁnition 4.1
(Algorithm with outsource-I/O) An algorithm Alg obeys the outsource in-
put/output speciﬁcation if it takes ﬁve inputs, and produces three outputs. e ﬁrst three inputs
are generated by an honest party, and are classiﬁed by how much the adversary A D .E; S0/ knows
about them, where E is the adversarial environment that submits adversarially chosen inputs to
Alg, and S0 is the adversarial software operating in place of oracle S. e ﬁrst input is called the
honest, secret input, which is unknown to both E and S0; the second is called the honest, protected
input, which may be known by E, but is protected from S0; and the third is called the honest,
unprotected input, which may be known by both E and S. In addition, there are two adversarially
chosen inputs generated by the environment E: the adversarial, protected input, which is known
to E, but protected from S0; and the adversarial, unprotected input, which may be known by E
and S. Similarly, the ﬁrst output is called secret, which is unknown to both E and S0; the second
is protected, which may be known to E, but not S0; and the third is unprotected, which may be
known by both parties of A.

4.1. SECURITY DEFINITIONS
31
e following deﬁnition of outsource-security ensures that the malicious environment E
cannot gain any knowledge of the secret inputs and outputs of C S, even if C uses the malicious
software S0 written by E.
Deﬁnition 4.2
(Outsource-security) Let Alg be an algorithm with outsource I/O. A pair of
algorithms .C; S/ is said to be an outsource-secure implementation of Alg if:
1. Correctness: C S is a correct implementation of Alg.
2. Security: For all probabilistic polynomial-time adversaries A D .E; S0/, there exist proba-
bilistic expected polynomial-time simulators .S1; S2/ such that the following pairs of ran-
dom variables are computationally indistinguishable.
• Pair One. EVIEWreal Ï EVIEWideal:
– e view that the adversarial environment E obtains by participating in the fol-
lowing real process:
EVIEWi
real D f.istatei; xi
hs; xi
hp; xi
hu/  I.1k; istatei 1/I
.estatei; j i; xi
ap; xi
au; stopi/  E.1k; EVIEWi 1
real ; xi
hp; xi
hu/I
.tstatei; ustatei; yi
s; yi
p; yi
u/  T U 0.ustatei 1/.tstatei 1; xj i
hs; xj i
hp; xj i
hu; xi
ap; xi
au/ W
.estatei; yi
p; yi
u/g
EVIEWreal D EVIEWi
real if stopi D TRUE:
e real process proceeds in rounds. In round i, the honest (secret, protected, and un-
protected) inputs .xi
hs; xi
hp; xi
hu/ are picked using an honest, stateful process I to which
the environment E does not have access. en E, based on its view from the last round,
chooses (0) the value of its estatei variable as a way of remembering what it did next
time it is invoked; (1) which previously generated honest inputs .xi
hs; xi
hp; xi
hu/ to give
to C S0 (note that E can specify the index j i of these inputs, but not their values); (2)
the adversarial, protected input xi
ap; (3) the adversarial, unprotected input xi
au; (4) the
Boolean variable stopi that determines whether round i is the last round in this pro-
cess. Next, the algorithm C S0 is run on the inputs .tstatei 1; xj i
hs; xj i
hp; xj i
hu; xi
ap; xi
au/,
where tstatei 1 is C’s previously saved state, and produces a new state tstatei for C, as
well as the secret yi
s, protected yi
p and unprotected yi
u outputs. e oracle S0 is given
its previously saved state, ustatei 1, as input, and the current state of S0 is saved in
the variable ustatei. e view of the real process in round i consists of estatei, and the
values yi
p and yi
u. e overall view of E in the real process is just its view in the last
round (i.e., i for which stopi D TRUE:).
– e ideal process:

32
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
EVIEWi
ideal D f.istatei; xi
hs; xi
hp; xi
hu/  I.1k; istatei 1/I
.estatei; j i; xi
ap; xi
au; stopi/  E.1k; EVIEWi 1
ideal; xi
hp; xi
hu/I
.astatei; yi
s; yi
p; yi
u/  Alg.astatei 1; xj i
hs; xj i
hp; xj i
hu; xi
ap; xi
au/I
.sstatei; ustatei; Y i
p; Y i
u; repi/  SU 0.ustatei 1/
1
.sstatei 1;    ; xj i
hp; xj i
hu; xi
ap; xi
au; yi
p; yi
u/I
.zi
p; zi
u/ D repi.Y i
p; Y i
u/ C .1   repi/.yi
p; yi
u/ W
.estatei; zi
p; zi
u/g
EVIEWideal D EVIEWi
ideal if stopi D TRUE:
e ideal process also proceeds in rounds. In the ideal process, we have a stateful sim-
ulator S1 who, shielded from the secret input xi
hs, but given the non-secret outputs
that Alg produces when running all the inputs for round i, decides to either output
the values .yi
p; yi
u/ generated by Alg, or replace them with some other values .Y i
p; Y i
u/.
Note that this is captured by having the indicator variable repi be a bit that determines
whether yi
p will be replaced with Y i
p. In doing so, it is allowed to query oracle S0;
moreover, S0 saves its state as in the real experiment.
• Pair Two. UVIEWreal Ï UVIEWideal:
– e view that the untrusted software S0 obtains by participating in the real process
described in Pair One. UVIEWreal D ustatei if stopi D TRUE:
– e ideal process:
UVIEWi
ideal D f.istatei; xi
hs; xi
hp; xi
hu/  I.1k; istatei 1/I
.estatei; j i; xi
ap; xi
au; stopi/  E.1k; estatei 1; xi
hp; xi
hu; yi 1
p
; yi 1
u
/I
.astatei; yi
s; yi
p; yi
u/  Alg.astatei 1; xj i
hs; xj i
hp; xj i
hu; xi
ap; xi
au/I
.sstatei; ustatei/  SU 0.ustatei 1/
2
.sstatei 1; xj i
hu; xi
au/ W
.ustatei/g
UVIEWideal D UVIEWi
ideal if stopi D TRUE:
In the ideal process, we have a stateful simulator S2 who, equipped with only the un-
protected inputs .xi
hu; xi
au/, queries S0. As before, S0 may maintain state.
Deﬁnition 4.3
(˛-eﬃcient, secure outsourcing) A pair of algorithms .C; S/ is said to be an
˛-eﬃcient implementation of Alg if (1) C S is a correct implementation of Alg and (2) 8 inputs x,
the running time of C is no more than an ˛-multiplicative factor of the running time of Alg.
Deﬁnition 4.4
(ˇ-checkable, secure outsourcing) A pair of algorithms .C; S/ is said to be a
ˇ-checkable implementation of Alg if (1) C S is a correct implementation of Alg and (2) 8 inputs

4.2. TWO UNTRUSTED PROGRAM MODEL
33
x, if S0 deviates from its advertised functionality during the execution of C S0.x/, C will detect
the error with probability no less than ˇ.
Deﬁnition 4.5
(.˛; ˇ/-outsource-security) A pair of algorithms .C; S/ is said to be an .˛; ˇ/-
outsource-secure implementation of Alg if it is both ˛-eﬃcient and ˇ-checkable.
It is worth noting that, depending on the ˇ parameter, a secure outsourcing algorithm may
not provide 100 percent checkability (e.g., [49, 82]). In practice, it is very likely that a client will
run the outsourcing algorithm many times with the same server. If a server cheats frequently,
there is a high chance that it will be caught in some instances of the algorithm. en the client
may seriously punish the server when a cheating is detected. As a result, the server will not ﬁnd
the incentive to cheat in practice. Nevertheless, it is clear that a larger ˇ is always better. However,
there is a tradeoﬀbetween the eﬃciency (˛) and checkability (ˇ). For instance, a trivial way to
improve the value of ˇ is to add a lot of dummy computations to check whether the server is
honest or not. is will signiﬁcantly reduce the eﬃciency because the server needs to perform a
lot of additional computations.
4.2
TWO UNTRUSTED PROGRAM MODEL
Hohenberger and Lysyanskaya [82] ﬁrst presented the so-called two untrusted program model for
outsourcing exponentiations modulo a prime. In this model, the adversarial environment E writes
the code for two (potentially diﬀerent) programs S0 D .S0
1; S0
2/. E then gives this software to C,
advertising a functionality that S0
1 and S0
2 may or may not accurately compute, and C installs
this software in a manner such that all subsequent communication between any two of E, S0
1,
and S0
2 must pass through C. e new adversary attacking C is A D .E; S0
1; S0
2/. Moreover, we
assume that at most one of the programs S0
1 and S0
2 deviates from its advertised functionality on a
non-negligible fraction of the inputs, while we cannot know which one, and security means that
there is a simulator S for both. is is named the one-malicious version of two untrusted program
model (i.e., “one-malicious model” for simplicity) as shown in Fig. 4.1.
e computation model using multiple, possibly dishonest, but physically separated parties
has been well studied in the literature [14, 25, 26]. Actually, in real-world applications, it is equiv-
alent to buying two copies of the advertised software from two diﬀerent vendors and achieving
the security as long as one of them is honest.
4.3
SECURE OUTSOURCING OF SINGLE MODULAR
EXPONENTIATION
Modular exponentiation is the most basic operation in discrete-logarithm-based cryptographic
protocols. However, it has been considered much more expensive for the resource-limited devices
such as RFID tags or smart cards. erefore, it is important to present an eﬃcient method to
securely outsource such operations to (untrusted) powerful servers.

34
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
Y1
response
Y2
response
E
Checkability
Checkability
Ch
k bilit
T
D
data
F
code
D
data
F
code
Y1
Y
response
D
data
F
code
Y2
Y
response
D
data
F
code
Secrecy
Secrecy
E
Write 
Program
Write 
Program
Non-
collusion
Efficiency
Figure 4.1: One-malicious version of two untrusted program model.
Now we formulate the problem of outsourcing of a single modular exponentiation: the aim
of client C is to compute a single modular exponentiation ua mod p (for an arbitrary base u
and an arbitrary power a), where p is a large prime. Due to limited computational resources, C
outsources the operation to two potentially malicious while much more computationally powerful
servers S1 and S2. An essential requirement is that the adversary A cannot know any useful
information about the inputs and outputs of outsourcing algorithm, i.e., .u; a; ua/.
Hohenberger and Lysyanskaya [82] proposed the ﬁrst outsource-secure modular exponen-
tiation algorithm based on the two previous approaches of precomputation [31, 66, 106, 115]
and server-aided computation [12, 71, 97, 128]. e main trick is to use some random blinding
factors to logically split the inputs into two random-looking pieces for two untrusted servers. Be-
sides, in the pre-processing phase, C is allowed to invest some one-time expensive computations
for a subroutine called Rand in order to speed up oﬀ-line computation. For each invocation of
Rand, the inputs are a large prime p, a ﬁxed base g 2 Z
p, and a random value b, and the outputs
are a random, independent pair of the form .b; gb mod p/.⁴ ere are two approaches to imple-
ment this functionality. One is for a trusted server to compute a table of random, independent
pairs in advance and then load it into the memory of C. e other is to apply the well-known
preprocessing techniques (e.g., EBPV generator [106]).
⁴ough the computation of Rand is also to perform a modular exponentiation, it always uses the ﬁxed base g. is is the
reason why we cannot just use the subroutine Rand to accomplish the outsourcing task. Furthermore, we emphasize that C
can never control the output of Rand in both approaches, especially the value of b.

4.3. SECURE OUTSOURCING OF SINGLE MODULAR EXPONENTIATION
35
Recently, Chen et al. [49] proposed the second secure outsourcing algorithm Exp for expo-
nentiation modulo a prime in the one-malicious model. e algorithm is superior to [82] in both
eﬃciency and checkability due to a new splitting and testing trick. e main idea is somewhat
similar to the famous “prisoner’s dilemma” in game theory. We illustrate it in more detail below.
Suppose that two suspects A and B are arrested and imprisoned while the prosecutors lack
suﬃcient evidence to convict them. en the prosecutors separate them and each prisoner is in
solitary conﬁnement with no means of communicating with the other (i.e., there is either no
subliminal channels). Simultaneously, the prosecutors oﬀer them a bargain as follows:
• If A and B both admitted their guilt, each of them serves 10 years in prison.
• If A admitted their guilt while B kept silent, A will be set free and B will serve 30 years in
prison (and vice versa).
• If A and B both kept silent, both of them will be serve 1 year in prison.
Trivially, the third case can maximize the common interests of the two suspects. is means
that both of them should be dishonest and output the false facts (i.e., neither of them admitted
their guilt). However, the experimental results show that the two suspects will betray each other
in an overwhelming probability (this means that they output the true facts). is indicates that
the probability for two parties to output the same false facts is negligible if they do not collude
with each other. In the one-malicious model, the two cloud servers are assumed not to collude
with each other. Given the same computation task, the probability for them to output the same
invalid results is negligible. us, they output either the same valid results or the diﬀerent invalid
results. is fact motivates us to have an idea that we could use some partial computation result to
act as a test query in the one-malicious model. Actually, this is the reason why the algorithm [49]
could improve Hohenberger and Lysyanskaya’s algorithm in both eﬃciency and checkability.
4.3.1
THE PROPOSED ALGORITHM
Let p; q be two large primes and qjp   1. e input of Exp is a 2 Z
q, and u 2 Z
p such that uq D
1 mod p (for an arbitrary base u and an arbitrary power a). e output of Exp is ua mod p.
Note that a may be secret or (honest/adversarial) protected and u may be (honest/adversarial)
protected. Both a and u are computationally blinded to S1 and S2. Similar to [82], Si.x; y/ ! yx
also denotes that Si takes as inputs .x; y/ and outputs yx mod p, where i D 1; 2. e proposed
algorithm Exp is given as follows:
1. To implement this functionality using S1 and S2, C ﬁrstly runs Rand twice to create two
blinding pairs .˛; g˛/ and .ˇ; gˇ/. We denote v D g˛ mod p and  D gˇ mod p.
2. e main trick is a more eﬃcient solution to logically split u and a into random looking
pieces that can be computed by S1 and S2. e ﬁrst logical divisions are
ua D .vw/a D ga˛wa D gˇgwa
mod p;

36
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
where w D u=v mod p and  D a˛   ˇ mod q.
e second logical divisions are
ua D gˇgwa D gˇgwkCl D gˇgwkwl
mod p;
where l D a   k mod q.
3. Next, C runs Rand to obtain three pairs .t1; gt1/, .t2; gt2/, and .t3; gt3/.
4. C queries S1 in random order as
S1.t2=t1; gt1/ ! gt2;
S1.=t3; gt3/ ! g;
S1.l; w/ ! wl.
Similarly, C queries S2 in random order as
S2.t2=t1; gt1/ ! gt2;
S2.=t3; gt3/ ! g;
S2.k; w/ ! wk.
5. Finally, C checks that both S1 and S2 produce the correct outputs, i.e., gt2 D
S1.t2=t1; gt1/ D S2.t2=t1; gt1/ and S1.=t3; gt3/ D S2.=t3; gt3/. If not, C outputs “er-
ror”; otherwise, C can compute ua D gwkwl.
Remark 2. In the one-malicious model, the equation S1.=t3; gt3/ D S2.=t3; gt3/ implies both
S1 and S2 produce the correct g. erefore, the partial computation result g also plays the role
of a test query. is is slightly diﬀerent from the technique in [82] while it indeed improves the
eﬃciency and checkability of the computations.
4.3.2
SECURITY ANALYSIS
eorem 4.6
In the one-malicious model, the algorithms .C; .S1; S2// are an outsource-secure im-
plementation of Exp, where the input .a; u/ may be honest, secret; or honest, protected; or adversarial,
protected.
Proof. e proof is similar to [82]. e correctness is trivial and we only focus on security. Let
A D .E; S0
1; S0
2/ be a PPT adversary that interacts with a PPT algorithm C in the one-malicious
model.
Firstly, we prove Pair One EVIEWreal Ï EVIEWideal:
If the input .a; u/ is anything other than honest, secret, then the simulator S1 behaves the
same way as in the real execution. If .a; u/ is an honest, secret input, then the simulator S1 behaves

4.3. SECURE OUTSOURCING OF SINGLE MODULAR EXPONENTIATION
37
as follows: on receiving the input on round i, S1 ignores it and instead makes three random
queries of the form .˛j ; ˇj / to both S0
1 and S0
2. S1 randomly tests two outputs (i.e., ˇ
˛j
j ) from
each program. If an error is detected, S1 saves all states and outputs Y i
p=“error,” Y i
u=¿, repi=1
(i.e., the output for ideal process is .estatei; ‘‘error;00 ¿/). If no error is detected, S1 checks the
remaining two outputs. If all checks pass, S1 outputs Y i
p=¿, Y i
u=¿, repi=0 (i.e., the output for ideal
process is .estatei; yi
p; yi
u/); otherwise, S1 selects a random element r and outputs Y i
p=r, Y i
u=¿,
repi=1 (i.e., the output for ideal process is .estatei; r; ¿/). In either case, S1 saves the appropriate
states. e input distributions to .S0
1; S0
2/ in the real and ideal experiments are computationally
indistinguishable. In the ideal experiment, the inputs are chosen uniformly at random. In the real
experiment, each part of all three queries that C makes to any one program is independently re-
randomized and thus computationally indistinguishable from random. If .S0
1; S0
2/ are honest in
round i, then EVIEWi
real Ï EVIEWi
ideal (this is because C .S0
1;S0
2/ perfectly executes Exp in the real
experiment and S1 simulates with the same outputs in the ideal experiment, i.e., repi=0). If one
of .S0
1; S0
2/ is dishonest in the round i, then it will be detected by both C and S1 with probability
2
3, resulting in an output of “error”; otherwise, the output of Exp is corrupted (with probability
1
3). In the real experiment, the three outputs generated by .S0
1; S0
2/ are multiplied together along
with a random value. In the ideal experiment, S1 also simulates with a random value r. us,
EVIEWi
real Ï EVIEWi
ideal even when one of .S0
1; S0
2/ is dishonest. By the hybrid argument, we
conclude that EVIEWreal Ï EVIEWideal.
Secondly, we prove Pair Two UVIEWreal Ï UVIEWideal:
e simulator S2 always behaves as follows: on receiving the input on round i, S2 ignores
it and instead makes three random queries of the form .˛j ; ˇj / to both S0
1 and S0
2. en S2
saves its states and the states of .S0
1; S0
2/. E can easily distinguish between these real and ideal
experiments (note that the output in the ideal experiment is never corrupted). However, E cannot
communicate this information to .S0
1; S0
2/. is is because in the round i of the real experiment, C
always re-randomizes its inputs to .S0
1; S0
2/. In the ideal experiment, S2 always generates random,
independent queries for .S0
1; S0
2/. us, for each round i we have UVIEWi
real Ï UVIEWi
ideal. By
the hybrid argument, we conclude that UVIEWreal Ï UVIEWideal.

eorem 4.7
In the one-malicious model, the algorithms .C; .S1; S2// are an .O. log2 n
n
/; 2
3/-
outsource-secure implementation of Exp.
Proof. e proposed algorithm Exp makes 5 calls to Rand plus 7 modular multiplication (MM)
and 3 modular inverse (MInv) in order to compute ua mod p (we omit other operations such
as modular additions). Also, Exp takes O.log2 n/ or O.1/ MM using the EBPV generator or
table-lookup method, respectively, where n is the bit-length of the a. On the other hand, it takes
roughly 1:5n MM to compute ua mod p by the square-and-multiply method. us, the algo-
rithms .C; .S1; S2// are an O. log2 n
n
/-eﬃcient implementation of Exp.

38
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
On the other hand, S1 (resp. S2) cannot distinguish the two test queries from all of the
three queries that C makes. If S1 (resp. S2) fails during any execution of Exp, it will be detected
with probability 2
3.

4.3.3
COMPARISON
We compare the above algorithm Exp [49] with Hohenberger-Lysyanskaya’s algorithm in [82].
We denote by MM a modular multiplication, by MInv a modular inverse, and by RandInvoke an
invocation of the subroutine Rand. We omit other operations such as modular additions in both
algorithms. Table 4.1 presents the comparison of the eﬃciency and the checkability between
Hohenberger-Lysyanskaya’s algorithm and the algorithm Exp.
Table 4.1: Comparison of the two algorithms
Algorithm [84]
Algorithm Exp [49]
MM
9
7
MInv
5
3
Invoke (Rand)
6
5
Invoke (S1)
4
3
Invoke (S2)
4
3
Checkability
½
⅔
Compared with Hohenberger-Lysyanskaya’s algorithm, the proposed algorithm Exp is su-
perior in both eﬃciency and checkability. More precisely, Exp requires only 7 MM, 3 MInv,
5 invocation of Rand, and 3 invocation of S1 and S2 for each modular exponentiation. Note
that the modular exponentiation is the most basic operation in discrete-logarithm-based crypto-
graphic protocols, and millions of such computations may be outsourced to the server every day.
us, our proposed algorithm can save huge computational resources for both the outsourcer C
and the servers S1 and S2.
On the other hand, Exp requires only 3 invocation of S1 and S2 for each modular exponen-
tiation, thus the communication overload is 6.jpj C jqj/. However, the communication overload
of algorithm [82] is 8.jpj C jqj/ since it requires 4 invocation of S1 and S2.
4.4
SECURE OUTSOURCING OF SIMULTANEOUS
MODULAR EXPONENTIATION
In this section, we focus on simultaneous modular exponentiations ua
1ub
2 mod p, which play an
important role in many cryptographic primitives such as chameleon hashing [5, 6, 42, 44, 46, 90,
114] and trapdoor commitment [9, 80, 108]. Trivially, a simultaneous modular exponentiation

4.4. SECURE OUTSOURCING OF SIMULTANEOUS MODULAR EXPONENTIATION
39
can be carried out by invoking 2 modular exponentiations. is requires roughly 3n MM, where
n is the bit-length of a and b. However, the computation cost is only 1:75n MM (i.e., roughly
1.17 modular exponentiation) if we use the simultaneous multiple exponentiation algorithm from
Chapter 14 of [99].
Recently, Chen et al. [49] proposed the ﬁrst eﬃcient outsource-secure algorithm of simul-
taneous modular exponentiations SExp in the one-malicious model. In the following, we give an
introduction for this outsourcing algorithm. Note that SExp also uses the same subroutine Rand
as in Section 4.3.
4.4.1
OUTSOURCING ALGORITHM
Let p; q be two large primes and qjp   1. Given two arbitrary bases u1; u2 2 Z
p and two arbitrary
powers a; b 2 Z
q such that the order of u1 and u2 is q. e output of SExp is ua
1ub
2 mod p. Both
a and u are computationally blinded to U1 and S2.
1. C ﬁrstly runs Rand twice to create two blinding pairs .˛; g˛/ and .ˇ; gˇ/. We denote v D
g˛ mod p and  D gˇ mod p.
2. e ﬁrst logical divisions are
ua
1ub
2 D .vw1/a.vw2/b D gˇgwa
1wb
2;
where w1 D u1=v, w2 D S2=v, and  D .a C b/˛   ˇ.
e second logical divisions are
ua
1ub
2 D gˇgwa
1wb
2 D gˇgwk
1wl
1wt
2ws
2;
where l D a   k and s D b   t.
3. Next, C runs Rand to obtain three pairs .t1; gt1/, .t2; gt2/, and .t3; gt3/.
4. C queries S1 in random order as
S1.t2=t1; gt1/ ! gt2;
S1.=t3; gt3/ ! g;
S1.k; w1/ ! wk
1;
S1.t; w2/ ! wt
2.
Similarly, C queries S2 in random order as
S2.t2=t1; gt1/ ! gt2;
S2.=t3; gt3/ ! g;
S2.l; w1/ ! wl
1;
S2.s; w2/ ! ws
2.

40
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
5. Finally, C checks that both S1 and S2 produce the correct outputs, i.e., gt2 D
S1.t2=t1; gt1/ D S2.t2=t1; gt1/ and S1.=t3; gt3/ D S2.=t3; gt3/. If not, C outputs “er-
ror”; otherwise, C can compute ua
1ub
2 D gwk
1wl
1wt
2ws
2.
Similar to theorem 3.1 and 3.2, we can easily prove the following theorem:
eorem 4.8
In the one-malicious model, the algorithms .C; .S1; S2// are an .O. log2 n
n
/; 1
2/-
outsource-secure implementation of SExp.
4.4.2
EFFICIENCY
Note that SExp requires only 10 MM, 4 MInv, 5 invocation of Rand, and 4 invocation of S1 and
S2 for each modular exponentiation. erefore, the computation cost of SExp is much less than
that of double running Exp. Surprisingly, it is even comparable to that of outsourcing one modular
exponentiation [82]. Table 4.2 presents the comparison of the eﬃciency and the checkability
between Hohenberger-Lysyanskaya’s Exp algorithm and our proposed algorithm SExp.
Table 4.2: Eﬃciency comparison for two algorithms
Algorithm [84]
Algorithm SExp [49]
MM
9
10
MInv
5
4
Invoke (Rand)
6
5
Invoke (S1)
4
4
Invoke (S2)
4
4
Checkability
½
½
4.5
SECURE OUTSOURCING OF BILINEAR PAIRINGS
Chevallier-Mames et al. [37] presented the ﬁrst algorithm for secure delegation of elliptic-curve
pairings based on an untrusted server model. Besides, the outsourcer could detect any failures with
probability 1 if the server misbehaves. However, an obvious disadvantage of the algorithm is that
the outsourcer should carry out some other expensive operations such as point multiplications
and exponentiations. More precisely, on the one hand, we argue that these expensive operations
might be too resource consuming to be carried out on a computationally limited device. On the
other hand, the computation of point multiplications is even comparable to that of bilinear pair-
ings in some scenarios [72, 116].⁵ erefore, it is meaningless if the client must perform point
⁵As pointed out in [72, 116], when the supersingular elliptic curve is deﬁned over a 512-bit ﬁnite ﬁeld with embedding degree
2, the computational overhead of a point multiplication is almost the same as that of a standard Tate pairing.

4.5. SECURE OUTSOURCING OF BILINEAR PAIRINGS
41
multiplications and exponentiations in order to outsource pairings, since this contradicts the aim
of outsourcing computation.
In the following, we introduce a new secure outsourcing algorithm Pair for bilinear pairings
in the one-malicious model [53]. A distinguishing property of the algorithm is that the (resource-
constrained) client never performs any expensive operations such as point multiplications and
exponentiations. Besides, in the algorithm [53], note that G1 and G2 are two cyclic additive
groups of order q and GT is a cyclic multiplicative cycle group of the same order. e pairing is
a map e W G1  G2 ! GT . Trivially, it is no diﬀerence if we use the notations for multiplicative
groups of G1 and G2.
4.5.1
OUTSOURCING ALGORITHM
e input of Pair is two random points A 2 G1, B 2 G2, and the output of Pair is e.A; B/.
Note that A and B may be secret or (honest/adversarial) protected and e.A; B/ is always se-
cret or protected. Moreover, both A and B are computationally blinded to S1 and S2. We let
Si.1; 2/ ! e.1; 2/ denote that Si takes as inputs .1; 2/ and outputs e.1; 2/, where
i D 1; 2. e proposed outsourcing algorithm Pair consists of the following steps:
1. To implement this functionality using S1 and S2, C ﬁrstly runs Rand to create a blinding
six-tuple .V1; V2; v1V1; v2V1; v2V2; e.v1V1; v2V2//. We denote  D e.v1V1; v2V2/.
2. e main trick of Pair is to logically split A and B into random looking pieces that can
be computed by S1 and S2. Without loss of generality, let ˛1 D e.A C v1V1; B C v2V2/,
˛2 D e.A C V1; v2V2/, and ˛3 D e.v1V1; B C V2/. Note that
˛1 D e.A; B/e.A; v2V2/e.v1V1; B/e.v1V1; v2V2/;
˛2 D e.A; v2V2/e.V1; v2V2/;
˛3 D e.v1V1; B/e.v1V1; V2/;
erefore, e.A; B/ D ˛1˛ 1
2 ˛ 1
3  1e.V1; V2/v1Cv2.
3. C then runs Rand to obtain two new six-tuple
.X1; X2; x1X1; x2X1; x2X2; e.x1X1; x2X2//
and
.Y1; Y2; y1Y1; y2Y1; y2Y2; e.y1Y1; y2Y2//:
4. C queries S1 in random order as
S1.A C v1V1; B C v2V2/ ! e.A C v1V1; B C v2V2/ D ˛1;
S1.v1V1 C v2V1; V2/ ! e.V1; V2/v1Cv2;

42
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
S1.x1X1; x2X2/ ! e.x1X1; x2X2/;
S1.y1Y1; y2Y2/ ! e.y1Y1; y2Y2/;
Similarly, C queries S2 in random order as
S2.A C V1; v2V2/ ! e.A C V1; v2V2/ D ˛2;
S2.v1V1; B C V2/ ! e.v1V1; B C V2/ D ˛3;
S2.x1X1; x2X2/ ! e.x1X1; x2X2/;
S2.y1Y1; y2Y2/ ! e.y1Y1; y2Y2/;
5. Finally, C checks that both S1 and S2 produce the correct outputs, i.e., e.x1X1; x2X2/ and
e.y1Y1; y2Y2/ for the test queries. If not, C outputs “error”; otherwise, C can compute
e.A; B/ D ˛1˛ 1
2 ˛ 1
3  1e.V1; V2/v1Cv2.
Remark 3. Given a random point P in G1 (or G2), C can compute the inverse point  P eas-
ily. erefore, C can query S2.A C V1;  v2V2/ ! e.A C V1;  v2V2/ D ˛ 1
2
and S2. v1V1; B C
V2/ ! e. v1V1; B C V2/ D ˛ 1
3 . Similarly, we can deﬁne the outputs of Randas
.V1; V2; v1V1; v2V1; v2V2; e.v1V1; v2V2/ 1/:
erefore, C need not perform the inverse computation in GT .
4.5.2
IMPROVED OUTSOURCING ALGORITHM
Recently, Tian et al. [122] proposed a new algorithm for securely outsourcing bilinear pairings
based on the two untrusted model, where the two cloud servers are both malicious while not in
collusion with each other. Otherwise, we can view them as one untrusted server. On the other
hand, we should emphasize that the security model in Pair [53] is actually one malicious version
of the two untrusted program model (at most one of the two servers is malicious).
e proposed algorithm consists of the following steps:
1. To implement this functionality using S1 and S2, C ﬁrstly runs Rand* twice to create two
blinding six-tuple
.x1P1; x1x 1
2 x3P1; x 1
1 x2P2; x 1
1 x4P2; e.P1; P2/x3Cx4 x2/
and
.y1P1; y1y 1
2 y3P1; y 1
1 y2P2; y 1
1 y4P2; e.P1; P2/y3Cy4 y2/:
Also, C randomly selects a small integer t 2 f1; : : : ; sg. Generally, s could be a 20-bit integer
in the real applications.

4.5. SECURE OUTSOURCING OF BILINEAR PAIRINGS
43
2. e main trick of Pair* is also to logically split A and B into random looking pieces
that can be computed by S1 and S2. Besides, these partial results are used to repre-
sent two diﬀerent but related functions f and g of e.A; B/, respectively. More precisely,
f .e.A; B// D e.A; B/ and g.e.A; B// D e.A; B/t. If and only if the veriﬁcation equation
g D f t holds, C is convinced that both S1 and S2 output the valid results. e principle
is that the probability for two untrusted servers to output two results that satisfy some un-
known conditions is negligible if they do not collude with each other, while in Chen et
al’s algorithm Pair, the veriﬁcation equation is the relation of two test queries (not the two
functions).
3. C queries S1 in random order as
S1.A C x1P1; B C x 1
1 x2P2/ ! ˛1;
S1.tA C y1y 1
2 y3P1;  y 1
1 y2P2/ ! ˛2;
S1. y1P1; B C y 1
1 y4P2/ ! ˛3;
4. Similarly, C queries S2 in a random order as
S2.tA C y1P1; B C y 1
1 y2P2/ ! ˛0
1;
S2.A C x1x 1
2 x3P1;  x 1
1 x2P2/ ! ˛0
2;
S2. x1P1; B C x 1
1 x4P2/ ! ˛0
3;
5. Finally, C computes
 D ˛1˛0
2˛0
3e.P1; P2/x3Cx4 x2
and
0 D ˛0
1˛2˛3e.P1; P2/y3Cy4 y2:
If t D 0 and  2 GT , C outputs  as the result of e.A; B/. Otherwise, outputs “error.”
Remark4. As pointed out in [39], it is essential to test the membership of an output, i.e.,  2 GT .
e reason is that a malicious program may modify a response by multiplying an element of
small orders. For some parameter sets given in [30, 113], the membership test does not need an
exponentiation. A more general solution is to outsource the membership test operation. Since S1
or S2 knows the order q, we may use a secure public-exponent-secret-base outsourcing algorithm
[134] to compute q and compare the result with e.P1; P2/ to determine whether  2 GT .


45
C H A P T E R
5
Secure Outsourcing of Large
Database With Updates
In this chapter, we mainly focus on secure outsourcing of large database (i.e., outsourcing storage).
at is, assume that a resource-constrained client would like to store a very large database on a
server so that it could later retrieve a database record and update a record by assigning a new
value. If the server attempts to tamper with the database, it will be detected by the client with an
overwhelming probability. Besides, the computation and storage resources invested by the client
must not depend on the size of the database (except for an initial setup phase). Recently, plenty
of research has been done on this hot topic [84, 102, 104, 112, 127, 133].
For the case of static database, we can easily solve the problem of outsourcing storage by
using message authentication codes or digital signatures. However, it is another thing if the client
(frequently) performs updates on the database. As noted in [18], the main technical diﬃculty in
this case is that the client must have a mechanism to revoke the signatures given to the server
for the previous values. Otherwise, the malicious server can utilize the previous (while valid)
database records and corresponding signatures to respond to the current query of the client. In
order to solve this issue, the client should keep track of every change locally. However, this totally
contradicts the goal of outsourcing, i.e., the client should use much fewer resources than those
needed to store the database locally.
Previous research on outsourcing dynamic databases is mainly based on accumulators [56,
57, 105] and authenticated data structures [98, 107, 109, 121]. However, Benabbas, Gennaro, and
Vahlis [18] pointed out that these solutions either rely on non-constant size assumptions (such
as the strong Diﬃe-Hellman assumption) or require expensive operations (such as re-shuﬄing
procedures) [18]. Besides, they introduced a new primitive called veriﬁable database (VDB) to
solve the problem. ey also presented the ﬁrst practical VDB scheme which relies on a constant
size assumption in bilinear groups of composite order. However, the scheme only supports private
veriﬁability, that is, only the owner of the database can verify the correctness of the proofs. In some
scenarios, especially in the case that the database owner is not the database user, it is essential
to achieve public veriﬁability (i.e., anyone can verify the correctness of the proofs). Motivated
by this issue, Catalano and Fiore [41] proposed an elegant solution to build VDB from vector
commitment. Besides, another advantage of this construction is that it relies on standard constant-
size assumption.

46
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
5.1
SECURITY DEFINITIONS
We consider the database DB as a set of tuples .x; mx/ in some appropriate domain, where x is an
index and mx is the corresponding value. Informally, a VDB scheme allows a resource-constrained
client C to outsource the storage of a very large database to a server S in such a way that C can
later retrieve and update the database records from S. Inherently, any attempts to tamper with
the data by the dishonest S will be detected with an overwhelming probability when C queries
the database. In order to achieve the conﬁdentiality of the data record mx, C can use a master
secret key to encrypt each mx using a symmetric encryption scheme such as AES. Trivially, given
the ciphertext vx, only C can compute the record mx. erefore, we only need to consider the
case of encrypted database .x; vx/. is is implicitly assumed in the existing academic research.
e formal deﬁnition for veriﬁable databases with updates is given as follows [18, 41]:
Deﬁnition 5.1
A veriﬁable database scheme with updates
VDB D .Setup; Query; Verify; Update/ consists of four algorithms deﬁned below.
• Setup.1k; DB/: On input the security parameter k, the setup algorithm is run by the client
to generate a secret key SK to be secretly stored by the client, a database encoding S that is
given to the server, and a public key PK that is distributed to all users (including the client
itself) for verifying the proofs.
• Query.PK; S; x/: On input an index x, the query algorithm is run by the server, and returns
a pair  D .v; /.
• Verify.PK/SK; x; /: e public veriﬁcation algorithm outputs a value v if  is correct with
respect to x, and an error ? otherwise.
• Update.SK; x; v0/: In the update algorithm, the client ﬁrstly generates a token t0
x with the
secret key SK and then sends the pair .t0
x; v0/ to the server. en the server uses v0 to update
the database record in index x, and t0
x to update the public key PK.
ere are two diﬀerent kinds of veriﬁability for the outputs of the query algorithm, i.e.,
 D .v; /. In the Catalano-Fiore’s scheme [41], anyone can verify the validity of  with the public
key PK. erefore, it satisﬁes the property of public veriﬁability. However, in some applications,
only the client can verify the proofs generated by the server since the secret key of the client is
involved in the veriﬁcation. is is called private veriﬁability [18]. A veriﬁable database scheme
should support both types of veriﬁability for various applications.

5.1. SECURITY DEFINITIONS
47
5.1.1
SECURITY REQUIREMENTS
In the following, we introduce some security requirements for a VDB scheme. e ﬁrst require-
ment is the security of a VDB scheme. Intuitively, a VDB scheme is secure if a malicious server
cannot convince a veriﬁer to accept an invalid output, i.e., v ¤ vx where vx is the value of a
database record in the index x. Note that vx can be either the initial value given by the client
in the setup stage or the latest value assigned by the client in the update procedure. Benabbas,
Gennaro, and Vahlis [18] presented the following deﬁnition:
Deﬁnition 5.2
(Security) A VDB scheme is secure if for any database DB 2 Œq  f0; 1g, where
q D poly.k/, and for any probabilistic polynomial time (PPT) adversary A,
AdvA.VDB; DB; k/  negl.k/;
where AdvA.VDB; DB; k/ D PrŒExpVDB
A .DB; k/ D 1 is deﬁned as the advantage of A in the ex-
periment as follows:
Experiment ExpVDB
A ŒDB; k
.PK; SK/  Setup.DB; k/I
For i D 1; : : : ; l D poly.k/I
Verify query W
.xi; i/  A.PK; t0
1; : : : ; t0
i 1/I
vi  Verify.PK/SK; xi; i/I
Update query W
.xi; v.i/
xi /  A.PK; t0
1; : : : ; t0
i 1/I
t0
i  Update.SK; xi; v.i/
xi /I
. Ox; O/  A.PK; t0
1; : : : ; t0
l/I
Ov  Verify.PK/SK; Ox; O/
If Ov ¤? and Ov ¤ v.l/
Ox ; output 1I else output 0:
In the above experiment, after every update query, we implicitly assign PK  PKi. Note
that this property of security is similar to that of soundness in zero-knowledge proof.
e second requirement is the correctness of a VDB scheme. at is, the value and proof
generated by the honest server can always be veriﬁed successfully and accepted by the client (the
honest server results in valid results and proof). is is similar to the property of completeness in
zero-knowledge proof.
Deﬁnition 5.3
(Correctness) A VDB scheme is correct if for any database DB 2 Œq  f0; 1g,
where q D poly.k/, and for any valid pair  D .v; / generated by an honest server, the output
of the veriﬁcation algorithm is always the value v.

48
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
e third requirement is the eﬃciency of a VDB scheme. at is, the client in the veriﬁable
database scheme should not be involved in much expensive computation and storage (except for
an initial pre-processing phase).⁶
Deﬁnition 5.4
(Eﬃciency) A VDB scheme is eﬃcient if for any database DB 2 Œq  f0; 1g,
where q D poly.k/, the computation and storage resources invested by the client must be inde-
pendent of q.
e last requirement is the accountability for a VDB scheme. at is, after the client has
detected the tampering of dishonest server, he should provide some evidence to convince a judge
of the facts.
Deﬁnition 5.5
(Accountability) A VDB scheme is accountable if for any database DB 2 Œq 
f0; 1g, where q D poly.k/, the client can provide a proof if the dishonest server has tampered
with the database.
5.1.2
FORWARD AUTOMATIC/BACKWARD SUBSTITUTION UPDATE
ATTACK
In the following, we consider two attacks on VDB schemes. Basically, both of them violate the
Security and Accountability properties of VDB in the above deﬁnition.
e ﬁrst attack is that an adversary A (i.e., the malicious server S) can perform the Update
algorithm in the same way as the client C. Speciﬁcally, S ﬁrstly retrieves the current record vx
and then computes the token t
x (if the computation does not need any secret knowledge of C).
Finally, S updates the corresponding database record with any new value v
x, and the public key
PK with t
x . Trivially, S can generate a valid proof for any query based on PK. Besides, this
forward updated public key PK and the real one PK0 are totally computationally indistinguishable
from a viewpoint of any third party. erefore, when a dispute occurs, a judge cannot deduce that
S is dishonest. We deﬁne this kind of adversary as Forward Automatic Update (FAU) attacker.
e second attack on VDB schemes is not explicitly stated in previous literature. We call
it Backward Substitution Update (BSU) attack. at is, the dishonest S can utilize the previous
(while valid) public key and the corresponding database to substitute the current ones (trivially,
this can also be viewed as an update). We argue that S in VDB has the ability to update the
public key freely. If this case happens, the eﬀort of the later update by C is no longer meaningful.
Furthermore, if C did not store the public key locally, it is diﬃcult for him to distinguish the past
public key from the latest one. On the other hand, even if C has stored the latest public key, it
seems still to be diﬃcult for him to prove the fact that the stored public key is the latest one.
⁶In some scenarios, the client is allowed to invest a one-time expensive computational eﬀort. is is known as the amortized
model of outsourcing computations [74].

5.2. VDB CONSTRUCTION FROM DELEGATING POLYNOMIAL FUNCTIONS
49
5.2
VDB CONSTRUCTION FROM DELEGATING
POLYNOMIAL FUNCTIONS
In this section, we introduce Benabbas-Gennaro-Vahlis VDB scheme from delegating high de-
gree polynomial functions. is is the ﬁrst eﬃcient VDB construction that relies on a “constant-
size” assumption (i.e., the subgroup member assumption).
5.2.1
DELEGATING OF POLYNOMIAL FUNCTIONS
Given a polynomial P.x/ D Pd
iD0 cixi, where ci 2 Zp. e aim is to compute y D P.u/. e
outsourcing protocol between C and S is given as follows:
Let R.x/ D Pd
iD0 rixi, where ri 2 Zp. C computes and then shares with S a vector t of
the group elements with the form gaciCri, where a 2R Zp is a random value which is only known
by C. Given the query u, S returns y D P.u/ and t D gaP.u/CR.u/. C accepts y iﬀt D gayCR.u/.
e crucial point is how C can compute R.u/ eﬃciently. If R.x/ is a random polynomial,
then the computational overload of R.u/ is the same as that of P.u/. e trick is that we can
use an algebraic PRF that has a closed form eﬃcient computation for polynomials such that
gri D FK.i/, where K is a secret key of F . In this case, the security of the construction is not
compromised, while the closed form eﬃciency of F will allow C to verify the result eﬃciently.
In the following, we present a concrete protocol for delegating polynomials with a certain
algebraic PRF FK.i/ D gk0ki
1 (note that we could use any other algebraic PRF). Deﬁne R.x/ D
Pd
iD0 rixi D Pd
iD0 k0ki
1xi. en, C can compute R.u/ eﬃciently for any u.
1. KeyGen: Given a security parameter k and the target function is P.x/ D Pd
iD0 cixi. Let G
be the range group of FK, and g be a generator of G. Deﬁne gi D FK.i/ D gk0ki
1. Choose
a random a 2R Zp and compute T D .t0; :::; td/ D .g0gac0; :::; gdgacd /. Output PK D
.T; P.x// and SK D .K; a/ D .k0; k1; a/.
2. ProbGen: Given the input u, output u D u and u D u.
3. Compute: Given the public key PK and the encoded input u, S computes h.u/ D
.1; u; : : : ; ud/ 2 ZdC1
p
, y D Pd
iD0 ciui, and t D Qd
iD0 tui
i . Output u D .y; t/.
4. Verify: C computes z D CFEvalh.u; K/ and accepts y iﬀt D zgay.
e correctness of the protocol is due to the fact below:
z D CFEvalh.u; K/ D
d
Y
iD0
ŒFK.i/ui D
d
Y
iD0
gk0ki
1ui D
d
Y
iD0
griui D gR.u/
Note that this protocol does not ensure the privacy of the polynomials. ough the issue
could be solved by using an additively homomorphic encryption scheme, it still does not protect
the privacy of input u.

50
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
5.2.2
BENABBAS-GENNARO-VAHLIS VDB CONSTRUCTION
In this section, we introduce Benabbas-Gennaro-Vahlis’s VDB scheme in the setting of bilinear
groups of composite order. e scheme consists of the following algorithms:
• Setup: e setup algorithm takes as input a security parameter n and an encrypted database
DB with the form of .i; vi/ 2 Œq  Zn 1. Trivially, we could use a hash function H W
f0; 1g ! Zn 1 to proceed a very large data record vi. It then generates the bilinear pairing
groups G, GT of order N D p1p2, where p1, p2 are primes in the range Œ2n 1; 2n   1, and
a pairing e W G  G ! GT . Let G1 and G2 be subgroups of G of orders p and q, respec-
tively. Choose two PRF keys k1, k2 randomly, and choose randomly:
g1; h1 2R G1; g2; h2; u2 2R G2; a; b 2R ZN
For each i 2 f1; : : : ; qg, set ri D Fk1.i/; wi D Fk2.i; 1/, and si D 1. Deﬁne
ti D griCaviCbsi
1
gwi
2 ; w D
qP
iD1
wi; Tw  e.g2; u2/w.
Set Ot0 D u2 and Ot1 D h1h2. e public key is PK D
 . Ot0; Ot1; s1; t1; : : : ; sq; tq/; DB
. e pri-
vate key is SK D .a; Tw; k1; k2/.
• Query: e query processing algorithm takes as input the public key PK and an index
query x 2 f1;    ; qg, and then computes
T D e.tx; Ot1/  e

qQ
iD1;i¤x
ti; Ot0

:
Output .T; y D vx; sx/.
• Verify: e veriﬁcation algorithm takes as input a private key SK, a query x, and .T; y; sx/.
e veriﬁer then computes rx D Fk1.x/, wx D Fk2.x; sx/ and checks
T
‹D Tw  e.grxCayCbsx
1
g2; h1u wx
2
hwx
2 /
If the equality holds, the veriﬁer outputs 1. Otherwise, outputs ?.
• Update: e update algorithm takes as input a pair .x; y0/ 2 Œm  Zn 1. C ﬁrstly submits
x as a query to S, and veriﬁes the validity of triple .T; y; sx/. en sets
w0
x D Fk2.x; sx C 1/   Fk2.x; sx/, Tw  Tw  e.gw0
x
2 ; u2/, and t0
x  ga.y0 y/Cb
1
gw0
x
2 :

5.3. VDB FRAMEWORK BASED ON VECTOR COMMITMENT
51
S is then given t0
x, and updates the public key by setting tx  tx  t0
x and sx  sx C 1.
e correctness of the scheme follows from properties of bilinear maps over composite order
groups (that is, for any u 2 G1 and v 2 G2, we have e.u; v/ D 1GT ):
T D e.tx; Ot1/e. Q
i¤x
ti; Ot0/ D e.grxCavxCbsx
1
gwx
2 ; h1h2/ Q
i¤x
e.griCaviCbsi
1
gwi
2 ; u2/
D e.grxCavxCbsx
1
g2; h1u wx
2
hwx
2 / Q
i
e.griCaviCbsi
1
gwi
2 ; u2/
D e.grxCavxCbsx
1
g2; h1u wx
2
hwx
2 /  Tw
Note that delegating a polynomial is used as a building block in the above construction. e
polynomial is deﬁned as P.x/ D vx for all 1  x  q. Nevertheless, S actually did not compute
the value of P.x/ for a query index x. at is the reason why VDB is not outsourcing computation
but storage. Besides, C can reconstruct and verify the proof T by using a PRF F with closed form
eﬃciency.
In order to prevent the BSU attack, S should compute a signature on the tuples .i; Ti/,
where Ti is the latest counter for index i. C should store the tuples together with the signature
locally by himself and it is meaningless to store these values in the S side.
5.3
VDB FRAMEWORK BASED ON VECTOR
COMMITMENT
In 2013, Catalano and Fiore presented the second eﬃcient construction for general VDB frame-
work using the primitive of vector commitment [41]. e elegant construction is based on the
standard CDH assumption in bilinear groups. Besides, compared with the ﬁrst eﬃcient VDB
construction, it can support both public veriﬁability and private veriﬁability.
In this section, we ﬁrst give an overview of their VDB general framework and then present
a security weakness of the construction [47].
5.3.1
THE GENERAL FRAMEWORK
e main idea of Catalano-Fiore’s VDB framework is as follows: Let C be the vector commitment
on the database. Given a query on index x by the client C, the server S provides the value vx
and the opening of commitment as a proof that vx has not been tampered with. During the
update phase, C computes a new ciphertext v0
x and a token t0
x and then sends them to S. Finally,
S updates the database and the corresponding public key with the pair .t0
x; v0
x/. Formally, the
framework consists of the following algorithms:
• Setup.1k; DB/: Let the database be DB D .i; vi/ for 1  i  q. Run the key generation al-
gorithm of vector commitment to obtain the public parameters PP  VC.KeyGen.1k; q/.

52
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
Run the committing algorithm to compute the commitment and auxiliary information
.C; aux/  VC.ComPP.v1;    ; vq/. Deﬁne PK D .PP; C/ as the public key of VDB scheme,
S D .PP; aux; DB/ as the database encoding, and SK D = as the secret key of C.
• Query.PK; S; x/: On input an index x, S ﬁrstly runs the opening algorithm to compute
x  VC.OpenPP.vx; x; aux/ and then returns  D .vx; x/.
• Verify.PK; x; /: Parse the proofs  D .vx; x/. If VC.VerPP.C; x; vx; x/ D 1, then return
vx. Otherwise, return an error ?.
• Update.SK; x; v0/: To update the record of index x, C ﬁrstly retrieves the current record vx
from S. at is, C obtains   Query.PK; S; x/ from S and checks that Verify.PK; x; / D
vx ¤?. Also, C computes .C0; U/  VC.UpdatePP.C; vx; x; v0
x/ and outputs PK0 D .PP; C0/
and t0
x D .PK0; v0
x; U/. en S uses v0
x to update the database record of index x, PK0 to update
the public key, and U to update the auxiliary information.
5.3.2
SECURITY ANALYSIS
In this section, we present a security analysis of Catalano-Fiore’s VDB general framework and
show the framework suﬀers from both the FAU and BSU attack [47].
Firstly, we argue that Catalano-Fiore’s VDB framework suﬀers from the FAU attack. e
main reason is that the secret key in Catalano-Fiore’s VDB construction is assumed to be empty,
i.e., SK D =. As a result, anyone can verify the validity of output  and thus the construction
supports the public veriﬁability. However, this also allows the adversary A to update the database
in an indistinguishable manner as the client since no secret information is required in the update
algorithm.⁷ Besides, it is more diﬃcult for the third party to detect the FAU attack than the
client. erefore, VDB schemes that support the public veriﬁability are more vulnerable to the
FAU attack in the real-world applications. In the following, we present the formal proof that
Catalano-Fiore’s framework violates the security deﬁnition of VDB.
eorem 5.6
Catalano-Fiore’s VDB framework does not satisfy the property of security.
Proof. A VDB scheme does not satisfy the property of security means that the adversary A (i.e.,
the dishonest server) can successfully simulate the experiment ExpVDB
A ŒDB; k and win the game
with a non-negligible probability. In Catalano-Fiore’s VDB framework, the secret key is assumed
to be empty, i.e., SK D ?. erefore, the adversary A can perform the algorithm Update freely.
Our main trick is that we require A to perform an additional round of Update after ﬁnishing l
rounds of Update queries of the client. However, in the last round of Update, A also plays the
role of client. More precisely, the simulated experiment Exp0VDB
A ŒDB; k is deﬁned as follows:
⁷Note that the construction [18] only supports the private veriﬁability since the (non-empty) secret key SK is involved in the
veriﬁcation. Besides, SK is also involved in the update algorithm and hence only the client can update the database.

5.3. VDB FRAMEWORK BASED ON VECTOR COMMITMENT
53
Experiment Exp0VDB
A ŒDB; k
.PK; ?/  Setup.DB; k/I
For i D 1; : : : ; l C 1I where l D poly.k/I
Verify query W
.xi; i/  A.PK; t0
1; : : : ; t0
i 1/I
vi  Verify.PK=?; xi; i/I
Update query W
.xi; v.i/
xi /  A.PK; t0
1; : : : ; t0
i 1/I
t0
i  Update.?; xi; v.i/
xi /I
. Ox; O/  A.PK; t0
1; : : : ; t0
lC1/I
Ov  Verify.PK=?; Ox; O/
Since we implicitly assign PK  PKi after every update query in the experiment, the ﬁ-
nal public key PK D PKlC1. en, let Ov D v.lC1/
Ox
. Trivially, Ov ¤? and Ov ¤ v.l/
Ox . is violates the
security deﬁnition of the VDB scheme.

Secondly, Catalano-Fiore’s framework also suﬀers from the BSU attack since the veriﬁ-
cation only requires the public key stored by the server. Besides, it certainly does not satisfy the
property of accountability. Fortunately, we could provide a straightforward eﬀective solution to
the BSU attack. e trick is as follows: we still need a counter T in the public key to denote the
number of updates. e diﬀerence is that the server computes a signature  on the latest counter
Tl and the identity IDc of the client. Given a past public key with the counter Tp, the client
provides the pair .; Tl/ to the judge as a proof. If  is valid and Tp < Tl, the judge claims that
the server is dishonest. Trivially, the storage workload of the client is only the latest pair .; Tl/
(not all signatures for every counters). erefore, we will not consider the BSU attack anymore
in the remainder of this book.
Remark 5. It seems that there are two naive approaches against FAU attack for Catalano-Fiore’s
VDB framework. e ﬁrst solution is that we can require the server to compute a signature on
the (updated) public key. However, we argue that this solution does not work since the dishonest
server is an inherent FAU attacker in Catalano-Fiore’s VDB framework (the server has the ability
to compute the signature on any public key). e second one is that the client computes a signature
on the (updated) public key. Obviously, the server cannot forge the client’s signature. However,
it requires that the client must have a mechanism to revoke the previous signatures (surprisingly,
it reverted to the same problem of VDB). erefore, neither of the two approaches can solve the
security issue of Catalano-Fiore’s constructions.
Remark 6. Note that Benabbas-Gennaro-Vahlis’s scheme [18] does not suﬀer from BSU attack
since the secret key of the client is updated each time. Without loss of generality, assume that
the latest secret key of the client is SKl. When the dishonest server presents a previous public key
PKp including a counter Tp and the corresponding database DBp, it is trivial that the output of

54
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
query algorithm by the server cannot pass the veriﬁcation with the secret key SKl. As a result, the
tampering will be detected by the client. However, this cannot be viewed as a proof even if the
client presents his secret key to a judge. e reason is that a malicious client also has the ability to
frame an honest server. at is, the malicious client can present a random value as the secret key to
invalidate the veriﬁcation on the output of an honest server. us, the judge cannot deduce who
is dishonest when a dispute occurred. In this sense, we argue that Benabbas-Gennaro-Vahlis’s
scheme does not satisfy the property of accountability (this also indicates that accountability is a
stronger notion than security). In order to achieve the accountability, the client should store the
latest counter and the corresponding signature as we mentioned in the above solution to the BSU
attack (we argue again that it is not suﬃcient only to store these values in the server’s side as in
[18]).
5.4
VDB FRAMEWORK FROM BINDING VECTOR
COMMITMENT
In this section, we introduce Chen et al’s new VDB scheme [47], which is not only public veriﬁable
but also secure under the FAU attack. e main trick is as follows.
As stated above, the main reason that Catalano-Fiore’s framework suﬀers from the FAU
attack is that the secret key SK of the client is not involved in the computation and update of
the public key PK (actually, SK is assumed to be ?). is will enable the adversary (especially the
dishonest server) to update PK freely. Note that PK D .PP; C0/ and the public parameters PP of
vector commitment is never updated. at is, the public parameters are generated and published
by a trusted party [67]. us, the server can update the vector commitment C0 at its own will and
this equals to update the databases. We argue that it is meaningless if we add a signature of the
server on C0 to PK since the server can compute such a signature on any message. On the other
hand, if we use SK to compute the updated public key PK (more precisely, the commitment C0) just
as in the scheme [18], the proposed VDB scheme might no longer support the property of public
veriﬁability. e main reason is that the secret key SK might be also involved in the veriﬁcation of
C and the corresponding proofs (i.e., the openings of C). at is, only the client with SK can verify
the validity of the proofs. erefore, it seems to be contradictory to construct a VDB scheme that
is public veriﬁable and secure under the FAU attack simultaneously.
We utilize the idea of commitment binding to solve this problem. at is, the client uses
the secret key SK to compute a signature on some binding information which will be explained
later. Also, the signature is used to compute the updated commitment C0. Since the signature is
diﬀerent for each updating, the server cannot compute a new C0 without the cooperation of client.
Also, we emphasize that the secret key SK is never used in the veriﬁcation algorithm, but only
used in the update algorithm.
e binding information consists of the last public key CT  1 (a commitment value), the
commitment C.T / on the current database vector, and the current counter T . Assume that the sig-
nature of client on binding information is HT D Ssk.CT  1; C.T /; T /, then the current public

5.4. VDB FRAMEWORK FROM BINDING VECTOR COMMITMENT
55
key CT D HT C.T /. So, the solution binds the commitment CT to the 3-tuple .CT  1; C.T /; T / in
a recursion manner as shown in Fig. 5.1. As a result, the adversary that includes the server cannot
update the database and public key freely.
CT  =  HTC(T)  =  SIGNSK    (CT–1, C(T),T )   C(T)
Figure 5.1: Commitment binding.
Chen et al.’s new proposed VDB framework is given as follows.
• Setup.1k; DB/: Let the database be DB D .i; vi/ for 1  i  q. Let VC be any secure vector
commitment scheme. Run the key generation algorithm of vector commitment to obtain the
public parameters PP  VC.KeyGen.1k; q/. Run the committing algorithm to compute the
commitment and auxiliary information .CR; aux/  VC.ComPP.v1;    ; vq/. Let .sk; pk/ be
the secret/public key pair of the client C. Let Sbe a provably secure digital signature
scheme. Let T be a counter with the initial value 0. Let C.T / D VC.ComPP.v.T /
1
;    ; v.T /
q
/
be the commitment on the latest database vector after the original database DB has been
updated T times. Trivially, C.0/ D CR. Specially, let C 1 D CR. e client C computes and
sends the signature H0 D Ssk.C 1; C.0/; 0/ to the server S. If H0 is valid, then S com-
putes C0 D H0C.0/. Also, S adds the information of ˙0 D .H0; C 1; C.0/; 0/ to aux.
Set PK D .PP; pk; CR; C0/ as the public key of the VDB scheme, S D .PP; aux; DB/ as the
database encoding, and SK D sk as the secret key of C.
• Query.PK; S; x/: Assume that the current public key PK D .PP; pk; CR; CT /. On input an
index x, S runs the opening algorithm to compute x  VC.OpenPP.vx; x; aux/ and returns
 D .vx; x; ˙T /, where ˙T D .HT ; CT  1; C.T /; T /.
• Verify.PK; x; /: Parse  D .vx; x; ˙T /. If Verpk.˙T / D 1 (this means that HT is a valid
signature of C on message .CT  1; C.T /; T /) and VC.VerPP.CT ; HT ; x; vx; x/ D 1, then re-
turn vx. Otherwise, return an error ?.
• Update.SK; x; v0
x/: To update the record of index x, C ﬁrstly retrieves the current record
vx from S as in the above Verify algorithm. at is, C ﬁrstly obtains   Query.PK; S; x/

56
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
from S and then checks that Verify.PK; x; / D vx ¤?. Set T  T C 1, C ﬁrstly computes
C.T / D VC.ComPP.v.T /
1
;    ; v.T /
q
/ and t0
x D HT D Ssk.CT  1; C.T /; T /, and then sends
.t0
x; v0
x/ to S. If t0
x is valid, then S computes CT D HT C.T / and updates the public key
PK D .PP; pk; CR; CT / (note that only the value of CT needs to be updated). Also, S uses
the value of v0
x to update the database record of index x, i.e., DB.x/  v0
x. Finally, S adds
the information of ˙T D .HT ; CT  1; C.T /; T / to aux in S.
5.4.1
A CONCRETE VDB SCHEME
In this section, we introduce a concrete VDB scheme from the vector commitments based on the
CDH assumption [47].
• Setup.1k; DB/: Let k be a security parameter. Let the database be DB D .x; vx/ for 1  x 
q. Let G1 and G2 be two cyclic multiplicative groups of prime order p equipped with a bilin-
ear pairing e W G1  G1 ! G2. Let g be a generator of G1. Let H W G1  G1  f0; 1g !
G1 be a cryptographic hash function. Randomly choose q elements zi 2R Zp and compute
hi D gzi, hi;j D gzizj , where 1  i; j  q and i ¤ j.
Set PP D .p; q; G1; G2; H; e; g; fhig1iq; fhi;j g1i;j q;i¤j /, and the message space M D
Zp. C randomly selects an element y 2R Zp and then computes Y D gy.
Let CR D Qq
iD1 hvi
i
be the root commitment on the database vector .v1; v2;    ; vq/. Let
T be a counter with the initial value 0. Let C.T / be the commitment on the latest database
vector after the original database DB has been updated T times. Trivially, C.0/ D CR. Spe-
cially, let C 1 D CR. C computes and sends H0 D H.C 1; C.0/; 0/y to S. If the equation
e.H0; g/ D e.H.C 1; C.0/; 0/; Y / holds (that means H0 is a valid signature of C), then S
computes C0 D H0C.0/. Also, S adds the information of .H0; C 1; C.0/; 0/ to aux.
Set PK D .PP; Y; CR; C0/, S D .PP; aux; DB/ and SK D y.
• Query.PK; S; x/: Assume that the current public key PK D .PP; Y; CR; CT /. Given a query
index x, S computes .T /
x
D Q
1j q;j ¤x h
v.T /
j
x;j and returns the proofs
 D .v.T /
x
; .T /
x
; HT ; CT  1; C.T /; T /:
• Verify.PK; x; /: Parse the proofs  D .v.T /
x
; .T /
x
; HT ; CT  1; C.T /; T /. en anyone (in-
cluding the client) can verify the validity of the proofs  by checking whether the following
two equations e.HT ; g/ D e.H.CT  1; C.T /; T /; Y / and e.CT =HT hv.T /
x
x
; hx/ D e..T /
x
; g/
hold.⁸ If the proofs  is valid, the veriﬁer accepts it and outputs v.T /
x
. Otherwise, outputs
an error ?.
⁸If the veriﬁer is client, then he needs only to check whether HT D H.CT  1; C.T /; T /y holds in order to decrease the
computation overload.

5.4. VDB FRAMEWORK FROM BINDING VECTOR COMMITMENT
57
• Update.SK; x; v0
x/: To update the record of index x, C ﬁrstly retrieves the current record vx
from S. at is, C obtains   Query.PK; S; x/ from S and checks that Verify.PK; x; / D
vx ¤?.
Set
T  T C 1,
C
ﬁrstly
computes
C .T / D
CT  1
HT  1 hv0
x vx
x
and
t0
x D HT D
H.CT  1; C.T /; T /y, and then sends .t0
x; v0
x/ to S. If t0
x is valid, then S computes
CT D HT C.T / and updates the public key with PK D .PP; Y; CR; CT /. Also, S uses the
value of v0
x to update the database record of index x, i.e., DB.x/  v0
x. Finally, S adds the
information of .t0
x D HT ; CT  1; C.T /; T / to aux in S.
5.4.2
SECURITY ANALYSIS OF THE VDB SCHEME
In this section, we present the security analysis of the above VDB scheme.
eorem 5.7
e proposed VDB scheme achieves the property of security.
Proof. Similar to [41], we can prove the theorem by contradiction. Assume there exists
a polynomial-time adversary A that has a non-negligible advantage  in the experiment
ExpVDB
A ŒDB; k for some initial database DB, then we can use A to build an eﬃcient algorithm
B to break the Squ-CDH assumption. at is, B takes as input a tuple .g; ga/ and outputs ga2.
First, B randomly chooses an element x 2R Zq as a guess for the index x on which A
succeeds in the experiment ExpVDB
A ŒDB; k. en B randomly chooses zi 2R Zp and computes
hi D gzi all 1  i ¤ x  q. Let hx D ga. Besides, B computes:
hi;j D gzizj for all 1  i ¤ j  q and i; j ¤ x;
hi;x D hx;i D .ga/zi for all 1  i  q and i ¤ x.
Set PP D .p; q; G1; G2; H; e; g; fhig; fhi;j g/, where 1  i ¤ j  q. en B randomly se-
lects an element y 2R Zp and computes Y D gy. Given a database DB, B computes the com-
mitment CR D Qq
iD1 hvi
i . Also, B computes H0 D H.CR; CR; 0/y and C0 D H0CR. Deﬁne
PK D .PP; Y; CR; C0/, S D .PP; aux; DB/ and SK D y. B sends PK to A. Note that PK and S are
perfectly distributed as the real ones.
To answer the verify and update queries of A in the experiment, B just simply runs the real
Query.PK; S; x/ and Update.SK; x; v0
x/ algorithms and responds with the same value. Note that
the Update.SK; x; v0
x/ algorithm requires the secret key y of B, and A cannot perform this algo-
rithm without the help of B. erefore, the FAU attack is no longer successful in the experiment
Exp0VDB
A ŒDB; k.
Suppose that . Ox; O/ be the tuple returned by A at the end of the experiment, where O D
.Ov; O; ˙l/. Besides, note that if A wins with a non-negligible advantage  in the experiment, then
we have Ov ¤?, Ov ¤ v.l/
Ox and e.C.l/; h Ox/ D e.h
v.l/
Ox
Ox
; h Ox/e..l/
Ox ; g/ D e.h Ov
Ox; h Ox/e. O; g/.
If Ox ¤ x, B aborts the simulation and fails. Otherwise, we have h Ox D ga. Trivially, B can
compute
ga2 D . O=.l/
Ox /.v.l/
Ox   Ov/ 1:

58
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
e success probability of B is =q.

eorem 5.8
e proposed VDB scheme achieves the property of correctness.
Proof. If the server is assumed to be honest in the VDB scheme, then the proofs  D
.v.T /
x
; .T /
x
; HT ; CT  1; C.T /; T /, where .T /
x
D Q
1j q;j ¤x h
v.T /
j
x;j . Firstly, note that HT D
H.CT  1; C.T /; T /y, therefore we have e.HT ; g/ D e.H.CT  1; C.T /; T /; Y/. Secondly, due
to CT =HT hv.T /
x
x
D C.T /=hv.T /
x
x
D Q
1jq;j ¤x h
v.T /
j
j
, we have e.CT =HT hv.T /
x
x
; hx/ D e..T /
x
; g/.
Hence, the output of the veriﬁcation algorithm is always the value v.T /
x
.

eorem 5.9
e proposed VDB scheme achieves the property of eﬃciency.
Proof. It is trivial that the computational resources invested by the client in the VDB scheme is
independent of q (except for a one-time Setup phase).

eorem 5.10
e proposed VDB scheme achieves the property of accountability.
Proof. Given the proofs  with the counter T , the client ﬁrstly compares it with the latest counter
Tc he stored. If T < Tc, then the client sends the corresponding signature  on Tc to the judge
as the proof. Otherwise, he sends  to the judge as the proof since the veriﬁcation of  will fail if
the server has tampered with the database.

5.5
INCREMENTAL VDB FRAMEWORK
Chen et al. [52] ﬁrst introduced a new notion named VDB with incremental updates (Inc-VDB,
for short), means that re-computing and updating the ciphertext in VDB are both incremental
algorithms, i.e., the client can eﬃciently perform both operations with previous values, rather
than from scratch. e motivation is that the database undergoes frequent while small updates
in some scenarios. For example, one anti-virus company outsources its virus database to a cloud
server. Also, the company must add the newly discovered viruses to the database everyday. Gen-
erally, the daily newly discovered viruses are a very tiny part of whole database and almost all
parts of the database remain unchanged. However, the company is still required to re-compute
and update the whole ciphertext everyday (note that the ciphertext is totally diﬀerent even if the
plaintext is modiﬁed only 1 bit for almost all provable secure encryption schemes). For a very
large database, it is extremely expensive for the resources-constrained client to re-compute and
update the ciphertext from scratch each time.
e notion of incremental encryption [15, 16] seems a naive solution for Inc-VDB scheme.
For example, if a single block of the data is modiﬁed (we can view the data as a sequence of blocks),
the client only needs to re-compute the ciphertext on this certain block and the ciphertext of other

5.5. INCREMENTAL VDB FRAMEWORK
59
blocks remains identical [19, 101]. Nevertheless, this incremental encryption method does not
provide a full solution for constructing eﬃcient Inc-VDB schemes. e reasons are two-fold:
Firstly, previous incremental encryption schemes cannot solve the case of distributed updates on
the data. at is, multiple blocks of the plaintext are modiﬁed while the modiﬁcation on each
single block is very small. e worst case is that every block of the plaintext is updated while
only one bit for each single block is changed. If this case happens, the client must re-compute
the whole ciphertext from scratch. Secondly, previous incremental encryption schemes cannot
necessarily lead to incremental updates on VDB. at is, the update algorithm of VDB is not
incremental and the client still needs to re-compute a new updated token from scratch each time.
Chen et al. [52] proposed a new incremental encryption based on the bit ﬂipping oper-
ation and then presented an eﬃcient Inc-VDB framework from vector commitment and the
incremental encrypt-then-MAC mode of encryption.
5.5.1
INCREMENTAL ENCRYPTION BASED ON BIT FLIPPING
e proposed incremental encryption based on bit ﬂipping is a main building block to construct
Inc-VDB schemes. Actually, it is a general mechanism for converting any provable secure encryp-
tion scheme into an incremental one. e construction ˘ D .KG; ENC; DEC; Inc-ENC; Inc-DEC/ is
given as follows:
• KG: On input the security parameter k, the key generation algorithm outputs the se-
cret/public key pair .SK; PK/. Without loss of generality, let ˘0 D .KG; ENC; DEC/ be any
IND-CCA secure (symmetric or asymmetric) encryption scheme and the key is implicit
in the notation for simplicity. Trivially, the public key PK is an empty string if ˘0 is a
symmetric scheme.
• ENC: On input a message m, the encryption algorithm outputs a ciphertext c D ENC.m/.
• DEC: On input the ciphertext c, the decryption algorithm outputs the message m D DEC.c/.
• Inc-ENC: On input a slightly modiﬁed message m0, the original message m, and the ciphertext
c on m, the incremental encryption algorithm outputs the (incremental) ciphertext c0 D
Inc-ENC.m0; c; m/ D .c; P /, where P D .p1; p2;    ; p!/ denotes the bit positions where
m0 and m have diﬀerent values, i.e., mŒpi ¤ mŒpi for 1  i  !.
• Inc-DEC: On input the ciphertext c0 D .c; P /, the incremental decryption algorithm outputs
the message m0. Trivially, it ﬁrstly decrypts c to obtain m and then performs the bit ﬂipping
operation on the location pi (1  i  !) of m.
In the following, we present the formal security proof of our construction.
eorem 5.11
If ˘0 is an IND-CCA secure (symmetric or asymmetric) encryption scheme, then ˘
is also an IND-CCA secure encryption scheme.

60
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
Proof. We prove by contradiction. Assume that there exists a polynomial time IND-CCA adver-
sary A can successfully attack the scheme ˘ with a non-negligible probability  in time T , then
we can construct another polynomial time IND-CCA adversary A0 that uses A as a subroutine
to attack the scheme ˘0. Without loss of generality, we assume that A can make at most q1 C q2
decryption queries.
Let c0
i D .ci; Pi/ be a decryption query issued by A.Trivially, A0 can relay the partial de-
cryption query ci to the challenger C in ˘0. Suppose the response of C is mi, A0 performs the
bit ﬂipping operation on the location Pi of mi to obtain m0
i. en A0 responds m0
i to the query
c0
i of A.
After issuing q1 decryption queries, A chooses two distinct (challenge) messages (m0
0, m0
1)
and sends them to A0. Similarly, A0 can compute two corresponding (challenge) messages (m0,
m1) for scheme ˘0, where mb (b 2 f0; 1g) is obtained by performing the bit ﬂipping operation
on the location P of m0
b and P is some bit positions randomly chosen by A0.
Let the challenge ciphertext by C be c D ENC.mb/. Trivially, A0 can compute the corre-
sponding challenge ciphertext c0 D .c; P/ for A. en A can issue further q2 decryption queries
except c0 and A0 responds in the same way as above.
Finally, A outputs its guess b0 2 f0; 1g. en A0 can replay b0 as its guess in the scheme
˘0. Trivially, the success probability of A0 is also .

As pointed out in [16], incremental encryption leaks some information that is kept secret
when using a traditional encryption scheme. In the proposed incremental encryption scheme
Inc-ENC, an adversary can determine where a modiﬁcation takes place, but still cannot determine
the symbol being modiﬁed (i.e., hide details about the data record m and m0). is is similar to
previous incremental encryptions [16, 19, 101]. In order to achieve stronger privacy, it should also
encrypt the modiﬁed location information P . at is, Inc-ENC.m0/ D .ENC.m/; ENC.P //. On the
other hand, though we only focus on the bit ﬂipping operation in our construction, it can be
extended to other operations such as insertion, deletion, etc.
On the other hand, we present a method to represent the ciphertext eﬃciently. Suppose the
ciphertext is .ENC.m/; P1;    ; Pl/ after performing l rounds of update. We give the following
recursive deﬁnition if we view Pj as a set:
NP1 D P1;
NPj C1 D NPj ˚ Pj C1 D . NPj   PjC1/ [ .Pj C1   NPj /:
As a result, the ciphertext is now .ENC.m/; NPl/ (or .ENC.m/; ENC. NPl// to enhance the privacy).
is ensures deletion of the identical positions information of Pj (thus no bit ﬂipping operation
is required in these positions) and the ciphertext is also shortened.

5.5. INCREMENTAL VDB FRAMEWORK
61
5.5.2
INC-VDB FRAMEWORK
Chen et al. [52] introduced the Inc-VDB framework by incorporating the primitive of vector
commitment and the encrypt-then-incremental MAC mode of encryption. e main trick is
two-fold:
Firstly, the framework uses the above incremental encryption to generate the updated ci-
phertext v0
x. More precisely, deﬁne v0
x D .vx; Px/, where Px D .p1; p2;    ; p!/ denotes the bit
positions where m0
x and mx have diﬀerent values, i.e, m0
xŒpi ¤ mxŒpi for 1  i  !. Trivially,
given v0
x D .vx; Px/, the client ﬁrstly decrypts vx to obtain mx, and then performs the bit ﬂip-
ping operation on the positions of Px to obtain m0
x. Since the bit ﬂipping operation is extremely
fast, the computation overhead of decrypting v0
x is almost the same as that of decrypting vx.
Moreover, it requires much less storage since jPxj << jv0
xj (note that we only consider the case
of incremental updates).
Secondly, the framework utilizes the encrypt-then-incremental MAC mode of encryption
[19], i.e., an incremental encryption together with an incremental MAC of the ciphertext (the
encrypt-then-MAC approach [29]), to generate the updated token t0
x. Also, it uses an incremental
version of the BLS signature scheme [27] to substitute the incremental MAC. For every update,
the client ﬁrst veriﬁes the current BLS signature on the commitment CR and all the current
modiﬁcations .P .1/
x ;    ; P .T /
x
/ of the data record vx, where P .i/
x
denotes the modiﬁcation in
the i-th update for 1  i  T . is ensures that the current database is not tampered with by
the server.⁹ If the veriﬁcation holds, the client then sends a new modiﬁcation P .T C1/
x
and the
corresponding (incremental) BLS signature to the server.
Since the framework also uses the signature to achieve the integrity of the database, it is
essential to invoke the previous signatures given to the server. e trick is that the server computes
a BLS signature  on all counters Tx for 1  x  q, where Tx denotes the update number of each
index x. After an update on the record vx is accomplished, let Tx  Tx C 1. en the server
computes an incremental BLS signature on the updated counters (note that only the value of Tx
is slightly modiﬁed). Given a previous signature  on the count Tx, the client can reject it by
providing a new signature 0 on the latest counter T 0
x since Tx < T 0
x. Note that the server cannot
deny his signature, therefore this is a proof that the server is dishonest when a dispute occurred.
Note that the paradigm by incorporating the primitive of vector commitment and the
encrypt-then-incremental MAC mode of encryption actually provides a general framework for
constructing Inc-VDB schemes. at is, if we use diﬀerent vector commitment schemes and
incremental encryption/signature schemes, we can obtain various constructions for Inc-VDB
schemes.
⁹Bellare, Goldreich, and Goldwasser pointed out that some incremental signature schemes may suﬀer from the so-called
substitution attack in some scenarios. However, it assumed that the adversary can successfully tamper with the data and
the signer does not check the corresponding signatures. Obviously, the attack does not work in our scheme.

62
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
5.5.3
A CONCRETE INC-VDB SCHEME
In this section, we introduce a concrete Inc-VDB scheme based on the CDH assumption [52].
• Setup.1k; DB/: Let k be a security parameter. Let the database be DB D .x; vx/ for
1  x  q. Let G1 and G2 be two cyclic multiplicative groups of prime order p
equipped with a bilinear pairing e W G1  G1 ! G2. Let g be a generator of G1. Let
H W G1  f0; 1g ! G1 be a cryptographic hash function. Randomly choose q elements
zi 2R Zp and compute hi D gzi, hi;j D gzizj , where 1  i; j  q and i ¤ j. Set PP D
.p; q; G1; G2; H; e; g; fhig1iq; fhi;j g1i;j q;i¤j /, and the message space M D Zp.¹⁰
Let .˛; Y D g˛/ and .ˇ; Z D gˇ/ be the secret/public key pair of the client C and server S,
respectively, where ˛; ˇ 2R Z
p. Trivially, the validity of Y and Z are ensured by the corre-
sponding certiﬁcate of a trusted third party, i.e, certiﬁcate authority. Let CR D Qq
iD1 hvi
i
be the root commitment on the database record vector .v1; v2;    ; vq/. For 1  x  q, let
Tx be a counter for index x with the initial value 0 and H .0/
x
D H.CR; x; 0/˛. S can use
the batch veriﬁcation technique of BLS signatures [43] to ensure the validity of H .0/
x
for
1  x  q, which requires only the workload of two pairings. en S computes a signature
 D H.CR; 0; 0;    ; 0/ˇ on CR and all initial counters .0; 0;    ; 0/ (note that all Tx has an
initial value 0). Also, set aux D faux1;    ; auxqg, where auxx D .H .0/
x ; 0/ for 1  x  q.
Deﬁne PK D .PP; CR; aux; DB/ and SK D ˛.
• Query.PK; x/: Assume that the current public key PK D .PP; CR; aux; DB/. Given a query
index x, S computes x D Q
1j q;j ¤x h
vj
x;j and returns the proofs
 D .vx; x; H .Tx/
x
; P .1/
x ;    ; P .Tx/
x
; Tx/:
Note that the proof x D Q
1j q;j ¤x h
vj
x;j is always identical for all queries to the same
index x. erefore, S only needs to compute x once for the ﬁrst query on index x (this is
diﬀerent from the scheme [41]). Trivially, S requires much less computational overhead for
the query algorithms.
• Verify.PK; x; /: Parse the proofs  D .vx; x; H .Tx/
x
; P .1/
x ;    ; P .Tx/
x
; Tx/. If the counter Tx
in  is less than the one in  that C stored locally, C rejects the proofs . Otherwise, C can
verify the validity of  by checking whether the following two equations e.CR=hvx
x ; hx/ D
e.x; g/ and e.H .Tx/
x
; g/ D e.H.CR; x; P .1/
x ;    ; P .Tx/
x
; Tx/; Y/ hold. If the proofs  are
valid, C accepts them and outputs v.Tx/
x
D .vx; P .1/
x ;    ; P .Tx/
x
/. Otherwise, outputs an
error ?.
• Inc-Update.SK; x; P .TxC1/
x
/: To update the record of index x, C ﬁrstly retrieves the cur-
rent record v.Tx/
x
from S. at is, C obtains   Query.PK; x/ from S and checks that
¹⁰ough the message space M in this construction is Zp, it can be easily extended to support possibly large payload vi by
using a collision-resistant hash function H W f0; 1g ! Zp.

5.5. INCREMENTAL VDB FRAMEWORK
63
Verify.PK; x; / D v.Tx/
x
¤?. en C computes the incremental signature
t0
x D H .TxC1/
x
D H.CR; x; P .1/
x ;    ; P .TxC1/
x
; Tx C 1/˛
and then sends .t0
x; P .TxC1/
x
/ to S. If t0
x is valid, then S adds P .TxC1/
x
to the record of index
x, and updates auxx in PK, i.e., auxx  .t0
x; P .1/
x ;    ; P .TxC1/
x
; Tx C 1/. Also, S computes
an updated incremental signature  D H.CR; T1; T2;    ; Tx C 1;    ; Tq/ˇ and sends it to
C. If  is valid, C updates it together with Tx C 1 locally. Finally, set Tx  Tx C 1.
Remark 7. e storage overhead of the client in our construction is all counters Tx and the latest
BLS signature . Note that the number of Tx is dependent on q, we estimate the storage overload
of client for very large q.
Assume that q D 108 and the counter Tx for each index x is 106 (that is, the database has
108 records and for each index x it has been updated 1 million times). is means that the total
number of update for the database is 106108 (this is a giant updates number in real applications).
However, the storage of the client is only about 7  108 bits (less that 700 M). It is still tolerable
even for a resource-limited client.
In the following, a new solution is given in order to further reduce the storage overload of
the client. e trick is to still use vector commitment. e server computes the signature  D
H.CR; CT /ˇ, where CT is the vector commitment on all counters .T1; T2;    ; Tq/. erefore, the
client only requires storing  and CT , and the storage overhead is independent of q. Trivially, the
server should provide a valid opening of CT as a proof during the veriﬁcation phase. Due to the
property of vector commitment, the update of CT is still incremental.


65
C H A P T E R
6
Conclusion and Future Works
Outsourcing computation is a fruitful and long-standing research topic in the academic commu-
nity. With the development of cloud computing and big data, we believe that more and more
researchers will focus on this hot topic. In this book, we present research progress on outsourcing
computation, while it is far from complete due to space and time constraints.
In the following, we present some (possible) future works and open problems in outsourcing
computation.
• In the outsourcing scientiﬁc computations, how do we achieve the CCA security for the
inputs? A totally random blinding or disguise technique seems not to work. For example,
if we blind a dense matrix with rank n by multiplying a randomly chosen dense matrix,
the computation overload should be n3. In this sense, we should ﬁnd some more eﬃcient
algorithms which can still achieve the strongest security notions.
• Is it possible to ﬁnd an eﬃcient algorithm for securely outsourcing the cryptographic oper-
ations by only using an untrusted server? Note that the algorithm should also only require
one round of interaction between the server and the client. We left it as an open problem.
• e system parameters in current VDB schemes are proportional to the number of database
indices. us, the constructions are given in the amortized model. It is interesting to pro-
pose a construction (or a framework) for eﬃcient VDB with constant system parameters.
Besides, the current VDB schemes do not support the insertion kind of update since the
number of database indices is ﬁxed in advance. erefore, an interesting open problem is
to propose an eﬃcient VDB scheme supporting all kinds of update operations (insertion,
deletion, and replacement).
• How do we detect the misbehavior of an untrusted server in the multiple results of outsourc-
ing computations? For example, the computation task is to ﬁnd all collisions of one-way
function or to ﬁnd all solutions of a large-scale linear equation (the solution is not unique).
In these scenarios, the servers may not send all the computation results to the client. In the
worst case, the untrusted server just responds with an empty set. e idea of ringer is a par-
tial solution that is only suitable for an “inversion of one-way function” class of outsourcing
computations. Is there any other eﬃcient solution to solve this problem by using some new
primitives, such as veriﬁably searchable encryption?

66
6. CONCLUSION AND FUTURE WORKS
• It seems that VDB is closely related to proof of retrievability (PoR) [55, 64, 86, 119, 129].
What is the essential relationship between the two primitives? On the other hand, the
current VDB schemes rarely consider the privacy of the clients, especially in the multi-client
scenarios. erefore, it is interesting to design eﬃcient privacy-preserving VDB schemes
using some new cryptographic primitives.
• Backes, Fiore, and Reischuk [13] ﬁrstly introduced the idea of outsourcing big data. at
is, the size of outsourced data is very huge while not ﬁxed beforehand (the data may be
changing and increasing). Currently, we are facing the era of big data. us, it is interesting
to construct more ﬂexible and eﬃcient outsourcing schemes for big data.

67
Bibliography
[1] M.J. Atallah and K.B. Frikken. Securely outsourcing linear algebra computations. Pro-
ceedings of the 5th ACM Symposium on Information, Computer and Communications Security
(ASIACCS), pp. 48–59, 2010. DOI: 10.1145/1755688.1755695. 3, 19
[2] M. Abadi, J. Feigenbaum, and J. Kilian. On hiding information from an oracle. Proceedings
of the 19th Annual ACM Symposium on eory of Computing (STOC), pp. 195–203, 1987.
DOI: 10.1145/28395.28417. 19
[3] M.J. Atallah and J. Li. Secure outsourcing of sequence comparisons. International Journal
of Information Security, 4(4), pp. 277–287, 2005. DOI: 10.1007/s10207-005-0070-3. 19
[4] B. Andrei and M. Michael. Network applications of bloom ﬁlters: A survey. Internet Math-
ematics, 1(4), pp. 485–509, 2004. DOI: 10.1080/15427951.2004.10129096. 17
[5] G. Ateniese and B. de Medeiros. Identity-based chameleon hash and applications. Finan-
cial Cryptography (FC), LNCS 3110, Springer, pp. 164–180, 2004. DOI: 10.1007/978-3-
540-27809-2_19. 38
[6] G. Ateniese and B. de Medeiros. On the key-exposure problem in chameleon hashes.
Security in Communication Networks (SCN), LNCS 3352, Springer, pp. 165–179, 2005.
DOI: 10.1007/978-3-540-30598-9_12. 38
[7] M.J. Atallah, K.N. Pantazopoulos, J.R. Rice, and E.H. Spaﬀord. Secure outsourcing
of scientiﬁc computations. Advances in Computers, vol. 54, pp. 216–272, 2001. DOI:
10.1016/s0065-2458(01)80019-x. 3, 19, 20, 22, 23
[8] D. Benjamin and M.J. Atallah. Private and cheating-free outsourcing of algebraic com-
putations. Proceedings of the 6th Annual Conference on Privacy, Security and Trust (PST),
pp. 240–245, 2008. DOI: 10.1109/pst.2008.12. 19
[9] G. Brassard, D. Chaum, and C. Crepeau. Minimum disclosure proofs of knowledge.
Journal of Computer and System Sciences, 37(2), pp. 156–189, 1988. DOI: 10.1016/0022-
0000(88)90005-0. 38
[10] F. Bao, R. Deng, and H. Zhu. Variations of Diﬃe-Hellman Problem. Information
and Communications Security (ICS), LNCS 2836, pp. 301–312, Springer, 2003. DOI:
10.1007/978-3-540-39927-8_28. 11

68
BIBLIOGRAPHY
[11] D. Boneh and M. Franklin. Identity-based encryption from the Weil pairings. Advances
in Cryptology-Crypto 2001, LNCS 2139, pp. 213–229, Springer, 2001. DOI: 10.1007/3-
540-44647-8_13. 12
[12] D. Beaver, J. Feigenbaum, J. Kilian, and P. Rogaway. Locally random reductions:
Improvements and applications. Journal of Cryptology, 10(1), pp. 17–36, 1997. DOI:
10.1007/s001459900017. 34
[13] M. Backes, D. Fiore, and R.M. Reischuk. Veriﬁable Delegation of Computation on Out-
sourced Data. Proceedings of the ACM Conference on Computer and Communications Security
(CCS), pp. 863–874, ACM, 2013. DOI: 10.1145/2508859.2516681. 3, 66
[14] M. Ben-Or, S. Goldwasser, J. Kilian, and A. Wigderson. Multi-prover interactive proofs:
How to remove intractability assumptions. Proceedings of the ACM Symposium on eory of
Computing (STOC), pp. 113–131, 1988. DOI: 10.1145/62212.62223. 33
[15] M. Bellare, O. Goldreich, and S. Goldwasser. Incremental cryptography: e case of
hashing and signing. Advances in Cryptology-CRYPTO 1994, LNCS 2836, pp. 216–233,
Springer, 1994. DOI: 10.1007/3-540-48658-5_22. 58
[16] M. Bellare, O. Goldreich, and S. Goldwasser. Incremental Cryptography and Application
to Virus Protection. Proceedings of the 27th ACM Symposium on the eory of Computing
(STOC), pp. 45–56, 1995. DOI: 10.1145/225058.225080. 58, 60
[17] D. Boneh, E.J. Goh, and K. Nissim. Evaluating 2-dnf formulas on ciphertexts. eory of
Cryptography, pp. 325–341, Springer, 2005. DOI: 10.1007/978-3-540-30576-7_18. 12
[18] S. Benabbas, R. Gennaro, and Y. Vahlis. Veriﬁable delegation of computation over large
datasets. Advances in Cryptology-CRYPTO 2011, LNCS 6841, pp. 111–131, Springer,
2011. DOI: 10.1007/978-3-642-22792-9_7. 12, 15, 45, 46, 47, 52, 53, 54
[19] E. Buonanno, J. Katz, and M. Yung. Incremental Unforgeable Encryption. Fast Soft-
ware Encryption (FSE), LNCS 2355, pp. 109–124, Springer, 2002. DOI: 10.1007/3-540-
45473-x_9. 59, 60, 61
[20] M. Benzi. Preconditioning Techniques for Large Linear Systems: A Survey. Journal of
Computational Physics, 182, pp. 418–477, 2002. DOI: 10.1006/jcph.2002.7176. 23, 26
[21] D. Boneh. Twenty years of attacks on the RSA cryptosystem. Notices of the American Math-
ematical Society, 46(2), pp. 203–213, 1999. 29
[22] M. Blanton. Improved conditional e-payments. Applied Cryptography and Network Security
(ACNS), LNCS 5037, pp. 188–206, Springer, 2008. DOI: 10.1007/978-3-540-68914-
0_12. 4

BIBLIOGRAPHY
69
[23] M. Blanton, M.J. Atallah, K.B. Frikken, and Q. Malluhi. Secure and eﬃcient outsourc-
ing of sequence comparisons. ESORICS 2012, LNCS 7459, pp. 505–522, Springer, 2012.
DOI: 10.1007/978-3-642-33167-1_29. 19
[24] B.H. Bloom. Space/Time trade-oﬀs in hash coding with allowable Errors, Communications
of the ACM, 13(7), pp. 422–426, 1970. DOI: 10.1145/362686.362692. 17
[25] M. Blum, M. Luby, and R. Rubinfeld. Program result checking against adaptive programs
and in cryptographic settings. DIMACS Series in Discrete Mathematics and eoretical Com-
puter Science, pp. 107–118, 1991. 33
[26] M. Blum, M. Luby, and R. Rubinfeld. Self-testing/correcting with applications to nu-
merical problems. Journal of Computer and System Science, 47(3), pp. 549–595, 1993. DOI:
10.1016/0022-0000(93)90044-w. 33
[27] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairings. Advances
in Cryptology-Asiacrypt, LNCS 2248, pp. 514–532, Springer, 2001. DOI: 10.1007/3-540-
45682-1_30. 12, 61
[28] F. Bonomi, M. Mitzenmacher, R. Panigrahy, S. Singh, and G. Varghese. An Improved
Construction for Counting Bloom Filters. Algorithms CESA, pp. 684–695, Springer, 2006.
DOI: 10.1007/11841036_61. 17
[29] M. Bellare and C. Namprempre. Authenticated Encryption: Relations Among Notions
and Analysis of the Generic Composition Paradigm. Advances in Cryptology-Asiacrypt,
LNCS 1976, pp. 531–545, Springer, 2000. DOI: 10.1007/3-540-44448-3_41. 61
[30] P. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. Selected Areas
in Cryptography, pp. 319–331, Springer, 2006. DOI: 10.1007/11693383_22. 43
[31] V. Boyko, M. Peinado, and R. Venkatesan. Speeding up discrete log and factoring based
schemes via precomputations. Advances in Cryptology-Eurocrypt, LNCS 1403, pp. 221–
232, Springer, 1998. DOI: 10.1007/bfb0054129. 30, 34
[32] D. Boneh and B. Waters. Conjunctive, subset, and range queries on encrypted data. eory
of Cryptography, LNCS 4392, pp. 535–554, Springer, 2007. DOI: 10.1007/978-3-540-
70936-7_29. 12
[33] D. Chaum. Blind signature for untraceable payments. Advances in Cryptology-Eurocrypt,
pp. 199–203, 1982. DOI: 10.1007/978-1-4757-0602-4_18. 20
[34] D. Chaum and T. Pedersen. Wallet databases with observers. Advances in Cryptology-
Crypto, LNCS 740, pp. 89–105, Springer, 1993. DOI: 10.1007/3-540-48071-4_7. 30

70
BIBLIOGRAPHY
[35] S. Chow, M. Au, and W. Susilo. Server-aided signatures veriﬁcation secure against collu-
sion attack. Proceedings of the 6th ACM Symposium on Information, Computer and Commu-
nications Security (ASIACCS), pp. 401–405, 2011. DOI: 10.1145/1966913.1966967.
[36] J. Cha and J.H. Cheon. An identity-based signature from gap Diﬃe CHellman groups.
PKC 2003, LNCS 2567, pp. 18–30, Springer, 2003. DOI: 10.1007/3-540-36288-6_2. 12
[37] B. Chevallier-Mames, J. Coron, N. McCullagh, D. Naccache, and M. Scott. Secure del-
egation of elliptic-curve pairing. Smart Card Research and Advanced Application, LNCS
6035, pp. 24–35, Springer, 2010. DOI: 10.1007/978-3-642-12510-2_3. 30, 40
[38] R. Cramer and I. Damgard. Multiparty computation, an introduction. Contemporary Cryp-
tology, pp. 41–87, 2005. DOI: 10.1007/3-7643-7394-6_2. 2
[39] S. Canard, J. Devigne, and O. Sanders. Delegating a pairing can be both secure and ef-
ﬁcient. Applied Cryptography and Network Security, pp. 549–565, Springer, 2014. DOI:
10.1007/978-3-319-07536-5_32. 43
[40] D. Catalano, D. Fiore, and M. Messina. Zero-knowledge sets with short proofs. Ad-
vances in Cryptology-EUROCRYPT, LNCS 4965, pp. 433–450, Springer, 2008. DOI:
10.1007/978-3-540-78967-3_25. 14
[41] D. Catalano and D. Fiore. Vector commitments and their applications. PKC 2013, LNCS
7778, pp. 55–72, Springer, 2013. DOI: 10.1007/978-3-642-36362-7_5. 14, 15, 45, 46,
51, 57, 62
[42] X. Chen, F. Zhang, and K. Kim. Chameleon Hashing without Key Exposure. Information
Security Conference, LNCS 3225, pp. 135–148, Springer, 2004. DOI: 10.1007/978-3-540-
30144-8_8. 38
[43] J. Camenisch, S. Hohenberger, and M. Pedersen. Batch Veriﬁcation of Short Signatures.
Advances in Cryptology-EUROCRYPT, LNCS 4515, pp. 246–263, Springer, 2007. DOI:
10.1007/978-3-540-72540-4_14. 62
[44] X. Chen, F. Zhang, W. Susilo, and Y. Mu. Eﬃcient generic online/oﬀ-line signatures
without key exposure. Applied Cryptography and Network Security (ACNS), LNCS 4521,
pp. 18–30, Springer, 2007. DOI: 10.1007/978-3-540-72738-5_2. 38
[45] X. Chen, J. Li, and W. Susilo. Eﬃcient Fair Conditional Payments for Outsourcing Com-
putations. IEEE Transactions on Information Forensics and Security, 7(6), pp. 1687–1694,
2012. DOI: 10.1109/tifs.2012.2210880. 3, 4
[46] X. Chen, F. Zhang, W. Susilo, H. Tian, J. Li, and K. Kim. Identity-based chameleon
hashing and signatures without key exposure. Information Sciences, 265, pp. 198–210, 2014.
DOI: 10.1016/j.ins.2013.12.020. 38

BIBLIOGRAPHY
71
[47] X. Chen, J. Li, X. Huang, J. Ma, and W. Lou. New publicly veriﬁable databases with
eﬃcient updates. IEEE Transactions on Dependable Secure Computing, 12(5), pp. 546–556,
2015. DOI: 10.1109/tdsc.2014.2366471. 51, 52, 54, 56
[48] X. Chen, W. Susilo, F. Zhang, H. Tian, and J. Li. Identity-Based Trapdoor Mercurial
Commitment and Applications. eoretical Computer Science, 412(39), pp. 5498–5512,
2011. DOI: 10.1016/j.tcs.2011.05.031. 14
[49] X. Chen, J. Li, J. Ma, Q. Tang, and W. Lou. New algorithms for secure outsourcing of
modular exponentiations. ESORICS, LNCS 7459, pp. 541–556, Springer, 2012. DOI:
10.1007/978-3-642-33167-1_31. 3, 33, 35, 38, 39
[50] X. Chen, J. Li, X. Huang, J. Li, Y. Xiang, and D. Wong. Secure Outsourced Attribute-
based Signatures. IEEE Transactions on Parallel and Distributed Systems, 25(12), pp. 3285–
3294, 2014. DOI: 10.1109/tpds.2013.2295809. 3
[51] X. Chen, X. Huang, J. Li, J. Ma, and W. Lou. New Algorithms for Secure Outsourcing of
Large-scale Systems of Linear Equations. IEEE Transactions on Information and Forensics
Security, 10(1), pp. 69–78, 2015. DOI: 10.1109/tifs.2014.2363765. 20, 24
[52] X. Chen, J. Li, J. Weng, J. Ma, and W. Lou. Veriﬁable Computation over Large Database
with Incremental Updates. ESORICS, LNCS 8712, pp. 148–162, Springer, 2014. DOI:
10.1007/978-3-319-11203-9_9. 58, 59, 61, 62
[53] X. Chen, W. Susilo, J. Li, D.S. Wong, J. Ma, S. Tang, and Q. Tang. Eﬃcient algorithms
for secure outsourcing of bilinear pairings. eoretical Computer Science, 562, pp. 112–121,
2015. DOI: 10.1016/j.tcs.2014.09.038. 41, 42
[54] X. Chen et al. Publicly Veriﬁable Databases with All Eﬃcient Operations, manuscipt.
DOI: 10.1109/tdsc.2014.2366471. 18
[55] R. Curtmola, O. Khan, and R. Burns. Robust remote data checking. Proceeding of the 4th
ACM Workshop on Storage Security and Survivability (StorageSS), pp. 63–68, 2008. DOI:
10.1145/1456469.1456481. 66
[56] J. Camenisch, M. Kohlweiss, and C. Soriente. An accumulator based on bilinear maps and
eﬃcient revocation for anonymous credentials. PKC, LNCS 5443, pp. 481–500, Springer,
2009. DOI: 10.1007/978-3-642-00468-1_27. 45
[57] J. Camenisch and A. Lysyanskaya. Dynamic accumulators and application to eﬃcient re-
vocation of anonymous credentials. Advances in Cryptology-CRYPTO, LNCS 2442, pp.
61–76, Springer, 2002. DOI: 10.1007/3-540-45708-9_5. 45

72
BIBLIOGRAPHY
[58] R. Canetti, B. Riva, and G.N. Rothblum. Practical delegation of computation using mul-
tiple servers. Proceedings of the 18th ACM Conference on Computer and Communications Se-
curity (CCS), pp. 445–454, 2011. DOI: 10.1145/2046707.2046759. 4, 7
[59] Y. Chen and R. Sion. Costs and Security in Clouds. Secure Cloud Computing, pp. 31–56,
Springer, 2014. DOI: 10.1007/978-1-4614-9278-8_2. 1
[60] Top reats Working Group. e notorious nine: cloud computing top threats in 2013.
Cloud Security Alliance Technical Report, 2013.
[61] B. Carbunar and M. Tripunitara. Conditioal payments for computing markets. Cryp-
tology and Network Security (CANS), LNCS 5339, pp. 317–331, Springer, 2008. DOI:
10.1007/978-3-540-89641-8_23. 4
[62] B. Carbunar and M. Tripunitara. Fair payments for outsourced computations. Pro-
ceedings of the 7th Annual IEEE Communications Society Conference on Sensor, Mesh
and Ad Hoc Communications and Networks (SECON), pp. 529–537, 2010. DOI:
10.1109/secon.2010.5508202. 4
[63] W. Diﬃe and M.E. Hellman. New directions in cryptography. IEEE Transactions in In-
formation eory, 22(6), pp. 644–654, 1976. DOI: 10.1109/tit.1976.1055638. 29
[64] Y. Dodis, S. Vadhan, and D. Wichs. Proofs of retrivability via hardness ampliﬁcation.
TCC, pp. 109–127, Springer, 2009. DOI: 10.1007/978-3-642-00457-5_8. 66
[65] D. Eppstein and M.T. Goodrich. Straggler Identiﬁcation in Round-Trip Data Streams
via Newton’s Identities and Invertible Bloom Filters. IEEE Transactions on Knowledge and
Data Engineering, 23(2), pp. 297–306, 2011. DOI: 10.1109/tkde.2010.132. 17
[66] S. Even, O. Goldreich, and S. Micali. On-line/Oﬀ-line digital signatures. Journal of Cryp-
tology, 9(1), pp. 35–67, Springer, 1996. DOI: 10.1007/bf02254791. 29, 34
[67] M. Fischlin and R. Fischlin. Eﬃcient non-malleable commitment schemes. Advances in
Cryptology, LNCS 1880, pp. 413–431, Springer, 2000. DOI: 10.1007/3-540-44598-6_26.
54
[68] K. Forsman, W. Gropp, L. Kettunen, D. Levine, and J. Salonen. Solution of dense sys-
tems of linear equations arising from integral-equation formulations. IEEE Antennas and
Propagation Magazine, 37(6), pp. 96–100, 1995. DOI: 10.1109/74.482076. 23
[69] C. Gentry. A fully homomorphic encryption scheme. Ph.D. thesis, Stanford University,
2009. 8
[70] C. Gentry. Fully homomorphic encryption using ideal lattices. Proceedings of the
ACM Symposium on the eory of Computing (STOC), pp. 169–178, 2009. DOI:
10.1145/1536414.1536440. 8

BIBLIOGRAPHY
73
[71] M. Girault and D. Lefranc. Server-aided veriﬁcation: theory and practice. Ad-
vances in Cryptology-Asiacrypt, LNCS 3788, pp. 605–623, Springer, 2005. DOI:
10.1007/11593447_33. 30, 34
[72] S. Galbraith, K. Paterson, and N. Smart. Pairings for cryptographers. Discrete Applied
Mathematics, 156(16), pp. 3113–3121, 2008. DOI: 10.1016/j.dam.2007.12.010. 40
[73] S. Goldwasser, Y.T. Kalai, and G.N. Rothblum. Delegating computation: interactive
proofs for muggles. Proceedings of the ACM Symposium on the eory of Computing (STOC),
pp. 113–122, 2008. DOI: 10.1145/1374376.1374396. 4
[74] R. Gennaro, C. Gentry, and B. Parno. Non-interactive veriﬁable computing: Outsourc-
ing computation to untrusted workers. Advances in Cryptology-CRYPTO, pp. 465–482,
Springer, 2010. DOI: 10.1007/978-3-642-14623-7_25. 1, 4, 5, 7, 8, 48
[75] J. Groth, R. Ostrovsky, and A. Sahai. Perfect non-interactive zero knowledge for NP.
Advances in Cryptology-EUROCRYPT, LNCS 4004, pp. 339–358, Springer, 2006. DOI:
10.1007/11761679_21. 12
[76] J. Groth and A. Sahai. Eﬃcient non-interactive proof systems for bilinear groups. Ad-
vances in Cryptology-EUROCRYPT, LNCS 4965, pp. 415–432, Springer, 2008. DOI:
10.1007/978-3-540-78967-3_24. 12
[77] S. Goldwasser, S. Micali, and C. Rackoﬀ. e knowledge complexity of interactive proof-
systems. SIAM Journal on Computing, 18(1), pp. 186–208, 1989. DOI: 10.1137/0218012.
[78] O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game. Proceedings
of the 19th Annual ACM Symposium on eory of Computing, pp. 218–229, 1987. DOI:
10.1145/28395.28420. 6
[79] P. Golle and I. Mironov. Uncheatable distributed computations. CT-RSA, LNCS 2020,
pp. 425–440, Springer, 2001. DOI: 10.1007/3-540-45353-9_31. 4, 7
[80] J. Garay, P. MacKenzie, and K. Yang. Strengthening zero-knowledge protocols using
signatures. Advances in Cryptology-Eurocrypt, LNCS 2656, pp. 177–194, Springer, 2003.
DOI: 10.1007/3-540-39200-9_11. 38
[81] S. Galbraith, K. Paterson, and N. Smart. Pairings for cryptographers. Discrete Applied
Mathematics, 156(16), pp. 3113–3121, 2008. DOI: 10.1016/j.dam.2007.12.010. 12
[82] S. Hohenberger and A. Lysyanskaya. How to securely outsource cryptographic com-
putations. eory of Cryptography, LNCS 3378, pp. 264–282, Springer, 2005. DOI:
10.1007/978-3-540-30576-7_15. 4, 5, 7, 30, 33, 34, 35, 36, 38, 40
[83] R.A. Horn and C.R. Johnson. Matrix Analysis. Cambridge University Press, 1985. 25

74
BIBLIOGRAPHY
[84] H. Hacigumus, B. Iyer, and S. Mehrotra. Providing database as a service. Proceedings
of the 18th International Conference on Data Engineering, pp. 29–38, IEEE, 2002. DOI:
10.1109/icde.2002.994695. 45
[85] J.J. Rotman. A First Course in Abstract Algebra, 3rd ed., Prentice Hall, Upper Saddle River,
New Jersey, pp. 127, 2005. 13
[86] A. Juels and B.S. Kaliski. PORs: proofs of retrievalibity for large ﬁles. Proceedings of the
14th ACM Conference on Computer and Communications Security (CCS), pp. 584–597, 2007.
DOI: 10.1145/1315245.1315317. 66
[87] J. Kilian. A note on eﬃcient zero-knowledge proofs and arguments. Proceedings of
the ACM Symposium on eory of Computing (STOC), pp. 723–732, 1992. DOI:
10.1145/129712.129782. 4
[88] J. Kilian. Improved eﬃcient arguments (preliminary version). Advances in Cryptology-
Crypto, pp. 311–324, Springer, 1995. 4
[89] T. Kleinjung, K. Aoki, J. Franke, et al. Factorization of a 768-bit RSA modulus. Advances
in Cryptology-Crypto, LNCS 6223, pp. 333–350, Springer, 2010. DOI: 10.1007/978-3-
642-14623-7_18. 1
[90] H. Krawczyk and T. Rabin. Chameleon hashing and signatures. NDSS, pp. 143–154, 2000.
38
[91] J. Katz, A. Sahai, and B. Waters. Predicate encryption supporting disjunctions, polynomial
equations, and inner products. Advances in Cryptology-EUROCRYPT, LNCS 4965, pp.
146–162, 2008. DOI: 10.1007/978-3-540-78967-3_9. 12
[92] J. Li, X. Huang, J. Li, X. Chen, and Y. Xiang. Securely Outsourcing Attribute-Based En-
cryption with Checkability. IEEE Transactions on Parallel and Distributed Systems, 25(8),
pp. 2201–2210, 2014. DOI: 10.1109/tpds.2013.271. 3
[93] A. Lathey, P. Atrey, and N. Joshi. Homomorphic low pass ﬁltering on encrypted mul-
timedia over cloud. IEEE International Conference on Semantic Computing, pp. 310–313,
2013. DOI: 10.1109/icsc.2013.60. 19
[94] A.K. Lenstra and E.R. Verheul. Selecting cryptographic key sizes. Journal of Cryptology,
14(4), pp. 255–293, Springer, 2001. DOI: 10.1007/s00145-001-0009-4. 29
[95] B. Libert and M. Yung. Concise mercurial vector commitments and independent zero-
knowledge sets with short proofs. eory of Cryptography, LNCS 5978, pp. 499–517,
Springer, 2010. DOI: 10.1007/978-3-642-11799-2_30. 14

BIBLIOGRAPHY
75
[96] S. Micali. CS proofs. Proceedings of the 35th Annual Symposium on Foundations of Computer
Science (FOCS), pp. 436–453, 1994. 4
[97] T. Matsumoto, K. Kato, and H. Imai. Speeding up secret computations with insecure
auxiliary devices. Advances in Cryptology-Crypto, LNCS 403, pp. 497–506, 1988. DOI:
10.1007/0-387-34799-2_35. 30, 34
[98] C.U. Martel, G. Nuckolls, P.T. Devanbu, M. Gertz, A. Kwong, and S.G. Stubblebine. A
general model for authenticated data structures. Algorithmica, 39(1), pp. 21–41, Springer,
2004. DOI: 10.1007/s00453-003-1076-8. 45
[99] A. Menezes, P. van Oorschot, and S. Vanstone. Handbook of Applied Cryptography. CRC
Press, 1996. DOI: 10.1201/9781439821916. 39
[100] M. Mohanty, W. Ooi, and P. Atrey. Scale me, crop me, know me not: Supporting scaling
and cropping in secret image sharing. IEEE International Conference on Multimedia and
Expo, pp. 1–6, 2013. DOI: 10.1109/icme.2013.6607567. 19
[101] I. Mironov, O. Pandey, O. Reingold, and G. Segev. Incremental Deterministic Public-Key
Encryption. Advances in Cryptology-Eurocrypt, LNCS 7237, pp. 628–644, Springer, 2012.
DOI: 10.1007/978-3-642-29011-4_37. 59, 60
[102] E. Mykletun, M. Narasimha, and G. Tsudik. Signature bouquets: Immutability for ag-
gregated/condensed signatures. Proceedings of the 9th European Symposium on Research in
Computer Security (ESORICS), pp. 160–176, Springer, 2004. DOI: 10.1007/978-3-540-
30108-0_10. 45
[103] S. Micali, M. Rabin, and J. Kilian. Zero-knowledge sets. Proceedings of the 44th Annual
IEEE Symposium on Foundations of Computer Science (FOCS), pp. 80–91, IEEE, 2003.
DOI: 10.1109/sfcs.2003.1238183. 14
[104] E. Mykletun and G. Tsudik. Aggregation queries in the database-as-a-service model. Pro-
ceedings of the 20th IFIP WG 11.3 Working Conference on Data and Applications Security, pp.
89–103, Springer, 2006. DOI: 10.1007/11805588_7. 45
[105] L. Nguyen. Accumulators from bilinear pairings and applications. CT-RSA, LNCS 3376,
pp. 75–292, Springer, 2005. DOI: 10.1007/978-3-540-30574-3_19. 45
[106] P.Q. Nguyen, I.E. Shparlinski, and J. Stern. Distribution of modular sums and the security
of server aided exponentiation. Proceedings of the Workshop on Cryptography and Computa-
tional Number eory, pp. 1–16, 1999. DOI: 10.1007/978-3-0348-8295-8_24. 34
[107] M. Naor and K. Nissim. Certiﬁcate revocation and certiﬁcate update. Proceedings of the 7th
Conference on USENIX Security Symposium, pp. 17–17, 1998. DOI: 10.1109/49.839932.
45

76
BIBLIOGRAPHY
[108] T. Pedersen. Non-interactive and information-theoretical Secure veriﬁable secret shar-
ing. Advances in Cryptology-CRYPTO, LNCS 576, pp. 129–140, Springer, 1991. DOI:
10.1007/3-540-46766-1_9. 38
[109] C. Papamanthou and R. Tamassia. Time and space eﬃcient algorithms for two-party au-
thenticated data structures. Information and Communications Security, LNCS 4861, pp.
1–15, Springer, 2007. DOI: 10.1007/978-3-540-77048-0_1. 45
[110] M. Peter and T. Grance. e NIST deﬁnition of cloud computing. National Institute of
Standards and Technology, 53(6), pp. 50, 2009. DOI: 10.6028/nist.sp.800-145. 2
[111] K. Ren, C. Wang, and Q. Wang. Security Challenges for the Public Cloud. IEEE Internet
Computing, 16(1), pp. 69–73, 2012. DOI: 10.1109/mic.2012.14. 3
[112] R. Sion. Secure data outsourcing. Proceedings of the 33rd International Conference on Very
Large Data Bases (VLDB), pp. 1431–1432, 2007. 45
[113] M. Scott. Unbalancing pairing-based key exchange protocols. Cryptology, ePrint
Archive/2013/688, 2013. 43
[114] A. Shamir and Y. Tauman. Improved online/oﬄine signature schemes. Advances in
Cryptology-CRYPTO, LNCS 2139, pp. 355–367, Springer, 2001. DOI: 10.1007/3-540-
44647-8_21. 38
[115] C.P. Schnorr. Eﬃcient signature generation for smart cards. Journal of Cryptology, 4(3), pp.
239–252, Springer, 1991. DOI: 10.1007/bf00196725. 30, 34
[116] M. Scott, N. Costigan, and W. Abdulwahab. Implementing cryptographic pairings on
smartcards. Cryptographic Hardware and Embedded Systems-CHES, LNCS 4249, pp. 134–
147, Springer, 2006. DOI: 10.1007/11894063_11. 40
[117] S. Subashini and V. Kavitha. A survey on security issues in service delivery models of cloud
computing. Journal of Network and Computer Applications, 34(1), pp. 1–11, 2011. DOI:
10.1016/j.jnca.2010.07.006.
[118] N.P. Smart and F. Vercauteren. Fully homomorphic encryption with relatively small key
and ciphertext sizes. Public Key Cryptography-PKC, vol. 6056, pp. 420–443, Springer, 2010.
DOI: 10.1007/978-3-642-13013-7_25. 8
[119] H. Shacham and B. Waters. Compact proofs of retrievability. Asiacrypt, LNCS 5350, pp.
90–107, Springer, 2008. DOI: 10.1007/978-3-540-89255-7_7. 66
[120] P. Tsang, S. Chow, and S. Smith. Batch pairing delegation. Advances in Information and
Computer Security, pp. 74–90, Springer, 2007. DOI: 10.1007/978-3-540-75651-4_6.

BIBLIOGRAPHY
77
[121] R. Tamassia and N. Triandopoulos. Certiﬁcation and authentication of data structures.
Alberto Mendelzon Workshop on Foundations of Data Management, 2010. 45
[122] H. Tian, F.Zhang, and K. Ren. Secure Bilinear Pairing Outsourcing Made More Eﬃcient
and Flexible. Proceedings of the 10th ACM Symposium on Information, Computer and Com-
munications Security (ASIACCS), pp. 417–426, 2015. DOI: 10.1145/2714576.2714615.
42
[123] C. Wang, K. Ren, and J. Wang. Secure and practical outsourcing of linear programming
in cloud computing. Proceedings of the 30th IEEE International Conference on Computer
Communications (INFOCOM), pp. 820–828, 2011. DOI: 10.1109/infcom.2011.5935305.
19
[124] M. van Dijk, C.Gentry, S. Halevi, and V.Vaikuntanathan. Fully homomorphic encryp-
tion over the integers. Advances in Cryptology-EUROCRYPT, pp. 24–43, 2010. DOI:
10.1007/978-3-642-13190-5_2. 8
[125] C. Wang, N. Cao, K. Ren, and W. Lou. Enabling Secure and Eﬃcient Ranked Keyword
Search over Outsourced Cloud Data. IEEE Transactions on Parallel Distribution Systems,
23(8), pp. 1467–1479, 2012. DOI: 10.1109/tpds.2011.282. 3
[126] C. Wang, K. Ren, J. Wang, and Q. Wang. Harnessing the Cloud for Securely Outsourc-
ing Large-scale Systems of Linear Equations. IEEE Transactions on Parallel Distribution
Systems, 24(6), pp. 1172–1181, 2013. DOI: 10.1109/tpds.2012.206. 19, 25
[127] H. Wang and L.V.S. Lakshmanan. Eﬃcient Secure Query Evaluation over Encrypted
xml Databases. Proceedings of the 32nd International Conference on Very Large Data Bases
(VLDB), pp. 127–C138, 2006. 45
[128] W. Wu, Y. Mu, W. Susilo, and X. Huang. Server-Aided Veriﬁcation Signatures: deﬁni-
tions and new constructions. Provable Security, LNCS 5324, pp. 141–155, Springer, 2008.
DOI: 10.1007/978-3-540-88733-1_10. 34
[129] J. Xu and E.C. Chang. Towards eﬃcient proofs of retrievability in cloud storage. AsiaCCS,
pp. 79–80, ACM, 2012. DOI: 10.1145/2414456.2414503. 66
[130] A. Yao. Protocols for secure computations. Proceedings of the IEEE Symposium on Founda-
tions of Computer Science, pp. 160–164, 1982. DOI: 10.1109/sfcs.1982.38. 8
[131] A. Yao. How to generate and exchange secrets. Proceedings of the IEEE Symposium on Foun-
dations of Computer Science, pp. 162–167, 1986. DOI: 10.1109/sfcs.1986.25. 8
[132] R. Yuster and U. Zwick. Fast Sparse Matrix Multiplication. Annual European Sympo-
sium on Algorithms, LNCS 3221, pp. 604–615, Springer, 2004. DOI: 10.1007/978-3-540-
30140-0_54. 27

78
BIBLIOGRAPHY
[133] A.A. Yavuz. Practical immutable signature bouquets (PISB) for authentication and in-
tegrity in outsourced databases, Proceedings of the 27th Annual on Data and Applications
Security and Privacy (DBSec), pp. 179–194, 2013. DOI: 10.1007/978-3-642-39256-6_12.
45
[134] F. Zhang, X. Ma, and S. Liu. Eﬃcient computation outsourcing for inverting a
class of homomorphic functions. Information Sciences, 286(1), pp. 19–28, 2014. DOI:
10.1016/j.ins.2014.07.017. 43

79
Author’s Biography
XIAOFENG CHEN
Professor Xiaofeng Chen received his B.S. and M.S. on Mathe-
matics from Northwest University, China, in 1998 and 2000, re-
spectively. He got his Ph.D. degree in Cryptography from Xidian
University in 2003. Currently, he works at Xidian University as a
professor. His research interests include applied cryptography and
cloud computing security. He has published over 100 research pa-
pers in refereed international conferences and journals. His work
has been cited more than 3,000 times at Google Scholar. He is
on the Editorial Board of Security and Communication Networks
(SCN), Telecommunication Systems (TELS), Computing and Infor-
matics (CAI), and International Journal of High Performance Com-
puting and Networking (IJHPCN), etc. He served as general chair of the 11th ACM Asia Con-
ference on Computer and Communications Security (AsiaCCS 2016) and as program co-chair
of the 5th International Conference on Provable Security (ProvSec 2011). He has also served
as program committee member in over 30 international conferences. Currently, he is a director
of Information Security Center, State Key Laboratory of Integrated Service Networks (ISN),
Xidian University.

