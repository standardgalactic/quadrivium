Introduction to 
Secure Outsourcing 
Computation
Xiaofeng Chen
Elisa Bertino & Ravi Sandhu, Series Editors
MORGAN&CLAYPOOL PUBLISHERS
SyntheSiS LectureS on  
information Security, Privacy, and truSt


Introduction to
Secure Outsourcing Computation

Synthesis Lectures on
Information Security, Privacy,
& Trust
Editors
Elisa Bertino, Purdue University
Ravi Sandhu, University of Texas, San Antonio
ÓÄÄe Synthesis Lectures Series on Information Security, Privacy, and Trust publishes 50- to 100-page
publications on topics pertaining to all aspects of the theory and practice of Information Security,
Privacy, and Trust. ÓÄÄe scope largely follows the purview of premier computer security research
journals such as ACM Transactions on Information and System Security, IEEE Transactions on
Dependable and Secure Computing and Journal of Cryptology, and premier research conferences,
such as ACM CCS, ACM SACMAT, ACM AsiaCCS, ACM CODASPY, IEEE Security and
Privacy, IEEE Computer Security Foundations, ACSAC, ESORICS, Crypto, EuroCrypt and
AsiaCrypt. In addition to the research topics typically covered in such journals and conferences, the
series also solicits lectures on legal, policy, social, business, and economic issues addressed to a
technical audience of scientists and engineers. Lectures on signiÔ¨Åcant industry developments by
leading practitioners are also solicited.
Introduction to Secure Outsourcing Computation
Xiaofeng Chen
2016
Database Anonymization: Privacy Models, Data Utility, and Microaggregation-based
Inter-model Connections
Josep Domingo-Ferrer, David S√°nchez, and Jordi Soria-Comas
2016
Automated Software Diversity
Per Larsen, Stefan Brunthaler, Lucas Davi, Ahmad-Reza Sadeghi, and Michael Franz
2015
Trust in Social Media
Jiliang Tang and Huan Liu
2015

iii
Physically Unclonable Functions (PUFs): Applications, Models, and Future Directions
Christian Wachsmann and Ahmad-Reza Sadeghi
2014
Usable Security: History, ÓÄÄemes, and Challenges
Simson GarÔ¨Ånkel and Heather Richter Lipford
2014
Reversible Digital Watermarking: ÓÄÄeory and Practices
Ruchira Naskar and Rajat Subhra Chakraborty
2014
Mobile Platform Security
N. Asokan, Lucas Davi, Alexandra Dmitrienko, Stephan Heuser, Kari Kostiainen, Elena Reshetova,
and Ahmad-Reza Sadeghi
2013
Security and Trust in Online Social Networks
Barbara Carminati, Elena Ferrari, and Marco Viviani
2013
RFID Security and Privacy
Yingjiu Li, Robert H. Deng, and Elisa Bertino
2013
Hardware Malware
Christian Krieg, Adrian Dabrowski, Heidelinde Hobel, Katharina Krombholz, and Edgar Weippl
2013
Private Information Retrieval
Xun Yi, Russell Paulet, and Elisa Bertino
2013
Privacy for Location-based Services
Gabriel Ghinita
2013
Enhancing Information Security and Privacy by Combining Biometrics with Cryptography
Sanjay G. Kanade, Dijana Petrovska-Delacr√©taz, and Bernadette Dorizzi
2012
Analysis Techniques for Information Security
Anupam Datta, Somesh Jha, Ninghui Li, David Melski, and ÓÄÄomas Reps
2010
Operating System Security
Trent Jaeger
2008

Copyright ¬© 2016 by Morgan & Claypool
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in
any form or by any means‚Äîelectronic, mechanical, photocopy, recording, or any other except for brief quotations
in printed reviews, without the prior permission of the publisher.
Introduction to Secure Outsourcing Computation
Xiaofeng Chen
www.morganclaypool.com
ISBN: 9781627057912
paperback
ISBN: 9781627057929
ebook
DOI 10.2200/S00701ED1V01Y201602SPT016
A Publication in the Morgan & Claypool Publishers series
SYNTHESIS LECTURES ON INFORMATION SECURITY, PRIVACY, & TRUST
Lecture #16
Series Editors: Elisa Bertino, Purdue University
Ravi Sandhu, University of Texas, San Antonio
Series ISSN
Print 1945-9742
Electronic 1945-9750

Introduction to
Secure Outsourcing Computation
Xiaofeng Chen
Xidian University, China
SYNTHESIS LECTURES ON INFORMATION SECURITY, PRIVACY, &
TRUST #16
C
M
&
cLaypool
Morgan
publishers
&

ABSTRACT
With the rapid development of cloud computing, the enterprises and individuals can outsource
their sensitive data into the cloud server where they can enjoy high quality data storage and com-
puting services in a ubiquitous manner. ÓÄÄis is known as the outsourcing computation paradigm.
Recently, the problem for securely outsourcing various expensive computations or storage has at-
tracted considerable attention in the academic community. In this book, we focus on the latest
technologies and applications of secure outsourcing computations. Specially, we introduce the
state-of-the-art research for secure outsourcing some speciÔ¨Åc functions such as scientiÔ¨Åc compu-
tations, cryptographic basic operations, and veriÔ¨Åable large database with update. ÓÄÄe construc-
tions for speciÔ¨Åc functions use various design tricks and thus result in very eÔ¨Écient protocols for
real-world applications.
ÓÄÄe topic of outsourcing computation is a hot research issue nowadays. ÓÄÄus, this book will
be beneÔ¨Åcial to academic researchers in the Ô¨Åeld of cloud computing and big data security.
KEYWORDS
cloud computing, veriÔ¨Åable computing, outsourcing paradigm, privacy preserving,
security model

vii
Dedicated to my precious wife and lovely daughter


ix
Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi
Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1
Outsourcing Paradigm in Cloud Computing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2
Secure Challenges in Outsourcing Computation . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3
Formal Security DeÔ¨Ånition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.1 Security Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3.2 Adversarial Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.4
General Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2
Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.1
Number-ÓÄÄeoretic Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2
Bilinear Pairings (Groups of Prime Order) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.3
Bilinear Pairings (Groups of Composite Order) . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.4
Sparse Matrix and Dense Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.5
Vector Commitments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.6
Algebraic Pseudorandom Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.7
Bloom Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3
Secure Outsourcing of ScientiÔ¨Åc Computations . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.1
Matrix Multiplication. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.1.1 A Basic Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.1.2 An Enhanced Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
3.2
Matrix Inversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.3
Large-scale Linear Equations Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3.1 New Secure Outsourcing Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.3.2 Security Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

x
4
Secure Outsourcing of Cryptographic Operations. . . . . . . . . . . . . . . . . . . . . . . . 29
4.1
Security DeÔ¨Ånitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2
Two Untrusted Program Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.3
Secure Outsourcing of Single Modular Exponentiation . . . . . . . . . . . . . . . . . . . 33
4.3.1 ÓÄÄe Proposed Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
4.3.2 Security Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.3.3 Comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.4
Secure Outsourcing of Simultaneous Modular Exponentiation . . . . . . . . . . . . . 38
4.4.1 Outsourcing Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.4.2 EÔ¨Éciency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.5
Secure Outsourcing of Bilinear Pairings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.5.1 Outsourcing Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.5.2 Improved Outsourcing Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
5
Secure Outsourcing of Large Database With Updates . . . . . . . . . . . . . . . . . . . . 45
5.1
Security DeÔ¨Ånitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.1.1 Security Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
5.1.2 Forward Automatic/Backward Substitution Update Attack . . . . . . . . . . 48
5.2
VDB Construction From Delegating Polynomial Functions . . . . . . . . . . . . . . . 49
5.2.1 Delegating of Polynomial Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
5.2.2 Benabbas-Gennaro-Vahlis VDB Construction . . . . . . . . . . . . . . . . . . . . 50
5.3
VDB Framework Based on Vector Commitment . . . . . . . . . . . . . . . . . . . . . . . . 51
5.3.1 ÓÄÄe General Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
5.3.2 Security Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
5.4
VDB Framework From Binding Vector Commitment . . . . . . . . . . . . . . . . . . . . 54
5.4.1 A Concrete VDB Scheme. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.4.2 Security Analysis of the VDB Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
5.5
Incremental VDB Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
5.5.1 Incremental Encryption Based on Bit Flipping . . . . . . . . . . . . . . . . . . . . 59
5.5.2 Inc-VDB Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5.5.3 A Concrete Inc-VDB Scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
6
Conclusion and Future Works . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
Author‚Äôs Biography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

xi
Preface
Cloud computing, the new term for the long dreamed vision of computing as a utility, oÔ¨Äers plenty
of beneÔ¨Åts for real-world applications, such as on-demand self-service, ubiquitous network access,
location independent resource pooling, rapid resource elasticity, usage-based pricing, outsourcing,
etc. ÓÄÄe most outstanding beneÔ¨Åt of cloud computing is the so-called outsourcing paradigm. ÓÄÄat
is, the users with resource-constraint devices can outsource heavy computation workloads into the
cloud server and enjoy the unlimited computing resources in a pay-per-use manner. As a result,
the enterprises and individuals can avoid large capital outlays in hardware/software deployment
and maintenance. Despite these beneÔ¨Åts, the outsourcing paradigm also inevitably suÔ¨Äers from
some new security challenges due to untrusted cloud servers. ÓÄÄus, how to securely outsource
prohibitively expensive computations is a hot issue in academic research community.
ÓÄÄe general construction for securely outsourcing arbitrary functions has been proposed
based on the primitives of garbled circuit and full homomorphic encryption. In this sense, the
problem of secure outsourcing computation has been theoretically solved. However, this gen-
eral solution is ineÔ¨Écient for most real applications and thus it is meaningful to seek eÔ¨Écient
outsourcing protocols for various speciÔ¨Åc functions. ÓÄÄis book addresses the advances of secure
outsourcing computations. More speciÔ¨Åcally, we focus on the state-of-the-art techniques of se-
cure outsourcing computations for diÔ¨Äerent speciÔ¨Åc functions based on diÔ¨Äerent design tricks.
In Chapter 1, we give a brief introduction for secure outsourcing computation, including its se-
curity challenges and formal security deÔ¨Ånitions. In Chapter 2, we present some preliminaries
which will be used in this book. Chapter 3 presents in detail some recent research for securely
outsourcing scientiÔ¨Åc computations. In Chapter 4, we present some recent techniques for securely
outsourcing cryptographic operations, such as modular exponentiations and bilinear parings. Re-
cent progress in veriÔ¨Åable outsourcing very large databases with eÔ¨Écient updates is presented in
Chapter 5. Finally, we conclude and discuss future research directions in Chapter 6.
Xiaofeng Chen
February 2016


xiii
Acknowledgments
Parts of the content of this lecture are results of research projects funded by the National Natural
Science Foundation of China (No. 61572382) and Program for New Century Excellent Talents
in University (No. NCET-13-0946).
I sincerely express my gratitude to Prof. Attila Yavuz at Oregon State University and
Prof. Fang-Yu Rao at Purdue University for their invaluable suggestions to improve this book.
I would also like to thank my three Ph.D. students, Jianfeng Wang, Hui Huang, and Zhiwei
Zhang, for their help when the book was being written.
Xiaofeng Chen
February 2016


1
C H A P T E R
1
Introduction
In this chapter, we present the security challenges and formal deÔ¨Ånitions of secure outsourcing
computation. We also introduce the general outsourcing framework of an arbitrary function in-
troduced by Gennaro, Gentry, and Parno [74].
Let us consider some scenarios in the real applications. For example, if you want to travel
the world by air, would you like the idea of buying a very expensive Boeing 737? I guess that the
overwhelming majority of people would not because the plane is too expensive. Of course, it is
another thing if you are Jackie Chan. Fortunately, most of us need not buy a Boeing 737, but
a Ô¨Çight ticket for traveling. In this example, we can outsource a very expensive task to a service
provider (e.g., an airline company) and just enjoy the service in a pay-per-use manner.
Nowadays, we always encounter some prohibitively expensive computation tasks. For ex-
ample, the sieving for factoring a 768-bit RSA modulus took almost two years on many hundreds
of machines. However, on a single core 2.2 GHz AMD Opteron processor with 2 GB RAM,
performing this algorithm would have taken about 1,500 years [89]. Trivially, in order to accom-
plish this kind of computation task, the resource-limited client has no choice but to outsource it
to servers with rich resources.
In some cases, even if we can aÔ¨Äord certain expensive tasks, they are not worthy it. For
example, would you like to buy a $10,000 wedding dress that you will wear only once in your life?
From the viewpoint of a rational economic person, the right thing is to rent it from a wedding
dress store. ÓÄÄat is, we could outsource this kind of expensive task to a service provider.
From the above examples, we could have an informal deÔ¨Ånition for outsourcing computa-
tion. ÓÄÄat is, the clients with resource-constraint devices delegate the heavy computation work-
loads into the powerful servers and pay for the services. Trivially, outsourcing computation can
oÔ¨Äer signiÔ¨Åcant beneÔ¨Åts to IT enterprises, especially in the period of Ô¨Ånancial crisis, since large
capital outlays on hardware/software deployment and maintenance are avoided. However, we ar-
gue that outsourcing computation is not a panacea to solve all problems in the environment of
limited resources. ÓÄÄe reason is that we should not only consider the computational resources
in the outsourcing paradigm, but also other types of resources, such as storage, communication
(bandwidth), and energy (electric power). Recently, Chen and Sion [59] explored the relationship
between the costs and security aspects in cloud computing, and pointed out that secure outsourc-
ing computation is only meaningful in some special scenarios. Indeed, there are always hidden
costs of bandwidth, which are costlier than computation itself, as well as energy consumption.
ÓÄÄerefore, we must carefully evaluate the tool of outsourcing computation and utilize it correctly.

2
1. INTRODUCTION
ÓÄÄroughout this book, we only consider the ‚Äúchallenge-response‚Äù type of outsourcing pro-
tocols. ÓÄÄat is, the client sends the computation task and then the server responds with the result.
ÓÄÄese kinds of protocols require only one round of interaction between the client and the server.
We argue that the protocols with multiple rounds of interaction are impractical in real applica-
tions.
1.1
OUTSOURCING PARADIGM IN CLOUD COMPUTING
Cloud computing, the new term for the long dreamed vision of computing as a utility, enables
ubiquitous, convenient, and on-demand network access to a centralized pool of conÔ¨Ågurable com-
puting resources [110]. Cloud computing oÔ¨Äers many beneÔ¨Åts, such as fast deployment, pay-per-
use, low-costs, rapid elasticity, ubiquitous network access, etc. One of the fundamental advan-
tages of cloud computing is the so-called outsourcing paradigm, where the clients with resource-
constraint devices can outsource the heavy computation workloads into untrusted cloud servers
and enjoy the unlimited computing resources in a pay-per-use manner. ÓÄÄat is, the computation
resources are now viewed as an infrastructure and platform to provide for the paying clients as a
service.
Generally, we can view any computation task as a function F W D ! M on a domain D such
that F.D/  M. Given any x 2 D, the goal is to compute F.x/. In the outsourcing paradigm, an
honest but resources-contained client C wants to delegate the computation task F.x/ to a cloud
server S that is not fully trusted by C. Firstly, C may outsource the encoding of F and x to C
(that is, the information about F and x should be kept secret to S in some scenarios). Secondly,
C returns the computation result based on the input (note that the output is not F.x/). ÓÄÄe client
Finally, C eÔ¨Éciently veriÔ¨Åes that the output provided by S is valid and then computes the Ô¨Ånal
result F.x/ by himself. ÓÄÄe outsourcing paradigm in cloud computing is illustrated in Fig. 1.1
(note that we have implicitly presented three security requirements of outsourcing computation
which will be given in more detail below).
Secure outsourcing computation is also termed as veriÔ¨Åable computation or delegation of
computation. Secure outsourcing computation is closely related to the primitive of secure mul-
tiparty computation (MPC), in which a set of players P1; P2; : : : ; Pn securely compute a given
function F on the inputs x1; x2; : : : ; xn [38]. DeÔ¨Åne F.x1; x2; : : : ; xn/ D .y1; y2; : : : ; yn/. ÓÄÄe
security in MPC means that each player Pi can only learn the information of yi. ÓÄÄis is very
similar to the input/output secrecy of outsourcing computation. ÓÄÄe main diÔ¨Äerence between the
two notations is that the computational resources of each player in MPC is assumed to be (al-
most) the same. While in the outsourcing computation paradigm, the client is assumed to have
insuÔ¨Écient resources to accomplish the computation of F . Besides, each party in MPC aims to
obtain a corresponding computation result. However, in the outsourcing computation, only the
client really cares about the computation result. Even if some server is also curious about the re-
sult, this is not the part of the protocol. Finally, in the outsourcing computation, the computation

1.2. SECURE CHALLENGES IN OUTSOURCING COMPUTATION
3
R
Checkability
R
Checkability
Client
Server
D
Secrecy
Data
R
Secrecy
Response
F: DƒÆM
Efficiency
Efficiency
Figure 1.1: Secure outsourcing paradigm in cloud computing.
is viewed as a service and the client must pay the server for the service. While in MPC, no party
will be paid by others.
1.2
SECURE CHALLENGES IN OUTSOURCING
COMPUTATION
With the availability of cloud services, the techniques for securely outsourcing the expensive com-
putaions to untrusted cloud servers are getting more and more attention in the scientiÔ¨Åc com-
munity [1, 7, 13, 45, 49, 50, 92]. However, on the other hand, the outsourcing paradigm also
inevitably introduces some new security concerns and challenges [111, 125]. Basically, there are
three security challenges as shown below.
Firstly, the cloud servers can only be assumed to be semi-trusted, while the computation
tasks often contain some sensitive information that should not be exposed to the cloud servers.
ÓÄÄus, the Ô¨Årst security challenge is the secrecy of the outsourcing computation: the cloud servers
should not learn anything about what it is actually computing (including the secret inputs and the
outputs). We argue that the encryption can only provide a partial solution to this problem since
it is very diÔ¨Écult to perform meaningful computations over the encrypted data. Note that fully
homomorphic encryption could be a potential solution to this problem, but the existing schemes
are not practical yet for real-world applications.
Secondly, the semi-trusted cloud servers may return some invalid results. For example, the
servers might contain a software bug that will fail on a constant number of invocations. Moreover,
the servers might decrease the amount of the computations due to Ô¨Ånancial incentives and then
return computationally indistinguishable (invalid) results. ÓÄÄerefore, the second security challenge

4
1. INTRODUCTION
is the checkability of the outsourcing computation: the client should have the ability to detect any
failures if the cloud servers misbehave.
Finally, the last challenge is the eÔ¨Éciency of the outsourcing computation. ÓÄÄat is, the ver-
iÔ¨Åcation algorithm is very eÔ¨Écient and should never require some other complicated computa-
tions. Otherwise, the outourcing will become meaningless. At least, the (computation and stor-
age) overload of the client must be much less than that for accomplishing the computation task
itself. Besides, the communication overload should also be considered as a factor of eÔ¨Éciency in
outsourcing protocols. ÓÄÄat is, the outsourcing protocols should not require multiple rounds of
interactions between the client and servers.
In general, we can achieve the secrecy by means of special encryption or disguise (also
known as blinding) techniques. ÓÄÄus, the remaining issue is how to eÔ¨Éciently verify the com-
putation results. Without loss of generality, there are three kinds of approaches to achieve the
veriÔ¨Åability of outsourcing computations. ÓÄÄe Ô¨Årst one is mostly suitable for the case that the ver-
iÔ¨Åcation itself is not involved in any expensive computations. For example, for the ‚Äúinversion of
one-way function‚Äù class of outsourcing computations [22, 45, 61, 62, 79], the client can directly
verify the result since the veriÔ¨Åcation is just equivalent to compute the one-way functions. ÓÄÄe
second approach is that the client uses multiple servers to achieve veriÔ¨Åability [45, 58, 82]. ÓÄÄat
is, the client sends the random test query to multiple servers and it accepts only if all the servers
output the same result. Trivially, the approach can only ensure the client to detect the error with
probability absolutely less than 1. ÓÄÄe last approach is based on one malicious server and might
leverage some proof systems [73, 87, 88, 96]. Obviously, an essential requirement is that the client
must verify the proofs eÔ¨Éciently.
1.3
FORMAL SECURITY DEFINITION
Gennaro, Gentry, and Parno [74] presented a formal deÔ¨Ånition for securely outsourcing compu-
tation, which consists of the following algorithms:
‚Ä¢ KeyGen .F; / ! .PK; SK/: ÓÄÄe randomized key generation algorithm generates a public
key PK that encodes the target function F with the security parameter , which is used by
the server to compute F. ÓÄÄen a corresponding secret key SK is generated and kept private
by the client.
‚Ä¢ ProbGen SK.x/ ! .x; x/: ÓÄÄe problem generation algorithm uses the secret key SK to
encode the function input x as a public value x which is given to the server to compute
with, and a secret value x is kept private by the client.
‚Ä¢ Compute PK.x/ ! y: Using the public key PK and the encoded input x, the server
computes an encoded version y of the output y D F.x/.

1.3. FORMAL SECURITY DEFINITION
5
‚Ä¢ Verify SK.x; y/ ! y [ ?: Using the client‚Äôs secret key SK and the secret ‚Äúdecoding‚Äù x,
the veriÔ¨Åcation algorithm converts the server‚Äôs encoded output y into the output of the
function, e.g., y D F.x/, or outputs ? if y is invalid.
Trivially, a secure outsourcing computation scheme should be correct. ÓÄÄat is, the compu-
tation result y by an honest server will always be successfully veriÔ¨Åed and the algorithm Verify
outputs y. In this sense, we say that C S correctly implements the function F.
1.3.1
SECURITY REQUIREMENTS
In the following, we introduce some security requirements for outsourcing computation [74, 82].
ÓÄÄe Ô¨Årst requirement is the privacy for the input/output of the computation task. Infor-
mally, it means that the server cannot learn anything from its interaction in the protocol in the
sense of an indistinguishability argument.
DeÔ¨Ånition 1.1
(privacy) Given a security parameter k, a pair of algorithms .C; S/ achieves the
privacy for the input/output of F if for any probabilistic polynomial time (PPT) adversary A,
AdvC S
A .F; k/  negl.k/;
where AdvC S
A .F; k/ D j Pr ≈íb D b0¬ç   1
2j is deÔ¨Åned as the advantage of A in the experiment as
follows:
.PK; SK/
R
 KeyGen.F; k/I
.x0; x1/  APubProbGenSK./.PK/
.0; 0/  ProbGenSK.x0/I
.1; 1/  ProbGenSK.x1/I
b
R
 f0; 1gI
b0  APubProbGenSK./.PK; x0; x1; b/:
During the above experiment, the adversary A is allowed to request the encoding of any in-
put he desires. ÓÄÄe oracle PubProbGenSK.x/ calls ProbGenSK.x/ to obtain .x; x/ and returns
only the public part x. Trivially, the output of PubProbGenSK.x/ is probabilistic.
ÓÄÄe second requirement is the eÔ¨Éciency of outsourcing algorithms. ÓÄÄat is, the local com-
putation done by client C should be substantially less than that to accomplish the original com-
putation by itself (i.e., without outsourcing). Note that the local computation consists of the
computational overload of algorithms ProbGen and Verify. However, it does not include the

6
1. INTRODUCTION
computation of KeyGen which may be prohibitively heavy since it can be amortized over plenty
of diÔ¨Äerent input computations.
DeÔ¨Ånition 1.2
(Àõ-eÔ¨Éciency) A pair of algorithms .C; S/ is said to be an Àõ-eÔ¨Écient implemen-
tation of F if (1) C S correctly implements F and (2) for 8 x 2 D, the running time of C is no
more than an Àõ-multiplicative factor of the running time of F, where 0 < Àõ < 1.
ÓÄÄe last requirement is the checkability (also known as veriÔ¨Åability) of outsourcing algo-
rithms. ÓÄÄat is, the output by the server must be checked for correctness. More precisely, the
invalid output given by any malicious server cannot pass the veriÔ¨Åcation and client C will detect
the error with a non-negligible probability.
DeÔ¨Ånition 1.3
(checkability) Given a security parameter k, a pair of algorithms .C; S/ achieve
the checkability for F if for any probabilistic polynomial time (PPT) adversary A,
AdvC S
A .F; k/  negl.k/;
where AdvC S
A .F; k/ D Pr≈íExp.F; k/ D 1¬ç is deÔ¨Åned as the advantage of A in the experiment Exp
as follows:
.PK; SK/
R
 KeyGen.F; k/I
For i D 1; 2; : : : ; l D poly.k/I
xi  A.PK; x1; 1; : : : ;xi 1; i 1/
.i; i/  ProbGenSK.xi/I
.i; Oy/  A.PK; x1; 1; : : : ; xl; l/I
Oy  VerifySK.i; Oy/
If Oy ¬§? ^ Oy ¬§ F.xi/; output 010I else 000I
Also, we can deÔ¨Åne the magnitude of checkability in a secure outsourcing scheme. ÓÄÄat is,
a pair of algorithms .C; S/ is said to be a Àá-checkable implementation of F if (1) C S correctly
implements F and (2) for 8 x 2 D, if a malicious S0 deviates from its advertised functionality
during the execution of C S0.x/, C will detect the error with probability no less than 0 < Àá  1.
1.3.2
ADVERSARIAL MODEL
In this section, we introduce four kinds of adversarial models for secure outsourcing computation.
Note that the adversary is the untrusted server(s) in all models.
‚Ä¢ Honest-but-curious Model
ÓÄÄe ‚Äúhonest-but-curious model‚Äù (also-called the semi-honest model) was Ô¨Årstly introduced
by Goldreich et al. [78]. In this model, both the client C and the server S are guaranteed

1.3. FORMAL SECURITY DEFINITION
7
to properly execute a prescribed protocol, but, at the end of it, S can use its own view of
the execution to infer about C‚Äôs input. ÓÄÄerefore, S will honestly send the computation
results to C. But he will try his best to retrieve some sensitive information such as the secret
input/output of C. Note that the computation results (i.e., the output of S) are diÔ¨Äerent
from the output of C (i.e., the real computation aim of C).
‚Ä¢ Lazy-but-honest Model
ÓÄÄe ‚ÄúLazy-but-honest model‚Äù was Ô¨Årst introduced by Golle and Mironov [79], which is
suitable for the inversion of the one-way function class of outsourcing computations. Sim-
ilarly, in this model, S will also honestly send the computation results to C if and only if
he has accomplished the computation. However, S is viewed as a rational economic person
and will try to minimize the amount of computation overload in order to save the compu-
tational resources. In the worst case, S will send a computational indistinguishable or even
random result to C. As a result, C should be able to verify the result eÔ¨Éciently.
‚Ä¢ Two Untrusted Program Model
Hohenberger and Lysyanskaya [82] Ô¨Årst introduced the ‚Äútwo untrusted program model‚Äù
for outsourcing cryptographic computations. ÓÄÄe two untrusted program model, in brief, is
the model that there are two non-colluding servers S1 and S2, and we assume at most one
of them is adversarial while we cannot know which one. Besides, the misbehavior of the
dishonest server can be detected with an overwhelming probability. ÓÄÄis model is suitable
for designing the secure outsourcing scheme for the expensive operations in a cryptographic
algorithm such as modular exponentiation or bilinear pair.
‚Ä¢ Refereed Delegation of Computation Model
ÓÄÄe ‚Äúrefereed delegation of computation model‚Äù was Ô¨Årst introduced by Canetti et al. [58],
where the client C delegates the computation to n  2 servers S1; S2; : : : Sn under the as-
sumption that at least one of the servers is honest. In case the servers make contradictory
claims about the computation results, C can engage in a protocol with each of the servers,
at the end of which C can eÔ¨Éciently determine the true claim under the assumption that at
least one of the servers is honest (while the client does not know which is honest). Obviously,
the two untrusted program model can be viewed as a special case of refereed delegation of
computation model when the number of servers n D 2.
‚Ä¢ Amortized Model
Gennaro, Gentry, and Parno [74] Ô¨Årstly introduce the ‚Äúamortized model‚Äù to construct ef-
Ô¨Åcient veriÔ¨Åable computation protocols. By introducing an expensive pre-processing stage,
the client C can outsource some computation-intensive tasks to the server S in an eÔ¨Écient
manner. Although C needs to perform a one-time complicated computation in the pre-
processing stage, the computation overload is amortized over all future executions. Note

8
1. INTRODUCTION
that the pre-processing is performed only once, C could outsource it to a trusted server or
perform it in an oÔ¨Ñine manner.
1.4
GENERAL CONSTRUCTION
In 2010, Gennaro, Gentry, and Parno [74] Ô¨Årst formalized the deÔ¨Ånition for secure outsourcing
computation (they called it the notion of veriÔ¨Åable computation) and presented a milstone theo-
retic framework for secure outsourcing arbitrary computation functions as shown in Fig. 1.2. ÓÄÄe
framework mainly uses two building blocks of garbled circuit [130, 131] and fully homomorphic
encryption [69, 70, 118, 124].
SK
FHE
 Encryption
FHE 
Compution
SK
FHE 
Decryption
Garble 
Circuit
Figure 1.2: General construction.
In this section, we give a brief introduction to Gennaro et al.‚Äôs general outsourcing frame-
work. ÓÄÄe main idea is as follows: Our task is to compute y D F.x/. Firstly, the client converts
the target function F as a garbled circuit C using Yao‚Äôs protocol. ÓÄÄe client keeps all the wire
values fwig as his private key SK and the ciphertexts fig on each gate g as his public key PK.
Now, there is a one-to-one correspondence between some wire values wi and the binary expres-
sion of x. Note that wi is the secret key and could not exposed to the servers. ÓÄÄus, the client
should encrypt wi and this is accomplished by using a fully homomorphic encryption scheme
FHE with the public/secret key pair .PKE; SKE/. As we know, there are two encryption opera-
tions in FHE. ÓÄÄe client performs the Ô¨Årst operation and encrypts wi with the public key PKE
and sends the ciphertext x to the server. On the other hand, the client outsources the second
(expensive) operation Evaluate to the server and let the ciphertext be y. Due to the property
of fully homomorphic encryption, we know that y should be the ciphertext of !0
i, where !0
i is
the wire values representing y D C.x/ D F.x/ in binary. Trivially, the client can decrypt y with

1.4. GENERAL CONSTRUCTION
9
SKE and obtain !0
i. Finally, the client uses the private key SK to map !0
i to the computation
result y.
ÓÄÄe general construction consists of the following algorithms:
‚Ä¢ KeyGen.F; / ! .PK; SK/: Represent F
as a garbled circuit C using Yao‚Äôs cir-
cuit construction. Choose two random values !0
i ; !1
i  f0; 1g for each wire !i. For
each gate g, compute the four ciphertexts .g
00; g
01; g
10; g
11/. ÓÄÄe public key PK  
[g.g
00; g
01; g
10; g
11/, and the secret key SK  [i.!0
i ; !1
i /.
‚Ä¢ ProbGenSK.x/ ! x: Run the key generation algorithm of a fully homomorphic en-
cryption scheme to create a new key pair .PKE; SKE/  KeyGenE./. Let !x  SK
be the wire values representing the binary expression of x. Set the public value x  
EncE.PKE; !x/ and the private value x  SKE.
‚Ä¢ ComputePK.x/ ! y: Construct a circuit  that on input !; !0;  outputs D!.D!0.//,
where D is the decryption algorithm corresponding to the encryption E used in Yao‚Äôs
garbling (therefore  computes the appropriate decryption in Yao‚Äôs construction). Cal-
culate EvaluateE.; EncE.PKE; !x/; EncE.PKE; i// repeatedly, to decrypt your way
through the ciphertexts, just as in the evaluation of Yao‚Äôs garbled circuit. ÓÄÄe result is
y  EncE.PKE; !0
i/, where !0
i is the wire values representing y D F.x/ in binary.
‚Ä¢ VerifySK.y/ ! y [ ?: Decrypt y with SKE to obtain !0
i. Use SK to map the wire values
to an output y. If the decryption or mapping fails, then output ?.
ÓÄÄough the above solution allows a client to outsource the computation of an arbitrary
function, it is ineÔ¨Écient for practical applications due to the complicated fully homomorphic en-
cryption techniques. Besides, another disadvantage of the schemes based on fully homomorphic
encryption is that the client must repeat the expensive pre-processing stage if the malicious server
tries to cheat and learns a bit of information, i.e., the client has accepted or rejected the compu-
tation result. In this sense, even the problem of outsourcing computation has been theoretically
solved, it is still meaningful to seek secure and eÔ¨Écient outsourcing computation protocols for
speciÔ¨Åc functions.
In the remainder of this book, we mainly focus on the concrete constructions of secure
outsourcing computation for speciÔ¨Åc functions using various design tricks.


11
C H A P T E R
2
Preliminaries
In this chapter, we introduce some preliminaries for this book. We assume that the readers have
some basic knowledge of number theory, basic algebra, and cryptography and thus will not present
them here.
2.1
NUMBER-THEORETIC PROBLEMS
Let G be a cyclic multiplicative group of prime order p, and g is a generator of G. We introduce
some intractable problems in G, and intractability means that by far there is no polynomial time
algorithm to solve these problems with non-negligible probability.
‚Ä¢ Discrete Logarithm Problem (DLP): Given two elements .g; h/ as inputs, to Ô¨Ånd an integer
x 2 Z
p such that h D gx whenever such an integer exists. We say that the DL assumption
holds in G if for every probabilistic polynomial time algorithm A, there exists a negligible
function negl./ such that Pr≈íA.1k; g; h/ D x¬ç  negl.k/ for all security parameter k.
‚Ä¢ Computational DiÔ¨Ée-Hellman Problem (CDHP): Given a triple .g; gx; gy/ for any
x; y 2R Zp as inputs, output gxy.
‚Ä¢ Square Computational DiÔ¨Ée-Hellman Problem (Squ-CDHP): Given .g; gx/ for x 2R Zp
as inputs, output gx2. It has been proved that the Squ-CDH assumption is equivalent to
the classical CDH assumption [10].
‚Ä¢ Decisional DiÔ¨Ée-Hellman Problem (DDHP): Given a triple .g; gx; gy; gz/ for any
x; y; z 2R Zp as inputs, to decide whether z  xy mod p:
‚Ä¢ Strong DiÔ¨Ée-Hellman Problem (SDHP): Given a tuple .g; gx; gx2;    ; gxl/ for any x 2R
Zp as inputs, output a pair .c; g
1
xCc /.
‚Ä¢ Strong
Decisional
DiÔ¨Ée-Hellman
Problem
(SDDHP):
Given
two
tuples
.g; gx; gx2;    ; gxl/ and .g; gx1; gx2;    ; gxl/ for any x; x1;    ; xl 2R Zp as inputs, to
decide which is the random tuple.
2.2
BILINEAR PAIRINGS (GROUPS OF PRIME ORDER)
Let G1, G2, and GT be three cyclic multiplicative groups of prime order p. Let g1 and g2 be a
generator of G1 and G2, respectively. DeÔ¨Åne an isomorphism  W G2 ! G1 with  .g2/ D g1 and

12
2. PRELIMINARIES
its inverse   1 W G1 ! G2. A bilinear pairing is a map e W G1  G2 ! GT with the following
properties:
1. Bilinear: e.ua; vb/ D e.u; v/ab for all u 2 G1, v 2 G2, and a; b 2 Z
p.
2. Non-degenerate: e.g1; g2/ ¬§ 1:
3. Computable: ÓÄÄere is an eÔ¨Écient algorithm to compute e.u; v/ for all u 2 G1, v 2 G2:
ÓÄÄe examples of such groups can be found in certain algebraic varieties or curves over Ô¨Ånite
Ô¨Åelds, and the bilinear pairings can be derived from the Weil or Tate pairings and some variants
thereof. For more details, see [11, 27, 36, 81]. It has been proved that the CDHP and DDHP
are not equivalent in the group G1 and thus called a gap DiÔ¨Ée-Hellman (GDH) group. More
precisely, we call G1 a GDH group if the DDHP can be solved in polynomial time but there is
no polynomial time algorithm to solve the CDHP with non-negligible probability.
Using the terminology of [81], we can separate the bilinear pairings into the following three
types.
‚Ä¢ Type 1: G1 D G2 or, both  and   1 are eÔ¨Éciently computable.
‚Ä¢ Type 2: G1 ¬§ G2 and, either  or   1 is eÔ¨Éciently computable but not both.
‚Ä¢ Type 3: G1 ¬§ G2 and, neither  nor   1 is eÔ¨Éciently computable.
Note that G1 and G2 are cyclic groups of the same order, thus  ;   1 certainly exist. Also,
as argued in [81], ‚Äúnot eÔ¨Éciently computable‚Äù does not necessarily mean ‚Äúinfeasible to compute.‚Äù
2.3
BILINEAR PAIRINGS (GROUPS OF COMPOSITE
ORDER)
Generally, we often use bilinear pairings on groups of prime order. Recently, pairings on groups
of composite order have been used to design new cryptographic schemes such as non-interactive
zero-knowledge proofs [75, 76], attribute-based encryption [32, 91], and database with eÔ¨Écient
update [18].
ÓÄÄe primitive of bilinear pairings over composite order groups was Ô¨Årst introduced by
Boneh, Goh, and Nissim [17]. ÓÄÄe deÔ¨Ånition for bilinear groups with composite order is al-
most the same as that with prime order. ÓÄÄe only diÔ¨Äerence is that the order of the groups are a
composite n D pq where the factorization of n is kept secret. As remarked in [81], it seems that
the academic community generally uses the Type 1 setting for bilinear groups of composite order.
Let G1 and GT be two cyclic multiplicative groups of composite order n D pq. A bilinear
pairing is a map e W G1  G1 ! GT that satisÔ¨Åes the properties of bilinear, non-degenerate, and
computable. Bilinear groups of composite order are pairs of groups .G1, GT / that are equipped
with the map e. In the following, we introduce the subgroup decision problem in .G1, GT /.

2.4. SPARSE MATRIX AND DENSE MATRIX
13
‚Ä¢ Subgroup Decision Problem: Let n D pq where p; q are two large primes. Let .G1; GT ; e/
be bilinear groups of order n. Given an element x 2 G1, output ‚Äò1‚Äô if the order of x is p and
output ‚Äò0‚Äô otherwise; that is, without knowing the factorization of n, decide if an element
x 2 G1 is in a subgroup of G1. We say that the subgroup decision assumption holds if for
every PPT distinguisher A there exists a negligible function neg(.) such that for all ,
jPr≈íA.n; G1; GT ; e; x/ D 1¬ç   Pr≈íA.n; G1; GT ; e; xq/ D 1¬çj  neg./
Informally, the assumption indicates that the uniform distribution on G1 is indistinguishable
from the uniform distribution on a subgroup of G1.
ÓÄÄere is an interesting property for pairings over composite order groups: Let Gp and Gq be
subgroups of G1 of orders p and q, respectively. For any u 2 Gp and v 2 Gq, we have e.u; v/ D
1GT . Note that this property holds for every pairing over composite order groups. ÓÄÄe reason is
as follows:
Let g be a generator of G1. ÓÄÄen gp generates Gq and gq generates Gp. So there exist
some a; b that satisfy u D .gq/a and v D .gp/b. ÓÄÄen we can deduce that
e.u; v/ D e.gaq; gbp/ D e.ga; gb/n D 1GT :
For the practical application, note that the size of n should be at least 1,024 bits. Besides, in
order to achieve the equivalent level of security, the size of a prime-order bilinear groups is only
about 160 bits. ÓÄÄus, the operations in composite-order bilinear groups are much slower than
that in prime-order bilinear groups. ÓÄÄis illustrates why the prime-order bilinear groups are the
optimal choice for pairing-based schemes unless they fail to work.
2.4
SPARSE MATRIX AND DENSE MATRIX
ÓÄÄe word ‚Äúmatrix‚Äù means something that contains the essence of a thing [85]. In linear algebra, a
matrix is a rectangular array of numbers, symbols, or expressions, arranged in rows and columns.
ÓÄÄe individual items in a matrix are called its elements or entries.
A major application of matrices is to solve the solution of systems of linear equations. ÓÄÄe
reason is that matrices can be used to compactly represent systems of linear equations. For ex-
ample, let A D .aij / be an m  n matrix, x00 be a column vector (i.e., n  1 matrix) of n variables
x1; x2;    ; xn, and b00 be an m  1 column vector, then the matrix equation Ax00 D b00 is equiv-
alent to the system of linear equations:
8
ÀÜÀÜÀÜ<
ÀÜÀÜÀÜ:
a1;1x1 C a1;2x2 C    C a1;nxn D b1
a2;1x1 C a2;2x2 C    C a2;nxn D b2
:::
:::
am;1x1 C am;2x2 C    C am;nxn D bm
(2.1)

14
2. PRELIMINARIES
In many real-world applications, some additional information about the matrices is known
beforehand. For example, the predominant entries of a matrix are zero. ÓÄÄis kind of matrix is
called sparse matrix. By contrast, if most of the entries of a matrix are non-zero, then the matrix
is dense. ÓÄÄe fraction of zero entries over the total number of elements in a matrix is called the
sparsity. Large-scale sparse matrices play an important role in solving partial diÔ¨Äerential equations
in scientiÔ¨Åc or engineering applications. Besides, when A is sparse, it is easier and faster to solve
the systems of linear equations Ax00 D b00.
We list some facts for sparse matrices without proof. Interested readers could give a proof.
In the following, we assume that both M and N are two large n  n square matrices.
‚Ä¢ If both M and N are dense, it is well known that the computational complexity of MN is
O.n3/. While if M is sparse and N is dense, the computational complexity is only O.n2/.
‚Ä¢ Even if both M and N are sparse, we could not know the sparsity of MN. Actually, MN
may be sparse or extremely dense!
‚Ä¢ If M is a sparse matrix, then M may be singular or non-singular (i.e., invertible).
‚Ä¢ If M is a sparse matrix, then the inverse matrix M  1 (if it exists) may be extremely dense.
ÓÄÄat is, the computational complexity of M  1 is O.n3/ in some cases. ÓÄÄus, it is not wise
to solve linear equations with M  1. Actually, we should never solve linear equations with
the inverse matrix.
‚Ä¢ Both iterative and direct methods can be used to solve systems of linear equations whether
the matrix is sparse or not.
2.5
VECTOR COMMITMENTS
Commitment is a fundamental primitive in cryptography and plays an important role in almost
all security protocols, such as voting, identiÔ¨Åcation zero-knowledge proof, etc. Intuitively, a com-
mitment scheme can be viewed as the digital equivalent of a sealed envelope. In the commitment
stage, the sender places a message in the sealed envelope and gives it to the receiver. In the opening
stage, the sender reveals the message to the receiver. On the one hand, no one except the sender
could open the envelope to learn the message from the commitment (this is called hiding). On
the other hand, the sender could not change the message anymore (this is called binding).
Recently, Catalano and Fiore [41] proposed a new primitive called Vector Commitment,
which is closely related to zero-knowledge sets [40, 48, 95, 103]. Informally speaking, a vector
commitment scheme allows one to commit to an ordered sequence of values .m1; : : : ; mq/ in
such a way that the committer can later open the commitment at speciÔ¨Åc positions. Furthermore,
anyone should not be able to open a commitment to two diÔ¨Äerent values at the same position
(this is called position binding). Furthermore, the vector can be required to be hiding. ÓÄÄat is,
any adversary cannot distinguish whether a commitment was created to a sequence .m1; : : : ; mq/

2.6. ALGEBRAIC PSEUDORANDOM FUNCTIONS
15
or to .m0
1; : : : ; m0
q/, even after seeing some openings at some positions. Besides the properties of
position binding and hiding, vector commitment needs to be concise, i.e., the size of the com-
mitment string and the opening are both independent of q. In the following, we present a formal
deÔ¨Ånition of vector commitment [41].
DeÔ¨Ånition 2.1
A vector commitment scheme VCD(VC.KeyGen, VC.Com, VC.Open, VC.Veri,
VC.Update, VC.ProofUpdate) consists of the following algorithms:
‚Ä¢ VC.KeyGen.1k; q/: On input the security parameter k and the size q D poly.k/ of the com-
mitted vector, the key generation algorithm outputs some public parameters PP which also
implicitly deÔ¨Åne the message space M.
‚Ä¢ VC.ComPP.m1;    ; mq/: On input a sequence of q messages .m1;    ; mq/ 2 Mq, and the
public parameters PP, the committing algorithm outputs a commitment string C and an
auxiliary information aux.
‚Ä¢ VC.OpenPP.m; i; aux/: ÓÄÄis algorithm is run by the committer to produce a proof i that m
is the i-th committed message.
‚Ä¢ VC.VeriPP.C; m; i; i/: ÓÄÄe veriÔ¨Åcation algorithm outputs 1 only if i is a valid proof that C
is a commitment to a sequence .m1;    ; mq/ such that m D mi.
‚Ä¢ VC.UpdatePP.C; m; i; m0/: ÓÄÄis algorithm is run by the original committer who wants to up-
date C by changing the i-th message to m0. It takes as input the old message m at the
position i, the new message m0, outputs a new commitment C 0 together with an update
information U .
‚Ä¢ VC.ProofUpdatePP.C; U; m0; j; j /: ÓÄÄe algorithm can be run by any user who holds a proof
j for some message m at the position j w.r.t. C. It allows the user to compute an updated
proof 0
j (and the updated commitment C 0) such that 0
j is valid w.r.t C 0 which contains
m0 as the new message at the position i. Basically, the value U D .m; m0; i/ contains the
update information which is needed to compute such values.
2.6
ALGEBRAIC PSEUDORANDOM FUNCTIONS
An
algebraic
pseudorandom
function
(PRF)
consists
of
three
algorithms
PRF
=
fKeyGen; F; CFEvalg. Given a security parameter 1n and a parameter m 2 N, the algorithm
KeyGen determines the domain size of the PRF and outputs a pair .K; param/ 2 Kn, where
Kn is the key space for security parameter n, K is the secret key of the PRF, and param encodes
the public parameters. ÓÄÄe algorithm F takes as input a key K, public parameters param, an
input x 2 f0; 1gm, and outputs a value y 2 Y , where Y is some set determined by param.
An algebraic pseudorandom function should satisfy the following properties [18]:

16
2. PRELIMINARIES
‚Ä¢ Algebraic: PRF is algebraic if the range Y of FK./ for every n 2 N and .K; param/ 2 Kn
forms an abelian group. Given param, the group operation on Y should be eÔ¨Éciently
computable.
‚Ä¢ Pseudorandom: PRF is pseudorandom if for every PPT adversary A, and every polyno-
mial m./, there exists a negligible function neg: N ! N, such that for all n 2 N:
jPr≈íAFK./.1n; param/ D 1¬ç   Pr≈íAR./.1n; param/ D 1¬çj  neg.n/
where .K; param/  R KeyGen.1n; m.n//, and R W f0; 1gm ! Y is a random function.
‚Ä¢ Closed form eÔ¨Éciency: Let N be the order of the range sets of F for security parameter n.
Let z D .z0;    ; zl/ 2 .f0; 1gm/lC1; k 2 N, and an eÔ¨Éciently computable h W Zk
N ! Zl
N
with h.x/ D< h0.x/;    ; hl.x/ >. We say that .h; z/ is closed form eÔ¨Écient for PRF if
there exists an algorithm CFEvalh;z such that for every x 2 Zk
N,
CFEvalh;z.x; K/ D
lQ
iD0
≈íFK.zi/¬çhi.x/
and the running time of CFEval is polynomial in n; m; k but sublinear in l. When z D
.0;    ; l/, we will omit it from the subscript, and write CFEvalh.x; K/ instead.
ÓÄÄe last condition provides a much more eÔ¨Écient way to compute a ‚Äúweighted prod-
uct‚Äù of l PRF values. ÓÄÄat is, given .param; h; x; FK.z/, one can always compute the value
lQ
iD1
≈íFK.zi/¬çhi.x/ in time linear in l (this follows from the algebraic property of the PRF).
In the following, we introduce a concrete construction of small domain algebraic PRFs
from strong decisional DiÔ¨Ée-Hellman (SDDH) assumption. Let G be a computational group
scheme. We deÔ¨Åne PRF as an algebraic PRF with polynomial sized domains.
‚Ä¢ KeyGen(1n; m): Generate a group description .p; g; G/  R G.1n/, where n is a security
parameter. Choose k0; k1 2R Zp. Output param D .m; p; g; G/; K D .k0; k1/.
‚Ä¢ FK.x/: Interpret x as an integer in f0;    ; D D 2mg where D is polynomial in n. Compute
and output gk0kx
1 .
‚Ä¢ CFEvalh.x; K/: DeÔ¨Åne CFEvalh.x; K/=g
k0.1 kdC1
1
xdC1/
1 k1x
.
We now show an eÔ¨Écient closed form for PRF for polynomials of the form:
p.x/ D FK.0/ C FK.1/x C    C FK.d/xd, where d  D.
Let h W Zp ! ZdC1
p
be deÔ¨Åned as h.x/
def
D .1; x;    ; xd/. Let .z0;    ; zd/ D .0;    ; d/. ÓÄÄen we
have

2.7. BLOOM FILTER
17
CFEvalh.x; K/ D
dQ
iD0
≈íFK.zi/¬çhi.x/ D
dQ
iD0
≈ígk0ki
1¬çxi D gk0
Pd
iD0 ki
1xi D g
k0.1 kdC1
1
xdC1/
1 k1x
.
ÓÄÄis proves the correctness of CFEvalh.x/.
2.7
BLOOM FILTER
ÓÄÄe Bloom Ô¨Ålter, proposed by Bloom [24] in 1970, is a space-eÔ¨Écient data structure for ap-
proximately representing a large set S subject to insertion operations and membership queries.
A Bloom Ô¨Ålter (BF ) consists of a hash table B containing m single-bit cells which are initially
set to 0, together with k random hash functions hi W f0; 1g? ! ≈í1; m¬ç for 1  i  k. Note that
the hash function is not the traditional one such as SHA-1. In the initial phase, all positions of
the array are set to 0. To add an element to the set, feed it to each of the k hash functions and
obtain k array positions. ÓÄÄen set the bit value for each position to 1, i.e., B≈íhi.x/¬ç:bit D 1 for
i D 1; 2;    ; k.
In order to test whether an element x in S or not, we must ensure that there is no i 2
f1; 2    ; kg such that B≈íhi.x/¬ç:bit D 0. ÓÄÄat is, if there exists some i 2 f1; 2    ; kg such that
B≈íhi.x/¬ç:bit D 0, then x is deÔ¨Ånitely not in S. Otherwise, we can deduce that x is a member of
S with a probability of false positive.
An instance of Bloom Ô¨Ålter is shown in Fig. 2.1. It is easy to see that the element z does
not belong to the set S. In the case of element w, though all the corresponding positions are 1,
it does not belong to S. It is called as false positive. In [4], the authors analyze the relationship
among the size of the Bloom Ô¨Ålter m, the number of hash functions k, the number of elements
n, and the probability of false positive Pf . SpeciÔ¨Åcally, for given m and n, Pf D .1   e kn=m/k.
Also, when k D ln2  .m=n/, Pf reaches the minimum value .0:6185/m=n.
1
1
1
0
0
0
0
0
1
0
1
1
{x  y}
Ôºå
z
w
Figure 2.1: A toy Bloom Ô¨Ålter construction.
Some variants of Bloom Ô¨Ålter consist of the counting Bloom Ô¨Ålter (CBF), invertible Bloom
Ô¨Ålter (IBF) [28, 65]. For example, CBF is a variant of Bloom Ô¨Ålter by replacing each bit cell of B
with a counter cell called count (initialized to 0 for each cell). An insertion/deletion of element x
amounts to incrementing/decrementing each B≈íhi.x/¬ç:count by 1 for i D 1; 2;    ; k. Similarly,

18
2. PRELIMINARIES
testing for the membership of x in S amounts to testing that there is no i 2 f1; 2    ; kg such
that B≈íhi.x/¬ç:count D 0. However, it is still very diÔ¨Écult to Ô¨Ånd (not just test) the members of a
set represented by a CBF.
We believe that these primitives play an important role in designing veriÔ¨Åable database
schemes with eÔ¨Écient updates and will present in our future work [54].

19
C H A P T E R
3
Secure Outsourcing of
ScientiÔ¨Åc Computations
In this chapter we focus on secure outsourcing some scientiÔ¨Åc computations. ÓÄÄe theoretical com-
puter science community has devoted considerable attention to the problem of how to securely
outsource diÔ¨Äerent kinds of expensive computations. Abadi et al. [2] Ô¨Årst proved the impossibility
of secure outsourcing an exponential computation while locally doing only polynomial time work.
ÓÄÄerefore, it is meaningful only to consider outsourcing expensive polynomial time computations.
Atallah et al. [7] presented a framework for secure outsourcing of scientiÔ¨Åc computations
such as matrix multiplications and quadrature. However, the solution used the disguise technique
and thus allowed leakage of private information. Atallah and Li [3] investigated the problem
of computing the edit distance between two sequences and presented an eÔ¨Écient protocol to
securely outsource sequence comparisons to two servers. Blanton et al. proposed a more eÔ¨Écient
scheme for secure outsourcing sequence comparisons [23]. Benjamin and Atallah [8] addressed
the problem of secure outsourcing for widely applicable linear algebra computations. However, the
proposed protocols required the expensive operations of homomorphic encryptions. Atallah and
Frikken [1] further studied this problem and gave improved protocols based on Shamir‚Äôs secret
sharing. Some other works [93, 100] also used Shamir‚Äôs secret sharing to perform homomorphic
computations over the cloud. Trivially, the protocols based on secret sharing require at least two
non-colluding servers. Wang et al. [123] presented eÔ¨Écient mechanisms for secure outsourcing
of linear programming computations. However, the solution requires matrix-matrix operations
(cubic-time computational burden). Recently, Wang et al. [126] proposed a secure outsourcing
mechanism for solving large-scale systems of linear equations based on the iterative methods.
However, it requires multi-round interactions between the client and the cloud server.
In the following, we introduce the protocols for securely outsourcing matrix multiplication,
matrix inversion, and large-scale system of linear equations, respectively.
3.1
MATRIX MULTIPLICATION
In this section, we introduce two classical protocols for outsourcing matrix multiplication [7]. ÓÄÄat
is, given two n  n matrices M1 and M2, the goal of the client C is to compute the product M1M2.
Since the inputs should not be revealed to the server S, the main trick in these protocols is how
to eÔ¨Éciently disguise the matrices. In some references, the disguising is also-called blinding (a

20
3. SECURE OUTSOURCING OF SCIENTIFIC COMPUTATIONS
typical example is blind signature [33]). From the viewpoint of cryptography, blinding is actually
a kind of one-time encryption, i.e., the blind factor should not be re-used.
Now we consider the problem of matrix multiplication and we only foucs on the dense ma-
trix. A straightforward solution to disguise a matrix is to multiply a random matrix. However, the
problem is that the computational complexity for multiplying two random n  n dense matrices
is O.n3/. Note that we assume that the resource-limited client cannot perform O.n3/ operations.
Atallah et al. [7] presented the following two ways to eÔ¨Éciently disguise a dense matrix by using
the random permutations and (special) sparse matrices. More precisely, the sparse matrices (e.g.,
P1 below) in the constructions are not random chosen sparse ones. Actually, they are the product
of some elementary matrices! Also, the inverse of these matrices could be computed easily, while
the sparse matrices used in [51] are random ones and computing the inverse is a prohibitively
expensive task for the client. Besides, another issue is that the client cannot verify the validity
of result in both schemes [7]. ÓÄÄus, the construction should be given in the honest but curious
model.
3.1.1
A BASIC SOLUTION
Let ƒ±x;y be the Kronecker delta function that equals 1 if x D y and 0 if x ¬§ y. ÓÄÄe Ô¨Årst out-
sourcing protocol consists of the following steps:
1. C generates three random permutations 1, 2, and 3 of the integers f1; 2;    ; ng,
and three sets of non-zero random numbers fÀõ1; Àõ2;    ; Àõng, fÀá1; Àá2;    ; Àáng and
f1; 2;    ; ng. DeÔ¨Åne P1.i; j / D Àõiƒ±1.i/;j, P2.i; j / D Àáiƒ±2.i/;j, P3.i; j / D iƒ±3.i/;j.
Note that these matrices are readily invertible, e.g., P  1
1 .i; j / D .Àõi/ 1ƒ± 1
1
.i/;j.
2. C
computes the matrices X D P1M1P  1
2
and Y D P2M2P  1
3 , where X.i; j / D
.Àõi=Àáj /M1.1.i/; 2.j //, and Y.i; j / D .Àái=j /M2.2.i/; 3.j //.
3. C sends X and Y to S. ÓÄÄen S computes the product
Z D XY D .P1M1P  1
2 /.P2M2P  1
3 / D P1M1M2P  1
3
and sends Z back.
4. C computes the matrix M1M2 D P  1
1 ZP3 locally in O.n2/ time.
In order to determine M1 (or M2), S must guess two permutations (from .n≈†/2 possible
choices) and 3n numbers (Àõi; Àái; i). ÓÄÄus, it is secure enough in many applications when n is
suÔ¨Éciently large (while not in the sense of cryptography).¬π Also, the disguise requires O.n2/ local
computation, and the outsourced computations require O.n3/ operations.
Note that this disguise technique is not a perfect disguise since the data in the matrix
is not fully blind. ÓÄÄe matrix M1 is transformed into X as X D P1M1P  1
2 , where X.i; j / D
¬πÓÄÄis indicates that the disguise could not achieve the cryptographic security since n is at most polynomial size.

3.1. MATRIX MULTIPLICATION
21
.Àõi=Àáj /M1.1.i/; 2.j//. ÓÄÄe non-zero number a in M1 will be transformed into Àõia=Àáj, and
the location is changed according to the two random permutations .1.i/; 2.j //. However, the
number 0 in M1 is still 0 even though the location is changed. Hence, this disguise technique
cannot protect the number 0 in M1.
3.1.2
AN ENHANCED SOLUTION
ÓÄÄe second outsourcing protocol enhances the security compared with the Ô¨Årst one (while the
eÔ¨Éciency is reduced). ÓÄÄe main trick consists of two steps: ÓÄÄe Ô¨Årst one is to hide a matrix by
the sparse random matrices Pi or their inverse P  1
i
just as above. ÓÄÄe second one is to hide the
resulting matrix by adding a dense random matrix.
1. C computes matrices X D P1M1P  1
2
and Y D P2M2P  1
3
as in the Ô¨Årst outsourcing pro-
tocol in Section 3.1.1
2. C generates four random numbers Àá; ; Àá0; 0 such that
.Àá C /.Àá0 C 0/.0Àá   Àá0/ ¬§ 0:
3. C selects two random n  n matrices S1 and S2 and computes the six matrices
X C S1; ÀáX   S1; Àá0X   0S1;
Y C S2; ÀáY   S2; Àá0Y   0S2:
ÓÄÄen C outsources the three matrix multiplications to S
W D .X C S1/.Y C S2/
U D .ÀáX   S1/.ÀáY   S2/
U 0 D .Àá0X   0S1/.Àá0Y   0S2/
which are returned.
4. C computes the matrices
V D .Àá C / 1.U C ÀáW /
V 0 D .Àá0 C 0/ 1.U 0 C Àá00W /
Observe that V D ÀáXY C S1S2 and V 0 D Àá0XY C 0S1S2.
5. C computes XY D .0Àá   Àá0/ 1.0V   V 0/.
6. C computes M1M2 D P  1
1 XYP3.

22
3. SECURE OUTSOURCING OF SCIENTIFIC COMPUTATIONS
3.2
MATRIX INVERSION
In this section, we introduce a secure outsourcing protocol for matrix inversion which uses the
secure matrix multiplication protocol above as a subroutine [7]. ÓÄÄe aim of this protocol is to
compute the inversion matrix M  1 of an n  n matrix M .
1. C selects a random n  n matrix N. If N is non-invertible, then the following Step 4 below
sends us back to Step 1.
2. ÓÄÄe client outsources
OM D MN to S using the secure matrix multiplication protocol in
Section 3.1. Trivially, the server could know neither M, nor N, nor OM.
3. C generates Ô¨Åve matrices P1; P2; P3; P4; P5 using the same method as in Section 3.1. ÓÄÄat
is, P1.i; j / D aiƒ±1.i/:j ; P2.i; j / D biƒ±2.i/:j ; P3.i; j / D ciƒ±3.i/:j ; P4.i; j / D diƒ±4.i/:j,
and P5.i; j / D eiƒ±5.i/:j, where 1; 2; 3; 4; 5 are random permutations, and where
the ai; bi; ci; di; ei are random numbers. C computes the matrices
Q D P1 OMP  1
2 I R D P3NP  1
4 :
4. C outsources the computation of Q 1 to S. If it succeeds, S returns Q 1. Otherwise, S
returns ‚Äúnon-inertible.‚Äù ÓÄÄen we know that at least one of N or M (possibly both) is non-
invertible. C performs the following procedure:
‚Ä¢ C Ô¨Årstly obtains ON D N1NN2 where N1 and N2 are matrices already known to be
invertible and then outsources ON to the server for inverting. Note that the computation
of ON should also be outsourced to S by running the subroutine of matrix multiplication
twice.
‚Ä¢ If S can invert ON (note that C really cares not about the value ON but whether ON
is invertible or not), then N is invertible. Hence, we know that M is not invertible.
Otherwise, ON is not invertible and thus N is not invertible. In this case, return to Step
1.
5. C computes the matrix T D P4P  1
2 Q 1P1P  1
5
and outsources S the computation of Z D
RT using the secure matrix multiplication protocol in Section 3.1.
6. C computes M  1=P  1
3 ZP5 since Z D P3M  1P  1
5 .
ÓÄÄe security of the above protocol follows from the facts that the calculations of OM and Z
are done using secure matrix multiplication. Also, the usage of matrices P1; : : : ; P5 for computing
Q; R; T is never repeated (that is, the random blinding factor should be never re-used). Another
important fact is that the random permutations and numbers used for secure matrix multiplication
subroutine in Steps 2 and 5 must be independently generated from Step 3.

3.3. LARGE-SCALE LINEAR EQUATIONS SYSTEMS
23
One disadvantage of this protocol is that it must run the subroutine of matrix multiplication
four times and matrix inversion (at least) one time. ÓÄÄat is, it requires at least Ô¨Åve rounds of
interaction between C and S. ÓÄÄis is really ineÔ¨Écient for real applications. Another disadvantage
of this protocol is that C must choose lots of random permutations and numbers (even worse
in the case of non-invertible N). Finally, we point out that the protocol is only valid under the
assumption of honest-but-curious server. C could not check the validity of results given by S in
Steps 2, 4, and 5.
3.3
LARGE-SCALE LINEAR EQUATIONS SYSTEMS
ÓÄÄe large-scale system of linear equations Ax D b is one of the most basic algebraic problems in
the scientiÔ¨Åc community [20, 68]. ÓÄÄere are a lot of real-world computation problems that would
result in a large-scale system of linear equations with up to thousands or even millions of unknown
variables. For example, a typical double-precision 50,000  50,000 system matrix resulted from
electromagnetic application would easily occupy up to 20 GBytes storage space. ÓÄÄerefore, the
storage requirements for such a system coeÔ¨Écient matrix may easily exceed the available memory
of the customer‚Äôs computing device, such as a modern portable laptop. Besides, it is ineÔ¨Écient
to perform computations on such a huge system coeÔ¨Écient matrix. Plenty of researchers have
devoted a considerable amount of eÔ¨Äort on seeking eÔ¨Écient algorithms for the task.
ÓÄÄe problem for securely outsourcing large-scale systems of linear equations can be formu-
lated as follows: ÓÄÄe client C seeks the solution to a large-scale system of linear equations Ax D b,
where A 2 Rnn is a real coeÔ¨Écient matrix with rank n, and b 2 Rn is a coeÔ¨Écient vector. Due
to the lack of computing resources, it could be infeasible for C to carry out such expensive com-
putation as O.n/ for 2 <   3 locally. ÓÄÄerefore, C will outsource the computation workloads
to cloud server S in a pay-per-use manner. Note that we only consider the case that A is a general
nonsingular dense matrix. For the case of (extremely) sparse matrices, there may be other more
eÔ¨Écient methods to solve the linear equations.
Atallah et al. [7] presented an outsourcing protocol for a system of linear equations based
on the above outsourcing techniques of matrix multiplication and inversion. ÓÄÄe main trick is
to hide the solutions into a matrix through random permutations and scalings and then use the
technique of matrix inversion. We give a brief overview as below.
1. C selects a random n  n matrix B and a random number j 2 f1; 2;    ; ng. ÓÄÄen, C re-
places the j-th column of B by b, i.e., B D ≈íB1;    ; Bj  1; b; Bj C1;    ; Bn¬ç.
2. C generates three matrices P1; P2; P3 as in Section 3.1. ÓÄÄat is, P1.i; j / D aiƒ±1.i/;j,
P2.i; j / D biƒ±2.i/;j, P3.i; j / D ciƒ±3.i/;j, where 1; 2; 3 are random permutations, and
where the ai; bi; ci are random numbers.
3. C computes the matrices

24
3. SECURE OUTSOURCING OF SCIENTIFIC COMPUTATIONS
OA D P1AP  1
2 I OB D P1BP  1
3 :
4. C outsources OA; OB to S in order to get the solution of the linear system OA OX D OB. If the
server returns that OA is singular, then C also returns that A is singular. Otherwise S returns
OX D OA 1 OB:
5. C compute X D P  1
2
OXP3 which equals A 1B.
6. ÓÄÄe answer x is the j-th column of X, i.e., x D Xj.
ÓÄÄe security of this process follows from the fact that b is hidden through the expansion
to a matrix B, and then A and B are hidden through random scalings and permutations. Also,
it uses the interactive matrix inversion in Section 3.2 as a building block, and thus the scheme is
also interactive and complicated.
3.3.1
NEW SECURE OUTSOURCING PROTOCOL
In the following, we introduce a new protocol LE [51] for securely outsourcing large-scale systems
of linear equations in the fully malicious model. ÓÄÄat is, the computation is delegated to only one
server who may be lazy, curious, and dishonest. ÓÄÄe main trick is to use two random sparse matrices
to hide A. More precisely, C chooses two random sparse matrices M; N 2 Rnn and computes
T D MAN. ÓÄÄe reason to use sparse matrices is that the computational complexity for two dense
matrices‚Äô multiplication is O.n3/. Now we analyze the case that a sparse matrix M multiplies a
dense one A. Without loss of generality, we assume that there are at most  ( << n) non-zero
elements for each row of M. Obviously, it takes at most n2 multiplications to calculate MA
and the computational complexity is O.n2/ since the constant  << n. ÓÄÄus, C can eÔ¨Éciently
compute T D MAN with the complexity of O.n2/.
ÓÄÄe input of LE is a coeÔ¨Écient vector b 2 Rn and a coeÔ¨Écient matrix A 2 Rnn. ÓÄÄe
output of LE is a coeÔ¨Écient vector x 2 Rn such that Ax D b. ÓÄÄe proposed protocol LE is given
as follows:
1. KeyGen.F; / ! .PK; SK/: Given the security parameter  and the target function F W
Ax D b, C picks a random blinding coeÔ¨Écient vector r 2 Rn and two random blinding
sparse matrices M; N 2 Rnn. Note that .M; N; r/ are one-time blinding factors that must
be generated each time for diÔ¨Äerent linear equations. ÓÄÄen, we have PK D n and SK D
.M; N; r/.
2. ProbGenSK.x/ ! .x; x/: Given the input x D .A; b/, C Ô¨Årstly computes c D Ar C b.
Trivially, the original linear equations can be rewritten as A.x C r/ D c. ÓÄÄen, C computes
T D MAN and d D Mc. Without loss of generality, we denote y D N 1.x C r/, where

3.3. LARGE-SCALE LINEAR EQUATIONS SYSTEMS
25
N 1 is the inverse of matrix N. We emphasize that no party needs to compute N 1 in this
algorithm. It appears here only for representing the form of y. Note that
Ty D MAN  N 1.x C r/ D MA.x C r/ D Mc D d:
ÓÄÄerefore, x D .T; d/, and x D .M; N; r/.
3. ComputePK.x/ ! y: C sends x to S, and S responds with the solution y D y such
that Ty D d.
4. VerifySK.x; y/ ! y [ ?: C veriÔ¨Åes whether the equations Ty D d hold. If not, C out-
puts ? and claims the misbehavior of S. Otherwise, C computes x D Ny   r as the result of
function y D F.x/. ÓÄÄe computational complexity for the veriÔ¨Åcation is still O.n2/. ÓÄÄis is
due to the fact that it requires at most n2 multiplications to compute Ty for any (even totally
dense) matrix T and any coeÔ¨Écient vector y. Furthermore, C can detect the misbehavior of
S with the probability 1.
ÓÄÄe protocol LE only requires one round of communication between C and S. ÓÄÄis is
diÔ¨Äerent from Wang et al.‚Äôs protocol [126] that requires multi-round communication between
C and S. More precisely, it may require dozens (or even hundreds) of iterations for a diÔ¨Äerent
matrix A by using the iteration methods. As a result, it also requires dozens (or even hundreds)
of rounds of communications between C and S. ÓÄÄerefore, the scheme could be impractical for
real-world applications.
Some further (implicit) observations on LE are listed as below:
1. Note that the sparse matrices M and N must be invertible (also-called nonsingular). By
L√©vy-Desplanques ÓÄÄeorem (see theorem 6.1.10 of [83]), we know that a strictly diagonally
dominant matrix A 2 Rnn is deÔ¨Ånitely nonsingular. ÓÄÄerefore, in the real applications, we
could choose sparse and row diagonally dominant matrix A such that P
j ¬§i jaij j < jaiij
for all 1  i  n: On the other hand, neither C nor S needs to compute N 1. Otherwise,
the protocol LE is totally impractical. ÓÄÄe reason is twofold: Firstly, though N is a sparse
matrix, the inverse matrix N 1 may be extremely dense. As a result, the computation and
storage cost for N 1 will be very expensive. Secondly, the computation complexity of N 1 is
O.n3/ if we use the naive Gaussian elimination or Gauss-Jordan elimination method.¬≤ ÓÄÄis
contradicts the assumption that C cannot carry out such expensive computation as O.n/
for 2 <   3.
2. Given T and d, S can solve the systems of linear equations Ty D d in any desired methods
such as elimination methods, decomposition (factorization) methods, iterative methods,
¬≤ÓÄÄe complexity of the Strassen algorithm is still O.n2:807/. Coppersmith and Winograd presented the state-of-the-art
record which stands at O.n2:376/. However, the programming of the two algorithms is so awkward and thus neither of them
is suitable for practical applications.

26
3. SECURE OUTSOURCING OF SCIENTIFIC COMPUTATIONS
etc. However, as pointed out in [20], for the systems comprising hundreds of millions or
even billions of equations in as many unknowns, iterative methods may be the only option
available (unless the iteration does not converge). Furthermore, we argue that it does not
require the interactive protocol between C and S in our proposed solution. As a result, S
can eÔ¨Éciently compute y using the iterative methods.
3.3.2
SECURITY ANALYSIS
In the following, we prove that the algorithms .C; S/ in LE can achieve the three security prop-
erties deÔ¨Åned in Section 1.3.
ÓÄÄeorem 3.1
In the fully malicious model, the algorithms .C; S/ in LE achieve the privacy for A, b,
and x.
Proof. We Ô¨Årst prove the privacy for input b and output x of LE. Note that the adversary A can
only know T and d throughout the whole algorithm LE. Besides, we have b D M 1d   Ar, and
x D Ny   r. Since r is a random blinding coeÔ¨Écient vector in Rn, both b and x are blinded by r
in the sense of computational indistinguishability.
We then prove the privacy for input A of LE. Let M D .mij /, N D .nij /, M0 D .m0
ij /, and
N0 D .n0
ij / be four random nonsingular sparse matrices generated by C. Given two nonsingular
dense matrices A D .aij / and A0 D .a0
ij / which are chosen by the adversary A, C computes T D
MAN D .tij / and T0 D M0A0N0 D .t0
ij /, where
tij D
n
X
lD1
n
X
kD1
mik  akl  nlj
and
t0
ij D
n
X
lD1
n
X
kD1
m0
ik  a0
kl  n0
lj :
Note that the numerical value and position of all non-zero elements of four matrices
M; N; M0, and N0 are randomly chosen by C, thus the two values tij and t0
ij are computationally
indistinguishable. ÓÄÄus, the advantage of A to distinguish between T and T0 is negligible.

Remark 1. Note that we currently cannot prove the privacy for any input A of LE (this is not
essential in LE since we only focus on the case that A is a nonsingular dense matrix). For ex-
ample, if the adversary A chooses a nonsingular matrix A and a singular one A0, then he can
distinguish between T D MAN and T0 D M0A0N0 with an overwhelming probability since T0 is
always singular.
Even in some special case that both A and A0 are nonsingular, e.g., let A be a nonsingu-
lar dense matrix and A0 be the identity matrix that is extremely sparse, it seems to be diÔ¨Écult

3.3. LARGE-SCALE LINEAR EQUATIONS SYSTEMS
27
to eÔ¨Éciently distinguish between T and T0 with a non-negligible probability.¬≥ Actually, there is
a paradox between the privacy and eÔ¨Éciency of the outsourcing scheme for any input A. More
precisely, in order to achieve privacy for any input A, the blinding matrix M (and N) for mask-
ing A should also be a random one (and thus may be a dense one). However, it requires O.n3/
computational overhead to compute T (or T0) in this case. ÓÄÄis makes the outsourcing totally
meaningless. We left it as an open problem.
ÓÄÄeorem 3.2
In the fully malicious model, the algorithms .C; S/ in LE are an O. 1
n/-eÔ¨Écient im-
plementation of LE.
Proof. In the proposed algorithm LE, C needs to perform four matrix-vector multiplication (we
omit the vector-addition operations), which takes O.n2/ computations. Besides, C also needs to
compute T D MAN, which also takes O.n2/ computations. On the other hand, it takes O.n3/
computations in order to solve the linear equations directly. ÓÄÄerefore, the algorithms .C; S/ are
an O. 1
n/-eÔ¨Écient implementation of LE.

ÓÄÄeorem 3.3
In the fully malicious model, the algorithms .C; S/ in LE are a 1-checkable implemen-
tation of LE.
Proof. Given a solution y, C can verify whether the equations Ty D d hold eÔ¨Éciently because
the computational complexity for Ty is O.n2/. ÓÄÄerefore, if S misbehaves during any execution
of LE, it will be detected by C with probability Àá D 1.

¬≥Note that the product of extremely sparse matrices can be complete dense [132], thus C could choose suitable M0 and N0 to
ensure that T0 D M0N0 is a dense matrix. Obviously, it is impossible to distinguish T and T0 only based on the sparsity of a
matrix.


29
C H A P T E R
4
Secure Outsourcing of
Cryptographic Operations
In this chapter, we consider the problem of secure outsourcing expensive cryptographic operations
in public key cryptography (PKC).
ÓÄÄe idea of PKC was introduced by DiÔ¨Ée and Hellman [63] 40 years ago (just the same
as my age) and it is really a milestone in the history of cryptology. Plenty of PKC schemes were
broken soon after their birth (even some inventors may claim that their constructions could not
be broken forever!). Nowadays, only two kinds of number-theoretic-based cryptographic systems
are believed to be secure and eÔ¨Écient, i.e., the integer-factorization-based system and discrete-
logarithm-based system. Some well-known concrete constructions include the RSA system, El-
Gamal system, ECC system, etc.
ÓÄÄe Ô¨Årst decade belongs to the RSA system, one of the most commonly used PKC systems
in the world. Many cryptographers presented much security analysis on the RSA (see Boneh‚Äôs
survey [21]), however, no eÔ¨Écient attacks are successful if we choose the parameters of RSA
carefully. ÓÄÄe second decade belongs to the elliptic curve cryptography (ECC) system, which was
invented by Koblitz and Miller in 1985. Compared to the RSA system, one signiÔ¨Åcant advantage
of the ECC system is to oÔ¨Äer the same level of security with much shorter parameters. For exam-
ple, a 160-bit ECC key oÔ¨Äers more or less the same level of security as a 1,024-bit RSA key [94].
Note that the main operation in both RSA and ECC systems is the exponentiation modulo a very
large integer. As Goldwasser and Micali pointed out, ‚Äúeven schemes like RSA are considered too
slow for many practical applications. In particular, these signature schemes require performing
modular exponentiation with a large modulus...‚Äù [66]. ÓÄÄat is, the practicality of PKC schemes is
closely related to the eÔ¨Éciency of modular exponentiation.
ÓÄÄe next decade is the time of bilinear pairings, which initiated some completely new Ô¨Åelds
in cryptography. Due to this new powerful tool, it became possible to realize many cryptographic
primitives that were previously unknown or impractical, such as one-round tripartite key agree-
ment protocol, ID-based encryption schemes, and short signature schemes. However, the com-
putations of modular exponentiation and bilinear pairings are considered to be prohibitively ex-
pensive operations in embedded devices, such as RFID tag, and smart cards. ÓÄÄus, the problem
of securely outsourcing such expensive computations has been well studied in the cryptography
community.

30
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
In 1992, Chaum and Pedersen [34] introduced the notion of ‚Äúwallets with observers,‚Äù
a piece of secure hardware installed on the client‚Äôs computer to perform some expensive
computations‚Äîa prototype of outsourcing computation. In 2005, Hohenberger and Lysyanskaya
[82] proposed the Ô¨Årst outsource-secure algorithm for modular exponentiations based on the two
previous approaches of precomputation [31, 115] and server-aided computation [71, 97]. In their
algorithm, the client needs to do some logic split on the parameters before sending them to the
two untrusted servers. Depending on the results that are returned by the two servers, the client can
verify the correctness of the result with probability 1
2. Chevallier-Mames et al. [37] presented the
Ô¨Årst algorithm for secure delegation of elliptic-curve pairings based on an untrusted server model.
Besides, the client could detect any failures with probability 1 if the server misbehaves. However,
an obvious disadvantage of the algorithm is that the client should carry out some other expensive
operations such as point multiplications (or called scalar multiplications) and exponentiations.
ÓÄÄerefore, the algorithm is not practical for real-world applications in this sense.
4.1
SECURITY DEFINITIONS
Informally, we say that C securely outsources some computations to S, and .C; S/ is an outsource-
secure implementation of a cryptographic algorithm Alg if (1) C and S implement Alg, i.e., Alg D
C S and (2) suppose that C is given oracle access to an adversary S0 (instead of S) that records
all of its computation over time and tries to act maliciously, S0 cannot learn anything interesting
about the input and output of C S0.
In the following, we introduce the formal deÔ¨Ånitions for secure outsourcing of a crypto-
graphic algorithm [82].
DeÔ¨Ånition 4.1
(Algorithm with outsource-I/O) An algorithm Alg obeys the outsource in-
put/output speciÔ¨Åcation if it takes Ô¨Åve inputs, and produces three outputs. ÓÄÄe Ô¨Årst three inputs
are generated by an honest party, and are classiÔ¨Åed by how much the adversary A D .E; S0/ knows
about them, where E is the adversarial environment that submits adversarially chosen inputs to
Alg, and S0 is the adversarial software operating in place of oracle S. ÓÄÄe Ô¨Årst input is called the
honest, secret input, which is unknown to both E and S0; the second is called the honest, protected
input, which may be known by E, but is protected from S0; and the third is called the honest,
unprotected input, which may be known by both E and S. In addition, there are two adversarially
chosen inputs generated by the environment E: the adversarial, protected input, which is known
to E, but protected from S0; and the adversarial, unprotected input, which may be known by E
and S. Similarly, the Ô¨Årst output is called secret, which is unknown to both E and S0; the second
is protected, which may be known to E, but not S0; and the third is unprotected, which may be
known by both parties of A.

4.1. SECURITY DEFINITIONS
31
ÓÄÄe following deÔ¨Ånition of outsource-security ensures that the malicious environment E
cannot gain any knowledge of the secret inputs and outputs of C S, even if C uses the malicious
software S0 written by E.
DeÔ¨Ånition 4.2
(Outsource-security) Let Alg be an algorithm with outsource I/O. A pair of
algorithms .C; S/ is said to be an outsource-secure implementation of Alg if:
1. Correctness: C S is a correct implementation of Alg.
2. Security: For all probabilistic polynomial-time adversaries A D .E; S0/, there exist proba-
bilistic expected polynomial-time simulators .S1; S2/ such that the following pairs of ran-
dom variables are computationally indistinguishable.
‚Ä¢ Pair One. EVIEWreal √è EVIEWideal:
‚Äì ÓÄÄe view that the adversarial environment E obtains by participating in the fol-
lowing real process:
EVIEWi
real D f.istatei; xi
hs; xi
hp; xi
hu/  I.1k; istatei 1/I
.estatei; j i; xi
ap; xi
au; stopi/  E.1k; EVIEWi 1
real ; xi
hp; xi
hu/I
.tstatei; ustatei; yi
s; yi
p; yi
u/  T U 0.ustatei 1/.tstatei 1; xj i
hs; xj i
hp; xj i
hu; xi
ap; xi
au/ W
.estatei; yi
p; yi
u/g
EVIEWreal D EVIEWi
real if stopi D TRUE:
ÓÄÄe real process proceeds in rounds. In round i, the honest (secret, protected, and un-
protected) inputs .xi
hs; xi
hp; xi
hu/ are picked using an honest, stateful process I to which
the environment E does not have access. ÓÄÄen E, based on its view from the last round,
chooses (0) the value of its estatei variable as a way of remembering what it did next
time it is invoked; (1) which previously generated honest inputs .xi
hs; xi
hp; xi
hu/ to give
to C S0 (note that E can specify the index j i of these inputs, but not their values); (2)
the adversarial, protected input xi
ap; (3) the adversarial, unprotected input xi
au; (4) the
Boolean variable stopi that determines whether round i is the last round in this pro-
cess. Next, the algorithm C S0 is run on the inputs .tstatei 1; xj i
hs; xj i
hp; xj i
hu; xi
ap; xi
au/,
where tstatei 1 is C‚Äôs previously saved state, and produces a new state tstatei for C, as
well as the secret yi
s, protected yi
p and unprotected yi
u outputs. ÓÄÄe oracle S0 is given
its previously saved state, ustatei 1, as input, and the current state of S0 is saved in
the variable ustatei. ÓÄÄe view of the real process in round i consists of estatei, and the
values yi
p and yi
u. ÓÄÄe overall view of E in the real process is just its view in the last
round (i.e., i for which stopi D TRUE:).
‚Äì ÓÄÄe ideal process:

32
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
EVIEWi
ideal D f.istatei; xi
hs; xi
hp; xi
hu/  I.1k; istatei 1/I
.estatei; j i; xi
ap; xi
au; stopi/  E.1k; EVIEWi 1
ideal; xi
hp; xi
hu/I
.astatei; yi
s; yi
p; yi
u/  Alg.astatei 1; xj i
hs; xj i
hp; xj i
hu; xi
ap; xi
au/I
.sstatei; ustatei; Y i
p; Y i
u; repi/  SU 0.ustatei 1/
1
.sstatei 1;    ; xj i
hp; xj i
hu; xi
ap; xi
au; yi
p; yi
u/I
.zi
p; zi
u/ D repi.Y i
p; Y i
u/ C .1   repi/.yi
p; yi
u/ W
.estatei; zi
p; zi
u/g
EVIEWideal D EVIEWi
ideal if stopi D TRUE:
ÓÄÄe ideal process also proceeds in rounds. In the ideal process, we have a stateful sim-
ulator S1 who, shielded from the secret input xi
hs, but given the non-secret outputs
that Alg produces when running all the inputs for round i, decides to either output
the values .yi
p; yi
u/ generated by Alg, or replace them with some other values .Y i
p; Y i
u/.
Note that this is captured by having the indicator variable repi be a bit that determines
whether yi
p will be replaced with Y i
p. In doing so, it is allowed to query oracle S0;
moreover, S0 saves its state as in the real experiment.
‚Ä¢ Pair Two. UVIEWreal √è UVIEWideal:
‚Äì ÓÄÄe view that the untrusted software S0 obtains by participating in the real process
described in Pair One. UVIEWreal D ustatei if stopi D TRUE:
‚Äì ÓÄÄe ideal process:
UVIEWi
ideal D f.istatei; xi
hs; xi
hp; xi
hu/  I.1k; istatei 1/I
.estatei; j i; xi
ap; xi
au; stopi/  E.1k; estatei 1; xi
hp; xi
hu; yi 1
p
; yi 1
u
/I
.astatei; yi
s; yi
p; yi
u/  Alg.astatei 1; xj i
hs; xj i
hp; xj i
hu; xi
ap; xi
au/I
.sstatei; ustatei/  SU 0.ustatei 1/
2
.sstatei 1; xj i
hu; xi
au/ W
.ustatei/g
UVIEWideal D UVIEWi
ideal if stopi D TRUE:
In the ideal process, we have a stateful simulator S2 who, equipped with only the un-
protected inputs .xi
hu; xi
au/, queries S0. As before, S0 may maintain state.
DeÔ¨Ånition 4.3
(Àõ-eÔ¨Écient, secure outsourcing) A pair of algorithms .C; S/ is said to be an
Àõ-eÔ¨Écient implementation of Alg if (1) C S is a correct implementation of Alg and (2) 8 inputs x,
the running time of C is no more than an Àõ-multiplicative factor of the running time of Alg.
DeÔ¨Ånition 4.4
(Àá-checkable, secure outsourcing) A pair of algorithms .C; S/ is said to be a
Àá-checkable implementation of Alg if (1) C S is a correct implementation of Alg and (2) 8 inputs

4.2. TWO UNTRUSTED PROGRAM MODEL
33
x, if S0 deviates from its advertised functionality during the execution of C S0.x/, C will detect
the error with probability no less than Àá.
DeÔ¨Ånition 4.5
(.Àõ; Àá/-outsource-security) A pair of algorithms .C; S/ is said to be an .Àõ; Àá/-
outsource-secure implementation of Alg if it is both Àõ-eÔ¨Écient and Àá-checkable.
It is worth noting that, depending on the Àá parameter, a secure outsourcing algorithm may
not provide 100 percent checkability (e.g., [49, 82]). In practice, it is very likely that a client will
run the outsourcing algorithm many times with the same server. If a server cheats frequently,
there is a high chance that it will be caught in some instances of the algorithm. ÓÄÄen the client
may seriously punish the server when a cheating is detected. As a result, the server will not Ô¨Ånd
the incentive to cheat in practice. Nevertheless, it is clear that a larger Àá is always better. However,
there is a tradeoÔ¨Äbetween the eÔ¨Éciency (Àõ) and checkability (Àá). For instance, a trivial way to
improve the value of Àá is to add a lot of dummy computations to check whether the server is
honest or not. ÓÄÄis will signiÔ¨Åcantly reduce the eÔ¨Éciency because the server needs to perform a
lot of additional computations.
4.2
TWO UNTRUSTED PROGRAM MODEL
Hohenberger and Lysyanskaya [82] Ô¨Årst presented the so-called two untrusted program model for
outsourcing exponentiations modulo a prime. In this model, the adversarial environment E writes
the code for two (potentially diÔ¨Äerent) programs S0 D .S0
1; S0
2/. E then gives this software to C,
advertising a functionality that S0
1 and S0
2 may or may not accurately compute, and C installs
this software in a manner such that all subsequent communication between any two of E, S0
1,
and S0
2 must pass through C. ÓÄÄe new adversary attacking C is A D .E; S0
1; S0
2/. Moreover, we
assume that at most one of the programs S0
1 and S0
2 deviates from its advertised functionality on a
non-negligible fraction of the inputs, while we cannot know which one, and security means that
there is a simulator S for both. ÓÄÄis is named the one-malicious version of two untrusted program
model (i.e., ‚Äúone-malicious model‚Äù for simplicity) as shown in Fig. 4.1.
ÓÄÄe computation model using multiple, possibly dishonest, but physically separated parties
has been well studied in the literature [14, 25, 26]. Actually, in real-world applications, it is equiv-
alent to buying two copies of the advertised software from two diÔ¨Äerent vendors and achieving
the security as long as one of them is honest.
4.3
SECURE OUTSOURCING OF SINGLE MODULAR
EXPONENTIATION
Modular exponentiation is the most basic operation in discrete-logarithm-based cryptographic
protocols. However, it has been considered much more expensive for the resource-limited devices
such as RFID tags or smart cards. ÓÄÄerefore, it is important to present an eÔ¨Écient method to
securely outsource such operations to (untrusted) powerful servers.

34
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
Y1
response
Y2
response
E
Checkability
Checkability
Ch
k bilit
T
D
data
F
code
D
data
F
code
Y1
Y
response
D
data
F
code
Y2
Y
response
D
data
F
code
Secrecy
Secrecy
E
Write 
Program
Write 
Program
Non-
collusion
Efficiency
Figure 4.1: One-malicious version of two untrusted program model.
Now we formulate the problem of outsourcing of a single modular exponentiation: the aim
of client C is to compute a single modular exponentiation ua mod p (for an arbitrary base u
and an arbitrary power a), where p is a large prime. Due to limited computational resources, C
outsources the operation to two potentially malicious while much more computationally powerful
servers S1 and S2. An essential requirement is that the adversary A cannot know any useful
information about the inputs and outputs of outsourcing algorithm, i.e., .u; a; ua/.
Hohenberger and Lysyanskaya [82] proposed the Ô¨Årst outsource-secure modular exponen-
tiation algorithm based on the two previous approaches of precomputation [31, 66, 106, 115]
and server-aided computation [12, 71, 97, 128]. ÓÄÄe main trick is to use some random blinding
factors to logically split the inputs into two random-looking pieces for two untrusted servers. Be-
sides, in the pre-processing phase, C is allowed to invest some one-time expensive computations
for a subroutine called Rand in order to speed up oÔ¨Ä-line computation. For each invocation of
Rand, the inputs are a large prime p, a Ô¨Åxed base g 2 Z
p, and a random value b, and the outputs
are a random, independent pair of the form .b; gb mod p/.‚Å¥ ÓÄÄere are two approaches to imple-
ment this functionality. One is for a trusted server to compute a table of random, independent
pairs in advance and then load it into the memory of C. ÓÄÄe other is to apply the well-known
preprocessing techniques (e.g., EBPV generator [106]).
‚Å¥ÓÄÄough the computation of Rand is also to perform a modular exponentiation, it always uses the Ô¨Åxed base g. ÓÄÄis is the
reason why we cannot just use the subroutine Rand to accomplish the outsourcing task. Furthermore, we emphasize that C
can never control the output of Rand in both approaches, especially the value of b.

4.3. SECURE OUTSOURCING OF SINGLE MODULAR EXPONENTIATION
35
Recently, Chen et al. [49] proposed the second secure outsourcing algorithm Exp for expo-
nentiation modulo a prime in the one-malicious model. ÓÄÄe algorithm is superior to [82] in both
eÔ¨Éciency and checkability due to a new splitting and testing trick. ÓÄÄe main idea is somewhat
similar to the famous ‚Äúprisoner‚Äôs dilemma‚Äù in game theory. We illustrate it in more detail below.
Suppose that two suspects A and B are arrested and imprisoned while the prosecutors lack
suÔ¨Écient evidence to convict them. ÓÄÄen the prosecutors separate them and each prisoner is in
solitary conÔ¨Ånement with no means of communicating with the other (i.e., there is either no
subliminal channels). Simultaneously, the prosecutors oÔ¨Äer them a bargain as follows:
‚Ä¢ If A and B both admitted their guilt, each of them serves 10 years in prison.
‚Ä¢ If A admitted their guilt while B kept silent, A will be set free and B will serve 30 years in
prison (and vice versa).
‚Ä¢ If A and B both kept silent, both of them will be serve 1 year in prison.
Trivially, the third case can maximize the common interests of the two suspects. ÓÄÄis means
that both of them should be dishonest and output the false facts (i.e., neither of them admitted
their guilt). However, the experimental results show that the two suspects will betray each other
in an overwhelming probability (this means that they output the true facts). ÓÄÄis indicates that
the probability for two parties to output the same false facts is negligible if they do not collude
with each other. In the one-malicious model, the two cloud servers are assumed not to collude
with each other. Given the same computation task, the probability for them to output the same
invalid results is negligible. ÓÄÄus, they output either the same valid results or the diÔ¨Äerent invalid
results. ÓÄÄis fact motivates us to have an idea that we could use some partial computation result to
act as a test query in the one-malicious model. Actually, this is the reason why the algorithm [49]
could improve Hohenberger and Lysyanskaya‚Äôs algorithm in both eÔ¨Éciency and checkability.
4.3.1
THE PROPOSED ALGORITHM
Let p; q be two large primes and qjp   1. ÓÄÄe input of Exp is a 2 Z
q, and u 2 Z
p such that uq D
1 mod p (for an arbitrary base u and an arbitrary power a). ÓÄÄe output of Exp is ua mod p.
Note that a may be secret or (honest/adversarial) protected and u may be (honest/adversarial)
protected. Both a and u are computationally blinded to S1 and S2. Similar to [82], Si.x; y/ ! yx
also denotes that Si takes as inputs .x; y/ and outputs yx mod p, where i D 1; 2. ÓÄÄe proposed
algorithm Exp is given as follows:
1. To implement this functionality using S1 and S2, C Ô¨Årstly runs Rand twice to create two
blinding pairs .Àõ; gÀõ/ and .Àá; gÀá/. We denote v D gÀõ mod p and  D gÀá mod p.
2. ÓÄÄe main trick is a more eÔ¨Écient solution to logically split u and a into random looking
pieces that can be computed by S1 and S2. ÓÄÄe Ô¨Årst logical divisions are
ua D .vw/a D gaÀõwa D gÀágwa
mod p;

36
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
where w D u=v mod p and  D aÀõ   Àá mod q.
ÓÄÄe second logical divisions are
ua D gÀágwa D gÀágwkCl D gÀágwkwl
mod p;
where l D a   k mod q.
3. Next, C runs Rand to obtain three pairs .t1; gt1/, .t2; gt2/, and .t3; gt3/.
4. C queries S1 in random order as
S1.t2=t1; gt1/ ! gt2;
S1.=t3; gt3/ ! g;
S1.l; w/ ! wl.
Similarly, C queries S2 in random order as
S2.t2=t1; gt1/ ! gt2;
S2.=t3; gt3/ ! g;
S2.k; w/ ! wk.
5. Finally, C checks that both S1 and S2 produce the correct outputs, i.e., gt2 D
S1.t2=t1; gt1/ D S2.t2=t1; gt1/ and S1.=t3; gt3/ D S2.=t3; gt3/. If not, C outputs ‚Äúer-
ror‚Äù; otherwise, C can compute ua D gwkwl.
Remark 2. In the one-malicious model, the equation S1.=t3; gt3/ D S2.=t3; gt3/ implies both
S1 and S2 produce the correct g. ÓÄÄerefore, the partial computation result g also plays the role
of a test query. ÓÄÄis is slightly diÔ¨Äerent from the technique in [82] while it indeed improves the
eÔ¨Éciency and checkability of the computations.
4.3.2
SECURITY ANALYSIS
ÓÄÄeorem 4.6
In the one-malicious model, the algorithms .C; .S1; S2// are an outsource-secure im-
plementation of Exp, where the input .a; u/ may be honest, secret; or honest, protected; or adversarial,
protected.
Proof. ÓÄÄe proof is similar to [82]. ÓÄÄe correctness is trivial and we only focus on security. Let
A D .E; S0
1; S0
2/ be a PPT adversary that interacts with a PPT algorithm C in the one-malicious
model.
Firstly, we prove Pair One EVIEWreal √è EVIEWideal:
If the input .a; u/ is anything other than honest, secret, then the simulator S1 behaves the
same way as in the real execution. If .a; u/ is an honest, secret input, then the simulator S1 behaves

4.3. SECURE OUTSOURCING OF SINGLE MODULAR EXPONENTIATION
37
as follows: on receiving the input on round i, S1 ignores it and instead makes three random
queries of the form .Àõj ; Àáj / to both S0
1 and S0
2. S1 randomly tests two outputs (i.e., Àá
Àõj
j ) from
each program. If an error is detected, S1 saves all states and outputs Y i
p=‚Äúerror,‚Äù Y i
u=¬ø, repi=1
(i.e., the output for ideal process is .estatei; ‚Äò‚Äòerror;00 ¬ø/). If no error is detected, S1 checks the
remaining two outputs. If all checks pass, S1 outputs Y i
p=¬ø, Y i
u=¬ø, repi=0 (i.e., the output for ideal
process is .estatei; yi
p; yi
u/); otherwise, S1 selects a random element r and outputs Y i
p=r, Y i
u=¬ø,
repi=1 (i.e., the output for ideal process is .estatei; r; ¬ø/). In either case, S1 saves the appropriate
states. ÓÄÄe input distributions to .S0
1; S0
2/ in the real and ideal experiments are computationally
indistinguishable. In the ideal experiment, the inputs are chosen uniformly at random. In the real
experiment, each part of all three queries that C makes to any one program is independently re-
randomized and thus computationally indistinguishable from random. If .S0
1; S0
2/ are honest in
round i, then EVIEWi
real √è EVIEWi
ideal (this is because C .S0
1;S0
2/ perfectly executes Exp in the real
experiment and S1 simulates with the same outputs in the ideal experiment, i.e., repi=0). If one
of .S0
1; S0
2/ is dishonest in the round i, then it will be detected by both C and S1 with probability
2
3, resulting in an output of ‚Äúerror‚Äù; otherwise, the output of Exp is corrupted (with probability
1
3). In the real experiment, the three outputs generated by .S0
1; S0
2/ are multiplied together along
with a random value. In the ideal experiment, S1 also simulates with a random value r. ÓÄÄus,
EVIEWi
real √è EVIEWi
ideal even when one of .S0
1; S0
2/ is dishonest. By the hybrid argument, we
conclude that EVIEWreal √è EVIEWideal.
Secondly, we prove Pair Two UVIEWreal √è UVIEWideal:
ÓÄÄe simulator S2 always behaves as follows: on receiving the input on round i, S2 ignores
it and instead makes three random queries of the form .Àõj ; Àáj / to both S0
1 and S0
2. ÓÄÄen S2
saves its states and the states of .S0
1; S0
2/. E can easily distinguish between these real and ideal
experiments (note that the output in the ideal experiment is never corrupted). However, E cannot
communicate this information to .S0
1; S0
2/. ÓÄÄis is because in the round i of the real experiment, C
always re-randomizes its inputs to .S0
1; S0
2/. In the ideal experiment, S2 always generates random,
independent queries for .S0
1; S0
2/. ÓÄÄus, for each round i we have UVIEWi
real √è UVIEWi
ideal. By
the hybrid argument, we conclude that UVIEWreal √è UVIEWideal.

ÓÄÄeorem 4.7
In the one-malicious model, the algorithms .C; .S1; S2// are an .O. log2 n
n
/; 2
3/-
outsource-secure implementation of Exp.
Proof. ÓÄÄe proposed algorithm Exp makes 5 calls to Rand plus 7 modular multiplication (MM)
and 3 modular inverse (MInv) in order to compute ua mod p (we omit other operations such
as modular additions). Also, Exp takes O.log2 n/ or O.1/ MM using the EBPV generator or
table-lookup method, respectively, where n is the bit-length of the a. On the other hand, it takes
roughly 1:5n MM to compute ua mod p by the square-and-multiply method. ÓÄÄus, the algo-
rithms .C; .S1; S2// are an O. log2 n
n
/-eÔ¨Écient implementation of Exp.

38
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
On the other hand, S1 (resp. S2) cannot distinguish the two test queries from all of the
three queries that C makes. If S1 (resp. S2) fails during any execution of Exp, it will be detected
with probability 2
3.

4.3.3
COMPARISON
We compare the above algorithm Exp [49] with Hohenberger-Lysyanskaya‚Äôs algorithm in [82].
We denote by MM a modular multiplication, by MInv a modular inverse, and by RandInvoke an
invocation of the subroutine Rand. We omit other operations such as modular additions in both
algorithms. Table 4.1 presents the comparison of the eÔ¨Éciency and the checkability between
Hohenberger-Lysyanskaya‚Äôs algorithm and the algorithm Exp.
Table 4.1: Comparison of the two algorithms
Algorithm [84]
Algorithm Exp [49]
MM
9
7
MInv
5
3
Invoke (Rand)
6
5
Invoke (S1)
4
3
Invoke (S2)
4
3
Checkability
¬Ω
‚Öî
Compared with Hohenberger-Lysyanskaya‚Äôs algorithm, the proposed algorithm Exp is su-
perior in both eÔ¨Éciency and checkability. More precisely, Exp requires only 7 MM, 3 MInv,
5 invocation of Rand, and 3 invocation of S1 and S2 for each modular exponentiation. Note
that the modular exponentiation is the most basic operation in discrete-logarithm-based crypto-
graphic protocols, and millions of such computations may be outsourced to the server every day.
ÓÄÄus, our proposed algorithm can save huge computational resources for both the outsourcer C
and the servers S1 and S2.
On the other hand, Exp requires only 3 invocation of S1 and S2 for each modular exponen-
tiation, thus the communication overload is 6.jpj C jqj/. However, the communication overload
of algorithm [82] is 8.jpj C jqj/ since it requires 4 invocation of S1 and S2.
4.4
SECURE OUTSOURCING OF SIMULTANEOUS
MODULAR EXPONENTIATION
In this section, we focus on simultaneous modular exponentiations ua
1ub
2 mod p, which play an
important role in many cryptographic primitives such as chameleon hashing [5, 6, 42, 44, 46, 90,
114] and trapdoor commitment [9, 80, 108]. Trivially, a simultaneous modular exponentiation

4.4. SECURE OUTSOURCING OF SIMULTANEOUS MODULAR EXPONENTIATION
39
can be carried out by invoking 2 modular exponentiations. ÓÄÄis requires roughly 3n MM, where
n is the bit-length of a and b. However, the computation cost is only 1:75n MM (i.e., roughly
1.17 modular exponentiation) if we use the simultaneous multiple exponentiation algorithm from
Chapter 14 of [99].
Recently, Chen et al. [49] proposed the Ô¨Årst eÔ¨Écient outsource-secure algorithm of simul-
taneous modular exponentiations SExp in the one-malicious model. In the following, we give an
introduction for this outsourcing algorithm. Note that SExp also uses the same subroutine Rand
as in Section 4.3.
4.4.1
OUTSOURCING ALGORITHM
Let p; q be two large primes and qjp   1. Given two arbitrary bases u1; u2 2 Z
p and two arbitrary
powers a; b 2 Z
q such that the order of u1 and u2 is q. ÓÄÄe output of SExp is ua
1ub
2 mod p. Both
a and u are computationally blinded to U1 and S2.
1. C Ô¨Årstly runs Rand twice to create two blinding pairs .Àõ; gÀõ/ and .Àá; gÀá/. We denote v D
gÀõ mod p and  D gÀá mod p.
2. ÓÄÄe Ô¨Årst logical divisions are
ua
1ub
2 D .vw1/a.vw2/b D gÀágwa
1wb
2;
where w1 D u1=v, w2 D S2=v, and  D .a C b/Àõ   Àá.
ÓÄÄe second logical divisions are
ua
1ub
2 D gÀágwa
1wb
2 D gÀágwk
1wl
1wt
2ws
2;
where l D a   k and s D b   t.
3. Next, C runs Rand to obtain three pairs .t1; gt1/, .t2; gt2/, and .t3; gt3/.
4. C queries S1 in random order as
S1.t2=t1; gt1/ ! gt2;
S1.=t3; gt3/ ! g;
S1.k; w1/ ! wk
1;
S1.t; w2/ ! wt
2.
Similarly, C queries S2 in random order as
S2.t2=t1; gt1/ ! gt2;
S2.=t3; gt3/ ! g;
S2.l; w1/ ! wl
1;
S2.s; w2/ ! ws
2.

40
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
5. Finally, C checks that both S1 and S2 produce the correct outputs, i.e., gt2 D
S1.t2=t1; gt1/ D S2.t2=t1; gt1/ and S1.=t3; gt3/ D S2.=t3; gt3/. If not, C outputs ‚Äúer-
ror‚Äù; otherwise, C can compute ua
1ub
2 D gwk
1wl
1wt
2ws
2.
Similar to theorem 3.1 and 3.2, we can easily prove the following theorem:
ÓÄÄeorem 4.8
In the one-malicious model, the algorithms .C; .S1; S2// are an .O. log2 n
n
/; 1
2/-
outsource-secure implementation of SExp.
4.4.2
EFFICIENCY
Note that SExp requires only 10 MM, 4 MInv, 5 invocation of Rand, and 4 invocation of S1 and
S2 for each modular exponentiation. ÓÄÄerefore, the computation cost of SExp is much less than
that of double running Exp. Surprisingly, it is even comparable to that of outsourcing one modular
exponentiation [82]. Table 4.2 presents the comparison of the eÔ¨Éciency and the checkability
between Hohenberger-Lysyanskaya‚Äôs Exp algorithm and our proposed algorithm SExp.
Table 4.2: EÔ¨Éciency comparison for two algorithms
Algorithm [84]
Algorithm SExp [49]
MM
9
10
MInv
5
4
Invoke (Rand)
6
5
Invoke (S1)
4
4
Invoke (S2)
4
4
Checkability
¬Ω
¬Ω
4.5
SECURE OUTSOURCING OF BILINEAR PAIRINGS
Chevallier-Mames et al. [37] presented the Ô¨Årst algorithm for secure delegation of elliptic-curve
pairings based on an untrusted server model. Besides, the outsourcer could detect any failures with
probability 1 if the server misbehaves. However, an obvious disadvantage of the algorithm is that
the outsourcer should carry out some other expensive operations such as point multiplications
and exponentiations. More precisely, on the one hand, we argue that these expensive operations
might be too resource consuming to be carried out on a computationally limited device. On the
other hand, the computation of point multiplications is even comparable to that of bilinear pair-
ings in some scenarios [72, 116].‚Åµ ÓÄÄerefore, it is meaningless if the client must perform point
‚ÅµAs pointed out in [72, 116], when the supersingular elliptic curve is deÔ¨Åned over a 512-bit Ô¨Ånite Ô¨Åeld with embedding degree
2, the computational overhead of a point multiplication is almost the same as that of a standard Tate pairing.

4.5. SECURE OUTSOURCING OF BILINEAR PAIRINGS
41
multiplications and exponentiations in order to outsource pairings, since this contradicts the aim
of outsourcing computation.
In the following, we introduce a new secure outsourcing algorithm Pair for bilinear pairings
in the one-malicious model [53]. A distinguishing property of the algorithm is that the (resource-
constrained) client never performs any expensive operations such as point multiplications and
exponentiations. Besides, in the algorithm [53], note that G1 and G2 are two cyclic additive
groups of order q and GT is a cyclic multiplicative cycle group of the same order. ÓÄÄe pairing is
a map e W G1  G2 ! GT . Trivially, it is no diÔ¨Äerence if we use the notations for multiplicative
groups of G1 and G2.
4.5.1
OUTSOURCING ALGORITHM
ÓÄÄe input of Pair is two random points A 2 G1, B 2 G2, and the output of Pair is e.A; B/.
Note that A and B may be secret or (honest/adversarial) protected and e.A; B/ is always se-
cret or protected. Moreover, both A and B are computationally blinded to S1 and S2. We let
Si.1; 2/ ! e.1; 2/ denote that Si takes as inputs .1; 2/ and outputs e.1; 2/, where
i D 1; 2. ÓÄÄe proposed outsourcing algorithm Pair consists of the following steps:
1. To implement this functionality using S1 and S2, C Ô¨Årstly runs Rand to create a blinding
six-tuple .V1; V2; v1V1; v2V1; v2V2; e.v1V1; v2V2//. We denote  D e.v1V1; v2V2/.
2. ÓÄÄe main trick of Pair is to logically split A and B into random looking pieces that can
be computed by S1 and S2. Without loss of generality, let Àõ1 D e.A C v1V1; B C v2V2/,
Àõ2 D e.A C V1; v2V2/, and Àõ3 D e.v1V1; B C V2/. Note that
Àõ1 D e.A; B/e.A; v2V2/e.v1V1; B/e.v1V1; v2V2/;
Àõ2 D e.A; v2V2/e.V1; v2V2/;
Àõ3 D e.v1V1; B/e.v1V1; V2/;
ÓÄÄerefore, e.A; B/ D Àõ1Àõ 1
2 Àõ 1
3  1e.V1; V2/v1Cv2.
3. C then runs Rand to obtain two new six-tuple
.X1; X2; x1X1; x2X1; x2X2; e.x1X1; x2X2//
and
.Y1; Y2; y1Y1; y2Y1; y2Y2; e.y1Y1; y2Y2//:
4. C queries S1 in random order as
S1.A C v1V1; B C v2V2/ ! e.A C v1V1; B C v2V2/ D Àõ1;
S1.v1V1 C v2V1; V2/ ! e.V1; V2/v1Cv2;

42
4. SECURE OUTSOURCING OF CRYPTOGRAPHIC OPERATIONS
S1.x1X1; x2X2/ ! e.x1X1; x2X2/;
S1.y1Y1; y2Y2/ ! e.y1Y1; y2Y2/;
Similarly, C queries S2 in random order as
S2.A C V1; v2V2/ ! e.A C V1; v2V2/ D Àõ2;
S2.v1V1; B C V2/ ! e.v1V1; B C V2/ D Àõ3;
S2.x1X1; x2X2/ ! e.x1X1; x2X2/;
S2.y1Y1; y2Y2/ ! e.y1Y1; y2Y2/;
5. Finally, C checks that both S1 and S2 produce the correct outputs, i.e., e.x1X1; x2X2/ and
e.y1Y1; y2Y2/ for the test queries. If not, C outputs ‚Äúerror‚Äù; otherwise, C can compute
e.A; B/ D Àõ1Àõ 1
2 Àõ 1
3  1e.V1; V2/v1Cv2.
Remark 3. Given a random point P in G1 (or G2), C can compute the inverse point  P eas-
ily. ÓÄÄerefore, C can query S2.A C V1;  v2V2/ ! e.A C V1;  v2V2/ D Àõ 1
2
and S2. v1V1; B C
V2/ ! e. v1V1; B C V2/ D Àõ 1
3 . Similarly, we can deÔ¨Åne the outputs of Randas
.V1; V2; v1V1; v2V1; v2V2; e.v1V1; v2V2/ 1/:
ÓÄÄerefore, C need not perform the inverse computation in GT .
4.5.2
IMPROVED OUTSOURCING ALGORITHM
Recently, Tian et al. [122] proposed a new algorithm for securely outsourcing bilinear pairings
based on the two untrusted model, where the two cloud servers are both malicious while not in
collusion with each other. Otherwise, we can view them as one untrusted server. On the other
hand, we should emphasize that the security model in Pair [53] is actually one malicious version
of the two untrusted program model (at most one of the two servers is malicious).
ÓÄÄe proposed algorithm consists of the following steps:
1. To implement this functionality using S1 and S2, C Ô¨Årstly runs Rand* twice to create two
blinding six-tuple
.x1P1; x1x 1
2 x3P1; x 1
1 x2P2; x 1
1 x4P2; e.P1; P2/x3Cx4 x2/
and
.y1P1; y1y 1
2 y3P1; y 1
1 y2P2; y 1
1 y4P2; e.P1; P2/y3Cy4 y2/:
Also, C randomly selects a small integer t 2 f1; : : : ; sg. Generally, s could be a 20-bit integer
in the real applications.

4.5. SECURE OUTSOURCING OF BILINEAR PAIRINGS
43
2. ÓÄÄe main trick of Pair* is also to logically split A and B into random looking pieces
that can be computed by S1 and S2. Besides, these partial results are used to repre-
sent two diÔ¨Äerent but related functions f and g of e.A; B/, respectively. More precisely,
f .e.A; B// D e.A; B/ and g.e.A; B// D e.A; B/t. If and only if the veriÔ¨Åcation equation
g D f t holds, C is convinced that both S1 and S2 output the valid results. ÓÄÄe principle
is that the probability for two untrusted servers to output two results that satisfy some un-
known conditions is negligible if they do not collude with each other, while in Chen et
al‚Äôs algorithm Pair, the veriÔ¨Åcation equation is the relation of two test queries (not the two
functions).
3. C queries S1 in random order as
S1.A C x1P1; B C x 1
1 x2P2/ ! Àõ1;
S1.tA C y1y 1
2 y3P1;  y 1
1 y2P2/ ! Àõ2;
S1. y1P1; B C y 1
1 y4P2/ ! Àõ3;
4. Similarly, C queries S2 in a random order as
S2.tA C y1P1; B C y 1
1 y2P2/ ! Àõ0
1;
S2.A C x1x 1
2 x3P1;  x 1
1 x2P2/ ! Àõ0
2;
S2. x1P1; B C x 1
1 x4P2/ ! Àõ0
3;
5. Finally, C computes
 D Àõ1Àõ0
2Àõ0
3e.P1; P2/x3Cx4 x2
and
0 D Àõ0
1Àõ2Àõ3e.P1; P2/y3Cy4 y2:
If t D 0 and  2 GT , C outputs  as the result of e.A; B/. Otherwise, outputs ‚Äúerror.‚Äù
Remark4. As pointed out in [39], it is essential to test the membership of an output, i.e.,  2 GT .
ÓÄÄe reason is that a malicious program may modify a response by multiplying an element of
small orders. For some parameter sets given in [30, 113], the membership test does not need an
exponentiation. A more general solution is to outsource the membership test operation. Since S1
or S2 knows the order q, we may use a secure public-exponent-secret-base outsourcing algorithm
[134] to compute q and compare the result with e.P1; P2/ to determine whether  2 GT .


45
C H A P T E R
5
Secure Outsourcing of Large
Database With Updates
In this chapter, we mainly focus on secure outsourcing of large database (i.e., outsourcing storage).
ÓÄÄat is, assume that a resource-constrained client would like to store a very large database on a
server so that it could later retrieve a database record and update a record by assigning a new
value. If the server attempts to tamper with the database, it will be detected by the client with an
overwhelming probability. Besides, the computation and storage resources invested by the client
must not depend on the size of the database (except for an initial setup phase). Recently, plenty
of research has been done on this hot topic [84, 102, 104, 112, 127, 133].
For the case of static database, we can easily solve the problem of outsourcing storage by
using message authentication codes or digital signatures. However, it is another thing if the client
(frequently) performs updates on the database. As noted in [18], the main technical diÔ¨Éculty in
this case is that the client must have a mechanism to revoke the signatures given to the server
for the previous values. Otherwise, the malicious server can utilize the previous (while valid)
database records and corresponding signatures to respond to the current query of the client. In
order to solve this issue, the client should keep track of every change locally. However, this totally
contradicts the goal of outsourcing, i.e., the client should use much fewer resources than those
needed to store the database locally.
Previous research on outsourcing dynamic databases is mainly based on accumulators [56,
57, 105] and authenticated data structures [98, 107, 109, 121]. However, Benabbas, Gennaro, and
Vahlis [18] pointed out that these solutions either rely on non-constant size assumptions (such
as the strong DiÔ¨Ée-Hellman assumption) or require expensive operations (such as re-shuÔ¨Ñing
procedures) [18]. Besides, they introduced a new primitive called veriÔ¨Åable database (VDB) to
solve the problem. ÓÄÄey also presented the Ô¨Årst practical VDB scheme which relies on a constant
size assumption in bilinear groups of composite order. However, the scheme only supports private
veriÔ¨Åability, that is, only the owner of the database can verify the correctness of the proofs. In some
scenarios, especially in the case that the database owner is not the database user, it is essential
to achieve public veriÔ¨Åability (i.e., anyone can verify the correctness of the proofs). Motivated
by this issue, Catalano and Fiore [41] proposed an elegant solution to build VDB from vector
commitment. Besides, another advantage of this construction is that it relies on standard constant-
size assumption.

46
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
5.1
SECURITY DEFINITIONS
We consider the database DB as a set of tuples .x; mx/ in some appropriate domain, where x is an
index and mx is the corresponding value. Informally, a VDB scheme allows a resource-constrained
client C to outsource the storage of a very large database to a server S in such a way that C can
later retrieve and update the database records from S. Inherently, any attempts to tamper with
the data by the dishonest S will be detected with an overwhelming probability when C queries
the database. In order to achieve the conÔ¨Ådentiality of the data record mx, C can use a master
secret key to encrypt each mx using a symmetric encryption scheme such as AES. Trivially, given
the ciphertext vx, only C can compute the record mx. ÓÄÄerefore, we only need to consider the
case of encrypted database .x; vx/. ÓÄÄis is implicitly assumed in the existing academic research.
ÓÄÄe formal deÔ¨Ånition for veriÔ¨Åable databases with updates is given as follows [18, 41]:
DeÔ¨Ånition 5.1
A veriÔ¨Åable database scheme with updates
VDB D .Setup; Query; Verify; Update/ consists of four algorithms deÔ¨Åned below.
‚Ä¢ Setup.1k; DB/: On input the security parameter k, the setup algorithm is run by the client
to generate a secret key SK to be secretly stored by the client, a database encoding S that is
given to the server, and a public key PK that is distributed to all users (including the client
itself) for verifying the proofs.
‚Ä¢ Query.PK; S; x/: On input an index x, the query algorithm is run by the server, and returns
a pair  D .v; /.
‚Ä¢ Verify.PK/SK; x; /: ÓÄÄe public veriÔ¨Åcation algorithm outputs a value v if  is correct with
respect to x, and an error ? otherwise.
‚Ä¢ Update.SK; x; v0/: In the update algorithm, the client Ô¨Årstly generates a token t0
x with the
secret key SK and then sends the pair .t0
x; v0/ to the server. ÓÄÄen the server uses v0 to update
the database record in index x, and t0
x to update the public key PK.
ÓÄÄere are two diÔ¨Äerent kinds of veriÔ¨Åability for the outputs of the query algorithm, i.e.,
 D .v; /. In the Catalano-Fiore‚Äôs scheme [41], anyone can verify the validity of  with the public
key PK. ÓÄÄerefore, it satisÔ¨Åes the property of public veriÔ¨Åability. However, in some applications,
only the client can verify the proofs generated by the server since the secret key of the client is
involved in the veriÔ¨Åcation. ÓÄÄis is called private veriÔ¨Åability [18]. A veriÔ¨Åable database scheme
should support both types of veriÔ¨Åability for various applications.

5.1. SECURITY DEFINITIONS
47
5.1.1
SECURITY REQUIREMENTS
In the following, we introduce some security requirements for a VDB scheme. ÓÄÄe Ô¨Årst require-
ment is the security of a VDB scheme. Intuitively, a VDB scheme is secure if a malicious server
cannot convince a veriÔ¨Åer to accept an invalid output, i.e., v ¬§ vx where vx is the value of a
database record in the index x. Note that vx can be either the initial value given by the client
in the setup stage or the latest value assigned by the client in the update procedure. Benabbas,
Gennaro, and Vahlis [18] presented the following deÔ¨Ånition:
DeÔ¨Ånition 5.2
(Security) A VDB scheme is secure if for any database DB 2 ≈íq¬ç  f0; 1g, where
q D poly.k/, and for any probabilistic polynomial time (PPT) adversary A,
AdvA.VDB; DB; k/  negl.k/;
where AdvA.VDB; DB; k/ D Pr≈íExpVDB
A .DB; k/ D 1¬ç is deÔ¨Åned as the advantage of A in the ex-
periment as follows:
Experiment ExpVDB
A ≈íDB; k¬ç
.PK; SK/  Setup.DB; k/I
For i D 1; : : : ; l D poly.k/I
Verify query W
.xi; i/  A.PK; t0
1; : : : ; t0
i 1/I
vi  Verify.PK/SK; xi; i/I
Update query W
.xi; v.i/
xi /  A.PK; t0
1; : : : ; t0
i 1/I
t0
i  Update.SK; xi; v.i/
xi /I
. Ox; O/  A.PK; t0
1; : : : ; t0
l/I
Ov  Verify.PK/SK; Ox; O/
If Ov ¬§? and Ov ¬§ v.l/
Ox ; output 1I else output 0:
In the above experiment, after every update query, we implicitly assign PK  PKi. Note
that this property of security is similar to that of soundness in zero-knowledge proof.
ÓÄÄe second requirement is the correctness of a VDB scheme. ÓÄÄat is, the value and proof
generated by the honest server can always be veriÔ¨Åed successfully and accepted by the client (the
honest server results in valid results and proof). ÓÄÄis is similar to the property of completeness in
zero-knowledge proof.
DeÔ¨Ånition 5.3
(Correctness) A VDB scheme is correct if for any database DB 2 ≈íq¬ç  f0; 1g,
where q D poly.k/, and for any valid pair  D .v; / generated by an honest server, the output
of the veriÔ¨Åcation algorithm is always the value v.

48
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
ÓÄÄe third requirement is the eÔ¨Éciency of a VDB scheme. ÓÄÄat is, the client in the veriÔ¨Åable
database scheme should not be involved in much expensive computation and storage (except for
an initial pre-processing phase).‚Å∂
DeÔ¨Ånition 5.4
(EÔ¨Éciency) A VDB scheme is eÔ¨Écient if for any database DB 2 ≈íq¬ç  f0; 1g,
where q D poly.k/, the computation and storage resources invested by the client must be inde-
pendent of q.
ÓÄÄe last requirement is the accountability for a VDB scheme. ÓÄÄat is, after the client has
detected the tampering of dishonest server, he should provide some evidence to convince a judge
of the facts.
DeÔ¨Ånition 5.5
(Accountability) A VDB scheme is accountable if for any database DB 2 ≈íq¬ç 
f0; 1g, where q D poly.k/, the client can provide a proof if the dishonest server has tampered
with the database.
5.1.2
FORWARD AUTOMATIC/BACKWARD SUBSTITUTION UPDATE
ATTACK
In the following, we consider two attacks on VDB schemes. Basically, both of them violate the
Security and Accountability properties of VDB in the above deÔ¨Ånition.
ÓÄÄe Ô¨Årst attack is that an adversary A (i.e., the malicious server S) can perform the Update
algorithm in the same way as the client C. SpeciÔ¨Åcally, S Ô¨Årstly retrieves the current record vx
and then computes the token t
x (if the computation does not need any secret knowledge of C).
Finally, S updates the corresponding database record with any new value v
x, and the public key
PK with t
x . Trivially, S can generate a valid proof for any query based on PK. Besides, this
forward updated public key PK and the real one PK0 are totally computationally indistinguishable
from a viewpoint of any third party. ÓÄÄerefore, when a dispute occurs, a judge cannot deduce that
S is dishonest. We deÔ¨Åne this kind of adversary as Forward Automatic Update (FAU) attacker.
ÓÄÄe second attack on VDB schemes is not explicitly stated in previous literature. We call
it Backward Substitution Update (BSU) attack. ÓÄÄat is, the dishonest S can utilize the previous
(while valid) public key and the corresponding database to substitute the current ones (trivially,
this can also be viewed as an update). We argue that S in VDB has the ability to update the
public key freely. If this case happens, the eÔ¨Äort of the later update by C is no longer meaningful.
Furthermore, if C did not store the public key locally, it is diÔ¨Écult for him to distinguish the past
public key from the latest one. On the other hand, even if C has stored the latest public key, it
seems still to be diÔ¨Écult for him to prove the fact that the stored public key is the latest one.
‚Å∂In some scenarios, the client is allowed to invest a one-time expensive computational eÔ¨Äort. ÓÄÄis is known as the amortized
model of outsourcing computations [74].

5.2. VDB CONSTRUCTION FROM DELEGATING POLYNOMIAL FUNCTIONS
49
5.2
VDB CONSTRUCTION FROM DELEGATING
POLYNOMIAL FUNCTIONS
In this section, we introduce Benabbas-Gennaro-Vahlis VDB scheme from delegating high de-
gree polynomial functions. ÓÄÄis is the Ô¨Årst eÔ¨Écient VDB construction that relies on a ‚Äúconstant-
size‚Äù assumption (i.e., the subgroup member assumption).
5.2.1
DELEGATING OF POLYNOMIAL FUNCTIONS
Given a polynomial P.x/ D Pd
iD0 cixi, where ci 2 Zp. ÓÄÄe aim is to compute y D P.u/. ÓÄÄe
outsourcing protocol between C and S is given as follows:
Let R.x/ D Pd
iD0 rixi, where ri 2 Zp. C computes and then shares with S a vector t of
the group elements with the form gaciCri, where a 2R Zp is a random value which is only known
by C. Given the query u, S returns y D P.u/ and t D gaP.u/CR.u/. C accepts y iÔ¨Ät D gayCR.u/.
ÓÄÄe crucial point is how C can compute R.u/ eÔ¨Éciently. If R.x/ is a random polynomial,
then the computational overload of R.u/ is the same as that of P.u/. ÓÄÄe trick is that we can
use an algebraic PRF that has a closed form eÔ¨Écient computation for polynomials such that
gri D FK.i/, where K is a secret key of F . In this case, the security of the construction is not
compromised, while the closed form eÔ¨Éciency of F will allow C to verify the result eÔ¨Éciently.
In the following, we present a concrete protocol for delegating polynomials with a certain
algebraic PRF FK.i/ D gk0ki
1 (note that we could use any other algebraic PRF). DeÔ¨Åne R.x/ D
Pd
iD0 rixi D Pd
iD0 k0ki
1xi. ÓÄÄen, C can compute R.u/ eÔ¨Éciently for any u.
1. KeyGen: Given a security parameter k and the target function is P.x/ D Pd
iD0 cixi. Let G
be the range group of FK, and g be a generator of G. DeÔ¨Åne gi D FK.i/ D gk0ki
1. Choose
a random a 2R Zp and compute T D .t0; :::; td/ D .g0gac0; :::; gdgacd /. Output PK D
.T; P.x// and SK D .K; a/ D .k0; k1; a/.
2. ProbGen: Given the input u, output u D u and u D u.
3. Compute: Given the public key PK and the encoded input u, S computes h.u/ D
.1; u; : : : ; ud/ 2 ZdC1
p
, y D Pd
iD0 ciui, and t D Qd
iD0 tui
i . Output u D .y; t/.
4. Verify: C computes z D CFEvalh.u; K/ and accepts y iÔ¨Ät D zgay.
ÓÄÄe correctness of the protocol is due to the fact below:
z D CFEvalh.u; K/ D
d
Y
iD0
≈íFK.i/¬çui D
d
Y
iD0
gk0ki
1ui D
d
Y
iD0
griui D gR.u/
Note that this protocol does not ensure the privacy of the polynomials. ÓÄÄough the issue
could be solved by using an additively homomorphic encryption scheme, it still does not protect
the privacy of input u.

50
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
5.2.2
BENABBAS-GENNARO-VAHLIS VDB CONSTRUCTION
In this section, we introduce Benabbas-Gennaro-Vahlis‚Äôs VDB scheme in the setting of bilinear
groups of composite order. ÓÄÄe scheme consists of the following algorithms:
‚Ä¢ Setup: ÓÄÄe setup algorithm takes as input a security parameter n and an encrypted database
DB with the form of .i; vi/ 2 ≈íq¬ç  Zn 1. Trivially, we could use a hash function H W
f0; 1g ! Zn 1 to proceed a very large data record vi. It then generates the bilinear pairing
groups G, GT of order N D p1p2, where p1, p2 are primes in the range ≈í2n 1; 2n   1¬ç, and
a pairing e W G  G ! GT . Let G1 and G2 be subgroups of G of orders p and q, respec-
tively. Choose two PRF keys k1, k2 randomly, and choose randomly:
g1; h1 2R G1; g2; h2; u2 2R G2; a; b 2R ZN
For each i 2 f1; : : : ; qg, set ri D Fk1.i/; wi D Fk2.i; 1/, and si D 1. DeÔ¨Åne
ti D griCaviCbsi
1
gwi
2 ; w D
qP
iD1
wi; Tw  e.g2; u2/w.
Set Ot0 D u2 and Ot1 D h1h2. ÓÄÄe public key is PK D
 . Ot0; Ot1; s1; t1; : : : ; sq; tq/; DB
. ÓÄÄe pri-
vate key is SK D .a; Tw; k1; k2/.
‚Ä¢ Query: ÓÄÄe query processing algorithm takes as input the public key PK and an index
query x 2 f1;    ; qg, and then computes
T D e.tx; Ot1/  e

qQ
iD1;i¬§x
ti; Ot0

:
Output .T; y D vx; sx/.
‚Ä¢ Verify: ÓÄÄe veriÔ¨Åcation algorithm takes as input a private key SK, a query x, and .T; y; sx/.
ÓÄÄe veriÔ¨Åer then computes rx D Fk1.x/, wx D Fk2.x; sx/ and checks
T
‚ÄπD Tw  e.grxCayCbsx
1
g2; h1u wx
2
hwx
2 /
If the equality holds, the veriÔ¨Åer outputs 1. Otherwise, outputs ?.
‚Ä¢ Update: ÓÄÄe update algorithm takes as input a pair .x; y0/ 2 ≈ím¬ç  Zn 1. C Ô¨Årstly submits
x as a query to S, and veriÔ¨Åes the validity of triple .T; y; sx/. ÓÄÄen sets
w0
x D Fk2.x; sx C 1/   Fk2.x; sx/, Tw  Tw  e.gw0
x
2 ; u2/, and t0
x  ga.y0 y/Cb
1
gw0
x
2 :

5.3. VDB FRAMEWORK BASED ON VECTOR COMMITMENT
51
S is then given t0
x, and updates the public key by setting tx  tx  t0
x and sx  sx C 1.
ÓÄÄe correctness of the scheme follows from properties of bilinear maps over composite order
groups (that is, for any u 2 G1 and v 2 G2, we have e.u; v/ D 1GT ):
T D e.tx; Ot1/e. Q
i¬§x
ti; Ot0/ D e.grxCavxCbsx
1
gwx
2 ; h1h2/ Q
i¬§x
e.griCaviCbsi
1
gwi
2 ; u2/
D e.grxCavxCbsx
1
g2; h1u wx
2
hwx
2 / Q
i
e.griCaviCbsi
1
gwi
2 ; u2/
D e.grxCavxCbsx
1
g2; h1u wx
2
hwx
2 /  Tw
Note that delegating a polynomial is used as a building block in the above construction. ÓÄÄe
polynomial is deÔ¨Åned as P.x/ D vx for all 1  x  q. Nevertheless, S actually did not compute
the value of P.x/ for a query index x. ÓÄÄat is the reason why VDB is not outsourcing computation
but storage. Besides, C can reconstruct and verify the proof T by using a PRF F with closed form
eÔ¨Éciency.
In order to prevent the BSU attack, S should compute a signature on the tuples .i; Ti/,
where Ti is the latest counter for index i. C should store the tuples together with the signature
locally by himself and it is meaningless to store these values in the S side.
5.3
VDB FRAMEWORK BASED ON VECTOR
COMMITMENT
In 2013, Catalano and Fiore presented the second eÔ¨Écient construction for general VDB frame-
work using the primitive of vector commitment [41]. ÓÄÄe elegant construction is based on the
standard CDH assumption in bilinear groups. Besides, compared with the Ô¨Årst eÔ¨Écient VDB
construction, it can support both public veriÔ¨Åability and private veriÔ¨Åability.
In this section, we Ô¨Årst give an overview of their VDB general framework and then present
a security weakness of the construction [47].
5.3.1
THE GENERAL FRAMEWORK
ÓÄÄe main idea of Catalano-Fiore‚Äôs VDB framework is as follows: Let C be the vector commitment
on the database. Given a query on index x by the client C, the server S provides the value vx
and the opening of commitment as a proof that vx has not been tampered with. During the
update phase, C computes a new ciphertext v0
x and a token t0
x and then sends them to S. Finally,
S updates the database and the corresponding public key with the pair .t0
x; v0
x/. Formally, the
framework consists of the following algorithms:
‚Ä¢ Setup.1k; DB/: Let the database be DB D .i; vi/ for 1  i  q. Run the key generation al-
gorithm of vector commitment to obtain the public parameters PP  VC.KeyGen.1k; q/.

52
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
Run the committing algorithm to compute the commitment and auxiliary information
.C; aux/  VC.ComPP.v1;    ; vq/. DeÔ¨Åne PK D .PP; C/ as the public key of VDB scheme,
S D .PP; aux; DB/ as the database encoding, and SK D = as the secret key of C.
‚Ä¢ Query.PK; S; x/: On input an index x, S Ô¨Årstly runs the opening algorithm to compute
x  VC.OpenPP.vx; x; aux/ and then returns  D .vx; x/.
‚Ä¢ Verify.PK; x; /: Parse the proofs  D .vx; x/. If VC.VerPP.C; x; vx; x/ D 1, then return
vx. Otherwise, return an error ?.
‚Ä¢ Update.SK; x; v0/: To update the record of index x, C Ô¨Årstly retrieves the current record vx
from S. ÓÄÄat is, C obtains   Query.PK; S; x/ from S and checks that Verify.PK; x; / D
vx ¬§?. Also, C computes .C0; U/  VC.UpdatePP.C; vx; x; v0
x/ and outputs PK0 D .PP; C0/
and t0
x D .PK0; v0
x; U/. ÓÄÄen S uses v0
x to update the database record of index x, PK0 to update
the public key, and U to update the auxiliary information.
5.3.2
SECURITY ANALYSIS
In this section, we present a security analysis of Catalano-Fiore‚Äôs VDB general framework and
show the framework suÔ¨Äers from both the FAU and BSU attack [47].
Firstly, we argue that Catalano-Fiore‚Äôs VDB framework suÔ¨Äers from the FAU attack. ÓÄÄe
main reason is that the secret key in Catalano-Fiore‚Äôs VDB construction is assumed to be empty,
i.e., SK D =. As a result, anyone can verify the validity of output  and thus the construction
supports the public veriÔ¨Åability. However, this also allows the adversary A to update the database
in an indistinguishable manner as the client since no secret information is required in the update
algorithm.‚Å∑ Besides, it is more diÔ¨Écult for the third party to detect the FAU attack than the
client. ÓÄÄerefore, VDB schemes that support the public veriÔ¨Åability are more vulnerable to the
FAU attack in the real-world applications. In the following, we present the formal proof that
Catalano-Fiore‚Äôs framework violates the security deÔ¨Ånition of VDB.
ÓÄÄeorem 5.6
Catalano-Fiore‚Äôs VDB framework does not satisfy the property of security.
Proof. A VDB scheme does not satisfy the property of security means that the adversary A (i.e.,
the dishonest server) can successfully simulate the experiment ExpVDB
A ≈íDB; k¬ç and win the game
with a non-negligible probability. In Catalano-Fiore‚Äôs VDB framework, the secret key is assumed
to be empty, i.e., SK D ?. ÓÄÄerefore, the adversary A can perform the algorithm Update freely.
Our main trick is that we require A to perform an additional round of Update after Ô¨Ånishing l
rounds of Update queries of the client. However, in the last round of Update, A also plays the
role of client. More precisely, the simulated experiment Exp0VDB
A ≈íDB; k¬ç is deÔ¨Åned as follows:
‚Å∑Note that the construction [18] only supports the private veriÔ¨Åability since the (non-empty) secret key SK is involved in the
veriÔ¨Åcation. Besides, SK is also involved in the update algorithm and hence only the client can update the database.

5.3. VDB FRAMEWORK BASED ON VECTOR COMMITMENT
53
Experiment Exp0VDB
A ≈íDB; k¬ç
.PK; ?/  Setup.DB; k/I
For i D 1; : : : ; l C 1I where l D poly.k/I
Verify query W
.xi; i/  A.PK; t0
1; : : : ; t0
i 1/I
vi  Verify.PK=?; xi; i/I
Update query W
.xi; v.i/
xi /  A.PK; t0
1; : : : ; t0
i 1/I
t0
i  Update.?; xi; v.i/
xi /I
. Ox; O/  A.PK; t0
1; : : : ; t0
lC1/I
Ov  Verify.PK=?; Ox; O/
Since we implicitly assign PK  PKi after every update query in the experiment, the Ô¨Å-
nal public key PK D PKlC1. ÓÄÄen, let Ov D v.lC1/
Ox
. Trivially, Ov ¬§? and Ov ¬§ v.l/
Ox . ÓÄÄis violates the
security deÔ¨Ånition of the VDB scheme.

Secondly, Catalano-Fiore‚Äôs framework also suÔ¨Äers from the BSU attack since the veriÔ¨Å-
cation only requires the public key stored by the server. Besides, it certainly does not satisfy the
property of accountability. Fortunately, we could provide a straightforward eÔ¨Äective solution to
the BSU attack. ÓÄÄe trick is as follows: we still need a counter T in the public key to denote the
number of updates. ÓÄÄe diÔ¨Äerence is that the server computes a signature  on the latest counter
Tl and the identity IDc of the client. Given a past public key with the counter Tp, the client
provides the pair .; Tl/ to the judge as a proof. If  is valid and Tp < Tl, the judge claims that
the server is dishonest. Trivially, the storage workload of the client is only the latest pair .; Tl/
(not all signatures for every counters). ÓÄÄerefore, we will not consider the BSU attack anymore
in the remainder of this book.
Remark 5. It seems that there are two naive approaches against FAU attack for Catalano-Fiore‚Äôs
VDB framework. ÓÄÄe Ô¨Årst solution is that we can require the server to compute a signature on
the (updated) public key. However, we argue that this solution does not work since the dishonest
server is an inherent FAU attacker in Catalano-Fiore‚Äôs VDB framework (the server has the ability
to compute the signature on any public key). ÓÄÄe second one is that the client computes a signature
on the (updated) public key. Obviously, the server cannot forge the client‚Äôs signature. However,
it requires that the client must have a mechanism to revoke the previous signatures (surprisingly,
it reverted to the same problem of VDB). ÓÄÄerefore, neither of the two approaches can solve the
security issue of Catalano-Fiore‚Äôs constructions.
Remark 6. Note that Benabbas-Gennaro-Vahlis‚Äôs scheme [18] does not suÔ¨Äer from BSU attack
since the secret key of the client is updated each time. Without loss of generality, assume that
the latest secret key of the client is SKl. When the dishonest server presents a previous public key
PKp including a counter Tp and the corresponding database DBp, it is trivial that the output of

54
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
query algorithm by the server cannot pass the veriÔ¨Åcation with the secret key SKl. As a result, the
tampering will be detected by the client. However, this cannot be viewed as a proof even if the
client presents his secret key to a judge. ÓÄÄe reason is that a malicious client also has the ability to
frame an honest server. ÓÄÄat is, the malicious client can present a random value as the secret key to
invalidate the veriÔ¨Åcation on the output of an honest server. ÓÄÄus, the judge cannot deduce who
is dishonest when a dispute occurred. In this sense, we argue that Benabbas-Gennaro-Vahlis‚Äôs
scheme does not satisfy the property of accountability (this also indicates that accountability is a
stronger notion than security). In order to achieve the accountability, the client should store the
latest counter and the corresponding signature as we mentioned in the above solution to the BSU
attack (we argue again that it is not suÔ¨Écient only to store these values in the server‚Äôs side as in
[18]).
5.4
VDB FRAMEWORK FROM BINDING VECTOR
COMMITMENT
In this section, we introduce Chen et al‚Äôs new VDB scheme [47], which is not only public veriÔ¨Åable
but also secure under the FAU attack. ÓÄÄe main trick is as follows.
As stated above, the main reason that Catalano-Fiore‚Äôs framework suÔ¨Äers from the FAU
attack is that the secret key SK of the client is not involved in the computation and update of
the public key PK (actually, SK is assumed to be ?). ÓÄÄis will enable the adversary (especially the
dishonest server) to update PK freely. Note that PK D .PP; C0/ and the public parameters PP of
vector commitment is never updated. ÓÄÄat is, the public parameters are generated and published
by a trusted party [67]. ÓÄÄus, the server can update the vector commitment C0 at its own will and
this equals to update the databases. We argue that it is meaningless if we add a signature of the
server on C0 to PK since the server can compute such a signature on any message. On the other
hand, if we use SK to compute the updated public key PK (more precisely, the commitment C0) just
as in the scheme [18], the proposed VDB scheme might no longer support the property of public
veriÔ¨Åability. ÓÄÄe main reason is that the secret key SK might be also involved in the veriÔ¨Åcation of
C and the corresponding proofs (i.e., the openings of C). ÓÄÄat is, only the client with SK can verify
the validity of the proofs. ÓÄÄerefore, it seems to be contradictory to construct a VDB scheme that
is public veriÔ¨Åable and secure under the FAU attack simultaneously.
We utilize the idea of commitment binding to solve this problem. ÓÄÄat is, the client uses
the secret key SK to compute a signature on some binding information which will be explained
later. Also, the signature is used to compute the updated commitment C0. Since the signature is
diÔ¨Äerent for each updating, the server cannot compute a new C0 without the cooperation of client.
Also, we emphasize that the secret key SK is never used in the veriÔ¨Åcation algorithm, but only
used in the update algorithm.
ÓÄÄe binding information consists of the last public key CT  1 (a commitment value), the
commitment C.T / on the current database vector, and the current counter T . Assume that the sig-
nature of client on binding information is HT D SÔù©ÔùßÔùÆsk.CT  1; C.T /; T /, then the current public

5.4. VDB FRAMEWORK FROM BINDING VECTOR COMMITMENT
55
key CT D HT C.T /. So, the solution binds the commitment CT to the 3-tuple .CT  1; C.T /; T / in
a recursion manner as shown in Fig. 5.1. As a result, the adversary that includes the server cannot
update the database and public key freely.
CT  =  HTC(T)  =  SIGNSK    (CT‚Äì1, C(T),T )   C(T)
Figure 5.1: Commitment binding.
Chen et al.‚Äôs new proposed VDB framework is given as follows.
‚Ä¢ Setup.1k; DB/: Let the database be DB D .i; vi/ for 1  i  q. Let VC be any secure vector
commitment scheme. Run the key generation algorithm of vector commitment to obtain the
public parameters PP  VC.KeyGen.1k; q/. Run the committing algorithm to compute the
commitment and auxiliary information .CR; aux/  VC.ComPP.v1;    ; vq/. Let .sk; pk/ be
the secret/public key pair of the client C. Let SÔù©ÔùßÔùÆbe a provably secure digital signature
scheme. Let T be a counter with the initial value 0. Let C.T / D VC.ComPP.v.T /
1
;    ; v.T /
q
/
be the commitment on the latest database vector after the original database DB has been
updated T times. Trivially, C.0/ D CR. Specially, let C 1 D CR. ÓÄÄe client C computes and
sends the signature H0 D SÔù©ÔùßÔùÆsk.C 1; C.0/; 0/ to the server S. If H0 is valid, then S com-
putes C0 D H0C.0/. Also, S adds the information of Àô0 D .H0; C 1; C.0/; 0/ to aux.
Set PK D .PP; pk; CR; C0/ as the public key of the VDB scheme, S D .PP; aux; DB/ as the
database encoding, and SK D sk as the secret key of C.
‚Ä¢ Query.PK; S; x/: Assume that the current public key PK D .PP; pk; CR; CT /. On input an
index x, S runs the opening algorithm to compute x  VC.OpenPP.vx; x; aux/ and returns
 D .vx; x; ÀôT /, where ÀôT D .HT ; CT  1; C.T /; T /.
‚Ä¢ Verify.PK; x; /: Parse  D .vx; x; ÀôT /. If Verpk.ÀôT / D 1 (this means that HT is a valid
signature of C on message .CT  1; C.T /; T /) and VC.VerPP.CT ; HT ; x; vx; x/ D 1, then re-
turn vx. Otherwise, return an error ?.
‚Ä¢ Update.SK; x; v0
x/: To update the record of index x, C Ô¨Årstly retrieves the current record
vx from S as in the above Verify algorithm. ÓÄÄat is, C Ô¨Årstly obtains   Query.PK; S; x/

56
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
from S and then checks that Verify.PK; x; / D vx ¬§?. Set T  T C 1, C Ô¨Årstly computes
C.T / D VC.ComPP.v.T /
1
;    ; v.T /
q
/ and t0
x D HT D SÔù©ÔùßÔùÆsk.CT  1; C.T /; T /, and then sends
.t0
x; v0
x/ to S. If t0
x is valid, then S computes CT D HT C.T / and updates the public key
PK D .PP; pk; CR; CT / (note that only the value of CT needs to be updated). Also, S uses
the value of v0
x to update the database record of index x, i.e., DB.x/  v0
x. Finally, S adds
the information of ÀôT D .HT ; CT  1; C.T /; T / to aux in S.
5.4.1
A CONCRETE VDB SCHEME
In this section, we introduce a concrete VDB scheme from the vector commitments based on the
CDH assumption [47].
‚Ä¢ Setup.1k; DB/: Let k be a security parameter. Let the database be DB D .x; vx/ for 1  x 
q. Let G1 and G2 be two cyclic multiplicative groups of prime order p equipped with a bilin-
ear pairing e W G1  G1 ! G2. Let g be a generator of G1. Let H W G1  G1  f0; 1g !
G1 be a cryptographic hash function. Randomly choose q elements zi 2R Zp and compute
hi D gzi, hi;j D gzizj , where 1  i; j  q and i ¬§ j.
Set PP D .p; q; G1; G2; H; e; g; fhig1iq; fhi;j g1i;j q;i¬§j /, and the message space M D
Zp. C randomly selects an element y 2R Zp and then computes Y D gy.
Let CR D Qq
iD1 hvi
i
be the root commitment on the database vector .v1; v2;    ; vq/. Let
T be a counter with the initial value 0. Let C.T / be the commitment on the latest database
vector after the original database DB has been updated T times. Trivially, C.0/ D CR. Spe-
cially, let C 1 D CR. C computes and sends H0 D H.C 1; C.0/; 0/y to S. If the equation
e.H0; g/ D e.H.C 1; C.0/; 0/; Y / holds (that means H0 is a valid signature of C), then S
computes C0 D H0C.0/. Also, S adds the information of .H0; C 1; C.0/; 0/ to aux.
Set PK D .PP; Y; CR; C0/, S D .PP; aux; DB/ and SK D y.
‚Ä¢ Query.PK; S; x/: Assume that the current public key PK D .PP; Y; CR; CT /. Given a query
index x, S computes .T /
x
D Q
1j q;j ¬§x h
v.T /
j
x;j and returns the proofs
 D .v.T /
x
; .T /
x
; HT ; CT  1; C.T /; T /:
‚Ä¢ Verify.PK; x; /: Parse the proofs  D .v.T /
x
; .T /
x
; HT ; CT  1; C.T /; T /. ÓÄÄen anyone (in-
cluding the client) can verify the validity of the proofs  by checking whether the following
two equations e.HT ; g/ D e.H.CT  1; C.T /; T /; Y / and e.CT =HT hv.T /
x
x
; hx/ D e..T /
x
; g/
hold.‚Å∏ If the proofs  is valid, the veriÔ¨Åer accepts it and outputs v.T /
x
. Otherwise, outputs
an error ?.
‚Å∏If the veriÔ¨Åer is client, then he needs only to check whether HT D H.CT  1; C.T /; T /y holds in order to decrease the
computation overload.

5.4. VDB FRAMEWORK FROM BINDING VECTOR COMMITMENT
57
‚Ä¢ Update.SK; x; v0
x/: To update the record of index x, C Ô¨Årstly retrieves the current record vx
from S. ÓÄÄat is, C obtains   Query.PK; S; x/ from S and checks that Verify.PK; x; / D
vx ¬§?.
Set
T  T C 1,
C
Ô¨Årstly
computes
C .T / D
CT  1
HT  1 hv0
x vx
x
and
t0
x D HT D
H.CT  1; C.T /; T /y, and then sends .t0
x; v0
x/ to S. If t0
x is valid, then S computes
CT D HT C.T / and updates the public key with PK D .PP; Y; CR; CT /. Also, S uses the
value of v0
x to update the database record of index x, i.e., DB.x/  v0
x. Finally, S adds the
information of .t0
x D HT ; CT  1; C.T /; T / to aux in S.
5.4.2
SECURITY ANALYSIS OF THE VDB SCHEME
In this section, we present the security analysis of the above VDB scheme.
ÓÄÄeorem 5.7
ÓÅêe proposed VDB scheme achieves the property of security.
Proof. Similar to [41], we can prove the theorem by contradiction. Assume there exists
a polynomial-time adversary A that has a non-negligible advantage  in the experiment
ExpVDB
A ≈íDB; k¬ç for some initial database DB, then we can use A to build an eÔ¨Écient algorithm
B to break the Squ-CDH assumption. ÓÄÄat is, B takes as input a tuple .g; ga/ and outputs ga2.
First, B randomly chooses an element x 2R Zq as a guess for the index x on which A
succeeds in the experiment ExpVDB
A ≈íDB; k¬ç. ÓÄÄen B randomly chooses zi 2R Zp and computes
hi D gzi all 1  i ¬§ x  q. Let hx D ga. Besides, B computes:
hi;j D gzizj for all 1  i ¬§ j  q and i; j ¬§ x;
hi;x D hx;i D .ga/zi for all 1  i  q and i ¬§ x.
Set PP D .p; q; G1; G2; H; e; g; fhig; fhi;j g/, where 1  i ¬§ j  q. ÓÄÄen B randomly se-
lects an element y 2R Zp and computes Y D gy. Given a database DB, B computes the com-
mitment CR D Qq
iD1 hvi
i . Also, B computes H0 D H.CR; CR; 0/y and C0 D H0CR. DeÔ¨Åne
PK D .PP; Y; CR; C0/, S D .PP; aux; DB/ and SK D y. B sends PK to A. Note that PK and S are
perfectly distributed as the real ones.
To answer the verify and update queries of A in the experiment, B just simply runs the real
Query.PK; S; x/ and Update.SK; x; v0
x/ algorithms and responds with the same value. Note that
the Update.SK; x; v0
x/ algorithm requires the secret key y of B, and A cannot perform this algo-
rithm without the help of B. ÓÄÄerefore, the FAU attack is no longer successful in the experiment
Exp0VDB
A ≈íDB; k¬ç.
Suppose that . Ox; O/ be the tuple returned by A at the end of the experiment, where O D
.Ov; O; Àôl/. Besides, note that if A wins with a non-negligible advantage  in the experiment, then
we have Ov ¬§?, Ov ¬§ v.l/
Ox and e.C.l/; h Ox/ D e.h
v.l/
Ox
Ox
; h Ox/e..l/
Ox ; g/ D e.h Ov
Ox; h Ox/e. O; g/.
If Ox ¬§ x, B aborts the simulation and fails. Otherwise, we have h Ox D ga. Trivially, B can
compute
ga2 D . O=.l/
Ox /.v.l/
Ox   Ov/ 1:

58
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
ÓÄÄe success probability of B is =q.

ÓÄÄeorem 5.8
ÓÅêe proposed VDB scheme achieves the property of correctness.
Proof. If the server is assumed to be honest in the VDB scheme, then the proofs  D
.v.T /
x
; .T /
x
; HT ; CT  1; C.T /; T /, where .T /
x
D Q
1j q;j ¬§x h
v.T /
j
x;j . Firstly, note that HT D
H.CT  1; C.T /; T /y, therefore we have e.HT ; g/ D e.H.CT  1; C.T /; T /; Y/. Secondly, due
to CT =HT hv.T /
x
x
D C.T /=hv.T /
x
x
D Q
1jq;j ¬§x h
v.T /
j
j
, we have e.CT =HT hv.T /
x
x
; hx/ D e..T /
x
; g/.
Hence, the output of the veriÔ¨Åcation algorithm is always the value v.T /
x
.

ÓÄÄeorem 5.9
ÓÅêe proposed VDB scheme achieves the property of eÔ¨Éciency.
Proof. It is trivial that the computational resources invested by the client in the VDB scheme is
independent of q (except for a one-time Setup phase).

ÓÄÄeorem 5.10
ÓÅêe proposed VDB scheme achieves the property of accountability.
Proof. Given the proofs  with the counter T , the client Ô¨Årstly compares it with the latest counter
Tc he stored. If T < Tc, then the client sends the corresponding signature  on Tc to the judge
as the proof. Otherwise, he sends  to the judge as the proof since the veriÔ¨Åcation of  will fail if
the server has tampered with the database.

5.5
INCREMENTAL VDB FRAMEWORK
Chen et al. [52] Ô¨Årst introduced a new notion named VDB with incremental updates (Inc-VDB,
for short), means that re-computing and updating the ciphertext in VDB are both incremental
algorithms, i.e., the client can eÔ¨Éciently perform both operations with previous values, rather
than from scratch. ÓÄÄe motivation is that the database undergoes frequent while small updates
in some scenarios. For example, one anti-virus company outsources its virus database to a cloud
server. Also, the company must add the newly discovered viruses to the database everyday. Gen-
erally, the daily newly discovered viruses are a very tiny part of whole database and almost all
parts of the database remain unchanged. However, the company is still required to re-compute
and update the whole ciphertext everyday (note that the ciphertext is totally diÔ¨Äerent even if the
plaintext is modiÔ¨Åed only 1 bit for almost all provable secure encryption schemes). For a very
large database, it is extremely expensive for the resources-constrained client to re-compute and
update the ciphertext from scratch each time.
ÓÄÄe notion of incremental encryption [15, 16] seems a naive solution for Inc-VDB scheme.
For example, if a single block of the data is modiÔ¨Åed (we can view the data as a sequence of blocks),
the client only needs to re-compute the ciphertext on this certain block and the ciphertext of other

5.5. INCREMENTAL VDB FRAMEWORK
59
blocks remains identical [19, 101]. Nevertheless, this incremental encryption method does not
provide a full solution for constructing eÔ¨Écient Inc-VDB schemes. ÓÄÄe reasons are two-fold:
Firstly, previous incremental encryption schemes cannot solve the case of distributed updates on
the data. ÓÄÄat is, multiple blocks of the plaintext are modiÔ¨Åed while the modiÔ¨Åcation on each
single block is very small. ÓÄÄe worst case is that every block of the plaintext is updated while
only one bit for each single block is changed. If this case happens, the client must re-compute
the whole ciphertext from scratch. Secondly, previous incremental encryption schemes cannot
necessarily lead to incremental updates on VDB. ÓÄÄat is, the update algorithm of VDB is not
incremental and the client still needs to re-compute a new updated token from scratch each time.
Chen et al. [52] proposed a new incremental encryption based on the bit Ô¨Çipping oper-
ation and then presented an eÔ¨Écient Inc-VDB framework from vector commitment and the
incremental encrypt-then-MAC mode of encryption.
5.5.1
INCREMENTAL ENCRYPTION BASED ON BIT FLIPPING
ÓÄÄe proposed incremental encryption based on bit Ô¨Çipping is a main building block to construct
Inc-VDB schemes. Actually, it is a general mechanism for converting any provable secure encryp-
tion scheme into an incremental one. ÓÄÄe construction Àò D .KG; ENC; DEC; Inc-ENC; Inc-DEC/ is
given as follows:
‚Ä¢ KG: On input the security parameter k, the key generation algorithm outputs the se-
cret/public key pair .SK; PK/. Without loss of generality, let Àò0 D .KG; ENC; DEC/ be any
IND-CCA secure (symmetric or asymmetric) encryption scheme and the key is implicit
in the notation for simplicity. Trivially, the public key PK is an empty string if Àò0 is a
symmetric scheme.
‚Ä¢ ENC: On input a message m, the encryption algorithm outputs a ciphertext c D ENC.m/.
‚Ä¢ DEC: On input the ciphertext c, the decryption algorithm outputs the message m D DEC.c/.
‚Ä¢ Inc-ENC: On input a slightly modiÔ¨Åed message m0, the original message m, and the ciphertext
c on m, the incremental encryption algorithm outputs the (incremental) ciphertext c0 D
Inc-ENC.m0; c; m/ D .c; P /, where P D .p1; p2;    ; p!/ denotes the bit positions where
m0 and m have diÔ¨Äerent values, i.e., m≈ípi¬ç ¬§ m≈ípi¬ç for 1  i  !.
‚Ä¢ Inc-DEC: On input the ciphertext c0 D .c; P /, the incremental decryption algorithm outputs
the message m0. Trivially, it Ô¨Årstly decrypts c to obtain m and then performs the bit Ô¨Çipping
operation on the location pi (1  i  !) of m.
In the following, we present the formal security proof of our construction.
ÓÄÄeorem 5.11
If Àò0 is an IND-CCA secure (symmetric or asymmetric) encryption scheme, then Àò
is also an IND-CCA secure encryption scheme.

60
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
Proof. We prove by contradiction. Assume that there exists a polynomial time IND-CCA adver-
sary A can successfully attack the scheme Àò with a non-negligible probability  in time T , then
we can construct another polynomial time IND-CCA adversary A0 that uses A as a subroutine
to attack the scheme Àò0. Without loss of generality, we assume that A can make at most q1 C q2
decryption queries.
Let c0
i D .ci; Pi/ be a decryption query issued by A.Trivially, A0 can relay the partial de-
cryption query ci to the challenger C in Àò0. Suppose the response of C is mi, A0 performs the
bit Ô¨Çipping operation on the location Pi of mi to obtain m0
i. ÓÄÄen A0 responds m0
i to the query
c0
i of A.
After issuing q1 decryption queries, A chooses two distinct (challenge) messages (m0
0, m0
1)
and sends them to A0. Similarly, A0 can compute two corresponding (challenge) messages (m0,
m1) for scheme Àò0, where mb (b 2 f0; 1g) is obtained by performing the bit Ô¨Çipping operation
on the location P of m0
b and P is some bit positions randomly chosen by A0.
Let the challenge ciphertext by C be c D ENC.mb/. Trivially, A0 can compute the corre-
sponding challenge ciphertext c0 D .c; P/ for A. ÓÄÄen A can issue further q2 decryption queries
except c0 and A0 responds in the same way as above.
Finally, A outputs its guess b0 2 f0; 1g. ÓÄÄen A0 can replay b0 as its guess in the scheme
Àò0. Trivially, the success probability of A0 is also .

As pointed out in [16], incremental encryption leaks some information that is kept secret
when using a traditional encryption scheme. In the proposed incremental encryption scheme
Inc-ENC, an adversary can determine where a modiÔ¨Åcation takes place, but still cannot determine
the symbol being modiÔ¨Åed (i.e., hide details about the data record m and m0). ÓÄÄis is similar to
previous incremental encryptions [16, 19, 101]. In order to achieve stronger privacy, it should also
encrypt the modiÔ¨Åed location information P . ÓÄÄat is, Inc-ENC.m0/ D .ENC.m/; ENC.P //. On the
other hand, though we only focus on the bit Ô¨Çipping operation in our construction, it can be
extended to other operations such as insertion, deletion, etc.
On the other hand, we present a method to represent the ciphertext eÔ¨Éciently. Suppose the
ciphertext is .ENC.m/; P1;    ; Pl/ after performing l rounds of update. We give the following
recursive deÔ¨Ånition if we view Pj as a set:
NP1 D P1;
NPj C1 D NPj Àö Pj C1 D . NPj   PjC1/ [ .Pj C1   NPj /:
As a result, the ciphertext is now .ENC.m/; NPl/ (or .ENC.m/; ENC. NPl// to enhance the privacy).
ÓÄÄis ensures deletion of the identical positions information of Pj (thus no bit Ô¨Çipping operation
is required in these positions) and the ciphertext is also shortened.

5.5. INCREMENTAL VDB FRAMEWORK
61
5.5.2
INC-VDB FRAMEWORK
Chen et al. [52] introduced the Inc-VDB framework by incorporating the primitive of vector
commitment and the encrypt-then-incremental MAC mode of encryption. ÓÄÄe main trick is
two-fold:
Firstly, the framework uses the above incremental encryption to generate the updated ci-
phertext v0
x. More precisely, deÔ¨Åne v0
x D .vx; Px/, where Px D .p1; p2;    ; p!/ denotes the bit
positions where m0
x and mx have diÔ¨Äerent values, i.e, m0
x≈ípi¬ç ¬§ mx≈ípi¬ç for 1  i  !. Trivially,
given v0
x D .vx; Px/, the client Ô¨Årstly decrypts vx to obtain mx, and then performs the bit Ô¨Çip-
ping operation on the positions of Px to obtain m0
x. Since the bit Ô¨Çipping operation is extremely
fast, the computation overhead of decrypting v0
x is almost the same as that of decrypting vx.
Moreover, it requires much less storage since jPxj << jv0
xj (note that we only consider the case
of incremental updates).
Secondly, the framework utilizes the encrypt-then-incremental MAC mode of encryption
[19], i.e., an incremental encryption together with an incremental MAC of the ciphertext (the
encrypt-then-MAC approach [29]), to generate the updated token t0
x. Also, it uses an incremental
version of the BLS signature scheme [27] to substitute the incremental MAC. For every update,
the client Ô¨Årst veriÔ¨Åes the current BLS signature on the commitment CR and all the current
modiÔ¨Åcations .P .1/
x ;    ; P .T /
x
/ of the data record vx, where P .i/
x
denotes the modiÔ¨Åcation in
the i-th update for 1  i  T . ÓÄÄis ensures that the current database is not tampered with by
the server.‚Åπ If the veriÔ¨Åcation holds, the client then sends a new modiÔ¨Åcation P .T C1/
x
and the
corresponding (incremental) BLS signature to the server.
Since the framework also uses the signature to achieve the integrity of the database, it is
essential to invoke the previous signatures given to the server. ÓÄÄe trick is that the server computes
a BLS signature  on all counters Tx for 1  x  q, where Tx denotes the update number of each
index x. After an update on the record vx is accomplished, let Tx  Tx C 1. ÓÄÄen the server
computes an incremental BLS signature on the updated counters (note that only the value of Tx
is slightly modiÔ¨Åed). Given a previous signature  on the count Tx, the client can reject it by
providing a new signature 0 on the latest counter T 0
x since Tx < T 0
x. Note that the server cannot
deny his signature, therefore this is a proof that the server is dishonest when a dispute occurred.
Note that the paradigm by incorporating the primitive of vector commitment and the
encrypt-then-incremental MAC mode of encryption actually provides a general framework for
constructing Inc-VDB schemes. ÓÄÄat is, if we use diÔ¨Äerent vector commitment schemes and
incremental encryption/signature schemes, we can obtain various constructions for Inc-VDB
schemes.
‚ÅπBellare, Goldreich, and Goldwasser pointed out that some incremental signature schemes may suÔ¨Äer from the so-called
substitution attack in some scenarios. However, it assumed that the adversary can successfully tamper with the data and
the signer does not check the corresponding signatures. Obviously, the attack does not work in our scheme.

62
5. SECURE OUTSOURCING OF LARGE DATABASE WITH UPDATES
5.5.3
A CONCRETE INC-VDB SCHEME
In this section, we introduce a concrete Inc-VDB scheme based on the CDH assumption [52].
‚Ä¢ Setup.1k; DB/: Let k be a security parameter. Let the database be DB D .x; vx/ for
1  x  q. Let G1 and G2 be two cyclic multiplicative groups of prime order p
equipped with a bilinear pairing e W G1  G1 ! G2. Let g be a generator of G1. Let
H W G1  f0; 1g ! G1 be a cryptographic hash function. Randomly choose q elements
zi 2R Zp and compute hi D gzi, hi;j D gzizj , where 1  i; j  q and i ¬§ j. Set PP D
.p; q; G1; G2; H; e; g; fhig1iq; fhi;j g1i;j q;i¬§j /, and the message space M D Zp.¬π‚Å∞
Let .Àõ; Y D gÀõ/ and .Àá; Z D gÀá/ be the secret/public key pair of the client C and server S,
respectively, where Àõ; Àá 2R Z
p. Trivially, the validity of Y and Z are ensured by the corre-
sponding certiÔ¨Åcate of a trusted third party, i.e, certiÔ¨Åcate authority. Let CR D Qq
iD1 hvi
i
be the root commitment on the database record vector .v1; v2;    ; vq/. For 1  x  q, let
Tx be a counter for index x with the initial value 0 and H .0/
x
D H.CR; x; 0/Àõ. S can use
the batch veriÔ¨Åcation technique of BLS signatures [43] to ensure the validity of H .0/
x
for
1  x  q, which requires only the workload of two pairings. ÓÄÄen S computes a signature
 D H.CR; 0; 0;    ; 0/Àá on CR and all initial counters .0; 0;    ; 0/ (note that all Tx has an
initial value 0). Also, set aux D faux1;    ; auxqg, where auxx D .H .0/
x ; 0/ for 1  x  q.
DeÔ¨Åne PK D .PP; CR; aux; DB/ and SK D Àõ.
‚Ä¢ Query.PK; x/: Assume that the current public key PK D .PP; CR; aux; DB/. Given a query
index x, S computes x D Q
1j q;j ¬§x h
vj
x;j and returns the proofs
 D .vx; x; H .Tx/
x
; P .1/
x ;    ; P .Tx/
x
; Tx/:
Note that the proof x D Q
1j q;j ¬§x h
vj
x;j is always identical for all queries to the same
index x. ÓÄÄerefore, S only needs to compute x once for the Ô¨Årst query on index x (this is
diÔ¨Äerent from the scheme [41]). Trivially, S requires much less computational overhead for
the query algorithms.
‚Ä¢ Verify.PK; x; /: Parse the proofs  D .vx; x; H .Tx/
x
; P .1/
x ;    ; P .Tx/
x
; Tx/. If the counter Tx
in  is less than the one in  that C stored locally, C rejects the proofs . Otherwise, C can
verify the validity of  by checking whether the following two equations e.CR=hvx
x ; hx/ D
e.x; g/ and e.H .Tx/
x
; g/ D e.H.CR; x; P .1/
x ;    ; P .Tx/
x
; Tx/; Y/ hold. If the proofs  are
valid, C accepts them and outputs v.Tx/
x
D .vx; P .1/
x ;    ; P .Tx/
x
/. Otherwise, outputs an
error ?.
‚Ä¢ Inc-Update.SK; x; P .TxC1/
x
/: To update the record of index x, C Ô¨Årstly retrieves the cur-
rent record v.Tx/
x
from S. ÓÄÄat is, C obtains   Query.PK; x/ from S and checks that
¬π‚Å∞ÓÄÄough the message space M in this construction is Zp, it can be easily extended to support possibly large payload vi by
using a collision-resistant hash function H W f0; 1g ! Zp.

5.5. INCREMENTAL VDB FRAMEWORK
63
Verify.PK; x; / D v.Tx/
x
¬§?. ÓÄÄen C computes the incremental signature
t0
x D H .TxC1/
x
D H.CR; x; P .1/
x ;    ; P .TxC1/
x
; Tx C 1/Àõ
and then sends .t0
x; P .TxC1/
x
/ to S. If t0
x is valid, then S adds P .TxC1/
x
to the record of index
x, and updates auxx in PK, i.e., auxx  .t0
x; P .1/
x ;    ; P .TxC1/
x
; Tx C 1/. Also, S computes
an updated incremental signature  D H.CR; T1; T2;    ; Tx C 1;    ; Tq/Àá and sends it to
C. If  is valid, C updates it together with Tx C 1 locally. Finally, set Tx  Tx C 1.
Remark 7. ÓÄÄe storage overhead of the client in our construction is all counters Tx and the latest
BLS signature . Note that the number of Tx is dependent on q, we estimate the storage overload
of client for very large q.
Assume that q D 108 and the counter Tx for each index x is 106 (that is, the database has
108 records and for each index x it has been updated 1 million times). ÓÄÄis means that the total
number of update for the database is 106108 (this is a giant updates number in real applications).
However, the storage of the client is only about 7  108 bits (less that 700 M). It is still tolerable
even for a resource-limited client.
In the following, a new solution is given in order to further reduce the storage overload of
the client. ÓÄÄe trick is to still use vector commitment. ÓÄÄe server computes the signature  D
H.CR; CT /Àá, where CT is the vector commitment on all counters .T1; T2;    ; Tq/. ÓÄÄerefore, the
client only requires storing  and CT , and the storage overhead is independent of q. Trivially, the
server should provide a valid opening of CT as a proof during the veriÔ¨Åcation phase. Due to the
property of vector commitment, the update of CT is still incremental.


65
C H A P T E R
6
Conclusion and Future Works
Outsourcing computation is a fruitful and long-standing research topic in the academic commu-
nity. With the development of cloud computing and big data, we believe that more and more
researchers will focus on this hot topic. In this book, we present research progress on outsourcing
computation, while it is far from complete due to space and time constraints.
In the following, we present some (possible) future works and open problems in outsourcing
computation.
‚Ä¢ In the outsourcing scientiÔ¨Åc computations, how do we achieve the CCA security for the
inputs? A totally random blinding or disguise technique seems not to work. For example,
if we blind a dense matrix with rank n by multiplying a randomly chosen dense matrix,
the computation overload should be n3. In this sense, we should Ô¨Ånd some more eÔ¨Écient
algorithms which can still achieve the strongest security notions.
‚Ä¢ Is it possible to Ô¨Ånd an eÔ¨Écient algorithm for securely outsourcing the cryptographic oper-
ations by only using an untrusted server? Note that the algorithm should also only require
one round of interaction between the server and the client. We left it as an open problem.
‚Ä¢ ÓÄÄe system parameters in current VDB schemes are proportional to the number of database
indices. ÓÄÄus, the constructions are given in the amortized model. It is interesting to pro-
pose a construction (or a framework) for eÔ¨Écient VDB with constant system parameters.
Besides, the current VDB schemes do not support the insertion kind of update since the
number of database indices is Ô¨Åxed in advance. ÓÄÄerefore, an interesting open problem is
to propose an eÔ¨Écient VDB scheme supporting all kinds of update operations (insertion,
deletion, and replacement).
‚Ä¢ How do we detect the misbehavior of an untrusted server in the multiple results of outsourc-
ing computations? For example, the computation task is to Ô¨Ånd all collisions of one-way
function or to Ô¨Ånd all solutions of a large-scale linear equation (the solution is not unique).
In these scenarios, the servers may not send all the computation results to the client. In the
worst case, the untrusted server just responds with an empty set. ÓÄÄe idea of ringer is a par-
tial solution that is only suitable for an ‚Äúinversion of one-way function‚Äù class of outsourcing
computations. Is there any other eÔ¨Écient solution to solve this problem by using some new
primitives, such as veriÔ¨Åably searchable encryption?

66
6. CONCLUSION AND FUTURE WORKS
‚Ä¢ It seems that VDB is closely related to proof of retrievability (PoR) [55, 64, 86, 119, 129].
What is the essential relationship between the two primitives? On the other hand, the
current VDB schemes rarely consider the privacy of the clients, especially in the multi-client
scenarios. ÓÄÄerefore, it is interesting to design eÔ¨Écient privacy-preserving VDB schemes
using some new cryptographic primitives.
‚Ä¢ Backes, Fiore, and Reischuk [13] Ô¨Årstly introduced the idea of outsourcing big data. ÓÄÄat
is, the size of outsourced data is very huge while not Ô¨Åxed beforehand (the data may be
changing and increasing). Currently, we are facing the era of big data. ÓÄÄus, it is interesting
to construct more Ô¨Çexible and eÔ¨Écient outsourcing schemes for big data.

67
Bibliography
[1] M.J. Atallah and K.B. Frikken. Securely outsourcing linear algebra computations. Pro-
ceedings of the 5th ACM Symposium on Information, Computer and Communications Security
(ASIACCS), pp. 48‚Äì59, 2010. DOI: 10.1145/1755688.1755695. 3, 19
[2] M. Abadi, J. Feigenbaum, and J. Kilian. On hiding information from an oracle. Proceedings
of the 19th Annual ACM Symposium on ÓÅêeory of Computing (STOC), pp. 195‚Äì203, 1987.
DOI: 10.1145/28395.28417. 19
[3] M.J. Atallah and J. Li. Secure outsourcing of sequence comparisons. International Journal
of Information Security, 4(4), pp. 277‚Äì287, 2005. DOI: 10.1007/s10207-005-0070-3. 19
[4] B. Andrei and M. Michael. Network applications of bloom Ô¨Ålters: A survey. Internet Math-
ematics, 1(4), pp. 485‚Äì509, 2004. DOI: 10.1080/15427951.2004.10129096. 17
[5] G. Ateniese and B. de Medeiros. Identity-based chameleon hash and applications. Finan-
cial Cryptography (FC), LNCS 3110, Springer, pp. 164‚Äì180, 2004. DOI: 10.1007/978-3-
540-27809-2_19. 38
[6] G. Ateniese and B. de Medeiros. On the key-exposure problem in chameleon hashes.
Security in Communication Networks (SCN), LNCS 3352, Springer, pp. 165‚Äì179, 2005.
DOI: 10.1007/978-3-540-30598-9_12. 38
[7] M.J. Atallah, K.N. Pantazopoulos, J.R. Rice, and E.H. SpaÔ¨Äord. Secure outsourcing
of scientiÔ¨Åc computations. Advances in Computers, vol. 54, pp. 216‚Äì272, 2001. DOI:
10.1016/s0065-2458(01)80019-x. 3, 19, 20, 22, 23
[8] D. Benjamin and M.J. Atallah. Private and cheating-free outsourcing of algebraic com-
putations. Proceedings of the 6th Annual Conference on Privacy, Security and Trust (PST),
pp. 240‚Äì245, 2008. DOI: 10.1109/pst.2008.12. 19
[9] G. Brassard, D. Chaum, and C. Crepeau. Minimum disclosure proofs of knowledge.
Journal of Computer and System Sciences, 37(2), pp. 156‚Äì189, 1988. DOI: 10.1016/0022-
0000(88)90005-0. 38
[10] F. Bao, R. Deng, and H. Zhu. Variations of DiÔ¨Ée-Hellman Problem. Information
and Communications Security (ICS), LNCS 2836, pp. 301‚Äì312, Springer, 2003. DOI:
10.1007/978-3-540-39927-8_28. 11

68
BIBLIOGRAPHY
[11] D. Boneh and M. Franklin. Identity-based encryption from the Weil pairings. Advances
in Cryptology-Crypto 2001, LNCS 2139, pp. 213‚Äì229, Springer, 2001. DOI: 10.1007/3-
540-44647-8_13. 12
[12] D. Beaver, J. Feigenbaum, J. Kilian, and P. Rogaway. Locally random reductions:
Improvements and applications. Journal of Cryptology, 10(1), pp. 17‚Äì36, 1997. DOI:
10.1007/s001459900017. 34
[13] M. Backes, D. Fiore, and R.M. Reischuk. VeriÔ¨Åable Delegation of Computation on Out-
sourced Data. Proceedings of the ACM Conference on Computer and Communications Security
(CCS), pp. 863‚Äì874, ACM, 2013. DOI: 10.1145/2508859.2516681. 3, 66
[14] M. Ben-Or, S. Goldwasser, J. Kilian, and A. Wigderson. Multi-prover interactive proofs:
How to remove intractability assumptions. Proceedings of the ACM Symposium on ÓÅêeory of
Computing (STOC), pp. 113‚Äì131, 1988. DOI: 10.1145/62212.62223. 33
[15] M. Bellare, O. Goldreich, and S. Goldwasser. Incremental cryptography: ÓÄÄe case of
hashing and signing. Advances in Cryptology-CRYPTO 1994, LNCS 2836, pp. 216‚Äì233,
Springer, 1994. DOI: 10.1007/3-540-48658-5_22. 58
[16] M. Bellare, O. Goldreich, and S. Goldwasser. Incremental Cryptography and Application
to Virus Protection. Proceedings of the 27th ACM Symposium on the ÓÅêeory of Computing
(STOC), pp. 45‚Äì56, 1995. DOI: 10.1145/225058.225080. 58, 60
[17] D. Boneh, E.J. Goh, and K. Nissim. Evaluating 2-dnf formulas on ciphertexts. ÓÅêeory of
Cryptography, pp. 325‚Äì341, Springer, 2005. DOI: 10.1007/978-3-540-30576-7_18. 12
[18] S. Benabbas, R. Gennaro, and Y. Vahlis. VeriÔ¨Åable delegation of computation over large
datasets. Advances in Cryptology-CRYPTO 2011, LNCS 6841, pp. 111‚Äì131, Springer,
2011. DOI: 10.1007/978-3-642-22792-9_7. 12, 15, 45, 46, 47, 52, 53, 54
[19] E. Buonanno, J. Katz, and M. Yung. Incremental Unforgeable Encryption. Fast Soft-
ware Encryption (FSE), LNCS 2355, pp. 109‚Äì124, Springer, 2002. DOI: 10.1007/3-540-
45473-x_9. 59, 60, 61
[20] M. Benzi. Preconditioning Techniques for Large Linear Systems: A Survey. Journal of
Computational Physics, 182, pp. 418‚Äì477, 2002. DOI: 10.1006/jcph.2002.7176. 23, 26
[21] D. Boneh. Twenty years of attacks on the RSA cryptosystem. Notices of the American Math-
ematical Society, 46(2), pp. 203‚Äì213, 1999. 29
[22] M. Blanton. Improved conditional e-payments. Applied Cryptography and Network Security
(ACNS), LNCS 5037, pp. 188‚Äì206, Springer, 2008. DOI: 10.1007/978-3-540-68914-
0_12. 4

BIBLIOGRAPHY
69
[23] M. Blanton, M.J. Atallah, K.B. Frikken, and Q. Malluhi. Secure and eÔ¨Écient outsourc-
ing of sequence comparisons. ESORICS 2012, LNCS 7459, pp. 505‚Äì522, Springer, 2012.
DOI: 10.1007/978-3-642-33167-1_29. 19
[24] B.H. Bloom. Space/Time trade-oÔ¨Äs in hash coding with allowable Errors, Communications
of the ACM, 13(7), pp. 422‚Äì426, 1970. DOI: 10.1145/362686.362692. 17
[25] M. Blum, M. Luby, and R. Rubinfeld. Program result checking against adaptive programs
and in cryptographic settings. DIMACS Series in Discrete Mathematics and ÓÅêeoretical Com-
puter Science, pp. 107‚Äì118, 1991. 33
[26] M. Blum, M. Luby, and R. Rubinfeld. Self-testing/correcting with applications to nu-
merical problems. Journal of Computer and System Science, 47(3), pp. 549‚Äì595, 1993. DOI:
10.1016/0022-0000(93)90044-w. 33
[27] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairings. Advances
in Cryptology-Asiacrypt, LNCS 2248, pp. 514‚Äì532, Springer, 2001. DOI: 10.1007/3-540-
45682-1_30. 12, 61
[28] F. Bonomi, M. Mitzenmacher, R. Panigrahy, S. Singh, and G. Varghese. An Improved
Construction for Counting Bloom Filters. Algorithms CESA, pp. 684‚Äì695, Springer, 2006.
DOI: 10.1007/11841036_61. 17
[29] M. Bellare and C. Namprempre. Authenticated Encryption: Relations Among Notions
and Analysis of the Generic Composition Paradigm. Advances in Cryptology-Asiacrypt,
LNCS 1976, pp. 531‚Äì545, Springer, 2000. DOI: 10.1007/3-540-44448-3_41. 61
[30] P. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. Selected Areas
in Cryptography, pp. 319‚Äì331, Springer, 2006. DOI: 10.1007/11693383_22. 43
[31] V. Boyko, M. Peinado, and R. Venkatesan. Speeding up discrete log and factoring based
schemes via precomputations. Advances in Cryptology-Eurocrypt, LNCS 1403, pp. 221‚Äì
232, Springer, 1998. DOI: 10.1007/bfb0054129. 30, 34
[32] D. Boneh and B. Waters. Conjunctive, subset, and range queries on encrypted data. ÓÅêeory
of Cryptography, LNCS 4392, pp. 535‚Äì554, Springer, 2007. DOI: 10.1007/978-3-540-
70936-7_29. 12
[33] D. Chaum. Blind signature for untraceable payments. Advances in Cryptology-Eurocrypt,
pp. 199‚Äì203, 1982. DOI: 10.1007/978-1-4757-0602-4_18. 20
[34] D. Chaum and T. Pedersen. Wallet databases with observers. Advances in Cryptology-
Crypto, LNCS 740, pp. 89‚Äì105, Springer, 1993. DOI: 10.1007/3-540-48071-4_7. 30

70
BIBLIOGRAPHY
[35] S. Chow, M. Au, and W. Susilo. Server-aided signatures veriÔ¨Åcation secure against collu-
sion attack. Proceedings of the 6th ACM Symposium on Information, Computer and Commu-
nications Security (ASIACCS), pp. 401‚Äì405, 2011. DOI: 10.1145/1966913.1966967.
[36] J. Cha and J.H. Cheon. An identity-based signature from gap DiÔ¨Ée CHellman groups.
PKC 2003, LNCS 2567, pp. 18‚Äì30, Springer, 2003. DOI: 10.1007/3-540-36288-6_2. 12
[37] B. Chevallier-Mames, J. Coron, N. McCullagh, D. Naccache, and M. Scott. Secure del-
egation of elliptic-curve pairing. Smart Card Research and Advanced Application, LNCS
6035, pp. 24‚Äì35, Springer, 2010. DOI: 10.1007/978-3-642-12510-2_3. 30, 40
[38] R. Cramer and I. Damgard. Multiparty computation, an introduction. Contemporary Cryp-
tology, pp. 41‚Äì87, 2005. DOI: 10.1007/3-7643-7394-6_2. 2
[39] S. Canard, J. Devigne, and O. Sanders. Delegating a pairing can be both secure and ef-
Ô¨Åcient. Applied Cryptography and Network Security, pp. 549‚Äì565, Springer, 2014. DOI:
10.1007/978-3-319-07536-5_32. 43
[40] D. Catalano, D. Fiore, and M. Messina. Zero-knowledge sets with short proofs. Ad-
vances in Cryptology-EUROCRYPT, LNCS 4965, pp. 433‚Äì450, Springer, 2008. DOI:
10.1007/978-3-540-78967-3_25. 14
[41] D. Catalano and D. Fiore. Vector commitments and their applications. PKC 2013, LNCS
7778, pp. 55‚Äì72, Springer, 2013. DOI: 10.1007/978-3-642-36362-7_5. 14, 15, 45, 46,
51, 57, 62
[42] X. Chen, F. Zhang, and K. Kim. Chameleon Hashing without Key Exposure. Information
Security Conference, LNCS 3225, pp. 135‚Äì148, Springer, 2004. DOI: 10.1007/978-3-540-
30144-8_8. 38
[43] J. Camenisch, S. Hohenberger, and M. Pedersen. Batch VeriÔ¨Åcation of Short Signatures.
Advances in Cryptology-EUROCRYPT, LNCS 4515, pp. 246‚Äì263, Springer, 2007. DOI:
10.1007/978-3-540-72540-4_14. 62
[44] X. Chen, F. Zhang, W. Susilo, and Y. Mu. EÔ¨Écient generic online/oÔ¨Ä-line signatures
without key exposure. Applied Cryptography and Network Security (ACNS), LNCS 4521,
pp. 18‚Äì30, Springer, 2007. DOI: 10.1007/978-3-540-72738-5_2. 38
[45] X. Chen, J. Li, and W. Susilo. EÔ¨Écient Fair Conditional Payments for Outsourcing Com-
putations. IEEE Transactions on Information Forensics and Security, 7(6), pp. 1687‚Äì1694,
2012. DOI: 10.1109/tifs.2012.2210880. 3, 4
[46] X. Chen, F. Zhang, W. Susilo, H. Tian, J. Li, and K. Kim. Identity-based chameleon
hashing and signatures without key exposure. Information Sciences, 265, pp. 198‚Äì210, 2014.
DOI: 10.1016/j.ins.2013.12.020. 38

BIBLIOGRAPHY
71
[47] X. Chen, J. Li, X. Huang, J. Ma, and W. Lou. New publicly veriÔ¨Åable databases with
eÔ¨Écient updates. IEEE Transactions on Dependable Secure Computing, 12(5), pp. 546‚Äì556,
2015. DOI: 10.1109/tdsc.2014.2366471. 51, 52, 54, 56
[48] X. Chen, W. Susilo, F. Zhang, H. Tian, and J. Li. Identity-Based Trapdoor Mercurial
Commitment and Applications. ÓÄÄeoretical Computer Science, 412(39), pp. 5498‚Äì5512,
2011. DOI: 10.1016/j.tcs.2011.05.031. 14
[49] X. Chen, J. Li, J. Ma, Q. Tang, and W. Lou. New algorithms for secure outsourcing of
modular exponentiations. ESORICS, LNCS 7459, pp. 541‚Äì556, Springer, 2012. DOI:
10.1007/978-3-642-33167-1_31. 3, 33, 35, 38, 39
[50] X. Chen, J. Li, X. Huang, J. Li, Y. Xiang, and D. Wong. Secure Outsourced Attribute-
based Signatures. IEEE Transactions on Parallel and Distributed Systems, 25(12), pp. 3285‚Äì
3294, 2014. DOI: 10.1109/tpds.2013.2295809. 3
[51] X. Chen, X. Huang, J. Li, J. Ma, and W. Lou. New Algorithms for Secure Outsourcing of
Large-scale Systems of Linear Equations. IEEE Transactions on Information and Forensics
Security, 10(1), pp. 69‚Äì78, 2015. DOI: 10.1109/tifs.2014.2363765. 20, 24
[52] X. Chen, J. Li, J. Weng, J. Ma, and W. Lou. VeriÔ¨Åable Computation over Large Database
with Incremental Updates. ESORICS, LNCS 8712, pp. 148‚Äì162, Springer, 2014. DOI:
10.1007/978-3-319-11203-9_9. 58, 59, 61, 62
[53] X. Chen, W. Susilo, J. Li, D.S. Wong, J. Ma, S. Tang, and Q. Tang. EÔ¨Écient algorithms
for secure outsourcing of bilinear pairings. ÓÅêeoretical Computer Science, 562, pp. 112‚Äì121,
2015. DOI: 10.1016/j.tcs.2014.09.038. 41, 42
[54] X. Chen et al. Publicly VeriÔ¨Åable Databases with All EÔ¨Écient Operations, manuscipt.
DOI: 10.1109/tdsc.2014.2366471. 18
[55] R. Curtmola, O. Khan, and R. Burns. Robust remote data checking. Proceeding of the 4th
ACM Workshop on Storage Security and Survivability (StorageSS), pp. 63‚Äì68, 2008. DOI:
10.1145/1456469.1456481. 66
[56] J. Camenisch, M. Kohlweiss, and C. Soriente. An accumulator based on bilinear maps and
eÔ¨Écient revocation for anonymous credentials. PKC, LNCS 5443, pp. 481‚Äì500, Springer,
2009. DOI: 10.1007/978-3-642-00468-1_27. 45
[57] J. Camenisch and A. Lysyanskaya. Dynamic accumulators and application to eÔ¨Écient re-
vocation of anonymous credentials. Advances in Cryptology-CRYPTO, LNCS 2442, pp.
61‚Äì76, Springer, 2002. DOI: 10.1007/3-540-45708-9_5. 45

72
BIBLIOGRAPHY
[58] R. Canetti, B. Riva, and G.N. Rothblum. Practical delegation of computation using mul-
tiple servers. Proceedings of the 18th ACM Conference on Computer and Communications Se-
curity (CCS), pp. 445‚Äì454, 2011. DOI: 10.1145/2046707.2046759. 4, 7
[59] Y. Chen and R. Sion. Costs and Security in Clouds. Secure Cloud Computing, pp. 31‚Äì56,
Springer, 2014. DOI: 10.1007/978-1-4614-9278-8_2. 1
[60] Top ÓÄÄreats Working Group. ÓÄÄe notorious nine: cloud computing top threats in 2013.
Cloud Security Alliance Technical Report, 2013.
[61] B. Carbunar and M. Tripunitara. Conditioal payments for computing markets. Cryp-
tology and Network Security (CANS), LNCS 5339, pp. 317‚Äì331, Springer, 2008. DOI:
10.1007/978-3-540-89641-8_23. 4
[62] B. Carbunar and M. Tripunitara. Fair payments for outsourced computations. Pro-
ceedings of the 7th Annual IEEE Communications Society Conference on Sensor, Mesh
and Ad Hoc Communications and Networks (SECON), pp. 529‚Äì537, 2010. DOI:
10.1109/secon.2010.5508202. 4
[63] W. DiÔ¨Ée and M.E. Hellman. New directions in cryptography. IEEE Transactions in In-
formation ÓÅêeory, 22(6), pp. 644‚Äì654, 1976. DOI: 10.1109/tit.1976.1055638. 29
[64] Y. Dodis, S. Vadhan, and D. Wichs. Proofs of retrivability via hardness ampliÔ¨Åcation.
TCC, pp. 109‚Äì127, Springer, 2009. DOI: 10.1007/978-3-642-00457-5_8. 66
[65] D. Eppstein and M.T. Goodrich. Straggler IdentiÔ¨Åcation in Round-Trip Data Streams
via Newton‚Äôs Identities and Invertible Bloom Filters. IEEE Transactions on Knowledge and
Data Engineering, 23(2), pp. 297‚Äì306, 2011. DOI: 10.1109/tkde.2010.132. 17
[66] S. Even, O. Goldreich, and S. Micali. On-line/OÔ¨Ä-line digital signatures. Journal of Cryp-
tology, 9(1), pp. 35‚Äì67, Springer, 1996. DOI: 10.1007/bf02254791. 29, 34
[67] M. Fischlin and R. Fischlin. EÔ¨Écient non-malleable commitment schemes. Advances in
Cryptology, LNCS 1880, pp. 413‚Äì431, Springer, 2000. DOI: 10.1007/3-540-44598-6_26.
54
[68] K. Forsman, W. Gropp, L. Kettunen, D. Levine, and J. Salonen. Solution of dense sys-
tems of linear equations arising from integral-equation formulations. IEEE Antennas and
Propagation Magazine, 37(6), pp. 96‚Äì100, 1995. DOI: 10.1109/74.482076. 23
[69] C. Gentry. A fully homomorphic encryption scheme. Ph.D. thesis, Stanford University,
2009. 8
[70] C. Gentry. Fully homomorphic encryption using ideal lattices. Proceedings of the
ACM Symposium on the ÓÅêeory of Computing (STOC), pp. 169‚Äì178, 2009. DOI:
10.1145/1536414.1536440. 8

BIBLIOGRAPHY
73
[71] M. Girault and D. Lefranc. Server-aided veriÔ¨Åcation: theory and practice. Ad-
vances in Cryptology-Asiacrypt, LNCS 3788, pp. 605‚Äì623, Springer, 2005. DOI:
10.1007/11593447_33. 30, 34
[72] S. Galbraith, K. Paterson, and N. Smart. Pairings for cryptographers. Discrete Applied
Mathematics, 156(16), pp. 3113‚Äì3121, 2008. DOI: 10.1016/j.dam.2007.12.010. 40
[73] S. Goldwasser, Y.T. Kalai, and G.N. Rothblum. Delegating computation: interactive
proofs for muggles. Proceedings of the ACM Symposium on the ÓÅêeory of Computing (STOC),
pp. 113‚Äì122, 2008. DOI: 10.1145/1374376.1374396. 4
[74] R. Gennaro, C. Gentry, and B. Parno. Non-interactive veriÔ¨Åable computing: Outsourc-
ing computation to untrusted workers. Advances in Cryptology-CRYPTO, pp. 465‚Äì482,
Springer, 2010. DOI: 10.1007/978-3-642-14623-7_25. 1, 4, 5, 7, 8, 48
[75] J. Groth, R. Ostrovsky, and A. Sahai. Perfect non-interactive zero knowledge for NP.
Advances in Cryptology-EUROCRYPT, LNCS 4004, pp. 339‚Äì358, Springer, 2006. DOI:
10.1007/11761679_21. 12
[76] J. Groth and A. Sahai. EÔ¨Écient non-interactive proof systems for bilinear groups. Ad-
vances in Cryptology-EUROCRYPT, LNCS 4965, pp. 415‚Äì432, Springer, 2008. DOI:
10.1007/978-3-540-78967-3_24. 12
[77] S. Goldwasser, S. Micali, and C. RackoÔ¨Ä. ÓÄÄe knowledge complexity of interactive proof-
systems. SIAM Journal on Computing, 18(1), pp. 186‚Äì208, 1989. DOI: 10.1137/0218012.
[78] O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game. Proceedings
of the 19th Annual ACM Symposium on ÓÅêeory of Computing, pp. 218‚Äì229, 1987. DOI:
10.1145/28395.28420. 6
[79] P. Golle and I. Mironov. Uncheatable distributed computations. CT-RSA, LNCS 2020,
pp. 425‚Äì440, Springer, 2001. DOI: 10.1007/3-540-45353-9_31. 4, 7
[80] J. Garay, P. MacKenzie, and K. Yang. Strengthening zero-knowledge protocols using
signatures. Advances in Cryptology-Eurocrypt, LNCS 2656, pp. 177‚Äì194, Springer, 2003.
DOI: 10.1007/3-540-39200-9_11. 38
[81] S. Galbraith, K. Paterson, and N. Smart. Pairings for cryptographers. Discrete Applied
Mathematics, 156(16), pp. 3113‚Äì3121, 2008. DOI: 10.1016/j.dam.2007.12.010. 12
[82] S. Hohenberger and A. Lysyanskaya. How to securely outsource cryptographic com-
putations. ÓÅêeory of Cryptography, LNCS 3378, pp. 264‚Äì282, Springer, 2005. DOI:
10.1007/978-3-540-30576-7_15. 4, 5, 7, 30, 33, 34, 35, 36, 38, 40
[83] R.A. Horn and C.R. Johnson. Matrix Analysis. Cambridge University Press, 1985. 25

74
BIBLIOGRAPHY
[84] H. Hacigumus, B. Iyer, and S. Mehrotra. Providing database as a service. Proceedings
of the 18th International Conference on Data Engineering, pp. 29‚Äì38, IEEE, 2002. DOI:
10.1109/icde.2002.994695. 45
[85] J.J. Rotman. A First Course in Abstract Algebra, 3rd ed., Prentice Hall, Upper Saddle River,
New Jersey, pp. 127, 2005. 13
[86] A. Juels and B.S. Kaliski. PORs: proofs of retrievalibity for large Ô¨Åles. Proceedings of the
14th ACM Conference on Computer and Communications Security (CCS), pp. 584‚Äì597, 2007.
DOI: 10.1145/1315245.1315317. 66
[87] J. Kilian. A note on eÔ¨Écient zero-knowledge proofs and arguments. Proceedings of
the ACM Symposium on ÓÅêeory of Computing (STOC), pp. 723‚Äì732, 1992. DOI:
10.1145/129712.129782. 4
[88] J. Kilian. Improved eÔ¨Écient arguments (preliminary version). Advances in Cryptology-
Crypto, pp. 311‚Äì324, Springer, 1995. 4
[89] T. Kleinjung, K. Aoki, J. Franke, et al. Factorization of a 768-bit RSA modulus. Advances
in Cryptology-Crypto, LNCS 6223, pp. 333‚Äì350, Springer, 2010. DOI: 10.1007/978-3-
642-14623-7_18. 1
[90] H. Krawczyk and T. Rabin. Chameleon hashing and signatures. NDSS, pp. 143‚Äì154, 2000.
38
[91] J. Katz, A. Sahai, and B. Waters. Predicate encryption supporting disjunctions, polynomial
equations, and inner products. Advances in Cryptology-EUROCRYPT, LNCS 4965, pp.
146‚Äì162, 2008. DOI: 10.1007/978-3-540-78967-3_9. 12
[92] J. Li, X. Huang, J. Li, X. Chen, and Y. Xiang. Securely Outsourcing Attribute-Based En-
cryption with Checkability. IEEE Transactions on Parallel and Distributed Systems, 25(8),
pp. 2201‚Äì2210, 2014. DOI: 10.1109/tpds.2013.271. 3
[93] A. Lathey, P. Atrey, and N. Joshi. Homomorphic low pass Ô¨Åltering on encrypted mul-
timedia over cloud. IEEE International Conference on Semantic Computing, pp. 310‚Äì313,
2013. DOI: 10.1109/icsc.2013.60. 19
[94] A.K. Lenstra and E.R. Verheul. Selecting cryptographic key sizes. Journal of Cryptology,
14(4), pp. 255‚Äì293, Springer, 2001. DOI: 10.1007/s00145-001-0009-4. 29
[95] B. Libert and M. Yung. Concise mercurial vector commitments and independent zero-
knowledge sets with short proofs. ÓÅêeory of Cryptography, LNCS 5978, pp. 499‚Äì517,
Springer, 2010. DOI: 10.1007/978-3-642-11799-2_30. 14

BIBLIOGRAPHY
75
[96] S. Micali. CS proofs. Proceedings of the 35th Annual Symposium on Foundations of Computer
Science (FOCS), pp. 436‚Äì453, 1994. 4
[97] T. Matsumoto, K. Kato, and H. Imai. Speeding up secret computations with insecure
auxiliary devices. Advances in Cryptology-Crypto, LNCS 403, pp. 497‚Äì506, 1988. DOI:
10.1007/0-387-34799-2_35. 30, 34
[98] C.U. Martel, G. Nuckolls, P.T. Devanbu, M. Gertz, A. Kwong, and S.G. Stubblebine. A
general model for authenticated data structures. Algorithmica, 39(1), pp. 21‚Äì41, Springer,
2004. DOI: 10.1007/s00453-003-1076-8. 45
[99] A. Menezes, P. van Oorschot, and S. Vanstone. Handbook of Applied Cryptography. CRC
Press, 1996. DOI: 10.1201/9781439821916. 39
[100] M. Mohanty, W. Ooi, and P. Atrey. Scale me, crop me, know me not: Supporting scaling
and cropping in secret image sharing. IEEE International Conference on Multimedia and
Expo, pp. 1‚Äì6, 2013. DOI: 10.1109/icme.2013.6607567. 19
[101] I. Mironov, O. Pandey, O. Reingold, and G. Segev. Incremental Deterministic Public-Key
Encryption. Advances in Cryptology-Eurocrypt, LNCS 7237, pp. 628‚Äì644, Springer, 2012.
DOI: 10.1007/978-3-642-29011-4_37. 59, 60
[102] E. Mykletun, M. Narasimha, and G. Tsudik. Signature bouquets: Immutability for ag-
gregated/condensed signatures. Proceedings of the 9th European Symposium on Research in
Computer Security (ESORICS), pp. 160‚Äì176, Springer, 2004. DOI: 10.1007/978-3-540-
30108-0_10. 45
[103] S. Micali, M. Rabin, and J. Kilian. Zero-knowledge sets. Proceedings of the 44th Annual
IEEE Symposium on Foundations of Computer Science (FOCS), pp. 80‚Äì91, IEEE, 2003.
DOI: 10.1109/sfcs.2003.1238183. 14
[104] E. Mykletun and G. Tsudik. Aggregation queries in the database-as-a-service model. Pro-
ceedings of the 20th IFIP WG 11.3 Working Conference on Data and Applications Security, pp.
89‚Äì103, Springer, 2006. DOI: 10.1007/11805588_7. 45
[105] L. Nguyen. Accumulators from bilinear pairings and applications. CT-RSA, LNCS 3376,
pp. 75‚Äì292, Springer, 2005. DOI: 10.1007/978-3-540-30574-3_19. 45
[106] P.Q. Nguyen, I.E. Shparlinski, and J. Stern. Distribution of modular sums and the security
of server aided exponentiation. Proceedings of the Workshop on Cryptography and Computa-
tional Number ÓÅêeory, pp. 1‚Äì16, 1999. DOI: 10.1007/978-3-0348-8295-8_24. 34
[107] M. Naor and K. Nissim. CertiÔ¨Åcate revocation and certiÔ¨Åcate update. Proceedings of the 7th
Conference on USENIX Security Symposium, pp. 17‚Äì17, 1998. DOI: 10.1109/49.839932.
45

76
BIBLIOGRAPHY
[108] T. Pedersen. Non-interactive and information-theoretical Secure veriÔ¨Åable secret shar-
ing. Advances in Cryptology-CRYPTO, LNCS 576, pp. 129‚Äì140, Springer, 1991. DOI:
10.1007/3-540-46766-1_9. 38
[109] C. Papamanthou and R. Tamassia. Time and space eÔ¨Écient algorithms for two-party au-
thenticated data structures. Information and Communications Security, LNCS 4861, pp.
1‚Äì15, Springer, 2007. DOI: 10.1007/978-3-540-77048-0_1. 45
[110] M. Peter and T. Grance. ÓÄÄe NIST deÔ¨Ånition of cloud computing. National Institute of
Standards and Technology, 53(6), pp. 50, 2009. DOI: 10.6028/nist.sp.800-145. 2
[111] K. Ren, C. Wang, and Q. Wang. Security Challenges for the Public Cloud. IEEE Internet
Computing, 16(1), pp. 69‚Äì73, 2012. DOI: 10.1109/mic.2012.14. 3
[112] R. Sion. Secure data outsourcing. Proceedings of the 33rd International Conference on Very
Large Data Bases (VLDB), pp. 1431‚Äì1432, 2007. 45
[113] M. Scott. Unbalancing pairing-based key exchange protocols. Cryptology, ePrint
Archive/2013/688, 2013. 43
[114] A. Shamir and Y. Tauman. Improved online/oÔ¨Ñine signature schemes. Advances in
Cryptology-CRYPTO, LNCS 2139, pp. 355‚Äì367, Springer, 2001. DOI: 10.1007/3-540-
44647-8_21. 38
[115] C.P. Schnorr. EÔ¨Écient signature generation for smart cards. Journal of Cryptology, 4(3), pp.
239‚Äì252, Springer, 1991. DOI: 10.1007/bf00196725. 30, 34
[116] M. Scott, N. Costigan, and W. Abdulwahab. Implementing cryptographic pairings on
smartcards. Cryptographic Hardware and Embedded Systems-CHES, LNCS 4249, pp. 134‚Äì
147, Springer, 2006. DOI: 10.1007/11894063_11. 40
[117] S. Subashini and V. Kavitha. A survey on security issues in service delivery models of cloud
computing. Journal of Network and Computer Applications, 34(1), pp. 1‚Äì11, 2011. DOI:
10.1016/j.jnca.2010.07.006.
[118] N.P. Smart and F. Vercauteren. Fully homomorphic encryption with relatively small key
and ciphertext sizes. Public Key Cryptography-PKC, vol. 6056, pp. 420‚Äì443, Springer, 2010.
DOI: 10.1007/978-3-642-13013-7_25. 8
[119] H. Shacham and B. Waters. Compact proofs of retrievability. Asiacrypt, LNCS 5350, pp.
90‚Äì107, Springer, 2008. DOI: 10.1007/978-3-540-89255-7_7. 66
[120] P. Tsang, S. Chow, and S. Smith. Batch pairing delegation. Advances in Information and
Computer Security, pp. 74‚Äì90, Springer, 2007. DOI: 10.1007/978-3-540-75651-4_6.

BIBLIOGRAPHY
77
[121] R. Tamassia and N. Triandopoulos. CertiÔ¨Åcation and authentication of data structures.
Alberto Mendelzon Workshop on Foundations of Data Management, 2010. 45
[122] H. Tian, F.Zhang, and K. Ren. Secure Bilinear Pairing Outsourcing Made More EÔ¨Écient
and Flexible. Proceedings of the 10th ACM Symposium on Information, Computer and Com-
munications Security (ASIACCS), pp. 417‚Äì426, 2015. DOI: 10.1145/2714576.2714615.
42
[123] C. Wang, K. Ren, and J. Wang. Secure and practical outsourcing of linear programming
in cloud computing. Proceedings of the 30th IEEE International Conference on Computer
Communications (INFOCOM), pp. 820‚Äì828, 2011. DOI: 10.1109/infcom.2011.5935305.
19
[124] M. van Dijk, C.Gentry, S. Halevi, and V.Vaikuntanathan. Fully homomorphic encryp-
tion over the integers. Advances in Cryptology-EUROCRYPT, pp. 24‚Äì43, 2010. DOI:
10.1007/978-3-642-13190-5_2. 8
[125] C. Wang, N. Cao, K. Ren, and W. Lou. Enabling Secure and EÔ¨Écient Ranked Keyword
Search over Outsourced Cloud Data. IEEE Transactions on Parallel Distribution Systems,
23(8), pp. 1467‚Äì1479, 2012. DOI: 10.1109/tpds.2011.282. 3
[126] C. Wang, K. Ren, J. Wang, and Q. Wang. Harnessing the Cloud for Securely Outsourc-
ing Large-scale Systems of Linear Equations. IEEE Transactions on Parallel Distribution
Systems, 24(6), pp. 1172‚Äì1181, 2013. DOI: 10.1109/tpds.2012.206. 19, 25
[127] H. Wang and L.V.S. Lakshmanan. EÔ¨Écient Secure Query Evaluation over Encrypted
xml Databases. Proceedings of the 32nd International Conference on Very Large Data Bases
(VLDB), pp. 127‚ÄìC138, 2006. 45
[128] W. Wu, Y. Mu, W. Susilo, and X. Huang. Server-Aided VeriÔ¨Åcation Signatures: deÔ¨Åni-
tions and new constructions. Provable Security, LNCS 5324, pp. 141‚Äì155, Springer, 2008.
DOI: 10.1007/978-3-540-88733-1_10. 34
[129] J. Xu and E.C. Chang. Towards eÔ¨Écient proofs of retrievability in cloud storage. AsiaCCS,
pp. 79‚Äì80, ACM, 2012. DOI: 10.1145/2414456.2414503. 66
[130] A. Yao. Protocols for secure computations. Proceedings of the IEEE Symposium on Founda-
tions of Computer Science, pp. 160‚Äì164, 1982. DOI: 10.1109/sfcs.1982.38. 8
[131] A. Yao. How to generate and exchange secrets. Proceedings of the IEEE Symposium on Foun-
dations of Computer Science, pp. 162‚Äì167, 1986. DOI: 10.1109/sfcs.1986.25. 8
[132] R. Yuster and U. Zwick. Fast Sparse Matrix Multiplication. Annual European Sympo-
sium on Algorithms, LNCS 3221, pp. 604‚Äì615, Springer, 2004. DOI: 10.1007/978-3-540-
30140-0_54. 27

78
BIBLIOGRAPHY
[133] A.A. Yavuz. Practical immutable signature bouquets (PISB) for authentication and in-
tegrity in outsourced databases, Proceedings of the 27th Annual on Data and Applications
Security and Privacy (DBSec), pp. 179‚Äì194, 2013. DOI: 10.1007/978-3-642-39256-6_12.
45
[134] F. Zhang, X. Ma, and S. Liu. EÔ¨Écient computation outsourcing for inverting a
class of homomorphic functions. Information Sciences, 286(1), pp. 19‚Äì28, 2014. DOI:
10.1016/j.ins.2014.07.017. 43

79
Author‚Äôs Biography
XIAOFENG CHEN
Professor Xiaofeng Chen received his B.S. and M.S. on Mathe-
matics from Northwest University, China, in 1998 and 2000, re-
spectively. He got his Ph.D. degree in Cryptography from Xidian
University in 2003. Currently, he works at Xidian University as a
professor. His research interests include applied cryptography and
cloud computing security. He has published over 100 research pa-
pers in refereed international conferences and journals. His work
has been cited more than 3,000 times at Google Scholar. He is
on the Editorial Board of Security and Communication Networks
(SCN), Telecommunication Systems (TELS), Computing and Infor-
matics (CAI), and International Journal of High Performance Com-
puting and Networking (IJHPCN), etc. He served as general chair of the 11th ACM Asia Con-
ference on Computer and Communications Security (AsiaCCS 2016) and as program co-chair
of the 5th International Conference on Provable Security (ProvSec 2011). He has also served
as program committee member in over 30 international conferences. Currently, he is a director
of Information Security Center, State Key Laboratory of Integrated Service Networks (ISN),
Xidian University.

