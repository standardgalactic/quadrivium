Nils Przigoda · Robert Wille
Judith Przigoda · Rolf Drechsler
Automated Validation 
& Veriﬁ cation of UML/
OCL Models Using 
Satisﬁ ability Solvers

Automated Validation & Veriﬁcation of UML/OCL
Models Using Satisﬁability Solvers

Nils Przigoda • Robert Wille
Judith Przigoda • Rolf Drechsler
Automated Validation &
Veriﬁcation of UML/OCL
Models Using Satisﬁability
Solvers
123

Nils Przigoda
Mobility Division
Siemens AG
Braunschweig, Germany
Judith Przigoda
University of Bremen
Bremen, Germany
Robert Wille
Johannes Kepler University Linz
Linz, Austria
Rolf Drechsler
AG Rechnerarchitektur
University of Bremen
Bremen, Germany
Cyber-Physical Systems
DFKI GmbH, Bremen, Germany
ISBN 978-3-319-72813-1
ISBN 978-3-319-72814-8
(eBook)
https://doi.org/10.1007/978-3-319-72814-8
Library of Congress Control Number: 2017961733
© Springer International Publishing AG 2018
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations, recitation,
broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or information
storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology
now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication
does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant
protective laws and regulations and therefore free for general use.
The publisher, the authors and the editors are safe to assume that the advice and information in this book
are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or
the editors give a warranty, express or implied, with respect to the material contained herein or for any
errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional
claims in published maps and institutional afﬁliations.
Printed on acid-free paper
This Springer imprint is published by Springer Nature
The registered company is Springer International Publishing AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland

Preface
Only four decades after the ﬁrst manned ﬂight to the moon, a common device
such as a smartphone consists of more complex technology than the “high-end”
computers that controlled the Apollo 11 space mission. The same holds for software
which became more complex at an even higher rate. Consequently, the design of
such systems became a tremendously hard, difﬁcult, and expensive problem. To
cope with this, modeling languages such as UML and SysML were introduced as
description means to describe quasi-blueprints in early stages of the design ﬂow.
These modeling languages hide implementation details while providing a formal
base for the ﬁrst system analysis.
However, in order to beneﬁt from this abstraction, it has to be ensured that
the resulting models are applicable (motivating validation) and correct (motivating
veriﬁcation). But even at this high level of abstraction, this remains a complex
problem. Accordingly, researchers heavily investigated the validation and veriﬁ-
cation of UML/OCL models as well as models described in similar languages.
Solutions which are based on so-called satisﬁability solvers ﬁnd particular interests
due to their capability to completely cover large search spaces in a—considering the
usually exponential complexity—rather efﬁcient fashion.
This book provides a comprehensive description of such methods and their
application—including a general ﬂow that utilizes a formalization of UML/OCL.
While the presented ﬂow focuses on using satisﬁability solvers, how the provided
descriptions can additionally be used for any other automatic reasoning engine is
also described. Furthermore, for a broad variety of validation and veriﬁcation tasks,
the application of the proposed ﬂow is described. Additionally, the book also brieﬂy
covers how nonfunctional properties such as timing constraints can be handled
within the described ﬂow.
A case study demonstrates the possibilities and applicability of the presented
approaches and shows that there is still a gap between the UML/OCL models and
the following design steps. In order to address this problem, ﬁnally, an approach
is presented which veriﬁes an implementation against its model. This enables
the designer to transfer validation and veriﬁcation results to the following lower
abstraction levels.
v

vi
Preface
This book is the result of several years of intensive research at the University of
Bremen, Germany; DFKI GmbH Bremen, Germany; the Johannes Kepler Univer-
sity Linz, Austria; and, recently, Siemens AG in Braunschweig, Germany. During
this time, we experienced broad support from many people for which we would like
to thank them very much. Most importantly, we are thankful to the respective groups
in Bremen, Linz, and Braunschweig for providing a comfortable and inspirational
environment from which some authors beneﬁt until today. Particular thanks go to
(in alphabetical order) Christoph Hilken, Frank Hilken, Jannis Stoppe, Jan Peleska,
Jonas Gomes Filho, Julia Seiter, Martin Gogolla, Mathias Soeken, Pablo González
de Aledo, Pablo Sánchez Espeso, Philipp Niemann, and Ulrich Kühne for the
very productive collaboration that resulted in research papers which are partially
covered in this book. With respect to funding, we are indebted to thank the German
Research Foundation (DFG) which supported the research summarized in this book
through the Reinhart Koselleck project under grant no. DR 287/23-1, the Graduate
School SyDe funded by the German Excellence Initiative within the University of
Bremen’s institutional strategy, and the German Ministry of Education and Research
(BMBF) for their support through the projects SPECifIC under grant no. 01IW1300
and SELFIE under grant no. 01IW16001. Besides that, the Siemens AG Mobility
Division sponsored a scholarship for Nils Przigoda’s PhD thesis leading to several
results which formed the basis for this book. Finally, we would like to thank
Springer and, in particular, Charles “Chuck” Glaser, for making this book possible.
Braunschweig, Germany
Nils Przigoda
Linz, Austria
Robert Wille
Bremen, Germany
Judith Przigoda
Bremen, Germany
Rolf Drechsler
October 2017

Contents
1
Introduction ..................................................................
1
2
A Formal Interpretation of UML/OCL ...................................
7
2.1
Type System .............................................................
8
2.2
Classes and Models .....................................................
10
2.3
Objects and System States ..............................................
14
2.4
Invariants, Pre-, and Postconditions ....................................
16
2.5
Decision Problems ......................................................
19
2.5.1
Boolean Satisﬁability ...........................................
19
2.5.2
Satisﬁability Modulo Theories .................................
22
3
A Symbolic Formulation for Models.......................................
25
3.1
A General Flow for Automatic Veriﬁcation and Validation...........
27
3.2
Transforming a Model into a Symbolic Formulation..................
30
3.2.1
Transforming Attributes ........................................
31
3.2.2
Transforming Associations .....................................
40
3.2.3
Handling a Fixed and Variable Number of Objects ...........
44
3.2.4
Handling Null and Invalid ......................................
49
3.2.5
Transforming OCL Constraints ................................
53
3.3
Adding Veriﬁcation Tasks ..............................................
83
3.3.1
Structural Veriﬁcation Tasks ...................................
83
3.3.2
Behavioral Veriﬁcation Tasks ..................................
85
3.4
Other Approaches for Model Validation and Veriﬁcation.............
92
4
Structural Aspects ...........................................................
95
4.1
Debugging Inconsistent Models ........................................
96
4.1.1
Problem Formulation ...........................................
97
4.1.2
Previously Proposed Solutions .................................
98
4.1.3
Proposed Approach ............................................. 100
4.1.4
Implementation and Evaluation ................................ 103
vii

viii
Contents
4.1.5
Comparison with Other Approaches, Also from
Different Fields ................................................. 108
4.1.6
Example of Use ................................................. 109
4.2
Analyzing Invariant Independence ..................................... 110
4.2.1
Independence in Formal Models ............................... 111
4.2.2
Analysis for Invariant Independence........................... 113
4.2.3
Proposed Solution .............................................. 115
4.2.4
Experimental Evaluation ....................................... 118
4.3
Relation to Similar Approaches Used in SAT/SMT Solving ......... 121
5
Behavioral Aspects........................................................... 125
5.1
Restricting State Transitions Using Frame Conditions................ 126
5.1.1
Related Work.................................................... 127
5.1.2
Integrating Frame Conditions in the Symbolic Formulation.. 128
5.1.3
Deriving Frame Conditions from the AST .................... 138
5.2
Moving on to Concurrent Behavior in the Symbolic Formulation.... 144
5.2.1
Problem Formulation and Related Work ...................... 144
5.2.2
Handling Contradictory Conditions............................ 151
5.2.3
Implementation and Application ............................... 154
6
Timing Aspects ............................................................... 159
6.1
Preliminaries About Clocks and Ticks ................................. 161
6.2
A Generic Representation of CCSL Constraints ...................... 163
6.2.1
Determining the Generic Representation ...................... 164
6.2.2
Discussion and Application of the Generic Representation .. 168
6.3
Validation of Clock Constraints Against Instant Relations ........... 172
6.3.1
Motivation and Proposed Idea ................................. 173
6.3.2
Implementation ................................................. 175
6.3.3
Application and Evaluation .................................... 180
7
Reducing Instance Sizes with Ground Setting Properties ............... 183
7.1
Considered Running Example.......................................... 184
7.1.1
Considered Scenario ............................................ 184
7.1.2
Corresponding UML/OCL Model ............................. 185
7.2
Transformation of OCL Invariants and Resulting Problem ........... 187
7.2.1
Transformation of OCL Invariants ............................. 187
7.2.2
Consequences and Resulting Problem ......................... 190
7.3
Ground Setting Properties for Efﬁcient Transformation of OCL ..... 191
7.3.1
Ground Setting Properties ...................................... 191
7.3.2
Efﬁcient Transformation of OCL .............................. 193
7.4
Discussion and Related Work .......................................... 194
7.5
Implementation and Evaluation ........................................ 196
7.5.1
Implementation ................................................. 196
7.5.2
Evaluation ....................................................... 197

Contents
ix
8
Re-utilizing Veriﬁcation Results of UML/OCL Models.................. 201
8.1
What Can Be Veriﬁed Where?—A Case Study ....................... 202
8.1.1
Considered Access Control System............................ 202
8.1.2
Resulting Model ................................................ 203
8.1.3
Veriﬁcation of the Model ....................................... 205
8.1.4
Implementation of the Model .................................. 210
8.1.5
Comparison to the Formal Model .............................. 213
8.1.6
Open Issues ..................................................... 217
8.2
Verifying Implementations Against Their Formal Speciﬁcation...... 217
8.2.1
Envisioned Design Flow........................................ 218
8.2.2
General Idea..................................................... 220
8.2.3
Representation of the Implementation ......................... 222
8.2.4
Evaluation ....................................................... 227
9
Conclusion .................................................................... 235
Appendix A Class Inheritance ................................................ 239
Appendix B
An SMT Instance with an Unknown Result .................. 241
Appendix C Contradictory XOR Deﬁnitions ................................ 243
References......................................................................... 245

Nomenclature
B
B D ftrue; falseg
N
N D f0; 1; 2; : : :g
Z
Z D f: : : ; 1; 0; 1; 2; : : :g
–
Symbol for null in OCL
?
Symbol for invalid in OCL
˛
a
Variable for the attribute a of the object  in the symbolic representation
ˇc
A variable indicating if objects of a class c exist or not
!!0
Variable for the operation to be executed during the transition from the
system state  to 0.
ı
a
Deﬁnedness of an attribute a of the object  in the symbolic representation
i=I
A transformed OCL expression i or a set of OCL expressions I

A set of links

A single link, i.e., an instance of an association r

rolec2
Variable for possible links of rolec2 of the object  in the symbolic
representation
E
The set of all enumerations
V
The set of all variables of all types
Vt
The set of all variables with the type t
!
An operation call ! D .; o/
˝m;
The set of all operation calls
; 4
Inheritance relation between two classes

The Greek letter  is used for a transformed value of a literal or the
result a transformed subexpression—in both cases combined a ı-variable
to ensure the pair notation .; ı/

A single system state of a model m
˙m
The set of all possible system states of a model m

The underbracket is used in SMT-LIB listing to show that term above must
be replaced by a precise value or number
A
Attributes of a class
C
The ﬁnite set of classes of a model m
xi

xii
Nomenclature
c
A single class c D .A; O; I/
F
A ﬁnite set of frame conditions of an operation o
I
Invariants of a class
m
A (UML/OCL) model m D .C; R/
O
Operations of a class
o
A single operation of class o D .P; r; C; B/
P
A maybe empty set of parameters of an operation o
R
The ﬁnite set of associations between the classes of a model m
r
A single association r D .rolec1 W c1; rolec2 W c2; .l1; u1/; .l2; u2//
r
Return value of an operation o
v W t
A variable with identiﬁer v and type t 2 T
C
A may empty set of preconditions of an operation o
C
The (inﬁnite) set of all classes
R
The (inﬁnite) set of all associations also called relations
T
Type system
B
A may empty set of postconditions of an operation o

An object instance of a class c

A set of object instances

Chapter 1
Introduction
In the last decades, all kinds of systems human beings are surrounded by have
become more and more electriﬁed, miniaturized, and digitalized. They also got
more powerful and, thus, much more complex tasks can be solved nowadays.
Hence, it is not surprising that already in 2012—just 43 years after the ﬁrst manned
spaceﬂight Apollo 11 with its crew Neil Armstrong, Edwin Aldrin, and Michael
Collins landed on the moon—navigation systems for automobiles are more powerful
and versatile than the Apollo Guidance Computer (AGC) used for the Apollo 11
project. However, the AGC is seen as the ﬁrst embedded computer as it was only
a part of the control unit supporting other systems. Today, embedded systems are
nearly everywhere. Examples for (embedded) systems are, on the one side, actively
used systems such as smartphones, smartwatches, or ﬁtness bracelets and, on the
other side, hidden systems running in the background of other devices like anti-
blocking systems and airbags in cars.
With the increasing performance and complexity of systems, also their func-
tionality has increased and it keeps in doing so. Furthermore, there is currently no
indication that this will change in the next years, since all those systems are more
and more connected, thanks to 3G/4G/5G or, generally spoken, a globally connected
world. All this affects the design process of both, hardware and software, and
increases the problems designers have to consider. Consequently, the complexity of
both design processes increased, old methodologies need to be updated or discarded,
and completely new concepts have to be developed.
One of those new concepts is the strive for (higher) abstraction levels during
the system design. Generally, all ﬁrst drafts of systems are speciﬁcations usually
provided in natural language. The contained information is coming from the
customers and/or users. They are often also the base for a contract between the
customer and the contractor, maybe also between a contractor, sub-contractor, and
suppliers. However, speciﬁcations are full of ambiguities caused by the richness of
words and languages, and/or communication problems. This makes it hard to answer
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8_1
1

2
1
Introduction
the questions are we building the right system (associated with the term validation)
and are we building the system right (associated with the term veriﬁcation).
Therefore, hardware systems are not any longer designed in one step as a gate
list on a sheet of paper derived from a speciﬁcation—this also holds for software
systems and assembly code in a similar fashion, i.e., normally no one will start to
write machine speciﬁc code after reading a speciﬁcation. Instead, several abstraction
levels have been introduced for both hardware and software systems.
Nowadays, software programmers usually do not manually write assembly code
or take care of the interaction between software and hardware (on which the
software will run later); also punched tapes are out. In contrast to this, they use
object-oriented or functional programming languages and available compilers to
generate executable ﬁles. Those programming languages themselves are one or
more abstraction levels. For hardware systems, the current design ﬂow already
includes several abstraction levels, e.g., the electronic system level and the register
transfer level.
However, the gap between the ﬁrst prototypes and the speciﬁcation is still
challenging. To close this gap and, at the same time, to overcome ambiguities
in the interpretation of the speciﬁcation, a new abstraction level in between was
installed. In general, this abstraction level makes use of mathematical concepts to
describe system structure and behavior, represented by models that can—as their
syntax is usually quite close to natural language—easily be understood even by
non-mathematically-skilled people. In the domain of hardware design, this level
was recently introduced as the Formal Speciﬁcation Level (FSL) [DSW12, Soe13].
For software, this concept of modeling languages is used for even longer. In both
cases, the concept of a (formal) modeling level combines the intuitive understanding
people have for a language close to natural language with the formal nature of
a mathematical description, making it evaluable by computers as well as human
beings. Hence, the chosen modeling language for this new level should be as easy
as possible to understand for all involved stakeholders, e.g., project managers,
developers, and clients. At the same time, the syntax has to be supported by a sound
mathematical background and semantics.
Representatives of recent modeling languages are the Uniﬁed Modeling Lan-
guage (UML, ﬁrst versions go back to 1994), Alloy (1997), and the Systems
Modeling Language (SysML, 2003, an extension of UML 2.0 using its proﬁles).
Since these modeling languages allow the application of formal methods and are
an interesting new abstraction level, they received much attention in the recent past.
Most of the approaches presented in this book make use of UML—but many of them
can easily be adjusted, e.g., for SysML as well. Besides that, for non-functional
descriptions, we will additionally consider the Modeling and Analysis of Real-time
and Embedded systems (MARTE) framework.
However, for an adequate description of a system model, UML or a derivative
alone would not be sufﬁcient in a general case. In fact, not before combined, e.g.,
with the Object Constraint Language (OCL), it is possible to deﬁne a UML model
of a system that respects a signiﬁcant amount of details of a speciﬁcation. For
this purpose, the declarative language OCL is used to annotate UML models with

1
Introduction
3
additional constraints. For example, so-called OCL invariants are typically used
to detail structural (or static) aspects of a model. Moreover, following the Design-
by-Contract concept [MNM87], the behavior of an operation can be described by
annotating so-called pre- and postconditions to a UML model. Motivated by this,
class diagrams as provided by UML can indeed be used as an all-purpose tool to
rather comprehensively model the structure and behavior of a system.
However, having a formal description alone is only a small improvement com-
pared to the ambiguities of a (natural language) speciﬁcation. If the model already
contains design ﬂaws at this stage, the formal description would be completely
useless in the worst case. Thus, it becomes crucial to validate and verify that
the system model is correct. As UML/OCL models are formally deﬁned (or, at
least, a formal interpretation can be employed), they allow for the application of
different formal methods for validation and veriﬁcation (V&V) purposes. Due to
their capability of formally deﬁning a system, UML/OCL models are also called
formal models in the following.
Assuming now that formal methods are available to validate and verify the formal
models, it is possible to prove that certain properties are satisﬁed or violated before
any implementation steps are done. Hence, models can be seen as a blueprint
of the system to be built in which errors can be detected early in the design
process. Moreover, in most cases, even an automatic detection becomes possible.
Consequently, the entire process of designing a new error-free system as well as the
burden of detecting and ﬁnding errors becomes less cumbersome and less expensive.
In this book, we will particularly cover the following checks:
•
Does any valid instance of the model exist? Or in other words, is the model
consistent?
•
Does a given model contain contradictory constraints? If yes, which constraints
are causing the contradiction?
•
Does the model contain unwanted (in)dependencies? If yes, which constraints
are causing the unwanted dependencies?
•
Can the system be executed at all? If yes, can the system get stuck in dead- or
livelocks?
•
How can concurrent behavior of the system be analyzed using the formal model
and can this concurrent behavior of the system lead to problems?
•
How can non-functional behavior, in particular timing-constraints, be consid-
ered?
•
How can veriﬁcation results be transferred to a lower abstraction level?
In the following chapters, all these questions are considered by analyzing and
improving existing solutions as well as proposing new methods to deal with the
different aspects of formal models.
For this purpose, a veriﬁcation ﬂow for formal models is proposed and described
in detail (cf. Fig. 3.1 on p. 28). The main idea of this ﬂow is based on model
transformations and applying efﬁcient solving engines in the target language. More
precisely, formal methods will not be applied directly at a formal model. Instead,
V&V tasks for a formal model are transformed into a decision problem. The great

4
1
Introduction
progress in the development of algorithms to tackle various decision problems made
this transformation very prominent [BieC09]. In fact, in the hardware domain, many
problems are transformed into an instance of the Satisﬁability Problem (SAT), e.g.,
for test pattern generation [EWD13] and equivalence checking [GPB01, DS07].
Using so-called SAT solvers, solutions in huge search spaces can be determined in
an efﬁcient fashion. In this book, we will use an extension of these SAT solvers,
i.e., solvers for Satisﬁability Modulo Theories (SMT). SMT solvers are used as
a powerful and efﬁcient black box in order to determine witnesses as well as
counterexamples for the given task. Overall, this forms a formal foundation on
which the remainder of this book is based on: The application of formal methods to
various aspects of model evaluation with respect to system design.
The combination of the model transformation and an SMT solver makes it
possible to apply those formal methods. As already mentioned above, this allows
for validation and veriﬁcation of systems before any implementation steps are done.
Flaws in these system blueprints can also be analyzed and ﬁxed earlier in the design
process—and in most cases also easier. In this book, we describe and illustrate how
this can be accomplished. To this end, the book is structured with respect to six main
pillars (each covered in a separate chapter):
•
First, we provide a formalization of UML/OCL models as well as corresponding
background information, e.g., on UML/OCL in general and on decision problems
in Chap. 2. The formalization of UML/OCL models is an important ﬁrst step that
allows to reason about a description afterwards. In fact, this formalization is used
in the following Chap. 3 to derive a symbolic formulation of all possible states
a UML/OCL model can assume. Based on this, validation and veriﬁcation tasks
can be employed on top of it.
•
A second pillar addresses questions about how to deal with structural aspects of
UML/OCL models, i.e., inconsistency and (in)dependencies. To this end, Chap. 4
introduces methods to automatically detect contradictions in UML/OCL models
as well as to aid the designer in identifying their source. Besides that, methods
are shown which help to identify (in)dependencies between the constraints. For
all these cases, the symbolic formulation will be utilized.
•
Since the formal models are not restricted to structural aspects only, the third
pillar covered in Chap. 5 considers various behavioral aspects. This requires the
consideration of so-called frame conditions but, then, allows to check, e.g., for
issues such as reachability, live- and deadlocks, executability, etc. Besides that,
this chapter also discusses what has to be done when concurrent behavior is
assumed for a formal model.
•
The fourth pillar leaves the sole functional consideration and additionally
considers timing as a non-functional property which may occur in corresponding
system descriptions. To this end, the symbolic formulation introduced before
is extended to descriptions provided in UML/MARTE models. By this, the
corresponding Chap. 6 shows the generality of the proposed solutions and, at
the same time, covers an important aspect of modern system designs.

1
Introduction
5
•
This generality is further extended in Chap. 7, which represents the ﬁfth pillar of
this book and shows how the symbolic formulation can be re-utilized to deal with
completely different problem ﬁelds. At the same time, it shows how, depending
on the respective problem, the formulation can be improved to accelerate the
solving process.
•
Finally, back to system design, the ﬁnal pillar covers how the results obtained
by the introduced validation and veriﬁcation methods for UML/OCL models can
be utilized in the following (lower) abstraction levels. To this end, Chap. 8 ﬁrst
provides a case study sketching the corresponding possibilities. Afterwards, a
dedicated formal veriﬁcation scheme for re-utilizing veriﬁcation results from the
UML/OCL level, e.g., at the SystemC level is provided.
Overall, a comprehensive overview on validation and veriﬁcation of formal
models is provided which, with increasing complexity of today’s designs, will gain
more and more relevance. The ﬁnal Chap. 9 summarizes this book.

Chapter 2
A Formal Interpretation of UML/OCL
This book aims for the improvement, development, and application of formal
methods for the veriﬁcation and validation of formal models, i.e., UML class
diagrams. For this purpose, a precise formal type system to describe the models
is needed. As UML class diagrams are usually enriched with textual constraints by
means of the Object Constraint Language (OCL) [Obj14], it is beneﬁcial to use the
type system offered by OCL. However, there is no need to introduce the complete
OCL type system, since not all parts of it are considered in this work. For example,
the OCL basic data type real as well as string are not examined and, thus,
omitted.
Afterwards, the type system is utilized to deﬁne classes and associations. Having
these two deﬁnitions, the central deﬁnition of a model follows. Examples as well as
the concept of class inheritance are also provided.
After that, instantiations of models are deﬁned step by step, i.e., objects
(instances of a class), links (instances of an association), and then the deﬁnition
of a system state. For applying formal methods, it is important to differentiate
between valid and invalid system states, thus, a ﬁrst deﬁnition about the validity
of associations is given.
To conclude the solid basement on UML/OCL models, details about the OCL are
explained. The concept of invariants as well as pre- and postconditions is deﬁned.
Furthermore, it is explained how these additional constraints are evaluated for a
given model and system state. Finally, this enables us to complete the deﬁnition of
a valid as well as invalid system states and to come up with a formal meaning for a
consistent and inconsistent model.
The chapter is complemented by a section about decision problems. More pre-
cisely, the Boolean Satisﬁability Problem (SAT) and Satisﬁability Modulo Theories
(SMT) are introduced, deﬁned, and explained by means of examples. The research
results in the ﬁeld of SAT as well as SMT make the corresponding algorithms, so-
called SAT/SMT solvers, an all-rounder tool to tackle different problems. This book
exploits the great success in order to validate and verify models.
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8_2
7

8
2
A Formal Interpretation of UML/OCL
Note that most of the notations which are used in this book are given in this
chapter. All deﬁnitions are explained using examples. Furthermore, a nomenclature
can be found at pages xii and following. It provides all notations used in this book
and can be used as a cheat sheet.
Furthermore, note that, in order to make the book easier to follow and understand,
different fonts as well upper and lowercase letters are used for different purposes.
More precisely, all sets are denoted by uppercase letters and single elements of sets
by lowercase. Furthermore, notations referring to a model and representing inﬁnite
sets are denoted in a calligraphic font (e.g., C and R), while the ﬁnite ones are
set using the Latin alphabet (e.g., C and R). Besides this, Greek letters are used for
the concept of system states (e.g., ˛ and ˇ). As all sets referring to system states
are broken down to ﬁnite sets, there is no need to differentiate between inﬁnite and
ﬁnite sets—details are given later in this work.
2.1
Type System
In order to apply any formal method to models, they have to be formally deﬁned,
or generally spoken, they need a solid basement which is provided in this section.
Therefore, a precise formal type system to describe models is introduced ﬁrst. The
type system is a modiﬁcation of the type system of the Object Constraint Language
(OCL) [Obj14] which includes the Uniﬁed Modeling Language (UML) [RJB05,
Obj15] type system. The presentation is inspired by [Soe13, Sect. 2.1.1. Type
System]. For this book, it is broken down to two basic and several advanced types.
More precisely, it consists of the two basic data types (Boolean and Integer),
and additionally so-called enum-data types as well as classes. On top of these types,
collections are built. Finally, variables are deﬁned to represent actual assignments
of model instances.
The type system T will recursively be deﬁned starting with the basic data types,
Boolean (symbol: B) and Integer (symbol: Z):
T WWD Boolean j Integer:
While regular values belonging to these two types are identical with the mathematic
sets, i.e., B D ftrue; falseg and Z D f: : : ; 1; 0; 1; 2; : : :g,
the OCL type
system also allows for two additional irregular values: invalid (symbol: ?,
from OCL type OclInValid) and null (symbol: –, from OCL type OclVoid).1
However, even if the concept of irregular values is needed for an adequate modeling,
they make it harder to describe examples or explain the proposed approaches. Thus
and for the sake of convenience, this book deals only with the regular values in the
1For more details about the OCL type system, interested readers are referred to the OCL
speciﬁcation [Obj14, p. 211ff.].

2.1
Type System
9
proposed approaches, except for Chap. 3. There, all details about how to represent
regular as well as irregular values in a symbolic formulation are given.
Another basic type are so-called enumerations. An enumeration allows for a
speciﬁc and ﬁnite set of values. Booleans, e.g., can also be seen as a special
enumeration type, since they allow exactly two values. Other examples are the
gender of a person, which might be restricted to female or male in a model,
or the civil status of a person, which might be restricted to single, married,
divorced, and widowed. The (inﬁnite) set of all possible enumerations is
denoted by E and for every element e 2 E a new type is added to the type system
as follows:
T WWD : : : j e:
Additionally, all classes C are also types—their precise concept is introduced
later in this chapter. More precisely, for every class c 2 C the type system is
extended by:
T WWD : : : j c:
In addition to the already introduced types, also collections of them are valid
types of the OCL type system. More precisely, the OCL offers four different
collection types, which are inherited from UML: Set, Bag, OrderedSet, and
Sequence. They can be distinguished by the properties ordered and unique. An
overview is given in Table 2.1. Each collection is a so-called generic type, i.e., it
needs a type as argument and all elements of the collection must be of this type.
Formally, the type system is extended by:
T WWD : : : j Set.T/ j Bag.T/ j OrderedSet.T/ j Sequence.T/:
Obviously, it is possible to nest collection types. This, e.g., makes it possible to have
types like Set(Bag(Integer)) or Sequence(OrderedSet(Boolean)).
Finally, on top of the type system variables can be deﬁned: A variable has an
identiﬁer v and type t 2 T and is denoted as v W t. It can be seen as an actual
instance of a type t which represents a precise assignment of any value of the type t
to v. The set of all possible values of a type is called its universe, its cardinality is
denoted with jtj, and x 2 t means that x is an element of the universe of t.
Table 2.1 Differences of the
four different collections
Collection Type
Ordered
Unique
Set
No
Yes
Bag
No
No
OrderedSet
Yes
Yes
Sequence
Yes
No

10
2
A Formal Interpretation of UML/OCL
For example, p W Integer deﬁnes the variable p of the type Integer and with
p  17 an explicit assignment is given. The set of all variables is denoted with V.
Other types of the OCL type system are, e.g., Pair or in general Tuple,
OclVoid, OclAny, and an abstract Collection. However, they are not used
in the examples and, thus, are not handled in this book. Nevertheless, a comment
concerning OclAny should be given: It is an abstract supertype for all other types,
i.e., a precise value can be of any type. It is comparable to the class Object in Java.
Aside from that, the types Pair and Tuple could easily be integrated into T, but
it would make the transformation rules provided in Chap. 3 harder to understand.
2.2
Classes and Models
This section provides the basic notation for classes and models using the previously
deﬁned type system T and variables V. Models are mainly represented as so-called
class diagrams enriched with textual constraints in OCL.
Deﬁnition 2.1 (Class) A class c D .A; O; I/ is a 3-tuple composed of attributes A,
operations O, and invariants I combined with a name. All three elements are ﬁnite
sets. Each attribute a 2 A is a variable, i.e., a 2 V, and its identiﬁer is unique
within c. An operation o 2 O is a 4-tuple o D .P; r; C; B/ composed of a
(possibly empty) set of parameters P, a return variable r, preconditions C, and
postconditions B. All parameters p 2 P are also variables, i.e., p 2 V. The return
variable r is a variable either of a type in T (i.e., in case the operation really returns
an instance of a type) or OclVoid (i.e., in case the operation returns nothing).
The pre- C and postconditions B as well as the invariants I are ﬁnite sets of OCL
expressions and are explained later in detail.
The (inﬁnite) set of all classes is denoted by C .
Note that C contains an inﬁnite number of classes with the same name but with
differences for the 3-tuple. However, for precise applications, i.e., the veriﬁcation
and validation of concrete models, there will be some restrictions. Details will be
discussed later.
Classes can be linked to other classes or to themselves using association.
Deﬁnition 2.2 (Association)
An association r (also called relation) is an element
of the Cartesian product R WD VC VC .N.N1[f1g//.N.N1[f1g//,
it is formally denoted by r D .rolec1 W c1; rolec2 W c2; .l1; u1/; .l2; u2// 2 R. The ﬁrst
two elements are variables with a precise class instance. The two classes, namely c1
and c2, are not necessarily different. In fact, if they are equal, the association is
called reﬂexive. The identiﬁers of the variables are given by roleci. With these role
names belonging to the association, OCL is able to navigate to another end. The
third and fourth element are representing the multiplicities between the classes, i.e.,
its lower and upper bounds. More precisely, any instance of a class c1 needs to be
connected to at least l1 as well as to at most u1 instances of class c2 and vice versa.

2.2
Classes and Models
11
Note that restricting the multiplicities to one interval per relation end instead of
a set of intervals as originally done in the UML yields to a simpler formalization
without decreasing the expressiveness as other multiplicities can be expressed in
terms of additional OCL constraints. Furthermore, modeling languages such as the
Eclipse Modeling Framework (EMF) [SteC09] do not support multiple intervals
for associations at all without loading additional meta models. The ecore model
format from the EMF provides the possibility to deﬁne a LowerBound as well as an
UpperBound only.
For the sake of simplicity, the book at hand is restricted to binary associations
only, even if the UML allows for n-ary associations with n  2. However, also
this restriction does not decrease expressiveness, since it has been shown that a
model containing n-ary associations can be mapped into a semantically equivalent
model solely composed of binary associations by adding a helping class and some
invariants to the affected classes [GR02a]. Again, the ecore model format does not
support n-ary associations as a core feature.
Additionally, it should be mentioned that there can be more than one relation
between the same classes with identical multiplicities as long as the role names are
different and, equally to classes, R contains an inﬁnite number of relations with
the same variables (i.e., the role names and the types are equal) but with different
multiplicities. Again, there will be some meaningful restrictions for models.
Deﬁnition 2.3 (Model) A model m D .C; R/ is a tuple of classes C  C and
relations R  R where
•
both elements are ﬁnite (sub)sets of the inﬁnite universal sets,
•
all class names are unique in C,
•
the role names belonging to a class c 2 C are unique, and
•
for each class c 2 C the set of all identiﬁers of the corresponding attributes of c
and the set of all identiﬁers of relations where one relation end belongs to the
class c are disjoint.
Deﬁnition 2.4 (Model Elements) All relations of a model together with the union
of all attributes (of all its classes) form the set of model elements.
As already mentioned above, models will be represented using so-called class
diagrams instead of writing the complete notation. For models containing any
enumeration type, these class diagrams will include a visualization of all used
enumeration types.
Example 1 The currently introduced notation is illustrated by a simple access
control system2 which also serves as recurring running example throughout the
remainder of this book. The corresponding model is depicted in Fig. 2.1 as a class
diagram.
2The access control system has originally been presented in [Abr99]. In Sect. 8.1 more details
about the idea of the model are provided. Here, the focus is on the formal notation.

12
2
A Formal Interpretation of UML/OCL
Turnstile
greenLightOn: Boolean
redLightOn: Boolean
currentlyAuthorized: Integer
timeOpen: Integer
type: TurnstileType
goThrough()
advanceTime()
checkCard(card : MagneticCard)
≪enum≫
TurnstileType
Entry
Exit
Building
authorized: Set(Integer)
inside: Set(Integer)
MagneticCard
id: Integer
gates
2..∗
building
1
inv
atLeastOneEntry:
gates->exists( t | t.type = #Entry)
inv
atLeastOneExit:
gates->exists( t | t.type = #Exit)
inv
uniqueID:
MagneticCard.allInstances()->forAll(
card1, card2 |
(card1 <> card2)
implies (card1.id <> card2.id)
)
context Turnstile ::advanceTime():
pre :
greenLightOn = true
or redLightOn = true
post :
(
(
( timeOpen@pre < 2 )
or ( redLightOn = false ) )
and ( timeOpen@pre < 30 )
) implies ( timeOpen = timeOpen@pre + 1 )
post :
(
( timeOpen@pre >= 2 )
and redLightOn
) implies
(
( timeOpen = 0 )
and ( redLightOn = false ) )
post :
(timeOpen@pre >= 30)
implies
(
( timeOpen = 0 )
and ( greenLightOn = false ))
context Turnstile ::checkCard(card : MagneticCard):
pre :
greenLightOn = false
pre :
redLightOn = false
post : (
( building.authorized->includes(card.id) )
and ( type = #Entry <> building.inside->includes(card.id) )
) implies
(
greenLightOn = true
and currentlyAuthorized = card.id)
post :
(not ( building.authorized->includes(card.id) ) )
implies
(redLightOn = true)
context Turnstile ::goThrough():
pre :
greenLightOn = true
post : (
( building.inside@pre->includes(currentlyAuthorized) )
and ( type = #Exit )
) implies
( not building.inside->includes(currentlyAuthorized) )
post : (
( not building.inside@pre->includes(currentlyAuthorized) )
and ( type = #Entry )
) implies
( building.inside->includes(currentlyAuthorized) )
post :
greenLightOn = false
post :
timeOpen = 0
Fig. 2.1 An access control system model
The model consists of three classes, namely, Building, MagneticCard, and
Turnstile, which are visualized with blue boxes in the class diagram where the class
name is in the top part. Since the class MagneticCard has only one attribute and one
invariant, it can be formally denoted as
MagneticCard D .fid W Integerg; ;; funiqueIDg/:

2.2
Classes and Models
13
Analogously, the other two classes can formally be denoted. The enumeration
TurnstileType (with the possible two values Entry and Exit) is visualized like
a class, but with the stereotype preﬁx enum	 in order to differentiate it from
proper classes.
The three operations of the Turnstile class, namely goThrough, advance
Time, and checkCard, do not return any value, i.e., the return type is OclVoid.
Whenever an operation has the type OclVoid, the return variable will simply be
omitted in the corresponding class diagram. This is also the reason why OclVoid
has not explicitly been added as a separate type to the type system.
Additionally, the model contains one relation between the classes Building and
Turnstile, which is formally denoted by
r D .building W Building; gates W Turnstile; .2; 1/; .1; 1//:
The variable identiﬁers or role names of the respective relation ends are building
and gates.
Remark 1 If no role name is given in the class diagram, the default names are the
class name itself in case the upper bound is 1 and the class name plus an additional
plural “s” in case the upper bound is greater than 1. In both cases, the ﬁrst letter of
the class name is assumed to be in lowercase. This is a variation compared to the
UML standard, where the role end name is always the class name with a lowercase
ﬁrst letter (c.f. [Obj15, p. 19]
In the context of modeling, inheritance between classes, which is also called
generalization in the modeling community, is a powerful concept. Unfortunately,
deﬁning class inheritance without a precise model is very hard to formalize because
it implicitly inﬂuences the concrete type system for a given model. An example for
this can be found in Appendix A. However, deﬁning inheritance for precise models
is easier.
Deﬁnition 2.5 (Class Inheritance) Classes can be marked as abstract which
forbids any instantiation. Since the exploration of abstract classes only does not
make much sense, a class can inherit from one or more other classes which are not
necessarily abstract.
Inheritance is a partial order 4 on C for a given model m D .C; R/, where for
csup 4 csub, csup and csub are called the superclass and subclass, respectively.
A proper subclass and a proper superclass are two classes where csup 4 csub and
csup ¤ csub are satisﬁed. For convenience the notation csup  csub is used.
A subclass csub automatically inherits all attributes Asup, operations Osup, and
invariants Isup from the superclass csup. However, it is possible to add more attributes,
operations, and/or invariants, i.e., normally Asup ¨ Asub etc. In this book, a proper
subclass must have at least one new attribute, operation, or invariant. More precisely,
csup  csub implies
Asup 
 Asub ^ Osup 
 Osub ^ Isup 
 Isub
^ .Asup ¨ Asub _ Osup ¨ Osub _ Isup ¨ Isub/:

14
2
A Formal Interpretation of UML/OCL
For convenience, the function
allSub W C ! P.C/
c 7!
˚
c0 2 C
ˇˇc 4 c0
is deﬁned, which returns all proper subclasses and the given class itself due to the
reﬂexivity of partial orders. Analogously, the function allSup is deﬁned and returns
all superclasses including the given class.
Of course, relations are also inherited to all subclasses of c1 and an instance of
the opposite relation end can also be linked to a subclass of c1.
Note that, in class diagrams, inheritance is visualized by a triangle at the
superclass and a line to the subclass and that the inherited attributes, operations,
and invariants are normally omitted in a class diagram. Additionally, it should be
mentioned that the implication for csup  csub does not work the other way around!
The type system in regard to the possible classes for a precise veriﬁcation or
validation task is restricted to the classes in C of a given model m. The type system
also takes the inheritance between the classes into account. More precisely, an
instance of a class can also be the instance of any subclass of the actual class.
2.3
Objects and System States
This section will introduce the concept of class instances, also called objects, links,
as well as the concept of system states which are instances of models.
Deﬁnition 2.6 (Object Instances) Let m D .C; R/ be a given model and c 2 C
be an arbitrary class which is not abstract. Then, an instance of a class is a precise
assignment of values to the attributes of the class c respecting the domain of each
attributes type combined with a name. In the following it will be called object or
object instance. A single object is denoted with  and a set of objects with  .
The objects of a speciﬁc class are written as c, this includes objects of respective
subclasses as well. Objects are the only valid assignments for the variables in VC.
Note that the name of an object is used to refer to it.
Deﬁnition 2.7 (Links) Let m D .C; R/ be a given model and r D .rolec1 W
c1; rolec2 W c2; .l1; u1/; .l2; u2// 2 R be a relation. Then, an instance of a relation is a
so-called link between two object instances c1 and c2 (derived from the classes c1
and c2, respectively). More precisely, it is an element  D .rolec1  c1; rolec2  
c2/ of the Cartesian product c1  c2. The identiﬁers are, in general, necessary
in order to differentiate between possibly various relations between the classes c1
and c2. A set of links is denoted by .
Remark 2 When the context of the relation is clear and, thus, ambiguity is avoided,
a link will be noted using the shorthand  D .c1; c2/.

2.3
Objects and System States
15
Deﬁnition 2.8 (System State) Let m D .C; R/ be a given model. Then  D .; /
is called a system state of m, if
•
both elements,  and , are ﬁnite sets,
•
the object names for the objects in  are unique, and
•
all objects used anywhere in any link  2  are contained in  .
The set of all possible system states for m is denoted by ˙m.
Remark 3 In the UML standard, the object names are optional (cf. [Obj15, p.129]).
Deﬁnition 2.9 (Instantiated Model Elements) The set containing all instances of
all model elements (cf. Deﬁnition 2.4) in a system state , or instantiated model
elements, is denoted by m./. A single element is normally denoted by  2 m./
in this work.
Deﬁnition 2.10 (Validity of an Association in a System State) Let  D .; / be
a system state of a model m D .C; R/. Then, the relations in R are valid or satisﬁed
in the system state , iff
8 r D .rolec1 W c1; rolec2 W c2; .l1; u1/; .l2; u2// 2 R W

8  2 c1 W l1 
ˇˇ˚
.rolec1  ; rolec2  0/ 2 
ˇˇ  u1

^

8  2 c2 W l2 
ˇˇ˚
.rolec1  0; rolec2  / 2 
ˇˇ  u2

Example 2 An example system state for the access control system model from
Fig. 2.1 is illustrated in Fig. 2.2. It consists of two objects of the class Turnstile,
namely Turnstile0 and Turnstile1, and one object of Building, namely Building0.
The system state can formally be denoted by
 D fTurnstile0 W Turnstile D f greenLightOn  false; redLightOn  false;
currentlyAuthorized  0; timeOpen  0;
type  #Exitg;
Building0: Building
authorized =
inside =
Turnstile0: Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = 0
timeOpen = 0
type = Exit
Turnstile1: Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = 0
timeOpen = 0
type = Entry
Fig. 2.2 A system state of the access control system model

16
2
A Formal Interpretation of UML/OCL
Turnstile1 W Turnstile D f greenLightOn  false; redLightOn  false;
currentlyAuthorized  0; timeOpen  0;
type  #Entryg;
Building0 W Building D fauthorized  ;; inside  ;g
g
Both Turnstile instances are connected with Building0 represented by a dashed
line. These dashed lines visualize links for the relation
r D .building W Building; gates W Turnstile; .2; 1/; .1; 1//:
The set of all links for the visualized system state is formally denoted by
 D f.Building0; Turnstile0/; .Building0; Turnstile1/g:
This relation is also satisﬁed in the given system state because each Turnstile
instance is connected to exactly one Building object and the only existing Building
object is connected to at least two Turnstile instances.
2.4
Invariants, Pre-, and Postconditions
The Object Constraint Language (OCL) is a declarative language which allows for
the formulation of constraint expressions among others.3 Constraint expressions
are used together with the model in order to add further restrictions that cannot
be expressed by the given model notation itself. In this book, the three so-called
stereotypes inv for invariant, pre for precondition, and post for postconditions are
considered. They mainly consist of
•
navigation expressions to access model elements (i.e., attributes and relations),
•
logic expressions (i.e., negation, conjunction, disjunction, etc.),
•
arithmetic expressions (i.e., addition, subtraction, multiplication, division, etc.),
and
•
collection expressions (i.e., intersection, union, etc.).
A comprehensive overview of all OCL expressions as well as keywords is given
in [Obj14]. Precise semantic deﬁnitions can also be obtained from [Obj14].
3The OCL can also be used, e.g., as a query language or to describe guards. However, in this
book only constraint expressions in order to specify invariants of classes as well as pre- and
postconditions for operations are considered.

2.4
Invariants, Pre-, and Postconditions
17
While the constraint expressions are added to the model, precise system states are
necessary in order to evaluate them, i.e., to decide if they are satisﬁed or violated.
This implies that the constraints of the three stereotypes can be evaluated to a value
of the type Boolean.
Deﬁnition 2.11 (Evaluation of Invariants) Let m D .C; R/ be a model and  D
.; / a system state of m. Further, let Ic be the set of all invariants for a class
c 2 C. Now, for an invariant i 2 Ic the context where the invariant has to be satisﬁed
is c. More precisely, the invariant has to be satisﬁed for all objects in ;c. Due to the
fact that invariants (as well as pre- and postconditions) are mostly using the keyword
self, directly or implicitly, in order to get the reference to an object instance of the
context class, exactly this reference must be known for an evaluation.
Then, the evaluation of an invariant for a single object  2  is deﬁned by:
evalm;i; W ˙m ! B
 7!
(
true;
if  2 ;c and the evaluation of i holds for self referring to 
false;
else
Then, the evaluation of an invariant for a system state is deﬁned by:
evalm;i W ˙m ! B
 7!
(
true;
if 8  2 ;c W evalm;i;./ D true
false;
else
For the sake of convenience, the shorthand notation .i/ will be used for the
evaluation of an invariant i for a given system state  instead of evalm;i./.
Deﬁnition 2.12 (Valid and Invalid System States) A system state  for a given
model m is called valid, if the evaluation of all invariants Ic of all classes c 2 C
holds and also the relation constraints are satisﬁed (cf. Deﬁnition 2.10). Otherwise 
is called invalid.
Deﬁnition 2.13 (Consistent Models) A model m for which at least one valid
system state exists is called consistent, otherwise m is called inconsistent. The set
of all valid system states for a model m is denoted by Vm.
Example 3 The system state of the running example shown in Fig. 2.3a is invalid
due to several reasons. First, the association between Building and Turnstile is not
satisﬁed: The only building is just connected to one turnstile and the turnstile T1
is not connected to any building. Second, the invariant atLeastOneExit is also
not satisﬁed because the building B1 is not connected to a turnstile whose type is
#Exit.
Figure 2.3b shows a valid system state. Not only the association is valid, but also
all invariants are satisﬁed there. The building is having at least one entry and one
exit. Thus, m is a consistent model.

18
2
A Formal Interpretation of UML/OCL
B1:Building
authorized = {1}
inside =
T1:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
type = #Entry
T2:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
type = #Entry
M1:MagneticCard
id = 1
(a)
B1:Building
authorized = {1}
inside =
T1:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
type = #Entry
T2:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
type = #Exit
M1:MagneticCard
id = 1
(b)
Fig. 2.3 Different system states of the access control system model. (a) An invalid system state.
(b) A valid system state
As mentioned above, the OCL can not only be used to add invariants which
describe which constraints should be satisﬁed in a single system state but also to
describe what should happen during the execution of an operation, i.e., during a
operation call. For this purpose, pre- and postconditions are used.
Deﬁnition 2.14 (Operation Call) Let m D .C; R/ be a model and ; 0 two system
states of m. Furthermore, let c be a class in C which has an operation o and let  be
an object of c with  2 . Then, the pair ! D .; o/ is called an operation call.
In order to invoke a valid operation call !, the evaluation of all preconditions p 2
Co, i.e., all preconditions of the operation o, must hold. Formally, this means:
evalm;! W ˙m ! B
 7!
(
true;
if 8 p 2 Co W evalm;p;./ D true
false;
else
where evalm;p; is the evaluation of a single precondition which can be handled like
an invariant because only one system state is necessary. However, a valid operation
call has to additionally satisfy the postconditions. Since postconditions can use the
@pre marking, the invoking as well as the succeeding system state may be needed
for an evaluation:
evalm;! W ˙m  ˙m ! B
.; 0/ 7!
(
true;
if 8 p 2 Bo W evalm;p;.; 0/ D true
false;
else

2.5
Decision Problems
19
Obviously, for each operation, several operation calls may exist in a system state
depending on the number of objects. The set of all operation calls ˝ for a model m
and a system state  is determined by
˝m; D
[
c2C
cD.A;O;I/
[
o2O
2;c
f.; o/g:
Note that the pre- and postconditions of an operation are also known as contracts.
When enforcing a total order on ˝, each operation call can be assigned a distinct
index between 0 and j˝j  1. A function r˝ W ˝ $ f0; : : : ; j˝j  1g maps an
operation to its index and vice versa.
Example 4 Figure 2.4a shows an invalid operation call because the ﬁrst post-
condition of the operation checkCard with M1 as argument is violated. The
postcondition consists of an implication whose premise holds, i.e., M1 is an
authorized card, the type of it is an entry and M1 is not listed as inside the building.
However, the conclusion is not satisﬁed because the attribute greenLightOn is
still switched off, i.e., false.
In contrast, Fig. 2.4b shows a valid operation call because the pre- as well as the
postconditions are satisﬁed.
2.5
Decision Problems
In this section, Boolean Satisﬁability (SAT) and Satisﬁability Modulo Theories
(SMT) are reviewed and illustrated with examples. Furthermore, the challenges
of solving both problems are sketched. This also includes a review of so-called
SAT/SMT solvers.
2.5.1
Boolean Satisﬁability
Deﬁnition 2.15 Let f W Bn ! B be a Boolean function with Boolean variables
x1; : : : ; xn. Then, the Boolean Satisﬁability problem (SAT problem) is to determine
an assignment a for the variables x1; : : : ; xn such that f evaluates to true/1 or to
prove that no such assignment exists.
A given Boolean function f (with an actual mapping) is a precise instance of the
SAT problem, also called SAT instance. The function f is called satisﬁable if there
is an assignment a such that f evaluates to true/1, and it is called unsatisﬁable if
it has been proven that no such assignment exists.
Example 5 Let f.x1; x2; x3/ D .x1 C x2 C x3/.x1 C x2/.x2 C x3/. Then, a D fx1  
1; x2  1; x3  1g is a satisfying assignment for f. The value of x1 ensures that the

20
2
A Formal Interpretation of UML/OCL
B1:Building
authorized = {1}
inside =
T1:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
type = #Entry
T2:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
type = #Exit
M1:MagneticCard
id = 1
B1:Building
authorized = {1}
inside =
T1:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = 1
timeOpen = 0
type = #Entry
T2:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
type = #Exit
M1:MagneticCard
id = 1
T1.checkCard(M1)
(a)
(b)
B1:Building
authorized = {1}
inside =
T1:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
entry = true
T2:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
entry = false
M1:MagneticCard
id = 1
B1:Building
authorized = {1}
inside =
T1:Turnstile
greenLightOn = true
redLightOn = false
currentlyAuthorized = 1
timeOpen = 0
entry = true
T2:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
entry = false
M1:MagneticCard
id = 1
T1.checkCard(M1)
Fig. 2.4 Different transitions of the access control system model. (a) An invalid transition between
two system states. (b) A valid transition between two system states
ﬁrst clause becomes satisﬁed, the value of x2 ensures this for the second clause, and
the value of x3 ensures this for the remaining clause.
Example 6 Let g.x1; x2; x3/ D x1.x1 Cx2/.x1 Cx3/.x2 Cx3/. Then, Table 2.2 proves
that g is unsatisﬁable because independently from the input values, g evaluates
always to false/0.
There are many ways to deﬁne the precise mapping relation of a Boolean
function. A truth table, e.g., is an explicit way. However, they are getting very huge
quickly due to the exponential growth. In the following, Boolean functions given
by an equation are analyzed. Besides the conjunctive normal form (CNF) used

2.5
Decision Problems
21
Table 2.2 A truth table
showing that g.x1; x2; x3/ D
x1.x1 C x2/.x1 C x3/.x2 C x3/
is unsatisﬁable.
x1
x2
x3
.x1 C x2/
.x1 C x3/
.x2 C x3/
g
0
0
0
1
1
0
0
0
0
1
1
0
1
0
0
1
0
0
1
1
0
0
1
1
0
0
1
0
1
0
0
1
1
0
0
1
0
1
1
1
1
0
1
1
0
1
1
1
0
1
1
1
1
1
1
0
in the last two examples, the disjunctive normal form (DNF) is another common
way. A CNF is a conjunction of disjunctions, while a DNF is a disjunction of
conjunctions. A disjunction can be seen as a sum of literals, which are either a
variable or a negation of a variable, and a conjunction as the product of literals.
Note that the sum of literals of Boolean variables is 1, if at least one of the
variables is assigned to 1 or a negated variable to 0. A product of literals of Boolean
variables is 1, if all variables are assigned to 1 and all negated variables to 0.
When a Boolean function f is given as a DNF, it is possible to prove that f is
satisﬁable (or unsatisﬁable) in a linear time complexity with respect to the number
of conjunctions. An algorithm could work as follows: Check if the ﬁrst conjunction
is satisﬁable. A conjunction (of literals only) is always satisﬁable, if all variables
have been used as either a variable or a negated variable or not at all. A satisfying
assignment is given by assigning all not-negated variables of the conjunction to 1,
the negated variables to 0, and the not-used variables arbitrarily. However, if the
conjunction is unsatisﬁable, try to determine a satisfying assignment for the next
conjunction. If there is no more conjunction left, then the DNF is unsatisﬁable.
Unfortunately, proving that a Boolean function given in CNF is satisﬁable or
not is not that easy. In 1971 Cook has proven that the SAT problem for a Boolean
function given in CNF in general is NP-complete [Coo71]. In fact, it was the
ﬁrst found NP-complete problem and today it is still one of the central NP-
complete problems. In 1972, Richard Karp presented a work in which he proved 21
combinatorial and graph theory based problems to be NP-complete, e.g., clique,
(un-)directed Hamilton circuit, chromatic number, or Knapsack [Kar72]. The proofs
are based on polynomial time many-one reductions to SAT at the end.
The question is now why should someone bother himself with Boolean functions
given in CNF when a DNF is much easier to handle. The answer lies in the nature of
most problems, because we normally add conditions to problems which should be
also satisﬁed, i.e., constraints are connected with conjunctions. Unfortunately, the
transformation of a CNF into a DNF requires exponential space in average.
Thankfully, in the last decades many efﬁcient solving algorithms, so-called
SAT solvers, have been proposed (see, e.g., [BB09]). Instead of simply traversing
the complete space of assignments, intelligent decision heuristics, conﬂict-based
learning, and sophisticated engineering of the implication algorithm by Boolean

22
2
A Formal Interpretation of UML/OCL
Constraint Propagation (BCP) lead to an effective search procedure. Due to these
efﬁcient algorithms, SAT instances composed of hundreds of thousands of variables,
millions of clauses, and tens of millions of literals can be handled.
2.5.2
Satisﬁability Modulo Theories
Besides Boolean Satisﬁability, the Satisﬁability Modulo Theories (SMT) problem
is another decision problem which offers different theories to describe a problem.
There are theories, e.g., for integers and reals as well as data types like lists or
arrays. In the book at hand, the following theory will be used: quantiﬁer-free Bit-
vector Logic (QF_BV). QF_BV allows to work on bit vector logic rather than pure
Boolean logic. It will be used, e.g., to represent integer attributes of UML/OCL
models with a single (bit vector) variable only. Theories for integers and reals are
not considered, because they can make precise veriﬁcation tasks to be undecidable
in a general case.
In the following, precise SMT instances are provided in the SMT-LIB syntax
speciﬁed in [BFT16]. Here, each constraint is provided following the Polish
notation, i.e., each operation is encapsulated by parenthesis and the operator is
provided before the list of (ordered) operands. An SMT-LIB constraint can also
be visualized using so-called Abstract Syntax Trees (AST). Then, an operation is a
node and childnodes are the operands, in a maybe nested manner.
Example 7 Consider the following SMT instance with two formulas in SMT-LIB
syntax, where bv1 and bv2 are bit vectors of size 44:
1 (declare-fun bv1 () (_ BitVec 4))
2 (declare-fun bv2 () (_ BitVec 4))
3 (assert (not (= bv1 bv2) ))
4 (assert (= ((_ extract 1 1) bv2) #b1))
The ﬁrst two lines declare bv1 and bv2 as bit vectors of length 4. Lines 3 and 4
show assertions (assert) which a valid assignment of bv1 and bv2 has to satisfy.
The ﬁrst assertion in Line 3 is composed of two operations, namely negation (not)
and equivalence (=) and states that the bit vectors bv1 and bv2 shall differ in at
least one position, i.e., in a symbolical notation bv1 ¤ bv2. The second assertion
illustrates how to access individual bits of a bit vector, namely using the extract
operation with the indices of the ﬁrst and last extracted bit being equal, as well as
how to use constant values (#b...). Overall, the constraint enforces that the second
to last bit5 of the bit vector bv2 is set to 1. Solving this SMT instance may lead to
the assignments bv1 = #b1101 and bv2 = #b1010.
4The preﬁx #b indicates that a binary string is following.
5The bits of a bit vector are enumerated using least signiﬁcant bit numbering, i.e., from right to left
starting with 0.

2.5
Decision Problems
23
Example 8 Let ˛ be a given bit vector with the bit string #b10110 and it is
searched for a second bit vector ˇ in which exactly one bit is 1 and the bit of ˛
with the same number must be also 1.6 One possibility for this problem is:
1 (declare-fun ˛ () (_ BitVec 5))
2 (declare-fun ˇ () (_ BitVec 5))
3 (assert (= ˛ #b10110))
4 (assert ((_ card_eq 1) ˇ))
5 (assert ((_ card_eq 1) (bvand ˛ ˇ )))
The ﬁrst two line declares the two bit vector ˛ and ˇ. The constraint of the assertion
in Line 3 ensures that a satisfying assignment must ensure that ˛  #b10110.
Line 4 enforces that a satisfying assignment for the bit vector ˇ must have exactly
one bit equal to 1 using a so-called cardinality constraint. This cardinality constraint
is not a part of the standard SMT-LIB, however, in [RieC14] it has been explained
how such constraints can be added to the SMT-LIB.
In the last line, it is ensured that the result of the bit-wise conjunction of ˛ and ˇ
also has exactly one bit equal to 1. Due to the other constraints, the number of this
bit must be one of those numbers where the same bit of ˛ is equal to 1.
Note that in the remainder of the book, only the inner constraints of assertions
will be given, since this will be always the important part.
For a detailed list of all operators and the logic descriptions the reader is referred
to [BFT16]. However, the expressions used in the remainder of this book are self-
explaining and if not, an explanation will be given. Finally, it should explicitly
be mentioned that SAT as well as SMT problem instances in general are denoted
in a declarative language. This means that a constraint like (= ˛ ˇ) is not an
assignment. Instead in order to ﬁnd a satisfying assignment for the constraint both
variables might be assigned to meaningful values.
SMT problems are solved by SMT solvers. Prominent examples are Boolec-
tor [BB09, NPB15], CVC4 [BarC11], MathSAT4 [BruC08]/MathSAT5 [CimC13],
and Z3 [MB08]. As a core function they provide the possibility to solve (normal)
SAT problems. In addition, they offer functions to declare new sorts, i.e., new data
types a user might need. Enum-data types can be, e.g., represented by deﬁning
a new sort. Furthermore, SMT solvers provide different libraries to model real
numbers, strings, and/or integers—more or less without any bounds—or the usage
of quantiﬁers. To solve SMT problems dealing with those unbounded types or
quantiﬁers, sophisticated automated reasoning techniques are internally applied and
the SMT solver will determine a witness (SAT), answer that there is no solution
(UNSAT), or unknown which means that the SMT solver could not decide whether
there is a solution or not.
6The problem is comparable to a textual description of the OclAny operation transformed into bit
vector logic.

Chapter 3
A Symbolic Formulation for Models
Research on the UML has a long history. Since the ﬁrst publication of the UML and
OCL standard in the 1990s, a great evolution was passed with regard to several ﬁelds
such as modeling accuracy, expressiveness, correctness, and usability. In parallel,
also the techniques for the (automated) validation and veriﬁcation of UML/OCL
models evolved.
Until around 2007, model analysis focused on the analysis of a given system
state with respect to a given model. Well-known tools here are the UML-based
Speciﬁcation Environment (USE) [GBR07] and DresdenOCL [DW09]. So far, also
in this book an actual system state was evaluated with respect to a given model,
but as system design relies on models, not on actual system states (which are a
result of the system model), it is much more interesting for the designer to evaluate
the model itself. This means addressing the question is the model consistent or not
(cf. questions in Chap. 1). In order to do so, the question becomes whether it is
possible to derive a valid system state from a given model. This veriﬁcation task has
been recently introduced as consistency (cf. Deﬁnition 2.13).
At a ﬁrst glance, it might be easy to show that a given model is consistent as
giving a valid system state as a witness is sufﬁcient to do so. But it turns out to
be a hard problem in a general case. In fact, veriﬁcation is EXPTIME-hard for
UML class diagrams and becomes undecidable with the inclusion of general OCL
constraints [BCD05]. The problem is commonly called model checking or model
ﬁnding1 and the tools are model checkers or model ﬁnders.
While USE has been extended with different approaches to ﬁnd a valid system
state since publishing the ﬁrst version, DresdenOCL does not provide any functions
for this. An example for a straightforward model ﬁnder is the ﬁrst approach within
USE which is based on a script language called A Snapshot Sequence Language
(ASSL) [GBR03, GBR05]. It enumerates all possible system states and stops with
1The term model ﬁnding comes from the fact that models as introduced in Chap. 2 are also called
meta-models and the instances of those meta-models are consequently also called models.
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8_3
25

26
3
A Symbolic Formulation for Models
the ﬁrst valid system state. To cope with the inﬁnite data types of the UML or just
a huge one, the designer can restrict the ranges of attribute values. The designer can
also specify the order of the attributes to be assigned. By doing so, the number of all
possible system states to be enumerated can be decreased in a good case. However,
enumerating all system states is a most time-consuming task, in many cases also
inefﬁcient, since in a worst-case scenario all system states have to be checked. Even
for small models, this can make the runtime escalate easily. Due to the restriction
to ﬁnite universes for the model elements, the ASSL approach can be classiﬁed as a
simple kind of Bounded Model Checking (BMC). Later, also a so-called USE Model
Validator has been published as a USE plugin which is based on [KG12] and applies
several model transformations: basically, ﬁrst from UML/OCL to relational logic
(using Kodkod, [TJ07]) and from there to a SAT problem.2 By this, USE provides a
much better model ﬁnder compared to the situation before with ASSL only.
In contrast, this book covers a direct model transformation from UML/OCL to
SAT/SMT to perform a more sophisticated kind of BMC compared to ASSL and
without any detours using relational logic compared to the USE Model Validator
in order to validate and verify UML/OCL model properties as, e.g., the recently
discussed consistency. The ﬁrst ideas go back to [SoeC10]. For this purpose, two
things are needed: 1. a general ﬂow for the model ﬁnding with a direct model
transformation to SAT/SMT and 2. transformation rules mapping all elements of
the model (e.g., model elements and OCL expressions) to SAT/SMT elements (i.e.,
variables and constraints).
The presented model ﬁnding ﬂow is permanently used in this book to produce
a symbolic representation of a system state. More precisely, this symbolic repre-
sentation is capable of representing all possible system states. For this purpose,
it consists of variables representing the values of attributes and associations of a
given model as well as constraints using that very variables, e.g., for the association
multiplicities or the invariants. In order to validate and verify different model
properties, i.e., other veriﬁcation tasks than consistency, more constraints are added
to the symbolic representation. In some cases also additional variables are added.
When the construction of the symbolic representation is done, the decision problem
to be solved is to ﬁnd an assignment to the variables such that all constraints
are satisﬁed. This can be done using SAT or SMT solvers. The result has to be
interpreted in the context of the given model and the applied veriﬁcation task.
The general model ﬁnding ﬂow to ﬁnd a valid system state for a given model
is explained in Sect. 3.1 (based on [PrzC17]). It will be exploited to tackle all
the problems described in this book. Within the model ﬁnding ﬂow, a model
transformation will be applied. In Sect. 3.2 (also based on [PrzC17]), the general
transformation rules from a model to a symbolic representation are introduced.
Afterwards, in Sect. 3.3 (based on [PrzC16c]), veriﬁcation tasks for both, structural
and behavioral aspects, are deﬁned and it is also shown how they are added on
top of the symbolic formulation by adding more constraints and if necessary also
more variables. Finally, in Sect. 3.4 (based on [PrzC16b]) other approaches for the
validation and veriﬁcation of UML/OCLs are discussed.
2More details will be discussed later in Sect. 3.4.

3.1
A General Flow for Automatic Veriﬁcation and Validation
27
3.1
A General Flow for Automatic Veriﬁcation
and Validation
Consider the following scenario: Let a model m be given. The question is now,
whether m is consistent or not. Sometimes consistency is trivial to prove as only
one trivial class is sufﬁcient to obtain a valid system state. But what if there is no
trivial class? A naive method to answer this question is to create system states with
exactly one object of one class after the other and enumerate all possible values for
the attributes and stop when the ﬁrst valid solution has been found—as mentioned
before, this is the ASSL approach of USE [GBR07, GBR03, GBR05]. However, there
are lots of problems coming up using such a naive method. First, how to enumerate
over an inﬁnite set, e.g., integers, strings, or reals? Second, assuming that one has
checked all possible assignments of the system states without any success, how
should one proceed? Increase the number of objects per class? If yes, increase the
object instances for all classes at the same time? Or is it better to just increase the
number of one class? And when should one stop trying more instances and start with
the next one? Thus, it should be clear that answering the question of consistency is
not that easy in general—and the same holds for other veriﬁcation tasks introduced
later.
Considering ASSL, most of the questions above must be answered by the designer
by writing a corresponding script. Basically each inﬁnite type must be restricted to
a ﬁnite one. For example, the number of possible object instances must be explicitly
deﬁned within the script and for each integer attribute a ﬁnite subset of Z must be
chosen. For associations, the designer must write loops trying all possible links.
Consequently, disadvantages of ASSL are the facts that the designer has to learn
ASSL itself and that he has to write the script himself. The last part includes that
the designer has to take care about the order in which all possible system states are
enumerated. If, on the one hand, the designer has a good knowledge and experience
in writing such scripts, ASSL may ﬁnd a system state quickly. But if the designer has
no expert knowledge and, thus, takes a bad choice for the order, ASSL might take
much more time or maybe exceed a time limit. For such reasons a fully automatic
approach is preferable which, of course, should be powerful and efﬁcient at the same
time. SAT and SMT solvers provide a good base for such an automatic approach, but
they do not accept a UML/OCL model as an input. So, a given UML/OCL model
with a veriﬁcation task has ﬁrst to be transformed into something which SAT/SMT
solvers can deal with: a symbolic description in terms of SMT-LIB syntax.
Hence, a precise ﬂow for the transformation of a UML/OCL model to such a
symbolic formulation is needed. Figure 3.1 illustrates the ﬂow which is used in this
book. There are ﬁve different steps visualized by boxes with numbers in the upper
right corner and arrows between the boxes.
In the ﬁrst step, the designer must select a UML/OCL model m, i.e., the UML
class diagram enriched with textual constraints using OCL. In Fig. 3.1, the access
control system model as already used in Chap. 2 is exemplarily displayed in the box.

28
3
A Symbolic Formulation for Models
Turnstile
greenLightOn: Boolean
redLightOn: Boolean
currentlyAuthorized: Integer
timeOpen: Integer
type: TurnstileType
goThrough()
advanceTime()
checkCard(card : MagneticCard)
≪enum≫
TurnstileType
Entry
Exit
Building
authorized: Set(Integer)
inside: Set(Integer)
MagneticCard
id: Integer
gates
2..∗
building
1
inv atLeastOneEntry:
gates->exists( t | t.type = #Entry)
inv atLeastOneExit:
gates->exists( t | t.type = #Exit)
inv uniqueID:
MagneticCard.allInstances()->forAll(
card1, card2 |
(card1 <> card2)
implies (card1.id <> card2.id)
)
context Turnstile::advanceTime():
pre :
greenLightOn = true
or redLightOn = true
post : (
(
( timeOpen@pre < 2 )
or ( redLightOn = false ) )
and ( timeOpen@pre < 30 )
) implies ( timeOpen = timeOpen@pre + 1 )
post : (
( timeOpen@pre >= 2 )
and redLightOn
) implies
(
( timeOpen = 0 )
and ( redLightOn = false ) )
post : (timeOpen@pre >= 30)
implies
(
( timeOpen = 0 )
and ( greenLightOn = false ))
context Turnstile::checkCard(card : MagneticCard):
pre : greenLightOn = false
pre : redLightOn = false
post :(
( building.authorized->includes(card.id) )
and ( type = #Entry <> building.inside->includes(card.id) )
) implies
(
greenLightOn = true
and currentlyAuthorized = card.id)
post : (not ( building.authorized->includes(card.id) ) )
implies
(redLightOn = true)
context Turnstile::goThrough():
pre : greenLightOn = true
post :(
( building.inside@pre->includes(currentlyAuthorized) )
and ( type = #Exit )
) implies
( not building.inside->includes(currentlyAuthorized) )
post :(
( not building.inside@pre->includes(currentlyAuthorized) )
and ( type = #Entry )
) implies
( building.inside->includes(currentlyAuthorized) )
post : greenLightOn = false
post : timeOpen = 0
UML/OCL Model
Problem bounds:
#Turnstile = 4
#Building = 2
#MagneticCard = 4
B0: Building
authorized ←?
inside ←?
B1: Building
authorized ←?
inside ←?
T1: Turnstile
greenLightOn ←?
redLightOn ←?
currentlyAuthorized ←?
timeOpen ←?
type ←?
T0: Turnstile
greenLightOn ←?
redLightOn ←?
currentlyAuthorized ←?
timeOpen ←?
type ←?
T2: Turnstile
greenLightOn ←?
redLightOn ←?
currentlyAuthorized ←?
timeOpen ←?
type ←?
T3: Turnstile
greenLightOn ←?
redLightOn ←?
currentlyAuthorized ←?
timeOpen ←?
type ←?
M1: MagneticCard
id ←?
M0: MagneticCard
id ←?
M2: MagneticCard
id ←?
M3: MagneticCard
id ←?
gates - building?
gates - building?
gates - building?
gates - building?
gates - building?
gates - building?
gates - building?
gates - building?
Un-assigned System State
Precise Decision Problem Formulation
using SAT, SMT, CSP, ...
1
2
3
5
Generic Symbolic Representation
T0
greenLightOn : B,
T0
redLightOn : B,
T0
cA : Z,
T0
timeOpen : Z,
T0
type : TurnstileType,
T1
greenLightOn : B,
T1
redLightOn : B,
T1
cA : Z,
T1
timeOpen : Z,
T1
type : TurnstileType,
T2
greenLightOn : B,
T2
redLightOn : B,
T2
cA : Z,
T2
timeOpen : Z,
T2
type : TurnstileType,
T3
greenLightOn : B,
T3
redLightOn : B,
T3
cA : Z,
T3
timeOpen : Z,
T3
type : TurnstileType,
B0
authorized : Z →B,
B0
inside : Z →B,
B1
authorized : Z →B,
B1
inside : Z →B,
M0
id : Z,
M1
id : Z,
M2
id : Z,
M3
id : Z
. ..
4
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
1 (declare-fun
Turnstile0
greenLightOn () Bool)
2 (declare-fun
Turnstile0
redLightOn () Bool)
3 (declare-fun
Turnstile0
currentlyAuthorized () (_ BitVec 8))
4 (declare-fun
Turnstile0
timeOpen
() (_ BitVec 8))
5 (declare-fun
Turnstile0
type
() (_ BitVec 1))
6 ...
a
a
a
a
a
Fig. 3.1 Transforming a model with many steps into a precise decision problem
In the second step, the designer has to deﬁne so-called problem bounds. They
restrict the number of objects per class to some ﬁnite value and, thus, also ensure that
the system state contains a ﬁnite number of objects. Problem bounds are a simple
map in which for each (nonabstract) class the precise number of object instances per
class is deﬁned.3
3The problem bounds will be extended later, e.g., for providing an interval instead of only a ﬁxed
number for the object instances or the number of system states, when a sequence of system states
is considered.

3.1
A General Flow for Automatic Veriﬁcation and Validation
29
In the third step, the two inputs of the preceding steps are used to automatically
derive an un-assigned system state, i.e., no further action by the designer is required
in this step. For each (nonabstract) class, objects are created whereby the number
of objects depends on the problem bounds. An object contains for each attribute
of its corresponding class a variable with the same name as the attribute. Since an
assignment to all variables shall be found, all variables are un-assigned for now.
In the ﬁgure, this is denoted, e.g., by authorized  ? Furthermore, the links
are also unclear. Therefore, every possible link is also illustrated in the un-assigned
system state by a dashed line with a box in between. In the box the names of the two
association ends followed by a ? are, again, indicating that it is unclear whether this
link exists or not.
But again, the question is how to ﬁnd an assignment such that the system state
is valid and, thus, provides a witness, e.g., for the consistency problem. At the
beginning of this section it has been explained that ASSL can tackle this problem,
however, it is not suitable for the desired automatic approach.
On these grounds, in the fourth step the model, the problem bounds, and the
un-assigned system state derived from both aforementioned ones are automatically
transformed into a generic symbolic formulation or symbolic representation, i.e., a
list of variables as well as a list of constraints. For this purpose, all the attributes and
all possible instances of associations have to be transformed into unique variables.
Uniqueness has to be guaranteed because a variable name must be unique within the
list of all variables of the symbolic formulation and not only within an object. For
example, the variable authorized in Fig. 3.1 appears for each object instance
of Building. Since the attributes of the system state themselves are just variables,
this will be quite easy for Boolean and integer attributes. However, for collection
typed attributes and associations it will be shown in the next section that it is not
that obvious. The constraints of the symbolic formulation should ensure that a valid
assignment to the variables indeed represents a valid system state. Constraints have
to be added, e.g., for the association multiplicities and the invariants.
In order to determine a valid (also called satisfying) assignment of the symbolic
formulation, existing powerful and efﬁcient solvers shall be used. Using those
solvers, the designer can get rid of the problems discussed at the beginning of
this section, but the symbolic formulation has to be further transformed into an
input language for those solvers. In this work, it will be explained how a symbolic
formulation in SMT-LIB syntax can be generated such that SMT solvers can be
used. The transformation from the generic symbolic formulation to a precise SMT-
LIB realization is the ﬁfth step of the proposed model checking ﬂow and can
automatically be conducted.
Of course, it would also be possible to skip the generic symbolic formulation
and directly obtain a formulation for SMT solvers. However, in this case it would be
not that easy to adopt the general ideas to another decision problem language, e.g.,
ASP or CSP. Nevertheless, the generic symbolic formulation may have a touch of
an SMT speciﬁc one for experts in this area.
The SMT-LIB realization will make use of quantiﬁer-free Bit-vector Logic
(QF_BV) and it will not make use of the full wide range modern SMT solvers

30
3
A Symbolic Formulation for Models
nowadays usually provide. This has several reasons: One reason is the fact that the
goal is to get rid of inﬁnite sets and undecidable results. For this purpose, e.g.,
integers are represented by bit vectors of a ﬁxed size instead of using an SMT
library which would support proper integers. Using such a library would enforce the
SMT solver to internally apply some strategies for deriving a satisfying assignment
(or to prove that none exists), but due to the inﬁnite ground set, the result might be
unknown, i.e., the SMT solver could not make a decision. The limited resources in a
real system are another reason. They can cause, e.g., over- or underﬂows which
are not detectable when using an SMT integer library. But when transforming
everything into bit vectors the SMT solver is always able to decide if there is a
satisfying assignment or not—the only exception is an acceptable run time of the
SMT solver. The derived SMT formula with bit vectors is one type of so-called
bounded model checking.
If a precise SMT formulation has been derived, it can be passed to an SMT
solver—in this book Z3 [MB08] will mainly be used. If the result is SAT, values for
attributes and links in the system state can be derived from the satisfying assignment.
Now, the system state generated in step 3 is no more un-assigned but an assigned
and valid system state. The designer is now required to interpret it in the context
of the provided model, the problem bounds and the veriﬁcation task. If otherwise,
the SMT solver returns UNSAT, no assignment for the system state can be derived
and the designer has to interpret this again in the context of the provided model, the
problem bounds, and the veriﬁcation task.
The automatic generation of an un-assigned system state in step 3 is easy and
straightforward. However, the generic symbolic formulation and the precise SMT-
LIB realization in steps 4 and 5, respectively, are absolutely not trivial to implement.
Thus, the next section will describe all necessary transformation rules in detail.
3.2
Transforming a Model into a Symbolic Formulation
In the following, it is assumed that the model m D .C; R/, problem bounds as well
as the un-assigned system state as described in the last section are given in order to
create a symbolic formulation representing all possible system states  D .; / of
the un-assigned system state. The symbolic formulation is divided into subsections
for the attributes, associations, the handling of a variable number of objects within
the problems, the support of the 4-valued OCL logic and ﬁnally one subsection
about the transformation of OCL constraints into constraints for the symbolic
formulation. In all those subsections, at ﬁrst, the generation of the generic symbolic
formulation will be explained coming from the un-assigned system state. This
conforms step 4 in Fig. 3.1. Afterwards, the introduced transformation rules are
realized using bit vector variables only in the SMT-LIB syntax, cf. step 5 in Fig. 3.1.
Of course, examples are also used to illustrate all steps.

3.2
Transforming a Model into a Symbolic Formulation
31
The generic symbolic formulation uses not only variables from the type system T
but also map-based types. They can be seen as a composition of variables of the
earlier introduced type system and are used to derive a reasonable representation for
the collection types.
3.2.1
Transforming Attributes
To symbolically represent all possible assignments of the un-assigned system state
 D .; /, for each attribute of each object instance in  a variable is created.
Transformation Rule 1 (Boolean Attributes) Let a 2 A be a Boolean attribute
where the set of attributes A belongs to a class c. Then for all object instances  of c
and also the subclasses, i.e., formally for all  2 c, a variable ˛
a W B is created.
Transformation Rule 2 (Integer Attributes) Let a 2 A be an integer attribute
where the set of attributes A belongs to a class c. Then for all object instances  in
c a variable ˛
a W Z is created.
Transformation Rule 3 (Enum Attributes) Let a 2 A be an attribute of an enum
data type e 2 E . Again, the set of attributes A belongs to a class c and the enum data
type e has k different values. These values are mapped using a bijective function
to the set f0; : : : ; k  1g. Then, for all object instances  in c a variable ˛
a W
f0; : : : ; k  1g is created.
Transformation Rule 4 (Class Attributes) Let a 2 A be an attribute of a class
type c0 where the set of attributes A belongs to a class c. Then for all object
instances  in c a variable ˛
a W c0 is created.
Note that the universe of c0 consists of all object instances of c0 as well as all its
subclasses. Consequently, it is a ﬁnite set which is known because of the provided
problem bounds.
Transformation Rule 5 (Collection Type Attributes) Let a 2 A be a collection
typed attribute where the set of attributes A belongs to a class c. Further, let t denote
the generic type of the collection.
If a is a set, then for all object instances  in c a variable ˛
a W t 7! B is
created, where ˛
a .x/ denotes for the element x 2 t whether it is contained in the set
(˛
a .x/ D true) or not (˛
a .x/ D false).
If a is a bag, then for all object instances  in c a variable ˛
a W t 7! N is
created. The universe of such a map based type consists of all possible mappings
from the universe of t to N. Naturally, ˛
a .x/ represents the number of copies of x 2 t
in the bag.
If a is an ordered set, then for all object instances  in c a variable ˛
a W t 7! N
is created. For x 2 t, ˛
a .x/ D 0 means that x is not an element of the ordered
set since the index of the ﬁrst element in OCL is 1. Otherwise, i.e., ˛
a .x/ ¤ 0, the
map returns the position index of x. In order to ensure a proper representation of an

32
3
A Symbolic Formulation for Models
ordered set, the variable, i.e., the precise mapping, must be restricted: For all x 2 t
with being in the ordered set, the position index must be unique and if the position
index is greater or equal than 2 a predecessor must exist. Formally this is
8 x 2 t W ˛
a .x/ > 0)

8 y 2 t n fxg W ˛
a . y/ ¤ ˛
a .x/

(3.1)
and
8 x 2 t W ˛
a .x/  2)

9 y 2 t W ˛
a . y/ D ˛
a .x/  1

(3.2)
If a is a sequence, then for all object instances  in c a variable
˛
a W t 7! P.N n f0g/ [ ff0gg
is created, whereby the following restrictions are added
8 n 2 N; n  1 W

9 x 2 t W n 2 .˛
a /.x/

)

8 y 2 t n fxg W n 62 .˛
a /. y/

(3.3)
—for a unique position index—and
8 n 2 N; n  2 W

9 x 2 t W n 2 .˛
a /.x/

)

9 y 2 t W n  1 2 .˛
a /. y/

(3.4)
—for the existence of predecessors.
Note that an additional limitation of N for ordered sets is possible when the
respective universe is ﬁnite, however, for a general symbolic formulation this does
not matter, but for the precise SMT realization it matters as it will be shown.
Example 9 Let’s assume the model m is the access control system as depicted in
Fig. 2.1 (and the model veriﬁcation ﬂow in the box for step 1 in Fig. 3.1). Further,
let’s assume the problem bounds #Turnstile = 4, #Building = 2, #MagneticCard = 4
as depicted in the box for step 2 in Fig. 3.1 yielding to the un-assigned system state
(step 3) visualized in Fig. 3.2.
In the next step, the ﬁve currently introduced transformation rules for attributes
are applied to derive variables which are needed to represent all system states in a
symbolic fashion. Figure 3.3 shows a list of all variables created for the attributes in
Fig. 3.2.
SMT-LIB Realization of Transformation Rule 1.
The variables for Boolean
attributes ˛
a W B are realized with the SMT-LIB type Bool in the SMT QF_BV
realization of the symbolic formulation. They are formally denoted by ˛
a W B1 and
the SMT-LIB declaration is
1 (declare-fun ˛
a () Bool)
Using the SMT-LIB Bool type, a speciﬁc assignment can be enforced with
true or false. In fact, assigning a single bit to a Bool variable would be an

3.2
Transforming a Model into a Symbolic Formulation
33
B0: Building
authorized ←?
inside ←?
B1: Building
authorized ←?
inside ←?
T1: Turnstile
greenLightOn ←?
redLightOn ←?
currentlyAuthorized ←?
timeOpen ←?
type ←?
T0: Turnstile
greenLightOn ←?
redLightOn ←?
currentlyAuthorized ←?
timeOpen ←?
type ←?
T2: Turnstile
greenLightOn ←?
redLightOn ←?
currentlyAuthorized ←?
timeOpen ←?
type ←?
T3: Turnstile
greenLightOn ←?
redLightOn ←?
currentlyAuthorized ←?
timeOpen ←?
type ←?
M1: MagneticCard
id ←?
M0: MagneticCard
id ←?
M2: MagneticCard
id ←?
M3: MagneticCard
id ←?
gates - building?
gates - building?
gates - building?
gates - building?
gates - building?
gates - building?
gates - building?
gates - building?
Fig. 3.2 An un-assigned system state
T0
greenLightOn : B,
T0
redLightOn : B,
T0
cA : Z,
T0
timeOpen : Z,
T0
type : TurnstileType,
T1
greenLightOn : B,
T1
redLightOn : B,
T1
cA : Z,
T1
timeOpen : Z,
T1
type : TurnstileType,
T2
greenLightOn : B,
T2
redLightOn : B,
T2
cA : Z,
T2
timeOpen : Z,
T2
type : TurnstileType,
T3
greenLightOn : B,
T3
redLightOn : B,
T3
cA : Z,
T3
timeOpen : Z,
T3
type : TurnstileType,
B0
authorized : Z →B,
B0
inside : Z →B,
B1
authorized : Z →B,
B1
inside : Z →B,
M0
id : Z,
M1
id : Z,
M2
id : Z,
M3
id : Z
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
Fig. 3.3 List of variables for the attributes
Note that currentlyAuthorized is abbreviated with cA
invalid statement. This also makes it easier to differentiate between Booleans and
bit vector variables with one bit.
SMT-LIB Realization of Transformation Rule 2.
The variables for integer
attributes ˛
a W Z are realized with bit vector variables of a ﬁxed length l, i.e.,
formally ˛
a W Bl; the SMT-LIB declaration is
1 (declare-fun ˛
a () (_ BitVec l ))

34
3
A Symbolic Formulation for Models
Remark 4 The notation l is used in SMT-LIB listings to show that the term above
must be replaced by a precise value or number. Furthermore, the value of l is another
entry for the problem bounds which must be provided by the designer in the second
step of the ﬂow.
Note that l usually is set to 8 in this work. Furthermore, it must be deﬁned as a
problem bound because otherwise the search space for the decision problem will be
inﬁnite. Likewise l has to be equal for all integer attributes, if, e.g., a comparison
shall be applied. The value of l will also be used to transform OCL expressions, e.g.,
like ->size(), into a reasonable SMT-LIB constraint.
Before the next SMT-LIB realization is given, a digression about the internal
representation of integers using bit vectors in SMT-LIB and about the impact of the
SMT-LIB inhouse operations for bit vectors is done.
Obviously, a bit vector with l bits can be used to encode 2l different integer
numbers: f0; 1; : : : ; 2l  1g. If the bits are bl1bl2 : : : b1b0, the encoded element is
x D
l1
P
iD0
bi  2i. This way of encoding is called unsigned bit vector representation.
If one of the basic operations addition, subtraction, or multiplication (bvadd,
bvsub, bvmul) is applied to two bit vectors of length l as operands, the result
is again a bit vector of length l. Unfortunately, this, in general, can cause over-
and underﬂows. Therefore, the result is the remainder or residue of the regular
operation modulo 2l whereby the remainder is chosen such that it is an element
of the aforementioned set of the 2l encoded numbers. Altogether, this is an abelian
ring: the ring of integers modulo 2l, commonly denoted by Z=2lZ or Z2l. Thence
the selection of a representative within a residue class or congruence class has no
impact on the result of the applied operation, also the representative set starting with
2l1 and ending with 2l1  1 can be chosen. These representatives are encoded
by the so-called two’s complement representation, a signed encoding, where the bit
bl1 indicates if the encoded number is negative or not. The full encoding works as
follows: x D bl1  2l1 C
l2
P
iD0
bi  2i. So it makes no difference which of the two
encodings is used for the addition, subtraction, and multiplication of two bit vectors
and, thus, the SMT-LIB offers only one SMT-LIB operation for each. However, for
the division and the modulo operation, the SMT-LIB standard offers an unsigned as
well as signed operand: bvudiv, bvurem, bvsdiv, and bvsrem because here
it makes a difference which of the two encodings is used as the following example
shows:
1 (= a (bvsdiv #b1100 #b0100))
2 ; a D #b1111 D 1 and 4 :
4 D 1
3 (= b (bvudiv #b1100 #b0100))
4 ; b D #b0011 D 3 and 12
:
4 D 3
5
6 (= c (bvsrem #b1101 #b0100))
7 ; c D #b1101 D 3 and 3 mod 4 D 3
8 (= d (bvurem #b1101 #b0100))
9 ; d D #b0001 D 1 and 13 mod 4 D 1

3.2
Transforming a Model into a Symbolic Formulation
35
Furthermore, a division by zero returns #b1111 for bvudiv and #b0001 for
bvsdiv, as an undeﬁned is not allowed within SMT-LIB.
Remark 5 The chosen encoding, unsigned or signed, must also be added to the
problem bounds. Otherwise, undesired results can occur, when, e.g., the operands
of a division make use of different encodings.
SMT-LIB Realization of Transformation Rule 3.
The variables for enum data
type attributes ˛
a W f0; : : : ; k  1g are realized with a bit vector of length l D
maxf1; dlog2 keg in the SMT QF_BV realization of the symbolic formulation, i.e.,
˛
a W Bl or
1 (declare-fun ˛
a () (_ BitVec l ))
Furthermore, the following constraint must be added
1 (bvult ˛
a #bk2;l)
where k2;l stands for the binary string of k with exactly l bits. It symbolically means
˛
a < k and is necessary because the bit vector variable ˛
a W Bl offers values from 0
up to 2l  1, which, in general, is greater than k  1.
Note that the max construction is only needed if enum data types with less than
two values are allowed, otherwise l D dlog2 ke  1. Obviously, the bit vector is
assumed to be unsigned and since the division or modulo operation (and also the
other basic arithmetic functions) are not deﬁned for enums, no one must bother with
the different operations.
SMT-LIB Realization of Transformation Rule 4. The variables for class type c0
attributes ˛
a W c0 are realized with a bit vector of length l D jc0j in the SMT-LIB
realization of the symbolic formulation, i.e., ˛
a W Bl.D Bjc0j/. Since the variable
should just point to one object, constraints ensuring that the binary string of an
assignment to ˛
a has exactly one 1 (one-hot encoding) have to be added:
1 (declare-fun ˛
a () (_ BitVec l )) ;
d e c l a r a t i o n
2 (or (= ˛
a #b0: : :001)
3
(= ˛
a #b0: : :010)
4
: : :
5
(= ˛
a #b100: : :0))
6 ;
or
a l t e r n a t i v e l y
7 ((_ card_eq 1) ˛
a )
Note that due to the ﬁxed number of objects deﬁned as part of the problem
bounds, the value of l or jc0j, respectively, is always ﬁnite.
SMT-LIB Realization of Transformation Rule 5.
Variables of collection typed
attributes ˛
a are, of course, also realized with bit vector variables. The respective
length depends on the collection type itself and its generic type t as well as the
number of elements of the universe.
For sets, the bit vector variable must decide whether an element is in a set or not.
This is done with a bit vector of length jtj, where each single bit represents a single
element of the universe and it is assigned to 1 (0), if the element is (not) in the set,
i.e., ˛
a W Bjtj.

36
3
A Symbolic Formulation for Models
Since a bag, in principle, can contain any natural number of copies, e.g., of
trues or 17s, a representation must be inﬁnite, even if the universe is ﬁnite. But,
this would again tackle the ﬁniteness of the search space of the SMT-LIB realization
of the symbolic formulation, thus, another problem bound for the bag element bit
width maxbag 2 N, maxbag  1 is declared. This means that maxbag restricts the
number of copies for each element within every bag to be in f0; 1; : : : ; 2maxbag  1g.
Consequently, the variable type from the symbolic formulation is not anymore
t 7! N but t 7! f0; 1; : : : ; 2maxbag  1g. Since the universe of the generic
type t has jtj elements, a bit vector of length jtj  maxbag is created, i.e., ˛
a W
Bjtjmaxbag.
For an ordered set, the representation must decide if an element of the universe
is an element of the ordered set or not and if it is an element, also the position
must be provided. The position can only be in f1; 2; : : : ; jtjg, further, 0 represents
that an element of the universe is not an element of the ordered set, the symbolic
variable type would be ˛
a W t 7! f0; 1; 2; : : : ; jtjg. To represent at least jtj C 1
different values, for each element of the universe dlog2 .jtj C 1/e bits are needed,
i.e., ˛
a
W Bjtjdlog2.jtjC1/e. However, the restriction constraints from the general
symbolic representation must also be added and, further, constraints are added in
order to restrict the position index to be less or equal than jtj4:
1 (let ( (y1 ((_ extract 1  n  1 0  n) ˛
a )) ; y1 D ˛
a .x1/
2
: : :
3
(yjtj ((_ extract jtj  n  1 .jtj  1/  n) ˛
a )) ; yjtj D ˛
a .xjtj/
4
)
5
(and (=> (bvugt y1 #b02;n) ; ˛
a .x/ D y1 > 0
6
(and (and (not (= y1 y2))
7
; ˛
a .x1/ D y1 ¤ y2 D ˛
a .x2/
8
(not (= y1 y3))
9
; ˛
a .x1/ D y1 ¤ y3 D ˛
a .x3/
10
: : :
11
(not (= y1 yjtj)) )
12
; ˛
a .x1/ D y1 ¤ yjtj D ˛
a .xjtj/
13
(=> (bvuge y1 #b22;n) ; ˛
a .x1/ D y1  2
14
(or (= (bvsub y1 #b12;n) y2) ; 9 : : :
15
(= (bvsub y1 #b12;n) y3)
16
: : :
17
(= (bvsub y1 #b12;n) yjtj)))))
18
(=> (bvugt y2 #b02;n)
4The restriction of the position index (cf. Lines 36–39 in the following listing) is not necessary,
since the sum of all other constraints already implies it. However, the position index restricting
constraints are added to provide more information to the used SMT solver.

3.2
Transforming a Model into a Symbolic Formulation
37
19
(and (and (not (= y2 y1))
20
(not (= y2 y3))
21
: : :
22
(not (= y2 yjtj)) )
23
(=> (bvuge y2 #b22;n)
24
(or (= (bvsub y2 #b12;n) y1)
25
(= (bvsub y2 #b12;n) y3)
26
: : :
27
(= (bvsub y2 #b12;n) yjtj)))))
28
: : :
29
(=> (bvugt yjtj #b02;n)
30
(and (and (not (= yjtj y1))
31
(not (= yjtj y2))
32
: : :
33
(not (= yjtj yjtj1)) )
34
(=> (bvuge yjtj #b22;n)
35
(or (= (bvsub yjtj #b12;n) y1)
36
(= (bvsub yjtj #b12;n) y2)
37
: : :
38
(= (bvsub yjtj #b12;n) yjtj1)))))
39
(and (bvule y1 #bjtj2;n) ; ˛
a .x1/ D y1  jtj
40
(bvule y2 #bjtj2;n) ; ˛
a .x2/ D y2  jtj
41
: : :
42
(bvugt yjtj #bjtj2;n) ; ˛
a .xjtj/ D yjtj  jtj
43
)
44
)
45 )
For last remaining collection type, sequences, the general symbolic represen-
tation is a map, which returns f0g for an element of the universe, if it is not
in the sequence and a subset of the natural numbers with the position indices
otherwise. Like a bag, the number of copies of an element is not limited, thus,
another problem bound for the maximum number of copies for each element of the
universe maxseq 2 N with maxseq  1 is declared. Having this maximum number
of copies per element, the sequence itself is now restricted to at most maxseq jtj
elements. Consequently, for each possible element of the sequence (not the universe
of t!) dlog2

maxseq jtj C 1

e bits are needed, i.e., ˛
a W Bmaxseq jtjdlog2.maxseq jtjC1/e.
Again, the restriction constraints from the general symbolic representation must
also be position index to be less or equal than jtj. For readability the following
substitution is used: k D dlog2 .n  jtj C 1/e.

38
3
A Symbolic Formulation for Models
1 (let ( (y1I1 ((_ extract 1  k  1 0  k) ˛
a ))
2
;
1 s t
copy
of x1 ( i f
any )
3
(y1I2 ((_ extract 2  k  1 1  k) ˛
a ))
4
;
2nd copy
of x1 ( i f
any )
5
: : :
6
(y1In ((_ extract n  k  1 .n  1/  k) ˛
a ))
7
;
nth
copy
of x1 ( i f
any )
8
(y2I1 ((_ extract .n C 1/  k  1 n  k) ˛
a ))
9
;
1 s t
copy
of x2
10
: : :
11
(y2In ((_ extract 2  n  k  1 .2  n  1/  k) ˛
a ))
12
;
nth
copy
of x2 ( i f
any )
13
: : :
14
(yjtjIn ((_ extract jtj  n  k  1 .jtj  n  1/  k) ˛
a ))
15
;
nth
copy
of xjtj ( i f
any )
16
)
17
(and (=> (bvugt y1I1 #b02;k) ; n 2 ˛
a .x1/
18
(and (and (not (= y1I1 y1I2))
19
(not (= y1I1 y1I3))
20
: : :
21
(not (= y1I1 y1In))
22
: : :
23
(not (= y1I1 yjtjIn)) )
24
(=> (bvuge y1I1 #b22;k) ; ˛
a .x1/ D y1  2
25
(or (= (bvsub y1I1 #b12;k) y1I2) ; 9 : : :
26
(= (bvsub y1I1 #b12;k) y1I3)
27
: : :
28
(= (bvsub y1I1 #b12;k) yjtjIn) ))))
29
: : :
30
(=> (bvugt yjtjIn #b02;n)
31
(and (and (not (= yjtjIn y1;1))
32
: : :
33
(not (= yjtjIn yjtjIn1)) )
34
(=> (bvuge yjtjIn #b22;n)
35
(or (= (bvsub yjtjIn #b12;k) y1;1)
36
: : :
37
(= (bvsub yjtjIn #b12;k) yjtjIn1)))))
38
(and (bvule y1I1 #b.n  jtj/2;k)

3.2
Transforming a Model into a Symbolic Formulation
39
39
: : :
40
(bvugt yjtjIn #b.n  jtj/2;k)
41
)
42
)
43 )
Additionally, the possible position indices for the same element of the universe
should be ordered such that yiI1  yiI2  yiI3  : : :  yiIk where i D 1; : : : ; jtj.
Remark 6 In the last SMT-LIB realization the problem bounds have been extended
to a value for the bag element bit width, maxbag 2 N; maxbag  1, which restricts
the number of copies in a bag to be less than 2maxbag. Similarly, the number of copies
of an element in a sequence is restricted by maxseq 2 N; maxseq  1.
Note that for the last two transformations into the SMT domain, each bit (or some
succeeding and cohesive bits) represents a single function value of a single element
of the respective universe. In order to map precise assignments for bit vector
variables back, a ﬁxed order for the universe must be given. Of course, the order
must be equal for variables with the same type.
Example 10 Applying the SMT-LIB realization to the un-assigned system state
in Fig. 3.2 yields to the following declarations of variables as well as restricting
constraints:
1 (declare-fun ˛Turnstile0
greenLightOn () Bool)
2 (declare-fun ˛Turnstile0
redLightOn () Bool)
3 (declare-fun ˛Turnstile0
currentlyAuthorized () (_ BitVec 8))
4 (declare-fun ˛Turnstile0
timeOpen
() (_ BitVec 8))
5 (declare-fun ˛Turnstile0
type
() (_ BitVec 1))
6
7 (declare-fun ˛Turnstile1
greenLightOn () Bool)
8 (declare-fun ˛Turnstile1
redLightOn () Bool)
9 (declare-fun ˛Turnstile1
currentlyAuthorized () (_ BitVec 8))
10 (declare-fun ˛Turnstile1
timeOpen
() (_ BitVec 8))
11 (declare-fun ˛Turnstile1
type
() (_ BitVec 1))
12
13(declare-fun ˛Turnstile2
greenLightOn () Bool)
14 (declare-fun ˛Turnstile2
redLightOn () Bool)
15 (declare-fun ˛Turnstile2
currentlyAuthorized () (_ BitVec 8))
16 (declare-fun ˛Turnstile2
timeOpen
() (_ BitVec 8))
17 (declare-fun ˛Turnstile2
type
() (_ BitVec 1))
18
19(declare-fun ˛Turnstile3
greenLightOn () Bool)
20 (declare-fun ˛Turnstile3
redLightOn () Bool)
21 (declare-fun ˛Turnstile3
currentlyAuthorized () (_ BitVec 8))
22 (declare-fun ˛Turnstile3
timeOpen
() (_ BitVec 8))

40
3
A Symbolic Formulation for Models
23 (declare-fun ˛Turnstile3
type
() (_ BitVec 1))
24
25(declare-fun ˛Building0
authorized () (_ BitVec 256))
26 (declare-fun ˛Building0
inside
() (_ BitVec 256))
27
28(declare-fun ˛Building1
authorized () (_ BitVec 256))
29 (declare-fun ˛Building1
inside
() (_ BitVec 256))
30
31(declare-fun ˛MagneticCard0
id
() (_ BitVec 8))
32 (declare-fun ˛MagneticCard1
id
() (_ BitVec 8))
33 (declare-fun ˛MagneticCard2
id
() (_ BitVec 8))
34 (declare-fun ˛MagneticCard3
id
() (_ BitVec 8))
35
36(bvule ˛Turnstile0
type
#b1)
37 (bvule ˛Turnstile1
type
#b1)
38 (bvule ˛Turnstile2
type
#b1)
39 (bvule ˛Turnstile3
type
#b1)
3.2.2
Transforming Associations
To symbolically represent all possible links within a system state  D .; /, for
both relation ends and their respective object instances a variable is created. Before
giving the formal transformation rule, the general idea is explained.
Let rolec1 W c1 and rolec2 W c2 be the ﬁrst two entries of an association and
ignore the multiplicities for a moment. Then, each object instance of c1 can be
linked (or not) with an arbitrary object instance of c2. Thus, a function mapping
each object instance of c2 to one of the Boolean values (true means linked and
false not linked) works as a representation for all possible combinations of links.
Adding variables for those functions for all objects of c1 to represent all possible
links would already be sufﬁcient, however, for the sake of convenience it is also
done vice versa. More precisely, for each object of c2 a function mapping the object
instances of c1 to B is also added. Furthermore, constraints ensuring the symmetry
of associations must be added.
Example 11 In Fig. 3.4, a piece of the symbolic formulation of a system state
with two object instances of Building and four of Turnstile (MagneticCards are
omitted) is visualized. Since a general symbolic formulation should represent all
links between the object instances of the two classes, but as no details are known—
except for the problem bounds—the symbolic representation must allow all possible
links. Thus, applying the ideas explained before one function mapping the four
turnstile objects Turnstile D {T1, T2, T3, T4} to B is added to the building B1 and

3.2
Transforming a Model into a Symbolic Formulation
41
T1 :Turnstile
{B1,B2 →
}
B
T2 :Turnstile
{B1,B2 →
}
B
T3 :Turnstile
{B1,B2 →
}
B
T4 :Turnstile
{B1,B2 →
}
B
B1 :Building
{T1,T2,T3,T4 →
}
B
B2 :Building
{T1,T2,T3,T4 →
}
B
T1
T2
T3
T4
T1
T2
T3
T4
B1
B2
B1
B2
B1
B2
B1
B2
Fig. 3.4 Idea of links in the symbolic representation
another to B2. Analogue, functions from {B1, B2} to B are added to all four turnstile
instances. The symmetry constraints are visualized with gray lines in Fig. 3.4
between possibly linked object instances (indicated by gray dots with a matching
name), they represent the equality of two evaluations.
Transformation Rule 6 (Associations) Let r D .rolec1 W c1, rolec2 W c2; .l1; u1/;
.l2; u2// 2 R be an association which belongs to the model. Then, for each object
instance  in c1 a variable 
rolec2 W c2 7! B is created and vice versa 0
rolec1 W
c1 7! B (with 0 2 c2). Since a link is symmetric, the following constraints must
be added:
8  2 c1 W 8 0 2 c2 W 
rolec2 .0/ D 0
rolec1 ./
(3.5)
Furthermore, the multiplicities can be enforced by adding the following constraints:
8  2 c1 W l1 
X
02c2

rolec2 .0/  u1
(3.6)
and
8  2 c2 W l2 
X
02c1

rolec1 .0/  u2:
(3.7)
SMT-LIB Realization of Transformation Rule 6. The variables 
rolec2 W c2 7! B
and 0
rolec1 W c1 7! B created for the general symbolic formulation of an association
r D .rolec1 W c1; rolec2 W c2; .l1; u1/; .l2; u2// 2 R both represent maps returning
just true or false, thus, a representing bit vector must have jc2j or jc1j,
respectively, bits. For all objects  in c1 a variable 
rolec2 W Bjc2j and for all
objects 0 in c2 a variable 
rolec1 W Bjc1j are created.
To realize the symmetry constraints from Eq. (3.5), the elements in the universes
are counted as follows: c1 D f1; 2; : : : ; jc1jg and c2 D f
0
1; 
0
2; : : : ; 
0
jc2jg.

42
3
A Symbolic Formulation for Models
1 (and (= ((_ extract 0 0) 1
rolec2 )
2
((_ extract 0 0) 

0
1
rolec1 ))
3
(= ((_ extract 1 1) 1
rolec2 )
4
((_ extract 0 0) 

0
2
rolec1 ))
5
: : :
6
(= ((_ extract jc2j  1 jc2j  1) 1
rolec2 )
7
((_ extract 0 0) 

0
jc2 j
rolec1 ))
8
(= ((_ extract 0 0) 2
rolec2 )
9
((_ extract 1 1) 

0
1
rolec1 ))
10
(= ((_ extract 1 1) 2
rolec2 )
11
((_ extract 1 1) 

0
2
rolec1 ))
12
: : :
13
(= ((_ extract jc2j  1 jc2j  1) 2
rolec2 )
14
((_ extract 1 1) 

0
jc2 j
rolec1 ))
15
: : :
16
(= ((_ extract 0 0) 
jc1 j
rolec2 )
17
((_ extract jc1j  1 jc1j  1) 

0
1
rolec1 ))
18
(= ((_ extract 1 1) 
jc1 j
rolec2 )
19
((_ extract jc1j  1 jc1j  1) 

0
2
rolec1 ))
20
: : :
21
(= ((_ extract jc2j  1 jc2j  1) 
jc1 j
rolec2 )
22
((_ extract jc1j  1 jc1j  1) 

0
jc2 j
rolec1 ))
23 )
Let l denote the bit vector length of an integer attribute of the problem bounds,
then the sum constraint for rolec2 from Eq. (3.6) for all  2 c1 is done with the
following SMT-LIB constraints:
1 (let ( (sum
rolec2
2
(bvadd (ite (= #b1
3
((_ extract 0 0) 
rolec2 ))
4
#b12;m #b02;m)
5
(ite (= #b1
6
((_ extract 1 1) 
rolec2 ))

3.2
Transforming a Model into a Symbolic Formulation
43
7
#b12;m #b02;m)
8
: : :
9
(ite (= #b1
10
((_ extract jc2j  1 jc2j  1) 
rolec2 ))
11
#b12;m #b02;m) ) )
12
)
13
(and (bvule #b.l1/2;m sum
rolec2 )
14
(bvuge #b.u1/2;m sum
rolec2 )
15
)
16 )
Analogously, constraints for rolec1 for Eq. (3.7) for all  2 c2 are added.
Example 12 Applying the SMT-LIB realization for links to the un-assigned system
state in Fig. 3.2 yields to:
1 ;
v a r i a b l e
d e c l a r a t i o n s
2 (declare-fun Turnstile0
building
() (_ BitVec 2))
3 (declare-fun Turnstile1
building
() (_ BitVec 2))
4 (declare-fun Turnstile2
building
() (_ BitVec 2))
5 (declare-fun Turnstile3
building
() (_ BitVec 2))
6
7 (declare-fun Building0
gates
() (_ BitVec 4))
8 (declare-fun Building1
gates
() (_ BitVec 4))
9
10 ;
eq / symmetry
c o n s t r a i n t s
11 (and (= ((_ extract 0 0) Turnstile0
building
)
12
((_ extract 0 0) Building0
gates
))
13
(= ((_ extract 1 1) Turnstile0
building
)
14
((_ extract 0 0) Building1
gates
))
15
(= ((_ extract 0 0) Turnstile1
building
)
16
((_ extract 1 1) Building0
gates
))
17
(= ((_ extract 1 1) Turnstile1
building
)
18
((_ extract 1 1) Building1
gates
))
19
(= ((_ extract 0 0) Turnstile2
building
)
20
((_ extract 2 2) Building0
gates
))
21
(= ((_ extract 1 1) Turnstile2
building
)
22
((_ extract 2 2) Building1
gates
))
23
(= ((_ extract 0 0) Turnstile3
building
)
24
((_ extract 3 3) Building0
gates
))
25
(= ((_ extract 1 1) Turnstile3
building
)
26
((_ extract 3 3) Building1
gates
))

44
3
A Symbolic Formulation for Models
27 )
28
29 ;
m u l t i p l i c i t y
c o n s t r a i n t s
30 (let ( (sumBuilding0
gates
31
(bvadd (ite (= #b1 ((_ extract 0 0) Building0
gates
))
32
#b00000001 #b00000000)
33
(ite (= #b1 ((_ extract 1 1) Building0
gates
))
34
#b00000001 #b00000000)
35
(ite (= #b1 ((_ extract 2 2) Building0
gates
))
36
#b00000001 #b00000000)
37
(ite (= #b1 ((_ extract 3 3) Building0
gates
))
38
#b00000001 #b00000000) ) )
39
)
40
(bvule #b00000010 sumBuilding0
gates
)
41 )
42 : : :
43
44(let ( (sumTurnstile0
building
45
(bvadd (ite (= #b1 ((_ extract 0 0) Turnstile0
building
))
46
#b00000001 #b00000000)
47
(ite (= #b1 ((_ extract 1 1) Turnstile0
building
))
48
#b00000001 #b00000000) ) )
49
)
50
(= #b00000001 sumTurnstile0
building )
51 )
52 : : :
Note that an overﬂow of the sum is possible, if l (the bit width for integers) is too
small with respect to the number of object instances. This means that the designer
has to choose the problem bounds carefully.
3.2.3
Handling a Fixed and Variable Number of Objects
So far, it has been assumed that the number of objects per class is ﬁxed to a number
deﬁned within the problem bounds. However, in many cases, it is desirable to have a
look for a variable number of objects. For example, trying to ﬁnd a system state with
4 Turnstile, 4 Building, and 4 MagneticCard objects would yield an UNSAT, i.e., the
model is inconsistent with respect to the deﬁned problem bounds. This is caused by
the fact that each building must be connected to at least two turnstiles and each
turnstile must be connected to exactly one building. As already discussed, guessing
other problem bounds for the number of objects is a cumbersome task. Approaches

3.2
Transforming a Model into a Symbolic Formulation
45
as presented in [SWD11b, CGC15] can be used to obtain a result like no solution in
bounds. But there are sometimes problems, where the number of objects is changing
or is in a certain interval. To also support such situations, this subsection deals with
those aspects.
So far, the problem bounds provide the precise number of objects for a nonab-
stract class in the system state, from now on it is also allowed to use a pair of two
natural numbers instead of the precise number. This pair is similar to the multiplicity
constraints of an association, i.e., the ﬁrst entry of the pair deﬁnes a lower bound of
objects to be present in the system state and the second entry of the pair an upper
bound.
Transformation Rule 7 (Present and Absent Objects) For all classes c 2 C
a variable ˇc W c 7! B is created. The function values indicate whether the
object is present/alive (true) or absent/dead (false) in a system state. Moreover,
constraints ensuring possible class inheritance have to be added:
8 csup; csub 2 C W csup  csub)8  2 csub W ˇcsup./ D ˇcsub./:
Furthermore, restricting constraints for all variables as previously introduced for
the attributes and associations are added. For Boolean attributes a, the assignment
of the respective variable in the symbolic formulation is enforced to be false, if
the object is absent:
8  2 c W .ˇc./ D false/ )

˛
a D false

In similar fashion, integer and enum data type attributes are restricted, but instead
of false the variable is enforced to be 0.
For a class attribute of a class type c0, the variable type is changed to ˛
a W c0 7!
B and for absent objects the following restriction is added:
8  2 c W .ˇc./ D false/ )

8 0 2 c0 W ˛
a .0/ D false

:
(3.8)
Additionally, for present objects the function must evaluate exactly one time to
true, this is ensured by
8  2 c W .ˇc./ D true/ )

9Š 0 2 c0 W ˛
a .0/ D true

:
Furthermore, the object 0 (with ˛
a .0/ D true) must be a present one, therefore
the constraint
8 0 2 c0 W

˛
a .0/ D true

)

ˇc0.0/ D true

(3.9)
is added.
Like the value of a class attribute must be a present object, also the occurring
objects of a collection (with a class as its generic type) must be present and if the

46
3
A Symbolic Formulation for Models
object of a collection typed attribute is absent, the value is enforced to be the empty
collection, of course, the collection type must be guaranteed. The ﬁrst part can be
ensured by applying Eq. (3.9) for a set, and for the remaining collection types the
premise of the implication must be changed as follows: ˛
a .0/ > 0 for a bag as well
as an ordered set and ˛
a .0/ ¤ f0g for a sequence. For the second part, Eq. (3.8)
can be re-used for a set, and for the other collection types the conclusion of the
implication is changed as follows: ˛
a .0/ D 0 for a bag as well as an ordered set
and ˛
a .0/ D f0g for a sequence.
Moreover, both objects within a link should be present in the system state and the
multiplicity constraints must be satisﬁed for present objects only. Formally, this is:
8  2 c1 W 8 0 2 c2 W


rolec2 .0/ D true

)

ˇc1./ D true ^ ˇc2.0/ D true

and
8  2 c1 W .ˇc1./ D true/ )
0
BBB@l1 
X
02c2

rolec2
.0/Dtrue
1  u1
1
CCCA
Analogously, constraints are added for the other end of a possible link.
Finally, the precise number or interval of object instances is ensured: If the
problem bounds provide a ﬁxed number nc of objects for the class c, then the
constraint
nc D
X
2c
ˇc./Dtrue
1
is added to the generic symbolic formulation. If instead the problem bounds provide
an interval .lc; uc/, the constraint
lc 
X
2c
ˇc./Dtrue
1  uc
is added.
Note that in the last transformation rule c=c0 corresponds to the un-assigned
system state which must have uc objects. The exact number of present objects in the
system state to be determined is now a part of the symbolic formulation.
SMT-LIB Realization of Transformation Rule 7. The ˇc-variables are realized
with bit vectors of length jcj in the SMT-LIB realization of the general symbolic
formulation, i.e., ˇc W Bjcj or

3.2
Transforming a Model into a Symbolic Formulation
47
1 (declare-fun ˇc () (_ BitVec jcj))
For two different classes csup; csub 2 C with csup  csub, the following constraints
ensure the inheritance relation5:
1 (and (= ˇcsub ((_ extract ksub  1 0) ˇcsup)
If there are more subclasses, the respective ranges of the bit vector variables are
also restricted and ksub  1 and 0 are changed with the respective numbers.
The restrictions to the attribute variables of absent objects is done as follows:
1 (=> (= ((_ extract 0 0 ) ˇc)
2
#b1)
3
(= ˛0
a
4
false/#b02;l))
5 : : :
6 (=> (= ((_ extract jcj  1 jcj  1) ˇc)
7
#b0)
8
(= ˛0
a
9
false/#b02;l))
The value false is chosen for Boolean attributes and a constant zero bit string for
all other attributes where the length l depends on the type.
Additionally, variables ˛
a W c0 7! B of class attributes as well as set attributes
are enforced to only have a present object as a value or element, respectively:
1 (and (=> (= ((_ extract 0 0) ˛
a ) #b1)
2
(= ((_ extract 0 0) ˇc0)) #b1)
3
(=> (= ((_ extract 1 1) ˛
a ) #b1)
4
(= ((_ extract 1 1) ˇc0) #b1))
5
: : :
6
(=> (= ((_ extract jc0j  1 jc0j  1) ˛
a ) #b1)
7
(= ((_ extract jc0j  1 jc0j  1) ˇc0) #b1))
8 )
For the variables ˛
a of a bag and an ordered set of class instances of c0, let n be
the bit width which is used to encode a single element of a bag or the position of an
element in an ordered set. Then, the restricting constraints are:
1 (and (=> (bvugt ((_ extract 1  n  1 0  n) ˛
a ) #b02;n)
2
(= ((_ extract 0 0) ˇc0)) #b1))
3
(=> (bvugt ((_ extract 2  n  1 1  n) ˛
a ) #b02;n)
5Without loss of generality, it is assumed that the ﬁrst ksub bits of ˇcsup are belonging to the objects
in csub.

48
3
A Symbolic Formulation for Models
4
(= ((_ extract 1 1) ˇc0) #b1))
5
: : :
6
(=> (bvugt ((_ extract jc0j  n  1 .jc0j  1/  n) ˛
a ) #b02;n)
7
(= ((_ extract jc0j  1 jc0j  1) ˇc0) #b1))
8 )
For sequences, it is sufﬁcient to check if the maybe ﬁrst occurrence of an element
is really present in the sequence instead of each possible occurrence due to the
-chain:
1 (and (=> (bvugt ((_ extract 1  k  1 0  k) ˛
a ) #b02;k)
2
; y1I1 > 0
3
(= ((_ extract 0 0) ˇc0)) #b1)
4
(=> (bvugt ((_ extract .n C 1/  k  1 n  k) ˛
a ) #b02;n)
5
; y2I1 > 0
6
(= ((_ extract 1 1) ˇc0) #b1))
7
: : :
8
(=> (bvugt ((_ extract jc0j  n  k  1 .jc0j  n  1/  k) ˛
a )
9
#b02;n)
10
(= ((_ extract jc0j  1 jc0j  1) ˇc0) #b1))
11 )
The restricting constraints for present and absent objects of link variables 
rolec2
are realized like the ones for a set attribute as previously introduced in this
realization and, thus, details are omitted. The multiplicity constraints are modiﬁed
such that adding a simple implication where k now represents the index of the
object :
1 (let ( (sum
rolec2
2
(bvadd (ite (= #b1 ((_ extract 0 0) 
rolec2 ))
3
#b12;m #b02;m)
4
(ite (= #b1 ((_ extract 1 1) 
rolec2 ))
5
#b12;m #b02;m)
6
: : :
7
(ite (= #b1
8
((_ extract jc2j  1 jc2j  1) 
rolec2 //
9
#b12;m #b02;m) ) )
10
)
11
(=> (= ((_ extract k k) ˇc1) #b1))
12
(and (bvule #b.l1/2;m sum
rolec2 )
13
(bvuge #b.u1/2;m sum
rolec2 )
14 )))

3.2
Transforming a Model into a Symbolic Formulation
49
As a restriction to ensure the in the problem bounds deﬁned numbers of objects
(or the intervals, respectively), the multiplicity constraint for association as just
presented is re-used. However, instead of an implication only the conclusion is
added.
In a case when all lower bounds are set to 0, it must be ensured that the system
state is not empty, this issue will be discussed in more detail later, when the
structural veriﬁcation task is deﬁned (Deﬁnitions 3.1 and 3.2 on page 84).
3.2.4
Handling Null and Invalid
A lot of variables have been introduced to derive a symbolic representation (as well
as precise SMT-LIB constraints) of all possible system states within given problem
bounds, some of these variables had to be restricted by constraints. However, so
far only regular values have been considered (cf. the type system from Sect. 2.1).
But in order to be compatible with all possible results of OCL expressions, also the
irregular values null, symbol: –, and invalid, symbol: ?, have to be considered
as possible values of attributes. For the generic symbolic formulation, this is pretty
much straightforward, while for the precise SMT formulation one should keep in
mind that an implementation should work for the OCL constraints quite easy.
Before giving the next transformation rules as well as the precise SMT-LIB
realizations to cope also with irregular values, a short discussion about different
possibilities gives a justiﬁcation for the following implementation.
One possibility to realize – and ? is to simply change the type of attribute
variables ˛
a , i.e., t [ f–; ?g is used as the universe instead of the universe with the
regular values t. However, this would cause problems for collection typed attributes.
For example, a set in the OCL type system can be null, invalid, and also
Set{null}, but not Set{invalid}. Thus, this work proposes not to use just
an extension of the universe, but to introduce another variable ı for the deﬁnedness
of each attribute (or result of an OCL operation) such that the pair .˛; ı/ is a good
representation to deal with regular and also irregular values.
Transformation Rule 8 (Extending the Universe of None Collection Typed
Attributes) Let a be a Boolean, Integer, Enum, or class attribute of a class c
and t the respective universe of regular values of a. Then, for each variable ˛
a
an additional variable ı
a W f✓; –; ?g is created, where ✓means that the attribute
value is neither null nor invalid, but a regular value. Furthermore, the possible

50
3
A Symbolic Formulation for Models
assignments for ˛
a should be restricted depending on the value of the ı
a
6:

ı
a D –

)

˛
a D 0

:
Additionally, the value of an attribute can only have either a regular value or is
null, i.e., it is always different from invalid. However, it must be comparable to
the result of an operation, etc., which can be invalid:
ı
a ¤ ?
Transformation Rule 9 (Extending
the
Universe
of
Collection
Typed
Attributes) Let a 2 A be a collection typed attribute belonging to a class c
and t the generic type of the collection. Since null can be an element within
any collection type, the domain of the map t 7! B (or another co-domain if the
collection is not a set) must be extended to t [ f–g, denoted by t– in the following.
If a is a set, then the type of all variables ˛
a is changed to t– 7! B and a new
variable ı
a W f✓; –; ?g is created, but again a constraint ensuring that ı
a ¤ ? is
added. Finally, the possible assignments to ˛
a are restricted by

ı
a D – _ ı
a D ?

)

8 x 2 t– W ˛
a .x/ D false

:
If a is a bag, then the type of all variables ˛
a is changed to t– 7! N and a new
variable ı
a W f✓; –; ?g (with ı
a ¤ ?) is created. Finally, the possible assignments
to ˛
a are restricted by

ı
a D – _ ı
a D ?

)

8 x 2 t– W ˛
a .x/ D 0

:
If a is an ordered set, then the type of all variables ˛
a is changed to t– 7! N
and a new variable ı
a W f✓; –; ?g (with ı
a ¤ ?) is created. Instead of Eqs. (3.1)
and (3.2), the following restrictions are added:

ı
a D – _ ı
a D ?

)

8 x 2 t– W ˛
a .x/ D 0


ı
a D ✓

)

8 x 2 t– W ˛
a .x/ > 0)

8 y 2 t– n fxg W ˛
a . y/ ¤ ˛
a .x/


ı
a D ✓

)

8 x 2 t– W ˛
a .x/  2)

9 y 2 t– W ˛
a . y/ D ˛
a .x/  1

If a is a sequence, then the type of all variables ˛
a is changed to t– 7! P.N n
f0g/ [ ff0gg and a new variable ı
a W f✓; –; ?g (with ı
a ¤ ?) is created. Instead of
Eqs. (3.3) and (3.4), the following restrictions are added:
6For Boolean attributes the 0 in the conclusion has to be replaced by false and for class attributes
the changed type from Transformation Rule 7 is used again, i.e., ˛
a W c0 7! B. In the latter case,
˛
a D 0 means that the function always evaluates to false.

3.2
Transforming a Model into a Symbolic Formulation
51

ı
a D – _ ı
a D ?

)

8 x 2 t– W ˛
a .x/ D f0g


ı
a D ✓

)

8 n 2 N; n  1 W

9 x 2 t– W n 2 .˛
a /.x/

)

8 y 2 t– n fxg W n 62 .˛
a /. y/


ı
a D ✓

)

8 n 2 N; n  2 W

9 x 2 t– W n 2 .˛
a /.x/

)

9 y 2 t– W n  1 2 .˛
a /. y/

Note that the above given implications containing ı
a D ? in the premise can never
be satisﬁed for exactly this case when attributes are considered. However, when
dealing with the results of precise OCL operations, there is no such constraint like
ı
a ¤ ? and, thus, the symbolic formulation must respect the type. So, this part can
be omitted for precise attribute cases but not for OCL operations.
SMT-LIB Realization of Transformation Rule 8.
Since the types of attribute
variables ˛
a have not been changed for none collection-typed attributes, only a
realization of the new created ı
a -variables and the corresponding constraints have
to be implemented. To represent any deﬁnedness value a bit vector variable of
length 2 is used and one of the 4 possible values is blocked:
1 (declare-fun ı
a () (_ BitVec 2)) ;
d e c l a r a t i o n
2 (not (= ı
a #b11)) ;
g e n e r a l
blocking
3 (not (= ı
a #b10)) ;
blocking ? f o r
a t t r i b u t e s
only
4 (=> (or (= ı
a #b01)
5
(= ı
a #b10))
6
(= ˛
a false/#b02;k))
Furthermore, for convenience auxiliary SMT-LIB functions are declared in order
to distinguish between the different deﬁnedness values:
1 (define-fun isRegular ((x (_ BitVec 2))) Bool
2
(ite (= x #b00) true false) )
3 (define-fun notRegular ((x (_ BitVec 2))) Bool
4
(ite (= x #b00) false true) )
5 (define-fun isNull ((x (_ BitVec 2))) Bool
6
(ite (= x #b01) true false) )
7 (define-fun isInvalid ((x (_ BitVec 2))) Bool
8
(ite (= x #b10) true false) )
Obviously, the currently deﬁned functions can also be used for the implication
of a default value. Furthermore, it should be mentioned that the functions will also
return a value for #b11, thus, this value must be blocked for each ı-variable. So, it
is important to carefully use these functions.
SMT-LIB Realization of Transformation Rule 9. Since the type of the collection
typed attribute variables for Boolean attributes ˛
a has been modiﬁed, also the bit
vector variables must be modiﬁed. As the universe is just extended by one element,
the idea is the same as in the SMT realization for collection typed attributes given
before, details are omitted. The ı
a are created as shown in the last SMT realizations
for none collection typed attributes and the restricting constraints are done as
follows:

52
3
A Symbolic Formulation for Models
1 (=> (isRegular ı
a ) (ensureValidAssignment))
2 (=> (notRegular ı
a ) (= ˛
a #b02;k))
where ensureValidAssignment is a slightly modiﬁed version of constraints
applied for the collections with only regular values (cf. SMT Realization 5) to ensure
that a valid assignment indeed represents the respective collection and k is equal to
the bit width of ˛
a .
Note that in the remainder of this work instead of the constant bit vector values
#b00, #b01, and #b10, the symbols ✓, –, and ? will be used within the SMT-LIB
listings.
However, not only for the attributes deﬁnedness variables must be added but also
for the relations.
Transformation Rule 10 (Extending the Association Variables) Let 
rolec2 be a
variable to represent the value of an association end. In order to make it possible
to also represent the irregular values and at the same time ensure the pair notation
for an easier comparison with attribute values and later on also the results of OCL
operations, etc., an additional variable ı
rolec2 W f✓; –; ?g is created.
In contrast to attributes, the possible values of an association end depend on
the upper bound of the corresponding multiplicity. If the upper bound is 1, then
the result can be either null (provided the lower bound is 0) or a reference to an
element. This results in the following restrictions:
ı
rolec2 ¤ ?
^

ı
rolec2 D ✓

)

9 Š x 2 c2 W 
rolec2 .x/ D true

^

ı
rolec2 D –

)

8 x 2 c2 W 
rolec2 .x/ D false

:
If otherwise, the upper bound is greater than 1, then the result is always a
regular value of type Set(c2), which is maybe an empty set, but neither null
nor invalid7:
ı
rolec2 ¤ – ^ ı
rolec2 ¤ ?
Furthermore, to be comparable with the results of other OCL operations, etc., also
null must be added as a possible value, even if it will be enforced to be not an
element. The changed universe is denoted by c2;– such that the type is changed to

rolec2 W c2;– 7! B and the restriction

rolec2 .null/ D false
is added.
7The differentiation for the upper bounds  1 and > 1 is caused by a technical detail in the UML
and OCL standards.

3.2
Transforming a Model into a Symbolic Formulation
53
SMT-LIB Realization of Transformation Rule 10. The SMT-LIB realization for
the ı
rolec2 variables is in most parts identical with the ones for an attribute of a
class c2 (in case the upper bound is 1) or set of object instances of c2 (otherwise).
Therefore, only the different blocking constraints will be given.
For associations with the upper bound 1 the restrictions are:
1 (not (isInvalid ı
rolec2 ))
2 (=> (isRegular ı
rolec2 )
3
(constraint for multiplicity 1-1 
rolec2 ))
4
5 (=> (isNull ı
rolec2 )
6
(= 
rolec2 #b02;k))
Instead of the normal multiplicity constraint a constraint ensuring a (1,1)
multiplicity is always ensured for a regular value.
For the remaining association (where the upper bound is greater than 1), the
normal multiplicity constraint and
1 (not (isInvalid ı
rolec2 ))
2 (not (isNull ı
rolec2 ))
are added. To further ensure that a reference never contains null, it can be
assumed that the null-bit is known:
1 (= ((_ extract null-bit) 
rolec2 ) #b0)
Note that for the null-bit, there is no opposite bit which must have the same
value, while for the others pointing to an object, this still has to be ensured.
If the number of object instances per class can vary (i.e., ˇc-variables are utilized)
and at the same time the 4-valued OCL logic (i.e., ı
a=role-variables are utilized)
should be used for the symbolic formulation, one has to decide how to deal with ı
variables if the object is not existing in the system state: Like the ˛ and  variables,
also the ı variables are ensured to be a constant zero bit vector, i.e., ı D ✓.
3.2.5
Transforming OCL Constraints
After introducing all the different variables to represent all possible system states
with respect to given problem bounds, an SMT solver will detect nearly every
assignment to the variables as a possible system state—also invalid ones. This
is caused by the fact that all constraints which have been added so far are just
ensuring that an assignment respects the type to the variable and is not something in
between. For example, a position in an ordered set is ensured to be unique and also a
predecessor must exist if the position index is greater than 1. However, there is one
exception: the multiplicity constraints for associations. They already ensure that a

54
3
A Symbolic Formulation for Models
determined assignment will satisfy all relations within the model (unless they are
not further restricted by OCL constraints). But usually a UML/OCL model does not
only have multiplicity constraints but also OCL constraints, i.e., invariants as well
as pre- and postconditions. As described in Sect. 2.4, invariants are added at the
model level to a class and pre- and postconditions to an operation of a class. They
restrict the number of possible assignments to the variables and, thus, also restrict
the number of valid system states of the model.
Unfortunately, the idea of just evaluating an invariant—pre- and postconditions
are handled later in this chapter—on a given system state (cf. Sect. 2.4) cannot be
applied here, because there is not a precise system state. Instead a list of variables
and some basic constraints are given which can represent any possible system
state—as already mentioned including those ones which are violating the invariants
and are, thus, invalid. Consequently, the invariants have to be transformed into
constraints to be added to the symbolic formulation such that an assignment to the
variables does not only represent some system state but a system state in which the
invariants are satisﬁed, i.e., valid system states. Thankfully, OCL follows a formal
syntax and grammar and it is possible to generate an Abstract Syntax Tree (AST) for
a given OCL expression (independently from being an invariant, pre-, postcondition,
or any other OCL expression).
Example 13 Figure 3.5 shows the AST of the invariant atLeastOneEntry
of the access control system model. The root is an OperationCallExp with
exists. The source of the OperationCallExp is PropertyCallExp
which returns the set of all connected turnstiles. As iterator variable t is deﬁned. The
argument of the root-OperationCallExp is another OperationCallExp
with an inner =. The calling source itself is a PropertyCallExp returning
the type of the current iterator t and the argument is an EnumLiteralExp
#Entry.
Fig. 3.5 The AST of the invariant atLeastOneEntry

3.2
Transforming a Model into a Symbolic Formulation
55
OclExpression
CallExp
LiteralExp
IfExp
VariableExp
Variable
FeatureCallExp
LoopExp
OperationCallExp
NavigationCallExp
PropertyCallExp
IteratorExp
IterateExp
0..1
+source
+appliedElement
0..1
*
+referringExp
+referredVariable
0..1
0..1
+loopExp
+iterator
*
LetExp
0..1
+in
0..1
+variable
0..1 +initExpression
+initializedElement
≪abstract≫
≪abstract≫
≪abstract≫
≪abstract≫
≪abstract≫
≪abstract≫
Fig. 3.6 OclExpression concept, cf. [Obj14, pp. 198ff.]
Having such an AST of an OCL expression, the main idea is now to transform it
into an AST which represents a constraint with the same semantic meaning for the
symbolic formulation (see also Sect. 2.5.2), i.e., it ensures that a found assignment
to the variables will satisfy the OCL expression. To that end, the AST is transformed
using a depth-ﬁrst search (DFS) from bottom to top and node by node. The precise
transformation rules for the different OCL expressions, i.e., navigation, operation
call, and variable expression etc., are the main contributions within this subsection.
In Fig. 3.6 the main concept of OCL expressions as introduced in [Obj14] is
visualized. Note that the ﬁgure is not complete in order to keep it readable and
consists of several ﬁgures taken from [Obj14, p. 198ff.]. The abstract common
super class of all OCL expressions is called OclExpression. Its subclass
LiteralExp represents all literals which can occur in any OCL expression, i.e.,
all Boolean, integer, enum (cf. EnumLiteralExp in the last example), set, etc.
constants. In the original OCL speciﬁcation, there are over 15 subclasses to model
all the different constant types, cf. [Obj14, Fig. 13.7 and 13.8 on p. 202] for details.
In the following, it will be described how the different parts of the AST of an
OCL expression are transformed. Like in the preceding subsections, at ﬁrst a general
transformation rule is given and explained, before in the second step the precise
SMT-LIB realization is derived. Some of the SMT-LIB realizations are kept rather
short because having the idea of bit vector variables for a speciﬁc type as well as
the general transformation rule in mind the SMT-LIB constraints should be obvious,
some are maybe completely omitted due to the same reason.
Before proceeding to the transformation rules, the different OCL logic levels
which can be used have to be discussed. While in Sect. 3.2.1 it has been explained
how the regular values of the most important UML/OCL types are transformed
into a symbolic formulation, Sect. 3.2.4 provides the basis to also deal with
different deﬁnedness status, i.e., null/– and invalid/?. Since regular values
are often sufﬁcient for a wide range of modeling problems, there is not always

56
3
A Symbolic Formulation for Models
the need to support more than just the regular values. Consequently, the level
of support differentiates from approach to approach and, thus, also from tool
to tool. Approaches working on regular values only are supporting a so-called
two-valued OCL logic; two-valued because there are only two values when a
Boolean expression is evaluated (e.g., [SoeC10, SWD11c, SWD11a]. Likewise, a
three-valued OCL logic supports regular values and null (e.g., [KG12]), and a
four-valued OCL logic regular and both null and invalid (e.g., [DC16]).
The transformations presented in the following from OCL expressions to con-
straints of a symbolic formulation are based on the four-valued OCL logic. This
makes it relatively easy to break it down to a two- or three-valued OCL logic.
Furthermore, a precise formalism of the (four-valued) OCL without any corner
cases left is another research ﬁeld since the last decade, but it is not a part of
this work since it would be beyond the scope. The main idea of the following
transformation rules is to provide a general base, while the precise deﬁnition for
a speciﬁc operation in the OCL standard might change in the future and, thus, also
the precise transformation rule. Appendix C provides an example for the problems
with the deﬁnition of xor in the OCL standard. The problems have arisen in the last
updates when the OCL was extended to a four-valued logic.
Transformation Rule 11 (LiteralExp) As already mentioned the abstract
class LiteralExp in Fig. 3.6 has several subclasses which, e.g., are used
to model a constant Boolean or integer literal. These different implementations
of LiteralExp represent regular values—except for NullLiteralExp and
InvalidLiteralExp, of course, which will be handled later. In order to make
those regular values comparable, e.g., to an attribute variable or the evalua-
tion of an OCL operation, the regular value must be embedded into the pair
representation—formerly denoted by .˛; ı/. If the regular value is denoted by , then
.; ✓/ is the transformed value to be used in constraints of the symbolic formulation.
Additionally, for enum literal values a transformation into its respective integer
value is applied.
If a literal for null occurs within an OCL collection, it will be simply adopted.
null literals occurring not within an OCL collection or invalid literals (which
by deﬁnition cannot occur within collections) are transformed to .false; –/ or
.false; ?/, respectively. While this at a ﬁrst glance maybe looks a bit strange, it
ensures the usage of the pair notation and, thus, gives the further processing of the
AST a bit more structure and reduces the case analysis.
SMT-LIB Realization of Transformation Rule 11. With the idea of transforming
literals for the general symbolic formulation, it should be clear that the precise
regular value and the deﬁnedness values are realized by using constant bit vectors
representing the respective values in SMT-LIB. Of course, the problem bounds have
to be respected for the bit width of an integer, collections, etc. Assuming that
literals are always used within an OclExpression from above, the SMT-LIB
realizations is:

3.2
Transforming a Model into a Symbolic Formulation
57
1 (let ( ( (constant bit vector)
2
(ı (✓))
3
)
4
OclExpression from above using  and ı
5 )
Transformation Rule 12 (IfExp) In OCL an IfExp always has a condition
and exactly two branches, one for the then-expression and another one for
the else-expression. The condition and the two branches are realized with an
OclExpression.8 Obviously, the evaluation of the condition must return a
Boolean.
Furthermore, for the transformation of an OCL IfExp into the general symbolic
formulation, the precise deﬁnition as given in [Obj14, p. 16f.] must be known or in
other words it must be clear how the none regular values are handled:
The IF-expression is another exception. It will be valid as long as the condition and the
chosen branch is valid, irrespective of the value of the other branch.
Furthermore, it can be assumed that all three OCL expressions have been
transformed in a former step, the transformed results are .cond; ıcond/, .then; ıthen/,
and .else; ıelse/.
IfExp Transformation
Input: .cond; ıcond/, .then; ıthen/, and .else; ıelse/
1: if ıcond 2 f–; ?g then
2:
.false; ?/
3: else
4:
if cond D true then
5:
if ıthen 2 f–; ?g then
6:
.false; ?/
7:
else
8:
.then; ✓/
9:
else
10:
if ıelse 2 f–; ?g then
11:
.false; ?/
12:
else
13:
.else; ✓/
SMT-LIB Realization of Transformation Rule 12. On a ﬁrst glance it looks like
that the general transformation of an IfExp can be realized using ite operations
in the SMT-LIB realization. Unfortunately, this is not the case, because in SMT-LIB
syntax the type of false, then and else must be equal. As the type of false is
Boolean, this means that then=else must be also from the type Boolean which, in
general, is not the case. Furthermore, it is also possible that then and else are from
8The details have been omitted in Fig. 3.6 to keep it clearer, however, interested readers are referred
to [Obj14, Fig. 8.4 and 13.5 on pp. 50 and 201].

58
3
A Symbolic Formulation for Models
different types, e.g., a set and a bag. At this point the SMT-LIB realization reaches
a limit, at least for the book at hand. The problem level is comparable to compiler
building where everything down to the bit level must be handled. Thus, it is assumed
that at least the types of then and else are equal. Now, the bit vector variables
representing then=else must also have an equal bit width, let k be that bit width.
Then, instead of false (which in the general transformation has only been used to
ensure the pair notation) a constant bit string with k zeros, i.e., #b02;k, is used.
Now, the SMT-LIB realization is again built with nested ites and a let which
provide two variables, if and ıif , to the OclExpression above:
1 (let ( (if (ite (isRegular ıcond)
2
(ite cond
3
then
4
else)
5
#b02;k))
6
(ıif (ite (isRegular ıcond)
7
(ite cond
8
(ite (isRegular ıthen)
9
✓
10
?)
11
(ite (isRegular ıelse)
12
✓
13
?))
14
?))
15
)
16
transformed OclExpression above using if and ıif
17 )
Note that the condition of an IfExp is always returning a Boolean. This implies
that cond is either false or true and, thus, cond is a valid ﬁrst operand for ite.
Transformation Rule 13 (LetExp) A LetExp deﬁnes a variable which can only
be used in the in-expression which itself is an OclExpression. For the general
transformation, the easiest way is to simply replace each occurrence (which
is realized with VariableExp which are handled later) of the new deﬁned
variable in the AST of the in-expression. However, this tackles a bit the sense and
purpose of LetExp, because maybe avoided redundant evaluations (recognized by
the designer) will now be not avoided.
As different decision problems offer different concepts to deal with LetExp,
the precise realization of LetExp should be handled there, e.g., to truly avoid
redundant evaluations and constraints.
SMT-LIB Realization of Transformation Rule 13.
The SMT-LIB let concept
has already been used several times, thus, it should be not surprising that it is again
used to deal with LetExp. For this purpose let var be the name of the deﬁned
variable, then var and ıvar are representing the value and the deﬁnedness status,
respectively.

3.2
Transforming a Model into a Symbolic Formulation
59
1 (let ( (var ...)
2
(ıvar ...)
3
)
4
transformed in-OclExpression using var and ıvar
5 )
In
OCL
logical
and
comparison
expressions
are
realized
with
OperationCallExp with an attribute providing the operation name. Each
operation is called on a source object, also called calling object, and has a list of
parameters, also called arguments. For unary operations the list of parameters is
empty, of course. For binary comparison and logical operations, the calling object
is the left-hand side and the object given by the (only) parameter the right-hand
side. This has implicitly also been shown in Example 13.
Transformation Rule 14 (OperationCallExp—on
Boolean
Expressions)
OCL offers the unary not operation to negate the value of the Boolean expression
on which it is called. The binary and, or, xor, implies, =, and <> should evaluate to
a new Boolean expression which represents the result of the respective operation.
However, all those operations must deal with the 4-valued OCL logic. The OCL
speciﬁcation describes those issues in [Obj14, Sect. 7.4.13 on pp. 16f., Sect. 11.3.2
on pp. 154f., Sect. 11.3.3. on pp. 155f., and Sect. 11.5.4 on p. 162]. Only a short part
of this section should be cited here to give an idea how the following transformation
rules have been derived:
•
True OR-ed with anything is True
•
False AND-ed with anything is False
•
False IMPLIES anything is True
•
anything IMPLIES True is True
With “anything” one of the four Boolean values is meant, i. .e., integer or other
completely different types are not allowed and should be recognized by the chosen
OCL parser before. But let’s start with the unary not, the respective truth table
derived from the OCL speciﬁcation is given in Table 3.1 and the transformation is:
not Transformation
Input: .src; ısrc/
1: if ısrc D ✓then
2:
.:src; ✓/
3: else
4:
if ısrc D – then
5:
.false; –/
Table 3.1 Truth table for
not (cf. [Obj14, Table A.2
on p. 214])
a
not a
false
true
true
false
–
–
?
?

60
3
A Symbolic Formulation for Models
Table 3.2 Truth table for (a)
and, (b) or, and (c) =
a
b
(a) For and
(b) For or
(c) For =
a and b
a or b
a = b
false
false
false
false
true
false
true
false
true
false
false
–
false
–
false
false
?
false
?
?
true
false
false
true
false
true
true
true
true
true
true
–
–
true
false
true
?
?
true
?
–
false
false
–
false
–
true
–
true
false
–
–
–
–
true
–
?
?
?
?
?
false
false
?
?
?
true
?
true
?
?
–
?
?
?
?
?
?
?
?
6:
else
7:
.false; ?/
For the transformation of and, or, and = the truth tables (Table 3.2(a)–(c)) are
used. While the ﬁrst two tables have been derived from [Obj14, Table A.2 on p. 214],
the last one has been derived from the OCL speciﬁcation at several positions.
and Transformation
Input: .lhs; ılhs/ and .rhs; ırhs/
1: if .ılhs D ✓^ lhs D false/ _ .ırhs D ✓^ rhs D false/ then
2:
.false; ✓/
3: else
4:
if ılhs D ? _ ırhs D ? then
5:
.false; ?/
6:
else
7:
if ılhs D – _ ırhs D – then
8:
.false; –/
9:
else
10:
.true; ✓/
or Transformation
Input: .lhs; ılhs/ and .rhs; ırhs/
1: if lhs D true _ rhs D true then
2:
.true; ✓/
3: else
4:
if ılhs D ? _ ırhs D ? then
5:
.false; ?/

3.2
Transforming a Model into a Symbolic Formulation
61
6:
else
7:
if ılhs D – _ ırhs D – then
8:
.false; –/
9:
else
10:
.false; ✓/
= Transformation
Input: .lhs; ılhs/ and .rhs; ırhs/
1: if ılhs D ? _ ırhs D ? then
2:
.false; ?/
3: else
4:
if ılhs D ırhs then
5:
.lhs D rhs; ✓/
6:
else
7:
.false; ✓/
The transformation of the implies operations follows, again, [Obj14, Table A.2
on p. 214]:
implies Transformation
Input: .lhs; ılhs/ and .rhs; ırhs/
1: if .ılhs D ✓^ lhs D false/ _ .rhs D true/ then
2:
.true; ✓/
3: else
4:
if ılhs D ? _ ırhs D ? then
5:
.false; ?/
6:
else
7:
if ılhs D – _ ırhs D – then
8:
.false; –/
9:
else
10:
.false; ✓/
A xor operation is ﬁrst mapped to its deﬁnition via a postcondition
a xor b W, (a or b) and not (a = b)
and afterwards transformed using the above given transformation rules.9
xor Transformation
Input: .lhs; ılhs/ and .rhs; ırhs/
1: if .lhs D true ^ ırhs D ✓^ rhs D false/ _ .ılhs D ✓^ lhs D false ^
rhs D true/ then
2:
.true; ✓/
3: else
9Note that the textual deﬁnition is equivalent to the respective truth tables—provided the “either
...or” is meant as a logical or—, but it is not equivalent to the deﬁnition via postcondition, see also
Appendix C.

62
3
A Symbolic Formulation for Models
4:
if .lhs D true^rhs D true/_.ılhs D ✓D ırhs ^lhs D false D rhs/
then
5:
.false; ?/
6:
else
7:
if ılhs D ? P_ ırhs D ? then
8:
.false; ?/
9:
else
10:
if ılhs D – P_ ırhs D – then
11:
.false; –/
12:
else
13:
.false; ?/
SMT-LIB Realization of Transformation Rule 14.
The not transformation can
be straightforward realized as follows in SMT-LIB syntax:
1 (let ( (src (ite (isRegular ıcond)
2
(not src)
3
false))
4
(ısrc (ite (isRegular ısrc)
5
✓
6
(ite (isNull ısrc)
7
–
8
?)))
9
)
10
transformed OclExpression above using src and ısrc
11 )
From the binary comparison operations of Boolean expressions, only the SMT-
LIB code of and will be given here:
1 (let ( (and (ite (or (and (isRegular ılhs)
2
(not lhs))
3
(and (isRegular ırhs)
4
(not rhs)))
5
false
6
(ite (or (isInvalid ılhs)
7
(isInvalid ırhs))
8
false
9
(ite (or (isNull ılhs)
10
(isNull ırhs))
11
false
12
true)))
13
(ıand (ite (or (and (isRegular ılhs)
14
(not lhs))
15
(and (isRegular ırhs)
16
(not rhs)))
17
✓

3.2
Transforming a Model into a Symbolic Formulation
63
18
(ite (or (isInvalid ılhs)
19
(isInvalid ırhs))
20
?
21
(ite (or (isNull ılhs)
22
(isNull ırhs))
23
–
24
✓)))
25
)
26
transformed OclExpression above using and and ıand
27 )
The remaining OCL operations can be realized with SMT-LIB in similar manner
like it has just been shown for and.
The next two groups of OperationCallExp which should be dealt with are
comparison operations between two integers (which in general return a Boolean
expression) and the arithmetic operations for integer (which in general return an
integer as a result).
Transformation Rule 15 (OperationCallExp—Comparison
of
Integers)
While the comparison of two regular integer expression results in a regular Boolean
expression where the comparison is the naturally given one, it is not clear how to
deal with cases where at least one of the two integer expressions is not regular at
a ﬁrst glance. However, with the following citations from the OCL speciﬁcation
[Obj14, Sect. 11.2.3 and Sect. 11.2.4 on p. 152] it is clear:
Any operation call applied on null results in invalid, except for the operations speciﬁed in
11.3.2 (=, <>, oclAsType, oclIsInState, oclIsKindOf, oclIsTypeOf, oclIsInvalid, oclIsNew,
oclIsUndeﬁned, oclType) and 11.5.4 (and, implies, not, or, xor).
Any operation call applied on invalid results in invalid, except for the operations speciﬁed
in 11.3.3 (=, <>, oclAsType, oclIsInState, oclIsKindOf, oclIsTypeOf, oclIsInvalid, oclIsNew,
oclIsUndeﬁned, oclType) and 11.5.4 (and, implies, not, or, xor).
The mentioned exceptions of interest here are formulated as follows:
For = (object2 : OclAny) : Boolean on null:
Evaluates to invalid if object2 is invalid. Evaluates to true if object2 is the null object.
Evaluates to false otherwise.
<> (object2 : OclAny) : Boolean on null:
Evaluates to invalid if object2 is invalid. Evaluates to false if object2 is the null object.
Evaluates to true otherwise.
= (object : OclAny) : Boolean and also <> (object : OclAny) : Boolean on invalid:
Evaluates to invalid.
Having this textual speciﬁcation, the transformation rules are straightforward:
= with two integers Transformation
Input: .lhs; ılhs/ and .rhs; ırhs/
1: if ılhs D ? _ ırhs D ? then
2:
.false; ?/
3: else
4:
if ılhs D – ^ ırhs D – then

64
3
A Symbolic Formulation for Models
5:
.true; ✓/
6:
else
7:
if ılhs D ✓^ ırhs D ✓then
8:
.lhs D rhs; ✓/
9:
else
10:
.false; ✓/
<> with two integers Transformation
Input: .lhs; ılhs/ and .rhs; ırhs/
1: if ılhs D ? _ ırhs D ? then
2:
.false; ?/
3: else
4:
if ılhs D – ^ ırhs D – then
5:
.false; ✓/
6:
else
7:
if ılhs D ✓^ ırhs D ✓then
8:
.lhs ¤ rhs; ✓/
9:
else
10:
.true; ✓/
The transformation rules for <, <=, >, and >= can be summarized. In the last line
of the transformation OP obviously has to be replaced by its natural counterpart:
<, <=, >, => with two integer Transformation
Input: .lhs; ılhs/ and .rhs; ırhs/
1: if ılhs D ? _ ırhs D ? _ ılhs D – _ ırhs D – then
2:
.false; ?/
3: else
4:
.lhs OP rhs; ✓/
SMT-LIB Realization of Transformation Rule 15. The SMT-LIB realizations for
the = and <> transformation rules are:
1 (let ( (D (ite (or (isInvalid ılhs)
2
(isInvalid ırhs))
3
false
4
(ite (and (isNull ılhs)
5
(isNull ırhs))
6
true
7
(ite (and (isRegular ılhs)
8
(isRegular ırhs))
9
(= lhs rhs)
10
false))))
11
(ıD (ite (or (isInvalid ılhs)
12
(isInvalid ırhs))
13
?
14
✓))
15
)
16
transformed OclExpression above using D and ıD
17 )

3.2
Transforming a Model into a Symbolic Formulation
65
1 (let ( (<> (ite (or (isInvalid ılhs)
2
(isInvalid ırhs))
3
false
4
(ite (and (isNull ılhs)
5
(isNull ırhs))
6
false
7
(ite (and (isRegular ılhs)
8
(isRegular ırhs))
9
(not (= lhs rhs))
10
true))))
11
(ı<> (ite (or (isInvalid ılhs)
12
(isInvalid ırhs))
13
?
14
✓))
15
)
16
transformed OclExpression above using <> and ı<>
17 )
The remaining four comparison operations can, again, be grouped together.
Depending on the usage of signed or unsigned bit vectors Table 3.3 shows which
SMT-LIB operations are used for which OCL comparison operation.
1 (let ( (OP (ite (or (isInvalid ılhs)
2
(isInvalid ırhs)
3
(isNull ılhs)
4
(isNull ırhs))
5
false
6
(SMT-LIB-OP lhs rhs)))
7
(ıOP (ite (or (isInvalid ılhs)
8
(isInvalid ırhs)
9
(isNull ılhs)
10
(isNull ırhs))
11
?
12
✓))
13
)
14
transformed OclExpression above using OP and ıOP
15 )
Table 3.3 Mapping of OCL
comparison operations to
SMT-LIB operations
ocl OP
SMT-LIB-OP
<
bvslt / bvult
<=
bvsle / bvule
>=
bvsge / bvuge
>
bvsgt / bvugt

66
3
A Symbolic Formulation for Models
Transformation Rule 16 (OperationCallExp—Arithmetic Operations with
Two Integers) OCL provides the default arithmetic operations to, e.g., add +,
subtract , multiply *, or divide / two integers. While the ﬁrst three always return
a new integer and thus ensure the type, the division returns an instance of the OCL
primitive type real. For the division without a remainder OCL provides the div
operation. However, since this book is not considering reals, the division of two
integers using / will be handled as div operation. For the remainder of a division,
OCL has the mod operation. The min and max operations in OCL can be used to
calculate the minimum or maximum, respectively.
But again, the interesting question is the handling of irregular values: If the left-
hand side or the right-hand side is not regular, the result is always invalid. With this
information the following transformation rules follow:
+, -, *, / or div, mod, min, and max with two integers Transformation
Input: .lhs; ılhs/ and .rhs; ırhs/
1: if ılhs D ? _ ırhs D ? _ ılhs D – _ ırhs D – then
2:
.false; ?/
3: else
4:
.lhs OP rhs; ✓/
Again, OP has to be replaced by the speciﬁc operation. For the OCL min and max
operations, max = minflhs; rhsg is used instead of lhs OP rhs.
SMT-LIB Realization of Transformation Rule 16. The SMT-LIB realization for
the arithmetic operations is very similar to the comparison operations < etc., except
for the fact that a constant bit vector consisting of zeros only has to be returned
instead false for the invalid cases. The mapping for the OCL operations is
given in Table 3.4.
1 (let ( (OP (ite (or (isInvalid ılhs)
2
(isInvalid ırhs)
3
(isNull ılhs)
4
(isNull ırhs))
5
#b02;k
6
(SMT-LIB-OP lhs rhs)))
7
(ıOP (ite (or (isInvalid ılhs)
8
(isInvalid ırhs)
9
(isNull ılhs)
10
(isNull ırhs))
11
?
12
✓))
13
)
14
transformed OclExpression above using OP and ıOP
15 )
For SMT-LIB realization of max and min, there is no operation in the SMT-
LIB speciﬁcation available. Thus, a case differentiation using ite combined

3.2
Transforming a Model into a Symbolic Formulation
67
Table 3.4 Mapping of OCL
arithmetic operations to
SMT-LIB operations
OCL operation
SMT-LIB-OP
+
bvadd

bvsub
*
bvmul
/
bvsdiv / bvudiv
mod
bvsrem / bvurem
with a comparison operation is needed. For
max Line 6 of the last listing,
(SMT-LIB-OP lhs rhs) must be replaced with
1 (ite (bvuge/bvsge lhs rhs)
2
lhs
3
rhs)
To realize the OCL min operation, either the last two lines of the ite can be swapped
or the comparison operation within the SMT-LIB realization can be changed to
bvule/bvsle.
Readers familiar with the wide range of OCL operations the OCL provides will
know that there are still a lot of them left for which transformation rules need to
be provided. However, before continuing with more operations the transformation
rules for other OCL expressions are now considered. They will make it later easier
to understand the transformation rules of the remaining OCL operations.
Transformation Rule 17 (VariableExp) In Deﬁnition 2.11, it has already been
made clear that self is a keyword. More precisely, it is a variable pointing to an
object  within a given scope, in the deﬁnition the evaluation of a single invariant
for single object. To ensure that an invariant is also satisﬁed by an assignment to the
variables of the general symbolic formulation, self must also refer to an object 
and, thus, it is assumed here that it is known to which object self is pointing to.
Each occurrence of self is replaced by a placeholder Þ W c with  being an
object instance of the class c. The same holds also for all other variables referring
to an object instance of any class of the model.
Variables which are not referring to an object instance of a class but to a Boolean
or integer are replaced by the respective value to be provided by the scope and are
treated like constants.
Please note that instead of the placeholder construction, it would be of course
possible to directly use the object . However, an object reference is not directly
available in the SMT-LIB realization and, therefore, the placeholder construction
has been introduced. Before giving the SMT-LIB realization of VariableExp,
the general idea of PropertyCallExp should be explained.
Transformation Rule 18 (PropertyCallExp) A
PropertyCallExp
is
used to get the value of an attribute of a reference of an object instance of a

68
3
A Symbolic Formulation for Models
class.10 It can be used, e.g., on the variable self or in a nested manner to get the
value of an attribute of the linked object. A PropertyCallExp always refers
the attribute name a or a role name of a reference end rc. Further, it is assumed
that a PropertyCallExp is called only on single objects and not a collection.
In the latter case, an implicit conversion will be applied which uses the collect
IteratorExp, e.g., self.Prop1.Prop2 is converted to self.Prop1->collect(temp1
: ClassOfProp1 | temp1.Prop2) This case will be handled later. Concerning the
handling of irregular object references, the OCL speciﬁcation says:
Any property call applied on null results in invalid.
Consequently, if an attribute a is called on the object Þ, it is replaced by the
variable ˛
a . If a relation end rc is called on the object Þ, it is replaced by
the variable 
rc. Note that in both cases the placeholder Þ will vanish and only
the ˛
a /
rc variable remains in the constraint for the general symbolic formulation.
If a PropertyCallExp is called on an unknown object reference, e.g., when
due to nested calls 
rc is the source/calling object, then it must be ﬁrst checked to
which object instance 
rc is referring to:
PropertyCallExp
Input: .
rc; ı
rc/, c D f0; 1; : : : ; jcj1g, and a property a
1: if ı
rc D – _ ı
rc D ? then
2:
.false; ?/
3: else
4:
if 
rc D 0 then
5:
.˛0
a ; ✓/
6:
else
7:
if 
rc D 1 then
8:
.˛1
a ; ✓/
9:
else
10:
:::
11:
if 
rc D jcj1 then
12:
.˛
jcj1
a
; ✓/
13:
else
14:
.false; ?/
If instead of an attribute a a relation end rc is called, then ˛a is replaced by rc
in the last pseudocode.
SMT-LIB Realization of Transformation Rule 17. In practice most of the place-
holders Þ will be removed by a PropertyCallExp in above hanging nodes of
the AST or in other words another OclExpression. However, it is also possible
to, e.g., compare a variable with another object or use a variable as an argument
for an OperationCallExp. In order to deal with those cases, all remaining
placeholders Þ must be realized using either constant bit vectors or bit vector
variables.
10Quote from the OCL spec: “A PropertyCallExpression is a reference to an Attribute of a Classiﬁer
deﬁned in a UML model. It evaluates to the value of the attribute.”

3.2
Transforming a Model into a Symbolic Formulation
69
A variable referring to a single object instance of a class c is encoded like a
class attribute (cf. Transformation Rule and it SMT-LIB Realization 4). Variables
for Booleans, integers, enums, and the different collection types are encoded like
the respective attributes or respective value.
SMT-LIB Realization of Transformation Rule 18. If a property is called on Þ,
the respective object is known and the replacement can be done as in the general
symbolic formulation. Of course, to ensure the pair notation maybe a let must be
used.
If a property is called on an unknown object, the transformation is done using
the following SMT-LIB code where .src; ısrc/ is the unknown reference to source
object:
1 (let ( (prop (ite (notRegular ısrc)
2
#b02;k
3
(ite (= src #b0: : :01)
4
˛0
a
5
(ite (= src #b0: : :010)
6
˛1
a
7
:::
8
(ite (= src #b10: : :0)
9
˛
jcj1
a
10
#b02;k): : :)
11
12
(ıprop (ite (notRegular ısrc)
13
?
14
(ite (or (= src #b0: : :001)
15
(= src #b0: : :010)
16
: : :
17
(= src #b10: : :00))
18
✓
19
?)))
20
)
21
transformed OclExpression above using src and ısrc
22 )
Transformation Rule 19 (IteratorExp) “An IteratorExp is an expression that
evaluates its body expression for each element of a collection. It acts as a loop
construct that iterates over the elements of its source collection and results in a
value” [Obj14, p. 46]. To iterate over the source collection, in most cases an iterator
variable is used. While the evaluation on a precise system state always provides a
precise source collection, this is not the case for the general symbolic formulation.
This means that an IteratorExp must always iterate over all possible elements
of the source collection, since the precise elements will be known after obtaining
an assignment to the variables and not before. To distinguish between the different

70
3
A Symbolic Formulation for Models
iterators, the IteratorExp provides a name which can be, e.g., forAll, exists,
one, select, reject, collect, collectNested, closure, any, etc.
For the ﬁrst two iterators, a transformation rule must respect the fact that forAll
is deﬁned using the OCL and operation and exists using OCL or, i.e., if there is any
element in the source collection for which the body expression evaluates to false
(true) the result is false (true) for forAll (exists).
forAll-IteratorExp
Input: .src; ısrc/, all possible objects of src: src D f0; 1; : : : ; jsrcj1g, it the
iterator variable name, and the body expression f
1: for all  2 src do
2:
.f; ıf/  result of evalit f
3: if ısrc ¤ ✓then
4:
.false; ?/
5: else
6:
if .0 2 src ^ .f0; ıf0 / D .false; ✓// _ : : : _ .jsrcj1 2 src ^
.fjsrcj1; ıfjsrcj1/ D .false; ✓// then
7:
.false; ✓/
8:
else
9:
if .0 2 src ^ ıf0 D ?/ _ : : : _ .jsrcj1 2 src ^ ıfjsrcj1/ D ?/ then
10:
.false; ?/
11:
else
12:
if .0 2 src ^ ıf0 D –/ _ : : : _ .jsrcj1 2 src ^ ıfjsrcj1 / D –/ then
13:
.false; –/
14:
else
15:
.true; ✓/
exists-IteratorExp
Input: .src; ısrc/, all possible objects of src: src D f0; 1; : : : ; jcj1g, it the
iterator variable name, and the body expression f
1: for all  2 src do
2:
.f; ıf/  result of evalit f
3: if ısrc ¤ ✓then
4:
.false; ?/
5: else
6:
if .0 2 src ^ f0 D true/ _ : : : _ .jsrcj1 2 src ^ fjsrcj1 D true/
then
7:
.true; ✓/
8:
else
9:
if .0 2 src ^ ıf0 D ?/ _ : : : _ .jsrcj1 2 src ^ ıfjsrcj1/ D ?/ then
10:
.false; ?/
11:
else
12:
if .0 2 src ^ ıf0 D –/ _ : : : _ .jsrcj1 2 src ^ ıfjsrcj1 / D –/ then
13:
.false; –/
14:
else
15:
.false; ✓/

3.2
Transforming a Model into a Symbolic Formulation
71
Table 3.5 Mapping of OCL
IteratorExp
ocl OP
OP conditionOP
OP—object
select
.f ; ıf / D .true; ✓/

reject
.f ; ıf / D .false; ✓/

collectNested
true
.f ; ıf /
To derive a transformation rule for the remaining IteratorExp, it should be
ﬁrst mentioned that the result is always a sub-collection of the source collection.
The body expression must be, again, evaluated for every possible element which
might be in the source collection. If the body expression of a single element which is
really an element of the source collection evaluates to invalid, instead of the sub-
collection invalid is the result. If the body expression of a single element which
is indeed an element of the source collection evaluates to null, the evaluations
will be done normally. The precise union S of the transformation rules depends on
Table 3.5 as well the respective collection type of the source collection. For example,
collectNested will return a bag, if it is called on a set or bag, a sequence for an
ordered set as well as a sequence. The generic type of the returned sub-collection
does not change for select and reject and it is body.type for collectNested, i.e., the
type of the body expression. However, for more details, the reader is referred to the
respective of the OCL speciﬁcation, mainly [Obj14, Sect. 11.9 on pp. 177ff.].
select, reject, collect-IteratorExp skeleton
Input: .src; ısrc/, all possible objects of src: src D f0; 1; : : : ; jcj1g, it the
iterator variable name, and the body expression f
1: for all  2 src do
2:
.f; ıf/  result of evalit f
3: if ısrc ¤ ✓then
4:
.false; ?/
5: if .0 2 src ^ ıf0 D ?/ _ : : : _ .jsrcj1 2 src ^ ıfjsrcj1 D ?/ then
6:
.false; ?/
7: else
8:
.
S
2src
2src
Add: OP condition
OP  object; ✓/
At the beginning of this transformation rule, more than just the three iterators
have been mentioned. The remaining iterator names can be mapped using other
operations and the currently explained iterators.
The one iterator is mapped to select(one.body)->size() = 1, where one.body is
the body expression used for one. The any iterator is similar to select, but instead
of the sub-collection just one arbitrarily chosen element of it is returned. If the sub-
collection is empty, the result is invalid.
The collect iterator is mapped to collectNested->flatten(). Unfortunately, the
flatten operation is called recursively until the source collection does not contain
another collection as an element. In OCL, this is possible since OclAny is a
superclass/type of all OCL expressions. However, the type system of the general
formulation does not support those concepts in its current form, thus, collect will

72
3
A Symbolic Formulation for Models
not be considered further—except for the implicit conversion in navigation chains
using PropertyCallExp in the SMT-LIB realization. The recursive calls of
closure are also the reason why it is not considered here. Due to the problem bounds,
it would be in general possible to break down the recursion to a bounded number of
operation calls, but, it will not be done in the book at hand.
SMT-LIB Realization of Transformation Rule 19.
The pre-calculation of the
transformation rules (cf. the for-all-loop) can be done using SMT-LIB let and is
identical for all three cases. Furthermore, the pre-calculation has to be done only
once for an element, i.e., if an element is more than once in a collection (not for
sets!), the result will be the same and can be re-used:
1 ; src and ısrc are known from
the
t r a n s f o r m a t i o n
before
2 (let ( (it0 transformed 0 reference of value)
3
(ıit0 ✓)
4
(inSrc0 Boolean if 0 2 src or not)
5
: : :
6
(itjcj1 transformed jcj1 reference of value)
7
(ıitjcj1 ✓)
8
(inSrcjcj1 Boolean if jcj1 2 src or not)
9
)
10
(let ( (f0 evaluation of f for it0 and ıit0 )
11
(ıf0 evaluation of f for it0 and ıit0 )
12
: : :
13
(fjcj1 evaluation of f for it0 and ıit0 )
14
(ıfjcj1 evaluation of f for it0 and ıit0 )
15
)
16
iterator specific part
17
)
18 )
The Boolean SMT-LIB auxiliary variables inSrc are used to avoid redundant
calculations, if the corresponding element is indeed an element of the source
collection or not. The precise SMT-LIB realization depends on the collection type
of the source collection. For a set, only the corresponding bit must be compared
with #b1. For a bag, the bits reserved to represent the number of contained copies
must be different from #b0: : :0. For an ordered set, the bits reserved to represent
the index must also differ from #b0: : :0. For a sequence, it is necessary to check, if
the bits reserved to represent the index of the maybe ﬁrst copy differs from #b0: : :0.
The precise SMT-LIB code is omitted.
With this information, it is now possible to formulate the forAll and exists
iterator in terms of SMT-LIB:
1 ;
f o r A l l
i t e r a t o r
s p e c i f i c
p a r t :
2 (let ( (forAll (ite (notRegular ısrc)
3
false

3.2
Transforming a Model into a Symbolic Formulation
73
4
(ite (and (=> inSrc0
5
f0 )
6
: : :
7
(=> inSrcjcj1
8
fjcj1 )
9
true
10
false) ) ) )
11
)
12
(ıforAll (ite (notRegular ısrc)
13
✓
14
(ite (or (and inSrc0
15
(= f0 false)
16
(isRegular ıf0 ))
17
: : :
18
(and inSrcjcj1
19
(= fjcj1 false)
20
(isRegular ıfjcj1)) )
21
✓
22
(ite (or (and inSrc0
23
(isInvalid ıf0 ))
24
: : :
25
(and inSrcjcj1
26
(isInvalid ıfjcj1)))
27
?
28
(ite (or (and inSrc0
29
(isNull ıf0 ))
30
: : :
31
(and inSrcjcj1
32
(isNull ıfjcj1 )))
33
–
34
✓))))
35
)
36
further processing with the result
37 )
1 ;
e x i s t s
i t e r a t o r
s p e c i f i c
p a r t :
2 (let ( (exists (ite (notRegular ısrc)
3
false
4
(ite (or (and inSrc0
5
f0 )
6
: : :
7
(and inSrcjcj1

74
3
A Symbolic Formulation for Models
8
fjcj1 ))
9
true
10
false) ) )
11
(ıexists (ite (notRegular ısrc)
12
✓
13
(ite (or (and inSrc0
14
f0 )
15
: : :
16
(and inSrcjcj1
17
fjcj1 ))
18
✓
19
(ite (or (and inSrc0
20
(isInvalid ıf0 ))
21
: : :
22
(and inSrcjcj1
23
(isInvalid ıfjcj1)))
24
?
25
(ite (or (and inSrc0
26
(isNull ıf0 ))
27
: : :
28
(and inSrcjcj1
29
(isNull ıfjcj1 )))
30
–
31
✓))))
32
)
33
)
34
further processing with the result
35 )
Instead of a skeleton for select, reject, and collect, only the precise formulation
for select will be given in the following. However, it will be described afterwards
which changes have to be applied to derive the SMT-LIB realization of reject or
collect, respectively.
1 ;
s e l e c t
f o r
the
remaining
i t e r a t o r
s p e c i f i c
p a r t s :
2 (let ( (skeleton (ite (notRegular ısrc)
3
#b02;k
4
(ite (or (and inSrc0
5
(isInvalid ıf0 ))
6
: : :
7
(and inSrcjcj1
8
(isInvalid ıfjcj1)))
9
#b02;k
10
(concat (ite (and inSrc0

3.2
Transforming a Model into a Symbolic Formulation
75
11
f0 )
12
#b1
13
#b0)
14
: : :
15
(ite (and inSrcjcj1
16
fjcj1)
17
#b1
18
#b0)
19
20
) ) )
21
(ıskeleton (ite (notRegular ısrc)
22
?
23
(ite (or (and inSrc0
24
(isInvalid ıf0 ))
25
: : :
26
(and inSrcjcj1
27
(isInvalid ıfjcj1)))
28
?
29
✓) ) )
30
)
31
further processing with the result
32 )
For the SMT-LIB realization of reject instead of the value (cf. f in Line 11
and 16), it must be checked if the value equals false and at the same time is a
regular value. The changed condition of the ite then is:
1 .. (and inSrc0
2
(= f0 false)
3
(= ıf0 ✓)) ...
So far, it has tacitly been assumed that the resulting sub-collection is a set and,
thus, also the source collection. However, it has already been explained how other
source collections can be handled to check if an element is really a part of the source
collection or not. But also the resulting sub-collection will always differ if the source
collection type differs.
If select or reject is called on a bag, the result is also a bag and instead of
#b1 (cf. Line 12 and 17) the number of copies in the source bag is used, i.e., the
part of the bit mask for the speciﬁc element, and instead #b0 (cf. Line 13 and 18)
#b02;k is used. For ordered sets and sequences, the idea is to ﬁrst copy the index (or
indices) or a constant zero bit string of the same bit width and then in a second step
re-use the result and ensure that the indices are decreased until a valid ordered set
or sequence is obtained which, of course, must have the same order as in the ﬁrst
step.

76
3
A Symbolic Formulation for Models
To realize a collectNested in SMT-LIB syntax, one should know that the result of
the body expression for different elements can be equal. Hence, the general idea is
to calculate a bag with the same number of copies as in the source collection (for
set and bag only) or an empty bag if no copy is in the source collection and then
calculate the union of all bags and return it as the result.
Some readers might have noticed that no SMT-LIB realization of the implicit
conversion using collect mentioned in PropertyCallExp has been given so far.
If the source collection is still a set of object instances (or reference to the object
instances), the collectNested SMT-LIB realization will already return the desired
results for collect. If the source is a bag of some class c, collectNested will return
a bag of bags of the related class c0. But a union over the elements of (outer) bag
will result in a bag of c0 which is exactly the desired result for collect. The precise
SMT-LIB realization details are omitted, but they can be assembled using other parts
of this subsection.
The any operation picks exactly one element of the source collection for which
the body expression evaluates to true. Therefore the operation is ﬁrst mapped to
select(any.body)-> asSet() and then the following SMT-LIB constraints are applied
to apply OCL any:
1 (declare-fun anyHelper () (_ BitVec k ))
2 ((_ card_eq 1) anyHelper)
3
4 (...
5 ;
from
the
mapping
select(any.body)->asSet() the
f o l l o w i n g
6 ;
v a r i a b l e s
are known : asSet and ıasSet
7
(let ( (any (ite (notRegular ıasSet)
8
#b02;k
9
(ite (= asSet #b02;k)
10
#b02;k
11
anyHelper) ) )
12
(ıany (ite (notRegular ıasSet)
13
?
14
(ite (= asSet #b02;k)
15
?
16
✓) ) )
17
)
18
(and (=> (not (= asSet #b02;k))
19
((_ card_eq 1) (bvand asSet anyHelper)))
20
further processing with the result
21
)
22
)
23 )

3.2
Transforming a Model into a Symbolic Formulation
77
There are still many OCL operations missing, basically the ones working on
collections have not been considered so far. The basic concepts have already been
published by Soeken et al. in [SWD11a]. However, the authors have not considered
the 4-valued OCL logic, but a mix between the 2-valued and 3-valued ones.
Furthermore, the encoding does not have something like the ˇ and/or ı-variables
as proposed and used in this chapter. Nevertheless, the idea how the different
regular values are transformed into a general symbolic formulation and how they
are realized using the SMT-LIB syntax can be taken from there. In the following,
only the operations for sets are given—with some exceptions.
Transformation Rule 20 (Operations on Collections) For every class
of a given UML/OCL model, it is possible to get the set of all object instances
within a system state: ClassName.allInstances(). The transformation depends on the
question whether the number of objects can vary or not, in other words, are ˇ-
variables used or not. If the number of objects can vary, the result of the allInstances
operation is ˇc with c being the calling class. If the number of objects is constant
for a class, then the result is a constant true-function. To make the result of the
operation comparable with other OCL operations the respective result must be a
pair with ✓as the second entry. Furthermore, it is again necessary to extend the
universe such that null theoretically can be an element of the result collection.
However, like for associations, this must be prohibited. Besides the classes of
a model, allInstances can also be called on all other types, e.g., Boolean or
integer. In those cases, the result is a regular set containing all regular values.
The size operation is transformed as follows:
size Transformation
Input: .src; ısrc/, all possible objects of src: src D f0; 1; : : : ; jsrcj1g
1: if ısrc D – _ ısrc D ? then
2:
.false; ?/
3: else
4:
.
P
x2src
src.x/Dtrue
1; ✓/ // for sets
5:
. P
x2src
src.x/; ✓/ // for bags
6:
. P
x2src
src.x/>0
1; ✓/ // for ordered sets
7:
.
P
x2src
src.x/¤f0g
jsrc.x/j; ✓/ // for sequences
The transformation of isEmpty and notEmpty must respect the following quote,
cf. [Obj14, Sect. 11.7.1 on p.166]:
Note: null->isEmpty() returns ‘true’ in virtue of the implicit casting from null to Bag
isEmpty Transformation
Input: .src; ısrc/, all possible objects of src: src D f0; 1; : : : ; jsrcj1g
1: if ısrc D ? then
2:
.false; ?/

78
3
A Symbolic Formulation for Models
3: else
4:
if ısrc D – then
5:
.true; ✓/
6:
else
7:
.8x 2 src W src.x/ D false; ✓/ // for sets
8:
.8x 2 src W src.x/ D 0; ✓/ // for bags
9:
.8x 2 src W src.x/ D 0; ✓/ // for ordered sets
10:
.8x 2 src W src.x/ D f0g; ✓/ // for sequences
The notEmpty transformation can be derived by negating the result of isEmpty or
the single results in Lines 5 and 7–10.
The next operations do not only have a source collection as the calling object
.src; ısrc/ but also an argument .arg; ıarg/. Furthermore, it is assumed that the type
of the argument is equal to the generic type of the source collection or a subclass (of
the generic type). The includes operations should be true if the element belonging
to the argument is inside the source collection:
includes Transformation
Input: .src; ısrc/, .arg; ıarg/,
1: if ısrc D ? _ ıarg D ? then
2:
.false; ?/
3: else
4:
if ısrc D – then
5:
.false; ✓/
6:
else
7:
.src.arg/ D true; ✓/ // for sets
8:
.src.arg/ > 0; ✓/ // for bags
9:
.src.arg/ > 0; ✓/ // for ordered sets
10:
.src.arg/ ¤ f0g; ✓/ // for sequences
The OCL excludes operations should return true, if the element belonging to the
argument is not an element of the source collection. It can be realized by negating
the respective single results in the includes transformation.
The includesAll expects a collection as an argument where the generic type of
the argument collection must be equal or a subclass of the generic type of the source
collection. The result should be only true, if all elements of the argument collection
are also an element of the source collection.
includesAll Transformation
Input: .src; ısrc/, .arg; ıarg/,
1: if ısrc D ? _ ıarg D ? then
2:
.false; ?/
3: else
4:
if ıarg D – then
5:
.true; ✓/
6:
else
7:
if ısrc D – then
8:
.false; ✓/

3.2
Transforming a Model into a Symbolic Formulation
79
9:
else
10:
.8x 2 arg W src.x/ D true; ✓/ // for sets
11:
.8x 2 arg W src.x/ > 0; ✓/ // for bags
12:
.8x 2 arg W src.x/ > 0; ✓/ // for ordered sets
13:
.8x 2 arg W src.x/ ¤ f0g; ✓/ // for sequences
Again, for the counterpart called excludesAll the single results have to be
negated.
The operations including and excluding return a new collection which is equal
to the source collection but additionally includes or excludes, respectively, the
argument element.
including Transformation
Input: .src; ısrc/, all possible objects of src: src
D
f0; 1; : : : ; jsrcj1g,
.arg; ıarg/,
1: if ısrc D ? _ ıarg D ? then
2:
.false; ?/
3: else
4:
if ısrc D – then
5:
// null is implicitly casted to Set<null>
6:
8x 2 src n fargg W including.x/  false
7:
including.–/  true
8:
if ıarg D – then
9:
.including; ✓/
10:
else
11:
including.arg/  true
12:
.including; ✓/
13:
else
14:
if ıarg D – then
15:
8x 2 src;– n f–g W including.x/  src.x/
16:
including.–/  true // for sets
17:
including.–/  including.–/ C 1 // for bags
18:
.including; ✓/
19:
else
20:
8x 2 src;– n fargg W including.x/  src.x/
21:
including.arg/  true // for sets
22:
including.arg/  including.arg/ C 1 // for bags
23:
.including; ✓/
The transformation of intersection and union is similar to excluding or including,
respectively. But instead of a single element the argument is a collection and,
therefore, the resulting collection depends on the collection type or the source
as well as the collection type of the argument. All valid combinations and the
resulting collection types are given in Table 3.6. Complete transformation rules
are omitted here, because they can be realized using asSet and asBag and then apply
the excluding or including transformation. Note that the intersection of two bags is
the minimum number of copies per element.

80
3
A Symbolic Formulation for Models
Table 3.6 Possible combinations of collection types for union and intersection
Source
Argument
union Result
intersection Result
Set
Set
Set
Set
Set
Bag
Bag
Set
Bag
Set
Bag
Set
Bag
Bag
Bag
Bag
Sequence
Sequence
Sequence
Not deﬁned
SMT-LIB Realization of Transformation Rule 20.
The handling of nonregular
values has now been presented several times on the last pages for different OCL
operations, hence, the focus is now on the realization of the OCL operations.
The size is realized like the sum for associations in order to ensure the
multiplicities (cf. SMT-LIB Realization for Transformation Rule 6 on page 41).
However, some changes are necessary: For a bag the number of copies is used
instead of a constant 0 or 1. Depending on the problem bounds the bit mask for the
number of copies must be ﬁlled with zeros before. For an ordered set, it must be
checked if the bits reserved for the index is greater than 0 or not and then 1 or 0 is
added. For sequences, every possible copy of every element it must be checked if the
index is greater than 0 or not and, again, 1 or 0 is added.
The isEmpty operation can be realized with a single comparison as follows:
1 .. (= #b02;k src) ..
where k depends on the bit width of the collection type. For notEmpty the result must
be negated using not.
For the includes, it is assumed that in a pre-calculation step, the source has been
transformed to a set of the regular values only called src, i.e., there is no bit for the
null reference left11:
1 .. (not (= (bvand arg
2
src)
3
#b02;k)) ..
The excludes operation is realized in the same fashion, but without the not.
For the includesAll operation it is again assumed that src and arg are already
transformed to bit vectors of a set, but now, there must be a bit for every regular
value as well as one bit for null:
1 .. (= (bvand arg
2
src)
3
arg)) ..
The OCL including operations for sets can be easily realized by:
11This can be easily done using extract and maybe concat afterwards.

3.2
Transforming a Model into a Symbolic Formulation
81
1 ;
i n c l u d i n g
f o r
s e t s
2 .. (let ( (including (bvor arg
3
src) ) ) .. ) ..
Note that arg and src are both bit masks for the regular values only. For bags,
it is unfortunately, in general, not clear which element is behind arg, hence, the
resulting bit mask must be composed with a concat iterating over all possible
elements. FIRST and LAST are just placeholders for the respective start and end
bits of the respective bit mask parts:
1 ;
i n c l u d i n g
f o r
bags
2 .. (let ( (including
3
(concat (ite (= arg #b0 : : : 01)
4
(bvadd ((_ extract FIRST) src)
5
#b0 : : : 01)
6
((_ extract FIRST) src))
7
: : :
8
(ite (= arg #b10 : : : 0)
9
(bvadd ((_ extract LAST) src)
10
#b0 : : : 01)
11
((_ extract LAST) src)) ) )
12
) .. ) ..
The intersection operation is realized by ﬁrst transforming the source and the
argument to a set, if one of both is a set:
1 ;
i n t e r s e c t i o n
i f
source or element
i s
a
s e t
2 .. (let ( (intersection (bvand arg
3
src) )
4
) .. ) ..
If both are bags, then result is again composed:
1 ;
i n t e r s e c t i o n
i f
source and element
are
bags
2 .. (let ( (intersection
3
(concat (ite (bvult ((_ extract FIRST) src)
4
((_ extract FIRST) arg))
5
((_ extract FIRST) src)
6
((_ extract FIRST) arg))
7
: : :
8
(ite (bvult ((_ extract LAST) src)
9
((_ extract FIRST) arg))
10
((_ extract LAST) src)
11
((_ extract LAST) arg)) ) )
12
) .. ) ..

82
3
A Symbolic Formulation for Models
The union operation can be realized with a bvor as follows, if both source and
argument are a set:
1 ;
union
i f
source
and
element
are
s e t s
2 .. (let ( (union (bvor arg
3
src) )
4
) .. ) ..
If otherwise at least one of both is a bag, the result again is composed:
1 ;
union
i f
source
or
element
i s
a bag
2 .. (let ( (union
3
(concat (ite (bvadd ((_ extract FIRST) src)
4
((_ extract FIRST) arg))
5
((_ extract FIRST) src)
6
((_ extract FIRST) arg))
7
: : :
8
(ite (bvadd ((_ extract LAST) src)
9
((_ extract FIRST) arg))
10
((_ extract LAST) src)
11
((_ extract LAST) arg)) ) )
12
) .. ) ..
The last transformation rules have partially used the operations asSet, asBag,
asOrderedSet, and/or asSequence. All four operations can be called on every OCL
type. Since all names are self-explaining and the structures of all four collection
types have been introduced in detail, only some comments about the SMT-LIB
realization will be given in the following, but no transformation rules for the general
symbolic formulation.12
The SMT-LIB realization for asSet is done using concat and ite which in
turn is checking if the number of copies is greater than 0 for a bag, if the index is
greater than 0, or if the index of the ﬁrst copy of an element is greater than 0 for a
sequence. In a similar way, asBag is realized and the number of copies is set to 1 for
a set and an ordered set or to the number of copies where the index is greater than 0.
Before concluding this subsection, three more OCL operations shall be intro-
duced, even if the precise constraints and the SMT-LIB realizations are omitted:
The oclIsUndefined operation evaluates to true, if the calling source object is
equal to invalid or equal to null. Otherwise it is false. It can be called on
any object. Obviously, this can be done using the ı-variables.
The oclIsTypeOf operation can also be called everywhere. It evaluates to true,
if the source is of the type t (given as an argument) but not a subtype of t. Besides
oclIsTypeOf, there is the oclAsType operation which basically casts an object to the
12If asOrderedSet or asSequence is called on an un-ordered collection type like set of bag, the
resulting collection type can have any order unless all elements are contained.

3.3
Adding Veriﬁcation Tasks
83
type t (again given as an argument). If t is a supertype of the source, then the casted
object is returned, otherwise invalid. Now, the introduced general symbolic
formulation has nearly reached its end, because integrating a complete type system
inside the formulation is a tough nut. It could maybe be implemented by adding a
third variable category 	 besides the one for the regular values and the deﬁnedness.
However, a limited functionality is already possible with the current formulation.
If there is no relation between the source object and the type t, the result is clear. If
there is a relation, it can be checked to which object of the system state a reference
is pointing to for transforming oclIsTypeOf or the type of the reference is changed
to t by creating a new bit vector with zeros at the positions for the new objects of
the extended universe for oclAsType.
3.3
Adding Veriﬁcation Tasks
With the transformation rules for the symbolic formulation as well as the SMT-
LIB realization it is now possible to determine an assignment of a precise system
state of a given model m respecting given problem bounds. In other words, the
designer has only to provide the model as well as the problem bounds and from here
on everything can automatically be transformed into a decision problem using the
SMT-LIB syntax and an SMT-solver can (automatically) determine an assignment
from which a system state can be derived. In this section, the symbolic formulation
is used to formulate model independent veriﬁcation tasks. They are divided into two
groups, structural and behavioral, and are explained as next.
3.3.1
Structural Veriﬁcation Tasks
This subsection ﬁrst introduces the basic veriﬁcation task consistency in two
different variants, so-called weak and strong consistency. Afterwards, inconsistent
models and invariant independence are roughly sketched.
When explaining the general ﬂow in Sect. 3.1 the problem bounds have been
introduced as a list mapping a nonabstract class to a ﬁxed natural number of objects
to be in the system state, later in Sect. 3.2.3 the concept has been extended to either
a ﬁxed natural number or an interval with a lower and an upper bound.13 When
explaining this extension, it has already been mentioned that when all lower bounds
are set to 0, it must be ensured that the system state itself is not empty. This has
13In the following, the terms lower and upper bound are frequently used for both, the ﬁxed number
of objects and the interval. For a ﬁxed number of objects, the number itself can be seen as the lower
and the upper bound simultaneously.

84
3
A Symbolic Formulation for Models
tacitly been assumed when deﬁning a consistent model (cf. Deﬁnition 2.13) and is
now discussed in more detail.
Referring to [CCR07, CCR08, CCR14], there are two different kinds of consis-
tent models: weak and strong ones.14
Deﬁnition 3.1 (Weak Consistent Model) A model m D .C; R/ is called weak
consistent, if at least one valid system state  2 Vm exists which consists of at
least one object of any class c 2 C.
Deﬁnition 3.2 (Strong Consistent Model) A model m D .C; R/ is called strong
consistent, if at least one valid system state  2 Vm exists which consists of at least
one object for each nonabstract class c 2 C.
The symbolic formulation already provides a mechanism to implement strong
consistency: If the designer sets the lower bounds of all nonabstract classes to 1,
only system states satisfying Deﬁnition 3.2 will be determined.
At a ﬁrst glance, setting the lower bounds of all nonabstract classes to 0 might be
sufﬁcient to implement weak consistency, however, it has already been mentioned
that system states should be not empty. Therefore, an additional constraint is added
to the symbolic formulation such that at least one object is present in a system state
and, thus, the system state is not empty.
Transformation Rule 21 (At Least One Object) For ensuring that a system state
contains at least one object of any class, the following constraint is added to the
symbolic formulation:
9 c 2 C W 9  2 c W ˇc./ D true
SMT-LIB Realization of Transformation Rule 21. The SMT-LIB realization for
at least one object in any class makes use of cardinality constraints which are only
satisﬁed, iff at least one bit of the passed bit vector variables is assigned to 1 which
means that the object belonging to the bit is present:
1 (or ((_ card_ge 1) ˇc0)
2
: : :
3
((_ card_ge 1) ˇcjCj1)
4 )
The general idea for the transformation of a system state for both types of
consistency is clariﬁed now. However, invariants have to be satisﬁed for present
objects only, of course, not only for consistency but also for other veriﬁcation tasks.
So, the symbolic formulation of a system state has to be extended.
14Note that the cited works are using the terms weak and strong satisﬁability of a model instead of
consistency. However, in order to avoid confusion with the satisﬁability of SAT or SMT instances
this book uses weak and strong consistency.

3.3
Adding Veriﬁcation Tasks
85
Transformation Rule 22 (System State) While in a regular system state  of a
model m D .C; R/ an invariant must be satisﬁed for all objects of the respective
class, this is, in general, not necessary for all objects in the un-assigned system
state. This is caused by maybe absent objects and can be taken into account with
the following constraint:
8 c 2 C W 8  2 c W ˇc./)I;fself7!g
m
D .✓; true/
where I are the invariants of the class c D .A; O; I/ and I;fself7!g
m
is shorthand
notation for the transformed invariants. The shorthand notation has the model m,
the un-assigned system state  (i.e., the system for which an assignment to variables
should be determined), and a map providing a reference for self as indices. They
are necessary to transform the invariants. The equation I;fself7!g
m
D .✓; true/
means that every transformed invariant i 2 I is equal to .✓; true/, so, the precise
deﬁnition is
I;fself7!g
m
D .✓; true/ W, 8 i 2 I W i;fself7!g
m
D .✓; true/
In a similar fashion, constraints for the multiplicities have to be ensured for
present objects only.
Let’s assume that a given model is inconsistent, i.e., proven to be neither weak nor
strong consistent by the proposed ﬂow and an SMT solver. This may be caused by
the complexity of the description. Such a model is obviously considered erroneous
and it is the designers task to ﬁx it. For this purpose, Sect. 4.1 explains how the
presented ﬂow with its symbolic formulation can be re-used to aid the designer in
this ﬁxing process. Other approaches are also discussed there.
Models have been introduced as one promising way to deal with the complexity
of nowadays systems. Hence, they represent an abstraction of the system in early
stages of the design ﬂow and should be as small as possible, such that it is easy to
keep an overview for the designer, while being appropriate at the same time. Too
complex models can easily result in an inconsistent model. To prevent this point,
one possibility is to minimize the number of invariants such that no invariant can
be implied by the remaining ones. One speaks in this context of an independent or
dependent invariant. In Sect. 4.2 the precise deﬁnitions are given and it is further
explained how the symbolic formulation can be used to decide whether a given
invariant is independent or dependent. Thus, precise details are omitted here.
3.3.2
Behavioral Veriﬁcation Tasks
Besides pure structural issues to be considered, models also include behavioral
speciﬁcations in terms of operations with pre- and postconditions. Hence, the
correctness of these descriptions may also be of interest to the designer. Although

86
3
A Symbolic Formulation for Models
all necessary information is provided by the operation contracts, the full model’s
behavior can hardly be grasped from the class diagram representation. Instead,
behavioral veriﬁcation in formal speciﬁcations is illustrated by unfolding the
complete possible behavior of a model using a so-called state space graph.
Given a model m, a state space graph is a ﬁnite state machine FSM D .Vm; 0; ı/
with the state space being all valid states of the model Vm, an initial state 0 2 Vm,
and a partial transition relation ı W Vm  ˝m ! Vm which maps a state and an
operation call to a next state. The set ˝m returns the union of all operation calls from
all classes in m (cf. Deﬁnition 2.14) and requires that the designer provides problem
bounds where at least the upper bounds are equal for all system states  2 Vm.
Given a current state , a next state 0, and an operation call ! D .; o/ with o D
.P; r; C; B/, then ı.; !/ D 0 holds, if for all p 2 C W evalm;p;./ D true, i.e.,
if the preconditions hold in the current state , and for all p 2 B W evalm;p;.; 0/ D
true, i.e., if the postconditions hold for  as the current state and 0 as the next
state.
Example 14 Figure 3.7 shows a model of a simple trafﬁc light preemption which
also serves as a running example throughout the remainder of this behavioral
veriﬁcation tasks subsection.
Button
request()
Controller
request: Boolean
switchPedLight()
switchCarLight()
Signal
light: Color
≪enum≫
Color
Red
Green
2
buttons
1
controller
pedLight
1
0..1 pcontroller
carLight
1
0..1
ccontroller
context Button::request():
pre: controller.pedLight.light = #Red
post: controller.request = true
context Controller::switchPedLight():
pre: request = true
post:
pedLight.light
<> pedLight.light@pre
post: request = false
context Controller::switchCarLight():
post:
carLight.light
<> carLight.light@pre
context Controller inv safety:
not (
pedLight.light = #Green
and carLight.light = #Green)
context Controller inv oneRole:
pcontroller.oclIsUndefined()
xor ccontroller.oclIsUndefined()
Fig. 3.7 Trafﬁc light example

3.3
Adding Veriﬁcation Tasks
87
The main class of the example is the Controller which is connected to exactly one
trafﬁc light signal for the cars and exactly one trafﬁc light signal for the pedestrians.
Two buttons are connected to the controller that can be pushed in order to send a
request to the controller. This request is supposed to indicate whether pedestrians
want to pass the street.
The model consists of two attributes, i.e., a request ﬂag for the Controller
class storing whether a pedestrian has requested to cross and a light attribute for
the Signal class storing the current state. The invariant safety ensures a general
safety property for trafﬁc lights, i.e., both the signal for the pedestrians and the signal
for the cars must not be “green” at the same time. Finally, the invariant oneRole
ensures that an instance of the class Signal can either serve as a pedestrian light or
as a car light, but not as both.
The complete state space graph for two Signals, one Controller, and two Buttons
is given as15
switchCarLight
switchCarLight
switchCarLight
switchCarLight
request
request
request
request
switchPedLight
switchPedLight
(3.10)
where
is assumed as an initial state in which the cars are allowed to drive
(trafﬁc light on the right) and the pedestrians are required to wait (trafﬁc light on
the left). The request signal, illustrated as a circle between the trafﬁc lights, is ﬁlled
orange if and only if it is set to true. Note that the invalid states in which both signals
are green are not part of the state space graph and are being shown grayed out
only for a more comprehensive illustration. All states are connected by transitions
labeled by the respective operation call. The operation request can be called on
both objects of Button, however, the impact is the same and, thus, only request
is denoted next to the arrow.
Based on the state space graph, different (universal) behavioral veriﬁcation tasks
can now easily be described, for example:
Deﬁnition 3.3 (Reachability) The set of all reachable states R D Ri with at least
i operation calls is given as
15For the sake of convenience, only regular values are considered for the attributes.

88
3
A Symbolic Formulation for Models
Ri D
(
f0g
if i D 0;
Ri1 [ succ.Ri1/
otherwise
where
succ.R/ D
[
2R
f0 2 V .m/ j 9 o 2 ops.m/ W ı.; o/ D 0g
and 0 is an initial state.
Example 15 In (3.10), the system state
is a not reachable, because it has no
incoming edge.
Deﬁnition 3.4 (Deadlock) A deadlock  2 R is a system state such that
8 o 2 ops.m/ W ı.; o/ 62 V .m/;
i.e., there exists no valid transition from  to any other valid system state. Given this
information a serious design ﬂaw in the model can be immediately determined from
inspecting the state space graph.
Example 16 In (3.10), a deadlock state is given by
, since the corresponding
node has no outgoing edge.
Deﬁnition 3.5 (Livelock) A simple livelock scenario can be described as well. Let
a simple livelock state be a system state  in which at least one operation call can
be executed and all those operation calls lead to the system state , i.e.,  can never
be left again. Based on the set of reachable states R, a livelock  2 R is a system
state with
succ.fg/ D fg
Several other veriﬁcation tasks can be described in a similar fashion—both based
on the state space graph and the underlying modeling languages such as OCL.
Considering these discussions, the veriﬁcation of behavioral aspects is similar
to the veriﬁcation of structural aspects. In both cases, all possible system states
need to be considered and, in case of the veriﬁcation of behavioral aspects, a
sequence of system states as well as the transitions between them need to be
additionally considered. This leads to decision problems (either “Does there exist
a valid system state?” or “Does there exist a corresponding sequence of systems
states and operations?”, respectively) which are decidable. However, for practically
relevant models that are larger than the one given in Fig. 3.7, the search for those
system states and sequences may be a rather complex and cumbersome task. Hence,
efﬁcient approaches are required for this purpose.
In order to further address behavioral veriﬁcation tasks, an approach is proposed
that does not explicitly create a state space graph as currently discussed, but again

3.3
Adding Veriﬁcation Tasks
89
formulates the respective model instantiations, i.e., a sequence of system states,
and a veriﬁcation task in a symbolic fashion. This is conducted by adjusting the
veriﬁcation ﬂow for a single system state as shown in Fig. 3.1. The length of the
sequence, i.e., the number of system states or the number of operation calls denoted
by number of calls T, additionally has to be considered when creating the symbolic
representation. The number of calls T is another entry of the problem bounds. The
idea is visualized in Fig. 3.8: T C 1 system states, 0 till T, are connected with T
operation calls, !0 till !T1, between two succeeding system states.16
Like the valid system states in the state space graph, also every system state
of a sequence needs problem bounds where at least the upper bounds are equal.
Without this restriction, some OCL operations might cause problems during the
transformation. The lower bounds can be different for different system states, but if
all lower bounds are set to 0 for a system state, then at least one object constraints
are automatically added to the symbolic formulation of the corresponding system
state. Furthermore, the designer has to provide an initial state. This is important
since, otherwise, the set of reachable states cannot be determined.
Based on these inputs, the main idea is to represent all possible sequences with
T operation calls and T C 1 system states in terms of a symbolical formulation.
Figure 3.9 sketches the resulting structure of a mainly un-assigned sequence of
system states for the trafﬁc light model. How to obtain a symbolic formulation
and its SMT-LIB realization for a single system state has already been discussed
in detail, but how to represent all transitions between two succeeding system states
in the symbolic formulation is missing so far.
Transformation Rule 23 (Single Transition) Let  and 0 be two (un-assigned)
succeeding system states of a model m. Further, let ˝m D f!0; !1; : : : ; !j˝mj1g be
σ0
σ1
σT
. . .
0 ∈
m
1 ∈
m
T−1 ∈
m
w
W
W
W
w
w
Fig. 3.8 Unrolling the state space graph to sequence of system states
C0: Controller
request=false
S0: Signal
light=#Red
S1: Signal
light=#Green
B0: Button
B1: Button
pedLight
carLight
C0: Controller
request=?
S0: Signal
light=?
S1: Signal
light=?
B0: Button
B1: Button
pedLight
carLight
...
C0: Controller
request=?
S0: Signal
light=?
S1: Signal
light=?
B0: Button
B1: Button
pedLight
carLight
0
1
T−1
0
1
T
w
s
s
s
w
w
Fig. 3.9 Bit vector representation of a sequence of the system states
16With !i the precise operation call of the transition from i to iC1 is meant, while the set of all
operation calls is ˝m D f!0; !1; : : : ; !j˝mj1g.

90
3
A Symbolic Formulation for Models
the set of all possible operation calls which can be called in . Then, a variable
!!0 W f0; 1; : : : ; j˝mj  1g (D r˝m cf. Sect. 2.4) is created.17
Additionally, the following constraints are added to ensure a valid transition
^
!2˝
.!!0 D r˝m.!// )
0
BB@
ˇc./ D true
^ C;fself7!g
m
D .✓; true/
^ B;0;fself7!g
m
D .✓; true/
1
CCA
(3.11)
with ! D .; .P; r; C; B// and where C and B are the—like I—transformed
pre- and postconditions, respectively. If the set of parameters P is not empty, for
each parameter a variable is created like an attribute with the same type. If also a
real result is returned by the operation, then for r another variable is created.
Now, the symbolic formulation is capable of representing all possible sequences
with T operations calls and precise veriﬁcation for behavioral aspects can be added:
If the veriﬁcation task is to check whether a speciﬁc state can be reached or not.
The symbolic formulation for a sequence is used again. In this case we just have to
add constraints for the last system state which ensure that the speciﬁc system state
is reached. For this purpose a complete or just a partial initial system state can be
encoded.
The restrictions for the last system state can be done on two different ways. On
the one hand, the designer can directly add constraints to the symbolic formula
using the ˛ and  variables. On the other hand, it is also possible to formulate
invariants, transform them with a speciﬁc context to the last system state only in
order to restrict the valid values there. While the ﬁrst way will normally be faster in
a solving process, the second way does not require expert knowledge.
Such restrictions can also be used in order to describe any other system state
instead of giving a complete state like done for the initial state.
Another veriﬁcation which can be speciﬁed and applied is executability. It checks
whether an operation o of a class c can be executed and is done by adding the
following constraint
_
2c
!T1 D r˝

; o

:
(3.12)
There may be several operation calls ! which refer to the operation o. Each of the
operation calls is associated to a number which can be obtained from the relation r˝.
Executability is ensured if the last operation call !T1 meets one of these ids. In
Eq. (3.12),  is the operation’s caller. Since the equation requires that o is called in
the last operation, it is tailored for a scenario in which the proposed ﬂow is initialized
with one operation call that is incremented until a satisfying solution has been found.
17If the system states are numbered, instead of !!0 also !i is used for the transition between i
and iC1.

3.3
Adding Veriﬁcation Tasks
91
One may ﬁnd a witness faster using an alternative ﬂow in which a higher number of
operation calls is given initially and allows the operation to be called in any of the
system states. This can be done by extending (3.12) to
T1
_
tD0
_
2c
!t D id˝

; o

:
(3.13)
In practice both formulas should be used in a hybrid manner: Starting with a
reasonable number of operation calls it is ﬁrst checked whether the operation can
be called using Eq. (3.13). If this is not possible, the number of operation calls is
incremented iteratively and Eq. (3.12) is used to check whether the additional time
step enables the execution of the operation.
In order to formalize a veriﬁcation task that checks for a deadlock, the precondi-
tions as well as the interaction between preconditions, postconditions and invariants
need to be taken into account. More precisely, two different kinds of checks have to
be done.
First, it should be ensured that at least one precondition of all operation calls
cannot be satisﬁed in the last system state T, i.e.,
^
!2˝
.ˇc;T./ D true/ )
 _
p2C
pT;fself7!g
m
D .✓; false/
!
:
(3.14)
While the outer operator iterates over the set of all possible operation calls ˝
which contains all possible operation calls, the inner operator ensures that for each
operation call (with a present object as caller) at least one precondition fails.
For the second check consider the following deadlock scenario: For a system
state exists an operation which satisﬁes all preconditions, but applying the postcon-
ditions will cause a contradiction with at least one invariant. Thus, another clause
has to be considered. First, it has to be ensured that for each operation of each
object a so-called pseudo state is added, noted by Q. The pseudo state Q inherits
the problem bounds from the last system state T. Like for the un-assigned system
states, variables are created for attributes, etc. Then the following constraint must
be added:
^
!D.;o/2˝
.ˇc;T./ D true/ )
 ^
p2C
pT;fself7!g
m
^
p2B
p
T;Q!;fself7! Q
! g
m
^
_
i2I
iQ!;fself7!g
m
¤ .✓; true/
!
(3.15)

92
3
A Symbolic Formulation for Models
As a deadlock only has to satisfy one of the two scenarios, the complete encoding
is an or expression of the inner constraints of Eqs. (3.14) and (3.15). Note that for
the pseudo states at least one invariant evaluation has to differ from the value which
it must have in a valid system state.
Transformation rules for the generic symbolic formulation as well as the precise
SMT-LIB realizations are straightforward for currently introduced veriﬁcation
tasks, thus, details are omitted. Furthermore, the presented ﬂow can also be re-
used to realize other veriﬁcation tasks like Applicability, Redundant precondition,
Weak executability, Strong executability, Correctness preserving, Immutability, and
Determinism as presented in [CCR09].
3.4
Other Approaches for Model Validation and Veriﬁcation
In the past, many approaches for structural and also some for behavioral veriﬁcation
tasks have been published [AnaC07, CCR08, GBR07, SoeC10, TJ07]. Almost all
of them have dedicated advantages and disadvantages. As an example, the UML-
based Speciﬁcation Environment (USE) [GBR07] provides the already discussed
A Snapshot Sequence Language (ASSL) [GBR03, GBR05]. It has well-established
methods that can be applied, e.g., to (semi-)automatically generate system states
for the respective UML/OCL models. However, as already mentioned in the
introduction to this chapter, in order to determine such system states the designer
has to write an ASSL script, which implies that the designer has to learn ASSL.
Furthermore, the search procedure tries all system states enumerative, i.e., in a
worst-case scenario all system states, one at a time, have to be checked. Even for
small models, this can make the runtime escalate.
For newer versions of USE a so-called USE ModelValidator exists. It was
implemented as a plugin for the USE tool reusing parts of the architecture USE
provides (UML and OCL models and programming logic) and uses the Kodkod
library [TJ07] which provides the metamodel for relational logic and interfaces
to SAT solvers. This way the integration into the USE tool was given from the
beginning. This replaces the ASSL idea for model ﬁnding.
When the plugin was ﬁrst released, it came with several features to instantiate
UML/OCL models and check constraints to cover basic validation and veriﬁcation
use cases, e.g., checking model consistency by trying to generate a valid system
state, generating all valid solutions within the speciﬁed model bounds (which
are comparable to the problem bounds of the proposed approach) and checking
invariants for independency [GKH09]. Since then, the plugin is maintained and
constantly upgraded introducing new OCL operations like selectByKind and
selectByType and new features such as the classifying terms [GogC15].
Furthermore, the authors of USE have also published an approach how behavioral
aspects of models can be veriﬁed [HHG14, GogC14]. For this purpose, the source
model (called application model in their work) is transformed into a ﬁlmstrip model.
By doing so, all dynamic model aspects are transformed into static ones. Some

3.4
Other Approaches for Model Validation and Veriﬁcation
93
parts for a veriﬁcation task have to be performed manually like rewriting the OCL
constraints and formulating the exact veriﬁcation task. For detailed comparison of
the ﬁlmstrip model approach and the currently introduced unrolling approach, the
reader is referred to [HilC14b].
Besides USE, in the last two decades also other tools and concepts have been
published to verify UML/OCL models in both academia and industry. In the
following, other tools will be introduced.18
In 2013, the last update for OCLsolve—a Constraint Solver for UML/OCL19
was conducted and published. This tool provides a Java API to deﬁne a class
model inside a Java program and, on top of this, the designer can deﬁne OCL
expressions and check whether they are satisﬁable or not. To ﬁnally solve the
resulting satisﬁability problem SAT4J20 or MiniSat21 can be chosen. However, to
the best of our knowledge, no model format is deﬁned which can be parsed, thus, it
is necessary to describe the whole model in terms of a Java program. Furthermore,
methods to apply other checks than just structural consistency have not been found.
UML2Alloy,22 an alternative project, was started in 2005 [AnaC07]. Referring to
the manual online available the last update was in May 2009. UML2Alloy as a tool
is the product of the scientiﬁc approach to formalize UML using Alloy23 [Jac02b,
Jac02a, Jac12]. It translates UML class diagrams enriched with OCL constraints
to ﬁnally form an Alloy model. Afterwards, this Alloy model can be automatically
analyzed using the Alloy Analyzer.
Consequently, Alloy itself translates the given model into a Boolean expression to
be analyzed with an embedded SAT solver. Since version 4, Alloy includes Kodkod24
[TJ07] as analyzer. Kodkod can be used as a ﬁnite model ﬁnder and it also can
calculate minimal unsatisﬁable cores in case the SAT problem derived from the
ﬁnite model ﬁnding problem is UNSAT.
EMFtoCSP25 (successor of UMLtoCSP26) is a tool for the automatic veriﬁcation
of UML or EMF models annotated with OCL constraints which is currently
maintained by the SOM Research Team. This tool is based on the Eclipse Modeling
Framework (EMF) [SteC09] and realized as an Eclipse plugin which can automati-
cally check several correctness properties within the model such as the satisﬁability
of the model or the lack of contradictory constraints. As a solving engine in the
18Please note that the following descriptions of tools are partially taken from the corresponding
websites.
19Available at http://www.mpkrieger.net/oclsolve/.
20Available at http://www.sat4j.org/.
21Available at http://minisat.se.
22Available at http://www.cs.bham.ac.uk/~bxb/UML2Alloy.
23Available at http://alloy.mit.edu/alloy/.
24Available at http://alloy.mit.edu/kodkod.
25Available at https://github.com/SOM-Research/EMFtoCSP.
26Available at http://gres.uoc.edu/UMLtoCSP/.

94
3
A Symbolic Formulation for Models
background, the ECLiPSe Constraint Programming System27 is used. Like Alloy
and Kodkod, EMFtoCSP is still maintained.
In 2016, another approach which supports the 4-valued OCL logic has been
published: OCL2MSFOL28 [DC16]. It is an extension of OCL2FOLC29 [DC13] and
OCL2FOL30 [CED09]. OCL2MSFOL propose a mapping from OCL to many-sorted
ﬁrst-order logic, therefore they provide mapping rules for many OCL operations.
This approach works well for inconsistent models which have been used in the
presenting paper [DC16]. However, due to the usage of SMT sorts, it still has a
lot of restrictions. For example, the size operation or anything which is related to
the size of collections is not supported. Consequently, only two types of associations
are supported: The upper bounds must be either 1 or .
Isabelle/HOL-OCL31 is an interactive proof environment for the Object Con-
straint Language (OCL). It is implemented as a shallow embedding of OCL into
the Higher-Order Logic (HOL) instance of the interactive theorem prover Isabelle.
Since it relies on Isabelle, Isabelle/HOL-OCL is not a fully automatic but—as
already mentioned—interactive environment. However, the partial simpliﬁcations
within a proof provided by Isabelle itself can still be used to speed up the
veriﬁcation process. Nevertheless, a designer needs expert knowledge to work with
Isabelle/HOL-OCL.
To minimize the expert knowledge and the reasoning, Sledgehammer32 has been
developed. Using Sledgehammer, subgoals and/or lemmas are converted into a
clause form which different solvers are trying to solve in parallel. However, up to
now, nobody has tried to combine Isabelle/HOL-OCL and Sledgehammer for model
checking.
Besides the HOL-OCL/Isabelle approach, a formalization of UML/OCL models
with Prototype Veriﬁcation System (PVS)33 has been published [KyaC05]. Another
idea is the so-called KeY approach [BHS07]. Like HOL-OCL/Isabelle, the two
lastly mentioned approaches can be used to check very large models, but often
require, again, a strong formal background of the designer as most steps have to
be performed manually.
A systematic overview of the mentioned approaches and many more is presented
in [GC14]. The authors have grouped the different approaches and discussed the use
cases and applicability of over 70 papers.
27Available at http://eclipseclp.org.
28Available at http://software.imdea.org/~dania/tools/ocl2msfol.html.
29Available at http://www.actiongui.org/index.php/new-ocl2fol-menu.
30Available at http://www.actiongui.org/index.php/ocl2fol-project.
31Available at https://www.brucker.ch/projects/hol-ocl/.
32Available at http://isabelle.in.tum.de/website-Isabelle2009-1/sledgehammer.html.
33Available at http://pvs.csl.sri.com.

Chapter 4
Structural Aspects
The previous chapter described a veriﬁcation ﬂow for UML/OCL models with ﬁve
stages. A designer is only required to manually provide a model and the so-called
problem bounds in the ﬁrst two steps. All remaining steps can be performed in a
fully automatic fashion using the transformation rules for a symbolic formulation
or its SMT-LIB realizations, respectively, to answer different questions about the
properties of the individual model. However, so far in the context of structural (or
conceptual) modeling aspects, the symbolic formulation can only prove whether
there is a system state within the given problem bounds or not. These veriﬁcation
tasks have been called weak and/or strong consistency. In this context, the problem
of inconsistent models has already been mentioned. But what makes a model
inconsistent has not been explored so far.
Therefore, Sect. 4.1 (which is based on [PWD15a, PWD15c, PWD16a]) deﬁnes
reasons for inconsistencies in a model and, further, identiﬁes different types which
may occur. More precisely, the constraints added for associations and invariants can
cause one or more contradictions. Afterwards different approaches for the detection
of inconsistencies are discussed, before ﬁnally new approaches are derived by
considering the advantages as well as disadvantages of old approaches. Most of the
discussed and also the proposed approaches can be conducted in a fully automatic
fashion, i.e., they can pinpoint the designer to a reason and thereby possibly to
erroneous parts of the model (i.e., associations and invariants or combinations of
both). Some approaches are already capable of deriving one of likely many reasons.
In contrast to this, the proposed approaches determine all reasons. The section is
completed with an evaluation to show the applicability.
Obvious risk factors which can easily end up in inconsistent models are huge
models with lots of constraints. More constraints in a model make it harder for the
designer (or a team of designers) to keep an overview. However, during a design
process more invariants are usually added than actually needed. This is because
designers tend to repeat parts of invariants or to accidentally mention generalizations
of already existent invariants. The resulting constraints may (or may not) imply
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8_4
95

96
4
Structural Aspects
each other and thus, are dependent (or otherwise independent) from each other.
Motivated by this, Sect. 4.2 introduces an approach which exploits the symbolic
formulation to not only differentiate between dependent and independent invariants
but also determines the reasons in case the invariant is dependent (based on the
work of [PWD15b]). All checks can be applied in a fully automatic fashion. By
this, the designer gets additional knowledge about the dependencies in the system
to be designed and can decide if he wants to remove dependent invariants.
Finally, the last section of this chapter discusses the relation of these tasks and
methods to the determination of unsatisﬁability cores for SAT/SMT instances. This
is relevant, since unsatisﬁability core determination is actually rather similar to the
problem of contradiction and (in)dependencies analysis.
4.1
Debugging Inconsistent Models
Models of nowadays systems may be composed of numerous different components
with various relations, dependencies, or constraints and usually lead to non-
trivial descriptions where errors can easily arise. This may lead to an inconsistent
description, where certain UML and OCL constraints contradict each other. Then,
no valid system state can be derived from the model anymore—obviously a serious
design error. Detecting such ﬂaws in early stages of the development is an important
task since correcting an inconsistent UML/OCL model is easier than ﬁxing a
resulting error in the actual implementation or even later in the chip. It also saves
a lot of time and money which is more and more important for nowadays time-to-
market constraints of systems.
Motivated by this, researchers and engineers developed corresponding methods
and tools for validation and veriﬁcation of system descriptions given as a formal
model (cf. Sect. 3.4). These approaches are particularly helpful in order to determine
a valid system state of the model. Furthermore they are useful, even if the description
is inconsistent, since these approaches also help to detect the non-existence of a valid
system state. However, in such cases they do not provide any further details on the
reason for the contradiction(s). Hence, the designer is left alone to debug the model,
i.e., to identify the UML/OCL constraints that caused the contradiction(s).
In this section, an automatic method is proposed which aids the designer in this
process. The introduced methodology efﬁciently determines so-called reasons of the
contradiction, i.e., a subset of all UML/OCL constraints of a model which forms a
contradiction and, hence, explains the inconsistency. For this purpose, the symbolic
formulation from Chap. 3 is exploited such that UML/OCL constraints can be
disabled in order to derive a valid—valid for all but the disabled constraints—system
state from the model. By exhaustively analyzing all possible combinations that got
disabled in order to allow a valid system state, the desired reasons can automatically
be determined. Previously proposed approaches for debugging UML/OCL models
(discussed in detail in Sect. 4.1.2) only provide approximations of the reasons. In
contrast to this, the solution proposed in this work determines all minimal reasons
explaining the problem.

4.1
Debugging Inconsistent Models
97
A
v: Integer
w: Boolean
C
u: Integer
B
x: Integer
y: Integer
D
z: Boolean
r1: 2
r2: 1
as
cs
r3: 2
r4: 5
as
bs
r6: 3
r5: 5
cs
bs
r7: 3
r8: 0..7
cs
ds
i3: A.allInstances().forAll(a|a.v = 8)
i4: C.allInstances().forAll(c|c.u = 3)
i5: B.allInstances().forAll(b|b.x = 11 and b.x = 12)
i2: as->one(a|a.w = false)
i1: v <= 10 implies w
i6: cs->forAll(c|c.u < 10)
i7: cs->forAll(c|c.ds->size() = cs.u->sum() )
Fig. 4.1 An example of an inconsistent model
4.1.1
Problem Formulation
Before giving a precise deﬁnition of a reason for a contradiction, the idea shall be
illustrated at hand at an example.
Example 17 Consider the UML/OCL model as shown in Fig. 4.1 which is used as
running example in the remainder of this section. The model describes a system
composed of four classes including several attributes which are constrained by
several UML constraints (i.e., relations together with their multiplicities) as well as
OCL constraints (i.e., invariants). Additionally, it is assumed that exactly 2, 5, 3, and
7 objects shall be instantiated from the classes A, B, C, and D, respectively. However,
although maybe not obvious at a ﬁrst glance, this model is highly inconsistent. In
fact, the following contradictions prohibit a valid instantiation of this model1:
1. A trivial contradiction is inherent in the invariant i5. Here, the logical expression
by itself is not satisﬁable.
2. Somewhat harder to debug are contradictions which span over several invariants.
In the model, this is the case for the invariants i3, i1, and i2. The invariant i3
enforces all attributes v of each instance of class A to be set to the value 8.
Adding invariant i1, the attribute w always has to be true. However, invariant i2
requires this attribute to be false for exactly one connected instance of class A.
3. In a similar fashion, UML constraints may lead to a contradiction. This is the
case for the association between the classes A and C. Since 2 objects are derived
from Class A and 3 objects are derived from class C, the multiplicities of the
respective relations (represented by r1 and r2) are violated.
1Note that the model was only built to serve as a proper example including various types of
contradictions which may occur in practice.

98
4
Structural Aspects
4. Finally, contradictions may have their origins in the combination of both, UML
and OCL constraints. For example, this is the case for the combination of the
invariants i4 and i7 and the relation r7. Both, the invariants and the relation,
enforce restrictions on the number of links from instantiations of class D to
instantiations of class C which are in contradiction to each other.
Without any additional help, debugging an inconsistent UML/OCL description
is a cumbersome and time-consuming task. Hence, methods that automatically
approximate or even exactly determine reasons for a contradiction are desired. A
reason is thereby a subset of all UML/OCL constraints which forms a contradiction
and, hence, has to be considered by the designer for debugging. The deﬁnition for a
reason is given as follows.
Deﬁnition 4.1 Let m D .C; R/ be an inconsistent UML/OCL model. Then, a
reason R for the contradiction is a non-empty set of constraints R 
 R [ I where
R is the set of the multiplicities of all relations, i.e., for both ends of the relation
an element for the multiplicities is included in the set, and I is the set consisting of
all invariants of all classes of C such that the conjunction of all constraints c 2 R
forms a contradiction, i.e.,
^
c2R
c
is not satisﬁable.
Please note that in the last deﬁnition c has been used for constraints instead of a
single class of a model. For the sake of convenience, the precise details about the
objects and the system state in general have been omitted.
Example 18 As discussed in Example 17, the model shown in Fig. 4.1 is inconsis-
tent due to four reasons, namely:
1. R1 D f i5g,
2. R2 D f i1; i2; i3g,
3. R3 D fr1; r2g, and
4. R4 D f i4; i7; r7g.
How to efﬁciently and automatically determine all reasons for an inconsistent
UML/OCL model is considered in the remainder of this subsection.
4.1.2
Previously Proposed Solutions
Determining reasons for inconsistent UML/OCL models has been considered
before. For example, approaches presented in [TCJ08] and [WSD12] provide
respective solutions. Both approaches utilize a solving engine which is already
applied in the ﬁrst place to check whether a contradiction exists.

4.1
Debugging Inconsistent Models
99
Torlak et al. have proposed an approach [TCJ08] which relies on a technique
called unsatisﬁable core extraction [GKS08, ZhaC11]. As already mentioned, they
ﬁrst check whether a given model is consistent, i.e., free of a contradiction. For that
purpose, they transform the declarative UML/OCL description into a propositional
formula which is given to a solving engine (e.g., a SAT solver). In case of a
contradiction, the solver will prove that no satisfying solution and, by this, no valid
instantiation exists. Then, unsatisﬁable core extraction determines a subset of the
propositional formula (a so-called unsatisﬁable core) which still is contradictory.2
This subset is further optimized until a minimal core results. Since each expression
in the formula represents invariants or relations of the UML/OCL model, a minimal
reason for the contradiction can be determined from the resulting subset. However,
a main problem of this approach is that only one contradiction is determined in each
turn.
Example 19 Applied to the running example, the approach presented in [TCJ08]
may deliver the reason R1, i.e., the information that i5 is self-contradictory. Even
after ﬁxing this error the designer is still left alone with a contradictory UML/OCL
model. In fact, the designer has to explicitly invoke this approach four times until all
contradictions have been identiﬁed and ﬁxed. Considering that unsat core extraction
is a computationally expensive process (i.e., requires signiﬁcant run-times), this
provides potential for further improvement.
Another possible problem are constraints which belong to more than just one
reason. If the designer does not know that a speciﬁc constraint also belongs to other
than the calculated reason, it could be much harder for him to debug the model. It
could also happen that changing the speciﬁc constraint does only ﬁx the calculated
reason, but not the other reasons.
More details on methods of unsatisﬁability core extraction are given in Sect. 4.3.
In [WSD12], a complementary approach has been proposed. The approach dis-
tinguishes between UML and OCL constraints. In a ﬁrst step the UML constraints,
i.e., the relations, are transformed into a Linear Integer Arithmetic (LIA) problem
and, from the result, it can be concluded if it is possible to derive a system state in
which all relations are valid or not. After ﬁxing possible ﬂaws, the designer should
handle the remaining problems: contradictions caused by OCL constraints.
In a second step, the propositional formula is enriched by additional logic
allowing to disable certain OCL constraints. The number of constraints to be
disabled is thereby restricted by an integer k. At the beginning, k is ﬁxed to 1
(i.e., one invariant may be disabled). If this still leads to a contradiction (checked
by the solving engine), k is increased. This procedure is repeated until the solving
engine determines the ﬁrst solution. Then, all solutions for activated and deactivated
invariants for the current value k are determined. This eventually leads to so-called
contradiction candidates, i.e., a set of OCL constraints which, once disabled, would
2Many solving engines such as MATHSAT, CVC, and Z3 already provide unsat core determination
as “in-house” functionality.

100
4
Structural Aspects
lead to a contradiction-free model. However, while this may pin-point the designer
to possible problems in the model, this approach only provides limited explanations
of the contradiction.
Example 20 Applying the approach from [WSD12], in the ﬁrst step it will be
detected that the relations are contradictory. In the second step, i1; i2; i3; i4; i5, and
i7 will be detected as contradiction candidates. Altogether, the designer gets a lot
of useful information in order to debug the contradictions, but he is still left alone
ﬁguring out their relations to each other.
Besides that, the approach from [WSD12] has a much bigger disadvantage than
just missing information about the relations between the contradiction candidates.
Example 21 Let’s assume a given model m is inconsistent due to the two reasons:
R1 D f i1; i2g and R2 D f i2; i3g, where ij are some OCL constraints (invariants)
of the model. Now, the approach determines a ﬁrst solution already for k D 1, i.e.,
exactly one constraint is disabled. More precisely, the deactivation of i2 leads to
the solution because both reasons have been eliminated. A deactivation of i1 (i3)
would only have been eliminating the reason R1 (R2), but not the other one. The
contradiction candidates are now the intersection instead of the union.
Overall, while the approaches proposed before already produce proper solutions
which aid the designer in debugging contradictory UML/OCL models, they still
offer room for improvement. Either only a single reason is determined or a subset
of contradictory UML/OCL descriptions is provided at once. In this section, an
alternative is proposed, which determines all minimal reasons and additionally
groups them according to their contradictions.
4.1.3
Proposed Approach
In this section, the proposed approach for an advanced analysis of contradictions in
UML/OCL models is described. The general idea is thereby based on the previously
proposed solutions described above, i.e., the idea relies on a solving engine which
already has been applied to identify the existence of a contradiction and enriches the
corresponding propositional formula.
In the following, let I be the set consisting of all OCL invariants of a UML
model m D .C; R/. Then, the symbolic representation to formulate the consistency
veriﬁcation task (cf. Chap. 3) can be summarized in the following simpliﬁed fashion:
fcon D ˚m; ^
^
r2R
r ^
^
i2I
i; where
(4.1)
•
˚m; are constraints to ensure that, e.g., an obtained assignment to the variables
indeed respects the given problem bounds, the data types for collections, etc.,

4.1
Debugging Inconsistent Models
101
•
r represents the constraints for one end of a UML relation r 2 R for all
corresponding objects in the system state , and
•
i represents the constraints for the given OCL invariant i
2
I for all
corresponding objects in the system state .
As already discussed, different approaches can be utilized to execute this
veriﬁcation task (see Sect. 3.4 for details). If the respectively applied solving engine
cannot determine a valid assignment for this instance, it has been proven that the
model is inconsistent and the designer must have a look at all constraints in order to
ﬁx the model.
In order to provide the designer with the desired reasons for the contradiction
or inconsistency, respectively, the idea presented in [WSD12] is exploited, i.e.,
Eq. (4.1) is enriched such that UML relations or OCL invariants may be disabled.
More precisely, the formula from Eq. (4.1) is extended to
f 0
con D ˚m; ^
^
r2R
.sr _ r/ ^
^
i2I
.si _ i/ ;
(4.2)
where sc is a new free variable corresponding to a constraint c. However, in contrast
to [WSD12], the total number k of constraints to be disabled is not restricted.
Further, everything is done in just one step instead of two. Contradictions of UML
and OCL constraints are analyzed simultaneously. Besides this, Deﬁnition 4.1 needs
to be extended as minimal reasons are the goal. The extension is straightforward and
comparable to the deﬁnition of a Minimal Unsatisﬁable Subformula (MUS) as, e.g.,
given in [MJB13, p. 3, Def. 4].
Deﬁnition 4.2 A reason R of an inconsistent model—as deﬁned in Deﬁni-
tion 4.1—is called minimal if no proper subset R0 ¨ R exists such that
^
c2R0
c
is unsatisﬁable.
Now, passing the formula from Eq. (4.2) to a solving engine allows to investigate
how enabling or disabling UML/OCL constraints keeps or does not keep the model
contradiction-free. For example, an assignment determined by the solving engine
such as
sr1 D 1, sr2 D 1, sr3 D 1, sr4 D 1, sr5 D 1, sr6 D 1, sr7 D 1, sr8 D 0, si1 D 1, si2 D 1,
si3 D 1, si4 D 1, si5 D 1, si6 D 1, and si7 D 1.
allows the conclusion that disabling all UML/OCL constraints except r8 would
lead to a valid instantiation of the model. Obviously, this alone does not signiﬁ-
cantly help in identifying the reasons for a contradiction. But observing all such
possibilities indeed provides a proper basis for a comprehensive analysis. In a
similar fashion, contradictions in inputs for constraint-based random simulation are
analyzed [GroC08].

102
4
Structural Aspects
Table 4.1 Possible solutions derived from the running example
r1
r2
r3
r4
r5
r6
i6
r8
i1
i2
i3
i5
i4
i7
r7
-
1
-
-
-
-
-
-
-
1
-
1
-
1
-
-
1
-
-
-
-
-
-
-
0
1
1
-
1
-
-
1
-
-
-
-
-
-
-
-
1
1
1
0
-
-
1
-
-
-
-
-
-
1
-
0
1
1
0
-
-
1
-
-
-
-
-
-
1
0
0
1
-
1
-
1
0
-
-
-
-
-
-
-
1
-
1
-
1
-
-
1
-
-
-
-
-
-
-
1
-
1
0
0
1
-
1
-
-
-
-
-
-
0
1
0
1
1
0
-
-
1
-
-
-
-
-
-
-
0
1
1
0
0
1
-
1
-
-
-
-
-
-
1
0
0
1
0
0
1
1
0
-
-
-
-
-
-
-
1
-
1
1
0
-
1
0
-
-
-
-
-
-
-
1
-
1
0
0
1
1
0
-
-
-
-
-
-
-
0
1
1
-
1
-
1
0
-
-
-
-
-
-
-
0
1
1
-
0
1
1
0
-
-
-
-
-
-
-
0
1
1
1
0
0
1
0
-
-
-
-
-
-
1
0
0
1
-
1
-
1
0
-
-
-
-
-
-
1
0
0
1
-
0
1
1
0
-
-
-
-
-
-
1
0
0
1
1
0
0
At least one 1 –
At least one 1
1
At least one 1
To illustrate this, Table 4.1 lists all possible assignments to the respective
sc-variables that have been obtained by applying the formula from Eq. (4.2) to the
running example. A 1 denotes that the respective constraint has been disabled, while
a 0 denotes that it has been enabled. A - represents a don’t care, i.e., the case that,
for the considered assignment, the value of the corresponding select variable (stating
whether the respective constraint is enabled or disabled) does not matter. This allows
to represent all solutions in a compact fashion. The row at the bottom summarizes
some of the properties which are exploited for the analysis and discussed next.
In fact, some very substantial conclusions can be drawn from Table 4.1. For
example, it can be observed that invariant i5 is disabled in all solutions. Hence,
this invariant must be self-contradictory; otherwise at least one solution where
all constraints except i5 are disabled must exist—a proof for this can be found
in [GroC08, p. 3, Property 1]. This is summarized by a 1 in the bottom row
of the column i5. Similarly, it can be concluded that the relations r3; r4; r5; r6; r8
and the invariant i6 are never part of a minimal reason; otherwise, the value of
the corresponding sc-variable could not arbitrarily be switched [GroC08, p. 3,
Property 2]. This is summarized by a - in the bottom row of the respective columns.
Another conclusion may be drawn from the ﬁrst two columns of Table 4.1. Here,
it is evident that at least one of the two constraints is disabled in all solutions. This
constitutes an indication that r1 and r2 are part of a reason; otherwise, at least one

4.1
Debugging Inconsistent Models
103
solution must exist in which both are enabled. In a similar fashion, this holds for i1,
i2, and i3 as well as i4; i7, and r7. All these cases are summarized by at least one 1
in the bottom row of the respective columns.
All these observations represent single snapshots and properties which can be
exploited to determine the reasons of the contradiction. This eventually leads to
the main idea of the proposed approach for contradiction analysis: Using the
formula from Eq. (4.2) and an efﬁcient solving engine, all possible combinations of
constraints are iteratively checked starting with the smallest ones, i.e., concerning
the cardinality. For each combination, the sc-variables are pre-assigned in a fashion
that the respective combinations are enabled. If no valid model can be derived
assuming this assignment, then a reason for a contradiction has been determined. By
excluding all supersets from already determined reasons, minimality is guaranteed.
4.1.4
Implementation and Evaluation
This section describes the implementation of the proposed contradiction analysis
based on the ideas discussed above. A big drawback of a straightforward imple-
mentation is thereby that the analysis relies on iteratively checking all possible
combinations of constraints and, hence, is rather time-consuming. Accordingly, an
optimized approach is additionally proposed which addresses this problem. Both
implementations are evaluated by means of the running example. Furthermore, the
optimized approach is also evaluated with other examples. At the end, a discussion
of advantages as well as disadvantages of the results of the two-step approach
of [WSD12] with the presented optimized approach is done based on the running
example.
4.1.4.1
Straightforward Approach
Implementation
The implementation of the proposed ideas is explained with the help of the pseudo
code depicted in Algorithm 1 f 0
con. The algorithm starts with a proper representation
of the formula from Eq. (4.2) and the two sets MR and S which are both initialized
to the empty set. MR stores all minimal reasons that are found, while S is used to
save all sc-variables that are passed to the detailed analysis later.
Then, the number of combinations to be considered is simpliﬁed based on the
observations discussed in Sect. 4.1.3. In other words, for each constraint is checked
if it is self-contradictory (Line 8) or not. If yes, the respective constraint is added
to the set of reasons R (Line 10). Each of these checks is conducted by passing the
extended version of the formula from Eq. (4.2) to an off-the-shelf SMT solver, i.e.,

104
4
Structural Aspects
Algorithm 1 Straightforward implementation
ContradictionAnalysis
Input: f 0
con
1: // initialization
2: // set of all minimal contradiction reasons
3: MR  ;
4: // sc variables for detailed analysis
5: S  ;
6: // ﬁrst step, simple analysis
7: for all c 2 R [ I do
8:
if . f 0
con ^ sc D 0/  0 then
9:
// c is self-contradictory
10:
MR  MR [ ffcgg
11:
else
12:
// c is selected for detailed analysis
13:
S  S [ fscg
14: // calculating all possible assignments
15: A  allSAT. f 0
con/
16: // detailed analysis
17: for all X 2 P.S/ n f;g do
18:
// from the smallest to the largest
19:
if 9X0  XW X0 2 MR then
20:
// ensure minimality
21:
continue
22:
if 6 9 a 2 AW 8 sc 2 XW a.sc/ D 0 then
23:
// reason found
24:
MR  MR [ fXg
25: return MR;
to check if sc is 1 for all solutions, the conjunction f 0
con^.sc D 0/ is carried out. If no
valid solution can be determined from that, it can be concluded that sc is always 1.
Thus, c becomes a reason.
If such a check fails (Line 11), then the respective constraint c can be a
part of a contradiction caused by the conjunction of c with one or more other
constraints. Thus, c is passed to the detailed analysis by inserting the respective sc
into S (Line 13).
The next step is to calculate all possible assignments for the select variables
which makes the model consistent. For this purpose the extended formula from
Eq. (4.2) is passed to the solving engine and allSAT (Line 15) will return all the
desired assignments A. This can be done naively by just blocking the last found
solution and ask the solving engine for another solution until the solver engine
recognizes that there are no more solutions.
Finally, the detailed analysis for all elements in S, representing the remaining
constraints, is performed (Line 17–24). First, the power set P.S/ of S is created
resulting in all subsets (i.e., combinations) of constraints considered for detailed
analysis. Note that we exclude the empty set as well as all sets which only contain
one element from the power set (this is already covered by the simpliﬁcations
before). Furthermore, the elements of the power set are ordered according to their

4.1
Debugging Inconsistent Models
105
cardinality. Then, for each subset X (i.e., for each combination), the conjunction of
the respective constraints is tested for a contradiction. If X is a contradiction, then it
is not possible to get an assignment a 2 A, where all corresponding select variables
are assigned 0. Thus the non-existence of such an assignment implies that X is a
contradiction (Line 22). To ensure minimality, each contradiction test of a subset X
is only carried out if no subset of X, i.e., X0  X, has already been detected as a
reason for a contradiction X0 2 R (Line 19–21).
In summary, the presented contradiction analysis procedure computes all mini-
mal reasons R that explain the contradiction of the considered UML/OCL model.
Evaluation
In order to evaluate the algorithm shown in Algorithm 1, the proposed approach
has been realized as an Eclipse plugin using both, Java and Xtend, on top of the
proposed symbolic formulation as presented in Chap. 3. The used SMT solver is
Z3. The experiment has been carried out on an Intel i5 with 2.6 GHz cores and
16 GB memory using a 3.11 kernel Linux.
Using the resulting tool, all minimal reasons explaining the contradiction in the
running example as discussed in Example 17 have successfully been determined in
an automated fashion. By this, designers are signiﬁcantly aided in the debugging of
contradictory UML/OCL models. In fact, the resulting reasons are more precise and
complete compared to the results of previously proposed solutions as discussed in
Sect. 4.1.2. On the other hand, following this straightforward scheme is computa-
tionally expensive: For the running example, a total of 9,408 possible assignments
have been analyzed requiring a total run-time of approximately eight CPU hours. In
order to address this, an optimized implementation is proposed next.
4.1.4.2
Optimized Approach
Implementation
The huge number of assignments to be analyzed represents a crucial obstacle of the
proposed approach. This is caused by the simple determination of all assignments in
Line 15 of the algorithm from Algorithm 1: After the determination of a satisfying
assignment, a so-called blocking constraint is added which prevents the solving
engine from determining the same solution again. By this, all possible assignments
are solely obtained. However, for the purposes considered here, explicitly determin-
ing all assignments is not necessarily required. In fact, a reduced set of assignments
is sufﬁcient.
Deﬁnition 4.3 Let a 2 A be one assignment which was obtained by the solving
engine and S the set of all sc-variables. Furthermore, let Sa be a subset of S (Sa 
 S)
composed of those sc-variables which are assigned 1 in a. Then a0 2 A is called

106
4
Structural Aspects
an overset3 of a, iff Sa 
 Sa0. Blocking the partial assignment including only the
variables assigned 1 rather than the complete assignment a prevents the solving
engine not only from obtaining the same assignment again but also all of its oversets.
This results in a reduced set of assignments, denoted by A0.
Considering the reduced set of assignments signiﬁcantly shrinks the total number
of assignments to be analyzed. At the same time, the reduced set of assignments is
still sufﬁcient to determine all minimal reasons for the contradiction.
Lemma 1 Checking not all possible assignments a 2 A but only the assign-
ments a0 2 A0 of the reduced set still allows the determination of all minimal reasons
for a contradiction using the algorithm from Algorithm 1.
Proof As it is obvious that A0 is not empty, it sufﬁces to prove that no smaller
reasons can wrongly be discovered by the algorithm. This will be proven by
contradiction. Let Rj be a minimal reason to be detected by the algorithm using
the complete set of assignments A. Now assume that a smaller reason Rj0 ¨ Rj
would (erroneously) be detected by relying on the reduced set A0.
Then, there would be an assignment a 2 A in the complete set such that, for
all constraints in the smaller reason Rj0, the corresponding sc-variables are all
assigned 0, i.e., 8 ci 2 Rj0W a.sci/ D 0 (otherwise, this reason would have been
detected using the complete set A). Then, we can distinguish two cases:
1. This assignment is in A0 (i.e., a 2 A0): Then, the algorithm would have not
detected Rj0 as reason since it violates the corresponding condition in Line 22.
2. This assignment is not in A0 (i.e., a 62 A0): Then, a must have been blocked before
by another assignment a0 2 A0 with Sa0 ¨ Sa. But such an assignment can only
have a smaller number of sc-variables set to 1. Consequently, all sc-variables in a
assigned 0 will also be assigned 0 in a0. Again, the algorithm would have not
detected Rj0 as reason since it violates the corresponding condition in Line 22.
ut
Remark 7 Consider the minimal reason Rj D fc1; c2; : : : ; ckg. In an optimal case,
the algorithm adds only k blocking constraints. In the worst case, up to 2k blocking
constraints are needed.
The actual number of blocking constraints added for Rj depends only on the
used solving engine and its internal learning techniques which depend on heuristic
methods.
In order to improve such a heuristic behavior, the number of disabled constraints
is restricted as explained in [WSD12]. At ﬁrst all assignments with only one disabled
constraint are obtained by the solver engine, if they exist. Then the number of
disabled constraints is increased by one and the solver engine is called again. Note
that, in contrast to [WSD12], we will not stop after the ﬁrst bunch of assignments.
Instead, we call the solving engine for every possible number of disabled constraints
3 The term overset is used to avoid confusions with the term superset.

4.1
Debugging Inconsistent Models
107
and, by this, we obtain a minimal list of assignments. Now, by blocking only
oversets of determined assignments and a structured search for every possible
number of disabled constraints, we can still ensure that the collected assignments
are a reduced set of assignments as described in Deﬁnition 4.3.
According to these results, the algorithm shown in Algorithm 1 can easily be
optimized by modifying Line 15. Here, instead of an allSAT scheme which
determines a complete set of assignments, simply a reduced set of assignments
according to Deﬁnition 4.3 is obtained. This is sufﬁcient to perform the following
detailed analysis but, at the same time, signiﬁcantly reduces the number of analysis
steps.
Evaluation
In order to evaluate the optimized approach, the reﬁned algorithm has been realized
as an Eclipse plugin as well. Here, the determination of assignments as described
above has been adjusted, while the rest of the algorithm remains identical.
Also the improved tool enabled the automatic determination of all minimal
reasons explaining the contradiction in the running example as discussed in
Example 17. But this time, only 18 rather than 9,408 assignments were sufﬁcient
for this purpose. As the solving engine had to be invoked respectively fewer times,
this led to a signiﬁcant reduction in the required run-time: Instead of more than 8
hours, the reasons have been determined in just a few seconds. By this, the designer
is clearly aided during the debugging of his model.
In order to further evaluate the optimized solution, the Eclipse plugin has also
been tested with well-known models from the USE framework [GBR07]. For this
purpose the CivStat model has been edited nine times such that all nine models
became inconsistent and different. Furthermore, the (inconsistent) CarRental2
model has been considered which is a variation of the (consistent) CarRental (both
are provided by the USE package as well).
Table 4.2 summarizes the obtained results. The ﬁrst columns provide the name
of the respective models followed by their number of classes (jCj), their number of
relations (jRj), their number of invariants (jIj), their maximal number of considered
object instantiations per class (jOj), the number of detected reasons (#R), the sizes
of the detected reasons (Sizes), the number of solver calls (#solve), and the overall
run-time. Note that the number of solver calls includes all calls with an UNSAT as
result and thus, is not equal to the number of assignments which have to be analyzed
in order to get all minimal reasons.
The numbers clearly show that the optimization of the proposed solution can
not only determine all minimal reason but also does this in feasible run-time for
the considered models. The detection of one and more reasons for all considered
models does never require more than some seconds—except for the last one.
The last four benchmarks are a special case of the running example where the
number of object instances has been set between one and the maximum given in the
jOj column (all other benchmarks had a ﬁxed number of objects). The results show

108
4
Structural Aspects
Table 4.2 Experimental results
Model
jCj
jRj
jIj
jOj
#R
Sizes
#solve
Run-time
CivStat
1
2
6
5
2
4
11
< 1 s
CivStat
1
2
6
5
2
4, 4
11
< 1 s
CivStat
1
2
7
5
2
4, 4, 4
13
3.3 s
CivStat
1
2
6
5
2
4, 4
11
< 1 s
CivStat
1
2
6
5
2
4
11
< 1 s
CivStat
1
2
7
5
2
4, 4, 4
13
2.7 s
CivStat
1
2
7
5
2
2, 3
11
2.2 s
CivStat
1
2
7
5
2
2, 3
11
2.2 s
CivStat
1
2
7
5
2
3, 3
11
< 1 s
CarRental2
9
14
7
5
1
3, 3
11
2.5 s
RunningExample 4
8
7
7
4
1, 2, 3, 3 34
5.3 s
FaultyRelations
4
6
1
5
1
3
11
< 1 s
FaultyRelations
4
6
1
6
1
5
13
< 1 s
FaultyRelations
4
6
1
7
1
5
13
5.2 s
FaultyRelations
4
6
1
8
1
5
13
436 s
Legend:
jCj: Number of classes
jRj: Number of relations
jIj: Number of invariants
jOj: Maximal number of considered object instantiations per class
#R: Number of reasons
Sizes: a list with the sizes of each reason
#solve: the number of sat solver calls
that, with an increasing maximal number of objects, the run-time increases and,
in the last case, the increase is rather signiﬁcant. This is caused by a fast growing
search space. Another very interesting fact is that the size of the reason differs. With
a maximum of ﬁve objects only, the three relation ends are causing the contradiction,
while with six, seven or eight, the only reason contains ﬁve relation ends. While this
may look confusing at the ﬁrst glance, it is easy to explain: Our approach determines
all reasons for a contradiction with respect to given problem bounds. In this case,
varying the maximum number of objects changes the problem bounds and, thus,
also changes the number of reasons.
4.1.5
Comparison with Other Approaches, Also from Different
Fields
As already discussed in Sect. 4.1.2, our approaches determine all minimal reasons,
while, to the best of our knowledge, previously proposed solutions do only calculate
one reason or/and contradiction candidates when staying inside the (UML/OCL)
modeling domain. However, very similar problems occur for the developers of SAT
and SMT solvers when they want to support Minimal Unsatisﬁable Subformula
(MUS) and especially Union of Minimal Unsatisﬁable Sets (UMUS). A MUS is
equivalent to one minimal contradiction reason and UMUS is the counterpart to all

4.1
Debugging Inconsistent Models
109
minimal reasons of a contradiction. In [NBE12], the authors use UMUS to derive
a so-called High-level Union of Minimal Unsatisﬁable Sets (HUMUS). HUMUS is
used to manage/ﬁx inconsistencies in product line engineering.
Compared to the two-step approach of [WSD12], the proposed approaches
here are considering UML and OCL constraints simultaneously. However, there
are also use cases in which the ﬁrst step of [WSD12] is a very useful and
helpful addition. Instead of R3 D fr1; r2g, the ﬁrst step would have calculated
R D fr1; r2; r3; r4; r5; r6g and, indeed, this is a contradiction which is independent
from the problem bounds. Due to a ﬁxed number of objects, our approach
determined R3 only. But by changing the input parameters of our approach, we are
also able to detect this circle of relations forming a contradiction. This means the
number of object instances must not be ﬁxed to precise values, but to an interval.
Unfortunately, SMT solvers are normally not optimized for such problems and it
takes much more time to determine a reason for this contradiction. However, they
can be easily encoded as LIA problems and solved in just some seconds, while an
SMT solver needs some hundred seconds.
Especially, applying the ﬁrst step of [WSD12] to the FaultyRelations models
would not need a problem bound like the maximum number of objects and, thus,
would calculate the whole relation contradiction caused by six relation ends.
Hence, depending on the speciﬁc problem bounds, i.e., ﬁxed or arbitrary object
numbers, it still can be wise to also use the ﬁrst step presented in [WSD12].
However, only with the presented approach all minimal reasons can be found. Fur-
thermore, the approach in [WSD12] is not able to detect contradictions containing
both, UML and OCL constraints.
An alternative to the ﬁrst step has recently been published as a conference
paper [CGC15]. In their work, the authors described a way to automatically derive
problem bounds or to tighten given problem bounds using a CSP solver. For this
purpose the authors analyze not only the relation but also the invariants. However, it
would be possible to modify the approach such that it can also be used to show just
the pre-deﬁned problem bounds are causing the inconsistency. Then the designer
can add validated bounds to ﬁnd the reasons.
4.1.6
Example of Use
Using the optimized version of the approach, we want to have a closer look at the
CarRental2 example shown in Fig. 4.2 and listed in Table 4.2—the original model
was taken from USE [GBR07] and slightly changed. It is a software model, which
at a ﬁrst glance looks like a consistent model, but in fact it is inconsistent due to
different reasons.
The only change compared to the model originally proposed in USE is the
helping class TRMaintenance, which was originally a ternary association, namely
Maintenance. The transformation was done as explained in [GR02b], however,
additionally added invariants from the transformation are omitted in the ﬁgure.

110
4
Structural Aspects
≪abstract≫Person
ﬁrstname: String
lastname: String
age: Integer
isMarried: Boolean
Customer
address: String
Employee
salary: Integer
Rental
fromDate: String
untilDate: String
Branch
location: String
CarGroup
kind: String
Check
description: String
ServiceDepot
location: String
TRMaintenance
Car
id: String
1
*
Booking
*
1
Provider
r1:1
0..1
manager
managedBranch
Management
*
r2:1
employee
employer
Employment
*
1
Reservation
0..1
0..1
Assignment
0..1
0..1
Classiﬁcation
*
*
Classiﬁcation
higher
0..1
0..1 lower
Quality
1
*
Fleet
1
*
1
0..1
1
*
inv Person1:
self.age > 0
inv Person2:
0 < self.age 0
and self.age < 150
inv Employee1:
self.employer->isEmpty()
xor self.managedBranch->isEmpty()
inv Branch1:
self.employee
->includes(self.manager)
inv Branch2:
self.employee->forAll( e |
(e <> self.manager)
implies (self.manager.salary
> e.salary)
)
inv CarGroup1:
self.higher <> self
and self.lower <> self
inv Car1:
self.rental->isEmpty()
or self.serviceDepot->isEmpty()
inv Car2:
self.serviceDepot->size() <= 1
inv Rental1:
self.branch.carGroup
->includes(self.carGroup)
Fig. 4.2 The CarRental2 model from USE
The
proposed
approach
has
determined
the
following
two
reasons:
fr1; r2; Employee1g and fr2; Employee1; Branch1g. With this information,
the designer is pin-pointed to non-obvious ﬂaws and can now start to ﬁx them.
Again, having all reasons is a big advantage for the debugging process, because
only the ﬁrst reasons would not be very helpful as the invariant Branch1 is a
contradictory constraint together with two parts of the ﬁrst reasons.
4.2
Analyzing Invariant Independence
UML/OCL models provide a good abstraction of hardware and/or software systems.
An advantage is the fact that they hide precise implementation details while being
expressive enough to specify such complex systems—the usage of OCL makes this
possible by deﬁning invariants which restrict valid system states or describe further
properties as well as relations between the speciﬁed components. However, at the

4.2
Analyzing Invariant Independence
111
same time such abstractions are only helpful if they are as small as possible such
that the designer can more easily stay on top of things.
But in practice the resulting models are often designed by large teams and
are composed of various components including classes, relations, and constraints,
which are given by invariants. This usually leads to non-trivial descriptions where
redundancies, i.e., model descriptions which can directly be implied from already
existing constraints, can easily arise. Those redundancies are often not obvious to
a (single) designer but signiﬁcantly hinder the further design process as they keep
the amount of description means to be considered unnecessarily large. In particular,
invariants are affected by this.
As a consequence, researchers and engineers started to investigate how corre-
sponding dependent invariants can efﬁciently be identiﬁed or how the independence
of invariants can efﬁciently be conﬁrmed. Since performing those checks is a
cumbersome task, these efforts eventually lead to the consideration of method-
ologies for the analysis for invariant independence. First accomplishments in this
regard have already been achieved: Corresponding solutions have been proposed
and evaluated in [GKH09, GHK10] based on the USE and the ideas in [BW09]
based on HOL-OCL can be also reused for this purpose. However, these approaches
have severe limitations with respect to scalability, automation, and quality of the
determined results.
In this section, the goal is to leverage the analysis for invariant indepen-
dence in UML/OCL models by addressing the drawbacks of previously proposed
approaches. For this purpose, a fully automatic approach is proposed which
efﬁciently determines either the independence of an invariant or determines the
reasons for its dependency. To tackle the underlying complexity, the symbolic
formulation (cf. Chap. 3) is again exploited and Z3 [MB08] is used as the solving
engine. By exhaustively analyzing all possible reasons in a clever fashion, the
quality of the obtained results is signiﬁcantly improved. In fact, the proposed
approach eventually delivers all minimal reasons for all dependencies and, by this,
signiﬁcantly supports the designer in removing the corresponding redundancies.
Similarities to unsatisﬁability core extraction as well as enumerating unsatisﬁability
cores are discussed later in Sect. 4.3.
The advantages of the proposed solution compared to previous work are con-
ﬁrmed in an experimental evaluation. It is shown that independence analysis is
performed signiﬁcantly faster and with better results. While previously proposed
approaches often determine no explicit reasons for a dependency, the presented
solution guarantees them in a minimal fashion. As a result, analysis for invariant
independence is leveraged with respect to automation, scalability, and quality.
4.2.1
Independence in Formal Models
During the design of complex systems, the clear and precise deﬁnition of constraints
and requirements is crucial. Description means as recently reviewed, in particular

112
4
Structural Aspects
invariants, are particularly suited for this purpose. In order to preserve the design
understanding, engineers aim to keep the respective speciﬁcations indeed complete
and comprehensive but, at the same time, as compact as possible. But with increas-
ing complexity of the considered design as well as a rising number of involved
engineers, often speciﬁcations result which are more complex than necessary.
In fact, often invariants are introduced which are supposed to add new constraints
and/or requirements but actually are already covered by previously added invariants.
This redundancy, which often is not obvious to designers, signiﬁcantly hinders the
further design process as it keeps the amount of invariants to be considered in
the following design steps unnecessarily large. Motivated by that, the detection of
dependent invariants (or the conﬁrmation that all invariants are independent) has
become an important task in early steps of today’s design ﬂows.
Deﬁnition 4.4 (Independence) Let m D .C; R/ be a consistent model, I the set of
all invariants of all classes, and ˙ the set of all system states derived from m (i.e.,
including invalid ones. Then an invariant ik 2 I is called independent iff
9  2 ˙ W
^
i2Inf ikg
.i/ ^ :.ik/:
(4.3)
Vice versa, an invariant ik 2 I is called dependent iff Eq. (4.3) does not hold.
In other words, Deﬁnition 4.4 states that an invariant is independent iff it further
restricts the set of valid system states (V  ˙) compared to I n f ikg, i.e., that at
least one system state which was valid under invariants I nf ikg is not valid any more
under invariant ik.
Example 22 Consider the model given in Fig. 4.3a composed of a single class
with two integer attributes a and b.4 The set of valid system states is restricted
by invariants i1, i2, and i3. However, invariant i3 does not further restrict the set
of valid system states compared to i1 and i2, since all system states valid under
i1 and i2 are trivially valid under i3 as well. Hence, i3 can be discarded. The
remaining two invariants are independent as each of them further restricts the set of
C
a: Integer
b: Integer
inv i1: 3 <= a and a <= 4
inv i2: 7 <= b and b <= 8
inv i3: 6 <= b and b <= 9
(a)
C1:C s
s
s
s
s
s
a = 5
b = 7
(i1) = false
(i2) = true
(i3) = true
(b)
C1:C
a = 3
b = 6
(i1) = true
(i2) = false
(i3) = true
(c)
Fig. 4.3 (In)Dependencies in formal models
4The example is borrowed from [GHK10, Fig. 1].

4.2
Analyzing Invariant Independence
113
valid system states. As an example, Fig. 4.3b shows a system state valid under i2,
but not i1, while Fig. 4.3c shows a system state valid under i1, but not i2.
Remark 8 In general, it is also possible that an invariant can never be not satisﬁed,
e.g., if the invariant is just a restriction on the relations between classes while the
relation itself already has the same or a harder restriction. This case can easily
be observed by sanity checks and will not be considered in this section, only
dependencies between invariants will be analyzed. Equally, it is assumed that the
model itself is not inconsistent (or is consistent referring to words of Deﬁnition 4.4)
as discussed in the last section.
Detecting dependent invariants (or showing the independence of invariants) may
signiﬁcantly simplify the design process. Invariants proven to be dependent can be
discarded from the model or, at least, do not have to be considered intensely. On
the contrary, if all invariants have been proven independent, designers know that
each and every constraint indeed restricts the desired design behavior further and
shall be considered accordingly. However, analyzing whether a given model is only
composed of independent invariants (and if not, determining which invariants are
dependent) is a non-trivial task. Consequently, (automatic) methods are applied for
this purpose.
4.2.2
Analysis for Invariant Independence
A straightforward and simple approach for the analysis of invariant independence
is provided by Algorithm 2. The algorithm expects a model m together with
the corresponding set of invariants I to be investigated. All dependent invariants
determined during the analysis are stored in a set D which is returned by the
algorithm.
First, it is assumed that the model does not include dependent invariants, i.e.,
D is initialized with an empty set (Line 1). Then, all invariants ik in I are considered
separately (Lines 2–7). For each ik is checked whether ik is independent or not. For
this purpose, Deﬁnition 4.4 is applied, i.e., it is checked whether there is a system
Algorithm 2 Analysis for invariant independence
Input: A model m D .C; R/
Input: A set I of invariants
1: D  ; // set of detected dependencies
2: for all ik 2 I do
3:
if 9  2 ˙ W V
i2Inf ikg .i/ ^ .:.ik// then
4:
// ik is independent
5:
else
6:
// i is dependent
7:
D  D [ f ikg
8: return D;

114
4
Structural Aspects
state which is valid under invariants I n f ikg, but violates ik (Line 3). The actual
checks can be conducted using the symbolic representation or by other approaches
for the veriﬁcation and validation as discussed, e.g., in Sect. 3.4. These methods
generate valid system states for a given model including a set of invariants and
can easily be utilized for the purpose considered here. If such a system state was
determined, it has been proven that ik is independent (Line 4). In contrast, if no such
system state was obtained, the invariant ik is considered as dependent and, hence,
added to the set D (Lines 5–7).
Example 23 Consider again the model shown in Fig. 4.3a. As discussed in Exam-
ple 22, corresponding system states showing the independence can be found for i1
and i2 (see Figs. 4.3b and c, respectively). In contrast, no system state satisfying i1
and i2 as well as violating i3 can be found. Hence, i3 is considered as dependent.
Approaches for the analysis of invariant independence as sketched by Algo-
rithm 2 have already been considered in previous work [GKH09, GHK10, BW09].
However, these approaches have severe limitations with respect to scalability,
automation, and quality of the determined results.
The ideas presented in [GKH09, GHK10] rely on the enumerative ASSL approach
from the USE framework for system state generation, i.e., when performing the
step in Line 3 of Algorithm 2, all possible states are considered one after another.
Designers may improve this enumeration by providing clever ASSL programs
(which allows to deﬁne in which fashion the traversal through the search space is
performed). Besides the fact that this requires a signiﬁcant amount of additional
manual work, the entire search space has to be enumerated in the worst case
anyway. Since newer versions of USE offer the USE ModelValidator [KG12], the
enumeration of all system states is avoided by using a SAT solver after some model
transformations.
In [BW09], the corresponding problem including the entire description of the
model to be analyzed is transformed into formal semantics for Isabelle/HOL. Then,
corresponding theorem provers are applied to determine the respective system states
from which either dependence or independence of an invariant can be concluded.
While this approach is very powerful with respect to generic conclusions (results
might be obtained which are universal and, e.g., do not rely on bounds for
object instantiation), it requires advanced expert knowledge and heavily relies on
manual interaction. More precisely, in the current version of HOL-OCL it is nearly
impossible to decide if the three invariants of the model depicted in Fig. 4.3a are
dependent or independent. This is caused by lack of a proper support for integers.
Besides that, strictly following Algorithm 2 also leads to rather poor results as
illustrated by the following example.
Example 24 Consider the model given in Fig. 4.4. Using Algorithm 2, it is observed
that all invariants are dependent. Consequently, D D fi1; i2; i3; i4g will be
returned by the algorithm. While this result indeed is correct (in fact, each invariant
could be covered by one or more of the other invariants), precise reasons are not

4.2
Analyzing Invariant Independence
115
Fig. 4.4 A model containing
dependencies
C
a: Boolean
b: Boolean
c: Boolean
inv i1: a and b and c
inv i2: a and (a implies b)
inv i3: b and (b implies c)
inv i4: c and (c implies a)
provided. Since simply discarding all invariants obviously is not an option, the
designer has to manually check the dependencies in order to remove redundancy
in the invariants.
While obviously the example above is rather artiﬁcial, cases like this frequently
occur in the design of complex systems. The approach in [GHK10] tries to deal
with that by ﬁrst applying Algorithm 2 and, afterwards, trying to identify the reason
for it. This is done by considering cases again, for which no system state could be
obtained. Then, one invariant after another is deactivated until a plausible reason
has been obtained (cf. [GHK10, Sect. 2]). An alternative relies on analyzing the set
of dependent invariants in detail, but without considering the full set of remaining
invariants [GHK10, Sect. 3]. In the example above, this would lead to no result. As
a consequence, no reasons for the dependencies would be detected and the designer
would probably try to discard i1 although discarding i2, i3, and i4 would not
only remove the redundancy, but eventually result in a much more compact model.
The approach proposed in [BW09] makes a more comprehensive analysis but also
here neither completeness nor minimality of the determined results is ensured.
Overall, previous approaches do not only suffer from limitations with respect
to scalability and automation but, in the worst case, also lead to results where the
designer is left with a rather poor understanding about the identiﬁed dependencies.
For a comprehensive and fast removal of redundancies, an independence analysis
is required which (1) does provide a complete set of dependent invariants together
with (2) a minimal list of the reason for each dependency.
4.2.3
Proposed Solution
The goal now is to aim for leveraging the analysis for invariant independence in
UML/OCL models by addressing the drawbacks of previously proposed approaches
discussed above. For this, an automated approach which does not rely on any
manual interaction at all is introduced. Scalability is improved by utilizing the
SMT solver Z3 again rather than enumerative methods. Finally, the quality of the
results is improved by performing a more advanced analysis of the respectively
considered invariants which eventually leads to the complete determination of
dependencies together with their respective minimal reasons. In this section, details
of the proposed solution are provided. For this purpose, an advanced problem
formulation for independence analysis is provided ﬁrst. Afterwards, the improved
algorithm is presented.

116
4
Structural Aspects
4.2.3.1
Advanced Problem Formulation
In order to address the drawbacks mentioned above, the original problem formula-
tion for independence analysis (see Deﬁnition 4.4) is enriched by a deﬁnition of a
minimal reason for a dependency.
Deﬁnition 4.5 (Minimal Reason for a Dependency) Let m
D
.C; R/ be a
(consistent) model, I the set of all invariants of all classes, and ˙ the set of all system
states derived from m. Furthermore, let ik 2 I be a dependent invariant according to
Deﬁnition 4.4. Then, the reason for this dependency is a subset IDR 
 I nf ikg which
satisﬁes
8  2 ˙ W
^
i2IDR
.i/ ) .ik/:
(4.4)
Furthermore, a reason I is called minimal, iff
8 J ¨ IDR W 9  2 ˙ W
^
j2J
. j/ ^ :.ik/
(4.5)
also holds.
In other words, Deﬁnition 4.5 states that a subset IDR  I n f ikg of invariants
is a reason, if for all system states  2 ˙ the satisfaction of the invariants I also
implies the satisfaction of the invariant ik. Minimality is guaranteed by the fact that
removing just one invariant from a reason IDR (leading to J ¨ IDR) would allow for
at least one system state  where Eq. (4.4) does not hold (for J instead of IDR). For
such a system state, all the invariants of a subset J are satisﬁed while ik is violated.
Example 25 Consider again, the model given in Fig. 4.4. Instead of providing
a simple set D D fi1; i2; i3; i4g of dependent invariants as discussed in
Example 24, applying the advanced deﬁnition additionally provides some evidently
minimal reasons, e.g.,
•
i1 is dependent on i2,i3,i4 (i.e., .i2/ ^ .i4/ ^ .i4/ ) .i1/),
•
i2 is dependent on i1 (i.e., .i1/ ) .i2/),
•
i3 is dependent on i1 (i.e., .i1/ ) .i3/), and
•
i4 is dependent on i1 (i.e., .i1/ ) .i4/).
Obviously, considering these minimal reasons helps the designer much better in
removing redundancies from the model. Based on that, it is clear that i2,i3,i4
can be removed.
4.2.3.2
Determining Minimal Reasons for Dependent Invariants
In order to additionally determine the minimal reasons for a dependent invariant ik,
a more thorough analysis is required. For this purpose, an extension to Algorithm 2

4.2
Analyzing Invariant Independence
117
Algorithm 3 Analysis for dependency of ik
Global Var.: A set MDR of minimal reasons (initialized MDR  ;)
analyze_dependency(IDR)
Input: A subset IDR of invariants
1: minimal_reason  true
2: for all J  IDR with j Jj D jIDRj  1 do
3:
if 9  2 ˙ W V
j2J . j/ ^ .:.ik// then
4:
// J is not a reason
5:
else
6:
// J is a reason smaller than IDR, i.e., IDR is not minimal
7:
minimal_reason  false
8:
analyze_dependency. J/
9: if minimal_reason then
10:
MDR  MDR [ f IDRg
11: return
for independence analysis is proposed: Whenever an invariant ik 2 I has been shown
dependent (Line 7 in Algorithm 2), another analysis of this particular dependency
is performed. To this end, a (recursive) procedure as sketched in Algorithm 3 is
proposed.
The algorithm gets the subset of invariants IDR D I nf ikg as input and determines
all minimal reasons for the dependent invariant ik.5 These reasons are stored in a
global variable MDR which is initialized as an empty set. Since ik was shown to be
dependent (using Algorithm 2), IDR D I n f ikg obviously is a reason for that. It is
additionally assumed that I is minimal; stored in a Boolean variable minimal_reason
(Line 1). Then, it needs to be analyzed whether smaller reasons exist or not.
For this purpose, all subsets J  IDR which are one element smaller than IDR are
considered (Line 2). For each of these subsets is checked whether it still is a reason
for the dependent invariant ik (Line 3), i.e., whether Eq. (4.4) from Deﬁnition 4.5
holds. As in Algorithm 2, the symbolic formulation can be utilized for this purpose.
This requires a slight re-formulation of the condition: Instead of showing that J is a
reason (i.e., the satisfaction of invariants J implies the satisfaction of invariant ik in
all system states), it is determined whether J is not a reason (i.e., whether a system
state exists which satisﬁes J but not ik).
If J is indeed not a reason, then the assumption that IDR is minimal remains valid,
i.e., the iteration through all subsets simply continues (Line 4). Otherwise, a reason
with a smaller number of invariants than I has been determined. Consequently,
minimal_reason is immediately set to false (Line 7) and the algorithm is recursively
called to analyze further subsets smaller than J (Line 8). The process terminates
if all subsets have been considered. If no smaller reason has been determined,
i.e., minimal_reason remained true (Line 9), the currently considered set IDR of
invariants has proven to be minimal and is accordingly added to MDR (Line 10).
5Note that more than one minimal reason may exist for a dependent invariant ik.

118
4
Structural Aspects
Algorithm 3 completely solves the problem formulated in the previous section.
However, a major bottleneck is the check in Line 3 which is computationally
expensive with respect to both the complexity of each single check and the quantity
of all checks to be conducted. This is addressed as follows:
•
Complexity
As discussed in Sect. 4.2.2, previously proposed approaches for the analysis
of independence relied on enumerative methods [GKH09, GHK10] or theorem
provers [BW09] with a signiﬁcant amount of manual interaction.
We propose to tackle the complexity by relying on powerful solving engines,
in this work the SMT solver Z3 [MB08]. For this purpose, the respective
veriﬁcation problems (is there a system state satisfying or not satisfying cer-
tain invariants) are transformed into corresponding symbolic formulation as
described in Chap. 3. Afterwards, Z3 is applied to solve the problem. Since it
does not enumerately traverse the search space but employs intelligent decision
heuristics, powerful learning schemes, and efﬁcient implication methods, they
handle the complexity much faster while, at the same time, require no manual
interaction.
•
Quantity
Strictly following Algorithm 3 might lead to a large number of checks to be
conducted—many of those might be redundant. This is avoided by keeping track
of previously performed checks: The results of all checks conducted in Line 3 are
stored in a corresponding global data-structure. If the same subset of invariants
is considered again (for the same ik), simply the previously determined result is
re-used.
Due to the fact that, for a subset J—which has been classiﬁed not to be a
reason—the determined system state also offers the information that all subsets
of J are not a reason as well, this data-structure allows for an efﬁcient and fast
processing of the algorithm. By this, the total number of actually performed
checks can be reduced signiﬁcantly.
Following these schemes, the proposed solution addressed the main drawbacks
of state-of-the-art approaches for invariant independence analysis, i.e., scalability,
automation, and quality of the determined results. This has also been conﬁrmed in
an experimental evaluation whose results are summarized next.
4.2.4
Experimental Evaluation
In order to evaluate the proposed solution, the algorithms described above including
its optimizations have been implemented as an Eclipse plugin using both, Java
and Xtend, on top of the proposed symbolic formulation presented in Chap. 3. As
already mentioned, Z3 has been utilized as SMT solver for the respective checks
in Line 3 of Algorithm 2 and Line 3 of Algorithm 3. The experiments have been
carried out on an Intel i5 with 2.6 GHz cores and 16 GB memory using a 3.11
kernel Linux. As benchmarks, different UML/OCL models taken from the USE

4.2
Analyzing Invariant Independence
119
package [GBR07]—including models considered in previous work [GHK10]—in
addition to further models not considered before have been used.
4.2.4.1
Evaluation of the Runtime Performance
In a ﬁrst series of experiments, the performance of the proposed solution with
respect to the required runtime was evaluated. Since the aim was a fully-
automatic approach for independence analysis, a comparison to the solution
proposed in [BW09] (which heavily relies on manual interaction and, hence, is
not comparable) has been omitted.
Table 4.3 summarizes the obtained results. The ﬁrst columns provide the name
of the respective models followed by their number of classes (jCj), their number of
relations (jRj), their number of invariants (jIj), their maximal number of considered
object instantiations per class (jOj), and an indication whether the invariants in the
model are independent (denoted by X) or not (denoted by ) under the respective
Table 4.3 Evaluation of the runtime performance
Model name
jCj
jRj
jIj
jOj
Independent? [GHK10]
This work
CAB
1
0
3
1
	
< 1 s
< 1 s
class C2
1
0
4
1
	
< 1 s
< 1 s
class C3
1
0
4
1
	
< 1 s
< 1 s
class C4
1
0
9
1
	
< 1 s
3 s
CivStat
1
1
6
4
	
987 s
4 s
5
	
>12 h
3 s
6
	
>12 h
7 s
7
	
>12 h
17 s
8
	
>12 h
37 s
9
	
>12 h
80 s
10
	
>12 h
217 s
Demo1
3
3
4
5
X
>12 h
3 s
Demo2
3
3
7
5
X
>12 h
5 s
CarRental
9
12
6
5
	
>12 h
< 1 s
6
	
>12 h
2 s
7
	
>12 h
3 s
8
	
>12 h
5 s
9
	
>12 h
8 s
10
	
>12 h
16 s
PerCom
3
4
5
5
X
>12 h
6 s
Simple-CPU 6
6
9
5
X
>12 h
9 s
Legend:
jCj: Number of classes
jRj: Number of relations
jIj: Number of invariants
jOj: Maximal number of considered object instantiations per class
Independent?: All invariants in the model are independent (X) or not (	)
[GHK10]/This work:
Runtime of the respective approach

120
4
Structural Aspects
conﬁguration (Indep?). Note that the models CivStat and CarRental have been
considered with more than one conﬁguration (i.e., number of object instantiations)
and, hence, corresponding results are reported in several rows in Table 4.3.
Afterwards, the respective runtime (in CPU seconds) needed for performing the
independence analysis is reported for the approach from [GHK10] as well as the
approach presented in this work.
The numbers clearly show that the proposed solution is an improvement com-
pared to state-of-the-art method from [GHK10]. For all models, an independence
analysis is performed signiﬁcantly faster. For most of the considered cases, the
previously proposed approach was not able to determine a result within the given
time limit of twelve hours while the proposed solution completed all the analyses in
just a couple of minutes. At the same time, the proposed approach was even able to
determine much better results which is discussed next.
4.2.4.2
Quality of the Results
In a second series of experiments, the quality of the obtained results was evaluated—
again including a comparison to the solution from [GHK10]. For this purpose, the
results obtained for the ﬁve models for which the approach presented in [GHK10]
terminated within the given time limit have been investigated in more detail.
Table 4.4 provides a corresponding summary, i.e., lists the results of the
respective analyses. The right-hand side of the respective terms represents the
Table 4.4 Quality of the
results
Model name
[GHK10]
This work
CAB
i3 ) i1
i3 ) i1
class C2
I n f i1g ) i1
i4 ) i1
I n f i2g ) i2
i4 ) i2
I n f i3g ) i3
i4 ) i3
I n f i4g ) i4
i1; i2; i3 ) i4
class C3
I n f i1g ) i1
i2; i3 ) i1
i3; i4 ) i1
i2; i4 ) i1
I n f i2g ) i2
i3; i4 ) i2
i1 ) i2
I n f i3g ) i3
i2; i4 ) i3
i1 ) i3
I n f i4g ) i4
i2; i3 ) i4
i1 ) i4
class C4
# 9
# 96
CivStat
i3; i4 ) i6
i3; i4 ) i6
i1; i4; i6 ) i3
i1; i3; i6 ) i4
i2; i3; i6 ) i4

4.3
Relation to Similar Approaches Used in SAT/SMT Solving
121
respectively determined dependent invariants of the model, while the left-hand side
represents their reasons. Note that in the proposed solution all reasons have been
shown to be minimal. This is not the case for results obtained by [GHK10]. In cases
where [GHK10] did not determine a reason, all remaining invariants (i.e., I n f ikg)
have been considered as a reason. In case of the model class C4, we omitted an
explicit listing of all determined results. Instead only the total number of determined
reasons are presented.
Also here, very clear conclusions can be drawn. While the previously proposed
approach determines all dependent invariants for the models CAB, class C2,
class C3, and class C4, no explicit reasons are provided in these cases. As
discussed before in Sect. 4.2.2, this may lead to rather poor design decisions, e.g.,
the removal of invariants which better should remain in the model. In contrast,
the proposed approach leads to all minimal reasons from which, as discussed in
Example 25 (see Sect. 4.2.3.1), redundancies can be removed in a signiﬁcantly better
fashion. Moreover, in case of CivStat it can even be observed that the previously
proposed solution does not necessarily detect all dependent invariants. In fact, only
invariant i6 was detected as dependent; but invariants i3 and i4 are dependent as
well in this case.
4.3
Relation to Similar Approaches Used in SAT/SMT
Solving
Determining unsat cores and maximum satisﬁable sets as used in the sections before
has a long history in informatics and is very much related to the determination
of Minimal Unsatisﬁable Subsets (MUS), Maximal Satisﬁable Subsets (MSS), and
Minimum Correction Sets (MCS). All these entities are connected tightly as different
perspectives to the same problem [IgnC15]. To outline the differences between
these three note the following description:
MUS
Minimal constraint set such that the set itself is unsatisﬁable but gets
satisﬁable as soon as any constraint is removed (equivalent to the unsat cores).
MSS
Maximum set of constraints that is satisﬁable but gets unsatisﬁable as soon
as any constraint is added.
MCS
Minimal set of constraints that has to be removed in order to make all
constraints satisﬁable.
The MCSs are equivalent to the minimal reasons for the inconsistency of a
model (Sect. 4.1) and for a dependent invariant (Sect. 4.2). None of these sets has
necessarily to be unique in a constraint system. Thus, for all research done in the past
there are generally two approaches. Either just one MUS/MSS/MCS is determined
or all are enumerated. However, the latter one suffers from performance problems
due to the complexity which is caused by the number of necessary enumerations to
test. Accordingly, only few approaches have been introduced and usually they do

122
4
Structural Aspects
not make use of newer approaches for single MUS/MSS/MCS detection—making
the already slow approaches even slower.
MUS/MSS/MCS is and stays undeniable a very complex problem, but a rea-
sonable objective would already be a tool ﬁnding the ﬁrst MUS/MSS/MCS in
a timespan comparable to a tool searching for only one MUS/MSS/MCS and
ﬁnding further ones in also comparable time. In 2016, Lifﬁton et al. published
the MARCO/eMUS algorithm which makes use of established MUS ﬁnding meth-
ods [LifC16]. The actual algorithm for MUS detection stays hereby exchangeable,
such that advances in that ﬁeld can be integrated. Furthermore, the approach is
independent from the kind of constraints.
To determine the MUS, the MARCO/eMUS algorithm uses two basic con-
cepts:
1. a function to determine the satisﬁability of a (sub-)set of the constraints and
2. a map of which (sub-)sets have been explored so far.
The actual algorithm is very similar to those used in Sects. 4.1 and 4.2. For
each constraint, a Boolean variable is assigned which can be used to deactivate the
constraint. For every known unsatisﬁable combination of these variables, a clause
is added to map, blocking all supersets of the unsatisﬁable set—this is what is also
done in the algorithms described in Sects. 4.1 and 4.2. But Lifﬁton et al. go beyond
the techniques of this book. They also add clauses for the determined satisﬁable
subsets to the map, blocking all subsets of them.
Example 26 Consider the constraints from Fig. 4.5. Next to them, there is the Hasse
diagram which can be seen as a depiction of the search room. Each constraint i will
be assigned with a variable xi.
In case the algorithm ﬁnds, e.g., f2; 4g to be satisﬁable, it will add the clause
x1 _ x3 to the map, i.e., the complement of the found set. By this, all subsets of the
found set will be blocked. If the algorithm ﬁnds f1; 2g to be unsatisﬁable, it will add
the clause :x1 _ :x2 to the map, blocking all supersets of the found set.
1,2,3,4
1,2,3
1,2,4
1,3,4
2,3,4
1,2
1,3
1,4
2,3
2,4
3,4
1
2
3
4
Constraints
1. a
2. ¬a
3. ¬a∨b
4. ¬b
Fig. 4.5 Hasse diagram of a set of constraints

4.3
Relation to Similar Approaches Used in SAT/SMT Solving
123
The actual algorithm will start exploring in any region of the problem with a
starting set called a seed and reduce the search room by blocking clauses. Depending
on whether the seed is found to be satisﬁable or not it is searched for a MUS
by shrinking the sets or moving down in Hasse diagrams as shown in Fig. 4.5.
Otherwise, if the seed is satisﬁable, an MSS is determined in an equivalent way
by increasing the sets until an MSS is reached. Afterwards, it is blocked upwards or
downwards, respectively, to exclude unnecessary evaluation. Finally, a new seed is
chosen for the next iteration.
Although the algorithms from Sects. 4.1 and 4.2 developed the same ideas as used
in MARCO/eMUS (while MARCO/eMUS was not published when authors of this
book started to investigate their problems), they do not combine both and employ
a less sophisticated searching and blocking strategy. However, the basic ideas are
the same and the improvements from MARCO/eMUS could easily be applied to the
implementation as well, probably improving the performance signiﬁcantly.
As the Sects. 4.1 and 4.2 do focus more on the actual use cases and the
applicability of such methods, it may be a shortcoming to not employ sophisticated
methods like the MARCO/eMUS but not a crucial one as the performance is
still remarkably improved by the method implemented here. Furthermore, the
MARCO/eMUS methods would be easily to implement as well and will be included
in the future.

Chapter 5
Behavioral Aspects
The previous chapter provided algorithms to deal with structural veriﬁcation aspects
of UML/OCL models. However, the question during design is not only whether a
model can be instantiated but also—and much more interesting and complicated—
whether the behavior is speciﬁed correctly. Pleasantly and intended by design, the
symbolic formulation described in Chap. 3 can also be used to address behavioral
veriﬁcation tasks. Also in Chap. 3, it has, e. g, been explained how the executability
of operations can be formulated or how to check if a system can get stuck in
bad system state such as deadlocks. Therefore, two succeeding system states are
connected by adding another variable to represent the executed operation call
between them and more constraints to enforce that the operation is valid. The
current OCL standard (version 2.4 from 2014-02-03) offers pre- and postconditions
to describe the impact of an operation. The preconditions must be satisﬁed in
the system state in which the operation is called and the postconditions must
be satisﬁed in the system after executing the operation (see Deﬁnition 2.14 for
details about the evaluation). While postconditions are well designed to describe
the changes that are supposed to occur during a transition, the OCL so far does
not offer any smart concepts to describe what is not supposed to change—except
for the case postconditions are used to avoid all undesired changes which is hard
to maintain. This means that according to pure OCL every attribute is allowed to
change completely arbitrarily unless there is a restricting postcondition.
Section 5.1 discusses different solutions how this arbitrary changes can be
restricted and have been restricted in the past when dealing with behavioral aspects.
This leads to the concept of invariability clauses as presented in [Kos06, Kos13] to
extend the description means for OCL operations. Furthermore, it is described how
these invariability clauses can be integrated into the symbolic formulation (based
on [PrzC16a, PrzC15b]).
Despite that, another important issue is considered in this chapter: So far, all
approaches to analyze behavior were only applicable to non-concurrent behavior.
However, minimization and parallelization are imminent trends in the design of
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8_5
125

126
5
Behavioral Aspects
modern embedded systems. Consequently, Sect. 5.2 uses the invariability clauses
again to present a methodology how concurrent operation calls in UML/OCL can
be handled and implemented using the symbolic formulation (based on the work
in [PrzC15a]).
5.1
Restricting State Transitions Using Frame Conditions
One central problem when dealing with behavior of UML/OCL models, i.e., pre-
and postconditions of an operation also called operation contracts, is the lack of
information which model elements are allowed to change their value during a
transition and which are not. The symbolic formulation obtained in Chap. 3 on the
one hand already supports behavioral checks, but on the other hand the descriptions
have ignored the aforementioned problem. Without any concept providing addi-
tional information, the behavioral checks which can be conducted with the symbolic
formulation are not very expressive at all. To tackle this problem, two concepts are
proposed and their integration into the symbolic formulation is described.
Before the concepts are explained, the problem is illustrated to make clear what
exactly is meant by which model elements are allowed to change their value during
a transition and which are not. For this purpose, the running example is used another
time.
Example 27 Figure 5.1 shows two different system states of the access control
system model, one at the top and one at the bottom of the ﬁgure. Both system states
are consisting of one building object, one magnetic card and two turnstiles.
Both system states are valid, i.e., all model constraints are satisﬁed. Moreover, it
is possible to get from the system state in the top to the one in the bottom because the
evaluations of both the preconditions and the postconditions hold for the operation
checkCard(M1) called on the turnstile T1.
As intended by the operation’s postconditions, the green light of turnstile T1 is
turned on by the operation call. However, at the same time it would also be possible
B1:Building
authorized = {1}
inside =
T1:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
entry = true
T2:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
entry = false
M1:MagneticCard
id = 1
B1:Building
authorized = {1}
inside = {42}
T1:Turnstile
greenLightOn = true
redLightOn = false
currentlyAuthorized = 1
timeOpen = 0
entry = true
T2:Turnstile
greenLightOn = true
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
entry = false
M1:MagneticCard
id = 1
T1.checkCard(M1)
Fig. 5.1 A valid transition between two valid system states

5.1
Restricting State Transitions Using Frame Conditions
127
to turn on the green light of the other turnstile T2 and to add an arbitrary id (e.g., 42)
to the inside attribute of the building B1 (even if there is no magnetic card with
such an id). Although such a behavior is obviously not intended, it is completely in
line with the postconditions as there are no postconditions explicitly forbidding it.
Since the recently described problem has already been identiﬁed before and the
ﬁrst concept to be proposed in this section bases on theoretical concept of another
work, related work is discussed at ﬁrst.
5.1.1
Related Work
As recently shown behavior can be expressed in UML/OCL models in terms of oper-
ations with pre- and postconditions. At a ﬁrst glance, these declarative descriptions
of the operation’s behavior ideally ﬁt to the paradigm of designing systems without
the need to provide detailed implementations. However, Example 27 showed that
they may allow for undesired behavior of the system.
In general, the shortcoming of declarative descriptions like pre- and postcon-
ditions is that they often do not make clear enough which model elements are
allowed to change during an operation call. In other words: they do not specify
what is within the frame that might be modiﬁed by an operation—the so-called
frame problem [BMR95]. Accordingly, as the entire design is somehow under-
speciﬁed without this information, it has been suggested to ﬁll this gap by adding
so-called frame conditions. In the past, various approaches have been proposed for
this purpose for UML/OCL models:
•
A very naive and straightforward approach is to manually specify what is not in
the frame by extending the postconditions with constraints like modelElement
= modelElement@pre as it is done in [DioC14]. This case study, however,
illustrates very impressively how time-consuming it is to create these constraints
in the ﬁrst place and to maintain them later on in case of design changes.
•
Another approach to frame conditions is to automatically derive them from the
postconditions using a paradigm like nothing else changes [Cab06, Cab07] which
includes every model element that is referenced within postconditions in the
frame of what may change (and nothing else). Again, the results of this implicit
approach are also often not exactly what the designer intended and, besides that,
it is hard to adjust them manually—which would have to be done by rewriting
the postconditions themselves.
•
Finally, a more thorough approach has been suggested by Kosiuczenko [Kos06,
Kos13]. The idea is to specify the set of variable model elements, i.e., model
elements that are allowed to be changed during an operation call, at the same
level as pre- and postconditions in terms of so-called invariability clauses1
which are of the form modifies only: scope::modelElement. For
1A variation of this idea is to specify the set of variable model elements within the postconditions
using an OCL primitive modifiedOnly(Set) [BTW14].

128
5
Behavioral Aspects
instance, the clause modifies only: self::greenLightOn expresses
that the operation may only change the attribute greenLightOn of the turnstile
on which the operation is called (self). However, the scope can also be more
complex and may contain any OCL expression, e.g., navigation on collections.
Besides that, it is even possible to allow objects of a certain class to be created
or deleted during an operation call using the construct Class::allInstances() and
oclIsNew.
This approach enables the designer to deﬁne frame conditions in a very
comfortable, understandable, and maintainable fashion. Moreover, there exists
a methodology to assist the designer in the initial generation of the frame
conditions [NieC15a] and an approach that does most of the work automatically
and requests feedback of the designer in ambiguous cases only [NieC15b].
Overall, frame conditions are very important for obtaining precise model descrip-
tions and are a key ingredient when considering behavior of UML/OCL models,
because without them undesired behavior as shown in Example 27 can easily occur.
Note that the frame problem also arises in the context of software veriﬁcation
where a substantial body of research has focused on it (see, e.g., [BS03] for a
proposal which is close to Kosiuczenko’s invariability clauses) and corresponding
approaches have been integrated into several veriﬁcation tools like Boogie [Lei08]
or KeY [AhrC05]. Though these approaches are somewhat similar, they are not
directly applicable to UML/OCL for many reasons, but especially due to the fact
that (a) OCL principally allows you to access arbitrary objects via allInstances(),
(b) associations are always bi-directional (in contrast to uni-directional pointers)
such that changes to references always affect both ends, and (c) object creation and
deletion can be rather random as we usually do not have a precise implementation.
5.1.2
Integrating Frame Conditions in the Symbolic
Formulation
In this subsection, the modifies only concept as proposed by Kosiuczenko [Kos06,
Kos13] is ﬁrst used to extend the deﬁnition of an operation of a class. Since this con-
cept in the presented shape can only be applied to evaluate a given transition between
two system states, it will be explained afterwards how modifies only statements can
be integrated into the symbolic formulation. By this, it is possible to add information
about the variability of model elements (which the symbolic formulation will respect
by construction) such that undesired behavior is signiﬁcantly restricted. Moreover,
besides conventional veriﬁcation tasks, it can additionally be used to validate the
frame conditions themselves, i.e., to check whether they are consistent (do not
completely prohibit the execution of the corresponding operation) or whether they
express what the designer intended.
From the approaches discussed in Sect. 3.4, only Isabelle/HOL-OCL supports
a similar concept. However, to the best of our knowledge there is currently no
approach supporting such a concept in a fully automatic fashion.

5.1
Restricting State Transitions Using Frame Conditions
129
5.1.2.1
Changes to the UML/OCL Model Deﬁnitions
Deﬁnition 5.1 (Adding Frame Conditions to an Operation) Let c D .A; O; I/
be a class as deﬁned in Deﬁnition 2.1. So far, an operation o 2 O was deﬁned as
a 4-tuple o D .P; r; C; B/, to allow for a more thorough modeling of behavior,
the deﬁnition is extended such that an operation o 2 O is from now on a 5-tuple
o D .P; r; C; B; F/, whereby F is set of frame conditions. Each frame condition
f 2 F is pair consisting of the scope in terms of an OCL expression and a model
element. The model element must always respect the result of the scope, i.e., it must
be possible to use a navigation expression on the result with the model element.
Further, the ﬁrst four entries stay as they are.
Deﬁnition 2.14 (dealing with evaluation of operation calls) also must be modiﬁed
to consider frame conditions.
Deﬁnition 5.2 (Evaluation of Frame Conditions to Operation) A valid transi-
tion from one system state to another is only valid, iff the evaluation of pre- and
postconditions hold and all model elements which have changed their value are
covered by at least one frame condition f 2 F. Otherwise the transition is invalid.
Note that if the model element of a frame condition is an association, only one
end of the association will be given because in general navigation expressions will
only work for one end. However, the corresponding other end is also affected—
details will be given later in this section.
Example 28 Figure
5.2
shows
the
running
example,
the
access
control
system model, but now frame conditions have been added for all three
operations. For example, for the operation checkCard has three frame condi-
tions: self::greenLightOn, self:: redLightOn, self::currently
Authorized. This makes the transition shown in Fig. 5.1 invalid because, e.g.,
the value of the attribute greenLightOn of the object T2 has changed but there
is no frame conditions allowing this.
5.1.2.2
Adding Constraints for Frame Conditions
To support frame conditions in symbolic representations, a description of their
impact has to be added, simply spoken, Eq. (3.11) must be changed. To this end,
further variables are introduced which symbolically represent whether a respective
model element is supposed to be changed by a transition or not. This is described
by a set of functions which map each instantiated model element to a Boolean value
indicating if the corresponding element is allowed to change or not.
Transformation Rule 24 For the impact of frame conditions on a transition, three
different types of variability maps V from m./ to B are created. If V ./ evaluates
to true, then the value of the model element  is variable during the operation
call ! from the system state  to 0. Otherwise, it is not allowed to change its value.
Since the evaluation of each explicit frame condition statement depends on the
scope which itself mostly depends on the calling object, the impact for each possible

130
5
Behavioral Aspects
Turnstile
greenLightOn: Boolean
redLightOn: Boolean
currentlyAuthorized: Integer
timeOpen: Integer
type: TurnstileType
goThrough()
advanceTime()
checkCard(card : MagneticCard)
≪enum≫
TurnstileType
Entry
Exit
Building
authorized: Set(Integer)
inside: Set(Integer)
MagneticCard
id: Integer
gates
2..∗
building
1
inv atLeastOneEntry:
gates->exists( t | t.type = #Entry)
inv atLeastOneExit:
gates->exists( t | t.type = #Exit)
inv uniqueID:
MagneticCard.allInstances()->forAll(
card1, card2 |
(card1 <> card2)
implies (card1.id <> card2.id)
)
context Turnstile::advanceTime():
pre :
greenLightOn = true
or redLightOn = true
post : (
(
( timeOpen@pre < 2 )
or ( redLightOn = false ) )
and ( timeOpen@pre < 30 )
) implies ( timeOpen = timeOpen@pre + 1 )
post : (
( timeOpen@pre >= 2 )
and redLightOn
) implies
(
( timeOpen = 0 )
and ( redLightOn = false ) )
post : (timeOpen@pre >= 30)
implies
(
( timeOpen = 0 )
and ( greenLightOn = false ))
modifies only : self::greenLightOn
modifies only : self::redLightOn
modifies only : self::timeOpen
context Turnstile::checkCard(card : MagneticCard):
pre : greenLightOn = false
pre : redLightOn = false
post :(
( building.authorized->includes(card.id) )
and ( type = #Entry <> building.inside->includes(card.id) )
) implies
(
greenLightOn = true
and currentlyAuthorized = card.id)
post : (not ( building.authorized->includes(card.id) ) )
implies
(redLightOn = true)
modifies only : self::greenLightOn
modifies only : self::redLightOn
modifies only : self::currentlyAuthorized
context Turnstile::goThrough():
pre : greenLightOn = true
post :(
( building.inside@pre->includes(currentlyAuthorized) )
and ( type = #Exit )
) implies
( not building.inside->includes(currentlyAuthorized) )
post :(
( not building.inside@pre->includes(currentlyAuthorized) )
and ( type = #Entry )
) implies
( building.inside->includes(currentlyAuthorized) )
post : greenLightOn = false
post : timeOpen = 0
modifies only : self.building::inside
modifies only : self::greenLightOn
modifies only : self::timeOpen
Fig. 5.2 The access control system model with frame conditions

5.1
Restricting State Transitions Using Frame Conditions
131
frame conditions statement must be considered. Thus, F! denotes the set of all frame
conditions of the operation call !. Then, the following maps are introduced:
V
W m./ 7! B
8 ! 2 ˝ WV!
W m./ 7! B
8 ! 2 ˝ W 8 f 2 F! WV!;f W m./ 7! B
whereby
1. V represents whether a model element  is affected in general by a transition,
2. V! represents whether a model element  is affected by the operation call !, and
3. V!;f represents whether the model element  is affected by the frame condi-
tion f 2 F! of the operation call !.
SMT-LIB Realization of Transformation Rule 24.
All three maps are repre-
sented with a bit mask of length jm./j, where each bit represents the result of
the map regarding a unique model element :
1 (declare-fun V
() (_ BitVec jm./j))
2 (declare-fun V! () (_ BitVec jm./j))
3 (declare-fun V!;f () (_ BitVec jm./j))
Example 29 Since the system state depicted in the top of Fig. 5.1 has 16 instantiated
model elements, each map requires a bit mask with 25C1C2C1C12 D 16 bits.
As stated in Transformation 24, maps are needed for the overall frame conditions
of the transition, the six different operation calls, and within them for each frame
condition statement, i.e., overall 1 C 6 C 3 C 3 C 3 C 3 C 3 C 3 D 25.
Unfortunately, the possible solutions for the symbolic representation have not
really changed, because the precise mapping for the maps is not given and, thus, a
solver can choose an arbitrary assignment to the recently added variables. That is,
there are no constraints restricting the changes of model elements compared to the
situation before adding the maps. Thus, a precise mapping for the three different
types of maps must be added and also further restrictions, i.e., constraints, based on
the overall frame condition map. Let us start with the latter.
Transformation Rule 25 An instantiated model element  2 m./ belonging to
an attribute of a class2 is variable by the transition if V ./ D true holds and
it is not allowed to change its value if V ./ D false. This yields the following
constraint:
^
2m./
 belongs to an attribute
.V ./ D false/ )

./ D 0./

(5.1)
2The idea for associations is a bit more complicated and is given later in more detail, but the main
idea is the same one.

132
5
Behavioral Aspects
where ./ represents the precise variable of  in system state , i.e., some ˛
a in
the respective system state.
SMT-LIB Realization of Transformation Rule 25. Let ./ belong to the vari-
able ˛
a and to the 0th bit of V .3 Then, the following SMT-LIB constraints are
added:
1 (=> (= ((_ extract 0 0) V ) #b0)
2
(=
˛
a
0˛
a ))
Example 30 Assume that, in the running example, the attributes greenLightOn
and redLightOn of the object instance T1 are related to bit number 0 and 1 of
the bit mask V representing the overall frame conditions map. Then, the precise
SMT-LIB constraints obtained by are:
1 (=> (= ((_ extract 0 0) V ) #b0)
2
(=
˛T1
greenLightOn
0˛T1
greenLightOn))
3 (=> (= ((_ extract 1 1) V ) #b0)
4
(=
˛T1
redLightOn
0˛T1
redLightOn))
As a next step, it should be ensured that the overall frame condition map equals
the frame condition map of the executed operation call. For this purpose, a slight
modiﬁcation of Eq. (3.11) is required:
Transformation Rule 26 To support frame conditions in a symbolic representa-
tion, use
^
!2˝
.!!0 D r˝m.!// )
0
BBBBB@
ˇc./ D true
^ C;fself7!g
m
D .✓; true/
^ B;0;fself7!g
m
D .✓; true/
V D V!
1
CCCCCA
(5.2)
instead of Eq. (3.11).
As exactly one of the premises of the implications for the operation calls can be
satisﬁed, satisfying assignments are only possible in which the overall variability
map will be equal to the overall variability map of the corresponding operation call.
In the next step, the overall variability map of an operation call is deﬁned:
Transformation Rule 27 If the disjunction of the values of all variability maps
V!;f for a ﬁxed ! and a ﬁxed instance of a model element  is true, then the
variability map V! should also state that the model element is variable. This is
formally done by the following formula:
3The preceded index  is used to make clear that the variable ˛
a in the corresponding system state
is meant. Those indices are important when behavioral aspects are analyzed because instead of a
single system (where variables are unique) a sequence of system states is considered.

5.1
Restricting State Transitions Using Frame Conditions
133
8  2 m./ W
^
!2˝
0
@V!./ D
_
f2F!
V!;f ./
1
A :
SMT-LIB Realization of Transformation Rule 27. For each operation call ! D
.; o/ where the frame conditions of o are F D ff1; f2; : : : ; fjFjg, the corresponding
variability map V! is restricted by
1 (= V!
2
(bvor V!;f1
3
V!;f2
4
: : :
5
V!;fjFj))
Example 31 For the operation call .T1; checkCard/ of the running example, the
following constraints in the SMT-LIB format are added:
1 (= V.T1;checkCard/
2
(bvor V.T1;checkCard/;f1
3
V.T1;checkCard/;f2
4
V.T1;checkCard/;f3))
In the last step, a precise deﬁnition of all V!;f respecting the corresponding frame
condition f given by modifies only statements must be given.
Transformation Rule 28 Let f be a frame condition of an operation o and ! D
.; o/ one corresponding possible operation call. Then, V!;f is deﬁned for each
instantiated model element  as follows:
^
2m./
ˇˇˇˇˇˇˇˇˇˇˇ
if
the object of  is in the scope of f
and  is an instance of the model element of f
then V!;f ./ D 1
else V!;f ./ D 0
endif
To check if the object of  is in the scope of f, the OCL expression for the scope
has to be transformed into the symbolic formulation ﬁrst, then includes has to be
called on this result with the object of  as argument consequently returning true,
iff the object indeed is within the scope. All other return values are interpreted as
the object is not in the scope. If  is an instance of the model element of f or not is
already clear when choosing some  2 m./.
Since the SMT-LIB realization is straightforward, it is omitted, however, next up
some examples are presented instead of precise deﬁnitions.
Example 32 For the operation call .T1; checkCard/ of the running example,
consider now the three frame conditions:

134
5
Behavioral Aspects
modifies only f1: self::greenLightOn
modifies only f2: self::redLightOn
modifies only f3: self::currentlyAuthorized
In all three frame conditions the scope is self, which is T1 for the assumed oper-
ation call. Assuming again that ˛T1
greenLightOn has the index 0 in the corresponding
bit mask of V!;f1, the following SMT constraints are generated for the ﬁrst frame
condition:
1 (= ((_ extract 0 0) V.T1;checkCard/;f1) #b0)
2 (= ((_ extract 1 1) V.T1;checkCard/;f1) #b1)
3 ...
4 (= ((_ extract 16 16) V.T1;checkCard/;f1) #b1)
Obviously, the evaluation for the scope condition is that easy for self or in other
words, there is no need for a real transformation of the OCL expression self to
evaluate the scope of the complete condition.
In a similar fashion, the SMT-LIB constraints for the other two frame conditions
are generated.
Example 33 For the operation call .T1; goThrough/ of our running example,
consider now the frame condition
modifies only: self.building::inside
Here, the scope is self.building which, in principle, could be any building. Thus, it
is not possible to directly assign all bits as in the previous example. However, when
the object of any  is not a building, 0 can be directly enforced again. The same
holds, if the model element is not inside.
For the remaining cases self.building is extended to self.building.includes
(object of ). Now, assume that the instantiated model element inside of B1
has the index 12. Then the constraints are:
1 (= ((_ extract 0 0) V.T1;goThrough/;f1) #b0)
2 ...
3 (= ((_ extract 11 11) V.T1;goThrough/;f1) #b0)
4 (ite ?self.building.includes(T1)?
5
(= ((_ extract 12 12) V.T1;goThrough/;f1)
6
#b1)
7
(= ((_ extract 12 12) V.T1;goThrough/;f1)
8
#b0)) )
9 ...
?self.building.includes(T1)? is a placeholder to denote the complete
SMT-LIB constraints for the scope.

5.1
Restricting State Transitions Using Frame Conditions
135
Let’s now come back to the precise handling of associations. An association has
two ends and each end can be marked as variable using frame conditions or not.
Since marking one end of an association as being variable should not only make the
marked association end variable but also the other end of the association.
In Fig. 5.3 (a slightly modiﬁed version of Fig. 3.4), a piece of the symbolic
representation of a system state with two object instances of Building and four of
Turnstile (MagneticCards are omitted) is visualized. Recall: a satisfying assignment
of the symbolic formulation should obtain valid links between the object instances
of the two classes, but as no details are known, the symbolic representation must
allow all possible links. Thus, for each object instance owning an association end, a
relation in the symbolic formulation is represented with a map from all possible
object instances of the class of the other end of the relation to B. For relation
gates of B1, where the opposite end must be an instance of Turnstile, this is
B1
gatesW fT1; T2; T3; T4g 7! B. In the SMT-LIB realization, the map is realized by a
bit vector variable: B1
gates 2 B4. As already mentioned before, links are symmetric
and, thus, corresponding constraints must be added. They are visualized with gray
lines in Fig. 5.3 between possibly linked object instances (indicated by gray dots
with a matching name inside).
Having this idea in mind, it is easy to understand that the variability of associa-
tions cannot depend on the single result of the variability map. More precisely, the
premise of the implication for every possible link must check the values of both
connected instances of the model elements. If at least one of the two values allows
for a change of the link status, the link may change. On the other side, if both values
are not allowing for a change, the link must be constant. This is also illustrated in
Fig. 5.3 with green ✓and red ✗. In the ﬁgure only the relation end gates of B1 is
marked as variable, consequently all values of the map (in the symbolic formulation)
or the bit mask (in the SMT-LIB realization) are marked as variable. Likewise, the
opposite ends are also marked variable. Since all other relation ends are marked as
not variable, all remaining parts of the maps or bit marks, respectively, are also not
variable.
T1 :Turnstile
{B1,B2 →
}
B
building∈B2
T2 :Turnstile
{B1,B2 →
}
B
building∈B2
T3 :Turnstile
{B1,B2 →
}
B
building∈B2
T4 :Turnstile
{B1,B2 →
}
B
building∈B2
B1 :Building
{T1,T2,T3,T4 →
}
B
gates∈B4
B2 :Building
{T1,T2,T3,T4 →
}
B
gates∈B4
T1
T2
T3
T4
T1
T2
T3
T4
B1
B2
B1
B2
B1
B2
B1
B2
Fig. 5.3 Impact of frame conditions to relations

136
5
Behavioral Aspects
Transformation Rule 29 For a model element  2 m./ belonging to an associa-
tion r 2 R, a formulation similar to the one from Eq. (5.1) is used:
^
2m./ where
 of rD.c;c0;_;_/2R
object of  is 
2c
^
Q2c0
 .V ./ D 0 ^ V .r; Q/ D 0/
)


r . Q/ D 0
r . Q/

!
(5.3)
where 
r . Q/ represents the status of the possible link between  and Q for the
relation r and V .r; Q/ refers to the opposite end of the possible link. As relations
have two ends, Eq. (5.3) must also be applied with the changed order of the classes.
Since the SMT-LIB realization again is straightforward, it is omitted, however,
some examples are presented in the following.
Example 34 For the running example (with only two turnstiles and one building),
the precise SMT-LIB constraint for the association constraints obtained from
Eq. (5.3) are, where bit 13 belongs to building of T1, bit 14 to building of T2,
and bit 15 to gates of B1:
1 (=> (and (= ((_ extract 13 13) V ) #b0)
2
(= ((_ extract 15 15) V ) #b0))
3
(= ((_ extract 0 0)
T1
building)
4
((_ extract 0 0)
0T1
building)))
5
6 (=> (and (= ((_ extract 14 14) V ) #b0)
7
(= ((_ extract 15 15) V ) #b0))
8
(= ((_ extract 0 0)
T2
building)
9
((_ extract 0 0)
0T2
building)))
10
11(=> (and (= ((_ extract 15 15) V ) #b0)
12
(= ((_ extract 13 13) V ) #b0))
13
(= ((_ extract 0 0)
B1
gates)
14
((_ extract 0 0)
0B1
gates)))
15 (=> (and (= ((_ extract 15 15) V ) #b0)
16
(= ((_ extract 14 14) V ) #b0))
17
(= ((_ extract 1 1)
B1
gates)
18
((_ extract 1 1)
0B1
gates)))
With all those changed and additional constraints, the symbolic representation as
well as the SMT-LIB realizations does now explicitly consider all frame conditions.

5.1
Restricting State Transitions Using Frame Conditions
137
5.1.2.3
Dealing with Object Creation and Deletion
For the sake of brevity, it has been assumed thus far that no objects are deleted
and/or created during an operation call. Since this obviously is a restriction, how to
deal with deletion and instantiations of objects is described now.
In Sect. 3.2.3, ˇ-variables have been introduced to deal with a range of objects
per class instead of a ﬁxed number per system state. To support or for a better
control of the creation and deletion of objects, the variability of the ˇ-variables
has to depend on frame conditions and the premises of Eqs. (5.1) and (5.3) must
also check if an object after the transition is still alive/dead. Because if the alive or
dead status of an object changes also all of its attributes might change their value.
Transformation Rule 30 For a transition where object creation and deletion is
allowed, the constraint in Eq. (5.1) ensuring that the model elements belonging to
attributes are not changing must be modiﬁed as follows:
^
2m./
 belongs to an attribute
of an object 
 of class c

V ./ D false ^ ˇc
.
/ D 0ˇc
.
/

)

./ D 0./

(5.4)
For associations, there are two different ways of changing the existing formula-
tion. In the ﬁrst option, the alive or dead status of the possibly linked object is also
considered in the premise as just done for the attributes. By this, a deleted object
will lose all its link connections, while a created object can be linked to all possible
instances. Restrictions are assumed to be given by additional constraints, i.e., more
postconditions. In the second option, it is assumed that the designer declares more
frame conditions in order to allow the deletion and creation of possible links.
However, here only the ﬁrst option will be presented:
Transformation Rule 31 For a transition where object creation and deletion is
allowed, the constraint in Eq. (5.3) ensuring that the model elements are not
changing must be modiﬁed as follows:
^
2m./ where
 of rD.c;c0;_;_/2R
object of  is 
2c
^
Q2 .c0/
0
@
V ./ D 0 ^ V .r; Q/ D 0
^ ˇc.
/ D 0ˇc0.
/
^ ˇc0. Q/ D 0ˇc0. Q/
1
A )


r . Q/ D 0
r . Q/

(5.5)
In order to restrict the deletion and creation itself, another bunch of V -map
is added, it maps the classes C to B and indicates if the number objects for the
given class is allowed to change. Precise details are a task requiring great diligence,
furthermore, they are similar to the given details about model elements in this
section and, thus, are omitted.

138
5
Behavioral Aspects
5.1.2.4
Implementation
The proposed approach has been realized within the already mentioned Eclipse
plugin on top of the EMF. As explained earlier, the OCL standard does not support
frame conditions at all, consequently EMF does also not support frame conditions
as it is an implementation of the current OCL standard.4 However, technically the
frame conditions have been realized as postconditions with special names, i.e.,
modifiesOnly for frame conditions on model elements and modifies for
frame conditions taking care of creation/deletion of objects. While all remaining
other postconditions are transformed normally, the special postconditions are
transformed as depicted in the examples. This allows for the ﬁrst time the explicit
consideration of frame conditions in the veriﬁcation and validation in UML/OCL
models.
Since the underlying concepts of frame conditions in existing methods (cf.
Sect. 5.1.1) compared to our approach are remarkably different, an evaluation
comparing them faces several problems: As the concepts are different, also the
provided models are slightly different. Thus, the quality of the results gained by
applying these different methodologies must be a matter of comparison. However,
for measure quality, ﬁrst some case studies have to be conducted in order to bring
up some criteria for quality, which is far beyond the scope of this book. Of course,
also the run time must be compared, but it does not make any sense to just compare
run times without analyzing the quality at the same time. Thus, a direct comparison
of the approaches in Sect. 5.1.1 with the proposed solution is omitted here.
5.1.3
Deriving Frame Conditions from the AST
The last subsections have described the problem of verifying behavior of UML/OCL
models, how frame conditions can solve it (at least partially), and how they can
be integrated into symbolic formulation. This subsection will at ﬁrst demonstrate
that there are still cases with undesired changes and second propose an additional
concept which further restricts such undesired changes. For the second part, an
automatic generation and evaluation of the respective postconditions by using
interpretation semantics is used, i.e., restricting further changes of instantiated
model elements concerning the given OCL expressions.
5.1.3.1
Remaining Problems with Frame Conditions
Example 35 Consider the access control system model with frame conditions as
depicted in Fig. 5.2. In the following, the focus lies on the operation checkCard.
4When writing this document OCL 2.4 is the OCL standard.

5.1
Restricting State Transitions Using Frame Conditions
139
B1:Building
authorized = {1}
inside =
T1:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
entry = true
T2:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
entry = false
M1:MagneticCard
id = 1
B1:Building
authorized = {1}
inside =
T1:Turnstile
greenLightOn = true
redLightOn = true
currentlyAuthorized = 1
timeOpen = 0
entry = true
T2:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = -1
timeOpen = 0
entry = false
M1:MagneticCard
id = 1
T1.checkCard(M1)
Fig. 5.4 A valid transition between two valid system states
Remember that this operation models the authentication process using the magnetic
card. If an authentication was successful (i.e., the card holder is allowed to get
access to a building), access is granted which is indicated by a green light at the
turnstile. Otherwise, no access is granted which is indicated by a red light. Who
has access to a building is stored in the attribute authorized; additionally, it
is constantly updated who is currently in a building (using the attribute inside).
An authentication process can only be started, if no other authentication process
is currently running (i.e., both greenLightOn and redLightOn are false).
This is accordingly realized in the post- and preconditions.
The three added frame conditions (self::greenLightOn, self::redLightOn, and
self::currentlyAuthorized) clearly reduce the ambiguities or variability compared
to Example 27, but open questions remain. In fact, greenLightOn and
redLightOn are restricted by an implication (in the respective postconditions).
If the premise of this implication evaluates to false, both attributes can be set
arbitrarily. For example, the operation call shown in Fig. 5.4 is valid, however, the
behavior is not really intended by the designer.
This example shows that the mindless application of frame conditions directly
leads to another severe problem: In many cases, attribute values only change
depending on a particular system state. However, frame conditions do not take this
into consideration. The precise problem with implications as recently illustrated can
be avoided using an if-then-else statement. But this would require much more effort
from the designer and it gets really uncomfortable and complicated when several
implications are used to restrict the behavior. Furthermore, it foils the principle of
declarative modeling. So, a more sophisticated deﬁnition about which changes are
allowed in an operation call is required.

140
5
Behavioral Aspects
5.1.3.2
Interpretation Semantics
Having identiﬁed the connection problem, now a way of tackling is addressed.
Similar to the frame problem in general, ﬁrst solutions how to evaluate and describe
that have been proposed in [Cab07]. Here, several heuristics for the most common
OCL operators are provided deﬁning what effect they may have on the variability
of the used model properties. This leads to a so-called interpretation semantic
providing a detailed deﬁnition which model properties are supposed to change and
under which conditions.
Example 36 In the considered example, all postconditions are implications (i.e.,
deﬁned using the OCL operator implies). According to the heuristic interpretation
semantics from [Cab07], this suggests that the following model properties are
supposed to change:
•
greenLightOn and currentlyAuthorized, iff
building.authorized-
>includes(card.id) and entry <> building.inside ->includes(card.id),
•
redLightOn, iff not ( building.authorized ->includes(card.id) ).
However, even with these heuristics the user still has to deﬁne the resulting
invariability clauses manually, e.g., as additional postconditions. Since this is time-
consuming and error-prone, automatic methods which aid the designer in the
generation of those additional constraints are desired. The recently introduced con-
cept of frame conditions does not support the usage of an additional interpretation
semantics for the evaluation as suggested in [Cab07]. To close this gap, the aim is
an approach that analyzes given pre- and postconditions of an operation in order
to automatically enforce the desired evaluation using interpretation semantics as
sketched in Example 36 and following the heuristics from [Cab07].
5.1.3.3
General Idea
In order to automatically generate constraints that enforce given interpretation
semantics, an approach which is based on the analysis of the Abstract Syntax
Tree (AST) of a given OCL constraint is proposed.
Each node of the AST represents an OCL expression and may have subtrees
as successors (representing the corresponding sub-expressions, cf. also Sect. 3.2.5).
This structure allows to explicitly employ the heuristics suggested in [Cab07]. The
proposed approach traverses the AST and checks whether heuristics are applicable.
If so, it automatically generates the resulting constraints enforcing the semantics.
For this purpose, the approach introduces two auxiliary Boolean variables for
each node, namely
1. i which represents whether the currently considered sub-expression (repre-
sented by the AST node) evaluates to true or false, and

5.1
Restricting State Transitions Using Frame Conditions
141
2.  i which represents whether the model elements used in the currently considered
sub-expression (represented by the subtree of the AST node) are supposed to
change or not.
Using the AST and these variables, the interpretation semantics can automati-
cally be enforced as sketched in the following example.
Example 37 Consider again the access control system model from Fig. 5.2.
Figure 5.5 provides the AST of the postcondition for the operation checkCard.5
This AST is divided into subtrees for every node whose expression relies on an
OperationCallExp with Boolean operands.6
Using this AST, the ﬁrst auxiliary variables are added, e.g., i with i D 1; 2; 3.
Additional constraints ensure that the assignment of i is inline with the evaluation
of the respectively considered expression (with respect to the currently considered
system state), e.g., 1 represents the evaluation of the root and-operation and, hence,
1 , 2 ^ 3. Similarly, 2 , 
f2
 and 3 , 
f3
 are enforced where

fi
 represents the evaluation of the corresponding subtree of the AST.
Next, the  i-variables representing the variability of the model elements con-
tained in the (sub)tree are added. According to the heuristics from [Cab07],
whether a model element is supposed to change its value depends on (i) the
respectively considered OCL operator and (ii) the evaluation of its sub-expression.
Both information is readily available in the AST and the corresponding i-variables.
For example, for the root node of AST, 1 ,  1 has to be satisﬁed, because the
values of model properties should be modiﬁed only when the speciﬁc operation is
called and the operation call is valid—indicated by 1 , true.
As another example (discussed before in Example 36), consider the implies sub-
expression, which is marked by '2;  2 in Fig. 5.5. The left side, marked by '4;  4,
represents the premise, which is normally not intended to be changed or change
something. This means that  4 , false and also  i , false is propagated
to all subtrees, as none of them is supposed to change. The other side of the
implication, marked with '5;  5, is only supposed to be changed, if the premise
holds, i.e., 4 , true. This means  5 , true iff 4 , true and sets generally
greenLightOn, currentlyAuthorized and card.id changeable. However,
card.id is a parameter which shall not be changed and currentlyAuthorized
saves the authorized id which should be changeable. The variables for all other
nodes are set analogously.
Following the sketched scheme, constraints are generated which avoid undesired
changes during an operation call. However, this does not entirely solve the task. In
5Since a valid call of this operation has to satisfy all postconditions, the single postconditions are
combined using an and-operator.
6Other expressions are not handled in this work. But for a complete set of rules issues such as
navigation chains have to be considered as well. Ideas for such rules have already been proposed
in [Cab07].

142
5
Behavioral Aspects
and
implies
implies
and
and
not
=
includes
j7,y7
j4,y4
j2,y2
j5,y5
j1,y1
j3,y3
j6,y6
j11,y11
j12,y12
j10,y10
j9,y9
j8,y8
̸=
=
=
includes
includes
true
true
entry
self
greenLightOn
self
currentlyAuthorized
self
redLightOn
self
inside
building
self
authorized
building
self
authorized
building
self
id
card
id
card
id
card
id
card
Fig. 5.5 Syntax tree of the operation checkCard

5.1
Restricting State Transitions Using Frame Conditions
143
fact, so far only the dependencies between i and  i have been considered, but their
connection to the (instantiated) model elements is still missing. In order to do that,
two cases are considered, namely
•
the given model does not provide frame conditions or
•
the given model is enriched by frame conditions.
The ﬁrst option is of high interest for UML/OCL models referring to the OCL 2.4
standard which in general does not have frame conditions at all. In this case, a simple
“nothing-else-changes” heuristic is applied for all model properties that do not occur
in the AST. For the remaining model properties m which do occur in the expression,
the statement
:
0
@ _
 2./
1
A )

./ D 0./

is added, where ./ is the set of all  i-variables which have to be taken into
account for the model element . It includes all  i-variables which correspond to
the smallest subtrees containing the respective model element  (and only those
ones).
In case of given frame conditions statements, only the model elements mentioned
in these statements, which are additionally found to be changeable by proposed
analysis, have to be taken into account.
Example 38 Consider again the AST from Fig. 5.5. With no additional information,
the following set of  i and the respective constraints are derived by the analysis, e.g.,
for card.id:
•
(card.id) = f 7;  8;  10;  11g
•
:. 7 _  8 _  10 _  11/ ) card.id=card.id@pre
This means that card.id can only be modiﬁed, if at least one of the respective  i
allows for this modiﬁcation. In case that at least one  i allows for the modiﬁcation,
the premise evaluates to false due to the negation and card.id stays changeable.
If
additionally
the
frame
conditions
are
given
for
greenLightOn,
currentlyAuthorized, and redLightOn, only ./-sets for these three
model properties have to be considered (all other can be ignored). For example,
card.id is directly enforced to be unchangeable by adding the respective constraints.
This results in the following  i-sets and respective constraints:
•
(greenLightOn) = f 9g
•
(currentlyAuthorized) = f 10g
•
(redLightOn) = f 12g
By design, it is impossible that both premises of the two implications eval-
uate to true. Consequently, either  9 and  10 or  12 can evaluate to true. In
the ﬁrst case, greenLightOn and currentlyAuthorized are changeable

144
5
Behavioral Aspects
while redLightOn is not changeable, and vice versa for the second case. This
behavior better ﬁts the designer’s intention, as opposed to an undesired change of
greenLightOn and redLightOn within one call.
5.1.3.4
Remarks
Above ideas based on ASTs and interpretation semantics for a useful extension
to frame conditions have been explained, however, only some basic operators were
covered, but some as, e.g., iterator expressions are still missing. These operators can
and will be covered by transforming them into the basic operators. The presented
approach can also be used to check behavior of OCL 2.4 models which per deﬁnition
do not have frame conditions. Anyway, the proposed concept is just a blueprint,
i.e., there is currently no implementation to evaluate models or their respective
constraints.
5.2
Moving on to Concurrent Behavior in the Symbolic
Formulation
So far this chapter dealt with the challenges of only one operation call per transition.
However, to model the behavior of nowadays systems, it is important to consider
more than just one operation per transition. Thus, in the following section it is
explained how concurrent operation calls can be realized with UML/OCL models.
More precisely, while some UML diagram types already provide mechanisms
to deal with concurrency, for UML/OCL models as introduced and used in the
work at hand, i.e., class diagrams, no solution for the validation and veriﬁcation
of concurrent behavior is available yet. To this end, the possible interpretations
of “concurrency” which are admissible according to the common UML/OCL
interpretation are discussed. How to address the resulting problems is described
and illustrated by means of a (new) running example. Finally, the application of the
proposed method is demonstrated.
5.2.1
Problem Formulation and Related Work
This subsection brieﬂy reviews the previous work about concurrency in general and
especially for UML/OCL and, by this, motivates the problem considered in this
section: How to verify concurrent behavior in UML/OCL models? Afterwards, a
review of the respective models for concurrent execution in general is provided.
The underlying concepts partially provide the basis for the solution proposed in the
following.

5.2
Moving on to Concurrent Behavior in the Symbolic Formulation
145
5.2.1.1
Related Work and Considered Problem
Early
deﬁnitions
of
behavioral
UML
semantics
focused
on
UML
state
machines [LMM99] due to their similarity to Harel’s Statecharts [HN96].
In [HPS13, Pel13], it has been shown how UML/SysML models whose behavior
is encoded by concurrent state machines, operation calls, and timing conditions
can be associated with a formal semantics. There, it has also been explained how
veriﬁcation by bounded model checking and automated test data generation can
be performed, if the behavioral semantics are described by means of a transition
relation in propositional form.
For the behavioral interpretation of class diagrams and their operations, existing
approaches utilize the constraints provided by the pre- and postconditions, as well
as the frame conditions given for each operation in the model, as explained, e.g., in
the last section. In order to show whether a speciﬁc behavior indeed is represented
by the model, all valid sequences of operation calls are (symbolically) checked.
If a sequence of operation calls can be determined which satisﬁes the respective
constraints and eventually leads, e.g., to previously deﬁned bad states or good states,
the erroneous or correct behavior has been shown, respectively (cf. Sect. 3.3.2). In
order to conduct these checks, various approaches have already been discussed, see
Sect. 3.4.
Most of these approaches, however, rely on a sequential behavioral interpretation.
This means that in each transition from one system state to another, only a single
operation call is considered. This contrasts with modern systems which typically
rely on the parallel execution of operation calls and, hence, concurrent behavior. To
the best of our knowledge, no comprehensive method for the validation and veriﬁ-
cation of concurrent behavior described by means of UML/OCL models consisting
of composite structures, class diagrams, and operations has been proposed yet.
A multitude of solutions for modeling concurrent designs and associated tool
support have been introduced in other formalisms outside the UML domain. Popular
tools are, e.g., FDR for the CSP process algebra [RHB97] and the more recent
mCRL2 process algebra with its tool set [GM14]. Despite their expressive power
and their noteworthy tool capabilities, however, these and similar formalisms have
the disadvantage that they do not represent industrial de-facto standards, as it is the
case for UML, SysML, and OCL.
Besides that, there exist a wide variety of tools for checking the concurrent
behavior represented in terms of
1. Harel’s statecharts (see, e.g., [HN96, LP99, KM02, Har87]),
2. variants of Petrinets (see, e.g., [Sta08]), as well as
3. graph transformations (see, e.g., [ESW07]).
Since these representations are quite similar to UML state machines (for 1.) and
UML activity diagrams (for 2. and 3.), they may, in principle, offer a solution for
checking the concurrent behavior of these UML description means. However, UML
state machines and UML activity diagrams serve an entirely different purpose than

146
5
Behavioral Aspects
the deﬁnition in terms of contracts (i.e., pre- and postconditions) considered allover
in the book at hand. In fact, they focus on implementation aspects while contracts
provide a speciﬁcation of the intended behavior.
Overall, to the best of our knowledge there is no solution available which can
automatically verify the concurrent behavior deﬁned by UML models enriched with
OCL pre- and postconditions.
5.2.1.2
Considered Computational Model
Obviously, an approach aiming for checking the behavior of a system descrip-
tion has to rely on a proper computational model. With respect to concurrency,
a signiﬁcant amount of corresponding theoretical foundations to be used have
been considered—[WN93] and [RHB97] provide good overviews of some of
them. Besides that, there are attempts to compare and classify these models
(see, e.g., [SNW96]). In case of the design by contract scheme considered here,
concurrency basically transforms to invoking and executing two or more operation
calls at once. In general, such a system is nondeterministic. Therefore, two options
for a computational model are left to be chosen from:
•
Interleaving Model: In this model, concurrently called operation calls are
executed in an “interleaved” fashion, i.e., they are executed sequentially, but their
atomic steps are executed nondeterministically. In this case, it is not possible
to split these operation calls into smaller units. In other words, one atomic
step is the execution of one operation, another atomic step is the execution of
another operation, and so on. Therefore, concurrently executing nondeterministic
operation calls in interleaving semantics result in the same state space as if they
would be executed sequentially. This model is typical for concurrent processes
on a single-core CPU.
•
Non-interleaving Model (true-parallelism): In this model, concurrently called
operation calls are executed in a “true parallel” fashion. The result is the merged
result of the concurrently executed operation calls, or a deadlock, or an illegal
racing condition if those operation calls cannot run in parallel because they
change the same attributes in contradictory ways. In case of a UML/OCL model,
two operation calls can only be executed in parallel if all their preconditions are
satisﬁed before and all their postconditions are satisﬁed after the call. Moreover,
the frame conditions of all operation calls must be considered in such a parallel
execution. This model is typical for many real-world scenarios.
In this case, considering a nondeterministic behavior, the interleaving model
results in the same state space as in sequential execution. Therefore, true-parallelism
ﬁts better for today’s complex systems which run truly parallel. Hence, the non-
interleaving model with its true-parallelism is considered in the remainder of this
section.

5.2
Moving on to Concurrent Behavior in the Symbolic Formulation
147
5.2.1.3
Supporting Concurrent Behavior
In order to validate and verify concurrent behavior deﬁned by means of UML/OCL
models, an approach which relies on the symbolic formulation for checking
(sequential) behavior is proposed. In this section, the background on the respectively
utilized approach is reviewed. Afterwards, corresponding extensions aiming to
support concurrency are introduced. While this provides a ﬁrst step towards the
desired veriﬁcation approach, further obstacles remain open. These are considered
afterwards in Sect. 5.2.2.
In the recent past, several approaches for the validation and veriﬁcation of
sequential behavioral aspects have been proposed (cf. Sect. 3.4). In this book, the
symbolic formulation for behavior relies on the solution presented in [SWD11c] and
makes use of SMT to solve the obtained symbolic formulations. The general idea is
sketched by means of Fig. 5.6 (see also Fig. 3.8) and details for the transformation
have been explained above in Sect. 3.3.2. In the last section, the transformation for a
transition between two system states has been extended to support frame conditions
(cf. Transformation 26). Since they are not a part of the OCL standard, they will
be partially ignored in the following. This makes it possible to analyze the current
problem. However, the solution itself will make usage of frame conditions.
Using this transformation, a satisfying assignment to all !i-variables must exist
if a sequence from the (possibly restricted) initial system state 0 to the (possibly
restricted) terminal system state n exists. From this assignment, the respective
operation calls for this sequence can eventually be obtained. If no such assignment
exists, it has been proven that no corresponding sequence exists.
Example 39 Consider the model of a simple counter as given in Fig. 5.7. The model
consists of one class Counter which has an integer attribute value representing the
current value of the counter and an operation count. Furthermore, one invariant
greaterZero belongs to the class which requires that the value must be always
0
1
T
. . .
0 ∈
m
1 ∈
m
T−1 ∈
m
s
w
w
w
W
W
W
s
s
Fig. 5.6 Transitions with sequential operation calls
Counter
value: Integer
void count()
context Counter::count():
post : self.value = self.value@pre + 1
post : Counter.allInstances()->forAll( c |
(self <> c) implies (c.value = c.value@pre)
)
inv greaterZero:
self.value >= 0
Fig. 5.7 A model of a simple counter

148
5
Behavioral Aspects
Fig. 5.8 A system state for
the simple counter model
Counter@0
value = 0
void count()
Counter@1
value = 0
void count()
Counter@2
value = 0
void count()
greater or equal 0. The behavior of the operation is described by a postcondition,
which requires that the value of the counter of the calling object should be increased
by one, and a postcondition, which requires that all remaining counters remain their
value. The operation count does not have explicit frame conditions as recently
introduced, but the second postcondition model acts as frame condition.
Further, let  be a system state as given in Fig. 5.8. There are three
object instantiations of the class Counter, namely Counter@0, Counter@1, and
Counter@2. As it is possible to call the operation count on each object, it follows
that ˝ D f.Counter@0; count/; .Counter@1; count/; .Counter@2; count/g.
Based on that, the resulting SMT-LIB syntax of the transition for operation call
.Counter@0; count/ can be formulated. Note that for the sake of convenience,
only the regular values will be considered in the following, i.e., no 4-valued OCL,
and integers are represented with 8 bits.
1 (=> (= omega #b00)
2
(and (=
0˛Counter0
value
3
(bvadd
˛Counter0
value
#x01))
4
(and (=> (not (= #b001 #b001))
5
(=
0˛Counter0
value
˛Counter0
value
))
6
(=> (not (= #b001 #b010))
7
(=
0˛Counter1
value
˛Counter1
value
))
8
(=> (not (= #b001 #b100))
9
(=
0˛Counter2
value
˛Counter2
value
)) ) ) )
The ﬁrst line realizes the left-hand side of the implication sketched in Eq. (5.2)—
assuming that 00 is the unique identiﬁer r˝.!/ representing the operation
.Counter@0; count/. Afterwards, the postconditions (which inherently also
represent the frame condition) of the operation are enforced (see Line 2–4
and Line 5–13). Hereby, the system states are represented by the assignments
to the respective attributes of the instantiated classes. For example, the value
of the attribute value of the object instance Counter@0 is represented by
State0::Counter0::value and State1::Counter0::value for the
initial system state and the succeeding system state, respectively. Based on that,
the ﬁrst postcondition (deﬁning the increase of the value) is enforced by the SMT
constraint in Line 2–4. The other postconditions are realized in a similar fashion.
The approach used for behavioral aspects so far obviously does not support the
consideration of concurrent behavior. In fact, due to the construction in Transforma-
tion 23 and 26 the symbolic formulation (and also the SMT-LIB realization) allows
for the execution of a single operation call per transition only. In order to extend this
concept accordingly, a revised formulation has to be applied.

5.2
Moving on to Concurrent Behavior in the Symbolic Formulation
149
0
1
T
. . .
0 :
m →B
1 :
m →B
T−1 :
m →B
s
s
s
w
w
w
W
W
W
Fig. 5.9 Transitions with concurrent operation calls
Figure 5.9 sketches the general idea of such an extended formulation. Again,
a symbolic representation of all possible sequences of system states (denoted
by 0; 1; : : : ; n and bounded by n 2 N) is considered. But instead of having a
variable !i W f0; 1; : : : ; j˝mj  1g which symbolically represents a single operation
call triggering the transition from i to iC1 (as in Fig. 5.6), now the type is changed
as follows: !0W ˝m 7! B. Obviously, the map makes it possible to apply more
than just one operation call. If the map evaluates to true for an operation, then
the operation call is executed in the ith transition. Moreover, the total number of
concurrent operation calls can be restricted by limiting the number of operation
calls which evaluate to true.
Overall, this leads to the extended symbolic formulation of a transition as
follows:
Transformation Rule 32 Let  and 0 be two (un-assigned) succeeding system
states of a model m. Further, let ˝m D f!0; !1; : : : ; !j˝mj1g be the set of all
possible operation calls which can be called in . Then, the transition variable
from Transformation 23 is changed to: !0W ˝m 7! B. Now, concurrent operation
calls whose parallel execution—conducted in a true-parallelism fashion—can be
conducted using the following equation instead of Eq. (3.11):
^
!2˝
.!!0.!// )
0
BB@
ˇc./ D true
^ C;fself7!g
m
D .✓; true/
^ B;0;fself7!g
m
D .✓; true/
1
CCA
(5.6)
Moreover, by additionally enforcing
d1 
X
!2˝
!!0.!/  d2
(5.7)
with d1; d2 2 N and d1  d2, it is possible to restrict the number of concurrent calls
to be between d1 and d2.
SMT-LIB Realization of Transformation Rule 32. The variables !!0W ˝m 7!
B are realized with bit vector variables of length j˝mj. Then, each bit indicates
whether the respective operation call is executed or not, this is illustrated in
Fig. 5.10. Since the constraints are still the same and the double inequality for the
restriction is straightforward, details are omitted.
Again, if the resulting formulation leads to a satisfying assignment to the
!!0 variable, the existence of a sequence of corresponding operation calls has
been proven. In contrast to the previous formulation, this sequence now may include

150
5
Behavioral Aspects
0
1
...
n
0[0]
0[1]
...
0[|
|−2]
0[|
|−1]
1[0]
1[1]
...
1[|
|−2]
1[|
|−1]
n−1[0]
n−1[1]
...
n−1[|
|−2]
n−1[|
|−1]
s
s
s
w
w
w
w
w
w
w
w
w
w
w
w
W
W
W
W
W
W
Fig. 5.10 Transitions with concurrent operation calls using SMT
concurrent operation calls in one transition. More precisely, two operations !; !0 2
˝ .! ¤ !0/ are executed in parallel iff both !!0.!/ and !!0.!0/ are assigned
1 by the SMT solver.
While this provides a simple solution to support concurrent behavior in the
validation and veriﬁcation of UML/OCL models, it does not consider that operations
may have contradictory effects and, hence, provoke conﬂicts in the succeeding
system state. The following example illustrates the resulting problem:
Example 40 Consider again, the simple counter model from Example 39. Follow-
ing the extended formulation, the resulting SMT syntax of the transition with respect
to the operation call .Counter@0; count/ reads as follows:
1 (=> (= ((_ extract 0 0) !!0) #b1)
2
(and (=
0˛Counter0
value
3
(bvadd
˛Counter0
value
4
#x01))
5
(and (=> (not (= #b001 #b001))
6
(=
0˛Counter0
value
˛Counter0
value
))
7
(=> (not (= #b001 #b010))
8
(=
0˛Counter1
value
˛Counter1
value
))
9
(=> (not (= #b001 #b100))
10
(=
0˛Counter2
value
˛Counter2
value
)) ) ) )
As the interest is a concurrent execution of operation calls, additionally also
the resulting SMT formulation for the operation call .Counter@1; count/ is
considered in detail:
1 (=> (= ((_ extract 1 1) !!0) #b1)
2
(and (=
0˛Counter1
value
3
(bvadd
˛Counter1
value
4
#x01))
5
(and (=> (not (= #b010 #b001))
6
(=
0˛Counter0
value
˛Counter0
value
))
7
(=> (not (= #b010 #b010))
8
(=
0˛Counter1
value
˛Counter1
value
))
9
(=> (not (= #b010 #b100))
10
(=
0˛Counter2
value
˛Counter2
value
)) ) ) )

5.2
Moving on to Concurrent Behavior in the Symbolic Formulation
151
Both sets of constraints enforce that, when the respective operations are called
(represented by setting the 0th and the 1st bit of bit vector !!0 to #b1), (1) the
attribute value of the respective object is increased by one and (2) the values of
all remaining attributes remain unchanged. This obviously leads to a conﬂict: An
attribute cannot be increased by one and, at the same time, keep its value. While
this is in accordance with the postconditions of the model as shown in Fig. 5.7, it
requires an explicit handling of contradictory conditions.
Consequently, only extending existing approaches for validation and veriﬁcation
of sequential behavior does not lead to satisfactory solutions addressing the “con-
current case.” Similar problems would occur, if frame conditions have been used for
each possible operation calls. Instead, a further analysis on possible contradictions
of operation contracts has to be conducted for each model. The result of such
an analysis eventually has to be incorporated into an accordingly revised SMT
formulation. How this can be accomplished is covered in the next section.
5.2.2
Handling Contradictory Conditions
Conditions deﬁned in contracts (by means of postconditions or frame conditions)
are supposed to completely describe the effect of an operation. As illustrated in the
previous example, this often also affects model elements which are not really in the
scope of a particular operation. For example, the operation .Counter@0; count/
could entirely focus on the attribute value of object Counter@0. But, in order to
avoid arbitrary changes to attributes from all the other objects, the postcondition
additionally restricts value from Counter@1 and Counter@2:7
As illustrated in Example 40, this constitutes a problem. In fact, when several
operation calls are executed in parallel it indeed might be acceptable to reduce the
scope of the conditions. In other words, postconditions denying undesired changes
or frame conditions of a single operation do not necessarily have to cover all model
elements—in particular when another (concurrently executed) operation call already
covers those elements anyway.
In order to address this, a modeling scheme is assumed in the following in which
the resulting frame conditions of all operation calls are meaningfully joined. More
precisely, for all model elements where no executed operation call modiﬁes them, a
“nothing else changes”-assumption is employed.
Example 41 Consider again the example from Fig. 5.7. Following the “nothing else
changes”-assumption, this model can be deﬁned as shown in Fig. 5.11. Here, the
postcondition only restricts the attribute of the respectively calling object and the
frame condition indicates that this operation will only effect this model element.
All other attributes are assumed to keep their value (except another operation is
restricting it).
7Note that, instead of a postcondition, also a frame condition modifies only: self::value
could have been applied for this purpose.

152
5
Behavioral Aspects
Fig. 5.11 Modiﬁed model of
a simple counter
Counter
value: Integer
void count()
inv greaterZero:
self.value >= 0
context Counter::count():
post : self.value = self.value@pre +1
modifies only : self::value
Following this assumption, it remains open to symbolically represent which
model elements are affected by an arbitrary combination of concurrent operation
calls. The values of all these model elements are already deﬁned by the conditions of
these operations. For all remaining model elements, constraints have to be employed
which ensure that their values are not supposed to change during the transition. To
this end, the variability maps are reused, but their application is modiﬁed, i.e., the
connecting constraints must be changed.
Transformation Rule 33 (Reuse of Existing Transformation Rules for Concur-
rency) As done in Transformation 24, the impact of which model elements are
allowed to change their value is done by frame conditions for each operation call
on a transition. Again, three different types of variability maps V from m./ to B
are created. If V ./ evaluates to true, then the value of the model element  is
variable during the operation call ! from the system state  to 0. Otherwise, it is
not allowed to change its value.
To enforce that an instantiated model element does not change its value
for a given transition, Transformation 25 is applied with its changes given in
Transformation 30 for attributes and Transformation 29 with its changes given in
Transformation 31 for associations, simply spoken ˛=
name. Q/ D 0˛=
name. Q/.
Likewise, Transformation 28 is applied to propagate the impact of a single frame
condition to all V!;f .
Transformation Rule 34 (Modiﬁcations of Existing Transformation Rules for
Concurrency) For concurrency, one must distinguish between an executed and a
not executed operation call, thus, Eq. (5.6) must be changed to:
^
!2˝
.!!0.!// )
0
BBBBBBBB@
ˇc./ D true
^ C;fself7!g
m
D .✓; true/
^ B;0;fself7!g
m
D .✓; true/
^ 8  2 m./ W
V!./ D
_
f2F!
V!;f ./
1
CCCCCCCCA
(5.8)
^
!2˝
.!!0.!/ D false/ )

8  2 m./ W V!./ D false

(5.9)

5.2
Moving on to Concurrent Behavior in the Symbolic Formulation
153
Table 5.1 Bit-masks for a transition
Model element 
Counter@0
Counter@1
Counter@2
Operation call !
::value
::value
::value
(Counter@0,count)
V! D
true
false
false
(Counter@1,count)
V!0 D
false
true
false
(Counter@2,count)
V!00 D
false
false
false
V D
true
true
false
The last two equations together ensure that a valid assignment for each V! map
is either indicating that all model elements are not allowed to change or that the
frame conditions are respected. However, the (modiﬁed) connection between the V
and V! maps is missing:
^
2m./
 
V ./ D
 _
!2˝
V!./
!!
:
(5.10)
The last equation ensures that an instantiated model element is variable, iff at least
on operation call allows for it.
Example 42 Consider again the example from Fig. 5.11 with three instances of
class Counter denoted by Counter@0, Counter@1, Counter@2. Additionally
assume a transition in which two operations !; !0
2
˝
with !
D
.Counter@0; count/ and !0 D .Counter@1; count/ are called. Then, Table 5.1
shows the resulting bit-masks b!, b!0, b!00 for each operation. From this, it can
be concluded that, in this transition, the model elements Counter@0::value
and Counter@1::value are affected (and, hence, restricted by the respective
constraints from Transformation 25, 30, 29, and 31), while the model element
Counter@3::value is supposed to keep its value.
From satisfying assignments, respective results can be determined as already
discussed for the formulations before. Again, the SMT-LIB realization is straight-
forward and, thus, precise details are omitted, however, an example will illustrate
the realization.
Example 43 Consider again the example from Fig. 5.11 with its three instances
of class Counter as well as the transition from a system state represented by 
to a succeeding system state represented by 0 in which the operation calls
.Counter@0; count/ and .Counter@1; count/ are called. Following the new
formulation, the resulting SMT-LIB syntax of this transition with respect to the
operation .Counter@0; count/ reads as follows:
1 (=> (= ((_ extract 0 0) !!0) #b1)
2
(and (=
0˛Counter0
value
3
(bvadd
˛Counter0
value

154
5
Behavioral Aspects
4
#x01))
5
(= V! #b001)))
6 (=> (= ((_ extract 0 0) !!0) #b0)
7
(= V! #b000))
8
9 (= V
(bvor V! V!0 V!00))
10 (=> (= ((extract 0 0) V ) #b0)
11
(=
0˛Counter0
value
˛Counter0
value
))
12 (=> (= ((extract 1 1) V ) #b0)
13
(=
0˛Counter0
value
˛Counter1
value
))
14 (=> (= ((extract 2 2) V ) #b0)
15
(=
0˛Counter0
value
˛Counter2
value
))
The constraint in Line 5 is in general much more complex, depending on the precise
frame condition.
Overall, the resulting formulation allows for automatically checking the con-
current behavior of UML/OCL models. The problems discussed above have been
solved by using the variability maps from Sect. 5.1 again and adding special
constraints between the three different variability map types.
5.2.3
Implementation and Application
In order to apply the proposed solution, the methodology described in this section
has been implemented as an Eclipse plugin using both, Java and Xtend. As solving
engine, again Z3 has been used to verify and validate UML/OCL models. Using the
resulting implementation, the concurrent behavior of UML/OCL models following
the design by contract scheme can be checked. In this subsection, the application of
the resulting tool is illustrated by means of an example.
5.2.3.1
Considered Model
In order to illustrate the application, a model of an international banking system
in which money may concurrently be deposited into an account, withdrawn from
an account, and transferred between accounts is considered. The UML/OCL model
and its OCL constraints are shown in Fig. 5.12. The system consists of three classes:
Person, Account, and Bank. Every Person has an age and can have multiple accounts
by different banks. The account has attributes for its International Bank Account
Number (iban), which identiﬁes the account in the international banking system,
and the current account balance amount. An account is always provided by a bank.
Every Bank has a unique Business Identiﬁer Code (bic). In this model, bic and
iban are represented by a unique positive number. In addition, the class Account
has the following operations:

5.2
Moving on to Concurrent Behavior in the Symbolic Formulation
155
Person
age: Integer
Account
iban: Integer
amount: Integer
depositCash(pAmount: Integer): void
withdrawCash(pAmount: Integer): void
transfer(
pAmount: Integer,
recipientIBAN: Integer,
recipientBIC: Integer
): void
Bank
bic: Integer
1..* holder
*
accounts
1 bank
*
accounts
context Person:
inv : age > 0
context Bank:
inv : bic > 0
inv : Bank.allInstances()->forAll( bank |
(self <> bank)
implies (self.bic <> bank.bic)
)
inv : Bank.accounts()->forAll( b1, b2 |
(b1 <> b2)
implies (b1.iban <> b2.iban)
)
context Account:
inv : iban > 0
inv : holder->exists(
h | h.age >= 18
)
context Account::depositCash(pAmount: Integer):
pre : pAmount > 0
post : self.amount = self.amount@pre + pAmount
modifies only : self::amount
context Account::withdrawCash(pAmount: Integer):
pre : pAmount > 0
post : self.amount = self.amount@pre - pAmount
modifies only : self::amount
context Account::transfer(
pAmount: Integer,
recipientIBAN: Integer,
recipientBIC: Integer
) :
pre : pAmount > 0
pre : Account.allInstances()->exists( a |
a.iban = recipientIBAN
and a.bank.bic = recipientBIC
)
post : self.amount = self.amount@pre - pAmount
post : Account.allInstances()->select( a |
a.iban = recipientIBAN
and a.bank.bic = recipientBIC
)->forAll( a |
a.amount = a.amount@pre + pAmount
)
modifies only : self::amount
modifies only : Account.allInstances()->select( a |
a.iban = recipientIBAN
and a.bank.bic = recipientBIC
)::amount
Fig. 5.12 Considered model
•
depositCash: A person can call this operation to deposit money at the bank.
The current balance is increased by the amount given by the parameter (which
has to be a positive number).
•
withdrawCash: A person can call this operation to withdraw cash. The current
balance of the account is decreased by the amount given by the parameter (which
has to be a positive number).
•
transfer: A person can call this operation to transfer money from his/her
account to another account. The recipient account is identiﬁed by its iban and
the corresponding bic. The current balance of the account calling this operation
is decreased by pAmount, while the account of the recipient is increased by this
amount.
For our evaluation, an instantiation of this model composed of one bank and ﬁve
persons with each of them having one account at the bank is analyzed. Furthermore,
one transition with at most ﬁve concurrent operation calls is considered.
5.2.3.2
Application
Using the proposed methodology, various checks can be conducted for the consid-
ered model. These checks can be divided into two classes: universal and problem
speciﬁc checks. As a typical example for a universal check, it has been validated
that the considered conﬁguration does not run into deadlocks, i.e., if a valid initial

156
5
Behavioral Aspects
Account@0
iban = 1
amount = 16
Account@1
iban = 2
amount = 17
Account@2
iban = 3
amount = 22
Account@3
iban = 5
amount = 23
Account@4
iban = 9
amount = 27
Person@0
age = 18
Person@1
age = 19
Person@2
age = 22
Person@3
age = 54
Person@4
age = 72
Bank@0
bic = 42
Account@0
iban = 1
amount = 22
Account@1
iban = 2
amount = 27
Account@2
iban = 3
amount = 12
Account@3
iban = 5
amount = 11
Account@4
iban = 9
amount = 17
Person@0
age = 18
Person@1
age = 19
Person@2
age = 22
Person@3
age = 54
Person@4
age = 72
Bank@0
bic = 42
(Account@0,depositCash(6))
(Account@1,depositCash(10))
(Account@2,trans fer(10,2,42))
(Account@3,withdrawCash(12))
(Account@4,trans fer(10,2,42))
Fig. 5.13 Considered sequence
state is assumed, no sequence of transitions exists that leads to a system state
out of which no further operation calls are possible anymore. In order to check
that, the symbolic formulation proposed above for a total of 50 transitions has
automatically been generated with additional constraints for the terminal state 50.
Afterwards, the resulting formulation was passed to Z3 which proved that no
satisfying assignment exists for this instance. From this result, it can be concluded
that no deadlock state can be reached from an arbitrary (but valid) system state
within 50 transitions. In addition to previously conducted consistency checks and
by following k-induction [SSS00], this allows for the conclusion that the behavior
of the considered model is free of deadlocks.
On the other side, also model (or problem) speciﬁc checks can be applied. For
the given banking system such a check would be, e.g., that the overall amount of
money with respect to deposits and withdrawals stays the same. Executing this
check, the sequence as shown in Fig. 5.13 has been obtained. Five concurrent
operation calls are conducted there. The upper part of Fig. 5.13 shows the obtained
(arbitrary but valid) initial system state, while the bottom shows the resulting state
of the transition when the ﬁve operation calls depicted in the middle of Fig. 5.13
are invoked. Although all constraints of the model are satisﬁed by this sequence,
it is very likely that this does not represent the desired behavior: This is because

5.2
Moving on to Concurrent Behavior in the Symbolic Formulation
157
Person@2 and Person@4 transfer 10 money units to the account of Person@1, and
Person@1 additionally deposits another 10 money units to his account, but the total
value of Person@1::amount increases by 10 only.
Due to the problem speciﬁc check, the designer has been pin-pointed to a serious
modeling error which can easily be ﬁxed afterwards in a manual fashion. In this
particular case, the designer could, e.g., add auxiliary variables for critical sections
to model locking mechanisms or add postconditions which avoid different amounts
of the overall money.
Using the methodology proposed here, all these checks can automatically be
conducted within negligible run-time on a modern computer (i.e., less than a second)
and, hence, provide useful aid to the designers of such models.

Chapter 6
Timing Aspects
The previous chapters have presented a symbolic representation and on top of
that different extensions for the validation and veriﬁcation of structural as well
as behavioral aspects of models. However, apart from modeling these two aspects,
system design consists of lots of specialized problems, e.g., timing or power con-
sumption. Developing dedicated modeling tools for each of these problems would
be cumbersome, impossible to keep compatible to each other, and unaffordably
expensive. But the approaches introduced in the previous chapters can be utilized
to also handle those specialized problems. In this chapter, timing constraints will be
used as an example to show how the methods from above can be used to cope with
a very specialized topic, i.e., timing, re-using the symbolic representation with its
extensions.
To this end, we ﬁrst need to review how timing can be described in a UML/OCL-
like fashion. In fact, in UML2 it is possible to deﬁne proﬁles to extend the language
to be able to address nearly all kinds of speciﬁc topics. One example is the Modeling
and Analysis of Real-time and Embedded systems (MARTE) [Obj11] proﬁle to
support model-driven development (for real-time embedded systems). Along with
the growing impact of modeling on the general domain of system design, especially
the inﬂuence of specialized proﬁles such as MARTE is steadily increasing during
the last decades. Within MARTE, the Clock Constraint Speciﬁcation Language
(CCSL) [Obj11] provides a formal description of timing constraints, also called
clock constraints, which have to be enforced on the considered system. This chapter
considers the speciﬁcation of timing behavior using MARTE/CCSL.
Timing is an essential part of a speciﬁcation and particularly of interest in all
cases where the question “when?” is asked. Specifying timing behavior is complex,
because it needs to provide a clear deﬁnition of time, clocks to access time, and
relations between all of them. MARTE/CCSL allows for a precise speciﬁcation
of all those timing aspects in complex systems. This builds the basis for the next
design steps and can be used, e.g., to, ﬁrst, check whether the timing constraints are
consistent, plausible, and indeed have been speciﬁed as intended, second, generate
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8_6
159

160
6
Timing Aspects
code which actually realizes the desired timing behavior, as well as, third, proving
whether the time constraints have correctly been implemented at lower abstraction
levels. In the recent past, very powerful and complementary methods addressing
these tasks have been proposed, e.g., in [MY12, SY12, YML11, AMD10, PWD14].
These methods, however, usually rely on a translation and interpretation of the
CCSL descriptions in some different computational model or language. Generating
this is a laborious and, at the same time, highly critical task in which any error
will spoil the validity of the respective results. Thus far, researchers approached this
challenge by providing translation schemes for single application scenarios only. For
example, checking CCSL as introduced in [MY12, SY12, YML11, AMD10] relies
on a direct encoding of the constraints, e.g., into Promela- or UPPAAL-syntax. Code
generation as proposed in [PWD14] directly creates SystemC code. That is, for each
design task usually a different translation and interpretation of CCSL constraints is
applied—although all of them eventually shall rely on the same semantics.
Moreover, in most of the existing approaches, the non-functional behavior of
the system is not explicitly considered. This constitutes a signiﬁcant drawback
since, e.g., methods such as [LLH05, CCR09, GogC14, EQF12, WilC13] which are
aiming for proving the correctness of corresponding models do not support CCSL
constraints. Vice versa, CCSL checkers as introduced in [MY12, SY12, YML11,
AMD10] do not consider the functional behavior. That is, functional and timing
constraints are usually checked independently of each other. Consequently, design
ﬂaws caused by the combination of both constraints are often not considered before
an initial implementation is available. Other design tasks such as code generation
similarly suffer from the current state-of-the-art: For example, the realization of
CCSL timing constraints in SystemC as described in [PWD14] relies on the fact
that the entire functional description of the system is already implemented.
Overall, the “inﬂation” of solutions for rather speciﬁc design tasks and, at the
same time, their inability to combine them with tools for functional code generation
and veriﬁcation signiﬁcantly limits the application of CCSL timing constraints in
practice.
Therefore, after Sect. 6.1 provides preliminaries about MARTE/CCSL, Sect. 6.2
aims for a generic representation of the CCSL constraints which (1) can be used
for various purposes such as veriﬁcation, code generation, and, moreover, (2) can
easily be integrated and merged with corresponding representations of the functional
behavior of the system under consideration. To this end, a transformation scheme
is proposed which takes CCSL constraints and maps those into an equivalent
representation in terms of a transition relation (or in other words an automaton).
Afterwards, the resulting transition relation can easily be integrated into the existing
solutions for design tasks as described in previous chapters (using the ﬁndings
from [PetC15]).
In Sect. 6.3, instant relations as an additional description mean of the CCSL
are introduced. Instead of using instant relations for monitoring purposes only, the
constraints (derived from the instant relations) are considered as properties to be

6.1
Preliminaries About Clocks and Ticks
161
satisﬁed by the clock constraints. Based on this interpretation, a methodology is
introduced (based on [PetC16]) which is capable of verifying clock constraints
against the given instant relations. To this end, the timing behavior is again repre-
sented in terms of an automaton followed by its veriﬁcation through satisﬁability
solvers. By this, a veriﬁcation scheme becomes available which is capable of
checking whether the timing behavior of a system has been speciﬁed in CCSL as
intended. A case study illustrates the application of the proposed methodology.
6.1
Preliminaries About Clocks and Ticks
Like for the UML/OCL models (i.e., class diagrams for this book) a formal
deﬁnition of the CCSL is needed to apply formal methods. Consequently, this
subsection aims to formally deﬁne the constructs of the CCSL time model. A
central part of the underlying time deﬁnition are instants, i.e., moments in the raw,
unordered time, deﬁned by clock ticks. The clock is an instrument to access a set of
instants [AM08].
Remark 9 Note that some of the symbols and notations which are used in the
section are shared with the UML/OCL model notations. However, from the context
it will be always clear which interpretation is utilized for a symbol with a double
meaning.
Deﬁnition 6.1 A clock c D hI ; ; D; ; ui consists of a set of instants I , which
owns a quasi-order relation , a set of labels for the instants D, a labeling function
, and a unit u for the clock ticks. A ﬁnite clock has a ﬁnite number of ticks. If no
ticks are left, the clock is empty. A clock c1 D hI1; 1; D1; 1; ui is a subclock of
another clock c2 D hI2; 2; D2; 2; ui, if I1 
 I2.
This deﬁnition shall be illustrated with the following example:
Example 44 Consider a sensor which can perform measurements at certain
times. The time steps to perform a measurement can be described using the
clock sensor1. They form a set of instants of the clock which are illustrated
by dots at the time line shown in Fig. 6.1. Every instant represents a clock tick.
These ticks represent time steps in which a measurement may be conducted. The
sensor1
3
4
5
6
sample3
sample4
sample5
sample6
Fig. 6.1 An exemplary time line of a clock sensor1

162
6
Timing Aspects
1 ClockConstraintSystem sensors {
2
Clock minClock;
3
Clock sensor1;
4
Clock sensor2;
5
Clock echo is sensor1 delayedBy 1;
6
7
sensor2 # echo;
8
sensor1 isPeriodicOn minClock period 1.0;
9
sensor2 isPeriodicOn minClock period 1.0;
10 }
Listing 6.1 A CCSL speciﬁcation
order of the instants on the line is speciﬁed by sensor1. Finally, the time steps in
which a measurement does actually take place are labeled by a corresponding ID
(in Fig. 6.1, denoted below the dots representing the instants).
In general, clocks can be logical or chronometric [Obj11]. Logical clocks can
refer to discrete events like processor cycles or sensor data, while chronometric
clocks refer to physical time and can also be dense. In this section, discrete clocks
are considered. From the clocks, a time structure can be derived [AM08]:
Deﬁnition 6.2 A time structure is a pair hC ; 4i, where C is a set of clocks and 4
is a binary relation on S
c2C
Ic named precedence (one clock tick takes place before
or coincidentally with the other). From 4, some further relations can be derived to
specify instant behavior.
These instant relations affect the instants to which they are referring to, but not
the rest of the instants of the clock. In contrast, if instant relations are deﬁned for
all instants of the clock, they become clock relations (or clock deﬁnitions, in terms
of CCSL). These clock relations constrain the complete behavior of the clocks. An
illustration of clock relations is given in the following example. A complete list of
clock constraints can be found, e.g., in [Obj11].
Example 45 Consider a system with two sensors triggered by the clocks sensor1
and sensor2. Both sensors have to reply in every second step with respect to a
third (minimal) clock minClock. From its second reply on, sensor1 causes an
echo interfering with the signal of sensor2. Hence, this echo and the reply of
sensor2 are not allowed to occur coincidentally. This is described in the CCSL
speciﬁcation in Listing 6.1.
At the beginning, the clocks are deﬁned (Lines 1–5). Clock echo in Line 5 is
deﬁned as a subclock of sensor1. Both tick together, but echo starts one tick after
sensor1. Afterwards, the clock relations are applied. Line 7 states the exclusion
of echo and sensor2, while Lines 8 and 9 deﬁne the periodicity of sensor1
and sensor2 on minClock.

6.2
A Generic Representation of CCSL Constraints
163
6.2
A Generic Representation of CCSL Constraints
Description means as the clock constraints described above allow for a very precise
speciﬁcation of the timing behavior for a system to be realized. The resulting
formal descriptions can already be utilized to automatically perform design tasks
such as consistency checking, code generation, or veriﬁcation. For this purpose, a
variety of solutions have been proposed in the recent past [MY12, SY12, YML11,
AMD10, PWD14]. A typical step involved in most of these approaches consists
of transforming the given speciﬁcation or a part thereof into a corresponding
representation such as Promela, SystemC, etc. The ﬁrst goal of this section is to
represent the non-functional timing constraints (provided in CCSL) in terms of a
more generic representation which is applicable to existing design approaches for
the tasks mentioned above but can also easily be integrated to solutions addressing
only functional behavior thus far.
The idea of the proposed representation is to model the timing behavior by means
of so-called ticking sets. A ticking set describes all clocks c 2 C which can tick in
a certain time step. Clocks that are not included in a ticking set will not tick in
the respective time step. Relying on such a description, the entire timing behavior
can be represented as a sequence of ticking sets: Each ticking set constitutes a
state; transitions allow for moving from one state to another in accordance with
the constraints originally provided in CCSL. For this purpose, transitions may have
guard conditions over global variables (such as counters for periodic behaviors)
which state whether a transition may be taken or not. The values of these global
variables may be changed during a transition by means of update functions. The
given CCSL constraints shall be represented in terms of a transition relation given
by an automaton A deﬁned as follows.
Deﬁnition 6.3 Let C be a set of clocks given by a CCSL speciﬁcation. Further-
more, let V be a set of global variables1 used to store additional information (e.g.,
counters) and V an assignment of them. In order to evaluate conditions derived
from the CCSL constraints, a guard function g is applied which maps the current
assignment V to either true or false. the values of V . Then, the behavior of the
clocks according to a given CCSL speciﬁcation can be represented by an automaton
A D .˙; S0; V ; V0; ı/ where
•
˙ 
 P.C / are the states referring to possible ticking sets,
•
S0 
 ˙ are the initial states,
•
V is a set of global variables,
•
V0 is an initial assignment of V , and
•
ıW 
g;u
7! 0 is a relation representing all transitions from a source state  2 ˙ to
a target state 0 2 ˙ with guard condition g and update function u.
1For the sake of clarity, a precise deﬁnition, e.g., of the domain of a variable v 2 V
is omitted
here, but will be provided later in Sect. 6.2.1.

164
6
Timing Aspects
1 A isPeriodicOn B
2
period 2.0;
(a)
{B}
{A,B}
g: (cA = 2)∨¬dA
u: (cA = 0)∧(dA = true)
g : cA < 2
u : cA ++
g : cA < 2
u : cA ++
V0 = (cA = 0,dA = false)
(b)
Fig. 6.2 Generic representation. (a) CCSL constraints. (b) Corresponding automaton
Obviously, a transition can be used only if the guard function evaluates to true.
Example 46 Figure 6.2a shows a CCSL constraint deﬁning the timing behavior of
two clocks A and B being periodic. A corresponding transition relation representing
this timing behavior is provided by the automaton shown in Fig. 6.2b. More
precisely, from the periodicity of A on B one can conclude that A is a subclock
of B, i.e. A can never tick alone. Hence, the set ˙ of states to consider is composed
of the ticking sets {B} and {A,B} only. In addition to that, a counter variable cA
and a Boolean variable dA are utilized in order to buffer the actual period as well
as to monitor whether A has already ticked. Relying on the assignments of these
variables, the transitions ı between the respective ticking sets can be conducted as
indicated in Fig. 6.2b.
6.2.1
Determining the Generic Representation
While the generic representation as recently introduced allows for manifold appli-
cations, a structured approach is required to automatically determine this automaton
from given CCSL constraints. This section outlines a possible scheme for this
purpose. A discussion of the beneﬁts and drawbacks as well as an exemplary
evaluation of the proposed approach is later provided in Sect. 6.2.2.
6.2.1.1
Initializing the Automaton
First, an initial structure for the automaton is created, i.e., an initial set of states
which may have to be considered is generated. A clock c 2 C may either tick solely
or in conjunction with one or more other clocks. Hence, in the worst case, for each

6.2
A Generic Representation of CCSL Constraints
165
possible subset of clocks, an own state may be required.2 Additionally, it is assumed
that, in each state, at least one clock is supposed to tick, i .e., there is no “empty”
state. Overall, this leads to an initial set ˙ of states formed over the power set of all
the clocks in C :
˙  P.C / n f;g:
In a similar fashion, it is initially assumed that an arbitrary clocking behavior
is allowed and, thus, a transition from each ticking state to any other ticking state
is possible. Guard conditions and update functions are initially assumed to always
evaluate to true and to employ the identity, respectively:
ı  f
g;u
7! 0 j ; 0 2 ˙; g.V/ D true; u D idVg
Hence, the automaton is initialized as a complete graph over the power set of all
clocks in C .
Example 47 In the remainder of this section, the necessary steps are illustrated by
means of the CCSL constraints given in Listing 6.1. This speciﬁcation of timing
behavior is composed of the clocks C
D fsensor1; sensor2; minClock;
echog, leading to a set ˙ composed of 15 states for the desired automaton. Each
state is connected to all of the remaining states eventually leading to the initial
structure as shown in Fig. 6.3a. Note that the names of the clocks have been shorted,
i.e., sensor1, sensor2, minClock, and echo have been abbreviated by s1,
s2, mC, and e, respectively.
6.2.1.2
Applying Constraints
Once the initial structure of the automaton is generated, the constraints are applied
to it. For every CCSL constraint, it is checked whether it states a subclock relation
(denoted by 
) between two clocks. For all clocks c1; c2 2 C with c1 
 c2, all
states containing the subclock but not the superclock are removed. This means, the
set of states is adjusted for each c1 
 c2 as follows:
˙  ˙ n fs 2 ˙ j c1 2 s ^ c2 … sg
Furthermore, states containing two clocks excluding each other (denoted by #)
are removed. Hence, for all clocks c1; c2 2 C with c1#c2 the set of states is adjusted
as follows:
2Note that, in many cases, the number of states to be considered can already be restricted at the
very beginning. As an example, it is already obvious from the CCSL constraints in Fig. 6.2a and
discussed in Example 46 that only two states are required. However, in order to keep the following
descriptions generic, such cases are not explicitly discussed in the following.

166
6
Timing Aspects
mC
s1
s2
e
mC, s1
mC, s2
mC, e
s1, s2
s1, e
s2, e
mC, s1,
s2
mC, s1,
e
mC, s2,
e
s1, s2,
e
mC, s1,
s2, e
mC
s1
s2
e
mC, s1
mC, s2
mC, e
s1, s2
s1, e
s2, e
mC, s1,
s2
mC, s1,
e
mC, s2,
e
s1, s2,
e
mC, s1,
s2, e
(a)
mC
mC,s1
mC,s2
mC,s1,e
mC,s1,s2
(b)
mC
mC,s1
mC,s2
mC,s1,e
mC,s1,s2
(c)
mC
mC,s1
mC,s2
mC,s1,e
mC,s1,s2
(d)
mC
mC,s1
mC,s2
mC,s1,e
mC,s1,s2
1
2
3
4
5
6
7
8
9
10
11
12
13
V0 = (cs1 = 0, ds1 = false,cs2 = 0, ds2 =
false, ce = 0)
1⃝g: ((cs1 = 1)∨¬ds1)∧(cs2 < 1)
u: (cs1 = 0)∧(ds1 = true)
∧(cs2 ++)∧(ce ++)
2⃝g: (cs1 < 1)∧((cs2 = 1)∨(¬ds2))
∧(ce < 1)
u: (cs1 ++)∧(cs2 = 0)∧(ds2 = true)
3⃝g: ((cs1 = 1)∨¬ds1)∧(cs2 < 1)
u: (cs1 = 0)∧(ds1 = true)∧(cs2 ++)
4⃝g: (cs1 < 1)∧(c1 < 1)
u: (cs1 ++)∧(cs2 ++)
. . .
(e)
Fig. 6.3 Determining the generic representation. (a) Initial structure of the automaton. (b) Apply-
ing subclock constraints. (c) Removing transitions. (d) Determining initial states. (e) Reﬁning
guard conditions and update functions

6.2
A Generic Representation of CCSL Constraints
167
˙  ˙ n fs 2 ˙ j c1 2 s ^ c2 2 sg
Obviously, the ingoing and outgoing transitions of all dropped states are removed
as well.
Example 48 In the considered example, the constraints isPeriodicOn and
delayedBy indicate subclock relations (see Lines 5, 8, and 9 in Listing 6.1),
i.e., the periodic clocks sensor1 as well as sensor2 are both subclocks of
minClock and echo is a subclock of sensor1. Hence, all states containing
sensor1 or sensor2 but not minClock as well as all states containing echo
but not sensor1 are removed. Moreover, the clocks echo and sensor2 exclude
each other (see Line 7 in Fig. 6.2a), so that all states containing both are removed as
well. The resulting automaton is shown in Fig. 6.3b.
At this stage, some more transitions can be removed. In fact, certain CCSL
constraints may reveal that clocks cannot tick directly after each other. Thus,
transitions between states containing these clocks can be removed. Although this
can also be handled later when guard conditions are reﬁned (which would never
evaluate to true for such transitions), dropping them before simpliﬁes the remaining
steps signiﬁcantly.
Example 49 Consider the isPeriodicOn-constraints of the example (see
Lines 8 and 9 in Listing 6.1). Since the periods are greater than 0, it can be
concluded that there can never be a valid transition between two states containing
the respective subclock. Hence, all transitions from states containing sensor1
to states containing sensor1 are removed. The same happens with transitions
from/to states containing sensor2. The resulting automaton is shown in Fig. 6.3.
Next, the initial states are determined. At the beginning, all states are assumed
to be initial states. However, all clocks which are dependent from other clocks (i.e.,
have to wait for other clocks) obviously cannot initiate the timing behavior. Hence,
whenever a CCSL constraint states that a clock c 2 C is dependent on another
clock c0 2 C (e.g., clocks with an offset have to wait for a triggering clock tick), all
states including c are not considered an initial state. Formally, the initial states are
deﬁned by
S0  ˙ n f 2 ˙ j 9 c 2  W c depends on c0 2 C n fcgg
Example 50 Thus far, all ﬁve states left in the automaton and shown in Fig. 6.3 are
assumed to be initial states. However, there exists a dependency between two clocks:
echo has to wait until sensor1 has ticked one time. As a consequence, all states
including the clock echo cannot initiate the timing behavior and, hence, they are
not considered to be initial states. Figure 6.3 shows the resulting automaton.
Finally, the guard conditions g and the update functions u for the transitions are
reﬁned with respect to the CCSL constraints. For this purpose, the set V of global
variables is initialized with

168
6
Timing Aspects
•
natural numbers N which are applied as counters, e.g., to control periodicity or
delays as well as
•
Boolean variables B which are applied to monitor whether a clock has already
ticked or not.
For all variables, the initial assignment is added to V0. Then, for all transitions
we reﬁne g and u depending on the respective constraints. For this purpose, a rather
direct mapping as illustrated in the following example is applied.
Example 51 The guard conditions and update functions for the transitions which
remained in the automaton shown in Fig. 6.3 have to be reﬁned. While the excluding
constraint (Line 7 in Listing 6.1) has already been handled above (by excluding
the corresponding states from the automaton at all), this particularly requires the
consideration of the isPeriodicOn and delayedBy constraints (see Lines 5,
8, and 9 in Listing 6.1).
These constraints obviously require a counter variable cclock 2 N (in order
to check whether the period or the delay has been completed) and a Boolean
variable dclock (in order to store whether the restricted clocks have ticked before) for
each of the restricted clocks clock. Note that, in the example, a clock can either
be s1, s2, or e, while the latter just needs a counter and no Boolean variable. Then,
states  2 ˙ including clock (i.e., with clock 2 ) may only be entered either
(1) if the period/delay (stored in cclock) satisﬁes the respective CCSL constraint
or (2) if clock has simply not ticked yet (stored in dclock). In a similar fashion,
entering a state  2 ˙ sets the existing dclock-variables for all clock 2  to true
(since all clock 2  are ticking in the following step) and leaving such states
updates the corresponding cclock-variables. For the latter, this means either resetting
the counter (if the corresponding clock just ticked in ) or increasing it by one (if
the corresponding reference clock ticked).
Overall, this leads to a revision of the guard conditions and update functions as
shown in Fig. 6.3.
Following the scheme described above, almost all CCSL constraints can auto-
matically be mapped into the generic representation. An exception is uncontrollable
behavior, e.g., clocks ticking according to external sensor input. However, if the
automaton satisﬁes certain characteristics these constraints are automatically satis-
ﬁed as well. Hence, supporting uncontrollable behavior boils down to a particular
veriﬁcation task which can, e.g., be conducted by established veriﬁcation methods
as discussed in the next section.
6.2.2
Discussion and Application of the Generic
Representation
Using the method described above, timing behavior provided in CCSL is generically
represented by means of a transition relation. Now, this can be used for various
purposes for which only very problem-speciﬁc design tools were available thus

6.2
A Generic Representation of CCSL Constraints
169
far. In this subsection, possible application areas of the proposed methodology are
discussed and compared to related work. Further, it is explained how the problem
is solved using the symbolic formulation for UML/OCL models as presented in the
last chapters. Afterwards, the feasibility of the approach is exemplary demonstrated
by means of the running example.
6.2.2.1
Application and Comparison to Related Work
An important issue after the speciﬁcation of timing constraints is to check, e.g.,
•
whether the resulting CCSL constraints are consistent, i.e., do not contradict each
other and thus allow for an execution of the clocks without deadlocks, as well as
•
whether they indeed have been speciﬁed as intended.
To conduct these checks, a few approaches have been proposed previously
(cf. [MY12, SY12, YML11, AMD10]). Here, each constraint is represented by
a single automaton. Moreover, they represent ticking sets in terms of transitions
rather than states. For some constraints, this leads to an inﬁnite number of states. To
deal with that, the authors of [MY12, SY12, YML11, AMD10] restrict the number
of transitions.
The proposed solution approaches this problem from a different direction which
allows for an easier consideration of many veriﬁcation tasks. It relies on a ﬁnite
representation from which serious design ﬂaws can directly be detected. For
example, if CCSL constraints result in an automaton composed of states with no
outgoing transitions (or outgoing transitions which will never satisfy the guard
conditions), a typical deadlock scenario is identiﬁed.
In addition to that, well-known and powerful methods for (bounded) model
checking (e.g., [LLH05, CCR09, SWD11c, GogC14]) can directly be applied on
the obtained transition relation in order to check more sophisticated properties.
Moreover, the obtained generic representation obtained by our approach can directly
be combined to a transition relation representing the functional behavior of a
system (obtained, e.g., by approaches as proposed in [SWD11c, GogC14]). In doing
so, non-functional timing constraints can be considered together with functional
speciﬁcations. Particular for generic veriﬁcation frameworks as envisioned, e.g.,
in [WilC13, HPW15, HilC14a], this is an important beneﬁt.
Another important use case for CCSL descriptions is code generation, i.e., the
derivation of a proper implementation of the speciﬁed timing behavior. A practical
approach for this purpose has recently been presented in [PWD14]. However, this
solution relies on a rather heavy data-structure as well as a complex analysis
scheme including, e.g., a categorization, several lists, etc. In contrast, the generic
representation of timing constraints proposed in this work provides an easy and
obvious basis for code generation. In fact, once an automaton has been found to
be correct, it can directly be translated into an implementation by (1) mapping all
states to an encoding in terms of state signals (which are connected to the clocks)
and (2) mapping all transitions to if-statements ensuring the correct assignment to
the state signals.

170
6
Timing Aspects
On the contrary, the proposed approach obviously suffers from the possibly
exponential size of the automaton. In the generic approach as described in
Sect. 6.2.1, a power set construction is conducted which represents the bottleneck of
the solution. However, this worst case behavior can be avoided in many cases. For
example, when CCSL constraints as discussed before in Listing 6.1 are considered,
it can already be derived that only ﬁve states (rather than 24  1 D 15) are required.
Determining more sophisticated bounds for all possible cases remains an open
problem for future work, but certainly provides further room for improvement.
6.2.2.2
Exemplary Evaluation
In order to evaluate the applicability of the proposed approach, the running example
considered above (i.e., the CCSL constraints from Listing 6.1) was subject to more
detailed investigations. More precisely, we applied the resulting generic description
to selected code generation and veriﬁcation tasks. In order to evaluate the scalability
of the generic representation, we additionally did not only consider this example
with four clocks (denoted by sensors4), but also derivations including six and eight
clocks (denoted by sensors6 and sensors8, respectively). To this end, corresponding
CCSL constraints have been added for the newly introduced clocks.
Applying the approach proposed in Sect. 6.2.1 to the resulting CCSL instances
yielded generic representations with characteristics as summarized in Table 6.1. The
columns denote the name of the instance (INSTANCE) as well as the number of
states (STATES), the number of transitions (TRANS.), and the number of variables
(VAR.). All automata have been derived in negligible run-time, i.e., within a few
seconds.
Afterwards, typical design tasks have been conducted in which the generic
representation has explicitly been utilized. Since code generation can be performed
by a rather simple mapping scheme (as discussed above), our evaluations on
veriﬁcation are summarized in more detail in the following. The resulting generic
description is utilized in order to automatically prove whether
1. the originally given CCSL description is consistent, i.e., allows for a consistent
execution at least for a given number of transition steps,
and
2. the originally given CCSL description is deadlock-free, i.e., no path from an
initial state to another state exists from which no further ticks can be executed
anymore.
Table 6.1 Characteristics of
the resulting automata
INSTANCE
STATES (˙)
TRANS.
VAR.
sensors4
5
13
5
sensors6
20
117
9
sensors8
80
1053
13

6.2
A Generic Representation of CCSL Constraints
171
Table 6.2 Veriﬁcation
results (consistency)
INSTANCE
#STEPS
RUN-TIME
RES.
sensors4
2
1.7
✓
50
3.5
✓
100
5.9
✓
sensors6
2
3.3
✓
50
24.0
✓
100
73.0
✓
sensors8
2
48.1
✓
50
825.7
✓
100
2583.3
✓
Table 6.3 Veriﬁcation
results (deadlock)
INSTANCE
#STEPS
RUN-TIME
RES.
sensors4
3
2.3
✗
10
3.9
✗
30
11.7
✗
sensors6
3
7.1
✗
10
19.9
✗
30
122.5
✗
sensors8
3
225.7
✗
10
928.0
✗
30
8138.2
✗
To this end, the generic description has been transformed into a UML/OCL model,
more precisely, a model with just one class. This class has one integer attribute to
represent the current state, i.e., the ticking set. For this purpose, the remaining states
of the automaton are simply enumerated. An additional invariant restricts the valid
assignments. To model the transitions, for each remaining transition an operation is
added to the class. Furthermore, the guard conditions are mapped to preconditions
and the update functions to postconditions. Now, it is possible to utilize the symbolic
formulation together with the respective veriﬁcation.
Tables 6.2 and 6.3 summarize the obtained results for the consistency- and
the deadlock-checks, respectively. Again, the ﬁrst column denotes the name of
the instance (INSTANCE), while afterwards the number of considered transition
steps (#STEPS), the overall run-time (in CPU seconds and obtained on an Intel(R)
Core(TM) i5-3320M machine with 2.60 GHz and 8 GB of memory; RUN-
TIME), and the result (RES.) is provided. For the last column, a ✓denotes
that consistency/deadlock-freeness has been proven; otherwise, ✗denotes that a
corresponding ﬂaw has been found.
The results conﬁrm the applicability of the proposed approach for veriﬁcation
purposes. In fact, the considered tasks could have been addressed in acceptable
run-time and, for a given CCSL constraint, consistency could have been proven by
utilizing an existing model checker rather than developing a speciﬁc CCSL-based
solution. More importantly, the proposed solution even helped unveiling a severe
design ﬂaw which was hidden the entire time in the considered running example:

172
6
Timing Aspects
The execution of the state sequence fmcg ! fmC, s1, s2g ! fmCg leads to a
deadlock. This is because the periodicity forces s1 and s2 to tick in the next step
(mC ticks always), but if s1 ticks, e has to tick as well (because of the delayedBy
constraint). The exclusion between s2 and e eventually leads to a contradiction
and, hence, no further transition can be taken at that point. While not obvious at
a ﬁrst glance, this ﬂaw can be detected using the proposed generic representation
(as indicated by column RES. in Table 6.3). Again, all these results have been
achieved without explicitly developing a speciﬁc CCSL-checker but entirely relying
on existing tools.
6.3
Validation of Clock Constraints Against Instant
Relations
Clocks (as deﬁned in Deﬁnition 6.1) are used to deﬁne sets of uniformed instants.
Moreover, special instants satisfying certain conditions can additionally be deﬁned
using CCSL statements. These speciﬁc instants can be used, e.g., to trigger certain
events in the system. More precisely, CCSL allows for deﬁning instants of a clock c
in categories such as:
•
Unspeciﬁc. An arbitrary instant of the clock (e.g., Instant i1 is
myClock;),
•
Fixed.
A
ﬁxed
instant
of
the
clock
(e.g.,
myClock(4) precedes
myOtherClock(8)),
•
Relative. A relative instant of the clock (e.g., myClock(i) precedes
myOtherClock(i-7)), or
•
Conditional. A conditional instant of the clock (e.g., Instant i1 is
myClock suchThat k>14;).
In general, the clocks these instants form can either refer to a constant physical
(and possibly dense) time or to logical events, which do not necessarily follow
constant timing rules, but can occur with varying periods in physical time. In our
scenario, the target system (i.e., SystemC) is discrete and, because of that, can only
simulate logical time. The processor clock itself is a logical clock counting cycles.
Hence, all times derived and simulated in this context are logical.
If there is more than one clock, all clocks and their respective instants can be
structured through instant relations [AM08]:
Deﬁnition 6.4 Given a set of clocks C , a binary instant relation 4 (called
precedence) can be deﬁned stating that one instant occurs before or coincidentally
with the other. From 4, three further instant relations can be derived, namely
•
precedence (denoted by 4), i.e., one of the clock ticks takes place before or
coincidentally with the other tick (e.g., i1 precedes i2),
•
coincidence (denoted by  , 4
\
<), i.e., two clock ticks take place
coincidently (e.g., i1 coincidentWith i2), and

6.3
Validation of Clock Constraints Against Instant Relations
173
1 sensor1(i) precedes sensor2(i);
2 sensor2(i) precedes sensor1(i+1);
3
4 sensor2(k) precedes sensor1(k);
5 sensor1(k) precedes sensor2(k+1);
Listing 6.2 CCSL speciﬁcation of instants
Fig. 6.4 Instant relations
with two precedes
statements
sensor1
sensor2
0
1
2
3
4
5
•
strict precedence (denoted by  , 4 n ), i.e., one of the clock ticks takes place
strictly before and not coincidentally with the other tick (e.g., i1 strictly
precedes i2).
Example 52 CCSL can be used to describe complex temporal relations. As an
example, consider the clocking as already described in Example 44.
Now, more precise statements about the instants of the clocks are given in
Listing 6.2. Lines 1–2 denote that the ith tick of sensor1 is followed by or
coincident with the ith tick of sensor2 and is again followed by or coincident
with the .i C 1/th tick of sensor1. In the CCSL statements, the same is stated in
lines 4–5 for the kth and .k C 1/th tick of sensor2 and the kth tick of sensor1.
Figure 6.4 illustrates the relations. Obviously, all relations could only be satisﬁed, if
sensor1 and sensor2 tick coincidently.
Instant relations only affect the instants to which they are referring to, not the
clocking behavior itself. Because of that, no behavior can be derived from the
instant relations and enforcing instants to appear is not possible. Consequently,
the clock constraints represent the actual clocking behavior while instant relations
provide a more detailed description of the intended timing behavior. Thus, instead of
generating behavior, instants are up to now applied by some approaches to monitor
the timing behavior and to report unwanted behavior (e.g., a meltdown instant)
[PWD14]. Respectively, from the clock constraints indeed the actual behavior can
be derived as described, e.g., in [PWD14] or as recently explained in Sects. 6.1
and 6.2.2.
6.3.1
Motivation and Proposed Idea
In this section, the current exploitation of CCSL for veriﬁcation purposes is brieﬂy
discussed and illustrated. Afterwards, it is discussed how this state-of-the-art can
signiﬁcantly be improved. This eventually motivates the veriﬁcation methodology
proposed in the work. To this end, the following example is considered:

174
6
Timing Aspects
1 ClockConstraintSystem satellite {
2
Clock photo_earth;
3
Clock photo_sun;
4
Clock check_height;
5
6
photo_earth # photo_sun;
7
photo_earth alternatesWith photo_sun;
8
photo_earth # check_height;
9
photo_sun # check_height;
10 }
Listing 6.3 CCSL description of a satellite
Example 53 A simple satellite application for space systems shall be designed. The
satellite shall take photos of the earth and the sun. In between, it has to ensure that
its orbit is still correct, i.e., it has to check (and, if necessary, correct) its height.
As it has only one camera, it shall alternately take photos of the sun and the earth.
The height control is a complex task leaving not enough processor performance for
image processing, thus, the satellite cannot take photos and control its height at the
same time.
As recently reviewed in the previous subsections, CCSL provides description
means to describe the ticking of the clocks to be implemented (in terms of clock
constraints). Using these notations, the clock behavior of this system can be
speciﬁed:
Example 54 Listing 6.3 shows a possible speciﬁcation of the clocks to be used in
order to realize the timing of the satellite application. The clocks photo_earth
and photo_sun speciﬁed in Line 2 and Line 3 trigger the camera to take a photo
of the earth and the sun, respectively. The constraints in Line 6 and in Line 7
respectively ensure that these clocks do not tick at the same time and indeed alternate
between each other. Checking height is triggered by clock check_height
(Line 4) which must not tick concurrently with the other two clocks as restricted
by the last two constraints in Lines 8–9.
Besides that, CCSL allows to describe certain timing behavior which is intended
to be executed on the realized system. To this end, detailed constraints over single
instants can be speciﬁed in terms of instant relations:
Example 55 In order to further reﬁne the speciﬁcation of the satellite application,
instant relations as depicted in Listing 6.4 are added. They state that between a
tick of photo_sun and the consecutive tick of photo_earth the height shall
be checked, i.e., clock check_height shall tick. This is expressed by two strict
precedence instant relations. The identiﬁer for the instants are the indices i and j.
The two consecutive instants of photo_sun and photo_earth are the ith ticks
of their clocks, while the control_height tick in between is the jth tick of its
clock.

6.3
Validation of Clock Constraints Against Instant Relations
175
1 photo_sun(i) strictly precedes
2
check_height(j);
3 check_height(j) strictly precedes
4
photo_earth(i);
Listing 6.4 CCSL instant relations
Eventually, a CCSL description results which, using, e.g., the recently introduced
generic automaton approach or approaches as presented in from [MY12, YML11],
can be checked for consistency. However, whether the intended behavior as speciﬁed
by the instant relations from Listing 6.4 can indeed be realized considering the
clock constraints from Listing 6.3 is not covered by these veriﬁcation methods.
Instead, the state-of-the-art methodology continues with an implementation of the
timing constraints (e.g., using code-generation approaches such as [PWD14]). As
this might result in the creation of monitors (as, e.g., suggested in [PWD14]),
corresponding checks can be conducted after the implementation has been ﬁnalized.
Obviously, this causes a signiﬁcant drawback: Checking the intended timing
behavior is considered rather late in the design process, namely not until a fully-
ﬂedged implementation is available. If it turns out that the intended behavior is not
possible, re-spins of the implementation or even the CCSL speciﬁcation have to be
conducted. This leads to long debugging loops and poses a serious threat to time-to-
market constraints.
Motivated by this, an alternative methodology is proposed. It aims for verifying at
the CCSL level, i.e., prior to implementation, whether the given descriptions allow
for the intended timing behavior. To this end, a slightly different interpretation of
the CCSL description means is applied. Instead of considering instant relations as
behavior to be monitored, they are applied as properties to be satisﬁed by the clock
constraints. Based on this, a veriﬁcation methodology is proposed whose general
idea rests on three main steps:
1. Formulating the properties to be checked according to the instant relations
2. Deriving a symbolic representation of all possible ticking behavior of the clocks
according to the clock constraints
3. Checking whether the resulting symbolic representation indeed satisﬁes the
properties derived from the instant relations
In the remainder of this section, the implementation and application of this
general idea is described and discussed, respectively.
6.3.2
Implementation
We start with a description of the three steps to be conducted in order to verify
instant relations against clock constraints. All steps are illustrated by means of the
satellite example from above.

176
6
Timing Aspects
6.3.2.1
Formulating the Properties
Single instant relations already provide a formal description of timing behavior to be
veriﬁed. However, as they may be connected to each other (cf. Example 55), a sole
consideration may not provide a sufﬁcient veriﬁcation objective or property to be
veriﬁed. In fact, an instant relation is only satisﬁed, if all other relations connected
to it are also satisﬁed. Hence, a property to be checked has to be composed of a
group of instant relations. To this end, the following deﬁnition and notation of an
instant group is used:
Deﬁnition 6.5 Let i be an instant and ˚ 2 f; ; 4g an instant relation symbol.
Let further .ij ˚k il/ be an instant relation and I the set of all instant relations. Then,
an instant group I is a set of instant relations such that
8 .i1 ˚1 i2/ 2 I W 9 .i3 ˚2 i4/ 2 I W f i1; i2g \ f i3; i4g ¤ ;:
An instant group is maximal, iff
8 .i1 ˚1 i2/ 2 I W À .i3 ˚2 i4/ 2 I W .f i1; i2g \ f i3; i4g ¤ ;/ ^ .i3 ˚2 i4/ … I
Example 56 Consider again the instant relations from Listing 6.4. Since both
relations are connected by the instant control_height, they ﬁnally form one
group. This eventually results in an instant group as shown in Fig. 6.5 and, hence, a
property to be veriﬁed.
6.3.2.2
Deriving a Symbolic Representation
Next, a symbolic representation of all possible clock tickings is required. To this
end, the recently presented approach is utilized again.
Example 57 Consider again the clock constraints from Listing 6.3. The correspond-
ing automaton representation is provided in Fig. 6.6. As no clock can tick together
with another clock, only three states have to be considered (one in which each clock
is allowed to tick). The states control_height and photo_earth are initial
states—the third one cannot be an initial state because of the alternatesWith-
photo_sun(i)
control_height(j)
photo_earth(i)
Fig. 6.5 An instant relation group

6.3
Validation of Clock Constraints Against Instant Relations
177
photo_sun
photo_earth
control_height
1
2
3
4
V0 = (balt = true, f = true)
1⃝
guard: balt =true
update: balt ←false
2⃝
guard: balt =true
update: balt ←false
3⃝
guard: (balt =false)∨(f =true)
update: (balt ←true)∧(f ←false)
4⃝
guard: (balt =false)∨(f =true)
update: (balt ←true)∧(f ←false)
Fig. 6.6 Automaton representing the CCSL
statement. The guard and update conditions consider additional Boolean vari-
ables balt (denoting who ticks next) and f (denoting if this is the initial alternation)
which direct the alternation between photo_earth and photo_sun and are
initially both set to true. This ensures that the clock photo_earth ticks ﬁrst
and, afterwards, the states photo_earth and photo_sun are only reached if
the respective other clock has ticked before.
6.3.2.3
Checking the Properties
Having the automaton, all clock ticking behavior which is possible according to
the clock constraints is available in a symbolic fashion. Now, it has to be veriﬁed
whether this ticking behavior indeed allows for the execution of a sequence of
clock ticks which satisﬁes the property given by the instant group. To this end, the
SMT-LIB realization for the generic automaton is exploited such that an SMT-LIB
instance considering the following question is derived: “Is it possible to execute
a sequence deﬁned by the instant group on the automaton derived from the clock
constraints?”
6.3.2.4
Creating the Instance
In order to formulate the corresponding instance, the execution of a sequence of
clock ticks is symbolically considered. Each step in this sequence is denoted as a
(symbolic) simulation step in the remainder of the section. All possible clocking
ticks are encoded in terms of variables to be assigned by the SMT solver. For each
clock c 2 C , the following variables are introduced and added to the sequence for
every simulation step:
•
A Boolean variable tc representing whether c does tick (tc D 1) or does not tick
(tc D 0) in the current step.
•
An integer variable indc representing the index of the current tick of the clock c.
The variable is initially undeﬁned and set to 0 when c ticks ﬁrst. Afterwards, its
value is increased by 1 with any further tick.

178
6
Timing Aspects
s0
s1
s2
step = 0
tps = 0
tpe = 1
tch = 0
indps = −
indpe = 0
indch = −
step = 1
tps = 0
tpe = 0
tch = 1
indps = −
indpe = 0
indch = 0
step = 2
tps = 1
tpe = 0
tch = 0
indps = 0
indpe = 0
indch = 0
pe0
ch0
ps0
pe1
pe2
ps1
ps2
ch1
ch2
Fig. 6.7 Additional variables for instant checking
Additionally, another integer variable step is introduced which serves as counter for
the respective (symbolic) simulation steps. For the formulation, it is assumed that a
maximum number stepmax of simulation steps to be considered is available.
Finally, constraints are added to enforce the satisﬁability solver to choose the
variable assignments in the consecutive simulation steps according to the behavior
of the automaton. This yields an instance representing all possible ticking sequences
of length stepmax which is allowed by the clock constraints.
Example 58 Consider again the clock constraints from Listing 6.3 and the instant
group from Listing 6.4. In Fig. 6.7, a possible simulation sequence including the
introduced variables is depicted. The assignments represent the simulation of the
following clock ticks:
{ photo_earth} ! {control_height} ! { photo_sun}:
The variable step counts the simulation steps and, thus, increases with each
step. For each step, the assignments to tc, c 2 fps, ch, peg (representing the
clocks photo_sun, control_height, photo_earth), state the ticking
clocks. For example, in the ﬁrst step, photo_earth ticks, hence tpe is assigned 1,
while tps and tch are assigned 0. Correspondingly, the index variable for clock
photo_earth, i.e., indpe is initialized with 0.
Note that, for illustration purposes, the example above as shown in Fig. 6.7
considers particular assignments. However, in order to symbolically represent all
possible sequences of simulation steps, the created satisﬁability instance is com-
posed of un-assigned variables only. The precise assignment has to be determined
by the satisﬁability solver.

6.3
Validation of Clock Constraints Against Instant Relations
179
6.3.2.5
Adding the Properties
Simply passing the satisﬁability instance created thus far to a satisﬁability solver
would simply yield an assignment representing an arbitrary sequence of simulation
steps possible by the clock constraints. However, we are interested in a dedicated
sequence which shows the executability of a considered instant group. Hence,
additional constraints are added to the satisﬁability instance enforcing the solver
to choose assignments in this regard.
The instant relation groups refer instants with certain indices. This means, one
need to extract the corresponding state number of the referred instants and to check
whether the ordering of the obtained state numbers follows the constraints from the
instant relations.
To extract the state number for a certain index, for all clocks and all stepmax
simulation steps, an Integer variable ci with 0  i  stepmax is added for each
c 2 C denoting the simulation step number of the ith tick of c. To model these
ith ticks, special constraints are added to the SMT solver. The considered property
extracts the variables ci from the encoded instance and connects them by precedence
or coincidence statements. Hence, the connection between the corresponding ci
is restricted using simple comparison-statements to model precedence (), strict
precedence (<), or coincidence (=).
The ﬁnal veriﬁcation task is then to check the following statement:
9 k 2 0  k  stepmax W I k
where I k is the evaluation of the instant relation group concerning the given
index k as the index variable from the CCSL speciﬁcation,3 e.g., .A2 < B3/ for k D
2 and A(k) strictly precedes B(k+1). This means that the concerning
index variables ci connected by the relations are chosen for every k concerning the
deﬁnition in the CCSL statements.
Example 59 Consider again the instance from Example 58. Now, additional vari-
ables are created for each clock, e.g., pe0; pe1; pe2; : : : for photo_earth, which
denote in which step this clock has been ticked for the 0th, 1st, 2st, etc. time. For
example, the variable pe0 pointing to step D 0 as illustrated in Fig. 6.7 states that
the 0th tick occurred in step 0. The variables without assignment (as shown in the
bottom of Fig. 6.7) simply state that their respective tick has not been conducted
yet.
Having this formulation, the order of clock ticks is symbolically described. Now,
this can be constrained in a fashion that a particular order (namely as given by
the instant group) is enforced. Considering the instant group from Listing 6.4, this
requires constraining the variables ps0, ch0, and pe0. In fact, as the corresponding
3Note that the evaluation will be false, if one of the index variables remained un-assigned.

180
6
Timing Aspects
clock tickings are restricted by strictly precedes statements, the following
constraint has to be employed:
. ps0 < ch0/ ^ .ch0 < pe0/:
6.3.2.6
Solving the Instance
The instance is now given to a satisﬁability solver which tries to determine an
assignment satisfying all constraints. If such an assignment can be determined
the corresponding values of each variable can be translated back to a particular
sequence of simulation steps. This works as witness demonstrating that the behavior
deﬁned by the instant group indeed is possible with the additionally considered
clock constraints.4
In contrast, if the satisﬁability solver proves that no assignment exists which
satisﬁes all constraints, it has been shown that no sequence of stepmax simulation
steps exists which satisﬁes both, the clock constraints and the constraints enforced
by the instant group. In this case, stepmax can be increased, e.g., until the diameter of
the automaton is reached or until the expected maximum number of time steps the
behavior is supposed to become evident is reached. If this still yields no satisﬁable
assignment, it has been proven that the given instant group cannot be executed under
the deﬁned clock constraints. This unveils an error in the CCSL speciﬁcation which
can be addressed by the designer prior to the implementation.
6.3.3
Application and Evaluation
Using the method described above, clock constraints can automatically be checked
against given instant relations and, hence, the timing behavior can be veriﬁed
prior to its implementation. In order to conﬁrm the applicability of the proposed
methodology, the three steps described in Sect. 6.3.2 have been implemented on top
of the proposed Eclipse model ﬁnding plugin.
Afterwards, the resulting tools have been applied to the CCSL descriptions
from Listing 6.1/6.2 (denoted by sensors) as well as from Listing 6.3/6.4 (denoted
by alternates). In order to evaluate correct as well as incorrect speciﬁcations,
different variations of the ﬁrst example have been considered (distinguished by
the sufﬁx corr and incorr, respectively). Furthermore, the later example (sensors)
has been considered with a different amount of sensors (and, hence, clocks to be
considered).
4Note that this does not guarantee the occurrence of a group in an actual system, as this additionally
depends on the precise implementation of the system. Nevertheless, this proof shows that the
desired timing behavior is, in principle, possible.

6.3
Validation of Clock Constraints Against Instant Relations
181
Table 6.4 Behavioral analysis for instant relation groups
Instance
Clk.
Inst.
Rel.
Grp.
States
Trans.
Res.
Time (s)
alternates_corr
3
3
2
1
3
7
✓
2.7
alternates_incorr
3
3
2
1
3
7
✗
5.1
sensors1
4
3
2
1
5
13
✓
4.1
sensors2
4
3
2
1
5
13
✓
4.0
sensors3
4
6
4
2
5
13
✗
4.0
sensors4
8
3
2
1
80
1053
✓
733.6
sensors5
8
4
4
1
80
1053
✓
773.3
The results of the application are summarized in Table 6.4. The ﬁrst columns
provide the name of the respective example including its number of clocks (Clk.),
number of instants (Inst.), number of instant relations (Rel.), and the eventually
resulting number of instant groups (Grp.) derived from the respectively given CCSL
representation (derived in Step 1 of the proposed methodology; see Sect. 6.3.2.1).
The results from the second step, i e., from the derivation of the automaton (see
Sect. 6.3.2.2) are summarized in the next columns. Here, the number of the states
(denoted by States) and the number of transitions (denoted by Trans.) are reported.
Note that these numbers only report the size of the ﬁnal automaton—intermediate
results may be signiﬁcantly larger due to the need to consider all possible subsets of
clock tickings in the automaton.5
Finally, the result of the third step (see Sect. 6.3.2.3) and, hence, the overall result
is presented in the column Res. More precisely, it is denoted whether the instant
relations indeed can be realized by the clock constraints or not (denoted by ✓and ✗
in Column Res.). Furthermore, the total run-time (in CPU seconds) is given.
Overall, the applicability of the proposed approach can be conﬁrmed. In fact,
the considered instant relations could have been veriﬁed against the given clock
constraints in acceptable run-time. More importantly, the proposed solution even
helped unveiling design ﬂaws in the examples considered above. In fact, alternates-
examples behaved as expected, i.e., the correct instance has been proven correct
while the error in the incorrect version has been detected.
Moreover, the sensor-example from Listing 6.1/6.2 (where no error has been
introduced on purpose) has also been found erroneous. If the two instant groups
are considered separately (as done in the experiments summarized in row sensors1
and sensors2), the clock constraints indeed realize the intended behavior. But
enforcing both together (as done in the experiments summarized in row sensors3)
would require both clocks (i.e., sensor1 and sensor2) to tick together. This
is implicitly prohibited due to the exclusion between sensor2 and echo (cf.
Listing 6.1). As a consequence, these instant groups cannot be realized using the
clock constraints—the speciﬁed behavior is not possible. While not obvious at a
ﬁrst glance, this ﬂaw can easily be detected using the proposed methodology.
5This has already been identiﬁed as bottleneck before in this section.

Chapter 7
Reducing Instance Sizes with Ground
Setting Properties
In the previous chapters, the symbolic formulation from Chap. 3 has been exploited
to solve various model ﬁnding problems for structural, behavioral, and timing
aspects, mainly to increase the conﬁdence in the correctness of a UML/OCL model,
i.e., the system to be designed. All those problems have in common that the designer
usually does not know anything about the system state to be obtained. This means
that the symbolic formulation has to consider all constraints of the model and all
(type ensuring) assignments to the variables at any time during the transformation.
However, there are also problems in the domain of system design and beyond where
the presented model ﬁnding techniques can be re-used and where the designer has
special knowledge. For example, when the designer already knows the assignment
of some variables prior to starting the model ﬁnding ﬂow. This is especially true,
when trying to tackle other problem domains with a UML/OCL model and then
deriving an SMT instance instead of directly formulating a decision problem, e.g.,
in terms of SAT or SMT.
Therefore, in this chapter, the proposed transformation rules are investigated.
It is shown that certain OCL operations—in particular, nested OCL navigation
and iterator expressions—are causing huge SMT formulations which harm the
transformation and, by this, also the solving process and the model ﬁnding in
general. However, this is not necessary if a ﬁxed structure of the model can be
assumed. Moreover, further investigations show that huge parts of the resulting
SMT formulations are often not necessary and, in fact, are ignored during the actual
model ﬁnding. Vice versa, just skipping those parts of an SMT formulation prior
to model ﬁnding yields an SMT instance which does not represent the model in an
adequate fashion. Motivated by this, a new concept called ground setting properties
is introduced (following [PWD16b]) which allows for an efﬁcient transformation
of OCL into SMT. This concept is illustrated by means of a running example
and compared to existing solutions. Furthermore, this information is utilized in
order to prune huge parts of SMT formulations which are not necessary anymore
considering the additional information. By this, SMT formulations can be generated
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8_7
183

184
7
Reducing Instance Sizes with Ground Setting Properties
which have only a fraction of the size of the originally created ones. Using an initial
implementation, this yields reductions of up to 4 orders of magnitude of the used
memory and allows to solve problems that could not be handled before.
The chapter is structured as follows. In Sect. 7.1 the running example is
introduced. Afterwards, in Sect. 7.2 the resulting model is used to investigate the
transformation of OCL invariants to SMT constraints and to show how this may
yield unnecessarily huge SMT formulations. Motivated by this, the concept of
ground setting properties is introduced in Sect. 7.3 and their relations to related
work is discussed in Sect. 7.4. Finally, Sect. 7.5 deals with the implementation and
evaluation.
7.1
Considered Running Example
The contributions of this chapter will be illustrated and evaluated by means of a
running example, namely a model of the One Tile Game—a variant of the well-
known Wythoff’s Game which is a so-called Nim game. This subsection brieﬂy
reviews the game and its rules as well as its formulation in terms of a UML/OCL
model. Based on that, the considered problem and the proposed solution are
explained in the remainder of this section.
7.1.1
Considered Scenario
The One Tile Game is played with a single tile on a board with x columns and y rows.
At the beginning, the tile is placed on the north-east ﬁeld of the board. Then, two
players A and B alternatingly move the tile either 1 or 2 ﬁelds towards the south, the
south-west, or the west. Figure 7.1 sketches the allowed moves at the beginning on
Fig. 7.1 One Tile Game—a
Nim variant
1
2
3
4
5
6
1
2
3
4
5
6

7.1
Considered Running Example
185
a 6  6 board. Player A starts the game. A player wins the game, if he is capable of
performing the last valid move, i.e., if the other player is not able anymore to move
the tile on the board.
If it is assumed that both players are playing with a perfect strategy—and they
can do so because the One-Tile-Game has perfect information, i.e., all information
about decisions and/or possible moves is available at any time—it is obvious that
the winner of the game can be determined before starting the game.1 Because of
this, it is possible to mark each ﬁeld of the board with the player that is going to
win the game if the game starts on this ﬁeld. Now, the question which player wins
the game when it is started on an arbitrary ﬁeld can be tackled as a model ﬁnding
instance. To this end, a UML/OCL model has to be available.
7.1.2
Corresponding UML/OCL Model
To model the One Tile Game with UML/OCL models, one class representing the
entire board and one class representing the single ﬁelds of the board as shown in
Fig. 7.2 are created. Further, an enum Player is deﬁned, which is used as a data-
type to mark which player is going to win when the game starts on a particular
ﬁeld.
The class Board additionally provides attributes to deﬁne the number of rows and
columns. Another attribute, namely validMoves, stores all the possible numbers
of ﬁelds to which the tile can be moved. This means that for the One Tile Game
1 and 2 should be the only elements in validMoves, since the tile can be moved
either 1 or 2 ﬁelds. This attribute allows for a quick consideration of further variants
of the game in which you can move the tile by more or less ﬁelds.
Since all ﬁelds in the actual game have a unique position deﬁned by its row
and column, the class Field is equipped with corresponding attributes. Besides this,
an attribute endPosition indicates whether a valid move is still possible from
this ﬁeld or not (i.e., endPosition deﬁnes whether the ﬁeld is the terminal/end
ﬁeld). Additionally, an attribute winner is used to mark the winner for this ﬁeld
as described above—if, e.g., winner is set to Player::A, Player A would win if
the game is started on this ﬁeld and an optimal strategy is used. Finally, each ﬁeld
is connected through a reference with exactly one board, while the board must be
connected to at least one ﬁeld.
Up to this point, a nearly arbitrary number of objects per class as well as arbitrary
values for the attributes would constitute a valid system state for this class diagram.
However, since the goal is still to aim only for conﬁgurations of object instances
which correctly represent different versions of boards as well as the respectively
correct winners for each ﬁeld, the attribute values have to be restricted by OCL
1Note that Player B wins, if the game starts on ﬁeld (1,1), since Player A has to make the ﬁrst move
but no valid options to do so.

186
7
Reducing Instance Sizes with Ground Setting Properties
Board
rows: Integer
columns: Integer
validMoves: Set<Integer>
Field
row: Integer
column: Integer
endPosition: Boolean
winner: Player
≪enum≫
Player
A
B
1 board
1..* ﬁelds
context Board
inv restrictFields : self.fields->size() = self.rows * self.columns
inv restrictMoves : self.validMoves = Set{1, 2}
inv restrictRowValues : self.fields->forAll( f |
1 <= f.row and f.row <= self.rows
)
inv restrictColumnValues : self.fields->forAll( f |
1 <= f.column and f.column <= self.columns
)
inv uniqueRowColumn : self.fields->forAll( f1, f2 | (f1 <> f2) implies
(f1.row <> f2.row or f1.column <> f2.column)
)
context Field
inv restrictEndPositions :
self.endPosition = self.board.validMoves->forAll( i |
(self.row - i <= 0) and (self.column - i <= 0)
)
inv andTheWinnerIs :
if (self.endPosition)
then self.winner = Player::B
else if (self.board.fields->select( f |
self.board.validMoves->exists( i |
(f.column = self.column - i and f.row = self.row
)
or (f.column = self.column
and f.row = self.row - i)
or (f.column = self.column - i and f.row = self.row - i)
)
)->exists( f | f.winner = Player::B )
)
then self.winner = Player::A
else self.winner = Player::B
endif
endif
Fig. 7.2 The one-tile-game as UML/OCL model
invariants as shown at the top of Fig. 7.2. For a board with x rows and y columns
the number of connected ﬁelds should be restricted by the product of rows and
columns. This is done by means of the invariant restrictFields. Since in
the One Tile Game, the tile can only be moved by 1 or 2 ﬁelds, validMoves is
restricted by the invariant restrictMoves. Because the values of row as well
as column of each ﬁeld are restricted and unique within a board, three additional
invariants for Board have been added. Altogether, the ﬁve invariants ensure that a
valid system state represents a board where all corresponding ﬁelds are properly
representing a board as required for the One Tile Game.
Next, invariants further restricting the set of valid system states are added. These
invariants enforce correct markings of the respective winners for each ﬁeld and are
provided at the bottom of Fig. 7.2. More precisely, restrictEndPositions is
added enforcing that, for each ﬁeld, endPosition is set to true if no valid
moves can be performed from this ﬁeld anymore or to false otherwise. The

7.2
Transformation of OCL Invariants and Resulting Problem
187
invariant andTheWinnerIs ﬁrst checks if the ﬁelds constitutes an end position;
then the winner must be Player::B. Otherwise, it is checked whether there is at
least one reachable ﬁeld with winner set to Player::B; then the winner must
be Player::A. If not, Player::B wins.
Passing the resulting class diagram together with its invariants to a model
ﬁnder eventually yields a valid system state representing various possible instances
of the One Tile Game and their respective marking of winners. However, the
SMT-based symbolic formulation described in this book and other model ﬁnders
signiﬁcantly suffer from OCL descriptions as depicted in Fig. 7.2 and, hence, are
hardly applicable particularly for large instances. In order to illustrate the problem
(and provide a solution), a more detailed look on how OCL invariants are handled
by state-of-the-art model ﬁnders is necessary.
7.2
Transformation of OCL Invariants and Resulting
Problem
In this section, the transformation of OCL invariants into an equivalent SMT-based
symbolic formulation (to be used for model ﬁnding as explained in Chap. 3) is
investigated in more detail. Based on this, it is shown afterwards how dedicated
OCL constraints may cause a “blow-up” of the resulting SMT formulation and,
hence, pose a serious obstacle to the efﬁciency of SMT-based model ﬁnding. By
this, the main problem which is considered in this section is illustrated. After that,
Sect. 7.3 introduces the proposed solution with which this problem is addressed.
7.2.1
Transformation of OCL Invariants
As explained in Chap. 3, the proposed SMT-based model ﬁnding ﬂow ﬁrst creates an
empty system state and from there a list of variables in order to represent all possible
system states symbolically. Considering the running example introduced in the
previous section, the empty system state of a corresponding symbolic formulation
for a 3  3 board is illustrated in Fig. 7.3. Since the assignment of all variables is
unknown prior to model ﬁnding, all values are as usual denoted by a “?”. Note that
the reference ends in this ﬁgure are handled by variables inside the objects, namely
fields or board, respectively. For details about how to derive the variables from
the empty system state, the reader is referred to Sects. 3.2.1 and 3.2.2. Further, note
that for the sake of convenience the 4-valued OCL will not be used, but again the
2-valued OCL which is handling regular values only.
Next, SMT constraints enforcing the invariants of the UML/OCL model to the
symbolic formulation are created. For the ﬁve invariants of class Board, this can
be conducted as described in Sect. 3.2.5. More precisely, the forAll iterations

188
7
Reducing Instance Sizes with Ground Setting Properties
Fig. 7.3 Symbolic
formulation for a 3 	 3 board
Field@0
row ←?
column ←?
endPosition ←?
winner ←?
board ←?
Field@1
row ←?
column ←?
endPosition ←?
winner ←?
board ←?
Field@2
row ←?
column ←?
endPosition ←?
winner ←?
board ←?
Field@3
row ←?
column ←?
endPosition ←?
winner ←?
board ←?
Field@4
row ←?
column ←?
endPosition ←?
winner ←?
board ←?
Field@5
row ←?
column ←?
endPosition ←?
winner ←?
board ←?
Field@6
row ←?
column ←?
endPosition ←?
winner ←?
board ←?
Field@7
row ←?
column ←?
endPosition ←?
winner ←?
board ←?
Field@8
row ←?
column ←?
endPosition ←?
winner ←?
board ←?
Board@0
rows ←?
columns ←?
validMoves ←?
ﬁelds ←?
in the invariants restrictRowValues and restrictColumnValues are
unfolded for all ﬁelds, i.e., the internal constraints are transformed nine times, while
the forAll with two iterators in the invariant uniqueRowColumn is unfolded
9  9 D 81 times. The size operation is internally transformed into j Fieldj C 1
constraints—each of them checks if for an i 2 f0; : : : ; j Fieldjg the board is
connected to exactly i ﬁelds. Listing 7.1 sketches the resulting SMT constraints
for the invariant restrictRowValues.
However, the symbolic formulation (which is based on [SoeC10, SWD11a]) will
reach its limits when transforming invariants of the class Field. In order to illustrate
that, let’s ﬁrst consider the invariant restrictEndPositions: Here, self.board
represents a reference of the connected board which is unknown prior to model
ﬁnding (since the precise connections are to be determined by a model ﬁnder).
Accordingly, a corresponding SMT formulation has to consider all possibilities.
Assuming that only one object of class Board is instantiated, this does not cause
a problem (since this would result in only one possible reference). But as soon
as Board would be instantiated multiple times, the number of possible references
quickly multiplies.
The consideration of all possibilities really becomes a problem when the access
of the attribute validMoves is transformed into SMT constraints. Again, the
precise value of this attribute is unknown prior to model ﬁnding. In principle, this set

7.2
Transformation of OCL Invariants and Resulting Problem
189
1 (and (=> (= ((_ extract 0 0) Board@0
fields ) #b1)
2
(and (bvule #x01 ˛Field@0
row
)
3
(bvule ˛Field@0
row
˛Board@0
rows
)))
4
(=> (= ((_ extract 1 1) Board@0
fields ) #b1)
5
(and (bvule #x01 ˛Field@1
row
)
6
(bvule ˛Field@1
row
˛Board@0
rows
)))
7
(=> (= ((_ extract 2 2) Board@0
fields ) #b1)
8
: : :)
9
: : :
10
(=> (= ((_ extract 8 8) Board@0
fields ) #b1)
11
(and (bvule #x01 ˛Field@8
row
)
12
(bvule ˛Field@8
row
˛Board@0
rows
))))
Listing 7.1 SMT constraints for the invariant restrictRowValues
1 (= ˛Field@0
endPosition
2
(and (ite (= ((_ extract 0 0) ˛Board@0
validMoves) #b1)
3
;
check
i f i D 0 i s
in validMoves
4
(and (or (bvult (bvsub ˛Field@0
row
#x00) ;
#x00 f o r i D 0
5
˛Field@0
row
)
6
(not (= (bvsub ˛Field@0
row
#x00)
7
#x00)))
8
(or (bvult (bvsub ˛Field@0
column
#x00)
9
˛Field@0
column )
10
(not ((= (bvsub ˛Field@0
column
#x00)
11
#x00)))))
12
true)
13
(ite (= ((_ extract 1 1) ˛Board@0
validMoves)
14
#b1) : : :)
15
: : :
16
(ite (= ((_ extract 255 255) ˛Board@0
validMoves)
17
#b1) : : :) ) )
Listing 7.2 SMT constraints for the invariant restrictEndPositions
can contain integers between 0 and 255 (assuming an integer is encoded with 8 bits).
For each of these possible integers, the internal OCL constraint must be transformed
into an equivalent SMT constraint. Afterwards, all these SMT constraints are
joined by an and expression and the result must be equal to self.endPosition.
For Field@0, this yields an SMT constraint as sketched in Listing 7.2.2 Since
such an SMT constraint enforcing the invariant restrictEndPositions has
to be created for all nine ﬁeld instances (with the 256 internal checks caused by the
unknown set), this easily “blows up” the resulting SMT instance—a serious problem
which signiﬁcantly degrades the performance of SMT-based model ﬁnding.
2Note that, in Listing 7.2, unsigned bit vectors have been used and, thus, the comparison looks a
bit different as in the corresponding OCL constraints.

190
7
Reducing Instance Sizes with Ground Setting Properties
The second invariant of Field, namely andTheWinnerIs, causes even more
problems. Consider here the condition of the inner if-then-else expression. First,
the correct reference of the board must be identiﬁed—this is similar to the ﬁrst
invariant. On top of that, the select-expression additionally has to consider all
possible ﬁelds. Within the scenario of the running example, this iteration should
only consider ﬁelds which are reachable by a valid move. In order to decide if a
ﬁeld is reachable by a valid move or not, an iteration over self.board.validMoves
and its up to 256 different values is required. Moreover, a constraint checking
whether Player::B wins the game for at least one of these selected ﬁelds has
to be added. Since which ﬁelds are selected here is unknown prior to model ﬁnding,
the constraints have to be generated for all ﬁelds.
7.2.2
Consequences and Resulting Problem
In the cases discussed above, a huge overhead in the SMT formulation is created. In
fact, already the running example considered here with a 33 board requires a total
of approx. 2 MB and 500 MB of memory to store the SMT formulations just for the
invariants restrictEndPositions and andTheWinnerIs, respectively.3
Here, the consideration of all possible cases, particularly for (nested) OCL navi-
gation and iterator expressions, poses a signiﬁcant obstacle to SMT-based model
ﬁnding. Similar observations can be made for other UML/OCL models relying on
navigation or iterator expressions on unknown large collections.
In contrast to that, most of the SMT constraints are never used by the applied
model ﬁnder. For example, as soon as the model ﬁnder concludes that the iteration of
validMoves only deﬁnes two ﬁelds because of the corresponding invariant (rather
than all 256 ones which are possible in general), a huge amount of the generated
SMT constraints is rendered to be irrelevant for further consideration.
The same happens as soon as the references between the ﬁelds and board as well
as the positions of the ﬁelds are assigned by the model ﬁnder—then, it becomes clear
which ﬁelds indeed are reachable from another ﬁeld. Hence, although a complete
and general SMT formulation is required in general, most of the constraints are not
required as soon as partial assignments, e.g., on validMoves and row/column
for the position, are applied.
Unfortunately, information on valid moves or reachable ﬁelds is not directly
available in the model as given in Fig. 7.2. However, the designer can easily assume
a dedicated structure which explicitly provides such information without harming
the generality of the model ﬁnding task. In fact, the order of the ﬁelds in the
running example is practically irrelevant as long as they are organized in a grid-
fashion. Employing such information could prevent the creation of a general SMT
3The ﬁles of the resulting SMT formulations are online available: http://informatik.uni-bremen.de/
agra/divers/gsp/.

7.3
Ground Setting Properties for Efﬁcient Transformation of OCL
191
formulation which generically considers all possible cases. Instead, it would help to
create only those SMT constraints which are actually needed in the model ﬁnding
process. To this end, the user has to provide additional information prior to the
automatic transformation from OCL to SMT.
On a ﬁrst glance, a partial system state might be a good solution to incorporate
those additional information in the transformation ﬂow. Unfortunately, this does not
satisfactorily address the problem. Using partial system states, the solving engine
can immediately satisfy huge parts of the resulting formulation (e.g., providing a ﬁx
structure of the board in the One-Tile-Game immediately satisﬁes the 5 invariants
of class Board and huge parts of the 2 invariants of class Field). However, although
they are immediately satisﬁed, simply not generating these constraints in the ﬁrst
place is not easily possible, since the generation procedure of the SMT constraints
for the OCL expressions does not have knowledge about which constraints are
affected by a partial system state. Hence, another solution is required.
7.3
Ground Setting Properties for Efﬁcient
Transformation of OCL
In this subsection, the concept of ground setting properties which enables the
designer to explicitly specify and provide the structure of a given model to be
considered during model ﬁnding is proposed. This additional information allows
for omitting huge parts of the SMT formulation and, hence, yields a signiﬁcantly
more efﬁcient model ﬁnding. In the following, ground setting properties themselves
and how to specify them is described. Afterwards, it is outlined how the generation
of an SMT formulation proﬁts from ground setting properties. Finally, the difference
of this concept compared to similar and related work is discussed.
7.3.1
Ground Setting Properties
As discussed above, the signiﬁcant overhead of the SMT formulation can be avoided
if additional information (e.g., about the structure) of the considered model is
explicitly given. In order to provide the model ﬁnder with this information, ground
setting properties are introduced in this section.
In addition to other existing properties which a model element  might already
have (such as, e.g., Changeable, Name, and Unsettable in EMF), it is proposed to
add a new property called ground setting by an annotation. Each ground setting
property of a model element  has one of the two Boolean values: If the values of all
instances of  can be assumed to have a ﬁxed value, then the ground setting property
is set to true (stating that additional information can be exploited when generating
the SMT formulation). If at least one value of an instance of  cannot be assumed

192
7
Reducing Instance Sizes with Ground Setting Properties
Table 7.1 Ground setting
properties for the running
example
Class
Model element
Ground setting property
Board
rows
✓
columns
✓
validMoves
✓
Field
row
✓
column
✓
endPosition
✗
winner
✗
Reference ﬁelds-board
✓
to have a ﬁxed value, then the ground setting property is set to false (stating
that the generic SMT formulation to be created has to consider all possibilities).4
In the former case (the ground setting property of  is set to true), the additional
information to be exploited has to be provided by corresponding values for each
instance of .
Example 60 Applying this concept to the running example, ground setting proper-
ties are set as summarized in Table 7.1, where ✓and ✗represent true and false,
respectively. The ground setting properties of the attributes rows, columns, and
validMoves of class Board can be set to true (because the designer usually
knows the sizes of the board to be considered as well as the value of the attribute
validMoves). Furthermore, the ground setting properties of the attributes row
and column of class Field can be set to true (because, without loss of generality,
the positions of the ﬁelds can be set). Finally, the ground setting property of the
reference between Board and Field is also set to true, because the designer knows
which ﬁelds are connected to which board. For all remaining model elements, the
ground setting properties are set to false—those are the attributes from which the
values should be determined by the model ﬁnder.
Besides that, additional information on the values for all model elements 
whose ground setting property is set to true has to be provided. Therefore, a
partial system state is used. Thanks to the ground setting annotation at the model
level, it is now possible to access the information on the partial system state during
the transformation from OCL to SMT; without the annotation for ground setting
properties, this would not be possible. For the running example, these values are
summarized in Fig. 7.4 (the links between objects are indicated by a connecting
line in the background). Overall, this provides more information which does not
signiﬁcantly harm the generality of the model ﬁnding task, but, as described next,
allows for a much more efﬁcient SMT formulation.
4Note that false is assumed as default value.

7.3
Ground Setting Properties for Efﬁcient Transformation of OCL
193
Fig. 7.4 Additional values
for the running example
Board@0
rows ←3
columns ←3
validMoves ←{1,2}
Field@0
row ←1
column ←1
endPosition ←?
winner ←?
Field@1
row ←1
column ←2
endPosition ←?
winner ←?
Field@2
row ←1
column ←3
endPosition ←?
winner ←?
Field@3
row ←2
column ←1
endPosition ←?
winner ←?
Field@4
row ←2
column ←2
endPosition ←?
winner ←?
Field@5
row ←2
column ←3
endPosition ←?
winner ←?
Field@6
row ←3
column ←1
endPosition ←?
winner ←?
Field@7
row ←3
column ←2
endPosition ←?
winner ←?
Field@8
row ←3
column ←3
endPosition ←?
winner ←?
7.3.2
Efﬁcient Transformation of OCL
Given the information from the subsection before, it is now possible to identify a
model element where the ground setting property is set to true. For those model
elements, the SMT formulation can immediately use the provided value instead of
unfolding it completely and causing the problems described in Sect. 7.2. Now it is
possible to directly use the respective value in the SMT formulation (of course it
must be mapped to a bit string before) rather than relying on an SMT variable. In
particular for (nested) OCL navigation and iterator expressions, this avoids the huge
enumeration of all possibilities.
Applying this to the running example, the values of the validMoves set are
given and, thus, the SMT formulation for the invariant restrictEndPositions
can now be shortened as sketched in Listing 7.3. Because of the same reason, also
the variables in the constraints, i.e., ˛Field@0
row
and ˛Field@0
column, for the two elements can
be replaced with its precise values. This is illustrated in Listing 7.4.
Already this yields substantial reductions. However, further optimizations can
be achieved since many arguments of SMT constraints become constant due to the
ground setting properties. This allows for pre-calculating the result of constraints
and the direct application in the SMT formulation. Iteratively applying these
pre-calculations to the constraint in Listing 7.4 ﬁnally yields the value true.
Analogously, the second constraint in Listing 7.3 can be optimized to true. Putting
both results together, the original SMT constraint from Listing 7.1 deﬂates to the one
shown in Listing 7.5.

194
7
Reducing Instance Sizes with Ground Setting Properties
1 (= ˛Field@0
endPosition
2
(and ( constraints for 1 )
3
( constraints for 2 ) )
4 ;
c o n s t r a i n t s
f o r
1:
5 (and (or (bvult (bvsub ˛Field@0
row
6
#x01)
7
˛Field@0
row
)
8
(not (= (bvsub ˛Field@0
row
9
#x01)
10
#x00)))
11
(or (bvult (bvsub ˛Field@0
column
12
#x01)
13
˛Field@0
column )
14
(not ((= (bvsub ˛Field@0
column
15
#x01)
16
#x00)))))
Listing 7.3 Optimized SMT constraints for the invariant restrictEndPositions
1 ;
c o n s t r a i n t s
f o r
1:
2 (and (or (bvult (bvsub #x01
3
#x01)
4
#x01)
5
(not (= (bvsub #x01
6
#x01)
7
#x00)))
8
(or (bvult (bvsub #x01
9
#x01)
10
#x01)
11
(not ((= (bvsub #x01
12
#x01)
13
#x00)))))
Listing 7.4 Additionally applying values
1 (= ˛Field@0
endPosition
2
true)
Listing
7.5 Completely
optimized
SMT
constraints
for
the
invariant
restrictEndPositions
7.4
Discussion and Related Work
Ground setting properties sufﬁciently address the problem of generating huge SMT
formulations for standard SMT-based model ﬁnding. However, other previously
proposed solutions may provide an alternative solution as well. The corresponding
related work is reviewed now. Further, it is discussed why they address the problem
considered here in an inadequate fashion only.

7.4
Discussion and Related Work
195
An obvious solution to the considered problem might be the utilization of partial
system states—without annotations for ground setting properties—which are also
used to provide the values for model elements when the ground setting property
is set to true. Instead of leaving all attributes and references un-assigned, the
designer could, e.g., provide a partial system state in which relevant model elements
(such as validMoves, rows, and columns of the class Board as well as the
attributes row and column of the class Field in the running example) are already
pre-deﬁned as done in Fig. 7.4. Then, e.g., for each attribute, a further constraint
is added which enforces the corresponding SMT variable to assume the respective
value. By this, information on the structure of the board would be known, but only
for the SMT solver and not for the transformation process from OCL to SMT—the
size of the SMT formulation would remain the same (in fact, the size would even
slightly increase). Moreover, even if additional information from the partial system
state would be exploited to improve the SMT formulation, many tools provide
default values. Those default values are a problem because for the OCL to SMT
transformation an internal system state (i.e., the empty system in the proposed
model ﬁnding ﬂow) of the model is generated and whenever one of the attributes
or references is used within OCL it is not possible to differentiate between a default
value (mostly null) and a real pre-assignment provided by the designer by a partial
system state or not. In other words, the values for attributes and relations in the
empty system are not really un-assigned with some kind of ˛  ?, instead the
provided default values always result in an assignment. Ground setting properties as
proposed in this work provide a solution which entirely avoids problems like that.
The UML-based speciﬁcation environment (USE) [GBR07] offers a so-called
model validator [KG12] which uses relation logic, Kodkod, Alloy, and SAT solvers.
The main ﬂow thereby is similar to SMT-based model ﬁnding, i.e., the USE
model validator uses Kodkod [TJ07] to transform the model, which itself uses
Alloy [Jac12] to eventually generate an equivalent SAT formulation to be solved.
This model validator allows for a restriction of the domain of each attribute before
starting with the complete transformation chain among other conﬁguration possi-
bilities. By this, the designer could, e.g., add useful information which restricts the
search space of the problem—similar to the ground setting properties proposed here.
However, so far it is not possible to pre-assign a speciﬁc attribute of a respective
class instance. Hence, the internal SAT constraints generated, e.g., for the nested
select-exists-exists in the inner condition of the invariant andTheWinnerIs
would cause a similar “blow-up” when increasing the number of Field instances
as in the SMT-based solution (this is also conﬁrmed by experimental evaluations
later in Sect. 7.5).
Finally, Kodkod [TJ07] internally supports symmetry breaking in order to avoid
permutations within the search space to be considered by the solver. This is a great
advantage compared to the approaches proposed in [SoeC10, SWD11c] where no
similar techniques have been used. However, to the best of our knowledge the “blow-
ups” as described earlier will not be avoided in the last transformation step (to SAT).
Hence, a similar problem as discussed in this work remains.

196
7
Reducing Instance Sizes with Ground Setting Properties
7.5
Implementation and Evaluation
The concept of ground setting properties has been implemented on top of the
existing Eclipse plugin. Here, UML/OCL models are represented in terms of the
Eclipse Modeling Framework (EMF). This environment is now brieﬂy reviewed
and it is described how the proposed concept has been realized and can be
used. Afterwards, the improvement of the performance which can be observed by
exploiting ground settings is evaluated.
7.5.1
Implementation
In order to apply the proposed solution, the existing Eclipse plugin using both,
Java and Xtend, has been re-used. As an SMT solving engine, Z3 [MB08] is
utilized again. This setting has been enriched by the proposed concept of ground
setting properties as described in Sect. 7.3. Eventually, this resulted in an extended
framework which enables designers to easily add and conﬁgure ground setting
properties as well as provide corresponding values.
Figure 7.5 exemplarily illustrates this for the considered model of the One-Tile-
Game. In Fig. 7.5a the emf ﬁle of the One-Tile-Game is shown for the general
model ﬁnding approach. This means that no ground settings properties are present.
Fig. 7.5 One-tile-game model in the EMF format. (a) Without ground setting properties. (b) With
ground setting properties

7.5
Implementation and Evaluation
197
Fig. 7.6 A visualization of the XMI ﬁle showing also the properties of the Board instance
However, in order to add and conﬁgure a ground setting property, the designer must
only add the following line in the text editor before a model element:
@ModelFinder(groundSettingProperty="true")
The result for the One-Tile-Game model is depicted in Fig. 7.5b. If the designer
prefers to work on the ecore ﬁles of the EMF, the same results can be achieved
with the Sample Ecore Model Editor provided by the EMF itself. There, the
annotations can be added and conﬁgured with some clicks only.
The corresponding values can afterwards be provided using the XMI format
which enables designers to declare a (partial) system state. The provided system
state implicitly includes problem bounds for the number of objects to be instantiated
for each class. Such an XMI ﬁle can be created using the editors provided by the
EMF—the precise details can be analyzed and changed using, e.g., the Sample
Reﬂective Ecore Model Editor as shown in Fig. 7.6.
7.5.2
Evaluation
Now, the performance of SMT-based model ﬁnding with ground setting properties
is compared to the performance of the original approach. In addition to that,
comparisons to the USE model validator with restricted domains as discussed in
Sect. 7.4 are conducted.
For the SMT-based model ﬁnding, the implementations have been applied within
Eclipse in version Mars.2. For USE, version 4.2.0-465 with version 5588 of the
model validator has been used. All experiments have been carried out on an Intel i5
with 2.6 GHz cores and 8 GB memory using a Windows 7 64 bit and a Java 64 bit
installation.

198
7
Reducing Instance Sizes with Ground Setting Properties
Table 7.2 Size of resulting SMT formulations
Field size
3 	 3
4 	 4
5 	 5
10 	 10
20 	 20
30 	 30
Without gr. set. prop.
491.0 MB
3.4 GB
MO
MO
MO
MO
With gr. set. prop.
7.4 kB
13.8 kB
22.4 kB
96.1 kB
403,9 kB
936.5 kB
5×5
10×10
15×15
20×20
25×25
30×30
35×35
0
15,000
10,000
5,000
20,000
Field Size
Run Time
SMT-based + gr. set. prop.
general SMT-based (old)
USE model Validator
Fig. 7.7 Run times for different board sizes
In a ﬁrst evaluation, the sizes of the obtained SMT formulations are considered.5
Table 7.2 provides the obtained numbers for the running example with several
board sizes. Here, the problem investigated in Sect. 7.2 can clearly be seen. Since a
general formulation is created which considers all possibilities, a “blow-up” in the
SMT formulation results. Already for rather tiny boards gigabytes of memory are
consumed by the formulation; board sizes of just 5  5 could not even be handled
because of memory limitations. In contrast to that, just some kilobyte of memory is
required once ground setting properties are applied and exploited.6
In a second experiment, the run times of the considered approaches have been
compared. Figure 7.7 provides the resulting numbers in terms of three plots: the
brown one show the run times when applying the USE model validator while the
red and blue one shows the run times when applying the proposed SMT-based model
ﬁnder without and with ground setting properties, respectively. The x-axis provides
the size of the board, while the y-axis provides the run time in CPU seconds. Also
5Since the USE model validator does not provide any information on the size of the resulting SAT
instance, only SMT-based model ﬁnding is considered in this part of the evaluation.
6Note that, without calculating the size of the SMT instance, the general SMT-based model ﬁnder
was capable of determining solutions for 5 	 5 and 6 	 6 as well (but approached its limits for
problems sizes of 7 	 7 or larger).

7.5
Implementation and Evaluation
199
this evaluation clearly shows the superiority of the proposed approach. While the
SMT-based model ﬁnder hardly can be applied even for rather tiny instances (which
is not surprising considering the size of the SMT formulation as covered above),
the USE model validator is, after all, capable of handling board sizes up to 15 
15. However, both approaches are clearly outperformed by the proposed approach
with ground setting properties which can even handle a 36  36 board in less than
20,000 s.
Overall, it has been recognized that for the One-Tile-Game the main effort for
the transformation with ground setting properties and its optimization made use of
99.9 % of the run time. The solving time for all board sizes was under 1 s. For the
USE model validator the transformation and solving heavily depends on the board
size.

Chapter 8
Re-utilizing Veriﬁcation Results of UML/OCL
Models
The previous chapters have shown the wide-ranging applicability of the symbolic
formulation from Chap. 3. This formulation has been exploited to tackle various
validation and veriﬁcation tasks for structural, behavioral, and timing aspects of
models. In the previous chapter, it has even been used to solve problems from other
domains. In this chapter, the focus is on the question how the results from the model
level can be transferred to the next lower level in the design ﬂow.
The formal model level has been proposed as another abstraction level in the
design of nowadays systems to cope with their complexity. It provides a good
abstraction and a formal base to apply formal methods—as, e.g., presented in
the previous chapters. However, this book has not dealt with the next lower
abstraction level so far: the implementation level. For the implementation level, the
(veriﬁed) models provide a precise blueprint to be realized. While they can even
be used to generate corresponding code stubs or initial implementations, a manual
reﬁnement is usually required afterwards. Due to this manual process, new errors
might be introduced, i.e., an implementation might violate constraints that have
been deﬁned before. This motivates approaches which verify an implementation
against its formal models (as recently considered, e.g., in [SWD14]), because if an
implementation does not realize the formal model then the designer would have
wasted his time with validation and veriﬁcation of the formal model.
Although impressive progress has been made in this regard, most of the
veriﬁcation approaches only consider single abstraction levels, i.e., either the
correctness/consistency of formal models or of (initial) implementations. While
those are important contributions, a gap between these two abstraction levels
remains. This issue is addressed in this chapter. More precisely, in Sect. 8.1 the
current state-of-the-art of validation and veriﬁcation approaches (including the
ones presented in this book) are applied in a case study (taken from [PrzC15c]).
Furthermore, how they can adequately be used within a two-level methodology
is considered. This unveils open issues which are addressed in Sect. 8.2 (based
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8_8
201

202
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
on [AleC17]). There, it is shown how an implementation can be veriﬁed against
its model and, by this, results from the UML/OCL level can be transferred to the
implementation level.
8.1
What Can Be Veriﬁed Where?—A Case Study
The focus of this section relies on a case study in which errors are tried to be detected
as soon as possible in the design ﬂow. For this purpose, the initial steps of the design
ﬂow are considered by means of a small practical example: the access control system
(inspired by [Abr99]). Starting with a textual speciﬁcation, both the creation of a
formal model and an initial implementation are considered—with a constant focus
on validation and veriﬁcation.
The case study illustrates the capabilities of the respective approaches and
clearly shows which checks can be conducted best at which level. Furthermore, it
demonstrates how an initially given model that may appear correct at a ﬁrst glance
can be improved throughout the design process and eventually be realized as a
(correct) implementation. By this, the advantages and shortcomings of veriﬁcation
methods solely proposed for models and implementations are discussed in the
context of a veriﬁcation-driven design across abstraction levels. This unveils open
issues which are addressed in the next section.
8.1.1
Considered Access Control System
The model of the access control system has been used several times in this book.
However, now, we consider this system in a bit more detail. The speciﬁcation of the
access control system has originally been presented in [Abr99] in the context of an
open challenge: The different model languages of that time should demonstrate their
possibilities by obtaining a model in a ﬁrst step. Here, the goal is to ﬁrst develop a
UML/OCL model based on the speciﬁcation of the access control system which
grants access to buildings based on a person’s authorization. This authorization is
based on the ID of a magnetic card each person receives. Each building is equipped
with turnstiles and card readers to check the card upon entry or exit. The derived
model will differ from former presentations in this book and will contain ﬂaws
which will be identiﬁed and ﬁxed step by step using the approaches presented in
the last chapters and other ones.
In addition to this rather general description of the scenario, [Abr99] provides a
more detailed list of requirements to be realized which reads as follows.
1. Each person is given permanent authorization to enter certain buildings.
2. Entry and exit must be controlled by the system so that at any point, it is known
which person is inside which building.

8.1
What Can Be Veriﬁed Where?—A Case Study
203
Fig. 8.1 Access protocol of
the control system
Turnstile
blocked
Insert card
into reader
Green light on;
turnstile open
for 30 seconds
Red light on
for 2 seconds;
turnstile blocked
Turnstile passed OR 30 secs are over
3. Each person possesses a magnetic card where a unique ID is stored. Access to
buildings is controlled based on this ID.
4. At each entrance and exit of a building, a card reader is installed to check a
person’s magnetic card.
5. Each card reader is equipped with two lights, red and green, which can be turned
on and off and are used to signal if the inserted card’s owner is authorized to
enter/leave the building.
6. Aside from card readers, each entrance/exit is also equipped with a turnstile.
7. Turnstiles are blocked until someone is allowed to pass based on the check of the
person’s card.
8. As each entrance and exit has its own turnstile, there are no two-way turnstiles to
be used for both purposes.
Figure 8.1 sketches the access protocol to be implemented. A person approaches
a blocked turnstile to enter or leave a building. When the card is inserted into the
card reader, it is checked for the person’s authorizations. If the person is allowed
to enter or leave the building, then the green light turns on and the turnstile is open
for at most 30 s. Upon expiry of the 30 s or once someone passes the turnstile, the
green light is switched off and the turnstile is blocked again. If the person is not
authorized for this building, then the red light is turned on for 2 s and the turnstile
remains blocked.
8.1.2
Resulting Model
The model derived from the speciﬁcation is shown in Fig. 8.2. It is composed of
three classes which represent its main components, i.e., Buildings, MagneticCards,
and Turnstiles. These components are modeled as follows.
•
The class MagneticCard represents the magnetic card and consists of one integer
attribute id which represents the unique ID. A magnetic card is possessed and
used by a person (cf. Req. 3 Sect. 8.1.1).
•
The class Building represents the considered buildings and consists of the two
attributes authorized and inside. The attribute authorized is a set of

204
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
Turnstile
greenLightOn: Boolean
redLightOn: Boolean
currentlyAuthorized: Integer
timeOpen: Integer
type: TurnstileType
goThrough()
advanceTime()
checkCard(card : MagneticCard)
≪enum≫
TurnstileType
Entry
Exit
Building
authorized: Set(Integer)
inside: Set(Integer)
MagneticCard
id: Integer
gates
2..∗
building
1
inv atLeastOneEntry:
gates->exists( t | t.type = #Entry)
inv atLeastOneExit:
gates->exists( t | t.type = #Exit)
inv uniqueID:
MagneticCard.allInstances()->forAll(
card1, card2 |
(card1 <> card2)
implies (card1.id <> card2.id)
)
context Turnstile::advanceTime():
pre :
greenLightOn = true
or redLightOn = true
post : (
(
( timeOpen@pre < 2 )
or ( redLightOn = false ) )
and ( timeOpen@pre < 30 )
) implies ( timeOpen = timeOpen@pre + 1 )
post : (
( timeOpen@pre >= 2 )
and redLightOn
) implies
(
( timeOpen = 0 )
and ( redLightOn = false ) )
post : (timeOpen@pre >= 30)
implies
(
( timeOpen = 0 )
and ( greenLightOn = false ))
context Turnstile::checkCard(card : MagneticCard):
pre : greenLightOn = false
pre : redLightOn = false
post :(
( building.authorized->includes(card.id) )
and ( type = #Entry <> building.inside->includes(card.id) )
) implies
(
greenLightOn = true
and currentlyAuthorized = card.id)
post : (not ( building.authorized->includes(card.id) ) )
implies
(redLightOn = true)
context Turnstile::goThrough():
pre : greenLightOn = true
post :(
( building.inside@pre->includes(currentlyAuthorized) )
and ( type = #Exit )
) implies
( not building.inside->includes(currentlyAuthorized) )
post :(
( not building.inside@pre->includes(currentlyAuthorized) )
and ( type = #Entry )
) implies
( building.inside->includes(currentlyAuthorized) )
post : greenLightOn = false
post : timeOpen = 0
Fig. 8.2 Class diagram of the access control system
integers storing the IDs of all cards with which the building can be entered or left
(cf. Req. 1 Sect. 8.1.1). The attribute inside is a set of integers which is used to
store the IDs of all persons currently inside the building (cf. Req. 2 Sect. 8.1.1).
Both attributes are directly derived from Req. 1 in Sect. 8.1.1.
•
The class Turnstile represents the entries/exits of the buildings. The card readers
mentioned in Req. 4 and 5 in Sect. 8.1.1 and the turnstile are combined into a
single class Turnstile as indicated in Req. 6. It consists of ﬁve attributes and three
operations. While the Boolean attributes greenLightOn and redLightOn

8.1
What Can Be Veriﬁed Where?—A Case Study
205
represent the state of the respective lights, the enum data type attribute entry
states if the corresponding turnstile is an entry port or an exit port. The integer
attribute currentlyAuthorized stores the ID of the last magnetic card
which has been inserted into the reader. The attribute timeOpen, also an integer,
represents an internal clock to realize the timing constraints of the system.
The classes Turnstile and Building are connected by an association ensuring that
each instance of class Building is connected with at least two Turnstile instances.
A Turnstile instance can only (and has to) be a part of one Building object. The
invariant uniqueID ensures that the IDs of all MagneticCards are unique as
deﬁned in Req. 3 in Sect. 8.1.1.
The behavior of the three operations of the class Turnstile is deﬁned by means of
pre- and postconditions as follows.
•
The operation checkCard checks whether a person inserting a MagneticCard
may pass the respective turnstile. It receives a MagneticCard instance as
parameter and can only be called if both lights are switched off in the current
system state. If the ID of the magnetic card is included in the set of authorized
IDs for the associated building, the green light is switched on and the ID of the
currently inserted card is stored. Otherwise, the red light is switched on.
•
The operation advanceTime realizes the timing constraints stated in the
speciﬁcation. It can only be called if one of the lights is switched on and increases
the timeOpen attribute until its respective limit, depending on the state of the
lights, has been reached. Then, the clock is reset and the respective light is
switched off.
•
The operation goThrough allows the currently authorized person to pass the
turnstile and, by this, to enter or to leave the associated building. This operation
can only be called if the green light is switched on. After execution, the respective
ID is added to or removed from the set of IDs currently registered inside the
building. Besides that, the green light is switched off and the clock is reset.
The resulting model could be considered to sufﬁciently represent the original
speciﬁcation from Sect. 8.1.1 and an implementation engineer could start imple-
menting the given features. However, since this model already provides a formal
description, it can be used to determine if any meaningful implementation exists
at all or if the model needs to be revised. Hence, before actually starting the
implementation, a selection of possible checks is conducted as a next design step.
8.1.3
Veriﬁcation of the Model
Possible directions for the veriﬁcation of models usually address two major
concerns: Do the given model and all of its constraints allow for a valid instanti-
ation/implementation (also known as checking structural aspects, see also Chap. 4)
and does the given model describe the desired behavior (demanding behavioral
aspects, see also Chap. 5))? In the case study, both types are considered.

206
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
These kinds of veriﬁcation problems, however, are undecidable when applied
to an unbounded model which is the case for UML models. Datatypes such as
integers have no upper or lower bound, the number of objects is not bounded,
etc. To solve this issue, problem bounds as described in Sect. 3.1 are applied for
bounded veriﬁcation. They restrict the concerned aspects, making the veriﬁcation
tasks decidable. Since the eventual implementation will be bounded as well, these
limitations are not too strict.
Consistency Checking
Checking the feasibility of a given model, it is essential to know whether
at least one arbitrary system state satisfying all constraints provided by the
model can be instantiated. If this is the case, the model is called consistent
(cf. Deﬁnitions 2.13, 3.1, and 3.2). Otherwise, the model contains contradictory
constraints which prevent a valid instantiation—the model is inconsistent (cf. Deﬁ-
nitions 2.13, 3.1, and 3.2). In case of any inconsistencies, the model has to be revised
prior to the implementation process because no implementation precisely realizing
the model’s constraints can result in an instantiable system.
In order to conduct such a consistency check, different approaches have been
proposed in the past. They have already been discussed in detail in Sect. 3.4 and
all of them are, in principle, sufﬁcient for checking structural aspects, likewise, the
proposed symbolic formulation is.
To conduct the most basic consistency check, the symbolic formulation has
been used to determine a valid system state where at least one class is instantiated
(cf. Deﬁnition 3.1). More precisely, an SMT-LIB problem for a system state where
the number of instances per class may vary from 0 to 5 is generated. This results in
the (valid) system state shown in Fig. 8.3.
While this system state proves that the considered model is not self-contradictory,
it does not provide a sufﬁcient witness for our scenario as no instance of the class
MagneticCard was created. If someone is going to implement an access control
system based on this model, he should be certain that there is at least one magnetic
card to be used by a person. Hence, a slightly modiﬁcation of the conﬁguration
of the consistency is applied. Now, the generation of a system state where all
classes are instantiated at least once—including the MagneticCard—is enforced
(cf. Deﬁnition 3.2).
This consistency check, however, turns out to be failing, i.e., there is no valid
system state in which all classes are instantiated at least once. This information
Building0:Building
authorized =
inside =
Turnstile0:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = 0
timeOpen = 0
entry = Exit
Turnstile1:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = 0
timeOpen = 0
entry = Entry
Fig. 8.3 A valid system state

8.1
What Can Be Veriﬁed Where?—A Case Study
207
is important: Although the model described in Sect. 8.1.2 seemed complete and
correct at a ﬁrst glance, it obviously includes a serious ﬂaw. Without conducting
consistency checks at this early stage in the design ﬂow, this ﬂaw might have
remained undetected until the completion of a ﬁrst implementation. Applying
veriﬁcation-driven design, which employs correctness checks as early as possible,
avoids the resulting large debugging effort and the equally expensive revision of
both the model and the implementation.
So far, the reason for the detected ﬂaw is still unknown. But just like for the
veriﬁcation, automated methods may help here. A signiﬁcant body of research has
recently been conducted aiming at supporting engineers in debugging inconsistent
models (see Sect. 4.1.2 for details). Based on the current conﬁguration of the
(failed) consistency check, the approach described in Sect. 4.1 automatically
generates all minimal reasons, i.e., minimal subsets of UML/OCL constraints which
might explain the contradiction. Inspecting these subsets signiﬁcantly simpliﬁes the
identiﬁcation of the ﬂaw’s origin.
In the present case, these approaches return the invariant uniqueID as the only
reason. A more detailed look unveils that this invariant indeed is self-contradictory:
The iterator of the forAll-operation also checks card1.id <> card2.id for card1 and
card2 being the same object. This means that the ID of a magnetic card has to be
different from itself which is impossible. With this information, the engineer can
easily ﬁx this problem by revising this invariant to
context MagneticCard inv uniqueID:
MagneticCard.allInstances()->forAll( card |
(self <> card) implies (self.id <> card.id)
)
Performing the consistency check with the revised model now leads to a valid
system state including instantiations for all classes. This is a promising indication
that the considered model indeed is a proper representation of the structure of the
desired system.
Behavior Checking
The checks from above validated that an implementation of the model from
Sect. 8.1.2 exists, i.e., an instantiation in the form of a consistent system state of
the access control system exists. Now, it remains to be checked whether such an
implementation would also realize the desired behavior. For this purpose, automatic
approaches of Sect. 3.4 and Chap. 5 are applied. Of course, other approaches for
behavioral aspects (cf. Sect. 3.3.2) can also be used. Overall, this allows for the
consideration of several behavioral veriﬁcation tasks.
To ensure that any kind of dynamic behavior is possible in the model, the goal
is to check the executability of the model, i.e., is it possible at all to conduct a
sequence of (arbitrary) operation calls on an instantiation. More precisely, it is tried
to determine a sequence of (valid) system states with valid operation calls between
two successive system states—i.e., each transition has to include a calling state
satisfying the precondition as well as a succeeding state satisfying the postcondition

208
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
Building0:Building
authorized = {1}
inside = {1}
Turnstile0:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = 0
timeOpen = 0
entry = Entry
MagneticCard0:MagneticCard
id = 1
Turnstile1:Turnstile
greenLightOn = false
redLightOn = false
currentlyAuthorized = 0
timeOpen = 0
entry = Entry
Fig. 8.4 A deadlock system state
of the respective operation call. This is an important check: if a model does not
allow an arbitrary sequence of operation calls, all further checks are rendered
meaningless. Using the symbolic formulation with its behavioral veriﬁcation tasks
(cf. Sect. 3.3.2), it can be proven that about a dozen of consecutive arbitrary
operation calls indeed can be conducted on the model presented in Sect. 8.1.2
(including the already mentioned corrections).
Still, the question remains whether the operation calls are performed as intended
or whether certain unwanted states can be reached. Other, more reﬁned, checks
focus on the evaluation of these issues. Guaranteeing that the model does not allow
for any deadlocks is such an issue. This can be formulated as the query “Does
the model allow for a system state in which no further operation calls can be
performed due to violated preconditions or an invalid subsequent system state?”
The approaches mentioned above can handle such queries and, in our case, generate
such a system state as illustrated in Fig. 8.4.
Here, none of the possible operation calls can be performed without violating a
constraint:
•
In order to invoke advanceTime, either greenLightOn or redLightOn
must be set to true. For both Turnstile instances, both elements are set to
false in the system state shown in Fig. 8.4.
•
In order to invoke goThrough, greenLightOn must be set to true. Again,
this is not the case for both Turnstile instances in the system state shown in
Fig. 8.4.
•
In order to invoke checkCard an instance of the class MagneticCard is required
which is either inside the building in case of an exit turnstile or outside the
building in case of an entry turnstile. But since both instances of the class
Turnstile are set to represent entries, the MagneticCard is identiﬁed as
inside the building and, thus, the operation cannot be invoked due to failed
preconditions.
In addition to detect a deadlock state (as intended by this check), another serious
design ﬂaw has been unveiled. While the association between Turnstile and Building
requires that each building has at least two turnstiles, it is not guaranteed that there
is always one Entry and one Exit—even though the relation 2:: was intended

8.1
What Can Be Veriﬁed Where?—A Case Study
209
for this. Having the unwanted system state shown in Fig. 8.4, a designer can identify
this problem manually and resolve it by adding the following invariant to the class
Building:
context Building
inv atLeastOneEntry :
self.gate->exists( g | g.entry)
inv atLeastOneExit :
self.gate->exists( g | not (g.entry) )
This also resolves the deadlock problem.
Knowing that the model is executable and how deadlock states can be detected,
another important aspect of behavioral models shall be considered: frame condi-
tions. Frame conditions describe which model elements may change during the
transition from one system state to another, triggered by an operation call. They
are important because, thus far, only pre- and postconditions restrict the respective
calling and succeeding states—allowing for plenty of arbitrary and unwanted
changes.
For example, during the execution of checkCard, which requires a Magnetic-
Card instance as a parameter, the ID of the MagneticCard could change although
this is not an intended behavior and should be prohibited. To this end, the OCL
command modifies only representing an invariability clause has been proposed
in [Kos06, Kos13] (see also Sect. 5.1). For each operation, this command allows
to declare a list of all model elements which might be modiﬁed in combination with
a scope. All other model elements are assumed to keep their respective values.
For the operation checkCard, deﬁning the invariability clauses can be
conducted based on the following considerations: The values of the elements
self.greenLightOn and self.redLightOn indicate whether the check of the magnetic
card was successful or not. The element self.currentlyAuthorized stores the ID
of the magnetic card which has just been checked for authorization. Consequently
changes of their values do make sense and all three elements have to be added to the
set of invariability clauses. In contrast, the element self.timeOpen, which is never
used in the postconditions, should not be affected by this operation and, hence, not
be added to an invariability clause. This applies to all elements which do not occur
in a postcondition. The remaining model elements mentioned in the postconditions
require further inspection: self.entry is used in the postcondition, but a change of
its value would change the direction of the turnstile—clearly an undesired behavior.
Therefore, self.entry is not added to the invariability clause. In the same way,
the designer decides that changes of self.building, self.building.authorized, and
self.building.inside are not desired and, thus, they are not added to the invariability
clause. Frame conditions for all other operations are deﬁned similarly.
Obviously, deﬁning these frame conditions is a highly manual approach thus far.
Since a great deal of design understanding has to be considered for this purpose, it
is unlikely that fully automatic methods will ever be able to completely handle this
task. Nevertheless, ﬁrst methods aiming for aiding this process are currently under
consideration (cf. [NieC15a, NieC15b]). Here, automatic analyses are performed

210
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
which lead to suggestions for the respective classiﬁcations of the model elements.
While the designer has to make the ﬁnal decision on the frame conditions, these
classiﬁcations may already provide a good starting point.
After adding all frame conditions, an operation of the model is clearly more
restricted than before and, thus, it is advisable to re-run all the behavioral checks
conducted thus far again. (In Sect. 5.1 the details of the integration of frame
conditions to the symbolic formulation are described.) Considering the updated
model, all these checks passed. As a consequence, a signiﬁcantly improved model
has been gained which has been stripped from its ﬂaws and additionally provides a
more precise deﬁnition of its behavior.
Now, it would be advisable to conduct further, more application-speciﬁc checks,
e.g., is it somehow possible to access a building with a magnetic card without
authorization or is it possible to register one ID of a magnetic card in more than
one building at the same time, etc. All these queries can be checked in a similar
fashion as done above for executability or deadlocks: The respective desired/bad
states and a bounded sequence of arbitrary operation calls are conﬁgured. Then,
approaches such as [SWD11c, GogC14] or the presented symbolic formulation can
be applied to determine a corresponding sequence or to prove that no such sequence
exists. Whenever the model is considered as sufﬁciently checked, it can be passed
to the next stage of the design ﬂow for an implementation.
Overall, the veriﬁcation-driven design of the model as sketched above leads to a
signiﬁcant improvement in the quality of the resulting model. Although the model
as described in Sect. 8.1.2 may have appeared correct at ﬁrst glance, it included a
signiﬁcant number of ﬂaws and/or imprecisions that would have complicated the
implementation process or, in the worst case, would have led to an implementation
which would not satisfy the described requirements. Using the methods exemplarily
discussed above and described in detail in the respective section of this book allowed
for avoiding these ﬂaws/imprecisions and has led to a much more mature model.
Note that this still is no guarantee that all ﬂaws/imprecisions are detected—but
chances for these are signiﬁcantly reduced.
8.1.4
Implementation of the Model
After the formal model is considered complete and veriﬁed, the implementation
process follows, i.e., the generation of a working, executable realization of the
given model. As this is mostly conducted manually, this design step provides
another source of errors. Hence, after completing the implementation, it is necessary
to validate the result against the original formal model. In this section, the
corresponding design steps are considered. To this end, the access control system
speciﬁed in Sect. 8.1.1 and modeled in Sect. 8.1.2 is implemented in C++.
The implementation derived from the model introduced in Fig. 8.2 and revised
in Sect. 8.1.3 is shown in Listing 8.1:

8.1
What Can Be Veriﬁed Where?—A Case Study
211
1 # include <iostream >
2 # include <algorithm >
3 # include < s t r i n g >
4 # define NUM_AUTH 32
5
6 c l a s s
S t r u c t u r e
{
7 public :
8
s t r i n g
m_name ;
9
s t r i n g
name ( )
{ return m_name ;}
10
S t r u c t u r e ( s t r i n g
p_name ) { this >m_name = p_name ;}
11 };
12
13 c l a s s
MagneticCard :
S t r u c t u r e
{
14 public :
15
i n t
id ;
16
s t a t i c
i n t
currentMaxID ;
17
MagneticCard ( s t r i n g
p_name ) : S t r u c t u r e ( p_name ){
18
this >id = currentMaxID ++;
19
}
20 };
21
22 i n t
MagneticCard : : currentMaxID = 0;
23
24 c l a s s
Building ;
25
26 c l a s s
T u r n s t i l e :
S t r u c t u r e
{
27 public :
28
bool
greenLightOn ;
29
bool
redLightOn ;
30
i n t
c u r r e n t l y A u t h o r i z e d ;
31
i n t
timeOpen ;
32
bool
e n t r y ;
33
Building b u i l d i n g ;
34
T u r n s t i l e
( s t r i n g
p_name ) :
S t r u c t u r e ( p_name ) { }
35
void
checkCard ( MagneticCard card ) ;
36
void
advanceTime ( ) ;
37
void
goThrough ( ) ;
38 };
39
40 c l a s s
Building :
S t r u c t u r e
{
41 public :
42
i n t
a u t h o r i z e d [NUM_AUTH] ;
43
bool
i n s i d e [NUM_AUTH] ;
44
T u r n s t i l e  g a t e s ;
45
Building
( s t r i n g
p_name ) :
S t r u c t u r e ( p_name ) { }
46
bool
a u t h o r i z e d I n c l u d e s ( i n t
value ) ;
47
bool
i n s i d e I n c l u d e s ( i n t
value ) ;
48 };
Listing 8.1 C++ implementation of model

212
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
1 bool
Building : : a u t h o r i z e d I n c l u d e s ( i n t
value ) {
2
i n t begin = a u t h o r i z e d ;
3
i n t end = a u t h o r i z e d + NUM_AUTH;
4
i f
( end == s t d : : f i n d ( begin ,
end ,
value ) )
{ return
f a l s e ;}
5
return
true ;
6 }
7
8 bool
Building : : i n s i d e I n c l u d e s ( i n t
value ) { return
i n s i d e [ value ] ; }
9
10 void
T u r n s t i l e : : checkCard ( MagneticCard card ) {
11
i f
( ! this >greenLightOn && ! this >redLightOn ) {
12
i f
( this >building >a u t h o r i z e d I n c l u d e s ( card >id ) &&
13
this >e n t r y
!= this >building >i n s i d e I n c l u d e s ( card >id ) )
{
14
this >greenLightOn = true ;
15
this >c u r r e n t l y A u t h o r i z e d = card >id ;
16
}
e l s e
i f
( ! this >building >a u t h o r i z e d I n c l u d e s ( card >id ) )
{
17
this >redLightOn = true ;
18
}
e l s e
{ }
19
}
e l s e
{ }
20 }
21
22 void
T u r n s t i l e : : advanceTime ( )
{
23
i f
( this >greenLightOn
| |
this >redLightOn ) {
24
this >timeOpen ++;
25
i f
( this >timeOpen >= 2 && redLightOn ) {
26
this >timeOpen = 0;
27
this >redLightOn = f a l s e ;
28
}
29
i f
( this >timeOpen >= 30) {
30
this >timeOpen = 0;
31
this >greenLightOn = f a l s e ;
32
}
33
}
e l s e
{ }
34 }
35
36 void
T u r n s t i l e : : goThrough ( )
{
37
i f
( greenLightOn ) {
38
i f
( this >building >i n s i d e I n c l u d e s ( this >c u r r e n t l y A u t h o r i z e d )
39
&& ! e n t r y ) {
40
this >building >i n s i d e [ c u r r e n t l y A u t h o r i z e d ] = f a l s e ;
41
}
e l s e
i f
( ! this >b u i l d i n g
42
>i n s i d e I n c l u d e s ( c u r r e n t l y A u t h o r i z e d )
43
&& e n t r y ) {
44
this >building >i n s i d e [ c u r r e n t l y A u t h o r i z e d ] = true ;
45
}
46
this >greenLightOn = f a l s e ;
47
this >timeOpen = 0;
48
}
e l s e
{ }
49 }
Listing 8.1 (continued)

8.1
What Can Be Veriﬁed Where?—A Case Study
213
•
Lines 1–3 specify packages which are referenced in the implementation to keep
the example self-contained and working.
•
Line 4 contains a preprocessor directive: The NUM_AUTH identiﬁer is replaced
with the given replacement value (32 in this case) before compilation. In this
case, this leads to a given maximum amount of cards that are allowed to be inside
a building. This already means that, in contrast to the model which does not
specify any size on the given sets, this implementation has been reﬁned to only
allow up to a certain number of values to be added to the according sets.
•
Lines 6–11 introduce a common base class for all other classes that gives each
of them a name, making it easier to, e.g., have readable feedback from the
application later on.
•
Lines 13–46 introduce the classes that were speciﬁed in Fig. 8.2. Fields are
named accordingly. Due to using C++, methods are declared in the class
declaration parts but are implemented later. Line 24 is a forward declaration
to enable the Turnstile class to reference the Building class before the latter is
declared below.
•
Lines 48–55 implement functions to check whether or not the given sets include
certain elements. These functions have not been speciﬁed before but they are
implicitly part of the OCL constraints that allow checking sets for the inclusion
of elements.
•
Lines 57–95 ﬁnally implement the functions that have been speciﬁed to be part
of the Turnstile class. Note that each function follows the pattern of starting with
an if-clause which tests the preconditions given in the formal model. If these
conditions are not met, the else{} statement at the bottom leaves the program’s
state untouched while exiting the function. This ensures that a function call with
unsatisﬁed conditions does not result in an unspeciﬁed program state. The ﬁrst
block of the if clause contains further if clauses implementing the various
implies postconditions from the model.
Having this implementation, the question remains whether or not it actually
implements the formal model, no matter how close it seems to be to the model.
8.1.5
Comparison to the Formal Model
In order to compare the implementation to its model, the program’s features need to
be available. In particular for languages such as C++, extracting the respectively
required information is not straightforward. In fact, C++ has a strong focus on
performance. Thus, compilers usually strip as much information as possible from
the code when it is translated into a (natively) executable ﬁle. Additionally, C++ is
not easy to parse. Over the last decades, several dialects have emerged which are
supersets of the standardized core language—each offering slightly different tools
and frameworks. Hence, before an actual comparison can be conducted, essential
features of the implementation need to be extracted ﬁrst.

214
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
Fig. 8.5 C++ information
extraction
Source
Code
Binary
exe-
cutable
Debug
symbols
Program
state
Static inf.
1
Dynamic
inf.
2
3
4
FSL spec.
5
Extracting the Features from the Implementation
Due to the reasons mentioned above, C++ offers no support for reﬂection and
introspection. Hence, the respectively required information needs to be extracted
directly during the compilation process. The approach presented in [SWD13] offers
a methodology for this purpose, which exploits debugging symbols generated by
an off-the-shelf compiler in combination with the existing C++ API.1 Figure 8.5
illustrates the respective steps:
1. The compiler generates debug-symbols during the compilation. These contain
the static information which can be gained by analyzing the source code (e.g.,
which classes are part of the system and which ﬁelds and methods are parts of
these).
2. The source code is compiled in order to generate an executable. This ﬁle can
be executed on a system, for building the simulated design and simulating it
afterwards.
3. While the system is running, instances of certain program states (called snapshots
in the following) are extracted.
4. The information obtained in the step before can be stored on the disk. At this
point, this information is basically the state of the program at the time of the
extraction.
5. Both the static structure of the program and (if available) the extracted program
state can then be compared to the formal model. Differences between the
program state and the formal model may indicate discrepancies. This pinpoints
designers to certain parts which may require further inspection or adaptation.
For the implementation from Listing 8.1, the static information obtained in Step 1
is shown in Fig. 8.6. Compared to the original formal model from Fig. 8.2, this
information of course does not contain any OCL constraints and is restricted to the
structural information present in the implementation. Moreover, it contains several
classes that are not deﬁned in the original formal model (e.g., the basic_string
class, which is used to name the objects and part of C++’s standard namespace).
They are a result of extracting anything the compiler keeps in a given program.
Nevertheless, it already provides a good basis for a comparison to the formal model.
1Note that relying on the C++ API and additional debugging symbols allows for utilizing the
approach within different C++ frameworks as well as dialects.

8.1
What Can Be Veriﬁed Where?—A Case Study
215
Fig. 8.6 Retrieved model from the implementation in Listing 8.1.

216
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
Next, behavioral information of the implementation is considered. This can
be obtained using the executable generated by the compiler in Step 2. If a set
of instances is available to the extraction algorithm, the internal state of an
implementation can be extracted by reading the classes’ structure information from
the debug symbols while the program is running (Step 3). Using this extraction
scheme repeatedly extracts a set of program states, i.e., snapshots (Step 4). These
states can be seen as the cornerstones of a behavior: if a certain protocol is invoked
and the snapshots after each communication step represent the state the program is
expected to be in, the communication can be interpreted to be correct. This way,
a series of program snapshots serves as a simple way to check the correctness
of a system. If no framework is available, using Aspect Oriented Programming
techniques [SGS02] can be used to solve this problem by previously refactoring
the code to give access to the given structures [SWD15]. Eventually, this leads to
structural and behavioral information to be compared to the originally given model.
Model Comparison
With a given formal model and an extracted set of information from the
implementation, a comparison of both descriptions can be conducted. Although this
would not provide a formal proof, it may lead to a validation of whether the resulting
implementation indeed realizes the given model. With the extraction methods still
being an active ﬁeld of research, how to actually perform the comparison remains
in its infancy as well.
One solution introduced in [SWD14] is a direct comparison of the two models.
While this method suggests that the added complexity (such as the explicitly
modeled std namespace in the extracted model) can safely be ignored, it otherwise
simply compares the two models and locates any differences that go beyond added
complexity as potential errors. In this case, the added Structure class that forms
a base class for all subclasses already represents a structural difference that would
be reported, suggesting that either the implementation or the formal model should
be altered in order to make them comply with each other’s structure.
The comparison from [SWD14] is able to match all elements from the formal
model to the elements from the implementation but not vice versa. The algorithm
issues warnings for all subpackage records (i. ., the std, the __gnu_cxx, and
__gnu_debug namespaces) and the respective subnodes. It also reports that the
operations Building, ~Building, MagneticCard, ~MagneticCard and
Turnstile (i.e., the constructors and destructors which are required to setup a
working C++ implementation) are missing, just as no corresponding Structure
element can be located.
Besides these warnings (which can easily be ruled out), the approach conﬁrms
that the structural features of the formal model are a subset of the structural features
of the implementation. That is, the implementation is in line with the notion of the
formal model. Comparing various test cases from the formal model to the generated
snapshots, similar conclusions can be drawn with respect to the behavior.

8.2
Verifying Implementations Against Their Formal Speciﬁcation
217
8.1.6
Open Issues
In this section, a case study showcasing the state-of-the-art in veriﬁcation-driven
design of hardware and software was provided. First, a speciﬁcation of an access
control system in natural language has been given, then a formal model was derived
from it. Before commencing any implementation steps, it has been shown that the
initial model contains ﬂaws and, thus, prevented an implementation phase based on
an erroneous model. With the help of various approaches for model veriﬁcation—
mainly presented in the book at hand—the model has been revised and eventually
implemented it in C++. Finally, the compatibility of the resulting implementation
with respect to the formal model has been shown.
By this, it has explicitly been shown how the combination of all the different
veriﬁcation methods proposed in the past may aid designers not only in detecting
ﬂaws as soon as possible, but also in improving the quality of the resulting
intermediate steps, i.e., the model and its initial implementation. Besides that, the
case study unveiled open gaps to be addressed in future work including, e.g.:
•
When an inconsistency in a model is detected, debugging approaches determin-
ing reasons for this are available. Thus far, the analysis of inconsistencies has
focused on static behavior only. How to determine reasons for ﬂaws in dynamic
behavior, e.g., deadlocks, remains an open question.
•
The mentioned approaches for checking the behavior of a model can be applied
for a lot of different checks, however, it remains an open question how coverage,
i.e., the guarantee that the model has completely been checked, can be ensured.
•
Solutions for the (automatic) determination of frame conditions are still in
their infancy and depend on the designers experience. Hence, more elaborated
methods which require only a minimum of interaction with the designer are
desired. In the best case, the designer directly gets examples and counterexamples
for a speciﬁc model in order to decide which one is to be added to an invariability
clause.
•
Checking whether the implementation indeed realizes the model is mainly done
by validation, i.e., structural features of an implementation are compared against
the originally given model. While this gives a strong indication whether or not an
implementation sticks to the features that were previously designed, veriﬁcation
methods which actually prove the correct implementation of operations by, e.g.,
comparing their internal logic to the original pre- and postconditions are yet to
be developed. A solution for this problem is presented as next.
8.2
Verifying Implementations Against Their Formal
Speciﬁcation
The case study presented in the previous section showed not only the possibilities
of approaches for the validation and veriﬁcation of UML/OCL models, but also
recently published approaches to check implementations. One issue which has been
recognized is the fact that veriﬁcation results are usually not re-used in later design

218
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
steps anymore. In fact, similar veriﬁcation tasks are often applied again, e.g., after
the implementation has been completed. This is a waste of computational and
human effort.
In order to close the aforementioned gap between the veriﬁcation results of
different levels, this section presents an as early as possible veriﬁcation scheme.
Therefore, the general idea is to transfer as many veriﬁcation results as possible from
a model down to the implementation. Formally, this yields to a central formulation
which is derived by orchestrating the parts of the symbolic formulation and a
veriﬁcation approach of C-implementations together.
8.2.1
Envisioned Design Flow
As already mentioned in Sect. 8.1, many approaches for the veriﬁcation of
UML/OCL models have been proposed in the recent past. They are helpful
in identifying the existence of ﬂaws in early stages of the design ﬂow and,
in this case, may prevent the implementation of a system based on a ﬂawed
formal speciﬁcation. However, once a (veriﬁed) formal speciﬁcation has been
realized in C, C++, SystemC, or other means, the resulting implementation has
to be veriﬁed again. For this purpose, veriﬁcation methods such as introduced
in [BucC11, CDE08, CKL04, AE15, GLD10, LeC13] can be utilized. They,
however, have the drawback that the entire system behavior is considered again.
Exceptions are the approaches presented in [MHS09, SWD14] where some issues
are addressed by comparing model descriptions against implementations, but on
a very naive level. Details of the latter one have been given in the case study in
Sect. 8.1.5.
In particular for detailed implementations, verifying the entire system behavior is
a computationally complex task. Moreover, it is also a redundant task, since, e.g., the
interaction of the system’s components could already have been veriﬁed by means
of the UML/OCL model. But existing methods do not allow for transferring such
veriﬁcation results from the formal speciﬁcation level to the implementation level—
a clear disadvantage.
To overcome this problem, a design and veriﬁcation ﬂow as depicted in Fig. 8.7
is proposed in which the following two stages are conducted.
In the ﬁrst stage, the formal speciﬁcation (provided by a stakeholder or designer
in abstract modeling languages such as UML, SysML, MARTE, etc.) is veriﬁed.
This, e.g., includes consistency checks such as checking whether it is possible to
instantiate the desired system considering all constraints and requirements, but also
ﬁrst behavioral checks such as checking whether it is possible to reach a prohibited
state. For this purpose, all the approaches presented in this book as well as the
ones explained in Sect. 3.4 can be used. Details about the possibilities have been
discussed recently in the case study in Sect. 8.1.3. All those methods allow for the
detection of design ﬂaws already in very early design steps—even in the absence
of a precise implementation. That is, if the veriﬁcation of a formal speciﬁcation
fails, design bugs can be determined and ﬁxed without considering implementation

8.2
Verifying Implementations Against Their Formal Speciﬁcation
219
details. Moreover, also the interaction of various components of a complex design
can be veriﬁed by these approaches. Consequently, further checks can often focus
on the implementation of sole components only.
This is conducted in the second stage. More precisely, this stage does not consider
the entire system and the interactions of their components anymore, but rather
checks whether the implementations of its individual components are functionally
correct with respect to the formal speciﬁcation. For this purpose, the implementation
of the respectively considered component (e.g., for operation op1() in the sketch
of Fig. 8.7; provided in C, C++, SystemC, or other means) is compared against
its corresponding formal speciﬁcation (i.e., the formal constraints for class A and
operation op1() provided in UML, SysML, MARTE, or other means). If this
veriﬁcation passes for all components of a system, conclusions about the correctness
of the overall system can be drawn.
Following such a ﬂow yields the following advantages:
•
An “as early as possible” veriﬁcation scheme is employed, i.e., errors are detected
as soon as possible. The more errors detected in the UML/OCL level, the less
errors that are propagated to lower levels.
•
Debugging loops are kept small. In fact, if an error has been detected, identifying
its source remains in one abstraction level (either the formal speciﬁcation or the
implementation is debugged). Loops over several abstraction levels may only
occur due to design exploration or unsatisﬁed non-functional requirements.
•
The efﬁciency is signiﬁcantly increased due to the clear separation of concerns.
The interaction of the respective components is mainly veriﬁed in Step 1
Fig. 8.7 Envisioned
veriﬁcation ﬂow
Implementation
UML model
A
op1()
B
op2()
C
op3()
Veriﬁcation
Debug behavior
of the system
fail
Veriﬁcation of system behavior
Implementation
op1();
op2();
op3();
Veriﬁcation
Debug implementation
of an operation
fail
pass
ok
Veriﬁcation of individual components
pass

220
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
using the abstract descriptions at the formal speciﬁcation level. In contrast, the
(much more precise) implementations are solely considered in Step 2. This is a
clear improvement compared to existing approaches such as [BucC11, CDE08,
CKL04, AE15, GLD10, LeC13] where the implementation as a whole has to be
considered, which frequently leads to complexity problems.
The design and veriﬁcation ﬂow sketched in Fig. 8.7 aims for avoiding this
additional overhead which is needed to verify the implementation of an entire
system with its computational complexity again. The system behavior is veriﬁed
in Step 1 only (at the more abstract formal speciﬁcation level). Afterwards, the
implementation is veriﬁed by solely considering each component and checking
whether it, in fact, has been implemented according to the formal model. Since this
requires the consideration of single operations only (rather than the entire system),
veriﬁcation can be conducted with signiﬁcantly less computational complexity.
However, no approach exists yet which conducts the second step.
Such a solution follows; more precisely, for a given formal model m (provided
in UML/OCL) and an implementation impl of m (provided in C), an approach
is presented which automatically checks whether the implementation implo of an
operation o 2 O (for some c D .A; OI/) has been realized as speciﬁed in m.
Using this solution, the design and veriﬁcation ﬂow as shown in Fig. 8.7 becomes
applicable.
8.2.2
General Idea
In order to address the problem above, it is assumed at ﬁrst that the data types used
in the model m and the corresponding implementation impl are isomorphic and that,
for each operation of all classes in m, there is exactly one method in impl with
matching deﬁnitions as well as types.2 This can be achieved, e.g., by applying model
reﬁnements to the original model before someone starts with the implementation.
Furthermore, we assume that the preconditions Co, postconditions Bo, and frame
conditions Fo of the model as well as the implementation implo for an operation
o 2 O are available.
Then, the following check needs to be conducted: For all possible system states 
(w. l. o. g. to be assumed the state calling an operation o) which
•
satisfy the invariants I of all classes,
•
satisfy the preconditions Co of the operation o, and
•
respectively lead to the succeeding state 0 when executing the implementa-
tion implo of o,
2Note that the latter restriction is assumed for the sake of clarity of the description. The proposed
solution and approaches proposed here will be capable of supporting 1 W 1 mappings but also 1 W n
mappings from UML/OCL to impl.

8.2
Verifying Implementations Against Their Formal Speciﬁcation
221
eventually a succeeding state 0 must result which
•
satisfy the invariants I of all classes,
•
satisfy the postconditions Bo, and
•
satisfy the frame conditions Fo between itself and the calling state .
More formally, an implementation implo of an operation o 2 O has been realized as
speciﬁed in m if
8 ; 0 2 ˙ W
  ^
i2I
i
!
^

Co
^

0 D implo./
!
)
 
Bo;0 ^
^
i2I
i0 ^ V 
!
(8.1)
holds, whereby
•
implo is a function which takes the calling state  and maps it to the successor
state by applying all atomar instructions of the implementation in the given order
and
•
V  is a function which evaluates to false iff the frame conditions of
operation o are violated between the states  and 0.
However, checking a formula such as Eq. (8.1) obviously is a problem of
signiﬁcant (computational) complexity—in particular, due to the universal quantiﬁer
which requires checking all possible system states ; 0 2 ˙. In order to cope with
this seriously large search space to be explored, SMT solvers are used again.
But unfortunately, SMT solvers are highly optimized for determining a (satis-
fying) assignment for a given formula or to prove that no such assignment exists.
They are unsuitable for universal quantiﬁed formulas such as Eq. (8.1).3 Hence, the
negation of Eq. (8.1) is applied instead, namely:
9 ; 0 2 ˙ W
  ^
i2I
i
!
^

Co
^

0 D implo./
!
^
 
:Bo;0 _
_
i2I
:i0 _ :V 
!
(8.2)
Equation (8.2) eventually states a classical satisﬁability problem which rep-
resents the considered problem. In fact, Eq. (8.2) is satisﬁable iff an assignment
(i.e., two system states) exists which violates the constraint stated in Eq. (8.1).
3Using different theories many state-of-the-art SMT solvers allow for universal quantiﬁers.
However, there are problems when combining with different theories, etc. Furthermore, the search
would be inﬁnite, something which this book tried to avoid. See also Appendix B.

222
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
These system states are counterexamples showing that, although a valid operation
call has been conducted in  (all invariants and preconditions are satisﬁed), the
implementation implo yielded a succeeding state 0 which violated either the
invariants, postconditions, or frame conditions. This shows that the implementation
has not been realized as speciﬁed in m. Vice versa, if the SMT solver can prove that
no such assignment exists, it can be concluded that no such counterexample exists
and, hence, the implementation has been realized as speciﬁed in m (Eq. (8.1) has
been proven).
What remains open is how to precisely create an instance representing Eq. (8.2)
for an (arbitrarily) given model m and an implementation impl. To this end,
more detailed description about how the implementation implo is provided in the
following subsection. For all other parts, precise details have already been given in
this book.
8.2.3
Representation of the Implementation
In order to complete Eq. (8.2), details for implo are left to be provided. Recall that
implo is a function which takes the calling state  and maps it to the successor
state 0 by applying all atomic instructions of the implementation in the given
order. Hence, a symbolic formulation of all possible executions of the given
implementation is required. In order to be inline with the formulations from above,
again a symbolic representation is created for this purpose. This yields the questions
how to transform an implementation provided in a high-level language such as
C/C++/SystemC to a corresponding (low-level) symbolic formulation as well as
how to link the resulting formulation to the symbolic formulation of the model.
To address these questions, common techniques from software veriﬁcation are
utilized. In particular, the base of the proposed method is symbolic execution. The
following discussion exempliﬁes how symbolic execution can be used to obtain a
suitable representation of the implementation implo in three steps:
•
Generate a Low-Level Representation
The implementation of an action has much richer semantics in C/C++/SystemC
languages than what can be expressed in terms of pre- and postconditions of
UML and OCL (i.e., an implementation might imply pointers, arrays, function
calls, structures, unions, ternary operators, various classes of loops, etc.). A ﬁrst
step to derive a suitable formula for implo has to transform all the semantic
richness of commonly used languages into a low-level representation which can
be mapped afterwards into bit vector constraints.
•
Conduct a Symbolic Execution
An implementation can evolve the system state through many different paths
expressed in the implementation code. Symbolic execution can be used to explore
all these paths (under the assumption that its number is ﬁnite) and coalesces all
explored constraints in the form of a single formula.

8.2
Verifying Implementations Against Their Formal Speciﬁcation
223
•
Map the Variables between Model and Implementation
The resulting symbolic formulation represents all possible executions of the
given implementation and has to be combined only with the formulation of the
model as proposed in Eq. (8.2). To this end, all bit vectors representing variables
of the implementation have to be mapped to the bit vectors representing the
corresponding attributes of the model.
In the following, these three steps are described in more detail.
8.2.3.1
Generate a Low-Level Representation
The ﬁrst step is to compile the program to a low-level representation. To this end, the
Low Level Virtual Machine (LLVM, [LA04]) is used as a black-box compiler that
translates the C code to an Intermediate Representation (IR). This representation is
further simpliﬁed and reﬁned by several transformations (as proposed in [AEH15])
in order to transform it to a less expressive description which is closer to the direct
bit vector representation. For example, the “+” operator of two registers is translated
to a bvadd operation of two bit vectors—also taking care of the appropriate casting
or the transformation to a function call if operator “+” is overloaded.
Example 61 Consider the excerpt of an implementation as shown in Listing 8.2(a).4
Passing this implementation to the LLVM compiler yields a low-level representation
as shown in Listing 8.2(b). This eventually is translated to the bit vector representa-
tion shown in Listing 8.2(c).
8.2.3.2
Symbolic Execution of the Implementation
In order to cover all possible executions of the implementation in a single symbolic
formula, both data dependencies and control dependencies have to be considered.
To this end, a scheme for symbolic execution as also done in [KT14, GKS05,
SMA05] is applied. Here, the semantic coverage criteria is increased by iteratively
expanding a set of feasible traces obtained from symbolic execution that model
feasible executions of the code. This way, the formula implo is iteratively extended
by new paths that could be executed.
For this purpose, two structures are updated during symbolic execution and used
afterwards to derive a formulation of implo:
•
.path/ W path 7! SMT_expression: A stack for every leaf that stores the
conditions that need to met in the tree to reach that particular leaf. This is usually
called path conditions in the literature, and enables to identify semantically
equivalent control-ﬂow dependencies in the code.
4The operation belongs to the trafﬁc lights model from Example 14 on page 86 visualized in
Fig. 3.7.

224
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
1 class A {
2
int a;
3
int switchPedLight(int a)
4
{
5
int c;
6
a = 1 - a;
7
if(a) c = 1;
8
else
c = 0;
9
return c;
10
}
11 }
(a) Implemented operation
1 define i32 @switchPedLight(i32 %a)
2 {
3 entry:
4
%c = alloca i32
5
%1 = bvsub i32 1, %a
6
%2 = icmp i32 %1, 0
7
br i1 %2, label %bb, label %bb1
8 bb:
9
store i32 1, i32* %c
10
br label %bb2
11 bb1:
12
store i32 0, i32* %c
13
br label %bb2
14 bb2:
15
%ret = load i32* %c
16
ret i32 %ret
17 }
(b) Resulting IR representation
1 (= (bvsub 0x0001 a@pre) 0x0000)
2 (= a@post (bvsub 0x0001 a@pre))
3 (= c@post 0x0001)
4
5 (not (= (bvsub 0x0001 a@pre) 0x0000))
6 (= a@post (bvsub 0x0001 a@pre))
7 (= c@post 0x0000)
(c)
Resulting bit vector representation
Listing 8.2 Generated a low-level representation
•
.path; variable/ W path 7! map.variable 7! SMT_expression/: A mapping
from variables to SMT expressions that stores the symbolic expression of every
variable in the path.
Example 62 Consider the IR representation as shown in Listing 8.3 and the path
that starts from the “entry” basic-block in the beginning of the function and
comprises the basic blocks “entry,” “bb,” and “bb2.” At the end of the symbolic
execution, the framework would construct the following formulas (symbolically
describing the behavior of that path):
.path1/  .D .bvsub 0x0001 a@pre/ 0x0000/
.path1; a/  .bvsub 0x0001 a@pre/
.path1; c/  0x0000
The resulting formulation represents all possible executions following the same
path. However, in order to cover the complete behavior of the implementation, all
possible paths have to be considered as well. Hence, the framework presented in this

8.2
Verifying Implementations Against Their Formal Speciﬁcation
225
Listing 8.3 Symbolic
execution
paper also uses symbolic execution to automatically augment the semantic coverage
of the inspected behavior. To this end, an SMT solver is called in every point in
which the control ﬂow of the program can continue and cover an area that has not
been semantically considered in the current formulation.
Example 63 In the previous example, new behaviors can be explored by calling
an SMT solver in the branch instruction over the expression stored in the
register “%2”. The symbolic expression stored in that register is equal to
.D .bvsub 0x0001 a@pre/ 0x0000/. The SMT solver can determine that both
branches are possible under the current context, and both of them explore new
behaviors that have not been considered before. Hence, the symbolic execution
forks the process and continues the construction of the formula following both
branches.
Once all semantically equivalent behaviors have been analyzed (the SMT solver
returns UNSAT for every possible new control-ﬂow that can be explored in the
program), the implementation is transformed into a symbolic formula using the bit
vector variables of the previous formulation introduced for  and :
implo ,
_
p2paths.P/
^
v2vars.P;p/
. p/ ^ .v D . p; v//
Example 64 In our previous example, unfolding the execution tree as described
in [AEH15], it is detected that there are two feasible paths in the given code:
•
In the former path, signal “c” ends being 1. This path is taken if and only if
1  a@pre is different than 0.
•
In the latter path, signal “c” ends with the value of 0. This path is taken if 1 
a@pre is equal to 0.
They can be expressed as constraints
path1  f1 W .D .bvsub 0x0001 a@pre/ 0x0000/;
1 W fa@post 7! .bvsub 0x0001 a@pre/;
fc@post 7! 0x0001gg

226
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
path2  f2 W :.D .bvsub 0x0001 a@pre/ 0x0000/;
2 W fa@post 7! .bvsub 0x0001 a@pre/;
fc@post 7! 0x0000gg
and, then, the two paths can be combined in a single formula as
implo , .1 ^ c@post D 1 ^ : : : / _ .2 ^ c@post D 0 ^ : : : /
8.2.3.3
Mapping Variables Between Model and Implementation
The symbolic formulation created thus far represents all possible executions of the
given implementation. As a ﬁnal step, this formulation has to be integrated into
Eq. (8.2). To this end, all bit vectors representing variables of the implementation
have to be mapped to the bit vectors representing the corresponding attributes of the
model. While this can, in principle, easily be conducted by mapping the respective
identiﬁers,5 the different states a variable may assume in the implementation have
to be considered. An example illustrates the issue.
Example 65 Consider an operation speciﬁed in terms of OCL as shown in List-
ing 8.4(a) and its implementation as shown in Listing 8.4(b). An OCL expression
referring to a model element  can only argue over two consecutive system states 
and 0, i.e., it is clearly distinguished by  and @pre for 0 and , respectively.
For example, in Listing 8.4(a) the attribute a is used in the calling system state 
by a@pre in the postcondition and c refers to the value in 0. However, the variable
of  may assume more states in the implementation (in fact, after each assignment,
a new value may be assumed). Moreover, these stages are not explicitly denoted but
have to be derived from the order of statements in the implementation.
To solve this problem, two pseudo functions prestate(a, "a") and
poststate(a, "a") are added at the beginning and the end of the imple-
mentation of the operation, respectively. These functions have no effect on the
implementation, however, they can be identiﬁed when processing the LLVM syntax
tree. The ﬁrst parameter helps to identify the corresponding LLVM variable and the
second parameter assigns the respective identiﬁer to the variable.
Overall, Fig. 8.8 sketches the respective steps during the generation of the
symbolic representation implo for an implementation of the trafﬁc light example
considered before. First, the source code is translated using LLVM and all possible
traces are obtained by symbolic execution. Afterwards, a corresponding symbolic
formulation with bit vector variables is derived for each of these paths. Finally,
the resulting symbolic formulations are combined—eventually yielding implo.6
5Recall that it is assumed that the identiﬁers of the model m and the corresponding implementa-
tion impl are equal and that their data types are isomorphic.
6Note that, in addition to the steps summarized here, also issues such as (irregular) loops, pointers,
recursion, function pointers, etc. have to be handled. However, as this is out of the scope of this

8.2
Verifying Implementations Against Their Formal Speciﬁcation
227
1 context A::switchPedLight()
2
pre:
a = 1
3
or a = 0
4
post: c <> a@pre
(a) Modeled operation
1 class A {
2
int a;
3
int switchPedLight(int a)
4
{
5
int c;
6
a = 1 - a;
7
if(a) c = 1;
8
else c = 0;
9
return c;
10
}
11 }
(b) Implemented operation
Listing 8.4 Correlation of variables
Passing the resulting formulation to an SMT solver only valid executions of the
implementation would be derived. Together with the formulation from Sect. 3.2,
this completes the generation of Eq. (8.2).
8.2.4
Evaluation
The proposed methodology has been implemented and tested with a case study on
top of the existing frameworks for the symbolic formulation as well as the tool
FOREST proposed in [AE15]. The translations of the formal speciﬁcation as well
as the implementation as described in Chap. 3 and Sect. 8.2.3, respectively, are
realized utilizing previously proposed solutions for UML/OCL veriﬁcation and C++
validation. Afterwards, the applicability of the resulting veriﬁcation ﬂow has been
evaluated by means of the following three examples:
•
The ﬁrst example serves as motivation—showing the kind of errors that can be
detected using the proposed approach.
work and corresponding solutions are already described in [AEH15], a detailed consideration of
those issues is omitted.

228
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
Fig. 8.8 Determining implo for an implementation
•
In the second example, we study the scalability of the proposed approach. For
that, we apply the proposed methodology to an example in which the size of the
problem can be easily modiﬁed. This allows for the evaluation of the veriﬁcation
time with a conventional approach.
•
Finally, the approach is evaluated considering an industrial example; i.e., a UML
description of a turn indicator used in Mercedes Benz cars (taken from [PelC]).

8.2
Verifying Implementations Against Their Formal Speciﬁcation
229
8.2.4.1
Motivating Example
An example showing what kind of errors can arise in the implementation of
UML components in low-level languages such as C/C++ has indeed already been
introduced in Listing 8.4. Even in the implementation of a simple “toggle” function,
errors can be introduced if we do not consider the pre-/postconditions. Remember
that the function ﬁrst subtracts the input from 1 (so if the input is 1, “a” turns 0,
and if the input is 0, “a” turns 1) and then uses that result to turn a light on or off.
However, note that the switching behavior only takes place under the assumption
that the input is “1” or “0”. C/C++ semantics consider any value that is different
than 0 as “true.” Hence, if, e.g., the input is “ON” with a value of 2, the output will
not be “OFF.” The methodology introduced in this work is capable of automatically
pinpointing the designer to errors like that.
8.2.4.2
Scalable Example
Next, an example is considered which allows for an evaluation with respect to
scalability of the proposed methodology (and, hence, also a comparison to currently
applied approaches). More precisely, implementations are considered which sorts
an array of size 10 according to different sort criteria (ascending, descending, odds-
ﬁrst, evens-ﬁrst, alphabetical, capital-letters-ﬁrst, and their combinations). Since
each of these sort functions has a rather homogeneous design space, this allows for
a consideration of different systems which can be scaled with respect to a different
number of operations.
Figure 8.9 summarizes the resulting run times in CPU seconds (y-axis) needed
to verify corresponding systems with a different number of sorting operations
0
2
4
6
8
10
103
102
Number of operations
Run Time in s
Conventional Solution
Proposed Methodology
Fig. 8.9 Needed run-times to verify the scalable example

230
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
(x-axis). The blue values denote the time needed using a conventional approach
(i.e., FOREST), while the red values denote the time needed by the proposed
methodology. The numbers clearly show the multiplicative effect that an increasing
number of operations (and, hence, possible interactions) has on conventional
veriﬁcation methods (see blue values). In contrast, if the proposed methodology is
applied, the overall system can be considered signiﬁcantly faster on the UML/OCL
level and, afterwards, the detailed implementations can solely be veriﬁed. This leads
to a signiﬁcant improvement in the veriﬁcation time (see red values).
8.2.4.3
Industrial Example
Finally, the proposed methodology has been applied to verify a system from an
industrial context: a turn indicator as used in Mercedes Benz cars and speciﬁed
in [PelC]. The turn indicator offers functionality for controlling the ﬂash signal of
the car by a lever (indicating left or right) and a switch for the warning lights. Once
the driver moves the lever up or down, the corresponding light is turned on and off
at least three times. The light keeps ﬂashing for as long as the lever is left in the
respective position. Pushing the switch turns on both lights simultaneously. As an
additional function, the warning lights can always get interrupted by the regular ﬂash
signal, i.e., when the warning lights are active and the lever is pulled, the respective
ﬂash signal is turned on instead.
This speciﬁcation leads to a UML/OCL description of the desired functionality as
shown in Fig. 8.10. Two classes (OutputCtrl and FlashCtrl) represent the structure
of the system. The integer attributes tilLevel and tilOld represent the current
and previous status of the lever, respectively, i.e., whether the level is/was on the left
position (0), the neutral position (1), or the right position (2). The invariants i1 and
i2 ensure that only valid values are assigned.
The Boolean attribute warnSwitch represents the value of the switch for the
warning lights. If its value is true (false), the warning lights are switched on
(off).
The attributes of the class OutputCtrl represent the respective “output signals”
of the turn indicator. More precisely, the integer attribute ctr counts the number of
ﬂashes of the indicator (this is needed in order to keep track on whether the lights
turned on and off at least three times). The attributes left and right represent
internal signals to control the car lights. Besides this, the two attributes lOld and
rOld store the indication of the direction in case it got interrupted by the warning
lights. The car lights itself are represented by the Boolean attributes carlightL
and carlightR.
The behavior of the turn indicator is speciﬁed by the operations as well
as their corresponding pre- and postconditions. The operations setTil and
switchEmerMode specify the actions of the driver, i.e., the activation of either
the turn indication or the warning lights. The remaining two operations of class
FlashCtrl, manageFlashing and manageEmerMode enforce that the correct
signals are activated in the output controller (represented by class OutputCtrl).

8.2
Verifying Implementations Against Their Formal Speciﬁcation
231
OutputCtrl
ctr: Integer
lOld: Boolean
rOld: Boolean
left: Boolean
right: Boolean
carlightL: Boolean
carlightR: Boolean
ﬂashOn()
ﬂashOff()
FlashCtrl
tilLevel: Integer
tilOld: Integer
warnSwitch: Boolean
setTil(l: Integer)
switchEmerMode()
manageFlashing()
manageEmerMode()
ﬂash
1
output
1
inv i1: tilLevel >= 0 and tilLevel <= 2
inv i2: tilOld >= 0 and tilOld <= 2
context FlashCtrl::setTil(l: Integer):
post : tilLevel = l
context FlashCtrl::switchEmerMode():
post : emerSwitch <> emerSwitch@pre
context OutputCtrl::flashOn():
pre :
left = true
or right = true
or (ctr >= 1 and ctr < 3)
pre :
lampsLeft = false
and lampsRight = false
post : (left@pre = true or lOld@pre = true)
implies lampsLeft = true
post : (right@pre = true or rOld@pre = true)
implies lampsRight = true
post : (ctr@pre < 3) implies (ctr = ctr@pre + 1)
post : (ctr@pre >= 3) implies (ctr = ctr@pre)
...
context FlashCtrl::manageEmerMode():
pre : emerSwitch = true
post : output.ctr = 3
post : (
tilOld@pre = 1
and (
tilLevel@pre = 2
or tilLevel@pre = 0)
and tilLevel = 2
) implies (output.right = true)
post : (tilLevel = 1)
implies (
output.left = false
and output.right = false)
post : tilOld = 1
...
Fig. 8.10 An industrial example: turn indicator
Here, the car lights are switched on/off by executing the operations flashOn and
flashOff.
Based on the model, we have implemented the operation(s)/method(s) and, now,
want to check whether the implementation represents a valid instantiation of the
functionality described in the model. We have implemented all operations in the
presented model and validated the resulting implementation against the model. To
evaluate the capabilities of the proposed methodology, we have also introduced
some ﬂaws. In the following, we consider how the proposed methodology assists
designers in detecting (and ﬁxing) these ﬂaws.
One of the most concise bugs detected is related with method flashOn.
This function implements the activation of the output controller. The pre- and
postconditions of this operation can be seen in Fig. 8.10, and can be read like this:
•
If the left/right signal is true in the previous state, or in the actual one, then the
corresponding output has to activate.
•
The counter has to increase if it is smaller than three.
•
If the counter is three (or bigger), it should not change its value.

232
8
Re-utilizing Veriﬁcation Results of UML/OCL Models
1 char ctr;
2
3 void FlashOn(){
4
if(lOld||left) carlightleft
= 1;
5
if(rOld||right)carlightright = 1;
6
if(ctr < 3) ctr++;
7 }
(a) Erroneous implementation
1 char ctr;
2
3 void FlashOn(){
4
if(lOld||left) carlightleft
= 1;
5
if(rOld||right)carlightright = 1;
6
if((unsigned char) ctr < 3) ctr++;
7 }
(b) Correct implementation
Listing 8.5 Two implementations of flashOn
•
The preconditions state that the operation can only be called, iff the signal left
or right in the previous state is assigned true or the value of the counter is
between 1 and 3.
A ﬁrst implementation of this function in C can be seen in Listing 8.5(a). At a
ﬁrst glance, the implementation looks like a trivial translation from postconditions
to C, but an error has been introduced in it. As a result, the framework produces
a counterexample (provided in Listing 8.6), in which the preconditions hold, but
applying the input to the implementation, the postconditions do not.
The counterexample shows the set of violated postconditions and can be used to
debug the implementation. For example, if the input is 0x83 (which is in principle
greater than 3), the counter should not change its value but the counterexample
shows that it is increased. This ﬂaw comes from the fact that 0x83 is expressed
as the following bit string: 100000112. This is only greater than 3 if we consider
signed comparison semantics, but the symbolic formulas for the postconditions are
expressed in terms of unsigned values. More precisely, the u in the preﬁx bvu states
that unsigned bit vector operations are used. The details of this bug motivate the ﬁx
shown in Listing 8.5(b). Checking this new version using the proposed methodology
proves the correctness of the implementation.
In a similar fashion, all remaining implementations have been veriﬁed.

8.2
Verifying Implementations Against Their Formal Speciﬁcation
233
1 ctr@pre
= #0x83
2 lOld@pre
= 0
rOld@pre
= 1
3 left@pre
= 0
right@pre
= 1
4
5 ctr@post
= #0x84
6 lOld@post = 0
rOld@post
= 1
7 left@post = 0
right@post = 1
8
9 (=> (or (= left
true) (= lOld
true)) (= carlightLeft’ true))
10 ;
e v a l u a t e s
to
t r u e
11
12 (=> (or (= right
true) (= rOld
true)) (= carlightRight’ true))
13 ;
e v a l u a t e s
to
t r u e
14
15 (=> (bvult ctr (_ bv3 8)) (= ctr’ (bvadd ctr
(_ bv1 8))))
16 ;
e v a l u a t e s
to
t r u e
17
18 (=> (bvuge ctr (_ bv3 8)) (= ctr’ ctr ))
19 ;
e v a l u a t e s
to
f a l s e
Listing 8.6 Counterexample showing the error in Listing 8.5(a)

Chapter 9
Conclusion
In this book, several approaches for the validation and veriﬁcation of formal models,
namely UML/OCL models, have been proposed. Those UML/OCL models are used
as blueprints for the implementation of hardware or software systems to close the
gap between a speciﬁcation—usually provided in natural language—and the ﬁrst
executable prototype—usually written in a high-level language, e.g., C++ or Java.
While speciﬁcations are naturally full of ambiguities, the models are formal and,
thus, allow for the application of formal methods. This makes it possible to detect
and ﬁx ﬂaws in the design process before any implementation steps are performed.
Especially, ﬁxing ﬂaws on such an abstract level reduces the time needed and also
the cost.
For the veriﬁcation of UML/OCL models, in Chap. 3 a highly automated general
ﬂow for the validation and veriﬁcation of UML/OCL models has been presented. In
fact, a designer needs only to provide a UML/OCL model, intervals for the number
of objects per system state, and a veriﬁcation task. From this stage on, the remaining
steps can be performed in a fully automatic fashion using model transformations.
Utilizing the proposed transformation rules the veriﬁcation task is transformed into
an instance of an SMT problem. This instance is basically a symbolic formulation
representing all possible system states of the model. Consequently, it can be passed
to an off-the-shelf SMT solver which will determine either a satisfying assignment
or prove that there is no satisfying assignment. Due to the power of current SMT
solvers, this is a promising way which has also been used with great success in other
domains, e.g., test pattern generation in the hardware domain.
Chapter 4 has exploited the symbolic formulation to pay attention to the analysis
of potentially erroneous UML/OCL models. For models where errors have already
been detected, it is explained how the reasons for an inconsistent model can
be identiﬁed. Second, another approach outlines how to avoid overspeciﬁed and
(unnecessarily) complex models from the very beginning by identifying unneces-
sary invariants. Therefore, invariants are grouped into either the category dependent
or independent. In the ﬁrst case, the approach is also capable of determining
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8_9
235

236
9
Conclusion
the reason for the dependency and, thus, helps the designer to remove redundant
information from the model, i.e., to keep the model as small as possible from the
designers point of view.
Chapter 5 has dealt with two different behavioral aspects extending the abilities
of the general approach. First, the frame problem—the occurrence of arbitrary
changes during behavioral evaluation not prohibited by UML/OCL originally—
is described and it is explained how invariability clauses can be used to solve it.
Unfortunately, invariability clauses have been considered so far as a theoretical
concept only in the context of UML/OCL models. Therefore, a way how this
concept can be integrated into the model transformation (and, by this, also the
symbolic formulation) is presented. In the second part, it is explained how the
concurrent interaction of components of a system can be handled using both the
symbolic formulation and the invariability clauses.
Another aspect of system design besides structure and behavior is timing. While
it is clear that and also how to deal ﬁrst the ﬁrst two aspects, it is not clear at a ﬁrst
glance that the approaches presented before can also deal with timing. Chapter 6
provides an evidence for this. To be more precise, a generic representation of timing
constraints provided in MARTE/CCSL in terms of an automaton is introduced.
This automaton is encoded as a UML/OCL class diagram such that the symbolic
formulation can be utilized to validate and verify timing properties. The second
contribution in Chap. 6 takes the encoded automaton as basis and, by adding further
constraints, even allows for a fully automatic veriﬁcation of the respective timing
behavior.
In Chap. 7, the proposed ﬂow for model veriﬁcation has been applied to
tackle other problem ﬁelds. Experiments have shown that the symbolic formulation
contains a lot of constraints for certain OCL expressions. This affects the generation
and solving time. However, this is in many cases not necessary. For example, if
the designer has some special knowledge about the structure, many constraints
are obsolete. To avoid this, a new concept called ground setting properties has
been introduced. Experiments have shown that they can signiﬁcantly improve those
problematic cases.
Finally, in Chap. 8, a case study has shown the possibilities of the proposed
approaches. Furthermore, a new gap between the formal models and ﬁrst imple-
mentation prototypes has been identiﬁed. To close this gap, a two-level veriﬁcation
methodology has been proposed and described in detail. This makes it possible to
re-use the veriﬁcation results from the formal model level at the next lower level,
i.e., an implementation in C.
Overall, this book covered a broad range of issues including functional aspects
(both structural and behavioral) as well as non-functional aspects (by means of
timing). The respectively used symbolic formulation has proven to be efﬁcient
to solve various validation and veriﬁcation tasks and, at the same time, remained
ﬂexible to handle different problems—even problems not directly related to system
design at all. All solutions proposed in this book can nicely be integrated into today’s

9
Conclusion
237
design ﬂows as most results obtained from the validation and veriﬁcation at the
UML/OCL level can be transferred to lower abstractions levels. Several evaluations
and case studies demonstrated the applicability of the proposed methods. By this,
a signiﬁcant advancement of the state-of-the-art has been observed. The proposed
methods are ready to be employed within industrial contexts.

Appendix A
Class Inheritance
Figure A.1a shows a UML/OCL model composed of two classes, A and B. A has
one Boolean attribute a. B is a subclass of A, i.e., a 4 b, this attribute is inherited.
Further, B has an additional Boolean attribute b.
The UML/OCL model shown in Fig. A.1b is also composed of two classes,
A and B. Again, A has one Boolean attribute a. B has two Boolean attributes a
and b. However, the two classes do not have any inheritance relation. This means
attribute a of B is not inherited.
The two models look very similar, but they are indeed not equal: an object of A
in Fig. A.1a could be an instance of A as well as B. For the model in Fig. A.1b,
this is not the case; an object of A can be an instance of A only. However, a closer
look at the tupel will not show any difference. This makes it hard to formulate class
inheritance on the inﬁnite set of all classes C .
A
a: Boolean
B
(a: Boolean inherited)
b: Boolean
(a)
A
a: Boolean
B
a: Boolean
b: Boolean
(b)
Fig. A.1 Two similar models. (a) A model with inheritance. (b) A model without inheritance
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8
239

Appendix B
An SMT Instance with an Unknown Result
This chapter provides an example for an SMT-LIB formulation for which the
solver Z3 returns unknown. The example shows a shortened version of a co-Büchi
automaton problem with two states. The example has been provided by Marcel
Walter and is based on [FS07]. The SMT-LIB example tries to ﬁnd annotations
for the edges of co-Büchi automaton, however, due to the usage of new types and
sorts without any success.
1 ;
producing
models
2 (set-option :produce-models true)
3 ;
d e f i n i n g
a power
s e t
4 (define-sort PowerSet (T) (Array T Bool))
5
6 ; LABELS
7 ;
output
symbols
of
the
environment
8 (declare-datatypes () ((EnvironmentOutput r1 r2)))
9 ;
output
symbols
of
the
t r a n s i t i o n
system
10 (declare-datatypes () ((TransitionOutput g1 g2)))
11 ;
power
s e t
of
environment
v a r i a b l e s
12 (define-sort Sigma () (PowerSet TransitionOutput))
13 ;
power
s e t
of
t r a n s i t i o n
system
v a r i a b l e s
14 (define-sort Ypsilon () (PowerSet EnvironmentOutput))
15
16 ; COBüchi AUTOMATON
17 ;
s t a t e s
of
the
coBüchi automaton
18 (declare-datatypes () ((BuechiState q1 q2)))
19
20 ;
t r a n s i t i o n
f u n c t i o n
d e l t a
21 (define-fun delta
22
(
23
(q_a BuechiState)
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8
241

242
Appendix B
An SMT Instance with an Unknown Result
24
(o Sigma)
25
(q_b BuechiState)
26
(v Ypsilon)
27
) Bool
28
(and (= q_a q1) (= (select v r2) true) (= q_b q2))
29 )
30
31 ; TRANSITION SYSTEM
32 ;
s t a t e s
of
the
t r a n s i t i o n
system
( implementation )
33 ;
s y n t h e s i s
should
be
s u c c e s s f u l
with 2
s t a t e s
34 (declare-datatypes () ((TransitionState t1 t2)))
35
36 ;
t r a n s i t i o n
f u n c t i o n
37 (declare-fun tau ( (TransitionState) (Ypsilon) )
38
TransitionState)
39
40 ;
l a b e l i n g
f u n c t i o n
41 (declare-fun o (TransitionState) Sigma)
42
43
44 ; ANNOTATION
45 ;
lambda
d e c l a r a t i o n
46 (declare-fun lambda ( (BuechiState) (TransitionState) )
47
Int)
48
49 ;
v a l i d
a n n o t a t i o n
( 2 )
50 (assert
51
(forall
52
(
53
(q_a BuechiState)
54
(t TransitionState)
55
(q_b BuechiState)
56
(v Ypsilon)
57
)
58
(implies (delta q_a (o t) q_b v)
59
(> (lambda q_b (tau t v)) (lambda q_a t))
60
)
61
)
62 )
63
64(check-sat) ;
produces unknown

Appendix C
Contradictory XOR Deﬁnitions
This appendix will show that the current OCL standard containing at least the
deﬁnition of xor is contradictory. When explaining the transformation rules in
Sect. 3.2.5, it has already been mentioned that the OCL standard has been extended
since its ﬁrst version. As already said, the current OCL 2.4 standard offers a 4-
valued logic, i.e., an OCL operation which returns a Boolean can evaluate to one of
the four values: true, false, –, and ?. Former standards have not offered ? and
during the integration process a lot of questions how exactly to deal with – and ?
have not been answered or have been formulated in an ambiguous fashion. Some
ambiguous formulations have been mentioned when the precise transformation rule
has been given. In the following, two contradictory deﬁnitions of the xor operation
will exemplarily show some problems of the current OCL standard. The deﬁnition
in natural language for the xor operator can be found in [Obj14, Sect. 11.5.4 on
p. 162]:
xor (b : Boolean) : Boolean
True if self is true and b is false, or if self is false and b is true.
False if self is true and b is true, or if self is false and b is false.
Otherwise invalid if either self or b is invalid.
Otherwise null.
post: (self or b) and not (self = b)
Assuming that with either-or the logical-or is meant, then the textual deﬁnition
is inline with the truth table provided in [Obj14, Table A.2 on p. 214]. However, the
last line of the quotation offers another deﬁnition by a postcondition which is not
inline with the lines before. In order to show this, Table C.1(a)–(c) shows the truth
tables for the OCL operations used in the postcondition, i.e., and, or, and =, for all
four possible Boolean values. In Table C.1(d), the truth table for the deﬁnition of
xor given in natural language as quoted above and given in [Obj14, Table A.2 on
p. 214] is shown. Table C.2 derives the truth table for the deﬁnition of xor given by
the postcondition step by step.
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8
243

244
Appendix C
Contradictory XOR Deﬁnitions
Table C.1 Truth table for (a) and, (b) or, (c) =, and (d) xor textual deﬁnition
a
b
(a) For and
(b) For or
(c) For =
(d) For xor textual deﬁnition
a and b
a or b
a = b
a xor b
false
false
false
false
true
false
false
true
false
true
false
true
false
–
false
–
false
–
false
?
false
?
?
?
true
false
false
true
false
true
true
true
true
true
true
false
true
–
–
true
false
–
true
?
?
true
?
?
–
false
false
–
false
–
–
true
–
true
false
–
–
–
–
–
true
–
–
?
?
?
?
?
?
false
false
?
?
?
?
true
?
true
?
?
?
–
?
?
?
?
?
?
?
?
?
?
Table C.2 Truth table for
xor deﬁnition via
postcondition post: (a or b)
and (not (a = b))
a
b
(a or b)
and
(not
(a = b))
false
false
false
false
false
true
false
true
true
true
true
false
false
–
–
–
true
false
false
?
?
?
?
?
true
false
true
true
true
false
true
true
true
false
false
true
true
–
true
true
true
false
true
?
true
?
?
?
–
false
–
–
true
false
–
true
true
true
true
false
–
–
–
false
false
true
–
?
?
?
?
?
?
false
?
?
?
?
?
true
true
?
?
?
?
–
?
?
?
?
?
?
?
?
?
?

References
[Abr99]
J.-R. Abrial, System Study: Method and Example, 1999. URL:http://atelierb.eu/
ressources/PORTES/Texte/porte.anglais.ps.gz
[AE15]
P.G. de Aledo, P. Sánchez Espeso, FramewORk for embedded system - veriﬁcation
(competition contribution), in Tools and Algorithms for the Construction and
Analysis of Systems - 21st International Conference, TACAS 2015, Held as Part of
the European Joint Conferences on Theory and Practice of Software, ETAPS 2015,
London, UK, April 11–18, 2015, Proceedings, vol. 9035. Lecture Notes in Computer
Science, 2015, pp. 429–431. doi:10.1007/978-3-662-46681-0_36
[AEH15]
P.G. de Aledo, P. Sánchez Espeso, R. Huuck, An approach to static-dynamic
software analysis, in Formal Techniques for Safety-Critical Systems - Fourth
International Workshop, FTSCS 2015, Paris, France, November 6–7, 2015. Revised
Selected Papers, vol. 596. Communications in Computer and Information Science,
2015, pp. 225–240
[AhrC05]
W. Ahrendt, T. Baar, B. Beckert, R. Bubel, M. Giese, R. Hähnle, W. Menzel, W.
Mostowski, A. Roth, S. Schlager, P.H. Schmitt, The KeY tool. Softw. Syst. Model.
4(1), 32–54 (2005). doi:10.1007/s10270-004-0058-x
[AleC17]
P.G. de Aledo, N. Przigoda, R. Wille, R. Drechsler, P. Sánchez Espeso, Towards
a veriﬁcation ﬂow across abstraction levels verifying implementations against their
formal speciﬁcation. IEEE Trans. CAD Integr. Circuits Syst. 36(3), 475–488 (2017).
doi:10.1109/TCAD.2016.2611494
[AM08]
C. André, F. Mallet, Clock Constraints in UML/MARTE CCSL. Tech. rep. RR-6540,
2008. URL:https://hal.inria.fr/inria-00280941/ﬁle/rr-6540.pdf
[AMD10]
C. André, F. Mallet, J. DeAntoni, VHDL observers for clock constraint check-
ing, in IEEE Fifth International Symposium on Industrial Embedded Sys-
tems, SIES 2010, University of Trento, Italy, July 7–9, 2010, pp. 98–107.
doi:10.1109/SIES.2010.5551372
[AnaC07]
K. Anastasakis, B. Bordbar, G. Georg, I. Ray, UML2Alloy: A challenging model
transformation, in Model Driven Engineering Languages and Systems, 10th Interna-
tional Conference, MoDELS 2007, Nashville, USA, September 30–October 5, 2007,
Proceedings, vol. 4735. Lecture Notes in Computer Science, 2007, pp. 436–450.
doi:10.1007/978-3-540-75209-7_30
[BarC11]
C. Barrett, C.L. Conway Morgan Deters, L. Hadarean, D. Jovanovic, T. King, A.
Reynolds, C. Tinelli, CVC4, in Computer Aided Veriﬁcation - 23rd International
Conference, CAV 2011, Snowbird, UT, USA, July 14–20, 2011, Proceedings,
vol. 6806. Lecture Notes in Computer Science, 2011, pp. 171–177. doi:10.1007/978-
3-642-22110-1_14
© Springer International Publishing AG 2018
N. Przigoda et al., Automated Validation & Veriﬁcation of UML/OCL Models
Using Satisﬁability Solvers, https://doi.org/10.1007/978-3-319-72814-8
245

246
References
[BB09]
R. Brummayer, A. Biere, Boolector: An efﬁcient SMT solver for bit-vectors and
arrays, in Tools and Algorithms for the Construction and Analysis of Systems,
15th International Conference, TACAS 2009, Held as Part of the Joint European
Conferences on Theory and Practice of Software, ETAPS 2009, York, UK, March
22–29, 2009, Proceedings, vol. 5505. Lecture Notes in Computer Science, 2009,
pp. 174–177. doi:10.1007/978-3-642-00768-2_16
[BCD05]
D. Berardi, D. Calvanese, G. De Giacomo, Reasoning on UML class diagrams. Artif.
Intell. 168(1–2), 70–118 (2005). doi:10.1016/j.artint.2005.05.003
[BFT16]
C. Barrett, P. Fontaine, C. Tinelli, The Satisﬁability Modulo Theories Library (SMT-
LIB), 2016. URL:http://www.SMT-LIB.org
[BHS07]
B. Beckert, R. Hähnle, P.H. Schmitt, Veriﬁcation of Object-Oriented Software: The
KeY Approach, 2007. doi:10 1007/978-3-540-69061-0
[BieC09]
A. Biere, M. Heule, H. van Maaren, T. Walsh, Handbook of Satisﬁability, Amster-
dam, The Netherlands, 2009. ISBN: 9781586039295
[BMR95]
A. Borgida, J. Mylopoulos, R. Reiter, On the frame problem in procedure speciﬁca-
tions. IEEE Trans. Softw. Eng. 21(10), 785–798 (1995). doi:10.1109/32.469460
[BruC08]
R. Bruttomesso, A. Cimatti, A. Franzén, A. Griggio, R. Sebastiani, The MathSAT
4SMT Solver, in Computer Aided Veriﬁcation, 20th International Conference, CAV
2008, Princeton, NJ, USA, July 7–14, 2008, Proceedings, vol. 5123. Lecture Notes
in Computer Science, 2008, pp. 299–303. doi:10.1007/978-3-540-70545-1_28
[BS03]
B. Beckert, P.H. Schmitt, Program veriﬁcation using change information, in
1st International Conference on Software Engineering and Formal Meth-
ods (SEFM 2003), 22–27 September 2003, Brisbane Australia, 2003, p. 91.
doi:10.1109/SEFM.2003.1236211
[BTW14]
A.D. Brucker, F. Tuong, B. Wolff, Feather-weight OCL: A proposal for a machine-
checked formal semantics for OCL 2.5, in Archive of Formal Proofs 2014, 2014.
URL:https://www.isa-afp.org/entries/Featherweight_OCL.shtml
[BucC11]
S. Bucur, V. Ureche, C. Zamﬁr, G. Candea, Parallel symbolic execution for
automated real-world software testing, in European Conference on Computer
Systems, Proceedings of the Sixth European conference on Computer sys-
tems, EuroSys 2011, Salzburg, Austria, April 10–13, 2011, 2011, pp. 183–198.
doi:10.1145/1966445.1966463
[BW09]
A.D. Brucker, B. Wolff, Semantics, calculi, and analysis for object-oriented speciﬁ-
cations. Acta Inf. 46(4), 255–284 (2009). doi:10.1007/s00236-009-0093-8
[Cab06]
J. Cabot, Ambiguity issues in OCL postconditions, in OCL Workshop, 2006,
pp. 194–204
[Cab07]
J. Cabot, From declarative to imperative UML/OCL operation speciﬁcations, in
Conceptual Modeling ER - 2007, 26th International Conference on Conceptual
Modeling, Auckland, New Zealand, November 5–9, 2007, Proceedings, vol. 4801.
Lecture Notes in Computer Science, 2007, pp. 198–213. doi:10.1007/978-3-540-
75563-0_15
[CCR07]
J. Cabot, R. Clarisó, D. Riera, UMLtoCSP: a tool for the formal veriﬁcation of
UML/OCL models using constraint programming, in 22nd IEEE/ACM International
Conference on Automated Software Engineering (ASE 2007), November 5–9, 2007,
Atlanta, Georgia, USA, 2007, pp. 547–548
[CCR08]
J. Cabot, R. Clarisó, D. Riera, Veriﬁcation of UML/OCL class diagrams using
constraint programming, in First International Conference on Software Testing
Veriﬁcation and Validation, ICST 2008, Lillehammer Norway, April 9–11, 2008,
Workshops, Proceedings, 2008, pp. 73–80
[CCR09]
J. Cabot, R. Clarisó, D. Riera, Verifying UML/OCL operation contracts, in Inte-
grated Formal Methods, 7th International Conference, IFM 2009, Düsseldorf,
Germany, February 16–19, 2009, Proceedings, vol. 5423. Lecture Notes in Com-
puter Science, 2009, pp. 40–55. doi:10.1007/978-3-642-00255-7_4

References
247
[CCR14]
J. Cabot, R. Clarisó, D. Riera, On the veriﬁcation of UML/OCL class
diagrams using constraint programming. J. Syst. Softw. 93, 1–23 (2014).
doi:10.1016/j.jss.2014.03.023
[CDE08]
C. Cadar, D. Dunbar, D.R. Engler, KLEE: unassisted and automatic generation of
high-coverage tests for complex systems programs, in 8th USENIX Symposium on
Operating Systems Design and Implementation, OSDI 2008, December 8–10, 2008,
San Diego, California, USA, Proceedings, 2008, pp. 209–224. URL:http://www.
usenix.org/events/osdi08/tech/full_papers/cadar/cadar.pdf
[CED09]
M. Clavel, M. Egea, M. Angel García de Dios, Checking unsatisﬁability for
OCL constraints. ECEASST 24 (2009). URL:http://journal.ub.tuberlin.de/index.
php/eceasst/article/view/334
[CGC15]
R. Clarisó, C.A. González, J. Cabot, Towards domain reﬁnement for UML/OCL
bounded veriﬁcation, in Software Engineering and Formal Methods - 13th Inter-
national Conference SEFM 2015, York, UK, September 7–11, 2015, Proceedings,
vol. 9276. Lecture Notes in Computer Science, 2015, pp. 108–114. doi:10.1007/978-
3-319-22969-0_8
[CimC13]
A. Cimatti, A. Griggio, B. Schaafsma, R. Sebastiani, The MathSAT5 SMT solver, in
Tools and Algorithms for the Construction and Analysis of Systems - 19th Interna-
tional Conference, TACAS 2013, Held as Part of the European Joint Conferences on
Theory and Practice of Software, ETAPS 2013, Rome, Italy, March 16–24, 2013,
Proceedings, vol. 7795. Lecture Notes in Computer Science, 2013, pp. 93–107.
doi:10.1007/978-3-642-36742-7_7
[CKL04]
E.M. Clarke, D. Kroening, F. Lerda, A tool for checking ANSI-C programs, in Tools
and Algorithms for the Construction and Analysis of Systems, 10th International
Conference TACAS 2004, Held as Part of the Joint European Conferences on Theory
and Practice of Software, ETAPS, 2004, Barcelona, Spain, March 29–April 2, 2004,
Proceedings, vol. 2988. Lecture Notes in Computer Science, 2004, pp. 168–176.
doi:10.1007/978-3-540-24730-2_15
[Coo71]
S.A.
Cook,
The
complexity
of
theorem-proving
procedures,
in
Proceed-
ings
of
the
Symposium
on
Theory
of
Computing,
1971,
pp.
151–158.
doi:10.1145/800157.805047
[DC13]
C. Dania, M. Clavel, OCL2FOLC: coping with undeﬁnedness, in Proceedings of the
MODELS 2013 OCL Workshop colocated with the 16th International ACM/IEEE
Conference on Model Driven Engineering Languages and Systems (MODELS
2013), Miami, USA, September 30, 2013, vol. 1092. CEUR Workshop Proceedings,
2013, pp. 53–62. URL:http://ceur-ws.org/Vol-1092/dania.pdf
[DC16]
C. Dania, M. Clavel, OCL2MSFOL: A mapping to many-sorted ﬁrst-order logic
for efﬁciently checking the satisﬁability of OCL constraints, in 19th ACM/IEEE
International Conference on Model Driven Engineering Languages and Systems,
MoDELS 2015, Saint-Malo, Brittany France, October 2–7, 2016, 2016, pp. 65–75
[DioC14]
M.A.G. de Dios, C. Dania, D.A. Basin, M. Clavel, Model-driven development of
a secure eHealth application, in Engineering Secure Future Internet Services and
Systems - Current Research, vol. 8431. Lecture Notes in Computer Science, 2014,
pp. 97–118. doi:10.1007/978-3-319-07452-8_4
[DS07]
S. Disch, C. Scholl, Combinational equivalence checking using incremental SAT
solving, output ordering, and resets, in Proceedings of the 12th Conference on Asia
South Paciﬁc Design Automation, ASP-DAC 2007, Yokohama, Japan, January 23–
26, 2007, 2007, pp. 938–943. doi:10.1109/ASPDAC2007.358110
[DSW12]
R. Drechsler, M. Soeken, R. Wille, Formal speciﬁcation level: towards veriﬁcation-
driven design based on natural language processing, in Proceeding of the 2012
Forum on Speciﬁcation and Design Languages, Vienna, Austria, September
18–20, 2012, 2012, pp. 53–58. URL:http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?
arnumber=6336984

248
References
[DW09]
B. Demuth, C. Wilke, Model and object veriﬁcation by using Dresden OCL, in Pro-
ceedings of the Russian-German Work-shop Innovation Information Technologies:
Theory and Practice Ufa, Russia, 2009, pp. 687–690
[EQF12]
E.S.M. Ebeid, D. Quaglia, F. Fummi, Generation of systemC/TLM code
from UML/MARTE sequence diagrams for veriﬁcation, in IEEE 15th Inter-
national Symposium on Design and Diagnostics of Electronic Circuits & Sys-
tems, DDECS 2012, Tallinn, Estonia, April 18–20, 2012, 2012, pp. 187–190.
doi:10.1109/DDECS.2012.6219051
[ESW07]
G. Engels, C. Soltenborn, H. Wehrheim, Analysis of UML activities using dynamic
meta modeling, in Formal Methods for Open Object-Based Distributed Systems, 9th
IFIP WG 6.1 International Conference FMOODS 2007, Paphos, Cyprus, June 6–8,
2007, Proceedings, vol. 4468. Lecture Notes in Computer Science, 2007, pp. 76–90.
doi:10.1007/978-3-540-72952-5_5
[EWD13]
S. Eggersglüß, R. Wille, R. Drechsler, Improved SAT-based ATPG: more con-
straints, better compaction, in The IEEE/ACM International Conference on
Computer-Aided Design, IC-CAD’13, San Jose, CA, USA, November 18–21, 2013,
2013, pp. 85–90. doi:10.1109/ICCAD.2013.6691102
[FS07]
B. Finkbeiner, S. Schewe, SMT-Based Synthesis of Distributed Systems, in Second
Workshop on Automated Formal Methods (AFM), November 6, 2007, Atlanta,
Georgia, 2007, pp. 69–76
[GBR03]
M. Gogolla, J. Bohling, M. Richters, Validation of UML and OCL models by
automatic snapshot generation, in “UML” 2003 - The Uniﬁed Modeling Language,
Modeling Languages and Applications, 6th International Conference, San Fran-
cisco, CA, USA, October 20–24, 2003, Proceedings, vol. 2863. Lecture Notes in
Computer Science, 2003, pp. 265–279. doi:10.1007/978-3-540-45221-8_23
[GBR05]
M. Gogolla, J. Bohling, M. Richters, Validating UML and OCL models in USE
by automatic snapshot generation. Softw. Syst. Model. 4(4), 386–398 (2005).
doi:10.1007/s10270-005-0089-y
[GBR07]
M. Gogolla, F. Büttner, M. Richters, USE: A UML-based speciﬁcation environment
for validating UML and OCL. Sci. Comput. Program. 69(1–3), 27–34 (2007).
doi:10.1016/j.scico.2007.01.013
[GC14]
C.A. González, J. Cabot, Formal veriﬁcation of static software models in
MDE: A systematic review. Inf. Softw. Technol. 56(8), 821–838 (2014).
doi:10.1016/j.infsof.2014.03.003
[GHK10]
M. Gogolla, L. Hamann, M. Kuhlmann, Proving and visualizing OCL invariant
independence by automatically generated test cases, in Tests and Proofs, 4th
International Conference TAP 2010, Málaga, Spain, July 1–2, 2010, Proceedings,
vol. 6143. Lecture Notes in Computer Science, 2010, pp. 38–54. doi:10.1007/978-
3-642-13977-2_5
[GKH09]
M. Gogolla, M. Kuhlmann, L. Hamann, Consistency independence and conse-
quences in UML and OCL models, in Tests and Proofs, Third International
Conference, TAP 2009, Zurich, Switzerland, July 2–3, 2009, Proceedings, vol. 5668.
Lecture Notes in Computer Science, 2009, pp. 90–104. doi:10.1007/978-3-642-
02949-3_8
[GKS05]
P. Godefroid, N. Klarlund, K. Sen, DART: directed automated random testing, in
Proceedings of the ACM SIGPLAN 2005 Conference on Programming Language
Design and Implementation, Chicago, IL, USA, June 12–15, 2005, 2005, pp. 213–
223. doi:10.1145/1065010.1065036
[GKS08]
R. Gershman, M. Koifman, O. Strichman, An approach for extracting a small unsat-
isﬁable core. Formal Methods Syst. Des. 33(1–3), 1–27 (2008). doi:10.1007/s10703-
008-0051-z
[GLD10]
D. Große, H. Minh Le, R. Drechsler, Proving transaction and system-level properties
of untimed SystemC TLM designs, in 8th ACM/IEEE International Conference on
Formal Methods and Models for Codesign (MEMOCODE 2010), Grenoble France
26–28 July 201, 2010, pp. 113–122. doi:10.1109/MEMCOD2010.5558643

References
249
[GM14]
J.F. Groote, M. Reza Mousavi, Modeling and Analysis of Communicating Sys-
tems, 2014. ISBN:9780262027717. URL:https://mitpress.mit.edu/books/modeling-
and-analysis-communicating-systems
[GogC14]
M. Gogolla, L. Hamann, F. Hilken, M. Kuhlmann, R.B. France, From application
models to ﬁlmstrip models: An approach to automatic validation of model dynamics,
in Modellierung 2014, 19.–21. März 2014, Wien, Österreich, vol. 225. LNI. 2014,
pp. 273–288
[GogC15]
M. Gogolla, A. Vallecillo, L. Burgueño, F. Hilken, Employing classifying terms
for testing model transformations, in 18th ACM/IEEE International Conference on
Model Driven Engineer ing Languages and Systems, MoDELS 2015, Ottawa, ON,
Canada, September–30 October 2, 2015, 2015, pp. 312–321. doi:10 1109/MOD-
ELS.2015.7338262
[GPB01]
E.I. Goldberg, M.R. Prasad, R.K. Brayton, Using SAT for combinational equiva-
lence checking, in Proceedings of the Conference on Design, Automation and Test
in Europe, DATE 2001, Munich, Germany March 12–16, 2001, 2001, pp. 114–121.
doi:10.1109/DATE.2001.915010
[GR02a]
M. Gogolla, M. Richters, Expressing UML class diagrams properties with OCL,
in Object Modeling with the OCL, The Rationale behind the Object Constraint
Language, vol. 2263. Lecture Notes in Computer Science, 2002, pp. 85–114
[GR02b]
M. Gogolla, M. Richters, Expressing UML class diagrams properties with OCL,
in Object Modeling with the OCL, The Rationale behind the Object Constraint
Language, vol. 2263. Lecture Notes in Computer Science, 2002, pp. 85–114.
doi:10.1007/3540-45669-4_6
[GroC08]
D. Große, R. Wille, R. Siegmund, R. Drechsler, Contradiction analysis for
constraint-based random simulation, in Forum on Speciﬁcation and Design Lan-
guages, FDL 2008, September 23–25, 2008, Stuttgart, Germany, Proceedings, 2008,
pp. 130–135. doi:10.1109/FDL.2008.4641434
[Har87]
D. Harel, Statecharts: A visual formalism for complex systems. Sci. Comput.
Program. 8(3), 231–274 (1987). doi:10.1016/0167-6423(87)90035-9
[HHG14]
F. Hilken, L. Hamann, M. Gogolla, Transformation of UML and OCL models
into ﬁlmstrip models, in Theory and Practice of Model Transformations - 7th
International Conference, ICMT 2014, Held as Part of STAF 2014, York, UK, July
21–22, 2014, Proceedings, vol. 8568. Lecture Notes in Computer Science, 2014,
pp. 170–185. doi:10.1007/978-3-319-08789-4_13
[HilC14a]
C. Hilken, J. Seiter, R. Wille, U. Kühne, R. Drechsler, Verifying consistency between
activity diagrams and their corresponding OCL contracts, in Proceedings of the
2014 Forum on Speciﬁcation and Design Languages, FDL 2014, Munich, Germany,
October 14–16, 2014, 2014, pp. 1–7. doi:10.1109/FDL2014.7119340
[HilC14b]
F. Hilken, P. Niemann, M. Gogolla, R. Wille, Filmstripping and unrolling: A
comparison of veriﬁcation approaches for UML and OCL behavioral models, in
Tests and Proofs - 8th International Conference TAP 2014, Held as Part of STAF
2014, York, UK, July 24–25, 2014, Proceedings, vol. 8570. Lecture Notes in
Computer Science, 2014, pp. 99–116. doi:10.1007/978-3-642-21768-5_12
[HN96]
D. Harel, A. Naamad, The STATEMATE semantics of statecharts. ACM Trans.
Softw. Eng. Methodol. 5(4), 293–333 (1996). doi:10.1145/235321.235322
[HPS13]
W.-l. Huang, J. Peleska, U. Schulze, Test Automation Support. Tech. rep. D34.1.
COMPASS comprehensive modelling for advanced systems of systems, 2013.
URL:http://www.compass-research.eu/deliverables.html
[HPW15]
C. Hilken, J. Peleska, R. Wille, A uniﬁed formulation of behavioral semantics
for SysML models, in MODELSWARD 2015 - Proceedings of the 3rd Inter-
national Conference on Model-Driven Engineering and Software Development,
ESEO, Angers, Loire Valley, France, 9–11 February, 2015, 2015, pp. 263–271.
doi:10.5220/0005241602630271

250
References
[IgnC15]
A. Ignatiev, A. Previti, M.H. Lifﬁton, J. Marques-Silva, Smallest MUS extraction
with minimal hitting set dualization, in Principles and Practice of Constraint
Programming - 21st International Conference, CP 2015, Cork, Ireland, August–31
September 4, 2015, Proceedings, vol. 9255. Lecture Notes in Computer Science,
2015, pp. 173–182. doi:10.1007/978-3-319-23219-5_13
[Jac02a]
D. Jackson, Alloy: a lightweight object modelling notation. ACM Trans. Softw. Eng.
Methodol. 11(2), 256–290 (2002). doi:10.1145/505145.505149
[Jac02b]
D. Jackson, Alloy: A new technology for software modelling, in Tools and Algo-
rithms for the Construction and Analysis of Systems, 8th International Conference,
TACAS 2002, Held as Part of the Joint European Conference on Theory and Practice
of Software, ETAPS 2002, Grenoble, France, April 8–12, 2002, Proceedings,
vol. 2280. Lecture Notes in Computer Science, 2002, p. 20. doi:10.1007/3-540-
46002-0_2
[Jac12]
D. Jackson, Software Abstractions - Logic, Language, and Analysis, 2012, pp. I–
XVI, 1–350. ISBN: 978-0-262-10114-1
[Kar72]
R.M. Karp, Reducibility among combinatorial problems, in Proceedings of a
Symposium on the Complexity of Computer Computations, held March 20–22, 1972,
at the IBM Thomas J Watson Research Center Yorktown Heights, New York. The
IBM Research Symposia Series, 1972, pp. 85–103. URL:http://www.cs.berkeley.
edu/~luca/cs172/karp.pdf
[KG12]
M. Kuhlmann, M. Gogolla, From UML and OCL to relational logic and back, in
Model Driven Engineering Languages and Systems - 15th International Conference,
MODELS 2012, Innsbruck, Austria, September 30–October 5, 2012, Proceedings,
vol. 7590. Lecture Notes in Computer Science, 2012, pp. 415–431. doi:10.1007/978-
3-642-33666-9_27
[KM02]
A. Knapp, S. Merz, Model checking and code generation for UML state machines
and collaborations, in 2002, pp. 59–64
[Kos06]
P. Kosiuczenko, Speciﬁcation of invariability in OCL, in Model Driven Engineering
Languages and Systems, 9th International Conference, MoDELS 2006, Genova,
Italy, October 1–6, 2006, Proceedings, vol. 4199. Lecture Notes in Computer
Science, 2006, pp. 676–691. doi:10.1007/11880240_47
[Kos13]
P. Kosiuczenko, Speciﬁcation of invariability in OCL – specifying invariable system
parts and views. Softw. Syst. Model. 12(2), 415–434 (2013). doi:10.1007/s10270-
011-0215-y
[KT14]
D. Kroening, M. Tautschnig, CBMC - C bounded model checker - (competition
contribution), in Tools and Algorithms for the Construction and Analysis of Systems
- 20th International Conference. TACAS 2014, Held as Part of the European Joint
Conferences on Theory and Practice of Software, ETAPS 2014, Grenoble, France,
April 5–13, 2014, Proceedings, vol. 8413. Lecture Notes in Computer Science, 2014,
pp. 389–391. doi:10.1007/9783-642-54862-8_26
[KyaC05]
M. Kyas, H. Fecher, F.S. de Boer, J. Jacob, J. Hooman, M. van der Zwaag, T. Arons,
H. Kugler, Formalizing UML models and OCL constraints in PVS. Electr. Notes
Theor. Comput. Sci. 115, 39–47 (2005). doi:10.1016/j.entcs.2004.09.027
[LA04]
C. Lattner, V.S. Adve, LLVM: A compilation framework for lifelong program
analysis & transformation, in 2nd IEEE / ACM International Symposium on Code
Generation and Optimization (CGO 2004), 20–24 March 2004, San Jose CA, USA,
2004, pp. 75–88. doi:10.1109/CGO.2004.1281665
[LeC13]
H.M. Le, D. Große, V. Herdt, R. Drechsler, Verifying SystemC using an intermediate
veriﬁcation language and symbolic simulation, in The 50th Annual Design Automa-
tion Conference 2013, DAC ‘13, Austin, TX, USA, May 29–June 07, 2013, 2013,
pp. 116:1–116:6. doi:10.1145/2463209.2488877
[Lei08]
K.R.M. Leino, This Is Boogie 2. Tech. rep. 2008. URL:http://research.microsoft.
com/en-us/um/people/leino/papers/krml178.pdf
[LifC16]
M.H. Lifﬁton, A. Previti, A. Malik, J. Marques-Silva, Fast, ﬂexible MUS enumera-
tion. Constraints 21(2), 223–250 (2016). doi:10.1007/s10601-015-9183-0

References
251
[LLH05]
X.
Li,
Z.
Liu,
J.
He,
Consistency
checking
of
UML
tequirements,
in
10th International Conference on Engineering of Complex Computer Systems
(ICECCS 2005), 16–20 June 2005, Shanghai, China, 2005, pp.
411–420.
doi:10.1109/ICECCS.2005.28
[LMM99]
D. Latella, I. Majzik, M. Massink, Towards a formal operational semantics of UML
statechart diagrams, in Formal Methods for Open Object-Based Distributed Systems,
IFIF TC6/WG6.1 Third International Conference on Formal Methods for Open
Object-Based Distributed Systems (FMOODS), February 15–18, 1999, Florence
Italy, vol. 139. IFIP Conference Proceedings, 1999
[LP99]
J. Lilius, I. Paltor, vUML: A tool for verifying UML models, in The
14th IEEE International Conference on Automated Software Engineering ASE
1999, Cocoa Beach, Florida, USA, 12–15 October 1999, 1999, pp. 255–258.
doi:10.1109/ASE1999.802301
[MB08]
L.M. de Moura, N. Bjørner, Z3: An efﬁcient SMT solver, in Tools and Algorithms
for the Construction and Analysis of Systems, 14th International Conference TACAS
2008, Held as Part of the Joint European Conferences on Theory and Practice of
Software, ETAPS 2008, Budapest, Hungary March 29–April 6, 2008, Proceedings,
vol. 4963. Lecture Notes in Computer Science, 2008, pp. 337–340. doi:10.1007/978-
3-540-78800-3_24
[MHS09]
R. Moiseev Shinpei Hayashi, M. Saeki, Generating assertion code from OCL: A
transformational approach based on similarities of implementation languages, in
Model Driven Engineering Languages and Systems, 12th International Conference
MODELS 2009, Denver, CO, USA, October 4–9, 2009, Proceedings, vol. 5795.
Lecture Notes in Computer Science, 2009, pp. 650–664. doi:10.1007/978-3-642-
04425-0_52
[MJB13]
J. Marques-Silva, M. Janota, A. Belov, Minimal sets over monotone predicates in
boolean formulae, in Computer Aided Veriﬁcation - 25th International Conference,
CAV 2013, Saint Petersburg, Russia, July 13–19, 2013, Proceedings, vol. 8044.
Lecture Notes in Computer Science, 2013, pp. 592–607. doi:10.1007/9783-642-
39799-8_39
[MNM87]
B. Meyer, J.-M. Nerson, M. Matsuo, EIFFEL: object-oriented design for software
engineering, in ESEC ‘87, 1st European Software Engineering Conference, Stras-
bourg, France, September, 9–11, 1987, Proceedings, vol. 289. Lecture Notes in
Computer Science, 1987, pp. 221–229. doi:10.1007/BFb0022115
[MY12]
F. Mallet, L. Yin, Correct Transformation from CCSL to Promela for Veriﬁcation.
Tech. rep. RR-7491, 2012, p. 33. URL:https://hal.inria.fr/hal-00667849/ﬁle/RR-
7491.pdf
[NBE12]
A. Nöhrer, A. Biere, A. Egyed, Managing SAT inconsistencies with HUMUS,
in Sixth International Workshop on Variability Modelling of Software-Intensive
Systems, Leipzig, Germany, January 25–27, 2012, Proceedings, 2012, pp. 83–91
[NieC15a]
P. Niemann, F. Hilken, M. Gogolla, R. Wille, Assisted generation of frame con-
ditions for formal models, in Proceedings of the 2015 Design, Automation & Test
in Europe Conference & Exhibition, DATE 2015, Grenoble, France, March 9–13,
2015, 2015, pp. 309–312. URL:http://dl.acm.org/citation.cfm?id=2755822
[NieC15b]
P. Niemann, F. Hilken, M. Gogolla, R. Wille, Extracting frame conditions from
operation contracts, in 18th ACM/IEEE International Conference on Model Driven
Engineering Languages and Systems, MoDELS 2015, Ottawa, ON, Canada, Septem-
ber 30-October 2, 2015, 2015, pp. 266–275. doi:10.1109/MODELS.2015.7338257
[NPB15]
A. Niemetz, M. Preiner, A. Biere, Boolector 2.0. J. Satisﬁability, Boolean Modeling
and Computation 9, 53–58 (2015)
[Obj11]
Object Management Group, UML Proﬁle for MARTE: Modeling and Analysis of
Real-Time Embedded Systems, June 2, 2011. 754 pp.
[Obj14]
Object Management Group, Object Constraint Language – Version 2.4, Feb 3, 2014.
230 pp. URL:http://www.omg.org/spec/OCL/2.4

252
References
[Obj15]
Object Management Group, OMG Uniﬁed Modeling Language TM (OMG UML) –
Version 2.5, Mar 1, 2015. 230 pp. URL:http://www.omg.org/spec/UML/2.5/
[PelC]
J. Peleska, F. Lapschies, H. Löding, P. Smuda, H. Schmid, E. Vorobev, C. Zahlten,
Turn Indicator Model Overview. URL:http://www.informatik.uni-bremen.de/agbs/
testingbenchmarks/turn_indicator/index_e.html
[Pel13]
J. Peleska, Industrial-strength model-based testing - state of the art and current chal-
lenges, in Proceedings Eighth Workshop on Model-Based Testing, MBT 2013, Rome,
Italy, 17th March 2013, vol. 111. EPTCS, 2013, pp. 3–28. doi:10.4204/EPTCS.111.1
[PetC15]
J. Peters, R. Wille, N. Przigoda, U. Kühne, R. Drechsler, A generic representation
of CCSL time constraints for UML/MARTE models, in Proceedings of the 52nd
Annual Design Automation Conference San Francisco, CA, USA, June 7–11, 2015,
2015, pp. 122:1–122:6. doi:10.1145/2744769.2744775
[PetC16]
J. Peters, N. Przigoda, R. Wille, R. Drechsler, Clocks vs. instants relations:
verifying CCSL time constraints in UML/MARTE models, in 2016 ACM/IEEE
International Con- ference on Formal Methods and Models for System Design,
MEMOCODE 2016, Kanpur, India, November 18–20, 2016, 2016, pp. 78–84.
doi:10.1109/MEMCOD.2016.7797750
[PrzC15a]
N. Przigoda, C. Hilken, R. Wille, J. Peleska, R. Drechsler, Checking concurrent
behavior in UML/OCL models, in 18th ACM/IEEE International Conference on
Model Driven Engineering Languages and Systems, MoDELS 2015, Ottawa, ON,
Canada, September 30–October 2, 2015, 2015, pp. 176–185. doi:10 1109/MOD-
ELS.2015.7338248
[PrzC15b]
N. Przigoda, J. Peters, M. Soeken, R. Wille, R. Drechsler, Towards an automatic
approach for restricting UML/OCL invariability clauses, in Proceedings of the 12th
Workshop on Model-Driven Engineering Veriﬁcation and Validation co- located
with ACM/IEEE 18th International Conference on Model Driven Engineering
Languages and Systems, MoDeVVa@MoDELS 2015, Ottawa, Canada, September
29, 2015, vol. 1514. CEUR Workshop Proceedings, 2015, pp. 44–47. URL:http://
ceur-ws.org/Vol1514/paper6.pdf
[PrzC15c]
N. Przigoda, J. Stoppe, J. Seiter, R. Wille, R. Drechsler, Veriﬁcation-driven design
across abstraction levels: A case study, in 2015 Euromicro Conference on Digital
System Design, DSD 2015, Madeira, Portugal, August 26–28, 2015, 2015, pp. 375–
382. doi:10.1109/DSD.2015.88
[PrzC16a]
N. Przigoda, J.G. Filho, P. Niemann, R. Wille, R. Drechsler, Frame condi-
tions in symbolic representations of UML/OCL models, in 2016 ACM/IEEE
International Conference on Formal Methods and Models for System Design,
MEMOCODE 2016, Kanpur, India, November 18–20, 2016, 2016, pp. 65–70.
doi:10.1109/MEMCOD.2016.7797747
[PrzC16b]
N. Przigoda, F. Hilken, J. Peters, R. Wille, M. Gogolla, R. Drechsler, Integrating an
SMT-based modelFinder into USE, in Proceedings of the 13th Workshop on Model-
Driven Engineering Veriﬁcation and Validation, co-located with ACM/IEEE 19th
International Conference on Model Driven Engineering Languages and Systems
(MODELS 2016), Saint-Malo, France, October 3, 2016, vol. 1713. CEUR Workshop
Proceedings, 2016, pp. 40–45. URL:http://ceur-ws.org/Vol-1713/MoDeVVa2016_
paper_5.pdf
[PrzC16c]
N. Przigoda, M. Soeken, R. Wille, R. Drechsler, Verifying the structure and behavior
in UML/OCL models using satisﬁability solvers. IET Cyper-Phys. Syst. Theory
Appl. 1(1), 49–59 (2016). doi:10.1049/iet-cps.2016.0022
[PrzC17]
N. Przigoda, P. Niemann, J. Peters, F. Hilken, R. Wille, R. Drechsler, More
than true or false: native support of irregular values in the automatic validation
& veriﬁcation of UML/OCL models, in Proceedings of the 15th ACM-IEEE
International Conference on Formal Methods and Models for System Design, MEM-
OCODE 2017, Vienna, Austria, September 29–October 02, 2017, 2017, pp. 77–86.
doi:10.1145/3127041.3127053

References
253
[PWD14]
J. Peters, R. Wille, R. Drechsler, Generating SystemC implementations for clock
constraints speciﬁed in UML/MARTE CCSL, in 2014 19th International Confer-
ence on Engineering of Complex Computer Systems, Tianjin, China, August 4–7,
2014, 2014, pp. 116–125. doi:10.1109/ICECCS.2014.24
[PWD15a]
N. Przigoda, R. Wille, R. Drechsler, Contradiction analysis for inconsistent formal
models, in 18th IEEE International Symposium on Design and Diagnostics of
Electronic Circuits & Systems, DDECS 2015, Belgrade Serbia, April 22–24, 2015,
2015, pp. 171–176. doi:10.1109/DDECS.2015.52
[PWD15b]
N. Przigoda, R. Wille, R. Drechsler, Leveraging the analysis for invariant indepen-
dence in formal system models, in 2015 Euromicro Conference on Digital System
Design, DSD 2015, Madeira, Portugal, August 26–28, 2015, 2015, pp. 359–366.
doi:10.1109/DSD.2015.85
[PWD15c]
N. Przigoda, R. Wille, R. Drechsler, Verbesserung der Fehlersuche in inkonsistenten
formalen Modellen (Erweiterte Zusam-menfassung), in Methoden und Beschrei-
bungssprachen zur Modellierung und Veriﬁkation von Schaltungen und Systemen,
MBMV 2015, Chemnitz, Germany, March 3–4, 2015, 2015, pp. 165–172
[PWD16a]
N. Przigoda, R. Wille, R. Drechsler, Analyzing inconsistencies in UML/OCL
models. J. Circuits Syst. Comput. 25(3) (2016). doi:10.1142/S0218126616400211
[PWD16b]
N. Przigoda, R. Wille, R. Drechsler, Ground setting properties for an efﬁcient trans-
lation of OCL in SMT-based model ﬁnding, in Proceedings of the ACM/IEEE 19th
International Conference on Model Driven Engineering Languages and Systems,
Saint-Malo, France, October 2–7, 2016, 2016, pp. 261–271. URL:http://dl.acm.org/
citation.cfm?id=2976780
[RHB97]
A.W. Roscoe, C.A.R. Hoare, R. Bird, The Theory and Practice of Concurrency
(Upper Saddle River, NJ, USA, 1997). ISBN:0136744095. URL:https://www.cs.ox.
ac.uk/people/bill.roscoe/publications/68b.pdf
[RieC14]
H. Riener, O. Keszocze, R. Drechsler, G. Fey, A logic for cardinality constraints
(extended abstract), in Methoden und Beschreibungssprachen zur Modellierung und
Veriﬁkation von Schaltungen und Systemen, MBMV 2014, Böblingen, Germany,
2014, pp. 217–220
[RJB05]
J.E. Rumbaugh, I. Jacobson, G. Booch, The Uniﬁed Modeling Language Reference
Manuel - Covers UML 2.0, Second Edition. Addison Wesley Object Technology
Series, 2005. ISBN:978-0-321-24562-5
[SGS02]
O. Spinczyk, A. Gal, W. Schröder-Preikschat, AspectCCC: An aspect-oriented
extension to the CCC programming language, in International Conference on
Tools Paciﬁc: Objects for Internet, Mobile and Embedded Applications, Australian
Computer Society, Inc., 2002, pp. 53–60
[SMA05]
K. Sen, D. Marinov, G. Agha, CUTE: a concolic unit testing engine for C, in
Proceedings of the 10th European Software Engineering Conference Held Jointly
with 13th ACM SIGSOFT International Symposium on Foundations of Software
Engineering, 2005, Lisbon, Portugal, September 5–9, 2005, 2005, pp. 263–272.
doi:10.1145/1081706.1081750
[SNW96]
V. Sassone, M. Nielsen, G. Winskel, Models for concurrency: towards a clas-
siﬁcation. Theor. Comput. Sci. 170(1–2), 297–348 (1996). doi:10.1016/S0304-
3975(96)80710-9
[SoeC10]
M. Soeken, R. Wille, M. Kuhlmann, M. Gogolla, R. Drechsler, Verifying UML/OCL
models using Boolean satisﬁability, in Design, Automation and Test in Europe,
DATE 2010, Dresden, Germany, March 8–12, 2010, 2010, pp. 1341–1344.
doi:10.1109/DATE.2010.5457017
[Soe13]
M. Soeken, Formal speciﬁcation level: concepts, methods, and algorithms. PhD
thesis. University of Bremen, 2013
[SSS00]
M. Sheeran, S. Singh, G. Stålmarck, Checking safety properties using induction and
a SAT-Solver, in: Formal Methods in Computer-Aided Design, Third International
Conference FMCAD 2000, Austin, Texas, USA, November 1–3, 2000, Proceedings,
vol. 1954. Lecture Notes in Computer Science, 2000, pp. 108–125. doi:10.1007/3-
540-40922-X_8

254
References
[Sta08]
T.S. Staines, Intuitive mapping of UML 2 activity diagrams into fundamental
modeling concept Petri Net Diagrams and Colored Petri Nets, in 15th Annual IEEE
International Conference and Workshop on Engineering of Computer Based Systems
(ECBS 2008), 31 March–4 April 2008, Belfast, Northern Ireland, 2008, pp. 191–
200. doi:10.1109/ECBS.2008.12
[SteC09]
D. Steinberg, F. Budinsky, M. Paternostro, E. Merks, EMF: Eclipse Modeling
Framework 2.0, 2009
[SWD11a]
M. Soeken, R. Wille, R. Drechsler, Encoding OCL data types for SAT-based veriﬁ-
cation of UML/OCL models, in Tests and Proofs - 5th International Conference,
TAP 2011, Zurich, Switzerland, June 30–July 1, 2011, Proceedings, vol. 6706.
Lecture Notes in Computer Science, 2011, pp. 152–170. doi:10.1007/978-3-642-
21768-5_12
[SWD11b]
M. Soeken, R. Wille, R. Drechsler, Towards automatic determination of problem
bounds for object instantiation in static model veriﬁcation, in Proceedings of the 8th
International Workshop on Model-Driven Engineering, Veriﬁcation and Validation,
2011, pp. 2:1–2:4
[SWD11c]
M. Soeken, R. Wille, R. Drechsler, Verifying dynamic aspects of UML models, in
Design, Automation and Test in Europe DATE 2011, Grenoble France March 14–18,
2011, 2011, pp. 1077–1082. doi:10.1109/DATE.2011.5763177
[SWD13]
J. Stoppe, R. Wille, R. Drechsler, Data extraction from SystemC designs using
debug symbols and the SystemC API, in IEEE Computer Society Annual Sympo-
sium on VLSI, ISVLSI 2013, Natal, Brazil, August 5–7, 2013, 2013, pp. 26–31.
doi:10.1109/ISVLSI.2013.6654618
[SWD14]
J. Stoppe, R. Wille, R. Drechsler, Validating SystemC implementations against their
formal speciﬁcations, in Proceedings of the 27th Symposium on Integrated Circuits
and Systems Design, Aracaju, Brazil, September 1–5, 2014, 2014, pp. 13:1–13:8.
doi:10.1145/2660540.2660981
[SWD15]
J. Stoppe, R. Wille, R. Drechsler, Automated feature localization for dynamically
generated SystemC designs, in Proceedings of the 2015 Design, Automation & Test
in Europe Confer ence & Exhibition, DATE 2015, Grenoble France, March 9–13,
2015, 2015, pp. 277–280. URL:http://dl.acm.org/citation.cfm?id=2755814
[SY12]
J. Suryadevara, L. Yin, Timed automata modeling of CCSL constraints, in Formal
Techniques for Safety-Critical Systems - First International Workshop, FTSCS 2012,
Kyoto, Japan, November 12, 2012, 2012, pp. 152–156. URL:http://csaba.olveczky.
se/ftscs12-preproceedings.pdf
[TCJ08]
E. Torlak, F. Sheng-Ho Chang, D. Jackson, Finding minimal unsatisﬁable cores
of declarative speciﬁcations, in FM 2008: Formal Methods, 15th International
Symposium on Formal Methods, Turku, Finland, May 26–30, 2008, Proceed-
ings, vol.
5014. Lecture Notes in Computer Science, 2008, pp. 326–341.
doi:10.1007/978-3-540-68237-0_23
[TJ07]
E. Torlak, D. Jackson, Kodkod: A relational model ﬁnder, in Tools and Algorithms
for the Construction and Analysis of Systems, 13th International Conference, TACAS
2007, Held as Part of the Joint European Conferences on Theory and Practice
of Software, ETAPS 2007 Braga, Portugal, March 24 April 1, 2007, Proceedings,
vol. 4424. Lecture Notes in Computer Science, 2007, pp. 632–647. doi:10.1007/978-
3-540-71209-1_49
[WilC13]
R. Wille, M. Gogolla, M. Soeken, M. Kuhlmann, R. Drechsler, Towards a generic
veriﬁcation methodology for system models, in Design, Automation and Test in
Europe, DATE 13, Grenoble, France, March 18–22, 2013, 2013, pp. 1193–1196.
doi:10.7873/DATE.2013.248
[WN93]
G. Winskel, M. Nielsen, Models for Concurrency. Tech. rep. 463, 1993
[WSD12]
R. Wille, M. Soeken, R. Drechsler, Debugging of inconsistent UML/OCL mod-
els, in 2012 Design, Automation & Test in Europe Conference & Exhibition,
DATE 2012, Dresden, Germany, March 12–16, 2012, 2012, pp. 1078–1083.
doi:10.1109/DATE.2012.6176655

References
255
[YML11]
L. Yin, F. Mallet, J. Liu, Veriﬁcation of MARTE/CCSL time requirements in
Promela/SPIN, in 16th IEEE International Conference on Engineering of Complex
Computer Systems, ICECCS 2011, Las Vegas, Nevada, USA, 27–29 April 2011,
pp. 65–74. doi:10.1109/ICECCS.2011.14
[ZhaC11]
J. Zhang, S. Shen, J. Zhang, W. Xu, S. Li, Extracting minimal unsatisﬁable
subformulas in satisﬁability modulo theories. Comput. Sci. Inf. Syst. 8(3), 693–710
(2011). doi:10.2298/CSIS101019024Z

