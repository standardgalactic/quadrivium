Contents

1: I/O and File Systems
b'Chapter 1: I/O and File Systems'
b'Introduction'
b'Using the common I/O interfaces'
b'Using the bytes and strings packages'
b'Working with directories and files'
b'Working with the CSV format'
b'Working with temporary files'
b'Working with text/template and HTML/templates'
2: Command-Line Tools
b'Chapter 2: Command-Line Tools'
b'Introduction'
b'Using command-line\xc3\x82\xc2\xa0flags'
b'Using command-line\xc3\x82\xc2\xa0arguments'
b'Reading and setting environment variables'
b'Configuration using TOML, YAML, and JSON'
b'Working with Unix pipes'
b'Catching and handling signals'
b'An ANSI coloring application'
3: Data Conversion and Composition
b'Chapter 3: Data Conversion and Composition'
b'Introduction'
b'Converting data types and interface casting'
b'Working with numeric data types using math and math/big'
b'Currency conversions and float64 considerations'
b'Using pointers and SQL NullTypes for encoding and decoding'
b'Encoding and decoding Go data'
b'Struct tags and basic reflection in Go'
b'Implementing collections via closures'
4: Error Handling in Go
b'Chapter 4: Error Handling in Go'
b'Introduction'
b'Handling errors and the Error interface'
b'Using the pkg/errors package and wrapping errors'
b'Using\xc3\x82\xc2\xa0the log package and understanding when
to log errors'
b'Structured logging with the apex and logrus packages'

b'Logging with the context package'
b'Using package-level global variables'
b'Catching panics for long running processes'
5: All about Databases and Storage
b'Chapter 5: All about Databases and Storage'
b'Introduction'
b'The database/sql package with MySQL'
b'Executing a database transaction interface'
b'Connection pooling, rate limiting, and timeouts
for\xc3\x82\xc2\xa0SQL'
b'Working with Redis'
b'Using NoSQL with MongoDB and mgo'
b'Creating storage interfaces for data portability'
6: Web Clients and APIs
b'Chapter 6: Web Clients and APIs'
b'Introduction'
b'Initializing, storing, and passing http.Client structs'
b'Writing a client for a REST API'
b'Executing parallel and async client requests'
b'Making use of OAuth2 clients'
b'Implementing\xc3\x82\xc2\xa0an OAuth2 token storage interface'
b'Wrapping a client in added functionality and function
composition'
b'Understanding GRPC clients'
7: Microservices for Applications in Go
b'Chapter 7: Microservices for Applications in Go'
b'Introduction'
b'Working with web handlers, requests, and ResponseWriters'
b'Using structs and closures for stateful handlers'
b'Validating input for Go structs and user inputs'
b'Rendering and content negotiation'
b'Implementing and using middleware'
b'Building a reverse proxy application'
b'Exporting GRPC as\xc3\x82\xc2\xa0a JSON API'
8: Testing
b'Chapter 8: Testing'
b'Introduction'

b'Mocking using the standard library'
b'Using the Mockgen package'
b'Using table-driven tests to improve coverage'
b'Using third-party testing tools'
b'Practical fuzzing'
b'Behavior testing using Go'
9: Parallelism and Concurrency
b'Chapter 9: Parallelism and Concurrency'
b'Introduction'
b'Using channels and the select\xc3\x82\xc2\xa0statement'
b'Performing async operations
with\xc3\x82\xc2\xa0sync.WaitGroup'
b'Using atomic operations and mutex'
b'Using the context package'
b'Executing state management for channels'
b'Using the worker pool design pattern'
b'Using workers to create pipelines\xc3\x82\xc2\xa0'
10: Distributed Systems
b'Chapter 10: Distributed Systems'
b'Introduction'
b'Using service discovery with Consul'
b'Implementing basic consensus using Raft'
b'Using containerization with Docker'
b'Orchestration and deployment strategies'
b'Monitoring applications'
b'Collecting metrics'
11: Reactive Programming and Data Streams
b'Chapter 11: Reactive Programming and Data Streams'
b'Introduction'
b'Goflow for dataflow programming'
b'Reactive programming with\xc3\x82\xc2\xa0RxGo'
b'Using Kafka with Sarama'
b'Using async producers with Kafka'
b'Connecting Kafka to Goflow'
b'Writing a GraphQL server in Go'
12: Serverless Programming
b'Chapter 12: Serverless Programming'

b'Introduction'
b'Go programming on Lambda with Apex'
b'Apex serverless logging and metrics'
b'Google App Engine with Go'
b'Working with Firebase using zabawaba99/firego'
13: Performance Improvements, Tips, and Tricks
b'Chapter 13: Performance Improvements, Tips, and Tricks'
b'Introduction'
b'Speeding up compilation and testing cycles'
b'Using the pprof tool'
b'Benchmarking and finding bottlenecks'
b'Memory allocation and heap management'
b'Vendoring and project layout'
b'Using fasthttprouter\xc3\x82\xc2\xa0and fasthttp'

Chapter 1. I/O and File Systems
In this chapter, the following recipes will be covered:
Using the common I/O interfaces
Using the bytes and strings packages
Working with directories and files
Working with the CSV format
Working with temporary files
Working with text/template and HTML/templates

Introduction
Go provides excellent support for both basic and complex I/O.Â The recipes
in this chapter will explore common Go interfaces to deal with I/O and show
how to make use of them. The Go standard library frequently uses
theseÂ interfaces, and these interfaces will be usedÂ by recipes throughout
the book.
You'll learn how toÂ workÂ with data in memory and in the form of streams.
You'll see examples of working with files and directories and of working
with the CSV format. The temporary files recipe discusses a mechanism to
work with files without the overhead of dealing with name collision and
more.Â Lastly, we'll explore Go standard templates for both plain text and
HTML.Â 
These recipes should lay the foundation for the use of interfaces to represent
and modify data and should help you think about data in an abstract and
flexible way.

Using the common I/O interfaces
Go provides a number of I/O interfaces used throughout the standard library.
It is a best practice to make use of these interfaces wherever possible rather
than passing structs or other types directly. Two powerful interfaces we
explore in this recipe are the io.Reader and io.Writer interfaces. These
interfaces are used throughout the standard library and understanding how to
use them will make you a better Go developer.
The Reader and Writer interfaces look like this:
type Reader interface {
       Read(p []byte) (n int, err error)
}
type Writer interface {
       Write(p []byte) (n int, err error)
}
Go also makes it easy to combine interfaces. For example, take a look at the
following code:
type Seeker interface {
       Seek(offset int64, whence int) (int64, error)
}
type ReadSeeker interface {
       Reader
       Seeker
}
The recipe will also explore an io function called Pipe():
func Pipe() (*PipeReader, *PipeWriter)
The remainder of this book will make use of these interfaces.Â 
Getting ready

Configure your environment according to these steps:
1. Download and install Go on your operating system...

Using the bytes and strings packages
The bytes and string packages have a number of useful helpers to work
with and convertÂ between strings and byte types. They allow the creation of
buffers that work with a number of common I/O interfaces.
Getting ready
Refer to the Getting ready section's steps in the Using the common I/O
interfaces recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create a new directory
calledÂ chapter1/bytestrings.
2. Navigate to this directory.
3. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter1/bytesstrings, or use this as an exercise to
write some of your own code!
4. Create a file called buffer.go with the following contents:
       package bytestrings
       import (
               "bytes"
               "io"
               "io/ioutil"
       )
       // Buffer demonstrates some tricks for initializing bytes 

       //Buffers
       // These buffers implement an io.Reader interface
       func Buffer(rawString string) *bytes.Buffer {
               // we'll start with a string encoded into raw...

Working with directories and files
Working with directories and files can be difficult when you switch between
platforms (Windows and Linux, for example). Go provides cross-platform
support to work with files and directories in the os and ioutils packages.
We've already seen examples of ioutils, but now we'll explore how to use
them in another way!
Getting ready
Refer to the Getting ready section's steps in the Using the common I/O
interfaces recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create a new directory
calledÂ chapter1/filedirs.
2. Navigate to this directory.
3. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter1/filedirs, orÂ use this as an exercise to
write some of your own code!
4. Create a file called dirs.go with the following contents:
       package filedirs
       import (
               "errors"
               "io"
               "os"
       )
       // Operate manipulates files and directories
       func Operate() error {

               // this 0777 is similar to what you'd see with ch
               // on a...

Working with the CSV format
CSV is a common format to manipulate data. It's common, for example, to
import or export a CSV file into Excel. The Go CSV package operates on data
interfaces, and as a result, it's easy to write data to a buffer, stdout, a file, or
to a socket. The examples in this section will show some common ways to
get data into and out of the CSV format.
Getting ready
Refer to the Getting readyÂ section's steps in theÂ Using the common I/O
interfaces recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create a new directory
calledÂ chapter1/csvformat.
2. Navigate to this directory.
3. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter1/csvformat, or use this as an exercise to
write some of your own code!
4. Create a file called read_csv.go with the following contents:
       package csvformat
       import (
               "bytes"
               "encoding/csv"
               "fmt"
               "io"

               "strconv"
       )
       // Movie will hold our parsed CSV
       type Movie struct {
             ...

Working with temporary files
We've created and made use of files for a number of examples so far. We've
also had to manually deal with cleanup, name collision, and more. Temporary
files and directories are a quicker, simpler way to handle these cases.
Getting ready
Refer to the Getting ready section's steps in theÂ Using the common I/O
interfaces recipe.
How to do it...
These steps cover writing and running your application:
1. From your terminal/console application, create a new directory
calledÂ chapter1/tempfiles.
2. Navigate to this directory.
3. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter1/tempfiles, or use this as an exercise to
write some of your own code!
4. Create a file called temp_files.go with the following contents:
       package tempfiles
       import (
               "fmt"
               "io/ioutil"
               "os"
       )
       // WorkWithTemp will give some basic patterns for working
       // with temporary files and directories
       func WorkWithTemp() error {
               // If you need a temporary place to store files w
               // the same name ie....

Working with text/template and
HTML/templates
Go provides rich support for templates. It is simple to nest templates, import
functions, represent variables, iterate over data, and so on. If you need
something more sophisticated than a CSV writer, templates may be a great
solution.
Another application for templates is for websites. When we want to render
server-side data to the client, templates fit the bill nicely. At first, Go
templates can appear confusing. This chapter will explore working with
templates, collecting templates inside of a directory, and working
withÂ HTML templates.
Getting ready
Refer to the Getting ready section's steps in theÂ Using the common I/O
interfaces recipe.
How to do it...
These steps cover writing and running your application:
1. From your terminal/console application, create a new directory
calledÂ chapter1/templates.
2. Navigate to this directory.
3. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter1/templates, or use this as an exercise to
write some of your own!
4. Create a file called templates.go with the following contents:
       package templates

       import (
           ...

Chapter 2. Command-Line Tools
In this chapter, the following recipes will be covered:
Using command-line flags
Using command-line arguments
Reading and setting environment variables
Configuration using TOML, YAML, and JSON
Working with Unix pipes
Catching and handling signals
An ANSI coloring application

Introduction
Command-line applications are amongÂ the easiest ways to handle user input
and output. This chapter will focus on command-line-based interactions, such
as command-line arguments, configuration, and environment variables. It'll
conclude with a library for coloring text output in Unix and Bash for
Windows.
With the recipes in this chapter, you should be equipped to handle expected
and unexpected user input. The signal recipeÂ is an example of cases where
users may send unexpected signals to your application, and the pipes recipe is
a good alternative to taking user inputs compared to flags or command-line
arguments.
The ANSIÂ colorÂ recipe will hopefully provide some examples of cleaning
up output to users. For example, in logging, being able to color text based on
its purpose can sometimes make large blocks of text significantly more clear.

Using command-lineÂ flags
The flag package makes it simple to add command-line flag arguments to a
Go application. It has a few shortcomings--you tend to duplicate a lot of code
in order to add shorthand versions of flags, and they're ordered alphabetically
from the help prompt. There are a number of third-party libraries that attempt
to address these shortcomings, but this chapter will focus on the standard
library version and not on those libraries.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/install, and configure yourÂ GOPATH
environment variable:
2. Open aÂ terminal/console application, and navigate to
yourÂ GOPATH/srcÂ and create a project directory, for example,
$GOPATH/src/github.com/yourusername/customrepo.
Â  All code will be run and modified from this directory.
3. Optionally, install the latest tested version of the code using theÂ go
get github.com/agtorre/go-cookbook/ command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate...

Using command-lineÂ arguments
The flags from the previous recipe are a type of command-line argument.
This chapter will expand on other uses for these arguments by constructing a
command that supports nested subcommands. This will demonstrate
FlagsetsÂ and also use positional arguments passed into your application.
Like the previous recipe, this one requires a main function to run. There are a
number of third-party packages to deal with complex nested arguments and
flags, but we'll investigate how to do that using only the standard library.
Getting ready
Refer to the Getting ready section's steps in the Using command-line
flagsÂ recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create a new directory called
Â chapter2/cmdargsÂ and navigate to that directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter2/cmdargs, or use this as an exercise to
write some of your own code!
3. Create a file calledÂ cmdargs.go with the following contents:
       package main
       import (
           "flag"
           "fmt"

          ...

Reading and setting environment variables
Environment variables are another way to pass state into an application
beyond reading data in from a file or passing it explicitly over the command
line. This recipe will explore some very basic getting and setting of
environment variables and then work with the highly useful third-party
libraryÂ https://github.com/kelseyhightower/envconfig.Â 
We'll build an application that can read a config via JSON or through
environment variables. The next recipe will further explore alternative
formats, including TOML and YAML.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section's steps in theÂ Using command-line
flags recipe.
2. Run the go getÂ github.com/kelseyhightower/envconfig/
Â command.
3. Run the go get github.com/pkg/errors/Â command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create a new directory
calledÂ chapter2/envvar and navigate to thatÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter2/envvar, or use this as an exercise to...

Configuration using TOML, YAML, and
JSON
There areÂ manyÂ configuration formats that Go, with theÂ use of third-
party libraries, has support for. Three of the most popular data formats are
TOML, YAML, and JSON. Go can support JSON out of the box, and the
others have clues on how to marshal/unmarshal or encode/decode data for
these formats. TheÂ formats have many benefits beyond configuration, but
this chapter will largely focus on converting a Go struct in the form of a
configuration struct. This recipe will explore basic input and output using
these formats.
These formats also provide an interface by which Go and applications written
in other languages can share the same configuration. There are also a number
of tools that deal with these formats and simplify working with them.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section's steps in theÂ Using command-line
flags recipe.
2. Run the go get github.com/BurntSushi/tomlÂ command.
3. Run theÂ go getÂ github.com/go-yaml/yamlÂ command.
How to do it...
These steps cover writing and running your application:
1. From...

Working with Unix pipes
Unix pipes are useful when passing the output of one program to the input of
another. For example, take a look at this:
$ echo "test case" | wc -l
  1
In a Go application, the left-hand side of the pipe can be read in using
os.Stdin and acts like a file descriptor. To demonstrate this, this recipe will
take an input on the left-hand side of a pipe and return a list of words and
their number of occurrences. These words will be tokenized on white space.
Getting ready
Refer to the Getting ready section's steps in theÂ Using command-line flags
recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create a new directory
calledÂ chapter2/pipes and navigate to thatÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter2/pipes, or use this as an exercise to write
some of your own code!
3. Create a file calledÂ pipes.go with the following contents:
       package main
       import (

           "bufio"
           "fmt"
           "io"
           "os"
       )
       // WordCount takes a file and returns a...

Catching and handling signals
Signals are a useful way for the user or the OS to kill your running
application. Sometimes, it makes sense to handle these signals in a more
graceful way than the default behavior. Go provides a mechanism to catch
and handle signals. In this recipe, we'll explore the handling of signals
through the use of a signal handling the Go routine.
Getting ready
Refer to the Getting ready section's steps in theÂ Using command-line flags
recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create a new directory
calledÂ chapter2/signals, and navigate to thatÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter2/signals, or use this as an exercise to write
some of your own code!
3. Create a file calledÂ signals.go with the following contents:
       package main
       import (
           "fmt"
           "os"
           "os/signal"
           "syscall"
       )
       // CatchSig sets up a listener for
       // SIGINT interrupts
       func CatchSig(ch chan os.Signal, done chan bool) {

        ...

An ANSI coloring application
Coloring an ANSIÂ terminal application is handled by a variety of code
before and after a section of text you want colored. This chapter will explore
a basic coloring mechanism to color text red or plain. For a complete
application, take a look atÂ https://github.com/agtorre/gocolorize, which
supports many more colors and text types and also implements the
fmt.Formatter interface for ease of printing.
Getting ready
Refer to the Getting ready section's steps in the Using command-line
flagsÂ recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter2/ansicolorÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter2/ansicolor, or use this as an exercise to
write some of your own code!
3. Create a file calledÂ color.go with the following contents:
       package ansicolor
       import "fmt"
       //Color of text
       type Color int
       const (
           // ColorNone is default
           ColorNone = iota

           // Red colored text
           Red
 ...

Chapter 3. Data Conversion and
Composition
In this chapter, the following recipes will be covered:
Converting data types and interface casting
Working with numeric data types using math and math/big
Currency conversions and float64 considerations
Using pointers and SQL NullTypes for encoding and decoding
Encoding and decoding Go data
Struct tags and basic reflection in Go
Implementing collections via closures

Introduction
Reasoning about Go's typing system is a critical step to all levels of Go
development. This chapter will show examples of converting between data
types, working with very big numbers, working with currency, types of
encoding and decoding, including base64 and gob, and creating custom
collections using closures.

Converting data types and interface casting
Go is typically very flexible in conversion between data. AÂ type may inherit
another type as follows:
type A int
Then, we can always cast back to the type we inherited as follows:
var a A = 1
fmt.Println(int(a))
There are also convenience functions for converting between numbers with
casting, between strings and other types using fmt.Sprint and with strconv,
and between interfaces and types using reflection. This recipe willÂ explore
some of these basic conversions that will be used throughout the book.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/install and configure your GOPATH
environment variable.
2. Open aÂ terminal/console application, and navigate to
yourÂ GOPATH/src and create a project directoryÂ such
asÂ $GOPATH/src/github.com/yourusername/customrepo.
Â  All the code will be run and modified from this directory.
3. Optionally, install the latest tested version of the code using theÂ go
get github.com/agtorre/go-cookbook/ command.
How to do it...Â 

These steps cover writing...

Working with numeric data types using
math and math/big
The math and math/bigÂ packages focus on exposing more complex
mathematical operations to the Go language, such as Pow, Sqrt, andÂ Cos.
The math package itself operates predominately on float64 unless a function
says otherwise. The math/big package is for numbers that are too large to
represent in a 64-bit value. This recipe will show some basic usage of the
math package and demonstrate math/big for fibonacci.
Getting ready
Refer to the steps given in the Getting ready section ofÂ theÂ Converting
data types and interface castingÂ recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter3/mathÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter3/mathÂ or use this as an exercise to write
some of your own code.
3. Create a file calledÂ math.goÂ with the following contents:
       package math
       import (
        "fmt"
        "math"
       )
       // Examples demonstrates some of the functions

       // in the math...

Currency conversions and float64
considerations
Working with currency is always a tricky process. It can be tempting to
represent money as a float64, but this can result in some pretty tricky (and
wrong) rounding errors when doing calculations. For this reason, it's
preferable to think of money in terms of cents and store it as anÂ Int64.
When collecting user input from forms, the command line, or other sources,
money is usually represented in dollar form. For this reason, it's best to treat
it as a string and convert that string directly to pennies without floating point
conversions. This recipe will present ways to convert a string representation
of currency into an int64 (pennies) and back again.
Getting ready
Refer to the steps given in theÂ Getting ready section ofÂ theÂ Converting
data types and interface casting recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter3/currencyÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter3/currencyÂ or use this as an exercise to
write...

Using pointers and SQL NullTypes for
encoding and decoding
When you encode or decode into an object in Go, types that are not explicitly
set will be set to their default values. Strings will default to empty string "",
and integers will default to 0 as an example. Normally, this is fine, unless 0
means something for your APIÂ or service that is consuming the user input
or returning it.
In addition, if you use struct tags such asÂ json omitempty, 0 values will be
ignored even if they're valid. Another example of this is Null that returns
from SQL. What value best represents Null for an Int? This recipe will
explore some of the ways Go developers deal with this issue.
Getting ready
Refer to the steps given in theÂ Getting ready section ofÂ theÂ Converting
data types and interface casting recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter3/nullsÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter3/nullsÂ or use this as an exercise to write
some of your own code.
3. Create a file...

Encoding and decoding Go data
Go features a number of alternative encoding types aside from JSON, TOML,
and YAML. These are largely meant for transporting data between Go
processes with things such asÂ wire protocols and RPCÂ or in cases where
some character formats are restricted.
This recipe will explore encoding and decoding gob format and base64. The
later chapters will explore protocols such asÂ GRPC.
Getting ready
Refer to the steps given in theÂ Getting ready section ofÂ theÂ Converting
Data Types and Interface Casting recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to a
theÂ chapter3/encodingÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter3/encodingÂ or use this as an exercise to
write some of your own.
3. Create a file calledÂ gob.goÂ with the following contents:
       package encoding
       import (
           "bytes"
           "encoding/gob"
           "fmt"
       )
       // pos stores the x, y position

       // for Object
       type pos struct {
         ...

Struct tags and basic reflection in Go
Reflection is a complicated topic that can't really be covered in a single
recipe. However, a practical application of reflection is dealing with struct
tags. At their core, struct tags are just key-value strings. You lookup the key,
then deal with the value. As you can imagine, for something like
JSONÂ marshal and unmarshal, there's a lot of complexity for dealing with
these values.
The reflectÂ package is designed for interrogating and understanding
interface objects. It has helper methods to look at kind of structs, values,
struct tags, and more. If you need something beyond the basic interface
conversion like at the beginningÂ of this chapter, this is the package you
should look at.
Getting ready
Refer to the steps given in theÂ Getting ready section ofÂ theÂ Converting
Data Types and Interface Casting recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter3/tags directory .
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter3/tagsÂ or use this as an...

Implementing collections via closures
If you've been working with functional or dynamic programming languages,
you may feel thatÂ for loops and if statements produce verbose code.
Functional constructs such asÂ map and filter for processing lists can be
useful and make code appear more readable. However, in Go, these types are
not in the standard library and can be difficult to generalize without generics
or very complex reflection and use of empty interfaces. This recipeÂ will
provideÂ you with some basic examples of implementing collections using
Go closures.
Getting ready
Refer to the steps given in theÂ Getting ready section ofÂ theÂ Converting
Data Types and Interface Casting recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter3/collections directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter3/collectionsÂ or use this as an exercise to
write some of your own code.
3. Create a file calledÂ collections.goÂ with the following contents:
       package collections
       //...

Chapter 4. Error Handling in Go
In this chapter, the following recipes will be covered:
Handling errors and the Error interface
Using the pkg/errors package and wrapping errors
UsingÂ the log package and understanding when to log errors
Structured logging with the apex and logrus packages
Logging with the context package
Using package-level global variables
Catching panics for long running processes

Introduction
Error handling is important for even the most basic Go program. Errors in Go
implement the Error interface and must be dealt with at every layer of the
code. Go errorsÂ do not work like exceptions, and unhandled errors can
cause enormous problems. You should strive to handle and consider errors
whenever they occur.
This chapter also covers logging since it's common to log whenever an actual
error occurs. We'll also investigate wrapping errors so that a given error has
the appropriate amount of context for the calling function.

Handling errors and the Error interface
The Error interface is a pretty small and simple interface:
type Error interface{
 Error() string
}
This interface is elegant because it's simple to make anything to satisfy it.
Unfortunately, this also creates confusion for packages that need to take
certain actions depending on the error received.
There are a number of ways to create errors in Go, this recipe will explore the
creation of basic errors, errors that have assigned values or types, and of a
custom error using a struct.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/install, and configure yourÂ GOPATH
environment variable.Â 
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ and create a project directory, for
example, $GOPATH/src/github.com/yourusername/customrepo.
Â  All code will be run and modified from this directory.
4. Optionally, install the latest tested version of the code using the go get
github.com/agtorre/go-cookbook/ command.
How to do it...

These steps cover writing and running your application:
1. From...

Using the pkg/errors package and wrapping
errors
The errors package located atÂ github.com/pkg/errors is a drop in
replacement for the standard Go errors package. In addition, it provides
some very useful functionality for wrapping and handling errors. The typed
and declared errors in the preceding recipe are a good example--they can be
useful to add additional information to an error, but wrapping it in the
standard way will change its type and break type assertion:
// this wont work if you wrapped it 
// in a standard way. i.e.
// fmt.Errorf("custom error: %s", err.Error())
if err == Package.ErrorNamed{
 //handle this error in a specific way
}
This recipe will demonstrate how to use theÂ pkg/errorsÂ package to add
annotation to errors throughout your code.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Handling errors and the Error
interface recipe in this chapter.
2. Run the go getÂ github.com/pkg/errors/Â command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create theÂ 

UsingÂ the log package and understanding
when to log errors
Logging should typically occur when an error is the final result. In other
words, it's useful to log when something exceptional or unexpected occurs. It
might also be appropriate, if you use a log that provides log levels, to sprinkle
debug or info statements at key parts of your code to quickly debug issues
during development.Â Too much logging will make it difficult to find
anything useful, but not enough logging can result in broken systems with no
insight into the root cause. This recipe will demonstrate the use of the default
Go log package and some useful options and showcase when a log should
probably occur.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Handling errors and the Error
interfaceÂ recipe in this chapter.
2. Run the go getÂ github.com/pkg/errors/ command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter4/logÂ directory and navigate to it.
2. Copy tests fromÂ 

Structured logging with the apex and logrus
packages
The primary reason to log information is to examine the state of the system
when events occur or occurred in the past. Basic log messages are tricky to
comb over when you have a large number of microservices that are
logging.Â 
There's a variety of third-party packages for combing over logs if you can get
the logs into a data format they understand. These packages provide indexing
functionality, searchability, and more. The sirupsen/logrus and apex/log
packages provide a way to do structured logging where you can log a number
of fields that can be reformatted to fit these third-party log readers. For
example, it's simple to emit logs in the JSONÂ format to be parsed by a
variety of services.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Handling errors and the Error
interfaceÂ recipe.
2. Run the go getÂ github.com/sirupsen/logrusÂ command.Â 
3. Run theÂ go get github.com/apex/log command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create the

Logging with the context package
This recipe will demonstrate a way to pass log fields between various
functions. The Go pkg/context package is an excellent way to pass
additional variables and cancelation between functions. This recipe will
explore using this functionality to distribute variables between functions for
logging purposes.
This style can be adapted to logrus or apex from the previous recipe. We'll
use apex for this recipe.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Handling errors and the Error
interfaceÂ recipe.
2. Run theÂ go get github.com/apex/log command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application create and navigate to
theÂ chapter4/contextÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter4/contextÂ or use this as an exercise to
write some of your own code.
3. Create a file calledÂ log.goÂ with the following content:
       package context
       import (
           "context"

           "github.com/apex/log"
       )
       type...

Using package-level global variables
The apex and logrusÂ packages in the earlier examples both used a package-
level global variable. Sometimes, it's useful to structure your libraries to
support both structs with a variety of methods and top-level functions so that
you can use them directly without passing them around.Â 
This recipe also demonstrates using sync.Once to ensure that the global
logger will only be initialized once. It can also be bypassed by the Set
method. The recipe only exports WithField and Debug, but one can imagine
exporting every method attached to a log object.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Handling errors and the Error
interfaceÂ recipe.
2. Run the go getÂ github.com/sirupsen/logrus command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter4/globalÂ directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter4/globalÂ orÂ use this as an exercise to
write some of your own code.
3. Create a file...

Catching panics for long running processes
When implementing long running processes, it's possible that certain code
paths will result in a panic. This is usually common for things uninitialized
maps and pointers, as well as division by zero problems in the case of poorly
validated user input.
Having a program crash completely in these cases is frequently much worse
than the panic itself, and so it can be helpful to catch and handle panics.
Getting ready
Refer to the Getting ready section of the Handling errors and the Error
interfaceÂ recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create the chapter4/panic
directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter4/panicÂ orÂ use this as an exercise to
write some of your own code.
3. Create a file calledÂ panic.goÂ with the following content:
       package panic
       import (
           "fmt"
           "strconv"
       )

       // Panic panics with a divide by zero
       func Panic() {
           zero, err :=...

Chapter 5. All about Databases and Storage
In this chapter, the following recipes will be covered:
The database/sql package with MySQL
Executing a database transaction interface
Connection pooling, rate limiting, and timeouts forÂ SQL
Working with Redis
Using NoSQL with MongoDB and mgo
Creating storage interfaces for data portability

Introduction
Go applications frequently need to make use of long-term storage. This is
usually in the form of relational and non-relational databases, as well as key-
value stores and more. When working with these storage applications, it helps
to wrap your operations in an interface. The recipes in this chapter will
examine various storage interfaces, considering parallel access with things
such asÂ connection pools, and look at general tips for integrating a new
library, which is often the case when using a new storage technology.

The database/sql package with MySQL
Relational databases are some of the most well understood and common
database options. MySQL and Postgres are two of the most popular open
source relational databases. This recipe will demonstrate the database/sql
package, a package that provides hooks for a number of relational databases
and automatically handles connection pooling, connection duration, and gives
access to a number of basic database operations.
The future versions of this package will include support for context and
timeouts.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/install, and configure yourÂ GOPATH
environment variable.
2. Open aÂ terminal/console application, navigate to
yourÂ GOPATH/srcÂ and create a project directory such as
Â $GOPATH/src/github.com/yourusername/customrepo.
Â  All code will be run and modified from this directory.
3. Optionally, install the latest tested version of the code using the go get
github.com/agtorre/go-cookbook/ command.
4. Run theÂ go get github.com/go-sql-driver/mysql command.
5. Install and...

Executing a database transaction interface
When working with connections to services such as database, it can be
difficult to write tests. This is because it's difficult in Go to mock or duck-
type things at runtime. Although I recommend using a storage interface when
working with databases, it's still useful to mock a database transaction
interface inside of this interface. TheÂ Creating storage interfaces for data
portability recipeÂ will cover storage interfaces; this one will focus on an
interface to wrap database connections and transaction objects.
To show the use of such an interface, we'll rewrite the create and query files
from the previous recipe to use our interface. The final output will be the
same, but the create and query operations will all be performed in a
transaction.
Getting ready
Configure your environment according to these steps:
1. Refer to the steps given in theÂ Getting ready section ofÂ theÂ The
database/sql package with MySQL recipe.
2. Run theÂ go getÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter5/database command or write your
own using theÂ The database/sql package with MySQL...

Connection pooling, rate limiting, and
timeouts forÂ SQL
Although the database/sql package provides support for connection
pooling, rate limiting, and timeouts, it's often important to tweak the defaults
to better accommodate your database configuration. This can become
important when you have horizontal scaling on microservices and don't want
to hold too many active connections to the database.
Getting ready
Configure your environment according to these steps:
1. Refer to the steps given in theÂ Getting ready section ofÂ the The
database/sql package with MySQL recipe.
2. Run theÂ go getÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter5/databaseÂ command or write your
own using theÂ The database/sql package with MySQL recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to the
chapter5/pools directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter5/poolsÂ or use this as an exercise to write
some of your own code.
3. Create a file called pools.goÂ with the following contents:

       package pools
...

Working with Redis
Sometimes you want persistent storage or additional functionality provided
by third-party libraries and services. This recipe will explore Redis as a form
of non-relational data storage and showcase how a language such asÂ Go can
interact with these services.Â 
Since Redis supports key-value storage with a simple interface, it's an
excellent candidate for session storage or temporary data that hasÂ a
duration. The ability to specify timeout on data stored in Redis is extremely
valuable. This recipe will explore basic Redis usage from configuration, to
querying, to using custom sorting.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/install, and configure yourÂ GOPATH
environment variable.
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ and create a project directory such
asÂ $GOPATH/src/github.com/yourusername/customrepo.
Â  All code will be run and modified from this directory.
4. Optionally, install the latest tested version of the code using theÂ go
get...

Using NoSQL with MongoDB and mgo
You might first think that Go is better suited to relational databases due to Go
structs and because Go is a typed language. When working with something
like the mgo package, Go can nearly arbitrarily store and retrieve struct
objects. If you version your objects, your schema can adapt and it can provide
a very flexible development environment.Â 
Some libraries do a better job of hiding or elevating these abstractions. The
mgo package is an excellent example of a library that does an excellent job of
the former. This recipe will create a connection in a similar way to Redis and
MySQL, but will store and retrieve an object without even defining a
concrete schema.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/install, and configure yourÂ GOPATH
environment variable.
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ and create a project directoryÂ such
asÂ $GOPATH/src/github.com/yourusername/customrepo.
Â  All code will be run and modified from this directory.
4. Optionally,...

Creating storage interfaces for data
portability
When working with external storage interfaces, it can be helpful to abstract
your operations behind an interface. This is for ease of mocking, portability
in case you change storage backends, and isolation of concerns. The
downside to this approach may come if you need to perform multiple
operations inside of a transaction. In that case, it makes sense to make
composite operations, or to allow it to be passed in via a context object or
additional function arguments.
This recipe will implement a very simple interface to working with items in
MongoDB. These items will have a name and price and we'll use an interface
to persist and retrieve these objects.
Getting ready
Refer to the steps given in theÂ Getting ready section of theÂ Using NoSQL
with MongoDB and mgo recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to the
chapter5/mongodb directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter5/mongodbÂ or use this as an exercise to
write some of your own...

Chapter 6. Web Clients and APIs
In this chapter we will cover the following recipes:
Initializing, storing, and passing http.Client structs
Writing a client for a REST API
Executing parallel and async client requests
Making use of OAuth2 clients
Implementing anÂ OAuth2 token storage interface
Wrapping a client in added functionality and function composition
UnderstandingÂ GRPC clients

Introduction
Working with APIs and writing web clients can be a tricky subject. Different
APIs have different types of authorization, authentication, and protocols.
We'll explore the http.Client struct object, working with OAuth2 clients
and long-term token storage, and finish off with GRPC with an additional
REST interface.
By the end of this chapter, you should have an idea of how to interface with
third-party or in-house APIs and have some patterns for common operations,
such as async requests to APIs.

Initializing, storing, and passing http.Client
structs
The Go net/http package exposes a flexible http.Client struct for working
with HTTP APIs. This struct has separate transport functionality and is
relatively simple to short-circuit requests, modify headers for each client
operation, and handle any REST operations. Creating clients is a very
common operation, and this recipe will start with the basics of working and
creating an http.Client object.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/installÂ and configure yourÂ GOPATH
environment variable.
2. Open aÂ terminal/console application.
3. Navigate toÂ GOPATH/srcÂ and create a project directory. For example,
$GOPATH/src/github.com/yourusername/customrepo.
Â  All code will be run and modified from this directory.
4. Optionally, install the latest tested version of the code using the go get
github.com/agtorre/go-cookbook/ command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create theÂ 

Writing a client for a REST API
Writing a client for a REST API will not only help you better understand the
API in question, but also gives you a useful tool for all future applications
using that API. This will explore structuring a client and show some
strategies that you can immediately take advantage of.
For this client, we'll assume that the authentication is handled by basic auth,
but it would also be possible to hit an endpoint to retrieve a token, and so on.
For the sake of simplicity, we'll assume our API exposes one
endpoint,Â GetGoogle(), which returns that status code returned from doing
a GET request to https://www.google.com.
Getting ready
Refer to the Getting ready section of the Initializing, storing, and passing
http.Client structsÂ recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter6/restÂ directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter6/restÂ or use this as an exercise to write
some of your own code.
3. Create a file calledÂ client.goÂ with the following...

Executing parallel and async client requests
Performing client requests in parallel is relatively simple in Go. In the
following recipe, we'll use a client to retrieve multiple URLs using Go
buffered channels. Responses and errors will both go to a separate channel
that is readily accessible by anyone with access to the client.
In the case of this recipe, creation of the client, reading the channels, and
handling of responses and errors will all be done in the main.go file.
Getting ready
Refer to the Getting ready section of theÂ Initializing, storing, and passing
http.Client structs recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create the chapter6/async
directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter6/asyncÂ or use this as an exercise to write
some of your own code.
3. Create a file calledÂ config.goÂ with the following content:
       package async
       import "net/http"
       // NewClient creates a new client and 
       // sets its appropriate channels
       func...

Making use of OAuth2 clients
OAuth2 is a relatively common protocol for speaking with APIs. The
golang.org/x/oauth2 package provides a pretty flexible client for working
with OAuth2. It has subpackages that specify endpoints forÂ various
providers such as Facebook, Google, and GitHub.
This recipe will demonstrate how to create a new GitHub OAuth2 client and
some of its basic usage.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Initializing, storing, and
passing http.Client structs recipe.
2. Run the go getÂ golang.org/x/oauth2Â command.
3. Configure an OAuth Client at
https://github.com/settings/applications/new.
4. Set the environment variables with your Client ID and Secret:
1. export GITHUB_CLIENT="your_client"
2. export GITHUB_SECRET="your_secret"
5. Brush up on the GitHub API documentation at
https://developer.github.com/v3/.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to the
chapter6/clientÂ directory.
2. Copy tests fromÂ 

ImplementingÂ an OAuth2 token storage
interface
In the previous recipe, we retrieved a token for our client and performed API
requests. The downside of this approach is that we have no long-term storage
for our token. In an HTTP server, for example, we'd like to have consistent
storage of the token between requests.
This recipe will explore modifying the OAuth2 client to store a token
between requests and retrieve them at will using a key. For the sake of
simplicity, this key will be a file, but it could also be a database, Redis, and
so on.
Getting ready
Refer to theÂ Getting readyÂ section of the Making use of OAuth2 clients
recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter6/clientÂ directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter6/oauthstoreÂ or use this as an exercise to
write some of your own code.
3. Create a file calledÂ config.goÂ with the following content:
       package oauthstore
       import (
           "context"
           "net/http"

          ...

Wrapping a client in added functionality
and function composition
In 2015, TomÃ¡s Senart gave an excellent talk on wrapping an http.Client
struct with an interface, allowing you to take advantage of middleware and
function composition. You can find out more on this at
https://github.com/gophercon/2015-talks. This recipe takes from his ideas and
demonstrates an example of doing the same to the Transport interface of the
http.Client struct similar to our earlier recipe,Â Writing a client for a REST
API.
This recipe will implement a logging and basic auth middleware for a
standard http.Client struct. It also includes a decorate function that can be
used when you need to with a large variety of middleware.
Getting ready
Refer to the Getting ready section of the Initializing, storing, and passing
http.Client structsÂ recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create the
chapter6/decorator directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter6/decoratorÂ or use this as an exercise to...

Understanding GRPC clients
GRPC is a high performance RPC framework that is built using protocol
buffers (https://developers.google.com/protocol-buffers) and HTTP/2
(https://http2.github.io). Creating a GRPC client in Go has a lot of the same
intricacies as working with Go HTTP clients. In order to demonstrate basic
client usage, it's easiest to also implement a server. This recipe will create a
greeter service, which takes a greeting and a name and returns the sentence
<greeting> <name>!. In addition, the server can specify whether to exclaim
!Â or not ..
This recipe won't explore some details about GRPC such as streaming, but
will hopefully serve as an introduction to creating a very basic server and
client.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Initializing, storing, and
passing http.Client structsÂ recipe in this chapter.
2. Install GRPC
atÂ https://github.com/grpc/grpc/blob/master/INSTALL.md.
3. Run theÂ go get github.com/golang/protobuf/proto command.
4. Run the go get github.com/golang/protobuf/protoc-gen-
goÂ command.
How to do it...
These steps cover writing...

Chapter 7. Microservices for Applications
in Go
In this chapter the following recipes will be covered:
Working withÂ web handlers, requests, and ResponseWriters
Using structs and closures for stateful handlers
Validating input for Go structs and user inputs
Rendering and content negotiation
Implementing and using middleware
Building a reverse proxy application
Exporting GRPC asÂ a JSON API

Introduction
Out of the box, Go is an excellent choice for writing web applications. The
built-in net/http packages combined with packages like html/template
allow for fully-featured modern web applications out of the box. It's so easy
that it encourages spinning up web interfaces for management of even basic
long-running applications. Although the standard library is fully featured,
there are still a large variety of third-party web packages for everything from
routes to full-stack frameworksÂ including these:
https://github.com/urfave/negroni
https://github.com/gin-gonic/gin
https://github.com/labstack/echo
http://www.gorillatoolkit.org/
https://github.com/julienschmidt/httprouter
The recipes in this chapter will focus on basic tasks you might run into when
working with handlers, when navigating response and request objects, and in
dealing with concepts such asÂ middleware.

Working with web handlers, requests, and
ResponseWriters
Go definesÂ HandlerFuncs and a Handler interface with the following
signatures:
// HandlerFunc implements the Handler interface
type HandlerFunc func(http.ResponseWriter, *http.Request)
type Handler interface {
   ServeHTTP(http.ResponseWriter, *http.Request)
}
By default, the net/http package makes extensive use of these types. For
example, a route can be attached to a Handler or HandlerFunc interface. This
recipe will explore creating a Handler interface, listening on a local port, and
performing some operations on an http.ResponseWriter interface after
processing http.Request. This should be considered the basis for Go web
applications and RESTFul APIs.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/install, and configure yourÂ GOPATH
environment variable.
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ and create a project directory, such
asÂ $GOPATH/src/github.com/yourusername/customrepo.
Â  All code will be run and modified from this...

Using structs and closures for stateful
handlers
Due to the sparse signatures of HTTP handler functions, it may seem tricky
to add state to a handler. For example, there are a variety of ways to include a
database connection.Â Two approaches to doing this are to pass in the state
via closures, which is useful for flexibility on a single handler, or by using a
struct.
This recipe will demonstrate both. We'll use a struct controller to store a
storage interface and create two routes with a single handler that are modified
by an outer function.
Getting ready
Refer to the steps given in theÂ Getting ready section of theÂ Working
withÂ web handlers, requests, and ResponseWritersÂ recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter7/rest directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter7/controllersÂ or use this as an exercise to
write some of your own.
3. Create a file calledÂ controller.goÂ with the following contents:
       package controllers
       // Controller passes state to...

Validating input for Go structs and user
inputs
Validation for web can be a difficult problem. This recipe will explore using
closures to support easy mocking of validation functions and to allow
flexibility in the type of validation performed when initializing a controller
struct as described by the previous recipe.Â 
We'll perform this validation on a struct, but not explore how to populate the
struct. We can assume that the data will be populated by parsing a JSON
payload, populating explicitly from the form input, or other methods.
Getting ready
Refer to the steps given in theÂ Getting ready section of the Working
withÂ web handlers, requests, and ResponseWriters recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to the
chapter7/validation directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter7/validationÂ or use this as an exercise to
write some of your own code.
3. Create a file calledÂ controller.goÂ with the following contents:
       package validation
       // Controller holds our validation...

Rendering and content negotiation
Web handlers can return a variety of content types, for example, they can
return JSON, plain text, images, and more. Frequently, when communicating
with APIs, it's possible to specify and accept content type to clarify what
format you'll pass data in as and what data you want to receive back out.Â 
This recipe will explore using unrolled/render and a custom function to
negotiate content type and respond accordingly.
Getting ready
Configure your environment according to these steps:
1. Refer to the steps in theÂ Getting ready section ofÂ the Working with
web handlers, requests, and ResponseWriters recipe.
2. Run theÂ go getÂ github.com/unrolled/render command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter7/negotiate directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter7/negotiateÂ or use this as an exercise to
write some of your own code.
3. Create a file calledÂ negotiate.goÂ with the following contents:
       package negotiate
       import (
          ...

Implementing and using middleware
Middleware for handlers in Go is an area that has been widely explored.
There are a variety of packages for handling middleware. This recipe will
create middleware from scratch and implement an ApplyMiddleware function
to chain together a bunch of middleware.
It will also explore setting values in the request context object and retrieving
them later using middleware. This will all be done with a very basic handler
to help demonstrate how to decouple middleware logic from your handlers.
Getting ready
Refer to the steps given in theÂ Getting ready section of the Working with
web handlers, requests, and ResponseWriters recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter7/middleware directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter7/middlewareÂ or use this as an exercise
to write some of your own.
3. Create a file calledÂ middleware.goÂ with the following contents:
       package middleware
       import (
           "log"
           "net/http"
        ...

Building a reverse proxy application
In this recipe, we will develop a reverse proxy application. The idea is, by
hitting http://localhost:3333 in a browser, all traffic will be forwarded to
a configurable host and the responses will be forwarded to your browser. The
end result should be https://www.golang.orgÂ rendered in a browser through
our proxy application.
This can be combined with port forwarding and ssh tunnels in order to
securely hit websites through an intermediate server. This recipe will build a
reverse proxy from the ground up, but this functionality is also provided by
theÂ net/http/httputil package. Using this package, the incoming request
can be modified byÂ Director func(*http.Request) and the outgoing
response can be modified byÂ ModifyResponse func(*http.Response)
error. In addition, there's support for buffering the response.
Getting ready
Refer to the steps given in theÂ Getting ready section ofÂ the Working with
web handlers, requests, and ResponseWriters recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to...

Exporting GRPC asÂ a JSON API
In the Understanding GRPC clients recipe from Chapter 6, Web Clients and
APIs, we wrote a basic GRPC server and client. This recipe will expand on
that idea by putting common RPC functions in a package and wrapping them
in both a GRPC server and a standard web handler. This can be useful when
your API wants to support both types of client, but you don't want to replicate
code for common functionality.
Getting ready
Configure your environment according to these steps:
1. Refer to the steps given in theÂ Getting ready section of the Working
with web handlers, requests, and ResponseWriters recipe.
2. Install GRPC from
https://github.com/grpc/grpc/blob/master/INSTALL.md.
3. Run theÂ go get github.com/golang/protobuf/proto command.
4. Run theÂ go get github.com/golang/protobuf/protoc-gen-go
command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter7/grpcjson directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter7/grpcjsonÂ or use this as an exercise to
write some of your own...

Chapter 8. Testing
In this chapter, we will cover the following recipes:
Mocking using the standard library
Using the Mockgen package
Using table-driven tests to improve coverage
Using third-party testing tools
Practical fuzzing
Behavior testing using Go

Introduction
This chapter will be different from the previous chapters; this will focus on
testing and testing methodologies. Go provides excellent testing support out
of the box, however, it can be difficult to understand coming from more
dynamic languages where monkey patching and mocking are relatively
straightforward.Â 
Go testing encourages a specific structure for your code, in particular, testing
and mocking interfaces is very straightforward and well supported. Some
types of code can be more difficult to test. For example, it can be difficult to
test code that makes use of package-level global variables, places that have
not been abstracted into interfaces, and structs that have non-exported
variables or methods. This chapter will share some recipesÂ forÂ testing Go
code.

Mocking using the standard library
In Go, mocking typically means implementing an interface with a test version
that allows you to control runtime behavior from tests. It may also refer to
mocking functions and methods, for which we'll explore another trick in this
recipe. This trick uses the Patch and Restore functions defined at
https://play.golang.org/p/oLF1XnRX3C.
In general, it's better to compose code so that you can use interfaces
frequently and the code is in small testable chunks. Code that contains lots of
branching conditions or deeply nested logic can be tricky to test and tests
tend to be more brittle at the end. This is because a developer will need to
keep track of more mock objects, patches, return values, and states within
their tests.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/installÂ  and configure yourÂ GOPATH
environment variable.
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ and create a project directory, for
example,Â $GOPATH/src/github.com/yourusername/customrepo.
Â  All...

Using the Mockgen package
The previous example used our custom mock objects. When you're working
with a lot of interfaces, writing these can become cumbersome and error
prone. This is a place where generating code makes a lot of sense.
Fortunately, there's a package calledÂ github.com/golang/mock/gomock that
provides a generation of mock objects and gives us a very useful library to
use in conjunction with interface testing.
This recipe will explore some of the functionality of gomock and will cover
trade-offs on where, when, and how to work with and generate mock objects.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section ofÂ theMocking using the standard
library recipe of this chapter.
2. Run the go getÂ github.com/golang/mock/Â command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter8/mockgenÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter8/mockgenÂ or use this as an exercise to
write some of your own.
3. Create a file calledÂ 

Using table-driven tests to improve
coverage
This recipe will demonstrate the process to write a table-driven test, collect
test coverage, and improve it. It will also make use of the
github.com/cweill/gotests packageÂ to generate tests. If you've been
downloading the test code for other chapters, these should look very familiar.
Using a combination of this recipe and the previous two, you should be able
to achieve 100% test coverage in all cases with some work.Â 
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section ofÂ the Mocking using the standard
library recipe of this chapter.
2. Run the go get github.com/cweill/gotests/Â command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter8/coverageÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter8/coverageÂ or use this as an exercise to
write some of your own code.
3. Create a file calledÂ coverage.goÂ with the following content:
       package main
       import "errors"
       //...

Using third-party testing tools
There are a number of helpful tools for Go testing. Tools that make it easier
to get an idea of code coverage at a per-function level, tools to do assertions
to reduce testing lines of code, and test runners. This recipe will cover
github.com/axw/gocov and
github.com/smartystreets/goconveyÂ packages to demonstrate some of
this functionality. There are a number of other notable test frameworks
depending on your needs. TheÂ github.com/smartystreets/goconvey
package supports both assertions and is a test runner. It used to be the
cleanest wayÂ to have labeled subtests prior toÂ Go 1.7.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section ofÂ the Mocking using the standard
library Â recipe of this chapter.
2. Run the go get github.com/axw/gocovÂ command.
3. Run the go getÂ github.com/smartystreets/goconvey/Â command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter8/toolsÂ directory and navigate to it.
2. Copy tests fromÂ 

Practical fuzzing
This recipe will explore fuzzing and how it can be used to help validate
functions. In theÂ Currency conversions and float64 considerations recipe
from Chapter 3, Data Conversion and Composition, we created a function
that takes decimal US currency as a string and returns an int64 version
representing cents. We'll modify that function and demonstrate finding a
panic with fuzzing.Â 
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section ofÂ the Mocking using the standard
library recipe of this chapter.
2. Run the go get github.com/dvyukov/go-fuzz/go-fuzzÂ command.
3. Run the go get github.com/dvyukov/go-fuzz/go-fuzz-
buildÂ command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter8/fuzzÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter8/fuzzÂ or use this as an exercise to write
some of your own code.
3. Create a file calledÂ dollars.goÂ with the following content:
       package fuzz
       import (
          ...

Behavior testing using Go
Behavior testing or integration testing is a good method of performing end-
to-end black box testing. One popular framework for this type of testing is
cucumber (https://cucumber.io/), which uses the Gherkin language to
describe the steps to a test in English and then implement those steps in code.
Go has a cucumber library as well (github.com/DATA-DOG/godog).Â This
recipe will explore using godog package to write behavior tests.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section ofÂ the Mocking using the standard
library recipe of this chapter.
2. Run the go getÂ github.com/DATA-DOG/godogÂ command.
3. Run the go get github.com/DATA-DOG/godog/cmd/godogÂ command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter8/bddÂ directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter8/bddÂ or use this as an exercise to write
some of your own code.
3. Create a file calledÂ handler.goÂ with the following content:
       package bdd
...

Chapter 9. Parallelism and Concurrency
In this chapter, the following recipes will be covered:
Using channels and the selectÂ statement
Performing async operations withÂ sync.WaitGroup
Using atomic operations and mutex
UsingÂ the context package
Executing state management for channels
Using the worker pool design pattern
Using workers to create pipelines

Introduction
This chapter covers worker pools, wait groups for async operations, and the
use of the context package. Parallelism and concurrency are someÂ of the
most advertised and promoted features of the Go language. This chapter
willÂ offer a number of useful patterns to get you started and help you
understand these features.
Go provides primitives that make parallel applications possible. Goroutines
allow any function to become asynchronous and concurrent. Channels allow
an application to set up communication with goroutines. One of the famous
sayings in Go is Do not communicate by sharing memory; instead, share
memory by communicatingÂ fromÂ https://blog.golang.org/share-memory-
by-communicating.

Using channels and the selectÂ statement
Go channels, in combination with goroutines, are first-class citizens for
asynchronous communication. Channels become especially powerful when
using selectÂ statements. These statements allow a goroutineÂ to
intelligently handle requests from multiple channels at once.Â 
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system from
https://golang.org/doc/install and configure yourÂ GOPATH environment
variable.
2. Open aÂ terminal/console application.
3. Navigate toÂ GOPATH/srcÂ and create a project directory, such
asÂ $GOPATH/src/github.com/yourusername/customrepo.
Â  All code will be run and modified from this directory.
4. Optionally, install the latest tested version of the code using theÂ go
get github.com/agtorre/go-cookbook/ command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter9/channels directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter9/channelsÂ or use this as an exercise...

Performing async operations
withÂ sync.WaitGroup
Sometimes, it is useful to perform a number of operations asynchronously,
then wait till they complete before moving on. For example, if an operation
requires pulling information from multiple APIs and aggregate that
information, it can be helpful to make those client requests asynchronously.
This chapter will explore using sync.WaitGroup to orchestrate non-
dependent tasks in parallel.
Getting ready
Refer to the Getting ready section of the Using channels and the select
statement recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter9/waitgroupÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter9/waitgroupÂ orÂ use this as an exercise
to write some of your own code.
3. Create a file calledÂ tasks.goÂ with the following content:
       package waitgroup
       import (
           "fmt"
           "log"
           "net/http"
           "strings"
           "time"

       )
       // GetURL gets a url, and logs...

Using atomic operations and mutex
In a language like Go, where you have build in asynchronous operations and
parallelism, it becomes important to consider things such as thread safety. For
example, it is dangerous to access a map from multiple goroutines
simultaneously. Go provides a number of helpers in the sync and
sync/atomic packages to make sure that certain events occur only once or
that goroutines can serialize on an operation.Â  This recipe will demonstrate
the use of these packages to safely modify a map with various goroutines and
to keep a global ordinal value that can be safely accessed by numerous
goroutines. It will also showcase the Once.Do method, which can be used to
ensure that something is only done by a Go application once, such as reading
a config or initializing a variable.
Getting ready
Refer to the Getting ready section of the Using channels and the select
statement recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter9/atomicÂ directory and navigate to it.
2. Copy tests fromÂ 

Using the context package
Several recipes throughout this book make use of the context package. This
recipe will explore the basics of creating and managing contexts. A good
reference for understanding context isÂ https://blog.golang.org/context. Since
this blog post was written, context moved from net/context to a package
called context. This still occasionally causes problems when interacting with
third-party libraries such as GRPC. This recipe will explore setting and
getting values for contexts, cancelation, and timeouts.
Getting ready
Refer to the Getting ready section of the Using channels and the select
statement recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter9/contextÂ directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter9/contextÂ orÂ use this as an exercise to
write some of your own code.
3. Create a file calledÂ values.goÂ with the following content:
       package context
       import "context"
       type key string
       const (
          ...

Executing state management for channels
Channels can be any type in Go. A channel of structs allows you to pass a lot
of stateÂ with a single message. This recipe will exploreÂ using of
channelsÂ to pass around complex request structs and return their results in
complex response structs. In the next recipe,Â Using the worker pool design
pattern, the value of this becomes even more apparent as you can create
general purpose workers capable of performing a variety of tasks.
Getting ready
Refer to the Getting ready section of the Using channels and the select
statement recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter9/state directory.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter9/state orÂ use this as an exercise to write
some of your own code.
3. Create a file calledÂ state.goÂ with the following content:
       package state
       type op string
       const (
           // Add values
           Add op = "add"
           // Subtract values
           Subtract...

Using the worker pool design pattern
The worker pool design pattern is one where you dispatch long-running
goroutines as workers. These workers can process a variety of work either
using multiple channels or by using a stateful request struct that specifies the
type as described in the preceding recipe. This recipe will create stateful
workers and demonstrate how to coordinate and spin up multiple workers all
handling requests concurrently on the same channel. These workers will be
crypto workers like in a web authentication app. Their purpose will be to
hashÂ plain text strings using bcrypt package and compare a text password
against a hash.Â 
Getting ready
Refer to the Getting ready section of the Using channels and the select
statement recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create theÂ chapter9/pool
directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter9/poolÂ orÂ use this as an exercise to
write some of your own code.
3. Create a file calledÂ worker.goÂ with the following...

Using workers to create pipelinesÂ 
This recipe demonstratesÂ creating groups of worker pools and connecting
them together to form a pipeline. For this recipe, we link together two pools,
but the pattern can be used for much more complex operations similar to
middleware.Â  Worker pools can be useful to keep workers relatively simple
and to also further control concurrency. For example, it may be useful to
serialize logging while parallelizing other operations. This may also be useful
to have a smaller pool for more expensive operations, so you don't overload
machine resources.
Getting ready
Refer to the Getting ready section of the Using channels and the select
statement recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter9/pipelineÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter9/pipeline orÂ use this as an exercise to
write some of your own code.
3. Create a file calledÂ worker.goÂ with the following content:
       package pipeline
       import...

Chapter 10. Distributed Systems
In this chapter, we will cover the following recipes:
Using service discoveryÂ with Consul
Implementing basic consensus using Raft
Using containerization with Docker
Orchestration and deployment strategies
Monitoring applications
Collecting metrics

Introduction
Sometimes, application-level parallelism is not enough, and things that seem
simple in development can become complex during deployment. Distributed
systems provide a number of challenges not found when developing on a
single machine. These applications have added complexity for things such as
monitoring, writing applications that require strong consistency guarantees,
and service discovery. In addition, you must always be mindful of single
points of failure, such as a database. Otherwise your distributed applications
canÂ fail when this single component fails.
This chapter will explore methods of managing distributed data,
orchestration, containerization, metrics, and monitoring.Â These will become
part of your toolbox for writing and maintaining microservices and large
distributed applications.

Using service discovery with Consul
When using the microservice approach to applications, you end up with a lot
of servers listening on a variety of IPs, domains, and ports. These IP
addresses will vary by environment (staging versus production), and it can be
tricky to keep them static for configuration between services. You also want
to know when a machine or service is down or unreachable due to a network
partition. Consul is a tool that provides a lot of functionality, but we'll explore
registering services with Consul and querying them from our other services.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/install andÂ ï»¿configure yourÂ GOPATH
environment variable.
2. Open aÂ terminal/console application.
3. Navigate toÂ GOPATH/srcÂ and create a project directory, for
example,Â $GOPATH/src/github.com/yourusername/customrepo. All
code will be run and modified from this directory.
4. Optionally, install the latest tested version of the code by running the go
get github.com/agtorre/go-cookbook/Â command.
5. Install Consul fromÂ 

Implementing basic consensus using Raft
Raft is a consensus algorithm that allows distributed systems to keep a shared
and managed state (https://raft.github.io/). Setting up a Raft system is
complex in many ways, for one you need consensus for an election to occur
and succeed. This can be difficult to bootstrap when working with multiple
nodes and it can be difficult to get started. A basic cluster can be run on a
single node/leader, but if you want redundancy, at least three nodesÂ allows
for a single node failure. This recipe implements a basic in-memory Raft
cluster, constructs a state machine that can transition between certain allowed
states, and connects the distributed state machine to a web handler that can
trigger the transition. This can be useful when you're implementing the base
finite state machine interface that Raft requires or when testing. This recipe
usesÂ https://github.com/hashicorp/raftÂ for the base Raft implementation.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Using service discoveryÂ with
Consul recipe in this chapter.
2. Run the go get...

Using containerization with Docker
Docker is a container technology for packaging and shipping applications.
Other advantages include portability, a container will run the same way
regardless of theÂ host OS. It provides a lot of the advantages of a virtual
machine, in a more light-weight container. It's possible to limit resources
consumption of individual containers and sandbox your environment. It can
be extremely useful for having a common environment for your applications
locally and when you ship your code to production. Docker is written in Go
and is open source, so it's simple to take advantage of the client and libraries.
This recipe will set up a Docker container for a basic Go application, store
some version information about the container, and demonstrate hitting a
handler from a Docker endpoint.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section ofÂ theÂ Using service discovery for
Consul recipe of this chapter.
2. Install Docker from https://store.docker.com/search?
type=edition&offering=community. This will also include Docker
compose.
How to do it...
These steps cover...

Orchestration and deployment strategies
Docker makes orchestration and deployment much more simple. In this
recipe, we'll set up a connection to MongoDB, inserting a document and
querying it all from Docker containers. This recipe will set up the same
environment as the Using NoSQL with MongoDB and mgo recipe,Â in
Chapter 5, All about Databases and Storage, but will run the
applicationÂ and environment inside ofÂ containersÂ andÂ will use Docker
compose to orchestrate and connect them.Â This can later be used in
conjunction with Docker Swarm, an integrated Docker tool that allows you to
manage a cluster, to create and deploy nodes that can be scaled up or down
easily, and to manage load balancing
(https://docs.docker.com/engine/swarm/). Another good example of container
orchestration is Kubernetes (https://kubernetes.io/), a container orchestration
framework written by Google using the Go programming language.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of theÂ Using containerization with
Docker recipe.
2. Run the go get gopkg.in/mgo.v2Â command.
3. Run the go get...

Monitoring applications
There are a variety of ways toÂ monitor Go applications. One of the easiest
ways is to set up Prometheus, a monitoring application written in Go
(https://prometheus.io). This is an application that polls an endpoint based on
your configuration file and collects a lot of information about your app,
including the number of goroutines, memory usage, and much more. This app
will use the techniques from the previous recipe to set up a Docker
environment to host Prometheus and connect to it.Â 
Getting ready
Configure your environment according to these steps:
1. Refer toÂ the Getting ready sectionÂ ofÂ the Using containerization
with DockerÂ recipe.
2. Run theÂ go
getÂ github.com/prometheus/client_golang/prometheus/promhttp
command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create the
chapter10/monitoringÂ directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter10/monitoringÂ or use this as an exercise
to write some of your own code.
3. Create a file called DockerfileÂ with the...

Collecting metrics
In addition to general information about your app, it can be helpful to emit
metrics that are app specific. For example, we might want to collect timing
data or keep track of the number of times an event occurs.Â 
This recipe will use theÂ github.com/rcrowley/go-metrics package to
collect metricsÂ and expose them via an endpoint. There are various exporter
tools to export metrics to places such as Prometheus and InfluxDB, also
written in Go.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Using service discoveryÂ with
Consul recipe in this chapter.
2. Run the go getÂ github.com/rcrowley/go-metricsÂ command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter10/metricsÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter10/metrics, or use this as an exercise to
write some of your own code.
3. Create a file called handler.goÂ with the following content:
       package metrics
       import (

          ...

Chapter 11. Reactive Programming and
Data Streams
In this chapter, we will cover the following recipes:
Goflow for dataflow programming
Reactive programming withÂ RxGo
Using Kafka with Sarama
Using async producers with Kafka
Connecting Kafka to Goflow
Writing a GraphQL server in Go

Introduction
This chapter will discuss reactive programming design patterns in Go.
Reactive programming is a programming concept that focuses on data
streams and the propagation of change
(https://en.wikipedia.org/wiki/Reactive_programming). Technologies such as
Kafka allow you to quickly produce or consume a stream of data. As a result,
these technologies are a natural fit for one another. In theÂ Connecting Kafka
to GoflowÂ recipe, we'll explore combining a kafka message queue with
goflow to show a practical example of using these technologies. This chapter
will also explore various ways to connect with Kafka and use it to process
messages. Lastly, this chapter will demonstrate how to createÂ a basic
graphql server in Go.Â 

Goflow for dataflow programming
TheÂ github.com/trustmaster/goflow package is useful for creating
dataflow-based applications. It tries to abstract concepts so that you can write
components and connect them together using a custom network. This recipe
will recreate the application discussed in Chapter 8,Â Testing, but it will do
so using the goflow package.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/install and configure
yourÂ GOPATHÂ environment variable.
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ and create a project directory, for
example,Â $GOPATH/src/github.com/yourusername/customrepo. All
code will be run and modified from this directory.
4. Optionally, install the latest tested version of the code using theÂ go
get github.com/agtorre/go-cookbook/ command.
5. Run the go get github.com/trustmaster/goflow command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter11/goflowÂ directory and navigate to it.Â 
2. Copy...

Reactive programming withÂ RxGo
ReactiveX (http://reactivex.io/) is an API for programming with observable
streams. RxGo (github.com/reactivex/rxgo) is a library to support this pattern
in Go. It helps you to think of your application as a big stream of events that
responds in different ways when those events occur. This recipe will create
an application that uses this approach to process different wines. Ideally, this
approach can be tied to wine data or wine APIs and can aggregate
information about wine.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Goflow for dataflow
programming recipe in this chapter.
2. Run theÂ go getÂ github.com/reactivex/rxgo command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter11/reactiveÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter11/reactiveÂ or use this as an exercise to
write some of your own.
3. Create a file calledÂ wine.goÂ with the following content:
       package reactive
  ...

Using Kafka with Sarama
Kafka is a popular distributed message queue with a lot of advanced
functions for building distributed systems. This recipe will show how to write
to a Kafka topic using a synchronous producer and how to consume the same
topicÂ using a partition consumer. This recipe will not explore different
configurations ofÂ Kafka as that is a much wider topic, but I suggest
beginning atÂ https://kafka.apache.org/intro.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Goflow for dataflow
programming recipe in this chapter.
2. Install Kafka using the steps mentioned at
https://www.tutorialspoint.com/apache_kafka/apache_kafka_installation_
3. Alternatively, you can also access https://github.com/spotify/docker-
kafka.
4. Run theÂ go get gopkg.in/Shopify/sarama.v1Â command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter11/synckafkaÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter11/synckafkaÂ or use this as...

Using async producers with Kafka
It's often useful to not wait for a Kafka producer to complete before moving
on to the next task. In cases like this, you can use an async producer. These
producers take Sarama messages on a channel and have methods to return a
success/error channel that can be checked separately.Â 
In this recipe, we'll create a go routine that will handle success and failure
messages while we allow a handler to queue messages to send regardless of
the result.
Getting ready
Refer to the Getting ready section ofÂ theÂ Using Kafka with
SaramaÂ recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter11/asyncsaramaÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter11/asyncsaramaÂ or use this as an exercise
to write some of your own.
3. Ensure that Kafka is up and running on localhost:9092.
4. Copy the consumer directory from the previous recipe.
5. Create a directory named producer and navigate to it.
6. Create a file called producer.go:
       package main
       import (
     ...

Connecting Kafka to Goflow
This recipe will combine a Kafka consumer with a Goflow pipeline. As our
consumer receives messages from Kafka, it will run strings.ToUpper() on
them and then print the results. These naturally pair as Goflow is designed to
operate on an incoming stream, which is exactly what Kafka provides us.
Getting ready
Refer to the Getting ready section ofÂ theÂ Using Kafka with Sarama recipe.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter11/kafkaflowÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter11/kafkaflowÂ or use this as an exercise to
write some of your own.
3. Ensure that Kafka is up and running on localhost:9092.
4. Create a file called components.go with the following content:
       package kafkaflow
       import (
           "fmt"
           "strings"
           flow "github.com/trustmaster/goflow"
       )
       // Upper upper cases the incoming
       // stream
       type Upper struct {
           flow.Component

           Val <-chan...

Writing a GraphQL server in Go
GraphQL is an alternative to REST, created by Facebook
(http://graphql.org/). This technology allows a server to implement and
publish a schema and the clients then can ask for the information they need
rather than understanding and making use of various API endpoints.Â 
For this recipe, we'll create a Graphql schema that represents a deck of
playing cards. We'll expose one resource card, which can be filtered by suit
and value. Alternatively, it can return all the cards in the deck if no arguments
are specified.
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Goflow for dataflow
programming recipe in this chapter.
2. Run theÂ go getÂ github.com/graphql-go/graphqlÂ command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter11/graphqlÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter11/graphqlÂ or use this as an exercise to
write some of your own.
3. Create and navigate to theÂ 

Chapter 12. Serverless Programming
In this chapter, we will cover the following recipes:
Go programming on Lambda with Apex
Apex serverless logging and metrics
Google App Engine with Go
Working with Firebase using zabawaba99/firego

Introduction
This chapter will focus on serverless architectures and using them with the
Go language. It will also explore app engine and Firebase, two services to
quickly deploy applications and data storage to the web.Â 
All of the recipes in this chapter deal with third-party services that bill for
use; ensure that you clean up when you're done using them. Otherwise, think
of these recipes as kick-starters for spinning up larger applications on these
platforms.

Go programming on Lambda with Apex
Apex is a tool for building, deploying, and managing AWS Lambda
functions. It provides wrappers for Go (using a Node.js shim). Currently,
there is not a way to run native Go code on Lambda without such a shim.
This recipe will explore creating Go Lambda functions and deploying them
with Apex.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
(https://golang.org/doc/install) and configure
yourÂ GOPATHÂ environment variable.
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ directoryÂ and create a project
directory, for
example,Â $GOPATH/src/github.com/yourusername/customrepo. All
code will be run and modified from this directory.
4. Optionally, install the latest tested version of the code using thego get
github.com/agtorre/go-cookbook/...Â command.
5. Install Apex from http://apex.run/.
6. Run theÂ go getÂ github.com/apex/go-apex command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter12/lambdaÂ directoryÂ and navigate to...

Apex serverless logging and metrics
When working with serverless functions such as Lambda, it is valuable to
have portable, structured logs. In addition, you can combine earlier recipes
dealing with logging to this recipe. The recipes covered in Chapter 4,Â Error
Handling in Go, are just as relevant. Because we're using Apex to handle our
lambda functions, we chose to use the Apex logger for this recipe. We'll also
rely on metrics provided by Apex as well as the AWSÂ console. The earlier
recipes explored more complex logging and metrics examples, and those still
apply--the Apex logger can easily be configured to aggregate logs using
something like Amazon Kinesis or Elasticsearch.Â 
Getting ready
Configure your environment according to these steps:
1. Refer to the Getting ready section of the Go programming on Lambda
with Apex recipe in this chapter.
2. Run theÂ go getÂ github.com/apex/logÂ command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter12/loggingÂ directoryÂ and navigate to it.
2. Create an Amazon accountÂ and an IAM role that can...

Google App Engine with Go
App Engine is a Google service that facilitates the quick deployment of web
applications.Â These applications have access to cloud storage and various
other Google APIs. The general idea is that App Engine will scale easily with
load and simplify any operations management associated with hosting an app.
This recipe will show how to create and optionally deploy a basic App
Engine application. This recipe won't get into the details of setting up a
Google cloud account, setting up billing, or the specifics on cleaning up your
instance. At a minimum, access to Google Cloud Datastore
(https://cloud.google.com/datastore/docs/concepts/overview) is required for
this recipe to work.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system from
https://golang.org/doc/installÂ and configure yourÂ GOPATH
environment variable.
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ and create a project directory, for
example,Â $GOPATH/src/github.com/yourusername/customrepo. All
code will be run and modified from this directory.
4. Optionally,...

Working with Firebase using
zabawaba99/firego
Firebase is another Google cloud service that creates a scalable, easy-to-
manage database that can support authentication and works especially well
with mobile applications. The service provides significantly more than what
will be covered in this recipe, but we will look at storing data, reading it,
modifying it, and restoring it. We'll also look into how to set up
authentication for your application and wrap the Firebase client with our own
custom client.
Getting ready
Configure your environment according to these steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/installandÂ and configure
yourÂ GOPATHÂ environment variable.
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ and create a project directory, for
example,Â $GOPATH/src/github.com/yourusername/customrepo. All
code will be run and modified from this directory.
4. Optionally, install the latest tested version of the code using theÂ go
get github.com/agtorre/go-cookbook/...Â command.
5. Create an account and database atÂ 

Chapter 13. Performance Improvements,
Tips, and Tricks
In this chapter, we will cover the following recipes:
Speeding up compilation and testing cycles
Using the pprof tool
Benchmarking and finding bottlenecks
Memory allocationÂ and heap management
Vendoring and project layout
Using fasthttprouter and fasthttp

Introduction
This chapter will focus on optimizing an application, discovering bottlenecks,
and vendoring dependencies. These are some tips and tricks that can be used
immediately by existing applications. Many of these recipes are necessary if
you or your organization require fully reproducible builds. They're also useful
when you want to benchmark an applications' performance. The final recipe
focuses on increasing the speed of HTTP, however, it's always important to
remember that the web world moves quickly, and it's important to refresh
yourself on best practices. For example, if you require HTTP/2, it is now
available using the built-in Go net/http package since version 1.6.

Speeding up compilation and testing cycles
There are a few reasons why an application might be slow to compile, and by
extension, run tests against. Usually, this is a combination requiring the
application to compile from scratch every time (no intermediate builds), large
code bases, and many dependencies. This recipe will explore some tools that
can be used to look at the current dependency lists and to speed up
compilation.
Getting ready
Configure your environment by performing the following steps:
1. Download and install Go on your operating system
fromÂ https://golang.org/doc/installÂ and configure
yourÂ GOPATHÂ environment variable.Â 
2. Open aÂ terminal/console application.
3. Navigate to yourÂ GOPATH/srcÂ directoryÂ and create a project
directory, for
example,Â $GOPATH/src/github.com/yourusername/customrepo.
Â  All code will be run and modified from this directory.
4. Optionally, install the latest tested version of the code using theÂ go
get github.com/agtorre/go-cookbook/Â command.
How to do it...
These steps cover writing and running your application:
1. To demonstrate how go build performance can degrade, either...

Using the pprof tool
The pprof tools allows Go applications to collect and export runtime profiling
data. It also provides web hooks to access the tool from a web interface. This
recipe will create a basic application that verifies a bcrypt hashed password
against a plaintext one, then it will profile the application.Â 
You might expect the pprof tool to be in the Chapter 10, Distributed
Systems,with other metrics and monitoring recipes. It was instead put in this
chapter because it will be used to analyze and improve a program much in the
same way benchmarking can be used. As a result, this recipe will largely
focus on pprof for analyzing and improving the memory usage of an
application.
Getting ready
Configure your environment by performing these steps:
1. Refer to the Getting ready section of the Speeding up compilation and
testing cycles recipe in this chapter.
2. Optionally, install Graphviz from http://www.graphviz.org/Home.php.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create and navigate to
theÂ chapter13/pprofÂ directory.
2. Copy tests fromÂ 

Benchmarking and finding bottlenecks
Another method for determining slow parts of code is to use benchmarks.
Benchmarks can be used to test functionsÂ for average performance and can
also run benchmarks in parallel. This can be useful when comparing
functions or doing micro-optimizations for certain code, especially to see
how a function implementation might perform when using it concurrently.
For this recipe, we'll create two structs that both implement an atomic
counter. The first will use the sync package, and the other will use
sync/atomic.Â We'll then benchmark both the solutions.
Getting ready
Refer to the Getting ready section of the Speeding up compilation and testing
cycles recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter13/benchÂ directoryÂ and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter13/benchÂ orÂ use this as an exercise to
write some of your own code.
Note
Note that copied tests also include benchmarks written later in
this recipe.
3. Create a...

Memory allocation and heap management
Some applications can benefit a lot from optimization. Consider routers, for
example, which we'll look at in a later recipe. Fortunately, the tool
benchmark suite provides flags to collect a number of memory allocations as
well as memory allocation size. It can be helpful to tune certain critical code
paths to minimize these two attributes.Â 
This recipe will show two approaches to writing a function that glues
together strings with a space, similar to strings.Join("a", "b", "c"). One
approach will use concatenation, while the other will use the strings
package. We'll then compare performance and memory allocations between
the two.
Getting ready
Refer to the Getting ready section of the Speeding up compilation and testing
cycles recipe in this chapter.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/console application, create
theÂ chapter13/tuningÂ directory and navigate to it.
2. Copy tests fromÂ https://github.com/agtorre/go-
cookbook/tree/master/chapter13/tuningÂ  or use this as an exercise to
write some of your own code.
Note
Note that copied...

Vendoring and project layout
VendoringÂ Go applications is still a largely unresolved issue. There are
discussions and plans to produce an official vendoring solution
(https://github.com/golang/dep), but it's very early days and things are far
from complete. For now, there are a number of alternative solutions. By
default, you can place packages into a local vendor directory to use them
instead of those in your GOPATH environment variable. This allows packages
to pin on the version in their vendor directory and allows for reproducible
builds without having to commit your entire GOPATH into version control.
Most package managers take advantage of this. For this recipe, we'll explore
the layout for a web application and how to manage its vendor dependencies
with godepgithub.com/tools/godep, a popular tool for managing
dependencies.
Getting ready
Configure your environment by performingÂ these steps:
1. Refer to the Getting ready section of the Speeding up compilation and
testing cycles recipe in this chapter.
2. Run theÂ go get github.com/tools/godep command.
3. Run the go get github.com/sirupsen/logrusÂ command.
How to do it...
These...

Using fasthttprouterÂ and fasthttp
Although the Go standard library provides everything you would need to run
an HTTPÂ server, sometimes you need to further optimize for things such
asÂ routing and request time. This recipe will explore a library that speeds up
requestÂ handling called fasthttp (https://github.com/valyala/fasthttp) and a
router, that dramatically speeds up routing performance called
fasthttprouter (https://github.com/buaazp/fasthttprouter). Although
fasthttp is quick, it's important to note that it doesn't support HTTP/2
(https://github.com/valyala/fasthttp/issues/45).
Getting ready
Configure your environment by performing these steps:
1. Refer to the Getting ready section of the Speeding up compilation and
testing cycles recipe in this chapter.
2. Run the go get github.com/buaazp/fasthttprouterÂ command.
3. Run theÂ go getÂ github.com/valyala/fasthttp command.
How to do it...
These steps cover writing and running your application:
1. From yourÂ terminal/consoleÂ application, create
theÂ chapter13/fastwebÂ directory and navigate to it.
2. Copy tests fromÂ 

