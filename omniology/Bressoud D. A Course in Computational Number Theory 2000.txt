
H Course in Computational Number Theorq 


R Course in 
Computational 
Number Theor4 
David Bressoud 
Macalester College 
Stan Wagon 
Macalester College 
@ 
WILEY 

David Bressoud 
Macalester College 
St. Paul, MN 55105 
bressoud@macalester.edu 
Stan Wagon 
Macalester College 
St. Paul, MN 55105 
wagon@macalester.edu 
About the Cover: The disk on the cover shows the prime numbers in the Gaussian integers 
(m + n N, where m and .n are integers), colored according to their reachability from the one 
closest to the origin. The yellow primes are reachable using steps of size at most ..f2; the blue 
primes are reachable using steps of size at most 2; and the red primes are the network based 
on size ../8. The background is a close-up of the first quadrant. A famous unsolved problem 
(see Section 9.2) asks whether such a reachability set can ever be infinite. 
Published by John Wiley & Sons, Hoboken, NJ 
No part of this publication may be reproduced, stored in a retrieval system, or transmitted in any form or by 
any means, electronic, mechanical, photocopying, recording, scanning, or otherwise, except as permitted 
under section I 07 or I 08 of the 1976 United States Copyright Act, without either the prior written permis­
sion of the Publisher, or authorization through payment of the appropriate per-copy fee to the Copyright 
Clearance Center, Inc., 222 Rosewood Drive, Danvers, MA 01923, 978-750-8400, fax 978-750-44 70, or on 
the web at www.copyright.com. Requests to the Publisher for permission should be addressed to the 
Permissions Department, John Wiley & Sons, Inc., 111 River Street, Hoboken, NJ 07030, 201-748-6011, 
fax 201-748-6008, email: permcoordinator@wiley.com. 
For general information on our other products and services, please contact our Customer Care Department 
within the United States at 800-762-2974, outside the United States at 317-572-3993 or fax 317-572-4002. 
For more information about Wiley products, visit our website at www.wiley.com. 
Library of Congress Catalogmg-m-Publication Data 
Bressoud, David M., 1950-
A course in computational number theory I David Bressoud, Stan 
Wagon. 
p. 
cm. 
Includes bibliographical references and index. 
ISBN 978-0-470-41215-2 
1. Number theory. 2. Algorithms. 
I. Wagon, S. II. Title. 
QA241.B788 1999 
512'.7-dc21 
99-16037 
copyright 2000 
Mathematica is a registered trademark of Wolfram Research, Inc. 

Pref ace 
This book is a successor to Factorization and Primality Testing (Bressoud, 
Springer-Verlag, 1989), but it is a totally new creation and should not be 
considered a new edition. The two books are both introductions to number 
theory, structured so that the motivation arises from interesting computa­
tional problems, but that is almost all they have in common. 
In 1989, when Factorization and Primality Testing appeared, the two 
computational problems of the title were still sufficiently undeveloped that 
much of what was known could be presented in a first course in number 
theory, providing the motivation for that course. Today, that is no longer 
true. The field of factorization and primality testing has advanced so far in 
the past decade that no slim book could both introduce number theory to 
undergraduates and do justice to current techniques of factorization and 
primality testing. 
While this book retains a discussion of the basic methods of factoriza­
tion and primality testing, the emphasis has shifted to a broader range of 
computational issues. More is done with continued fractions, pseudoprime 
tests, Gaussian primes, Pell's equation, and computer explorations in 
general. And there are presentations of several applications that have not 
appeared in texts at this level before: the Madelung constant for salt, the 
Yao millionaire problem as an extension of the ideas of RSA encryption, 
and the use of check digits both to catch errors and to correct errors. The 
entire topic of elliptic curves has been avoided. There is not space to do it 
justice. And the detailed discussion of the quadratic sieve has been replaced 
by a detailed discussion of the continued fraction algorithm (CFRAC). 
While CFRAC is no longer one of the most powerful factorization algo­
rithms, neither is the simplistic version of the multiple polynomial qua­
dratic sieve that was presented in Factorization and Primality Testing. The 
advantage of CFRAC is that it illustrates the fundamental processes com­
mon to all of the Kraitchik family of factorization algorithms, including the 
quadratic sieves and the number field sieves, while having a relatively 
simple implementation. 

v1 
PREFACE 
But the greatest difference between these books lies in their style of 
presentation. 
The relatively infrequent programs written in pseudocode 
have been replaced by a rich assortment of Mathematica programs that are 
included on the website www.wiley.com/college/bressoud. 
The student 
using this book does not need to be able to program and should be able to 
get on the computer quickly to begin doing his or her own experiments, 
with patterns of integers. 
Our presentation of the theoretical structure of 
number theory is tightly integrated with these explorations, arising out of 
them to confirm, explain, or deny what is observed experimentally, and 
feeding back into them to enable ever deeper and more sophisticated 
investigations. For those who want to program, there is a rich assortment of 
problems, 
challenging 
the 
student to tum the theory 
into practical 
algorithms. 
This is designed to be a one-semester introduction to number theory, 
though there is more material than can be covered in a single semester. The 
book is more than a text, and we hope that the reader will continue to return 
to it for ideas and challenges. 
We are grateful to the students of our number theory classes at 
Macalester who have always been enthusiastic about the use of computers 
in their explorations. In particular, the work of Celine Liu, Einar Mykletun, 
Tamas Nemeth, Craig Ortner, Bill Owens, and Scott Tumquest has led to 
improvements 
in 
the 
package 
and 
exposition. 
We 
thank 
Daniel 
Bleichenbacher and Ilan Vardi for sharing their expertise, both theoretical 
and computational, on several topics covered in the book. The comments of 
Ellen Gethner and Patrick Mitchell, who used a preliminary version in their 
classes, were much appreciated. 
The careful production work of Steven 
Pisano (Springer-Verlag) and Louis J. D' Andria (Wolfram Research, Inc.) 
was superb. We thank them. 
We also thank our editor Jerry Lyons for his 
confidence in this project and his feelings that the incorporation of 
computational 
ideas 
in traditional 
courses 
is the right 
direction for 
contemporary education. 
The CRT package that accompanies this book (Mathematica is required 
for its use) has a lot of powerful techniques and ideas encoded in it. 
Readers who feel it would benefit from the inclusion of additional functions 
should feel free to communicate with the authors. We have prepared a file 
of solutions to selected exercises and will provide that to instructors on 
request. 
David Bressoud 
bressoud@macalester.edu 
Stan Wagon 
wagon@macalester.edu 

Contents 
Preface 
Notation 
Chapter 1. Fundamentals 
v 
xi 
1 
1.0 Introduction .................................................. .......................................... 1 
1 .1 A Famous Sequence of Numbers.......................................................... 2 
1.2 The Euclidean Algorithm .............................. .......................................... 6 
The Oldest Algorithm 
Reversing the Euclidean Algorithm 
The Extended GCD Algorithm 
The Fundamental Theorem of Arithmetic 
Two Applications 
1 .3 Modular Arithmetic ......... ................................ . ....................................... 25 
1.4 Fast Powers............................................................................................. 30 
A Fast Algorithm for Exponentiation 
Powers of Matrices, Big-0 Notation 
Chapter 2. Congruences, Equations, and Powers 
41 
2.0 Introduction ............................................................................................ 41 
2.1 Solving Linear Congruences ................................................................... 41 
Linear Diophantine Equations in Two Variables 
Linear Equations in Several Variables 
Linear Congruences 
The Conductor 
An Important Quadratic Congruence 
2.2 The Chinese Remainder Theorem ............. ............................................. 49 

viii 
CONTENTS 
2.3 PowerMod Patterns................................................................................ 55 
Fermat's Little Theorem 
More Patterns in Powers 
2.4 Pseudoprimes. .. ....... ...... ...... .. .... .. ... .... .... .. ... .. .. .... .... .. ... .. .. .. ........ ....... .. .. . 59 
Using the Pseudoprime Test 
Chapter 3. Euler's tfJ Function 
65 
3.0 Introduction .............................................................. : ............................. 65 
3.1 
Euler's tfJ Function ................................................................................... 65 
3.2 Perfect Numbers and Their Relatives .................................................... 72 
The Sum of Divisors Function 
Perfect Numbers 
Amicable, Abundant, and Deficient Numbers 
3.3 Euler's Theorem ...................................................................................... 81 
3.4 Primitive Roots for Primes ....................................................................... 84 
The Order of an Integer 
Primes Have Primitive Roots 
Repeating Decimals 
3.5 Primitive Roots for Composites .............................................................. 90 
3.6 The Universal Exponent.......................................................................... 93 
Universal Exponents 
Power Towers 
The Form of Carmichael Numbers 
Chapter 4. Prime Numbers 
99 
4.0 Introduction ............................................................................................ 99 
4.1 The Number of Primes............................................................................ 100 
We'll Never Run Out of Primes 
The Sieve of Eratosthenes 
Chebyshev's Theorem and Bertrand's Postulate 
4.2 Prime Testing and Certification .............................................................. 114 
Strong Pseudoprimes 
Industrial-Grade Primes 
Prime Certification Via Primitive Roots 
An Improvement 
Pratt Certificates 
4.3 Refinements and Other Directions ......................................................... 131 
Other Primality Tests 
Strong Liars Are Scarce 
Finding the nth Prime 
4.4 A Dozen Prime Mysteries........................................................................ 141 

CO NTENTS 
ix 
Chapter 5. Some Applications 
145 
5.0 Introduction ............................................................................................ 1 45 
5.1 Coding Secrets ...................................................................................... . 1 45 
Tossing a Coin into a Well 
The RSA Cryptosystem 
Digital Signatures 
5.2 The Yao Millionaire Problem ......................................................... ......... 1 55 
5.3 Check Digits............................................................................................ 1 58 
Basic Check Digit Schemes 
A Perfect Check Digit Method 
Beyond Perfection: Correcting Errors 
5.4 Factoring Algorithms.............................................................................. 1 67 
Trial Division 
Fermat's Algorithm 
Pollard Rho 
Pollard p-1 
The Current Scene 
Chapter 6. Quadratic Residues 
1 79 
6.0 Introduction............................................................................................ 1 79 
6.1 Pepin's Test. ........................................................................................... 1 79 
Quadratic Residues 
Pepin's Test 
Primes Congruent to 1 (Mod 4) 
6.2 Proof of Quadratic Reciprocity............................................................... 185 
Gauss's Lemma 
Proof of Quadratic Reciprocity 
Jacobi's Extension 
An Application to Factoring 
6.3 Quadratic Equations............................................................................... 1 94 
Chapter 7. Continued Fractions 
201 
7.0 Introduction ............................................................................................ 201 
7 .1 Finite Continued Fractions..................................................................... 202 
7.2 Infinite Continued Fractions ................................................................... 207 
7 .3 Periodic Continued Fractions ................................................................. 21 3 
7 .4 Pell's Equation ........................................................................................ 227 
7 .5 Archimedes and the Sun God's Cattle................................................... 232 
Wurm's Version: Using Rectangular Bulls 
The Real Cattle Problem 
7.6 Factoring via Continued Fractions .............. ............................................ 238 

X 
CONTENTS 
Chapter 8. Prime Testing with Lucas Sequences 
247 
8.0 Introduction ............................................................................................ 247 
8.1 Divisibility Properties of Lucas Sequences.............................................. 248 
8.2 Prime Tests Using Lucas Sequences ....................................................... 259 
Lucas Certification 
The Lucas-Lehmer Algorithm Explained 
Lucas Pseudoprimes 
Strong Quadratic Pseudoprimes 
Primality Testing's Holy Grail 
Chapter 9. Prime Imaginaries and Imaginary Primes 
279 
9.0 Introduction ............................................................................................ 279 
9.1 Sums of Two Squares ............................................................................. 279 
Primes 
The General Problem 
How Many Ways 
Number Theory and Salt 
9.2 The Gaussian Integers ............................................................................ 302 
Complex Number Theory 
Gaussian Primes 
The Moat Problem 
The Gaussian Zoo 
9.3 Higher Reciprocity .................................................................................. 325 
Appendix A. Mathematica Basics 
333 
A.O Introduction ................................................................................. ........... 333 
A.1 Plotting ................................................................................................... 335 
A.2 Typesetting ............................................................................................ 338 
Sending Files By E-Mail 
A.3 Types of Functions ................................................................................. 341 
A.4 Lists........................................................................................................ 343 
A.5 Programs................................................................................................ 345 
A.6 Solving Equations ................................................................................... 347 
A.7 Symbolic Algebra ................................... ................................................ 349 
Appendix B. Lucas Certificates Exist 
References 
Index of Mathematica Objects 
Subject Index 
351 
355 
359 
363 

Notation 
Mathematics Notation 
T 
w 
a 
A 
4>w.Q1 
"' 
Fn 
1f(X) 
z 
Zn 
zߎ 
Z[i] 
The golden ratio, ( 1 + ../5) / 2 
The rank of the Lucas sequence 
The quadratic conjugate of the quadratic irrational a 
Lucas lambda function 
The analog for the f P, QI-Lucas sequence of the Euler t/J function 
The Euler phi function: the number of integers in {l, ... , nl that 
are relatively prime to n 
The nth Fibonacci number; also the nth Fermat number, 22" 
The number of primes less than or equal to x 
The integers, { ... , -3, -2, -1, 0, 1, 2, 3, ... ) 
The integers modulo n 
The integers modulo n that are relatively prime to n 
The Gaussian integers: {a + bi: a, b E Zl 
[ a0; a1 , a2, • • •  , an I The finite continued fraction a0 + ---'-.,---
a1+---­
a2+ 
The infinite continued fraction ao + 
1 
a1 + a2+ ... 
[a0;a1, a2, ... ,a., bi. b2, • • •  , bnl The periodic continued fraction 
li(x) 
log(x) 
u(n) 
u(n, 1) 
T(n) 
t/J(n) 
gcd(a, b) 
[ao;a1, a2, ... ,a,, bi. b2, ... , bn, bi. b2, ... , bn, b1, ... ] 
The natural numbers {0, 1, 2, 3, ... ) 
Carmichael's lambda function: the least universal exponent 
The logarithmic integral function, fox +d t 
The natural logarithm of x 
The sum of the divisors of n 
The sum of the kth powers of the divisors of n 
The sum of the divisors of n, excluding n 
The sum of the divisors of n that are congruent to 1 (mod 4) 
The number of divisors of n 
The Euler phi function: the number of integers in {l, ... , n) that 
are relatively prime to n 
The greatest common divisor 

xii 
NOTATION 
lcm(a, b) 
log"(a, s) 
O(f(n)) 
Q[{q1, . . .  , Qk}] 
aln 
a,rn 
a= b (mod n) 
a 1= b (mod n) 
N(a) 
Vʠ(n) 
(̞)4 
ordm(a) 
a i n 
The least common multiple 
The largest integer n such that a i n :s s 
Big-0: a function that is bounded by a constant times f(n) 
The continuant function 
a divides n 
a does not divide n 
a is congruent to b modulo n 
a is not congruent to b modulo n 
Norm of a Gaussian integer a 
The ¢>-valence of n: the number of times n occurs as ¢>(m) 
The Legendre symbol (and the Jacobi symbol) of a with respect 
top 
The quartic residue symbol, where tr is a prime in the Gaussian 
integers 
The order of a modulo m 
The tower of powers with n terms: a00 
Mathematica Notation 
#, #1, #2 
I@ 
& 
&& 
II 
@@ 
II 
1. 
I; 
->,--) 
:>, =ݣ 
<< 
The generic variables in pure functions 
Map 
A delimiter for the end of a pure function 
And 
Or 
Apply 
Notation allowing a function to be applied after its argument 
(postfix notation) 
ReplaceAll 
Conditional 
Blank: stands for any pattern 
Double blank: stands for a nonempty sequence of objects 
Triple blank: stands for a sequence of objects, possibly empty 
Delayed assignment 
A rule 
A delayed rule 
Is numerically equal to 
Is identical too 
Not 
Get (the file) 

CHAPTER 1 
Fundamentals 
1.0 Introduction 
Consider the following sequence of rational numbers: 
1 3 7 17 41 99 
T · 2' 5 · 12 · 29 • 10 • . .  · · 
(1) 
After starting with 1/i ,  the next fraction is obtained by adding numerator 
and denominator to get the new denominator, and then adding the old and 
new denominators to get the next numerator. Compare these values to the 
square root of 2. These are not only good approximations, they are fantasti­
cally good. The more familiar approximation 141/ioo is in error by no more 
than 1/200 . But the error for a fraction in (1) is less than the reciprocal of 
twice the square of the denominator; for example, 99/?o - "2 = 0.000072 ... , 
while 1 / (2 ·  702) = 0.00010 
.. .. 
This is an ancient algorithm, known to the Greeks of the classical era 
and rediscovered in other times and places. A more modern algorithm, one 
that is less than 150 years old, is the following test for whether or not 
m = 2n - 1 is prime when n is an odd integer greater than 2. Start with 
S = 4 and iterate the following sequence of commands n - 2 times: square S, 
subtract 2, divide the resulting number by m, and assign to S the value of 
the remainder that you get from the division. After n - 2 iterations, look at 
the value of S. If it is 0, then m is prime; if it is not 0, then m is not prime. 
For example, when n is 5 and m = 25 - 1  = 31 we get the following sequence 
of values for S: 
4, 42 - 2 = 14, 142 - 2 = 194 = 6 · 31 + 8, 82 - 2 = 62 = 2 · 31 + 0 .  
Given that this algorithm is valid, 31 must be prime. In 1999, this algo­
rithm was used to prove that 26972593 - 1 is prime, setting the record for the 
world's largest known prime. 
These are two of the algorithms of number theory. We shall see an 
explanation of the first algorithm as well as an exploration of its extension 

2 
1 .  FUNDAM ENTALS 
to other square roots and eventually to other irrational numbers in Chapter 
7. The second algorithm will be explained and justified in Chapter 8. 
Number theory, the study of properties of the integers, has long been 
inseparable from algorithms, precisely specified procedures that produce 
desired output. To find efficient numerical algorithms, we must understand 
the structure of the integers. To explore this structure, we are aided by the 
algorithms that we already possess. The advent of the electronic computer 
has strengthened this symbiosis. Raw computer power is seldom sufficient 
for really interesting problems. 
Factorization of large integers gives us an illustration of the need to 
understand the structure of the integers. Integers 100 digits long can now 
be factored routinely. It might seem that this is a problem for which a naive 
approach and a lot of computer power would work well: you generate a list 
of prime numbers and just run trial division until you find a prime divisor. 
As we shall see, generating the possible prime divisors is easy. The problem 
is that there are too many of them. If the smallest prime divisor of our 
integer has 50 digits (and these days, that is not considered to be especially 
large), then the Prime Number Theorem (Chapter 4) tells us that there are 
about 8. 7 · 1047 primes that we have to test before we get to this divisor. 
That is a lot of trial divisions! 
If we imagine an ideal processor that does a trillion (1012) trial divisions 
per second, and set up a million of these processors in parallel, each proces­
sor taking a different subset of the possible divisors, we would be able to 
test 1018 different primes each second. That sounds like a lot, but it is not. 
There are about 3.2 · 107 seconds in a year, so it would take over 1022 years 
to complete the factorization. Our universe is less than 2 · 1010 years old. 
In fact, there is no number theory problem that stretches our under­
standing of integers so much as the problem of factorization. In recent 
years, it has seemed that whatever new insight we gain into the structure 
of the integers, it is directly applicable to the factorization problem or to its 
twin, the problem of recognition of prime numbers. Algorithms for factoriza­
tion and primality testing will appear throughout this book. 
1.1 A Famous Sequence of Numbers 
The following sequence of numbers plays a central role in elementary 
number theory: 0, 1, 1, 2, 3, 5, 8, 13, . . .  , where each number is obtained by 
adding the preceding two. These are the Fibonacci numbers, with the 
indices starting at O; Fo = 0, F1 = 1, F2 = 1, and so on, with Fn = Fn-l + Fn-2· 
One could use a recursive method to generate these numbers, but that is 
very inefficient (see Exercise 1.5). It is much, much better to use an itera­
tive approach, as follows. 
Fib [ O] = O ;  
Fib [ n_] : = Module [ { a = O , b = l } ,  
Do [ { a ,  b }  = { b ,  a + b } ,  {n - 1 } ] ; b] 

1 . 1 .  A FAMOUS S EQUENCE OF NUM B ERS 
3 
Map [ Fib , { O ,  1, 2 ,  3 ,  4 ,  5 ,  6 ,  7 ,  100} ]  
{ O , 1 , 1, 2 ,  3 ,  5 ,  8 ,  13 , 35422484 81792619150 7 5 } 
The parallel definition of a and b makes it clear that a matrix formula­
tion will work well, since {a, b) is updated to ({ 4)(:)· This means that the 
nth Fibonacci number is the number in the (1, 2) position of ( { 4 f. 
MatrixPower [ { { O ,  l } , { l ,  l} }, 5 ]  II MatrixForm 
'.rable [MatrixPower[ ( z ǯ), n] [l ,  2:n , {n , O ,  10} ] 
{ O , 1 ,  1, 2 ,  3 , 5 ,  8 , 13 , 21, 34 , 55 } 
In fact, the Fibonacci numbers are built into Mathematica as follows. 
Fibonacci [ { lO ,  100} ] 
{ 5 5 ,  3 5 4 2 2 4 8 4 817 9 2 61915075 } 
An important question concerns the growth rate of Fn. Figure l. l(a) 
shows the raw Fibonacci numbers; not too much is visible except that the 
growth seems to follow a steady pattern. But plotting the logarithm of Fn 
will cause the underlying exponential growth rule to jump out, since F = an 
becomes logF = n(loga), a linear function of n. 
1 0 0 0  
50 0 
4 
8 
(a) 
1 0 0 0 0 0  
1 0 0 0 0  
(b) 
2 0  
2 5  
3 0  
Figure 1.1. (a) The Fibonacci numbers grow at a regular rate. (b) Plotting log Fn 
against n makes the exponential nature of the Fibonacci growth rate jump out. 
A beautiful and important fact about the Fibonacci numbers is due to 
Binet. Let T denote the golden ratio, which is (1 + ../5)/2, or 1.61803 ... ; 
this famous number, the larger root of the quadratic equation x2 = x + 1, is 
built into Mathematica as GoldenRatio. Note that the other root, which 
we will denote by er, is - 1 /r. Binet's formula is the surprising result that a 
certain combination of nth powers of T and er equals Fn . The formula is 
given in Proposition 1.1. Here is a computation in support, done using 
floating-point arithmetic (caused by the decimal point after the "1"). 

4 
1 .  FUNDAM ENTALS 
'.rable[...:.:_ (GoldenRation - (-
1 
)n), {n, O ,  10}] 
../5 
GoldenRatio 
{ 0 ' 1 .  ' 1 .  ' 2 .  ' 3 .  ' 5 . '  8 . '  13 . ' 2 1 .  ' 34 . ' 5 5 . } 
Proposition 1.1. Binet's Formula. 
Proof. It is easy to verify the formula when n = 0 or 1. For the latter 
observe that 1/T = (-1 + -{5)/2. Thus, it suffices to show that the right side 
obeys the same recursive rule as the Fibonacci numbers; that is, we need 
--- + --- = ---
-{5 
-f5 
-f5 
But this follows immediately from the fact that Tn + Tn+l - Tn+2 = Tn(l + T­
T2) = 0, and the identical relationship that holds for CT. 
D 
Because ICTI < 1, powers of CT approach 0. This means that Binet's for­
mula has the following corollary. 
Corollary 1.2. Fn equals the nearest integer to Tn / -f5. 
Proof. Because !CTI < 1 and -f5 > 2, the CTn / "5 part of Binet's formula is, 
in absolute value, less than 1'2; this suffices. 
D 
Exercises for Section 1 .1 
1.1. Prove that the gcd of two consecutive Fibonacci numbers is 1. 
1.2. Investigate the ratio Fn+l I Fn of consecutive Fibonacci numbers and 
try to identify the limit. 
1.3. Investigate the sum Fo + F1 + · · · + Fn . Find a formula for this sum and 
prove it by induction. 
1.4. Investigate the numbers Fn-1 ·Fn+ l · Find a formula for this product 
and prove it by induction. 
1.5. The following code is a recursive definition of the Fibonacci numbers, 
with a counter added to count the number of additions performed. The 
output following the code shows that, when Fib[ 6 ]  is called, the resulting 
value of count is 12. Explain where 12 comes from. Do the same for values 
other than 6. Find a formula for sumCount when Fib [ n] is called. If you do 

1 . 1 .  A FAMOUS SEQU ENCE OF NUMBERS 
5 
this correctly you will see why this method, simple as it is, is useless for 
generating Fibonacci numbers. 
Clear [Fib ] ; 
Fib [ O ]  = O ;  
Fib [ l ]  = 1 ;  
Fib [n_] := ( sumCount + + ;  Fib [n - 1 ]  + Fib [n - 2 ] ) 
sumCount = 0 ;  
Fib [ 6 ] ; 
sumCount 
12 
1.6. (a) Find all n between 1 and 100 for which Fn is prime. These numbers 
are large, so use PrimeQ or an equivalent function in other software. Such 
functions are almost always correct, as will be discussed in detail in Chap­
ters 4 and 8. Do you see any patterns? 
(b) Prove that Fn divides Fkn· and show how this fact helps in the search 
for prime Fibonacci numbers. Hint: Use the fact that Fm= Am where A is a 
2x2 matrix. Show that if a 2x2 matrix B has the property that its two off­
diagonal elements are divisible by b, then that property is valid for any 
power of b. 
1. 7. (E. Lucas, 1876; see [Jon]) Prove that the pairs of positive integers x, y 
that satisfy y2 - yx - x2 = ± 1 are precisely the pairs of consecutive 
Fibonacci numbers. Figure 1.2 shows how the pairs of Fibonacci numbers 
sit on these two hyperbolas. The relationship of the Fibonacci numbers to 
the theory of Diophantine equations and computers is a deep one; see [Mat, 
Jon] for the connections with Hilbert's tenth problem. In particular, a 
central role is played by the fact that there is a Diophantine definition of 
the set of pairs (n, Fn>· This is somewhat more difficult than the result of 
this exercise, which gives a Diophantine definition of the set of pairs 
(Fn, Fn+d· 
13 
B 
0 
1 
2 
3 
5 
B 
Figure 1.2. Pairs of consecutive Fibonacci numbers live on the two hyperbolas 
given by y2 - y x - x2 = ± 1 .  

6 
1 .  FUNDAMENTALS 
1.2 The Euclidean Algorithm 
 The Oldest Algorithm 
One of the oldest and most important algorithms of number theory is the 
one that Euclid described at the beginning of Book VII of The Elements, 
written around 300 BCE. The algorithm finds the greatest common divisor of 
two integers and is essentially unchanged after 2300 years. It appears as a 
subroutine in many algorithms we will study. Most modern factorization 
techniques rely on finding integers that are likely to share a nontrivial 
factor with n, the integer that is to be factored. They then accomplish the 
factorization by applying the Euclidean algorithm to find this nontrivial 
factor of n. On a more basic level, computer algebra systems such as Mathe­
matica typically use the Euclidean algorithm whenever a rational number 
is encountered, so that it can remove common factors and express the 
fraction in lowest terms. An example: 
8888888 
3 1 1 1 1 108 
2 
7 
Before we explain the Euclidean algorithm, we must pin down our 
terminology. We say that an integer n is divisible by the integer d, or that 
d divides n, if there is an integer m such that n = d · m. If d divides n then 
it is a divisor of n. While this definition may look obvious, it will be impor­
tant for discovering and understanding proofs. An integer larger than 1 
that is not divisible by any other integer larger than 1 is called a prime or 
a prime number. An integer larger than 1 that is not prime is called 
composite; thus, a composite integer has a divisor larger than 1 and less 
than itself. The prime factorization of a positive integer is a representa­
tion of n as a product of primes. Thus, the prime factorization of 620 is 
22 . 5 . 31. 
Factorinteger [ 620] 
{ { 2 ,  2 } ,  { 5 ,  1 } ,  { 3 1 ,  l } }  
The CNT package that accompanies this book contains a function, 
FactorForm, that puts factorizations in familiar form. The I /fen notation 
is a way of applying a function to an expression without typing brackets at 
both ends. First we load the package. 
Heeds [ " CRT' " ]  
Factorinteger [ 30 I ] I I Factorrorm 
226 314 57 74 1 12 1 32 1 7 1 9 23 29 

1 .2. THE EUCLI DEAN ALGORITH M 
7 
The number 1 is neither prime nor composite. It is an example of a 
unit, an integer that divides 1. When working with ordinary integers, there 
are only two units, the other one being -1. For purposes of factorization, we 
shall ignore negative integers. The significance of the primes is that they 
are the building blocks under multiplication for all integers greater than 1. 
We assume that we have a division algorithm: given any two integers a 
and b (b * 0), we can find the unique integers r and q such that a =  qb + r, 
with 0 s r < I  b j. The integer r represents the remainder when a is divided 
by b. Mathematica and many other computer languages use Mod for this 
function: Mod [a , b] is the remainder when a is divided by b. So b divides a 
if and only if Mod [a , b] is 0. 
Mod [ 2 5 , 7 ]  
4 
Mod [ l0100 , 7 9 1 9 ]  
4806 
The quotient - q in the preceding paragraph - can also be obtained 
quickly. This can be useful in programs because it is faster than 
Floor [ a  I b] . (Reason: Quotient avoids the invocation of the Euclidean 
algorithm to reduce to lowest terms.) 
Quotient [ 2 5 , 7 ]  
3 
Because the division algorithm fails in other domains, it is worthwhile 
to see why it is valid in the integers. The main point is that every set of 
nonnegative integers has a least element. Thus, the remainder r can be 
defined as the smallest element of {a - qb : q E Z, a - q b d 0). From this, it 
is not hard to prove (Exercise 1.8) that 0 s r < I  b I and that r and the choice 
of q are unique. 
The greatest common divisor, or gcd, of two integers is the largest 
integer that divides both; it is denoted by gcd(a, b). Two integers are called 
relatively prime if their gcd is 1. The least common multiple, or lcm, of 
two integers is the smallest positive integer that is divisible by both. We 
leave it as an exercise to prove that for any two positive integers, a and b, 
gcd(a, b) · lcm(a, b) = ab (and so the lcm is easily computed from the gcd). 
The Euclidean algorithm for calculating the gcd is based on the following 
fact. 
Proposition 1.3. If a - b is divisible by n, then gcd(a, n) = gcd(b, n). 
Proof. 
The hypothesis tells us that there is an integer t such that 
a - b = n t. Let d be any common divisor of b and n, say b = dy and n = dz. 
Then a =  b + n t = dy + dzt = d(y + zt), so d is also a divisor of a and there­
fore a common divisor of a and n. And if c is any common divisor of a and n, 
say a =  c u  and n = c v, then b =a - n t =cu - c v t = c(u - v t). So c divides b 
and is a common divisor of b and n. 

8 
1 .  FUNDAM ENTALS 
Because the set of common divisors of b and n is identical to the set of 
common divisors of a and n, the largest elements of these sets must be the 
same. 
D 
Because a and Mod[a, b] differ by a multiple of b, Proposition 1.1 tells 
us that gcd(a, b) = gcd(Mod[a, b], b). This is the basis for a recursive defini­
tion of the Euclidean algorithm. 
Algorithm 1 .1 . The Euclidean Algorithm 
gcd[a_, OJ :=a; 
gcd[a_, b_] :=gcd[b, Mod[a, b]] 
From the definition of Mod[a, b], after each recursive step the second 
argument is strictly smaller than the first (unless b > a, but then they 
switch roles after the first step). Therefore the algorithm must terminate. 
The question of the number of steps required is addressed in Theorem 1.6 
and Exercise 1.14. 
gcd[97, 18] 
1 
Alternatively, the algorithm can be defined using a single I f  statement. 
Here we add a Print statement so we can watch the algorithm at work. 
gcdl[a_, b_] := (Print[{a, b}]; If[b==O, a, gcdl[b, Mod[a, b]]]) 
gcdl [97, 18] 
{ 9 7 , 1 8 } 
{ 1 8 , 7 }  
{ 7 ,  4 } 
{ 4 , 3 }  
{ 3 , 1 } 
{ 1 ,  0 } 
1 
The values produced by the Euclidean algorithm starting with a, b are 
called the remainders, and we will refer to them as r0 = a, r1 = b, ... , Tn = 
d, Tn+l = 0, where d = gcd(a, b). The quotients are denoted q1, 
. . .  , Qn· For 
the detailed study of the algorithm later in this chapter it is important to be 
clear and consistent in the use of subscripts. The Ful lGCD function shows 
the progress of the algorithm. 

FullGCD[97, 18, Labels-+ True] 
Remainders 
Quotients 
ro 
= a 
= 97 
r1 
= b 
= 18 
ql 
= 5 
r2 
= 7 
q2 
= 2 
r3 
= 4 
q3 
= 1 
r. 
= 3 
q. 
= 
1 
rs 
= 
1 
q5 
= 3 
r& 
= 
0 
1 .2. THE EUCLIDEAN ALGORITHM 
9 
Of course, gcd is built into Mathematica (as is lcm, as LCM [ a ,  b ]  ). 
GCD[97, 18] 
1 
One can appreciate the speed of this algorithm by using very large 
integers. Here we use two random 1000-digit integers; the computation is 
almost instantaneous. 
{a, b} 
= '.rable[Random[Inveger, {10999, 101000 - 1}], {2}]; 
Timing[GCD[a, b]] 
{0.0166667 Second, l }  
In a moment we will find the values of a and b below any given bound 
that cause the Euclidean algorithm to take the largest number of steps. 
Exercise 1.14 contains some code that one could use to search for such 
integers. 
The Euclidean algorithm is blindingly fast, widely useful, and imple­
mentable in a single line of code, all of which combine to make it one of the 
most beautiful algorithms of number theory. 
ª Reversing the Euclidean Algorithm 
It often happens in mathematics that reversing an algorithm leads to new 
insights. For example, the ability to multiply two integers is something all 
numerate humans can do. Yet the reversal of this operation - going from 
an integer n that has the form p · q, where p and q are primes, to the individ­
ual numbers p, q - is extremely difficult; this observation is the key to 
modern secure encryption systems. 
For several reasons - deeper understanding of the algorithm, its 
connection with continued fractions (Chapter 7), its use for writing an 
integer as a sum of squares (Chapter 9) - it is useful to consider how to 
reverse the Euclidean algorithm. Given the quotients, we try to find the 
remainders. Suppose the quotients are q1 , • • • , Qn , where q1 is the quotient 
formed by a I b, and Qn , the last quotient, is r n-I Id. For simplicity assume 
that a and b are relatively prime, so d, the gcd of a and b, is 1. Can one 
reconstruct the sequence of remainders - the r-values, including a and b -

10 
1. FUNDAM ENTALS 
from the q-values? The answer is YES, for it is fairly clear that the quotients 
can be used, bottom-up, to determine the remainders. Keep in mind the 
fundamental relationship of these numbers: 
Tk-1 = QkTk + Tk+l · 
(2) 
Thus Tn = d = 1, Tn-1 = Qn . Tn-2 = Qn-1 Tn-l + Tn = Qn-l Qn + 1, and so on. It is 
instructive to work out the value of Tn-a in terms of the q's; then try rn_4• 
Can you see a pattern in the definition of the r-values in terms of the q­
values? A further exercise: Suppose the quotient sequence is {5, 2, 1, 1, 3}. 
Determine a and b. 
Let us use Q to represent the function that takes a list of quotients and 
produces the topmost remainder of the corresponding Euclidean algorithm 
remainder sequence. This is called the continuant function; and the 
procedure we are about to describe was known to Euler. Keeping with our 
assumption that gcd(a, b) = 1, we can say that Q[{}] = 1 and, as observed a 
moment ago, Q[{q1 }] is simply q1 . Equation (2) leads to the following recur­
sive definition of Q for lists of length 2 or more: 
Q[{Q1 •
. . .  , Qk }] = Q1 Q[{Q2 , ... , Qk }] + Q[{q3, ... , Qk }]
. 
(3) 
We can use this to define Q in Mathematica and investigate some examples. 
It is good practice to use descriptive names, so we use ContinuantQ 
instead of just Q. 
ContinuantQ[ {}] 
= 1 ;  
ContinuantQ[ {q_}] 
: = q 
ContinuantQ[q_] 
:= 
q[l] ContinuantQ[R est[q]] +ContinuantQ[Drop[q, 2]] 
We can now recover our a-value, 97. 
qVals 
= {5, 2, 1 ,  1 ,  3}; 
ContinuantQ[qVals] 
9 7  
And we can recover the entire r-sequence by applying Q to all the tails 
of the q-sequence. Here are the tails. 
'.rable['.rake[qVals, i], {i, - 5, O}] 
{ { S , 2 ,  1 ,  1 ,  3 } , { 2 ,  1 ,  1 ,  3 } ,  { 1 ,  1 ,  3 } , { 1 ,  3 } ,  { 3 } ,  { } }  
'.rable[ContinuantQ['.rake[qVals, - i]], {i, - 5, O}] 
{ 9 7 , 2 7 , 1 6 , 1 1 ,  5 ,  l }  
Now comes a surprising fact: Q is invariant under the reversal of the 
quotient list. 

ContinuantQ[{3, 1 ,  1 ,  2 ,  5}] 
97 
1 .2. TH E EUCLIDEAN ALGORITHM 
1 1  
To understand why this is so, we use ContinuantQ to examine the 
remainders as abstract functions of the quotients. Such an approach oftens 
leads to valuable symbolic information. The version of ContinuantQ in the 
CNT package expands the output and formats it in a more natural sorted 
order than the default, so we load the package now and use that version. 
Get ["CRT'"] 
ContinuaptO [ { q1 , qz , qJ , q, , q, } ] 
Contipuapt;O ['l!able [q1, {i, 6}]] 
1 + Qi Q2 + Qi Q4 + Qi Q6 + QJ Q4 + QJ Q6 + Qs Q6 + Qi Q2 QJ Q4 + 
Qi Q2 QJ Q6 + Qi Q2 Qs Q6 + Qi Q4 Qs Q6 + QJ Q4 Qs Q6 + Qi Q2 QJ Q4 Qs Q6 
Can you detect the pattern in the results? There is indeed a simple rule 
at work, which we express in Proposition 1.4. Note that the product of no 
numbers is taken to be 1 Gust like the sum of the empty set is 0). Before 
reading the proof, make sure you see the connection with the sums just 
obtained: starting with, say, abcde, one can delete a single pair to get a b c, 
a b  e, ad e, or c de, or one can delete a double pair to get a, c, or e (but not b 
or d). In the 6-case, deleting all pairs yields the empty set, whose product 
is 1. 
Proposition 1.4. Q[{q1 , • • •  , Qk)] is the sum of all products obtained by 
starting with q1 q2 · • · Qk and deleting adjacent pairs in all possible ways. 
Proof. Let R denote the pair-deletion function. Then R and Q agree on the 
empty set and singletons. Thus it is sufficient to show that R obeys the 
same recursive law that defines Q. So we want to show that 
R[{Q1 , ... , Qk )] = Q1R[{Q2 , ... , Qk)] + R[{q3, ... , Qk)]. But this is easy, since 
every summand on the left side arises by the deletion of pairs that do not 
involve q1 , in which case the summand shows up in the first term on the 
right side, or by the deletion of a pair that does involve q1 , in which case q2 
must have been deleted too, so it shows up in the second term on the right. 
A similar argument shows that every term on the right side appears in the 
sum on the left side. 
o 
This immediately explains the reversal invariance, because the sum of 
products is invariant under reversal. This fact will play a key role in Chap­
ter 9, where it is used in a very fast algorithm for writing an integer as a 
sum of two squares. 

1 2  
1. FUNDAM ENTALS 
Corollary 1.5. Continuant Reversal Q[{q1, ... , Qk)] = Q[{qk, ... ,qi}] 
Proposition 1.4 sheds a strong light on the issue of worst-case running 
times for the Euclidean algorithm. Suppose we seek the smallest number a 
for which some Euclidean algorithm sequence starting with a has six steps. 
What would the quotient sequence look like? It cannot end in a 1 for that 
would mean that rn = rn-1. which cannot happen. So the smallest last 
quotient is 2. But all the other quotients can be 1. So the quotient sequence 
can look like {1, 1, 1, 1, 1, 2). Proposition 1.4 tells us that any other q­
sequence of length six would lead to a larger value of a, since a is a simple 
algebraic sum of quotients that can only increase when a quotient 
increases. This means that the n-element sequence {1, 1, 1, ... , 1, 2) is the 
quotient sequence that leads to the smallest a-value for which a Euclidean 
algorithm sequence has length n. Moreover, the corresponding b-value 
comes from the (n - 1)-term sequence of the same form (just delete the first 
1) and so it is the worst a-value for length n - 1. 
Identifying these numbers is easy. 
Table [Continuant.a [Append [Table [ 1, {n - 1}] , 2]] , {n, 1, 10}] 
{ 2 , 3 , 5 ,  8 , 1 3 , 2 1 ,  34 , 5 5 ,  8 9 , 1 4 4 } 
These are the Fibonacci numbers (defined in Section 1.1). It follows immedi­
ately from equation (3) that Q[{l, 1, 1, ... , 1, 2)] = Fn+2, where there are n 
terms in the argument to Q. These observations provide a proof of the 
following result, commonly known as Lame's theorem. 
Theorem 1.6. 
Lame's Theorem. 
The smallest positive integer a for 
which there is a smaller number b so that the Euclidean algorithm applied 
to a and b stops in n steps is the (n + 2)nd Fibonacci number. And the 
corresponding b is the (n + l)st Fibonacci number. 
Here is an example showing the length-6 behavior for the seventh and 
eighth Fibonacci numbers. 
FullGCD [Fibonacci [ 8], Fibonacci [7] , Labels-+ Short] 
Remainders 
Quotients 
ro 
= 
a 
= 21 
r1 
= 
b 
= 13 
ql 
= 1 
8 
1 
5 
1 
3 
1 
rs 
= 2 
qs 
= 1 
r6 
= 1 
q6 
= 2 
r1 
= 0 

1 .2. TH E EUCLIDEAN ALGORITH M 
1 3  
Binet's formula (Corollary 1.2) tells us that the (n + 2)nd Fibonacci 
numbers is the closest integer to r"+2 / .../5, where r is the golden ratio. 
Thus, we get the following result on the worst-case running time of the 
Euclidean algorithm. 
Corollary 1.7. 
If 1 s b <a, then the number of steps in the Euclidean 
algorithm on the pair {a, b} is at most 4.8log10a. 
Proof. Lame's theorem states that the number of steps, n, is at most k - 2, 
where Fk is the largest Fibonacci number under a. But then, by the corol­
lary to Binet's formula, rk / .../5 s a+ 0.5, so k s  log, .../5 +log,( a+ 0.5) = 
1.68 + 4.79log10(a + 0.5). Therefore, n s k- 2 =s; -0.32 + 4.79log10(a + 0.5). If 
a 2: 3 this last expression is bounded by 4.8log10a. The single case where 
a= 2 and b = 1 stops in 1 step, and 1 s 4.8log102. 
D 
From a practical perspective, average-case behavior can be more impor­
tant than worst-case behavior. The average behavior of the Euclidean 
algorithm is discussed in Exercise 1.14. 
 The Extended GCD Algorithm 
With just a little more work we can get a lot more information out of this 
algorithm. As Euclid realized, given integers a and b, a small modification 
of this algorithm can be used to find integers s and t such that 
sa + tb = gcd(a, b). 
Moreover, the s and t value are tremendously important for a variety of 
reasons, one of which is their central role in the proof that numbers can be 
factored uniquely into primes (Theorem 1.1 1). 
The proof that s and t exist is straightforward. Recall the central rela­
tionship (3) among the remainders in the Euclidean algorithm, which we 
rephrase as rk+l = rk-i - qkrk. This tells us that any remainder is an integer 
linear combination of the previous two remainders. Now, if rn is the gcd of 
a and b, then r n is an integer combination of r n- l and r n-2• But r n- t is an 
integer combination of rn-2 and rn-3, so we now have a combination of rn_2 
and rn_3. We can work all the way back up to a and b in this way, getting 
the desired representation. An example will clarify how this would work. 
Remainders 
Quotients 1 
{s, t }  
97 
l 
{1, 0} 
1--·--
-----
--·-.. ·····--+-----·-
.. · ·······--------···----
1---·--¨ 
-9=-··· _9_7 ___ 5 
___ 1_0__ 
---§ ----t 
· · / 1°; ' ©\!} 
___ _ 
4 = 10 - 2. 1 
----G---··1-··-··--·-i 
---{ό2-.-1-n 
__
__ 
_ 
1--- 3 
= 7 - 4 
i ___ 
! ___ {i;=-16·:----·· 
----- -------+-------··---·-·.:...·- ----····· -
-
·---------· 
1=4
-
3 
3 
{-5, 27j 
i 

1 4  
1. FUNDAMENTALS 
Working backwards up the list of remainders, we see that 
1 = 4 - (7 - 4) = 2 * 4 - 7 = 2 * (18 - 2 * 7) - 7 = 
2 * 18 - 5 * 7 = 2 * 18 - 5 * (97 - 5 * 18) = 27 * 18 - 5 * 97 . 
This tells us that 1 = 27 · 18 - 5 · 97. But a much better way to organize this 
process is to start at the top, rather than the bottom. It is clear that each of 
a and b is an integer combination of a and b: just use 1 ·a + 0 · b and 
O·a + 1 · b. But whenever each of rk-l and rk-2 is such a combination, say 
rk-2 = ask-2 + b tk-2 and rk-1 = ask-1 + btk-1 , one can use the fundamental 
relationship (2) to get the next remainder in such a form as well: rk = rk_2 -
Qk rk-1 = a(sk-2 - Qk Bk-i >  + b(tk-2 - Qk tk-d· 
This tells us that the new coefficients, Bk and tk, are Sk-2 - QkBk-l and 
tk-2 - Qktk-1 , respectively. Algorithm 1.2 implements this recursion in an 
iterative manner, making use of the fact that the definition of the new s­
and t-values can be defined by multiplying the old values by a 2x2 matrix. 
Mathematica uses lists of lists to represent matrices, with a dot for matrix 
multiplication. 
However, by using Tradi tionalForm for output one can gets results 
that are much easier to read. 
( 0 
1 ) ( ·k-2 
tk-2 ) 
• 
• 
1 
• 
11 'l!rad1t1onalForm 
- q  
•k-1 
tk-1 
( 
Bk-I 
tk-1 ) 
Bk-2 - QSk-1 tk-2 -qtk-1 
In fact, equation (3), which generates the new remainder from q and the 
previous remainders, is identical to the s- and t-equations, so the remainder 
computation can be included in the matrix operation as well: 
Algorithm 1 .2. The Extended Euclidean Algorithm 
Given integers a and b, this algorithm calculates their gcd, d, and outputs 
{d, {s, t}) where d = s ·a + t · b. The three columns of the 2x3 matrix rst 
represent the two latest r-values, s-values, and t-values, respectively. 

1 .2. TH E EUCLI D EAN ALGORITH M 
1 5  
extendedgcd [ a_ , b_] : =  
( a 
1 
0 ) 
Module[ { rst = 
b 
0 
1 } , While [rst [2 ,  l]t- 0 , 
q = Quotient [ rst [l ,  l] , rst [2 ,  l] ]J r&t = (z _
1
q) . rst] J 
{ rst [l ,  l] , rst [l ,  { 2 , 3 } ] } ] 
extendedgcd [ 97 , 1 8 ]  
{ 1 ,  { - 5 ,  2 7 } }  
This function is built into Mathematica as ExtendedGCD. Here's an 
example using the hundredth and thousandth prime. 
ExtendedGCD [ 54 1 , 7 9 1 9 ]  
{ l , { - 1 0 1 0 , 69 } } 
It never hurts to verify results, especially when the verification is as 
simple as it is here. 
- 1010 * 5 4 1  + 69 * 7 9 1 9  
1 
We can see the algorithm at work by use the ExtendedGCDValues 
option to FullGCD. Having the full list of s- and t-values illustrates several 
important points: 
1. The equation rk = ska + tk b holds at every step. 
2. The signs of the s- and t-sequences alternate. 
3. If gcd(a, b) = 1 and if one carries the iteration an extra step, then the 
final s- and t-values agree with b and a (except for sign). 
4. The complete s- and t- sequences, viewed in reverse and ignoring the 
minus signs, are Euclidean algorithm remainder sequences starting 
from b and a, respectively. 
5. Sktk+l -tkSk+l = (-l)k 
FullGCD [ 97 , 18 , ExtendedGCDValues-+ True , Labels-+ Short ] 
Remainders 
I 
Quotients 
ro 
a 
97 
ri 
= b 
= 18 t 
ql 
= 5 
7 
2 
4 
1 
r4 
= 3 
q4 
1 
I 
r5 
1 
i 
q5 
3 
r6 
= 0 
I 
So 
St 
S4 
= 
85 
86 
s 
1 
0 
. 
___
_ _L. __ 
1 
I 
-·· 
-2 
3 
- 5 
18 
t 
to 
0 
·-·· 
t1 
1 
-5 
11 
t. 
= - 16 
·-- ·-··-··-·-··-
t5 
= 2 7 
t6 
= -97 
Proofs are left as an exercise (Exercise 1.18). Note also that if one wants 
only the final values Sn and tn, then one could skip the t-computation 
entirely and get tn as simply (d- Sn a)/ b. But in fact it is useful to have the 

1 6  
1 .  FU NDAM ENTALS 
full sequence, and for that the iterative method of Algorithm 1.2 is just as 
efficient as getting each Bk from tk . 
Theorem 1.8. Let a and b be integers with greatest common divisor d. 
There exist integers s and t such that d = sa + t b. 
One corollary of Theorem 1.8 is that any integer that divides both a and 
b must divide their greatest common divisor. In other words, the gcd is not 
merely the largest integer in the set of common divisors. It is actually 
divisible by every element of the set of common divisors. 
A second corollary that is so important that we shall call it a proposi­
tion is the following. 
Proposition 1.9. If d divides mn and d is relatively prime to m, then d 
must divide n. 
Proof. Because d divides mn, we can write m n = du for some integer u. 
And because d and m are relatively prime, we can find integers s and t with 
1 = sd + tm. We multiply each side of this equation by n and then replace 
mn by du: 
n = nsd + ntm = nsd + dut = d(ns + ut) .  
Because ns + ut is an integer, this proves that d divides n. 
o 
An important special case is given in the following result. 
Corollary 1.10. If a prime number divides the product of two integers, 
then it must divide at least one of those integers. 
Proof. If a prime p divides m n but does not divide m, then it is relatively 
prime to m (because p and 1 are the only divisors of p). Proposition 1.9 then 
tells us that p divides n. 
o 

 The Fundamental Theorem of Arithmetic 
We are now in a position to prove the fundamental theorem of arithmetic, 
the theorem that asserts that not only do we have a prime factorization for 
each positive integer, but that it must be unique. First, note that it is very 
easy to prove that every integer is a product of primes. Use induction: 
either n is prime or it equals a · b where 1 < a, b < n. By induction a and b 
are each a product of primes. Multiplying all the primes together shows 
that the same is true for ab. But this is far short of showing that the prime 
factorization is unique; that is more subtle and requires the gcd machinery 
we have just built. 
Theorem 1.11. 
The Fundamental Theorem of Arithmetic. 
Every 
positive integer may be factored into primes, and the factorization is unique 
up to order. 

1 .2. TH E EUCLI DEAN ALGORITH M 
1 7  
This says that even though there may be several ways of ordering the 
primes that go into a factorization (30 = 2 · 3 · 5 ·  5 = 5 · 3 · 5 · 2), we cannot 
change the primes that appear. As obvious as this theorem may appear, it 
actually says something that is significant, a fact that was driven home in 
the nineteenth century when mathematicians began to use extended 
integers such as numbers of the form m + n .../TO, where m and n are 
ordinary integers. Integers such as these underlie the theory that explains 
the algorithm (mentioned in Section 1.0) for testing whether or not 2n - 1 is 
prime. 
Like ordinary integers, these extended integers form a set that is closed 
under addition, subtraction, and multiplication. We can also apply the 
notion of divisibility: 12 + 3 .../TO is divisble by 2 + .../TO because there is an 
extended integer that we can multiply 2 + ../10 by to get 12 + 3 .../TO: 
(2 + .../10)(1 + .../10) = 12 + 3 .../10 . 
In Exercise 1.22 you will be asked to prove that 2, 3, 4 + ../10, and 
4 - .../TO cannot be written as products of smaller extended integers - thus, 
they are analogous to primes in this system. But factorization is not 
unique! Here are two factorizations of 6: 
6 = 2 . 3 = ( 4 + .../10)( 4 - .../10) .  
Proof of Theorem 1. 11. We use induction. The base case is n = 2; but 2 is 
prime and so can be factored in only one way: 2. Suppose every integer 
strictly between 1 and n has unique factorization. To prove it for n, suppose 
it fails. So 
where the Pi and Qj are primes that are not necessarily distinct, but where 
the second factorization is not simply a reordering of the first. If p1 were 
equal to any of the qj , then we could divide each product by p1 to get an 
integer smaller than n with nonunique factorization. So p1 is relatively 
prime to each Qj · We now invoke Proposition 1.10. We know that p1 divides 
n and so it must divide q1 q2 · . .  q8• But P1 is relatively prime to q1 , so it must 
divide Q2 . .  · Q8 • But p1 is also relatively prime to Q2 , so it divides q3 · · · q8 • 
Continuing to the end we see that p1 divides q8 , a contradiction. 
o 
The most common use of the fundamental theorem is to represent an 
integer in the form pC' pD2 · · ·PE' where the Pi are prime and ai ;;: 1. 
Mathematica's internal factoring algorithm finds such factorizations for 
modestly sized integers, or large integers that have only small factors. 
Factorinteger [ 3 5 1 13 1 5 1674694 180853418027 5 ] / /  ractorForm 
3 11 52 472 5 4 12 7 9 1 9  1 5 4 8 5 8 6 3  

1 8  
1 .  FUNDAM ENTALS 
 Two Applications 
Here are two more applications of the ideas of gcd and the Fundamental 
Theorem of Arithmetic. 
Irrational Numbers 
A real number that can be expressed as a ratio of integers, such as 3/s or 
22'7 , is called a rational number. Nonrational numbers are irrational. 
The first irrational number, in the sense that it was the first number to be 
proved irrational, is ../2. This discovery, by the Pythagoreans in 500 BCE, is 
extremely important, for it showed the world that irrational numbers do 
exist. 
Theorem 1.12. The square root of 2 is irrational. 
Proof. We will need the fact that if s is a square, then all primes in s occur 
to an even power, which is an easy consequence of the fundamental theo­
rem because (pa)2 = p2a . Now, assume that {2 can be written as m / n  
where m and n are integers. Then 2 n2 = m2 • But the power of 2 in m2 is 
even, while the power of 2 in 2 n2 is odd. Contradiction. 
D 
In fact, ..rn is irrational whenever n is a nonsquare (Exercise 1.25). 
Pythagorean Triples 
The next application involves Pythagorean triples, triples of integers that 
satisfy :x?- + y2 = z2 ,  and a truly ancient algorithm for finding them. Without 
loss of generality, we can assume that x, y, and z are positive and share no 
common factor. Such a triple is called a primitive triple. 
The most famous Pythagorean triples are (3, 4, 5) and (5, 12, 13). The 
triple (6, 8, 10) is Pythagorean, but is not a primitive triple, because it is 
obtained by multiplying (3, 4, 5) by 2. If we want to find all Pythagorean 
triples, it is sufficient to first find all primitive triples and then take multi­
ples of them. The following proposition shows how to generate all primitive 
triples. 
Proposition 1.13. For any pair of relatively prime integers, (m, n), such 
that one of them is odd, the other is even, and m > n > 0, the three numbers 
(m2 - n2 , 2 m n, m2 + n2 ) form a primitive triple. Furthermore, every primi­
tive triple is of this form. 
Note that (3, 4, 5) corresponds to m = 2, n = 1, while (5, 12, 13) comes 
from m = 3, n = 2. 
Proof. Simple algebra verifies that the triple in question is Pythagorean. 
You should verify for yourself that (2 m n)2 + (m2 - n2 )2 = (m2 + n2 )2 . We 

1 .2. T H E  EUCLIDEAN ALGORITHM 
1 9  
leave the proof that the triple has no factor in common as an exercise. The 
more interesting part of this result is that there are no other primitive 
triples. 
Let (x, y, z) be a primitive triple. Because x, y, and z are not all even, at 
most one of them is even. If x and y are both odd, then x2 and y2 are each 
one more than a multiple of 4 (because (2k + 1)2 = 4 k2 + 4 k  + 1) and so 
x2 + y2 must be 2 more than a multiple of 4. But that says that z2 is divisi­
ble by 2 and not by 4, a contradiction to Proposition 1.10. Thus one of x or y 
must be even. By symmetry in x and y, we can assume that it is y that is 
even, say y = 2 k, and x and z are odd. 
We can solve for k2 • 
z2 - x2 
z - x  z + x 
k2 = -- = -- --
4 
2 
2 
Because x and z are odd, (z - x) I 2 and (z + x) I 2 are integers. Furthermore, 
they must be relatively prime because any common divisor would have to 
divide both their sum (which is z) and their difference (which is x), and we 
assumed that x and z have no common divisors. 
Each prime p that divides (z - x) / 2 also divides k2 , and so p2 divides k2 • 
Because p does not divide (z + x) / 2, p2 must divide (z - x) I 2. Thus the 
prime factorization of (z - x) / 2 will have only even exponents, which is 
another way of saying that (z - x) / 2 is a perfect square. Similarly, (z + x) I 2 
must be a perfect square. Let us write 
z + x  
2 and 
-2- = m  
z - x  
2 
-- = n  
2 
As we have just shown, m and n are relatively prime. Because m2 + n2 = z is 
odd, one of m or n  is odd and the other even. Also, m > n. We now solve for 
x, y, and z. 
z = m2 + n2 
y = 2 m n  
x = m2 - n2 o 
The characterization is easy to program. Indeed, we can immediately 
get a giant triple as follows. 
{m2 - n2 , 2 m n, m2 + n2 } I .  {m -+ 1010 + 1 , n -+ 1010 } 
{ 2 0 0 0 0 0 0 0 00 1 , 2 0 0 0 0 0000020000000000 , 2 0 0 0 00000020000000001 } 
Going from the generators to the triples and vice versa are excellent 
programming exercises, and more specific instructions are given in Exercise 
1.28. When one generates tables of triples, several patterns jump out, and a 
few are mentioned in Exercise 1.29. 

20 
1 .  FUNDAMENTALS 
A computational problem of a diferent sort comes from trying to visual­
ize the triples. One approach is to view the generators as points in the m-n 
plane; such an image is given in Figure 1.3. The transformation from the 
generators to the actual triples is left to the viewer's imagination. 
5 
1 0  
1 5  2 0  2 5  
3 0  3 5  4 0  4 5  
5 0  
Figure 1.3. A view of the Pythagorean triples. Each dark square represents a pair 
(m, n) that is a generator of a primitive triple. 
A much more fruitful way of viewing the triples comes by observing 
that the central relationship, a2 + b2 = c2 ,  can be viewed as (a/ c)2 + (b / c)2 = 
1. This can be viewed as a relationship between two rational numbers: 
r2 + s2 = 1. Thus a Pythagorean triple corresponds to a point on the unit 
circle, both of whose coordinates are rational; such a point is called a ra­
tional point. Note that a triple and any multiple of it correspond to the 
same rational point - the multiplier disappears in the fraction - so this 
point of view is somewhat purer than the integer context. 
Here is some code to turn a triple into a rational point and then to look 
at the rational points corresponding to the first n triples. It uses the pack­
age function PythagoreanTriples [ n ) ,  which generates the first n primi­
tive triples. 
RationalPoints [n_] 
• -
Pytbagorean'Jriples [n , UseGridBox Ա False] / .  
{ a_ , b_ ,  c_} >+ { a  I c ,  b I c} 
RationalPoints [ lO] 
{ { 
3 
4 } { 
5 
12 
8 
15 
7 
24 
20 
21 
s ' s
,
 rr ·  rr l ·  { rr ·  rr l ·  { 25 '  25 } , { 29 '  29 } • 
{ 
9 
40 } { 12 
35 
11 60 
28 45 
3 3  
56 
41 '  41 I 
Ti '  Tf } ' { 6T '  61 } ' { 53 •  TI } ' { 65 '  65 } }  

1.2. TH E EUCLIDEAN ALGORITH M 
21 
Because a < b in our setup, these points will lie only on a 45° arc of the 
circle. Symmetry and/or negatives will fill up the circle. Figure 1.4 shows 
the first 15 triples and then 400 of them. The natural question is whether 
these points are dense. There are two regions where the rational points 
seem rare: near (0, 1) and near ( 3/s , 4/5 ). Exercise 1.27 addresses these 
questions, and in a constructive way, so that, for example, a triple that is 
very "close" to (3, 4, 5) can be found. 
Figure 1.4. The Pythagorean triples viewed as rational points on the unit circle . 
The upper diagram shows the points corresponding to the first 1 5  triples, while the 
lower one is a close-up of the image of the first 400 points. There seem to be two 
gaps, one near (0, 1) and the other near ( 3/s ,  4/5 ), but these gaps disappear eventu­
ally because the set of rational points really is dense in the circle . 

22 
1. FU NDAMENTALS 
Exercises for Section 1 .2 
1.8. Complete the proof of the division algorithm by showing that, given 
integers a and b with b -:/:  0, and then defining r to be the smallest element 
of {a - qb : q E Z, a - q b d 0} leads to a pair, r and q, that satisfies the 
conclusion of the division algorithm. Moreover, there is a unique pair r, q 
that works. 
1.9. Let d = gcd(a, b). Prove that a/ d and b /d are relatively prime. 
1.10. Prove that lcm(a, b) = ab/gcd(a, b). This can be done by appealing to 
the fundamental theorem of arithmetic, but it is more elegant to avoid 
prime factorizations. Find such a proof as follows. Let d = gcd(a, b). 
(a) Show that ab Id is an integer and is a multiple of both a and b. 
(b) Let n be any common multiple of a and b, say n = ar = bs. Prove that 
a/d is relatively prime to b/d and therefore a/d divides s, say s =  (a/d)t. 
Prove that ab/d divides n. It follows that ab/d is the least common multi­
ple of a and b. 
1.11. Write a program that accepts a list of integers and returns True if 
the entries are pairwise relatively prime, and False otherwise. Important: 
Try to find a way of doing this that avoids checking all pairs from the list 
and avoids factoring the inputs. 
1.12. The recursive definition of gcd can run into problems, because Mathe­
matica has built-in recursion limits. Thus, if the recursion involves too 
many steps an error will result. It is generally better to use traditional 
iterative programming, as exemplified by the following routine based on a 
While loop. The parentheses group the three sentences of the program into 
a single compound sentence. 
gcditerative [ a_, b_] : = ( { aa , bb} = { a ,  b } J 
While [ bb # O ,  { aa ,  bb} = {bb ,  Mod [ aa ,  bb ] } ]  J aa) 
Alternatively, it is a little faster to use the matrix formulation as 
described in Algorithm 1.2. 
gcditerative [ a_, b_] : =  (r = { a ,  b } J 1fhile [ r [2:n # O ,  
q = Apply [Quotient , r] J r =  { { O ,  l } ,  { l , - q} } . r ] J 
r[l] )  
gcditerative [ 97 , 1 8 ]  
1 
Compare the timing of the recursive and iterative approaches on pairs 
of large Fibonacci numbers. To get reasonable timings you may wish to 
repeat a calculation 100 or times, via Do [ ... , { 1 0 0 } ] .  Find such a pair for 
which the recursive method fails. 

1 .2. TH E EUCLIDEAN ALGORITH M 
23 
1 .13. Investigate the question: What percentage of random pairs of inte­
gers are relatively prime? For example, look at a couple of thousand ran­
dom pairs between 1 and 106 and compute the percentage that are rela­
tively prime. The theoretical probability (defined as a limit as the bounds 
approach infinity, because the notion of a random integer between 1 and 
infinity does not make sense) turns out to be a very simple number involv­
ing 7r2 ; use the results of your experiments to try to find this formula. Use 
Random [ Integer , { a , b }  ] to get a random integer between a and b. 
1 . 14. Here is a recursive routine to compute the length of the Euclidean 
algorithm sequence. 
EALengtb [ a_, b_] : =  I f [b == O ,  0, l + EALengtb [ b ,  Mod [ a ,  b] ] ] 
EALengtb [ 97 , 1 8 ]  
5 
Turn this into an iterative routine, avoiding recursion. Investigate 
Euclidean algorithm lengths for a variety of inputs. Look at the average 
length of the sequence, over hundreds of samples. A result of H. Heilbronn 
[Knu, §4.5.3, Exercises 33, 34] says that there is a constant c such that the 
average length of this sequence is asymptotically equal to c times the 
length of the input. More precisely: the average length over all inputs less 
than M divided by log10 (M) approaches c as M -+ oo . Do some computations 
to make an estimate of c. For comparison, recall that the worst-case behav­
ior is about 4.78log10(M). Generate some graphics to illustrate the conver­
gence to c. (Warning: The convergence is a little slow. It is better to try 
large random inputs than to look at all integers under some bound.) 
1.15. Work out the proper definition and implementation of a continuant 
function when the starting point - the gcd of a and b - is greater than 1. 
1 .16. Write a function FullQ to turn a quotient sequence into the entire 
remainder sequence. 
1.17. Algorithm 1.2 outputs only the final s- and t-values. Write a program 
that accepts a and b as input and generates the entire s- and t-sequences 
corresponding to the Euclidean algorithm for a and b. The output should 
give the sequences in the terms of two lists, one for the s-values, one for the 
t-values. 
1 .18. Let a, b, Tk, Qk, Sk, tk be as in the discussion of the extended Euclid­
ean algorithm, and let n be the number of steps, so that Tn = gcd(a, b). 
(a) Prove that Tk = Sk a + tk b. (Use induction and the definition of Sk and tk.) 
(b) Prove that the signs of the s- and t-sequences alternate. (Use induction 
and the definition of skand tk.) 
(c) The complete s- and t- sequences, when viewed in reverse and ignoring 
the minus signs, are Euclidean algorithm remainder sequences starting 
from b and a, respectively. (Use the defining equations of s and t. Then 

24 
1 .  FU NDAM ENTALS 
observe that the quotients are the same, and so the continuant reversal 
phenomenon (Theorem 1.5) can be used.) Note one small exception: If 
b > a/ 2, then the reversed t-sequence is a remainder sequence provided the 
initial 0 and 1 are ignored.) 
(d) 
Prove, under the assumption that gcd(a, b) = 1, that lsn+1 I = b and 
ltn+1 I = a. (Use (c).) 
(e) Prove that sktk+l - tkSk+l = (-l)k (Induction.) 
(f) Prove that gcd(sk, tk) = 1 if k > 1. 
1.19. Prove that in the system of extended integers of the form m + nm, 
3 + m divides 1 and therefore it divides every integer. Such a number is 
called a unit. 
1.20. Prove that in the system z[ m] of extended integers of the form 
m + nm, a + b m divides 1 if and only if a2 - 10 b2 = ± 1. It is useful to 
define the norm of one of these objects, N( a + b m ), to be ( a2 - 10 b2 ). 
Then this exercise can be rephrased as if a E z[ m], then a divides 1 if 
and only if N(a) = ± 1. 
1.21. 
Prove that if a + b m divides m + n m, then a2 - 10b2 divides 
m2 - 10n2 • 
1.22. Prove that there are no integers a and b for which a2 - 10b2 = 2, -2, 
3, or -3. Hint: First show that every perfect square is either a multiple of 5, 
1 more than a multiple of 5, or 1 less than a multiple of 5. 
1.23. Prove that for 2 = 2 + om, 3 = 3 + om, 4 + m, and 4 - m, if 
we represent these as a product of two extended integers, then at least one 
of those extended integers must be a unit. In other words, we cannot factor 
the four given numbers any further. 
1.24. Explain why the following formula gives the power e of a given prime 
p in n!: 
Then write a program that, on input n and p, returns e. Explain how this 
can be used to predict the number of Os at the right end of n !. 
1.25. Prove that Vn is an irrational number whenever n is not a perfect 
square. (Hint: Look at the prime factorization of n and use a prime whose 
exponent is odd.) 
1.26. Show that no integer greater than 1 divides each entry of the 
Pythagorean triple (m2 - n2 , 2mn, m2 + n2 ), where m and n are relatively 
prime. 

1 .3 .  MODULAR ARITH M ETIC 
25 
1.27. Show that the set of rational points on the unit circle is dense, mean­
ing that, for any point P on the circle and any e > 0, there is a rational point 
within distance e of P. Find a rational point within distance 10-5 of 
( % ,  4/5). Hint: Let Pm,n be the rational point corresponding to the primitive 
triple whose generators are (m, n). Work out the slope of the line from Pm,n 
to (- 1, 0). The formula for this slope will be sufficient to allow you to con­
struct a rational point near any given point. 
1.28. Implement some functions to go from a primitive Pythagorean triple 
(a, b, c) to the generators (m, n) and vice versa. For example, a routine 
might accept max as input and return all the triples whose generators are 
less than max in each coordinate. Or it could return all the primitive triples 
such that c s  max. 
1.29. (a) Show that any Pythagorean triple has an entry that is divisible 
by 3. 
(b) Show that any Pythagorean triple has an entry that is divisible by 4. 
(c) Show that any Pythagorean triple has an entry that is divisible by 5. 
1 .3 Modular Arithmetic 
Much of the insight into the structure of the integers we need comes from 
an understanding of modular arithmetic. Some readers may be familiar 
with its structure and so may wish to skip this section. This is intended as 
an introduction for those who are less familiar with it. 
We begin with a postage stamp problem. Given positive integers a and 
b, which integers can and cannot be represented by ma + nb where m and n 
are nonnegative integers? In other words, what postage amounts can you 
make if you are restricted to an unlimited supply of a¢ and b¢ stamps? 
First consider the concrete example of 5¢ and 8¢ stamps. To find the 
largest amount that cannot be made, we begin by listing the nonnegative 
integers in five columns. 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
1 1  1 2  
1 3  
14 I 
1 5  
16 
17 
18 
19 
2 0  
2 1  
2 2  
2 3  
2 4  
2 5  
2 6  
2 7 
2 8  
2 9  
I 3 0  
3 1 
3 2  
3 3 
3 4  
I 3 5 
3 6  
37 
3 8  
3 9  
l 
: 
i 

26 
1 .  FUNDAM ENTALS 
If we highlight (bold in the table) the amounts that can be made, there are 
several easy, and important, observations: 
• When we can make any postage amount in any column, we can also 
make any larger amount in that column (just add 5¢ stamps). 
• The first number in each column that is highlighted is a multiple of 8 
(if it was not a multiple of 8, then we would need to use some 5¢ 
stamps to make it, and so we could take away one of those 5¢ stamps 
to make the number above it). 
• Each of the multiples of 8 from 0 · 8 = 0 to 4 · 8 = 32 appears in a differ­
ent column. 
When we have a multiple of 8 in each column, we can make any larger 
postage amount. The largest amount that cannot be made is the number 
directly above the last highlighted multiple of 8: 27¢ is the largest amount 
that cannot be made. Moreover, there are exactly fourteen unmakeable 
values. 
We can do the same thing with a¢ stamps and b¢ stamps. List all 
nonnegative integers in a columns that begin with 0 through a - 1. When 
we can make an amount in a given column, we can make any amount below 
it by adding a¢ stamps. And the smallest amount that we can make in any 
column must be a multiple of b. Do we always have a multiple of b in every 
column? 
A little experimentation should make it clear that the answer is NO 
whenever a and b are not relatively prime. If gcd(a, b) > 1, then any linear 
combination of a and b must be divisible by this greatest common divisor, 
and you can only make amounts in columns all of whose entries are divisi­
ble by this greatest common divisor. 
Central Question: What if a and b are relatively prime? Do the first a 
multiples of b, (0, b, 2 b, 3 b, ... , (a - 1) b), have to lie in different columns? 
You are encouraged to examine some examples. 
To answer this question, it is very helpful to switch to the terminology 
of modular arithmetic. The integers in each column share an important 
property: They each differ from the number at the top of the column by a 
multiple of a. In modular arithmetic, we take this entire column of integers, 
call it a residue class, and replace it by a single integer. Usually, this is 
the integer at the top of the column, but any integer in the column can be 
used to represent this residue class. When two integers lie in the same 
residue class, we say that they are congruent modulo a, and this is written 
using a modified equality symbol, as in: 27 = 12 (mod 5). 
The Mod command that we used at the beginning of Section 1.2 takes us 
from an integer to the top integer in its residue class. The first argument is 
the input integer and the second argument is the modulus or number of 
columns; for example, Mod [ 2 7 , 5 ]  is 2 .  
We can do arithmetic on residue classes. For the modulus 5, if we take 
any integer in the residue class of 2 and add 7 to it, we always wind up in 

1 .3 .  MODULAR ARITH M ETIC 
27 
the residue class of 9, which is the same as the residue class of 4: 
2 + 7 = 4 (mod 5). The congruence sign, =, means that the two sides differ by 
a multiple of the modulus. This also works for multiplication. If we take 
any integer in the residue class of 2 and multiply it by 9, we always wind 
up in the residue class of 3: 2 · 9 = 3 (mod 5). 
We write the symbol for congruence to look like an equality because it 
acts very much like the equality symbol. We can add congruent amounts to 
each side of a congruence: 
[ a =  b (mod m) l 
and 
č a +  e = b + d (mod m) . 
e = d (mod m) 
We can multiply congruent amounts to each side of a congruence: 
[ a =  b (mod m) l 
and 
č a · e = b · d (mod m) . 
e = d (mod m) 
We can also subtract congruent amounts from each side of a congruence. 
Division, however, must be approached with great care. We have that 
3 = 15 (mod 12) but dividing both sides by 3 is highly illegal, since 
1 ;/: 5 (mod 12). To pinpoint what goes wrong here, we need a precise defini­
tion of congruence: a is congruent to b modulo m if and only if m divides 
the difference between a and b. It is easy to check (Exercise 1.30) that if m 
divides a - b and m divides e - d, then m divides both (a + e) - (b + d) and 
a e - b d. On the other hand, if m divides a e - be, we cannot be certain that 
m divides a - b. 
Proposition 1.9 does come to our aid here with a partial solution. If m 
divides ae - be = (a - b)e and m is relatively prime to e, then m must divide 
a - b. In other words, we have yet another corollary of Proposition 1.9. 
Corollary 1.14. If ae = be (mod m) and gcd(e, m) = 1, then a =  b (mod m). 
Cancellation is always possible, provided one is careful to change the 
modulus. Here is an important rule, whose proof is left as an exercise. 
Proposition 1.15. If ae = be (mod m), then a =  b (mod m / gcd(m, e)). 
We also get some counterintuitive divisibility properties in modular 
arithmetic. For example, 3 divides 1 modulo 5 because 1 = 3 · 2 (mod 5). If 
we go back to the central question on page 26, we see that it is equivalent to 
asking if b must divide everything when b is relatively prime to the 
modulus. 
Proposition 1.16. If gcd(b, m) = 1 then b is a divisor of every residue class 
modulo m. 

28 
1 .  FU NDAMENTALS 
Proof. We shall prove that b divides 1. This suffices, because if b divides 1, 
b divides everything. So we must show that there is an integer a, called the 
multiplicative inverse of b (modulo m), such that ab = 1 (mod m). 
Because b and m are relatively prime, we can use the extended Eul­
cidean algorithm to find integers s and t such that s b + t m = 1. This implies 
that m divides sb - 1. The integer s is therefore a multiplicative inverse of b 
modulo m. 
D 
Notice that this is much more than a proof that a multiplicative inverse 
exists; the argument provides a method for finding it. The solution s might 
be negative, but a residue class is easily extended to cover negative inte­
gers. If we need a positive solution, we just add the appropriate multiple of 
m to s. 
As an example, to find the multiplicative inverse of 17 (mod 73), we 
apply the extended gcd algorithm to 73 and 17. 
BxtendedGCD [ 7 3 , 17 ] 
{ l ,  { 7 ,  - 3 0 } } 
This means that 7 · 73 - 30 · 17 = 1. So we could use -30 as a multiplica­
tive inverse of 17, or any other integer that is congruent to -30. The small­
est positive integer that is a multiplicative inverse of 17 is -30 + 73 = 43. 
Mod [ 4 3 • 17 ,  7 3 ]  
1 
And here is a simple result that allows us to paste together congruences 
modulo relatively prime factors to get a congruence modulo their product. 
Proposition 1.17. If x = y (mod m1 ) and x = y (mod m2 ), where m1 and m2 
are relatively prime, then x = y (mod m1 · m2 ). 
Exercises for Section 1 .3 
1.30. Prove that if a =  b (mod m) and c = d (mod m), then a + c = b + d (mod 
m) and ac = bd (mod m). 
1.31. Prove that if a =  b (mod m) and r is any integer, then a' = b' (mod m). 
Find an example to show that r being congruent to s modulo m does not 
guarantee that a' = as (mod m). Fixing m to be, say 11, experiment to find 
conditions on r and s that do guarantee that, for any a, a' = as (mod m). 
1.32. Prove Proposition 1.15. 
1.33. Prove Proposition 1.17. 
1.34. Find a version of Proposition 1.17 that is valid when the moduli fail 
to be relatively prime. 

1 . 3 .  MODULAR ARITH M ETIC 
29 
1.35. Binomial coefficients are critical to combinatorics, but also play an 
important role in number theory. The binomial coefficient ( Z )  is defined 
to be k!C:k>! 
• In Mathematica they are computed as Binomial [ n ,  k ]  . 
Table [ Binomial [ n ,  i ] , { n ,  0 ,  10} , { i ,  o ,  n } ] / /  ColumnForm 
{ 1 }  
{ l , l }  
{ 1 ,  2 ,  l }  
{ 1 ,  3 ,  3 ,  1 }  
{ 1 ,  4 ,  6 ,  4 ,  l }  
{ 1 ,  5 ,  1 0 , 1 0 ,  5 ,  l }  
{ 1 ,  6 ,  1 5 ,  2 0 ,  1 5 , 6 ,  1 }  
{ 1 ,  7 ,  2 1 ,  3 5 , 3 5 , 2 1 ,  7 ,  1 }  
{ 1 ,  8 ,  2 8 , 5 6 , 7 0 , 5 6 , 2 8 , 8 ,  1 }  
{ 1 ,  9, 3 6 , 84 , 1 2 6 , 1 2 6 , 8 4 ,  3 6 , 9 ,  1 }  
{ 1 ,  1 0 ,  4 5 , 1 2 0 , 2 1 0 ,  252 , 2 1 0 ,  120 , 4 5 , 1 0 , 1 }  
When arranged in a triangular array, the result lS called Pascal's 
triangle. 
Pasca1Trianqle [ 1 4 ]  
O r  
1 i  
2 I 
2 
s I 
l 
3 
a 
4 I 
4 
6 
4 
5 ! 
l 
5 
10 
10 
6 
--&1------------1---0-15---·20 -- -·-- -15- . - - -· -6 -·--· . .. 
7 I 
1 
7 
21 
35 
35 
21 
7 
8 
28 
66 
70 
56 
28 
8 
8 
9 
10 
9 
36 
84 
126 
126 
84 
36 
9 
10 
46 
120 
210 
252 
210 
120 
45 
··-··-··- --.. -------· .. --·-·-·--·---···--·----··- - -·- - - - - - - - - --- ̉ - -
-
. 
11 i 
1 1  
55 
165 
330 
462 
462 
330 
165 
55 
12 ! 
12 
66 
220 
495 
792 
924 
792 
491\ 
220 
1s I 
1 
13 
78 
286 
7 1 5  
1287 
1716 
1716 
1 287 
7 1 5  
28fi 
I 
14 i l 14 91 
364 
1001 
2002 
3003 
3432 
3003 
200:2 
1 00 1  
1 1)  
1 1  
1 
fi6 
1 2  
78 
1 3  
I 
364 
91 
14 
1 
Show that if p is prime, then every entry (except the ls) in the pth row of 
Pascal's triangle is divisible by p. 
1.36. (Erdos and Szekeres, 1978) Prove that any two entries (excluding 
the ls) in the same row of Pascal's triangle have a common factor. Amaz­
ingly, this fact was not proved until 1978. Hint: Prove the following for­
mula, and then use it to derive the result in question: 

30 
1 .  FUNDAMENTALS 
1.37. 
Suppose a and b are relatively prime, the Euclidean algorithm 
applied to a and b requires n steps, and the quotients are Qi ,  ... , Qn. Then 
the continuant reversal phenomenon (Corollary 1.5) tells us that if Q is 
applied to all initial segments of {Qn, ... , Qi } the result will be a Euclidean 
algorithm remainder sequence of the form {a, bi ,  ... }. What is the relation­
ship between bi and b? That is, given b, find (and prove) a simple formula 
that will produce 
bi . Then answer these same questions when 
gcd(a, b) = d > 1. Hint: The s- and t-sequences of the extended gcd algorithm 
play an important role in generating the desired formulas. In particular, it 
will be useful to find a formula for tn in terms of a modular inverse in the 
1.38. (Emma Lehmer) If Fn is the nth Fibonacci number, there is an 
interesting divisibility relation that holds for primes. It is not true that p 
divides Fp, but something very similar is true. Can you discover what it is? 
Does your property characterize the prime numbers? Hint: Consider the 
mod-5 residue of p. 
1 .4 Fast Powers 
Il!: A Fast Algorithm for Exponentiation 
We hope that it is evident by now that the Euclidean algorithm and the 
extended Euclidean algorithm are two of the fundamental subroutines of 
algorithmic number theory. They are built into Mathematica and virtually 
every high-level language. There is one more basic algorithm that rivals 
these in importance: fast exponentiation. 
The idea behind fast exponentiation is that if the exponent is a power of 
2, then we can exponentiate by successively squaring: 
If the exponent is not a power of 2, then we use its binary representation; 
for example, 291 = 28 + 25 + 2i + 2° 
= 256 + 32 + 2 + 1, which gets us b29i as 
follows. 
b29i 
= b256 b32 b2 b 
So we can calculate b29i with only 11 multiplications: 8 for the powers of 2 
and 3 to combine them. In general, bn can be calculated with at most 
2Llog2 nJ multiplications. 

1 .4. FAST POWERS 
31 
No one cares to compute the giant integers that arise as such powers. 
Rather, it is their values modulo m that are of critical importance to prime 
testing, factoring, and many other parts of number theory. The binary 
method just presented allows one to compute such residues efficiently 
because one can reduce modulo m at each step, and so the numbers never 
get large. This is worth repeating: Never use raw exponentiation (I') to 
compute exponents. Some languages might use logarithms, which will 
result in round-off error that can make the computation meaningless. And 
the testing of a 100-digit integer r for primality might call for examining 
2n (mod p) where n also has 100 digits. Any attempt to evaluate the exact 
integer 2<10100 > will crash your computer system, for this number has more 
binary digits than there are particles in the universe. 
The power-of-2 method described above can easily be turned into a 
precise algorithm, one that scans the binary digits of the exponent from 
right to left. It turns out that it is more efficient to scan the digits from left 
to right, using a slightly different method, and we will take that approach 
as our main exponentiation technique. 
Most computers have numbers stored in base 2, so the extraction of the 
base-2 digits is very fast. And high-level languages typically have a built-in 
function to do this. Here is how to do it in Mathematica. 
IntegerDigits [ 41 , 2 ]  
{ 1 ,  O ,  1 ,  0 ,  O ,  1 } 
So 41 = 1010012• To get b41 , start by setting ans to b and then scan the 
digits from the left, ignoring the leading 1. At each digit square ans, and at 
each 1 follow that by multiplying ans by b. Using base-2 for the exponents, 
the values in ans will be: bl , b10 , b100 , b101 , b1010 , b10100 , b101000 , b101001 ; the 
last term is b41 • If we are working modulo m, then each multiplication is 
followed by a modular reduction so that the numbers stay under m. The 
package function PowerAlgorithm allows one to watch this algorithm in 
action. 
PowerAlgorithm [ b ,  4 1 ]  
- --·-----·--- --·--1 
. Binary Digits of 41 ! Answer 
. 
I 
-
I 
1 
i 
b 
I 
r-----0 
. 
; 
b2 
i 
• 
1 
I 
! 
1 
j 
b4 
I 
i·-··-·-···· --· · ··· ----· --·--·--
---·--+--5-_j 
; 
; 
b 
I 
ߍ·--·--·-·-··-·-··-··-·-··-···-·-··--·-··-··-·-··- ݢ··-··--··-· --- -··1 
I 
0 
I 
b ' o  
; 
·-·---··-
- -· ------t·- - --·--; 
॰ 
o 
I 
b2o 
, 
: 
1 
j 
b40 
. 
I 
I 
b4 1 
I 
·--·· -- - - - - - ---·----·-·-·--··--·..L---·---··--j 
The sequence of exponents, which has the property that each one is a 
sum of two previous ones and the first term is 1, is called an addition 
chain, and that too can be generated by a package function. Further 
properties of addition chains are discussed in Exercises 1.40 and 1.41. 

32 
1 .  FUNDAM ENTALS 
Ac!ditionCbain [ 4 1 , BinaryLeft±oRigbt ] 
{ l ,  2 ,  4 ,  5 ,  1 0 ,  2 0 ,  40 , 4 1 } 
Here is the algorithm in action modulo 7. 
PowerAlgoritbm [ 3 ,  41 , 7 ]  
!- Binary Digits of _t_i . ADsWerJ 
f-- -·--· 1 
3 
i 
l 
0 
2 1 
1 
4 
5 
0 
4 
0 
2 
; 
----+-
·
- ---l 
1 
4 
i 
t------+-̜s--j 
----.] 
And here's an example with larger numbers. 
PowerAlgorithm [ 3 ,  7 9 1 8 ,  7 9 1 9 ]  
Binary Digits o f  7918 Answer · 
1 
3 
·
------·-+---' 
1 
9 
t----·----+--1 
I 
1 
1 
2 7  
i 
729 i 
21111 J 
1 0 12 1 
7598 l 
- -o
------+----9
- -4 
· 
1 
917 
2751 
1 
5356 
t------·---+---1 
230 
1----- · - · ------<----·-···-· 
1 
5386 
320 
0 
7372 
I 
1 
6206 
1---·-_-i-----+---342--
6287 
----------+---; 
1 
2640 
1 
I t----ݡ-------+------
i 
0 
! 
1 
3------ · - · - · · - · ·· ····· ··· ·-·---4---
Each nonzero bit (''bit" comes from ''binary digit") causes two opera­
tions: a squaring and a multiply-by-3. It is very common in number theory 
to want bn (mod m), where n and m are large, but b is small, often 2 or 3. 
Thus, it is noteworthy that the multiplication step involves multiplication 
by b, which, for small b, will be much faster than the multiplication of two 

1 .4. FAST POWERS 
33 
integers near m. The right-to-left method alluded to earlier involves multi­
plication of two large numbers at each multiply step, and that is why it is 
inferior to the left-to-right method (Exercise 1.39). 
Algorithm 1 .3 .  Fast Powers, Left to Right 
powermodLR [ a_, n_ , m_] : =  
Module [ { ans = a ,  dig = IntegerDigits [ n , 2 ] } ,  
Do [ ans = Mod [ ans2 , m] ; I f  [dig [i] = =  1 ,  ans = Mod [ ans * a ,  m] ] ,  
{ i ,  2 ,  Lengtb [ dig] } ] ; 
ans ] 
Setting up a Do-loop for operations on a list is not efficient in Mathemat­
ica. Rather, one should work on the list more abstractly using the concept 
of a pure function. An expression such as ( #" 2 ) & stands for the function 
that takes its argument and squares it. For functions of more than one 
argument, #1 and #2 are used for the variables. 
Fold [ f ,  1 , { 3 , 4 , 5 } ] 
f [ f [ f [ l , 3 ] , 4 ] , 5 ]  
FoldList [ U  + 3 1 2  & ,  1 ,  { 3 ,  4 } ]  
{ 1 ,  1 0 , 2 2 } 
This leads to the following alternative, faster, and shorter way of coding 
the exponentiation algorithm. 
powermodLRl [ a_, n_ , m_] : = 
Fold [ Mod [Mod [ l l  1 1 ,  m] * I f [ 1 2  = = 1 ,  a ,  1 ] , m] & ,  
a ,  Rest [ IntegerDigits [n , 2 ] ] ]  
{powermodLR [ 3 ,  4 1 , 7 ]  , powermodLRl [ 3 ,  4 1 ,  7 ]  } 
{ 5 '  5 } 
This is built into Mathematica as PowerMod. 
PowerMod [ 3 , 4 1 ,  7 ]  
5 
And very large integers can be handled easily. 
PowerMod [ lOOOOOl , 10000000 , 999999999999 ] 
39968 0 3 9 9 6 8 0  
A nifty bonus is that PowerMod accepts -1 as an exponent, in which 
case it returns the modular inverse, using the extended gcd method 
described in Section 1.3. 

34 
1 .  FUNDAMENTALS 

 Powers of Matrices 
The ideas of fast exponentiation are especially important when the item 
being raised is a matrix. All the same ideas apply, but we must use matrix 
multiplication (a dot in Mathematica) instead of normal multiplication. The 
modification to the left-to-right algorithm is very simple. 
Algorithm 1 .4. Powers of Matrices 
The following function is not built into Mathematica, but it is included 
in the CNT package. 
MatrixPowerMod [ a_ , n_ , m_] : =  
Module [ { ans = a ,  dig = IntegerDigits [ n ,  2 ] } ,  
Do [ ans = Mod [ ans . ans , m] i I f [dig [i] = =  1 ,  ans = Mod [ ans . a , m] ] ,  
{ i ,  2 ,  Length [dig] } ] i ans ] 
The powers of (̚ ̛) are interesting because they are the Fibonacci 
numbers (proved in Section 1.1). Now, suppose we wish to know the right­
most 10 digits of the 10100th Fibonacci number. The raw integer is way too 
large to compute easily, but the mod- 1010 reductions make the computation 
almost instantaneous. The following output tells us that the googol'th 
Fibonacci number ends in . .. 9560546875 (a googol is 10100). 
MatrixPowerMod [ { {  0 ,  1 }  , { 1 ,  1 } } ,  10100 , 1010 ] 
{ { 2 9 0 0 3 9 0 6 2 6 , 956054 6 8 7 5 } , { 95 6 0 5 4 6 8 7 5 , 2 4 6 0 9 3 7 5 0 1 } }  

 Big-0 Notation 
Computers are fast enough that you can calculate 37291 by multiplying 37 
by itself 290 times. They are not fast enough to be able to calculate 370050J 
by multiplying 37 by itself 1050 - 1 times. On the other hand, fast exponenti­
aton requires 11 multiplications in the first case, but only 223 in the sec­
ond. The time required is growing much more slowly. 
Big-0 notation (the "O' stands for "order of growth") is a way of describ­
ing how fast the computation time grows. Running time is measured as a 
function of the length of the input. Let us take n for the input to our algo­
rithm (though many algorithms have more than one input) and N for the 
physical length of n. Then N is typically log2 n or log10 n; the choice of base 
is irrelevant as far as the big picture is concerned. An algorithm is said to 
run in linear time if there is a constant c such that, on input n, the num­
ber of steps it takes is less than cN. For such an algorithm, if the input 
length is doubled, so is the running time. For a quadratic algorithm - that 
is, time bounded by cN2- doubling the input length multiplies the running 
time by a factor of 4. 

1 .4. FAST POWERS 
35 
An algorithm is said to run in time 0(/(N)) if there is some constant c 
so that the running time for input n is bounded by c · f(N). If f is a polyno­
mial function of N, then the algorithm runs in polynomial time, and this 
is generally good. An algorithm whose running time exceeds all polynomials 
will typically be useless on very large integers (though it can still be very 
helpful for work on small integers). For example, factorization of n by trial 
division requires up to rn trials (one needs to be able to check all prime 
divisors up to Yn). Because yn = 2C1og2n>nt2> = cv2t, this is not a polyno­
mial-time algorithm. Number field sieve methods for factorization run in 
O(Exp[K N113 (lnN)213]) for some constant K. The reader should verify that 
for any value of the constant K, Exp[K N113 (logN)213 ] grows more slowly 
than (-{2t. The rub is in that unknown constant c out front. 
Note that "steps" really refers to steps involving individual bits. Thus, 
the multiplication of two N-digit numbers, using the algorithm we all 
learned in elementary school, has time complexity 0(N2). 
Here is an example of how to estimate running times from timing data: 
the squaring of an n x n matrix. This involves n3 multiplications. We use 
100-digit integers to slow down the multiplication process and bring out 
more clearly the time increase due to the increase in n. Because the integer­
lengths are fixed, the input length is measured as a constant times the 
number of entries in the matrix, which is n2. Thus, the true complexity of 
the algorithm should be 0(N312). For simplicity, we will work with functions 
of n, instead of functions of n2, and so we will see whether an n3 complexity 
shows up. The following function squares an n x n matrix and returns the 
time only. Figure 1.5(a) shows a plot of the data as n goes from 10 to 60 in 
steps of 5. 
time [n_] : = 
(mat = 'l!able [ Random [ Integer , { 10100 , 10101 } ] , { n } , { n } ] ; 
'l!iming [mat . mat ] [l , l] ) 
data = 'l!able [ { n ,  time [n] } ,  { n ,  10,  60 , 5 } ] ; 
Time 
7 
6 
5 
4 
3 
2 
1 
_._..,,---- n 
2 0  
3 0  
4 0  
s o  
6 0  
(a) 
Time 
7 
3 
0 . 5  
O . l r 
0 . 0 3 3  ·---
n 
1 0 
2 0  
3 0  4 0  5 0 6 0  
(b) 
Figure 1.5. (a) One would expect that the time needed to square an n x n matrix 
would be proportional to n3
• The timing plot supports this. (b) A log-log plot (base 
10) of the timing data yields an approximate straight line having slope very close to 
3 [(log10 60 - log10 10) / (log10 7 - log10 0.033) = 2.9898 ... ] . 

36 
1 .  FU NDAMENTALS 
A relationship of the form y = x" becomes, when logarithms of both x 
and y are taken, logy = slogx. Thus, when a power law is suspected, one 
should look at a log-log plot to see if a straight line results. And if so, the 
slope indicates the power. In this case (Figure l.5{b)), the cubic relationship 
pops right out. In Mathematica Log [ x ]  denotes loge x; other bases are 
handled by Log [ b ,  x )  . And numerical functions such as Log apply to all 
the numbers in any level in a list, so Log [ data ) takes the logarithm of 
both coordinates. 
If we fit a line to the log-log data (this minimizes the least-squares 
error), we get a slope very close to 3. 
Fit [Log [ lO ,  data] , { 1 ,  logn} , logn ] 
- 4 . 4 9 7 1 2  + 3 . 0006 1 logn 
This indicates that the time data is close to 10-4.49712 n3·00061 , or 
0.0000318n3·00061 . In fact, the pure cubic 0.000032n3 fits pretty well, as we 
can discover by fitting a cn3 function. 
Fit [data, n3 ' D ]  
0 . 00003 1 9 0 3 7  n3 
Plot [ 0 . 000032 n3 , { n ,  5,  60} , 
Epilog -+ { PointSize [ 0 . 02 5 ] , Map [ Point , data] } ,  
AxesLabel -+ { " n " , " 'rime " } ] i 
Time 
7 
6 
5 
4 
3 
2 
1 
1 0  
2 0  
3 0  
4 0  
5 0  
6 0  n 
Figure 1.6. The timing data for squaring a matrix is very well approximated by the 
cubic function 0.000032 n3 • 
When you know the running time for a given algorithm on a given 
machine with a given input, big-0 estimates will give you an idea of how 
much you can enlarge the input and still expect a result in reasonable time 
or within the hardware capacities of your machine. By itself, it is not terri­
bly helpful in comparing two algorithms. Given an integer less than a 
million, it would be silly to try to use the number field sieve to try to factor 
it. Trial division works best. 
Having said this, we shall now try to avoid big-0 notation in this book. 
It is no substitute for a hands-on feel for how fast the algorithms run and, 
as pointed out above, it can be deceptive. But we have introduced it here 

1 .4. FAST POWERS 
37 
because it does give a useful shorthand for describing the nature of the 
superiority of one algorithm over another, and anyone who pursues algorith­
mic number theory beyond the scope of this book will find that it assumes 
increasing importance. A slower order of growth means that there will be a 
crossover point someplace. It may not be attainable with current machines 
or implementations, but some day, in some situation, the algorithm with a 
lower order of growth will demonstrate its superiority. 
Exercises for Section 1 .4 
1.39. Implement the right-to-left method of binary exponentiation (the 
computation of bn (mod m)), based on the description at the beginning of 
Section 1.4. Here is a tabular description of the basic method, with no 
modular reduction. Successive squares are stored in, say, sq. The exponent, 
e starts out being n and is divided by 2 at each step, with its parity deter­
mining what happens to the answer being built up. If e is odd, the answer 
gets multiplied by the current value of square; if e is even, nothing is done. 
PowerAlqorithm [ b ,  4 1 ,  Method -+ BinaryRigbt'roLeft] 
Exponent P&Z:!iYTiepeat:El«f.squ-are& TiD&werl 
4 1  
1 
-
- - ϋ
-
-
_
_
_
_
_
 j _
_
_ _  1-_
_
_ ߌ 
20 
0 
' 
b 2  
i 
b 
. 
---+---·-----·------··--·--- +-· -· - - · -
' 
10 
I 
0 
I 
b 4  
! 
b 
ǭ-Ǯ-----· 
_ _ _ _  1-__
_
__ --=-ϊ-----l-
_j 
I 
2 
0 
b 1 6  
b 9 
i 
1 
1 
b 3 2 ·------ ---b9- --- . 
ݟ----ݠ-------
----r----+---; 
l 
___ _ _ _ __L_ ___ _J_ ___ _ -
-
-
-
-
. 
b4 l 
' 
. 
··----·-··-__J 
AdditionCbain [ 4 1 ,  BinaryRigbtToLeft ] 
{ l , 2 ,  4 ,  8 , 9 ,  1 6 ,  32 , 4 1 }  
Compare the performance of this method to powermodLR. Note that the 
addition chains from the two algorithms are different, but they have the 
same length. A straight time comparison is a little unfair because power­
modLR uses a built-in Mathematica function to get the base-2 digits. So here 
is code that implements the left-to-right algorithm manually, thus making 
for a fairer comparison. Try these on triples (b, m, n) where b is small and 
m and n are very large, and you should see a clear victory for the left-to­
right method. Note that one often has to repeat a calculation 5 or 10 or 100 
times to get the times up into a meaningful range (1-10 seconds, say). 
powermodLRFairer [ a_, n_, m_] : = 
Module [ { ans = a , digits = { } ,  nn = n} , 
While [ DD 'I 0 1  

38 
1. FUNDAM ENTALS 
digits = { Mod [ nn , 2 ] , digits } ;  
nn = Quotient [ nn ,  2 ] ] ;  
digits = Flatten [digits ] ; 
Do [ ans = Mod [ans2 , m] ; 
I f  [digits [iD = = 1 ,  ans = Mod [ ans * a , m] ] ,  
{ i ,  2 ,  Lengtb [digits ] } ] ;  
ans ]  
A note on the code: the base-2 digits are built-up in digits in the form of a 
nested list via the { Mod [ nn ,  2 ] , digits } phrase; later, digits is flat­
tened out. This is much faster than, say, using AppendTo. 
1.40. There is one integer between 2 and 20 that has an addition chain that 
is shorter then the one provided by either of the binary methods. Find it. 
1.41. Here is another method for finding addition chains; it is a recursive 
procedure called the factor method. Explain why the following rules give a 
valid algorithm for an addition chain. Work out the factor chain for 78 by 
hand. Then write a program that implements the factor method, and com­
pare the results to the binary method. 
1. The chain for 1 is (1}; the chain for 2 is ( 1, 2}; the chain for 3 is 
{1, 2, 3}. 
2. The chain of a prime p is obtained by tacking p onto the end of the 
chain for p - 1 .  
3. The chain for n, a composite integer of the form a · b, is obtained by 
starting with the chain for a and following it with the chain for b 
with each term multiplied by a. The duplicated entry - the a at the 
end of the first part and the beginning of the second part - is 
replaced by a single a. 
Here are examples of the factor method in action on exponent 39. You 
can use these package functions to check your program. 
AclditiopCbain [ 39 , FactorMetbod] 
{ l ,  2 ,  3 ,  6 ,  12 , 24 , 3 6 ,  3 9 } 
PowerAlqori tlua [b , 39 , Method -+ FactorMetbod] 
r--·-·- -· 
--
'l'be Recarsi ve Cella . b818¥' 
{ 3 , 13 } 
2 
1 3  
I 
{ 2 ,  6 }  
{ 2, 3 } 
3 
-
2 
-
. 
. 
' 
. 
'
.
 
b 
ߋ 
'
.
 
b3· 
b' 
'bu· 
bJ4 
bJ6 
b39 

1 .4. FAST POWERS 
39 
1.42. There is an ancient method for multiplying two large numbers with­
out the use of multiliplication tables. It is sometimes refered to as Russian 
peasant multiplication. To multiply, for example, 361 x 425, we form two 
columns with the smaller number at the top of the left column and the 
larger number atop the right column. We find the numbers in the left 
column by taking half of the top entry, discarding any remainder, and 
continuing until we get to 1. We find the numbers in the right column by 
doubling the top entry and continuing until this column is as long as the 
left column. 
361 
425 
180 
850 
90 
1700 
45 
3400 
22 
6800 
11 13600 
5 27200 
2 54400 
1 108800 
We now cross out the entries on the right for which the corresponding entry 
on the left is even, and then add the remaining entries in the right column: 
361 
425 
180 
90 
45 
3400 
22 
11 13600 
5 27200 
2 
1 108800 
Answer 153425 
The last result, 153425, is the product of the original integers. Explain why 
this works. 
1.43. Carry out timing experiments to obtain a function that describes the 
time complexity of the PowerMod function, using three random n-digit 
integers as input. 
1.44. A perfect shuffle involves cutting a deck of cards exactly in half and 
then shuffling so that the cards alternate from each hand. An out-shuffle is 
a perfect shuffle in which the top card stays on top (and the bottom card 
stays on the bottom). An in-shuffle is a perfect shuffle in which the top card 

40 
1. FUNDAMENTALS 
moves to the second position. Prove that it is always possible to use a 
sequence of in-shuffles and out-shuffles to move the top card to any position 
in the deck. Show how to use the binary expansion of j to determine the 
minimal sequence of in-shuffles and out-shuffles that will move the top card 
to position j + 1. 

CHAPTER 2 
Congruences, Equations, and 
Powers 
2.0 Introduction 
The Euclidean algorithm is the foundation of many important computa­
tional ideas. In this chapter we show how it can be used to solve certain 
Diophantine equations (meaning: equations where solutions in integers 
only are desired). Two other critical foundational results are the Chinese 
Remainder Theorem for solving certain systems of congruences and 
Fermat's theorem on powers modulo a prime. His theorem is the basis of 
some simple tests for primality, and that is pursued in the section on 
pseudoprimes. 
2.1 Solving Linear Congruences 
ߊ Linear Diophantine Equations in Two Variables 
A Diophantine equation, named after Diophantus of Alexandria (c. 250 CE) 
refers to any equation for which solutions in integers are sought. The most 
famous example is Fermat's Last Theorem, recently proved by Andrew 
Wiles, which says that, if n > 2, there is no integer solution to x" + y" = z" 
except for the trivial solution where x, y, or z is 0. Another very famous 
Diophantine equations is Catalan's equation: xa - yb = 1; the only solution 
known is 32 - 23 = 1, and it is suspected that there are no others. Diophan­
tine equations have a long history in the area of recreational mathematics, 
where puzzles such as the following are common: Suppose a piggy bank has 
37 coins, all of which are nickels, dimes, and quarters, with at least one 
coin of each type. If the total value of the coins is $2.25, then how many 
coins of each type are in the bank? In this section we discuss a method for 
getting a complete solution to a linear Diophantine equation. The algorithm 
will make short work of puzzles such as the one just given. 
Although the general problem of solving Diophantine equations is 
extremely difficult, a comprehensive theory has been developed to handle 

42 
2. CONG RU ENCES, EQUATIONS, AND POWERS 
the case of one or more linear equations, and our work with the Euclidean 
algorithm in Chapter 1 gives us a method for dealing with the simplest 
case, where the equation is linear and involves only two variables. Such 
equations have the form ax + by = c. 
Proposition 2.1. Consider the equation ax + by = c and let d = gcd(a, b). If 
d does not divide c, the equation has no solution in integers. If d divides c, 
then there are infinitely many solutions, which are obtained as follows. A 
particular solution is given by (xo, Yo) =  (cs/d, ct/d), where s and t are the 
result of the extended Euclidean algorithm on the pair a, b. The general 
solution then has the form x = Xo + (b Id) n, y = Yo - (a Id) n, where n is any 
integer. 
Proof. For a solution to exist, d must divide c, since d divides a and b. If d 
does divide c, then the extended Euclidean algorithm (Section 1.2) yields 
integers s and t such that sa + t b = d. Because c / d is an integer, multiplica­
tion by c/ d yields a(c/d)s + b(c/d)t = (c/ d)d = c, and thus we have our first 
solution, Xo = cs Id and Yo = ct Id. 
For the general case, we use the common algebraic technique of first 
studying the equation (called a homogeneous equation) with 0 as the 
right side. One solution is (bn, -an), but a better solution is 
((b/d)n, -(a/d)n), because any solution is a multiple of this last one. For 
suppose ax1 + by1 = 0. Then (a/d)x1 + (b/d)y1 = 0, so (a/d)x1 = -(b/d)Y1 · 
But a/d and b/d are relatively prime (Exercise 1.9), so a/d divides -y1 
(Proposition 1.9), say -y1 = n(a/d). Substituting into the equation relating 
x1 and y1 yields x1 = bn/d, completing the analysis of the homogeneous 
equation. 
Now suppose (x2, y2) is a solution to the general equation. Then it is 
easy to check that (x2 - x0, y2 - y0) satisfies the homogeneous equation, and 
so there is an n such that x2 - xo = bn/d and y2 - Yo = -na/d. But this is 
the desired representation of (x2, Y2 ). 
D 
The preceding proof yields an algorithm to solve linear Diophantine 
equations in two variables. 
Algorithm 2 . 1 . The Diophantine Equation a x  + b y =  c 
The code that follows uses the built-in ExtendedGCD function to implement 
the algorithm of the preceding proof. The setup requires one parameter, 
which is used to represent the infinite family of solutions. An alternative 
approach would code the output in the form of a 2 x 2 matrix. 
DiopbantineSolve [ { a_ ,  b_} , c_, n_] : = Module [ { d ,  e } , 
{ d ,  e }  = BxtendedGCD [ a ,  b] " 
I f [Mod [ c ,  d] == O ,  
'rranspose [ { c e , { b ,  - a } } / d] . { l ,  n} , { } ] ]  

2 . 1 . SOLVI NG LI N EAR CON G RUENCES 
43 
gen = DiophantineSolve [ { l3 ,  5 1 } , 500 , n ]  
{ 2 0 0 0  + 51 n, - 500 - 1 3  n } 
Note that the numbers are quite large. A change of variable of the form 
n -+ n - 39 will reduce the size of the coefficients, where 39 is obtained as 
the nearest integer to 20001s1 . 
gen = Bxpand [ gen 1 . n -.  n - 3 9 ]  
{ 11 + 5 1  n , 7 - 1 3  n }  
And here are some explicit solutions. 
Table [ gen , { n , 1 ,  5 } ]  
{ { 6 2 , - 6 ) , { 1 1 3 ,  - 1 9 ) , { 1 6 4 , - 32 ) , { 2 1 5 ,  - 4 5 ) , { 2 6 6 ,  - 58 ) )  
« Linear Equations in Several Variables 
There is a well-developed theory for solving linear Diophantine equations, 
and even systems of such equations can be handled. Exercise 2.4 shows how 
one linear equation in many variables can be handled by a method that 
reduces the number of variables until two are left. The CNT package con­
tains LinearDiophantineSolve, which implements this idea. Here is 
how it can be used to solve 2x + 3y + 4z + 5w = 20. 
LingaԮDioehanting&olvԯ [ { 2 ,  3 ,  4 ,  5 } , 20] I I  MatrixForm 
0 
1 
0 
0 
0 
0 
1 
0 
- 2 0 
2 
3 
5 
2 0  
- 2 
- 3 
- 4 
The matrix represents the general solution in that the first column is a 
particular solution while the other three columns form the general solution 
to the homogeneous equation 2x + 3y + 4z + 5 w = 0. Thus multiplying the 
matrix by { 1, n, m, r} yields the complete representation of the general 
solution. 
LinearDioehantineSolve [ { 2 ,  3 ,  4 , 5 } , 20 ] . { l ,  n ,  m ,  r }  
{ n ,  m, - 2 0 + 3 m + 2 n + 5 r , 2 0 - 3 m - 2 n - 4 r } 
LinearDiophantineSo lve contains an appeal to Mathematica's 
standard Algebra '  Inequali tySol ve ' package to solve the inequalities 
that arise when the solutions are restricted to be positive or nonnegative. 

44 
2. CONG RUENCES, EQUATIONS, AND POWERS 
Here is the complete list of all solutions to the sample equation subject to 
the constraint that no negative numbers appear. 
LiD!i!A԰iogbADUn12Sol ve [ { 2 ,  3 ,  4 ,  5 } , 20 , 
Solution'lype -+  HonHegative] 
{ { O ,  0 ,  0 ,  4 } ,  { O ,  O , 5, O } ,  { O ,  1 ,  3 ,  1 } ,  { O , 2 ,  1 ,  2 } ,  
{ O , 4 ,  2 ,  0 } ,  { O ,  5, 0 ,  1 } ,  { 1 ,  O , 2 ,  2 } ,  { 1 ,  1 ,  O , 3 } ,  
{ 1 ,  2 ,  3 ,  0 } ,  { 1 ,  3 ,  1 ,  1 } , { 1 ,  6 ,  O , 0 } ,  { 2 ,  O , 4 ,  O } ,  
{ 2 ,  1 ,  2 ,  1 } ,  { 2 ,  2 ,  0 ,  2 } , { 2 ,  4 ,  1 ,  0 } ,  { 3 ,  O , 1 ,  2 } ,  
{ 3 , 2 ,  2 ,  0 } , {3, 3 ,  O , 1 } ,  { 4 ,  O , 3 ,  0 } ,  { 4 ,  1 ,  1 ,  1 } ,  
{ 4 ,  4 , 0 ,  0 } ,  {5, 0 ,  O , 2 } , { 5 ,  2 ,  1 ,  O } , { 6 , 0 , 2 , 0 } ,  
{ 6 ,  1 ,  O , 1 } ,  { 7 ,  2 ,  O , O } , { 8 ,  O , 1 ,  0 } ,  { 1 0 ,  0 ,  0 ,  O } } 
The function also allows the specification of additional assumptions, so that 
certain common problems can be easily solved. For example, recall the 
problem mentioned at the beginning of this section: A piggy bank has 37 
coins, all of which are nickels, dimes, and quarters, with at least one coin of 
each type. If the total value of the coins is $2.25, then how many coins of 
each type are in the bank? We could look at all positive solutions and 
Select the ones for which x + y + z = 37, but the function can do that for us. 
good [ x_] 
: =  Apply [ Plus , x] 
== 37 
solutions = LingarDioghAntineSolye [ { 5 ,  10 , 2 5 } ,  225 , 
Solution'l'ype -+ Positive , Assumptions -+ good] 
{ { 3 2 , 4 , 1 } } 
ȭ Linear Congruences 
The notion of modular inverses makes short work of solving congruences 
such as 7x = 2 (mod 17). Just multiply both sides by the mod-17 inverse of 7. 
PowerMod [ 7 , - 1 ,  17 ] 
5 
So 2 · 5, or 10, is a solution, and indeed 7 · 10 = 2 + 68. But this method 
requires the inverse. In fact, the congruence can be solved whether or not 
the inverse exists. 
Proposition 2.2. Consider the modular equation ax = b(modm), where a, 
b, and m are integers with m > 0. 
(a) If gcd(a, m) = 1, then the equation has the solution a-1 b, where the 
inverse is modulo m; the solution is unique modulo m. 
(b) If gcd(a, m) fails to divide b, then the equation has no solutions. 
(c) If d = gcd(a, m) and d divides b, then there are exactly d incongruent 
solutions modulo m. 

2.1 . SOLVI NG LI N EAR CONGRUENCES 
45 
Proof. 
(a) It is clear that a-1 b is a solution. And if x0 satisfies 
axo = b (mod m), then a-1axo = a-1 b (mod m), and xo = a-1 b (mod m) as 
claimed. 
(b) If x0 is a solution, then ax0 = b + km for some k, and so gcd(a, m) must 
divide b. 
(c) The congruence ax = b (mod m) is equivalent to the Diophantine equa­
tion ax + km = b, and so we may apply Proposition 2.1. Therefore solutions 
for x are given by x0 + (m Id) n. Two such solutions are congruent modulo m 
if and only if (m /d)n1 = (m/ d)n2 (mod m). But, by Proposition 1.15, this is 
equivalent to: n1 = n2 (mod m I gcd[m, m Id]), which reduces to n1 = 
n2 (mod m I (m I d)), or n1 = n2 (mod d). This means there are d incongruent 
solutions, obtained by letting n run through the residue classes modulo d. o 
Solving a single linear congruence in one variable is essentially the 
same problem as solving a single linear Diophantine equation in two vari­
ables, and is easy to implement. A function in the CNT package does the job. 
Here is how to solve 6123123x = 6123123123 (mod 9123123123123). 
LinearConqruenceSolve [ { 6123 123 , 6123123123 } ,  9 1 2 3 1 2 3 1 2 3 1 2 3 ]  
{ 2 2 8 2 5 0 3 5 3 1 9 3 8 , 5 3 2 3 5 4 4 5 7 2 9 7 9 , 8 3 6 4 5 8 5 6 1 4 0 2 0 } 
Mathematica's LinearSolve function can be coaxed to work modulo m, 
and can handle linear systems where the number of unknowns equals the 
number of equations. Ordinarily LinearSolve [ A ,  c ]  solves the linear 
system Ax = c. If the Modu lus option is used it works modulo m. 
v = LinearSol ve [ 
A = { { 5 ,  1 0 ,  3 } , { 1 ,  1 ,  1 } ,  { 1 ,  2 ,  5 } } ,  { 1 ,  2 ,  3 } ,  Modulus -+ 53 ] 
{ 2 7 , 3 7 , 4 4 } 
Mod [A . v ,  5 3 ]  
{ 1 ,  2 ,  3 } 
One can also appeal directly to Solve; this approach fails for large 
integers, but has the advantage that quadratic and higher equations can be 
handled. 
{ x ,  y, z }  I .  Solve [ { 
5 x + 10 y + 3 z == 1 ,  
x + y + z = = 2 , 
x + 2 y + 5 z == 3 ,  Modulus = =  5 3 } , x ]  
{ { 2 7 '  - 1 6 ,  - 9 } } 
x I . Solve [ { 5 x3 + x2 = =  17 , Modulus == 7 9 19 } , x ]  
{ 1 1 0 1 , 5 6 2 1 ,  7 5 3 2 } 

46 
2. CONG RUENCES, EQUATIONS, AND POWERS 
Mod [ 5 x3 + x2 I .  x -+  { 1 101 , 562 1 ,  7 532 } ,  7 9 1 9 ]  
{ 1 7 , 1 7 , 1 7 } 
­ The Conductor 
A special type of Diophantine problem concerns the collections of numbers 
that can be represented by a certain formula. For example, if one asks for 
the set of integers represented by 6x + 9y + 20z, one has the Chicken McNug­
get® problem mentioned in Exercise 2.8. There are many fascinating prob­
lems of this form; for example, it is unsolved whether every fraction 4 / n 
has the form 1 / x + 1 / y + 1 / z. For this sort of problem, even the general 
linear case is quite dificult. However, the 2-variable case is not hard. Given 
a and b with gcd(a, b) = 1, there is always a point beyond which every 
integer is representable as ax + by. The least such point is called the con­
ductor of a and b. For example, it is not hard to see that 2 and all greater 
integers are representable as 2x + 3y with nonnegative x and y, while 1 is 
not so representable. So conductor[2, 3] = 2. 
Before studying the following proof, the reader should review the 
postage stamp problem at the beginning of Section 1.3. Indeed, the conduc­
tor problem also has its history in a problem of postage stamps, because it 
answers the question: Given denominations a and b, which postage 
amounts are feasible? The following table from Section 1.3 shows which 
denominations are representable (in bold) using 5¢ and 8¢ stamps. 
--
. 
0 
5 
10 
1 
6 
1 1  
1 5  J 16 
20 t 2 1  
1 2s 26 
I 30 
3 1  
! 3 5  
I 
: 
36 
L _ _  :_ 
2 
3 
4 
7 
8 
9 
1 2 
13 
14 
1 7 
18 
19 
2 2  
2 3  24 
2 7  2 8  2 9  
·--·-
32 
33 
3' 
--
37 
3 8  
3 9  
i 
Theorem 2.3. If a and b are relatively prime and positive, then the conduc­
tor of a and b is (a - l)(b - 1). 
Proof. We need several facts: 
• If a and b are relatively prime, then in each residue class modulo a, 
the smallest positive integer that can be represented by ax + by, x 
and y nonnegative integers, must be a multiple of b (otherwise sub­
tract a; in the table these multiples are 0, 16, 32, 8, and 24). 
• When we can find an integer in a given residue class modulo a that is 
representable by ax + by, then any larger integer in that residue 

2. 1 .  SOLVING LI N EAR CONGRUENCES 
47 
class is also representable (just add multiples of a). 
• If a and b are relatively prime, then Ob, 1 b, ... , (a - l)b lie in different 
residue classes modulo a (Exercise 2.24). 
These facts tell us that the residue class that contains (a - l)b is the resi­
due class with the largest integer that cannot be represented. This nonrepre­
sentable integer is (a - l)b - a, and so the conductor of a and b is 
(a - 1) b - a + 1, or (a - l)(b - 1). In the table, this is 27 + 1, or 28. D 
To completely understand the set of representable positive integers, we 
must also figure out what happens below the conductor. Exactly half of the 
integers between 0 and the conductor are representable (Exercise 2.7). 
The conductor of any finite set of pairwise coprime positive integers 
always exists (Schur's theorem; see [Wil]). The CNT package contains an 
algorithm for the conductor of three integers. The algorithm cannot handle 
all cases, but it can do some. For example, 197 is the largest integer not of 
the form 12 x + 19y + 31z. 
Conductor [ { l2 ,  19 , 3 1 } ] 
1 9 8  
« An Important Quadratic Congruence 
For any m, 1 and m - 1 are solutions to a2 = 1 (mod m); this is just a restate­
ment of (± 1)2 = 1. A very important fact is that for prime moduli there are 
no other solutions. 
Proposition 2.4. If p is prime then the only solutions to x2 = 1 (mod p) are 
1 and p - 1. 
Proof. Suppose a is its own inverse modulo p. Then a2 - 1 = 0 (mod p), 
whence p divides a2 - 1. But then p divides (a - l)(a + 1) so, by Corollary 
1.10, either p divides a - 1 or p divides a + 1. But this means that 
a = ± 1 (mod p). 
o 
Exercises for Section 2.1 
2.1. Modify the code of Algorithm 2.1 so that it performs a change of vari­
able in an attempt to make the integers in the output small. 
2.2. A van that can hold no more than 20 people ferried a group of travelers 
to a train station, making five trips and taking an equal number of people 
in each group. Then they were joined by 7 people who walked over, and all 
were evenly divided among 14 railroad cars. How many people were travel­
ing? Use the algorithm of the text, working out the details by hand. 
2.3. Find a two-digit number such that the digit in the ones place times 8 
is thirteen less than the digit in the tens place times 3. 

48 
2. CONG RUENCES, EQUATIONS, AND POWERS 
2.4. (a) Implement an algorithm that uses the ideas of Algorithm 2.1 to get 
a parametric representation of all solutions of ax + by +  cz = B. Use an 
inductive approach by letting w represent (b I d)y + (c I d)z where d = 
gcd(b, c) and solving ax + d w = B. Then use the representation of w that 
this solution yields - it will involve a parameter, say n 
- to solve the 
original problem by solving (b/d)y + (c/ d)z = w. Because b/d and c/d are 
relatively prime, the fact that w involves n is not an obstacle. 
(b) Use part (a) to solve 5x + lOy + 25z = 100. Then use the solution to find 
out how many ways one can make change for $1.00 using nickels, dimes, 
and quarters. 
(c) Use recursion to extend the ideas of part (a) to apply to a general linear 
Diophantine equation a1x1 + a2x2 + · · ·  + anXn = B. There are well-developed 
methods based on linear algebra to solve Diophantine systems of n linear 
equations in m unknowns; see [NZM, §5.2]. 
2.5. A good argument can be made that the following puzzle, whose first 
appearance was in an article by Ben Ames Williams in the Saturday 
Evening Post in 1926, is one of the most studied Diophantine problems in 
history! The magazine received 20,000 solutions. 
Five sailors on an island gather a pile of coconuts and decide to divide 
them among themselves the next day. During the night, one of the sailors 
awoke, counted the coconuts, gave one to the monkey that was hanging 
around camp, and took exactly 1/5 of the rest for himself. Later that night, a 
second sailor awoke and did exactly the same thing. And so on, in turn, 
with none of the sailors being aware of what the others were doing. In the 
morning, all awoke and, after tossing one coconut to the waiting monkey, 
divided the remaining coconuts into five equal parts. How many coconuts 
had the sailors gathered? 
Show how the conditions can be combined to get an equation of the form 
ax + by = c, where x is the total number of coconuts. Then use the methods 
of this section to solve the equation and find the smallest possibility for x. 
2.6. Write a routine that accepts a, b, and m as input and returns the 
complete mod-m solution set to ax = b (mod m). 
2.7. Theorem 2.3 states that if gcd(a, b) = 1, then any number greater than 
or equal to (a - l)(b - 1) is representable as ax + by, with x, y ;;: 0. Show 
that, among the numbers between 0 and (a - l)(b - 1) - 1, inclusive, exactly 
half are representable. Hint: Use the ideas in the proof of Theorem 2.3. 
2.8. What is the largest number of Chicken McNuggets that you cannot 
buy? Chicken McNuggets are sold in baskets of size 6, 9, and 20. (Do this 
without using the Conductor function in the CNT package.) 
2.9. Show that Proposition 2.4 can fail if p is not prime. 

2.2. TH E CHINESE REMAINDER TH EOREM 
49 
2.10. Show that Proposition 2.4 can be generalized to the following: If p is 
an odd prime and x2 = a  (mod p) has one solution in Zp . then it has pre­
cisely two solutions: b and p - b. 
2.11. Show that Proposition 2.4 can be generalized to: If p is an odd prime 
then x2 = 1 (mod pe ) has two solutions modulo pe : 1 and pe - 1. What hap­
pens if the modulus is 2e? 
2.12. 
(Wilson's Theorem) Use Proposition 2.4 to prove that, for any 
prime p, (p - 1) ! = - 1  (mod p). Then prove the converse: If n satisfies 
(n - 1) ! = - 1  (mod n) then n is prime. Hint: Consider the two cases (1) n is 
divisible by two primes, and (2) n is a prime power. Use the formula (Exer­
cise 1.24) for the highest power of a prime that divides a factorial. 
2.2 The Chinese Remainder Theorem 
It is easy to find an integer of the form 3k + 1. And anyone can find an 
integer of the form 5m + 3. But is there a single integer that has both 
forms? This problem is a special case of a method that has come to be 
known as the Chinese Remainder Theorem. Of course, a brute force 
approach would let k be 0, 1, 2, 3, ... in succession until we obtain a value of 
3k + 1 that is congruent to 3 (mod 5). Will this always work? Yes, and again 
that is part of the conclusion of the Chinese Remainder Theorem. 
Mod ['l!able [ 3 k + l ,  { k ,  O, 19 } ] , 5 ]  
{ l , 4 ,  2 ,  0 ,  3 , 1 ,  4 ,  2 ,  0 ,  3 ,  1 , 4 ,  2 , O ,  3 , 1 ,  4 ,  2 , O ,  3 }  
The fifth entry (k = 4) yields the desired 3, so 3 · 4 + 1, or 13, is a solution to 
the sample problem. But in fact any number of congruences can be solved, 
so long as each pair of moduli are relatively prime. 
Theorem 2.5. Chinese Remainder Theorem. Suppose m1 , m2, .. ., mr 
are positive integers that are relatively prime in pairs, and M = 
m 1 m2 · • • m r .  Consider the following system of congruences: 
x = a1 (mod mi) 
x = a2 (mod m2) 
Then there is exactly one integer m {0, 1, 2, .. ., M - 1) that solves the 
system. 
Before proving the result, we give a very important interpretation. The 
least nonnegative residues modulo n are usually denoted Zn ; that is, 
Zn = {0, 1, .. ., n - 1). Moreover, under the operation of mod-n addition, Zn 

50 
2. CONGRUENCES, EQUATIONS, AND POWERS 
forms a group (the operation is associative, there is an identity, 0, and 
every element x of the group has an inverse, namely the element congruent 
to -x). Now, given x E Zmn• one can get integers in Zm and Zn by just 
looking at Mod[x, m] and Mod[x, n]. The point of the CRT is that, provided 
gcd(m, n) = 1, any pair from Zm and Zn , respectively, comes from a unique 
member of Zm n under congruence mod m and mod n. 
More precisely, the set of pairs with the first entry from one group, G, 
and the second from another, H, itself forms a group, with the operation 
defined componentwise; this is called the direct product, G x H. So the 
pairs just mentioned are objects in Zm x Zn . Modular reduction gives a 
function from Zmn to Zm XZn; when gcd(m, n) = 1 the CRT says that the 
function is one-to-one and onto (and therefore is invertible). In short, when 
m and n are relatively prime, the two groups Zm x Zn and Zmn are isomor­
phic, meaning that there is a one-to-one and onto function from one to the 
other that preserves the group operation. And of course the Chinese Remain­
der Theorem deals with any number of congruences, not just two. So it tells 
us that Zm1 XZm2 X ··· XZm, is isomorphic to Zm1m2···m, . 
Proof. Consider M / mI = m2 m3 ··· mn; this integer is relatively prime to mI , 
so we can let bI be the inverse of MI mI modulo m1 . Then look at 
YI = aI bI (MI mI ); YI = 0 (mod m;) for each i > 1, and Y1 = aI (mod m1 ). In 
other words, YI is a solution to the first congruence, and contributes noth­
ing as far as the other moduli are concerned. So, for a general solution, just 
form y2 , y3, • • •  , Yn in the same way, and sum all the y-values. The sum, 
which we can reduce modulo M without affecting any of the congruences, is 
a solution to the system. 
It remains to show that the solution is unique modulo M. Suppose x 
and z are two solutions. Then x = z (mod mi) for each i, so, by Proposition 
1.7, x = z (mod M). 
D 
Here is a visual interpretation of the CRT. The columns are indexed by 
the integers mod 9 and the rows by the integers mod 4. For example, the 
pair {2, 7) in Z4 x Z9 corresponds to 34 in Z36 • Note how the group opera­
tions are preserved: in Z36 , 21 + 34 = 55 = 19. But adding up the compo­
nents, {1, 3) + {2, 7), yields {3, 10), or {3, 1), which is also 19. 
CRTGrid [ 4 ,  9 ] ; 
¦ 
0 
1 
2 
3 
' 
s 
6 
7 
8 
4 
0 
0 
2 8  
2 0  
1 2  
4 
3 2  
2 4  
1 6  
8 
1 
9 
1 
2 9  
2 1  
1 3  
5 
3 3  
2 5  
1 7  
2 
1 8  
1 0  
2 
3 0  
22 
1 4  
6 
3 4  
2 6 
3 
2 7  
1 9  
1 1  
3 
3 1  
2 3  
1 5  
7 
3 5  

2.2. THE CHINESE REMAI NDER THEOREM 
51 
Algorithm 2.2 Chinese Remainder Theorem 
The implementation that follows uses the formula inherent in the proof of 
Theorem 2.5 to solve a system of congruences of the form x = a (mod m), 
where a and m represent lists. The output is simply the least nonnegative 
solution; the user can add multiples of M to get the general solution. We 
first define a query function that decides if a list of integers is pairwise 
relatively prime. That function, PairwiseCoprimeQ, is used as a restrictor 
in the CRT definition so that if it fails the program will not apply. Note that 
Pairwi seCoprimeQ avoids the obvious, but very slow approach of checking 
all pairs (see Exercise 1.11). See Exercises 2.15 and 2.20 for different ways 
of programming CRT that are faster, and more powerful in that they deal 
with the case of non-coprime moduli too. 
PairwiseCoprimeO [m_List ] 
: = Apply [LCM, m] = =  Apply ['.rimes , m] 
CR'.r [ a_ ,  m_ ? PairwiseCoprimeO] 
: = 
Module [ {M = Apply ['.rimes , m] } , 
Mod [Apply [ Plus , a •  PowerMod [M I m ,  - 1 , m] M I  m] , M] ] 
The following alternative approach is both shorter and faster. In general, 
replacing multiplication and addition with a dot product speeds things up. 
And it uses a pure function to act on the product of the moduli, thus avoid­
ing the need to store that product in M. 
CR'.r [ a_, m_ ? PairwiseCoprimeO] 
: = 
Mod [ a .  ( PowerMod [ l  / m, - 1 ,  m] I / m) ,  I ]  & ['.rimes 00 m] 
Here are some examples. The usage is such that CRT [ { 1 ,  3 ,  5 } ,  { 3 ,  5 ,  
7 }  ] finds x congruent to 1 (mod 3), 3 (mod 5), and 5 (mod 7). 
CR'.r [ { 1 , 3 , 5 } , { 3 , 5 , 7 } ] 
1 0 3  
The way the code is written, nothing happens if the moduli are not pairwise 
relatively prime. 
CR'.r [ { 1 ,  3 ,  4 } , { 3 ,  5 ,  25 } ]  
CRT [ { l ,  3 ,  4 } ,  { 3 ,  5 ,  2 5 } ]  
A classic application of the CRT algorithm is to the following problem: 
Find five consecutive integers each of which is divisible by a square. We can 
approach this by seeking x such that x = 0 (mod 4), x + 1 = 0 (mod 9), 
x + 2 = 0 (mod 25), and so on, where we are using squares of small primes 
for the moduli because they will be relatively prime. Isolating the x's leads 
to a system that is easily solved by CRT. The code that follows forms the 
squares of the first five primes by squaring the list, and then using CRT just 
defined. In fact, a ChineseRemainder function (in versions earlier than 

52 
2. CONGRUENCES, EQUATIONS, AND POWERS 
4.0, this was called ChineseRemainderTheorem) is included in the stan­
dard Mathematica package NumberTheory ' NumberTheoryFunctions ' . 
x = CR'.r [ Range [ O ,  - 4 ,  - 1 ] , Prime [Range [ 5 ]  ] 2 ] 
1 3 0 8 2 4 8  
consecutive& = 
x + Range [ O ,  4 ]  
{ 1 3 0 8 2 4 8 , 1 3 0 8 24 9 , 1308250 , 1 3 0 82 5 1 , 1 3 0 8 2 5 2 } 
Mod [consecutives , { 2 , 3 ,  5 ,  7 ,  1 1 } 2 ] 
{ O ,  O ,  O ,  O ,  O }  
The sequence just found is by no means the smallest sequence of five inte­
gers, each of which is divisible by a square. Exercise 2.16 asks you to find 
the smallest such sequence. 
A classic application of the CRT algorithm is its use in high-precision 
arithmetic. One could take a very large computation and work in a coordi­
nate system based on a certain fixed set of primes; that is, one would be 
working with vectors consisting of the residues modulo these primes, and 
do arithmetic on those residues only. Then, at the very end, the CRT would 
be invoked to get the real answer. Here is a simple example showing how 
100! can be computed using low-precision operations. First we select suffi­
ciently many small primes. For the problem at hand it is sufficient to use 
the first 50 ten-digit primes, for their product is beyond 100!. We use 1T(106) 
to get the number of primes under 106. 
primes = Prime [zr [ l06 ] + Range [ 5 0 ] ] 
{ 1 000003 , 1 0 0 0 033 , 10000 3 7 , 10000 3 9 , 1 0 0 0 0 8 1 ,  1 0 0 0 0 9 9 , 1000 1 1 7  I 
1 0 0 0 1 2 1 ,  1000 133 , 1000 1 5 1 ,  1000 1 5 9 , 1 0 0 0 1 7 1 ,  1 0 00 1 8 3 , 1000 1 8 7 , 
1000 1 9 3 , 1000 199 , 10002 1 1 ,  10002 1 3 , 1 0 0 0 2 3 1 ,  1 0 0 02 4 9 , 
100025 3 ,  1000273 , 10002 8 9 ,  10002 9 1 , 1 0 0 0 3 0 3 , 1 0 0 0 3 1 3 , 
10003 3 3 ,  1 0 0 0 35 7 ,  10003 6 7 , 1000 3 8 1 , 1 0 0 0 3 9 3 , 1 0 0 0 3 9 7 , 
1 000403 , 1000409 , 100042 3 ,  10004 2 7 , 1 0 0 0 4 2 9 , 1 0 0 04 5 3 , 
10004 5 7 , 1 0 0 0 50 7 ,  10005 3 7 , 100054 1 ,  1 0 0 0 5 4 7 ,  1 0 0 0 5 7 7 , 
1000579 , 1 0 0 0 589 , 100060 9 ,  1000 6 1 9 , 1 0 0 0 6 2 1 ,  1 0 0 0 6 3 9 } 
Now we start with a vector of fifty ls and form 100! in each coordinate, 
reducing modulo the primes at each step. 
vector = '.rable [ l ,  { 50 } ] ;  
Do [vector = Mod [vector * i ,  primes ] ,  { i ,  2 ,  100 } ] ;  
vector 
{ 37 1 0 7 3 , 4 2 74 6 2 ,  9 8 9 0 6 8 , 5 7 6 75 6 ,  6 1 9 0 5 3 , 9 5 5 3 9 3 , 8 0 3 3 8 ,  52340 1 ,  
4 80 1 1 5 ,  9 7 4 3 8 3 , 9 1 0 8 6 8 , 4 1 69 7 1 ,  5 7 5 0 0 0 , 9 1 1 6 3 9 ,  6 6 0 7 6 3 , 
4 6 2 2 1 , 6552 1 0 ,  3 7 9 02 4 , 5 5 8302 , 1 7 7 6 1 4 , 6 4 1 9 5 2 , 9 8 3 3 4 9 ,  
3 7 9 0 8 8 ,  2 9 4 3 4 5 ,  2 7 6 4 2 9 , 924 1 6 5 , 6 5 6 7 7 1 ,  6 1 6 6 7 8 , 4 9 4 6 9 6 ,  
1 2 9 9 5 5 , 9504 0 3 ,  403948 , 30562 1 ,  8 7 5 1 1 1 ,  9 8 7 8 8 4 , 9 8 2 6 0 2 , 
4 8 64 7 ,  9 2 8 8 1 , 5 3 7 8 1 2 , 2 8 6 6 1 2 , 3 2 6 2 1 0 , 7 7 3 3 2 , 9 3 0 6 5 3 , 
6 4 6 1 0 7 ' 2 09 1 7 5 ,  5 8 8 6 3 , 64 1 930 , 4 2 9 0 8 , 1 9 8 7 4 6 ,  5 3 4 7 6 7 } 

2.2. THE CHINESE REMAINDER THEOREM 
53 
The final step uses the CRT to get the real value of 100 !. 
CbineseR@maipder [ vector, primes ] 
9 3 3 2 6 2 1 5 4 4 3 9 4 4 1 5 2 6 8 1 6 9 9 2 3 8 8 5 6 2 6 6 70049 0 7 1 5 9 6 8 2 64 3 8 1 6 2 1 4 6 8 5 9 2 9 Ȓ  
6 3 8 9 52 1 7 5 9 9 9 9 3 2 2 9 9 1 560894 1 4 6 3 9 7 6 1 5 65 1 82 8 62 5 3 6 9 7 9 2 0 8 2 7 2 2 3 7 5 8 ȓ  
2 5 1 1 8 5 2 1 0 9 1 6 8 64000 000000000000000000000 
Ideas such as these are occasionally used in massive high-precision 
computations. Indeed, CRT methods were used by David Bailey in one of 
his record-breaking computations of the digits of TC. 
Exercises for Section 2.2 
2.13. Use the Chinese Remainder Theorem algorithm to find, by hand­
calculation (no computer or calculator), all solutions to the system: 
x = 2 (mod 3), x = 3 (mod 5), x = 4 (mod 7). 
2.14. A very short, though nonalgorithmic, proof of the Chinese Remainder 
Theorem exists. Show that if the moduli are pairwise relatively prime, then 
the function from Zm, m2···m, to Zm, X Zm2 x · · ·  X Zm, given by sending x to 
(Mod[x, mi], Mod[x, m2], ... , Mod[x, m,]), is one-to-one. Show why this 
implies that the system of equations has a unique solution modulo the 
product of the mi. 
2.15. When the moduli are at all large there is a faster approach to the 
Chinese Remainder Theorem than Algorithm 2.2. Implement the algorithm 
described below and compare its performance to Algorithm 2.2 in the case 
that the a-values are given by {1, 2, 3, ... , r) and the moduli are the first r 
primes past the lOOOOOth (the moduli can be described as Prime [ 
Range [ 1 ,  r ]  + 1 0 0 0 0 0  ] ). Try both small and large values of r, doing 
multiple runs in the case of small values to get reasonable timing values. 
(a) Show that the case of two equations with coprime moduli 
x = ai (mod m1) 
x = a2 (mod m2) 
has a solution given by ai + (a2 - ai)mi (mj1 mod m2) (Hint: The algebra 
underlying this verification is simple, but to see where the formula comes 
from look at the grid for Z4 x Z9 on page 50 and observe that once one 
knows the entry in {0, 1) one can easily get any entry in the grid.) 
(b) Given r equations x = ai (mod mi) with pairwise relatively prime mod­
uli, generate a solution by replacing the first two equations by the single 
equation x = a  (mod m1 m2) where a is given by part (a). Continue such 
reductions until the final answer is obtained. Try to avoid using recursion 
in your program, as an iterative approach will be faster. 

54 
2. CONG RU E NCES, EQUATIONS, AND POWERS 
2.16. Find the smallest sequence of 5 consecutive integers each of which is 
divisible by a square. 
2.17. Suppose gcd(m, n) = 1 and let f : Zm x Zn -+ Zm n be the one-to-one and 
onto function given by the Chinese Remainder Theorem. Prove that the 
product f(a, b)f(s, t) in Zmn is the same as f(as, bt) . This shows that f 
preserves the group operation. 
2.18. Let m = 2a p1 b, · · ·  Pr b, , where a   0, r  0, bi  1. How many incongru­
ent solutions are there to x2 = 1 (mod m)? Hint: Use Exercise 2.11 and the 
Chinese Remainder Theorem. Verify your result by an exhaustive search in 
several small cases. 
2.19. Write a program that handles the general Chinese Remainder Theo­
rem situation, including the case that the moduli are not relatively prime. 
Your program should return the empty set if the equations have no solution 
(such as x = 1 (mod 5), x = 3 (mod 25)), and should return the least nonnega­
tive solution otherwise. Here are some key ideas: 
(a) Prove that the system 
x = ai (mod mi ) 
x = a2 (mod m2) 
has a solution if and only if a1 - a2 is divisible by gcd(m1 , m2), and that 
when there is a solution it is unique modulo LCM[m1 , m2 ]. 
(b) Find an explicit formula for a solution to the system in (a) when such 
exists. 
(c) Deal with r equations by reducing the first two to a single equation, 
thus reducing the system to a smaller one. 
2.20. (Dan Lichtblau, Wolfram Research, Inc.) 
An even faster 
approach to a CRT algorithm is by a divide-and-conquer method. Use the 
method of Exercise 2.15 when there are seventeen or fewer equations. But 
when there are more, break the system into two nearly equal halves and 
use recursion. With proper care this can be made to work in the noncoprime 
case as well, using the ideas of Exercise 2.19 for the base case. Implement 
this method and make timing comparisons to the other methods discussed 
in this chapter. 
2.21. We will see in Chapter 6 that 2 is a square modulo those primes, and 
only those primes, congruent to ± 1 (mod 8). Here are the first six such 
primes. 
pr = Select [ Prime [ Range [ 18 ] ] ,  Mod [ I ,  8] == 7 1 1  Mod [ I ,  8] == 1 & ]  
{ 7 ,  1 7 , 2 3 , 3 1 ,  4 1 ,  4 7 } 

2.3. POWERMOD PATTERNS 
55 
We will learn later a formula for getting ω modulo a prime, but for now 
we can do a brute force search. 
sqrts = 'l!able [ Select [Range [pr [i] ] ,  Mod [ i2 , pr [i] ] == 2 & ]  , { i ,  6 } ] 
{ { 3 ,  4 } ,  { 6 ,  1 1 } ,  { 5 ,  1 8 } ,  { 8 ,  23 } ,  { 1 7 ,  24 ) , { 7 , 40 ) } 
As a check, observe that 52 = 182 = 2 (mod 23). Now let M be the product of 
the primes in question. 
M = Apply [ Time s ,  pr] 
1 6 3 5 0 0 1 6 9  
Show that x is a square root of 2 (mod M) if and only if x = ap (mod p) for 
each p in pr, where each ap is a mod-p square root of 2. Use this result to 
show that there are 64 square roots of 2 (mod M), and then use the CRT to 
find them all. 
2.22. Let Pk denote the kth prime. Implement the following algorithm and 
explain why it returns 2pk + 1 consecutive composite integers. Use the 
Chinese Remainder Theorem to find b such that b is divisible by 0̙=1 p;, 
b = -1 (mod Pk+d. and b = 1 (mod Pk+2). Then {b - Pk, ... , b - 1, b, b + 1, ... , 
b + Pk} are all composite. 
2.23. Find five consecutive integers each of which is divisible by the lOOth 
power of an integer. 
2.3 PowerMod Patterns 
« Fermat's Little Theorem 
Perhaps the most important function in elementary number theory is the 
modular power: ai (mod m). When one looks at a few of these powers many 
extremely interesting patterns jump out. Indeed, you should experiment 
with the tabular and visual functions described shortly to see how many 
patterns you can find. There are lots of them. In this section we will restrict 
ourselves to prime moduli; there are many important patterns in the com­
posite case too, as we will discover in Section 3.4. 
Here are two typical tables, with m equal to the primes 7 and 11. Each 
row gives the modular powers of a single a; so the second row of the first 
table shows 2, 22 , 23, 24, 25, 26, all modulo 7. Whenever p - 1 occurs as a 
power, - 1  is shown instead; the most important entries are the ls, shown 
in bold. How many patterns can you find in this array? Examine other 
arrays with prime modulus and see if the patterns you see persist. 

56 
2. CONG RUENCES, EQUATIONS, AN D  POWERS 
PowerGrid [ 7 ] 
PowerGrid [ 1 1 ]  
i =  
1 
2 
3 
4 
5 
6 
a = l 
1 
1 
1 
1 
1 
1 
a = 2  
2
4
1
2
4
1
 
I-- ·--··--
-----
3 
3 
2 
·- 1 
4 
5 
1 
----- - · -·-- L-
4 
4
2
1
4
2
1 
5 
5 
4 -1 2 
3 
1 
·----
--
6 
- 1  1 
- 1  
1 
- 1  
1 
i = 
a 
= 1 
a 
= 2 
3 
f----·-·-
4 
L....---·-··-
5 
e----
6 
7 
8 
9 
ݞ-- ··-
10 
1 
2 
a 
1 
l 
1 
2 
4 
8 
3 
9 
5 
4 
5 
9 
5 
a 
4 
6 
a 
7 
7 
5 
2 
8 
9 
6 
9 
4 
3 
- 1  
1 
- 1  
4 
5 
1 
1 
5 
- 1  
4 
1 
3 
1 
9 
1 
9 - 1 
3 
- 1  
4 
- 1  
5 
1 
1 
- 1  
11 = 7 
n = l l 
6 
7 
8 
9 
1 0  
1 
1 
1 
1 
9 
7 
3 
6 
3 
9 
5 
4 
1 
·-···-
4 
5 
9 
3 
1 
·-··-·--
5 
3 
4 
9 
5 
8 
4 
2 
1 
·--····--·-··-
4 
6 
9 
8 
3 
2 
5 
7 
9 
4 
3 
5 
1 
··----
1 
- 1  I 
- 1  
1 
Of course, the pattern that leaps out of the data is the fact that the 
rightmost column is all ls. Indeed, this property tells us that there is no 
need to examine any columns beyond the (p - l)st, because entries will just 
repeat. And it is clear that there is no need to examine rows beyond the 
(p - l)st because a =  b (mod m) implies ak = bk (mod m). The fact that 
aP-1 = 1 (mod p) is known as Fermat's Little Theorem. This identity is 
subtle and important; the proof that follows is short, but that doesn't take 
away from the inobvious nature of this result. 
Theorem 2.6. Fermat's Little Theorem. If a is not divisible by p, then 
aP-1 = 1 (mod p). For any a, aP = a  (mod p). 
Proof. A set of m numbers that are distinct modulo m is called a complete 
residue system (mod m). For example, {0, 1, 2, 3, ... , m - 1} is such a 
system. And so is {0, 3, 4, 5, 6, ... , m - 1, m + 1, m + 2}. Any such system, 
when reduced modulo m, is just a permutation of {0, 1, 2, 3, ... , m - 1}. We 
need the following fact: If a is relatively prime to m and X is a complete 
residue system mod m, then so is the set obtained by multiplying each 
member of X by a. The proof is a straightforward application of the modu­
lar cancellation law and is left as an exercise. 
Now, if p is prime, then two complete residue systems (mod p) are 
X = {0, 1, 2, 3, ... , p - 1} and Y = {a, 2a, 3a, ... , (p - l)a}. Because, viewed 
modulo m, X and Y are just permutations of each other, the products of 
their entries are congruent modulo m. This means that 
aP-1 (p - 1) ! = (p - 1) ! (mod p) 
Because p is prime, it cannot divide (p - 1) !. This means that (p - 1) ! 
and p are relatively prime, so (p - 1) ! can be cancelled from the preceding 
congruence. [Think of multiplying both sides by the mod-p inverse of 
(p - 1)!; in fact, (p - 1)! is the same as - 1  (mod p) by Wilson's theorem (see 
Exercise 2.12), but that is not needed for this proof.] The cancellation leaves 

2.3. POWERMOD PATTERNS 
57 
us with aP- 1 = 1 (mod p). The additional result of the second assertion of 
the theorem requires only checking the case that a is divisible by p, and 
then both sides are 0 (mod p). 
o 
« More Patterns in Powers 
Many other patterns are visible in the data. Indeed, we can visualize the 
power grid by using colors and the VisualPowerGrid function. The default 
scheme uses red for + 1, yellow for -1, and different shades of blue for the 
other residues. If the powers of a run through all possibilities - which is 
the same as saying that the powers are all distinct - then a is called a 
primitive root for p. The tabular data presented earlier can be examined 
for primitive roots, while the varying shades that we use make their recogni­
tion more difficult. However, the ShowPrimitiveRoots option causes the 
a-values that are primitive roots to be shown in red (or with an arrow, as in 
Figure 2.1). Some color output of VisualPowerGrid appears in color plate 
l; black and white images appear in Figure 2.1. 
yisualPowerGrid [13 , SbowPrimitiveRoots Ű True] ; 
YisualPowerGrid [ 17 ,  SbowPrimitiveRoots Ű True ] ; 
i 
1 
2 
) 
4 
5 
6 
7 
e 
9 
l o  : 1  1 ::  
i 
" 
2 
3 4 
5 IS 
7 
9 
9 1 0 l i l 2 1 3 1 4 1 5 1 6  
a 
1 
-+ 2 
) 
... ९. 
-··-1 
• 
• 
• 
• 
a 
l 
2 
-+ 3 
4 
4 
5 
-+ 6 
• 
• 
• 
• 
I 
« 
.1 
' \  
... 5 
... 6 
_, 7 
8 
... 7 
e 
9 
ψ· 
• 
• 
• 
• 
• 
•• 
9 
_, 10 
_, 1 1  
_, 1 2  
1 0  
... 1 1  
1 2  
• 
., 
:• 
. " 
. 
• 
• • • • • • 
1 3  
_, 1 4  
1 5  
1 6  
Figure 2.1. Two graphic displays of the power grid, for the prime moduli 13 and 17. 
White denotes + 1, black denotes -1, and other values are represented by shades of 
gray. The arrows indicate the rows consisting of distinct entries (the primitive 
roots). Many patterns are visible. Some of them always hold; others will be dis­
proved by looking at more examples. 
The reader is encouraged to experiment with this function and discover 
what patterns he or she can. There are very many patterns here, both when 
the modulus is prime and when it is composite. Questions to think about: 
Which columns (rows) consist only of ± ls? Which rows (columns) consist of 
distinct values? Are there any patterns to the +ls and -ls? Some patterns 
that you will find will be true and not hard to prove. Others will be false, 
though a counterexample might be tricky to find. Others may involve 
unsolved problems . 

58 
2. CONGRUENCES, EQUATIONS, AND POWERS 
Of course, number theory is notorious for generating simple-sounding 
statements that are difficult to prove. However, the fact that the central 
column consists only of ± ls is easy to understand, for it follows immedi­
ately from Proposition 2.4. 
Finally, we observe that Fermat's Little Theorem gives an alternate 
way to look at modular inverses. If gcd(a, p) = 1 then, because aP-l = 
1 (mod p), we see that the mod-p inverse of a is given by aP-2 • This is 
interesting, and a conceptually very simple algorithm, but in fact the 
method for getting inverses based on the Euclidean algorithm is faster. 
Exercises for Sedion 2.3 
2.24. Prove that if gcd(a, m) = 1 and X is a complete residue system modulo 
m, then so is the set obtained by multiplying each member of X by a. 
2.25. Write a program that accepts primes as inputs and counts the num­
ber of primitive roots. 
2.26. Identify as many patterns as you can in the power grids. For each 
one, try to gain some evidence for its truth by either finding a proof or doing 
lots of numerical computations without using grids. To get started, con­
sider: Which columns (rows) consist only of ± ls? Which rows (columns) 
consist of distinct values? Are there any patterns to the + ls and - ls? 
2.27. Compare the speed of the following two methods of getting modular 
inverses: (1) via the ideas of the extended Euclidean algorithm; (2) via the 
formula a-1 = aP-2 (mod p). For a fair comparison you should use large 
numbers, and make the programs as similar as possible in terms of their 
use of built-in functions. 
2.28. Fermat's Little Theorem says that if p is prime then p divides 
2P-l - 1. If a prime p is such that p2 divides 2p-l - 1, then p is called a 
Weiferich prime. There are two Weiferich primes under 1012 . Find them. 
2.29. Prove Fermat's Little Theorem by fixing a prime p and using induc­
tion on a, starting with a =  1. Hint: Use the binomial theorem to expand 
(a + l)P . You will need the auxiliary fact (Exercise 1.36): ( f )  = 0 (mod p) 
when 1 < i <  p. 
2.30. Prove that if ab = l (mod p), then agcd(b,p-ll = l (mod p). Hint: Consider 
integers s and t such that sb + t(p - 1) = gcd(b, p - 1). 
2.31. Let p be prime. Show that there is no prime less than p that divides 
2P - 1. Use this to prove that if p < m < p2 and m divides 2P - 1, then m is 
prime. 
2.32. Find a prime p between .Y 267 497 and 267 497 such that 267 497 
divides 2P - 1. 

2.4 Pseudoprimes 
2.4. PSEUDOPRI M ES 
59 
Fermat's Little Theorem tells us that 2n-1 = 1 (mod n) whenever n is prime. 
Because the modular power can be computed very quickly even when n is 
huge, it would be wonderful if 2n-1 '$ 1 (mod n) whenever n is not prime; this 
would be an extremely fast and elegant test for primality. Unfortunately, 
this simple criterion fails to characterize the primes. Here are some func­
tions to test how well this works; TwoPseudoprimeQ returns True if 
2n-I = l (mod n) but n is not prime. We use TwoPseudoprimeQ for this 
function because such numbers are called 2-pseudoprimes. Because we 
will want to use this as a prime test too, we define a separate function to 
carry out the power computation. 
'rwoPseudoprime'.rest [n_] : =  PowerMod [ 2 ,  n - 1 ,  n ]  = =  1 
'rwoPseudoprimeQ [n_] : =  n.c>PseudoprimeTest [ n ]  && ! PrimeQ [n] 
Now we look at the first 1000 integers, and discover that there are three 
that fool our criterion; the first one is 341. More generally, an integer n is 
called a b-pseudoprime if bn-I = 1 (mod n) and n is not prime. 
Select [ Range [ lOOO] , 'rwoPseudoprimeQ] 
{ 34 1 ,  5 6 1 ,  6 4 5 } 
The CNT package has a function that checks whether n is a b­
pseudoprime. Because PseudoprimeQ has two arguments, we must use the 
pure function construction: f [ :fl , 2 ]  & refers to the function that, on input n 
returns f [ n ,  2 ]  , in other words, :fl acts as a universal variable. 
Select [ Range [ lOOO] , Pseudoprime0 [ 2 , I ] & ]  
{ 34 1 ,  5 6 1 ,  6 4 5 } 
If there were only finitely many 2-pseudoprimes, we could incorporate a 
list into a program and so would have a foolproof and fast test for primality. 
But, even though they do become rarer as numbers get larger, there are 
infinitely many of them. 
Proposition 2.7. There are infinitely many 2-pseudoprimes. 
Proof. First a general fact: If d divides n then 2d - 1 divides 2n - 1. This 
can be proved by algebraic factorization of xdk - 1  (Exercise 2.34), but it is 
smoother to use congruence arithmetic: 
Now we can build our infinite list of 2-pseudoprimes by showing that if n is 
one, then so is m = 2n - 1. We know that n is composite, so the fact just 
proved tells us that m is composite too. So it remains to show that 

60 
2. CONGRU ENCES, EQUATIONS, AND POWERS 
2m-l = 1 (mod m). Because n is a 2-pseudoprime, 2n = 2 · 2n-l = 2 (mod n), 
which means that n divides 2n - 2. Then, by the fact proved at the start of 
the proof, 2n - 1 divides 22" -2 - 1, which equals 2m-l - 1. This construction 
gives the infinite sequence of 2-pseudoprimes: 341, 2341 - 1, 2234' - 1 , • • • . 
o 
It never hurts to check. 
m = 2341 - 1 ;  
{Mod [m, 2 11 - l ] , PowerMod [ 2 , m - 1 ,  m] } 
{ 0 ,  1 } 
It is useful to know that arithmetic can be suppressed in Mathematica by 
the use of HoldForm. Here is how one can generate a compact list of seven 
pseudoprimes. Can you estimate the number of base-10 digits in each of 
these numbers? 
f [ x_] : = BoldForm [ 2" - l ]  
HestList [ f ,  3U , 6 ]  
{341 , 2 34 1 - 1 , 2 2'" - 1 - 1 , 2 22m . 1 _ 1 - 1 , 
Naturally one can also look at b-pseudoprimes for any b, the definition 
being simply: n is not prime and bn-l = 1 (mod n). Here is a table of all the b­
pseudoprimes under 1000, with b = 2, 3, 5, ... , 19. It is common to consider 
prime values of b only (see Exercise 2.40), though one can investigate b­
pseudoprimes when b is not prime. 
Pseud,oprimeTable [ 8 ,  1000 ] 
.-.. 
l b  
I¥ 
34 1 
5 61 
645 
91 
1 2 1  
2 8 6  
61 1 
703 
i 5 
4 
1 2 4  
2 1 7  
56 1 . :11 1  
' 7  6 
2 5  
3 2 5  
56 1 
703 
1 1 1 
1 0  
15 
7 0  
1 3 3  
1-9 0  
! 1 3  4 
6 
1 2  
2 1  
as 
949 
8 1 7  
259 
1 0 5  
I 1 1  
4 
8 
9 
16 
45 
.91 
! 1 9  6 
1 9  
15 
1 8  
4 5  
49 
\. __ _ _ __ 
-· 
T--
i 
I 
I 
305 
4 8 1  
6 4 5  
2 3 1  
244 
2 7 6  
145 
261 781 
153 169 
34.3 
... _ .... _ 
703 
793 
3 5 7  427 
5 6 1  
6 3 7  
.. --
I 
I 
I 
I 
I 
561 I 
··-· 
- --
I 
I 
88?_ i 905 l 906 
It looks like our focus on b = 2 was wise, because that seems to have 
fewer counterexamples than any other b. Of course, we would be especially 
pleased if there was a b for which there were no pseudoprimes whatsoever, 
or perhaps only finitely many. But that is false (Exercise 2.43). Worse, 
there are certain numbers that can never have their primality verified by a 
pseudoprime test. Notice how 561, which factors as 3 · 11 · 17, appears in 
each of the lists (except b = 3, 11, or 17). This means that 561 is a b­
pseudoprime for every possible b, except those that have a factor in common 
with 561. So the only way that 561's compositeness could be discovered 
would be by using b = 3, 11, or 17, in which case a simple divisibility test 
would show that 561 is not prime. Numbers such as 561 are called Car-

2.4. PSEUDOPRI M ES 
61 
michael numbers. Precisely: A Carmichael number n is an integer that is 
a b-pseudoprime for every b that is relatively prime to n. It is now known 
(though this is a recent result; it was conjectured by Carmichael in 1912 
and not proved until 1992, by Alford, Granville, and Pomerance [AGP]) that 
there are infinitely many Carmichael numbers. 
It is easy to see why 561 is a Carmichael number. Let gcd(b, 561) = 1 .  
To show that b560 = 1 (mod 561) it is sufficient (by Proposition 1.17) to show 
that this congruence holds modulo 3, 11, and 17. But b560 = b10·56 = 
156 = 1 (mod 11) by Fermat's Little Theorem. Similarly b560 = b16·35 = 
1 (mod 17) and b560 = b2"280 = 1 (mod 3). In short, n = 561 has the form n p; 
where the Pi are distinct odd primes and each Pi - 1 divides n - 1. In fact 
every Carmichael number has this form, with three or more prime factors 
(see Section 3. 7). 
Here are the first seven Carmichael numbers. 
Select [ Range [ 2 ,  10000 ] , CarmicbaelO] 
{ 5 6 1 ,  1 1 05 , 1 7 2 9 , 2 4 6 5 , 2 82 1 ,  6 6 0 1 ,  89 1 1 }  
Even though the 2-psp test ("psp" is used to abbreviate "pseudoprime") 
fails to fully characterize primality, it is immensely important as a first 
tool. For if the simple modular power fails to be 1 (mod n), we know with 
certainty that n is composite. If n is large we may have no idea how to find 
any factors of n, but we can be absolutely certain that n fails to be prime. 
For example, let n be the 3571st Fibonacci number, which has 746 digits; 
then 2n-1 '$ 1 (mod n), as we now show. 
n = Fibonacci [ 3 57 1 ]  " 
H [ n] 
8 .  8 1 8 1 6 7 2 2 7 2 5 8 2 4 9  x 1 0745 
PowerMod [ 2 , D - 1 ,  D ]  / / H 
4 . 1 5 5 04 7 8 9 3 6 1 1 5 6 7  x 1 0745 
This is not 1, and so we know with certainty that F3571 is not prime, even 
though we have no idea what any of its factors are. We can try to find some 
small factors by taking the gcd of n with the product of all primes less than 
30000, but this turns up nothing. We use 7r(30000) (which is 3245) to figure 
out how many primes to use. 
GCD [ n ,  Apply [ Times , Prime [Range [ԭ [ 30000 ] ] ] ] ]  
1 
« Using the Pseudoprime Test 
Because pseudoprimes are relatively rare, we can use a pseudoprime test to 
find large numbers that are, almost surely, prime. Note that, when looking 
for prime Fibonacci numbers, one looks only at Fp where p is prime, for 
reasons mentioned in Exercise 1.6. 

62 
2. CONGRUENCES, EQUATIONS, AND POWERS 
Select [ Prime [ Range [ 2 , 100 ] ] ,  
'l'WoPseudoprimeTest [Fibonacci [ I ] ] & ]  
{ 5 ,  7 ,  1 1 ,  13 , 1 7 ,  2 3 ,  2 9 , 43 , 4 7 ,  
83 , 1 3 1 ,  1 3 7 , 359 , 43 1 ,  433 , 4 4 9 , 509 } 
We can look for the first few primes beyond a googol. The package 
function ExponentForm splits a power of 10 away from an integer, which is 
best for displaying numbers near a googol. 
Select [ Range [ 10100 + 1 ,  10100 + 1000 , 2 ] , 'l'WoPseudoprimeTest ] / /  
ExpopentForm 
{ 1 0100 
+ 2 6 7 ,  1 0 100 + 949 } 
We again emphasize that this does not prove that 10100 + 267 is prime. But 
it is reasonable to believe it is. On the other hand, this computation tells us 
with absolute certainty that, with at most two exceptions, all the numbers 
in the first 1000 past 10100 are composite. 
The Mersenne numbers (numbers of the form 2n - 1) occupy a special 
place in the history of primes because the world record largest primes have 
almost always been Mersenne primes. The current largest prime is 
26972593 - 1. There is a special-purpose test that finds Mersenne primes (see 
Section 9.2), but we can try a pseudoprime test. 
Mersenne [ n_] : = 2n - 1 
Select [ Range [ lOO] , 'l'WoPseudoprimeTest [M&rsenne [ t ] ] & ]  
{ 2 ,  3 , 5 , 7 ,  1 1 ,  13 , 1 7 ,  1 9 , 2 3 , 2 9 ,  3 1 ,  3 7 , 
4 1 ,  4 3 , 4 7 ,  53 , 59 , 6 1 ,  6 7 ,  7 1 ,  7 3 , 7 9 , 8 3 , 8 9 ,  9 7 } 
Ouch! There are too many here! For example, 211 - 1 = 204 7 = 23 · 89. 
Recall from Proposition 2.7 (and Exercise 2.36) that numbers of the form 
2P - 1 have a tendency to be 2-pseudoprimes. Indeed, of the 25 hits that the 
2-psp test found, the imposters outnumber the actual primes 15 to 10. It is 
easy to unmask the composites by using a 3-psp test. 
Select [ Range [ lOO ] , 
PowerMod [ 3 ,  Mersenpe [ t ]  - 1 , M&rsenne [ t ] ] == 1 & ]  
{ 3 ,  5 , 7 ,  1 3 , 1 7 ,  1 9 ,  3 1 ,  6 1 ,  8 9 } 
These are in fact the true Mersenne primes among the first 100 Mersenne 
number, with one exception: the index 2 is missing from this list. That is 
because 22 - 1 is 3 which is prime, but hides from the 3-psp test because 32 
is not 1 (mod 3). Using a 5-psp test would get them all in this range. We 
repeat that combining pseudoprime tests for different bases, while it does 
cut down the number of failures, can never lead to a perfect test because of 
Carmichael numbers. 
Of course, when investigating large numbers for probable primality we 
could just use the built-in PrimeQ function. It uses more sophisticated, but 

2.4. PSEU DOPRI M ES 
63 
still very fast, pseudoprime tests, which will be explained in Chapters 4 
and 8. 
Exercises for Section 2.4 
2.33. Consider the following primality test: Fix an initial segment of the 
primes, such as 2, 3, 5, 7, and combine the b-psp test for each b in this list. 
For several such initial segments find the first n for which this test gives an 
incorrect answer. 
2.34. Prove that if d divides n then 2d - 1 divides 2n - 1, via a direct argu­
ment based on factoring xdk - 1. 
2.35. Consider the sequence of 2-pseudoprimes 
341 2341 - 1 2<2:141 -l) - 1 22'2"' -IJ - 1 - 1 
' 
' 
' 
' 
For each entry, estimate the number of base-10 digits it has. You cannot be 
exact here because the numbers are so large. Just come up with a concise 
description. 
2.36. Show that 2P - 1 is a 2-pseudoprime whenever p is prime and 2P - 1  
is composite. 
2.37. Prove the converse of the divisibility fact used in Proposition 2.7: If 
2d - 1 divides 2n - 1, then d divides n. 
2.38. (a) (D. H. Lehmer) If n is a 2-pseudoprime, then n must be odd and 
2n = 2 (mod n). Find an even integer n (other than 2) such that 2n = 
2 (mod n). 
(b) Use the result of part (a) to resolve the following. We saw in the proof 
of Proposition 2. 7 that if 2n - 1 is prime, then n is prime. True or False: If 
2n - 1 is a 2-pseudoprime then n is either prime or a 2-pseudoprime. 
2.39. True or False: If n is a 3-psp, then so is 3n - 1. 
2.40. Prove that if n is composite then the least b such that n is not a b-psp 
is prime. 
2.41. Prove that if 2n + 1 is prime, then n must be a power of 2. Hint: When 
n has an odd divisor 2n + 1 has an algebraic factorization. 
2.42. The Fermat numbers, Fn. are numbers of the form 22
" + 1. The first 
few are prime and it was once suspected that all might be prime, but now it 
is suspected that, except for the first few, they are all composite. Show that 
whenever a Fermat number is composite, it is a 2-pseudoprime. Prove that 
Fs is composite. 

64 
2. CONGRUE NCES, EQUATIONS, AND POWERS 
2.43. (M. Cipolla, 1904) Show that for any b there are infinitely many b­
pseudoprimes by showing that for any odd prime p that does not divide 
b(b2 - 1), 
bP - 1 bP + 1 
--
--
b - 1 b + l  
is a b-pseudoprime. Note that this expression has the neat form: 1 + b2 + 
b4 + . . .  + b2p-2 . 
2.44. A pseudoprime witness for a composite n is an integer b such that 
gcd(b, n) = 1, 1 s b s n - 1, and bn-l '$ 1 (mod n). Of course, the existence of 
such a witness proves that n is composite. Do some computations to support 
the following formula due to Monier, Baillie, and Wagstaff [BW]: If n is odd, 
the number of psp witnesses for n is 
<f>(n) - n 
. 
. . 
(gcd(n - 1, p - 1) - 1) . 
p a prime d1V1sor of n 
See Exercise 3.39 for more information on this formula. 
2.45. Use the 2-psp test to get the likely primes in the first 10000 integers 
beyond a googol. How does this compare with the heuristic value for the 
expected number of primes in this interval? 
2.46. A Mersenne number in base 2 has the form 111. .. 1112 . One can look 
at similar numbers in base 10 and see how many are prime. These numbers 
are sometimes called repunits, with repunitn denoting the concatenation 
of n ls; they are easy to define arithmetically. 
Repunit [n_] : = 
(108 - 1 )  / 9 
Repunit [ 7 ] 
1 1 1 1 1 1 1  
(a) Prove that if repunitn is prime, then n is prime. 
(b) Find some (probably) prime repunits. For a long time only 5 were 
known, but in late 1999 H. Dubner discovered a sixth, since he found that 
repunit49081 is probably prime (see [Rib]). 

CHAPTER 3 
Euler's </J Function 
3.0 Introduction 
The goal of this chapter is to explore the structure of the power grid for 
composite moduli. In particular, we will be looking for rows that contain all 
possible residues: Which moduli have such rows? How many such rows are 
there? What can be said about the positions of these rows? The answers will 
depend on arithmetic properties of the modulus. 
Getting these answers will lead us to investigate two important arith­
metic functions: Euler's function <f>(n), which counts the number of integers 
in {l, . . .  , n} that are relatively prime to n, and the sum of divisors function, 
CT(n), which is the sum of the positive integers that divide n. The ¢-function 
is particularly significant. It provides information about the order of the 
residues modulo n - the least power that is congruent to 1 - and will play 
a role in many algorithms for factorization and prime testing, as well as the 
RSA public-key cryptosystem. The CT function will be used to explore perfect 
numbers, but it too has deeper applications, some of which will be discussed 
in Chapter 9. 
3.1 Euler's <f> Function 
The Euler phi function, denoted <f>(n) and available in Mathematica as 
EulerPhi, or just </> if the CNT package is loaded, is central to much of 
number theory. It counts the number of integers in {l, 2, . . .  , n} that are 
relatively prime to n. For example, ¢(12) = 4 because of the 4-element set: 
{l, 5, 7, 11}. Here is a table showing ¢-values of the first 100 integers. Not 
too many patterns are apparent from this data - it is always instructive 
for the reader to try to recognize what patterns there are - but there are in 
fact many important rules (and fascinating unsolved problems) involving ¢. 

66 
3. EU LER'S  FU NCTION 
Fupct.iop:rable C*' 100 , Columns -+ 5 ]  
n t/J(n) 
n ef>(n) 
n t/J(n) 
1 
1 
2 1  12 
41 
40 
2 
1 
22 
10 
42 
12 
3 
2 
23 22 
43 42 
4 
2 
24 
8 
44 
20 
5 
4 
25 
20 
45 
24 
6 
2 
26 
12 
46 22 
7 
6 
27 18 
47 
46 
8 
4 
28 12 
48 16 
9 
6 
29 28 
49 
42 
10 
4 
30 
8 
50 
20 
1 1  1 0  
3 1  30 
51 32 
12 
4 
32 
16 
52 
24 
13 
12 
33 20 
53 
52 
14 
6 
34 
16 
54 
18 
15 
8 
35 
24 
55 40 
16 
8 
36 
12 
56 
24 
17 
16 
37 
36 
57 
36 
18 
6 
38 
18 
58 28 
19 18 
39 24 
.59 ߉ 
20 
8· 
40 
16 
:so 
16 
n t/J(n) 
n t/J(n) 
61 
60 
81 54 
62 
30 
82 
40 
63 
36 
83 
82 
64 
32 
84 
24 
65 
48 
85 64 
66 20 
86 
42 
67 
66 
87 
56 
68 
32 
88 40 
69 
44 
89 
88 
70 24 
90 
24 
71 70 
9 1  72 
72 
24 
92 
44 
73 
72 
93 
60 
74 36 
94 46 
75 
40 
95 
72 
76 
36 
96 
32 
77 60 
97 
96 
78 
24 
98 42 
.79 
78 
99 
60 
80 
32 
100 
40 
For convenience we list several facts about <fJ in the following theorem. 
We use d I n  to abbreviate "d divides n". 
Theorem 3.1. (a) If n ;;:: 2, then 1 s <fJ(n) s n - 1. 
(b) If n > 2, </J(n) is even. 
(c) If n is prime then <fJ(n) = n - 1. 
(d) If </J(n) = n - 1, then n is prime. 
(e) If p is prime, </J(pe) = pe - pe-l = pe- l (p - 1). 
(f) If {p; }  are the prime divisors of n, then </J(n) = nni (1 - ;, ). 
(g) </J(n) ;;::: nnǬ (1 - ..l.) ;;:: -
1
 
n12 l where P 1 , P2 , 
. . .  , 
Pr are the first r 
1= 1 
p, 
og2 n 
primes and n has r distinct prime factors. 
(h) L dln <fJ(d) = n. 
The proofs of (f)--{h) will be given shortly. Facts (a)-(e) are straightfor­
ward. The definition yields (a) immediately. For (b), if gcd(a, n) = 1 then 
gcd(n - a, n) = 1 too, and n - a * a if n > 2. Assertion (c) holds because all 
candidates (except n itself) are coprime to a prime; for (d) observe that if n 

3. 1 .  EULER'S I/> FUNCTION 
67 
has a divisor, then that divisor is excluded from the ¢-count, making it 
submaximal. And (e) is proved by counting the integers in {1, 2, ... , pe) that 
are excluded from the ¢-count; there are pe-1 of them: p, 2p, 3p, ... , pe-l p. 
In 1932, D. H. Lehmer asked if condition (c) could be weakened and still 
characterize the primes. Precisely: Is there a composite n such that tf>(n) 
divides n - 1. It is known that any example must be larger than 1020 (see 
[Guy, problem B37] and [Rib, p. 36]). 
Understanding If> and many other functions of number theory requires 
the notion of a multiplicative function. A function f from positive integers to 
positive integers is called multiplicative if f(mn) = f(m)f(n) whenever 
gcd(m, n) = 1. The main point to note about such functions is that a value 
f(n) can be computed by just multiplying together the values f(pe) for all 
prime powers pe in the prime factorization of n. Of course, the difficulty of 
the general factoring problem means that this is useless for very large 
numbers. But it does provide an efficient way of computing f(n) when the 
factorization of n can be quickly obtained (which is the case for n < 1020). 
Proposition 3.2. If> is a multiplicative function. 
Proof. Recall the mapping F :  Zmn -+Zm xZn given by F(a) = (Mod[ a, m], 
Mod[a, n]). The Chinese Remainder Theorem, which uses the fact that 
gcd(m, n) = 1, states that this is one-to-one and onto. Now define Z1 to 
consist of those integers in {0, 1, 2, 3, ... , n - 1} that are relatively prime to 
n. The size of Z2 is tf>(n). Therefore, we need only prove that, given rela­
tively prime m and n, the sets z;.n and z;. x Z1 have the same size. Sup­
pose k E z;.n ; then gcd(k, mn) = 1 so gcd(k, m )  = gcd(k, n) = 1, and F(k) E 
z;. x Z3 . This means that F may be viewed as a function from z;.n to 
z;. x Z1 . Because the original F is one-to-one, so is the restriction. So all 
that remains is to show that the restriction of F is onto. 
Suppose that (a, b) E z;,. x Z1 . The Chinese Remainder Theorem yields 
a unique x in Zmn such that F(x) = (a, b). We must show that x lies in z;.n . 
But if some prime divided both x and mn, then it would divide one of m and 
n, a contradiction. So F is onto and proves that z;,. n and z;,. x Z4 have the 
same size. 
o 
Knowing that If> is multiplicative suffices to prove Theorem 3. l(f), 
because it follows from the explicit formula in Theorem 3. l(e). The formula 
in Theorem 3.l(f) is easily implemented, as follows. We will not use this 
function explicitly since we can just use If> or Eu lerPhi. 
1 
phi [n_] : = n Apply ['l'imes , 1 -
] 
Map [ First , Factorinteger [n] ] 
{phi [ lOO ] , ʛ [ 100] } 
{ 4 0 ,  4 0 } 
In general we cannot compute tf>(n) when n is very large, because the algo­
rithm requires factoring n and, moreover, it is known that there is no way 

68 
3. EU LER'S tfJ FU NCTION 
to avoid this in general (Exercise 3.3). However, if n can be factored then 
there is no problem. 
{li [ 100 ! ] , li [ 10100 ] }  / / Bxponentrom 
{ 1 1 2 2 8 7 5 7 3 7 2 4 954 1 1 0 8 1 2 4 2 4 2 6 9 055 1 3 5 3 9 4 9 7 1 8 2 9 6 7 3 4 8 7 1 94 4 7 5 4 7 0 6 8 \  
2 4 4 02 3 5 1 2 5 1 4 1 4 8 9 8 5 5 4 3 8 94 2 9 3 5 2 1 6 7 7 05 0 7 7 2 2 6 3 8 1 2 8 3 0 0 6 6 32 3 5 2 3 9 \  
9 1 2 3 6 1 7 4 1 5 1 6 8  1 028 , 4 1 099 } 
To complete the proof of Theorem 3.1 we explain the formulas in parts 
(g) and (h). We start with (h), which is easier. 
Proof of Theorem 3. l(h). Let d be a divisor of n. The integers m in 
{ 1, 2, ... , n) for which gcd(m, n) = d are precisely those integers of the form 
dx where 1 s x s n/d and x is relatively prime to n/d. From the definition 
of </J, there are <fJ(n/ d) such values of x. As d runs through the divisors of n, 
each of the integers 1, 2, ... , n is counted exactly once and therefore 
Ldln <fJ(n/d) = n. As d runs through the divisors of n, so does n/d, which 
means that the preceding sum is identical to Ldln <fJ(d) = n. 
D 
Now on to part (g) which gives a lower bound on </J(n). 
Proof of Theorem 3. l(g). The second inequality is left as an exercise. Let 
q1 , • • •  , q, be the distinct primes dividing n, in increasing order. Then 
r 
1 
r 
1 
<fJ(n) = nn (1 - -. ) d nn(1 - -. )
. 
i=l 
q, 
i=l 
p, 
where the last inequality follows from Qi  Pi· But this is exactly what is 
wanted. 
D 
The lower bound just proved helps us compute the inverse of </J. For 
example, suppose that we want to find all integers x such that <fJ(x) = 100. 
Let x have the distinct prime factors q1 , • • •  , q, . Then 
r 
1 
<fJ(x) = x n ( 1 -
-. ) 
i=l 
q, 
r 
l 
r 
r 
l 
r 
 x n ( 1 - -. )  nPi n ( 1 - -. ) = n (Pi - 1). 
i=l 
p, 
i=l 
i=l 
p, 
i=l 
When r = 5 this last product is 1 · 2  · 4 · 6 · 10, or 480, which is greater than 
100. So r s  4. This means that </J(x)  x0f=1 (1 - 1 /  pi) so, if </J(x) = 100, 
x s 100/ 0f=1 (1 - 1 / Pi) Њ  437.5. Thus, we can simply check the interval 
[101, 438] to find appropriate values of x. 
Select [Range [ lOl , 437 ] , li [ I ]  = =  100 & ]  
{ 1 0 1 , 1 2 5 , 202 , 2 5 0 } 

3 . 1 . EULER'S I/> FUNCTION 
69 
It is a little faster to compute all the ¢'-values at once and then see where 
the lOOs are in that list, as follows. 
100 + Flatten [ Position [lR [Range [ lOl , 437 ] ] ,  100 ] ] 
{ 1 0 1 , 1 2 5 , 202 , 2 5 0 } 
Turning this into a general program is a good exercise. But there is a much 
faster way, though it requires a greater programming effort based on using 
the prime factorization of n to deduce which primes can appear in x. This 
fancier method is implemented in the CNT package as Phiinverse, and the 
package enhances Solve so that it can handle the inverse of ¢1. 
Phi inyerse [ lOOO ] 
{ 1 1 1 1 ,  1 2 5 5 , 1 3 7 5 , 1 8 7 5 , 2008 , 
2 2 2 2 , 2 5 0 0 , 2 5 1 0 ,  2 7 5 0 , 3 0 1 2 , 3 7 5 0 } 
x / .  Solve [lR [ x ]  = =  7 2 0 ,  x ]  
{ 7 7 9 ,  7 9 3 , 8 0 3 , 905 , 925 , 1 0 0 1 , 1045 , 10 8 5 ,  1 1 0 7 , 1 2 0 9 , 1 2 2 1 ,  
1 2 8 1 ,  1 2 8 7 , 1 3 9 5 , 1 4 2 5 , 1 4 4 8 , 1 4 8 5 ,  155 8 , 1 5 7 5 , 1 58 6 ,  1 6 0 6 , 
1 6 1 2 , 1 6 2 8 , 1 6 7 2 , 1 7 0 8 , 1 7 3 6 , 1 8 1 0 ,  185 0 ,  1 900 , 2002 , 2090 , 
2 1 7 0 ,  2 1 7 2 , 2 1 9 6 , 2 2 1 4 , 2 2 3 2 , 2 3 7 6 , 24 1 8 ,  2 4 4 2 , 2508 , 
2 5 6 2 , 2 5 7 4 , 2 6 0 4 , 2 7 0 0 ,  2 7 7 2 , 2 7 9 0 ,  285 0 ,  2 9 7 0 ,  3 1 5 0 } 
The values that turn up as l,il(x) lead to a famous unsolved problem 
called Carmichael's conjecture. From the table of ¢'-values on page 66 you 
can see that whenever a number arises as a ¢'-value, it shows up more than 
once. For example, ¢1(13) = 12, which shows up again as ¢1(21). Some num­
bers do not ever appear; Theorem 3.1 tells us that odd numbers, except 1, 
do not appear, but it is not hard to see that certain even numbers are also 
missing, such as 14 (see Exercise 3.1). Carmichael conjectured that no 
integer shows up exactly once as a ¢'-value. We can make a stronger conjec­
ture by defining the f!-multiplicity of n to be the number of x-values for 
which lfl(x) = n. 
Carmichael's Conjecture. The ¢'-multiplicity is never 1; in other words, 
if lfl(x) = n then there is some y different from x such that l,il(y) = n. 
Sierpinski had conjectured that every number other than 1 does occur 
as a multiplicity. Computations show that every multiplicity under 311 
(except 1) does occur (Exercise 3.9), and in 1998 Kevin Ford [For] proved 
the complete Sierpinski conjecture. 
The PhiMu ltiplicity function from the CNT package just uses Phi­
Inverse. A good programming exercise is to speed up this process by 
precomputing a giant table of ¢'-values, perhaps 100,000 of them, and using 
it to generate multiplicities; that would require a machine with adequate 
memory. The table that follows shows that there are eleven integers whose 
¢'-value is 48, and 48 is the smallest number with this property. The table 

70 
3. EU LER'S I/! FUNCTION 
also shows that every multiplicity between 2 and 11 occurs. The notation VȬ 
is used because this function is also known as the valence of </J. 
FunctionTable [PbiMultiplicity ,  5 0 ,  
FunctionBeading -+  "V• (n) " ,  Fontsize -+ 9 ]  
n V,(n) 
n V.,(n) 
n V.,(n) 
n V., (n) 
n 
V,(n) 
1 
2 
11 
0 
21 
0 
31 
0 
41 
0 
2 
3 
12 
6 
22 
2 
32 
7 
42 
4 
3 
0 
13 
0 
23 
0 
33 
0 
43 
0 
4 
4 
14 
0 
24 
10 
34 
0 
44 
3 
5 
0 
15 
0 
25 
0 
35 
0 
45 
0 
6 
4 
16 
6 
26 
0 
36 
8 
46 
2 
7 
0 
17 
0 
27 
0 
37 
0 
47 
0 
8 
5 
18 
4 
28 
2 
38 
0 
48 
11 
9 
0 
19 
0 
29 
0 
39 
0 
49 
0 
10 
2 
20 
5 
30 
2 
40 
9 
50 
0 
Regarding Carmichael's conjecture, it is not too hard to show that a 
counterexample - a value of n such that VȬ(n) = 1 - must be incredibly 
large. Schlafly and Wagon [SW] showed that such an n must be greater 
than 1010•920•000 (recently extended by Kevin Ford [For] to 101010 ) ; moreover, 
there is every reason to believe that the bound could be extended indefi­
nitely, which would mean, if only it could be proved, that the conjecture is 
true. 
Finally, we mention another elementary thread of ideas surrounding </J. 
D. J. Newman proved recently that, given any positive integers a and b, 
there is an n such that <fJ(an + b) < <fJ(an). However such integers are not 
always easy to find. In particular Newman observed that no n under 
2,000,000 satisfies ¢J(30n + 1) < ¢J(30n). Greg Martin discovered the first 
number that satisfies Newman's equation. It has 1116 digits! To see 
Martin's number, let Pi denote the ith prime. Then let z = p4p5ps · · · 
Pas2PasaPassPass - Then z = l (mod 30). Let n = (z - 1)/ 30. Then, as proved 
by Martin [Mar], ¢J(30n + 1) < ¢J(30n). 
Exercises for Section 3.1 
3.1. Prove that <fJ(n) is never equal to 50. 
3.2. Which integers n have the property that n is divisible by <fJ(n)? 
3.3. Suppose that n = 1696 10714 26634 37950 88165 66546 93070 58932 ... 
98221 and it is known that n is a product of two primes. Suppose further 
that <fJ(n) is known to be 1696 10714 26634 37950 86324 914 71 72767 86428 ... 
51100. Find the prime factors of n. Hint: Perhaps consider the analogous 
problem with some smaller numbers. Or consider the more general problem 
where one is given </J(n) and the information that n is a product of two 
primes. This result says that computing </J(n) in general is at least as diffi-

3 . 1 . EULER'S t/J FUNCTION 
71 
cult as factoring products of two primes. Because the latter is considered to 
be computationally infeasible, there is likely no efficient algorithm for 
computing </J(n) in general. 
3.4. Prove that nǪ (1 - ..l.) ;;:: -
1 
1<2 > , where Pi is the ith prime and n has 
•=l 
p, 
og2 
n 
r distinct prime factors. This completes the proof of Theorem 3.l(g). 
3.5. (a) Use the method outlined in the text, based on identifying an inter­
val that captures all candidates, to write a program that, given n, finds the 
set of x for which </J(x) = n. 
(b) Now program the inverse-</> problem more efficiently by first analyzing 
the prime factorization of n (the power of 2 in this factorization plays a 
critical role) to determine the primes that can show up in x. Then generate 
a list of all candidates, and finish by checking this list to find the solutions. 
The set of candidates gets large, but you should be able to handle n-values 
up to 10000 or more. It seems reasonable to use recursion to built up the 
list of candidates. Use the package function Phiinverse or your work in 
part (a) to check your results. 
3.6. Let A(x) be the average value of </J(n) up to x: A(x) = (1 /x)l:χ=l </>( n). 
Then A(x) is well approximated by a linear function, ex. Perform computa­
tions in an attempt to find the best value of c in such a model. Create some 
graphics to show how well the model fits the data. Hint: c involves TC2• 
Mathematica Tip: Using Sum or Plus to add up numbers causes Mathemat­
ica to form the entire list of summands, which can be deadly when that list 
is large. Using a Do-loop as follows is much better: ( sum = 0 .  ; Do [ sum = 
sum + EulerPhi [ i ]  , { i ,  x } ] ; sum I x ) .  While it is instructive for you to 
program the average function yourself, the CNT package does include two 
functions relevant to this sort of work: Average and AverageList. Use 
?Average and ?AverageList to learn about them. 
3.7. Do some computations in an attempt to estimate the long-term aver­
age of </J(n) I n. It turns out to have the form 6 I TC2 • Using this one can give a 
heuristic argument that if n is restricted to even integers, the long-term 
average of </J(n) I n  is 4 I TC2 • Do some experiments to confirm this. Finally, try 
to estimate the long-term average of </J(p - 1) I (p - 1), where p is prime. 
Such results show that p - 1 is not a typical even number. 
3.8. If f maps integers to integers, define log1 (n) to be the number of times 
f must be iterated, starting with n, to reach a fixed point. If f(x) = Lx/ lOJ, 
then log,(n) is the number of digits in n. Now, the only fixed point of <fJ is 1, 
so logq,(n) is the number of times </> must be applied to get n down to 1. For 
example, logq,(100) = 6. 
FixedPointList [ʛ , 100 ] 
{ 1 0 0 , 4 0 ,  1 6 ,  8 ,  4 ,  2 ,  1 ,  1 } 

72 
3. EU LER'S 4> FUNCTION 
Investigate the log"' function. Prove that logq,(n) s f log2(n)l. Let exp,,(n) be 
the first x such that logq,(X) = n. It was thought for many years that expq,(n) 
would have to be prime. Find a counterexample. 
3.9. Investigate the multiplicity function Vq,(n), which is the number of 
times n occurs as <f>(x). Try to show that all multiplicities up to 50 (or 100, or 
200 or more), occur (except for 1). You could use the package function 
PhiMul tiplici ty, but it is faster, if you have enough memory, to precom­
pute a large number of </>-values, say 50,000 or 100,000, and use that data 
set together with facts about bounds on </> proved in this section, to deduce 
multiplicity information. For a really large computation, speed is less of a 
priority than memory consumption. Our own computations show that every 
multiplicity between 2 and 311 does occur (but Kevin Ford [For] recently 
proved the long-standing conjecture that all multiples (except 1) definitely 
occur). What is the first n for which </J-1 (n) has size 312? 
3.2 Perfect Numbers and Their Relatives 
« The Sum of Divisors Function 
The special properties of certain numbers have fascinated both profession­
als and amateurs for millenia. And no property has exerted a greater 
fascination than perfection: A number n is perfect if it is equal to the sum 
of its divisors, excluding n itself. The first perfect number is 6, which equals 
1 + 2  + 3. The next one is 28. In fact, there is a simple formula for the even 
perfect numbers, but to understand it we must first investigate the sum-of­
divisors function. For k ݀ 0, <Tk(n) is defined to be the sum of the kth powers 
of all the positive integers that divide n. When the subscript is omitted it is 
assumed to be 1; o-(n) is just the sum of n's divisors. So o-(6) = 12. When 
k = 0, o-0 counts a 1 for every divisor, and so gives the number of divisors. 
That function often goes by the special name T(n). 
These functions are built into Mathematica as Divi sorSigma [ k , n ] ,  
but the CNT package allows us to use o- and <Tk. Let us also introduce o-- for 
the reduced o- function, where the number itself is excluded; then n is 
perfect if o-- (n) = n. 
{Divisors [ 2 8 ] , Q'. [2 8 ] , g_- [ 2 8 ] } 
{ { l ,  2 ,  4 ,  7 ,  1 4 , 2 8 } , 56 , 2 8 } 
A formula for T is easy to derive, and the reader might experiment with 
some small numbers in an attempt to discover it. There is a relatively 
simple formula for o-, but understanding it requires that we first show that 
o- is a multiplicative function. That follows from the following more general 
result. But note that o-- is not multiplicative (o--(2) = 1 and o--(3) = 1, but 
o-- (6) = 3), which explains why it is a second-string function. 

3 .2. PERFECT NUMB ERS AND TH EIR RELATIVES 
73 
Proposition 3.3. If f is multiplicative then so is F, defined by 
F(n) = L: f(d) . 
din 
Proof. Observe first that any divisor r of mn, where m and n are relatively 
prime, splits into cd where c divides m, d divides n, and gcd(c, d) = 1. For a 
proof just look at the prime factorization of m n and let c and d be the gcd of 
r with m and n, respectively. Moreover, given c and d dividing m and n, 
respectively, their product is a divisor of mn. 
Now, if gcd(m, n) = 1, we must prove that F(mn) = F(m)F(n), or 
L dlm n f(d) = (l: dim f(d))(l: din f(d)). But this follows immediately from alge­
braic expansion of the right side: if ci are the divisors of m and dj are the 
divisors of n, then the right side is 
({(ct ) + f(c2) + {(ca) + · · · ] [f(d1 ) + f(d2) + f(da) + · · ·] = 
L: t<ci)f(dj) = L: t<cidj) = L: f(d) . 
o 
i,j 
i.j 
dlm n  
The sequence of equalities just given, indeed, the entire proof, can be 
given concrete form using symbolic calculation. As an example, let m and n 
be 4 and 15, respectively. The phrase f [m_] f [ n_ ]  =т f [ m  n ]  (the =т symbol 
is the same as : >} causes the substitution to apply to all products, which is 
all right since the pairs that arise are all relatively prime; f [ l ]  2 requires a 
special case. 
F [ n_] : = Apply [ Plus , Map [ f ,  Divisors [n] ] ]  
left = F [ 60] 
f [ l ] + f [ 2 ] + f [ 3 ] + f [ 4 ] + f [ S ]  + f [ 6 ] + 
f [ l O ]  + f [ 1 2 ] + f [ 1 5 ] + f [ 20 ] + f [ 30 ] + f [ 6 0 ) 
right = F [ 4 ]  F [ l S ]  
( f [ l ) + f [ 2 ) + f [ 4 ) )  ( f [ l ) + f [ 3 ] + f [ S )  + f [ 1 5 ) )  
right = Expand [ right ] 
f [ 1 ] 2 + f [ l ) f [ 2 ) + f [ l )  f [ 3 ) + f [ 2 ) f [ 3 ] + 
f [ l ]  f [ 4 ) + f [ 3 ) f [ 4 ] + f [ l )  f [ S )  + f [ 2 ) f [ S )  + 
f [ 4 ) f [ S )  + f [ l ) f [ l S ]  + f [ 2 ) f [ 1 5 ] + f [ 4 ) f [ l S )  
right = right / .  { f [m_] f [ n_] :-+ f [m n] , f [ l ] 2 -+ f [ l ] } 
f [ l ] + f [ 2 ] + f [ 3 ] + f [ 4 ] + f [ S ]  + f [ 6 ) + 
f [ l O ) + f [ 1 2 ] + f [ l S )  + f [ 20 ) + f [ 30 ) + f [ 60 j 
left = =  right 
True 

74 
3. EU LER'S  FUNCTION 
Proposition 3.4. The function CTk(n) is a multiplicative function of n. In 
particular, CT and T are multiplicative. 
Proof. This follows from Proposition 3.3 because CTk(n) = Ldln dk and f(d) = 
dk defines a function of d that is obviously multiplicative. 
o 
Corollary 3.5. If n's prime factorization is n P? '  then T(n) = n7=l (e; + 1) 
nn 
e; + I 1 
and CT(n) = 
!!.L..:..1 . 
i=l 
p; -
Proof. Because CT and T are multiplicative, we need only establish the 
formulas in the case of prime powers. This is easy for T because we can list 
the e + 1 divisors of pe: {1, p, p2, • • •  , pe }. For CT we must consider 
1 + p + p2 + · · · + pe; but this is a geometric progression and sums to 
(pe - 1) / (p - 1), as desired. 
D 
Note that modern software can handle symbolic sums such as the one 
that just arose. 
i=O 
11!J Perfect Numbers 
Now that we see how to compute CT we can blindly search for some perfect 
numbers. A quick computation gets us four of them. Can you see the pat­
tern they follow? 
perfect = Select [ Range [ lOOOO] , o- [ I ]  == I & ] 
{ 6 ,  2 8 , 4 9 6 , 8 128 } 
Factoring the numbers is a first investigative step. 
Map [ FactorForm, Factorinteger [perfect ] ]  
{ 2 3 , 22 7 ,  2 4 31 , 26 127 } 
The connection between even perfect numbers and primes of the form 28 - 1 
(Mersenne primes) such as 7, 31, and 127 was known to the ancient Greeks. 
Here it is. 
Proposition 3.6 
(Euler-Euclid Formula). 
If 28 - 1 is prime, then 
28-1 (28 - 1) is perfect. Moreover, every even perfect number arises in this 
way. 

3.2. PERFECT NUMB ERS AND TH EIR RELATIVES 
75 
Proof. Showing that Mersenne primes lead to perfect number is a straight­
forward application of the formula for o-(n) and we leave the details to an 
exercise. For the harder direction, suppose that n is even and perfect. Write 
n = 28-1 t where s > 1 and t is odd. Because u(n) = 2 n, we know that 28 t = 
o-(28-1 t) = (28 - l)o-(t). So 
28t 
t 
o-(t) = 28 - 1 = t + 28 - 1 . 
It follows that t / (28 - 1) is an integer and therefore t and t / (28 - 1) each 
divide t. The expression for o-(t) then implies that there can be no other 
divisors of t / (28 - 1). This means that t is prime and t / (28 - 1) = 1, so n = 
28-1 (28 - 1) and 28 - 1 is prime. 
D 
The Euclid-Euler formula tells us that even perfect numbers are in one­
to-one correspondence with Mersenne primes. So if there are infinitely 
many Mersenne primes, a famous unsolved problem, then there will be 
infinitely many even perfect numbers, and vice versa. But this brings us to 
one of the oldest unsolved mysteries of mathematics, as it goes back to the 
ancient Greeks. 
The Odd Perfect Number Problem. Is there an odd perfect number? 
This problem has received a lot of attention and it is known that if 
there is an odd perfect number it must have 29 prime factors (not necessar­
ily distinct), one of them is greater than 1020, and the number must be 
greater than 10300 • The famous nineteenth-century mathematician J. J. 
Sylvester thought hard about it and, summarizing the many conditions that 
an odd perfect number would have to satisfy, came to the conclusion that 
''The existence of [an odd perfect number] - its escape, so to say, from the 
complex web of conditions which hem it in on all sides - would be little 
short of a miracle." Yet, the problem is quite sensitive and perhaps some 
combination of 100 odd primes is perfect; see Exercise 3.12 for a near miss 
discovered by Descartes. For more information on this conjecture see [KW]. 
ȫ Amicable, Abundant, and Deficient Numbers 
If m and n are different integers such that the divisors of n (excluding n 
itself) sum to m and vice versa, then the pair (m, n) is called an amicable 
pair. The first amicable pair is 220 and 284. 
o- [ 2 2 0 ]  
2 8 4  
0- [ 2 84 ] 
2 2 0  

76 
3. EULER'S  FU NCTION 
For 
an 
amicable 
IT- (IT- (n)) = n. 
pair, 
IT(m) + IT(n) = 2 (m + n); 
AmicableQ [n_] : =  ( (s = a- [n] ) -;. n && a- [ s ]  == n) 
Select [Range [ 2000] , AmicableO] 
{ 2 2 0 ,  2 8 4 , 1 1 8 4 , 1 2 1 0 } 
al terna ti vely 
Amicable numbers are not particularly important in number theory, 
but they do have a long history. Perhaps the most amusing application 
comes from a fifteenth-century Spanish book that recommended their use 
in formulating a love potion: Serve the object of your affection 220 grains of 
rice while you eat 284, for example. The experimental support is incon­
clusive. 
The following problem has been much studied. Start with n, form IT- (n), 
IT-(IT-(n)), and so on. The sequence of numbers obtained in this way is 
called an aliquot sequence. What will happen? Well, starting with 25 gets 
to 1 + 5, a perfect number. Perhaps iterating IT- will yield perfect numbers, 
maybe even an odd perfect number. Indeed, any fixed point of this process 
is a perfect number; a cycle of length 2 is an amicable pair. This iteration is 
interesting for several reasons. First, it is tied to the distinction between 
deficient and abundant numbers. A deficient number is one for which 
IT- (n) < n; an abundant number has so many divisors that they add up to 
more than n: IT- (n) > n. 
DeficientQ [ n_] : = a- [n] < n 
AbundantQ [n_] : = a- [n] > n 
Select [Range [ 3 ,  100 ] , AbundantO] 
{ 1 2 ,  1 8 ,  2 0 ,  24 , 3 0 ,  3 6 , 4 0 ,  42 , 4 8 , 54 , 
56 , 6 0 ,  6 6 , 7 0 , 7 2 ,  7 8 ,  8 0 ,  84 , 8 8 , 9 0 ,  9 6 , 1 0 0 } 
Computing problems related to IT illustrate diverse ideas of the theory 
of algorithms. Naturally we are most pleased to have algorithms, such as 
the Euclidean algorithm, that work quickly even on very large inputs. The 
algorithms for computing <f>(n), factoring n, or determining the nth prime 
are fine when n is small, but are useless when n is large. But at least 
algorithms for these problems do exist, even if they take too long. If you 
want to know the nth prime then, in theory, there is a simple way to do it. 
Start counting with 2, 3, 5, and stop when the count reaches n. But if you 
want the lOOOth Mersenne prime then there might be no algorithm. For if 
there turn out to be only finitely many Mersenne primes we may never 
know when we have come to the last one, and so we would not know when 
to tell our computer to stop looking and report "there is no lOOOth 
Mersenne prime." 
The unifying idea for these sorts of thoughts is the unsolvability of the 
halting problem, a fundamental result of computer science. This means 
that there is no computer program that, on input another computer pro­
gram P and an integer n, will determine whether program P halts on input 

3.2. PERFECT NUMB ERS AND TH EIR RELATIVES 
77 
n. In essence this is because there is very little the halt-checking program 
can do other than run P on n. But it won't know when to stop and declare 
"P(n) does not halt" because there is always the possibility that just one 
more step will yield a halt. Of course, particular programs might be amena­
ble to analysis, but general programs are too complex to be understood in a 
universal way. 
It is interesting to come up with specific algorithms whose halting 
status is unresolved, and even more interesting to come up with particular 
instances. The aliquot sequence problem is, perhaps, one such. It is not 
known whether there can be an unbounded aliquot sequence. If the 
sequence does terminate, then it ends in 1, a perfect number, or a cycle, of 
which {220, 284} is the simplest one. 
Aliquot Sequence Problem. Is there an integer n so that the aliquot 
sequence n, u- (n), u-(u-(n)), . . .  is unbounded? 
There was a time when the fate of 138 was unknown. Thanks to a 
decent factoring algorithm, 138 does not present a great challenge to Mathe­
matica. The largest entry is 179931895322, and then the deficient numbers 
take over and the sequence dies out. 
ali = AliguotSeguence [ 13 8 ]  " 
{ 1 3 8 , 1 50 , 2 2 2 , 2 3 4 , 3 1 2 ,  528 , 9 6 0 ,  2088 , 3 7 6 2 , 5598 , 
6 5 7 0 , 1 0 7 4 6 ,  1 3 2 5 4 , 1 3 8 3 0 ,  19434 , « 9 9  terms omitted» , 
4 0 3 8 1 3 5 7 6 5 6 , 6 0 5 7 2 0 3 6544 , 10003 9 3 54 7 0 4 , 
1 7 9 9 3 1 895322 , 9 4 6 8 5 9 6 32 7 8 , 5 1 3 9 9 0 2 1 2 1 8 ,  2 8 3 5 80 8 0 7 6 2 , 
1 8 0 4 6 0 5 1 4 3 0 , 1 7 3 9 6 0 8 1 3 3 8 ,  8 6 9 8 040672 , 8 4 2 6 2 2 6 9 6 4 , 
« 3 7  terms omitted» , 6 1 54 , 3 6 7 4 , 2374 , 1 1 9 0 ,  1402 , 
7 0 4 , 8 2 0 , 944 , 9 1 6 , 694 , 350 , 394 , 200, 2 6 5 , 59 , 1 }  
Figure 3.l(a) shows the entire sequence. Logarithms are used (via the Log­
Li stPlot function from a standard package) so that the image is visually 
appropriate. 
But when we go beyond 138, things get much worse very quickly. No 
one knows what happens to the aliquot sequence of 276. This number is 
seriously abundant in the sense that iterations of u- lead, most of the time, 
to larger numbers. And when the numbers get large, factoring them is 
difficult. A 10-minute computation, using an upper bound of 1035 to shut it 
off, gets us 433 members of the sequence. Current knowledge is that this 
sequence has at least 628 terms. We repeat that this means that we have a 
conceptually simple algorithm (iterate o- until it hits 1 or enters a cycle) and 
a single instance (start with 276), but we do not know, and may never 
know, whether the algorithm halts on this input. 

78 
3. EULER'S tfJ FU NCTION 
(a) 
1 030 
(b) 
1 020 
1 0 10 
1 03 
50 
Aliquot Sequence of 1 3 8  
5 0  
1 0 0  
1 7 8  
Aliquot Sequence of 2 7 6  
.I 
100 
1 5 0  
2 0 0  
2 5 0  
3 0 0  
3 5 0  
4 0 0  4 3 3  
Figure 3.1. These diagrams show the sequences of values obtained by iterating the 
sum-of-divisors function on 138 and 276. The sequence for 138 terminates, but the 
ultimate fate of the sequence for 276 is not known. 
ali = Aliguotsequence [ 27 6 , 1035 ] ;  
Lengtb [ali] 
4 3 3  
Sbort [ali] 
{ 2 7 6 ,  3 9 6 , « 4 29 » , 3 0 8 6 9 5 8 1 32 5 6 1 4 59 6 0 5 2 02 0 3 5 8 7 6 03 5 4 2 2 0 ,  
6 6 3 4 8 6 8 8 4 2 8 0 56499 7 8 6 4 9 9 4 4 0 8 7 6 9 0 0 9 4 8 } 
There are many facets of perfect numbers and the er function that lead 
to interesting questions. For example, are there any triply perfect numbers: 
<r(n) = 3 n? 
Flatten [ Position [a [Range [ 1000] ] / Range [ 1000 ] , 3 ] ] 
{ 1 2 0 ,  6 7 2 } 
This leads to yet another computationally interesting question: Which 
rational numbers arise as values of cr(n) / n? Of course, 2 arises and we just 
saw that 3 shows up. But given a rational, there is no obvious way of telling 
whether it shows up. It has been conjectured by C. W. Anderson that the 
set of rationals that arise in this way is noncomputable. A computation up 
to 30,000 shows that, for example, 5/a and 7/5 are missing. Perhaps they 
show up later. 

3.2. PERFECT NUMB ERS AND THEIR RELATIVES 
79 
sigmaRatios = Table [ a [n] / n , { n ,  30000} ] ;  
Union [ Select [ s igmaRatio& , Denominator [  I ]  = =  3 & ]  ] 
4 
7 
8 
1 0  
{ 3 ' 3 ' 3 ' 3 }  
Union [ Select [ sigmaRatios , Denominator [ I ]  = =  5 & ] ]  
6 
8 
9 
1 2  
1 3  
1 4  
1 6 
1 8  
{ s '  5 '  5 '  5 '  5 '  5 '  5 '  5 }  
There are many more questions regarding the behavior of perfect 
numbers and their relatives. Chapter B in [Guy] is an excellent source of 
additional problems of both a theoretical and computational flavor. 
Exercises for Section 3.2 
3.10. Prove that <Tk is a multiplicative function and derive an explicit 
formula for it in terms of the prime factorization of n. 
3.11. (Euclid) Show that whenever 2n - 1  is prime, 2n-l (2n - 1) is a per­
fect number. 
3.12. (Rene Descartes) Find the flaw in the following proof that an odd 
perfect number exists. Let n = 32 • 72 · 112 
• 132 
· 22021. Then 
<r(n) = (1 + 3  + 32)(1 + 7  + 72)(1 + 11 + 112)(1 + 13 + 132)(1 + 22021) = 
3971 71152378 = 2 · 32 
• 72 · 112 
• 132 
• 22021 = 2 n . 
3.13. Find all integer solutions to l /x +  l /y = 1 / 100. Express the number 
of solutions in terms of one of the functions introduced in this chapter. 
3.14. Is there an odd abundant number? 
3.15. A unit fraction is a fraction of the form 1 / n. A proper unit frac­
tion excludes 1/i . An odd unit fraction has an odd denominator. It is easy 
to write 1 as a sum of distinct unit fractions: 1 = 1 /2 + 1 /3 + 1 /s. Write the 
number 1 as the sum of finitely many distinct odd unit fractions (not using 
1 itself). 
3.16. An integer n, necessarily abundant, is called pseudoperfect if it is a 
sum of some of its divisors (excluding n itself). Find an abundant number 
that is not pseudoperfect. The following problem is unsolved: Is every odd 
abundant number pseudoperfect? 
3.17. True or False: If n is an even perfect number and k > 1, then nk is 
abundant? 

80 
3. EU LER'S tfJ FU NCTION 
3.18 In late 1997, a new record. was set by Mariano Garcia, who found an 
amicable pair that, at that time, was the largest one known (he has since 
found a larger pair). Garcia's pair is {m, n} given below. 
r = 2131 · 51971 - 168605317· 15378049151 
p = 574451143340278962374313859 
c = 211 p89 
q = 136272576607912041393307632916794623 
m = cr((p + q)p89 - 1) 
n = cq((p - r)p89 - 1) 
Each number in the pair has 4829 digits. Show, by computing er of m and n, 
that the pair is amicable. Do not ask a computer for cr(m) or <r(n) directly, 
since that will get hung up on factoring. Use the formula for er directly, 
after confirming that all prime-looking numbers in the formulas are proba­
bly prime via a 2-pseudoprime test. Warning: Do not try the love potion 
based on m grains of rice! 
3.19. An aliquot cycle is a sequence n, <r-(n), <r- (cr-(n)), ... , n. An amica­
ble pair is an example of a 2-cycle. Write a progam that searches for aliquot 
cycles. 
3.20. (H. Wilf) Develop and implement a formula that computes cr(n, 1), 
the sum of the divisors of n that are congruent to 1 (mod 4). Here is an 
1. Write n as 2g NM where the primes in N are 1 (mod 4) and the 
primes in M are 3 (mod 4). 
2. Show that <r(n, 1) = <r(N)cr(M, 1). 
3. Use recursion to solve the problem for M: Write M as qe M1 and look 
at divisors of M that involve q0, q1 , q2, and so on to get 
cr(M, 1) = (1 + q2 + q4 + ... + q2c)<r(M1 , 1) + 
(q + qa + q5 + ... + q2d+1 ) [cr(M1 ) - cr(M1 ' 1)) 
where 2 c is the largest even number less than or equal to e and 
2 d + 1 is the largest odd number less than or equal to e. 
4. Use the algebraic rule 1 + w + w2 + · ·· + wa = (1 - wa+1 ) /(1 - w) with w 
equal to -q and also q2 to turn the preceding formula into the sum­
free recursive formula that follows. 
(1 ( q)e+l) 
q(l q2d+2) 
(M 1) -
- -
(M 1) 
-
(M ) 
<T 
' 
-
1 
<T l •  + 
1 
2 
<T 
1 
+ q  
- q  
5. Put the previous steps together to get a program that computes 
cr(n, 1). 
6. Check your implementation by comparing your results to the result 
of a straightforward sum using 

3.3. EULER'S TH EOREM 
81 
Select [ Divisors ( n ] , Mod [ # ,  4 ]  = = 1 & ] . 
7. Show how the sum of divisors congruent to 3 (mod 4) can be obtained 
from u(n, 1). 
8. Show how the preceding work can be extended to get the sum of the 
kth powers of divisors of n that are congruent to 1 (mod 4); it simply 
requires adding k to various places in the treatment above. 
3.21. Find and implement a formula for o-k11 (n), which adds up ( -l)d dk over 
all divisors d of n. Hints: o-k'' is not multiplicative, but it is close; make use 
of uk, because that is already well understood and implemented in Mathe­
matica as DivisorSigma. 
3.3 Euler's Theorem 
The Euler ¢>-function allows us to generalize Fermat's Little Theorem 
(Theorem 2. 7) to composite numbers. Fermat's Little Theorem can be 
viewed as saying that modular powers for a prime modulus p are periodic 
with period p - 1. The two power grids in Figure 3.2 (see also color plate 2) 
show that there is periodicity for composite moduli too, so long as bases 
coprime to the modulus are used. That gets done with the ReducedResi­
duesOnly option. 
VisualPoverGrid [ lO , ReducedResiduesOnly Ű True] ; 
VisualPoverGrid [ 1 8 , ReducedResiduesOnly Ű True] ; 
i 
2 
5 
6 
8 
9 
a 
3 
7 
9 
i 
a 
l 
5 
7 
1 1  
1 3  
1 7  
Figure 3.2. Two power grids for moduli 1 0  (top) and 18. Only values of a that are 
relatively prime to the modulus are shown, and the periodicity at ¢>(10) = 4 and 
¢>(18) = 6 is evident. 

82 
3. EU LER'S  FU NCTION 
The periodicity occurs at tf>(n). In the case that n is prime, this is just 
n - 1, and that is Fermat's Little Theorem. This result, called Euler's 
Theorem, has a proof that is essentially identical to that for the prime case. 
Theorem 3.7. Euler's Theorem. If m > 0 and (a, m) = 1 then 
aiP<m> = 1 (mod m). 
Proof. Consider .Zυ , the set of integers in Zm that are relatively prime to 
m; suppose that .Zφ = {b1 , ... , b¢<mi l· This is a complete reduced residue 
system, meaning that the entries are distinct modulo m and they represent 
all the residue classes of integers coprime to p. It follows exactly as for 
complete residue systems that {ab1 , ... , ab¢<m>l is a complete reduced resi­
due system also. Here is a quick example. The CNT package has a Reduced­
Res idues [ n ]  function that can be accessed by the standard notation Z'i5 . 
The simplest way to enter this is by the following keystrokes (݁ 5] goes to 
the opposite position in a subsuperscript, dsZ stands for double-struck Z): 
ܾdsZܿ ݂݃-] 15 005]*. 
{Zi5 , multiplied = Mod [ 7  Zi5 , 1 5 ]  , Sort [multiplied] } 
{ { 1 ,  2 ,  4 ,  7 ,  8 ,  1 1 ,  1 3 , 1 4 } , 
{ 7 ,  1 4 , 1 3 , 4 ,  1 1 ,  2 ,  1 ,  8 } , { 1 ,  2 ,  4 ,  7 ,  8 , 1 1 ,  1 3 , 14 } }  
Therefore the products of the two systems are congruent: 
¢(m] 
¢(m] 
a¢(m) n bj = n bj (mod m) . 
j= l 
j= l  
The product is relatively prime to a, and so can be cancelled, leaving 
atP!ml = 1 (mod m). 
D 
One standard application of Euler's Theorem is to hand calculations of 
large powers. If you want to know 101000 (mod 21), use the fact that t/>(21) is 
12 and 1012 = 1 (mod 21). Then 101000 = 1083·12+4 = (1012)83 104 = 104 = 1002 = 
(-4)2 = 16 (mod 21) . The following corollary shows the general rule underly­
ing this sort of computation. 
Corollary 3.8. Suppose that s is relatively prime to each of a and b and 
a =  b (mod tf>(m)). Then sa = sb (mod m). 
Proof. Write a as k¢J(m) + b. Then sa = sk¢<m>+b = stf>l.m>ksb = sb (mod m). 
o 

3.3. EU LER'S THEOREM 
83 
Euler's Theorem can be restated as: If gcd(a, n) = 1, then 
a1°·1·2•3····' (mod n) is periodic with period tf>(n). But an investigation of the 
power grids, or some numerical computation, will show that there is some 
interesting periodicity at work even in the cases where gcd(a, n) -:/= 1. 
Proposition 3.9. The power sequence aliPCnJ.snl+I.iP<n>+2 
. . . .  1 (mod n) is periodic 
with period tf>(n). 
Proof. 
Factor n as p" q/3 · · .. It suffices to show that aiP<n> = a2<1>cnJ (mod n), 
because all others follow by multiplication by a. And it suffices to work 
modulo p", for the other powers follow similarly, and then the desired 
congruence will be true modulo n. 
Case 1: p divides a. In this case aiPfn> = 0 (mod p"). To see this, it 
suffices to know that tf>(n) % a. But tf>(n) d tf>(p") = p" - p"-1 % 2"-1 % a. 
Case 2: p does not divide a. Then aiPCnl = aiP<P"liP<nfp"l = 1iP<nfp"l = 1 (modp"), 
using Euler's Theorem. 
o 
A consequence of this proposition is that when looking at power grids, 
and including all bases a, one need never look at power grids beyond the 
2nth column. 
In fact, there are some values of n for which the statement of Euler's 
Theorem holds in as strong a form as is possible for any base a. Can you 
discover which n have this property? For which n is it true that 
a'1•2•3····' (mod n) is periodic with period tf>(n)? The details are left to Exer­
cise 3.23. 
Exercises for Section 3.3 
3.22. Find an example to show that Proposition 3.9 cannot be improved by 
starting earlier, with the power aiP<nl-1 •  
3.23. Find as many integers n as you can for which, for any integer a, 
a11•2•3•···1 (mod n) is periodic with period tf>(n). Try to find a characterization of 
the set of n that work, and then prove that if n is not in this set, the power 
sequence is not periodic. 
3.24. Show how Euler's Theorem can be used to solve a congruence of the 
form ax = b (mod n) where n is composite. Start by thinking about the 
example 34x = 14 (mod 90). Hint: Isolate x by multiplying both sides by an 
appropriate power of 34. 

84 
3. EULER'S </J FU NCTION 
3.4 Primitive Roots for Primes 
ȭ The Order of an Integer 
Euler's Theorem leads naturally to the mod-m order of an integer. If a and 
m are relatively prime, then the· mod-m order of a is the least positive 
integer e such that ae = l (mod m); we denote this by ordm (a). If a and m 
have a common divisor greater than 1, then no power of a will ever be 
1 (mod m), and the order is undefined. Euler's Theorem says that 
ordm (a) s efJ(m). A natural question is whether the order equals efJ(m). If it 
does, then a is called a primitive root for m. For example, 2 is a primitive 
root for 13. 
PowerMod [ 2 ,  Range [ l2 ] , 1 3 ]  
{ 2 ,  4, 8 , 3 , 6 , 1 2 , 1 1 ,  9 , 5 , 1 0 , 7 , l }  
But 3 is not. 
PowerMod [ 3 ,  Range [ l2 ] , 1 3 ]  
{ 3 , 9 , 1, 3 , 9 , 1 ,  3 , 9 , 1, 3 , 9 , 1 }  
The next lemma emphasizes the central property of primitive roots: the 
eth powers, e 
= 1, ... , <fJ(m) are all distinct and take on all values in z;,. . 
Lemma 3.10. If g is a primitive root for m then every integer that is 
relatively prime to m is congruent to ff for some i 
= 1, 2, ... , efJ(m). Equiva­
lently, {gi : i 
= 1, ... , </J(m)} is a complete reduced resude system modulo m. 
Proof. The efJ(m) integers g, g2 , g3 , • • •  , g><m> are distinct modulo m, for if 
gi = gj (mod m) , with i < j, then gj-i = 1 (mod m), contradicting the hypothe­
sis on g. The powers are all relatively prime to m and because there are 
<fJ(m) of them, they must exhaust all the possiblities in z;,. . 
o 
Primitive roots and the structure of the order function play an impor­
tant role in prime testing - finding a primitive root can be a crucial step in 
proving that an integer is prime - and we will study them in detail in this 
section and the next. Our first lemma tells us that when we know ordm (a), 
we know all about the powers of a that are 1 (mod m): they are precisely the 
eth powers where e is a multiple of ordm (a). 
Lemma 3.11. Suppose that gcd(a, m) 
= 1. Then ax = 1 (mod m) if and only 
if ordm (a) divides x. 
Proof. All orders and con̘ruences are modulo m. The reverse direction is 
clear: ax = aord<a>·k = (aord<a> ) 
= 1. For the other direction, suppose ax = 1. 

3.4. PRI M ITIVE ROOTS FOR PRI M ES 
85 
Write x as q · ord(a) + r, where 0 :s; r < ord(a). Then 1 = ax = aq·ord ral + ' = 
aq·ord (al ar = a', a contradiction to minimality of ord(a) unless r = 0. 
D 
Note that this result can be interpreted as: ax = a0 (mod m) if and only 
if x = 0 (mod ordm (a)). More generally (proof left as exercise): ai = 
aj (mod m) if and only if i = j (mod ordm(a)). 
Corollary 3.12. Suppose that gcd(a, m) = 1 .  Then ordm(a) divides tf>(m). 
The result of this corollary can be used to get an algorithm for computing 
orders. Just check all the divisors of tf>(m) and take the first one that works. 
As an example, the order of 5 modulo 17 must be one of the divisors of 
tf>(l 7), which is 16. So the only choices are 1, 2, 4, 8, or 16. But 52 = 25 = 8, 
54 = 82 = 64 = -4, and 58 = (-4)2 = 16 (mod 17), so the order of 5 must be 16. 
And this means that 5 is a primitive root for 17. 
Theorem 3.13. Order-of-Powers Theorem. If ordn(a) = t, then for any 
u, ordn(au) = t/ gcd(t, u). 
Proof. 
All orders and congruences are modulo n. Let s = ord(au), 
d = gcd(t, u), t1 = t Id, ui = u Id. Then t1 and u1 are relatively prime. Now, 
(au)11 = autfd = (a1)u1 =1 (mod n), so s divides ti . Our goal is s = t1 , so we 
must show that t1 divides s. We have aus = (au)s = 1, so t divides us. This 
means that ti d divides ui ds, so ti divides ui s. But t1 and u1 are relatively 
prime, so t1 divides s. 
o 
Corollary 3.14. If m has a primitive root, then m has exactly tf>(tf>(m)) 
primitive roots. 
Proof. If r is a primitive root, the powers ru ,  u = 1, 2, ... , tf>(m), form a 
complete reduced residue system. So we need only check which of these are 
primitive roots. By the Order-of-Powers Theorem, the order of ru is 
tf>(m)/gcd(tf>(m), u). This is tf>(m) whenever gcd(tf>(m), u) = 1, and there are 
tf>(tf>(m)) such powers u. 
o 
We saw earlier that 2 is a primitive root for 13. Here is the list of all 
such primitive roots. There are four of them because tf>(13) = 12 and 
t/>(12) = 4. 
PrimitiyeRoots [ l 3 ]  
{ 2 ,  6 ,  7 ,  1 1 }  
The Order-of-Powers Theorem has a consequence for our knowledge of 
pseudoprimes. Recall that there are numbers, such as 561, that are b­
pseudoprimes for every b coprime to 561. This aberrant behavior can never 
happen for a prime power. The proof that follows uses the result, proved in 
the next subsection, that every prime has a primitive root. 
Proposition 3.15. Let n = ܺ where p is an odd prime, and let b be a 
primitive root for n. Then n is not a b-pseudoprime. 

86 
3 .  EULER'S I/! FU NCTION 
Proof. Assume j ;;:: 2 because primes are not pseudoprimes. Because b is a 
primitive root, ordnb = <fJ(pj) = τ-1(p - 1), which is divisible by p. But 
n - 1 = pj - 1 is not divisible by p and so t/>(pj) cannot divide n - 1, whence 
bn
-l '$ 1 (mod n). 
D 
 Primes Have Primitive Roots 
We now prove the first important theorem about primitive roots (discovered 
by Gauss, who also found the characterization of numbers admitting primi­
tive roots that is proved in the next section). 
Theorem 3.16. Every prime has a primitive root. 
The proof of Theorem 3.16 requires some preliminary work. 
Theorem 3.17. Lagrange's Theorem. If p is prime, then a polynomial of 
degree n (n ;;:: 1) with integer coefficients and leading coefficient not divisi­
ble by p has at most n solutions in Zp · 
Proof. Because Zp is a field, this theorem is a special case of the more 
general result of algebra that a polynomial of degree n with coefficients in a 
field has at most n roots in the field. We prove the case at hand by induc­
tion. If n = 1, then the polynomial is a1x + a0 where p does not divide a1 . A 
root in Zp corresponds to a solution of a1x = -a0 (mod p), and we know that 
this has a unique solution -a0ai1 • 
Now assume that the result is true for degree n - 1 and assume, to get a 
contradiction, that f(x) = an xn + an-1 xn-1 + ... + a1 x + ao has n + 1 incongru­
ent roots modulo p. Let the roots be Po •
. . .  , Pn· Then 
f(x)-f(Po> = an (xn - Pon) + an_i (xn-l - Pon-l) + · · ·  + ai (x - Po> 
= an (x-Po><xn-1 + xn-2 Po + ... + xPo n-2 + Po n-l) + an-1 (x-Po> 
cxn-2 + xn-3 Po + · · · + x Po n
-3 + Po n
-2> + · · · + a1 <x - Po> 
= (x - p0)g(x), where g has degree n - 1. 
Now, look at the n numbers Pk. k > 0. We know that p divides f(pk) - f(Po), 
so p divides (Pk - Po)g(Pk>· Because Pk and Po are distinct modulo p, p 
divides g(pk ) . This contradicts the inductive hypothesis. 
o 
Theorem 3.18. If p is prime and d divides p - 1, then the dth degree 
polynomial xf-1 = 0 has exactly d solutions mod-p. 
Proof. Write p - 1 as dk. Then 
xp
-l - 1 = (xd - l)(ɍ<k-ll + ɍ<k-2> + · · · + xd + 1) = (xd - l)g(x) . 

3.4. PRIM ITIVE ROOTS FOR PRI M ES 
87 
By Fermat's Little Theorem, we know that each of the p - 1 numbers 
1, 2, ... , p - 1 is a solution of xP-l - 1 = 0 (mod p). Thus each of these num­
bers is a mod-p root of either r1 - 1 or g(x). But g(x) has degree d(k - 1), and 
so, by Lagrange's Theorem, has at most d(k - 1) roots. This means that 
xd - 1 has at least (p - 1) - (d(k - 1)) roots. But this quantity is 
p - 1 - (p - 1) + d, or d, as desired. 
D 
Solve can handle modular equations when the modulus is not too 
large. Here is an example having 37 solutions, as predicted by the preced­
ing theorem, because 7918 = 2 · 37 · 107 
solns = x I .  Solve [ { x37 = =  1 ,  Modulus = =  7 ! H 9 } , x] 
Length [ solns ] 
{ 1 ,  6 ,  3 6 , 2 1 6 , 2 2 0 , 7 5 5 , 7 8 8 , 8 8 6 , 1015 , 1 2 9 6 , 
1 3 2 0 , 1 4 8 9 , 1 5 6 8 , 2 7 7 1 ,  2 9 0 1 , 3 2 6 2 , 3423 , 3 7 3 4 , 3909 , 
4 4 4 3 , 4 5 3 0 , 4 6 1 1 ,  4 7 0 0 , 4728 , 4 8 6 4 , 4930 , 5 3 1 6 , 5427 , 
5 8 2 3 , 6 0 9 0 , 6 10 1 ,  6 5 6 6 , 6 7 2 5 , 706 1 , 7 6 1 6 , 7 7 2 0 , 7 7 7 6 } 
37 
Theorem 3.19. If p is prime, then the number of incongruent integers 
whose order mod-p is d is ʡ(d) if d divides p - 1, 0 otherwise. 
Proof. For each d dividing p - 1, let F(d) be the number of integers in 
{1, . . .  , p - 1) of order d. If F(d) > 0, then d divides p - 1 by Corollary 3.12. 
Therefore p-1 = Ldlp- l F( d). But Theorem 3.l(h) says that p - 1  = 
Ldlp- l ʡ( d). So if we can show F(d) :5 ʡ(d) when d divides p - 1 we will be 
done, for that will mean that F(d) must equal ʡ(d) in each case. Fix d, a 
divisor of p - 1. If F(d) = 0, we have the inequality. If not, there is at least 
one b such that ordp(b) = d. This means that each bi, i = 1, ... , d satisfies 
xd - 1 = 0  and hence, by Theorem 3.18, there are no other solutions. But 
among these d solutions, there are exactly ܻ(d) of them that have order d: 
this follows from the Order-of-Powers Theorem, because they are the ones 
whose exponent is coprime to d. 
D 
Now the proof that every prime has a primitive root is complete. 
Proof of Theorem 3. 16. If p is prime, then Theorem 3.19 states that the 
number of integers of order p - 1 is ʡ(p - 1). This is positive, so there is at 
least one b having mod-p order equal to p - 1. 
o 
« Repeating Decimals 
A rational number is a number of the form r / s where r and s are integers. 
The rationals all have decimal expansions that are eventually periodic, and 
any eventually periodic decimal represents a rational number. We prove 
this now, and then discuss a connection between decimal expansions and 
primitive roots. 

88 
3 .  EU LER'S ; FUNCTION 
Proposition 3.20. Every rational number has a decimal expansion that 
consists of an initial part (the preperiod) followed by a periodic part. 
Conversely, every eventually periodic decimal expansion represents a 
rational number. 
Proof. We will only sketch the main ideas. Filling in all the details is a 
good exercise. If r /s is rational, imagine performing the long division as you 
learned in grade school. At each step there will be a remainder less than s. 
Therefore, after finitely many steps, the remainders must repeat; this 
means that the resulting decimal expression - the quotient - will start 
repeating at that point. 
For the other direction, suppose that x = m.abc ... defg ... hefg ... hefg ... h ... 
where m is an integer, the preperiod abc ... d has length r, and the periodic 
part efg ... h has length s. Then, using the formula for the sum of a geometric 
series, 
b 
efg ... h 
.४ 
h 
a c ... d 
1Qi'+B 
1 ( b 
d 
e,g. 
· ·  ) 
x = m + 
1or 
+ 1 - _1_ 
= m + 1or a c. .. + 10s - 1 . 
10• 
This last is a sum of rational numbers, and so is rational. 
o 
Mathematica has some functions for dealing with decimal expansions of 
rationals. RealDigits returns the preperiod and period and FromDigits 
does the opposite. 
Rea1DigiǓs [ 4 1 1 1 / 33000] 
{ { { 1 , 2 ,  4 } } ,  { 5 , 7 } } 
FromDigUs [ { { { l ,  2 ,  4 } } ,  { S ,  7 } } ]  
4 1 1 1  
33000 
Now, some rationals have periods that are as long as possible: for 
example, the period of 1h is 6 which, by the proof of Proposition 3.20, is the 
largest possible. 
RealDigUs [ 1 I 7 ]  
H [ l  I 7 ,  3 0 ]  
{ { { } } ,  { 1 ,  4, 2 , 8 , 5, 7 } } 
0 . 1428 5 7 1 4 2 8 5 7 1 4 2 8 5 7 1 4 2 8 5 7 1 4 2 8 5 7  
This leads to the question: Which rationals r / s have the property that 
the periodic part of the decimal expansion has length s - 1? We will not 
prove it here, but it turns out that the answer is: r / s has decimal period 
s - 1 if and only if s is prime and 10 is a primitive root for s. Here is a 
computation that finds all these fractions of the form 1 / s, where s s 200. 

3.4. PRI M ITIVE ROOTS FOR PRI M ES 
89 
Select [ Range [ 2 , 200 ] , Length [ RealDigits [ l / I ] [2] ] = =  f - 1 & ]  
Select [ Range [ 2 , 200] , OrderMod [ 10 ,  # ]  = =  I - 1 & ]  
{ 7 ,  1 7 , 1 9 , 23 , 2 9 , 4 7 , 5 9 , 6 1 ,  97 , 
109 , 1 1 3 , 1 3 1 ,  1 4 9 , 1 6 7 , 1 7 9 , 18 1 ,  1 9 3 } 
{ 7 ,  1 7 , 1 9 , 2 3 , 2 9 , 4 7 , 5 9 , 6 1 ,  97 , 
109 , 1 1 3 , 1 3 1 ,  1 4 9 , 1 6 7 , 1 7 9 , 1 8 1 ,  1 9 3 } 
And here is the result that describes the whole situation in base 10; similar 
results hold for base b (see [Ros, §10.1] for proofs). 
Theorem 3.21. Suppose that x = r Is where r and s are positive integers 
and r < s. Write s as 2a 5b y where gcd(y, 10) = 1. Then the length of the 
periodic part of the decimal representation of x is ordy(lO) and the length of 
the preperiodic part is max(a, b). 
Exercises for Section 3.4 
3.25. If b has order 360 (mod m), what is the order of b150? 
3.26. Suppose gcd(a, m) = 1. Prove that ai = aj (mod m) if and only if i = 
j (mod ordm (a)). 
3.27. If g is a primitive root modulo 67, what powers of g represent the 
other primitive roots modulo 67? Do this by hand. 
3.28. Show that if p is prime and d is relatively prime to p - 1, then every 
positive integer less than p is congruent to the dth power of some other 
integer. 
3.29. (D. Brizolis [Guy, p. 248]) Investigate by computations the following 
two assertions, which are unproved: 
(a) If p is prime, then p has a primitive root g such that gcd(g, p - 1) = 1. 
(b) If p is prime, then p has a primitive root g such that, for some i, gi = 
i (mod p). 
3.30. For each d in A =  {1, 2, 4, 13, 26, 52) find those values of a for which 
xd = a (mod 53) has exactly d solutions modulo 53. For each d in A, what 
are the orders of the corresponding values of a? What are necessary and 
sufficient conditions on the order of a so that xd = a  (mod p) has exactly d 
incongruent solutions when d divides p - 1? 
3.31. Implement the formula in the proof of Proposition 3.20 via a program 
that returns the exact rational represented by a decimal expression with a 
given preperiod and period. 
3.32. Implement a routine that, given a rational, returns the lengths of the 
preperiodic and periodic parts in its decimal expansion. 

90 
3. EU LER'S  FU NCTION 
3.5 Primitive Roots for Composites 
Which integers have primitive roots? There is a characterization, but it is a 
little tricky and hard to guess from the data. Here is how to find all the 
integers under 100 that have primitive roots (where we use the Primitive­
Roots function from the CNT package). Of course, all the primes show up. 
Can you detect any patterns to the nonprimes in the list? 
Select [ Range [ lOO ] , PrimitiveRoots [ I ] ;. { }  & ]  
{ 2 ,  3 ,  4 ,  5 ,  6 , 7 ,  9 ,  1 0 ,  1 1 ,  13 , 1 4 , 1 7 ,  1 8 , 1 9 ,  2 2 , 23 , 2 5 , 26 , 
2 7 , 2 9 ,  3 1 ,  3 4 , 37 , 3 8 , 4 1 ,  43 , 4 6 , 4 7 , 4 9 ,  SO , 53 , 54 , 5 8 , 5 9 , 
6 1 ,  6 2 , 6 7 , 7 1 ,  73 , 7 4 , 7 9 ,  8 1 ,  8 2 , 8 3 , 8 6 , 8 9 ,  9 4 , 9 7 , 9 8 } 
We will get the complete characterization (Theorem 3.25) by working in 
steps. 
Lemma 3.22. The only powers of 2 that have primitive roots are 2 and 4. 
Proof. The small cases are easy: 1 is a primitive root for 2 and 3 is a 
primitive root for 4. For powers of 2 beyond 4 we prove the stronger result 
that for any odd s, if k ;;:: 3 then s2k-2 = 1 (mod 2k). This shows that s cannot 
be a primitive root, because </J(2k) = 2k-1 • Use induction on k. We already 
know that s2 = l (mod 8), so assume k ;;:: 3 and s2k-2 = 1 (mod 2k) for any odd 
integer s. Then 2k divides s2k-2 - L Squaring a number doubles the expo­
nent of 2, so 22k divides s2k- i - 2s2k-2 + 1. We will use only the weaker fact 
that 2k+l divides s2t- i - 2s2k-2 + 1. Working modulo 2k+l, the inductive 
hypothesis reduces this last expression as follows. 
as required. 
D 
Lemma 3.23. If p is an odd prime and g is a primitive root for p, but not 
for pk, then g + p is a primitive root for pk. 
Proof. Let e = ordPk (g). Then pk divides if - 1, so p divides this as well, 
which means that e is a multiple of ordp (g), which is p - 1 by hypothesis. 
Because g is not a primitive root for pk, e divides but is not equal to 
(p - l)pk-1. This implies that 
Because g + p is also a primitive root for p, its order modulo pk must be 
divisible by p - 1 and must divide (p - l)pk-1 . It suffices to show that 
ordPk (g + p) is not a divisor of (p - l)pk-2. We need a fact about binomial 

3.S. PRIM ITIVE ROOTS FOR COM POS ITES 
91 
coefficients: (a ǩb ) pi is divisible by pb+2 for j ;;:: 2. Because p is odd, this is 
clear when j = 2. For j ;;:: 3, the expression has the form mpb pi I j!, and it is 
easy to see that there are at least two more factors of p in pi than there are 
in j !. We use the binomial theorem as follows, where the preceding fact is 
used in the first step to eradicate all but the first two terms of the expan­
sion modulo pk. 
(g + p)(p-l)pk-2 ;: g<P-l)pk-2 + (p - l)pk-2 g<p-l)pk-2_1 p 
= 1 - g<P-l>pk 2  pk-1 (mod pk) 
Because p does not divide any power of g, the right side of this last congru­
ence is not 1, and so ordPk (g + p) does not divide (p - l)pk-2. This means 
that the order of g + p must be (p - l)pk-l, which is </J(pk). 
o 
Lemma 3.24. If p is an odd prime and g is a primitive root for pk, then 
either g (if g is odd) or g + pk (if g is even) is a primitive root for 2 pk. 
Proof. Assume that g is odd. As in the proof of Lemma 3.23, ord2p• (g) must 
be divisible by ordPk (g). But the latter is </J(pk), and because </J(pk) = </J(2pk), 
g is a primitive root for 2pk. If g is even, then g + pk is odd and the previous 
case applies. 
D 
The preceding three lemmas complete the proof of one direction of 
Gauss's characterization, which we now state. 
Theorem 3.25. An integer m admits a primitive root if and only if m is 2, 
4, a power of an odd prime, or twice a power of an odd prime. 
All that remains is to show that all other integers do not have primitive 
roots. The numbers not yet covered have the form m n where m and n are 
relatively prime and larger than 2. One more lemma will finish the job. 
Lemma 3.26. Suppose that b, m, and n are pairwise relatively prime. Then 
ordmn(b) = lcm[ordm (b), ordn(b)]. 
Proof. Let e = ordmn(b) and f = lcm[ordm(b), ordn(b)]. Then be = 1 (mod mn) 
and so be = 1 modulo each of m and n. This means that each of ordm (b) and 
ordn(b) divides e, so their lcm does too. So f divides e. And bf = 1 modulo 
each of m and n, and therefore bf = 1 (mod mn) so e divides f. Therefore 
e = f. 
D 
This lemma tells us that the order of any element modulo m n must 
divide lcm[</J(m), </J(n)]. If m and n are larger than 2, then both </J-values are 
even, and so lcm[</J(m), </J(n)] < </J(m)</J(n) = </J(mn), and this means the order of 
any b is less than </J(mn). 
D 
Recall that when n admits a primitive root, there are precisely </J(</J(n)) of 
them. Here's an example. 

92 
3. EULER'S I/! FUNCTION 
n = 2 1 32 ; prs = Primit;iyeRoots [n] 
{Length [prs ] , j [j [ n ] ] }  
{ 7 ,  1 1 ,  1 5 ,  3 3 , 37 , 4 1 ,  4 5 , 5 9 , 63 , 6 7 , 7 1 ,  8 5 ,  93 , 97 , 1 1 1 ,  
1 1 5 ,  1 1 9 ,  1 2 3 , 137 , 14 1 ,  145 , 1 4 9 , 1 6 3 , 1 6 7 , 1 7 1 , 1 7 5 , 
1 8 9 ,  1 93 , 1 9 7 , 20 1 ,  2 1 5 ,  2 1 9 , 2 2 3 , 2 2 7 , 2 4 1 ,  2 4 5 , 2 5 3 , 
2 6 7 , 2 7 1 ,  2 7 5 , 279 , 2 9 3 , 297 , 3 0 1 , 305 , 3 2 3 , 3 2 7 , 3 3 1 }  
{ 4 8 ,  4 8 } 
Exercises for Section 3.5 
3.33. What are the possible orders for an integer modulo 1423, and how 
many positive integers less than 1423 are there of each order? 
3.34. Show that if there is no primitive root for n, then the order of each 
element divides </J(n) /2. 
3.35. Let p be an odd prime. Show that Lemma 3.23 implies that there are 
at least </J(p - 1) (pk
-l + 1) / 2 primitive roots modulo pk. 
3.36. Calculate the number of primitive roots modulo pk for various values 
of an odd prime p and integer k 2: 2. How do these numbers compare with 
the minimum established in Exercise 3.35? 
3.37. Prove a stronger form of Lemma 3.23: If g is a primitive root for p but 
not for pk and if a is not divisible by p, then g + a p is a primitive root for pk. 
3.38. Use Exercise 3.37 to prove that there are at least <f>(p - l)pk-2 (p - 1) 
primitive roots for pk when k 2: 2. How does this new minimum compare 
with the actual number of primitive roots for various values of odd primes p 
and integers k 2: 2? 
3.39. In Exercise 2.44, you were asked to do computations to support the 
Monier-Baillie-Wagstaff formula that the number of witnesses for n is 
<f>(n) - npln gcd(n - 1, p - 1). You should now be able to prove this formula. 
Hint: Show that if p is a prime divisor of the odd integer n and pe is the 
highest power of p that divides n, then the number of residues a, modulo 
pe, for which an-l = 1 (mod pe) is the gcd of n - 1 and p - 1. Then use the 
Chinese Remainder Theorem to show that the number of residues a, mod­
ulo n, for which an-l = 1 (mod n) is npln gcd(n - 1, p - 1). 

3.6 The Universal Exponent 
߈ Universal Exponents 
3.6. THE U N IVERSAL EXPONENT 
93 
A universal exponent for m is an integer e such that ae = 1 (mod m) for 
every a relatively prime to m. Euler's Theorem tells us that efJ(m) is a univer­
sal exponent. Sometimes efJ(m) is the smallest one, but most of the time 
there is a smaller universal exponent Consider m = 8. Then efJ(8) = 4, but 2 
serves as a universal exponent because 12, 32, 52 , 72 are all congruent to 
1 (mod 8). Or look at m = 15: a universal exponent is 4 even though efJ(l5) 
is 8. 
PowerMod [Zi5 , 4 ,  1 5 ]  
!l [ 1 5 ]  
{ l ,  1 ,  1 ,  1 ,  1 ,  1 ,  1 ,  1 }  
8 
Define A(m) to be the least universal exponent for m, also called 
Carmichael's lambda. Some traditional applications of efJ really depend 
only on .\, so it is worth knowing how to compute it. There is a formula that 
is very similar to the one for efJ. 
Theorem 3.27 . .\(2) = 1; ,\(4) = 2; .\(28) = 2s-2 if r % 3; and .\(pk) =  t/J(ph) if p 
is an odd prime. In general, write n as 2s nσ=I pf' , where each Pi is an odd 
prime; then .\(n) = lcm[.\(2'), t/J(pC' ), ... , t/J(Pܼ' )]. 
Proof. Simple inspection takes care of 2 and 4. For 28 we already know 
that s - 2 is a universal exponent by the proof of Lemma 3.22. We need a 
little bit more, namely, that s - 2 is the least universal exponent. So we 
need a t such that ord2• (t) = r - 2. It turns out that t = 5 works; verification 
is left as an exercise (Exercise 3.40). The case of powers of odd primes is 
easy because such numbers have primitive roots, which proves that t/J(pk) is 
the least universal exponent. 
The general formula for .\(n) follows immediately from the following 
auxiliary fact, which allows us to paste together the results for prime 
powers. 
If n = ab where a and b are relatively prime and less than n, then 
• there is an integer s such that ordn(s) = lcm[.\(a), ,\(b)] 
• ,\(n) ,,;, lcm[.\(a), .\(b)] 
Proof of fact: We know that the desired special value s exists for prime 
powers, because a primitive root does the job. So we can use induction, 
where the inductive hypothesis gets us s and t such that orda(s) = .\(a) and 

94 
3. EULER'S I/! FU NCTION 
ordb(t) = -'.(b). Use the Chinese Remainder Theorem to find u congruent to 
s (mod a) and t (mod b). Then by Lemma 3.26, 
ord,,b(u) = lcm[ord,,(u), ordb(u)] = lcm[orda(s), ordb(t)] = lcm[-'.(a), -'.(b)] . 
Now, it is clear that lcm[-'.(a), -'.(b)] is a universal exponent for n because it is 
a multiple of universal exponents for a and b. But the existence of s shows 
that it is the least universal exponent. 
o 
Carmichael's A function is built into Mathematica (version 4) as Car­
michaelLambda. Our CNT package allows us to use just A. 
J, [ 102 ] 
1 6 
Note that -'.(n) is even unless n = 2, if m divides n then -'.(m) divides A(n), and 
A(n) always divides l/J(n). In fact, -'.(n) can be quite a bit less than <f>(n); here 
are some values for which A is less than one tenth of <f>. 
Select [ Range [ lOOO] , J, [ I ]  < li [ I ]  I 10 & ] 
{ 24 0 , 2 5 2 , 2 7 3 , 3 1 5 , 3 6 4 , 3 9 9 , 4 5 5 , 4 6 8 , 4 8 0 , 4 8 1 , 504 , 5 1 3 , 520 , 
532 , 544 , 5 4 6 , 560 , 5 8 5 , 624 , 6 3 0 , 6 5 1 , 6 6 5 , 6 8 0 , 6 8 4 , 6 9 3 , 7 0 3 , 
7 2 0 , 7 2 8 , 7 4 1 ,  756 , 7 7 7 , 7 8 0 , 7 9 3 , 7 9 8 , 8 1 6 , 8 1 9 ,  82 5 ,  8 4 0 , 
8 5 5 , 8 6 8 , 8 8 0 , 903 , 9 10 , 936 , 945 , 94 9 ,  9 6 0 , 9 6 2 , 9 8 8 , 9 9 9 } 
 Power Towers 
Here is a pretty application of A to a computational problem: What is 
222"" (mod 719)? (We use the typographical convention that ab< always 
means aW>; in other words, the bracketing is top-down.) This is a simple­
sounding problem, but the numbers that arise, especially if instead of eight 
2s we had one hundred or more 2s, are so huge that some sophisticated 
ideas are needed to answer it. First we show that <f> can be replaced by A in 
Corollary 3.21. 
Lemma 3.28. If s is relatively prime to m and a =  b (mod -'.(m)), then sa = 
sb (mod m). 
Proof. Write a as k-'.(m) + b. Then sa = skA<m>+b = (sA<m>)k sb = sb (mod m). 
o 
Here is how the lemma can be used to answer the tower-of-2s question. 
Let's introduce the notation a t  n for the height-n tower aa" ; then the 
sample problem asks for 2 i 7(mod 719). First we need the result of iterating 
A six times on 719. 

He&tLi&t [,6, 7 1 9 ,  6 ]  
{ 7 1 9 ,  7 1 8 ,  3 5 8 , 1 7 8 , 8 8 , 10 , 4 ) 
3.6. THE UN IVERSAL EXPON ENT 
95 
This means that A(lO) = 4, A(88) = 10, and so on. Now we work down from 
the top, using the lemma (and PowerMod) at each stage. 
2 = 2 (mod 4) 
22 = 22 = 4 (mod 10) 
222 = 24 = 16 (mod 88) 
2 i 4 = 216 = 65536 = 32 (mod 178) 
2 i 5 = 232 = 126 (mod 358) 
2 i 6 = 2126 = 66 (mod 718) 
2 i 7 = 266 = 596 (mod 719) 
The noncoprime case adds some minor complications, but we can pro­
gram a function TowerMod [ a ,  n ,  m ]  that will give us, in an instant, the 
results of mind-boggling computations such as 123456789 i 100 (mod 10100). 
Algorithm 3 . 1 .  Modular Towers 
Here is how to turn the ideas of the preceding example into an algorithm 
for computing a i n  (mod m). First we need the log' function, where 
log• (a, s) is the largest integer n such that a i n ::;  s. Here is a recursive 
implementation, followed by a line that allows us to use a *-superscript. We 
temporarily set $MaxExtraPrecis ion to a high value by using Block, 
because it can happen that a lot of extra precision is needed to resolve the 
inequality. We also define a i n to be the pure tower aa by redefining the 
built-in UpArrow. 
LogStar [ a_, n_] : = Block [ { $MaxExtraPrecision = 10000} , 
I f [n < a , O ,  LogStar [ a ,  Log [ a ,  n] ] + 1 ] ]  
Log• [ a_, n_] : =  LogStar [ a ,  n] 
Unprotect [UpArrow] ; 
UpArrow [ a_, n_] : =  I f [n = = O ,  1 ,  a•T <n-1> 1 
Protect [UpArrow] ; 
{ 2 t 4 ,  222' } 
{ 6 5 5 3 6 , 6 5 5 3 6 } 
{Log• [ 3 ,  3 t 3 J ,  Log• [ 3 ,  ( 3 f 3 ) - 1 ] }  
{ 3 ,  2 } 

96 
3. EULER'S 4> FU NCTION 
To get a t  n (mod m) in general, assume n <:: 2, for otherwise it is easy. 
Then we can split m into a product of prime powers and paste the answers 
together using the Chinese Remainder Theorem. Thus, it is sufficient to 
assume m = pe, where p is prime. Let g = gcd(a, pe); then g = p' for some r. 
Case 1. 
g = 1. This is easy: pe is coprime to a, so recursion and 
Lemma 3.28 get the result as aai(n-ll (mod .l[p'J> (mod m). 
Case 2. g > 1. Subcase 1. n - 1 > log* [a, logg(Pe)] 
The answer is simply 0. For we know that a t (n - 1) > logg(Pe), which 
means that ga1cn- 1> > pe. But g is a power of p, so this means that 
ga1cn-l > = 0 (mod pe), and therefore a01<n- l > = 0 (mod pe) because g divides a. 
Subcase 2. n - l s  log* [a, logg(Pe)] 
In this case the answer is ga1cn-l> (a/ g)ai(n- ll mod .l[p'J (mod pe). To see 
this, write a t  n as a01<n- 1> and split it into ga1<n-l> (a / g)ai(n-ll . The first 
factor is easy to compute because the case definition means it is at most pe; 
therefore we can get it nonmodularly by just iterating powers. For the 
second factor the following point is critical: gcd(a/ g, pe) = 1. Given this, we 
can work modulo A(pe) as in case 1. Why is this gcd assertion true? We must 
be sure that g eats up all the powers of p that lie in a. For this it suffices to 
know that a s pe . Here is a proof: 
a s  a t (n - 1) s logg(Pe) = logP, (pe) s e s  pe. 
We now give complete TowerMod code. The first three lines handle 
some small cases. The fourth line factors m, gets the results for the prime 
powers, and uses the Chinese Remainder Theorem to combine these results 
(this code requires the CNT package for ChineseRemainder, A, and Log­
Star). The last section of code implements the crux of the method in the 
case that the modulus is pe, where p and e are treated as separate argu­
ments, in part to avoid unnecessary refactoring. 
'.rowerMod [ a_, n_, l ]  : = 0 
'.rowerMod [ a_, O ,  m_] : =  l / ;  m > 1 
'.rowerMod [ a_, 2 ,  m_] : =  PowerMod [ a ,  a ,  m] 
'.rowerMod [b_, n_, m_] : = 
Module [ { fi = Factorinteger [m] } , CbineseBem•incler [Map [ 
'.rowerModPrimePower [b, n ,  I ] & ,  fi ] ,  Power OO '.rranspose [ fi ] ] ]  
'.rowerModPrimePower [_, 0 ,  {p_, _} ] : = 1 / ;  p > 1 
'.rowerModPrimePower [_, _, l ]  : =  0 
'.rowerModPrimePower [a_, 2 ,  {p_, e_} ] : =  PowerMod [ a ,  a ,  p• ] 

3.6. TH E UN IVERSAL EXPONENT 
97 
'.rowerModPrimePower [ a_, n_ , {p_, e_ } ]  : = 
Module [ { g ,  pp = p• } ,  g = GCD [ a ,  pp] ; I f  [g > 1 && 
n - 1  > LogStar [ a ,  Log [g ,  p• ] ] ,  O ,  Mod [ I f [g = =  1 ,  1 ,  g•T <n-1> ] 
PowerMod [ a  I g ,  '.rowerMod [ a ,  n - 1 ,  J, [p• ] ] ,  pp] , pp] ] ]  
Attributes [ '.rowerMod] = Listable ; 
Here is an application to the sample problem 
TowerMod [ 2 , Range [ lO] ,  7 19 ]  
{ 2 ,  4 , 1 6 ,  1 0 7 , 6 2 4 , 2 5 7 , 596 , 507 , 507 , 507 } 
In order to handle very large numbers we have to change the default 
recursion limit from 256 to a larger value. 
$RecursionLimit = 1000 ; 
TowerHod [ 1234567 8 9 , 100 , 10100 ] 
2 7 1 1 0 7 0 8 0 1 0 1 8 8 6 9 8 5 4 2 1 8 0 5 8 6 4 9 50045993 8 1 1 1 9 5 8 6 6 8 5 0 7 0 1 9 5 6 4 5 6 5 5 1 ȏ 
6 3 6 07 5 5 9 3 8 3 1 3 4 9 9 6 4 6 9 9 9 7 52 6 9 1 1 3 3 5 6 3 1 0 9 5 0 9  
If you examine sequences of the form al l, at2, at3, . . . , all modulo m, 
you will see that they become constant, and in fewer than log2 m steps 
(Exercise 3.46 asks you to prove this). 
'.rowerMod [ 3 1 1 , Range [ 10] , 100000 ] 
{ 3 1 1 ,  1 1 9 1 1 ,  8 7 9 1 1 ,  4 7 9 1 1 ,  
4 7 9 1 1 ,  4 7 9 1 1 ,  4 7 9 1 1 , 4 7 9 1 1 ,  4 7 9 1 1 ,  479 1 1 } 

 The Form of Carmichael Numbers 
Recall that a Carmichael number, such as 561 ( = 3 · 11 · 1 7), is a composite 
integer n for which bn-l = 1 (mod n) for every b coprime to n. It turns out 
that such numbers are very restricted in the form they can have. An alter­
nate route to the following proposition can be obtained by using the result 
of 3.39. 
Proposition 3.29. If n is a Carmichael number then n = p1 p2 
· · · Pr where 
each Pi is prime and n - 1 is divisible by each Pi - 1. 
Proof. 
We know from Theorem 3.27 that there is some b such that 
ordn(b) = -'.(n). Because bn-l = l (mod n), this means that -'.(n) divides n - 1. 
Because n > 2, -'.(n) is even and so n must be odd. Now suppose that some pe 
divides n with p odd and e  2. Then -'.(pe) divides -'.(n), which means that 
<f>(pe) = pe-l (p - 1) divides n - 1. But this is a contradiction because p 
divides n. This proves the first part. For the rest, use the fact that -'.(pi) 
divides -'.(n), so Pi - 1 divides n - 1. 
D 
Proposition 3.30. If n is a Carmichael number then n = p1p2 ... Pr where 
each Pi is prime and r  3. 

98 
3. EU LER'S I/! FU NCTION 
Proof. By the preceding proposition, we need only consider the case that n 
is a product of two primes, say n = p q. Suppose that n is a Carmichael 
number and let g be a primitive root for p. Then the order of g is p - 1, 
which must divide pq - 1. Therefore, 1 = pq = q (mod p - 1). This means 
that q  p. But a completely symmetric argument shows that p  q. There­
fore, p = q, a contradiction. 
D 
The preceding result gives us an efficient way to search for Carmichael 
numbers. The code that follows looks at products of three primes. 
Select [ Flatten [Table [Prime [ i ]  Prime [ j ] Prime [k] , 
{ i ,  2 ,  2 0 } , {j , i + l , 2 0 } , {k ,  j + l , 20 } ] ] ,  CarmichaelO] 
{ 5 6 1 ,  1 1 05 , 2 4 6 5 , 1 7 2 9 , 2 82 1 ,  8 9 1 1 ,  6 6 0 1 , 2 9 3 4 1 } 
Exercises for Section 3.6 
3.40. Show that if k  3, then 52•-a • 1 (mod 2k). This shows that A(2k) 
cannot be less than 2k-2, and so, by the first part of the proof of Theorem 
3.27, A(2k) = 2k-2 • Hint: Use induction on k to show that, if k  3, 52•-a = 
1 + 2k-l (mod 2k). 
3.41. Prove that A(m) divides A(n) whenever m divides n. 
3.42. Prove that A(n) always divides <f>(n). 
3.43. For which n does A(n) = <f>(n)? 
3.44. Write a program that, on input n, computes A(n). 
3.45. 
Recall the definition of log1(n) from Exercise 3.8. Show that 
log.t (n) s log"'(n). It then follows from Exercise 3.8 that log.t (n) s r1og2(n)l. 
3.46. Prove that the sequence at l, at2, at 3, . . .  , all modulo m, is eventu­
ally constant. Do this by showing that whenever n  c = r1og2(m)l, 
atn = ate (mod m). Hint: It suffices to prove it for the case that m is a 
prime power, pe . Then break it further into cases according as a and p are 
relatively prime. Use Exercise 3.45. 
3.47. Implement a TowerLimit [ a ,  m] function that returns the limiting 
value of atn (mod m). 
3.48. Find a Carmichael number that is a product of 4 primes. 

CHAPTER 4 
Prime Numbers 
4.0 Introduction 
Prime numbers have fascinated counters for thousands of years. Indeed, 
the search for patterns in prime numbers is one of the oldest problems of 
mathematics. Moreover there are many extremely elementary problems 
about primes that are still unsolved (one example: Are there infinitely 
many primes of the form n2 + 1 ?). While prime numbers have shown up in 
applications from time to time, interest in them increased greatly with the 
discovery in the 1970s that they could be used to generate methods of 
encrypting data that were almost surely unbreakable. In this chapter we 
will discuss several aspects of the theory of prime numbers focusing on the 
following questions: 
• What patterns govern the appearance of the primes among the inte-
gers at large? 
• Is it possible to quickly tell whether a very large number is prime? 
• How can we generate large numbers that are certifiably prime? 
• How can we quickly find, for modest values of n, the nth prime 
exactly? 
Here are three examples of functions that do some of these things. First we 
check the primality of a 101-digit number. PrimeQ is known to be valid up 
to 1016, and no example for which it fails is known; thus, one should inter­
pret the following computationas saying that 10267 is almost certainly 
prime. 
PrimeQ [ l0100 + 2 67 ] 
True 
If the primes are listed, starting from 2, as p1 , P2 , ... , then here is P 123456789 . 
Prime [ 12 3 4567 89 ]  
2 5 4 3 5 6 8 4 6 3  

1 00 
4. PRI M E  NUM BERS 
And here is how one can generate a large prime whose primality can be 
certified. There is no doubt as to its status. 
CerǓifiedPrime [ lOO] 
2 3 8 1 8 54 1 1 8 8 7402483 6 2 1303885 8 8 7 1 1 2 7 3 1 2 1 9 0 7 1 6 8 2 7 0 8 4 7 7 2 9 9 2 4 4 5 9 2 \ 
6 0 6 42 0 5 4 1 4 06 7 24495 8 1 603682 2 4 7 6 5 5 6 50 3 3 3 2 1 9  
4.1 The Number of Primes 
« We'll Never Run Out of Primes 
Primes are the multiplicative building blocks of arithmetic. Finding the 
factorization of an integer into primes, recognizing primes when you encoun­
ter them, understanding how they are distributed: These are fundamental 
abilities that are required throughout number theory. We begin their study 
with a result that comes down to us from Euclid; there is no largest prime. 
Theorem 4.1. There are infinitely many primes. 
Proof. Let us assume that there is a largest prime number, call it p, , so 
that the primes are given by 
P 1 = 2, P2 = 3, Pa = 5, · .. , Pr · 
Let P be their product, perhaps a huge number but surely finite. Consider 
P + 1, and factor it into primes. Because all primes divide P, none of them 
divides P + 1 (any prime that divides both P and P + 1 would have to divide 
their difference, which is 1). Therefore, P + 1 is not divisible by any prime, a 
contradiction. 
o 
If we know the first n primes, then taking their product and adding 1 to 
it will give us a number that must be divisible by a prime not in our list. 
There is no guarantee that this product plus one is prime. In fact, it usually 
is not. The first such example is 
2 . 3 . 5 . 7 . 11 . 13 + 1 = 30031 = 59. 509 . 
The next question to arise naturally is: How thickly are the primes 
spread among the integers? Are they plentiful or relatively scarce? The 
answer to this question is important because if they are scarce, that makes 
factorization easy: We can just trial-divide by the few primes that are 
around. On the other hand, a plentiful supply of primes is good for the 
many applications of number theory that require selecting a set of large 
primes. We saw one of these in Section 2.2 where the Chinese Remainder 

4. 1 .  THE NUM BER OF PRIMES 
1 01 
Theorem was used with prime moduli to do high-precision arithmetic. The 
answer is that primes are plentiful, very plentiful. 
The prime-counting function 1r(X) gives the number of primes less than 
or equal to x. It is included in Mathematica as PrimePi [ x ] ,  but the CNT 
package allows Tr [ x ]  to be used as well. Computing 1T(X) exactly is difficult 
when x is large (the basic algorithms are described at the end of Section 4.3. 
Mathematica's implementation goes up to 9 · 1013 , but the CNT package 
includes the special values 1T( 1014 ), 1T( l015 ), • • •  , 1T(l020 )). The following 
computations show that there are 78,498 primes under one million and 
2,220,819,602,560,918,840 primes under one hundred quintillion. 
{.zr [ 106 ] , .zr [ 1020 ] } 
{ 7 8 4 9 8 , 2 2 2 0 8 1 9 6 0 2 5 6 0 9 1 8 8 4 0 } 
It is one of the most amazing facts of mathematics that the primes, 
though they appear randomly placed in the integers, have a growth rate 
that is incredibly smooth. (See the graphs in Figure 4.1, which were gener­
ated by simply plotting 1T(X).) 
Naturally the appearance of such a smooth curve (it is not straight: 
note the slight curvature it exhibits) makes us desperately want to know a 
formula that approximates it. This question has played a central role in 
number theory ever since Gauss examined tables of primes and came up 
with a conjecture about the long-term behavior of 1T(X). We can make some 
similar investigations by asking how many primes there are in intervals of 
size 1000 near various powers of 10. Here is some raw data followed by a 
tabular view of same. 
data = 
'l!able [ { i ,  Count [ Range [ l01 , 101 + 99 9 ] , _ ? PrimeQ] } ,  { i ,  O ,  20 } ]  
{ { O ,  1 6 8 } ,  { 1 ,  1 6 5 } ,  { 2 ,  1 5 9 } ,  { 3 ,  1 3 5 } ,  { 4 , 1 0 6 } ,  
{ 5 ,  8 1 } , { 6 ,  7 5 } , { 7 ,  6 1 }  , { 8 , 54 } , { 9 ,  4 9 } , { 1 0 ,  4 4 } , 
{ 1 1 , 4 7 } ,  { 1 2 , 37 } ,  { 1 3 , 34 } ,  { 1 4 , 30 } , { 1 5 , 2 4 } , 
{ 1 6 , 2 0 } , { 1 7 , 2 7 } ,  { 1 8 , 2 3 } ,  { 1 9 ,  2 8 } ,  { 2 0 , 2 4 } }  
n 
Number of Primes 
n 
Number of Primes 
n 
Number of Primes 
0 
168 
7 
61 
14 
30 
1 
165 
8 
54 
15 
24 
2 
159 
9 
49 
16 
20 
3 
135 
10 
44 
17 
27 
4 
106 
1 1  
47 
18 
23 
5 
81 
12 
37 
19 
28 
6 
75 
13 
34 
20 
24 
Note that we cannot use PrimePi to make this computation because it 
does not work well beyond 1013• Instead we are actually counting primes 
and living with the small risk of an incorrect output from PrimeQ beyond 
1016 • There is a pattern to this data: as the power of 10 

1 02 
4. PRI M E  NUM BERS 
Plot [.zr [x] , { x ,  1 ,  108 } ]  
2 0 0 0  
4 0 0 0  
6 0 0 0  
8 0 0 0  1 0 0 0 0  
S x 1 0 6 
4 x 1 0 6 
3 x 1 0 6 
2 x 1 0 6 
l x 1 0 6 
5 1 04 
5 1 0 7 
Figure 4.1. These graphs of 1r(x) show that the growth rate of the primes is remark­
ably smooth. 
doubles, the number of primes gets cut roughly in half. For example, near 
104 there are 106 primes; near 108 there are 54. Because the first entry is 
the power of 10, this indicates that the relationship might be k/(log10x), 
which is the same as c/ (log x) [log x denotes natural logarithm, often writ­
ten as ln x or logex] . Now, the amazing thing is that the best value of c to 
make this function match the data is 1. In other words, the best logarithm 
to use is the logarithm to the base e - the chance of a number near x being 
prime is close to 1 /log x. For example, 1 /log(108) = 0.0542868, and because 
we are looking at intervals of size 1000, this would predict 54.3 primes in 
such an interval near 108; sure enough, there are 54 primes in 
[108' 108 + 1000). 
We can phrase this observation as: The probability that a number near 
x is prime is 1 /(log x). This would mean that 1f(x) should be well approxi-

4.1 . THE NUM BER OF PRIMES 
1 03 
mated by fix 10̔1 dt. This quantity is called the logarithmic integral1 of 
x, denoted li(x), and available in Mathematica as Logintegral [ x ] .  The 
CNT package defines the alias li ( x )  for Logintegral. This function is not 
too hard to compute but there is a rough approximation that is easier to 
remember and to compute: x/(log x). This fraction is asymptotic to li(x), 
where f is asymptotic to g means that limx..,00 f (x) I g(x) = 1 (Exercise 4.3). 
Figure 4.2 shows graphs of the three functions 1T(X), x /(log x), li(x). 
Plot [ {zr [z ] , x / Log [x] , li [x ] } ,  { x ,  2 , 10000 } , 
PlotStyle -+ { { GrayLevel [ O .  8 ] , Absolute'1'bicknes s  [ 3 ] } ,  
{Absolute'1'bickness [ 2 ] } ,  { } } ] ; 
1 2 0 0  
1 0 0 0  
6 0 0  
4 0 0  
2 0 0  
2 0 0 0  
4 0 0 0  
6 0 0 0  
8 0 0 0  
1 0 0 0 0  
Figure 4.2. The graphs of 1T(x) (gray), x / (log x) (thick), and li(x) (thin). 
The fact that 1T(X) is asymptotic to a simple function is a famous result. 
It was conjectured by several mathematicians at the end of the eighteenth 
century and not proved until the end of the nineteenth when Jacques 
Hadamard (1865-1963) and Charles.Jean de la Vallee-Poussin (1866-1962) 
independently completed the details of a proof that had been sketched by 
Bernhard Riemann almost 40 years earlier. The result is now known as the 
Prime Number Theorem. 
Theorem 4.2. 
Prime Number Theorem. The number of primes less 
than or equal to n is asymptotically equal to n/(log n). 
1 An alternative definition of the logarithmic integral (and the one used by 
Mathematica's Loglntegral function) uses the interval from 0 to n, which can be 
done even though 1 / (log t) has a vertical asymptote at t = 1 .  The difference between 
starting at 0 or at 2 is only a little more than 1.045. For practical purposes, it does 
not matter which definition is used. 

104 
4. PRI M E  NUM BERS 
The logarithmic integral is asymptotically equal to n/(log n), but is in 
fact a better approximation to 1T(n). The table that follows compares the 
values of 1T(n) with the nearest integers to n/(log n) and li(n); the error is 
given as a percentage. Note how well li(x) approximates 1T(X). 
n 
ir(n) 
n / log n. % error 
li(nJ 
% error 
102 
25 
22 
1 2 .  
30 
20. 
103 
168 
145 
14. 
178 
5.962 
1 04 
1229 
1086 
12. 
1246 
1.383 
10" 
9592 
8686 
9.4 
9630 
0.3962 
106 
78498 
72382 
7.8 
78628 
0.1656 
107 
664579 
620421 
6.6 
664918 
0.05101 
108 
5761455 
5428681 
5.8 
5762209 
0.01309 
109 
50847!)34 
48254942 
5.1 
50849235 
0.003345 
10•0 
45505251 1  
434294482 
4.6 
455055615 
0.0006821 
. 1011 
4118054813 
3948131654 
4. 1 
4118066401 
0.0002814 
10•2 
37607912018 
36191206825 
3.8 
37607950281 
0.0001017 
101a 
346065536839 
334072678387 
3.5 
:ư6065645810 
0.0003149 
101·• 
3204941750802 
3102103442166 
3.2 
3204942065692 9.825 X 10-A 
1015 
29844670422669 
28952965460217 
3.0 
298445714 75288 3.527 x 10-6 
1018 
279238341033926 
271434061189532 
2.8 
279238344248557 
1.151 x 10-d 
101• 
2623557157654233 
2554673422960305 
2.6 
26235571656108'l2 
3.033 x 10 - 7 
1018 
24739954287740860 
24127471216847324 
2.5 
24739964309690415 8.872 x 10-8 
1019 
234057667276344607 
228678043106974646 
2.3 
234057667376222382 
4.267 x io-8 
10211 
2220819602560918840 
2171472409516259138 
2.2 2220819602783663484 
1.003 x 10-8 
While the proof of the Prime Number Theorem requires far more back­
ground than we can expect for this book, we will show with a slightly less 
accurate estimate that this formula makes sense. Its implications are 
profound. The number of 100-digit primes is closely approximated by 
li(10100) - li(1099), which can be computed very quickly. 
DWD = li [ 10 . lOO ) - li [ 1099 ) 
3 . 9 2 1 3 5 x 1 097 
10100 - 1099 
DWD 
229 . 5 1 3  
So, one out of every 230 hundred-digit numbers is prime. When you con­
sider that even numbers, multiples of 3, and multiples of 5 are all easy to 
recognize and none of them will be prime, the odds of choosing a prime just 
by randomly selecting one of the remaining hundred-digit integers goes up 
to one in 77. It is easy to find a hundred-digit prime. Generate hundred­
digit numbers that are not divisible by 2, 3, or 5 and use the 2-pseudoprime 
test to check whether or not each is prime. Of course, actually proving that 
you have a prime is another matter. The CNT package has a RandomPrime 
function to get random d-digit primes, and these are certifiably prime, as 
discussed in Section 4.2. 

4.1 . THE N U M BER OF PRIMES 
1 05 
Randomrrime [ 200] 
6 1 5 9 2 8 9 2 1 1 0 3 3 6 4 7 1 0 4 0 1005258 292446 9064 3 1 4 6 9 2 5 1 3 6 7 92 7 2 6 93466 6 5 '  
1 7 7 5 9 7 0 5 6 1 2 7 4 8 3 3 4 3 4 9 2 4 7 3 6 6 7 253 698472 6 1 9 3 3 9 6 6 7 0 1 3 7 4 6 8 9 2 1 6 3 4 5 Ȑ  
0 4 7 0 4 3 9 4 3 4 8 1 0 0 7 8 2 7 8 3 8 4 6 6 6 7 4 8 70492063 6 9 3 3 8 7 8 5 5 7 9 7 5 2 5 12880290ȑ 
5 7 3 4 8 9 1 7 8 4 2 8 1 3 2 4 3 9 8 8 7 1  
More exact estimates of 11"(X) quickly lead to deep mathematics, espe­
cially the notorious Riemann Hypothesis. When Riemann was investigating 
how one might prove the Prime Number Theorem, he used the function of s 
given by L:=I 1 I n8, which today is known as the Riemann zeta function. 
Written in this way, this function is defined only when the real part of s is 
strictly larger than 1, but Riemann showed that the function could be 
extended uniquely to all complex values of s. The Prime Number Theorem 
relies on the fact that this function is never 0 when the real part of s is 1. 
Riemann conjectured that this function is never 0 when the real part of s is 
larger than 1'2 , a statement that is equivalent to saying that for any e > 0, 
there is a constant Ke so that I 11"(X) - li(x) I < K8xo.5+e . This is the Riemann 
Hypothesis. It implies a regularity in the distribution of primes that has 
many important implications. For more information on these topics see 
[BS], [Rie], [Wag], and [Zag]. 
߇ The Sieve of Eratosthenes 
If you want to generate a table of all primes less than a given number, then 
the most efficient algorithm known today is the same as that known to Era­
tosthenes of Cyrene, now part of Libya. He was a Greek mathematician 
who lived from 276-194 BCE and taught in Alexandria in what is now 
Egypt. To find all primes less than or equal to n, we list all the integers 
from 2 to n. We then work our way down the list. The first integer (namely 
2) must be prime. We cross off all multiples of 2 that are larger than 2. The 
first integer after 2 that has not been crossed off (namely 3) must be prime. 
We cross off all multiples of 3 that are larger than 3. We continue in this 
manner. When we have found a new prime, we cross off all multiples of that 
new prime that are larger than the prime itself and then move on to the 
next integer that has not been crossed off; again, it must be prime. The 
reason that this is efficient, as Eratosthenes realized, is that we do not have 
continue all the way up to n. When we have found a prime larger than Yn, 
all of the remaining integers that have not been crossed off must be prime. 
Any composite integer must have a factor less than or equal to its square 
root. So if a positive integer does not have any divisors larger than 1 and 
less than or equal to its square root, then it must be prime. The following 
table (using blanks instead of Os) shows how three sieving steps give us all 
the primes under 40; they are in the last column. 

1 06 
4. PRI M E  NUMBERS 
EratostbenesTable [ 40 ]  
2 2 
2 
2 
3 
3 
3 
3 
4 5 
5 5 
5 
'--L-.
.
 
6 7 I 
7 
7 
7 
: I 9 
10 I 
tu111 11 11 
1 12 
1 13 13 13 
13 
14 
15 15 
16 
17 17 17 17 
1 10 
. 19 
1 9  19 19 
20 
21 2 1  
22 
I 
23 23 23 23 
24 
25 25 25 
26 
2 7  2 7  
28 
29 29 29 29 
3 0  
31 3 1  3 1  3 1  
32 
33 33 
34 
35 35 35 
36 
37 37 37 37 
38 
3 9 39 
4 0  
Algorithm 4. 1 . The Sieve of Eratosthenes 
This is the sieve of Eratosthenes, which finds all primes less than or equal 
to n. It begins by setting L = {2, 3, ... , n}. Starting with i = 1, if the ith entry 
of L is not 0, then it must be prime, call it p. Starting with p2 in position 
i2 + 2i, every pth entry of L is reset to 0. We increment i by 1 and repeat 
until p > -{Ti; this requires 1r( vn) steps. The primes are all of the nonzero 
entries left in L. 

4. 1 .  TH E N U M BER OF PRI M ES 
1 07 
Eratosthenes [ n_] : = Module [ {L = Range [ 2 ,  n ] , i = l } , 
Wbile [ L [i] 2 s n ,  
I f [ L [i] ; o , Do [ L [k] = 0 , { k ,  i2 + 2 i , n - 1 , L [i] } ] ] 1 i + + ] 1 
Rest [Union [ L] ] ]  
Eratostbenes [ SOO] 
{ 2 ,  3 ,  5 ,  7 ,  1 1 ,  1 3 , 1 7 , 19 , 23 , 2 9 ,  3 1 , 3 7 ,  4 1 , 43 , 47 , 53 , 
5 9 , 6 1 ,  6 7 , 7 1 ,  7 3 , 7 9 , 83 , 89 , 97 , 101 , 1 0 3 , 1 0 7 , 109 , 
1 1 3 , 1 2 7 , 1 3 1 , 1 3 7 , 1 3 9 , 149 , 1 5 1 ,  1 5 7 , 1 6 3 , 1 6 7 , 1 7 3 ,  
1 7 9 , 1 8 1 ,  1 9 1 ,  1 9 3 , 1 9 7 , 1 99 , 2 1 1 ,  223 , 2 2 7 , 2 2 9 , 233 , 
2 3 9 , 2 4 1 ,  2 5 1 , 2 5 7 , 2 6 3 , 2 6 9 , 2 7 1 ,  2 7 7 , 2 8 1 ,  2 8 3 , 2 9 3 , 
3 0 7 , 3 1 1 ,  3 1 3 , 3 1 7 ,  33 1 ,  3 3 7 , 347 , 349 , 353 , 3 5 9 , 367 , 
3 7 3 , 3 7 9 , 3 8 3 , 3 8 9 , 397 , 4 0 1 , 409 , 4 1 9 , 42 1 ,  43 1 ,  433 , 
4 3 9 , 4 4 3 , 4 4 9 , 4 5 7 , 4 6 1 , 4 6 3 , 4 6 7 , 479 , 4 8 7 , 4 9 1 ,  499 } 
This algorithm has some serious drawbacks. If n is very large, it 
requires a lot of memory. And if you want to use it to prove that n is prime, 
it would take approximately {Ti steps. But it does possess a great strength 
that will come into play in the most powerful known factorization algo­
rithms, the quadratic sieve and the number field sieve. All these sieves 
share the feature that they eliminate division and almost all multiplica­
tions from the step that sifts for the desired objects. 
The sieve of Eratosthenes also plays a role in our understanding of the 
distribution of primes and the Prime Number Theorem. In number theory 
one often uses as a guide probabilistic statements about divisibility such as: 
• About half the numbers between 2 and x are divisible by 2. 
• About Ǩ of the numbers between 2 and x are divisible by p. 
These two examples are, when x is large, essentially true; but there is 
much more subtlety involved when one combines many such statements. 
For example, the sieve of Eratosthenes gets at the primes below x by remov­
ing the multiples of 2 (except 2 itself), then the multiples of 3 in what 
remains, then the multiples of 5 in what remains, and so on up to the last 
prime under '1X. One might therefore think that the amount remaining at 
the end-the number of primes-would be approximately xn 
_ r  (1 - .!. ). 
ps -v :x:  
P 
But this is false! It turns out that the true sieve is more efficient in its 
deletion of numbers than one would expect from the random model. 
The reason for this surprising efficiency is that the deletions that occur 
in the true sieve are not really independent. For example, consider the 
integers to 10,000. The random view is that, say, 1\ 213 4\ of the numbers 
under x are divisible by 11, 23, and 41. But in reality there are no such 
numbers, because 1 1 · 23 · 41 > 10000. This means that there is less overlap 
in the deletions, and so, at least most of the time, more numbers will be 
deleted than expected. 
We can make a step-by-step comparison of the true sieve to the num­
bers predicted by the random model. Let us avoid issues related to small 
integers by considering a small interval around a large number; we'll use 

1 08 
4. PRI M E  NUM BERS 
[108 - 5000, 108 + 5000). There are 1229 sieving primes - {2, 3, 5, ... , 9973} 
- and 548 primes in the interval. Here are the number of integers remain­
ing after each sieving step. Figure 4.3 shows the difference between the 
predicted remainders using the random model and the actual remainders. 
The data show that the random model overestimates the number of inte­
gers not sieved out by 61, an error of 11 %. 
0 
2 0 0  
4 0 0  
6 0 0  
8 0 0  
1 0 0 0  
1 2 0 0  
Figure 4.3. When sieving the integers in [ 108 - 50000, 108 + 50000] for primes, the 
random model overestimates the number of true survivors at each step after the 
first few. Overall there is an overestimate of 61, a large overestimate because there 
are only 548 primes in the interval. 
The following theorem shows exactly what has to be done to the random 
model to get a correct prediction. Recalling that the prime density near x is 
1 /(log x), the theorem of Mertens (see [HW, thm. 4.29] for a proof) shows 
that by extending the product from x0·5 to x0·56 one gets the right answer. 
Theorem 4.3. (F. Mertens, 1874) Let c be the constant e-r, where y is 
Euler's constant, 0.577 ... ; the numerical value of c is about 0.56. 
n 
( 
1 ) 
2c 
(a) 
1 - - - --
psvx 
p 
log x 
(b) n 
(1 - ..!.) - _1_ 
psx" 
p 
log x 
Note that the assumption that the random model was a good predictor 
of the prime distribution might lead to a prediction, using part (a), that 1f(x) 
would be asymptotic to 1.12x /(log x). But the Prime Number Theorem tells 
us that the constant should not be there. One idea used to prove the Prime 
Number Theorem is to show directly (i.e., without the complex analysis 
used in the original 1896 proof) that 1f(X) is asymptotic to the product 
xn 
(1 - ..!. ). This is the essence of the celebrated Erdos-Selberg proof of 
psx" 
P 
the Prime Number Theorem in 1949. 

4. 1 .  THE N U M BER OF PRIMES 
1 09 
« Chebyshev's Theorem and Bertrand's Postulate 
An early approximate result is one due to Pafnuty Chebyshev (1821-1894). 
He found constants c1 and c2 such that 
n 
n 
C1 -1-- < 1T(n) < C2 -1--
og n 
og n 
for sufficiently large n. He was able to prove this result with c1 = 0.92 and 
c2 = 1.106. Since then improvements have been made on these constants. In 
1989, N. Costa Pereira proved this result for c1 = 1 - 1/2976 , c2 
= 1 + 1/2976 • 
To give the flavor of this approach, we present a proof for c2 = 1. 7. A proof 
for c1 = 2/a is outlined in Exercise 4.12. 
Theorem 4.4. Chebyshev's Theorem. For any x > 200, 
2 
x 
x 
-3 -1
- < 1T(X) < 1.7-l - . 
og x 
og x 
Proof. We will prove the upper bound, leaving the lower bound to Exercise 
4.12. The condition on x is not necessary for the upper bound. The proof 
breaks into six short steps and is totally elementary. 
(a) The result is true for x < 1300. This could be done by computing lf [ x ] ,  
but it is more satisfying to do it from scratch, using an Eratosthenes sieve 
to get the primes below 1300. The following code looks at the primes and 
their positions in the list, and verifies that the result is true. 
data = Eratosthenes [ 1300] 1 
Apply [And , ±able [ x = data [i] J 
1 .  7 x 
Position [data , x ] [l , 1] < 
, {i , Length [data ] } ] ]  
Log [x] 
True 
(b) ( 2: ) < 4n. This follows from 4n = (1 + 1)2n
, which is the sum of all the bi­
nomial coefficients of the form ( 2; ). Note that this also proves ( 2nn
+ 1 ) < 4n , 
because ( 2nn
+ 1 ) = ( 2: ) 
+ ( n2¬
1 ) < 4n . 
(c) If n ;;:: 1300, then 3.09 10;n 
+ 1 < 1.7 10:,:ǧ1 1 • The condition on n allows us 
to replace the left side of the inequality with 3.1 10;n ; we can also replace 
2 n + 1 by 2 n in the numerator of the right side, thus reducing the inequal­
ity to 1ǰ:,12 < 10:;:nn+I> . This is valid when n = 1300 and the derivative of the 
right side is positive, so it is valid beyond 1300. 

1 1 0 
4. PRI M E  N U M BERS 
(d) If n ;;:: 1300, then 3.09 10:n < 1.7 lo:<̓n> . To prove this, write log(2n) as 
log n + log 2 and simplify the difference to find the unique point where the 
sides are equal. 
2 * 1 . 7 
Log [n] + Log [ 2 ]  
3 . 09 
-- 1 1  '.rogeǓher 
Log [n] 
- 2 . 1 4 1 8 2  + 0 . 31 Log [ n ]  
Log [ n ]  ( Log [ 2 ] + Log [ n ]  ) 
E2 . 1U82 / 0 . J l  
1 0 0 1 . 34 
(e) ( 2: ) is divisible by every prime p between n and 2 n. This is clear 
because any such prime appears in the numerator of the binomial coeffi­
cient and cannot be cancelled by the denominator. 
Now we can complete the proof by induction, where we assume the 
result is true for n (where 2n ;;:: 1300) and prove it for 2n and 2 n  + 1. By (b) 
and (e): 
4 n > ( 2n ) ;;:: n 
p > n n 
= n"(2n)-ir(n) • 
n 
n<ps2n 
n<ps2n 
Take logarithms to get: 1T(2 n) - 1T(n) < 1.39 Io:n . But the inductive hypothesis 
(for n) gives 1T(n) < 1. 7 Io:n . So, using (d), 1T(2 n) < 3.09 lo:n < 1. 7 10:Cnl . For 
the case of 2 n + 1, combine the result for 2 n with (c): 
n 
n 
2 n  + 1 
1T(2n + 1) s 1T(2 n) + 1 < 3.09 -1 - + 1 < 3.10 -1 - < 1.7 1 
2 
ogn 
ogn 
og( n + 1) 
D 
A related result is Bertrand's Postulate that for any integer n ;;:: 2, there 
always is a prime between n and 2 n. This result was conjectured by Joseph 
Louis Franܽois Bertrand (1822-1900) and proven by Chebyshev in 1850. A 
proof of this result due to Paul Erdos is outlined in Exercise 4.13. This 
result has a counterpoint in the observation that there are arbitrarily long 
strings of consecutive composite integers. To prove this just look at 
k ! + 2, k ! + 3, ... , k ! + k, which is a sequence of k - 1 consecutive composites. 
Another approach is given in Exercise 2.22. 
Exercises for Sedion 4.1 
Note: In all exercises in this chapter p denotes a prime number. 
4.1. Modify the proof that there are infinitely many primes to show that 
there are infinitely many primes that are congruent to 3 (mod 4). Hint: 

4. 1 .  T H E NUMBER OF PRI M ES 
1 1 1  
Assume that there are only finitely many such primes: p1 = 3, P2 = 7, .. . , Pr 
and consider 4 P1 P2 · · · Pr - 1. 
4.2. What is wrong with the following proof that there are infinitely many 
primes that are congruent to 1 (mod 4)? (A correct proof is given in Theorem 
6.4.) 
Assume that there are only finitely many primes congruent to 1 
modulo 4: P1 = 5, P2 = 13, . . .  , Pr · Consider 4p1 P2 · · ·  Pr + 1. This is not 
divisible by any of our primes, but it must be divisible by a prime 
congruent to l(mod4), so the assumption that there are only finitely 
many such primes must be wrong. 
4.3. Prove that li(x) is asymptotic to x/(log x). Hint: Use l'Hopital's rule 
twice and the fact that the derivative of a definite integral can be computed 
by the fundamental theorem of calculus. 
4.4. A number of the form p1 p2 · · · Pr + 1 is called a Euclid number. They 
can be defined in Mathematica as follows. 
Buclid [n_] : =  1 + Apply ['l!imes , Prime [Range [ n ] ] ]  
Use a pseudoprime test to determine which of the first 100 Euclid numbers 
are (most likely) prime. 
4.5. Euclid's proof of Theorem 4.1 can be used to build an infinite list of 
primes by choosing at each step the least prime dividing P + 1. The list then 
begins with 2, 3, 7, 43, 13 because 13 is the least divisor of 2 · 3 · 7 · 43 + 1. 
Investigate by computation the following open question of Dan Shanks 
(1991): Is it true that every prime appears in this list? 
4.6. Prove that the infinite product (1 - ..!. )(1 - ..!. )(1 - ..!. ) • • •  (1 - __!_) · · ·  = 0. 
2 
3 
5 
Pn 
This should be interpreted as: limn_,oc (1 - t )(1 - i )(1 - i )· · ·( 1 - :. ) = 0. 
Hint: Use the geometric series formula to show that for each N, there is a k 
such that ""k 
..!. < nǫ 1_111 
.
• Show that as N approaches infinity, so 
L.in=l n 
1=1 
p, 
does k. Then use the fact that L::=l -!, diverges. 
4.7. Prove that "" 
. 
..!. diverges by assuming convergence and getting 
L.J p pnme P 
a contradiction as follows. 
(a) 2: (- log[ 1 - 1; ] - 1J) = oo . (Use Exercise 4.6.) 
p prime 
(b) Use the Maclaurin series for log(l + x) to express the general term of 
th 
.
.
 ( )
" 
1 
1 
1 
e series m a is 2P2 + 3P3 + 4p4 · · · . 
(c) Use the geometric series formula to see that the general term in (b) is 
less than 2P (̒- I > , and such terms form a convergent series, contradiction. 
4.8. Use a pseudoprime test to get the likely primes in the first 10,000 
integers beyond a googol (10100). How does the number of such probable 

1 1 2  
4. PRIME NUMBERS 
primes compare with the heuristic value for the expected number of primes 
in this interval? 
4.9. Generate some graphs of the error when using li(x) to estimate 1f(X). 
Does li(x) overestimate or underestimate 1f(x)? An amazing theorem of 
Littlewood asserts that the sign of li(x) - 1f(X) changes sign infinitely often. 
The place where the sign-change first occurs is called the Skewes number; 
we do not know much about this number, except that it must be less than 
10371 • Note the amazing moral here: millions of hours of computations can 
lead one to believe in a conclusion [in this case, that li(x) is always larger 
than 1f(x)] that is false. 
4.10. Dirichlet's Theorem (1837) states that any arithmetic progression 
{ak + b : k = 0, 1, 2, ... } where gcd(a, b) = 1 contains infinitely many primes. 
Therefore, there are infinitely many primes of the form 4 k + 1 and of the 
form 4k + 3. Do some computations and create some graphs to investigate 
the race between these two families of primes. Can you find n such that in 
the interval [2, n] the primes congruent to 3 (mod 4) are outnumbered by 
those congruent to 1 (mod 4)? In fact, a famous theorem of Littlewood 
asserts that in such prime number races, the lead changes hands infinitely 
often. Investigate some random 50-digit primes. Are they more likely to be 
congruent to 3 (mod 4) than 1 (mod 4)? Littlewood's theorem was extended 
recently by M. Rubenstein and P. Sarnak [RS] who showed that if we 
assume a generalization of the Riemann Hypothesis, then, in the prime 
number race for congruence classes modulo n, any configuration of the 
coprime residue classes shows up as the race order infinitely many times. 
Generate some graphics to illustrate the leader in the mod-5 race; that is, 
study which congruence class mod-5 is dominant among the first n primes. 
4.1 1. Perform some computations that show that the random sieve over­
estimates the number of primes in a large interval by 12%, or, more pre­
cisely, 2e-r. 
4.12. Complete the proof that if x > 200, then f 10;x < 1f(X) by following 
steps (a)-(d). 
(a) Prove that if pe divides ( 3 ) then pe s n (use the formula - see Exercise 
1.24 - for the number of primes in a factorial). 
(b) Use (a) to deduce that ( 3 )  s n"<n> . 
(c) Use (b) and the fact that 2n = .L::=O ( 3 ) to show that 2n s (n + l)n"<n> . 
(d) Take logarithms in (c) to obtain the desired result, using the condition 
on 200 to get the needed inequality involving logarithms. 
4.13. This exercise proves Bertrand's Postulate: If n ģ 2, then there is a 
prime between n and 2 n. 
(a) Prove that 0psn p < 4n. This can be proved by induction on n. Verify 
that it is correct for n s 3. Show that if it is true for n when n is odd, then it 

4. 1 .  THE NUMBER OF PRIMES 
1 1 3  
is also true for n + 1. The only tricky step is from n = 2 m to n + 1 = 2 m + 1. 
Prove that if the inequality holds for all integers less than or equal to 
n = 2 m, then 
n p :5 ( 2mm+ I )  n p < ( 2mm+ I )4m+I . 
ps2m+I 
psm+I 
Use the inequality mentioned in the proof of part (b) in Theorem 4.4 to 
finish the proof. 
(b) Prove that if n > 2 and p is a prime such that f n < p :5 n, then p does 
not divide ( 2: ). It follows that if there are no primes between n and 2 n, 
then all prime divisors of ( 2: )  are less than or equal to f n. 
(c) Use Exercise 4.12(a) to show that if e(p), the largest power of p that 
divides ( 2: ). is greater than 1, then p < ../2n .  Then use part (b) to show 
that if there are no primes between n and 2 n, then 
(d) Use induction to prove that ( 2,:' ) > 2!:1 • 
(e) Use parts (a), (c), and (d) to prove that if there are no primes between n 
and 2 n, then 
This implies that 
4nt3 < (2 n  + 1)(2 n)v'2il < (2 n)2+& . 
Show that this inequality cannot hold for any n  750, and therefore 
Bertrand's Postulate is valid for n  750. 
(f) Show that Bertrand's Postulate holds for all n larger than 1 and less 
than 750. 

1 1 4 
4. PRI M E  NUMBERS 
4.2 Prime Testing and Certification 
 Strong Pseudoprimes 
We have seen that Fermat's Little Theorem is effective for identifying 
composite integers and is usually reliable when trying to find primes. Given 
a random integer n of, say, 100 digits, if n satisfies 2n-1 = l(mod n), then 
the odds are overwhelming that n is prime. But overwhelming likelihood is 
not certainty. We can improve the odds by checking some other bases: 
bn-l = 1 (mod n). In some cryptographic applications it would be safer to use 
randomly chosen bases rather than just starting at 2 and moving up. There 
is no composite integer that is guaranteed to pass the pseudoprime test for 
all bases. Even Carmichael numbers will fail the pseudoprime test for all 
bases that are not relatively prime to the number being tested. However, 
the existence of Carmichael numbers implies that there could be relatively 
few bases for which a composite integer is revealed to be composite. 
A very strong improvement on the pseudoprime test comes out of the 
simple observation that all primes except 2 are odd. Let n be an odd integer 
that we suspect might be prime. We can write n as 2 m + 1. If n really is 
prime, then Fermat's Little Theorem tells us that for any base b between 1 
and n, b2m = 1 (mod n). This means that bm is a mod-n square root of 1; but 
we know (Proposition 2.4) that there are only two such square roots, ± 1. So 
if it turns out that bm is congruent to something other than ± 1, we have a 
proof that n is composite. Moreover, if bm does turn out to be congruent to 
+1 and if m is even, say m = 2k, we can apply the same reasoning to bk: It 
must be ± 1 (mod n) if n is prime. And so on down. 
Consider 341, the first 2-pseudoprime. Because 341 = 2· 170 + 1, we can 
look at 2170 (mod 341). 
PowerMod [ 2 , 170, 3 4 1 ]  
1 
This doesn't help. But 170 = 2 · 85 so we next check out 285. 
PowerMod [ 2 , 85 , 3 4 1 ]  
32 
Jackpot! 32 is not ± 1(mod341), so this proves that 341 is composite. 
The general situation is described as follows. Given n, an odd integer, 
and b, write n - 1 as 2' m where m is odd. Then look at the mod-n sequence 
bm , b2m, b4m , ... , b2'm = bn-1 . Let us call this the b-sequence for n. If this 
sequence fails to end in + 1, or ever has a + 1 preceded by an integer that is 
not ± 1, then n is definitely composite. Otherwise n is exhibiting prime-like 
behavior; if such an n is not prime, it is called a b-strong pseudoprime, or 
b-spsp. Note that the sequence is very fast to compute because each term is 

4.2. PRI M E  TESTING AND CERTI FICATION 
1 1 5  
just the square of the preceding term. The following table shows the differ­
ent sorts of behaviors, where * denotes an integer not congruent to ± 1. The 
observant reader will note that one type of behavior is missing from the 
table: the case where bn- l = -1 (mod n). In fact, if n is odd then for any b, 
bn- l २ -1 (mod n); see Exercise 4.18. 
bm 
b2'" 
b4m 
b8rn 
b" I 
+ l 
+ l 
+ l  
+ l  
+ l  
+ I  
+ I  
+ l  
+ I  
+ I 
prime or b·spsp: b"' iݝ + 1 
-1 
-t- 1  
+ I  
prim<' or b-spsp: b'" "' i३ - 1  for 
some k < r 
+ l  
+ 1  
r 1  
C.:ompo•iW: a n  tmtry diJfor<'ni 
fmm ± 1 squares to 1 
• 
• 
Composite; b" - 1  is not :r 1 
Strong pseudo primes exist. If b = 2 then 204 7, which factors as 23 · 89, is 
a 2-spsp. Because 2046 = 2 · 1023 + 1, we can get the 2-sequence as follows. 
PowerMod [ 2 , { 102 3 , 2046 } , 2047 ] 
{ 1 ,  1 }  
The behavior of this sequence is primelike, so 204 7 is a 2-strong 
pseudoprime. 
One uses the strong pseudoprime idea to gain evidence for primality by 
checking n using a few bases. If n appears to be prime according to the 
strong pseudoprime criterion, then it is extremely likely that n is prime. 
For example, under 1016 there are only 52,593 composite integers 1 n that 
are both a 2-spsp and a 3-spsp. Moreover, this test runs essentially as fast 
as the ordinary pseudo prime test. Unlike the case for the ordinary 
pseudoprime test, it makes sense to consider composite values of b that are 
not squares (see Exercises 4.15 and 4.16); but it is efficient to look only at 
the prime bases. 
Algorith m  4.2 Th e Strong Pseudoprime Test for Primality 
Choose bases b in order from the primes 2, 3, 5, ... , and find r and odd m 
such that n - 1 = 2r m . Then examine the b-sequence for n to see if the first 
+ 1 is preceded by a -1; if it is not or if there is no + 1, n is proved composite. 
Otherwise n is either prime or a b-strong pseudoprime. Several bases can 
be used to increase the likelihood of correctness. The following code 
1 These integers are provided in the StrongPseudoprimeData package on the disk 
accompanying this book. When that package is loaded - it is done automatically as 
needed within the CNT package - one can use StrongPseudoprimes ( { 2 , 3 } , 
max ] to get all 2- and 3-strong psps under max, where max o5 1016 . This data set, 
computed by Daniel Bleichenbacher [Ble], can be useful in finding special pseudo­
primes (as in Exercise 4. 15) or in evaluating new primality tests. 

1 1 6 
4. PRI M E  NUMBERS 
includes the SpspSequence function so that we can look at some b­
sequences if we so desire. These functions are in the CNT package too. 
The IntegerExponent [ n ,  b )  function (new in version 4.0; included in 
CNT package for version 3 users) returns the highest power of b that divides 
n. NestList is used to iterate the modular squaring function, and so 
generates the b-sequence. Then MemberQ and Or ( I  I )  are used to check 
whether the b-sequence indicates strong pseudoprimality. 
SpspSequence [b_, n_] : = Module [ { • = Integerlxponent [ n - 1 , 2 ]  } ,  
llestList [Mod [ l2 , n ]  & ,  
PowerMod [ b ,  ( n - 1 ) 1 2• , n] , s ]  / .  n - 1 -+ - l ]  
StrongPseudoprimeQ [b_, n_] : = I f  [ PrimeQ [ n ]  1 1  n = =  1 ,  False , 
bSeq = SpspSequence [b ,  n] ; 
Union [bSeq] == { l }  1 1  MemberQ [bSeq, - 1 ] ] 
SpspSegyence [ 2 ,  7 9 1 9 ]  
{ 1, 1 } 
Now we can easily find the 2-strong pseudoprimes among the first 
10,000 integers. 
Select [ Range [ 3, 10000 , 2] , strongPseudoprimeO [ 2 ,  I ]  & ] 
{ 2 0 4 7 , 3 2 7 7 ,  4033 , 4 6 8 1 , 832 1 } 
The test is certainly imperfect, for there are five false positives. But the 2-
spsp test does have an impressive success rate of 99.95% on this interval. 
There are several 3-spsps in this interval too, but if we run the test using 2 
and 3 together, it is formidable indeed. The first bad integer for this double 
test is 1,373,653. And below 1016 the odds of being fooled when using the 
bases 2 and 3 together are 1 in 200 billion. 
StrongPseudoprim@O [ { 2 ,  3 }  , 13 7 36 5 3 ]  
{ True , True } 
{SpspSeguence [ 2 , 137365 3 ] , SpspSeguence [ 3 ,  1 3 7 3 6 5 3 ] } 
{ { 8 9 0 5 9 2 , - 1 ,  l } , { 1 ,  1 ,  1 } } 
Factorinteger [ l 3 7 3 6 5 3 ]  
{ { 82 9 ,  l } , { 1 6 5 7 , 1 } }  
Indeed, if we made a test that combined the base-b strong pseudoprime 
tests for b = 2, 3, 5, 7, 11 then that test would be very efficient, as there are 
no counterexamples less than 25· 109• The composite integer 3215031751 is 
the first integer that is a b-spsp for b = 2, 3, 5, and 7. It is caught by b = 11. 
In such a case we would say that 11 is the first witness to the composite­
ness of the integer in question. 

4.2. PRI ME TESTING AND CERTIFICATION 
1 1 7  
StrongPseudoprimeO [ Range [ 2 ,  1 2 ] , 32 1503 17 5 1 ]  
{ True , True , True , True , True , 
True , True , True , True , False , True } 
Factorinteger [ 32 1 50 3 17 5 1 ]  
{ { 1 5 1 ,  1 } , { 7 5 1 ,  1 } , { 2 835 1 ,  1 } }  
A record of sorts was set by the composite number n = pqr (found by D. 
Bleichenbacher [Ble]), where p, q, and r are the following primes. 
p = 182 1 5 7 4 5 4 5 2 5 89259639 ; 
q = 43370822 506 164903 9 1 ; 
r = 867 4 1 6 4501232 9807 9 ;  
D = p q r ; 
The first witness for this 56-digit composite number is 101. 
Select [Range [ lOl ] , ! StrongPseudQprimeO [ I ,  n ]  & ,  l ]  
{ 1 0 1 } 
There is also a package function that gives the first strong psp witness. 
FirstSPSPWitness [ n ] 
1 0 1  
It is strongly suspected (indeed, it follows from the unproved extended 
Riemann Hypothesis) that checking all bases up to 2(log n)2 is a true test of 
primality; such a test would run in polynomial time. Exercise 4.15 shows 
that, below 1016, the first strong pseudoprime witness for n is less than 
1.66(log n)2 • If we avoid small numbers by starting at the first 3-strong 
pseudoprime (204 7), the witness upper bound below 1016 becomes 
0.052(log n)2 • 
Now we have a better understanding of Mathematica's PrimeQ func­
tion. It combines a 2-spsp test, a 3-spsp test, and a Lucas pseudoprime test 
(a detailed discussion of Lucas pseudoprimes is in Chapter 8). There is no 
known counterexample to the assertion that these three tests pass the 
primes and only the primes; it has been checked by D. Bleichenbacher that 
there is no counterexample under 1016• Finally, we note that for any fixed 
set of bases !B there are infinitely many numbers that are b-strong 
pseudoprimes for each b E !B [AGP]. 
ª Industrial-Grade Primes 
Strong pseudoprimes are much rarer than pseudoprimes. Below one mil­
lion, there are 2445 2-pseudoprimes but only 46 2-strong pseudoprimes. 
Some years ago, Pomerance, Selfridge, and Wagstaff [PSW] took the search 
for 2-pseudoprimes up to 25 billion. They found 21853 pseudoprimes and 

1 1 8  
4. PRI M E  NUMBERS 
only 4842 strong pseudoprimes. Even better is the fact that there is no 
analog of Carmichael numbers for strong pseudoprimes. Following Bach 
and Shallit [BS], we shall call a base b a strong liar for the composite 
integer n if n passes the strong pseudoprime test for the base b. As we shall 
show in Section 4.3, the set of strong liars for a composite n cannot be 
larger than (n - 1)/4, and, in fact, it is usually much smaller than this. 
Thus the probability of a composite integer passing the strong pseudoprime 
test using m random bases is at most 4-m . If we run this test 10 times and 
n passes each time, we can be 99.99999% confident that n is prime, for if it 
were not, then each of the random choices of b would have have to come 
from a set of integers contained in [l, n] whose size is no greater than n/ 4. 
The chance of this happening in a specific case is at most 1/4, and so the 
chance of this happening in 10 independent trials is no greater than 4-10, or 
about 10-7• If an integer passes this test for 100 random choices of b, then 
the probability that it is not prime is less than 10-so. This probabilistic 
approach is known as the Miller-Rabin test, and the Mil lerRabin­
PrimeQ function from the CNT package performs this test any number of 
times. 
D = 1080 + 129 ; 
MillerRabinPrimeO [ n , 100] 
True 
The odds that each of the 100 random integers was a strong liar is so 
remote that, for any practical purpose, we can be certain that 1080 + 129 is 
prime. 
The issue has been raised whether or not this is good enough. Remem­
ber that a positive probability of failure surrounds any project carried out 
on a computer because no computer program is absolutely 100% guaranteed 
to run correctly. In practice, several strong pseudoprime tests are good 
enough for those times - such as constructing an RSA cryptosystem 
(discussed in Chapter 5) - when one needs to identify large primes. Henri 
Cohen has called such highly probable primes industrial-grade primes. 
But it would be nice to be able to prove rigorously (called: certifying a 
prime) that a given integer is prime. The remainder of this chapter will look 
at tests that give us absolute certainty. These tests share the drawback 
that they do not identify composite integers. They simply run indefinitely 
when a composite integer is the input. For this reason, you will want to use 
a pseudoprime test before attempting to certify primality. You need to know 
that your number is probably prime before you try to prove that it is prime. 
 Prime Certification Via Primitive Roots 
So far our discussion of prime testing has focused on methods that tell us 
that n is probably prime. But suppose we wish to have an absolute proof of 
primality. Such a proof is often called a certificate of primality, the point 

4.2. PRI M E  TESTI NG AND CERTI FICATION 
1 1 9 
being that the certificate should contain enough information so that it can 
quickly be turned into a rigorous proof of primality. We now discuss one 
way to get certificates for primes p for which we can find the complete 
factorization of p - 1. 
The method that we shall focus on here is based on the observation that 
n is prime if and only if <fJ(n) = n - 1. As we have seen in Exercise 3.3, the 
only practical means of calculating <fJ(n) is first to find the complete factoriza­
tion of n, which seems to defeat our purpose. But if, for an integer n, we can 
find b such that ordn(b) = n - 1, then we will know that n is prime, since 
ordn(b) divides <fJ(n) and so this proves that <fJ(n) = n - 1. And if n is prime, 
there definitely exists such a b: any primitive root will do (see Section 3.5). 
The primitive roots are fairly common: there are <fJ(n - 1) of them by Corol­
lary 3.13. So to prove n is prime all we have to do is find one of these primi­
tive roots and verify that its order really is n - 1. 
Let b be between 1 ·and n. We want to see if n - 1 is the order of b 
modulo n. If it is, we have our proof; if not, we keep looking. We could try 
all integer powers up to and including n - 2 and check that none is congru­
ent to 1, but this is neither practical nor necessary. If bn-l = 1 (mod n), then 
the true mod-n order of b must divide n - 1. This means that in our search 
for a smaller order we can restrict ourselves to the divisors of n - 1. 
We can do much better than this. If we know that the factorization of 
n - 1 is pɋ' p©2 • • •  pɌ' , where p1 = 2, and if the order of b is not n - 1, then, 
because ordn(b) divides n - 1, there must be at least one p; such that 
(n - 1)/ Pi is a multiple of the order of b. This means that if b's order is not 
n - 1, then b<n-l)/p, = 1 (mod n) for some i, 1 :s; i :s; r. We will sometimes call b 
a witness to n's primality (the term "witness" in the context of strong 
pseudoprimes is used to refer to a witness for compositeness). The theorem 
that follows gives a slight improvement to the preceding criterion by reduc­
ing the size of the exponents from (n - 1)/ Pi to (n - l)/(2pi). 
Theorem 4.5. Suppose that n is odd and n - 1 has the prime factorization 
pɋ' p©2 • • •  pɌ' , where p1 = 2. Suppose that b has the following property: 
b<n-1>12 = -1 (mod n) but for each i > 2, b<n-l>IC2P• l '$ - 1 (mod n). Then ordn ( b) = 
n - 1. It follows that <fJ(n) = n - 1 and so n is prime. 
Proof. The first congruence tells us that ordn(b) divides n - 1 but does not 
divide (n - 1)/2. It follows that 2e1 divides ordn(b). We claim that the remain· 
ing congruences imply that ordn(b) does not divide any (n - 1)/ Pi; it will 
follow that each pr• divides ordn(b), and this will mean that n - 1 divides 
ordn(b), and therefore ordn(b) = n - 1, completing the proof. To prove the 
claim, let b<n-1>1<2Pil = a (modn), where a '$ -1, and suppose that bCn-l)/p, = 
1 (mod n). Then a2 = 1 (mod n) and aP· = -1 (mod n); but aP• = (a2 )Cp,-I>t2 a =  
a (mod n), a contradiction because a '$  - 1. 
o 
The preceding theorem leads to the following algorithm for proving a 
number is prime. 

1 20 
4. PRI M E  NUMBERS 
Algorithm 4.3 Prime Certification via Prim itive Roots 
This algorithm terminates when it has found an element of order n - 1 
modulo n, which proves that n is prime. It will not terminate if n is not 
prime. We use oddprimes to denote the set of odd primes that divide n - 1. 
StringForm [ " abed' ' efg' - " , x ,  y] produces the string where x and y 
are substituted for the two ' - s in order; this can be used to create informa­
tive output. The _ ?OddQ is used to restrict the function to odd arguments, 
but it is worth modifying the code so that it recognizes (most) composite 
integers; see Exercise 4.20. Because PowerMod is a "listable" function we 
can use a list as the second argument, and check whether 1 occurs in the 
resulting list. 
PrimeQWitbProof [n_ ? OddQ] : = Module [  
{oddprimes = Rest [Map [First , Factorinteger [n - 1 ] ] ] ,  b = 2 } , 
Wbile [ PowerMod [ b ,  (n - 1 ) / 2 , n] "l n - 1 1 1 
MemberQ [ PowerMod [b, (n - 1 ) I ( 2  oddprimes) , n] , n - 1 ] , b + + ] ; 
StringForm [ "n = ' '  is prime ; ' '  bas order n - 1 .  " ,  n ,  b] ] 
This algorithm requires the factorization of n - 1. That will be difficult 
for a random large prime, say the first prime beyond 1050. But for some 
special classes of primes this presents no problem at all. For example, we 
can look at the 1 1th and 75th Euclid numbers, in which case n - 1 is very 
easy to factor. The following computations provide witnesses to the primal­
ity of these large integers. 
PrimeQWitbProof [Buclid [ l l ] ] 
n = 20056049 0 1 3 1  is prime ; 34 has order n - 1 .  
PrimeQWitbProof [Buclid [ 7 5 ] ] 
n =  
17 1 9 6 2 0 1 05 4 5840643348 334056 8 3 1 7 5 4 3 0 1 9 5 8 4 5 7 5 6 3 5 8 9 5 7 4 2 5 6 0 4 3 8 Ğ  
7 7 1 1 05 0 5 8 3 2 1 6 5 5 2 3 8 5 6 2 6 1 30839 7 9 6 5 1 4 7 9 5 5 5 7 8 8 0 0 9 9 9 4 5 5 7 8 2 2 02 4 Ğ  
5 6 5 2 2 6 9 3 2 9 06295208262756822 2 7 5 6 6 3 6 9 4 1 1 1  
is prime ; 1 9  has order n - 1 .  
Note that to be a useful certificate, the output should include the prime 
factorization of n - 1; for, with that in hand, one could easily check that the 
claimed witness really has maximal order. This point will be discussed in 
more detail in the Pratt certificate subsection that follows. 
As we saw in Exercise 3.6, the average value of </J(m) is 6m/TC2 • Of 
course, m = n - 1 is not arbitrary. It must be even, and for even integers the 
average value of </J(m) is 4m/Tr2• Experimental evidence suggests that when 
m is one less than a prime, then </J(m) is about 0.37 m, still a very high 
fraction of all the residues. Thus one can expect to find a primitive root 
quickly. The difficulty is not in finding a primitive root when n is prime. 
The drawback to this algorithm is that you have to be able to factor n - 1 in 
order to prove that n is prime. If n has fewer than 50 digits, then this is 

4.2. PRIME TESTI NG AND CERTIFICATION 
1 21 
often possible with the methods that will shall investigate in this book. 
When n has more than 50 digits, you need to switch to a more sophisticated 
technique such as those described briefly at the end of this chapter. 
« An Improvement 
It is possible with a little additional insight to make some improvements to 
Algorithm 4.3. An observation made by Brillhart, Lehmer, and Selfridge in 
1975 is that we do not really need to find a primitive root. It is sufficient if 
for each of our odd prime divisors of n - 1, p2 through Pr . we can find a b; 
for which bǀn-1>12 = - 1  (mod n) and w-ntcZp;) ";JE - 1 (mod n). The first congru-
ence tells us that the order of b2 divides n - 1  but not (n - 1)/ 2. This implies 
that 2e1 must divide the order of b2 • Because the order of b2 divides efJ(n), 2e1 
must also divide efJ(n). The second congruence tells us (by the same reason­
ing as in the proof of Theorem 4.4) that the order of b; (which, from the first 
congruence, must divide n - 1) does not divide (n - 1)/ p; , and so the order of 
b; is divisible by pr' .  This implies that efJ(n) is divisible by pr' .  When we have 
found such a b; for each odd prime divisor of n - 1, we will have established 
that n - 1 divides efJ(n), which can only happen if n is prime. This argument 
fails if n has the form 2m + 1, for then there is no odd prime p2 • In that case 
we use the method of Algorithm 4.3. 
The algorithm given below is the modified form of Algorithm 4.3 in 
which the certificate of primality is the list of bases that work for each of 
the odd prime divisors of n - 1. 
Algorithm 4.4 Im proved Prime Certification via Pri m itive Roots 
This algorithm terminates when it has found a proof that </J(n) = n - 1, 
which proves that n is prime. It will not terminate if n is not prime. The 
I f  ( ] construction deals with the case that n - 1 is a power of 2. Scan ( 
Function [ k ,  bvals [ k )  
= b )  , P 1 )  scans the list P 1 and applies the 
function defined by Function [ ] to each element p in the list. That func­
tion assigns a b-value to bvals [ p ] .  The While construction starts with the 
full set of odd prime divisors and deletes them as witnesses are found; once 
that set becomes empty the complete set of witnesses has been found. 
BLSPrimeProof [n_] : = Module [ {b = 2 ,  bvals ,  
P = oddprimes = Rest [Map [ First , Factorinteger [ n  - l ] ] ] } , 
I f [ P  = =  { } ,  While [ PowerMod [ b ,  (n - 1 )  / 2 ,  n] ¢ n - 1 ,  b + + ] ; 
StringForm [ " n  = • • 
is prime ; the prime divisors of n- 1 
and their witnesses are 
• • " ,  n ,  Transpose [ { { 2 ,  b } } ] ] ,  
While [ P  ¢ { } , I f  [ PowerMod [ b ,  (n - 1 )  I 2 ,  n] = =  n - 1 , 
Pl = Select [ P ,  PowerMod [ b ,  (n - 1 )  I (2 I ) , n] ¢ n - 1 & ]  ; 
Scan [ Function [ k ,  bvals [ k ]  = b ] , Pl ] ; P = Complement [ P ,  Pl] ] ;  
b + + ] ; StringForm [ " n =  - -
is prime ; the odd prime 
divisors of n- 1 and their witnesses are 
• • " ,  n ,  
Transpose [ { oddprimes , Map [ bvals , oddprimes ] } ] ] ] ] 

1 22 
4. PRIME NUMBERS 
This variation can be many times faster than Algorithm 4.3. 
8LSPrimeProof [ l 3 1 ]  
n = l 3 1  is prime ; the odd prime divisors 
of n- 1 and their witnesses are { { 5 ,  2 } ,  { 1 3 ,  2 } }  
&LSPrimeProof [Euclid [ l l ] ] I I  ±iming 
PrimeQWithProof [Euclid [ l l ] ] / /  ±iming 
{ 0 .  0 1 6 6 6 6 7  Second , 
n = 2 0 0 5 6 0 4 9 0 1 3 1  is prime ; the odd prime divisors of n- 1 
and their witnesses are { { 3 ,  2 } ,  { 5 ,  3 } ,  { 7 ,  2 } ,  { 1 1 ,  2 } , 
{ 1 3 ,  2 } , { 1 7 ,  2 } ,  { 1 9 ,  2 } , { 2 3 ,  2 } ,  { 2 9 ,  2 } ,  { 3 1 ,  2 } } }  
{ 0 . 3 Second , n = 20056049 0 1 3 1  is prime ; 34 has order n - 1 . }  
 Pratt Certificates 
The primality test of Algorithm 4.3 does not really produce a certificate 
because the output is not detailed enough for the user to verify that Theo­
rem 4.5 holds. For that, the user would need to know the prime factoriza­
tion of n - 1, and that information was not provided. Moreover, even if that 
factorization was provided, how would the user know with certainty that 
the primes in the list are really prime. In 1975, Vaughan Pratt made the 
nifty observation that the same method can be used on those primes! That 
is, we can use a recursive technique to certify n, where the same procedure 
is used to certify the primes in the factorization of n - 1. This leads to a tree 
structure for the certificate. The PrattCertif icate function from the CNT 
package can be used to get such trees; here is an example for the lOOOth 
prime. 
PrattCertificate [ 7 9 1 9 , ±ree -+ ±rue] 
,-"-· -
I 
7 9 1 9  -+ 7 
2 
37 
-+ 2 
2 
3 
-+ 2 
2 
1 0 7  -+ 2 
2 
53 -+ 2 
2 
1 3 
-+ 2 
2 
3 
-+ 
2 
----
L 
__ _ _ 
2J" 
Here is how to read this tree. The primes 2, 37, and 107 are the primes 
that occur in the factorization of 7918 (some of them could occur to a power 
higher than 1, but that is not shown as it is not relevant). The number 7 to 

4.2. PRIME TESTI NG AND CERTI FICATION 
1 23 
the right of the first arrow is the witness for the primality of 7919 in that it 
has full order; that is, it satisfies the congruence conditions of Theorem 4.5. 
Now the same rules apply recursively: 2 and 53 are the prime factors of 106 
and 2 is the value of b showing that 107 is prime. Note that 2 is considered 
to be self-certifying: everyone knows that 2 is prime. 
A slight modification to the code of Algorithm 4.3 yields code that 
produces these Pratt certificates. Of course, we repeat the drawback that 
one must be able to factor n - 1 for this to work. 
Algorithm 4 . 5 .  Pratt Certificates of Pri mality 
We call this PrattCerti f icateBas ic to avoid a clash with the package 
function. It is essential to make w and primes local variables (via Module) 
so that they are distinct variables at every stage of the recursion. The 
routine finds a witness w using the citerion of Theorem 4.4, and then calls 
itself on the primes showing up in the factorization of n - 1 to certify them 
in the same way. We make PrattCertificateBas ic listable so that we 
can use it on a list of primes (the last line of the code). We also check the 
input to see that PrimeQ thinks it is prime, for otherwise the search for a 
witness will never end. The output is a nested list. 
Attributes [ PrattCertificateBasic] = Listable ; 
PrattCerti ficateBasic [ 2 ]  = 2 ;  
PrattCertificateBasic [p_Integer ? PrimeQ] 
·
-
Module [ {w = 2 ,  primes = First /0 Factorinteger [p - l ] } ,  
While [ PowerMod [w , (p - 1 )  / 2 ,  p ]  ¢ p - 1 I I MemberQ [ 
PowerMod [w , (p - 1 )  I (2 Rest [primes ] ) , p] , p - 1 ] , w + + ] ; 
{p , w ,  PrattCertificateBasic [primes ] } ]  / ;  p > 2 
Here is an example (we give the straight-line form followed by the tree 
form) that certifies the primality of 1030 + 57. 
The version in the CNT package gives the certificate in the form of a 
tree. Because p - 1 is even, there will be a 2 in each list of primes; because 2 
is self-certifying we may as well shorten our certificates by suppressing the 
2s. The package version has an option to do this. 
PrattCerti ficate [ l030 + 57 , Sbow2 s -+ False] 
{ 1 000000000000000000 000000000057 , 5 ,  
{ { 3 ,  2 } , { 7 9 0 4 3 , 2 ,  
{ { 3 9 52 1 ,  3 ,  { { 5 ,  2 } , { 1 3 ,  2 ,  { { 3 ,  2 } } } , { 1 9 , 2 ,  { { 3 ,  2 } } } } } } } , 
{ 3 9 9 8 7 4 1 ,  2 ,  { { 5 ,  2 } , { 1 7 ,  3 } , { 1 9 ,  2 , { { 3 ,  2 } } } , 
{ 6 1 9 ,  2 ,  { { 3 ,  2 } , { 1 0 3 , 5 ,  { { 3 ,  2 } , { 1 7 ,  3 } } } } } } } , 
{ 2 9 0 2 4 0 0 1 7 , 1 0 ,  { { 3 ,  2 } , { 1 1 ,  2 ,  { { 5 , 2 } } } , 
{ 1 8 1 ,  2 ,  { { 3 ,  2 } , { 5 ,  2 } } } , { 3037 , 2 ,  
{ { 3 ,  2 } , { 1 1 ,  2 ,  { { 5 ,  2 } } } , { 2 3 ,  5 , { { 1 1 ,  2 ,  { { 5 ,  2 } } } } } } } } } , 
{ 4 54 1 9 7 5 3 9 , 2 ,  { { 3 3 1 , 3 ,  { { 3 ,  2 } , { 5 , 2 } , { 1 1 ,  2 ,  { { 5 ,  2 } } } } } , 
{ 6 8 6 0 9 9 , 2 ,  { { 7 ,  3 ,  { { 3 ,  2 } } } , 
{ 7 0 0 1 , 3 ,  { { 5 ,  2 } , { 7 ,  3 ,  { { 3 , 2 } } } } } } } } } } }  

1 24 
4. PRIME NU MBERS 
PrattCertificate [ l030 + 57 , Tree -+ True , Sbow2 s -+ False] 
r·- ·-·· 
i 
1000000000000000000000000000057 -+ 5 
3 
-+ 2 
79043 -+ 2 
3 9 5 2 1  -+ 3 
3 9 9 8 7 4 1 
-+ 2 
5 
-+ 2 
1 3 
-+ 2 
3 
-+ 2 
19 
-+ 2 
3 
-+ 2 
5 -+ 2 
1 7  -+ 3 
19 
-+ 2 
3 
-+ 2 
6 1 9  -+ 2 
3 
-+ 2 
103 -+ 3 
3 
-+ 2 
1 7 
-+ 3 
2 902400 1 7  -+ 5 
3 
-+ 2 
1 1  -+ 2 
5 -+ 2 
181 -+ 2 
3 
-+ 2 
5 
-+ 2 
3037 -+ 2 
3 
-+ 2 
1 1  -+ 2 
5 
-+ 2 
2 3  -+ 5 
1 1  -+ 2 
5 
-+ 2 
454 1 9 7 5 3 9  -+ 2 
33 1 
-+ 2 
3 
-+ 2 
5 -+ 2 
1 1  -+ 2 
5 
-+ 2 
686099 -+ 2 
7 
-+ 3 
3 
-+ 2 
7001 -+ 3 
5 
-+ 2 
7 
-+ 3 
3 -+ 2 
! 
We repeat that the information in this table can be used to, very 
quickly, get a complete and rigorous proof of the primality of 1030 + 57: just 

4.2. PRIME TESTI NG AND CERTI FICATION 
1 25 
check that the primes in the vertical columns do exhaust the various num­
bers of the form n - 1, and then check that the congruences of Theorem 4.5 
are satisfied by the various witnesses to the right of the arrows. Note that 
finding these witnesses is generally quite easy: most of the time 2 works. It 
is a good exercise in recursive programming to write a routine that takes 
the straight-line certificate and performs the computations necessary to 
verify that it behaves as claimed (Exercise 4.23). 
Both the length of a certificate and the time needed to verify the claims 
for the entries in the certificate are polynomial functions of the length of 
the input (details omitted). This means that Pratt's method proves that the 
problem of determining primality is in the complexity class NP. Recall that 
1' denotes the set of problems solvable in polynomial time. The class N1' 
stands for problems solvable in nondeterministic polynomial time. A set 
X is in N1' if for each x in X there is a certificate whose length is polyno­
mial in the length of x and that can be checked to be a certificate in time 
polynomial in the length of x. If the certificate checks out properly, then x 
lies in X. If x does not lie in X the program does nothing. The certificate is 
viewed as heaven-sent because the definition makes no provision for find­
ing the certificate. It might seem that this notion is uninteresting, because 
heaven is not in the business of providing certificates to us. But in fact the 
notion is very important. 
Consider the set of composite integers, for example. It is easy to see 
that this set is in N1' because a certificate for a composite n can be a pair 
{a, b) where n = ab. Of course, such pairs may be very hard to find, but if we 
have a pair, it is easy to multiply a by b and check that the product is n; so 
the pair works as a certificate. Now, the class N1' is apparently asymmet­
ric: the fact that X is in N1' gives no information about the complement of 
X. So composites are in N1' but it might seem unlikely that the primes are 
in N1', because there is no obvious way to certify a number's primality. But 
the work of Pratt just described shows that every prime does indeed have a 
short certificate. The code in Algorithm 4.5 actually searches for the certifi­
cate; that algorithm itself is not a polynomial time algorithm because of the 
factoring step. It is the verification of the Pratt certificate (Exercise 4.23) 
that will be fast. 
Amazingly, it is not known that the class N1' is really different from 1'. 
Indeed this problem, called the 1' = N1' problem, is the most important 
unsolved problem of theoretical computer science. Of course, 1' १ NP 
because a fast algorithm that works without a certificate can be viewed as 
working with the empty certificate. 
For serious certification work we can improve the basic Pratt certificate 
in several ways, the aim being to make it smaller. As noted, we may as well 
suppress the 2s. And we can use the knowledge that Mathematica's PrimeQ 
is reliable up to 1016 and avoid certifying such small primes. The PrattCer­
tif icate function in the package uses an AssumedPrimeBound that 
controls this last point. Using the options, the certificate for 1030 + 57 
becomes remarkably short. 

1 26 
4. PRI M E  NUMBERS 
PrattCertificate [ l030 + 57 , Tree -+ True , 
Show2 s -+ False , AsswnedPrimeBound -+ 1016 ] 
-loOOOOOoooooooOOOOoooooo0000051 3.:.:-1 
3998741 I 
290240017 
__ 4_54V9-_75W 
One can shorten the Pratt certificate even more by appealing to Theo­
rem 4.6 that follows. We use Factor integer and if that works, then we 
have the full factorization of n - 1. But we don't actually need all the primes 
and the certificate works so long as we look at enough primes of the factor­
ization of n - 1 so that they multiply to more than Yn. This cuts down on 
the number of conditions the witness has to satisfy. The ideas of Theorem 
4.6 go back well into the nineteenth century. The variation that follows was 
proved in 1914 by Henry Cabourn Pocklington (1870-1952). 
Theorem 4.6. Suppose n - 1 factors into F · R = (0f=1 pf' ) ·  R, where 
R < Vn. And suppose that a witness b exists so that 
1. bn- l = 1 (mod n), and 
2. gcd(bcn-l)/p, - 1, n) = 1 for i = 1, . . .  , s. 
Then n is prime. 
Proof. Let p be the smallest prime divisor of n and let d = ordp(b). Then d 
divides p - 1. Further, by assumption (1), d divides n - 1. But d does not 
divide (n - 1)/ p;, because doing so would violate assumption (2) (for then p 
would divide both n and b<n- llfp, - 1). This means that pf' divides d for each 
i, so F divides d. But d divides p - 1, so F divides p - 1  and therefore 
p - 1  F d Yn, a contradiction unless p = n. 
D 
The version of PrattCertificate in the CNT package incorporates 
this theorem via the FullPrattCertificate option. When that is set to 
False, then we start with the largest primes and continue down until we 
have captured Vn. The resulting reduction in certificate size can be impres­
sive. For example: 
PrattCertificate [ l030 + 57 , Tree -+ True , Sbow2 s -+ False, 
AsswnedPrimeBound -+ 1016 , FullPrattCertificate -+ False] 
r--100]0XYZ[0000000\-0-000000000057 ݜ 2 
290240017 
454197539 
· · · · · · -----·-··- · · - ·······-.. -- ---
······ -----·-· ·-· · --..J 
To check such a certificate one would check that the two primes really 
divide n - 1 and that, when multiplied together, they are greater than vn. 

4.2. PRIME TESTI NG AND CERTI FICATION 
1 27 
There are four other primes in the factorization of 1030 + 56, but they can be 
ignored thanks to Theorem 4.6. 
One can use Theorem 4.6 to construct large primes that are certifiably 
prime. The basic idea is due to U. Maurer [Mau]. 
Algorithm 4.6. Getting Certified Primes 
Suppose that we want p, a d-digit prime that is certifiably prime. Select a 
prime q having rd I 21 + 1 many digits (this can be done recursively). Then 
choose a random integer r < q and adjust it by adding (randomly) one of two 
small integers so that 1 + rq = ± 1 (mod 6); then check whether p = rq + 1 
can be declared probably prime by a pseudoprime test. If so then, because 
we know (with certainty!) that q is prime, we have enough of a factorization 
of p - 1 to apply Theorem 4.6 and check whether b = 2 is a witness to p's 
primality. As discussed in Exercise 4.29, it is almost always the case that 2 
will work as the witness b, so that we lose nothing by relying on 2 to be the 
witness. If p fails to be probably prime we can just add 6 to the random 
multiplier r and try again (and again and again). Below 107 we can simply 
use RandomPrime; this calls PrimeQ, which is known to tell the truth in 
that domain (we could use this under 1016, but it seems faster to use 107 as 
the crossover point). 
And now here is a recursive routine to get large certified primes. The 
Certif iedPrime routine returns the prime only. If the ShowPrimeCer­
tif icate option is set to True then it returns a complete certificate. The 
code makes use of some tricks for speed: the mod-6 residue of the first 
random prime selected (call it q0, the base case of the recursion) is stored in 
the form adjust = 1 - q01 (mod 6). Then as the random multipliers r are 
generated, they are immediately adjusted to be 0 (mod 6), and then adjust 
is added; this guarantees that each 1 + qr =  q0 (mod 6). Because of the size 
of q and the bounds on r, it follows that r < q and 1 + qr has d base-10 
digits. We can gain some speed by using a rudimentary prime test instead 
of the more cautious PrimeQ. Thus we use QuickPrimeQ which combines a 
single gcd to check the existence of a small prime divisor in [5, 863] with a 2-
pseudoprime test. We are assuming that the unlikely event of randomly 
getting a 2-pseudoprime for one of the q-values (which would send the 
routine into an infinite loop since 2 will never be a Pocklington witness) will 
not occur. 
Options [CertifiedPrime] = { SbowCertificate -+ False } ; 
primeProd = Apply [ Times , Prime [Range [ 3 , 150] ] ] ;  
QuickPrimeQ [ n_] : =  
GCD [ n ,  primeProd ] = =  l && PowerMod [2 , n - 1 ,  n ]  = =  1 ;  
CertifiedPrime [d_, opts_] : = 
I f [ SbowCertificate / .  { opt& } / .  Options [CertifiedPrime ] , 
Identity , First ] [PrimeAndCertificate [ d] ] ;  

1 28 
4. PRI M E  NUMBERS 
PrimeAndCert ificate [d_] : =  
Module[ {p , r ,  q, ql = PrimeADdCertificate [Ceiling [d / 2 ]  + 1 ] } ,  
q = ql [1] ; r = Random [ Integer , 
r = r - Mod [ r ,  6 ]  + adj ust ; 
While [ r  = r +  6 ;  p = 1 + q r ; 
{ 10 . d - l  , 10 . d } ] 
,
· 
q 
I QuickPrimeQ [p] V GCD [p ,  PowerMod [ 2 , r ,  p] - 1 ]  'I- 1 ] ; 
Prepend [ql , p] ] ; 
PrimeAndCertificate [ d_ I ;  d < 8 ]  . -
{qO = Randomrrime [d] ; adjust = 1 - PowerMod [qO ,  - 1 ,  6 ] ; qO } ; 
CertifiedPrime [ SO ] 
3 4 0 8 7 1 7 4 5 4 5 5 1952590 1 6 9 3 1376 2 7 3 5 1 7 4 1 0 8 2 5 5 7 4 6 2 2 2 8 3 4 1  
CertifiedPrime [SO, SbowCertificate -+ '.rrue ] 
{ 3 4 0 8 7 1 7 4 5 4 5 5 1952590 1 6 9 3 1 3 7 62 7 3 5 1 7 4 1 0 8 2 5 5 7 4 6 2 2 2 8 3 4 1 ,  
32 1 0 5 6 4 53 6 1 2 17806642 3 1053 7 ,  6 8 9 7 3 6 1 4 1 8 6 8 3 1 ,  5 7 7 3 4 4 4 9 , 7 0 7 5 3 } 
cert = CertifiedPri• [ lSO ,  SbowCertificate -+ '.rrue] 
{ 2 0 0 6 3 1 0 7 7 3 0 74 7 7 9 7 1 5 2 7 8 1759046 2 5 3 54 5 4 8 2 0 1 1 6 2 0 6 7 55 8 8 1 6 3 5 2 5 5 3 5 \  
2 4 9 4 6 3 8 9 6 5 836422 3 4 5 7 84252750 7 2 2 1 5 2 5 9 3 7 2 5 8 2 0 52 1 7 3 4 8 7 9 3 9 6 7 6 8 \  
6047 0 4 1 4 7 5 79160792 14017002 2 1 142 2 7 ,  
2 0 0 1 2 1 5 7 3 6 9 956 1051 1 4 8 3 8 4 2 7 7 5 3 1 7 3 0 6 2 7 8 3 4 8 8 8 7 5 3 1 2 4 3 0 4 6 6 9 5 4 02 9 \  
9 5 7 0 1 1 6 7 5 6 92 8 1 5 7 3 , 435706909 5 2 6 5 1 8 9 4 1 2 5 5 7 5 9 7 3 1 1 4 6 3 2 9 2 8 2 57 7 , 
1 4 6 0 0 7 8 00 4 9 002 8 40 9 8 7 9 , 3 4 4 6 3 50 8 8 7 5 3 , 5 9 0 2 9 0 3 } 
It is not hard to check that all the primes in cert are proved prime by the 
witness 2 (except for the last prime, which is less than 107). The following 
code checks them all at once. 
'.rable[ {p , q} = cert [ [ { i ,  i + l } ] ] ;  {q > VP , PowerMod [ 2 , p - 1 ,  p] , 
GCD [p , PowerMod [ 2 , (p - 1 )  I q,  p] - 1 1 } , { i , Length [ cert ] - 1 } ] 
{ { True , 1 ,  1 }  , {True , 1 ,  1 }  , 
{ True , 1 ,  1 } ,  {True , 1 ,  l } ,  { True , 1 ,  1 } } 
Now here's a surprise: The generation of certified primes by Maurer's 
method is, for large integers, faster than using Pr imeQ, which provides 
numbers that are only probably prime; see Exercise 4.32. 
Exercises for Section 4.2 
4.14. For plain pseudoprimes we use only prime bases because of Exercise 
2.41, which shows that the first pseudoprime witness must be prime. Show 
that the analogous statement for strong pseudoprimes is false. More pre-

4.2. PRI M E  TESTI NG AND CERTI FICATION 
1 29 
cisely, show that the following is false: If n is a b-spsp and a c-spsp, then n 
is a bc-spsp. Hint: Let n = 410041. 
4.15. (a) 
Exercise 4.14 raises the possibility that the first strong 
pseudoprime witness to the compositeness of an odd n might be composite. 
A search for such a number should focus on numbers that are known to be 
2- and 3-strong pseudoprimes, because we want the first witness to be 
neither 2 nor 3. The StrongPseudoprimes function (based on computa­
tions of D. Bleichenbacher) accesses a list of all such candidates below 1016 . 
The usage is StrongPseudoprimes [ { 2 ,  3 } , max ] , where max :s; 1016. Use 
this function to find an odd n whose first witness is composite. Find the 
first instance of each composite that occurs. 
(b) Use the results of part (a) and some further computations to show that 
between 2047 and 1016, the first strong pseudoprime witness b for n is less 
than 0.052(log n)2 • 
4.16. Exercise 4.15 suggests that the first strong pseudoprime witness 
cannot be 4. Prove that this is so. More generally, prove that the first 
witness cannot be a square. Prove that the first witness cannot be a perfect 
power. Find an odd composite n so that neither 2 nor 3 are witnesses, but 
12 is. There are no examples below 1016 for which 12 is the first witness, 
but such examples do exist. In 1994, two months of computing time led 
Shuguang Li (University of Hawaii at Hilo) to 1502401849747176241, for 
which 12 is the first strong psp witness. 
4.17. Exercise 2.42 asserts that each composite Fermat number 22k + 1 is a 
2-pseudoprime. Show that each composite Fermat number is a 2-strong 
pseudoprime. 
4.18. (a) Suppose that 21 divides p - 1 for each prime divisor p of n. Prove 
that 21 divides n - 1. 
(b) Prove that if n is odd and b is arbitrary, then bn-l 'f: -1 (mod n). Hint: 
Suppose that the congruence holds and I Pi } are the distinct prime divisors 
of n. Look at the power of 2 in n - 1 and the power of 2 in each ordp, (b). Use 
part (a). 
4.19. (J. H. Davenport) Here is an improvement to the strong pseudo­
prime idea in the case that n = 1 (mod 4). Compute the strong pseudoprime 
sequences corresponding to b = 2, 3, and 5. If one of these proves n is compos· 
ite, we know that n is composite. Otherwise, look at the square roots of - 1  
that show up in the three strong psp sequences [note that such a square 
root can occur only if the first entry of the sequence is not ± 1; this requires 
that the sequence have length at least three, which requires n = 1 (mod 4)]. 
If more than two such square roots occur among the three sequences, n can 
be declared composite. The odds of success are higher if one allows b to take 
on more than three values. Implement this strong strong test with 
b = 2, 3, 5, 7, 11. There are 107 integers below 1016 that are 2-, 3-, 5-, 7-, 
and 11-strong pseudoprimes, and they are quickly available as Strong-

1 30 
4. PRI M E  NUMBERS 
Pseudoprimes [ { 2 ,  3 ,  5 ,  7 ,  1 1 } , 1 0 16 ] .  Of these, 79 are congruent to 
1 (mod 4). How many of these 79 does this strong strong test catch? 
4.20. Modify the code for PrimeQWithProof so that it returns a message 
indicating failure (as opposed to running forever) if the input is composite 
according to Pr imeQ. 
4.21. Let p be an odd prime divisor of n - 1 where n is prime. Prove that if 
b is selected randomly from {1, ... , n - 1} and if b<n-1>12 = - 1  (mod n), then 
the probability that b(n-nt<2P> = -1 (mod n) is 1 / p. 
4.22. Write a program that takes any integer less than 100,000,000 and 
proves either primality or compositeness using the list of all primes less 
than 10,000. Use Eratosthenes [ 1 0 0 0 0 ] to generate the list of primes. 
4.23. Write a routine that takes a straight-line Pratt certificate and veri­
fies that all the claims are true. 
4.24. Write a routine that takes a straight-line Pratt certificate in short­
ened form, as discussed following Theorem 4.6, and verifies that all the 
claims are true. 
4.25. Use PrimeQ or a pseudoprime test to find some large prime Fibonacci 
numbers, and then try to certify their primality via Pratt's method. 
4.26. Modify PrattCertificateBasic so that it makes use of Algorithm 
4.5 to avoid finding a witness that works for all the prime divisors, but 
rather finds a list of witnesses, one for each prime dividing n - 1. 
4.27. Modify PrattCertificateBas ic so that it makes use of Theorem 
4.6 to avoid using the full factorizations of the numbers n - 1 that occur. 
4.28. In Theorem 4.6, why is it not sufficient to verify that b7-1 = 1 (mod n) 
and b[n-l)/p, '$ 1 (mod n)? To be more specific: Find an example of a compos­
ite integer n for which n - 1 = F · R where R < Vn < F and gcd(F, R) = 1, 
such that for every prime p that divides F, there is an integer b that satis­
fies bn-l = 1 (mod n) and b<n-l)/p '$ 1 (mod n). 
4.29. Explain why we may as well restrict the witness search to b = 2 in 
Algorithm 4.6. More precisely, if p is prime and p = 1 + rq where q is prime 
and q > ..JP, why are the odds that 2 fails to certify the primality of p via 
the Pocklington method (Theorem 4.6) very small? 
4.30. Prove the following small variation on Theorem 4.6. It requires that 
we factor more of n (we lose a 2) but gets us a little more efficiency in the 
search for b since we have, in cases where F is odd, eliminated the need to 
find a witness b for the case of the prime 2. The proof is almost identical to 
that of Theorem 4.6. 
Suppose n is odd and n - 1 factors into 2R · F = 2R(0f=1 pf' ), where 
F > Vn or, if F is odd, F > R. And suppose a witness b exists so that 

1. bn-l = 1 (mod n), and 
4.3. REFINEM ENTS AND OTH ER DIRECTIONS 
1 31 
2. gcd(bcn- 1 )/p, - 1, n) = 1 for i = 1, . . .  , s. 
Then p is prime. 
4.31. Prove the following extension of Pocklington's method due to (U. Mau­
rer [Mau]): Suppose n is odd and n - 1 factors into 2 R · F = 2 R ( 0f= 1 pf' ) ,  
where F > n 1'3 . Suppose a witness b exists satisfying the two conditions of 
Theorem 4.6. Choose x and y so that 2 R  = xF + y where 0 :S y <  F (so y is 
just Mod[2R, F]). If y2 - 4x is not a perfect square, then n is prime. Hint: 
First improve Theorem 4.6 to show that every prime factor of n is congruent 
to 1 (mod F ). This shows that n can have at most two prime factors. This 
can be used to build a quadratic equation of the form k2 - y k + x that has an 
integer solution, which means y2 - 4x is a square. 
4.32. Compare the speed of generating d-digit primes (with d between 70 
and 150) using Maurer's method against just generating a random number 
and then searching upwards. The latter search, for a fair timing compari­
son, should not use the built-in PrimeQ, but should instead mimic it using 
MillerRabinPr imeQ with 2 bases and the RandomBases option set to 
False to force it to use 2 and 3. This is an adequate simulation of PrimeQ. 
4.33. Implement a modification of Maurer's algorithm for certified primes 
that accepts the digit-size d and a relatively prime pair {a, m} as input and 
returns a certified d-digit prime that is congruent to a (mod m). 
4.3 Refinements and Other Directions 
« Other Primality Tests 
In the nineteenth century, Edouard Lucas discovered how to use what we 
now call Lucas sequences to prove primality when it is possible to factor 
n + 1. This approach will be explained in Chapter 8. It gives us the Lucas­
Lehmer test, a very fast test for checking possible Mersenne primes, inte­
gers of the form 2P - 1. It relies on the fact that (2P - 1) + 1 is very easy to 
factor. In 1975, Brillhart, Lehmer, and Selfridge [BLS] published modified 
primality testing algorithms that relied on partial factorizations of n + 1, 
similar to Pocklington's theorem (Theorem 4.6) or that could be imple­
mented with a partial factorization of n - 1 and a partial factorization of 
n + 1. 
All of these modifications ran up against the difficulty of factoring very 
large integers. The breakthrough came in 1980 when Adleman, Pomerance, 
and Rumely showed how to use algebraic characters to test for primality. In 
1981, H. Cohen and H. W. Lenstra simplified and improved this algorithm, 
and then A. K. Lenstra implemented it. Known as the cyclotomy test, it is 
now the algorithm of choice for proving prime those candidates for which 

1 32 
4. PRIME NU MBERS 
we do not expect to be able to factor n ± 1 easily, basically anything over 
100 digits. It is effective up to about 1000 digits. This test and the mathe­
matics behind it are explained in [Coh] and [CP]. 
A different approach to proving primality for large integers was taken 
by Atkin in the late 1980s. Based on ideas of Goldwasser and Kilian from 
1986, it relies on the arithmetic of elliptic curves. Its running time is less 
predictable than the cyclotomy test. Within the realm of what is now com­
putable, the cyclotomy test is usually faster but the Atkin test has success­
fully proven integers of more than a thousand digits to be prime. It is 
known that somewhere between 1000 and 10,000 digits the Atkin test will 
be consistently faster. This algorithm and the mathematics behind it are 
also explained in [Coh]. 
Mathematica has a package that uses elliptic curve techniques to 
certify large primes. Here is how to load and use it. If you wish to see the 
form of the elliptic curve certificate, set the Certificate option to True. 
For inputs less than 1010 the ProvablePrimeQ function just uses a Pratt 
certificate (this changeover point is controlled by the Smal lPrimes option). 
Heeds [ " HumberTheory' PrimeQ' " ]  
p = 10100 + 267 ० 
ProvablePrimeQ [p] 
True 
The positive result means that a certificate was found that proves that p is 
prime. 
 Strong Liars Are Scarce 
Our next goal is to prove that there are no strong Carmichael numbers. By 
this we mean that for any composite n one can always find a base b rela­
tively prime to n such that the b-strong pseudoprime test declares that n is 
composite. In fact, we will show that there are lots of such bases b. 
Theorem 4. 7. If n is odd and composite, then at most (n - 1) / 4 of the 
residue classes can be strong liars. 
Proof. Al unspecified congruences are modulo n. We begin with the case 
that n is a prime power, n = pe ,  where e  2. Let g be a primitive root for n 
so that ordp• (g) = (p - l)pe-1 . If n is a g°-pseudoprime, then ga<p
' -1> = 
1 (mod pe ), which means that (p - l)pe-1 divides a (pe - 1); this implies that 
pe-l divides a. In fact, pe is a pseudoprime for the base g° if and only if pe-l 
divides a. This implies that here are exactly p - 1 bases for which pe is a 
pseudoprime. But 
p - 1  
p - 1  
s 
pe 
pe 
_ 1 
p
- 1 
s 
= 
1 
p + l 
1 
4 

4.3. REFINEM ENTS AND OTH ER DI RECTIONS 
1 33 
Let p1, P2 , . . .  , Pr be the primes that divide n, n = pǁ' ... pǂ' . We can now 
assume that r is at least 2. Let n - 1 = 28 t where t is odd. We define k to be 
the largest integer such that b2• = -1 for some b. To show that k is well 
defined, we first observe that (-1)20 = - 1, so there exists an integer that 
satisfies this congruence. We next note that if b and k satisfy this congru­
ence they must also satisfy b2• = -1 Љ 1  (mod p;) and b2•·1 = 1 (mod p;) for 
1 ::; i ::;  r and therefore ordp, (b) = 2k+l . This implies that 2k+l divides Pi - 1 
or, equivalently, Pi = 1 (mod 2k+l ). Because this is true for all primes divid­
ing n, we see that n = 1 (mod 2k+ 1 ), which means that 2k+ 1 divides n - 1. 
This implies that k must be strictly less than s. 
Let k and b be as in the preceding paragraph and let m = 2k t. Note that 
bm = (- 1}' = - 1. We define the set L = {a: am = ± 1, 1 ::; a <  n). We shall show 
that all strong liars are in L and that L has at most (n - 1)/4 elements. If a 
is a strong liar, then either a1 = ± 1 or a2j1 = -1 for some j with 1 ::;  j ::;  k. If 
a211 = ± 1, then a21•11 = 1, so a must be in L. We note also that if a E L, then 
so is ab because (abr = -am. 
For each a E L, we consider the set 
S(a) = {x :  1 s x < n and for each i with 1 s i s  r, x = a  or ab(modp1' >} .  
There are 2' elements in S(a), exactly two of which - a and ab - are also 
in L (Exercise 4.34). Each integer appears in at most two of these sets 
(Exercise 4.35), and thus we have found at least I L I (2' - 2) / 2 integers that 
are not strong liars. If r ;;:: 3, this proves that there are at least three inte­
gers that are not strong liars for every integer that is. If r = 2, we have 
shown that there is at least one element in the union of the S(a) that is not 
a strong liar for every element that is. 
We next observe that if x is in the union of the S(a), then x is at least a 
liar in the sense that n is an x-pseudoprime (Exercise 4.35). We claim that 
if a is not a Carmichael number, then the liars make up at most half the 
positive integers less than a. If x is a liar and y is relatively prime to a and 
not a liar, then xy is not a liar. If x1 and X2 are distinct liars, then X1Y and 
X2Y are distinct nonliars. 
All that is left is to show that if r = 2, then n cannot be a Carmichael 
number. But this was done in Proposition 3.8. 
D 
This theorem yields a method for getting probabilistic proofs of primal­
ity, implemented in the CNT package as MillerRabinPrimeQ and dis­
cussed earlier on page 1 17. 
߆ Finding the nth Prime 
It seems very impressive that we can get, say, the billionth prime exactly in 
only a few seconds. 

1 34 
4. PRI ME N UMBERS 
Prime [ l09 ] 
2 2 8 0 1 7 6 3 4 8 9  
Of course, there is some cleverness underlying the algorithm for this; it is 
done without computing millions of primes and counting them. Recall the 
prime-counting function 1f(x). A good algorithm for 1f(X) quickly leads to a 
good algorithm for getting Pn . the nth prime: one can just use a root-finding 
technique to invert rr. The code that follows uses the built-in FindRoot, but 
it would be quite simple to program an interval-halving method that would 
work almost as fast. As with all root-finding problems, we need some start­
ing values that are close to the final answer. It is known that Pn is asymptot· 
ically equal to nlog n, so we could use multiples of that. But we may as well 
use the current best-known bounds, which are due to Rosser (1938) and 
Robin (1983); see [Rib, p. 249; BS, p. 299]. 
n ( log n + log log n - 1.0072629) s Pn < n (log n + log log n + 8), when n 2! 2 . 
We can use this trapping interval to start the root-finding program. We find 
x such that 1f(X) ::: n and use a simple function to perform the fine correc­
tions to get the exact prime we want. 
CorrectPrime [ x_, n_] : =  ( a = Round [ x ] ; s = PrimePi [ a ] ; While [ 
! PrimeQ [ a ]  1 1 PrimePi [ a] Ⱥ n ,  a - = (Sign [ s  - n ]  / .  0 -+  1 ) ] ;  a )  
prime [ l ]  = 2 ;  
prime [n_] : = Module [ { x } , 
CorrectPrime [ x / .  FindRoot [ PrimePi [ x ]  = =  n ,  
{ x ,  {n (Log [ n ]  + Log [ Log [n] ] - 1 .  007 2629 ) ,  
n (Log [n] + Log [Log [n] ] + 8 ) } } ] , n ] ]  
{prime [ l234567 ] , Prime [ l2 3 4567 ] } 
{ 1 93944 89 , 1 9 394489 } 
So the key is coming up with a fast way to compute 1f(x). Legendre, in 
1808, found an excellent way to do this. He used what is now known as a 
Legendre sum. Define <f>(n, a) to be the number of positive integers m that 
are less than or equal to n and are not divisible by any of the first a primes 
p1 , P2 , . . .  , Pa · One can give an explicit, but unwieldy formula for <f> as 
follows, where the signs alternate because we first subtract the number of 
multiples of p 1 , p2 , and so on, and then we add back the number that are 
subtracted doubly, then recorrect by subtracting the number that were 
added triply, and so on. 
<f>(n, a) = LnJ -i: l Ǧ J + i: l¤J- L l 
. ǥ J + .. · 
·_1 
p, 
· · - i  P1 P1 
.
.
 k - i 
P1 P1 Pk 
1-
I,] -
I , ] ,  
-

4.3. REFINEM ENTS AND OTHER DIRECTIONS 
1 35 
But the following succinct recursive rule is much more useful. If m s n and 
m is not divisible by any of the first a - 1 primes, then either m is not 
divisible by Pa and so appears in the count in r/J(n, a), or it is, in which case 
m /  Pa gets counted the right number of times in r/J(Ln/ PaJ, a - 1). 
r/J(n, a - 1) = r/J(n, a) + rp(l _!:_ J. a - 1) 
Pa 
Isolating rfJ(n, a) in the preceding formula leads to a recursive definition. We 
cache the values (this is done by the phrase Legendrect> [ n ,  a ]  
= 
Legendrect> [ n ,  a - 1 ]  -
· · ·, which stores the values as soon as they are 
computed; this is a standard technique and is often essential in recursions 
to avoid a tremendous slowdown due to repeated computation of the same 
value). · Note that for this to work we need the ath prime. We avoid 
Prime ( a ) ,  because the whole point here is to see how PrimePi and Prime 
can be computed from scratch. So we first use a sieve to generate the 
primes below 10,000 This will allow our implementation of 1r(X) to work for 
x under 10,0002, or 100 million (though our implementation will be too slow 
for numbers much beyond ten million). 
primes = Eratosthenes [ 10000 ] ; 
Length [primes ] 
1 2 2 9  
Now we implement the recursion, with a reset of a system default so that 
we can do large recursions. 
$RecursionLimit = 5000 ; 
Legendrel#) [ n_Integer , O] : = n 
Legendrel#) [ n_Integer , a_Integer] : =  (Legendrel#) [ n ,  a] = 
Legendrel#) [ n ,  a - l ]  - Legendre4>[Floor [ 
. 
n 
] , a - 1]) 
primes [a] 
Here is an example followed by a check that uses a one-by-one count. 
The general behavior of the Legendre function for fixed a is shown in 
Figure 4.4. 
{ Legendrel#) [ SOO , 3 0 ] , Length [ 
Select [ Range [ SOO] , Intersection [First /@ Factorinteger [ # ] , 
Take [primes , 30] ] == { }  & ]  ] } 
{ 6 6 ,  66 } 
We can speed up the code by eliminating part of the recursion. Note how 
the first part of the recursion will decrement a until it gets down to 1. Thus 
we can replace it by a simple sum. A special case is added for n < Pa+i , as 
that is simply 1. We use an Apply ( Plus , ... ) construction as that is fastest; 

1 36 
4. PRI M E  NUMBERS 
3 0
L
ct> [ n . _1 J 
2 5  
------
J 
2 0  
/ 
I 
1 5  
-----
: 
l o  
____ ---
I 
5 
--
• 
-
. 
0 · 2 0  4 0  6 0  8 0  1 0 0  
3 0
1 
2 5  
2 0  
1 5  
1 01 
5' 
ct> [ n , 4 ] 
I 
i 
-
---1 
0 
2 0  4 0  6 0  8 0  1 0 0  
ct> [ n , 2 ] 
3 01r
. 
̅̆̇̈-
2 5f 
2 01 
1 5  
1 01 
5' 
0:-'-<
2
 
0=4>0-6?0@0A0B1'"-='o o 
ct> [ n , 5 ] 
3 0.--ȉȊȋ 
2 5
1 
2 0  
1 51 
lÌ\,.o_-C--,-,,.-,.-DE...,.J 
2 0  4 0  6 0  8 0  1 0 0  
̑v
ct> [ n , 3 ] 
_
_ ---
, 
2 0  
---
I 
1 5  
_
__ 
--
I 
1 Ì 
-----------
I 
0 
-
2 0  4 0  6 0  8 0  1 0 0  
3 0
D
ct> [ n , 6 ] 
2 5  
2 0  
----
1 5  
---
1 0  
-----
5 
-
------
0 
2 0  4 0  6 0  8 0  1 0 0  
Figure 4.4. The Legendre sums up to 100 with a =  1, 2, 3 ,  4 ,  5, and 6. 
that requires making Legendre<!> listable so it will properly run through 
the list returned by Quotient [ ] . This variation gives a worthwhile 
speedup to the function. 
Clear [Legendre•J ; 
Attributes [ Legendre•] = Listable ; 
Legendre9 [ n_Integer , O J : =  n 
Legendre9 [ n_Integer , a_] : =  1 / ;  n < primes [a +  l] 
Legendre9 [ n_Integer , a_ Integer] : = 
(Legendre9 [ n ,  a] = n - Apply [ Plus , 
Legendre9 [Quotient [ n ,  Take [primes , a] ] ,  Range [ O ,  a - l ] ] ] ) 
We add the following code so we can clear out the cached values for timing 
tests. 
initialize : = ( 
Clear [Legendre9] ; 
Attributes [Legendre9] = Listable ; 
Legendre9 [ n_Integer , O J : =  n ;  
Legendre9 [ n_Integer , a_] : =  1 I ;  n < primes [a + l] ; 
Legendre9 [ n_Integer , a_Integer] : =  
(Legendre9 [n, a] = n - Apply [ Plus , Legendre9 [ 
Quotient [ n ,  Take [primes , a ] ] , Range [ O ,  a - 1 ] ] ] ) )  
Now Legendre's idea on how to use </> to compute 1r(X) is very simple. The 
following recursive rule will do the job: 
1f(n) + 1 = 11"( ..Jn) +  <f>[n, 11"( ..Jn) ] . 
To prove this observe that if p is a prime and p :s; n, then either p :s; {Ti, or 
p > ..Jn; in the latter case p gets counted in the ¢>-term and because the ¢>­
count includes the nonprime integer l, we must add 1 to the left side. This 
shows that the left side is less than or equal to the right. For the opposite 
direction, suppose that m is an integer occurring in the count on the right 

4.3. REFI N EM ENTS AND OTH ER DI RECTIONS 
1 37 
side. Then one of the following hold: m = 1; or m is prime and m ::; Yn ;  or 
Vn < m s n and m is not divisible by any prime p ::; Yn. But this last case 
means that m is prime, and so appears in the 1f-count on the left side. 
Isolating 1f(n) in this formula leads to a simple recursive implementation. 
Because the second argument to <fJ is at most 7r( Yn) and because 
1r(Y 10,0002 ) is the number of primes in the sieve-list that we computed to 
10,000, we see that our sieve will be adequate for n < 108. Here is the 
implementation; the amount of total code is nicely compact. 
LegendrePi [ x_] : = 0 / 1 x < 2 
LegendrePi [ x_] : = Module [ { a =  LegendrePi [a [ ...f;J ] } ,  
a +  Legendrect> [ Floor [x] , a ]  - 1] 
{LegendrePi [ lOOOO] , PrimePi [ lOOOO] } 
{ 1 2 2 9 ' 1 2 2 9 } 
{LegendrePi [ 1234567 ] , PrimePi [ l234567 ] } 
{ 9 5 3 6 0 ,  9 5 3 6 0 } 
Here is a chart, created by a CNT package function, that shows the 
recursion in action. The answer, 1f(l,000,000}, is the last entry of the last 
column. Because iterating the square root function quickly gets us down to 
1 - the repeated square roots are shown in the first column - the number 
of recursive steps is quite small. 
LegendrepiFull [ l06 ] 
Square roots, m lrmJ ir(l rm J) ςm. ir(l rm j)) ir(m) = ir(l rm Ji + cb( m ,  1r(l rm Jl) - 1 
1 
1 
0 
1 
0 
2 
1 
0 
2 
1 
5 
2 
1 
3 
3 
31 
5 
3 
9 
1 1  
1000 
31 
11 
1 58 
168 
1,000,000 
1000 
168 
78,331 
78,498 
Note that it is essential to make a a local variable, otherwise confusion 
would ensue in the recursion. One can easily program this part without 
recursion (Exercise 4.44), but it is not so easy to eliminate recursion for the 
definition of </J. 
This routine is slow, with the main bottleneck being in the <fJ computa­
tions. Some important improvements due to Meissel and Lehmer can lead 
to a significant speedup. But the most modern approach to the problem -
the one that led to the current world record of 1r(l020) by Deleglise and 
Rivat [DR] - is due to Lagarias, Miller, and Odlyzko in 1985 (see [BS, 
Chap. 9]. Indeed, the data of these researchers for powers of 10 has been 
hard-wired into the CNT package. 

1 38 
4. PRI M E  NUMBERS 
l! [ lORanp [20] ] 
{ 4 ,  2 5 , 1 6 8 , 1229 , 9592 , 7 8 4 9 8 , 6 6 4 5 7 9 , 5 7 6 1 4 5 5 , 
5 0 8 4 7 5 3 4 , 4550525 1 1 ,  4 1 180548 1 3 , 3 7 6 0 7 9 1 2 0 1 8 , 
3 4 6 0 6 5 5 3 6 8 3 9 ,  3204941750802 , 2 9 8 4 4 5 7 0 4 2 2 6 6 9 , 
2 7 9 2 3 8 3 4 1 0 3 3 92 5 , 2 6 2 3 5 5 7 1 5 7 6 5 4 2 3 3 ,  2 4 7 3 9 9 5 4 2 8 7 7 4 08 6 0 ,  
2 3 4 0 5 7 6 6 7 2 7 6344607 , 22208 1 9 6 0 2 5 6 0 9 1 8 8 4 0 } 
An important improvement to Legendre's ideas came from the astrono­
mer E. D. F. Meissel in 1871. In 1885, he used his method to compute 
1r(l09) = 50,847,478. He made some arithmetical errors, as his value is low 
by 56. 
l!'. [ 109 ] 
5 0 8 4 7 5 3 4  
Meissel's formula requires Pk(n, a), the number of positive integers less 
than or equal to n that are a product of k prime factors, each of which is 
greater than Pa· The sum of Pk(n, a) for k = 1, 2, 3, . . .  gives a count of all 
the positive integers less than or equal to n whose smallest prime factor is 
at least Pa+l ·  This leads to the following formula for 1f(n): 
1T(n) = <f>(n, a) + a - 1 - P2(n, a) - P3(n, a) - ··· . 
The required number of terms Pk(n, a) depends on a. If a is such that 
Pa+l > ../n, then P2 (n, a) equals 0 and we have the original formula of 
Legendre. If a is chosen so that n l/3 < Pa+l s n 112 , then P2(n, a) is not 0, but 
P3(n, a) and subsequent terms do vanish, because Pi Pi Pk > n113 n113 n113 = n 
for all i, j, k beyond a. 
Thus all that remains is to find a compact formula for P2 (n, a). Recall 
that P2(n, a) is the number of integers in the interval [l, n] that are of the 
form Pi Pi with a + 1 s i s  j. Considering one prime at a time we have 
P2(n, a) = the number of integers Pa+l Pi s  n with j V a + 1 
+ the number of integers Pa+2 pi s n with j V a + 2 + · · · 
+ the number of integers Pb Pi s n with j V b 
where b = 1r('v'n) . Using subtraction to account for the inequalities on j gets 
the following formula. 
P2(n, a) = 1T(-n-) - a +  1T(-n-) - (a + 1) + 1T( -n-) - (a + 2) + ··· = 
Pa+l 
Pa+2 
Pa+3 
_ (b - a)(£+ a - 1) + ± 1f(Ǥ) 
i=a+l 
p, 
Here is some code that implements the Meissel formula. For large 
values it is much faster than Legendre's formula. But if n s 104 we use 

4.3. REFINEM ENTS AND OTH ER DI RECTIONS 
1 39 
Legendre's formula, because that is faster for small values of n. And we use 
some caching, so reinitialization of Meis selPi would be necessary for 
repeated timing comparisons. 
Clear [MeisselPi ] ;  
Attributes [MeisselPi ] = Listable ; 
MeisselPi [ x_] : = 0 I ;  x < 2 ;  
MeisselPi [ n_Integer] : = Module [ { a = LegendrePi [-v'il"[n]] } ,  
a +  Legendrel/I [ n ,  a ]  - 1] I ;  n ݛ 10' 
MeisselPi [ n_Integer ] : = MeisselPi [n] = 
Module [ { a =  MeiBBelPi [H [ n ]  113 ] , b = MeiBBelPi [-Yi[i]] } , 
Legendrel/l [ n ,  a ] + (b + a - 2 ) (b - a + l ) / 2 - Apply [ Plus , 
MeisselPi [ Quotient [ n ,  Take [primes , { a + 1 ,  b} ] ] ] ] ] 
MeisselPi [ x_] : = MeisselPi [ Floor [ x ] ] I ;  ! IntegerQ [ x ]  
initialize ; MeisselPi [ 106 ] I I  Timing 
{ 2 .  7 1 6 6 7  Second , 7 8 4 9 8 } 
initialize ; LegendrePi [ 106 ] / / Timing 
{ 7 . 2 1 6 6 7  Second , 7 8 4 9 8 } 
The Meissel improvement is substantial. D. H. Lehmer, and later investiga­
tors, pushed Meissel's idea farther to get ever more speed; see Exercise 4.46. 
Exercises for Section 4.3 
4.34. Referring to the proof of Theorem 4.7, prove that a and ab are the 
only elements of S(n) that are also in L. 
4.35. 
Referring to the proof of Theorem 4.7, prove that each integer 
appears in at most two of the sets S(a), a E L, and that each a E L  appears 
in exactly two of these sets. 
4.36. Referring to the proof of Theorem 4.7, prove that if x E S(a) for some 
a E L, then xn-1 = 1 (mod n). 
4.37. Let p be an odd prime, p - 1 = 25 t where t is odd. Let a be a positive 
odd integer that is not divisible by p. Prove that the number of incongruent 
solutions of xa = 1 (mod pe) is gcd(a, t). Hint: Every residue class that 
satisfies this congruence must have an order that divides a and thus the 
order must divide gcd(a, ¢[pe ]). Prove that gcd(a, ¢[pe]) = gcd(a, t). If d 
divides gcd(a, t), then there are ¢(d) elements of order d. Use Theorem 
3.l(h). 
4.38. 
Let n be an odd integer with factorization p1' p;2 • • • p2' where 
p; - 1 = 2•· t; . Use Exercise 4.37 to prove that if a is a positive odd integer 

1 40 
4. PRIME NUMBERS 
relatively prime to n, then the number of incongruent solutions of 
:xfl = 1 (mod n) is equal to nr=l gcd(a, ti). 
4.39. Let p be an odd prime, p - 1 = 28 t where t is odd. Let a be a positive 
odd integer that is not divisible by p. Prove that the number of incongruent 
solutions of r,; a = - 1  (mod pe ) is 2j gcd(a, t) if j < s and 0 otherwise. Hint: A 
residue class satisfies this congruence if and only if its order divides 2j+l a 
but not 2j a. There is no element of this order if j  s. If j < s, then the order 
must be of the form 2j+l d where d is a divisor of gcd(a, tf>(pe]). The number 
of elements of order 2j+l d is tf>(2j+l d), which equals 2j tf>(d). 
4.40. 
Let n be an odd integer with factorization p>' p?2 • • • p@' where 
Pi - 1 = 28' ti. Use Exercises 4.37-39 to prove that if a is a positive odd 
integer relatively prime to n, then the number of incongruent solutions of 
:xfl2i = - 1  (mod n) is equal to 2jrni=1 gcd(a, t; ) if j < Si for all i and 0 
otherwise. 
4.41. Combine the results of Exercises 4.37-4.40 to prove that for odd 
n = pA1 p?2 • • • p@' where Pi - 1 = 28' t;, the number of strong liars is equal to 
[ r 
]( s-1 l [ r 
l 
2rs 
1 
[1 gcd[a, td 
1 + ¢ 2jr = [1 gcd[a, t; ]  (1 + 2r ǣ 1 ) 
where a is the largest odd integer that divides n - 1 and s is the minimum 
of {s1 , • • •  , Sr }. 
4.42. What is the probability that n = 49939 · 99877 is a strong pseudoprime 
to the base b if b is chosen at random from {1, 2, . . .  , n - 1}? 
4.43. Suppose q, 2 q + l, and 4 q + l  are all prime, and n = (2 q + 1)(4q + l). 
Prove that the number of strong liars for n is 2 q2 • This means that if we 
could find arbitrarily large primes q for which 2 q  + 1 and 4 q  + 1 are prime 
(this is an open question), then the proportion of strong liars can be made 
arbitrarily close to 1/4 • 
4.44. Implement the LegendrePi function in a way that avoids recursion. 
4.45. Let Pm = n::,1 Pi · The following formulas, which make use of the 
standard Euler </>-function, can be useful in sophisticated computations of 
Legendre sums. Prove them. 
(a) (Symmetry) If Pa I 2 < n < Pa , tf>(n, a) = tf>(Pa )  - tf><Pa - n - 1, a) 
(b) (Reduction) If Pa s n, tf>(n, a) = LP a / nJ tf>(Pa ) + tf>(Mod[n, Pa ], a) 
4.46. Derive and implement Lehmer's improvement to Meissel's formula 
for 11'(X). Here is an outline. 
(a) Show that if a =  11'(n114), then 11'(n) = tf>(n, a) + a - 1 - P2 ( n, a) - P3 (n, a). 
(b) Show that 

4.4. A DOZEN PRI M E  MYSTERIES 
1 41 
P3(n, a) = the number of integers Pa+l Pj Pk s n with a + 1 s j s k 
+ the number of integers Pa+2 Pi Pk s n with a + 2 s j s k + · · ·  
+ the number of integers Pc Pj Pk s n with cs j s k 
where c = Ln113 J. 
(c) Show that 
(d) Use the formula for P2 (n, a) to get the following, where b; = tr{../ n/ p; ): 
(e) Replace the -(j - 1) terms by finding a closed form using the standard 
formula for the sum of a sequence of consecutive integers. 
(f) Put this all together, using Meissel's formula for P2(n, a), to get the 
following, where a =  Ln114 J, b = l v'nJ, and c = Ln113 J .  
(b + a - 2)(b + a - 1) 
tr(n) = <fJ(n, a) + 
2 
-
4.47. Extend Legendre's method to obtain a program that computes 11'1 (n), 
the number of primes less than or equal to n that are congruent to 
1 (mod 4). This can be done by proving the formulas in (a)-(c) and then 
implementing them recursively in a way similar to the implementation of 
Legendre¢. For a more sophisticated approach, see [HB]. 
Define <fJ1 and <fJ3 as follows: r/>;(n, a) is defined to be the number of 
positive integers between 1 and n, inclusive, such that m is relatively prime 
to the first a primes and m = i (mod 4). 
(a) Prove that </J1 (n, a) = </J1 (n, a - 1) - </J1 (Ln I PaJ. a - 1). 
(b) Prove that <fJ3(n, a) = <fJ3(n, a - 1) - <fJ3(Ln/ PaJ , a - 1). 

1 42 
4. PRI M E  N U M BERS 
(c) Prove that <f>3(n, a) = <f>(n, a) - </>1 (n, a). For implementation, one can use 
the preceding formula together with the implementation of Legendre¢ 
given in the text. 
(d) Establish what the necessary base cases for the recursive definition of 
</>1 are. 
(e) Write a program to compute </>1 (n, a). 
(f) Prove that 1Ti (n) = 1Ti (Vn) + <f>i [n, 1T(Vn)] - l, and then implement this 
formula to get a program that computes 1T1 (n). 
4.4 A Dozen Prime Mysteries 
There are many unsolved problems about prime numbers. Several have the 
form: Are there infinitely many primes of a certain form? Here are a dozen 
prominent open questions about primes. See [Guy] and [Rib] for results 
related to these, as well as many more questions about primes. 
1. Is there a good formula for the primes? Note that formulas do exist. A 
fascinating formula in terms of a polynomial was discovered in 1970 
(see [JSWW]). And, assuming the extended Riemann Hypothesis, one 
can say that n is prime if and only if n passes the b-strong pseudo­
prime test for any b < 2(log n)2; this is easy to compute and so is, in 
an important sense, a "good" formula. But one wonders if there is a 
simple combination of a fixed number of pseudoprime tests that 
characterizes primality. The three tests used by PrimeQ work up to 
1016 and no counterexample is known. Thus a specific case of the 
question here is: Is it true that n is prime if and only if n passes the 
2- and 3-strong pseudoprime test and a certain Lucas test (discussed 
in Section 9.2). Experts feel that it is unlikely, but one cannot help 
but be intrigued by the possibility that a handful of pseudoprime 
tests might characterize primality. Other possible characterizations 
are mentioned in Section 9.2. 
2. (Goldbach's Conjecture) Is every even number beyond four a sum 
of two primes? 
3. Are there infinitely many Mersenne primes? 
4. Are there infinitely many twin primes? (A twin prime is one of a 
pair of primes whose difference is 2, such as 41 and 43.) 
5. Are there infinitely many primes of the form n 2 + 1? 
6. Are there infinitely many prime Fibonacci numbers? 
7. Are there infinitely many primes of the form n ! + 1? 
8. Are there infinitely many Sophie Germain primes (meaning: a 
prime p such that 2p + 1 is prime too; these primes played an impor­
tant role in 19th-century work on Fermat's Last Theorem). 

4.4. A DOZEN PRI M E  MYSTERI ES 
1 43 
9. Are there arbitrarily long strings of primes in arithmetic progres­
sion? For example, 142,072,321,123 + l,419,763,024,680i 
(i = 0, 1, .. ., 20) is a string of 21 such primes. 
10. (Giuga's Conjecture) Is it true that 
p-1 + 2P-1 + . . .  + (p - l)p-J = -1 (mod p) if and only if p is prime? 
(one direction is an easy consequence of Fermat's Little Theorem. It 
is known that a composite n satisfying the equation must have at 
least 12,000 digits). 
1 1. (Bertrand's Postulate Extension) Is there always a prime 
between n2 and (n + 1)2? 
12. (Gilbreath's Conjecture) Does the sequence of iterated prime 
gaps always yield ls in the first column? 
Gilbreath's conjecture requires some explanation. Start with a long list 
of primes. Form the differences of adjacent primes, writing them below the 
smaller of the two primes. Form the differences of these differences. Con­
tinue. It seems as if the infinite column of numbers in the leftmost column 
are all ls. But this has not been proved. 
IteratedPrimeGaps [ 2 0 ,  2 0 ]  
Prim PS 
2 
a 
5 
7 
I I  1 3  17 
Differences 1 
1 
2 
2 
4 
2 
4 
2 
Differemݚs 2 
1 
0 
2 
2 
2 
2 
2 
Differencms 3 
1 
2 
0 
0 
0 
() 
0 
Differences 4 
1 
2 
() 
0 
0 
(I 
2 
Di.ferenccs 5 
1 
2 
0 
0 
0 2 
0 
Differences 6 
I 
2 
0 
0 
2 
2 
0 
Di1Tercnces 7 
I 
2 
0 
2 
0 
2 
0 
Differences 8 
I 
2 
2 
2 
2 
2 
2 
Differences 9 
1 
0 
I) 
0 
0 
0 
0 
Differenr.es 10 
I 
0 
0 
0 
0 
0 
2 
Differenct>s 1 1  
1 
0 
0 
0 
0 
2 
0 
Differences 12 
1 
0 
0 
0 
2 
2 
2 
Difft>rt.•nces 13 
1 
0 
0 
2 
0 
0 
2 
Differences 1 4  
1 
0 
2 
2 
I) 
2 
2 
DifferenC"RS 15 
1 
2 
0 
2 
2 
0 
2 
Differences 1 6  
1 
2 
2 
0 
2 
2 
2 
Differences 1 7  
I 
0 
2 
2 
0 
0 
0 
Differences 1 8  
1 
2 
0 
2 
0 
0 
0 
Differences 1 9  
1 
2 
2 
2 
0 
0 
2 
Differences 20 
I 
0 
0 
2 
0 
2 
2 
Exercise for Section 4.4 
1 9  
23 
29 
4 
6 
2 
2 
4 
4 
2 
u 
2 
2 
2 
2 
0 I 0 
2 
0 
2 
2 
2 
0 
0 
2 
0 
0 
2 
0 
0 
2 
0 
2 
2 
2 
2 
() 
0 
0 
0 
u 
0 
0 
0 
2 
0 
2 
0 
2 
2 
0 
0 
2 
0 
2 
2 
2 
0 
0 
2 
0 
2 
2 
31 
37 
41 
43 
47 
:;;ݙ 
6 
4 
2 I 
4 
6 
6 
2 
2 
2 
2 
0 
4 
0 
0 
0 
2 
4 
u 
0 
u 
2 
2 
4 
2 
0 
2 
0 
2 
2 
0 
2 
.. 
2 
0 
2 1 0  
0 
0 
2 
2 
,, 
2 
0 
2 
0 ! 0 
0 
l) 
2 
2 
() 
0 
0 
2 
0 
2 
0 
0 
2 
0 
2 
2 
0 
2 
2 
2 
0 
2 
2 
0 
I) l o  
2 
0 
2 
0 
0 
2 
2 
2 
2 
0 
2 
" 
0 
0 
2 
2 
u 
0 
0 
2 
0 
2 
0 
2 
2 
2 
2 
2 
2 
0 
0 
0 
0 
0 
2 
0 
0 
0 
() 
2 
2 
0 
0 
0 
2 
() 
2 j 2 
;;9 
2 
4 
2 
I 
2 
i 0 
I 2 
2 
2 
2 
I 2 
2 
2 
0 
2 
2 
2 
0 
0 
2 
2 
61 ! 67 
7 1  
6 
2 
0 
2 
2 
0 
0 
() 
0 
0 
I) 
2 
2 
tl 
() 
-
0 
2 
0 
2 
i 
j 
··-
4 
0 
2 
4 
2 
,, 
u 
2 
2 I 2 
i 
() 
0 
0 
0 
() 
0 
0 
0 
0 
2 
" 
" 
0 
2 
2 
2 
() 
2 
7 
0 
2 
tl 2 1  
0 
2 
0 
2 1 0 
I 2 
o 
4.48. Use a computer to explore some of the mysteries in this section. 


CHAPTER 5 
Some Applications 
5.0 Introduction 
Number theory started out 3000 years ago as an abstract field of study for 
Egyptians, Babylonians, and Greeks, but today its applications span an 
incredibly diverse collection of areas of engineering, science, and communica­
tion. Indeed, this is a truly modern development. It is fair to say that until 
the middle of the twentieth century number theory was still being pursued 
for its own sake. But many aspects of modern computing, and the develop­
ment of a secure scheme for coding secret messages based on prime num­
bers, have guaranteed that the subject will henceforth be known for its 
beauty and its utility. 
Two good sources for a general overview of the applications of number 
theory are [Sehr] and [Ros]. In this chapter we discuss two important uses 
of integers in the real world: public-key cryptography to send secret mes­
sage and the use of check digits to catch and sometimes correct errors when 
messages are transmitted. And we also begin a discussion of how to factor 
large integers. The methods presented here will only work on integers of 
modest size, but they show the sorts of ideas that can be brought to bear; 
and current state-of-the-art factoring routines can handle numbers of about 
150 digits. 
5.1 Coding Secrets 
The world of secret codes was turned on its head in the mid-1970s when it 
was discovered that, by a clever use of large prime numbers, one could send 
messages using an encryption method that was completely public, but yet 
entirely secure in that only the intended recipient could decrypt the mes­
sage. Such a scheme means that senders of sensitive data, from credit card 
numbers to computer passwords to stolen state secrets, need not worry 
about keeping their means of communication confidential: All correspon­
dence can be fully open, and the method of coding can be open as well; 
decryption, though, will be impossible except by the intended recipient. 

1 46 
5. SOM E APPLICATIONS 
Of course, this development is only the latest in a long line of important 
mathematical contributions to code-breaking. Mathematicians and cryptog­
raphers played critical roles in almost all wars from the time of Caesar on 
to the present day. See [Hod], [Kah], and [Tue] to learn more about code­
breaking in World Wars I and II. 
At first glance, the claim seems impossible. Recall a simple cipher 
allegedly used by Julius Caesar. Each letter is shifted three units to the 
right, so "SEND HELP" becomes ''VHQG KHOS". Obviously if someone 
intercepts the encrypted message and knows the method of encryption, it is 
a trivial matter to decrypt: Just invert the coding procedure and shift down 
three letters. Public-key cryptography, however, is a way of encoding for 
which knowledge of the encryption procedure does not help with decryption. 
 Tossing a Coin into a Well 
To see why prime numbers are relevant to keeping secrets, consider a 
slightly different problem. Alice and Bob wish to flip a coin over the tele­
phone or via e-mail. Alice will flip, Bob will call HEADS or TAILS, and Alice 
will tell Bob whether he is right in a way that prevents cheating. There is 
an obvious flaw to the suggestion that Alice just use a real coin: the tempta­
tion to cheat might be too strong to resist. Here is how prime numbers can 
be used to eliminate any possibility of cheating by either party. Alice picks 
two large primes p and q (100 digits each, say) with p = 1 (mod 4) and q = 
3 (mod 4) and tells Bob their product, n. Bob then commits himself to HEADS 
or TAILS and tells Alice his choice. Then Bob guesses whether the larger of p 
and q is congruent to 1 (mod 4). If he is right the toss is considered HEADS; if 
he is wrong it is taken to be TAILS. Alice then reveals the primes and they 
can quickly see whether Bob's choice regarding the modulo 4 condition was 
right or wrong. This in turn translates into HEADS or TAILS, and they can see 
whether Bob's choice of one of these was correct. 
Here is how Alice might proceed. RandomPrime uses the three 
pseudoprime tests of Pr imeQ to vouch for primality; more stringent tests 
can be used if more certainty is required. RandomPrime allows the user to 
specify a congruence class, so here Alice specifies that the larger of the two 
primes should be congruent to 1 (modulo 4). 
p = RandODIPrime [40, { l ,  4 } ] ; 
q = RandODIPrime [39 , { 3 ,  4 } ] ; 
D = p * q 
4 03 9 4 6 5 6 6 9 4 7 8 5789206702 8923703 9 6 5 4 3 3 0 2 3 9 6 4 9 0 0 4 2 5 8 9 6 8 8 3 86 1 7 1 3 \  
9 9 1 6 9 7 1 3 7 6 800347947 
Presented with this large number, Bob has no idea what its prime factors 
are, and current factoring algorithms would not be able to factor this in the 
few seconds before Bob must commit to a decision. Of course, larger primes 
can be used for more security. 

5 . 1 . CODI NG SECRETS 
1 47 
Note that, after committing to his choice and receiving p and q from 
Alice, Bob can easily multiply the primes together to make sure there was 
no funny business: he checks that pq agrees with the n he received earlier. 
He should also run the Miller-Rabin probabilistic test a few dozen times on 
p and q to make sure they are prime; otherwise Alice might choose four 
primes a, b, c, and d and decide, after Bob commits to his choice, to tell Bob 
that p is ab (or perhaps a c  or ad), which would allow her to rig the results. 
The protocol is effective because Bob cannot factor n in reasonable time, 
and so he has no information about p and q. This sort of electronic coin flip 
is called "coin flipping into a well" because it is as if Alice flips a coin into a 
well, Bob calls it, and then they both walk over to see how it came up. In 
the protocol given here Alice learns the answer first, but this is of no conse­
quence. Note that because the coin flip is tied to the correctness of Bob's 
mod-4 choice, as opposed to directly relating it to the mod-4 class of the 
larger prime, Alice cannot rig in advance that, say, HEADS come up. She does 
not know what Bob's choice will be until she is committed to p and q. 
Exercise 5.1 addresses the situation where Alice wishes to pass a random 
bit to Bob in such a way that she does not know what it is, and Bob and she 
are both convinced that it is random. An application of this is to the situa­
tion where Alice and Bob wish to play poker by e-mail. Alice can deal a 
random card to Bob by passing enough bits to determine five numbers in 
[l, 52). Bob can then do the same for Alice and they can see who has the 
better hand. If the same card occurs in both hands, they start over. See 
[Schn] and the references therein for more details of this sort of electronic 
communication. 
A natural question is: How should Alice choose her primes? The sim­
plest strategy is to generate random integers and use several strong 
pseudoprime tests to verify primality. If sufficiently many spsp tests are 
used the probability that p is not really prime can be made so small as to be 
negligible. But recall that Algorithm 4.6 (see also Exercise 4.33) contained a 
much simpler algorithm for generating large primes that are certifiably 
prime. 
ρ The RSA Cryptosystem 
The fact that two primes can be easily multiplied but a product of two 
primes cannot be easily factored is the basis of the RSA public-key scheme. 
It is a little more complicated than the coin-flipping idea just described 
because it requires Euler's theorem. Suppose Alice wishes to send the 
message "Sell shares now. Alice." to Bob. First she must convert the mes­
sage to a single integer (or perhaps a sequence of integers in case the 
message is very long). This can be done in a number of ways. The CNT 
package function StringTointeger uses standard ASCII coding. The 
ASCII code for "S" is 83, but 31 is subtracted so that all characters will 
yield 2-digit numbers. Thus, "S" yields "52". 
'l!oCbaracterCode [ " S " ] 
{ 83 } 

148 
5. SOME APPLICATIONS 
m = StrinaTointeger [ " Sell shares now . Alice . " ]  
5 2 7 07 7 7 7 0 1 8 4 7 3 6 6 8 3 7 0 8 4 0 1 7 9 8 0 8 8 1 5 0 1 3 4 7 7 7 4 6 8 7 0 1 5  
Now, some time ago Bob has chosen two large primes, p and q, and he has 
published their product, n. He must also choose an encryption exponent, 
called e, and that gets published too; e must be relatively prime to 
(p - l)(q - 1), which is easy for Bob to arrange. The pair (n, e), called the 
public key, is all anyone needs to send a secret message to Bob. Alice 
would simply take m, her message in integer form, and compute 
me (mod n), communicating the result to Bob over a completely open line. 
To see this in action, we first generate two primes for Bob, and use 17 as 
the encryption exponent. 
p = RandO!IPrime [ 5 3 ]  i 
q = Randomrrime [ 47 ] i 
e = 17 i 
D = p • q  
2 1 7 4 1 3 7 5 9 5 3 6 6 1 1 2043 1 9 6 8 2 6 3 6 0 8 8 6 9 6 6 1 7 1 4 3 7 8 6 7 83 7 1 5 1 7 9 0 0 1 5 4 6 7 4 0 \  
4 5 2 3 8 8 57 2 6 6 8 62 9 4 9 3 3 8 3 8 0 9 9 84 3 1 7 9 5 3 8 7 1 1 7 5 7  
GCD [ e ,  ( p  - 1 )  ( q - 1 )  ] 
1 
Alice then uses the public key - the pair (n, e) - to form the eth power of 
m, call it s, and sends it to Bob. It is important in this basic example that 
m < n; longer messages can be broken into several pieces. 
s = PowerMod [ m , e ,  n] 
1 0 1 0 7 9 802 1 0 1 0 8599438385268504282 9 6 3 5 0 3 1 2 3 5 6 1 3 0 8 3 5 1 5 2 0 3 4 0 8 53 2 \  
5 6 3 2 1 84 5 6 0 3 862003 4 1 4 1 17320737 1 9 2 4 6 1 5 3 4 4 8  
Now for the good part: Even though the whole world knows n, e, and the 
encrypted message s, Bob is the only person who knows p and q. Therefore, 
he knows the explicit value of <fJ(n), which is </J(pq), or (p - l)(q - 1). Using 
this he is able to compute d, the inverse of e(mod<fJ(n)); d is the decoding key. 
d = PowerMod [ e ,  - 1 , (p - 1) ( q - 1 ) ] 
1 2 7 8 9 0 4 4 6 7 8 6 2 4 1 8 84 893930962405 1 1 5 6 5 7 1 4 3 4 0 3 9 904 1 6 8 6 6 2 6 4 7 8 1 5 5 7 \ 
8 3 7 6 1 1 8 2 3 7 1 6 524435593293987084 1 1 1 0 8 0 4 0 1  
Using d he can look at sd (mod n), which is just (me)d(mod n), or med(mod n). 
But ed = 1 (mod </J(n)), so by Euler's Theorem (or the more explicit Corollary 
3.8), med = m 1 = m (mod n). 
decrypt = PowerMod [ s ,  d, n] 
52707 7 7 7 0 1 84 7 3 6 6 8 3 7 0 8 4 0 1 7 9 80 8 8 1 5 0 1 34 7 7 7 4 6 8 7 0 1 5  

Integer'foString [decrypt ] 
Sell shares now . Alice . 
5. 1 .  CODING SECRETS 
1 49 
This method, called RSA encryption after its inventors, R. Rivest, 
A. Shamir, and L. Adleman, is most remarkable. It is an example of a 
public-key cryptosystem. One wonders if the great codebreakers of the past, 
from John Wallis to Alan Turing, would have thought such a thing was 
possible. The idea of a public-key cryptosystem was put forward by W. 
Diffie and M. Hellman in 1976. While RSA, which was discovered in 1978, 
was not the first public-key system, it is the easiest to understand and 
works well in practice. 
Before committing to an RSA system for serious work, one must be 
aware of several things: 
• The choice of p and q should be such that factoring their product is 
difficult. This depends on the state of factoring algorithms. Current 
practice is to avoid primes p for which p - 1 is divisible only by small 
primes. Part of the reason is that Pollard's p - 1 factoring algorithm 
(see Section 5.4) will be able to factor pq if p - 1 is divisible only by 
small primes. An even more important reason is that if p - 1 and 
q - 1 have many small prime divisors, then there is a high probability 
that the encryption exponent e has a small order (mod </J(n)). This can 
help an eavesdropper (see Exercise 5.5). 
• Message senders must be aware of the chosen-plaintext attack. If an 
eavesdropper knows that the message is either YES or NO , then she 
can just encode these two and see which yields a match. Thus short 
messages should be padded with random sequences of letters. 
• Short messages can be insecure. For if me turns out to be less than n, 
then the modular reduction disappears and an eavesdropper can just 
take the eth root of what she overhears to recover m. 
• Of course, e must be coprime to (p - l)(q - 1). But that does not guaran­
tee security. There can be bad values of e that must be avoided like 
the plague. This is discussed in Exercise 5.5. 
• If a message would yield an integer larger than n, then the message 
must be broken into blocks, each of which gets coded as an integer 
less than n. 
• A  single numerical error in transmission is a disaster, so perhaps 
some error-correcting or redundancy might be useful. See Section 5.5 
for the use of check digits to catch some transmission errors. 
• No system is immune to the rubber-hose method of breaking a code. If 
Bob can read the secret message, then so can Eve if she is torturing 
Bob to force him to do her bidding. No encryption scheme can prevent 
this. Bribery is a less violent alternative: 
For a more comprehensive treatment of pitfalls in encryption, see [Schn]. 

1 50 
5. SOM E APPLICATIONS 
The CNT package has RSAEncode and RSADecode functions that take 
care of the conversion to an integer and the breaking down into blocks. 
Here is how these functions would be used to encode the Zimmermann 
telegram, which was sent in January 1917 from the German foreign minis­
ter to the German ambassador in Mexico City. The British were able to 
decipher this most secret and sensitive message, and when they revealed it 
to the Americans, it was one of the most important factors causing the 
United States to enter World War I. For more information on the code­
breaking methods involved see [Tue]. 
telegram = 
" We intend to begin on the first of February unrestricted 
submarine warfare . We shall endeavor in spite of this 
to keep the United States of America neutral . In the 
event of this not succeeding, we make Mexico a proposal 
of alliance on the following terms : make war together , 
make peace together,  generous financial support and an 
understanding on our part that Mexico is to reconquer 
the lost territory in Texas , Hew Mexico , and Arizona . 
The settlement in detail is left to you . You will inform 
the President of Mexico of the above most secretly as 
soon as the outbreak of war with the United States 
of America is certain and add the suggestion that be 
should , on his own initiative , invite Japan to immediate 
adherence and at the same time mediate between Japan 
and ourselves . Please call the President ' s  attention 
to the fact that the ruthless employment of our 
submarines now offers the prospect of compelling England 
in a few months to make peace . Signed , Z IMMERMAH . " i 
CodedTelegram = RSAEncode [telegram, e ,  n] 
{ 1 9 8 0 6 1 1 9 1 1 0 2 7020 3 1 1 7 3 40260430447 9 1 7 5 8 5 5 8 5 4 8 6 6 5 8 1 6 9 5 7 3 7 8 8 7 3 6 \  
1 8 1 0 5 6 9 3 1 7 7 53354 6 3 5 1 7 60 7 0 1 8 4 6 0 3 4 8 1 7 2 0 8 , 
8202248603 1 5 2 504 8 0 3 2 9 4 1 5 3 5 9 1 8 07 4 3 6 3 4 1 2 7 5 7 2 1 0 0 3 3 4 9 7 7 8 6 8 5 5 2 3 3 \  
1 1 2 5 1 5 5 9 8 6 9 33988054966009 1 8 0 3 4 9 9 4 2 2 7 6 3 5 7 , 
1 2 7 4 4 9 3 7 3 3 5 2 8 6 3 8 9 6 9 4 9 2 5 9 1 7 0 2 3 2 3 8 8 1 4 6 2 9 4 1 3 2 7 1 6 8 8 1 4 8 4 5 6 4 4 1 6 5 9 \  
902 1 6 3 3 1 0 4 2 3 108504 3 5 7 122025792 5 4 8 1 3 3 7 7 9 2 8 ,  
1 5 6 3 9 8 2 2 1 2 6 6 1 1930092 5 1 020433833 8 6 1 5 7 5 0 0 6 7 6 2 1 0 6 2 3 1 8 9 5 1 4 2 9 9 3 6 \  
0 8 1 3 2 8 3 1 4 7 4 3 33 9 7 7 1 3 7 9 50256934 1 6 8 6 6 8 9 2 9 0 6 7 ,  
1 1 4 4 1 2 50 3 8 0 9 2 4 7 2 8 3 3 4 020899 6 2 8 6 4 6 4 2 4 2 4 54 6 1 2 7 9 4 2 7 1 9 4 3 5 1 1 9 9 69 7 \  
2 7 1 2 8 6 1 0 5 9 7 7 527 4 8 8 7 8 0 1 3 62 0 2 8 7 4 7 2 2 2 2 0 3 2 2 5 9 ,  
1 6 5 2 9 5 5 8 6 8 9 8 5 29 9 1 54 9 3 6 2 2 2 8 4 6 3 0 6 6 8 4 9 2 1 8 2 0 9 5 0 7 3 1 7 6 3 2 1 7 8 2 3 5452 \ 
4 5 3 4 6 3 7 5 2 3 4 3 3 1 3 4 7 3 9 40 1 3 8 7 1 7 55 8 0 2 2 9 8 7 0 2 8 8 ,  
1 3 4 5 5 1 3 0 6 5 7 5 7 744074404 5 8 4 1 2 6 3 9 5 9 1 4 57 8 6 8 3 1 6 7 7 6 3 1 2 7 8 8 1 0 9 8 4 0 1 8 \  
0 1 809 8 8 8 5 6 2 2 56 7 6 7 6 5 3 5 9 7 3 6 8 4 5 5 9 8 9 2 4 3 4 07 4 3 5 ,  
1 6 7 8 7 5 0 6 7 6 3 5 3 17 5 6 5 1 5 5 6 7 3 8 5 1 2 7 2 1 6 0 7 9 0 1 3 3 7 1 8 1 4 2 0 7 0 1 3 0 5 6 1 5 1 1 3 5 \  
0 4 4 5 8 8 7 9 2 8 5 3 05802 6 3 8 8 2 1 6 5 8 3 4 4 7 6 8 0 7 3 4 8 8 5 8 9 , 
1 8 9 9 1 9 5 8 8 6 8 7 4 73 1 7 8 53 7 7 1 1 664403 8 5 2 5 4 0 6 6 2 4 2 3 8 7 9 0 8 6 5 3 1 8 2 7 89907 \ 
6 5 2 9 9 5 0 6 1 4 9 7 634 7 9 1 63 2 2 6 1 3 8 69 7 2 6 2 8 7 1 7 1 0 4 4 8 ,  
1 3 2 1 5 0 5 8 9 5 5 4 1 4 8 630604254 1 9 1 4 504 3 1 64 6 9 7 0 1 1 4 6 4 7 6 3 1 4 4 2 4 4 5 6 4 3 9 7 \  
5 3 6 4 4 3 5 5 3 1 8 7 2 8 2 4 4 0 6 1 2 2 5 9 3 5 8 0 6 0 3 0 9 3 2 0 1 9 0 4 5 ,  
1 4 7 8 2 2 0 3 4 0 2 5 1 4 6 4 3 0 6 8 7 7 2 0 1 0 8 57 8 8 1 5 2 3 3 3 6 8 0 7 1 6 6 8 9 1 8 2 2 1 0 2 9 4 3 5 9 7 \ 
0 2 8 5 3 2 62 2 6 7 8 1 7 1 69244822899643 5 1 4 1 3 3 0 0 8 7 1 8 ,  

5. 1 .  CODI NG SECRETS 
1 51 
3 5 0 8 80 9 3 9 4 0 6 1 1 9 4 6 9 2 5 9 9 3 6 540535365 192653 5 2 1 7 2 3 5 7 3 59 2 6 0 8 9 9 5 1 1 4 '  
9 9 2 9 6 1 4 4 3 9 5 2 3 9 4 7 8 4 8 8 8 7 2 1 86 9 7 7 2 1 3 47 7 9 6 6 3 , 
7 8 5 7 5 5 2 6 0 8 6 3 0 6 4 4 9 8 2 3 7 3 7 9 74 6 8 5 5 2 6 4452 1 9 1 6 7 0 0 8 9 7 6 3 3 7 4 3 3 8598 7 1 \ 
7 8 0 0 8 3 5 8 9 4 6 0 0 3 3 0 5 1 0 2 9 3 8 3 7 838629547 9 7 8 8 3 9 ,  
2 1 3 1 7 6 3 1 2 8 5 6 0 4 3 1 0 3 2 8 2 1 6 6 6 6 184581074 0 1 3 5 6 2 1 8 9 1 5 2 3 8 3 5 6 8 4 3 7 2 6 9 '  
0 4 6 9 9 1 1 5 3 5 1 5 54 2 4 0 9 2 9 6 8 8 3 7 4 6 1342959 1 50 7 8 9 0 ,  
2 0 9 8 2 4 1 6 3 4 5 7 7 2 2 3 9 8 59 8 3 8 7 8 7 2 8 05 1 4 1 14 4 8 5 2 3 9 6 2 0 6 4 3 7 0 0 9 1 7 4 4 1 4 4 0 \  
4 3 3 8 8 1 9 6 0 2 1 8 6 2 1 3 2 5 8 1 7 3 7 8583530 1 7 66 1 4 6 9 8 1 7 ,  
1 8 8 1 7 8 7 3 1 5 9 7 1 5 8 9 0 7 6 3 6096306945 1 8 1065 1 7 54 5 2 2 4 0 9 1 9 5 02 7 8 3 5 8 1 4 8 \  
9 6 3 3 1 1 6 9 5 4 0 1 0 2 5 0 8 0 5 5 8 3 4 80 7 3 8 5 105929 6 0 4 7 6 0 ,  
1 2 2 2 1 4 50 9 5 6 2 0 9 0 7 6 6 9 3 5 1242080 7 8 2 4 1 9 54 3 74044 1 8 8 1 5 8 4 6 50222085 3 \  
5 9 6 9 5 6 6 7 1 3 3 3 0 8 9 0 8 8 4 5 8 6 7226769644952 7 1 5 7 7 0 ,  
6 4 6 4 3 1 6 5 2 2 9 0 0 8 9 1 6 3 5 54590642659 1 6 9 8 3 8 9 8 4 4 9 7 6 4 6 1 7 7 7 1 3 6 7 6 1000 2 \  
7 4 9 7 0 8 4 0 3 3 7 2 1 4 2 6 2 7 22 3 8 9 0 2 1 7 4 3 7 84 5 7 5 0 7 9 2 6 , 
1 69 9 3 4 0 3 6 0 6 6 4 3 5 7 5 3 4 9 6 2 2 829862 1 2 1 7 375720206404234909 8 1 3 54 5 9 0 \  
7 3 0 3 5 6 5 9 1 2 0 1 3 9 1 0 3 8 10494822506886820 1 9 2 3 1 4 ,  
1 9 7 2 1 8 6 6 8 9 1 8 6 0 7 1 1 4 850098265878079585 6 8 7 9 8 1 3 2 0 7 5 4 8 0 8 3 3 7 0 3 9 0 5 \  
7 1 8 6 2 3 6 8 0 7 8 2 4 1 5 8 9 1 8 7 8 5 5 1 1 9 7 65439924 5 0 5 1 2 4 } 
Short [RSAPecode [ Coded±elegram, d ,  n] , 8 ]  
We intend t o  begin on the first of February unrestricted 
submarine warfare . We shall endeavor in spite of 
this to keep the United States of America neutral . 
In the event of this not succeeding , we make Mexico 
a proposal of alliance on the following terms : ... 
at the same time mediate between Japan and ourselves . 
Please call the President ' s  attention to the fact 
that the ruthless employment of our submarines now 
offers the prospect of compelling England in a few 
months to make peace . Signed , Z IMMERMANN . 

 Digital Signatures 
Suppose Bob, a stockbroker, receives a message from his client, Alice, 
saying: "Sell all shares in XY Co. Alice. Feb. 17, 1999". Because the key to 
send messages to Bob is fully public, he has no way of knowing whether 
this message is really from Alice; and he needs certification of Alice's signa­
ture to avoid a future claim by Alice that she sent no such message. The 
public-key scheme allows Alice's signature to be encoded in such a way that 
it would stand up in a court of law. Here is how it is done. 
Recall that the directory of public keys contains Bob's key (n, e) as well 
as one for Alice, (nA, eA>· Alice takes the message and turns it into a num­
ber as usual, but before sending it to Bob, she encrypts it using nA and her 
personal decoding key, dA , which only she knows. She then takes this and 
encrypts it using n and e. Now, Bob, upon receipt, decrypts as usual. What 
he sees is not English, but gibberish. But it is very special gibberish! If he 
pretends to encode it using Alice's public key, it will turn into the original 
message. This means that the sender had to know dA , which proves that 
the sender was Alice. The reason this works is that the main rule of RSA, 
me d = m1 = m (mod n), is independent of the order in which e and d are 
multiplied; md e = m1 (mod n) too. 

1 52 
5. SOME APPLICATIONS 
Here are the details, where we use Bob's keys defined earlier and create 
a new key for Alice, nA , eA, and dA .  
P.1. = RagdO!lPrime [ 5 3 ] ; 
q.. = RandmpPrime [ 4 7 ]  ; 
D.1. = P.1. Ch ;  
e.1. = 17 ; 
d.1. = PowerMod [ e.1. , - 1 , (P.1. - 1 )  (q.. - 1 ) ] 
message = StringToipteger [ 
" Sell all shares in XY co . Alice . Feb . 17 , 1999 " ] ;  
signedmessage = PowerMod [message , d.1. , n.1. ] ; 
sentmessage = PowerMod [ signedmessage , e ,  n] ; 
Now when Bob decrypts what he receives, the integer he gets turns into 
nonsense if he tries to turn the integer into a string. 
decryptedgibberisb = PowerMod [ sentmessage , d ,  n ]  
1 4 6 1 7 2 0 1 2 6 84 0 7 8 6 5 8 2 2 8 5 82 8 6 1 8 0 1 7 6 3 1 9 7 0 2 1 7 7 4 4 5 5 8 4 6 7 7 7 6 4 9 5 5 9 4 8 3 \  
8 8 2 1 0 0 8 7 8 57 7 2 2 1 5 1 7 2 8 6 5 0 4 1 5 6 5 4 0 1 7 0 3 4 8 5 7 2  
Inteqer±oString [decryptedgibberisb] 
M0 3 +cGm' q; Y ; \o0 Ȍ 2e4lKVsbl_- ZOEq) ' mXg4RguQHWU eAtg 
This ostensibly meaningless string is in fact very special. Encoding it with 
Alice's public key turns it into proper English. 
Inteqeriostring [ PowerMod [ decryptedgibberisb , e.1. , D.1. ] ] 
Sell all shares in XY Co . Alice . Feb . 1 7 , 1 9 9 9  
Only someone who knew dA could have produced such a string, and this 
proves that Alice sent the message. 
The ideas of public-key cryptosystems have diverse applications in the 
world of electronic commerce and communication. See [Schn] for an encyclo­
pedic treatment by an expert in the field. 
Exercises for Sedion 5.1 
5.1. Show how a modification of the coin-flipping protocol in the text leads 
to a system by means of which Alice can pass a random bit (0 or 1) to Bob in 
such a way that: 
• Bob learns what the bit is and has faith that it is random (in no way 
controlled by Alice's choices). 
• Alice does not learn what the bit is (but has faith that it is truly 
random). 
• Alice receives some information from Bob so that, if Bob must prove at 

5. 1 .  COD I NG S ECRETS 
1 53 
a future date that he used the proper bit, he can do so in a way that 
satisifies Alice that he did not cheat. 
We do not know any applications of this idea, but closely related ideas 
of oblivious transfer of messages have a variety of uses (see [Schn]). 
5.2. Why is the following coin-flipping protocol seriously flawed? Alice picks 
two large primes p and q and reveals their product to Bob. Bob then 
guesses whether p = q (mod 4) or not. If he is correct, the toss is deemed to 
be HEADS, otherwise TAILS. 
5.3. 
Explain why the following protocol for coin-flipping electronically 
works; in particular explain why it is important that the same modulus n 
be used by Alice and Bob. 
Alice and Bob use the same primes p and q, with n = pq as usual. But 
they choose large random exponents eA and eB and keep them secret. They 
can each find the mod-cf>(n) inverse of their exponent, dA and dB. Alice forms 
two integers mo and m1 so that mi has an i encoded near the beginning and 
has random digits near the end. She encodes them using eA and n and 
sends the results, Mo and M1 , to Bob. Bob picks one, encodes it using eB 
and n, and returns it to Alice. Alice "decodes" this using dA and n and sends 
the result back to Bob. Bob "decodes" this using dB and looks in the speci­
fied location for a 0 or 1, which becomes his random bit. He sends this last 
message, which is one of the mi ,  back to Alice, thus proving to her, because 
of the random digits she included, that he has played by the rules. Alice 
then tells Bob eA so he knows she really encoded one 0 and one 1. 
5.4. Show how the protocol of Exercise 5.3 can be used to allow Alice and 
Bob to play poker by e-mail. Hint: Instead of 2 messages, Alice will use 52 
messages M1 , ... , M52 . 
5.5. Suppose that Bob uses the following primes to get n for his RSA public 
key. 
p = 125811237 444512 7 1 420939617037 41802 6 5 1 1 52228819947 ; 
q = 7 62 2 7 3 4 3 3 8 1 7 509332 689903 16369522 1767002 3 ;  
D = p q ; 
PrimeQ [ {p ,  q} ] 
{ True , True } 
And because he is concerned about security, he generates a large random 
number to use as the encryption exponent e. And, of course, he checks that 
gcd[e, (p - l)(q - 1)] = 1. 
e = 3682 4022897 03089202230506624896433 55058600584012993920997 ' 
3 9 829686647 17 046427297322817 2 5 ;  
Soon after, Alice then sends a message to Bob using his public key. 

1 54 
5. SOM E APPLICATIONS 
message = 
RSAEncode [ " Look out. . Charlie is a double agent. . " ,  e , n] 
2 9 4 4 2 1 8 8 84 9 6 5 98 6 5 1 0 4 63 0 6 1 14748003 8 1 6 1 1 8 7 1 6 0 0 7 3 6 3 1 9 5 6 8 07 4 4 1 6 4 '  
9 0 7 5 03 9 6 1 3 7 9 7 12974238948242 8 
Eve, Charlie's handler, obtains the coded message and tries something she 
once heard about at a cryptographers' convention. She re-encodes the coded 
message using Bob's public key, and then repeats this several times. Lo and 
behold (see table), on the twenty-second iteration the original message pops 
out! What is special about e that makes it vulnerable to this method of 
attack? What could Bob have done to prevent it? 
The following Mathematica code takes the message and runs 22 modu­
lar powers on it using the exponent e. (NestList [ f ,  a ,  m ]  applies f to a 
repeatedly m times and shows all the intermediate results.) The Integer­
ToString function shows us the characters corresponding to the integer at 
each stage. 
Map [ Int.egerToString, 
Nest.List. [ PowerMod [ fl ,  e ,  n] &, message , 22 ) ] / /  'rableForm 
---
1 
i <11:4ws0ZuR# ' \ • NO[)E / • V l 0h - 2WoiH__yj " 0 , nf< i6x07 ; 
2 I [ 5 • 5 { H•- FkP : Uj_ % I l ! •6•\Ug l Vqlz ; h@Aav6 = / 1 1 } X< 
3 
k>zc4Rzwxav' Lhx0S0_00" 2q [ & 7 . z\3D@[] . cdT92 { ! 00 
̄ >- -
4 
A '  fwZ AS z l  \llTQe4E ( c  ( ; . IgVG i aZh • fw-• ! YkQI# ) VU "  . 
5 
6 
7 
8 
g 
1 0  
i 1 1  
[ tWW> 4GwfV= >#Q l a\\56<rNll:ORDO -wtl7X >m Xatcy ! ' $  
dn , tU . 2 JA 1 7 + ) 9oZ 2 > r < = ! _Dl ?t + jroSyA •9oM39g' & 8  
b ( n . Rw@- ] IQ ' OL] UM [ >U V5 \ , eky(lu ( i-L"r , D ! 2Z_4 . 
dn&\dtis "•jCO#JE ( ) OSWiNcllSiBppV ! b-S#0 ! 8fFDwQ 
IRbOs "K) : C ' 6 ' xly . Kyb9lil!N#zs ' SpXKq" O#L ,T) BllO 
B7•1 = [ W [ zw6E_Ai •OobStzE9 > 1 020 . @) lmup /CS } al• 
4 '  : S/qJ [ 9 ( fr " TKD3hR2Us ' BkcqD811 ?w> [ NOXA4ov! = 8  
, , 
1 2  
SlloR4a22Y = .  jSXZw ) , Vall@-" (uhdOz '.lC ( zYi<ZgLScCtl .• 
1 3  Z n  l n ;  2dUUtE6UJYMqV l ?Qc-D{]H8E9 1 &Bqo (c?<$1YDD 
-·-· 
1 4  
?P ;ovdF , e&y; e[]#I · v =  · $\] @'•'-Ke ' ;(). ॣe l Q, ; Fa (K : 
Jl 5 I .alW/C$qBmliZQhp+>ReVBnull'DI;Uj ] RU "86 • (112π. + 
· 
! 1 6  &RC#SiiFuo3Uz08j ! BTR : "#-v9 • A  -G : lfWq߄"l!i (-!?߅V 
: 1 7  m9" anUL2nGR7 ) _&WBQtKr8 [wr;pTil'JD >Ui -f"'2 ॥a3 
! 1 8  j 39TsEK3CxJ7 ) h [VP' f > pgHl!i'9U2xB I Z ; ) " Uldl" iatW_Xt 
i 1 9  i Stul l g ? ] rNKYV62 0t03m . e ? ! dvp>B' ZFiqCj lx9Vj ; "F 
f 2 0  ! XyC " 3 1R64KDB ' 
?FOb-/uyq ' 7{]q=vi z VY$V1Y-rR ! ( xR  · 
i'21' ! G  ! OOJ i  4FXqA ) O[J@Sq2 7e#a4I<9z) -JN 4By>5 ' . noo 
Eavesdrop in string form 
Encode of preceding 
1 2 2  l1 > & -x2d ' hg "w ( J 403211ou >c@M>1$z ! jjgiBO ) p ;khj : 
߃Look out _. Charlie ' is a double .agent-_ 
. Surp।! 
l 
I 
i 
! 
I 
5.6. In the RSA keys one uses large primes, but typically such large num­
bers are only probably prime. Investigate the consequences of using a 2-
pseudoprime for one of the primes used to form n. What happens if the 
prime is a Carmichael number? 
5.7. Investigate what happens in the RSA scheme if the message m 
(assumed to be less than n) happens to be divisible by one of the two primes 

5.2. THE YAO M I LLIONAI RE PROBLEM 
1 55 
that divides n (which is pq), say m = pt k, where gcd(k, n) = 1. Prove that 
(pt k)de = pt k (mod n). 
5.8. Suppose that Bob is using the RSA public key (n, e) of Exercise 5.5 and 
Alice is using the public key (nA, eA) from the Digital Signatures subsec­
tion. Suppose further that Alice and Bob always use digital signatures to 
validate their messages. Show how Eve can send a message to Alice saying: 
"Good news. Eve has just come over to our side. Follow her instructions. 
Bob." in such a way that Alice will believe the signature is correct and the 
message is from Bob. 
5.9. Suppose that Alice and Bob are both using RSA with the same public­
key n, but diferent values of e which are relatively prime to each other. 
Suppose Charlie sends the same message to each of them, and Eve captures 
it. Show that Eve can read the message. Hint: Eve will want to use r and s 
so that re1 + se2 = 1. 
5.2 The Yao Millionaire Problem 
Suppose Alice and Bob wish to learn who has the higher salary, but without 
revealing his or her own salary. This problem, known as the Yao millionaire 
problem, has a nice solution using the ideas of the RSA protocol. Suppose 
that Alice's salary is $65,000 and Bob's is $68,000, they will work only to 
the nearest thousand dollars, and they each know that all salaries are 
between $60,000 and $70,000. These last two assumptions simplify the 
presentation, but are completely inessential. 
First, Alice generates a large random number, less than but with the 
same number of digits as the n of Bob's public key. To help us keep track of 
it, we will use the number that follows, which is not quite random. 
AliceRandom = 
13854655523423924323527835325325284 1 2 4 8 5 3 12 3 3 52 5 522 5 123726\ 
82720086 181965 3 4 1 4 107 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 892545 ; 
Alice then encrypts this number using Bob's public key, but she subtracts 
65 before sending it to him. Bob is using the same key he used in Section 
5.1, which we regenerate here. 
p = 650634807 6528520'25015627 372170468 1 1 49 1 4 5 199258873459; 
q = 3 3 4 15 6360802 3456723 16578240709529 1 7 5 503 9 1 4 7 1 95 9 ;  
{D , e }  = {p q , 17 } ;  
d = PowerMod [e , - 1 , (p - 1 ) (q - 1 ) ] ; 
AliceToBob = PowerMod [AliceRandom , e ,  11 ]  - 6 5 
2 04 1 3 2 6 4 50 9 4 3 0 1 8 3 7 4 4 2 6 8 8 4 7 8 050980205 7 4 0 4 9 1 0 3 9 2 8 1 2 3 2 7 8 4 9 7 2 1 9 8 c  
3 9 7 0 8 5 4 7 6 3 4 1 7 3 0 7 6 6 5 7 6 6 7 67504202 6 1 05 1 9 9 1 6  

1 56 
5. SOME APPLICATIONS 
Bob could recover Alice's random number if he knew to add 65 from the 
received number, but he does not know this. So the best he can do is add 
each of 60, 61, 62, . . .  , 70 before decoding and be confident that one of these 
is Alice's random number. Of course, it sticks out as the sixth entry in the 
list that follows. 
BobData = PowerMod [Alice'roBob + Range [ 6 0 ,  7 0 ] , d, n] 
{ 1 6 6 5 2 3 1 2 5 1 8 08 0 253707408620592 8 9 9 2 4 1 6 9 7 6 0 3 7 6 8 3 2 3 1 2 5 4 6 3 8 0 4 7 8 0 \  
7 2 0 9 9 4 3 1 9 6 7 9 3 2 1 3 9 5 7 4 0 72 3 6 4 1 9 5 1 7 7 6 6 003 3 1 8 0 ,  
1 2 6 6 02 3 8 5 0 5 9 1 74743 7 2 1 7 55623333 5 8 8 8 2 7 603 1 8 3 9 8 2 7 1 6 4 5 6 0 5 3 7 6 3 4 5 \  
5993 1 2 7 7 8 3 6 2 62 7 7 9 5 1 79980629872 7 1 7 6 6 5 7 1 1 4 6 , 
1 2 3 8 4 2 3 1 8 1 05 0 105383 1 1 3 8 8 2 9 4 3 0 5 2 8 0 4 3 2 3 55 9 6 9 7 4 0 9 1 07 0 8 6 9 0 4 7 9 1 5 \  
5508 6 1 5 9 2 2 2 92884948 94829402 1 8 3 1 2 3 0 5 2 04 9 2 , 
1 1 4 03 8 1 2 5 6 8 7 0630408 6 7 8 4 4 3 10304 8 6 5 3 4 2 53 5 6 6 8 6 5 0 7 4 8 8 8 1 9 4 0 0 6 2 4 6 \  
1 3 02 6 6 3 9 4 1 0 7 3024 1 4 052494 14692 5 5 1 9 08 4 9 5 5 3 0 ,  
4 6 8 0 2 3 5 8 2 4 4 8 526209 140242 1 1 6 8 2 1 7 00 9 1 7 3 7 4 6 9 3 3 03 6 0 7 6 6 1 8 5 8 2 1 5 6 3 \  
7054 1 9 2 0 6 5 8 684705394900989875003 9 2 1 09022 , 
1 3 8 5 4 6 5 5 5 2 3 4 2 392432352783532532 5 2 8 4 1 2 4 8 5 3 1 2 3 3 52 5 5 2 2 5 1 2 3 7 2 6 8 \  
2 7 2 0 0 8 6 1 8 1 9653 4 1 4 1 07 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 9 2 5 4 5 ,  
2 04 1 1 2 5 5 1 6 8 3 52 1 1 1 5 0033 1 0209443 1 6 8 4 5 1 5 2 9 3 8 9 7 3 2 2 3 7 2 4 8 4 6 1 3 6 3 7 6 \  
4 9 1 1 8 7 5 6 3 5 2 4 5 6 1 8 2 4 7 0 8 8 7 8 0 1 6 2 2 2 6 8 8 8 5 4 8 6 9 5 9 , 
2 7 3 3 8 2 6 1 5 4 6 2 635909 9 8 8 1 7 3 9 6 3 1 5 8 8 0 8 8 5 3 3 4 0 0 1 6 8 5 8 2 7 8 7 8 3 9 2 2 1 3 08 7 \  
8 9 9 4 3 7 6 5 7 2 8 2 650469062 897 1 1 59 6 3 7 00 2 8 0 0 7 6 2 , 
1 5 4 9 0 0 0 7 6 7 7 6028593 7 4 64 0 1 7 0 8 6 7 8 7 6 6 6 5408094 4 4 4 2 4 5 3 9 6 6 0 4 8 4 6 8 3 8 \  
0550409 2 4 7 5 1 86 6 7 8 420233244254 6 6 3 1 0 1 0 1 6 1 1 ,  
3309 5 8 6 9 7 8 3 6 1 78 5 4 5 9 5 5 0 2 8 2 9 1 2 9 0 7 9 5 4 8 4 7 6 4 9 4 9 2 0 9 5 8 9 08 6 6 03 9 6 3 1 3 \  
4 6 9 2 4 4 8 8 5 8 5 1 98 1 6 1 9 6 0 5 1 3625755 1 2 9 7 4 9 7 5 7 6 7 ,  
2 6 9 6 0 6 2 0 3 9 1 9 8 1 8 3 0 9 9 3 2 8 3 6 4 7 07 2 1 7 6 3 2 2 6 7 8 4 6 8 6 4 9 7 1 7 8 0 8 4 2 1 4 8 4 1 1 7 \  
8 5 0 5 5 8 8 7 6 6 0 783 3 5 1 1 0902379 5022 3 7 1 2 4 3 8 8 7 5 6 } 
Bob now has an 11-number data set. What he would like to do is add 1 
to the last two entries only, which correspond to offsets of 69 and 70, the 
two numbers greater than his salary. 
BobDataModified = BobData + { O ,  O ,  O ,  O ,  O ,  O ,  O ,  O ,  O ,  1 ,  1 }  
{ 1 6 6 52 3 1 2 5 1 8 0 8 02 5 3 7 074086205928 9 9 2 4 1 6 9 7 6 0 3 7 6 8 3 2 3 1 2 5 4 6 3 8 04 7 8 0 \  
7 2 0 9 9 4 3 1 9 6 7 932 1 3 9 574072364 1 9 5 1 7 7 660033 1 8 0 ,  
1 2 6 6 0 2 3 8 5 0 5 9 1 74 7 4 3 7 2 1 7 55623333 5 8 8 8 2 7 6 0 3 1 8 3 9 8 2 7 1 6 4 5 6 0 5 3 7 6 34 5 \ 
5993 1 2 7 7 8 3 6 262 7 7 9 5 1 79980629 8 7 2 7 1 7 6 6 5 7 1 1 4 6 , 
1 2 3 8 4 2 3 1 8 1 050105383 1 1 3 8 82943052804323 5 5 9 6 9 7 4 0 9 1 07 0 8 6 9 0 4 7 9 1 5 \  
5508 6 1 5 9 2 2 2 9288494894829402 1 8 3 1 2 305204 9 2 , 
1 1 4 03 8 1 2 5 6 8 7 06304 0 8 6 7 8 4 4 3 1 03 04 8 6 53 4 2 5 3 5 6 6 8 6 5 0 7 4 8 8 8 1 9 4 0 0 6 2 4 6 \  
1 3 0 2 6 6 3 9 4 1 07302 4 1 4 052494 1 4 6 92 5 5 1 9 0 8 4 9 5 5 3 0 ,  
4 6 8 02 3 5 8 2 4 4 8 526209 140242 1 1 6 8 2 1 7 00 9 1 7 3 7 4 6 9 3 3 0 3 6 07 6 6 1 8 5 8 2 1 5 6 3 \  
7054 1 9 2 0 6 5 8 684705394 90098 9 8 7 5 0 0 3 9 2 1 090 2 2 , 
1 3 8 54 6 5 5 5 2 3 4 2392 4 3 2 3 5 2 7 8353253 2 5 2 8 4 1 2 4 8 5 3 1 2 3 3 5 2 5 5 2 2 5 1 2 3 7 2 6 8 \  
2 7 2 0 0 8 6 1 8 1 9 6534 1 4 1 07 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 9 2 54 5 ,  
2 04 1 1 2 5 5 1 6 8 3 52 1 1 1 50033 1 020944 3 1 6 8 4 5 1 52 9 3 8 9 7 3 2 2 3 7 2 4 8 4 6 1 3 6 3 7 6 \  
4 9 1 1 8 7 5 6 3 5 2 45 6 1 8 2 4 7 0 8 8 7 8 0 1 6 22 2 6 8 8 8 5 4 8 6 9 5 9 , 
2 7 3 3 8 2 6 1 5 4 6 2 635909988 1 73963 1 5 8 8 08 8 5 3 3 4 00 1 6 8 5 8 2 7 8 7 8 3 9 2 2 1 3 08 7 \  
8 9 94 3 7 6 5 7 2 8 26504 6 9 0 6 2 8 9 7 1 1 5 9 6 3 7 0028007 6 2 ,  
1 5 4 9 0 00 7 6 7 7 6 02 8 5 9 3 7 4 6 4 0 1 7 0 8 67 8 7 6 6 6 54 0 8 0 9 4 4 4 4 2 4 5 3 9 6 6 0 4 8 4 6 83 8 \  
05504 0 9 2 4 7 5 186678420233244254 6 6 3 1 0 1 0 1 6 1 1 ,  

5.2. THE YAO M I LLIONAI RE PROBLEM 
1 57 
3 3 0 9 5 8 6 9 7 8 3 6 1 7 8 5 4 5 9 5 5 02 8 2 9 1 2 9 0 7 9 54847 6 4 9 4 92 0 9 5 8 9 0 8 6 6 0 3 9 6 3 1 3 4 c 
6 9 2 4 4 8 8 5 8 5 1 9 8 1 6 1 9 6 0 5 1 3 6 2 5 7 5 5 1 2 97497576 8 ,  
2 6 9 6 0 6 2 03 9 1 9 8 1 8 3 09 9 3 2 8 3 6 4 7 0 7 2 1 763226784 6 8 6 4 9 7 1 7 8 0 8 4 2 1 4 84 1 1 7  
8 5 0 5 5 8 8 7 6 6 0 7 8 3 3 5 1 1 09 0 2 3 7 9 50223 7 1 2 4 3 8 8 7 5 7 } 
Bob wishes to sends this modified data set back to Alice, but he cannot do 
so for she could then just encrypt the data set and learn Bob's salary. Such 
an encryption would lead to numbers near the encrypted value of Alice­
Random, except in the cases that Bob changed them. Thus, Bob's salary of 
$68,000 would become evident to Alice. 
PowerMod [ BobDataModified ,  e ,  n] 
{ 2 04 1 32 6 4 5 0 9 4 3 0 1 8 3 7 4 4 2 6 8 84 7 8050980205 7 4 04 9 1 0 3 9 2 8 1 2 3 2 7 8 4 9 72 1 9 '  
8 3 9 7 08 5 4 7 63 4 1 7 3 0 7 6 6 57 6 6 7 6 7 504202 6 1 0 5 1 9 9 7 6 , 
2 0 4 1 3 2 6 4 5 0 9 4 3 0 1 8 3 7 4 4 2 6 8 8 4 7 8050980205 7 4 04 9 1 03 9 2 8 1 2 3 2 7 8 4 9 72 1 9 '  
8 3 9 7 08 5 4 7 6 3 4 1 7 3 0 7 6 6 57 6 6 7 6 7504202 6 1 0 5 1 9 9 7 7 ,  
2 0 4 1 3 2 6 4 5 09 4 3 0 1 8 3 7 4 4 2 6 8 84 7 8 0509802 0 5 7 4 04 9 1 03 9 2 8 1 2 3 2 7 8 4 9 72 1 9 \  
8 3 9 7 08 5 4 7 6 3 4 1 7 3 0 7 6 6 5 7 6 6 7 6 7 5042026 1 0 5 1 9 9 7 8 ,  
2 0 4 1 3 2 6 4 5 0 9 4 3 0 1 8 3 7 4 4 2 6 8 847 8050980205 7 4 04 9 1 0 3 9 2 8 1 2 32 7 8 4 9 72 1 9 '  
8 3 9 7 0 8 5 4 7 63 4 1 7 3 0 7 6 6 5 7 6 6 7 6 7 5 042026 1 0 5 1 9 9 7 9 , 
2 0 4 1 3 2 6 4 5 0 9 4 3 0 1 8 3 7 4 4 2 6 8 84 7 8050980205 7 4 04 9 1 0 3 9 2 8 1 2 3 2 7 8 4 9 7 2 1 9 \  
8 3 9 7 0 8 54 7 6 3 4 1 7 3 0 7 6 6 57 6 6 7 67504202 6 1 0 5 1 9 9 8 0 ,  
2 0 4 1 3 2 6 4 5094 3 0 1 8 3 7442 6 8 8 4 7 80509802 0 5 7 4 04 9 1 0 3 9 2 8 1 2 3 2 7 8 4 9 72 1 9 \  
8 3 9 7 0 8 5 4 7 63 4 1 7 3 0 7 6 6 57 6 6 7 6 75042026 1 0 5 1 9 9 8 1 ,  
2 0 4 1 3 2 6 4 5 0 9 4 3 0 1 8 3 7 4 4 2 6 8 8 4 7 80509802 0 5 7 4 04 9 1 03 9 2 8 1 2 3 2 7 8 4 9 72 1 9 '  
8 3 9 7 0 8 5 4 7 6 3 4 1 7 3 0 7 6 6 57 6 6 7 6 75042026 1 0 5 1 9 9 8 2 , 
2 0 4 1 3 2 6 4 5 0 9 4 3 0 1 8 3 7 4 4 2 6 8 8478 050980205 7 4 04 9 1 03 9 2 8 1 2 3 2 7 8 4 9 72 1 9 \  
8 3 9 7 0 8 54 7 6 3 4 1 7 3 0 7 6 6 5 7 6 6 7 6 7504202 6 1 0 5 1 9 9 8 3 , 
2 0 4 1 3 2 6 4 5 0 9 4 3 0 1 8 3 7 4 4 2 6 8 84 7 8 0509802 0 5 7 4 04 9 1 0 3 9 2 8 1 2 3 2 7 8 4 9 72 1 9 \  
8 3 9 7 0 8 5 4 7 6 3 4 1 7 3 0 7 6 6 57 6 6 7 6 7 504202 6 1 0 5 1 99 8 4 , 
1 1 2 6 1 0 3 5 84 8 5 1 8 6 1 7 3 6 1 9 6 7 9 7 7 6 44 3 7 1 1 2 3 2 5 1 3 7 7 9 0 3 9 9 6 9 7 8 5 1 0 9 8 74 2 0 '  
5 1 8 0 1 1 3 3 8 7 50 6 3 7 8 4 8 8 3 7 1 3 7 3 8 24 7 3 1 0 54 0 4 6 7 8 6 0 ,  
6 7 4 8 0 8 5 0 07 9 6 2 1 9 7 0 0 1 6 7 9 9 9 5 5932 7 5 1 8 7 0 1 8 3 9 2 6 8 3 0 6 4 1 504 1 0 8 3 722 1 8 ȍ  
8 5 3 6 5 1 1 4 1 2 2 4 9 9 6 0 8 2 8 99054799 5 1 8 1 3 8 4 8 8 8 6 5 4 } 
To avoid this problem, Bob chooses some moderately large prime p and 
reduces everything modulo p before adding 1 to the last three entries and 
sending the results to Alice, together with p tacked on to the end. 
p = RandomPrime [ 30 ]  
7 0 3 0 2 5 4 4 3 2 4 7 1 3 52 9 8 02 4 0 1 1 4 7 0 3 8 7 
BobToAlice = 
Append [Mod [ BobData , p] + { O ,  O ,  0 ,  O ,  O ,  O ,  0 ,  O ,  O ,  1 ,  1 } , p ]  
{ 4 4 3 7 2 7 1 0 3 8 6 0 5 1 3 9 5 4 3 9 9 1 3 9 3 8 9 2 4 ५ 7 0 04 5 6 7 5 2 9 7 4 6 5 7 2 6 8 7 6 6 4 3 2 6 8 3 3 8 ६ 
5 0 1 8 3 5 3 4 4 4 5 6 8 2 3 2 1 5 6 8 5 6 4 4 5 9 7 6 1 ७ 6 0 3 4 5 5 8 6 5 5 5 9 6 6 3 1 3 1 6 2 3 3 0 4 5 1 2 2 2 Ȼ  
3 3 5 5 9 3 1 1 1 4 8 0 8 0 8 5 9 0 1 0 3 2 9 6 6 2 4 6 3 Ȼ  6 3 7 6 2 4 8 5 1 3 1 6 4 2 3 8 0 4 4 6 6 9 4 1 0 1 6 5 2 ८ 
4 4 0 7 6 8 9 5 3 4 1 2 0 4 2 7 6 6 0 8 9 6 1 8 1 0 0 4 6 3, 1 3 7 0 7 8 1 5 6 4 3 7 0 2 1 9 0 6 0 3 2 3 4 3 6 94 0 3 2, 
4 4 8 8 4 2 5 2 7 5 4 9 4 4 1 3 4 2 4 9 9 9 9 4 0 5 7 6 8 0, 6 8 5 0 1 5 4 2 5 6 4 0 7 8 8 6 2 9 2 9 4 5 9 4 3 4 8 7 4 1, 
6 0 1 7 9 2 0 2 7 3 3 5 3 8 5 4 4 1 5 5 1 5 2 2 3 5 8 0 6 3, 7 0 3 0 2 5 4 4 3 2 4 7 1 3 5 2 9 8 0 2 4 0 1 1 4 7 0 3 8 7} 
Mod [Al iceRandom , p] 
6 3 7 6 2 4 8 5 1 3 1 6 4 2 3 8 0 4 4 6 6 9 4 1 0 1 6 52 7  

1 58 
5. SOME APPLICATIONS 
Alice checks to see if her original random number, modulo p, is on this list. 
If it is, she knows that Bob did not add 1 to the corresponding encrypted 
version, and therefore her salary is less than or equal to Bob's; otherwise 
her salary is higher. In our example, the 6376 ... 527 is on the list Alice sees, 
so she knows Bob's salary is $65,000 or greater. 
There are some flaws with this protocol! 
• Alice or Bob could claim a false salary. There is no way around this 
problem; we simply assume that the intent to discover the truth is 
sincere or that an attempt to deceive would be found out at some 
future date. 
• Alice learns the answer first. She can then refuse to tell Bob the 
result, or lie about it. 
• If the protocol should lead to two identical numbers (or a zero) in the 
list that Bob returns to Alice, Alice can get some information she is 
not supposed to. Bob can easily avoid this problem. See Exercise 5.10. 
Protocols similar to this have diverse applications, to electronic auctions, 
secure voting, contract signing by e-mail, and the like; see [Schn]. 
Exercise for Section 5.2 
5.10. In the Yao millionaire protocol, it could happen that two of the num­
bers Bob produces and is planning to ship back to Alice differ by one. Why 
is this bad? What can be done to avoid this problem? 
5.3 Check Digits 
¨ Basic Check Digit Schemes 
The most common typing errors are single-digit errors, where an incorrect 
character is entered, and transposition errors, where a pair of adjacent, 
characters are switched. Thus a classical problem is to attach an additional 
character to a data string, called a check digit and denoted c in this chap­
ter, in the hope that its presence can help a computer detect errors, with 
special emphasis on the two most common errors. 
A very simple scheme, which is currently used by the U.S. Postal Ser­
vice on its money orders, is to simply take the raw number and let c be its 
mod-9 remainder. For example, if the raw number is 19023687, then c = 0 
and the official number of the object would be taken to be 190236870. If one 
erroneously enters 190246870, the check digit won't check, because 0 is no 
longer the mod-9 value of the rest, and a computer can detect this. The 
origin of this method is probably the traditional folk method, called "casting 
out nines," where one repeatedly sums digits until a single digit remains, 

5.3. CH ECK DIG ITS 
1 59 
replacing 9s by 0 (these are the same modulo 9) to check arithmetic opera­
tions (see Exercise 5.11). 
This method is certainly simple enough, but it has several problems. It 
fails to catch the error caused by the typing of a 9 instead of a 0, or vice 
versa, because such errors leave the mod-9 value unchanged. Worse, trans­
positions have no effect on the mod-9 value at all, so the method fails to 
detect any transposition errors (with the exception of transpositions involv­
ing c; these are detected). Of course, the reader may have already noticed 
that the mod-9 method is inefficient in the sense that c can never be 9, and 
so a potential check digit is wasted. But it turns out that even using a 
mod-7 system (in which c is never 7, 8, or 9) is far better than the mod-9 
system, as we now show. This method is used on airline tickets. 
Proposition 5.1. If a raw identification number has nine digits and a 
check digit c is taken to be the mod-7 residue of the raw number, then the 
single-digit-error correction rate is 93.81 % and the transposition error 
correction rate is 93.87%. 
Proof. The number of possible errors in the nine leftmost positions are (9 
positions) (10 possible digits) (9 possible wrong digits), or 810. Of these, 
errors of the form 7 tt 0, 8 tt 1, or 9 tt 2 will not be caught. Thus the suc­
cess rate is (9 · 84)/ 810. For the check position, there are no failures because 
the correct digit can never by 7, 8, or 9. Thus, the overall single-digit correc­
tion rate is (9 · 84 + 63)/(810 + 63), or (756 + 63)/(810 + 63), or 93.81%. 
Transposition errors of the form 70 tt 07, 81 tt 18, or 92 tt 29 are 
undetected, but not all of these can occur in situations involving the check 
digit. There are nine possible transposition positions. For each of the left­
most eight, there are 90 possible transpositions, and 84 are caught; thus 
the rate is (8 · 84) I (8 · 90). For the rightmost two digits there are 3 · 7 + 7 · 6 
possible errors and all are caught. Thus, the overall rate is (8 · 84 + 63) I 
(8 · 90 + 63), or 93.87%. 
D 
Of course, we can perform much more complex caclulations than a 
single modular reduction, and there are methods that take advantage of 
that fact. The 3-weight method is used by banks: if the raw number is 
a1 a2 a3 a4 a5asa1 as , then the check digit is the dot product: 
We leave the computation of the success rate to Exercise 5.12. A widely 
used scheme that was first developed by IBM comes tantalizingly close to 
being perfect: it catches all the single-digit errors and misses only the 
transposition error 9 tt 0. Here are the details. The method takes, say, a 13-
digit number a1 a2 . • .  a13 and defines the check digit to be 
-(a1 , a2 , . . .  , aia ) · (2, 1, 2, 1, 2, 1, ... , 1, 2)-r (mod 10) 

1 60 
5. SOM E APPLICATIONS 
where r is the number of the odd-indexed digits a1 , a3, a5, • • •  , a13 that are 
greater than 5. Complicated! But it is in some sense the best possible 
because, as we now prove, no scheme that uses ordinary modular arith­
metic can catch all single-digit errors and all transposition errors. There is 
a perfect scheme in base 11 (Exercise 5. 13), but the fact that "10" can show 
up as a check digit is a big drawback. 
Theorem 5.2. There is no perfect check-digit scheme based on mod-10 
addition. 
Proof. Suppose that we had such a system, where c was computed by a 
mod-10 sum of values derived from each of the digits. Because diferent 
functions can be used in different positions, let <Ti : Z10 -+ Z10 be the func­
tion for the ith digit. Then digit d in position i contributes <Ti(d) to the 
determination of c. To catch all single-digit errors, it must be that each er; is 
a permutation of {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}. To catch all transpositions in the 
first two positions, we must have that cr1 (a) + cr2 (b) * cr2 (a) + cri (b) (mod 10), 
which means that x 1-+ Mod[cr2(x) - cr1 (x), 10] is a permutation of Z10• This 
leads to a contradiction as follows, where = is modulo 10. 
5 = 45 
= 0 + 1 + 2  + · · ·  + 9 5 <T2(0) - CT1(0) + <T2(l) - CT1 (l) + ... + CT2(9) - <T1(9) 
= CT2(0) + CT2(1) + ... + CT2(9) - CT1 (0) - cri (l) - ... - cri (9) 
= 45 - 45 = 0 
D 
1!J A Perfect Check Digit Method 
A group is a set of objects together with an associative operation, often 
called multiplication but sometimes called addition, that takes pairs of 
objects to a third object in the set. The group axioms require that there 
should be an identity (an element that leaves other elements unchanged 
under multiplication) and that each element should have an inverse, multi­
plication by which yields the identity. For example, {O, 1, 2, 3, 4, 5, 6, 7, 8, 9} 
forms a group under modular addition: 0 is the identity, and the inverse of 
a is Mod[-a, 10]; this group is called Z10. 
There is only one other group with ten elements: the group of symme­
tries of a regular pentagon, with two such symmetries yielding a third by 
first applying one and then the other. To be more precise, multiplication 
CT0T is the symmetry of the pentagon defined by taking each vertex A to 
T(A) and this, in turn, to cr(T(A)). It is easy to check that this is a group; in 
fact, there are two types of symmetries: the five rotations (0°, 72°, 144°, 
216°, 288°) and the five reflections about perpendiculars from vertices to 
opposite sides. This group is an example of a dihedral group, and is de­
noted Ds. 
Now - and this fairly brilliant observation is due to J. Verhoeff in 1969 
- we can use the ten symmetries to encode the ten digits by using the 

5.3. CH ECK DIG ITS 
1 61 
identity for 0, the rotations, in order, for 1, 2, 3, and 4, and the reflections 
for 5-9 (see Figure 5.1). 
B 
c 
A 
D 
E 
Figure 5.1. The five diagonals of a pentagon and their corresponding digits. 
Here is the full multiplication table. Note that, unlike Z10, D5 is not 
commutative: for example, 803 = 5 while 308 = 6. However, the rotations 
are commutaive so ioj = joi if O :s; i, j :s; 4. 
0 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
0 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
1 
1 
2 
3 
4 
0 
6 
7 
8 
9 
5 
2 
2 
3 
4 
0 
1 
7 
8 
9 
5 
6 
3 
3 
4 
0 
1 
2 
8 
9 
5 
6 
7 
4 
4 
0 
1 
2 
3 
9 
5 
6 
7 
8 
5 
5 
9 
8 
7 
6 
0 
4 
3 
2 
1 
6 
6 
5 
9 
8 
7 
1 
0 
4 
3 
2 
7 
7 
6 
5 
9 
8 
2 
1 
0 
4 
3 
8 
8 
7 
6 
5 
9 
3 
2 
1 
0 
4 
9 
9 
8 
7 
6 
5 
4 
3 
2 
1 
0 
Now let er be the permutation of digits that acts as follows: er switches 1 
and 4, and also 2 and 3, and er cyclically permutes 5, 8, 6, 9, 7; 0 is 
unmoved. One can summarize cr's behavior by 
5-+8-+6-+9-+7-+5 . 
A more concise notation is to just list the cycles: er = (0)(14)(23)(58697). 
Given an integer n, such as 1793, Verhoeffs method performs the 
following operation: 

1 62 
5. SOM E  APPLICATIONS 
Use the multiplication table and the definition of er and you will see the 
result is 1060502, or 4. But we are not finished. The final step is to take the 
inverse in D5 of the previous result. The inverse of 4 is 1 (because 1°4 = 0, 
or because four rotations followed by one rotation is the same as five rota­
tions, or doing nothing), so the check digit is 1. In general, if abc 
. • .  z denotes 
an n-digit number, c is chosen to be the inverse of <rn(a)ocrn-1 (b)o ... ocr(z). 
As we shall show in a moment, this check digit scheme is perfect: it 
catches all single-digit errors and all transposition errors. Some investiga­
tors had predicted that such a perfect scheme could not exist! Well, it does, 
and it is used to add a check-digit to the serial numbers of German 
currency. 
Theorem 5.3. The check-digit scheme based on the symmetries of the 
pentagon catches all single-digit errors and all transposition errors. 
Proof. We will need the following property of er, which Exercise 5.16 asks 
you to verify: cr(a)o b  * cr(b)oa whenever a *  b. Now observe that, because of 
the inverse used in the last step of the check digit's definition, if c is the 
check digit of an n-digit number abc ... z, then <rn(a)ocrn-l (b)o· · · ocr(z)oc = 0. 
Now suppose -a-c is mistyped as -b-c, where - represents any digit 
sequence, and the possibility that the error involves c itself is allowed. If 
the check digit test is passed, then wocri(a)oz would equal wocri(b)oz, and 
cancellation in the group yields a = b, contradicting the assumption that an 
actual error was made. 
For transpositions, suppose -ab-c is mistyped -ba-c, and the check 
digit test is passed. Then wocri+l(a)ocri(b)oz would equal wocri+1 (b)ocri(a)oz, 
where w and z are the contributions left and right of the error, respectively. 
Cancellation yields cri+1 (a)ocri(b) = cri+1 (b)ocri(a), which can be rewritten as 
cr(cri(a))ocr(cri(b)) = cr(cri(b))ocr(cri(a)). This contradicts the property of er that 
started this proof, unless a = b. 
o 
 Beyond Perfection: Correcting Errors 
In a remarkable 1978 paper, A. S. Sethi, V. Rajaraman, and P. S. Kenjale of 
India [SRK] described a scheme by which check digits can be used to correct 
any single-digit error or transposition error. This is much stronger than the 
dihedral and other schemes, which merely detect errors. The theory of error­
correcting codes has a long history, and, in fact, some schemes that allowed 
a certain amount of error-correction via check digits have been in use for 
some time. For example, the abstracts published by the American Chemical 
Society had used such a scheme for several years, though it now uses a 
different method. But the SRK scheme is noteworthy in that it detects and 
corrects all single-digit and transposition errors. Such an improvement 
comes at a cost: their schemes work only for certain bases, and require the 

5.3. CHECK DIG ITS 
1 63 
use of two check characters. In this section we will describe their base-37 
scheme, which allows the use of two check characters for strings made up of 
digits and the letters A, B, C, ... , Z. 
Let p be 37, the first prime beyond 36. Then the SRK method would use 
the elements of Z37 to denote, in order, the characters "O", "l", "2", ... , "9", 
"A", "B", "C", "D", . . . , "X", "Y'', "Z", "-". So the scheme can be used to add 
check digits to strings such as "123A-459WZ". It is a little weird to allow 
the hyphen to occur as a check digit, and a computer implementation might 
wish to disallow numbers that lead to such a thing. 
Their system uses modular arithmetic in a familiar way, but with two 
check digits. Thus a raw string a1a2 .. · ak will be enhanced to A
= 
a1 a2 . .  · akak+1ak+2 ·  It turns out that there are restrictions on k. We shall see 
why, in the case at hand, the SRK method leads to k s 11. 
The basic definition of the check digits is simple. We will find two sets 
of weights W = {wd and V = {ud, and then choose ak+l and ak+2 to satisfy 
the following two congruences, where n = k + 2. 
n 2.: Wi ai = 0 (mod p) 
i=l 
n 
(1) 
2.: vi ai = 0 (mod p) 
i=l 
Finding the two check digits will be simple because they satisfy two linear 
equations in two unknowns: Wk+l ak+l + Wk+2 ak+2 = r and Vk+1 ak+1 + 
Vk+2 ak+2 = r1 • The weights will be chosen so that the corresponding 2 x 2 
determinant is not divisible by p - conditon C3 in the list that follows -
and so the system will have a unique rational solution with denominators 
not divisible by p. Such rationals yield a solution in integers between 0 and 
p by using the mod-p inverse of the denominators. 
Note that condition (1) can also be interpreted as W · A =  V · A =  0 (mod 
p), where · is the standard dot product. 
The key to the method is to find weights W and V that satisfy the 
following five conditions, where i and j are assumed to be distinct. 
C1 : 1 s; vi, w; < p for i = 1, 2, . . .  , n. 
C2: The W-values are distinct, as are the V-values. 
C3: v; Wj '!/= wi Vj (mod p) for i = 1, 2, ... , n and j = 1, 2, . . .  , n. 
C4: (vi+1 - Vj)(Wj+1 - Wj) '!/= (Wi+1 - wj}(Vj+1 - Vj) (mod p) for 
i = 1, 2, . . .  , n - 1 and j = 1, 2, . . .  , n - 1. 
C5: (wi - Wi+d Vj '!/= (vi - vi+dWj (mod p) for i = 1, 2, . . .  , n and 
j = 1, 2, . . .  , n. 

1 64 
5. SOM E  APPLICATIONS 
How can we find appropriate weights? One of the two methods in [SRK] 
is to let a be a positive integer less than p - n and let Wi = i + a and 
vi = i(i + a) (both reduced modulo p) for i = 1, ... , n. C1 is then clear, as is C2 
for the case of W. For V, we want (i + a)i $ (j + a)j which simplifies to 
(i - j)(i + j + a) $ 0. The first factor is not divisible by p because of the 
bounds on i and j. The second factor will be nonzero (mod p) provided 
i + j + a  < p, which holds if n + (n - 1) + a < p, or 
2 n + a < p + l . 
(2) 
Conditions C3 and C4 follow directly from the definitions: C3 reduces to 
(a + i)(i - j)(a + j) $ 0 which follows from the boundary conditions on a, i, 
and j, and C4 is similar. And C5 reduces to 
U + a)(2 i - j + a +  1) 'f= 0 (mod p) . 
But note that j + a is never divisible by p because 1 s a < p - n. So the 
condition reduces to 
2 i - j + a +  1 'f: 0 (mod p)
. 
To get this condition, it suffices to choose a and n so that 
0 <  2 i - j + a + l < p. Because i s n, j s n, and i -:F j, the upper bound will 
hold if 2 n + a  < p + 2. But this will follow from condition (2). For the lower 
bound, let i = 1 and j = n, the extreme values. We want 0 < 2 - n + a +  1 or 
n < a +  3. This will hold, and n will be maximized, if we let a = n - 2. 
So now we see how to get the weights and appropriate values of a and 
n. For n, condition (2) leads to 2 n + a s p, which becomes, using a = n - 2, 
3 n - 2 s p or n s L(p + 2)/3J. In our case p is 37, so n can be 13 and a is 1 1. 
Then the weights are as follows. 
p : 37 i D = 13 i a =  D - 2 i 
W = Table [Mod [ i + a , p] , { i , 1 ,  n} ] 
v = Table [Mod [ i  ( i  + a) ,  p] , { i , 1 ,  n } ] 
{ 1 2 , 1 3 , 1 4 , 1 5 ,  1 6 ,  1 7 , 1 8 , 1 9 , 2 0 , 2 1 , 2 2 , 2 3 , 2 4 }  
{ 1 2 , 2 6 , 5 , 2 3 , 6 ,  2 8 ,  1 5 ,  4 ,  32 , 2 5 , 2 0 ,  1 7 , 1 6 } 
Now let us see how the five conditions lead to error detection and 
correction. Given a string A, let 81 and 82 denote the two "check-sums" for 
A, as given by formula (1). All congruences in the paragraphs that follow 
are modulo 37. First observe that, because of C1 and C2, any single-digit 
error or transposition error leads to values of 81 and 82 that are both 
nonzero (Exercise 5.19). 
Let A denote the string entered and suppose a single-digit error was 
made, say d became e in position i. Then the two check-sums for A would 
satisfy 81 = (e - d) Wi and 82 = (e - d) Vi , respectively (since each check-sum 
is 0 for the errorless string). Cross-multiplying and using the primality of 

5.3. CH ECK DIG ITS 
1 65 
37 to cancel e - d  leads to S1 u; = S2w;. Now, for any j * i, S1 vj 1' 82Wj, for 
otherwise S1 u;S2wj = S; vjS2w; in which we can cancel the S's (they are 
both nonzero modulo p) and get a contradiction to condition (3). So in this 
case there is a unique value of i such that 81 u; = S2w;. A computer can find 
such an i - that is, locate the position of the error - and then compute the 
correct digit by finding which value of d leads to 81 = (e - d)w; . The correct 
digit is simply e - 81 w;1 , using the mod-37 inverse. 
A similar argument using C4 shows how transposition errors can be 
detected; the critical equation is 81 (u;+1 - u;) = S2(Wi+i - w;). Note that for 
transposition errors correction is trivial once the location of the error is 
known. Finally, we must be sure that the computation never confuses a 
single-digit error with a transposition error, and that is what C5 
accomplishes. 
The implementation of the SRK error-correction scheme is left as an 
exercise (Exercises 5.22 and 23). All of us are quite used to having comput­
ers beep when an error of some sort is made at the keyboard; having the 
computer correct the error is much more impressive. An implementation is 
included in the CNT package. Here is an example, where the input string 
has the right number of letters, 11, for the parameters of this section 
SRKProtect [ " PAIHT'rBECAR" ] 
PAINTTHECARRN 
SRKCorrect [ " PAIHT'rBECA'rRN " ]  
PAINTTHECARRN 
SRKCorrect [ " PARI'r'rBECARN" ] 
PAINTTHECARRN 
A second method of finding the weights is given in [SRK]; it is a little 
better than the method presented here because it allows the protected 
string can be as long as 18 characters, as opposed to 13. 
Exercises for Section 5.3 
5.11. Show that summing the digits of an integer, summing the digits of 
the result, and continuing until only a single digit remains leaves the 
remainder modulo 9 of the original number (provided one replaces a final 9 
with a O). 
5.12. What are the single-digit and transposition success rates for the 3-
weight method that uses the mod-10 dot product (7, 3, 9, 7, 3, 9, 7, 3) - (a1 , 
a2 , aa, a4 , a5 , a5 , a1 , as )? 
5.13. The scheme used in ISBN numbers (International Standard Book 
Numbers, which are used to register every book with a number) is perfect 
in the sense that all single-digit and transposition errors are caught. It uses 
base-11 arithmetic, with an X used to represent 10 in base 11. Thus, it is 

1 66 
5. SOM E  APPLICATIONS 
not a purely numeric scheme, which can cause programming and other 
dificulties. Show that the method is perfect. The raw ID number has 9 
digits (the leading digit codes the language, the next four code the pub­
lisher, and the next four identify the book). Given such an ID number 
a1a2 
• • •  a9, the check digit c is computed so that 10a1 + 9a2 + 8a3 + · · ·  + 
3a8 + 2a9 + c = 0 (mod 11); if c ends up being 10, then X is used as the 
check digit. 
5.14. Prove that the IBM check digit scheme catches all single-digit errors 
and all transposition errors except 9 +.. 0. 
5.15. Implement a routine that creates random single-digit or random 
transposition errors and then run a simulation to see if the success rate of a 
particular check-digit scheme matches the rates predicted in this section 
and earlier exercises. 
5.16. Verify that the permutation er of Theorem 5.3 satisfies the critical 
property: cr(a)ob -:f:. cr(b)oa whenever a -:f:. b. 
5.1 7. Find some other permutations of 0, 1, 2, 3, ... , 9 that have the same 
critical property of u? Why is it preferable to use a permutation that leaves 
0 unchanged? 
5.18. Write a computer program that takes any integer and appends the 
check digit as defined by Verhoeffs pentagonal scheme. 
5.19. Show that a single-digit or transposition error in a string that is 
protected by the SRK scheme leads to nonzero values for both check sums 
in (1). 
5.20. Show how condition C4 in the SRK scheme allows the method to 
detect and correct a transposition error. 
5.21. Show how condition C5 in the SRK scheme guarantees that the 
equations governing the detection of a single-digit or transposition error 
will never clash with each other. In other words, show that the SRK proto­
col will always be successful in detecting the type of an error, provided only 
one error is made. 
5.22. Implement a routine that accepts an 11-character string using the 
characters "O", "l", "2", ... ,"9", "A", "B", "C", "D", ... ,"X", ''Y'', "Z", "-" and 
computes the two check digits according to the SRK scheme. Short inputs 
should be padded with Os on the left. The Mathematica code that follows 
shows how to turn a string into a list of codes between 0 and 37, and vice 
versa. 
ToSRKinteger [ s_String] : =  (c = First [ToCbaracterCode [ s ] ] - 55 1 
Wbicb [c > 9 , c ,  - 8 < c < 3 , c + 7 , c == - 10 ,  3 6 ] ) / 1  
StringLengtb [ s ]  = =  1 
ToSRKinteger [ s_String] : = Map [ToSRKinteger , Characters [ s ] ] 

5.4. FACTORING ALGORITH M S  
1 67 
FromSRKinteger [n_Integer] : = (Which [ 
D < 10 , ToString [ D ]  , 
9 < n < 3 6 , FromCharacterCode [n + 5 5 ]  , 
D = =  3 6 , " - " ) )  
FromSRKinteger [ s_Li st ] 
: =  Apply [StringJoin , 
Map [ FromSRKinteger, s ] ] 
ToSRKinteger [ "ABC-0123X-2Z " ]  
{ 1 0 ,  1 1 ,  1 2 , 3 6 , O ,  1 ,  2 ,  3 ,  33 , 36 , 2 ,  3 5 } 
FromSRKinteger [ { lO , 11 , 12 , 36 , O ,  1 ,  2 ,  3 ,  33 , 36 , 2 ,  3 5 } ] 
ABC - 0 1 2 3X - 2 Z  
5.23. Implement a routine that accepts a 13-character string using "O", "1", 
"2", . . .  , "9", "A", "B", "C", "D", . . .  ,"X", "Y'', "Z", 
"-" and checks to see if the 
two rightmost characters are the proper SRK check digits. If they are not, 
then the scheme checks to see if one single-digit error or one transposition 
error has been made, in which case it returns the correct string. 
5.4 Factoring Algorithms 
The use of large numbers in cryptography brought the problem of factoring 
large integers to the forefront of computational number theory. Faced with 
a large integer to be factored, our first task is to determine whether or not 
it is probably prime. If, in fact, it is composite, this will almost certainly be 
revealed by a pseudoprime or strong pseudoprime test. Knowing that our 
integer is composite, what comes next? Indeed, the factoring problem is 
difficult in part because, aside from trial division, there is no obvious way to 
proceed. The reader may find it surprising that there is no single algorithm 
that one always uses for factoring whatever integer is presented. The choice 
of algorithm is heavily dependent on the size of the integer and on what 
else is known about it. 
ȫ Trial Division 
The best place to start is with simple trial division. Using a list of primes 
generated by the sieve of Eratosthenes, one simply checks if they divide the 
integer in question. 
Algorithm 5 . 1 . Factorization by Trial Division 
This algorithm attempts to factor n by trial division by all primes less than 
or equal to m. The parameter u tracks the unfactored portion that remains. 

1 68 
5. SOME APPLICATIONS 
If at any point, u is less than the square of the prime we are about to trial 
divide, then we know that u is prime. If we finish trial division with an 
unfactored u larger than 1, then this algorithm runs a 2-strong pseudo­
prime test to see if the unfactored piece is probably prime. It returns the 
value of u and the truth value of the strong pseudoprime test. 
TrialDi vide [ n_, m_] : = Module [ { u = n ,  ans = { } }  , 
Scan [ 
( I f [u < 1 2 , If [u > 1 ,  AppendTo [ ans , { u ,  l } ] ] ;  u =  l ;  Return [ ] ] ;  
I f [Mod [ u ,  I ] = =  0 ,  j = O ;  Wbile [Mod [u ,  I ] = =  0 ,  u / = I ;  j + + ] ; 
AppendTo [ans , { I ,  j } ] ] ) & , Prime [ Range [zr [m] ] ] ] ; 
I f  [u = =  1 ,  ans , 
Append [ ans , { u ,  Si;rongPseudoprimeO [ 2 , u] I . 
{ False -+ "Composite " ,  'l!rue -+ " Probably Prime " } } ] ] ]  
'l!ria1Divide [ 2686632685 14419 , 10000 ] 
{ { 54 1 ,  1 } ,  { 7 919 , 3 } } 
Tria1Divide [ 2686632685 14419 , 1000 ] 
{ { 54 1 ,  1 } , { 4 9 660493 2 5 5 9 , Composite } }  
No algorithm is as efficient as trial division for finding small prime 
factors (though one can improve efficiency by using gcds of the input with 
the precomputed products of several small primes at once). On the other 
hand, even with fast computers, this algorithm is impractical for finding 
factors larger than 10 7 • 
The beauty of this algorithm is that if you know you have a prime 
divisor of a given size, you know exactly how long it will take to find that 
divisor. This is what we mean by "completely deterministic". All the power­
ful factoring algorithms rely on a certain random element so that luck 
begins to play a role. If there is a prime divisor of a given size, we can 
predict how long the algorithm will run on average, but we cannot be 
certain that we will not run considerably over that time. These 
"probabilistic" algorithms also share the characteristic that they are not 
always guaranteed to find a prime divisor. All they will do for you is to 
break your integer into a product of two smaller integers. You then have to 
test each of these factors for probable primality and, if they are shown to be 
composite, run them through again until they have been reduced to a 
product of probable primes. 
The probabilistic algorithms come in two broad categories. The first 
category consists of those algorithms that are most likely to find the 
smallest prime divisor. Their running time is more dependent on the size of 
the smallest prime divisor than on the size of the integer that one wants to 
factor. Such algorithms include Pollard rho, which was used to factor the 
Fermat number Fs, Pollard p - 1, Williams p + 1, and the elliptic curve 
method, which was used on F10 and F11 •  These are simple, fast algorithms 
that can be effective when there is a prime divisor having between 7 and 40 

5.4. FACTORING ALGORITHM S  
1 69 
digits. They are extremely effective at finding divisors of less than 20 digits. 
They should always be used as the second line of attack. 
If you want to factor an integer of 100 or more digits and you are not 
getting anywhere with first category algorithms, then you need to move to 
the second category, also known as the Kraitchik family, after the 
number theorist Maurice Kraitchik (1882-1957). Let n be the integer that 
you want to factor. All of these second category algorithms rest on the 
search for "randomly generated" pairs of integers (a, b) such that 
a2 = b2 (mod n). This implies that n divides a2 - b2 = (a - b)(a + b). If p and 
q are distinct primes that divide n and if (a, b) is really chosen at random, 
then we have a 50% chance that gcd(n, a - b) is divisible by one of these 
primes and not the other. In other words, there is at least a 50% chance 
that gcd(n, a - b) is a nontrivial divisor of n. 
All the algorithms of the Kraitchik family are complicated, and one 
draws no benefit from the existence of small prime divisors of n. Their 
running time is essentially independent of the size of the smallest prime 
factor and depends only on the size of n. This is why they should not be 
used until after trial division and first category algorithms have been 
pushed as far as possible. On the other hand, they draw no disadvantage 
from the fact that all of the prime divisors are large and therefore these 
algorithms are ideally suited to finding factorizations when there are no 
small prime divisors. From this family, the continued fraction algorithm 
was used to crack F7 • The Lenstra and Manasse factorization of a 100-digit 
integer used the multiple polynomial quadratic sieve. Fg fell to the number 
field sieve. At present, these methods reach their practical limitations for 
general integers that are difficult to factor when n has about 130 digits. The 
method of this type that we shall discuss is the continued fraction method, 
but that must wait until Section 7.6. 
¬ Fermat's Algorithm 
Trial division is not the only completely deterministic algorithm available. 
Fermat discovered an algorithm that he prized which, instead of starting 
with small primes and working up, begins by looking for divisors near the 
square root and works down. One of its great advantages is that it involves 
no division, except for division by 2 at the end. 
The idea is as follows. If n is odd and composite, n = ab, then 
x = (a +  b)/2 and y = (a - b)/2 are integers and 
n = ab = (x + y)(x - y) = x2 - y2 • 
On the other hand, if we can write n as the difference of two squares, 
n = x2 - y2, then this yields a factorization of n as (x - y) (x + y). 
The algorithm proceeds by starting with x = f Fnl and y = 0. A fast 
algorithm for finding l Vn J is given in Exercise 5.24. Then each cycle incre­
ments x or y by 1 until we find the first pair of values for which n = x2 - y2 • 
If x2 - y2 > n, then we want to increase y by 1. If x2 - y2 < n, then we 

1 70 
5. SOM E APPLICATIONS 
increase x by 1. We can further streamline this algorithm if we just keep 
track of 
r = x2 - y2 - n, 
u = 2x + 1, and 
v = 2y + 1 .  
The variable u tracks the amount by which we increase r when x is 
increased; v does the same for an increase in y. When r = 0, we know that 
( u - v )( u + v - 2 ) 
n = (x - y)(x + y) =  -2-
2 
. 
Algorithm 5 . 2 .  
Fermat's Factorization Algorithm 
This algorithm takes an odd composite n and returns a pair of integers 
whose product is n and that are as close as possible to {1i .  The SqrtFloor 
function is discussed in Exercise 5.24, though one could simply use Floor [ 
Sqrt [ ] ] . The I f  statement near the end is adequate, as opposed to Whi le, 
because it will always take only one upward u-step to make r positive 
(because u > v). 
SqrtFloor [ n_] : = Module [ { a = n ,  b = Quotient [n + 1 ,  2 ] } ,  
While [ b < a , a = b ; b = Quotient [ a2 + n , 2 a] ] ;  a] 
FermatFactor [ n_? OddQ] : =  
Module [ { s  = SqrtFloor [n] + 1 ,  r ,  u ,  v = 1 } , 
I f  [ ( s - 1 )  2 = = n , Return [ { s - 1 ,  s - 1 }  ] ] ; 
{ r ,  u} = { s2 - n , 2 s + l } ;  
While [ r  ¢ O ,  
While [ r > O , r -= v ; v + = 2 ] ; I f [ r < O , r + = u ; u + = 2 ] ] ;  
{ u - v , u + v - 2 } / 2 ]  
FermatFactor [ 2027 651281] 
{ 4 4 0 2 1 , 4 6 06 1 } 
 Pollard Rho 
In 1974-75, J. M. Pollard published the first two category-I factorization 
algorithms, what today we know as Pollard p - 1  and Pollard rho. 
Despite its age, the second is still popular for finding prime divisors in the 
range of 7 to 20 digits. Pollard p - 1 is seldom used anymore, but it illumi­
nates the theoretical foundation for the elliptic curve method. 
Pollard called his second algorithm the Monte Carlo method. It is based 
on the birthday paradox, that given 23 randomly selected people, there is 

5.4. FACTORING ALGORITH MS 
1 71 
better than a 50-50 chance that at least two of them share the same birth­
day. In general, if we perform slightly more than Yn selections with replace­
ment from a set of n elements, we have better than a 50-50 chance of 
picking some element twice (Exercise 5.29). 
Let n be the composite integer for which we want to find a proper 
divisor. In the Pollard rho algorithm, we begin with a randomly chosen seed 
s, and generate the sequence 
So = S 
si = sL + 1 (mod n), 1 s si < n .  
As an example, let n be 59153 and let the seed s be 24712. The sequence 
that we get is 
D = 5 915 3 ; 
s [ O ]  = 247 12 ; 
s [ i_] : =  Mod [ s [ i - 1 ] 2 + 1 ,  n] 
Map [ s ,  Range [ 15 ] ] 
{ 4 6 5 2 6 , 2 3 7 9 5 , 4 8 6 6 3 , 1552 1 ,  30426 , 5 6 18 0 ,  2 4 9 3 3 , 
1 5 6 1 3 , 5 5 4 1 0 , 4 9 9 4 2 , 1 7 1 2 0 ,  50439 , 40498 , 1 1 927 ' 4 9 5 1 8 } 
This is an apparently random sequence of integers in (0, 59152]. 
Unbeknownst to us, 149 is a prime divisor of 59153. Modulo 149, this 
sequence looks like 
Function'l'able [Mod [ s [ I ] , 149 ] & ,  15 , 
FunctionBeading -+ " s  (n) 
(mod 149 ) " , Columns -+ 4 ]  
n s(n) (mod 149) n s(n) (mod 149) 
n s(n) (mod 149) 
n 
1 
38 
5 
30 
9 
131 
1 3  
2 
104 
6 
7 
10 
27 
14 
3 
89 
7 
50 
1 1  
134 
15 
4 
25 
8 
117 
12 
77 
16 
s(n) (mod 149) 
1 19 
7 
50 
1 1 7  
We see that S14 is the same as S5 . Because each si is completely determined 
by the previous value, once we get a repetition we enter a never-ending 
cycle, in this case a cycle of length 8. We can visualize what is happening as 
a circle with a tail: s1 -ss are on the tail. In other words, it looks like the 
Greek letter p, spelled rho (see Figure 5.1). 
If we now go back to what we do know, the sequence as it appears 
modulo 59153, and we take any i > 5, then 149 divides S;+s - Si . Fortunately 
397, which is the other factor of 59153 does not divide S;+s - Si . This means 
that gcd(s14 - s6, 59153) = gcd(11927 - 56180, 59153) = 149. 

1 72 
5. SOM E  APPLICATIONS 
Figure 5.1. The Pollard sequence has a tail and a loop, and so may be viewed as a 
Greek rho. 
Of course, we do not know that the correct cycle length is 8, nor that we 
must take i > 5. But we can expect that if there is a divisor around size m 
then the cycle length and tail length will be around 0.59Vm. Once we have 
roughly 1.18Vm values of Si , the probability that they are distinct modulo 
m drops below 50% (see Exercise 5.30), so we can expect that it will take 
about 1.18Vm iterations before we get a residue, modulo m, that has 
appeared before. Since all of the residues that have appeared are, in theory, 
equally likely to be the first to repeat, the expected position of the first 
residue to repeat is at the midpoint. We try all possible cycle lengths until 
we find one that works and take the tail length close to the cycle length. It 
does not really matter if we try what turns out to be the correct cycle length 
while we are still on the tail because any multiple of that cycle length will 
also work. 
The version that we describe below is due to Brent. It considers the 
differences: 
s, - 83 ,  
83 - Ss ,  83 - 87, 
87 - 8 12 , S7 - 813 ,  87 - S14 , S7 - 81 5 , 

5.4. FACTORING ALGORITHMS 
1 73 
Warning. You should only use category-1 or category-2 algorithms such as 
Pollard rho after a pseudoprime test has confirmed that the integer in 
question is composite. In general, a prime input will either prevent the 
algorithm from terminating or will produce an otherwise inconclusive 
response. 
Algorithm 5 . 3 .  Pollard Rho 
This version of Pollard rho computes the gcd after each step. Exercise 5.31 
asks you to speed it up by computing the gcd only after ten differences have 
been collected. The use of max_ : 1 0 0 0 0  is a way of assigning a default 
value to max, which is the maximum number of terms of the sequence. 
$Failed is a system variable that is often used to indicate failure, so we 
use it here. 
PollardRho : : maxtrm = 
" 'l!be number of terms of the Pollard sequence 
bas exceeded its maximum with no repeats . " ;  
PollardRho : : allfac = "'l!be potential gcd equals 
' ' ,
and so a factor bas not been identified . " ;  
PollardRho [ n_, max_ : 10000 ] : =  
Module [ { s = Random [ Integer , { l ,  n - 1 } ] , g = l , t ,  range = l , 
prod = 1 ,  terms = 0 ,  bf = BoldForm [ PollardRho [ n ,  max ] ] } , 
t = Mod [ s2 + 1 , n] ; 
While [ terms s max && g == 1 ,  
Do [ t  = Mod [ t2 + 1 ,  n ]  ; prod = Mod [prod * ( s  - t )  , n] ; 
terms + + ; g = GCD [ n ,  prod] ; I f [g > 1 ,  Break [ ] ] ,  { range} ] ; 
s = t ;  range * =  2 ; Do [t  = Mod [t2 + 1 , n] , { range} ] ] ;  
Which [ 
g = =  1 ,  Message [ PollardRho : : maxtrm] ; bf , 
g = =  n , Message [ PollardRho : : allfac , n] ; bf , 
'l!rue , { g ,  n I g }  ] ] 
PollardRho [ 2058499 66067 09 ] 
{ 1 3 1 6 7 1 7 , 1 5 6 3 3 5 7 7 } 
Of course, it can happen that the sequence will not run long enough to 
find a repeat. As an exercise, you can reprogram it so that old results are 
saved and if the user decides to attempt a longer sequence, that can be done 
without starting over from the beginning (Exercise 5.33) 
PollardRho [ l 377 0349 1 ,  10] 
PollardRho : : maxtrm : 
The number of terms of the Pollard sequence 
has exceeded its maximum with no repeats . 
PollardRho [ 1 3 7 7 0 3 4 9 1 , 1 0 ] 

1 74 
5. SOM E APPLICATIONS 
PollardRho [ l 37 7 03491 , 100 ] 
{ 7 9 1 9 , 1 7 3 8 9 } 
1!J Pollard p - 1 
Pollard's earlier category-1 algorithm - the p - 1 method - is based on 
Fermat's Little Theorem. Let p be a prime divisor of n, the number that we 
want to factor. We know that if a, a random integer, is not divisible by p, 
then aP-1 = 1 (mod p). This means that p divides gcd(aP-l - 1, n). Since it is 
extremely unlikely that p - 1 is a multiple of the order of a for other prime 
divisors of n, this greatest common divisor will be p. 
Of course, we do not know p, and so we do not know p - 1. But any 
multiple of p - 1 will work just as well. In fact, all we need is a multiple of 
ordp(a). If k is at least as large as the largest prime divisor of ordp(a), then 
k! should be a multiple of ordp(a). An advanced result states that on aver­
age, the largest prime divisor of m is approximated by m 1- 1/e , or m0·632 (see 
Exercise 5.26). This means that if p is prime divisor of n, then p should 
divide gcd(ak! - 1, n) provided k  p0·64 • We do our exponentiation modulo n 
so that it goes quickly. The drawback is that if p is large, we have a lot of 
exponentiations to carry out. 
Algorithm 5 .4. 
Pollard p - 1 
If the algorithm returns {n, 1}, then you have picked up all of the factors at 
once. The code then returns a message suggesting that d, the number of 
iterations before calculating the gcd, be reduced. 
PollardpMinusl :  : maxtrm = 
" The number of terms of the Pollard sequence 
has exceeded its maximum with no repeats . " ;  
PollardpMinusl : : allfac = " The potential gcd equals 
- - ,  and so a factor has not been identified . " ;  
PollardpMinus l  [ n_, max_ : 10000 ] : = 
Module [ { a = Random [ Integer ,  { 2 ,  n - 2 } ] , g =  1 ,  
i = O ,  hf = BoldForm [ PollardpMinus l  [ n , max] ] } , 
Wbile [ i  !Ii max && g = =  1 ,  i + + ;  a =  PowerMod [ a ,  i , n ] ; 
g = GCD [ n ,  a - 1 ] ] ;  
Which [ 
g = =  1 ,  Mes sage [PollardpMinus l :  : maxtrm] ; hf , 
g = =  n ,  Message [ PollardpMinus l :  : allfac , n ] ; hf , 
True , { g ,  n I g }  ] ] 
PollardpMinusl [ 22 520042 8365 1 ]  
{ 1 3 0 3 83 1 ,  1 7 2 7 2 2 1 } 

PollardpMinus l [ 225 + 1] 
{ 6 4 1 ,  6 7 0 04 1 7 } 
5.4. FACTORING ALGORITHMS 
1 75 
This algorithm, of course, works best if p - 1 has only small divisors. 
Here's an example, where the smaller prime is 54 7 · 2 · 3 · 5 · 7 · 11 · 13 · 17 · 19 · 
23 . 29· 31 · 37 . 41 · 43 . 47 + 1. 
PollardpMinu s l [ 
2037 6 1 3 3 337 18005 1727 964427 87984 18006432 58424495695969452562; 
97 ] 
{ 3 3 6 3 4 4 7 1 1 0 7 5 9 0 4 8 0 1 2 7 1 ,  
6 0 5 8 1 1 0 2 2 62 6 1 7 8 7 4 7 9078952 9 1 4 3 6 12907 0 9 4 0 7 } 
@J The Current Scene 
The Pollard p - 1 algorithm is almost always less efficient than Pollard rho, 
but it contains an idea that has led to other category-1 algorithms. The 
reduced residue system modulo p is an example of a finite group: It is 
closed under multiplication and has an identity and multiplicative inverses. 
Each element of a finite group has an order, the smallest power of that 
element that is equal to the identity, and this order must divide the size of 
the group. Pollard p - 1 uses a group of size p - 1 that is based on arith­
metic modulo p. 
There are other finite groups that use arithmetic modulo p in their 
definition. Lucas sequences give rise to one of these, and we shall study 
them in more detail in Chapter 8. The arithmetic structure of Lucas 
sequences can be used to find those prime factors p for which p + 1 has only 
small prime divisors. This gives rise to a p + 1 factoring algorithm devel­
oped by Hugh Williams. 
We get real flexibility when we use the arithmetic of elliptic curves, an 
important area of number theory that is beyond the scope of this book. 
Elliptic curves arise in many contexts, most famously in Andrew Wiles's 
proof of Fermat's Last Theorem. One can use them to construct finite 
groups based on arithmetic modulo p, groups that have all possible num­
bers of elements from f p + 1 - 2v'Jl to lP + 1 + 2Vp J. As we choose groups 
at random, we have a greatly improved chance that we will select one 
whose order is a divisor of k! for relatively small k. This is the fundamental 
idea behind Lenstra's elliptic curve algorithm that has been used to factor 
F10 and F11 · 
The Fermat number F10 = 2210 + 1 is a 309-digit integer. It has two 
relatively small prime factors: 45592577 and 6487031809 that were discov­
ered, respectively, by John Selfridge in 1953 and John Brillhart in 1962, 
but that left a 291-digit integer that was known to be composite. In 1995 
R. P. Brent used the elliptic curve method to find a 40-digit prime that 
divides F10 , and then proved that the remaining piece, a 252-digit integer, 
is prime. As this book goes to press, the largest prime factor found by the 
elliptic curve method is the 53-digit factor of 2677 - 1 that was discovered by 

1 76 
5. SOM E  APPLICATIONS 
Conrad Curry in 1998. The latest record for the elliptic curve method can be 
found at www.loria.fr/-zimmerma/records/ecmnet.html . A description of this 
algorithm can be found in [CP]. 
Category-1 factorization methods are useful for finding a prime divisor 
of around 50 digits or fewer, and they are relatively insensitive to the size 
of the number you are trying to factor, but the real workhorses of factoriza­
tion are the category-2 methods. These algorithms have running times that 
are direct functions of the size of the number you wish to factor and are 
insensitive to the size of the smallest prime divisor. The first category-2 
method was a variation of what today is called the quadratic sieve. It was 
proposed by Maurice Kraitchik in the 1920s but was not implemented until 
the advent of massive and inexpensive computer memory in the early 
1980s. The first of the category-2 methods to be programmed into an elec­
tronic computer was the continued fraction algorithm that we shall see in 
Chapter 7. It was used by Brillhart and Morrison in 1975 to factor the 39-
digit integer F7 . The category-2 algorithms in use today are the quadratic 
sieve and the number field sieve, each with its own variations. The qua­
dratic sieve was used to factor RSA-129, a 129-digit behemoth created by 
Rivest, Shamir, and Adleman in 1977 and publicized by Martin Gardner in 
his Scientific American column as a challenge problem to those who would 
try to crack the RSA public-key cryptosystem. In 1994, the quadratic sieve 
produced the factorization of RSA-129 into a 64-digit and a 65-digit prime. 
This was a herculean effort that required eight months on 1600 computers 
yoked in parallel. But the record for the factorization with the largest least 
prime divisor goes to the number field sieve, which The Cabal, coordinated 
by Peter Montgomery, used to factor (10211 - 1)/9 (a repunit with 211 ls) 
into a 93-digit and a 118-digit prime. Unfortunately, this version of the 
number field sieve works only on integers such as 10211 - 1 that are very 
close to a power of a very small integer. A variation of it, the general num­
ber field sieve, works on any integers, but so far has only been successful in 
factoring integers of less than 120 digits. The quadratic and number field 
sieves, together with their most useful variations, are described in detail by 
Crandall and Pomerance [CP]. 
Most factorization records have arisen from the Cunningham Project, a 
dispersed effort to factor all integers of the form bn ± 1 for 2 :s; b :s; 12. The 
current status of this project, the smallest composite integers that have not 
been factored, and the records for the two largest prime divisors found by 
each of the category 1 methods and for the two largest composite integers 
factored by each of the category 2 methods can be found at 
www.cerias.purdue.edu/homes/ssw/cun/index. html. 
Exercises for Section 5.4 
5.24. Explain why the following algorithm returns l -{Ti J. Hint: It is based 
on the Newton-Raphson method for finding the root of a polynomial, in this 
case a root of x2 - n. Note that Quotient [ a ,  b ]  is faster than Floor [ a ,  b ]  . 

5.4. FACTORING ALGORITH MS 
1 77 
SqrtF loor [ n _] : = Module [ { a  = n , b = Quotient [ n + 1 , 2 ] } , 
While [ b  < a , a =  b i  b = Quotient [a2 + n , 2 a] ] i  a] 
5.25. Use Algorithm 5.2 to factor 2027651281. 
5.26. Perform some numerical computations to support the theorem that, 
on average, if p(n) is the largest prime divisor of n, then lognp(n) is asymp­
totic to 1 - 1 / e (asymptotic means that the limit of the quotient is 1; the 
use of average means that you must study the average value of logn p(n) 
over a large number of integers). 
5.27. Consider the following factorization algorithm: Given a composite 
integer n, we choose a random integer r between 1 and n and compute 
g = gcd(r, n). If g is 1 or n, then we choose another random integer and 
repeat. If g is not 1 or n, then we have found a proper divisor of n. How does 
this algorithm difer from Algorithm 5.1 and, in particular, how many tries 
would you expect this algorithm to take if the smallest prime divisor of n is 
of size m? 
5.28. The following program selects a prime p below one million and a 
random seed s. Starting with so = s, it calculates the sequence Si+ l  = s̏ + 
1 (mod p) until it finds i and j such that si = si+j · It then returns the values 
of p, i (the length of the tail), and j (the length of the cycle). Do multiple 
trials and apply whatever statistical tools you have available to see how 
well the outcomes match the predicted value of slightly more than ../P / 2 
for i and j. 
Rho'.rrials : = Module [ 
{p = Prime [ Random [ Integer , { 1 ,  PrimePi [ 106 ] } ] ]  , s ,  seq = { } } , 
s = Random [ Integer , { 2 ,  p - 1 } ]  i 
While [ FreeQ [ seq , s ] , seq = { seq, s } i s = Mod [ s2 + l , p] ] i  
seq =  Flatten [ seq] i 
Flatten [ {p ,  Position [ seq, & ]  - 1 , 
Length [ seq] - Position [ seq , s ]  + 1 } ] ] 
5.29. 
For each of the following values of m - 25, 100, 365, 10,000, 
1,000,000 - find the smallest integer t for which 
m - 1 m - 2  
m 
m 
m - (t - 1) 
m 
1 
< -2 
· 
5.30. We can get a rough approximation of the smallest value of t (as a 
function of m) for which 
m,; 1 · m,;2 · · ·  m-̐- l l  < t bܹ taking the logarithm of 
each side, replacing the logarithm of 1 - -fn by - -fn, and then replace t2 - t 
by t2 • Show that this approximation gives t to be roughly 1.18 Ym. Test this 
rough approximation against the values calculated in Exercise 5.29. 
5.31. Speed up the Pollard rho algorithm by doing the gcds 10 at a time. Or 
d at a  time. 

1 78 
5. SOM E APPLICATIONS 
5.32. If you are willing to run the Pollard rho algorithm for 100,000 itera­
tions, how large a prime factor can you expect to be able to find? 
5.33. Improve the code for Pollard rho so that, perhaps via an option, 
partial results are stored so that the user can continue and use these 
already computed values if he or she wishes to try again with a longer 
sequence. Perhaps the output, in case of failure, could have the form: "No 
success yet. Shall I continue for another 10,000 terms?" 

CHAPTER 6 
Quadratic Residues 
6.0 Introduction 
We learned in Chapter 2 how to solve linear congruences ax + b = 0 (mod 
m). What about quadratic congruences of the form ax2 + bx +  c = 0 (mod m)? 
The problem is both harder and richer. In solving it, we shall develop tools 
that have implications for primality testing (as in Pepin's test) and factoriza­
tion (as in the quadratic sieve). 
When the mathematicians of the eighteenth century tackled this prob­
lem, they soon realized that it boiled down to the simple case x2 = a  (modp), 
where p is an odd prime. When does this have a solution? If a solution 
exists, how does one find it? There are two approaches to studying this 
congruence: 
• One can fix p and ask for the values of a that have a square root 
modulo p. 
• One can fix a and ask for the moduli p for which a square root of a 
exists. 
The greatest breakthrough comes from the realization that these questions 
are connected. Knowing the answer to one will yield an answer to the other. 
This is the content of the celebrated quadratic reciprocity theorem. 
6.1 
Pepin's Test 
« Quadratic Residues 
As we saw in the last chapter, if we can factor n - 1, then we have a reliable 
and fast algorithm for proving n to be prime. For most values of n over 
10100 this is not a practical approach, but if n is of a special form, say n = 

1 80 
6. QUADRATIC RESIDUES 
2m + 1, then we can verify primality quickly, even for very large n. As 
Fermat realized, if 2m + 1 is prime, then m must be a power of 2 (see Exer­
cise 2.42). 
Fermat also observed that each of the following numbers is prime. 
2 + 1 = 3  
22 + 1 = 5 
24 + 1 = 17 
28 + 1 = 257 
216 + 1 = 65537 
At one time, he believed that 2m + 1 would be prime if and only if m is a 
power of 2, but it is not that simple. In fact, 232 + 1 = 4294967297 = 641 · 
6700417. We define Fk, the kth Fermat number, to be 22k + 1 and ask 
when Fk is prime. 
We know from Theorem 4.4 that if b is an integer such that b<Fk -1>12 = 
- 1  (mod Fk ), then b has order Fk - 1 (modulo Fk), and so Fk is prime; 
indeed, b is a primitive root for Fk. In 1877, Fr. Jean Franc;ois Theophile 
Pepin (1826-1904) pointed out that there are values of b that are guaran­
teed to work for any k for which Fk is prime. This implies that if b<Fk -1>12 $ 
- 1  (mod Fk ), then Fk cannot be prime. The key to finding such values of b is 
the notion of quadratic residues. 
We say that b is a quadratic residue modulo m if b is relatively 
prime to m and there exists an integer t such that b = t2 (mod m); if there is 
no such t, b is called a nonresidue. For small numbers we can see the 
quadratic residues by simply squaring all nonzero residues. Here are the 
quadratic residues for 7 and 11. 
Mod [ Range [ 6 ] 2 , 7 ]  
{ 1 ,  4 ,  2 ,  2 ,  4 ,  l } 
Mod [ Range [ 1 0 ] 2 , 1 1 ]  
{ 1 ,  4 ,  9 ,  5 ,  3 , 3 , s , 9 ,  4 , 1 } 
Some of the basic properties of quadratic residues for prime moduli are 
summarized in the following theorem. 
Theorem 6.1. For any prime modulus p > 2, exactly (p - 1)/2 elements of 
the reduced residue system modulo p are quadratic residues. The integer b 
is a quadratic residue modulo p if and only if b<P-1>12 = 1 (mod p) [this is 
called Euler's criterion] .  If p does not divide b = cd, then b is a quadratic 
residue if and only either c and d are both quadratic residues or neither is a 
quadratic residue. 
Proof. 
Because i2 = (p - i)2 (mod p) and i cannot be congruent to p - i 
modulo p, each quadratic residue must be the square of at least two distinct 

6. 1 .  PãPIN'S TEST 
181 
elements of Zi . On the other hand, if i2 = j2 ( modp), then p divides i2 - j2 = 
(i - j) (i + j). Because p is prime, either p divides i - j, and so i = j (mod p), 
or p divides i + j and so i = -j (mod p). This implies that each quadratic 
residue corresponds to exactly two elements of the reduced residue system 
modulo p, so the number of quadratic residues is (p - 1)/2. 
Let g be a primitive root modulo p. Because any even power of g is a 
quadratic residue and because there are (p - 1)/ 2 distinct even powers of g 
(modulo p), no odd power of g can be a quadratic residue (and these are all 
the nonresidues). If b = g" (mod p) where e is odd, then b<P- 1 >12 = g"(p-l>t2 
(mod p). Because e(p - 1)/ 2  is not a multiple of p - 1, ge<p- 1 >12 cannot be 
congruent to 1 (mod p); in fact it must be - 1  (mod p) because it squares to 
1. Euler's criterion now follows from ge<p-1 "2 = (gP- 1 ) e/2 = 1 (mod p) if e is 
even and ge<p-ll/2 = (g<p-lll2 )e = (- l)e = - 1 (mod p) if e is odd. 
Finally, if b = c · d, then b is an even power of g if and only if either both 
c and d are even powers of g (and hence quadratic residues) or both are odd 
powers of g. 
o 
Given a prime p, it is easy to use Euler's criterion to test whether or not 
a given integer b is a quadratic residue. 
QuadraticResidueQ [b_, p_] : =  (PowerMod [b , (p - 1 ) / 2 , p] == l )  
Assuming that p is prime, this returns True when b is a quadratic residue 
and False when it is not. 
But there are many instances - Pepin's Test is one of them - when we 
want a simple characterization of all primes for which a given b is a qua­
dratic residue. By Theorem 6.1, if we know the status of all prime factors of 
b, we can determine whether or not b is a quadratic residue, so we shall 
restrict our attention to prime values of b. The following program finds all 
odd primes below nmax for which b is a quadratic residue. 
QuadraticModuli [b_, nmax_] : = 
Select [ Prime [ Range [ 2 , zr [nmax ] ] ] ,  OuadraticResidueO [ b ,  I ] & ] 
QuadraticModuli [ 7 , 100] 
{ 3 , 1 9 , 2 9 , 3 1 ,  3 7 , 4 7 , 5 3 , 5 9 , 83 } 
Some of the results are summarized in the following table. 
b 
Primes Less Than 100 
2 
7, 1 7, 23, 31, 41. 47, 71, 73, 79, 89, 97 
3 
1 1 ,  13, 23, 37, 47, 59, 61, 71, 73, 83, 97 
5 
1 1 ,  19, 29, 3 1 , 41, 59, 61, 71, 79, 89 
7 
3, 19, 29, 31, 37, 47, 53, 59, 83 
1 1  5, 7, 19, 37, 43, 53, 79, 83, 89, 97 
13 3, 17, 23, 29, 43, 53, 61, 79 
17 13, 19, 43, 47, 53, 59, 67, 83, 89 

1 82 
6. QUADRATIC RESIDUES 
For b = 2, we get precisely the primes congruent to ± 1 (modulo 8). For 
b = 3, we get the primes congruent to ± 1 (modulo 12). For b = 5 we get the 
primes congruent to ± 1 (modulo 5). For b = 7, it is a bit more complicated. 
We get the primes congruent to ± 1, ± 3, or ± 9  (modulo 28). For b = 13 we 
get the primes congruent to ± 1, ± 3, or ± 4  (modulo 13). 
Euler, Legendre, and other eighteenth-century mathematicians studied 
these residue classes for patterns, and eventually made the following 
remarkable observation. 
Theorem 6.2. Quadratic Reciprocity. For distinct odd primes p and q, 
p is a quadratic residue modulo q if and only if q is a quadratic residue 
modulo p, except in the case where p and q are both congruent to 3 (mod 4), 
in which case p is a quadratic residue modulo q if and only if q is not a 
quadratic residue modulo p. 
In the late 1700s, this was one of the great unproven conjectures in 
mathematics. Notice what it will do for us. To find the primes for which 5 is 
a quadratic residue, we only need to find the residue classes that are qua­
dratic residues modulo 5. There are two of them and they are 1 and 4, so 
the primes congruent to 1 and 4 (modulo 5) are the ones sought. There are 
six quadratic residues modulo 13. They are 1, 3, 4, 9, 10, and 12. The num­
ber 7 is more complicated because it is congruent to 3 (modulo 4). The 
quadratic residues modulo 7 are 1, 2, and 4. Any prime for which 7 is a 
quadratic residue must either be congruent to 1 (modulo 4) and congruent 
to 1, 2, or 4 (modulo 7) [in other words, congruent to 1, 9, or 25 (modulo 28)) 
or it must be congruent to 3 (modulo 4) and to 3, 5, or 6 (modulo 7) [in other 
words, congruent to 3, 19, or 27 (modulo 28)) . 
This theorem was finally proven by the brilliant young mathematician 
Carl Friedrich Gauss (1777-1855) who published the first proof in his book 
Disquisitiones ArithmeticCE in 1801. We shall postpone this proof until the 
next section. 

 Pepin's Test 
Returning to the testing of Fermat numbers, Fk = 22• + 1, for primality, 
recall that we wanted to find a b for which b<F•-1>12 = - 1  (mod Fk) whenever 
Fk is prime. This will be true if b is not a quadratic residue for any prime 
Fk. If we look at our table, we see that 3 and 5 look promising (they are not 
quadratic residues for 3, 5, or 17) while 2, 7, 11, and 13 are out of the 
question. 
Quadratic reciprocity (see Exercise 6.1) tells us that 3 is a quadratic 
residue modulo p if and only if p = 1 or 1 1  (mod 12). It is clear that for k > 0, 
Fk = 1 (mod 4). Can Fk be congruent to 1 (mod 3)? For k > 0, 2k is even and 
therefore 22• = 1 (mod 3). This means that Fk = 22• + 1 = 2 (mod 3), and so 
Fk = 5 (mod 12). So 3 is not a quadratic residue for any prime Fermat 
number; this means that if Fk is prime, 3 will be a primitive root. This 
proves Pepin's test. 

6. 1 .  PãPIN'S TEST 
1 83 
Theorem 6.3. Pepin's Test. The Fermat number Fk = 22k + 1 is prime if 
and only if 3<Fk - ll/2 = - 1  (mod Fk>· 
Composite Fermat numbers are always 2-strong pseudoprimes (Exer­
cise 4.16). Pepin's test can be interpreted as saying that a composite Fer­
mat number is never a 3-strong pseudoprime. The following computation 
shows that among the first twelve Fermat numbers, only the first four are 
prime. FermatNumber is a CNT package function that gives the Fermat 
numbers. 
Select (Range [ l2 ] , 
( 
f - 1 
) 
f = FermatHnmher [ t ]  1 PowerMod ( 3 ,  -
2
- ,  f] = =  f - 1 
& ] 
{ l ,  2 ,  3 , 4 } 
Because of this simple test, it has been possible to prove that F5 
through F23 are all composite. At this moment, the two smallest Fermat 
numbers whose status is unknown are F24 and F31 •  The former has 
5,050,446 digits, the latter 646,456,994. Other methods have been used to 
find large families of Fermat numbers that must be composite. It is gener­
ally believed that there are at most a finite number of prime Fermat num­
bers. Probably the current list - n = 1, 2, 3, 4 - is a complete list of Fer­
mat primes, but no proof of this is known. 
@J Primes Congruent to 1 (Mod 4) 
There is one value of b for which it is easy to determine the primes for 
which b is a quadratic residue without using quadratic reciprocity. That is 
b = - 1. From Theorem 6.1 we know that - 1  is a quadratic residue if and 
only if (- l)(p-ll/2 = 1 (mod p). If p = 3 (mod 4), then (- l)<p-ll/2 = - 1 '1= 1  (mod 
p), while if p = 1 (mod 4) then (- l)<P-ll/2 = 1. We have proven the following 
theorem. 
Theorem 6.4. For odd primes p, - 1  is a quadratic residue modulo p if and 
only if p = 1 (mod 4). 
This simple idea gives a very fast way of computing a square root of 
- 1  (mod p). If p = 1 (mod 4), then half of the integers in Zp are nonresidues. 
If c is such, then c<P-ll/2 = - 1  (mod p), so c<p-ll/4 squares to - 1  (mod p). It 
will be easy to find c by trial and error. Here is an example that shows a 
typical case. 
p = RandOIDPrime [ 50 ,  { l ,  4 } ]  
6 3 7 92 2 7 8 1 5 6 5 1 63 5 8 3 0 6 8 1 0 9 7 7 3 4 1392653093 7 3 3 0 3 4 3 3 9 5 3 7  
Below 20 there are five good values of c. 

1 84 
6. QUAD RA TIC RESIDUES 
p - 1 
Select [Range (20) , PowerMod[ t ,  -- , p) == p - 1 & ) 
2 
{ 5 ,  1 0 ,  1 3 , 1 5 , 2 0 } 
And here is a value of H. The other mod-p square root of - 1  is just its 
negative. 
PowerMod [ S ,  (p - 1 ) / 4 , p] 
6 3 0 7 0 95 6 4 1 8 3 3044459492 8 1 3 8 4 0 1 5 95 9 7 7 8 3 0 5 2 2 0 9 8 3 3 0 3 8 1 
In Exercise 4.1, you were asked to prove that there are infinitely many 
primes that are congruent to 3 (mod 4). In the next exercise, you were asked 
to explain why that approach could not succeed in proving that there are 
infinitely many primes congruent to 1 (mod 4). Equipped with Theorem 6.4, 
we can now prove that we also have infinitely many primes congruent to 
1 (mod 4). 
Theorem 6.5. There are infinitely many primes congruent to 1 (mod 4). 
Proof. Assume that there are only finitely many such primes: p1 = 5, p2 = 
13, . .  ., Pr, and let P be their product, P = P1P2 ... Pr· Let q be any prime that 
divides P2 + 1, which means that P2 = - 1  (mod q). Because - 1  is congruent 
to a perfect square modulo q, q must be congruent to 1 (mod 4). But because 
P is the product of all primes congruent to 1 (mod 4), q must also divide P2, 
a contradiction. 
o 
Exercises for Section 6.1 
6.1. Use Theorem 6.2 to prove that 3 is a quadratic residue modulo p, 
where p is an odd prime, if and only if p = ± 1 (mod 12). 
6.2. What are the residue classes for which 11 is a quadratic residue mod­
ulo the prime p if and only if p is in one of these residue classes? 
6.3. Can 5 be a quadratic residue for a prime of the form 22k + 1? 
6.4. Can 17 be a quadratic residue for a prime of the form 22k + 1? 
6.5. Prove that -3 is a quadratic residue modulo p if and only if p is congru­
ent to 1 (mod 6). 
6.6. Prove the following formula for a square root of - 1  (mod p) where p is 
prime and congruent to 1 (mod 4). 
[ p 1 
2 
( T]!} = -l(mod p) 
Hint: You will need Wilson's Theorem (Exercise 2.12). 

6.2. PROOF OF QUADRATIC RECIPROCITY 
185 
6.7. Prove that if p is a prime congruent to 3 (mod 4), then [(p - 1)/2) ! 
must be congruent to ± 1 (mod p). 
6.8. Prove that there are infinitely many primes congruent to 1 (mod 6). 
Hint: Assume that there are only finitely many such primes and let P be 
their product. Show that if q is a prime divisor of 12P2 + 1, then -3 is a 
quadratic residue (mod q). Use the result of Exercise 6.5 to show that q 
must be congruent to 1 (mod 6) and so q divides 12P2 • 
6.9. If p = 1 (mod 4), then there are an even number of quadratic residues 
(mod p). Prove that exactly half of them are between 1 and (p - 1)/2 
(inclusive). 
6.10. Show that if p = 3 (mod 4) and 1 s x s p - 1, then x is a quadratic 
residue (mod p) if and only if x is a fourth power (mod p). Hint: Use the fact 
that - 1  is not a quadratic residue. 
6.2 Proof of Quadratic Reciprocity 
« Gauss's Lemma 
Although Adrien-Marie Legendre could not prove quadratic reciprocity, he 
did come up with a convenient notation for expressing it, the Legendre 
symbol, written (-} ). It is defined for any integer b and any odd prime p 
and is equal to + 1 when b is a quadratic residue modulo p, - 1  when b is not 
divisible by p and is not a quadratic residue, and 0 when b is divisible by p. 
It follows from Theorem 6.1 that 
( % ) = b<p-Il/2 (mod p) 
( b+:p ) = ( % ) 
( a:) = (-})(%) · 
(Euler's criterion) 
for any integer k 
The code that follows computes the Legendre symbol by appealing to 
Euler's criterion via the package function QuadraticRes idueQ. The built­
in way of getting Legendre symbols uses the fact that it is a special case of 
the Jacobi symbol, discussed later in this section. 
LegendreSymbol [b_, p_ ? PrimeQ] : = (qr = OuadraticResidueO [b, p] " 
Which [ qr ,  1 ,  Mod [b , p] f. 0 && ! qr ,  - 1 ,  True , O] ) 
Quadratic reciprocity is the statement that ( {") and ( .!j;) are the same 
unless p = q = 3 (mod 4), in which case ( {") = -(-9p ). A slick way of stating 
this in a single statement is that if p and q are distinct odd primes, then 

1 86 
6. QUADRATIC RESIDUES 
(.!..). ( !! ) = (-lip-l)(q-1)/4 . 
q 
p 
The first step in proving quadratic reciprocity is Gauss's criterion. 
Theorem 6.6. 
Gauss's Criterion Let p be an odd prime and b a positive 
integer not divisible by p. For each positive odd integer 2 i - 1 less than p, 
let ri be the residue of b(2i - 1) (mod p): 
ri = b(2i - 1) (mod p), 0 < ri < p . 
Let t be the number of ri that are even. Then ( ""i) = (-1)1• 
As an example, let p = 23 and b = 3 [72 = 49 = 3 (mod 23) so 3 is a 
quadratic residue modulo 7). Then 
r1 = 3· 1 = 3(mod 23) r5 = 3·9 = 4(mod 23) 
r9 = 3· 17 :: 5(mod 23) 
r2 = 3 · 3 = 9(mod 23) r6 = 3· 11 = lO(mod 23) r10 = 3· 19 = ll(mod 23) 
r3 = 3 · 5 = 15(mod 23) r7 = 3· 13 = 16(mod 23) ru = 3 · 21 = 17(mod 23) 
r4 = 3 · 7 = 21(mod 23) r8 = 3· 15 = 22(mod 23) 
It follows that t = 4 -the bold entries in the display - and ( 2
33 ) = (- 1)4 = 1. 
If b = 5, then there are five even residues in the list of multiples - {5, 15, 
2, 12, 22, 9, 19, 6, 16, 3, 13} - and 5 is indeed not a quadratic residue 
modulo 23. 
Proof. Write p = 2m + 1. There are m positive odd integers less than p. 
Relabel the residues so that r1, r2 , • • •  , r1 are all even and r1+1, r1+2 •
• • •  , rm 
are all odd. Let a1, a2, • • .  , am be the positive odd integers less than p 
ordered so that ri = bai (mod p). 
Consider the integers p - r1 , p - r2 , . . .  , p - r, ,  r1+1 •
• • •  , rm. These are all 
odd positive integers less than p. We claim that they are distinct. Because 
the ai are distinct modulo p, there are no repetitions among the first t or 
among the last m - t. It suffices to prove that we cannot have p - ri = rj 
where i is at most t and j is larger than t. If we did, then we would have that 
Because p does not divide b, it must divide ai + aj. But 0 < ai + aj < 2 p, so 
p = ai + aj, which contradicts the fact that ai and aj are both odd and 
therefore their sum is even. 
Because p - r1, p - r2, ... , p - r,, r1+1, • • •  , rm are m distinct odd positive 
integers less than p, they must be all of them, and therefore 

6.2. PROOF OF QUADRATIC RECIPROCITY 
187 
But p does not divide any of the odd integers between 0 and p, so we can 
divide both sides of this congruence by a1 a2 . .  · a, .  Using Euler's criterion 
this implies that 
1 = (- 1}' b<P- 1 >12 = (-1)1 (!) (mod p) .  D 
Corollary 6.7. For prime modulus p, 2 is a quadratic residue if and only if 
p = ± 1 (mod 8). 
Proof. 
For 1 s i s (p - 1)/2, r; = 2(2i - 1) (mod p) is even if and only if 
2 i - 1 < p/2, or i < p/4 + 1 / 2. If p = 4m + 1, (using the notation of Gauss's 
criterion) this means that t = m, and so 2 is a quadratic residue when 
p = 1 (mod 8) and not when p = 5 (mod 8). If p = 4 m + 3, then t = m + 1 and 
so 2 is a quadratic residue when p = 7 (mod 8) and not when p = 3 (mod 
8). 
D 
« Proof of Quadratic Reciprocity 
Theorem 6.2 requires p and q to be distinct primes, so the Legendre sym­
bols ( f) and ( .!j;) are not zero. We let s be the number of positive odd inte-
gers 2 i - 1 < p such that if r; = q(2i - 1) (mod p) with 0 < r; < p, then r; is 
even. We let t be the number of positive odd integers 2j - 1  < p such that if 
rj = p(2j - 1) (mod q) with 0 < rj < q, then rj. From Gauss's criterion (Theo­
rem 6.6), we know that 
We shall prove that s +  t is odd if and only if p = q = 3 (mod 4). 
Consider the set S of all integers of the form qa - p b where a runs over 
the positive odd integers less than p and b runs over the positive odd 
integers less than q. As an example, if p = 5 and q = 7, then a is 1 or 3 and b 
is 1, 3, or 5. The set S can be computed using Outer, which takes all combi­
nations from the arguments, as follows. 
Outer [ f ,  { 1 ,  2 ,  3 }  , { 7 ,  8 } ] 
{ { f [ l ,  7 ] , f [ l ,  8 ] } , { f [ 2 ,  7 ] ,  f [ 2 ,  8 ] } ,  { f [ 3 , 7 ] ,  f [ 3 , 8 ] } } 
Now here is the set S. 
p = 5 ;  q = 7 ; a =  { l ,  3 } ;  b = { l ,  3 ,  5 } ;  
S = Flatten [Outer [ Subtract , q a , p b] ]  
{ 2 , - 8 , - 1 8 , 1 6 , 6 , - 4 } 

1 88 
6. QUADRATIC RESIDUES 
We leave it as an exercise (6.11) to verify that the numbers in S are always 
even, nonzero, and distinct. 
Consider those pairs (a, b) for which r = qa - p b  is positive and less 
than p. This means that 
qa = p b + r = r (mod p) 
and so r is one of the residues counted by s. Furthermore, every residue 
counted by s arises in this way, for if qa = r (mod p) where a is positive, 
odd, and less than p and if r is positive, even, and less than p, then qa - r = 
p b where b is positive and odd and p b is strictly less than q p - r, and 
therefore b is strictly less than q. 
Similarly, if qa - pb is negative and larger than -q, then it equals - r, 
where r is one of the residues counted by t. Furthermore, every residue 
counted by t corresponds to a pair (a, b) for which qa - p b  is negative and 
larger than -q. Therefore s + t is the number of elements of S that lie 
between -q and p. 
We have reduced our problem to showing that the number of elements 
of S between -q and p is even except when p = q = 3 (mod 4), in which case 
it is odd. We shall investigate the parity of this set by identifying natural 
pairs of elements. 
Let qa - pb be an element of S in the desired range. Let 
c = p - 1 - a 
d = q - 1 - b .  
We see that qc - pd is also in S and that qc - pd = -q + p - (qa - p b). 
Using the bounds on qa - pb, we observe that 
-q = -q + p - p < qc - pd < -q + p - (-q) = p  
and so qc - pd is also in the desired range. This means that we can pair up 
the elements of S in the desired range via 
(a, b) +--+ (p - 1 -a, q - 1 - b) . 
The number of such elements must be even unless some elements pair with 
themselves. But if a = p - 1 - a and b = q - 1 - b, then a = (p - 1) / 2 and 
b = (q - 1) I 2. This means that there is at most one element of S in the 
desired range that pairs with itself, and this element exists if and only if 
(p - 1) / 2 and (q - 1) I 2 are both odd. In other words, the number of ele­
ments of S in the desired range is odd if and only if p = q = 3 (mod 4). 
o 

« Jacobi's Extension 
6.2. PROOF OF QUADRATIC RECIPROCITY 
1 89 
The notion of quadratic residue is defined only for moduli that are prime 
and odd. It certainly makes sense to ask whether, say, 2 is or is not a 
square modulo n where n is composite, but in fact that is not the "right" 
generalization of the Legendre symbol to composites. It is much more useful 
to extend the Legendre symbol to what is called the Jacobi symbol ( *) as 
follows. Given n odd, n = p'' p(2 • • • p)' , and a relatively prime to n, the 
Jacobi symbol ( g) is defined by 
(ǡ) = (_!:_f (_!:_f2 · · ·(_!:_f 
n 
PI 
P2 
Pn 
where each ( ;; ) is a Legendre symbol (and so indicates the quadratic 
character of a (mod p; )). Note the special case of the empty product: ( f) = 1. 
This function is built into Mathematica as JacobiSymbol, and, because of 
a special algorithm that we will describe presently, this provides a faster 
way to get the Legendre symbol ( .!j;) than the more straightforward use of 
Euler's criterion. Here is a simple example to show that the Jacobi symbol 
does not correspond to the quadratic character of a modulo n. 
JacobiSymbol [ S , 1 5 ]  
1 
But 8 is not a square modulo 15. 
Union [ PowerMod [Range [ 1 4 ]  , 2 ,  15] ] 
{ 1 , 4 , 6 , 9 , 1 0 } 
The next result summarizes the main properties of the Jacobi symbol. 
The proofs are straightforward applications of the results about the Leg­
endre symbol presented earlier in this chapters, including quadratic reci­
procity, and are left as exercises. 
Proposition 6.8. The Jacobi symbol has the following properties. 
(a) If a = b (mod n), then ( g) = ( Ë ). 
(b) ( a: ) = ( ̎ )( Ë) 
(c) (..:.!.) = (-l)(n-1)/2 
n 
(d) (.!) = (-l)(n2-l)/8 
n 
(e) ( ..!.. )( ߂)  = (- 1)( m;t )(
";' ) 
m n 

1 90 
6. QUADRATIC RESIDUES 
(f) (І) = (!!..)(-l)8Cn2-1>18(-lin-l)(r-ll/4, where s and r are defined as follows: 
n 
r 
let R = Mod[ a, n], let s be the largest e such that 2e divides R, and let 
r = R/28• 
Algorithm 6. 1 .  The Jacobi Symbol 
To compute ( g) one can use a recursion based on part (f) of the preceding 
proposition. That leads to an algorithm that is very similar to the standard 
Euclidean algorithm. We raise the built-in recursion limit within a B lock 
so that it reverts to its default outside of the program. 
j acobi [ a_,  n_ ? OddQ] : =  0 / J  GCD [ a ,  n] Ⱥ 1 
j acobi [_, l ]  : =  1 
j acobi [ a_, n_ ? OddQ] : = 
Block [ { $RecursionLimit = oo , R = Mod [ a ,  n ] ,  s ,  r } , 
s = InteqerBxpopent [R, 2 ]  J r = R I 2• J 
(D- 1 )  (r- 1) 
(D1 - l) 
j acobi [ n ,  r] * ( - 1 )  
* ( ( - 1 )  • ) --.- ) 
The recursive version just given is slower than the simple PowerMod 
approach for getting Legendre symbols. For a fair comparison one should 
use the manual exponentiation code from Section 1.4 as opposed to the 
built-in version. We repeat that code here for convenience. 
powermodLR [ a_,  n_ , m_] : =  
Fold [Mod [Mod [ 1 1 U ,  m] * I f [ 12 = =  1 ,  a ,  l ] , m] & , 
a ,  Rest [ IntegerDigits [ n ,  2 ] ] ]  
n = Random [ Integer , { l ,  10200 } ]  J 
p = RandomPrime [ 200] J 
Do [ j acobi [ n ,  p] , { 5 } ] / / Timing 
Do [powermodLR [ n,  (p - 1 ) / 2 ,  p] / .  p - 1 -+ - 1 ,  { 5 } ] / / Timing 
{ 4 . 3 1 6 6 7  Second , Null } 
{ 1 . 9 6 6 6 7  Second , Null } 
But the implementation can be improved quite a bit. First, one can 
eliminate the recursion and get a thoroughly iterative method, much as was 
done for the Euclidean algorithm in Exercise 1.12. Second, one can elimi­
nate the arithmetic in the n2 - 1 computation by using instead the mod-8 
value of n. The table in the code that follows summarizes the mod-8 behav­
ior so that this part of the work can be accomplished by a table lookup. This 
code also avoids a gcd computation, because that comes for free; the value of 
aa at the completion of the loop will be the gcd of a and n. 

j acobiiter [ a_,  n_] : = 
6.2. PROOF OF QUAD RATIC RECIPROCITY 
1 91 
(table = { O , 1 ,  O ,  - 1 , 0 ,  - 1 ,  O ,  l } ; { aa ,  bb , c } = { a ,  n ,  1 } ; 
While [ bb it 0 ,  { aa ,  bb , c } = { bb , I f  [ (R = Mod [ aa ,  bb] ) == 0 ,  
O ,  r = R I 2 "'  ( s  = InteqerExponent [R, 2 ] ) ] ,  
r-1 
c * I f  [a = =  O ,  1 , ( ( - 1 ) bb.- • ) -. • table [Mod [bb ,  B J + lD "' s] } ] ; 
I f [ aa it 1 , O ,  c ]) 
We first check correctness. 
And H Table [ JacobiSymbol [r = Random [Integer , { l ,  100 } ] , 
m = Random [ Integer , { 1 ,  10 } ] 2 + 1 ]  == j acobiiter [ r ,  m] , { SO } ]  
True 
And now we do a timing comparison, 
Do [ j acobiiter [ n ,  p ] , { 5 } ]  I I  Timing 
Do [powermodLR [ n ,  (p - 1 )  I 2 ,  p] / .  p - 1 -+ - 1 , { 5 } ]  / / Timing 
{ O . Second , Null } 
{ 0 . 0 1 6 6 6 6 7  Second , Null } 
We can also compare the built-in PowerMod approach with the built-in 
JacobiSymbol algorithm, which is similar to our code just given. There is 
no contest. 
Do [ PowerMod [ n ,  (p - 1 ) / 2 , p] / .  p - 1 -+ - 1 , { 5 } ]  / / Timing / /  
First 
Do [ JacobiSymbol [ n ,  p ] , { 5 } ]  II Timing II First 
1 . 1 8 3 3 3  Second 
0 . 0 1 6 6 6 6 7  Second 
A historically important pseudoprime test - one of the first probabilis­
tic prime tests, sometimes called the Solovay-Strassen algorithm - can be 
developed from the Jacobi symbol (Exercise 6.13). 
߁ An Application to Factoring 
Gauss came up with a clever way of using quadratic residues to reduce the 
set of primes that one would try when using trial division to factor a num­
ber. His idea is related to the quadratic sieve, a powerful factorization 
algorithm in use today. 
If n is the number to be factored and if we know that a is a quadratic 
residue modulo n, then it must be a quadratic residue for any prime p that 
divides n. We can use quadratic reciprocity to find the possible residue 

1 92 
6. QUADRATIC RESIDUES 
classes in which p must lie. This cuts out approximately half of the primes 
that we need to test. If we find a second integer that is also a quadratic 
residue modulo n, we can expect to cut the number of primes by another 
factor of 2. Ten quadratic residues cut our trial divisions by a factor of 1000. 
Twenty quadratic residues reduce it by a factor of 1,000,000. 
To see how this works in practice, we shall factor n = 21,307,703. We 
take a small value of k, say 1 s k s 10, and choose integers i near fu, in 
this case LfuJ - 20 s  i s  LfuJ + 20. We calculate the 410 values of 
i2 - kn and see which ones we can factor completely using only primes 
below 100. We get 41 of these values that have all of their prime divisors 
less than 100. We list here nine of them that will turn out to be useful: 
46042 - 21307703 = - 1 · 72 · 31 · 73 
46162 - 21307703 = -1 · 13 · 19 
46272 - 21307703 = 2 · 13 · 47 · 83 
79782 - 3 . 2 1307703 = - 1 · 53 . 133 
122052 - 7 . 2 1307703 = - 1 · 23 • 172 • 83 
1220192 - 7 . 2 1307703 = 23 . 5 · 112 • 31 
122232 - 7 . 21307703 = 211 · 112 
122252 - 7 · 2 1307703 = 28 · 19· 61 
130432 - 8 · 21307703 = - 1 · 32 . 52 • 72 • 31 . 
Let p be any prime that divides 2 1,307, 703. The third equation from 
the bottom implies that 
122232 = 211 · 112 (mod p) 
and therefore 2 must be a quadratic residue mod p. Because 21,307, 703 = 
3 (mod 4), it must be divisible by a prime congruent to 3 (mod 4), so that we 
can assume that p = 3 (mod 4). This implies that - 1  is not a quadratic 
residue modulo p, and so by the last equation, 31 cannot be a quadratic 
residue modulo p. 
We now look at the first equation. Because -31 is a quadratic residue, 
73 must also be a quadratic residue. From the fifth equation, because - 1  is 
not a quadratic residue and 2 is, 83 cannot be. In the sixth equation, 2 is 
and 31 is not, so 5 cannot be a quadratic residue. In the fourth equation, 
because -5 is a quadratic residue, so is 13. From the second equation, 19 is 
not a quadratic residue. From the third equation, 4 7 is not a quadratic 
residue. From the second last equation, 61 is not a quadratic residue. 
In summary, we have established that 21,307, 703 is divisible by a 
prime p for which 2, 13, and 73 are quadratic residues and - 1, 5, 19, 31, 47, 
61, and 83 are not. We can now use the fast method of computing Jacobi 
symbols to determine the possible primes. There turn out to be two of them, 
8167 and 9463. 

6.2. PROOF OF QUADRATIC RECIPROCITY 
1 93 
Select [ Prime [Range [ 2 , PrimePi [ lOOOO) ] ] , 
Union [ JacobiSymbol [ { 2 ,  13 , 7 3 } , I ] ] = =  { 1 }  && 
Union [ JacobiSymbol [ { - 1 ,  S, 19 ,  3 1 , 47 , 6 1 ,  8 3 } , I ] ] == { - 1 }  & ]  
{ 8 1 6 7 , 9 4 6 3 } 
And, indeed, 2 1,307,703 factors into 8167 · 2609. 
2 1 3 07 7 03 I 8 167 
2 6 0 9  
It may seem that we have done an awful lot of work for a very small 
reward. After all, there are only 1229 primes below 10,000. The point here 
is that until we identified 8167 and 9463, we had avoided division by inte­
gers larger than 100. When we get to 40 and 50-digit integers, being able to 
avoid divisions will be critically important. Gauss's algorithm is not useful 
today, but the ideas that it embodies are. 
Exercises for Section 6.2 
6.11. Let p and q be distinct odd primes and consider the integers of the 
form qa - pb where a runs over the positive odd integers less than p and b 
runs over the positive odd integers less than q. Prove that the numbers 
generated in this fashion are even, nonzero, and distinct. 
6.12. Prove Proposition 6.8. 
6.13. (a) Explain why the following pseudoprime test is valid. Given n odd, 
let a = 2 and look at a<n- l)/2 (mod n). If this is not ± 1, n is proved composite. 
If this does not equal ( % ), n is proved composite. Otherwise, n is very 
probably prime. Composite numbers that pass this test are called Euler 
pseudoprimes to the base a. When the test is repeated many times with 
random choices of a, it can be interpreted as saying that n is prime with 
very high probability Gust as in the Miller-Rabin test). This probabilisiitc 
form is called the Solovay-Strassen algorithm. 
(b) Implement the 2-Euler pseudoprime test and find the first 2-Euler 
pseudoprime. Find the first 2-Euler pseudoprime that is not a Carmichael 
number. 
6.14. Show that if p = 1 (mod 4) and d is an odd integer that divides p - 1, 
then d is a quadratic residue modulo p. 
6.15. Show that for every prime p there is a solution to the congruence 
x6 - llx4 + 36x2 - 36 = 0 (mod p) . 
How many solutions are there? 

1 94 
6. QUADRATIC RESIDUES 
6.16. Prove that if 3 does not divide m, then there is at least one prime p = 
7 (mod 12) that divides 4m2 + 3. Use this to prove that there are infinitely 
many primes that are congruent to 7 (mod 12). 
6.17. Show that if p is prime and divides an integer of the form n4 - n2 + 1, 
then p = 1 (mod 12). Hint: First show that if p divides n4 - n2 + 1, then 
(2 n2 - 1)2 = -3 (mod p) and (n - n-1 )2 = - 1  (mod p). 
6.18. Show that if p is an odd prime that divides an integer of the form 
n4 + 4, then p = 1 (mod 4). 
6.19. Prove that x4 = -4 (mod p) has a solution if and only if p = 1 (mod 4). 
6.20. Prove that for any a > 2 and any prime p, the congruence x20 = 220- •  
(mod p) has a solution. 
6.3 Quadratic Equations 
In this section we will show how to find square roots modulo m. In other 
words, we will solve the quadratic congruence x2 = a  (mod m); Exercise 6.29 
will show how to extend this to solve all quadratic congruences. We will 
discuss the case of a prime modulus in detail; the extension to the general 
case is handled in the exercises. Of course, a solution to x2 = a  (mod p) 
exists only when a is a quadratic residue modulo p. Some cases are quite 
easy. Suppose that p = 3 (mod 4); then it is easy to find a solution to this 
congruence. Just choose x so that 
x = a<P+ll/4 (mod p) . 
This works because 
(a<P+lJ/4)2 = a<P+lJ/2 = aa<p-ll/2 = a (mod p) 
where the last congruence follows from the fact that a is a quadratic resi­
due modulo p. Here's an example. The package function NextPrime allows 
a congruence condition to be given as the second argument, so we can easily 
get a large prime congruent to 3 (mod 4). 
p = HextPri ge [ 1030 , { 3 , 4 }  ] 
1000000000000 000000000000000099 
Then we get a large square by squaring an integer modulo p. 
a =  Mod [ l 23 1 23 1234564564567 897 8 9 7 8 92 , p ]  J 
And we can recover the square root very easily. 

p + l 
PowerMod [a, 
-- , p] 
4 
1 2 3 1 2 3 1 2 3 4 5 64 5 64 5 6 7 8 9 7 8 9 7 8 9  
6.3. QUADRATIC EQUATIONS 
1 95 
There are several algorithms for the remaining case. We present 
Tonelli's algorithm here. 
Algorithm 6 . 2  Tonelli's Algorithm for Ya (mod p) 
Suppose that p = 1 (mod 4). If k is odd, say k = 2 m + 1, and ak = 1 (mod p), 
then am+l is a mod-p square root of a. If we have a nonresidue h handy, 
then we can also deal with the case that ak = -1 (mod p), because Euler's 
criterion tells us that ak h<p-lJ/2 = 1 (mod p) and the desired square root is 
am+l h<p-lJ/4 • This leads to the following algorithm, known as Tonelli's 
algorithm. We take two exponents el and e2 , which start off as (p - 1) I 2 
and p - 1, respectively. Then e1 will be repeatedly halved until it yields the 
odd integer k. After each halving, e2 will be modified so that it remains an 
even integer and so that the following congruence holds. 
(1) 
Note that (1) holds for the initial values of the exponents: Fermat's 
Little Theorem tells us that hP-1 
= 1 (mod p) and Euler's criterion yields 
a<p-ll/2 = 1 (mod p) because a must be a quadratic residue if a square root is 
to exist. If we can preserve (1) and get e1 to have the form 2m + 1, then we 
will have the desired square root as am+l he2t2 , because its square is 
a2m+2 he2 , or a(a2m+l he2 ), which is congruent to a. 
Now, here is how to modify e2 . First it is halved and then the new value 
of e2 is inserted into (1) together with the new value of el (which is half the 
old). The product is then ± 1, because it squares to 1 (mod p). If it is + 1, 
then nothing else is necessary. If it is -1, add (p - 1) / 2 to (the new value 
of) e2 . This has the effect of turning the expression in (1) into the desired 
+ 1. Because the final, odd, value of el has not yet been reached and because 
e2 starts out with one more 2 in it than e1 starts out with, e2 stays even; 
this is essential because the protocol calls for it to be halved at each step. 
Note that, at the last step when e1 finally becomes odd, we must perform 
the final transformation on e2 to preserve (1). 
The following table illustrates Tonelli's method to get ../49 (mod 3329). 
Because 3328 = 28 13, the initial values of (ei . e2 ) are (1664, 3328) and the 
algorithm requires eight steps before the special final step. The e1 values 
are cut in two at each step. The e2 values are also cut in two, but they get 
1664 added to them in the boldface cases, which correspond to the cases in 
which the Tonelli equation on the pre-e2 value is 3328. The final answer is 
3322, which is -7 (mod 3329). 

1 96 
6. QUAD RA TIC RESIDUES 
e1 
a•1 
a•1 (mod p) pre·e2 
e2 
Tonelli equation <ft hP'NZ (mod p) 
1664 
4912s 1a 
1 
3328 3328 
1 
1 
832 
4964 1 3  
1 
1664 3328 
1 
3328 
416 
4932 13 
3328 
1664 
1664 
1 
1 
208 
4916 13 
1 729 
832 2496 
1 
3328 
104 
49813 
2580 
1248 
1248 
1 
1 
52 
494 13 
2642 
624 
2288 
1 
3328 
26 
492 13 
2267 
1144 
2808 
1 
3328 
13 
4913 
2447 
1404 1404 
1 
1 
7 
497 
532 
702 
532 
332! 
The code that follows assumes that the second argument is prime. It 
uses Nest and Reverse to form the list of powers of a in advance, which it 
then scans to get the e2-sequence. It also shows how to include a message to 
handle bad calls; in this case such a case arises when the input is not a 
square modulo p. 
SqrtModPrimeTonelli : : noroot = 
" ' '  bas no square root modulo 
SqrtModPrimeTonelli [a_, p_] : = 
.. ... 
.. . 
. 
, 
(Message [ SqrtModPrimeTonelli : : noroot , a ,  p ]  ; BoldForm [ 
SqrtModPrimeTonelli [ a ,  p] ] )  / ;  JacobiSymbol [ a ,  p ]  = =  - 1 ;  
SqrtModPrimeTonelli [a_, p_] : =  Mod [ a ,  p ]  / ;  Mod [ a ,  p ]  = =  0 1 1 p = = 2  
SqrtModPrimeTonelli [a_, p_] : = 
( r  = PowerMod [a, (p + 1 )  / 4 ,  p] ; Min [ p - r ,  r ] ) I ; Mod [p, 4 ]  = =  3 
SqrtModPrimeTonelli [ a_, p_] : =  
Module [ { b = Nopresidue (p] , e2 = p - 1 ,  
p - 1 
s = Ip1;eqerExponept [ -- , 2] }  , 
4 
p - 1 
k =  -- ; 
2••2 
scan[ (e2 / =  2 ;  I f [Mod ( I  PowerMod [ b ,  e2 , p ] , p ]  ;. 1 ,  
p - 1 ) 
e2 + = -
2
- ] 
& ,  
Reverse [NestList [Mod [ l2 , p ]  & ,  PowerMod [ a ,  k ,  p] , s ] J ] ; 
( 
k + 1 
) 
e2 
r = Mod [ PowerMod[a ,  -
2
- ,  P] 
• PowerMod [b ,  2 '  p] , p] ; 
Min [ {p - r ,  r} ] ] / ;  Mod [p , 4 ]  = =  1 

SqrtModPrimeTonelli [3 , 5 ]  
SqrtModPrimeTonelli : : noroot 
SqrtModPrimeTonelli [ 3 ,  5 ] 
p = NextPrime [ l0'0 , { l ,  4 } ] i 
a = Mod [ 3 3 1232 , p] i 
SqrtModPrimeTonelli [ a , p] 
3 3 1 2 3  
6.3. QUADRATIC EQUATIONS 
1 97 
3 has no square root modulo 5 .  
An algorithm known as Shanks's algorithm is slightly faster; it is 
discussed in Exercise 6.31. 
Of course, one really wants a general modular square root function that 
will return all the square roots of a modulo n even when n is composite. 
This can be done (Exercise 6.27) by first considering the case that n is a 
prime power (Exercises 6.23-25) and then, in the general case, pasting 
together the results for prime powers by using the Chinese Remainder 
Theorem (Exercise 6.26). If n is a product of many primes, this will be 
impossible; if n has 30 different prime factors, then the number of square 
roots will be 230, or over one billion. Mathematica's standard NumberTheo· 
ryFunctions package comes with a general SqrtMod function, but it does 
not return all the square roots and is not as general as the function you are 
asked to program in Exercise 6.27. A SqrtModAl l function is included in 
the CNT package. Here's an example. 
SgrtMQdA.11 [ 4 , 653989852238983 167 5790] 
{ 2 ,  1 0 5 8 8 4 0 7 1 3 1 4 8 8 2 98 9 0 3 6 8 , 
1 1 2 1 1 2 5 4 6 0 9 8 1 1 1 4 0 0 1 5 62 , 1 5 5 7 1 1 8 6 95 807 1 0 2 7 7 9 94 8 ,  
1 7 4 3 9 7 2 9 3 9 3 0 3 9 5 5 1 13542 , 2 1 7 9 9 6 6 1 74 1 29 9 4 3 8 9 1 932 , 
2 6 1 5 95 94 0 8 9 5 5 9 3 2 6 7 0 3 1 8 , 2 8 0 2 8 1 36524 52 7 8 5 0 0 3 9 1 2 , 
3 7 3 7 0 8 4 8 6 9 9 3 7 0 4 6 6 7 1 8 7 8 , 3 9 2 3 9 3 9 1 13433 8 99005472 , 
4 3 5 9 9 3 2 3 4 8 25 9 8 8 7 7 8 3 8 5 8 , 4 7 95925583085 8 7 65 6 2 24 8 , 
4 9 8 2 7 7 9 8 2 6 5 8 2 7 2 8 8 9 5 8 4 2 , 5 4 1 8 7 7 3 0 6 14 0 8 7 1 7 6 7 4 2 2 8 , 
5 4 8 1 0 5 7 8 0924 1 0 0 1 7 854 22 , 6 5 3 9 8 9 8 5 2 2 3 89 8 3 1 6 7 5 7 8 8 } 
Mod [ \2 , 6539898522389831675790] 
{ 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 } 
While it does not always work, in many cases the built-in Solve function is 
capable of solving polynomial congruences. 
x / .  Solve [ { x13 + 3 x2 == 4 , Modulus == 497 985451829 } ]  
{ 1 ,  6 1 7 6 9 5 3 0 3 9 3 , 1 2 9605760352 , 18834024 8 5 4 6 , 
1 9 1 3 7 5 2 90 7 4 4 , 2 0 8 84 0 7 2 3 0 1 2 , 2 5 0 1 0 97 7 8 9 3 8 ,  2 7 0 6 10253404 } 

198 
6. QUADRATIC RESIDUES 
Exercises for Section 6.3 
6.21. Show that if the sequence an is defined recursively by an 
= c2an-2 + 
c1an-1 with initial conditions aoand a1 , and M is the 2 x 2  matrix ( 0 1 ), 
C2 
Ct 
then Mr ( ao ) = ( a, ). 
a1 
ar+I 
6.22. Write a program that, on input a and n, uses a brute force search to 
return all the mod-n square roots of a between 0 and n. Such a program can 
be used as a check on the more sophisticated and much faster routine 
discussed in Exercise 6.27. 
6.23. Show that if p is an odd prime that does not divide a and if x2 = a  
(mod pn) has two solutions - x = ±t (mod pn) - then x2 = a  (mod pn+l ) has 
exactly two solutions: x = ±(t + kpn) (mod pn+l ), where k satisfies 2kt = 
(a - t2)/ pn (mod p). It follows that for any positive integer n, x2 = a  
(mod pn) has two solutions if and only if a is a quadratic residue modulo p. 
6.24. In this exercise we solve the congruence x2 = a  (mod 2r) when a is 
odd. 
(a) Show that if a is odd, then x2 = a (mod 4) has a solution if and only if 
a = 1 (mod 4), and the solutions in that case are 1 and 3. 
(b) Show that if a is odd, r 2: 3, and x2 = a (mod 2r), then x2 = a  (mod 8) 
[which occurs if and only if a =  1 (mod 8)). 
(c) Show that if a is odd, r 2: 3, and x2 = a  (mod 2r), then there are precisely 
four solutions: ±x and 2r-l ± x. 
(d) 
Show that if a is odd and r > 3 then a particular solution to 
x2 = a  (mod 2r) may be built up from a mod-8 solution using the rule: If 
x2 = a  (mod 2r-l ), then [(x3 + (2 - a)x) / 2]2 = a (mod 2r). 
(e) Explain how (a)-(d) give a complete solution to x2 = a  (mod 2r) when a 
6.25. This exercise concludes the square root algorithm for the case that 
the modulus is a prime power by considering the case that the square is 
divisible by the prime in the prime power modulus. Let p be any prime and 
assume e 2: 1, and 1 s s s e. Show that x2 = mp8 (mod pe), where p does not 
divide m, can be solved as follows. If s = e, then the set of roots is just 
{0, pre121 , 2pfe/21 , ... , pe - pfe/21 }. Otherwise, if s is odd there are no solutions 
and if s is even a solution exists if and only if there is a solution to 
x2 = m (mod pe-s); the solution set is then obtained by taking, for each 
solution y to y2 = m (mod pe-s), the set {p812(y + j pe-s) : j = O, 1, ... , pe/2-l }. 
6.26. Use the Chinese Remainder Theorem to show that if m and n are 
relatively prime then there is a one-one correspondence between solutions 
to x2 = a  (mod mn) and pairs of solutions {y, z} where y2 = a (mod m )  and 

6.3. QUADRATIC EQUATIONS 
1 99 
z2 = a  (mod n). So, if a has s square roots modulo m and t square roots 
modulo n, then there are st square roots of a modulo m n. 
6.27. Write a program that will find all square roots of a (mod m) for any 
modulus m. Use Tonelli's method if m is prime and Exercises 6.23-6.25 for 
prime power moduli. Then use Exercise 6.26 to paste together the results 
for prime powers. 
6.28. Find all solutions of each of the following congruences: 
x2 = 2 (mod 4572) 
x2 = 3 (mod 3724572) 
x2 = 5 (mod 293532) .  
6.29. Fill in the details in the following outline of an algorithm that solves 
ax2 + bx +  c = 0 (mod m) for any integers a, b, and c and modulus m d 2. 
Then implement the algorithm. 
Let f (x) denote the quadratic polynomial. For each prime p that divides 
m, let kp be the largest integer such that pkp divides m. If x is a solution to 
f(x) = 0 (mod m), then x is a solution to f(x) = 0 (mod pkp ). And if we have a 
solution to f (x) = 0 (mod pkp )  for each prime p that divides m, then we can 
use the Chinese Remainder Theorem to construct a unique solution to 
f(x) = 0 (mod m). Thus we can reduce the problem to solving f(x) = 0 (mod 
pk) for any prime p and power k. 
If x is a solution to f (x) = 0 (mod pj+l ), then it must be a solution modulo 
pi. If x is a solution to f(x) = 0 (mod pj), then x + tpj is a solution modulo 
pi+ 1 if and only if 
. 2 
. 
a(x + tp1) + b(x + tp1) + c = 
(ax2 + bx + c) + pj (2axt + b t) + p2j (at2) :: O (mod pj+l ) .  
Because pj divides ax2 + bx + c = f(x), this congruence is satisfied if and 
only if 
f (x) 
-. 
+ t(2ax + b) = 0 (mod p) . 
pl 
This is a linear congruence that has either 0, 1, or p solutions. Given all 
solutions modulo pi ,  the corresponding solutions to this linear congruence 
can be used to construct all solutions modulo pj+l . So we can reduce our 
problem to solving f(x) = 0 (mod p). 
If p = 2, x2 = x (mod 2), so the original problem is equivalent to 
(a + b)x + c = 0 (mod 2), a linear congruence with 0 or 1 solutions. 
If p divides a, the original problem is equivalent to bx + c = 0 (mod p), 
a linear congruence with 0, 1, or p solutions. 

200 
6. CUADRA TIC RESIDUES 
If p > 2 and p does not divide a, then the original problem is equivalent 
to x2 + a-1 bx =  -a-1 c (mod p). We can complete the square on the left: 
All solutions to this congruence are found by finding the square roots (if 
any) of 4-1 a-2 b2 - a-1 c  (mod p) and then subtracting 2-1 a-1 b. It follows 
that this congruence has 0, 1, or 2 solutions. 
6.30. Find a characterization of the set of integers n for which the only 
solutions to x2 = 1 (mod n) are ± 1. Recall from Proposition 2.4 that this fact 
is true when n is prime. 
6.31. Prove that the following algorithm for solving x2 = a  (mod p) works 
and implement it. It is called Shanks's algorithm, and timing tests 
should show you that it is faster than Algorithm 6.2. This is the algorithm 
used by the CNT package. 
Given p prime and a such that a<P-1>12 = 1 (mod p), write p - 1 = 21 q 
with q odd. Let z = hq (reduced mod p), where h is a nonresidue modulo p; 
then z21-1 = - 1  (mod p) by Euler's criterion. All congruences are modulo p, 
and all powers are reduced modulo p. 
Step 1: Define v and w by: v = a<q+ll/2 , and w = aq . 
Step 2a: If w = 1, then v is the desired square root of a. 
Step 2b: Find the least k such that w2• = 1. We know w21-1 = 1, so 
k s t - 1. Update z, t, v, and w to z21-k, k, vz2t-k-1 , and wz21-k, 
respectively, and repeat step 2. 
The algorithm halts because the value of t is decreasing each time. The key 
point in the working of the algorithm is that the following congruences are 
preserved at each step: aw = v2 , z21-1 = - 1, w21-1 = 1. Prove this. 

CHAPTER 7 
Continued Fractions 
7 .0 Introduction 
We began this book with the example of an ancient algorithm for finding 
rational approximations of ../2. We start with a =  b = 1, and simply iterate, 
resetting b -+  a +  b, then a -+  2b - a. The fraction a/ b gives an approxima­
tion to -{"2 that is off by less than 1 / b2 • The following code generates sev­
eral of these approximations. 
nextterm [ r_] : =  
( 
a + 2 b) 
{ a ,  b } = { Humerator [r] , Denominator [r] } " --
a +  b 
fracs = HestList [ next term , 1 ,  8 ]  
{ 
3 
7 
1 7 
4 1  
9 9  
2 3 9  
5 7 7  
1 3 93 } 
1 • 2 '  5 '  IT '  29 '  70 '  1 6 9 ' 408 ' 985 
fracs - Vo 
{ - 0 . 4 1 4 2 1 4 , 0 . 0 8 5 7 8 6 4 , - 0 . 0 14 2 1 3 6 , 0 . 0 0 2 4 5 3 1 ,  - 0 . 0004 20459 , 
0 . 0000 7 2 1 5 1 9 , - 0 . 0 0 0 0 1 23 7 8 9 , 2 . 1239 x l 0 -6 , - 3 . 64404 x l 0 -7 } 
The key to what is happening is to rewrite these fractions as 
1 
1 
1 
1 
1, 1 + -2 ' 1 + --1 ' 1 + 
1 ' 1 + 
1 
' .... 
2 + -2 
2 + --
2 +--
2+-21 
2+-l-
2+i 
These are called continued fractions. They have a very rich structure, 
which we will exploit to solve many number-theoretic questions. They arose 
in the study of Diophantine equations, the Archimedes cattle problem 
(Section 7.5) being one of the most famous examples. These Diophantine 
equations were studied in great depth during the period of classical Indian 
mathematics, roughly CE 500 to 1200, and continue to be of interest to 
researchers in mathematics. In Section 7.6 we will see how continued 
fractions are used to create one of the powerful category·2 algorithms for 
factorizations: CFRAC, or the Continued Fraction Algorithm. 

202 
7. CONTI NUED FRACTIONS 
7 .1 Finite Continued Fractions 
A finite simple continued fraction (we will use simply CF to refer to 
these) has the form 
1 
ao + ----
where each ai is a positive integer and the process terminates. By loading a 
standard package we can generate continued fractions in typeset form. 
Heeds [ " HumberTheory' ContinuedFractions ' " ] ; 
ContinuedFractionForm [ { a ,  b ,  c ,  d ,  e ,  f } ] 
1 
a + ----Ċ--
b +  
1 
C+ 
1 
d+ 
1 
e+f 
It is easy to write a rational, say ̍! , as a CF: 
33 
5 
1 
1 
1 
1 
= 2 + -
14 = 2 + - = 2 + -- = 2 + 
= 2 + 
14 
..! 
2 + .! 
2 + + 
2 + -1-1 
5 
5 
4 
1+4 
Definition. The notation [ao; a1 , a2, ... , an] is used to represent the CF 
1 
ao + -----
al + -----­
a2 + 
Proposition 7.1. Every finite CF represents a rational number. Every 
rational number can be represented by a finite CF. 
Proof. The forward direction is obvious, because we can just simplify the 
fraction. A proper proof uses induction based on the number of terms: 
[ao; al , a2, ... , an] =  ao + !ai ; a2̌ ••• , a. J '  which is a sum of an integer and, by 
an inductive assumption, a rational. For the reverse direction use the 

7. 1 .  FINITE CONTI NUED FRACTIONS 
203 
Euclidean algorithm and induction on the length of the remainder 
sequence. Given a rational a / b, let q and r be the quotient and remainder 
in the first step of the Euclidean algorithm. Then a = q b + r, so a I b = q + 
r / b = q + b=r , and the pair (b, r) has a shorter Euclidean algorithm sequence 
than (a, b), and therefore, by an inductive assumption, b / r has a representa­
tion as a finite CF, and hence so does a / b. 
o 
Note that every rational number has two representations. This is 
because any integer a can be written as (a - 1) + + · Thus, [a0; a1 , a2, ... , an] 
is the same as either [ao; al , a2, ... , an - 1, 1] (if an * 1) or [ao; al , a2, ... , 
an-1 + 1] (if an = 1). 
FromContinuedFraction /0 { { 2 ,  1 ,  3 } , { 2 ,  1 ,  2 ,  1 } } 
{ _!_!_ 
_!_!_ } 
4 , 
4 
The construction of a CF is very reminiscent of the Euclidean algo­
rithm. Indeed, the numbers that show up in a CF appear in the extended 
Euclidean algorithm. The convergents of a CF [ao ; al , a2 , ... , an] are the 
fractions of the form [ao; a1 , a2 , ... , ak] for k = 0, 1, ... , n. The kth conver­
gent, Ck, is often denoted Pk I qk. Here are the convergents for the CF of 
612/233 . 
cf = ContinuedFraction [612 / 2 3 3 ]  
{ 2 ,  1 , 1 ,  1 , 2 ,  9 , 3 } 
Table [Take [cf , i ] , { i ,  Length [cf] } ]  
{ { 2 } ,  { 2 ,  l } , { 2 ,  1 , l } ,  { 2 ,  1 ,  1 ,  l } ,  
{ 2 , 1 ,  1 ,  1 ,  2 } ,  { 2 ,  1 , 1 ,  1 ,  2 , 9 } ,  { 2 ,  1 , 1 ,  1 , 2 ,  9 , 3 } }  
Map [ FromContinuedFraction , \ ]  
5 
8 
2 1  
197 
612 } 
{ 2 • 3 • 2 '  3 '  8 '  75 ' 233 
In fact, a Convergents function lives in the ContinuedFractions 
package. 
Conyerqents [ 6 12 I 2 3 3 ]  
{ 
5 
8 
2 1  
197 
612 } 
2 ,  3 , 2 ,  3 ,  8 ,  75 , 233 
The Ful lContinuedFraction function gives a table showing the 
development of a CF. Comparing such a table with the Euclidean algorithm 
data shows us many connections. 

204 
7. CONTI N U ED FRACTIONS 
FullCont.inuedFract.ion [ 612 / 2 3 3 ]  
FullGCD [ 6 12 , 233 , Ext.endedGCDValues -+ True] 
Partial Quotients 
Convergents 
2 
2 
1 
3 
1 
5 
2 
1 
.! 
3 
2 
!!. 
8 
9 
197 
-:;; 
3 
612 
23 
Remainders 
Quotients 
8 
t 
612 
1 
0 
233 
2 ·  
0 
1 
146 
1 
1 
޿߀· ' 
' . 
87 
1 
- 1  
3 
59 
1 
2 
-5 
28 
2 
- 3  
8 
3 
9 
8 
-21 
'
'
 
1 
3 
-ο5 
19'1 
0 
233 
"'-612' 
We can now see where the continuant function gets its name from. The 
convergents arise from the quotients via the continuant function; this 
follows from the continuant discussion in Section 1.2 and the fact that the 
reversed s- and t-sequences are Euclidean algorithm sequences. The CNT 
function FullContinuant gives us the cumulative continuants. 
FullContinuant. [ { 2 ,  1 ,  1 ,  1 ,  2 ,  9 ,  3 } ]  
{ 6 1 2 , 2 3 3 , 1 4 6 , 8 7 I 59 , 2 8 , 3 , 1 } 
And the numerators and denominators of the convergents come from the s­
and t-sequences, which occur as continuants of the reversed quotient 
sequence. 
FullCoptinuant. [ { 3 ,  9 ,  2 ,  1 ,  1 ,  1 ,  2 } ]  
{ 6 1 2 , 1 9 7 , 2 1 , 8 , 5 , 3 , 2 , l } 
Ful1Coptinuant [ { 3 ,  9 ,  2 ,  1 , 1 ,  l } ]  
{ 2 3 3 , 7 5 , 8 , 3 , 2 ,  1 , 1 } 
Proposition 7.2. (a) The partial quotients in the CF for a/ b are the 
quotients when the Euclidean algorithm is applied to the pair (a, b). 

7 . 1 . FIN ITE CONTI NUED FRACTIONS 
205 
(b) The convergents in the CF for a/ b are Ck = - tk+3 / sk+3, k ) 2, where the 
s- and t-values are those from the extended Euclidean algorithm. 
( c) If the partial quotients in the CF for a/ b are { ak }, then the convergents 
are Pk / qk, where these integers are defined inductively by: 
Po = ao 
P1 = aoa1 + 1 
qi = ai 
Pk = akPk-t + Pk-2 qk = akqk-1 + qk-2 · 
(d) 
For k ) 1, qk ) k. In fact, qk is greater than or equal to the kth 
Fibonacci number. 
Proof. (a) Let q1 = La/ bJ and let r = a  - q1 b. Then q1 is the first Euclidean 
algorithm quotient for (a, b) and a/ b = q1 + 1 / (b / r). Because (b, r) has a 
shorter Euclidean algorithm sequence then (a, b), we may assume induc­
tively that the quotients in the CF for b / r are the Euclidean algorithm 
quotients for (b, r). But the latter are the rest of the Euclidean algorithm 
quotients for (a, b) and the former are the rest of the quotients in the CF of 
a/b. 
(b) Use the continuant function Q from Section 1.2. We claim that 
This suffices because of (a) and the fact that the I s  I- and I t  I-sequences are 
Euclidean algorithm remainder sequences and so are continuant functions 
of the quotients; the match of the indices is as desired because s0 is not part 
of the remainder sequence, while to is, and the sign is right because Sk and 
tk have opposite signs. We prove the claim by induction on k. The induction 
hypothesis is used in the middle equality below, and the inductive defini­
tion of Q is used at the end. 
1 
1 
[a0; a1 , a2 , ... , ai] = ao + [ 
] = ao + 
a1 ; a2 , ... , a; 
Q[a1 , a2 . . . . .  aj ) 
Q[a2 , . . . , a; ]  
ao Q[a1 , a2, ... , ai] + Q[a2, ... , a; ] 
Q[ao, ai , a2, ... , a; ] 
= 
= -----
Q[a1 , a2, . . .  , a;] 
Q[a1 , a2 , . . .  , a;] 
(c) This follows from (b) because the inductive definition in (c) agrees with 
the definition of the s- and t-sequences. 
(d) Part (c) tells us that qk = Q[a2, a3 ,  . • •  , ak], which is clearly larger than 
Q[l, 1, 1, ... , 1] (with k - 1 ls). But this continuant expression was shown in 
Section 1.2 to be the kth Fibonacci number. 
o 

206 
7. CONTIN U ED FRACTIONS 
This inductive definition leads to relatively prime pairs (Exercise 1.18), 
and so we can assume there is no cancellation in the formation of Ck as 
Pk /Qk· 
Proposition 7.3. For a finite CF with convergents Ck = Pk I Qk: 
(a) PkQk-1 - Pk-1 Qk = (-l)k-i _ 
Pk 
.&=lo. -
(-l)k-1 
(b) q;- -
qk- 1 
-
qk qk- 1 • 
k 
(c) _a -
Pk-2 = ak (-l) when k 2: 2 
qk 
qk-2 
qk qk-2 
(d) Co < C2 < C4 < ··· < Cs < C3 < C1 . 
Proof. Part (a) follows from Proposition 7.2(b) and Exercise l.18(e); see 
also Exercise 7.1. For (b) just divide (a) by QkQk-l · Part (c) follows from (a) 
by straightforward algebra (Exercise 7.2). (d). Examining the parity of k in 
(c) tells us that Ck < Ck-2 when k is odd and Ck > Ck-2 when k is even. From 
(b) we get C2k < C2k_1 , and this is sufficient to tell us that every odd-indexed 
convergent is larger than any even-indexed one. 
D 
Parts (b) and (c) can be interpreted as saymg that the differences 
between nearby convergents is small. 
Exercises for Section 7.1 
7.1. Prove Proposition 7.3(a) by induction on k. 
7.2. Prove Proposition 7.3(c). 
7.3. Prove that for any infinite sequence of positive integers {ao, a1 , a2, • • •  }, 
the convergents of the corresponding finite CFs actually converge to a 
single number as k approaches infinity. 
7 .4. Consider the finite CF for a0 = 1 and ai = a2 = · · · = ak = 2. Show that 
Po /Qo = 1, P1 /Q1 = 3/2, and 
Qk = Pk-1 + Qk-1 
Pk = 2qk - Pk-1 . 
7.5. With the same finite CF as in Exercise 7.4, show that 
p6 
(- l)k 
- = 2 -
-- . 
q6 
q6 
Hint: Use the fact that Pk Qk = Pk (pk - Qk-d = Qk (2qk - Pk-d. and then use 
Proposition 7.3(a). 
7 .6. The solar year is 365 ̤: days. The Gregorian calendar that we use 
approximates the fraction by adding 97 days every 400 years (on the leap 

7.2. I N FI NITE CONTI NUED FRACTIONS 
207 
years that occur every fourth year except for years divisible by 100 and not 
divisible by 400, so that 1700, 1800, and 1900 were not leap years, but 2000 
is). Find a better approximation with a denominator smaller than 400. 
7 .2 Infinite Continued Fractions 
Any real number can be decomposed into a single, infinitely long continued 
fraction as follows. Let's use rr as an example. The equation rr = 3 + 1h is not 
exactly true; to make it true, 7 would have to be replaced by a larger num­
ber, whose value we can find by solving 3 + 1/x = rr. This leads to 
x = 1 I (rr - 3) ::: 7 .06251. But we want integers in our continued fraction, so 
we write 7 .0625 ... as 7 + 1 Ix, where x is obtained from 1 / (rr - 3) in the same 
way that 7.0625 ... was obtained from rr. Continue, replacing x by LxJ, and so 
on. In this case, one would obtain, to six terms: rr = 3 + 1 / (7 + 1 / (15 + 1 / (1 + 
1 /(292 + 1/(1 + ... ))))). Using the notation introduced in the preceding 
section, we have rr = [3; 7, 15, 1, 292, 1, ... ]. 
To use the built-in function we need to specify the number of terms. 
Here are some famous continued fractions. 
ContinuedFraction [n, 20] 
{ 3 , 7 , 1 5 , 1 ,  2 9 2 , 1 ,  1 , 1 , 2 , 1 ,  3 , 1 , 14 , 2 , 1 , 1 , 2 , 2 , 2 , 2 } 
Converqents [n, 10] 
2 2  
{ 3 1 7 I 
1 04 3 4 8  
3 3 2 1 5  I 
3 3 3  
3 5 5  
1 0 3 9 9 3  
1 0 6  I 1 1 3  I 
3 3 102 I 
2 0 8 3 4 1 
3 1 2 6 8 9  
8 3 3 7 1 9 
6 6 3 1 7  I 
99532 I 2 6 5 3 8 1 I 
ContinuedFraction [E, 10] 
{ 2 , 1 , 2 , 1 , 1 , 4 , 1 ,  1 ,  6 , 1 } 
ContinuedFraction [../2 , 10] 
{ 1 , 2 ,  2 , 2 , 2 , 2 , 2 , 2 ,  2 , 2 } 
ContinuedFraction [..fl , 10] 
{ 1 , 1 ,  2 , 1 , 2 , 1 ,  2 , 1 ,  2 , 1 } 
ContinuedFraction [GoldenRatio, 10] 
{ l ,  1 ,  1 ,  1 ,  1 , 1 , 1 ,  1 ,  1 ,  1 } 
1 1 4 6 4 0 8  } 
3 6 4 9 1 3  
An infinite simple continued fraction (we will use just CF for these) 
is a continued fraction of the form 

208 
7. CONTINUED FRACTIONS 
which we can refer to as [ao; a1 , a2, • • •  ]. The value of this CF is taken to be 
the limit of the finite approximations (the convergents). Given a irrational, 
we can define the CF [a0; a1 , a2, ... ] for a as follows: Start with a0 = a  and 
let ak = LakJ and let ak+l = 1 /(ak - ak). 
Theorem 7.4. 
Existence and Uniqueness of Continued Fractions 
(a) Every CF is convergent. 
(b) The CF obtained from a real number by using the procedure illustrated 
in the paragraph preceding this theorem converges to the real number. 
(c) Every infinite CF converges to an irrational number. 
(d) The CF obtained from an irrational is the only CF that converges to 
that irrational. 
Proof. (a) Let Ci denote the convergents of [a1 ; a2, a3, . . .  ]. Applying 
Proposition 7.3(d) to the finite approximations tells us that 
This means that the even convergents have a limit, as do the odd conver­
gents. Thus, it remains to show that C2k+l - C2k -+ 0. But this follows from 
Proposition 7.3(d) and (e). 
(b) Because each ak is an integer, induction yields that each ak is irratio­
nal. Therefore, ak < ak < ak + 1 and ak+1 = 1 / (ak - ak) % 1, so each ak is 
positive. Let Ck = Pk / Qk be the kth convergent of 
the infinite CF 
[a1 ; a2, a3, . . .  ]. 
l a - Ck I = l a - :: I 
1(-l)kl 
1 
1 
1 
= ---- < ---- = -- < 
-+ 0 .  
(ak+1 Qk + Qk-1 )qk 
(ak+1 Qk + Qk-1 )qk 
Qk+1 Qk 
k(k + 1) 
(c) 
Suppose that a = [ao; a1 , a2, • • .  ]. Part (a) tells us that a lies between 
each even· and odd-indexed convergent. This, combined with Proposition 
7 .3{b), gives us 0 < a - CP2n I Q2n ) ' < C2n+l - C2n < 1 / (q2n+l Q2n ). It follows that 
0 < aq2n - P2n < 1 I Q2n+l · Now suppose that a is rational, say a =  x/ y. Then 
0 < XQ2n - y P2n < y I Q2n+1 < y /(2n + 1), a contradiction, because the last 
expression converges to 0 as n -+  oo, while XQ2n - y P2n is an integer. 
(d) See Exercise 7.7. 
o 

7.2. I N F I N ITE CONTI NUED FRACTIONS 
209 
The preceding results are not very surprising as they just tell us that 
CFs behave in the way one would hope they would. However, the next 
theorem is more sophisticated, for it gives some surprising information 
about the relationship between a and the convergents of its CF. Note that 
from earlier work - proof of Proposition 7.4(b) - we know that 
la _
_
 
Pk l <
-1 -
Qk 
QkQk+l 
This means that the convergents are very good approximations to the limit. 
For any a it is easy to find a fraction of the form p / q that it is closer to a 
than any other fraction with denominator q: 314/100 is closer to 1C than any 
other p / 100. But in such cases one can state only that p / q will be within 
1 / (2q) of a. The convergents are much closer than this. Look at some of the 
convergents for 1C. 
con = Conyeraents [ n ,  S ]  
{ 
2 2  
3 3 3  
3 5 5  
104 34 8 
3 , --r- · 1 0 6 , 1 1 3 , 
3 3 2 1 5  } 
The third convergent is within 1/i2000 of 1f, consistent with the theory's 
prediction that it should be within 1/i06.113• The next convergent - the 
famous 355/113 - is even better, because it must lie within 1/113.33215 of 1C. 
1 
{Round [ 
333 ] , 106 * 113} 
7f - 106 
{ 1 2 0 1 6 , 1 1 9 7 8 } 
1 
{Round [ ..!.!. 
_ 
n ] , 113 * 33215} 
1 1 3  
{ 3 7 4 8 6 2 9 , 3 7 5 3 2 9 5 } 
The reason that 355/113 is so good is that the fifth partial quotient of 1C is 292, 
which is much larger than average. The next result tells us that rational 
approximations that are especially good must be one of the convergents. 
Note that part (b) refers to Qk, not qō; we can see why by looking at the 
convergents of 1C. The third convergent, 333fi06, is within 1112,000th of 1C, but 
the next convergent, whose denominator is only a little larger (355/113), is 
much better. 
Theorem 7 .5 . (a) If a is irrational, Pk and Qk are its CF convergents, and r 
and s are integers with s >  0 and Isa - rl < lqka - Pkl then s ܳ Qk+l · 
(b) If Pk I Qk is a convergent for a, then Pk I Qk is closer to a than any other 
rational with denominator less than or equal to Qk· 
(c) If la - r / sl < 1 / (2s2 ), then r / s must be a convergent in the CF of a. 

21 0 
7. CONTI NUED FRACTIONS 
Proof. (a) Assume not, so s < qk+l . Consider the following system: 
PkX + Pk+1 Y = r 
qkx + qk+l Y  = s .  
(1) 
The determinant of this system is Pk+ 1 qk - Pk qk+ 1 , which equals (- l)k . This 
means that there is a unique solution for x and y and the solution consists 
of integers (alternatively, use standard techniques to solve the equations 
explicitly). We claim that neither x nor y is 0. For if x = 0, then 
SPk+1 = rqk+1 and so qk+1 divides s, a contradiction. And y = 0 would yield 
that r = Pk x and s = Qk x, implying 
in contradiction to the assumption. 
We next claim that x and y have opposite signs. For if y < 0, then x > 0 
by the second equation in (1). And if y > 0 then, because qk+l is assumed to 
be greater than s, the same equation implies that x is negative. 
Now, convergents alternate, so either Pk I qk < a <  Pk+l I qk+l , or the 
reverse. In either case qk a - Pk and qk+l a - Pk+l have opposite signs. 
Finally: 
Isa - rl = l(qk x + Qk+1 y)a - (pk x + Pk+1 y)I 
= lx(qk a - Pk) +  y(qk+1 a - Pk+ di 
= lxl lqk a - Pkl + IYl lqk+1 a - Pk+1 I 
Ɋ lxl lqk a - Pkl Ɋ I qk a - Pkl 
where the claims about opposite signs are used to get the breakup of abso­
lute values. This is a contradiction. 
(b) 
Suppose la - r/sl < la - pk fqkl and s s qk. Then lsa - rl < lqk a - pkl, 
which contradicts (a). 
(c) If not, we can find consecutive convergents, say the kth and (k + l)st, so 
that qk s s < qk+l · Then, by (a), we can say that 
which implies that 
We know that IBPk - rqkl ģ 1 because it is an integer and not 0 (r/s * 
Pk I qk). Therefore 

1 
--
$ 
7.2. I N FI N ITE CONTI N U ED FRACTIONS 
21 1 
So 1 /(2sqk) < 1 / (2s2), or qk > s, a contradiction. 
o 
Exercises for Section 7.2 
7.7. 
Prove Proposition 7.4(d). Hint: Suppose that a =  [ao; a1 , a2, • • •  ] = 
[bo; b1 , b2, ... ]. First show that ao = bo, and then use induction to show that 
each ak = bk. 
7.8. 
If a >  1 and a =  [ao; ai, a2, • • •  ], then 1 /a = [O; ao, ai . a2, • • •  ]. The 
convergents of 1 I a are the reciprocals of the convergents of a. 
7.9. Use continued fractions to find some good rational approximations to 
log2 3. This number and its rational approximations are relevant to the 12-
tone scale used in western music; see [DM]. 
7 .10. Hurwitz proved that for any rational number a, there are always 
infinitely many convergents to a, Pk I qk, such that 
I 
Pk 
I 
1 
q; - a < qō ../5 
. 
For T, the golden ratio (which is (1 + ../5)/2), find an infinite set of conver­
gents that satisfy the inequality. Hints: First use Proposition 7.2(b) to see 
that the convergents for T are ratios of Fibonacci numbers. Also Binet's 
formula (Proposition 1.1) will be useful. 
7.11. Show that the inequality of Exercise 7.10 is the best possible in the 
sense that if c > ../5, then there are at most finitely many convergents to 
the golden ratio for which 
I Pk - Tl < _1_ 
qk 
cqō 
7.12. Show that the inequality of Exercise 7.10 is not the best possible for 
all irrationals. In particular, prove that there are infinitely many conver­
gents to "2 for which 
l_
Pk - "21 < _1 _ 
qk 
../8 qō 
7.13. Let Pk I qk be a convergent to a =  [a0; a1 , a2, • • .  ]. Show that 

21 2 
7. CONTI NUED FRACTIONS 
Pk = det 
ao 
1 
0 
-1 0 
ai -1 
1 a2 
0 
0 
0 
0 
0 
0 
ak-1 
0 
0 
0 
1 
Find a similar expression for qk. 
0 
0 
0 
- 1 
ak 
7.14. Let a =  [ao; a1 , • • •  , an]. Show that for k >  0 
rak + s  
a =
--­
tak + u  
where 
7.15. If {3 is a positive real number, a0, a1 , • • •  are positive integers, and n is 
odd, show that 
Is this ever true if n is even? 
7.16. Let a be a real number chosen uniformly at random from the interval 
(0, 1) and let [O; a1 , a2, • • •  ] be its continued fraction. Given a positive integer 
m, what is the probability that a1 > m? What is the probability that a1 = m? 
7 .17. Given a as in the preceding exercise, show that the probability that 
a2 2: m is 
Find the probability that a2 = 1. 
7.18. Let d be a positive integer that is not a perfect cube. Show that if 
(xo, y0) is a solution in positive integers to x3 - dy3 = n and 
if 
Yo > 2 1 n I Id 213, then x0 I y0 is a convergent to d1'3 . Hint: Factor xg - d yg. 

7.3. PERIODIC CONTI N U ED FRACTIONS 
21 3 
7 .3 Periodic Continued Fractions 
Our goal in this section is to prove one of the prettiest theorems about 
continued fractions (discovered by Lagrange): a CF is periodic if and only if 
it represents a quadratic irrational number. A quadratic irrational is an 
irrational real number that is a root of the quadratic polynomial 
Ax2 + Bx +  C, where A, B, and C are integers. This polynomial will have 
two roots, and the other one is called the conjugate of a, denoted a. 
Proposition 7 .6 . (a) Every quadratic irrational a can be written as 
(a + ../b )/ c, where a, b, and c are integers and b is not a perfect square. 
(b) The conjugate of (a + ../b) / c is (a - ../b) / c. 
(c) If a is a quadratic irrational, so is (ma + n)/(sa + t), where m, n, s, and t 
are integers. 
(d) a +  /3 = a +  73. 
(e) af3 = a 73. 
(f) arp = a (/3. 
(g) Every quadratic irrational a can be written as (X + Yd)/ Y where X, Y, 
and d are integers, Y -:/=  0, d is not a square, and Y divides d - X2• This 
representation is called a normal form of a (but it is not unique: ../2 /2 = 
i/8 / 4). Note that X or Y might be negative. 
Proof. (a) The use of the quadratic formula in the following computer 
solution shows that (a + ../b) / c is a quadratic irrational. 
x / .  Solve [ c2 x2 
- 2 a c x + (a2 - b) = =  O ,  x ]  
{ a - Vb 
a + ../b } 
c 
, 
c 
And it is easy to see from the quadratic formula that if a is a root of the 
quadratic equation Ax2 + Bx +  C, then a has the desired form. 
(b) This follows from the quadratic formula. This allows us to program a 
QuadraticConj ugate function to switch the sign of any square roots. This 
is done in the CNT package. 
OuadraticConj ugate [ a + Vb] 
a - Vb 
(c) We can use Quadraticcon j ugate to prove this. 

21 4 
7. CONTI NUED FRACTIONS 
a =  (a + Vb) / c ;  
f3 = Simplify [ (m a  + n )  I ( s  a + t ) ) 
a m + .,/b m + c n  
a s + .,/b s + c t  
Now we multiply top and bottom by the conjugate of the bottom; the result 
has the proper form. 
qc = OUaclraticCopjugate [Denominator [/3 ) )  ; 
EzpandDenominator[ 
Collect [Numerator [/3] qc , Vb) /  (Denominator [/3 ) qc) ) 
a2 m s  - b m s +  a c n s + a  c m  t + c2 n t + .,/b ( -c n s + c m t) 
a2 s2 - b s2 + 2 a c s t + c2 t2 
Parts (d)-(f) can be proved by easy algebra. Here is one approach to (f). 
a =  (a + ../b) / c ;  
13 =  (d + Ve) / f ;  
OuadraticCopi ugate [a / /3 ) 
(a - .,/b ) f 
c (d - Ye) 
QyadraticCopi ugate [a) / QuadraticConj ugate [ fJ ]  
(a - .,/b ) f 
c (d - Ye ) 
(g) 
We know by (a) that a = (a + ..fb)/c. Then a = (alcl + -v'be2)/Cclcl), 
which satisfies the desired conditions; in particular, d - X2  = bc2 - a2 c2 ,  
which is divisible by c2. 
o 
This normal form of part (g) is easily implemented; the CNT package 
function QuadraticNormalForm gives a triple {X, d, Y} that represents a 
given quadratic irational in a normal form. 
3 1  
2 ..rm 
{ X, d ,  'f }  = QuadraticRormalrorm [a = -- -
) 
178 
3 
{ 14 16 14 1 7 2 7 2 , 5 1 7 20 2 0 1 2 2 8 9 842 9 9 5 8 3 8 9 7 6 ,  8 1 3 1 3 9 4 4 3 3 6 } 
The built-in RootReduce function transforms quadratic irrationals to a 
slightly different normal form. This allows us to check the preceding result. 
RootReduce[ {a ,  (x + ..fd) /Y} J 
{ 5Ǡ4 ( 93 - 1 4 2 4  ..[i ) ,  5ǟ4 ( 93 + 1 4 2 4  ../1f) } 

7.3. PERIODIC CONTI NUED FRACTIONS 
21 5 
Theorem 7.7. Periodicity of Quadratic Irrational CFs The CF corre­
sponding to a quadratic irrational is eventually periodic; conversely, every 
CF that is eventually periodic converges to such a real. 
The fact that periodic CFs represent quadratic irrationals is easy to 
understand. Consider the periodic CF [1; 2, 1, 2, 1, 2, 1, 2, ... ], which we 
can denote by [1; 2]. If this represents a, then 
1 
a = l + -- . 
2 +  _!._ 
a 
But the right side quickly simplifies to a rational expression in a. 
1 
Map [Together, a == 1 + 
--1
- ] 
1 + 3 a 
a = = _1_+_2_a_ 
2 + -
a 
And this means that a is a root of a quadratic equation. The general proof is 
no harder than simplifying the CF as we did in this example. The other 
direction, going from a quadratic irrational to a periodic CF, is more diffi­
cult and relies on recognizing certain patterns in the sequences of remain­
ders ai that show up in the construction of a CF. 
Proof of Theorem 7. 7. 
We do the easier direction first. Suppose 
[a0; a1 , a2, . . •  , a8, b1 , b2, . . .  , bn] converges to a. It suffices to show that the 
periodic part represents a quadratic irrational, because the effect of the 
nonperiodic part is simply to add integers and invert, properties that leave 
one in the domain of quadratic irrationals by Proposition 7.6(c). So let 
/3 = [b1 ; b2, . . .  , bn1· Then /3 = [b1 ; b2, b3, ... , bn, /3), a finite CF, albeit one 
having a noninteger as its last entry. Collapsing the finite CF leads to an 
expression of the form (i/3 + j) I (k/3 + l ). We can be more precise by using 
Proposition 7.2(c), which tells us that the convergents give us the exact 
relationship: 
/3 = Pn+l 
= Pn /3 + Pn-1 
qn+l 
qn /3 + qn-1 
Because the P· and q-values are integers, this simplifies to a quadratic 
equation having /3 as a solution, which is what we want. We know that f3 
(and hence a) will be irrational by Proposition 7.4(c). 
It remains to show that a quadratic irrational having the normal form 
a =  (Xo + ..fd) / Yo leads to a periodic CF. This will be done by means of an 
algorithm. Consider the following inductive definitions of ak, ak and inte­
gers Xk, Yk: 

216 
7. CONTI N U ED FRACTIONS 
Uk = Xk;V: 
ak = LakJ 
Xk+ 1 = ak Yk - Xk 
Yk+l = Yk-1 + ak(Xk - Xk+d; except : Y1 = d;.l . 
Note that Y1 is an integer because Yo divides d - XJ and X'f = X6 (mod Yo). 
One could define Yk+l to be (d - Xf+1)/ Yk; but, for computation, it is always 
wise to avoid division when possible. Note that Xk or Yk might be neܲtive. 
Here are the first few values of these sequences for the case of ( 2 - V 2 ) / 4, 
which has the normal form (128 + v' 8192 ) / 256. 
fX, Y} 
a 
Partial Quotients Convergents 
(128,.256} 
l- 128, -32} 
. .  {96; 82} 
128+Vill9i 
266 
-128+޾ 
ݘ112 
96+./iji: 
82 
We will show that: 
1. Yk :#: O and Yk+1 = (d - Xf+1)/ Yk. 
0 
1 
0 
1 
5 
6 
6 
7 
.![ 
4l 
2. Yk divides d - Xf. [Because Yk divides d - Jq+1 and 
Xk+1 = -Xk (mod Yk).] 
3. (Xk + v'd) I Yk is a normal form of ak . [By (2).] 
4. ak+l = 1 / (ak - ak). 
5. The ak are the partial quotients of the CF for a. [By (4).] 
6. 0 < Yk for sufficiently large k. 
7. Yk :s d for sufficiently large k. [Use (6). If Yk > 0 beyond N, then for 
k 2: n we have Yk :s Yk Yk+l = d - Xf+1 :s d.] 
8. -v'd < xk < {d for sufficiently large k. 
9. The pairs {Xk, Yk} must repeat at some point. [By 6, 7, and 8, there 
are only finitely many possiblilities.] 
10. The ak must repeat at some point. [By (9).] 
11. The ak must repeat at some point. [By (10).] 
Before completing the ,..Proof, let us look at some data. The following 
table shows that a =  1 + v 3 / 2 leads to X4 and Y4 that agree with X2 and 

7.3. PERIODIC CONTI NUED FRACTIONS 
21 7 
Y2 ; the repetition is shown in bold. Thus, the CF for a consists of the preperi­
odic part {1, 1} followed by repetitions of 6, 2; in short, a =  [1; 1, 6, 2] 
Ful lContinuedFraction [ 1 + ..J3 / 2] 
{X, Y) 
a 
Partial Quotients 
{ 16, 16) 
111+..J192 
1 
16 
{0, 12) 
./Ui2 
1 
-12-
{12, 4} 
1 2+"192 
6 
4 
{ 12, 12) 
12+v°l92 
2 
12 
{12, 4} 
12+ {192 
6 
4 
Periodic Form: 
(( 1 1 1 6 2 )) 
Convergents 
1 
2 
.! 
7 
28 
15 
181 
97 
We can get such periodic forms directly using the built-in Continued­
Fraction. 
ContinuedFraction [ 1 + VJ / 2] 
{ 1 , 1 ,  { 6 ,  2 } } 
And we can check our answers by going in the other direction. 
FromContinuedFraction [ { 1 ,  1 ,  { 6 ,  2 } } )  
2 ( 2 + '13) 
Perhaps the simplest periodic CF is [I]. It is not hard to see that it repre­
sents the golden ratio because of x = 1/(1 + x). 
FromContinuedFraction [ { { l } } ]  
2 ( l nfs ) 
We now return to the proof of claims 1-11. Only 1, 4, 6, and 8 remain to be 
proved. 
1. Use induction on k as follows. 
Ykak = xk + Xk+I 
Yk+1 - Yk-1 = X - X 
ak 
k 
k+l 
(by the definition) 
Yk(Yk+1 - Yk-d = Xt - Xt+i (multiply preceding equations) 
Yk-1 Yk 
= d - x: 
Yk Yk+1 = d - X:+i 
(the induction hypothesis) 
(add preceding two equations) 

21 8 
7. CONTI NUED FRACTIONS 
Because d cannot equal the perfect square .X:+i • Yk+ l is not 0, which proves 
point 1. 
4. ak+l = Xk+1 + ...fd 
Yk(Xk+1 + 4<f) 
Yk(Xk+1 + 4<f) 
= 
= 
Yk+1 
Yk Yk+1 
d - Xt+1 
yk 
yk 
1 
1 
= 
= 
= 
= 
4<f - Xk+1 
..fd - ak Yk + Xk 
Xk+..fd 
ak - ak 
- ak 
yk 
6. By (4), (5), and the proof of Proposition 7.4(b), a =  [ao ; al , a2 , . . .  , ak, ak]. 
Letting Pk /qk be the convergents of this CF, Proposition 7.2(c) tells us that 
Pk-1ak + Pk-2 
a = ----
We can take conjugates throughout, solve for "lfk, and see what happens as k 
gets large. The first step is accomplished by the two substitutions in the 
code that follows. 
Pk-1 ak + Pk-2 
ak / .  First [ Solve [a == 
/ .  { a -+ ii, ak -+ ak } ,  ak ) )  
Cb:-1 ak + Cb:-2 
Pk-2 - a qk-2 
a qk-1 - Pk-1 
This quantity is the same as the following 
(ii - .!l!=L ) 
[ 
qk-Z 
'h 2 
Simplify \ - --
-
Cb:-1 (ii - h:!.. ) 
2 ( P-2+k - a q-2+k ) 
-P-1+k + a q-1+k 
'h- 1  
But because the convergents approach a, this approaches 
qk-2 (a - a) 
. 
qk-2 
- --
or Just - --
qk-1 (a - a) ' 
qk-1 
Because qk-1 > qk-2, this last fraction is less than - 1. Therefore, there is an 
N such that "l:fk < 0 whenever k 2: N. But ak > 0 by (4). So 0 < ak - "l:fk  = 
2 ..fd / Yk , as desired. 
8. If k is large enough that Yk and Yk+1 are positive, then 0 < Yk Yk+l = 
d - Xt+1 , so lq+1 < d. 
o 

7.3. PERIODIC CO NTI N U ED FRACTIONS 
21 9 
The preceding proof yields an algorithm for getting the exact periodic 
CF for any quadratic irrational: Form the sequences of X and Y values and 
check for a repeat. It must occur eventually. This is how Mathematica's 
ContinuedFraction function is able to find the periodic forms, though 
that built-in algorithm uses some storage tricks to speed up the compari­
sons with past values. 
The following table shows the periodic CFs for the simple square roots. 
These will play a critical role in the solution to the Pell equation, discussed 
in detail in the next section. 
i V2  
{ l , { 2 } }  
I ..j3 
{ l , { l , 2 } } 
-J4 
2 
..rs 
{ 2 ,  { 4·} } 
../6 
{ 2 , { 2 , 4 } } 
..fi 
{ 2 , { l ,  1 ,  1 ,  4 } } 
I 
I 
1 rs I 
{ 2 , { l ,  4 } }  
: -f9  1 3  
I 
.
.
 
i ../10 
{ 3 , { 6 } } 
..[IT 
{ 3 , { 3 , 6 } } 
! -{IT 
{ 3 , { 2 ,  6 } } 
../IT 
{ 3 , { l , 1 ,  1 ,  1 ,  6 } } 
-{14 { 3 , { l , 2 ,  1 ,  6 } } 
../ls 
{ 3 , { 1 ,  6 } } 
-./16 
4 
! 
I 
i 
I 
; ffi  { 4 ,  { 8 } } 
i 
-.f8 
{ 4 , { 4 , 8 } } 
! 
..[19 l
.
{ 4 ,  { 2 ,  1 ,  3 , 1 ,  2 ,  8 } } I 
1 ../20  { 4 ,  { 2 ,  8 } } 
I 
' 
. 
You may not see any obvious patterns, but in fact there are several. For 
square roots near perfect squares the patterns are quite striking. 
ξ 
../3 
{ l , 
..f8 
{ 2 , 
! YlS  
{ 3 , 
I 
I VIT  
{ 4 , 
{ l ,  2 } } 
{ l ,  4 } } 
{ 1 , 6 } } 
{ l ,  8 } } 
1 ../5  
../IO 
ffi 
1 .../26 
{ 2 ,  { 4 } } 
1 { 3 ,  
{
6 } }  
{ 4 , { 8 } }  
I { 5 I { 1 0 } } . 

220 
7. CONTI NUED FRACTIONS 
¡--n=·-· ··----1 
: -12  
1 {1, {2} }  
! 
I 
. 
I 
-J7 
I { 2 ,  { 1 , 1 ,  1 , 4 } } , 
I 
, 
I VIT 
l {3, {1, 2, 1, 6} l l 
L!!I 
̇i_̈ · -̉· 1 ,  8 }  } 
__ j 
{ 2 ,
{ 2 , 4 } }  
{ 3 , { 3 ,  6 } } 
{ 4 ,  { 4 ,  8 } } 
{ S ,  { S ,  10 } } 
i7̊2-_-4̋,-
· ·
·
-----··-·· ---1 : ̕ I 
' 
i -[O  
{ O } 
l 
! Vs  
{ 2 ,  { 4 } }  
I 
i 
-112 
{ 3 , {2, 6} } 
I 
ff! 
{ 4 ,  { 1 , 1 ,  2 ,  1 ,  1 ,  S } }j 
[ ,/32  
{ S , { l , l , 1 , 1 0 } }  
; -145 
1 { 6 , { l ,  2 ,  2 ,  2 , 1 ,  1 2 } l 
: ..f60  
1 { 7 ,
{ 1 , 2 , 1 , 1 4 } } 
' 
_____ _! _ _  
. 
--
--·----
- -
I -18 
i w 
; 
i {20 
I ..(29 
..[40 
Ys3 
-{68 
·
·-·- .. 
{ 2 ,  { 1 ,  4 } } 
{ 3 , { l ,  1 , 1 ,  1 , 6 } } 
{ 4 ,  { 2 , 8 } } 
{ 5 ,  { 2 , 1 , 1 , 2 , 1 0 } } 
{ 6 , { 3 , 12 } }  
{ 7 , { 3 ,  1 ,  1, 3 ,  1 4 } } 
{ 8 , { 4 , 1 6 } }  
·
-
·--
I 
I 
Figure 7 .1 shows the period lengths for the CFs of {Ti .  It has been sug­
gested by H. C. Williams [Will] that the period-length is bounded by approx­
imately {Ti log(log( 4n)); Yn log(log( 4 n)) + 1, whose graph is superimposed 
on the data in Figure 7.1, does the job up to n =  1000. 
CPPeriodLength [ z_] 
: = Length [ContinuedPraction [ z] [- 1] ] i 
ListPlot [±able({n ,  CPPeriodLength [Vn] } , { n ,  1 ,  1000 } ] ] i 
6 0  
5 0  
4 0  
3 0  
2 0  
1 0  
0 t ' 
• 
• 
• 
• 
•
•
 
• 
• 
• 
. • • 
. 
. . . 
. ... . . 
. 
. 
. 
·. 
. 
.. . . 
. 
.· . ·'- · 
. . 
- . . . 
. 
. . .  
-
. . .  
. . . 
,, . ·... 
. ޼ . 
. 
. 
' . ... 
. 
. . . . . 
. 
• • • • 
• •• 
• •• • 
•• • .. !I . • 
·. . .. . 
- ... . ̖ · . , l • 
• " 
• 
• 
-
• 
,, 
... 
• .. 
• -
• • 
.. 
• 111. .. .  
· · -
. . . ... . .. =- - · · ޽· ·  -
,
..-,.,.. . 
. 
,.,, . .  
. 
,.̗ \c:r:_;{ǚ:fi;;, t-:iǔǕ ǖ bTǗǘǙ;:..:;4; 'IĬ 
. 
·Y!'r"-=-,..-ar;r-i-Ǜi=rrǜ-.ǝǞ,.-:-r-.,- r·" 
0 
2 0 0 
4 0 0  
6 0 0  
8 0 0  
1 0 0 0  
Figure 7 . 1 .  The period lengths of the continued fractions of .fn ,  for n up to 1000. 
The longest period is 60, for ..,/ 919 and ..,/ 991 , and the period-lengths are bounded 
by {n log(log(4 n)) + 1 in this range. 
The next theorem summarizes some properties of CFs of {Ti that will 
be important in the next section. These results are esthetically pleasing as 
they explain several features of these CFs that jump out when one does 
computations; for example, it always takes exactly only one step to reach 
the periodic part. And they are important algorithmically, as we will dis­
cuss after the proof. 

7.3. PERIODIC CONTI NUED FRACTIONS 
221 
Theorem 7.8. (a) The quadratic irrationals that are purely periodic -
that is, have the form [a0; a1, ... , an] - have a simple characterization: A 
quadratic irrational a has a purely periodic CF if and only if a > 1 and 
- 1 < CY < 0. 
(b) If a is purely periodic, then so is -1 / a, and its periodic part is the 
reverse of that of a. 
(c) The CF of i.f1t has the form [ao; ai , a2, ... , ar. 2ao] where each a; s ao. 
Moreover, the sequence a1 , a2, • • •  , ar is symmetric about its center. 
Proof. The proofs of (a) and (b) are somewhat long, and we refer the reader 
to [NZM] or [Ros]. However, part (c) can be quickly derived from (a) and (b). 
Let ao = L i./1t J; then, by (a), -{Ti, + L -{Ti, J is purely periodic. So we have 
rn + ao = [2ao. ai . a2, ... , ar] 
= [2ao; ai , a2, ... , ar, 2ao, ai , a2, ... , ar] 
(2) 
(3) 
For the palindromic result, let a1 = 1 / (Vn - a0). Apply (b) to (2) to get 
a1 = [an ar-1 . ... , ai , 2ao]. But (3) tells us that i./1t -a0 = [0; a1 , a2, ... , ar. 
2ao], whence a1 = [a1 , a2, ... , ar, 2ao]. Comparing the two representations 
of a1 yields the palindrome. 
It remains to prove that ai s a0• Suppose that the CF of Yd is 
[ao ;  a1 , ... , an 2a0]. We claim that when 0 < i < r, ai s a0• To prove this, we 
first claim that Yi * 1 when 0 < i < r. Using the notation of the proof of 
Theorem 7.7, recall that, for -{Ti,, X0 = 0, Y0 = 1, and X1 = a0. Now suppose 
that Yi = 1. Then 
ai = Xi + Yd; and then ai = Lad = ao + Xi . Then 
Xi+1 = ai Yi - Xi = ao + Xi - Xi = ao = X1 
and 
Yi+ i 
= d - Xf+i = d - aЅ = Y1 • 
This means that periodicity in the quotients starts with ai+l • which contra­
dicts our hypothesis that periodicity starts at r + 2. Now, knowing that 
Y; 2: 2 and using the fact from Theorem 7. 7's proof that Xi < ..Jd, tells us 
that 
2-Yd 
<
--
2 
which means that ai s l ..Jd J = ao. 
D 
Part (c) has interesting consequences for a computation of the periodic 
form of the CF of Yd .  One could use it in a direct manner, by computing 
the CF until 2a0 shows up. But this requires knowing Yd to a certain 
precision, and we do not know that precision in advance. It is better to 
interpret part (c) as follows: Compute the Y-sequence until Yr = 1 shows up 
for a second time. Then the periodic form of the CF of Yd is 

222 
7. CO NTINUED FRACTIONS 
[ a0; a1 , a2, ... , ar- I , 2a0 ]. The relationships of the proof of Theorem 7. 7 tell 
us how to compute the Y-sequence, but here is an important simplification: 
do not use ak = (Xk + '1d) I Yk and ak = LakJ to get ak. Rather use ak = 
L(Xk + ao)/ YkJ . 
We leave it as an exercise to show that for CFs of "'1, 
(see Exercise 7.21). The advantage is that this eliminates real-number 
arithmetic from the computation of the sequences {ad, {Xd, and { Yd; the 
numerical value of Yd gets used once only, to find a0 = L '1d J. Because the 
CF of pure square roots arises often (Pell equation, factoring algorithms), 
this yields an important speed-up. Mathematica has a ContinuedFrac­
tion function that does this, but here is complete code anyway, to show 
how to optimize in the case of a pure square root. Note the use of Quo­
tient, as that is faster than dividing in cases where the integer quotient is 
what is wanted. And we avoid the slow Append, using an ans = { ans , q} 
construction instead, flattening at the end. 
CFSqrt [d_] : = 
Module [ { k = 0 ,  P = 0 ,  Q = 1 ,  a = Floor [ Vd] , ans} , ans = { a }  ; 
While [ P  = Last [ans ] Q - P ;  Q = Quotient [d  - P2 , Q] ; 
ans = { ans , Quotient [P  + a , Q] } ; k = 0 1 1 Q ʚ 1 , k + + ] ; 
{ a ,  Rest [Flatten [ans] J }] / ;  ! IntegerQ [Vd] 
CFSqrt [ 9 1 9 ]  
{ 30 , { 3 , 5 , 1 ,  2 , 1, 2, 1, 1, 1, 2, 3 , 1 ,  1 9 , 2 ,  3 , 1, 1, 4 , 9 , 1, 7 , 
1 ,  3 , 6 , 2 ,  1 1 , 1 ,  1 ,  1 ,  29 , 1 ,  1 ,  1 ,  1 1 ,  2 , 6 , 3 , 1 ,  7 , 1 ,  9 , 
4 , 1 ,  1 ,  3 , 2 ,  1 9 , 1 ,  3 , 2 ,  1 ,  1 ,  1 ,  2 ,  1 ,  2 , 1 , 5 , 3 , 6 0 } }  
And here's an example that arises in the puzzle of Archimedes that will be 
discussed in Section 7.5. 
CFSqrt [ 47 29494] 
{ 2 1 7 4 , { 1 ,  2 , 1 , 5 ,  2 , 2 5 , 3 , 1 ,  1 ,  1 ,  1 ,  1 ,  1 ,  1 5 , 1 ,  2 ,  1 6 , 
1 ,  2 ,  1 ,  1 ,  8 ,  6 , 1 ,  2 1 ,  1 ,  1 ,  3 , 1 ,  1 ,  1 ,  2 , 2 ,  6 ,  1 ,  1 ,  5 , 
1 ,  1 7 , 1 , 1 ,  47 ,  3 , 1 ,  1 ,  6 , 1 ,  1 , 3 , 4 7 , 1 ,  1 ,  1 7 , 1 ,  5 , 1 ,  
1 ,  6 , 2 ,  2 , 1 ,  1 ,  1 ,  3 , 1 ,  1 ,  2 1 ,  1 ,  6 , 8 , 1 ,  1 ,  2 ,  1 , 1 6 , 
2 ,  1 ,  1 5 , 1 ,  1 , 1 ,  1 ,  1 ,  1 ,  3 , 2 5 , 2 , 5 , 1 ,  2 ,  1 ,  4 3 4 8 } }  
We can now prove many of the patterns in the CFs of rn. For example, 
the cases where the period-length is 1 or 2 are easy to discover. The next 
result shows how symbolic algebra can lead to automated proofs of many of 
these patterns. 
Proposition 7.9. (a) The CF of Yn has period-length 1 if and only if 
n = r + 1. The CF then is [r; 2r]. 

7.3. PERIODIC CONTI NUED FRACTIONS 
223 
(b) Given n, a nonsquare, let r = l {n j; then n = r2 + k, where O < k s  2r. 
The CF of -{Ti has period-length 2 if and only if k divides 2 r. 
(c) The CF of ܴ is [r - 1; 1, 2 r - 2). 
(d) The CF of ../ r2 + 2 is [r; r,2r]. 
(e) The CF of ܵ is [r - 1; 1, r - 2, 1, 2 r - 2) if r 2: 3. 
(f) The CF of ..J"r2+4 is [r; r;1 , 1, 1, r;1 , 2r] if r is odd and r 2: 3. 
(g) The CF of ../ r2 + 4 is [r; f, 2r] if r is even and r 2: 2. 
(h) The CF of ܶ is [r - 1; 1, ¥. 2, ¥. 1, 2 r - 2] if r is odd and r 2: 5. 
(i) The CF of ..,/ r2 - 4 is [r - 1; 1, ¥. 1, 2r - 2] if r is even and r 2: 6. 
(j) The CF of ../ r2 + 8 is [r; rŽ2 , 1, 1, r;2 , 1, 1, rŽ2 , 2 r] if r = 2 (mod 4) and 
r 2: 6. 
(k) The CF of ../ r2 + 8 is [r; f, 2r] if r = 0 (mod 4). 
(1) The CF of ܷ is [r - 1; 1, rŽ6 , 2, r;2 , 2, rŽ6 , 2r - 2] if r = 0 (mod 4) 
and r 2: 10. 
(m) The CF of ܸ is [r - 1; 1, rνs ,  1, 2r - 2] if r = 0 (mod 4) and r 2: 12. 
Proof. In all the proofs we will make use of Theorem 7.8, which tells us the 
general form of the CF of ..Jn. Thus, in (a), we know that the CF must look 
like [r; 2 r]. So we can set up a quadratic equation by observing that if 
1 
x = 2r +
---
2 r  + 
1 
2r+ 2,! ... 
then x = 2 r +  1/x and [r; 2 r] = r +  1/x. We can now easily solve for x, squaring 
the result. 
1 
1 
)2 
FullSimplify [ (r 
+ --;- / .  Solve[ x = =  2 r 
+ -; , x ]  ] 
{ 1 + r2 , 1 + r2 } 
This proves (a) because of uniqueness of CFs for irrationals. For the remain­
ing parts we can automate the symbolic algebra just outlined. The following 
routine takes a CF in the form {a1 , a2, ... , an, {b1 , b2, ... , bn ll and returns 
the square of the quadratic irrational it represents. This routine can be 
extremely helpful in discovering patterns in CFs. 

224 
7. CONTI NUED FRACTIONS 
FromCFSquared [a_] : = Module [ { z ,  periodicsoln , radical } ,  
periodicsoln = 
z / .  Solve [ x == FromContinuedFraction [Append [ a [- 1] , x ] ] ,  x ]  J 
radical = Expand [FromContinuedrraction [ 
Append [Drop [ a ,  - 1 ] , periodicsoln [2] ] ] ]  J 
RootReduce [PullSimplify [ radical2 ] ] ]  
Now we have a one-line machine proof of part (a). 
FromeFSquared [ { r ,  { 2  r} } ] 
r2 + 1 
Here is a proof of part (b). 
FromeFSquared [ { r ,  { a ,  2 r} } ] I I  Expand 
r2 + 2 r 
s 
And here are proofs of (c)-(i). The extra conditions in (e)-(i) follow from the 
form of the CF in each case. 
FromCFSquared [ { r - 1 ,  { l ,  2 (r - 1 ) } } ] 
r2 
- 1 
FromeFSquared [ { r ,  { r ,  2 r} } ] 
r2 + 2 
FromeFSqpared [ { r - 1 ,  { l ,  r - 2 , 1 ,  2 ( r - 1 ) } } ]  
r2 
- 2 
The next two cases each break into subcases depending on the parity of r. 
From,CFSquared [ { r ,  { (r - 1 ) / 2 , 1 ,  1 ,  ( r - 1 ) / 2 , 2 r} } ] 
r2 + 4 
FromeFSquared [ { r - 1 ,  { l ,  ( r - 3 ) / 2 , 2 ,  ( r - 3 ) / 2 , 1 ,  2 ( r - 1 ) } } ] 
r2 
- 4 
From,CFSqpared [ { r - 1 ,  { l , ( r - 4 ) / 2 , 1 ,  2 ( r - 1 ) } } ] 
r2 
- 4 
FromCFSqpared [ { r ,  { r  I 2 ,  2 r} } ] 
r2 + 4 
The ,,/ r2 ± 8 cases are left as exercises. 
o 

7.3. PERIODIC CONTI NUED FRACTIONS 
225 
There are many, many other patterns in CFs and, armed with the 
symbolic CF-reverser, one can find and prove them (see Exercise 7.26). The 
next fact about the convergents of CFs of pure square roots will be useful in 
subsequent sections. 
Proposition 7 .10. Let Pk / qk be the kth convergent in the CF of ..Jn, 
where n is not a perfect square. If Yk is as in Theorem 7.7, then p - nq = 
(- l)k-l Yk+1 . 
Proof. Letting ak denote the partial quotients and ak denote l /(ak-1 -
ak-l ), we have the following two equations. 
We can simplify the first equation using the second as follows . 
• r 
Pk ak.1 + Pk-1 
. r  
0 = = Together [ -v n -
I . ak.1 -+ (xk.1 + -v n ) /Yk.1 ] 
q. ak.1 + Clk-1 
O 
= =  - Xk+ l Pk - Yn Pk + n Qk + Yn Qk Xk+ 1 - Pk- 1  Yk+ l + Yn Qk- 1  Yk+ l 
Xk+ l Qk + Yn Qk + Qk- 1  Yk+ l 
This means that the numerator is 0, which, by Exercise 7.19, tells us that 
the two coefficients - the rational part and the coefficient of -Vn - must 
each be 0. This yields 
nqk = Pk Xk+1 + Pk-1 Yk+1 
Pk = qk Xk+1 + qk-1 Yk+1 
Multiplying the first equation by qk and the second by Pk, and subtracting: 
Pk (q. Xk+l + Clk-1 Yk+l ) - q. (Pk Xk+l + Pk-1 Yk+l ) / / Expand / / Factor 
By Proposition 7 .3(a) this is (-l)k Yk+l · 
o 
Exercises for Section 7 .3 
7 .19. Suppose that r, s, t, and u are rationals and that n is not a perfect 
square. Prove that if r + s ..Jn = t + u ..Jn, then r = t and s = u. 
7 .20. Implement an algorithm that writes any quadratic irrational in the 
normal form of Proposition 7.6(g). 
7 .21. Show that in the definition of the quotients ak for the CF of v'd, one 
can use ak = L(Xk + a0)/ YkJ, as opposed to the more complicated ak = 
l(Xk + v'd)/ YkJ of Theorem 7.7. 

226 
7. CONTI NUED FRACTIONS 
7.22. Implement an algorithm that returns True if and only if the input is 
a quadratic irrational. Use the ideas of Theorem 7.7. 
7.23. 
Use Theorem 7.9(b) to implement a CFPeriod2 Q [ n ]  function that 
returns True or False according to whether the CF of {Ti has period 2 or 
not. 
7.24. Prove that the CF of μ is [r; 2, 2 r]. 
7.25. Use FromCFSquared to prove parts G)-(m) of Proposition 7.9. 
7.26. Use FromCFSquared to prove that the CF of y r2 + 12 is 
{ { r - 3 
r - 1 2 r r - 1 
r - 3 
}} 
r, -6-, 1, 1, -2-, 3 ,  -2-, 1, 1, -6-, 2r 
if r <:: 9 and r = 3 (mod 6), and that the CF of Y r2 - 12 is 
{ 
{ 
r - 9 
r - 3 
1 
r - 3 
r - 9 
}} 
r - 1, 1, -6-, 2, -2-, 1, 3 (r - 3)2, 1, -2-, 2, -6-, 1, 2 r - 2  
if r <:: 15 and r = 3(mod6). 
7.27. The first few recordholders among {Ti for long periods are: 2, 3, 7, 13, 
19, 31, 43, 46, 94, 139, 151, 166, 211, 331, 421, 526, 571, 604, 631, 751, 886, 
919. Extend this list. 
7 .28. Show that the following construction leads to n such that the period­
length of {Ti is 3. Let s be even, let k be arbitrary, and let 
r = k(l + s2) - (2s)-1 where the inverse is the least positive inverse modulo 
s2 + 1. Let n = r2 + (2rs + 1)/(s2 + 1). If r is positive and s <  2 r, then the CF 
of {Ti is [r; s, s, 2r]. Prove that all period-3 examples arise in this way. 
Implement a function CFPeriod3Q [ n ]  that returns True or False accord­
ing to whether the CF period of {Ti is 3 or not. 
7.29. We will find integers Sn such that [sn ; 2, 2, 2, ... 2, 2sn], with n twos, 
represents ..fd, with d an integer. This will show that every period length 
occurs in the CFs of square roots of integers. Let Pi /qi be the convergents 
in the CF of {2 - 1: starting with p1 /q1 , they are 112, 2/s, 5/i2, 12129, 
29ho , 101i69, .... 
(a) 2pn + Pn-1 = qn 
(b) qn-1 = Pn 
(c) Let Sn = qn + 1 and let rn = [sn ; 2, 2, 2, ... 2, 2sn ]; then 
rn - Sn = [o; 2, 2, 2, ... , 2, 2sn, 
l ] = [0; 2, 2, 2, ... , 2, rn + sn] . 
rn - Sn 

(d) Use (c) to get 
Pn(rn + Sn) + Pn-1 
qn(rn + Sn) + Pn 
7.4. PELL'S EQUATION 
227 
(e) Solve (d) for r and use (a) and (b) to get r; = s; + 2Pn + 1; this proves 
that ..J sλ + 2pn + 1 = [qn ; 2, 2, 2, ... 2, 2(qn + 1)] . 
(f) Write a program to generate integers d such that the CF of Yd is as 
above, and verify by examining their CFs. 
7.4 Pell's Equation 
The Diophantine equation x2 - dy2 = ± 1 is called Pell's equation; this 
equation and its relatives where the right side is n have a long and interest­
ing history. The solutions (we consider positive integer solutions only) are 
very closely related to good rational approximations to Yd. For example, 
x = 1351, y = 780 form a solution to the d = 3 case and 1351/780 is a very good 
approximation to .,/3 (it is one of the convergents in the CF of Va). In this 
section we will study the relationship more closely and see why any Pell 
equation has a solution in positive integers, and why those solutions must 
occur among the convergents of a CF. We restrict the discussion to positive, 
nonsquare values of d, to avoid some simple cases where there are no 
positive solutions (Exercise 7.30). 
The Pell equation has played a large role in some ancient puzzles. In 
1657, Fermat challenged British mathematicians with x2 - 433y2 = 1. The 
smallest solution is 
x = 104564907854286695713 and y = 5025068784834899736. 
More famous is Archimedes's immortal challenge regarding the number of 
cattle in the herd of the Sun god. It reduces to a Pell equation for which the 
smallest solution is truly gigantic. In the next section we will see how one 
can compute an exact form for the solution to the cattle problem. Many 
much simpler puzzles also reduce to the Pell equation, and some are men­
tioned in the exercises (Exercises 7.32, 7.34, 7.36, and 7.37) so knowledge of 
its solutions and how fast they grow can be useful. Finally, Matijasevic's 
famous solution to Hilbert's Tenth Problem was based on solutions to the 
Pell equation (see [Mat]; the main sequence occurring on p. 19 is related to 
x2 - 5y2 = 4). 
Theorem 7.11. 
Suppose that d is a positive nonsquare integer. If 
x2 - dy2 = ± 1 and x and y are positive, then x/ y is a convergent of the CF 
for Yd. 

228 
7. CONTI NUED FRACTIONS 
Proof. Assume first that the target is + 1. Factoring the Pell equation as 
(x + y../(i )(x - y ..fd) = 1 yields two positive factors (because we assume x 
and y are positive), so x/ y - {Ci > 0. Then 
̅ - - Gd = x - y {d  = x2 - dy2 
1 
1 
y 
-v a  
y 
y(x + y{d) < 2y2 ../(i < 2y2 . 
Therefore, Theorem 7 .5(c) tells us that x I y is a convergent of {Ci. The - 1  
case is similar, except that we get y/x being a convergent of 1 / ../d; by 
Exercise 7.8 this means that x/ y is a convergent of ..fd. 
D 
The preceding immediately gives us an algorithm for finding the small­
est solution to the Pell equation x2 - dy2 = ± 1: Just search through the 
convergents of {Ci .  In fact, one can be perfectly precise about which conver­
gents will lead to the solution: If the CF of ..fd is periodic with period 
length n, then the (n - l)st convergent gives the first Pell solution, and 
subsequent convergents in steps of n yield the rest. 
Theorem 7.12. Suppose that d is a positive nonsquare, n is the period 
length of the CF of {Ci, and Pk I qk denotes the kth convergent. The small­
est solution to x2 
- dy2 = ± 1 is x = Pn-l and y = qn-l · If n is even this is a + 1 
solution (and there are no - 1  solutions). If n is odd this is a - 1  solution, and 
there are both + 1 and - 1  solutions. Solutions beyond the first occur at the 
convergents Pk I qk where k = 2n - 1, 3n - 1, .... 
Proof. Theorem 7.1 1  tells us that any solution is a convergent. And we 
know that pc - dqc = (- l)k+i yk+l (see Theorem 7.10). We now appeal to 
Theorem 7.S(c), which tells us that the preperiodic part of the CF of ..fd has 
length 1. Knowing this, the fact that the periodic part has length n means 
that (Xn+l • Yn+d = (X1 , Yi ) (using the notation of Theorem 7.7). Therefore, 
d - Xr 
-- = Yo =  1 .  
Y1 
But then pɈ_1 - dqɈ_1 = (- lt Yn = (- lt . So this gives us one solution: 
(Pn-1 • qn-d· 
To see that no earlier convergent is a solution, suppose that the kth 
convergent is a solution. Then Yk+l = ± 1. Suppose first that it is + 1. Then 
ak+1 = Xk+1 + {Ci  so the CF of ak+l is [Xk+l + a0; a1 , a2, . • . , anJ which is 
purely periodic. Theorem 7.S(a) then yields - 1  < Xk+l - {Ci < 0, so 
L ..fd J = Xk+l · This means that ak+2 = a1 ; but because the a-sequence gov­
erns the a-sequence, this would mean that the a-sequence was periodic 
with period k + 1. But we know the period is n, so n would divide k + 1, 
which means that k + 1 : n or k : n - 1. In fact, this argument tells us that 
the solutions are the convergents Cn-l • C2n-l • C3n-l • ... ; a different 
approach to getting all the solutions will be discussed in Theorem 7.13. 

7 .4. PELL'S EQUATION 
229 
Finally, we will show that Yk never equals - 1, for any k. For if it did, ak, 
which we know has a purely periodic CF (every a does except ao) would 
equal -Xk - ../d, and Theorem 7.S(a) would yield -Xk + ..fd < 0 and 
-Xk - ..fd > 1. These two inequalities contradict each other. 
D 
Here is an example. The period-length is 6 so we want the convergents 
C5, C1 1 , and so on. Because indices in lists start at 1 (Co will be the first 
entry in the convergent list), we use Range [ 6 ,  4 8 ,  6 ]  to get C5, C11 , ... , 
C41 . 
ContinuedFraction [.../19] 
{ 4 , { 2 , 1 ,  3 , 1 ,  2 ,  8 } }  
solns = Convergents [ .../19 , 50] [Range [ 6 ,  48 , 6 ] ] 
{ 1 7 0  
5 7 7 9 9  
1 9 6 5 1490 
6 6 8 1 4 4 8 8 0 1  
2 2 7 1 6 72 9 4 0 8 5 0  
'3'9 , 1 3 2 6 0  , 
4 5 0 8 36 1  , 153282948 0 , 
52 1 15 7 5 14 8 3 9  , 
7 7 2 3 6 2 1 1 84 4 0 1 9 9 
2 6 2 6 00848596 7 2 6 8 10 
8 9 2 8 3 5 1 6 1 6 0 7 6 8 6 7 5 2 0 1  
1 7 7 1 9 2 0 2 2 2 1 5 7 8 0  , 
6 0 2 4 4 7 663958503 6 1  , 2 0 4 8 3 0 4 3 3 8 2 56 6 9 0 6 9 6 0  } 
The numerators and denominators solve the Pell equation with d = 19. 
Map [Rumer a tor [ t] 2 - 19 Denominator [ t] 2 & , solns] 
{ 1 , 1 ,  1 ,  1 ,  1 ,  1 ,  1 ,  1 } 
Theorem 7.13. The complete solution set to x2 - dy2 = ± 1 is generated by 
the least positive solution (x1 ,  y1 ) by taking the pairs (xk, Yk) arising from 
(x1 + Yt ..fdt = Xk + Yk ..fd, k = 1, 2, 3, .... 
Proof. It is easy to see that the pairs (Xk, Yk) are solutions, with the help of 
the fact that the conjugate of a power is the power of a conjugate: 
xc - dyd = (xk + Yk ...fd)(xk - Yk ..fd) 
= (x1 + Y1 ..fd)k (x1 - YI ..fdt = (κ - yed)k 
= ± 1 .  
It remains to show that every positive solution arises in this way. 
Suppose (X , Y) is a solution not equal to any (Xk , Yk). Let n be an integer 
such that 
_ r, n 
_ r, 
_ r, n+ 1 
(x1 + Y1 v a ) < X + Y v d < (x1 + Y1 v d ) 
. 
Divide all by the leftmost to get 
Write (X + Y../d)(x1 - Yi ..fdf as a + b../d. 

230 
7. CONTI N U ED FRACTIONS 
a2 - db2 = (a - b./d)(a +  b..fd) 
= (X + Y ..fd)(x1 - Y1 ..fdf (X - Y ..fd)(x1 + Y1 ..Jdf 
= (xι - yс d)n (X2 - d Y2) 
= ± 1 
So (a, b) is a solution to the equation and 1 < la +  b -Yd I < x1 + y1 ..Jd. This is 
almost a contradiction to the minimality of (x1 , Y1 ), but we do not yet know 
that a and b have the same sign. But la +  b Yd I > 1, so its reciprocal is less 
than 1 in absolute value. But its reciprocal is either a - b ..fd or -a + b Yd. 
It follows in all cases that a and b have the same sign. For example, sup­
pose -a - b..fd > 1 and its reciprocal, in absolute value, is a - b {d, which 
is less than 1. Adding and subtracting yields that both -2b..fd and -2a are 
positive. The other cases are identical. So either (a, b) or (-a, -b) is a 
subminimal solution, contradiction. 
o 
The pairs of the preceding theorem can be generated very quickly using 
matrix powers. To each irrational m + n {d associate the 2 x 2 matrix 
( ;',. : ). Then we can easily see that matrix( a) · matrix(p) = matrix( a /3). 
matr[m_ + n_F-J : = { {m, n} , {d n, m} }  
a = a + b Vd ; fJ = m + n Vd ; 
prod = Collect[Bxpand [a fJ] , Vi] 
a m +  b d n + -{d (b m + a n) 
Map [MatrixForm , {matr [prod] , matr [a] .matr [fJ] } ] 
( a m + b d n  
b m + a n ) ( a m + b d n  
b m + a n ) 
{ d (b m + a n) a m + b d n  ' 
b d m + a d n  a m + b d n  } 
Here is a specific example. The reader can run some timing tests to see that 
the matrix-power approach is much faster then expanding the radical. 
Expand [ ( 111 + 888 V) 12 ] 
3252 1 1 123544057 178702 11468769242755129409 + 
63 109244 162677391095868842709287 185 16320 "17 
MatrixPower[matr[lll + 888 -f7] , 12] [l]I 
{ 3252 1 1 123544057178702 11468769242755129409, 
63 109244 162677391095868842709287185 16320} 
Now the Pell equation x2 - dy2 = ± 1 can be completely solved by getting 
the smallest solution from the CF, forming the matrix, and using powers of 
the matrix to get all solutions. There are two CNT package functions for 

7.4. PELL'S EQUATION 
231 
solving Pell equations. The first, Pe l l Solve, returns the generating 
matrix. Then powers of this matrix can be used to generate all solutions to 
x2 - dy2 = ± 1. 
d = 13 ; 
mat = PellSolye [d] 
{ { 18 , 5 } ,  { 65 ,  18 } }  
solns = Table [MatrixPower [mat , i ]  [l:n , { i ,  5 } ]  
{ xvals , yvals } = Transpose [ solns ] ; 
xvals2 - d yvals2 
{ { 18 , 5 } ,  { 649 , 180 } ,  { 23382 , 6485 } ,  
{ 84240 1 ,  233640 } ,  { 30349818 , 841752 5 } } 
{ - 1 ,  1 ,  - 1 ,  1 ,  - 1 }  
Pe l lSolutions can be used to get a set of solutions. 
PellSolutions [ 13 , { 1 ,  5 }  ] 
{ { 18 , 5 } ,  { 649 , 180 } ,  { 23382 , 6485 } ,  
{ 84240 1 ,  233640 } ,  { 303498 18 , 841752 5 } } 
PellSolutions [ 13 , { 1 ,  5 } , RightSide -+ - 1 ]  
{ { 18 , 5 } ,  { 23382 , 6485 } ,  { 303498 18 , 8417525 } ,  
{ 39394040382 , 10925940965 } ,  { 5 1133434066018 , 1418 1862955045 } }  
Here is the answer to Fermat's challenge of 1657. An omitted second argu­
ment is assumed to be 1, so the first solution only is given. 
Pel lSolutiops [ 4 3 3 , RightSide -+ 1 ]  
{ 104564907854286695713 , 5025068784834899736 } 
Exercises for Section 7 .4 
7.30. Show that the Pell equation x2 - dy2 = ± 1 has no solutions in positive 
integers if d is either negative or a positive perfect square. 
7.31. Our discussion of solutions to the Pell equation x2 - dy2 = ± 1 often 
talks about one solution being smaller than another. But these solutions 
are pairs, not just single numbers. Explain why the concept of order makes 
sense for Pell solutions. 
7 .32. A triangular number is one such as 6, which equals 1 + 2 + 3, or 
10 = 1 + 2 + 3 + 4. Their general form is n(n + 1)/ 2. 36 is both triangular and 
square. Find some other numbers that are simultaneously square and 
triangular. Hint: If n(n + 1)/2 = m2 then a simple substitution can trans­
form this equation to the Pell equation x2 - 2y2 
= 1. But finding the substitu· 
tion is a little tricky. 

232 
7. CONTI N U ED FRACTIONS 
7.33. (a) Consider the Pell equation x2 - 2y2 = ± 7. Let a =  3 + ../2 and 
p = 1 + ../2. Prove that a pi, when expanded, yields solutions to the equation 
x2 - 2y2 = ± 7. Show that the same is true for a pi. 
(b) Show that the solutions found in part (a) are all the solutions. Hint: 
Proceed as in Theorem 7.13. Given a solution (a, b), let i be such that 
(1 + ../2 )i < a +  b ../2 < (1 + ../2 t1 • Divide by the leftmost term, let c + d ../2 
be the radical in the middle, and show how to get a bound on the possible 
values of c and d. Then find all possibilities and deduce that, in each case, 
a + b../2 = (c + d../2)(1 + ../2( 
7.34. (I. Vardi) A rack of 15 billiard balls has the pleasant property that 
they fit into a triangle and when the cue ball is added they fit into a square. 
Find some other numbers with this property by reducing the problem to a 
Pell equation with right side equal to -7. Then use Exercise 7.33. 
7.35. A certain Belgian street has houses numbered consecutively along 
one side of the street starting with the number 1. A friend who lives on this 
street invites you to his house. He won't tell you the house number, but 
says that the sum of all the house numbers that come before his house is 
equal to the sum of all the house numbers that come after his house. If you 
know that there are more than 50 and less than 500 houses on this street, 
what is the house number? 
7 .36. An urn contains n balls, some black, some white. Two balls are drawn 
at random without replacement, and both of them turn out to be black. 
Find values of n for which the chance of this happening is exactly 1/2 . 
7.37. When a regular hexagon of side-length 1 is inscribed in a circle, the 
circle's radius is 1. Find other integers m such that when a hexagon with 
sides (in order) 1, 1, 1, m, m, m is inscribed in a circle, the circle has an 
integer radius. Hint: Reduce the question to a Pell equation. 
7 .5 Archimedes and the Sun God's Cattle 
Approximately 2000 years ago, Archimedes asked: 
If thou are diligent and wise, 0 stranger, compute the number of cattle of the 
Sun, who once upon a time grazed on the fields of the Thrinacian isle of Sicily, 
divided into four herds of different colors, one milk white, another glossy black, the 
third yellow, and the last dappled. In each herd were bulls, mighty in number 
according to these proportions: Understand, stranger, that the white bulls were 
equal to half and a third of the black together with the whole of the yellow, while the 
black were equal to the fourth part of the dappled and a fifth, together with, once 
more, the whole of the yellow. Observe further that the remaining bulls, the dappled, 
were equal to a sixth part of the white and a seventh, together with all the yellow. 
These were the proportions of the cows: The white were precisely equal to the third 

7.5. ARCH I M EDES AND TH E SUN GOD'S CATILE 
233 
part and a fourth of the whole herd of the black; while the black were equal to the 
fourth part once more of the dappled and with it a fifth part, when all, including the 
bulls, went to pasture together. Now the dappled in four parts were equal in number 
to a fifth part and a sixth of the yellow herd. Finally, the yellow were in number 
equal to a sixth part and seventh of the white herd. 
If thou canst accurately tell, 0 stranger, the number of Cattle of the Sun, giving 
separately the number of well-fed bulls and again the number of females according to 
each color, thou wouldst not be called unskilled or ignorant of numbers, but not yet 
shalt thou be numbered among the wise. 
But come, understand also all these conditions regarding the cows of the Sun. 
When the white bulls mingled their number with the black, they stood firm, equal in 
depth and breadth, and the plains of Thrinacia, stretching far in all ways, were filled 
with their multitude. Again, when the yellow and the dappled bulls were gathered 
into one herd they stood in such a manner that their number, beginning from one, 
grew slowly greater till it completed a triangular figure, there being no bulls of other 
colors in their midst nor one of them lacking. 
If thou art able, 0 stranger, to find out all these things and gather them 
together in your mind, giving all the relations, thou shalt depart crowned with glory 
and knowing that thou hast been adjudged perfect in this species of wisdom. 
This problem has an interesting history, but only recently has symbolic 
computation been brought to bear. In this section we describe Ilan Vardi's 
approach to the problem [Var]. Quoting Vardi: "The simple nature of the 
question and the difficulty of its solution make this a perfect example of a 
challenge problem and show once more that Archimedes is one of the 
greatest mathematicians of all time." See [Var] for more information on 
attempts over the ages to solve the puzzle and for connections with alge­
braic number theory. 
¨ Wurm's Version: Using Rectangular Bulls 
J. F. Wurm in 1830 cleverly assumed that a bull had a rectangular shape, 
so that the underlined condition says only that a certain number isn't 
prime. The problem then translates into the eight equations that follow, 
where X, Y, Z, and W denote number of white, black, yellow, and dappled 
bulls, respectively, and x, y, z, w similarly denote the cows. 
eqns = { 
w = =  (  +  )  X + Y, 
x = =  
w = =  (  + : ) (X + x) , x = =  
z = =  (  + : ) (Y + J') ' J' = =  
1 
y + z = =  - q (q + 1) } ;  
2 
( : +  ) z + y , z = =  ( :  +   ) w+Y, 
( : + ) (Z + z ) , 
( :  +   )  (W + w) , 

234 
7. CONTI NUED FRACTIONS 
The first seven equations form a linear system in eight unknowns, and so 
can be solved by standard linear algebra techniques. 
raWSoln = {W, X, Y ,  z ,  w, x ,  y ,  z } / .  
First [ Solve [Drop [eqns , - 1 ] , {X, Y, Z ,  x ,  y ,  z , w } ] J 
267 W 
297 W 
790 W 
{w, 371 '  742 '  1113 ' 
171580 w 
8 15541 w 
1813071 w 
246821 , 1 727747 , 3455494 , 83710 w }  
246821 
We do not want fractional cows, so W must be a multiple of all the denomi­
nators. 
Apply [LCM ,  Denominator [ raWSoln] ] 
10366482 
So now we can express the solution in terms of W1 , where W = 10366482W1 . 
{Wo ,  Xo , Yo , Zo , Wo , Xo , Yo , Zo } = raWSoln I . W -+ 10366482 W1 
{ 10366482 W1 , 7460514 W1 , 4149387 W1 , 7358060 W1 , 
7206360 W1 , 4893246 W1 , 5439213 W1 , 35 15820 W1 } 
This means that the total size of the herd is 25194541W/ 5183241. We next 
try to find q, the number of rows in the large triangle. 
1 
q / .  Solve [Yo + Z0 = =  - q (q + 1 )  , q] [2] 
2 
Ǔ ( - l + V1 + 92059576 W1 l 
This tells us that we seek W1 so that 92059576W1 + 1 = s2 ; or s2 = 1 (mod 
92059576). We can use the modular square root algorithm from Section 6.3 
to find all the possibilities for s. 
SgrtMoclAll [ l ,  9205957 6 ]  
{ 1 ,  3287843 , 4303069 , 7590911 , «26» , 88771733 , 92059575 } 
We cannot take s to be 1, because that leads to W1 = 0 and no cattle. So let 
s = 3287843. 
s = 3287843 1 
( s2 - 1 )  I 92059576 
117423 
This gives us the value of W1 , which in turn gives us everything else. 
{Wo , Xo ,  Yo , Zo , Wo , Xo r Yo r Zo } / .  W1 -+ 1 17 423 
{ 1217263415886 , 876035935422 , 487233469701 , 8640054 79380 , 
846192410280 , 57457962505 8 ,  638688708099 , 412838131860 } 

Apply [Plus , % ] 
59 16837175686 
7.5. ARCHIMEDES AND TH E SUN GOD'S CATILE 
235 
Because W0 + X0 is even (and so not prime), this is a valid solution -
the smallest one - to Wurm's version of the problem; the Sun's herd con­
sisted of almost six trillion head of cattle. Here's a check, where Thread is 
used to turn listl ݗ l i st2 into the list of coordinatewise replacements. 
1 
eqns / . q -+ - ( - 1 + ../1 + 92059576 • 117423 ) / .  
2 
Thread [ {W, X ,  Y , z , w ,  x ,  y ,  z } -+ 
{Wo r Xo ,  Yo ,  Zo r  Wo r Xo r Yo r Zo } ]  / .  W1 -+ 117423 
{ True , True , True , True , True , True , True , True } 
« The Real Cattle Problem 
A proper reading of the problem says that W + X is a square integer. We 
know that 
W + X = 10366482 W1 + 7 460514 W1 = 17826996 W1 
from Wurm's work. Because 17826996 = 4 · 3 · 1 1 · 29 · 4657, W1 must have 
the form 3 · 11 · 29 · 4657m2 , or 4456749m2 • And Yo + Zo must be triangular. 
Yo + Zo / .  W1 -+ 4456749 m
2 
51285802909803 m2 
So 51285802909803m2 must be q (q + 1)/2. It is easy to find q. 
q / .  Last [Solve [51285802909803 m2 = =  q (q + 1) I 2 ,  q] ] 
j- ( - 1 + ..J1 + 410206423210424 m2 ) 
So we must solve 1 + 4102864232784m2 = k2 • One could try directly for the 
CF of .../ 4102864232784 , but its period is very large. The problem can be 
much simplified if we factor 410286423278424. 
FactorForm [Factorinteger [410286423278424] ] 
23 3 7 1 1  29 353 46572 
This means that we can replace m in the Pell equation by 
m1 = 2 · 4657m. Then the equation becomes 1 + 2 · 3 · 7 · 1 1 · 29 · 353mθ = k2 , 
or k2 - 4729494mс = 1. We can generate solutions to this, but we are seek­
ing a very special solution, one that has m1 divisible by 2 · 4657. Even with 
this reduction, the CF has a large period, so the first Pell solution will be 
large. 

236 
7. CO NTI NUED FRACTIONS 
d = 4729494 1 
ContinuedPraction [ Vd] / / «iming 
{ 0 . 0666667 Second , 
{ 2174 , { l , 2 ,  1 ,  5 ,  2 ,  25 , 3 , 1 ,  1 ,  1 ,  1 ,  1 ,  1 ,  15 , 1 ,  2 ,  16 , 
1 ,  2 ,  1 ,  1 ,  8, 6 ,  1 ,  21 , 1 ,  1 ,  3 ,  1 ,  1 ,  1 ,  2 ,  2 ,  6 ,  1 ,  1 , 5 ,  
1 ,  17 , 1 ,  1 , 47 , 3 ,  1 ,  1 ,  6 ,  1 ,  1 ,  3 ,  47 , 1 ,  1 ,  17 , 1 ,  5 , 1 ,  
1 ,  6 ,  2 ,  2 ,  1 ,  1 ,  1 ,  3 ,  1 ,  1 ,  2 1 , 1 ,  6 ,  8 ,  1 ,  1 ,  2 ,  1 ,  16 , 
2 ,  1 ,  15 , 1 ,  1 ,  1 ,  1 ,  1 , 1 ,  3 , 25 , 2 ,  5 , 1 ,  2 , 1 ,  4348 } } }  
Here is the matrix whose powers generate the solutions. 
mat = PellSolve [d] 
{ { 10993198673282973497986623282 1433543901088049 , 
50549485234315033074477819735540408986340 } ,  
{ 239073487 1 1878154303554440157231995 105844 1 1 1 1960, 
10993198673282973497986623282 1433543901088049 } }  
Now, we seek a solution {k, mi } where m1 is divisible by 2 and by 4567. 
Because 4729494 = 2 (mod 4), k must be odd and m1 must be even, so only 
4657 need be considered. The m1 just obtained is not divisible by 4657. 
Here is the radical form of the smallest solution. 
£ = mat[l] . { 1 ,  Vi }  
10993198673282973497986623282 1433543901088049 + 
505494852343 15033074477819735540408986340 yă4-7Ą2ą9Ć4-94ć 
Theorem 7.13 tells us that all solutions are given by powers of e. We can 
use the matrix power approach to find the first solution that has a radical 
coefficient that is divisible by 4657. Note that such a solution must exist, 
because it is equivalent to a solution of the larger Pell equation, and we 
know that all Pell equations do have solutions! We can search for one by 
looking at them all in order. Of course, a reduction modulo 4657 is neces­
sary at each step so the computation will avoid gigantic integers. And it 
helps to perform a modular reduction on the multiplying matrix right at the 
start too. 
i = 1 1  
ans = matl = Mod [mat , 4657 ] 1 
While [ans [l , 2] ʚ O ,  i++ 1 ans = Mod [matl . ans , 4657 ] ] 1 
{ans , i} 
{ { { 4656 , O } , { 0, 4656 } } , 2329 } 
The preceding computation takes under a second, but in fact we could 
have been even more efficient. Let p = 4657. Because e is a Pell solution, 
1 Iɉ = ɉ ;  therefore finding a power of e with radical coefficient divisible by 
p is the same as finding k such that ޻ - e-k = O(modp). But this is the 
same as asking that e2k = l(modp). It can be shown (see [Var]) that the 
smallest such k must divide (p + 1) I 2. Because those divisors of are {1, 17, 
137, 2329}, one can simply check that 17 and 137 do not work, and it is then 

7.5. ARC H I M EDES AND THE SUN GOD'S CATTLE 
237 
certain that 2329 will work. This is precisely what the exhaustive search 
yielded. 
In any case, the 2329th solution is what we want. This is given by e2329 , 
with m1 being the radical coefficient in the expression. So all that remains 
is to use the information we have to go back and build the actual solution. 
Recall that 1 / e is the conjugate of e. So 
(e2329 _ *9 ) 
e2329 _ (e)2329 
= 
2 .y 4 729494 
2 .y 4 729492 = m1 . 
This allows us to get m and then W1 and Wo. 
(e2329 
1 )2 
m2 - (Ї)2 _ 
- ॢ 
_ 
1 
( 4658 
1 
2 
- 2 · 4567 
- (2·4657·2Ј 4729494 )2 - 4·410286423278424 e 
+ e465B - ) 
W1 = 4456749m2 
W0 = 10366482 W1 = 10366482 · 44567 49 m2 
= 159e4658 
159 ( 1 
2) 
159e4658 
159 
159e4658 
0 056 
5648 
+ 5648 e4658 -
::: 5648 
- 2824 = 5648 
-
· 
· · · 
where the number e-4658, which is extremely small, is ignored. We can now 
eliminate the 0.056 by using a ceiling function. In short, we can express Wo 
exactly using ceiling, square root, and exponentiation. 
W0 = r 5165i8 ( 1 0993 1986732829734979866232821433543901088049 + 
505494852343 1 5033074477819735540408986340 .y 4729494 )4658 l 
This is a perfectly exact solution for the smallest number of dappled bulls in 
the Archimedes challenge. The same argument using the ceiling function 
applies to the other variables, so that the complete solution vector is 
159 
801 
891 
395 
128685 
2446623 
5439213 
125565 
46581 
f ( 5648 • 39536 • 19012 • 19768 • 6575684 • 184119152 • 368238304 • 13151368 )e 
Th 
fi 
h 
1 
b 
f 
ttl . 
f 25194541·159 46581 
h. h 
ere ore t e tota num er o ca e Is 5183241.5648 e 
, w IC we can 
approximate as follows. 
approx = 1!1 ( £ , 100 ] 
2 . 1986397346565946995973246564286708780217609799999999999999Ĉ 
9 99999 99999999999999999999999954517 332502 x 1044 

238 
7. CONTI NUED FRACTIONS 
2 5 194541 
"ݖ 
--- approx 
1841 19152 
7 . 7602714064868182695302328332138866642323224059233761031506\ 
1922690321593061406953194348955323833 x 10206544 
That's a lot of cattle! 
A natural question is whether Archimedes could have solved the prob­
lem. He did know about ideas related to the Pell equation, because his 
famous book The Measurement of the Circle contains the rational approxima­
tion 1351 hso for {3 .  This is the twelfth convergent for the CF of {3 and the 
sixth solution to the Pell equation. 
Converqents [-v'l , 12] 
{ 
5 
7 
19 
26 
71 
97 
265 
362 
989 
1351 } 
1 • 2 • 3 '  4 ' IT '  TS ' TI '  56 '  153 ' 209 ' 571 ' 780 
Pel1Solutions [3 , {l ,  6} ]  
{ { 2 ,  l } , { 7 ,  4 } ,  { 26 , 15 } , { 97 , 56 } , { 362 , 209 } , { 1351 , 780 } }  
But this is a far cry from understanding the theory well enough to know 
that x2 -4729494y2 = 1 has a solution. As Vardi observes, Archimedes could 
not have solved this problem, but he might well have gathered enough 
evidence to be convinced that all Pell equations have solutions. 
Exercises for Section 7 .5 
7.38. Find the rightmost ten digits in the number representing the total 
number of cattle in the Sun's herd. 
7.39. What is the approximate size of the second-smallest solution to 
Archimedes's problem? 
7 .6 Factoring via Continued Fractions 
In 1926 Maurice Kraitchik proposed the following scheme to factor n. 
Search for "random" pairs of integers that satisfy x2 = y2 (mod n). Kraitchik 
suggested taking values of x close to Vn and trying to factor x2 - n just 
using a relatively small set of primes. The set of primes over which we try 
to factor x2 - n is called the factor base ; the values x2 - n are called resi­
dues. We focus only on those values of x2 - n that factor completely using 
the primes in our factor base. If for any of these factorizations, all of the 
powers are even, then we have found integers x and y for which 
x2 = y2 (mod n). If p and q are distinct primes that divide n, then pq divides 
n which divides x2 - y2 = (x - y)(x + y), and there is a 50% chance that 

7.6. FACTORING VIA CONTI NUED FRACTIONS 
239 
exactly one of these two primes divides gcd(x - y, n). If this happens, then 
gcd(x - y, n) is a proper, nontrivial divisor of n. 
To illustrate the idea, let n = 30,929 and consider values of x in the 
range 166 s x s 185. Seven values of x2 - n factor completely using primes 
less than 50: 
1672 - 30929 = - 1 · 25 • 5 ·  19 
1692 - 30929 = - 1 · 26 .  37 
1732 - 30929 = - 1 · 23 . 53 
1752 - 30929 = - 1 · 24 · 19 
1762 - 30929 = 47 
1 772 - 30929 = 24 • 52 
1832 - 30929 = 29 • 5 . 
In this case, we immediately find an (x, y) pair: 
1772 = (22 • 5)2 (mod 30929) . 
This is great, for it tells us that 30,929 = (177 - 20)(177 + 20) 
We were lucky. What usually happens is that each factorization of 
x2 - n will contain at least one odd power of a prime. But one can then 
compare the factorizations that are over a small set of primes, searching for 
a product of the factorizations in which all primes appear to even powers. 
This example is simple enough that such a combination can be found by 
inspection, but we will see shortly how to automate the search. Here is a 
combination of three factors that works. 
1672 • 1752 • 1832 = (- 1)2 • 218 • 52 • 192 (mod 30929) 
So we set x = 167 · 175· 183 and y = 29 · 5 - 19, the square root of the square 
we found. We then use gcd to discover a factor. 
GCD [ 167 175 183 - 29 5 19 , 3092 9 ]  
157 
To summarize, this method tries to find integers Xi so that the product 
of the integers xη - n is a perfect square, say 
n (xr - n) = Y2 • 
ieS 
Then X is set to CT xi . It follows that X2 = Y2 (modn), and we can look at 
gcd(n, X - Y) in the hope of splitting off a nontrivial factor; if the X and Y 

240 
7. CONTI NUED FRACTIONS 
are independent then there is at least a 50% chance that this splitting will 
occur. 
Note that we can restrict the factor base to primes for which n is a 
quadratic residue: for if p divides x2 - n, then n = x2 (mod p). 
The difficulty with Kraitchik's approach is that I x2 - n I grows fairly 
quickly. It is approximately equal to 2 1  x - rn I rn. This reduces the 
probability that x2 - n factors completely using only primes from the factor 
base. 
In 1931 D. H. Lehmer and R. E. Powers published an algorithm that 
uses the continued fraction expansion of rn to get around the problem of 
the size of the residue. Let Pk I qk be the kth convergent to -{"it. We know 
that 
2 
2 
( l)k+l v 
Pk - nqk = -
i k+1 
where Yk is as in the proof of Theorem 7. 7, and so 
pō = (- l)k+I Yk+1 (mod n) . 
We have already seen in the proof of Theorem 7.7 that I Yk l < n for general 
quadratic irrationals. In fact, as we shall prove, much more is true in the 
case of a pure square root: 
The algorithm for finding the CF for -{"it generates, as a byproduct, lots of 
perfect squares - the p̄ - whose residues (mod n) - ± Yk - are close to 
0. We will generate the sequence of Y-values and keep track of the ones we 
are able to factor using the factor base, as well as the corresponding p­
values. Then we will try, using linear algebra, to combine the factorizations 
so that each prime goes evenly into the final product. If we can do this, then 
the product of the Y-values used, call it Z, will be a square, and we can let 
Y = ..fZ and X be the product of the corresponding p-values. We will than 
have that X2 = Y2 (mod n). The linear algebra part would be tedious to 
program in its full detail; fortunately the built-in Nul lSpace command of 
Mathematica will do the job for us. 
First we take care of the generation of the factor base, making sure at 
the same time that no small prime divides n. 
fb [ n_Integer , len_Integer) : = Module [ { smallQ = False , fac , j ,  u } , 
I f [ EvenQ [ n] , Return [ 2 ] ] i  
u = Select [ Prime [Range [2 len) ] , I = =  2 I I ( j = JacobiSymbol [ n , I )  i 
I f [ j = =  O, smallQ = True i fac = GCD [ I ,  n] ) i j = =  1 )  & ] i 
I f [ smal lQ ,  fac , u] ) 

fb [ 7 9 1 9 , 20] 
7 . 6 .  FACTORING VIA CONTI NUED FRACTIONS 
241 
{ 2 ,  5 ,  7 , 3 1 ,  3 7 , 7 1 ,  7 3 , 7 9 , 8 9 , 
9 7 , 1 0 3 , 1 0 7 , 1 0 9 , 1 1 3 , 1 3 1 ,  1 49 , 1 6 3 } 
fb [ 7 9 1 9  * 1 1 , 20] 
1 1  
The next function returns the parities of the exponents of the primes in 
y, under the assumption that all the primes that occur in y lie in the helper 
list. Mapindexed is like Map but it is stronger in that it allows us to refer to 
both # 1 ,  the element of the list being scanned, and #2 , the position of the 
scanned element within the list. We use this, via Cases, to change the 
appropriate entry of ans to the mod-2 value of the power of the prime. 
exponentsBinary [y_ , helpers_] : =  Module [ {prs , ans = helpers , p = 
DeleteCases [Map [ { I ,  IntegerExponent [J' , I ]  } & , helpers ] , 
{_, O } ] } , 
prs = First /fl p i  
Mapindexed [ ( ans [l2 [1U = I f [ !  MemberQ [prs , 1 1 ] , O ,  
Cases [p , { I ,  e_} :-+ Mod [ e ,  2 ] ] 1[1] ] )  & ,  helpers ] ]  
exponentsBinary [ l l  37 3 7 16 , fb [ 7 9 19 , 20 ] ] 
{ O ,  O ,  O ,  1 ,  1 ,  O ,  O ,  O ,  O ,  O ,  O ,  O ,  O ,  O ,  O ,  O ,  O } 
The powers 1, 3, 6 show up as 1, 1, 0 in positions 4, 5, 6, which correspond 
to the factor-base primes 31, 37, and 73, respectively. 
And now the main routine. We compute the p- and ¥-values together, 
making use of various relationships discussed earlier in this chapter. 
Whenever a ¥-value can be factored by the factor base, which we check by 
raising the product of the primes in the factor base modulo Y, we call on 
exponentsBinary to get the parity vector. We want to be able to add some 
of these to get the zero vector mod-2, for that will mean that the correspond­
ing product of the Ys will be a square. We can then let Y be the square root 
of the product of the ¥-values and let X be the product of the corresponding 
p-values. Sometimes it will happen that X = ± Y (mod n), which is bad for 
then neither of X ± Y will split n; we just move on to the next combination 
in such a case. 
In order to be sure that some combinations of the parity vectors sum to 
0 (mod 2) we need to have more such vectors than there are entries in a 
single vector; this is standard linear algebra. And this is why the target is 
set to 30 more than the length of the factor base. 
Other points about the code worth noting: 
• Any factoring algorithm should begin by checking for small divisors. 
We here check for divisibility by the first 10,000 primes by using a 
gcd test with the product of those primes. 
• AppendTo is avoided when accumulating the p- and y-values because 

242 
7. CONTI N U ED FRACTIONS 
it is slow. Instead we use code such as pvals = { pvals , p} to attach 
a new value, flattening when we are done. In the case of rows we 
must Partition the flattened result to get the right row-sizes (the 
size is one more than the length of the factor base because of the 
powers of - 1  added). We use count to tell when the target of 30 more 
than the size of the factor base is reached. 
• We reduce modulo n whenever possible. 
• Because the key congruence, pc = (- l)k+l Yk+l (mod n), can involve a 
minus sign, we must be sure that the product of the y-values we take 
is positive; otherwise the p-product would not have the correct proper­
ties. We ensure this by adding the relevant power of - 1 - called k in 
the code: it is either 0 or 1 - to the binary vectors. Then the Null­
Space command will take this into account and the resulting combina­
tions will have a 0th power of - 1, and so be positive. 
• Nul lSpace has a Modulus option, which we set to 2 because the 
parity is all that matters in the search for combinations that lead to 
squares. Here is an example where mat consists of some odd and 
some even integers. 
• Scan is used to work through the list of combinations, breaking out of 
the search via the Scan when a factor has been found. 
• Experiments have shown that 10 · 1.110g•o n is a good guide to the 
length of the factor base, and we use that. 
• We must transpose the matrix of mod-2 powers because NullSpace 
gives vectors that can be used to combine the columns of a matrix to 
get the zero vector. Here's an example where the matrix is not 
reduced modulo 2. 
mat = { { 3 ,  3 ,  l } , { 3 ,  2 ,  1 } , { 3 ,  13 , 12 } , { 3 ,  O ,  2 } ,  { 2 , 1, 32 } } i  
nap = HullSpace [Transpose [mat ] , Modulus -+ 2 ]  
Map [Flatten [ Position [ I , 1 ] ] & ,  nap ]  
{ { l , 1 ,  O , O , l } ,  { l , 1 ,  1 ,  1 ,  O } }  
{ { l , 2 ,  5 } ,  { l ,  2 ,  3 , 4 } }  
And the coefficients yield vectors that are entirely even. 
{mat [l:O + mat [2:0 + mat [S:O , mat [l:O + mat [2:0 + mat [3:0 + mat [4] } 
{ { 8 ,  6 ,  34 } ,  { 12, 18 , 16 } }  
• The method can fail on prime powers (Exercise 7 .42), so we insert a 
special check at the beginning to handle the case that n is a prime 
power. We do this efficiently by checking only if n is a square, cube, or 
fifth power. Because of our check of primes through 105, any power 
that slips by these two tests would be greater than 1035 and, realisti­
cally, the CF factoring algorithm should be restricted to numbers 
smaller than this. 

7.6. FACTORI NG VIA CONTI N U ED FRACTIONS 
243 
Here is the CF factoring code, which requires exponentsBinary and 
fb presented earlier. 
testnumber = Apply [Times , Prime [Range [ PrimePi [ 10000 ) ] ] ] ; 
CFFactor [ n_Integer, opts __ ] : = Module [ 
{ count = 0 , k = 1 , i = 1 , pO = 1 ,  pl , X ,  Y ,  Z ,  ans = $Failed , 
g ,  aO = Floor[v'D] , a ,  j = 1 ,  pvals = { } ,  r ,  yvals = { } ,  
rows = { } ,  factorbase = fb [ n ,  Floor [ 10 1 .  l1.o9 c io, aJ ] ] } , 
I f [ l < (g = GCD [ n ,  testnumber] )  < n , Return [ {g ,  n / g } ) ] ;  
While [ ! IntegerQ [ r  = n11•rime [j J ) && j s 3 ,  j + + ] ; 
I f  [ IntegerQ [r] , Return [ { r ,  n I r } ] ] ;  
I f [ PrimeQ [n ] , Return [ { n } ] ] ;  
x = pl = ao ; y = n - a02 ; 
I f [ IntegerQ [ factorbase] , 
Return [ Sort [ { factorbase , n I factorbase} ] ] ] ; 
prod = Apply [Times , factorbase] ; 
Wbile [ count < Length [ factorbase ) + 3 0 , k = 1 - k ;  
a = Quotient [X + aO , Y] ; {pl ,  pO } = {Mod [a pl + pO ,  n] , p l } ; 
{ X ,  Y }  = { a  Y - X ,  Mod [ ( - 1 ) k pl 2 , n )  } ; 
I f  [ PowerMod [prod ,  2•1-r c1.ogcz . •  YJ J , Y] = = O ,  
count + + ; pvals = {pvals ,  pl } ;  yvals = {yvals ,  Y } ; 
rows = { rows , k ,  exponentsBinary [Y, factorbase] } ] ] ; 
{ pvals , yvals ,  rows } = Flatten /0 {pval s ,  yvals ,  rows } ; 
rows = Partition [ rows , Length [ factorbase] + 1 ) ; 
coeffs = Flatten [ Position [ I ,  1 ) ] & /0 
NullSpace [Transpose [ rows ) , Modulus -+ 2 ) ;  
Scan[ ( { XX ,  YY } = Mod [{Times H (pvals [I] ) , 
.../Times H (yvals [I] ) } , n] ; 
I f [XX i! YY && ll i! - YY && l <  (g = GCD [n ,  XX - YY ) ) < n , 
Return [ ans = Sort [ { g ,  n I g} ] ] ] ) & ,  coeffs] ; 
ans] 
CFFactor [ Prime [ lOOOOO ] Prime [ lOOOO l ] ] 
{ 1299709 , 1299721 } 
The version in the CNT package has several options that give more 
information. 
Get [ " en· " J 
CFFactor [ Prime [ lOOOOOOO] Prime [ lOOOOOO l] , ShowData -+ True ) 
Beginning the search for 83 factorable Y-values •
•
•
 
It took 2092 Y-values to find the 83 good values needed . 
13 of the 35 square combinations had X = ±Y ;  
0 o f  the remaining 2 2  failed to split n. 
{ 179424673 , 179424691 } 

244 
7. CONTINUED FRACTIONS 
The output means that there were 35 pairs of X and Y values that 
could be used, but 13 of them would fail to work as hoped. However, all of 
the 22 other values both worked to split the input. In fact, this 100% suc­
cess rate for the good pairs always occurs whenever n is a product of two 
primes (Exercise 7.40). 
Here is an example of an 11-digit integer where the method fails. 
CFFactor [ n  = 12091920623 , ShowData -+ True ] 
Beginning the search for 56 factorable Y-values •
•
•
 
It took 377 Y-values to find the 56 good values needed. 
All 33 of the square combinations had X = ±Y .  
$Failed 
But increasing the number of squares sought to 100 more than the factor 
base's size gets the job done. It yields 101 squares and only 96 of them are 
bad. 
CFFactor [ n ,  ShowData -+ True , TargetMargin -+ 100] 
Beginning the search for 126 factorable Y-values •
•
•
 
It took 855 Y-values to find the 126 good values needed . 
96 of the 101 square combinations had X = ±Y ;  
0 o f  the remaining 5 failed to split n .  
{ 104849 , 115327 } 
Here is an example that shows the method is capable of handling 
moderately large numbers. There turn out to be 31 combinations of the Y­
values that were squares, and 15 of them were bad. All of the remaining 16 
succeeded in factoring n. 
n = NextPrime [ 1010 ] NextPrime [ 1011 ] ; 
CFFactor [ n , ShowData -+ True] 
Beginning the search for 107 factorable Y-values •
•
•
 
It took 9323 Y-values to find the 107 good values needed. 
15 of the 31 square combinations had X = ±Y ; 
0 of the remaining 16 failed to split n .  
{ 10000000019 , 100000000003 } 
The next example shows success on a 34-digit number, though it takes 
several hours. The TraceintervalFactor option causes percentage-done 
statements to be printed. Note that over 400,000 terms of the CF had to be 
examined in order to get the desired set of 276 Y-values. 

7.6. FACTORING VIA CONTI N U ED FRACTIONS 
245 
CFFactor [ l628 17059 1890338745518252 8 1 9 193643 , 
SbowData -+ ±rue , ±raceintervalFactor -+ 0 . 10 ]  / /  ±iming 
Beginning the search for 276 factorable Y-values . . .  
10% done 
20% done 
30% done 
41% done 
51% done 
61% done 
71% done 
81% done 
91% done 
It took 458193 Y-values to find the 276 good values needed . 
18 of the 4 1  square combinations had X = ±Y Ȏ  
0 o f  the remaining 23 failed to split n .  
{ 4895 . 57 Second, { 12050933302352249 , 135 10742703824 7107 } }  
Factoring is a messy problem. There are many algorithms, and each of 
them is somewhat complicated to program; indeed CFFactor is signifi­
cantly more complicated than the other algorithms in this book. But, pre­
cisely because there is no simple method, it is very satisfying to discover the 
factors of a number and this explains why many people are intrigued by the 
problem. And, of course, much of the motivation for this work comes from 
the prevalence of codes that assume that factoring large numbers is essen­
tially impossible. 
The continued fraction factoring method is knows as CFRAC; until the 
early 1980s it was the method of choice for factoring large integers. But it 
hits a limit at around 50 digits. For integers of this size, the Y-values have 
25 digits. If we use all primes under one million in our factor base, that 
means we want to factor Y over a set of 40,000 primes. Our chances in any 
particular case are only about 1 in 1,000. So the number of Y-values we 
must compute is running close to 50,000,000. Trial division by 40,000 
integers 50,000,000 times is too time-consuming. 
We conclude by proving the bound on the Y-values that arise in the CF 
of a pure square root. 
Theorem 7 .14. In the derivation of the CF for -Vn, n not a square, we 
always have 0 < Xk < -Vn when k ) 1, and 0 < Yk < 2 -Vn for all k. 
Proof. Assume the theorem holds for Xk and Yk-l · We shall prove it holds 
for the next X and Y values. Note that X1 "' L -Vn J and Yo = 1, so we can 
start the induction at k = 1. 

246 
7. CONTINUED FRACTIONS 
We know that 
so Yk > 0 and Yk < Xk + ,,/Ti <  2,,/n. We also have 
(4) 
so Xk+l < -Vn. To prove that Xk+1 > 0, we note from inequality (4) that if 
Xk+l ॡ 0, then Yk > ,,/Ti . But this would mean that Xk+1 = ak Yk - Xk ;::; 
Yk - Xk > 0. It follows that Xk+l must be strictly positive. 
D 
Exercises for Section 7 .6 
7.40. Suppose that n is a product of two primes and X and Y are such that 
X2 = Y2 (mod n) but X -;J:. ± Y (mod n). Show that gcd(X - Y, n) will be one of 
the two primes. 
7.41. Implement a general factoring algorithm that combines a brute force 
method below 106, the Pollard rho method between 106 and 1015, and the 
continued fraction method between 1015 and 1025 . And in all cases improve 
the check for small divisors. Compare this method's performance with that 
of any single method. (Code for Pollard rho is in Chapter 5). 
7.42. Show that if n is a prime power, n = pe , e > 1, then the CF factoring 
method will not factor n. Hint: If e is even, then the square root of pe is not 
irrational, so we can assume that e is odd. Show that if the method finds a 
pair of integers, (X, Y), for which 
then p must be an element of the factor base. But the elements in the factor 
base are quadratic residues modulo pe . 
7.43. Use CFFactor (or the more general routine of Exercise 7.41) to get a 
routine that provides the complete prime factorization of an integer. 

CHAPTER 8 
Prime Testing with Lucas 
Sequences 
8.0 Introduction 
Lucas sequences are defined by two-term linear recurrences, the most 
famous example of which is the Fibonacci sequence. Edouard Lucas's 
generalization of the Fibonacci sequence plays an important role in computa· 
tional number theory. For a comprehensive treatment of the work of Lucas, 
and much other historical material on prime-testing, see [Wil2]. We will see 
in this chapter how it can be used to: 
1. yield a general-purpose prime-testing technique that is one of the 
best known; 
2. yield a prime certification procedure that is similar to Pratt certifica­
tion, except that one needs a factorization of p + 1 (as opposed to 
p - 1 in the Pratt case); 
3. get a very efficient algorithm for finding Mersenne primes (primes of 
the form 2m - 1) called the Lucas-Lehmer algorithm. 
Indeed, regarding (1) we will see how some very fast primality testing proce­
dures based on Lucas's ideas have no known counterexamples; Mathema­
tica's PrimeQ uses such tests. 
Lucas sequences come in pairs and are related to continued fractions. 
For integers P and Q we define the sequences { Ud and {Vi}, i = 0, 1, 2, 3, ... , 
by 
Uo = 0, U1 = 1, and Ui+l = P Ui - Q Ui-l when i ) 1 
Vo = 2, Vi = P, and Vi+1 = PVi - QVi-1 when i ) 1 
We define the discriminant to be the largest square-free integer that 
divides d = P2 - 4 Q. The discriminant of the Fibonacci sequence (the case 
P = 1, Q = - 1) is 5. We shall restrict our attention to Lucas sequences for 
which the discriminant is not 1 (i.e., P2 - 4 Q is not a perfect square). 
Throughout this chapter, d denotes P2 - 4 Q and a is (P + ..fd) / 2. Note that 

248 
8. PRIME TESTING WITH LUCAS SEQUENCES 
a is a root of x2 - Px + Q. We shall also use the notion of quadratic conju­
gate, defined and studied in Section 7.3: a =  (P - ..fd) / 2. Note that aa = Q. 
As a consequence, if p is prime and Q is relatively prime to p, then Q-1a is 
a mod-p inverse of a, where Q-1 is the mod-p inverse of Q. 
The first critical point (Exercise 8.1) is that 
V; + U; ../d" 
2 
from which it follows that 
(1) 
(2) 
Note also that if Q = ± 1, then the terms in the Lucas sequences that are 
even correspond (by halving) to solutions to Pell's equation x2 - dy2 = ± 1, 
and therefore also arise from the continued fraction expansion of ..fd. 
8.1 Divisibility Properties of Lucas Sequences 
A critical first task is to get an efficient way of computing the mod-m value 
of members of a Lucas sequence. Recall from Section 1.4 how matrix powers 
can be used to quickly get the Fibonacci numbers. The same ideas work for 
any recurrence relation. Here is how one would do it for a degree-3 recur­
rence, where an = c1an-1 + c2an-2 + c3an-3 and ao, ai , and a2 have specific 
values; the ideas are perfectly general. 
It follows that the nth power of the 3x3 matrix, when applied to the vector 
of three initial values, will give a vector with an in the third position. 
Because we can use MatrixPowerMod to get modular powers of the matrix 
quickly, this is an efficient, recursion-free approach to getting values of an 
for large n. The following snippet of code rotates the rows of the identity 
matrix (except the last row) and then places the coefficients into the third 
row. 
coeffs = {c1 , c2 , C3 } i 
ReplacePart [ 
Map [RotateRigbt , IdentityMatrix [Length [coeffs ] ] ] ,  
coeffs , 3 ]  I I MatrixPorm 
[ :. 

8. 1 .  DIVISIBILITY PROPERTI ES OF LUCAS SEQU ENCES 
249 
And so the following short program gets the nth element of the sequence 
modulo m. This code will work for any linear recurrence, not just those of 
degree 3. The function is included in the CNT package. 
LinearRecurrence [ coeffs_ , init_, n_Integer , m_ : oo ] : =  
Mod [ First [MatrixPowerM9d [ ReplacePart [ 
RotateRight /0 IdentityMatrix [ Length [coeffs ] ] ,  
coeffs , l ] , n ,  m] ] • init , m] I ;  n ݕ Length [coeffs ] 
LinearRecurrence [ coeffs_, init_, n_Integer, m_ : oo ] : = 
Mod [ init [n + i:n , m] I ;  n < Length [coeffs ] 
LinearRecurrence [ coeffs_, init_, n_List , m_ : oo ] 
: =  
LinearRecurrence [coeffs , init , I ,  m] & /O n 
Here are the Fibonacci numbers, for which the basic recurrence is 
an = an-1 + an-2 ·  
LinearRecurrence [ { l ,  l } ,  { O ,  l } , Range [O , 10] ] 
{ O ,  1 ,  1 , 2 , 3 , 5 ,  8 , 1 3 , 2 1 , 34 , 55 } 
These ideas can be used to define LucasU [ { P ,  Q }  , m] as a function so that 
Lucasu [ { P ,  Q } , m ]  [ n ]  gives the mod-m value of Un . Lucasu and Lucasv 
functions are included in the CNT package, by a somewhat faster algorithm 
that we will discuss later in this section. 
If Q = ± 1, then the Lucas sequences satisfy 
If Vi and Ui are both even, then they are the doubles of solutions to Pell's 
equation 
( V.- )2 ( u- 2 
-t - d  -t) = ± 1 
and therefore Vi / 2 and Ui / 2 must appear as convergents in the continued 
fraction of ../d. 
The next result shows how a version of Fermat's Little Theorem is valid 
for powers of a. Note that when working in a quadratic extension, f3 = 
y (mod p) means there is a 8 in the extension such that f3 = y + p8. Through­
out this chapter we shall use e(n) to denote the Jacobi symbol ( *) [defined 
in Section 6.2; if n is prime then this is just the Legendre symbol that 
encodes the quadratic character of d (mod n)]. 
Theorem 8.1. Fermat's Little Theorem in Quadratic Field Fix P and 
Q and let p be an odd prime. Then 
{ a (mod p) 
if e(p) = 1 
aP = 
a (mod p) 
if e(p) = -1 
P/ 2 (mod p) if e(p) = O . 
(3) 

250 
8. PRIME TESTI NG WITH LUCAS SEQUENCES 
Proof. 
aP = (P + ..fd { / 2P = (PP + d<p-lJ/2 ..fd) / 2 = (P + e(p )../d) / 2 (mod p ), 
where the well-known property of binomial coefficients - p divides ( ǒ) 
when 1 < k < p - is used to cancel all the middle terms in the expansion, 
and Euler's criterion is used to eliminate the power of d. 
o 
An alternative conclusion that follows easily and makes the connection 
with Fermat's Little Theorem clearer is: 
{ 1 (mod p) 
if e(p) = 1 
ap-e(pJ = Q (mod p) 
if e(p) = -1 
P/ 2 (mod p) if e(p) = 0 .  
(4) 
Observe that this means that if p is prime, then ap-e<PJ is congruent to an 
integer modulo p. But this does not capture the full strength, as the exact 
value of the integer is specified. 
Here are two examples: the first shows that a1 1  = a  (mod 11), while the 
second shows that a7 = a  (mod 7). These use QuadraticPowerMod and 
QuadraticMod, which are CNT functions to do modular arithmetic on 
quadratic irrationals. In such cases one does not wish to apply the reduc­
tion to the radical, and that is why special functions are needed. 
1 
P = 3 ;  Q = l ;  d = P2 - 4 Q ;  a =  - (P + ..fd) 
2 
2 ( 3 + -[5) 
p = 1 1 ;  JacobiSymbol [ d ,  p] 
1 
{ OUadraticPowerHod [ a ,  p ,  p] , 
OuadraticMod [a, p] , OUadraticPowerHod [ a ,  p - 1 ,  p] } 
{ 7 + 6 -15, 7 + 6 -15 , 1 }  
Now we switch to p = 7. 
p = 7 ; JacobiSymbol [ d ,  p ]  
- 1  
{ OuadraticPowerKod [ a ,  p ,  p] , 
OuadraticHod [QuadraticConjugate [a] , p] , 
OuadraticPowerM9d [ a ,  p + 1 ,  p] } 
{ 5 + 3 -15 , 5 + 3 -15 , l } 

8 . 1 . DIVISIBILITY PROPERTI ES OF LUCAS SEQU ENCES 
251 
Corollary 8.2. Fix P and Q, let p be an odd prime, and let e = (} ). Then 
Up-e = 0 (mod p) 
{ 2 (mod p) 
if e = 1 
Vp-e = 2 Q  (mod p) if e = - 1  
P (mod p) 
if e = 0 .  
(5) 
Proof. These follow almost immediately from equations (1) and (4). Those 
equations imply 
VP_" + Up-e ../d = R (mod p) 
where R is the right side of (5). But now a subtle point arises! The preced­
ing congruence is in the context of z[ v'd] and states that Vp-e + Up-e ../d = 
R + p(a + b ../d). But we can apply the result of Exercise 7.4 to conclude that 
Vp-e = R and Up-e = 0 (mod p), as desired. 
o 
Note the special case of Fibonacci numbers, which are the U-sequence 
when P = 1 and Q = - 1 . If p is prime then p divides Fp-( % ) . 
This gives us an easy pseudoprime test on a candidate n. Given n, and a 
pair of parameters P and Q, we check whether n divides Un-e . If it does not, 
then n is proved composite. If it does, then either n is prime or n is a {P, Q}­
Lucas pseudoprime. We will pursue this in Section 8.2. 
We now continue to examine divisibility properties of the Lucas U­
sequences, for fixed P and Q. To illustrate, let P = 3 and Q = - 1  (so that the 
discriminant d is 13). We consider the sequence of (Ui, Vi) and look for 
those Ui that are divisible by p, as p varies through the primes from 3 
through 19. Some data is shown in Table 8.1, where the Os are in bold. 
It appears that 3 divides ui if and only if 2 divides i; 5 divides ui if and 
only if 3 divides i; 7 divides ui if and only if 8 divides i; 11 divides ui if and 
only if 4 divides i; 13 divides ui if and only if 13 divides i; 17 divides ui if 
and only if 8 divides i; and 19 divides Ui if and only if 20 divides i. 
The next several theorems will explain what is happening. It turns out, 
for any odd number m that is relatively prime to Q, there is a positive 
integer, called the rank modulo m and denoted w(m) such that m divides 
Ui if and only if w(m) divides i. This is analogous to the order of b (modulo 
m). In that case we consider the powers bi (mod m) and look at the ones 
that are 1; the least such i is called ordm(b); here P and Q play the role of b. 
More precisely, the powers of a underlie what we are examining when we 
look at the rank: When Ui = 0 (mod p), then ai, when reduced modulo p, is 
an integer. We reiterate: The rank function depends on the parameters P 
and Q. We will learn shortly how to compute the rank. Table 8.2 shows 
some w values, with the prime and composite cases distinguished. For 
example, the observation that 19 divides U; if and only if 20 divides i 
becomes w( 19) = 20. 

252 
8. PRI M E  TESTI NG WITH LUCAS SEQUENCES 
i mod 3 
mod 5 mod 7 mod 1 1  mod 1 3  mod 1 7  
0 
(0,2) 
(0,2) 
(0,2) 
(0,2) 
(0,2) 
(0 ,2) 
1 
(1,0) 
(1,3) 
( 1,3) 
(1,3) 
(1 ,3) 
( 1,3) 
2 
(0 ,2) 
(3, 1) 
(3,4) 
(3,0) 
(3,11) 
(3, 1 1) 
3 
(1,0) 
(0, 1) 
(3,1) 
( 10,3) 
(10, 10) 
(10,2) 
4 
(0,2) 
(3,4) 
(5,0) 
(0,9) 
(7,2) 
(16,0) 
5 
(1,0) 
(4,3) 
(4,1) 
(10,8) 
(5,3) 
(7,2) 
6 
(0,2) 
(0,3) 
(3,3) 
(8,0) 
(9 , 1 1) 
(3,6) 
7 
( 1,0) 
(4,2) 
(6,3) 
( 1,8) 
(6,10) 
(16,3) 
8 
(0,2) 
(2,4) 
(0,5) 
(0,2) 
( 1,2) 
(0,1 5) 
9 
(1,0) 
(0,4) 
(6,4) 
( 1,3) 
(9,3) 
( 16, 14) 
10 
(0,2) 
(2, 1) 
(4,3) 
(3,0) 
(2 , 1 1) 
(14,6) 
1 1  
( 1,0) 
(1,2) 
(4,6) 
(10,3) 
(2 , 10) 
(7, 15) 
12 
(0,2) 
(0,2) 
(2,0) 
(0,9) 
(8,2) 
(1,0) 
1 3  
( 1,0) 
(1,3) 
(3,6) 
(10,8) 
(0 ,3) 
(10, 1 5) 
14 
(0,2) 
(3, 1) 
(4,4) 
(8,0) 
(8, 1 1) 
(14, 1 1) 
1 5  
(1,0) 
(0,1) 
(1,4) 
(1,8) 
( 1 1 , 10) 
(1, 14) 
16 
(0,2) 
(3,4) 
(0,2) 
(0,2) 
(2,2) 
(0,2) 
17 
(1,0) 
(4,3) 
(1,3) 
(1,3) 
(4,3) 
(1,3) 
18 
(0 ,2) 
(0,3) 
(3,4) 
(3,0) 
(1,11) 
(3, 1 1) 
19 
(1,0) 
(4,2) 
(3, 1) 
(10,3) 
(7, 10) 
(10,2) 
20 
(0,2) 
(2,4) 
(5,0) 
(0,9) 
(9,2) 
( 16,0) 
(0,2) 
( 1,3) 
(3, 1 1) 
(10,36) 
(33, 1 19) 
( 109,393) 
(360, 1298) 
( 1 1 89 .4287) 
(3927,14159) 
(12970,46764) 
(42837, 154451) 
(141481,5101 1 7) 
(467280, 1684802) 
(154332 1 ,5564523) 
(5097243, 18378371) 
( 16835050,60699636) 
(55602393,2004 77279) 
(183642229,662 131473) 
(606529080,2186871698) 
(2003229469, 72227 46567) 
(6616217487,23855 1 1 1 399) 
Table 8.1. The Lucas sequences ( U; ,  V; )  for P = 3 and Q = - 1  are shown in the last 
column, and reduced modulo 3, 5, 7, 1 1, 13, 1 7, and 19. 
The main points to be gleaned from Table 8.2 are: 
• If p is an odd prime , then w(p) divides p - ( % ). 
• If p is composite then, apparently, w(p) does not divide p - (  % ). 
We will build on these observations to develop some powerful prime tests. 
But first we continue to develop the proof that w(n) always exists. 
Theorem 8.4. Let { Ui } be the Lucas sequence determined by parameters P 
and Q and let m be odd and relatively prime to Q. If any Ui is divisible by 
m, then there is an integer e such that m divides Ui if and only if e divides i. 
Proof. From equation (1) we have that 
(6) 
If Ue is divisible by m, then the same is true for the coefficient of ..J<i when 
the kth power is expanded, and so Uke is divisible by m too. 
We now assume that e is the smallest positive index for which m 
divides Ue . To prove that if m divides Ui then e divides i, we use a-1 = Q-1 a. 

n 
3 
5 
7 
11 
13 
17 
19 
23 
29 
3 1 
37 
4 1  
43 
47 
53 
59 
61 
67 
71 
8. 1 .  DIVISIBILITY PROPERTI ES OF LUCAS SEQUENCES 
253 
w(n) n - ( ll )  
" 
n w(n) n - ( 1,; ) 
2 
2 
9 
6 
8 
3 
6 
1 5  
6 
1 6  
8 
8 
2 1  
8 
22 
4 
1 2  
2 5  
1 5  
2 4  
1 3  
1 3  
2 7  
1 8  
26 
8 
1 6  
3 3  
4 
34 
20 
20 
35 
24 
34 
22 
22 
39 
26 
39 
7 
28 
45 
6 
46 
32 
32 
49 
56 
48 
19 
38 
51 
8 
50 
7 
42 
55 
12 
54 
42 
42 
57 
20 
58 
48 
48 
63 
24 
64 
26 
52 
65 
39 
65 
12 
60 
69 
22 
68 
30 
60 
75 
30 
74 
68 
68 
77 
8 
76 
72 
72 
81 
54 
80 
Table 8.2. Some Lucas ranks w(n) for odd integers, where P = 3, Q = - 1, d = 13. In 
the prime cases w(n) divides n - ( ̂3 ). 
Assume that m divides U,. We choose k so that ke is the greatest multi­
ple of e less than or equal to r. Then 
Vr-ke + Ur-ke ..fd = 2ar-ke = 2 a' Q-ke (2a")k2-k 
k 
= 2-k Q-ke (V, + U, ..fd)(Ve - Ue ..fd) 
· 
Because m divides both U, and Ue, it must divide Ur-ke . The subscript 
r - ke is strictly less than e, and so it must be 0. 
o 
We now begin the proof that w(m) always exists when m is relatively 
prime to 2 Q. In the case of odd primes we know from equation (5) that 
Up-E(pJ is divisible by p, and therefore that w(p) exists in this case. 
The Lucas numbers satisfy some useful recurrences that involve much 
larger steps than the basic recurrence that defines them. These recurrences 
can be useful for computation of the U- and V-values. Equation (6) with 
k = 2 implies that 

254 
8. PRI M E  TESTING WITH LUCAS SEQU ENCES 
This gives us, for any e, the following "doubling rules": 
Vi + n u; 
V2e = 
2 
(7) 
(8) 
There are many other relations among Lucas numbers, and the follow­
ing ones will all prove useful later in this chapter. Proofs are left to Exer­
cises 8.4 and 8.5. 
U2k = 2 Uk Uk+1 - P u; 
Binary U-formulas: 
U2k+1 = l1+i - Q u; 
U2k+2 = P Ul+i - 2 Q Uk Uk+1 
Binary ¥-formulas: V2k = v: - 2 Qk 
V2k+1 = Vk Vk+1 - PQk 
V-from- U formulas: Vk = 2Uk+1 - P  Uk 
(9) 
(10) 
(11) 
We pause momentarily to show how these equations lead to a very fast 
way of computing Un and Vn (mod m). 
Algorithm 8. 1 
Computing Lucas Sequ ences 
To get Un (mod m) start by writing n in base 2. Then keep track of a pair of 
values that start as (Uo, Ui ) = (0, 1) and will finish as (Un, Un+d (mod m). 
Scan the base-2 digits of n from left to right. At each step, if we have two 
consecutive values Uk, Uk+l in hand, we can use equations (9) to get U2k, 
U2k+l , U2k+2 (mod m), keeping the first two if the current base-2 digit of n is 
0, and the last two if it is 1. The leftmost base-2 digit must be 1 so the first 
step gives (U1 , U2). When we're finished we will have (Un, Un+d and can 
use (11) to get Vn . Here is an implementation that uses Fold to scan the 
bits of n. LucasBoth returns the pair of U-V values. 
LucasUPair [ {P _ ,  Q_J ,  mod_ : oo] [ n_] : = Fold [ 
Mod[ I f [l2 : :  0 ,  {11 [1] (2 11[2] - p 11[1] )  I 1 1 [2]2 - Q 11[1]2 } ,  
{11 [2]2 - Q l1[1]2 , 11[2] (P l1 [2] - 2 Q l1 [1] ) } ] , mod] & , 
{ O ,  1 } , IntegerDigits [ n ,  2 ] ] 

8. 1 .  DIVISIBILITY PROPERTI ES O F  LUCAS SEQU ENCES 
255 
LucasUFast [ { P_ , Q_} ,  mod_ : oo ] [n_] : =  
First [LucasUPair [ { P ,  Q } ,  mod] [n] ] 
LucasVFast [ { P_ , Q_} , mod_ : oo ] [ n_] : =  
Mod [LucasUPair [ { P ,  Q} , mod] [n] . { - P ,  2 } , m] 
LucasBotb [ { P  _,  Q_} , mod_ : oo ] [n_] : = 
Mod [ { { l ,  O } , { - P ,  2 } } . LucasUPair [ { P , Q} , mod] [n] , mod] 
Here is a matrix version followed by timing comparisons that illustrate the 
speedup. The bit method uses about 80% of the time of the matrix method 
in the case of a single V, and 40% in the case of both. 
LucasUMat [ { P_ , Q_} , m_ : oo ] [n_] : =  
LinearRecurrence [ { -Q ,  P } ,  { O ,  l } ,  n ,  m] 
LucasVMat [ { P _, Q_} ,  m_ : oo] [ n_] : = 
LinearRecurrence [ { -Q ,  P } ,  { 2 ,  P} , n ,  m] 
p = 3 " Q = 1 " p = 1060 + 57 " 
{First [Timing [Do [LucasVFast [ { P ,  Q} , p] [ 
p; 
1 ] , { 10 } ] ] ]  / 
First [Timing [Do [LucasVMat [ { P ,  Q} , p] [ 
p + 1 ] , { 10 } ] ] ] , 
2 
First [Timing [Do [LucasBoth [ {P ,  Q} , pJ [
p;
l ] , { 10 } ] ] ]/ 
First [Timing [Do [ {LucasUMat [ { P ,  Q} , p] [ P 
+ 1 ] , 
2 
p + l  
LucasVMat [ { P , Q} , p] [ -2- ] } , { 10 } ] ] ] } 
{ 0 . 8 0 9 5 2 4 , 0 . 4 0 9 4 4 9 } 
Even more speedup is possible in situations where we know that, say, P is 
fixed at 1, for then special code could be written with the P's deleted. 
We now return to our study of the Lucas rank function. Let p be an odd 
prime and use e to denote e(p). We have seen that p divides Up-e ·  But, by 
(8), this means that p divides U<p-eJ/2 \lcp-el/2 · Assume now that p does not 
divide Q. Then, because Y;2 
- d U'f = 4Qi , the prime p cannot divide both 
U<p-eJ/2 and \lcp-eJ/2 . Which factor it divides is determined by whether or not 
Q is a quadratic residue modulo p. Thus the quadratic character of both Q 
and d are critical to the divisibility properties in question. 
Theorem 8.5. Let V; be the Lucas sequence determined by parameters P 
and Q and let p be an odd prime that does not divide Q. Then p divides 
\lcp-eJ/2 if and only if Q is not a quadratic residue modulo p, and p divides 
U<p-eJ/2 if and only if Q is a quadratic residue modulo p. 
Proof. Equation (7) and Corollary 8.2 imply that 

256 
8. PRIME TESTI NG WITH LUCAS SEQU ENCES 
Vb_ = Vp-e + 2 Qp-e)/2 = 2 Q(l-e(p))/2 + 2 Qp-e)/2 
2 
= 2 Qp-eJ/2(Ql-pJ/2 + 1) = 2 Qp-e)/2(( 1 ) + 1) (mod p) 
Because Q-1 is a quadratic residue if and only if Q is, p divides Vcp-e)/2 if 
and only if ( % ) = -1. We know that p divides Up-e • which means that p 
divides U<p-e)/2 \lcp-e)/2 .  If { % ) = + 1, then p does not divide the V-term 
because of the case just handled, so p divides the U-term, as claimed. 
o 
We next consider the rank of a Lucas sequence for prime powers. 
Theorem 8.6. Let U; be the Lucas sequence determined by parameters P 
and Q and let p be an odd prime that does not divide Q. Then w(pt) exists 
and divides pt-1 [p - e(p)]. 
Proof. The t = 1 case has been done. For the general case, use induction on 
t. Let e = p1-2(p - ( * )), which turns the induction hypothesis into: p1-1 
divides Ue. Use equation (6) with k = p to get 
Expanding the power we see that the coefficient of '1d on the right side is 
By the induction hypothesis, and because each binomial coefficient is 
divisible by p, each term in this sum is divisible by p1 • Because p does not 
divide 2P-1 , this means that p2 divides Upe ·  
o 
We now get two easy corollaries, the second of which will lead us to a 
pseudoprime test and the Lucas-Lehmer test for primality of Mersenne 
numbers. 
Corollary 8.7. Let Ui be the Lucas sequence determined by parameters P 
and Q and let n = p<1 • • • pܱ' be odd and relatively prime to Q. Then w(n) for 
the sequence exists and is a divisor of the least common multiple of 
pri-1 (Pi - e(pi)), i = 1, . . .  , r. In particular, if r ģ 2 and d is relatively prime to 
n, then w(n) < n - 1. 
Proof. By Theorem 8.6, for each i and any s ,  pri divides U ( "i- i 1 
) • 
s P; 
Pi -e(p; )] 
Therefore n divides Uk, where k is the least common multiple in the corol­
lary; and so w(n) divides k. The last assertion follows from the fact that 
r > 2 implies that k < n - 1. This is because n is odd, and so the factors 
Pi - e(pi) have at least one 2 in common. 
D 

8. 1 .  DIVISIBI LITY PROPERTIES O F  LUCAS S EQUENCES 
257 
Corollary 8.8. Fix a Lucas sequence determined by parameters P and Q, 
and let n be an odd integer relatively prime to Q and d. If w(n) for the 
sequence is n ± 1, then n is prime. 
Proof. Suppose that n is divisible by two or more distinct primes. Then by 
Corollary 8. 7, w(n) < n - 1 :s; n ± 1, contradicting the assumption. If n = p1 
and t > 1 then Theorem 8.6 states that w(n) is one of p1 ± p1-1 , and neither 
equals p1 ± 1 .  
o 
If we have an integer n that we suspect is prime, then this gives us a 
means of proving primality by generating Lucas sequences until we find 
one for which w(n) is n - e(n). This is very similar to proving primality using 
primitive roots where we tried to find an element whose order modulo n 
was n - 1. We will pursue this in Section 8.2. 
There is one more refinement of our primality test that we need. It is 
exactly analogous to the observation that underlies Theorem 4.4. 
Theorem 8.9. If n is odd and relatively prime to Qd, n divides Ycn+ l>/2 , and, 
for each odd prime p that divides n +  1, n does not divide Ycn+ l>tc2p» then 
w(n) = n + 1 and n is prime. 
Proof. If n divides Ycn+ i v2 , then by equation (8) n divides Un+ l • and so w(n) 
divides n + 1. Because n is relatively prime to Qd and l'c+ l>/2 - d  Ufn+l>/2 = 
4 Qi, n is relatively prime to Ucn+ 012 . This means that w(n) does not divide 
(n + 1)/ 2. It also means, because of equation (6), that n is relatively prime 
to U<n+ l>l<2p> . Because n does not divide Vcn+ l>t<2p» it cannot divide U<n+l>/C2pJ · 
Ycn+1J/C2p» which equals Ucn+ l)/p · It follows that w(n) = n + 1. By Corollary 8.8, 
n is prime. 
o 
The next section will show how all these results can be used in both 
prime-testing and prime certification. We conclude this section by illustrat­
ing the analogs between Lucas sequences and powers of the ordinary 
integers. Recall from Chapter 4 that, by Euler's theorem, ordn(b) divides 
if>(n); and the Carmichael function A(n) is the least universal exponent, so 
that, in fact, ordn(b) divides A(n). The preceding results allow us to define 
two new functions, <l>p.Q (n) and Ap.Q (n) that have analogous properties with 
respect to w(n), the main one being: w(n) divides A(n). Suppose that n is odd 
and n = pδ' pε2 • • • pζ' ; then 
Then w(n) is the first divisor r of A(n) for which U, = 0 (mod n). Here are 
implementations of all these functions. 
Lucas• [ { P_,  Q_} , {p_ ,  e_} ] 
: =  
pe-l (p - JacobiSymbol [ P2 
- 4 Q ,  p] ) I i GCD [Q , p] = =  1 

258 
8. PRIME TESTI NG WITH LUCAS SEQUENCES 
Lucasl! [ { P_ , Q_} ,  n_ ? OddQ) : =  
Apply [':rimes , Lucasl! [ { P , Q} ,  I ]  & / 0 Factorinteger [n] ] I ;  
GCD [Q , n] = =  1 
LucasA [ { P_ ,  Q_} ,  n_ ? OddQ) . -
Apply [LCM ,  Lucasl! [ { P ,  Q } , I ]  & / 0 Factorinteger [n] ] / ; 
GCD [ Q ,  n] = =  1 
LucasRank [ {_ ,  _} , 1 ) = 1 ;  
LucasRank [ { P_ , Q_} ,  n_ ? OddQ] 
· ­
Select [ Divisors [Lucas.A [ { P ,  Q} , n] ] , 
LucasU [ { P ,  Q} , n] [ I )  = = 0 & , 1 ) [ [ 1 ) ] 
/ ; GCD [ n ,  Q )  = =  1 
LucasRank [ { J ,  - 1 } ,  19 ) 
2 0  
LucasRapk [ { J ,  - 1 } ,  119 ) 
8 
LucasRank [ { 3 ,  - 1 } ,  428417 9 )  
2 1 4 6 3 2 0  
Exercises for Section 8.1 
8.1. Given integers P and Q so that d = P2 
- 4 Q is not a square, define ui 
and Vi by 
Vi + Ui ..fd 
2 
Prove that 
and therefore 
uo = 0, u1 = 1, and Ui+l = Pui - Qui-1 when i <:: 1 
Vo = 2, Vi = P, and Vi+l = Pvi - Qvi-l when i <:: 1 

8.2. PRI M E  TESTS U S I NG LUCAS S EQU ENCES 
259 
8.2. Show that if a and a are the two roots of x2 - Px + Q, then the Lucas 
sequences determined by the parameters P and Q satisfy 
8.3. Derive equation (4) from Theorem 8.1 
8.4. Prove that Uk+ I = (Vk + PUk)/2 and Vk+J = (PV,, + d Uk)/ 2. This proves 
equation ( 1 1). 
8.5. Prove the binary U- and ¥-formulas: equations (9) and (10). Hint: 
First use a2k+ l  = akak+ l to prove that 
8.6. Explain in more detail why the bit-scanning method presented in 
Algorithm 8. 1 is a correct implementation of the equations (9) for comput­
ing U-values. 
8.7. The three parameter-pairs P = 1, Q = - 1 ;  P = -3, Q = 1; and P = 4, 
Q = - 1  all have the same discriminant (the d-values are 5, 5, and 20, respec­
tively, but recall that the discriminant is the square-free part of d). Investi­
gate the corresponding Lucas sequences and discover the pattern that 
relates them. 
8.2 Prime Tests Using Lucas Sequences 
« Lucas Certification 
Theorem 8.9 gives a proof procedure for primality that is completely analo­
gous to the proof using primitive roots of Section 4.2. Suppose that we have 
an integer n that we think is prime. If n - 1 can be factored, then we 
already know from our earlier work how to search for a primality proof 
using primitive roots. But Lucas sequences yield proofs in the case that 
n + 1 can be factored. We will attempt to prove primality by finding a Lucas 
sequence for which w(n) = n + 1. Note that for this to happen it must be that 
( P2Ǒ4Q )  = - 1. We can set P to be 1 and then let Q vary until the Jacobi 
symbol condition is met. Now, to prove that the rank is n + 1 we will use 
Theorem 8.9, which requires the primes in n + 1. We perform the factoriza­
tion and store the prime divisors. Then we see if our Q, chosen so that 
( l-́Q ) = - 1, yields n + 1 for w(n); this is checked by using the stored primes 

260 
8. PRIME TESTING WITH LUCAS SEQUENCES 
to check whether Theorem 8.9 applies to the Lucas sequence determined by 
1 and Q. If not, we simply increment Q and try again. Here is an implemen­
tation. See Exercise 8.8 for why Q is started at 2 (as opposed to 0 or 1). 
A proof that a certifying Q exists for every prime p is given in Appen­
dix B. 
PrimeQWitbLucasProof [n_ / ;  PrimeQ [n] && n > 2 ]  : =  
Module [ {Q = 2 ,  nn = ( n  + 1 )  / 2 ,  
primes = Rest [First /0 Factorinteger [ n  + 1 ] ] } ,  
Wbile [ JacobiSymbol [ l - 4 Q ,  n] f. - 1  I I 
LucasV [ { l , Q} , n] [nn] f. 0 I I Apply [Or , 
Map [LucasV [ { l ,  Q} , n] [nn / I ] = = 0 & , primes ] ] ,  Q + + ] ; 
StringForm [ " n  = ' '  is prime because \nranka 
for the Lucas sequence defined from 
P = 1 and Q = ' ' equals n + 1 . " , n ,  Q)  ) 
PrimeQWithLucasProof [ 17 ]  
n = 1 7  is prime because 
rank0 for the Lucas sequence 
defined from P = 1 and Q = 3 equals n + l • 
PrimeQWithLucasProof [47 ] 
n = 47 is prime because 
rank0 for the Lucas sequence 
defined from P = 1 and Q = 1 3 equals n +l • 
PrimeQWi thLucasProof [ 1016 + 6 1 ]  
n = 1 00000000000000 6 1  is prime because 
rank0 for the Lucas sequence 
defined from P = 1 and Q 
= 1 0  equals n +l • 
Note that the preceding are not really proofs of primality because we 
have not certified the primality of the prime factors of p + 1. But that can be 
addressed recursively exactly as was done for Pratt certificates in Section 
4.2 (Exercise 8.10). Here is an example of such a Lucas certificate. The 
witnesses, to the right of the arrows, are the Q values, it being understood 
that P = 1 in this implementation. The complexity is quite similar to that of 
Pratt certificates. 
LucasCertificate [ 7 9 19 , Tree -+ True ] 
1- 7919  7 
I 
3 
ݔ 2 
I 
s 
Č 2 
; 
3 
 2 
11  7 
3 
Č 2 
----· -·-----J 

8.2. PRI M E  TESTS USING LUCAS SEQUENCES 
261 
LucasCert.ificat.e [ 1016 + 61 , Tree ... True ] 
i------·----·· ---···· ····-···· 
! 
1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 1  
., 
1 0  
3 
- ·  2 
1 3  . ., 
2 
7 
.... 
3 
4 2 7 3 5 0 4 2 7 3 5 0 4 3  
... 
3 
1 1  ... 7 
3 
-> 
2 
6 7  
-> 
5 
1 7  
-· 
3 
3 
> 
2 
1 1 9 8 0 3 9 9 3  
... 
1 7  
5 9 9 0 1 9 9 7  
' 
5 
L--·-··--··-··--· 
1 3  
-· 
2 
7 
-· 
3 
2 3 0 3 9 2 3  
-> 
3 
7 ... , 
3 
1 0 7  
-> 
5 
3 
... 2 
7 6 9  ... 2 1  
5 ... 2 
3 
-· 
2 
7 
... 
3 
1 1  -
7 
3 
• 
2 
Because the Lucas method requires that p + 1 be factored, it is espe­
cially appropriate for numbers of some special forms, such as 2n - 1 (see 
Exercise 8.9). Here is how it works on a large Mersenne prime. There are no 
odd primes in 2n , so the tree has but a single row. 
LucasCert.ificat.e [ 2 127 - 1 ,  Tree ... True ] 
1701411834604692317316873037 1 5884105727 ݓ 3 
For numbers such as Euclid numbers (p1p2 · · · P r + 1) one would use the 
primitive root method. For numbers with no special form and of moderate 
size (30-50 digits), the timing comparison will depend entirely on the 
factoring difficulties. For smaller numbers (16-25 digits), it seems as if the 
primitive root method is generally faster. 
« The Lucas-Lehmer Algorithm Explained 
The introduction to Chapter 1 mentions the Lucas-Lehmer algorithm for 
determining the primality of Mersenne numbers, 2n - 1. The algorithm is a 
beauty because it is exceedingly simple and can be used efficiently on very 
large numbers. Indeed, the largest known prime has almost always been a 
Mersenne prime, and the Lucas-Lehmer test has been used to prove the 
primality of these number. The current world record is 26•972•593 - 1, a 
number with over two million digits that was proved prime in 1999 by 
Nayan Hajratwala, a participant in the Great Internet Mersenne Prime 
Search (GIMPS; see ww.mersenne.org/prime.htm). 

262 
8. PRI M E  TESTING WITH LUCAS SEQUENCES 
Exponent 
Year 
2 
-
3 
-
5 
-
7 
-
13 
1461 
17 
1588 
19 
1588 
31 
1750 
61 
1883 
89 
1911 
107 
1913 
127 
1876 
521 
1952 
607 
1952 
1279 
1952 
2203 
1952 
2281 
1952 
3217 
1957 
4253 
1961 
4423 
1951 
9689 
1963 
9941 
1963 
11213 
1963 
19937 
1971 
21701 
1978 
23209 
1979 
44497 
1979 
86243 
1982 
110503 
1988 
132049 
1983 
216091 
1985 
756839 
1992 
859433 
1993 
1257787 
1996 
1398269 
1996 
2976221 
1997 
3021377 
1998 
6972593 
1999 
Digits 
1 
1 
2 
3 
4 
6 
6 
10 
19 
27 
33 
39 
157 
183 
386 
664 
687 
969 
1281 
1332 
2917 
2993 
3376 
6002 
6533 
6987 
13395 
25962 
33265 
39751 
65050 
227832 
258716 
378632 
420920 
895932 
909526 
2098960 
Table 8.3. The history of the discovery of the Mersenne primes. Sometimes the 
discoveries have not been in chronological order. Thus the following were not record­
setters at their time of discovery: 61, 89, 107, 521, 607, 1279, 2203, 2281, 3217, 
4253, 1 10503. 

8.2. PRI M E  TESTS U S I NG LUCAS SEQU ENCES 
263 
From Theorem 8.9, we see that n = 2P - 1 is proven to be prime if we 
can find a Lucas sequence for which n divides V2p-1 , for that will yield 
w(n) = n + 1. For this to happen it will have to be the case that ( f) and ( *) 
are not quadratic residues modulo n. The situation is reminiscent of Pepin's 
test for Fermat primes: There is a Lucas sequence that is guaranteed to 
work when n is prime; it is given by P = 2 and Q = - 2, which gives d = 12. 
We know that ( ޺)  = ( ..! )( ޹)  = ( 1. ). And by quadratic reciprocity, 3 is not a 
n 
n 
n 
n 
quadratic residue modulo 2P - 1 if and only if 2P - 1 is a quadratic residue 
modulo 3. We can assume that p is an odd prime (22 
- 1 is prime and so we 
do not need a test for this case), and therefore 2P - 1 = 2 - 1 = 1 (mod 3). 
This shows that 12 is not a quadratic residue for n. 
We also know (by Theorem 6.3 and Corollary 6.7) that Q = -2 is a 
quadratic residue if and only if 2P - 1 = 1  or 3 (mod 8). Because p is at least 
3, 2P - 1 = 7 (mod 8), and therefore Q = - 2  is not a quadratic residue. We 
have therefore proven that if n = 2P - 1  is prime then n divides Ycn+lJ/2 • But 
by Theorem 8.9, if n = 2P - 1 divides Ycn+lJ/2 • then n is prime. Thus we have 
an infallible test for primality of 2P - 1, when p is an odd prime. We not 
only have a test for primality, we have an algorithm that infallibly deter­
mines whether n = 2P - 1 is prime or composite. 
Some algebraic manipulation turns the preceding ideas into a very fast 
algorithm. Recall from equation (7) that 
With our choice of parameters, V2 = 2 · 2 + 2 · 2 = 8. We can therefore define 
a new sequence: 
s - ̀ 
t - 2<21-1 ) . 
It follows that 
and 
Because n = 2P - 1 is odd, n divides V2p-1 if and only if n divides Sp-l · And 
this can be checked in p - 2 steps by forming the sequence 81 , 82 , • • •  , Sp , 
reducing modulo n at each step. 
Here is an implementation of the Lucas-Lehmer test (it is in the CNT 
package). We do not have to bother checking that the exponent is prime, 
because the test works properly in the case of 2m - 1 even when m is compos­
ite, provided m is odd and at least 3 (Exercise 8.1 1). 

264 
8. PRI M E  TESTING WITH LUCAS SEQUENCES 
MersennePrimeO [ l ]  = True ; 
MersennePrimeO [ l ]  = False ; 
MersennePrimeO [n_Integer] : =  
IntegerO [m = Log [2 , n + l ] ]  && Nest [Mod [ l2 - 2 , n ]  & ,  4 ,  m - 2 ] = = 0 
Here is a list of the primes p among the first 100 that yield Mersenne 
primes 2P - 1. 
Select [ Prime [ Range [ lOO ] ] ,  MersengePrime0 [ 2 1 - l ]  & ]  
{ 2 ,  3 , 5, 7 , 13 , 17 , 19 , 31 , 6 1 ,  8 9 , 107 , 127 , 521 } 
We could do a timing comparison to see whether Mer sennePrimeQ 
outperforms Pr imeQ. But that would miss the point. Remember that for 
large values Pr imeQ, when it returns True, is not guaranteed to be accu­
rate. The Lucas-Lehmer test is an absolutely correct test of primality. So 
even though it is true that MersennePrimeQ is a little faster that PrimeQ, 
that is not a fair comparison. Actually, for the negative cases Mer senne­
Pr imeQ is only slightly faster than PrimeQ. That makes sense from a 
complexity point of view: a single PowerMod to check whether 2n - 1 is, say, 
a 3-pseudoprime would require n - 1 squarings and n - 1 multiplications by 
3. But the Lucas-Lehmer test requires only n - 2 squarings and n - 2 
subtractions of 2. (Recall from Proposition 2. 7 and Exercise 2.37 that 
Mersenne numbers are often 2-pseudoprimes, and that is why 3 should be 
used if one is using a pseudoprime test on them.) 

 Lucas Pseudoprimes 
There are several ways to use Lucas sequences to get pseudoprime tests. 
Recall from Corollary 8.2 that if p is an odd prime then Up-e(pl = 0 (mod p). 
This leads to an odd integer n being called a {P, Q}-Lucas pseudoprime if 
n is not prime and Un-e<n> = 0 (mod n). As always, d denotes P2 - 4Q and 
e(n) = ( f ). Note that this condition implies that an-e<n> is congruent to an 
integer modulo n. The special case of Fibonacci pseudoprimes, which corre­
sponds to P = 1, Q = - 1, was mentioned in Exercise 1.39: n is a Fibonacci 
pseudoprime if n is composite and n divides Fn-( γ). These tests are by no 
means infallible, but they form a foundation for some very satisfactory 
methods that seem to approach infallibility. Here is an implementation. 
The first function serves as a prime test; the second detects pseudoprimes. 
LucasPseudoprimeTest [ { P _, O_} ,  n_] : = Module [ {d = P2 - 4 0} , 
Wbich [ l  < (g = GCD [ n ,  2 O d ] )  < n ,  False , g = =  n ,  PrimeO [n] , 
g = =  1 ,  0 = =  LucasU [ { P , 0} , n ]  [ n  - JacobiSymbol [ d ,  n ] ] ] ]  
LucasPseudoprimeO [ {P _, 0_} ,  n_] : = I PrimeO [ n ]  && 
LucasPseudoprimeTest [ { P ,  0 } ,  n ]  
LucasPseudoprimeO [ { P _, O_} , n_List ] 
• -
Map [LucasPseudaprimeTest [ { P ,  O }  , I ]  & , n ]  

8.2. PRI M E  TESTS USI NG LUCAS SEQU ENCES 
265 
We could use these functions in a Select [ Range [ ] , ... ] construction, but 
let us introduce the CNT package function PseudoprimeSearch. It takes a 
bound and various options control the type of pseudoprime searched for, 
Here are the Fibonacci pseudoprimes. 
PseudoprimeSearch [ 10000 , Type -+ Fibonacci ] 
{ 32 3 ,  377 , 189 1 ,  3827 , 4181 , 5777 , 660 1 ,  672 1 ,  8149 }  
And here is another example. 
PseudoprimeSearch [ 10000 , Type -+ Lucas , LucasParameters -+ { 3 ,  - 1 } ]  
{ 1 19 , 649 , 1189 , 1763 , 359 9 ,  4187 , 5559 , 6681 } 
Unlike the case for ordinary pseudoprimes, it is not known that in all 
cases there are infinitely many Lucas pseudoprimes. However, one step in 
this direction is due to Emma Lehmer, who proved in 1964 that F2p is a 
Fibonacci pseudoprime whenever p is prime, except p = 3 or 5. 
LucasPseudoprimeO [ { l ,  - 1 } , Fibonacci [2 Prime [ Range [20] ] ] ]  
{ True , False, False, True, True, True, True, True, True, True, 
True , True , True, True, True, True, True, True , True , True } 
Recalling the Fermat's Little Theorem generalization, it makes sense to 
invoke the stronger property that looks at both U- and V-values. Indeed, it 
is no more difficult to compute both values than one of them, as explained 
in Algorithm 8.1. Thus, we will call n a {P, Q}-quadratic pseudoprime if 
the following holds, where a power of Q is used to combine the two cases. 
1 -r.(n) 
Un-e(n> = 0 (mod n) and Vn-e(n> = 2Q_2_ (mod n) 
Note that this is equivalent to the condition an-e(nJ = q.i-e(nJJ/2 (mod n). The 
word quadratic is used because this notion is directly related to powers of a 
quadratic irrational. It would be natural to call this a Lucas pseudoprime, 
but the term Lucas psp has the history just presented. The implementation 
that follows uses Lucas, which computes the { U, V }  pair. 
QuadraticPseudoprime:rest [ { P_, Q_} ,  n_] 
: = Module [ {d = P2 - 4 Q} , 
Wbich [ l  < (g = GCD [ n ,  2 Q d] ) < n , False , 
g = =  n ,  PrimeQ [n] , g = =  1 ,  £ = JacobiSymbol [ d ,  n] ; 
Lucas [ { P ,  Q } , n] [ n - £ ] == { O , Mod [ 2  Q < 1 -<> 12 , n ] } ] ] ;  
QuadraticPseudoprimeQ [ { P_, Q_} ,  n_Integer] : =  ! PrimeQ [ n ]  && 
OuadraticPseudoprimeTest [ { P ,  Q} , n ]  
QuadraticPseudoprimeQ [par_, n_List ] 
: =  
Map [OuadraticPseudoprimeo [par , f ]  & , n] 
In the Fibonacci case this extension reduces the number of bad examples 
less than 10,000 from nine to three. 

266 
8. PRI M E  TESTING WITH LUCAS SEQU ENCES 
PseudoprimeSearch [ 10000 , Type -+ QuadraticF ibonacci ]  
{ 4181, 5777 , 6721 } 
But even for this test, the number of pseudoprimes can be numerous. 
PseudoprimeSearch [ lOOOO , 
Type -+ Quadratic , LucasParameters -+ { 14 , 1 } ]  
{ 65 , 209 , 629 , 679 , 901 , 989 , 124 1 ,  
1769 , 196 1 ,  199 1 ,  2509 , 270 1 ,  29 1 1 ,  3007 , 3439 , 
3869 , 5249 , 5719 , 5777 , 606 1 ,  6767 , 6989 , 9 869 } 
Using ± 1 for Q turns out to be very bad, as we will explain in a moment; 
switching to 2 yields a much better test. Do you recognize the number in 
the following output? 204 7 is the first 2-strong pseudoprime. This is not a 
coincidence (see Exercise 8.15). 
PseudoprimeSearch [ lOOOO , 
Type -+ Quadratic , Lucas Parameters -+ { 14 , 2 } ]  
{ 2 047 } 
In addition to Lucas psps and quadratic psps, we can also examine 
what we will call Lucas V pseudoprimes, by using only the V-equation of 
the pair given in (5). These pseudoprimes, which are somewhat rarer than 
Lucas psps, are pursued in Exercise 8.16. 
Now we address two important points in the theory of quadratic 
pseudoprimes: one should avoid using Q = ± 1, and one should avoid choices 
that lead to ( *) = + 1. First, the Q-problem: The case P = - 1, Q = 1 is an 
extreme example, because a3 = 1, and this implies that every composite not 
divisible by 3 is a quadratic psp. 
More generally, the Q-problem has to do with the order of a (mod p). 
This order exists because ap-e(pl = 2 or 2 Q  (mod p), and so alp-e(p)] (p-lJ = 
(aP-E<P> t-1 = 1 (mod p). Now, suppose that Q = 1 and d = P2 - 4. If p is a 
prime such that (}) = -1, then we know that aP = a  (modp) and so 
aP+ l = aa = 1 (mod p). This means that integers of the form n = mp where 
p does not divide m, m = 1 (mod p + 1), and e(n) = - 1  have an above-average 
chance of being a quadratic psp. This is because for such m, an = (aP r = 
am = am = a  (mod p), and so we would need only that aPm = a  (mod m). If, 
say, m is prime, then aPm = (am)P = aP (mod m) because ( : )  = + 1. Thus we 
need only find such a prime, m, so that aP = a  (mod m), which is equivalent 
to aP+l = 1 (mod m). In fact, this happens fairly often, as a simple search for 
quadratic psps will show. 
Table [ { P ,  Pseudoprimesearch [ 2000 , Type ... Quadratic , 
LucasParameters -+ { P ,  1 } ] } ,  { P ,  3 ,  10} ] / / ColumnForm 
{ 3 , { 323 , 377 , 189 1 } } 
{ 4 ,  { 209 , 901 , 989 } }  
{ 5 ,  { 527 , 551 , 1807 , 1919 } }  

8.2. PRI M E  TESTS USING LUCAS SEQUENCES 
267 
{ 6 ,  { 35 , 169 , 385 , 779 , 899 , 96 1 ,  1 12 1 ,  1 1 89 } }  
{ 7 ,  { 323 , 329 , 377 , 45 1 ,  108 1 ,  1819 , 189 1 } }  
{ 8 ,  { 52 7 ,  559 , 781 , 1763 , 192 1 } }  
{ 9 ,  { 9 ,  703 , 7 1 1 , 989 , 1343 } } 
{ 10 , { 49 , 323 , 385 , 1067 , 1079 , 1595 , 1763 } }  
The 323 example fits the pattern exactly, where P = 3, Q = 1, d = 5, 
p = 17, m = 19 : a18 = 1 (mod 19) 
D = 323 1 P = l 1 0 = 1 1 d = P2 - 4 Q 1 p = l7 1 m = l9 1 a =  ( P + Vd) / 2 1 
JacobiSymbol [ d ,  n ] 
- 1  
OuadraticPowerMod [a , p + 1 ,  m] 
1 
Similar heuristics apply to Q = -1. Table 8.4 shows the number of quadratic 
pseudoprimes below 150000 in several cases where I Q  I is and is not 1. The 
performance difference is clear. Note the large numbers for (2, 2) and (3, 3). 
That is because a4 and a6 , respectively, are integers in those cases, thus 
increasing the chances for a modular power of a to be an integer. Note also 
that several cases are perfect through 150,000. But perfection does not last 
long: the first pseudoprimes for (3, -2), (9, 2), (9, -2), (13, -2) are, respec­
tively, 220729, 514447, 642001, and 658801. 
Q = -1 
Number 
Q = -2 
Number Q = l 
Number 
Q = 2  Number 
Q = 3 
Number 
p 
of psps 
p 
of psps 
p 
of psps 
p 
of psps 
p 
of psps 
2 
50 
2 
5 
2 
0 
2 
43 
2 
2 
3 
28 
3 
-
3 
61 
3 
0 
3 
47 
4 
63 
4 
2 
4 
69 
4 
7 
4 
L 
5 
28 
5 
1 
5 
53 
5 
3 
5 
3 
6 
47 
6 
2 
6 
105 
6 
1 
6 
2 
7 
41 
7 
2 
7 
103 
7 
2 
7 
1 
8 
26 
8 
4 
8 
88 
8 
3 
8 
2 
9 
40 
9 
--
9 
86 
9 
-
9 
3 
10 
36 
10 
10 
10 
95 
10 
8 
10 
3 
1 1  
59 
11 
2 
11 
61 
11 
6 
1 1  
4 
12 
29 
12 
3 
12 
75 
12 
2 
12 
1 
13 
50 
13 
-
13 
93 
13 
3 
13 
2 
14 
111 
14 
2 
14 
127 
1 4  
5 
14 
2 
15 
52 
15 
6 
15 
85 
15 
3 
15 
3 
Table 8.4. The number of quadratic pseudoprimes for various choices of P and Q. 
When Q is ± 1 there are a lot; for other values of Q, pseudoprimes are much rarer. A 
small square indicates that P2 - 4 Q is a square, in which case the theory does not 
apply. Dashes mean that there are no pseudoprimes. The counts are based on 
integers below 1 50,000. 

268 
8. PRI M E  TESTING WITH LUCAS SEQUENCES 
We next consider what might be called the square root problem: Sup­
pose that P and Q lead to d such that ( f) = + 1. This does not mean that d is 
a square modulo n, but it does increase the likelihood that that is so; for if d 
is a square modulo n, then it is a square modulo each prime divisor of n, 
and so ( f) = + 1. Before explaining why squareness is bad, we need a lemma 
that connects ordinary pseudoprimes and quadratic pseudoprimes. 
Lemma 8.10. If an odd integer n is a b-psp and a e-psp, then n is a {P, Ql­
quadratic psp whenever P = b + e and Q = be (mod n). 
Proof. Define a from P and Q as usual. Then {a, a) = {b, e) (mod n) because 
the quadratic polynomials x2 - Px + Q and x2 - (b + e)x + be have coeffi­
cients that are congruent modulo n. Using Exercise 8.2, Vn = bn + en = b + 
e = P (mod n), and Un = (bn - en)/(b - e) = (b - e)/ (b - e) = l (mod n); because 
( P2N4Q )  = ( <bǢd ) = 1, this shows that n is a {P, QI-quadratic psp. 
D 
Now, if P and Q are such that d = r2 (mod n), then the pair of simulta­
neous equations P = b + e and Q = be can be easily solved modulo n for b 
and e to get b = (P - r)(n + 1) / 2 and e = (P + r) (n + 1) / 2. If, for example, n is 
a 2-pseudoprime, then it might well be a b-psp and a e-psp (assuming 
gcd(n, be) = 1), because it might be a Carmichael number, or one of b and e 
might be ± 1. This would mean, by the lemma, that n will be a quadratic 
{P, Q}-psp. This is bad because it means that the quadratic test will not be 
independent of the ordinary Fermat pseudoprime test. We strongly desire 
such independence because, if we have a quadratic psp, it is very fast to 
apply, say, a 2-psp test in the hope that that will prove compositeness. In 
short, our pseudoprime tests are more powerful if they are independent. 
Here's an example, where n is 2047, the first strong 2-psp. If we allowed 
( f) = + 1, we might choose P = 1 and Q = -2, which yield d = 9. Of course, 
this is the square of 3. 
n = 2047 ; 
p = 1 ; 0 = - 2 ; d = P2 - 4 0 
r = SgrtJlodAl l [d , n] [l:n 
9 
3 
Now, b and e turn out to be - 1  and 2, respectively, and so the lemma tells 
us that n is a quadratic {P, Q}-psp. 
{ b ,  c} = Mod [ (n + l )  / 2  { (P - r) ,  (P + r) } , n ]  
GCD [ n ,  b c] 
{ 2 0 4 6 , 2 }  
1 

8.2. PRI ME TESTS U S I NG LUCAS SEQU ENCES 
269 
OuadraticPseudoprimeO [ { P ,  Q} , n] 
True 
This desire to make the quadratic test as independent as possible from 
the Fermat pseudoprime test is why we always try to use P and Q so that 
e(n) = - 1. A curiosity is that, if we actively seek d such that ( *) = + 1, we 
seem to get fewer pseudoprimes than in the -1 case. But quality, not 
quantity is the issue: These pseudoprimes are very likely to be 2-psps or 
quadratic psps (see the entries under method A+ in Table 8.5). 
The preceding discussion about good and bad choices of P and Q brings 
us now to a most intriguing point about quadratic pseudoprimes. Given n, 
we can try to choose P and Q to maximize the chance that the quadratic 
test will tell the truth about n. Such a customization procedure is entirely 
absent from the classical pseudoprime contexts. There one either chooses a 
few b-values randomly (the Miller-Rabin test), or just takes a couple of 
small values of b, such as 2 and 3 and runs b-strong pseudoprime tests. But 
in the quadratic situation, we can carefully choose P and Q to maximize the 
chance of success. 
Here is a method suggested by J. Selfridge [PSW], called method A: 
Given an odd, nonsquare integer n, let d be the first number among 
5, -7, 9, - 11, ... such that (*) = -1; then let P = l and Q = (l - d)/ 4. If, 
during this search, one finds ( *) = 0, then one has solved the problem 
because either d proves n composite or d = n and n is so small that it can be 
checked by elementary means. Here is how one can handle this in code. 
MethodA [ n )  either returns a pair of parameters that can be used, or, in the 
( *) = 0 case, it simply returns True or Fal se. The calling routine, typically 
LucasPseudoprimeQ or QuadraticPseudoprimeQ must be taught to 
recognize that a True or False settles the problem. 
MethodA[n_ / 1 0ddQ [n] && I IntegerQ[Vn] ]  : =  Module [ { d = S , j } ,  
While [ j  = JacobiSymbol [ d ,  n] == 1 ,  d = - d  - 2 Sign [d] ] ;  
1 - d 
I f [ j = =  - 1 ,  { l ,  -- } ,  I f [GCD [d , n] < n , False , PrimeQ [dJ J ) ] 
4 
LucasPseudoprimeQ [ a_, _] : = a I ;  MemberQ [ {True , False } , a] 
QuadraticPseudoprimeQ [ a_, _] : = a / ;  MemberQ [ { True , False } , a ]  
One problem with method A is that, very often, d will turn out to be 5, 
and that leads to Q = - 1, which we have seen should be avoided. Because of 
this Baillie and Wagstaff [BW] introduced method A• : same as A, but use 
P = 5 and Q = 5 in the cases where d = 5. And we can also introduce 
method A•• : same as A but start the search at d = -7 instead of d = 5. One 
can consider these methods in the context of Lucas pseudorprimes, but of 
course it makes more sense to consider the full quadratic version of the test. 
These methods are in the CNT package as MethodA and MethodAStar; 
method A•• is available in the package as MethodA [ n ,  - 7 ]  (that is, any 
starting point can be used). 

270 
8. PRI M E  TESTING WITH LUCAS SEQUENCES 
These methods are not so good in the Lucas situation, as there turn out 
to be 219 bad examples below one million. The CNT package has access to 
various lists of pseudoprimes, including a master list through 109 of any 
integer that satisfies either the U- or ¥-equation using any of methods A, 
A* , or A•• . That large list, called LucaPseudoprimesAl lTypes, can be fil­
tered to get complete lists satisfying various other conditions. For example, 
here is how to find the 219 Lucas psps under one million using method A. 
Lucaspsps = Select [LucasPseudoprimesAllTypes ,  
I <  106 && LucasPseudqprimeTest [MethodA [ I ] , I ]  & ]  
{ 323 , 377 , 1159, 1829 , 3827 , 5459 , 5777 , 907 1 ,  9179 , 10877 , 
11419 , 1 1663 , 13919 , 14839 , 16109 , 162 1 1 , 18407 , 1897 1 ,  
19043 , 22499 , 23407 , 24569 , 25199 , 2587 7 ,  26069 , 27323 , 
32759 , 34943 , 35207 , 39059 , 39203 , 39689 , 40309 , 44099 , 
46979 , 47879 , 50183 , 51983 , 53663 , 56279 , 585 19 ,  60377 , 
6388 1 ,  69509 , 72389 , 739 19 , 7507 7 ,  77219 , 79547 , 79799 , 
82983 , 84419 , 86063 , 90287 , 94667, 97019 , 97439 , 100127 , 
101919 , 103739, 104663 , 113573 , 113849 , 115439 , 11563 9 ,  
120581 , 1 2 1 1 0 3 ,  121393 , 130139 , 142883 , 150079 , 1558 19 , 
157079 , 158399 ,  158717 , 161027 , 162133 , 162719 , 164699 , 
167969 , 176399 ,  176471 , 178949 , 182513 , 18478 1 ,  189419 , 
192509 , 19522 7 ,  19780 1 ,  200147 , 20187 1 ,  203699 , 2 16659 , 
218129 , 22390 1 ,  224369 , 226529 , 230159 , 23069 1 ,  231703 , 
238999 , 242079 , 243629 , 250277 , 253259 , 256409 , 265481 ,  
268349 , 271991 , 275099 , 27739 9 ,  28337 3 ,  28417 1 ,  288919 , 
294527 , 3062 8 7 ,  308699 , 309959 , 313499 , 317249 , 324899 , 
3249 1 1 ,  327359 , 3459 13, 353219 , 364229 , 366799 , 36835 1 ,  
380393 , 381923 , 383921 ,  385307 , 391169 , 39 1859 , 396899 , 
427349 , 429263 , 430127 , 436409 , 436589 , 44 1599 , 454607 , 
455519 , 475799 , 480689 , 487199 , 500207 , 50752 7 ,  510479 , 
5 19689 , 531439 , 543449 , 548627 , 55465 1 ,  566579 , 569087 , 
572669 , 575279 , 575819 , 600767 , 606761 ,  61 1399 , 622169 , 
626639 , 635627 , 636199 , 636707 , 636999 , 653939 , 656011 , 
667589 , 676367 , 676499 , 678869 , 685583 , 686279 , 697883 , 
701999 , 708749 , 72 1279 , 732887 , 736163 , 749699 , 753059 , 
753377 , 761039 , 765687, 770783 , 775207 , 794611 , 80797 1 , 
8 12239 , 819839 , 823439 , 824879 , 82882 7 ,  833 1 1 1 ,  83599 9 ,  
839159 , 850859 , 851927 , 871859 , 87587 9 ,  885119 , 887879 , 
895439 , 895679 , 907061 , 948433 , 950821 , 960859 , 961999 , 
9675 9 1 ,  9723 1 1 , 980099, 980699 , 983903, 9945 1 7 ,  997919 } 
The quadratic test is much better. The quadratic method-A test admits only 
38 psps below 10 7• 
Select [LucasPseudqprimesAllTypes , 
I < 10 7 && OuadraticPseudqprimeTest [MethQdA [ I ]  , f ]  & ] 
{ 5777 , 10877 , 75077 , 100127 , 1 13573 , 161027 , 162133 , 
231703 , 430127 , 635627 , 851927 , 1033997 , 1 106327 , 1256293 , 
1388903 , 1697183 , 2263127 , 2435423 , 2662277 , 3175883 , 

8.2. PRI M E  TESTS USING LUCAS SEQU ENCES 
271 
3399527 , 345214 7 ,  3774377 , 3900797 ,  4 109363 , 4226777 , 
4403027 , 4828277 , 487084 7 , 5208377 , 5942627 , 6003923 , 
73539 17 , 851812 7 ,  9401893 , 9713027 , 9793313 , 9922337 } 
The LucasV test using method A* is impressive, as 913 is the only 
pseudoprime below 5 · 108. 
Select [LucasPseudoprimesAllTypes , 
LucasVPseudoprimeTest [KethoclAStar [ f ] , I ] & ]  
{ 9 1 3 } 
But the results are even more impressive when method A•• is used: There 
are no counterexamples known. 
Table 8.5 summarizes the situation with respect to various combinations of 
these tests, and includes data for some variations discussed in the exercises. 
It turns out that each of the 219 Lucas method-A pseudoprimes is 
unmasked by a simple 2-psp test. 
Or H Pseudoprime0 [ 2 , Lucaspsps ] 
False 
This leads to a famous unsolved problem. 
The PSW Challenge. Find a counterexample to: n is prime if and only if n 
passes the 2-psp test and n passes the Lucas test with P = 1 and Q = 
(1 - d) / 4  where d is the first element of 5, -7, 9, - 11, 13, ... such that 
(*) = -1. 
But the preceding points fade somewhat when we look at the superb 
performance of methods A* and A** . Baillie and Wagstaff [BW] checked the 
integers below 108 and found no pseudoprimes at all with respect to the 
quadratic method-A• test! Let us use the term pseudoperfect to refer to a 
pseudoprime test for which no counterexample to its perfection is known. 
So the quadratic method A* test is pseudoperfect. The method A** approach 
has the implementation advantage that P is fixed at 1. Like method A•, 
this approach leads to a quadratic test that is pseudoperfect. Indeed, even 
the LucasV version of this is pseudoperfect. Thus we have the following 
challenges. 
The Lucas Pseudoprime Challenges. 
1. Find a counterexample to: n is prime if and only if n is not a qua­
dratic pseudoprime for P = 1 and Q = (1 - d) / 4, where d is the first 
element of 5, -7, 9, -11, 13, ... such that ( *) = - 1, but with (P, Q) = 
(- 1, 1) replaced by (5, 5). 
2. Find a counterexample to: n is prime if and only if n is not a { 1, Ql­
quadratic pseudoprime where Q = (1 - d) / 4, and d is the first ele­
ment of -7, 9, - 11, 13, ... such that ( *) = - 1. 

272 
8. PRI M E  TESTING WITH LUCAS S EQUENCES 
Method 
First two pseudoprimes 
1 
A. Lucas 
323, 377 
2 
A· , Lucas 
323, 377 
3 
A .. ( = A start at -7) Lucas 
1 127, 1 1 59 
4 
A, LucasV 
1 127, 5777 
5 
A· , LucasV 
913 
6 
A•• , LucasV 
7 
A, Quadratic 
5777, 10877 
8 
A• , Quadratic 
9 
A, Strong quadratic 
5777, 10877 
10 
N, Strong Quadratic 
1 1 
A+ (Exercise 9.17), Lucas 
1891, 2047 
12 
A• , LucasV 
1003, 2047 
13 
A+ , Quadratic 
2047, 4181 
14 
2 -pseudoprime 
341, 561 
1 5  
2 -strong pseudoprime 
2047, 3277 
16 2 -strong psp & 3 -strong psp 
1373653, 1530787 
17 
Perrin, basic 
271441, 904631 
18 
Perrin, symmetric 27664033, 46672291 
19 
Fibonacci 
323, 377 
20 
FibonacciV 
1127, 3751 
21 
Quadratic Fibonacci 
4181, 5777 
22 
Strong Quadratic Fibonacci 
4181, 5777 
23 
Carmichael numbers 
561, 1 105 
Number of pseudoprimes 
219 ; 659 ; 191 1 ; 3999 
219 ; 659 ; 1911 ; 3999 
203 ; 649 ; 1976 ; 4146 
18 ; 55 ; 145 ; 280 
1 
0 
1 1  ; 38 ; 105 ; 214 
0 
1 1 ; 38 ; 105 ; 214 
0 
134 
103 
67 
245 ; 750 ; 2057 ; 5597 
46 ; 162 ; 488 ; 1282 
7 ;  2 1 ; 58 ; 52593 
2 
55 
155 
271 
16; 56 
14 ; 41 
43 ; 105 ; 255 ; 646 
Table 8.5. A summary of the efficacy of several customized tests. The strong 
versions are discussed in the next section. A+ is used for the variation of method A 
that actively seeks d so that ( ˿) 
= + 1 .  
3. Find a counterexample to: n is prime if and only if n is not a { 1, QI· 
LucasV pseudoprime where Q = (1 - d)/ 4, and d is the first element 
of -7, 9, - 1 1, 13, ... such that ( f) = - 1. 
And here is a final challenge. It applies only to numbers ending in a 3 
or 7, because, for the cases 1 and 9, n would be such that ( ޸)  = + 1, and that 
n 
has an impact on the independence of the tests. But no counterexample is 
known for the 3 and 7 cases, so one might use a 2-psp test followed by a 
Fibonacci psp test on such numbers; this would be a very fast test that is 
applicable half the time. 

Search bound 
106 ; 107 ; 108 ; 5 · 108 
106 ; 107 ; 108 ;  5 · 108 
106 ; 107 ; 108 ; 5 · 108 
106 ; 107 ; 108 
5 108 
5 ·  108 
106 ; 107 ; 108 ; 5 · 108 
5 ·  108 
106 ;  107 ; 108 ;  5 . 108 
5 - 108 
106 
106 
106 
106 ; 107 ; 108 ;  109 
106 ; 107 ; 108 ; 109 
107 ;  108 ; 109 ;  1016 
106 
50 · 109 
106 
106 
105 ; 106 
105 ; 106 
106 ;  107 ; 108 ; 109 
8.2. PRI M E  TESTS USING LUCAS SEQU ENCES 
273 
Comments 
Fixes P = 1; none are 2 -psps 
1 
P is 1 or 5; none are 2 -psps 
2 
Fixes P = 1 ;  none are 2 -psps 
3 
Fixes P = 1 
4 
P is 1 or 5; neither a 2 -psp nor a 5 -psp 
5 
The fastest pseudoperfect test ? Fixes P = 1 
6 
Intersection of 1 and 4 
7 
Intersection of 2 and 5 
8 
Curiosity: same data as in 7 
9 
10 
38 are 2 -psps; 9 are strong 2 -psps 1 1  
29 are 2 -psps; 8 are strong 2 -psps 12 
Intersection of 1 1  and 12 1 3  
There are infinitely many 
1 4  
There are infinitely many 15 
There are infinitely many 16 
The 3, 0, 2, 3, 2, 5 . . . .  sequence; E x.  8. 18 17 
Both directions, plus signature 
18 
There are infinitely many 19 
Surprise: V yields a worse test than U 20 
2 1  
22 
There are asymptotically x2i7 under x 23 
The Fibonacci Pseudoprime Challenge. Find n such that n = 3 or 7 
(mod 10), and n is both a 2-psp and a Fibonacci psp. 
'1 Strong Quadratic Pseudoprimes 
Just as the notion of a strong pseudoprime provided a major improvement 
over the simple pseudoprime test involving a single exponentiation, so too 
can we improve our quadratic criteria. One traditional notion of strong 
Lucas pseudoprime fixes Q = 1 and looks at the V-sequence only. But we 
will consider both the U- and V-sequences, which is equivalent to looking 
at properties of powers of a. 

274 
8. PRIME TESTING WITH LUCAS SEQUENCES 
Recall that the quadratic pseudoprime test checks whether an-e<n> = 2 Q 
(mod n). We turn this into a strong test with the simple observation that if 
n is prime and cf squares to an integer modulo n, then cf is congruent (mod 
n) to either an integer or an integer times ..Jd,. This is just a restatement of 
the doubling rule, which says that if U2e = 0 (mod n) then one of Ue or Ve is 
0 (mod n). So we can follow the strong pseudoprime scenario: Write n - e(n) 
as 2e m where m is odd, look at the U and V values for indices m, 2 m, 4 m, 
. . .  , n + 1. If Um =  0 (mod n), we learn nothing new and can proceed directly 
to a check that Vn-£ = 2Q (mod n). But if the first U-value is not 0, we 
examine the U-sequence until we get a O; then we check that the preceding 
V-value is 0 (mod n); and again we then proceed to the end to make sure 
2 Q shows up. 
Here is some code to compute the U V-sequences. Equations (8) and (10) 
are used to move up at each step. For V, this requires knowing certain 
powers of Q, and they are kept along and updated (by simply squaring) as 
the third entry of the list and discarded at the end. 
uvsequencel [ { P_, Q_} ,  n_ ? OddQ] 
: = 
Module [ {m = n - JacobiSymbol [P2 - 4 Q ,  n ] } ,  
e = IntegerBxponent [m , 2 ] ; m / =  28 ; 
Transpose [ (Drop [ I ,  - 1 ] & /0 
NestList [Mod [ { 1 1[1:0 11[ 2:0 , 1 1[2:0 2 - 2 1 1[3:0 , 1 1[3:0 2 } , n] & , 
Append [Ԭ [ { P ,  Q} ,  n] [m] , PowerMod [ Q ,  m ,  n ] ] ,  e] ) ] ]  
The version in the CNT package can produce nice gridboxes. The three 
examples that follow are for primes; note how the Os slide from the U­
sequence to the V-sequence at one point, except for the case where the U­
sequence is only 0. 
UVSequence [ { 3 ,  13 } , 539039 , UseGridBox -+ True ] 
Powers 
m 
2 m  
22 m 
23 m 
24 m 25 m = 539040 
u 280023 144566 38321 1  153412 236877 
v 
5531 1 283184 516152 474252 
0 
UVSequence [ { 3 ,  13 } , 533261 , UseGridBox -+ True] 
Powers 
m 2 1 m = 533262 
u 
0 
0 
v 445985 
26 
uysequence [ { 3 ,  13 } ,  914161 , UseGridBox -+ True ] 
Powers 
m 
2m 
22 m 23 m 24 m = 914160 
u 411591 875637 187752 
0 
0 
v 596925 243841 
0 
2 
2 
0 
26 

8.2. PRI M E  TESTS USING LUCAS SEQU ENCES 
275 
Recall from earlier work that 658801 was the first quadratic psp for the 
parameters (13, -2). The strong test unmasks it. 
UVSequence [  { 1 3 , - 2 } , 658801 , UseGridBox -+ True ] 
Powers 
m 
2m 
22 m 
2a m 
24 m = 658800 
u 244970 
0 
0 
0 
0 
v 320593 378589 1 13280 1 16261 
2 
Now here is how to implement the strong quadratic test using the U V­
sequence. 
StrongOuadraticPseudoprimeTest [ {P _, O_} ,  n_ ? OddO] 
• -
Module [ { d = P
2 - 4  o , g ,  u ,  v } ,  g = GCD [O d ,  n] ; 
Wbicb [ l < g < n ,  False , g = =  n ,  PrimeO [n] , 
True , { u ,  v} = UVSeqyepce [ { P ,  0} , n] ; 
v [- l:n = = Mod [ 2 0 ( 1-.JacobiSpbol [ d , n ] ) /2
' D) && 
( u l[l:n = =  o 1 1  MemberQ [ v ,  O ] ) 1 1  
StrongQuadraticPseudoprimeO [ { P  _ , 0_} ,  n_ ? OddO] 
: = 
I PrimeO [ n ]  && StrongOuadrat.icPseydoprimeTest [ { P ,  0} , n] 
It works nicely on the cases of fixed P, Q. Here are 39 large numbers 
that are quadratic pseudoprimes for the Fibonacci case (P = 1, Q = - 1). 
f ibpsps = Select [StrongPseudoprimes [ { 2 ,  3 }  , 1011 ] , 
Ouadrat.icPseydoprimeTest [ { 1 , - 1 } , I] & ] 
{ 10 164924 1 , 1 1798784 1 , 579606301 ,  927 10656 1 ,  1 157839381 ,  
22 1787990 1 ,  262678392 1 , 269373975 1 ,  321503175 1 ,  406094238 1 ,  
47 10862501 , 5755495201 , 82 14723001 , 997458066 1 ,  15114550951 , 
15579919981 , 17475044329 , 2 127602862 1 , 2536686666 1 ,  
277 16349961 , 291 18033 181 , 30481338889 , 425507 167 8 1 ,  
4353654582 1 ,  44453586241 , 44732778751 , 483548105 7 1 ,  
52139 147581 , 53700690781 , 74 19009780 1 ,  7528507035 1 ,  
75350936251 , 79696887661 , 823 18050361 ,  8382829455 1 ,  
9 1609762861 , 9613334 1781 , 9807156156 1 ,  985 1539302 1 }  
We unmask almost half of them when we move to the strong test. 
Lengtb [ fibpsps ] 
Length [ 
Select [ fibpsps , StrongOuadraticPseudoprimeTest [ { l ,  - 1 } , I ]  & ]  ] 
39 
22 
It is hard to judge the benefits of the strong test for the situation where 
the P and Q are chosen in a customized fashion for each n. This is because 
we know of no quadratic pseudoprimes whatsoever for this test! Still it does 
make sense to use the strong test because no extra work is involved. 

276 
8. PRI M E  TESTING WITH LUCAS S EQU ENCES 
We can now describe how Mathematica's PrimeQ works. The descrip­
tion below is not completely accurate in the sense that it uses a slightly 
different strong Lucas test than the one presented here. 
1. If n has a small divisor, return False. Check this via a gcd with the 
product of primes under 100. 
2. If n is proved to be composite by the 2-strong pseudoprime test, 
return False. 
3. If n is proved to be composite by the 3-strong pseudoprime test, 
return False. 
4. If n is proved to be composite by the strong Lucas pseudoprime test, 
return False. 
5. Return True. 
We do not know if this test always tells the truth. Note that it is not a 
probabilistic test: There is no randomness involved. The question is simply 
whether there is a composite that is so well disguised that it slips by the 
three (really, four) tests. There are heuristic reasons for believing that such 
examples exist. But we know, thanks to Bleichenbacher's data set of 2- and 
3-strong pseudoprimes to 1016 , that this test is valid to that bound. 
K Primality Testing's Holy Grail 
It is generally believed that no simple combination of a fixed number of 
pseudoprime tests will characterize primality. On the other hand, probably 
2 (log n)2 strong-pseudoprime tests do the job; this follows from a conjecture 
known as the extended Riemann Hypothesis (Section 4.2) and has as a 
consequence that primality testing can be done in polynomial time. Thus it 
is tempting to hope that some simple test might indeed characterize the 
primes, and there are several for which the first counterexample is quite 
large. We list here some open questions in this direction. 
Find counterexamples to the assertion that any of the following condi­
tions characterize primality: 
1. The LucasV pseudoprime test with P and Q chosen by method A** . 
2. The quadratic pseudoprime test using method A• . 
3. The strong quadratic pseudoprime test using method A* . 
4. The quadratic pseudoprime test using method A•• . 
5. The strong quadratic pseudoprime test using method A** . 
6. The 2- and 3-strong pseudoprime tests and also the Lucas 
pseudoprime test using method A (or any of the other quadratic tests 
just mentioned). 
While the last assertion seems the most complicated, the existence of a 
database of all the 2- and 3-spsps below 1016 allows us to say that there is 
no counterexample below that bound. No such comparable results exist 
(yet) for the other criteria. This explains why Mathematica uses (a variation 
of) Method 6 in its PrimeQ: It is guaranteed correct below 1016 . Also, when 

8.2. PRI M E  TESTS USING LUCAS SEQUENCES 
277 
considering how to define a general-purpose prime-testing function, atten­
tion must be paid to speed. For almost all composite inputs, a 2-psp or a 2-
strong psp test will suffice; so it makes sense to use such a simple test first. 
And it is always wise, right at the beginning, to check the input for small 
factors, perhaps by doing a GCD with some precomputed large product of 
small primes. 
Exercises for Section 8.2 
8.8. Why, in the Lucas certification procedure described in the text, would 
it be foolish to begin the Q-search at either 0 or 1? 
8.9. Determine, with a proof via Lucas certificates, which numbers of the 
form p1 p2 · · · Pn - 1 are prime, where n ::s; 100 and Pi is the ith prime. 
8.10. Write a program that uses the Lucas prime-proving method to gener­
ate a true certificate of primality, in the sense that all primes in the factor­
ization of p + 1 are certified by the same method, and so on recursively 
down to 2. 
8.11. Show that the Lucas-Lehmer algorithm will return False if the 
input has the form 2k - 1 where k is not prime. 
8.12. Explain why, in the Lucas-Lehmer algorithm, one could replace the 
choice P = 2 and Q = -2 by P = 2 and Q = 3. 
8.13. Prove that if n is a {P, QI quadratic psp then n is also a quadratic 
pseudoprime for {-P, QI. 
8.14. Show that if n is a quadratic pseudoprime for {P, QI, then n is a Q­
pseudoprime. 
8.15. Use Exercise 2.40 to explain why 2-pseudoprimes are likely to be b­
pseudoprimes for a greater than average number of bs. Investigate this by 
counting the number of such bs when n = 341. For how many bases less 
than 2047 is 2047 a b-psp? Show how this phenomenon combines with the 
perfect square problem discussed in the text to explain why the 2-strong 
pseudoprime 2047 is a { 14, 21-quadratic pseudoprime. 
8.16. Do some computations to confirm some of the values in Table 8.5. In 
particular, verify that 913 is the only small LucasV pseudoprime under 
method A• . 
8.1 7. To see first-hand the difference between the ( *) = + 1 and ( *) = - 1  
situations, modify the functions that define the method A and method A• 
parameter choices so that they search for a d with ( *) = + 1; call this 
method A+ . Count the number of Lucas pseudoprimes for method A+ , 
confirming some of the entries in Table 8.5. Check how many of the exam­
ples you find are 2-pseudoprimes. This should confirm the discussion in the 
text that these two tests are not independent when ( *) = + 1. 

278 
8. PRIME TESTING WITH LUCAS SEQU ENCES 
8.18. 
(Perrin's Test) The following test for primality - essentially a 
cubic test - is not quite as good as the quadratic tests of this chapter, but 
it is noteworthy for its simplicity. Perrin's sequence, Ian }, is defined by 
an = an-2 + an-3. where ao = 3, ai = 0, and a2 = 2. 
(a) Implement a routine Perrin [ n ,  m] that quickly returns the mod-m 
value of an . 
(b) Show that each of the three roots of x3 - x - 1, the characteristic polyno­
mial of the recurrence, is such that its powers (complex numbers, perhaps) 
satisfy the Perrin recurrence (though not the initial conditions). 
(c) 
Show that if a, /3, and y are the three roots of x3 - x - 1 and c; are 
constants, then bn = c1an + c2f3n + c3yn satisfies the Perrin recurrence. 
(d) 
Show that taking c1 = c2 = c3 = 1 in (c) yields a solution to both the 
recurrence and the initial conditions. 
(e) Observe experimentally that if p is prime, than ap = 0 (mod p); this is 
called Perrin's test for primality. Prove it by establishing (a + f3 + y)P = 
aP + f3P + yP (modp). A subtle point: Just as in the Lucas case, we are work­
ing in Z[a, f3, y], and some algebraic knowledge is required to conclude that 
p divides n in Z[a, f3, y] means that p divides n in Z. You may assume this 
fact in this problem. For the record, it can be proven by first proving that 
every element in Z[a, /3, y] has the form n0 + n1a + n2/3 + n3y + n4af3 + 
n5ay + n6f3y + terms involving squares (terms involving cubes reduce 
because the polynomial allows one to reduce them to quadratic powers). 
(f) Call n a Perrin pseudoprime if n is not prime and n passes Perrin's 
test. Write a program that searches for and finds the first Perrin pseudo­
prime. Find the second. 
(g) Extend the recurrence backwards, defining a_n from a-n+l ,a-n+2, and 
a-n+3 so that the main recurrence holds. What pattern do you observe in 
a_P when p is prime? What is the first Perrin psp if this negative condition 
is taken into account? (These are called symmetric Perrin pseudoprimes.) 
(h) Generalize parts (a)-(g) to sequences defined by an = ran-l - san-2 + 
an-3. where a0 = 3, a 1 = r, and a2 = r2 
- 2s. 
For more information on Perrin pseudoprimes see [AS] and [KSW] . 

CHAPTER 9 
Prime Imaginaries and 
Imaginary Primes 
9.0 Introduction 
The square root of - 1  is an imaginary number. We have already seen that 
this number has a concrete realization modulo certain primes; for example, 
2 is a square root of - 1  (mod 5) because 22 = 4 = - 1  (mod 5). And in the 
domain of numbers using the traditional imaginary number i, one can 
define primes of the form a + b i. For example, 1 + 2 i is a prime, but 1 + 3 i is 
not. Thus, we have prime imaginaries, such as 2 (mod 5), and imaginary 
primes, such as 1 + 2 i. Remarkably, there are several important connec­
tions between the two concepts, and each will help us gain a deeper under­
standing of the other. 
In this chapter we investigate in some detail the problem of writing a 
prime, or an arbitrary integer, as a sum of two squares. We will solve this 
problem with a very fast algorithm, and then apply our knowledge to the 
question of primes in the complex numbers, and also to a problem of chemis­
try involving electrical energy in the lattice structure of salt. A further 
application of the imaginary realm is to an extension of the notion of qua­
dratic reciprocity to fourth powers. 
9.1 Sums of Two Squares 
'1 Primes 
Some primes are a sum of two squares: 2 = 1 + 1, 5 = 1 + 4, 13 = 4 + 9, 17 = 
1 + 16. Others, such as 3 and 1 1, are not. A landmark result of number 
theory is the theorem of Fermat that tells us exactly which primes are the 
sums of two squares. 
Theorem 9.1. A prime p is a sum of two squares if and only if p '1= 3 (mod 4). 

280 
9. PRIME IMAGI NARI ES AND IMAGINARY PRI M ES 
One direction is quite easy: If p = 3 (mod 4), then p cannot have the 
form a2 + b2 because a square is congruent to 0 or 1 (mod 4) and so a sum of 
two squares is 0 + 0, 0 + 1, or 1 + 1; 3 is therefore not a possibility. This 
applies to any integer, not just primes. Fermat's proof of the other direction, 
showing that all other primes can be so represented, was by a method 
called "infinite descent". He assumed there was a counterexample p, and 
showed that there would then be a smaller counterexample. Such a process 
would eventually lead to 5, but 5 is representable, as 1 + 4. Fermat's 
method is pretty, and Fermat himself applied the idea to other problems of 
number theory, such as proving that the equation x4 + y4 = z4 has no non­
trivial solutions. 
But the infinite descent method is not very useful for a computer algo­
rithm, so we will not present the details here. We will instead present an 
algorithm due to H. J. S. Smith [CELV] (1855) that not only proves that p 
has the desired representation, but also finds, and quickly, the integers a 
and b that work. Some of the ideas go back to Hermite and Serret a few 
years earlier; they were working in the language of continued fractions, but 
Smith's formulation, using the Euclidean algorithm, is simpler. In fact, the 
solution to p = a2 + b2 is unique (up to order and sign); see Exercise 9.4. 
Smith's algorithm requires that we can quickly get a square root of - 1  
(mod p). This was discussed in Theorem 6.4, where it was shown that the 
primes that admit such square roots are precisely the primes congruent to 1 
(mod 4). Chapter 6 presented some general methods for modular square 
roots, but the case of H can be handled quickly with a simple formula: If 
p = 1 (mod 4) and c is a nonresidue for p, then Euler's criterion says that 
c<P-1>12 = - l (mod p). Because p = 4k + l, (p - 1)/2 is even and so c<P-1>14 is 
the desired square root of - 1. The code that follows implements this, using 
a trial-and-error method to find a suitable value of c. Note that SqrtNeg­
One returns the smaller of the two values of H. 
Honresidue [p_ ? OddQ] : = Module [ { n = 0 } , 
While [ JacobiSymbol [Prime [ ++n] , p ]  = =  l ]  1 Prime [ n ] ] 
SqrtHegOne [p_] : =  
Module [ { a = PowerMod [Honresidue [p] , (p - 1 )  / 4 ,  p ] } ,  
First [ Sort [ { a ,  p - a} ] ] ]  / 1 Mod [p , 4 ]  = =  1 
SqrtRegOne [p_] : = { }  / 1 Mod [p , 4 ]  == 3 
SqrtHegOne [ 2 ]  = { l } 1 
SgrtRegOne [ 181] 
19 
Mod [ l92 , 18 1 ]  
1 8 0  

Algorith m 9 . 1 . Sm ith 's Algorith m 
9. 1 .  SUMS OF TWO SQUARES 
281 
Suppose that p is a prime and p = 1 (mod 4). To find the (unique) solution 
to p = a2 + b2 , let x2 = - 1  (mod p) and apply the Euclidean algorithm to the 
pair (p, x). The first two remainders that are less than yp are the a and b 
that solve the equation. 
This is a remarkable algorithm because it is both easy to implement 
and very fast. Note that once we have a we can immediately get b as 
Y p - a2 • Here is some code that finds a, which turns out to be the middle 
remainder in the remainder sequence. The main routine has the two argu­
ments p and x, but an auxiliary case with three arguments carries out the 
recursion: the extra argument keeps track of p so the stopping criterion can 
be checked. Thus, the code is almost identical to the recursive technique for 
the basic Euclidean algorithm. Note that the condition 
I ; x2 
ݒ p is not 
appended to the second case, because the first line will be checked first: 
Mathematica tries to use particular cases before general cases. This saves a 
few multiplications. 
CentralRemainder [p_ ,  m_ , x_] 
: = x I ;  x2 < p 
CentralRemainder [p_ ,  m_, x_] 
: = 
CentralRemainder [p , x ,  Mod [m, x ] ] 
CentralRemainder [p_ ,  x_] 
: =  CentralRemainder [p , p ,  x] 
Sum2Squares [p_] : =  
Module [ { a = CentralRemainder [p , SqrtllegOne [p] ] } , 
{-vp:-;z , a} ] / ;  Mod [p , 4 ]  == 1 
To see how fast this is, we can try it on a very large prime congruent to 
1 (mod 4). We use the package function RandomPrime with a second argu­
ment of { l, 4} to find a large random prime congruent to 1 (mod 4). 
p = Randqmprime [ lO ,  { 1 ,  4 } ] 
79616 17333 
Now it takes only an eyeblink to write p as a2 + b2 • 
{ a ,  b }  = Sum2Squares [p] 
{ 60922 , 65193 } 
It is easy to check. 
a2 + b2 
7961617333 
And this algorithm is very fast on 100-digit numbers. 

282 
9. PRIME IMAGI NARIES AND IMAGI NARY PRIMES 
p = RandomPrime [ 100 , 
{ 1 ,  4 }  ] 1 
{ a ,  b }  = Sum2Squares [p] 
{ 1126407463075065494382239920368702 105884398675480, 
95436801890894986169830666 134753241279884292414373 } 
P = =  a2 + b2 
True 
The proof that this algorithm works is a little intricate, but entirely 
elementary. This proof was found by an intensive investigation of the data 
in the extended Euclidean algorithm. Note that Theorem 9. 1 is a conse­
quence of the theorem that follows. 
Theorem 9.2. Smith's Algorithm. If p is a prime and p = 1 (mod 4), let 
x E Zp be a solution to x2 = - 1  (mod p) and let a be the first remainder that 
is smaller than ,[j) when the Euclidean algorithm is applied to the pair p 
and x. Then ../ p - a2 is an integer; that is, a is one member of a pair (a, b) 
that satisfies p = a2 + b2• 
Proof. Recall the sequence {t; }  that is produced by the extended gcd algo­
rithm of Section 1.2; its main property is that tix = ri (mod p), where 
{p, x, r2, . . .  , rn l is the sequence of remainders, with rn = 1. Moreover, as 
was shown in Section 1.2 (Exercise 1.18), the t-sequence alternates in sign, 
tn+I = ±p, and the absolute values of the ti themselves (with the exception 
of the initial 0 and 1 if x > p / 2) form a Euclidean algorithm remainder 
sequence in reverse, with quotients the reverse of the main sequence of 
quotients {qi}. It may be helpful to focus on an example, so let p = 73; then 
x can be either 27 or 46 and we'll use 27. We shall prove that several of the 
patterns evident in the table that follows hold whenever x is a square root 
of - 1  modulo p. 
FullGCD [ 7 3 , 27 , EztendedGCDValues -+ ±rue ] 
Remainders 
!---· -· 
1--.. -·-
ݑ·
· 
. -
7 3  
2 7  
1 9  
8 
3 
2 
1 
0 
Quotients 
s 
1 
2 
0 
1 
1 
2 
- 1  
2 
3 
1 
- 7  
2 
1 0  
- 2 7 
I 
I 
i 
. 
-
t 
0 
1 
- 2  
3 
- 8  
1 9  
- 2 7 
7 3  
The proof leans heavily on the continuant functions Q, which give each 
remainder as a function of the quotients that follow it (see Section 1.2). Let 
rm be the first remainder that is less than yp. Then 

P = Q(q1 ' · · · , Qn ), 
rm-1 = Q(qm , ... , Qn), 
ltm I = Q(Qm-1 • . . .  , qi ) = Q(ql ' . . .  , Qm- d · 
9. 1 .  SUMS OF TWO SQUARES 
283 
(1) 
The first two equations hold because each remainder rj begins a Euclidean 
algorithm remainder sequence; the third equality holds because the abso­
lute values of the t; are a remainder sequence with the same quotients and 
(Exercise 1.18(c)) Q is invariant under reversal of its arguments. (The 
exceptional case in which t1 is not part of a remainder sequence occurs 
when x > p / 2, and when this happens m <!: 2.) Now, the sum-of-products 
characterization of Q (Proposition 1.4) implies that 
because each product occurring as a summand in the expanded right-hand 
side also occurs in the left-hand side. This last inequality combines with (1) 
to yield p <!: rm-i ltm l, and because rm-l > {Ji , tm must be less than {Ji. 
To conclude the proof, simply observe that tm x = rm (mod p), so p 
divides r; - t; x2 • But t;. x2 = -t;. . Thus, r; + t; is divisible by p. Each of 
rm and tm is less than {Ji, so r; + t; < 2p. The only positive integer less 
than 2p that is divisible by p is p itself, whence r; + t; = p. 
D 
޷ The General Problem 
With very little more work, Smith's algorithm can be used to obtain a 
complete list of the representations of n as a sum of two squares. Two key 
observations allow this. First, note that the proof of Theorem 9.2 never used 
the primality of p; the result works in exactly the same way if p is replaced 
by an arbitrary integer n for which H modulo n exists. And a second key 
idea is that one should focus first on the primitive representations; a sum 
a2 + b2 is called primitive if gcd(a, b) = 1. Remember that the values of a 
and b can be negative. 
Theorem 9.3. An integer n admits a primitive representation as a2 + b2 if 
and only if the square root of - 1  exists modulo n. 
Proof. All congruences in this proof are modulo n. We will show that there 
is a one-one correspondence between primitive representations n = a2 + b2 
with positive a and b and pairs {x, n - x) where x2 = - 1  and x < n - x. Sup­
pose that we are given such a pair {x, n - x). Then we can apply Smith's 
algorithm to the pair n and x to get a primitive representation n = a2 + b2 , 
with a > b. This is indeed primitive because a and b coincide with rm and 
rm+! (see Exercise 9. l(g)) and the gcd of these two remainders coincides 
with gcd(n, x), which is 1 (because x2 = - 1). Moreover, the proof of Smith's 
algorithm yields bx = a, which means x = ab-1 [b-1 exists because 

284 
9. PRI M E  I MAG I NARIES AND I MAGI NARY PRI M ES 
gcd(b, n) = 1, else a and b would have common factor] and it follows that 
different values of x yield different pairs a, b. 
It remains to show that every primitive representation arises in this 
way. So suppose that a2 + b2 is a primitive representation of n with positive 
a, b. Then a2 = -b2 and so ab-1 is a mod-n square root of -1. Assume for a 
moment that (the reduced residue of) ab-1 is the smaller of the two square 
roots of - 1, and call this value y. Applying Smith's algorithm to n and y 
yields a primitive solution {e, d} with e > d > 0 and such that ed-1 = y. It 
follows that ab-1 = ed-1 , so ad = be. But each of a, b, e, and d is less than 
../Ti, so ad and be are less than n; therefore ad = be. And gcd(a, b) = 1, so 
a = e and b = d. If the assumption is false, then the other square root of - 1  
is the smaller. But this other square root is -ab-1 , which is the same as the 
inverse of ab-1 , or ba-1 • Now we can use the arguments from the first case 
to get bd = ae, or b = e and a =  d, which also means that the pair {a, b} is 
the same as {e, d}. So in either case the pair {a, b} arises from the Euclidean 
algorithm method applied to n and a mod-n square root of - 1. 
o 
To implement a primitive representations algorithm we first make 
centralRemainder a listable function so that we can feed a bunch of 
square roots of - 1  to it, and then we define SmallSqrtsNegOne to give the 
smaller of each pair of such square roots. 
Attributes [CentralRemainder] = Li stable i 
SmallSqrtsRegOne [ n_] : = Select [SgrtMoclAll [ - 1 ,  n ]  , I < n I 2 & ] 
PrimitiveReps [n_] : =  ( 
avals = CentralRemainder [ n ,  Smal lSqrtsRegOne [ n )  ) i 
Sort /fl Transpose [ { avals , ,.Y n - avals2 } ] ) I i n > 0 
PrimitiveReps [ l ]  = { { O ,  l } } i 
PrimitiveReps [OJ = { }  i 
PrimitiveReps [6565] 
{ { 4 7 ,  66 } ,  { 33 , 74 } ,  { 18 , 79 } ,  { 2 ,  81 } }  
One last step is needed to get the complete set of representations of n as 
a sum of two squares. If n = a2 + b2 where gcd(a, b) = d > 1, then n = 
d2 (a/ d)2 + d2 (b/ d )2 , where the pair a/ d, b/ d is a primitive representation 
of n / d2 • So we can proceed by finding the possible values of d and then 
using PrimitiveReps on n/ d2• We find the possible values of d by looking 
at all divisors of n. Of course, if n is too large to be factored, then this 
approach will be stopped in its tracks. 
SqrtSquareDivisors [n_] : = Select [../Divisors [n] , IntegerQ] 
SqrtSquareDivisors [ lOO] 
{ 1 ,  2 ,  5 ,  10 } 

9.1 . SUMS OF TWO SQUARES 
285 
Attributes [ PrimitiveReps ] = Listable 1 
Genera1Sum2Squares [ O ]  = { { O ,  O } } 1 
Genera1Sum2Squares [ n_] 
: = (d = SqrtSquareDivisors [n] 1 
Sort [Apply [ Join, PrimitiveReps [n I d2 ] d ] ] )  
Genera1Sum2Squares [ l 12132 ] 
{ { 24 , 334 } , { 136 , 306 } , { 206 , 264 } }  
Some sum-of-squares functions are included in the standard Number­
TheoryFunctions package. 
SumOfSquaresRepresentations [ 2 ,  3380] 
{ { 4 ,  58 } ,  { 26 , 52 } ,  { 38 , 44 } }  
The package also includes a function that gets representations of d squares 
provided d and n are not very large. The algorithm for this uses recursion 
on d (see Exercise 9. 7). 
SumOfSquaresRepresentations [ 3 ,  3380] 
{ { O , 4 ,  58 } , { O , 26 , 52 } ,  { O , 38, 44 } , { 4 ,  40 , 42 } , { 8 , 20, 54 } , 
{ 1 0 ,  12 , 56 } I { 10 , 24 , 52 } I { 20 , 26 , 48 } I { 22 , 36 , 40 } }  
޶ How Many Ways 
Let rd (n) be the number of ways of writing n as a sum of d squares. We 
take order and sign into account so, for example, r2(5) = 8 because of the 
representations { 1, 2}, { 1, -2}, {- 1, 2}, { - 1, -2}, {2, l}, {2, - 1}, { -2, 1}, 
{ -2, - 1}. This is a natural way to view the problem because we are, in 
essence, counting the number of integer lattice points on the circle of radius 
../5 (see Figure 9. 1). 
2 .  
• 
l • 
• 
0 .  
• ·  
• 
• 
• 
· • 
• · 
. 
. 
. 
. 
.. 
. 
. .  
-2 
- 1  
0 
1 
2 
Figure 9.1. The eight representations of 5 as a sum of two squares correspond to 
the eight lattice points on the circle centered at (0, 0) and having radius ../5. 
Indeed, this geometric interpretation of the problem helps resolve a fact 
that might otherwise seem mysterious. On average, the value of r2(n) is 1C. 

286 
9. PRI M E  I MAG INARIES AND I MAGINARY PRI M ES 
Here is some evidence. The r2 function is included as SumOfSquaresR in 
Mathematica's standard NumberTheoryFunctions package. We should be 
precise about what average means: It is the asymptotic average 
Needs [ " Number':rbeory' NumberTbeoryPunctions ' " ]  
n = 5000 i 
3 . 1 4 1  
.E..0 H [SWlOfSquaresR [2 , i ] ] 
n 
Exercise 9. 11 discusses why the limiting value of this expression is rr. 
Now let us turn our attention to how one can quickly compute r2(n). 
The derivation of a useful formula breaks into several steps. 
Prof. We can exhibit a direct one-one and onto correspondence f between 
the representations of n and those of 2n. 
f [ { a_, b_} ) : = {a - b , a + b } 
It is easy to check that f is one-one; for example, this follows from the fact 
that the determinant of ( 4 -/ ) is nonzero. To see that f gives representa-
tions of 2 n just perform the necessary algebra. 
(a - b) 2 + (a + b) 2 / / Simplify 
2 ( a2 + b2 ) 
To prove that f is onto we need a function g that goes from representations 
of 2n to representations of n and is such that f[g(a, b)] = (a, b). Here is such 
a function. 
g [ { x_, y_} ]  : = {x + y , y - x } / 2 
Apply [ Plus , g [ {c , d } ] 2 ] / / Simplify 
_.!_ (c2 + d2 ) 
2 
f [g [ {c ,  d } ] ] I I  Simplify 
{ c , d} 
This completes the proof of the lemma. 
o 
Lemma 9.4 means that, in our investigation of r2(n), we can assume 
that n is odd. We have already seen that primitive representations play a 

9. 1 .  SUMS OF TWO SQUARES 
287 
crucial role, so let r2 (n) denote the number of primitive representations of n 
as a sum of two squares. Formulas for r2 and r2 are closely related to 
the number-of-divisors function T introduced in Section 3.3. Recall that 
r(paqb · · · ) = (a + l)(b + 1) · · · .  Now, we begin by getting a count of the primi­
tive representations. This is easy because our previous work reduces this to 
counting the number of mod-n square roots of - 1. 
Lemma 9.5. Suppose that n is odd and n = pE' · · · pF' . Then r2(n) = 0 unless 
each Pi is congruent to 1 (mod 4), in which case r2 (n) = 21+2 • 
Proof. Recall from Theorem 9.3 that the number of primitive representa­
tions, where order and sign are ignored, is in one-one correspondence with 
the number of mod-n square roots of - 1  that are less than n/ 2. If n has a 
prime divisor, q, that is congruent to 3 (mod 4), then because - 1  has no 
mod-q square root, it can have no mod-n square root. This means that there 
are no primitive representations of n. If no such primes occur in the factor­
ization of n, then we must count the number of square roots of - 1  (mod n). 
Recall from Exercise 6.23 that each power of a prime congruent to 1 (mod 4) 
admits two square roots of - 1; the Chinese Remainder Theorem is used to 
paste together such roots to get all the square roots modulo n. Therefore 
there are 21 square roots in all, and because they come in pairs {x, n - x), 
there are 21- 1 of them lying under n/2. Because n is odd, each representa­
tion yields 8 when sign and order are taken into account. Thus, the total 
number is 8 · 21- 1 , or 21+2 •  
o 
We can check our results using the routines we have implemented. The 
example that follows yields 8 basic solutions, which become 64 primitive 
solutions when sign and order are considered. This agrees with 24+2 • 
PrimitiveReps [ S  133 17 1012 ] 
{ { 19752 , 38921 } , { 13567 , 4 1484 } , { 9729 , 42548 } , { 28607 , 32964 } , 
{ 2820 1 ,  33312 } , { 25047 , 35744 } , { 755 1 ,  42988 } , { 9207 , 42664 } } 
Theorem 9.6. If n is a positive integer, write n as 2g NM where N = 
0f=1 pfi and M = CTj'=1 qJj , Pi =  1 (mod 4), and Qj = 3 (mod 4). Then r2 (n) 
equals 0 if any of the bj are odd, and equals 4 nf=l (ai + 1) otherwise. Alter­
natively, r2 (n) is 0 unless M is a perfect square, in which case r2 (n) = 4r(N). 
Proof. 
Lemma 9.4 tells us that powers of 2 do not affect the left side. 
Because they leave the right side unchanged too, we can ignore them, and 
assume n = MN. Assume first that all the exponents in N are odd. 
Case L Each ai is odd. 
Recall that every representation of n arises from the multiplication by 
<fl- of a primitive representation of n I d2 , where <fl- is a square divisor of n. 
If d2 fails to include the entire product M, the number of primitive represen­
tations of n / d2 is 0 by Lemma 9.5. Therefore the number of ways of getting 
a square divisor that will yield some primitive representations is 

288 
9. PRIME I MAGINARIES AND I MAG I NARY PRI M ES 
(2) 
and, because each a; is odd, each such d2 leaves n / d2 that is divisible by 
each of the primes p; . Therefore in each case r2 (n I d2) = 4 · 2s . But then the 
power of 2 cancels exactly with the 2s in (2), and so r2(n) is 4 n (ai + 1). 
In order to motivate the general inductive proof that follows in case 3, 
consider first the simpler case where M = 1 and all primes in N appear to 
an odd power, except one, which we call r. 
Case 2. n = r Of=1 pfi where each ai is odd, r is prime, c is even, and 
all the primes are congruent to 1 (mod 4). 
Note that there are two type of square divisors d2 : those that involve re 
and those that involve a lesser power of r. In the latter case, n/d2 will 
involve as many primes as n does, and so r2(n/ d2) equals 4· 2s+1 . The 
number of such divisors is 
(a1 + l)(a2 + l) ··· (as + 1) c 
2s 
2 
and so the number of representations is 4c(a1 + l)(a2 + 1)· ··(as + 1). But if 
d2 uses the full power of r, the number of representations is only 2s+2 ; in 
this case the possibilities for d number (a1 + l)(a2 + l)···(as + l)/ 2s and the 
total number of representations is 4(a1 + l)(a2 + 1)· ··(as + 1). The total 
number is therefore 4(c + a)(a1 + l)(a2 + 1)· ··(as + 1), as desired. 
Now we complete the proof by induction on the number of primes in N 
whose exponent is even. 
Case 3. n = cn:=l pf' )(Ok=! r̥k )M where each ai is odd and the primes 
Pi in N having even exponents are relabeled rk , with even exponents ck. In 
this case we assume that some such primes exist, so m > 0. 
Use induction on m. The base case, m = 0, is covered in case 1, and the 
m = 1 case, which is illustrative of the present case, was just given. Let N1 
denote cn:=i pBk HO:'=-/ r˾k ). The second equality below follows from the fact 
that if M fails to divide a square divisor, then r2 of the number that 
remains after the square divisor is divided out is 0. For the third inequality 
we gather the square divisors according to the power of rm they contain; the 
case that the full power appears is special and appears at the end. In the 
last line the inductive hypothesis is used and the 2s appear because of the 
two primitive representations corresponding to the power of r; the 2 is 
missing from the last summand because in that case there is no power of r. 
r2(n) = L r2( ; ) = L r2( ) 
d21n 
d21N 
= L (r2( :r )  + r2Lr) + r2( r4,::y} + ··· + r2L:;,m! dy )) + L r2L"!dy} 
4 α  
4 β  

9. 1 .  SUMS OF TWO SQUARES 
289 
= (by inductive hypothesis) r(N1 )2 + 4r(N1 )2 + · · ·  + 4r(N1 ) 2  + r2(N1 ) 
= 4r(N1 )2 c; + 4r(N1 ) = 4r(N1 )(cm + 1) = 4r(N). 
D 
Now it is easy to implement a routine to compute r2 (n). The Cases 
phrase picks out the {p, a} pairs where p = 1 (mod 4) and replaces each with 
a +  1. 
r2 [ n_] : = If [MemberQ [ 
fi = Factorinteger [n] , {p_ / ;  Mod [p , 4 ]  = =  3 ,  _ ? OddQ} ] ,  O ,  
4 Apply [Times , Cases [ fi ,  {p_ / ;  Mod [p , 4 ]  = =  1 , a_} -+ a + l ] ] ]  
There are 804 lattice points on the circle with radius 10100 • 
804 
There are many results about sums of more than two squares. An ency­
clopedic reference is [Gro]. Here are a few. 
• (Gauss) Every integer is a sum of three squares except those of the 
form 4r (8k + 7). One direction is an easy exercise. 
• It is not known exactly which integers are a sum of three nonzero 
squares. Example: It is conjectured, but not known, that each n 
congruent to 1 (modulo 8) is a sum of three nonzero squares, except 
for 1 and 25. It is known that the only squares that are not sums of 
three nonzero squares are 4a and 25 · 4a . 
• (Lagrange) Every integer is a sum of four squares. 
• (Descartes and Dubouis [Gro, §6.3]) Every integer is a sum of four 
nonzero squares except: 1, 3, 5, 9, 11, 17, 29, 41, 2 . 4r, 6 . 4r, 14 · 4r. 
• Every integer is a sum of distinct squares, with the following 31 
exceptions: {2, 3, 6, 7, 8, 11, 12, 15, 18, 19, 22, 23, 24, 27, 28, 31, 32, 
33, 43, 44, 47, 48, 60, 67, 72, 76, 92, 96, 108, 112, 128} (Exercise 9.15). 
• [Gro, §2.1] Every integer is a sum of five nonzero squares except 1, 2, 
3, 4, 6, 7, 9, 10, 12, 15, 18, 33. 
• For each k <:: 5, all but a finite set of integers are sums of k nonzero 
squares. There are two key steps to the proof. The first is to show 
that 169 is a sum of 1, 2, 3, ... , 156 nonzero squares; proving this is a 
nice programming exercise (see Exercise 9.16). The second is to 
appeal to Lagrange's four-square theorem. 
• For each n, let k(n) be the least k such that n is not a sum of k nonzero 
squares. Then k(n) is either 1, 2, 3, or n - 13. This somewhat surpris­
ing result follows from earlier results in this list (Exercise 9.19). 
The proof of Lagrange's theorem is not too difficult, so we present an 
outline. Call n good if n is a sum of four squares, and say that a set A 
represents n if the squares of numbers in A sum to n. 

290 
9. PRIME IMAG INARIES AND I MAG INARY PRIMES 
(a) A product of good integers is good. This follows from the identity 
(a2 + b2 + c2 + d2)(e2 + f + g2 + h2) = (ae + bf + cg +  dh)2 + 
(a f - be + ch - dg)2 + ( ag - b h - ce + d {)2 + (ah + b g - cf - de)2 
(b) If p is prime then there is an integer m such that 0 < m < p and mp is a 
sum of three squares. This is proved by defining s = { 02 , 12, 22, • • •  , e; 1 ) 2 } 
and T = {-1 - s :  s E S}. There must be an entry in S that is congruent to one 
in T. This means that x2 = -1 - y2 (mod p), and this gives an appropriate m 
so that mp = x2 + y2 + 1. 
(c) If p is prime, mp is good, and m is even, then mp/2 is good. Let {xd be 
a representation for mp. We can assume that x1 and X2 have the same 
parity and xa and x4 have the same parity. It follows that {(x1 + X2) / 2, 
(x1 - x2)/2, (xa + x4)/2, (xa - x4)/2} is a representation of mp/2. 
(d) Let M be the least integer m for which mp is good. We can use the fact 
that M is odd to prove that M = 1 and so p is good. Let {x;} be a representa­
tion of Mp. Then let ai be the least residue of x; (mod M) in absolute value 
-M / 2 < ai < M / 2; let k be (aЁ + aЂ + aЃ + aЄ)/ M. If k = 0 one can easily get 
a contradiction to M's minimality. The conditions on ai imply that k < M 
and {ad represents kM. These two representations - of kM and Mp -
yield one for kM2 p in which each representing term is divisible by M. This 
yields a representation for kp, contradicting M's minimality. 
These results imply that every prime is a sum of four squares, and then 
(a) yields the same for any nonnegative integer. 
D 
A classic problem of number theory is known as Waring's problem: 
Show that, for every k, there is a g such that every n is a sum of g many kth 
powers. If we denote the least g for a given k with g(k), then Lagrange's 
theorem states that g(2) = 4. Wieferich proved that g(3) = 9. In 1909 Hilbert 
proved Waring's conjecture that g(k) always exists. Getting exact values of 
g has proved difficult. We now know that 19 s g(4) s 35, and it has been 
conjectured that g(k) = L(3 / 2)k J + 2k - 2. 
Lagrange's theorem has an interesting application to logic. Consider the 
question of whether the natural numbers 111 can be defined in the integers Z 
using only the terms of basic logic and the two operations of arithmetic, + 
and ·. In logical terms, this is asking whether 111 is a definable set in the 
structure (Z, +, · ,  0, 1) using only basic logic. The answer is YES, because of 
the 4-square theorem. Here is a definition: 
n E N if and only if 3 a 3 b 3 c 3 d (n = a · a + b · b + c · c + d. d) . 
It is clear that this works, because a sum of squares cannot be negative, 
and because of Lagrange's theorem. So, for integers, the notion of being 
positive is definable; indeed the definition is quite simple. The next ques-

9. 1 .  SUMS OF TWO SQUARES 
291 
tion of interest is whether Z is definable in Q, the rationals. One would like 
to say that a rational is an integer if and only if its denominator is 1, but 
there is no obvious way of getting at the denominator, because logic allows 
us to use only single variables for rationals. In an amazing display of 
mathematical reasoning, Julia Robinson, in her 1949 doctoral thesis, used 
some advanced number theory to prove that, indeed, it can be done: Z is 
definable in (Q, +, ·
, 0, 1). The details of her work are presented in [FW]. 
There are some beautiful formulas that one can use to evaluate rd, 
provided that d is not too large. For details see [Gro]. First, some notation: 
Given n, write it as 2g NM as in the proof of Theorem 9.6. Recall that cr(n) 
is the sum of the divisors of n, crk(n) is the sum of the kth powers of divisors 
of n. In Exercises 3.20 and 3.21 the following variations were defined and 
implemented: 
B11 (n) is the sum (- l)d dk for d dividing n; 
erk (n, 1) is the sum of kth powers of divisors of n that are congruent 
to 1 (mod 4); 
erk (n, 3) is the sum of kth powers of divisors of n that are congruent 
to 3 (mod 4). 
Here are the formulas for d = 2, 4, 6, and 8. 
r2(n) = 4 r(N), unless M is not a perfect square, in which case it 
equals 0. 
r4(n) = 8l:din & 4u d. This equals 8cr(N M) if n is odd, or 8cr(2N M) if 
n is even. 
rs(n) = 16n2 [cr-2(n, l) - cr-2(n, 3)] - 4[cr2 (n, l) - cr2(n, 3)] 
rs(n) = 16(- lt C11 (n) 
It is possible to use these formulas and recursion to compute values of r3 , 
r5 , r7 , and r9, provided that n is not too large (Exercise 9.7). 
K Number Theory and Salt 
We can use Z3, the lattice of integer points in space to visualize salt. Salt 
has a crystal structure made up of alternating ions of sodium (Na) and 
chloride (Cl). Imagine a sodium ion placed at the origin, and then chloride 
and sodium ions placed alternately on the entire infinite lattice (Figure 
9.2). An ion is an electrically charged atom; sodium is positive, chloride is 
negative, and the amount of charge in each is the same. Like charges repel 
and opposite charges attract, with a force inversely proportional to the 
distance between them. So the basic law is like the law of gravitation, but 
electricity, unlike gravity, can repel as well as attract. This feature leads to 
some interesting mathematics, and a surprising application of the sum-of­
squares results of this chapter. 

292 
9. PRIME IMAGINARI ES AND I MAGINARY PRIMES 
Figure 9.2. Part of an infinite salt lattice. The light spheres represents sodium 
ions; the dark spheres are the chloride ions. The large sphere represents the salt ion 
at the origin. 
Figure 9.3. As a sodium ion moves to infinity, the attractive force exerted by a 
single chloride ion leads to an energy demand expressed as an integral of 1 / r2 • 

9. 1 .  SUMS OF TWO SQUARES 
293 
An important constant in a charged lattice is the amount of energy 
exerted by the lattice to hold a single sodium ion in place. This is the nega­
tive of the energy that would be required to move the ion all the way to 
infinity. We refer here to the energy required to fight the various electrical 
forces exerted by the other ions: Some of the ions in the lattice will help 
push the moving ion to infinity, others will work to keep it from moving. 
The actual path taken to reach the (hypothetical) edge of the lattice turns 
out not to matter. This constant is called the Madelung constant; we will 
use the term for our salt lattice, though the notion applies to any lattice 
and leads to different constants for different structures. 
To see the subtlety in the mathematics surrounding this constant, it is 
good to start with a two-dimensional version (Figure 9.3). 
As the sodium ion goes to infinity along some line, the amount of energy 
that must be expended because of the attraction of the single chloride ion at 
( - 2, 3) is given by the following integral, where the 13 arises as ../ 22 + 32 . 
This is just the standard use of integrals in a work = force· distance situation. 
energy = f dr 
Jr13 r 
This integral is easy to evaluate, even in the general case where the 
initial distance is r0 and the force is either attracting or repelling. 
loo ԫ 1  
- ci r  
ro r2 
± 1  
ro 
So this means that the total energy exerted by the lattice to hold the 
sodium ion in place is given by the infinite sum M2. We use M2 for the two­
dimensional version and Ma for the true Madelung constant for salt. 
M2 = 
00 
I 
(- l
)'r
+y 
..j x2 + y2 
x, y = -oo 
xr޵O 
00 
Ma = I 
x, y, z =  - oo  
XYZ *O 
(- l
)x+y+z 
..j x2 + y2 + z2 
The infinite series in both cases have the property, unusual for series 
that arise in physical applications, of being conditionally convergent. This 
means that the series obtained by looking at the absolute values of the 
terms are divergent. Looking at the values along the x-axis is enough to get 
divergence of the absolute values. We pause for a second to remind the 
reader of some basic facts about this notion. 
A result of nineteenth-century mathematics that still surprises stu­
dents of calculus is the fact that the sum of a series can change when the 
terms are rearranged. This is discussed in any calculus book, so we will just 
present an example here. The alternating harmonic series converges to 
log 2. Dividing each term in half reduces the sum to 1'2 log 2. Spreading out 

294 
9. PRIME I MAG INARIES AND I MAG I NARY PRIMES 
this series and adding it to the first series gives a series that sums to 
3/2 log 2, but is just a rearrangement of the original series. 
1- .l + .l_ .l + .l_ .!. + .!. _ .!. + .l _  ..l.. + ..l.. + . . .  
2 3 
4 
5 
6 
7 
8 
9 
10 
1 1  
= 
log2 
+ .l 
1 
+ .!. 
1 
1 
t log 2 
- 4  
- 8 
+ 10 
= 
2 
6 
1 
+ .l- .!. + .!. 
3 2 
5 
+ .!.- .!. + .l 
7 
4 
9 
+ ..!.. + · · ·  
1 1  
= f log 2 
If a series is such that the absolute values of the terms converge, then 
the series is called absolutely convergent, and any rearrangement gives 
the same sum. But if the absolute values fail to converge - as happens for 
the alternating harmonic series - then the series is called conditionally 
convergent. A somewhat surprising result is that, for any target T in 
[-ao, oo], the terms of a conditionally convergent series can be rearranged so 
that the new series sums to T (see [PW]). Indeed, one can program the 
algorithm to do this explicitly in the case of the alternating harmonic 
series. The algorithm is sometimes called the "method of repeated U-turns": 
To get a sum of T, add up positive terms until T is passed; then start with 
the first unused negative term to go in the other direction, again until T is 
passed; then add in unused positive terms again until T is passed; and so 
on ad infinitum. Here is a rearrangement that converges to 2. For more on 
the general relationship between the target (2 in the next example) and the 
numbers of positive and negative terms (8, 1, 13, 1, 14, 1, 13, 1, . . .  in the 
example) see [PW]. 
BarmonicRearranqement [ 2 ]  
The rearranged series for 2 is: 1 + t + f + t + i" + 111 + 
1˽ + 
I 
I 
I 
1 
I 
1 
1 
' 1  
1 
1 
l 
I 
t - 2 + u + w + 21 + u + u + v + w + 31 + x + y + 
I 
1 
I 
1
1
 1 
1 
I 
1 
I 
1 
z + { + | - 7 + } + ~ +  +  +  +  +  +  
1 
I 
I 
1 
.
. 
1 
l 
I 
1 
l 
1 
1 
w +  + w + w + w + w + w - T +  +  +  +  
I 
I 
I 
I 
1 
1 
l 
l 
l 
1
1
 
w + w +  + E +  + w + w + w +  + w -  +  
I + 
I 
1 + 
1 
1 
1 
. 1  
1 
1 
. 
1 
97 
 + mi 
 +  +  +  + m + rn + m + 
I 
1 
I 
· 
l 
· 1  
1 
1 
l 
1 
. 
l 
m + rn + m + Fa - w + m + w + m + m +  +  
l 
I 
l 
1 
1 
I 
l 
1 
I 
I 
13& + 137 + "i39 + ill + l43 + 146 + "i47 + l4il + il - 12· ·· 
The partial sums just before the sign changes: 
{2.0218, 1.5218, 2.00406, 1. 75406, 2.00945, 1.84278, 
2.0007, 1 .8757, 2.00366, 1.90366, 2.00546, 1.92213, ··· ' 
Numbers of terms that are positive, negative, 
positive, . . .  : f 8, 1, 13, 1, 14, 1 ,  13, 1, 14, 1, 14, 1, . . .  } 
Here is what happens, in abbreviated form, for a rearrangement converging 
to 11". 

9. 1 .  SUMS OF TWO SQUARES 
295 
BarmonicRearrangement [ n ,  ShowSeries .. False , 
ShowPartialSums .. False , Max':rerms -+ 1000 ] 
Numbers of terms that are positive, negative, positive, . . .  : 
{76, 1 ,  1 29, 1 .  132, l ,  1 34, 1 ,  133. 1 ,  1 34, 1 ,  134. 1 ,  133, 1 ,  ... } 
The mathematics of the Madelung constant is of interest because it is a 
rare example of a conditionally convergent series occurring in nature. 
Now, because the series for M2 and M3 are conditionally convergent, 
what happens will be sensitive to the order in which the terms are added. 
We will focus here on two possibilities, using partial sums that correspond 
to expanding squares or cubes, or partial sums that correspond to expand­
ing disks or balls. First, squares: 
n 
Msquare _ l" I 
2 
- Im 
n-+oc x.y = -n 
(x,y)*( 0,0) 
(- l)x+y 
--;===- ' M;quare = lim 
..; x2 + y2 
n-+oo 
n 
I 
(- l)x+y+z 
..J x2 + y2 + z2 
x,y,z = -n 
(x,y,zl*( 0,0,0) 
One could program these using Sum, but it makes more sense to exploit 
the symmetry. The M2 SquareShel l  function that follows gets the sum 
along the border of the square. Then we can add them up and watch the 
convergence of the partial sums. The computation that follows goes up to a 
401 x 401 square, so 160,800 lattice points are counted. 
k-1 
( - 1 .  ) k+y 
M2SquareShell [ k_] : = 4 
i 
J'•-k "' k2 + y2 
termssq = Map [M2SquareShell , Range [ 200 ] ] i 
ListPlot [ FoldList [ Plus , 0 ,  terms sq] ] i 
The output (see Figure 9.4) shows that the partial sums appear to 
converge to a value near - 1.6. Expanding disks will lead to the same sum, 
though the convergence is much slower. For this case one can make a major 
simplification, and it is here that the sum-of-squares theory comes into 
play. The disks will pick up their points circle by circle and on any circle 
there will be only chloride ions, or only sodium ions. An ion at (a, b) lies on 
the circle of radius Vn ,  where n = a2 + b2, so there will be exactly r2(n) ions 
on any such circle. Thus, each term (- l)x+Y / Y  x2 + y2 may be replaced by 
(- ltr2(n) / Vnwhere we count all the ions at the same distance from the 
origin at the same time (note that x + y and x2 + y2 have the same parity). 
The computation that follows (see Figure 9.4) examines the disk of radius 
../ 10,000 , so about 31,416 points are counted. 

296 
9. PRIME IMAG INARIES AND IMAGINARY PRI MES 
( - 1 . )  
k SWDOfSquaresR [ 2 , k] 
M2Circle [ k ] 
: = -------
-
Vi 
terms = Map [M2 Circle , Range [ 10000 ] ] ; 
ListPlot [ FoldList [Plus , 0 ,  terms ] ] ;  
- 1 . 2  
- 1 . 4  
- 1 . 6  
- 1 . 8 
5 0 0 0 0  
1 6 0 0 0 0  
Figure 9.4. Expanding squares (left) yield good convergence to the two-dimen­
sional Madelung constant. Expanding disks yield convergence to the same value, 
but it is very slow. The horizontal labels correspond to the number of lattice points 
counted. 
In fact, it can be shown that M2 , the two-dimensional Madelung con­
stant, equals 
-4[ǐ (- lt+l ][2 (- lt l 
· 
LJ 
..;n 
LJ V2n +  1 
n=l 
n=O 
This in turn can be calculated in terms of zeta functions: 
1 ( 
1
1
 
1
3 ) 
- 2 • ( 1 - Vi) Zeta [ - ) 
Zeta [ - , - ) - Zeta [ - , - ) 
2 
2 
4 
2 
4 
- 1 .  6 1 5 5 4  
The case of real three-dimensional salt is more subtle. If we compute 
approximations as for M2 we will see that the expanding cubes converge to 
a constant near - 1. 7 4, but the expanding spheres yield highly oscillatory 
behavior, and indeed one can prove that the spherical partial sums diverge. 
First we look at the cubic scenario. The following routine uses symmetry 
and computes terms on the eight vertices, six faces, and twelve edges. 
MlCubeShell [ k_] : = 
k-1 
k-1 
8 ( - 1  > 3  k 
+ 6 Li Li 
( - 1 . ) 
k+J•• 
"1Jk.Z' 
J=-k• l • • -k• l ../kz + yz + z Z 
+ 12 I: 
711: -k+ l 
( - 1 . )  2 k+J 
../ 2 kZ + yz 
Now we build up the sum for a cube of side-length 61 as we did in the 
two-dimensional case; this counts about 227,000 ions (see Figure 9.5). 

9. 1 .  SUMS OF TWO SQUARES 
297 
terms = Map [MlCubeShell , Range [ 30] ] ; 
partialSums = FoldList [ Plus , O ,  terms] ; 
ListPlot [partialSums , PlotJoined -+ True ] ; 
- o . 54-------, 
2 0 ! - --------, 
- 0 . 75 
- 1  
- 1 . 2 5 
- 1 . 5 
- 1 . 75 
- 2  
- 2 · 2 5 '------2-o_
o_
o_
o ݎs-0_
0_
0_
0 ݏ2-2-
oݐ
o o o  
15 
1 0  
5 
- 5  
50 0 0  
4 50 0 0  
Figure 9.5. Expanding cubes (left) yield convergent to the three-dimensional 
Madelung constant. Expanding spheres yield oscillatory partial sums that diverge 
to infinity. The horizontal labels correspond to the number of lattice points counted. 
And now we try a sphere of radius ../ 500 . Its area is 4/a rr 500312 , so 
about 47,000 points are counted. The results, shown in Figure 9.5, look 
somewhat inconclusive, but it can be proved that the partial sums oscillate 
to greater and greater heights, and so fail to converge. 
( - 1 . ) k  SumOfSquaresR [ l , k] 
MlSphere [ k ] : = ̊̋̌̍̎̏-
-
-{k 
terms = Map [ Ml Sphere , Range [ SOO ] ] ;  
ListPlot [ FoldList [ Plus , O ,  terms ] , PlotJoined -+ True] ; 
From a physical perspective the interesting question is: If the sum is 
dependent on the order of the terms, what order does Nature use to add up 
the energies? One could use complex numbers and analytic continuation to 
deduce what the "right" interpretation of the sum is, but does Nature really 
know about analytic continuation? A more down-to-earth explanation was 
given recently by physicist Jean Delord (Reed College). He suggested that, 
because the entire salt crystal is electrically neutral, the partial sums used 
to approximate the full infinite sum should be corrected to give a neutral 
charge at each stage. Thus, he suggests looking at the spherical order of 
terms, but at each stage adding back a charge to the surface of the sphere 
to render the whole finite ball electrically neutral. Because the total spheri­
cal charge, assuming radius ..[Ti,, is the sum of (- l):r+y+z over all points 
inside or on the sphere of radius ..[Ti,, this requires adding a charge of 
Lksn (- l)kra(k) to the sphere's surface. This in turn leads to an energy­
correction term of -(1 / ..[Ti,)Lksn (- l)kr3(k). It turns out that the limit of the 
numbers obtained by correcting in this way converge to the true Madelung 
constant [BC]; see Exercise 9.22. 
There are faster ways to compute sums such as M3; one such formula is 
given in Exercise 9.23. The proper mathematical way to define the Made­
lung constants is to use complex numbers and analytic functions. The 

298 
9. PRIME IMAG INARIES AND IMAG INARY PRIMES 
reader who wishes to pursue that should look at [BB]. However, it is note­
worthy that the sum-of-squares functions can play a role in Madelung 
computations. 
Exercises for Section 9.1 
9.1. Prove that the following patterns, evident in the table in the middle of 
the proof of Theorem 9.2, always hold for the extended Euclidean algorithm 
sequence for (p, x) where x is the smaller of the two square roots of - 1  
modulo p. Make liberal use of the results of Exercise 1. 18. Let n denote the 
number of quotients, so that r n = 1. 
(a) tn = -x. (Hint: Show first that tn must be either x or p - x ,  and then 
show that the latter would lead to the contradiction of the t-sequence being 
longer than the r-sequence.) 
(b) tn+l = p. 
(c) The t-sequence, in absolute value, is the reverse of the remainder 
sequence. 
(d) n is even. 
(e) The quotient sequence is symmetric about its center. 
(f) If m is the index of the first remainder under ..JP, then m = n/2. 
(g) ltm l = rm+1 ; therefore the first two remainders under ..JP are the a and 
b of p = a2 + b2 • 
9.2. Check that the result in the text for the set of primitive representa­
tions of 6565 is correct by doing an exhaustive search of all possibilities. 
And perform a similar verification for the complete set of representations of 
112, 132 as a sum of two squares. 
9.3. Find an integer n that has more than 10,000 representations as a sum 
of two squares. 
9.4. Use the proof of Theorem 9.3 to deduce that if p is prime and congru­
ent to 1 (mod 4) then there is only one way (up to sign and order) to write p 
as a sum of two squares. 
9.5. Here is an incredibly short proof that every prime p congruent to 1 
(mod 4) is a sum of two squares (discovered by D. Zagier [Zagl]). 
(a) A function f :  S -+  S is called an involution if f(f(s)) = s for each x in S. 
Show that if f is an involution on S, then the number of elements in S is 
odd if and only if the number of fixed points of f is odd. (A fixed point is a 
point y such that f(y) = y.) 
(b) Suppose that p is prime and S is defined by: 

S = {(x, y, z) E D3 : x2 + 4yz = p) . 
9.1 . SUMS OF TWO SQUARES 
299 
Show that f is an involution on S where f is defined by 
{ (x + 2z, z, y - x -z) if x < y - z  
f(x, y, z) = (2y - x, y, x - y + z) if y - z < x < 2y 
(X - 2y, X - y + Z ,  y) if X > 2y 
(c) Show that f has exactly one fixed point; conclude that ISi is odd. 
(d) Show that the function (x, y, z) 1-+ (x, z, y) maps S to S. Conclude that 
this function has a fixed point and show how that yields a representation of 
p as a sum of two squares. 
9.6. Implement procedures to compute r4 , r6 , and r8 using the formulas 
given on page 291. 
9. 7. Implement a procedure to find all the representations of n as a sum of 
d squares by reducing the problem in a recursive way to the d = 2 case, 
which was handled in this section. For example, for d = 3 just subtract all 
possible squares s2 from n and compute, in each case, the complete set of 
representations of n - s2 as a sum of two squares. Such an approach will not 
work when d or n is very large, but it works reasonably well for d up to 4 
and n up to 2000. In the case of d = 3 you should check your program for 
correctness against a brute-force approach, for some values of n. 
9.8. Let T;(n) be the number of divisors of n that are congruent to i (mod 4). 
Show that r2(n) equals 4[T1(n) - T3(n)]. 
9.9. (I. Vardi) Explain why the concise bit of code that follows correctly 
computes r2(n). Im[ z ]  gives the imaginary part of the complex number z. 
4 Apply [ Plus , Im [ IDhiooro [nJ J ] 
Perform some timing tests to compare this method to the implementation of 
r2 given in this section. 
9.10. Without appealing to the formulas given in the text, prove the follow­
ing. (Hint: Discover the patterns by looking at the set of representations in 
each case.) 
(a) r2(2n) = 4 
(b) ra (2n) = { 6 
12 
(c) r4 (2n ) ={ 8 
24 
if n is even 
if n is odd 
if n = 0 
if n > 0 

300 
9. PRI M E  I MAG I NARI ES AND IMAG I NARY PRIMES 
9.11. Prove that the long-term average of r2(n) approaches Jr; precisely: 
limN-+oo O r,:;=0 r2 (n) = TC. Here is an outline. Let D(a) denote the closed disk 
of radius a centered at (0, 0). We will examine D(W), the disk given by 
x2 + y2 s N. A lattice point is a point of the form (a, b) where a and b are 
integers. 
(a) Prove that r.:;=0 r2(n) equals the number of lattice points inside D(ffe). 
(b) Take the square of side 1 centered at each lattice point inside D(ffe) 
and color them all blue. Then the blue area is r,:;=O r2(n). 
(c) Step (b) shows that r.:;=0 r2(n) is near the area of the disk, Jr N. But the 
border must be looked at closely. Use geometrical reasoning to show that 
n[Jr( ffe - /)] ȇ Total blue region ȇ n[1 ffe + 0 )] 
and use this to conclude that P r.:;=o r2(n) is trapped between two quanti­
ties that converge to TC. 
9.12. Show that the formula for r4 (n) given in the text yields the following 
formula, which is easy to implement. Here N and M are as defined from n 
as explained before the formula for r 4 • 
{ 24 <T(N M) if n is even 
r4(n) = 
8 <T(N M) if n is odd. 
9.13. Fill in the details in the proof outline of Lagrange's theorem that 
every nonnegative integer is a sum of four squares. 
9.14. Fill in the proofs and implement the following method, due to Rabin 
and Shallit, for finding a single representation of n as a sum of four 
squares. Given n = 2 (mod 4), subtract a pair of randomly chosen squares 
from n and check if the result is a prime. If it is, it must be 1 (mod 4) and 
we can represent it as a sum of two squares, using SumOfSquaresRepre­
sentations. This gives four squares that sum to n. If the result of the 
subtraction is not prime, try subtracting a different pair of squares. If n = 
0 (mod 4), use recursion on n/ 4, and multiply each entry in the answer by 
2. If n is odd, use recursion on 2 n; the result must have two even entries 
and two odd entries. Let the even ones be r and s and let a and b be the 
others, with s >  r and b > a. Then (s + r)/ 2, (s - r)/2, (b + a)/2, and (b - a)/2 
solve the problem for n. 
9.15. Show that if n > 128 then n is a sum of distinct nonzero squares. Here 
is an outline. 

9. 1 .  SU M S  OF TWO SQUARES 
301 
(a) Write a routine SumNonZeroSquares [ n ]  that uses recursion to get the 
set of integers that are a sum of one or more distinct squares of integers in 
{ 1, 2, . . .  , n}. For example, if n = 2 the resulting list should be { 1, 4, 5}. 
(b) Prove the auxiliary result: Suppose that n is positive and every integer 
from n + 1 to 4 n + 35 (inclusive) is a sum of distinct positive squares. Then 
every integer m > n is a sum of nonzero squares. Hint: Consider the four 
cases m = 4k, 4k + 1, 4k + 2, 4k + 3. 
(c) Write a short program that uses (b) and the code from (a) to get a list of 
all integers that are not a sum of nonzero squares. The list has length 31 
and its largest entry is 128. 
9.16. It is not hard to see that 169, or 132, is a sum of 1, 2, 3, 4, or 5 
squares: 169 = 132 = 25 + 144 = 9 + 16 + 144 = 1 + 4 + 64 + 100 = 1 + 4 + 4 + 
16 + 144. Find the first integer k for which 169 is not the sum of k nonzero 
squares. 
9.17. Find the smallest integer that is not a sum of 8 cubes. Hint: The 
number is quite small, so you need consider only small cubes. 
9.18. Prove that 79 is not a sum of 18 fourth powers. 
9.19. Let k(n) be the least k such that n is not a sum of k nonzero squares. 
Prove that k(n) is always one of 1, 2, 3, or n - 13. Hint: You will need the 
Descartes-Dubouis result cited in the text. Use it to show that if n is a sum 
of four squares then it is also a sum of j squares for each j = 5, 6, . . .  , n - 14. 
This leaves the fairly easy assertion that no n is a sum of n - 13 nonzero 
squares. 
9.20. (a) 
Implement the following magic trick, which may or may not 
impress your friends. Ask a friend to take his or her date of birth and write 
it as two four-digit numbers. For example, July 9, 1951, becomes {0709, 
1951} . Then ask him or her to square each of the numbers and tell you the 
sum of the two squares. With the help of SumOfSquaresRepresen­
tations you can respond very quickly with the date of birth. Many of the 
integers generated in this way will have more than one representation as a 
sum of two squares, but, with rare exceptions, the fact that the answer has 
so much structure (month between 01 and 12, day between 01 and 31, year 
between 1900 and 2000) will allow your program to select the correct val­
ues. Implement a BirthDate routine that does this. Ideally, it will work as 
follows. 
7092 + 1951 z 
4 3 0 9 0 8 2  
BirthDate [ 4309082] 
July 9 , 1 9 5 1  

302 
9. PRI M E  I MAG I NARI ES AND I MAG I NARY PRIMES 
(b) Find some ambiguous birth dates: they should yield the same sum of 
squares and the years should be within ten years of each other. For exam­
ple, March 18, 1945, and March 30, 1943, both yield 3,884, 149. 
9.2 1. The following variation of the Madelung sum is interesting: 
.t (- l)2(n) . 
n= l 
Compute some partial sums and try to discover the surprising formula for 
the infinite sum. Hint: The average value of r2 is 1f (Exercise 9.1 1) and the 
sum of the alternating harmonic series is log 2. 
9.22. The Delord interpretation considers the following limit. 
Do some computations to gain evidence for the theorem that this limit 
equals the Madelung constant Ma .  
9.23. The following formula due to Crandall and Buhler [CB] seems to be 
the fastest way to compute the Madelung constant. 
Compute some approximations and note how few terms in each sum are 
needed to get accurate results. The true value of Ma is 
- 1. 74 7564594633182190636212035544397403485161436624 7417581 
"
·
. 
5282535076504062353276117989075836269460789 
9 .2 The Gaussian Integers 
'1 Complex Number Theory 
It makes sense, and it turns out to be quite a useful thing, to define inte­
gers and divisibility in the realm of complex numbers. The complex num­
bers, C, are numbers of the form a +  b i, where i denotes H and a and b 

9.2. TH E GAUSSIAN I NTEG ERS 
303 
are real. Of course, i suffers from being called an imaginary number, but it 
can be treated as a concrete object, the important point being that i2 = - 1. 
Each complex number has a real part and an imaginary part, given by a 
and b in a +  bi. We can give the complex numbers a geometric interpreta­
tion by letting the vertical axis be the imaginary axis. In Mathematica I is 
used for i and Re [ ] and Im[ ] are used for real and imaginary parts, respec­
tively. 
We can perform arithmetic in C. Indeed, C is a field, meaning that we 
can add, subtract, multiply, or divide any pairs of numbers, except for the 
case of division by 0. Addition is easy: (a +  bi) + (c + di) is (a + c) + (b + d) i. 
Subtraction is similar. Multiplication comes from the identity: (a + b i) ­
(c + di) =  a c  - bd + (ad + bc)i. 
The conjugate of z = a + bi E C comes by replacing the imaginary part 
of z by its negative and is denoted by z. So a+7i = a - b i  (we assume a and 
b are real). The absolute value of z, I z I, is ../ a2 + b2 , which is the length of 
the vector from 0 to z. It is also useful to define the norm of z, N(z), to be 
just a2 + b2 • 
Now, the integers in C are called the Gaussian integers and consist of 
complex numbers of the form m + n i where m and n are integers; the set is 
denoted Z[i]. The units refer to the invertible elements; there are four of 
them: ± 1 and ± i. If a =  e{3 where a and {3 are Gaussian integers and e is a 
unit, then we say that a and {3 are associates. A Gaussian integer a 
divides another, {3, if there is a Gaussian integer y such that {3 = ay. This 
definition will allow us to study primes, gcds, and the like in the imaginary 
realm. Note, for example, that 2 loses its primality because 2 = (1 + i)(l - i). 
Before investigating the Gaussian primes, we catalog some important 
properties of Z[i]. The proofs of the nine assertions that follow are straight­
forward and left as exercises. To avoid confusion, and because the integers 
are related to the field of rational numbers in the same way that the Gauss­
ian integers are related to the field C, the ordinary integers are called the 
rational integers and the ordinary primes are called rational primes. 
Proposition 9. 7. The following hold for a, {3 E Z[i] and a, b E Z. 
(a) aa = N(a). 
(b) N(a) = N(a ). 
(c) N(a{3) = N(a)N({3). 
(d) If {3 divides a in Z[i], then N(/3) divides N(a) in Z. 
(e) The units are the only elements of Z[i) that are invertible in Z[i]. 
(f) If a divides {3 and {3 divides a, then a and {3 are associates. 
(g) If a and b are rational integers and a divides b in Z[i], then a divides b 
in Z. 
(h) If {3 divides a, then 73 divides a .  

304 
9. PRIME I MAGINARIES AND IMAG INARY PRIMES 
(i) If f3 divides a and f3 is neither a unit nor an associate of a, then 
1 < N(/3) < N(a). 
We can now discuss the fundamental facts about greatest common 
divisors and unique factorization in Z[i]. First note that gcd is a little tricky 
to define because there is no notion of "greatest" for complex numbers. 
Thus, we use the following: y is the greatest common divisor of a and f3 if 
y divides each of a and f3 and any other common divisor divides y. And we 
can define primes in the obvious way: a is a Gaussian prime if any divisor 
of a in Z[i] is either a unit or an associate of a. 
Theorem 9.8. (a) If a and f3 are in Z[i] and f3 :/:- 0, then there exist Gauss­
ian integers q and r such that a = q /3 + r and N(r) < N(/3). 
(b) 
Every pair of Gaussian integers not both 0 has a greatest common 
divisor, which is unique up to associates. 
(c) If d = gcd(a, /3) then there are Gaussian integers s and t such that 
d = sa + tf3. 
(d) Every nonzero Gaussian integer may be written in a unique way (up to 
order and associates) as a product of Gaussian primes. 
Proof. (a) Suppose that the true quotient a/ /3 in C equals u + iv. Let m be 
the nearest integer to u and let n be the nearest integer to v (it will not 
matter whether rounding is up or down). Then u + iv =  (m + s) + i(n + t) 
where I s I and I t I are at most 1/2. Take q to be m + ni, and let r = a - qf3. 
Then 
N(r) = N((u + iv - q)/3) 
( 1 2 
1 2) 
= N(u + iv - q)N(/3) = N(f3)N(s + it) s N(f3) (2) + (2) < N(/3) 
(b) This follows from (a) as for the ordinary integers. Namely, one uses a 
division algorithm to form a sequence of remainders whose norms are a 
decreasing sequence of nonnegative integers. The sequence must therefore 
terminate with a remainder having norm 0, that is, a zero remainder. We 
leave the details of proving that the final nonzero remainder is a gcd of a 
and /3 under the Z[i)-definition as an exercise. Uniqueness follows from 
Proposition 9. 7(f) and the fact that two gcds would divide each other. 
(c) See Exercise 9.29. 
(d) This is similar in all respects to the proof of the same result in Z, in 
that one uses induction for existence and the extended gcd ideas to get an 
analog of Corollary 1. 10, which is then used in the proof of uniqueness. In 
fact, unique factorization for Z and Z[i) are special cases of a more general 
result of modern algebra: Every Euclidean domain is a unique factorization 
domain. This theorem states that any structure of an appropriate sort 
(called an integral domain) for which the notions of gcd and the central 

9.2. THE GAUSSIAN I NTEG ERS 
305 
ideas of the Euclidean algorithm hold satisfies a unique factorization 
theorem. 
D 
Mathematica's PrimeQ, Factorinteger, Divisors, and GCD functions 
all work in Z[i] when the Gaussianintegers option is turned on. We 
present a few examples here, but our understanding of these concepts will 
be much improved if we implement algorithms for these three operations 
ourselves, as we will do shortly. 
Table [p = Prime [ i ]  ; 
{ p ,  PrimeQ [p , Gaussianintegers -+ True ] } ,  { i ,  S } ]  
{ { 2 , False } ,  { 3 , True } ,  { 5 , False } ,  { 7 ,  True } ,  { 11 ,  True } }  
Factorinteger [ l20] / /  FactorForm 
23 3 5 
Factorinteger [ l20 , Gaussianintegers -+ True ] / /  FactorForm 
( 1 + 1 ) 6 ( 1  + 2 1 ) ( 2  + l )  3 
Complex gcds are built into GCD, but it is not hard to write a one-line 
program that does it. 
Algorithm 9 . 2  GCDs in the Gaussian Integers 
The code that follows obtains the gcd of two Gaussian integers by a method 
that is almost identical to the standard Euclidean algorithm. The only 
difference is that Round [ z I u ]  is used where the classic algorithm uses 
Floor [ z I u ] ; this works because Round acts on real and imaginary parts 
separately. The reason for rounding rather than flooring is the proof of 
Theorem 9.8(a). 
ComplexGCD ( z_ , u_] 
: = 
I f  [ u  = =  0 ,  z ,  ComplexGCD [u , z - u Round [ z  I u ] ] ]  
ComplexGCD [ 7 300 + 12 I ,  2700 + 100 I ]  
- 4  + 4 l 
ComplexGCD [ 324 + 1608 I ,  - 11800 + 7 900 I ]  
- 52 + 16 1 
ComplexGCD [ Product [a + b I , { a ,  1 ,  8 } , {b, 1 ,  7 } ] , 
Product [ a + b I , { a ,  12 , 16 } ,  { b ,  12 , 15 } ] ]  
270015 13244 1600000 + 4044308486400000 l 
The CNT package's Ful lGCD function works on Gaussian integers too. 
The table that follows shows the extended gcd coefficients s and t, which 
can be found in the same way as in Z (Exercise 9.29). 

306 
9. PRIME IMAGINARIES AND IMAG I NARY PRIMES 
PullGCD [ 7 300 + 12 I ,  2700 + I 100 , EztendedGCDValues -+ True ) 
Remainders 
Quotients 
s 
t 
7300 + 12 I 
1 
0 
2700 + 100 I 
-·-··----
3 
0 
I 
1 
- 800 - 2 8 8  I 
- 3  + I 
1 
I 
- 3  
i 
12 + 3 6 I 
I 
- 1 4  + 1 8  I 
3 - I  
- 8  + 3 I 
1 6  
1 + 2 1  
I 
2 5 - 6 8  I 
- 6 1 + 1 8 6 1 
- 4  + 4 I 
- 2  - 2 I 
- 1 5 8  + 17 I 
4'2 5 - 6 1 I 
0 
- 3 2 5  - 350 I 
9 1 1  + 914 I 

 Gaussian Primes 
· ·-
As mentioned, some rational primes, such as 2 and 5, fail to be prime in 
Z[i]: 2 factors into (1 + i)(l - i); 5 factors as (1 + 2i)(l - 2 i). An examination 
of these and similar factorizations will show that there is a close connection 
between primality in the Gaussian integers and representations as sums of 
two squares. Before giving a complete characterization of primes, we show 
how the connection can be exploited to get another algorithm for writing a 
prime p congruent to 1 (modulo 4) as a sum of two squares. 
By earlier work (either Theorem 9. 1 or Exercise 9.5), we know that p 
can be written as a2 + b2, and we also know there is an x such that x2 = 
- 1  (mod p). Observe first that a2 + b2 = (a +  b i)(a - b i) and that each of the 
factors is a Gaussian prime. For if a divided a +  b i  and is neither a unit nor 
an associate of a +  bi, then, by Proposition 9.7(i), N(a) would be a divisor of 
N(a + bi) lying strictly between 1 and N(a + bi). But this norm is just p, a 
prime having no such divisors in Z. Now, because p divides x2 + 1 in Z, 
(a + bi)(a - b i) divides (x + i)(x - i) in Z[i]. Because each of a ± bi is prime, 
each divides one of x + i or x - i. But they cannot divide the same factor for 
that would mean that p divides x ± i, which it does not because it does not 
divide the imaginary part. It follows that gcd(p, x + i) is one of a ±  b i  (or an 
associate) and so will yield a solution to the sum-of-two-squares problem. 
The ideas of the previous paragraph can also be used to prove that 
primes congruent to 1 (mod 4) have the form a2 + b2, and to prove that such 
representations are unique. The latter is done in Exercise 9.31. Here's an 
example of the complex algorithm; it is quite fast, but a little bit slower 
than Smith's method. 
p = RandmpPriM [ SO ,  { 1 ,  4 } )  
z = Sgrt.RegOne [p) 
9 1480166797897129116732458636901268966333430126797 
133833276792206694002302950562445780990005 17634778 
repn = GCD [ p ,  z + I ] 
8616615032376256176870269 + 4151398822291669296703794 I 

Re [ repn) 2 + Im [ repn] 2 = =  p 
True 
9.2. TH E GAUSSIAN I NTEGERS 
307 
We now give a complete characterization of the Gaussian primes. 
Theorem 9.9. A Gaussian integer a is prime in Z[i] if and only if either 
(a) a is a rational prime congruent to 3 (mod 4), or 
(b) N(a) is a prime integer. 
Proof. Part (b) of the reverse direction is easy, for if a is not a prime in 
Z[i], then, by Proposition 9.7(i), some f3 divides er, where 1 < N({3) < N(a). 
Then Proposition 9. 7(d) implies that N({3) divides N(a), contradicting the 
primality of N(a). For part (a), suppose that p is a rational prime, p = 
3 (mod 4), and p fails to be a Gaussian prime. Then p = a f3 where a and f3 
are not units. This implies that p2 = N(a/3) = N(a)N({3), and this in turn 
implies that p = N(a), and is therefore a sum of two squares, contradicting 
the fact that no sum of two squares can be 3 (modulo 4). 
For the forward direction, suppose that a is a Gaussian prime. If a E Z, 
then a must be a prime integer. It cannot be 2 or a prime congruent to 1 
(mod 4) because it would then have the form a2 + b2 and so be divisible by 
a + b i. Suppose that a is not in Z. Then a divides a product of primes in Z 
because a a = N(a); because of unique factorization in Z[i], a must divide a 
prime in Z. But if a divides p, then N(a) divides N(p), which is p2 ; there­
fore N(a) = p, as desired. 
D 
Because of the eightfold symmetry to the Gaussian primes - if a + b i  is 
prime so are ±a ± bi and ± b ± a i - their image in the complex plane makes 
a pleasing pattern. The CNT package function GaussianPrimePlot pro­
duces such images (Figure 9.6), with the primes given as black squares and 
the units shown in gray. 
Exercise 9.32 describes how the methods of this section can be used to 
obtain the prime factorization of a Gaussian integer; the only tricky part is 
that one needs a subroutine to write a prime as a sum of two squares, but 
Smith's algorithm does that in an eyeblink. This is how Mathematica's 
Factorinteger function works on Gaussian integers. In Section 9. 1 we 
showed how one can get all representations of n as a sum of two squares. 
The full program was a little involved, requiring the Chinese Remainder 
Theorem to get all the square roots of - 1. Another approach (see Exercise 
9.33) is to use Gaussian factorization: From a factorization of p one can 
easily get its set of Gaussian divisors and find the desired representations 
among them. Because the Gaussian divisor function is built into Mathemat­
ica, this provides a fast way to get all the representations of an integer as a 
sum of two squares and is the method used by the NumberTheoryFunc­
tions package function SumOfSquaresRepresentations. 

308 
9. PRIM E  I MAGINARIES AND IMAGINARY PRIMES 
GaussianPrimePlot [ l J ] ; 
GaussianPrimePlot [ SO) ; 
Figure 9.6. The Gaussian primes having norm at most 13 Oeft) and having norm at 
most 50. This pleasing pattern is often used to tile walls. 
« The Moat Problem 
Recall that it is a simple matter to show that no giant can walk along the 
real axis from 2 to infinity stepping only on the prime integers. This is 
because, if the largest step the giant can take has size k, he would eventu­
ally run into a string of k + 1 composite integers (Exercise 2.22 or see the 
simpler proof given at the end of Section 4.1). The analogous question in the 
Gaussian integers is: Can one walk in Z[i] from 1 + i to infinity taking steps 
of size k or less and stepping only on the Gaussian primes? This is a famous 
unsolved problem due to Basil Gordon in 1962. 
This problem is known as the Gausian moat problem because it 
asks whether, for some k, there is an uncrossable moat of width k: a region 
of width k that consists only of nonprimes and that surrounds the origin. If 
there is such a moat, then steps of size less than k will not be adequate to 
get to infinity. The first computational result was by J. H. Jordan and J. R. 
Rabung, who showed in 1970 that a moat of width "10 exists. In 1998 this 
was improved by E. Gethner, S. Wagon, and B. Wick [GWW] to show that a 
moat of width ../26 exists. This problem leads to the creation of interesting 
graphics, and we show in this section how to get images of the Gaussian 
primes that are reachable using steps of size k. 
We will consider steps of size 2 first (a simpler case would be steps of 
size ../2 or less; that corresponds to squares in the Gaussian prime image 
that are just touching at the corners, and it is easy to see in Figure 9.6 that 
such touching primes never leave the disk of radius 12). We can proceed as 
follows: 

9.2. TH E GAUSSIAN I NTEG ERS 
309 
Step 1. Identify the Gaussian primes in a given disk (first octant only, 
because of symmetry). 
Step 2. For each identified prime, find all its 2-neighbors: the Gauss­
ian primes at distance two or less. 
Step 3. Form the road network consisting of all lines between Gaussian 
primes and their 2-neighbors. 
Step 4. Determine the connected component of 1 + i in this network. 
Step 1 is easy. We just select the Gaussian primes from all possibilities 
in the disk; because we want a graphic image we use pairs { a ,  b }  rather 
than Gaussian integers a + b I .  Because we want to be sure to include edges 
that cross the lines of symmetry, we fatten the first octant wedge (via the 
argument k) to include primes that are near the lines of symmetry but not 
in the first octant. 
Gauss ianPrimesinExpandedFirstOctant [rad_, k_] 
: = 
Select [Flatten [Table [ { a , b} , { a , - Ceiling [ k ] , rad } ,  
{ b ,  - Ceiling [ k ] , Min[ a + Floor[k V ] , " rad2 - a2 ] } ] , 1] , 
GaussianPrimeO [ I  l[l:D + I [2:D I ]  & ] 
Figure 9. 7 shows how we have captured the Gaussian primes m the fat­
tened wedge. 
Show [ Graphics [ {Line ( { { O ,  O } , { 1 1 ,  11 } } ] , 
Line [ { { O ,  O } , { 15 ,  O } } ] , PointSize ( 0 . 02 ] , 
Map ( Point , GaussianPrimesinExpandedFirstOctant [ l5 ,  2 ] ] } ] ,  
AspectRatio -+ Automatic , Frame -+ True , 
PlotRange -+ { { - 3 ,  15 . 5 } ,  { - 3 ,  11 . 5 } } ,  FrameTicks -+ 
{ Range [ - 2 ,  15 , 2 ] , Range [ - 2 ,  1 1 ,  2 ] , Hone , Hone } ] i 
Figure 9.7. 
1 0  
8 
6 
4 
2 
0 .  
I 
- 2 '  
·-· - - -
- · ----- -- -
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• • 
• 
• 
• 
• 
• 
• 
• 
• 
- 2  
0 
2 
4 
6 
8 
1 0  
• 
• 
• 
• 
• 
• 
• 
• i 
1 2  
1 4  
The Gaussian primes in the first octant, slightly fattened. 
For step 2, the possibilities are limited. With some small exceptions, the 
primes within two units of a Gaussian prime p must be exactly two steps 
away in any direction, where a step refers to a horizontal or vertical step; 
this is because a and b must have opposite parity for a + b i  to be a Gaussian 

31 0 
9. PRIME I MAG INARIES AND I MAG I NARY PRIMES 
prime. There is an exception at 1 + i, for which a and b are odd, but a2 + b2 
is the prime 2. The following two cases take care of it, where the second 
argument, 2, refers to the bound on the step size. 
neighbors [ { l ,  l} , 2) : =  { { 2 ,  l } ,  { l ,  2 } , { - 1 , l } ,  { l ,  - 1 } }  
neighbors [pt_ , 2 )  : = Select [Map [pt + I  & ,  { { 1 ,  l } , 
{ l ,  - 1 } , { - 1 ,  1 } , { - 1 ,  - 1 } ,  { 2 ,  O } , { O ,  2 } , { O ,  - 2 } , { - 2 ,  O } } ] , 
GaussianPrimeO [ l [l] + 1 [2] I )  & )  
Step 3 is easy too: Just agglomerate all the neighbors of all the Gauss­
ian primes in a disk of radius 50. We use Sort so that Union, which we use 
in roads, will eliminate duplicates. Note that edges and roads consist of 
pairs of primes, to be viewed as edges connecting two primes that are 
sufficiently close. 
primes = GaussianPrimesinBxpandedFirstOctant [ 50 ,  2) " 
edges [p_ ,  d_] : = Map [Sort [ {p ,  I } ) & ,  neighbors [p , d] ] 
roads = Union [ Flatten [Map [edges [ I ,  2 )  & ,  primes ] ,  1 ) ]  " 
Length /0 {primes , roads } 
{ 2 3 5 , 34 1 }  
So we have 235 primes and 341 edges in the road network. Time for a 
reality check to see if we have what we want. The result, shown in Figure 
9.8, is correct; note that it contains some edges lying outside the first 
octant. This will lead to some duplicates eventually, but they will be elimi­
nated; they arise because we want to be certain to get all the edges that 
cross the lines of symmetry. 
Show [Graphics [ {Line /0 roads , 
{GrayLevel [ 0 . 4 ] , Line [ { { O ,  O } , { 40 ,  40 } } ] } } ] ,  
AspectRatio -t Automatic , Frame -t True , Frame!l'icks .. 
{ Range [O , 50 , 10 ] , Range [O , 50 , 10] , None , None } , GridLines -t 
{ { { O ,  {GrayLevel [O . 4 ] } } } ,  { { O ,  { GrayLevel [O . 4 ] } } } } ]  " 
4 0  
Figure 9.8. The road network in the Gaussian primes using steps of size 2 or less, 
first octant only. 

9.2. TH E GAUSSIAN I NTEG ERS 
31 1 
For step 4 we start with the single point and build the set by repeatedly 
adding neighbors. To avoid redundancy, at each step we look only at the 
neighbors of the points that were just added. And we restrict the neighbor 
search to points not already in the component. These important efficiencies 
are introduced by keeping track of the pair (component, new) and stopping 
when new is empty, and using comp! to keep track of the set of points not 
yet in the component. 
FindComponent [ s_, {m_Integer , n_} ] 
: =  Module [ 
{ new , component , newneighbors , compl } , newneighbors [ { 1 ,  1 }  ] 
• -
Intersection [ { { 2 ,  l } , { 1 ,  2 } , { - 1 ,  l } , { 1 ,  - 1 } } ,  compl ] ;  
newneighbors [pt_] : = Intersection [ 
Map [pt + I & ,  { { 1 ,  1 } , { l ,  - 1 } ,  { - 1 ,  l } ,  { - 1 ,  - 1 } , 
{ 2 ,  O } ,  { O ,  2 } ,  { O ,  - 2 } , { - 2 ,  O } } ] , compl ] ;  
component = new = { {m, n } }  ; 
While [ new 'I- { } ,  compl = Complement [ s , component ] ; 
new = Union H (newneighbors /0 new) ; 
component = Join [component , new] ] ; 
component ] 
component = F indComponent [primes , { 1 ,  1 }  ] ; 
Length [ component ] 
1 2 1  
This shows that 121 primes are reachable from 1 + i. To see the result in 
its symmetric form, we define symmetrize to apply the eight transforma­
tions, and then symmetrize the road network consisting of reachable Gauss­
ian primes and use just dots for the unreachable ones. The following code 
generates the image of the 2-component (the set of reachable primes using 
steps of size 2) shown in Figure 9.9. We make liberal use of Union to elimi­
nate duplicate edges or points. 
symetrize [ { a_Integer , b_} ] : = { { a ,  b} , { - a ,  b } , 
{ a ,  - b } , { - a ,  - b } ,  { b ,  a } ,  { -b ,  a } ,  { b ,  - a } , { - b ,  - a } } ; 
symetrize [ {p_List , q_List } ] : =  
Transpose [ { symetrize [p] , symetrize [q] } ] ;  
symetrize [pts_List ] : =  
Flatten [ symetrize /O pts , 1 ]  / ;  Depth [pt s ]  = =  3 ;  
firstOctant = Select [ roads , MemberQ [component , l [l] ] & ]  ; 
roadNetwork = Union [Flatten [ symetrize /0 firstOctant , 1 ] ] ;  
unreachablePrimes = Union [ 
symetrize [ Complement [primes , component ] ] ] ;  
Show [ Graphics [ {Circle [ { 0 ,  O} , 50] , 
{AbsolutePointSize [ l ] , Point /0 unreacbablePrimes } , 
{AbsoluteThickness [ 0 . 4 ] , Line /0 roadNetwork} } ] , 
AspectRatio -+ Automatic] ; 

31 2 
9. PRIME IMAG INARI ES AND IMAG INARY PRIMES 
Figure 9.9. The network of reachable Gaussian primes using steps of size 2 or 
smaller. 
The preceding computation shows that steps of size 2 or smaller will not 
get one beyond the circle of radius 46. Note that because of parity consider­
ations the differences between Gaussian primes (excluding 1 + i and ignor­
ing signs) must have one of the forms 1 + i, 2, 2 i, 2 + 2 i, 1 + 3i, 3 + i, 4, 4i, 
3 + 3 i, 2 + 4 i, 4 i + 2, 1 + 5i, 5 i + 1, and so on. Thus, the stee:_size bounds that 
one considers in the moat problem should be: {2, 2, v 8 ,  {10, 4, "18, 
ffo, "26, . . . . Similar computations show that steps of size .,/8 will not 
get escape the disk of radius 94 (Figure 9. 10). And the complete Jordan­
Rabung collection of Gaussian primes is shown in Figure 9. 1 1; that shows 
that steps of size {10 will not get one past the circle of radius 1025. 
Slightly different techniques were used in [GWW] to show that a walk 
using steps of size ,(26 or less will never get farther from the origin than 
distance 5,656,855. 
For heuristic arguments that no step size will lead to a Gaussian prime 
walk to infinity, see [Var]. 
« The Gaussian Zoo 
In the familiar world of rational primes, a primality pattern is called admis­
sible if it might occur infinitely often. For example, the pattern (n, n + 1) is 
not admissible because no matter what n is, one of the pair is divisible by 2; 
therefore there cannot be infinitely many prime pairs of the form (n, n + 1). 

9.2. THE GAUSSIAN I NTEG ERS 
_,,_;: 
( 
ݤ .. .. 
. " 
क़ 
·) :
, έ-£'.2;"-{.-
݂ "· 
. .  ̀ 
,•";)--ή7ίΰ: - ज़,ड़ 
•. ,:; ... ग़·· 
݋-; 
' """,/. I 
" 
•• 
... ..... JO. 
-; 
:..s.,..,,,+ :݃ .. ---•. ;.: 
"o. 
:>-; 
- ·̂ 
-
, 
=݅, ""'. 
.. :> .t." 
"', 
../' 
·-݊ 
+-.1·,.. 
)-:ॠ/ ){ 
ढ़;  ;फ़!'य़ . ..-- ݈݉" ... 
i.. 
...,_, 
)' ;.,, 
7 --޳޴ • .) 
• } -'  
-."". 
r,. 
i 
' ;( 
..... v˻̠,._!·˼.r-4 
,._ . ݁ 7; 
'1 ;s.ख़· ॖ 
,, 
':-Y-_.·':'.,.ݍ 
• 
(,݌-:.,: ˾ -ॗ . 
. ́.. 
< .... 
_:. 
˿ -݆݇ 
' ' 
-̃ ... .,..--
,{v > ,  
>"';" < ݄-
....
. , 
31 3 
Figure 9.10. The network of reachable Gaussian primes using steps of size .f8 or 
smaller; the greatest distance from the origin is 93.47. 
Figure 9.1 1. The collection of reachable Gaussian primes using steps of size YW 
or smaller. The greatest distance from the origin is 1024.35; there are 249,508 
reachable primes. 

3 14 
9 .  PRIME IMAGINARIES AND I MAGINARY PRIMES 
Of course, (2, 3) is the only prime pair that fits this pattern. But the pattern 
(n, n + 2) is admissible because, for any prime p and any n, the pair, 
reduced modulo p, will miss one of the residue classes. If p 2: 3 this is 
obvious, and if p = 2, the pair becomes (0, 0) or (1, 1) (mod p). This means 
that arbitrarily large pairs can be found such that no entry is divisible by p, 
and so p does not block the primality of that pair. The assertion that there 
are infinitely many n such that the pattern (n, n + 2) yields two primes is 
just the Twin Prime Conjecture. Note that (n, n + 2, n + 4) is not admissible 
because p = 3 turns this into (n, n + 2, n + 1), which hits all three classes. 
But (n, n + 2, n + 6) is admissible. Note that to check whether a k-term 
pattern (sometimes called a constellation) is admissible it suffices to 
check it modulo the primes up to k. 
The main conjecture - called the prime k-tuples conjecture and due 
to Hardy and Littlewood - is that every admissible pattern occurs infi­
nitely often among the primes, but not even the simplest case (the notorious 
Twin Prime Conjecture) has been proved (see [Rie] and [RWW] for more 
information, including heuristic arguments in favor of the conjecture). 
Here is a short routine for checking admissibility, where we assume the 
input is just a list of integers. 
AdmissibleQ [ c_] : = And @O ':rable [p = Prime [ i ]  " 
Length [Union [Mod [c ,  p] ] ]  ;. p ,  { i ,  zi: [Length [ c ] ] } ] 
AdlaissibleO [ { O, 2, 6, 8 } ]  
True 
We can easily find all the examples below 10,000 that fit the {0, 2, 6, 8} 
pattern. The next output contains the first members of the sequences. 
Select [ Prime [Range [zi: [ 10000 ] ] ]  , And @O PrimeQ [ I  + { 2 , 6 ,  8 } ] & ]  
{ 5 ,  1 1 ,  101 , 191, 82 1 ,  148 1 ,  187 1 ,  208 1 ,  3251 , 346 1 ,  565 1 ,  9431 } 
And here is an inadmissible constellation. 
Adm.issibleO [ { l', 7 ,  11 , 13 , 17 , 19 , 23 , 2 9 } ] 
False 
This pattern fails because all the mod-7 classes are represented. Therefore 
any sequence that fits this pattern will have an entry that is divisible by 7. 
Mod [ { l ,  7 ,  1 1 , 13 , 17 , 19 , 23 , 2 9 } , 7 ]  
{ l , o , 4 , 6 ,  3 , 5 , 2 ,  l } 
Here is the pattern determined by the primes between 11 and 29. It is 
admissible and Exercise 9.38 asks you to find some occurrences of it in the 
primes. 

9.2. TH E GAUSSIAN I NTEG ERS 
31 5 
largepattern = Prime [Range [ 5 , 10] ] - 11 
{ O , 2 , 6 , 8 , 1 2 , 1 8 }  
Adl!lissibleO [ largepattern] 
True 
One might think that an admissible constellation could not be denser 
than the initial segment of primes. But D. Gordon and G. Rodemich [GR] 
found an admissible constellation spanning an interval of size 4893 and 
having 655 numbers; n(4894) is only 654 (see Exercise 9.39). Such a constel­
lation is called a superdense constellation . If the prime k-tuples conjec­
ture is true, then there would be an interval of primes that follows this 
pattern. Such an interval would have a greater prime density than the 
corresponding interval starting at 2, which would contradict an earlier 
conjecture of Hardy and Littlewood that such an interval cannot exist! 
Now, in the hope of understanding what a Twin Prime Conjecture for 
the Gaussian primes might be, we can look at admissible patterns in the 
Gaussian primes. Let us use the term animal for a connected pattern of 
squares in the Gaussian lattice; an n-animal is an animal with n squares. 
Animals related by any of the eight symmetries of Gaussian primes are 
considered the same. An animal is admissible if for every Gaussian prime 
p, the animal, when reduced modulo p, does not cover all classes. Here is 
an extension of the routine just given that uses an option to handle both the 
rational and Gaussian cases. If the input has a complex number in it, then 
it will automatically work in the Gaussian integers. 
Options [AdmissibleQ] = { Gaussianintegers -+ False } ; 
AdmissibleQ [ c_ ,  opts __ ] : = Module [ {primes , gi , 1 = Length [c] } ,  
gi = Gauss ianintegers / . {opts } / . Options [AdmissibleQ] ; 
I f [ ! FreeQ [ c ,  Complex ] ,  gi .= True ] ; 
I f [gi , primes = 
Select [Flatten [Table [a + b I ,  {a ,  O ,  Floor [Vi"] } , 
{b ,  O ,  Floor[̃] }] ] , GaussianPrimeo] ; 
And H (Length [Union [Mod [c , I ] ] ]  'I- Gauss ianNorm [ I ]  & ) /0 
primes , 
And H Table [p = Prime [ i ] ; Length [Union [Mod [c , p] ] ]  '/- p ,  
{ i ,  zr [ l ] } 1 ] ]  
Of course, by parity considerations any admissible animal cannot have 
two squares that touch along an edge (in particular, one of two such touch­
ing squares would be divisible by 1 + i); an admissible animal can have only 
squares touching at a corner. Simple enumeration of possibilities (using the 
fact that the longest 45° row must have length 4, 3, or 2) shows that the 
following list contains all the 4-animals. 
animals [ 4 ]  = { { O ,  l + I , 2 + 2 I , 3 + 3 I } , { O , l + I , 2 + 2 I , l + I } ,  
{ O ,  l + I , 2 + 2 I , 2 } ,  { O ,  l + I ,  2 ,  J + I } ,  { I ,  1 + 2 I , 2 + I , l } } ; 

316 
9 .  PRI M E  I MAGI NARIES A N D  IMAG I NARY PRIMES 
Show [GraphicsArray [ (Graphics [ I ,  AspectRatio -+ Automatic , 
PlotRange -+ { { - 1 ,  5 } , { - 1 ,  5 } } ] & )  /@ 
Map [Rectangle [ {Re [ I ] , Im [ I ] } )  & ,  animals [ 4 ] , { 2 } ] ] ] i 
/ 
•
•
 
• •  
Figure 9. 12. The five admissible patterns of four Gaussian primes. 
And all five are admissible. 
AdJ!lissibleO /0 animals [ 4 ]  
{ True , True , True , True , True } 
However, one should focus on maximal admissible animals: ones that 
become inadmissible if a square is added anywhere. Let us call these lions. 
Then the admissible animals are just the connected subsets of any of the 
lions. 
Here are several points that can be proved with hand or light computer 
computations (see Exercise 9.40). 
• Of the five admissible 4-animals, only the diamond is a lion. 
• There are twelve 5-animals. 
• There are seven admissible 5-animals. 
• There are no 5-lions. 
Bringing more complicated computer programs to bear ([JR], [Varl], 
[RWW]) leads to: 
• The largest lion has size 48, and there are seven of them. 
• There are 52 lions in all, having size profile as follows, where an 
exponent indicates the number of lions of a given size: 4 12 17 19 20 
23 24 252 274 28 293 30 31 325 333 342 362 393 414 422 43 44 45 46 4 7 
487 . 
. 
Using a combination of computer techniques it is possible to capture all 
the lions. Renze, Wagon, and Wick [RWW] accomplished this by combining 
some ideas from computer graphics with the approach given by Vardi 
[Varl]. Vardi showed that every admissible animal is contained in one of 
506 animals, the largest of which have sizes 37, 50, 51, and 71 (details in 
Exercise 9.41). One can then prune the animals in all possible ways to yield 
connected subsets and check for admissibility; such connected sets, when 
they first occur, will be lions, and all lions arise in this way. Some care is 
necessary to check for maximality and eliminate the duplicates under 
symmetry. The complete collection is shown in Figure 9. 13. 

> 
4 5  
˺ 
4 1  
4 2  
ǎ Ǐ  
9.2. TH E GAUSSIAN I NTEG ERS 
31 7 
3 9  
˹ 
4 2  
Ǎ 
Figure 9.13. The complete catalog of lions, labelled by size. There are 52 of them. 
The CNT package contains a function that we will describe only briefly 
here. For more information on its derivation, implementation, and use, see 
[RWW] . Given an admisible constellation, such as {0, 2}, one can make a 
heuristic estimate of how many times the pattern is expected to appear 
among the primes under x. The ConstellationEstimate function does it, 
leaving the answer in symbolic form and li(x) is the logarithmic integral 
function (see Section 4. 1). The symbolic form of the output involves an 
infinite product over primes p and an integral of a negative power of log. 

31 8 
9. PRIME I MAGINARIES AND IMAG I NARY PRIMES 
ConstellationEstimate [ { O ,  2 } ,  Evaluateintegral -. False] [ x ]  
(2 n (p - 2) p) lx 
1 
dt 
p> 3 ( p - 1 ) 2 
0 Log [ t ]  2 
One can simplify the integrals that arise by omitting the option of the 
preceding input. 
ConstellationEstimate [ { O ,  2 } ]  [x] 
(2 n (p - 2) p) ( li (x) -_x _) 
p? J (p - 1 )  2 
log (x) 
And one can get the numerical value of the infinite product. 
H [ConstellationEstimate [ { O ,  2 } ] [ x ] ] 
1 . 32032 ( li (x) - lo:(x) ) 
And so we can find out the expected number of twin primes less than, say, 
1014 . 
Round [H [ConstellationEstimate [ { O ,  2 } ] [ 101' ] ] ]  
135780282954 
In fact, it is known that there are 135, 780,321,665 twin primes beneath 
1014 , so the error in the estimate is quite small. The good agreement here 
provides some evidence that the Twin Prime Conjecture is true. 
The estimates also work on constellations in the Gaussian integers, 
where the count is of the expected number of times the pattern occurs 
inside the first octant and inside the disk of radius x. 
ConstellationEstimate [ { 0 ,  2 ,  1 + I , 1 - I } ] [ x ]  
:3 (23 n (N(p) - 4 )  (N(.;) ) 3 ) . 
N ( p ) , 5 
(N (p) - 1 )  
( 
2 x2 
x2 
x2 
+ 4 li
3
(x2 ) ) 
- 3 log (x) - 3 1092 (x) - 3 1093 (x) 
Rationalize [ H [ConstellationEstimate [ { O , 2 ,  1 + I , 1 - I } ] [ x ] ] ] 
1 . 37959 ...!_ ( -
2 x2 
-
x2 
-
x2 
+ 4 li ( x2 ) 
rr3 
3 log(x) 
3 1092 (x) 
3 1093 (x) 
3 
H [ConstellationEstimate [ { O ,  2 ,  1 + I , 1 - I } ]  [ 2 00000 ) ] 
193922 . 
And, as shown in [RWW], there are 193,628 diamonds in the first 
octant and within distance 200,000 of the origin. 

Exercises for Section 9.2 
9.24. Prove all parts of Proposition 9. 7. 
9.2. TH E GAUSSIAN I NTEG ERS 
319 
9.25. 
Explain why, in the division algorithm for Gaussian integers, we 
cannot just let q = LuJ + LvJ i (where a/ f3 = u + iv), which would be the exact 
analog to what is done in the ordinary integers. 
9.26. Explain why, if a +  bi is a Gaussian prime, then the four nearest 
neighbors a +  (b ± l)i and (a ± 1) + bi are not Gaussian primes, except for a 
few cases surrounding 1 + i. 
9.27. Prove that if p is a Gaussian prime that divides af3 where a and f3 are 
Gaussian integers, then p must divide at least one of a, {3. 
9.28. Find a characterization of the Gaussian integers that are squares of 
Gaussian integers. 
9.29. Explain why the extended gcd coefficients s and t can be defined by a 
recursive formula identical to that formula for the integers (given in Sec­
tion 1.2). 
9.30. When ordinary integers are used in PrimeQ, Divisors, or Factor­
Integer, the Gau s s ianintegers option must be turned on if one wants 
the integer to be considered as a Gaussian integer. Explain why GCD can 
handle both domains without having a Gaussianintegers option. Hint: 
Use Proposition 9.7(h). 
Options [ PrimeQ] 
{ Gaussianintegers Ȉ False } 
Options [ GCD] 
{ } 
9.31. Use the Gaussian integers and Gaussian primes to give an alterna­
tive proof that if a prime integer is a sum of two squares, then its represen­
tation is unique, up to order and sign. Hint: Assume that p has two repre­
sentations a2 + b2 and c2 + d2 and use the fact that a ±  b i  and c ± di are all 
Gaussian primes. 
9.32. Formulate and implement an algorithm to factor a Gaussian integer 
a into powers of prime Gaussian integers. Outline: 
(a) Factor N(a) in Z. 
(b) If N(a) is even use 2 = ( 1  + i)2 to get the appropriate power of 1 + i. 
(c) Deal with the primes in N(a) that are congruent to 3 (modulo 4). 

320 
9. PRIME I MAGINARI ES AND IMAG INARY PRIMES 
(d) Deal with the remaining primes in N(a), by factoring such a p into the 
primes (a + b i)(a - bi) and determining how many of each divide a. 
Check your program by using the Un factor command from the CNT 
package. 
9.33. Show how the built-in Divisors function for Gaussian integers can 
be used to obtain all representations of an integer n as a sum of two 
squares. 
9.34. (a) Show that if n is an integer and a = a +  b i  is a Gaussian integer, 
then gcd(a, n) = 1 if and only if gcd(n - a, n) = 1 iff gcd(a - b i, n) = 1 iff 
gcd(b + ai, n) = 1. 
(b) Show that if n = 2 m  is an even integer and a is a Gaussian integer then 
gcd(a, n) = 1 if and only if gcd(m + m i - a, n) = 1. 
(c) To study the set of Gaussian integers coprime to an integer n, it suffices 
to look at integers whose real and imaginary parts lie in [O, n). Use parts (a) 
and (b) to show that, if n = 2 m  is even, there are 16 symmetry functions for 
the coprime data within this square. In fact, all the coprime information is 
given by the triangular region {a + b i : 0 ::5 a ::5 m, b :s; a, b :s; m - a ). Figure 
9. 14 shows the symmetries in the case n = 48. 
Figure 9.14. The Gaussian integers coprime to 48. Any one of the triangles can be 
used to generate the entire figure. 
9.35. The Gaussian integers are related to some important formulas for rr. 
For example, there is the relatively simple 

1C 
1 
1 
2 = arctan 1 + arctan 2 + arctan S 
which is equivalent to 
1 
1 
1C = 4 arctan 2 + 4 arctan 3 
9.2. TH E GAUSSIAN I NTEG ERS 
321 
But this formula, when expressed as an infinite series using the Maclaurin 
series for arctan x, is not too efficient in computing many digits of 1C because 
the powers of 2 and 3 do not grow very quickly. Much more impressive is 
Machin's formula 
1 
1 
1C = 16 arctan 5 - 4 arctan 239 
or Gauss's 
1 
1 
1 
1C = 48 arctan l8 + 32 arctan 57 - 20 arctan 239 . 
These formulas, expressed as infinite series, were used for several centuries 
to compute hundreds, thousands, and then millions of digits of 1C. Here is 
how these formulas can be understood using the Gaussian integers. 
The following factorizations are the key to Machin's formula. 
Factorinteger [ 2 3 9  + I ]  / / FactorForm 
I ( 1 + I ) ( 2 + 3 I ) 4 
Factorinteger [ ( 5 + I ) 4 ] / / FactorForm 
( 1  + I ) 4 ( 2  + 3 I ) 4 
Factorinteger [ 2 ,  Gaussianintegers -+ True ] / / FactorForm 
- I ( l + I ) 2 
These factorizations tell us that (5 + i)4 = 2 (239 + i)(l + i). Therefore 
z = (5 + i)4 / (239 + i) is a complex number whose angle (with the positive real 
axis) is 1C / 4. But 5 + i = r1 ei61 and 239 + i = r2 ei92 , where lh = arctan 1 /5 and 
02 = arctan 1 f239; it follows that the angle of z is 4 01 - 02 . 
Use similar techniques to prove Gauss's formula. Can you discover (an_d 
prove) Stormer's formula, which is a combination of arctan 1/8 ,  arctan 1/57 , 
and arctan 1 f239? 
9.36. Find the longest possible sequence of adjacent Gaussian primes on a 
line of slope 1. More precisely, find a long sequence of the form Pi . p2, 

322 
9. PRIME I MAGINARI ES AND IMAG I NARY PRI M ES 
p3 , 
• • •  such that Pi+ 1 
= Pi + 1 + i. Prove that your sequence is the longest one 
that exists. 
9.37. Modify the code in the text to generate an image of the Gaussian 
primes that are reachable from 1 + i in steps of size bounded by rs. If you 
have a computer with a lot of memory, you can try for an image of the YW -
reachable primes. For that you should arrange to show only points at the 
reachable primes (don't bother with the network of lines), as there are over 
249,000 reachable points. If memory is tight, just generate the image in the 
first octant (under the 45° line in the first quadrant), because, by symmetry, 
that contains the essence of the component. Also look at the V2-component; 
this consists of the Gaussian primes that are "connected" to 1 + i. Exercise 
9.41 looks at connected sets in more detail. 
9.38. Find a sequence of primes not starting with 5 or 11 that matches the 
pattern {n, n + 2, n + 6, n + 8, n + 12, n + 18} 
9.39. 
(Gordon and Rodemich [GR]) 
Let A consist of those integers n 
between 1 and 4893 that satisfy each of the following 45 incongruences 
n <f! 0(mod2) 
n "'  26(mod29) n "'  22(mod 67) 
n "'  42 (mod l07) 
n • 150(mod 157) 
n ;J;  2 (mod3l 
n $ 4{mod31) 
n '$ 24 (mod71) 
n • 12(mod 109) 
n "'  70(mod l63) 
n $ 4(mod5J 
n '$ 24(mod37) n '$ 70(mod 73) 
n • 106(mod 1 13) n * 72 (mod l67) 
n $  6(mod7) 
n * 32{mod41) n • 28(mod 79) 
n • 52 (mod l27) 
n • 77{mod l73) 
n "'  5 (mod l l) 
n * 10(mod43) n "'  30 (mod83) 
n • 54(mod 131) 
n • 78(mod 179) 
n * O(mod l3) 
n "'  12 (mod47) n "'  84(mod 89) 
n "'  125(mod l37) n !il 6l (mod l81) 
n '$ 6(mod l7) 
n '$ 30{mod53) n .; 9 (mod97) 
n • 58(mod139) 
n "' 84(mod l91) 
n $ 17(mod 19) n "'  18(mod59) n '$ 71 (mod 101) n "'  47.(mod l49) 
n * 98(mod l93) 
n -. O (mod23) 
n $  17 (mod61) n '$ 40(mod 103) n * 64(mod l51) 
n "' 188(mod 197) 
Show that A is admissible, and that A has more elements than the set of 
primes between 2 and 4894. 
9.40. Find all 5-animals, all admissible 5-animals, and all maximal admissi­
ble 5-animals. 
9.41. (J. H. Jordan, J. R. Rabung, I. Vardi) The goal of this exercise is 
to show that there is no admissible m-animal where m > 71. The reduction 
to the correct maximum of 48 takes a little more work along the lines of 
Exercise 9.42. 
(a) Let n = 130 = 2 · 5 · 13. Consider the Gaussian integers having real and 
imaginary parts between 0 and n - 1 and mark the ones that are relatively 
prime to n. Referring to Exercise 9.34, consider the triangular region -
{a +  b i : 0 s a s  m, b s a, b s m - a }  - that generates the full coprime data, 
and let T be the set of the Gaussian integers in that triangle that are 
coprime to n. Generate an image of T, as in Figure 9. 15. 

3 0  
2 5  
2 0  
1 5  
1 0  
5 
0 
0 
9.2. THE GAUSSIAN I NTEG ERS 
323 
1 0  
15 
2 0  
2 5  
3 0  
3 5  
4 0  
4 5  
5 0  
5 5  
6 0  
6 5  
Figure 9.15. The Gaussian integers coprime to 130. 
(b) Examine Figure 9. 15 and conclude that there is no path in T that 
touches all three sides. Locate the largest path in T that touches two sides; 
it has 75 points. 
(c) Show that the 75-animal of (b), when extended through the symmetric 
copies of the triangle, leads to one of size 580 (this comes from 8 · 70 + 4 · 5). 
This is the largest animal in the gcd-lattice in the 130 x 130 square. 
(d) Show that any admissible animal must be contained in the gcd-lattice 
in the 130 x 130 square. This proves that the largest admissible animal has 
size no greater than 580. In particular, there is no infinite animal, and so 
no prime walk to infinity using steps bounded by {2, no matter where one 
starts (see [GS]). 
(e) Repeat parts (a)-(d) with n = 390 = 2 · 3 · 5 · 13 to deduce that the largest 
admissible animal has size no larger than 71. For more information on the 
types of admissible animals see [RWW]. The largest admissible animal has 
size 48. 
9.42. Consider the pattern in Figure 9. 16, which we call a protolion and 
which has 50 elements; the source for this is discussed in Exercise 9.41. The 
coordinates are as follows: 
protolionSO = { O ,  2 ,  1 + I ,  2 + 2 I ,  1 + 3 I ,  2 + 4 I ,  3 + 5 I ,  4 + 6 I ,  
5 + 5 I ,  6 + 6 I ,  7 + 7 I ,  6 + 8 I ,  7 + 9 I ,  8 + 10 I ,  9 + 11 I ,  10 + 10 I ,  
l l + l l I , 12 + 12 I , 12 + 10 I , 8 + 12 I , 9 + 13 I , 8 + 14 I , 
7 + 1 5 I , 6 + 1 6 I , 5 + 15 I , 4 + 16 I , 3 + 17 I , 4 + 18 I , 5 + 19 I , 
3 + 1 9 I , 4 I , - l + J I , - 2 + 4 I , - J + S I , - 4 + 6 I , - 3 + 7 I , 
- 4 + 8 I , - 5 + 9 I , 
- 6 + 8 I , 
- 7 + 7 I , - 7 + 9 I , - 3 + 9 I , - 2 + 10 I , 
- l + l l I , - 2 + 12 I , - l + lJ I , 14 I ,  1 + 13 I , 2 + 14 I , 3 + 15 I } ;  
(a) Show that the only prime moduli for which this pattern fails to omit a 
residue are p 1 = 2 + 5 i  and p2 = 2 - 5i. This shows that the 50-element set 
is inadmissible. 

324 
9. PRIM E  I MAGINARIES AND I MAGINARY PRIM ES 
1 5 
---
o[--=--_:-_-
˽-
- ߏ- --=:_޲ 
- 5  
0 
5 
1 0  
Figure 9. 16. A 50-element animal that contains the largest lions. 
(b) Show that omitting one square from the set cannot lead to a 49-element 
admissible animal. Use Figure 9.17, which shows the residues modulo p1 
and P2 (where we are using a lemma, to be proved in Section 9.3, that 
residues mod 2 ± 5 i can be taken to be one of {0, 1, . . .  , 28}). 
(c) Find all ways of deleting two squares from the main pattern so that the 
remainder is connected and a residue is omitted in each case, thus making 
the 48-element set admissible. For example, deleting the two squares 
corresponding to 25 (mod p1 ) and 0 (mod p2 ) (the boldface entries in Figure 
9. 17) works and leaves an admissible set. Up to symmetry there are seven 
ways to perform such double deletions, which leads to the seven 48-lions. A 
similar analysis on the 51-component and 71-component of Exercise 9.41 
shows that the largest lions arising from those have sizes 45 and 44, respec­
tively, thus proving that 48 is the largest lion size. 
Figure 9.17. The reduction of the protolion modulo 2 + 5 i (left) and 2 - 5 i. Removal 
of the two boldface entries (25 and 0) yields a 48-animal that is admissible. 

9.3. HIGHER RECI PROCITY 
325 
9.43. Use the Conste l l ationEstimate function to predict how many 
times the pattern {n, n + 2, n + 6, n + 8} should be expected to appear be­
neath 10,000, and then count how many times the pattern does appear. 
9.3 Higher Reciprocity 
The Legendre symbol is an example of a character : a mapping x from ZϿ 
into C such that x(a)x(b) = x(ab). There are similar characters that reveal 
when a number is a perfect cube or fourth or higher power in ZЀ. We shall 
restrict attention to quartic residues, perfect fourth powers, and the 
corresponding quartic residue symbol (-;) 
4 • We would like this symbol to be 
+ 1 if and only if a is a quartic residue modulo p. But if 1 = x(a4) = x(a)4 , 
this means that the symbol needs to take on the values ± 1 and ± i; there­
fore we will work over the Gaussian integers; the primes we use as a modu­
lus will be Gaussian primes. 
This makes life a little more complicated. For the purposes of the 
quartic residue symbol, 5 is not prime. We will have to work either modulo 
1 + 2 i or 1 - 2 i. Moreover, if we are working modulo 7, say, then 3 is a 
quartic residue because (1 + i)
4 = -4; but there is no rational integer whose 
fourth power is 3 (mod 7). Let 1C be a Gaussian prime. Two Gaussian inte­
gers are congruent modulo 1f, written a +  b i = c + d i  (mod 7r), if and only if 
1C divides their difference. 
Lemma 9.10. Given a Gaussian prime 1f, there are exactly N(7r) distinct 
residue classes modulo 1C, and each nonzero residue class has an inverse 
modulo 1C. Moreover, if 1C = a + b i and neither a nor b is 0, then any Gauss­
ian integer µ is congruent modulo 1C to one of 0, 1, . . .  , N(7r) - 1. 
Proof. The existence of the inverse follows from the fact that we have an 
extended Euclidean algorithm (Theorem 9.8(c)). If 1C does not divide a, then 
we can find Gaussian integers s and t so that s a +  t 1C = 1; s is the inverse, 
modulo 1f, of a. 
If 1C = q, a rational prime congruent to 3 (mod 4), then each Gaussian 
integer is congruent to a Gaussian integer of the form a +  b i, 0 s a < q, 
0 s b < q, modulo q, and no two Gaussian integers of this form can be congru­
ent modulo q (Exercise 9.44). The number of distinct residue classes is 
q2 = N(q). 
If 1C = a +  b i, where ab * 0, let p = a2 + b2 ; p is a rational prime, 1C 
divides p, and p does not divide b. We claim that each Gaussian integer is 
congruent to exactly one of the integers 0, 1, . . .  , p - 1 (mod 1f). Given any 
Gaussian integer µ = m + ni, we can find a rational integer c such that 
cb = n (mod p). It follows that µ - C1C = m - c a (mod p), and so µ = m - ca 
(mod 7r). This shows that each Gaussian integer is congruent to a rational 
integer modulo 1C, and so must be congruent to one of the integers from O 
through p - 1 (mod 1C) . Because no two of these rational integers can be 

326 
9. PRIME I MAGI NARIES AND IMAGI NARY PRIMES 
congruent modulo tr (use Proposition 9. 7(d)), there are exactly p = N(n) 
residue classes modulo n. 
D 
Mathematica's Mod [ a ,  z ]  does not always give residues in the two 
classes of the preceng lemma (rather, it finds a residue whose absolute 
value is bounded by N[z] ); therefore we will want our own version for the 
Gaussian integers that makes the conditions of Lemma 9.10 the highest 
priority. Here are several utilities for Z[i]: Gau s s ianintegerQ detects the 
Gaussian integers, GaussianPrimeQ detects the Gaussian primes, Gauss­
ianNorm gives the norm, and Gaus s ianMod gives the residue lying in the 
complete systems specified in Lemma 9.10 (when the modulus is prime). 
These are included in the CNT package. We cannot use n, and so often use p 
for Gaussian primes. The _complex in the last case ensures that that case 
does not apply to primes of the form p or p i, where p is a rational prime. 
Note that any w is congruent to one of {0, 1, ... , N[z] - 1} modulo z so long as 
gcd(a, b) = 1, where z = a +  bi. This case is included in the code that follows. 
Gauss ianintegerQ [ a_Integer] : = True 
Gauss ianintegerQ [ Complex [a_Integer ,  b_Integer] ] : = True 
Gauss ianintegerQ [ a_] : = False 
GaussianPrimeQ [p_ ? GaussianintegerQ] 
·
­
PrimeQ [p , Gaussianintegers -+ True ] 
GaussianHorm [a_ ? GaussianintegerQ] : = Abs [ a ]  2 
GaussianMod [ a_ ? GaussianintegerQ , p_ ? Gaus s ianintegerQ ] 
• -
Module [ {pp = GaussianHorm [p] } ,  
Mod [ Re [ a ]  - Im [a] Re [p] PowerMod [ Im [p] , - 1 , pp] , pp ] ] / i  
I IntegerQ [p] && I MatchQ [ p ,  Complex [ O ,  _Integer] ]  && 
GCD [ Re [p] , Im [p] ] == 1 
GaussianMod [ a_ ?  GaussianintegerQ , p_ ?  GaussianintegerQ ] : = 
Mod [ a ,  p] 
SetAttributes [ I ,  Listable] & /0 
{GaussianintegerQ , GaussianPrimeQ , GaussianMod } i 
Gau11 iapPrimeO [ { 7 , 1 + 2 I ,  3 + 8 I } ]  
{ True , True , True } 
Gau11iapMod [ 2  + Range [ JO ] .'I ,  3 + 8 I ]  
{ 2 9 , 5 6 , 1 0 , 37 , 64 , 1 8 , 45 , 72 , 2 6 , 5 3 , 7 , 3 4 , 6 1 ,  1 5 , 42 , 
6 9 , 2 3 , 5 0 , 4 , 3 1 , 5 8 , 12 , 39 , 6 6 , 2 0 ,  4 7 , 1 , 2 8 ,  5 5 , 9 } 
Gau1 1iaRKod [ 34 + 12 I ,  14 + 9 I ] 
2 0 0  

9.3. HIGHER RECI PROCITY 
327 
Theorem 9.11. Fermat's Little Theorem for Gaussian Integers If 1C is 
a Gaussian prime and a is a Gaussian integer that is not divisible by 1f, 
then aNCrr>-1 = 1 (mod 1C). 
The proof is essentially identical to the classical Fermat Little Theorem, 
and is left to Exercise 9.45. Here are some examples. 
GaussianMod [ PowerMod [ { 19 ,  3 + 2 I ,  11 , 1010 + 1 + 10 I } , 
GaussianNorm [ I ]  - 1 , I ] , I ]  & /@ { 1 + 2  I ,  7 ,  3 + 8 I } 
{ { 1 ,  1 ,  1 ,  1 } ,  { 1 ,  1 ,  1 ,  1 } ,  { 1 , 1 ,  1 ,  l } }  
Now, if 1C is a Gaussian prime and N(7r) :/:. 2, then N(1C) = 1 (mod 4). 
Therefore, if 1C does not divide a and N(7r) :/:. 2, then acNcrr>-1>14 is a Gaussian 
integer and it satisfies x4 = 1 (mod 1C). But this congruence has the four 
incongruent solutions ± 1 and ± i; it has no other solutions because if 1C 
divides x4 - 1, then 1C divides the product (x + l)(x - l)(x + i)(x - i), and hence 
divides one of the factors. Therefore we have that 
NCrr>-1 
a
-
4 - = ± 1 or ± i (mod 1C) . 
We define the quartic residue symbol, (.;:. ) 4 , to be ± 1 or ± i, so that 
N<rr>-1 ( Q' )  
a-
4 - = -; 
4 
(mod 1C) .  
Corollary 9.12. If 1C is a Gaussian prime and a is a Gaussian integer that 
is not divisible by 1C, then a is a fourth power modulo 1C if and only if 
( .!. ) = l. 
Tr 4 
Proof. 
If a is a fourth power modulo 
lf, say a = {34 (mod 1C), then 
aCN<rrl-ll/4 = pN<rr>-1 = 1 (mod 7r), so ( .!. ) 
= 1. For the converse, let g be a 
Tr 4 
primitive root modulo 1C (this requires generalizing the work in Chapter 4 
on primitive roots for primes to the Gaussian prime context, but in fact this 
uses no new ideas; see Exercise 9.51). Then (g" : e = 1, . . .  , N(1C) - 1} is a 
complete residue system for 1C. If e is a multiple of 4 then g" is of course a 
fourth power and the quartic residue is correct. If e is not a multiple of 4, 
then g"<Ncrr>-1>14 cannot be 1 (mod 1C) because the exponent is not a multiple of 
N(7r) - 1, which is the order of g (mod 1C). And these powers of g are not the 
fourth powers of any other power of g, so they are not fourth powers at all, 
because powers of g exhaust the possible fourth roots. 
D 
The quartic residue symbol is not defined for 1C = 1 + i. Various aspects 
of the quartic residue symbol are discussed in the exercises, the highlight 
being the law of quartic reciprocity (Exercise 9.53) which was discovered by 
Gauss, and proved later by F. G. Eisenstein. 
Here is code to compute the quartic residue symbol. 

328 
9. PRI ME IMAG INARIES AND I MAGI NARY PRIMES 
Attributes [QuarticResidueSymbol] = Listable ; 
QuarticRes idueSymbol [a_ ? G&ussianiptegerQ, p_ ] 
: =  
(GaussianMQd [PowerMod [ a ,  (aaussianlorm [p] - 1 )  / 4 ,  p ] , p ]  / .  
{ I f [ IntegerQ [p] , p - 1 ,  GaussiapRorm [p] - l ]  -+ - 1 ,  
GaussiaDMQd [ I ,  p ]  -+ I ,  G&ussiagMod [ - I , p ] -+ - I } )  / ;  
G&ussiapinteaerO [p] && Gaussiap,Horm [p] ;. 2 
p = 8 + 3 I ; 
powers =  PowerMod [ l3 + { l ,  2 ,  3 }  I ,  4 ,  p ]  
{ 7 + 5 I , l + S I , 3 + 4 I } 
Quart,icR@sidueSymbol [powers , p] 
{ 1 ,  1 ,  1 }  
We next show how working in the Gaussian integers allows us to 
determine which elements of Zp are fourth powers mod p, when p is a 
rational prime. If p = 3 (mod 4) then it is not hard to see that the fourth 
powers coincide with squares, which correspond to integers x for which 
( '}) * - 1. Every fourth power is obviously a square. And if x = y2 (mod p) 
then also x = (-y)2 (mod p). But we know that - 1  is a nonsquare mod p, so 
it follows that one of ± y  is a square mod p; this means that x is a fourth 
power. Now, if p = 1 (mod 4), then p splits into (a + bi) - (a - bi). If x is a 
fourth power mod p it will be a fourth power mod each of these factors and 
so ( a:b i  )4 = ( aάb i  )4 
= 1. Conversely, if these two quartic symbols are both 1, 
then x is a fourth power modulo each of a ±  bi and, by Lemma 9. 10, the two 
fourth roots can be taken to be integers. But if x = y4 (mod a + bi) then 
x = y4 (mod a - bi): just take conjugates in the equation x = k(a + bi) + y4 • 
Because a - bi and a +  bi are relatively prime, this means that x is a fourth 
power modulo (a +  bi)(a - bi), or modulo p. 
Here is a routine that detects the fourth powers for all rational primes. 
FourthPowerQ [m_,  p_ ?  PrimeQ] : = 
JacobiSymbol [m, p] ;. - 1  / ; Mod [p , 4 ]  = =  3 ;  
FourthPowerQ [m_,  2 ]  : = True 
FourthPowerQ [m_,  p_ ?  PrimeQ] : = ( 
{ a ,  b} = SumOfSquaresRepresentations [ 2 ,  p ]  [1:0 ; 
MemberQ [ { O ,  l } , OUarticResidueSymbol [m, a +  b I ] ] )  I ; 
Mod [ p,  4 ] = = 1 
And here we check by comparing it to an exhaustive listing. 
n = 13 ; 
Select [ Range [O , n - 1 ] , FourthPowerQ [ I  , n ] & ] 
Union [ PowerMod [ Range [ O ,  n - l ] , 4 ,  n] ]  
{ O ,  1 ,  3 , 9 } 
{ O , 1 ,  3 ,  9 } 

n = 19 i 
9.3. H I G H E R  RECIPROCl1Y 
329 
Select [ Range [ O ,  n - 1 ] , FourthPowerQ [ I ,  n] & ]  
Union [ PowerMod [ Range [ O ,  n - l ] , 4 ,  n ] ]  
{ O ,  1 ,  4 , 5 , 6 ,  7 , 9 , 1 1 ,  16 , 1 7 }  
{ O ,  1 ,  4 , 5 , 6 ,  7 , 9 , 1 1 ,  16 , 1 7 } 
Recalling the power grids of Chapter 2, the present work tells us that, 
when p is prime, the number of distinct integers in the fourth column is 
either (p - 1) I 2 or (p - 1) I 4 according as p is or is not a Gaussian prime. 
Other quadratic extensions of the integers and rationals are possible. If 
d, called the discriminant, is squarefree, we can consider the field Q(../d), 
which consists of all reals of the form r + s../d, where r and s are rational. 
The integers of this field refer to the elements of the field that satisfy a 
monic polynomial with integer coefficients. 
If d = 1 (mod 4), then the integers are of the form (m + n ..fd) / 2, where 
m and n are rational integers of the same parity. Otherwise the integers 
are of the form m + n ..fd where m and n are arbitrary rational integers. 
The norm of m + n ..fd is always m2 - dn2 • 
There are relatively few quadratic extensions for which the norm can be 
used to create a Euclidean algorithm. The complete list of cases for which 
the norm does yield a Euclidean algorithm is: d = - 1, - 2, - 3, -7, - 11, 2, 3, 
5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57, and 73. And in these cases, 
because there is a Euclidean algorithm there is unique factorization for the 
integers of Q(../d). 
But there are other quadratic extensions that have unique factorization 
even though the norm does not admit a Euclidean algorithm. When d is 
negative they are d = - 19, -43, - 67, - 163. In the 1960s Harold Stark 
proved that there are no other quadratic extensions with negative discrimi­
nant (d) that have unique factorization. For positive discriminants it has 
been conjectured but not proven that there are infinitely many cases with 
unique factorization. Among those that have unique factorization but for 
which one cannot use the norm to get a Euclidean algorithm are d = 14, 22, 
23, 31, 38, 43, 46, 47, 53, 59, 61, 62, 67, 69, 71, 77, 83, 86, 89, 93, 94, and 97. 
All other square-free discriminants between - 100 and 100 yield quadratic 
extensions with nonunique factorization. 
These distinctions can help explain many mysteries involving rational 
integers, and also real numbers. For instance, the fact that the integers of 
Q(ffl) admit a Euclidean algorithm is related to the amazing property of 
x2 + x + 41 discovered by Euler: This polynomial is prime for every value of 
x between -40 and 40. And the fact that Q(y- 163 ) has unique factorization 
is related to the curiosity, observed by Ramanujan, among others, that 
e"../163 is very close to an integer. 
AccountingForm[H [E" "163 , 35] ]  
2 6 2 5 3 7 4 1 2 6 4 0 7 6 8 7 4 3 . 99999999999925007 

330 
9. PRIME I MAGINARI ES AND I MAGI NARY PRIMES 
For more information in these directions an excellent place to start is the 
book by by D. Flath [Fla]; see also [Els], [EM], [Mol], or [Rib] . 
Exercises for Section 9.3 
9.44. Prove that if q is a rational prime congruent to 3 (mod 4), then q 
divides a +  b i  if and only if q divides a and q divides b. Show that this 
implies that the q2 values a +  bi, 0 s a, b < q, are distinct modulo q. 
9.45. Let rr be any Gaussian prime. Use the fact that every residue class 
other than 0 has an inverse modulo rr to prove that if rr does not divide a, 
then aNC1r>-1 = l(mod rr). 
9.46. Show that, for any Gaussian integer z = a + bi with d = gcd(a, b), the 
rectangle {r + si : O s s < d, O s r s d((a/d)2 + (b/d)2)} is a complete residue 
system modulo z. Implement a routine that, given x and z, returns the entry 
in this rectangle that is congruent to x (mod z). 
9.4 7. Show that if q is a rational prime congruent to 3 (mod 4), and a is a 
rational integer not divisible by q, then ( ˸ )
4 
= 1. 
9.48. Show that if q is a rational prime congruent to 3 (mod 4), then ( f) 
4 = 
(- l)<q+ll/4 • If rr is a Gaussian prime that is not rational with N(rr) = p, then 
( f )4 
= i(p- 1)/4 . 
9.49. Prove that a polynomial of degree n has at most n incongruent solu­
tions over the Gaussian integers modulo rr, where rr is any Gaussian prime. 
Hint: This is similar to the rational case (Theorems 3.17 and 3. 18), using 
Exercise 9.27 as necessary. 
9.50. Prove that if rr is a Gaussian prime, then the order of any integer in 
the reduced residue system modulo rr must divide N(rr) - 1. 
9.51. Prove that if tr is a Gaussian prime and d divides N(rr) - 1, then in the 
reduced residue system modulo rr there are exactly </J(d) elements of order d. 
In particular, there is at least one element of order N(rr) - 1, which is called 
a primitive root for rr. 
9.52. Each Gaussian prime rr (other than 1 + i and its associates) has four 
representations: ±rr, ±rri. Prove that exactly one of them is either congruent 
to 1 (mod 4) or congruent to 3 + 2 i (mod 4). This is called the primary 
representation of rr. For example, - 1  - 2 i is the primary representation of 
1 + 2 i, -7 is the primary -representation of 7, and - 5  + 2i is the primary 
representation of 2 + 5i. Implement a routine that finds primary representa­
tions (the built-in Mod can be used to do this). 
9.53. There is a law of quartic reciprocity for Gaussian primes. Experiment 
with pairs of Gaussian primes written in their primary representation until 
you can state it with confidence. Gauss stated this law in 1832, but he 

9.3. HIGHER RECIPROCllY 
331 
never published a proof. He claimed that the proof "belongs to the mysteries 
of higher arithmetic." The first proof was published by F. G. Eisenstein in 
1844 (see [IR]). 


APPEN DIX A 
Mathematica Basics 
A.O Introduction 
Mathematica is a somewhat unusual programming language. While it has 
some features in common with BASIC, Pascal, and C, it is really a radical 
departure from anything that has come before. In fact, the breadth and 
depth of the program are phenomenal and we can only touch the surface in 
this brief appendix. For a fuller treatment of the capabilities of Mathemat­
ica see [Wag, Wol]. 
A central point is that it is an interpreted language, which means that 
one can execute commands in real-time, without having to compile them 
into a program. Just start typing and an Input cell will form (to create 
other types of cells, type some text, select the cell via its cell bracket on the 
right, and try some of the entries in the Format:Style menu). Hit the enter or 
shift-return keys and your command will be evaluated. 
2 "  3 1 4  
3 3 3 7 4 7 9 7 4 3 6 2 6 4 2 2 0 0 3 7 4 2 2 2 1 4 1 5 88 9 9 2 5 1 79066 7 2 5 8 1 6 1 8 2 2 6 9 9 5 3 0 4 2 2 5 ȉ  
2 5 1 2 2 2 2 2 1 8 3 2 1 5 3 2 2 508594 1 0 8 7 82608384 
Here are a few examples that are particularly relevant to the study of 
number theory. First, a modest factorization. 
Factorinteger [ lOOOOOOOO l] 
{ { 7 , 1 } , { 1 1 ,  l } ,  { 1 3 , l } , { 1 9 ,  l } ,  { 525 7 9 , l } }  
This means that 1000000001 = 7 · ll · 13 · 19 · 52579. Here is the thousandth 
prime. 
Prime [ lOOO ] 
7 9 1 9  
Here is how to tell (with a reasonable amount of certainty - see Chapter 4) 
whether an integer is prime. 

334 
APPENDIX A. MATHEMATICA BASICS 
False 
PrimeQ [ lO A  30 + 57 ] 
True 
Here are all the divisors of 10000. 
Divisors [ lOOOO] 
{ l ,  2 , 4 , s ,  8 , 10 , 1 6 , 20 , 2 5 , 40 , s o , 8 0 , 1 0 0 , 1 2 5 , 2 00 , 
2 5 0 , 400 , 5 0 0 , 625 , 1000 , 1250 , 2 0 0 0 , 2 5 0 0 , 5000 , 1 0000 } 
The PrimePi function gives the number of primes under x. 
PrimePi [ lOOOOOO] 
7 8 4 9 8  
Here is the lOOth Fibonacci number. 
Fibonacci [ lOO] 
3 5 4 22 4 8 4 8 1 79 2 6 1 9 15075 
Of course you can write programs. It is tempting to use Do-loops, much 
as one would do in a traditional languages. Often more advanced tech­
niques will be better, but Do-loops have their place, and the next code 
shows how to implement a loop to compute the sum of the first 10 integers. 
The semicolons at the end of the lines suppress the output from that line. 
The phrase { i ,  1 ,  1 O }  is called an iterator in this context. The 1 can be 
omitted. Or a step can be added, as in { i ,  1 , 1 0  , 2 } . 
sum = o i 
Do [ sum = sum +  i ,  { i ,  1 ,  10 } ]  i 
Bum 
55 
There is a built-in Sum function, though in fact the Do-loop is a good 
approach when adding thousands of numbers. 
Sum [ i ,  { i ,  1 ,  10 } ] 
5 5  
There are several important notational conventions. 
• All built-in Mathematica functions begin with a capital letter 
(functions and variables you define have no such restriction). 

APPENDIX A. MATHEMATICA BAS ICS 
335 
• A space will, in most cases, be interpreted as multiplication. thus a b 
is the same as a*b (but ab denotes a single variable called "ab'). 
• Round brackets, ( ) , are used for grouping, as in 2 ( 3+5 ) .  
• Square brackets, [ ] , are used for arguments to functions. 
• Curly braces, { } , are used to denote lists, such as { 1 , 2 , 3 } . 
One can use the Table command to make a list. 
Table [ i A 2 ,  { i ,  1 ,  10 } ] 
{ 1 ,  4 , 9 , 1 6 , 2 5 , 3 6 , 49 , 64 , 8 1 ,  100 , 1 2 1 } 
One can add a step-size to an iterator as a fourth entry. 
Table [ i A 2 , { i ,  2 ,  10 , 2 }  ] 
{ 4 , 1 6 , 3 6 , 6 4 , 1 0 0 } 
But some lists, like the integers from a to b, can be obtained more easily 
using Range. 
Range [ lO ,  2 0 )  
{ 1 0 , 1 1 ,  1 2 , 1 3 , 1 4 , 1 5 , 1 6 , 1 7 , 1 8 , 1 9 , 20 } 
And because numerical operations are "listable" - meaning that they work 
on the elements of a list - this can be a quick way of avoiding program­
ming. Here is an example that squares the even integers, as we just did 
using Table. 
Range [ 2 , 10 , 2) A 2  
{ 4 , 1 6 , 3 6 , 6 4 , 1 0 0 } 
A handy abbreviation is the use of % to refer to the last-computed output. 
Sqrt [ 12 3 4 . ]  
35 . 1 2 8 3  
\ A 2  
1 2 3 4 .  
A.1 Plotting 
A powerful feature of Mathematica is its sophisticated graphics capabilities. 
Here is a standard plot. 

336 
APPENDIX A. MATHEMATICA BASICS 
Plot [Sin [ l / x] ,  { x ,  0 . 02 ,  1 } ] i 
1 
0 . 5  
0 . 6  
- 0 . 5  
- 1  
Next we add some options to improve the look. 
Plot [ Sin [ l / x] ,  { x ,  0 . 02 ,  1 } , 
0 . 8  
1 
Frame - >  ±rue , Axes 
- > False , PlotPoints 
- > 200] i 
0 
0 . 2 
0 . 4  
0 . 6  
0 . 8  
1 
To get information about a function one can first ask for its usage message. 
? Plot 
Plot [ f , { x , xmin , xmax } ] generates a plot of f 
as a function of x from xmin to xmax . Plot ( { f l ,  
f2 , 
•
•
•
 } ,  { x , xmin , xmax } ] plots several functions fi . 
Options [ Plot ) 

APPENDIX A. MATH EMA TICA BASICS 
337 
1 
{ AspectRatio 4 GoldenRatio , Axes 4 Automatic , AxesLabel 4 None , 
Axesorigin 4 Automatic , AxesStyle Ȋ Automatic , 
Background 4 Automatic , ColorOutput 4 Automatic , 
Compiled 4 True , DefaultColor ĝ Automat ic , Epilog ĝ { } ,  
Frame 4 False , FrameLabel 4 None , FrameStyle 4 Automatic , 
FrameTicks 4 Automatic , GridLines 4 None , ImageSize 4 Automatic , 
MaxBend 4 1 0 . , PlotDivision 4 30 . , PlotLabel 4 None , 
PlotPoints 4 2 5 , PlotRange 4 Automatic , PlotRegion 4 Automatic , 
PlotStyle 4 Automatic , Prolog 4 { } ,  RotateLabel ȋ True , 
Ticks 4 Automatic , DefaultFont :-+ $DefaultFont , 
DisplayFunction :-+ $DisplayFunction , 
FormatType :-+ $FormatType , TextStyle :-+ $TextStyle} 
? MazBend 
MaxBend is an option for Plot which measures the maximum 
bend angle between successive line segments on a curve . 
One can also use the Help Browser in the Help menu, which provides 
examples and more detailed information about each Mathematica function. 
Often one has data points that need plotting. This is done with List­
Plot. Here is some data that counts the number of divisors of n. 
8 
6 
4 
2 
data = ':rable [ { n ,  Lengtb [Divisors [n] ] } ,  { n ,  30} ] 
{ { l ,  l } , { 2 , 2 } , { 3 , 2 } ,  { 4 , 3 } ,  { 5 , 2 } ,  { 6 , 4 } ,  
{ 7 , 2 } ,  { 8 , 4 } ,  { 9 , 3 } ,  { 10 , 4 } ,  { 1 1 ,  2 } , { 1 2 ,  6 } ,  
{ 1 3 , 2 } , { 1 4 , 4 } ,  { 1 5 , 4 } ,  { 1 6 , 5 } ,  { 1 7 ,  2 } ,  { 1 8 , 6 } ,  
{ 1 9 , 2 }  I { 2 0 , 6 } I { 2 1 , 4 } I { 2 2 , 4 } I { 2 3 , 2 }  I { 2 4 , 8 } I 
{ 2 5 , 3 } I { 2 6 , 4 } I { 2 7 I 4 } I { 2 8 , 6 } I { 2 9 , 2 } I { 3 0 ,  8 } }  
ListPlot [data] i 
5 
1 0  
1 5  
2 0  
2 5  
3 0  

338 
APPENDIX A. MA TH EMA TICA BASICS 
ListPlot [data, PlotJoined -> True , Frame -> True , Axes -> None ] ; 
8 
6 
4 
2 
o '--'-ύώϏϐϑϒϓϔϕϖϗϘ 
0 
5 
1 0  
1 5  
2 0  
2 5  
3 0  
A.2 Typesetting 
Mathematica provides an environment that allows simple typesetting of 
complicated mathematical expressions. And equally important, one can e­
mail these expressions, or entire notebooks, to users who are on diferent 
platforms. Here are the basic ideas. 
Mathematica input and output comes in three flavors: InputForm, 
StandardForm, and Tradi tionalForm. The first two are the most impor­
tant to a beginner. InputForm is straightforward inline computer-code 
style, such as 
Sin [ x ] Pi / Sqrt [ ll ] • Sum [ l / n " ( l / 2 ) , { n ,  1, Infinity } ] 
StandardForm is very close to traditional mathematical notation, but is 
perfectly precise and unambiguous as input. Here is the StandardForm 
version of the preceding expression. 
Sin [ x ]  n ̝ _1_ 
W 
ft nJ12 
It is easy to convert between the two forms by using the items in the Cell : 
Convert To menu. One can arrange that inputs and outputs be in either of 
the two forms by using the Cell :DefaultlnputFormatType and Cell:DefaultOut­
putFormatType menu items. We recommend that beginners use InputForm 
for input and StandardForm for output. When you learn more about the 
typesetting system you might prefer to use StandardForm for input too. 
StandardForm is fine for short programs, but longer programs should 

APPENDIX A. MATHEMATICA BASICS 
339 
probably be written in InputForm. The following table shows some of the 
differences in these two forms. 
Input.Form 
st.andardFom ___ l 
Integrate [ f [ x ] , 
{ x ,  O ,  l } ] 
Sum [ l / n " 2 ,  { n ,  1 ,  Infinity } ]  
Product [ x + i , { i , 1 , 4 } ] 
I 
Logintegral {Log [ x J  / Sqrt [ x] ] 
Lo9Inte9ral [ ̟*'z1 ] 
Floor [ x /  5 ]  
Floor [ f ] 
When working in a StandardForm eel there are many shortcuts. For 
example, one can enter an expression in InputForm, select the cell and 
ConvertToStandardForm . This will turn 
into 
Integrat.e ( l / Log [ z ]  "' 15 ,  { x , O ,  Infinity} ] 
.£"' Log ;x ] is dx 
Alternatively, one can use the palettes (use the File:Palettes menu item 
to make the basic palettes operative). But there are many easy-to-remem­
ber escape-key and control-key sequences that make typesetting simple. 
Table A l  shows some of the keyboard shortcuts that we have found most 
useful. The most important ones are ̣6] for superscript, Ϋ-] for sub­
scripts, !Qfil{2] for square roots, and IQ[l[/] to create a fraction. These can be 
found in the Edit:Expression Input menu. 
Here's an example to show how simple keystrokes can be used to create 
the formula 
<f>(n) ;?; nnr (i - _1 ) ;?; _n_ 
i=l 
Pi 
log2(2 n) 
ml{9] 
To start an inline cell. 
ްfޱ(n) 
f yields I 
l§l >= m n 
Im{>) or @I{>) also works for this 
Product(l - lfp;, (i, 1, r}) 
Then . select this phrase and convert it 
StandardForm. 
˶ >= ˷ n ̢[I] 
log lJH 2 right arrow(2n) 

340 
APPENDIX A. MATH EMA TICA BASICS 
Key sequence 
Result 
! Full name 
@; a ;  
a 
l 
\ [Alpha ] 
1----··˻ ˼-· ---- -----------1 
;@ D r@  
6 
i 
\ [ CapitalDelta ] 
1----i-----·-----···-----1-------1 
c inf [@ 
oo 
\ [ Infinity ] 
!---------·----·--· 
-· -·--·-·---·-·--------l 
[@ p i@ 
7T 
\ [ Pi ] 
(@elem!@ 
e 
\ [ Element ] 
i@eĉ 
e 
\ [ Epsilon ] 
!@ degd 
0 
\ [ Degree ] 
i@ - >  [@ 
ܹ 
, 
\ [ Rule ] 
I@ l f  ޮ 
L 
! 
\ [LeftPloor ] 
5 rf i@ 
J 
! 
\ [RightFloor ] 
1----1-----+---------ܻ 
I@ *  I.@ 
x 
\ [Times ] 
1----1-----+----·-ܺ-
[@ . ޯ 
\ [ CenterDot ] 
I 
'-ŕ-'-ŗŘřŚśŜ-l l 
!@ = = =  i@ 
_ 
\ [ Congruent ] 
'--------'-------- -----' ! 
!@ - 100 
-
\ [Tilde ] 
i@ '  I.@ 
, 
i 
\ [ Prime ] 
1-------1-ܼܾܽܿ----+---------݀----
l@ un !@ 
U 
\ [Union ] 
[@_ int {@ 
n 
[@ dsZ [@ 
Z 
l@ scP I@ 
'f .. 
x ©ID[6] _2 . 
©ilf2] 1i: ' 
•
. · 
l l@[ / ]  23 ' 
©ilf.9] ' 
. .r . .  
· l 
..
•. 
"f ' 
. . .
.
 
\ [ Intersection ] 
\ [DoubleStruckCapitalZ) 
-\ [ DoublΪSt.r,uc,kCapi talZ J 
-̣i,raetionBe>X 1 · 1  ·" Ω 
• 23_" 1 . 
Table A.I. Keyboard shortcuts for useful typesetting commands. 
For something like I din <f>(d) = n one would create a normally indexed sum, 
convert it, and then delete the upper index and edit the lower one into d I n. 
K Sending Files By E-Mail 
If you have a complete file you would like to send via e-mail, then that can 
be done with the standard send file or attach file feature of your e-mail 
software. The user will receive a text-only version of the notebook, but 
when it is opened in Mathematica it will look like a formatted notebook. 
If you just wish to send a single cell that is mostly text, use the Edit: 
Copy As:Text menu item and paste the text into an e-mail message. If the 
cell has typesetting in it then you can copy it as a Cell object and e-mail 
that. The recipient will be able to paste it and get it to look like a cell. Note 

APPENDIX A. MATHEMATICA BASICS 
341 
that the internal form of any cell can be viewed by selecting the cell and 
choosing the Format:Show Expression menu item. 
A.3 Types of Functions 
A dummy variable is represented by a blank ( _). Here is how to define a 
function f that squares its input. The : = indicates a delayed assignment, 
meaning that the right-side is not evaluated until f is called. 
f [ x_] 
: =  x2 
f [ l S ]  
2 2 5  
f [w] 
w2 
Using Select is a convenient way to select from a list numbers having a 
specified quality. Here are the evens. 
Select [ Range [ lO] , EvenQ] 
{ 2 , 4 , 6 , 8 ,  1 0 }  
Next we define a function called good that gives True only if its input is 
prime and of the form lOOk + 1. Then we can easily find all good numbers 
below 1000. Note that a check for equality is done via 
= = , as opposed to 
just =. 
good [ x_] 
: =  PrimeQ [ x ]  && Mod [x , 100 ] = =  1 
Select [ Range [ lOOO ] , good] 
{ 1 0 1 ,  4 0 1 ,  6 0 1 ,  7 0 1 }  
The preceding discussion concerns the familiar way of applying func­
tions to arguments. But there are slightly less familiar ways, and these are 
built-into Mathematica. For example, we might wish to apply a function to 
each member of a list. Map accomplishes that. 
Map [ func , { a , b ,  c ,  d } ] 
{ func [ a ] , func [ b ] , func [ c ] ,  func [ d ] }  
Or sometimes we have a list but we wish to treat its entries as arguments 
to a function. This is done by Apply. 
Apply [ func , { l ,  2 ,  3 } ]  
func [ 1 , 2 , 3 ] 

342 
APPENDIX A. MATHEMATICA BASICS 
Here is an example: The greatest common divisor function wants its argu­
ments in sequence, not as a list. 
GCD [ lOO , 642 ] 
2 
When we use a list, nothing happens. 
GCD [ { lOO , 642 } ]  
{ 100 , 6 4 2 } 
But Apply turns the list into a sequence of arguments. 
Apply [GCD ,  { 100 , 642 } ] 
2 
Iteration is an important concept. The Nest and NestList functions 
apply a given function n times. Here is an example where we apply the 
squaring function 5 times, starting with 2. 
sq [ x_] : =  x " 2 ;  
Nest [ sq ,  2 ,  5 ]  
4 2 9 4 9 6 7 2 9 6  
NestList causes the entire sequence of iterates to be shown. 
NestList [ sq ,  2 ,  5 ]  
{ 2 , 4 , 1 6 ,  2 5 6 , 655 3 6 , 4 2 9 4 9 6 7 2 9 6 } 
Having to define functions such as sq and good in the examples above 
can be a bother. For example, if we wish to iterate the cosine function, it is 
very simple. 
NestList [ Cos , 0 . 2 , 15] 
{ 0 . 2 , 0 . 9 8 0 0 6 7 , 0 . 5 5 6 9 6 7 , 0 . 848 8 6 2 , 0 . 6 6 0 8 3 8 , 0 . 7 8 9 4 7 8 , 
o .  704 2 1 6 , o .  7 6 2 1 2 , o .  7 2 3 3 7 4 , o .  7 4 9 5 7 7 , o .  7 3 1 9 7 7 , 
0 . 74 3854 , 0 . 7 35864 , 0 . 74 1 2 5 1 ,  0 . 7 3 7 6 2 4 , 0 . 7 4 00 6 8 } 
There is a construction, called a pure function, that allows us to specify a 
function without defining it with a separate name. The idea is that # is the 
generic variable, and & is used to mark the end of the pure function. Thus 
the squaring function is # "  2 & .  This can be used as a function. 
But the more important use of this construction is as follows, where we 
repeat the computation given earlier using Se lect. 

APPENDIX A. MATHEMATICA BASICS 
343 
Select [ Range [ lOOO ] , (PrimeQ [ I ]  && Mod [ I ,  100] == 1 )  & ]  
{ 10 1 ,  4 0 1 , 60 1 ,  7 0 1 }  
This is a very powerful mechanism. For another example, here is how to 
find all the primes under 5000 having the form n2 + 1. 
Select [ Range [ SOOO] , (PrimeQ [ I ]  && IntegerQ [ Sqrt [ l - 1 ] ] )  & ]  
{ 2 , s ,  1 7 , 3 7 , 1 0 1 , 1 9 7 , 2 5 7 , 4 0 1 ,  
5 7 7 , 6 7 7 , 1 2 9 7 , 1 60 1 ,  2 9 1 7 , 3 1 3 7 , 4357 } 
Fold and FoldList are useful in some special situations. 
FoldList [ f ,  0 ,  { a ,  b, c } ]  
{ O ,  f [ O , a] , f [ f [ O , a] ,  b] ,  f [ f [ f [ O , a] ,  b] , c ] }  
To see this in action, note that pure functions of two or more arguments 
use #1, #2 , . . .  for the variables. The first argument to Fold must be a 
function of two arguments. 
Fold [ f , 1 , { 3 , 4 , 5 }  ] 
f [ f [ f [ l , 3 ] ,  4 ] ,  S J 
We can use this idea to quickly code the left-to-right method of modular 
exponentiation (see Section 1.4) as follows. Rest [ IntegerDigi ts [ n ,  2 ]  ] 
gives all the base-two digits except the leading 1. 
pawermodLRl [ a_,  n_ , m_] : = 
Fold [Mod [Mod [ l l  1 1 ,  m] * I f [ l 2  == 1 ,  a ,  1 ] ,  m] & ,  
a ,  Rest [ IntegerDigits [ n ,  2 ] ] ]  
pawermodLRlList [ a_ ,  n_ , m_] : = 
FoldList [ Mod [Mod [ l l l l , m] • I f [ l2 == 1 ,  a ,  l ] , m] & ,  
a ,  Rest [ IntegerDigits [ n ,  2 ] ] ]  
powermodLRlList [ a  I 4 1 , Infinity ] / / .  Mod [z_ ,  oo ] : > x 
{ a ' a 2 ' as ' a i o ' a 20 ' a 4 1 } 
{powermodLR [ 3 , 4 1 , 7 ] , pawermodLRl [ 3 , 41 , 7 ] } 
{ 5 I 5 } 
A.4 Lists 
Lists in Mathematica are delineated by braces. 
S =  { l ,  2 ,  3 ,  9 ,  8 ,  7 } 
{ l ,  2 , 3 , 9 , 8 ,  7 } 

344 
APPENDIX A. MATHEMATICA BASICS 
Here are some examples of operations on lists. 
Sort [ s ]  
{ l ,  2 , 3 ,  7 , 8 ,  9 } 
Reverse [ & ]  
{ 7 , 8 , 9 , 3 , 2 , 1 } 
s [ [ 4 ] ] 
9 
In StandardForm one can use a special character for double brackets: 
[@ [  [ ̤ yields [ .  
s [ - 1] 
7 
Take [ s ,  3 ]  
{ l ,  2 , 3 } 
A matrix is just a list of lists 
{ { l ,  2 } , { 3 , 4 } }  
{ { l ,  2 } ,  { 3 , 4 } }  
MatrixForm [ { { 1 ,  2 } , { 3 ,  4 } } ] 
IdentityMatrix [ 3 ]  
{ { 1 , O ,  O } , { O ,  1 , O } , { O ,  O , 1 } }  
Matrix multiplication is carried out by a dot: ( ǌ :) .(:) 
= ( 164). 
A = { { l , 2 } , { 3 , 4 } } i  
A . { 2 , 2 }  
{ 6 , 1 4 } 
Here are three other common operations on matrices. 
Transpose [A] 
{ { 1 ,  3 } , { 2 , 4 } }  

Det [A] 
- 2  
Eigenvalues [A] 
{ ; (5 - VJJ) , ; (5 + VJJ) }  
APPENDIX A. MATHEMATICA BASICS 
345 
As a final example, here is how the IntegerDigits function, which 
returns the list of digits of an integer, can be used to decide if an integer is 
a palindrome (reads the same forward or backward, like 1991). Then we can 
very easily find all the palindromic primes between, say, 10,000 and 1 1,000. 
palindromeQ [ x_] : =  
IntegerDigits [ x ] = = Reverse [ IntegerDigits [ x ] ] 
palindromeQ [ l 2 1 ]  
True 
palindromeQ [ l 2 1 1 ]  
False 
Select [ Range [ 10000 , 11000 ] , PrimeQ [ I ]  && palindromeQ [ I ]  & ] 
{ 1 0 3 0 1 , 1 0 5 0 1 , 1 0 6 0 1 } 
A.5 Programs 
Here is a simple example to show how a While loop can be used to add up 
1, 1 / 22 ,  1 / 32 ,  until the terms are less than 1/1000. Note the decimal point 
after the 1, which turns everything into approximate reals. Try it without 
the decimal point to see the perfectly precise rational answer. 
sum = 0 1  n = 1 1  
1 
1 
1 .  
1 
While [ -
> 
-- , sum = sum + - 1 n = n + 1 1 
n2 
1000 
ॕ 
sum 
1 .  6 1 3 1 9  
Note the comma in the While phrase that separates the condition from 
what is being done. And what is being done consists of two statements -
change the sum; change the term - separated by a semicolon. 
Often in a program one wishes to see the progress of a computation. 
Here is how to use a Print statement to print a tracing message every 
tenth step. 

346 
APPENDIX A. MATHEMATICA BASICS 
sum = 0 1 n = l 1 
1 
1 
While [ - > -- , 
n2 
1000 
I f [Mod [ n ,  10] == 0 ,  Print [ { n ,  " terms . The sum is " , sum} ] ] 1  
1 .  
1 
sum = sum + - 1 n = n + 1 1 
nz 
sum 
{ 1 0 , terms . The sum is , 1 . 5 3 9 7 7 } 
{ 2 0 , terms . The sum is , 1 . 59 3 6 6 } 
{ 30 , terms . The sum is , 1 . 6 1 104 } 
1 .  6 1 3 1 9  
The preceding ideas can be turned into a general program as follows. 
sumSquareReciprocals [tolerance_] : = (sum = 01 n = 1 1  
While [ ˴ > tolerance , sum = sum + ˵ 1 n = n + 1] 1 sum) 
n2 
n2 
sumSquareReciprocals [ l / 1000 ] 
1 .  6 1 3 1 9  
Here is another simple example of a program, one that finds the first 
prime greater than or equal to the input. 
nextprime [ z_] : =  (n = z 1  While [ I PrimeQ [ n ] , n = n + l ]  1 n) 
nextprime [ lOO] 
1 0 1  
nextprime [ 1012 ] 
1 000000000039 
An important point in writing programs is make the auxiliary variables 
local, so that they are unaffected by any prior definitions. For example, if n 
was already set to something the value would be lost by the n = z part of the 
next prime program. This can be avoided by using Module, whose first 
argument is a list of symbols that are to be local only. The second argument 
is a compound statement comprising the main program. 
nextprimel [ z_] : = Module [ {n } , 
n = z 1 While [ I  PrimeQ [n] , n = n + l ]  1 n ]  
n = 159 1 
nextprimel [ 100] 
1 0 1  
And n is still 159. 

D 
1 5 9  
APPENDIX A .  MATHEMATICA BASICS 
347 
A cautionary note: Code such as the following will fail, where the z is 
both the dummy variable and a variable being incremented. The reason 
this fails is that when nextprime2 [ 1 0 0 ) is called, the z = z + 1 part of the 
program becomes 1 0  O 
= 1 0  0 + 1 ,  which is of course not allowed and yields 
error messages. And the loop runs forever because the z in PrimeQ [ z ]  
never departs from 100. If you run this code you will have to abort the 
program, which is accomplished by either control-period or :H:-period. 
nextprime2 [ z_] : = (While [ ! PrimeQ [ z ] , z = z + l] 1 z ) 
nextprime2 [ 100 ] 
Set : : setraw : Cannot assign to raw object 100 . 
It is often useful to restrict the inputs to, say, odd integers or prime 
integers, and that can be done with the n_?OddQ construction. Here is an 
example of a function that works only on odd integers n and returns True if 
and only if n = 5 or n > 1 and if n = 1 or 4 (mod 5) then n divides Fn- I  while 
if n = 2 or 3 (mod 5), then n divides Fn+l · (Note: If n = 0 (mod 5) then it is 
not hard to see than n does not divide Fn+i , and this is why the 0 case is 
ignored in the code.) 
FibonacciPseudoprime!l'est [n_? OddQ] : = n  == 5 1 1  
( n  > 1 && 0 = = Mod [ 
Fibonacci [n - I f  [MemberQ [ { l ,  4 } , Mod [n ,  5 ) ] ,  1 ,  - 1 ) ] ,  n ] ) 
And here is how one would find composite numbers that pass the Fibonacci 
pseudoprime test (see Exercise 1.38). 
Select [ Range [ lOOO] , I PrimeQ [ I ]  && FibonacciPseudoprimeQ [ I )  & ]  
{ 32 3 ,  3 7 7 } 
A.6 Solving Equations 
Mathematica uses substitution rules, such as x - > 2 (same as x ܸ 2), to 
replace every occurrence of x in an expression by 2. One reason this is 
important is that the global value of x is unchanged. The replacement is 
carried out by the slash-dot operator, / .  
x2 + 2 / .  x -+  2 
6 
x 
x 

348 
APPENDIX A. MATHEMATICA BASICS 
And this explains why the solutions to equations are given as substitution 
rules. 
soln = Solve [x3 + 7 x2 - 5 x - 35 == O ,  x] 
{ { x -+ - 7 } ,  { X -+ - Vs } ,  { x -+ Vs } }  
:i: / .  soln[2] 
Solve works only for equations having a solution that can be expressed in 
terms of standard functions. In general, fifth-or-higher degree polynomials 
do not have such solutions. One can always try to use Solve. Be aware that 
solutions often involve imaginary numbers. 
1 
soln = Solve [Cos [2 x] Sin [x] = =  - , x) 
2 
-[57" 1/3 
{ {x -+ -ArcSin [ ( 9 -
2 3213
) 
+ 
1 
113 
( 3 ( 9 - -[57" ) )  
J } , 
( l + I ../3 ) ( 9 - -{57 ) 1 13 
{ x -+ ArcSin [ 
4 3213 
+ 
( 1 - I ../3 ) ( 9 - -{57 ) 1 1 3  
{ x -+ ArcSin [ 
4 3213 
+ 
1 - I ../3 
2 ( 3 ( 9 - -f57" ) ) 11 3  ] } , 
l + I ../3 
] } }  
ܷ r;_-;:;-
l I 3 
2 ( 3 ( 9 - v ::> i ) )  
Here are the numerical values of the three solutions. 
nSoln = N [x / .  soln] 
{ - 1 . 0 8 5 7 3 , 0 . 4 34 1 7 4  - 0 . 3 1 9 5 6 1  I , 0 . 4 3 4 1 7 4  + 0 . 3 1 9 5 6 1  I } 
We can check them using the listability of sine and cosine. 
Cos [2 nSoln] Sin [nSoln] 
{ 0 . 5 , 0 . 5 - 2 . 7 7556 x l 0-17 I , 0 . 5 + 2 . 7 7 5 5 6 x l 0-17 I } 
Small imaginaries are caused by roundoff error; Chop gets rid of small 
quantities. 
Chop [\] 
{ 0 . 5 , 0 . 5 , 0 . 5 } 
Sometimes there are built-in functions that can help solve equations 
that you might think are unsolvable. The ProductLog function is useful for 
some simple equations involving powers and logarithms. 

Solve [ x  10" = =  2 ,  x ]  
{ { 
ProductLog [ 2 Log [ 1 0 ]  ] } } 
x __. 
Log [ 1 0 ] 
APPENDIX A. MATHE MA TICA BASICS 
349 
Of course, many equations cannot be solved symbolically but have to be 
approached numerically using Newton's method or the like. This is accom­
plished by FindRoot, but we must provide a starting value. 
FindRoot [ ( x2 + 1 )  10" == 2 ,  { x ,  l } ] 
{ x -. 0 . 2 7 0 3 8 6 } 
A. 7 Symbolic Algebra 
Here are a few examples to show the power of symbolic computation. First, 
an easy geometric series. 
Sum [ l / 2k , { k ,  1 ,  oo } ) 
1 
Here is the sum of a finite geometric series. We switch to StandardForm. 
D 
1 
L 2k  
k=l 
Here is an elementary sum. 
i=l 
1 
2 n ( 1 + n )  
Here is one that is harder to remember. 
i=l 
1 
6 n ( 1 + n )  ( 1 + 2 n )  
And here is an infinite geometric series with x as the ratio. 
D•O 
1 
1 
- x 

350 
APPENDIX A. MATHEMATICA BASICS 
Here is a more complicated infinite series . 
., 
XD 
 (n + 2) ! 
- 1  + Ex - x 
x2 
And of course derivatives and (many) integrals can be done effortlessly. 
o [sin [x] Cos [ x2 ] 17 , x] 
Cos [ x] Cos ( x2 ) 17 - 34 x Cos [x2 ] 16 Sin [x] Sin [x2 ) 
I 
1 
-- cl x  
1 + x' 
ArcTan [ -../2 •2 x ] 
Ji 
ArcTan [ǋ ] 
+ 
2 -{2  
-
Log [ - 1 + ../2 x - x2 ] 
-ā--Ă----'- + Log [ l + ../2 x + x2 ] 
4 -{2 
4 -{2 

APPEN DIX B 
Lucas Certificates Exist 
In Section 8.2 we discussed how to obtain a Lucas certificate that proves an 
integer n is prime. However, it remains to prove that such certificates 
always exist for the method as described in that section. We present such a 
proof in this appendix. 
Let p be an odd prime and d a quadratic nonresidue modulo p. We shall 
prove that among the p2 - p pairs of integers a, b for which 1 s a <  p and 
0 s b < p, exactly (p - l)</J(p + 1) of them are such that the Lucas sequence 
defined by P = 1 and Q = (1 - a-2b2d)/4 (mod p) will certify the primality of 
p. In particular, a Lucas certificate of primality (as defined in Section 8.2) 
exists. 
We will be working with numbers of the form a +  b ../d where a and b 
are integers. We first need a divisibility result for these generalized inte­
gers. To say that p divides a + b../d means that a + b../d = p(u + vVd) for 
some pair of integers u and v, and therefore (see Exercise 7.19) p divides a 
and p divides b. 
Lemma. Suppose that p is an odd prime and d is a quadratic nonresidue 
modulo p. Then if p divides (a + b../d )(f + g../d ), then p divides a +  b../d or 
p divides f + g ../d. 
Proof. If p divides (a + bVd )(f + g../d) = af + bgd + (bf + ag)../d, then p 
divides (a - b ../d)(f - g../d) = af + bgd - (bf + ag)../d. It follows that p2 
divides (a2 - db2)(f2 - dg2), and so p divides a2 - db2 or {2 - dg2 • We can 
assume it divides a2 - d b2• If p does not divide b, then b has an inverse 
modulo p and (ab-1 )2 
= d (mod p), which contradicts the fact that d is a 
nonresidue modulo p. Therefore p divides b and so it must divide a. 
o 
We now do our arithmetic on these extended residues modulo p. To 
say that 
a + b ../d  = f + g../d (mod p) 

352 
APPENDIX B. LUCAS CERTIFICATES EXIST 
means that p divides the difference of the left and right sides, so a = f and 
b = g. This residue system has p2 residues, p2 - 1 of which are relatively 
prime to p. 
The lemma implies that any monic polynomial of degree n has at most 
n incongruent solutions modulo p (as in Theorem 3.17; see Exercise B.3). In 
a manner exactly analogous to what we did in Section 3.5 where we proved 
that there are </J(p - 1) primitive roots modulo p, it is possible to use this 
lemma to prove that there are exactly <fJ(p2 - 1) residues of order p2 - 1 in 
the set of extended residues modulo p. We leave this for the exercises where 
you are led through the proof that the order of each extended residue that 
is relatively prime to p must divide p2 - 1, and if m divides p2 - 1, then 
there are <fJ(m) extended residues of order m. 
Among the p2 - 1 extended residues that are not divisible by p, p - 1 of 
them are rational integers. These satisfy the congruence xP-l = 1 (mod p). 
Since this congruence has at most p - 1 solutions in the extended residues 
(Exercise B.3), we know that the order of {3 = a +  b .,/d, divides p - 1 if and 
only if p divides b (if and only if {3 is a rational integer). 
Now consider the Lucas sequence defined by parameters P and Q with 
d = P2 - 4 Q and a = (P + ../d,) / 2. Suppose that p is a prime such that d is a 
nonresidue modulo p. Then the Lucas sequence will certify the primality of 
p if and only p + 1 is the smallest power of a that is congruent to a rational 
integer modulo p. This is true if and only if the order of a is (p2 - 1) / t 
where t is relatively prime to p + 1. The divisors of p2 - 1 that are relatively 
prime to p + 1 are precisely the odd divisors of p - 1. 
If a + b.,/d, has order (p2 - 1) / t where t is an odd divisor of p - 1, then 
any Lucas sequence with P = 2a and Q = a2 - b2 d (mod p) will certify the 
primality of p. 
The certification protocol we presented restricts the search to Lucas 
sequences with P = 1. This is not a significant restriction. Let {3 = a +  b .,/d, 
be a residue for which p + 1 is the smallest power that is congruent to a 
rational integer. If p does not divide a, then this will still be true of (2a)-1 {3. 
The corresponding Lucas sequence is P = 1, Q = (1 - a-2b2d)/ 4 (mod p). 
Exercises for Appendix B 
B.1. Imitate the proof of Fermat's Little Theorem to prove that for any 
extended residue, {3, modulo p that is not divisible by p, f3P2 -1 = 1 (mod p). 
B.2. Prove that the order of {3 modulo p must divide p2 - 1. 
B.3. Prove that x" = 1 (mod p) can have at most n incongruent roots among 
the extended residues modulo p. 
B.4. In Section 3.5, we used the fact that x" = 1 (mod p) has at most n 
solutions modulo p to prove that for each m that divides evenly into p - 1, 
there are exactly </J(m) integers modulo p with order m. In a precisely analo­
gous manner, prove that if m divides p2 - 1, then exactly <fJ(m) extended 
residues have order m. 

APPENDIX B. LUCAS CERTIFICATES EXIST 
353 
B.5. Let p - 1 = 2e m where m is odd. Show that 
I 
Ȫ( p2 
t- 1 J = (p - l)Ȇ(p + 1) . 
tlm 
B.6. 
Show that if P = 1 and Q is chosen at random from among those 
integers for which 1 - 4 Q is a nonresidue modulo p, then the probability 
that this sequence will certify the primality of p is Ȇ(p + 1)/ p. 
B.7. Check computationally the main claim of this appendix: Given a prime 
p and a quadratic nonresidue d for p, then among all the pairs a, b with 
1 s a <  p, 0 s b < p, exactly (p - l)Ȫ(p + 1) of them are such that the Lucas 
sequence defined by P = 1 and Q = (1 - a-2 b2d) / 4 (mod p) has the property 
that w(p) = p + 1. 


References 
[AS] 
W. Adams and D. Shanks, Strong primality tests that are not sufficient, 
Mathematics of Computation, 39, 255-300 (1982). 
[AGP] 
W. R. Alford, A. Granville, and C. Pomerance, There are infinitely many 
Carmichael numbers, Annals of Mathematics, 140, 703-722 (1994). 
[BS] 
E. Bach and J. Shallit, Algorithmic Number Theory, MIT Press, Cam­
bridge, MA (1 996) . 
[BW] 
R. Baillie and S. S. Wagstaff, Jr., Lucas pseudoprimes, Mathematics of 
Computation, 35, 1391-1 4 1 7  (1980). 
[Ble] 
D. Bleichenbacher, Efficiency and Security of Cryptosystems Based on 
Number Theory, ETH Ph.D. dissertation 1 1404, Swiss Federal Instititute 
of Technology, Zurich (1996). 
[BB] 
J. Borwein and P. Borwein, Pi and the AGM: A Study in Analytic Number 
Theory and Computational Complexity, Wiley, New York (1987). 
[BLS] 
J. Brillhart, J. L. Selfridge, and D. H. Lehmer, New primality criteria and 
factorizations of 2m ± 1 ,  Mathematics of Computation, 39, 620-647 (1975). 
[BC] 
J. P. Buhler and R. E. Crandall, On the convergence problem for lattice 
sums, Journal of Physics, Series A: Mathematical and General, 23, 
2523-2528 (1990). 
[BW l] 
J. Buhler and S. Wagon, Secrets of the Madelung constant, Mathematica 
in Education and Research, 5:2, 49-55 (1996). 
[CELV] 
F. W. Clarke, W. N. Everitt, L. L. Littlejohn, and S. J. R. Vorster, H. J. S. 
Smith and the Fermat two squares theorem, American Mathematical 
Monthly, 106, 652-665 (1999). 
[Coh] 
H. Cohen, A Course in Computational Algebraic Number Theory, Springer­
Verlag, Berlin (1 993). 
[CB] 
R. E. Crandall and J. P. Buhler, Elementary function expansions for 
Madelung constants, Journal of Physics, Series A: Mathematical and 
General, 20, 5497-5510 (1987). 
[CP] 
R. Crandall and C. Pomerance, Prime Numbers: A Computational Perspec­
tive, Springer-Verlag, New York (2000). 
[DR] 
M. Deleglise and J. Rivat, Computing Jr(x): The Meissel, Lehmer, Lagarias, 
Miller, Odlyzko method, Mathematics of Computation, 65, 235-45 (1996). 
[DM] 
E. Dunne and M. McConnell, Pianos and continued fractions, Mathematics 
Magazine, 72, 104-1 1 5  (1999). 

356 
[ELS] 
[EM] 
[Fla] 
[FW] 
[For] 
[GW] 
[Gal] 
[GS] 
[GWW] 
[GR] 
[Gro] 
[Guy] 
[HW] 
[Hod] 
[HB] 
[IR] 
[Jon] 
[JSWW] 
[JR] 
[Kah] 
[KW] 
[Knu] 
[KSW] 
[Leh] 
REFERENCES 
R. B. Eggleton, C. B. Lacampagne, and J. L. Selfridge, Euclidean qua­
dratic fields, American Mathematical Monthly, 99, 829-837 (1992). 
J. Esmonde and M .  R. Murty, Problems in Algebraic Number Theory, 
Springer-Verlag, New York (1999). 
D. Flath, Introduction to Number Theory, Wiley, New York (1989). 
D. Flath and S. Wagon, How to pick out the integers in the rationals: An 
application of number theory to logic, American Mathematical Monthly, 
98, 812-823 (1991). 
K. Ford, The distribution of totients, Electronic Research Announcements 
of the American Mathematical Society, 4, 27-34 (1998). 
J. Gallian and S. Winters, Modular arithmetic in the marketplace, Ameri­
can Mathematical Monthly, 95, 548-55 1  (1988). 
J. Gallian, Error detection methods, ACM Computing Surveys, 28:3, 504-
5 1 6  (Sept. 1 996). 
E. Gethner and H. M. Stark, Periodic Gaussian moats, Experimental 
Mathematics, 6, 289-292 (1997). 
E. Gethner, S. Wagon, and B. Wick, A stroll through the Gaussian primes, 
American Mathematical Monthly, 104, 327-337 (1998). 
D. M. Gordon and G. Rodemich, Dense admissible sets, Proceedings of 
Algorithmic Number Theory Symposium Ill, Lecture Notes in Computer 
Science 1423, Springer-Verlag, New York, 216-225 (1998). 
E. Grosswald, Representations of Integers as Sums of Squares, Springer­
Verlag, New York (1985). 
R. K. Guy, Unsolved Problems in Number Theory, 2nd ed., Springer­
Verlag, New York (1994). 
G. H. Hardy and E. M. Wright, An Introduction to the Theory of Numbers, 
5th ed., Oxford Univ. Pr., Oxford (1 979). 
A. Hodges, Alan Turing: The Enigma, Simon and Schuster, New York 
(1983). 
R. H. Hudson and A. Brauer, On the exact number of primes in the 
arithmetic progressions 4n ± 1 and 6 n  ± 1 ,  Journal fi,r die Reine und 
Angewandte Mathematik, 29 1, 23-29 (1 977). 
K. Ireland and M. Rosen, A Classical Introduction to Modern Number 
Theory, Springer-Verlag, New York (1982). 
J. Jones, Diophantine representation of the Fibonacci numbers, Fi.bonacci 
Quarterly, 13, 84-88 (1975). 
J. P. Jones, D. Sato, H. Wada, and D. Wiens, Diophantine representation 
of the set of prime numbers, American Mathematical Monthly, 83, 449-
464 (1976). 
J. H. Jordan and J. R. Rabung, Local distribution of Gaussian primes, 
Journal of Number Theory, 8, 43-5 1 (1 976). 
D. Kahn, The Codebreakers: The Story of Secret Writing, Macmillan, New 
York (1983). 
V. Klee and S. Wagon, Unsolved Problems in Plane Geometry and Number 
Theory, Mathematical Association of America, Washington, DC (1991). 
D. E. Knuth, The Art of Computer Programming, vol. 2, Addison-Wesley, 
Reading, MA (1971). 
G. C. Kurtz, D. Shanks, and H. C. Williams, Fast primality tests for 
numbers less than 50 · 109 , Mathematics of Computation, 46, 69 1-701 
(1986). 
E. Lehmer, On the infinitude of Fibonacci pseudo-primes, Fi.bonacci 
Quarterly, 2, 229-230 (1964). 

[Mar] 
[Mat] 
[Mau] 
[Mor] 
[NZM] 
[PW] 
[PSW] 
[RWW] 
[Rib] 
[Rie] 
[Ros] 
[RS] 
[SW] 
[Schn] 
[Sehr] 
[SRK] 
[Tue] 
[Var] 
[Varl] 
[Wag] 
[Will 
[Will] 
[Wil2] 
[Woll 
[Zag] 
[Zagl] 
REFERENCES 
357 
G. Martin, The smallest solution of IP(30n + 1 )  < IP(30n) is . . .  , American 
Mathematical Monthly, 106, 449-45 1 (1999). 
Y. Matijasevich, Hilbert 's Tenth Problem, MIT Press, Cambridge, MA 
(1993). 
U. Maurer, Fast generation of prime numbers and secure public-key 
cryptographic parameters, Journal of Cryptology, 9, 123-155 ( 1 995). 
S. B. Morris, Magic Tricks, Card Shu{fiing, and Dynamic Computer 
Memories, Mathematical Association of America, Washington, DC (1998). 
I. Niven, H. S. Zuckerman, and H. L. Montgomery, An Introduction to the 
Theory of Numbers, 5th ed., Wiley, New York (1991). 
E. Packel and S. Wagon, Animating Calculus, Springer/TELOS, New York 
(1997). 
C. Pomerance, J. L. Selfridge, and S. S. Wagstaff, Jr., The pseudoprimes to 
25 x 109 , Mathematics of Computation, 35, 1003-1026 (1980). 
J. Renze, S. Wagon, and B. Wick, The Gaussian zoo, forthcoming. 
P. Ribenboim, The New Book of Prime Number Records, 3rd ed., Springer­
Verlag, New York (1996). 
H. Riesel, Prime Numbers and Computer Methods for Factorization, 
Birkhauser, Boston (1985). 
K. H. Rosen, Elementary Number Theory and Its Applications, 3rd ed., 
Addison-Wesley, Reading, MA (1993). 
M. Rubenstein and P. Samak, Chebyshev's bias, Experimental Mathemat­
ics, 3, 1 73-197 (1994). 
A. Schlafly and S. Wagon, Carmichael's conjecture is valid below 
1010·000·000 , Mathematics of Computation, 63, 4 1 5-419 (1994). 
B. Schneier, Applied Cryptography, 2nd ed., Wiley, New York (1996). 
M. Schroeder, Number Theory in Science and Communication, Springer­
Verlag, Berlin (1984). 
A. S. Sethi, V. Rajaraman, and P. S. Kenjale, An error-correcting coding 
scheme for alphanumeric data, Information Processing Letters, 7, 72-77 
(1978). 
B. Tuchman, The Zimmermann Telegram, Macmillan, New York (1966). 
I. Vardi, Prime percolation, Experimental Mathematics, 7, 275-289 (1998). 
I. Vardi, Archimedes' cattle problem, American Mathematical Monthly, 
105, 305-3 1 9  (1 998). 
S. Wagon, Mathematica in Action, 2nd ed., Springer/TELOS, New York 
(1 999) . 
H. Wilf, Generatingfunctionology, Academic Press, San Diego (1994). 
H. C. Williams, A numerical investigation into the length of the period of 
the continued fraction expansion of ..fd, Mathematics of Computation, 36, 
593-601 (1981). 
H. C. Williams, Edouard Lucas and Primality Testing, Wiley, New York 
(1 998). 
S. Wolfram, The Mathematica Book, 4th ed. , Cambridge Univ. Press, New 
York (1 996). 
D. Zagier, The first 50 million prime numbers, The Mathematical Intelli­
gencer, 0, 7-1 9  (1977). 
D. Zagier, A one-sentence proof that every prime = 1 (mod 4) is a sum of 
two squares, American Mathematical Monthly, 97, 144 (1 990). 


Mathematica Index 
Items in boldface are from the CNT package; items in italics denote symbols 
defined in the book, but not in the CNT package. 
@@, App ly, 5 1  
I I (function application), xviii 
/ . , Rep l ac eAl l ,  19-20, 347-348 
_, B l ank, xviii 
_, BlankSequence, xviii 
__ , Bl ankNu l l Sequence, xviii 
= = , Equal , xviii 
= = =, SameQ, xviii 
# , Slot, 62, 342-343 
# 1 ,  33 
# 2 , 33 
& , Func ti on, 342, 343 
& & , And, 343 
: > , Rul eDe l ayed, 73 
% (preceding output), 335 
? (show information), 336 
: =, SetDe l ayed, 341 
AlnmdantQ, 76 
Account ingForm, 329 
Ad.itionChain, 32, 37-38 
AdmiaaibleQ, 3 1 2 , 3 1 5-3 16  
Al iquotsequ.ence, 77-78 
AmicableQ, 76 
And, 312 
anima l s, 3 1 5-3 1 6 
Apply, 22, 44, 5 1 , 299, 341-342 
AspectRatio, 3 1 1 , 3 1 6  
Aaawaedl'rimeBOIUld, 126 
As sumptions, 44 
Attributes, 123 
Average, 7 1  
AverageLiat, 7 1  
Axes, 336 
AxesLabe l , 36 
Bi:aryLeftToRight, 32 
Bi:aryRightToLeft, 37 
Binomi al, 29 
BirthDate, 30 1 
BLSPrimeProof, 12 1-122 
Carmichae lLambda, 94 
CazmichaelQ, 6 1 , 98 
Ce l l ,  340 
Cen tra lRema inder, 281, 284 
Cert i f icate, 1 32 
Certifiec!Prime, 100, 127-128 
crractor, 243-245 
CFPeri odLength, 220 
CFSqrt, 222 
ChineseRema i nder, 53 
Chop, 348 
C i rc le, 31 1 
CNT package, xii, 6 
Co l l ec t, 2 14, 230 
ColumnForm, 29 
Colwana, 66 
Compl exGCD, 305 
COlductor, 47 

360 
MATH EMA TICA INDEX 
ConstellationB•timate, 31 7-3 18, 325 
continuantQ, 10--12 
ContinuedFrac t i on, 207, 2 1 7  
Cont inuedFrac ti onForm, 202 
Convergents, 203, 207, 209 
CorrectPrime, 134 
CRT, 5 1-52 
CR'l'Grid, 50 
DeficientQ, 76 
De l e teCases, 241 
Denominator, 79, 214 
De t, 345 
Di ophan tineSolve, 42--43 
Divisors, 72, 299, 305, 319, 334 
DivisorS igma, 72 
Do, 33, 334 
Drop, 10 
EALength, 23 
Ei genva lues, 345 
Ep i l og, 36 
Bratosthene•, 107 
BratosthenesTable, 106 
Bucli4, 1 1 1 ,  120, 122 
J:valuate:tzategral, 3 1 7  
EvenQ, 34 1 
Expand, 43, 224, 230 
ExpandDenomi nator, 214 
:b:panentPorm, 62, 68 
exponen tsBinazy, 24 1 
ExtendedGCD, 15, 28, 42 
BxtendedGCDValues, 1 5, 204, 282, 306 
Factor, 225 
PactorPorm, 6, 17, 305 
Factorinteger, 6, 17, 305, 31 9, 32 1 , 333 
Pacto:dfethoc!, 37 
Ferma tFa c tor, 1 70 
PeŨtllmber, 183 
Fibonacc i , 3, 1 2, 334 
FindComponent, 3 1 1  
F indRoot, 349 
PirstSPSPWitness, 1 1 7  
Fi t, 36 
FixedPo intLi st, 7 1  
Fl atten, 78, 187 
Fl oor, 7, 1 76 
Fo l d, 33, 1 90, 343 
Fo ldList, 33, 297, 343 
FourthPowerQ, 328-329 
Frame, 3 10, 336 
FrameTicks, 310 
PramCPSquared, 224 
FromContinuedFrac t i on, 203, 2 1 7  
FromDigits, 88 
FromSRKin teger, 167 
PUllCODtinuant, 204 
PUllCODtinuedPraction, 203-204, 2 1 7  
PUllQCD, 8-9, 12, 15, 204, 282, 305-306 
PUllPrattCertificate, 126 
Ful l Simpl i fy, 223 
PUDctiODBeading, 70, 1 7 1  
PUDctiODTable, 66, 70, 1 7 1  
GaussianJ:ntegerQ, 326-328 
Gauss i anintegers , 305, 3 1 5, 3 1 9, 32 1 
Gaussi&Zllod, 326-328 
Gaussi&llorm, 326-328 
Gaussi&DPrim9Plot, 308 
Gaussi&DPrimeQ, 309-3 10, 326 
GCD, 9, 6 1 , 305-306, 3 1 9  
Genera 1 Sum2Squares, 285 
Get, 1 1  
Go ldenRatio, 3-4, 207 
BazmcaicRearrang.-.nt, 294-295 
Hold.Form, 60, 1 73-174 
I , 303 
Identi tyMatrix, 248-249, 344 
I f, 346 
Im, 299, 303, 307 
InputForm, 338 
IntegerDigi ts, 3 1 , 33 
IntegerExponent, 1 1 6 
Xnteger'l'oString, 149, 152 
ja cobi , 189 
ja cobi iter, 1 9 1  
Jacobi Symbo l ,  189, 250 
.A, 94-95 
Labels, 12, 15 
LCM, 9, 51 
Legendre¢, 1 35-1 36 
LegendrePi , 137 
LegeldrePiPUll, 137 
LegeldreSymbol, 185 
li, 103-104 
LinearCongruenceSolve, 45 
LinearDiophantineSolve, 43-44 
LinearRecurrence, 249, 255 
L i nearSolve, 45 

L i s tabl e ,  123 
L i s tPlot, 220, 297, 337 
Log, 36 
Log* , 95 
Logintegra l ,  103 
LogL i s t Plot, 77 
LogStar, 95 
Luca•A, 258 
Luca••, 257-258 
LucasBo th, 254-255 
Luca•Certificate, 260--261 
Luca•Par..-ter•, 265-266 
Luca•P•eudopr:LmeQ, 264-265, 269 
Luca•P•eudoprimesAllTypes, 270--271 
LucasPseudoprim9Test, 264, 270 
Luc-Rank, 258 
LucasUFast, 255 
LucasUMa t, 255 
LucasUPair, 254-255 
LucasVFas t, 255 
LucasVMa t, 255 
LucasVPseudoprill9Test, 271 
M2Circl e, 296 
M2SquareShel l , 295 
MJCubeShel l, 296--297 
MJ Sphere, 297 
Map, 3, 36, 34 1 
MatrixForm, 3, 230, 344 
MatrixPower, 3, 230 
llatrixPoweztlod, 34, 249 
Mei ssel Pi, 139 
MemberQ, 1 1 6  
llersenne, 62 
llersennePri.meQ, 264 
Me s s age, 173-174 
Me thodA, 269-270 
Me thodAStar, 269, 271 
llillerRabinPrimeQ, 1 18 
Mod, 7 
Modul e, 33 
Modulus , 45, 87, 197 
N, 6 1 , 237, 3 1 8  
Needs , 6 
Nest, 264, 342 
NestL i s t, 60, 95, 1 1 6, 342 
RextPr:Lme, 1 94, 244 
Ronresi4ue, 1 96, 280 
Nul l Space, 242-243 
NumberTheory ' Cont i nuedFractions ' 
package, 202 
MATHEMATICA I N DEX 
361 
Number°heory ' NumberTheoryFunctions ' 
package, 285-286, 307 
NumberTheory ' PrimeQ ' package, 1 32 
Numerator, 214 
OddQ, 120, 347 
Options, 315, 3 1 9, 336 
Or, 1 1 6  
Or4erl0d, 89 
Outer, 187 
", 52, 6 1 , 101, 103, 1 38 
ť. 67-68 
Pairwi•eCopr:lmeQ, 51 
Part i t i on, 241-243 
PascalTriangle, 29 
Pellsolutions, 231 
PellSolve, 231, 236 
Phi:l:nverse, 69 
Philultiplicity, 69-70, 72 
Plot, 36, 336 
PlotPo ints , 336 
Plus, 44 
Pol l ardpMinusl, 1 74-1 75 
Pol l ardRho, 173 
Pos i t i on, 78 
PowerAlgorithm, 3 1-32, 37 
PowerGri4, 56 
PowerMod, 33 
powennodLR, 1 90--191 
PrattCertificate, 122-124, 126, 1 30 
Pra t tCert i fi ca t eBasi c, 123, 1 30 
Prime, 52, 99, 1 34, 333 
PrimeAndCerti fi ca te, 129 
PrimePi, 1 0 1 , 334 
PrimeQ, 99, 1 0 1 , 305, 3 19, 333 
PrimeQWi thLucasProof, 260 
PrimeQWi thProof, 120, 122 
Primi t i veReps, 284, 287 
PrimitiveRoots, 85, 90 
Print, 345 
Produc t, 305 
Produc tLog, 348-349 
Protec t, 95 
Provabl ePrimeQ, 1 32 
PseudoprimeQ, 69, 271 
Pseudoprimesearch, 265-266 
PseudoprimeTable, 60 
PythagoreanTriples, 20 
QuadraticConjugate, 2 1 3-2 14, 250 
Qua4rat icllo4, 250 

362 
MATHE MA TICA INDEX 
Quadra ti cModul i ,  181 
Quac!raticNŦll'orm, 214 
Quac!raticPow.:icloc!, 250, 267 
QuadraticPseudoprimeQ, 265, 269 
QuadraticPseudoprime'l'est, 265, 270 
QuadraticResidueQ, 181, 185 
QuarticResidueŧl, 328 
Qui ckPrimeQ, 127 
Quo tient, 6, 22, 1 76 
r2 , 289 
Random, 9, 35 
RandcmPrime, 104-105, 147, 149, 1 83, 
281-282, 306 
Range, 335 
Rationa l i ze, 3 1 8  
Re, 303, 307 
RealDigi ts, 8±9 
ReducedaesiduesODly, 81 
Replace Part, 248-249 
Repuzait, 64 
Res t, 10 
Reverse, 344 
RhoTri a l s, 177 
RightSide, 2 3 1 
RootReduce, 2 14, 224 
RotateRight, 248-249 
Round, 209, 3 1 8  
RSADecode, 1 5 1  
llSABDcode, 1 50, 1 54 
a, 72 
a- , 72, 74-75 
Scan, 242-243 
S e l ect, 54-55, 59, 341 , 343 
SetAt tributes, 326 
Short, 78 
Show2s, 123-124, 1 26 
ShowCertificate, 127-128 
ShowData, 243-245 
Showl'rimitiveltots, 57 
S impl i fy, 24 
Sma l l SqrtsNegOn e, 284 
So lve, 45, 87, 1 97, 349 
Sort, 82, 344 
SpspSequence, 1 1 6 
Sqrt, 335 
SqrtFl oor, 1 70 
SqrtlfodAll, 197, 234 
SqrtModPrimeTone l l i ,  1 96-197 
SqrtNegOne, 280, 306 
SqrtSquareDi vi sors, 284 
sRKCorrect, 165 
SRKProtect, 1 65 
StandardForm, 338-339 
Stri ngForm, 1 20- 1 2 1 ,  260 
striDQ"l'c>Xnteger, 147, 149, 152 
StrongPseudoprimeData package, 1 1 5 
StrongPseudoprimeQ, 1 1 6-1 1 7  
StrongP•eudopriaes, 1 1 5, 275 
StrongQuadraticPseudoprimeQ, 275 
StZ'ODQ'QuadraticPseudoprime'l'est, 275 
Subtract, 1 87 
Sum, 334, 349 
Sum2Squares, 281 
SumOfSquaresR, 285-286 
SumOfSquaresRepresentations, 285, 307, 
328 
Table, 9-12, 335 
Take, 10 
Times, 5 1  
Timing, 9, 35 
ToCharacterCode, 147 
Together, 1 10 
ToSRKin teger, 1 66 
Towerlod, 96-97 
TraceXntervall'actor, 245 
Trad i t i onal Form, 14, 338 
Transpose, 242, 344 
Tree, 1 24, 126, 260-261 
Tri alDi vi de, 1 68 
TwoPseudoprimeP 59 
TwoPseudoprimeTes t, 59, 62 
Type, 265-266 
Unprotect, 95 
UpArrow, 95 
UseGric!Box, 274-275 
UVSequence, 274-275 
VisualPow.rGricl, 57, 81 
Whi l e, 22, 345-346 
z; , 82, 93 
$RecursionLimi t, 1 35 

Subject Index 
absolute value, 303 
absolutely convergent, 294 
abundant number, 76 
Adams, W., 355 
addition chain, 3 1  
Adleman, L., 1 3 1 ,  149, 1 76 
admissible animal, 3 1 5  
admissible pattern, 312 
Alford, W. R., 61, 355 
algorithm, 2 
aliquot cycle, 80 
aliquot sequence, 77 
problem, 77 
alternating harmonic series, 294 
American Chemical Society, 162 
amicable pair, 75 
Anderson, C. W., 78 
animal, 3 1 5  
Archimedes, 227, 232-233, 238 
sun god cattle problem, 232 
associate, 303 
asymptotic, 1 77 
Atkin, A. 0. L., 1 32 
average, 286 
b-sequence, 1 14 
b-strong pseudoprime, 1 14 
Bach, E., 355 
Bailey, D., 53 
Baillie, R., 64, 269, 271, 355 
Belgian house number problem, 232 
Bertrand, J. L. F., 1 10 
Bertrand's Postulate, 1 10, 1 12 
extension, 142 
big-0 notation, 34 
billiard balls, 232 
Binet's formula, 4 
binomial coefficient, 29 
birthday paradox, 1 71 
birthday trick, 301 
Bleichenbacher, D., 1 17, 128, 355 
Borwein, J., 355 
Borwein, P., 355 
Brauer, A., 356 
Brent, R. P. , 172, 175 
Brillhart, J., 121, 131, 175-176, 355 
Brizolis, D., 89 
Buhler, J. P., 302, 355 
Cabal, The, 176 
Carmichael, R. D., 69 
Carmichael number, 61, 97, 1 32 
Carmichael's conjecture, 69 
Carmichael's lambda, 93 
Catalan's equation, 41 
certificate of primality, 1 18, 120--121 
cyclotomy test, 131 
certified prime, 126 
CF, see continued fraction 
CFRAC, 245 
character, 325 
Chebyshev, P., 109-110 
Chebyshev's theorem, 109 
check digit, 158 
Chicken McNugget problem, 46 
Chinese Remainder Theorem, 49, 5 1  
Cipolla, M. 64 
Clark, F. W., 355 
coconut problem, 48 
Cohen, H., 1 18, 1 3 1 ,  355 
coin tossing, 146, 153 
complete reduced residue system, 82 
complete residue system, 56 
complex number, 302 
composite, 6 
conditionally convergent, 294 

364 
SUBJ ECT I NDEX 
conductor, 46 
congruent, 26, 325 
conjugate, 2 1 3, 303 
constellation, 314 
superdense, 3 1 5  
continuant, 1 0  
continuant reversal, 12 
continued fraction, 201 
convergent, 203 
existence and uniquenes, 208 
factoring with, 238 
period length, 220 
periodicity for quadratic irrational, 215 
purely periodic, 22 1 
Costa Pereira, N. , 109 
Crandall, R. E., 1 76, 302, 355 
Cunningham Project, 1 76 
Curry, C., 1 76 
cyclotomy test, 1 3 1  
Davenport, J. H., 129 
de la Vallee-Poussin, C.-J., 103 
deficient number, 76 
Deleglise, M., 137, 355 
Delord, J., 297 
dense, 25 
Descartes, R., 75, 79, 289 
Diffie, W., 149 
dihedral group of pentagon, 160 
Diophantus, 4 1  
direct product, 50 
Dirichlet's theorem, 1 12 
discriminant, 247, 329 
divide, 6, 303 
divisible, 6 
divisor, 6 
sum of, 72 
Dubner, H., 64 
Dubouis, E., 289 
Dunne, E., 355 
Eggleton, R. B., 356 
Eisenstein, F. G., 327, 331 
Eratosthenes, 105 
Erdos, P., 29, 108, 1 10 
Esmonde, J., 356 
Euclid, 6, 79 
Euclid number, 1 1 1  
Euclidean algorithm, 8 
Euler, L., 182, 329 
Euler phi function, 66 
Euler pseudoprime, 193 
Euler-Euclid formula, 74 
Euler's criterion, 180 
Euler's theorem, 82 
Everitt, W. N., 355 
extended Euclidian algorithm, 14 
extended integer, 17 
extended residue, 352 
factor base, 238 
factor method, 38 
fast powers, 33 
Fermat, P., 227, 280 
Fermat number, 63, 180 
Fermat's challenge, 227 
Fermat's factorization algorithm, 170 
Fermat's Little Theorem, 56 
for Gaussian integers, 327 
in quadratic field, 249 
Fibonacci number, 2 
Fibonacci pseudoprime, 264 
Fibonacci pseudoprime challenge, 273 
field, 303 
finite simple continued fraction, 202 
first category algorithm, 168 
Flath, D., 330, 356 
Ford, K., 69-70, 356 
Fundamental Theorem of Arithmetic, 16 
Gallian, J., 356 
Garcia, M., 80 
Gardner, M., 1 76 
Gauss, C. F., 86, 182, 191, 289, 327, 330 
Gauss's criterion, 186 
Gauss's formula, 321 
Gaussian integer, 303 
Gaussian moat problem, 308 
Gaussian prime, 304 
gcd, 7, 304-305 
Germain prime, 142 
German currency, 162 
Gethner, E., 308, 356 
Gilbreath's conjecture, 142 
GIMPS, 261 
Giuga's conjecture, 142 
Goldbach's conjecture, 142 
golden ratio, 3 
Goldwasser, S., 1 32 
good, 289 
googol, 34 
Gordon, D., 315, 322, 356 
Granville, A., 61, 355 
Great Internet Mersenne Prime Search, 261 
Grosswald, E., 356 
group, 50, 160 
Guy, R. K., 356 
Hadamard, J., 103 
Hajratwala, N., 261 
Hardy, G. H., 315, 356 
Heilbronn, H., 23 

Hellman, M., 149 
Hermite, C., 280 
Hilbert, D., 290 
Hilbert's tenth problem, 5 
Hodges, A., 356 
Holy Grail, 276 
homogeneous equation, 42 
Hudson, R. H., 356 
Hurwitz, A., 2 1 1  
IBM check digit scheme, 159 
industrial-grade prime, 1 18 
infinite simple continued fraction, 207 
integer of quadratic extension, 329 
integral domain, 304 
involution, 298 
ion, 291 
Ireland, K. , 356 
irrational, 18 
ISBN numbers, 165 
isomorphic, 50 
iterator, 334 
Jacobi symbol, 189-190 
Jones, J., 356 
Jordan, J. H., 308, 322, 356 
Julius Ceasar, 146 
Kahn, D. 356 
Kenjale, P. S., 162, 357 
Kilian, J., 1 32 
Klee, V., 356 
Knuth, D. E., 356 
Kraitchik, M., 169, 1 76, 238 
Kraitchik family, 169 
Kurtz, G. C., 356 
Lacampagne, C. B., 356 
Lagarias, J., 137 
Lagrange, J. L., 289 
Lagrange's theorem, 86 
Lame's theorem, 12 
lattice point, 300 
lcm, 7 
least universal exponent, 93 
Legendre, A.-M., 1 34, 182, 185 
Legendre sum, 134 
Legendre symbol, 185 
Lehmer, D. H., 63, 67, 121, 131, 1 37, 139, 
240, 355 
Lehmer, E., 30, 356 
Lenstra, A. K., 131, 169 
Lenstra, H. W., 131 
liO, 103 
Li, S., 129 
liar, 133 
Lichtblau, D., 54 
SUBJ ECT I N DEX 
365 
linear Diophantine equation, 42 
linear time, 34 
lions, 316, 3 1 7  
Littlejohn, L .  L . ,  355 
Littlewood, J. E., 1 12, 315 
Littlewood's theorem, 1 12 
log, , 71 
logarithmic integral, 103 
love potion, 76 
Lucas, E., 131, 247 
Lucas certification, 259 
Lucas pseudoprime, 251, 264 
Lucas pseudoprime challenges, 271 
Lucas sequences, 247, 254 
computing 254 
divisibility of, 252 
prime testing with, 259 
Lucas-Lehmer algorithm, 261 
LucasV pseudoprime, 266 
Machin's formula, 32 1 
Madelung constant, 293 
Manasse, M. S., 169 
Martin, G., 70 
Martin's number, 70 
Matijasevic, Y., 227, 357 
Maurer, U., 126, 1 3 1 ,  357 
McConnell, M., 355 
Meissel, E. D. F., 1 37-138 
Mersenne primes, 262 
Mertens, F., 108 
Mertens's theorem, 108 
method A, 269 
method A+ , 277 
method A' , 269 
method A'' , 269 
Miller, G., 137 
Miller-Rabin test, 1 1 8  
modular square root, 195 
modular towers, 95 
modulus, 26 
Monier, L., 64 
Monte Carlo method, 1 70 
Montgomery, H. L., 357 
Montgomery, P., 1 76 
Morris, S. 8., 357 
Morrison, M., 1 76 
multiplicative function, 67 
multiplicative inverse, 28 
Murty, M. R., 356 
n-animal, 315 
Newman, D. J., 70 
Niven, I., 357 
nondeterministic polynomial time, 125 

366 
SUBJ ECT INDEX 
nonresidue (quadratic), 180 
norm, 24, 303 
normal form, 2 1 3  
NP, 125 
0(), 35 
odd perfect number problem, 75 
odd unit fraction, 77 
Odlyzko, A., 137 
order, 84 
order-of-powers theorem, 85 
'P, 125 
Packel, E., 357 
Pascal's triangle, 29 
peasant multiplication, 39 
Pell's equation, 227 
pentagon, group of symmetries, 160 
?epin, J. F. T., 180 
Pepin's test, 183 
perfect number, 72 
odd, 75 
perfect shuffies, 39 
Perrin pseudoprime, 278 
Perrin's sequence, 278 
Perrin's test, 278 
phi function, 66 
Carmichael's conjecture, 69 
divisibility of n - 1 by efl(n}, 67 
Newman's theorem, 70 
efl-multiplicity, 69 
1r, formulas for, 320 
Pocklington, H. C., 126 
Pollard, J. M., 170 
Pollard p - 1 ,  170, 1 74 
Pollard rho, 170, 173 
polynomial time, 35, 1 1 7, 125 
Pomerance, C., 61, 1 17, 131, 176, 355, 357 
postage stamp problem, 25 
power grid, 56, 57 
power tower, 94 
Powers, R. E., 240 
powers of matrices, 34 
Pratt, V., 122, 125 
Pratt certificate, 123 
preperiod, 88 
primary representation, 330 
prime factorization, 6 
prime k-tuples conjecture, 314 
prime number, 6 
certification, 1 18, 120, 121, 259 
certified, 126 
cyclotomy test, 131 
finding the nth, 1 34 
industrial-grade, 1 18 
mysteries, 141 
Prime Number Theorem, 103 
Erdos-Selberg proof, 108 
primitive root, 57, 84, 330 
primitive sum, 283 
primitive triple, 18 
proper unit fraction, 79 
protolion, 323 
pseudoperfect number, 79 
pseudoperfect test, 271 
pseudoprime, 59 
b-strong, 1 14 
comparison of psp tests, 272-273 
Euler, 193 
Fibonacci, 264 
Fibonacci challenge, 273 
Lucas, 25 1 ,  264 
Lucas challenges, 271 
LucasV, 266 
Perrin, 278 
quadratic, 265, 267 
strong psp test, 1 1 5  
strong quadratic psp, 273 
symmetric Perrin, 278 
pseudoprime witness, 64 
PSW challenge, 271 
public key, 148 
pure function, 342 
Pythagorean triple, 18 
quadratic congruences, 194, 199 
quadratic irrational, 2 1 3  
periodicity of CF, 2 1 5  
purely periodic, 221 
quadratic pseudoprime, 265 
quadratic reciprocity, 182, 185 
quadratic residue, 180 
quartic residue, 325 
quartic residue symbol, 327 
quotient, 8 
Rabin, M., 300 
Rabung, J. R., 308, 322, 356 
Rajaraman, V., 162, 357 
Ramanujan, S., 329 
rank, 251 
rational, 18 
rational integer, 303 
rational point, 20 
rational prime, 303 
rectangular bulls, 233 
relatively prime, 7 
remainder, 8 
Renze, J., 3 1 6, 357 
repeating decimals, 87 
represent, 289 
repunit, 64 

residue class, 26 
Ribenboim, P., 357 
Riemann, B., 105 
Riemann hypothesis, 105 
extended, 11 7 
Riemann zeta function, 105 
Riesel, H., 357 
Rivat, J., 1 37, 355 
Rivest, R., 149, 1 76 
Robin, G., 1 34 
Robinson, J., 291 
Rodemich, G., 315, 322, 356 
Rosen, K. H., 357 
Rosen, M., 356 
Rosser, J. B., 1 34 
RSA encryption, 149 
Rubenstein, M., 1 12, 357 
Rumely, R., 1 3 1  
salt, 2 9 1  
Sarnak, P., 1 12, 357 
Sato, D., 356 
Schlafly, A., 70, 357 
Schneier, B., 357 
Schroeder, M., 357 
Schur's theorem, 47 
second category algorithm, 169 
Selberg, A., 108 
Selfridge, J., 1 17, 121, 1 3 1 ,  1 75, 269, 
355-357 
series rearrangement, 294 
Serret, J.-A., 280 
Sethi, A. S., 162, 357 
Shallit, J ., 300, 355 
Shamir, A., 149, 176 
Shanks, D., 355-356 
Shanks's algorithm, 200 
Sierpinski, W., 69 
Sierpinski's conjecture, 69 
sieve of Eratosthenes, 106 
sigma function, 72 
signature, digital, 1 5 1  
Skewes number, 1 1 2  
Smith, H. J. S . ,  280, 355 
Smith's algorithm, 282 
Solovay-Strassen algorithm, 193 
square root, modular, 1 95 
square triangular numbers, 231 
SRK scheme, 162 
Stark, H., 329, 356 
Stormer's formula, 32 1 
strong liar, 1 18, 132 
strong pseudoprime, 1 14 
strong pseudoprime test, 1 15 
sum of divisors, 72 
SUBJ ECT I NDEX 
367 
sums of squares, 285, 289 
sun god cattle problem, 232 
superdense constellation, 3 1 5  
Sylvester, J. J., 75 
symmetric Perrin pseudoprime, 278 
Szekeres, G., 29 
3-weight method, 159 
time 
linear, 34 
nondeterministic polynomial, 125 
polynomial, 35, 1 17, 125 
Tonelli's algorithm, 195 
trial division, 167 
Tuchman, B., 357 
Turing, A., 149, 356 
12-tone scale, 2 1 1  
twin prime conjecture, 142 
2-component, 3 1 1  
2-pseudoprime, 59 
U. S. Postal Service money orders, 158 
unit, 7, 303 
unit fraction, 79 
universal exponent, 93 
Vardi, I., 232-233, 238, 299, 3 1 6, 322, 357 
Verhoeff, J., 160 
Vorster, S. J. R., 355 
Wada, H., 356 
Wagon, S., 70, 308, 316, 355-357 
Wagstaff, S. S., Jr, 64, 1 1 7, 269, 271, 355, 
357 
Wallis, J., 149 
Waring's problem, 290 
Weiferich prime, 58 
Wick, B. , 308, 316, 356--357 
Wiens, D., 356 
Wiles, A., 41 
Wilf, H., 80, 357 
Williams, B. A., 48 
Williams, H. C., 220, 356--357 
Wilson's theorem, 49 
Winters, S., 356 
witness. 1 16, 1 1 9  
Wolfram, S . ,  357 
Wright, E. M., 356 
Wurm, J. F., 233 
Yao millionaire problem, 155 
Zagier, D., 298, 357 
Zimmermann telegram, 150 
Zuckerman, H. S., 357 

Printed and bound in the UK by 
CPI Antony Rowe, Eastbourne 

a 
a 
I 
2 
3 
4 
s 
6 
I 
2 
.\ 
4 
s 
6 
7 
8 
9 
JO 
I I  
1 2  
13 
14 
1 5  
1 6  
a 
I 
3 
7 
9 
I 
2 
3 
4 
5 
6 
I 
2 3 4 5 6 7 8 9 10 
a 
I 
2 
3 
4 
5 
6 
7 
8 
9 
10 
n = 7  
n 
= 1 1  
2 
3 
4 
5 
6 
7 
8 
9 
10 I I  1 2  1 3  1 4  1 5  1 6  
Color Plate I. Prime Power 
Grids. Three views of the 
power function ai modulo some 
primes (7, 1 1 , and 1 7). Red 
denotes + 1 ,  yellow denotes - 1, 
and the other shades denote the 
other values. Several patterns 
are visible, such as Fermat's 
Little Theorem (the red col-
umns at the right) and the 
criterion for quadratic residues 
(the red-yellow column in the 
middle). If a is a primitive root 
(all powers are distinct), then it 
is shown in red. 
n 
= 1 7  
2 
3 
4 
5 
6 
7 
8 
9 
I 2 3 4 5 6 7 8 9 10 I I  1 2  1 3  14 1 5  16 17 
a 
I 
I 
I 
s 
7 
I I  
1 3  
1 7  
• 
• 
• 
• 
I 
• 
I 
• 
.
.
.
 Ǌ . . . 
. 
•
•
•
•
 
n 
= 1 0 
n = 1 8  
I 
2 3 4 5 6 7 8 9 1 0  1 1  1 2  1 3  14 1 5  1 6  1 7  1 8  19 
a 
I 
3 
7 
9 
I I  
1 3  
1 7  
19 
I 
I 
I 
I 
• • • • • • • •  
n 
= 20 
I 
I 
I 
I 
• 
• 
Color Plate 2. Composite Power Grids. Views of the power function modulo 
some composites (10, 18, and 20). Only the resides coprime to n are shown. Euler's 
Theorem is visible in the periodicity that occurs at <f>(n) (which is 4, 6, and 8, respec­
tively). In the case of 20, the periodicity actually occurs at the 4th power, illustrating 
the phenomenon that the least universal exponent A(n) can be less than <f>(n). 

Color Plate 3. Three Gaussian Components. Three sets of Gaussian primes 
reachable from 1 + i. The yellow squares are the ones reachable using steps of size 
..f2 or less; the blue network consists of those reachable in steps bounded by 2; and 
the the red network corresponds to a step-bound of ../8. 


