x 
Intro
Your brain on Design Patterns.  Here you are trying to learn something, while 
here your brain is doing you a favor by making sure the learning doesn’t stick.  Your brain’s 
thinking, “Better leave room for more important things, like which wild animals to avoid and 
whether naked snowboarding is a bad idea.”  So how do you trick your brain into thinking 
that your life depends on knowing Design Patterns? 
Who is this book for? 
xxvi
We know what your brain is thinking 
xxvii
Metacognition 
xxix
Bend your brain into submission 
xxxi
Technical reviewers 
xxxiv
Acknowledgements 
xxxv
Table of Contents (summary)
          Intro 
xxv
1  
Welcome to Design Patterns:  an introduction 
1
2 
Keeping your Objects in the know:  the Observer Pattern 
37
3 
Decorating Objects:  the Decorator Pattern 
79
4 
Baking with OO goodness:  the Factory Pattern 
109
5 
One of a Kind Objects:  the Singleton Pattern 
169
6 
Encapsulating Invocation:  the Command Pattern 
191
7 
Being Adaptive:  the Adapter and Facade Patterns 
235
8 
Encapsulating Algorithms:  theTemplate Method Pattern 
275
9 
Well-managed Collections:  the Iterator and Composite Patterns 
315
10 
The State of Things:  the State Pattern 
385
11 
Controlling Object Access:  the Proxy Pattern 
429
12 
Patterns of Patterns: Compound Patterns 
499
13 
Patterns in the Real World: Better Living with Patterns 
577
14 
Appendix:  Leftover Patterns 
611
 
Table of Contents (the real thing)
table of contents

xi
1
Welcome to Design Patterns
Someone has already solved your problems. In this chapter, 
you’ll learn why (and how) you can exploit the wisdom and lessons learned by 
other developers who’ve been down the same design problem road and survived 
the trip. Before we’re done, we’ll look at the use and beneﬁts of design patterns, 
look at some key OO design principles, and walk through an example of how one 
pattern works. The best way to use patterns is to load your brain with them and 
then recognize places in your designs and existing applications where you can 
apply them. Instead of code reuse, with patterns you get experience reuse.
intro to Design Patterns
Your BRAIN
Your Code, now new 
and improved with 
design patterns!
A Bunch of Patterns
swim()
display()
performQuack()
performFly()
setFlyBehavior()
setQuackBehavior()
// OTHER duck-like methods...
Duck
FlyBehavior flyBehavior;
QuackBehavior quackBehavior;
<<interface>>
FlyBehavior
fly()
fly() {
  // implements duck flying
}
FlyWithWings
fly() {
  // do nothing - can’t fly!
}
FlyNoWay
<<interface>>
QuackBehavior
quack()
quack) {
  // implements duck quacking
}
Quack
quack() {
  // rubber duckie squeak
}
Squeak
quack() {
  // do nothing - can’t quack!
}
MuteQuack
display() {
// looks like a decoy duck }
Decoy Duck
display() {
// looks like a mallard }
Mallard Duck
display() {
// looks like a redhead }
Redhead Duck
display() {
// looks like a rubberduck }
Rubber Duck
Encapsulated ﬂy behavior
Encapsulated quack behavior
Client 
View
Controller
Model
Request
MVC
S
u
b
j
e
c
t
 
O
b
j
e
c
t
8
int
  
 
D
o
g
 
O
b
j
ect
M
o
u
s
e
 
O
b
j
ec
t
  
C
a
t
 
O
b
j
e
ct
  
D
u
c
k
 
O
b
j
e
c
t
Observers
8
8
8
8
Automatic update/notification
Object that 
holds state
Dependent Objects
OBSERVER
Remember, knowing 
concepts like abstraction, 
inheritance, and polymorphism do 
not make you a good object oriented 
designer.  A design guru thinks 
about how to create ﬂexible 
designs that are maintainable 
and that can cope with 
change.
The SimUDuck app 
 
 
 
 
2
Joe thinks about inheritance...  
 
 
 
5
How about an interface? 
 
 
 
 
6
The one constant in software development 
 
 
8
Separating what changes from what stays the same 
 
10
Designing the Duck Behaviors 
 
 
 
11
Testing the Duck code 
 
 
 
 
18
Setting behavior dynamically  
 
 
 
20
The Big Picture on encapsulated behaviors 
 
 
22
HAS-A can be better than IS-A 
 
 
 
23
The Strategy Pattern 
 
 
 
 
24
The power of a shared pattern vocabulary 
 
 
28
How do I use Design Patterns? 
 
 
 
29
Tools for your Design Toolbox 
 
 
 
32
Exercise Solutions  
 
 
 
 
34

xii 
The Weather Monitoring application   
 
 
39
Meet the Observer Pattern 
 
 
 
 
44
Publishers + Subscribers = Observer Pattern 
 
 
45
Five minute drama: a subject for observation 
 
 
48
The Observer Pattern defined 
 
 
 
51
The power of Loose Coupling 
 
 
 
53
Designing the Weather Station 
 
 
 
56
Implementing the Weather Station 
 
 
 
57
Using Java’s built-in Observer Pattern  
 
 
64
The dark side of java.util.Observable 
 
 
 
71
Tools for your Design Toolbox 
 
 
 
74
Exercise Solutions  
 
 
 
 
78
2
Keeping your Objects in the Know
Don’t miss out when something interesting happens! 
We’ve got a pattern that keeps your objects in the know when something they 
might care about happens.  Objects can even decide at runtime whether they 
want to be kept informed. The Observer Pattern is one of the most heavily used 
patterns in the JDK, and it’s incredibly useful. Before we’re done, we’ll also look 
at one to many relationships and loose coupling (yeah, that’s right, we said 
coupling). With Observer, you’ll be the life of the Patterns Party. 
the Observer Pattern
S
u
b
j
e
c
t
 
O
b
j
e
c
t
8
int
  
 
D
o
g
 
O
b
j
ect
M
o
u
s
e
 
O
b
j
ec
t
  
C
a
t
 
O
b
j
e
ct
  
D
u
c
k
 
O
b
j
e
c
t
Observers
8
8
8
8
ONE TO MANY RELATIONSHIP
Automatic update/notification
Object that 
holds state
Dependent Objects
Abstraction
Encapsulation
Polymorphism
Inheritence
OO Basics
Encapsulate what varies
Favor Composition over inheri-
tance
Program to Interfaces, not 
implementations
Strive for loosely coupled 
designs between objects that 
interact
OO Principles
table of contents

xiii
3
Decorating Objects
Just call this chapter “Design Eye for the Inheritance 
Guy.” We’ll re-examine the typical overuse of inheritance and you’ll learn how 
to decorate your classes at runtime using a form of object composition. Why? 
Once you know the techniques of decorating, you’ll be able to give your (or 
someone else’s) objects new responsibilities without making any code changes 
to the underlying classes.
the Decorator Pattern
I used to think real men 
subclassed everything. That was until 
I learned the power of extension 
at runtime, rather than at compile 
time.  Now look at me!
Welcome to Starbuzz Coffee  
 
 
 
80
The Open-Closed Principle  
 
 
 
86
Meet the Decorator Pattern  
 
 
 
88
Constructing a Drink Order with Decorators 
 
 
89
The Decorator Pattern Defined 
 
 
 
91
Decorating our Beverages 
 
 
 
 
92
Writing the Starbuzz code 
 
 
 
 
95
Real World Decorators: Java I/O 
 
 
 
100
Writing your own Java I/O Decorator  
 
 
102
Tools for your Design Toolbox 
 
 
 
105
Exercise Solutions  
 
 
 
 
106

xiv 
4
Baking with OO Goodness
Get ready to cook some loosely coupled OO designs. 
There is more to making objects than just using the new operator. You’ll learn 
that instantiation is an activity that shouldn’t always be done in public and can 
often lead to coupling problems.  And you don’t want that, do you? Find out how 
Factory Patterns can help save you from embarrasing dependencies.
the Factory Pattern
<<interface>>
Clams
<<interface>>
Cheese
<<interface>>
Sauce
<<interface>>
Dough
createPizza()
NYPizzaStore
ThinCrustDough
MarinaraSauce
ReggianoCheese
FrozenClams
ThickCrustDough
PlumTomatoSauce
Mozzarella Cheese
FreshClams
Each factory produces a different 
implementation for the family of products.
The abstract PizzaIngredientFactory 
is the interface that defines how to 
make a family of related products 
- everything we need to make a pizza.
The clients of the Abstract 
Factory are the two 
instances of our PizzaStore, 
NYPizzaStore and 
ChicagoStylePizzaSore. 
The job of the concrete 
pizza factories is to 
make pizza ingredients.  
Each factory knows 
how to create the right 
objects for their region.
createDough()
createSauce()
createCheese()
createVeggies()
createPepperoni()
createClam()
<<interface>>
PizzaIngredientFactory
createDough()
createSauce()
createCheese()
createVeggies()
createPepperoni()
createClam()
NYPizzaIngredientFactory
createDough()
createSauce()
createCheese()
createVeggies()
createPepperoni()
createClam()
ChicagoPizzaIngredientFactory
table of contents
When you see “new”, think “concrete”  
 
 
110
Objectville Pizza 
 
 
 
 
 
112
Encapsulating object creation  
 
 
 
114
Building a simple pizza factory 
 
 
 
115
The Simple Factory defined  
 
 
 
117
A Framework for the pizza store 
 
 
 
120
Allowing the subclasses to decide 
 
 
 
121
Let’s make a PizzaStore 
 
 
 
 
123
Declaring a factory method  
 
 
 
125
Meet the Factory Method Pattern 
 
 
 
131
Parallel class hierarchies 
 
 
 
 
132
Factory Method Pattern defined 
 
 
 
134
A very dependent PizzaStore  
 
 
 
137
Looking at object dependencies 
 
 
 
138
The Dependency Inversion Principle 
 
 
 
139
Meanwhile, back at the PizzaStore... 
 
 
 
144
Families of ingredients... 
 
 
 
 
145
Building our ingredient factories 
 
 
 
146
Looking at the Abstract Factory 
 
 
 
153
Behind the scenes  
 
 
 
 
154
Abstract Factory Pattern deﬁned 
 
 
 
156
Factory Method and Abstract Factory compared  
 
160
Tools for your Design Toolbox 
 
 
 
162
Exercise Solutions  
 
 
 
 
164

xv
5
One of a Kind Objects
The Singleton Pattern: your ticket to creating one-of-a-
kind objects, for which there is only one instance. You 
might be happy to know that of all patterns, the Singleton is the simplest in terms 
of its class diagram; in fact the diagram holds just a single class!  But don’t get 
too comfortable; despite its simplicity from a class design perspective, we’ll 
encounter quite a few bumps and potholes in its implementation.  So buckle 
up—this one’s not as simple as it seems...
the Singleton Pattern
Strategy - defines a family of algorithms, 
encapsulates each one, and makes them inter-
changeable.  Strategy lets the algorithm vary 
independently from clients that use it.
OO Patterns
Observer - defines a one-to-many 
dependency between objects so that 
when one object changes state, all its 
dependents are notified and updated 
automatically
Decorator - Attach additional 
responsibilities to an object dynami-
cally.  Decorators provide a flexible 
alternative to subclassing for extending 
functionality.
Abstract Factory - Provide an 
interface for creating families of 
related or depedent objects without 
specifying their concrete classes.
Factory Method  - Define an 
interface for creating an object, but 
let subclasses decide which class to in-
stantiate.  Factory Method lets a class 
defer instantiation to the subclasses.
Singleton - Ensure a class only has 
one instance and provide a global point 
of access to it.
One and only one object 
 
 
 
 
170
The Little Singleton 
 
 
 
 
171
Dissecting the classic Singleton Pattern  
 
 
173
Confessions of a Singleton 
 
 
 
 
174
The Chocolate Factory 
 
 
 
 
175
Singleton Pattern defined 
 
 
 
 
177
Houston, we have a problem... 
 
 
 
178
BE the JVM 
 
 
 
 
 
179
Dealing with multithreading  
 
 
 
180
Singleton Q&A 
 
 
 
 
 
184
Tools for your Design Toolbox 
 
 
 
186
Exercise Solutions  
 
 
 
 
188
Hershey, PA

xvi 
6
Encapsulating Invocation
In this chapter we take encapsulation to a whole new 
level: we’re going to encapsulate method invocation. 
That’s right, by encapsulating invocation we can crystallize pieces of computation 
so that the object invoking the computation doesn’t need to worry about how to do 
things; it just uses our crystallized method to get it done.  We can also do some 
wickedly smart things with these encapsulated method invocations, like save 
them away for logging or reuse them to implement undo in our code.  
the Command Pattern
I’ll have a Burger 
with Cheese and a Malt 
Shake
Burger with Cheese
  Malt Shake
createOrder()
takeOrder()
Burger with Cheese
  Malt Shake
orderUp()
makeBurger(), makeShake()
output
The Order consists of an order 
slip and the customer’s menu 
items that are written on it.
The customer knows 
what he wants and 
creates an order.
The Waitress takes the Order, and when she 
gets around to it, she calls its orderUp() 
method to begin the Order’s preparation.
The Order has all 
the instructions 
needed to prepare 
the meal.  The 
Order directs the 
Short Order Cook 
with methods like 
makeBurger().
The Short Order 
Cook follows the 
instructions of 
the Order and 
produces the meal.
Start Here
table of contents
Home Automation or Bust 
 
 
 
 
192
The Remote Control 
 
 
 
 
193
Taking a look at the vendor classes 
 
 
 
194
Meanwhile, back at the Diner...  
 
 
 
197
Let’s study the Diner interaction 
 
 
 
198
The Objectville Diner Roles and Responsibilities  
 
199
From the Diner to the Command Pattern 
 
 
201
Our first command object 
 
 
 
 
203
The Command Pattern defined 
 
 
 
206
The Command Pattern and the Remote Control  
 
208
Implementing the Remote Control 
 
 
 
210
Putting the Remote Control through its paces 
 
 
212
Time to write that documentation 
 
 
 
215
Using state to implement Undo 
 
 
 
220
Every remote needs a Party Mode! 
 
 
 
224
Using a Macro Command 
 
 
 
 
225
More uses of the Command Pattern: Queuing requests 
 
228
More uses of the Command Pattern: Logging requests 
 
229
Tools for your Design Toolbox 
 
 
 
230
Exercise Solutions  
 
 
 
 
232

xvii
7
Being Adaptive
In this chapter we’re going to attempt such impossible 
feats as putting a square peg in a round hole. Sound impossible? 
Not when we have Design Patterns.  Remember the Decorator Pattern?  We 
wrapped objects to give them new responsibilities. Now we’re going to wrap some 
objects with a different purpose: to make their interfaces look like something they’re 
not. Why would we do that?  So we can adapt a design expecting one interface to a 
class that implements a different interface. That’s not all, while we’re at it we’re going 
to look at another pattern that wraps objects to simplify their interface.
the Adapter and Facade Patterns
Adaptee
Client
Adapter
request()
translatedRequest()
The Client is implemented 
against the target interface
The Adapter implements the 
target interface and holds an 
instance of the Adaptee
target interface
adaptee 
interface
Turkey was the 
adaptee interface
European Wall Outlet
AC Power Adapter
Standard AC Plug
Adapters all around us 
 
 
 
 
236
Object Oriented Adapters 
 
 
 
 
237
The Adapter Pattern explained 
 
 
 
241
Adapter Pattern defined 
 
 
 
 
243
Object and Class Adapters 
 
 
 
 
244
Tonight’s talk:  The Object Adapter and Class Adapter  
 
247
Real World Adapters 
 
 
 
 
248
Adapting an Enumeration to an Iterator 
 
 
249
Tonight’s talk:  The Decorator Pattern and the Adapter Pattern  
252
Home Sweet Home Theater  
 
 
 
255
Lights, Camera, Facade!   
 
 
 
 
258
Constructing your Home Theater Facade 
 
 
261
Facade Pattern defined 
 
 
 
 
264
The Principle of Least Knowledge 
 
 
 
265
Tools for your Design Toolbox 
 
 
 
270
Exercise Solutions  
 
 
 
 
272

xviii 
8
Encapsulating Algorithms
We’ve encapsulated object creation, method invocation, 
complex interfaces, ducks, pizzas... what could be next?  
We’re going to get down to encapsulating pieces of algorithms so that subclasses can 
hook themselves right into a computation anytime they want.  We’re even going to 
learn about a design principle inspired by Hollywood.
the Template Method Pattern
table of contents
1
Boil some water
2
3
4
Steep the teabag in the water
Pour tea in a cup
Add lemon
1
Boil some water
2
3
4
Brew the coffee grinds
Pour coffee in a cup
Add sugar and milk
2
4
Steep the teabag in the water
Add lemon
Tea subclass
Coffee subclass
2
4
Brew the coffee grinds
Add sugar and milk
1
Boil some water
2
3
4
Brew
Pour beverage in a cup
Add condiments
Caffeine Beverage
Tea
Coffee
Caffeine Beverage knows 
and controls the steps of 
the recipe, and performs 
steps 1 and 3 itself, but 
relies on Tea or Coffee 
to do steps 2 and 4.
We’ve recognized 
that the two recipes 
are essentially the 
same, although 
some of the steps 
require different 
implementations.  So 
we’ve  generalized the 
recipe and placed it in 
the base class.
generalize
relies on 
subclass for 
some steps
generalize
relies on 
subclass for 
some steps
Whipping up some coffee and tea classes 
 
 
277
Abstracting Coffee and Tea  
 
 
 
280
Taking the design further 
 
 
 
 
281
Abstracting prepareRecipe()  
 
 
 
282
What have we done? 
 
 
 
 
285
Meet the Template Method  
 
 
 
286
Let’s make some tea 
 
 
 
 
287
What did the Template Method get us?  
 
 
288
Template Method Pattern defined 
 
 
 
289
Code up close 
 
 
 
 
 
290
Hooked on Template Method... 
 
 
 
292
Using the hook 
 
 
 
 
 
293
Coffee? Tea? Nah, let’s run the TestDrive 
 
 
294
The Hollywood Principle 
 
 
 
 
296
The Hollywood Principle and the Template Method 
 
297
Template Methods in the Wild 
 
 
 
299
Sorting with Template Method 
 
 
 
300
We’ve got some ducks to sort  
 
 
 
301
Comparing ducks and ducks  
 
 
 
302
The making of the sorting duck machine 
 
 
304
Swingin’ with Frames 
 
 
 
 
306
Applets  
 
 
 
 
 
307
Tonight’s talk:  Template Method and Strategy 
 
 
308
Tools for your Design Toolbox 
 
 
 
311
Exercise Solutions  
 
 
 
 
312

xix
9
Well-Managed Collections
There are lots of ways to stuff objects into a collection. 
Put them in an Array, a Stack, a List, a Map, take your pick. Each has its own 
advantages and tradeoffs.  But when your client wants to iterate over your objects, 
are you going to show him your implementation? We certainly hope not! That just 
wouldn’t be professional. Don’t worry—in this chapter you’ll see how you can let 
your clients iterate through your objects without ever seeing how you store your 
objects. You’re also going to learn how to create some super collections of objects 
that can leap over some impressive data structures in a single bound. You’re also 
going to learn a thing or two about object responsibility. 
the Iterator and Composite Patterns
P
a
n
c
a
k
e
H
ou
s
e
M
e
nu
 
 
D
i
n
e
r
M
e
nu
 
 
 
C
a
f
e
M
e
nu
1
2
3
 
 
 
M
e
n
u
I
t
e
m
 
 
 
 
M
e
n
u
I
t
em
 
 
 
M
e
n
u
I
t
e
m
 
 
 
 
M
e
n
u
I
t
em
1
2
3
4
Pancake Menu
 
 
 
M
e
n
u
I
t
e
m
 
 
 
 
M
e
n
u
I
t
em
 
 
 
M
e
n
u
I
t
e
m
 
 
 
 
M
e
n
u
I
t
em
Café Menu
 
 
 
 
 
 
  
 
 
k
e
y
 
 
 
 
 
 
  
 
 
k
e
y
 
 
 
 
 
 
  
 
 
k
e
y
 
 
 
 
 
 
  
 
 
k
e
y
 
 
 
M
e
n
u
I
t
e
m
 
 
 
 
M
e
n
u
I
t
em
 
 
 
M
e
n
u
I
t
e
m
 
 
 
 
M
e
n
u
I
t
em
1
2
3
4
Diner Menu
All Menus
 
 
 
M
e
n
u
I
t
e
m
 
 
 
 
M
e
n
u
I
t
em
 
 
 
M
e
n
u
I
t
e
m
 
 
 
 
M
e
n
u
I
t
em
1
2
3
4
Dessert Menu
Array
ArrayList
Objectville Diner and Pancake House merge 
 
 
316
Comparing Menu implementations 
 
 
 
318
Can we encapsulate the iteration? 
 
 
 
323
Meet the Iterator Pattern 
 
 
 
 
325
Adding an Iterator to DinerMenu 
 
 
 
326
Looking at the design 
 
 
 
 
331
Cleaning things up with java.util.Iterator 
 
 
333
What does this get us? 
 
 
 
 
335
Iterator Pattern defined 
 
 
 
 
336
Single Responsibility 
 
 
 
 
339
Iterators and Collections 
 
 
 
 
348
Iterators and Collections in Java 5 
 
 
 
349
Just when we thought it was safe... 
 
 
 
353
The Composite Pattern defined 
 
 
 
356
Designing Menus with Composite 
 
 
 
359
Implementing the Composite Menu 
 
 
 
362
Flashback to Iterator 
 
 
 
 
368
The Null Iterator  
 
 
 
 
372
The magic of Iterator & Composite together...  
 
 
374
Tools for your Design Toolbox 
 
 
 
380
Exercise Solutions  
 
 
 
 
381

xx 
10
The State of Things
A little known fact: the Strategy and State Patterns were 
twins separated at birth.  As you know, the Strategy Pattern went on 
to create a wildly successful business around interchangeable algorithms.  State, 
however, took the perhaps more noble path of helping objects learn to control their 
behavior by changing their internal state. He’s often overheard telling his object 
clients, “just repeat after me, I’m good enough, I’m smart enough, and doggonit...”
the State Pattern
Mighty Gumball, Inc.
Where the Gumball Machine 
is Never Half Empty
Here’s the way we think the gumball machine controller needs to 
work. We’re hoping you can implement this in Java for us!  We 
may be adding more behavior in the future, so you need to keep 
the design as flexible and maintainable as possible!
       - Mighty Gumball Engineers
Out of 
Gumballs
   Has 
Quarter
   No 
Quarter
Gumball 
  Sold
inserts quarter
ejects quarter
turns crank
dispense 
gumball
gumballs = 0
gumballs > 0
table of contents
How do we implement state?  
 
 
 
387
State Machines 101  
 
 
 
 
388
A ﬁrst attempt at a state machine 
 
 
 
390
You knew it was coming... a change request! 
 
 
394
The messy STATE of things... 
 
 
 
396
Defining the State interfaces and classes  
 
 
399
Implementing our State Classes 
 
 
 
401
Reworking the Gumball Machine 
 
 
 
402
The State Pattern defined 
 
 
 
 
410
State versus Strategy 
 
 
 
 
411
State sanity check  
 
 
 
 
417
We almost forgot!  
 
 
 
 
420
Tools for your Design Toolbox 
 
 
 
423
Exercise Solutions  
 
 
 
 
424

xxi
11
Controlling Object Access
Ever play good cop, bad cop? You’re the good cop and you provide 
all your services in a nice and friendly manner, but you don’t want everyone 
asking you for services, so you have the bad cop control access to you.  That’s 
what proxies do: control and manage access.  As you’re going to see there are 
lots of ways in which proxies stand in for the objects they proxy.  Proxies have 
been known to haul entire method calls over the Internet for their proxied objects; 
they’ve also been known to patiently stand in the place for some pretty lazy 
objects. 
the Proxy Pattern
Not
Hot
<<interface>>
Subject
request()
RealSubject
request()
Proxy
request()
<<interface>>
InvocationHandler
invoke()
InvocationHandler
The proxy now consists 
of two classes.
invoke()
Monitoring the gumball machines 
 
 
 
430
The role of the ‘remote proxy’ 
 
 
 
434
RMI detour 
 
 
 
 
 
437
GumballMachine remote proxy 
 
 
 
450
Remote proxy behind the scenes 
 
 
 
458
The Proxy Pattern defined 
 
 
 
 
460
Get Ready for virtual proxy  
 
 
 
462
Designing the CD cover virtual proxy  
 
 
464
Virtual proxy behind the scenes 
 
 
 
470
Using the Java API’s proxy 
 
 
 
 
474
Five minute drama: protecting subjects  
 
 
478
Creating a dynamic proxy  
 
 
 
 
479
The Proxy Zoo 
 
 
 
 
 
488
Tools for your Design Toolbox 
 
 
 
491
Exercise Solutions  
 
 
 
 
492

xxii 
12
Patterns of Patterns
Who would have ever guessed that Patterns could work 
together?  You’ve already witnessed the acrimonious Fireside Chats (and be 
thankful you didn’t have to see the Pattern Death Match pages that the publisher 
forced us to remove from the book so we could avoid having to use a Parent’s 
Advisory warning label), so who would have thought patterns can actually get along 
well together?  Believe it or not, some of the most powerful OO designs use several 
patterns together.  Get ready to take your pattern skills to the next level;  it’s time for 
Compound Patterns. Just be careful—your co-workers might kill you if you’re struck 
with Pattern Fever.
Compound Patterns
B
e
a
t
M
o
d
e
l
Controller
setBPM()
getBPM()
on()
off()
You click on 
the increase 
beat button.
The controller asks 
the model to update 
its BPM by one.
View is notified that the BPM 
changed.  It calls getBPM() on 
the model state.
Because the BPM is 120, the view gets 
a beat notification every 1/2 second.
The beat is set at 119 BPM and you 
would like to increase it to 120.
Which results in the 
controller being invoked.
The view is updated 
to 120 BPM.
You see the beatbar 
pulse every 1/2 second.
View
View
table of contents
Compound Patterns 
 
 
 
 
500
Duck reunion 
 
 
 
 
 
501
Adding an adapter  
 
 
 
 
504
Adding a decorator  
 
 
 
 
506
Adding a factory 
 
 
 
 
 
508
Adding a composite, and iterator 
 
 
 
513
Adding an observer  
 
 
 
 
516
Patterns summary  
 
 
 
 
523
A duck’s eye view: the class diagram 
 
 
 
524
Model-View-Controller, the song 
 
 
 
526
Design Patterns are your key to the MVC 
 
 
528
Looking at MVC through patterns-colored glasses 
 
532
Using MVC to control the beat... 
 
 
 
534
The Model 
 
 
 
 
 
537
The View  
 
 
 
 
 
539
The Controller 
 
 
 
 
 
542
Exploring strategy  
 
 
 
 
545
Adapting the model 
 
 
 
 
546
Now we’re ready for a HeartController  
 
 
547
MVC and the Web  
 
 
 
 
549
Design Patterns and Model 2  
 
 
 
557
Tools for your Design Toolbox 
 
 
 
560
Exercise Solutions  
 
 
 
 
561

xxiii
13
Patterns in the Real World
Ahhhh, now you’re ready for a bright new world filled with 
Design Patterns. But, before you go opening all those new doors of opportunity 
we need to cover a few details that you’ll encounter out in the real world—things get a 
little more complex out there than they are here in Objectville.  Come along, we’ve got 
a nice guide to help you through the transition...
Better Living with Patterns
Erich Gamma
John Vlissides
Richard Helm
Ralph 
Johnson
Your Objectville guide 
 
 
 
578
Design Pattern defined 
 
 
 
579
Looking more closely at the Design Pattern definition 
581
May the force be with you 
 
 
 
582
Pattern catalogs 
 
 
 
 
583
How to create patterns 
 
 
 
586
So you wanna be a Design Patterns writer? 
 
587
Organizing Design Patterns  
 
 
589
Thinking in patterns 
 
 
 
594
Your mind on patterns 
 
 
 
597
Don’t forget the power of the shared vocabulary  
599
Top ﬁve ways to share your vocabulary  
 
600
Cruisin’ Objectville with the Gang of Four 
 
601
Your journey has just begun...  
 
 
602
Other Design Pattern resources 
 
 
603
The Patterns Zoo  
 
 
 
604
Annihilating evil with Anti-Patterns 
 
 
606
Tools for your Design Toolbox 
 
 
608
Leaving Objectville... 
 
 
 
609
Gang of Four
The Objectville Guide to 
    Better Living with Design Patterns
Please accept our handy guide of tips & tricks for living with patterns in the real 
world. In this guide you will:
b  Learn the all too common misconceptions about the deﬁnition of a 
“Design Pattern.”
b  Discover those nifty Design Pattern Catalogs and why you just have to 
get one.
b  Avoid the embarrassment of using a Design Pattern at the wrong time.
b  Learn how to keep patterns in classiﬁcations where they belong.
b  See that discovering patterns isn’t just for the gurus; read our quick 
HowTo and become a patterns writer too.
b  Be there when the true identify of the mysterious Gang of Four is revealed.
b  Keep up with the neighbors – the coffee table books any patterns user 
must own.
b  Learn to train your Design Patterns mind like a Zen master.
b  Win friends and inﬂuence developers by improving your patterns 
vocabulary.

xxiv 
14
Appendix: Leftover Patterns
Not everyone can be the most popular. A lot has changed in 
the last 10 years. Since Design Patterns: Elements of Reusable Object-Oriented 
Software ﬁrst came out, developers have applied these patterns thousands of times. 
The patterns we summarize in this appendix are full-ﬂedged, card-carrying, ofﬁcial 
GoF patterns, but aren’t always used as often as the patterns we’ve explored so 
far. But these patterns are awesome in their own right, and if your situation calls for 
them, you should apply them with your head held high. Our goal in this appendix is 
to give you a high level idea of what these patterns are all about. 
i
Index
 
631 
MenuItem
Menu
Ingredient
MenuItem
Ingredient
Visitor
  Client / 
Traverser
getState()
getState()
getState()
getState()
getState()
getHealthRating()
getCalories()
getProtein()
getCarbs()
All these composite 
classes have to do is add 
a getState() method 
(and not worry about 
exposing themselves  : ).
The Client asks the 
Visitor to get in-
formation from the 
Composite structure... 
New methods can be 
added to the Visitor 
without affecting the 
Composite.
The Visitor needs to be able to call 
getState() across classes, and this is 
where you can add new methods for 
the client to use.
The Traverser knows how to 
guide the Visitor through 
the Composite structure.
Bridge 
 
 
 
612
Builder  
 
 
614
Chain of Responsibility 
 
616
Flyweight  
 
 
618
Interpreter 
 
 
620
Mediator  
 
 
622
Memento  
 
 
624
Prototype  
 
 
626
Visitor 
 
 
 
628
table of contents




















































































































this is a new chapter
79
Just call this chapter “Design Eye for the Inheritance Guy.” 
We’ll re-examine the typical overuse of inheritance and you’ll learn how to decorate 
your classes at runtime using a form of object composition. Why? Once you know the 
techniques of decorating, you’ll be able to give your (or someone else’s) objects new 
responsibilities without making any code changes to the underlying classes.
Decorating Objects          
3  the DecoratorPattern
I used to think real men 
subclassed everything.  That was 
until I learned the power of 
extension at runtime, rather than 
at compile time.  Now look at me!
g
h
g

80 
Chapter 3
Starbuzz Coffee has made a name for itself as the 
fastest growing coffee shop around.  If you’ve seen one 
on your local corner, look across the street; you’ll see 
another one.
Because they’ve grown so quickly, they’re scrambling 
to update their ordering systems to match their 
beverage offerings.  
When they ﬁrst went into business they designed their 
classes like this...
Welcome to Starbuzz Coffee
Beverage is an abstract class, 
subclassed by all beverages 
offered in the coffee shop.
Each subclass implements cost() to return the cost of the beverage.
cost()
Espresso
cost()
Decaf
cost()
DarkRoast
cost()
HouseBlend
Beverage
description
getDescription()
cost()
// Other useful methods...
The description instance variable 
is set in each subclass and holds a 
description of the beverage, like 
“Most Excellent Dark Roast”. 
The getDescription() method 
returns the description.
The cost() method is 
abstract; subclassses 
need to define their 
own implementation.
the starbuzz story

the decorator pattern
you are here 4
81
Beverage
description
getDescription()
cost()
// Other useful methods...
In addition to your coffee, you can also ask for several condiments like 
steamed milk, soy, and mocha (otherwise known as chocolate), and have 
it all topped off with whipped milk.  Starbuzz charges a bit for each of 
these, so they really need to get them built into their order system. 
 Here’s their ﬁrst attempt...
cost()
HouseBlendWithSteamedMilk
andCaramel
cost()
HouseBlendWithMocha
cost()
HouseBlendWithWhipandMocha
cost()
HouseBlendWithSteamedMilk
andSoy
cost()
HouseBlendWithSteamedMilk
cost()
HouseBlendWithSteamedMilk
andMocha
cost()
HouseBlendWithSoy
cost()
HouseBlendWithWhip
cost()
HouseBlendWithSteamedMilk
andWhip
cost()
HouseBlendWithSoyandMocha
cost()
HouseBlendWithWhipandSoy
cost()
DarkRoastWithSteamedMilk
andCaramel
cost()
DarkRoastWithMocha
cost()
DarkRoastWithWhipandMocha
cost()
DarkRoastWithSteamedMilk
andSoy
cost()
DarkRoastWithSteamedMilk
cost()
DarkRoastWithSteamedMilk
andMocha
cost()
DarkRoastWithSoy
cost()
DarkRoastWithWhip
cost()
DarkRoastWithSteamedMilk
andWhip
cost()
DarkRoastWithSoyandMocha
cost()
DarkRoastWithWhipandSoy
cost()
DecafWithSteamedMilk
andCaramel
cost()
DecafWithMocha
cost()
DecafWithWhipandMocha
cost()
DecafWithSteamedMilk
andSoy
cost()
DecafWithSteamedMilk
cost()
DecafWithSteamedMilk
andMocha
cost()
DecafWithSoy
cost()
DecafWithWhip
cost()
DecafWithSteamedMilk
andWhip
cost()
DecafWithSoyandMocha
cost()
DecafWithWhipandSoy
cost()
DarkRoastWithSoy
cost()
EspressoWithSteamedMilk
andCaramel
cost()
EspressoWithMocha
cost()
EspressoWithWhipandMocha
cost()
EspressoWithSteamedMilk
andSoy
cost()
EspressoWithSteamedMilk
cost()
EspressoWithSteamedMilk
andMocha
cost()
DecafWithSoy
cost()
EspressoWhip
cost()
EspressoWithSteamedMilk
andWhip
cost()
DecafWithSoyandMocha
cost()
EspressoWithWhipandSoy
Each cost method computes the 
cost of the coffee along with the 
other condiments in the order.
Whoa!  
Can you say 
“class explosion?”

82 
Chapter 3
Well, let’s give it a try.  Let’s start with the Beverage base 
class and add instance variables to represent whether or 
not each beverage has milk, soy, mocha and whip...
It’s pretty obvious that Starbuzz has created a maintenance nightmare for 
themselves.  What happens when the price of milk goes up?  What do they do 
when they add a new caramel topping?  
Thinking beyond the maintenance problem, which of the design principles that 
we’ve covered so far are they violating?
brain
power
A
Hint: they’re violating two of them in a big way!
This is stupid; why do we need 
all these classes?  Can’t we just use 
instance variables and inheritance in 
the superclass to keep track of the 
condiments?
Beverage
description
milk
soy
mocha
whip
getDescription()
cost()
hasMilk()
setMilk()
hasSoy()
setSoy()
hasMocha()
setMocha()
hasWhip()
setWhip()
// Other useful methods..
These get and set the boolean 
values for the condiments.
New boolean values for 
each condiment.
Now we’ll implement cost() in Beverage (instead of 
keeping it abstract), so that it can calculate the 
costs associated with the condiments for a particular 
beverage instance. Subclasses will still override 
cost(), but they will also invoke the super version so 
that they can calculate the total cost of the basic 
beverage plus the costs of the added condiments.
violating design principles

the decorator pattern
you are here 4
83
cost()
Espresso
cost()
Decaf
cost()
DarkRoast
cost()
HouseBlend
Now let’s add in the subclasses, one 
for each beverage on the menu:
Write the cost() methods for the following classes (pseudo-Java is okay):
Each cost() method needs to compute 
the cost of the beverage and then 
add in the condiments by calling the 
superclass implementation of cost().
public class Beverage {
    public double cost() {
    }
}
public class DarkRoast extends Beverage {
    public DarkRoast() {
        description = “Most Excellent Dark Roast”;
    }
    public double cost() {
    }
}
Beverage
description
milk
soy
mocha
whip
getDescription()
cost()
hasMilk()
setMilk()
hasSoy()
setSoy()
hasMocha()
setMocha()
hasWhip()
setWhip()
// Other useful methods..
The superclass cost() will calculate the 
costs for all of the condiments, while 
the overridden cost() in the subclasses 
will extend that functionality to 
include costs for that specific 
beverage type.
Sharpen your pencil

84 
Chapter 3
See, ﬁve 
classes total. This is 
deﬁnitely the way to go.
I’m not so sure; I can 
see some potential problems 
with this approach by thinking 
about how the design might need 
to change in the future.
What requirements or other factors might change that will impact this design?
Price changes for condiments will force us to alter existing code.
New condiments will force us to add new methods and alter the cost method in the superclass.
We may have new beverages.  For some of these beverages (iced tea?), the condiments 
may not be appropriate, yet the Tea subclass will still inherit methods like hasWhip().
What if a customer wants a double mocha?
Sharpen your pencil
Your turn:
As we saw in 
Chapter 1, this is 
a very bad idea!
impact of change

the decorator pattern
you are here 4
85
Master and Student...
Master: Grasshopper, it has been some time since our last 
meeting.  Have you been deep in meditation on inheritance?
Student: Yes, Master.  While inheritance is powerful, I have 
learned that it doesn’t always lead to the most ﬂexible or 
maintainable designs. 
Master: Ah yes, you have made some progress.  So, tell me my student, how 
then will you achieve reuse if not through inheritance?
Student: Master, I have learned there are ways of “inheriting” behavior at 
runtime through composition and delegation. 
Master: Please, go on...
Student: When I inherit behavior by subclassing, that behavior is set statically 
at compile time.  In addition, all subclasses must inherit the same behavior.  If 
however, I can extend an object’s behavior through composition, then I can do 
this dynamically at runtime.
Master:  Very good, Grasshopper, you are beginning to see the power of 
composition.
Student: Yes, it is possible for me to add multiple new responsibilities to objects 
through this technique, including responsibilities that were not even thought of 
by the designer of the superclass. And, I don’t have to touch their code!
Master: What have you learned about the effect of composition on maintaining 
your code?
Student: Well, that is what I was getting at. By dynamically composing objects, 
I can add new functionality by writing new code rather than altering existing 
code.  Because I’m not changing existing code, the chances of introducing bugs 
or causing unintended side effects in pre-existing code are much reduced.
Master: Very good. Enough for today, Grasshopper.  I would like for you to 
go and meditate further on this topic...  Remember, code should be closed (to 
change) like the lotus ﬂower in the evening, yet open (to extension) like the 
lotus ﬂower in the morning.

86 
Chapter 3
The Open-Closed Principle
Design Principle
Classes should be open 
for extension, but closed for 
modiﬁcation.
Come on in; we’re 
open. Feel free to extend 
our classes with any new behavior you 
like.  If your needs or requirements change (and we 
know they will), just go ahead and make your own 
extensions. 
Sorry, we’re closed.  
That’s right, we spent 
a lot of time getting this code correct and 
bug free, so we can’t let you alter the existing code.  
It must remain closed to modiﬁcation. If you don’t 
like it, you can speak to the manager.
Grasshopper is on to one of the most important design principles:
Our goal is to allow classes to be easily extended to 
incorporate new behavior without modifying existing code.  
What do we get if we accomplish this?  Designs that are 
resilient to change and ﬂexible enough to take on new 
functionality to meet changing requirements.
the open-closed principle

the decorator pattern
you are here 4
87
Q: Open for extension and closed 
for modiﬁcation?  That sounds very 
contradictory.  How can a design be 
both?
A: That’s a very good question.  It 
certainly sounds contradictory at first.  
After all, the less modifiable something 
is, the harder it is to extend, right?
As it turns out, though, there are some 
clever OO techniques for allowing 
systems to be extended, even if we can’t 
change the underlying code.  Think 
about the Observer Pattern (in Chapter 
2)... by adding new Observers, we can 
extend the Subject at any time, without 
adding code to the Subject. You’ll see 
quite a few more ways of extending 
behavior with other OO design 
techniques.
Q: Okay, I understand Observable, 
but how do I generally design 
something to be extensible, yet closed 
for modiﬁcation?
A: Many of the patterns give us 
time tested designs that protect your 
code from being modified by supplying 
a means of extension.  In this chapter 
you’ll see a good example of using the 
Decorator pattern to follow the Open-
Closed principle.
Q: How can I make every part of 
my design follow the Open-Closed 
Principle? 
A: Usually, you can’t.  Making OO 
design flexible and open to extension 
without the modification of existing 
code takes time and effort.  In general, 
we don’t have the luxury of tying 
down every part of our designs (and it 
would probably be wastefu).  Following 
the Open-Closed Principle usually 
introduces new levels of abstraction, 
which adds complexity to our code.  
You want to concentrate on those areas 
that are most likely to change in your 
designs and apply the principles there.  
Q: How do I know which areas of 
change are more important?
A: That is partly a matter of 
experience in designing OO systems and 
also a matter of the knowing the domain 
you are working in.  Looking at other 
examples will help you learn to identify 
areas of change in your own designs.
While it may seem like a contradiction, 
there are techniques for allowing code to be 
extended without direct modif ication.
Be careful when choosing the areas of code 
that need to be extended; applying the 
Open-Closed Principle EVERYWHERE 
is wasteful, unnecessary, and can lead to 
complex, hard to understand code.
there are no
Dumb Questions

88 
Chapter 3
Meet the Decorator Pattern
Okay, enough of the “Object 
Oriented Design Club.” We have real  
problems here!  Remember us?  Starbuzz 
Coffee?  Do you think you could use 
some of those design principles to 
actually help  us?
Okay, we’ve seen that representing our beverage plus condiment pricing 
scheme with inheritance has not worked out very well – we get class 
explosions, rigid designs, or we add functionality to the base class that isn’t 
appropriate for some of the subclasses.
So, here’s what we’ll do instead: we’ll start with a beverage and “decorate” 
it with the condiments  at runtime.  For example, if the customer wants a 
Dark Roast with Mocha and Whip, then we’ll:
1
2
Take a DarkRoast object
Decorate it with a Mocha object
3
Decorate it with a Whip object
4
Call the cost() method and rely on 
delegation to add on the condiment costs
Okay, but how do you “decorate” an object, and how does delegation 
come into this?  A hint: think of decorator objects as “wrappers.”  Let’s 
see how this works...
meet the decorator pattern

the decorator pattern
you are here 4
89
Remember that DarkRoast 
inherits from Beverage and has 
a cost() method that computes 
the cost of the drink.
 
 
 
D
a
r
k
R
o
a
s
t
cost()
  
   
 
M
oc
h
a
cost()
  
W
h
i
p
cost()
  
   
 
M
oc
h
a
cost()
1
2
We start with our DarkRoast object.
The customer wants Mocha, so we create a Mocha 
object and wrap it around the DarkRoast.
3
The customer also wants Whip, so we create a 
Whip decorator and wrap Mocha with it.
The Mocha object is a decorator.  Its 
type mirrors the object it is decorating, 
in this case, a Beverage. (By “mirror”, 
we mean it is the same type..)
So, Mocha has a cost() method too, 
and through polymorphism we can treat 
any Beverage wrapped in Mocha as 
a Beverage, too (because Mocha is a 
subtype of Beverage).
Whip is a decorator, so it also 
mirrors DarkRoast’s type and 
includes a cost() method.
Constructing a drink order with Decorators
So, a DarkRoast wrapped in Mocha and Whip is still 
a Beverage and we can do anything with it we can do 
with a  DarkRoast, including call its cost() method.
 
 
 
D
a
r
k
R
o
a
s
t
cost()
 
 
 
D
a
r
k
R
o
a
s
t
cost()

90 
Chapter 3
First, we call cost() on the 
outmost decorator, Whip.
  
W
h
i
p
  
   
 
M
oc
h
a
  
 
D
a
r
k
R
o
a
st
Now it’s time to compute the cost for the customer.  We do this 
by calling cost() on the outermost decorator, Whip, and Whip is 
going to delegate computing the cost to the objects it decorates.  
Once it gets a cost, it will add on the cost of the Whip.
Whip calls cost() on Mocha.
Mocha adds its cost, 20 
cents, to the result from 
DarkRoast, and returns 
the new total, $1.19.
4
.99
.20
.10
$1.29
Whip adds its total, 10 cents, 
to the result from Mocha, and 
returns the ﬁnal result—$1.29.
1
2
5
5
Okay, here’s what we know so far...
ß 
Decorators have the same supertype as the objects they decorate.
ß 
You can use one or more decorators to wrap an object.
ß 
Given that the decorator has the same supertype as the object it decorates, we can pass 
around a decorated object in place of the original (wrapped) object.
ß 
The decorator adds its own behavior either before and/or after delegating to the object it 
decorates to do the rest of the job.
ß 
Objects can be decorated at any time, so we can decorate objects dynamically at runtime 
with as many decorators as we like.
Now let’s see how this all really works by looking at the 
Decorator Pattern definition and writing some code.
3
Mocha calls cost() on 
DarkRoast.
DarkRoast 
returns its cost, 
99 cents.
4
(You’ll see how in 
a few pages.)
Key Point!
decorator characteristics
cost()
cost()
cost()

the decorator pattern
you are here 4
91
The Decorator Pattern attaches additional 
responsibilities to an object dynamically.  
Decorators provide a ﬂexible alternative to 
subclassing for extending functionality.
The Decorator Pattern defined
Decorators implement the 
same interface or abstract 
class as the component they 
are going to decorate.
methodA()
methodB()
// other methods
ConcreteComponent
component
methodA()
methodB()
// other methods
Component
methodA()
methodB()
// other methods
Decorator
The ConcreteDecorator has an 
instance variable for the thing 
it decorates (the Component 
the Decorator wraps).
Decorators can add new methods; however, new 
behavior is typically added by doing computation 
before or after an existing method in the component.
Each decorator HAS-A  
(wraps) a component, which 
means the decorator has an 
instance variable that holds 
a reference to a component.
The ConcreteComponent  
is the object we’re going 
to dynamically add new 
behavior to. It extends 
Component.
Let’s ﬁrst take a look at the Decorator Pattern description:
While that describes the role of the Decorator Pattern, it doesn’t give us a lot 
of insight into how we’d apply the pattern to our own implementation. Let’s 
take a look at the class diagram, which is a little more revealing (on the next 
page we’ll look at the same structure applied to the beverage problem).
Each component can be used on its 
own, or wrapped by a decorator.
Decorators can extend the 
state of the component.
ConcereteDecoratorB
methodA()
methodB()
// other methods
Component wrappedObj
Object newState
ConcereteDecoratorA
methodA()
methodB()
newBehavior()
// other methods
Component wrappedObj

92 
Chapter 3
Decorating our Beverages
Okay, let’s work our Starbuzz beverages into this framework...
getDescription()
CondimentDecorator
getDescription()
cost()
// other useful methods
Beverage
description
Beverage beverage
cost()
getDescription()
Milk
cost()
HouseBlend
component
cost()
DarkRoast
cost()
Decaf
cost()
Espresso
Beverage beverage
cost()
getDescription()
Soy
Beverage beverage
cost()
getDescription()
Mocha
Beverage beverage
cost()
getDescription()
Whip
The four concrete 
components, one per 
coffee type.
And here are our condiment decorators; notice 
they need to implement not only cost() but also 
getDescription(). We’ll see why in a moment...
Beverage acts as our 
abstract component class.
Before going further, think about how you’d implement the cost() method of 
the coffees and the condiments.  Also think about how you’d implement the 
getDescription() method of the condiments.
brain
power
A
decorating beverages

the decorator pattern
you are here 4
93
Cubicle Conversation
Some confusion over Inheritance versus Composition
Mary
Sue:  What do you mean?
Mary: Look at the class diagram.  The CondimentDecorator is extending the Beverage class.  
That’s inheritance, right?
Sue:  True.  I think the point is that it’s vital that the decorators have the same type as the 
objects they are going to decorate.  So here we’re using inheritance to achieve the type matching, 
but we aren’t using inheritance to get behavior.
Mary:  Okay, I can see how decorators need the same “interface” as the components they wrap 
because they need to stand in place of the component.  But where does the behavior come in?
Sue:  When we compose a decorator with a component, we are adding new behavior.  We 
are acquiring new behavior not by inheriting it from a superclass, but by composing objects 
together.
Mary:  Okay, so we’re subclassing the abstract class Beverage in order to have the correct type, 
not to inherit its behavior. The behavior comes in through the composition of decorators with 
the base components as well as other decorators.
Sue:  That’s right.
Mary:  Ooooh, I see. And because we are using object composition, we get a whole lot more 
ﬂexibility about how to mix and match condiments and beverages.  Very smooth.
Sue:  Yes, if we rely on inheritance, then our behavior can only be determined statically at 
compile time.  In other words, we get only whatever behavior the superclass gives us or that we 
override. With composition, we can mix and match decorators any way we like... at runtime.
Mary:  And as I understand it,  we can implement new decorators at any time to add new 
behavior.  If we relied on inheritance, we’d have to go in and change existing code any time we 
wanted new behavior.
Sue:  Exactly.
Mary:  I just have one more question.  If all we need to inherit is the type of the component, 
how come we didn’t use an interface instead of an abstract class for the Beverage class?
Sue:  Well, remember, when we got this code, Starbuzz already had an abstract Beverage class.  
Traditionally the Decorator Pattern does specify an abstract component, but in Java, obviously, 
we could use an interface. But we always try to avoid altering existing code, so don’t “ﬁx” it if 
the abstract class will work just ﬁne.
Okay, I’m a little 
confused...I thought we weren’t 
going to use inheritance in this 
pattern, but rather we were going 
to rely on composition instead.

94 
Chapter 3
Okay, I need for you to 
make me a double mocha, 
soy latte with whip. 
New barista training
First, we call cost() on the 
outmost decorator, Whip.
  
W
h
i
p
cost()
  
   
 
M
oc
h
a
  
 
D
a
r
k
R
o
a
st
cost()
cost()
Whip calls cost() on Mocha.
Mocha adds its cost, 20 
cents, to the result from 
DarkRoast, and returns 
the new total, $1.19.
.99
.20
.10
$1.29
Whip adds its total, 10 cents, 
to the result from Mocha, and 
returns the ﬁnal result—$1.29.
1
2
5
5
3
DarkRoast 
returns its cost, 
99 cents.
4
Mocha calls cost() on 
DarkRoast.
Sharpen your pencil
Make a picture for what happens when the order is for a 
“double mocha soy lotte with whip” beverage. Use the menu 
to get the correct prices, and draw your picture using the 
same format we used earlier (from a few pages back):
Starbuzz Coffee
Coffees
House Blend   
Dark Roast 
Decaf         
Espresso
Condiments
Steamed Milk
Mocha
Soy
Whip
 .89
 .99
1.05
1.99
 .10
 .20
 .15
 .10
Draw your picture here.
This picture was for 
a “dark roast mocha 
whip” beverage. 
decorator training
S
t
a
r
b
u
z
z
 
C
o
f
f
e
e
 
S
t
a
r
b
u
z
z
 
C
o
f
f
e
e
HINT: you can make a “double 
mocha soy latte with whip” 
by combining HouseBlend, Soy, 
two shots of Mocha and Whip! 

the decorator pattern
you are here 4
95
Writing the Starbuzz code
It’s time to whip this design into some real code.  
Let’s start with the Beverage class, which doesn’t need to 
change from Starbuzz’s original design.  Let’s take a look:
public abstract class Beverage {
    String description = “Unknown Beverage”;
  
    public String getDescription() {
        return description;
    }
 
    public abstract double cost();
}
public abstract class CondimentDecorator extends Beverage {
    public abstract String getDescription();
}
Beverage is simple enough.  Let’s implement the abstract 
class for the Condiments (Decorator) as well:
Beverage is an abstract 
class with the two methods 
getDescription() and cost().
getDescription is already 
implemented for us, but we 
need to implement cost() 
in the subclasses.
First, we need to be 
interchangeable with a Beverage, 
so we extend the Beverage class.
We’re also going to require 
that the condiment 
decorators all reimplement the 
getDescription() method.  Again, 
we’ll see why in a sec...

96 
Chapter 3
Coding beverages
public class Espresso extends Beverage {
  
    public Espresso() {
        description = “Espresso”;
    }
  
    public double cost() {
        return 1.99;
    }
}
Starbuzz Coffee
Coffees
House Blend   
Dark Roast 
Decaf         
Espresso
Condiments
Steamed Milk
Mocha
Soy
Whip
 .89
 .99
1.05
1.99
 .10
 .20
 .15
 .10
public class HouseBlend extends Beverage {
    public HouseBlend() {
        description = “House Blend Coffee”;
    }
 
    public double cost() {
        return .89;
    }
}
Now that we’ve got our base classes out of the way, let’s 
implement some beverages.  We’ll start with Espresso.  
Remember, we need to set a description for the speciﬁc 
beverage and also implement the cost() method.
First we extend the Beverage 
class, since this is a beverage.
To take care of the description, we 
set this in the constructor for the 
class.  Remember the description instance 
variable is inherited from Beverage.
Finally, we need to compute the cost of an Espresso.  We don’t 
need to worry about adding in condiments in this class, we just 
need to return the price of an Espresso: $1.99.
Okay, here’s another Beverage.  All we 
do is set the appropriate description, 
“House Blend Coffee,” and then return 
the correct cost: 89¢.
You can create the other two Beverage classses 
(DarkRoast and Decaf) in exactly the same way.
implementing the beverages

the decorator pattern
you are here 4
97
Coding condiments
public class Mocha extends CondimentDecorator {
    Beverage beverage;
 
    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }
 
    public String getDescription() {
        return beverage.getDescription() + “, Mocha”;
    }
 
    public double cost() {
        return .20 + beverage.cost();
    }
}
If you look back at the Decorator Pattern class diagram, you’ll 
see we’ve now written our abstract component (Beverage), we 
have our concrete components (HouseBlend), and we have our 
abstract decorator (CondimentDecorator).  Now it’s time to 
implement the concrete decorators.  Here’s Mocha:
Mocha is a decorator, so we 
extend CondimentDecorator.
We’re going to instantiate Mocha with 
a reference to a Beverage using:
   (1)  An instance variable to hold the 
beverage we are wrapping.
   (2)  A way to set this instance 
variable to the object we are wrapping.  
Here, we’re going to pass the beverage 
we’re wrapping to the decorator’s 
constructor.
Now we need to compute the cost of our beverage 
with Mocha.  First, we delegate the call to the 
object we’re decorating, so that it can compute the 
cost; then, we add the cost of Mocha to the result.
We want our description to not only 
include the beverage - say “Dark 
Roast” - but also to include each 
item decorating the beverage, for 
instance, “Dark Roast,  Mocha”.  So 
we first delegate to the object we are 
decorating to get its description, then 
append “, Mocha” to that description.
On the next page we’ll actually instantiate the beverage and 
wrap it with all its condiments (decorators), but first...
Remember, CondimentDecorator 
extends Beverage.
Sharpen your pencil
Write and compile the code for the other Soy and Whip 
condiments. You’ll need them to finish and test the application.

98 
Chapter 3
public class StarbuzzCoffee {
 
    public static void main(String args[]) {
        Beverage beverage = new Espresso();
        System.out.println(beverage.getDescription() 
                + “ $” + beverage.cost());
 
        Beverage beverage2 = new DarkRoast();
        beverage2 = new Mocha(beverage2);
        beverage2 = new Mocha(beverage2);
        beverage2 = new Whip(beverage2);
        System.out.println(beverage2.getDescription() 
                + “ $” + beverage2.cost());
 
        Beverage beverage3 = new HouseBlend();
        beverage3 = new Soy(beverage3);
        beverage3 = new Mocha(beverage3);
        beverage3 = new Whip(beverage3);
        System.out.println(beverage3.getDescription() 
                + “ $” + beverage3.cost());
    }
}
Serving some coffees
File  Edit   Window  Help  CloudsInMyCoffee
% java StarbuzzCoffee
Espresso $1.99
Dark Roast Coffee, Mocha, Mocha, Whip $1.49
House Blend Coffee, Soy, Mocha, Whip $1.34
%
Congratulations.  It’s time to sit back, order a few coffees and marvel at 
the ﬂexible design you created with the Decorator Pattern.
Here’s some test code to make orders:
Order up an espresso, no condiments 
and print its description and cost.
Make a DarkRoast object.
Finally, give us a HouseBlend 
with Soy, Mocha, and Whip.
Now, let’s get those orders in:
We’re going to see a much better way of 
creating decorated objects when we cover the 
Factory and Builder Design Patterns.
File  Edit   Window  Help  CloudsInMyCoffee
Wrap it with a Mocha.
Wrap it in a second Mocha.
Wrap it in a Whip.
testing the beverages

the decorator pattern
you are here 4
99
Our friends at Starbuzz have introduced sizes to their menu.  You can now order 
a coffee in tall, grande, and venti sizes (translation: small, medium, and large).  
Starbuzz saw this as an intrinsic part of the coffee class, so they’ve added two 
methods to the Beverage class: setSize() and getSize().  They’d also like for the 
condiments to be charged according to size, so for instance, Soy costs 10¢, 15¢ 
and 20¢ respectively for tall, grande, and venti coffees.
How would you alter the decorator classes to handle this change in requirements?
Q: I’m a little worried about code 
that might test for a specfic concrete 
component – say, HouseBlend – and 
do something, like issue a discount.  
Once I’ve wrapped the HouseBlend 
with decorators, this isn’t going to work 
anymore.
A: That is exactly right.  If you have 
code that relies on the concrete component’s 
type, decorators will break that code.  
As long as you only write code against 
the abstract component type, the use of 
decorators will remain transparent to your 
code.  However, once you start writing code 
against concrete components, you’ll want to 
rethink your application design and your use 
of decorators.
Q: Wouldn’t it be easy for some 
client of a beverage to end up with 
a decorator that isn’t the outermost 
decorator?  Like if I had a DarkRoast with 
Mocha, Soy, and Whip, it would be easy 
to write code that somehow ended up 
with a reference to Soy instead of Whip, 
which means it would not including Whip 
in the order.
A: You could certainly argue that 
you have to manage more objects with 
the Decorator Pattern and so there is 
an increased chance that coding errors 
will introduce the kinds of problems you 
suggest. However, decorators are typically 
created by using other patterns like Factory 
and Builder.  Once we’ve covered these 
patterns, you’ll see that the creation of the 
concrete component with its decorator is 
“well encapsulated” and doesn’t lead to 
these kinds of problems.
Q: Can decorators know about the 
other decorations in the chain?  Say, I 
wanted my getDecription() method to 
print “Whip, Double Mocha” instead of 
“Mocha, Whip, Mocha”?  That would 
require that my outermost decorator 
know all the decorators it is wrapping.
A: Decorators are meant to add 
behavior to the object they wrap.  When 
you need to peek at multiple layers into 
the decorator chain, you are starting to 
push the decorator beyond its true intent.  
Nevertheless, such things are possible.  
Imagine a CondimentPrettyPrint decorator 
that parses the final decription and can print 
“Mocha,  Whip, Mocha” as “Whip, Double 
Mocha.”  Note that getDecription() could 
return an ArrayList of descriptions to make 
this easier.
there are no
Dumb Questions
Sharpen your pencil

100 
Chapter 3
Real World Decorators: Java I/O
The large number of classes in the java.io package is... overwhelming. Don’t feel alone 
if you said “whoa” the ﬁrst (and second and third) time you looked at this API. But 
now that you know the Decorator Pattern, the I/O classes should make more sense 
since the java.io package is largely based on Decorator.  Here’s a typical set of 
objects that use decorators to add functionality to reading data from a ﬁle:
Li
n
e
N
u
m
b
e
r
In
pu
t
S
t
re
a
m
B
u
f
f
e
r
e
d
I
n
pu
t
S
t
re
a
m
Fi
le
In
pu
t
S
t
r
e
a
m
FileInputStream is the component that’s 
being decorated. The Java I/O library 
supplies several components, including 
FileInputStream, StringBufferInputStream, 
ByteArrayInputStream and a few others.  
All of these give us a base component from 
which to read bytes.
BufferedInputStream 
is a concrete decorator.  
BufferedInputStream adds 
behavior in two ways: it 
buffers input to improve 
performance, and also augments 
the interface with a new 
method readLine() for reading 
character-based input, a line 
at a time.
LineNumberInputStream is 
also a concrete decorator.  
It adds the ability to 
count the line numbers as 
it reads data.
A text file for reading.
BufferedInputStream and LineNumberInputStream both extend 
FilterInputStream, which acts as the abstract decorator class. 
decorators in java i/o

the decorator pattern
you are here 4
101
FileInputStream
ByteArrayInputStream
FilterInputStream
StringBufferInputStream
InputStream
LineNumberInputStream
DataInputStream
BufferedInputStream
PushbackInputStream
Here’s our abstract component.
FilterInputStream 
is an abstract 
decorator.
These InputStreams act as 
the concrete components that 
we will wrap with decorators.  
There are a few more we didn’t 
show, like ObjectInputStream.
And finally, here are all our concrete decorators.
You can see that this isn’t so different from the Starbuzz design. You should 
now be in a good position to look over the java.io API docs and compose 
decorators on the various input streams. 
You’ll see that the output streams have the same design. And you’ve probably 
already found that the Reader/Writer streams (for character-based data) 
closely mirror the design of the streams classes (with a few differences and 
inconsistencies, but close enough to ﬁgure out what’s going on).
Java I/O also points out one of the downsides of the Decorator Pattern: 
designs using this pattern often result in a large number of small classes 
that can be overwhelming to a developer trying to use the Decorator-based 
API.  But now that you know how Decorator works, you can keep things in 
perspective and when you’re using someone else’s Decorator-heavy API, you 
can work through how their classes are organized so that you can easily use 
wrapping to get the behavior you’re after.  
Decorating the java.io classes

102 
Chapter 3
Writing your own Java I/O Decorator
Okay, you know the Decorator Pattern, you’ve 
seen the I/O class diagram. You should be ready to 
write your own input decorator.
No problem.  I just have to 
extend the FilterInputStream class 
and override the read() methods.
public class LowerCaseInputStream extends FilterInputStream {
    public LowerCaseInputStream(InputStream in) {
        super(in);
    }
 
    public int read() throws IOException {
        int c = super.read();
        return (c == -1 ? c : Character.toLowerCase((char)c));
    }
        
    public int read(byte[] b, int offset, int len) throws IOException {
        int result = super.read(b, offset, len);
        for (int i = offset; i < offset+result; i++) {
            b[i] = (byte)Character.toLowerCase((char)b[i]);
        }
        return result;
    }
}
How about this: write a decorator that converts 
all uppercase characters to lowercase in the 
input stream.  In other words, if we read in “I 
know the Decorator Pattern therefore I RULE!” 
then your decorator converts this to “i know the 
decorator pattern therefore i rule!” 
First, extend the FilterInputStream, the 
abstract decorator for all InputStreams.
Now we need to implement two 
read methods. They take a 
byte (or an array of bytes) 
and convert each byte (that 
represents a character) to 
lowercase if it’s an uppercase 
character.
Don’t forget to import 
java.io... (not shown)
write your own i/o decorator
REMEMBER: we don’t provide import and package 
statements in the code listings. Get the complete 
source code from the wickedlysmart web site.  You’ll 
find the URL on page xxxiii in the Intro.

the decorator pattern
you are here 4
103
public class InputTest {
    public static void main(String[] args) throws IOException {
        int c;
        try {
            InputStream in = 
                new LowerCaseInputStream(
                    new BufferedInputStream(
                        new FileInputStream(“test.txt”)));
            while((c = in.read()) >= 0) {
                System.out.print((char)c);
            }
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
Write some quick code to test the I/O decorator:
% java InputTest
i know the decorator pattern therefore i rule!
%
File  Edit   Window  Help  DecoratorsRule
Give it a spin:
Set up the FileInputStream 
and decorate it, first with 
a BufferedInputStream 
and then our brand new 
LowerCaseInputStream filter.
Just use the stream to read 
characters until the end of 
file and print as we go.
I know the Decorator Pattern therefore I RULE!
test.txt ﬁle
Test out your new Java I/O Decorator
You need to 
make this file.

104 
Chapter 3
HeadFirst:  Welcome Decorator Pattern.  We’ve heard that you’ve been a bit 
down on yourself lately?
Decorator: Yes, I know the world sees me as the glamorous design pattern, but 
you know, I’ve got my share of problems just like everyone. 
HeadFirst: Can you perhaps share some of your troubles with us?
Decorator: Sure.  Well, you know I’ve got the power to add ﬂexibility to 
designs, that much is for sure, but I also have a dark side. You see, I can sometimes 
add a lot of small classes to a design and this occasionally results in a design 
that’s less than straightforward for others to understand.
HeadFirst: Can you give us an example?
Decorator: Take the Java I/O libraries.  These are notoriously difﬁcult for 
people to understand at ﬁrst. But if they just saw the classes as a set of wrappers 
around an InputStream, life would be much easier.
HeadFirst: That doesn’t sound so bad.  You’re still a great pattern, and 
improving this is just a matter of public education, right?
Decorator: There’s more, I’m afraid.  I’ve got typing problems:  you see, 
people sometimes take a piece of client code that relies on speciﬁc types and 
introduce decorators without thinking through everything. Now, one great thing 
about me is that you can usually insert decorators transparently and 
the client never has to know it’s dealing with a decorator.  But like I 
said, some code is dependent on speciﬁc types and when you start introducing 
decorators, boom!  Bad things happen.
HeadFirst: Well, I think everyone understands that you have to be careful 
when inserting decorators, I don’t think this is a reason to be too down on 
yourself.
Decorator: I know, I try not to be.  I also have the problem that introducing 
decorators can increase the complexity of the code needed to instantiate the 
component.  Once you’ve got decorators, you’ve got to not only instantiate the 
component, but also wrap it with who knows how many decorators.
HeadFirst: I’ll be interviewing the Factory and Builder patterns next week – I 
hear they can be very helpful with this?
Decorator: That’s true; I should talk to those guys more often.
HeadFirst: Well, we all think you’re a great pattern for creating ﬂexible designs 
and staying true to the Open-Closed Principle, so keep your chin up and think 
positively!
Decorator: I’ll do my best, thank you.
This week’s interview:
Confessions of a Decorator
Patterns Exposed
decorator interview

the decorator pattern
you are here 4
105
Tools for your Design Toolbox
 BULLET POINTS
ß 
Inheritance is one form of 
extension, but not necessarily 
the best way to achieve flexibility 
in our designs.
ß 
In our designs we should allow 
behavior to be extended without 
the need to modify existing code.
ß 
Composition and delegation 
can often be used to add new 
behaviors at runtime.
ß 
The Decorator Pattern provides 
an alternative to subclassing for 
extending behavior.
ß 
The Decorator Pattern involves 
a set of decorator classes that 
are used to wrap concrete 
components.
ß 
Decorator classes mirror the 
type of the components they 
decorate. (In fact, they are the 
same type as the components 
they decorate, either through 
inheritance or interface 
implementation.)
ß 
Decorators change the behavior 
of their components by adding 
new functionality  before and/or 
after (or even in place of) method 
calls to the component.
ß 
You can wrap a component with 
any number of decorators.
ß 
Decorators are typically 
transparent to the client of the 
component; that is, unless 
the client is relying on the 
component’s concrete type.
ß 
Decorators can result in many 
small objects in our design, and 
overuse can be complex.
Abstraction
Encapsulation
Polymorphism
Inheritance
OO Basics
Encapsulate what varies.
Favor composition over inheritance.
Program to interfaces, not 
implementations.
Strive for loosely coupled designs 
between objects that interact.
Classes should be open for 
extension but closed for 
modification.
OO Principles
Strategy - defines a family of algorithms, 
encapsulates each one, and makes them 
interchangeable.  Strategy lets the algorithm 
vary independently from clients that use it.
OO Patterns
You’ve got another chapter under 
your belt and a new principle and 
pattern in the toolbox.
Observer - defines a one-to-many 
dependency between objects so that 
when one object changes state, all its 
dependents are notified and updated 
automatically
We now have the Open-Closed 
Principle to guide us.  We’re going 
to strive to design our system 
so that the closed parts are 
isolated from our new extensions.
And here’s our first pattern for creating designs 
that satisfy the Open-Closed Principle.  Or was it 
really the first?  Is there another pattern we’ve 
used that follows this principle as well?
Decorator - Attach additional 
responsibilities to an object dynamically.  
Decorators provide a flexible 
alternative to subclassing for extending 
functionality.

106 
Chapter 3
Exercise solutions
public class Beverage {
   // declare instance variables for milkCost,
  //  soyCost, mochaCost, and whipCost, and 
   // getters and setters for milk, soy, mocha
   // and whip.  
public ﬂoat cost() {
        ﬂoat condimentCost = 0.0;
        if (hasMilk()) {
            condimentCost += milkCost;
        }
        if (hasSoy()) {
            condimentCost += soyCost;
        }
        if (hasMocha()) {
            condimentCost += mochaCost;
        }
        if (hasWhip()) {
            condimentCost += whipCost;
        }
        return condimentCost;
    }
}
public class DarkRoast extends Beverage {
    public DarkRoast() {
        description = “Most Excellent Dark Roast”;
    }
    public ﬂoat cost() {
        return 1.99 + super.cost();
    }
}
S
t
a
r
b
u
z
z
 
C
o
f
f
e
e
 
  
   
 
M
oc
h
a
  
 
H
o
u
s
e
B
l
end
  
   
 
M
oc
h
a
  
  
So
y
  
W
h
i
p
cost()
cost()
cost()
cost()
cost()
.89
.15
.20
.20
.10
$1.54
First, we call cost() on the 
outmost decorator, Whip.
Whip calls cost() on Mocha
Last topping! Soy calls 
cost() on HouseBlend.
Finally, the result returns to 
Whip’s cost(), which adds .10 and 
we have a ﬁnal cost of $1.54.
1
2
5
11
3
Mocha calls cost() on another Mocha.
4
Next, Mocha calls cost() on Soy.
New barista training
“double mocha soy lotte with whip” 
HouseBlend’s cost() 
method returns .89 
cents and pops off 
the stack.
6
Soy’s cost() method 
adds .15 and returns 
the result, and pops 
off the stack.
7
The second Mocha’s 
cost() method adds .20 
and returns the result, 
and pops off the stack.
8
The ﬁrst Mocha’s cost() method 
adds .20 and returns the result, 
and pops off the stack.
9
exercise solutions

the decorator pattern
you are here 4
107
Our friends at Starbuzz have introduced sizes to their menu.  You can now order a coffee in 
tall, grande, and venti sizes (for us normal folk: small, medium, and large).  Starbuzz saw this 
as an intrinsic part of the coffee class, so they’ve added two methods to the Beverage class: 
setSize() and getSize().  They’d also like for the condiments to be charged according to size, so 
for instance, Soy costs 10¢, 15¢, and 20¢ respectively for tall, grande, and venti coffees.
How would you alter the decorator classes to handle this change in requirements?
Exercise solutions
public class Soy extends CondimentDecorator {
    Beverage beverage;
 
    public Soy(Beverage beverage) {
        this.beverage = beverage;
    }
    public getSize() {
 
 return beverage.getSize();
    }
 
    public String getDescription() {
        return beverage.getDescription() + “, Soy”;
    }
 
    public double cost() {
 
 double cost = beverage.cost();
 
 if (getSize() == Beverage.TALL) {
           cost += .10;
 
 } else if (getSize() == Beverage.GRANDE) {
 
    cost += .15;
 
 }  else if (getSize() == Beverage.VENTI) {
 
    cost += .20;
 
 } 
 
 return cost;
    }
}
Now we need to propagate the 
getSize() method to the wrapped 
beverage.  We should also move this 
method to the abstract class since 
it’s used in all condiment decorators.
Here we get the size (which 
propagates all the way to the 
concrete beverage) and then 
add the appropriate cost.





















































































































































































































































































































































































































































































































































