
Android’s Architecture Components
by Mark L. Murphy

Android’s Architecture Components
by Mark L. Murphy
Copyright © 2017-2018 CommonsWare, LLC. All Rights Reserved.
Printed in the United States of America.
Printing History:
January 2018:
Version 0.7
The CommonsWare name and logo, “Busy Coder's Guide”, and related trade dress are trademarks of CommonsWare,
LLC.
All other trademarks referenced in this book are trademarks of their respective frms.
The publisher and author(s) assume no responsibility for errors or omissions or for damages resulting from the use of the
information contained herein.

Table of Contents
Headings formatted in bold-italic have changed since the last version.
• Preface
◦How the Book Is Structured ....................................................... v
◦Prerequisites .......................................................................................... vi
◦About the Updates ................................................................................ vi
◦What’s New in Version 0.8? ........................................................ vi
◦Warescription ........................................................................... vii
◦Book Bug Bounty ............................................................................... viii
◦Source Code and Its License ................................................................ ix
◦Creative Commons and the Four-to-Free (42F) Guarantee ....... ix
◦Acknowledgments ................................................................................. x
• Room Basics
◦Wrenching Relations Into Objects ....................................................... 1
◦Room Requirements ................................................................... 2
◦Room Furnishings .................................................................................. 3
◦Get a Room ............................................................................................ 9
• Testing Room
◦Writing Instrumentation Tests ............................................................ 11
◦Writing Unit Tests via Mocks ..................................................... 15
• The Dao of Entities
◦Configuring Entities ............................................................................ 21
◦DAOs and Queries ................................................................................ 31
◦Other DAO Operations ............................................................. 38
◦Transactions and Room ....................................................................... 41
◦Threads and Room .............................................................................. 43
• Room and Custom Types
◦Type Converters ........................................................................ 46
◦Embedded Types .................................................................................. 53
◦Updating the Trip Sample ................................................................... 56
• Room and Relations
◦The Classic ORM Approach ................................................................ 61
◦A History of Threading Mistakes ........................................................ 62
◦The Room Approach ........................................................................... 63
◦Plans for Trips ..................................................................................... 64
◦Self-Referential Relations for Tree Structures ................................... 72
◦Using @Relation .................................................................................. 74
i

◦@Relation and @Query ....................................................................... 76
◦Representing No Relation ................................................................... 77
• Room and Migrations
◦What’s a Migration? ............................................................................ 79
◦When Do We Migrate? ....................................................................... 80
◦But First, a Word About the Support Database Classes .................. 80
◦…And a Word About Exporting Schemas .......................................... 81
◦Writing Migrations ............................................................................. 84
◦Employing Migrations ........................................................................ 89
◦How Room Applies Migrations ........................................................... 91
◦Testing Migrations ................................................................... 91
◦Migrating Under Protest .................................................................... 96
• Securing Your Room
◦Meet the Players .................................................................................. 97
◦Using CWAC-SafeRoom ..................................................................... 98
◦More to Come! ................................................................................... 100
• Lifecycles and Owners
◦A Tale of Terminology ....................................................................... 103
◦Adding the Lifecycle Components ........................................... 104
◦Getting a Lifecycle ............................................................................. 105
◦Observing a Lifecycle ........................................................................ 107
◦Legacy Options ....................................................................... 109
◦So, What’s the Point of This? ............................................................. 112
• LiveData
◦Observables Are the New Black ........................................................ 113
◦Yet More Terminology ........................................................................ 114
◦Implementing LiveData .......................................................... 115
◦Other LiveData Examples .................................................................. 121
◦Testing LiveData ................................................................................. 123
• ViewModel
◦ViewModels, As Originally Envisioned ............................................. 125
◦ViewModel Versus… .......................................................................... 126
◦Dependencies ........................................................................... 127
◦Mommy, Where Do ViewModels Come From? ................................ 127
◦ViewModels, Google’s Way ............................................................... 128
◦ViewModels as Simple POJOs ........................................................... 132
• Other Lifecycle Owners
◦ProcessLifecycleOwner ............................................................ 135
◦LifecycleService .................................................................................. 139
◦Wait… Where Is LifecycleProvider and LifecycleReceiver? ............ 140
• M:N Relations in Room
ii

◦Implementing a Join Entity ................................................................ 143
◦Implementing DAO Methods ........................................................... 147
◦Where’s That Good Ol’ Object Feel? ................................................ 149
• LiveData Transformations
◦The Bucket Brigade ............................................................................ 151
◦Mapping Data to Data ........................................................................ 152
◦Mapping Data to… LiveData? ............................................................ 154
◦Writing a Transformation .................................................................. 155
◦Do We Really Want This? ................................................................. 156
• RxJava and Room
◦Adding RxJava .......................................................................... 159
◦A Quick Sidebar on Rx Testing ......................................................... 160
◦Rx Query Response Types ................................................................. 162
◦Applying This to Your UI .................................................................. 167
• RxJava and Lifecycles
◦The Classic Approach ........................................................................ 169
◦Bridging RxJava and LiveData ................................................ 170
◦The Uber Solution: AutoDispose ....................................................... 172
◦The Semi-Deprecated Solution: RxLifecycle .................................... 173
• ViewModels and Data Binding
◦Binding From LiveData ...................................................................... 175
◦The Saved Instance State Situation .................................................. 180
• Packing Up a Room
◦The Problem ....................................................................................... 185
◦The Classic Solution: SQLiteAssetHelper ........................................ 186
◦The New Problem .............................................................................. 187
◦Merging SQLiteAssetHelper with Room .......................................... 187
• Paging Room Data
◦The Problem: Too Much Data ............................................................ 191
◦Addressing the UX ............................................................................. 192
◦Enter the Paging Library ................................................................... 192
◦Paging and Room ..................................................................... 194
• Paging Beyond Room
◦Writing Your Own DataSource ............................................... 205
◦LivePagedListBuilder and Custom DataSources ..................... 214
◦PagedList.Builder .................................................................... 216
• Immutability
◦The Benefits of Immutability ............................................................. 221
◦The Costs of Immutability ................................................................ 223
◦Immutability via AutoValue ................................................... 226
• The Repository Pattern
iii

◦What the Repository Does ................................................................. 231
◦High-Level Repository Strategies ..................................................... 234
◦Let’s Roll the Dice .............................................................................. 236
• Introducing Model-View-Intent
◦GUI Architectures ............................................................................... 251
◦Why People Worry About GUI Architectures ................................. 252
◦Why Others Ignore GUI Architectures ............................................ 254
◦A Rough Comparison of GUI Architectures .................................... 256
◦The Basics of Model-View-Intent .................................................... 260
◦Additional MVI Resources ................................................................ 263
• A Deep Dive Into MVI
◦What the Sample App Does .................................................... 265
◦MVI and the Sample App .................................................................. 273
◦The Model .......................................................................................... 274
◦The View State ........................................................................ 276
◦The View .................................................................................. 278
◦The Actions ............................................................................. 282
◦Publishing Actions ............................................................................ 286
◦The Repositories ............................................................................... 288
◦The Controller ........................................................................ 293
◦About Those Results .......................................................................... 297
◦The Reducer in the RosterViewModel ............................................ 298
◦Examining the Other Fragments ...................................................... 303
◦Summary ................................................................................. 304
• MVI and Paging
◦Flawed Assumptions ............................................................... 307
◦ToDoModelDataSource and the PagedDataSnapshot ........... 308
◦Saving Our Instance State ...................................................... 309
◦The Rest of the Core Changes .................................................. 312
• Configuring SQLite Beyond Room
◦When To Make Changes .................................................................... 321
◦Example: Turbo Boost Mode ............................................................. 322
iv

Preface
Thanks!
Thanks for your interest in Android app development, the world’s most popular
operating system! And, thanks for your interest in the Android Architecture
Components, released by Google in 2017 to help address common “big-ticket”
problems in Android app development.
And, most of all, thanks for your interest in this book! I sincerely hope you find it
useful!
(OTOH, if you find it completely useless… um, don’t tell anyone, OK?)
How the Book Is Structured
We start off with a look at Room, an object/relational mapping (ORM) library. This
makes it a bit easier to integrate your app with SQLite, the built-in relational
database engine in Android.
We then move into the lifecycle components. These components help you deal with
objects that have lifecycles, particularly activities and services. The LiveData class
in particular gives you a lightweight “reactive” way of consuming data while still
honoring things like configuration changes and the typical activity/fragment
destroy-and-recreate cycle. We will also peek at ViewModel, the Architecture
Components’ way of helping you maintain state across configuration changes. We
will see how other libraries, like data binding and RxJava, can be tied into the
Architecture Components.
v

We then move into a discussion of architecture in general, with material on the
repository pattern and major GUI architecture patterns. Then, we start to
investigate one of those GUI architectures — Model-View-Intent (MVI) — in detail,
through some larger sample apps.
Prerequisites
This book is targeted at:
• People who have read the core chapters of the companion volume, The Busy
Coder’s Guide to Android Development, or
• Intermediate Android app developers — those with some experience but not
necessarily “experts” in the field
About the Updates
This book will be updated a few times per year, to reflect new advances with the
Architecture Components.
If you obtained this book through the Warescription, you will be able to download
updates as they become available, for the duration of your subscription period.
If you obtained this book through other channels… um, well, it’s still a really nice
book!
Each release has notations to show what is new or changed compared with the
immediately preceding release:
• The Table of Contents shows sections with changes in bold-italic font
• Those sections have changebars on the right to denote specific paragraphs
that are new or modified
And, there is the “What’s New” section, just below this paragraph.
What’s New in Version 0.8?
This update:
PREFACE
vi

• Added a new chapter, covering creating a custom DataSource for use with
the Paging library
• Made various improvements to the Model-View-Intent sample app and
chapter
• Added a follow-up chapter, profiling an extended version of the Model-
View-Intent sample app, augmented with the Paging library
• Updates the chapter on paging Room queries to reflect alpha5 of the Paging
library
• Updates all of the dependencies to reflect the January 2018 release of the
Architecture Components, and updated bits of the prose to match
• Fixes various errata and makes other improvements
Warescription
If you purchased the Warescription, read on! If you obtained this book from other
channels, feel free to jump ahead.
The Warescription entitles you, for the duration of your subscription, to digital
editions of this book and its updates, in PDF, EPUB, and Kindle (MOBI/KF8)
formats. You also have access to other titles that CommonsWare publishes during
that subscription period, such as the aforementioned The Busy Coder’s Guide to
Android Development.
Each subscriber gets personalized editions of all editions of each title. That way,
your books are never out of date for long, and you can take advantage of new
material as it is made available.
However, you can only download the books while you have an active Warescription.
There is a grace period after your Warescription ends: you can still download the
book until the next book update comes out after your Warescription ends. After
that, you can no longer download the book. Hence, please download your
updates as they come out. You can find out when new releases of this book are
available via:
1. The CommonsBlog
2. The CommonsWare Twitter feed
3. The Warescription newsletter, which you can subscribe to off of your
Warescription page
4. Just check back on the Warescription site every month or two
PREFACE
vii

Subscribers also have access to other benefits, including:
• “Office hours” — online chats to help you get answers to your Android
application development questions. You will find a calendar for these on
your Warescription page.
• A Stack Overflow “bump” service, to get additional attention for a question
that you have posted there that does not have an adequate answer.
• A discussion board for asking arbitrary questions about Android app
development
Book Bug Bounty
Find a problem in the book? Let CommonsWare know!
Be the first to report a unique concrete problem in the current digital edition, and
CommonsWare will extend your Warescription by six months as a bounty for
helping CommonsWare deliver a better product.
By “concrete” problem, we mean things like:
1. Typographical errors
2. Sample applications that do not work as advertised, in the environment
described in the book
3. Factual errors that cannot be open to interpretation
By “unique”, we mean ones not yet reported. Be sure to check the book’s errata page,
though, to see if your issue has already been reported. One coupon is given per
email containing valid bug reports.
We appreciate hearing about “softer” issues as well, such as:
1. Places where you think we are in error, but where we feel our interpretation
is reasonable
2. Places where you think we could add sample applications, or expand upon
the existing material
3. Samples that do not work due to “shifting sands” of the underlying
environment (e.g., changed APIs with new releases of an SDK)
However, those “softer” issues do not qualify for the formal bounty program.
PREFACE
viii

Questions about the bug bounty, or problems you wish to report for bounty
consideration, should be sent to bounty@commonsware.com.
Source Code and Its License
The source code samples shown in this book are available for download from the
book’s GitHub repository. All of the Android projects are licensed under the Apache
2.0 License, in case you have the desire to reuse any of it.
Copying source code directly from the book, in the PDF editions, works best with
Adobe Reader, though it may also work with other PDF viewers. Some PDF viewers,
for reasons that remain unclear, foul up copying the source code to the clipboard
when it is selected.
Creative Commons and the Four-to-Free (42F)
Guarantee
Each CommonsWare book edition will be available for use under the Creative
Commons Attribution-Noncommercial-ShareAlike 3.0 license as of the fourth
anniversary of its publication date, or when 4,000 copies of the edition have been
sold, whichever comes first. That means that, once four years have elapsed (perhaps
sooner!), you can use this prose for non-commercial purposes. That is our Four-to-
Free Guarantee to our readers and the broader community. For the purposes of this
guarantee, new Warescriptions and renewals will be counted as sales of this edition,
starting from the time the edition is published.
This edition of this book will be available under the aforementioned Creative
Commons license on 1 February 2022. Of course, watch the CommonsWare Web
site, as this edition might be relicensed sooner based on sales.
For more details on the Creative Commons Attribution-Noncommercial-ShareAlike
3.0 license, visit the Creative Commons Web site
Note that future editions of this book will become free on later dates, each four years
from the publication of that edition or based on sales of that specific edition.
Releasing one edition under the Creative Commons license does not automatically
release all editions under that license.
PREFACE
ix

Acknowledgments
The author would like to thank the Google team responsible for the Architecture
Components for their work in making this library.
PREFACE
x

Room


Room Basics
First, let’s spend some time working with Room.
Google describes Room as providing “an abstraction layer over SQLite to allow fluent
database access while harnessing the full power of SQLite.”
In other words, Room aims to make your use of SQLite easier, through a lightweight
annotation-based implementation of an object-relational mapping (ORM) engine.
NOTE: The material in this chapter — and in all the chapters of this book edition —
is based on the 1.0.0 release of Room. Since this is a preview release, there may be
changes in newer versions that affect you.
Wrenching Relations Into Objects
If you have ever worked with a relational database — like SQLite — from an object-
oriented language — like Java — undoubtedly you have encountered the “object-
relational impedance mismatch”. That is a very fancy way of saying “gosh, it’s a pain
getting stuff into and out of the database”.
In object-oriented programming, we are used to objects holding references to other
objects, forming some sort of object graph. However, traditional SQL-style relational
databases work off of tables of primitive data, using foreign keys and join tables to
express relationships. Figuring out how to get our Java classes to map to relational
tables is aggravating, and it usually results in a lot of boilerplate code.
Traditional Android development uses SQLiteDatabase for interacting with SQLite.
That, in turn, uses Cursor objects to represent the results of queries and
ContentValues objects to represent data to be inserted or updated. While Cursor
1

and ContentValues are objects, they are fairly generic, much in the way that a
HashMap or ArrayList is generic. In particular, neither Cursor nor ContentValues
has any of our business logic. We have to somehow either wrap that around those
objects or convert between those objects and some of ours.
That latter approach is what object-relational mapping engines, or ORMs, take. A
typical ORM works off of Java code and either generates a suitable database
structure or works with you to identify how the Java classes should map to some
existing table structure (e.g., a legacy one that you are stuck with). The ORM usually
generates some code for you, and supplies a library, which in combination hide
much of the database details from you.
The quintessential Java ORM is Hibernate. However, Hibernate was developed with
server-side Java in mind and is not well-suited for slim platfoms like Android
devices. However, a vast roster of Android ORMs have been created over the years to
try to fill that gap. Some of the more popular ones have been:
• DBFlow
• greenDAO
• OrmLite
• Sugar ORM
Room also helps with the object-relational impedance mismatch. It is not as deep of
an ORM as some of the others, as you will be dealing with SQL a fair bit. However,
Room has one huge advantage: it is from Google, and therefore it will be deemed
“official” in the eyes of many developers and middle managers.
While this book is focused on the Architecture Components — and Room is part of
those — you may wish to explore other ORMs if you are interested in using Java
objects but saving the data in SQLite. Room is likely to become popular, but it is far
from the only option.
Room Requirements
To use Room, you need two dependencies in your module’s build.gradle file:
1. The runtime library version, using the standard compile directive
2. An annotation processor, using the annotationProcessor directive
implementation "android.arch.persistence.room:runtime:1.0.0"
annotationProcessor "android.arch.persistence.room:compiler:1.0.0"
ROOM BASICS
2

(from Trips/RoomBasics/app/build.gradle)
Note that Room has a minSdkVersion requirement of API Level 15 or higher. If you
attempt to build with a lower minSdkVersion, you will get a build error. If you try to
override Room’s minSdkVersion using manifest merger elements, while the project
will build, expect Room to crash horribly.
Room Furnishings
Roughly speaking, your use of Room is divided into three sets of classes:
1. Entities, which are POJOs that model the data you are transferring into and
out of the database
2. The data access object (DAO), that provides the description of the Java API
that you want for working with certain entities
3. The database, which ties together all of the entities and DAOs for a single
SQLite database
If you have used Square’s Retrofit, some of this will seem familiar:
• The DAO is roughly analogous to your Retrofit interface on which you
declare your Web service API
• Your entities are the POJOs that you are expecting Gson (or whatever) to
create based on the Web service response
In this chapter, we will look at the Trips/RoomBasics sample project. This app is the
first of a linked series of apps that we will examine in this book, as we build a travel
itinerary manager. It will track your upcoming trips in a database and allow you to
add, edit, and remove trips. Right now, though, we are settling for being able to see
some very rudimentary trips get into and out of a database.
Entities
In many ORM systems, the entity (or that system’s equivalent) is a POJO that you
happen to want to store in the database. It usually represents some part of your
overall domain model, so a payroll system might have entities representing
departments, employees, and paychecks.
With Room, a better description of entities is that they are POJOs representing:
• the data that you want to store into the database, and
ROOM BASICS
3

• a typical unit of a result set that you are trying to retrieve from the database
That difference may sound academic. It starts to come into play a bit more when we
start thinking about relations.
However, it also more closely matches the way Retrofit maps to Web services. With
Retrofit, we are not describing the contents of the Web service’s database. Rather, we
are describing how we want to work with defined Web service endpoints. Those
endpoints have a particular set of content that we can work with, courtesy of
whoever developed the Web service. We are simply mapping those to methods and
POJOs, both for input and output. Room is somewhere in between a Retrofit-style
“we just take what the Web service gives us” approach and a full ORM-style “we
control everything about the database” approach.
Tactically, an entity is a Java class marked with the @Entity annotation. For example,
here is a Trip class that serves as a Room entity:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.UUID
java.util.UUID;
@Entity(tableName = "trips")
class
class Trip
Trip {
@PrimaryKey
@NonNull
public
public final
final String id;
public
public final
final String title;
final
final int duration;
@Ignore
Trip(String title, int duration) {
this
this(UUID.randomUUID().toString(), title, duration);
}
Trip(@NonNull String id, String title, int duration) {
this
this.id=id;
this
this.title=title;
this
this.duration=duration;
}
@Override
ROOM BASICS
4

public
public String toString() {
return
return(title);
}
}
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/Trip.java)
There is no particular superclass required for entities, and the expectation is that
often they will be simple POJOs, as we see here.
Sometimes, your fields will be marked with annotations describing their roles. In
this example, the id field has the @PrimaryKey annotation, telling Room that this is
the unique identifier for this entity. Room will use that to know how to update and
delete Trip objects by their primary key values. Room also requires that any
@PrimaryKey field of an object type — like String – be annotated with @NonNull, as
primary keys in SQLite cannot be null.
Similarly, sometimes your methods will be marked with annotations. In this case,
Trip has two constructors: one that generates the id from a UUID, and one that takes
the id as a constructor parameter. Room needs to know which constructor(s) are
eligible for its use; you mark the other constructors with the @Ignore annotation.
For Room to work with a field, it needs to be public or have JavaBean-style getter
and setter methods, so Room can access them. If the fields are final, as they are on
Trip, Room will try to find a constructor to use to populate the fields, as final fields
will lack setters.
We will explore entities in greater detail in an upcoming chapter.
DAO
“Data access object” (or DAO for short) is a fancy way of saying “the API into the
data”. The idea is that you have a DAO that provides methods for the database
operations that you need: queries, inserts, updates, deletes, whatever.
In Room, the DAO is identified by the @Dao annotation, applied to either an
abstract class or an interface. The actual concrete implementation will be code-
generated for you by the Room annotation processor.
The primary role of the @Dao-annotated abstract class or interface is to have one
or more methods, with their own Room annotations, identifying what you want to
ROOM BASICS
5

do with the database and your entities. This serves the same role as the methods
annotated @GET or @POST in Retrofit.
The sample app has a TripStore that is our DAO:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Dao
android.arch.persistence.room.Dao;
import
import android.arch.persistence.room.Delete
android.arch.persistence.room.Delete;
import
import android.arch.persistence.room.Insert
android.arch.persistence.room.Insert;
import
import android.arch.persistence.room.OnConflictStrategy
android.arch.persistence.room.OnConflictStrategy;
import
import android.arch.persistence.room.Query
android.arch.persistence.room.Query;
import
import android.arch.persistence.room.Update
android.arch.persistence.room.Update;
import
import java.util.List
java.util.List;
@Dao
interface
interface TripStore
TripStore {
@Query("SELECT * FROM trips ORDER BY title")
List<Trip> selectAll();
@Query("SELECT * FROM trips WHERE id=:id")
Trip findById(String id);
@Insert
void insert(Trip... trips);
@Update
void update(Trip... trips);
@Delete
void delete(Trip... trips);
}
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/TripStore.java)
Besides the @Dao annotation on the TripStore interface, we have five methods, each
with their own annotations. Your four main annotations for these methods are
@Query, @Insert, @Update, and @Delete, which map to the corresponding database
operations.
Two TripStore methods — selectAll() and findById() — have the @Query
annotation. Principally, @Query will be used for SQL SELECT statements, where you
put the actual SQL in the annotation itself. To a large extent, any valid SQLite query
can be used here. However, instead of using ? as placeholders for arguments, as we
would in traditional SQLite, you use :-prefixed method parameter names. So, in
ROOM BASICS
6

findById(), we have a String parameter named id, so we can use :id in the SQL
statement wherever we might have used ? to indicate the value to bind in.
The remaining three methods use the @Insert, @Update, and @Delete annotations,
mapped to methods of the same name. Here, the methods take a varargs of Trip,
meaning that we can insert, update, or delete as many Trip objects as we want
(passing in zero Trip objects works, though that would be rather odd).
If you want custom code on your DAO, beyond the code-generated implementations
of your Room-annotated methods, use an abstract class and mark all the Room-
annotated methods as abstract. If, on the other hand, all you need on the DAO are
the Room-annotated methods, you can use an interface and skip all the abstract
keywords, as we did with TripStore.
We will explore the DAO in greater detail in an upcoming chapter.
Database
In addition to entities and DAOs, you will have at least one @Database-annotated
abstract class, extending a RoomDatabase base class. This class knits together the
database file, the entities, and the DAOs.
In the sample project, we have a TripDatabase serving this role:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Database
android.arch.persistence.room.Database;
import
import android.arch.persistence.room.Room
android.arch.persistence.room.Room;
import
import android.arch.persistence.room.RoomDatabase
android.arch.persistence.room.RoomDatabase;
import
import android.content.Context
android.content.Context;
@Database(entities={Trip.class}, version=1)
abstract
abstract class
class TripDatabase
TripDatabase extends
extends RoomDatabase {
abstract
abstract TripStore tripStore();
private
private static
static final
final String DB_NAME="trips.db";
private
private static
static volatile
volatile TripDatabase INSTANCE=null
null;
synchronized
synchronized static
static TripDatabase get(Context ctxt) {
if
if (INSTANCE==null
null) {
INSTANCE=create(ctxt, false
false);
}
return
return(INSTANCE);
ROOM BASICS
7

}
static
static TripDatabase create(Context ctxt, boolean memoryOnly) {
RoomDatabase.Builder<TripDatabase> b;
if
if (memoryOnly) {
b=Room.inMemoryDatabaseBuilder(ctxt.getApplicationContext(),
TripDatabase.class);
}
else
else {
b=Room.databaseBuilder(ctxt.getApplicationContext(), TripDatabase.class,
DB_NAME);
}
return
return(b.build());
}
}
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/TripDatabase.java)
The @Database annotation configures the code generation process, including:
• Identifying all of the entity classes that you care about in the entities
collection
• Identifying the schema version of the database (as you see with
SQLiteOpenHelper in conventional Android SQLite development)
@Database(entities={Trip.class}, version=1)
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/TripDatabase.java)
Here, we are saying that we have just one entity class (Trip), and that this is schema
version 1.
You also need abstract methods for each DAO class that return an instance of that
class:
abstract
abstract TripStore tripStore();
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/TripDatabase.java)
In this app, we have but one DAO (TripStore), so we have an abstract method to
return an instance of TripStore.
ROOM BASICS
8

Extending RoomDatabase, having the @Database annotation, and having the
abstract method(s) for your DAOs are the requirements. Anything beyond that is
up to you, and some apps may elect to have nothing more here.
In our case, we have a bit more logic.
Get a Room
In this example, the database is a singleton. TripDatabase has a static getter
method, cunningly named get(), that creates our singleton. get(), in turn, calls a
create() method that is responsible for creating our TripDatabase:
static
static TripDatabase create(Context ctxt, boolean memoryOnly) {
RoomDatabase.Builder<TripDatabase> b;
if
if (memoryOnly) {
b=Room.inMemoryDatabaseBuilder(ctxt.getApplicationContext(),
TripDatabase.class);
}
else
else {
b=Room.databaseBuilder(ctxt.getApplicationContext(), TripDatabase.class,
DB_NAME);
}
return
return(b.build());
}
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/TripDatabase.java)
To create a TripDatabase, we use a RoomDatabase.Builder, which we get by calling
one of two methods on the Room class:
•
databaseBuilder() is what you will normally use
•
inMemoryDatabaseBuilder() does what the method name suggests: it
creates an in-memory SQLite database, useful for instrumentation tests
where you do not necessarily need to persist the data for a user
Both of those methods take a Context and the Java Class object for the desired
RoomDatabase subclass. databaseBuilder() also takes the filename of the SQLite
database to use, much as SQLiteOpenHelper does in traditional Android SQLite
development.
ROOM BASICS
9

While there are some configuration methods that can be called on the
RoomDatabase.Builder, we skip those here, simply calling build() to build the
TripDatabase. The result is that when we call get(), we get a singleton lazy-
initialized TripDatabase.
From there, we can:
• Call tripStore() on the TripDatabase to retrieve the TripStore DAO
• Call methods on the TripStore to query, insert, update, or delete Trip
objects
We will see how to do that in the next chapter, where we look at how to write
instrumentation tests for our Room-generated database code.
ROOM BASICS
10

Testing Room
Once you have a RoomDatabase and its associated DAO(s) and entities set up, you
should start testing it.
The good news is that testing Room is not dramatically different than is testing
anything else in Android. Room has a few characteristics that make it a bit easier
than some things to test, as it turns out.
Writing Instrumentation Tests
On the whole, writing instrumentation tests for Room — where the tests run on an
Android device or emulator — is unremarkable. You get an instance of your
RoomDatabase subclass and exercise it from there.
So, for example, here is an instrumentation test case class to exercise the
TripDatabase from the preceding chapter:
package
package com.commonsware.android.room;
import
import android.support.test.InstrumentationRegistry
android.support.test.InstrumentationRegistry;
import
import android.support.test.runner.AndroidJUnit4
android.support.test.runner.AndroidJUnit4;
import
import org.junit.After
org.junit.After;
import
import org.junit.Before
org.junit.Before;
import
import org.junit.Test
org.junit.Test;
import
import org.junit.runner.RunWith
org.junit.runner.RunWith;
import
import java.util.List
java.util.List;
import
import static
static junit.framework.Assert.assertNotNull;
import
import static
static junit.framework.Assert.assertTrue;
import
import static
static org.junit.Assert.assertEquals;
import
import static
static org.junit.Assert.assertNotEquals;
11

@RunWith(AndroidJUnit4.class)
public
public class
class TripTests
TripTests {
TripDatabase db;
TripStore store;
@Before
public
public void setUp() {
db=TripDatabase.create(InstrumentationRegistry.getTargetContext(), true
true);
store=db.tripStore();
}
@After
public
public void tearDown() {
db.close();
}
@Test
public
public void basics() {
assertEquals(0, store.selectAll().size());
final
final Trip first=new
new Trip("Foo", 2880);
assertNotNull(first.id);
assertNotEquals(0, first.id.length());
store.insert(first);
assertTrip(store, first);
final
final Trip updated=new
new Trip(first.id, "Foo!!!", 1440);
store.update(updated);
assertTrip(store, updated);
store.delete(updated);
assertEquals(0, store.selectAll().size());
}
private
private void assertTrip(TripStore store, Trip trip) {
List<Trip> results=store.selectAll();
assertNotNull(results);
assertEquals(1, results.size());
assertTrue(areIdentical(trip, results.get(0)));
Trip result=store.findById(trip.id);
assertNotNull(result);
assertTrue(areIdentical(trip, result));
TESTING ROOM
12

}
private
private boolean areIdentical(Trip one, Trip two) {
return
return(one.id.equals(two.id) &&
one.title.equals(two.title) &&
one.duration==two.duration);
}
}
(from Trips/RoomBasics/app/src/androidTest/java/com/commonsware/android/room/TripTests.java)
Here, we:
• Create an empty database
• Get the DAO (TripStore)
• Confirm that there are no trips in the database
• Create a Trip object and insert() it into the database, then confirm that the
database was properly inserted
• Create a new Trip object with the same ID as the first, update() the
database using it, then confirm that the database was properly modified
• Delete the Trip object, then confirm that the database has no trips once
again
Using In-Memory Databases
When testing a database, though, one of the challenges is in making those tests
hermetic, or self-contained. One test method should not depend upon another test
method, and one test method should not affect the results of another test method
accidentally. This means that we want to start with a known starting point before
each test, and we have to consider how to do that.
One approach — the one taken in the above TripTests class — is to use an in-
memory database. The static create() method on TripDatabase, if you pass true
for the second parameter, creates a TripDatabase backed by memory, not disk:
static
static TripDatabase create(Context ctxt, boolean memoryOnly) {
RoomDatabase.Builder<TripDatabase> b;
if
if (memoryOnly) {
b=Room.inMemoryDatabaseBuilder(ctxt.getApplicationContext(),
TripDatabase.class);
}
else
else {
b=Room.databaseBuilder(ctxt.getApplicationContext(), TripDatabase.class,
TESTING ROOM
13

DB_NAME);
}
return
return(b.build());
}
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/TripDatabase.java)
There are two key advantages for using an in-memory database for instrumentation
testing:
1. It is intrinsically self-contained. Once the TripDatabase is closed, its
memory is released, and if separate tests use separate TripDatabase
instances, one will not affect the other.
2. Reading and writing to and from memory is much faster than is reading and
writing to and from disk, so the tests run much faster.
On the other hand, this means that the instrumentation tests are useless for
performance testing, as (presumably) your production app will actually store its
database on disk. You could use Gradle command-line switches, custom build types
and buildConfigField, or other means to decide when tests are run whether they
should use memory or disk.
Importing Starter Data
The one downside to having an empty starter database, such as a fresh in-memory
database, is that you have no data. Eventually, you need some data to test.
That could come from test code, such as what TripTests does. In many cases, this is
a necessary part of testing, to confirm that all of your DAO methods work as
expected.
Alternatives include:
• Loading the data from some neutral format (e.g., JSON) via some utility
method
• Packaging one or more starter database as assets in the instrumentation
tests (e.g., src/androidTest/assets/), then using ATTACH DATABASE ... and
INSERT INTO ... SELECT FROM ... SQLite code to copy from the starter
database to the database to be used in testing
TESTING ROOM
14

Writing Unit Tests via Mocks
Let’s look again at the TripStore DAO:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Dao
android.arch.persistence.room.Dao;
import
import android.arch.persistence.room.Delete
android.arch.persistence.room.Delete;
import
import android.arch.persistence.room.Insert
android.arch.persistence.room.Insert;
import
import android.arch.persistence.room.OnConflictStrategy
android.arch.persistence.room.OnConflictStrategy;
import
import android.arch.persistence.room.Query
android.arch.persistence.room.Query;
import
import android.arch.persistence.room.Update
android.arch.persistence.room.Update;
import
import java.util.List
java.util.List;
@Dao
interface
interface TripStore
TripStore {
@Query("SELECT * FROM trips ORDER BY title")
List<Trip> selectAll();
@Query("SELECT * FROM trips WHERE id=:id")
Trip findById(String id);
@Insert
void insert(Trip... trips);
@Update
void update(Trip... trips);
@Delete
void delete(Trip... trips);
}
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/TripStore.java)
This is a pure interface. More importantly, other than annotations, its API is purely
domain-specific. Everything revolves around our Trip entity and other business
logic (e.g., String values as identifiers).
Room DAOs are designed to be mocked, using a mocking library like Mockito, so
that you can write unit tests (tests that run on your development machine or CI
server) in addition to — or perhaps instead of — instrumentation tests.
The primary advantage of unit tests is execution speed, as they do not have to be run
on Android devices or emulators. On the other hand, setting up mocks can be
tedious.
TESTING ROOM
15

The RoomBasics project not only has the instrumentation tests shown earlier in this
chapter, but an equivalent unit test in test/, embodied in a TripUnitTests class:
package
package com.commonsware.android.room;
import
import org.junit.Before
org.junit.Before;
import
import org.junit.Test
org.junit.Test;
import
import org.mockito.ArgumentMatchers
org.mockito.ArgumentMatchers;
import
import org.mockito.Mockito
org.mockito.Mockito;
import
import org.mockito.invocation.InvocationOnMock
org.mockito.invocation.InvocationOnMock;
import
import org.mockito.stubbing.Answer
org.mockito.stubbing.Answer;
import
import java.util.ArrayList
java.util.ArrayList;
import
import java.util.Collections
java.util.Collections;
import
import java.util.Comparator
java.util.Comparator;
import
import java.util.HashMap
java.util.HashMap;
import
import java.util.List
java.util.List;
import
import static
static org.junit.Assert.assertEquals;
import
import static
static org.junit.Assert.assertNotEquals;
import
import static
static org.junit.Assert.assertNotNull;
import
import static
static org.junit.Assert.assertTrue;
import
import static
static org.mockito.Matchers.any;
import
import static
static org.mockito.Mockito.doAnswer;
public
public class
class TripUnitTests
TripUnitTests {
private
private TripStore store;
@Before
public
public void setUp() {
store=Mockito.mock(TripStore.class);
final
final HashMap<String, Trip> trips=new
new HashMap<>();
doAnswer(new
new Answer() {
@Override
public
public Object answer(InvocationOnMock invocation) throws
throws Throwable {
ArrayList<Trip> result=new
new ArrayList<>(trips.values());
Collections.sort(result, new
new Comparator<Trip>() {
@Override
public
public int compare(Trip left, Trip right) {
return
return(left.title.compareTo(right.title));
}
});
return
return(result);
}
}).when(store).selectAll();
TESTING ROOM
16

doAnswer(new
new Answer() {
@Override
public
public Object answer(InvocationOnMock invocation) throws
throws Throwable {
String id=(String)invocation.getArguments()[0];
return
return(trips.get(id));
}
}).when(store).findById(any(String.class));
doAnswer(new
new Answer() {
@Override
public
public Object answer(InvocationOnMock invocation) throws
throws Throwable {
for
for (Object rawTrip : invocation.getArguments()) {
Trip trip=(Trip)rawTrip;
trips.put(trip.id, trip);
}
return
return(null
null);
}
}).when(store).insert(ArgumentMatchers.any());
doAnswer(new
new Answer() {
@Override
public
public Object answer(InvocationOnMock invocation) throws
throws Throwable {
for
for (Object rawTrip : invocation.getArguments()) {
Trip trip=(Trip)rawTrip;
trips.put(trip.id, trip);
}
return
return(null
null);
}
}).when(store).update(ArgumentMatchers.any());
doAnswer(new
new Answer() {
@Override
public
public Object answer(InvocationOnMock invocation) throws
throws Throwable {
for
for (Object rawTrip : invocation.getArguments()) {
Trip trip=(Trip)rawTrip;
trips.remove(trip.id);
}
return
return(null
null);
}
}).when(store).delete(ArgumentMatchers.any());
TESTING ROOM
17

}
@Test
public
public void basics() {
assertEquals(0, store.selectAll().size());
final
final Trip first=new
new Trip("Foo", 2880);
assertNotNull(first.id);
assertNotEquals(0, first.id.length());
store.insert(first);
assertTrip(store, first);
final
final Trip updated=new
new Trip(first.id, "Foo!!!", 1440);
store.update(updated);
assertTrip(store, updated);
store.delete(updated);
assertEquals(0, store.selectAll().size());
}
private
private void assertTrip(TripStore store, Trip trip) {
List<Trip> results=store.selectAll();
assertNotNull(results);
assertEquals(1, results.size());
assertTrue(areIdentical(trip, results.get(0)));
Trip result=store.findById(trip.id);
assertNotNull(result);
assertTrue(areIdentical(trip, result));
}
private
private boolean areIdentical(Trip one, Trip two) {
return
return(one.id.equals(two.id) &&
one.title.equals(two.title) &&
one.duration==two.duration);
}
}
(from Trips/RoomBasics/app/src/test/java/com/commonsware/android/room/TripUnitTests.java)
The basics() test method, and its supporting utility methods, are the same as in the
instrumentation tests. What differs is where the TripStore comes from. In the
TESTING ROOM
18

instrumentation tests, we created an in-memory TripDatabase and retrieved a
TripStore from it. In the unit tests, we use Mockito to create a mock TripStore (via
Mockito.mock(TripStore.class)), then teach the mock how to respond to its
methods. In this case, we mock a database with a simple HashMap, with a roster of
the trips, keyed by their ID values. Each of the doAnswer() calls mocks a specific
method on the TripStore, down to the details of having selectAll() return the
trips ordered by title.
Whether this is worth the effort is for you to decide. For many projects,
instrumentation tests will suffice. For larger projects, where the speed difference
between unit tests and instrumentation tests is substantial, it might be worth the
engineering time to create the mocks. While mocking is also useful for scenarios
that are difficult to reproduce, it is unlikely that your DAO will have any of those
scenarios.
TESTING ROOM
19


The Dao of Entities
Two chapters ago, we went through the basic steps for setting up Room:
• Create and annotate your entity classes
• Create, annotate, and define operator methods on your DAO(s)
• Create a subclass of RoomDatabase to tie the entities and DAO(s) together
• Create an instance of that RoomDatabase at some likely point in time, while
you are safely on a background thread
• Use the RoomDatabase instance to retrieve your DAO and from there work
with your entities
However, we only scratched the surface of what can be configured on entities and
DAOs. In this chapter — and the subsequent chapters on custom types and relations
— we will explore the rest of the configuration for entities and DAOs.
Many of the code snippets shown in this chapter come from the General/RoomDao
sample project. This contains a library module (stuff) with entity and DAO code
along with instrumentation tests for bits of that code.
Configuring Entities
The only absolute requirements for a Room entity class is that it be annotated with
the @Entity annotation and have a field identified as the primary key, typically by
way of a @PrimaryKey annotation. Anything above and beyond that is optional.
However, there is a fair bit that is “above and beyond that”. Some — though probably
not all — of these features will be of interest in larger apps.
21

Primary Keys
If you have a single field that is the primary key for your entity, using the
@PrimaryKey annotation is simple and helps you clearly identify that primary key at
a later point.
However, you do have some other options.
Auto-Generated Primary Keys
In SQLite, if you have an INTEGER column identified as the PRIMARY KEY, you can
optionally have SQLite assign unique values for that column, by way of the
AUTOINCREMENT keyword.
In Room, if you have an int or Integer field that is your @PrimaryKey, you can
optionally apply AUTOINCREMENT to the corresponding column by adding
autoGenerate=true to the annotation:
@Entity
public
public class
class Constant
Constant {
@PrimaryKey(autoGenerate=true
true)
@NonNull
public
public int id;
String title;
double value;
@Override
public
public String toString() {
return
return(title);
}
}
By default, autoGenerate is false. Setting that property to true gives you
AUTOINCREMENT in the generated CREATE TABLE statement:
CREATE
CREATE TABLE
TABLE IF NOT
NOT EXISTS
EXISTS constants (id INTEGER PRIMARY
PRIMARY KEY
KEY AUTOINCREMENT, title
TEXT, value REAL NOT
NOT NULL
NULL)
However, this starts to get complicated in the app. You do not know your primary
key until you insert the entity into a database. That presents “trickle-down”
complications — for example, you cannot make the primary key field final, as then
you cannot create an instance of an entity that is not yet in the database. While you
THE DAO OF ENTITIES
22

can try to work around this (e.g., default the id to -1), then you have to keep
checking to see whether you have a valid identifier.
Most of the samples in this book will use a UUID instead. While these take up much
more room than a simple int, they can be uniquely generated outside of the
database. For your production apps, you will need to decide if the headaches
surrounding database-generated identifiers are worth their benefits.
Also, notice that the value column has NOT NULL applied to it. Room’s rule is that
primitive fields (int, double, etc.) will be NOT NULL, while their object equivalents
(Integer, Double, etc.) will allow null values.
Composite Primary Keys
In some cases, you may have a composite primary key, made up of two or more
columns in the database. This is particularly true if you are trying to design your
entities around an existing database structure, one that used a composite primary
key for one of its tables (for whatever reason).
If, logically, those are all part of a single object, you could combine them into a
single field, as we will see in the next chapter. However, it may be that they should
be individual fields in your entity, but they happen to combine to create the primary
key. In that case, you can skip the @PrimaryKey annotation and use the primaryKeys
property of the @Entity.
One scenario for this is data versioning, where we are tracking changes to data over
time, the way a version control system tracks changes to source code and other files
over time. There are several ways of implementing data versioning. One approach
has all versions of the same entity in the same table, with a version code attached to
the “natural” primary key to identify a specific version of that content. In that case,
you could have something like:
@Entity(primaryKeys={"id", "versionCode"})
class
class VersionedThingy
VersionedThingy {
@NonNull public
public final
final String id;
public
public final
final int versionCode;
VersionedThingy(String id, int versionCode) {
this
this.id=id;
this
this.versionCode=versionCode;
}
}
THE DAO OF ENTITIES
23

Room will then use the PRIMARY KEY keyword in the CREATE TABLE statement to set
up the composite primary key:
CREATE
CREATE TABLE
TABLE IF NOT
NOT EXISTS
EXISTS VersionedThingy (id TEXT NOT
NOT NULL
NULL, versionCode INTEGER NOT
NOT
NULL
NULL, PRIMARY
PRIMARY KEY
KEY(id, versionCode))
Even though we are using primaryKeys rather than @PrimaryKey, the @NonNull
requirement still holds. We need to add that to any of our primaryKeys fields that
are of object types. Since id is a String, we need @NonNull. However, versionCode is
an int, and an int cannot be null, so we do not need @NonNull (though having it
will not cause a problem). If versionCode were an Integer, we would need
@NonNull, as an Integer field could be null.
Adding Indexes
Your primary key is indexed automatically by SQLite. However, you may wish to set
up other indexes for other columns or collections of columns, to speed up queries.
To do that, use the indices property on @Entity. This property takes a list of @Index
annotations, each of which declares an index.
For example, as part of a Customer entity, you might have an address, which might
contain a postalCode. You might be querying directly on postalCode as part of a
search form, and so having an index on that would be useful. To do that, add the
appropriate @Index to indices:
@Entity(indices={@Index("postalCode")})
class
class Customer
Customer {
@PrimaryKey
public
public final
final String id;
public
public final
final String postalCode;
public
public final
final String displayName;
Customer(String id, String postalCode, String displayName) {
this
this.id=id;
this
this.postalCode=postalCode;
this
this.displayName=displayName;
}
}
Room will add the requested index:
CREATE
CREATE INDEX
INDEX index_Customer_postalCode ON
ON Customer (postalCode)
THE DAO OF ENTITIES
24

If you have a composite index, consisting of two or more fields, @Index takes a
comma-delimited list of column names and will generate the composite index.
If the index should also enforce uniqueness — only one entity can have the indexed
value — add unique=true to the @Index. This requires you to assign the column(s)
for the index to the value property, due to the way Java annotations work:
@Entity(indices={@Index(value="postalCode", unique=true
true)})
class
class Customer
Customer {
@PrimaryKey
@NonNull
public
public final
final String id;
public
public final
final String postalCode;
public
public final
final String displayName;
Customer(String id, String postalCode, String displayName) {
this
this.id=id;
this
this.postalCode=postalCode;
this
this.displayName=displayName;
}
}
This causes Room to add the UNIQUE keyword to the CREATE INDEX statement:
CREATE
CREATE UNIQUE
UNIQUE INDEX
INDEX index_Customer_postalCode ON
ON Customer (postalCode)
Ignoring Fields
If there are fields in the entity class that should not be persisted, annotate them with
@Ignore:
@Entity(primaryKeys={"id", "versionCode"})
class
class VersionedThingy
VersionedThingy {
@NonNull public
public final
final String id;
public
public final
final int versionCode;
@Ignore
private
private String something;
VersionedThingy(String id, int versionCode) {
this
this.id=id;
this
this.versionCode=versionCode;
}
}
THE DAO OF ENTITIES
25

That annotation is required. For example, this does not work:
@Entity(primaryKeys={"id", "versionCode"})
class
class VersionedThingy
VersionedThingy {
@NonNull public
public final
final String id;
public
public final
final int versionCode;
private
private String something;
VersionedThingy(String id, int versionCode) {
this
this.id=id;
this
this.versionCode=versionCode;
}
}
You might think that since the field is private and has no setter, that Room would
ignore it automatically. Room, instead, generates a build error, as it cannot tell if you
want to ignore that field or if you simply forgot to add it properly.
With Room, transient fields are ignored automatically by default, so in the
following code snippet, something will be ignored:
@Entity(primaryKeys={"id", "versionCode"})
class
class VersionedThingy
VersionedThingy {
@NonNull public
public final
final String id;
public
public final
final int versionCode;
public
public transient
transient String something;
VersionedThingy(String id, int versionCode) {
this
this.id=id;
this
this.versionCode=versionCode;
}
}
Note that you can also @Ignore constructors. This may be required to clear up Room
build errors, if the code generator cannot determine what constructor to use:
@Entity(primaryKeys={"id", "versionCode"})
class
class VersionedThingy
VersionedThingy {
@NonNull public
public final
final String id;
public
public final
final int versionCode;
@Ignore
private
private String something;
THE DAO OF ENTITIES
26

@Ignore
VersionedThingy() {
this
this(UUID.randomUUID().toString(), 1);
}
VersionedThingy(String id, int versionCode) {
this
this.id=id;
this
this.versionCode=versionCode;
}
}
NOT NULL Fields
As noted earlier, primitive fields get converted into NOT NULL columns in the table,
while object fields allow null values.
If you want an object field to be NOT NULL, apply the @NonNull annotation:
@Entity(indices={@Index("postalCode")})
class
class Customer
Customer {
@PrimaryKey
@NonNull
public
public final
final String id;
@NonNull
public
public final
final String postalCode;
public
public final
final String displayName;
Customer(String id, String postalCode, String displayName) {
this
this.id=id;
this
this.postalCode=postalCode;
this
this.displayName=displayName;
}
}
This will make the associated column have NOT NULL applied to it.
Custom Table and Column Names
By default, Room will generate names for your tables and columns based off of the
entity class names and field names. In general, it does a respectable job of this, and
so you may just leave them alone. However, you may find that you need to control
these names, particularly if you are trying to match an existing database schema
(e.g., you are migrating an existing Android app to use Room instead of using SQLite
THE DAO OF ENTITIES
27

directly). And for table names in particular, setting your own name can simplify
some of the SQL that you have to write for @Query-annotated methods.
To control the table name, use the tableName property on the @Entity attribute, and
give it a valid SQLite table name. For example, while in Java we might want to call
the class VersionedThingy, we might prefer the table to just be thingy:
@Entity(tableName="thingy", primaryKeys={"id", "versionCode"})
class
class VersionedThingy
VersionedThingy {
@NonNull public
public final
final String id;
public
public final
final int versionCode;
@Ignore
private
private String something;
@Ignore
VersionedThingy() {
this
this(UUID.randomUUID().toString(), 1);
}
VersionedThingy(String id, int versionCode) {
this
this.id=id;
this
this.versionCode=versionCode;
}
}
To rename a column, add the @ColumnInfo annotation to the field, with a name
property that provides your desired name for the column:
@Entity(tableName="thingy", primaryKeys={"id", "versionCode"})
class
class VersionedThingy
VersionedThingy {
@NonNull public
public final
final String id;
@ColumnInfo(name="version_code")
public
public final
final int versionCode;
@Ignore
private
private String something;
@Ignore
VersionedThingy() {
this
this(UUID.randomUUID().toString(), 1);
}
VersionedThingy(String id, int versionCode) {
this
this.id=id;
THE DAO OF ENTITIES
28

this
this.versionCode=versionCode;
}
}
Here, we changed the versionCode field’s column to version_code, along with
specifying the table name.
However, this fails. The values in the primaryKeys property are the column names,
not the field names. Since we renamed the column, we need to update primaryKeys
to match:
package
package com.commonsware.android.room.dao;
import
import android.arch.persistence.room.ColumnInfo
android.arch.persistence.room.ColumnInfo;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.UUID
java.util.UUID;
@Entity(tableName="thingy", primaryKeys={"id", "version_code"})
class
class VersionedThingy
VersionedThingy {
@NonNull public
public final
final String id;
@ColumnInfo(name="version_code")
@NonNull
public
public final
final int versionCode;
@Ignore
private
private String something;
@Ignore
VersionedThingy() {
this
this(UUID.randomUUID().toString(), 1);
}
VersionedThingy(String id, int versionCode) {
this
this.id=id;
this
this.versionCode=versionCode;
}
}
(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/VersionedThingy.java)
Also note that adding @ColumnInfo to a transient field means that this field will be
included when creating the table structure. By default, transient fields are ignored,
THE DAO OF ENTITIES
29

but adding @ColumnInfo indicates that you want that default behavior to be
overridden.
Other @ColumnInfo Options
Beyond specifying the column name to use, you can configure other options on a
@ColumnInfo annotation.
Indexing
You can add an index property to indicate that you want to index the column, as an
alternative to listing the column in the indices property of the @Entity annotation.
For example, we could replace:
@Entity(indices={@Index("postalCode")})
class
class Customer
Customer {
@PrimaryKey
public
public final
final String id;
public
public final
final String postalCode;
public
public final
final String displayName;
Customer(String id, String postalCode, String displayName) {
this
this.id=id;
this
this.postalCode=postalCode;
this
this.displayName=displayName;
}
}
with:
@Entity
class
class Customer
Customer {
@PrimaryKey
public
public final
final String id;
@ColumnInfo(index=true
true)
public
public final
final String postalCode;
public
public final
final String displayName;
Customer(String id, String postalCode, String displayName) {
this
this.id=id;
this
this.postalCode=postalCode;
this
this.displayName=displayName;
THE DAO OF ENTITIES
30

}
}
and have the same result.
Collation
You can specify a collate property to indicate the collation sequence to apply to
this column. Here, “collation sequence” is a fancy way of saying “comparison
function for comparing two strings”.
There are four options:
•
BINARY and UNDEFINED, which are equivalent, the default value, and indicate
that case is sensitive
•
NOCASE, which indicates that case is not sensitive (more accurately, that the
26 English letters are converted to uppercase)
•
RTRIM, which indicates that trailing spaces should be ignored on a case-
sensitive collation
There is no full-UTF equivalent of NOCASE in SQLite.
Type Affinity
Normally, Room will determine the type to use on the column in SQLite based upon
the type of the field (e.g., int or Integer turn into INTEGER columns). If, for some
reason, you wish to try to override this behavior, you can use the typeAffinity
property on @ColumnInfo to specify some other type to use.
DAOs and Queries
One popular thing to do with a database is to get data out of it. For that, we add
@Query methods on our DAO.
Those do not have to be especially complicated, as we saw with the TripStore:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Dao
android.arch.persistence.room.Dao;
import
import android.arch.persistence.room.Delete
android.arch.persistence.room.Delete;
import
import android.arch.persistence.room.Insert
android.arch.persistence.room.Insert;
THE DAO OF ENTITIES
31

import
import android.arch.persistence.room.OnConflictStrategy
android.arch.persistence.room.OnConflictStrategy;
import
import android.arch.persistence.room.Query
android.arch.persistence.room.Query;
import
import android.arch.persistence.room.Update
android.arch.persistence.room.Update;
import
import java.util.List
java.util.List;
@Dao
interface
interface TripStore
TripStore {
@Query("SELECT * FROM trips ORDER BY title")
List<Trip> selectAll();
@Query("SELECT * FROM trips WHERE id=:id")
Trip findById(String id);
@Insert
void insert(Trip... trips);
@Update
void update(Trip... trips);
@Delete
void delete(Trip... trips);
}
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/TripStore.java)
However, SQL queries with SQLite can get remarkably complicated. Room tries to
support a lot of the standard SQL syntax, but Room adds its own complexity, in
terms of trying to decipher how to interpret your @Query method’s arguments and
return type.
Adding Parameters
As we saw with findById() on TripStore, you can map method arguments to query
parameters by using : syntax. Put : before the argument name and its value will be
injected into the query:
@Query("SELECT * FROM thingy WHERE id=:id AND version_code=:versionCode")
VersionedThingy findById(String id, int versionCode);
(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
Bear in mind that the rest of the SQL statement is based on the table, not the entity.
Table names and column names will either be the code-generated names or your
overridden names (via tableName and @ColumnInfo).
THE DAO OF ENTITIES
32

WHERE Clause
Principally, your method arguments will be injected into your WHERE clause, such as
in the above examples.
Note that Room has special support for IN in a WHERE clause. So, while this works for
a single postalCode:
@Query("SELECT * FROM Customer WHERE postalCode IN (:postalCodes)")
List<Customer> findByPostalCodes(String postalCodes);
…you can also do:
@Query("SELECT * FROM Customer WHERE postalCode IN (:postalCodes)")
List<Customer> findByPostalCodes(List<String> postalCodes);
…or even:
@Query("SELECT * FROM Customer WHERE postalCode IN (:postalCodes)")
List<Customer> findByPostalCodes(String... postalCodes);
Room will convert the collection argument into a comma-delimited list for use with
the SQL query.
Other Clauses
If SQLite allows ? placeholders, Room should allow method arguments to be used
instead.
So, for example, you can parameterize a LIMIT clause:
@Query("SELECT * FROM Customer WHERE postalCode IN (:postalCodes) LIMIT :max")
List<Customer> findByPostalCodes(int max, String... postalCodes);
(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
Here, because Java needs the varargs to be the last parameter, we need to have max
first.
THE DAO OF ENTITIES
33

What You Can Return
We have seen that a @Query can return a single entity (e.g., findById() returning a
single Trip) or a collection of entity (e.g., selectAll() returning a List of Trip
entities).
While those are simple, Room offers a fair bit more flexibility than that. In
particular, not only does Room support reactive return values, but we can return
objects that are not actually entities.
Specific Return Types
In addition to returning single objects or collections of objects, a Room @Query can
return a good old-fashioned Cursor. This is particularly useful if you are migrating
legacy code that uses CursorAdapter or other Cursor-specific classes. Similarly, if
you are looking to expose part of a Room-defined database via a ContentProvider, it
may be more convenient for you to get your results in the form of a Cursor, so that
you can just return that from the provider’s query() method.
Beyond that, a @Query method can return:
• A Flowable or Publisher from RxJava2, a popular framework for reactive
programming
• A LiveData object
We will explore what a LiveData object is later in this book.
Breadth of Results
For small entities, like Trip, usually we will retrieve all columns in the query.
However, the real rule is: the core return object of the @Query method must be
something that Room knows how to fill in from the columns that you request.
For wider tables with many columns, this is important. For example, perhaps for a
RecyclerView, you only need a couple of columns, but for all entities in the table. In
that case, it might be nice to only retrieve those specific columns. You have two ways
to do that:
THE DAO OF ENTITIES
34

1. Have your @Entity support only a subset of columns, allowing the rest to be
null or otherwise tracking the fact that we only retrieved a subset of
columns from the table
2. Return something other than the entity that you have associated with this
table
If you look at your @Dao-annotated interface, you will notice that while methods
might refer to entities, its annotations do not. That is because the DAO is somewhat
independent of the entities. The entities describe the table, but the DAO is not
limited to using those entities. So long as the DAO can fulfill the contract stipulated
by the SQL, the method arguments, and the method return type, Room is perfectly
content.
So, for example, suppose that Customer not only tracks an id and a postalCode, but
also has many other fields, including a displayName:
package
package com.commonsware.android.room.dao;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.Index
android.arch.persistence.room.Index;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.UUID
java.util.UUID;
@Entity(indices={@Index(value="postalCode", unique=true
true)})
class
class Customer
Customer {
@PrimaryKey
@NonNull
public
public final
final String id;
public
public final
final String postalCode;
public
public final
final String displayName;
@Ignore
Customer(String postalCode, String displayName) {
this
this(UUID.randomUUID().toString(), postalCode, displayName);
}
Customer(String id, String postalCode, String displayName) {
this
this.id=id;
this
this.postalCode=postalCode;
this
this.displayName=displayName;
}
}
THE DAO OF ENTITIES
35

(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/Customer.java)
Perhaps to show a list of customers, we need the displayName (to show in the list)
and the id (to know which specific customer this is). But we do not need the
postalCode or the rest of the fields in the Customer class.
We can still return a Customer:
@Query("SELECT id, displayName FROM Customer WHERE postalCode IN (:postalCodes) LIMIT
:max")
List<Customer> findByPostalCodes(List<String> postalCodes, int max);
The code that Room generates will simply fill in null for the postalCode, since that
was not one of the returned columns. However, then it is not obvious whether a
given instance of Customer is completely filled in from data in the table (and it is
genuinely missing its postalCode) or whether this is a partially-populated Customer
object.
However, we could also define a dedicated CustomerDisplayTuple class:
package
package com.commonsware.android.room.dao;
public
public class
class CustomerDisplayTuple
CustomerDisplayTuple {
public
public final
final String id;
public
public final
final String displayName;
public
public CustomerDisplayTuple(String id, String displayName) {
this
this.id=id;
this
this.displayName=displayName;
}
}
(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/CustomerDisplayTuple.java)
Then, we can return a List of CustomerDisplayTuple from our DAO:
@Query("SELECT id, displayName FROM Customer WHERE postalCode IN (:postalCodes) LIMIT :max")
List<CustomerDisplayTuple> loadDisplayTuplesByPostalCodes(int max, String... postalCodes);
(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
This way, we get our subset of data, and we know by class whether we have the full
Customer or just the subset for display purposes.
Note that @ColumnInfo annotations can be used on any class, not just entities. In
particular, if you use @ColumnInfo on a field in an entity, you will need the same
THE DAO OF ENTITIES
36

@ColumnInfo on any “tuple”-style classes that represent subsets of data that include
that same field.
Aggregate Functions
A @Query can also return an int, for simple aggregate functions:
@Query("SELECT COUNT(*) FROM Customer")
int getCustomerCount();
(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
If you wish to compute several aggregate functions, create a “tuple”-style class to
hold the values:
package
package com.commonsware.android.room.dao;
public
public class
class CustomerStats
CustomerStats {
public
public final
final int count;
public
public final
final String max;
public
public CustomerStats(int count, String max) {
this
this.count=count;
this
this.max=max;
}
}
(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/CustomerStats.java)
…and use AS to name the aggregate function “columns” to match the tuple:
@Query("SELECT COUNT(*) AS count, MAX(postalCode) AS max FROM Customer")
CustomerStats getCustomerStats();
(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
Dynamic Queries
Sometimes, you do not know the query at compile time.
One scenario for this is when you want to expose a Room-managed database via a
ContentProvider to third-party apps. You could document that you support a
limited set of options in your provider’s query() method, ones that you can map to
@Query methods on your DAO. Alternatively, you could generate a SQL statement
THE DAO OF ENTITIES
37

using SQLiteQueryBuilder that supports what your table offers, but then you need
to somehow execute that statement and get a Cursor back.
For that, RoomDatabase has a query() method that is analogous to rawQuery() on a
SQLiteDatabase. Pass it the SQL statement and an Object array of position
parameters, and RoomDatabase will give you a Cursor back.
Other DAO Operations
To get data out of a database, generally it is useful to put data into it. We have seen
basic @Insert, @Update, and @Delete DAO methods on TripStore:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Dao
android.arch.persistence.room.Dao;
import
import android.arch.persistence.room.Delete
android.arch.persistence.room.Delete;
import
import android.arch.persistence.room.Insert
android.arch.persistence.room.Insert;
import
import android.arch.persistence.room.OnConflictStrategy
android.arch.persistence.room.OnConflictStrategy;
import
import android.arch.persistence.room.Query
android.arch.persistence.room.Query;
import
import android.arch.persistence.room.Update
android.arch.persistence.room.Update;
import
import java.util.List
java.util.List;
@Dao
interface
interface TripStore
TripStore {
@Query("SELECT * FROM trips ORDER BY title")
List<Trip> selectAll();
@Query("SELECT * FROM trips WHERE id=:id")
Trip findById(String id);
@Insert
void insert(Trip... trips);
@Update
void update(Trip... trips);
@Delete
void delete(Trip... trips);
}
(from Trips/RoomBasics/app/src/main/java/com/commonsware/android/room/TripStore.java)
Generally speaking, these scenarios are simpler than @Query. The @Insert, @Update,
and @Delete set up simple methods for inserting, updating, or deleting entities
THE DAO OF ENTITIES
38

passed to their methods… and that is pretty much it. However, there are a few
additional considerations that we should explore.
Parameters
@Insert, @Update, and @Delete work with entities. TripStore uses varargs, so we can
pass zero, one, or several Trip objects, though passing zero objects would be a waste
of time.
However, in addition to varargs, you can have these methods accept:
• A single entity
• Individual entities as separate parameters (void insert(Trip trip1, Trip
trip2))
• A List of entities
Return Values
Frequently, you just have these methods return void.
However:
• For @Update and @Delete, you can have them return an int, which will be
the number of rows affected by the update or delete operation
• For an @Insert method accepting a single entity, you can have it return a
long which will be the ROWID of the entity (and, if you are using an auto-
increment int as your primary key, this will also be that key)
• For an @Insert method accepting multiple entities, you can have it return an
array of long objects or a List of Long objects, being the corresponding
ROWID values for those inserted entities
Conflict Resolution
@Insert and @Update support an optional onConflict property. This maps to
SQLite’s ON CONFLICT clause and indicates what should happen if there is either a
uniqueness violation (e.g., duplicate primary keys) or a NOT NULL violation when the
insert or update should occur.
The value of onConflict is an OnConflictStrategy value:
THE DAO OF ENTITIES
39

Value
Meaning
OnConflictStrategy.ABORT
Cancel this statement but preserve prior results in
the transaction and keeps the transaction alive
OnConflictStrategy.FAIL
Like ABORT, but accepts prior changes by this specific
statement (e.g., if we fail on the 50th row to be
updated, keep the changes to the preceding 49)
OnConflictStrategy.IGNORE
Like FAIL, but continues processing this statement
(e.g., if we fail on the 50th row out of 100, keep the
changes to the other 99)
OnConflictStrategy.REPLACE
For uniqueness violations, deletes other rows that
would cause the violation before executing this
statement
OnConflictStrategy.ROLLBACK
Rolls back the current transaction
The default strategy for @Insert and @Update is ABORT. You might want to consider
changing that to be ROLLBACK, particularly if you start using transactions:
@Insert(onConflict=OnConflictStrategy.ROLLBACK)
void insert(Trip... trips);
Other Operations
The primary problem with @Insert, @Update, and @Delete is that they need entities.
In part, that is so the DAO method knows what table to work against.
For anything else, use @Query. @Query not only works with operations that return
result sets, but with any SQL that you wish to execute, even if that SQL does not
return a result set.
So, for example, you could have:
@Query("DELETE FROM Customer")
void nukeCustomersFromOrbit();
…or:
@Query("DELETE FROM Customer WHERE id IN (:ids)")
int nukeCertainCustomersFromOrbit(String... ids);
(from General/RoomDao/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
THE DAO OF ENTITIES
40

…or INSERT INTO ... SELECT FROM ... syntax, or pretty much any other
combination that cannot be supported directly by @Insert, @Update, and @Delete
annotations directly.
Consider @Insert, @Update, and @Delete to be “convenience annotations” for entity-
based operations, where @Query is the backbone for your DAO methods.
Transactions and Room
By default, SQLite treats each individual SQL statement as an individual transaction.
To the extent that Room winds up generating multiple SQL statements in response
to our annotations, it is Room’s responsibility to wrap those statements in a suitable
transaction.
However, sometimes, you have business logic that requires a transaction, for
operations that require multiple DAO methods. For example, persisting an invoice
might involve inserting an Invoice and all of its InvoiceLineItem objects, and that
might require more than one DAO method to achieve.
Room offers two ways of setting up app-defined transactions: the @Transaction
annotation and some methods on RoomDatabase.
Using @Transaction
Your DAO can have one or more methods that have the @Transaction annotation.
Whatever a @Transaction-annotated method does is wrapped in a SQLite
transaction. The transaction will be committed if the @Transaction-annotated
method does not throw an exception. If it does, the transaction will be rolled back.
There are two places to apply @Transaction: custom methods on an abstract DAO
class, or on @Query methods.
Custom Methods
Here, the idea is that your @Transaction-annotated method would make multiple
DAO calls to other methods (e.g., ones with @Insert or @Query annotations), so that
the work performed in those other methods “succeed or fail as a whole”.
Given our fictitious Invoice example, we might have something like this:
THE DAO OF ENTITIES
41

@Dao
public
public abstract
abstract class
class InvoiceStore
InvoiceStore {
@Insert
public
public abstract
abstract void _insert(Invoice invoice);
@Insert
public
public abstract
abstract void insert(List<InvoiceLineItem> lineItems);
@Transaction
public
public void insert(Invoice invoice) {
_insert(invoice);
insert(invoice.getLineItems());
}
}
Here, we still use an insert() method to insert an Invoice, but we use that to wrap
two DAO calls to insert the Invoice metadata and insert the InvoiceLineItem
objects.
Note that you will need to use an abstract class, not an interface, as an interface
cannot have arbitrary method implementations in them.
On @Query Methods
It may seem odd to have to specifically request a transaction on a @Query-annotated
method. After all, the default behavior of SQLite is to have each individual SQL
statement be in its own transaction.
However, there are two scenarios called out in the documentation where
@Transaction would be a good idea. One is tied to @Relation, which we will cover
later in the book.
The other is tied to a little-known issue with Android’s SQLite support: things get
weird when the result set of a query exceeds 1MB. In that case, using the regular
Android SQLiteDatabase API, the Cursor that you get back does not contain the full
result set. Instead, it contains a “window” of results, and if you position the Cursor
after that window, the query is re-executed to load in the next window. This can lead
to inconsistencies, if the database is changed in between those two database
requests to populate the window. Room, by default, will load the entire result set
into your entities, quickly moving through the windows as needed, but there is still
a chance that a database modification occurs while this is going on. Using
THE DAO OF ENTITIES
42

@Transaction would help ensure that this is not an issue, by having the entire query
— including traversing the windows — occur inside a transaction.
Using RoomDatabase
Alternatively, RoomDatabase offers the same beginTransaction(),
endTransaction(), and setTransactionSuccessful() methods that you see on
SQLiteDatabase, and so you use the same basic algorithm:
roomDb.beginTransaction();
try
try {
// bunch of DAO operations here
roomDb.setTransactionSuccessful();
}
finally
finally {
roomDb.endTransaction();
}
The advantage to this approach is that you can put the transaction logic somewhere
other than the DAO, if that would be more convenient or make more sense for your
particular implementation. However, it is a bit more work.
Threads and Room
@Insert, @Update, and @Delete-annotated methods are synchronous, performing
their work on the current thread. Hence, they should only be called from a
background thread.
@Query methods that return entities, int, tuples, etc. directly also are synchronous.
However, @Query methods that return an RxJava type (e.g., Flowable) or a LiveData
are not synchronous. Instead, the real work will be performed on a background
thread.
As noted earlier, we will explore what this “LiveData” is later in the book. For now,
take it on faith that it is another piece of the Android Architecture Components, one
that offers an alternative to RxJava for reactive programming
THE DAO OF ENTITIES
43


Room and Custom Types
So far, all of our fields have been basic primitives (int, float, etc.) or String. There
is a good reason for that: those are all that Room understands “out of the box”.
Everything else requires some amount of assistance on our part.
Sometimes, a field in an entity will be related to another entity. Those are relations,
and we will consider those in the next chapter.
However, other times, a field in an entity does not map directly to primitives and
String types, or to another entity. For example:
• What do we do with a Java Date or Calendar object? Do we want to store
that as a milliseconds-since-the-Unix-epoch value as a Java long? Do we
want to store a string representation in a standard format, for easier
readability (at the cost of disk space and other issues)?
• What do we do with a Location object? Here, we have two pieces: a latitude
and a longitude. Do we have two columns that combine into one field? Do
we convert the Location to and from a String representation?
• What do we do with collections of strings, such as lists of tags?
• What do we do with enums?
And so on.
In this chapter, we will explore two approaches for handling these things without
creating another entity class: type converters and embedded types.
45

Type Converters
Type converters are a pair of methods, annotated with @TypeConverter, that map
the type for a single database column to a type for a Java field. So, for example, we
can:
• Map a Date field to a Long, which can go in a SQLite INTEGER column
• Map a Location field to a String, which can go in a SQLite TEXT column
• Map a collection of String values to a single String (e.g., comma-separated
values), which can go in a SQLite TEXT column
• And so forth
However, type converters offer only a 1:1 conversion: a single Java field to and from a
single SQLite column. If you have a single Java field that should map to several
SQLite columns, the @Embedded approach can handle that, as we will see later in this
chapter.
Setting Up a Type Converter
First, define a Java class somewhere. The name, package, superclass, etc. do not
matter.
Next, for each type to be converted, create two public static methods that convert
from one type to the other. So for example, you would have one public static
method that takes a Date and returns a Long (e.g., returning the milliseconds-since-
the-Unix-epoch value), and a counterpart method that takes a Long and returns a
Date. If the converter method is passed null, the proper result is null. Otherwise,
the conversion is whatever you want, so long as the “round trip” works, so that the
output of one converter method, supplied as input to the other converter method,
returns the original value.
Then, each of those methods get the @TypeConverter annotation. The method
names do not matter, so pick a convention that works for you.
Finally, you add a @TypeConverters annotation, listing this and any other type
converter classes, to… something. What the “something” is controls the scope of
where that type converter can be used.
The simple solution is to add @TypeConverters to the RoomDatabase, which means
that anything associated with that database can use those type converters. However,
ROOM AND CUSTOM TYPES
46

sometimes, you may have situations where you want different conversions between
the same pair of types, for whatever reason. In that case, you can put the
@TypeConverters annotations on narrower scopes:
@TypeConverters
@TypeConverters Location
Affected Areas
Entity class
all fields in the entity
Entity field
that one field in the entity
DAO class
all methods in the DAO
DAO method
that one method in the DAO, for all parameters
DAO method parameter
that one parameter on that one method
POJO
all fields on the POJO
The General/RoomTypes sample project illustrates the use of type converters. As with
the RoomDao project from the preceding chapter, this project contains a single library
module with an associated instrumentation test case. In fact, it is a clone of the
RoomDao project, just with some type converters.
Example: Dates and Times
A typical way of storing a date/time value in a database is to use the number of
milliseconds since the Unix epoch (i.e., the number of milliseconds since midnight, 1
January 1970). Date has a getTime() method that returns this value.
So, the project has a TypeTransmogrifiers class that contains two methods, each
annotated with @TypeConverter, for converting Date to and from a Long:
@TypeConverter
public
public static
static Long fromDate(Date date) {
if
if (date==null
null) {
return
return(null
null);
}
return
return(date.getTime());
}
@TypeConverter
public
public static
static Date toDate(Long millisSinceEpoch) {
if
if (millisSinceEpoch==null
null) {
return
return(null
null);
}
return
return(new
new Date(millisSinceEpoch));
}
ROOM AND CUSTOM TYPES
47

(from General/RoomTypes/stuff/src/main/java/com/commonsware/android/room/dao/TypeTransmogrifier.java)
StuffDatabase then has the @TypeConverters annotation, listing
TypeTransmogrifier as the one class that has type conversion methods:
package
package com.commonsware.android.room.dao;
import
import android.arch.persistence.room.Database
android.arch.persistence.room.Database;
import
import android.arch.persistence.room.Room
android.arch.persistence.room.Room;
import
import android.arch.persistence.room.RoomDatabase
android.arch.persistence.room.RoomDatabase;
import
import android.arch.persistence.room.TypeConverters
android.arch.persistence.room.TypeConverters;
import
import android.content.Context
android.content.Context;
@Database(
entities={Customer.class, VersionedThingy.class},
version=1
)
@TypeConverters({TypeTransmogrifier.class})
abstract
abstract class
class StuffDatabase
StuffDatabase extends
extends RoomDatabase {
abstract
abstract StuffStore stuffStore();
private
private static
static final
final String DB_NAME="stuff.db";
private
private static
static volatile
volatile StuffDatabase INSTANCE=null
null;
synchronized
synchronized static
static StuffDatabase get(Context ctxt) {
if
if (INSTANCE==null
null) {
INSTANCE=create(ctxt, false
false);
}
return
return(INSTANCE);
}
static
static StuffDatabase create(Context ctxt, boolean memoryOnly) {
RoomDatabase.Builder<StuffDatabase> b;
if
if (memoryOnly) {
b=Room.inMemoryDatabaseBuilder(ctxt.getApplicationContext(),
StuffDatabase.class);
}
else
else {
b=Room.databaseBuilder(ctxt.getApplicationContext(), StuffDatabase.class,
DB_NAME);
}
return
return(b.build());
}
}
ROOM AND CUSTOM TYPES
48

(from General/RoomTypes/stuff/src/main/java/com/commonsware/android/room/dao/StuffDatabase.java)
Now, classes like Customer can use Date fields, which will be stored in INTEGER
columns in the database.
CREATE
CREATE TABLE
TABLE IF NOT
NOT EXISTS
EXISTS Customer (id TEXT, postalCode TEXT, displayName TEXT,
creationDate INTEGER, PRIMARY
PRIMARY KEY
KEY(`id`))
Example: Locations
A Location object contains a latitude, longitude, and perhaps other values (e.g.,
altitude). If we only care about the latitude and longitude, we could save those in the
database in a single TEXT column, so long as we can determine a good format to use
for that string. If we use Locale.US formatting for the latitude and longitude, so that
the decimal place is denoted by a ., we could use a two-element comma-separated
values list for the string.
That is what these two type converter methods on TypeTransmogrifiers do:
@TypeConverter
public
public static
static String fromLocation(Location location) {
if
if (location==null
null) {
return
return(null
null);
}
return
return(String.format(Locale.US, "%f,%f", location.getLatitude(),
location.getLongitude()));
}
@TypeConverter
public
public static
static Location toLocation(String latlon) {
if
if (latlon==null
null) {
return
return(null
null);
}
String[] pieces=latlon.split(",");
Location result=new
new Location("");
result.setLatitude(Double.parseDouble(pieces[0]));
result.setLongitude(Double.parseDouble(pieces[1]));
return
return(result);
}
(from General/RoomTypes/stuff/src/main/java/com/commonsware/android/room/dao/TypeTransmogrifier.java)
ROOM AND CUSTOM TYPES
49

Since TypeTransmogrifiers is registered on the StuffDatabase, a Customer could
have a Location field, which would be mapped to a TEXT column in the database:
CREATE
CREATE TABLE
TABLE IF NOT
NOT EXISTS
EXISTS Customer (id TEXT, postalCode TEXT, displayName TEXT,
creationDate INTEGER, officeLocation TEXT, PRIMARY
PRIMARY KEY
KEY(`id`))
However, the downside of using this approach is that we cannot readily search based
on location. If your location data is not a searchable field, and it merely needs to be
available when you load your entities from the database, using a type converter like
this is fine. Later in this chapter, we will see another approach (@Embedded) that
allows us to store the latitude and longitude as separate columns while still mapping
them to a single POJO in Java.
Example: Simple Collections
TEXT and BLOB columns are very flexible. So long as you can marshal your data into a
String or byte array, you can save that data in TEXT and BLOB columns. As with the
comma-separated values approach in the preceding section, though, columns used
this way are poor for searching.
So, suppose that you have a Set of String values that you want to store, perhaps
representing tags to associate with an entity. One approach is to have a separate Tag
entity and set up a relation. This is the best approach in many cases. But, perhaps
you do not want to do that for some reason.
You can use a type converter, but you need to decide how to represent your data in a
column. If you are certain that the tags will not contain some specific character (e.g.,
a comma), you can use the delimited-list approach demonstrated with locations in
the preceding section. If you need more flexibility than that, you can always use
JSON encoding, as these type converters do:
@TypeConverter
public
public static
static String fromStringSet(Set<String> strings) {
if
if (strings==null
null) {
return
return(null
null);
}
StringWriter result=new
new StringWriter();
JsonWriter json=new
new JsonWriter(result);
try
try {
json.beginArray();
ROOM AND CUSTOM TYPES
50

for
for (String s : strings) {
json.value(s);
}
json.endArray();
json.close();
}
catch
catch (IOException e) {
Log.e(TAG, "Exception creating JSON", e);
}
return
return(result.toString());
}
@TypeConverter
public
public static
static Set<String> toStringSet(String strings) {
if
if (strings==null
null) {
return
return(null
null);
}
StringReader reader=new
new StringReader(strings);
JsonReader json=new
new JsonReader(reader);
HashSet<String> result=new
new HashSet<>();
try
try {
json.beginArray();
while
while (json.hasNext()) {
result.add(json.nextString());
}
json.endArray();
}
catch
catch (IOException e) {
Log.e(TAG, "Exception parsing JSON", e);
}
return
return(result);
}
(from General/RoomTypes/stuff/src/main/java/com/commonsware/android/room/dao/TypeTransmogrifier.java)
Here, we use the JsonReader and JsonWriter classes that have been part of Android
since API Level 11. Alternatively, you could use a third-party JSON library (e.g.,
Gson).
ROOM AND CUSTOM TYPES
51

Note that type converter methods cannot throw checked exceptions, as the Room
code generator does not wrap type converter calls in a try/catch block. Here, the
IOExceptions should never happen, since we are working with strings, not files or
other types of streams. In other cases, though, you may need to wrap the checked
exception in some form of RuntimeException and throw that, to trigger your app’s
unhandled-exception logic, as it is unlikely that you can recover from within a type
converter method.
Given these type conversion methods, we can now use a Set of String values in
Customer:
package
package com.commonsware.android.room.dao;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.Index
android.arch.persistence.room.Index;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.location.Location
android.location.Location;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.Date
java.util.Date;
import
import java.util.HashSet
java.util.HashSet;
import
import java.util.Set
java.util.Set;
import
import java.util.UUID
java.util.UUID;
@Entity(indices={@Index(value="postalCode", unique=true
true)})
class
class Customer
Customer {
@PrimaryKey
@NonNull
public
public final
final String id;
public
public final
final String postalCode;
public
public final
final String displayName;
public
public final
final Date creationDate;
public
public final
final Location officeLocation;
public
public final
final Set<String> tags;
@Ignore
Customer(String postalCode, String displayName, Location officeLocation,
Set<String> tags) {
this
this(UUID.randomUUID().toString(), postalCode, displayName, new
new Date(),
officeLocation, tags);
}
Customer(String id, String postalCode, String displayName, Date creationDate,
Location officeLocation, Set<String> tags) {
this
this.id=id;
ROOM AND CUSTOM TYPES
52

this
this.postalCode=postalCode;
this
this.displayName=displayName;
this
this.creationDate=creationDate;
this
this.officeLocation=officeLocation;
this
this.tags=tags;
}
}
(from General/RoomTypes/stuff/src/main/java/com/commonsware/android/room/dao/Customer.java)
…where the tags will be stored in a TEXT column:
CREATE
CREATE TABLE
TABLE IF NOT
NOT EXISTS
EXISTS Customer (id TEXT, postalCode TEXT, displayName TEXT,
creationDate INTEGER, officeLocation TEXT, tags TEXT, PRIMARY
PRIMARY KEY
KEY(`id`))
Embedded Types
With type converters, we are teaching Room how to deal with custom types, but we
are limited to mapping from one field to one column. That field might be complex,
but it still goes into one column in the table.
What happens, though, when we have multiple columns that should combine to
create a single field?
In that case, we can use the @Embedded annotation on some POJO, then use that
POJO as a type in an entity.
Example: Locations
For example, as was noted earlier in this chapter, cramming a location into a single
TEXT field works, but we cannot readily query on the resulting field. If we want to
query for locations near some location in the database, it would be much more
convenient to have the latitude and longitude stored as individual REAL columns.
But, using type converters, we cannot map two columns to one field.
With @Embedded, we can, as we can see in the General/RoomEmbedded sample project.
This is a clone of the RoomTypes project from earlier in this chapter, where we have
changed Customer to have the officeLocation be represented by a LocationColumns
POJO:
package
package com.commonsware.android.room.dao;
import
import android.arch.persistence.room.Embedded
android.arch.persistence.room.Embedded;
ROOM AND CUSTOM TYPES
53

import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.Index
android.arch.persistence.room.Index;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.location.Location
android.location.Location;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.Date
java.util.Date;
import
import java.util.HashSet
java.util.HashSet;
import
import java.util.Set
java.util.Set;
import
import java.util.UUID
java.util.UUID;
@Entity(indices={@Index(value="postalCode", unique=true
true)})
class
class Customer
Customer {
@PrimaryKey
@NonNull
public
public final
final String id;
public
public final
final String postalCode;
public
public final
final String displayName;
public
public final
final Date creationDate;
@Embedded
public
public final
final LocationColumns officeLocation;
public
public final
final Set<String> tags;
@Ignore
Customer(String postalCode, String displayName, LocationColumns officeLocation,
Set<String> tags) {
this
this(UUID.randomUUID().toString(), postalCode, displayName, new
new Date(),
officeLocation, tags);
}
Customer(String id, String postalCode, String displayName, Date creationDate,
LocationColumns officeLocation, Set<String> tags) {
this
this.id=id;
this
this.postalCode=postalCode;
this
this.displayName=displayName;
this
this.creationDate=creationDate;
this
this.officeLocation=officeLocation;
this
this.tags=tags;
}
}
(from General/RoomEmbedded/stuff/src/main/java/com/commonsware/android/room/dao/Customer.java)
The @Embedded annotation tells Room to combine the columns from the annotated
type into the table for this entity. In this case, LocationColumns has two fields, for
latitude and longitude:
package
package com.commonsware.android.room.dao;
public
public class
class LocationColumns
LocationColumns {
public
public final
final double latitude;
public
public final
final double longitude;
ROOM AND CUSTOM TYPES
54

public
public LocationColumns(double latitude, double longitude) {
this
this.latitude=latitude;
this
this.longitude=longitude;
}
}
(from General/RoomEmbedded/stuff/src/main/java/com/commonsware/android/room/dao/LocationColumns.java)
LocationColumns itself is a POJO, not an entity, though you can use @ColumnInfo
annotations if needed to rename the columns associated with the POJO’s fields.
Now, Room will use individual REAL columns for our latitude and longitude:
CREATE
CREATE TABLE
TABLE IF NOT
NOT EXISTS
EXISTS Customer (id TEXT, postalCode TEXT, displayName TEXT,
creationDate INTEGER, tags TEXT, latitude REAL, longitude REAL, PRIMARY
PRIMARY KEY
KEY(id))
…and we can query on those:
@Query("SELECT * FROM Customer WHERE ABS(latitude-:lat)<.000001 AND ABS(longitude-:lon)<.000001")
List<Customer> findCustomersAt(double lat, double lon);
(from General/RoomEmbedded/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
Simple vs. Prefixed
What happens if we need two locations, though? Perhaps we need officeLocation
and affiliateLocation, or something like that.
By default, Room generates column names based on the @Embedded POJO’s field
names, perhaps modified by @ColumnInfo annotations on the POJO. In this case,
though, if we have two LocationColumns fields in the Customer entity, we would
wind up with two latitude and two longitude columns, which neither Room nor
SQLite will support.
To address this, the @Embedded annotation accepts an optional prefix property:
@Embedded(prefix = "office_")
public
public final
final LocationColumns officeLocation;
The columns for that POJO will have the prefix added:
CREATE
CREATE TABLE
TABLE IF NOT
NOT EXISTS
EXISTS Customer (id TEXT, postalCode TEXT, displayName TEXT,
creationDate INTEGER, tags TEXT, office_latitude REAL, office_longitude REAL, PRIMARY
PRIMARY
KEY
KEY(id))
ROOM AND CUSTOM TYPES
55

Hence, having two LocationColumns simply means that one or both need to use
distinct prefix values.
However, bear in mind that this changes the column names, so you will also need to
adjust any @Query method that references those names, so that you use the
appropriate prefix.
Updating the Trip Sample
Back in the chapter on Room basics, we started in on an app to track upcoming
travel. The Trips/RoomConverters sample project extends that app with four new
fields on Trip:
•
priority, representing how important the trip is to the user
•
startTime, indicating when the trip is to begin
•
creationTime, indicating when the Trip was first created… somewhere
•
updateTime, indicating when the Trip was last changed… somewhere
Those latter two are largely ignored for the moment, though they will become more
important later in the book.
The latter three are all Date fields, and so we need to have some code to support
getting them into and out of our table. So, this project has a TypeTransmogrifier
class, akin to the ones seen above, but right now only with the Date converters:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.TypeConverter
android.arch.persistence.room.TypeConverter;
import
import java.util.Date
java.util.Date;
public
public class
class TypeTransmogrifier
TypeTransmogrifier {
@TypeConverter
public
public static
static Long fromDate(Date date) {
if
if (date==null
null) {
return
return(null
null);
}
return
return(date.getTime());
}
@TypeConverter
public
public static
static Date toDate(Long millisSinceEpoch) {
if
if (millisSinceEpoch==null
null) {
ROOM AND CUSTOM TYPES
56

return
return(null
null);
}
return
return(new
new Date(millisSinceEpoch));
}
}
(from Trips/RoomConverters/app/src/main/java/com/commonsware/android/room/TypeTransmogrifier.java)
priority, though, is an enum, as there is a list of valid values:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.TypeConverter
android.arch.persistence.room.TypeConverter;
enum
enum Priority {
LOW(0), MEDIUM(1), HIGH(2), OMG(3);
private
private final
final int level;
@TypeConverter
public
public static
static Priority fromLevel(Integer level) {
for
for (Priority p : values()) {
if
if (p.level==level) {
return
return(p);
}
}
return
return(null
null);
}
@TypeConverter
public
public static
static Integer fromPriority(Priority p) {
return
return(p.level);
}
Priority(int level) {
this
this.level=level;
}
}
(from Trips/RoomConverters/app/src/main/java/com/commonsware/android/room/Priority.java)
Here, we implement the @TypeConverter methods right on Priority, as there is
little value in having them elsewhere. Note that the enum assigns explicit numeric
values to the priorities (level). That way, we are in control over the mapping
between Priority values and their representation in the database.
ROOM AND CUSTOM TYPES
57

Rather than apply these type converters on the TripDatabase (though we could), we
instead apply them on the Trip model:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.arch.persistence.room.TypeConverters
android.arch.persistence.room.TypeConverters;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.Date
java.util.Date;
import
import java.util.UUID
java.util.UUID;
@Entity(tableName = "trips")
@TypeConverters({TypeTransmogrifier.class})
class
class Trip
Trip {
@PrimaryKey
@NonNull
public
public final
final String id;
public
public final
final String title;
public
public final
final int duration;
@TypeConverters({Priority.class})
public
public final
final Priority priority;
public
public final
final Date startTime;
public
public final
final Date creationTime;
public
public final
final Date updateTime;
@Ignore
Trip(String title, int duration, Priority priority, Date startTime) {
this
this(UUID.randomUUID().toString(), title, duration, priority, startTime,
null
null, null
null);
}
Trip(String id, String title, int duration, Priority priority,
Date startTime, Date creationTime, Date updateTime) {
this
this.id=id;
this
this.title=title;
this
this.duration=duration;
this
this.priority=priority;
this
this.startTime=startTime;
this
this.creationTime=creationTime;
this
this.updateTime=updateTime;
}
ROOM AND CUSTOM TYPES
58

@Override
public
public String toString() {
return
return(title);
}
}
(from Trips/RoomConverters/app/src/main/java/com/commonsware/android/room/Trip.java)
The Priority type converters are applied specific to the priority field, as this
specific conversion is only needed here. The TypeTransmogrifier is registered on
the Trip class, as there are multiple Date fields.
ROOM AND CUSTOM TYPES
59


Room and Relations
SQLite is a relational database. At some point, Room should support relations.
Right?
Right?!?
Well, actually, the story is a bit more complicated than that. Yes, Room supports
entities being related to other content in other tables. Room does not support
entities being directly related to other entities, though.
And if that sounds strange, there is “a method to the madness”.
In this chapter, we will explore how you implement relational structures with Room
and why Room has the restrictions that it does.
The Classic ORM Approach
Java ORMs have long supported entities having relations to other entities, though
not every ORM uses the “entity” term.
One Android ORM that does is greenDAO. It allows you to use annotations to
indicate relations, such as:
@Entity
public
public class
class Thingy
Thingy {
@Id private
private Long id;
private
private long otherThingyId;
@ToOne(joinProperty="otherThingyId")
61

private
private OtherThingy otherThingy;
// other good stuff here
}
@Entity
public
public class
class OtherThingy
OtherThingy {
@ID private
private Long id;
}
These annotations result in getOtherThingy() and setOtherThingy() methods to
be synthetically added to Thingy (or, more accurately, to a hidden subclass of
Thingy, but for the purposes of this section, we will ignore that). Which
OtherThingy our Thingy relates to is tied to that otherThingyId field, which is
stored as a column in the table. When you call getOtherThingy(), greenDAO will
query the database to load in the OtherThingy instance, assuming that it has not
been cached already.
That is where the threading problem creeps in.
A History of Threading Mistakes
In Android app development, we are constantly having to fight to keep disk I/O off
of the main application thread. Every millisecond that our code executes on the
main application thread is a millisecond that the main application thread is not
updating our UI. Disk I/O — such as queries on complex structures – can easily take
dozens or hundreds of milliseconds, particularly on older or low-end devices. As a
result, we freeze our UI while that disk I/O is occurring, possibly resulting in visual
“jank” for the user. Our objective is to move as much disk I/O as possible off the
main application thread.
The problem is that the nice encapsulation that we get from object-oriented
programming also encapsulates knowledge of whether disk I/O will be done when
we call a particular method.
Classic use of SQLiteDatabase encounters this with the rawQuery()/query() family
of methods. They return a Cursor. You might think — reasonably – that those
methods execute the SQL query that you request. In truth, they do not. All they do
is create a SQLiteCursor instance that holds onto the query and the
SQLiteDatabase. Later, when you call a method that requires the actual query result
(e.g., getCount(), to get the number of returned rows), then the query is executed
against the database. As a result, all the work that you do to call rawQuery() or
ROOM AND RELATIONS
62

query() on a background thread gets wasted if you do not also do something to
force the query to be executed on that same background thread. Otherwise, you may
wind up with the query being executed on the main application thread, with
impacts on the UI.
greenDAO relations can work the same way. If you retrieve your Thingy on a
background thread, then call getOtherThingy() on the main application thread,
depending on what else has all occurred, getOtherThingy() might need to perform
a database query… which you do not want on the main application thread.
The Room Approach
Room behaves a bit like other annotation-based Android ORMs, but when it comes
to relations, Room departs from norms, in an effort to reduce the likelihood of
threading problems.
No Direct Entity References
Unlike the greenDAO example above, with Room, a Thingy cannot have a field for
an OtherThingy that Room is expected to manage. You could have a field for an
OtherThingy marked as @Ignore, but then you are on your own for dealing with that
field.
The implication of an entity referencing another entity directly is that developers
would expect that when Room retrieves the outer entity, that Room either will
automatically retrieve the inner entity or will retrieve it lazily later on. The former
approach avoids threading issues but runs the risk of loading more data than is
necessary. The latter approach runs the risk of trying to do disk I/O on the main
application thread.
Foreign Keys
This does not mean that you cannot have foreign keys. Room fully supports foreign
key relationships, by way of a @ForeignKey annotation. This sets up the foreign keys
in the appropriate tables… but that’s about it. Room does very little else with these
keys.
ROOM AND RELATIONS
63

Cascades on Updates and Deletes
Part of what you can place on a @ForeignKey annotation are onUpdate and onDelete
properties. These indicate what actions should be taken on this entity when the
parent of the foreign key relationship is updated or deleted. There are five
possibilities, denoted by ForeignKey constants:
Constant
Name
If the Parent Is Updated or Deleted…
NO_ACTION
…do nothing
CASCADE
…update or delete the child
RESTRICT
…fail the parent’s update or delete operation, unless there are no
children
SET_NULL
…set the foreign key value to null
SET_DEFAULT
…set the foreign key value to the column(s) default value
NO_ACTION is the default, though CASCADE will be a popular choice.
Cascades on… Retrievals?
You cannot have an entity automatically retrieve related objects via a @Query.
You can have an arbitrary POJO automatically retrieve related objects via a @Query,
by means of a @Relation annotation.
This seeming inconsistency will be explored later in this chapter.
Plans for Trips
Let’s explore how @ForeignKey works by adding some more entities to the trip-
tracking app, as seen in the Trips/RoomRelations sample project.
The app itself does not make use of these new changes in its fledgling UI — we will
address that much later in the book. This sample also drops off the mock-database
unit tests. For now, the focus is on adding the necessary Room bits and updating the
instrumentation tests.
ROOM AND RELATIONS
64

The Domain Model
In the beginning, we had just the Trip entity. However, a trip is made up of lots of
pieces, so in this sample, we add two more: flights and lodgings. Not surprisingly,
these come in the form of Flight and Lodging entity classes. A Trip can have zero
or more related Flight instances and zero or more related Lodging instances.
However, many of the pieces of data that we need to track for these things – title,
duration, start time, etc. — are in common. So, we will pull those things into an
abstract base class named Plan, from which Trip, Flight, and Lodging will all
inherit.
The New Entities
As a result, Plan itself is pretty much what Trip used to be:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.arch.persistence.room.TypeConverters
android.arch.persistence.room.TypeConverters;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.Date
java.util.Date;
import
import java.util.UUID
java.util.UUID;
abstract
abstract class
class Plan
Plan {
@PrimaryKey
@NonNull
public
public final
final String id;
public
public final
final String title;
public
public final
final int duration;
@TypeConverters({Priority.class})
public
public final
final Priority priority;
public
public final
final Date startTime;
public
public final
final Date creationTime;
public
public final
final Date updateTime;
@Ignore
Plan(String title, int duration, Priority priority, Date startTime) {
this
this(UUID.randomUUID().toString(), title, duration, priority, startTime,
null
null, null
null);
}
ROOM AND RELATIONS
65

Plan(String id, String title, int duration, Priority priority,
Date startTime, Date creationTime, Date updateTime) {
this
this.id=id;
this
this.title=title;
this
this.duration=duration;
this
this.priority=priority;
this
this.startTime=startTime;
this
this.creationTime=creationTime;
this
this.updateTime=updateTime;
}
@Override
public
public String toString() {
return
return(title);
}
}
(from Trips/RoomRelations/app/src/main/java/com/commonsware/android/room/Plan.java)
Note that while we have the Priority TypeConverter registered for the Priority
field, we do not have the TypeTransmogrifier registered on the Plan class, the way
we had it for Trip. That is due to a limitation in Room, whereby class-level
@TypeConverters annotations are not inherited, though field-level ones are.
Instead, the TypeTransmogrifier @TypeConverters annotation appears on our rump
Trip class:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.arch.persistence.room.TypeConverters
android.arch.persistence.room.TypeConverters;
import
import java.util.Date
java.util.Date;
import
import java.util.UUID
java.util.UUID;
@Entity(tableName = "trips")
@TypeConverters({TypeTransmogrifier.class})
class
class Trip
Trip extends
extends Plan {
@Ignore
Trip(String title, int duration, Priority priority, Date startTime) {
super
super(title, duration, priority, startTime);
}
Trip(String id, String title, int duration,
Priority priority, Date startTime, Date creationTime,
ROOM AND RELATIONS
66

Date updateTime) {
super
super(id, title, duration, priority, startTime, creationTime, updateTime);
}
}
(from Trips/RoomRelations/app/src/main/java/com/commonsware/android/room/Trip.java)
The relations that we are setting up from Trip to Flight and Lodging are 1:N
relations. As such, the parent (Trip) does not need any foreign keys. Those are held
by the children of the relation… such as Lodging:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.ForeignKey
android.arch.persistence.room.ForeignKey;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.Index
android.arch.persistence.room.Index;
import
import android.arch.persistence.room.TypeConverters
android.arch.persistence.room.TypeConverters;
import
import java.util.Date
java.util.Date;
import
import static
static android.arch.persistence.room.ForeignKey.CASCADE;
@Entity(
tableName="lodgings",
foreignKeys=@ForeignKey(
entity=Trip.class,
parentColumns="id",
childColumns="tripId",
onDelete=CASCADE),
indices=@Index("tripId"))
@TypeConverters({TypeTransmogrifier.class})
class
class Lodging
Lodging extends
extends Plan {
public
public final
final String address;
public
public final
final String tripId;
@Ignore
Lodging(String title, int duration, Priority priority, Date startTime,
String address, String tripId) {
super
super(title, duration, priority, startTime);
this
this.address=address;
this
this.tripId=tripId;
}
Lodging(String id, String title, int duration,
Priority priority, Date startTime, Date creationTime,
Date updateTime, String address, String tripId) {
super
super(id, title, duration, priority, startTime, creationTime, updateTime);
this
this.address=address;
ROOM AND RELATIONS
67

this
this.tripId=tripId;
}
}
(from Trips/RoomRelations/app/src/main/java/com/commonsware/android/room/Lodging.java)
Here, Lodging also extends from Plan, adding two fields, one to track the address of
the hotel (or whatever) and the tripId of the Trip that contains this Lodging. That
tripId field is then referenced in the @ForeignKey annotation,which:
• Sets up the relation as being with Trip (entity=Trip.class)
• Ties the id column on Trip (parentColumns="id") to the tripId on Lodging
(childColumns="tripId")
• Indicates that if the Trip is deleted, associated Lodging instances should also
be deleted (onDelete=CASCADE)
Lodging also sets up an index on tripId (indices=@Index("tripId")). Querying on
tripId will be fairly common, as we look up the Lodging instances associated with a
given Trip. Hence, typically you will want to set up an index on your foreign keys.
Room will even warn you about this, if you examine the Gradle Console output from
a build.
Flight works similarly:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.ForeignKey
android.arch.persistence.room.ForeignKey;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.Index
android.arch.persistence.room.Index;
import
import android.arch.persistence.room.TypeConverters
android.arch.persistence.room.TypeConverters;
import
import java.util.Date
java.util.Date;
import
import static
static android.arch.persistence.room.ForeignKey.CASCADE;
@Entity(
tableName="flights",
foreignKeys=@ForeignKey(
entity=Trip.class,
parentColumns="id",
childColumns="tripId",
onDelete=CASCADE),
indices=@Index("tripId"))
@TypeConverters({TypeTransmogrifier.class})
class
class Flight
Flight extends
extends Plan {
public
public final
final String departingAirport;
ROOM AND RELATIONS
68

public
public final
final String arrivingAirport;
public
public final
final String airlineCode;
public
public final
final String flightNumber;
public
public final
final String seatNumber;
public
public final
final String tripId;
@Ignore
Flight(String title, int duration, Priority priority, Date startTime,
String departingAirport, String arrivingAirport, String airlineCode,
String flightNumber, String seatNumber, String tripId) {
super
super(title, duration, priority, startTime);
this
this.departingAirport=departingAirport;
this
this.arrivingAirport=arrivingAirport;
this
this.airlineCode=airlineCode;
this
this.flightNumber=flightNumber;
this
this.seatNumber=seatNumber;
this
this.tripId=tripId;
}
Flight(String id, String title, int duration,
Priority priority, Date startTime, Date creationTime,
Date updateTime, String departingAirport, String arrivingAirport,
String airlineCode, String flightNumber, String seatNumber,
String tripId) {
super
super(id, title, duration, priority, startTime, creationTime, updateTime);
this
this.departingAirport=departingAirport;
this
this.arrivingAirport=arrivingAirport;
this
this.airlineCode=airlineCode;
this
this.flightNumber=flightNumber;
this
this.seatNumber=seatNumber;
this
this.tripId=tripId;
}
}
(from Trips/RoomRelations/app/src/main/java/com/commonsware/android/room/Flight.java)
The Updated DAO and Database
Since we added new entities, TripDatabase needs to know about them, via the
entities property on the @Database annotation:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Database
android.arch.persistence.room.Database;
import
import android.arch.persistence.room.Room
android.arch.persistence.room.Room;
import
import android.arch.persistence.room.RoomDatabase
android.arch.persistence.room.RoomDatabase;
import
import android.content.Context
android.content.Context;
ROOM AND RELATIONS
69

@Database(
entities={Trip.class, Lodging.class, Flight.class},
version=2
)
abstract
abstract class
class TripDatabase
TripDatabase extends
extends RoomDatabase {
abstract
abstract TripStore tripStore();
private
private static
static final
final String DB_NAME="trips.db";
private
private static
static volatile
volatile TripDatabase INSTANCE=null
null;
synchronized
synchronized static
static TripDatabase get(Context ctxt) {
if
if (INSTANCE==null
null) {
INSTANCE=create(ctxt, false
false);
}
return
return(INSTANCE);
}
static
static TripDatabase create(Context ctxt, boolean memoryOnly) {
RoomDatabase.Builder<TripDatabase> b;
if
if (memoryOnly) {
b=Room.inMemoryDatabaseBuilder(ctxt.getApplicationContext(),
TripDatabase.class);
}
else
else {
b=Room.databaseBuilder(ctxt.getApplicationContext(), TripDatabase.class,
DB_NAME);
}
return
return(b.build());
}
}
(from Trips/RoomRelations/app/src/main/java/com/commonsware/android/room/TripDatabase.java)
Note that now we are still on version=2. Ideally, this sort of change would involve
updating an existing database in-place, so as not to disturb any existing data. Room
calls these “migrations”, and they are covered in an upcoming chapter.
TripStore, our DAO, now needs methods for Lodging and Flight as well:
package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Dao
android.arch.persistence.room.Dao;
import
import android.arch.persistence.room.Delete
android.arch.persistence.room.Delete;
ROOM AND RELATIONS
70

import
import android.arch.persistence.room.Insert
android.arch.persistence.room.Insert;
import
import android.arch.persistence.room.OnConflictStrategy
android.arch.persistence.room.OnConflictStrategy;
import
import android.arch.persistence.room.Query
android.arch.persistence.room.Query;
import
import android.arch.persistence.room.Update
android.arch.persistence.room.Update;
import
import java.util.List
java.util.List;
@Dao
interface
interface TripStore
TripStore {
/*
Trip
*/
@Query("SELECT * FROM trips ORDER BY title")
List<Trip> selectAllTrips();
@Query("SELECT * FROM trips WHERE id=:id")
Trip findTripById(String id);
@Insert
void insert(Trip... trips);
@Update
void update(Trip... trips);
@Delete
void delete(Trip... trips);
/*
Lodging
*/
@Query("SELECT * FROM lodgings WHERE tripId=:tripId")
List<Lodging> findLodgingsForTrip(String tripId);
@Insert
void insert(Lodging... lodgings);
@Update
void update(Lodging... lodgings);
@Delete
void delete(Lodging... lodgings);
/*
Flight
*/
@Query("SELECT * FROM flights WHERE tripId=:tripId")
ROOM AND RELATIONS
71

List<Flight> findFlightsForTrip(String tripId);
@Insert
void insert(Flight... flights);
@Update
void update(Flight... flights);
@Delete
void delete(Flight... flights);
}
(from Trips/RoomRelations/app/src/main/java/com/commonsware/android/room/TripStore.java)
The Lodging and Flight @Query methods retrieve only those for a particular Trip,
based on the ID. There is nothing stopping us from having other @Query methods
(e.g., searching across all Lodging, regardless of Trip), but these will suffice for now.
We could elect to have separate DAO classes for each entity, or have nested @Dao-
annotated classes inside the entity for these sorts of methods. In those cases,
TripDatabase would have to be augmented with additional abstract methods to
return instances of those classes, mirroring the existing tripStore() method.
Self-Referential Relations for Tree Structures
With care, you can use Room for self-referential relations: an entity having a foreign
key back to itself. This is most commonly seen in tree structures:
• Categories having sub-categories
• Folders having folders and items
• And so on
The General/RoomTree sample project demonstrates the first of those examples: a
Category entity that has an optional parent Category:
package
package com.commonsware.android.room.dao;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.ForeignKey
android.arch.persistence.room.ForeignKey;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.Index
android.arch.persistence.room.Index;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.UUID
java.util.UUID;
ROOM AND RELATIONS
72

import
import static
static android.arch.persistence.room.ForeignKey.CASCADE;
@Entity(
tableName="categories",
foreignKeys=@ForeignKey(
entity=Category.class,
parentColumns="id",
childColumns="parentId",
onDelete=CASCADE),
indices=@Index(value="parentId"))
class
class Category
Category {
@PrimaryKey
@NonNull
public
public final
final String id;
public
public final
final String title;
public
public final
final String parentId;
@Ignore
Category(String title) {
this
this(title, null
null);
}
@Ignore
public
public Category(String title, String parentId) {
this
this(UUID.randomUUID().toString(), title, parentId);
}
public
public Category(@NonNull String id, String title, String parentId) {
this
this.id=id;
this
this.title=title;
this
this.parentId=parentId;
}
}
(from General/RoomTree/stuff/src/main/java/com/commonsware/android/room/dao/Category.java)
Here, Category has a @ForeignKey that points back to Category as the entity, with
a parentId column holding the id of the parent Category. onDelete is set to
CASCADE, so that when a parent Category is deleted, its children are deleted as well.
Now we can have DAO methods that work with the Category tree:
@Query("SELECT * FROM categories")
List<Category> selectAllCategories();
@Query("SELECT * FROM categories WHERE parentId IS NULL")
Category findRootCategory();
ROOM AND RELATIONS
73

@Query("SELECT * FROM categories WHERE parentId=:parentId")
List<Category> findChildCategories(String parentId);
@Insert
void insert(Category... categories);
@Delete
void delete(Category... categories);
(from General/RoomTree/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
Using @Relation
If you have a POJO class — one that does not directly have the @Entity annotation
— you can use @Relation to automatically retrieve entities related to… something in
the POJO.
For example, in other Android ORMs, one might expect that Category would have
methods, fields, or something to get at the parent Category (where there is one) or
the child Category instances (where there are some). However, that is not supported
by Room and @Entity, but it is supported by separate POJO classes.
To that end, we can set up a CategoryTuple:
package
package com.commonsware.android.room.dao;
import
import android.arch.persistence.room.Relation
android.arch.persistence.room.Relation;
import
import java.util.List
java.util.List;
public
public class
class CategoryTuple
CategoryTuple {
public
public final
final String id;
public
public final
final String title;
public
public final
final String parentId;
public
public CategoryTuple(String id, String title, String parentId) {
this
this.id=id;
this
this.title=title;
this
this.parentId=parentId;
}
@Relation(parentColumn="id", entityColumn="parentId")
public
public List<Category> children;
@Relation(parentColumn="parentId", entityColumn="id")
ROOM AND RELATIONS
74

public
public List<Category> parents;
}
(from General/RoomTree/stuff/src/main/java/com/commonsware/android/room/dao/CategoryTuple.java)
Here, we have two @Relation annotations. These go on fields, not methods, and they
indicate fields that Room should fill in when a @Query returns instances of this
POJO. The field type needs to be a List or Set of the related entity, not the POJO.
Hence, children and parents are lists of Category instances, not CategoryTuple.
The two required properties on @Relation are parentColumn and entityColumn.
entityColumn is the name of a column in the entity’s table; parentColumn is the
name of a field in the POJO representing the parent entity. In this case, the entity for
both is Category, as we are working with a self-referential relation. In the generated
code, Room is going to run a query that finds all objects whose entityColumn has
the value pulled from this POJO’s parentColumn field. More specifically:
• For the children field, Room will query the categories table to return all
rows where the parentId column equals the id of this CategoryTuple
• For the parent field, Room will query the categories table to return all rows
where the id column equals the parentId of this CategoryTuple
For a 1:N relation, Room’s restriction on @Relation data types (must be List or Set)
means that both the 1 side and the N side get represented by collection fields… even
though one should only ever have at most one element.
If there are no matching entities (e.g., no parent for the root Category, no children
for a leaf Category), the resulting field is either null or an empty collection.
But now, our DAO methods will not only set up the POJOs but all entities that are
called for by the @Relation fields:
@Transaction
@Query("SELECT * FROM categories WHERE parentId IS NULL")
CategoryTuple findRootCategoryTuple();
@Transaction
@Query("SELECT * FROM categories WHERE parentId=:parentId")
List<CategoryTuple> findChildCategoryTuples(String parentId);
(from General/RoomTree/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
ROOM AND RELATIONS
75

However, this involved a lot of copying. CategoryTuple has the same fields as
Category. It would not have to have all of those fields, of course, as a POJO need not
have fields for all columns in the table. But, still, it seems to be a bit wasteful.
Another related approach is to create a “POJO” subclass of the entity… such as this
CategoryShadow:
package
package com.commonsware.android.room.dao;
import
import android.arch.persistence.room.Relation
android.arch.persistence.room.Relation;
import
import java.util.List
java.util.List;
public
public class
class CategoryShadow
CategoryShadow extends
extends Category {
public
public CategoryShadow(String id, String title, String parentId) {
super
super(id, title, parentId);
}
@Relation(parentColumn="id", entityColumn="parentId")
public
public List<Category> children;
}
(from General/RoomTree/stuff/src/main/java/com/commonsware/android/room/dao/CategoryShadow.java)
Even though CategoryShadow inherits from Category, and even though Category is
an entity, Room treats CategoryShadow as a POJO, and we can have @Relation fields,
such as the children one shown. If you need most or all of the fields from the entity,
this subclass approach involves less code duplication than does the standalone-
POJO approach.
@Relation and @Query
If you use @Relation, it is a good idea to add the @Transaction annotation to any
related @Query. That ensures that the initial query that populates the POJO, plus the
query (or queries) necessary to resolve the @Relation, are all performed inside a
transaction and therefore will have consistency.
By default, @Transaction logic is not applied to @Query methods returning POJOs
with @Relation, and it is possible that you would wind up with inconsistent results,
if the database was modified while the @Query was being processed. Unfortunately,
this has been deemed as “working as intended”.
This is why the @Query methods on StuffStore that return CategoryTuple or
CategoryShadow also have the @Transaction annotation.
ROOM AND RELATIONS
76

Representing No Relation
While much of this book will use UUID values for primary keys, plenty of other Room
examples will use int, particularly with autoGenerate set to true, to have SQLite
generate the keys.
However, this does not work well if those keys will be used as foreign key values, in
cases where there may be no value for the relation.
For example, Category uses String for its id (created from a UUID), and we
represented a root category by means of having null for its parentId value. That
works because String fields can be null.
If, however, we used int, we have no way of representing the no-relation scenario.
You cannot assign null to an int field in Java.
Hence, if you want to support the no-relation scenario, your foreign key field needs
to allow for null values. If you want to use auto-generated SQLite identifiers, use
Integer, not int.
ROOM AND RELATIONS
77


Room and Migrations
When you first ship your app, you think your database schema is beautiful, a true
work of art.
Then, you wake up the next morning and realize that you need to make changes to
that schema.
During initial development — and for silly little book examples — you just go in and
make changes to your entities, and Room will rebuild your database for you.
However, it does so by dropping all of your existing tables, taking all the data with it.
In development, that may not be so bad. In production… well, let’s just say that users
get a little irritated when you lose their data.
And that’s where migrations come into play.
What’s a Migration?
With traditional Android SQLite development, we typically use SQLiteOpenHelper.
This utility class manages a SQLiteDatabase for us and addresses two key problems:
1. What happens when our app first runs on a device — or after the user has
cleared our app’s data — and we have no database at all?
2. What happens when we need to modify the database schema from what it
was to some new structure?
SQLiteOpenHelper would do that by calling onCreate() and onUpgrade() callbacks,
where we could implement the logic to create the tables and adjust them as the
schemas change.
79

While onCreate() worked reasonably well, onUpgrade() rapidly grew out of control.
Long-lived apps might have dozens of different schemas, evolving over time.
Because users are not forced to take on app updates, our apps need to be able to
transition from any prior schema to the latest-and-greatest one. This meant that
onUpgrade() would need to identify exactly what bits of code are needed to migrate
the database from the old to the new version, and this could get unwieldy.
Room addresses this somewhat through the Migration class. You create subclasses
of Migration — typically as anonymous inner classes — that handle the conversion
from some older schema to a newer one. You pass a bunch of Migration instances to
Room, representing different pair-wise schema upgrade paths. Room then
determines which one(s) need to be used at any point in time, to update the schema
from whatever it was to whatever it needs to be.
When Do We Migrate?
On our RoomDatabase subclass, we have a @Database annotation. One of the
properties is version. This works like the version code that we would pass into the
SQLiteOpenHelper constructor. It is a monotonically increasing integer, with higher
numbers indicating newer schemas. The version in the code represents the schema
version that this code is expecting.
Once your app ships, any time you change your schema — mostly in the form of
modifying entity classes — you need to increment that version and create a
Migration that knows how to convert from the prior version to this new one.
Note that there is no requirement that you increment the version by 1, though that
is a common convention. If using a date-based format like YYYMMDD (e.g., 20170627)
makes your life easier, you are welcome to do so.
But First, a Word About the Support Database
Classes
So far, this book has portrayed Room as being an ORM-style bridge between your
code and SQLite.
Technically, that is not accurate.
ROOM AND MIGRATIONS
80

Part of what we get with Room is a series of classes and interfaces in the
android.support.persistence.db package. These classes come from a separate
artifact (android.arch.persistence.room:support-db) and represent an
abstraction for SQLite-style database access.
We also get implementations of that abstraction, in the form of the “framework”
classes (from android.arch.persistence.room:support-db-impl). Those classes
use the Android standard SQLite environment. Room’s artifacts pull in these
support artifacts by default, and when we use RoomDatabase.Builder to set up our
RoomDatabase, we are using those “framework” classes for the database access.
There are two reasons why this is important.
First, database migrations are largely outside of Room itself. Room is expecting the
database to be set up with the appropriate schema. While a RoomDatabase.Builder
can use Migration objects to migrate the database schema, Room itself is not yet
ready at this point. We wind up using a SupportSQLiteDatabase class for modifying
the schema, where this class is from that abstraction library. So, while most of Room
hides you from most of SQLite-related Java code, migrations are one area where this
stuff becomes more visible.
Second, just because Room uses the device implementation of SQLite by default
does not mean that you have to use it. One of the methods on
RoomDatabase.Builder is openHelperFactory(), where you supply a
SupportSQLiteOpenHelper.Factory to use for working with the database. That, in
turn, can pull in another whole set of implementations of the database abstraction.
For example, you can use this approach to have Room interoperate with SQLCipher
for Android, an encrypted edition of SQLite. A later chapter will explore such a
library. And, a future update to this book will explain more about the support
database API.
…And a Word About Exporting Schemas
One of the side-effects of using Room is that you do not write your own schema for
the database. Room generates it, based on your entity definitions. During the
ordinary course of programming, this is perfectly fine and saves you time and effort.
However, when it comes to migrations, now we have a problem. We cannot create
code to migrate from an old to a new schema without knowing what those schemas
are. And while schema information is baked into some code generated by Room’s
ROOM AND MIGRATIONS
81

annotation processor, that is only for the current version of your entity classes (and,
hence, your current schema), not for any historical ones.
Fortunately, Room offers something that helps a bit: exported schemas. You can
teach Room’s annotation processor to not only generate Java code but also generate
a JSON document describing the schema. Moreover, it will do that for each schema
version, saving them to version-specific JSON files. If you hold onto these files — for
example, if you save them in version control – you will have a history of your schema
and can use that information to write your migrations.
However, the real reason for those exported schemas is to help with testing your
migrations. As a result, the JSON format is not designed for developers to read.
To set this up, in the defaultConfig closure of your module’s build.gradle file, you
can add the following javaCompileOptions closure:
javaCompileOptions {
annotationProcessorOptions {
arguments = ["room.schemaLocation": "$projectDir/schemas".toString()]
}
}
(from Trips/RoomMigrations/app/build.gradle)
This teaches Room to save your schemas in a schemas/ directory off of the module
root directory. In principle, you could store them elsewhere by choosing a different
value for the room.schemaLocation argument.
The next time you (re-)build your project, that directory will be created.
Subdirectories with the fully-qualified class names of your RoomDatabase classes will
go inside there, and inside each of those will be a JSON file named after your schema
version (e.g., 1.json):
{
"formatVersion": 1,
"database": {
"version": 1,
"identityHash": "d46bfccddeca286f2948a702a4938d56",
"entities": [
{
"tableName": "trips",
"createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, `title` TEXT,
`duration` INTEGER NOT NULL, `priority` INTEGER, `startTime` INTEGER, `creationTime` INTEGER, `updateTime`
INTEGER, PRIMARY KEY(`id`))",
"fields": [
{
"fieldPath": "id",
ROOM AND MIGRATIONS
82

"columnName": "id",
"affinity": "TEXT"
},
{
"fieldPath": "title",
"columnName": "title",
"affinity": "TEXT"
},
{
"fieldPath": "duration",
"columnName": "duration",
"affinity": "INTEGER"
},
{
"fieldPath": "priority",
"columnName": "priority",
"affinity": "INTEGER"
},
{
"fieldPath": "startTime",
"columnName": "startTime",
"affinity": "INTEGER"
},
{
"fieldPath": "creationTime",
"columnName": "creationTime",
"affinity": "INTEGER"
},
{
"fieldPath": "updateTime",
"columnName": "updateTime",
"affinity": "INTEGER"
}
],
"primaryKey": {
"columnNames": [
"id"
],
"autoGenerate": false
false
},
"indices": [],
"foreignKeys": []
}
],
"setupQueries": [
"CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
"INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42,
\"
\"d46bfccddeca286f2948a702a4938d56\"
\")"
]
}
}
(from Trips/RoomMigrations/app/schemas/com.commonsware.android.room.TripDatabase/1.json)
The JSON properties that will matter to you will be the createSql ones. There are
ones that create your tables and others that create your indexes.
ROOM AND MIGRATIONS
83

Writing Migrations
A Migration itself has only one required method: migrate(). You are given a
SupportSQLiteDatabase, which resembles a SQLiteDatabase and allows you to
execute SQL statements to modify the schema as needed.
The Migration constructor takes two parameters: the old schema version number
and the new schema version number. Hence, the recommended pattern is to use
anonymous inner classes, where you can provide the migrate() method to use for
migrating the schema between that particular pair of schema versions.
To determine what needs to be done, you need to examine that schema JSON and
determine what is different between the old and the new. Someday, we may get
some tools to help with this. For now, you are largely stuck “eyeballing” the SQL. You
can then craft the ALTER TABLE or other statements necessary to change the schema,
much as you might have done in onUpgrade() of a SQLiteOpenHelper.
For example, the Trips/RoomMigrations sample project has a FROM_1_TO_2
migration:
static
static final
final Migration FROM_1_TO_2=new
new Migration(1,2) {
@Override
public
public void migrate(SupportSQLiteDatabase db) {
db.execSQL("CREATE TABLE IF NOT EXISTS `lodgings` (`id` TEXT NOT NULL, `title` TEXT, `duration`
INTEGER NOT NULL, `priority` INTEGER, `startTime` INTEGER, `creationTime` INTEGER, `updateTime` INTEGER,
`address` TEXT, `tripId` TEXT, PRIMARY KEY(`id`), FOREIGN KEY(`tripId`) REFERENCES `trips`(`id`) ON UPDATE
NO ACTION ON DELETE CASCADE )");
db.execSQL("CREATE  INDEX `index_lodgings_tripId` ON `lodgings` (`tripId`)");
db.execSQL("CREATE TABLE IF NOT EXISTS `flights` (`id` TEXT NOT NULL, `title` TEXT, `duration`
INTEGER NOT NULL, `priority` INTEGER, `startTime` INTEGER, `creationTime` INTEGER, `updateTime` INTEGER,
`departingAirport` TEXT, `arrivingAirport` TEXT, `airlineCode` TEXT, `flightNumber` TEXT, `seatNumber`
TEXT, `tripId` TEXT, PRIMARY KEY(`id`), FOREIGN KEY(`tripId`) REFERENCES `trips`(`id`) ON UPDATE NO ACTION
ON DELETE CASCADE )");
db.execSQL("CREATE  INDEX `index_flights_tripId` ON `flights` (`tripId`)");
}
};
(from Trips/RoomMigrations/app/src/main/java/com/commonsware/android/room/Migrations.java)
Here, we create two tables and two indexes in migrate(). The SQL is mostly copied
from the 2.json file, representing the schema for version 2:
{
"formatVersion": 1,
"database": {
"version": 2,
"identityHash": "69efe3a24b62764afa37e5eb0f162fd9",
"entities": [
ROOM AND MIGRATIONS
84

{
"tableName": "trips",
"createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, `title` TEXT,
`duration` INTEGER NOT NULL, `priority` INTEGER, `startTime` INTEGER, `creationTime` INTEGER, `updateTime`
INTEGER, PRIMARY KEY(`id`))",
"fields": [
{
"fieldPath": "id",
"columnName": "id",
"affinity": "TEXT",
"notNull": true
true
},
{
"fieldPath": "title",
"columnName": "title",
"affinity": "TEXT",
"notNull": false
false
},
{
"fieldPath": "duration",
"columnName": "duration",
"affinity": "INTEGER",
"notNull": true
true
},
{
"fieldPath": "priority",
"columnName": "priority",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "startTime",
"columnName": "startTime",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "creationTime",
"columnName": "creationTime",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "updateTime",
"columnName": "updateTime",
"affinity": "INTEGER",
"notNull": false
false
}
],
"primaryKey": {
"columnNames": [
"id"
],
"autoGenerate": false
false
},
"indices": [],
"foreignKeys": []
},
{
"tableName": "lodgings",
ROOM AND MIGRATIONS
85

"createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, `title` TEXT,
`duration` INTEGER NOT NULL, `priority` INTEGER, `startTime` INTEGER, `creationTime` INTEGER, `updateTime`
INTEGER, `address` TEXT, `tripId` TEXT, PRIMARY KEY(`id`), FOREIGN KEY(`tripId`) REFERENCES `trips`(`id`)
ON UPDATE NO ACTION ON DELETE CASCADE )",
"fields": [
{
"fieldPath": "id",
"columnName": "id",
"affinity": "TEXT",
"notNull": true
true
},
{
"fieldPath": "title",
"columnName": "title",
"affinity": "TEXT",
"notNull": false
false
},
{
"fieldPath": "duration",
"columnName": "duration",
"affinity": "INTEGER",
"notNull": true
true
},
{
"fieldPath": "priority",
"columnName": "priority",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "startTime",
"columnName": "startTime",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "creationTime",
"columnName": "creationTime",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "updateTime",
"columnName": "updateTime",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "address",
"columnName": "address",
"affinity": "TEXT",
"notNull": false
false
},
{
"fieldPath": "tripId",
"columnName": "tripId",
"affinity": "TEXT",
"notNull": false
false
}
],
ROOM AND MIGRATIONS
86

"primaryKey": {
"columnNames": [
"id"
],
"autoGenerate": false
false
},
"indices": [
{
"name": "index_lodgings_tripId",
"unique": false
false,
"columnNames": [
"tripId"
],
"createSql": "CREATE  INDEX `index_lodgings_tripId` ON `${TABLE_NAME}` (`tripId`)"
}
],
"foreignKeys": [
{
"table": "trips",
"onDelete": "CASCADE",
"onUpdate": "NO ACTION",
"columns": [
"tripId"
],
"referencedColumns": [
"id"
]
}
]
},
{
"tableName": "flights",
"createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, `title` TEXT,
`duration` INTEGER NOT NULL, `priority` INTEGER, `startTime` INTEGER, `creationTime` INTEGER, `updateTime`
INTEGER, `departingAirport` TEXT, `arrivingAirport` TEXT, `airlineCode` TEXT, `flightNumber` TEXT,
`seatNumber` TEXT, `tripId` TEXT, PRIMARY KEY(`id`), FOREIGN KEY(`tripId`) REFERENCES `trips`(`id`) ON
UPDATE NO ACTION ON DELETE CASCADE )",
"fields": [
{
"fieldPath": "id",
"columnName": "id",
"affinity": "TEXT",
"notNull": true
true
},
{
"fieldPath": "title",
"columnName": "title",
"affinity": "TEXT",
"notNull": false
false
},
{
"fieldPath": "duration",
"columnName": "duration",
"affinity": "INTEGER",
"notNull": true
true
},
{
"fieldPath": "priority",
"columnName": "priority",
"affinity": "INTEGER",
ROOM AND MIGRATIONS
87

"notNull": false
false
},
{
"fieldPath": "startTime",
"columnName": "startTime",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "creationTime",
"columnName": "creationTime",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "updateTime",
"columnName": "updateTime",
"affinity": "INTEGER",
"notNull": false
false
},
{
"fieldPath": "departingAirport",
"columnName": "departingAirport",
"affinity": "TEXT",
"notNull": false
false
},
{
"fieldPath": "arrivingAirport",
"columnName": "arrivingAirport",
"affinity": "TEXT",
"notNull": false
false
},
{
"fieldPath": "airlineCode",
"columnName": "airlineCode",
"affinity": "TEXT",
"notNull": false
false
},
{
"fieldPath": "flightNumber",
"columnName": "flightNumber",
"affinity": "TEXT",
"notNull": false
false
},
{
"fieldPath": "seatNumber",
"columnName": "seatNumber",
"affinity": "TEXT",
"notNull": false
false
},
{
"fieldPath": "tripId",
"columnName": "tripId",
"affinity": "TEXT",
"notNull": false
false
}
],
"primaryKey": {
"columnNames": [
"id"
ROOM AND MIGRATIONS
88

],
"autoGenerate": false
false
},
"indices": [
{
"name": "index_flights_tripId",
"unique": false
false,
"columnNames": [
"tripId"
],
"createSql": "CREATE  INDEX `index_flights_tripId` ON `${TABLE_NAME}` (`tripId`)"
}
],
"foreignKeys": [
{
"table": "trips",
"onDelete": "CASCADE",
"onUpdate": "NO ACTION",
"columns": [
"tripId"
],
"referencedColumns": [
"id"
]
}
]
}
],
"setupQueries": [
"CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
"INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42,
\"
\"69efe3a24b62764afa37e5eb0f162fd9\"
\")"
]
}
}
(from Trips/RoomMigrations/app/schemas/com.commonsware.android.room.TripDatabase/2.json)
In the JSON, the createSql properties have the table name as a template-style
macro (${TABLE_NAME}), which you will need to replace with the actual table name.
The backticks are supported in SQLite as they are in MySQL, and since they cause
no harm here, usually it is simpler just to leave them in there.
Employing Migrations
Simply creating a Migration as a static field somewhere is necessary but not
sufficient to have Room know about performing the migration. Instead, you need to
use the addMigrations() method on RoomDatabase.Builder to teach Room about
your Migration objects. addMigrations() accepts a varargs, and so you can pass in
one or several Migration objects as needed.
ROOM AND MIGRATIONS
89

package
package com.commonsware.android.room;
import
import android.arch.persistence.room.Database
android.arch.persistence.room.Database;
import
import android.arch.persistence.room.Room
android.arch.persistence.room.Room;
import
import android.arch.persistence.room.RoomDatabase
android.arch.persistence.room.RoomDatabase;
import
import android.content.Context
android.content.Context;
@Database(
entities={Trip.class, Lodging.class, Flight.class},
version=2
)
abstract
abstract class
class TripDatabase
TripDatabase extends
extends RoomDatabase {
abstract
abstract TripStore tripStore();
private
private static
static final
final String DB_NAME="trips.db";
private
private static
static volatile
volatile TripDatabase INSTANCE=null
null;
synchronized
synchronized static
static TripDatabase get(Context ctxt) {
if
if (INSTANCE==null
null) {
INSTANCE=create(ctxt, false
false);
}
return
return(INSTANCE);
}
static
static TripDatabase create(Context ctxt, boolean memoryOnly) {
return
return(create(ctxt, DB_NAME, memoryOnly));
}
static
static TripDatabase create(Context ctxt, String name, boolean memoryOnly) {
RoomDatabase.Builder<TripDatabase> b;
if
if (memoryOnly) {
b=Room.inMemoryDatabaseBuilder(ctxt.getApplicationContext(),
TripDatabase.class);
}
else
else {
b=Room.databaseBuilder(ctxt.getApplicationContext(), TripDatabase.class,
name);
}
return
return(b.addMigrations(Migrations.FROM_1_TO_2).build());
}
}
(from Trips/RoomMigrations/app/src/main/java/com/commonsware/android/room/TripDatabase.java)
ROOM AND MIGRATIONS
90

Here, we teach the RoomDatabase.Builder about the FROM_1_TO_2 Migration. In this
sample project, the migrations are implemented in a separate Migrations class,
though you are welcome to have them directly in your RoomDatabase class or
wherever makes sense for you.
How Room Applies Migrations
When you create your RoomDatabase instance via the Migration-enhanced Builder,
Room will use SQLiteOpenHelper semantics to see if the schema version in the
existing database is older than the schema version that you declared in your
@Database annotation. If it is, Room will try to find a suitable Migration to use,
falling back to dropping all of your tables and rebuilding them from scratch, as
happens during ordinary development.
Much of the time, the schema will jump from one version to the next. If you are
using a simple numbering scheme starting at 1, the schema will then move to 2, then
3, then 4, and so on, for a given device. Hence, your primary Migration objects will
be ones that implement these incremental migrations.
However, it may be that for some device you need to skip a schema version, such as
moving from version 1 to version 3. Room is smart enough to find a chain of
Migration objects to use, and so if you have Migration objects for each incremental
schema change, Room can handle any combination of changes. For example, to go
from 1 to 3, Room might first use your (1,2) migration, then the (2,3) migration.
Sometimes, though, this can lead to unnecessary work. Suppose in schema version 2,
you created a bunch of new tables and stuff… then reverted those changes in schema
version 3. By using the incremental migrations, Room will create those tables and
then turn around and drop them right away.
However, all else being equal, Room will try to use the shortest possible chain.
Hence, you can create additional Migration objects where appropriate to streamline
particular upgrades. You could create a (1,3) migration that bypasses the obsolete
schema version 2, for example. This is optional but may prove useful from time to
time.
Testing Migrations
It would be nice if your migrations worked. Users, in particular, appreciate working
code… or, perhaps more correctly, get rather angry with non-working code.
ROOM AND MIGRATIONS
91

Hence, you might want to test the migrations.
This gets a bit tricky, though. The code-generated Room classes are expecting the
latest-and-greatest schema version, so you cannot use your DAO for testing older
schemas. Besides, RoomDatabase.Builder wants to set up your database with that
latest-and-greatest schema automatically.
Fortunately, Room ships with some testing code to help you test your schemas in
isolation… though you bypass most of Room to do that.
Adding the Artifact
This testing code is in a separate android.arch.persistence.room:testing artifact,
one that you can add via androidTestCompile to put in your instrumentation tests
but leave out of your production code:
dependencies {
implementation "com.android.support:recyclerview-v7:26.1.0"
implementation 'com.android.support:support-fragment:26.1.0'
androidTestImplementation 'com.android.support:support-compat:26.1.0'
androidTestImplementation 'com.android.support:support-core-utils:26.1.0'
implementation "android.arch.persistence.room:runtime:1.0.0"
annotationProcessor "android.arch.persistence.room:compiler:1.0.0"
androidTestImplementation "com.android.support:support-annotations:26.1.0"
androidTestImplementation 'com.android.support.test:rules:1.0.1'
androidTestImplementation "android.arch.persistence.room:testing:1.0.0"
}
(from Trips/RoomMigrations/app/build.gradle)
Adding the Schemas
Remember those exported schemas? While we used them for helping us write the
migrations, their primary use is for this testing support code.
By default, those schemas are stored outside of anything that goes into your app.
After all, you do not need those JSON files cluttering up your production builds.
However, this also means that those schemas are not available to your test code, by
default.
However, we can fix that, by adding those schemas to the assets/ used in the
androidTest source set, by having this closure in your android closure of your
module’s build.gradle file:
ROOM AND MIGRATIONS
92

sourceSets {
androidTest.assets.srcDirs += files("$projectDir/schemas".toString())
}
(from Trips/RoomMigrations/app/build.gradle)
Here, "$projectDir/schemas".toString() is the same value that we used for the
room.schemaLocation annotation processor argument. This snippet tells Gradle to
include the contents of that schemas/ directory as part of our assets/.
The result is that our instrumentation test APK will have those directories named
after our RoomDatabase classes (e.g.,
com.commonsware.android.room.TripDatabase/) in the root of assets/. If you have
code that uses assets/, make sure that you are taking steps to ignore these extra
directories.
Creating and Using a MigrationTestHelper
The testing support comes in the form of a MigrationTestHelper that you can
employ in your instrumentation tests.
Adding the Rule
MigrationTestHelper is a JUnit4 rule, which you add to your test case class via the
@Rule annotation:
@Rule
public
public MigrationTestHelper helper;
(from Trips/RoomMigrations/app/src/androidTest/java/com/commonsware/android/room/MigrationTests.java)
Setting Up the Helper
You then need to create an instance of the MigrationTestHelper, such as in a
@Before-annotated method:
@Before
public
public void setUp() {
helper=new
new MigrationTestHelper(InstrumentationRegistry.getInstrumentation(),
TripDatabase.class.getCanonicalName());
}
(from Trips/RoomMigrations/app/src/androidTest/java/com/commonsware/android/room/MigrationTests.java)
MigrationTestHelper takes two parameters, both of which are a bit unusual.
ROOM AND MIGRATIONS
93

First, it takes an Instrumentation object. We use those in our test code, but it is rare
that we pass them as a parameter. You get your Instrumentation usually by calling
getInstrumentation() on the InstrumentationRegistry.
Then, it takes what appears to be the fully-qualified class name of the RoomDatabase
whose migrations we wish to test. Technically speaking, this is actually the relative
path, inside of assets/, where the schema JSON files are for this particular
RoomDatabase. Given the above configuration, each database’s schemas are put into a
directory named after the fully-qualified class name of the RoomDatabase, which is
why this works. However, if you change the configuration to put the schemas
somewhere else in assets/, you would need to modify this parameter to match.
Creating a Database for a Schema Version
There are two main methods on MigrationTestHelper that we will use in testing.
One is createDatabase(). This creates the database, as a specific database file, for a
specific schema version… including any of our historical ones found in those schema
JSON files. Here, we ask the helper to create a database named DB_NAME for schema
version 1:
SupportSQLiteDatabase db=helper.createDatabase(DB_NAME, 1);
(from Trips/RoomMigrations/app/src/androidTest/java/com/commonsware/android/room/MigrationTests.java)
That SupportSQLiteDatabase object has an API reminiscent of a trimmed-down
SQLiteDatabase. query() replaces rawQuery() and is used for executing arbitrary
SQL SELECT statements. We also have execSQL(), insert(), update(), and
delete(), for other operations.
As part of testing a migration, you will need to add some sample data to the
database, using whatever schema you asked to be used, so that you can confirm that
the migration worked as expected and did not wreck the existing data. This code will
not be very Room-ish, but more like classic SQLite Android programming:
SupportSQLiteDatabase db=helper.createDatabase(DB_NAME, 1);
db.execSQL("INSERT INTO trips (id, title, duration) VALUES (1, NULL, 0)");
final
final Cursor firstResults=db.query("SELECT COUNT(*) FROM trips");
assertEquals(1, firstResults.getCount());
firstResults.moveToFirst();
assertEquals(1, firstResults.getInt(0));
ROOM AND MIGRATIONS
94

firstResults.close();
db.close();
(from Trips/RoomMigrations/app/src/androidTest/java/com/commonsware/android/room/MigrationTests.java)
Testing a Migration
The other method of note on MigrationTestHelper is
runMigrationsAndValidate(). After you have set up a database in its starting
conditions via createDatabase() and CRUD operations,
runMigrationsAndValidate() will migrate that database from its original schema
version to the one that you specify:
db=helper.runMigrationsAndValidate(DB_NAME, 2, true
true,
Migrations.FROM_1_TO_2);
(from Trips/RoomMigrations/app/src/androidTest/java/com/commonsware/android/room/MigrationTests.java)
You need to supply the same database name (DB_NAME), a higher schema version (2),
and the specific Migration that you want to use (Migration.FROM_1_TO_2).
Not only does this method perform the migration, but it validates the resulting
schema against what the entities have set up for that schema version, based on the
schema JSON files. If there is something wrong — your migration forgot a newly-
added column, for example — your test will fail with an assertion violation. The
true parameter shown above determines whether this schema validation will be
checked for un-dropped tables. true means that if you have unnecessary tables in
the database, the test fails; false means that unnecessary tables are fine and will be
ignored.
However, all MigrationTestHelper can do is confirm that you set up the new
schema properly. It cannot determine whether the data is any good after the
migration. That you would need to test yourself. In many cases, there is little to test,
particularly if you are just setting up empty tables as we are doing in this migration.
However, if you had a complex table change, perhaps requiring a temp table and
statements like INSERT INTO ... SELECT FROM ..., you could write test code that
confirms the data is OK. However, you cannot use the Room DAO for this either;
instead, you will use the SupportSQLiteDatabase and work with the tables “the old-
fashioned way”, using query() and Cursor and such.
ROOM AND MIGRATIONS
95

Migrating Under Protest
Starting with the 1.0.0-alpha8 edition of Room, subtle changes in your object
model can have unexpected impacts on your database storage.
In particular, changing the order of fields as they appear in your entity forces you to
have a do-nothing migration if you want to keep your data. This appears to be
because:
• Room creates columns in the table in the same order as the fields appear in
the entity, so changing the field order changes the column order
• Room’s logic for detecting if a migration is needed does not take into
account the fact that the order of fields in a table does not matter
With luck, this will be addressed in a future update to Room.
Similarly, pay close attention to the release notes for Room. Updating your Room
implementation may require you to implement or modify a migration. For example,
upgrading from 1.0.0-alpha3 to 1.0.0-alpha8 changed the nature of columns
generated from int fields — these are now NOT NULL, where formerly they allowed
null values. However, since this changes the schema, you will now need to take this
account in the migration, altering those columns to be NOT NULL. With luck, once
1.0.0 ships in final form, breaking schema changes will be relegated to major
version releases.
ROOM AND MIGRATIONS
96

Securing Your Room
Room, by default, works with the device’s stock copy of SQLite. This is fine, as far as
it goes. However, from a security standpoint, SQLite stores its data unencrypted.
Many apps should be considering encrypting their data “at rest”, when it is stored in
a database, to protect their users.
Fortunately, as noted in the last chapter, Room supports a pluggable SQLite
implementation, and so we can plug in a SQLite edition that supports encryption,
such as SQLCipher for Android. This chapter will outline how to do this.
Meet the Players
There are two pieces to the encrypted-database puzzle: a SQLite implementation
with encryption capability, and the “glue code” that allows Room to work with that
SQLite implementation.
SQLCipher for Android
Since SQLite is public domain, it is easy for people to grab the source code and hack
on it. SQLite also offers an extension system, making it relatively easy for developers
to add functionality with a minimal number of changes to SQLite’s core code. As a
result, a few encryption options for SQLite have been published.
One of these is SQLCipher, whose development is overseen by Zetitec. This offers
transparent AES-256 encryption of everything in the database: data, schema, etc.
With the help of the Guardian Project, Zetitec released SQLCipher for Android. This
combines a pre-compiled version of SQLite with Java classes that mimic an old
edition of Android’s native SQLite classes (e.g., SQLiteOpenHelper). SQLCipher for
97

Android is open source, and if you can live with the increase in app size due to the
native binaries, it is an effective solution.
However, it knows nothing about Room.
CWAC-SafeRoom
To fill that gap, the author of this book has released CWAC-SafeRoom. This is an
implementation of Room’s pluggable database API to bridge between Room and
SQLCipher for Android. Using SQLCipher for Android then becomes mostly a
matter of a single method call on the RoomDatabase.Builder to use the CWAC-
SafeRoom code — everything else works as normal.
That being said, at the time of this writing, the latest release of Room is 1.0.0, and
CWAC-SafeRoom is 0.1.2. These are early days for both libraries, and so changes
may occur either at the Room or the CWAC-SafeRoom level.
Using CWAC-SafeRoom
Fortunately, using CWAC-SafeRoom is fairly straightforward, at least in terms of the
Java code.
The fact that SQLCipher for Android makes use of native libraries will make your
APK substantially larger, though using ABI filters and splits can help manage that.
However, those concerns would be the same for any use of SQLCipher for Android
and are not unique to CWAC-SafeRoom.
Adding the Dependency
As with all the CWAC libraries, you get CWAC-SafeRoom from the CWAC artifact
repository:
repositories {
maven {
url "https://s3.amazonaws.com/repo.commonsware.com"
}
}
(or use http://repo.commonsware.com if you cannot use SSL for your builds, for
some scary reason)
SECURING YOUR ROOM
98

Then, it is merely a matter of adding a dependency on the
com.commonsware.cwac:saferoom artifact. At the time of this writing, the artifact is
available as a 0.0.4 release:
compile 'com.commonsware.cwac:saferoom:0.0.4'
Using CWAC-SafeRoom
When you use Room, you use Room.databaseBuilder() or
Room.inMemoryDatabaseBuilder() to get a RoomDatabase.Builder. After
configuring that object, you call build() to get an instance of your custom subclass
of RoomDatabase, whichever one that you supplied as a Java class object to the
Room.databaseBuilder() or Room.inMemoryDatabaseBuilder() method.
To use SafeRoom, on the RoomDatabase.Builder, before calling build():
• Create an instance of com.commonsware.cwac.saferoom.SafeHelperFactory,
passing in the passphrase to use
• Pass that SafeHelperFactory to the RoomDatabase.Builder via the
openHelperFactory() method
// EditText passphraseField;
SafeHelperFactory factory=SafeHelperFactory.fromUser(passphraseField.getText());
StuffDatabase db=Room.databaseBuilder(ctxt, StuffDatabase.class, DB_NAME)
.openHelperFactory(factory)
.build();
Passphrase Management
A cardinal rule of passphrases in Java is: do not hold them in String objects. You
have no means of clearing those from memory, as a String is an immutable value.
The SafeHelperFactory constructor takes a char array for the passphrase. If you are
getting the passphrase from the user via an EditText widget, use the fromUser()
factory method instead, supplying the Editable that you get from getText() on the
EditText.
SafeRoom will zero out the char array once the database is opened. If you use
fromUser(), SafeRoom will also clear the contents of the Editable.
SECURING YOUR ROOM
99

More to Come!
More material on CWAC-SafeRoom and the use of SQLCipher for Android will be
added to this book in the future, as Room, CWAC-SafeRoom, and this book all
mature.
SECURING YOUR ROOM
100

Lifecycle Components and
ViewModels


Lifecycles and Owners
Programmers, in any environment, often encounter one or more topics that inspire
the five stages of grief. It might be related to threads, to security, to UI
implementation (e.g., how to deal with resizeable windows).
Android developers experience this sort of grief on all those topics.
Another one that triggers this sort of grief is the concept of lifecycles. On the
surface, the concept seems unremarkable: objects are in use for a time and then
become discarded, and along the way we receive callbacks regarding their state.
However, dealing with the ramifications of those lifecycles — such as handling
configuration changes, like screen rotation — vex even seasoned Android
developers.
Part of the Architecture Components is a series of classes designed to help you deal
with lifecycles in a more consistent fashion.
A Tale of Terminology
The Architecture Components have very specific definitions for certain terms, and
these definitions affect the classes that we wind up using.
Lifecycle
A lifecycle is a series of states that an object can be in. Hence, a trivial lifecycle
simply has “alive” and “dead” or similar states.
The eponymous Lifecycle class, however, models a specific lifecycle, that of
activities and fragments.
103

Lifecycle Owner
A lifecycle owner is simply something that goes through a lifecycle. If the lifecycle is
the state, the lifecycle owner is what has the trigger events for navigating through
the state machine.
A LifecycleOwner is a Java interface, with a getLifecycle() method, that returns
the Lifecycle for a given owner. As we will see, various classes already implement
LifecycleOwner, and adding it to something else is not especially difficult.
Lifecycle Observers
A lifecycle observer is something that is notified about the change in state of some
lifecycle. It finds out about those trigger events and the movement of the lifecycle
from state to state.
There are two ways to do this, via annotations and via DefaultLifecycleObserver,
as we will explore later in this chapter.
Adding the Lifecycle Components
As with Room, the lifecycle-related libraries are housed in Google’s Maven
repository, and you need to teach Gradle where that is. The convention is to add the
repository URL in the allprojects closure in the project’s root build.gradle file:
allprojects {
repositories {
jcenter()
maven { url 'https://maven.google.com' }
}
}
(from General/Lifecycle/build.gradle)
Then, you need a runtime dependency and an annotation processor, once again akin
to how Room is set up:
dependencies {
implementation "com.android.support:recyclerview-v7:27.0.2"
implementation "com.android.support:support-fragment:27.0.2"
implementation "android.arch.lifecycle:runtime:1.1.0"
LIFECYCLES AND OWNERS
104

implementation "android.arch.lifecycle:common-java8:1.1.0"
}
(from General/Lifecycle/app/build.gradle)
However, making sense of the artifact versions — particularly when transitive
dependencies come into play — will be difficult.
If your project directly or indirectly depends upon support-compat version 26.1.0
or higher, support-compat has a dependency on android.arch.lifecycle:runtime,
for some version of that artifact. What version that is will depend on the version of
support-compat:
Support Library Versionandroid.arch.lifecycle:runtime
android.arch.lifecycle:runtime Version
27.0.2
1.0.3
26.1.0
1.0.0
In the sample dependencies closure shown above, we depend upon
recyclerview-v7. That has a dependency on support-compat, and so we would get
android.arch.lifecycle:runtime simply by depending on recyclerview-v7.
However, Google is also releasing patch versions of
android.arch.lifecycle:runtime independent of updates to the Support Library
artifacts. So, the compile statement pulling in android.arch.lifecycle:runtime is
pulling in a newer version than what the Support Library would (specifically
1.1.0).
In addition, we have an dependency on android.arch.lifecycle:common-java8,
which provides better Java 8 support for the lifecycle system.
How these versions will work out in the future is anyone’s guess right now.
Getting a Lifecycle
Everything dealing with Lifecycle comes down to a LifecycleOwner. You have
several possibilities of where to get one of those.
LIFECYCLES AND OWNERS
105

…From a FragmentActivity or a Support Fragment
If you are using version 26.1.0 or higher of the Support Library artifacts, then
FragmentActivity and the android.support.v4.app.Fragment class both
implement LifecycleOwner.
If you are using an older version of the Support Library artifacts… you really should
upgrade to at least 26.1.0 to use the Architecture Components.
…From an AppCompatActivity
Perhaps you are using the appcompat-v7 artifact. In that case, you are inheriting
from AppCompatActivity instead of FragmentActivity or Activity.
However, since AppCompatActivity inherits from FragmentActivity, if you are using
26.1.0 or higher of appcompat-v7, your AppCompatActivity subclasses will also
implement LifecycleOwner.
…From an Activity or Fragment
Perhaps you are using the classic Activity and Fragment classes, or from classes
that extend those (e.g., WearableActivity). Those will never directly implement
LifecycleOwner, as framework classes cannot depend upon libraries.
The simplest solution is to switch to inheriting from FragmentActivity and the
corresponding backport of Fragment.
Otherwise, this means that we need to handle this in a more complex fashion,
outlined later in the chapter.
…From Anything Else
In principle, you could have other objects that are themselves tied into the activity
and fragment lifecycle. After all, the backport of fragments in the Support Library
are just that sort of “other objects”. It so happens that Google takes care of managing
that backport. However, you might find other objects that, for whatever reason, are
similar in concept to the fragments backport and therefore should be suppliers of
lifecycle events.
LIFECYCLES AND OWNERS
106

In that case, you can implement LifecycleOwner on those classes. However, you will
also need to call handleLifecycleEvent() method on the LifecycleRegistry at
appropriate points.
This will be illustrated with support for ordinary activities, shown later in the
chapter.
Observing a Lifecycle
Most likely, if you are interested in the Architecture Components, you are up to
speed with Java 8 and are interested in using it in your project. In that case, you can
go the preferred route and use DefaultLifecycleObserver as your observer
implementation. This takes advantage of Java 8’s ability to define methods on
interfaces, so that you only need to override the particular lifecycle events that
concern you.
So, for example, here is an observer that passes all events to a
RecyclerView.Adapter named EventLogAdapter:
static
static class
class LObserver
LObserver implements
implements DefaultLifecycleObserver {
private
private final
final EventLogAdapter adapter;
LObserver(EventLogAdapter adapter) {
this
this.adapter=adapter;
}
@Override
public
public void onCreate(@NonNull LifecycleOwner owner) {
adapter.add("ON_CREATE");
}
@Override
public
public void onStart(@NonNull LifecycleOwner owner) {
adapter.add("ON_START");
}
@Override
public
public void onResume(@NonNull LifecycleOwner owner) {
adapter.add("ON_RESUME");
}
@Override
public
public void onPause(@NonNull LifecycleOwner owner) {
adapter.add("ON_PAUSE");
LIFECYCLES AND OWNERS
107

}
@Override
public
public void onStop(@NonNull LifecycleOwner owner) {
adapter.add("ON_STOP");
}
@Override
public
public void onDestroy(@NonNull LifecycleOwner owner) {
adapter.add("ON_DESTROY");
}
}
(from General/Lifecycle/app/src/main/java/com/commonsware/android/lifecycle/MainActivity.java)
Then, you can register the observer, and it will start being called for the various
events:
@Override
public
public void onCreate(Bundle savedInstanceState) {
super
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
setTitle(getString(R.string.title, hashCode()));
RecyclerView rv=findViewById(R.id.transcript);
adapter=new
new EventLogAdapter(getLastCustomNonConfigurationInstance());
rv.setAdapter(adapter);
getLifecycle().addObserver(new
new LObserver(adapter));
}
(from General/Lifecycle/app/src/main/java/com/commonsware/android/lifecycle/MainActivity.java)
All of this code is from the General/Lifecycle sample project, which shows you the
events in a RecyclerView as they come in. The MainActivity handles configuration
changes via onRetainCustomNonConfigurationInstance(), so you can see the
lifecycle events across a configuration change. Through an overflow menu item, you
can kick off another instance of MainActivity, then press BACK to see the flow of
lifecycle events as the original instance comes and goes from the foreground.
LIFECYCLES AND OWNERS
108

Legacy Options
The Java 8 and FragmentActivity approach is the simplest way to work with
lifecycles. However, sometimes, those are not an option, and for that, you will need
workarounds.
Ordinary Activities and Fragments, and Other Objects
Sometimes, you have to use activities and fragments not rooted in the Support
Library backport. For example, WearableActivity for Android Wear does not extend
FragmentActivity. By default, you cannot use such activities with the lifecycle
system. And, sometimes, you might have some other object need to be the source of
lifecycle events, independent of activities and fragments.
For these scenarios:
• Have your class implement the LifecycleOwner interface
• Use LifecycleRegistry to track the registered observers
• Return that registry from getLifecycle(), the one method on
LifecycleOwner that you need to implement
• From all of the lifecycle methods, call handleLifecycleEvent() on the
registry, indicating what lifecycle event has just occurred
For example, here is a SimpleLifecycleActivity that handles the standard activity
lifecycle events, forwarding them to the LifecycleRegistry:
package
package com.commonsware.android.lifecycle;
import
import android.app.Activity
android.app.Activity;
import
import android.arch.lifecycle.Lifecycle
android.arch.lifecycle.Lifecycle;
import
import android.arch.lifecycle.LifecycleOwner
android.arch.lifecycle.LifecycleOwner;
import
import android.arch.lifecycle.LifecycleRegistry
android.arch.lifecycle.LifecycleRegistry;
import
import android.os.Bundle
android.os.Bundle;
import
import android.support.annotation.Nullable
android.support.annotation.Nullable;
public
public class
class SimpleLifecycleActivity
SimpleLifecycleActivity extends
extends Activity
implements
implements LifecycleOwner {
private
private LifecycleRegistry registry=new
new LifecycleRegistry(this
this);
@Override
public
public Lifecycle getLifecycle() {
return
return(registry);
}
LIFECYCLES AND OWNERS
109

@Override
protected
protected void onCreate(@Nullable Bundle savedInstanceState) {
super
super.onCreate(savedInstanceState);
registry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);
}
@Override
protected
protected void onStart() {
super
super.onStart();
registry.handleLifecycleEvent(Lifecycle.Event.ON_START);
}
@Override
protected
protected void onResume() {
super
super.onResume();
registry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);
}
@Override
protected
protected void onPause() {
super
super.onPause();
registry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);
}
@Override
protected
protected void onStop() {
super
super.onStop();
registry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);
}
@Override
protected
protected void onDestroy() {
super
super.onDestroy();
registry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);
}
}
(from General/LifecycleLegacy/app/src/main/java/com/commonsware/android/lifecycle/SimpleLifecycleActivity.java)
LIFECYCLES AND OWNERS
110

Pre-Java 8
Perhaps Java 8 is not an option for you, for whatever reason.
DefaultLifecycleObserver will not work for you. Instead, you will need to:
• Remove the android.arch.lifecycle:common-java8 dependency, as it will
not be compatible with your app
• Add an annotationProcessor dependency on
android.arch.lifecycle:compiler
• Have your observer implement LifecycleObserver instead of
DefaultLifecycleObserver
• Implement one or more methods, annotated with @OnLifecycleEvent, to
receive the lifecycle events of interest to you
So, for example, here is an observer that passes all events to a
RecyclerView.Adapter named EventLogAdapter:
static
static class
class LObserver
LObserver implements
implements LifecycleObserver {
private
private final
final EventLogAdapter adapter;
LObserver(EventLogAdapter adapter) {
this
this.adapter=adapter;
}
@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
void created() {
adapter.add("ON_CREATE");
}
@OnLifecycleEvent(Lifecycle.Event.ON_START)
void started() {
adapter.add("ON_START");
}
@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
void resumed() {
adapter.add("ON_RESUME");
}
@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
void paused() {
adapter.add("ON_PAUSE");
}
@OnLifecycleEvent(Lifecycle.Event.ON_STOP)
LIFECYCLES AND OWNERS
111

void stopped() {
adapter.add("ON_STOP");
}
@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
void destroyed() {
adapter.add("ON_DESTROY");
}
}
(from General/LifecycleLegacy/app/src/main/java/com/commonsware/android/lifecycle/MainActivity.java)
Note:
• There is also a Lifecycle.Event.ON_ANY event that you can request; this
triggers your method to be called for any lifecycle event… though you have
no way of knowing what event it was
• A single method can only have one @OnLifecycleEvent annotation, and that
annotation accepts only a single Lifecycle.Event value (not a list)
As noted, you also need the annotation processor, so those @OnLifecycleEvent
annotations can be interpreted and applied:
dependencies {
implementation 'com.android.support:recyclerview-v7:27.0.2'
implementation 'android.arch.lifecycle:runtime:1.1.0'
annotationProcessor 'android.arch.lifecycle:compiler:1.1.0'
}
(from General/LifecycleLegacy/app/build.gradle)
So, What’s the Point of This?
On the surface, this all seems fairly silly. One could just as easily override the
lifecycle methods on MainActivity and log directly to the RecyclerView, bypassing
all this Lifecycle and LifecycleOwner stuff.
Most developers will not be creating their own LifecycleObserver classes, though
anyone can, as the sample app demonstrates. Instead, developers will tend to use
observers created by others. Most notable among those is LiveData from the
Architecture Components, and the subject of the next chapter.
LIFECYCLES AND OWNERS
112

LiveData
Lifecycle, LifecycleOwner, and related classes mostly exist to provide the
foundation for LiveData. LiveData is the next generation of various Android
asynchronous solutions, such as AsyncTask and the Loader framework. LiveData, in
particular, is modeled somewhat after RxJava, a popular reactive programming
library.
All of this is to set up ways for you to be able to observe changes to data without
having to worry as much about activity and fragment lifecycles… though, as it turns
out, you cannot escape them entirely.
Observables Are the New Black
The observer pattern in software design has been around for decades. Yet, it has
caught fire in the past few years, repackaged as “reactive programming”. Reactive
programming visualizes an app as a set of streams of data changes, whether from the
user (e.g., UI widget interactions), from a server (e.g., updates to data from a sync
operation), or from something else (e.g., GPS fixes). Developers set up observers to
respond (“react”) to these data changes and apply updates to the UI.
The centerpiece for reactive programming in Android is RxJava, typically combined
with RxAndroid. RxJava provides the basic framework for observing streams of data
changes, with RxAndroid primarily providing ways to route results of observations to
the main application thread. This book is not going to go into details of how you use
RxJava/RxAndroid in general — for that, see The Busy Coder’s Guide to Android
Development or other books.
One problem with RxJava, though, is that “it is difficult to get your head wrapped
around it”. Reactive programming works great in platforms that implemented
113

reactive programming from the outset. Reactive programming is more difficult to
bolt onto an existing platform, both from a technical standpoint and from a
documentation standpoint. RxJava is the sort of technology that is easy to illustrate
in “hello, world”-level examples but gets difficult to explain for more practical
scenarios. In part, that is because RxJava is extremely flexible, and with great
flexibility comes great need for great documentation… which RxJava historically
lacked.
LiveData is designed to be a much lighter-weight approach to reactive
programming, designed to do one thing (deliver asynchronous data changes
regardless of lifecycle events) and do it reasonably well.
Yet More Terminology
First, let’s review some new and exciting terms that we need to understand in order
to use LiveData.
LiveData
LiveData itself is a source of data, both for a point in time and (via an observer) for
changes to that data over time. Something will create and hand you a LiveData
object, where the work to get that data and update it over time is handled by some
background thread coming from the LiveData supplier.
Observer
In principle, you can call getValue() on a LiveData to get the current value for
whatever stream of data the LiveData is tracking. In practice, this will not be
especially common.
Instead, you will register an Observer with the LiveData, usually via an observe()
method. Your Observer will be called with onChanged() when:
• You start observing and there is already data in the LiveData, and
• When the LiveData finds out about a change in the data
Your onChanged() method is given the data (a Location, a SensorEvent, a Room
entity, whatever) on the main application thread, with an eye towards you using it to
update the UI by one means or another.
LIVEDATA
114

Active State
If a LiveData was instantiated in a forest, and nobody was there to observe data
changes, does the LiveData really exist?
The answer is: yes, but it hopefully is not consuming any resources.
A LiveData implementation will be called with onActive() when it receives its first
active observer. Here, “active” means that, if the observer is tied to a
LifecycleOwner, the lifecycle is in the started or resumed state. Conversely, the
LiveData will be called with onInactive() once it no longer has any active
observers, either because all observers have been unregistered or none of them are
active, as their lifecycles are all paused, stopped, or destroyed.
The idea is that a LiveData would only start consuming significant system resources
— such as requesting GPS fixes — when there are active observers, releasing those
resources when there are no more active observers. This works in many cases,
though there are some that will require more finesse. For example, given that the
GPS radio takes some time before it starts generating GPS fixes, a LiveData for GPS
might want to wait some amount of time after losing its last active observer before
releasing the GPS radio, in case a new observer pops up quickly, to avoid delays in
getting those GPS fixes.
Implementing LiveData
With that as background, let’s see LiveData in action. The General/LiveSensor
sample project implements LiveData for sensor readings coming from a
SensorManager. We can use this to track the accelerometer, ambient light, and so on.
However, the technique shown here can be used for lots of different system-level
data sources, such as:
• Other system services (e.g., LocationManager, ClipboardManager)
• System broadcasts, for cases where you want to dynamically register for the
broadcast via registerReceiver()
• Local broadcasts, using LocalBroadcastManager
• Content changes in providers, via a ContentObserver
LIVEDATA
115

Dependencies
To use Lifecycle and LifecycleOwner, you needed two dependencies: the lifecycle
runtime library and its compiler annotation processor.
LiveData is in a third dependency. Which dependency itself depends on the
version.
Version 1.1.0 Onwards
Use the android.arch.lifecycle:livedata dependency:
dependencies {
implementation 'com.android.support:recyclerview-v7:27.0.2'
implementation 'com.android.support:support-fragment:27.0.2'
implementation 'android.arch.lifecycle:runtime:1.1.0'
implementation 'android.arch.lifecycle:livedata:1.1.0'
}
(from General/LiveSensor/app/build.gradle)
Prior to Version 1.1.0
Use the android.arch.lifecycle:extensions dependency. For 1.1.0 onwards, the
extensions dependency pulls in both the livedata dependency and a separate
viewmodel dependency. The viewmodel dependency is for the ViewModel class and
related classes, covered later in the book.
State Transitions
We have a SensorLiveData class that extends the LiveData base class, offering to
support a custom Event static nested class:
package
package com.commonsware.android.livedata;
import
import android.arch.lifecycle.LiveData
android.arch.lifecycle.LiveData;
import
import android.content.Context
android.content.Context;
import
import android.hardware.Sensor
android.hardware.Sensor;
import
import android.hardware.SensorEvent
android.hardware.SensorEvent;
import
import android.hardware.SensorEventListener
android.hardware.SensorEventListener;
import
import android.hardware.SensorManager
android.hardware.SensorManager;
import
import java.util.Date
java.util.Date;
LIVEDATA
116

class
class SensorLiveData
SensorLiveData extends
extends LiveData<SensorLiveData.Event> {
final
final private
private SensorManager sensorManager;
private
private final
final Sensor sensor;
private
private final
final int delay;
SensorLiveData(Context ctxt, int sensorType, int delay) {
sensorManager=
(SensorManager)ctxt.getApplicationContext()
.getSystemService(Context.SENSOR_SERVICE);
this
this.sensor=sensorManager.getDefaultSensor(sensorType);
this
this.delay=delay;
if
if (this
this.sensor==null
null) {
throw
throw new
new IllegalStateException("Cannot obtain the requested sensor");
}
}
@Override
protected
protected void onActive() {
super
super.onActive();
sensorManager.registerListener(listener, sensor, delay);
}
@Override
protected
protected void onInactive() {
sensorManager.unregisterListener(listener);
super
super.onInactive();
}
final
final private
private SensorEventListener listener=new
new SensorEventListener() {
@Override
public
public void onSensorChanged(SensorEvent event) {
setValue(new
new Event(event));
}
@Override
public
public void onAccuracyChanged(Sensor sensor, int accuracy) {
// unused
}
};
static
static class
class Event
Event {
final
final Date date=new
new Date();
final
final float[] values;
Event(SensorEvent event) {
LIVEDATA
117

values=new
new float[event.values.length];
System.arraycopy(event.values, 0, values, 0, event.values.length);
}
}
}
(from General/LiveSensor/app/src/main/java/com/commonsware/android/livedata/SensorLiveData.java)
In the constructor, we hold onto configuration details, such as the particular sensor
to monitor and how frequently we should ask for updates. We also obtain an
instance of the SensorManager system service and try to find the actual requested
Sensor, throwing a runtime exception if there is no matching sensor on this device.
However, we do not register for sensor events in the constructor. Until we have 1+
active observers, we do not need those events, and monitoring sensor events drains
the battery. So, we postpone registering for events until onActive(), unregistering in
the corresponding onInactive() callback.
Updating the Observers
The SensorEventListener that we use, in its onSensorChanged() method, creates a
new instance of our Event, grabbing data from the SensorEvent. We use our own
Event class for two reasons:
1.
SensorEvent objects get recycled, and so it is not safe to hold onto one of
those after the end of onSensorChanged(), so we copy the sensor results
float values into our own object
2. While a SensorEvent has a timestamp, it is a pain to use, and this is a casual
book sample, so we just track our own Date for simplicity
That Event is passed to setValue() on the LiveData, which in turn will pass the
result to observers. Note that setValue() needs to be called on the main application
thread — we will see how to handle events originating on background threads later
in this chapter.
Retaining the LiveData
So, we have a LiveData for sensor readings. We can have an activity that displays
those readings, by having it create a SensorLiveData instance and registering to
observe those events. But now we run into a problem… what do we do with the
SensorLiveData object after that?
LIVEDATA
118

One possibility is that we just hold onto it in a field, mostly to ensure that nothing
gets garbage-collected that would interrupt the sensor readings. If we undergo a
configuration change, we just create a new SensorLiveData objects and a fresh
observer. While this is not completely ridiculous for this particular scenario, it is bad
for cases where setting up the LiveData is expensive.
The idea behind LiveData is that it is the unique source of the specific data for the
entire app. In other words, if we had several activities and fragments that all needed
a particular sensor reading, we should set up a single SensorLiveData for all of
them. That suggests using a singleton, and we will see how to do that later in this
chapter. And, in truth, this is going to be the most common answer. However, it does
raise some bits of complexity — in the case of SensorLiveData, there are many
possible sensors, and a few possible delay periods, and so we would need a fairly
sophisticated manager object to reuse or lazily create the appropriate
SensorLiveData for a given client.
In this sample app, we take a middle-ground approach, and use
onRetainNonConfigurationInstance() inside the activity that is going to use the
sensor readings. Since the UI is going to be a RecyclerView of readings, we also need
to hold onto past readings, so we do not lose them when we undergo the
configuration change.
So, we have a State static nested class that holds onto the SensorLiveData and
outstanding readings:
private
private static
static class
class State
State {
final
final ArrayList<SensorLiveData.Event> events=new
new ArrayList<>();
SensorLiveData sensorLiveData;
}
(from General/LiveSensor/app/src/main/java/com/commonsware/android/livedata/MainActivity.java)
In onCreate(), we set up that State if we do not already have one, storing it in a
state field. This includes setting up the SensorLiveData, in this case for the
ambient light sensor:
@Override
public
public void onCreate(Bundle savedInstanceState) {
super
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
RecyclerView rv=findViewById(R.id.transcript);
LIVEDATA
119

state=(State)getLastCustomNonConfigurationInstance();
if
if (state==null
null) {
state=new
new State();
state.sensorLiveData=
new
new SensorLiveData(this
this, Sensor.TYPE_LIGHT,
SensorManager.SENSOR_DELAY_UI);
}
adapter=new
new EventLogAdapter();
rv.setAdapter(adapter);
state.sensorLiveData.observe(this
this, event -> adapter.add(event));
}
(from General/LiveSensor/app/src/main/java/com/commonsware/android/livedata/MainActivity.java)
We also register our Observer, which will be called with onChanged() with a new
Event as sensor readings come in. Our EventLogAdapter knows how to add() that to
the list of historical readings and update the RecyclerView.
However, the LiveData will automatically deliver the last-received reading to our
observer when we attach a fresh observer after a configuration change. That could
result in onChanged() being given the same Event object as before, one that we
already put into the ArrayList. So, the EventLogAdapter add() method checks that
first, before actually adding it:
void add(SensorLiveData.Event what) {
if
if (!state.events.contains(what)) {
state.events.add(what);
notifyItemInserted(getItemCount()-1);
}
}
(from General/LiveSensor/app/src/main/java/com/commonsware/android/livedata/MainActivity.java)
And we override onRetainNonConfigurationInstance() to return the State
instance, so onCreate() can retrieve it after a configuration change:
@Override
public
public Object onRetainCustomNonConfigurationInstance() {
return
return(state);
}
(from General/LiveSensor/app/src/main/java/com/commonsware/android/livedata/MainActivity.java)
LIVEDATA
120

Other LiveData Examples
Let’s take a look at a few more examples of using LiveData, to explore other facets of
how this can be used.
Event Bus
LocalBroadcastManager implements an in-process event bus, where events are
delivered to you on the main application thread, and where “events” are Intent
objects.
You can accomplish the same thing, with greater flexibility, by means of a LiveData
object, as can be seen in the General/LiveBus sample project.
This sample app is derived from one shown in The Busy Coder’s Guide to Android
Development, where we have AlarmManager triggering a service. In principle, that
service should do some work, which we are skipping here because we are lazy.
However, the fake work is something that the user might care about, and so we want
to let the UI layer know about the event if we happen to be in the foreground.
Otherwise, we want to raise a Notification. In The Busy Coder’s Guide to Android
Development, implementations of this sample are available for a few event buses,
including LocalBroadcastManager and greenrobot’s EventBus.
Here, though, we will use a MutableLiveData singleton:
static
static final
final MutableLiveData<Intent> BUS=new
new MutableLiveData<>();
(from General/LiveBus/app/src/main/java/com/commonsware/android/livedata/bus/ScheduledService.java)
MutableLiveData is a subclass of LiveData, with one key feature: it offers a
postValue() method that works like setValue() but can be called from a
background thread. Here, our events are in the form of Intent objects, the way they
would be for LocalBroadcastManager. However, you could create your own custom
event objects if you prefer, and typically that would be a better idea. In this case, the
sample is demonstrating a quick-and-dirty change from LocalBroadcastManager, so
we are keeping the event objects the same to reduce the number of code changes.
The service, as part of its work, asks the BUS whether there are any active observers,
by means of hasActiveObservers(). If hasActiveObservers() returns true, we use
postValue() to post the event onto our BUS. Otherwise, we raise a Notification, as
our UI is not in the foreground.
LIVEDATA
121

(note: this service extends WakefulIntentService, and so the method is
doWakefulWork() instead of the onHandleIntent() that you might typically use with
an IntentService).
Our EventLogFragment registers an observer lambda on the BUS, adding the events
to its ArrayAdapter:
ScheduledService.BUS.observe(this
this, intent -> adapter.add(intent));
(from General/LiveBus/app/src/main/java/com/commonsware/android/livedata/bus/EventLogFragment.java)
Unlike LocalBroadcastManager, this approach performs no Intent filtering, and we
can have as many MutableLiveData objects as needed. So, you can create custom
buses for different event channels, instead of using action strings as you might with
LocalBroadcastManager.
Room
Having DAO methods in Room return a LiveData is simply a matter of setting them
up that way:
@Query("SELECT * FROM Customer WHERE postalCode IN (:postalCodes) LIMIT :max")
LiveData<List<Customer>> findByPostalCodes(int max, String... postalCodes);
(from General/LiveRoom/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
Now, findByPostalCodes() will return a LiveData. Moreover, it will do so
immediately when called, with the actual query being performed on a Room-
supplied background thread. You can arrange to register an observer to find out
when the results are ready. And, by using the same LiveData instance after a
configuration change, you can get the last-loaded results without having to perform
another round of disk I/O.
However, Room has an additional feature: if you make changes to the database
through your DAO, Room will deliver fresh results to any registered observer of your
LiveData. So, for example:
• You register an observer on a LiveData, returned by a Room @Query, that
represents a list of your entities
• Shortly thereafter, you get the list of entities as they exist in the database at
present, for you to fill into your RecyclerView (or whatever)
• Later on, as part of processing a request from the user, you invoke an
@Insert method on your DAO to add a new entity to the database
LIVEDATA
122

• Your registered observer gets the updated list of entities as they exist in the
database, for you to fill into your RecyclerView (or whatever)
• And so on
In effect, Room attempts to give you ContentObserver capabilities, for your own
database, tied directly into the LiveData system.
Note, though, that these changes are tied in large part to your use of the DAO. For
example, if you want to insert 100 entities, you could:
• Call a single @Insert method that takes a List of those entities, in which
case you will get a single update from the LiveData
• Call a one-entity @Insert method 100 times, in which case you will get 100
updates from the LiveData
Doing things in batch form generally will be more efficient, both from a disk I/O
standpoint and a LiveData-updating standpoint. On the other hand, this means that
a LiveData update might represent several changes, and that may require additional
smarts to handle properly in terms of updating the UI (e.g., use DiffUtil to
efficiently update a RecyclerView).
We will see using LiveData with Room in the next chapter.
Testing LiveData
LiveData works asynchronously, and so your tests have to deal with this. There are
various patterns for handling asynchronous tests. One is to use a CountDownLatch.
The General/LiveRoom sample project has the revised findByPostalCodes()
method shown above, and so we need to modify the instrumentation tests to match.
The DaoTests class now has two additional fields:
1. A CountDownLatch named responseLatch
2. A List of Customer objects, named customers
In setUp(), we initialize the CountDownLatch, set to track one event:
@Before
public
public void setUp() {
db=StuffDatabase.create(InstrumentationRegistry.getTargetContext(), true
true);
LIVEDATA
123

store=db.stuffStore();
responseLatch=new
new CountDownLatch(1);
}
(from General/LiveRoom/stuff/src/androidTest/java/com/commonsware/android/room/dao/DaoTests.java)
In the test, we can retrieve the LiveData, register an observer, and have the observer
save the results in customers and countDown() the CountDownLatch:
final
final LiveData<List<Customer>>
liveResult=store.findByPostalCodes(10, firstCustomer.postalCode);
final
final Observer<List<Customer>> observer=new
new Observer<List<Customer>>() {
@Override
public
public void onChanged(@Nullable List<Customer> customers) {
DaoTests.this.customers=customers;
responseLatch.countDown();
}
};
liveResult.observeForever(observer);
responseLatch.await();
(from General/LiveRoom/stuff/src/androidTest/java/com/commonsware/android/room/dao/DaoTests.java)
Instrumentation test methods run on background threads, and onChanged() is
called on the main application thread. So, we block the test thread via await(), to
wait on the disk I/O to complete. At that point, we have our List of Customer
objects for assertions.
LIVEDATA
124

ViewModel
Many Android apps are trivial. The smaller the app, the less likely it is that you need
much in the way of a true GUI architecture. Slapping together whatever you want
wherever you want it most likely will suffice. Your average soundboard, flashlight,
front-facing-camera “mirror”, and similar apps just do what they do, and their
developers do not need to worry about the alphabet soup of MVC, MVP, MVVM,
MVI, and so on.
If you are reading this book, you may have an app in mind that is not so trivial.
The more complex the app, the more likely it is that you are going to want to think
more seriously about the GUI architecture. The Architecture Components
contribution to this is the ViewModel, which we will explore in this chapter.
ViewModels, As Originally Envisioned
Microsoft devised the model-view-viewmodel (MVVM) GUI architecture in 2005,
and it has remained generally murky ever since. This is not terribly surprising, as
many of the “alphabet soup” GUI architectures have malleable definitions which
developers can twist and tweak to match what it is that they want to write.
Roughly speaking, in this GUI architecture, the “view model” represents a collection
of data and other state, necessary to render a view, derived from the underlying
models. The view model would be responsible for things like data formatting (e.g.,
converting the model’s long Unix epoch time into something that the user will be
able to read). The view updates the view model, which in turn updates the model at
the appropriate time.
125

Ideally, the view model knows nothing much about the view, but rather just exposes
data and operations that the view needs.
The Architecture Components ships with a ViewModel class. This class does almost
nothing. This will be an important point, as what little we get from ViewModel can
be implemented in other ways without significant difficulty. But, for now, consider
ViewModel to be a place to hold the data necessary to represent your views. For
example, a ViewModel might hold a list of objects, obtained from Room, that are
used to populate a RecyclerView.
ViewModel Versus…
The objective of ViewModel, in particular, is to be able to survive past configuration
changes.
Of course, we have been dealing with configuration changes for years, before the
Architecture Components were a glimmer in any Google engineer’s eye.
So, when would we use a ViewModel, and when would we use other techniques?
…Saved Instance State
Saved instance state — what you put into the Bundle supplied to
onSaveInstanceState() – survives process termination. A ViewModel does not. So
while both can help deal with configuration changes, only saved instance state can
help with the process termination scenario:
• User is in your app, in an activity
• User navigates to something else (e.g., presses HOME, switches to another
task via the overview screen)
• A few minutes later, Android terminates your process to free up system RAM
• A few minutes after that — but within 30 minutes of the user navigating
away – the user returns to your task
• Android recreates the activity atop your task’s back stack as part of forking a
fresh process for you, and Android hands you your saved instance state
Bundle back
However, the saved instance state Bundle has size limits (should be well under 1MB)
and type limits (only objects that can go into a Parcel).
VIEWMODEL
126

As a result:
• Use the ViewModel for holding onto data in your process necessary to be able
to rapidly repopulate the UI after a configuration change
• Use the saved instance state Bundle to hold identifiers and other data that
will help you rebuild the UI after process termination, even if you wind up
having to re-read from disk or the network as part of that work
…Retained Objects
In the end, the ViewModelProviders system supplied by the Architecture
Components is an oddly-written wrapper around retained fragments. As a result,
there is nothing that you can do with a ViewModel that you could not do using
retained objects, whether those are retained fragments or using
onRetainNonConfigurationInstance(). We will see examples of this later in this
chapter.
Dependencies
For 1.1.0 and higher of the lifecycle components, you get ViewModel and related
classes from the android.arch.lifecycle:viewmodel artifact.
For 1.0.3 and earlier versions of the lifecycle components, you get these classes
from android.arch.lifecycle:extensions. You can still use that artifact if you
want; it pulls in both viewmodel and livedata, the latter for LiveData and its
support classes.
Mommy, Where Do ViewModels Come From?
You might think that you create a ViewModel via whatever constructor you set up for
it. And, if you are going to manage a ViewModel yourself — via the retained object
pattern described above — then this is perfectly fine.
The Architecture Components expect you to get a ViewModel instance by using
ViewModelProvider. A ViewModelProvider instance is tied to either:
• A FragmentActivity (or a subclass, like AppCompatActivity), or
• A Fragment, from the fragments backport
If you do not have one of those, you cannot use ViewModelProvider.
VIEWMODEL
127

If you do have one of those, call the static of() method on the
ViewModelProviders class (note the plural) to get a ViewModelProvider (note the
singular) tied to your FragmentActivity or Fragment. This ViewModelProvider is
tied to the logical instance of this activity or fragment, regardless of configuration
changes. So, if the activity is destroyed and recreated as part of a configuration
change, you will get the same ViewModelProvider instance in the new activity as you
had in the old one.
Then, to get a ViewModel, call get() on the ViewModelProvider, passing in the Java
class object for your subclass of ViewModel (e.g., MyViewModel.class). If there
already is an instance of this ViewModel tied to this ViewModelProvider, you get that
instance. Otherwise, a fresh instance will be created for you, from the zero-
argument constructor. If using the zero-argument constructor is not what you want,
you can:
• Create an implementation of the ViewModelProvider.Factory interface,
implementing the create() method to create an instance of your ViewModel
by whatever constructor you want
• Associate an instance of your ViewModelProvider.Factory with the
ViewModelProvider by supplying it as a second parameter to the of()
method on ViewModelProviders
So, in the typical case, you wind up with code like this:
TripRosterViewModel vm=
ViewModelProviders.of(this
this).get(TripRosterViewModel.class);
(from Trips/ViewModels/app/src/main/java/com/commonsware/android/room/TripsFragment.java)
Here, this inherits from the Fragment backport, and we are retrieving a
TripRosterViewModel to use in that fragment.
We will see this code snippet again in the next section.
ViewModels, Google’s Way
So, let’s take a look at the Trips/ViewModels sample project. This adds a ViewModel
to our app showing a roster of upcoming trips. More specifically, we will use
ViewModelProvider, the way Google envisioned it.
VIEWMODEL
128

Earlier editions of this sample used Android’s native Activity and Fragment classes.
Those do not work with ViewModelProviders. So, in this sample, MainActivity has
been revised to extend from FragmentActivity and RecyclerViewFragment has been
revised to extend from LifecycleFragment. Using LifecyleFragment allows us to
use LiveData for retrieving our trips from Room. Otherwise, we could just use the
backport Fragment class, as ViewModelProvider has nothing to do with the lifecycle
classes.
Defining a ViewModel
The idea is that a ViewModel should hold the data necessary to render the UI. In our
case, that is simply a roster of Trip objects, pulled in from Room.
For ViewModelProvider to work, the class must be public, even though your IDE
might suggest otherwise. So, our TripRosterViewModel is public:
package
package com.commonsware.android.room;
import
import android.app.Application
android.app.Application;
import
import android.arch.lifecycle.AndroidViewModel
android.arch.lifecycle.AndroidViewModel;
import
import android.arch.lifecycle.LiveData
android.arch.lifecycle.LiveData;
import
import java.util.List
java.util.List;
public
public class
class TripRosterViewModel
TripRosterViewModel extends
extends AndroidViewModel {
final
final LiveData<List<Trip>> allTrips;
public
public TripRosterViewModel(Application app) {
super
super(app);
allTrips=TripDatabase.get(app).tripStore().selectAllTrips();
}
}
(from Trips/ViewModels/app/src/main/java/com/commonsware/android/room/TripRosterViewModel.java)
Note that TripRosterViewModel extends from AndroidViewModel. AndroidViewModel
itself extends ViewModel. The only difference between the two is the constructor:
ViewModel has a zero-argument constructor, while AndroidViewModel has a one-
argument constructor, supplying the Application instance. In our case, we need the
Application instance to get() our TripDatabase (as Room needs a Context for
this).
VIEWMODEL
129

TripRosterViewModel, in its constructor, sets up an allTrips field that is a LiveData
of our roster of Trip objects. Since this is LiveData, the actual work will not be done
until we ask it to, by registering an observer to use the results.
Getting a ViewModel
Our TripsFragment needs access to the TripRosterViewModel, in order to be able to
get to the allTrips data and request the roster of Trip objects.
However, now we have a decision to make: is the TripRosterViewModel tied to the
fragment or to the activity?
Since a fragment can get to its hosting activity via getActivity(), a fragment can
choose either scope:
• Pass this into of() to get the ViewModelProvider tied to the fragment, or
• Pass getActivity() into of() to get the ViewModelProvider tied to the
activity
Either is perfectly legitimate. Frequently, it will boil down to who needs the data.
Data that is only needed by a single fragment should be owned by a ViewModel tied
to that fragment. Data needed by multiple fragments, or by a fragment and the
activity, or just by the activity, should be owned by a ViewModel tied to the activity. A
fragment can also elect to do both, using two ViewModel instances, one for its own
data and one that it gets via the activity.
In this case, the only UI is the TripsFragment, so we can say that the
TripRosterViewModel is owned by the fragment and retrieve it as part of our
onViewCreated() work:
TripRosterViewModel vm=
ViewModelProviders.of(this
this).get(TripRosterViewModel.class);
(from Trips/ViewModels/app/src/main/java/com/commonsware/android/room/TripsFragment.java)
The first time we run through these lines, we will get a fresh TripRosterViewModel
instance. If we undergo a configuration change, when this fragment is recreated, the
new fragment instance will get the same TripRosterViewModel as before.
VIEWMODEL
130

Using the ViewModel
Given our TripRosterViewModel, our TripsFragment can now get at the roster of
Trip objects, by registering an Observer (via a lambda expression):
vm.allTrips.observe(this
this, trips -> {
setAdapter(new
new TripsAdapter(trips, getActivity().getLayoutInflater()));
if
if (trips==null
null || trips.size()==0) {
final
final TripStore store=TripDatabase.get(getActivity()).tripStore();
new
new Thread() {
@Override
public
public void run() {
store.insert(new
new Trip("Vacation!", 10080, Priority.MEDIUM, new
new Date()),
new
new Trip("Business Trip", 4320, Priority.OMG, new
new Date()));
}
}.start();
}
});
(from Trips/ViewModels/app/src/main/java/com/commonsware/android/room/TripsFragment.java)
A typical app would just have the setAdapter() call, to pass the Trip roster over to
the TripsAdapter, to show the roster in the RecyclerView. In this case, we want to
lazy-create some trips, as otherwise we will have no data. So, if we have no trips, we
insert some in a background thread.
However, there are two issues with that approach. One is the possible race
condition, where the user rotates the screen while the background thread is going
on, and so we fork a second thread. Since this code is not the sort of thing you would
do in a production app, what we have here will suffice for now.
But, if you run the app, you will see that our data shows up in the RecyclerView,
even after a fresh run of the app, when we did not have any data. Yet, our Thread is
not doing anything to refresh the UI. So, the second issue is: how is this working?
The answer is that Room is monitoring our DAO for changes and is automatically
updating the LiveData to reflect those changes, as was mentioned in the chapter on
LiveData.
Getting Rid of the ViewModel
Ideally, you should not have to do anything to explicitly “get rid of” a ViewModel. If
you are using LiveData, it is lifecycle-aware, and so it should clean up itself when
the activity or fragment is destroyed. If you have anything else in the ViewModel that
VIEWMODEL
131

needs cleanup when the activity or fragment is destroyed, use the lifecycle classes or
LiveData for that.
ViewModels as Simple POJOs
The primary limitation of ViewModelProviders is that it is inextricably tied to
FragmentActivity and the backport of Fragment. If you are using those classes, or
things inheriting from them (e.g., AppCompatActivity), great! If not, you will need
to pursue alternatives.
One alternative is to ignore ViewModel entirely, and implement a view model
yourself as a POJO, as we will explore in the Trips/ViewModelPOJO sample project.
This is a clone of the previous sample, except that we are using a POJO and
onRetainNonConfigurationInstance() rather than ViewModel and
ViewModelProviders.
Since we are not using ViewModelProviders, MainActivity inherits from Activity
and RecyclerViewFragment inherits from the framework’s implementation of
Fragment.
Defining a ViewModel
The ViewModel class itself, from the Architecture Components, mostly serves as a
marker. It adds very little logic. So, modifying TripRosterViewModel to be a POJO
simply involves removing AndroidViewModel:
package
package com.commonsware.android.room;
import
import android.app.Application
android.app.Application;
import
import android.arch.lifecycle.LiveData
android.arch.lifecycle.LiveData;
import
import java.util.List
java.util.List;
class
class TripRosterViewModel
TripRosterViewModel {
final
final LiveData<List<Trip>> allTrips;
TripRosterViewModel(Application app) {
allTrips=TripDatabase.get(app).tripStore().selectAllTrips();
}
}
(from Trips/ViewModelPOJO/app/src/main/java/com/commonsware/android/room/TripRosterViewModel.java)
VIEWMODEL
132

And, in this case, since we will create our TripRosterViewModel conventionally via
its constructor, it can be package-private, rather than public.
Getting a ViewModel
One downside to the POJO approach is that the simple way of using it as a view
model limits your scope to activities. Fragments do not have a trivial
onRetainNonConfigurationInstance()/getLastNonConfigurationInstance()
implementation the way activities do. It is certainly possible to do something to
retain a per-fragment view model across configuration changes, but it requires more
work (e.g., retained fragments).
So, here, we move the TripRosterViewModel management into MainActivity:
package
package com.commonsware.android.room;
import
import android.app.Activity
android.app.Activity;
import
import android.os.Bundle
android.os.Bundle;
import
import android.support.annotation.Nullable
android.support.annotation.Nullable;
public
public class
class MainActivity
MainActivity extends
extends Activity {
private
private TripRosterViewModel viewModel;
@Override
public
public void onCreate(Bundle savedInstanceState) {
super
super.onCreate(savedInstanceState);
viewModel=(TripRosterViewModel)getLastNonConfigurationInstance();
if
if (viewModel==null
null) {
viewModel=new
new TripRosterViewModel(getApplication());
}
if
if (getFragmentManager().findFragmentById(android.R.id.content)==null
null) {
getFragmentManager().beginTransaction()
.add(android.R.id.content,
new
new TripsFragment()).commit();
}
}
@Override
public
public Object onRetainNonConfigurationInstance() {
return
return(getViewModel());
}
VIEWMODEL
133

TripRosterViewModel getViewModel() {
return
return(viewModel);
}
}
(from Trips/ViewModelPOJO/app/src/main/java/com/commonsware/android/room/MainActivity.java)
onCreate() retrieves the TripRosterViewModel, creating a new instance if we do not
have one. onRetainNonConfigurationInstance() returns that
TripRosterViewModel, so we retain it across configuration changes. And we expose
the TripRosterViewModel to the TripsFragment via a getViewModel() method.
Now, TripsFragment can get the TripRosterViewModel by a simple call on the
hosting activity:
TripRosterViewModel vm=((MainActivity)getActivity()).getViewModel();
(from Trips/ViewModelPOJO/app/src/main/java/com/commonsware/android/room/TripsFragment.java)
Nothing else needs to change:
• We observe() the allTrips LiveData as before
• We still do not need to worry about cleaning up the LiveData when the
activity is destroyed and the TripRosterViewModel is no longer needed
VIEWMODEL
134

Other Lifecycle Owners
Activities and fragments are not the only things with lifecycles. The Architecture
Components also support other forms of lifecycle owner:
• Services, and
• What the documentation will refer to as “the process”
ProcessLifecycleOwner
With a name like ProcessLifecycleOwner, you might think that this modeled the
lifecycle of a process. Then, you quickly realize that this makes little sense, as the
only “lifecycle” that a process goes through is creation and termination, and we
cannot get control in the latter event.
Instead, ProcessLifecycleOwner might better be named
ForegroundLifecycleOwner. ProcessLifecycleOwner models the lifecycle of all
activities combined:
•
ON_CREATE is triggered when the process starts up
•
ON_START and ON_RESUME are triggered when an activity goes through those
lifecycle events, and no other activity had been started recently
•
ON_PAUSE and ON_STOP are triggered, after a delay, when an activity goes
through those lifecycle events, if another activity is not started and resumed
by this time
•
ON_DESTROY is never triggered
The delay period is 700ms (as of 1.0.0), so as long as another activity is started and
resumed after a prior activity was paused and stopped within 700ms, the process has
not undergone a lifecycle change, even though those individual activities did.
135

So, imagine a single-activity app:
•
ON_CREATE happens right away
•
ON_START and ON_RESUME happen shortly thereafter, assuming that the
process is starting because an activity is being displayed
• The user rotates the screen, causing the activity to be destroyed and
recreated
•
ON_PAUSE and ON_STOP do not occur, because a new activity was started and
resumed before the ProcessLifecycleOwner delay period elapsed
•
ON_START and ON_RESUME do not occur, because we did not move through the
paused and stopped lifecycle states, even though the new activity instance
did
• The user presses HOME, BACK, or otherwise leaves this activity for another
task
•
ON_PAUSE and ON_STOP happen after the delay period, since no activity from
this process went through ON_START and ON_RESUME during that time
Note that this comes at a cost: the extensions artifact automatically adds a
<provider> element to your manifest, one that initializes the
ProcessLifecycleOwner… even if your app does not use ProcessLifecycleOwner.
This is simply so ProcessLifecycleOwner code can be invoked as soon as your
process is started.
The General/ProcessLifecycle sample project has a LifecycleApplication that
registers itself as an observer of the singleton instance of ProcessLifecycleOwner
and dumps all the events to LogCat:
package
package com.commonsware.android.recyclerview.videolist;
import
import android.app.Application
android.app.Application;
import
import android.arch.lifecycle.DefaultLifecycleObserver
android.arch.lifecycle.DefaultLifecycleObserver;
import
import android.arch.lifecycle.Lifecycle
android.arch.lifecycle.Lifecycle;
import
import android.arch.lifecycle.LifecycleOwner
android.arch.lifecycle.LifecycleOwner;
import
import android.arch.lifecycle.OnLifecycleEvent
android.arch.lifecycle.OnLifecycleEvent;
import
import android.arch.lifecycle.ProcessLifecycleOwner
android.arch.lifecycle.ProcessLifecycleOwner;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import android.util.Log
android.util.Log;
public
public class
class LifecycleApplication
LifecycleApplication extends
extends Application
implements
implements DefaultLifecycleObserver {
@Override
public
public void onCreate() {
super
super.onCreate();
OTHER LIFECYCLE OWNERS
136

ProcessLifecycleOwner.get().getLifecycle().addObserver(this
this);
}
@Override
public
public void onCreate(@NonNull LifecycleOwner owner) {
Log.d(getClass().getSimpleName(), "ON_CREATE");
}
@Override
public
public void onStart(@NonNull LifecycleOwner owner) {
Log.d(getClass().getSimpleName(), "ON_START");
}
@Override
public
public void onResume(@NonNull LifecycleOwner owner) {
Log.d(getClass().getSimpleName(), "ON_RESUME");
}
@Override
public
public void onPause(@NonNull LifecycleOwner owner) {
Log.d(getClass().getSimpleName(), "ON_PAUSE");
}
@Override
public
public void onStop(@NonNull LifecycleOwner owner) {
Log.d(getClass().getSimpleName(), "ON_STOP");
}
@Override
public
public void onDestroy(@NonNull LifecycleOwner owner) {
Log.d(getClass().getSimpleName(), "ON_DESTROY");
}
}
(from General/ProcessLifecycle/app/src/main/java/com/commonsware/android/recyclerview/videolist/LifecycleApplication.java)
That LifecycleApplication is then registered in the manifest via android:name on
<application>:
<?xml version="1.0" encoding="utf-8"?>
<manifest
<manifest package="com.commonsware.android.recyclerview.videolist"
xmlns:android="http://schemas.android.com/apk/res/android"
android:versionCode="1"
android:versionName="1.0">>
<supports-screens
<supports-screens
android:anyDensity="true"
android:largeScreens="true"
android:normalScreens="true"
OTHER LIFECYCLE OWNERS
137

android:smallScreens="false" />
/>
<uses-permission
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
/>
<application
<application
android:allowBackup="false"
android:name=".LifecycleApplication"
android:icon="@drawable/ic_launcher"
android:label="@string/app_name"
android:theme="@style/Theme.Apptheme">>
<activity
<activity android:name=".MainActivity">>
<intent-filter>
<intent-filter>
<action
<action android:name="android.intent.action.MAIN" />
/>
<category
<category android:name="android.intent.category.LAUNCHER" />
/>
</intent-filter>
</intent-filter>
</activity>
</activity>
<activity
<activity
android:name=".VideoPlayerActivity"
android:configChanges="screenSize|smallestScreenSize|screenLayout|orientation"
android:launchMode="singleTask"
android:supportsPictureInPicture="true"
android:theme="@style/Theme.Apptheme.NoActionBar" />
/>
<receiver
<receiver android:name=".RemoteActionReceiver" />
/>
</application>
</application>
</manifest>
</manifest>
(from General/ProcessLifecycle/app/src/main/AndroidManifest.xml)
The app itself is a clone of one from The Busy Coder’s Guide to Android Development.
It consists of two activities. One shows a list of all videos indexed by the MediaStore.
The other plays back a selected video using a VideoView. And, on Android 8.0+
devices, the video player activity will have a FAB that switches that activity into
picture-in-picture mode.
(NOTE: to run this sample, your test device will need 1+ videos)
If you run it, you will see the ON_CREATE, ON_START, and ON_RESUME events logged in
rapid succession. And, if you do not press that enticing FAB, and just use the video
player in normal mode, ON_PAUSE and ON_STOP get invoked at normal times, such as
when the user navigates to some other task (e.g., presses HOME).
The FAB, though, changes things, as it moves the video player to a floating picture-
in-picture (PiP) window.
If you tap the FAB, and do not touch anything else for a bit, you will see ON_PAUSE,
then ON_RESUME, get logged. This is because:
OTHER LIFECYCLE OWNERS
138

• The PiP window never has the foreground from an input standpoint, and so
its activity is paused, but not stopped (as it is still visible)
• The underlying activity is started and resumed, though with a few seconds’
delay, for inexplicable reasons
Similarly, if you tap the PiP window, to bring up the controls, you will see ON_PAUSE
logged, as the list-of-videos activity is paused (it no longer has the foreground input)
but the PiP window is not resumed (the input is handled by the system UI, not the
activity). After a few moments of inactivity, that PiP window will return to its regular
state, and ON_RESUME will be logged.
Playing around with the PiP further (e.g., closing it via the X in the corner) allows
you to see how PiP mode ties into activity lifecycles.
LifecycleService
If you have a class that extends Service, you can replace it with LifecycleService
and get a service that is a LifecycleOwner. Four of the six lifecycle events are
honored:
This Lifecycle Event…
Is Triggered When…
ON_CREATE
the service is created
ON_START
when the service is first started or bound to
ON_RESUME
unused
ON_PAUSE
unused
ON_STOP
when the service is destroyed
ON_DESTROY
also when the service is destroyed
Of note, LifecycleService does not attempt to model binding/unbinding as a
lifecycle (e.g., calling ON_STOP when the service is unbound and has no more active
bindings).
However, most services do not directly inherit from Service. Instead, they extend
IntentService or JobService or any one of dozens of other specialized service
implementations. Few, if any, of those will extend LifecycleService, as most of
them come from the core framework, which cannot depend on libraries like the
Architecture Components.
OTHER LIFECYCLE OWNERS
139

Wait… Where Is LifecycleProvider and
LifecycleReceiver?
A ContentProvider has no real “lifecycle”. It is called with onCreate() when the
process starts up… and that’s about it. Similarly, a BroadcastReceiver is called with
onReceive()… and that’s about it.
OTHER LIFECYCLE OWNERS
140

Intermediate Topics


M:N Relations in Room
For 1:1 relations, one entity has a foreign key back to the other entity.
For 1:N relations, one entity has a foreign key back to the other entity. In other
words, 1:1 is simply 1:N for a specific small value of N.
In SQL, implementing M:N relations requires a join table of some form, where the
join table has foreign keys back to the entities being related. Room, using SQL at its
core, does not change this. And since Room does not model relations, but only
foreign keys, to create an M:N relation, you have to create a “join entity” that winds
up creating the associated join table.
In this chapter, we will take a look at how that is accomplished. Along the way, we
will also look at other Room tidbits, such as how to use static classes as entities.
Implementing a Join Entity
The General/RoomMN sample project demonstrates an M:N relation. From earlier
chapters, we have a Customer entity and a Category entity. Previously, those were
unrelated. Now, let’s implement an M:N relation between them, so a Customer can
be a member of zero or more categories, and a Category can have zero or more
customers.
Note that we are retaining the tree structure for Category used previously. For the
purposes of this chapter, we are ignoring that, considering a customer to belong to a
category only via a direct relationship. So for example, if customer Foo belongs to
category Child, which has a parent category Parent, Foo is not a member of Parent.
The tree structure simply organizes categories, without impacting customers.
143

Static Entity Classes
Much of the time, your entity classes will be standard, top-level Java classes.
Sometimes, though, you might have some utility class that you would rather have as
a static class, nested inside something else. For example, in the case of a join entity,
perhaps you might want to tuck it inside of one of the entities being joined, just to
reduce the clutter of your namespace.
Fortunately, this works, albeit with a wrinkle.
In the sample project, the Customer class — which itself is an entity — has a static
class named CategoryJoin that will serve as the join entity:
package
package com.commonsware.android.room.dao;
import
import android.arch.persistence.room.Embedded
android.arch.persistence.room.Embedded;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.ForeignKey
android.arch.persistence.room.ForeignKey;
import
import android.arch.persistence.room.Ignore
android.arch.persistence.room.Ignore;
import
import android.arch.persistence.room.Index
android.arch.persistence.room.Index;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.Date
java.util.Date;
import
import java.util.Set
java.util.Set;
import
import java.util.UUID
java.util.UUID;
import
import static
static android.arch.persistence.room.ForeignKey.CASCADE;
@Entity(indices={@Index(value="postalCode", unique=true
true)})
class
class Customer
Customer {
@PrimaryKey
@NonNull
public
public final
final String id;
public
public final
final String postalCode;
public
public final
final String displayName;
public
public final
final Date creationDate;
@Embedded
public
public final
final LocationColumns officeLocation;
public
public final
final Set<String> tags;
@Ignore
Customer(String postalCode, String displayName, LocationColumns officeLocation,
Set<String> tags) {
this
this(UUID.randomUUID().toString(), postalCode, displayName, new
new Date(),
officeLocation, tags);
}
Customer(String id, String postalCode, String displayName, Date creationDate,
LocationColumns officeLocation, Set<String> tags) {
this
this.id=id;
this
this.postalCode=postalCode;
this
this.displayName=displayName;
M:N RELATIONS IN ROOM
144

this
this.creationDate=creationDate;
this
this.officeLocation=officeLocation;
this
this.tags=tags;
}
@Entity(
tableName="customer_category_join",
primaryKeys={"categoryId", "customerId"},
foreignKeys={
@ForeignKey(
entity=Category.class,
parentColumns="id",
childColumns="categoryId",
onDelete=CASCADE),
@ForeignKey(
entity=Customer.class,
parentColumns="id",
childColumns="customerId",
onDelete=CASCADE)},
indices={
@Index(value="categoryId"),
@Index(value="customerId")
}
)
public
public static
static class
class CategoryJoin
CategoryJoin {
@NonNull public
public final
final String categoryId;
@NonNull public
public final
final String customerId;
public
public CategoryJoin(String categoryId, String customerId) {
this
this.categoryId=categoryId;
this
this.customerId=customerId;
}
}
}
(from General/RoomMN/stuff/src/main/java/com/commonsware/android/room/dao/Customer.java)
Room is perfectly content to work with this class, so long as you also register it with
your RoomDatabase via its @Database annotation:
@Database(
entities={Customer.class, Category.class, Customer.CategoryJoin.class},
version=1
)
(from General/RoomMN/stuff/src/main/java/com/commonsware/android/room/dao/StuffDatabase.java)
However, note that this is a static class. Room will not be able to work with a
non-static nested class, as only instances of the outer class can create instances of
the nested class.
Also, note that the default table name is based on the plain class name. In this case,
the default table name is CategoryJoin. The outer class name (Customer) is not
added into the table name. Normally, this will not be a problem, and you might be
M:N RELATIONS IN ROOM
145

renaming the table anyway. However, where you can get tripped up is if you decided
to have two (or more) classes with the same name, such as having CategoryJoin
inside both Customer and some other entity. Then, you would wind up with two
entity classes both trying to define the same table name by default, and Room will
not like that very much.
Foreign Keys and Indices
Let’s take a closer look at the @Entity annotation on Customer.CategoryJoin:
@Entity(
tableName="customer_category_join",
primaryKeys={"categoryId", "customerId"},
foreignKeys={
@ForeignKey(
entity=Category.class,
parentColumns="id",
childColumns="categoryId",
onDelete=CASCADE),
@ForeignKey(
entity=Customer.class,
parentColumns="id",
childColumns="customerId",
onDelete=CASCADE)},
indices={
@Index(value="categoryId"),
@Index(value="customerId")
}
)
(from General/RoomMN/stuff/src/main/java/com/commonsware/android/room/dao/Customer.java)
Here, we declare four properties.
tableName renames the table to something that is more unique to this situation,
incorporating both “customer” and “category” in the name. That way, if we do wind
up with CategoryJoin elsewhere, we can avoid table name collisions.
primaryKeys is used, instead of @PrimaryKey, because we need a composite key. The
uniqueness is determined by the combination of the IDs of the Customer and
Category, held in customerId and categoryId columns, respectively.
A join entity will need foreign keys back to both entities that it is joining. So, here,
we have two @ForeignKey annotations for the foreignKeys property, connecting to
M:N RELATIONS IN ROOM
146

both Customer and Category by their respective IDs. We also use onDelete=CASCADE,
so if the parent entity (Customer or Category) is deleted, we also delete all join
entities associated with that parent.
And, since Room does not automatically add indices for foreign key columns, we
add them ourselves, so we can rapidly find all of the join entity instances for a given
Customer or Category.
Implementing DAO Methods
In addition to setting up the join entity, we need to leverage it in our DAO.
Otherwise, the join entity is pointless.
Adding and Removing Relations
In many ORMs, where relations are directly implemented on model objects, you
connect objects by direct manipulation. In our case, a Customer might have
addCategory() and removeCategory() methods, and Category might have
addCustomer() and removeCustomer().
Since Room models foreign keys, not relations, that’s not how we connect a
Customer and a Category. Instead, we do it much the same way as you would with
plain SQL: @insert and @Delete Customer.CategoryJoin instances representing a
particular customer-category connection.
And, to that end, we have suitable DAO methods for this:
@Insert
void insert(Customer.CategoryJoin... joins);
@Delete
void delete(Customer.CategoryJoin... joins);
(from General/RoomMN/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
And, to connect a specific Customer instance to a specific Category instance, we set
up the Customer.CategoryJoin instance and insert() it:
tags.add("sculpture");
tags.add("bronze");
tags.add("slow-pay");
final
final LocationColumns loc=new
new LocationColumns(40.7047282, -74.0148544);
M:N RELATIONS IN ROOM
147

final
final Customer firstCustomer=new
new Customer("10001", "Fearless Girl", loc, tags);
tags.remove("slow-pay");
tags.add("large");
final
final Customer secondCustomer=new
new Customer("10002", "Charging Bull", loc, tags);
store.insert(firstCustomer, secondCustomer);
final
final Category root=new
new Category("Root!");
final
final Category child=new
new Category("Child!", root.id);
store.insert(root, child);
final
final Customer.CategoryJoin join=
new
new Customer.CategoryJoin(root.id, secondCustomer.id);
store.insert(join);
(from General/RoomMN/stuff/src/androidTest/java/com/commonsware/android/room/dao/DaoTests.java)
Fetching Via the Join
If an ORM offers addCategory() and removeCustomer() methods, presumably that
ORM also offers getCategories() on Customer and getCustomers() on Category, to
identify the members of a relation with a specific entity.
Again, Room does not work that way.
Instead, we crack open our SQL syntax reference and craft an INNER JOIN ourselves,
to use in a @Query method:
@Query("SELECT categories.* FROM categories\n"+
"INNER JOIN customer_category_join ON categories.id=customer_category_join.categoryId\n"+
"WHERE customer_category_join.customerId=:customerId")
List<Category> categoriesForCustomer(String customerId);
@Query("SELECT Customer.* FROM Customer\n"+
"INNER JOIN customer_category_join ON Customer.id=customer_category_join.customerId\n"+
"WHERE customer_category_join.categoryId=:categoryId")
List<Customer> customersForCategory(String categoryId);
(from General/RoomMN/stuff/src/main/java/com/commonsware/android/room/dao/StuffStore.java)
Here we have methods that return the members of a specific relation, so we can find
the categories for a Customer or the customers for a Category. And the DAO
methods return sensible data types. But, it is our job to set up the SQL.
So, in the case of categoriesForCustomer(), our SQL:
M:N RELATIONS IN ROOM
148

• Retrieves all columns from the categories table…
• …where we JOIN with customer_category_join based on the IDs…
• …and find all those where the join entity points to a specific customer ID
Where’s That Good Ol’ Object Feel?
By this point, some of you may be wanting to dismiss Room outright, as being too
thin of a wrapper around the SQL. Certainly, Room has, um, room for improvement.
However, a lot of the pain may come from what you are thinking that entities
represent. Many developers, particularly those using ORMs in other environments,
will think of entities as being model objects.
That’s not the best approach with Room.
Instead, consider entities to be more akin to data transfer objects (DTOs). They are a
means of getting data from point (SQLite) to point (your application code), and not
much more.
For example, pretend that the SQLite database was on a server somewhere, and you
wrapped it in a Web service which you accessed from your Android app via Retrofit
or some similar library. Developers are used to thinking of the POJOs that you might
get back from a REST call to be DTOs, objects that model the Web service response,
not necessarily modeling any business logic within the app.
Room is much the same. The entities are DTOs from the relational data store to
your app, but may or may not line up with how you would want to represent that
data in memory as “real” model objects. So, just as you sometimes convert the
Retrofit response object graph into something more useful, you sometimes convert
the Room response POJOs into something more useful.
Consider the DAO and the entities to be a low-level API, much as you might
consider Retrofit or other REST access layers. If you need a richer object
representation of your data, wrap the DAO and entities in some sort of repository
object, one that knows more about your app’s needs and can perform the
conversions as needed. That repository can also handle details like transactions, to
keep your business logic clean from any details about how the data storage is
accomplished. The ultimate goal would be to replace one repository implementation
(e.g., using Room) with another (e.g., using Realm or Couchbase Mobile or some
M:N RELATIONS IN ROOM
149

non-SQL solution), without having to change anything related to the business logic
itself.
M:N RELATIONS IN ROOM
150

LiveData Transformations
Sometimes, the data that you want is not the data that you get:
• You want to capitalize those names before showing them in a list
• You want to restrict the results to some subset of what you are receiving
• You do not need the data, but rather some calculation made upon batches of
the data, grouped by some key
• And so on
The LiveData system has some limited support for “transformations”, which help
you adapt an existing LiveData into one that changes the data to better suit your
needs. You can also create your own transformations, if desired. In this chapter, we
will explore all of this.
The Bucket Brigade
LiveData is designed to be a simplified form of a reactive framework like RxJava.
Anyone who has looked at RxJava code knows that it has a tendency towards long
chains of calls, to configure a stream of data, and sometimes to modify that stream
along the way.
For example, you will find code like:
Observable<String> observable=Observable
.create(new
new WordSource(getActivity()))
.subscribeOn(Schedulers.io())
.map(s -> (s.toUpperCase()))
.observeOn(AndroidSchedulers.mainThread())
.doOnComplete(() -> {
151

Toast.makeText(getActivity(), R.string.done, Toast.LENGTH_SHORT)
.show();
});
Here, we:
• Request a roster of words (create(new WordSource(getActivity())))
• Ask to retrieve that roster on a background thread, as it involves disk I/O
(subscribeOn(Schedulers.io()))
• Convert the words to uppercase (map(s -> (s.toUpperCase())))
• Ask to get the results on the main application thread, so we can update our
UI with these words (observeOn(AndroidSchedulers.mainThread()))
• Show a Toast when we are done processing the words (doOnComplete() ...)
(if you are interested in learning more about RxJava, see The Busy Coder’s Guide to
Android Development)
In particular, map() is a transformation “operator”, in Rx terms. map() takes an object
from our stream of data (in this case, a word) and transforms it into something else,
which flows downstream to the subsequent chained calls. In this case, map()
transforms a String into a String, where the “transformation” is converting the
input String to uppercase to use as the output String.
RxJava has a dozens of such operators. In contrast, LiveData has two, and we will
implement a third ourselves to see how that is accomplished.
Mapping Data to Data
Both RxJava and LiveData offer a map() transformation. As seen in the preceding
section, a map() converts an item of data from the stream (e.g., a String) to some
other item of data to flow downstream (e.g., an uppercase String).
However, whereas map() is a method on RxJava’s Observable and related classes,
with LiveData, the transformations are held in a separate Transformations class.
For example, suppose we have a DAO method like:
@Query("SELECT * FROM Customer")
LiveData<List<Customer>> allCustomers();
LIVEDATA TRANSFORMATIONS
152

Here, we are expecting a stream of results. However, Room only supports returning
one item in the stream: a list of Customer objects.
Suppose, though, we do not need the Customer objects, but instead need their IDs.
The simplest and most performant solution would be to have a different DAO
method:
@Query("SELECT id FROM Customer")
LiveData<List<String>> allCustomerIds();
However, that does not use Transformations, and so it is boring. Plus, not every
possible transformation is simply cutting a POJO down to a single field from that
POJO.
The Transformations equivalent would be something like this:
LiveData<List<String>> liveCustomerIds=
Transformations.map(store.allCustomers(),
new
new Function<List<Customer>, List<String>>() {
@Override
public
public List<String> apply(List<Customer> customers) {
ArrayList<String> result=new
new ArrayList<>();
for
for (Customer customer : customers) {
result.add(customer.id);
}
return
return(result);
}
});
map() takes two parameters: a LiveData of the stream to manipulate, and a Function
that converts items from that stream from one data type to another.
Here is where Room’s insistence on a single-object response becomes a pain. If this
were a stream of Customer objects, our Function could just get the id from the
Customer and return it. But we do not have a stream of Customer objects — we have
a stream of a list of Customer objects. That means we need to return a list of
customer IDs, requiring allocating a new ArrayList and iterating over each
Customer to add its id to that list.
LIVEDATA TRANSFORMATIONS
153

This would be a little bit cleaner with Java 8 lambda expressions. The proof of this is
left as an exercise for the reader, until sometime after Android Studio 3.0 ships, at
which time this book will be updated to use lambda expressions.
Mapping Data to… LiveData?
So now we have a list of Customer IDs. Suppose that we now want to retrieve the
categories associated with all of the Customer entities. That requires another
database request via our DAO:
@Query("SELECT categories.* FROM categories\n"+
"INNER JOIN customer_category_join ON
categories.id=customer_category_join.categoryId\n"+
"WHERE customer_category_join.customerId IN (:customerIds)")
LiveData<List<Category>> categoriesForCustomers(List<String> customerIds);
And if we are on the main application thread — as is typical when working with
LiveData results — we need the DAO to return another LiveData.
In principle, you could use map() for this. However, for this scenario, there is the
oddly-named switchMap(). This says that the objects being created via the mapping
are themselves LiveData. This help the LiveData system keep everything in sync,
particularly across lifecycle events.
So, given the liveCustomerIds from the preceding section, we can get the categories
via:
final
final LiveData<List<Category>> liveCategories=
Transformations.switchMap(liveCustomerIds,
new
new Function<List<String>, LiveData<List<Category>>>() {
@Override
public
public LiveData<List<Category>> apply(List<String> customerIds) {
return
return(store.categoriesForCustomers(customerIds));
}
});
And, if we arrange to observe() that liveCategories object, we will be called with
onChanged() when the list of Category objects is available, after the initial database
I/O to get the customers, then the secondary database I/O to get the categories for
those customers.
LIVEDATA TRANSFORMATIONS
154

Writing a Transformation
Another RxJava transformation operator is filter(). This takes a stream of objects
and a function that tests each object and returns true for the ones to be sent
downstream. The ones that test out to false are dropped. Hence, the stream
becomes filtered by whatever rule is encoded in that function.
Transformations does not have a filter() method, but we can write one, to see
what a transformation method looks like.
Earlier in the book, we had the LiveSensor sample, where we had a LiveData
reporting sensor events, specifically the light level. The General/LiveFilter sample
project is a clone of that project, one that introduces a filter, to only report those
readings that fall between 20 and 40 lux.
To that end, we have a LiveTransmogrifiers class that serves as a home for our
transformation methods:
package
package com.commonsware.android.livedata;
import
import android.arch.lifecycle.LiveData
android.arch.lifecycle.LiveData;
import
import android.arch.lifecycle.MediatorLiveData
android.arch.lifecycle.MediatorLiveData;
import
import android.support.annotation.MainThread
android.support.annotation.MainThread;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
class
class LiveTransmogrifiers
LiveTransmogrifiers {
interface
interface Confirmer
Confirmer<T> {
boolean test(T thingy);
}
@MainThread
static
static <X> LiveData<X> filter(@NonNull LiveData<X> source,
@NonNull final
final Confirmer<X> confirmer) {
final
final MediatorLiveData<X> result=new
new MediatorLiveData<>();
result.addSource(source, x -> {
if
if (confirmer.test(x)) {
result.setValue(x);
}
});
return
return(result);
}
}
LIVEDATA TRANSFORMATIONS
155

(from General/LiveFilter/app/src/main/java/com/commonsware/android/livedata/LiveTransmogrifiers.java)
The RxJava filter() operator uses a Predicate as the function for testing an object
to determine if it should be passed or not. Unfortunately, Predicate is part of the
Java 8 classes added in Android 7.0, and so it is unavailable for older devices. So, we
have a Confirmer interface that fills that role. The test() method on a Confirmer
needs to return true for objects that should pass the filter, false otherwise.
The filter() method on LiveTransmogrifiers takes a LiveData of some type and a
Confirmer of that type. It then uses a MediatorLiveData, which is a LiveData object
that can chain onto an existing LiveData and expose the onChanged() method for
outside parties to use. In this case, our lambda uses the Confirmer to see if the new
object passes the test(), and if it does, we call setValue() on the
MediatorLiveData to have that object flow along to anything that observes that
MediatorLiveData. filter() then returns that MediatorLiveData. The net effect is
as if filter() wraps the original LiveData in another LiveData that applies our
filtering rule.
We can now use filter() to limit the readings that we get from the sensor:
final
final LiveData<SensorLiveData.Event> filtered=
LiveTransmogrifiers.filter(state.sensorLiveData,
event -> (event.values[0]>20 && event.values[0]<40));
filtered.observe(this
this, event -> adapter.add(event));
(from General/LiveFilter/app/src/main/java/com/commonsware/android/livedata/MainActivity.java)
We pass our original SensorLiveData to filter(), along with a Confirmer (in the
form of a lambda expression) that sees if the light level is between 20 and 40. Then,
we observe the results of the filter() call and only add those objects — not every
reading from the SensorLiveData — to the EventLogAdapter.
The net result, if you compare and contrast the output of this sample with the
original, is that while the original reports everything, this new sample only reports a
subset of the data.
Do We Really Want This?
LiveData was not set up to have a vast library of transformations, the way that
RxJava has its vast library of operators. map() and switchMap() are almost
afterthoughts. And while Google may not add many more transformations to the
LIVEDATA TRANSFORMATIONS
156

Transformations class, undoubtedly somebody will create a library with
implementations of filter() and a handful of other RxJava-style operators.
However, those libraries will be limited, because LiveData itself is not as rich a
framework as is RxJava. There is no notion in LiveData of propagating errors, or
indicating that a stream is completed. Some RxJava operators will be difficult or
impossible to implement as a result.
And this is by design.
LiveData is designed to be simple and lifecycle aware. That’s it. If your needs
transcend what LiveData can handle well, consider migrating to RxJava. Conversely,
if LiveData handles everything that you need, you can skip RxJava’s complexity.
LIVEDATA TRANSFORMATIONS
157


RxJava and Room
In a previous chapter, we saw how a Room DAO could return a LiveData object as a
wrapper around the “real” data to be retrieved from the database. Then, the @Query
method would no longer be a blocking call, but instead would return the LiveData
immediately, with the actual query results being delivered to any observers of the
LiveData.
Not surprisingly, you can do the same thing with RxJava types. Simply wrap the
return type from the @Query method in a suitable RxJava type. You get the same
results as you do with LiveData: the @Query method returns the RxJava object
immediately, and you get the actual query results via RxJava’s subscriber system.
However, RxJava is a much richer library, and it is commensurately more complex. In
this chapter, we will explore what RxJava types can be returned by a @Query, how
those work with respect to data changes, and how the underlying data type affects
all of that.
Adding RxJava
RxJava has its own dependencies. In an Android app, typically you will use
io.reactivex.rxjava2:rxjava and io.reactivex.rxjava2:rxandroid, where the
latter provides utility classes like AndroidSchedulers.
However, Room itself does not have a transitive dependency upon RxJava.
Otherwise, everybody using Room would need to pull in RxJava, and that would add
unnecessary bloat.
So, in addition to the regular dependencies for RxJava and the regular dependencies
for Room (e.g., android.arch.persistence.room:runtime), you also need the
159

android.arch.persistence.room:rxjava2 dependency. This contains the glue code
necessary to tie Room to RxJava:
implementation "android.arch.persistence.room:runtime:1.0.0"
implementation "android.arch.persistence.room:rxjava2:1.0.0"
annotationProcessor "android.arch.persistence.room:compiler:1.0.0"
(from Trips/RxRoom/app/build.gradle)
If you forget this dependency, but you have the regular RxJava and Room
dependencies, you will not notice a problem right away. You will be able to use
RxJava types in your DAO, because Android Studio knows about RxJava through
your existing dependencies. However, when you go to build and run the project,
your build will fail with:
Error:(41, 24) error: To use RxJava2 features, you must add `rxjava2` artifact from
Room as a dependency. android.arch.persistence.room:rxjava2:<version>
A Quick Sidebar on Rx Testing
Testing RxJava in general can be a bit interesting, given that you need to have your
test methods wait for the results to come in before you can assert whether the
results match expectations. You will see various approaches used by developers for
testing RxJava-powered Room DAOs, including those in the following sections.
The InstantTaskExecutorRule
The JavaDocs — and a prominent Medium post – offer an
InstantTaskExecutorRule. This is a JUnit4 @Rule that you can use to change the
threading model used by the Architecture Components. Basically, any place where a
background thread might be used, the main application thread is used instead.
However, this approach has issues:
• It requires you to call allowMainThreadQueries() on your
RoomDatabase.Builder, as otherwise Room will crash if you apply
InstantTaskExecutorRule
• It weakens your tests, by having you test something (queries on the main
application thread) that differs substantially from what you run in
production (queries running on a background thread)
RXJAVA AND ROOM
160

• If you manually use observeOn() to control the threading in your own code,
it is unclear how this will interact with InstantTaskExecutorRule
The Blocking Calls
If you want to leave the Architecture Components’ threading alone — so the code
that you are testing more closely resembles the code that you will run in production
— you still need to arrange to block in your test methods. You cannot allow a test
method to return until you are done testing whatever it is that you are going to test.
A simple approach for this is to use RxJava blocking...() calls. Many RxJava types
offer methods like blockingGet() and blockingFirst(). These do what their names
suggest: they block the current thread until there is data to be returned from the
observable. For cases where you have a one-time asynchronous result — you query
the database and want to test what it returns — these blocking calls are a simple
way to implement the tests.
The CountDownLatch
However, that approach breaks down when you need to test longer-term
asynchronous work. For example, you may want to:
• Subscribe to an observable, waiting for a result
• Test to confirm that you did not receive a result immediately
• Do something in your test code that will trigger an event from the
observable
• Test to confirm that you now did receive a result, and the result is what you
expected
The blocking...() family of calls do not handle this sort of scenario well. Here, you
are more than likely going to wind up with other lower-level solutions, such as using
a CountDownLatch to allow the test method to block (with a timeout) until some
event is emitted by the observable.
In this chapter, we will see the latter two techniques (blocking...() and
CountDownLatch) in use.
RXJAVA AND ROOM
161

Rx Query Response Types
There are three major RxJava types that you can use to wrap a @Query response and
get a reactive response: Flowable, Single, and Maybe. The use of these are illustrated
in the Trips/RxRoom sample project, and in particular some instrumentation test
classes that exercise a version of TripStore that offer reactive queries.
Publisher and Flowable
While we tend to focus on RxJava, bear in mind that RxJava 2 is itself based upon a
broader Reactive Streams initiative, which has its own library. Effectively, Reactive
Streams offers a common API for some high-level constructs, to help make it easier
to have multiple disparate reactive libraries be able to inter-operate.
One key class from Reactive Streams is Publisher, which is the source of events that
get “published”. The primary implementation of Publisher in RxJava 2 is Flowable.
In principle, you could use either type with Room, though you may be more
comfortable sticking with Flowable, so you are sticking with native RxJava types.
So, we can use Flowable in our queries:
@Query("SELECT * FROM trips ORDER BY title")
Flowable<List<Trip>> flowAllTrips();
@Query("SELECT * FROM trips WHERE id=:id")
Flowable<Trip> flowTripById(String id);
(from Trips/RxRoom/app/src/main/java/com/commonsware/android/room/TripStore.java)
We can then use subscribeOn(), observeOn(), subscribe(), and standard RxJava
operators to get the results… whatever those results are.
What Happens… Normally?
If our query has results — which includes an empty List for flowAllTrips() — we
will get those results via subscribe() or other mechanisms… such as
blockingFirst() on the List response:
assertEquals(0, store.flowAllTrips().blockingFirst().size());
latch=new
new CountDownLatch(1);
store.flowTripById(TEST_ID).subscribe(new
new Consumer<Trip>() {
RXJAVA AND ROOM
162

@Override
public
public void accept(Trip trip) throws
throws Exception {
foundTrip=trip;
latch.countDown();
}
});
(from Trips/RxRoom/app/src/androidTest/java/com/commonsware/android/room/FlowableTests.java)
However, the nature of the event stream varies depending on the return type. If the
return type is a List of entities (or other POJOs), we will get one result, and that is
it. If, instead, the return type is the entity/POJO itself, we get one event per returned
row. So, you design your queries around the unit of usable response:
• If you can only really use the results when you get the full roster, use a List
• If you want to process one table row at a time, or you expect only one result,
or you want to progressively show results as they get processed, use the
entity or POJO as the result
For the List scenario, once you get your result, the Flowable is considered to be
completed, and you will receive no further events.
What Happens… When No Results?
If you request a List, and there are no results, you will get an empty List back, and
you are done. As with the single-List scenario, the Flowable is considered to be
completed, and you will receive no further events.
If, on the other hand, you request the entity/POJO directly, and there are no results,
nothing happens. However, your subscription is still valid and alive, at least until you
dispose of it.
What Happens… When the Data is Updated?
If you request a List, and sometime later you update the database via Room (e.g.,
insert a row that would match the criteria for the query)… nothing happens. You do
not get a new result delivered to you automatically, because the Flowable was
completed previously.
However, if you request the entity/POJO directly, so long as your subscription is still
outstanding, you will get inserted and updated objects delivered to you via that
RXJAVA AND ROOM
163

subscription. In essence, you find out about data changes of relevance, so long as
you are willing to deal with one item at a time.
For example, here is the full test method from which the previous code listing was
extracted:
@Test
public
public void basics() throws
throws InterruptedException {
assertEquals(0, store.flowAllTrips().blockingFirst().size());
latch=new
new CountDownLatch(1);
store.flowTripById(TEST_ID).subscribe(new
new Consumer<Trip>() {
@Override
public
public void accept(Trip trip) throws
throws Exception {
foundTrip=trip;
latch.countDown();
}
});
assertFalse("Should have timed out!", latch.await(100, TimeUnit.MILLISECONDS));
final
final Trip first=new
new Trip(TEST_ID, "Foo", 2880, Priority.LOW, new
new Date());
assertNotNull(first.id);
assertNotEquals(0, first.id.length());
store.insert(first);
assertTrue("Should not have timed out!", latch.await(1, TimeUnit.SECONDS));
assertNotNull(foundTrip);
assertTrue(areIdentical(first, foundTrip));
assertEquals(1, store.flowAllTrips().blockingFirst().size());
latch=new
new CountDownLatch(1);
foundTrip=null
null;
final
final Trip updated=
new
new Trip(first.id, "Foo!!!", 1440, Priority.MEDIUM, first.startTime,
first.creationTime, first.updateTime);
store.update(updated);
assertTrue("Should not have timed out!", latch.await(1, TimeUnit.SECONDS));
assertNotNull(foundTrip);
assertTrue(areIdentical(updated, foundTrip));
assertEquals(1, store.flowAllTrips().blockingFirst().size());
latch=new
new CountDownLatch(1);
foundTrip=null
null;
store.delete(updated);
assertFalse("Should have timed out!", latch.await(100, TimeUnit.MILLISECONDS));
assertEquals(0, store.flowAllTrips().blockingFirst().size());
}
(from Trips/RxRoom/app/src/androidTest/java/com/commonsware/android/room/FlowableTests.java)
We subscribe to flowTripById(), looking for a Trip with a particular ID value.
Initially, our database is empty, and so there are no results. Our Consumer does not
RXJAVA AND ROOM
164

get anything initially, and so our CountDownLatch (latch) is not cleared. But, once
we insert() a Trip with that ID, now our Consumer is invoked, and we clear the
latch and note the Trip that we received (foundTrip). Similarly, when we update()
the Trip with the ID of interest, our Consumer gets invoked again.
However, we do not get a call when something is deleted that matched the query, as
there are no good semantics for doing that. As a result, this feature has somewhat
limited utility — you will still need to call flowTripById() again when you might
have deleted a relevant entity.
Single
A Flowable models a stream of events, though how Room handles the “stream”
depends on whether you are returning a List type or an entity/POJO type.
In contrast, a Single models a one-time event. To an extent, it is the RxJava
analogue to a one-time callback. This makes it a more natural RxJava type to use
than Flowable for List results, since there is no question that you will only get the
one event.
Hence, we can use Single instead of Flowable in our DAO:
@Query("SELECT * FROM trips ORDER BY title")
Single<List<Trip>> singleAllTrips();
@Query("SELECT * FROM trips WHERE id=:id")
Single<Trip> singleTripById(String id);
(from Trips/RxRoom/app/src/main/java/com/commonsware/android/room/TripStore.java)
What Happens… Normally?
If there is a result, including a zero-element List, we get that via our Consumer… or,
in the case of testing code, perhaps via blockingGet(), which will block until that
result is available:
assertEquals(0, store.singleAllTrips().blockingGet().size());
(from Trips/RxRoom/app/src/androidTest/java/com/commonsware/android/room/SingleTests.java)
RXJAVA AND ROOM
165

What Happens… When No Results?
However, for a @Query returning a Single of an entity/POJO, if there is nothing in
the database that matches the query criteria, an EmptyResultSetException is
thrown:
@Test(expected=EmptyResultSetException.class)
public
public void emptyResults() {
assertNull(store.singleTripById("this does not exist").blockingGet());
}
(from Trips/RxRoom/app/src/androidTest/java/com/commonsware/android/room/SingleTests.java)
This is a RuntimeException, so it is easy to forget to wrap this in a try/catch block,
and therefore it is somewhat risky to use.
What Happens… When the Data is Updated?
A Single represents a one-time event, so whatever result you get, you get, and you
will not get further updates automatically as the data is changed. In this respect, a
Single always behaves the way a Flowable for a List response behaves.
Maybe
Single and Maybe are closely related, and not merely as possible relationship status
values on a social network.
Both model a single-value response. They behave identically when there is data
available for use. Their difference is in the no-results case:
•
Single fails with an exception
•
Maybe delivers a null result
Swapping Maybe for Single is easy:
@Query("SELECT * FROM trips ORDER BY title")
Maybe<List<Trip>> maybeAllTrips();
@Query("SELECT * FROM trips WHERE id=:id")
Maybe<Trip> maybeTripById(String id);
(from Trips/RxRoom/app/src/main/java/com/commonsware/android/room/TripStore.java)
RXJAVA AND ROOM
166

But now we do not need to worry about an exception in a no-result scenario. We just
get and use null:
assertEquals(0, store.maybeAllTrips().blockingGet().size());
assertNull(store.maybeTripById("this does not exist").blockingGet());
(from Trips/RxRoom/app/src/androidTest/java/com/commonsware/android/room/MaybeTests.java)
What Should I Use?
Single is the least likely choice, given the “hidden” chance of an
EmptyResultSetException. Flowable for a List offers little value over a Single or
Maybe for the List. So, the most likely options are:
• For single-event responses, including a one-time List, use Maybe
• For cases where you want to get the streaming changes for inserts and
updates (but not deletions), use Flowable for an entity/POJO result
Applying This to Your UI
Given that our TripStore offers maybeAllTrips(), we can jettison the AsyncTask
and switch to RxJava in TripsFragment:
private
private Disposable sub;
@Override
public
public void onCreate(Bundle savedInstanceState) {
super
super.onCreate(savedInstanceState);
setRetainInstance(true
true);
TripStore store=TripDatabase.get(getActivity()).tripStore();
trips=store.maybeAllTrips()
.subscribeOn(Schedulers.io())
.cache()
.observeOn(AndroidSchedulers.mainThread());
}
@Override
public
public void onViewCreated(View view, Bundle savedInstanceState) {
super
super.onViewCreated(view, savedInstanceState);
setLayoutManager(new
new LinearLayoutManager(getActivity()));
RXJAVA AND ROOM
167

getRecyclerView()
.addItemDecoration(new
new DividerItemDecoration(getActivity(),
LinearLayoutManager.VERTICAL));
unsub();
sub=trips.subscribe(this
this::setAdapter);
}
(from Trips/RxRoom/app/src/main/java/com/commonsware/android/room/TripsFragment.java)
When we create the fragment, we set up the Maybe to return the entire List of trips.
We specifically schedule the work to occur on the RxJava io() thread, since Room
does not document what its threading model is. Plus we cache() the result (for
configuration changes) and arrange to observe on the main application thread.
Once we have our UI, we subscribe() to the Maybe to get the result, using it to
update our TripsAdapter. On a configuration change (when onViewCreated() is
called a second time) or when the fragment is finally destroyed, we dispose() of our
subscription, if for some reason it is still outstanding. Most likely, we will have
gotten our results long before, and so it will already be disposed.
RXJAVA AND ROOM
168

RxJava and Lifecycles
RxJava is cool, albeit confusing. But beyond that, it is a pure Java library. RxJava
knows nothing about Android-specific concepts, as it is designed to be used on all
sorts of Java projects.
Android developers using RxJava invariably also add RxAndroid, which gives us
access to a Scheduler that knows about the Android main application thread.
However, RxAndroid does not have anything that deals with activity or fragment
lifecycles, leaving that up to you. With Android lifecycles, we want to create things
as activities and fragments start up and clean up those things as the activities and
fragments go away. In the case of RxJava, if we subscribe to some Observable, it
would be nice to get rid of that subscription at an appropriate point.
In this chapter, we will explore a few options — including one from the Architecture
Components — for dealing with lifecycles with RxJava.
The Classic Approach
The default way of handling this is the approach used in the chapter on RxJava and
Room:
• Hold onto the Disposable that you get back from subscribing to an
observable
• Clean up that Disposable in a suitable lifecycle method, such as
onDestroy(), via a call to dispose()
If you have several subscriptions to track, CompositeDisposable lets you track all of
them in one spot. CompositeDisposable has add() and addAll() methods to add
subscriptions to it. And, as the name suggests, CompositeDisposable implements
169

the composite pattern, and so CompositeDisposable itself is a Disposable. Calling
dispose() on the CompositeDisposable triggers calls to dispose() on all of the
Disposable objects you added to the composite.
This works, but it does require you to remember to clean these things up, and it is
easy to forget.
Bridging RxJava and LiveData
Of course, the Architecture Components have Lifecycle, LifecycleOwner, and
related classes for performing operations when certain lifecycle events occur.
LiveData — the Architecture Components’ counterpart to RxJava — is intrinsically
lifecycle-aware.
So, another option would be to have some sort of adapter that converts RxJava into
LiveData. We could then observe the LiveData, knowing that our Observer would
be cleaned up automatically as part of normal lifecycle management.
Fortunately, the Architecture Components has LiveDataReactiveStreams, for
converting LiveData to and from RxJava structures, as is illustrated in the Trips/
RxLifecycle sample project.
LiveDataReactiveStreams is in yet another artifact,
android.arch.lifecycle:reactivestreams. So, you need to request that artifact
with the others that you are using:
dependencies {
implementation "com.android.support:recyclerview-v7:27.0.2"
implementation "com.android.support:support-core-utils:27.0.2"
implementation "com.android.support:support-fragment:27.0.2"
implementation 'io.reactivex.rxjava2:rxjava:2.1.7'
implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'
implementation 'android.arch.lifecycle:runtime:1.1.0'
implementation 'android.arch.lifecycle:livedata:1.1.0'
implementation 'android.arch.lifecycle:reactivestreams:1.1.0'
implementation "android.arch.persistence.room:runtime:1.0.0"
implementation "android.arch.persistence.room:rxjava2:1.0.0"
annotationProcessor "android.arch.persistence.room:compiler:1.0.0"
androidTestImplementation "com.android.support:support-annotations:27.0.2"
androidTestImplementation 'com.android.support.test:rules:1.0.1'
androidTestImplementation 'android.arch.core:core-testing:1.1.0'
androidTestImplementation "com.android.support:support-core-utils:27.0.2"
androidTestImplementation "com.android.support:support-compat:27.0.2"
RXJAVA AND LIFECYCLES
170

androidTestImplementation 'android.arch.lifecycle:runtime:1.1.0'
androidTestImplementation 'android.arch.lifecycle:common:1.1.0'
}
(from Trips/RxLifecycle/app/build.gradle)
To bridge from RxJava to LiveData, LiveDataReactiveStreams offers a
fromPublisher() method. Here, “publisher” refers to Publisher from the Reactive
Streams initiative. Most RxJava Observable types do not implement the Publisher
interface, but Flowable does. And most RxJava Observable types can be converted to
a Flowable via the toFlowable() method.
As a result, the recipe for using LiveDataReactiveStreams is:
• Create your RxJava Observable as normal
• Call toFlowable() on it to convert it into a Flowable
• Pass that Flowable to fromPublisher() to get a LiveData
• Observe that LiveData and consume the results, such as with a method
reference
@Override
public
public void onViewCreated(View view, Bundle savedInstanceState) {
super
super.onViewCreated(view, savedInstanceState);
setLayoutManager(new
new LinearLayoutManager(getActivity()));
getRecyclerView()
.addItemDecoration(new
new DividerItemDecoration(getActivity(),
LinearLayoutManager.VERTICAL));
TripStore store=TripDatabase.get(getActivity()).tripStore();
Flowable<List<Trip>> trips=store.maybeAllTrips()
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.toFlowable();
LiveDataReactiveStreams.fromPublisher(trips)
.observe(this
this, this
this::setAdapter);
}
(from Trips/RxLifecycle/app/src/main/java/com/commonsware/android/room/TripsFragment.java)
Here, we do this work inside of TripsFragment, which is a LifecycleOwner courtesy
of the support-fragment implementation of Fragment. We do not have to worry
RXJAVA AND LIFECYCLES
171

about cleaning up the LiveData ourselves; the lifecycle system will handle this for
us.
If, for some reason, you need to convert a LiveData to something in the RxJava
space, toPublisher() on LiveDataReactiveStreams can adapt a LiveData to a
Publisher. On its own, Publisher only offers a subscribe() method. However,
Observable.fromPublisher() can adapt a Publisher into an Observable, and from
there you can set up RxJava chains as needed.
The Uber Solution: AutoDispose
The downside of LiveDataReactiveStreams, to some, is that you wind up with a
LiveData object. Some developers will prefer to stick with RxJava throughout, but
still would like some measure of automatic lifecycle-based subscription cleanup.
For that, Uber offers AutoDispose.
It allows you to add lifecycle-based subscription cleanup with a single line added to
your RxJava chain, akin to:
observable
// subscribeOn(), observeOn(), map(), and so on go here
.to(AutoDispose.with(scope).forObservable())
.subscribe(/* good stuff here */);
Here, scope will be an object that provides lifecycle details to AutoDispose, so that it
knows when to stop forwarding events on to your Consumer or other subscriber.
There are two Android-specific classes for this:
•
AndroidLifecycleScopeProvider, which uses Lifecycle and
LifecycleOwner
•
ViewScopeProvider, which (somehow) uses View
If you are comfortable with consuming events in your UI using LiveData,
LiveDataReactiveStreams is likely to be the simpler choice. If, however, you are
interested in avoiding the conversion to LiveData, AutoDispose is worth
considering.
RXJAVA AND LIFECYCLES
172

The Semi-Deprecated Solution: RxLifecycle
Android developers who got involved early in RxJava ran to Trello’s RxLifecycle
library as a solution for this sort of problem. RxLifecycle has been updated to RxJava
2, and it even has support for leveraging the Lifecycle-related classes from the
Architecture Components.
However, Dan Lew, in an August 2017 blog post, pointed out a variety of issues with
RxLifecycle, stemming in part from its need to support RxJava 1 subscription
semantics. Dan is now steering new projects away from RxLifecycle and towards
other solutions, such as those mentioned above.
RXJAVA AND LIFECYCLES
173


ViewModels and Data Binding
In 2015, Google introduced the data binding framework to Android app
development.
In 2017, Google introduced LiveData and its take on the ViewModel construct.
These can work well together, if you take care, and if you think through some of the
ramifications, particularly if your UI allows the user to modify the data.
Binding From LiveData
The idea with the Architecture Components is that the ViewModel holds references
to LiveData, where your data is coming from somewhere deeper in your app’s
architecture… or possibly just from some system component, such as
SensorManager. Your activities and fragments using that ViewModel can then observe
the data and apply it to the user interface.
Applying the LiveData-emitted output to the UI using data binding is not
significantly different, on its own, than binding anything else.
However, what the LiveData emits may not be directly what you want to bind. While
data binding’s expression language and import capability means that you can do
some fairly fancy data formatting directly in a layout resource, that becomes difficult
to debug. All else being equal, it is better to put complex data conversions in
ordinary program logic, and use data binding mostly to attach the data to the views.
This is particularly true if you want to use two-way data binding, which requires
only simple getter and setter access.
175

So, while the LiveData might emit objects of type X, you might want to convert
those into type Y, where the values on Y are in line with what data binding needs.
For this, Transformations.map() is a solution, as we saw in the chapter on LiveData
transformations.
To see all of this connected together, let’s turn to the General/BindSensor sample
project. This is a clone of the LiveSensor sample project from the chapter on
LiveData, updated to use a ViewModel and data binding.
The ViewModel
The original LiveSensor sample used onRetainNonConfigurationInstance() for
managing its LiveData. Here, we use an AndroidViewModel subclass named
SensorViewModel, one that sets up and references the SensorLiveData instance:
package
package com.commonsware.android.livedata;
import
import android.app.Application
android.app.Application;
import
import android.arch.lifecycle.AndroidViewModel
android.arch.lifecycle.AndroidViewModel;
import
import android.hardware.Sensor
android.hardware.Sensor;
import
import android.hardware.SensorManager
android.hardware.SensorManager;
public
public class
class SensorViewModel
SensorViewModel extends
extends AndroidViewModel {
private
private final
final SensorLiveData sensorLiveData;
public
public SensorViewModel(Application app) {
super
super(app);
sensorLiveData=new
new SensorLiveData(app, Sensor.TYPE_LIGHT,
SensorManager.SENSOR_DELAY_UI);
}
SensorLiveData getSensorLiveData() {
return
return(sensorLiveData);
}
}
(from General/BindSensor/app/src/main/java/com/commonsware/android/livedata/SensorViewModel.java)
We use AndroidViewModel because we need a Context for setting up the
SensorLiveData, and ViewModel itself does not provide us with one.
VIEWMODELS AND DATA BINDING
176

The RowModel
The objects emitted by the SensorLiveData are instances of SensorLiveData.Event:
static
static class
class Event
Event {
final
final Date date=new
new Date();
final
final float[] values;
Event(SensorEvent event) {
values=new
new float[event.values.length];
System.arraycopy(event.values, 0, values, 0, event.values.length);
}
}
(from General/BindSensor/app/src/main/java/com/commonsware/android/livedata/SensorLiveData.java)
However, this data is ill-suited to bind directly into our UI:
• The layout should not need to know that we want the 0th element out of the
values array, given that we are asking for the ambient light sensor
• The layout really should not be trying to format a Date
To that end, we define a RowModel, which is a view-model for use in an individual
row in our RecyclerView:
public
public static
static class
class RowModel
RowModel {
private
private static
static final
final DateFormat fmt=
new
new SimpleDateFormat("HH:mm:ss", Locale.US);
public
public final
final String date;
public
public final
final float value;
RowModel(SensorLiveData.Event event) {
date=fmt.format(event.date);
value=event.values[0];
}
}
(from General/BindSensor/app/src/main/java/com/commonsware/android/livedata/MainActivity.java)
Here is where we do the conversion of the Date to a suitably-formatted String and
extract the sensor value that we need.
VIEWMODELS AND DATA BINDING
177

The Layout
The original sample just used android.R.layout.simple_list_item_1 for the rows.
Now we need a custom layout, one with data binding expressions:
<?xml version="1.0" encoding="utf-8"?>
<layout
<layout xmlns:android="http://schemas.android.com/apk/res/android">>
<data>
<data>
<variable
<variable
name="model"
type="com.commonsware.android.livedata.MainActivity.RowModel" />
/>
</data>
</data>
<TextView
<TextView
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:gravity="center_vertical"
android:minHeight="?android:attr/listPreferredItemHeightSmall"
android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
android:paddingStart="?android:attr/listPreferredItemPaddingStart"
android:text='@{model.date+" "+model.value}'
android:textAppearance="?android:attr/textAppearanceListItemSmall" />
/>
</layout>
</layout>
(from General/BindSensor/app/src/main/res/layout/row.xml)
Here, we bind in an instance of RowModel and use its fields (and some
concatenation) to populate a TextView, where the TextView otherwise is configured
the same as is the one from android.R.layout.simple_list_item_1.
The Adapter and ViewHolder
We can now use data binding in our EventLogAdapter and its associated RowHolder:
private
private class
class EventLogAdapter
EventLogAdapter extends
extends RecyclerView.Adapter<RowHolder> {
private
private final
final ArrayList<RowModel> models=new
new ArrayList<>();
@Override
public
public RowHolder onCreateViewHolder(ViewGroup parent, int viewType) {
return
return(new
new RowHolder(RowBinding.inflate(getLayoutInflater(), parent, false
false)));
}
@Override
public
public void onBindViewHolder(RowHolder holder, int position) {
holder.setModel(models.get(position));
}
VIEWMODELS AND DATA BINDING
178

@Override
public
public int getItemCount() {
return
return(models.size());
}
void add(RowModel model) {
models.add(model);
notifyItemInserted(getItemCount());
}
}
static
static class
class RowHolder
RowHolder extends
extends RecyclerView.ViewHolder {
final
final RowBinding binding;
RowHolder(RowBinding binding) {
super
super(binding.getRoot());
this
this.binding=binding;
}
void setModel(RowModel model) {
binding.setModel(model);
}
}
(from General/BindSensor/app/src/main/java/com/commonsware/android/livedata/MainActivity.java)
Here we:
• Use RowBinding (generated from our row.xml file) for setting up the widgets
• Wrap that RowBinding in an otherwise-pointless RecyclerView.ViewHolder,
just to make the compiler happy
• Use setModel() on RowBinding to attach a RowModel and populate the
widgets from it
The Transformation
However, we have a gap: our SensorLiveData is emitting SensorLiveData.Event
objects, but our UI is consuming RowModel objects. The glue is a map()
transformation, applied as part of observing the SensorLiveData, set up in
onCreate() of the activity:
@Override
public
public void onCreate(Bundle savedInstanceState) {
super
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
RecyclerView rv=findViewById(R.id.transcript);
SensorViewModel viewModel=ViewModelProviders.of(this
this).get(SensorViewModel.class);
adapter=new
new EventLogAdapter();
VIEWMODELS AND DATA BINDING
179

rv.setAdapter(adapter);
Transformations
.map(viewModel.getSensorLiveData(), RowModel::new
new)
.observe(this
this, rowModel -> adapter.add(rowModel));
}
(from General/BindSensor/app/src/main/java/com/commonsware/android/livedata/MainActivity.java)
Since RowModel has a constructor that takes a SensorLiveData.Event, we can use the
RowModel::new method reference to map() a SensorLiveData.Event to a RowModel.
We then observe() the map() output, so we have a lambda observing RowModel
objects. The lambda adds each RowModel to our RecyclerView.Adapter, and we are
set.
Note that a more serious app of this nature should cap the number of rows in the
RecyclerView.Adapter, lest we run out of memory by getting too many ambient
light sensor readings.
The Saved Instance State Situation
Using LiveData and ViewModel exacerbates a problem with how the data binding
framework interacts with the saved instance state Bundle.
In addition to data that you might put in that Bundle, the built-in
onSavedInstanceState() logic saves obvious user-mutable state of widgets in the UI
to the Bundle. So, for example, if the user types something into an EditText, or
toggles the state of a Switch, that information goes in the Bundle. If you have
matching widgets in the new configuration, the state is applied to those widgets
automatically.
Except if you are using the data binding framework, in which case, things get
complicated.
The General/DataBindingState sample project illustrates the problem and the
workaround.
This app has a trivial UI, consisting mostly of an EditText. It uses the data binding
framework, so the main.xml layout resource has a <layout> element and so forth:
<?xml version="1.0" encoding="utf-8"?>
<layout
<layout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:app="http://schemas.android.com/apk/res-auto">>
<data>
<data>
VIEWMODELS AND DATA BINDING
180

<variable
<variable
name="model"
type="com.commonsware.databindingstate.Model" />
/>
</data>
</data>
<android.support.constraint.ConstraintLayout
<android.support.constraint.ConstraintLayout xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
tools:context="com.commonsware.databindingstate.MainActivity">>
<EditText
<EditText android:id="@+id/title"
android:layout_width="0dp"
android:layout_height="wrap_content"
android:inputType="text"
android:text="@{model.title}"
app:layout_constraintLeft_toLeftOf="parent"
app:layout_constraintRight_toRightOf="parent"
app:layout_constraintTop_toTopOf="parent" />
/>
</android.support.constraint.ConstraintLayout>
</android.support.constraint.ConstraintLayout>
</layout>
</layout>
(from General/DataBindingState/app/src/main/res/layout/main.xml)
Of note, the android:text attribute of the EditText has a binding expression,
pulling the title from a Model object. Model is as trivial of a model as you can
imagine:
package
package com.commonsware.databindingstate;
public
public class
class Model
Model {
public
public String getTitle() {
return
return("Title");
}
}
(from General/DataBindingState/app/src/main/java/com/commonsware/databindingstate/Model.java)
However, we do not actually wind up using that Model. In fact, we never bind
anything to the layout.
One might reasonably expect that this would result in the same flow as if we did not
use data binding at all:
• The UI shows our layout
• The user types something into the EditText
• The user rotates the screen, and the saved instance state Bundle populates
the newly-created replacement EditText for the new configuration
VIEWMODELS AND DATA BINDING
181

Instead, if you try it, you will find that what you type in gets lost on a configuration
change.
However, you will notice that there is an action bar overflow menu, with an “Apply
Workaround” checkable item in it. If you check that, what you type into the
EditText is properly retained across the configuration change.
The difference is a call to executePendingBindings() in onCreateView() of the
FormFragment that is showing our limited UI:
@Nullable
@Override
public
public View onCreateView(LayoutInflater inflater,
@Nullable ViewGroup container,
@Nullable Bundle savedInstanceState) {
if
if (savedInstanceState!=null
null) {
savedWorkaround=savedInstanceState.getBoolean(STATE_WORKAROUND);
if
if (workaround!=null
null) {
workaround.setChecked(savedWorkaround);
}
}
MainBinding binding=MainBinding.inflate(inflater, container, false
false);
if
if (savedWorkaround) {
binding.executePendingBindings();
}
return
return(binding.getRoot());
}
(from General/DataBindingState/app/src/main/java/com/commonsware/databindingstate/FormFragment.java)
Our layout is main.xml, so our binding class is MainBinding. We call the static
inflate() method on it to inflate our layout, and use getRoot() to return the View
from onCreateView().
If, however, our checkable MenuItem is checked (or, rather, was checked in the
previous configuration), we call executePendingBindings(). Otherwise, we do not.
That makes the difference.
(the author would like to thank Stack Overflow user Cheticamp for pointing out the
workaround)
VIEWMODELS AND DATA BINDING
182

This sample is very artificial. Using data binding without binding any data would
seem atypical. However, it does illustrate a general problem with data binding that
using reactive UIs — LiveData, ViewModel, etc. — exacerbate. Simply put, when do
we bind, to get the correct results?
Let’s examine two common cases: the user is editing an existing model object, or the
user is creating a new model object.
Existing Model
We inflate our layout using our binding object, plus we observe a LiveData to get
the model object when it is ready. Once it is ready, we call the appropriate setter on
the binding to populate the widgets.
Right?
Unfortunately, not always.
That is what we do at the outset, the first time our activity or fragment is displayed
to edit this particular model. However, if we undergo a configuration change, we
have a problem: we do not want to lose changes that the user made already. If the
user started typing something into an EditText, then rotated the screen (e.g., to
switch to the landscape keyboard for easier typing), we do not want to lose the
changes already made in that EditText.
Ordinarily, the saved instance state Bundle would handle that… but if we turn
around and call our binding setter in the new activity or fragment, we will replace
what the user typed in with whatever is in the model object.
There are two main solutions here:
1. Use two-way binding, so the UI immediately updates the model object as the
user makes changes to it. If the ViewModel holds onto that model object and
can give it back to us after the configuration change, we can safely call the
setter method on the binding object, as our model has the appropriate data.
2. Only bind the model object on the initial creation of the activity or
fragment, not on configuration changes. Instead, let the normal saved
instance state logic handle the form contents. This requires you to call
executePendingBindings() shortly after inflating the layout via the binding
class, so that the saved instance state is applied properly.
VIEWMODELS AND DATA BINDING
183

New Model
In the new-model scenario, you have the additional question of: is there anything to
bind, anyway?
If you are using two-way data binding, then you need to bind something to collect
the input from the user. Similarly, if you are using a newly created model object to
supply starter data to the form, you will need to create such a model object and bind
it. In these cases, the new-model scenario is largely the same as the existing-model
scenario, with the primary difference being where the model comes from.
If you have no need for a model at the outset, though, you could skip binding
anything, much as the sample app skipped binding anything. Then, so long as you
call executePendingBindings() shortly after inflating the layout via the binding
class, you should be in fine shape.
VIEWMODELS AND DATA BINDING
184

Packing Up a Room
A popular question over the years has been: how do I ship a pre-populated database
with my app?
Android has never offered an “out of the box” solution for this, though there are
third-party solutions that we can use. Room changes the problem space slightly,
breaking the original solutions and requiring a fresh option. In this chapter, we will
review that new solution and how you can use it to ship a database, packaged in
your app, and used by Room.
The Problem
Roughly speaking, data for a SQLite database can come from one of three places:
• It can come from user input, through the UI of your app
• It can come from external sources, such as data that you synchronize with a
Web service
• It can come with the app itself, when the app was installed
Most apps get by with the first two data sources. However, from time to time, there
situations where shipping a database with an app can prove useful.
Sometimes, that database represents starter data, that the user (or a server) will
augment or modify over time. For example, you might be writing an app for
documenting household goods and other items, to help a homeowner or renter with
future insurance claims in case of a fire, natural disaster, etc. The app allows the user
to take photos of items, provide notes about them (make, model, etc.), and
categorize them. While the user can manage the list of categories, you might want to
185

ship some pre-defined categories with the app, so that the user is not forced into
deciding on categories before the app can be used.
Sometimes, the packaged database is a read-only data repository. Frequently, this is
for apps that want to offer offline access to a dataset that otherwise might be pulled
from a Web service. Sometimes, the data simply is not meant to change frequently.
For example, the APK edition of The Busy Coder’s Guide to Android Development
ships with a packaged database containing the prose of the book, indexed by
SQLite’s FTS3 engine for use with full-text searching. The database contents are
updated when the app is updated, reflecting a new version of the book.
For tiny datasets, you can get away with populating the database yourself when you
first create it, using ordinary Java code. This is inefficient for larger databases,
though, as it forces us to execute a bunch of SQLite transactions on the user’s
device. It would be more efficient to ship an actual SQLite database file. And, since
the developers of SQLite have done an admirable job of backwards and forwards
compatibility with their database file structure, this works fairly well. You use other
tools, such as DB Browser for SQLite, to create the database with your data. Then,
you… do… something… to put that database in the APK and use it at runtime.
The Classic Solution: SQLiteAssetHelper
The recommended “something” for traditional SQLite work in Android has been Jeff
Gilfelt’s SQLiteAssetHelper. Basic use of SQLiteAssetHelper is fairly simple:
• Create an assets/databases/ directory in your main sourceset of your app
module
• Put your pre-populated database in that directory, with the same filename
that you want to use at runtime
• Instead of using SQLiteOpenHelper, subclass SQLiteAssetHelper instead,
supplying that filename:
public
public class
class YourDatabase
YourDatabase extends
extends SQLiteAssetHelper {
private
private static
static final
final String DB_NAME="whatever.db";
private
private static
static final
final int SCHEMA_VERSION=1;
public
public YourDatabase(Context context) {
super
super(context, DB_NAME, null
null, SCHEMA_VERSION);
}
}
PACKING UP A ROOM
186

The rest of your code can use your SQLiteAssetHelper subclass just as it would
SQLiteOpenHelper, such as calling getReadableDatabase() or
getWritableDatabase(). The first time one of those methods is called,
SQLiteAssetHelper will notice that there is no database and will copy the database
from assets into the proper location.
The New Problem
Room, however, does not use SQLiteOpenHelper… at least, not directly. There is no
obvious place that you can use to put SQLiteAssetHelper.
There are two potential hooks, though.
One is with addCallback() on RoomDatabase.Builder. This allows you to register a
RoomDatabase.Callback instance with the RoomDatabase. That callback will be
called with onCreate() when the database is created for the first time. If you wanted
to execute some SQL statements to populate the database, you could use this
approach. However, Room stores its own metadata in the database in a private table.
We have no great way of putting that metadata inside our pre-populated database,
and by the time onCreate() is called, it is too late for us to try to swap in that pre-
populated database.
The other hook is with openHelperFactory() on RoomDatabase.Builder. This is the
entry point to replacing the standard SQLite access code with our own code. As it
turns out, a slightly-modified version of SQLiteAssetHelper can be used in this
fashion.
Merging SQLiteAssetHelper with Room
The General/AssetRoom sample project demonstrates that latter approach, in the
form of AssetSQLiteOpenHelper and AssetSQLiteOpenHelperFactory classes. In a
future update to the book, we will explore how those classes are implemented.
Using them, though, is fairly easy.
As with the original SQLiteAssetHelper, you need to put your pre-populated
database in assets/databases/, under whatever name you want to use for that
database:
PACKING UP A ROOM
187

Figure 1: AssetRoom Project, Showing assets/databases/constants.db
Then, when creating your RoomDatabase subclass:
• Use that same database name, and
• Use openHelperFactory(new AssetSQLiteOpenHelperFactory()) when
creating the instance of your RoomDatabase via RoomDatabase.Builder
package
package com.commonsware.android.room;
import
import android.arch.persistence.db.framework.AssetSQLiteOpenHelperFactory
android.arch.persistence.db.framework.AssetSQLiteOpenHelperFactory;
import
import android.arch.persistence.room.Dao
android.arch.persistence.room.Dao;
import
import android.arch.persistence.room.Database
android.arch.persistence.room.Database;
import
import android.arch.persistence.room.Insert
android.arch.persistence.room.Insert;
import
import android.arch.persistence.room.Query
android.arch.persistence.room.Query;
import
import android.arch.persistence.room.Room
android.arch.persistence.room.Room;
import
import android.arch.persistence.room.RoomDatabase
android.arch.persistence.room.RoomDatabase;
import
import android.content.Context
android.content.Context;
import
import java.util.List
java.util.List;
@Database(entities={Constant.class}, version=1)
abstract
abstract class
class ConstantsDatabase
ConstantsDatabase extends
extends RoomDatabase {
public
public abstract
abstract Constant.Store constantsStore();
static
static final
final String DB_NAME="constants.db";
private
private static
static volatile
volatile ConstantsDatabase INSTANCE=null
null;
synchronized
synchronized static
static ConstantsDatabase get(Context ctxt) {
if
if (INSTANCE==null
null) {
INSTANCE=create(ctxt);
}
return
return(INSTANCE);
}
static
static ConstantsDatabase create(Context ctxt) {
RoomDatabase.Builder<ConstantsDatabase> b=
Room.databaseBuilder(ctxt.getApplicationContext(), ConstantsDatabase.class,
DB_NAME);
PACKING UP A ROOM
188

return
return(b.openHelperFactory(new
new AssetSQLiteOpenHelperFactory()).build());
}
}
(from General/AssetRoom/app/src/main/java/com/commonsware/android/room/ConstantsDatabase.java)
Compared with some of the other Room samples, you will notice that
ConstantsDatabase lacks any option to create an in-memory database. There is a
good reason for that: SQLiteAssetHelper cannot support that, as we have no way of
copying the database file into some place where SQLite itself will use it in memory.
This makes testing slightly more aggravating, as you will want to make sure that you
delete your database file in an @After method, as otherwise future runs of your tests
will encounter the existing database file:
package
package com.commonsware.android.room;
import
import android.support.test.InstrumentationRegistry
android.support.test.InstrumentationRegistry;
import
import android.support.test.runner.AndroidJUnit4
android.support.test.runner.AndroidJUnit4;
import
import org.junit.After
org.junit.After;
import
import org.junit.Before
org.junit.Before;
import
import org.junit.Test
org.junit.Test;
import
import org.junit.runner.RunWith
org.junit.runner.RunWith;
import
import static
static org.junit.Assert.assertEquals;
import
import static
static org.junit.Assert.assertTrue;
@RunWith(AndroidJUnit4.class)
public
public class
class AssetTests
AssetTests {
private
private ConstantsDatabase db;
private
private Constant.Store store;
@Before
public
public void setUp() {
db=ConstantsDatabase.get(InstrumentationRegistry.getTargetContext());
store=db.constantsStore();
}
@After
public
public void tearDown() {
db.close();
assertTrue(InstrumentationRegistry
.getTargetContext()
.getDatabasePath(ConstantsDatabase.DB_NAME)
.delete());
}
@Test
PACKING UP A ROOM
189

public
public void assets() {
assertEquals(13, store.all().size());
store.insert(new
new Constant("Pi", 3.1415926));
assertEquals(14, store.all().size());
}
}
(from General/AssetRoom/app/src/androidTest/java/com/commonsware/android/room/AssetTests.java)
However, otherwise, using the pre-populated database is no different than using a
regular Room database. Whether the data can be modified is up to you, particularly
with your @Dao class — if you do not write any DAO methods that modify the data,
you should be safe. Note, though, that Room has its own metadata table, which
might be modified by Room as it sees fit.
PACKING UP A ROOM
190

Paging Room Data
September 2017 brought a new addition to the Architecture Components: the Paging
library. This library contains a series of classes designed to help you offer a
browsable UI across a large data set, particularly where that data set comes from a
Room-managed database.
In this chapter, we will explore the role of this library, some of the key classes, and
the basic setup for use with Room and RecyclerView.
The Problem: Too Much Data
One of the little-known issues with Android’s SQLite API is how the Cursor works.
We tend to just use that Cursor and ignore exactly how it is getting its data. The
behavior of our database Cursor is normal for smaller data sets but possibly
problematic for really large ones.
Cursor is an interface. The real Java class that we get back from SQLite is a
SQLiteCursor. The Cursor API, and SQLiteCursor in particular, was developed well
before Android 1.0 was released, and therefore has a fair share of “features” that
seemed like good ideas at the time but did not hold up well as the years progressed.
The one that everybody encounters is the fact that when you get a Cursor back from
methods like query() or rawQuery() on a SQLiteDatabase, the query has not
actually been done yet. Instead, it is lazy-executed when you ask the Cursor for
something where the data is needed, such as getCount(). This is a pain, as we want
to do the database I/O on a background thread, so we have to specifically do
something while on that background thread (e.g., call getCount()) to ensure that
the query really does get executed when we expect it to.
191

Another quirk with Cursor is that when the query is executed, it really populates a
CursorWindow. For small queries, this will represent the entire result set. For larger
queries, it is a portion of that result set. As we move through the Cursor,
SQLiteCursor will load more relevant rows into the CursorWindow, around the new
position. This exacerbates the threading problem, as we might wind up doing disk I/
O at any point while working with the Cursor, if the window’s contents need to be
adjusted.
Ideally, your queries are small, within the CursorWindow limits. And for apps where
the data comes from the user, usually you can keep your queries small. Users are
only going to enter in so much data on a small screen. Even if the user records some
form of multimedia — such as taking a picture with the camera – large queries can
be avoided by not storing the media in the database itself, but rather storing it in
plain files referenced by the database.
However, in cases where the data comes from some server, sticking with small
queries can get tricky.
Addressing the UX
Beyond the threading issues, there is another challenge with showing large result
sets in a single UI (e.g., in a RecyclerView): it is a pain for users to navigate. Nobody
is going to want to scroll through 10,000 rows in a vertically-scrolling list — their
finger will develop a blister first.
If you anticipate having a large amount of data, your primary concern is to get the
UX right. Focus on searching, filtering, and other means for the user to easily scope
the required data to some subset of relevance. Do not have the primary UX be a
“scroll through the world” sort of experience, even if that is an available option for
users who are gluttons for punishment or have steel-tipped fingers (or, perhaps, a
stylus).
However, even with user-supplied constraints, you still might wind up with more
data than can fit in a CursorWindow. And we have no direct control over that
CursorWindow behavior, as it is hidden behind a few layers of abstraction.
Enter the Paging Library
The Paging library exists to provide greater developer control over exactly what gets
loaded from a backing data store and when, handling things like:
PAGING ROOM DATA
192

• Performing smaller queries, to stay inside a CursorWindow’s bounds, so we
can control the threads used for data loads
• Supporting multiple traversal options through a data set: not only classic
position-based systems, but ones where you might be navigating a tree and
need to retrieve related child objects as part of traversal
• Offering reactive approaches, based on LiveData, so we can ensure that our
UI remains responsive.
There are a number of classes involved in the Paging library, but for basic scenarios,
there are a few of significance: including PagedList and PagedListAdapter.
PagedList
PagedList, on the surface, is a List, not that dissimilar from an ArrayList.
However, it is designed to handle very large collections using a time-honored
technique: lying.
A PagedList may know how much data there can be — to be able to respond to
methods like size() — but it does not actually hold all of that data. Instead, it holds
onto a small amount of data and by default will return null for requests to get items
from the List that have not been loaded.
A loadAround() method tells the PagedList a position of importance.
Asynchronously, PagedList will work to load that data and be able to return
non-null values for positions “around” the requested one. This may cause the
PagedList to jettison previously-loaded data, to minimize the memory footprint
that the PagedList takes up.
The idea is that PagedList should work the way that the UI does: showing a small
amount of information at a time, but allowing for (theoretically) arbitrary navigation
through a much larger set of information.
PagedListAdapter
A PagedListAdapter is a RecyclerView.Adapter that uses a PagedList as its source
of items to render. It handles the details of calling loadAround() for you. All you
need to do is handle standard RecyclerView.Adapter methods like
onCreateViewHolder() and onBindViewHolder().
PAGING ROOM DATA
193

DataSource.Factory
A DataSource, surprisingly enough, is a source of data. It is a wrapper around some
data provider — a database, a Web service, etc. — and knows how to retrieve pages
of data from it.
A DataSource.Factory follows a time-honored Java tradition, where we have factory
classes to create instances of other things. In this case, a DataSource.Factory knows
how to create certain types of DataSource. In particular, when working with Room,
you can request that a @Query method return a DataSource.Factory as its data type,
instead of a List of entities or a LiveData or other things.
LivePagedListBuilder
LivePagedListProvider is a utility class that can create a LiveData object that
delivers PagedList objects to observers, given a DataSource.Factory. So, if you have
a Room @Query method that returns a DataSource.Factory, you can create a
LivePagedListProvider to convert that into a LiveData for use with your UI layer.
Room, DataSource.Factory, and PagedList will handle loading data
asynchronously as you navigate through the list. If you attach the PagedList to a
RecyclerView via PagedListAdapter, you get seamless data paging, with
controllable memory consumption, with very little work on your part.
Paging and Room
The CityPop/RoomPaging sample project will illustrate the use of the Paging library
in conjunction with Room.
As with the PackRoom sample shown earlier in the book, RoomPaging packages a
database with the app. Specifically, it is list of 2015 city populations, culled from a
United Nations data set. Not all cities are represented there, for unknown reasons,
but there are over 1,000, and so it offers a chance to see how the Paging classes work
in action.
The Dependency
To use those classes, we need another dependency, one for the Paging library.
Paging is on its own separate release cycle from Room or the lifecycle classes. At
the time this chapter was written, Paging is available in an alpha5 release.
PAGING ROOM DATA
194

So, we request the android.arch.paging:runtime library in our Gradle script, along
with other necessary dependencies:
dependencies {
implementation "android.arch.persistence.room:runtime:1.0.0"
annotationProcessor "android.arch.persistence.room:compiler:1.0.0"
implementation "android.arch.paging:runtime:1.0.0-alpha5"
implementation "com.android.support:support-annotations:27.0.2"
implementation "com.android.support:recyclerview-v7:27.0.2"
implementation 'com.android.support:support-fragment:27.0.2'
androidTestImplementation 'com.android.support.test:rules:1.0.1'
androidTestImplementation "com.android.support:support-annotations:27.0.2"
}
(from CityPop/RoomPaging/app/build.gradle)
The Entity, DAO, and Database
Our Room entity is a City. It has four fields:
• a unique ID in the form of a UUID (id)
• the name of the city (city)
• the name of the country or area in which the city is located (country)
• the population of the city (population)
In addition to sporting a suitable constructor for Room’s use and a toString() that
returns the city name, City also implements equals() and hashCode(), using the
id as the discriminator.
package
package com.commonsware.android.citypop;
import
import android.arch.paging.DataSource
android.arch.paging.DataSource;
import
import android.arch.persistence.room.Dao
android.arch.persistence.room.Dao;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.arch.persistence.room.Query
android.arch.persistence.room.Query;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.List
java.util.List;
@Entity(tableName = "cities")
class
class City
City {
@PrimaryKey
@NonNull
final
final String id;
final
final String country;
PAGING ROOM DATA
195

final
final String city;
final
final int population;
City(@NonNull String id, String country, String city, int population) {
this
this.id=id;
this
this.country=country;
this
this.city=city;
this
this.population=population;
}
@Override
public
public String toString() {
return
return(city);
}
@Override
public
public boolean equals(Object obj) {
if
if (obj instanceof
instanceof City) {
City other=(City)obj;
return
return(id.equals(other.id));
}
return
return(false
false);
}
@Override
public
public int hashCode() {
return
return(id.hashCode());
}
@Dao
interface
interface Store
Store {
@Query("SELECT * FROM cities ORDER BY population DESC")
List<City> allByPopulation();
@Query("SELECT * FROM cities ORDER BY population DESC")
DataSource.Factory<Integer, City> pagedByPopulation();
}
}
(from CityPop/RoomPaging/app/src/main/java/com/commonsware/android/citypop/City.java)
City also has a nested Store class that is our DAO, with two @Query methods. One
(allByPopulation()) is a traditional synchronous “give me a list of all the cities”
query. The other is pagedByPopulation(), and it returns a DataSource.Factory.
DataSource.Factory takes two data types:
PAGING ROOM DATA
196

• The page identifier type
• The type of entity (or other POJO) that you want the underlying Room
query to use
A “page identifier” is pretty much what it says: it identifies a page in a response. For
a Room query, pages are numbered, and so you will use Integer as the page
identifier type. The Paging library also supports “keyed” pages, where a page might
be identified by something other than a simple number, but Room does not offer
that at present.
Our RoomDatabase is CityDatabase, and it set up akin to the one from PackRoom,
using AssetSQLiteOpenHelperFactory to use a packaged un.db database as our
initial data:
package
package com.commonsware.android.citypop;
import
import android.arch.persistence.db.framework.AssetSQLiteOpenHelperFactory
android.arch.persistence.db.framework.AssetSQLiteOpenHelperFactory;
import
import android.arch.persistence.room.Database
android.arch.persistence.room.Database;
import
import android.arch.persistence.room.Room
android.arch.persistence.room.Room;
import
import android.arch.persistence.room.RoomDatabase
android.arch.persistence.room.RoomDatabase;
import
import android.content.Context
android.content.Context;
@Database(entities={City.class}, version=1)
abstract
abstract class
class CityDatabase
CityDatabase extends
extends RoomDatabase {
public
public abstract
abstract City.Store cityStore();
static
static final
final String DB_NAME="un.db";
private
private static
static volatile
volatile CityDatabase INSTANCE=null
null;
synchronized
synchronized static
static CityDatabase get(Context ctxt) {
if
if (INSTANCE==null
null) {
INSTANCE=create(ctxt);
}
return
return(INSTANCE);
}
static
static CityDatabase create(Context ctxt) {
RoomDatabase.Builder<CityDatabase> b=
Room.databaseBuilder(ctxt.getApplicationContext(), CityDatabase.class,
DB_NAME);
return
return(b.openHelperFactory(new
new AssetSQLiteOpenHelperFactory()).build());
}
}
PAGING ROOM DATA
197

(from CityPop/RoomPaging/app/src/main/java/com/commonsware/android/citypop/CityDatabase.java)
The ViewModel
This sample uses ViewModelsProvider, and for that, we need a ViewModel that can
get the LiveData from the LivePagedListProvider, so our UI can observe that data.
So, we have a CitiesViewModel serving that role:
package
package com.commonsware.android.citypop;
import
import android.app.Application
android.app.Application;
import
import android.arch.lifecycle.AndroidViewModel
android.arch.lifecycle.AndroidViewModel;
import
import android.arch.lifecycle.LiveData
android.arch.lifecycle.LiveData;
import
import android.arch.paging.DataSource
android.arch.paging.DataSource;
import
import android.arch.paging.LivePagedListBuilder
android.arch.paging.LivePagedListBuilder;
import
import android.arch.paging.PagedList
android.arch.paging.PagedList;
public
public class
class CitiesViewModel
CitiesViewModel extends
extends AndroidViewModel {
final
final LiveData<PagedList<City>> pagedCities;
public
public CitiesViewModel(Application app) {
super
super(app);
DataSource.Factory<Integer, City> factory=
CityDatabase.get(app).cityStore().pagedByPopulation();
LivePagedListBuilder<Integer, City> pagedListBuilder=
new
new LivePagedListBuilder<>(factory, 50);
pagedCities=pagedListBuilder.build();
}
}
(from CityPop/RoomPaging/app/src/main/java/com/commonsware/android/citypop/CitiesViewModel.java)
We first get our DataSource.Factory by asking the CityDatabase singleton for the
cityStore(), and then ask it to get the cities pagedByPopulation().
We then create a LivePagedListBuilder, supplying its constructor with the
DataSource.Factory and how big of a page that we want (in this case, 50).
Specifying the page size helps us manage how much heap space gets used by the
PagedList. The number of rows you request should exceed the maximum number
that you might display at once, but it should be small enough to not consume tons
of heap space. For the purposes of this sample, 50 is plenty, though since our rows
are fairly small, we could go higher if needed.
PAGING ROOM DATA
198

Finally, we can get a LiveData object by calling build() on the
LivePagedListBuilder.
The PagedListAdapter
Our LivePagedListProvider will provide us with a PagedList of our City data, by
way of the CitiesViewModel. To consume that, we can use a PagedListAdapter to
show our cities in a RecyclerView. Ours is called CityAdapter and is a nested class
inside of a CitiesFragment:
private
private static
static class
class CityAdapter
CityAdapter extends
extends PagedListAdapter<City, RowHolder> {
private
private final
final LayoutInflater inflater;
CityAdapter(LayoutInflater inflater) {
super
super(CITIES_DIFF);
this
this.inflater=inflater;
}
@Override
public
public RowHolder onCreateViewHolder(ViewGroup parent, int viewType) {
return
return(new
new RowHolder(inflater.inflate(R.layout.row, parent, false
false)));
}
@Override
public
public void onBindViewHolder(RowHolder holder, int position) {
City city=getItem(position);
if
if (city==null
null) {
holder.clear();
}
else
else {
holder.bind(city);
}
}
}
(from CityPop/RoomPaging/app/src/main/java/com/commonsware/android/citypop/CitiesFragment.java)
To a large extent, you use PagedListAdapter as you would any other subclass of
RecyclerView.Adapter, including needing to implement onCreateViewHolder()
and onBindViewHolder(). PagedListAdapter manages the PagedList for us, and
that in turn provides us with some methods that we will need along with
opportunities to configure how the adapter works.
PAGING ROOM DATA
199

PagedListAdapter takes two data types: the type of data in the PagedList (here,
City) and a standard RecyclerView.ViewHolder as you would use with any other
RecyclerView.Adapter (here, RowHolder).
PagedListAdapter needs you to pass a DiffCallback object to the
PagedListAdapter constructor. DiffCallback is part of the RecyclerView family of
classes. It can work with a RecyclerView to reflect changes made to the data behind
the RecyclerView, ideally with the minimum amount of actual work required by the
RecyclerView itself. For more details on DiffCallback and its role, see The Busy
Coder’s Guide to Android Development.
Specifically, we need to supply a DiffCallback for our model data type, City in this
case. To that end, we have a static instance of DiffCallback named CITIES_DIFF:
static
static final
final DiffCallback<City> CITIES_DIFF=new
new DiffCallback<City>() {
@Override
public
public boolean areItemsTheSame(@NonNull City oldItem,
@NonNull City newItem) {
return
return(oldItem.equals(newItem));
}
@Override
public
public boolean areContentsTheSame(@NonNull City oldItem,
@NonNull City newItem) {
return
return(areItemsTheSame(oldItem, newItem));
}
};
(from CityPop/RoomPaging/app/src/main/java/com/commonsware/android/citypop/CitiesFragment.java)
areItemsTheSame() takes advantage of that equals() method that we implemented
on City, to determine if two City objects are the same by their id values. The data
in the database is fairly unique — any two rows should have different content — so
areContentsTheSame() simply delegates to areItemsTheSame().
PagedListAdapter offers a getItem() method. Given a position, it will give us the
model object (City) for that position… if that model object is loaded. If not, it will
return null. So, in the onBindViewHolder() method of our CitiesAdapter uses
getItem(), and either binds the City to the RowHolder or asks the RowHolder to
clear() its contents.
RowHolder, in turn, does typical ViewHolder things: retrieving widgets out of the
inflated layout and adjusting their contents as needed:
PAGING ROOM DATA
200

private
private static
static class
class RowHolder
RowHolder extends
extends RecyclerView.ViewHolder {
private
private final
final TextView cityLabel;
private
private final
final TextView country;
private
private final
final TextView population;
RowHolder(View itemView) {
super
super(itemView);
cityLabel=itemView.findViewById(R.id.city);
country=itemView.findViewById(R.id.country);
population=itemView.findViewById(R.id.population);
}
void bind(City city) {
cityLabel.setText(city.city);
country.setText(city.country);
population.setText(NumberFormat.getInstance().format(city.population));
}
void clear() {
cityLabel.setText(null
null);
country.setText(null
null);
population.setText(null
null);
}
}
(from CityPop/RoomPaging/app/src/main/java/com/commonsware/android/citypop/CitiesFragment.java)
In a production app, we might put placeholder information in the rows for a null
City, rather than clear the widgets.
The CitiesFragment
CitiesFragment inherits from a RecyclerViewFragment seen earlier in the book.
That, plus our use of LiveData and view models, means the only method on
CitiesFragment itself is onViewCreated():
@Override
public
public void onViewCreated(View view, Bundle savedInstanceState) {
super
super.onViewCreated(view, savedInstanceState);
setLayoutManager(new
new LinearLayoutManager(getActivity()));
getRecyclerView()
.addItemDecoration(new
new DividerItemDecoration(getActivity(),
LinearLayoutManager.VERTICAL));
CitiesViewModel vm=ViewModelProviders.of(this
this).get(CitiesViewModel.class);
final
final CityAdapter adapter=new
new CityAdapter(getActivity().getLayoutInflater());
PAGING ROOM DATA
201

vm.pagedCities.observe(this
this, cities -> adapter.setList(cities));
setAdapter(adapter);
}
(from CityPop/RoomPaging/app/src/main/java/com/commonsware/android/citypop/CitiesFragment.java)
In addition to basic setup of the RecyclerView, we:
• Obtain or create our CitiesViewModel by way of ViewModelsProvider
• Create our CitiesAdapter
• Arrange to observe the LiveData and hand the resulting PagedList objects
over to the CitiesAdapter, via its inherited setList() method
• Attach the CitiesAdapter to the RecyclerView
The Results
The UI is fairly straightforward: a scrolling list of rows that contains the city name,
country or area the city resides in, and its 2015 population:
Figure 2: Room Paging Demo
If you scroll through the list of countries, even with a fairly aggressive fling
operation, the list scrolls smoothly. On a well-equipped Android device there are no
PAGING ROOM DATA
202

blank rows, as Room is able to load the 50-at-a-time pages fairly quickly and make
them available to the PagingListAdapter, so we do not see any gaps.
Obviously, not all sources of data will be that quick to load, and not all Android
devices are powerful. You will need to run your own experiments with your own
data and test devices to determine what the best thing to do is when
PagingListAdapter lacks a model object for a particular position that has scrolled
into view.
PAGING ROOM DATA
203


Paging Beyond Room
Room’s support of the Paging library makes for a gentle way of getting into using
paging to display large data sets. You just wrap what Room gives you in a
LivePagedListBuilder and use the resulting PagedList with things like
PagedListAdapter and a RecyclerView.
Often, though, life is more complicated that that.
In this chapter, we will stick with Room as our source of data, but explore other
wrinkles with the Paging library that might be more applicable to your scenario.
Writing Your Own DataSource
In the end, the Paging library is based on implementations of DataSource. As the
name suggests, DataSource is a common API around sources of data, in particular
data that can be paged.
At the present time, there are three major DataSource implementations to use as a
foundation. Two of these — PageKeyedDataSource and ItemKeyedDataSource – are
designed for network APIs (REST, GraphQL, etc.), where we have to adapt to the
API offered by the Web service.
PositionalDataSource is the third DataSource foundation. It is for cases where the
DataSource has full random access of the underlying data. The client using the
PositionalDataSource can ask for M items starting at position N, for arbitrary
values of M and N, and the PositionalDataSource should be able to fulfill that
request.
205

Room, under the covers, uses a PositionalDataSource. The DataSource.Factory
that you get back from Room will create PositionalDataSource implementations
on demand, backed by the database query that you specified in your @Dao.
The Problem: Life Is More Than Entities
However, Room’s support for PositionalDataSource has a key limitation: it only
works with things that Room knows about. You can have it return classes annotated
with @Entity, or you could have it return other POJOs for which the columns in
the query map cleanly to the fields in the POJOs.
However, that’s pretty much it. Instantiating these objects is Room’s responsibility.
You do not get control at any point (other than the constructor), up until the
objects show up in your RecyclerView for binding to the rows, cells, or other visual
representation.
This approach works for many simpler scenarios. However, it falls down for more
complex situations.
Data Beyond Room
Suppose that the database table that you wish to page through represents
particular locations of interest: name, description, latitude/longitude, etc. However,
what you want to display is not only from that table, but also from a network
source, such as the weather forecast for that location.
Room has no way to fetch a weather forecast from a network source of weather
data.
The clean way of constructing an app with this sort of combined data source is to
use the repository pattern, as will be discussed in an upcoming chapter. The
repository is responsible for getting the data from Room, blending it with data from
the network, and returning the results. But, in this case, we cannot readily use
Room’s PositionalDataSource, as we do not get a chance, in our repository, to
make the network calls to get the forecasts.
Models, Not Entities
Entities and other Room-capable POJOs have certain rules that they need to follow,
such as having a suitable constructor or setter methods. That may or may not be
PAGING BEYOND ROOM
206

the API that you want to expose to the UI layer. For example, you may want your UI
layer to work with immutable objects, and Room does not work well with the
leading immutability implementation for Java: AutoValue.
Or, perhaps your data comes from multiple sources naturally. For example, the real
source of data is the network, but you also support offline caching, whether in a
Room-fronted SQLite database or in some other form of cache. However, the way
that the network API may want to represent the data may not match the way that
your caching solution wants to represent the data. You might have one set of
POJOs that Retrofit or Apollo-Android uses and a different set of POJOs that Room
uses. Your UI layer should be working with a single representation, independent of
where the data comes from… and that might be some third set of data structures
(e.g., immutable objects). Your repository can handle the work to normalize the
data from the disparate sources… but then you need to offer your own DataSource,
not one directly from Room.
Derived Data
Room’s direct-to-Paging solution also does not give you a chance to perform any
work on the data that comes from Room, prior to that data arriving in your
RecyclerView. Perhaps part of what you need to show is derived from Room data
but requires some amount of calculation on your part, where that calculation may
be slow and not good for the main application thread. In some cases, you can
perform the calculation in the database and have it be part of the query. In other
cases, the calculation may require more expressive power than you get from
SQLite’s available functions, or it may need data that is held in your app, not in
SQLite.
Once again, a repository can handle all of this calculation work, but it means that
you need your own DataSource, not just the one that you get from Room.
What Doesn’t Work: Decorator/Wrapper
One might think that these scenarios could be handled via the decorator pattern.
Create a DataSource wrapper that delegates to the wrapped DataSource and
performs conversions or additional work as needed. For example, if Room’s
DataSource is returning some form of entity objects, you could create a
ModelDataSource that wraps Room’s DataSource and converts the entities to
models.
PAGING BEYOND ROOM
207

It is conceivable that this could be done, but when the author of this book went
down that path, it seemed to be impractical, at least with the current alpha5
implementation of the Paging library.
Partly, that is because some classes and methods that we need are not public.
Partly, that is because the Paging implementation involves callbacks calling
callbacks calling callbacks. This “callback-ception” approach makes wrapping
difficult, as we cannot necessarily get control at the proper points to provide
wrappers for all of the nested callbacks.
It is possible that future editions of the Paging library will offer greater flexibility
here.
Inside a Custom Data Source
On the plus side, creating a custom PositionalDataSource, is not that difficult.
The API is fairly small, so it is not like there are dozens of methods that you have to
implement.
In this section, we will example some classes that build up to a concrete custom
PositionalDataSource, for a series of to-do items. While the to-do items are stored
in a ToDoDatabase in a ToDoEntity-defined table, the objects we want the UI layer
to work with are ToDoModel instances. So, to provide paging with ToDoModel
objects, we have a ToDoModelDataSource.
This data source will be used to populate a RecyclerView with the roster of to-do
items, as part of an extensive upcoming sample app.
The sample app builds up a ToDoModelDataSource using two other custom ancestor
classes: BaseDataSource and SnapshotDataSource.
BaseDataSource
There are two abstract methods to be implemented on a PositionalDataSource
subclass: loadInitial() and loadRange(). loadRange() loads a specified number
of items starting at a specified position, while loadInitial() loads some initial
page’s worth of content.
If you use paging with Room and have a @Dao method return a
DataSource.Factory, the generated code uses an internal class named
PAGING BEYOND ROOM
208

LimitOffsetDataSource to perform the SQLite operations and fulfill the
PositionalDataSource contract. BaseDataSource is based on that
LimitOffsetDataSource and converts the loadInitial() and loadRange()
methods into countItems() and loadRangeAtPosition() methods:
package
package com.commonsware.android.todo.impl;
import
import android.arch.paging.PositionalDataSource
android.arch.paging.PositionalDataSource;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
import
import java.util.Collections
java.util.Collections;
import
import java.util.List
java.util.List;
abstract
abstract class
class BaseDataSource
BaseDataSource<T> extends
extends PositionalDataSource<T> {
abstract
abstract protected
protected int countItems();
abstract
abstract protected
protected List<T> loadRangeAtPosition(int position, int size);
@Override
public
public void loadInitial(@NonNull LoadInitialParams params,
@NonNull LoadInitialCallback<T> callback) {
int total=countItems();
if
if (total==0) {
callback.onResult(Collections.emptyList(), 0, 0);
}
else
else {
final
final int position=computeInitialLoadPosition(params, total);
final
final int size=computeInitialLoadSize(params, position, total);
List<T> list=loadRangeAtPosition(position, size);
if
if (list!=null
null && list.size()==size) {
callback.onResult(list, position, total);
}
else
else {
invalidate();
}
}
}
@Override
public
public void loadRange(@NonNull LoadRangeParams params,
@NonNull LoadRangeCallback<T> callback) {
List<T> list=loadRangeAtPosition(params.startPosition, params.loadSize);
if
if (list!=null
null) {
callback.onResult(list);
}
else
else {
PAGING BEYOND ROOM
209

invalidate();
}
}
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/BaseDataSource.java)
countItems() needs to return the current number of items that are available for
whatever data source the BaseDataSource uses. Subclasses will need to do
something, like query a database, to find out the value. loadInitial(), therefore
starts off by getting the count and calling the callback’s onResult() method with
an empty list if there are no items.
Assuming that there are items that could be returned, loadInitial() leverages the
computeInitialLoadPosition() and computeInitialLoadSize() helper methods –
supplied by PositionalDataSource — to determine the position and size to pass to
loadRangeAtPosition(). loadRangeAtPosition() takes simple position and size
values and is responsible for loading those on demand. If we got a valid list back,
loadInitial() passes the list to the callback’s onResult() method; otherwise, we
mark our source as invalidated, so it should no longer be used.
loadRange() is even simpler: it merely converts the supplied params into a position
and size and calls loadRangeAtPosition(). Once again, the results are passed to
the callback’s onResult() method if we have a list, or else we invalidate()
ourselves.
Both loadInitial() and loadRange() should be called on background threads
(e.g., via a LivePagedListBuilder), and therefore countItems() and loadRange()
will be called on background threads.
So, the result of BaseDataSource is to replace one API with a simpler one.
SnapshotDataSource
Room’s LimitOffsetDataSource uses the position and size as values for OFFSET and
LIMIT clauses in SQL statements.
SnapshotDataSource extends BaseDataSource and takes a different approach: load
in all of the primary keys in one shot, then use those keys to load in the real data as
needed. This allows us to map between positions and primary keys at any point in
time, at pure-memory speed. The downside is that it consumes more memory,
since we have all of the keys (long values, UUIDs, etc.) in memory at once, in
PAGING BEYOND ROOM
210

addition to any fully-populated models. This should not be a huge issue in practice,
as even a Paging-enabled list needs to be reasonable in length. Users will not be
swiping through tens of thousands of items — they will throw their device against a
wall and attack the developer with an machete first. Any UI needs to keep the
number of items in the list to be a reasonable level, and so SnapshotDataSource
should not introduce a major memory burden.
SnapshotDataSource, like BaseDataSource, is abstract, mapping the countItems()
and loadRangeAtPosition() methods to loadKeys() and loadForIds() methods:
package
package com.commonsware.android.todo.impl;
import
import java.util.Collections
java.util.Collections;
import
import java.util.List
java.util.List;
public
public abstract
abstract class
class SnapshotDataSource
SnapshotDataSource<T, PK> extends
extends BaseDataSource<T> {
protected
protected abstract
abstract List<PK> loadKeys();
protected
protected abstract
abstract List<T> loadForIds(List<PK> pks);
private
private volatile
volatile List<PK> keys=null
null;
public
public int findPositionForKey(PK key) {
if
if (keys==null
null) {
throw
throw new
new IllegalStateException("Attempted to find position for key without having keys loaded");
}
return
return keys.indexOf(key);
}
public
public PK findKeyForPosition(int position) {
if
if (keys==null
null) {
throw
throw new
new IllegalStateException("Attempted to find position for key without having keys loaded");
}
return
return keys.get(position);
}
@Override
protected
protected List<T> loadRangeAtPosition(int position, int size) {
initKeys();
return
return loadForIds(keys.subList(position, position+size));
}
@Override
protected
protected int countItems() {
initKeys();
return
return keys.size();
}
synchronized
synchronized private
private void initKeys() {
if
if (keys==null
null) {
keys=Collections.unmodifiableList(loadKeys());
}
PAGING BEYOND ROOM
211

}
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/SnapshotDataSource.java)
Subclasses can then use a Room DAO (or whatever) to load all of the primary keys,
reflecting whatever filtering is desired. Plus, the subclasses will use the same
backing store to get the real objects based on a slice of the overall primary key list.
SnapshotDataSource also provides helper methods to convert between positions
and primary key values (findPositionForKey() and findKeyForPosition()).
Those fail fast if, for some strange reason, you try to use them before you have
really started using the SnapshotDataSource and do not yet have the keys loaded.
ToDoModelDataSource
So now we can create a SnapshotDataSource subclass that bridges between this
constructed DataSource protocol and a @Dao, in this case in the form of a
ToDoModel.Store class.
That Store class has Room @Query methods to support what a SnapshotDataSource
needs:
@Query("SELECT id FROM todos ORDER BY description")
abstract
abstract List<String> allKeys();
@Query("SELECT id FROM todos WHERE isCompleted=:isCompleted ORDER BY description")
abstract
abstract List<String> filteredKeys(boolean isCompleted);
@Query("SELECT * FROM todos WHERE id IN (:ids) ORDER BY description")
abstract
abstract List<ToDoEntity> forIds(List<String> ids);
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoEntity.java)
The sample app that uses this ToDoModelDataSource has a filtering feature. Users
can choose from three filter settings:
• Show all of the to-do items
• Show only those to-do items that are marked as having been completed
• Show only those to-do items that are still outstanding (i.e., have not been
marked as completed)
Our ToDoModelDataSource will need to take the current filter mode into account.
To that end, we have:
•
allKeys(), to be used when we want to show all of the to-do items
PAGING BEYOND ROOM
212

•
filteredKeys(), to be used when we want either the completed or the
outstanding items (but not both)
•
forIds(), to retrieve the full entities for a given set of id values
All three methods apply our sort order, so that the keys come back in the desired
order, plus to ensure that SQLite and Room return our entities (for a given page) in
that same order.
ToDoModelDataSource then is a SnapshotDataSource subclass that wraps a
ToDoModel.Store and uses those new methods to implement loadKeys() (based on
FilterMode) and loadForIds() (converting from entities to models along the way):
package
package com.commonsware.android.todo.impl;
import
import java.util.ArrayList
java.util.ArrayList;
import
import java.util.List
java.util.List;
class
class ToDoModelDataSource
ToDoModelDataSource extends
extends SnapshotDataSource<ToDoModel, String> {
private
private final
final ToDoEntity.Store todoStore;
private
private final
final FilterMode filterMode;
ToDoModelDataSource(ToDoDatabase db, FilterMode filterMode) {
todoStore=db.todoStore();
this
this.filterMode=filterMode;
}
@Override
protected
protected List<String> loadKeys() {
if
if (filterMode==FilterMode.ALL) {
return
return todoStore.allKeys();
}
else
else if (filterMode==FilterMode.COMPLETED) {
return
return todoStore.filteredKeys(true
true);
}
return
return todoStore.filteredKeys(false
false);
}
@Override
protected
protected List<ToDoModel> loadForIds(List<String> strings) {
ArrayList<ToDoModel> result=new
new ArrayList<>();
for
for (ToDoEntity entity : todoStore.forIds(strings)) {
result.add(entity.toModel());
}
PAGING BEYOND ROOM
213

return
return result;
}
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoModelDataSource.java)
FilterMode is an enum, used by this sample app, to denote the particular filter that
the user has requested. FilterMode.ALL, FilterMode.COMPLETED, and
FilterMode.OUTSTANDING values determine which of the ToDoEntity.Store
methods we call to get our keys and what parameters we supply.
Since the API methods on BaseDataSource should be called on background
threads, the methods on ToDoModelDataSource should be called on those same
background threads, so it is safe for us to make synchronous queries against the
database.
LivePagedListBuilder and Custom DataSources
There is one thing missing with the previous section’s depiction of a custom
DataSource: its Factory. Room does not return a DataSource — it returns a
DataSource.Factory. LivePagedListBuilder does not use a DataSource — it uses a
DataSource.Factory.
There’s a reason for this approach: invalidation.
DataSource Invalidation
Room not only provides data to you up front, but if you use appropriate reactive
types (e.g., LiveData, Observable), it can also provide you with updates to the data
over time, as that data changes. So, for example, if you have a @Query method on
your @Dao class that returns a LiveData for some query, not only will you get the
current values, but if you use Room to modify the database, you will get the
updated values delivered to you automatically.
With Observable and LiveData, you simply get the new results, and it is up to you
to deal with those results as appropriate. Under the covers, the
DataSource.Factory returned by Room does something different: it invalidates the
previous DataSource returned by the Factory.
The base DataSource class is mostly for invalidation-related methods:
PAGING BEYOND ROOM
214

•
invalidate() to mark a particular DataSource as invalid
•
addInvalidatedCallback() and removeInvalidatedCallback(), for
interested parties to find out when the DataSource is invalidated
•
isInvalid() to return the current invalidation status of the DataSource
When a DataSource is invalid, in principle, it should stop loading any data.
Effectively, “invalid” is used to mean “stale”; invalidating a DataSource tells
interested parties that they should get a fresh DataSource… such as from the
DataSource.Factory that was used to create the current DataSource.
As a result, when the data changes in your database and your existing DataSource
may reflect old results, Room will invalidate that DataSource. A consumer of that
DataSource — such as a LivePagedListBuilder — can register an
InvalidatedCallback, find out when the current DataSource becomes invalid, and
get a fresh DataSource from the associated Factory.
Crafting a DataSource.Factory
A DataSource.Factory needs but one public method: create(). It takes no
parameters and returns a DataSource.
However, the important thing is that it needs to be able to do this repeatedly, with a
fresh, not-yet-invalidated DataSource each time. This implies that the Factory
holds onto the objects necessary to create the desired DataSource. In the case of
ToDoModelDataSource, that means that its Factory would need to hold onto the
ToDoDatabase and FilterMode necessary to create a fresh ToDoModelDataSource.
What If DO NOT WANT?
The Paging invalidation pattern assumes that the driver of new data is Room or
some other DataSource.Factory provider. Changes in data are detected at low
levels and push new results to the UI.
That may or may not be appropriate. In particular, it may be tricky to integrate that
with your desired GUI architecture.
For example, the sample app employing ToDoModelDataSource and the other
classes shown here is an example of the Model-View-Intent (MVI) GUI
architecture. There is a specific flow dictated by that architecture. While underlying
data changes might necessitate UI updates, that needs to be done as part of the
PAGING BEYOND ROOM
215

overall GUI architecture. Having it as some secondary channel might lead to
conflicts.
As a result, ToDoModelDataSource does not use invalidation.
There is no requirement for a DataSource to use the invalidation mechanism. This
is an available communications channel between a DataSource, its Factory, and
consumers of those objects. However, “available” does not mean “required”, and if
you are getting your UI updates by some other means, that is perfectly fine.
However, in this case, it means that LivePagedListBuilder is overkill. It will be
waiting for signs of invalidation that never arrive. As a result, this sample app does
not use LivePagedListBuilder to set up its PagedListAdapter for its
RecyclerView. Instead, it uses a separate class, called PagedList.Builder.
PagedList.Builder
PagedList.Builder “does what it says on the tin”: it builds PagedList instances.
Those instances can then be handed over to consumers like a PagedListAdapter to
consume the paged data.
The current PagedList.Builder API is not bad but is unnecessarily complex.
You provide two things to the PagedList.Builder constructor: the DataSource to
page against, and an int that represents the desired page size. Whether that
particular page size is used depends on the actual DataSource implementation – in
the case of a PositionalDataSource, the page size is used in the calls to
loadInitial() and loadRange().
However, given the Builder, before you can build() a PagedList, you need to
provide two Executor instances. Executor is a Java abstraction around things like
thread pools. It just has an execute() method to execute some Runnable, on a
thread designated by the Executor. Typically, we get Executor instances from the
Executors utility class, which has a number of factory methods for common
patterns (e.g., thread pools).
One Executor is supplied to the Builder via the setBackgroundThreadExecutor()
method. As the name suggests, this is a thread used for doing the actual data
loading. For a PositionalDataSource, this will be the thread for the loadInitial()
and loadRange() calls. If you already have some Executor that you are using for a
PAGING BEYOND ROOM
216

thread pool, you might supply it here. Or, call
Executors.newSingleThreadExecutor() to get an Executor with a single dedicated
background thread.
The other Executor is passed to setMainThreadExecutor(). This Executor is
supposed to execute its Runnable on the main application thread.
It may not be immediately obvious how to do this without introducing some sort of
memory leak. For example, you could use runOnUiThread() on an Activity,
wrapped in an Executor, but then there are risks that if the PagedList outlives the
Activity (e.g., configuration change), you might leak the Activity.
Ideally, future versions of this API will provide a default implementation.
Google demonstrates one implementation in one of their sample apps:
private
private static
static class
class MainThreadExecutor
MainThreadExecutor implements
implements Executor {
private
private Handler mainThreadHandler = new
new Handler(Looper.getMainLooper());
@Override
public
public void execute(@NonNull Runnable command) {
mainThreadHandler.post(command);
}
}
Handler, like View, offers a post() method that takes a Runnable. The stock recipe
for creating a Handler that is certain to be tied to the main application thread is to
get the Looper for that thread (via Looper.getMainLooper()) and pass that Looper
to the Handler constructor.
The sample app containing ToDoModelDataSource has a PagedDataSnapshot class
that builds the PagedList using PagedList.Builder and an equivalent main-thread
Executor:
package
package com.commonsware.android.todo.impl;
import
import android.arch.paging.PagedList
android.arch.paging.PagedList;
import
import android.os.Handler
android.os.Handler;
import
import android.os.Looper
android.os.Looper;
import
import java.util.concurrent.Executor
java.util.concurrent.Executor;
import
import java.util.concurrent.Executors
java.util.concurrent.Executors;
public
public class
class PagedDataSnapshot
PagedDataSnapshot<T, PK> {
private
private final
final SnapshotDataSource<T, PK> dataSource;
private
private final
final PagedList<T> pagedList;
PAGING BEYOND ROOM
217

public
public PagedDataSnapshot(SnapshotDataSource<T, PK> dataSource, int count) {
this
this.dataSource=dataSource;
PagedList.Builder<Integer, T> builder=
new
new PagedList.Builder<>(dataSource, count);
pagedList=builder
.setBackgroundThreadExecutor(Executors.newSingleThreadExecutor())
.setMainThreadExecutor(new
new MainThreadExecutor())
.build();
}
public
public SnapshotDataSource<T, PK> dataSource() {
return
return dataSource;
}
public
public PagedList<T> pagedList() {
return
return pagedList;
}
private
private static
static class
class MainThreadExecutor
MainThreadExecutor implements
implements Executor {
private
private Handler mainHandler=new
new Handler(Looper.getMainLooper());
@Override
public
public void execute(Runnable command) {
mainHandler.post(command);
}
}
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/PagedDataSnapshot.java)
We will see more about PagedDataSnapshot in the full coverage of this sample app.
PAGING BEYOND ROOM
218

Exploring Architecture


Immutability
Generally, developers like setters.
After all, it stands to reason that if you can get a piece of data from an object, you
should be able to modify that piece of data in that same object. We are used to read-
write data structures, whether in memory or persisted.
However, there are some costs to allowing objects to be mutable (in other words,
able to be modified). In some cases, you can have a more robust app architecture if
you consider objects to be immutable and unable to be modified. The objects get
replaced outright, rather than changing their contents. This winds up being a bit
more reminiscent of a transactional database, where changes are applied as a unit,
rather than piecemeal.
In this chapter, we will explore the benefits (and costs) of immutability and how to
create immutable (or mostly immutable) objects in Java.
The Benefits of Immutability
Having immutable objects — particularly for things like models — is not a new
concept. Immutability has had its adherents for quite some time. It is what lead to
libraries like AutoValue for Java, and immutability features in languages like Kotlin.
So, why go with immutability?
221

No Dirty Data
A perpetual problem with model objects (and related objects, such as view-models),
is knowing what data changed, when, and by what. That comes from promiscuous
use of setters, blindly changing data that might be in use already.
For example:
• You implement a model cache, shared between your code that gets data from
the server and your UI code, to minimize memory consumption
• You construct a view-model from a model object, representing data to be
presented to the user in the UI
• You use two-way data binding, so user interactions with the UI directly
update the view-model
• Your code for communicating with the server finds out about an update that
happens to affect that same model object, and it updates the model object in
the cache
• Your UI code, after the user clicks Save to commit the data changes, uses the
view-model contents to update the model object
Now, we have possible data consistency issues:
• The model started in state A
• The view-model was created based on that state A
• The user mutates the view-model and moves it to state B
• The server-sync code mutates the model and moves it to state C
• The view-model updates the model and moves it to state B… potentially
ignoring the changes the server-sync code made that resulted in state C
Immutable model and view-model objects do not prevent this sort of situation, but
they help to make it a bit more obvious. Changing the state is a more obvious action;
it is not merely a matter of calling some setters.
Thread Safety
If more than one thread has access to the same data, and that data can change, we
wind up having to synchronize access to that data, so that changes can be made
atomically. We do not want a thread to be part-way through updating the data when
another thread tries reading it, as the partly-updated data may be in an inconsistent
state at that moment. We wind up using synchronized and CopyOnWriteArrayList
and all sorts of other constructs to allow mutable data to be shared between threads.
IMMUTABILITY
222

This goes away if the data is immutable. Multiple threads can read the same,
unchanging data whenever they want without issue. Now, we limit our
synchronization to more specific scenarios, such as updating shared caches: so long
as we are replacing a cache entry atomically, all consumers of the cache can run in
parallel, if the cache entries themselves are immutable.
Functional Programming
One way to combat the complexities of multi-threaded development is to use
functional programming. Functional programming is based on pure functions:
methods (or the equivalent) that operate solely on input parameters, with no side-
effects that affect the operation of the program.
RxJava is based on functional programming concepts. We build up chains of RxJava
operators, where each operator applies some sort of function to the input, such as
the map() operator applying a Function to convert objects from one type to another.
Immutability is one way of imposing a contract upon yourself, as a developer, to
avoid side effects. Calling a setter is a very casual act in programming, even if calling
that setter introduces a side effect. Immutability enforces the creation of new
objects, ideal for use in pure functions, where the function can create objects to
return but cannot change the parameters’ contents and cause side effects.
The Costs of Immutability
Immutability is not without its downsides. Partly, that comes from its use in
languages where immutability is not an integrated feature, such as Java. And partly,
that comes from environments where mutability is the norm; you may be unable to
impose immutability due to environmental restrictions.
Partial Immutability Problems
In a language like Java, where immutability is not a built-in feature, you need to
implement it manually, ensuring that your to-be-immutable objects lack setters or
other means of manipulating their contents. On the surface, this may not seem very
difficult. After all, not writing code (e.g., setters) should take less time than would
actually writing that code.
However, not everything can be made immutable just by avoiding setters.
IMMUTABILITY
223

For example, suppose we have:
class
class FooModel
FooModel {
final
final String bar;
final
final List<GooModel> goos;
FooModel(String bar, List<GooModel> goos) {
this
this.bar=bar;
this
this.goos=goos;
}
}
There are no setters, and both fields are final. This is immutable, right?
Actually, no, because the goos List might be mutable. If this is just an ordinary
ArrayList, for example, holders of a FooModel instance can call add() or remove()
on the goos field, changing its contents.
This can be improved somewhat via the Collections class and its
unmodifiableList() method:
class
class FooModel
FooModel {
final
final String bar;
final
final List<GooModel> goos;
FooModel(String bar, List<GooModel> goos) {
this
this.bar=bar;
this
this.goos=Collections.unmodifiableList(goos));
}
}
Now, goos will fail if you attempt to call add(), remove(), etc. on it.
However, not all collection types have a corresponding unmodifiable...() method.
Plus, you need to remember to use the unmodifiable...() method, such as we do
here in the constructor. And, what if GooModel is mutable? Holders of a FooModel
could reach into goos, pluck out a GooModel, and change it.
Creating surface-level immutability is not that hard, even in Java. The challenge is in
having immutability “all the way down”.
Some Things Want Setters
Unfortunately, some things really want setters or other forms of mutability:
IMMUTABILITY
224

• An interface might imply mutability. Spannable, for example, has setSpan()
and removeSpan() methods, implying mutability.
• Some frameworks might require mutability, at least for some features. Data
binding, for example, works with immutable objects… except for two-way
binding, which requires some means to modify the existing bound object.
Even for one-way binding, Observable requires that the object support
registering and removing listeners, which itself is an aspect of mutability.
In these and similar cases, avoiding mutability may be impossible, just because you
are trying to use something that itself expects some degree of mutability.
Garbage, To Be Collected
One big problem with immutability is that it leads to lots of data copying. Instead of
simply updating a field of a model object with a new value, we create a new instance
of that model object. We cannot even use an object pool to help minimize the
garbage that gets created, because typically we cannot reuse an existing object…
because to reuse it, we often need to fill in different data, and that requires
mutability.
The copies might be shallow copies, reducing the amount of garbage. Going back to
the earlier example, we could have:
class
class FooModel
FooModel {
final
final String bar;
final
final List<GooModel> goos;
FooModel(String bar, List<GooModel> goos) {
this
this.bar=bar;
this
this.goos=Collections.unmodifiableList(goos));
}
FooModel withNewBar(String bar) {
return
return(new
new FooModel(bar, this
this.goos));
}
}
Here, we create a new FooModel, but both the old and the new instance of FooModel
share the same goos collection. If goos is immutable, sharing it between two
FooModel instances is not a problem. So, we consume the extra memory for an extra
FooModel, but not an extra list of GooModel instances, keeping the memory
consumption down.
IMMUTABILITY
225

However, there is little doubt that immutability leads to more garbage in Java. On
Android 5.0+, ART’s garbage collector will help reduce the impact of this garbage,
but it cannot completely eliminate its effects.
Immutability via AutoValue
Many developers who elect to make immutable classes in Java elect to use Google’s
AutoValue library. This library uses annotations and code generation to help enforce
immutability, while also handling aggravating details like implementing equals(),
hashCode(), and so forth.
For basic stuff, using AutoValue is fairly simple: implement an abstract class with
abstract getter methods for the data that you want the immutable class to hold.
Add the @AutoValue annotation — along with the dependency that supplies it —
and AutoValue takes over from there.
Earlier in the book, we had the LiveSensor sample app, where we wrapped the
SensorManager in a LiveData. The General/AutoSensor sample project is a clone of
that one, where we use AutoValue for the event objects.
The original project had a simple Event static class inside of SensorLiveData, using
final for its limited immutability:
static
static class
class Event
Event {
final
final Date date=new
new Date();
final
final float[] values;
Event(SensorEvent event) {
values=new
new float[event.values.length];
System.arraycopy(event.values, 0, values, 0, event.values.length);
}
}
(from General/LiveSensor/app/src/main/java/com/commonsware/android/livedata/SensorLiveData.java)
The revised project pulls that Event class out to a top-level AutoSensorEvent class
and applies AutoValue to it:
package
package com.commonsware.android.livedata;
import
import android.hardware.SensorEvent
android.hardware.SensorEvent;
import
import com.google.auto.value.AutoValue
com.google.auto.value.AutoValue;
IMMUTABILITY
226

import
import java.util.ArrayList
java.util.ArrayList;
import
import java.util.Arrays
java.util.Arrays;
import
import java.util.Collections
java.util.Collections;
import
import java.util.Date
java.util.Date;
import
import java.util.List
java.util.List;
@AutoValue
abstract
abstract class
class AutoSensorEvent
AutoSensorEvent {
abstract
abstract long date();
abstract
abstract List<Float> values();
static
static AutoSensorEvent from(SensorEvent event) {
ArrayList<Float> values=new
new ArrayList<>();
for
for (float value : event.values) {
values.add(value);
}
return
return(new
new AutoValue_AutoSensorEvent(System.currentTimeMillis(),
Collections.unmodifiableList(values)));
}
}
(from General/AutoSensor/app/src/main/java/com/commonsware/android/livedata/AutoSensorEvent.java)
Annotating an abstract class with @AutoValue causes AutoValue to find all getter-
style abstract methods — in this case, date() and values(). AutoValue then code-
generates a shadow class, AutoValue_AutoSensorEvent, that is a concrete
implementation of the AutoSensorEvent API. We use the concrete class constructor
to make instances of an AutoSensorEvent-compatible class. Outside parties using
AutoSensorEvent should neither know nor care that the actual implementation is
actually AutoValue_AutoSensorEvent. The AutoValue_AutoSensorEvent class not
only handles our two data values but also the equals(), hashCode(), and
toString() methods as well.
Our from() factory method sets up the data to be passed to the
AutoValue_AutoSensorEvent constructor. We use unmodifiableList() to ensure
that nobody can modify the contents of the values() List, and since Float itself is
immutable, that makes values() immutable “all the way down”. Similarly, the long
that is returned by date() is immutable, so nothing can be changed in the
AutoSensorEvent.
All of this is possible because we are adding AutoValue’s dependencies:
IMMUTABILITY
227

dependencies {
implementation 'com.android.support:recyclerview-v7:27.0.2'
implementation 'com.android.support:support-fragment:27.0.2'
implementation 'android.arch.lifecycle:runtime:1.1.0'
implementation 'android.arch.lifecycle:livedata:1.1.0'
provided 'com.google.auto.value:auto-value:1.5.1'
annotationProcessor 'com.google.auto.value:auto-value:1.5.1'
}
(from General/AutoSensor/app/build.gradle)
Here, the same dependency (com.google.auto.value:auto-value) is used twice.
The annotationProcessor dependency enables the compile-time handling of
@AutoValue and related annotations. The provided dependency adds in runtime
support code that the generated code depends upon.
AutoValue itself has many more features, including:
• Generating an optional builder-style API for constructing instances of the
@AutoValue-annotated class
• Support for @Nullable to indicate if a value can be null or not
• Memoization support for caching the results of derived values, which is
particularly useful if those calculations are expensive
AutoValue and LiveData
LiveData and AutoValue work together nicely. The revised SensorLiveData simply
uses the from() factory method to create AutoSensorEvent instances that wrap up
the data we want to cache from a SensorEvent:
package
package com.commonsware.android.livedata;
import
import android.arch.lifecycle.LiveData
android.arch.lifecycle.LiveData;
import
import android.content.Context
android.content.Context;
import
import android.hardware.Sensor
android.hardware.Sensor;
import
import android.hardware.SensorEvent
android.hardware.SensorEvent;
import
import android.hardware.SensorEventListener
android.hardware.SensorEventListener;
import
import android.hardware.SensorManager
android.hardware.SensorManager;
class
class SensorLiveData
SensorLiveData extends
extends LiveData<AutoSensorEvent> {
final
final private
private SensorManager sensorManager;
private
private final
final Sensor sensor;
private
private final
final int delay;
SensorLiveData(Context ctxt, int sensorType, int delay) {
IMMUTABILITY
228

sensorManager=
(SensorManager)ctxt.getApplicationContext()
.getSystemService(Context.SENSOR_SERVICE);
this
this.sensor=sensorManager.getDefaultSensor(sensorType);
this
this.delay=delay;
if
if (this
this.sensor==null
null) {
throw
throw new
new IllegalStateException("Cannot obtain the requested sensor");
}
}
@Override
protected
protected void onActive() {
super
super.onActive();
sensorManager.registerListener(listener, sensor, delay);
}
@Override
protected
protected void onInactive() {
sensorManager.unregisterListener(listener);
super
super.onInactive();
}
final
final private
private SensorEventListener listener=new
new SensorEventListener() {
@Override
public
public void onSensorChanged(SensorEvent event) {
setValue(AutoSensorEvent.from(event));
}
@Override
public
public void onAccuracyChanged(Sensor sensor, int accuracy) {
// unused
}
};
}
(from General/AutoSensor/app/src/main/java/com/commonsware/android/livedata/SensorLiveData.java)
AutoValue and Room
Unfortunately, AutoValue and Room do not work together, at least for @Entity
classes:
IMMUTABILITY
229

• Room wants to work with a constructor, and an @AutoValue abstract class
cannot have a constructor
• Annotations like @PrimaryKey and @ColumnInfo go on fields, and an
@AutoValue class has no fields
• Room’s documentation indicates that it wants setter methods or public
fields, and an @AutoValue class has neither
It is possible that this will be added in a future update to Room.
IMMUTABILITY
230

The Repository Pattern
There are lots of possible ways that your app’s data can be stored. It could be local,
remote, or both. The local copy could be in SQLite, XML files, JSON files, or other
forms. The server could be using REST, GraphQL, gRPC, or something else.
And, on the whole, your UI should not care.
Your UI code has enough problems to deal with. Figuring out where the data comes
from (to show the user) and where it goes (after getting input from the user) is more
than it should have to bear.
That is where the repository pattern comes into play. In a nutshell: you design a
single API that abstracts out all of the storage stuff. The repository implementation
deals with all of the decision-making for where the data goes, what all has to get
updated, what has to be refreshed from some remote source, and so on. The API just
offers “give me X” and “here is an update to Y” and so on — the basic operations that
the UI needs in order to function.
Therefore, in many respects, the repository pattern is not significantly different from
any other abstraction that one might use. However, since data storage and retrieval
is usually the reason why the app exists, it is important to give this pattern some
thought.
What the Repository Does
A repository has a few key roles inside of your app.
231

Manages Data Storage
First and foremost, this is where you isolate all of the details of the data storage,
including all the esoteric rules that your app may require (e.g., we have to update the
catalog after midnight in the server’s time zone).
The repository is responsible for:
• Making any real-time requests of a server that may be necessary, to retrieve
data that is not yet available locally
• Managing or directing any in-memory cache of that data
• Saving the data in a local persistent store, whether on a temporary or long-
term basis
• Orchestrating any background data transfers that may be necessary (e.g.,
responding to push requests, periodically synchronizing with a server)
The details of this will vary widely from app to app. Some of those details may be
dictated by business requirements. Some of those details may be dictated by the
server team. Some of those details might be under your control. As a result, there is
no single recipe for implementing a repository — all books like this can do is explain
the role, illustrate some implementations, and provide general guidance.
Normalizes Model Objects
Your UI code probably will work best with a nice clean object model representing
the data that the app needs to allow the user to see and manipulate.
However, it is quite likely that you will not get a clean object model from the data
storage code:
• Plain SQLite uses Cursor and ContentValues, which do not resemble
business objects
• Object wrappers around SQLite like Room may impose their own
limitations, such as Room’s approach for relations
• Web service APIs cannot model some data structures at all (e.g., M:N
relations), requiring some amount of data conversion to craft the desired
object model
• Some Web service APIs will have further limitations, because the developers
of the Web service had a different vision at the time they created the Web
service (e.g., older approaches, targeting other platforms)
• And so on
THE REPOSITORY PATTERN
232

Your UI code should not have to deal with any of that.
So, another part of the repository is to normalize the data from the data storage into
clean model objects that the UI code can consume. So, the repository gets to convert
those Retrofit POJOs and those Room POJOs (neither of which may resemble the
other) into some consistent POJOs that form the object model that the rest of the
app uses.
Provides a Clean Reactive API
The UI code needs to be able to make generic requests for normalized data, with the
repository handling all of the “dirty details” for making that happen.
At the same time, the UI code needs to have the patience to allow the repository to
do its work. The responsiveness of the repository could range from microseconds to
seconds, depending on a lot of environmental factors:
• Is the data that the UI wants in a memory cache? A disk cache?
• Do we have to perform a SQL request? How about a network call?
• Do we have to several of these things, because the UI is seeking a big object
graph, and our data storage options deal in smaller slices?
Here, “reactive” could mean RxJava, or possibly LiveData. It could be some form of
event bus. It could be a callback system. What it has to be is asynchronous — the
API exposed by the repository has to force the UI code to receive the data at some
time in the future, not immediately.
Isolates Rest of App from Strategy Changes
You might be tempted to cut corners on the previous point, and have some APIs
exposed by the repository that return immediately. So long as those APIs are set up
to gracefully fail — such as returning null if the data is not cached in memory —
that can be fine. However, in general, that is still not a good idea, for one simple
reason: things change. Today, your implementation might support those real-time
APIs. Tomorrow, your implementation might not, for any number of reasons:
• You elect to switch to some newer approach that simply lacks an equivalent
to the in-memory cache that you are using
• You elect to switch to some newer approach that does not offer its own real-
time API, and you need to “pass along” the reactive approach
• You jettison this particular cache because you keep running out of memory
THE REPOSITORY PATTERN
233

• And so on
If you design a reactive API around a generalized object model, you should be able to
change the implementation of the repository without requiring changes in the UI
code. The only time that the UI code would change is if the data structure itself
changes (e.g., new fields or objects added to the object model).
High-Level Repository Strategies
There are many, many ways to implement a repository. How one app approaches it
may differ significantly from how another app approaches it, and neither approach
is necessarily wrong (or right).
That being said, there are a few commonalities among the approaches that will tend
to arise, based on where the data is being stored.
Pure Network
Occasionally, you will have an app where the repository always makes network
requests whenever the UI needs data. This is fairly uncommon, as it implies that
caching is not an option, and usually there is some amount of caching that can be
applied to the problem.
Network + Network API Caching
Sometimes, the caching can be provided by whatever API you are using to access
that network:
• OkHttp offers integrated caching, assuming that the Web server uses
appropriate cache-control headers
• Apollo-Android — a library for making GraphQL requests — offers its own
caching, in addition to possibly using caching at the OkHttp layer
• Picasso, Glide, and other image-loading libraries often have their own caches
• And so on
In these cases, other than configuring the cache (e.g., specifying the directory to use
for a disk cache), there is little cache-related code in the repository itself.
THE REPOSITORY PATTERN
234

Network + External Caching
Sometimes, you may want more sophisticated caching than might be offered by the
API that you are using to access the network, Or, perhaps the caching required by
the app does not match what the libraries offer (e.g., the Web server does not use
cache-control headers, as the caching is handled by client-side rules rather than
server-side configuration). In those cases, you need to handle caching “above” the
software layer represented by those networking APIs.
The Store library offers an “all-in-one” solution for this, though the learning curve is
steep.
Network + First-Class Persistence
Sometimes — particularly for an app that offers rich offline functionality – you need
to put the local storage first in your mind, with network functionality serving in a
“sync” role.
While a robust caching system can help with “offline-first” apps, you are limited in
how you can access that cached data to whatever APIs are offered by the caches. For
caches integrated into the networking APIs, that means that all you can do is make a
network request and deal with the failures when the device is offline and the data is
not cached. Often you have no way of examining the cache to try to determine what
you can do locally.
Also, most caching systems are designed for read operations, where the “system of
record” is the server and the cache is a replica of data retrieved from that server.
Many caches offer little to no support for buffering write operations while the device
is offline. And caches, by definition, are never a “system of record”, and sometimes
the device is the primary storage location, with the network serving in the role as a
backup.
For these, your repository will be built around a rich local storage API: SQLite, an
object database, etc. The repository will be responsible for the network I/O as well,
though that network I/O may be a “side” piece of functionality, not used in the
direct fulfillment of requests from the UI.
THE REPOSITORY PATTERN
235

Persistence-Only
Sometimes, there is no server. In those cases, the repository wraps around your local
storage API of choice, with the abstraction helping to isolate you from your choice of
local storage API, in case you change your mind later.
Let’s Roll the Dice
In The Busy Coder’s Guide to Android Development, one of the sample apps is a
“diceware” app, to help you generate a passphrase made up of a series of randomly-
selected words, such as correct horse battery staple. However, that sample puts
most of the work inside a single fragment, which is messy. So, let’s rebuild that app,
hiding all of the data-loading details in a repository, with a view-model to mediate
communications between the fragment and the repository. The results can be found
in the Diceware/Repository sample project.
The Repository
In our case, the words come from two locations: a “baked in” word list in assets/
and a word list of the user’s choosing, obtained via ACTION_OPEN_DOCUMENT. However,
the data structure for each is the same: a list of words, one per line. Hence, we do
not have a sophisticated data model, only a list of strings. So our repository does not
need to worry about normalizing disparate model objects, though we might if we
obtained words from some Web service. And, our repository does not need to worry
about data modification, as the word lists are treated as read-only.
However, we still need a nice reactive API. The code for getting the words from a
user-chosen document is a bit different from the code for getting the words from an
asset. Moreover, if we want to cache the words, we need to handle the case where we
have not yet loaded the words and the case where the words are cached.
API
In the end, what our UI needs is a set of randomly-selected words, with the UI
providing the number of words and the source of those words.
To that end, Repository has a single instance method that is exposed to the rest of
the app: getWords(). It takes the Uri representing the data source and the number
of words to return. The words themselves will be a List of String objects. We wrap
that in an RxJava Single, as we do not know how long it will take to come up with
THE REPOSITORY PATTERN
236

those words at compile time, since the word list from the data source may not be
cached yet. However, we do know that this is a one-shot event, and so Single makes
more sense than does a generic Observable.
The Repository is a singleton, so we will have a static method named get() to
retrieve that singleton, given a Context to use for lazy initialization.
Implementation
getWords() breaks the problem town into two pieces: getting the full word list and
then choosing a random subset of those words:
Single<List<String>> getWords(Uri source, final
final int count) {
return
return(getWordsFromSource(source)
.map(strings -> (randomSubset(strings, count))));
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/Repository.java)
The map() operator delegates the “choose a random subset” work to a
randomSubset() method, which uses a SecureRandom instance to choose the words:
private
private List<String> randomSubset(List<String> words, int count) {
List<String> result=new
new ArrayList<>();
int size=words.size();
for
for (int i=0;i<count;i++) {
result.add(words.get(random.nextInt(size)));
}
return
return(result);
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/Repository.java)
getWordsFromSource() needs to look to see if we have a cached copy of the word list
for the requested Uri. If not, we need to arrange to load and cache those words;
otherwise, we can just use the cache. Our cache is ConcurrentHashMap mapping the
Uri to the word list:
private
private final
final ConcurrentHashMap<Uri, List<String>> cache=new
new ConcurrentHashMap<>();
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/Repository.java)
THE REPOSITORY PATTERN
237

getWordsFromSource() checks the cache and creates an Single chain based on
whether or not the words are cached:
synchronized
synchronized private
private Single<List<String>> getWordsFromSource(Uri source) {
List<String> words=cache.get(source);
final
final Single<List<String>> result;
if
if (words==null
null) {
result=Single.just(source)
.subscribeOn(Schedulers.io())
.map(uri -> (open(uri)))
.map(in -> (readWords(in)))
.doOnSuccess(strings -> cache.put(source, strings));
}
else
else {
result=Single.just(words);
}
return
return(result);
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/Repository.java)
If the words are cached, our job is simple: just return that word list, wrapped in an
Single, for getWords() to use to come up with the random subset.
If the words are not yet cached, we:
• Wrap the Uri in an Single to start a chain
• Use an open() method to get an InputStream on that the contents identified
by that Uri (or pulling in our one-and-only asset if the Uri seems to point to
assets):
private
private InputStream open(Uri uri) throws
throws IOException {
String scheme=uri.getScheme();
String path=uri.getPath();
if
if ("file".equals(scheme) && path.startsWith("/android_asset")) {
return
return(ctxt.getAssets().open(ASSET_FILENAME));
}
ContentResolver cr=ctxt.getContentResolver();
cr.takePersistableUriPermission(uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
return
return(cr.openInputStream(uri));
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/Repository.java)
THE REPOSITORY PATTERN
238

• Use a readWords() method to convert that InputStream into a word list:
private
private static
static List<String> readWords(InputStream in) throws
throws IOException {
InputStreamReader isr=new
new InputStreamReader(in);
BufferedReader reader=new
new BufferedReader(isr);
String line;
List<String> result=new
new ArrayList<>();
while
while ((line = reader.readLine())!=null
null) {
String[] pieces=line.split("\s");
if
if (pieces.length==2) {
result.add(pieces[1]);
}
}
return
return(result);
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/Repository.java)
• Arrange to do all that work on a background thread
• As a side effect, put the word list in the cache for later use, via
doOnSuccess()
The ViewModel
The Repository API is fairly clean, isolating the caching and data loading and stuff
behind a reactive response. However, there is one hiccup: each call to getWords()
results in a new Single. This is somewhat of a headache for the UI, as we would
need a fresh subscription — via a fresh LiveData – whenever the user asks for a new
set of words, or changes the word count, or opens a new word list. That is on top of
having to manage the subscriptions across lifecycle events.
What would be nice is if the UI could have a single Observable, on which all the
words would come in, regardless of the trigger (including getting a set of words on
first launch). We would still have to deal with lifecycle events, but we have LiveData
for that.
So, this app has a ViewModel implementation — named PassphraseViewModel – that
offers a LiveData of the incoming words that the UI can use, in addition to tracking
our current word source and word count across configuration changes.
THE REPOSITORY PATTERN
239

Managing the Observables
Getting words to the UI is handled by a words() method, that returns a LiveData for
random word list subsets. That LiveData is in the form of a liveWords field:
LiveData<List<String>> words() {
return
return(liveWords);
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseViewModel.java)
As noted, though, we will get multiple Single instances from the Repository, one
for each getWords() call that we need. If we want the UI to use this stable LiveData
instance, we need a way to feed different Single results to it over time.
The approach that PassphraseViewModel takes is to hold onto a BehaviorSubject,
called wordsSubject:
private
private final
final BehaviorSubject<List<String>> wordsSubject;
private
private final
final LiveData<List<String>> liveWords;
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseViewModel.java)
…and say that it is what our LiveData wraps:
wordsSubject=BehaviorSubject.create();
liveWords=LiveDataReactiveStreams
.fromPublisher(wordsSubject.toFlowable(BackpressureStrategy.LATEST));
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseViewModel.java)
In RxJava, a BehaviorSubject is both an Observable and an Observer. It can be the
source of events (Observable) and be a sink of events Observer. In this case, we will
use it to consolidate all of the events from all of the different Single instances that
we get from the Repository.
As was noted back in the chapter on RxJava and lifecycles,
LiveDataReactiveStreams can convert a Publisher to a LiveData. The standard
RxJava Publisher implementation is Flowable, and Room can return a Flowable
from a @Query method. However, in this case, we are not using Room, and our
Repository is publishing a Single, not a Flowable. However, RxJava offers a
toFlowable() method on Observable, Single, and other types, to convert them into
Flowable instances. toFlowable(), though, takes a BackpressureStrategy
parameter. “Backpressure” is a fancy way of saying “what happens when we get more
THE REPOSITORY PATTERN
240

input than we can stream to the output?” — BackpressureStrategy.LATEST says
“hold onto the latest event and provide that to the subscriber when it is ready”. In
our case, backpressure is unlikely to be an issue, as we only generate new events
based on discrete requests from the user (e.g., clicking an action bar item).
Repository Integration
The PassphraseViewModel constructor takes, among other things, a Context as a
parameter, to use to retrieve the Repository singleton, held in a field named repo.
We also have source and count fields to hold how many words we should retrieve
and where we should retrieve them from, initialized to some starter values:
private
private final
final Repository repo;
private
private Uri source=Uri.parse("file:///android_asset/eff_short_wordlist_2_0.txt");
private
private int count=6;
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseViewModel.java)
The PassphraseViewModel also has a refresh() method. Partly, this is used literally
for a “refresh” operation, to load a fresh batch of words given the current count and
source values. In fact, everything else that needs to trigger loading words routes
through refresh(). refresh() calls the getWords() method that we have on
Repository and forwards the events to the wordsSubject by using a Java 8 method
reference to tie the subscribe() of the Single to onNext() of the wordsSubject:
void refresh() {
repo.getWords(source, count).subscribe(wordsSubject::onNext);
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseViewModel.java)
The net effect is that every time refresh() is called, the liveWords eventually will
deliver a new random subset of the current word list, by means of the wordsSubject.
Saving State
We need to get the source and the count from the UI, for use in refresh(). And,
along the way, we can hold onto that information across configuration changes,
since this is a ViewModel. Plus, we can also have the PassphraseViewModel store this
information in the saved instance state Bundle, so the view-model is the single
“source of truth” for the current source and count.
THE REPOSITORY PATTERN
241

To that end, the constructor on PassphraseViewModel takes a saved instance state
Bundle as input and — if the Bundle is not null — populates the source and count
from its contents:
PassphraseViewModel(Context ctxt, Bundle state) {
repo=Repository.get(ctxt);
if
if (state!=null
null) {
source=state.getParcelable(STATE_SOURCE);
count=state.getInt(STATE_COUNT, 6);
}
wordsSubject=BehaviorSubject.create();
liveWords=LiveDataReactiveStreams
.fromPublisher(wordsSubject.toFlowable(BackpressureStrategy.LATEST));
refresh();
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseViewModel.java)
The constructor also calls refresh(), to queue up the first random set of words, so
we can populate the UI as quickly as possible.
PassphraseViewModel then has its own onSaveInstanceState(), where it fills in the
state Bundle using the same keys that its constructor uses to read the values out:
void onSaveInstanceState(Bundle state) {
state.putParcelable(STATE_SOURCE, source);
state.putInt(STATE_COUNT, count);
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseViewModel.java)
(hat tip to Danny Preussler for the idea of centralizing both view-model and saved
instance state logic in the ViewModel)
The Factory
However, by default, the Architecture Components’ ViewModel system has no way to
create an instance of PassphraseViewModel. After all, it has no idea what this Bundle
is.
To help with that, PassphraseViewModel has a Factory nested class that implements
ViewModelProvider.Factory. This provides the “glue” for tying the Architecture
THE REPOSITORY PATTERN
242

Components to PassphraseViewModel, by creating an instance of
PassphraseViewModel as needed:
static
static class
class Factory
Factory implements
implements ViewModelProvider.Factory {
private
private final
final Bundle state;
private
private final
final Context ctxt;
Factory(Context ctxt, Bundle state) {
this
this.ctxt=ctxt.getApplicationContext();
this
this.state=state;
}
@NonNull
@Override
public
public <T extends
extends ViewModel> T create(@NonNull Class<T> modelClass) {
return
return((T)new
new PassphraseViewModel(ctxt, state));
}
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseViewModel.java)
When we create an instance of the Factory, we need to provide a Context (such as
the Activity hosting our UI) and the incoming saved instance state Bundle, for the
Factory to pass along to the newly-created instance.
The Fragment
The launcher (and only) activity — MainActivity — simply sets up a
PassphraseFragment:
package
package com.commonsware.android.diceware;
import
import android.os.Bundle
android.os.Bundle;
import
import android.support.v4.app.FragmentActivity
android.support.v4.app.FragmentActivity;
public
public class
class MainActivity
MainActivity extends
extends FragmentActivity {
@Override
protected
protected void onCreate(Bundle state) {
super
super.onCreate(state);
if
if (getSupportFragmentManager().findFragmentById(android.R.id.content) == null
null) {
getSupportFragmentManager().beginTransaction()
.add(android.R.id.content,
new
new PassphraseFragment()).commit();
}
}
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/MainActivity.java)
THE REPOSITORY PATTERN
243

All of the real UI/UX work resides in the fragment.
The UI
The UI for PassphraseFragment consists of a TextView for the words, wrapped in a
CardView to make it a bit more aesthetically interesting:
<FrameLayout
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:padding="8dp">>
<android.support.v7.widget.CardView
<android.support.v7.widget.CardView
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_gravity="center"
android:padding="8dp">>
<TextView
<TextView
android:id="@+id/passphrase"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:textSize="20sp"
android:typeface="monospace" />
/>
</android.support.v7.widget.CardView>
</android.support.v7.widget.CardView>
</FrameLayout>
</FrameLayout>
(from Diceware/Repository/app/src/main/res/layout/activity_main.xml)
The core of our UI setup is in onViewCreated():
@Override
public
public void onViewCreated(View view, Bundle state) {
super
super.onViewCreated(view, state);
passphrase=view.findViewById(R.id.passphrase);
viewModel=ViewModelProviders
.of(this
this, new
new PassphraseViewModel.Factory(getActivity(), state))
.get(PassphraseViewModel.class);
updateMenu();
viewModel.words().observe(this
this,
words -> passphrase.setText(TextUtils.join(" ", words)));
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseFragment.java)
THE REPOSITORY PATTERN
244

Here, we:
• Retrieve the passphrase TextView to hold our random word list subset
• Obtain our PassphraseViewModel, by way of ViewModelProviders and our
Factory
• Update our menu, described in the next section
•
observe() our LiveData, taking the list of words and populating the
TextView, joining those words with spaces
For a newly-created PassphraseViewModel, the constructor’s call to refresh() will
give us some words to show automatically. On a configuration change, our LiveData
will hand back our last set of words automatically. Plus, the LiveData handles the
rest of the lifecycle work for us.
The Menu
The fragment also has a menu, with a drop-down for the word count, a “refresh”
item to get a fresh random subset of words, and an “open” item to choose a word list
document:
<?xml version="1.0" encoding="utf-8"?>
<menu
<menu xmlns:android="http://schemas.android.com/apk/res/android">>
<item
<item
android:id="@+id/word_count"
android:showAsAction="ifRoom"
android:title="@string/menu_words">>
<menu>
<menu>
<group
<group android:checkableBehavior="single">>
<item
<item
android:id="@+id/word_count_4"
android:title="4" />
/>
<item
<item
android:id="@+id/word_count_5"
android:title="5" />
/>
<item
<item
android:id="@+id/word_count_6"
android:checked="true"
android:title="6" />
/>
<item
<item
android:id="@+id/word_count_7"
android:title="7" />
/>
<item
<item
android:id="@+id/word_count_8"
android:title="8" />
/>
THE REPOSITORY PATTERN
245

<item
<item
android:id="@+id/word_count_9"
android:title="9" />
/>
<item
<item
android:id="@+id/word_count_10"
android:title="10" />
/>
</group>
</group>
</menu>
</menu>
</item>
</item>
<item
<item
android:id="@+id/refresh"
android:icon="@drawable/ic_cached_white_24dp"
android:showAsAction="ifRoom"
android:title="@string/menu_refresh" />
/>
<item
<item
android:id="@+id/open"
android:enabled="false"
android:showAsAction="never"
android:title="@string/open" />
/>
</menu>
</menu>
(from Diceware/Repository/app/src/main/res/menu/actions.xml)
The “refresh” item ties directly to the refresh() method on the view-model, while
the word count items update their checked state and route to a setCount() method
on the view-model:
@Override
public
public boolean onOptionsItemSelected(MenuItem item) {
switch
switch(item.getItemId()) {
case
case R.id.open:
open();
return
return(true
true);
case
case R.id.refresh:
viewModel.refresh();
return
return(true
true);
case
case R.id.word_count_4:
case
case R.id.word_count_5:
case
case R.id.word_count_6:
case
case R.id.word_count_7:
case
case R.id.word_count_8:
case
case R.id.word_count_9:
case
case R.id.word_count_10:
item.setChecked(!item.isChecked());
THE REPOSITORY PATTERN
246

viewModel.setCount(Integer.parseInt(item.getTitle().toString()));
return
return(true
true);
}
return
return(super
super.onOptionsItemSelected(item));
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseFragment.java)
The “open” item routes to an open() method, which brings up an
ACTION_OPEN_DOCUMENT activity for the user to choose a word list:
private
private void open() {
Intent i=
new
new Intent()
.setType("text/plain")
.setAction(Intent.ACTION_OPEN_DOCUMENT)
.addCategory(Intent.CATEGORY_OPENABLE);
startActivityForResult(i, REQUEST_OPEN);
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseFragment.java)
If we get a document, that is passed over to a setSource() method on the view-
model:
@Override
public
public void onActivityResult(int requestCode, int resultCode,
Intent resultData) {
if
if (resultCode==Activity.RESULT_OK) {
viewModel.setSource(resultData.getData());
}
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseFragment.java)
The setCount() and setSource() methods on PassphraseViewModel not only
update their respective fields, but they also call refresh(), to deliver a fresh set of
words based on the new count or new source of words:
void setSource(Uri source) {
this
this.source=source;
refresh();
}
THE REPOSITORY PATTERN
247

void setCount(int count) {
this
this.count=count;
refresh();
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseViewModel.java)
As a result, when the user chooses any of those action bar items, if there is an actual
state change (e.g., a new count), we get a new roster of words.
We also need to set the checked state of the word count items based on the count,
either from the default value or from our state (view-model or saved instance state).
Since we do not know whether the menu or the view-model will be set up first, we
call a central updateMenu() method from a couple of places to check the right action
bar item:
private
private void updateMenu() {
if
if (menu!=null
null && viewModel!=null
null) {
MenuItem checkable=menu.findItem(WORD_COUNT_MENU_IDS[viewModel.getCount()-4]);
if
if (checkable!=null
null) {
checkable.setChecked(true
true);
}
}
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseFragment.java)
And, our fragment’s onSaveInstanceState() forwards that Bundle to the
PassphraseViewModel for saving the state:
@Override
public
public void onSaveInstanceState(Bundle outState) {
super
super.onSaveInstanceState(outState);
viewModel.onSaveInstanceState(outState);
}
(from Diceware/Repository/app/src/main/java/com/commonsware/android/diceware/PassphraseFragment.java)
The Event Flow
When our fragment is created, we create our view-model. It, in turn, asks the
repository to give us our initial random subset of words, triggering some background
file I/O to read in the initial word list. When that is done, the random words wind
their way to the fragment, which pops them into the UI.
THE REPOSITORY PATTERN
248

When the user requests different words — a different count, a different source, or
just words that maybe they might like better — the fragment updates the view-
model, which in turn asks the repository for words for the now-current word count
and word source. Eventually, another random subset of words make its way to
fragment, which displays them using the same code as before.
On a configuration change, our newly-recreated fragment winds up connecting to
the same view-model as before, courtesy of the Architecture Components’
ViewModel system. Our LiveData gives us back the words we were showing in the
previous fragment, so we can show them again.
So, each layer has its role in the event flow:
• The fragment manages the UI, including the menu
• The repository manages the data loading and random-subset work
• The view-model mediates the communications between them, folding all of
the disparate Single objects from the repository into a single stream of
events for the fragment to consume
And, of course, the user gets a reasonably-secure passphrase to use for some app or
site that needs it:
THE REPOSITORY PATTERN
249

Figure 3: Diceware Demo, Showing Random Words
THE REPOSITORY PATTERN
250

Introducing Model-View-Intent
MVC. MVP. MVVM. MVI. These abbreviations get tossed around a lot in app
development discussions, and increasingly in Android app development discussions.
Those using these abbreviations often think that:
• Everybody knows what they mean, and
• There is a single universal definition for each of those abbreviations, one
that everybody holds
In reality, these MV* abbreviations are well-known in some circles and unknown in
others. And, even among people who think the know these abbreviations, there is a
fair bit of disagreement about what the abbreviations mean, particularly when it
comes time to writing actual code. In this chapter, we will explore what these
abbreviations mean, with a particular emphasis on the last of the four: MVI, which
stands for Model-View-Intent. And, as an illustration of the problems inherent in
applying these abbreviations:
• The “model” in Model-View-Intent may or may not be what you might think
of as the model
• The “view” in Model-View-Intent is unlikely to be a View
• The “intent” in Model-View-Intent is not going to be an Intent
GUI Architectures
MVC, MVP, MVVM, MVI, and others are GUI architecture patterns. They describe
different ways of organizing your code to update your UI based upon user input and
other changes in data, such as the results of server requests or database operations.
The abbreviations, as you might expect, abbreviate short phrases that are the formal
names of these patterns:
251

• MVC = Model-View-Controller
• MVP = Model-View-Presenter
• MVVM = Model-View-Viewmodel
• MVI = Model-View-Intent
In these, “model” represents some data, and “view” represents some way of
visualizing that data. The trailing portion of the GUI architecture name indicates
another component that is involved in taking model changes and updating the view,
and taking user input (e.g., button clicks, text entry) and updating the models…
which in turn updates views.
Some people may find it surprising that there are so many different organization
patterns for this work, and that developers spend time debating the merits of one
pattern over another. Debates over GUI architectures are reminiscent of debates over
text editors (emacs versus vi), in that they tend to be debates over minutiae and
ignore other options (e.g., Sublime Edit 3).
Why People Worry About GUI Architectures
Those participating in these debates over GUI architectures will tend to unite
against architecture-agnostics, hammering home their belief that you should have
some formal GUI architecture in your app — the debate merely is over which one.
There are some reasons why formal GUI architecture adherents are strident in their
beliefs that such architectures are universally beneficial.
Avoiding Known Problems
GUI development can be tricky. Android GUI development can be trickier than
others, with things like configuration changes, tasks, and the like adding lots of edge
and corner cases to worry about.
If a popular GUI architecture has been applied to Android — and if those results
have been published in a blog post, conference presentation, etc. — part of the work
will be to address those tricky bits. Some of the points of contention in the GUI
architecture debates are how they handle things like configuration changes, where
architectures that handle those things gracefully are considered to be better than
those that ignore the problem.
This is not to say that using one of these formal GUI architectures is a requirement
to address these problem areas in Android. However, if you implement an Android
INTRODUCING MODEL-VIEW-INTENT
252

version of one of these GUI architectures, there is a decent chance that these
problem areas will be covered as part of that work.
Consistency Between Team Members
Many Android apps are developed by teams, rather than by solo developers. Team
members may switch between working on different parts of the code base at
different times, and so while certain areas may have a specific “owner”, that owner
may not be the only one to work in those areas. For example, if a critical bug is
discovered while an “owner” is away from the office, somebody else may need to step
in and fix the bug, so that users are not harmed any longer than is necessary.
Having team members be able to work in any portion of an app’s code base is the
reason for overall standards, such as:
• Tabs versus spaces for indents
• Line lengths
• Naming conventions (as opposed to NamingConventions or
namingConventions or naming_conventions)
• And so on
At a higher level, teams may elect to standardize on a GUI architecture so that
different developers writing different portions of a UI (e.g., different activities) will
create similar code. It will be easier for others to adopt and modify that code if it is
similar to other areas of the code that was seen previously.
Consistency Over Time
Teams are rarely stable for long. Team members come and go, within the overall
organization or departing for greener pastures elsewhere. As such, “onboarding” of
team members is important, and having a standardized approach to UI
construction, in the form of a specific GUI architecture, can help here.
However, even solo developers are victims of time. Code that might make sense
today may make less sense in a year and no sense at all in three years. Developer
experience and expertise changes, even when the code does not. Having consistent
code within an app reduces this problem, in part by making it more likely that the
developer will have seen similar code recently. And, adopting a specific GUI
architecture means that all the world’s prose on that GUI architecture act as
documentation for the project that the developer does not have to write.
INTRODUCING MODEL-VIEW-INTENT
253

Why Others Ignore GUI Architectures
It is quite likely that the vast majority of Android apps do not use any of these GUI
architectures.
In some cases, this is unintentional, insofar as the developer(s) of the app do not
know about such architectures or have not considered them. Not everybody has
equal education and experience, and that will be reflected in the tactical and
strategic development decisions that they make or participate in making.
However, in some cases, there are clear reasons why a classic MV* GUI architecture
is unsuitable.
Atypical Apps
These GUI architectures have been refined for “typical” app structures:
• You have some data (local or remote)
• You want to display that data to the user (in collections or for individual
items)
• Often, the user can manipulate that data, adding to it, modifying it, or
perhaps deleting it
• Sometimes, the data can change on the fly from outside of the app (e.g.,
push messages, other forms of server-centered updates)
• You want those data changes to flow back to the data source, plus update the
UI of the app as needed
Lots of apps fit that general description. At the same time, lots of apps do not fit
that general description, such as:
• Many types of games
• System-integrated tools, like soft keyboards and VPNs
• Musical instrument simulators
• Terminal emulators
• Camera apps
• Calculators
• And so on
Some of these will have their own architecture patterns, perhaps tied to libraries or
frameworks. Game development, for example, has its own approaches, often
INTRODUCING MODEL-VIEW-INTENT
254

embodied in toolkits like Unity3D. Those approaches may not resemble the MV*
architectures that you might use in, say, a social network client.
It is up to you to decide how well these sorts of GUI architectures fit your particular
type of app.
YAGNI and Overhead
The bigger the app, the more likely it is that you will gain benefit from a formal GUI
architecture. Such apps are more likely to have more developers and be used for
more time, where a formal GUI architecture can yield benefits.
Conversely, the smaller the app, the less likely it is that a formal GUI architecture is
necessarily worth it. Or, as the saying goes, “you aren’t going to need it” (YAGNI).
Most of the sample apps in this book, like the sample app from The Busy Coder’s
Guide to Android Development, skip the formalities. That is because they are
samples of how to use particular APIs and usually have little code beyond that.
A well-architected app is likely to have more code than an equivalent app that “just
gets the job done”. The next chapter will profile a simple checklist-style “to-do” app
built using the MVI architecture. As you will see, the architecture itself dictates that
many more classes be created, above and beyond what might be needed for the core
functionality.
No Obvious User Benefit
The counterpart to this issue is that the user rarely, if ever, benefits directly from the
use of a formal GUI architecture. Developers may benefit, and their organization
(where relevant) may benefit. However, the user is not necessarily going to see
anything different. A note-taking app, or a chat client, or a video player, should look
the same to the user whether the developer(s) used MVC, MVP, MVVM, MVI, some
other GUI architecture… or no specific GUI architecture at all.
It is entirely possible that bugs will exist in an informally-developed app that would
not exist had the developers chosen and implemented a formal GUI architecture.
However, there is no guarantee that bugs will exist in an informally-developed app.
Similarly, there is no guarantee that using an MV* architecture will eliminate all of
your bugs by magic. A development team that doesn’t pay much attention to GUI
architecture — instead choosing to invest that time in an awesome test suite – may
INTRODUCING MODEL-VIEW-INTENT
255

have a better app in the end than a team that focused heavily on the architecture
and did a sub-par job at testing.
Choosing a GUI architecture does not give the users any additional features. There
are no new marketing buzzwords to tout. The media will not praise the app for its
adherence to some GUI architecture. If management thinks that investing in a GUI
architecture is slowing down “work that matters”, management might steer
developers towards other efforts and away from a formal architecture. Frequently,
decisions made on this basis turn out to be bad ones… but management is free to
make those decisions.
No Consistency In Definitions
Compounding that latter problem is that it may take a while to figure out how to
implement a GUI architecture, as they are very ill-defined. We toss around terms
like “model” and “view” without clear definitions, particularly with respect to
concrete scenarios and Android apps. As a result, not only does the development
team need to debate which architecture to use, but also what that architecture really
means in practice.
A Rough Comparison of GUI Architectures
For the purposes of this book, the primary differences between the major GUI
architectures is how data and control flow from the model data and the visual
representation of that model data (the view).
The simplest, in many respects, is Model-View-Presenter:
INTRODUCING MODEL-VIEW-INTENT
256

Figure 4: Model-View-Presenter
We have a UI, we have data, and we have glue code — in the form of a “presenter” —
that ties the two together. The presenter is responsible for:
• Sinking events raised by the UI, such as form submissions, and using that
information to update the stored representation of that data (the model),
applying relevant business rules along the way
• Taking updates from the model — originating from this presenter, another
presenter, asynchronous changes from a remote server, etc. — and updating
its associated visual representation (the view)
It’s nice and straightforward. On Android, things get a bit interesting with
configuration changes, so while early Android apps might consider the activity or
fragment to be the presenter, nowadays they are considered to be part of the view
(along with the widgets). The presenter is a separate object, one that can be
(carefully) reused across configuration changes, as a stable platform as our activities
and fragments come and go.
Ironically, what today is called Model-View-Presenter originated as Model-View-
Controller. Long-time MVC fans — those who worked on Smalltalk development in
1993, for example — need to deal with this name change. Nowadays, MVC is a
slightly different approach than MVP:
INTRODUCING MODEL-VIEW-INTENT
257

Figure 5: Model-View-Controller
The principal difference is that now data changes from the model flow directly to
the view, bypassing any intermediary. In Android terms, if the model is publishing
RxJava streams, for example, the view is the subscriber of those streams, whereas in
MVP, the presenter would be the subscriber.
The benefit of this approach is the unidirectional data flow. A presenter serves as a
common junction for data flows, which is OK in simple scenarios, but can get messy
in larger use cases. In particular, the presenter needs to keep track not only of the
data, but who knows about that particular piece of data:
• Is this some interim POJO, updated from the view, that needs to get reflected
in the model?
• Is this some interim POJO, updated from the model, that needs to get
reflected in the view?
If you use the same POJO class for each — and particularly if you are applying
caching to hold onto that data in the presenter — there is a risk of bugs causing the
data to stop flowing. For example, you get a revised POJO from the model, you
update the presenter’s cache… and fail to do anything to update the view. Or, you get
data from the view, prepare changes for the model, then the model gives you new
data from some other source, and you need to somehow merge this stuff together.
A unidirectional data flow, particularly with immutable objects, makes this simpler.
Now, each component is responsible for doing some work and passing the results
along to a single destination, rather than having to remember which destination
needs the results of the work.
INTRODUCING MODEL-VIEW-INTENT
258

Microsoft led the charge to convert Model-View-Presenter into Model-View-
ViewModel (MVVM). From a diagram standpoint, MVVM looks strangely familiar:
Figure 6: Model-View-ViewModel
In fact, typically, a MVVM app still has something called a presenter, which is
responsible for preparing the view-model and connecting it with the view. MVVM
implementations tend to emphasize two-way data binding, so the “business logic”
for updating the view-model lies in a declarative UI (e.g., Android’s layout resources,
Microsoft’s XAML). For major operations, such as form submission, the presenter
takes the view-model and uses that information to update the “real” model.
This helps to clean up the communications somewhat. The presenter is mapping
from the model to the view-model, applying appropriate changes along the way,
such as:
• Data minimization: only exposing data in the view-model that the view
needs
• Data transformation: taking the data in the form that the model stores it and
changing it to something more amenable to the UI, such as converting
currencies, converting time formats (e.g., Unix epoch times to richer date
objects), and so on
INTRODUCING MODEL-VIEW-INTENT
259

The Basics of Model-View-Intent
While you have been working in Android, Web development has continued its own
innovations. Redux has popularized a new approach to Web app development, and
Redux in turn has led to interest in Model-View-Intent (MVI) as a GUI architecture.
However, as with the rest of the major GUI architectures, MVI is defined fairly
loosely. However, at its core, it is a return to the unidirectional data flow that MVC
offered… though with few more parts:
Figure 7: Model-View-Intent
Things start off a bit like MVC, where the view lets the controller know about
actions that the user has taken, such as submitting a form or requesting a search.
And, as with MVC, the controller is responsible for updating the model.
However, at that point, things start to differ, introducing a couple of new concepts:
the view state and the reducer.
What’s a View State?
The view state is somewhat reminiscent of the view-model in MVVM. It is the data
necessary to render the view, by populating widgets and so forth.
The key behind many MVI implementations is that the view state is immutable. The
view is handed a view state and needs to update the UI to reflect that new state. In
many cases, that is simply filling in all of the widgets. In a few cases, that might get
more elaborate, such as using DiffUtil to update the contents of a RecyclerView.
INTRODUCING MODEL-VIEW-INTENT
260

The Redux folks would phrase this something like “the view is a function applied to
the state”. The view layer does not care why the view state changed, just that it
changed, and so it just updates the UI to match that state.
What’s a Reducer?
The view state may be very complex, as it needs to be as complex as the UI that is
being rendered. A single activity or fragment that has multiple tabs in a ViewPager
might have several lists of material to go into those tabs, plus perhaps some
additional data, all as part of the view state.
However, any individual action by the user is likely to only change a little bit of that
view state. The user might mark some list item as a favorite, or add a new item, or
swipe away an existing item. Most of the view state is stable.
In MVI, the controller is not directly responsible for maintaining that view state. It
simply consumes actions from the view, updates the model, and publishes some sort
of result to indicate that the work has been completed. Results do not have to map
1:1 to actions, though in many cases they will.
The “reducer” — whose name stems from the MapReduce model, presumably — is
responsible for taking the result and crafting a new view state that reflects that
incremental change in the data needed by the view. So, for example, if the user
marks an item in the list as a favorite:
• The view emits an “mark-as-favorite” action
• The controller tells the model to persist that change and emits a “marked-as-
favorite” result
• The reducer uses to update the in-memory representation of the list data to
show that the favorite has been marked
The view does not update itself based upon the user’s request. Instead, it emits the
action, then renders the updated view state once it arrives.
Where Does the “Intent” Thing Show Up?
In the diagram shown above, there is a split between a result and a view state. In
some MVI implementations, there is also a split between an “intent” and an “action”.
The intent is what the view publishes, but what the controller consumes is an
action. There is a separate component that converts intents into actions.
INTRODUCING MODEL-VIEW-INTENT
261

Figure 8: Model-View-Intent, With Actual Intents
Part of the rationale here is having a strictly layered separation of concerns:
• Intents and view state on the view side of the interpretor and reducer
• Actions and results on the controller side of the interpretor and reducer
For some UIs, it may be that the distinction between intents and actions may be
fruitful over time. For example, perhaps you have a UI with a search option. On
mobile devices, search is triggered by the typical sort of magnifying-glass icon in a
toolbar. When the search is submitted, the UI wants to get a view state with search
results. However, on Chromebooks or other devices with physical keyboards, you
want to offer a direct typing approach, where the user can just start typing a search
expression, and that automatically displays the SearchView, skipping the toolbar
icon. The result is the same: conduct a search. But, perhaps you want to distinguish
those as separate intents, with an eye towards perhaps offering different behaviors
for searches triggered by each mechanism. However, the controller does not care
whether the search was triggered by a toolbar icon click, just typing on the
keyboard, selecting some saved search in a list or whatever. The controller just needs
to know that a search is required. In this case, the view can publish different intents
based upon how the search was requested, but the interpretor can normalize those
into a smaller set of actions.
In practice, though, this approach can wind up with a lot of code duplication, as you
mind-numbingly convert intents into actions on a 1:1 basis. For the sample MVI app
profiled in the next chapter, the author originally wrote the app with intent/action
separation… then got rid of the intents. If you feel that the intent/action separation
is worthwhile, certainly use it. In the author’s opinion, for many apps, the YAGNI
principle applies: you aren’t going to need it.
INTRODUCING MODEL-VIEW-INTENT
262

Additional MVI Resources
Here are some additional resources on MVI in Android that you may find useful:
• Jake Wharton’s 2017 Devoxx US presentation – while Jake does not mention
MVI, the architecture that he demonstrates is the Redux/MVI approach
• Yousuf Haque’s droidcon NYC 2017 presentation on MVI
• Benoît Quenaudon’s droidcon NYC 2017 presentation on MVI, and his
associated sample app and blog post
INTRODUCING MODEL-VIEW-INTENT
263


A Deep Dive Into MVI
The preceding chapter introduced Model-View-Intent (MVI) as a GUI architecture
pattern… without any code.
This chapter will look at a concrete implementation of MVI, so you can see how it
works. Note, though, that all of these GUI architectures are fairly malleable, and so
this chapter’s approach may differ somewhat from other MVI implementations.
What the Sample App Does
A popular app category is a to-do list. These track outstanding tasks that need to be
done, usually with some sort of checkbox or other indicator to denote which ones
have been completed. Some offer due dates, recurring tasks, or other features to
make it easier for you to set up a roster of tasks that match your needs. Some
synchronize with a Web service, so that you can view your to-do list in multiple
places, such as both on your phone and from a desktop Web browser.
Google has published a long list of sample apps that use a to-do list as a way of
exploring various GUI architectures. The ToDo/MVI sample project is not a fork of
those, but rather a “cleanroom” implementation of a to-do list with similar
functionality. That functionality is tied into three fragments: the to-do list roster,
the viewer, and the editor.
The Roster
When initially launched, the app will show a roster of the recorded to-do items, if
there are any. Hence, on the first run, it will show just an “empty view”, prompting
the user to click the “add” action bar item to add a new item:
265

Figure 9: ToDo MVI App, As Initially Launched, with No Items
Once there are some items in the database, the roster will show those items, in
alphabetical order by title, with a checkbox indicating whether or not they have
been completed:
A DEEP DIVE INTO MVI
266

Figure 10: ToDo MVI App, Showing Two Items
From here, the user can tap the checkbox to quickly mark an item as completed (or
un-mark it if needed). A filter drop-down allows the user to toggle the list from
showing all items, only those marked as completed, or only those still outstanding
(i.e., not yet checked as completed):
A DEEP DIVE INTO MVI
267

Figure 11: ToDo MVI App, Showing Filter Options
Long-pressing on an item switches the list into multiple-selection mode, where the
user can then tap on items to build up a selection:
A DEEP DIVE INTO MVI
268

Figure 12: ToDo MVI App, Showing Multi-Select Mode with Two Selected Items
The “trash can” toolbar button will allow the user to delete the selected items, after
confirmation:
A DEEP DIVE INTO MVI
269

Figure 13: ToDo MVI App, Showing Delete Confirmation Snackbar
On a smaller-screen device, such as a phone, the roster will fill the screen. However,
on larger-screen devices, the activity adopts the master-detail pattern and shows the
viewer or editor fragment side-by-side with the roster:
A DEEP DIVE INTO MVI
270

Figure 14: ToDo MVI App, Showing Master-Detail UI
The Viewer
A simple tap on an item in the roster brings up the viewer fragment, either
alongside the roster on a larger screen or on its own on a smaller screen:
A DEEP DIVE INTO MVI
271

Figure 15: ToDo MVI App, Showing a Completed Item
This just shows additional information about the item, including any notes the user
entered to provide more detail than the simple description that gets shown in the
roster. The checkmark icon will appear for completed items.
From here, the user can edit this item (via the “pencil” icon). The user can also swipe
left and right to traverse the roster of items — this is particularly useful on a phone,
to avoid the “ping-pong” effect of having to navigate back to the roster fragment just
to view details of the next item.
The Editor
The editor is a simple form, either to define a new to-do item or edit an existing one.
If the user taps on the “add” action bar item from the roster, the editor will appear
blank, and submitting the form will create a new to-do item. If the user taps on the
“edit” (pencil) action bar item from the viewer, the editor will have the existing
item’s data, which can be altered and saved:
A DEEP DIVE INTO MVI
272

Figure 16: ToDo MVI App, Editing a Completed Item
Clicking the “save” toolbar button will either add the new item or edit the item that
the user requested to edit. For an edit, the “delete” toolbar button will be available
and will allow the user to delete this specific item, after confirmation.
MVI and the Sample App
The sample app uses the simplified MVI approach outlined in the preceding
chapter, skipping the intent/action separation and just having the view emit actions:
A DEEP DIVE INTO MVI
273

Figure 17: Model-View-Intent, As Used In This App
The view consists of our three fragments, as they each operate off of the same state:
the roster of to-do items.
The model is made up of two parts:
• The to-do items themselves, stored in a Room-managed database, fronted by
a repository, and converted into model objects used as part of our view state
• The filter mode, which we want to persist across runs of the app, stored in a
SharedPreferences fronted by another repository
We also have actions, a controller, results, and a reducer as well, to mirror the MVI
structure. Though, as you will see, the reducer is named something other than
Reducer.
The Model
We need some in-memory representation of a to-do item. That comes in the form of
a ToDoModel POJO class.
In addition to a unique ID, there are four pieces of additional data that we track
about each to-do item in ToDoModel:
• The description, which is the text that the user sees in the roster
• Some notes, in case there are additional instructions that the user wants to
track for this to-do item
• Whether or not this item is completed, in the form of a simple boolean
• The date and time on which this to-do item was created
A DEEP DIVE INTO MVI
274

We could track more information — last-updated timestamp, revision history,
categories, etc. — but we are trying to keep this relatively simple.
ToDoModel, like the actions, uses AutoValue for immutability. So, our class has the
@AutoValue annotation and abstract methods for each of the properties that we are
tracking:
@AutoValue
public
public abstract
abstract class
class ToDoModel
ToDoModel {
public
public abstract
abstract String id();
public
public abstract
abstract boolean isCompleted();
public
public abstract
abstract String description();
@Nullable public
public abstract
abstract String notes();
public
public abstract
abstract Calendar createdOn();
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoModel.java)
The notes() method is annotated with @Nullable, so AutoValue will allow null for
that property. All other properties are required.
We are using the builder pattern, so we have an @AutoValue.Builder-annotated
static class named Builder, with corresponding setter methods for the properties,
plus build() to create a ToDoModel instance from the Builder:
@AutoValue.Builder
public
public abstract
abstract static
static class
class Builder
Builder {
abstract
abstract Builder id(String id);
public
public abstract
abstract Builder isCompleted(boolean isCompleted);
public
public abstract
abstract Builder description(String desc);
public
public abstract
abstract Builder notes(String notes);
abstract
abstract Builder createdOn(Calendar date);
public
public abstract
abstract ToDoModel build();
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoModel.java)
We also have three methods for getting Builder instances:
•
builder() is a static method that just returns an instance of the
AutoValue-generated Builder implementation
•
creator() is a static method that takes the builder() and fills in some
default information (a generated ID, the current timestamp, and false for
isCompleted())
•
toBuilder() is an instance method that takes a builder() and fills in all of
the current data
A DEEP DIVE INTO MVI
275

static
static Builder builder() {
return
return(new
new AutoValue_ToDoModel.Builder());
}
public
public static
static Builder creator() {
return
return(builder()
.isCompleted(false
false)
.id(UUID.randomUUID().toString())
.createdOn(Calendar.getInstance()));
}
public
public Builder toBuilder() {
return
return(builder()
.id(id())
.isCompleted(isCompleted())
.description(description())
.notes(notes())
.createdOn(createdOn()));
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoModel.java)
So, creating a new ToDoModel instance is a matter of calling creator(), then
whatever setters are necessary, then build() to create the instance. To modify an
existing ToDoModel, call toBuilder() on it, then whatever setters are necessary, then
build() to create the modified instance.
While the sample app uses Room to save the to-do items, ToDoModel is not a Room
@Entity. There is a separate ToDoEntity class that models our database table, and
the app maps between ToDoModel and ToDoEntity instances as needed.
The View State
Our view layer gets its ToDoModel instances from the ViewState. This class
aggregates all of the data necessary to render our three fragments. It includes:
• The list of models to display (as this sample app makes the tremendously
simplifying assumption that the entire set of to-do items can be held in
memory)
• A boolean indicating whether the data has been loaded or not, so we can
distinguish whether an empty list of models means “we have no to-do
items” or “we have not yet loaded the to-do items”
• A list of indices into the model data representing items that are selected,
when the list fragment is in multi-select mode
A DEEP DIVE INTO MVI
276

• The current filter mode, indicating what subset of the list of models should
be rendered
• The “current” model, for situations where our display or edit fragments are
visible, to reflect the model that they are showing
• A Throwable, in case there was some exception coming from the repository
that we need to show to the user
As with ToDoModel, ViewState uses AutoValue to create a more-or-less immutable
object. So, we have abstract methods for each of those properties that we want to
track:
@AutoValue
public
public abstract
abstract class
class ViewState
ViewState {
public
public abstract
abstract boolean isLoaded();
public
public abstract
abstract List<ToDoModel> items();
abstract
abstract Set<Integer> selections();
@Nullable public
public abstract
abstract Throwable cause();
public
public abstract
abstract FilterMode filterMode();
@Nullable public
public abstract
abstract ToDoModel current();
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ViewState.java)
We also have an associated Builder:
@AutoValue.Builder
abstract
abstract static
static class
class Builder
Builder {
abstract
abstract Builder isLoaded(boolean isLoaded);
abstract
abstract Builder items(List<ToDoModel> items);
abstract
abstract Builder selections(Set<Integer> positions);
abstract
abstract Builder cause(Throwable cause);
abstract
abstract Builder filterMode(FilterMode mode);
abstract
abstract Builder current(ToDoModel current);
abstract
abstract ViewState build();
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ViewState.java)
We have a builder() method that returns a Builder with a likely set of default
values (e.g., no current selections):
static
static Builder builder() {
return
return(new
new AutoValue_ViewState.Builder()
.isLoaded(false
false)
.selections(new
new HashSet<>())
.filterMode(FilterMode.ALL));
}
A DEEP DIVE INTO MVI
277

(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ViewState.java)
Beyond that, we have a series of helper methods for common scenarios, such as
empty() for returning a Builder set up with no items:
static
static Builder empty() {
return
return(builder().items(new
new ArrayList<>()));
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ViewState.java)
…and a toBuilder() method, which creates a Builder pre-populated with the
current values from a ViewState, to be able to revise those values and create a fresh
ViewState from the Builder:
private
private Builder toBuilder() {
return
return(builder()
.isLoaded(isLoaded())
.cause(cause())
.items(items())
.selections(selections())
.current(current())
.filterMode(filterMode()));
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ViewState.java)
The View
The MainActivity and its fragments implement the “view” layer of the MVI
architecture. These classes have two primary jobs:
1. Render the view state when it arrives
2. Create actions and get them over to the controller
Of course, this is Android, and so there are other details to be worried about.
Configuration changes are chief among those details.
Right now, we will focus on RosterListFragment, the fragment for displaying the list
of to-do items. Later on, we will look briefly at the other two fragments. Note that
RosterListFragment inherits from an AbstractRosterFragment, as some of its logic
is shared with DisplayFragment.
A DEEP DIVE INTO MVI
278

Incorporating a ViewModel
The fragments use a ViewModel, named RosterViewModel, as the state to be
retained across configuration changes. To that end, MainActivity is a
FragmentActivity and the three fragments each extend from the support libraries’
edition of Fragment. The fragments hold onto the RosterViewModel in a viewModel
field and initialize it in onCreate():
@Override
public
public void onCreate(@Nullable Bundle savedInstanceState) {
super
super.onCreate(savedInstanceState);
viewModel=ViewModelProviders.of(getActivity()).get(RosterViewModel.class);
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/ui/AbstractRosterFragment.java)
Notice that we are passing the activity into of(), not the fragment. As a result, all
three fragments share a common RosterViewModel. For relatively tightly-coupled
fragments, this likely will be a common pattern.
RosterViewModel has two key roles:
1. It holds onto the Controller to be used by the view and forwards actions
from the view to that Controller
2. It serves as the reducer, receiving results from the Controller and
converting them into updated view states, delivering those to the view as
results arrive
Receiving View States
We need to get ViewState instances from the RosterViewModel to the fragments,
when results arrive from the Controller.
To that end, RosterViewModel has a LiveData object, representing a stream of view
states. That is made available to the view layer via a simple stateStream() method:
public
public LiveData<ViewState> stateStream() {
return
return(states);
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/RosterViewModel.java)
A DEEP DIVE INTO MVI
279

Our fragments then use that LiveData to subscribe to the stream and route the
ViewState objects to a render() method:
viewModel.stateStream().observe(this
this, this
this::render);
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/ui/AbstractRosterFragment.java)
Rendering View States
Each of our three fragments has its own render() method, responsible for taking
the data in our ViewState and updating its own bit of the UI to match.
In the case of the RosterListFragment, render() is responsible for populating the
RecyclerView:
@Override
void render(ViewState state) {
if
if (adapter!=null
null) {
if
if (state.cause()==null
null) {
adapter.setState(state);
if
if (state.isLoaded() && state.filteredItems().size()==0) {
getEmptyView().setVisibility(View.VISIBLE);
if
if (state.items().size()>0) {
getEmptyView().setText(R.string.msg_empty_filter);
}
else
else {
getEmptyView().setText(R.string.msg_empty);
}
}
else
else {
getEmptyView().setVisibility(View.GONE);
}
if
if (state.getSelectionCount()==0 && snackbar!=null
null &&
snackbar.isShown()) {
snackbar.dismiss();
}
}
else
else {
Snackbar
.make(getView(), R.string.msg_crash, Snackbar.LENGTH_LONG)
.show();
Log.e(getClass().getSimpleName(), "Exception in obtaining view state",
state.cause());
A DEEP DIVE INTO MVI
280

}
}
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/ui/RosterListFragment.java)
If we have no adapter, then our UI has not been set up just yet, and so we need to
skip this rendering event.
If the ViewState contains a cause(), we show a Snackbar to alert the user to the
problem, plus log the Throwable to LogCat for debugging purposes.
In the more normal case, where everything worked and we have our UI, we:
• Pass the ViewState along to the RosterListAdapter, to update the contents
of the RecyclerView
• Hide, show, and update the prose for the empty view, as appropriate
• If we happen to have some other Snackbar showing (e.g., from a delete
request), dismiss it
The empty view is a bit complicated, because we have three conditions:
1. There are items in the list, in which case we do not want to show the empty
view, so we mark it GONE
2. There are no items in the list, because there are simply no items at all
3. There are items in the list, but the current filter mode that the user has
chosen blocks all of them (e.g., the user chose outstanding items and all
items are completed)
The ViewState has a helper method, filteredItems(), which returns only the
subset of the items() list that apply for the currently-chosen filter:
@Memoized
public
public List<ToDoModel> filteredItems() {
return
return(ToDoModel.filter(items(), filterMode()));
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ViewState.java)
Here, @Memoized means that the ViewState will cache the results of computing this
list, to save time on subsequent calls — this is a feature of AutoValue.
ToDoModel.filter(), in turn, does the actual filtering:
A DEEP DIVE INTO MVI
281

public
public static
static List<ToDoModel> filter(List<ToDoModel> models,
FilterMode filterMode) {
List<ToDoModel> result;
if
if (filterMode==FilterMode.COMPLETED) {
result=new
new ArrayList<>();
for
for (ToDoModel model : models) {
if
if (model.isCompleted()) {
result.add(model);
}
}
}
else
else if (filterMode==FilterMode.OUTSTANDING) {
result=new
new ArrayList<>();
for
for (ToDoModel model : models) {
if
if (!model.isCompleted()) {
result.add(model);
}
}
}
else
else {
result=new
new ArrayList<>(models);
}
return
return(result);
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoModel.java)
The implementation of setState() on RosterListAdapter is responsible for
updating the RecyclerView contents. That is fairly complicated and not particularly
relevant for the discussion of MVI, so we will skip that here, other than to note that
it uses DiffUtil to animate any relevant changes to the visible rows in the list,
comparing the new view state with its predecessor.
The Actions
There are several possible actions that our view layer will be able to publish:
• The user might add a new to-do item
• The user might edit a new to-do item, replacing some of its data with new
values
• The user might delete one or more to-do items
A DEEP DIVE INTO MVI
282

• In the dual-pane master-detail mode, the user might select or unselect items
– while this is not part of a persistent data model, it is information that we
need to retain across configuration changes and therefore forms part of our
view state
• The user might change the filter mode for controlling which set of to-do
items appears in the roster
In addition, we need a “load” action to load our content when the UI first appears.
Some of these actions have associated data. For example, to add a new to-do item,
we need some sort of model object describing the item. Some actions need no
additional data, such as the “load” or “unselect-all” actions.
To that end, we have an Action class. This class is abstract, with concrete
subclasses for each specific action. This way, some of our code can just deal with
actions in general via the Action base type, while the rest of our code can work with
the specific action types where needed. Each concrete class can hold whatever data
that action needs.
The Action class:
• Defines those concrete subclasses, either directly (if the action has no
associated data) or via AutoValue (if the action has data, for immutable
action types)
• Defines helper static methods to create instances of the appropriate Action
concrete type
package
package com.commonsware.android.todo.impl;
import
import com.google.auto.value.AutoValue
com.google.auto.value.AutoValue;
import
import java.util.Collections
java.util.Collections;
import
import java.util.List
java.util.List;
public
public abstract
abstract class
class Action
Action {
public
public static
static Action add(ToDoModel model) {
return
return(new
new AutoValue_Action_Add(model));
}
public
public static
static Action edit(ToDoModel model) {
return
return(new
new AutoValue_Action_Edit(model));
}
public
public static
static Action delete(List<ToDoModel> models) {
A DEEP DIVE INTO MVI
283

return
return(new
new AutoValue_Action_Delete(Collections.unmodifiableList(models)));
}
public
public static
static Action delete(ToDoModel model) {
return
return(delete(Collections.singletonList(model)));
}
public
public static
static Action select(int position) {
return
return(new
new AutoValue_Action_Select(position));
}
public
public static
static Action unselect(int position) {
return
return(new
new AutoValue_Action_Unselect(position));
}
public
public static
static Action unselectAll() {
return
return(new
new UnselectAll());
}
public
public static
static Action show(ToDoModel model) {
return
return(new
new AutoValue_Action_Show(model));
}
public
public static
static Action filter(FilterMode mode) {
return
return(new
new AutoValue_Action_Filter(mode));
}
public
public static
static Action load() {
return
return(new
new Action.Load());
}
@AutoValue
public
public static
static abstract
abstract class
class Add
Add extends
extends Action {
public
public abstract
abstract ToDoModel model();
}
@AutoValue
public
public static
static abstract
abstract class
class Edit
Edit extends
extends Action {
public
public abstract
abstract ToDoModel model();
}
@AutoValue
public
public static
static abstract
abstract class
class Delete
Delete extends
extends Action {
public
public abstract
abstract List<ToDoModel> models();
}
@AutoValue
static
static abstract
abstract class
class Select
Select extends
extends Action {
A DEEP DIVE INTO MVI
284

public
public abstract
abstract int position();
}
@AutoValue
static
static abstract
abstract class
class Unselect
Unselect extends
extends Action {
public
public abstract
abstract int position();
}
static
static class
class UnselectAll
UnselectAll extends
extends Action {
}
@AutoValue
static
static abstract
abstract class
class Show
Show extends
extends Action {
public
public abstract
abstract ToDoModel current();
}
@AutoValue
static
static abstract
abstract class
class Filter
Filter extends
extends Action {
public
public abstract
abstract FilterMode filterMode();
}
public
public static
static class
class Load
Load extends
extends Action {
}
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Action.java)
This looks complicated, but it is just a number of occurrences of the same basic
pattern. For example, for the “add” action we have an Add subclass of Action, set up
via AutoValue:
@AutoValue
public
public static
static abstract
abstract class
class Add
Add extends
extends Action {
public
public abstract
abstract ToDoModel model();
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Action.java)
We also have a static method named add() on Action to create an instance of an
Action.Add:
public
public static
static Action add(ToDoModel model) {
return
return(new
new AutoValue_Action_Add(model));
}
A DEEP DIVE INTO MVI
285

(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Action.java)
Publishing Actions
Our RosterViewModel has a process() method that our fragments call to publish
actions. In the case of RosterListFragment and RosterListAdapter, this happens in
a few places.
First, the user might modify a to-do item directly from the RecyclerView by clicking
the item’s CheckBox. This sample app uses the data binding framework, and so the
CheckBox has a binding expression for the onCheckedChanged event, routing it to the
view (by way of RosterListAdapter and its associated RosterRowHolder for each
row). That, in turn, eventually triggers a process() call to publish an edit event:
process(Action.edit(model.toBuilder().isCompleted(isChecked).build()));
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/ui/RosterListFragment.java)
Here, we:
• Get a Builder with the current item’s data from toBuilder()
• Call isCompleted() to mark the item as completed
•
build() a new ToDoModel from that Builder
• Pass that ToDoModel to the edit() helper method on Action to create the
proper Action instance
• Hand that Action over to process()
Similarly, if the user clicks the “delete” icon in multi-select mode, we want to get
confirmation from the user, then delete those items. That eventually gets handled by
a requestDelete() method on RosterListFragment, which shows a Snackbar and
calls process() for delete() Action if the user clicks the Snackbar action:
public
public void requestDelete(int selectionCount) {
Resources res=getResources();
String msg=res.getQuantityString(R.plurals.snackbar_delete,
selectionCount, selectionCount);
snackbar=Snackbar.make(getView(), msg, Snackbar.LENGTH_LONG);
snackbar
.setAction(android.R.string.ok, view -> {
process(Action.delete(adapter.getSelectedModels()));
adapter.exitMultiSelectMode();
A DEEP DIVE INTO MVI
286

})
.show();
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/ui/RosterListFragment.java)
Our filter mode is part of our view state, and the filter mode is something that we
want to persist. That is why we have actions related to filter mode, and why when
the user toggles those menu items we call process() to publish the associated
actions:
case
case R.id.all:
filterAll.setChecked(true
true);
process(Action.filter(FilterMode.ALL));
return
return(true
true);
case
case R.id.completed:
filterCompleted.setChecked(true
true);
process(Action.filter(FilterMode.COMPLETED));
return
return(true
true);
case
case R.id.outstanding:
filterOutstanding.setChecked(true
true);
process(Action.filter(FilterMode.OUTSTANDING));
return
return(true
true);
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/ui/RosterListFragment.java)
Note that in none of these cases do we update the fragment’s UI based on these
events. Of course, in the case of the CheckBox, that happens automatically. But if the
user deletes items or changes the filter mode, we do not update the RecyclerView.
Instead, we just publish the actions, and we only update the UI in render(), when
we get the updated view state.
One oddball action is the “load” action. Somewhere along the line, when we start up
the app, we need to load our data — without the data, we have no view state and we
have nothing to render. But, at the same time, we only want to load the data when
we are starting out, not after a configuration change, so we cannot readily use
lifecycle methods on the activity or fragments to trigger a load. Instead,
RosterViewModel, as part of its constructor, publishes a load() Action on its own.
Hence, when we create the view-model, we initiate loading of the data. Since a
ViewModel is only created once per “logical” activity instance (taking into account
configuration changes), we only load this data once for the entire activity. This
A DEEP DIVE INTO MVI
287

might be insufficient in a more elaborate app, where multiple activities might share
a common repository, but it will suffice here.
The Repositories
Eventually, our Controller will need to update backing stores, so that our to-do
items and filter modes are persistent from run to run of our app. This sample app
uses the repository pattern, with two repositories: ToDoRepository for to-do items
and FilterModeRepository for filter modes.
The objective of each repository is simple:
• Modify the backing store as needed, where the caller is required to establish
the appropriate thread to do this on
• Offer an observable API to load the data
Each repository is a singleton, so all logic routes through central points for each type
of data.
ToDoRepository
The ToDoRepository wraps around a ToDoDatabase and ToDoEntity objects, where
those have the appropriate Room annotations to set up a SQLite database.
ToDoEntity has fields that map to the same pieces of data that ToDoModel holds. In
principle, we could have dispensed with the separation and passed around
ToDoEntity objects where we are currently passing around ToDoModel objects.
However, it is possible that some future edition of this sample might have multiple
backing stores (e.g., local database and a server), in which case keeping some
separation between the in-memory model and the persistent representations is
worthwhile. In this case, converting between the two is relatively simple, and
ToDoEntity has a constructor and toModel() methods that do just that:
package
package com.commonsware.android.todo.impl;
import
import android.arch.persistence.room.Dao
android.arch.persistence.room.Dao;
import
import android.arch.persistence.room.Delete
android.arch.persistence.room.Delete;
import
import android.arch.persistence.room.Entity
android.arch.persistence.room.Entity;
import
import android.arch.persistence.room.Index
android.arch.persistence.room.Index;
import
import android.arch.persistence.room.Insert
android.arch.persistence.room.Insert;
import
import android.arch.persistence.room.PrimaryKey
android.arch.persistence.room.PrimaryKey;
import
import android.arch.persistence.room.Query
android.arch.persistence.room.Query;
import
import android.arch.persistence.room.Update
android.arch.persistence.room.Update;
import
import android.support.annotation.NonNull
android.support.annotation.NonNull;
A DEEP DIVE INTO MVI
288

import
import java.util.Calendar
java.util.Calendar;
import
import java.util.List
java.util.List;
import
import io.reactivex.Single
io.reactivex.Single;
@Entity(tableName="todos", indices=@Index(value="id"))
public
public class
class ToDoEntity
ToDoEntity {
@PrimaryKey
@NonNull final
final String id;
@NonNull final
final String description;
final
final String notes;
final
final boolean isCompleted;
@NonNull final
final Calendar createdOn;
public
public static
static ToDoEntity fromModel(ToDoModel model) {
return
return(new
new ToDoEntity(model.id(), model.description(), model.isCompleted(),
model.notes(), model.createdOn()));
}
ToDoEntity(@NonNull String id, @NonNull String description, boolean isCompleted,
String notes, @NonNull Calendar createdOn) {
this
this.id=id;
this
this.description=description;
this
this.isCompleted=isCompleted;
this
this.notes=notes;
this
this.createdOn=createdOn;
}
public
public ToDoModel toModel() {
return
return(ToDoModel.builder()
.id(id)
.description(description)
.isCompleted(isCompleted)
.notes(notes)
.createdOn(createdOn)
.build());
}
@Dao
public
public interface
interface Store
Store {
@Query("SELECT * FROM todos ORDER BY description ASC")
Single<List<ToDoEntity>> all();
@Insert
void insert(ToDoEntity... entities);
@Update
void update(ToDoEntity... entities);
@Delete
void delete(ToDoEntity... entities);
@Delete
void delete(List<ToDoEntity> entities);
@Query("DELETE FROM todos")
void deleteAll();
}
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoEntity.java)
A DEEP DIVE INTO MVI
289

ToDoRepository then maps between the models that it uses as its API and the
entities that it uses with the ToDoDatabase:
package
package com.commonsware.android.todo.impl;
import
import android.content.Context
android.content.Context;
import
import java.util.ArrayList
java.util.ArrayList;
import
import java.util.List
java.util.List;
import
import io.reactivex.Single
io.reactivex.Single;
import
import io.reactivex.annotations.NonNull
io.reactivex.annotations.NonNull;
import
import io.reactivex.functions.Function
io.reactivex.functions.Function;
public
public class
class ToDoRepository
ToDoRepository {
private
private static
static volatile
volatile ToDoRepository INSTANCE=null
null;
private
private final
final ToDoDatabase db;
public
public synchronized
synchronized static
static ToDoRepository get(Context ctxt) {
if
if (INSTANCE==null
null) {
INSTANCE=new
new ToDoRepository(ctxt.getApplicationContext());
}
return
return(INSTANCE);
}
private
private ToDoRepository(Context ctxt) {
db=ToDoDatabase.get(ctxt);
}
public
public Single<List<ToDoModel>> all() {
return
return(db.todoStore().all().map(entities -> {
ArrayList<ToDoModel> result=new
new ArrayList<>(entities.size());
for
for (ToDoEntity entity : entities) {
result.add(entity.toModel());
}
return
return(result);
}));
}
public
public void add(ToDoModel model) {
db.todoStore().insert(ToDoEntity.fromModel(model));
}
public
public void replace(ToDoModel model) {
db.todoStore().update(ToDoEntity.fromModel(model));
}
A DEEP DIVE INTO MVI
290

public
public void delete(List<ToDoModel> models) {
List<ToDoEntity> entities=new
new ArrayList<>();
for
for (ToDoModel model : models) {
entities.add(ToDoEntity.fromModel(model));
}
db.todoStore().delete(entities);
}
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoRepository.java)
Its all() method is a Single, used for the initial data load, which gets all() the
entities, then uses a map() operator to convert those entities into models.
FilterModeRepository
The filter mode is saved in SharedPreferences. The FilterMode itself is an enum that
knows how to map between stable int values and the corresponding enum values:
package
package com.commonsware.android.todo.impl;
public
public enum
enum FilterMode {
ALL(0),
COMPLETED(1),
OUTSTANDING(2);
private
private final
final int value;
static
static FilterMode forValue(int value) {
FilterMode result=ALL;
if
if (value==1) {
result=COMPLETED;
}
else
else if (value==2) {
result=OUTSTANDING;
}
return
return(result);
}
FilterMode(int value) {
this
this.value=value;
}
A DEEP DIVE INTO MVI
291

int getValue() {
return
return(value);
}
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/FilterMode.java)
FilterModeRepository hides the storage details, accepting in FilterMode objects
and offering a load() method to obtain the current FilterMode via a Single:
package
package com.commonsware.android.todo.impl;
import
import android.annotation.SuppressLint
android.annotation.SuppressLint;
import
import android.content.Context
android.content.Context;
import
import android.content.SharedPreferences
android.content.SharedPreferences;
import
import io.reactivex.Single
io.reactivex.Single;
class
class FilterModeRepository
FilterModeRepository {
private
private static
static final
final String PREF_MODE="filterMode";
private
private static
static volatile
volatile FilterModeRepository INSTANCE=null
null;
private
private SharedPreferences prefs=null
null;
synchronized
synchronized static
static FilterModeRepository get() {
if
if (INSTANCE==null
null) {
INSTANCE=new
new FilterModeRepository();
}
return
return(INSTANCE);
}
Single<FilterMode> load(Context ctxt) {
final
final Context app=ctxt.getApplicationContext();
return
return(Single.create(e -> {
synchronized
synchronized(this
this) {
if
if (prefs==null
null) {
prefs=app.getSharedPreferences(getClass().getCanonicalName(),
Context.MODE_PRIVATE);
}
}
e.onSuccess(FilterMode.forValue(prefs.getInt(PREF_MODE, 0)));
}));
}
@SuppressLint("ApplySharedPref")
void save(FilterMode mode) {
A DEEP DIVE INTO MVI
292

prefs.edit().putInt(PREF_MODE, mode.getValue()).commit();
}
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/FilterModeRepository.java)
The Controller
Given the actions and the repositories, the controller is the glue code, updating the
repositories based on the actions and emitting results to trigger updates to the view
state and, from there, the UI.
Subscribing to Actions
To get the actions over to the Controller, the RosterViewModel has an RxJava
PublishSubject that serves as its Observable source of a stream of Action objects.
Every time process() is called, the RosterViewModel emits that Action onto the
actionSubject:
public
public void process(Action action) {
actionSubject.onNext(action);
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/RosterViewModel.java)
As part of its constructor, the RosterViewModel creates a Controller. Once again,
this may not be an appropriate approach for a more complex app, where there may
be multiple view-models needing to work with a common Controller, but it suffices
for here. Along the way, the RosterViewModel calls a subscribeToActions()
method, so that the Controller can subscribe to those Action events:
public
public void subscribeToActions(Observable<Action> actionStream) {
actionStream
.observeOn(Schedulers.io())
.subscribe(this
this::processImpl);
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
This particular subscription routes the work to the io() thread, to keep the
repository work off of the main application thread. And, it passes the Action objects
to a processImpl() method.
A DEEP DIVE INTO MVI
293

Doing the Work and Publishing Results
So far, the only place where we care about specific types of Action is when we
publish them. In effect, we take several event types and combine them into a single
type for convenience. However, at some point, we need to split them back out again,
so we can handle specific logic for specific actions, and that occurs in
processImpl():
private
private void processImpl(Action action) {
if
if (action instanceof
instanceof Action.Add) {
add(((Action.Add)action).model());
}
else
else if (action instanceof
instanceof Action.Edit) {
modify(((Action.Edit)action).model());
}
else
else if (action instanceof
instanceof Action.Delete) {
delete(((Action.Delete)action).models());
}
else
else if (action instanceof
instanceof Action.Load) {
load();
}
else
else if (action instanceof
instanceof Action.Select) {
select(((Action.Select)action).position());
}
else
else if (action instanceof
instanceof Action.Unselect) {
unselect(((Action.Unselect)action).position());
}
else
else if (action instanceof
instanceof Action.UnselectAll) {
unselectAll();
}
else
else if (action instanceof
instanceof Action.Show) {
show(((Action.Show)action).current());
}
else
else if (action instanceof
instanceof Action.Filter) {
filter(((Action.Filter)action).filterMode());
}
else
else {
throw
throw new
new IllegalStateException("Unexpected action: "+action.toString());
}
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
This basically “unwraps” the action and invokes a dedicated method per action type.
Most of those methods work with one of the repositories for the data associated
A DEEP DIVE INTO MVI
294

with that action. All of these methods use a BehaviorSubject named resultSubject
to publish the result, and we will examine that in detail a bit later.
The action method can be broken down into four groups, based on the data being
operated on and the operation type.
add()/modify()/delete()
These three methods are fairly straightforward. They call the associated method on
the ToDoRepository and publish their results:
private
private void add(ToDoModel model) {
toDoRepo.add(model);
resultSubject.onNext(Result.added(model));
}
private
private void modify(ToDoModel model) {
toDoRepo.replace(model);
resultSubject.onNext(Result.modified(model));
}
private
private void delete(List<ToDoModel> toDelete) {
toDoRepo.delete(toDelete);
resultSubject.onNext(Result.deleted(toDelete));
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
filter()
filter() is similar, except that it works with the FilterModeRepository:
private
private void filter(FilterMode mode) {
filterModeRepo.save(mode);
resultSubject.onNext(Result.filter(mode));
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
select()/unselect()/unselectAll()
The selections are not persistent — they are purely a UI contrivance. However, they
are part of the view state, and the only way to update the view state is by going
A DEEP DIVE INTO MVI
295

through the action-controller-reducer flow. So, these three methods just publish
results to get their data updates over to the reducer:
private
private void select(int position) {
resultSubject.onNext(Result.selected(position));
}
private
private void unselect(int position) {
resultSubject.onNext(Result.unselected(position));
}
private
private void unselectAll() {
resultSubject.onNext(Result.unselectedAll());
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
load()
load() is the quirky one, as this would not be traditional computer programming if
everything were simple.
private
private void load() {
Single<Result> loader=
Single.zip(toDoRepo.all(), filterModeRepo.load(ctxt),
(models, mode) -> (Result.loaded(models, mode)));
loader
.subscribeOn(Schedulers.io())
.subscribe(resultSubject::onNext);
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
The load action is to load our data. In our case, though, we have data from two
repositories: the ToDoRepository and the FilterModeRepository. Each publishes a
Single for loading their particular bits of data. We need to publish results once both
of those Single objects have completed processing.
RxJava’s zip() operator — which has nothing much to do with ZIP files, zip ties, or
ziplines — is designed for this sort of scenario. You give zip() multiple observables,
and it invokes your code for each set of results emitted by the source observables.
Since our observables are Single, they only emit one object, and so we get control
once both Single results are in. We then publish those as our own result.
A DEEP DIVE INTO MVI
296

About Those Results
Just as we have a common Action type that wraps up a bunch of disparate actions,
we have a common Result type that wraps up a bunch of disparate results. The
Controller uses the aforementioned BehaviorSubject to emit Result objects to
interested parties.
Result is structured similarly to Action, using AutoValue for immutable objects,
with static factory methods to create instances associated with each type:
package
package com.commonsware.android.todo.impl;
import
import com.google.auto.value.AutoValue
com.google.auto.value.AutoValue;
import
import java.util.Collections
java.util.Collections;
import
import java.util.List
java.util.List;
public
public abstract
abstract class
class Result
Result {
public
public static
static Result added(ToDoModel model) {
return
return(new
new AutoValue_Result_Added(model));
}
public
public static
static Result modified(ToDoModel model) {
return
return(new
new AutoValue_Result_Modified(model));
}
static
static Result deleted(List<ToDoModel> models) {
return
return(new
new AutoValue_Result_Deleted(Collections.unmodifiableList(models)));
}
static
static Result loaded(List<ToDoModel> models, FilterMode filterMode) {
return
return(new
new AutoValue_Result_Loaded(Collections.unmodifiableList(models), filterMode));
}
static
static Result selected(int position) {
return
return(new
new AutoValue_Result_Selected(position));
}
static
static Result unselected(int position) {
return
return(new
new AutoValue_Result_Unselected(position));
}
static
static Result unselectedAll() {
return
return(new
new AutoValue_Result_UnselectedAll());
}
static
static Result showed(ToDoModel current) {
return
return(new
new AutoValue_Result_Showed(current));
}
static
static Result filter(FilterMode mode) {
return
return(new
new AutoValue_Result_Filter(mode));
}
@AutoValue
A DEEP DIVE INTO MVI
297

public
public static
static abstract
abstract class
class Added
Added extends
extends Result {
public
public abstract
abstract ToDoModel model();
}
@AutoValue
public
public static
static abstract
abstract class
class Modified
Modified extends
extends Result {
public
public abstract
abstract ToDoModel model();
}
@AutoValue
public
public static
static abstract
abstract class
class Deleted
Deleted extends
extends Result {
public
public abstract
abstract List<ToDoModel> models();
}
@AutoValue
static
static abstract
abstract class
class Selected
Selected extends
extends Result {
public
public abstract
abstract int position();
}
@AutoValue
static
static abstract
abstract class
class Unselected
Unselected extends
extends Result {
public
public abstract
abstract int position();
}
@AutoValue
static
static abstract
abstract class
class UnselectedAll
UnselectedAll extends
extends Result {
}
@AutoValue
static
static abstract
abstract class
class Showed
Showed extends
extends Result {
public
public abstract
abstract ToDoModel current();
}
@AutoValue
static
static abstract
abstract class
class Filter
Filter extends
extends Result {
public
public abstract
abstract FilterMode filterMode();
}
@AutoValue
public
public static
static abstract
abstract class
class Loaded
Loaded extends
extends Result {
public
public abstract
abstract List<ToDoModel> models();
public
public abstract
abstract FilterMode filterMode();
}
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/Result.java)
The Reducer in the RosterViewModel
What remains is the reducer: accepting the results and updating the view state to
match. In this sample app, that is part of the role of the RosterViewModel.
You might wonder why this is called “RosterViewModel”, given that it has
responsibilities that do not exactly line up with a classic view-model. The name
comes from the base class: AndroidViewModel. We want to retain this object across
A DEEP DIVE INTO MVI
298

configuration changes, and the way to do that with the Architecture Components is
to use ViewModel, AndroidViewModel, ViewModelProviders, and so forth. In the
author’s opinion, Google would have been better served naming their system
something that did not have “ViewModel” in it, just as Room does not have “Model”
or “Repository” in it.
Subscribing to Results
Our Controller publishes Result objects via the resultSubject Observable,
exposed via a resultStream() method. RosterViewModel needs to subscribe to that
stream, take the results, fold them into the view state, and publish an updated view
state.
That is wired together in the RosterViewModel constructor:
public
public RosterViewModel(Application ctxt) {
super
super(ctxt);
ObservableTransformer<Result, ViewState> toView=
results -> (results.map(result -> {
lastState=foldResultIntoState(lastState, result);
return
return(lastState);
}));
Controller controller=new
new Controller(ctxt);
states=LiveDataReactiveStreams
.fromPublisher(controller.resultStream()
.subscribeOn(Schedulers.io())
.compose(toView)
.cache()
.toFlowable(BackpressureStrategy.LATEST)
.share());
controller.subscribeToActions(actionSubject);
process(Action.load());
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/RosterViewModel.java)
The stateStream() method that our views use to get the updated live states is a
LiveData, held onto as a states field and exposed via stateStream(). To create
states, we:
• Get the resultStream() Observable from the Controller
A DEEP DIVE INTO MVI
299

• Arrange to process those Result objects on a background thread
• Use the toView ObservableTransformer to convert Result objects into a new
ViewState — we will examine this part in greater detail shortly
• Cache the resulting ViewState
• Convert the Observable to a Flowable, only worrying about the latest
ViewState that we receive
•
share() that Flowable among multiple subscribers
• Convert that Flowable into a LiveData using
LiveDataReactiveStreams.fromPublisher()
Merging Results Into the ViewState
An ObservableTransformer is simply a way of packaging an RxJava operator or chain
of operators into a separate object. That can be useful in cases where:
• You might want to reuse the same operator(s) in multiple chains
• The operator might be fairly complex, and so you want to pull it out of the
chain declaration to keep the chain itself more readable
So, let’s look at that operator more closely:
ObservableTransformer<Result, ViewState> toView=
results -> (results.map(result -> {
lastState=foldResultIntoState(lastState, result);
return
return(lastState);
}));
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/RosterViewModel.java)
We get in our Result stream, and our declaration says that we are emitting a
ViewState. We are using the map() operator to make that conversion, where the
bulk of the logic lies in a foldResultIntoState() method.
What we are trying to do is to mix a new Result with the previous ViewState to get
a new ViewState. This implies that we have the previous ViewState somewhere.
That is the lastState field, initialized to be an empty ViewState at the outset:
private
private ViewState lastState=ViewState.empty().build();
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/RosterViewModel.java)
A DEEP DIVE INTO MVI
300

It is the job of foldResultIntoState() to create the new ViewState, which the
ObservableTransformer both holds in lastState and returns to flow through the
rest of the chain.
foldResultIntoState() needs to identify the specific type of Result (e.g., we added
an item, we deleted an item) and update the ViewState. foldResultIntoState()
mostly handles the first part: identifying the specific type of Result:
private
private ViewState foldResultIntoState(@NonNull ViewState state,
@NonNull Result result) throws
throws Exception {
if
if (result instanceof
instanceof Result.Added) {
return
return(state.add(((Result.Added)result).model()));
}
else
else if (result instanceof
instanceof Result.Modified) {
return
return(state.modify(((Result.Modified)result).model()));
}
else
else if (result instanceof
instanceof Result.Deleted) {
return
return(state.delete(((Result.Deleted)result).models()));
}
else
else if (result instanceof
instanceof Result.Loaded) {
List<ToDoModel> models=((Result.Loaded)result).models();
return
return(ViewState.builder()
.isLoaded(true
true)
.items(models)
.filterMode(((Result.Loaded)result).filterMode())
.current(models.size()==0 ? null
null : models.get(0))
.build());
}
else
else if (result instanceof
instanceof Result.Selected) {
return
return(state.selected(((Result.Selected)result).position()));
}
else
else if (result instanceof
instanceof Result.Unselected) {
return
return(state.unselected(((Result.Unselected)result).position()));
}
else
else if (result instanceof
instanceof Result.UnselectedAll) {
return
return(state.unselectedAll());
}
else
else if (result instanceof
instanceof Result.Showed) {
return
return(state.show(((Result.Showed)result).current()));
}
else
else if (result instanceof
instanceof Result.Filter) {
return
return(state.filtered(((Result.Filter)result).filterMode()));
}
else
else {
throw
throw new
new IllegalStateException("Unexpected result type: "+result.toString());
}
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/RosterViewModel.java)
In the case of Result.Loaded, we are creating a brand-new ViewState from scratch.
We only get this event when we first load the data, and so there is no meaningful
prior state to use. In all the other scenarios, we call mutation methods on the
A DEEP DIVE INTO MVI
301

existing ViewState, which turn around and create a new ViewState with the
requested changes applied:
ViewState add(ToDoModel model) {
List<ToDoModel> models=new
new ArrayList<>(items());
models.add(model);
sort(models);
return
return(toBuilder()
.items(Collections.unmodifiableList(models))
.current(model)
.build());
}
ViewState modify(ToDoModel model) {
List<ToDoModel> models=new
new ArrayList<>(items());
ToDoModel original=find(models, model.id());
if
if (original!=null
null) {
int index=models.indexOf(original);
models.set(index, model);
}
sort(models);
return
return(toBuilder()
.items(Collections.unmodifiableList(models))
.build());
}
ViewState delete(List<ToDoModel> toDelete) {
List<ToDoModel> models=new
new ArrayList<>(items());
for
for (ToDoModel model : toDelete) {
ToDoModel original=find(models, model.id());
if
if (original==null
null) {
throw
throw new
new IllegalArgumentException("Cannot find model to delete: "+model.toString());
}
else
else {
models.remove(original);
}
}
sort(models);
return
return(toBuilder()
.items(Collections.unmodifiableList(models))
.build());
}
ViewState selected(int position) {
HashSet<Integer> selections=new
new HashSet<>(selections());
selections.add(position);
return
return(toBuilder()
A DEEP DIVE INTO MVI
302

.selections(Collections.unmodifiableSet(selections))
.build());
}
ViewState unselected(int position) {
HashSet<Integer> selections=new
new HashSet<>(selections());
selections.remove(position);
return
return(toBuilder()
.selections(Collections.unmodifiableSet(selections))
.build());
}
ViewState unselectedAll() {
return
return(toBuilder()
.selections(Collections.unmodifiableSet(new
new HashSet<>()))
.build());
}
ViewState show(ToDoModel current) {
return
return(toBuilder()
.current(current)
.build());
}
ViewState filtered(FilterMode mode) {
return
return(toBuilder()
.filterMode(mode)
.build());
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ViewState.java)
In all cases, we get a new immutable ViewState, which then flows out of the
RosterViewModel to the view layer, so the fragments can update their UI as needed.
Examining the Other Fragments
While most of the code that we have reviewed so far was common for all three
fragments, it is worth mentioning the other two fragments, as they have some
different wrinkles.
DisplayFragment
DisplayFragment does not publish any actions itself. It is simply a passive consumer
of view states.
However, its view state logic is a bit more complicated than is the
RosterListFragment. While the user may think that the DisplayFragment is only
displaying one to-do item, in reality it uses a RecyclerView to display the same
A DEEP DIVE INTO MVI
303

roster that RosterListFragment does. While RosterListFragment displays the roster
in a vertically-scrolling list, DisplayFragment displays the roster via horizontal
swipes, akin to the behavior of a ViewPager. The DisplayFragment needs to know
what particular to-do item to be displaying. That can be determined by:
• the RosterListFragment and MainActivity, if the user taps on an item in
the list
• the user, via swipe gestures
As a result, DisplayFragment has two view-models. AbstractRosterFragment
handles most of the logic for working with the RosterViewModel, as it does for
RosterListFragment. DisplayFragment has its own DisplayViewModel that keeps
track of the currently-viewed page in the “pager”, so we can restore this after a
configuration change.
EditFragment
EditFragment publishes three actions:
• If the user saves the form, and this is a new to-do item, it publishes an “add”
action
• If the user saves the form, and this is an existing to-do item, it publishes an
“edit” action
• If the user taps on the “Delete” toolbar button and confirms this request, it
publishes a “delete” action
Unlike DisplayFragment, EditFragment only ever works on a single to-do item. The
ID of the ToDoModel which it is editing arrives via the newInstance() factory method
and is saved in the arguments Bundle, so we do not need a separate view-model for
it.
Summary
This sample app is far from perfect.
Strategically, this is quite a bit of code for a silly little to-do app. To an extent, the
value of formal architectures increases with the size and scope of the app. The more
“disposable” the app is, the more likely it is that you can skip some architectural
complexity and just focus on writing a working app. As the preceding chapter noted,
for smaller apps, YAGNI (You Aren’t Going to Need It).
A DEEP DIVE INTO MVI
304

Tactically, the sample app makes a core simplifying assumption: that the entire set
of to-do items fits comfortably in memory. Sometimes that will be the case with full
production-grade apps. Sometimes that will not be the case, and the complexity of
the app rises. We will address that in the next chapter.
The objective of this sample is to demonstrate the flows of Model-View-Intent and
some of the code that would be required to implement such a GUI architecture. It is
not necessarily the best possible implementation of Model-View-Intent, let alone of
a to-do tracking app.
A DEEP DIVE INTO MVI
305


MVI and Paging
The preceding chapter’s example app is fairly complex, yet it has a key architectural
limitation: it holds the entire set of model objects in memory. Some apps will be
able to get by with this limitation. Other apps will not be able to get away with that
and instead need to do something to be able to work with a subset of model objects
at a time.
Fortunately, the Architecture Components has a Paging library that can help with
this.
So, in this chapter, we will walk through aspects of the ToDo/PagingMVI sample
project, which adapts the MVI sample to use the Paging library.
Flawed Assumptions
Switching from holding all models in memory to a paged approach has a lot of
rippling effects throughout the app.
Generally, it was assumed that you could get to any ToDoModel instance at any point
in time, by position or by its ID. The ViewState held all of them. As a result, when
the EditFragment needed its ToDoModel, it just asked the ViewState for that model.
Now, that requires more work.
Similarly, cross-cutting effects like filtering cannot be accomplished the same way.
Previously, we just used a subset of the in-memory list of models. Now, we need to
make a separate database query to get the proper subset, then use the Paging
library to work with that subset.
307

Basically, anything that worked with lots of models needs to be revisited. So, for
example, multiple selection can still work, even when data gets paged in and out, as
the selections were represented by position numbers, not models. However,
deleting multiple selections would pass the list of models via the action, and that is
impractical now, so we need to switch approaches.
ToDoModelDataSource and the
PagedDataSnapshot
In a previous chapter, we saw how to create a custom DataSource for the Paging
library, in the form of a ToDoModelDataSource. As it turns out, that DataSource is
from this chapter’s sample app.
The end use of that ToDoModelDataSource is to show its contents in the roster list
RecyclerView, using LivePagedListBuilder to create a PagedList for us.
Inside the PagedList… somewhere… is our DataSource. Unfortunately, there is no
way to retrieve it. We will need that ToDoModelDataSource from time to time.
So, rather than pass around a bare PagedList, we are forced to pass around
something that wraps a PagedList and our DataSource, just so that we can get to
the DataSource that the PagedList uses. In the case of this app, that comes in the
form of a PagedDataSnapshot:
package
package com.commonsware.android.todo.impl;
import
import android.arch.paging.PagedList
android.arch.paging.PagedList;
import
import android.os.Handler
android.os.Handler;
import
import android.os.Looper
android.os.Looper;
import
import java.util.concurrent.Executor
java.util.concurrent.Executor;
import
import java.util.concurrent.Executors
java.util.concurrent.Executors;
public
public class
class PagedDataSnapshot
PagedDataSnapshot<T, PK> {
private
private final
final SnapshotDataSource<T, PK> dataSource;
private
private final
final PagedList<T> pagedList;
public
public PagedDataSnapshot(SnapshotDataSource<T, PK> dataSource, int count) {
this
this.dataSource=dataSource;
PagedList.Builder<Integer, T> builder=
new
new PagedList.Builder<>(dataSource, count);
pagedList=builder
MVI AND PAGING
308

.setBackgroundThreadExecutor(Executors.newSingleThreadExecutor())
.setMainThreadExecutor(new
new MainThreadExecutor())
.build();
}
public
public SnapshotDataSource<T, PK> dataSource() {
return
return dataSource;
}
public
public PagedList<T> pagedList() {
return
return pagedList;
}
private
private static
static class
class MainThreadExecutor
MainThreadExecutor implements
implements Executor {
private
private Handler mainHandler=new
new Handler(Looper.getMainLooper());
@Override
public
public void execute(Runnable command) {
mainHandler.post(command);
}
}
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/PagedDataSnapshot.java)
PagedListSnapshot uses PagedList.Builder to create the PagedList immediately,
and therefore its constructor will need to be invoked on a background thread. It
also uses the MainThreadExecutor outlined in the chapter on paging.
Saving Our Instance State
In the original MVI sample, we did not save our instance state. Ideally, we would
track the ID of the current ToDoModel, in case that DisplayFragment or
EditFragment are visible. That way, if the activity has to be re-created from scratch,
those fragments would know what model they should be showing.
This, however, is a bit complex to add in. We need that ID when we create our
RosterViewModel, so that when we load() our initial data, we can pull in that
model object. This is particularly important with this Paging-based edition of the
app, as we might not have the model object otherwise — it might be for some page
that is beyond what we are initially loading.
MVI AND PAGING
309

Revising the ViewModel
RosterViewModel now has a constructor that takes both an Application and a
Bundle. The idea is that the Bundle would be part of the saved instance state for the
activity. In that constructor, we get a STATE_CURRENT_ID from the Bundle, if we
actually got a Bundle (versus null), and we pass that ID to load():
public
public RosterViewModel(Application ctxt, Bundle state) {
super
super(ctxt);
ObservableTransformer<Result, ViewState> toView=
results -> (results.map(result -> {
lastState=foldResultIntoState(lastState, result);
return
return(lastState);
}));
Controller controller=new
new Controller(ctxt);
states=LiveDataReactiveStreams
.fromPublisher(controller.resultStream()
.subscribeOn(Schedulers.io())
.compose(toView)
.cache()
.toFlowable(BackpressureStrategy.LATEST)
.share());
controller.subscribeToActions(actionSubject);
String currentId=(state==null
null ? null
null : state.getString(STATE_CURRENT_ID));
process(Action.load(currentId));
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/RosterViewModel.java)
Defining a Factory
However, the standard approach for using a ViewModel has library code create our
ViewModel instances, and that code knows nothing about this two-parameter
constructor. So, we need to implement our own ViewModelProvider.Factory that
can create instances of the RosterViewModel:
public
public static
static class
class Factory
Factory implements
implements ViewModelProvider.Factory {
private
private final
final Application app;
private
private final
final Bundle state;
MVI AND PAGING
310

public
public Factory(@android.support.annotation.NonNull Application app,
Bundle state) {
this
this.app=app;
this
this.state=state;
}
@android.support.annotation.NonNull
@Override
public
public <T extends
extends ViewModel> T create(
@android.support.annotation.NonNull Class<T> modelClass) {
return
return (T)new
new RosterViewModel(app, state);
}
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/RosterViewModel.java)
Centralizing the ViewModel
Now, the problem is that we need that Bundle when we create instances of our
RosterViewModel using the RosterViewModel.Factory.
So, rather than having each fragment get the RosterViewModel from
ViewModelProviders, we now have the MainActivity get that RosterViewModel in
onCreate() and hold onto it in a field:
private
private RosterViewModel viewModel;
@Override
public
public void onCreate(Bundle state) {
super
super.onCreate(state);
setContentView(R.layout.activity_main);
isDualPane=(findViewById(R.id.detail)!=null
null);
viewModel=ViewModelProviders
.of(this
this, new
new RosterViewModel.Factory(getApplication(), state))
.get(RosterViewModel.class);
if
if (getSupportFragmentManager().findFragmentById(R.id.master)==null
null) {
getSupportFragmentManager().beginTransaction()
.add(R.id.master, new
new RosterListFragment())
.commit();
if
if (isDualPane) {
display=DisplayFragment.newInstance(null
null);
MVI AND PAGING
311

getSupportFragmentManager().beginTransaction()
.replace(getDetailContainer(), display)
.commit();
}
}
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/ui/MainActivity.java)
There is a corresponding getViewModel() method that the fragments can use to
obtain the RosterViewModel. This way, we can centrally create the RosterViewModel
(when it needs to be created) and provide the saved instance state Bundle.
Saving the State
To close the loop, RosterViewModel has its own onSavedInstanceState() method:
public
public void onSaveInstanceState(Bundle state) {
if
if (lastState!=null
null && lastState.current()!=null
null) {
state.putString(STATE_CURRENT_ID, lastState.current().id());
}
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/RosterViewModel.java)
…which is called by the MainActivity:
@Override
protected
protected void onSaveInstanceState(Bundle outState) {
super
super.onSaveInstanceState(outState);
viewModel.onSaveInstanceState(outState);
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/ui/MainActivity.java)
So now the saved instance state will be updated with the relevant bits from the
RosterViewModel, and the RosterViewModel can load those bits back in when it is
instantiated.
The Rest of the Core Changes
Armed with a Paging library-compatible DataSource, we can now ripple the
necessary changes through the rest of the app. Everywhere that we assumed that
MVI AND PAGING
312

our ViewState had all models now needs to handle the situation where we only
have a page’s worth of those models.
Repository API
First, we need to actually get those ToDoModelDataSource instances as needed. They
are designed to be published by the ToDoRepository, which is our gateway to our
database.
There are two significant changes to the ToDoRepository to make all of this work.
A Filtered all()
Previously, all() would return an RxJava Single, delivering the full roster of
ToDoEntity instances:
public
public Single<List<ToDoModel>> all() {
return
return(db.todoStore().all().map(entities -> {
ArrayList<ToDoModel> result=new
new ArrayList<>(entities.size());
for
for (ToDoEntity entity : entities) {
result.add(entity.toModel());
}
return
return(result);
}));
}
(from ToDo/MVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoRepository.java)
The version in this app — now named allForFilter() — builds and returns a
PagedDataSnapshot:
public
public PagedDataSnapshot<ToDoModel, String> allForFilter(FilterMode filterMode) {
return
return new
new PagedDataSnapshot(new
new ToDoModelDataSource(db, filterMode), 50);
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoRepository.java)
As noted above, the PagedDataSnapshot constructor needs to be called on a
background thread, but all clients of a repository should assume that they need to
make calls on a background thread, so this is not really an issue.
Also, whereas we did not need the FilterMode in the non-paged MVI sample, we
do here, because that eventually drives our database query.
MVI AND PAGING
313

Load and Delete By ID
As mentioned previously, for multiple deletions via the multiple-selection
RecyclerView, we should use IDs, not models, to delete the underlying entities. We
may not have the models in memory, if the user has selected multiple items that
span pages in the data.
To that end, delete() now works off of IDs:
public
public void delete(List<String> ids) {
db.todoStore().delete(ids);
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoRepository.java)
…using a corresponding ID-based delete() on ToDoEntity.Store:
@Query("DELETE FROM todos WHERE id IN (:ids)")
abstract
abstract void delete(List<String> ids);
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoEntity.java)
As noted earlier, we add the ID of the current model to the Load action, where that
ID comes from our saved instance state. Then, our controller can work with the
repository to load that specific model in addition to setting up our PagedList as
part of loading our starting point.
To handle that, ToDoRepository has a new forId() method:
ToDoModel forId(String id, PagedDataSnapshot<ToDoModel, String> snapshot) {
if
if (id==null
null && snapshot.dataSource().countItems()>0) {
id=snapshot.dataSource().findKeyForPosition(0);
}
if
if (id!=null
null) {
ToDoEntity entity=db.todoStore().forId(id);
if
if (entity!=null
null) {
return
return entity.toModel();
}
}
return
return null
null;
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoRepository.java)
MVI AND PAGING
314

…using a corresponding forId() on ToDoEntity.Store:
@Query("SELECT * FROM todos WHERE id=:id")
abstract
abstract ToDoEntity forId(String id);
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/ToDoEntity.java)
forId() also handles the case where we have a null ID, such as after a delete
operation (where the formerly-current model is now deleted). In that case, we take
advantage of the SnapshotDataSource to find the ID for the 0th position and use
that instead. If the snapshot is empty, of course, we return null, lacking any better
option.
Actions
There are two changes of note with our actions.
First, just as we changed our repository to delete by ID, so too we need to change
our actions to track deletion requests by ID:
public
public static
static Action delete(List<String> ids) {
return
return(new
new AutoValue_Action_Delete(Collections.unmodifiableList(ids)));
}
public
public static
static Action delete(ToDoModel model) {
return
return(delete(Collections.singletonList(model.id())));
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Action.java)
@AutoValue
public
public static
static abstract
abstract class
class Delete
Delete extends
extends Action {
public
public abstract
abstract List<String> ids();
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Action.java)
Plus, as noted above, our Load action — and the load() method — need to track
the current model ID:
public
public static
static Action load(String currentId) {
return
return(new
new AutoValue_Action_Load(currentId));
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Action.java)
MVI AND PAGING
315

@AutoValue
public
public static
static abstract
abstract class
class Load
Load extends
extends Action {
@Nullable public
public abstract
abstract String currentId();
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Action.java)
Controller and Result
Given the revised actions, and the revised repository, we can shuffle around the
behavior of the Controller and Result.
A Changed Result
In the original MVI sample, Action and Result had a near-1:1 relationship. Each
Action had its corresponding Result, with similar information. That is because the
actual working copy of our models was in the ViewState, so a changed model
would pass from Action, through the Controller, to the ViewState, by means of
the Result and RosterViewModel.
Now, though, any change to the database contents has the same effect: we need a
fresh PagedDataSnapshot with a fresh PagedList, to update the UI.
As a… ummm… result, we no longer need separate Result objects for different
types of database changes. We can get away with just one, representing the change:
public
public static
static Result changed(PagedDataSnapshot<ToDoModel, String> snapshot,
ToDoModel current) {
return
return(new
new AutoValue_Result_Changed(snapshot, current));
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Result.java)
@AutoValue
public
public static
static abstract
abstract class
class Changed
Changed extends
extends Result {
public
public abstract
abstract PagedDataSnapshot<ToDoModel, String> snapshot();
@Nullable public
public abstract
abstract ToDoModel current();
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Result.java)
Here, we also track what the new “current” model should be:
• On an add operation, this will be the newly-added model
MVI AND PAGING
316

• On an edit operation, this will be whatever model had been current already
(and therefore should remain the current one)
• On a delete operation, our repository will aim to set the current one to be
the 0th position, assuming that there are 1+ items in the snapshot at the
moment
The Controller, for add, modify, and delete operations, then can just pass along a
Result representing the change, rather than distinct Result classes for each type of
change:
private
private void add(ToDoModel model) {
toDoRepo.add(model);
resultSubject.onNext(Result.changed(buildSnapshot(), model));
}
private
private void modify(ToDoModel model) {
toDoRepo.replace(model);
resultSubject.onNext(Result.changed(buildSnapshot(), model));
}
private
private void delete(List<String> toDelete) {
toDoRepo.delete(toDelete);
PagedDataSnapshot<ToDoModel, String> snapshot=buildSnapshot();
resultSubject.onNext(Result.changed(snapshot, toDoRepo.forId(null
null, snapshot)));
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
For the delete() scenario, we pass null into forId(), to have the repository give us
the model for the 0th position (or null if the snapshot is empty).
Tracking FilterMode
However, the Controller now needs to remember the current FilterMode, since
that is needed for the repository, which in turn needs it for the database.
Hence, Controller has a currentFilterMode field representing the current
FilterMode. It it initially populated as part of the initial data load:
private
private void load(String currentId) {
filterModeRepo.load(ctxt)
.subscribeOn(Schedulers.io())
.subscribe(filterMode -> {
currentFilterMode=filterMode;
PagedDataSnapshot<ToDoModel, String> snapshot=buildSnapshot();
MVI AND PAGING
317

resultSubject.onNext(Result.loaded(snapshot, filterMode,
toDoRepo.forId(currentId, snapshot)));
}
);
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
…and it is updated when the FilterMode changes:
private
private void filter(FilterMode mode) {
currentFilterMode=mode;
filterModeRepo.save(mode);
resultSubject.onNext(Result.filter(mode, buildSnapshot()));
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
When we need a fresh PagedDataSnapshot, the current FilterMode is applied:
private
private PagedDataSnapshot<ToDoModel, String> buildSnapshot() {
return
return toDoRepo.allForFilter(currentFilterMode);
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Controller.java)
Loading the Current Model
And, as noted previously, we need to specifically get the current ToDoModel when
we start up, if there is an ID that we have from the saved instance state Bundle.
load() handles this, calling forId() on the repository to retrieve that model. The
Loaded form of Result now holds onto that, along with the snapshot and filter
mode:
static
static Result loaded(PagedDataSnapshot<ToDoModel, String> snapshot,
FilterMode filterMode, ToDoModel current) {
return
return(new
new AutoValue_Result_Loaded(snapshot, filterMode, current));
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Result.java)
@AutoValue
public
public static
static abstract
abstract class
class Loaded
Loaded extends
extends Result {
public
public abstract
abstract PagedDataSnapshot<ToDoModel, String> snapshot();
public
public abstract
abstract FilterMode filterMode();
MVI AND PAGING
318

@Nullable public
public abstract
abstract ToDoModel current();
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/Result.java)
RosterViewModel and ViewState
Surprisingly, these classes are not affected as much as one might expect. ViewState
now holds the PagedDataSnapshot instead of the List of model objects, and that
eliminates a lot of code for maintaining that List. Similarly, ViewState no longer
needs the filteredItems() method, as the snapshot is always properly filtered.
Plus, the RosterViewModel has fewer Result types to merge into the state.
When it comes time to delete items from the multiple-selection RecyclerView, we
need the list of IDs. What the ViewState tracks is the list of selections, which are
based on position values. So the former getSelectedModels() method turns into a
getSelectedIds() method, to convert positions into IDs:
public
public List<String> getSelectedIds() {
List<String> result=new
new ArrayList<>();
SnapshotDataSource<ToDoModel, String> dataSource=snapshot().dataSource();
for
for (int selection : selections()) {
result.add(dataSource.findKeyForPosition(selection));
}
return
return(result);
}
(from ToDo/PagedMVI/app/src/main/java/com/commonsware/android/todo/impl/ViewState.java)
This is one place where we make use of the ToDoModelDataSource inside of the
PagedDataSnapshot, and it is one of the reasons why, way back in the early portion
of this chapter, the load-all-the-primary-keys DataSource hierarchy was created.
Now, even though we cannot get full models for arbitrary positions, we can get
primary keys for those positions, and we can use those ID values to delete the
selected to-do items.
The Fragments
EditFragment is largely unaffected by these changes.
The RecyclerView.Adapter classes used by RosterListFragment and
DisplayFragment are now based on PagedListAdapter, which comes with the
MVI AND PAGING
319

Paging library and handles paging and differences as we apply new PagedList
objects representing updates to our data. This cuts out some of the former code
that we had, such as for applying the DiffUtil.Callback, since PagedListAdapter
does that for us. Otherwise, even to these classes, the changes are fairly minor,
despite the significant change in the in-memory data representation.
MVI AND PAGING
320

Configuring SQLite Beyond Room
Room covers a lot of what you will need when interacting with SQLite from your
app. Room might not cover everything of what you would like to use with SQLite,
though.
Some things — particularly anything involving table definitions — pretty much
requires Room itself to be upgraded in order to work. For example, you cannot
readily add full-text searching yourself, as that requires particular options in the
CREATE TABLE statement.
Anything that lies outside of Room, though, is fair game, though you have to resort
to classic SQLite approaches to make it work.
When To Make Changes
You have two main events for when to make changes outside of Room to the
database: when it is created and when it is opened. Which you use depends on the
nature of your changes.
Changes that are persistent would be applied when the database is created, or
(eventually) via a Migration when the database schema is modified. For example,
using CREATE TRIGGER to create a trigger results in a persistent change to the
database, so you only need to do this when the database schema is created or
modified.
However, some PRAGMA statements are transient, living for the life of our connection
to the database. Once the connection is closed, the effects of those PRAGMA
statements go away. As a result, we have to apply these every time that the database
is opened.
321

Example: Turbo Boost Mode
Some developers are desperate to wring every last bit of performance out of their
database, even to the point of risking data loss or corruption. Some PRAGMA
statements tie into performance this way.
For example, normally, many times when SQLite writes data to disk, it will use
fsync() or the equivalent to block until all of the bytes are confirmed to be written.
This is important in operating systems with write-caching filesystems, as otherwise
the data that you think that you wrote might actually just be in a buffer waiting to
be written in the future. Android, when using the ext4 filesystem, is one such OS.
However, PRAGMA synchronous = OFF tells SQLite to skip those fsync() calls. This
speeds up I/O, with increased risk of the database becoming corrupted if there is a
major system problem while that I/O is going on. This is a transient PRAGMA, only
affecting the current connection.
Even riskier is PRAGMA journal_mode = MEMORY. In effect, this says to keep the
transaction log of the database in memory, rather than writing it to disk. As the
documentation states, “if the application using SQLite crashes in the middle of a
transaction when the MEMORY journaling mode is set, then the database file will
very likely go corrupt”. But, some people would consider performance gains as being
a valid trade-off here. This is a persistent setting, and so it only needs to be applied
once.
The approach for both of these cases is to use a RoomDatabase.Callback, as seen in
the CityPop/RoomPragma sample project.
The create() method that we use to create an instance of our CityDatabase uses a
RoomDatabase.Builder as normal. However, based on a boolean parameter, it may
also use addCallback() to add a RoomDatabase.Callback to the builder:
static
static CityDatabase create(Context ctxt, final
final boolean applyPragmas) {
RoomDatabase.Builder<CityDatabase> b=
Room.databaseBuilder(ctxt.getApplicationContext(), CityDatabase.class,
DB_NAME);
if
if (applyPragmas) {
b.addCallback(new
new Callback() {
@Override
public
public void onCreate(@NonNull SupportSQLiteDatabase db) {
super
super.onCreate(db);
CONFIGURING SQLITE BEYOND ROOM
322

db.query("PRAGMA journal_mode = MEMORY");
}
@Override
public
public void onOpen(@NonNull SupportSQLiteDatabase db) {
super
super.onOpen(db);
db.query("PRAGMA synchronous = OFF");
}
});
}
return
return(b.build());
}
(from CityPop/RoomPragma/app/src/main/java/com/commonsware/android/citypop/CityDatabase.java)
There are two methods that you can supply on a Callback implementation:
onCreate() and onOpen(). As the names suggest, they are called when the database
is created and opened, respectively. In each, you are handed a
SupportSQLiteDatabase instance, which has an API reminiscent of the framework’s
SQLiteDatabase. It has a query() method that works like rawQuery(), taking a
simple SQL statement (that might return a result set) and executing it. Since PRAGMA
might return a result set, we have to use query() instead of execSQL(). Here, we
invoke our PRAGMA statements at the appropriate times.
And, in truth, there does seem to be a significant performance gain:
Scenario
Use the
PRAGMA
PRAGMAs?
Time
(milliseconds)
Inserting 1,063 cities via individual insert()
calls
No
18,766
Inserting 1,063 cities via individual insert()
calls
Yes
1,331
Inserting 1,063 cities in a single insert() call
No
402
Inserting 1,063 cities in a single insert() call
Yes
126
(tests conducted on a Google Pixel)
Proper use of transactions — such as doing all of the inserts at once rather than one
at a time — has a much bigger impact, though. Using these two PRAGMA statements
is a bit like using a holodeck with the safeties off: you may have some casualties.
CONFIGURING SQLITE BEYOND ROOM
323


