Song Y. Yan
Number Theory
for Computing
Second Edition
Foreword by Martin E. Hellman
With 26 Figures, 78 Images, and 33 Tables
Springer
Berlin
Heidelberg
New York
Barcelon a
Hong Kong
Londo n
Milan
Pari s
Tokyo
Springer

Song Y. Yan
Computer Science
Aston University
Birmingham B4 7ET
UK
s.yan@aston.ac.uk
ACM Computing Classification (1998) : F.2.1, E.3-4, D .4 .6, B .2 .4, 11 .2
AMS Mathematics Subject Classification (1991) : 1 lAxx, 1 IT71 ,
11Yxx, 11Dxx, 11Z05, 68Q25, 94A6 0
Library of Congress Cataloging-in-Publication Data applied for
Die Deutsche Bibliothek - CIP-Einheitsaufnahm e
Yan, Song Y. :
Number theory for computing: with 32 tables/Song Y. Yan. - 2. ed., rev.
and extended. - Berlin; Heidelberg ; New York; Barcelona; Hong Kong ;
London; Milan; Paris ; Tokyo: Springer, 200 2
ISBN 3-540-43072- 5
ISBN 3-540-43072-5 Springer-Verlag Berlin Heidelber New Yor k
ISBN 3-540-65472-0 Springer-Verlag Berlin Heidelberg New York (1st ed .)
This work is subject to copyright . All rights are reserved, whether the whole or part of th e
material is concerned, specifically the rights of translation, reprinting, reuse of illustrations ,
recitation, broadcasting, reproduction on microfilm or in any other way, and storage in dat a
banks. Duplication of this publication or parts thereof is permitted only under th e
provisions of the German Copyright Law of September 9, 1965, in its current version, an d
permission for use must always be obtained from Springer-Verlag . Violations are liable for
prosecution under the German Copyright Law .
Springer-Verlag Berlin Heidelberg New York,
a member of BertelsmannSpringer Science+Business Media Gmb H
http://www.springende
Springer-Verlag Berlin Heidelberg 2000, 200 2
Printed in Germany
The use of general descriptive names, trademarks, etc . in this publication does not imply ,
even in the absence of a specific statement, that such names are exempt from the relevan t
protective laws and regulations and therefore free for general use .
Cover Design : KunkelLopka, Heidelberg
Typesetting: Camera ready by the author
Printed on acid-free paper
SPIN 10852441
45/3142SR - 5 4 3 2 1 0
Foreword
Modern cryptography depends heavily on number theory, with primality test-
ing, factoring, discrete logarithms (indices), and elliptic curves being perhap s
the most prominent subject. areas. Since my own graduate study had empha-
sized probability theory, statistics, and real analysis, when I started work-
ing in cryptography around 1970, I found myself swimming in an unknown ,
murky sea. I thus know from personal experience how inaccessible numbe r
theory can be to the uninitiated . Thank you for your efforts to ease th e
transition for a new generation of cryptographers .
Thank you also for helping Ralph Merkle receive the credit he deserves .
Diffie, Rix-est . Shamir. Adleman and I had the good luck to get expedite d
review of our papers, so that they appeared before Merkle's seminal contribu-
tion. Your noting his early submission date and referring to what has come t o
be called "Diffie-Hellman key exchange" as it should, "Diffie-Hellman-Merkle
key exchange", is greatly appreciated.
It has been gratifying to see how cryptography and number theory hav e
helped each other over the last twenty-five years . Number theory has bee n
the source of numerous clever ideas for implementing cryptographic systems
and protocols while cryptography has been helpful in getting funding for this
area which has sometimes been called the queen of mathematics" becaus e
of its seeming lack of real world applications . Little did they know !
Stanford, 30 .July 2001
Martin E. Hellman

Preface to the Second Editio n
Number theory is an experimental science
J . W. S . CASSELS (1922 -
Professor Emeritus of Mathematics . The University of Cambridge
If you teach a course on number theory nowadays, chances are it will gen-
erate more interest among computer science majors than among mathe-
matics majors. Many will care little about integers that can be expresse d
as the sum of two squares . They will prefer to learn how Alice can send a
message to Bob without fear of eavesdropper Eve deciphering it .
BRAIN E. BLANK, Professor of Mathematics
Washington University. St.. Louis, Missouri
The success of the first edition of the book encouraged me to produce thi s
second edition . I have taken this opportunity to provide proofs of many the-
orems, that had not been given in the first edition. Some additions and cor-
rections have also been included .
Since the publication of the first edition . I have received many communica-
tions from readers all over the world . It is my great pleasure to thank the fol-
lowing people for their comments . corrections and encouragements : Prof. Jim
Austin, Prof. Friedrich L . Bauer. Dr. Hassan Daghigh Dr . Deniz Deveci .
Mr. Rich Fearn, Prof. Martin Hellman . Prof. Zixin Hou . Mr. Waseem Hus-
sain, Dr . Gerard R. Maze. Dr. Paul Maguire . Dr. Helmut Mevn. Mr. Rober t
Pargeter. Mr. Mok-Kong Shen. Dr. Peter Shiu . Prof. Jonathan P . Sorenson .
and Dr. David L . Stern. Special thanks must be given to Prof. Martin Hell-
man of Stanford University for writing the kind Foreword to this edition and
also for his helpful advice and kind guidance . to Dr. Hans Wossner . Mr. Al-
fred Hofmann, Mrs. Ingeborg Mayer, Mrs . Ulrike Stricken, and Mr. Frank
Holzwarth of Springer-Verlag for their kind help and encouragements dur-
ing the preparation of this edition, and to Dr. Rodney Coleman. Prof. Glyn
James, Mr. Alexandros Papanikolaou . and Mr. Robert Pargeter for proof-
reading the final draft . Finally. I would like to thank Prof. Shiing-Shen Chern .

Preface to the Second Editio n
Director Emeritus of the Mathematical Sciences Research Institute in Berke-
ley for his kind encouragements ; this edition is dedicated to his 90th birthday !
Readers of the book are, of course, very welcome to communicate with
the author either by ordinary mail or by e-mail to s . yan@aston . ac . uk, so
that your corrections, comments and suggestions can be incorporated into a
future edition.
Birmingham . February 2002
S . Y. Y .
Preface to the First Edition
Mathematicians do not study objects, but relations among objects; they ar e
indifferent to the replacement of objects by others as long as relations do
not change . Matter is not important, only form interests them .
HENRI PoINCARr (1854-1912 )
Computer scientists working on algorithms for factorization would be well
advised to brush up on their number theory .
IAN STEWART
Geometry Finds Factor Fast
Nature, Vol. 325, 15 January 1987, page 199
The theory of numbers, in mathematics, is primarily the theory of the prop-
erties of integers (i .e., the whole numbers), particularly the positive integers .
For example, Euclid proved 2000 years ago in his Elements that there ex-
ist infinitely many prime numbers . The subject had long been considered as
the purest branch of mathematics, with very few applications to other ar-
eas. However, recent years have seen considerable increase in interest in sev-
eral central topics of number theory, precisely because of their importanc e
and applications in other areas, particularly in computing and informatio n
technology. Today, number theory has been applied to such diverse areas as
physics, chemistry, acoustics, biology, computing, coding and cryptography,
digital communications, graphics design, and even music and business' . In
particular, congruence theory has been used in constructing perpetual calen-
dars, scheduling round-robin tournaments, splicing telephone cables, devisin g
systematic methods for storing computer files, constructing magic squares ,
generating random numbers, producing highly secure and reliable encryptio n
schemes and even designing high-speed (residue) computers . It is specificall y
worthwhile pointing out that computers are basically finite machines ; they
1 In his paper [96] in the International Business Week, 20 June 1994, pp. 62-64 ,
Fred Guterl wrote :
"Number Theory, once the esoteric study of what happen s
when whole numbers are manipulated in various ways, is becoming a vital prac -
tical science that is helping solve tough business problems " .

Preface to the First Edition
Preface to the First Edition
have finite storage . can only deal with numbers of some finite length and can
only perform essentially finite steps of computation . Because of such limita-
tions. congruence arithmetic is particularly useful in computer hardware an d
software design .
This book takes the reader on a journey, starting at elementary number
theory. going through algorithmic and computational number theory. and
finally finishing at applied number theory in computing science . It is divided
into three distinct parts :
(1) Elementary Number Theory,
(2) Computational/Algorithmic Number Theory ,
(3) Applied Number Theory in Computing and Cryptography .
The first part is mainly concerned with the basic concepts and results of divis-
ibility theory, congruence theory, continued fractions . Diophantine equation s
and elliptic curves . A novel feature of this part is that it contains an ac-
count of elliptic curves. which is not normally provided by an elementar y
number theory book. The second part provides a brief introduction to th e
basic concepts of algorithms and complexity, and introduces some important
and widely used algorithms in computational number theory. particularly
those for prirnality testing, integer factorization. discrete logarithms, and el-
liptic curve discrete logarithms . An important feature of this part is that
it contains a section on quantum algorithms for integer factorization an d
discrete logarithms, which cannot be easily found, so far, in other texts o n
computational/algorithmic number theory. This part finishes with section s
on algorithms for computing x( :r.), for finding amicable pairs, for verifyin g
Goldbach's conjecture, and for finding perfect and amicable numbers . The
third part of the book discusses some novel applications of elementary an d
computational number theory in computing and information technology, par-
ticularly in cryptography and information security ; it covers a wide range o f
topics such as secure communications, information systems security . com-
puter organisations and design . error detections and corrections . hash func-
tion design. and random number generation . Throughout the book we follow
the style "Definition-Theorem-Algorithm-Example " to present our material ,
rather than the traditional Hardy Wright "Definition-Theorem-P1oof " style
[100], although we do give proofs to most of the theorems . We believe this is
the most. suitable way to present mathematical material to computing profes-
sionals. As Donald Knuth [121] pointed out in 1974 : "It has often been sai d
that a. person does not really understand something until he teaches it t o
someone else. Actually a person does not really understand something unti l
he can teach it to a computer . The author strongly recommends readers
to implement all the algorithms and methods introduced in this book on a
computer using a. mathematics (computer algebra) system such as Maple i n
order to get a better understanding of the ideas behind the algorithms and
methods . A small number of exercises is also provided in some sections . and
it is worthwhile trying all of them .
The book is intended to be self-contained with no previous knowledg e
of number theory and abstract algebra assumed . although some familiarity
with first, year undergraduate mathematics will be helpful . The book is suit-
able either as a text for an undergraduate/postgraduate course in Numbe r
Theory/Mathematics for Computing/Cryptography. or as a basic reference
researchers in the field.
Acknowledgements
I started to write this book in 1990 when I was a lecturer in the School of
Mathematical and Information Sciences at La Trobe University . Australia .
I completed the book when I was at the University of York and finalized i t
at Coventry and Aston Universities . all in England. I am very grateful t o
Prof. Bertram Mond and Dr. John Zeleznikow of the School of Mathemat-
ical and Information Sciences at La. Trobe University . Dr. Terence Jackson
of the Department of Mathematics and Prof . Jim Austin of the Department
of Computer Science at the University of York, Prof. Glyn James. Mr. Brian
Aspinall and Mr. Eric Tatham of the School of Mathematical and Informa-
tion Sciences at Coventry University, and Prof. David Lowe and Dr . Ted
Elsworth of Computer Science and Applied Mathematics at Aston Univer-
sity in Birmingham for their many fruitful discussions. kind encouragement
and generous support . Special thanks must be given to Dr. Hans Wossner
and Mr . Andrew Ross at Springer-Verlag Berlin/Heidelberg and the referees
of Springer-Verlag, for their comments, corrections and suggestions . During
the long period of the preparation of the book . I also got much help in on e
way or another from, whether they are aware of it, or not, Prof. Eric Bach of
the University of Wisconsin at Madison . Prof. Jim Davenport of the Univer-
sity of Bath . Prof. Richard Guy of the University of Calgary. Prof. Martin
Hellman of Stanford University . Dr. David Johnson of ATkT Bell Labo-
ratories . Prof. S . Lakshmivarahan of the University of Oklahoma, Dr . Ajie
Lenstra. of Bell Communication Research . Prof. Hendrik Lenstra Jr . of the
University of California at Berkeley. Prof. Roger Needham and Dr. Richard
Pinch of the University of Cambridge . Dr. Peter Pleasants of the Univer-
sity of the South Pacific (Fiji), Prof. Carl Pomerance of the University of
Georgia, Dr . Herman to Riede of the Centre for Mathematics and Computer
Science (CWI), Amsterdam, and Prof . Hugh William of the University of
Manitoba. Finally. I would like to thank Mr. William Bloodworth (Dallas ,
Texas) . Dr. John Cosgrave (St . Patrick's College, Dublin) . Dr. Gavin Doherty
(Rutherford Appleton Laboratory, Oxfordshire) . Mr. Robert Pargeter (Tiver-
ton, Devon) . Mr . Alexandros Papanikolaou (Aston University, Birmingham) .

xii
Preface to the First Editio n
and particularly Prof. Richard Brent (Oxford University Computing Labora-
tory) . Dr. Rodney Coleman (Universite Joseph Fourier, Grenoble) and Prof .
Glyn James (Coventry University) for reading the various versions of th e
book. As communicated by Dr . Hans wossner: nothing is perfect and no -
body is perfect . This book and the author are no exception . Any comments .
corrections and suggestions from readers of the book are especially very wel-
come and can be sent to the author either by ordinary mail or by e-mail t o
s .yan@aston .ac .uk .
Birmingham. February 2000
S. Y. Y .
Table of Content s
1 .
Elementary Number Theory	
1
1.1
Introduction	
1
1 .1.1
What is Number Theory?	
1
1 .1 .2
Applications of Number Theory	
13
1 .1 .3
Algebraic Preliminaries	
14
1.2
Theory of Divisibility	
2 1
1 .2 .1
Basic Concepts and Properties of Divisibility	
21
1 .2.2
Fundamental Theorem of Arithmetic	
27
1 .2.3
Mersenne Primes and Fermat Numbers	
33
1 .2.4
Euclid's Algorithm	
40
1 .2.5
Continued Fractions	
44
1 .3
Diophantine Equations	
52
1.3.1
Basic Concepts of Diophantine Equations	
52
1.3.2
Linear Diophantine Equations	
54
1 .3.3
Pell's Equations	
57
1 .4
Arithmetic Functions	
63
1 .4.1
Multiplicative Functions	
63
1 .4.2
Functions 7(n), a(n) and s(n)	
66
1 .4.3
Perfect . Amicable and Sociable Numbers	
7 1
1 .4 .4
Functions 6(n) . z\(n) and µ(n) 
79
1.5
Distribution of Prime Numbers	
8,5
1 .5 .1
Prime Distribution Function ;r(x)	
85
1 .5 .2
Approximations of
(r) by x/ in x	
87
1 .5 .3
Approximations of 'T(x) by Li(r)	
94
1.5 .4
The Riemann (-Function c(s) 
95
1 .5 .5
The nth Prime	
104
1 .5.6
Distribution of Twin Primes	
106
1.5.7
The Arithmetic Progression of Primes	
110
1 .6
Theory of Congruences	
111
1.6.1
Basic Concepts and Properties of Congruences	
11 1
1.6.2
Modular Arithmetic	
118
1.6.3
Linear Congruences	
123
1 .6 .4
The Chinese Remainder Theorem	
130
1.6 .5
High-Order Congruences	
133

Table of Contents
Table of Contents
xv
1.6.6
Legendre and Jacobi Symbols 
139
2.6
Miscellaneous Algorithms in Number Theory 
287
2.6 .1
Algorithms for Computing 7r(x)	
1 .6 .7
Orders and Primitive Roots 
150
287
1 .6 .8
Indices and kth Power Residues 
155
2.6 .2
Algorithms for Generating Amicable Pairs 
292
1 .7
160
2.6 .3
Algorithms for Verifying Goldbach's Conjecture 
295
Arithmetic of Elliptic Curves 
160
2.6.4
Algorithm for Finding Odd Perfect Numbers 
299
1.7.1
Basic Concepts of Elliptic Curves 
1.7.2
Geometric Composition Laws of Elliptic Curves 
163
2 .7
Bibliographic Notes and Further Reading 
300
1 .7.3
Algebraic Computation Laws for Elliptic Curves 
164
3 .
Applied Number Theory in Computing/Cryptography 
303
1.7.4
Group Laws on Elliptic Curves 
168
3.1
Why Applied Number Theory? 
303
1.7.5
Number of Points on Elliptic Curves 
169
1 .8
171
3.2
Computer Systems Design 
305
Bibliographic Notes and Further Reading 
3 .2.1
Representing Numbers in Residue Number Systems 
305
2.
Computational/Algorithmic Number Theory 
173
3 .2.2
Fast Computations in Residue Number Systems 
308
2.1
Introduction 
173
3 .2.3
Residue Computers 
312
174
3 .2 .4
Complementary Arithmetic 
315
2 .1 .1
What is Computational/Algorithmic Number Theory? 
2.1 .2
Effective Computability 
177
3.2 .5
Hash Functions 
317
2.1 .3
Computational Complexity 
181
3.2 .6
Error Detection and Correction Methods 
321
2.1 .4
Complexity of Number-Theoretic Algorithms 
188
3.2.7
Random Number Generation 
326
Cryptography and Information Security 
2 .1.5
Fast Modular Exponentiations 
194
3 .3
332
2 .1.6
Fast Group Operations on Elliptic Curves 
198
3.3.1
Introduction 
332
2.2
202
3.3.2
Secret-Key Cryptography 
333
Algorithms for Primality Testing 
202
3.3.3
Data/Advanced Encryption Standard (DES/AES) 
344
2 .2 .1
Deterministic and Rigorous Primality Tests 
2 .2 .2
Fermat's Pseudoprimality Test 
206
3.3.4
Public-Key Cryptography 
348
2 .2.3
Strong Pseudoprimality Test 
208
3 .3.5
Discrete Logarithm Based Cryptosystems 
354
2.2 .4
Lucas Pseudoprimality Test 
215
3 .3.6
RSA Public-Key Cryptosystem 
3.58
2.2 .5
Elliptic Curve Test 
222
3 .3.7
Quadratic Residuosity Cryptosystems 
373
2.2.6
Historical Notes on Primality Testing 
225
3 .3.8
Elliptic Curve Public-Key Cryptosystems 
379
2 .3
228
3 .3 .9
Digital Signatures 
385
Algorithms for Integer Factorization 
3.3 .10 Digital Signature Standard (DSS) 
228
392
2.3.1
Complexity of Integer Factorization 
2.3 .2
Trial Division and Fermat Method 
232
3.3 .11 Database Security 
395
2 .3 .3
Legendre's Congruence 
234
3.3 .12 Secret Sharing 
399
2 .3 .4
Continued FRACtion Method (CFRAC) 
237
3.3 .13 Internet/Web Security and Electronic Commerce 
403
2.3.5
Quadratic and Number Field Sieves (QS/NFS) 
240
3.3.14 Steganography 
409
2.3.6
Polland's -rho" and "p — 1" Methods 
244
3.3.1.5 Quantum Cryptography 
410
2.3.7
Lenstra's Elliptic Curve Method (ECM) 
251
3 .4
Bibliographic Notes and Further Reading 
411
2 .4
Algorithms for Discrete Logarithms 
2.54
255
Bibliography 
41 .5
2.4.1
Shanks' Baby-Step Giant-Step Algorithm 
2.4.2
Silver—Pohlig--Hellman Algorithm 
258
Index 
429
2.4.3
Index Calculus for Discrete Logarithms 
262
2 .4.4
Algorithms for Elliptic Curve Discrete Logarithms 
266
2 .4..5
Algorithm for Root Finding Problem 
270
2 . .5
Quantum Number Theoretic Algorithms 
273
2 .5 .1
Quantum Information and Computation 
273
2 .5 .2
Quantum Computability and Complexity 
278
2 .5.3
Quantum Algorithm for Integer Factorization 
279
2.5.4
Quantum Algorithms for Discrete Logarithms 
285

Notatio n
All notation should be as simple as the nature of the operations to whic h
it is applied .
CHARLES BABBAGE (1791—1871 )
Notation
Explanation
N
set of natural numbers: N = {1, 2, 3, . - • }
Z
set of integers (whole numbers) : Z = {0, ±n : n E N}
Z +
set. of positive integers : Z + = N
7L>1
set of positive integers greater than 1 :
7G> i ={n :nEZandn>1}
a
set of rational numbers : Q=
b : a. b E Z and b
0
R
set of real numbers :
li'={n+0.drdzd3 ••• :nEZ. d1E{0,1,--- ,9}
and no infinite sequence of 9's appears }
C
set of complex numbers :
C={a+bi :a,bE
andi=-/-1 }
Z/nZ
also denoted by Z a, residue classes modulo n :
a ring of integers: a field if n is prime
(Z/nZ)*
multiplicative group ; the elements of this group are th e
elements in Z/nZ that are relatively prime to n :
(Z/nZ)* = {[a]„ E Z/nZ :
gcd(a,n.) = 1} .
p
finite field with p elements, where p is a prime numbe r
~v
finite field with q = a prime power
IC
(arbitrary) field
ring

xviii
Notation
Notation
six
c
B, ,
F,,
lip
R ~.
oc
f(:r)
g(x)
(c. *) = (1-t, *)
1
el,
(lk
E bb (M)
D i, (C)
group
order of group
Bernoulli numbers :
Fermat numbers : F,, = 23 + 1, n > 0
lersenne primes :
1111, = 2' – 1 is prime whenever p is prim e
square root of x
kth root of x
asymptotic equality
approximate equality
infinity
implication
equivalence
blank symbol : end of proof
space
probability measure
cardinality of set S
member of
proper subse t
subset
binary operations
binary operation (addition) ; exclusive or (XOR)
binary operation (multiplication )
f (x) and g(x) are asymptotically equal
(g,*) and ("H .*) are isomorphi c
undefined
encryption key
decryption key
encryption process C = ,(M) .
where 11 is the plaintex t
decryption process ..1 1- = D d ,, (C) ,
where C is the ciphertext
n!
:rk
kP
e
Iog b x
log x
In x
exp(x)
al b
a) b
p" II n
xmod n
x=ymod n
y (mod n)
x
tj (mod ii)
function of x
inverse of f
binomial coefficient
integratio n
logarithmic integral : Li(x) =
sum : XI + x-2 +
product : x1 x2 - - x„
factorial : n(n–1)(n–2)•••3 .2 . 1
x to the power k
kP = P :i P' ? . . .
. P, where P is a point (x, y) on
k summand s
an elliptic curve E : y2 = x3 + ax + b
the point at infinity on an elliptic curve E over a fiel d
the transcendental number e =
1
2.7182818
„>o n .
logarithm of x to the base b (b
1) : x = b tOr t
binary logarithm : loge x
natural logarithm : log e x
exponential of x :
—
,x>o n !
a divides b
a does not divide b
nbut1P
1 { n
greatest, common divisor of (a, b)
least common multiple of (a, b )
the greatest integer less than or equal to x
the least integer greater than or equal to x
x
remainder: x — n
_n -
x is equal to y reduced to modulo n
x is congruent to y modulo n
x is not congruent to p modulo n
+
n+ 1
1
B,i+ . . .+
n
B 1 +Bo=0
dt
In t

xx
xk mod n.
kP mod n
ord„(a)
indg ,,,a
Y(n)
o-(n)
s(n)
0(n)
c(s)
K(k) 1,
Notation
residue class of a n odulo n
addition modulo n.
subtraction modulo n-
multiplication modulo n
x to the power k modulo 1 1
kP modulo n
order of an integer a modul o
also denoted by ord(a, n)
index of a to the base g modulo n :
also denoted by ind9a whenever n
number of primes less than or equal to x :
,; (x)
E
1
number of positive divisors of n : )-(n)
E 1
sum of positive divisors of n: o-(n) = E d
sum of proper divisors of n: s(n) = a(n) — n
Euler's totient function: 0(n) =
E
1
Carmichael's function :
a(n) = lcln (\(pi')A(pa )
. . .A(p
Mobius function
1
Riemann zeta-function : S(s) = f s ,
,1=1 Ti
where s is a complex variable
Legendre symbol, where p is prim e
Jacobi symbol, where n is composite
set of all quadratic residues of n
set, of all quadratic nonresidues of n.
Jn = {a E (Z/nZ)` : () =1 }
set of all pseudosquares of n :
= Jn — Q n
set, of all kth power residues of n, where k > 2
set of all kth power nonresidues of n, where k > 2
Notation
[qo . q1 , q2 ,
, q,,]
finite simple continued fractio n
Cr. =
k-th convergent of a continued fraction
[go, qi, q2 .
]
infinite simple continued fractio n
[gogl, . .
,gk .gk+l,qh+2,
.
. '
periodic simple continued fraction
class of problems solvable in deterministi c
polynomial time
class of problems solvable in nondeterministi c
polynomial time
class of problems solvable in random polynomia l
time with one-sided errors
class of problems solvable in random polynomial
time with two-sided errors
class of problems solvable in random polynomial
time with zero errors
upper bound : f(n) = O(g(n)) if there exists some
constant c > 0 such that f (n) < c g(n)
upper bound that is not asymptotically tight :
f(n) = O(g(n)), do > 0 such that f(n) < c g(n)
low bound: f (n) = .2(g(n)) if there exists a
constant c such that f (n) >
g(n)
tight bound: f (n) = 0(n) if f (n) = O(g(n))
and Pi)) = .2(g(n))
polynomial-time complexity measured in terms of
arithmetic operations. where k > 0 is a constant
q ((logN) k ) polynomial-time complexity measured in terms o f
bit operations. where k > 0 is a constant
q ((log N)' 1"g N)
superpolynomial complexity, where c > 0 is a constan t
q (exp (cv/log N log log N
subexponential complexit
0 (exp (cy/log A log log 1' ~l = (NeVlog log N/ log N)
0 (exp(x))
exponential complexity. sometimes denoted by 0 (e )
exponential complexity measured in terms of
bit operations : O (N') = 0 (2E log N)
,
where e > 0 is a constant
CFRAC
Continued FRACtion method (for factoring )
ECM
Elliptic Curve Method (for factoring )
)) ifn = IlK'
i= 1
n;
A P
s
xed
RP
BP n
zPP
0 (N`)

Notatio
NFS
QS/MPQS
ECPP
DES
AES
DSA
DSS
RSA
WW W
Number Field Sieve (for factoring )
Quadratic Sieve/Multiple Polynomial Quadrati c
Sieve (for factoring )
Elliptic Curve Primality Proving
Data. Encryption Standard
Advanced Encryption Standard
Digital Signature Algorithm
Digital Signature Standar d
Rivest-Shamir-Adlelnan
World Wide Web
1. Elementary Number Theor y
The elementary theory of numbers should be one of the very best subjects
for early mathematical instruction . It demands very little previous knowl-
edge, its subject matter is tangible and familiar; the processes of reasonin g
which it employs are simple, general and few ; and it is unique among th e
mathematical sciences in its appeal to natural human curiosity .
G . H. HARDY (1877 1947 )
This chapter introduces the basic concepts and results of the elementar y
theory of numbers. Its purpose is twofold :
— Provide a solid foundation of elementary number theory for Computational,
Algorithmic ; and Applied Number Theory of the next two chapters of the
book .
— Provide independently a self-contained text of Elementary Number Theory
for Computing; or in part a text of Mathematics for Computing .
1 .1 Introduction
In this section, we shall first give a brief review of the fundamental ideas of
number theory and then present some mathematical preliminaries of elemen-
tary number theory.
1 .1 .1 What is Number Theory ?
Mathematics is the Queen of the sciences, and number theory is the Queen
of mathematics .
C. F . GAuss 17771855)

2
1 . Elementary Number Theo
1 .1 Introduction
3
Number theory, in mathematics, is primarily the theory of the properties
of integers (whole numbers), such as parity, divisibility, primality, additivit y
and multiplicativity, etc . To appreciate the intrinsic mathematical beauty o f
the theory of numbers, let us first investigate some of the properties of the
integers (the investigation is by no means complete : more detailed discussions
will be given later in the book) .
(I) Parity. Perhaps the simplest property of an integer is its parity, tha t
is, whether it is odd or even. By definition, an integer is odd if dividing i t
by 2 leaves a remainder of 1 : otherwise. it is even. Of course, if the binary
representation of an integer is readily available for inspection . division by 2
can be avoided, since we need only look to see if the integer's rightmost bit i s
a 1 (indicating oddness), or a 0 (indicating evenness) . Two integers m and n
have the same parity if both rn and it are even or odd, otherwise. they have
opposite parity. Some well-known results, actually already known to Euclid' ,
about the parity property of integers are as follows :
(1) The sum of two numbers is even if both are even. or both are odd . More
generally. the sum of n even numbers is even, the sum of n odd numbers
is even if n is even and the sum of n odd numbers is odd if n is odd .
(2) The difference of two numbers is even if both have the same parity . More
generally. the difference of n even numbers is even, the difference of n
odd numbers is even if n is even and the difference of it odd numbers is
odd if n is odd .
(3) The product of two numbers is even if at least one of them is even. More
generally, the product of n numbers is even if at least one of them is even .
That is,
even + even ± even + ± even = even ,
n even numbers, n is eve n
Euclid (about 350 B .C.) was the author of the most successfu l
mathematical textbook ever written . namely his thirteen books
of Elements, which has appeared in over a thousand different edi-
tions from ancient to modern times . It provides an introduction to
plane and solid geometry as well as number theory . For example ,
some properties of the parity of integers are given in Proposition s
21-29 of Book IX. Euclid's algorithm for computing the greates t
common divisor of two and three positive integers is found in Boo k
VII Proposition 2 and Proposition 3 . respectively, and his proofs for the infinitude
of primes and a sufficient condition for even numbers to be perfect are found i n
Book IX Proposition 20 and Proposition 36 . respectively . The "Axiom-Definition-
Theorem-Proof" style of Euclid's work has become the standard for formal math -
ematical writing up to the present day. (All portrait images in this book, unles s
stated otherwise, are by courtesy of O 'Connor and Robertson [177] .)
odd x odd x odd x ' ' ' x odd = odd ,
all odd
even x odd x odd x
x odd = even .
at least one even
Example 1 .1 .1 . Following are some examples :
100+4+54+26+12= 196 ,
100-4-54-20-18=4 ,
101+1+13+15+17+47=194,
101-1-13-15-17-47=8 ,
101+1+13+15+17+47+3=197 ,
101-1-13-M-17-47-3=5 ,
23 x 67 x 71 x 43 = 4704673 .
23x67x72x43=4770936 .
It is worthwhile pointing out that the parity property of integers has im-
portant applications in error detection and correction codes, that are useful i n
computer design and communications . For example, a simple error detection
and correction method, called parity check, works as follows. Let xrx2 . . . xn
be a binary string (codeword), to be sent (from the main memory to th e
central processing unit (CPU) of a computer, or from a computer to other
computers connected to a network) . This code is of course in no way an erro r
detection and correction code . However, if an additional bit 1 (respect to 0)
is added to the end of the codeword when the number of 1's in the codewor d
is odd (respect to even), then this new code is error detecting . For instance,
let the two codewords be as follows :
Ci = 1101001001 .
C2 = 1001011011 .
then the new codewords will become
C~ = 11010010011 ,
C.: = 10010110110 .
These codes apparently have some error detecting function . For example, if
after transmission C. becomes CI = 11010110110, then we know there is an
error in the transmitted code. since
1 + 1 + 0 + 1 + 0 + 1 + 1 + 0 + 1 + 1 + 0 = 7 mod 2 O .
n odd numbers, n is even
odd+odd+ odd±'''±odd=even .
n odd nmbers, a is od d
odd+odd+ odd±''±odd=odd,

1 . Elementary Number Theory
1 .1 Introduction
5
(The notation a mod a is defined to be the remainder when a is divided b y
a : for example. 10 mod 3 = 1 .) Of course, the new codes are still not erro r
correction codes . However, if we arrange data in a rectangle and use parit y
bits for each row and column. then a single bit error can be corrected .
(II) Primality. A positive integer n > 1 that has only two distinct factors . 1
and o itself (when these are different) . is called prime ; otherwise, it is called
composite . It is evident that a positive integer n, > 1 is either a prime or a
composite. The first. few prime numbers are: 2 .3,5,7.11, 13.17.19, 23 . It i s
interesting to note that primes thin out: there are eight up through 20 bu t
only three between 80 and 100, namely 83,89 and 97 . This might lead one to
suppose that there are only finitely many primes . However as Euclid proved
2000 years ago there are infinitely marry- primes. It is also interesting to not e
that 2 is the only even prime: all the rest are odd . The prime pairs (3, 5) .
(5, 7) and (11.13) are twin primes of the form (p. p + 2) where p and p + 2
are prime; two of the largest known twin primes (both found in 1995) are :
570918348' 10"120 + 1 with .5129 digits and 242206083 . 2388" ± 1 with 11713
digits. It is not known if there are infinitely many twin primes : however, it ha s
been proved by J . R . Chen that there are infinitely many pairs of integers
(p, p + 2), with p prime and p + 2 a product of at most two primes. The
triple primes are those prime triples of' the form either (p, p + 2, p + 4) or
(p, p+2, p+6) . For example, (3 . 5, 7) is a prime triple of the form (p. p+2 . p+
4), whereas the prime triples ( .5,7,11), (11.13 .17), (17.19, 23), (41 .43, 47) .
(101,103, 107). (107.109, 113). (191,193,197), (227, 229, 233), (311 .313.317) ,
(347, 349, 353), (347.349, 3:53) are all of the form (p, p+2. p+6). It is amusing
to note that there is only one prime triple of the form (p. p+2, p +4), namely
(3,5,7) ; however, we do not know whether or not there are infinitely many
prime triples of the form (p. p + 2 . p + 6). There are other forms of prim e
triples such as (p, p+4. p+ 6) ; the first ten triples of this form are as follows :
(7,11 .13). (13,17,19), (37 .41.43) . (67.71 .73), (97 .101,103) . (103.107.109) ,
(193,197,199), (223.227.229) . (277.281 .283) . and (307,311.313) . Again, we
also do not know whether or not there are infinitely many prime triples of
this form. According to Dickson [65) . the ancient Chinese mathematicians .
even before Fermat (1601 1665) . seem to have known tha t
p E Primes	
> p (2" — 2) .
(1 .1 )
However. there are some composites
n that are not prime but satisfy th e
condition that n (2" — 2) ; for example . n = 341 = 11 . 31 is not prime.
but 341 (2331 — 2). It is not an easy task to decide whether or not a large
number is prime. One might think that to test whether or not the numbe r
n is prime. one only needs to test all the numbers (or just the primes) up t o
a. Note that the number n has about 3 = loge bits. Thus for a number
a with 3 bits . this would require about exp(3/2) bit operations since o =
exp O logo) = exp(3/2) . and hence, it is inefficient and essentially useless
for large values of n . The current best algorithm for primality testing needs
at most ,3'11'3g I°g 3 bit operations, where c is a real positive constant .
(III) Multiplicativity . Any positive integer ra > 1 can be written uniquel y
in the following prime factorization form :
n=p 'p' . . .pF
(1 .2 )
where pr < p2 < < pa are primes. and a1 . a> . -
a. are positive integers .
This is the famous Fundamental Theorem of Arithmetic; it was possibly
known to Euclid (around 350 B .C .) . but it was first clearly stated and prove d
by Gauss (1777 1855) . It can be very easy to factor a positive integer is if
it is not very big; the following are the prime factorizations of o. for n =
1999 .2000 .-• .2010 :
1999 = 1999
2000 = 2 1 . 53
2001 = 3 . 23 . 29
2002=2 . 7 . 11 . 13
2003 = 2003
2004=2 2 . 3167
2005 = 5 401
2006=2 . 17 . 59
2007 = 32 . 223
2008 = 2 3 . 251
2009 = 72 . 41
2010=2 . 3 . 5 . 67 .
However, it can be very difficult to factor a large positive integer (e .g ., with
more than 100 digits at present) into its prime factorization form - a task eve n
more difficult than that of primality testing. The most recent and potentially
the fastest factoring method yet devised is the Number Field Sieve (NFS) ,
which can factor an integer N in approximately
exp (c(log V) 1 3 (loglogY)2/3)
(1 .3)
bit operations. where c is a positive real constant (an admissible value is
c = (64/9) 1" 1 .9 . but this can be slightly lowered to c = (32/9) 1/3
1 .5
for some special integers of the form N = crr c + c28" : see Huizing [1071 )
and exp stands for the exponential function. By using the NFS. the 9th
Fermat number F, = 2 29 + 1, a number with 155 digits, was completel y
factored in 1990 . (However . the 12th Fermat number F,2 = 22'- + 1 has
still not completely been factored. even though its five smallest prime factor s
are known .) The most recent record of NFS is perhaps the factorization . by
a group led by Herman to Ride [206) in August 1999 of the random 15 5
digit (512 bit) number RSA-155. which can be written as the product. of two
78-digit primes :
10263959282974110577205419657399167.59007165678080 _
38066803341933521790711307779 .
106603488380l684548209272203600128786792079585759 _
89291522270608237193062808643 .

6
1 . Elementary Number Theory
1.1 Introduction
It is interesting to note that a number of recent proposals for cryptographi c
systems and protocols, such as the Rivest Shamir—Adleman (RSA) public-
key cryptography, rely for their security on the infeasibility of the intege r
factorization problem . For example, let M be a message . To encrypt the
message Al, one computes
C Mr (mod n),
(1.4)
where e is the encryption key, and both e and n are public. (The notation
a E. b (mod n) reads "a is congruent to b modulo n" . Congruences will be
studied in detail in Section 1 .6.) To decrypt the encrypted message C, one
computes
>7 C d (mod n),
(1 .5 )
where d is the private decryption key satisfyin g
ed
1 (mod 0(n)) .
(1.6)
where M(n) is Euler's m-function (O(n), for n > 1 . is defined to be the num-
ber of positive integers not exceeding n which are relatively prime to n;
see Definition 1 .4.6) . By (1 .6), we have cd =
1 + kO(n) for some integer
k . By Euler's theorem (see Theorem 1 .244), AI'(") - 1 (mod n), we have
Mko(") E
(mod n) . Thus.
Cd - ,If"d -1ilr+kc,(") = Al (mod n) .
(1 .7)
For those who do not have the private key but can factor a, say, e.g., n. = pq.
they can find d by computing
d - er (mod M (n)) - e
1 (mod (p — 1) (q — 1)),
(1 .8)
and hence, decrypt the message .
(IV) Additivity. Many of the most difficult mathematical problems are in
additive number theory : Goldbach's conjecture is just one of them . On 7th
June 1742 the German-born mathematician Christian Goldbach (1690-1764 )
wrote a letter (see Figure 1 .1) to the Swiss mathematician Euler (then both
in Russia) . in which he proposed two conjectures on the representations o f
integers as the suns of prime numbers . These conjectures may he rephrased
as follows :
(1) Every odd integer greater than 7 is the suns of three odd prime numbers .
(2) Every even integer greater than 4 is the sum of two odd prime numbers .
They may also be stated more strongly (requiring the odd prime numbers to
be distinct) as follows :
(1) Every, odd integer greater than 17 is the sum of three distinct odd prime
numbers .
~,S
~).
!h
i 1
J/' y Jet WU#
'I lAJitJ~ C.ul
t{
4a+
:sl
z
W w`/tY= t
rt, ` ..I.
J
c. ezor-Gffri.i
. n..g6 sar -
eo9
S C
Y
O#'~ f~µ'~l(i't/ x..lYiif I/r.v3. detIr,IM•az urIDV'
=~~
(
vlx„ly . /
~1s 4Al~r..4,r fIIYAJ uu.YJ :O[-.
!,&n u
/Yla 0161 _
t.
x .~no azl.JJ.tna.
x.t"x `'.t
&co. w'u r t°.t ci-
3,~i '!da
a
,
fem.._
t
- 5
t
/''-''--
Figure
Figure 1.1 . Goldbach's letter to Euler
(2) Every even integer greater than 6 is the sum of two distinct odd prime
numbers .
The following are some numerical examples of these conjectures :
9=3+3+3
6=3+ 3
11=3+3+5
8=3+ 5
13=3+3+7=3+5+5
10=3+7=5+ 5
15=3+5+7=5+5+5
12=5+ 7
17 = 3+3+11=3+7+7=5+5+7
14=3+1 1
19 = 3+3+13=3+5+11=5+7+7
16=3+13=5+1 1
21 = 3+5+13=3+7+11=5+5+11
18=5+13=7+1 1
=7+7+7 .
It is clear that the second conjecture implies the first . As a result, the firs t
became known as the little Goldbach conjecture (or the ternary Goldbach
`
H	
4..
d.!/
f=
,., . .
rrr.?
S; ,rrl7
6 ,.. .3
.s1
. ., .r .a	
flfl
g
,

8
1 . Elementary Number Theory
1 .1. Introduction
9
conjecture) . whereas the second became known as the Goldbach conjectur e
(or the binary Goldbach conjecture) . Euler believed the conjectures to b e
true but was unable to produce a proof . The first great achievement on th e
study of the Goldbach conjecture was obtained by the two great British math-
ematicians, Hardy' and Littlewood ; using their powerful analytic method
[99] (known as the `'Hardy-Littlewood-Ramanujan method`, or the "Hardy -
Littlewood method", the "circle method" for short) they proved in 1923 tha t
If a certain hypothesis (a natural generalization of Riernann's hy-
pothesis concerning the complex zeros of the (-function) is true, the n
every sufficiently large odd integer is the sum of three odd primes ,
and almost all even integers are sums of two primes .
Godfrey Harold Hardy (1877 1947), was born in Cranleigh .
England, and was admitted to Trinity College. Cambridge in
1896. He studied and taught there until 1919, at which dat e
e was appointed as Savilian professor of geometry at Oxford .
He spent about 10 years at Oxford and one year at Princeton ,
then he returned to Cambridge in 1931 and remained ther e
until his death. Hardy collaborated with his friend john E .
Littlewood, an eminent British mathematician also at Cam-
) bridge University, for more than 35 years surely the mos t
_ mils successful collaboration ever in mathematics! They wrote a
hundred joint papers, with their last publication a year after Hardy's death . In
the 1920s the eminent German mathematician Edmund Landau (1877–1938) ex-
pressed the view that "the mathematician Hardy-Littlewood was the best in th e
world, with Littlewood the more original genius and Hardy the better journalist" .
Someone once even jokingly said that "nowadays . there are only three really great
English mathematicians : Hardy, Littlewood and Hardy-Littlewood " . Hardy made
significant contributions to number theory and mathematical analysis, and receive d
many honours for his work, among them the prestigious Copley Medal of the Roya l
Society in 1947: he learnt of this award only a few weeks before his death . Hardy 's
book An Introduction to the Theory of Numbers [100] is classic and possibly th e
best in the field. and influenced several generations of number theorists in the world .
Another book by Hardy A Mathematician 's Apology [98] is one of the most vivi d
descriptions of how a mathematician thinks and the pleasure of mathematics .
In 1937, without appealing to any form of Riernann's hypothesis, the grea t
Russian mathematician I . M. Vinogradovproved unconditionally tha t
Every sufficiently large odd integer can be written as the sum of thre e
odd prime numbers .
This is the famous V'inogradov's Three-Prime Theorem for the little Goldbach
conjecture. As for the Goldbach conjecture . the best result is still Chen' s
theorem (see Chen [46] . or Halberstarn and Richert [97]) . in honour of the
Chinese mathematician J . B . Chen' :
Every sufficiently large even integer can be written as the sum of a
prime and a product of at most two primes .
Exercise 1 .1 .1 . Let a representation of an even number as the sum of tw o
distinct primes (i .e . . n = pi + p2. n even,
pr < p2) or a representation of
an odd number as the sum of three distinct primes (i .e., n = pr + p2 +
van Matveeyich Vinogradov (18911983), a great Russian mathe -
ratician, studied at. St Petersburg and obtained his first degree in
914 and master's degree in 1915, respectively . Vinogradov taught
at the State University of Perm from 1918 to 1920 . and returned
to St Petersburg and was promoted to professor at the State Uni-
versity of St Petersburg in 1925, becoming head of the probabilit y
and number theory section there . He moved to Moscow to become
the first director of the Steklov Institute of Mathematics in 1934 ,
a post he held until his death . Vinogradov used trigonometric sums to attack deep
problems in analytic number theory . particularly the Goldbach conjecture.
Jing Run Chen (1933 1996), one of the finest mathematicians i n
China and a distinguished student of the eminent Chinese math-
ematician Loo Keng Hua (1909-1985), died on the 19th of Marc h
996 after fighting disease for many years . In about 1955 Chen
sent Hua (then the Head of the Institute of Mathematics of th e
Chinese Academy of Sciences . Beijing), a paper on Tarry's prob-
ern. which improves Hua's own result on the problem . It was this
paper that Hua decided to bring him from Xia Men University in a
Southern China Province to the Institute in Beijing. Chen devoted himself' entirely
to mathematical research, particularly to some hard problems in number theory ,
such as Warin g's problem . Goldbac h's conjecture and the twin prime problem, and
even during the cultural revolution (1966-1976), a very chaotic period over the long
Chinese history, he did not stop his research in mathematics . During that difficul t
period, he worked on number theory, particularly on Goldbac h 's conjecture almost
all day and all night, in a small dark room (about 6 square meters) : there were n o
electric lights (he had to use the kerosene to light the room in the night) . no table
and no chairs in that room (Ire read and wrote by setting at the bed using a plat e
on his legs) . just a single bed and his many hooks and manuscripts; It was in this
room that he completed the final proof of the famous Chen's theorem. (Photo by
courtesy of the Chinese Mathematical Society. )
John Edensor Littlewood (1885 1977) . is best known for his 3 5
years collaboration with G . H. Hardy on summability. function
theory and number theory . Littlewood studied at Trinity College .
Cambridge. From 1907 to 1910 he lectured at the University of
Manchester. He became a Fellow of Trinity College (1908) return -
there in 1910 . He was to become Rouse Ball professor of math -
ematics there in 1928 . In World War I Littlewood also served i n
e Royal Garrison Artillery. Hardy once wrote of Littlewood tha t
he knew of no one else who could command such a combination of insight. techniqu e
and power. Note that Littlewood also wrote a very readable book A Mathemati-
cian's Miscellany [144] (a collection of Littlewood s 15 articles in mathematics) ,
published in line with Hardy's A Mathematician 's Apology.

10
1 . Elementary Number Theory
1.1 Introduction
11
p3 .n odd,pi < P2 < p3) be a Goldbach partition of n, denoted by G(n) . Let
also IG(n)I be the number of partitions of n. Then
G(100)=3+97=11+89=17+83 =29+ 71=41 + 59=47+53 ..
G(101) =3+19+79=3+31+67 = 3+37 + 61=5 + 7 + 89
=5+13+83=5+17+79 = 5+ 23+ 73=5 + 29 + 67
=5+37+59=5+43+53 = 7+ 11 + 83=7 + 23 + 71
=7+41+53=11+17+73 = 11+ 19 + 71=11 + 23 + 6 7
=11+29+61=11+31+59 = 11+37+ 53=11 + 43 + 47
=13+17+71=13+29+59 = 13+ 41 + 47=17 + 23 + 61
=17+31+53=17+37+47 = 17+ 41 + 43=19 + 23 + 59
=19+29+53=23+31+47 = 23+37 + 41=29 + 31 + 41 .
Hence IG(100)1 = 6 . and IG(101)[ = 32 .
(1) Find the values for IG(1000)l and 1G(1001)! . (Hint: 1G(1001)1 > 1001 .)
(2) List all the partitions of G(1000) and G(1001) .
(3) Can you find any patterns from your above computation ?
There are, of course, many other fascinating properties of positive integer s
that interest mathematicians . The following well-known story of the "Hardy—
Ramanujans taxi number" might also give us an idea of what number theory
is. One day Hardy went to visit Ramanujan in a hospital in England . When he
arrived, he idly remarked that the taxi in which he had ridden had the licens e
number 1729, which, he said. seemed to him a rather uninteresting number .
Ramanujan replied immediately that it is an interesting number, since it is th e
Srinivasa Ramanujan
(1887 1920) was one of India 's greatest
mathematical geniuses . He made substantial contributions to th e
analytical theory of numbers and worked on elliptic functions, con -
tinued fractions, and infinite series. Despite his lack of a formal
education, he was well-known as a mathematical genius in Madras
(the place where he lived) and his friends suggested that he shoul d
send his results to professors in England. Ramanujan first wrote
to two Cambridge mathematicians E . W. Hobson and H. F. Baker
trying to interest them in his results but neither replied . In January 1913 Ramanu-
jan then wrote to Hardy a long list of unproved theorems, saying that "I have had
no university education but I have undergone the ordinary school course . After
leaving school I have been employing the spare time at my disposal to work a t
mathematics ." It. did not take long for Hardy and Littlewood to conclude that Ra -
manujan was a man of exceptional ability in mathematics and decided to bring hi m
to Cambridge. Ramanujan arrived in Cambridge in April 1914 . Hardy was soon
convinced that. in terms of natural talent, Ramanujan was in the class of Euler
and Gauss . He worked with Hardy and made a series of outstanding breakthroughs
in mathematics, and was elected a Fellow of the Royal Society at the age of jus t
31 . It was Littlewood who said that every positive integer was one of Rarnanuja n's
personal friends. But sadly, in May 1917 . Ramanujan fell ill; he returned to Indi a
in 1919 and died in 1920, at the early age of 33 .
smallest positive integer expressible as a sum of two positive cubes in exactly
two different ways, namely, 1729 13 + 123 = 93 + 10 3 . (Ramanujan could
have pointed out that 1729 was also the third smallest Carmichael number! )
Hardy then naturally asked Ramanujan whether he could tell him the solution
of the corresponding problem for fourth powers . Ramanujan replied, after a
moment's thought, that he knew no obvious example, and supposed that th e
first such number must be very large. It is interesting to note that the solution
to the fourth power was known to Euler [7] : 635318657 = .594 + 1584 =
1334 + 1344 .
Exercise 1 .1 .2 . Let r(tn, n, s) denote the smallest integer that can be ex-
pressed as a sum of in positive (not necessarily distinct) n-th powers in s
different ways. Then we have
r(2,2,2)=50=5 .2 +5 22 =1~+72
x(2,3,2) = 1729 = 1 3 + 12 3 = 93 + 10 3
r(2, 4, 2) = 635318657 = 59 4 + 158 4 = 1334 + 134 4
r(6,4,4) =6625=14 +24 +2 4 +24 +24 +94 =24 +24 +24 +34 +74 +84
=24 +44 +44 +64 +74 +74 =34 +44 +64 +64 +64 + 74 .
Find an example for each of the following numbers :
r(3, 2, 2),
r(4, 2, 2),
r(5, 2, 2),
r(3, 3.2) .
r(2 .2, 3),
r(3, 4, 2),
r(3.5.2),
r(3, 6, 2) ,
r(2, 2, 4),
r(3, 3, 3) .
r(3.4, 3),
r(5, 5.3) .
Finally, we wish to remark that number theory is not only the oldes t
subject of mathematics, but also a most active and lively branch in mathe-
matics. It uses sophisticated techniques and deep results from almost all area s
of' modern mathematics; a good example would be the solution by Andrew
Wiles' to the famous Fermat's Last Theorem (FLT), proposed by the grea t
7
Andrew J. Wiles, a well-kown number theorist and algebraic ge-
l ometer, was born in 1953 in Cambridge, England . He attended
Merton College at the University of Oxford . starting from 1971 .
and received his BA there in 1974 . He then went to Clare Colleg e
at the University of Cambridge, earning his PhD there in 1980 .
under the supervision of John Coates . He emigrated to the U .S_ A .
in the 1980s and became a professor at Princeton University in
1982 . Wiles was elected a Fellow of the Royal Society . London in
1989 . He has recently received several prestigious awards in mathematics . includ-
ing the Wolf Prize and the U.S. National Academy of Sciences award in 1996. for
his proof of Fermat 's Last Theorem. It is interesting to note that Wiles became
interested in Fermat's Last Theorem at the age of ten, when he read the book The
Last Problem (by Eric Temple Bell, 1962), a book with only one problem and no
solution, in a Cambridge local library.

12
1. Elementary Number Theory
1.1 Introduction
13
French mathematician Fermat" 350 years ago . Wiles proof of Fermat's Last
Theorem employed almost all the sophisticated modern pure mathematica l
techniques .
It should also be noted that number theory has many different faces, an d
hence different branches . This means that number theory can be studied
from e .g.. an algebraic point of view . a geometrical point of view. or an
analytical point of view . Generally speaking. number theory, as a branch of
mathematics, can be broadly classified into the following sub-branches :
(1) Elementary number theory.
(2) Algebraic number theory ,
(3) Analytic number theory.
(i) Multiplicative number theory.
(ii) Additive number theory .
(4) Geometric number theory,
(5) Probabilistic number theory,
(6) Combinatorial number theory ,
(7) Logic number theory.
(8) Algorithmic/Computational number theory ,
(9) Arithmetic algebraic geometry, and
(10) Applied number theory.
These sub-branches reflect .. either the study of the properties of the integer s
from different points of view . or techniques used to sol ve the problems in
number theory. For example, probabilistic number theory makes extensiv e
use of probabilistic methods, whilst analytic number theory employs dee p
results in mathematical analysis in solving number-theoretic problems . Note
that arithmetic algebraic geometry is a brand new subject of modern numbe r
theory. which is the study of arithmetic properties of elliptic (cubic) curves .
The great amateur French scientist Pierre de Fermat (1601–1665 )
led a quiet life practising law in Toulouse, and producing high
quality work in number theory and other areas of mathematics
as a hobby. He published almost nothing. revealing most of his
results in his extensive correspondence with friends, and generall y
kept his proofs to himself. Probably the most remarkable reference
to his work is his Last Theorem (called Ferma t 's Last Theorem
(FLT)) . which asserts that if ra > 2, the equation x" + y" = z"
cannot be solved in integers x. y,z. with :nyz
O. He claimed in a margin of his
copy of Diophantns's book that he had found a. beautiful proof of this theorem. but
the margin was too small to contain his proof. Later on mathematicians everywher e
in the world struggled to find a proof for this theorem but without success. The
theorem remained open for more than 300 years and was finally settled in June 199 5
by two English number theorists, Andrew Wiles. currently Professor at Princeton
University. and Richard Taylor . a former student of Wiles and currently Professor
at Harvard University . the original result of Wiles (with a hole in it) was firs t
announced on 23 June 1993 at the Isaac Newton Institute in Cambridge .
This book. however. shall be mainly concerned with elementary and algorith-
mic number theory and their applications in computer science.
1.1.2 Applications of Number Theory
Number theory is usually viewed as the purest branch of pure mathematics ,
to be admired for its beauty and depth rather than its applicability . It is not
well known that number theory has, especially in recent years, found divers e
"real-world" applications, in areas such as
(1) Physics ,
(2) Chemistry,
(3) Biology ,
(4) Computing,
(5) Digital information .
(6) Communications ,
(7) Electrical and electronic engineering ,
(8) Cryptography,
(9) Coding theory,
(10) Acoustic . and
(11) Music .
It is impossible to discuss all the above applications of number theory.
We only concentrate ourselves on the applications of number theory in com-
puting. In the pas few decades, number theory has been successfully applie d
to the following computing-related areas :
(1) Computer architecture and hardware design ,
(2) Computer software systems design,
(3) Computer and network security .
(4) Random number generation .
(5) Digital signal processing ,
(6) Computer graphics and image processing ,
(7) Error detection and correction .
(8) Faulty tolerant computing.
(9) Algorithm analysis and design .
(10) Theory of Computation, an d
(11) Secure computation and communications .
In this book. we. of course. cannot deal with all the applications of number s
theory in computing : instead. we shall only deal with the applications of
number theory in the following three computing related areas :
(1) Computer systems design ,
(2) Information systems security, an d
(3) Random number generation .

14
1. Elementary Number Theory
1 .1 Introduction
15
1 .1 .3 Algebraic Preliminaries
If you are faced by a difficulty or a controversy in science. an ounce of
algebra as worth a ton of verbal argument.
J. B . S. HALDANE (1892—1964)
The concepts and results in number theory are best described in certain types
of modern abstract algebraic structures . such as groups, rings and fields . In
this subsection, we shall provide a brief survey of these three widely used
algebraic structures. Let us first introduce some set-theoretic notation for
numbers .
(1) The set of natural numbers (positive integers, or counting numbers) N:
N_{1,2,3, . . .}
(1 .9)
Some authors consider 0 as a natural number . But like Kronecker y , we
do not consider 0 as a natural number in this book .
(2) The set of integers Z (the letter 7G comes from the German word Mien) :
Z = {0, +1, +2, +3, . .
} .
(1 .10)
We shall occasionally us e
(i) Z>o to represent the set of nonnegative integers :
11>o = {0,1,2,3
(1.11)
(ii)
7G + to represent the set of positive integers :
Z T = 11 2 3
.
. } = N,
(1.12)
(iii) Z > 1 to represent the set of positive integers greater than 1 :
7N>i={2,3,4,- .-} .
(1 .13)
Leopold Kronecker (1823 1891) studied mathematics at Berlin
University, and did his doctoral thesis on algebraic number the-
ory under Dirichlet's supervision . Kronecker was one of the few
of his generation to understand and master Evariste Galoi s's the-
ory, and is well known for his famous remark "Natural number s
e by God, all the rest are man made ." Kronecker believed
mathematics should deal only with finite numbers and wit h
finite number of operations .
(3) The set of all residue classes modulo a positive integer n, denoted
Z/nZ (which is read "Z modulo n") :
N/nN = {0,1,2,- . . , n -1} = N, F .
(1 .14)
One of the main tasks in this chapter is to study the arithmetic in th e
set 7N/uZ . Note that some authors use 7Nn to denote the set of all residue
classes modulo n .
(4) The set of rational numbers Q :
-a
b
a.bETGandb~0
(1 .15)
(5) The set of real numbers IN :
IIN is defined to be the set of converging sequences of rational number s
or decimals; they may or may not repeat. There are two subsets within
the set of real numbers : algebraic numbers and transcendental numbers.
An algebraic number is a real number that is the root of a polynomia l
equation with integer coefficients ; all rational numbers are algebraic. since
a/b is the root of the equation bx - a = 0. An irrational number is a
real number that, is not rational. For example, f = 1.4142135 . . .
)x =
3.1415926 - . and e = 2 .7182818 . . are all real numbers but not rational ,
and hence they are irrational . Some irrational numbers are algebraic; for
example, f is the root of equation x2 - 2 = 0, and hence y is an
algebraic number. An irrational number that is not a root of a polynomia l
equation with integer coefficients (i.e .. not algebraic. such as x and e) is
a transcendental number . Thus, we have
rational - algebraic, e .g., 5/4, 2/3, 20/ 7
real number
rational algebraic, e.g., y , 1+ V2
transcendental, e.g., x . e
(6) The set of complex numbers C:
tC={a+bi
: a.bERandi=V-1} .
(1 .16)
Definition 1.1 .1 . A binary operation * on a set S is a rule that assigns to
each ordered pair (a, b) of elements of S a unique element of S .
Example 1 .1 .2 . Ordinary addition + is a binary operation on the sets N.
Z . R. or C. Ordinary multiplication . is another binary operation on the sam e
sets .
Definition 1 .1 .2. A group, denoted by (C . *), or (g,*) . or simply g, is a
nonempty set g of elements together with a binary operation *, such that .
the following axioms are satisfied :
(1) Closure : a* b E g, Va_ b E g .

16
1 . Elementary Number Theory
1 .1 Introduction
17
(2) Associativity : (a *b) *c = a * (b * e) . Va. b. c E g .
(3) Existence of identity : There is a unique element e E g . called the identity ,
such that c*a=a*e=a .
VaEg .
(4) Existence of inverse : For every a E g there is a unique element b suc h
that a *b = b* a, = e . This b is denoted by a-t and called the inverse of
a .
The group (g,*) is called a commutative group if it satisfies a furthe r
axiom :
(5) Commutativity : a * b = b* a. Va, b E g .
A commutative group is also called an Abelian group, in honour of the
Norwegian mathematician N . H. Abel° .
Example 1 .1 .3. The set Z" with operation + is not a group, since there i s
no identity element for + in Z + . The set
7G + with operation . is not a group :
there is an identity element 1 . but no inverse of 3.
Example 1 .1.4. The set of all nomiegative integers . Z>o, with operation +
is not a group ; there is an identity element O . but no inverse for 2 .
Example 1.1.5. The sets Q+ and
L78+ of positive numbers and the sets Q*
,
iF* and C" of nonzero numbers with operation - are Abelian groups .
Definition 1 .1.3 . g is said to be a semigroup with respect to the binar y
operation * if it only satisfies the group axioms (1) and (2) of Definition
1 .1 .2 . G is said to be a monoid with respect to the binary operation * if i t
only satisfies the group axioms (1) . (2) and (3) .
Definition 1 .1 .4 . If the binary operation of a group is denoted by +, the n
the identity of a group is denoted by 0 and the inverse a by -a ; this group
is said to be an additive group .
Definition 1.1 .5 . If the binary operation of a group is denoted by *, the n
the identity of a group is denoted by 1 or e ; this group is said to be a
multiplicative group .
Definition 1 .1 .6 . A group is called a finite group if it has a finite number
of elements :; otherwise it is called an infinite group .
to
Many mathematicians have had brilliant but short careers : _Niels
Henrik Abel (1802 1829), is one of such mathematicians . Abel
made his greatest contribution to mathematics at the age of
nineteen and died in poverty, just eight years later . of tuber-
culosis. Charles Hermite (1822 1901), a French mathematician
who worked in algebra and analysis, once said that Abel
"has
left mathematicians something to keep them busy for five hun -
dred }ears" ; it is certainly true that Abe l's discoveries still hav e
a profound influence on today 's number theorists.
Definition 1.1.7. The order of a group f . denoted by VI (or by #(c)) . is
the number of elements in C .
Example 1 .1 .6. The order of 7G is I7L, = oc .
Definition 1.1.8 . A nonempty set g ' of a group which is itself a group.
under the same operation . is called a subgroup of C .
Definition 1.1.9. Let a be an element of a multiplicative group g . The
elements a' . where r is an integer, form a subgroup of g . called the sub-
group generated by a . A group g is cyclic if there is an element a E g
such that the subgroup generated by a is the whole of g . If g is a finite
cyclic group with identity element e. the set of elements of g may be writ-
ten {e, a, a2 . '
.07 1 1 . where a" = e and n is the smallest such positiv e
integer. If g is an infinite cyclic group . the set of elements may be written
{ . . . .a
2 .a1 .e.a_a2,
.}.
By making appropriate changes . a cyclic additive group can be defined .
For example . the set {0,1, 2 . ' ' ' ,n
1} with addition modulo n is a cyclic
group, and the set of all integers with addition is an infinite cyclic group .
Definition 1.1.10. A ring, denoted by (R, -;, :•" ), or (R, - .4)) . or simply R ,
is a set of at least two elements with two binary operations
'♦and which
we call addition and multiplication . defined on R. such that the following
axioms are satisfied :
(1) The set is closed under the operation
a ;;+bER. Va . b E R .
(1 .17)
(2) The associative law holds for
-
a
+
(b+ c)
(a + b)
Va, b. c E R.
(1.18)
(3) The commutative law holds for
a -- b
b a, Vu, bER .
(1.19)
(4) There is a special (zero) element 0 E R . called the additive identity of
R . such that
(1 .20)
( .5) For each a E R. there is a corresponding element -a E R. called the
additive inverse of a. such that :
a (-a) = 0,
Va E R .
(1.21)
(6) The set is closed under the operation
a +bE72., Va, bER .
(1 .22)
a(D 0
0 .3a=a .
Va. ER

18
1. Elementary Number Theory
1 .1 Introduction
1 9
aC1=a=1(aa,
Va E
(1 .27)
Definition 1.1.13. An integral domain is a. commutative ring with identit y
1 VJCVUCVKUHKGU :
a .b E R K ab = 0 
> a = 0 or
b = 0 .
(1 .28)
Definition 1 .1 .14 . A division ring is a ring R with identity 1 VJCt
satisfies:
for each a  0 E R, the equation ax = 1 and xa = 1 have solution s
in R .
Definition 1 .1 .15 . A field, denoted by K, is a division ring with commuta-
tive multiplication .
Example 1.1 .8. The integer set 7G, with the usual addition and multiplica-
tion, forms a commutative ring with identity, but is not a field .
It is clear that a field is a type of ring, which can be defined more generall y
as follows :
Definition 1.1 .16. A field . denoted by (h;, L . ), or (IC.
o), or simply K ..
is a set of at least two elements with two binary operations and which
we call addition and multiplication, defined on K such that the followin g
axioms are satisfied:
(1) The set is closed under the operation 'E -
a ea, b E .lC.
Va, bEIC,
(1 .29)
(2) The associative law holds for
a .l (b e c)
(a C b) =? c, Va .. b, c E K .
(1.30)
(3) The commutative law holds for C :
aeh
bCa, Va.., bEK .
(1.31 )
(4) There is a special (zero) element 0 E K, called the additive identity o f
K, such that
a ;o 0
0 :-' a = a . Va E /C,
(1 .32)
(5) For each a E K, there is a corresponding element —a E K, called the
additive inverse of a, such that :
aC(a)=0.
VaEK,
(1.33)
(6) The set is closed under the operation
CCC :
aCbEK,
Va, bEK,
(1 .34)
(7) The associative law holds for
:
aCC(bCc)=(a(a b)
c,
Va,b,cE1C
(1 .35)
(8) The operation Ca is distributive with respect to E :
aC;(bCc)
aChCaCc,
Va,b,cE1C,
(1 .36)
(a-eb) .>c=a
•;cCbCc,
Va, b, cE1C .
(1 .37)
(9) There is an element 1 E 1C, called the multiplicative identity of K, such
that. 1 CPF
avl=a,
Va EK,
(1 .38)
(10) For each nonzero element a C
1C there is a corresponding elemen t
ar E K. called the multiplicative inverse of a, such that
ac•?a
(1 .39)
(11) The commutative law holds for C :
a(a b=bOa,
Va, bEIC,
(1 .40)
Again, from a group theoretic point of view, a field is an Abelian group
with respect to addition and also the non-zero field elements form an Abelia n
group with respect to multiplication .
Figure 1 .2 gives a Venn diagram view of containment for algebraic struc -
tures having two binary operations .
(7) The associative law holds for J :
a • . (b
'a c)
(a Ci b) G c,
Va, b, c E R,
(1 .23)
(8) The operation v is distributive with respect to '_ :
a ;• (b - c)
_o c,
Va, b, c E R .
(1 .24)
(aob)Cc=a
• c ; b ;a c .
Va,b,cER .
(1 .25)
From a group theoretic point of view. a ring is an Abelian group, with
the additional properties that the closure, associative and distributive law s
hold for a
.
Example 1 .1 .7. (7G
F , (a), (Q e . off), (118
CC), and (C,
J) are all rings .
Definition 1.1.11 . A commutative ring is a ring that further satisfies :
aC1b=ba a .
Va,bER .
(1 .26)
Definition 1 .1.12. A ring with identity is a ring that contains an element
1 satisfying:

20
1 . Elementary Number Theory
1 .2 Theory of Divisibility
2 1
Figure 1.2. Containment of various ring s
Example 1.1.9. Familiar examples of fields are the set of rational numbers.
Q, the set of real numbers . R and the set of complex numbers. C: since
8 and C are all infinite sets, they are all infinite fields. The set of integers Z
is a ring but not a field, since 2, for example, has no multiplicative inverse ; 2
is not a. unit in Z . The only units in Z are 1 and -1 . Another example of a
ring which is not a field is the set IC[x] of polynomials in x with coefficients
belonging to a field 1C .
Definition 1 .1 .17 . A finite field is a field that has a finite number of ele-
ments in it; we call the number the order of the field .
The following fundamental result on finite fields was first proved by
Evariste Galois'
:
Theorem 1 .1.1. There exists a field of order q if and only if q is a prime
power (i .e., q = p'') with p prime and r E F. Moreover, if q is a prime power ,
then there is, up to relabelling, only one field of that order .
A field of order q with q a prime power is often called a Galois field, ant
is denoted by GF(q) . or just FQ . Clearly. a Galois field is a finite field .
Evariste Galois (1811-1832), a French mathematician who made
major contributions to the theory of equations (for example, h e
proved that the general quintic equation is not solvable by radicals )
and groups before he died at the age of 21 . shot in an illegal duel ;
he spent the whole night before the duel writing a letter containing
notes of his discoveries . Galois's unpublished mathemat ical papers
were copied and sent to Gauss . Jacobi and others by his brother
and a friend. No record exists of any comment from Gauss and
Jacobi. However when the papers reached Lionville (1809 1882) . he announced i n
1843 to the French Academy that he had found deep results in Galois's papers, and
subsequently published Galois ' s work in 1846 in his Journal .
Example 1 .1 .10 . The finite field F, has elements {0. 1, 2, 3, 4} and is de-
scribed by the following addition and multiplication table (see Table 1 .1) :
Table 1 .1 . 'The addition and mnitiplicatio r
®uu®®®
Q©®®®®
®®®®
0
®®® 0 Q®
®®®©®®
The theory of groups ; rings, and particularly finite fields plays a very im-
portant role in elementary, algorithmic and applied number theory, including
cryptography and information security.
1 .2 Theory of Divisibility
The primary source of all mathematics is the integers .
H . MlNxowsxt (1864—1909 )
Divisibility has been studied for at least three thousand years . From befor e
the time of Pythagoras, the Greeks considered questions about even and od d
numbers, perfect and amicable numbers, and the primes, among many others ;
even today a few of these questions are still unanswered .
1 .2 .1 Basic Concepts and Properties of Divisibility
Definition 1 .2.1. Let a and b be integers with a  . We say a divides b .
denoted by a
b, if there exists an integer c such that b = ac . When a divides
b. we say that a is a divisor (or factor) of b. and b is a multiple of a . If a does
not divide b. we write a fi b. If a ( b and 0 < a < b. then a is called a proper
divisor of b .
Remark 1 .2.1 . We never use 0 as the left member of the pair of integers i n
a
b . however, 0 may occur as the right member of the pair, thus a 0 for
every integer a not zero . Linder this restriction, for a
b, we may say that b is
divisible by a, which is equivalent to sac that a is a divisor of b. The notatio n
a°
b is sornethnes used to indicate that e
b but as+r { b .
Commutative
Rings
for IF'.,

22
1. Elementary Number Theory
1 .2 Theory of Divisibility
23
Example 1 .2 .1 . The integer 200 has the following positive divisors (not e
that, as usual, we shall be only concerned with positive divisors, not negativ e
divisors, of an integer) :
1,2,4.5,8,10,20,25,40,50,100,200 .
Thus. for example. we can write
81200, 50 200,
71 200, 35 { 200 .
Definition 1 .2.2. A divisor of n is called a trivial divisor of n if it is either
1 or n itself. A divisor of n is called a nontrivial divisor if it is a divisor of n .
but is neither 1 . nor n .
Example 1 .2.2. For the integer 18, 1 and 18 are the trivial divisors, whereas
2, 3, 6 and 9 are the nontrivial divisors. The integer 191 has only two trivial
divisors and does not have any nontrivial divisors .
Some basic properties of divisibility are given in the following theorem :
Theorem 1 .2 .1 . Let a, b and c be integers. Then
(1) if a1banda1 e .then a1 (b+c) .
(2) if a b, then a bc, for any integer c.
(3) if a1 b and h
a . then a c .
Proof.
(1) Since a
h and a a, we hav e
b=ma. c=na,
rn,nEZ .
Thus b + c = (m + n)a . Hence, a (m + n)a since in + n is an integer .
The result follows .
(2) Since a
1 b we have
b=ma,
mEZ .
Multiplying both sides of this equality by c give s
Sc = (mc) a
which gives a
1 Sc . for all integers c (whether or not c = 0) .
(3) Since a ( b and b c. there exists integers in, and n such that
b=rna .
c=nb.
Thus. c = (mn)a. Since nth . is an integer the result follows .
Exercise 1 .2 .1 . Let a, b and c be integers . Show that
(1)1I a.aI a.a0 .
(2) if aband 5 a, then a=+b .
(3) if a ~ b and a ( c. then for all integers m and n we have a
1 (nab + nc) .
(4) if a
1 b and a and b are positive integers . then a < b .
The next result is a. general statement of the outcome when any integer
a is divided by any positive integer b .
Theorem 1.2.2 (Division algorithm) . For any integer a and any positive
integer b. them exist unique integers q and r such that
a=bq+r,
0<r<b.
(1.41)
where a is called the dividend, q the quotient, and r the remainder . If b) a .
then r satisfies the stronger inequalities 0 < r < a .
Proof. Consider the arithmetic progressio n
3b, -2b, –b, 0, b, 2b . 3b .
then there must be an integer q such that
gb < a < (q + 1)b .
Let a – qb = r, then a = bq + r with 0 < r < b. To prove the uniqueness of q
and r, suppose there is another pair qr and rr satisfying the same conditio n
in (1 .41), then
a=bqr+rr,
0<rr <b .
We first show that rr = r . For if not. we may presume that r < rr, so that
0 < r 1 – r < b. and then we see that b(q – qr) = r t – r, and so b (rr – r) .
which is impossible. Hence . r = rr, and also q = qr .
q
Remark 1 .2 .2. Theorem 1 .2.2 is called the division algorithm . An algorithm
is a mathematical procedure or method to obtain a result (we will discus s
algorithms and their complexity in detail in Chapter 2) . We have stated in
Theorem 1 .2 .2 that "there exist unique integer q and r " and this wording
suggests that we have an existence theorem rather than an algorithm. How -
ever, it nray be observed that the proof does provide a method for obtainin g
the integer q and r, since q and r can be obtained by the arithmetic division
a/b .
Example 1.2.3. Let b = 15 . Then
(1) when a = 255 . a=b-17+0.soq=17andr=0<15 .
(2) when a = 177 . a=b-11+ 12. so q = 11 and r= 12<15.

24
1 . Elementary Number Theory
1 .2 Theory of Divisibility
25
(3) when a=—783 ;a=b .(—52)+3, so q = - 52 andr=3<15.
Definition 1 .2 .3. Consider the following equatio n
a = 2q + r, a, q, r E Z . 0 < r < q.
(1 .42 )
Then if r = O. then a is even, whereas if r = 1 . then a is odd .
Definition 1.2.4. A positive integer n greater than 1 is called prime if its
only divisors are n and 1 . A positive integer n that is greater than 1 and i s
not prime is called composite .
Example 1 .2 .4 . The integer 23 is prime since its only divisors are 1 and 23 ,
whereas 22 is composite since it is divisible by 2 and 11 .
Prime numbers have many special and nice properties, and play a cen-
tral role in the development of number theory . Mathematicians throughout
history have been fascinated by primes . The first result on prime numbers is
due to Euclid :
Theorem 1 .2 .3 (Euclid) . There are infinitely many primes .
Proof. Suppose that 1)1,1)2 
Pk are all the primes. Consider the numbe r
N = prp2 • • • pr; + 1. If it is a prime, then it. is a new prime. Otherwise, it
has a prime factor
q . If q were one of the primes pi. i = 1 .2.-'' , k, then
q (pi pe 'Pk), and since q (pipe- . •pt + 1), q would divide the difference
of these numbers, namely 1, which is impossible . So q cannot be one of the
p i for i = 1.2, • . - ,k, and must therefore be a new prime. This completes the
proof .
q
Remark 1 .2 .3. The above proof of Euclid's theorem is based on the moder n
algebraic language. For Euclid's original proof, translated in English, see
Figure 1 .3.
Two other related elementary results about. the infinitude of primes are
as follows .
Theorem 1 .2 .4. If it is an integer > 1, then there is a prime p such tha t
n<p<a!+1 .
Proof. Consider the integer N = n! + 1 . If N is prime, we may take p = N.
If N is not prime, it has some prime factor p . Suppose p < n . then p
n! ;
hence. p (N n!) . which is ridiculous since N – n! = 1 . Therefore . p > n . q
Theorem 1 .2 .5 . Given any' real number a• > 1 . there exists a prime betwee n
J. and 2x .
ET I
Figure 1.3. Proposition 20 of the Elements Book IX (by courtesy of Thomas L .
Heath [73])
This is the famous Bertrand's postulate, conjectured by Joseph Bertran d
(1822 . 1900) in 1845 . and proved by Chebyshev in 1850 . The proof of this
result is rather lengthy ; interested readers are advised to consult Hardy an d
Wright's book [100] . However . there do exist long sequences of consecutiv e
integers which are barren of primes. as the next result shows .
Proposition 1 .2 .1 . If n is an integer > 2, then there are no primes betwee n
rd + 2 and n! + n .
Proof. Since if n! is a product of all integers between 1 and n . then 2
I n!+2,
31a!+3	
nI a!+n.
q
Prune numbers are mere rr6st awy asrtg e
Irihdk of
prime Am.
Let A, B, C be the assigned prime no
1 say that there are more
prime numbers than A, B, C.
For let the least number
measured by A . B, C be
taken ,
and let it be DE
let the unit DE be added
Then BE is either pri
First, let it be prime
then the prime numbers .4 ,
ace than A, B. (-
Enid be prime ,
by some prime number.
red by the prime number G.
the same with any of the numbers
therefore it i
Let it be n
i say' that
A, B .
Fr
m-
a -
(via . Cs)
number, will measure the remainder.
nc of the numbs
Now
therefore
But it
Therefore
the unit DF
which is absurd.
Therefore G
A, B, C.
And by hypothesis
Therefore the prime numbers A, B. Cl G have been found
which are more than the assigned multitude of A, B, C.
m . It, 0.
DF.
C, EF have been found which

26
1 . Elementary Number Theory
1..2 Theory of Divisibility
27
Theorem 1 .2 .6. If n is a composite, then n has a prime divisor p such tl
p < n .
Proof. Let p be the smallest prime divisor of n . If n = rs, then p < r and
p < s . Hence, p2 < rs = n . That is . p <
n .
q
Theorem 1 .2.6 can be used to find all the prime numbers up to a given
positive integer x; this procedure is called the Sieve of Eratosthenes, at-
tributed to the ancient Greek astronomer and mathematician Eratosthenes
of Cyrene 12 , assuming that x is relatively small . To apply the sieve, list al l
the integers from 2 up to x in order :
2.3.4.5 .6 .7.8.9.10.11,12,13 .14,15 
x .
Starting from 2 . delete all the multiples 2m of 2 such that 2 < 2m < x :
2,3.5,7 .9,11,13,15, .•,x .
Starting from 3, delete all the multiples 3m of 3 such that 3 < 3m < x:
2.3.5.7, 11, 13.-
. ,x .
In general, if the resulting sequence at the kth stage i s
2,3,5 ; 7,11 .13.
then delete all the multiples pm of p such that p < pm < x . Continue this
exhaustive computation, until p <
y( . The remaining integers are all the
primes between [ fj and x and if we take care not to delete 2,3, 5, . ' ' .p <
[fi] , the sieve then gives all the primes less than or equal to x . For example ,
let x = 36, then far = 6 . there are only three primes 2 .3 and 5 below 6, an d
all the positive integers from 2 to 36 are as follows .
2
3
4
5
6
7
8
9
10
11
1 2
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
First of all, we delete (marked with the symbol
all the multiples of 2
with 2<2m<36,forin=1,2,•
, 18. and get :
12
Eratosthenes of Cyrene (274194 B.C.) was born in Cyrene whic h
now in Libya in North Africa. was one of the great men in the
ncient world. He was the first to calculate the size of the Earth
by making measurements of the angle of the Sun at two differen t
places a known distance apart . His other achievements include
measuring the tilt of the Eart h's axis. Eratosthenes also worked o n
prime numbers . He is best remembered by generations of numbe r
theorists for his prime number sieve. the
"Sieve of Eratosthene s"
which, in modified form. is still an important tool in number theory research .
_
_
Then we delete (marked with the symbol •,") all the multiples of 3 wit h
3<3m<36.form=1 .2, .
. .11.andget :
_
_
Finally, we delete (marked with the symbol " x ") all the multiples of 5 wit h
5 < 5rn. < 35. for m = 1.2, . . . . 7, and get :
2 3 _
5
1 1
13 _
_ 17 _ 19 _ , _ 2 3
_ 29 _ 31
_
The remaining numbers 2,3,5,7,11, 13, 17,19, 23, 29,31 are then the primes
up to 36 .
According to the above analysis, we can get the following algorithm for
the Sieve of Eratosthenes :
Algorithm 1 .2.1 (The Sieve of Eratosthenes) . Given a positive intege r
n > 1, this algorithm will find all prime numbers up to n .
[1] Create a list of integers from 2 to n ;
[2] For prime numbers p ; (i = 1,2 . . .') from 2,3.5 up to [071, delete all the
multiples p i < p,m < n from the list ;
[3] Print the integers remaining in the list .
1 .2.2 Fundamental Theorem of Arithmeti c
First. let us investigate a simple but important property of' composite num-
bers .
Theorem 1.2.7. Every composite number has a prime factor .
Proof. Let n be a composite number . Then
n = n1T12
where nr and n 2 are positive integers with n i . n2 < n . If either nr or n 2 is a
prime, then the theorem is proved . If nl and n 2 are not prime, the n
2
3
7
_
9
_
1 1
13
_
15
_
17
_
19
_
21
_
23
25
_
27
_
29
_
31
33
_
35
2
3
_
5
1 1
13
_
_
17
19
_
_
_
23
25
_
_
29
31
_
35

28
1 . Elementary Number Theory
where n3 and n .i are positive integers with n3 , na < nr . Again if n3 or n
is a
prime . then the theorem is proved. If n3 and n4 are not prime. then we can
write
n.3 = n5n6
where n.5 and n6 are positive integers with n 5 , n6 < n3 . hi general . after k
steps we write
n2k-I = n2k+1 1t2k+2
where n2k+1 and n?k+2 are positive integers with ri2k+i, n2k+1 < n2Since
n. > ii.i > n 3 > 115 >
. . . n2a._ 1

0
for any value k, the process must terminate . So there must exist an n2k_1 for
some value of k . that is prime. Hence. every composite has a prime factor . q
Prime numbers are the building blocks of positive integers, as the followin g
theorem shows :
Theorem 1 .2.8 (Fundamental Theorem of Arithmetic) . Every posi-
tive integer n greater than 1 can be written uniquely as the product of primes :
k
a,
a ;
Pk
=
p
i— 1
where pi .1)2 , .
. ,Pk are distinct primes. and al , a2 , are natural num-
bers . The equation (1 .43) is often called the prime power decomposition o f
n, or the standard prime factorization of n .
Proof. We shall fast show that a factorization exists . Starting from n > 1, if
n. is a prime. then it stands as a product with a single factor. Otherwise . n can
be factored into . say . ob ., where a > 1 and b > 1. Apply the same argumen t
to a and b: each is either a prime or a product of two numbers both > 1.
The numbers other than primes involved in the expression for n are greater
than 1 and decrease at every step; hence eventually all the numbers must b e
prime .
Now we come to uniqueness . Suppose that the theorem is false and let
a. > 1 be the smallest number having more than one expression as the product
of primes. say
= PIP2
. 'p,• =(Itg2 . . .g 5
where each pi (i = 1 .2. - - - . r) and each q~ (j = 1 .2 
s) is prime . Clearly
both r and s must be greater than 1 (otherwise n is prime . or a prime is equal
to a composite) . If for example pi were one of the qj (j = 1 , 2. - - -
. s), then
is/p l would have two expressions as a product of primes, but n/P i < n so
this would contradict the definition of n . Hence pi is not equal to any of the
gi ( j = 1, 2 . - - - , s). and similarly none of the pi (i = 1. 2, ' - - ,r) equals any
1 .2 Theory of Divisibility
29
of the (pi (j = 1 .2,
, s) . Next, there is no loss of generality in presumin g
that p l < a" , and we define the positive integer A a s
N = (qi — Pi )q2 13 . qs = pi (h3P3
— g2g3 . qs) .
Certainly 1 < N < n., so N is uniquely factorable into primes . However .
pi { (eh —p i ) . since pi < ql and qr is prime. Hence one of the above expression s
for contains p i and the other does not . This contradiction proves the result :
there cannot be any exceptions to the theorem .
q
Note that if n is prime, then the product is, of course . I itself.
Example 1 .2 .5 . The following are some sample prime factorizations :
643 = 643
231 — 1 = 2147483647
644 = 22 - 7 , 23
231 + 1 = 3 - 71582788 3
645=3 . 5 . 43
2i'--=3 . 5 . 17 . 257 . 65537
646=2-1719
232 +1=641 . 6700417
647 = 647
231 +2=2-52 -13 . 41 . 61 . 1321
Definition 1 .2 .5 . Let a, and b be integers, not both zero. The largest divisor
d such that d
a and d
b is called the greatest common divisor (gcd) of a
and b. The greatest common divisor of a and b is denoted by gcd(a, b) .
Example 1 .2.6. The sets of positive divisors of 111 and 333 are as follows :
1,137,111 ,
1, 3, 9, 37,111, 333 ,
so gcd(111 .333) = 111 . But. gcd(91,111) = 1. since 91 and 111 have no
common divisors other than 1 .
The next. theorem indicates that gcd(a,b) can be represented as a linea r
combination of a and b.
Theorem 1.2.9. Let a and b be integers, not both zero . Then there exists
integers x and y such that
d
gcd(a, b) = ax + by .
(1 .44)
Proof. Consider the set of all linear combinations au + bc, where a and v
range over all integers . Clearly this set of integers {au+bv} includes positive ,
negative as well as O. Choose .r and y such that rn = ax + by is the smallest
integer in the set . Use the Division algorithm . to write a = inq + r . where
0 < r < m . Then
r = a—inq=a—q(ax+by)=(1
qx)a+(—qy)b
and hence r is also a. linear combination of a. and b . But r < in. so it. follows
from the definition of in that r = O . Thus a = mg, that is . in
a; similarly,
m.
b. Therefore, nt is a common divisor of a and 6 . Since d
a and d
b .
d < m . Since (1 = gcd(a, 6), we must, have d = in .
q
n = P1 'pz-
(1.43)

30
1 . Elementary Number Theory
Remark 1 .2 .4. The greatest common divisor of a and b can also be char-
acterized as follows :
(1)daanddb ,
(2) ife
a and e
h, then c
d.
Corollary 1.2.1. If a and b are integers, not both zero then the se t
S={a:r+by : :r,yEZ }
is precisely the set of all multiples of d 
ged(a,b) .
Proof. It follows from Theorem 1 .2.9. because d is the smallest positiv e
values of ax + by where x and y range over all integers .
q
Definition 1 .2 .6 . Two integers a and b are called
relatively prime
if
gcd(a, b) = 1 . We say that integers ni , n .2 
n 1 are promise relatively prime
if, whenever i j, we have gcd(n.,,ni ) = 1.
Example 1 .2.7. 91 and 111 are relatively prime, since gcd(91, 111) = 1 .
The following theorem charaterizes relatively primes in terms of linear
combinations .
Theorem 1 .2 .10. Let a and b be integers, not both zero, then a and b
are relatively prime if and only if there exsit integers x and y such tha t
ax + by = 1 .
Proof. If a and b are relatively prime, so that gcd(a .. b) = 1 . then Theorem
1 .2.9 guarantees the existence of integers x and y satisfying ax + by = 1 . As
for the converse. suppose that ax + by = 1 and that d = gcd(a, b) . Since d
a
and d b, d (ax + by), that is, d
1. Thus d = 1. The results follows .
q
Theorem 1.2.11 . If a
I be and gcd(a . b) = 1, then a
1 c .
Proof. By Theorem 1 .2.9. we can write ax + by = 1 for some choice o f
integers x and y . Multiplying this equation by c we ge t
ae.r; + bey = c .
Since a ac and a bc . it follows that a
; (acx + bey)_ The result thus follows .
For the greatest common divisor of more than two integers, we have th e
following result .
1.2 Theory of Divisibility
3 1
Theorem 1 .2 .12 . Let a.r, a 2 ,
•
, a„ be n integers. Let also
(1.45)
gcd(ai , a2) = d2.
gcd(d2,a3) = d 3 .
gcd(d u _ 1 .a,
Then
gcd(a i .a2 , .
_a,,,) = d,, .
(1 .46)
Proof. By (1 .45). we have d,a
a„ and d„ ~ de_i . But d,,_ t
a„_ 1 and
d„_r d„_ 2 , so d„
a„_r and d„
d„,_ 2. Continuing in this way_ we fi-
nally have d„
a,,,
d„
a„_r, -
. d„
I al , so d„ is a common divisor o f
ai , a2 .
. a,, . Now suppose that d is any common divisor of ar . a 2, - • . ,a„ ,
then d
al and d
(12 . Observe the fact that the common divisor of a an d
b and the divisor of gcd(a, b) are the same, so d ~ d2 . Similarly. we have
d
d 3	
d d,, . Therefore, d <
d„ . So, d„ is the greatest commo n
divisor of al, a 2 , .
•
. a,, .
q
Definition 1 .2.7. If d is a multiple of a and also a multiple of b, then d
is a common multiple of a and b . The least common multiple (1cm) of tw o
integers a and b, is the smallest of the common multiples of a and b . The
least common multiple of a and b is denoted by lcm(a, b) .
Theorem 1 .2.13. Suppose a and b are not both zero (i.e., one of the a an d
b can be zero, but not both zero). and that rn = Icm(a, b) . If x is a commo n
multiple of a and b, then m
x . That is. every common multiple of a and b
is a multiple of the least common multiple .
Proof. If any one of a and b is zero, then all common multiples of a and
b
are zero. so the statement is trivial . Now we assume that both a and b ar e
not. zero. Dividing x by in . we get
x = ma + r.
where 0 < r < in .
Now a
.r and S
x and also a
m and S
Ta : 50 by Theorem 1 .2.1, a. rand
b r. That is . r is a common multiple of a and b . But m is the least commo n
multiple of a and b, so r = O. Therefore, :r = 7nq, the result follows .
q
For the lest common multiple of more than two integers . we have the
following result.
Theorem 1 .2.14. Let a
.(12 . . . , a„ be n integers. Let. also
lcm(ai , a 2 ) = in .
lcm(tn 2 , a3) = m3,
(1 .47)
lcm(rnn_z, a,,,) = me .

32
1 . Elementary Nunihes Theory
1 .2 Thec of Divisibility
3 3
Then
lcm(ar, a_
a-„) =
10
(1 .48)
Proof. By (1 .47) . we have m,
i = 2,3, .
.n — 1. and a l
m2 ,
a ;
I In, .
i =
2 .3. -
.n . So, in, is a common multiple of a 1 .0, . .
. a,, .
Now let to is any common multiple of
(1. 1 . a? 
a„, then a1
m, a 2
in .
Observe the result that all the common multiples of a and
b are the multiples
of lcm(a, b)
a„ and d„
d 0_i . So in l
in and a3
rn . Continuing the
process in this way, we finally have m„
in . Thus, na„
<
iin . Therefore .
m„=lcni(a 1 ,a2 .'
 Cœ 
q
One way to calculate the gcd(a, b) or the lcrn(a, b) is to use the standard
prime factorizations of a and b. That is :
Proof. Since -> + fi, = a i + 3;, it is now obvious that
gcd(a, b) ' Icin(a. b) = ab .
The result thus follows .
Example 1 .2 .8 . Find gcd(240.560) and lcm(240. 560) .
Since the prime factorizations of' 240 and 560 ar e
240=24
. 3 . 5=2 1 -3 1 -5 1
. 70
560 = 24
. 5 . 7=2 4 - 30 . 5 1
. 71 .
then
5min(1-1) 7nun(0,1 )
0)
_ 55n ax(1 .1) . 7o,ax(0,1)
Of course, if we know gcd(240, 560) = 80, then we can find lcm(240, .560) by
lcm(240, 560) = 240 - .560/80 = 1680 .
Similarly, if we know lcm(240, .560) . we can find gcd(240.560) by
gcd(240, 560) = 240 - 560/1680 = 80 .
k
gcd(a , b) =
1?"
(1 .49 )
k
a =III?',
a;>0 ,
i= 1
b=
z " ,
3i >0,
gcd(240 .560) = 2'0(`1,4)
. 3oiia(1 .0 )
=2 9 .3 0 .5 1 .7 0
= 80.
lcm(240. 560) = 2max(4,4)
3„,ax( 1
= 24 - 31 , 51 . 7 1
= 1680 .
Icrn(a, b) = 1114 `
:.1
1 .2.3 Mersenne Primes and Fermat Number s
(1 .50)
where = min(a, . 3i) and 6, = ma (a, . 3i) for i = 1 .
Proof. It is easy to see that
k
gcd(a, b) = LI p, ' . where
is the lesser of (A i and
,= 1
k
lcln((L,b) = f[ p°' . where bi is the greater of a, and 3 i.
i— i
The result thus follows .
Of course. if we know any one of the gcd(a .b) or lcm(a. b) . we can easily
find the other via the following corollary which follows immediately fro m
Theorem 1 .2 .15 :
In this section, we shall introduce some basic concepts and results o n
Mersenne primes and perfect numbers.
Definition 1 .2 .8 . A number is called a llersenne ls number if it is in the
form of'
13
rin Mersenne (1588 1648) was a French monk, philosopher an d
mathematician who provided a valuable channel of communica-
tion between such contemporaries as Descartes. Fermat. Galileo
and Pascal: "to inform Mersenne of a discovery is to publish
it throughout the whole of Europe" . Mersenne stated in
Cogni-
tata Physico-Matheinatica but without proof that 5I„ is prime for
p = 23,5 .7,13 . 17. 19 . 31 .67.12 7. 257 and for no other primes p
with p < 257. Of course. Mersenne 's list is not quite correct . It
took over 300 years to totally settle this claim made by Mersenne . and finally in
1947, it. was shown that Mersenne made five errors in his work : namely . 4fa- and
M2 ;7 are composite and hence should be deleted from the list, whereas
4I6 , , ills0 ,
M107 are all primes and hence should be added to the list .
Corollary 1 .2.2. Suppose a and b are positive integers, t h
ab
lcan(a,b) = gcd(a,6)
(1.51)

34
1 . Elementary Number Theory
1.2 Theory of Divisibility
35
11r =21' –1,
(1 .52)
Table 1 .2. The thirty-nine known Mersenne primes Alp = 2 "
No .
P
digits in
11",
discoverer(s )
and time
1
2
1
2
3
1
3
5
2
4
7
3
5
13
4
anonymous,1456
6
17
6
Cataldi, 158 8
7
19
6
Cataldi, 158 8
8
31
10
Euler, 1772,
9
61
19
Pervushin.1883
10
89
27
Powers, 191 1
11
107
33
Powers, 191 4
12
127
39
Lucas, 1876
13
521
157
Robinson, 195 2
14
607
183
Robinson, 195 2
15
1279
386
Robinson, 1952
16
2203
664
Robinson, 1952
17
2281
687
Robinson, 1952
18
3217
969
Riesel. 1957
19
4253
1281
Hurwitz . 196 1
20
4423
1332
Hurwitz, 196 1
21
9689
2917
Gillies, 1963
22
9941
2993
Gillies, 196 3
23
11213
3376
Gillies, 1963
24
19937
6002
Tuckerman, 1971
25
21701
6533
Noll & Nickel. 1978
26
23209
6987
Noll. 1979
27
44497
13395
Nelson & Slowinski, 197 9
28
86243
25962
Slowinski. 1982
29
110503
33265
Colquitt & Welsh. 1988
30
132049
39751
Slowinski, 198 3
31
216091
65050
Slowinski. 1985
32
7 56839
227832
Slowinski & Gage, 199 2
33
859433
258716
Slowinski & Gage . 1994
34
1257787
378632
Slowinski & Gage, 199 6
35
1398269
420921
Armengaud & Woltman et al .
(GIMPS) . 1996
36
2976221
895932
Spence & Woltman et al .
(GIMPS), 199 7
37
3021377
909526
Clarkson, Woltman & Kurowski et al .
(GIMPS. PrimeNet) . 1998
38
6972593
2098960
Hajratwala, Woltman & Kurowski et al .
(GIMPS, PrimeNet), 1999
39
13466917
4053946
Cameron, Woltman & Kurowski et al .
(GIMPS, PrimeNet), 200 1
where p is a prime. If a Mersenne number ?17p = 21' – 1 is a prime. then it is
called a Mersenne prime .
Example 1 .2 .9 . The following numbers
22 –1=3 .
23 –1=7 .
2'–1=31,
27 –1=127 ,
213 – 1 = 8191
217 – 1 = 131071
are all Mersenne numbers as well as Mersenne primes, but 2 11 – 1 is only a
Mersenne number, not a Mersenne prime, since 2 11 – 1 = 2047 = 23 x 89 is
a. composite .
In Table 1.2, we list all thirty-nine Mersenne primes known to (late (where
GIMPS is the short for the Great Internet Mersenne Prime Search) . There
seems to be an astounding amount of interest in the world's largest know n
prime. When Curt Noll and Laura Nickel, two 18-year-old American high -
school students in California, discovered the 25th Mersenne prime in Octobe r
1987, the announcement was carried by every major wire service in the Unite d
States and even announced by Walter Cronkite on the CBS Evening News .
Currently the largest known prime is the 37th Mersenne prime 2 3021377 –
1, a 909526 digit number . In fact, since 1876, when Lucas determined th e
primality of 2 127 – 1 (confirmed later in 1914) the largest known prime ha s
always been a Mersenne prime, except for a. brief interregnum between June
1951 and January 1952. In this period Miller and Wheeler found the prime
934(2127 – 1) + 1 and later 180(2 127 – 1) + 1. Also Ferrier in 1952 found, by
hand calculation, that (2148 + 1)/17 is a prime . This is probably the largest
prime that will ever be identified without using a computer (Williams [255]) .
It is amusing to note that after the 23rd Mersenne prime was found at the
University of Illinois, the mathematics department there was so proud tha t
they had their postage meter changed to stamp "2 1121s – 1 IS PRIME" on
each envelope (see Figure 1.4), at no profit to the U.S . Post Office. considering
the zero value of the stamp .
Figure 1 .4. A stamp of the 23rd Mersernne prime (by courtesy of Schroeder [222])

36
1 . Elementary Number Theory
1.2 Theory of Divisibility
3 7
There are some probabilistic estimates for the distribution of Mersenne
primes; for example, in 1983 . Wagstaff proposed the following conjecture :
Conjecture 1 .2 .1 .
(1) Let the number of Mersenne primes less than x be
aAf((r) . then
r(.r)	 	
log log x = (2.5695 - - . ) 1n In x.
(1 .53)
where -y = 0.5772 is Euler's constant .
(2) The expected number of Mersenne primes Mq with r < q < 2x is about
e1 = 1 .7806 -
(3) The probability that Mq is a prime is abou t
e
ineq
Inaq
_ (2 .5695 .
) .
In 2 1n 2
q
where
2 if q = 3 (mod 4 )
a =
6 if q 1 (mod 4) .
Schroeder [222] also refers to a conjecture of Eberhart, namely :
Conjecture 1 .2.2. Let q„ be the nth prime such that Mq], is a Mersenne
prime. Then
q,,
2
-
(l .aa)
Definition 1.2.9. Numbers of the form F, = 22' + 1, whether prime or
composite. are called Fermat numbers . A Fermat number is called a prim e
Fermat number if it is prime. A Fermat number is called a composite Ferma t
number if it is composite .
These special numbers obey the simple recursion :
F„+1 = (F,,
1)2 + 1
(1 .56)
or
F,+l—2=F,(FU—2)
(1 .57)
which leads to the interesting product :
F,+—2=F0F
. . .F5 .
(1 .58)
In other words . F,,+i — 2 is divisible by all lower Fermat numbers :
F,— A,
(F,
1 — 2) .
1 < k < n .
(1 .59)
Fermat in 16-10 conjectured, in a letter to Mersenne, that all numbers of
the form F,, = 22" + 1 were primes after he had verified it up to n = 4 ;
but Euler in 1732 found that the fifth Fermat number is not a prime . since
F, = 22,' + 1 is the product of two primes 641 and 6700417 . Later, it was
found that Fe, F7. and many others are not primes . Fermat was wrong! To
date, the Fermat numbers F5 . F6 
Fu have been completely factored :
(1) F; was factored by Euler in 1732 :
22' +1=2'j2 +1 = 641 6700417
(2) F6 was factored by Landry and Lasseur in 1880 :
22~ + 1 = 264 + 1 = 274177 . 6728042131072 1
(3) F7 was factored by Morrison and Brillhart in 1970 using the Continued
FRACtion (CFRAC) method :
22 + 1 = 2 1228 + 1 = 59649589127497217 . 570468920068512905472 1
(4) F8 was factored by Brent and Pollard in 1980 by using Brent and Pol-
lard's "rho" (Monte Carlo) method :
228 + 1 = 2256 + 1 = 1238926361,552897 . P62
(5) F9 was factored by Lenstra et al . in 1990 by using the Number Field
Sieve (NFS) method :
220 + 1 = 2 512 + 1 = 2424833 -
745360282564788420833739573620045491878336634265 7 . p0 1
(6) Fib was factored by Brent in 1995 by. using the Elliptic Cu rve Method
(ECM) :
22'0 + 1 = 21024 + 1 = 45592577 . 648703180 9
1659775785220018543264560743076778192897-p 257
(7) Fi r was factored by Brent in 1989 by using again the Elliptic Curv e
Method (ECM) :
22" +1 = 22018 +1=319489 . 974849 -
16798855634176047513 7 . 3560841906445833920513- p564
In the above list, p63 , p90 , P252 and p564 are primes with 40. 49, 63, 99, 25 2
and 564 decimal digits, respectively . As a summary, we give the factorization
status for the Fermat numbers F,, with 0 < n < 24 in Table 1 .3 (where p
denotes a proven prime, and c a proven composite : Y means that the pri-
mality/compositeness of the number is not, known) . Four Fermat numbers i n
Table 1.3, namely, Fr4i F20 , F22 and F> 1 are known to be composite, though
(1 .54)

38
1 . Elementary Number Theory
1.2 Theory of Divisibility
39
Table 1 .3. The factorization status for Fermat numbers
Table 1.4 . Prime factors of the form
2+1 inF,,=
+1 for 23 < r1. < 30308 8
F,
Prime Factor of F,~
F„
Prime Factor of F,
F3
5 . 2 25 + 1
F25
48413 . 224 + 1
F;
1522849979 - 2 '2' + 1
Fs
143165 . 229 + 1
F7
141015 . 2 3° + 1
F27
430816215
. 229 + 1
F9
1120049 . 231 + 1
F30
149041
232 + 1
F39
127589 . 2 33 + 1
F32
1479 . 234 + 1
F36
5 2 39 + 1
F36
3759613 -233 + 1
F38
3 . 2 41 + 1
F38
2653 . 240 + 1
F39
21 . 241 + 1
F42
43485 . 2 45 + 1
F2
4119 - 254 + 1
F52
21626655 . 2'4 + 1
F55
292 67 +1
Fs
95 . 261 + 1
F61
54985063 . 266 + 1
F2
697 . 2 64 + 1
F3
9 . 267 + 1
F6 .1
17853639 . 267 + 1
F66
7551 269 + 1
F71
683 . 2 73 + 1
F73
5 2 75 + 1
Fr
3447431 2 77 + 1
F77
4252 79 +1
F81
271 . 2 64 + 1
F91
1421 . 2 93 +1
F93
92341 . 2 96 + 1
F99
16233 . 2104 +1
F117
7 . 21t0 + 1
F122
523477 .5 . 2124 + 1
F12.5
5 . 2127 + 1
F142
8152599 . 2 145 + 1
F144
17 . 2147 + 1
F147
3125 . 2149 + 1
F150
1575 . 2157 + 1
F150
5439 . 2154 + 1
F201
4585 . 2204 + 1
F205
232905 . 2207 + 1
F207
3 . 2209 + 1
F215
32111 . 2217 + 1
F226
15
2229 + 1
F228
29 . 2231 + 1
F25o
403 . 2252 + 1
F255
629 .2 257 + 1
F267
177 . 2 271 + 1
F6s
21 . 2'276 + 1
F275
22347 . 2279 + 1
F,84
7 . 2230 + 1
F287
5915 . 2269 + 1
F298
247 . 2302 + 1
F316
7 . 2320 + 1
F3329
1211 . 2333 + 1
F334
27609 . 2 .341 + 1
F398
120845 . 2401 + 1
F416
8619 . 2 418 + 1
F116
38039 . 2419 + 1
F452
27 . 2 h5' + 1
F544
225 2547 + 1
F556
127 . 2J8 + 1
F637
11969 . 2643 + 1
F692
717 . 2 69 '5 + 1
F744
17 . 274' + 1
Fob
57063 . 2 90s + 1
F931
1985 ,2°93 + 1
F1551
291 . 21'5'3 + 1
F 945
5 - 21947 + 1
F2023
29 . 22027 + 1
F2089
431 . 27099 + 1
F2456
85 - 22458 + 1
F3310
5 . 23313 + 1
F724
29 - 24'27 + 1
F6537
17 - 26539 + 1
F6835
19 - 26838 + 1
F9428
9 . 29431 + 1
F94-18
19 . 29450 + 1
F23471
5 . 2 23473 + 1
F2 .5006
57 . 22'0°10 + 1
F94798
21 . `294801 + 1
F95328
7 . 295.330 + 1
F114293
13 - 2114296 + 1
F125410
5 -2125413 + 1
F157167
3 . 2[5716°9 + 1
F213319
3 . 2213321 + 1
F303088
3 . 2303093 + 1
Tl
F,
_
0, 1 .2, 3, 4
p
5
641 . 6700417
6
274177-6728042131072 1
7
59649589127497217 . 570468920068512905472 1
8
1238926361552897- p
9
2424833 .
7455602825647884208337395736200454918783366342657- p
10
45592577 . 6487031809 .
4659775785220018543264560743076778192897
- p
11
319489 . 974849 16798855634176047513 7
.3560841906445833920513 . p
12
114689 . 26017793 - 63766529 .
190274191361 1256132134125569- c
13
2710954639361 . 2663848877152141313 . 3603109844522919 9
-3603109844542291969 -c.
14
15
1214251009-2327042503868417
. c
16
825753601
. 188981757975021318420037633- c
17
31065037602817
c
18
13631489 . c
19
70525124609 . 646730219521- c
20
c
21
4485296422913
. c
22
c
23
167772161- ?
24
c
no factors have yet been found (see Crandall . Doenias, et al [55], Crandal l
and Pomerance [56]) . Table 1 .3 also shows that the smallest not completel y
factored Fermat number is F12 , thus, it is the most wanted number at present .
The smallest Fermat numbers which are not known to be prime or composite
are F24 and F28 . Riesel [207] lists 99 prime factors of the form k . 2"` + 1 in
Fermat numbers. the largest being 5 . 2'-3473 + 1 of F23471 . Combining Riese l
[207] and Young [263], we give in Table 1 .4 the known prime factors of th e
form k . 2 1" + 1 for Fermat numbers F,, with 23 < n < 303088 .
There are still many open problems related to the Fermat numbers ; some
of them are the following :
(1) Are there infinitely many prime Fermat numbers?
(2) Are there infinitely many composite Fermat numbers?
(3) Is every Fermat number square-free?

40
1 . Elelnentals
v umber Theory
1 .2 Theory of Divisibili
4 1
1 .2 .4 Euclid's Algorithm
We might call Euclid 's method the granddaddy of all algorithms, becaus e
it is the oldest nontrivial algorithm that has survived to the present day .
DONALD E . KNUT H
The Art of Computer Programming : Seminumerical Algorithms [123J
Euclid's algorithm for finding the greatest common divisor of two integers i s
perhaps the oldest nontrivial algorithm that has survived to the present day .
It is based on the division theorem (Theorem 1 .2.2) . In fact, it is based o n
the following fact .
Theorem 1 .2 .16 . Let a, b, q. r be integers with b > 0 and 0 < r < b such
that a = bq + r . Then gcd(a, b) = gcd(b, r) .
Proof. Let X = gcd(a, b) and Y = gcd(b, r), it suffices to show that X = Y .
If integer cis a divisor of a and b. it follows from the equation a = bq+r and
the divisibility properties that c is a divisor of r also . By the same argument,
every common divisor of b and r is a divisor of a .
u
Theorem 1.2.16 can be used to reduce the problem of finding gcd(a, b)
to the simpler problem of finding gcd(b,r). The problem is simpler because
the numbers are smaller, but it has the same answer as the original one .
The process of finding gcd(a, b) by repeated application of Theorem 1 .2.16 is
called Euclid ' s algorithm which proceeds as follows.
a = bqo + r 1 ,
0 < r 1 < b
(dividing b into a) ,
b = r1 q1
+1 '2,
0 < 7.2 < r 1
(dividing r 1 into b) .
r 1 = r2 q2 + 7 .3 .
0 < r3 < r2
(dividing 7-2 into r 1 ) ,
r2 = r3 g 3 + 1 .3 .
0 < rq < r3
(dividing r3 into n,) .
r'„_2 = r n-1 qn-1 + r,,,
0 < r,, < r,,-1
(dividing r,,.-1 into
r'„-2);
-1q„— 1
1'a
11 0=1 = 0
Then the greatest common divisor ged of a, and b is r,, . That is,
d= gcd(a, h) =rr,,,.
(1 .60)
We now restate it in a theorem form .
Theorem 1 .2.17 (Euclid's algorithm). Let a and b be positive integers
with a > b. If b (a, then gcd(a, b) = b . If b { a, then apply the division
algorithm repeatedly as follows :
a=bqo+ri ,
0<rl <b ,
b=rim+r2,
0<'2 <1'
,
=
1 '2g2 T r :3,
0 < r:3 < r_, ,
1 '2 =rsgs+ r 1 .
0<<r3 ,
(1.61)
-1 q,,—1 + 1' ,,,
0 < r,, < 7-,,- 1 .
1' n
=
q„ + O .
Then r,,, the last nonzero remainder . is the greatest common divisor of a and
b . That is ,
gcd(a, b) = r,, .
(1 .62)
Values of J. and y in
gcd(a,b) = as + by
(1 .63)
can be obtained by writing each 7 . 7 as a linear combination of a and b .
r„-1 =1'ng„+ 0 .
1'„+1 = 0
(arriving at a zero-remainder) .
or. diagralnlnatically.
a
- bqo
r3
1'n- 1
1'„q„
q o
ql
q 2
q 3
qn -1
gn
r' 3 q3

1. Elementary Number Theory
L2 Theory of Divisibility
42
4 3
Proof. The chain of equations is obtained by dividing b into a, r i into b, r 2
into ri,
. , r,z—1 into r, - (Note that we have written the inequalities for the
remainder without an equality sign.) The process stops when the division i s
exact . that is. whenever r i = 0 for i = 1, 2, .
We now prove that r1 is the greatest common divisor of a and b. by
Theorem 1 .2.16, we have
gcd(a, b)
gcd(a — bqo, b )
gcd(ri , b)
gcd(rr .b — rigs )
gcd(ri , 1 .2)
gcd(ri — r2g2 ,1'2)
gcd(ra,r2 )
Continuing by mathematical induction, we have
gcd(a, b) = gcd(r1—r,r1) = gcd(r 1 .0) = ri .
To see that ri is a linear combination of a and b, we argue by inductio n
that each r, is a a linear combination of a and b. Clearly, r i is a linear
combination of a and b, since r i = a — bqo, so does r2. In general, r; is a
linear combination of r,_ 1 and r,_2 . By the inductive hypothesis we ma y
suppose that these latter two numbers are linear combinations of a and b ,
and it follows that r, is also a linear combination of a and b .
q
Remark 1 .2 .5 . Euclid's algorithm is found in Book VII, Proposition 1 an d
2 of his Elements, but it probably wasn't his own invention . Scholars believe
that the method was known up to 200 years earlier . However, it first appeare d
in Euclid's Elements, and more importantly. it is the first nontrivial algorith m
that has survived to this day .
Remark 1 .2.6. It is evident that the algorithm cannot recur indefinitely,
since the second argument strictly decreases in each recursive call . Therefore .
the algorithm always terminates with the correct answer . More importantly . it
can be performed in polynomial time. That is. if Euclid's algorithm is applie d
to two positive integers a and b with a > b, then the number of division s
required to find gcd(a,b) is O(logb) . a polynomial-time complexity (the big -
0 notation is used to denote the upper bound of a complexity function . i.e . .
f (n) = O(q(n)) if there exists some constant c > 0 such that f (n) < c . g(n) ;
see Subsection 2.1 .3 in Chapter 2 for more information) .
Example 1 .2.10 . Use Euclid's algorithm to find the gcd of 1281 and 243 .
Since
1281
— 1215
243
66
3
— 198
— 45
45
21
2
— 42
— 21
0
we have gcd(1281, 243) = 3 .
Exercise 1.2.2. Calculate gcd(1403, 549) using Euclid's algorithm .
Theorem 1.2.18. If a and b are any two integers, the n
Qka — Pk b = (—1) A—irk ,
k = 1, 2,
, n.
(1 .64)
where
= ( —1) k (rk—i
gk rk )
=
(Qk—ia — Pk b) + gr(Qka
Pk b)
= (gkQk+Qk—1) a— (qk'.+iPk+Pk+i )b .
Thus, Qk+ i a—Pk+i a = ( 1) krk}1 , where P = k + 1 = gcPk+Pk—i, Qk+i =
qk+i Qk + Qk—i . By induction, the reult is true for all positive integers .
q
The gcd(a, b) will be equal to unity for more than 60 percent of the time
for random inputs : this is a consequence of the following well-known resul t
of number theory (Knuth [123]) :
Theorem 1 .2 .19 . If a and b are integers chosen at rando m ; the probability
that gcd(a, b) = 1 is 6/w'- = 0 .60793. That is ,
Prob[gcd(a,b) = 1] = 0 .6 .
Po = 1 , P1 = qo, Pk = qm—i Pk—i + Pk —2
Qo = 0, Qi = 1, Qk = W—1 (2k—1 + Qk—2
fork=2,3,- .',n .
Proof.
When k = 1, (1 .64) is clearly true, since Q ia Pi b = (—1)1—
implies a — gob = r i . When k = 2, r2 = — (aqi — b(1 + gi gi )) . But 1+ gi gi =
g2Pi + Po, qi = ye • 1 + 0 = giQi + Qo, therefore, Q2a — P2 b = (-1)2 - 1 r, .
P2 = girl + Po, Q2 = g1Qi + Qo. Assume (1 .64) and (1 .65) hold for all
positive integers < k, then
(—1 ) krk+i
(L65)
(1 .66 )

44
1. Elementary Number Theor y
This result was first proved by the Italian mathematician Ernesto Cesar o
(1859-1906) in 1881 . The idea of the proof is as follows . Let p be the proba-
bility
p = Prob[gcd(a, b) = L .
Then, for any positive integer d . consider the probability
p = Prob[gcd(a, b) = d] .
This happens when a is a multiple of d,
b is a multiple of d, an d
gcd(a/d, b/d) = 1 . The probability that d
1 a is 1/d .
1 .2 .5 Continued Fractions
Euclid's algorithm for computing the greatest common divisor of two integer s
is intimately connected with continued fractions .
Definition 1 .2 .10 . Let a and b be integers and let Euclid's algorithm ru n
- bqo
rr
1.2 Theory of Divisibility
4 5
a
Then the fraction b can be expressed as a simple continued fraction :
a
1
b = qo+
g1 +
1 1
qn
where qo . q 1 i .
- , q„—1 , qn are taken directly from Euclid's algorithm ex-
pressed in (1.61) . and are called the partial quotients of the continued fraction .
For simplicity, the continued fraction expansion (1 .67) of b is usually written
as
= qo+ 
b
q1+ q2+
+ q,,
or even more briefly as
a _ [qo, q1, q2, . . . qn-1, q,,] .
If each q i is an integer, the continued fraction is called simple; a simple
continued fraction can either be finite or infinite . A continued fraction formed
from [qo, q1, q2, qn] by neglecting all of the terms after a given ter m
is called a. convergent of the original continued fraction. If we denote the k-th
Pk
convergent by Ck. = 
,then
Q k
Po
go
Co - Qo - 1 ;
Pi
gogl + 1
C1
Q 1
qi
(1)
Ck = Pk = gkPk-1+Pk-2 ,fork > 2 .
Qk
gkQk—1 +Qk—2
(2) If Pk = 4kQk—i +Qk-2 and Qk = gkPk—i +Pk_2 , then gcd(Pk, Qk) = 1 .
(3) PkQk-i - Pk_1Qk =
for k > 1 .
The following example shows how to use Euclid's algorithm to express a
rational number as a finite simple continued fraction .
1281
Example 1 .2 .11 . Expand the rational number
243 as a simple continued
fraction. First let a = 1281 and b = 243. and then let Euclid's algorithm run
as follows :
as
That is,
a = bqo + T i ,
b = r 1 g 1 + r2
r1 = r2g2 + r3 -
1'2 = r3 q3 + r4 ,
rn-2 = rn—rqn-1 +
rn-i = rain + O .
a
- roar tin
i
qo
q 1
q2
q3
qn- 1
qn
(1 .67)
qz +
(L68)
(1 .69)

46
1. Elementary Number Theory
1 .2 Theory of Divisibility
47
1281
– 1215
66
-
45
2 1
- 21
0
198
45
42
3
243
5
3
1
2
1281
So 243 = [5, 3,1, 2, 7] . Thus
1281
243 =5 +
Of course, as a by-product, we also find that gcd(1281, 243) = 3 .
239
51
Exercise 1 .2 .3 . Expand the rational numbers 5
1 
and 239 as simple con-
tinued fractions .
The above discussion tells us that any rational number b with b
0 can
be expressed as a simple finite continued fraction .
Theorem 1 .2 .20 . Any finite simple continued fraction represents a rational
number . Conversely, any rational number can be expressed as a finite simpl e
continued fraction, in exactly two ways, one with an odd number of term s
and one with an even number of terms .
Proof. The first assertion is proved by induction. When n = 1, we have
1
gogi + 1
[go ;4i] = qo +
=
qi
4 i
which is rational. Now we assume for n = k the simple continued fraction
[go,
, q .] is rational whenever qo, qi , -
. . qk are integers with
. . . , qk
positive . Let qo,
, qk+i are integers with ql 
qk+l positive. Note that
1
[qo, qi, . . . , gk, qa,+i] = ao + [qi 
qk , qk+i ]
By the induction hypothesis,
[qi . q2 
qk , qk+e] is rational . That is, there
exist two integers r and s with s
0 such that
[qi . q, , . . . , qi qk+l]
r
s
Thus,
1
aor + s
[go, gi,
.
, gt.., gd+l] = ao+
_
r/s
r
which is rational .
Now we use Euclid's algorithm to show that every rational number ca n
be written as a finite simple continued fraction. Let a and b be a rational
number with b > 0 . Euclid's algorithm tells us that
a=bqo+ri ,
0<ri <b .
b = ri qi + r2i
0 < r2 < ri ,
ri = r2g2 + r 3 ,
0 < r3 < r2 ,
r2 = r3g3 + r 4 ,
0 < r4 < r3 ,
ra—2 = r ~x—1 qa—1 + rn,
0 <
< rn—i ,
rn–i = ro(lo +0 .
In these equations, qt , q2 , - - • ,qo are positive integers. Rewriting these equa-
tions, we obtain
1
1
3+
a
b
b
ri
Ti
r2
rrz- 1
r„
= q,I
By successive substitution, we have

1.2 Theory of Divisibility
49
Number Theory
48
a.
1
b
qo + bC
1
1
qo + qi +
1 1
1
q2 +
1
This shows that every rational number can be written as a finite simpl e
continued fraction .
Further. it can be shown that any rational number can be expressed as a
finite simple continued fraction in exactly two ways, one with an odd numbe r
of terms and one with an even number of terms ; we leave this as an exercise .
In what follows, we shall show that any irrational number can be expressed
as an infinite simple continued fraction .
Definition 1 .2 .11 . Let qo, q1 , q2 . . . . be a sequence of integers, all posi-
tive except possibly qo . Then the expression [go,g [ ,q2,
.] is called an in-
finite simple continued fraction and is defined to be equal to the number
rim [qo, qi , q2, . , q —i, q,z]
[1—>
Theorem 1 .2 .21 . Any irrational number can be written uniquely as an infi-
nite simple continued fraction. Conversely, if a is an infinite simple continued
fraction. then a is irrational.
Proof. Let a be an irrational number . We write
1
a= [a] + {a} = [a] + {a
}
where [a] is the integral part and {a} the fractional part of a_ respectively .
Because a is irrational . 1/{a} is irrational and greater than 1 . Let
1
and
a1 = {a}
where 1/{a i } is irrational and greater than 1 . Let
gi = [a ll -
We continue inductivel y
q2
[02],
and
a 3 =
1
q3
[03],
and
a4 _ {a3}
q„
and
a,, = 
1 
> 1
(a3 irrational )
{a„—1 }
Since each cs , i = 2, 3, - . is greater than 1, then q„_1 > 1, n = 2, 3, . '
. If
we substitute successively. we obtain
[qo, al ]
[qo, qi, a2]
[qo, ql, q2, a3]
Next we shall show that a = [qo, qi, q2, -
.1 . Note that C o ., the nth conver-
gent to [qo,
.q2 . ' ' ' ] is also the nth convergent to [qo, qi, q2, -
. qn . a„+1]
If we denote the (n + 1)st convergent to this finite continued fraction b y
= a, then
P
1 n+ 1
	
n+r 
a—Cn—
P
t
Qn+1
Qa
Qrz+i"r o
Q[
.,
.+1 become infinite as n
x[, then
' . q,—i+ q,,
and
a2=
{ 1 }
al
{a2}
1
>1
(a3
> 1
(a3 irrational)
ational)
=
[go,gi,q2,,q,,,ao+1 ]
Since
1 ' ±1
lim (a — Co) = lim (~ ) 
= 0
n-*x,
R-*yC Q ,,±1 (2,
1
We now write
a l = [a l ] + {c
and

50
1 . Elementary Number Theory
1 .2 Theory of Divisibility
51
a = lim C, = [qo, q1 .
. ]
R
a)
The uniqueness of the representation, as well as the second assertion are left
as an exercise .
q
Definition 1.2.12. A real irrational number which is the root of a quadrati c
equation axe+bx+c = 0 with integer coefficients is called quadratic irrational.
For example, O . 0, V are quadratic irrationals . For convenience, we
shall denote with N not a perfect square, as a quadratic irrational .
Quadratic irrationals are the simplest possible irrationals.
Definition 1 .2.13. An infinite simple continued fraction is said to be pe-
riodic if there exists integers
k and m such that q,+,,,
= qa for all
i > k. The periodic simple continued fraction is usually denoted by
[q0, gl,
, qe, gk F1, qk+2,
, qk+tn] . If it is of the form [qo, ql,
.q.—]I .
then it is called purely periodic . The smallest positive integer m satisfying
the above relationship is called the period of the expansion .
Theorem 1 .2 .22. Any periodic simple continued fraction is a quadratic ir-
rational. Conversely, any quadratic irrational has a periodic expansion as a
simple continued fraction.
Proof. The proof is rather lengthy and left as an exercise; a complete proof
can be found on pages 224–226 in [197] .
q
We are now in a position to present an algorithm for finding the simpl e
continued fraction expansion of a real number.
Theorem 1 .2 .23 (Continued fraction algorithm) . Let x = xo be a real
number. Then a can be expressed as a simple continued fractio n
[a°,gl,g2, . . . ,gaa,gn+1,' ]
by the following process :
qo = [xo] ,
ql = [xi J .
(1 .70)
q,, = [x o j .
q.,+1 = [x,H-1),
Proof. Follows from Theorem 1 .2.21.
Note that just as the numbers qo, ql , - -
are called the partial quo-
tients of the continued fraction, the numbers xo . x 1 . - • are called the corn-
plete quotients of the continued fraction . For quadratic irrational numbers .
of course. we do not, need to calculate the infinitely many q,'s, since ac -
cording to Theorem 1 .2.22, any quadratic irrational number is periodic
and can be written as an infinite simple continued fraction of the form
[q0 . qi . q2, . . .
, qr . qk+1 , . . . , qk+na]•
Now we can use the algorithm given in Theorem 1 .2 .23 to represent an y
real number as a. simple continued fraction .
Example 1.2 .12 . Expand 0 as a. periodic simple continued fraction . Let
xo = O . Then we have :
qo=[xoj=LA= 1
x2 — x i –al
f+l
1
0– 1
2
2
q2 = [x2] = LO + 11 = 2
x3 = x2 – q2
+1–2
01
2 = xi
q3=[x3J=[ 2 1 1=[1 +~2
]
=q1
1
1
1
2(0+1 )
x4 =
xo – qo
0 – 1
2
q1 = [xl]=[02
1 ] = [1 + 02
1
1
1
1
2(f + 1)
(0 –1 )0+1) =+ 1
X3 q3
+
1
Vs—1
(0—1)(0+ 1) =
+1=x2
2
2
q4 = [x3] _ [0 + 1) = 2 = q2
xJ = x4 – q4
+1–2
f1
2
q5 = [x5] = [x3] = 1 = q3 = q]
1
1
1
f+ 1
So, for n = 1, 2, 3, . . . , we have q2,,_1 = 1 and q2n = 2. Thus, the period of
the continued fraction expansion of 0 is 2. Therefore, we finally get

52
1 . Elementary Number Theor y
= 1+
1 1
= [1 , 1 , 2] .
1
2+
1
1+
1
2+ -
Exercise 1.2.4. Find the continued fraction expansions of x/5- and \TT'
1 .3 Diophantine Equations
I consider that I understand an equation when I can predict the propertie s
of its solutions, without actually solving it.
PAUL A. M . DIRAC (1902—1984 )
In this section, we shall introduce some basic concepts of Diophantine equa-
tions and study some solutions of certain types of Diophantine equations .
1 .3 .1 Basic Concepts of Diophantine Equations
The word "Diophantine" is derived from the name of Diophantus r" of Alexan-
dria who was one of the first to make a study of equations in integers . The
simplest form of problem involved is the determination of whether or not a
polynomial equation f (x, y, z,
• •) = 0 in variables x, y, z, -
., with integral
coefficients . has integral solutions . or in some cases rational solutions .
Diophantus (about 200 284) . the father of algebra, lived in the great city of
Alexandria about 1700 years ago . He is perhaps best known as the writer of th e
book Arithmetica, of which only six of the original thirteen volumes of the book
have been preserved : the photograph in Figure 1 .5 shows the title page of the
Latin translation of the book . About 130 problems in Arithmetic and Algebr a
are considered in the book . some of which are surprisingly hard. The work o f
Diophantus was forgotten until a copy of the book was discovered in 1570 . Italian
mathematicians in the 16th century introduced his works into Europe where the y
were read with great interest and where they stimulated the study of Algebra .
more specifically, Diophantine Analysis . Very little knowledge about his persona l
life has survived except his epitaph which contains clues to his age : One sixth of
his life was spent as a child ; after one twelfth more he grew a beard : when on e
seventh more had passed, he married . Five years later a son was born ; the so n
lived to half his father's age; four years after the son 's death, he also died .
1.3 Diophantine Equations
53
DIOPHAN .T I
ALEXANDRIN I
ARITHMETICORV M
LIBRI SEX ,
ET DE NVMERIS MVLJANGVLI S
LII3ER
VNVS.
CYM COMFNrrl
zrs c. c. PACHET/ V. C.
'ter o/rferttatioutbusV . P. de F E It M A T Senatori ., ToloJanr .
Accemt Doetrinx AnalytIcx muumuu
cx vatijs ciufdcm D. dc FERMAT Epiftoiis .
SE
TOLOSA
,
EtcudebatRERNARDVS BOSC,tRegime ColiegijSacicceti s
M. DC L7: X.
Figure 1 .5. The title page of Diophantus ' book Arithmetica
A Diophantine equation may have no solution . a finite number of solutions
or an infinite number of solutions, and in the infinite case . the solutions ma y
be given in terms of one or more integral parameters .
From a geometrical point of view . the integral solutions of a Diophantin e
equation f (.r, y) = 0 represents the points with integral coordinates on th e
curve f (x. y) = 0 . For example. in the case of equation .r 2 — 2y 2 = 0. the only
integral solution is ( .x, y) = (0.0), which shows that the point (0 .0) is the only
point on the line .r 2 — 2y = = 0 with integral coordinates . whilst the equatio n
+ y = = z
has an infinite number of solutions . There are corresponding
geometrical interpretations in higher dimensions .
1 +
1 .1

54
1 . Elementary Number Theory
1 .3 .2 Linear Diophantine Equations
Definition 1 .3 .1 . The algebraic equation with two variable s
ax+by= c
is called a linear Diophantine equation, for which we wish to find intege r
solutions in x and y .
A linear Diophantine equation is a type of algebraic equation with two
linear variables . For this reason. it is sometimes also called a bilinear Dio-
phantine equation . In this type of equation ax + by = c. we are only interested
in the integer solutions in x and y .
Theorem 1 .3.1. Let a, b, c be integers with not both a and b equal to 0, an d
let d = gcd(a, b) . If d { c, then the linear Diophantine equation
ax+by= c
has no integer solution . The equation has an integer solution in x and y if
and only if d c . Moreover, if (xo,yo) is a solution of the equation, then the
general solution of the equation i s
(x, y) = (xo + d
t, yo — d ' t) t E Z .
(1.72)
Proof. Assume that x and y are integers such that ax + by = c . Since d
a
and d ( b . d e . Hence, if d { c, there is no integer solutions of the equation .
Now suppose d c. There is an integer k such that e = kd . Since d is a
sum of multiples of a and b. we may writ e
am+bn=d .
Multiplying this equation by k. we get
a(1n,k) + b(nk) = dk = c
so that x = ink and y = nk is a solution .
For the "only if" part . suppose xo and yo is a solution of the equation .
Then
axo + byo = c .
Since (1
a and d 5, then (1
c
Observe that the proof of Theorem 1 .3.1 . together with Euclid 's algorithm .
provides us with a practical method to obtain one solution of the equation .
In what follows, however. we shall show how to find x and y by using the
continued fraction method .
Suppose that a and b are two integers whose gcd is d and we wish to solve
1 .3 Diophantine Equations
5 5
ax — by = d.
(1 .73)
We expand a/b as a finite continued fraction with convergent s
Po Pi
Po—r
P„
_ a
(1 .74)
Qo'Q1-
. . .,Q
b
Since d = gcd(a, b) we roust have a = do'. b = db' and gcd(a', b ') = 1 . Then
P,,/Q„ = a'/b' and both fractions are in their lowest terms, giving P,, = a ' .
Q,b = b' . So equation (1.73) give s
f',tQ~—1 — Q,zP„ = a ' (2,, --1 — b'P„—1 = (—1) „ - 1
Hence
aQ„—
bPn—1 = da'Q„—r — db'Po —1 = (
or
(
1)'r raQ,~—r — (—1)”
bP,,_1 = d
(1 .77)
A solution to the equation ax — by = d is therefore given b y
To conclude the above analysis, we have the following theorem for solvin g
the linear Diophantine equation ax — by = d:
Theorem 1 .3 .2 . Let the convergents of the finite continued fraction of a/b
be as follows:
PO
P1
Pn-1
P,,
a
Qo ' Q1
'
Q,~
b
Then the integer solution in .r and y of the equation ax — by = d is
x =
y = (—1) " r P,,—1 .
Remark 1.3.1. We have already known a way of solving equations like 1 .73
by applying Euclid's algorithm to a and b and working backwards throug h
the resulting equations (the so-called extended Euclid's algorithm) . Our new
method here turns out to be equivalent to this since the continued fractio n
for a/b is derived from Euclid's algorithm . However . it is quicker to generate
the convergents P,/Q; using the recurrence relations than to work backwards
through the equations in Euclid's algorithm .
Example 1.3.1. Use the continued fraction method to solve the follow
g
linear Diophantine equation :
364.. — 227y = 1 .
(1.71)
(1.7a
(1 .76)
(1 .78)
(1 .79)
(1 .80)

56
1 . Elementary Number Theory
Since 364/227 can be expanded as a finite continued fraction with convergent s
3 5 8 85 93 36 4
2' 2 ' 3 ' 5 ' 53 58 22 7
we have
x = (-1),:, r q" -r = (-1) t-r58 = 58.
y = (-1)„—'p,,-i = (-1)x-'93 = 93 -
Tha
364 58-227 93 = 1 .
Example 1 .3.2. Use the continued fraction method to solve the following
linear Diophantine equation :
20719x + 1387ly = 1 .
Note first that
20719x + 13871y = 1
20719x - (-13871y) = 1.
Now since 20719/13871 can be expanded as a finite simple continued fraction
with convergents
3
118
829
947
1776
2723
4499
20719
2 '
79 ' 555 634' 1189 ' 1823' 3012 ' 13871
'
we have
x = (-1)"-'q,,_i = (-1)8- '3012 = -3012,
y = (-1)"-rp -r = (-1)8-1 4499 = -4499 .
That is .
20719 - (-3012) - 13871 . (-4499) = 1.
The linear Diophantine equation ax + by = d can also be interprete d
geometrically. If we allow (x, y) to be any real values . then the graph of thi s
equation is a straight line L in the xy-plane. The points (:r, y) in the plane
with integer coordinates (x . y) are the integer lattice-points . Pairs of integers
(x, y) satisfying the equation correspond to integer lattice-points ( .r, y) on L .
Thus. Theorem 1 .3 .1 tells us that L passes through such a lattice-point , if an d
only if gcd(a, b) d, in which case it passes through infinitely many of them .
Remark 1.3 .2 . In some areas of number theory (see e.g., Yan [261]) . it may
be necessary to solve the following more general form of linear Diophantin e
equation :
1 .3 Diophantine Equations
57
(ax + c)(ay + b) = ad + be.
(1 .82)
If inn is a factorization of ad + be and a divides n - c and m - b . an integer
solution of (1 .81) is
n,
x =
a
(1 .83)
y = rn - b
a
1.3 .3 Pell's Equations
In this subsection, we shall study the elementary theory of Pell's equations ,
a type of quadratic Diophantine equation .
Definition 1.3.2. A Pell's equation is a quadratic Diophantine equation in
any one of the following three forms :
where N is a positive integer other than a perfect square, and n a positive
integer greater than 1 .
Remark 1 .3.3 . Pell's equations are named after the 17th century British
mathematician John Pell (1611-1685) . It is often said that Euler mistakenly
attributed these types of equations to Pell . They probably should be called
Fermat's equations since Fermat initiated the comparatively recent study of
the topic. But because Euler is so famous, everybody adopts Euler's conven -
tion .
The solutions to Pell's equations or its more general forms can be easil y
obtained in terms of the continued fraction of I/:T;. In this subsection, we
shall use the continued fraction method to solve Pell's equations .
Theorem 1 .3 .3. Let a be an irrational number . If a/b is a rational number
in lowest terms, where a and b are integers b > 0, such tha t
then alb is a. convergent of the simple continued fraction expansion of a .
Theorem 1 .3 .4. Let a be an irrational number greater than 1. The (k +
1)th convergent to 1/a is the reciprocal of the kth convergent to a, for k =
1 2
. .
.
[1,
axy + bx + cy = d.
(1 .81 )
Note first that this type of equation can be reduced to a factorization : mul-
tiplying (1 .81) by a, adding be to both sides and factoring results in
x2 -Ny-=1 ,
- A`y2 = -1 ,
x2 - Ny = n,
(1 .84)
(1 .85)
(1 .86)
(1.87)
1
< —
2s' '
a
a
b

58
1 . Elementary Number Theory
1.3 Diophantine Equations
59
Theorem 1 .3.5. Let N be a positive integer other than a perfect square,
(1) in is even
and let n be an integer with
111 < VN' . If xo and yo is a positive integer
(i) The positive integer solutions of .r2 — Nye = 1 are
solution of
fork=2,3.-
with
x' — Nye = n.
(1 .88 )
then xo/yo is one of the convergents of V .
Proof. Suppose n > 0 . Since xo and yo is a positive integer solution of
x' — Nye = n. then
yo-V-7\7 ) ((so + yo \IV) = n
x = Pkn,—1 ,
Y =k
,
.
-
Pin—1
,
y = Qn,—i,
(1.91)
(1.92)
which implies that
Therefore,
as the smallest positive integer solution .
(ii) The equation x2 — Nye = -1 has no integer solution .
(2) in is odd
(i) The positive integer solutions of x' — Nye = 1 are
yo(xo + W .v
<
for k = 2, 4, 6, - • , with
Yo (Yo + yo
)
0 <
—xo —
Ye
n.
x = Pk„~—r,
y = Qkm—1,
(1.93)
(1.94)
(1 .95)
(1 .96)
N
<
2y
It follows from Theorem 1 .3.3 that .xo/yo is a convergent to
N. Similarly,
if n < O . we find that yo/xo is a convergent to 1// . Using Theorem 1 .3 .4,
we conclude that xo/yo is a convergent to fg .
q
Corollary 1.3.1 . Let (xo, yo) be a positive integer solution of
x' r 2 = + 1,
(1 .89)
then
xo = Po,
yo = Qn,
(1 .90)
where P„ /Q„ is a convergent to
N .
Since the fraction s
Proof. By Theorem 1 .3.5 we know that xo/yo =
are reduced to lowest terms, then xo = Po . yo = Q,
.
q
Theorem 1.3.6 . Let :V be a positive integer other than a perfect square,
and in the period of the expansion of V7V as a simple continued fraction .
Then we have :
x = Pi,n—t,
1
y = Q2m—] ,
as the smallest positive integer solution.
(ii) The positive integer solutions of x — Nye = -1 are
= Pkn,—1 ,
y = Qk -
for k = 1 .3.5,
, with
x = Pm—1 ,
9 = Q,n—1 ,
as the smallest positive integer solution.
Proof. Left as an exercise .
q
Example 1.3.3 . Find the integer solutions of x 2 — 73y2 =
±1. Note first
that
73= [8, 1, 1. 5 .5.1 .1, 16] .
So the period m = 7 and of course m is odd. Thus, both equations are soluble
and their solutions are as follows :

60
1 . Elementary Number Theory
1 .3 Diophantine Equations
61,
(1) The smallest positive integral solution of :r-2 – 73y-- = 1 is
x = P0,—1
P2 7–1 = Pis = 2281249 .
y = Qk,n
1 = Q2 .7-1 = Q13 = 267000.
That is. 22812492 – 73 . 267000 2 = 1 .
(2) The smallest positive integer solution of x 2 – 73y 2 = - 1 is
x = Pkm–1 = P1 .7-1 = Pb = 1068,
ii = Qkm-1 = Q1 .7-1 = Q6 = 125. }
That is, 1068 2 – 73 . 125' = -1.
Example 1.3.4. Find the integer solutions of x 2 – 97y2 = +1. Note first
that
97 = [9,1, 5, 1,1 .1,1,1,1, 5, 1,18] .
So the period m = 11 and of course m is odd . Thus, both equations are
soluble and their solutions are as follows :
(1) The smallest positive integral solution of x 2 – 97y 2 = 1 is
x = P2,,,– 1 = P211–1 = P21 = 62809633 ,
y = Q2n,
1 = Q2-11-1 = Q21 = 6377352 .
That is. 62809633 2 – 97 . 63773522 = 1 .
(2) The smallest positive integer solution of :r2 – 97y 2 = - 1 is
x = P,,,– i = Pi .11-i = P10 = 5604 ,
= Q,n–1 = Qi.ti–i = Qio = 569 .
That is. 56042 – 97 • 5692 = 1 .
Remark 1 .3 .4. Incidentally. the continued fraction for
N, with N not a
perfect square, always has the form
N — [yo.
. Q2 ; (La
. ;43_gZ ; Ql ; 2yo] .
as can he seen in Table 1 .5 .
Table 1 .6 and Table 1 .7 show the smallest positive integer solutions (Jay )
to Pell's equations x 2 – Nye = 1 and x2
\Ny2 = - 1 for 1 < N < 100 (except
the perfect squares) . respectively .
The following is actually a corollary of Theorem 1 .3.6.
Corollary 1 .3 .2 . Let N be a positive integer other than a perfect square . m
the period of the expansion of
as a simple continued fraction, and f2„ ,
n = 1 .2. - . - the convergents to
N . Then the complete set of all solutions .
including positive and negative (if any) of Pell 's equation are :
Table 1 .5. Continued fractions for
witl
< 50 and not perfect squar e
(1) m even
(i)x2 -Ny2 =1: Fori=0,1,2,3, . . . .
x + yr = ± (P, - 1 f y
Q, –i)'
(1 .101 )
(ii) x 22
\'y2 = - 1: No solutions .
(2) m odd
(i)x-'–Ny-'=1 : Fori=1 .3.5	
.r+yfN =± (P,,,-1 t ?l
Q,,,–1) ' .
(ii) x2'–\l2=–1 : Foori=0 .2,4 . . . .
+yV_t ==( Pm—1 ±
Proof. Left as an exercise .
f=[1.2 ]
N/[ = [2.4 ]	
=[2.1.1,1.4]
10 = [3 .6 ]
12 = [3 .T6]
14=[3.1.2,1,6 ]
17 = [4.8]
19 = [4.2,1 .3 .1.2.8]
21 = [}.1,1,2,1,1,8]
\12-
= [4.1 .3 . 1 . 8]
26=[.5.10 ]
28 = [5.3, 2, 3, 10 ]
30 = [5 .2. 10]
32=[5.1.1,1,10]
34 = [5. 1. 4, 1, 10]
37 = [6.12]
39 = [6.4.12 ]
41 = [6, 2, 2, 12]
43 = [6,1 . 1, 3,1, 5 . 1.3,1 1, 12 1
45 = [6.1 .2, 2, 2.1 . 12]
47 = [6. 1. 5,1,12]
50 = [7,14]
= [1 . 1, 2 ]
=[2.2,4 ]
18- = [2 . 1. 4]
11=[3,3, 6
13 = [3,1 .1,1,1,6]
15=[3,1,6]
18 = [4 4.8 ]
20 = [4 2, 8 ]
vf[22
24 = [4.1,8 ]
27=[5,5,10]
29 = [5, 2, 1, 1, 2,10 ]
31 = [5,1,1,3,5.3,1,1,10 ]
3 = [5, 1, 2,1. 10]
35 = [5,1,10]
38 = [6.6, 12]
40=[6.3,12]
42=[6,2,12]
44=[6,1,1,1 .2.1,1,1.12]
46 = [6,1,3,1,1.2,6,2,1 .1 .3,1,12 ]
48=[61,12]
(1.97)
(1.98)
(1.99)
(1.100)
(1.102)
(1 .103)
If \ is not a perfect square, Pell's equation .x2 – Ny2 = 1 always has
infinitely many integer solutions . For the more general form of Pell's equation
we have the following result :

62
1 . Elementary Number Theory
63
Table 1 .6. The smallest solution to x 2
= 1 for N G 100
N
S
y
`
x
y
®8I8 ®
1
©
1®®®®® 180
® 33
8
18
® 170
®I®®__
®®®I®®©
®®®I®®®
28
9801
1820
30 ®®I®®®
® 17
®
33
6
1
®®®I 38
®®®I 40 ®®
® 2049 ®i®®®
43
3482 ®®® 30
®®®I
46
3588
® 48
®) 48 ®®
®
_®®I®®
910
®
68g
®MIM
8989
58
MIUIIIEMMIMI EMI 530
®®®I
®®®®~®
8
67
48842
68
®® 936
170
82 80
®I 80
9
MIMI=
82
163
18
83
82
EMI=
84 ® 6
85
285769
30996
86 ® 1122
187
28
3
88
197
89
EEMIUM 53000
90 ®®I®®®
®®®
1260
94
2143295 IISMIUIBM•IIEMMMIIM
96
62809633
6377352
98
10
1
Table 1.7. The smallest solution to r` — Ny = -1 for N G 100
®® N ®®I®®
13
18
29
70
®I®
___ 6 v®®®
50 ®©I®
182 ®
58
99
61
29718
3805
65
8
©~ 73
1068 EBE
® 43
®~ 82
9
©~ 85
378 MON
89
500 ®~® 5604
569 __
1 .4 Arithmetic Functions
It is true that a mathematician who is not also somewhat of a poet wil l
never be a perfect mathem,atzezan .
KARL \\. EIERSrRASS (1815-1897 )
Theorem 1.3.7. If N is not a perfect square and n an integer, then th e
equation
x-- Vy~=n
(1 .104)
has a finite set T of solutions such that for any solution (x. y), we have
(x + y7) = (xo + yo N)(u f v
)
(1 .105)
for some (xo,yo) E T and some (a.v) with u :2
No2 = 1 .
Proof. Left as an exercise .
Arithmetic (or number-theoretic) functions are the most fundamental func-
tions in mathematics and computer science : for example.. the computable
functions studied in mathematical logic and computer science are actuall y
arithmetic functions . In this section. we shall study some basic arithmeti c
functions that are useful in number theory .
1 .4.1 Multiplicative Functions
Definition 1 .4 .1 .
A function f is called an arithmetic function or a number-
theoretic function if it assigns to each positive integer n a unique real or com-
plex number f (n.) . Typically, an arithmetic function is a real-valued functio n
whose domain is the set of positive integers .

64
1 . Elementary Number Theory
1 .4 Arithmetic Functions
65
Example 1 .4.1 . The equation
f (n) = frt .
n E N
(1 .106)
defines an arithmetic function f which assigns the real number
n. to each
positive integer n .
Definition 1.4.2. A real function f defined on the positive integers is said
to be multiplicative if
f(m)f(n) = f(inn) . Vm_n C N . with gcd(m, n) = 1 .
(1 .107)
If
f (rn) f(n) = f(Inn) . Vm. n E N .
(1 .108 )
then f is completely multiplicative . Every completely multiplicative function
is multiplicative .
Theorem 1.4.1 . If f is completely multiplicative and not the zero function ,
then f(1) = 1 .
Proof. If f is not zero function, then there exists a positive integer k such
that Pk) 1. Hence, f(k) = f(k
1) = f(k)f(l) . Dividing both sides b y
f (k), we get f (1) = 1 .
q
Theorem 1 .4 .2. Let
k
=HA'
be the prime factorization of n and let f be a multiplicative function, then
k
f(n) = Hf(K') .
i=i
Proof. Clearly, if k = 1 . we have the identity, f (p ' ' ) = f (p; ')
Assume
that the representation is valid whenever n has r or fewer distinct prime
r
factors, and consider n = ~
,f (p?") . Since gcd ~ p° . PrTi
= 1 and f is
— i
multiplicative, we have
f (ar)
= f
111'` '
i= 1
1- 1
-i
,
(p i
a )
i— 1
Theorem 1 .4.3. If f is multiplicative and if
g(n)
f(d)
(1.109)
di n
where the sum is over all divisors d of n, then g is also multiplicative .
Proof. Since f is multiplicative. if gcd(m,a) = 1, then
g(mn)
=
E E f(dd' )
d' , ,
= Ef(d)Ef(d')
dl,"
d' I n
=
g(m)g (n) .
Theorem 1.4.4 . If f and 9 are multiplicative. then so is
Proof. If gcd(m, n) = 1 . then d inn if and only if d = dl d2 , where d1
in
and d2
a. gcd(di . dz) = 1 and gcd(an/d1 , n/d,) = 1 . Thus ,
C
Q
= f
Hpi '
-i
H(f(p°'))
f
)
,
CI
.f (p
n
i
=
)
F(n)

66
1 . Elementary Number Theory
1 .4 Arithmetic Functions
F(non)
E f(d)9 ( nd r )
dlmn
then the positive divisors of n are precisely those integers d of the form
d =
67
m9 2
E
.f
~
(d 1 d2) 9
d, ,n d2(n
dld2
E Ef(dr)f(d2)9 ( dr) (d2)
(film d2 ln
= F(m)F(n) .
0
1.4.2 Functions r(n), cr(n) and s(n)
Definition 1 .4.3. Let n be a positive integer . Then the arithmetic function s
T(n) and a(n) are defined as follows :
where 0 < 3, < a, .
Proof. If d
n, then n = dq. By the Fundamental theorem of arithmetic ,
the prime factorization of n is unique, so the prime numbers in the prim e
factorization of d must occur in pj , (j = 1, 2, - . ' , k) . Furthermore, the power
3, of p1 occurring in the prime factorization of d cannot be greater than aj .
that is, 3i < aj . Conversely, when 3j < aj , d clearly divides n .
q
Theorem 1.4.5. Let n be a positive integer. Then
(1) r(n) is multiplicative, i .e.,
T(m,n) = r(m)T(n) .
(1 .112)
(2) if n is a prime, say p, then r(p) = 2 . More generally, if n
S a prime
power e, then
T(p°) = a + 1 .
(1.113)
(3) n is a composite and has the standard prime factorization form, the n
.f(di)9
f (d2) .g
r(n) =)
a(n) => d.
(1.110)
d
T(n)
=
(a1 + 1)(a 2 + 1) ' ''(ak + 1 )
k
That is, r(n) designates the number of all positive divisors of n, and a(n)
designates the sum of all positive divisors of n .
It is sometimes also convenient to use the function s(n) rather than a(n) .
The function s(n) is defined as follows :
Definition 1 .4 .4. Let n be a. positive integer . Then
s(n) = a(n) — n .
Example 1 .4.2 . By Definitions 1 .4 .3 and 1 .4.4, we have :
n
1
2
3
4
5
6
7
8
9
10
100 ' 101
220
284
T(n) ©®®®~®®®®®
6
a(n) Q®®
6
12
8
18
217
102
504
504
s(n)
0
1
1
3
1
6
1
7
4
8
117
1
284
220
Lemma 1 .4.1 . If 1a he a positive integer greater than 1 and
((Ai + 1) .
z=
Proof.
(1) Since the constant function .f(n) = 1 is multiplicative and T(n) = E 1 .
dln
the result follows immediately from Theorem 1.4.3.
(2) Clearly, if n is a prime. there are only two divisors . namely. 1 and n itself.
If n = °, then by Lemma 1.4.1, the positive divisors of n are precisely
those integers d = p3 . with 0 < 3 < a. Since there are a + 1 choices fo r
the exponent, 3 . there area + 1 possible positive divisors of n .
(3) By Lemma 1 .4.1 and Part (2) of this theorem. there are a1 +1 choices for
the exponent 3 1 . a2 +1 choices for the exponent .32 , . ' . ak +1 choices for
the exponent 3k . From the multiplication principle it follows that ther e
are (a1+1)(a2+1) . - (ak +1) different choices for the 3 1 ,
. ' ' „3k . thus
that many divisors of n . Therefore, r(n) = (a1  1)(a2 + 1 ) .
(at + 1) .

68
1. Elementary Number Theory
1 .4 Arithmetic Functio
69
Theorem 1 .4.6. The product of all divisors of a number n is
d = nr (,i)l2 .
(1 .115)
Proof. Let d denote an arbitrary positive divisor of n, so that
n=dd'
for some d' . As d ranges over all T(n) positive divisors of n, there are r(n)
such equations. Multiplying these together, we get
nr(")=fJdd' .
diiz
d', n
But as d runs through the divisors of n. so does d ' , hence
11d= 11d' .
d!~a
d'l n
Example 1.4.3. Let n =1371, then
x(1371) = 4.
Therefore
d = 13714/22 = 1879641 .
It is of course true. since
d(1371) = 11, 3.457,1371}
rid=1 . 3 . 457 . 1371 =1879641 .
The result in Theorem 1 .4.6 can he expressed in a different manner . Let
{x 1,,r2 ,
, :ct} be a set of k positive integers. The geometric mean of these
k numbers is defined by
G=( :z i :r2
x A.)
(1 .116)
When this applies to the product of T(n) divisors of n, we have :
Theorem 1 .4.7. The geometric mean of the divisors of n. i.s
G(n) = n .
(1 .117)
Example 1 .4.4. Let again n = 1371. then
G(1371) = (1 . 3 . 457 . 13711 '/d = 37.02701716.
It is of course true since
31371 = 37.02701716 .
Theorem 1 .4.8. Let n be a positive integer. Then
(1) a(n) is multiplicative, i.e.,
a(mn) = a(m)a(n) .
(2) if n is a prime, say p, then a(p) = p + 1 . More generally, if n is a prime
power p' . then
pfl+1
1
a(p°)
p 
_ 1
(3) if n is a composite and has the standard prime factorization form, the n
p
+1 — 1
pp -1 — 1
pAk+1 — 1
pr —1
P2 —1
Pk
k
a;+1 — 1
p a
=1
P'
Proof.
(1) The result follows immediately from Theorem 1 .4 .3 since the identity
function f(n) = n and a(n) can be represented in the form a(n) = E d.
dln
(2) Left as an exercise, we prove the most general case in Part (3) .
(3) The sum of the divisors of the positive intege r
n.= 7 1~'pr
.
.
2
7 A
can be expressed by the product .
(1+pi +pi+
. .+pi
( 1 +p2+p + . .+p.°, ' )
Using the finite geometric serie s
So,
or equivalently
n'
din
,nr(n)/'2 = T(d . d'
implies that
(1 .119)
(1.120)

70
1 . Elementary Number Theory
1.4 Arithmetic Functions
71
we simplify each of the k sums in the above product to find that the su m
of the divisors can be expressed as
par±r – 1
pz'-+1 – 1
a(n)
Pr –1
P2 – 1
Pk
1
p at
;+1 — 1
pi — 1
Just as the geometric mean G(n) of the divisors of a. number n, we can
define the arithmetic mean as follows :
u(n)
A(n) = T(re) .
1.4.3 Perfect, Amicable and Sociable Number s
`Perfect numbers" certainly never did any good, but then they never did
any particular harm.
J . E . LITTLEwoon (1885–1977)
Perfect and amicable numbers have been studied since ancient times; how -
ever. many problems concerning then still remain unsolved . This subsection
introduces some basic concepts and results on perfect and amicable number s
based on the arithmetic functions studied previously.
Definition 1 .4 .5 . Let (m,l,m2,''' ,Mk) be k positive integers all greater
than 1, satisfying :
a(mt) = ml +m2
pkax.+r – 1
(1 .122)
Similarly, we can also define the harmonic mean H(n) of the divisors of a
number n in terms of the arithmetic mean as follows :
1
A(n)
(1 .123)
(70112) = 717 2 + m3
Q(m.k) = mk + ml
(1 .127)
H(n)
n
then the k positive integers form a sociable group with order k (or an aliquot
k-cycle) . If k = 1, that is
Note that the harmonic mean H(n) of a set of numbers {x 1 , x2, -
.x,} is
defined by
1
1
1
1
1
+—+•• .—(1 .124)
H
n
xl
x2
x„
The following theorem gives the relationships between the number n and
the harmonic and arithmetic means of the divisors of n .
o(m.l ) = m.1 +ml = 2m1 ,
then rn 1 is called a perfect number. If k = 2, that is
(1.128)
Theorem 1 .4.9 . Let A(n), G(n) and H(n) be arithmetic, geometric an d
harmonic means, respectively. Then
a(ml ) = mi + m2 = u(m2),
then
.m2 ) is called an amicable pair . The k integers m l ,m2i ' '
called an amicable k-tuple if
(1 .129)
' , mk are
(1) The product of the harmonic and arithmetic means of the divisors of n
is equal to n
Q(m'r) = 4 (m 2) =
. .
= Q (mk) = m.l + m2 + . . . + Mk .
(1 .130)
n = A(n) ' H(n),
(1 .125)
(In case k = 3, we call them amicable triples .)
(2)
H(n) < G(n) =
n < A(n) .
(1.126)
Example 1.4.5. The following are some examples of perfect, amicable an d
sociable numbers :
(1)
6. 28. 496 and 8128 are the first four perfect numbers, whereas
24053946( 24003946 – 1) is the largest known perfect number at present.
Since once we found a Mersenne prime of the form 2P – 1. we found an
(even) perfect number of the form 2p–1 (2P – 1) . As there are 39 known
Mersenne primes at present (see Table 1 .2) . there are 39 known perfect
numbers .

72
1 . Elementary Number Theory
1 .4 Arithmetic Functions
73
(2)
(220, 284),
(1184,1210), (2620 . 2924)
and
(5020, 5564) are the
first four amicable pairs. The following is a large amicable pair :
(2s
p 65
. in
q 1 .
2s ' p6' ' q ' q2) with
p = 37669773212168992472511541.
q = 609610904872320606430695102719 .
in = 569 5023
22866511 . 287905188653 .
ss
ss
Both numbers in the pair have 3383 digits ; it was found by M . Garcia
in 1997. But it is still not the largest known amicable pair; the largest
known amicable pair at present has 5577 digits in both its numbers. To
date, there are in total 2494343 amicable pairs are known . Table 1.8 gives
the frequency of these known amicable pairs distributed over the number
of digits in the smaller number (the list exhaustive up to 10 72) .
(3) (1980 .2016, 2556), (9180.9504,11556) and (21668 .22200, 27312) are the
first three amicable triples with ml
7n2
m3 ; the last two triples
were found by Te Ride in 1994 whereas the first one was known a long
time ago . (amr,am 2i arm.am,4,ams) is an amicable 5-tuple, with a =
2' s . 35 . 5 . 73 . 13 . 3141, mr = 11 - 359, 7n2 = 23
179, m3 = 47 - 89,
rn 4 = .53 79, rn.4 = 59 . 71 ; it was found by C . Krishnamurthy in 1980 .
(4) (1236402232,1369801928,1603118392 .1412336648) is an aliquot 4-cycle .
The longest aliquot known cycle is the aliquot 28-cycle with m.l
=
14316 = 22 - 3
1193 : it was found by P. Poulet in 1918. About 119
aliquot k-cycles for 4 < k < 28 have been found to date (with k = 28 the
longest, generated by 14316) :
For perfect numbers .. we have the very convenient necessary and sufficien t
condition for an even number to be perfect :
Theorem 1 .4 .10 (The Euclid—Euler Theorem) . n is an even perfect
number if and only if n. = 2n—7 (26 — 1), where 26 — 1 is a Mersenne prune .
Proof.
AVe first prove that this is a necessary condition for m. to be perfect .
Let. rr = 2 6—7 (26 — 1) . Then
a (n) = a(26—r)a(26 _ 1)
= (26 — 1)26
(since 26 — 1 is prim e
=2 . 2i' '(26 —1)
= 272 .
Table 1.8 . Number of Known Amicable Pairs (By courtesy of Mr_ Jan Munch
Pedersen)
Digits
0
1
2
3
4
5
6
7
8
9
0-9
0 ©®
8
29
66
128
350
® 841
1913
4302
9867
15367 30604 5881
1991
1851
® 1750
1916
1936 ® 2405
2817
2914
3306
3977
4699
30-39
5240
5565
6276 ® 6899 ® 8029
8661
8804
I12013 12876 13078 ® 12343 12383 15085 17050 ® 1693 3
I18409 18477 20555 18142 ® 16068 16576 16564 13678 1269 7
60-69 ®®®® 10961 12099 ® 48368 40170 3460 1
70-79
31817 27639 75099 ® 48401 41159 46813 44160 50008 3901 7
80-89
41982 46845 51611 47552 55896 49069 ® 41510 39944 41246
90-99
46649 ® 36427 32406 33921 31181 29169 ® 25986 28029
100-109 27840 ® 20766 18801 18288 18267 16257 ® 12668
® 11189 18642 16929 15070 13570 12468 ® 10517 9557
8892
120-129 8358
7684 ® 8733 16396 15748 14108 ® 12695 11986
130-139 11348 10522 10271 9498
9103
8434
7704 ® 6468
6177
® 5546
5217
4449
4042
3620
3297
2999
2651
2281
2240
150-159 2352
2065
1746
1484 ® 1184
1101
979
833
160-169 ® 814 ® 672
882 ® 1158
1158
1154
1100
170-179 1001
968
939
852 ®® 718
674
666
646
180-189
667
606
566 ®®® 453 ® 439
387
190-199
358
379
362 ®® 289
190
288 ®®
200-209®® 185
152
161 ® 131
150
96
119
210-219®® 112 ®
87
66 ®
68 ®®
220-229
60
70
70 ®
55
69
66
48
56
230-239
55 ®®
50 ®
41 ®®
32
46
240-249 ®®®®
40 ®®
98
84
90
250-259
79
66
70 ®
85
80 ®
64
63
260-269 ®®
50
99
78 ®
62
63
60
45
®®
56 ®
49
34
49 ®®
39
280-289 ®
36 ®®®
33 ®®
28
290-299 ®
21
20
18 ®®®®®®
613 pairs with 300-55777 digits
There are 2574378 pairs in total
Therefore, by Definition (1 .4.5) . n is a perfect number . Next, we prove that.
even perfect numbers must be of the given form. Let n be an even perfect
number and write it as
n = 26—1 q
with q odd .
Since gcd(2r'-1 ,q) = 1, then
a(rr) = a(2'
)a(q) = (26 — 1)a(q) .
By Definition 1 .4.5. we must have
a(n) = 2'n = 2 6q_
(1 .132)

74
1 . Elementary Number Theory
1 .4 Arithmetic Functions
t o
Combining (1 .131) and (1.132) . we get
2Pq = (2P — 1)a (q)
= (2P – 1)(s(q) + (I)
(since s(q) = a(q) – q)
Therefore .
q = s(q)(2P – l) .
(1.133)
Clearly, (1.133) implies that d = s(q) is a proper divisor of q . On the other
hand, s(q) is the sum of all proper divisors of q . including d. so that there
cannot be any other proper divisors besides d . But a number q with a single
proper divisor d must be a prime and d = 1 . So from (1.133), we can conclude
that
q=2P – 1
is a Mersenne prime. Thus each even perfect number is of the form
2P–t (2P – 1)
where 2P – 1 is a Mersenne prime .
0
The sufficient condition of the above theorem was established in Euclid' s
Elements (Book IX, Proposition 36) 2000 years ago, but the fact that it is also
necessary was established by Euler in work published posthumously . Thus we
have an example of a theorem in Number Theory that took about 2000 years
to prove. However. we still do not know if there are infinitely many perfec t
numbers and we also do not know if there exists an odd perfect number ; we
know that there are no odd perfect numbers up to 10 300 (Brent . Cohen and
Te Riele, [39]) and if there is an odd perfect number it should be divisibl e
by at least eight distinct prime numbers . Compared with perfect numbers .
unfortunately, we not only do not know whether or not there exist finitely
many amicable pairs, but also do not have necessary and sufficient condition s
for amicable numbers (i.e., we do not have a general rule for generating al l
amicable pairs) .
The first (algebraic) rule for amicable numbers was invented by the Ara b
mathematician Abu-l-Hasan Thabit, ibn Qurra' 5 and appeared in his book
in the ninth century :
r5 Thabit ibn Qurra (824 901) . a famous Arab mathematician of the 9th century .
lived in Baghdad as a money changer . but he was highly esteemed for his writings
on medicine. philosophy, mathematics, astronomy and astrology. He wrote a
Book on the Determination of Amicable Numbers (Figure 1.6 shows the front
cover of the book). in which he proposed his famous rule for amicable numbers :
"if p= 3 . 2 "—n , q = 3 - 2 " — 1 and r = 9 . 2 2' 1 - 1 are primes, then If = 2"
-p - q
and IV = 2 " . r are amicable numbers" . In his remarkable treatise entitled "On
the Verification of the Problems of Algebra by Geometrical Proofs" . he showed
that the three types of quadratic equations :
x ' — ax + c
0, :r'
ra c — c = O .
and x 2 + a.t — c = 0 can be solved by means of Propositions 5 and 6 in Book I I
of Euclid 's Elements. Thabit was also a most competent translator from Greek
and Syriac to Arabic; he translated works of Euclid, Archimedes . Apollonios,
Autolykos, Ptolemaios . Nikomachos. Proklos and others .
Figure 1 .6. The cover of Thabit's book on amicable numbers (by courtesy of Guedj
X95))
Theorem 1.4.11 (Thabit's rule for amicable pairs) . If
p=3 . 2"–r – 1
q=3 2 – 1
(1 .134)
n. = 9 .2a"–r– 1
are all primes, then
(IL ti)=(2" .p .q, 2" . r)
(1 .135)
is an amicable pair .
Proof. First, we have
(7(111)=o(2" .p .q)
= o(2")u(p)a(q )
= a(2")u(3 . 2a—r — 1)a(3 . 2 " — 1 )
= (2"D l – 1) (3 - 2' 1 )(3 - 2" )

76
1 . Elementary Number Theor y
= 9 . 22'1(2" - 1)
a(N) = a(2" , r)
= a(2)Q(9 2
1)
= 9 . 22"-r (2n+r - 1 )
.li + N = 2"(p ' q + r)
= 2"[(3 .2"-r - 1)(3 . 2" - 1) + (9
. 22"-r - 1)]
=2"(9_22n-r—3 .2"-3 .211-1+ 9 .2_2- 1)
= 2"(9 . 22e - 9 , 2"-r )
= 2" [(9 . 2" -1(2"+r - 1 )]
= 9 . 22"-i(2'
- 1) .
So (M, N) = (2" . p
q, 2" - r) is an amicable pair .
q
For n = 2 Thabit's rule gives the first and also the smallest amicable pai r
(M, N) = (22 . 5 • 11, 22 . 71) = (220, 284)
attributed to the legendary Pythagoras rb . Two further pairs obtained by
Thabit's rule are for n = 4 and n = 7 (see Borho and Hoffmann [32]) : in the
early 14th century Ibn al-Banna in Marakesh and also Kamaladdin Farisi in
Baghdad discovered the pair for n = 4:
(i, N) = (2`' . 23 - 47, 2 4 . 1151) = (17296, 18416 )
and in the 17th century Muhammad Baqir Yazdi in Iran discovered the pair
fora=7
(_1i. N) = (2 '
191 383, 2 ' . 73727) = (93631584, 9437056) .
However, after a = 7, Thabit's method seems to dry up and has not, produced
any other amicable pairs .
1s
Pythagoras (died about 500 B .C.) was born on the Greek island of
Samos. He founded his famous school at the Greek port of Crotona
(now in southern Italy) and discovered the Pythagoras Theorem .
namely that a2 +b2 = e2 where a. b and e are the lengths of the two
legs and of the hypotenuse of a right-angled triangle, respectively .
The Pythagoreans believed that Everything is Number. Becaus e
of their fascination with natural numbers, the Pythagoreans mad e
many discoveries in number theory, and in particular. they stud-
ied perfect numbers and amicable pairs for the mystical properties they felt thes e
numbers possessed .
1 .4 Arithmetic Functions
77
Euler r' was the first to study amicable numbers systernatmally. Based on
Thabit's work. he developed several new methods for generating amicabl e
numbers and found 59 new amicable pairs . Since Euler's time, many mor e
amicable pairs have been found . most of them with the help of variations o f
Euler's methods . The following rule developed by Euler is directly based o n
Thabit's rule :
Theorem 1.4.12 (Euler's rule for amicable pairs) . Leta be a positive
number. and choose 0 < x < n. such that q =
+ 1. If
p=2'g- 1
q=2"q - 1
(1 .136)
s= 2"+y
. g2 - 1
are all primes, then
(M, N) = (2" . p . q,
2" . s)
(1 .137)
is an amicable pair .
It is clear that Euler's rule is a . generalization of Thabit's rule . That is,
when a - J. = 1, it reduces to Thabit's rule . There are many rules (althoug h
none of them are general) for generating amicable pairs ; interested readers
may wish to verify that if
f =2 k + 1
2111-k f2
9 =
'
"
ri = f'2"`-'' - 1
r2 = f .2", - 1
p=g(2"'+r - 1) + 1
q 1 =p" [g (2"z-1)+2]- 1
q2 =
.p" ' q [(2"' — 1 )g + 2 ] —
17
Leonhard Euler (1707-1783) . a key figure in 18th century math-
ematics. was the son of a minister from the vicinity of Basel .
Switzerland. who, besides theology, also studied mathematics . He
spent most of his life in the Imperial Academy in St . Petersburg.
Russia (1727-1741 and 1766 1783) . "Prolific" is the word most of-
ten applied to Euler, from whom gushed forth a steady flow of wor k
from the age of 19 on. even though he was blind for the last 17 years
of his life. (He also had 13 children .) Mainly known for his work in
analysis. Euler wrote a calculus textbook and introduced the present-day symbols
for e, o and i. Among Puler's discoveries in number theory is the law of quadratic
reciprocity, which connects the solvability of the congruences s 2 . p (mod q) and
y-
q (mod p), where p and q are distinct primes, although it remained for Gauss
to provide the first proof'. Euler also gave a marvellous proof of the existence o f
infinitely many primes based on the divergence of the harmonic series En -r .
(1 .138)

78
1 . Elementary Number Theory
1.4 Arithmetic Functions
79
are all primes (where k . rn. n E N and in > k) , then
(M, N) = (2"'
pn
_ ri
r? . gi,
2'"
p"
(1 . )
(1 .139)
is an amicable pair .
It is interesting to note that although we do not know whether or not
there exist infinitely many amicable pairs. we do have some methods which
can be used to generate new amicable pairs from old ones : the following is
one of the very successful methods invented by Te Riele 18 [203] in 1983:
Theorem 1.4.13 . Let (b7' . N' ) = (a . u, a . p) be a. given amicable pair
(called a breeder pair) with gcd(a, u) = gcd(a, p) = 1. where p is a prime. If
a pair of primes (r. s), with p < r < s and gcd(a. r . s) = 1, exists. satisfying
the following bilinear Diophantine equation
(r — p) (s p) = a(a) a(u)2
(1.140)
and if a third prime q exists, with gcd(a
(I) = 1 and
q=r+s+ u
then (Al, N) = (a . u . q . a r . s) is also an amicable pai r
Proof. See pages 170—172 in [261] .
Very surprisingly we are in trouble as soon as k = 3. for no one has
yet come up with an example . and this in spite of the fact that an algorithm
(Borho [31]) exists which purports to produce them! This algorithm generate s
the following four numbers :
p=2"_ 1
(2''TI — 1)(2" — 1) + 2" —" (2"+i _ 1 )
Pi _
p
P2 = 2'' (Pi + 1) — 1
p3 = 2" (2' 1 — 1) + 2"+1 — 1
where i. . u E N. u > e and 2u + 1 = 0 (mod v) . If p. pi . p2, p3 are all primes ;
then
Herman J. J. to Riele, a leading computational number theorist, is a senior scien -
tist at the Centre for Mathematics and Computer Science (CWI) in Amsterdam,
the Netherlands. Te Riele works in several central areas of computational number
theory and has made significant contributions to the field : he jointly with A . M .
Odlyzko at AT&T. showed in 1985 that Mertens's conjecture was false. (Mertens
conjectured that 1AI(x)j < f for all x
> 1, where M(x) = E„<~ p(n).) This
question. which was in the minds of many classical number theorists, includin g
Stieltjes and Hadamard, was very important to settle . Together with the Germa n
mathematician W . Borho, he has discovered more amicable pairs and rules tha t
generate amicable pairs than anyone else.
(mi . m 2, m3) = (2" .p . m .
2'
. P2- 2" . P3)
(1.143)
is an aliquot 3-cycle. Unfortunately. these four numbers don't seem to wan t
to play! Nevertheless it is conjectured that aliquot 3-cycles exist. Readers
who are interested in perfect, amicable and sociable numbers are invited to
consult Yan [261] for more information .
1 .4.4 Functions (/)(n), .Mn) and µ(n)
Let us first introduce Euler's (totient) 6-function, attributed to Euler .
Definition 1 .4.6. Let n be a positive integer . Euler's (totient) 4-function ,
¢(n), is defined to be the number of positive integers k less than n which are
relatively prime to n. :
0(n) _ )
1.
cc ,
Example 1 .4 .6 . By Definition 1 .4 .6, we have :
n
1
2
3
4
5
6
7
8
9
10
100
101
102
o(n)
1
1
2
2
4
2
6
4
6
4
40
100
32
Lemma 1 .4 .2 . For any positive integer n .
E 6(d) = n .
dl n
Proof.
Let nd denote the number of elements in the set {1 .2, . . . , n} having
a greatest common divisor of d and n. Then
n= E n-d = E¢
n
din
din
d
Theorem 1 .4 .14. Let n be a positive integer. Then
(1) Euler's 0-function is multiplicative . that is . if ged(rn, n) = 1, then
dr(mn) = 6(m)e(n) .
(1 .146)
(2) If n is a prime, say p, then
d(p) = p — I .
(1 .147)
(Conversely, if p is a positive integer with 6(p) = p — 1. then p is prime.)
(1 .142)
is
(1 .144)
103
102
(1 .145)

80
1 . Elementary Nurnber Theory
1 .4 Arithmetic Functions
81
(3) If n is a prime power pa with o > 1 . then
4(pa)=pa—pa
1
(1.148)
(4) if n is a composite and has the standard prime factorization form, then
1- 1 p 1
1)
. .pAA
1 - 1
C
pl /
P2 /
Pk
(l -
1- )
P
Proof.
(1) Since g(n) = n is multiplicative and n = E o(n), it follows from Theo -
rem 1.4.3 that the o-function is multiplicative .
(2) If 11. is prime, then 1, 2	
n - 1 are relatively prime to n . so it follows
from the definition of Euler's o-function that o(n) = n - 1. Conversely,
if n is not prime, n has a divisor d such that gcd(d, n)  1 . Thus, there
is at least one positive integer less than n that is not relatively prime t o
n. and hence o(n) < n - 2 .
(3) Note that gcd(n, p" ) = 1 if and only if p { n . There are exactly p"-1
integers between 1 and pa divisible by p, namely,
p. 2p, 3p . .,
(pa-1 )p.
Thus, the set {1, 2,- . . ,p" } contains exactly p" - pa–1 integers that
are relatively prime to p and so by the definition of the 9-function ,
O(pa ) = pa -e-l .
(4) We use mathematical induction on k, the number of distinct prime
factors. By Part (3) of this theorem . the result is true for k = 1 . Suppose
that the result is true for k = i . Since
I
a–1
a2
a,
a =+ i
get
~p1
P2
. . . Pi , pi+l
- 1,
the definition of multiplicative function gives
o ((Pr pa~_
)
la; , )
o (pi ?1'2 . . . p(,,) o
)
(pi+I
a; i
a r+,
_ )
o (p, Ip n2
. .
) (pi+l
1l =
1
(pal — pl'
1)
(p° `
p1 i )
1
1
1
n\1—p1/ (1
P2)
. . .(I
pr+ ,
So, the result holds for all positive integer k .
Remark 1 .4.1. Suppose that n is known to be the product of two distinct
primes p and q . Then knowledge of p and q is equivalent to knowledge of o(n) .
since q(n) = (p - 1)(q - 1) . However, there is no known efficient method t o
compute o(n) if the prime factorization of n is not known . More precisely,
one can compute O(n) from p and q in O(log a) bit operations, and one ca n
compute p and q from n and o(n) in O(logn) 3 bit operations (see Koblitz
[128]) . This interesting fact is useful in the RSA public-key cryptography.
which will be studied in detail in Chapter 3 .
The following function, first proposed by the American mathematicia n
Carmichael19 , is a very useful number theoretic function .
Definition 1 .4 .7. Carmichael's a-function, A(n), is defined as follows :
for prime p,
for p = 2 and a < 2 ,
and for p > 3
A(2" ) = 24(2°)
A(n) = Icm (A (pi' ) A (pr
Example 1 .4.7. By Definition 1 .4.7, we have :
n
1
2
3
4
5
6
7
8
9
10
100
101
102
103
a(n)
1
1
2
2
4
2
6
2
6
4
20
100
16
102
Example 1 .4.8. Let n = 65520 = 2^ . 32 - 5 - 7 . 1.3. and a = 11. Then
gcd(65520.11) = 1 and we have
0(65520)=8 . 6 . 4 . 6 . 12=13824 .
A(65520) = lcm(4, 6, 4, 6,12) = 12 .
Euler's 6-function and Carmichael's a-function are two very useful arith-
metic functions particularly in public-key cryptography which we shall dis-
cuss in Chapter 3 of this hook: some important properties about Puler's
o-function and Carmichael's a-function will be discussed in Subsection 1 .6.2.
L9 Robert D. Carmichael (1879- 1967) was born in Goodwater, Alabama. He re-
ceived his BA from Lineville College in 1898 and his PhD in 1911 from Prince-
ton University. His thesis. written under G. D. Birkhoff, was considered th e
first significant American contribution to differential equations . Perhaps best
known in number theory for his Carmichael numbers, Carmichael s function.
and Carmichael 's theorem„ Carmichael worked in a wide range of areas. includ-
ing real analysis, differential equations, mathematical physics, group theory an d
number theory. It is also worthwhile mentioning that Carmichael published two
'erg readable little books about number theory : Theory of Numbers in 1914 and
Diophantine Analysis in 1915, both published by John Wiley Sr Sons. New York.
o(n)
=
(1 .149)
a, + ]
Pi-el
a i+1- 1 )
pi+l
1
1
4'
C1—
1f;"
1- -
pl)
P2
~(p)=4(p)=p- 1
A(pa ) = 4(p")
A (4k ))
fora> 3
(
if n =
p"'
i=1
(1.150)

82
1 . Elementary Number Theor y
Now we move on to another important arithmetic function . the Mains func-
tion . named after A . F . Mobius'-0 .
Definition 1 .4 .8 . Let n be a positive integer. Then the Mobius µ.-function.
µ(n), is defined as follows :
ifn=1 .
0 .
if n contains a. squared factor ,
(—1) k ,
if n =p1P2 . . .Pk is the product of
k distinct primes .
Example 1 .4.9. By Definition 1 .151, we have:
n
1
2
3
4
5
6
7
8
9
10
100
101
102
µ(n)
1
-1
-1
0
-1
1
-1
0
0
1
0
-1
-1
Theorem 1 .4.15 . Let p(n) be thellobius function. Then
(1) µ(n) is multiplicative. i.e., for gcd(m, n) = 1 ,
µ(run) = µ(m)µ(n) .
(1 .152)
(2) Let
v(n) =
p(d) .
(1 .153)
d la
Then
1,
if n = 1 ,
v(n) _
(1 .154)
0
ifn>1 .
Proof.
(1) If either p2
m or p2
I n. p is a prime, then p2
inn . Hence . µ(mn) = 0 =
p(7n)µ(n) . If both m and n are square-free integers, say. m = pips . . . Ps
and n = q qz - qt . then
20
Augustus FerdinandMobius (1790 1868) was born in Schilpforta
in Prussia. Mains studied mathematics at Leipzig . Halle and fi-
nally at Gottingen with Gauss . He became a lecturer at Leipzi g
in 1815 and Professor in 1844; he held the post there until hi s
death. Mobius is perhaps best known for his work in topology, es-
pecially for his conception of the Mobius strip, a two dimensional
surface with only one side . He is also well-known for proposin g
the colouring of maps in 1840, which led to the famous four -
colouring problem.
1.4 Arithmetic Functions
8 3
µ(vin)
p(piP22 . . .psgrg9
. . q1 )
(—0'
(—1) s (—1)r
µ(rn)p(n)
(2) If n
1, then v(1) = E v(d) = p(l) =
1 . If n > 1, since v(n) i s
d o
multiplicative . we need only evaluate v on prune to powers . In addition ,
if p is prime,
v(pa)
p (l) + u(p) + µ(p2 ) + . . . + µ(P`s)
1+(—1)+0+
+ 0
0 .
Thus, v(n) = 0 for any positive integer n greater than 1 .
q
The importance of the :Mobius function lies in the fact that it plays a n
important role in the inversion formula given in the following theorem . The
formula involves a general arithmetic function f which is not necessaril y
multiplicative .
Theorem 1 .4.16 (The Mobius inversion formula) . If f is any arith-
metic function and if
g(n) =
f (d),
(1.155)
dIn
dhz
If f is an arithmetic function and g(n) = E f (d) . Then
dl'a
E µ(d)
f(a)
(-IM
c1(n/d )
= E E
µ(d)f(a)
din akn/d )
E E
f(a) p(d)
d ;n aj( o/d )
E f(a) E
µ(d)
d~a
a((ajd )
= f (n) . 1
= f(n) .
then
f(n)=
(—) g(d)=µ(d)g(s) .
(1 .156)
Proof.
n
µ(d) g
d

84
1 . Denim ntar Number Theory
1..5 Distribution of Prime Numbers
85
The converse of Theorem 1 .4.16 is also true and can be stated as follows :
1 .5 Distribution of Prime Number s
Theorem 1 .4.17 (The converse of the Mobius inversion formula) .
It will be another ?pillion years . at least . before we understand the primes .
PAUL Enoos (1913—1996 )
(d) 9(d),
(1.157)
f (a )
If
then
Note that the functions T and a
T(n) =
1
and
0(n) =
dbr a
may be inverted to giv e
1=
() T(d)
and
la
d ]
for all n >
1 . The relationship between Euler's phi-function and Mobius '
p-function is given by the following theorem .
Theorem 1 .4.18 . For any positive integer n,
µ(d)
(1.159)
Proof. By applying Mobius inversion formula to
9(n) = n = > 6(d)
As mentioned earlier . prime numbers are building blocks of positive integers .
In fact, the theory of numbers is essentially the theory of prime numbers . In
this section . we shall introduce some important results about the distributio n
of prime numbers . More specifically. we shall study some functions of a real
or a complex variable that are related to the distribution of prime numbers .
1 .5 .1 Prime Distribution Function ar(r )
Let us first investigate the occurrence of the prime numbers among the posi-
tive integers . The following are some counting results of the number of primes
in each hundred positive integers :
(1) Each 100 from 1 to 1000 contains respectively the following number o f
primes :
25. 21, 16, 16, 17. 14, 16, 14. 15, 14 .
(2) For each 100 from 10 6 to 106 + 1000. the corresponding sequences are :
6, 10 . 8, 8, 7, 7, 10. 5. 6, 8 .
(3) For each 100 from 10' to 10' + 1000 . the corresponding sequences are :
2. 6. 6. 6 . 5. 4. 7, 10 . 9. 6 .
(4) For each 100 from 10 12 to 10 12 + 1000, the corresponding sequences are :
4. 6, 2, 4. 2. 4, 3. 5. 1 . 6 .
Except 2 and 3, any two consecutive primes must have a distance that is a t
least equal to 2. Pairs of primes with this shortest distance are called twi n
primes. Of the positive integers < 100. there are eight twin primes, namely.
(3 .5) . (5.7) . (11.13) . (17.19) . (29,31) . (41 .43), (59,61) . (71.73) .
In spite of the seemingly frequent. occurrence of twin primes, there are howeve r
arbitrarily long distances between two consecutive primes_ that is, there ar e
arbitrarily long sequences of consecutive composite numbers . To prove this ,
one needs only to observe that for an arbitrary positive integer n > 1, th e
following n — 1 numbers
g(n) _> f(d) .
(1 .158)
0(n) = n ,
d
dl,~
we get
4(a) =
/I(d) g (
)
cl
Ed µ(d) n
d

86
1 . Elementary Number Theory
1 .5 Distribution of Prime Numbers
87
n! + 2, n! + 3, it! + 4,
n + n.
are all composite numbers . The above investigations show that the occurrence
of primes among positive integers is very irregular . However, when the large-
scale distribution of primes is considered, it appears in many ways quite
regular and obeys simple laws. In the study of these laws . a central question
is : "How many primes are there less than or equal to x" ? The answer to this
question leads to a famous expression. r(x) . which is defined as follows .
Definition 1 .5 .1 . Let x be a positive real number > 1 . Then r(x), is defined
as follows :
it Er) =
That is, x(x) is the number of primes less than or equal to x ; it is also called
the prime counting function (or the prime distribution function)
Example 1 .5 .1 . The prime numbers up to 100 are :
2,3,5,7,11,13,17,19,23,29,31,37,41,43 ,
47,53,59,61,67,71,73,79,83,89,97 .
Thus we have
x(1) = O .
r(2) = 1,
r(3) = 2,
x(10) = 4,
x(20) = 8 .
7x(30) = 10,
x(40) = 12,
7x(50) = 15,
x(75) = 21,
x(100) = 25.
A longer table of values of r(x) can be found in Table 1.9 .
The numerical values of the ratio of r(x)/x in Table 1 .9 suggest (in fact
it is not difficult to prove) that
lim x(r,) = O .
(1.161 )
That is . almost all the positive integers are composite numbers. It must be .
however, pointed out that even though almost all positive integers are com-
posites, there are infinitely many prime numbers, as proved by Euclid 200 0
years ago. So, in terms of r(x) . Euclid's theorem on the infinitude of prime
numbers can then be re-formulated as follows:
lim r(x) = x .
(L162 )
The asymptotic behaviour of r(x) has been studied extensively by many
of the world's greatest mathematicians beginning with Legendre in 1798 and
culminating in 1899 when de la Vallee-Poussin proved that. for some constant
c > O .
Table 1.9. Table of values of r(r)
r(x)
x(x)/r
10
4
0 .4
102
25
0.25
10'
168
0.168
10 '
1229
0.1229
10'
9592
0.09592
106
78498
0.078498
10 `
664579
0.0664579
108
5761455
0.0576145 5
10`'
50847534
0 .050847534
10 10
455052511
0.04550525110
10 "
4118054813
0.0411805481 3
10 12
37607912018
0.03760791201 8
10 '3
346065536839
0 .0346065536839
10 '
3204941750802
0.0320494175080 2
10 '
29844570422669
0.02984457042266 9
10 16
279238341033925
0 .0279238341033925
10 ' '
2625557157654233
0 .0262555715765423 3
10 L8
24739954287740860
0 .0247399542877408 6
1019
234057667276344607
0.023405766727634460 7
1020
2220819602560918840
0.022208196025609188 4
10 L1
21127269486018731928
0.02112726948601873192 8
1022
20146728668931 .5906290
0.0201467286689315906290
Note that the big-0 notation used above was first. introduced by German
mathematician Edmund Landau . Intuitively, f is 0(g) if there is a real pos-
itive constant k such that f (x) < k • g(x) for all sufficiently large x . The
big-0 notation is very useful in computational complexity, and we shall use
it throughout the book .
In the next few subsections . we shall study the asymptotic behaviour of
x(.r) . More specifically, we shall study the approximations of ;r(x) by the
functions 111x , Li(x) and R(x) .
1.5.2 Approximations of 7r(x) by x/ In x
Although the distribution of primes among the integers is very irregular ,
the prime distribution function r(x) is surprisingly well behaved . Let us first
study the approximation
1
to x(x). Table 1 .10 gives the values of x(x), m x
fr(x
and x/ ln):r. ' for x = 10.102 . io2 ,- , 1020 . It can be easily seen from Table
1.10 that the approximation J'/in x gives reasonably accurate estimates o f
(1.160)
tit
x(`x)
In f, + 0 (xexp{
° 3ln :r
.
(1 .163)

88
1 . Elementary Number Theory
1.5 Distribution of Prime Numbers
89
Table 1 .10. Approximations to 2r(r) by .r/ In .r
r
(,c)
r
Inx
n(r)
min x
10 '
4
4.3 . . .
0.93 . - -
10'
25
21 .7 .
1.152- -
103
168
144.8 . . .
1 .16 . . .
10'
1229
1085.7 .
1 .13• . .
10'5
9592
8685 .8
-
1 .131
100
78498
72382.5 . .
1 .084 -
10r
664579
620420.5 . .
1.071
.
108
5761455
5428680.9• . -
1 .061
109
50847534
48254942.5- . .
1 .053— .
1010
455052511
434294481 .9- . -
1 .047 . . -
10"
4118054813
3948131653 .7- . .
1 .043 .
.
10 1-
37607912018
36191206825.3 . . .
1 .039
1013
346065536839
334072678387.1 . .
1.035 -
1014
3204941750802
3102103442166 .0• . -
1 .033 . . .
101'
29844570422669
28952965460216 .8- .
1 .030 — .
1010
279238341033925
271434051189532 .4 . .
1 .028 .
101r
2625557157654233
2554673422960304 .8
1 .027 . . .
10 1ri
24739954287740860
24127471216847323 .8
-
1 .025
-
1010
234057667276344607
228576043106974646.1 — .
1 .023- .
102U
2220819602560918840
2171472409516259138 .2 . . -
1.022
10 L1
21127269486018731928
20680689614440563221 .4 —
1.021
.
1022
201467286689315906290
197406582683296285295 .9
1.020 . . .
4-10L2
783964159852157952242
768592742555118350978 .9 . - .
1.019
7r(x) . In fact . the study of this approximation leads to the following famous
theorem of number theory. and indeed of all mathematics .
Theorem 1 .5.1 (Prime Number Theorem) . ir(x) is asymptotic to
In x That is ..
(1 .164)
The Prime Number Theorem (PNT) was postulated by Gauss 2r in 1792 on
numerical evidence. It is known that Gauss constructed by hand a table of al l
primes up to three million, and investigated the number of primes occurrin g
in each group of 1000 . Note that it was also conjectured by Legendre 22 before
Gauss . in a different form. but of course both Legendre and Gauss were unable
to prove the PNT .
The first serious attempt (after Gauss) to study the function ir(x) was
due to Legendre. who used the sieve of Eratosthenes and proved in 1808 tha t
ir(o)= (
n)—1 +
where the sum is over all divisors d of the product, of all primes p < n, and
µ(d) is the \-lobius function. Legendre also conjectured in 1798 and again i n
1808 that
(x)
x—4(x)
21
Carl Friedrich Gauss (1777—1855), the greatest mathematician of
all time (Prince of Mathematicians), was the son of a German
bricklayer. It was quickly apparent that he was a child prodigy .
In fact, at the age of three he corrected an error in his father' s
payroll, and at the age of seven, he can quickly calculate 1 + 2 +
3 +
. + 100 = 5050 because 50(1 + 100) = 5050 . Gauss made
fundamental contributions to astronomy including calculating th e
orbit of the asteroid Ceres. On the basis of this calculation, Gauss
was appointed Director of the Gottingen Observatory. He laid the foundations o f
modern number theory with his book Disquisitiones Arithmeticae in 1801. Gauss
conceived most of his discoveries before the age of 20 . but spent the rest of his life
polishing and refining them .
22
Adrien Marie Legendre (1752-1833), a French mathematicia n
who. with Lagrange and Laplace, formed a trio associated with
the period of the French Revolution . Legendre was educated at
College Mazarin in Paris and was Professor of Mathematics at
Ecole Militaire Mazarin in Paris for five years. He resigned to de -
vote more time to his research . In 1782, he won a prize offered
by the Berlin Academy with a paper in ballistics . Legendre gave
the first proof that every prime has a primitive root . He was also
the first to determine the number of representations of an integer as a sum of tw o
squares and proved that every odd positive integer which is not of the form 8k+7 is
a sum of three squares . Legendre conjectured the Prime Number Theorem and the
Law of Quadratic Reciprocity but of course unable to prove them. In his later years .
Legendre's investigations focussed on elliptic integrals . At the age of 75 . Legendre
proved the Fermat, Last Theorem for n = 5. It was unfortunate that Legendre lived
in the era of Lagrange and Gauss and received less recognition than he deserved .
T(x)
lim
—>x x/lnx
(1.165)
x
(1.166)

90
1. Elementary Number Theory
1 .5 Distribution of Prime Numbers
91
where lirn .4(:r) = 1.08366 . - - . It was shown 40 years later by Chebvshev -
that if lira .-1(x) exists. it must be equal to 1 (see Ribenboirn [200]) . It is
r~ x
also interesting to note that around 1850 (about 50 years before the Prim e
Number Theorem was proved) . Chebvshev showed tha t
0.921291n ' 
< ;r(x) G 1.1056  
(1.167)
x
ln x
for large x . Chebyshev's result was further refined by Sylvester in 1892 t o
0 .95695 ' 
<
(x) < 1 .04423 
.z'
(1.168)
ln .r
In.r
for every sufficiently large x . Chebvshev also worked with the function 0(.r) ,
defined by
6(:r) =
lnp
(1 .169)
p< c
now called Chebyshev-'s function . which is closely related to 7r(0. That is .
Theorem 1.5.2.
0(x)
lira 
= 1 .
x
.r
Note that the summatory function of i1(n) defined in (1 .177), denoted b y
ti'(x), is easily expressible in terms of Chebyshev's 0-function
x) = 0(x) + 9(x n/' ) + 8(x1/ 2) +
.
.
.
(1 .171)
The Prime Number Theorem may then be rephrased as follows :
Theorem 1 .5 .3 .
lnn v(x) = 1 .
(1 .172)
It can be seen that Chebvshev came rather close to the Prime Number
Theorem; however. the complete proof of the PNT had to wait for about 5 0
23
Pafnuty Lvovich Chebvshev (18211894) . was a Russian mathe-
matician and founder of a notable school of mathematicians i n
St Petersburg. He made St Petersburg for the second time, afte r
Euler. a world centre of mathematics. He contributed to several
branches of mathematics and his name is remembered in results i n
algebra, analysis and mathematical probability . In number theory .
he proved. among many other things, Bertrand 's postulate that .
if n E N. then there is at least one prime p such that n < p < 2n.
Chebvshev was appointed in 1847 to the University of St Petersburg . became a
foreign associate of the Institut de France in 1874 and also a foreign Fellow of th e
Royal Society, London .
years more. During this time. Riemann'r had the idea of defining the zet a
function for complex numbers s having real part greater than 1 . namely .
(we shall return to the zeta function soon) . and attempted to give a proof
of the prime number Theorem using the zeta function . Although Riemann's
proof was not adequate but contained the ideas essential for a complete proof.
The theorem was established in 1896 independently by two eminent mathe-
matical analysts: Jacques Hadamard25 and the Belgian mathematician De la
Vallee-Poussin2 b independently proved the theorem. Since Euclid discovered
2000 years ago that "there are infinitely many prime numbers" , thousands of'
21
Georg Friedrich Bernhard Riemann (1826–1866) . the son of a min-
ister, was born in Breselenz, Germany . Riemann was a major fig-
ure in 19th century mathematics. somewhat the father of mod-
ern analytic number theory. and the last of the famous trilogy
at Gottingen (the other two were Gauss and Dirichlet) . In many
ways . Riemann was the intellectual successor of Gauss (Rieman n
did his PhD at Gottingen under Gauss) . In geometry, he started
the development of those tools which Einstein would eventually us e
to describe the universe and which in the 20th century would be turned into the the -
ory of manifolds. He also made fundamental contributions to analysis, in which hi s
name is preserved in the Riemann integral, the Riemann sum, the Cauchy Riemann
equations and Riemann surfaces . Riemann only wrote one paper on number theory ,
but this paper had tremendous impact on the development of the Prime Num-
ber Theorem: it was in this paper that Riemann provided a foundation of moder n
analytic number theory. Riemann died of tuberculosis at the early age of 40 .
Jacques Hadamard (1865–1963) was born in Versailles . France. He
was good at all subjects at, school except mathematics ; he wrote
in 1936 that "in arithmetic. until the seventh grade, I was last o r
nearly last" . A good mathematics teacher happened to turn hi m
towards mathematics and changed his life. Hadamard made im-
portant contributions to complex analysis. functional analysis and
partial differential equations of mathematical physics . His proof
of the Prime Number Theorem was based on his work in comple x
analysis. Hadamard was also a famous teacher ; he taught at a Paris secondary
school and wrote numerous articles on elementary mathematics for schools .
Charles-Jean de la Vallee-Poussin (1866 -1962) was born in Lou -
in, Belgium . He proved the Prime Number Theorem indepen-
dently of Hadamard in 1896 . He also extended this work and es-
tablished results about the distribution of arithmetic progression s
of prime numbers, and refined the Prime Number Theorem to
include error estimates. Notice that both Hadamard and De l a
Vallee-Poussin lived well into their 9 0's (Hadamard 98, and De la.
'allbe Poussin 96); it is a common belief among mathematician s
(1 .170)
(1 .173)

92
1 . Elementary Number Theor y
theorems about prime numbers have been discovered : many are significant ,
some are beautiful, but only this serious theorem is called the Prime Numbe r
Theorem (PNT) .
The mathematicians of the 19th century were somewhat disturbed by th e
use of complex analysis to prove the PNT ; for example . in their proofs of
the PNT, both Hadarnard and De la Vallee-Poussin used very complicate d
analytical methods. Mathematicians attempted for a long time to give a n
elementary proof of the PNT. This was first achieved by Atle Selberg' i n
1949, whose proof used only elementary estimates of arithmetic function s
such as
(1np)+
lnpinq=2.rin :r.+O(x),,
(1 .174)
p<r
pq< a
where p and q are primes (the above estimate was given by Selberg in 1949) .
Soon after, using also a variant of Selberg's estimat e
u(x)
1
rt(x/n) .1(n)
1
 
= 2 + 0  
(1 .175)
x/n
n
In x
where A(n) is the von Mangoldt function defined by
J
In p
if n = ph is prime power
0
otherwise ,
and 7(x) is the summatory function of A(n)
A(n)
nn
1 .5 Distribution of Prime Numbers
93
Paul Eras" gave, with a different elementary method, his proof of the prim e
number theorem. (It was planned to write a joint paper between Selberg and
Erdos, but for some reason this did not happen .) These elementary proofs
of the PNT were considered so important that Selberg got a Fields medal in
19.50 and Erdos received the American Mathematical Society's Cole Prize i n
1951 and the Wolf prize in 1984 .
The PNT is not only an important theoretical result about prime num-
bers . but also a very applicable result in mathematics and computing science .
For example, we can use the PNT to :
(1) Estimate the probability that a randomly chosen integer n will turn ou t
to be prime as 1/1n n. Thus we would need to examine approximatel y
In n integers chosen randomly near n in order to find a prime that is
of the same size as n ; for example . to find a 1000-digit prime migh t
require testing approximately In 101000
2303 randomly chosen 1000-
digit numbers for primality. Of course. this figure can be cut in half i f
only the odd numbers are chosen .
(2) Estimate the number of computation steps required for primality testing
by trial divisions. The maximum number of divisions in the trial divisio n
primality of n is n (lei) : for large rt we have
rc
(3ii) ^ In t
test for p
rt
.
A(n) =
(1 .176)
(1.177)
2
n
A computer which takes (In n)/10 6 seconds to perform one such
in n
division would take approximately 
n
Inn = 2
Ti, seconds to check
Inn 100
106
that n was prime, provided that all the primes up to n were known .
Using this direct method it would take more than 63 years to verify that
a. 30-digit number was prime . Later on, we shall introduce more efficient
methods for primality testing .
that anyone who produces a proof of the Prime Number Theorem is guaranteed
longevity!
Atle Selberg (1917- ), is a Norwegian mathematician and th e
1950 Fields Medal recipient . Selberg's interest in mathematics be-
gan when he was a schoolboy . By reading about Bamanujan an d
Ramanujan 's collected papers. Selberg was not only greatly im-
pressed by the mathematics he read but also intrigued by Ramanu-
jan's personality. Inspired by Ramanujan 's work, Selberg began
to make his own mathematical explorations and made significan t
contributions to the theory of numbers, particularly the Rieman n
zeta function . Selberg is perhaps best known for his elementary proof of the prim e
number theorem . He has been a permanent member of the Institute for Advance d
Study at Princeton since 1949 and is currently Professor Emeritus in the Institute .
The legendary Paul Erdos was born in Budapest, Hungary, on
26 March 1913 and died on 20 September 1996 while attending
a. minisemester at the Banach Mathematical Centre in Warsaw .
Poland. A mathematician with no home . no wife, no job. and
no permanent address, Eras was the most versatile and prolifi c
mathematician of our time, and indeed probably of all times . He
traveled a lot around the world to meet mathematicians, to delive r
lectures, and to discuss mathematical problems . He wrote about
1500 papers. about five times as many as other prolific mathematicians, co-authore d
with over 250 people. These people are said to have Eras number 1 . People wh o
do not have Erdos number
1 . but who have written a paper with someone who
does . are said to have Erdos number 2 . and so on inductively . Erdos's papers cover
a broad range of topics, but the majority are in number theory . combinatorics
and probability theory. (Photo by courtesy of the Mathematical Institute of th e
Hungarian Academy of Sciences .)

94
1 . Elementary Number Theor y
1 .5 .3 Approximations of 7r(x) by Li(x)
Although the expression .r/ in x is a fairly simple approximation to x(x), i t
is not terribly close (i.e . . it is good, but not very good) . and mathematician s
have been interested in improving it . Of course, one does this at the price of
complicating the approximation . For example . one can use the following much
better approximation Li(x) to r(x) . Li(x) is called the logarithmic integral
of x: the formal definition of the logarithmic integral Li(x) is as follows .
Definition 1 .5.2. Let x be a positive real number greater than 1 . Then
Li(x) =
(1.178)
0
1n
dt
t '
the integral is usually interpreted a s
dt
'—''
dt
o Int
lim \,J
+ .~+,iJ In t
As illustrated in Table 1 .11 (compared also with Table 1 .10), the logarith-
mic integral UP.) is indeed a much better approximation to
:7(x). although
for large values of x the two approximations behave asymptotically alike. Rie-
mann and Gauss believed that Li(x) > r(x) for every x > 3 . It is of cours e
true in the present range of Table 1.11. However. Littlewood showed in 191 4
that the difference Li(x) — r(x) changes sign infinitely often, whilst Te Riel e
showed in 1986 that between 6 .62 . 10''70 and 6.69 there are more tha n
10100 successive integers a for which Li(x) < x(x) .
The study of the approximation of x(ar) by Li(x) leads naturally to an
equivalent form of the Prime Number Theorem, sinc e
Li(.c)
(Li(x))'
1/lna:
fin]. 
= Inn
= lim
_,
= 1 .
(by- x/ln .x.
1->x (.r/llla')'
r=x 1/1nZ - 1/In
.r
Theorem 1 .5.4. x(3;) is asymptotic to Li(x) . That is,
r(r)
litre
= 1 .
-x Li(x)
Remark 1 .5 .1 . At the age of 15. in 1792 . Gauss conjectured tha t
x(x)
Li(x) .
but Gauss used the following definition for Li(x)
dt
Li( r) _
In t
which differs by a constant Li(2) from (1 .178) .
1.5 Distribution of Prime Numbers
95
Table 1.11 . Approximations to rr(x) by Li(c )
x
x(x)
Li(x)
(x)
Li(x )
103
168
178
0 .943820224719 - -
10'
1229
1246
0 .986356340288 . .
110'
9592
9630
0.99605399792 3
109
78498
78628
0 .99834664496 1
10 '
664.579
664918
0 .999490162696 .
108
5761455
5762209
0.999869147405
.
109
50847534
50849235
0 .999966548169 . .
1010
455052511
455055615
0 .999993178855 . . .
10"
4118054813
4118066401
0.999997186058 . . .
1012
37607912018
37607950281
0 .999998982582 . . .
10"
346065536839
34606 55645810
0.999999685114 . . -
10''
3204941750802
3204942065692
0.999999901748 .
10''
29844570422669
29844571475288
0.999999964729
.
101c
279238341033925
279238344248557
0.999999988487 . . .
101r
2625557157654233
2625557165610822
0.999999996969 . .
10'8
247399.54287740860
24739954309690415
0.999999999112 . . .
1019
234057667276344607
234057667376222382
0.999999999573 . .
1.5.4 The Riemann t-Function c(s )
In 1859, Bernhard Riemann astounded the mathematical world by writin g
an eight-page memoir on x(x) entitled Uber die Anzahl der Primzahlen linter
einer ,gegebeaen Grosse (On the Number of Primes Less Than a Given Mag-
nitude) which is now regarded as one of the greatest classics of mathematics .
In this remarkable paper. which was incidentally the only paper he ever wrote
on Number Theory. Riemann related the study of prime numbers to the prop-
erties of various functions of a complex number. In particular. he studied the
(-function (now widely known as the Riemann (-function) as a function of
a complex variable. and made various conjectures about its behaviour . We
shall first give the definition of the Riemann (-function as follows .
Definition 1 .5.3. Let s be a complex variable (we write s = o- + it with a
and t real; here a = Re(s) is the real part of s . whereas t = hn(s) is the
imaginary part of s) . Then the Riemann (-function, ((s) . is defined to be the
sum of the following series
n s
(1 .183)
In particular ,
(1.179)
(1 .180 )
(1 .182)

96
1 . Elementary Number Theory
1 .5 Distribution of Prime Numbers
97
((2)
=
n
6
'
(1 .184)
a=i
(( 4 )
=
90
(1 .185 )
and more generally.
2,t-1 BLl lF
(2n) !
where B„ is the Bernoulli number, named after Jacob Bernoulli (1654 1705) .
Bernoulli numbers are defined as follows :
1
1
1
1
Bo = 1, Br = 2 , B.] = 6 .
Ba = O . Bt = — 30 B
6 = O, B6 =
2 , . . .
B . being recursively- defined by the relation
( k±i ) Bk +( k±1 )Bk_1 + . .
It is clear that the series ((s) converges absolutely for a > 1, and indee d
that it converges uniformly for a > 1 + h for any 6 > O . Euler actually
studied the zeta function earlier, but only considered it for real values of s .
The famous Euler's product formula expresses the unique factorization of
integers as product of primes :
Theorem 1 .5 .5 (Euler's product) . If a > 1, then
((.$)=H(1_~
..
(1 .188)
where the product runs over all prime numbers .
In particular, this implies that ((s) HQTC  . Euler's product formul a
is very important in the theory of prime numbers; it is, in fact, this formula
that allows one to use analytic methods in the study of prime numbers . (Note
that Euler's product formula may also be regarded as an analytic version of '
the Fundamental Theorem of Arithmetic.) Biemann's great insight was to
study the (-function for complex values of s and to use the powerful methods
of' complex analysis. This enabled him to discover a remarkable connection
between the zeros of the (-function and prime numbers : he showed that ((s )
is analytic for a > 1 and can be continued across the line a = 1 (see Figure
1 .7). More precisely, the difference
C(5)
1
1
can be continued analytically to the half-plane a > 0 and in fact to all of C .
Re(s) = I
Re(s)= 1/2
Figure 1.7. The complex plane of the Riemann (-function
The most interesting thing about the Riemann (-function is the distribu-
tion of the zeros of the (-function, since it is intimately connected with th e
distribution of the prime numbers . Now let us investigate the distribution of
the zeros of the Riemann (-function (see Figure 1 .7) . It is known that
(1) The ((-function has no zeros in the half-plane Be(s) > 1 . (Since by Euler's
product, if Re(s) > 1 . then ((s) / 0.)
(2) The (-function has no zeros on the line Re(s) = 1 . (Since for any real
value oft, ((1+it) / 0 . )
Therefore, there are only three possible types of zeros of ((s) :
// /
/
((2n) =
(1.186)
± 1
k
Bl + Bo = O.
(1.187)
(
0

98
1 . Flententaiv Number Theory
1.5 Distribution of Pri
99
(1) Zeros lying outside the critical strip 0 < Re(s) < 1 : These are the zero s
at the points
-2. -4 . -6 . -8 . -10 .
These zeros are the only zeros of (( .$) outside the critical strip and are
called trivial zeros of ((s). They are also called real zeros of ((s) . since
the zeros -2 . -4, • - - are certainly real, and no other zeros are real .
(2) Zeros lying in the critical strip 0 < Re(s) < 1 : These zeros are called
nontrivial zeros of c(s) ; there are infinitely many such nontrivial zeros .
Note that the nontrivial zeros are not real. and hence they are sometime s
called complex zeros . Note also that these zeros are symmetric about the
real axis (so that if so is a zero, so is tilt, where the bar denotes th e
complex conjugate) and the critical line Re(s) = 1 so that if + it were
a zero . then 11 + it would also be a zero) .
(3) Zeros lying on the critical line Re(s) = 1 : These are the zeros at
+it .
These zeros are. of course. nontrivial (complex) zeros (because they al l
lie in the critical strip) . There are infinitely many such nontrivial zeros
lying on the critical line .
Riemann made the somewhat startling conjecture about the distributio n
of the nontrivial zeros of ((s) in his famous memoir . namely that
Conjecture 1.5.1 (Riemann Hypothesis (RH)) . All the nontrivial
(complex) zeros p of ((s) lying in the critical strip 0 < Re(s) < 1 must lie o n
1
1
the critical line Re(s) =
that is, p = + it. where p denotes a. nontrivial
zero of ((s) .
Remark 1 .5.2. The Riemann Hypothesis may be true : if it is true, the n
it can be diagrammatically shown as in the left picture of Figure 1 .8. The
Riemann Hypothesis may also be false; if it is false, then it can be diagram-
matically shown as in the right picture of Figure 1 .8. At present . no one
knows whether or not the Riemann Hypothesis is true .
Remark 1 .5 .3 . The Riemann Hypothesis has never been proved or dis-
proved: in fact. finding a proof or a counter-example is generally regarded
as one of most difficult and important unsolved problems in all of mathemat-
ics. There is, however, a lot of numeric al evidence to support the conjecture :
as we move away from the real axis . the first thirty nontrivial zeros p„ (where
p„ denotes the nth nontrivial zero) of ((s) are given in Table 1 .12 (all fig-
ures here are given to six decimal digits) . In fact. as we move further and
further away from the real axis, the first 1500000001 nontrivial zeros of ((s)
in the critical strip have been calculated : all these zeros lie on the critical lin e
1
Re(s) = 2 and have imaginary part with 0 < t < 5-15439823 .215 . That is .
Re(s) = 1
0
1/2 1
Re(s)= 1/2
Refs)= 1/2
Riemann Hypothesis true
Riemann Hypothesis fals e
Figure 1 .8. The diagrammatical representation of the Riemann Hypothesi s
1
p„ = 2 + it
with n = 1 .2, . - . ,1500000001 and 0 < t„ < 545439823 .215 . In
spite of this. there are several distinguished number theorists who believe th e
Riemann Hypothesis to be false . and that the presence of the first 1500000001
nontrivial zeros of ((s) on the critical line Re(s) = 2 does not indicate the
behaviour of ((s) for every large t . The current status of knowledge of' thi s
conjecture is :
(1) The (-film- )n has infinitely- many zeros lying on the critical line
Re(s) =
-4
0

tuber Theory
1.5 Distribution of' Prime Numbers
10 1
100
1 . Elementary
Table 1 .12. The first thirty nontrivial zeros of c(s )
n
t„
n
t„
- n
t„
1
14 .134725
2
21 .022040
3
25.010857
4
30.424876
5
32 .935062
6
37.586178
7
40.918719
8
43 .327073
9
48.005151
10
49.773832
11
52 .970321
12
56.446248
13
59.347011
14
60 .831779
15
65.112544
16
67.079811
17
69 .546402
18
72.067158
19
75.704691
20
77.144840
21
79.337375
22
82.910381
23
84 .735479
24
87.425275
25
88.809111
26
92 .491899
27
94.651344
28
95.874634
29
98 .831194
30
101 .317851
(2) A positive proportion of the zeroes of ((s) in the critical stri p
0 < Re(s) < 1 he on the critical line Re(s) = (thanks to Selberg) .
(3) It is not known whether there are any nontrivial zeros which are not
simple: certainly, none has ever been found .
Remark 1 .5 .4. The Riemann Hypothesis (RH) is fundamental to the Prim e
Number Theorem (PNT) . For example. if this conjecture is true, then ther e
is a refinement of the Prime Number Theorem
dt
1T(tr) =  
+(~ (re-cs/Inr)
2
In t
to the effect that
-r(x) = ' (Ii + 0 (\/Yln x) .
(1.190)
2
In t
Remark 1 .5 .5. The knowledge of a large zero-free region for ((s) is impor-
tant in the proof of the PNT and better estimates of the various function s
connected with the distribution of prime numbers : the larger the region. the
better the estimates of differences [ -(x) - Li(.i)I and 1yr(:r) - .rl, appearing
in the PNT . If we assume RH . we then immediately have a good zero fre e
region and hence the proof of PNT becomes considerably easier (see pictur e
on the right, in Figure 1 .9) . De la Vallee-Poussin constructed in 1896 a zero -
free region in the critical strip (see the picture on the left in Figure 1 .9). This
zero free region is not as good as that given by the RH. but it turns out to
be good enough for the purpose of proving the PNT .
Refs) =1/2
Refs)= 1/2
Figure 1.9 . Zero-free regions for (s )
In a celebrated memoir published in 1837, when studying the arithmeti c
progression kn + h. Dirichlet 29 introduced new arithmetic functions k(n) .
29
Johann Peter Gustav Lejeune Dirichlet
(180.5 1859) was born
into a French family in the vicinity of Cologne, Germany. He
studied at the University of Paris . and held positions at the Uni -
versities of Breslau and Berlin and, in 1855, he was chosen t o
succeed Gauss at the University of Gottingen. Dirichlet is sai d
to be the first person to master Gauss 's Disquisitiones Arith-
meticae. He is said to have kept a copy of this book at his sid e
even when he traveled . His own book on number theory
1/or-
lesungen fiber Zahlentheorie, helped make Gauss's discoveries
(1 .189)
Reis)= I
Re(s) =
zero-fee
reg ion
zero-fre e
regio n
0
1 /2 '
/2

102
1. Elementary Number Theor y
now called Dirichlet characters modulo k . These are multiplicative function s
that have period k and vanish only on numbers not relatively prime to k .
Clearly, there are 4(k) Dirichlet characters modulo k . In terms of Dirichlet
characters, Dirichlet also introduced functions analogous to the Riemann ( -
function ((s) . These functions, now called Dirichlet L-functions, are defined
by infinite series of the form :
n= 1
where y(n) is a Dirichlet character modulo k and s is a real number greater
than 1 (or a complex number with real part greater than 1) . Dirichlet's work
on L-functions led naturally to the description of a more general class of
functions defined by infinite series of the form :
where f (n) is a given arithmetic function. This is called a Dirichlet series
with coefficients f (n), and the function F(s) is called a generating functio n
of f (n) . For example, the simplest possible Dirichlet series is the Riemann
(-function ((s), which generates the constant function f(n) = 1 for all n .
(1.194)
and the reciprocal of the (-function generates the J4obius function µ(n) ,
=
n'
(1 .19.5)
The study of L-functions is an active area of contemporary mathematical
research, but it is not our purpose to explain here the theory and applica-
tions of Dirichlet L-functions in detail: we shall only use the basic concept s
of Dirichlet L-functions to formulate the following Generalized Riemann Hy-
pothesis.
accessible to other mathematicians . Dirichlet made many important contributions
to several branches of mathematics . He proved that in any arithmetic progression
a . a +d, a+2d, - - , where gcd(a, d) = I, there are infinitely many primes . His famous
Pigeonhole Principle is used extensively in combinatorics and in number theory.
1 .5 Distribution of Prime Numbers
103
Conjecture 1 .5 .2 (Generalized Riemann Hypothesis (GRH)) .
All the nontrivial zeros of the Dirichlet L-functions in the critical stri p
0 < Re(s) < 1 must lie on the critical line Re(s)
= Clearly, the Generalized Riemann Hypothesis generalizes the (plain) Rie -
mann hypothesis to Dirichlet L-functions . There are again many conse-
quences of the generalized Riemann hypothesis . For example, if this con-
jecture is true. then the primality testing problem is in P . (P stands for
a class of problems solvable in polynomial time on a deterministic Turing
machine; see Section 2.1.3 of Chapter 2 for more information .)
Having introduced the Riemann (-function and Dirichlet L-functions . let
us introduce one more function named also after Riemann (but this time we
just call it the "plain" Riemann function) and its relationship to 7(x) .
Definition 1 .5.4. Let x be a. positive real number . Then the Riemann func-
tion, R(x), is defined as follow s
R(x) =
h(n) Li(x1/" )
n
Remark 1.5.6. The Riemann function R(x) is computable by the followin g
quickly converging power series
1
On x)"
=1 n((n + 1)
n!
In terms of the Riemann function R(x) . Riemann gave the following exact
formula for 7(x)
7(x) = R(x) > R(x°)
(1 .198)
°
where the sum is extended over all the zeros p of the Riemann (-function .
each counted with its own multiplicity (Ribenboim [200]) .
The Riemann function R(x) provides a very good approximation to 7(x) .
Table 1.13 shows what a remarkably good approximation R(x) is to 7(:r) .
Table 1.14 shows the differences between rr(x) and 
' 
. Li(x) and R(x) .
ln x
Theorem 1 .5 .6. 7(r) is asymptotic to R(x) . That is .
hm
T( c) = 1 .
,=x R(x)
L(s,
) =
(n.)
n '8
f (u )
ns
(1 .192)
((s) =
The square of the (-function generates the divisor function T(71),
((s)
~ T(11 )
n8
n=1
(1.196)
"= 1
(1 .193)
R(x) =
1 +
(1.197)
(1 .199)

104
1 . Elementary Number Theor y
Table 1.13. Approximations to r(x) by R(x)
(x)
R(x)
r( )/R(, )
108
5761455
5761552
0.99998316425 8
10"
50847534
50847455
1 .00000155366 6
10 t0
455052511
455050683
1.00000401713 4
10 11
4118054813
4118052495
1 .00000056288 7
1012
37607912018
37607910542
1 .00000003924 7
101i
346065536839
346065531066
1.00000001668 1
10"
3204941750802
3204941731602
1.000000005990
1018
29844570422669
29844570495887
0.99999999754 6
10 16
279238341033925
279238341360977
0.99999999882 8
10"
2625557157654233
262555715705.5978
1.00000000022 7
10 t8
24739954287740860
24739954284239494
1.00000000014 1
1019
234057667276344607
234057667300228940
0.999999999897
1 .5 Distribution of Prime Numbers
105
Let p„ be the nth prime. Then we have :
pt = 2,
p2 = 3,
p3 = 5 ,
P4 = 7 ,
p7 = 17 ,
ps = 11 ,
ps = 19 ,
ps = 13,
p9 = 23,
Pion = 541 .
Plot = 547,
P102 = 557 .
P103 = 563 .
P101 = 569.
Pros = 571 .
P106 = 577 .
P107 = 587,
pros = 593 .
Moo = 599 .
prl0 = 601,
pill = 607,
Now we wish to show that
Table 1.14 . Differences between r(x) and a:/ In x, Li(x) and R(x)
r(n)
lim 
= 1
„+x n/ In n
(1.200)
x
x/ In x — r(x)
Li(x) — r(x)
R(x) — r(x)
®~®
97
-2592592
®
-79
-1828
-2318
-1476
10
-11992858452
108971
-5773
10
-102838308636
314890
-1920 0
10
-891604962453
1052619
73218
32705 2
EMI
-598255
-350136 6
10
-5481624169369961
99877775
2388433 3
1.5.5 The nth Prime
We have seen several equivalent forms of the prime nu 4er theorem . for
example
7(n)
t'( .r)
lint 
= 1
lim
= 1 .
n—.x n/inn
„—47C
.z
In this subsection, we shall study one more equivalent form of the prime
number theorem. More specifically, we shall show that the following two form s
of the prime number theorem are also equivalent .
 r(n) = 1 
 p„ 
1
71/ Inn
ninn
is equivalent
0
p n
lim
= 1 .
x n1n n
By taking logarithms of both side sides of equation (1 .200) and then removing
a factor inn, we get
In r (n)
1n 111 n
lira Inn 
+ 
– 1) = O .
„-->x
Inn
In n
Since
1nln n
lim
= 0 ,
ra+x
In n
we have
In r(n)
lim 
= 1 .
"—
in n
Multiplying (1 .204) by (1.200) . we get
lim
„-+x
Now replace n by the nth prime p„,
lim nlnn = I .
n—>x
which implies (1 .201) . Equation (1.200) can also be deduced front (1 .201) :
we leave it as an exercise . So the two forms are equivalent. It is worthwhile
pointing out that each of the statements (involving the Mobius function) :
(1 .201)
(1 .202)
(1 .203)
(1 .204)
7r(n) In r(n) =1 .
n
(1 .205)
Then r(p„) = n . and (1.205) becomes
(1 .206)

106
1 . Elementary Number Theo
1 .5 Distribution of Prime Numbers
107
is also equivalent to the prime number theorem .
It is known in fact that p„ > n inn for all ra. The error p„ - n Inn. can be
very large, but if n is large, the error is much smaller than n Inn . In other
words, for large n . the nth prime is about the size of n Inn. Feigner showed
in 1990 a weaker estimate that
0.91n Inn < p„ < 1.7n In n .
(1.209)
Example 1 .5 .2 . Table 1 .1 .5 gives some comparisons of p„ with
n In It .
0.91n Inn, 1 .7n Inn. and P„ - n hr n . For example, let n = 664999 . Then
we have
10006721 - 8916001 .238
--,s
p„
n In n
10006721 > 8113561 .127 
-->
p,, > 0 .91n 1n
10006721 < 15157202 .10 
-~
p,> < 1 .7n In
These agree well with (1 .209) .
Table 1.15 . Some comparisons about p„
n
p„
n1nn
0.9nInn.
1.7n1nn
1
-
n.In n
10
29
23 .02585093
20.95352435
39.14394658
.25945399 8
100
541
460.5170186
419.0704869
782 .8789316
.174766574
1000
7919
6907.755279
6286.057304
11743 .18397
.146392667
10000
104729
92103 .40372
83814.09739
156575.7863
.137080670
664999
10006721
8916001 .238
8113561 .127
15157202.10
.122332841
1 .5.6 Distribution of Twin Primes
Compared with the distribution of prime numbers . little is known about th e
distribution of the twin primes ; for example . it was known 2000 years ago that
there are infinitely many prune numbers . but it is not known whether or not
there are infinitely many twin primes. In spite of this, remarkable progress
has been made on the distribution of twin primes. Let r2(a;) be the number of
primes p such that p < x and p+2 is also a. prime . Then we have ;;2 (10) = 2
and
7r2 (100) = 12 . A larger table of values of 212(.r) . together with some other
information (L 2 (x) is defined in (1 .215) in the same way as Li(x)), can be
found in Table 1 .16 . Note that in Brent's paper [34], some interesting table s
and graphs are given : they show . in particular, the difference between the
behaviour of r2 (x) (which has slow oscillations) and ir(x) (which has much
faster oscillations) .
Table 1 .16. Some results for twin primes up to 10 1.1
x
~2(r)
L 2( x )
~
r2 (x) - L 2(x)
L2(x)
10
2
5
0.4
-3
102
8
14
0.5714285
-6
103
35
46
0.7608695
-11
104
205
214
0.9579439
- 9
10
1224
1249
0.9799839
-25
109
8169
8248
0.9904219
-79
10'
58980
58754
1.0038465
226
10"
440312
440368
0.9998728
-56
109
3424506
3425308
0.9997658
-802
10 10
27412679
27411417
1.0000460
1262
1011
224376048
224368865
1.0000320
7183
10 12
1870585220
1870559867
1.0000135
25353
10 13
15834664872
15834598305
1.0000042
66567
1014
135780321665
135780264894
1.0000004
5677 1
There is also keen competition to find the largest pair of twin primes ;
we list in Table 1 .17 twenty-nine large pairs of twin primes . (Note that the
multifactorial notation n!!!! in the 27th pair of the twin primes denotes the
quadruple factorial function, i .e., n!!!! = n (n - 4) (n - 8) (n - 12)(n- 16) . ' ' .)
Clemant in 1949 gave a necessary and sufficient condition for twin primes .
although it has no practical value in the determination of twin primes .
Theorem 1 .5.7. Let n > 2 . The pair of integers (inn + 2) form a pair of
twin primes if and only if
4((n-1)!+1)+n.=0 (mod n(n+2)) .
(1.210)
V. Brun announced in 1919 and proved in 1920 that there exists an effec-
tively computable integer xo such that if x > x 0 then
100r
rrz(r) < In" x
inn -~p(k)= 0
x IL
(1.207)
lim
p(k) = 0
11
> x
k
ti-1
(1 .208)
and

108
1. Elementary Number Theo
1.5 Distribution of Prime Numbers
10 9
Brim proved that the sure of p
1 
1 for all primes p such that p + 2 is also a
prime converges . The sum is now called Brun's constant, B, and it has no w
in fact been calculated :
Table 1 .17 . Twenty-nine large twin primes
Twin Primes
Digits
Year
Discoverer(s)
318032361
2107001 ± 1
32220
2001
Underbakke et al .
1807318575 . 298305 + 1
29603
2001
Underbakke et al .
665551035 . 280025 ± 1
24099
2000
Underbakke et al .
781134345 . 266445 ± 1
20011
2001
Underbakke et al.
1693965 . 266443 ± 1
20008
2000
LaBarbera et al .
83475759 . 264955 ± 1
19562
2000
Underbakke et al .
291889803
260090 ± 1
18098
2001
Boivin & Gallot
4648619711505 - 260000 ± 1
18075
2000
Indlekofer et al .
2409110779845 . 260000 +1
18075
2000
Indlekofer et al .
2230907354445 . 248000 ± 1
14462
1999
Indlekofer et al .
871892617365 . 29&000 ± 1
14462
1999
Indlekofer et al .
361700055 . 23902° + 1
11755
1999
Lifchit z
835335 . 239014 ± 1
11751
1999
Ballinger & Gallot
242206083 . 238880 + 1
11713
1995
Indlekofer & Jarai
570918348 . 10°120 + 1
5129
1995
Dubner
697053813 216352 ± 1
4932
1994
Indlekofer & Jarai
6797727 2 15328 + 1
4622
1995
Forbes
1692923232 . 10402° ± 1
4030
1993
Dubner
4655478828 10 3429 ± 1
3439
1993
Dubner
1706595 - 211235 ± 1
3389
1989
Parady et al .
459 . 28529 ± 1
2571
1993
Dubner
1171452282 102490 ± 1
2500
1991
Dubner
571305 . 2 701 ± 1
2324
1989
Paradi et al .
75188117004
102298 ± 1
2309
1989
Dubner
663777 . 27650 ± 1
2309
1989
Paradi et al .
107570463 - 1022`59 + 1
2259
1985
Dubner
2846!!!! + 1
2151
1992
Dubner
43690485351513 101995 ± 1
2009
1985
Dubner
260497545 . 2662o ± 1
2003
1984
Atkin & Rickert
(1 + 
1
p
p+2 /
C 3+5)+(5+ )+
. . +
= 1.902160577783278 . . .
It also has been proved by Bombieri and Davenport [97) in 1966 tha t
r2 (x) < 8 H
— 
I x
Cl
+
In In x
(1.213)
px
(P —1 )2 1 Ina
In x
The constant 8 has been improved to 6.26 + e, however it was conjectured b y
Hardy and Littlewood that the constant should be 2 rather than 8 .
The famous Twin Prime Conjecture states that
Conjecture 1 .5 .3 . Let 7r2(x) be the number of primes p such that p < x
and p+ 2 is also a prime . Then
(1) (A weak form) There are infinitely many twin primes . That is .
hm 772(x) = cxc .
n;-*x
(2) (A strong form) Let
L2(x)
=
2
p(p — 2) r
dt
pb3 (P — 1)2 .2
ln2 t
1 .320323632
2x
.320323632 ~x
dt
(1 .215)
J2
In t
then
~2(x)
r--am L>(x)
1 .
Using very complicated arguments based on sieve methods . the Chinese
mathematician J. R. Chen showed that there are infinitely many pairs of
integers (p. p + 2) . with p prime and p+2 a product of at most two primes .
If we write d„ = p,,+1 — p„ so that di = 1 and all other d„ are even .
Then an equivalent form of the Twin Prime Conjecture is that d„ = 2 occurs
infinitely often . How large can d, 1 be? Rankin has shown that
(In In In n) 2
(1.217)
for infinitely many n . Erdos offered 85000 for a proof or a disproof that th e
constant c can be taken arbitrarily large .
B =
( 1
p
(1.212)
(1 .214)
(1.216)
c in n in in n in In in in n
r1„ >

110
1. Elementary Number Theor y
1 .5 .7 The Arithmetic Progression of Prime s
In this subsection we shall move on to the study of the arithmetic progressio n
of primes .
An arithmetic progression of primes is defined to be the sequence of primes
p, p+d, p+2d, . , p+(n–1)d,
(1.218)
where pis the first term. d the common difference, and p + (n – 1)d the last
term of the progression, respectively. For example ,
5, 11, 17, 23, 2 9
is an arithmetic progression of primes with p = 5, d = 6 and n = 5 . Table
1.18 contains fifteen long arithmetic progressions of primes, discovered by
James Fry, Andrew Moran, Paul Pritchard, S. C . Root, S. Weintraub and
Jeff Young; see Table 1 of Guy [94] and Table 32 of Ribenboim [200] fo r
more information (note that there are some printing errors in Table 32 o f
Ribenboim [200], which have been corrected here in Table 1 .18) .
Table 1.18. Fifteen long arithmetic progressions of prime s
n
p
d
p+ (n — 1)d
Year
22
11410337850553
4609098694200
108201410428753
PMT, 199 3
21
5749146449311
26004868890
6269243827111
P. 1992
21
142072321123
1419763024680
28537332814723
MP, 1990
20
24845147147111
19855265430
25222397190281
MP, 1990
20
1845449006227
1140004565700
23505535754527
MP. 1990
20
214861583621
18846497670
572945039351
YF, 1987
20
1140997291211
7643355720
1286221049891
F . 1987
20
803467381001
2007835830
841616261771
F, 1987
19
244290205469
13608665070
489246176729
F,1987
19
8297644387
4180566390
83547839407
P. 1984
18
107928278317
9922782870
276615587107
P. 1982
18
4808316343
717777060
17010526363
P. 1983
17
3430751869
87297210
4827507229
W. 1977
16
2236133941
223092870
5582526991
R. 1969
16
53297929
9699690
198793279
R.1969
It. is conjectured that n can be as large as you like (but it has not bee n
proven yet) :
Conjecture 1.5.4. There are arbitrarily long arithmetic progressions o f
primes .
1.6 Theory of Congruences
11 1
Erdos conjectured that if fa i l is any infinite sequence of integers for which
1
E
is divergent, then the sequence contains arbitrarily long arithmeti c
a ,
progressions; he offered $3000 for a proof or disproof of this conjecture (befor e
his death, Erdos signed some blank cheques and left them in the care o f
Ronald L . Graham to present to future problem solvers) . A related but even
more difficult problem is the following :
Conjecture 1 .5 .5 . There are arbitrarily long arithmetic progressions o f
consecutive primes .
1 .6 Theory of Congruences
As with everything else, so with a mathematical theory : beauty can be per-
ceived, but not explained.
ARTHUR CAYLEY (1821—1895)
1 .6.1 Basic Concepts and Properties of Congruences
The notion of congruences was first introduced by Gauss, who gave their
definition in his celebrated Disquisitiones Arithmeticae in 1801, though th e
ancient Greeks and Chinese had already had the idea .
Definition 1 .6 .1 . Let a be an integer and n a positive integer greater than
1. We define "a mod n" to be the remainder r when a is divided by n, that
is
r = a modn=a–[a/n]n .
(1 .219)
We may also say that "r is equal to a reduced modulo n" .
Remark 1 .6 .1 . It follows from the above definition that a mod n is the in-
teger r such that a = [a/n[n + r and 0 < r < n, which was known to the
ancient Greeks and Chinese some 2000 years ago .
Example 1 .6 .1 . The following are some examples of a mod n :
35 mod 12=11 .
-129 mod 7 = 4.
3210 mod 101 = 79 .
1412131
mod 12349 = 1275 .
Given the well-defined notion of the remainder of one integer when divide d
by another, it is convenient to provide a special notion to indicate equalit y
of remainders .

112
1 . Elementary Number Theory
1 .6 Theory of Congruences
11 3
Definition 1.6.2. Let a and b be integers and n a positive integer . We say
that "a. is congruent to b modulo n" . denoted by
a b (mod n)
(1.220)
if n is a divisor of a — b, or equivalently, if n
(a. — b) . Similarly, we write
a A b (mod n)
(1 .221)
if a is not congruent (or incongruent) to b modulo n . or equivalently, if n {
(a — b) . Clearly ; for a - b (mod n) (resp. a A b (mod n)), we can writ e
a = kn — b (resp . a  kn — b) for some integer k . The integer n is called the
modulus .
Clearly .
a = b (mod n)
n
1 (a — b)
a=kii+b,
kE/Z
and
(L() (inodn)
'=
n,{(a—b )
a  kn+b,
kE7G
So, the above definition of congruences, introduced by Gauss in his Dis-
quisitiones Arithmeticae, does not offer any new idea than the divisibilit y
relation, since "a - b (mod n)" and "n
I (a — b)" (resp . "a A b (mod n)"
and "n { (a — b)") have the same meaning, although each of them has it s
own advantages. However, Gauss did present a new way (i.e., congruences )
of looking at the old things (i.e., divisibility) ; this is exactly what we ar e
interested in . It is interesting to note that the ancient Chinese mathemati-
cian Ch'in Chiu-Shao 30 already had the idea and theory of congruences i n
his famous book Mathematical Treatise in Nine Chapters appeared in 1247 .
Definition 1.6.3 . If a = b (mod n) . then b is called a residue of a modulo
it . If 0 < b < m — 1, b is called the least nonnegative residue of a modulo n .
Remark 1 .6 .2 . It. is common, particularly in computer programs . to denote
the least nonnegative residue of a modulo n by a mod n . Thus, a _ b (mod
n) if and only if a mod n. = b mod n. and. of course, a A b (mod n) if and
only if a mode bmodn .
so Chin Chiu-Shao (12021261) was born in the southwest Chinese province of
Sichuan. but studied astronomy in Hangzhou, the capital of the Song dynasty .
now the capital of the Chinese southeast province Zhejiang . Chin was a genius in
mathematics and was also accomplished in poetry, fencing . archery. riding, mu-
sic and architecture. He wrote Mathematical Treatise
in Vine Chapters which
appeared in 1247 . It contains simultaneous integer congruences, the Chinese Re -
mainder Theorem, and considers algebraic equations, areas of geometrical figure s
and linear simultaneous equations. This work on congruences was rediscovered
by Gauss, Lebesgue and Stieltjes .
Example 1 .6.2. The following are some examples of congruences or incon-
gruences .
35 = 11 (mod 12)
since
12
1 (35 — 11)
12 (mod 11)
since
11 { (35 — 12)
2 (mod 11)
since
11
(35 — 2)
The congruence relation has many properties in common with the equalit y
relation. For example. we know from high-school mathematics that equalit y
is
(1) reflexive: a = a, Va E 7G :
(2) symmetric: if a = b, then b = a. Ha, b E 7G;
(3) transitive: if a = b and b = c, then a = c, Va . b, c E Z .
We shall see that congruence modulo n has the same properties :
Theorem 1 .6 .1 . Let n be a positive integer. Then the congruence modulo
n is
(1) reflexive: a - a (mod n), b'a E 7G ;
(2) symmetric: if a b (mod n), then b - a (mod n), Va, b E 7G
(3) transitive: if a - b (mod Ti) and b = c (mod n), then a - c (mod n) ,
da,b,cEZ .
Proof.
(1) For any integer a, we have a = 0 . n + a, hence a = a (mod n) .
(2) For any integers a and b, if a - b (mod n), then a = kn + b for some
integer k . Hence b = a — kn = (—k)n + a, which implies b = a (mod n).
since —k is an integer .
(3) If a - b (mod n) and b = c (mod Ti), then a = kin +b and b = k2n + c.
Thus, we can get
a =ki n+kzn+c= (k t +kz)n+c= k'n+ c
which implies a - c (mod n), since k' is an integer .
q
Theorem 1 .6 .1 shows that the congruence modulo n is an equivalence
relation on the set of integers Z . But note that the divisibility relation a
b
is reflexive. and transitive but not symmetric ; in fact if a
b and b a then
a = b. so it is not an equivalence relation . The congruence relation modulo n
partitions Z into n equivalence classes . In number theory, we call these classe s
congruence classes. or residue classes . More formally. we have:
Definition 1.6.4. If :r = a (mod n). then a. is called a residue of x modulo
n . The residue class of a modulo n . denoted by [a]„ (or just [a] if no confusion
will be caused), is the set of all those integers that are congruent to a modul o
R . That is,

1 . Elementary Number Theory
1.6 Theory of Congruences
115
114
[a],, _
{x : x E Z and .r - a (mod n) }
{a + kn : k E} .
Note that writing a E [b]„ is the same as writing a = b (mod n .) .
Example 1 .6.3 . Let, n = 5. Then there are five residue classes, modulo 5 .
namely the sets :
[0] 5 ={•
15 .–10.–5.0,5,10,15.20,- - . }
[1] 5 = { . . . , -14. – 9. -4.1,6.11.16 . 21, . . . } ,
[2] 5 = { . . . , -13, – 8, -3.2, 7,12,17, 22, •
[3] 5 = {. • • . -12, – 7, -2, 3, 8.13,18, 23, - - 1 ,
[4] 5 = { . . . ,–11, -6,–1,4.9,14,19,24, . . .} .
The first set contains all those integers congruent to 0 modulo 5, the secon d
set contains all those congruent to 1 modulo 5, • • , and the fifth (i .e . . the
last) set contains all those congruent to 4 modulo 5 . So, for example. the
residue class [2] 5 can be represented by any one of the elements in the se t
{
-13, -8,–3,2,7,12,17,22,••} .
Clearly, there are infinitely many elements in the set [2]5 .
Example 1 .6 .4 . In residue classes modulo 2, [0 ]2 is the set of all even inte-
gers, and [1] 2 is the set of all odd integers :
[0] 2 ={ . . . ,–6,–4,–2,0,2,4,6,8, . .-} ,
[1] 2 ={• . . ,–5,—3 .—1 .1 .3,5,7,9, . .} .
Example 1.6.5. In congruence modulo 5. we have
[9] 5
=
{9+5k : kEZ}={9.9+5,9+10,9±15 .
= {
. .–11,–6.–1 .4.9,14,19,24 .
} .
We also have
[4] 5
=
{4+5k : kEZ}={4,4+5,4+10.4±15.
}
_
{ . . . . -11 . -6. -1 .4.9. 14 . 19 .24 .
. . } .
So. clearly, [4] 5 = [9] 5 .
Definition 1 .6 .5 . If x E a (m)d n) and 0 < a <
then a is called the
least (nonnegative) residue of .r modulo n .
Example 1 .6.6. Let n = 7. There are seven residue classes, modulo 7 . In
each of these seven residue classes, there is exactly one least residue of x mod -
ulo 7. So, the complete set of all least residues x modulo 7 is {0, 1, 2, 3, 4, 5, 6} .
Definition 1 .6.6. The set of all residue classes modulo n . often denoted be
l /nZ or Z,,, is
Z/nZ {[a],,
: 0 < a < n– 1} .
(1 .223)
Remark 1 .6.3. One often sees the definitio n
Z/nZ = {0,1 .2. .
. . n – 1} .
(1.224)
which should be read as equivalent to (1.223) with the understanding that
0 represents [0],,, 1 represents [1],, . 2 represents [2]„, and so on : each class
is represented by its least nonnegative residue . but the underlying residu e
classes must be kept in mind . For example, a reference to –a as a member of
Z/nZZ is a reference to [n – a],,, provided n > a, since –a - n –a (mod n) .
The following theorem gives some elementary properties of residue classes :
Theorem 1 .6.2. Let n. be a positive integer. Then we have :
(1) [a], = [b]„ if and only if a = b (mod n).
(2) Two residue classes modulo n are either disjoint or identical .
(3) There are exactly
n distinct residue classes modulo n, namely.
[0]„, [l]„, [2],,,, [3]„,
, [n – 1],,. and they contain all of the integers .
Proof.
(1) If a - b (mod n), it follows from the transitive property of congruence
that an integer is congruent to a modulo n if and only if it is congruent t o
b modulo n. Thus, [a]„ = [b],, . To prove the converse, suppose [a]„ = [b],, .
Because a E [a],, and a E [b],,, Thus, a E b (mod n) .
(2) Suppose that [a] .„ and [b]„ have a common element c. Then c E a
(mod n) and c - b (mod n) . From the symmetric and transitive prop-
erties of congruence, it follows that a - b (mod n) . From part (1) o f
this theorem, it follows that [a],, and [b],, . Thus, either [a]„, and [b],, are
disjoint or identical .
(3) If a is an integer, we can divide a by n to get
a=kq+r,
0<r<k .
Thus. a - r (mod n) and so [a]„ = [r],, . This implies that a is one
of the residue classes [0],, .[1]„ .[2],,, . . . ,[n – 1],, . Because the integer s
0.1.2, . .
.n – 1 are incongruent modulo n, it follows that there are ex-
actly n residue classes modulo n .
D
Definition 1.6.7. Let n be a positive integer . A set of integers a t , a2,
, a,.
is called a complete system of residues modulo n. if the set contains exactly
one element from each residue class modulo n .
(1 .222)

116
L Elementary Number Theory
1 .6 Theory of Congruences
11 7
Example 1.6.7. Let n = 4. Then {—12 .9 . -6, -1} is a complete system of
residues modulo 4. since -12 E [0], 9 E [1] . -6 E [2] and -1 E [3] . Of course.
it can be easily verified that {12. — 7.18, -9} is another complete system o f
residues modulo 4. It is clear that the simplest complete system of residue s
modulo 4 is {0 .1.2, 3}, the set of all nonnegative least residues modulo 4 .
Example 1 .6.8 . Let n = 7. Then {x, r + 3, x + 32 . x + 3 3 .
a + 34. x +
35 , x + 36} is a complete system of residues modulo 7 . for any x C Z . To see
this let us first evaluate the powers of 3 modulo 7 :
3
3' E 2 (mod 7)
33 - 6 (mod 7)
3 4 - 4 (mod 7)
35 - 5 (mod 7)
36 - 1 (mod 7)
hence, the result follows from x = O . Now the general result follows immedi -
ately, since Or + 3') — (x + 31 ) = 3' — 31 .
Theorem 1 .6 .3 . Let n be a positive integer and S a set of integers . S is a
complete system of residues modulo n if and only if
(1) S contains n elements, and
(2) no two elements of S are congruent, modulo n .
Proof. If S is a complete system of residues, then the two conditions ar e
satisfied. To prove the converse, we note that if no two elements of S are
congruent, the elements of S are in different residue classes modulo n . Since
S has n elements, all the residue classes must be represented among th e
elements of S . Thus, S is a complete system of residues modulo n
q
We now introduce one more type of' systems of residues, the reduced sys-
tems of residues modulo n .
Definition 1 .6 .8 . Let [a]„ be a residue class modulo n . We say that [a]„ is
relatively prime to n if each element in [a],, is relatively prime to n .
Example 1 .6 .9 . Let n = 10 . Then the ten residue classes, modulo 10, are
as follows :
[0] 10 = { --
30,-20 .-10.0.10 .20,30 . .' }
[1] 10 = {--
,—29,—19 . -9.1 .11 .21 .31,-- }
[2]10 = { . . -
. —28, —18 . -8,2 .12,22,32 . . -}
[3110 = {'
27.—17, -7.3 .13.23 .33 .-'' }
[4] 10 = {-' . .—26,—16 . -6.4 .14.24.34.- - . }
[5]1o = { . .
-25.—15 . -5 .5 .15.25 .35, . . . }
[6] j 0 = { . . -
. -24. -14 .
— 4 .6.16, 26.36 . . . - }
[7]10 = { . '-
-23 .—13 . -3 .7.17,27.37,--- }
[8], 0 = {-
.—22,—12, -2 .8.18,28.38,
. . }
[9] 10 ={''',—21,—11,
-1,9,19,29,39,---} .
Clearly . [l]10, [3]10, [7]10. and [9]10 are residue classes that are relatively prim e
to 10 .
Proposition 1 .6.1 . If a residue class modulo n has one element which is
relatively prime to n, then every element in that residue class is relativel y
prime to n .
Proposition 1 .6.2. If n is prime. then every residue class modulo n (excep t
[0]„) is relatively prime to n .
Definition 1 .6 .9 . Let n be a positive integer, then 0(n) is the number of
residue classes modulo n, which is relatively prime to n . A set of integer s
{ai , 09, ' ' '
. aol„) } is called a reduced system of residues, if the set contain s
exactly one element from each residue class modulo n which is relatively
prime to n .
Example 1 .6 .10. In Example 1 .6 .9, we know that. [1]10, [3]1o, [7]10 and [911 0
are residue classes that. are relatively prime to 10, so by choosing -29 from
[1] 10,
- 17 from [3] 10 .. 17 from [7] 10 and 39 from [9] 10, we get a. reduced
system of' residues modulo 10: {—29 . -17.17.39} . Similarly, {31, 3, -23 . -1 1
is another reduced system of residues modulo 10 .
One method to obtain a . reduced system of residues is to start with a
complete system of residues and delete those elements that are not relativel y
prime to the modulus m . Thus, the simplest reduced system of residues ( mod
In) is just the collections of all integers in the set {0,1, 2, -
. m -1} that are
relatively prime to rn .
Theorem 1 .6.4. Let rn be a positive integer . and S a set of integers . Then
S is a reduced system of residues (modn) if and only if
(1) S contains exactly 0(n) elements .
(2) no two elements of S are congruent (modn) ;
(3) each element of S is relatively prime to n .
Proof. It is obvious that a reduced system of residues satisfies the three
conditions. To prove the converse, we suppose that S is a set of integer s
having the three properties. Because no two elements of S are congruent . .
the elements are in different residues modulo n . Since the elements of S are
relatively prune n. there are in residue classes that. are relatively prime n .
Thus. the d(n) elements of S are distributed among the o(n) residue classes
that are relatively prime n, one in each residue class . Therefore. S is a reduced
system of residues modulo m. .
q
Corollary 1 .6 .1 . Let {a1-ap .
,a, be a reduced system of residues
modulo m, and suppose that gcd(k, m) = 1 . Then {kar . kaz, . - - , ka 0 (,,o}
is
also a reduced system of residues modulo rn .
Proof. Left as exercise .

118
1. Elementary Number Theory
1.6 Theory of Congruences
11 9
1 .6.2 Modular Arithmetic
The finite set Z/n7Z is closely related to the infinite set I . So. it is natural
to ask if it is possible to define addition and multiplication in Z/n7G and do
some reasonable kind of arithmetic there . Surprisingly, addition, subtraction
and multiplication in Z/nl will be much the same as that in Z . Let us first
investigate some elementary arithmetic properties of congruences .
Theorem 1.6.5. For all a, b, c. d E Z and n . E Z> 1, if a = b (mod n) and
c = d (mod n). then
(1)a±b=c+d (mod n) .
(2) a . b E e- d (mod a).
(3) a"" = b'
(mod n) . dm E N .
Proof.
(1) Write a = kit + b and c = In + d for some k, l E Z . Then a + c =
(k+I)n,+b+d . Therefore, a+c= b+d+tn, t = k+l E Z . Consequently,
a + c
b + d (mod n), which is what we wished to show . The case of
subtraction is left as an exercise .
(2) Similarly,
ac = bd + bl n + knd + kl n'
= bd + n(bl + k(d + In) )
= bd + n(bl + kc )
=bd+sn
where s=bl+kcEZ .Thus . a- bd (mod n) .
(3) We prove Part (3) by induction . We have a - b (mod n) (base step )
and a"" = b"` (mod n) (inductive hypothesis) . Then by Part (2) we have
am+1 = aam = bb„' = b'"+1 (mod n) .
q
Theorem 1 .6 .5 is equivalent to the following theorem, sinc e
a - b
(mod n)	
a mod n
f-->
a-->
a mod n = b mod n
[a],, ,
b mod n
[b],, .
Theorem 1 .6.6 . For all a, b. c, d E Z . if [a]„ _ [b],,, [c]„ _ [d],, . then
(1) [a ± b],, = [c t d],, .
(2) [a ' b],, = [c ' d],, .
(3) [a"'],, = [brn],, .
Vm E N.
The fact that the congruence relation modulo n is stable for addition
(subtraction) and multiplication means that we can define binary operations .
again called addition (subtraction) and multiplication on the set of 7G/n76 of
equivalence classes modulo n as follows (in case only one n is being discussed .
we can simply write [.x] for the class [x]„) :
[a]„ + [b]„
=
[a + b]„
[a]„
—
[b],,
=
[a — b] „
[a] " ,
- [b]„
=
[a ' b] „
(1 .225)
(1 .226)
(1.227)
Example 1 .6 .11 . Let n = 12. then
[7]12 +12
[8]12 = [7 + 8]12 = [15]12 = [3]12 .
[7]12 -12 [8]12 = [7 — 8112 = [— 1]19 = [11]12 ,
[7]12
*12 [8]12 = [7 . 8]12 = [56112 _ [8]12 .
In mane cases. we may still prefer to write the above operations as follows :
7+8=15=3 (mod 12) .
7—8=—1-11 (mod 12) .
7 . 8=568 (mod 12)
We summarise the properties of addition and multiplication modulo n in
the following two theorems .
Theorem 1 .6.7. The set Z/nZ of integers modulo n. has the following prop-
erties with respect to addition:
(1) Closure : [.r,] + [y] E Z/aZ . for all [x] . [y] E Z/nZ .
(2) Associative: ([r] + [y]) + [z] = [x] + ([y] + [z]) . for all [x], [y] . [z] E Z/nZ.
(3) Commutative : [x] + [y] _ [y] + [x] . for all [x] . [y] E Z/nZ.
(4) Identity. namely, [0] .
(5) Additive inverse: —[x] _ [—r] . for all [x] E Z/nZ.
Proof. These properties follow directly from the stability and the definitio n
of the operation in Z/nZ .
q
Theorem 1 .6.8. The set Z/nw of integers modulo n has the following prop-
erties with respect to multiplication:
(1) Closure : [x] . [y] E Z/nZ . for all [x] . [y] E Z/nZ .
(2) Associative: ([.r] . [y]) ' [=) = [x]
. ([u] [=]), for all [s], [y] . [z) E
/nZ.
(3) Commutative : [r]
. [y] = [y] ' [.r] . for all [:r.] . [y] E Z/nZ.
(4) Identity. namely. [1] .
(.5) Distributivity of multiplication over addition : [.r] . ([;y]) + [a]) _
([1' ]
[y]) + ([r]' [al) . for all [x] . [y] . [z] E
/n7; .
Proof. These properties follow directly from the stability of the operatio n
in Z/nZ and and the corresponding properties of Z .
q
The division a/b (we assume a/b is in lowest terms and b
0 (mod n) )
in Z/nZ . however . will be more of a problem: sometimes you can divide .
sometimes you cannot.. For example. let n = 12 again, then

120
1. Eleinei ary Number Theory-
1.6 Theory of Congruences
12 1
3/7 - 9 (prod 12)
(no problem) .
b
1
2
4
5
8
10
11
13
16
17
19
20
3/4 - 1 (mod 12)
(impossible) .
1/b (mod 21)
1
11
16
17
8
19
2
13
4
5
10
20
Why is division sometimes possible (e .g ., 3/7 - 9 (mod 12)) and sometimes
impossible (e.g . . 3/41 (mod 12))? The problem is with the modulus n ; if
n is a prime number, then the division a/b (mod n) is always possible and
unique, whilst if n is a composite then the division a/b (mod n.) may be not.
possible or the result may be not unique . Let us observe two more examples .
one with n = 13 and the other with n = 14. First note that, a/b = a . 1/b
(mod n) if and only if 1/b (mod n) is possible, since multiplication modulo n
is always possible. We call 1/b (mod n) the multiplicative inverse (or modular
inverse) of b modulo n . More generally . we have :
Definition 1 .6 .10 . Two integers x and y are said to be multiplicative in-
verses if
:ry - 1 (mod n),
(1 .228)
where n is a positive integer greater than 1 .
It is now clear that given (x, n) . y does not always exist . Let n = 13 be a
prime, then the following table gives all the possible values of the multiplica-
tive inverses y = 1/x (mod 13) for x = 1, 2. •
,12 :
x
1
2
3
4
5
6
7
8
9
10
11
1 2
y
1
7
9
10
8
11
2
5
3
4
6
12
This means that divisions in Z/13Z are always possible and unique (i .e.. the
multiplicative inverses y of x in Z/13Z do always exist and are unique) . On
the other hand, if n = 14 (n, now is a composite) . then for x = 1, 2, - - ,13,
some values for y = 1/x (mod 14) exist, whereas others do not :
x
1
2
3
4
5
6
7
8
9
10
11
12
13
p
1
1
5
1
3
1
1
1
11
1
9
1
13
This means that, only the numbers 1,3,5,9 . 11 and 13 have multiplicative
inverses modulo 14, or equivalently only those divisions by 1,3 .5,9. 11 and
13 modulo 14 are possible . This observation leads to the following important
results :
Theorem 1 .6 .9 . The multiplicative inverse 1/b modulo n exists if and only
if gcd(b, n) = 1 .
But how many Us are there that satisfy gcd(b .. n) = 1? The followin g
result answers this question .
Corollary 1 .6.2. There are d(n) numbers b for which 1/b (mod n) exists .
Example 1 .6 .12. Let n = 21 . Since d(21) = 12 . there are twelve b for which
1/b (mod 21) exists. In fact, the multiplicative inverse modulo 21 only exist s
for each of the following b :
Corollary 1 .6 .3 . The division a/b modulo n (assume that a/b is in low-
est terns) is possible if and only if 1/b (mod n) exists, i .e., if and only if
gcd(b,n) = 1.
Example 1 .6 .13. Compute 6/b (mod 21) whenever it is possible . By the
multiplicative inverses of 1/b (mod 21) in the previous table, we just need to
calculate 6 . 1/b (mod 21) :
b
1
2
4
5
8
10
11
13
16
17
19
20
6/b (mod 21)
6
3
12
18
6
9
12
15
3
9
18
1 5
As it can be seen, addition (subtraction) and multiplication are alway s
possible in Z/nZ, with n > 1, since Z/nZ is a ring . Note also that Z/nZ with
n prime is an Abelian group with respect to addition, and all the non-zer o
elements in 76/n76 form an Abelian group with respect to multiplication (i.e . ;
a division is always possible for any two non-zero elements in Z/nZ if n is
prime) ; hence Z/nZ with n prime is a field. That is ,
Theorem 1.6.10. Z/nZ is a field if and only if n is prime .
The above results only tell us when the multiplicative inverse 1/a modulo
n is possible_ without mentioning how to find the inverse . To actually find
the multiplicative inverse, we let,
1/a (mod n) =
(1.229)
which is equivalent to
ax
1 (mod n) .
(1 .230)
Since
(1 .231)
ax - 1 (mod n)
ax — ny = 1.
So the finding of the multiplicative inverse becomes to find the solution o f
the linear Diophantine equation ax — n.y = 1 . which, as we know in Sectio n
1 .3, can be solved by using the continued fraction expansion of a/n, and can.
of course, be solved by using Euclid's algorithm .
Example 1.6.14. Find
(1) 1/154 (mod 801) ,
(2) 4/154 (mod 801) .

122
1 . Elemontary Number Theor}
1 .6 Theory of Congruences
123
Solution :
(1) Since
1/a (mod n) =
ax - 1 (mod n)
ax — ny = 1 (1.232)
we only need to find ,ar and y i n
154x — 801y = 1 .
To do so, we first use the Euclid's algorithm to find gcd(154, 801) a s
follows .
801
1545+3 1
154
314+30
31
301+ 1
30
10 . 3+0 .
Since gcd(154. 801) = 1, by Theorem 1 .6.9, the equation 154x — 801y = 1
is soluble. We now rewrite the above resulting equation s
31 = 801—154 . 5
30 = 154—31
4
1 = 31—30 . 1
and work backwards on the above new equation s
1
31 30 . 1
31—(154—31 . 4) . 1
31—154+431
5 . 31—154
=
5(801—154 . 5)—154
5801—26 . 154
801 5—154 26
So. x - -26 - 775 (mod 801) . That is. 1/154 mod 801 = 775 .
(2) Since 4/154 E 4 1/154 (mod 801), then 4/154 - 4 . 775 - 697 (mo d
801) .
The above procedure used to find the x and y in ax + by = 1 can be
generalized to find the x and y in ax + by = c: this procedure usually calle d
the extended Euclid 's algorithm . We shall discuss the solution of the general
equation ax + by = c in the next. subsection .
1.6.3 Linear Congruence s
Congruences have much in common with equations. In fact, the linear con-
gruence ax - b (mod n) is equivalent to the linear Diophantine equation
ax — ny = b . That is.
ax b (mod n) 
ax — ny = b .
(1 .233)
Thus, linear congruences can be solved by using a continued fraction metho d
just as for linear Diophantine equations . In this section. however, we shal l
use some theoretical properties of congruences to solve linear congruence s
(the continued fraction approach to linear congruences is left as an exercise
for readers) . The basic theory of linear congruences is described in the nex t
three theorems .
Theorem 1 .6.11 . Let gcd(a, n) = d . If d { b, then the linear congruence
ax - b (mod n)
(1 .234)
has no solutions .
Proof. -'e will prove the contrapositive of the assertion: if ax - b (mod n )
has a solution, then gcd(a,n)
I b. Suppose that s is a solution. Then as
b (mod n), and from the definition of the congruence . n
(as — b) . or from the
definition of divisibility, as — b = kn for some integer k . Since gcd(a, m)
a
and gcd(a . m)
I kn . it follows that gcd(a,n?)
1 b .
q
Theorem 1.6.12 . Let gcd(a,n) = d . Then the linear congruence ax
b (mod n) has solutions if and only if d
b .
Proof. Follows from Theorem 1.6.11 .
Theorem 1 .6.13 . Let gcd(a,n) = 1. Then the linear congruence a x
b (mod n) has exactly one solution .
Proof. If gcd(a,n) = 1, then there exist x and y such that ax + ny
1 .
Multiplying by b gives
a(xb) + n(yb) = b .
As a(xb) — b is a multiple of n . or a(xb) b (mod n) . The least residue of xb
modulo n is then a solution of the linear congruence . The uniqueness of the
solution is left as an exercise .
q
Theorem 1 .6 .14 . Let gcd(a,n) = d and suppose that d
b . Then the linear
congruence
ax - b (mod n) .
(1 .235)
has exactly d solutions modulo n . These are given by

124
L Elementary Number Theory
1 .6 Theory of Congruences
125
n
2n
(d
1)n
t, t+
t+
t+ 
d
where t is the solution . unique modulo n/d, of the linear congruence
a
b
n
–x = – (plod-) .
d '
d
d
Proof.
By Theorem 1.6.12. the linear congruence has solutions since d b .
Now let t be be such a solution, then t + k(n/d) for k = 1 .2, -
.d – 1 are
also solutions, since a(t + k(n/d)) = at + kn(t/d) - at - b (mod n) .
q
Together with the above theorems and the extended Euclid's algorith m
discussed in the previous subsection (or the continued fraction method dis-
cussed in Subsection 1 .3) . we can find the solutions of ax 
b (mod n) .
provided they exist .
Example 1 .6.15 . Find 154x - 22 (prod 803) . Notice first that
154x - 22 (mod 803)
154x – 803y = 22 .
Now we use the Euclid's algorithm to find gcd(154, 803) as follows .
803
=
154 . 5 + 33
154
=
33 . 4+22
33
=
22 . 1+11
22
=
11
2.
Since gcd(154, 803) = 11 and 11
1 22, by Theorem 1 .6 .12 . the equation 154x
801y = 22 is soluble . Now we rewrite the above resulting equations
33 =
803–154 5
22 =
154–33 . 4
11 = 33–22 . 1
and work backwards on the above new equation s
11
33–22
1
33–(154–33 . 4) . 1
33–154+4 . 33
5 . 33 – 154
5(803–154 5) – 154
5 . 803–26 154
= 803 . 5–15426 .
So. x - -26 - 777 (mod 803) . By Theorem 1 .6.13, there are. in total ; 11
solutions of 154x — 801y = 22; we list all of them as follows (we also writ e
the verifications of the results on right) :
777,
154 . 777 - 11 (mod 803)
777 + 803/11 47 .
154 . 47
11 (mod 803)
777 + 2 . 803/11 - 120,
134 . 120 E 11 (mod 803 )
777 + 3 • 803/11 - 193.
154 . 193 = 11 (mod 803 )
4 . 803/11 = 266 .
154 . 266 - 11 (mod 803 )
5 . 803/11 - 339,
154 . 339 E 11 (mod 803 )
777+6803/11=412 .
154 412=11
(mod 803 )
777 + 7 . 803/11 = 485,
154 . 48,5 -11
(mod 803)
777 + 8 - 803/11 - 558 .
154 558 = 11 (mod 803 )
777 + 9 . 803/11 = 631,
154 631 = 11 (mod 803 )
777 + 10 . 803/11 - 704,
1,54 - 704 - 11 (mod 803) .
Remark 1.6.4. To find the solution for the linear Diophantine equatio n
ax 
b (mod n)
is equivalent to find the quotient of the modular division
(1 .238)
x - b (mod n)
a
which is, again, equivalent to find the multiplicative inverse
(1 .239)
- 1 (mod n)
a
(1 .240)
because. if modulo n exists, the multiplication b
is always possible .
In what follows, we shall introduce some important results on linear con -
gruences. Our first result will be Fermat's little theorem (or just Fermat' s
theorem, for short), due to Fermat .
Theorem 1 .6.15 (Fermat's little theorem) . Let a be a positive integer .
and p prime. If gcd(a . p) = 1 . then
ap–r - 1 (mod p).
(1 .241)
Proof. First notice that the residues modulo p of U . 2a 
(p – 1)a are
1 .2 
(p – 1) in some order, because no two of them can be equal . So. if
we multiply them together, we get
a - 2a . . . (p — 1)a =
[(a mod p) - (2a mod p) . . . (p — 1)a mod p)] (mod p)
(p — 1)! (mod p) .
This Tneans tha.
— 1)!a'
(p — 1)! (mod p).
(1 .236)
(1 .237)

126
1 . Elementary Number Theory
Now we can cancel the (p — 1)! since p { (p — 1)!, and the result thus follows .
There is a more convenient and more general form of Fermat's little the -
orem :
ar
a (mod p),
(1.242)
for a E N. The proof is easy: if gcd(a,p) = 1. we simply multiply (1 .241) by
a. If not, then p
a. So ap - 0 - a (mod p).
Fermat's theorem has several important consequences which are very use-
ful in compositeness: one of the these consequences is as follows :
Corollary 1 .6.4 (Converse of Fermat's little theorem, 1640) . Let
n
be an odd positive integer . If gcd(a, n) = 1 and
a"
$ 1 (mod n),
(1.243)
then a is composite .
Remark 1 .6 .5 . As mentioned in Subsection 1 .2 .3, Fermat, in 1640, made a
false conjecture that. all the numbers of the form F, = 22' + 1 were prime .
Fermat really should not have made such a "stupid" conjecture, since F =
232 +1 can be relatively easily verified to be composite. by just using his ow n
recently discovered theorem — Fermat's little theorem :
81
(mod 2 32 + 1)
6561
(mod 2 32 + 1)
43046721
(mod 232 + 1)
3793201458
(mod 2 32 + 1)
3029026160
(mod 2 32 + 1 )
$ 1
(mod 232 + 1) .
Thus. by Fermat's little theorem . F = 23" + 1 is not prime !
Based on Fermat's little theorem . Euler established a more general result
in 1760 :
Theorem 1.6.16 (Euler 's theorem) . Let a and n. be positive integers
with gcd(a.n) = 1 . Then
1 .6 Theory of Congruences
12 7
Proof. Let r1 , r2, - . . , ro(") be a reduced residue system modulo n . Then
are , ar-2, -
.am,(„) is also a residue system modulo n. Thus we have
(arr)(a,r2) . . . (aro(~~)) = 7'112 
(mod n) .
since an
, ar0(„ ) . being a reduced residue system, must be congruent
in some order to n, r2.
, r,(,, ) . Hence,
a ,(n) r i ar, . . . r4(,a) E Ti rz . . . row (mod n) ,
which implies that a°(") = 1 (mod n) .
q
It can be difficult to find the order31 of an element a modulo n but
sometimes it is possible to improve (1 .244) by proving that every integer
a modulo n must have an order smaller than the number 0(n) — this order is
actually the number a(a) .
Theorem 1 .6 .17 (Carmichael's theorem) . Let. a and n be positive inte-
gers with gcd(a,n) = 1 . Then
ay(") = 1 (mod n).
(1.245)
where ,k(n) is Carmichael's function .
Proof. Let n = pi' pz'- • . . p7" . We shall show that
aA(") - 1 (mod p° =)
for 1 < i < k. since this implies that a x(" )
1 (mod n) . If p7' = 2, 4
or a power of an odd prime, then by Definition 1 .4.7, A(at ) = 0(00, so
o))(r;' - 1 (mod p7`)_ Since ,A(p )
A(n) aA(" = 1 (mod p7'). The case
that p7
is a power of 2 greater than 4 is left as an exercise .
q
Note that .A(n) will never exceed ¢(n) and is often much smaller than
0(n): it is the value of the largest order it is possible to have .
Example 1 .6.16. Let a = 11 and n = 24. Then d(24) = 8 . .\(24) = 2. So ,
11° (21) =lls =1(mod 24) .
11 A('21) = 11 2
(mod 24) .
That is. ord2a(11) = 2 .
nod n) .
(1.244)
3 The order of an element a modulo n is the smallest integer r such that a'
1 (mod n) ; we shall discuss this later in Subsection 1.6.7 .

128
1 . Elementary Number Theory
1 .6 Theory of Congruences
12 9
In 1770 Edward Waring (1734 1793) published the following result . which
is attributed to John Wilson 3' .
Theorem 1 .6 .18 (Wilson's theorem) . If p is a prone, then
(p — 1)! - -1 (mod p) .
(1.246)
Proof. It suffices to assume that p is odd . Now to evert integer a with 0 <
a < p there is a unique integer a' with 0 < a' < p such that aa' - 1. (mod p).
Further if a = a' then a'' = 1 (mod p) whence a = 1 or a = p—1 . Thus the set
2,3n • . . .p— 2 can be divided into (p — 3) /2 pairs a, a' with aa' = 1 (mod p) .
Hence we have 2 . 3 - -' (p— 2)
1 (mod p). and so (p — 1)!
-1 (mod p), as
required .
q
Theorem 1 .6 .19 (Converse of Wilson's theorem) . If n is an odd posi-
tive integer greater than 1 and
(n — 1)! - -1 (mod a),
(1 .247)
then n is a prime .
Remark 1 .6 .6 . Prime p is called a Wilson prime if
IV(p) = 0 (mod p) ,
Tv (P) = (p 
1)! + 1
p
599
It is not known whether there are infinitely many Wilson primes : to date .
the only known Wilson primes for p < 5 . 10s are p = 5 .13.563 . A prime p is
called a Wieferich prince, named after A. Wieferich . if
21'—' E 1 (mod p'). (1 .250 )
To date . the only known Wieferich primes for p < 4 . i0' 2 are p = 1093 and
3.511 .
3' The English mathematician John Wilson (1741-1793) is best known for Wilson' s
theorem. This result was first published by Waring . Almost certainly Wilson's
theorem was a guess and Waring didn't know how to prove it . It was first prove d
li Joseph-Louis Lagrange (1736 1813) in 1773 who showed that the converse
is true. Wilson 's theorem has a direct application in primality testing, although
the test is not very efficient .
In what follows, we shall show how to use Euler's theorem to calculat e
the multiplicative inverse modulo n . and hence the solutions of a . linear con-
gruence .
Theorem 1 .6 .20 . Let x be the multiplicative inverse 1/a modulo n. If
gcd(a .n) = 1 . then
is given by
x - 1 (mod n.)
a
(1.251 )
x = aoc")—t (mod n) .
(1 .252)
Proof. By Euler's theorem, we have a' ) ") = 1 (mod n) . Hence
aa'T")—1 - 1 (mod n) ,
and a'' i")
r is the multiplicative inverse of a modulo n . as desired .
q
Corollary 1 .6 .5 . Let a be the division b/a modulo n (b/a is assumed to b e
in lowest terms) . If gcd(a,n) = 1, then
= b
x
(mod n)
a
is given by
x = b ' a° 1")
(mod n).
Corollary 1 .6 .6 . If ged(a, n) = 1 . then the solution of the linear congruenc e
ar = b (mod n)
(1 .255 )
is given by
x = ba" ( ")—' (mod n) .
(1 .256)
Example 1 .6.17. Solve the congruence 5x - 14 (mod 24) . First note that
because gcd(5, 24) = 1 . the congruence has exactly one solution . Using (1 .2.56 )
we get
= 14 . 5° )'r )—r (mod 24) = 22 .
Example 1 .6.18. Solve the congruence 20x = 15 (mod 13 .5) . First note
that as d = gcd(20.135) = 5 and d
15. the congruence has exactly five
solutions modulo 135 . To find these five solutions, we divide by 5 and get a
new congruence
4x' = 3 (mod 27) .
To solve this new congruence, we get
x' = 3 - 4027)–i = 21 (mod 27) .
Therefore, the five solutions are as follows :
where
is an integer . or equivalently if
(n — 1)! _ -1 (mod p2) .
For example. p = 5, 13, 563 are Wilson primes, but 599 is not sinc e
(599 — 1)! + 1 mod .599 = 382  .
(1 .248)
(1 .249)
(1 .253)
(1 .254)

130
1 . Elementary >\ umber Theory
,
n
2n-
,
3n
4i .
Cr,x+ d , '+ a,a + d,x+ d
(21, 21+27, 21+2-27. 21+3 . 27 . 21+4 . 27)
(21.48, 75,102,129)
(mod 135) .
1 .6 .4 The Chinese Remainder Theorem
In this subsection, we introduce a method for solving systems of linear con-
gruences. The method, widely known as the Chinese Remainder Theorem (o r
just CRT . for short) . was discovered by the ancient Chinese mathematician
Sun Tsu33 .
Theorem 1 .6 .21 (The Chinese Remainder Theorem CRT) . If m i
m2, rn, are pairwise relatively prime and greater than 1, and a i , a2 , - -
a„ are any integers, then there is a solution .r to the following simultaneou s
congruences :
x - a l (mod nzm) ,
x = a2 (mod m2 ) ,
x - a„ (mod rn„) .
If x and x' are two solutions, then x - x ' (mod Al) . where Al = mi rn2 . .
- m,t .
Proof. Existence: Let us first solve a special case of the simultaneous con-
gruences (1 .257), where i is some fixed subscript ,
ai = 1 , a l = a2 =
= ai--r = coal = - = a„ = O .
33 Sun Zi (known as Sun Tsu in the West) . a Chinese mathematician, lived sometim e
between 200 B .C . and 200 A .D. He is perhaps best. known for his discovery of th e
Chinese Remainder Theorem which may be found in Problem 26 in Volume 3 of
his classic three-volume mathematics book Mathematical Manual: find a number
that leaves a remainder of 2 when divided by 3, a remainder of 3 when divided
by 5 . and a remainder of 2 when divided by 7: in modern algebraic language . to
find the smallest positive integer satisfying the following systems of congruences :
x = 2 (mod 3) ,
x - 3 (mod 5) ,
x - 2 (mod 7) .
Sun Zi gave a rule called "tai-yen" ( "great generalisation" ) to find the solu-
tion. Sun Zi's rule was generalized in today 's "theorem-form" by the great Chi-
nese mathematician Ch 'in Chiu-Shao in his book Mathematical Treatise in Nin e
Chapters in 1247 ; Ch ' in also rediscovered Euclid 's algorithm. and gave a complet e
procedure for solving numerically polynomial equations of any degree, which i s
very similar to. or almost the same as . what. is now called the Horner metho d
published by William Horner in 1819 .
1.6 Theory of Congruences
131
Let k, = mi m2 - • •
. . in,, . Then k 1 and m i are relatively prime,
so we can find integers r and s such that rk i + srn i =
1 . This gives the
congruences :
rki
0 (mod k i ) ,
rki = 1 (mod mi ) .
Since mr, rn.2 , - -
. nti_i , real+r,
m„ all divide ki , it follows that xi = rk i
satisfies the simultaneous congruences :
xi - 0 (mod m i ) .
x i, - 0 (mod m.2 ) ,
x i - 0 (mod mi_r) .
x i = 1 (mod aai) .
x i - 0 (mod mi+r) .
x i - 0 (mod m,i ) .
For each subscript i, 1 < i < n, we find such an x, . Now, to solve the syste m
of the simultaneous congruences (1.257), set x = a i xr + a2x2 + ' -' +
Then x = aixi = ai (mod in i) for each i, 1 < i < n . therefore x is a solution
of the simultaneous congruences .
Uniqueness: Let x ' be another solution to the simultaneous congruence s
(1.257) . but different from the solution x, so that x' = x (mod mi) for each
xi. Then .r — x ' - 0 (mod m i ) for each i . So, mi divides x — x' for each i ;
hence the least common multiple of all the m l 's divides x — x' . But since the
m i are pairwise relatively prime, this least common multiple is the produc t
AI. So, .r
.r' (mod AI) .
q
The above proof of the CRT is constructive, providing an efficient metho d
for finding all solutions of systems of simultaneous congruences (1 .257) . There
are, of course, many other different proofs of the CRT: there is even a very
short proof, due to Mozzochi [171] : it makes use of the following lemma :
Lemma 1 .6.1 . Suppose that mi ,'m2, - - - , m,z are pairwise relatively prime .
Then x - y (mod m i ). i = 1, 2 
n if and only if x = y (mod M), wher e
M=mim2 . . .
Now we are in a position to presentMozzochi's short proof of the CRT .
Proof. Let a E Z . [x],, = {y : .r, = y (mod a)}, and Z/aZ the set of all
residue classes modulo a . Define
a :7L/_l7L—>Z/m 1ZxZ/m9Zx
. - . xZ/m„7G
by
(Y ([x]al) = f[f] ', [x] rus
.
. . [x] n,,~ )
for each x E Z . By Lemma 1 .6 .1,
t is a. well-defined, one-to-one mapping o f
Z/MZ into Z,,,, x Z,,, 2 x - . - x Z,„,, . Since
(1 .257)

132
1 . Elementary Number Theory
1.6 Theory of Congruences
133
1Z/11IZI = 1I = I7Z/miZ x 7G/in2Z x
. . . x 76/m„Z H
ii is onto. But then, given integers a1 . a2, • - - , a, there is an integer x such
that
Grim atismi
= ([a11,,n, [a2],,,2 . . . [a,a],>, „
and therefore . x
ai (mod m,), for i = 1 .2 
n . By Lemma 1 .6 .1, any
two solutions are congruent modulo Al .
q
Remark 1.6.7. If the system of the linear congruences (1 .257) is soluble ,
then its solution can he conveniently described as follows :
a, Ill JI ' (mod m)
(1 .258)
where
m=ml rn2 .
Tit
1Ii = rn/rn„
ll =lI
' (rnodmi ) ,
fori=1,2,---
. n
Example 1 .6.19. Consider the Sun Zi problem :
= 2 (mod 3) ,
x - 3 (mod 5) ,
x - 2 (mod 7) .
By (1 .258), we have
m=nal m2m3 =3 . 5 . 7=105,
17 1 = m/rn 1 = 105/3 = 35 ,
1h
Al_
1 (mod m 1 ) = 35-1 (mod 3) = 2 ,
1I2 =ni/m9=105/5=21 ,
lL_ = ALT 1 (mod rn2 ) = 21-1 (mod 5) = 1 ,
113=m/rn 3 =105/7= 15 .
1I3
if
1 (mod m3 ) = 15-1 (mod 7) = 1 .
Hence .
al IIi _ll; +x2 112 11._+a 113 11 .'3 (mod m )
2 . 35 . 2+3 . 211+2 . 15 . 1 (mod 105 )
23 .
Exercise 1 .6 .1 . Solve the following simultaneous congruences :
x - 2 (mod 7) ,
x-7(mod 9) ,
a - 3 (mod 4).
The Chinese Remainder Theorem is very applicable in several central ar-
eas of mathematics and computer science. including algebra, number theory.
computer arithmetic, fast computation. cryptography. computer security. and
hash functions. We shall discuss some of these applications later .
1 .6 .5 High-Order Congruence s
The congruences ax E b (mod m) we have studied so far are a special type
of high-order congruence; that is. they are all linear congruences. In this
subsection. we shall study the higher degree congruences, particularly th e
quadratic congruences .
Definition 1 .6.11 . Let in be a positive integer, and let
f(x)ao+al x+a2x-+ .
. + an .a "
be any polynomial with integer coefficients . Then a high-order congruence or
a polynomial congruence is a congruence of the for m
f (x) - 0 (mod 1a) .
(1 .259)
A polynomial congruence is also called a polynomial congruential equation .
Let us consider the polynomial congruence
f(.r) = x`; +5x-4 = 0 (mod 7) .
This congruence holds when x = 2 . since
f(2)=23 +5 . 2-4=0(mod 7).
Just as for algebraic equations, we say that x = 2 is a root or a solution o f
the congruence. In fact, any value of x which satisfies the following condition
x = 2 (mod 7 )
is also a solution of the congruence . In general . as in linear congruence . when
a solution xo has been found . all values x for whic h
x - xo (mod n)
are also solutions. But, by convention . we still consider them as a single so-
lution. Thus, our problem is to find all incongruent (different) solutions of
f (x) - 0 (mod ii) . In general . this problem is very difficult . and many tech-
niques for solution depend partially on trial-and-error methods . For example.
to find all solutions of the congruence f (x) = 0 (mod n), we could certainly
try all values 0.1 .2. - - - ,n - 1 (or the numbers in the complete residue syste m
modulo n) . and determine which of them satisfy the congruence : this would
give us the total number of incongruent solutions modulo n .

134
1. Elementary Number Theory
1 .6 Theory of Congruences
135
Theorem 1.6 .22. Let bl = m l n1 2
in,,, where rnr,nz2, -- - . m.,, are pair-
wise relatively prime. Then the integer xo is a solution of
Pa.) = 0 (mod M)
(1 .260)
if and only if xo is a solution of the system of polynomial congruences :
f (x) = 0 (mod mi ) ,
f (x) 0 (mod m2),
(1 .261)
f (x) = 0 (mod m„).
If x and x' are two solutions, then x = x' (mod M), where Al = m i rn2 . . - m,,.
Proof. If f(a) - 0 (mod Al), then obviously f (a) - 0 (mod m,), for i =
1 .2, • ,n . Conversely, suppose a is a solution of the system
f (x) = 0 (mod m;),
for i = 1, 2, . . . . a .
Then f (a) is a solution of the system
y-0(mod m,i
y - 0 (mod m 2
y = 0 (mod m„)
and it follows from the Chinese Remainder Theorem that Pa) = 0 (mod
m i rn2
Thus, a is a solution of ,f (x) = 0 (mod M) .
q
We now restrict ourselves to quadratic congruences, the simplest possibl e
nonlinear polynomial congruences .
Definition 1 .6.12 . A quadratic congruence is a congruence of the form :
a (mod n)
(1.262)
where gcd(a, n) = 1. To solve the congruence is to find an integral solutio n
for x which satisfies the congruence .
In most cases, it is sufficient to study the above congruence rather tha n
the following more general quadratic congruenc e
axe + bxr + c - 0 (mod
(1 .263)
since if gcd(a,n) = 1 and b is even or n is odd . then the congruence (1 .263)
can be reduced to a congruence of type (L262) . The problem can even be
further reduced to sol ving a congruence of the type (if n =
where pi .p2 . • • • pk are primes. and ca l
. ak are positive integers) :
zs = n. (mod pi `pz~
. °)
(1.264)
because solving the congruence (1 .264) is equivalent to solving the followin g
system of congruences:
x 2 = a (mod K i )
r 2 - a (mod p42)
(1 .265)
x 2
a (mod pk `) .
In what follows, we shall be only interested in quadratic congruences of the
form
x - a (mod p)
(1 .266)
where p is an odd prime and a 0 (mod p) .
Definition 1 .6.13. Let a be any integer and n a natural number_ and sup-
pose that gcd(a, n) = 1 . Then a is called a quadratic residue modulo n if the
congruence
a;- = a (mod n)
is soluble. Otherwise. it is called a quadratic nonresidue modulo n, .
Remark 1 .6.8. Similarly. we can define the cubic residues, and fourth-power
residues . etc. For example, a is a kth power residue modulo n if the congruence
= a (mod n)
(1 .267)
is soluble. Otherwise, it is a kth power nonresidue modulo n .
Theorem 1 .6 .23. Let, p he an odd prime and a an integer not divisible by
p. Then the congruence
x-2 - a (mod p)
(1 .268)
has either no solution, or exactly two congruence solutions modulo p .
Proof. If x and y are solutions to x2 = a (mod p) . then x 2 - y2 (mod p) ,
that is . p (x2 — y2 ) . Since x 2 — ,y 2 = (x+ y)(x
y), we must have p
(x — y )
or p
(x + y), that is, x = ±y (mod p). Hence, any two distinct solution s
modulo p differ only by a factor of -1 .
q
Example 1.6.20. Find the quadratic residues and quadratic nonresidues fo r
moduli 5, 7,11, respectively.

136
1. Elementary Number Theory
1 .6 Theory of Congruences
137
(1) Modulo 5. the integers 1,4 are quadratic residues. whilst 2,3 are
quadratic nonresidues, sinc e
1 2 =42 =1,
22 =32 =4.
(2) Modulo 7 . the integers 1, 2.4 are quadratic residues, whilst 3 .5.6 are
quadratic nonresidues, since
12 -62 -1,
22 =52
4
3 22 -42 -2 .
(3) Modulo 11, the integers 1.3,4, 5 .9 are quadratic residues, whilst
2 .6, 7.8,10 are quadratic nonresidues, sinc e
12 =102 =1 .
22 =9 2 =4,
32 =82 =9,
42=72=5 ,
52
62 -3 .
(4) Modulo 15, only the integers 1 and 4 are quadratic residues, whils t
2, 3, 5, 6, 7, 8, 9,10,11,12,13,14 are all quadratic nonresidues. since
12 =42 -11 2 =14 2 -1 ,
22 -72 =8=132 -4.
(5 Modulo 23, the integers 1 .2,3.4 .6.8.9.12,13.16, IS are quadratic
residues, whilst 5, 7,10,11,14,15,17,19 .20, 21, 22 are quadratic non-
residues. since
12=222 - 1 .
52 =182 =2 ,
72 =162 =3 .
22 =212 =4 .
112 =122 _6.
102 =132 +8 .
32 =202 =9 .
92 =142 -12 ,
62 =172 -13,
42 =192 =16 ..
8 2 =152 =18 .
The above example illustrates the following two theorems :
Theorem 1.6.24. Let p be an odd prime and N(p) the number of consecu-
tive pairs of quadratic residues modulo p in the interval [l .p — 1] . Then
(p) =
\1' — 4
( 1)(n
r)/2)
(1 .269)
Proof. (Sketch) The complete proof of this theorem can be found in [10] ;
here we only give the sketch of the proof. Let (RR), (RN), (NR) and (NN )
denote the number of pairs of two quadratic residues, of a quadratic residue
followed by a quadratic nonresidue . of a quadratic nonresidue followed by a
quadratic residue, of two quadratic nonresidues, among pairs of consecutiv e
positive integers less than p. respectively. Then from [10], we have :
(RR) + (RN) = 2 (p
2— (
1) (P—' )/2 )
(NR) + (NN) = 2 (p — 2 + (—1)(P—i)/'2 )
(RR) + (NR) = 2 (p — 1)) — 1
(RN)+(NN)= 2(p—1) )
(RR) + (NN) — (RN) — (NR) = - 1
(RR)+(NN)=2(p—3)
(RR) — (NN) = -2 (1 + (-1)(P-0/2 )
Hence (RR) = (p — 4 — (—1)(P—')/2)
q
Remark 1 .6 .9. Similarly, Let v(p) denote the number of consecutive triple s
of quadratic residues in the interval [1,p — 1] . where p is odd prime. Then
v(p) = gp+EP,
(1 .270)
where IEP 1<$ p+2 .
Example 1 .6.21 . For p = 23, there are five consecutive pairs of quadratic
residues. namely, (1, 2), (2, 3), (3, 4), (8 .9) and (12,13), modulo 23 ; there are
also one consecutive triple of quadratic residues, namely. (1.2, 3), modulo 23 .
Theorem 1.6.25. Let p be an odd prime. Then there are exactly (p — 1)/2
quadratic residues and exactly (p — 1)/2 quadratic nonresidues modulo p.
Proof. Consider the p — 1 congruences :
:r,2 = 1 (mod p)
r2 - 2 (mod p )
r2 - p — 1 (mod p) .
Since each of the above congruences has either no solution or exactly two
congruence solutions modulo p, there must be exactly (p – 1)/2 quadrati c
residues modulo p among the integers 1 .2. -
.p – 1. The remaining p – 1 –
(p–1)/2 = (p–1)/2 positive integers less than p–1 are quadratic nonresidue s
modulo p .
q

138
1 . Elementary Number Theory
1.6 Theory of Congruences
139
Example 1 .6.22 . Again for p = 23. there are eleven quadratic residues . and
eleven quadratic nonresidues modulo 23 .
Remark 1 .6 .10 . Note that here 15 = 3 . 5 is a composite number . Let Q„
be the quadratic residues modulo n with n composite. Then for n = p . q with
p. q prime, we have
Qn — Qp U Qq .
This fact suggests that the quadratic residues modulo a composite n can be
determined quickly if the prime factorization of n is known. For example. let
n= 15 . we have
Qr;=Q3UQ={1}U{1,4}={1,4} .
Euler devised a simple criterion for deciding whether an integer a is a
quadratic residue modulo a prime number p .
Theorem 1 .6.26 (Euler's criterion) . Let p he an odd prime and
gcd(a,p) = 1 . Then a is a quadratic residue modulo p if and only if
a(p-r)/'-' - 1 (mod p).
Proof. Using Fermat's little theorem, we find that
(a (p-1)/2 - 1)(a(p-0/2 + 1) = ap-r - 1 = 0 (mod p)
thus
a(P-r)/2 = 1 (mod p )
If a is a quadratic residue modulo p . then there exists an integer xo such that
o E a (mod p). By Fermat's little theorem, we have
Euler's criterion is not very useful as a practical test for deciding whethe r
or not an integer is a quadratic residue . unless the modulus is small . Euler's
studies on quadratic residues were further developed by Legendre, who in-
troduced. in his own honour . the Legendre symbol, which will be the subjec t
matter of our next subsection .
1 .6 .6 Legendre and Jacobi Symbols
Definition 1 .6 .14 . Let p be an odd prime and a an integer . Suppose that
gcd(a, p) = 1. Then the Legendre symbol. (
p
~) , is defined by
= 1 .
if a is a quadratic residue modulo p ,
(a
p)
= 1, if a is a quadratic non residue modulo p .
We shall use the notation a E Qp to denote that a is a quadratic residu e
modulo p ; similarly_ . a E Qp will be used to denote that a is a quadratic
nonresidue modulo p .
Example 1 .6.23. Let p = 7 and
1'- = 1 (mod 7),
22 - 4 (mod 7),
32 = 2 (mod 7) .
42 = 2 (mod 7),
5-' = 4 (mod 7),
6 = = 1 (mod 7) .
Then
O=(2)=(3)=
(3)=()_(6)=1 .
(1 .271)
a(p- 1 )/2 = (:co)(p-E/2 = ,ro-r - 1 (mod p) .
To prove the converse. we assume that a(p—r)/2- = 1 (mod p) . If g is a prim-
itive root modulo p (g is a primitive root modulo p if order(g . p) = ¢(p); we
shall formally define primitive roots in Subsection 1 .6.7) . then there exists a
positive integer t such that g (
a (mod p) . Then
Some elementary- properties of the Legendre symbol . which can be used
to evaluate it. are given in the following theorem .
Theorem 1 .6.27. Let p be an odd prime, and a and b integers that ar e
relatively prime to p . Then:
gt(p—r)/2 = a(p-1)/2 = 1 (mod p)
a
b '
(1) If a = b (mod p). then
= ( -
1)
p z
which implies that
t(p - 1)/2E 0 (mod p - 1) .
(2)
a '
(-)
1
= 1. and so-) = I .
Thus, t is even, and so
(m0( 1
(9t/y = gr = a
p)
(3)
P
a
P
=( (p–1)/'(mod p) .
which implies that a is a, quadratic residue modulo p .

140
1 . Elementary Number Theory
1 .6 Theory of Congruences
141
(4)
p J
( p
J
(p
)
(5)  
1
= (_1)(n–r)/a
P i
Proof. Assume p is an odd prime and gcd(p, a) = gcd(p, b) = 1 .
(1) If a
b (mod p), then x2 - a (mod p) has solution if and only if
a
b
x2 E b (mod p) has a solution. Hence (-~
=
p
p
(2) The quadratic congruence x2 - a'
(mod p) clearly has a. solution
namely a, so (—) = 1 .
p //1
(3) This is Euler's criterion in terms of Legendre's symbol .
(4) We have
(al
Therefore. the quadratic congruence x2
63 (mod 11) has no solution .
To avoid the "trial and error" in the above and similar examples, we
introduce in the following Gauss's lemma for evaluating the Legendre symbol.
Definition 1 .6.15 . Let a E Z and n E N. Then the least residue of a modulo
n is the integer a' in the interval (-n/2,n/2] such that a E a' (mod n) . We
denote the least residue of a modulo n by LR„(a) .
Example 1 .6.25 . The set {–5, -4. -3, -2, -1,0,1,2,3,4,51 is a complete
set of of the least residues modulo 11 . Thus, LB 11 (21) = -1 since 21 E 10
-1 (mod 11) ; similarly, LRlr (99) = 0 and LB. 1 i (70) = 4.
{±1.±2,
by (1) of Theorem 1.6.2 7
Lemma 1.6.2 (Gauss's lemma) . Let p be an odd prime number and sup-
pose that gcd(a, b) = 1 . Further, let w be the number of integers in the set
(ab)(r'–1)/2 (mod p) (by Euler 's criterion) (1 .272)
E
a(p–11/2b(n–11/2 (mod p)
(1 .273)
(1.274)
(11)
( 8 )
i
11) (11
)
211
1
= -1
by -trial and error" .
by (2) of Theorem 1 .6.27
by (2) of Theorem 1.6.27
(5) By Euler's criterion, we have
 
1
_1)(r-1)/2 .
p
whose least residues modulo p are negative (or greater than p/2), then
2a, 3a ,
This completes the proof.
q
Corollary 1 .6.7. Let p be an odd prime . Then
(a) = (–1 )''' .
(1 .276)
(1
1
if p -= 1 (mod 4)
p )
-1
if p 3 (mod 4) .
(
– 1
a. 2a, 3a,
p 2 
a
Proof. When we reduce the following numbers (modulo p )
(1 .275)
Proof. If p - 1 (mod 4) . then p = 4k + 1 for some integer k . Thus ,
()/2 = (—1)((4k+1)—1)/2 = (—1)2k = 1,
so that
7 -1
= 1. The proof for p - 3 (mod 4) is similar .
q
P
Example 1 .6.24 . Does x2 E 63 (mod 11) have a solution? We first evalu -
ate the Legendre symbol (W) corresponding to the quadratic congruence as
follows :
to lie in set
( 2
a}
.
then no two different numbers ma and na can go to the same numbers.
Further, it cannot happen that ma goes to k and na goes to k, becaus e
then no + na E k + (–k) E 0 (mod p), and hence (multiplying by th e
inverse of a), in + n. E 0 (mod p), which is impossible. Hence, when reduced
the numbers
{a . 2a, 3a,
( p 2 1 )a}

142
1 . Elementary Number Theory
1 .6 Theory of Congruences
14 3
we get exactly one of -1 and 1, exactly one of -2 and 2 . - -' , exactly- one of
–(p – 1)/2 and (p – 1)/2 . Hence, modulo p, we get
(–1) ' (mod p) .
Cancelling the numbers 1 .2 . • - - , (p – 1)/2, we hav e
a(p–r)/_ (–1) 7' (mod p).
By Euler's criterion, we have G) _– (–1)w (mod M . Since (–)
we
must have (P)
(–1)w .
Example 1 .6 .26. Use Gauss's lemma to evaluate the Legendre symbol
(P) . By Gauss's lemma . O = (–l)', where w is the number of integer s
in the set
{1 . 6, 2 . 6. 3 . 6. 4-6 . 5 . 6 }
whose least residues modulo 11 are negative (or greater than 11/2) . Clearly.
(6,12 .18.24.30) mod 11 - (6,1, 7, 2, 8) - (–5, 1 . -4, 2, -3) (mod 11)
So. there are 3 least residues that are negative (or greater than 11/2) . Thus,
= 3. Therefore. (P) = (–1) t3 = -1 . Consequently. the quadratic congru-
ence x2
6 (mod 11) is not solvable .
Remark 1 .6.11. Gauss's lemma is similar to Euler's criterion in the follow-
ing ways :
(1) Gauss's lemma provides a method for direct evaluation of the Legendre
symbol :
(2) It has ,Wore significance as a theoretical tool than as a computationa l
tool.
Gauss's lemma provides .. among many others . a means for deck
whether or not 2 is a quadratic residue modulo an odd prime p .
Theorem 1 .6.28 . If p is an odd prime . then
1,
ifp = +1 (mod 8)
(1 .277)
-1
if p E +3 (mod 8) .
Proof. By Gauss's lemma, we know that if w is the number of least positive
residues of the integers
1
1 . 2, 22 
p 2 
-2
that are greater than p/2 . then
= (–1)' . Let k E Z with 1 < k <
P
(p – 1)/2. Then 2k < p/2 if and only if k < p/4; so [p/4] of the integers
1 - 2. 2 . 2 
p–
• 2 are less than p/2 So. there are u
(p – 1)/2 – [p/4]
integers greater than p/2 . Therefore, by Gauss's lemma., we have
(p) _ (–1)r 2
1
L4~ .
For the first equality, it suffices to show that
p	
2 1
[4i =
p 2	 8 1 (mod 2) .
If p = 1 (mod 8), then p = 8k + 1 for some k C 7G, from which
p–1
p- _ (8k+1)–1
8k+ 1
2
L4_
2
4
and
– 1
(8k+1) 2 –1
64k2 +16k.
8 =
8
8
8k2 + 2k - 0 (mod 2) .
so the desired congruence holds for p = 1 (mod 8) . The cases for p E
-1 . T3 ( mod 8) are similar. This completes the proof for the first equality of
the theorem . Note that the cases above yield
which implies
)
J 1,
if p +1 (mod 8)
-1,
if p = ±3 (mod 8 )
This completes the second equality of the theorem .
Example 1 .6.27. Evaluate (2) and ( ; ) .
o3
(1) By Theorem 1 .6.28. we have (2) = 1. since 7 = 7 (mod 8) . Conse-
r
quently,. the quadratic congruence yz = 2 (mod 7) is solvable .
(2) By Theorem 1 .6.28. we have (3) = -1, since 53
.5 (mod 8) . Con-
sequently. the quadratic congruence :2 - 2 (mod 53) is not solvable .
a 2a . . .
a - 1 . 2 . .
l: -1 \
2
2
= ( –1) (p'– r
p
=4k–2k=2k=0 (mod 2) ,
P2	
= ( 1,
ifp - +1 (mod 8 )
8
-1,
if p - +3 (mod 8)

256
2. Computational/ Algorithmic Number Theory
2 .4 Algorithms for Discrete Logarithms
25 i
Let m =
'VT J . The baby-step giant-step algorithm is based on th e
observation that if J. = log„ b . then we can uniquely write :r = i + jrn, where
0 < < rn . For example . if 11 = log 2 15 mod 19, then a = 2, b = 15. m. = 5 ,
so we can write 11 = i+ 5j for 0 < i, j < m . Clearly. here
i, = 1 and j = 2
so we have 11 = 1 + 5 • 2 . Similarly. for 14 = loge 6 mod 19 we can writ e
14=4+5-2,for 17=log 2 10mod 19wecanwrite 17=2+5 . 3, etc. The
following is a description of the algorithm :
Algorithm 2 .4.1 (Shanks' baby-step giant-step algorithm) . This al-
gorithm computes the discrete logarithm J . of y to the base a, modulo n, such
that y = a .' (mod n) :
[1] [Initialization] Computes s = [:(/Ti J .
[2] [Computing the baby step] Compute the first sequence (list), denoted by S ,
of pairs (pa'. r), r = 0,1.2 .3:
, s
1 :
S = {(y.0) . (ya . 1) . (ya2.2) . (ya3 , 3) 
( .ya's
, s — 1) mod n}
(2 .117)
and sort S by ya', the first element of the pairs in S .
[3] [Computing the giant step] Compute the second sequence (list), denoted b y
T, of pairs (a" . ts), t = 1.2 .3 .
.s :
T = {(a' .1), (a2.a , 2), (a3' 3)
. . . , (a'~, s) mod n}
(2 .118)
and sort T by a", the first element of the pairs in T .
[4] [Searching, comparing and computing] Search both lists S and T for a matc h
pa' = an with ya' in S and at' in T, then compute x = is — r . This x i s
the required value of log„ y (mod a) .
This algorithm requires a table with O(m) entries (m =
[N/Ti j, where
it is the modulus) . Using a sorting algorithm. we can sort both the lists S
and T in O(mlogm) operations . Thus this gives an algorithm for computing
discrete logarithms that uses O(
n.logn.) time and space for O( n) group
elements. Note that Shanks' idea is originally for computing the order of a
group element g in the group G. but here we use his idea. to compute discret e
logarithms . Note also that although this algorithm works on arbitrary groups .
if the order of a group is larger than 10 10 , it will be infeasible .
Example 2.4.1. Suppose we wish to compute the discrete logarithm x =
loge 6 mod 19 such that 6 = 2' mod 19 . According to Algorithm 2 .4.1 . we
perform the following computations :
1]y=6 .a=2 and n= 19 . .s=[
19J=4 .
[2] Computing the baby step :
S
= {(y, 0) . ( .pa,1) . (ya- . 2) . (ya 3 .3)
mod 19 }
=
{(6.0) .(6 .2,1),(6 .22 .2) .(6-23 .3)mod 19}
{(6, 0) . (12 .1) . (5 .2), (10, 3) }
1(5. 2), (6.0), (10, 3), (12. 1)}.
[3] Computing the giant step :
T = {(as. .$) . (02s , 2.$) . (a3', 3.$) . (a l' . 4s) mod 19 1
{(2 1 , 4) . (28 .8),(2 12 , 12) . (2 10 .16) mod 19}
_ {(16,4),(9,8) .(11.12).(5 .16) }
1(5. 16) . (9, 8), (11.12), (16.4)} .
[4] Matching and computing: The number 5 is the common value of th e
first element in pairs of both lists S and T with r = 2 and st = 16 . so
:r = st — r = 16 — 2 = 14. That is . log2 6 (mod 19) = 14, or equivalently.
214 (mod 19) = 6 .
Example 2.4.2. Suppose now we wish to find the discrete logarithm x
log;9 67 (mod 113) . such that 67 - 59'` (mod 113) . Again by Algorithm
2.4.1, we have :
[1]y=67,a=59andn=113,s=[ 3113j=10 .
[2] Computing the baby step :
S = {(y, 0), (ya,1), (ya' , 2) . (pa 3 , 3) 
(pa', 9) mod 113 }
= {(67.0), (67 . 59.1) . (67 . 592.2) . (67 . 59 3 , 3) . (67 . 594 , 4) ,
(67 . 590 .5), (67 . 59 0 , 6), (67 . 597, 7) . (67 . 598, 8) ,
(67 . 599 ,9) mod 113}
1(67. 0), (111 . 1), (108, 2), (44, 3), (110, 4) . (49, 5), (66, 6) .
(52, 7), (17,8),(99. 9)1
1(17, 8), (44, 3) . (49. 5) . (52, 7), (66, 6), (67, 0), (99, 9) ,
(108. 2) . (110, 4) . (111.1)}.
[3] Computing the giant-step :
T
=
{(as. .$), (a2' . ss) . (a3s .3.$) . . . . (110' . 10s) mod 113 }
{(5910.10), (592.10.2 . 10) . (59110 .3 - 10). (59410.4 . 10).
(59°'10 .5 . 10), (59610 ..6 . 10). (59710, 7 . 10) . (59 R 10 .8 . 10) .
(59910,9 . 10) mod 113}
1(72. 10). (99 . 20) . (9, 30) . (83.40) . (100.50) . (81, 60).
(69.70) .(109,80),(51,90),(56 .100) 1
{(9.30) . (51 . 90), (.56. 100) . (69. 70). (72, 10) . (81 .60). (83 . 40) .
(99. 20). (100, 50), (109, 80)} .
[4] Matching and computing: The number 99 is the common value of th e
first element in pairs of both lists S and T with r = 9 and st = 20 .
so x = st — r = 20 — 9 = 11 . That is, log ;;g 67 (mod 113) = 11, or
equivalently. 5911 (mod 113) = 67.

144
1 . Elementary Number Theory
1.6 Theory of Congruences
14 5
Using Lemma 1 .6.2, Gauss proved the following theorem, one of the grea t
results of mathematics :
Theorem 1.6.29 (Quadratic reciprocity law) . If p and
odd primes, the n
(1) (p~
= (2)
if one of p.q
1 (mod 4) .
q
p
(2) (~) =
if both p, q E 3 (mod 4) .
q ///
x p
Remark 1 .6 .12 . This theorem may be stated equivalently in the for m
( q
)
p = (_i)(p—1)(q—1)/9
(1.278)
Proof. We first observe that, by Gauss's lemma, P = 1', where w
q i
is the number of lattice points (x, y) (that is, pairs of integers) satisfyin g
0 < x < q/2 and —q/2 < px — qy < O . These inequalities give y < (px/q) +
1/2 < (p+1)/2 . Hence, since y is an integer, we see w is the number of lattic e
points in the rectangle R defined by 0 < x < q/2, 0 < y < p/2, satisfying
—q/2 < px — qy < 0 (see Figure 1 .10) . Similarly, (I)) = le , where i is the
CI))
number of lattice points in R satisfying —p/2 < qx — py < O. Now, it suffices
to prove that (p—1)(q—1)/4—(w+µ) is even . But (p—1)(q—1)/4 is just the
number of lattice points in R satisfying that px —qy < q/2 or qy —px < —p/2 .
The regions in R defined by these inequalities are disjoint and they contai n
the same number of lattice points. since the substitutio n
x=(q+1)/2 —
y=(p+1)/2— y
furnishes a one-to-one correspondence between them . The theorem follows.
Remark 1 .6 .13 . The Quadratic Reciprocity Law was one of Gauss's majo r
contributions. For those who consider number theory `"the Queen of Mathe-
matics" . this is one of the jewels in her crown . Since Gauss's time, over 150
proofs of it have been published : Gauss himself published not less than six
different proofs. Among the eminent mathematicians who contributed to th e
proofs are Cauchy, Jacobi, Dirichlet . Eisenstein, Kronecker and Dedekind .
Combining all the above results for Legendre symbols . we get the following
set of formulas for evaluating Legendre symbols :
Figure 1 .10. Proof of the quadratic reciprocity law
= a(p—1)/2 (mod p)
P
(1.279)
= 1
P( 1 )
(1.280)
-1
(_1)(p—1)/2
P
(1 .281)
a = b (mod p) 
( p
)
(b)
(1 .282)
(1.283)
t \
(ala?
. . .(
= /al ) ( a9 )
. . . .
( lik )
(1.284)
P
P
P
P
(ab21
(a
for
(1 .285 )
(2) _ (1)(p2-1)/ $
P
(1 .286)
(P~ _ (—I)(p—1)(q-1)/
q
Cp
(1 .287)
q are distinct
p/2
1/2

146
1 . Elementary Humber Theory
1.6 Theory of Congruences
14 7
honour of the German mathematician Jacob) . which is a natural general-
ization of the Legendre symbol :
Definition 1 .6 .16. Let a be an integer and n > 1 an odd positive integer .
If n =
.
. then the .Jacob y symbol. ( ) . is defined by
i
(a
(lj
"
(P2) "
. . .
(p`~, "'
(1.288)
where CI) for i = 1, 2, .
.k is the Legendre symbol for the odd prime p ;.
~
If n is an odd prime. the Jacobi symbol is just the Legendre symbol .
The Jacobi symbol has some similar properties to the Legendre symbol .
It follows that the quadratic congruence 33
2 (
od 83) is soluble .
as shown in the following theorem .
Theorem 1.6.30. Let
in and n be any positive odd composites. and
gcd(a, n) = gcd(b, n) = 1 . Then
(1) If a - b (mod a), then (a)
= C
b
n
n
(2) (n)
(n)
(al) )
(3) If gcd(m .n) = 1 . then (nan) (rn) = (n) .
(4) (n)
= (-1)(-1)/2 .
(6) If gcd(na, n) = 1 . then
Example 1 .6 .28 . Evaluate the Legendre sy
(83)
(83~
by (1 .282)
by (1 .284)
by (1 .285)
by (1.281 )
(83}
83
(83 )
(83
2
)
= 1
by (1.286) .
Example 1 .6.29. Evaluate the Legendre sy
46
rbol
997
997) ( 9 7
)
23
997
997
23
/ 8
23
(22 . 2)
23
2
23
( 46 )
997
by (1 .284)
by (1.286)
by (1.287)
by (1.282)
by (1 .284)
by (1 .283)
4
= -1
by (1.286) .
It follows that the quadratic congruence 46 - -' (mod 997) is not soluble .
Gauss's quadratic reciprocity law enables us to evaluate the values o f
Legendre symbols Cad
very quickly. provided a is a prime or a product of
p
primes. and p is an odd prime . However, when o is a composite. we must
factor it into its prime decomposition form in order to use Gauss's quadrati c
reciprocity law . Unfortunately. there is no efficient algorithm so far for prime
decomposition (see Chapter 2 for more information) . One way to overcom e
the difficulty of factoring a is to introduce the following Jacobi symbol (in
Remark 1 .6 .14. It should be noted that the Jacobi symbol \a ) = 1 does
n
not imply that a is a quadratic residue modulo n . Indeed. a is a quadratic
Carl Gustav Jacobi (1804 18.51) was largely self-taught, learnin g
ids mathematics from the works of Euler and Lagrange . He entered
he University of Berlin in 1821 and obtained his PhD in 1825, with
a thesis on continued fractions. In 1826 he became a lecturer at
the University of Konigsberg and was appointed professor there in
831 . Jacobi is mainly known for his work in the theory of elliptic
coons and was not primarily a number theorist ; nevertheless ,
e made important contributions to number theory .

148
I . Elementary Number Theory
residue modulo n if and only if a is a. quadratic residue modulo p for each
2
prime divisor p of n.. For example. the Jacobi symbol
:3599= 1, but the
quadratic congruence x ' - 2 (mod 3599) is actually not soluble . This is the
significant difference between the Legendre symbol and the Jacobi symbol .
However. (-) = 1 does imply that a is a quadratic nonresidue modulo n.
For example, the Jacobi symbo l
( 35— 5 )
7
/
(
a )
71 /
and so we can conclude that 6 is a quadratic nonresidue modulo 35 . In sho
we have
{ 1
.
a E x2 (mod p) is soluble
-1,
a = x' (mod p) is not soluble .
(1.289)
1,
a E x2 (mod n) may or may not be soluble
-1,
a - x 2 (mod n) is not soluble .
Combining all the above results for Jacobi symbols, we get the followin g
set of formulas for evaluating Jacobi symbols :
n
1` =1
(1.290)
1
—r)/ 2
(1 .291)
a - b (mod n)		
> (a)
b
_
n
n
(1 .292)
ak'
(
) (a72) 
(a)
(1 .293)
(0.109r
t
(IV))
( a
(
)
forgcd(Inn ) = 1
(1 .294)
(2) = (
1)(,,'
)/s
(1 .295)
nt
1) (na -
- 1 )/ 7
(1 .296)
= (
n
(
n
m
Example 1.6.30 . Evaluate the Jacobi symbol
1 .6 Theory of Congruences
139
(563)
(563
2
(563)
by
(1 .293)
143
by
(1 .295)
563
X63
by
(1 .296)
143
('2 )
by
(1 .292 )
3'
143)
by
(1 .291 )
= -1
by
(1.294) .
It follows that the quadratic congruence 286 - x 2 (mod 563) is not soluble .
Example 1.6.31 . Evaluate the Jacobi symbol
230
1009
7
(2307)
(1009)
by
(1 .296)
289
by
(1 .292)
1009
(17'
1009)
by
(1 .293)
= 1
by
(1 .294) .
( 1009)
Although the Jacobi symbol 2307
1, we still cannot determine whether
or not the quadratic congruence 1009
x2 (mod 2307) is soluble .
Remark 1 .6.15 . Jacobi symbols can be used to facilitate the calculation o f
Legendre symbols. In fact . Legendre symbols can be eventually calculated by
Jacobi symbols [17] . That is .. the Legendre symbol can be calculated as if i t
335
were a Jacobi symbol. For example. consider the Legendre symbol 
2999
where 335 = .5 . 67 is not a prime (of course . 2999 is prime, otherwise. it is
not a Legendre symbol) . To evaluate this Legendre symbol . we first regard it
as a Jacobi symbol and evaluate it as if it were a Jacobi symbol (note that
once it is regarded as a Jacobi symbol, it does not matter whether or not 33 5
is prime: it even does not matter whether or not 2999 is prime . but anyway .
it is a Legendre symbol) .
(29
335
99)
335
( 3
—16
3 )
33.5
(a) =
rz
286 )
563
-1
=1 .
335

150
1 . Elementary Number Theory
335
Since 2999 is
1e' (2999
is a Legendre symbol. and so 355 is a quadrati c
p
residue modulo 2999 .
Example 1 .6.32 . In Table 1.19. we list the elements in (7Z/21Z)* and thei r
Jacobi symbols. Incidentally, exactly half of the Legendre and Jacobi symbol s
Table 1 .19. Jacobi Symbols for a E (Z/21Z)'
a e (Z/21z)' ®®~®®®®®
17 ®
20
1 ®®®©®®©®®®O
(
E
\ I©OE®EO®MIO®
1
©®m®~~®m®~
1
2 )
(a)
. (a) and
a
are equal to1andhalfequalto-1._llsoforthoseJacobi
3
7
2 1
symbols a1 = 1, exactly half of the a's are incleecl quadratic resiclues ,
whereas the other half are not. (Note that a is a quadratic residue of 21 if
and only if it is a quadratic residue of both 3 and 7 .) That is ,
a
1 .
for a E {1,4.10.13,16,19} = Q 3
( 3) — { -1,
for a E {2 .5 .8,11 .17, 20}
Q3
for aE{1 .2.4.8.11 .16}=Q 7
for a E {5.10,13.17.19.20} =
1 .6 .7 Orders and Primitive Roots
In this subsection. we introduce two very important and useful concepts i n
elementary number theory: orders and primitive roots. First let us give the
definition of the order of an integer modulo n .
1 .6 Theory of Congruences
15 1
Definition 1.6.17. Let n be a positive integer and a an integer such tha t
ged(a .n) = 1 . Then the order of a modulo n . denoted by ord„(a) or by
ord(a, n) . is the smallest integer r such that a'
E. 1 (mod n) .
Remark 1 .6 .16 . The terminology "the order of a modulo n" is the modern
algebraic term from group theory. The older terminology "a belongs to th e
exponent r" is the classical terns from number theory used by Gauss .
Example 1.6.33. In Table 1 .20, values of a' mod 11 for i = 1, 2, . -
.10 are
given. By Table 1.20, we get . e.g . .
ord ii (1) = 1
ord11 (2) = ord11 (6) = ordlt (7) = ord 11 (8) = 10
ordu(3) = ordrr(4) = ordrr(5) = ordu (9) = 5
ord i1 (10) = 2 .
Table 1 .20. Values of a ' mod 11, for 1 < < 1 1
a
r
a t o
1
1
1
1
1
1
1
1
1
1
2
4
8
10
9
7
3
6
1
3
9
5
4
1
3
9
5
4
1
4
5
9
3
1
4
5
9
3
1
5
3
4
9
1
5
3
4
9
1
6
3
7
9
10
5
8
4
2
1
i
2
3
10
4
6
9
8
1
8
9
6
4
10
3
2
5
7
1
9
4
3
5
1
9
4
3
5
1
10
1
10
1
10
1
10
1
10
1
Exercise 1 .6 .2 . What are the orders of 3.5 and 7 modulo 8 ?
We list in the following theorem some useful properties of the order of a n
integer a modulo to
Theorem 1 .6.31 . Let n be a positive integer, gcd(a., n) = 1, and r =
ord„(a) . Then
(1) If am .
1 (mod n)
h re nz is a positive integer, then r
rn .
(2) r 0(n).
(3) For integers .s and t, a s = a'. (mod n) if and only if s - t (mod r) .
(4) No two of the integers a, a', a3, -
. a' are congruent modulo r .
1
{
-1 .
for a E 12,8.10 .1 1. 3.191C Q21 .
for a E {1 .4.5,1617,20}
a E {5. 17.20} C Q2 1
aE{1.4,16}=Q3 i

152
1 . Elementary Number Theory
1 .6 Theory of Congruences
153
r
gcd(r.rn) 4
(5) If m is a positive integer, then the order of a'" modulo n
is
(6) The order of a"` modulo n is r if and only if gcd(nt, r) = 1 .
The following theorem shows an unexpected relationship between grou p
theory and number theory.
Theorem 1.6.32. If .r is an element of a group g, then the order of x divide s
the order of c .
Example 1 .6.34. Let g = (Z/917Z)' and = 17 . Then the order of g
is
= d(91) = 72, and the order of 17 modulo 91 is 6 . It is clear that 6
1 72.
Definition 1.6.18. Let n be a positive integer and a an integer such that
gcd(a,a.) = 1. If the order of an integer a modulo n is o(n), that is .
order(a, n)
o(n), then a is called a primitive root of n .
Example 1 .6.35 . Determine whether or not 7 is a primitive root of 45 . First
note that gcd(7, 45)
1 . Now observe that
7 1 - 7 (mod 45)
72 = 4 (mod 45 )
73 - 28 (mod 4 .5)
74 = 16 (mod 45 )
75 - 22 (mod 45)
76 - 19 (mod 45)
77 - 43 (mod 45)
78
31 (mod 45 )
79 - 37 (mod 45)
710 - 34 (mod 45 )
711 - 13 (mod 45)
712
1 (mod 45) .
Thus, ord48 (7) = 12 . However, ¢(45) = 24. That is. ord45 (7) ~ ¢(45). There-
fore, 7 is not a primitive root of 45.
Example 1.6.36. Determine whether or not 7 is a primitive root of 46 . First
note that gcd(7, 46) = 1. Now observe that
7 1 = 7 (mod 46)
72 = 3 (mod 46 )
73 - 21 (mod 46)
74 - 9 (mod 46 )
75 - 17 (mod 46)
76 - 27 (mod 46 )
7' - 5 (clod 46)
78 - 35 (mod 46 )
79 -15 (mod 46)
710 - 13 (mod 46 )
711 - 45 (mod 46)
712 = 39 (mod 46 )
717 = 43 (mod 46)
714 - 2.5 (mod 46)
715 - 37 (mod 46)
I fs = 29 (mod 46 )
717 E 19 (mod 46)
718 = 41 (mod 46 )
719 E 11 (1110d 46)
720 E 31 (mod 46 )
721 = 33 (mod 46)
722 = 1 (mod 46) .
Thus. ord46 (7) = 22. Note also that 0(46) = 22 . That is. ord .16;(7) = 0(46) =
22. Therefore 7 is a primitive root of 46 .
Exercise 1 .6 .3 . Show that 11 is a primitive root of 31 .
Exercise 1 .6 .4 . Find. by trial, the second smallest primitive root of 106 .
Theorem 1 .6 .33 (Primitive roots as residue system) . Suppose
gcd(g,n) = 1 . If g is a primitive root modulo n, then the set of integer s
{g , 92 , y3 , .
, 9"—1 } is a reduced system of residues modulo n .
. .
Example 1 .6 .37. Let n = 34. Then there are ¢(¢(34)) = 8 primitive roots
of 34, namely. 3 .5,7,11,23,27,29,31 . Now let g = .5 such that gcd(g, n) =
gcd(5, 34) = 1 . Then
oh1)
mod 34
= {5.25 .23.13.31,19,27,33.29.9,11,21,3,15,7,1 }
= {1.3 . .5.7.9.11 .13.15 .19,21,23,25.27.29.33.31 }
which forms a reduced system of residues modulo 34. We can, of course ,
choose g = 23 such that gcd(g, n) = gcd(23, 34) = 1 . Then we hav e
{9,92 . . . .
9900 1
= {23, 23 2, 233 , 23 9 , 235, 236 , 237 , 238 ,239 ,23'0 , 2311 .23'2 ,23 13 .2314 ,
2315 , 2316 } mod 34
= {23,19.29,21, 7 .25,31,33,11,15 .5.13.27.9,3,1 1
= {1,3.5,7.9.11,13,1 .5 .19.21,23.25,27,29.33,31 }
which again forms a reduced system of residues modulo 34.
Theorem 1 .6.34. If p is a prime number, then there exist 0(p— 1) (incon-
gruent) primitive roots modulo p .
Example 1 .6.38. Let p = 47, then there are ¢(47 — 1) = 22 primitive root s
modulo 47, namely,
.5
10
11
13
15
19
20
22
23
26
29
30
31
33
35
38
39
40
41
43
44
45
Note that no method is known for predicting what will be the smalles t
primitive root of a given prime p, nor is there much known about the dis-
tribution of the 0(p — 1) primitive roots among the least residues modulo
p .
Corollary 1 .6.8. If n. has a primitive root, then there are 0(¢(n)) (incon-
gruent) primitive roots modulo n .
Example 1.6 .39. Let n = 46, then there are 0(0(46)) = 10 primitive roots
modulo 46, namely .
5 7 11 15 1'l 19 21 33 37 43
Note that not all moduli n have primitive roots; in Table 1.21 we give the
smallest primitive root .g for 2 < n < 1017 that has primitive roots .
The following theorem establishes conditions for moduli to have primitiv e
roots :

154
1 . Elementary Number Theory
1 .6 Theory of Congruences
155
Table 1.21 . Primitive roots g modulo n (if any) for 1 < n < 1017
n
9
I7.
g
ii.
g
a
g
n
( 9
n
9
®®®
®®®
2 ®®®
3
18 ®
19
2
22 BM=
5 ®®®
7
27 ® 29 ®®
3
37
2
38 Ell
®
50
~®
5
58
59 ®®®
62
3
® 2
71 ®®®
74
5
79
3
8 1
82
7
83 ® 86 ®
89
3 ® 5
9Z
5
98 ®®® 103
5 ®
3 ®®®
6
113 ®
118
11
125
2
127
131 ®®
7
137
3
®®~®
®
142 ®®
149 ®®®®®
158
3
162
0 ®®
®®®®
169 ®®®
178 ®®®
181 ®®®®
5
197
2 W
U
®
5
211
2 ®®
218
11
223 ®®®
®
2
229 ® 233 ®
239 =®®
242 a
®®®®
3 ®
262
263
5
269
2
2®®®
3
0
278
281 ® 283 ® 289
3
293
2
298 ®
302
30
10
314
3
3
®
U
®H
21
367
373
2
379 ®
382
19
383
386 ® 389 ®®
3
397
5
398 ®®®
419 ®
421
2
422 ®®®®®
®®
443
2
3
449
3 ®®®®
458 ®
461
2 ®®®
3
467
2
478
7
®®
482 ®
486 ®
487
3 ®®
499
®
11 ®® 509 ®
514 ®
521 ®®
2
®
5
529
5
338 ®®®®
15
547
2
554
5
®®
3 ®®®®
569
3
®®®
5
578
3
586
3
587 ®®
3
599 7®
7
1 607 U®®
5
617
3
®® 622
UW
U
634
3
®® 643
11
647 ®
653
2
659 ®
661
2
® 3
673 ® 674 ®® 683
686
®® 698 a
701 ®
706 ®
709
2
718 7®®
727
5 ® 2 MIME
EMMEUMEBEE
713
5 ®®®®~
758
3
761 6®
0
®~®
X 7 8
3
787
2 ® 797
2
802
3
809
811
3
818
21
821
2
3
827
EMEBYAME.
838
1 1
839
I 1
811
2
842 ®
853
2
857
3
8559
2
862
7
863 ® 866 ®
87 7
2
1 878
1 ;5
881
3
883
2
886
5
887
5
898
IELIENIIBWN
2 EMI
3 ®
®®®
2 ®
2
953
3
958
13 ME=
®®®®®
977
3
982
991
997 U 998 U
1006
5 ®~
3
Theorem 1 .6 .35 . An integer n. > 1 has a primitive root modulo ii if and
only if'
n = 2. 4. p° . or 2p" .
(1.297)
where p is an odd prime and a is a positive integer .
Corollary 1 .6.9. If n = 2° with a > 3, or n
2'K
'TV with a > 2 or
k > 2. then there are no primitive roots modulo n .
Example 1 .6 .40. For n = 16 = 2 1 . since it is of the form n
2° with
t > 3, there are no primitive roots modulo 16 .
Although we know which numbers possess primitive roots . it is not a
simple matter to find these roots . Except for trial and error methods . very few
general techniques are known . Artin in 1927 made the following conjectur e
(Rose [210[) :
Conjecture 1.6.1 . Let V« (x) be the number of' primes less than x of which
a is a primitive root . and suppose a is not a square and is not equal to -1.
0 or 1 . Then
(1 .298)
®®
®
where A depends only on a .
Hoolev in 1967 showed that if the extended Riemann hypothesis is tru e
then so is Actin 's conjecture . It is also interesting to note that before the
age of computers Jacobi in 1839 listed all solutions {a . b} of the congruences
g°
b (mod p) where 1 < a < p. 1 < b < p. q is the leash positive primitive
root of p and p < 1000 .
1 .6.8 Indices and kth Power Residues
We shall now move on to the study of' the theory of index . and the kth power
residues .
The concept of index of an integer modulo n was first introduced by Gaus s
in his Disquisitiones Arithmeticae . Given an integer n, if a has primitive roo t
g . then the set
o(n )
,g
}
(1 .299)
forms a reduced system of residues modulo ra : g is a generator of the cycli c
group of the reduced residues modulo to (Clearly, the group (Z/nZ)* is cycli c
if n = 2 .4.p° . or 2p' . for p odd prime and a positive integer.) Hence. if
gcd(a, n) = 1 . then a can be expressed in the form :
a = y a (rnocl ri) (1.300)
for a suitable k with 1 < k < o(n) . This motivates our following definition
which is an analogue of the real base logarithm function .
Nu(x) — A In x

156
1 . Elementary Number Theory
1 .6 Theory of Cox ruences
15 7
Definition 1.6.19. Let. g be a primitive root of n . If gcd(a, n) = 1, then th e
smallest positive integer A . such that a - gk (mod n) is called the index of a
to the base g modulo n and is denoted by indy ,6 (a), or simply by indy a .
Clearly, by definition, we have
a E g'" °° (mod n) .
(1 .301)
The function indy a is sometimes called the discrete logarithm and is denoted
by logy a so that
a = gl°g 9
(mod n) .
(1 .302)
Generally. the discrete logarithm is a computationally intractable problem ;
no efficient algorithm has been found for computing discrete logarithms an d
hence it has important applications in public key cryptography. We shall dis-
cuss some modern computer algorithms for computing general discrete loga-
rithms (including elliptic curve analogues of discrete logarithms) in Chapte r
2 and applications of' the computational infeasibility of discrete logarithms in
cryptography in Chapter 3 .
Theorem 1 .6.36 (Index theorem) . If g is a primitive root modulo n, then
gT - g" (mod n) if and only if x = y (mod Q(n)) .
Proof. Suppose first that x y (mod 6(n)) . Then, x = y+k¢(n) for some
integer k . Therefore,
g
x
gY'kohz) (mod n)
gy . (gn(n))k (mod n)
gy - lk (mod n)
gy (mod n) .
The proof of the "only if" part of the theorem is left as an exercise .
q
The properties of the function indya are very similar to those of the con-
ventional real base logarithm function . as the following theorems indicate :
Theorem 1.6.37. Let g be a primitive root. modulo the prime p. and
gcd(a, p) = 1 . Then gk E a (mod p) if and only i f
k - indg a (mod p — 1) .
(1 .303)
Theorem 1 .6 .38. Let n be a positive integer with primitive root g. and
gcd(a, n) = gcd(b, n) = 1 . Then
(1) indg 1 - 0 (mod Q(n)) .
(2) indg (ab) - indya+indgb (mod Q(n)) .
(3) indg ak = A . . indya (mod Q(n)) . if k is a positive integer .
Example 1 .6 .41 . Compute the index of 15 base 6 modulo 109. that is.
6''001' mod 109 = 15. To find the index . we just successively perform th e
computation 6k (mod 109) for A. = 1, 2, 3, - -
until we find a suitable k such
that 6k (mod 109) = 15 :
6' E 36 (mod 109)
6 1 = 6 (mod 109)
63 - 107 (mod 109)
6' - 97 (mod 109)
65 - 37 (mod 109)
66 = 4 (mod 109)
6' - 24 (mod 109)
68 = 35 (mod 109)
69 - 101 (mod 109)
610 - 61 (mod 109 )
611 = 39 (mod 109)
6 1 - - 16 (mod 109 )
6 13 = 96 (mod 109)
61 `1 - 31 (mod 109)
6 15 = 77 (mod 109)
616 - 26 (mod 109 )
6 17
47 (mod 109)
618 - 64 (mod 109 )
619 = 57 (mod 109)
620 - 15 (mod 109) .
Since k = 20 is the smallest positive integer such that 6 20
15 (mod 109) ,
ind 615 mod 109 = 20 .
In what follows, we shall study the congruences of the form xk
a (mo d
n), where n. is an integer with primitive roots and gcd(a, n) = 1 . First of all ,
we present a definition, which is the generalization of quadratic residues .
Definition 1.6.20. Let a, n and k be positive integers with k > 2 . Suppose
gcd(a, n) = 1 . then a is called a kth (higher) power residue of n if there is an
x such that
.rk E a (mod n) .
(1.304)
The set of all kth (higher) power residues is denoted by K(k),, . If the congru-
ence has no solution, then a is called a kth (higher) power nonresidue of n .
The set of such a is denoted by K(k)g . For example, K(9),,6 would denote
the set of' the 9th power residues of 126. whereas K(5)3, the set of the 5th
power nonresidue of 31 .
Theorem 1 .6 .39 (kth power theorem) . Let n be a positive integer hav-
ing a primitive root . and suppose gcd(a, n) = 1 . Then the congruence (1 .304)
has a solution if and only if
go(wi g,d(k .o(,~)) = 1 (mod n).
(1 .305)
If (1 .304) is soluble, then it has exactly gcd(k .0(a)) incongruent solutions .
Proof. Let x be a. solution of .rk = a (mod n) . Since gcd(a, n) = 1.
gcd(I:. n) = 1 . Then
atel "
;c((k(u))
_
( rk)m(e)/ gcd(k,e
( .e(n))k/ gcd(k,e
1L:~ gcd(k.o(n) )
1 (mod n) .
s) )

158
1. Elementary Number Theory
1 .6 Theory of Congruences
159
(
Pa )k 0
.
(2) a E a l (mod p )
Conyerselc, if aV(»1/gcd(k.o(n))
(mod n) . then r(u'd''')o(rz)/gcd(k .o(n)) _
E 1
_
1 (mod n) . Since ord„r
o(aa),
o(n) 1
(ind,a)o(n)/gcd(k .0(n.)), and
hence d ind,.a because (ind,.a)/d must be an integer . Therefore, there are
gcd(k,0(n)) incongruent solutions to k(ind, .:r)
(ind,a.) (mod n) and hence
gcd(k. o(n)) incongruent solutions to .rk E a (mod n) .
If n is a prime number, say, p . then we have :
Corollary 1 .6 .10. Suppose p is prime and gcd(a, p) = 1 . Then a is a kth
power residue of p if and only if
r 1 (mod p). (1 .306)
Example 1 .6 .42 . Determine whether or not 5 is a sixth power of 31, that,
is, decide whether or not the congruenc e
6 E5(mod 31)
has a solution . First of all, we compute
5(31—1)/g8d(6,31 i) = 25
(mod 31 )
since 31 is prime. By Corollary 1.6.10.5 is not a. sixth power of 31 . That is ,
5 ' K(6)31 . However .
5(31—1)/ ged(7 . : -1) = 1 (mod 31) .
So. 5 is a seventh power of 31 . That is . 5 E K(7) 31 .
Exercise 1 .6.5. Determine whether or not 5 is a seventh power of 359. That
is. decide whether or not 5 E K(7)359 .
Exercise 1 .6 .6 . Find the complete set of incongruent 16th power residue s
of 512. That is, find all the as which satisfy a E K(16) :112 .
Now let us introduce a new symbol
C
(
—)
. the kth power residue symbol .
P
k
analogous to the Legendre symbol for quadratic residues (Ko and Sun . [125]) .
Definition 1 .6 .21 . Let p be a odd prime . k >
1, k p — 1 and q =
A
Then the symbol
(a k mod p (1 .307)
is called the k power residue symbol modulo p, where a9 mod p represent the
absolute smallest residue of a n modulo p (the complete set of the absolute
smallest residues modulo p are : (p — 1)/2, . - - . -1,0, 1 
(p
1/2)) .
Theorem 1.6.40. Let
be the kth power residue symbol . Then
P k
All the above congruences are modular 19 .
Exercise 1 .6 .7 (Research problem). Extend the Jacobi symbol for
quadratic residues to the kth power residues .
P/ k
a(P—1)l
d
I, - 1
(1)PI a
(3) For a l
a
P)A, — ~ cP) A
a J~a~ J
~ P k k ~ cP )
(4) indg ( E b (mod k) .0 < b < k —, C~) = g"" (mod p) .
P
k
(5) a is the kth power residue of p
a—
= 1 .
P
k
(6) n = Pl P2~
q
. . K' 
> (—
=
( Pi)
/ P2 )
P
k
P )h
vPA.
Example 1 .6.43. Let p = 19, k = 3 and q = 6. Then
(— 1
19
3
( 2
19
3
3
C 19
(19 )
0 19 ) 3
11
19) 3
13
19
3
C
-16l
(—1
(16)  
1
(
4
19 )3
19 /3
19
a
19/3
19)
24
.)
~19)
C 9
)
(9 )
(9)3
( .
(19) :3
\ 19 / 3 \19/ :3
/ 3 -
30
/
3
(5 `
19)
v 19 )3
19
3 v 19 1 3
2
(19 )
(
9)3
8 .
( 9 )3
19 )3 ~9)3
1 .
1
_
19
3 -1 .
E1 .

160
1 . Elementary Number Theory
1 .7 Arithmetic of Elliptic Curves
16 1
1 .7 Arithmetic of Elliptic Curve s
As long as algebra and geometry have been separated, their progress ha s
been slow and their uses limited: but when these two sciences have been
united, they have lent each other mutual forces, and have marched togethe r
towards perfection .
AUGUSTUS Dr: MORGAN
(1806__1871 )
Elliptic curves have been studied by number theorists for about a century :
not for applications in either mathematics or computing science but becaus e
of their intrinsic mathematical beauty and interest . In recent years . however.
elliptic curves have found applications in many areas of mathematics an d
computer science. For example, by using the theory of elliptic curves . Lenstra
[140] invented the powerful factoring method ECM . Atkin and Morain [12] de-
signed the practical elliptic curve prirnality proving algorithm ECPP . Koblitz
[126] and Miller [163] proposed the idea of elliptic public-key crvptosysterns ,
and more interestingly, Wiles proved the famous Fermat's Last Theore m
[254] . In this section. we shall provide some basic concepts and results o n
elliptic curves. In Chapter 2, we shall introduce some fast group operation s
on elliptic curves and algorithms for primality testing and factoring base d
on elliptic curves, and in Chapter 3, we shall introduce some applications o f
elliptic curves in cryptography .
1 .7.1 Basic Concepts of Elliptic Curve s
An elliptic curve is an algebraic curve given by a. cubic Diophantine equatio n
y2 = x's + ax + b.
(1 .308)
More general cubics in x and y can be reduced to this form, known as 'V eier-
strass normal form. by rational transformations. Two examples of elliptic
curves are shown in Figure 1 .11 (from left to right) . The graph on the left i s
the graph of a single equation. namely Er
:
y2 =
4x + 2 : even though
it breaks apart into two pieces . we refer to it as a single curve . The graph on
the right is given by the equation E,
:
y 2 = — 3x + 3. Note that an elliptic
curve is not an ellipse, it is so named because it is related to the length of the
perimeter of an ellipse; a more accurate name for an elliptic curve, in term s
of algebraic geometry, is an Abelian variety of dimension one. It should be
also noted that quadratic polynomial equations are fairly well understood b y
mathematicians today, but cubic equations still pose enough difficulties t o
be topics of current research . In what follows. we shall provide some more
formal definitions of elliptic curves .
Figure 1 .11. Two examples of elliptic curves
Definition
1 .7.1 . Let K be a field. Then the characteristic of the field IC is
0 if
1' 1+,
. .,a 1
it summand s
is never equal to 0 for any n > 1 . Otherwise, the characteristic of the field K
is the least positive integer n such that
Example 1 .7.1 . The fields 7G,
JR and C all have characteristic 0, wherea s
the field 7L /pZ is of characteristic p . where p is prime .
Definition 1 .7.2. Let K be a field (either the field Q, La, C. or the finite
field IEq with q = pn elements), and :r,3 + ax + b with a . b E K; be a cubic
polynomial. Then
(1) If K is a field of characteristic 2 .3 , then an elliptic curve over K is
the set of points (x. y) with x. y E K that satisfy the following cubi c
Diophantine equation :
E : yr
x' + ax + b .
(1 .309)
(where the cubic on the right-hand side has no multiple roots) together
with a single element, denoted by Or;, called the point at infinity .
(2) If K, is a field of characteristic 2, then an elliptic curve over K is th e
set of points (x, y) with x, y E K that satisfy one of the following cubi c
Diophantine equations :

162
1 . Elemeu vN fiber Theory
1 .7 Arithmetic of Elliptic Curves
16 3
E :
y-+cy= :r3 +ax+b .
E :
y2 +a-y=a' 3 +nx'+b .
(here we do not care whether or not the cubic on the right-hand side has
multiple roots) together with a point at infinity 0 E .
(3) If /C is a field of characteristic 3 . then an elliptic cur ve over is the set of
points (it, y) with x. y E K: that satisfy the cubic Diophantine equation :
E :
y23 +
2 +0+ c,
(1 .311 )
(where the cubic on the right.-hand side has no multiple roots) togethe r
with a point at infinity OE .
In this book, we shall not consider the elliptic curves over a field of char-
acteristic = 2 .3 . We are now moving on to the definition of the notion of a n
elliptic curve over the ring p /NZ, which are specifically useful in primality
testing. integer factorization and public key cryptography.
Definition 1 .7.3 . Let N be a positive integer with gcd( y', 6) = 1. An elliptic
curve over 7L/NZ is given by the following cubic Diophantine equation :
E : y
x3 +a.x+b .
(1 .312 )
where a, b E Z and gcd(N .
4(13 + 27b2) = 1 . The set of points on E is the
set of solutions in (Z/NZ)2 to the equation (1 .312), together with a point at
infinity OE .
Remark 1 .7.1 . The subject of elliptic curves is one of the jewels of 19th
century mathematics, originated by Abel. Gauss, Jacobi and Legendre . Con-
trary to popular opinion, an elliptic curve (i.e . . a nonsingular cubic curve )
is not an ellipse; as Niven, Zuckerman and Montgomery [174] remarked. it
is natural to express the arc length of an ellipse as an integral involving the
square root of a quartic polynomial. By making a rational change of vari-
ables . this may be reduced to an integral involving the square root of a cubi c
polynomial. In general, an integral invol ving the square root of a quartic o r
cubic polynomial is called an elliptic integral . So, the word elliptic actually
came from the theory of elliptic integrals of the form :
f R( Odd :
(1 .313)
where R(:r, y) is a rational function in .r and y, and y' is a polynomial in
:r of degree 3 or 4 having no repeated roots . Such integrals were intensivel y
studied in the 18th and 19th centuries . It is interesting to note that ellipti c
integrals serve as a motivation for the theory of elliptic functions, whils t
elliptic functions parameterize elliptic curves . It is not our intention here to
explain fully the theory of elliptic integrals and elliptic functions : intereste d
readers are suggested to consult some more advanced texts, such as Cohe n
[50], Lang [137], and McKean and Moll [153] for more information .
1 .7.2 Geometric Composition Laws of Elliptic Curve s
The basic operation on an elliptic curve E : y '- = x3 +aa'+b is the addition of
points on the curve . The geometric interpretation of addition of points on a n
elliptic curve is quite straightforward . Suppose E is an elliptic curve as shown
in Figure 1 .12 . A straight line (non vertical) L connecting points P and Q
intersects the elliptic curve E at a third point R. and the point P
Q is the
reflection of R in the X-axis. That is, if R = (.r : . m) . then P
Q = (a'3 . —ys )
is the reflection of R in the X-axis . Note that a vertical line . such as L ' or L" .
meets the curve at two points (not necessarily distinct) . and also at the point
at infinity OE (we may think of the point at infinity as lying far off in the
direction of the Y-axis) . The line at infinity meets the curve at. the point Or
three times. Of course. the non-vertical line meets the curve in three point s
in the XI'" plane . Thus. every line meets the curve in three points .
OE
Y
L'
TT=O
P 0Q+R=O 1
Figure 1.12. Geometric composition laws of an elliptic curve
L"
(1.310)
X

164
1. Elementary Number Theor y
As can be seen from Figure 1 .12 . an elliptic curve can have many ratio-
nal points: any straight line connecting two of them intersects a. third. The
point at infinity O E is the third point of intersection of any two points (no t
necessaril y, distinct) of a vertical line with the elliptic curve E . This makes
it possible to generate all rational points out of just a few .
The above observations lead naturally to the following geometric compo-
sition law of elliptic curves [229].
Theorem 1 .7.1 (Geometric composition law) . Let P, Q E E, L the line
connecting P and Q (tangent line to E if P = Q). and R the third point of
intersection of L with E . Let L' be the line connecting R and OE (the point at
infinity) . Then the point P1 Q is the third point on E such that L' intersects
E at R, OE and P+ Q .
1.7 Arithmetic of Elliptic Curves
165
y 1
1
xi
2
=a=- :rl- .r2= 2
Y3 = A ( :T 1
— 1? 2
So, P3 = P , P
( 113, ys) = (2, -5) .
Exercise 1.7.1. Find the points Pi + P2 and 2P1 on the elliptic curve
E :
y 2 = x 3 - 36x, where Pi = (-3.9) and P2 = (-2.8) .
Example 1 .7.3. Let P = (3,2) be a point on the elliptic curve E
:
x 3 - 2x - 3 over Z/7Z . Compute
Y2
x~2
= —b .
y2 =
10P = P
P +
+ P
(rood 7) .
10 summand s
1 .7.3 Algebraic Computation Laws for Elliptic Curves
The geometric composition law gives us a clear idea how two points on an
elliptic curve can be added together to find a third. However. to systematically
perform the additions of points on elliptic curves on a computer . we will need
an algebraic formula . The following result gives us a very convenient formul a
for computing points on an elliptic curve.
Theorem 1 .7 .2 (Algebraic computation law) . Let Pi = y1)
. P2 =
012,Y2) be points on the elliptic curve :
E :
:y2= x 3 +ax+b .
(1 .314)
then P 3 = (x3 , y3 )
PI +P2 on E may be computed b y
I OE ,
P1 :i P =
( O 3,y3) ,
where
and
3a' + a
A =
2y 1
yz — y]
x2— x i ,
Example 1 .7.2 . Let E be the elliptic curve y 2 = .r + 17 over Q' and let
P1 = (x1, y1) = (- 2.3) and P2 = (x2 ,p2)
(1/4, 33/8) be two points on E .
To find the third point P3 on E . we perform the following computation :
According to (1 .316), we have :
2P = P - P = (3, 2) s= (3, 2) _ (2, 6) ,
3P = P G 2P = (3,2)
(2,6) = (4, 2) .
4P = P + 3P = (3,2) > (4,2) = (0, 5) ,
5P = P
4P = (3, 2)
. (0, 5) _ (5 .0),.
6P = P G 5P = (3, 2)
(5,0) = (0, 2) .
7P=PT6P=(3,2)'-(0,2)=(4,5) ,
8P=P-7P=(3,2)
;(4,5)=(2,1) .
9P = P -- 8P = (3,2) e (2,1) = (3, 5) ,
l0P
P + 9P (3,2) , (3,5)
OE .
Example 1 .7 .4. Let E
:
y 2
= ;r3 + 17 be the elliptic curve over
ant
P = (-2,3) a point on E . Then
2P = (8, -23 )
9
522 )
3P = (?5' 122 5
4P
7 .
2 2
-;423 9
(529' 1216 7
5P = (174598
7694333 7
32761
5929741 /
6P
(4471631
-1955435709 7
3027600 ' 5268024000
/
7P = (1.2870778678
1160185427995887 )
7651 :001
66969221374 9
8P = -3705032916418
363519 0074 25360001 )
1556 248765009 191141566560243247 3
9P = (1508016107720305
- 185877 155 24311744}0537502 )
1146705139411225' 3883091 627056219156787 5
if x 1 - x2 & yl = -y 2
otherwise .
0' 3 . Y3) = (A2 - xl
)xl - r3) -m)
(1 .316)
if P1 =P2 .
(1 .315 )
(1 .317)
otherwise .

166
1. Elementary Number Theory
1.7 Arithmetic of Elliptic Curves
167
10P — ( . 1621479238320017368
412508081502523505109813257257 )
21550466481219504001
1 1000426099138845115 2511474399 9
(983864891 291087873382478
-1600181839303165170139037888610254293 )
11P — \ 415770822453576119856081
1
30769153204 053509350325905517943271
/
12P = ( 172770177945973356951996259 2 1
261632579225132155842970406236745469642671 9
4630688543838991376029953600
3151144181214267 2670439205364 1337633216000
Suppose now we are interested in measuring the size (or the height) of
points on an elliptic curve E . One way to do this is to look at the numerator
and denominator of the x-coordinates . If we write the coordinates of kP as
(Ak
Ck
kP —
B k ' D k
we may define the height of these points as follow s
H(kP) =max (I4k11
B k I) .
(1 .319)
For example, the values for various heights of points kP for k = 1,2,3, . , 38
on the elliptic curve E : y2
x3 – 7x + 10 for P = (1.2) are shown in Table
1.22 . It is interesting to note that for large k, the height of kP looks like
[230 :
D(H(kP))
0.1974k 2
(1.320)
H(kP)
100 .1971k2
(1,574) k2
(1 .321)
where D(H(kP)) denotes the number of digits in H(kP) .
Remark 1 .7.2 . To provide greater flexibility- . we may consider the following
more general form of elliptic curves :
E :
y2 =x3 +axe +bx+e .
.322)
In order for E to be an elliptic curve. it is necessary and sufficient that
D = a 2b 2 – 4a3 c – 41) 3 + l8abc – 27c2  O .
(1 .323)
Thus,
123(x 3, y3) = Pi (x11 y1)
P2 ( X2, y2) ,
811
on E may be computed by
(x31 y3) = (A2 – a xi
x>,
a(x i
r3) – y1)
(1.324) .
where
(3x + 2(i + b)/2y 1
,
if Pi = P2
(1.325)
(y2 — yl)/(x2 XI),
otherwise.
Exercise 1 .7.2 . Compute l0P on the elliptic curve E
: y2 = 3 13 — 7x + 10
with P = (1 .2) .
Table 1.22 . The height of points kP on y = x3 — 7x + 10 for P = (1, 2)
7 0
439
486 1
8831.
36412 1
1321559 1
14793856 9
1905671 771 6
75884514328 9
3199440044839 9
332883195948283 1
233184473054307329
10683181372399165448 1
1.2136575362948971796241 .
5436002 25189284171282984 9
1908909186516282262-1048485' 1
349837224996124067806820745129
6369 :1355054181537616729430239516 1
2803004647184009344981487597984864441.
1224829627942850195377997653151211774284 9
388989845)
61508954411 15949832933 305295 1
216567609001765950181219762286409 :5385794183003 9
1069741124 )074133163 8690096308 3537181 .5981155860 9
189 7024883
:0835)8660 37845914423814'6660011 875194239 1
;409713390180 .271992711 4336288454678093891x1 123647600 9
481000715264511935492147006
5436R
81502188 76 .0
)173 536183 . .33 1
28538527030802388558747693790983815044208310156&19186288079981552 1
_489095913 31461128 0 (89947063 1818 7339511
3 ,56781188
8_7.587149 6
4 304+0939 1848404 3 103 80f 16 :3303
3122 2811366 J 051
3
1000 903 8 608 1
80091739901_0_ 02492704
83 , ,.001(5(11 3832274 047_4 .581 290 .3108926707 11331311 9
4339 .58591
10855 78432 3 068 1 794789/
t -.22640578 1 7171090720 00634221605238 744830711611 9
2203153780792594371 .8488796231476710871 .035783371077385889402022838896530075204571531603209
4694807034_19515435331 00863797031324049113941130392063 4970) 37622 13593556340403422120973428 9
39468745844039759722170729306852089133304602538429927422166687574215220106133898790146616007838212 1
(1.318)

168
1 . Elementary Number Theory
1.7 Arithmetic of Elliptic Curves
169
1 .7.4 Group Laws on Elliptic Curves
The points on an elliptic curve form an Abelian group with addition of point s
as the binary operation on the group . In this subsection . we shall study some
group-theoretic properties of elliptic curves .
Theorem 1 .7.3 (Group laws on elliptic curves) . The geometric com-
position laws of elliptic curves have the following group-theoretic properties :
(1) If a line L intersects E at the (not. necessary distinct) points P. Q, R,
then
(P (2)• ;R=C~1
.
(2) P . . OE = P. VP E E .
(3) P
Q= Q P, VP. Q E E .
(4) Let P E E . then there is a point of E, denoted
. P . such that
P ., ()P) = OE .
(5) Let P, Q, R C E. then
(P .i Q) + R = P , (Q R) .
In other words. the geometric composition law makes E into an Abelian grou p
with identity element O E. Moreover. if E is defined over a. field K. then
E(r) = {(x . y) E
: y2 = x3 + ax + b} U {OE} .
is a. subgroup of E.
Example 1 .7.5 . Let E(Q) be the set of rational points on E . Then E(Q)
with the addition operation defined on it forms an Abelian group .
We shall now introduce the important concept of the order of a point o n
E .
Definition 1 .7.4. Let P be an element of the set E(Q)) . Then P is said t o
have order k if
kP =P
P ;• . .- . p
k summand s
with k'P  OE for all 1 < k' < k (that is, k is the smallest integer such tha t
kP = OE) . If such a. k exists, then P is said to have finite order. otherwise_
it has infinite order.
Example 1 .7.6 . Let P = (3 .2) be a point on the elliptic curve E : y' =
c3 — 2x — 3 over Z/7.Z (see Example 1 .7 .3) . Since 10P = Cc and kP ~ CE
for k < 10, P has order 10 .
Example 1 .7.7. Let P = (—2.3) be a point on the elliptic curve E : y2 =-
x3 + 17 over Q (see Example 1.7.4) . Then P apparently has infinite order .
1 .7.5 Number of Points on Elliptic Curves
As mentioned in the previous subsection . it is possible to generate all rational
points of an elliptic curve out of just a few . In this subsection, we shall b e
concerned with the problem : How many points (rational or integral) are there
on an elliptic carve? Let us first look at an example :
Example 1 .7.8. Let E be the elliptic curve p22 = x3 + 3x over ]F5 . then
OE . (0, 0), (1. 2), (1 .3) . (2 , 2) .
(2 , 3) . (3,1) . (3.4) . (4,1), (4,4 )
are the 10 points on E . However, the elliptic curve y'= = 3x3 + 2x over ]F;; has
only two points :
OE, (0.0) .
Exercise 1 .7.3. Find the number of points on the following el
over 1Fr3
(1)Er
:
y' = x3 + 2x + 1,
(2)E2 : y2 = x3 + 4x .
How many points are there on an elliptic curve E :
y2 = x3 -
Fr ? The following theorem answers this question :
Theorem 1 .7.4. There are
=1+p+ e
era,
points on E
:
g2 = x3 + ax + b, including the point at in 'nit
/x3 +ax+b
p
\
P
The quantity e in (1 .326) is given in the following theorem . due to Hasse35
in 1933:
Theorem 1 .7.5 (Hasse) .
(e~ < 2
.
(1.327)
Example 1 .7 .9 . Let p = 5, then H < 4. Hence, we have between 2 and 10
points on an elliptic curve over F5 . In fact, all the possibilities occur in th e
following elliptic curves given in Table 1 .23.
35
Helmut Hasse (1898–1979) was born in Kassel. Germany. He was
educated in Gottingen and Marburg. and subsequently worke d
in Kiel . Halle. Marburg, and Gottingen . In
1922 Hasse was ap-
pointed a lecturer at the University of Kiel. then three years later
he was appointed professor at Halle, and in 1930 he was appointed
a chair in Marburg . Hasse made significant contributions to the
theory of elliptic curves: for example, he proved, among others ,
the analogue of the Riemann Hypothesis for zeta functions of el -
liptic curves. Note that Hasse also wrote a very influential book in number theory ,
ZAHLENTHEORIE in 1963 . English translation in 1980 .
1+p+
C
x j + ax + b
ptic. curves
ax + b over
(1.326)
OE , where
is the Legendre symbol .

170
1 . Element
v Number Theory
1.8 Bibliographic Notes and Further Reading
171
Table 1 .23. Number of points on elliptic curves over
WM= Number of points
9 8 = 1' 3 +2:r'
2
y'-= .r3+4:r+2
3
Y = = .T3 + :r
4
yf-' = ar3 + 3r + 2
5
y ' = :1 3 + 1
6
y; =r3 +2x+1
1
y' = :r 3 + 4x
8
y' =~ 3 + T+1
9
y' = .r 3 +3.r
10
A more general question is : how many rational points are there on an
elliptic curve E
:
y 2 = .r' + ax + b over ? Mordell3t solved this problem
in 1922 :
Theorem 1 .7.6 (Mordell's finite basis theorem) . Suppose that the cu-
bic polynomial f (:r, y) has rational coefficients, and that the equatio n
f (x. y) = 0 defines an elliptic curve E. Then the group E(Q) of rational
points on E is a finitely generated Abelian group .
In elementary language, this says that on any elliptic curve that contains
a rational point, there exists a finite collection of rational points such that
all other rational points can be generated by using the chord-and-tangen t
method. From a group-theoretic point of view, Mordell's theorem tells u s
that we can produce all of the rational points on E by starting from some
finite set and using the group laws . It should be noted that for some cubi c
curves. we have tools to find this generating set . but unfortunately . there is
no general method (i .e., algorithm) guaranteed to work for all cubic curves .
Louis Joel Mordell (1888–1972) was born in Philadelphia, Penn-
sylvania. He was educated at Cambridge and began research i n
number theory. He lectured at Manchester College of Technology
from 1920 to 1922 . During this time he discovered the famous finite
basis theorem. which was suggested by POincarS in 1901 . In 1922 he
moved to the University of Manchester where he remained unti l
he succeeded Hardy at Cambridge in 1945 . Together with Dav-
enport . he initiated great advances of the geometry of numbers .
Mordell was elected Fellow of the Royal Society and received the De Morgan Meda l
in 1941 and the Sylvester Medal in 1949 . He was also the President of the Londo n
Mathematical Society from 1943 to 1945 .
The fact that the Abelian group is finitely generated means that it consist s
of a finite "torsion subgroup" E t(,rs , consisting of the rational points of finite
order. plus the subgroup generated by a finite number of points of infinit e
order :
E(
) ti Et,.
z. ''
The number r of generators needed for the infinite part is called the rank
of E(Q): it is zero if and only if the entire group of rational points is finite .
The study of the rank r and other features of the group of points on a n
elliptic curve over Q is related to many interesting problems in number theor y
and arithmetic algebraic geometry, readers are suggested to consult . e .g . ,
Silverman and Tate's book [228] for more information .
1 .8 Bibliographic Notes and Further Reading
Elementary number theory is the oldest but it is still a lively subject in num-
ber theory: it is the basis for other branches of number theory. including
algebraic number theory, geometric number theory, analytic number theory .
logic number theory. probabilistic number theory_ combinatorial number the-
ory. algorithmic number theory. and applied number theory. hr this chapter,
we have provided a survey of basic concepts and results of elementary num-
ber theory. For those who desire a more detailed exposition in elementar y
number theory, the following classical texts are highly recommend (in order) :
Hardy and Wright [100] . Niven et al . [174], Davenport [58], Baker [l7] . Hua
[105] . and Dirichlet [68] . Other good references in elementary number theor y
include Anderson and Bell [8] . Koblitz [128] . Kumanduri and Romero [135] ,
Mollin [164]. Nathanson [172] . Rose [210], Rosen [211]. and Silverman [230] .
The books by Ore [181] and Dickson [65] contain a wealthy source of the his-
torical development of the subject. whilst Ribenboim [200] contains the new
records (up to 1996) of research in number theory, particularly in the theor y
of prime numbers . Khinchin's book [119] gives an excellent introduction t o
continued fractions .
One of the important features of' this chapter is that we have provide d
a rather lengthy section on the distribution of prime numbers . It includes
approximations to rr(.r) by ln
. Li(.r) . and R(.r) . It also contains a discussion
of the Riemann c-function and relationships between the distribution of th e
complex zeros of (s) and the distribution of prime numbers. The study o f
the real function ( .r) and its various approximations belongs to the field o f
Analytic Number Theory. This particular domain of number theory operate s
with very advanced methods of calculus and it is considered to be one of th e
most difficult fields of mathematics . Readers who are interested in Analytic
Number Theory are referred to Apostol 's book [11] or to the Open University
text. [180] .

172
1 . Elementary Number Theory
Another very important feature of this chapter is that we have provide d
a section on an introduction to elliptic curves. The study of elliptic curve s
belongs to the field of algebraic geometry, or more specifically Diophantine
geometry. because we are essentially only interested in the integral or rational
solutions of certain types of algebraic equations represented by elliptic curves .
Elliptic curve theory is a rich and well studied area, with a wide range of re-
sults, including Wiles' proof of Fermat's Last Theorem . Remarkably enough .
the theory of elliptic curves is not only applicable to mathematics, but als o
applicable to computing science, including primality testing . integer factor-
ization and cryptography. For those who desire a more detailed exposition
of elliptic curves, please refer to the following more comprehensive texts :
Husemoeller [109] . Koblitz [127], Silverman [229]. and Silverman and Tate
[228] .
Number theory is intimately connected with abstract algebra, particularly
with the theory of groups, rings and fields . In fact, number theory can be
studied from an algebraic point of view . For this reason, much of the materia l
in this chapter is presented in terms of algebraic language . Hence, readers
may find it helpful to consult one of the following algebra books : Childs [49] ,
Ellis [70] . Fraleigh [76] . Herstein [103], Hungerford [108], McEliece [152] . or
Rotman [212] .
2. Computational/Algorithmic Number
Theory
The problem of distinguishing prime numbers from composite, and of re -
solving composite numbers into their prime factors, is one of the mos t
important and useful in all arithmetic .
. . . The dignity of science seems
to demand that every aid to the solution of such an elegant and celebrate d
problem be zealously cultivated .
C . F . GAUSS (1 777 1855)
Computational and algorithmic number theory are two very closely re-
lated subjects; they are both concerned with. among many others . com-
puter algorithms, particularly efficient algorithms (including parallel and dis-
tributed algorithms, sometimes also including computer architectures), fo r
solving different sorts of problems in number theory and in other areas, in-
cluding computing and cryptography. Primality testing, integer factorizatio n
and discrete logarithms are . amongst many others, the most interesting, dif-
ficult and useful problems in number theory, computing and cryptography .
In this chapter, we shall study both computational and algorithmic aspects
of number theory. More specifically, we shall study various algorithms for
primality testing, integer factorization and discrete logarithms that are par-
ticularly applicable and useful in computing and cryptography, as well a s
methods for many other problems in number theory. such as the Goldbac h
conjecture and the odd perfect number problem .
2.1 Introductio n
In this section, we shall first present a brief introduction to algorithmic an d
computational number theory, and then provide a theoretical foundation of
algorithms, including effective computability and computational complexity.
which are useful in both algorithmic and computational number theory.

2.1 .1 What is Computational/Algorithmic Number Theory ?
Algorithmic number theory studies of algorithms (including parallel algo-
rithms. sometimes also including computing architectures) for problems that
arise in number theory. Primality testing. integer factorization, and discret e
logarithms (including elliptic curve discrete logarithms) are, amongst man y
others, the most interesting . difficult and useful problems in number theory .
Computational number theory-, however, studies problems from elementary-,
algebraic geometric and analytic number theory which require the help of
fast computers (particularly vector and parallel systems) and fast algorithm s
(particularly deterministic polynomial-time algorithms) . It is clear that thes e
two subjects are closely related each other; some people may well regard the m
as one single subject which belongs to both mathematics and computer sci-
ence. whereas others may regard algorithmic number theory as a. part of
computer science and computational number theory a part of mathematics .
In this chapter, we shall study both algorithmic and computational aspect s
of number theory.
Computational (or algorithmic) number theory is a relatively new branc h
of science. which has become a discipline in its own right during the past tw o
decades. hi computational (or algorithmic) number theory, all the problems
studied are from number theory, but the methods for solving these problem s
call be either from mathematics, or computer science, or both . This makes
computational number theory different from other branches of number the-
ory such as algebraic number theory which uses algebraic methods to solv e
number-theoretic problems. Thus, computational (or algorithmic) number
theory is an interdisciplinary subject of number theory and computer science .
and the people working in this area. often come from either mathematics o r
computer science. Its main purpose is to design efficient . computer algorithms
(and sometimes high-speed computer architectures) for large-scale numerica l
computations (including verifications) for number theory. Among its wid e
spectrum of activities, this new branch of number theory is concerned wit h
problems such as the following :
(1) Primality testing: The fastest deterministic algorithm for primality test-
ing is the APRCL algorithm (see Adlennan, Pomerance and Rumely [3] .
and Cohen [50]) . invented by Adleman, Pomerance. Rumely. Cohen and
Lenstra, which runs in O(logN)` logiOglog .y and is possible to prove th e
primality of integers with 1000 digits in a not too unreasonable amoun t
of time. At present . the most practical primality testing/proving algo-
rithm is the elliptic curve primality proving algorithm ECPP_ designed
by Atkin and \Iorain [12] . which can prove the primality of integers with
several thousand digits in reasonable amount of time. for example, week s
of workstation time _
(2) hnteger factorization : The fastest general algorithm for integer factoriza-
tion is the Numher Field Sieve (NES), which under plausible assumption s
174
2. Compntat onal/ Algori hmic Number Theory
2 .1 Introduction
175
has the expected unning ti
e
O (exp (c /log _\ /(log log N) = )) .
Cleary-. NFS is still a subexponential-time algorithm, not a polynomial -
time algorithm . The largest integer factored with NFS is the RSA-13 3
(August. 1999) . an integer with 155 digits .
(3) Discrete logarithms : over a finite field : This discrete logarithm prob-
lem (DLP) for the multiplicative group IFS is similar to that of integer
factorization (although it is a little bit more difficult than integer fac-
torization) . and the methods for factoring (e .g . . Number Field Sieve) ar e
usually applicable to discrete logarithms . It should be noted, however ,
that there are quantum algorithms [227] that can be used to solve th e
integer factorization problem and the discrete logarithm problem in poly-
nomial time on a quantum computer . although no one knows at present.
whether or not a practical quantum computer can be built .
(4) Elliptic curve discrete logarithms : Let E/FF, be an elliptic curve defined
over a finite field, and let P. Q E E(IF1,) be two points on E . The ellip-
tic curve discrete logarithm problem (ECDLP) asks to find an intege r
k such that Q = kP in E(I F,) . This problem is considered to be very
difficult to solve if p is large, for w hick reason it has formed the basis for
various cryptographic systems. Note that there are subexponential com-
plexity Inde:c Calculus algorithms such as the Number Field Sieve for
discrete logarithms over a finite field . however . no practical Index Cal-
culus method has been found for the Elliptic curve discrete logarithms ,
and more serious, it looks like that ECDLP does not admit an Index
Calculus. Current research in ECDLP aims to develop new algorithm s
such as Xedni Calculus [231] that might be used to solve the ECDLP .
(5) Counting the numbers of primes, 7r(a) : The most recent record
is r(4 . 1022 ) = 783964159852157952242. that is. there are exactly
783963159852157952242 prime numbers up to 4 , 10 22 .
(6) Mersenne primes : There are now 39 known Mersenne primes. The largest
is 2'246691 ` — 1 : it has 4053946 digits and was discovered by Cameron .
W'oltanan and Kurowski, et al . in 2001 . At present . we still do not know
if there are infinitely many Alersenne primes .
(7) Odd perfect numbers: Even perfect numbers are in one-to-one correspon-
dence with Mersenne primes . That is, once we find a Mersenne prime
2 1' — 1, we have an even perfect number 2n'7 1 (2 1' — 1) . All the known
perfect numbers are even; we do not know if there exists an odd perfec t
number. Numerical results show that there are no odd perfect number s
up to 10300 (Brent, Cohen and Te Riele, [39]) .
(8) Fermat numbers: Only the first five Fermat numbers (i .e.. F„ = 22" + 1
for n = 0. 1, 2, 3, 4) have been found prime, all the rest are either com-
posite. or their primality is unknown . The complete prune factorizations

176
2 . Computational/Algorithmic Number Theory
2 .1 Introduction
for F,, with 5 < n < 11 have been obtained : the smallest not completely
factored Fermat number . and indeed the most wanted number, is F1 2 .
(9) Amicable numbers: The first amicable pair (220 .284) was known to the
legendary Pythagoras 2500 years ago . but the second smallest amicable
pair (1184 .1210) was not found until 1866 by a 16-year old Italian school
boy. Nicolo Paganini . Prior to Euler (1707-1783) . only three amicable
pairs were known. Although there are 2574378 known amicable pairs at
present. we still do not. know if there are infinitely many amicable pair s
or not: we even do not have a general rule to generate all the amicabl e
pairs .
(10) Riernann Hypothesis: The first 1,500,000,001 nontrivial zeros of the
R.iemann (-function have been calculated, and they all lie on the critica l
line Re(s) = 1/2. as conjectured by Riernann in 1859 . However, we do
not know if all the nontrivial zeros of the (-function lie on the critica l
line Re(s) = 1/2, On 24 May 2000 the Clay Mathematics Institute of
Cambridge . Massachusetts announced seven Millennium Prize Problems ;
The Riernann Hypothesis is one of these . It designated a one-million U S
dollar prize fund for the solution to each of these seven problems. (For
an official description of the problem . see [29] .)
(11) Goldbach's conjecture: It has been numerically verified that Goldbach's
conjecture is true for even numbers 4 < n < 4 . 1011 (see Deshouillers, Te
Riele and Saouter [62], and Richstein [201]) . The experimental results are
in good agreement with the theoretical prediction made by Hardy and
Littlewood. On 20 March 2000 the British publishing company Faber an d
Faber in London announced a one-million US dollar prize to any person
who can prove Goldbach's Conjecture within the next two years (befor e
midnight. 15 March 2002) .
(12) Calculation of r: By using an analytic extension of a formula of Ra-
manujan . David and Gregory Chudnovsky in 1989 calculated it to one
billion decimal digits. It is interesting to note that the string of digit s
1234.56789 occurs shortly after the half-billionth digit .
(13) Waring's Problem: In 1770 the English mathematician Edward Warin g
conjectured that every integer can be written as the sum of g(k) positiv e
kth powers . where g(k) = q + 2k — 2 with 3k = q
2k + r . It is currently
known that
g (2) = 4 , g(3) = 9•. g (4) = 19.g(5) = 37
for 6 < k < 471600000 .
(14) Primes in arithmetic progressions : An arithmetic progression of prime s
is a sequence of primes where each is the same amount more than the
one before. For example. the sequence .5 . 11, 17, 23 and 29 forms an
arithmetic progression of primes . since all the numbers in the sequence
are prhne, and the common difference is 6 . It is conjectured that there
should be arbitrarily long arithmetic progressions of primes, but no proo f
has been given so far . The longest known arithmetic progression contains
22 terms . The first terra is 11410337850553 and the common differenc e
is 4609098694200 . This sequence of primes was discovered in March 199 3
at Griffith University. Queensland. Australia .
As can be seen, the main theme in computational number theory is algo-
rithms. In the next two subsections, we shall provide a theoretical foundatio n
of algorithms, including effective computability and computational complex-
ity .
2.1.2 Effective Computability
Algorithmic number theory emphasizes algorithmic aspects of number theory
and aims at the design of efficient algorithms for solving various number-
theoretic problems. But what is an algorithm'? Remarkably enough, the wor d
algorithm itself is interesting and has a very long history ; it comes from the
name of the Persian mathematician Abu Ja'far Muhammad ibn Musa al-
Khwarizmil . An algorithm may be defined as follows .
Definition 2 .1 .1 . An algorithm is a finite sequence of' well-described instruc-
tions with the following properties :
(1) There is no ambiguity in any instruction .
(2) After performing a particular instruction there is no ambiguity about
which instruction is to be performed next .
(3) The instruction to stop is always reached after the execution of a finit e
number of instructions .
An algorithm is also called an effective procedure, since all of the opera-
tions to be performed in the algorithm must be sufficiently basic that they
can in principle be done exactly and in a finite length of time by a . man us-
ing pencil and paper (Knuth [122]) . So. for us the two terms algorithm and
effective procedure are synonymous and we shall use them interchangeably .
Abu Ja'far Muhammad ibn Musa al-Khwarizmi (about 78 0
850) was born in an area not far from Baghdad . He wrote his
celebrated book Hisab al-jabr u-'al-mugabala (from which our
modern word algebra comes) while working as a scholar at the
House of Wisdom (a center of study and research in the Islamic
world of the ninth century) in Baghdad . In addition to thi s
treatise. al-Khwarizmi wrote works on astronomy, on the Jewis h
calendar. and on the Hindu numeration system. The English
word algorithm derives from algorism, which is the Latin form
of al-Khwarizrni's name .
+2k -2.

178
2 . Computational/.algorithmic Number Theory
2.1 hitroduction
179
Definition 2 .1 .2 . A function f is computable (or equivalently, a problem i s
decidable/solvable) if there exists an effective procedure (or algorithm) . Af .
that produces the value of f correctly for each possible input : otherwise, the
function is called noncotnputable (or equivalently. the problem is undecid-
able/unsolvable).
Clearly, the notion here for computable functions is intuitive, but to show
that a function is computable or noncoinputable, we need a formalized notion
for effective computability : otherwise. we cannot show that an effective pro-
cedure does not exist for a function tinder consideration . This can be achieved
by an imaginary computing machine . named the Turing machine (TM) after
its inventor Alan Turing= , which can be defined as follows :
Definition 2.1.3. A (standard k-tape) Turing machine (TM), 31 (see Fig-
ure 2.1), is an algebraic system defined b y
~1I = (Q, r F, (5, go,
F)
(2.1)
Finite State
Control Unit
Read-AVote Head s
Tape I	
Tape ,
where
(1) Q is a finite set of internal states .
Alan M. Turing (1912 1954) was born in London, England . He
was educated in Sherborne. an English boarding school and King's
College. Cambridge. In 1935. Turing became fascinated with th e
decision problem, a problem posed by the great German math-
ematician David Hilbert, which asked whether there is a gen-
eral method that can be applied to any assertion to determin e
whether the assertion is true. The paper which made hint famous
On Computable Numbers, with an Application to the Entschei-
dungsproblem (problem of decidability )" was published in the Proceedings of the
London Mathematics Society. Vol 42, November 1936 . It was in this paper that he
proposed the very general computation model, now widely known as the Turing
machine, which can compute any computable function . The paper attracted imme-
diate attention and led to an invitation to Princeton (recommended by John vo n
Neumann), where he worked with Alonzo Church . He took his PhD there in 1938 ;
the subject of his thesis was "Systems of Logic based on Ordinals" . During Worl d
War II Turing also led the successful effort in Bletchley Park (then the British Gov-
ernment's Cryptography School in Milton Keynes) to crack the German "Enigm a"
cipher. which Nazi Germany used to communicate with the U-boats in the Nort h
Atlantic. To commemorate Turing's original contribution, the Association for Com -
puting Machinery- in the U .S.A. created the Turing Award in 1966 . The award is
presented annually to an individual selected for contributions of a technical natur e
to the computing community that are judged to be of lasting and major importanc e
to the field of computer science . and it is in fact regarded as the Nobel Prize of
computer science. Turing committed suicide in 1954 after a conviction related t o
his homosexuality. N5-ere it known that he had been a war hero (having deciphere d
Enigma) . the prosecution would never have taken place. and this great man migh t
still be alive today.
Tape Is
Figure 2 .1 . A standard Turing machin e
(2) L' is a finite set of symbols called the input alphabet. A~'e assume that
C F
{0} .
(3) F is a finite set of symbols called the tape alphabet.
(4) d is the transition function. which is defined by
(i) if' M is a deterministic Turing machine (DTI) . then
S : QxFt. -QxFt. x{L,R} t',
(2 .2)
(ii) if' 31 is a nondeterrninistic Turing machine (NDTM), the n
fi : Q x F t -4 2Qxr' -Lk RV'
(2 .3)
where L and R specify the movement of the read-write head left or
right. When k = 1 . it is just a standard one-tape Turing machine .
(5) 0 E F is a special symbol called the blank.
(6) go E Q is the initial state .
(7) F C Q is the set of final states.
A probabilistic Turing machine is a type of nondeterministic Turing ma -
chine with distinguished states called coin-tossing states . For each coin-
tossing state, the finite control unit specifies two possible legal next states .
The computation of a probabilistic Turing machine is deterministic excep t
that in coin tossing states the machine tosses an unbiased coin to decid e
between the two possible legal next states .

180
2 . Computations]/Algorithmic Number Theory
2.1 Introduction
18 1
The computation of a Turing machine is formalized by using the notio n
of an instantaneous description : Let ill be a Turing machine, then any strin g
ar . . .ak_Igra.I,ak+r . . .a,, . with o f E P and qi E Q . is an instantaneous descrip-
tion (ID) of AI . A move
a. -rgraliar+r ...a„ H ar . . .ak_rbg2al.+i . . .a„
(2.4)
is possible i f
A move
is possible if
d (gr, ax) = (g2,b,L) .
AI is said to halt, starting from some initial configuration ,riqif
x i qrx2 h yrgaay2
(2.8)
for any qj and a, for which 5(qj ,a) is undefined . The sequence of configura-
tions leading to a halt state is called a. computation. If 31 never halts, the n
we represent it by
xrq,x2 I- oc .
(2.9)
indicating that. starting from the initial configuration xrgix 2 , the machine
never halts. Thus, the Turing machine provides us with the simplest, pos-
sible abstract model of computation in general . Moreover, any effectively
computable function can be computed by a Turing machine, and there is no
effective procedure that a Turing machine cannot perform . This leads to th e
following famous Church-Turing thesis, named after Church' and Turing :
The Church-Turing thesis. A function is effectively computable
if it can be computed by a Turing machine . That is, computable is
Turing computable .
Alonzo Church (1903 1995) was born in Washington. D.C. Much
of his professional life was centered around Princeton University .
He received his first degree in 1924 and PhD in 1927, both from
Princeton. He was a National Research Fellow in 1927-29, spend-
ing time at Harvard . Gottingen and Amsterdam . Church was
a faculty member in Mathematics at Princeton University from
1929 until 1967 when he moved to the University of California at
Los Angeles . He made substantial contributions to the theory o f
computability including his solution to the decision problem, his invention of th e
lambda-calculus, and his statement known as the Church-Turing thesis . He also
supervised 31 doctoral students, including Alan Turing, Stephen Kleene, Marti n
Davis. Michael Rabin. Dana Scott and John Kemeny.
Remark 2.1 .1 . The Church-Turing thesis is a thesis, not a theorem. because
it is not a mathematical result and cannot be proved mathematically ; it just
asserts that a certain intuitive notion (effective procedure) corresponds to a
certain mathematical object (Turing machine) . To prove it, we would have
to compare effective procedures (an intuitive notion) and Turing machine s
(a formal notion) . To do this. we would have to formalize the notion of an
effective procedure . But. then we would face the problem : is the introduce d
formalization equivalent to the intuitive notion? The solution of this proble m
would require a claim to the Church-Turing thesis, and so we would fall int o
an endless loop. Hence, the Church-Turing thesis has to remain as a thesis .
not a theorem . Nevertheless, a tremendous amount of evidence has shown
that the Church-Turing thesis is true, and researchers in computer scienc e
and also in mathematics generally believe the truth of the thesis . It is theo-
retically possible. however, that the Church-Turing thesis could be disprove d
at some future date. if someone were to propose an alternative model of com-
putation that was provably capable of carrying out computations that cannot
be carried out by any Turing machine; but this is not likely to happen .
The Church-Turing thesis thus provides us with a very powerful tool t o
distinguish which functions are computable and which are noncomputable :
functions that can be computed by a Turing machine are computable, wherea s
functions that cannot be computed by a Turing machine are noncomputable .
We can therefore classify all computational problems into two categories :
(1) Class of problems solvable by a Turing machine .
(2) Class of problems unsolvable by a Turing machine .
There are many unsol vable problems : the best known one is surprisingly con-
cerned with the Turing machine itself : given a Turing machine 1I and an
input rig does AI halt on w7 This is the so-called halting problem for Turing
machines, and is unsolvable by a Turing machine . Of course, unsolvable prob-
lems do not only exist in the domain of Turing machines, but in virtually al l
fields of mathematics . It is not our purpose to discuss the uncomputabilit y
of Turing machines here : we shall restrict ourselves to Turing computability ,
particularly to practical Turing computability.
2 .1 .3 Computational Complexity
Effective computability studies theoretical computability. which does not im-
plyany restrictions concerning the efficiency of computations : efficiency is
often described in terms of complexity, which is essentially a measure of tim e
and memory space needed to perform a computation (in this book we shal l
treat complexity primarily in terms of time) . Effective computability does
not mean practical computability. In fact. many problems. although solvable
in theory, cannot be solved in any practical sense by a Turing machine du e
b(qL a ,) = ((h . b, R) .
(2.5 )
al . . .ak- rg i akak+ 7 . ..a.,, I- ai . . .g2ak_ l baa+a ...a,,
(2.6)

182
2. Computational/Algorithmic Number Theory
2.1 Introduction
183
to excessive time requirements. For example. using the Sieve of Eratosthenes
to find the nth prime. it is practical to compute the 10 1 °th prime. but it
would never become practical to find the 1070" -th prime . In this subsection .
we shall give a brief introduction to the theory of practically feasible com-
putation (practically feasible computation is also called practically tractable
computation: we shall use the two terms interchangeably) .
The time complexity (or the running time) of an algorithm is a function
of the length of the input . An algorithm is of time complexity t(n) if for all n
and all inputs of length n . the execution of the algorithm takes at most t(n)
steps. More precisely, we have :
Definition 2 .1 .4. Let TM be a Turing machine which halts after in steps
for an input of length n . Then the time complexity function or the running
time associated with TM, denoted by h im (ra) . is defined by
t 1- 1 (n) = max{1n : TM halts after 1n steps for an input of length O .
(2 .10)
Let NDTM be a nondeterministic Turing machine . For an input w we denote
by .s(w) the shortest halting computation starting from w. Then the time
complexity function associated with NDTM, denoted by tNDtnl . is defined b y
tNDTn1(a) = max{(1,na) : w is of length n and s(w) has ni steps} . (2 .11 )
Definition 2.1 .5. .A deterministic Turing machine (DTM) is called polyno-
mially bounded if there exists a polynomial function p(n) E 0(nt) . for some
positive integer k, such that
tD'ry1( ra) < p(aa),
(2.12)
where n is the length of the input. A problem is called polynomially solvable
if there is a polynomially bounded Turing machine that solves it . The class
of all polynomially solvable problems is denoted by P .
Definition 2.1.6 . A deterministic Turing machine (DIM) is called expo-
nentially bounded if there exists an exponential function exp(n) E 0(a" ) for
some constant a > 1 such tha t
tD'1 yt (n) < exp(n),
for all n .
(2 .13)
where n is the length of the input. A problem is called exponentially solvabl e
if there is an exponentially bounded Turing machine that solves it. The clas s
of all exponentially solvable problems is denoted by EXP .
Definition 2 .1 .7. A nondeterministic Turing machine (NDTM) is calle d
polynomially bounded if there exists a polynomial function p(n) E 0(n k ) ,
for some positive integer k, such that
t\DT\1(n) < p(n) .
(2 .14 )
where n is the length of the input . The class of all problems solvable by a
polynomial ly bounded nondeterministic Turing machine is denoted by
_ASP .
All different types of Turing machines . such as single-tape DT\l, mul-
titape DIM and NDTM are equivalent in computation power but may b e
different in efficiency. For example. let t(n) be a function with t(n) > n. Then
(1) Every t(n) time multitape deterministic Turing machine has an equiva-
lent 0(t-(a)) time single tape deterministic Turing machine .
(2) Every t(n) time single-tape nondeterministic Turing machine has a n
equivalent 2°r+
")i time single-tape deterministic Turing machine .
hn complexity theory, it is common to concentrate on decision problems .
i.e . . those having a yes/no solution . since any decision problem can be treate d
as a language recognition problem .
Definition 2 .1 .8 . An alphabet .L is a finite set of symbols . A language L
over L is any set of strings made up of symbols from L . We denote the
empty string by e. and the empty language by 0 . The language of all string s
over is denoted by E" . We also define the complement of L by L = 12* —L .
We say a Turing machine 31 accepts a string x E
17* if. given input .r . M
outputs M (x) = 1, and otherwise DI(x) = O .
Within the framework of formal language theory . the complexity classes
P, .,1-P and £XP defined above can then be re-defined as follows .
Definition 2.1 .9. The class P consists of all languages L that have a poly-
nomially bounded deterministic Turing machine (DIM), such that for any
string x C 17* .
a: EL
DTl1(z)=1 ,
x
L
DTM(x) = 0 .
The class £XP consists of all languages L that have an exponentially bounded
deterministic Turing machine DIM, such that for any string :v E * ,
a L
DT\I(.r) = O .
The class .VP consists of all languages L. that have a polynomially bounded
nondeterministic Turing machine (NDTM), such that for any string x E .L
.
a' E L
—
Ey E 17*, NDTM(x y) = 1,
where [yl is
bounded by a polynomial i r
L
>
fly E .17` . NDTM(x . y) = O .
For probabilistic Turing machines . we have the coilesponcling probabilis-
tic complexity classes R.P. BP- P . and 1FPP .
Definition 2 .1 .10 . The class 'RP (Randomized Polynomial) consists of al l
languages L that have a probabilistic Turing machine (PT\I) running i n
expected polynomial time with one-sided error . That is, for any input x E L

184
2 . Computational/Algoritlnnic Number Theory
2 .1 Introduction
18 5
J :r E L  
>
Prob[PTM(ar) = 1] > 1/2 .
.r L
Prob[PTM(.r) = 1] = O.
Definition 2 .1.11. The class 2PP (Zero-error Probabilistic Polynomial) i s
defined by 2PP = RPnco-RP. That is . 2PP is the class of all languages L
that have a probabilistic Turing machine (PTM) running in expected poly-
nomial time with zero sided error. That is, for any input .r E r* .
f :r E L
Prob[PTM(a) = 1] = O .
x L 
> Prob[PTM(r) = 1] = O .
Definition 2.1.12. The class BPP (Bounded-error Probabilistic Polyno-
mial) consists of all languages L that have a probabilistic Turing machin e
(PTM) running in expected polynomial time with two-sided error . That is .
for any input E Z* .
f :r E L
>
Prob[PTM(a) = 1] > 3/4 .
x
L  
>
Prob[PTM(x) = 1] < 1/4.
The space complexity classes 'P-SPACE and .VP-SPACE can be define d
analogously as P and A-'P . It is clear that a time class is included in th e
corresponding space class since one unit is needed to the space by one square .
Although it is not known whether co not P = A-P, it is known that P SPACE
= A'P SPACE. It is generally believed that
P C
PP CRP C
BPP
C P-SPACE C EXP .
Besides the proper inclusion P C EXP . it is not known whether any of the
other inclusions in the above hierarchy is proper . Note that the relationshi p
of BPP and A-'P is not known . although it is believed that AVP
BPP .
Remark 2.1 .2 . Although the complexity classes are defined in terms of de-
cision problems, they can be used to classify the complexity of a broader
class of problems, such as search or optimization problems . It should be als o
noted that complexity classes are not only referred to problems . but also t o
algorithms. For example, we can say that Euclid's algorithm is of polynomia l
complexity. since it can be performed in polynomial time, that is. Euclid's
algorithm is in P .
From a practical computability point of view. all algorithms can be classi -
fied into two categories :
(1) Efficient (good) algorithms : those algorithms that can be performed in
polynomial time .
(2) Inefficient (bad) algorithms: those algorithms that can only be performed
in exponential time.
The reason is fairly obvious: An exponential function grows much mor e
quickly than a polynomial function does for large values of n . Algorithms
of polynomial complexity are considerably more efficient than those of expo-
nential complexity. More generally, there is a hierarchy of increasing orders :
lognn .ii,
2'x.3" ,
Table 2.1 compares growth rates of complexity functions for different in -
put values of n, whereas Table 2 .2 compares execution times for algorithms
of various complexities [79] (we assume that each step of the algorithm take s
one microsecond of computer time to execute) .
By examining these tables . one can see that exponential and factorial
complexity functions grow faster than any polynomial functions when n i s
large. This gives us the idea that the running time of any practically feasibl e
computation must be bounded by a, polynomial in the length of the input,
and leads to the Cook-Karp thesis, a quantitative refinement of the Church -
Turing thesis . Similarly, all solvable problems can also be classified into tw o
categories :
(1) Computationally tractable (or feasible) .
(2) Computationally intractable (or infeasible) .
It is widely believed, although no proof has been given, that problems i n
P are computationally tractable, whereas problems not in (beyond) P are
Table 2.1 . Comparison of growth rates of complexity functions with input size s
Input
Size n
Complexity Function f
log n
n
n log n
nz
2
n !
5
2
5
12
25
32
120
10
3
10
33
100
1024
3.6 x 106
5x10
6
50
282
2500
1 .1x1015
3x106 1
102
7
100
664
10'
1 .3 x 10U0
9 .3 x 10157
5 x 102
9
500
4483
25 x 10'
3.3 x 10159
1 .2 x 1011'3
10'
10
10 3
9966
106
1.1 x 10301
4.0 x 10'6 7
10 '
13
10 1
132877
l0s
1.9 x 103010
2 .8 x 103'6'0
10 5
17
10
1 .6 x 10°
10
(too large)
I (too large)

186
2. Computational/Algorithmic Number Theory
2.1 Introduction
187
Table 2.2 . Comparison of several polynomial and exponential time complexit y
functions f
Input Size n
f
10
20
30
40
50
60
n
- 0 .00001
second
0 .00002
second
0.00003
second
0.00004
second
0.00005
second
0.00006
second
rz"
0.0001
second
0.0004
second
0.0009
second
0.0014
second
0.0025
second
0.0036
second
n'
0.001
second
0.008
second
0 .027
second
0 .064
second
0 .125
second
0.216
second
u'
0 .1
second
3 .2
seconds
24.3
seconds
1 . 7
minutes
5 . 2
minutes
13 .0
minutes
0.0 1
second
1 .0
second
17 .9
minutes
12 .7
days
35 .7
years
366
centuries
3 "
0.59
second
58
minutes
6 .5
years
3855
centuries
2.3 x 10"
centuries
1 .3 x tor'
centuries
5'
9 .8
seconds
3
years
3x10 `'
centuries
2.9 x 10 1 2
centuries
2.8x10
1 2
centuries
2.8 x 10 26
centuries
ni
3 .6
seconds
7.7x10
years
8.4x101 1
centuries
2.6x10 12
centuries
9.6x10 1"
centuries
2.6x1066
centuries
computationally intractable . This is the famous Cook-Karp Thesis, named
after Stephen Cook' and Richard Karp' :
Stephen Cook (1939- ) was born in Buffalo. New York. received
his BSc degree from the University of Michigan in 1961 . and his
PhD from Harvard University in 1966 . From 1966 to 1970 he was
Assistant Professor at the University of California, Berkeley. He
joined the faculty at the University of Toronto in 1970 as an Asso -
ciate Professor, and was promoted to Professor in 1975 and Uni-
versity Professor in 1985 . He is the author of over 50 researc h
papers, including his famous 1971 paper "The Complexity of The-
orem Proving Procedures" which introduced the theory- of .A' P-completeness . Cook
was the 1982 recipient of the Turing award, is a Fellow of the Royal Society o f
Canada. and a member of the U .S . National Academy of Sciences and the Ameri-
can Academy of Arts and Sciences. (Photo by courtesy of Prof. Cook.)
Richard M. Karp (193.5 ) earned his PhD in applied mathematic s
from Harvard University in 1959. He has been a researcher at the
IBM Thomas J . Watson Research Center in New York, and Profes-
sor of Computer Science in the University of California. Berkeley
and University of Washington, Seattle. He is currently professor a t
UC Berkeley. returning from Washington in June 1999 . Karp was
le 1985 Turing award winner for his fundamental contribution s
to complexity theory. which extended the earlier work of Stephe n
Cook in A'I'-completeness theory. He has been elected to membership of the U .S .
National Academy of Sciences and National Academy of Engineering . (Photo by
courtesy of Prof. Karp.)
The Cook-Karp thesis. A problem is said to he computationally
tractable (or computationally feasible) if it is in P ; a problem which i s
not in P is said to be computationally intractable (or computationally
infeasible) .
Whether or not P = .A-P is one of the most important open problems in bot h
computer science and mathematics, and in fact, it has been chosen to he on e
of the seven \Iillenniunr Prize Problems by the Clay _Mathematics Institute .
with one million US dollars prize for a proof or disproof of the problem (fo r
the official description of the problem see [52]) .
Example 2.1.1. The following two problems are computationally in -
tractable :
(1) The primality testing problem. The best deterministic algorithm to tes t
n for primality runs in time C) ((logn)`'hOgloglog " I ), which grows super -
polynomially in input length log n : we do not regard a superpoly_ nomial
as being a polynomial .
(2) The integer factorization problem. The best algorithm for factorin g
a general integer n runs in time O(exp((logn) 1/3 (loglogn) 2/3 ) . which
grows subexponentially (but superpolynomiaily) in input length log n .
How about problems in .A'P? Are all the problems in .1'P tractable?
Clearly. P is included in A -P . but it. is a celebrated open problem as to
whether or not P = A' P . However there are many A "P-complete problems ,
which are significantly harder than other problems in A'P . A specific problem
is X'P-complete if it is in _\'P and, moreover, it is P-hard 6. It thus follow s
that P = A'P if an A"" -complete problem is in P . It is generally conjec-
tured that P A-P . Therefore. .A'P complete problems are considered to be
intractable. Several hundred problems in mathematics, operations researc h
and computer science have been proven to be .A'P-complete . The following
are just some of them :
(1) The traveling salesman problem (TSP) : Given a complete graph G =
(1'. E). with edge costs. and an integer k . is there a simple cycle that
visits all vertices and has total cost < k ?
(2) The Hamiltonian Cycle Problem : Given a network of cities and road s
linking them . is there a route that starts and finishes at the same cit y
and visits every other city exactly once ?
6 A problem is A"P-hard if all problems in A'P are polynomial time rrducablc to
it, even though it may not be in A`P itself. A formal definition for this reductio n
s : for an arbitrary problem in A'P, there exists a polpnomially bounded deter-
ministic Turing machine that translates every instance of the arbitrary proble m
into all instance of the problem .

188
2 . Computational/Algol .hnnc Number Theory
2.1 Introduction
189
(3) The clique problem : A clique. in an undirected graph G = (I E) is a
subset C ' E I" of vertices, each pair of which is connected by an edge i n
E. The size m of a clique is the number of vertices it contains . The clique
problem is then : given a finite graph C = (I E) and positive integer
an <
does G have a clique of size m ?
(4) The binary partition problem : Given A = {a l . a2 ,
• .
a set of inte-
gers written in binary notation . is there a subset .-1' such that
a?
2EA- .1
(Note that if A is a set of integers written in unary notation, then it can
be decided in polynomial time .)
(5) The quadratic congruence problem : Given positive integers a, b and c, is
there a positive integer x < c such that x2
a (mod b)?
(6) The quadratic Diophantine equation problem: Given positive integers
a, b and c, are there positive integers x and y such that ax' + by =
(7) The subset-sum problem: Given a finite set S C N and a target t E N, is
there a subset S' C S whose elements suns to t?
The integer factorization problem, however, is currently thought to be in .'CP ,
not in P, but no one has yet proven that it must be in _1'P . The best referenc e
for computational intractability is still the book by Garey and Johnson [79] ,
although it is a little bit out. of date .
2 .1 .4 Complexity of Number-Theoretic Algorithms
As mentioned previously, the time complexity of an algorithm is a functio n
of the length of the input. If the input n is an integer. then its length is th e
number of bits in n :
length(n) = number of bits in n .
(2.15)
In computational number theory, the inputs are of course always integers .
and hence our input lengths (or sizes) will be the total number of bits neede d
to represent the inputs of the algorithms . and our running times for these al-
gorithms will count bit operations rather than arithmetic operations . Polyno-
mial time algorithms counted by arithmetic operations are essentially useles s
in computational number theory, because they will be of exponential time if
we count by bit operations . When we describe the number of bit operations
needed to perform an algorithm, we are describing the computational corn.-
plexity of this algorithm. In describing the number of bit operations neede d
to perform an algorithm, we will need some notations particularly the big- 0
Ilotation.
Definition 2 .1 .13 . Let f and
,q be positive real-valued functions . Then
(1) Big -0 notation (denotes the upper bound of the complexity function f) :
f(n) = C(g(n)) if there exists a real constant c > 0 such that f(n) <
c g(n) for all sufficiently large n .
(2) Small-a notation (denotes the upper bound of the complexity function
f. that is not asymptotically tight) : f(n) = C(g(n)),Vc > 0 such that
.f(n) < c .g (n) .
(3) Big-42 notation (denotes the low bound of the complexity function f) :
f(n) = f2(g(n)) if there exists a real constant c such that f (n) >
. y(n) .
(4) Big-(-J notation (denotes the tight bound of the complexity function f) :
f(n) = e(n) if H(n) = C(g(n)) and .f ( n) = P(g (n)) .
In this book, we shall mainly use the big-0 notation .
Example 2.1 .2. Let f (n) = n3 + 80 logn + 14n — 1. then with the big-0
notation, we have f (n) = 0(n 3) .
Definition 2.1.14. Given integers p. q and b with q = h' , then p is said to
be the logarithm to the base b of the number q . We shorten this to
p = loge q .
p=logbq
q=br" .
,
p = log2 q 4 q = 2r.
Symbolically,
If b = 2 then
Note that while base 10 is common in high school algebra and base e i s
typically used in calculus: in computer science logs are always assumed to b e
base 2. In this book, we shall use the notation log to mean log,, and In t o
mean log,, .
Any integer n E N to the base b can be written as follows :
=
(d3_1d,j_2
di do) ),
= (1 , _ 1 1r3 - 1 + d 3 -,b3-2 +
. . + d 1 b+do
0
d,b'.
(2 .19)
i=3— 1
where d; (i 3 — 1 . 3 — 2 .
. 1 .0) are digits . If d ;3_ 1  O . we call ra a 3-digit
base-b number . Clearly, any number b 3—r < a . < b'3 is a 3-digit number to
the base b. For example. 101 < 780214 < 10 o is a 6-digit number to the base
10. By Definition 2 .1 .14 . this gives the following formula for the number of
base-b digits for aa :
ntunber of digits of a = (Iog b of ± 1 =
(2 .16)
(2 .17)
(2 .18)
In n
(2.20)
in b_

190
2 . Computational/Algorithmic Number Theory
2 .1 Introduction
19 1
(The notation [x], where x is a real nmber. is defined to be the greates t
integer less than or equal to x and called the floor of :r,, whereas [x] is defined
to be the least integer greater than or equal to x and called the ceiling of .r .
The notation [:r] is also used for ]x] .) For example. let n = 999, then
the number of digits of 999
[log 10 999] + 1
L
in999
In 10
the number of bits of 999 = (log[ 999] + 1
It is easy to verify that 999 has 10 bits, since 999 = 1111100111 . Note tha t
the word bits is short for binary digits, and usually refers to Shannon bits, in
honour of the American scientist. Claude Shannon7 .
Exercise 2 .1 .1 . Find the number of digits and bits for the following num-
bers :
12 1 '"—1
5 1=8 + 1
11
2 . 257
In terms of the big-C) notation . (2.1.5) can be rewritten as
length(n) = ]log, n.] + 1 = 0(log n) .
(2 .21)
Claude E. Shannon (1916-2001) was a graduate of Michigan an d
went to MIT to write his PhD in Boolean algebra . where he re-
ceived his PhD in 1940. He joined Bell Telephones in 1941 remain -
ing until 1972 . He was also a Professor in Electrical Engineerin g
at MIT from 1958 to 1980, and has been Professor Emeritus ther e
ince 1980 . Shannon is the inventor of information theory, the first
to apply Boolean algebra to the design of circuits, and the first t o
use bits' to represent information . His paper "Communication
Theory of Secrecy Systems" , published in 1949 . is regarded as one of the very first
papers in modern secure communications .
Exercise 2.1 .2 . Estimate in terms of the big-0 notation the number of bits
in nl .
Now we are in a position to discuss the hit complexity of some basi c
arithmetic operations .
First let us look at the addition of two 3-bit binary integers . (If one of th e
two integers has fewer bits than the other, we just fill in zeros on the left .)
Consider the following example :
Clearly. we must repeat the following steps 3 times :
(1) Starting on the right, look at the top and bottom bits, and also a t
whether there is a carry above the top bit .
(2) If both bits are 0 and there is no carry. then put down 0 and move on .
(3) If either one of the following occurs
(i) both bits are 0 and there is a. carr y
(ii) only one of the bits is 0 and there is no carry
then put down 1 and move on .
(4) If either one of the following occurs
(i) both bits are 1 and there is no carr y
(ii) only one of the bits is 0 and there is a carry
then put down 0, put a carry on the next column . and move on .
(5) If both bits are 1 and there is a carry. then put down 1, put a carry o n
the next column. and move on .
Doing this procedure once is called a bit operation. So adding two 3-bit num-
bers requires 3 bit operations . That is .
T(3-bits + 3-bits) = O(3) = ((log n.) .
Next let us observe the multiplication of two 3-bit binary integers . Con-
sider the following example :
1110101100 1
x
0100011010 1
1110101100 1
1.110101100 1
1110101100 1
1110101100 1
+ 1110101100 1
10000001101110110110 1
+ 1
In 999
hr 2
[9 .964340868] + 1
=
9+1=10 .
+ 1
2 67
3 x67
2'11 — 1,
1110101100 0
[2.999565488] + 1
+
0100011010 1
2+1=3,
1001.10001101

192
2. Computational/Algorithmic
-Number Theory
2.1 Introduction
193
that is ,
11101011001 + 1110101100100 = 1001001011110 1
10010010111101 + 111010110010000 = 100110101001001101
100110101001001101 + 1110101100100000 = 1001101001001101
11000010101101101 + 11101011001000000000 = 100000011011101101101 .
and hence,
11101011001 1000110101 = 100000011011101101101 .
The result can easily be verified to be correct . since
111010110012 = 1881 .
10001101012 = 565 ,
1881 . 565 = 1062765 = 1000000110111011011012 .
The above example shows us that multiplying two 3-bit integers requires
at most 3- bit operations. That is ,
T(3 bits x ;3-bits) = 0(3 2 )
= 0(logn) 2 .
How fast can we multiply two integers? Earlier attempts at improvement s
employed simple algebraic identities and resulted in a reduction to the fol-
lowing:
Theorem 2 .1 .1 . There is an algorithm which can multiply two 3-bit inte-
gers in
T(3-bits x i3-bits) = C')(3Io523)
= C)(31 584962501 )
= 0(log 11)1 584962 .50 1
bit operations .
However. Schbnhage and Strassen in 1971 utilized some number-theoreti c
ideas and the Fast Fourier Transform (FFT) and obtained a much bette r
result :
Theorem 2.1.2. There is an algorithm which can multiply two 3-bit inte-
gers in
T(3 bits x 3-bits) = 0(3 log 3loglog .3)
= O(log n log log n log log log n )
bit operations .
Definition 2 .1 .15 . An algorithm is said to be of polynomial complexity8 ,
measured in terms of bit operations, if its required running time is
0(log \')k .
(2 .22)
for some constant k-. An algorithm is said to be of exponential complexity.
measured in terms of bit operations . if its required running time i s
O( .V 1 ) .
(2 .23 )
where e < 1 is a small positive real number .
Example 2.1.3. Let 3 be the number of bits needed to represent n . Then .
3 = [log n J + 1 .
Suppose that the complexity of an algorithm, measu red by arithmetic op-
erations on an integer (input) n, is 0(n) . What is the complexity for thi s
algorithm in terms of bit operations? Since for each arithmetic operation .
0(log 1W hit operations will be needed ,
0(n)
= 0 (n(logn) 2 )
= O(2 1"°(log n)2 )
,
Therefore. the algorithm is of polynomial complexity in arithmetic opera-
tions, but of exponential complexity in bit operations .
Remark 2 .1 .3 . In some computational problems such as the Traveling
Salesman Problem, and the problem of sorting a list . the complexities mea-
sured by arithmetic operations reflect the actual running times . However ,
in most of the computational problems in number theory . the complexities
measured by bit operations reflect the actual running times . In this book ,
all the complexities will be measured in terms of bit operations, rather tha n
arithmetic operations.
Let us finally observe the complexities of some other common operation s
in arithmetic and number theory .
(1) The computation of q = (a/b] . where a is a 23-bit integer and b a 3-bit
integer, can be performed in 0( :322) bit operations. However. the number
of bit operations needed for integer division can be related to the th e
More generally, an algorithm with an input containing integers
a1 .n2, . . .,n, .
of lengths log n 1 .log n
_log it,
bits, respectively, is said to be o f
polynomial complexity if there exist integers
k1 , kz.
. . .
such that
the number of bit operations required to perform the algorithm is
O ((log nr )tti , (log n.2,
. . , (log a, ) k ) . Thus, by a large input, we will always
mean that an input contains
large integers, rather than many integers as for
sorting .

194
2. Computational/Algorithmic Number Theory
2 .1 Introduction
195
number of bit operations needed for integer multiplication. That is. the
division of a 23-hit integer by a 3 -bit integer can be done in O( 1(n) )
bit operations, where 111(n) is the number of bit operations needed t o
multiply- two 3-bit integers .
(2) Euclid's algorithm for calculating gcd(31 . J) where 11 < can be
performed in O(log M)' 3 bit operations . This follows from a theorem .
due to the French mathematician Gabriel Lame (179.5 1870) in 1844 (see
Cormen . Ceiserson and Rivest [54]) . which states that the number of
divisions necessary to compute the gcd(14i, 1') is at most five times the
number of decimal digits of M . So it will perform O(log 11i) arithmeti c
operations and O(log 111)3 bit operations (assuming that multiplication
and division take O(logn) '- bit operations).
11
(3) The computation of the Jacobi symbol — ) with 1 < Al < N can
be performed in ()dog my bit operations . This is derived from the reci-
procity law for the Jacobi symbol . In fact, with a. more effective method
indicated by Lehrner . which avoids divisions. it is possible to compute
11
both gcd(M. N) and (N )
in O(log 111) '- bit operations .
Exercise 2.1 .3 . Using the big-O notation, estimate the number of bit op-
erations needed for the following operations .
(1) Let n, be a 3-bit integer written in binary. Estimate the time to conver t
n to decimal .
(2) Let n! be the factorial n • (n – 1) . - . 2 - 1 and (
coefficient (n 
7
m
i
b . )	
mi. . Estimate the time to compute n! an d
–
(3) Let A and B be n x n matrices, with entries a,3 and b,f for 1 < i.. j < n ,
then AB is the n x n matrix with entries c,1 = E aik bkJ . Estimate th e
k= 1
number of bit operations required to find AB directly from its definition .
(4) Suppose we want to test if a large odd number n is prime by trial divisio n
by all odd numbers up to n. Estimate the number of bit operations thi s
test will take. How about if we have a list of all primes up to n? Ho w
many bit operations will be needed to test if n is prime by trial divisio n
by all the primes up to n (use the Prime Number Theorem) ?
2 .1 .5 Fast Modular Exponentiations
A frequently occurring operation in elementary number theoretic compu-
tation is that of raising one number to a power modulo another number,
r e mod n, also known as modular exponentiation . The conventional method
of repeated multiplication would take O(c log a) 2 bit operations which is too
slow when c is large. Fortunately, the method of repeated squaring will solve
this problem efficiently using the binary representation of b . The idea of th e
repeated squaring method is as as follows :
Theorem 2 .1 .3 . Suppose we want to compute x' mod n with i .e . n E N .
Suppose moreover that, the binary form of e is as follows :
= 3c2k + i3k–12k–r + . . . + 3 1 2 1 + 3302° .
where each 3 (i = 0.1 .2 . - -k) is either 0 or 1. Then we hav e
x3ti2~'+de-,2
+30 1 +3020
k
=o
Furthermore, by the exponentiation law
+l
x-
= (x:
and so the final value of the exponentiation can be obtained by
squaring and multiplication operations .
Example 2 .1 .4. Suppose we wish to compute a 100 ; we first write 10010 =
11001002 := Ese,c1e.3C2erco, and then compute
eo
1
a
initialization
co
1
(a)2
- a
squaring and multiplication
e
0
((a)2 .02
squaring
c j
0
squaring
(((a) '
(02 )2
c9
1
((((a)2
a)2)2
.
squaring and multiplication
el
0
(((((a)2 - (02 )2 ) 2
. a)~
squaring
co
0
((((((a)2 . a)2)2)2
. 0)2)2
squaring
0 10 0
n
m
the binomial
n
(2.24)
(2.25)
(2.26 )
repeated
=
((((((a)2
. (1)2)2)2 . a) 2 )'2
(. a3 . 0 6 , a12 . a24 . a2s, ( SO . (loo
Note that for each e, . if ei = 1. we perform a squaring and a. multiplication
operation (except "co = 1", for which wejust write down a . as indicated in
the first bracket). otherwise. we perform only a squaring operation. That is.
(2.27)
a loo

196
2 . Computational/Algoritlunic Number Theo r}
2 .1 Introduction
19 7
Exercise 2 .1.4. Write down the similar expressions as in (2 .27) for comput-
ing x931 and t;g'S01 , and verify your results . (Hints: 931 10 = 11101000112 an d
650110 = 1100101100101 .)
We are now in a position to introduce a fast algorithm for nodular ex-
ponentiations (note that we can simply remove the "mod n" operation if we
only wish to compute the exponentiation c = x e ) :
Algorithm 2 .1 .1 (Fast modular exponentiation x e mod n) . This algo-
rithm will compute the modular exponentiatio n
c = .r` mod n,
where x.e,n E N with n > 1 . It requires at most 2loge and 2loge division s
(divisions are only needed for modular operations ; they can be removed if onl y
c =
are required to be computed) .
[1] [Precomputation] Let
e;3 lea
2
eleo
(2 .28)
be the binary representation of e (i .e., e has e3 bits) . For example, for 562 =
1000110010, we have 3 = 10 an d
1
0
0
0
1
1
0
0
1
0
1
1
T T
i
T T T 1
T
e9
eg
e7
e6
C
e,t
e ; 3
e2
el
CO
we multiply together the least positive residues of the integers
x2' corre-
sponding to the binary bits of e which are equal to 1 . and reduce modulo n .
This also requires 0 ((loge)(logn)~-) bit operations . since there are at most
0(log e) multiplications . each requiring 0(log n) 2 bit operations. Therefore, a
total of 0 ((log e) (log n)2) bit operations are needed to find the least positiv e
residue of :re mod n .
q
Example 2.1.5. Use the above algorithm to compute 79007 mod 561 (here
J . = 7, e = 9007 and in = 561) . By writing e in the binary form e =
e;3_1 e 5_2 . . . C'1 CO . we have
9007 = 10001100101111 
%13e12• . . etep .
Now we just perform the following computations as described in algorithm
2.1 .1 :
cl- 1
r F 7
a. – 56 1
for i from 3 – 1 down to 0 d o
el-C- mod e
if e,=1then ct-c . xmod n
print c; (now c = xe mod n )
The values of (i . e, . c) at each loop for i from 13 down to 0 are as follows :
[2] [Initialization] Set c E- 1 .
13
12
11
10
9
8
7
6
5
4
3
2
1
0
1
0
0
0
1
1
0
0
1
0
1
1
1
1
[3] [Modular Exponentiation] Compute c = a
rood n in the following way :
7
49
157
526
160
241
298
166
469
49
538
337
46
226
for i from 3 – 1 down to 0 d o
c
c2 mod n (squaring )
if e, = 1 then
c 1
c . x mod n (multiplication )
[4] [Exit] Print c and terminate the algorithm .
Theorem 2 .1 .4. Let x . e and n be positive integers with n > 1. Then the
modular exponentiation x e mod n can be computed in 0(log e) arithmeti c
operations and 0 ((loge) (log n)2 ) bit operations. That is .
Time O.' mod n) = 0 4 (loge) ,
=
OB ((loge)(log n
Proof. We first find the least positive residues of x. .t :
. ' .r'', .
. .r'
modulo
n . where 2 1 < e < 21
" 1 , by successively squaring and reducing modulo n .
This requires a total of 0 ((loge)(loga) 2 ) bit operations, since we perfor m
O(loge) squarings modulo n, each requiring 0(log n) 2 bit operations. Next.
So. at the end of the computation, the final result c = 7' 007 mod 561 =
226 will be returned. It is clear that at most 21og2 9007 multiplications and
21og2 9007 divisions will be needed for the computation . In fact, only 22
multiplications and 22 divisions will be needed for this computation task .
Exercise 2.1 .5. Use the fast exponentiation method to comput e
= 3129x967296 mod 429496729 7
completing the items marked with for F in the following table (not e
4294967296 = 1 000 . . . 00 in binary) :
32
zero s
32
31
30
29
28
27  
2
1
0
111111111118111I
o
(
=Ell 8 1
Remark 2.1 .4. The above fast exponentiation algorithm is about half as
good as the best ; more efficient algorithms are known . For example, Brickell ,
(2.29)
(2.30)
) .

198
2. Computational/Algorithmic Number Theory
2 .1 Introduc on
199
et. al. [41] developed a. more efficient algorithm, using precomputed values
to reduce the number of multiplications needed. Their algorithm allows the
computation of q" for ti < N in time O(log N/ log log X) . They also showed
that their method can be parallelized. to compute powers in time O(log log N )
with O(log N/ log log N) processors .
2.1.6 Fast Group Operations on Elliptic Curve s
The most fundamental computations on elliptic curves are the group opera-
tions of the type
kP=P
Lb
(IL
.
.
P
k time s
where P = (.r . y) is a point, on an elliptic curve E : y2 = .r' + a.r+ + b . and k a
very large positive integer. Since the computation of kP is so fundamental in
all elliptic curve related computations and applications . it is desirable that
such computations be carried out as fast as possible. The basic idea of th e
fast computation of kP is as follows :
[1] Compute 2'P, for i = 0,1 .2, . . . . ;3 — 1. with .3 = [1.4421n k + 1j J .
[2]Add together suitable multiples of P . determined by the binary expansio n
of k . to get kP .
For example, to compute kP where k = 232792560, we first compute :
3= [1.4421nk+1J = 28 ,
then compute 2`P, for i = 0, 1, 2, ' ' ' , 27 as follows :
P 2P 2 2 P
2 3P
2 4 P
2 2 'P
2 26 P
227p
II
II
II
II
II
I I
2(2P) 2(2 2 P) 2(2 3 P)
. .
2(2 21P) 2(225 P) 2(2 96 P)
By the binary expansion of k ,
k = 232792560 10 = 11011110000000100001111100002 := e27C'2g -
zer co,
we add only those multiples that correspond to 1 :
1
1
1
1
1
1
1
1
1
1
227
226
221
223
222
2 2'
2rs
2 8
2'
2 c
and ignore those multiples that correspond to 0 :
2 202 20 , 2 10 ,2 18.2 17, 2 1A , 2' .2''~ .212 .2n
.210 2 s . 2 3 , 2
. 2 1 . 2 0 .
Thus, we finally have :
kP = 227P
=. 2 25P 2 21 P
:; 2 233 2 22P ,) 2 2 ' P
2''P
E)
e
27P
2`'P 20 P LI) 2:'P
= 232792560P .
Remarkably enough, the idea of repeated squaring for fast exponentia-
tions can be used almost directly for fast group operations (i.e . . fast point
additions) on elliptic curves . The idea of fast group additions is as follows :
Let e s 1 e3_
. . . CI CO be the binary representation of k . Then for i starting
from e3_ 1 down to co (eg_r is always 1 and used for initialization) . check
whether or not e i = 1 . If e; = 1 . then perform a doubling and an additio n
group operation : otherwise, just perform a doubling operation . For example.
to compute 89P. since 89 = 1011001, we have :
eb
1
P
initialization
es
0
2P
doubling
e
1
2(2P) + P
doubling and addition
e3
1
2(2(2P) + P) + P
doubling and addition
C2
0
2(2(2(2P) + P) + P)
doubling
e1
0
2(2(2(2(2P) + P) + P))
doubling
co
1
2(2(2(2(2(2P) + P) + P))) + P
doubling and addition
(1
89P
The following algorithm implements this idea of repeated doubling and addi-
tion for computing kP .
Algorithm 2 .1 .2 (Fast group operations kP on elliptic curves) .
This algorithm computes kP, where k is a large integer and P is assumed to
be a point on an elliptic curve E
:
y 2 = a: 3 + ax + b . (Note that we do no t
actually do the additions for the coordinates of P in this algorithm . )
[1] Write k in the binary expansion form k
e 3
CO ,
ei
where each e ;
is either 1. or 0 . (Assume k has 3 bits .)
[2] Set A' - O .
[3] Compute kP :
for i from 3 -1 down to 0 do
c
2c (doubling) ;
if e, = 1 then c t- c+P ; (addition )
[4] Print c; (now c = kP)
Example 2.1.6. Use Algorithm 2.1.2 to compute 105P . Let
k=105=1101001 :=
e e:e2 e
C O .
At the initial stage of the algorithm, we set c = O. Now, we perform the
following computation steps according to Algorithm 2 .1.2 :
(2 .31)

2 . Computational AIgorithjnic Number Theor y
--> c4-P
—> c = P
—> c4-P+2P 
 
> c'=3P
 
> c4-2(P+2P)
 
> c=6P
c3 =1 : c4-P+2c 
> c 4- P + 2(2(P + 2P)) 
 
> c=13P
e2 = 0 :
c 4-- 2c 
 
> c 4- 2(P + 2(2(P + 2P)))
—>
c = 26P
c 1 = 0: c 4- 2c 
 
> c 4- 2(2(P + 2(2(P + 2P)))) 
 
>
c = 52P
ea=1 : c4-P+2c 
> c4-P+2(2(2(P+2(2(P+2P)))))-> c=105P .
That is, P + 2(2(2(P + 2(2(P + 2P))))) = 105P .
Example 2 .1.7. Suppose we wish to compute kP mod 1997, where k =
9007 = 1000110010111 12. The computation can be summarized in the follow -
ing table which shows the values of (r .e„c) for each execution of the "for `
loop in Algorithm 2 .1 .2 (plus an additional modular operation "mod 1997"
at the end of each loop) :
13
12
11
10
9
8
7
6
2
1
0
1
0
0
0
1
1
0
0
1
1
1
P
2P
4P
8P
17P
35P
70P
140P
254P
509P
1019P
The final result of the computation is c - 1019P ( mod 1997) . It is clear that
the above computation will need at most log 9007 arithmetic operations .
Note that Algorithm 2 .1 .2 does not actually calculate the coordinates
(x. y) of kP on an elliptic curve over Q or over Z/NZ . To make Algorithm
2.1.2 a practically useful algorithm for point additions on an elliptic curve E ,
we must incorporate the actual coordinate addition P3 (L 3 , y3 ) = P1 (.r1 , yr) +
P2 (x >, y2 ) on E into the algorithm . To do this. we use the following formulas
to compute
a;3 and y3 for P3 :
(1'3 . Y3) _ () 2 - :r
2 :
A (1•i — x3) — yl),
where
Algorithm 2 .1 .3 (Fast group operations AT on elliptic curves) .
This algorithm will compute the point k;P mod N . where le E Z + and P is a n
initial point (x. y) on an elliptic curve E
:
y 2 = x 3 + ax + b over 7Z/NZ ; if
we require E over Q, just compute kP, rather than kP mod N . Let the initia l
point P = (ar t .m ), and the result point P = (x,. . y,) .
[1] [Precomputation] Write k in the following binary expansion form k =
es
j e
2 ''-e 1 eo . (Suppose k. has 3 bits) .
[2] [Initialization] Initialize the values for a, x i and yj . Let (x,, y,) = (:rj ,y 1 ) ;
this is exactly the computation task for e1 (e l always equals 1) .
[3] [Doublings and Additions] Computing kP mod N :
2.1 Introdu( on
201
for i. from 3 - 2 down to 3 d o
rn1 4— 3x + a rood .\'
m2 4- 2y,, mod N
M 4— in 1/1112 mod N
x3 4- M2 - 2:r, mod ,\-
y; 4- 11(.r, - r3 ) - y,. mod N
x,. 4 - x3
Ye 4- y 3
ifc,= 1
then c4-2c+ P
nz j
- y mod N
102 f- X . - x i mod N
Al 4- rn i / no mod N
x3 4-11 2 - .r 1 -x,.mod N
y3 4- 11( :r l - :r3 ) - ,y1 mod \'
xc 4— :14
Ye 4 113
else c 4- 2c
[4] [Exit] Print y,.) and terminate the algorithm . (Note that this algorith m
will stop whenever at ] / rn2 = Or (mod N), that is, it will stop whenever a
modular inverse does not exit at any step of the computation .)
Exercise 2.1 .6. Let
E :
y2 =r' -x- 1
be an elliptic curve over Z/10984137Z and P = (0,1) a point on E . Use
Algorithm 2 .1 .3 to compute the coordinates (x, y) of the points kP on E
over Z/1098413Z for k = 8,31 .92,261, 513, 875 . 7892,10319P. Find also th e
smallest integral values of k such that kP = (467314.689129) and kP =
(965302, 895958), respectively .
Theorem 2 .1 .5 . Suppose that an elliptic curve E is defined by any one
of the equations of (1 .309) . (1 .310) and (1 .311), over a finite field Il'9 with
q = p' a prime power. Given P E E, the coordinates of kP can be computed
by Algorithm 2.1 .3 in O(log k) group operations and O ((log k) (log p)') bi t
operations. That is .
Time(kP) = O i (logk) .
(2.32)
= 0B (log k) (log (1) 3 ) .
(2.33)
Note that both the fast modular exponentiation a1 mod n and the ellipti c
curve group operation kP mod n are very well suited for parallel computa-
tion. For example. a naive parallel algorithm to compute kP could be as
follows :
200
eb =1 : c4-P+2c
es=1 : c4-P+2c
e'a=0 :
e4— 2c
if PL = P2
otherwise .

202
2 . Coral»national/Algorithmic N umber Theory
2.2 Algoritlnns for Primality Testing
203
begin parallel
for i from io to O(log k) do
compute 2' P
end parallel
compute Q = E 2'P
(It is assumed that we have sequentially tried all the small values up to io .)
With this naive algorithm kP can be computed in C)(log log k) group op-
erations with O(log k) processors . For example, at most 28 processors wil l
be needed to compute 232792560P and at most 5 group operations will b e
needed for each of these processors. Brickell. Gordon and Mt :Curley [41] de-
veloped a parallel algorithm for computing a t in O(log log k) arithmetic op-
erations and O(log k/ log log k) processors. It seems reasonable to conjecture
that kP can also be computed in O(log log k) elliptic curve group operation s
with O(log k/log log k) processors .
2 .2 Algorithms for Primality Testin g
It would be 'interesting to know, for example, what the situation is wit h
the determination if a number is a prune, and in general how much w e
can reduce the number of steps from the method of simply trying for finit e
combinatorial problems .
KURT GODEI. (19061978 )
2 .2 .1 Deterministic and Rigorous Primality Test s
The primality testing problem (PTP) may be described as the following simpl e
decision (i .e., yes/no) problem :
Input :
n E N
Yes,
with n > 1 .
if n E Primes .
(2.34)
Output :
No,
otherwise- .
hl theory it is easy to determine if a given positive integer rr > 1 is prime ;
sirnply verify that n is not divisible by any of the integers from 2 up to n/2
(the largest possible factor of a) . Since any divisor of iris itself a product of
primes. we need only check to see if n is divisible by the primes from 2 up to
n/2 . The following test however will reduce the amount of work considerably.
Theorem 2 .2.1 (Primality test by trial divisions) . Let n > 1 . If n has
no prime factor less than or equal to
n, then n is prime .
With this test we just try to divide n by each prime number from 2 u p
to (
n) (this can he done by using the sieve of Eratosthenes. or by using a
table containing prime numbers up to
n). It is easy to see that n is prime
if and only if none of the trial divisors divides n . However, even this test is
not practically useful for the test of primality for large numbers . since it is
very inefficient needing 0 (2° 08 " 0 ) hit operations .
In what follows . we shall introduce some other rigorous primality tests .
Theorem 2 .2 .2 (Lucas' converse of Fermat's little theorem, 1891) .
If there is an integer a such tha t
(1) a' -1 = 1 (mod n) . and
(2) a ( " -IN " A 1 (mod n) . for each prime p of
Then n is prime .
Proof. Since a"-r - 1 (mod a) . Part (1) of Theorem 1 .6 .31 (see Chapter
1) tells us that ord,,(a)
(n - 1) . We will show that ord„(a) = n - 1 . Suppose
that ord„(a)
n - 1 . Since ord„(a) ((ra - 1), there is an integer k satisfying
n - 1 = k ord,, (a) . Since ord„(a)
n - 1. we know that k > 1. Let p he a
prime factor of k. Then
r, n-r /q
:rk /q ord„ c)
ord,(a)
k/ 9
=
= (r
)
.1 (mod n) .
However, this contradicts the hypothesis of the theorem, so we must hav e
ord o (a) = rr 1 . Now, since oard,,(a) <'(n) and d(n) < n-1, it follows that
'(n) = n - 1 . So. by Part (2) of Theorem 1 .4 .14. n must be prune .
q
Example 2.2.1 . Let n = 2011, then 2011 - 1 = 2 . 3 . 5 . 67. Note first
3 is a primitive root (in fact, the smallest) of 2011, since order(3, 2011) =
'(2011) = 2010. So, we have
3 20111
(mod 2011) ,
3(20x0-rl/2 _ -1 ; 1 (mod 2011),
3tmro-11/3
205 : 1 (mod 2011 )
,
,
3 tzoro-il/s _ 1328 1 (mod 2011)
3(( 2010- 1 1C"7 - 1116 A 1 (mod 2011) .
Thus by Theorem 2 .2.2 . 2011 must be prime .
Remark 2.2.1. The defect of this test is that it requires the prune factor-
ization of n - 1, a problem of almost the same size as that of factoring n and
a problem much harder than the primality testing of n .
Theorem 2.2.2 is equivalent to the following theorem :

204
2 . Computational/Algorithmic Number Theory
Algorithms for Primality Testing
205
Theorem 2.2 .3. Let a and n be positive integers with gcd(a, n) = 1 . If
ord„(a) = 9(n.) = n – 1.
(2 .35)
then n is prime .
Example 2.2.2. Let n = 3779. We find for example that the integer a = 1 9
with gcd(19,3779) = 1 satisfies
(1) ord3779 (19) = 3778,
(2) 0(3779) = 3778 .
That. is, ord377s (19) = 0(3779) = 3778 . Thus by Theorem 2 .2.3 3779 is prime.
Remark 2.2.2 . If we know the value of O(n), we can immediately determine
whether or not n is prime, since by Part (2) of Theorem 1 .4.14 we know that
n is prime if and only if d(n) = n–1 . Of course, this method is not practicall y
useful, since to determine the primality of n, we need to find 0(n) . but to find
o(n), we need to factor n, a problem even much harder than the primality
testing of n .
It is possible to use different bases a, (rather than a single base a) for
different prime factors p, of n – 1 in Theorem 2.2.2:
Theorem 2 .2 .4. If for each prime p, of n– 1 there exists an integer a; such
that
(1) a `–r
1 (mod n) . and
(2) a('–r)'r`
1 (mod a) .
Then n is prime .
k
Proof. Suppose that n–1 = fl 1)7' , with a; > 0, for i = 1 .2, . ' ' .k . Let also
a=r
ri = ord„(a,) . Then r,
(n – 1) and ri
(n – 1)/p; implies that p°' ri . But
for each i, we have r,
0(n) and hence p7'
1 O(n) . This gives us (n–1) 1 d(n) ,
so n must be prime .
0
Example 2.2.3. Let again n = 3779, then n – 1 = 2 . 1889 = p t
pt = 2 we choose al = 19 and get
193778 - 1 (mod 3779), 23778, - E
1 $ 1 (mod 3779) .
For p2 = 1889 we choose a 2 = 3 and get
33778 = 1 (mod 3779),
33778'1889 = 9 1 (mod 3779) .
So.. by Theorem 2.2.4, 3779 is prime. Note that for a
3. we have 2 3778/3 E
1 (mod 3779) and 33778/1889 $ 1 (mod 3779), but it does not matter, since
it is not necessary to have the same value of a for the prime factors 2 and
1889 of n – 1 : a different value of a. (e .g., a = 2) is allowed for the prime
factor 1889 of n – 1.
It. is interesting to note. although primality testing is difficult . the verifi-
cation of primality is easy, since the primality (as well as the compositeness )
of an integer n can be verified very quickly in polynomial time :
Theorem 2.2.5. If n is composite, it can be proved to be composite i n
0((logn)2 ) bit operations.
Proof. If tt is composite. there are integers a and b with 1 < a < n . 1 < b <
and n = ab . Hence, given the two integers a and b. we multiply a and b, and
verify that it = ab . This takes 0((loga.) 2 ) bit operations and proves that n
is composite.
0
Theorem 2 .2 .6 . If n is prime, it can be proved to be prime in O((log n)
)
bit operations .
Remark 2.2.3. It should be noted that Theorem 2 .2 .5 cannot be used for
finding the short proof of primality, since the factorization of n – 1 and the
primitive root a of n are required .
Theorem 2.2 .5 was discovered by Pratt [193] in 1975 : he interpreted the
result as showing that every prime has a succinct primality certification . For
some primes . Pratt's certificate is considerably shorter . For example, if p =-
22' + 1 is a Fermat number with k > 1, then p is prime if and only i f
3(n–t)/2 _ - 1 (mod p) .
(2.36)
This result . known as Papin's test, gives a Pratt certificate for Fermat primes .
The work in verifying (2 .36) is just 0(p) . since 2k – 1 = [loge pj – 1. In fact .
as Pomerance [189] showed, every prime p has an O(p) certificate. More
precisely. he proved :
Theorem 2.2.7. For every prime p there is a proof that it is prime . which
requires for its certification (5/2 + o(1)) log2 p multiplications modulo p .
However. if we assume that the Riemann hypothesis is true . then there
is a deterministic polynomial algorithm for primality testing (Miller . [162]) .
But as we do not know if the Riemann hypothesis is true. the complexity i s
uncertain .
The fastest unconditional. rigorous and deterministic algorithm is th e
ARRCL test. invented by Adleman . Pomerance, R.umely Cohen and Lenstra
(see [3] and [50]): its running time i s
O ((log \•)o(tog tog Iog_I
where c is small positive real number . Although the exponent c(log log log Ai)
is an extremely slowly growing function. it is not polynomial, but superpoly-
no,nial. Thus, the ARRCL test is of superpolynomial complexity .
Irz
For

206
2 . Computational/Algorithmic Number Theory
2 .2 Algorithms for Primality Testing
207
Although no deterministic polynomial time algorithm has been found fo r
primality testing. there do exist some efficient probabilistic algorithms fo r
primality testing. In the next few subsections, we shall introduce some of
these probabilistic algorithms .
2 .2 .2 Fermat's Pseudoprixnality Test
This section will be concerned with the basic concepts of probable primes .
pseudoprimes and pseudoprimality testing . Let (Z/n7Z)
denote the nonzero
elements of (74/nZ) :
(74/n..4)+=
.l — 1} .
(2 .37)
Clearly, if it is prime, then (74/n7Z)+ = 74/n74 .
Let us first. re-examine Fermat's little theorem : if b is a positive integer.
p a prime and gcd(b. p) = 1, the n
bn—1 E 1 (rood p) .
(2 .38)
The converse of Fermat's little theorem is : for some odd positive integer n, if
gcd(b, n) = 1 and
b"—t
1 (mod n),
(2.39)
then n is composite . So . if there exists an integer b with 1 <
b < n . gcd(b, n) =
1 and b" — " $ 1 (mod n), then it must he composite . What happens if we fin d
a. number n such that 1)i—1 - 1 (mod a)? Can we conclude that n is certainly
a prime? The answer is unfortunately not. because n sometimes is indeed a
prime. but sometimes is not! This leads to the following important concepts
of probable primes and pseudoprimes .
Definition 2 .2 .1 . We say that n is a base-b probable prime if
b"—1 E 1 (mod n.) .
(2.40)
A base-b probable prime it is called a base-b psendoprime if it is composite .
A base-b probable prime and a base-b pseudoprime are also called a base- b
Fermat probable prime and a base-b Fermat pseudoprime, respectively .
Example 2 .2 .4. If it = 1387. we have 2 3 `"1—1
E 1 (mod 341) . Thus 341
is a base-2 probable prime. But since 341 = 11 - 31 is composite, it i s
a base-2 pseudoprime . The first few base-2 pseudoprimes are as follows :
341 . 561. . 645. 1105 . 1.387, 17 29,. 1905 .
Note that there are some composite numbers that satisfy (2 .40) for ever y
positive integer b, such that gcd(b, n) =
1 :
Definition 2 .2 .2 . A composite number n that satisfies b" —1 = 1 (mod n)
for every positive integer b such that gcd(b . n) =
1 . is called a Carmichael
number . in honour of the American mathematician Carmichael° .
Example 2 .2 .5 . The first ten Carmichael numbers are as follows :
561 .
It. is usually much harder to show that a given integer (particularly when i t
is large) is a Carmichael number than to show that it is a base-b pseudoprime .
as we can see from the following example .
Example 2 .2 .6. Show that 561 is a Carmichael number . Note that 561 =-
3 . 11 - 17. Thus gcd(b, 561) = 1 implies that gcd(b, 3) = gcd(b, ll) =
gcd(b, 17) = 1 . To show that aJ60 - 1 (mod .561) for all b for which
gcd(b, 3) = gcd(b, 11) = gcd(b, 17) = 1, we use the Chinese Remainder Theo -
rem and Fermat's little theorem, and get
b~ - 1 (mod 3) 
> a'"60 = (a2)280
1 (mod 3) .
b10 = 1 (mod 11)  
> 0°60 = (010)56 - 1 (mod 11) ,
b16 - 1 (mod 17)  
> a'60 = (a16)35
1 (mod 17) .
Hence bf60 - 1 (mod 561) for all b satisfying gcd(b, 561) = 1 . Therefore, 56 1
is a. Carmichael number .
The largest known Carmichael number was found by H . Dubner in 1994 ;
it has 8060 digits and is a product of three primes; it also has been known that
there are 246683 Carmichael numbers up to 10 16 (Pinch. [185]) . Carmichael
numbers are characterized by the following property.
Theorem 2 .2 .8 . A composite integer n > 2 is a Carmichael number if an d
only if
k
n=Hpi,
k> 3
i= 1
for all distinct odd primes p i such that .\(n)
n—1 . or equivalently p,—1 n—1.
for all nonnegative integers i < k .
Exercise 2 .2 .1 . Use Theorem 2 .2.8 to show that the integer 29341 is a
Carmichael number . but 341 is not .
Fermat 's little theorem implies that if n is prime, then n satisfies the
congruence (2.40) for every a in (Z/n7L) + . Thus, if we can find an integer
" Robert Carmichael conjectured in 1912 that there are infinitely many such num-
bers that now bear his name. W. Alford, G. Granville and C . Pornerance [6]
proved this conjecture in 1992 .

208
2 . Computational/algorithmic Number Theory
2.2 Algorithms for Prinrality Testing
209
b E
(Z/nZ)+ such that n does not satisfy the congruence (2 .40) . then n
is certainly composite . Surprisingly. the converse almost holds. so that this
criterion forms an almost perfect test for primality. The following is the al-
gorithm for b = 2 :
Algorithm 2.2.1 (Base-2 Fermat pseudoprimality test) . This algo-
rithm will test numbers from 3 up to j . say. j = l010 for primality. If it
outputs n is composite. then n is certainly composite. Otherwise . n is almost
surely prime .
[1] Initialize the values > 3 and j > i . Set n s— i .
[2] If 2" (mod n) = 2, then n is a base-2 probable prime, else n is composite .
[3]n t— n + 1. If n < j goto [2], else goto [4] .
[4] Terminate the execution of the algorithm .
The above base-2 pseudoprimality test is also called Chinese test . since
the Chinese mathematicians had this idea earlier than Fermat (Rosen [211]) .
Among the numbers below 2000 that can pass the Chinese test . only six are
composites: 341. 561, 645, 1105 . 1729 and 1905: all the rest are indeed primes .
Further computation shows that such composite numbers seem to be rare .
To exhibit quite how rare these are, note that up to 10 10 there are around
450 million primes, but only about fifteen thousand base-2 pseudoprimes ,
while up to 2 . 5 x 10 10 there are over a billion primes . and yet. fewer than 2 2
thousand base-2 pseudoprimes . So, if we were to choose a random number
n < 2 . 5 x 10 10 for which rz divides 2" — 2, then there would be less than an
one-in-fifty-thousand chance that our number would be composite . We quote
the following comments on the usefulness of the Chinese test from Rosen
[211] :
Because most composite integers are not pseudoprimes. it i.s possible
to develop primality tests based on the original Chinese idea, together
with extra observations .
2 .2 .3 Strong Pseudoprimality Test
It this subsection we shall present an improved version of the pseudoprimal-
ity test discussed previously. called the strong pseudoprimality test. (or just
strong test, for short) .
Theorem 2 .2 .9 . Let p be a prima Then
— 1 (mod p)
(2 .41)
if and only if x
+1 (mod p) .
Proof. First notice that
x2 E tl (mod p)
(.r, + 1)(.r — 1) - 0 (mod p)
p](a'+1)(•r—1 )
pl(x + 1) or p~(x—1)
x+10 (mod p) or .r—1-0 (mod p)
:r,
-1 (mod p) or x = 1 (mod p).
Conversely. if either
.r E -1 (mod p) or x
1 (mod p) holds, then x2
1 (mod p) .
q
Definition 2 .2 .3 . The number x is called a nontrivial square root of 1 mod-
ulo n if it satisfies (2.41) but x
±1 (mod n.).
Example 2 .2 .7 . The number 6 is a nontrivial square root of 1 modulo 35 .
since .r2 = 62 E. 1 (mod 35). x = 6 $ ±1 (mod 35) .
Corollary 2 .2 .1 . If there exists a. nontrivial square root of 1 modulo n . then
n. is composite .
Example 2.2.8. Show that 1387 is composite. Let x = 2 693. We have x-2 =
(2693 )2 = 1 (mod 1387), but x = 2 693
512 $ ±1 (mod 1387) . So, 2693 is
a nontrivial square root of 1 modulo 1387. Then by Corollary 2 .2.1 . 1387 is
composite.
Now we are in a position to introduce the strong pseudoprimality test, an
improved version of the (Fermat.) pseudoprimality- test .
Theorem 2.2.10 (Strong pseudoprimality test) . Let n = 1+ 2fid, with
d odd, is prime . Then the so-called b-sequence
{bd . b 2s
ba"
bsa ,
b'2-'d
mod n
(2 .42)
has one of the following two forms :
1 . 1 
1) .
(2.43)
(1. 1,
. . .
, 1 .
(? .
? .
. .
?
— 1. 1 
1) .
(2.44)
reduced to modulo n . for any 1 < b < n . (The question mark . T' denotes a
number different from T1 .)
The correctness of the above theorem relies on Theorem 2 .2 .9: if n i s
prime. then the only solutions to x 22 = 1 (mod n) are x
+1 . To use the
strong pseudoprimality test on n . we first choose a. base b, usually a small
prime. Then we compute the It-sequence of n : write n— 1 as 2 1d where d
is odd. compute b`r mod n, the first term of the b -sequence. and then square
repeatedly to obtain the b-sequence of' j + 1 numbers defined in (2 .42), all

210
2 . Computational/Algorithmic Number Theory
2.2 Algorithms for Primality Testing
211
reduced to modulo n . If n is prime, then the b -sequence of n. will be of the
form of either (2 .43) or (2.44) . If the b-sequence of n has any one of th e
following three forms
(?
. . ., ?
1
1
,
1),
(2.45)
(? .
. '' .
?, ? .
. -1).
(2.46)
(?
. . .
_
~
>
. .
?)
(2.47)
then n is certainly composite . However, a composite can masquerade as a
prime for a few choices of base b . but not be "too many" (see Wagon [251]) .
The above idea leads naturally to a very efficient and also practically usefu l
algorithm for (pseudo)primality testing :
Algorithm 2 .2 .2 (Strong pseudoprimality test) . This algorithm wil l
test n for primality with high probability :
[1] Let n be an odd number, and the base b a random number in the range
1 < b < n . Find j and d with d odd, so that n
1 = 2t d.
[2] Set i - 0 and y <- bd (mod n .) .
[3] If i = 0 and y = 1, or y = n - 1, then terminate the algorithm and outpu t
"n is probably prime" . If i > 0 and y = 1 goto [5] .
[4] i <- i. + 1. If i < j, set y - y2 (mod n) and return to [3] .
[5] Terminate the algorithm and output "n. is definitely not prime" .
The strong pseudoprimality test is most often called the Miller-Rabin test ,
in honour of the computer scientists Miller 10 and Rabin" . It is also called the
Miller-Selfridge-Rabin test, because Selfridge' used the test in 1974 before
Miller first published the result (Mollin [164]) .
Definition 2.2 .4. A positive integer n with n - 1 = d . 2) and d odd, is
called a base-h strong probable prime if it passes the strong pseudoprimality
test described above (i .e., the last term in sequence 2 .42 is 1, and the firs t
occurrence of 1 is either the first term or is preceded by -1) . A base-h stron g
probable prime is called a base-b strong psendoprime if it is a composite .
10 Gary L. Miller is currently Professor in Computer Science at Carnegie-Mello n
University working on computer algorithms . He received his PhD in Compute r
Science at the University of California . Berkeley in 1974 .
i1 Michael O. Rabin received his MSc in 1953 from Hebrew University and hi s
PhD in 1956 from Princeton University. He is currently Professor in Compute r
Science at Harvard University. working on the theory and application of computer
algorithms. Prof. Rabin was a 1976 Turing Award co-recipient for his joint paper
"Finite Automata and Their Decision Proble m" with Dana S. Scott . Both were
PhD students of Alonzo Church at Princeton .
John L. Selfridge was born in Ketchican . Alaska in 1927 . He obtained his Ph D
from the University of California at Los Angeles in 1958 and became a Professo r
at Pennsylvania State University six years later . Selfridge is one of the leading
scientists in computational number theory and has made important contribution s
to the field .
If n. is prime and 1 < b < n . then n passes the test . The converse is usually
true, as shown by the following theorem .
Theorem 2.2.11. Let n > 1 be an odd composite integer . Then n passes
the strong test for at most (n - 1)/4 bases b with 1 < b < n .
Proof. The proof is rather lengthy . we thus only give a sketch of the proof.
A more detailed proof can be found either in Section 8.4 of Rosen [211]. or
in Chapter V of Koblitz [128] .
First note that if p is an odd prime, and a and q are positive integer s
then the number of incongruent solutions of the congruenc e
r°-r - 1 (mod p" )
is gcd(q. pa
l (p - 1 )) .
Let n - 1 = d . 2), where d is an odd positive integer and ,j is a positive
integer. For a to be a strong pseudoprime to the base b, eithe r
bd - 1 (mod n)
Or
b2'd - -1 (mod n)
for some integer i with 0 < i < j - 1 . In either case, we have
b" -i = 1 (mod n .) .
Let the prime factorization of n be
q 1
rt = pr
P2?
. .
. pt
.
By the assertion made at the beginning of the proof, we know that there ar e
gcd (n - 1, p
` (pi - 1)) = gcd(n - 1, p, - 1)
incongruent solutions to the congruenc e
.r r-1 =1 (mod pt') .
i=1 .2, .-
.k .
Further, by the Chinese remainder theorem . we know that there are exactl y
flgcd(rt-1, pi -1)
t— ~
incongruent solutions to the congruence
x"_r E 1 (r od n) .
To prove the theorem, there are three cases to consider :

212
2 . Computational algorithmic. Number Theory
2 .2 Algorithms for Primalit. Testing
21 3
[1] the prime factorization of n contains a prime power p;
with exponent
a,.>2:
[2]n = pq_ with p and q distinct odd primes .
[3] n = prP2 • pt . with pi ,p>, • • .Pk distinct odd primes .
The second case can actually be included in the third case . We consider here
only the first case . Since
2
<
9
we have
Pi 1) C H(pt — 1)
i=
forn>9 .
Thus, there are at most (n — 1)/4 integers b, 1 < b < n — 1 . for which n is a
base-b strong pseudoprime and it can pass the strong test .
q
A probabilistic interpretation of Theorem 2 .2.11 is as follows :
Corollary 2.2.2. Let n > 1 be an odd composite integer and b be chosen
randomly from {2 . 3 
n—1}. Then the probability that it passes the strong
test is less than 1/4 .
From Corollary 2 .2.2. we can construct a simple . general purpose. polyno-
mial time primality test which has a positive (but arbitrarily small) probabil-
ity of giving the wrong answer . Suppose an error probability of e is acceptable .
Choose k such that 4—ti' < F . and select br . b_, . . , b ti. randomly and indepen-
dently from {2, 3, . . ,n. — 1}. If n fails the strong test on b i . i = 1.2, . . , k .
then it is a strong probable prime .
Theorem 2 .2 .12. The strong test (i.e .. Algorithm 2.2.2) requires, for n—1 =
2/d with d odd and for k randomly selected bases. at most k(2+j) logo steps .
If n is prime . then the result is always correct . If n is composite. then the
probability that ra passes all k tests is at most 1/4 6.
Proof. The first two statements are obvious . only the last statement requires
proof. An error will occur only when the n to be tested is composite and the
bases br . h2 . • • . b k chosen in this particular run of the algorithm are all non -
witnesses. (An integer a is a witness to the compositeness of n if it is possible
using a to prove that n is composite. otherwise it is a nonwitness) . Since the
probability of randomly selecting a nonwitness is smaller than 1/4 (by Corol-
lary 2 .2.2) . then the probability of independently selecting k nonwitnesses is
smaller than 1/46 . Thus the probability that with any given number
it, a
particular run of the algorithm will produce an erroneous answer is smalle r
than 1/4k.
hr the following list . we give some values of k and 1/4 6 for the purposes
of comparison :
1/4k
10
< 10 —6
2.5
< 10
' '
30
< 10 — ' s
50
< 10
30
100
< 10—6°
168
< 10
fo r
1000
< 10—602
Let n be a composite positive integer . Using the strong test . if we pick 10 0
different integers between 1 and n at random and perform the strong test
for each of these 100 bases, then the probability that n passes all the test s
is less than 4 —700 < 10—60, an extremely small number. In fact, it may be
more likely that a computer error was made than that a composite integer
passes all 100 tests. We conclude that for all practical purposes. we can test
primality in polynomial time .
The Generalized Riemann Hypothesis (GRH) for the Dirichlet L-function s
has the following important consequence (see also Niven. Zuckerman an d
Montgomery [174] or Rosen [2111) :
Conjecture 2 .2 .1 . For every composite positive integer n . there is a number
(base) b with 1 < b < 2(loga)2 such that n fails the strong test for the base
b .
If this conjecture is true . then the following result provides a rapid pri-
mality test :
Theorem 2.2.13. If the Generalized Rietnann Hypothesis (GRH) is true .
then there is an algorithm to determine whether or not a positive integer n
is prime using O((log a)') bit operations .
1
1
fJ gcd(n 1,
i=i
(2
9
n— 1
4

214
2. Computational/Algorithmic Number Theory
2.2 Algorithms for Primality Tes g
215
Proof. Let, b be a positive integer less than n . To perform the strong test
for the base b on n takes O((logo)) bit operations, because this test re -
quires that we perform no more than ((log a) I) modular exponentiations _
each using 0((logb)2 ) bit operations. Assume that the GRH is true . If n is
composite . then, by Conjecture 2.2.1 . there is a base b with 1 < b 2(logn) '-
such that n fails the strong test for
b . To discover this b requires less
than O((Iogn) 3
>
-O((logn) 2 ) = O((loga) 5) bit operations . Hence, usin g
O((log n)) bit operations, we can determine whether n is composite or prime .
Although very few composites can pass the strong pseudoprimality test .
such numbers do exist . For example . the composite n = 2047 = 23-89 can pass
the base-2 strong pseudoprimality test, because n — 1 = 2 1
- 1023 . d = 1023
and the sequence (2 .42) is 2 1023 = 1 (mod 2047), 2'-036 = 1 (mod 2047). So .
n = 2047 is a base-2 strong pseudoprime . Thus, from a pure mathematics
point of view. we cannot conclude that n is prime just by a strong primality
test .
Another probabilistic test for primality similar to (although not as goo d
as) the strong pseudoprimality test is Euler's pseudoprimality test ; it uses
the Jacobi symbol and relies on Eulers criterion (Theorem 1 .6.26) .
Theorem 2.2.14 (Euler's pseudoprimality test). Let n be a positive
integer greater than 1 and choose at random k integers 131 .b2 .''',bk. with
0 < b ;
< 11 . and gcd(b 1 . n) = 1 and compute
h," r)/"
~bi
(mod n), for i = 1,2, . . . ,k.
(2.48)
If (2.48) fails to hold for any i, then n is composite. The probability that n
is composite but (2 .48) holds for every i is less than 1/2 k .
Euler's pseudoprimality test is often called the Solovay-Strassen test . in
honour of its inventors Solosay and Strassen [244] . If the positive integer
n > 1 passes Euler's pseudoprimality test on base b, then n is called a base
b Euler probable prime . A Euler probable prime is called the base-b Eyler
pseudoprirne if it is composite .
Example 2 .2 .9 . Let n = 1105 = 5 - 13 . 17 and b = 2. Then we have
2
b`"—i)/2 rood n = 2(rro5—r)/2 mod 110 .5 = 1 and (
b
= 
= 1 . Thus.
n /
1105
2
1105
However. 1105 is not a base-2 strong pseudoprirne .
Remark 2.2.4. Since every base-a strong pseudoprime is a base-a Euler
pseudoprime. more composites pass Euler 's pseudoprimality test than th e
strong pseudoprimality test . although both require O( (log n)) bit operations .
2 .2 .4 Lucas Pseudoprimality Test
In this subsection. we shall study Lucas sequences and their applications t o
primality testing .
Let a. b be non-zero integers and D = a 2 — 4b. Consider the equation
a•'
a:c + b = 0: its discriminant is D = a= 4b, and a and 3 are the two
roots :
So
a+3=a.
a
3=~
D
(13=b.
We define the sequences (Lik ) and (IL ) by
a k
3k ;
Lt(a,b)
n
3
1k(a,b)=a k +3k . }
In particular . U0 (mb) = 0.t m((L_b)=1, while T'o(a, b
k > 2. we also have
L'k.(a,b) =at- k_ 1
k_ 2
I .k(a.b)=at)_1
bV k_2 .
The sequences
L (a, b) = (L k(a , b ))k> o
((Lb) = (
A (a , b ))k> o
are called the Lucas sequences associated with the pair (a, b), irr honour of
the French mathematician Lucas 13 . Special cases of Lucas sequences wer e
Francois Edouard Lucas (1842 1891) . was born in Amiens. France
and was educated at the Ecole Aorurale . one of the two most pres-
tigious French institutions of the time. After finishing his studies .
he worked as an assistant at the Paris Observatory, and later on .
he became a mathematics teacher at three Paris secondary schools .
He became the last bilges( prime record holder in the pre-computer
age, by discovering the 12th Nrersenne prime in 1876 . though it
was only confirmed in 1914. In the world mathematics community.
Lucas is perhaps best known for his work on Lucas numbers, th e
Lucas test for \lersenne prime and the Tower of Hanoi problem .
rt
b(0—1)/2
n) . Therefore . 1105 is a base-2 Euler pseudoprirne .
nod
a =
3=
(2.49)
(2 .50)
(2 .51 )
= a. For
= 2 . 1) (a . b
(252 )
(2.53)

216
2 . Computational/Algorithmic 5 umber Theory
2 .2 Algorithms for Primality Testing
21 7
considered by Fibonacci. Fermat. and Pell . among others. For example, the
sequence Ur (a, b) . k = 0. 1. corresponding to a = 1 . b = -1, was first
considered by Fibonacci, and it begins as follows :
0,1 .1.2 .3.5 .8.13 .21 .34.55, 89.144, 233.377. 610,
. .
These are called Fibonacci numbers . in honour of the Italian mathematician
Fibonacci" . The companion sequence to the Fibonacci numbers, still with
a = 1 . b = -1 . is the sequence of Lucas numbers: It) = Ital
. -1) = 2 . 1' =
hill,—1) = 1, and it begins as follows :
2 . 1. 3 . 4 . 7 . 11 . 18, 29, 47, 76.123 .199, 322.521 . 843 .
364 . 2207. 3571 .
5778,9349.15127 .
If a = 3 . b = 2 . then the sequences obtained are
U1.(3,2)=2 k -1
:
0.1.3.7. L5.31.63 127.255, 511 1023,2047, 4095, 819 16383, -
1),(3,2) = 2r + 1
:
2, 3, 5, 9.17.33 .65.129.257. 513. 1025, 2049, 4097, 8193, 16385 . . .
for k > O . The sequences associated with a =
2. b = -1 are called Pell
sequences; they begin as follows :
U0(2, -1) : 0 .1 .2.5.12, 29 . 70 .169. 408.985 .2378, 5741, 13860, 33461 .80782 ,
Vt. (2, -1) : 2 .2, 6 . 14, 34 .82.198 .478.1154. 2786, 6726.16238.39202.94642,
-
Now we are in a position to study some analogues of pseudoprimes i n
which a"' — 1 is replaced by a. Lucas sequence. Recall that odd composite
numbers n for which
0—' - 1 (mod n )
are called pseudoprimes to base a .
Leonardo Pisano Fibonacci (1170—1250) . is better known by his
nickname Fibonacci, but Fibonacci himself sometimes used th e
name Bigollo. which may mean good-for-nothing or a traveller .
Fibonacci ended his travels around the year 1200 and at that time
he returned to Pisa. There he wrote a number of important texts
which played an important. role in reviving ancient mathematica l
skills and he made significant contributions of his own . Fibonacci
lived in the days before printing. so his books were hand writ -
ten and the only way to have a copy of one of his books was to have another
hand-written copy made. Of his books we still have copies of Liber _4bbaci (1202) ,
Practica Geornetriae (1220). Flos (1225), and Liber Quadratorum. A problem in
the third section of Liber lbbaci led to the introduction of Fibonacci numbers an d
the Fibonacci sequence for which Fibonacci
is best remembered today .
Theorem 2 .2 .15 (Lucas theorem) . Let a and b be integers and put D =
•
4b O . Define the Lucas sequence {U0 } with the parameters D,, a, b by
U k
at —
(2 .54)
a
where a and 3 are the two roots of x2
ax + b = O . If p is an odd prime.
D
p { b and
-1, where ~ — ~ is a Jacobi symbol, then p U„-t .
The above theorem can be used directly to construct a primality test .
often called the Lucas test:
Corollary 2 .2 .3 (Converse of the Lucas theorem — Lucas test) . Let
n be an odd positive integer . If n { U0+1 . then n is composite .
Just as there are Fermat probable primes and Fermat pseudoprimes, w e
also have the concepts of Lucas probable primes and Lucas pseudoprimes .
Definition 2.2.5 . An odd positive integer n is called a Lucas probable prime
with D. a and b . if n I- b. (D ) = -1 and n U,r+r . A Lucas probable prim e
it
n is called a Lucas pseudoprime if n is composite .
Another different but equivalent, presentation of' Theorem 2 .2 .15 is as
follows :
Theorem 2 .2 .16. Let n be an odd positive integer ; e(n) the Jacobi symbol
(9
. and h(n) = n — e(n) . If it is prime and gcd(n. b) = 1 . then
Ugh„) E 0 (mod n). (2.55)
If it is composite, but (2.55) still holds, then n is called a Lucas pseudoprime
with parameters a and b .
Although Theorem 2.2.16 is true when (D)
= 1, it is best to avoid this
situation. A good way to avoid this situation is to select a suitable D such
that (--'W) = -1 . Two methods have been proposed (see Baillie and Wagstaff
[18]) :
(1) Let D be the first element of the sequence 5 .—7.9 . -11 .13 . . ' ' for which
D
-1 . Let a = 1 and b = (1 — D)/4 .
n
=
(2) Let D be the first element of the sequence
.5 .9. 13 . 17, 21, ' ' ' for which
(P
-1 . Let a be the least odd number exceeding
and b =
(a2 — D)/4 .

218
2 . Computational/Algorithmic Number Theory
2 .2 Algorithms for Primalitp Testing
219
The first 10 Lucas pseudoprimes found by the first method are
323 .
and the first 10 Lucas pseudoprimes found by the second method are :
323 ,
The most interesting thing about the Lucas test is that if we choose the
parameters D . a and
b as described in the second method, then the firs t
50 Carmichael numbers and several other base-2 Fermat pseudoprimes will
never be Lucas pseudoprimes (Baillie and Wagstaff [18]) . This leads to the
general belief that a combination of a strong pseudoprimality test and a Luca s
pseudoprimality test (or just a combined test . for short) alight be an infallible
test for primality. Since to date, no composites have been found to pass such
a combined test, it is thus reasonable to conjecture that :
Conjecture 2.2.2. If n is a positive integer greater than 1 which can pas s
the combination of a strong pseudoprimality test and a Lucas test, then to is
prime .
The advantage of the combination of a strong test and a Lucas test seem s
to he that the two probable prime tests are independent . That is, a being a
probable prime of' the first type does not affect the probability of' a . being a.
probable prime of the second type . In fact. if n is a strong pseudoprime (to
a. certain base), then n is less likely than a typical composite to be a Luca s
pseudoprime (with the parameters a and b), provided a and b are chosen
properly, and vice versa. If a passes both a strong test and a Lucas test, we
can be more certain that it is prime than if' it merely passes several strong
tests, or several Lucas tests . Pomerance, Selfridge and Wagstaff [192] issued a
challenge (with a total prize now $620) for an example of a composite number
which passes both a strong pseudoprimality test base 2 and a Lucas test, or
a proof that no such number exists . At the moment, the prize is unclaimed :
no counter example has yet been found .
There is . however, a very efficient and deterministic Lucas test specifi-
cally- for Mersenne prunes. known as the Lucas Lehmer test, after the French
mathematician Lucas who discovered the basic idea in 1876 and the Ameri-
can mathematician Lehmer l '' who refined the method in 1930 . based on the
following theorem :
Derrick H. Lehmer (1905 1991) . perhaps the father of computa-
tional number theory. was born in Berkeley . California . He received
his bachelor's degree in physics from the University of California .
Berkeley, whereupon he went to the University of Chicago for grad-
uate studies in number theory with L . E . Dickson. But since he
didn 't like working under Dickson he went to Brown Universit y
in Providence. Rhode Island to study for a PhD . He served as a
acuity member in the California Institute of Technology, Lehigh
Theorem 2 .2 .17 (Lucas–Lehmer theorem for Mersenne primes lI„) .
Let a = 2 and
b = -2. Consider the associated Lucas sequences (U L )L>() .
(1 .) k.>o . with discriminant D = 12 . Then -
lI„ is prime if and only if'
y
I C\+1 > .
Example 2.2.10. First we notice that the Lucas sequence (2 -2) begins
as follows :
2.2.8.20, 56, 152 . 416. 1136. 3104, 8480, 23168, 63296. 172928 ,
472448, 1290752, 3526400, 9634304, . . .
.
Now suppose we wish to test the primality of ti = 2 7 – 1. Compute I
for '\'=2' -1 :
1),2 - 127/ 2
= Isa
= 861551776580078726854108774 4
0 (mod (2' -1)) ,
so by Theorem 2 .2 .17,
=
– 1 is a. prime .
For the purpose of computation . it is convenient to replace the Luca s
sequence (I'ti.)r.>>o by the following Lucas Lehmer sequence (L I. ) k> 1 , defined
recursively as follows :
Lo= 4
LA.+1 = LA. – 2 .
(2 .56)
The Lucas–Lehmer sequence begins with
4.14.194 .37634,1416317954.2005956546822746114 ,
402386166774103602282563.56.56102100994 .•x •
The reason that we can replace the Lucas sequence I-k(2 . -2) by the Lucas–
Lehmer sequence L k is based on the following observations :
Lo = I -2 / 2
Lk—r=I>42'
University and the University of Cambridge before joining the Mathematics De -
partment at Berkeley in 1940 . He made many significant contributions to numbe r
theory. and also invented some special purpose devices for number-theoretic com -
putations. some with his father who was also a mathematician at Berkeley . The
breadth of Lehmer's mathematical work is best judged lry the 17' subject head-
ings he chose for the 1981 publication of his Selected Papers . He was interested i n
primality testing throughout his life. He is perhaps best known for his sharp and
definitive form of the Lucas primality test for Mersenne primes . Lehmer was also
involved throughout his life with the theory and practice of integer factorization .
(Photo by courtesy of the American Mathematical Society.)
w+rl/ 2
(2.57)

220
2 . Computational/Algorithmic Number Theory
2.2 Algorithms for Prisnality Tes g
22 1
Example 2 .2 .11. The following example shows how to calculate the Lucas-
Lehmer sequence (L i.) :
Lo = I2/4 = 8/2 = 4
L i = 4z2 /2 '2 2
= I
1 /222
= .56/4 = 14
L,' = 1[2)/223
[-
=1"8/2 1
= 3104/16 = 194
L3 =1 24/22'
[
- I ie/2s
= 9634304/256 = 3763 4
L i = 1[25/22' ,
= 132/2 rs
= 92819813433344/65.536 = 14163179.54
So Theorem 2.2.17 can be rewritten as follows :
Theorem 2.2.18 (Lucas-Lehmer test for Mersenne primes Al,) .
Let n be an odd prime . Then 2" - 1 is prime if and only if Al.,, divides L,,_2 .
That is .
L,a_2 = 0 (mod (2" - 1)) .
(2 .58)
Proof. There are several ways to prove this theorem (see . for example .
Knuth [123] and Ribenboim [198]) . Here we follow Ribenboim [198] :
Let Lo = 4 = 1 2 /2. Assume that L A._ 1 = 1 :2k/22'
.e /22' ' . Then
Lk = Li._r - 2
2
22'
22"
By Theorem 2.2.17. ll,,. is prime if and only if ,
M
divides
i'(nt„+r)1- =
= 22' Lo-2,
or equivalently, L o a-2 = 0 (mod (2" - 1)) .
Example 2 .2 .12 . Suppose we wish to test the primality of 2 7 - 1 : we first
compute the Lucas-Lehmer sequence {L,.} for 2' -1 (k = 0 .1 . .
.p- 2 = .5) :
Lo = 4
L 1 = 1 4
L2 -67
L3
42
Lo11 1
L5 = 0 (mod 127) .
Since L 7_2 = 0 (mod (2' - 1)), 2 7 - 1 is a prime .
Thus, a practical primality testing algorithm for Mersenne primes can
then be derived as follows :
Algorithm 2 .2 .3 . (Lucas-Lehmer Test for Mersenne Primes )
Initialize the value for p E Primes
L- 4
for i from 1 to p - 2 do
L+- L 2 – 2 (mod (2 P -1))
if L = 0 then 2t' - 1 is prim e
else 2" - 1 is composite
Remark 2.2.5. The above Lucas-Lehmer test for \Iersenne primes is ver y
efficient, since the major step in the algorithm is to comput e
L = L2 – 2 (mod (2P -1) )
which can he performed in polynomial time. But still . the computation re-
quired to test a single Mersenne prune Mr, increases with p to the order o f
O(p') . Thus, to test M2 ,.+1 would take approximately eight times as long as
to test llr with the same algorithm (Slowinski [241]) . Historically. it has re-
quired about four times as much computation to discover the next Mersenne
prime as to re-discover all previously known Mersenne primes. The search for
Mersenne primes has been an accurate measure of computing power for th e
past two hundred years and . even in the modern era, it has been an accurat e
measure of computing power for new supercomputers .

222
2 . Computational/Algorithmic Number The
2.2 Algorithms for Primality Testing
223
2.2.5 Elliptic Curve Test
hi this subsection. we introduce a novel application of elliptic curves to pri-
mality testing. called the elliptic curve test . Although the elliptic curve pri-
mality test is still probabilistic, its answer is always correct: only the runnin g
time is random. In practice. the expected running time is finite ; it is possible
that the algorithm does not terminate but. the probability of that occurrin g
is zero .
First let us introduce one of the very useful converses of Fermat`s littl e
theorem :
Theorem 2 .2 .19 (Pocklington's theorem) . Let .s be a divisor of N - 1.
Let a be an integer prime to
.y such that
a v-r =_ 1 (mod A')
gcd(a(-r)/a . N) = 1
for each prime divisor q of s. Then each prime divisor p of ti satisfies
p—1 (mod s) .
Corollary 2 .2.4. If .s >
- 1 . then N is prim e
A similar theorem can be stated for elliptic curves as follows .
Theorem 2.2.20 . Let N be an integer greater than 1 and relatively prim e
to 6. E an elliptic curve over 7Z/NZ. P a point on E, m and s two integer s
with s
m,. Suppose we have found a point P on E that satisfies mP = Or .
and that for each prune factor q of s, we have verified that (rn/q)P ~ Or .
Then, if p is a prime divisor of N. 1E(Z/pZ)l - 0 (mod s) .
Corollary 2 .2 .5 . If s > (' N + 1) 2 . then N is prime .
Combining the above theorem with Schoof's algorithm [221] which com-
putes E(7Z/pZ) in time O ((logp)s-F) . we obtain the following GK algorith m
due to GoldR asserrs and Kilian' (see Goldwasser and Kilian [85] and its new
version [86]) .
u;
Shafi Goldwasser obtained her PhD in Computer Science fro m
the University of California at Berkeley. She is currently the RSA
Professor of Electrical Engineering and Computer Science at the
Massachusetts Institute of Technology (MIT) . a co-leader of the
cryptography and information security group and a member o f
the complexity theory- group within the Theory of Computatio n
Group and the Laboratory for Computer Science . Goldwasser is
also Professor of Computer Science at the «-eizniann Institute of
Science. Israel . (Photo by courtesy of Prof. Goldwasser .)
' Joe Kilian is currently with the NEC research Institute in Princeton . He was a
PhD student at the MIT 's Lahoradory for Computer Science, with Goldwasser as
Algorithm 2 .2 .4 (Goldwasser-Kilian Algorithm) . For a given probabl e
prime N, this algorithm will show whether or not N is indeed prime :
[1] choose a nonsingular elliptic curve E over TG/NT), for which the number of
points to satisfies to = 2q, with q a probable prime ;
[2] if (E.m) satisfies the conditions of Theorem 2 .2.20 with .s = in, then
is
prime, otherwise it is composite ;
[3] perform the same primality proving procedure for q ;
[4] Exit .
The running time of the GK algorithm is analyzed in the following two the-
orems (Atkin and Nlorain [12]) :
Theorem 2.2.21 . Suppose that there exist two positive constants e l and c2
such that the number of primes in the interval [.r . .r + 2.c] . where .c(> 2), is
greater than c crf(log x) -` 2 , then the GK algorithm proves the primality of
_ "" in expected time O ((log y')"T''= ) .
Theorem 2 .2.22 . There exist two positive constants c3 and c. such that.
for all k > 2, the proportion of prime numbers N of k bits for which the
expected time of GK is hounded by C3(log NE' is at leas t
1-cy 2
A serious problem with the GK algorithm is that Schoof's algorith m
seems almost impossible to implement. In order to avoid the use of Schoof' s
algorithm . Atkinrs and klorain19 in 1991 developed a new implementation
method called ECPP (Elliptic Curve Primality Proving), which uses the prop-
erties of elliptic curves over finite fields related to complex multiplicatio n
his thesis advisor . His thesis Primality Testing and the Power ofNoisy Communi-
cation Channels, won the 1989 ACM Distinguished Dissertation Award and wa s
published by the MIT Press under the title Uses of Randomness in Algorithm s
and Protocols. in 1990 (see Kilian [120]) .
A. O . L . Atkin is currently Professor Emeritus at the University of Illinois a t
Chicago. He received his PhD in Mathematics from the University of Cambridg e
in 1952. Together with Bryan Birch . he organized the very successful 1969 Corn-
puters in Number Theory Conference in Oxford, England.
Francois Morain is currently with LIX Laboratoire dInformatique
de 1' Ecole Polvtechnique, France. He received his PhD in math -
ematics. more specifically in elliptic curve primality proving fro m
U niyersite de Lyon I in 1990 . The ECPP (Elliptic Curve Pri-
mality Proving) program . developed jointly with Atkin, is th e
most popular Primality testing program for large numbers of sev -
eral thousand digits in the public domain . (Photo by courtesy of
Dr. Morain .)
(2 .59 )
(2.60)

224
2 . Computational/Algorithmic Number Theory
2.2 Algorithms for Primality Test
225
(Atkin and Morain [12]) . We summarize the principal properties of ECPP a s
follows.
Theorem 2.2.23 . Let p be a rational prime number that splits as the prod-
uct of two principal ideals in a field K:: p = r, tt' with
r . 7 ' integers of K . Then
there exists an elliptic curve E defined over 7G/pZ having complex multipli-
cation by the ring of integers of K. whose cardinality i s
1n=AK(x—1)=(x—1)(x'—1)=p+1— t
with
t1 < 2 p (Hasse's Theorem) and whose invariant is a root of a fixe d
polynomial HU (X) (depending only upon D) modulo p.
For more information on the computation of the polynomials HD , readers
are referred to Morain [168] . Note that there are also some other importan t
improvements on the GK algorithm, notably the Adleman-Huang primalit y
proving algorithm [4] using hyperelliptic curves .
In the GK algorithm. it begins by searching for a curve and then computes
its number of points, but in the ECPP algorithm, it does exactly the opposite .
The following is a brief description of the ECPP algorithm .
Algorithm 2.2.5 (ECPP Algorithm) . Given a probable prime N, this al-
gorithm will show whether or not N is indeed prime :
[1] [Initialization] Set i +- 0 and No +- N .
[2] [Building the sequence] While N, > N,,,,, nn
[2 .1] Find a D ; such that N, = ar;x[ in K = .7(V–D, )
[2 .2] If one of the w(–D,) numbers
__m u
(rn,.
Nr; (w, -1) where
w,. is a conjugate of T) is probably factored goto step [2 .3] else got o
[2 .1] ;
[2 .3] Store D . N„ D;. w, . rn, . F, } where na,. F,N,+r . Here F, is a com-
pletely factored integer and \',_r a probable prime : set i <– i + 1 an d
goto step [2 .1] .
[3] [Proving] For i from k down to 0
[3.1] Compute a root j of HD , (N) = 0 (mod N,) ;
[3.2] Compute the equation of the curve E, of the invariant j and whos e
cardinality modulo N, is rra, ;
[3.3] Find a point P, on the curve E, ;
[3.4] Check the conditions of Theorem 2 .2 .23 with s = N,_1 and
[4] [Exit] Terminate the execution of the algorithm .
For the ECPP. only the following heuristic analysis is known (Morai n
[168])_
Theorem 2 .2 .24. The expected running trine of the ECPP algorithm i s
roughly proportional to O ((log h")' ) for some e > 0 .
One of the largest primes verified so for with the ECPP algorithm is
391587x2' ' 6 ' 93 – 1
which has 65087 digits. However. in practice, we normally can
malitv test in the following way.
Algorithm 2 .2 .6 (Practical Test) . Given an odd integer n, this algo-
rithm will make use of the probabilistic test and elliptic curve test to de-
termine whether or not ra is prime:
[1] [Primality Testing – Probabilistic Method] Use a combination of the stron g
pseudoprimality test and the Lucas pseudoprimality test to determine if n i s
a probable prime . If it is, go to [2], else report that rr is composite and g o
to [3] .
[2] [Primality Proving – Elliptic Curve Method] Use the elliptic curve method
(e.g., ECPP) to test whether or not a. is indeed a prime . If it is, then repor t
that n is prime, otherwise report that as is composite .
[3] [Exit] Terminate the algorithm .
2 .2 .6 Historical Notes on Primality Testing
In this subsection, we summarize some computational complexity results o f
primality testing.
Determining if a given integer N E N is composite is easily seen to be in
VP
simply multiply a nontrivial pair of integers whose product is N . In
1975 Pratt showed that determining primality is also in .VP by exhibiting
polynomial-time verifiable certificates of primality . (The basic idea is to prove
N prime by showing that the multiplicative group of integers modulo N is
cyclic of order N – 1 : this requires a generator for the group. as well as a
primality- proof for each prime factor of N–1. which can be found recursively.)
Finding these certificates . however, requires the ability to factor, a proble m
even harder than primality testing .
Miller [162] in 1976 showed that primality could be tested in polynomia l
time if the following conjecture (a version of the Generalized Riemann Hy-
pothesis GRH) holds :
Let gcd(a . A%) = 1, then when .r —t x.
)rime .
r G .r, r= a
mod Al
Li(r,)
out a pr

226
2. Computational/Algorithmic Number Theory
2.2 Algorithms for Primality- Testing
227
Miller's result can be stated as follows (Bach, Giesbrecht and McInnes [14]) .
For l E N. let v 2 (1) = max{e : 2'
l} . Also, for a E N. let L(a) be the Boolean
expression :
L(a) = [an'—r E. 1 (mod N) and dk; < v2(N — 1) .
x- i
a =f - 1 
> a
tat, = + 1 (mod N)] .
(2.61 )
Now assume that N is odd . and restrict a to be nonzero modulo N . Miller
showed that if the GRH holds. then there is some c > 0 such that N is prim e
if and only if for all such a with 1 < a < c(log N) 2 . L(a) holds. Because L(a)
can he checked in C)((log N)3 ) steps . this shows that. the set of primes is in
P (assuming GRH) .
Shortly after Miller published his results. Solovav and Strassen [244] noted
that N is prime if and only if every a with gcd(a, N) = 1 satisfie s
a(N.-r)/2
(a) (mod N)]
.
(2.62)
Furthermore, they observed that if N is composite, then M(a) holds for a t
most half of the residues modulo N . One could therefore obtain statistica l
evidence of primality by choosing a from {1, ' ' ,N — 1} at random, an d
testing M(a) . Because 1l1(a) will always hold when N is prime, and can b e
checked in 0 ((logN) 3) steps, this shows that the set of composite number s
belongs to RP . Rabin [195] showed that Miller's predicate L(a) has the same
property, and is somewhat more reliable. He proved that if a is chosen a t
random from {1, • . • ,N — 1} and N is composite . then the probability tha t
L(a) holds is at most 1/4 .
Recent work has the goal of proving primality quickly. unconditionally ,
and without error . The fastest known deterministic algorithm, abbreviated
the APRCL test, originally invented in 1980 by Adleman . Pomerance and
R.unely [3] (known as the APR test), but further simplified and improve d
in 1981 by Cohen and Lenstra [50] using the idea of Jacobi sums . can deter -
mine the primality of N in time 0 ((logN) '(10gloglotN)) for some suitable
constant c > O . The exponent c(log log log N) is an extremely slowly growin g
fun ction: for example, for the APR test . if N has a million decimal digits .
then log log log N is only about 2 .68. Riesel in 1985 reported an algorithm
based on this method . which, when implemented on the CDC Cyber 170-75 0
Computer. was able to deal with 100-digit numbers in about 30 seconds and
200-digit numbers in about 8 minutes . It is now possible to prove the primal-
ity of numbers with 1000 digits in a not too unreasonable amount of time . Of
course. the APRCL test does not run in polynomial time. nor does it provid e
polynomial-length certificates of primality .
In 1986. another modern primality testing algorithm. based on the theory
of elliptic curves was invented, first, for theoretical purposes by Goldwasser
and Kilian [85]. and then considerably modified by Atkin and implemented
by Atkin and Morain [12] ; we normally call Atkin and Morain's version the
ECPP (Elliptic Curves and Prinnality Proving) test . The ECPP test is also
practical for numbers with 1000 digits . and possibly with several thousan d
digits. The expected running time for ECPP is 0 ((log NM . hence. is poly-
nomial time. but this is only on average, since for some numbers the runnin g
time of ECPP could be much larger . A totally impractical version based on
Abelian varieties (higher dimensional analogs of elliptic curves) was give n
by Adleman and Huang [4] in 1992 ; they proved that without hypothesis ,
primality testing can be done in random polynomial time. In other words .
they proved that there exists a random. polynomial time algorithm that ca n
prove whether or not a given number N > 1 is prime. Note that both th e
ECPP test and the Adleman Huang test belong to the probabilistic com-
plexity class APP . that is, they always give the correct answer ; only running
time depends on chance and is expected to be polynomial .
More recently, Konyagin and Pomerance proposed several algorithms that
can find proof's of primality in deterministic polynomial time for some primes .
Their results do not rely on any unproven assertions such as the Riemaa m
Hypothesis, but their algorithms need the complete prime factorization of
p — 1 in order to determine the primality of p .
Finally, we summarize some of the main complexity results in primality
testing as follows :
(1) Primes/Composites E EXP ; just try all the possible divisors .
(2) Composites E A"P ; guess a divisor .
(3) Primes E NP : Pratt (1975) .
(4) Primes E P: Miller (1976) ; assuming the Extended Riemann Hypothesis .
(5) Composites E RP ; Rabin (1976); using Miller's randomized algorithm .
(6) Primes E super-'P ; the APR.CL test, due to Adleman . Pomerance and
Rumely (1980), and Cohen and Lenstra (1981) .
(7) Primes E 2PP : the Elliptic Curve Test, due to Goldwasser and Killia n
(1985) . and to Atkin and Morain (1991) ; not yet proved to work on al l
primes .
(8) Primes E ZPP: Hyperelliptic Curve Test . due to Adleman and Huan g
(1992); does not rely on any hypothesis . but is totally non-practical .
(9) Primes E P: Konyagin and Pomerance (1997) ; only for some primes .

228
2 . Computational/Algorithmic Number Theory
2 .3 Algorithms for Integer Factorization
22 9
21.
2 .3 Algorithms for Integer Factorizatio n
Of all the problems in the theory of numbers to which computers have been
applied, probably none has been influenced more than of factoring.
Huc,n C . «''LLIAvl s
The Influence of Computers in the Development of Number Theory [255]
2 .3 .1 Complexity of Integer Factorization
According to the Fundamental Theorem of Arithmetic (Theorem 1 .2.8), any
positive integer greater than one can be written uniquely in the following
prime factorization (prime decomposition) form :
a, a,
a
n = pi
Tz
. . .pt
(2 .63)
where pl < P2 < • • ' < Pk are primes and ak positive integers .
The so-called integer factorization problem (IFP) is to find a nontrivial facto r
f (not necessarily prime) of a composite integer n. That is.
Input :
n E N> i
Output
:
f such that f n .
Clearly. if there is an algorithm to test whether or not an integer n is a .
prime. and an algorithm to find a nontrivial factor f of a composite intege r
n. then there is a simply recursive algorithm to compute the prime powe r
decomposition of 'V expressed in (2 .63), as follows :
(1) find a nontrivial factor f of N ;
(2 apply the algorithm recursively to f and N/f :
(3) put the prime power decompositions of f and N/f together to get th e
prime power decomposition of N .
There are, in fact, many algorithms for primality testing and integer factor-
ization : the only problem is that there is no known efficient (deterministic
polynomial-time) algorithm for either primality testing or integer factoriza-
tion .
Primality testing. and particularly integer factorization, are very impor-
tant in mathematics. Gauss [82] wrote in 1801 the following famous state-
ments in his most profound publication Disquistiones Arithrneticae:
The problem of distinguishing prime numbers from composite num-
bers and of resolving the latter into their prince factors is known to b e
one of the most important and useful in arithmetic .
. . . the dignity of
science itself seems to require that every possible means be explore d
for the solution of a problem so elegant and so celebrated .
But unfortunately, ptimaht}. testing, and particularly integer factorization ,
are computationally intractable (Adleman [2]) . as Knuth20 explained in his
encyclopaedic work [123] :
It is unfortunatelynot a simple matter to find this prime factorization
of n, or to determine whether or not n is prime. therefore we
should avoid factoring large numbers whenever possible .
In fact, no deterministic or randomized polynomial-time algorithm has been
found for integer factorization. nor has anyone proved that there is not an
efficient algorithm" . Despite this. remarkable progress has been made in
recent yea's. and mathematicians (at least some) believe that efficient pri-
mality testing and/or integer factorization algorithms are somewhere aroun d
the corner waiting for discovery. although it is very hard to find such algo-
rithms. Generally speaking, the most useful factoring algorithms fall into one
of the following two main classes (Brent [37]) :
(1) The running time depends mainly on the size of X . the number to b e
factored. and is not strongly dependent on the size of the factor p found .
Examples are :
(i) Lehman's method [139] . which has a rigorous worst-case running
time bound Cp (NI /3-') .
(ii) Shanks' SQUare FOrm Factorization method SQUFOF . which has
expected running time 0 (N'
I ) .
(iii) Shanks' class group method . which has running time 0 (N I / 1 )
20
Donald E. Knuth (1938– ), studied mathematics as an undergradu -
ate at Case Institute of Technology, and received a PhD in Mathe -
matics in 1963 from the California Institute of Technology. Knuth
joined Stanford University as Professor of Computer Science in
1968 . and is now Professor Emeritus there . Knuth received in 1974
the prestigious Turing Award from the Association for Comput e
Mg Machinery (ACM) for his work in analysis of algorithms an d
particularly for his series of books, TAOCP . (Photo by courtes y
of Prof. Knuth .)
For primality testing . although we also do not have a
truly deterministi c
polynomial-time algorithm . we do have randomized polynomial-time algorithms :
this explains partly that integer factorization is much harder than primality test-
ing. although both of them are computationally intractable (in the sense that n o
deterministic polynomial-time algorithm exists for both of them) . The followin g
fact about randomized computation is important in public key cryptography ,
which will be studied in detail in the next chapter . A problem is said to be easy
if there is a randomized polynomial-time algorithm to sol ve it, otherwise, it is
hard. For example. there is a randomized polynomial-time algorithm for the test
of primality of an integer, so the primality testing problem is regarded as easy.
However. there is no randomized polynomial-time algorithm for factoring a larg e
integer, so the integer factorization problem is hard .
(2 .64)

230
2. Computational/Algorithmic Number Theory
2.3 Algorithms for Integer Factorization
231
(iv) Continued FRACtion (CFRAC) method. which under plausible as-
sumptions has expected running time
O (exp (c\/logNloglog :N ) ) = O (A'
log
/logN )
where c is a constant (depending on the details of the algorithm) ;
usually c =
ti 1 .414213562 .
(v) Multiple Polynomial Quadratic Sieve (MPQS), which under plausi-
ble assumptions has expected running tim e
O (exp (cOogNlog logN )) = O (AT( Vic% log nlogN )
where cis a constant (depending on the details of the algorithm) ;
usually c =  
1 .060660172 .
2f ti
(vi) _Number Field Sieve (NFS), which under plausible assumptions has
the expected running tim e
C) (exp (c /log N /(log log N) 2 )) .
where c = (64/9) 0/3
1 .922999427 if GNFS (a general version
of NFS) is used to factor an arbitrary integer N . whereas c =
(32/9) 0/ '
.: 1 .526285657 if SNFS (a general version of NFS) is use d
to factor a special integer N such as N = r e + s . where r ands are
small . r > 1 and e is large. This is substantially and asymptotically
faster than any other currently known factoring methods .
(2) The running time depends mainly on the size of p (the factor found) of
N. (We can assume that p <
.) Examples are :
(i) Trial division, which has running time O (p(logN) 2) .
(ii) Pollard's p-method (also known as Pollard's
"rho" algorithm) .
which under plausible assumptions has expected running time
O (p0/'(log N)') .
(iii) Lenstra's Elliptic Curve Method (ECM), which under plausibl e
assumptions has expected running tim e
C') (exp (c~/logploglogy) (log ) 2) .
where c ti 2 is a constant (depending on the details of the algorithm) .
The term O ((log \r)') is a generous allowance for the cost of performin g
arithmetic operations on numbers which are O(log 'y') or O ((log N)' )
bits long: these could theoretically be replaced by C) ((log N)0'-`) for any-
e>0 .
In practice. algorithms in both categories are important . It is sometimes
very difficult to say whether one method is better than another . but it is
generally worth attempting to find small factors with algorithms in the sec-
ond class before using the algorithms in the first class. That is, we could first
try the trial division algorithm . then use some other methods such as NFS .
This fact shows that the trial division method is still useful for integer fac-
torization. even though it is simple. In the subsections that follow, we shal l
introduce some of the most useful and widely used factoring algorithms .
Remark 2 .3 .1 . As mentioned previousely, an algorithm is of exponentia l
complexity. if its required running time i s
O (X'),
(2.65)
where a typical value fore would be between 0 .1 and 0.5. But note that w e
usually do not regard the type of complexity
C)(N'(l''l)
= O (No
/log log N/log N )
= O (exp (clog _ r log log N))
(2 .66)
as a truly exponential complexity : we normally call it subexponential corn-
plexity. The relationship between the polynomial . superpolvnomial. subex-
ponential, and exponential complexities . together with some examples . can
be shown as follows :
O ((log N) 1 )
Polynomial
<—
Euclid's algorithm
n
.
Superpolvnomial —
APRCL test
n
n
0 (NOVloglog N/logN ) ~.
Subexponential
MPQS factoring
n
n
O (N`)
« Exponential 
 
. Trial divisions
Remark 2 .3 .2 . It is sometimes convenient to use some short expressions t o
denote subexponential complexity ; one such short expression is the following :
L,y'(7,c)
<I r exp (c(logAT(log logN) 0–`) .
So, in this notation, we could, for example, write
(2.67)
T(CFRAC)
C) (L A. (1/2, f)) ..
(2 .68 )
T(ECM)
O (Lr (1/2, f) . (log N) 2) ,
(2 .69)
T(l1PQS)
O (L N (1/2, 3/(2■/'j)))
.
(2 .70)
T(GNFS)
C) (L, . (1/3, 64/9)) .
(2 .71 )
T(SNFS)
C) (L,A. (1/3, /32/9)) .
(2 .72)
n
C) ((log N)c log log log N )

232
2. Coniputational/Algorithmic Number The o
Note also that some authors prefer to use the following short notation
L(N) dg
N log log
(2.73)
In this notation . we could . for example write
T(CFRAC) = O (L(,)2+"(r)1 ,
(2.74)
T(ECM) = O (L(p)'-<,,r
. (log \") 22) ,
(2.75)
T(MPQS) = O (L(ti-)r±
n) .
(2.76)
In order to avoid any possible confusion in this book we shall use the ordinary
full notation.
Remark 2 .3 .3. For primality testing .. although we still do not have a. truly
deterministic polynomial-time algorithm . we do have randomised polynomial-
time algorithms . However, there is no known deterministic. or even ran-
domised polynomial time, algorithm for finding a factor of a given composit e
integer n. This empirical fact is of great interest in public key cryptography .
2 .3 .2 Trial Division and Fermat Method
(I) Factoring by Trial Divisions . The simplest factoring algorithm is th e
trial division method, which tries all the possible divisors of n. to obtain its
complete prone factorization :
n = prom2
. . p
p C p2 <
. . . < pt .
(2.77)
The following is the algorithm :
Algorithm 2.3.1 (Factoring by trial divisions) . This algorithm tries t o
factor an integer it > 1 using trial divisions by all the possible divisors of n .
[1] [Initialization] Input It and set t - 0,
k <— 2 .
[2] [n = 11 If n = 1, then goto [5] .
[3] [Compute Remainder]
q - n/k and r
n (mod k) .
If r
0, goto [4] .
t
t + 1 , pr <— k, n
q, goto [2] .
[4] [Factor Found?]
If q > k, then k <— k + 1 . goto [3] .
t<— t+1 ; pr <—ra .
2.3 Algorithm
233
[5] [Exit] Terminate the algorithm .
Exercise 2.3.1 . Use Algorithm 2.3.1 to factor n = 2739 .
An immediate improvement of Algorithm 2 .3.1 is to make use of an aux-
iliary sequence of trial divisors :
2=do <di <d9 <d i <
(2.78)
which includes all primes <
n (possibly some composites as well if it is
convenient to do so) and at least one value di. > a . The algorithm can be
described as follows :
Algorithm 2.3.2 (Factoring by Trial Division) . This algorithm tries to
factor an integer n >
1 using trial divisions by an auxiliary sequence of tria l
divisors .
[1] [Initialization] Input n and set t
0, k r- O .
[2] [n = 1?] If n = 1, then goto [5] .
[3] [Compute Remainder]
q -- n/dk and r <— n (mod dA,) .
If r IQVQ=? .
t F t + 1,
pt
<— da., n, <— q, goto [2] .
[4] [Factor Found?]
If q > da., then k - k + 1, and goto [3] .
t<— t+1 ; pi <— n. .
[5] Exit : terminate the algorithm .
Exercise 2 .3 .2 . Use Algorithm 2 .3 .2 to factor n = 2759 ; assume that we
have the list L of all primes < [x/2759] = 52 and at least one >
n, that is ,
L = {2 .3.5, 7,11.13,17,19, 23. 29, 31, 37, 41, 43.47, 53} .
Theorem 2 .3 .1 . Algorithm 2.3.2 requires a running time in
O(max (pt—r
{/J.Ti
If a prfmality test between steps [2] and [3] were inserted, the running time
would then be in O (pr—r) . or O (Ap'p-r ~ I if one does trial division only b
y—t \
I
primes, where pr- t is the second largest prime factor of it .
The trial division test is very useful for removing small factors . but i t
should not be used for factoring completely, except when n is very small, say,
for example, n < 10s .

234
2. Computationa1/ .4lgorithniic Number Theory
2 .3 Algorithms for Integer Factorizatio
235
(II) Fermat's Factoring Method. Now suppose n is any odd integer (if
n were even we could repeatedly divide by 2 until an odd integer resulted) .
If n = pq, where p < q are both odd. then by setting x = z (p + q) and
y = (q p) we find that xt= :x•' - y' _ (x +y)(a. y) . or y' = a'
It . The
following algorithm tries to find n = pq using the above idea .
Algorithm 2.3.3 (Fermat's factoring algorithm) . Given an odd intege r
n > 1, then this algorithm determines the largest factor <
n of n .
[1] Input nandsetk4-[ n]+1,y
k-k-n, de l
[2] If [Al =
y goto step [4] else y f- y + 2 • k + d and d <- d + 2
[3] If [A < n./2 goto step [2] else print No Factor Found" and goto [5 ]
[4] x 4—
+ y, y
y, print x - y and :c + y, the nontrivial factors of n
[5] Exit: terminate the algorithm .
Exercise 2 .3.3. Use the Fermat method to factor n. = 278153 .
Theorem 2.3.2 (The Complexity of Fermat's Method) . The Fermat
n+ 1
method will try as many as
2
n arithmetic steps to factor n. that is .
n.+ 1
it is of complexity 0  
n
2.3.3 Legendre's Congruence
In the next two subsections, we shall introduce three widely used genera l
purpose integer factorization methods, namely . the continued fraction method
(abbreviated CFRAC) . the quadratic sieve (abbreviated QS) and the number
field sieve (abbreviated NFS) . By a general purpose factoring method . we
mean one that will factor any integer of a given size in about the same time
as any other of that size. The method will take as long . for example. to split
a 100-digit number into the product of a 1-digit and a 99-digit prime, a s
it will to split a different number into the product of two 50-digit primes .
These methods do not depend upon any special properties of the number o r
its factors .
The CFRAC method, as well as other powerful general purpose factorin g
methods such as the Quadratic Sieve (QS) and the Number Field Sieve (\FS) .
makes use of the simple but important observation that if we have two integer s
.r and y such that
= y'" (mod N), 0<<<A, x y, ar+y
N, (2.79)
then gcd(:r y. l') and gcd(x + y, N) are possibly nontrivial factors of N .
because N
(x + y) (x - y), but N { (x + y) and N { (x - y) . The congruence
(2.79) is often called Legendre's congruence . So, to use Legendre's congruence
for factorization, we simply perform the following two steps :
[1] Find a nontrivial solution to the congruence x 2 = y 22 (mod X) .
[2] Compute the factors di and d2 of l" by using Euclid's algorithm :
(di . d2) = (gcd(;r + y. X) . gcd(x - y . Ai)) .
Example 2.3.1 . Let N = 119 . 122 mod 119 = 52 mod 119 . Then
(d,,d>) = (gcd(12 + 5.119), gcd(12 - 5.119)) = (17.7) .
In fact . 119=7 . 17 .
The best method for constructing congruences of the form (2 .79) starts
by accumulating several congruences of the form
(mod _N) .
(2 .80)
Some of these congruences are then multiplied in order to generate square s
on both sides (Montgomery [167]) . We illustrate this idea in the followin g
example .
Example 2 .3 .2 . Let N = 77. Then, on the left hand side of the following ta-
ble ; we collect eight congruences of the form (2 .80) over the prime factor bas e
FB = {-1,2, 3 .5} (note that we include -1 as a "prime" factor) ( the right .
hand side of the table contains the exponent vector information of v( .1 1) and
v(B;) modulo 2 .
45 = 32
5
-32 = -2'
.<=> (0' 0 0 1) - (1 1 0 0)
50 = 2 . 5''
_
-27 = -33
(0 1 0 0) _ (1 0 1 0)
72 = 2' 3 . 3'
-5
i;=> (0 1 0 0) E (1 0 0 1)
~
75 = 3
5-
-2
—> (0 0 1 0) = (1 1 0 0 )
80=2
.5
3
x(0001)-(0010 )
125 = 5'
=
48 = 2
3
(0 0 0 1) E (0 0 1 0)
320 = 26, 5
=
243 = 3'
(0 0 0 1) _ (0 0 1 0)
384 = 2r
3
-1
(0 1 1 0) _ (1 0 0 0)
Now we multiply some of these congruences in order to generate squares o n
both sides: both sides will be squares precisely when the sum of the exponen t
vectors is the zero vector modulo 2 . We first multiply the sixth and seventh
congruences and get :
125=5 3
E
48=2 c
. 3
~>
(0001) 
_ 
(0010 )
320 = 26 . 5
=
243 = 3'
(0 0 0 1)
-
(0 0 1 0 )
11
11 1
 (0000) 
(0000)
Since the sum of the exponent vectors is the zero vector modulo 2 . we find
squares on both sides :

236
2 . Computational/Algorithmic Number Theory
2 .3 Algorithms for Integer Factoriza.tio
23 7
53 . 26 . 5 = 2a . 3 . 3'
(52 . 23)2 = (22 . 33 )2
and hence we have gcd( 52 . 23 ± 22 . 33 , 77) = (77, 1), but this does not spli t
77, so we try to multiply some other congruences, for example, the fifth and
the seventh, and get :
80=2`x . 5
3
(0001)
_
(0010 )
320 = 26 . 5
243 = 35
(0 0 0 1) - (0 0 1 0)
1111
1 -1-
(o 000)
(0000)
The sum of the exponent vectors is the zero vector modulo 2 . so we find
24 . 5 . 26 . 5-3
3' x(2' . 5)2 -(33 )2
and compute gcd(23 . 5 ± 33, 77) = (11, 7) . This time, it splits 77. Once we
split N . we stop the process . Just for the purpose of illustration . we try one
more example, which will also split N .
45=3 2 . 5
-
-32=—2'
(0001)
_
(1100)
50 = 2 . 52
-27 = -3 3
(0 1 0 0)
(1 0 1 0)
75=3 . 5-
-2
(0010)
-
(1100)
320=2 6 . 5
243=35
(0001)
(0010)
384 = 2 7 . 3
-1
(0 1 1 0)
(1 0 0 0)
111 1
(0000)
111 1
(0000)
So we hav e
32 -5-2 .52 -3-52 . 26 . 5 . 27 . 3
-20 . —33 . —2 .3 '3 —1
(2' . 32 .53 ) 2 E (23 . 31 )2 ,
thus gcd(2 7 . 32 . 53 ± 23 . 34 , 77) = (7,11) .
Based on the above idea, the trick . common to the CFRAC, QS and NFS .
is to find a congruence (also called a relation) of the form
( — 1)eok
, k
E
ezr.
' KT
e
k
xk -
pr h2 "
(mod N),
(2.81)
where each p; is a `"small" prime number (the set of all such p t . for 1 <
i < m ; forms a factor base . denoted by FB) . If we find sufficiently many
such congruences . by Gaussian elimination over Z/2Z we may hope to find a
relation of the for m
Fk. (eok . e l k . e2k., . . . , e ,
(0.0 .0 
0) (mod 2) .
(2.82)
1<k<n
where e is either 1 or 0. and then
1<k<a
y = (—1)]j4
. . . K',"
where
E ek(eOk
lk, e2k- .
,emk-)= 2(eo .
iM 1 . ti.2 .
. . .v, ) .
(2 .85)
k
It is clear that. we now have x 2 - y 22 (mod N) . This splits N if, in addition .
x +y (mod N) .
Now we are in a position to introduce our first general purpose factorin g
method, the CFRAC method .
2.3.4 Continued FRACtion Method (CFRAC )
The continued fraction method is perhaps the first modern. general purpose
integer factorization method . although its original idea may go back to M .
Kraitchik in the 1920s. or even earlier to A. M. Legendre. It was used by D .
H. Lehmer and R. E. Powers to devise a new technique in the 1930s, howeve r
the method was not very useful and applicable at the time because it wa s
unsuitable for desk calculators. About 40 years later . it was first implemented
on a computer by M . A . Morrison and J . Brillhart [169], who used it to
successfully factor the seventh Fermat number
F7 = 22' + 1 = 59649589127497217 . 570468920068512905472 1
on the morning of 13 September 1970 .
The Continued FRACtion (CFRAC) method looks for small values o f
111 - 1
that x 2 = TT' (mod N) has a. solution. Since IT' is small (specifi-
cally II- = O(')) . it has a reasonably good chance of being a product of
primes in our factor base FB. Now if TV is small and x'-
W ( mod N), then
we can write x2 = IT - + kNd2 for some k and d. hence (x/d)2 — kN = T17d2
will be small. In other words, the rational number x/d is an approximation
of 3k N. This suggests looking at the continued fraction expansion of 3k N.
since continued fraction expansions of real numbers give good rational ap-
proximations. This is exactly the idea behind the CFRAC method! We first
obtain a sequence of approximations (i .e . . convergents) P,/Q; to 3kN for a
number of values of k, such that
p .
3k N —
<_ ~ 1)
(2.86)
Putting IT'; = Pr' — (MN, then we have
TT' _ ( I'r +Qr 3k:N)(P, — Q, 3k_N)
2Q,/kA--1—1
2 3kN .
(2 .87)
Q,
Hence, the P,2 mod N are small and more likely to be smooth, as desired .
Then, we try to factor the corresponding integers Tha =
W kA.- over our
factor base FB ; at each success, we obtain a new congruence of the form
(2.83)
(2.84)

238
2 . Computational/Algorithmic Number Theory
2.3 Algorithms for Integer Factorization
239
P2 = TT",~ .rz(
1)<,..p<1'p`-> . . .1
(mod N) .
(2.88)
Once we have obtained at least m + 2 such congruences, by Gaussian elim-
ination over Z/2Z we have obtained a congruence x 2 = y2 (mod N) . That
is. if (.r 1 . eot . ellI .
, e ,,,I ), "
. (.x i . c=or. e l r, "
.e,,.) are solutions of (2.88)
such that the vector su m
(e01,e11 . . . .
+ ' + (60r—
c,,,,.) = (2cf1 .2ei . . .
) (2.89)
is even in each component. then
= :r, 1 .r 2 . . . i, . (mod N)
(2.90)
q = ( 1)c~p~' . . .psi= (mod N)
(2.91)
is a solution to (2.79) . except for the possibility that .r E +y (mod N) . and
hence (usually) a nontrivial splitting of N .
Example 2.3.3. We now illustrate, by an example . the idea of CFRAC fac-
toring. Let N = 1037. Then x/1037 = [32 .4.1.15.3 .3.15 .1.4 .641 . The first
ten continued fraction approximations of x/1037 are :
Convergent P/Q
P2
N . Q2 := W
32/1
-13 = -13
129/4
49 = 72
161/5
-4 = -2L
2544/79 = 470/79
19 = 1 9
7793/242 = 534/242
-19 = -1 9
25923/805 - 1.035/805
4 = 22
396638/12317 = 504/910
-49 = -7 2
422561/13122 E 502/678
13 = 13
2086882/64805 = 438/511
-1 = - 1
133983009/4160642 E 535/198
13 = 13
Now we search for squares on both sides. either just by a single congruence .
or by a combination (i .e., multiplying together) of several congruences an d
find that
1292 = 72
gcd(1037. 129 + 7) = (17,61 )
103 .52 - 22
gcd(1037, 1035 ± 2) = (1037 .1 )
122 - 10352 E. 72
22
gcd(1037, 129 . 103.5 ± 7 . 2) = (61 .17)
161 2 . 5042 E (—1)2 . 22 . 7 2 
gcd(1037. 161 - 504 ± 2 - 7) = (17.61)
.502 2 . 535 2 E. 132
gcd(1037 502
335 + 13) = (1037, 1) .
Three of them yield a factorization of 1037 = 17 - 61 .
Exercise 2 .3 .4 . Ise the continued fraction expansion
31711=[41,2,1, 2,1,13.16.2,8.1,2 .2,2,2,2,1,8.2,16,13,1,,2,1..2,821
and the factor base FB = 1—1,2,3,51 to factor the integer 1711 .
It is clear that the CFRAC factoring algorithm is essentially just
a
continued fraction algorithm for finding the continued fraction expansio n
[qe. q1 
qti . - ] of Vk y', or the Pr. and Q,,. of such an expansion. In what
follows, we shall briefly summarize the CFRAC method just discussed abov e
in the following algorithmic form :
Algorithm 2 .3 .4 (CFRAC factoring) . Given a positive integer N and
a
positive integer k such that kN is not a perfect square, this algorithm tries to
find a factor of N by computing the continued fraction expansion of ../key' .
[1] Let N be the integer to be factored and k any small integer (usually 1) ,
and let the factor base, FB, be a set of small primes {pi i p>, p } chosen
such that it is possible to find some integer
2;, such that x
= kIV (mod p;) .
Usually, FB contains all such primes less than or equal to some limit . Note
that the multiplier k >
1 is needed only when the period is short . For
example, Morrison and Brillhart used k = 257 in factoring F7 .
[2] Compute the continued fraction expansion [qo . q 1 , q2	
q,.] of \/kN for
a number of values of k . This gives us good rational approximations P/Q .
The recursion formulas to use for computing P/Q are as follows :
Po
qo
_
Qo
1 '
•
gogl + 1
Q1
q 1
P;
4tf'; -1 + Pi— 2
Q,
cI Qi—i + Q— 2
This can be done by a continued fraction algorithm such as Algorithm 1 .2.23
introduced in subsection 1 .2.5 of Chapter 1 .
[4] Try to factor the corresponding integer I1% = P2 —Q2kN in our factor bas e
FB. Since IT' < 2v/kN, each of these IT - is only about half the length of
kN . If we succeed, we get a new congruence . For each success, we obtain a
congruence
= (—I)"
. p;" ( mod A") ,
since, if P;/Q, is the ftli continued fraction convergent to N/kN and
P/ —N -Q,then
P,'
TV (mod N) .
(2 .92)
[5] Once we have obtained at least m. + 2 such congruences, then by Gaussia n
elimination over Z/2Z we obtain a congruence x2 - y2 (mod N) . That is ,
if (xi,eo1,el 1 . . .
. ( 1%r . co,. c.r . .
.c„i,.) are solutions of (2 .88 )
such that the vector sum defined in (2 .89) is even in each component, the n
>2 .

240
2 . Computational/Algorithmic Number Theory
2 .3 Algorithms for Integer Factorization
24 1
/),n" (mod N )
x- r i r:2 . . . a i, (mod N)
Y = (
1 ) `0Pi
is a solution to r2 E y ' (mod N), except for the possibility that r
+y (mod N), and hence we have
(d1 . d2) = (gcd(x + y, N) . gcd(x — ,y .
'V)) ,
which are then possibly nontrivial factors of N .
Conjecture 2.3.1 (The Complexity of the CFRAC Method) . If N
is the integer to be factored, then under certain reasonable heu ristic assump-
tions. the CFRAC method will factor N in tim e
0 (exp (( +o(1)) N/logNloglogN ) )
= 0
VV(2+o0 ))log log N/logN
(2.93)
Remark 2.3.4. This is a. conjecture. not a theorem, because it. is supported
by some heuristic assumptions which have not been proven (Cohen [50]).
2 .3.5 Quadratic and Number Field Sieves (QS/NFS )
In this subsection, we shall briefly introduce two other powerful general pur-
pose factoring methods : the Quadratic Sieve (QS) and the Number Field
Sieve (NFS) .
(I) The Quadratic Sieve (QS) . The idea of the quadratic sieve (QS )
was first introduced by Carl Pomerance 22 in 1982. QS is somewhat. similar
to CFRAC except that, instead of using continued fractions to produce the
values for
= P
N . Q
. it uses expressions of the form
11'k=(k+[INJ)2 - N
( k +[
J)2 (mod N) .
(2.94 )
2 2
Carl Pomerance is currently Research Professor in the Depart -
ment of Mathematics at the University of Georgia. U.S .A. He
obtained his PhD at Harvard University in 1972 and has been a
faculty member at Georgia since 1972 . Pomerance has made sev -
eral important contributions in computational number theory .
particularly in primality testing and integer factorization: for ex-
pie, the "P" in the APRCL primality test (the fastest know n
I( terministic primality testing algorithm) stands for Pomerance .
Pomerance co-authored 18 papers with the legendary Paul Erdos . (Photo by cour-
tesy of Prof. Pomerance .)
Here. If 0 < k < L . then
0 < TV < (2L+1)i+L2 .
(2.9 .5 )
If we get
r
= y
(2.96)
1= 1
then we have x2
y .2 (mod N) with
f([] + n) (mod N) .
(2.97)
1= 1
Once such r and y are found, there is a good chance that gcd(x y .N) is
a nontrivial factor of N . For the purpose of implementation . we can use the
same set FB as that used in CFRAC and the same idea as that describe d
above to arrange that (2 .96) holds. The most widely used variation of th e
quadratic sieve is perhaps the multiple polynomial quadratic sieve (MPQS) ,
proposed by Peter Montgomery [235] in 1986 . MPQS has been used to obtain
many spectacular factorizations . One such factorization is that of the 103 -
digit number
2361 + 1
3 174763 = 6874301617534827509350575768454356245025403-P 61 .
The most recent record of the quadratic sieve is the factorization of the RSA -
129, a 129 digit number. (It was estimated by Rivest [78] in 1977 that th e
running time required to factor numbers with about the same size as R.SA-
129 would be about 40 quadrillion years using the best algorithm and fastes t
computer at that time .)
Example 2 .3.4 . Use the quadratic sieve method (QS) to factor N = 2041 .
Let lV(r) = ,r'- N. with x = 43 . 44 .45.46. Then we have :
IV(44)
_
-3 . 5 . 7
IV(45)
=
-2
11(46)
=
3
52
which leads to the following congruence :
(43 . 45 . -16) 2
(—1)2 '210 . 3= -52 =(2'5) 2 .
This congruence gives the factorization of 2041 = 13 . 1 .57. since
gcd(2041 . 43 . 45 . 46+2' -3 5) = 157. gcd(2041 .. 43-4546—2" . 3 5) = 13.
IV(43)
=
-26 . 3
UV(45)
IV(43)
1
IV(46 )
0
0
0
1
0
0
1
0
0
0
3
1 
5

242
2 . Computational/Algorithmic Number Theor y
Conjecture 2 .3 .2 (The complexity of the QS/MPQS Method) . If
y' is the integer to be factored. then under certain reasonable heuristi c
assumptions. the QS/MPQS method will factor N in time
0 (exp ((1 +o(1))0ogloglog \ ) )
=0(\r(1-O(1)) .VloglogV"/logA' )
(2 .98 )
(II) The Number Field Sieve (NFS) . Before introducing the number
field sieve, NFS, it will be useful to briefly review some important milestones
in the development of integer factorization methods . In 1970, it was barely
possible to factor "hard" 20-digit numbers . In 1980. by using the CFRAC
method, factoring of 50-digit numbers was becoming commonplace . In 1990,
the QS method had doubled the length of the numbers that could be factore d
by CFRAC, with a record having 116 digits . In the spring of 1996 . the NFS
method had successfully split a 130-digit. RSA challenge number in abou t
15% of the time the QS would have taken . At present . the number fiel d
sieve (NFS) is the champion of all known factoring methods . NFS was first
proposed by John Pollard ill a letter to A . M. Odlvzko, dated 31 August 1988 ,
with copies to R. P. Brent. J. Brillhart, H . W. Lenstra., C. P. Schnorr and
H. Suyama. outlining an idea of factoring certain big numbers via algebrai c
number fields . His original idea was not for any large composite, but fo r
certain "pretty" composites that had the property that they were close t o
powers . He illustrated the idea with a. factorization of the seventh Fermat
number F7 = 22' + 1 which was first factored by CFRAC in 1970 . He also
speculated in the letter that "if F9 is still unfactored. then it might be a
candidate for this kind of method eventually?" The answer now is of cours e
"yes" . since F9 was factored by NFS in 1990 . It is worthwhile pointing out
that NFS is not only a method suitable for factoring numbers in a specia l
form like F. but also a general purpose factoring method for any integer o f
a given size. There are, in fact, two forms of NFS (see Huizing [107], an d
Lenstra and Lenstra [141]) : the special NFS (SNFS), tailored specifically for
integers of the form _A = c 1 r 1 +c2s" . and the general NFS (GNFS), applicabl e
to any arbitrary number .
The fundamental idea of the NFS is the same as that of the quadratic
sieve (QS) introduced previously : by a sieving process we look for congru-
ences modulo N by working over a factor base, and then we do a Gaussian
elimination over Z/27L to obtain a congruence of squares r e = g 2- (mod N) ,
and hence hopefully a factorization of N . Given an odd positive integer N-
NFS has four main steps in factoring N :
[1] [Polynomial Selection] Select two irreducible polynomials f (x) and g(x) with
small integer coefficients for which there exists an integer m, such that
f (rn)
g(rrr) = 0 (mod N)
(2 .99)
2.3 Algorithms for Integer Factorization
243
The polynomials should not have a common factor over Q
.
[2] [Sieving] Find pairs (a . b) such that gcd(a, b) = 1 and both
b<le g (t ) f(a/b) .
bdegtg)g(a/b)
(2.100)
are smooth with respect to a chosen factor base. The expressions in (2.100)
are the norms of the algebraic numbers a — ba and a b3, multiplied b y
the leading coefficients of f and g, respectively. (a denotes a complex root
of f and 3 a root of g) . The principal ideals a. — ba and a — b3 factor into
products of prime ideals in the number field i(a) and Q(3), respectively .
[3] [Linear Algebra] Use techniques of linear algebra to find a set S of indice s
such that the two products
l (ai — bin),
f (ai -1)0)
(2.101 )
iES
E s
are both squares of products of prime ideals .
[4] [Square Root] Use the set S in (2.101) to find an algebraic numbers a' E
Q(a) and j3' E Q(3) such that
(x' )2 = Ma, — bia),
(3') 2 = fl(a i
— bi 3)
(2.102)
ies
ies
Prior to the NFS, all modern factoring methods had an expected ru n
time of at best
0 (exp ((c+o(1))0oglogN/logN ) ) .
(2.103)
For example. the multiple polynomial quadratic sieve (MPQS) takes tim e
0 (exp ((1 +o(1))OoglogN/logN ) )
.
Because of the Canfield Erdos Pomerance theorem [50], some people eve n
believed that this could not be improved . except maybe for the term (c+o(1)) ,
but the invention of the NFS has changed this belief .
Conjecture 2.3 .3 (Complexity of NFS) . Under some reasonable heuris-
tic assumptions, the NFS method can factor an integer
in time
0 (exp ((e+o(1))~log V(loglogN) 2 )) ,
(2 .104)
where e = (64/9) 1/3 ti 1 .922999427 if GNFS is used to factor an arbitrar y
integer N . whereas c = (32/9)1/3 ti 1 .526285657 if SNFS is used to factor a
special integer N .

244
2 . Computational/ Algoritlnnic Number Theory
2 .3 Algorithms for Integer Factorization
245
Example 2 .3 .5 . The largest number ever factored by SNFS i s
N = (12 167 +1)/13= f~ >r; x ~ 10 5
It was announced by P. Montgomery. S. Cavallar and H . to Riele at CWI i n
Amsterdam on 3 September 1997. They used the polynomials f (x) = x' -144
and y(x) 12 33x + 1 with common root rn E 12131 (mod N) . The factor
base bound was 4.8 million for f and 12 million for g. Both large prime
bounds were 150 million. with two large primes allowed on each side . They
sieved over ]a.[ < 8.4 million and 0 < b < 2 .5 million. The sieving lasted 10 .3
calendar days: 85 SCI machines at CWI contributed a combined 13027719
relations in 560 machine-day's. It took 1.6 more calendar days to process the
data. This processing included 16 CPU-hours on a Cray C90 at SARA i n
Amsterdam to process a 1969262 x 1986500 matrix with 57942503 nonzer o
entries .
2 .3.6 Polland's "rho" and "p – 1" Methods
In this and the next subsections, we shall introduce some special-purpose
factoring methods. By special-purpose we mean that the methods depend .
for their success, upon some special properties of the number being factored .
The usual property is that the factors of the number are small . However ,
other properties might include the number or its factors having a special
mathematical form . For example, if p is a prime number and if 2 1' – 1 is a
composite number, then all of the factors of 2 1' – 1 must be congruent to
1 modulo 2p. For example, 211 – 1 = 23 - 89 and 23 - 89 - 1 (mod 22) .
Certain factoring algorithms can take advantage of this special form of th e
factors. Special-purpose methods do not always succeed . but it is useful to try
them first, before using the more powerful . general methods. such as CEP AC .
MPQS or NFS .
(I) The "rho" Method . In 1975 John M . Pollard 23 [187] proposed a very
efficient Monte Carlo method, now widely known as Pollards "rho " or /r
method. for finding a small nontrivial factor d of a large integer N. Trial
division by all integers up to
i/7\'' is guaranteed to factor completely any
number up to N . For the same amount of work . Pollard's "rho - method wil l
factor any number up to N 2 (unless we are unlucky) . The method uses an
iteration of the form
23 John M . Pollard is an English mathematician who has made several significan t
contributions to the field of computational number theory and is responsibl e
for the factoring methods "rho" . `p — 1 " and the number field sieve (NFS) .
Pollard studied mathematics at the University of Cambridge, and later obtaine d
a doctorate there (a rather unusual kind. based not on a thesis, but on published
research work) for his contribution to computational number theory .
xi)
random(0. N – 1) .
f(~'~—u) (mod N),
i = 1, 2.3 . . .
where xo is a random starting value . A` is the number to be factored, an d
f E Z[x] is a polynomial with integer coefficients; usually. we just simply
choose f (x) = x 2 +a with a  .0. Then starting from some initial value xo ,
a "random sequence x 1 . x2 , .r3 ,
is computed modulo N in the following
way :
= f(r'o) ,
X 3 = f(f('o)) = f(•1'u) ,
X 3 = f(f(f(xo))) = f(f(rt)) = f('2),
(2.106)
xi =
Let d be a nontrivial divisor of N, where d is small compared with N. Since
there are relatively few congruence classes modulo d (namely, d of them) ,
there will probably exist integers 2' and x1 which lie in the same congruence
class modulo d, but belong to different classes modulo N ; in short, we will
have
x, - x~
(mod d) ,
x 1 $ xi
(mod N) .
Since d
I (x; – xi ) and 0] (xr – xi) . it follows that gcd(xr –
N) is a
nontrivial factor of N. In practice, a divisor d of N is not known in advance ,
but it can most likely be detected by keeping track of the integers x ;, which
we do know: we simply compare x 1 with the earlier xi , calculating gcd(x;
xl . N) until a nontrivial gcd occurs . The divisor obtained in this way is no t
necessarily the smallest factor of N and indeed it may not be prime. The
possibility exists that when a gcd greater that 1 is found . it may also turn
out to be equal to N itself . though this happens very rarely .
Example 2 .3 .6 . For example. let N = 1387 = 19 - 73 . f (x) = x2 – 1 and
r, r = 2. Then the "random" sequence
J' ] . x2 . x„ . - - is as follows :
2 .3,8,63, 1194 . 1186. 177. 814 .. 996. 310 . 396. 84 . 120. 529. 1053, 595.339
where the repeated values are overlined . Now we find that
23
6 (mod 19 )
13 = 63 (mod 1387)
x i E 16 (mod 19 )
x.] E 1194 (mod 1387 )
= 8 (mod 19 )
= 1186 (mod 1387)
(2.105)
(2 .107)

246
2 . Computational/Algorithmic Number Theory
2.3 Algorithms for Integer Factorization
24 7
So we have
gcd(63 – 6,1387) = gcd(1194 -16,1387) = gcd(1186 – 8 .1387) =
= 19 .
Of course, as mentioned earlier . d is not, known in advance, but we can keep
track of the integers xi which we do know, and simply compare ;ri with al l
the previous x i with j <'i,, calculating gcd(x i
a J , N) until a nontrivial gcd
occurs :
So, after 13 comparisons and calculations, we eventually find the divisor 19 .
As k increases, the task of computing gcd(x i –x i , N) for all j < i becomes
very time-consuming; for n = 1050 , the computation of gcd(x i –ai , N) would
require about 1.5 - 10 6 bit operations. as the complexity for computing one
gcd is O((logn) t) . Pollard actually used Floyd's method to detect a cycle i n
a long sequence (x,) . which just looks at cases in which xi = x 2, . To see how
it works, suppose that x i = a: 1 (mod ic), then
x i+r = f(ri) = f( x.i) = .xJ+r
(mod d) ,
ai d+2 = f(xi+i) = f(rJ+L) = a:J_2 (mod (1) ..
(2.108 )
H (xi—k— ) — (x'J+k—l) = xJ+k (mod d) .
If the period of' the cycle .is k with k = j–i . then .x2 i - xi (mod d) . Hence, we
only need look at x2i – x i (or x i – x2i ) for i = 1 .2. ' • • . That is, we only need
to check one gcd for each i . Note that the sequence x 0 . .r 3 . x2 . - - modulo a
prime number p, say, looks like a circle with a tail : it is from this behaviou r
that the method gets its name (see Figure 2.2 for a graphical sketch: it looks
like the Greek letter p) .
Example 2.3.7. Again, let N = 1387 = 19 . 73, f (a:) =
and au = 2 .
By comparing pairs x i and X2,, for i. = 1, 2, .
we have :
So. only after 3 comparisons and gcd calculations . the divisor 19 of 1387 is
found .
In what follows, we shall show that to compute y i
x2i . we do not need
to compute :ri+u,
.x 2i_ 3 until we get x2; . Observe that
,yl = x2 = f(xl) = f(f (xo)) = f (f (yo)) +
y2= :c4=f(x3)=f(f(r2))=f(f(yi)) ,
113 = :r 6 = f(ro) = f(f(.r ))= f(f(il2)) .
tl == f(feyi—i)) .
So at each step ; we compute
xi =
.f(a
1)
(mod u) .
ill = f(f(?li–u)
(mod n) .
Therefore. only three evaluations of f will be required .
Example 2.3.8. Let once again N = 1387 = 19 . 73 . f (.r) = i2 – 1 and
xo =yo = 2 . By comparing pairs x i and X2i, for i = 1 . 2 
we get :
f(yo) = 22 — 1 = 3 ,
f(f(yo))=32 —1=8 = ?l u
gcd(yr – xr,
= gccl(3 – 8, 1387) = 1
gcd(a) " – x0 ,
gcd(:r2 – xi ,
gcd(x2 – xo ,
gcd(x3 – x2 ,
gcd(x3 – xi ,
gcd(xs – x0 ,
ged(a'a – a 3 ,
gcd(x.i – a:2 ,
gcd(x d –xi .
gcd(x d – x0 ,
gcd(x. – :r a
gcd(a',i – a : 3 ,
gcd(xs – x
:1) = gcd(3 – 2 . 1387) = 1
N) = gcd(8 – 3, 1387) = 1
N) = gcd(8 – 2 . 1387) = 1
N) = gcd(63 – 8 . 1387) = 1
A') = gcd(63 – 3, 1387) = 1
N) = gcd(63 – 2 . 1387) = 1
N) = gcd(1194 – 63. 1387) = 1
N) = gcd(1194 – 8.1387) = 1
N) = gcd(1194 – 3. 1387) = 1
N) = gcd(1194 – 2, 1387) = 1
N) = gcd(1186 – 1194. 1387) =
N) = gcd(1186 – 63 . 1387) = 1
N) = gcd(1186 –
, 1387) = 1
xo
Figure 2.2. Illustration of the p-method
gcd(a I
x2, 1) = gcd(3 – 8, 1387) = 1
1
gcd(z
x4 , N) = gcd(8 – 1194. 1387) = 1
gcd(a.3 – x6 . N) = gcd(63 – 177, 1387) = 19
(2 .109)
(2 .110 )

248
2 . Computational/Algorithmic Number Theory
2 .3 Algorithms for Integer Factorization
249
f(yi ) = 82 - 1 = 63 .
f(f(y O) =63'22 - 1=1194=y 2
gcd(y2 - x,2 , N) = gcd(8 - 1194 .. 1387) = 1
f (y 2) = 11942 - 1 mod 1387 = 1186 .
f(f(112))=1186 2
1 mod 1387=177=y3
 
> gcd(y 3 - :r3 . N) = gcd(63 - 177, 1387) = 19 .
The divisor 19 of 1387 is then found .
Remark 2.3.5. There is an even more efficient algorithm, due to Brent 2'1
[35], which looks only at the following differences and the corresponding gc d
results :
a• 1 - ir3
—> gcd(:rl - r3 , N )
t•3 - x6	
> gcd(x 3 - .r6 , N )
— x7 —> gcd(x3 — :r7 , A' )
- x 1 2
gcd(x 7
xr2 . N )
x7 - :r 13 
> gcd(x 7
2' 3, N)
:r7 - x11	
gcd(x 7
xra, ` )
gcd(x 7 - :rr3, ` )
and in general :
.r ,
2"+1 - 2 0_i < j < 2'r+1 - 1 .
(2 .111 )
Brent's algorithm is about 24 percent faster than Pollard's original version .
Now we are in a position to present an algorithm for the p-method .
Algorithm 2 .3 .5 (Pollard's p-method) . Let : - be a composite intege r
greater than 1 . This algorithm tries to find a nontrivial factor d of N . which
is small compared with
Suppose the polynomial to use is
f ( .r) = a!'- + 1 .
Richard P. Brent was born in Melbourne . Australia in 1946 . He ob -
tained his BSc in Mathematics at Monash University . Melbourne .
Australia in 1968, and his MSc and PhD at Stanford University.
California in 1970 and 1971 . respectively . Brent was Professor i n
Computer Science at the Australian National University for more
than 25 years. and is currently Professor of Computing Scienc e
at Oxford University. Perhaps best known for his work in th e
improvement of Pollard's p-method and the factorization of th e
Fermat numbers Fs . Fo and he has also made significant contributions to the
analysis of algorithms and parallel computations. It is interesting to note that he i s
descended from Hannah Avscough . who was the mother of Sir Isaac Newton (1642 -
1727) ; Newton never married, and had no direct descendants . (Photo by courtesy
of Prof. Brent.)
[1] [Initialization] Choose a seed, say .ro = 2, a generating function, say f (a;) =
.r'-+1 (mod N) . Choose also a value fort not much bigger than
d, perhap s
t<100f .
[2] [Iteration and Computation] Compute a?, and yi in the following way :
x i = f(xo) ,
X2 = f(f(xo)) = f(x r) .
X3 = f(f(f(xo))) = f(f(xr)) = f(x2) ,
x i = f(x i-r)•
yr = x2 = f(xr) = f(f(xo)) = f(f(yo)) ,
y_= x 3 = f(x)) = f(f(x2)) = f(f(yr)) ,
Y3 = x6 = f(xe) = f(f(x&)) = f(f(y2)) ,
yt = x2t = f(f(y;—r)) .
and simultaneously compare x, and yi by computing d = gcd(x, - yi , N) .
[3] [Factor Found?] If 1 < d < A', then d is a nontrivial factor of N, print d ,
and goto step [5] .
[4] [Another Search?] If x, = y, (mod N) for some i or i > V, then goto ste p
[2] to choose a new seed and a new generator and repeat .
[5] [Exit] Terminate the algorithm .
Now. let us move on to the complexity of the p-method. Let p be th e
smallest prime factor of N . and j the smallest positive index such that.
x2j = xi (mod p) . Making some plausible assumptions, it is easy to sho w
that the expected value of j is 0(fP) . The argument is related to the well-
known "birthday" paradox: suppose that 1 < k < n and that the number s
rl
, xt, are independently chosen from the set {1, 2 . -
Then the
probability that the numbers x k are distinct is
(1_
k-1 )
n
exp~ 
k2~
.
(2 .112 )
\2n /
Note that the a; i's are likely to be distinct if k is small compared with
n, but
unlikely to be distinct if k is large compared with rt . Of course. we cannot
work out x i mod p, since we do not know p in advance, but we can detect xj
by taking greatest common divisors. We simply compute d = gcd(x2 , -N )
for i = 1 .2 .
. .
. and stop when a d > 1 is found .
Conjecture 2.3.4 (Complexity of the p-method) . Let p be a prime di-
viding N and p = O(/i). then the p-algorithm has has expected runnin g
time
CI
n)
(1
n)

250
2. Computational/Algorithmic Number Theory -
2.3 Algorithms for Integer Factorization
251
0( ) = 0( p(logN) 2 ) = O(_\"/(logN)2)
(2.113)
to find the prime factor p of N .
Remark 2.3.6. The p-method is an improvement over trial division . because
0(p) = C)(N'l ') divisions are needed for trial division to find a small factor p
of N . But, of course . one disadvantage of the p-algorithm is that its runnin g
time is only a conjectured expected value, not a rigorous hound .
(II) The "p—1" Method . Pollard in 1974 invented also another simple bu t
effective factoring algorithm . now widely known as Pollard's "p -1" method .
which can be described as follows :
Algorithm 2.3.6. [Pollard's "p — 1" Method] Let N > 1 be a composite
number. This algorithm attempts to find a nontrivial factor of N .
[1] [Initialization) Pick out a E Z/ NZ at random . Select a positive integer k
that is divisible by many prime powers, for example, k = lc111(1, 2, . ' ' , B)
for a suitable bound B (the larger B is the more likely the method will be to
succeed in producing a factor, but the longer the method will take to work) .
[2] [Exponentiation] Compute ac. = at mod N .
[3] [Compute GCD] Compute d = gcd(ai. — 1 . N) .
[4] [Factor Found?] If 1 < d < IV' , then d is a nontrivial factor of N, output d
and goto [6] .
[5] [Start Over?] If d is not a nontrivial factor of N and if you still want to tr y
more experiments, then goto [2] to start all over again with a new choice of
a and/or a new choice of k, else goto [6] .
[6] [Exit] Terminate the algorithm .
The "p 1" algorithm is usually- successful in the fortunate case where
A'
has a prime divisor p for which p—1 has no large prime factors. Suppose that
(p — 1)
k and that pt a . Since
(Z/p~/)*I = p
1. we have a - 1 (mod p) .
thus p
I gcd(a ),. — 1. N) . In many- cases . we have p = ged(at. — 1, X) . so the
method finds a nontrivial factor of N .
Example 2 .3 .9 . Use the "p—1" method to factor the number N = 5-10143 _
Choose B = 8 and hence k = 840 . Choose also a = 2 . Then we have
gcd(2s`'n — 1 mod 540143, .540143) = gcd(53046 .. 640143) = 421 .
Thus. 421 is a (prime) factor of 540143 . In fact. 421 . 1283 is the complete
prime factorization of 540143 . It is interesting to note that, by using the
"p — 1" method, Baillie in 1980 found the prune facto r
P25 = 115568539524661918267303 3
of the Mersenne number M25 = 2'-3
— 1 . hr this case
1 = 23 . 32 . 192 . 47 ' 67 ' 257 ' 439 ' 119173 . 1050151 .
In the worst case . where (p 1)/2 is prime, the "p — 1" algorithm is
no better than trial division . Since the group has fixed order p — 1 there i s
nothing to be done except try a different algorithm . Note that there is a
similar method to "p — 1" . called "p + 1" . proposed by H . C. Williams
1982. It is suitable for the case where N has a prime factor p for which p + 1
has no large prince factors .
2.3.7 Lenstra's Elliptic Curve Method (ECM )
In Subsection 2 .2 .., we discussed the application of elliptic curves to primality
testing. In this subsection, we shall introduce a factoring method which use s
of elliptic curves. The method is actually obtained from Pollard's "p — 1 "
algorithm : if we can choose a random group G with order g close to p, we
may be able to perform a computation similar to that involved in Pollard' s
"p
1" algorithm, working in G rather than in Fp . If all prime factors of g
are less than the bound B then we find a. factor of N. Otherwise. we repeat
this procedure with a different group G (and hence. usually, a different g)
until a factor is found. This is the motivation of the ECM method . invented
by H . W. Lenstra2' [140] in 1987.
Algorithm 2 .3 .7 (Lenstra's Elliptic Curve Method) . Let N > 1 be a
composite number, with gcd(N .. 6) = 1 . This algorithm attempts to find a non -
trivial factor of N . The method uses elliptic curves and is analogous to Pollard' s
"p — 1" method .
[1] [Choose an Elliptic Curve] Choose a random pair (E . P), where E is a n
elliptic curve y s = :c3 +ax+b over Z/NZ, and P(x, y) E E(Z/NZ) is a point
on E . That is, choose a . .c. y E Z/N7G at random, and set b <— y2 — x3 — ax .
If gcd(4a3 +2762 .
 1, then E is not an elliptic curve, start all over an d
choose another pair (E . P) .
[2] [Choose an Integer k] Just as in the "p—1" method, select a positive intege r
k that is divisible by many prime powers, for example, k = lcm(1, 2 . . , B)
or k = B! for a suitable bound B ; the larger B is the more likely the method
25
Hendrik W. Lenstra Jr., perhaps best known for his invention o f
the ECM method for factoring, was born in 1949 in Zaandarn ,
the Netherlands . He studied at the University of Amsterdam and
obtained his PhD there in 1977. He was appointed Full Professo r
at the same university almost immediately after his PhD . In 198 7
he left the Netherlands to become a Professor in the University o f
California at Berkeley while still keeping a strong mathematical
connection with the Netherlands . Lenstra has received numerou s
awards, such as the Fulkerson Prize in 1985 . (Photo by courtesy of Profs. Lenstra
and W . A. Stein.)

252
2. Computational/Algorithmic Number Theory
2.3 Algorithms for Integer Factorization
253
will succeed in producing a factor, but the longer the method will take t o
work .
[3] [Calculate kP] Calculate the point kP E E(7L/NTZ) . We use the following
formula to compute P3(:r3,y3) = P1(.rl,yl)+P,(x2 .y2) mod N :
(x3, y3) = (,A 2 — x1 — x2
mod N .
x3) — y 1 mod N) ,
where
0e1
3,r + a
0r2
2m
r01 = yl 
y'
rood A T
otherwise .
7rr2
x 1 — x2
The computation of kP mod N can be done in O(log k) doublings an d
additions .
[4] [Compute GCD] If kP - OL (mod N), then set 0 .2 = z and compute
d = gcd(z . N), else goto [1] to make a new choice for "a" or even for a
new pair (E, P) .
[5] [Factor Found?] If 1 < d < N, then d is a nontrivial factor of N, output d
and goto [7] .
[6] [Start Over?] If d is not a nontrivial factor of A' and if you still wish to try
more elliptic curves, then goto [1] to start all over again, else goto [7] .
[7] [Exit] Terminate the algorithm .
As for the "p— 1" method, one can show that a given pair (E, P) is likely
to be successful in the above algorithm if N has a prime factor p for which
7L/pZ is composed of small primes only. The probability for this to happen
increases with the number of pairs (E, P) that one tries.
Example 2 .3 .10 . Use the ECM method to factor the number N = 187 .
[1] Choose B = 3, and hence k = lcm(1, 2.3) = 6. Let P = (0.5) be a point
on the elliptic curve E :
y2 = x' + x + 25 which satisfies gcd(\' . 4a3 +
27b2 ) = gcd(187, 16879) = 1 (note that here a = 1 and b = 25) .
[2] Since k = 6 = 110 3 . we compute 6P = 2(P + 2P) in the following way :
[2-1] Compute 2P = P + P = (0 .5) + (0.5) :
A
0r 1
1
= 
=
131(mod 187 )
702
10
= 144 (mod 187 )
iy3 = 18 (mod 187) .
So, 2P (144.18) with 101 = 10 and A = 131 .
[2-2] Compute 3P = P + 2P = (0,5) + (144,18) :
A
nz 1 = 13
072
144 = 178 (mod 187 )
X3 = 124 (mod 187 )
13 = 176 (mod 187) .
So. 3P = (124 ..176) with m .2 = 144 and A = 178 .
[2-3] Compute 6P = 2(3P) = 3P + 3P = (124,176) + (124,176) :
\= m 1
46129 — 127 —
C1
n2
352
165
This time m 1 = 127 and rn2 = 165, so the modular inverse fo r
127/16:5 modulo 187 does not exist: but this is exactly what we want !
this type of failure is called a "pretended failure" . We now set
_=nr2 =165.
[3] Compute d = gcd(N, z) = gcd(187,165) = 11 . Since 1 < 11 < 187, 11 is
a (prime) factor of 187 . In fact. 187 = 11 ' 17.
In 1995 Richard Brent at the Australian National University completed th e
factorization of the tenth Fermat number using ECM :
22'0 + 1 = 2 1024 + 1 = 45592577 - 6487031809 • P10 • p212
where the 40-digit prune 1)40 was found using ECM, and 0252 was proved
to be a 252-digit prime . Other recent ECM-records include a 38-digit prim e
factor in the 112-digit composite (1 1 118 + 1)/(2 • 61 ' 193121673), a 40-digit
prime factor of 26 120 + 1 . a 43-digit prime factor of the partition numbe r
p(19997) and a 44-digit prime factor of the partition number p(19069) i n
the RSA Factoring Challenge List, and a 47-digit prime in c135 of 528 + 1 =
2 - 1655809' pss ' clan .
Conjecture 2 .3.5 (Complexity of the ECM method) . Let p be the
smallest prime dividing N . Then the ECM method will find p of N, under
some plausible assumptions, in expected running tim e
0 (exp (~(2+o(1))logploglogp) ' (log N) 2)
(2.114)
In the worst case, when N is the product of two prime factors of the sam e
order of magnitude, we have
0 (exp (~(2+o(1))log \loglogN) )
= 0 (NV(2+0(1)) log log 1Vf log A% )
(2 .115)
mod A'
if P1 = P,
{
nod 187) .

254
2. Computational/ Algorithmic Number Theory
2.4 algorithms for Discrete Logarithms
255
Remark 2 .3 .7 . What is especially interesting about the ECM is that its
running time depends very much on p (the factor found) of !A . rather than
N itself. So one advantage of the ECM is that one may use it. in a manner
similar to trial division. to locate the smaller prime factors p of a number N
which is much too large to factor completely .
2.4 Algorithms for Discrete Logarithm s
The discrete logarithm problem has marry different facets to it, and ther e
are areas in which much remains to be discovered .
KEVIN S . plc CuRt
v
Odds and Ends from Cryptology and Computational Number Theory [150 ]
The discrete logarithm problem (DLP) can be described as follows :
where the modulus n can either be a composite or a prime .
According to Adleman [1] . the Russian mathematician Bouniakowskv de-
veloped a clever algorithm to solve the congruence a ." = b (mod ii), with
asymptotic complexity 0(n) in 1870 . Despite its long history. no efficient al-
gorithm has ever emerged for the discrete logarithm problem . It is believed to
be extremely hard, and harder than the integer factorization problem (IFP )
even in the average case. The best known algorithm for DLP at present, usin g
NFS and due to Gordon [90] . requires an expected running time
C) (exp (c(logn) I%'(log logn) 2 " 3) ) .
There are essentially three different categories of algorithms in use fo r
computing discrete logarithms :
(1) Algorithms that work for arbitrary groups, that is, those that d o
not exploit any specific properties of groups ; Shanks' baby step giant-
step method. Pollard's p -method (an analogue of Pollard's p-factoring
method) and the a-method (also known as wild and tame Kangaroos )
are in this catego
(2) Algorithms that work well in finite groups for which the order of th e
groups has no large prime factors ; more specifically, algorithms that work
for groups with smooth orders . (A positive integer is called smooth if i t
has no large prime factors: it is called y-smooth if it has no large prime
factors exceeding y .) The well-known Silver—Pohlig—Hellman algorith m
based on the Chinese Remainder Theorem is in this category .
(3) Algorithms that exploit methods for representing group elements as
products of elements from a. relatively small set. called the factor bas e
(it may also make use of the Chinese Remainder Theorem) : the typical
algorithms in this category are various forms of index calculus, includin g
Number Field Sieve .
In the subsections that follow . we shall introduce the basic ideas of each o f
these three categories ; more specifically. we shall introduce Shanks' baby-step
giant step algorithm, the Sil verPohlig Hellman algorithm, and the index
calculus .
2.4.1 Shanks' Baby-Step Giant-Step Algorithm
Let G be a finite cyclic group of order it . a a generator of G and b E G. The
obvious algorithm for computing successive powers of a until b is found takes
0(n) group operations. For example. to compute x = log. 15 (mod 19) . we
compute 2` mod 19 for x = 0, 1, 2, -
. , 19 — 1 until 2" mod 19 = 15 for some
x is found. that is :
x
0
1
2
3
4
5
6
7
8
9
10
1 1
as
1
2
4
8
16
1 13
7
14
9
18
17
15
So log 2 15 (mod 19) = 11. It is clear that when a is large . the algorithm is
inefficient. In this section. we introduce a type of square root algorithm, called
the baby-step giant step algorithm. for taking discrete logarithms, which is
better than the above mentioned obvious algorithm. The algorithm works o n
arbitrary groups . and according to Odlyzko [178] . its original idea is due to
Shanks' .
Daniel Shanks (1917-1996) . an American physicist and math-
ematician, responsible for the SQUFOF method for intege r
factorization and the baby-step giant-step method for taking
discrete logarithms . He served as an editor of Mathematics of
Computation from 1959 until his death . His book Solved an d
Unsolved Problems in Number Theory is one of the very popu-
lar books in number theory . (Photo by courtesy of the American
Mathematical Society. )
Input :
a, b, n E N
Output :
xENwith a''b (
if such an .z• exists,
(2.116)

256
2. Computational/ Algorithmic Number Theory
2 .4 Algorithms for Discrete Logarithms
25 i
Let m =
'VT J . The baby-step giant-step algorithm is based on th e
observation that if J. = log„ b . then we can uniquely write :r = i + jrn, where
0 < < rn . For example . if 11 = log 2 15 mod 19, then a = 2, b = 15. m. = 5 ,
so we can write 11 = i+ 5j for 0 < i, j < m . Clearly. here
i, = 1 and j = 2
so we have 11 = 1 + 5 • 2 . Similarly. for 14 = loge 6 mod 19 we can writ e
14=4+5-2,for 17=log 2 10mod 19wecanwrite 17=2+5 . 3, etc. The
following is a description of the algorithm :
Algorithm 2 .4.1 (Shanks' baby-step giant-step algorithm) . This al-
gorithm computes the discrete logarithm J . of y to the base a, modulo n, such
that y = a .' (mod n) :
[1] [Initialization] Computes s = [:(/Ti J .
[2] [Computing the baby step] Compute the first sequence (list), denoted by S ,
of pairs (pa'. r), r = 0,1.2 .3:
, s
1 :
S = {(y.0) . (ya . 1) . (ya2.2) . (ya3 , 3) 
( .ya's
, s — 1) mod n}
(2 .117)
and sort S by ya', the first element of the pairs in S .
[3] [Computing the giant step] Compute the second sequence (list), denoted b y
T, of pairs (a" . ts), t = 1.2 .3 .
.s :
T = {(a' .1), (a2.a , 2), (a3' 3)
. . . , (a'~, s) mod n}
(2 .118)
and sort T by a", the first element of the pairs in T .
[4] [Searching, comparing and computing] Search both lists S and T for a matc h
pa' = an with ya' in S and at' in T, then compute x = is — r . This x i s
the required value of log„ y (mod a) .
This algorithm requires a table with O(m) entries (m =
[N/Ti j, where
it is the modulus) . Using a sorting algorithm. we can sort both the lists S
and T in O(mlogm) operations . Thus this gives an algorithm for computing
discrete logarithms that uses O(
n.logn.) time and space for O( n) group
elements. Note that Shanks' idea is originally for computing the order of a
group element g in the group G. but here we use his idea. to compute discret e
logarithms . Note also that although this algorithm works on arbitrary groups .
if the order of a group is larger than 10 10 , it will be infeasible .
Example 2.4.1. Suppose we wish to compute the discrete logarithm x =
loge 6 mod 19 such that 6 = 2' mod 19 . According to Algorithm 2 .4.1 . we
perform the following computations :
1]y=6 .a=2 and n= 19 . .s=[
19J=4 .
[2] Computing the baby step :
S
= {(y, 0) . ( .pa,1) . (ya- . 2) . (ya 3 .3)
mod 19 }
=
{(6.0) .(6 .2,1),(6 .22 .2) .(6-23 .3)mod 19}
{(6, 0) . (12 .1) . (5 .2), (10, 3) }
1(5. 2), (6.0), (10, 3), (12. 1)}.
[3] Computing the giant step :
T = {(as. .$) . (02s , 2.$) . (a3', 3.$) . (a l' . 4s) mod 19 1
{(2 1 , 4) . (28 .8),(2 12 , 12) . (2 10 .16) mod 19}
_ {(16,4),(9,8) .(11.12).(5 .16) }
1(5. 16) . (9, 8), (11.12), (16.4)} .
[4] Matching and computing: The number 5 is the common value of th e
first element in pairs of both lists S and T with r = 2 and st = 16 . so
:r = st — r = 16 — 2 = 14. That is . log2 6 (mod 19) = 14, or equivalently.
214 (mod 19) = 6 .
Example 2.4.2. Suppose now we wish to find the discrete logarithm x
log;9 67 (mod 113) . such that 67 - 59'` (mod 113) . Again by Algorithm
2.4.1, we have :
[1]y=67,a=59andn=113,s=[ 3113j=10 .
[2] Computing the baby step :
S = {(y, 0), (ya,1), (ya' , 2) . (pa 3 , 3) 
(pa', 9) mod 113 }
= {(67.0), (67 . 59.1) . (67 . 592.2) . (67 . 59 3 , 3) . (67 . 594 , 4) ,
(67 . 590 .5), (67 . 59 0 , 6), (67 . 597, 7) . (67 . 598, 8) ,
(67 . 599 ,9) mod 113}
1(67. 0), (111 . 1), (108, 2), (44, 3), (110, 4) . (49, 5), (66, 6) .
(52, 7), (17,8),(99. 9)1
1(17, 8), (44, 3) . (49. 5) . (52, 7), (66, 6), (67, 0), (99, 9) ,
(108. 2) . (110, 4) . (111.1)}.
[3] Computing the giant-step :
T
=
{(as. .$), (a2' . ss) . (a3s .3.$) . . . . (110' . 10s) mod 113 }
{(5910.10), (592.10.2 . 10) . (59110 .3 - 10). (59410.4 . 10).
(59°'10 .5 . 10), (59610 ..6 . 10). (59710, 7 . 10) . (59 R 10 .8 . 10) .
(59910,9 . 10) mod 113}
1(72. 10). (99 . 20) . (9, 30) . (83.40) . (100.50) . (81, 60).
(69.70) .(109,80),(51,90),(56 .100) 1
{(9.30) . (51 . 90), (.56. 100) . (69. 70). (72, 10) . (81 .60). (83 . 40) .
(99. 20). (100, 50), (109, 80)} .
[4] Matching and computing: The number 99 is the common value of th e
first element in pairs of both lists S and T with r = 9 and st = 20 .
so x = st — r = 20 — 9 = 11 . That is, log ;;g 67 (mod 113) = 11, or
equivalently. 5911 (mod 113) = 67.

258
2 . Computational/Algorithuhic Number Theory
2.4 Algorithms for Discrete Logarithms
259
Exercise 2 .4 .1 . Use the baby step giant step algorithm to find the following
discrete logarithms x :
(1) r - log3 5 (mod 29) .
(2) .r = log; 96 (mod 317) .
(3) x log37 15 (mod 123) .
Shanks' baby-step giant-step algorithm is a type of .square root metho d
for computing discrete logarithms . In 1978 Pollard [188] also gave two othe r
types of square root methods . namely the p-method and the method fo r
taking discrete logarithms. Pollard's methods are probabilistic but remov e
the necessity of precomputing the lists S and T . as with Shanks' baby-step
giant-step method . Again, Pollard's algorithm requires O(n) group operation s
and hence is infeasible if the order of the group G is larger than 10 40 .
2 .4 .2 Silver-Pohlig-Hellman Algorithm
In 1978 . Pohlig and Hellman [186] proposed an important special algorithm ,
now widely known as the Silver-Pohlig Hellman algorithm for computin g
discrete logarithms over GF(q) with O(f) operations and a comparable
amount of storage, where p is the largest prime factor of q - 1 . Pohlig and
Hellman showed that if
k
q - 1= 11
(2 .119)
i=r
where the p, are distinct primes and the a, are natural numbers . and if
r 1 , , rk are any real numbers with 0 < r, < 1 . then logarithms over GF(q )
can be computed in
O
E(logq+p;
e (1+log e
=
field operations. using
k
O
log q
(1 + p,` )
i=
bits of memory-, provided that a precomputation requirin g
O
log p? +log q)
(2 .122)
field operations is performed first . This algorithm is very- efficient if q is
"smooth" . i .e., all the prime factors of q - 1 are small . Here is a brief descrip-
tion of the algorithm :
Algorithm 2 .4.2 (Silver-Pohlig-Hellman Algorithm) . This algorithm
computes the discrete logarithm a' = logy b mod q :
[1] [Factor q
1 into its prime factorization form ]
k
q -1 = H
.
[2] [Precompute the table rr,;1 for a given field ]
rp,,J = aJ(q-i)/p+ mod q .
0 <7 < p, .
(2 .123)
This only needs to be done once for any given field .
[3] [Compute the discrete logarithm of b to the base a. modulo q, i .e., compute
x = log1 b mod q]
[3-1] Use an idea similar to that in the baby-step giant-step algorithm to fin d
the individual discrete logarithms x mod p,' ' : To compute It modp7
we consider the representation of this number to the base p, :
x nlod p7' = xo+ rrpt + . . .+x~,
(2.124)
where 0<x„<p,-1 .
[i] To find xo, we compute b(q-r) /
set .ro = j for which
1)q-I1/p= mod q = rpr,J '
This is possible because
0 -1 )/Th = a' ("-I)/''' = aso(q-1)lp' mod q = rp, ., o
[ii] To find r t , compute in = ba- "0 .
If
b(q-I )/p modq=i'
.J
then set
Z!1 = j . This is possible because
6( q-r)lr = a(a.-1a)(e-)lp = a(z,+r 2p,-'-)(q-tle i
1
a i
mod q =rpz ,:ti .
[iii] To obtain r,, consider the number b1 = ba-.r0- -
and compute
0-104 mod q .
The procedure is carried on inductively to find all xo,r 1 ,''' ,an,_ 1
[3-2] Use the Chinese Remainder Theorem to find the unique value of x
from the congruences x mod pi`
(2.120 )
(2.121)
which equals rpa
for some j, and

260
2. Computational/Algorithmic Number Theory
2 .4 Algorithms for Discrete Logarithms
26 1
We now give an example of how the above algorithm works :
Example 2.4.3. Suppose we wish to compute the discrete logarith m
- log., 62 (mod 181). Now we have a = 2 . b= 62 andq= 181 (2 is a
generator of IFi81 ) . We follow the computation steps described in the abov e
algorithm :
[1] Factor q – 1 into its prime factorization form :
180=2 2 . 32 . 5 .
[2] Use the following formula to precompute the table rr, ; •3 for the given field
81 :
.1 <
r,_o = 2J00 mod 181 = 1,
r2 .1 = 2901 mod 181 = 180 .
[2-2] Compute ry, .J = al(q–1)/r2 mod q = 2601 mod 181 for 0 < j <
P2 = 3 :
r3 .9 = 2600 mod 181 = 1,
13 , 1 = 260'1 mod 181 = 48 .
r3 .2 = 2602 mod 181 = 132 .
[2-3] Compute rP3_j
= (P (q–1)/Pa mod q = 2361 mod 181 for 0 < j
<
P:3 = 5 :
5 .0 = 2364' mod 181=1 .
7-5.1 = 236 ' 1 mod 181 = 59,
7-5 . 2 = 2362 mod 181 = 42,
r„ ,3= 2J6.3 mod 181=125 .
r 5 .1 = 276.4 mod 181 = 135 .
Construct the rr, ;_j table as follows :
P+
j
0
1
2
3
4
2
1
180
3
1
48
132
5
1
59
42
125
135
This table is manageable if all p, are small .
[3] Compute the discrete logarithm of 62 to the base 2 modulo 181, that is ,
compute x = log., 62 mod 181 . Here a = 2 and h = 62 :
[3-1] Find the individual discrete logarithms :r mod
using
x mod pa, = :8 + x 1p1 +
. . . + .ra ,
1 pa :–1
0 G x,, < p3 – 1 .
[i] Find the discrete Logarithms x mod pi' . i.e ., x mod 22 :
x mod 181
x mod 2 2 = xo + 2a:
[a] To find xo, we compute
b(`r–1)/m mod q = 62 180/2 mod 181 = 1 = r
= >'2 .o
hence xo = O .
[b] To find xl, compute first bl = ba
'T0 = h = 62, then compute
1)/r' mod q 62180/9 mod 181=1=rp,,1 = r2 , o
hence :El = O. So ,
xmod22 =xo+2x1 
>xrood4=0 .
[ii] Find the discrete logarithms x mod 14'-, that is, x mod 32 :
xmod181t=8 xmod32 =xo+2 :r, 1 .
[a] To find xo, we compute
0–1)4z mod q = 62rso/3 prod 181 = 48 = rp2 .) = r'a . r
hence xo = 1 .
[b] To find x 1 . compute first h 1 = ba–L ° = 62 . 2–1 = 31, then
compute
biq
1)i1'= mod q = 31180/3'- mod 181 = 1 =
, 1
hence x i = O. So ,
xmod32 = .8o+2x 1 
>xmod9=1 .
[iii] Find the discrete logarithms x mod
that is, x mod 5 1 :
r, mod181=>xmod5 1 =xo .
To find :ro, we compute
h('rn/r° mod q = 62180/5 rood 181 = 1 = rr,3 . = r3 .o
hence xo = O. So we conclude tha t
xmod5= :ro 
;xmod5=0 .
= cr.i(v–r)ln mod q .
0 < j < p, .
This only needs to be done once for this field.
[2-1] Compute
= a- (q–1)/ r" mod q = 2903 mod 181 for 0
<
pr = 2 :

262
2. Cornputationa /A gorithmic Number Theory
2 .4 Algorithms for Discrete Logarithms
263
[2-2] [Gaussian elimination] Check if over the finite field Z 1, ,, bas mod q
is dependent on
{a'' mod p, . .
mod p} .
[3-2] Find the in
x plod 181
such that
x rood 4 = 0 ,
a;lnod9=1 .
X mod a = O .
To do this. we just use the Chinese Remainder Theorem to solve th e
following system of congruences :
.r E 0 (mod 4 )
r - 1 (mod 9 )
x 0 (mod 5) .
The unique value of x for this system of congruences is x = 100 .
(This can be easily found by using, for example, the Maple functio n
chrem( [0, 1, 0] , [4,9, 571 .) Thus. the value of .c in the congru-
ence x mod 181 is 100. Hence x = loge 62 = 100 .
2 .4.3 Index Calculus for Discrete Logarithms
In this subsection. we shall introduce several versions of index calculus fo r
discrete logarithms for the multiplicative group Ft; over the finite field gip .
which are probabilistic . but have subexponential-time complexity .
In 1979. Adleman [1] proposed a general purpose . subexponential-tim e
algorithm for taking discrete logarithms . called the index calculus for the
multiplicative group 1Er, . with the following expected running time :
0 (exp (eJlogploglogp))
.
His algorithm can be briefly described as follows :
Algorithm 2.4.3 (Adleman's index calculus) . This algorithm tries to
compute the discrete logarithm x = log,,b mod p with input a. b. p. where a
and b are generators and p a prime :
[1] [Factoring] Factor p — 1 into its prime factorization form :
p—1 =P1Pz
. . .pt.
[2] [Computing] For each p'
n, carry out the following steps until rn t
i s
obtained :
[2-1] [Guessing and checking] Find c, . s, such that et
q are smooth with respect to the bound 2 [12g P I"
If yes, calculate 3 's such that
then
rnr =
~j=1
[3] [Chinese remaindering] Calculate and output .r such that
xra t (mod p[`),
l=1,2 . . . .k .
Note that the above algorithm can also be easily generalized to the case
where p is not a prime, or a or h are not generators (Adleman [1]) . The
most widely used index calculus algorithm for discrete logarithms for If, is ,
however. in the following form :
Algorithm 2.4.4 (Index calculus for discrete logarithms in If,,) .
This algorithm tries to find an integer k such that
= 3 "
ill IF
.
[1] [Factor base] Choose a set of multiplicatively independent integers (usuall y
the first r primes) :
T =
7r, 1-
(2.125)
[2] [Compute and factor 3e mod p] Randomly choose exponent e < p, comput e
3e mod p, and attempt to factor it as a product :
re3(e)
nx z
modp=T 1
tr,
[3] Repeat Step [2] to find r independent factorization (2 .126), then solve th e
system of congruences
,
m.l (e,) log3 Ti l + . . + rn, (c,) log 3 rr,. (mod p — 1)
(2 .127)
for the quantities log3 rte .
mod p and ba`
mod
log p)' /"
ba' mod p
3j a''mod p mod
(2 .126)

264
2 . Computational/Algorithmic Number Theory
2.4 Algorithms for Discrete Logarithms
26 5
[4] Randomly choose exponents e < p, compute ail mod p, and attempt to
factor it as a product :
u3 mod p
(2.128)
When this is successful, the relatio n
log 3 a + e - ki log3 Sri + . . . + k, log 3 )-c,. (mod p — 1)
(2.129)
gives the value of k = log ,3 a . If unsuccessful, choose a different e and go
to step [2] and repeat .
Example 2 .4 .4 . Use the index calculus described in Algorithm 2 .4.4 to find
the discrete logarithms log„ 7 in 1Fz9 . Here, a = 7. 3 = 11 and p = 29, we wis h
to find k = log 3 a in 15'29 . We follow exactly the computational procedures i n
Algorithm 2.4.4 .
[1] [Factor base] Choose the factor base as follows :
F = {2.3,5} .
[2] [Compute and factor 3' mod p] Randomly choose exponent e < p, compute
3` mod p, and attempt to factor it as a product . This step needs to b e
repeated for several times in order to find r independent factorizations :
( 1)
3"' =11'
.5 (mod 29)
(2) 33 =11s
2 - 23 (mod 29)
(failure)
(3)
33 = 11°
2 - 7 (mod 29)
(failure)
(4)
c' = llc'
32 (mod 29 )
(5)
3' = 11 '
22 . 3 (mod 29)
(6)
30 = 119
2 (mod 29)
[3] Solve the system of congruences for the quantities log 3 r;
:
(1) log„ 5 - 2 (mod 29) 
> log ] , 5 E 2 (mod 28 )
(4) 2 . log " 3 6 (mod 29) — 2 - log„ 3 - 6 (mod 28 )
which does not uniquely determine logt1 3 since gcd(2, 28)  1
(6) log„ 2E 9 (mod 29) 
> log, 2 = 9 (mod 28 )
(5) 2 . log ] , 2 + loge 3 - 7 (mod 29) --z 2 log, i 2 + loge i 3 - 7 (mod 28 )
— log, 3 - 17 (mod 28)
[4] Randomly choose exponent e < p, compute a3" mod p, and attempt to
factor it as a product : a3" mod p = )3.1'1' 1 -T
a3 = 7 . 11 = 19 (mod 29) (failure )
a32=7 , 11'
=
2'3 (mod 29 )
Thus, by the relatio n
log 3 a+e- k 1 log , 3
1 +
. .+ k,.log331,. (modp—1 )
we have
log" 7-log„ 2+log " 3—2-9+17—2- 24 (mod 28) .
The correctness of the above computation is, of course, ready to verify, sinc e
11" E 7 (mod 29) .
Exercise 2.4.2. Use the index calculus described in Algorithm 2 .4.4, to find
the discrete logarithms log" 15 and logtI 27 in Fit .
Note that Gordon [90] in 1993 proposed an algorithm for computing dis -
crete logarithms in IFr . Gordon's algorithm is based on the Number Fiel d
Sieve (NFS) for integer factorization . with the heuristic expected runnin g
time
O (exp (c(logp) (13 (log logp)2/ 3 )) '
the same as that used in factoring . The algorithm can be briefly described as
follows :
Algorithm 2 .4.5 (Gordon's NFS) . This algorithm computes the discrete
logarithm
J . such that a e =
b (mod p) with input a,b,p, where a and
b are
generators and p is prime :
[1] [Precomputation] : Find the discrete logarithms of a factor base of smal l
rational primes, which must only be done once for a given p .
[2] [Compute individual logarithms] : Find the logarithm for each b E
by
finding the logarithms of a number of "medium-sized" primes .
[3] [Compute the final logarithm] : Combine all the individual logarithms (b y
using the Chinese Remainder Theorem) to find the logarithm of b .
Interested readers are referred to Gordon's paper [90] for more detaile d
information. Note also that Gordon. with co-author McCurley [89], discusse d
some implementation issues of massively parallel computations of discrete
logarithms in IF, . with q = 2' 1 .

266
2 . Computational/Algoritlnnic Number Theory
2 .4 Algoritlu for Discrete Logarithms
26
1
2.4.4 Algorithms for Elliptic Curve Discrete Logarithm s
Let Fr be a finite field with p elements (p prime) . E an elliptic curve over )F, ,
say, given by a \\'c i< rStrass equation
[3] Repeat Step [2] to find r independent expressions (2 .134), then solve the
system of congruences
e, = rrzi (( ,) logy P1 + . .
+ nz,.(e,) logy P, (mod Yp)
(2.135)
for the quantities logy P1 .
[4] Randomly choose exponent e <
compute S + cT E E(Fp ), lift it to
E : y2 =+nay+b .
(2.130)
S and T the two pints in E(Fp ) . Then the elliptic curve discrete logarith m
problem (ECDLP) is to find the integer k
point in £(Q) . and attempt to write it as :
Lift(S+eT)=k 1 Pi +k2 P2 +---+k,.P,..
(2.136)
k = logy S,
(2 .131 )
such that
When this is successful, the relatio n
loge S +
= ki log, Pr + ' -' + k,. logy P, . (mod V',,)
(2 .137)
S = k.T .
(2 .132)
In this subsection, we shall extend the (indeu. calculus for the discrete loga-
rithm problem (DLP) of multiplicative group over finite field °r, to the
ECDLP, more specifically and importantly, we shall study a new algorithm .
called xedni calculus for the ECDLP.
To apply the index calculus for the DLP to the ECDLP . one would firs t
lift the elliptic curve E/Fp to an elliptic curve £/c, next attempt to lift
various points from E/Fp to ETU. and finally use relationships among thes e
lifts to solve the ECDLP. The following is the algorithm :
Algorithm 2.4.6 (Index calculus for the ECDLP) . This algorithm wil l
try to find an integer k
k = logy S
such that
S = kT
where S and T are two pints on an elliptic curve
E : y' = + a:r + b
over a finite field Fp . (We denote E over Fp as E/Fp .)
[1] Lift E/7,, to an elliptic curve £/Q and fix a set of independent points :
T = {P I..P>,
,Pr.} E £(Q) .
(2.133)
[2] [Compute and lift CT E E(Fp )] Randomly choose integers e < Alp (Np
denotes the number of points on E), computer cT E E(Fp), lift it to a
point in E(Q), and attempt to write the lift as a linear combination :
Lift(cT) = na i (r)Pj + rn->(e)P> + -- + In,.(c)P,. .
(2.134)
gives the value of k = logy S .
There are two difficulties in the above algorithm . First of all, one needs to
lift E(Fp ) to £(Q) having many independent rational points of small height .
Secondly, one needs to lift points from E(Fp ) to £(Q) . Both of these two
problems are very difficult, probably more difficult than the original ECDLP .
Furthermore. even if one could find curves £(Q) of very high rank, there ar e
good theoretical reasons for believing that the generators of £(Q) would neve r
be small enough to allow the lifting problem to be solved in subexponentia l
time. A conclusion made by Silverman and Suzuki [232] is that the inde x
calculus will not work for solving the ECDLP because it is not possible to lif t
E(Fp ) to a curve £(Q) having many independent points of sufficiently smal l
height. For this reason, the ECDLP is believed to be much more harde r
than either the IFP (integer factorization problem) or the DLP in that n o
subexponential-time (general-purpose) algorithm is known .
In 1998, Joseph Silverman 27 proposed a new type of algorithm (although
it has not yet been tested in practice) to attack the ECDLP [231] . He called
it :redni calculus because it "stands index calculus on its head" . The idea of
the xedni calculus is as follows :
[1] Choose points in E(Fp ) and lift them to pints in z = .
Joseph H. Silverman is currently Professor of Mathematics at
Brown University. He received his Ph.D. at Harvard university
in Number theory in
1982 . His research interests include num-
ber theory. elliptic curves . arithmetic and Diophantine geometry .
number theoretic aspects of dynamical systems, and cryptography .
Prof. Silverman is perhaps best known for his four books, all by
Springer-Verlag : The Arithmetic of Elliptic Curves . 1986 . Arith -
metic Geometry, co-editored with Gary Cornell . 1986 . Rational
Points on Elliptic Curves, co-editored with John Tate, 1992, and _Advanced Topics
in the Arithmetic of Elliptic Curves, 1995 .

268
2 . Computational/Algorithrnic Number Theory
2 .4 Algorithms for Discrete Logarithms
269
[2] Choose a curve E(Q) containing the lift points ; use Mestre's method [159]
(in reverse) to make rank E(U) small .
Whilst the index calculus works in reverse :
[1] Lift E/Fp to E(Q) ; use Mestre's method to make rank E(t) large .
[2] Choose points in E(Fp ) and try to lift -them to pints in E(3) .
A brief description of the xedni algorithm is as follows (a completed an d
detailed description of the algorithm can be found in [231]) .
Algorithm 2.4.7 (Xedni calculus for the ECDLP) . Let Fp be a finit e
field with p elements (p prime), E/Fp an elliptic curve over Fp , say, given b y
E : y ' + aimx'11 + ap. :311 =x3 + (lp.2X + ap ,4x + ap6 .
Np the number of points in E(Fp ), S and T the two points in E(Fp ) . This
algorithm tries to find an integer k ;
k=logT S
such that
S=kT
inE(Fp ) .
[1] Fix an integer 4 < r < 9 and an integer M which is a product of smal l
primes .
[2] Choose r points :
P1r,i =
Yin . ,1 < i < r
(2.138)
having integer coefficients and satisfyin g
— the first 4 points are [1,0,0], [0 .1.0], [0.0,1] and [1.1,1] .
— For every prime 1 I M, the matrix B(Pnt,1, .
,Pm,.) has maximal ran k
modulo 1 .
Further choose coefficients
u. n1
.
anr.lo such that the point s
P1i,1 . • •
satisfy the congruence :
u pr .
. 3 + lLp t .2 X2y + 11 .3 Cy 2 + u .tr.-iy 3 + Um , 5x•' : + uom6x'y z
+u 11 .7y' z+a,lt. a.rz z + u119q'
+u9ii
=0(mod 11) . (2 .139)
[3] Choose r random pairs of integers (s i.t,) satisfying 1 < si.t, < Np , an d
for each 1 < i < r, compute the point Pp
= (xp ,i , yp,) defined b y
Ppi = s,S — t 1T
in ER',) .
(2 .140)
[4] Make a change of variables in ]F' of the for m
so that the first four points becom e
Pp,i = [1.0 .0] . Pp.2 = [0, 1, 0], Pp.3 = [0.0 . 1 ] . Pp.9
[1,1.1] .
The equation for E will then have the form :
u p,1 3r' + up 2.r2 y + u ;
+up ,7y 2 z + apsa'z'
[5] Use the Chinese Remainder Theorem to find integers u'1 . .
, uio satisfying
ii - up_i (mod p) and u
E
(mod M) for all 1 < i < 10 . (2.143)
[6] Lift the chosen points to F 2 (Q) . That is, choose point s
P; = [,x i , y i , z;] .
1 < i < r .
(2.144)
with integer coordinates satisfying
P = Pp,i (mod p) and P E Pm i (mod M) for all 1 < i < r. (2.145)
In particular, take P1 = [1,0.0],1? = [0, 1,0],J
3 = [0, 0,1], P1 = [1,1 .1] .
[7] Let B = B(P1 ,
•
,P, ) be the matrix of cubic monomials defined earlier .
Consider the system of linear equations :
Bu = 0 .
(2 .146)
Find a small integer solution u =
[u1 i . . .
. 010] to (2 .146) which has th e
additional property
u
,u'lo] (plod ,,) .
(2.147)
where o.
, ii'lo are the coefficients computed in Step [5] et C„ denote
the associated cubic curve :
C,, .
u 1 x,3 +u2r,'y+u ;3xy 2 +ii
y 3 +0
.r
+U 7y ' 2 + us:rz '2 + 119yz 2 + 3) 102' = O .
(113 " / N
(2 .141 )
a 1 2
a 2 -2
a2 3
(132 (133 ) \ Z j
a l l
al l
91 21
z
3
>
•1'y 9 +up,,
+v+11,6xy z
up ,oyz 2 +
p,loz = O.
(2.142 )
+ u6:1'yZ
(2.148)

270
2 . Congrutational/Algorithmic Number Theory
2 .4 Algorithms for Discrete Logarithms
271
[8] Make a change of coordinates to put C',, into standard minimal Weierstras s
form with the point Pi = [1.0.0] the point at infinity, (9. Write the resultin g
equation as
y2 +al xy+o;i%
+a 2x-+n :t r+at,
(2.149)
with a l	
as E Z, and let
Q . Q2,
.
. Q, . denote the images of
Pl . P2 ; ' '
. P, under this change of coordinates (so in particular, (21 = 0) .
Let c4 (u), cb (u), and i(u) be the usual quantities in [229] associated to
the equation (2 .149) .
[9] Check if the points Q 1 ,Q 2 ,•
• .Q, E E„(Q) are independent . If they are ,
return to Step [2] or [3] . Otherwise compute a relation of dependenc e
n2Q2 + 11 1Q3 + . +
t9 .
(2.150)
set
n 1 = — 772
n. 3 —	
and continue with the next step .
[10] Compute
s = E nisi
and
t =
i= 1
If gcd(s,Ap) > 1, return to Step [2] or [3] . Otherwise compute an invers e
ss ' - 1 (mod 'V) . Then
log7 . S - s't (mod Ap),
(2.153)
and the ECDLP is solved .
It is interesting to note that soon after Silverman proposed the xedni algo-
rithm. Koblitz showed that a modified version of Silverman's xedni algorith m
could be used to attack both the DLP (upon which the US governmen t's Dig-
ital Signature Standard, DSS . is based) and IFP (upon which the securit y
of RSA relies) . This implied that if Silverman's algorithm turned out to b e
practical. it would break essentially all forms of public-key cryptography tha t
are currently in practical use. Even if it is found not at all practical, it woul d
be still interesting, because at least we know that IFP . DLP and ECDLP ar e
not as different from each other as appears at first glance .
2 .4 .5 Algorithm for Root Finding Proble m
There are three closely related problems in computational number theory:
(1) The modular exponentiation problem (see Subsection 2 .1.5) given the
triple (l .x:,n) to compute y = :r a' (mod n) . This problem is relativel y
easy because it can be performed in polynomial time .
(2) The discrete logarithm problem (see the preceding four subsections)
given the triple ( .r, p .n) to find an exponent k such that y = x ( rood n) .
This problem is hard, since no polynomial time algorithm for it has been
found vet .
(3) The root finding problem – given the triple (k . y, n) to find an x such
that y = .r a' (mod n) . This problem is slightly easier than the discret e
logarithm problem, since there are efficient randomized algorithms for it .
provided n is a prime power. However. for general n, even the problem
for finding square roots modulo n is as difficult as the well-known integer
factorization problem. It should be noted that if the value for t(n) is
known. then the ktt, root, of p modulo n can be found fairly easily.
In what follows. we shall present an efficient and practical algorithm for
computing ktt' roots modulo
n, provided d(n) is known (Silverman [230]) ,
and give an example to illustrate the use of the algorithm .
Algorithm 2 .4.8 (Root finding algorithm) . Given integers k, y and n ,
this algorithm tries to find an integer .r such that y - x
(mod n) .
[1] Compute o(n) (See Subsection 1.4.4) .
[2] Find positive integers a and v such that ku – o(n)v = 1. (The linea r
Diophantine equation ku – o(n)e = 1 can be solved by using the continue d
fraction method – see Section 1 .3 . )
[3] Compute x = y" (mod n) (By using the fast exponentiation method – se e
Subsection 2 .1 .5) .
How do we know .r, = y" is a solution to the congruence x a - y (mod n) ?
This can be verified b y
(yU)k
(by Euler's Theorem) .
Example 2.4.5. Find the 131° root of 758 modulo 1073 . That is . find a
solution to the congruence :
x 1131 - 758 (mod 1073) .
We follow the steps in Algorithm 2 .4.8 :
[1] Since 1073 = 29 . 37. Q(1073) = 28 - 36 = 1008 .
[2] Sol ve the linear Diophantine equation :
131u-10081]=1 .
(2.151)
(2.1.52)
(by step [2])

272
2. Computational/Algorithmic Number Theory
2 .5 Quantum Number-Theoretic .9lgoritlnns
273
2 .5 Quantum Number-Theoretic Algorithms
Since 131/1008 can be expanded as a finite continued fraction with con-
vergents :
1 1
3
10
13
23
36
13 1
0,
8 ' 23 '
77 '
100 '
177 '
277 ' 1008 _
we have
u = (—1) „— I
= (— 1) 7277 = -277 ,
= (
1)
Foy—r = (—1 ) 736 = -36 .
Therefore .
131 - (—277) — 1008 (—36) = -36287 + 35288 = 1 .
Thus, u = -277 and e = -36 . In order to get positive values fora and
v. we modify this solution to :
Clearly, x = 905 is the required solution t o
:c131 = 758 (mod 1073) .
since
905 131
758 (mod 1073) .
Remark 2 .4.1 . The above method works only when o(n) is known . It won' t
work if we cannot calculate 6(n.). but it is exactly this weakness (unreasonabl e
effectiveness, see Burr [44]) which is used by Bivest. Shamir, and Adlenlan
[209] to construct their unbreakable crvptosystein (see Subsection 3 .3.6 in
Chapter 3 for a further discussion) .
If we oar to have any hope of sustaining the economic benefits to the na-
twnal economy provided by sustaining Alcoves law, we have no choice but
to develop quantum switches and the means to interconnect them .
JOEL BIRNBAU M
Chief Scientist at Hewlett-Packard
In this section, we shall first introduce some basic concepts of quantum com-
putation, including quantum computability and quantum complexity . then
introduce some recently developed quantum algorithms for integer factoriza-
tion and discrete algorithms.
2.5.1 Quantum Information and Computation
The idea that computers can be viewed as physical objects and computa-
tions as physical processes is revolutionary ; it was first proposed by Benioff
[23] . Feynman28 [74], Deutsch-
[63] and others in the first half of the 1980s .
28
Richard Phillips Feynman (1918 1988) studied Physics at MI T
and received his doctorate from Princeton in 1942 . His doctora l
work developed a new approach to quantum mechanics using th e
principle of' least action . Feynman worked on the atomic bomb
project at Princeton University (1941-42) and then at Los Alamos
(1943-45). After World War II he was appointed to the chair of
theoretical physics at Cornell University. then, in 1950, to the chair
of theoretical physics at California Institute of Technology. where
he remained for the rest of his career. Feynman was awarded the Nobel Prize i n
1965 for introducing the so-called Feynman diagrams . the graphic analogues of th e
mathematical expressions needed to describe the behaviour of systems of interact-
ing particles. Perhaps best known for his excellent text The Feynman Lectures on
Physics. Feynman [75] also published posthumously a text on quantum computa-
tion, namely Feynman Lectures on Computation .
David Deutsch was born in Haifa, Israel, in 1953. and came t o
Britain in 1956. He obtained a BA in Natural Sciences from Cam-
bridge University in 1974 and a doctorate in theoretical physic s
roni Oxford University in 1978. Deutsch is currently with the
Centre for Quantum Computation at Oxford University. He re-
ceived the prestigious Paul Dirac Prize and Medal in 1998 for his
pioneering work in quantum computation leading to the concep t
of quantum computers and for contributing to the understandin g
of how such devices might be constructed from quantum logic gates in quantu m
networks. He was also elected as a Distinguished Fellow of the British Compute r
Society in 1998. (Photo by courtesy of Dr . Deutsch .)
u=—277+1008=731 .
v=—36+131=9 5
131731—100895=1 .
y" (mod 1073)
(x131)731 (mod 1073 )
758731 (mod 1073)
905 (mod 1073) .
with
[3 Finally comput e
l

274
2 . Computational/Algorithmic Number Theory
2.5 Quantum Number Theoretic Algorithms
275
Quantum computers are machines that rely on characteristically quantu m
phenomena.. such as quantum interference and quantum entanglement . in
order to perform computation . whereas the classical theory of computatio n
usually refers not to physics but to purely mathematical subjects . A con-
ventional digital computer operates with bits (we may call them Shannon
bits . since Shannon was the first to use bits to represent information) th e
Boolean states 0 and 1 and after each computation step the computer ha s
a definite, exactly measurable state, that is, all bits are in the form 0 or 1 bu t
not both . A quantum computer, a quantum analogue of a digital computer,
operates with quantum bits (the quantum version of Shannon bit) involving
quantum states. The state of a quantum computer is described as a basis
vector in a Hilbert space30 . named after the German mathematician David
Hilbert (1862 1943) . More formally, we have :
Definition 2.5.1 . A quoit is a quantum state 1 ) of the form
1p)=al0)+ .311) .
(2 .1.54 )
where the amplitudes a . 3 E C such that 1((111 + H3H = and 0) and 11) are
basis vectors of the Hilbert space .
Note that state vectors are written in a special angular bracket notation
called a "ket vector"
I W), an expression coined by Paul Dirac 31 , who wanted
a shorthand notation for writing formulae that arise in quantum mechanics .
In a quantum computer, each quoit could be represented by the state of a
simple 2-state quantum system such as the spin state of a spin- ; particle .
The spin of such a particle. when measured, is always found to exist in one o f
two possible states +) (spin-up) and —) (spin-down) . This discreteness
30 Hilbert space is defined to he a complete inner-product space . The set of all
sequences x = (a 1, x2,
) of complex numbers (where
(xir is finite) is
a good example of a Hilbert space. where the sum x + y is defined as
(x1 +
y 1 , x2 + y2 . ' ), the product ax as (am . ax2, - . . ) . and the inner product as
(:r; y) =
x, y, . where .r, is the complex conjugate of
a; i , x
]11 . xz ,
and y = (y i . y2 .
. ) . In modern quantum mechanics all possible physical states
of a system are considered to correspond to space vectors in a Hilbert space .
31
Paul Adrien Maurice Dirac (19021984) . the creator of the com-
plete theoretical formulation of quantum mechanics, was born i n
Bristol. England and studied electrical engineering at the Univer -
sity of Bristol before doing research in mathematics at St John' s
College at Cambridge . His first major contribution to quantum
theory was a paper written in 1925 . He published The principles
of Quantum Mechanics in 1930 and for this work he was awarded
the Nobel Prize for Physics in 1933 . Dirac was appointed Lucasian
Professor of Mathematics at the University of Cambridge in 1932, a post he held
for 37 years. He was elected a fellow of the Royal Society in 1930 and was awarded
the Society 's Royal Medal in 1939 .
is called quantization . Clearly. the two states can then be used to represen t
the binary value 1 and 0 (see Figure 2.3) . The main difference between quoits
Figure 2.3 . A qubit for the binary values 0 and 1 (picture by courtesy of William s
and Clearwater [258])
and classical bits is that a bit can only be set to either 0 and 1, while a quoit
P) can take any (uncountable) quantum superposition of 10) and 11) (see
Figure 2 .4) . That is, a qubit in a simple 2-state system can have two states
Figure 2.4. Each sphere represents a qubit with the same proportions of the 10 )
and
I 1) (picture by courtesy of Williams and Clearwater [258])
rather than just one allowed at a. time as the classical Shannon bit . Moreover .
if a 2-state quantum system can exist in any one of the states (0) and 11) . it
can also exist. in the superposed state
1P)=at
1 0)+a911) .
(2 .155)
This is known as the principle of superposition. More generally, if a
k-
state quantum system can exist in any one of the following k eigenstates
ci ) ,
I cc) .
. ( c,;) . it can also exist in the superposed state
I P) =
a q
c1) .
(2.156)
where the amplitudes a,, E C are such that E, llo, l l = = 1. and each le,) is
a basis vector of the Hilbert space . Once we can encode the binary values 0
and 1 in the states of a physical system . we can make a complete memory o f
register out of a chain of such systems .

276
2 . Computational/Algorithmic Number Theory
2 .5 Quantum Number Theoretic Algorithms
27 7
Definition 2.5.2. A quantum register, or more generally. a quantum com-
puter. is an ordered set of a finite number of (ubits .
In order to use a physical system to do computation, we must be abl e
to change the state of the system ; this is achieved by applying a sequenc e
of unitary transformations to the state vector 1W) via a unitary matrix (a
unitary matrix is one whose conjugate transpose is equal to its inverse) .
Suppose now a computation is performed on a one-bit quantum computer .
then the superposition will b e
1W) = a 10) + ;31 1) ,
(2.157)
where a.3 E C are such that Ila 112 + 11 3 11 2 = 1. The different possible state s
are
1 0) =
) and 11) _ ( 1)
. Let the unitary matrix bI be
1I =
100) —> 100 )
101) -s I01 )
110)
3	
~
1
I10)+ 
/n 111 )
111) - 
110)—111 )
or equivalently by giving the unitary matrix of the quant.um operation :
/ 1 0 0
0
\
0 1
0
0
1
1
0 0
(2 .160)
_
1
(
1
11 ~
I\
—1
(2.158)
1 1
1
Then the quantum operations on a qubit can be written as follows :
)( 01 ) =
1 0) —1) =
1 0)
1)
7,
1
1 I 1)=1 1)
1110)=( 11
which is actually the quantum gate (analogous to the classical logic gate) :
10)-
I0)—
I 1)
I 1) - F 10)+~11) .
Logic gates can be regarded as logic operators. The NOT operator defined as
NOT=
11
changes the state of its input. as follows :
NOT10)=(1
m
= (
1 1
0
0 )
1
=I 1)
NoT l 1) = (
1
0
( 1~ = ( ) = 1o) .
Similarly, we can define the quantum gate of two bits as follows:
(2 .159)
This matrix is actually the counterpart of the truth table of Boolean logi c
used for digital computers. Suppose now the computation is in the superpo-
sition of the states :
1 110H	
111)
or
1
1
 
110) +111) .
Then using the unitary transformations defined in (2 .160), we have
x[10)— 
111) ='
~110)+ . 
Ili))
	
Ilo) — X111)
=-(110)+111))—2(110)+111) )
= 11) .
12
x ;10)+
1 11) = 2(1 10)+1 11 ))+-(I 10) — I 11 ))
= 110) .
We have just introduced the very basic concepts of quantum computation ,
including quantum bits, quantum states, quantum registers, and quantum

278
2 . Conrputationat/Algorithmic Number Theory
2.5 Quantum Number-Theoretic Algorithms
279
gates and quantum operations. Interested readers are advised to consult, for
example, Williams and Clearwater 's book [258] for more information .
2 .5 .2 Quantum Computability and Complexity
In this subsection. we shall give a brief introduction to some basic concept s
of quantum computability- and complexity within the theoretical framework
of quantum Turing machines .
The first true quantum Turing machine (QTM) was proposed in 198 .5 by
Deutsch [63] . A quantum Turing machine (QTM) is a quantum mechanical
generalization of a probabilistic Turing machine (PTM), in which each cel l
on the tape can hold a qubit (quantum bit) whose state is represented as an
arrow contained in a sphere (see Figure 2.5). Let C be the set consisting of
o E C such that there is a deterministic Turing machine that computes th e
real and imaginary parts of
(1 to within 2– " in time polynomial in ri, then
the quantum Turing machines can still be defined as an algebraic system
A7 = (Q,
F, 6, qo, 0, F)
(2.161)
where
6 :Q x F
r"'{"}
.
(2.162)
and the rest remains the same as a probabilistic Turing machine . Readers
are suggested to consult Bernstein and Vazirani [27] for a more detailed dis-
cussion of quantum Turing machines. Quantum Turing machines open a ne w
way to model our universe which is quantum physical, and offer new feature s
of computation. However, quantum Turing machines do not offer more com-
putation power than classical Turing machines. This leads to the followin g
quantitative version of the Church-Turing thesis for quantum computation :
The Church-Turing thesis for quantum computation . Any
physical (quantum) computing device can be simulated by a Turin g
machine in a number of steps polynomial in the resources used b y
the computing device .
That is . from a computability point of view. a quantum Turing machine
has no more computation power than a classical Turing machine. However .
from a computational complexity point of view, a quantum Turing machine
will be more efficient than a classical Turing machine. For example, the integer
factorization and the discrete logarithm problems are intractable on classical
Turing machines (as everybody knows at present) . but they are tractable o n
quantum Turing machines .
Just as there are classical complexitv classes, so are there quantum com-
plexity classes . As quantum Turing machines are generalizations of proba-
bilistic Turing machines, the quantum complexity classes resemble the prob-
abilistic complexity classes . More specifically, we have :
Figure 2.5 . A quantum Turing machine (by courtesy of Williams and Clearwater
[258])
(1) QP (quantum analogue of P) the class of problems solvable, with cer-
tainty, in polynomial time on a quantum Turing machine. It can be show n
that P C QP . That is. the quantum Turing machine can solve more prob-
lems efficiently than a classic Turing machine .
(2) BQP (quantum analogue of' BPP) is the class of problems solvable i n
polynomial time by a quantum Turing machine, possibly with a bounded
probability < 1/3 of error. It is known that BPP C BQP C P-SPACE ,
and hence ; it is not known whether quantum Turing machines are mor e
powerful than probabilistic Turing machines .
(3) 2QP (quantum analogue of 2PP) is the class of problems solvable
in expected polynomial time with zero-error probability by a quantum
Turing machine. It is clear that 2PP C 2QP .
2 .5 .3 Quantum Algorithm for Integer Factorizatio n
hr this and the next subsection, two quantum algorithms for integer factor-
ization and discrete logarithms will be introduced .
In 1976. Miller [162] showed that, using randomization, one can factor a n
odd positive composite n. > 1 if one can find the order of an element .r modulo
77 (or more precisely, the order of an element at in the multiplicative group
Q =
(9G foZ)*) . denoted by ord„(:r). The order r of .r in the multiplicativ e
group f (see Section 1.6.7 of Chapter 1), is the smallest positive intege r
r such that c' 1 (mod n) . Finding the order of an element at in f is ,
in theory, not a problem : just keep multiplying until you get to
" 1" , the
identity, element of the multiplicative group C . For example, let rt = 179359,

280
2 . Computational/Algorithmic Number Theory
2.5 Quantum Number Theoretic Algorithms
281
r = 3 E g, and c = (Z/179359Z)*, such that gcd(3,179359) = 1 . To find the
order r = ord179359(3), we just keep multiplying until we get to "1" :
3 1
mod
1793.59
3
32
mod
179359
=
9
33
mod
179359
=
27
3 1000
mod
179359
=
31981
3 1001
mod
179359
=
9.5943
31002
mod
179359
=
108470
319716
plod
179359
=
99644
314717
mod
179359
=
119573
31-1718
mod
1793,59
1.
Thus, the order r of 3 in the multiplicative group g = (Z/179359Z)* i s
14718 . that is. ord, 703 ;,9 (3) = 14718 . Once the order ord„ (x) is found, it is
then trivial to factor n by just calculating
{gcd(x'%2 + 1.n), gcd(x''/2 — 1, n) }
which. as we have shown, can always he performed in polynomial time . For
instance, for x = 3, r = 14718 and n = 179359 . we have
{gcd(319718/2 + 1,179359) . gcd(31471s/2 — 1 .179359)1 = (67.2677) .
and hence the factorization of
n=179359=67 . 2677 .
If one of the factors is not prime, then we can invoke the above proces s
recursively until a complete prime factorization of n is obtained . Of course .
we can choose other elements x in (Z/179359Z)*, rather than 3 . For example .
we can choose x = 5 . In this case. we have ord 1793;s(u) = 29436 . Then we
have
{gcd(5>9936/z + 1 .179359), gcd(529176/2 — 1 .179359)} = (2677.67) .
which also leads to the factorization of n: 179359 = 67 . 2677 . However. in
practice. the above computation for finding the order of a- (Z/nZ)* may
not work. since for an element x in a large group g with n having more than
200 digits, the computation of r may require more than 10 150 multiplications.
Even if these multiplications could be carried out at the rate of 1000 billion
per second, it would take approximately 3 . 10x0 years to arrive at the answer' .
This explains partly why integer factorization is difficult. Fortunately, Shor`33
discovered in 1.994 an efficient quantum algorithm to find the order of a n
element x E (Z/nZ) * and hence possibly the factorization of n . The main
idea of Shor's method is as follows [258] . First of all. we create two quantum
registers for our machine: Register-1 and Register-2 . Of course. we can create
just one single quantum memory register partitioned into two parts. Secondly .
we create in Register-1, a. superposition of' the integers a = 0,1, 2, 3, • which
will be the arguments of f(a) = x" (mod n.), and load Register-2 with all
zeros. Thirdly. we compute in Register-2, f(a) = a i (mod n) for each input
a . (Since the values of a are kept in Register-1, this can be done reversibly) .
Fourthly, we perform the discrete Fourier transform on Register-1 . Finally
we observe both registers of the machine and find the order r that satisfie s
s''
1 (mod n) .
A few words at this point are needed about the relation between th e
Fourier transform and the order-finding (and eventually the factoring) . As
we know, any mathematical function can be described as a weighted sum of
certain "basis" or "elementary building block" functions such as sines an d
cosines: sin x, sin 2x, . and cos x, cos 2x, • • - . The Fourier transform of a
function is the mathematical operation that translates the original function
into this equivalent sum of sine and cosine functions . Simon [236] in 199 4
showed that a quantum computer could obtain a sample from the Fourier
transform of a function faster than any classical computer . Note that there
exist a Fast (discrete) Fourier Transform (FFT) algorithm, developed by Coo-
32 There is however a "quick" way to find the order of an element x in the mul-
tiplicative group g modulo n if the order IcI (where igi = I(Z/nZ)*l = q(n))
of g as well as the prime factorization of [C are known . since, by Lagrange's
theorem. r = ord„(x) is a divisor of Of course, as we know, the numbe r
A(n) is the largest possible order of an element x in the group g . So. once w e
have the value of A(n). it is relatively easy to find ord,,(x), the order of the ele-
ment x E G . For example, let n = 179359, then x(179359) = 29436 . Therefore .
ord1793ss(3) G 29436. In fact, ord1793ss(3) = 14718 . which of course is a divisor
of 29436. However, there are no efficient algorithms at present for calculatin g
either o(ia) or A(n) . Therefore, these two "quick ways for computing ord,,(x )
by either 6(n) or A(n) are essentially useless in practice .
33
Peter Shor. born in 1959. is a mathematician at the AT&T Re-
search Laboratories in Florham Park . New Jersey. After studying
at the California Institute of Technology he gained a PhD at the
Massachusetts Institute of Technology . Before going to AT&T in
1986. the was a postdoctoral researcher for a year at the Mathemat -
cal Research Center in Berkeley, California . Perhaps best know n
for his 1994 work which shows that integer factorization can b e
performed in polynomial time on a. quantum computer. Shor re -
ceived the Nevanlinna Prize at the 1998 International Congress of Mathematicians .
Berlin. (Photo by courtesy of Dr . Shor.)

Number Theoretic Algorithms
28 3
1
q— 1
1 W2)
=
/C~ /
I a)
I .c" (mod rr)) .
(2.164)
)/-q-i "=o
This step can be done reversibly since all the as were kept in Register-1 .
[4] [Perform a quantum FFT] Apply FFT on Register-1 . The FFT maps eac h
state
1 (t) to
c
That is, we apply the unitary matrix with the ((pc) entry equal t o
iq exp(2triac/q) . This leaves the machine in the state
1 ( ;) :
exp(2ar/q)c) .
(2.165 )
p(2;ri.ac/q) c) x" (mod ra)) .
(2 .166)
[5] [Detect periodicity in x"] Observe the machine. For clarity, we observe bot h
I c) in Register-1 and
1 s" (mod It)) in Register-2, measure both argument s
of this superposition, obtaining the values of lc) in the first argument an d
some
(mod a)) as the answer for the second one (0 < k < r) .
[6] [Extract r] Finally extract the required value of r . Given the pure state I P,;) ,
the probabilities of different results for this measurement will be given by th e
probability distribution :
282
2 . Computational/Algorithmic Number Theory
1ev and Tuley'in 1965 [53] ; there exists also an efficient quantum algorith m
for Fourier transform which is a quantum analog of the FFT . Shor first real-
ized that if he could relate the problem of finding factors of a large numbe r
to that of finding the period of a function . then he could use Simon's idea
for sampling from Fourier transform . Now we are in a position to give Shor' s
quantum algorithm for integer factorization .
Now we are in a position to give Shor's quant. nn algorithm for integer
factorization .
Algorithm 2.5.1 (Quantum algorithm for integer factorization) .
Given integers :r and n, the algorithm will find the order of .r, i .e., the smallest
positive integer r such that
= 1 (mod ra) . Assume our machine has two
quantum registers : Register-1 and Register-2, which hold integers in binary form .
[1] [Initialize] Find a number q, a power of 2, with n' < q < 2n 2 .
[2] [Prepare information for quantum registers] Put in Register-1 the unifor m
superposition of states representing numbers a (mod q), and load Register -
2 with all zeros. This leaves the machine in the state I P I ) :
— i
I PI)=
~~I a )I0) .
(2.163)
a=0
(Note that the joint state of both registers are represented by
1 Register-1)
and
1 Register-2)) . What this step does is put each bit in Register-1 into th e
superposition
1
( l0)+I1))
Prob(c,x k ) _
exp(2rriac/q)
(2.167)
[3] [Create quantum-parallelly all powers] Compute x° (mod ra) in Register-2 .
This leaves the machine in state
1 P2 ) :
at
John Wilder Tukey (1915-2000) as educated at home by his par-
ents who were both teachers : his formal education began only when
he entered Brown University, where he earned his bachelor's an d
master's degrees in chemistry in 1936 and 1937, respectively. He
then went to Princeton University in 1937 to study mathemat-
ics and obtained his doctorate in 1939 . He was a faculty member
at Princeton from 1939 to 1970 . and in the same time he was
a Member of Technical Staff at ATRT Bell Laboratories fro m
1945 to 1985 . In 1965 ; in a paper with J. W. Cooley- published in Mathematics
of Computation, he introduced the important "Fast Fourier Transform" algorithm .
a mat hematical technique that greatly simplifies omputation for Fourier series an d
integrals. For many people this will be the work for which he is best known. Hoiy-
ever, it is only a small part of a large number of areas with which he made significan t
contributions .
where the sum is over all values of a such that
(mod n).
(2.168)
Independent of k, Prob(c,x a') is periodic in c with period q/r ; but since
q is known, we can deduce r with just a few trial executions (this can b e
accomplished by using a continued fraction expansion) .
[7] [Resolution] Once r is found, the factors of as can be possibly obtained from
computinggcd(ar' ---1,n) and gcd(.r'''-+1.n), that is, the pair of integer s
(a, b) satisfying
((Lb) = {gcd(x [
Ea) . gcd(a,''/'- + 1, n) }
could be the nontrivial factors of n . If it fails to produce a nontrivial facto r
of it, goto step [1] to choose a new base .
Steps [6] and [7] of the algorithm are purely classical computation an d
hence can be performed on a classical computer . Compared with the best.

284
2 . Computational/Algorithntic iNrumber Theory
2.5 Quantum Number Theoretic Algorithms
28 5
known factoring algorithm NFS with asymptotic running time, as we already
know .
0 (exp c(logn) ' ''3 (log logn.) 2/
for some constant c depending on details of the implementation, the quantum
factoring algorithm takes asymptotically
0 (log n.) 2 (log log n)(log log log n) )
steps on a quantum computer and °(toga) amount of post : processing time
on a classical computer that converts the output of the quantum computers .
That. is, Shor's quantum algorithm can factor integers in time 0 ((log n) 2-`) )
It should be noted that Shor's factoring algorithm is probabilistic, no t
deterministic, that is, it can sometimes fail . In fact, it will fail if
(1) r is odd. in which case r/2 is not an integer .
(2) xr/2 E. -1 ( mod n) . in which case the algorithm yields the trivial factor s
1 and n .
For example, when n = 21 = 3 . 7, we have the related values for the order o f
x modulo 21 for x = 1, 2 
20 and gcd(x, 21) = 1 (the order may not exis t
for some x when gcd(x, 21) CUUJQYPKP6CDNG.3 . Thus, of all the 20
Table 2.3 . Various values about the order of x modulo n
x
r
r odd
x '' ~2 = -1 (mod n)
1
1
Yes
2
6
4
3
Yes
5
6
Yes
8
2
10
6
11
6
13
2
16
3
Yes
17
6
Yes
19
6
20
2
Yes
cases. Shor's algorithm only applies to 12 cases in which the order r exists '
and of these 12 cases six (exactly half) will fail, since three have r odd an d
three xf/2 = -1 (mod n) (see Table 2 .3) . Thus, in this particular example .
Note that the order r of .r modulo 21 exists if and only if gcd(x, 21) =
1 for
x = 1, 2 . -
. 20 . Recall that (see Theorem 1 .2.19 in Chapter 1) if' two integers a
and b are chosen at random, then Prob[gcd(a, b) = 11 = 0.6. Thus, about 40`7e of
the x will fail to produce an order r . For example when n = 21, the order r wil l
not exist for x = 3.6,7,9,12,14 .
14,15.18 .
about 70% of the values of' x cannot lead to a successful factorization of n .
Generally, when r exists (that is. Z/n711 forms a multiplicative group) . Shor's
algorithm will produce a nontrivial factor of n with probability > 1— 1/2i'— r
where k is the number of distinct odd prime factors of n . In the case n = 21 .
this probability is 1 — 1/2 2 ' = 1/2. which agrees with the calculation in
Table 2.3. In public-key cryptography (see Chapter 3 of this book), however ,
the integers to be factored are specifically chosen with two prime factors ,
each having the same size. thus Shor's algorithm will fail for about 50% of
the values of r . and hence is not very useful . The main problem here is that
Shor's factoring algorithm is not really a factoring algorithm, but rather a n
algorithm for finding the order of element .r modulo n., which will lead to
a successful factorization of n for only about half of the values of r . In the
author's opinion, a good quantum algorithm would be the quantum versio n
of the best classical factoring algorithm such as Number Field Sieve (NFS )
or Quadratic Sieve (QS) .
2 .5 .4 Quantum Algorithms for Discrete Logarithm s
It is clear that the finding of' the order of x modulo n is related to the compu-
tation of discrete logarithms . Recall that the discrete logarithm problem may
be described as: given a prime p. a generator g of the multiplicative group
modulo p, and an x modulo p, find an integer r with 0 < r < p — 1 such
that q'
( mod p) . As a by-product, the quantum factoring algorithm can
also be used, of' course with some modifications, for the computation of' dis-
crete logarithms. The following is a sketch of Shor's algorithm for computing
discrete logarithms .
Algorithm 2.5.2 (Quantum algorithm for discrete logarithms) .
Given g, x E N and p prime. This algorithm will find the integer r such that
g' - x (mod p) if r exists. It uses three quantum registers .
[1] Find q a power of 2 such that q is close to p, that is, p < q < 2p .
[2] Put in the first two registers of the quantum computer the uniform super -
position of all
I a) and lb)
(mod p — 1), and compute y°'x —b (mod p)
in
the third register . This leaves the quantum computer in the state
I Pr) :
[3] Use the Fourier transform A,, to map
1 a) —r
I c) and
1 b) - Id) with
probability amplitude
1
1
2-i
q exp
( 
(at+ bd)
a, b. q°x—e (mod
(2 .169)
1
y—2 p— 2
-0 b= o

286
2 . Computational/Algorithmic Number Theory
2 .6 Miscellaneous Algorithms in Number Theory
287
Thus, the state
a . b) will be changed to the state :
 
(ac + bd)
C. (I) .
(2.170)
4
This leaves the machine in the state P,) :
1- 1
qf(?)
0)-1)(1
exp
(2xi (a( +bd)~
; d .
c-z (mod p))
1
(2.171 )
[4] Observe the state of the quantum computer and extract the required infor-
mation . The probability of observing a state c . d. gr' (mod p)) is
2 .6 Miscellaneous Algorithms in Number Theor y
We have. so far. introduced in this chapter three important types of algo-
rithms for primality testing . integer factorization and discrete logarithms .
There are. however_ many other algorithms for solving different, sorts o f
number-theoretic problems. This section aims to provide some algorithms
for computing the exact value of x(x), for verifying Goldbach's conjecture
and for generating amicable numbers . Many important algorithms in com-
putational number the envy. such as those for computing the nontrivial zero s
of the Riemann (-function and those for checking the odd perfect numbers .
are omitted; it would be impossible for a single book to contain discussion s
on all sorts of algorithms in computational number theory .
exp 
(ac + bd)
4
(2.172)
2 .6 .1 Algorithms for Computing 7r(x )
where the sum is over all (a b) such that
a — rb —
k: (mod p — 1) .
(2.173 )
The better outputs (observed states) we get, the more chance of deducing r
we will have; readers are referred to Shor's original paper for a justification .
The above quantum discrete logarithm algorithm uses only two modular
exponentiations and two quantum Fourier transformations . It is significantly
faster than any classical discrete logarithm algorithm .
As many important computational problems have been proven to be A.-P-
complete, quantum computers will not likely become widely useful unless the y
can solve ,A"P complete problems . At present, we do not know whether or no t
a quantum computer can solve an A"P complete problemn although there are
some weak indications that quantum computers are not powerful enough t o
solve A '''P-complete problems (Bennett et al., [26]) . It is worthwhile pointin g
out that at present no-one knows how to build a. quantum computer . Even if
such a computer could in principle be constructed. there are still enormou s
technical issues to overcome before reaching this goal . Much work needs to
be done! Despite the great difficulty of constructing a. truly general-purpose
quantum computer, it might be relatively easy to construct a. special-purpose
quantum factoring machine which could be used for coda breaking. History
does have a tendency to repeat itself: were not the first digital computer s
used for coda breaking?
In Section 1 .5 of Chapter 1, we studied the asymptotic behaviour of the prim e
counting function 7r(.r) (recall that 7r(.r) is the number of primes up to :r) .
In this subsection, we shall discuss some modern methods for calculating the
exact values of ( .r).
The most straightforward method is, of course, to use the ancient sieve
of' Eratosthenes to find and count all the primes up to .r. According to the
Prime Number Theorem (PNT), it is not possible to have a method tha t
computes 7(:r) with less than about :r/ ln,r arithmetic operations. Despite
its time complexity, the sieve of Eratosthenes was for a very long time the
practical way to compute lr(.r) . In the second half of the 19th century . the
German astronomer Meissel86 discovered a practical combinatorial metho d
that does not need to find all primes p < .r. He used his method to compute by
hand 7x(108 ) and 7(10 9). In 1959, Lehmer extended and simplified Meissel' s
method (now widely known as the Meissel-Lehmer method, and he used th e
method on an IBM 701 computer to obtain the value of 7x(1010) . In 198.5 .
s6
Daniel Friedrich Ernst Meissel (1826–1895) studied at the Univer-
sity of Berlin working under Jacobi. He also had contacts wit h
Dirichlet . His doctorate was from Halle. He taught in a number o f
places. including in Kiel from 1871 until the end of his life . Meis-
sel's mathematical work covers a number of areas . He worked on
prune numbers giving the result that there are 50847478 primes
less than 109 . Lehner showed, 70 years later . that this is 56 too
ew. In addition to other number theory work on Mains inversion
and the theory of partitions . Meissel wrote on Bessel functions. asymptotic analy -
. refraction of light and the three body problem His main skill was in numerical
calculations and manipulation of complicated expressions .

288
2 . Computational/Algorit unit Number Theory
2.6 Miscc aneous Algorithms in Number Theory,
289
Lagarias'', Miller and Odlyzko' s adapted the Meissel Lehmer method an d
proved that it is possible to compute 77(x) with 0 ( .r--/'/ In x) operations an d
using 0(5[ 1 ./3 1n' In In r) space. They used their method to compute severa l
values of 77(x) up to x = 4 . 10 16. More recently, Deleglise and Rivat [59]
proposed a modified form of the Lagarias . Miller and Odlyzko method, which
computes 77(x) with 0 (a:2/'/ ln 2 x) operations and using 0(.c1f3 113 xInln .r)
space. They used this method to compute several values of 7r(r) for :r up
to 10 19 . In what follows . we shall first introduce a simple form of Meissel ls
method :
Theorem 2.6.1. If p 1 . p,. .- .p h. are the primes less than or equal to ta ,
then the formula for computing 77(x) is :
77(n) =
n-1+7(01) -{
1 ]
+ [tz + . . .+ [1 1
P1
P2_
Pk _
1t
rt.
+ P1P21 + [PIPS _
[PIP=P:3I
+--- +
k 
n
PIP2
Pk
Jeffrey C . Lagarias is a member of the Mathematics and Cryptog -
raphy Research Department at AT&T Research Labs in Florham
Park. New Jersey. He is a very active research scientist with mor e
than 120 papers in number theory . Diophantine approximation.
dynamical systems, harmonic analysis, discrete geometry, mathe -
matical programming and optimization . computational complex-
ity theory. cryptography and neural networks . (Photo by courtesy
of Dr. Lagarias .)
sell-known scientist in computational number theory. computa-
tional complexity, coding and cryptography. -Andrew M. Odlyzko
studied Mathematics at the California Institute of Technology an d
obtained his PhD in Mathematics at the Massachusetts Institute
of Technology in 1975 . He is currently the head of the Mathemat -
ics and Cryptography Research Department at AT&T Research
Labs in Florham Park . New Jersey. Odlyzko has made significan t
contributions to several central areas of number theory and cryp-
tography. (Photo by courtesy of Schwarz and Wolfgang [223] .)
Example 2 .6 .1 . We shall show in this example how to use the Meissel' s
method to compute 77(129) . First note that
(029) = .5: the primes les s
than or equal to x/129 are 2,3 .5 .7 and 11 . By (2.174), we have :
129
2 . 3 . 7 . 1 1
129
129
3 . 57 . 11
2-3 . 5 . 7 . 11
129-1+5-64-43-25-18-11+21+1 2
+9+5+8+6+3+3+2+1-4-4-1-1- 1
-0-1-0-0-0+0+0+0+0+0- 0
31 .
That is, there are exactly 31 primes up to 129.. It is of course true, since the
following are the only primes < 129 :
2, 3. 5, 7 ; 11, 13 . 17, 19 . 23 . 29. 31. 37 .. 41 . 43. 47, 53. 59. 61, 67, 71 .
73, 79, 83, 89, 97, 101 . 103, 107, 109, 113, 127 .
We are now in a position to introduce a modern algorithm for computing
77(x) . due to Meissel. Lehnler. Lagarias. Miller. Odlyzko. Deleglise and Rivat
[59] .
Theorem 2.6 .2 . Let p, p2 .
' - - denote the primes 2 . 3. 5, - - - in increasing
order. Let 9(x, a) denote the partial sieve function, which counts numbers <
with all prime factors greater than p,, :
37
3n
x(129)
129-1+5
+ [1291 +
3
129
129
1 1
7
+
+223]
+[229
+
+ [31211
+[129 1 +
129
129
2-7
+[ 2 . 1 1
 129
[
129
5 . 11
2-3 . 5
+ [ 129 - + 129
3 . 5
3 . 7
tL
P2P 3
Pk—2N—lPk
1 1
+ . . .+
Pk— 1Pk
(2.174)
+ . . .
+
+
129
129
2 . 3 . 5 . 71 + [2 . 3 . 5 . 11
+
129
2 . 57 . 1 1
2 . 3 . 71 - [2 . 3 . 11
129
-
129
[
129
3 . 5 . 7
3 . 511
3 . 7 . 11
129
2 . 5 . 1 1
129
5 . 7 . 1 1
129
2 . 5 . 7

290
2 . Computational/Algorithmic Number Theory
2 .6 Miscellaneous Algontlmis in Number Theory
291
d(a:,a)= {n<a
'p>poll
(2.175)
So =
(2.181 )
x
n
and let
Pt.(x, a) = #{n < a :; qa = grg2
. .
. (it a d qr, qa	
qt. > A, }
(2 .176)
which counts numbers < .r with exactly k prime factors. all larger than pa . If
we sort the numbers < x by the number of their prime factors greater than
po , we obtain
9(x, a) = Po (a:, a) + Pi (x, a) +
+ PP (x. a) +
.
(2.177)
where the sum on the right-hand side has only finitely many non zero terms ,
since Pt (a:,a) = 0 for P[ > x. Finally let y be an integer such that xi/'j <
y < x c/'2 and let a = tc(y) . Then we have
n< y
S =
E
/(n)o ( x(S(n)) – l) ,
(2.182)
ra/5r)<y< n
and d(n) denotes the smallest prime factor of n. The computation of So can
be done in O(y In In a:) time which is negligible. Thus. the main computation
of 9(x . a) is in computing S . which can be computed by
S = Sj + S2 + S3 ,
(2 .183)
where
E
p(m)9 
x(p)
1
(2 .184)
np
xl /3<p<y
abr,)> P
/r(:r) = c5(x
– P> (a:, a) + a – 1 .
(2 .178)
p(m)92
- x(p)
1
,1/-1<P<.r1/3
_b(in)>P
(2 .185)
S2
That is, r(x) can be obtained by the calculation of ¢(x, a) and P2 (x, a) .
Thus, the algorithm for computing x(x) has just the following two main
steps:
[1]Computing P2 (x, a) .
[2] Computing q(x, a) .
In what follows, we shall give a brief description of the two main computatio n
steps in the algorithm.
[1] Computing P7(x,a). Note first that
[1-1] count all the prime pairs (p, q) such that y < p < q and pq
[1-2]pE[y+1.V/.],
[1-3] for each p . q E [p, a:/p] .
Then, we have
The computation of P> (x . a) can be done in O(x/y In In x
space .
[2] Computing o(x, a) . The formula for computing b(x, a) can be expressed
as follows:
a.
µ(m)9 mp (p)
1
(2 .186)
P <rl/3
61,n)> P
The computation of Si can be done in constant time which is negligible, sinc e
S, can be written as follows :
S, =
E
—,
x (p) – 1
:z• 1/I <p<y p<q< y
(x(y) – x(r1/"))(x(y) 
x (
2
However . the computations for S2 and S3 are more complicated and need to
be broken down into several small steps in order to speed up the computation .
For example. we can split S2 in the following way :
- 1
.r1/2<p< .,.1/ :3 p<q<y
pq
U+
U+T
+
li+ii+T1'i +1F2 +TT•e+Hi+Tl5 .
(2 .188)
P2 (a,a) =
y<P«
(2.179)
O(y )
S3 _ –
– 1)
(2.187)
S2
=
where
U =
E
(x (y) –r (p2))
(2 .189)
vx/y<P<x1 / 3
d(r a) = So + S,
where
(2.180)
.x1/^<p<¢1/3
p<q<rnin(a;/p 2 ,y)
(2—x(p))
(2 .19(1)

292
2 . Computational/Algorithmic Number Theory
2 .6 Miscellaneous Algorithms in Number Theo
293
(2.191)
t%a<P<a .<Pf.
P<g< y
E
x
.Vz / y< P <z1/
V:c/P<g<r/rf
pq
It is clear that the significant time and space are spent only on all com-
putations of P>(x.a) . H si , TT>, T T 3 . 1 E 1 , T T 15 . S; . As analyzed by Deleglise
and Rivat [59], the space complexity .s( .) and the time complexity tO of the
algorithm are :
s(r(.r)) = 0(y)
2/3
(2.196)
I
(2 .197)
t(7(x))=0 Gln1nJ.+yln .rinln .r,+rr/ly+ln7
.
If we choose y = x r/3 ln 3 r1nInx, then
r t `
t(it r)) =
-
1n- J .
2.6.2 Algorithms for Generating Amicable Pairs
Recall that a pair of positive integers (Ilan) is an amicable pair if a(m) =
a(n) = na + a_ There are three essentially different methods for generatin g
amicable pairs : exhaustive numerical method . algebraic assumption metho d
and algebraic constructive method . In 1993. Herman J . J . to R9e4e [2041 pro -
posed a new method based on the following observation of Paul ErdOs :
Proposition 2 .6 .1 . Given a positive integer
s, if
are integer so -
lutions of the equation
a(x) = s .
(2 .198 )
then any pair (x ;, ar) ) for which art + xj = s is an amicable pair.
Proof. Since a(x i ) = a(x )) = .s and x; +
= s.
q
Since this method has a strong connection with numerical methods, al-
though it is not exhaustive. we call it a seminumerical method. From a com-
putational point of view. it should not be too difficult to calculate all th e
integers within a certain range . which have the same value. For example
for 200 < a < 300, all the following integers
204. 220, 224 . 246, 284. 286
have the same a-value 504, but of course . only 220 + 284 = 504. Instead of
randomly selecting the numbers xi , :r 2 ,-
as candidates for the solution of
(2.198) . Te Riele used the so-called smooth numbers (i.e . . numbers with only
small prime factors) as candidates to the solution of' (2 .198). His idea is based
on the number-theoretic fact that if a(p°)
s where p is a prime and a a
positive integer . and if a(y) = s/a(p°) has a solution y with gcd(y,p) = 1 ,
then x = yp° is a solution to a(r) s . Based on this fact, a recursive
algorithm can be designed to find a factor a(p") of s and to solve a(y) =
s/a(p") with gcd(p, y) = 1 . The following is the algorithm .
Algorithm 2 .6 .1 (Te Ride's algorithm for amicable numbers) . For
a given integer s, first find as many solutions as possible to the equatio n
a(r) = s, where 2
1
J . or 3
1
J . but 6 { r, and then find amicable pairs among th e
pairs of solutions found. Two tables Tr and T are used to store the informatio n
concerning the triples
(p, (■, p°) ; the
triple from table Ti
(resp . T)
is
denoted by T; (resp . T;) . Solutions are stored in J. ] .X2 .''' . Choose upper
bounds B i and B2 for the a-values admitted in Ti and T, respectively .
[1] [Precomputation of Tables of a(p")-values] . Fill table T with triples
(p, a . a(p°)) for p = 2 .3 and for those integers a = 1 .2 . . . . for whic h
a(p°) < Br . Similarly, fill table T2 with all primes p=5,7 . •'
. and integers
a = 1 .2.- . for which a(p') < B2 , such that the a(p°)-values are in in-
creasing order. Set and jt„,,. to the number of triples in Table Ti and
T2 , respectively .
[2] [Initialization]. Set d t- 1 . sa - .s. i — O.
ra F O. The current value of d
indicates that the d en' prime factor of r is being looked for (so d — 1 prime
factors have been found so far) . The integer sd is the current value of s fo r
which a(x) = s is being solved ; ,j, (d > 2) records the location in Table T2
where a prime power factor of .r has been found ; p,i and e, t are the prime
and the corresponding exponent in that prime power .
[3] [Select next triple from T] . Set i
i + 1. If i >
i,na,. goto step [8] ,
otherwise set (p . a . a) t— Tr, . If a {
.S'3, repeat step [3], otherwise set
Pi e- p, a l
a. d~-2 .. s_>si /a, sq
s2 , j~0 .
YF2
T (
(2.192)
11"3
=
II 7 1
=
x
CPq~
(2.193)
tty=<P<N-,/y
N/.rfp<q<y
\
(2 .194)
J :r/y<p< :r t/3
P<g0/P
(2 .195)

294
2 . Computational/Algorithmic Nu her Theory
2 .6 Miscellaneous Algorithms in Number Theory
295
[4] [Select next triple from
T2] . Set j – j +
1 . If j >
goto step [5] ,
otherwise set (p . a. a)
T2j. If p = p i for some l E {2, 3, . . . ,d – 1} ,
repeat step [4]. If a > .sq, goto step [6] . If a
sd, set
.74
j, 7~d <– p, ad {– a, sd+1 <– sd/a, sq
3`sd+i, d {– d + 1 .
Repeat step [4] .
[5] [Check if s d – 1 is prime] . If sd – 1 is prime, set
d
nt–72+1 .
Goto step [7] .
[6] [Check if sd occurs as a-value in table T2]. If there exists l and T21 = (p. a . a)
with a = .S ,h set
d—i
n4—n+1,
E—j/ HEk" .
k= 1
Goto step [7] .
[7] [Decrease depth d] . Set d = d – 1 . If d = 1, goto step [3], otherwise set
j = jd, sq t– sd , return to step [4] .
[8] [Sort solutions and check pair sums]. Sort the solutions , r,, i n
decreasing order and find amicable pairs, i .e., pairs (x 1 . .i) with xi +xi = s .
Notice that the size of the members of amicable pairs found is close to .9/2 .
Example 2 .6 .2 . Applying the above algorithm with B 1 = 70, B2 = 100 to
s 504 yields the following five solution s
(xi
l2 . xs, x4 r5 ) = (286.334,220,284,224 )
where (:c , x4) = (220, 284) is an amicable pair since x3+x4 = s. The equation
a(x) = 1504 has five more solutions, viz . . .c = {204, 246, 415, 451 . 503}, but the
first two of them are divisible by 6, the next two of them have a smallest prim e
factor > 3 (namely. 5 and 11), whereas the last one (i .e . . 503) is a prime. Such
solutions were excluded from the algorithm .
Let. N be the number of solutions .2 of a(x) = s found by the algorithm .
What is the probability of finding an amicable pair (x t .a'2) among the 1',s
solutions for which x l + x2 = .s? Te Riele[s experiment shows that if Ns ,s:{ .V[[/.;. ,
and if solutions are "randomly" distributed in [1, s], then the values of A's/f
are in the range (0.01, 0 .43) (see Table 2 .4 for more information) .
Table 2.4.N,/fors=i! .
=8,9 .
.1 5
0.1494
0 .3014
0 .3113
0 .2635
0 .3198
13!
0 .325 1
14!
0 .3730
0 .3869
0 .392 4
3 . 14!
200965 EIMMI
®®®
8 . 14!
331105
0.396 5
12 14!
449253
0.4392
2 .6.3 Algorithms for Verifying Goldbach's Conjectur e
As mentioned in Section 1 of Chapter 1 . Goldbach in 1742 made a famous
conjecture concerning the representation of an integer as a sum of prim e
numbers. Goldbach's conjecture. after some rephrasing. may be expressed as
follows :
(1) Binary Goldbach Conjecture (BGC) : Every even number > 6 is the su m
of two odd primes. For example. 6 = 3 + 3, 8 = 3 + 5. 10 = 3 + 7.12 =
5+7 .
(2) Ternary Goldbach Conjecture (TGC) : Every odd number greater tha n
7 is the sum of three odd primes . For example, 9 = 3 + 3 + 3 . 11 =
3+3+5, 13 = 3 + 5 + 5.15 = 3 + 5 + 7.
.
Clearly. the binary Goldbach conjecture (BGC) implies the ternary Goldbac h
conjecture (TGC) . Much work has been done on this conjecture by man y
of famous mathematicians, including Hardy and Littlewood, though thes e
conjectures still have not been completely solved yet . The best known result s
concerning Goldbach's Conjectures can be summarized as follows (here we
let A"o denote a sufficiently large even number . Pi . P2 , P; and P I be primes ,
E the even number > 6 . 0 the odd number > 7. and GRH the Generalized
Riemann Hypothesis) :

296
2 . Computational/Algorithmic Number Theory
2 .6 _Miscellaneous Algorithms in Number Theory
29 7
(1) Binary Goldbach Conjecture :
(i) Theoretical Result :
(a) Unconditionally, every sufficiently large even number can b e
represented as a sum of one prime number and a product of a t
most two prime numbers . That is . E = Pr +P., - P3 with E > No .
This result was proved by J . R. Chen [46] in 1973 .
(b) Assuming GRH, every even number can be represented as a
sum of at most four prime numbers . That is. E = Pt + P2 +
P3 + P4 under GRH . This result is a consequence of Kaniecki ,
and Deshouillers, Effinger. Te Raele and Zinoviev [62] . (Ramare
proved that unconditionally every even number can be repre-
sented as a suns of at most six prime numbers . )
(ii) Numerical Result : BGC is true up to 4 . 10 1r (Richstein [201]) .
(2) Ternary Goldbach Conjecture :
(i) Theoretical Result:
(a) Unconditionally. TGC is true for all odd numbers > 10 43000 :
this is a refinement of Chen and Wang over V'inogradov's famou s
three-prime theorem .
(b) Assuming GRH . every odd number > 7 can be represented as a
sum of three prime numbers . That is, 0 = Pr + P2 + P3 under
GRH . This result is due to Deshouillers, Effinger, Te Riele an d
Zinoviev [61] .
(ii) Numerical Result : The TGC is true up to 10' 0 . It was verified by
Saouter [216] in 1995 .
The above results are diagrammatically shown in Figure 2.6. Readers may
also find the historic computation results (see Table 2 .5) concerning the BGC
interesting. In what follows. we shall introduce two algorithms for verifying
Goldbach's conjecture .
First . let us introduce an algorithm for verifying TGC, based on Saoute r
[216] who used it to verify TGC up to 10 20 . Observe that. if n is an odd
number, p a prime, and rn — p the sum of two primes. then n is the sum o f
three primes. It is already known that BGC is true up to 4 - 10 14 (Richstein
[201]) . Thus, if n is an odd number and there exists a prime p such that
— p < 4 . 1011 . then n is the sum of three primes. So Saouter's algorithm
just amounts to exhibiting an increasing sequence of prime s
Po, PI,P2 
Pi
such that
P0 <4'i0'
.
Pi
Pa—r<4 . 1011 ,
i=1,2, .--,l andpi >10'0 .
(2.199)
Saouter's algorithm has the following form :
Algorithm 2.6.2 (Saouter's algorithm for verifying the TGC). Thi s
algorithm verifies TGC in the interval [4 . 10 1 ',1020 ] .
[1] (Initialization] Set i = 0 and let p, = 33 . 2"' + 1 = 138412033 (a prime
number) .
P1+P2
Pi + P2 P3
6
4 . 10"
No
(i) Binary Golbach conjecture
Table 2 .5. Historic computation results concerning BCC
P1+P2+Ps]
Assuming GRH, Pi + P2 + P3
Verified ba
Date
Limit
A. Desboves
1855
104
N. Pipping
1940
10'
M . K. Shen
1964
3 .3
. 10'
M . L. Stein and P. R. Stein
1965
10 3
A. Granville. J . v . d. Lune and H . .1 . J . to Riele
1989
2 . 1010
M. Sinisalo
1993
4
10 ` 1
J. M. Deshouillers, H.J .J. to Biele and T . Saouter
1989
10 1 1
.1 . Richstein
1998
4 . 1074
102°
Unconditionally. P i + P2 + P3
1043000
(ii) Tertnary Goldback conjecture
Figure 2.6. Best known results on Goldbach s conjecture

298
2. Computational/ Algorithmic Number Theory
2.6 Miscellaneous Algorithms in Number T
299
[2] (Is p, Prime?) If pi is a prime, the n
i=i+1 .
Pi =
+ 95360 . 2'1
(2 .200)
else
P1=p,–10 .22.
(2 .201)
[3] (p, < 1020?) If p, <
then goto Step [2], else terminate the algorithm .
According to Saouter [216] . if the algorithm terminates, then TGC is true
up to 10 L0 . However the converse is not true .
Next comes the algorithm for verifying BGC . originally used by Shen
but explicitly given by Deshouillers, Saouter and Te Riele in [62] (hence we
called it the DSR algorithm), and also subsequently used by Richstein [201 ]
for verifying BGC up to 4 . 10' `r . The algorithm can be briefly described a s
follows :
Algorithm 2.6.3 (DSR algorithm for verifying the BGC) . This algo-
rithm tries to verify BGC on a given interval [a, b] by finding two sets P and (2
such that P + (2 covers all the even primes in the given interval [a,b] . Let P, be
the ith odd prime number .
[1] [Generating/Sieving the Primes in Sets P and Q] For every even numbe r
e E [(Lb], find a prime q, close to a, for which b – a is a prime . (This
amounts to choosing for P the set of odd primes up to about b – a and for
(2 the k largest primes q i < qz < .'' < q k. below a, for suitable k ; both the
generation of P and (2 can be done by the sieve of Eratosthenes .)
[2] [Checking whether P+Q Covers all the Even Numbers in [a, b]] Generate
the sets
FCF1 cFC
.
.
defined by
Fo = 0 .
F' = F,_
1 U (P + (p+i), i = 1 .2 . . .
until for some j the set F covers all the even numbers in [a .. b] .
There are several different implementations of this classical algorithm on
different types of machines . varying from SGI \Vol kstations to the Cray C91 6
supercomputer. Interested readers are referred to Deshouillers . Te Riele and
Saouter [62] and Richstein [201] for more information .
2.6.4 Algorithm for Finding Odd Perfect Number s
Recall that a positive integer n is perfect if a(n)
2n . All known (in fact ,
thirty-seven at present) perfect numbers are even perfect . and there is a one-
to-one correspondence between even perfect numbers and Mersenne primes .
that is . 2P–1 (2 r' – 1) is perfect whenever 2 P – 1 is prime. However, no odd
perfect number has ever been found, and the question of the existence o f
an odd perfect number has become one of the most notorious problems i n
number theory. In this subsection, we shall outline an algorithm . based on
Brent . Cohen and Te Riele [39], for finding an odd perfect number less tha n
a given bound B (if one exists) or proving that there is none, by checkin g
each odd number A < B .
First note a simple fact, due to J . J . Sylvester . that any odd perfect
number has at least three prime factors. since if n = pa q.3 is perfect, where p
and q are distinct odd primes, then a contradiction is reached as follows :
2
a(q
q3
. .+ n) \l+1+
1
+ .
. .+
1 )
P
q
q-
+-+2r+
.l .(1+5+25+125 f
. )
2
4
< 2.
k
k
Now let. n = ]l p ` `, then a(n) = ]l cr(pi `) . Hence .
;_r
;–r
a(n)
1
2 = 
<
I ?
U 1–1/p,
i= l
Using (2.203) . it is easy to show that n must be divisible by a reasonably
small prime p = o(log B) . which gives a finite number of possible prim e
powers p Many of the methods for odd perfect numbers are based on th e
simple fact that if n is an odd perfect number. and p" ! n . where p is prime
and a is even. then n p"a(p") >
. Methods based on this observation
require the explicit factorization of a(p a ) for large values of pa . However .
fewer factorizations would be required if it were known that
n
> p' for
> p"'/2 . and in some cases. the exponent on p can be raised almost t o
3a. By using these various techniques to restrict attention to prime power s
pa < B2/5 . Brent, Cohen and Te Riele [39] were able to prove that there are
(2.202)
(2 .203)

300
2. Computational/Algorithmic Number Theory
2 .7 Bibliographic Notes and Further Rear g
301
no odd pee feet number less than 10300 . Thus. an algorithm for odd perfec t
mmnbers can be outlined as follows:
Algorithm 2 .6.4 (Algorithm for odd perfect numbers) . Let n be an
odd perfect number, and p"
H) n, where p is prime and ct is even . This algorith m
tries to find an odd perfect number less than a given bound B (if one exists) or
to prove that there is no odd perfect number less than B. The algorithm make s
use of the simple fact that if p" i)
it, then (Hp")
2n .
[1] Use various factoring algorithms such as ECM, MPQS and NFS, to factor
the prime powers p" < B2/3 .
[2] If we deduce more and more primes which divide n, but eventually a contra -
diction to n < B will occur, then there is no odd perfect number less tha n
B .
[3] If we converge to a finite set of primes which do divide n, then n is an od d
perfect number .
Clearly, the main task of this algorithm is the prime factorization of dif-
ferent, particularly large, values of p" . In practice. step [3] in Algorithm 2 .6 .4
never seems to occur . and hence we obtain a tree of factorizations which prov e
that there is no odd perfect number less than B .
There are some other theoretical results about odd perfect numbers . For
example. Hagis and Chein have independently showed that an odd perfec t
number is divisible by at least 8 distinct prunes and Muskat that it is divisibl e
by a. prune power > 10 1 '. Hagis and McDaniel show that the largest prun e
divisor is greater than 1001100, and Pomerance that the next largest is greate r
than 138. Condict and Hagis have improved these bounds to 3 . 105 and 10 3 .
respectively. Pomerance has also shown that an odd perfect number with at
most k factors is less than
(4k) ("12']
but Heath-Brown [101] has improved this by showing that if n is an od d
number with a(n)
an . then n < (4d)4k . where d is the denominator of a .
and k is the number of distinct prime factors of n . In particular . if it is an
odd perfect number with k distinct prime factors . then n < 4^ k .
2.7 Bibliographic Notes and Further Readin g
Compared To elementary number theory. Computational/algorithmic num-
ber theory is a relatively new subject in number theory . In this chapter . we
have introduced some fundamental issues of the computational/algorithmi c
aspects of number theory, more specifically. we have introduced various algo-
rithms for primality testing, integer factorization, and discrete logarithms
(including elliptic curve discrete logarithms), which will be useful in th e
next chapter on applications of number theory in computing and informatio n
technology. such as cryptography and network security . However. it should
be noted that computational/algorithmic number theory covers a very wide
range of topics. not just those of primality testing. integer factorization, an d
discrete logarithms .
Although computational/algorithmic number theory is new . it is very ac-
tive: many new textbooks and monographs on the subject have already been
published. For those who desire a more detailed exposition, we recommend
the following references for further reading : Bach and Shallit [16] . Brassard
[33] . Cohen [50] . Giblin [83] . Garrett [81], Knuth [123] . Koblitz [128] and
[129] . Krana [134] . Krishna. Krishna. Lin and Sun [133] . Riesel [201 and
Schroeder [222] . The book by Ribenboim [200] contains new records in num-
ber theory. including computational/algorithmic number theory. The paper
by Silverman [234] provides a good survey as well as a nice introductio n
to the field. As computational/algorithmic number theory is an interdisci-
plinary subject of' computer science (particularly algorithms and complexity)
and number theory, readers are suggested to consult. for example, Bach [14] ,
Garet' and Johnson [79]. Johnson [114] . Lewis and Papadimitriou [142], Lin z
[143] . Motwani and Raghavan [170] . Rozenberg and Salomaa, [214], and Yan
[261] for more information on computability and complexity .
The proceedings of the international symposia on Algorithmic Numbe r
Theory (ANT), say, for example, the ANTS-III edited by Buhler [43]), ofte n
contain new developments in the subject : readers are strongly recommended
to consult this series of' proceedings regularly in order to update their knowl-
edge of the subject .
Since Peter Shor [226] published his paper in 1994 on quantum factorin g
and discrete logarithms_ quantum computing has become an increasingly im-
portant subject of research : there are at least 10 papers published every day i n
the world on this subject . Three classical references to quantum computation
are Benioff [23], Deutsch [63] and Feynnan [74] . hrterested readers may also
wish to consult Feymnan's lectures on computation [75] and Williams and
Clearwater's book [258] for more information . Serious readers in quantu m
computing are referred to a special section of SI.4_M Journal on Computing
in 26 . (5)1997 . which contains the following papers :
[1] L. Vazirani .
"Introduction to Special Section on Quantum Computa-
tion" . p 1409-1410 .
[2]E. Bernstein and U . A'azirani . "Quantum Complexity Theory , pp 141 1
1473 .
[3]D . R . Simon. "On the Power of Quantum Computation" . pp 1474-1483 .
[4]P. Shor. "Polynomial-Time Algorithms for Prime Factorization and Dis-
crete Logarithms on a Quantum Computer " . pp 1484 1.509 .
[5]C. H. Bennett et al ., "Strengths and Weakness of Quantum Computi n
pp 1510 1523 .

302
2 . Computational/Algorithmic Number Theor y
[6] L . M . Adleman et al .. "Quantum Computability", pp 1524 1540 .
[7] A. Barenco et al . . "Stabilization of Quantum Computations by Sym-
metrization " . pp 1541-1337 .
We strongly recommend the interested reader to consult. Shor's paper listed
above for a full account of the quantum algorithms for integer factorizatio n
and discrete logarithms . However. beginners in quantum computing may fin d
the papers by Bennett [24] . Jozsa [115] . Rieffel and Polak [202] . and Scarani
[217] useful .
3. Applied Number Theory i n
Computing/Cryptography
To the layman, a lot of math (like primality testing and factoring larg e
numbers) may seem a frivolous waste of time. However, this research of-
ten pays off unexpectedly years later . Factoring and primality testing hav e
become important because of the need to make electronic communications
secure . . .- So, what used to be an esoteric playground for mathematician s
has become applicable research .
DAVID GIBES AND FRED B . SCHNEIDER.
A Logical Approach to Discrete Math [93 ]
The aim of this chapter is to introduce some novel applications of elementar y
and particularly algorithmic number theory to the design of computer (bot h
hardware and software) systems, coding and cryptography, and informatio n
security, especially network/communication security .
3.1 Why Applied Number Theory ?
The eminent American number theorist Leonard Dickson' once said :
Thank God that number theory is unsullied by any application .
Leonard Eugene Dickson (1874-1954) . one of the key figures of
20th century mathematics, particularly number theory, was born
in Independence. Iowa, a descendant of one William Dickson wh o
had emigrated from Londonderry . Northern Ireland to London-
derry. New Hampshire in the 18th century. Dickson obtained his
PhD in 1896 from the University of Chicago, the first PhD awarded
in Mathematics by the institution. Following periods at the Uni-
versities of Leipzig, Paris. California and Texas, he returned to
Chicago in 1900, becoming a full professor in 1910. One of the most productive
of all mathematicians, Dickson wrote over 250 papers and 18 books, including the
three volume 1600 page History of the Theory of Numbers [65] . It is amusing to note
that he stopped to write papers and books in mathematics abruptly and completely
on reaching the age of 65 in 1939 and devoted himself to his recreations, includ -
ing bridge. tennis and billiards . (Photo by courtesy of the American Mathematical
Society.)

31)4
3 . Applied Number Theory in Computing/Crvptography
3 .2 Computer Systems Design
30 5
The most famous English mathematician G . H . Hardy- (1877—1947) also in
his Apology ([98] . page 120) expressed that
If the theory of numbers could be employed for any practical an d
obviously honourable purpose, if it could be turned directly to the
furtherance of human happiness or relief of human suffering . as physi-
ology and even chemistry can . then surely neither Gauss or any other
mathematician would have been so foolish as to decry or regret suc h
applications .
He then further proudly stated on page 140 that
Real mathematics has no effects on war . No one has yet discovered
any warlike purpose to be served by the theory of numbers .
The above famous quotations made by the two greatest mathematicians o f
the 20th century may be true before 1950, but certainly are not true a t
the present time. since, e.g .. number theory now can help the generals to
plan their battles in a completely secret way. Remarkably enough . the great
Russian mathematician Nikolay Lobachevsky (1792 1856) predicated nearl y
200 years ago that
There is no branch of mathematics, however abstract, which may not
some day be applied to phenomena of the real world .
In fact, any branch of pure mathematics will eventually find real world ap-
plications. Number theory, for example, was considered the purest branch o f
pure mathematics, with no direct applications to the real world . The advent
of digital computers and digital communications and particularly public -
key cryptography revealed that number theory could provide unexpecte d
answers to real-world problems. As showed in Schroeder [222] and Wald-
schnnidt, _Moussa.. Luck and Itzykson [250] . and Guterl [96], mnnber theor y
has already been successfully _applied to such diverse areas as physics, biology .
chemistry. computing. engineering ; coding and cryptography. random num-
ber generation. acoustics. communications . graphic design, and even musi c
and business. It. is also interesting to note that the eminent mathematicia n
Shiing-Shen Ghent (1911 ), the 1980 Wolf Prize Winner . even considers
number theory as a branch of applied mathematics [48 ] because of its strong
applicability in other fields . Today. number theory is used widely in com-
puting and information theory/technology, due in part to the invention of
the high-speed computers based on e.g . . the residue number systems and the
cryptographic schemes based on e .g . . large prime numbers . For example, th e
feasibility of several modern cryptographic schemes rests on our ability t o
find large primes easily . while their security rests on our inability to facto r
the product of large primes .
Number theory is generally considered to be laid in the discrete . finite
side of mathematics . along with algebra and combinatorics, and is intimately
connected to computing science and technology, since computers are basically
finite machines; they have finite storage and can only deal with numbers o f
some finite length. Because of these features in computing, number theor y
is particularly useful and applicable to computing. For example, congruenc e
theory has been used for devising systematic methods for storing computer
files, generating random numbers, designing highly secure and reliable en-
cryption schemes and even developing high-speed residue computers . Since
most computer scientists are more interested in the applications of numbe r
theory in computing. rather than the number theory itself, in this chapter ,
we shall apply the number-theoretic results and algorithms from the previou s
two chapters to the design of fast computer architectures_ and more secure .
more reliable computer/network systems .
3 .2 Computer Systems Desig n
virtually every theorem in elementary number theory arises in a nat-
ural, motivated way in connection with the problem of making computer s
do high-speed numerical calculations .
DONALD E . KNUT H
Computer Science and its Relation to Mathematics
[121]
3 .2 .1 Representing Numbers in Residue Number Systems
The way we do arithmetic on numbers is intimately related to the way we
represent the numbers . There are essentially two different types of method s
to represent numbers : nonpositional and positional. The Roman numeral s
i. iii, iv. v. vii. viii. ix, x, xi, xii. xiii,
. are a classical example of a
nonpositional number system ; whereas the familiar decimal or binary number
system are good examples of a positional number system. The positional
number system using base b (or radix b) is defined by the rule
( . . . a 3 a2 ar aoa—ra—2a—3 . . . )e =
+ a3 b' + a>b- +
1) 1 -i- ro b
+a_rb —r a_2b_
2 a_3 b —3 +
.
. .
(3.1)
It is clear that when b = 10 . it is the decimal system . whereas when b = 2 we
have the binary system. This type of positional number system is said to have
a fixed-base or fixed-radix . A positional number system which is not fixed-bas e
is said to be mixed-base . The number systems. residue number systems, we
shall study in this section are a type of mixed-base system .
Let us first recall the Fundamental Theorem of Arithmetic : any positive
integer a. E N>r can be uniquely written as
n = p~'pza . . . pke = nr n2 -
. nr
(3.2)

306
3 . Applied Number Theory in Computing/Cryptography
3.2 Computer Systems Design
307
where p i . p2 . • - - ,Pk are distinct primes,
a2,
a k are natural numbers.
n, = p _ . i = 1, 2, - , k . and gcd(n 1 . n ) ) = 1 for i j. The prime decom-
position of n call be used to represent any number in Z/nZ in terms of the
numbers in Z/n,Z, for i = 1 .2, . • - , k .
Definition 3 .2.1 . Let x be any number in Z/nZ and
x = as (mod-
x E 02 (mod
ak (mod nk
}
(3 .3)
then the k-tuple
(a 1i (1 2,
.
,ak) = (x mod n 1 , x mod n2 .
. . , x mod nk )
(3 .4)
is called the residue (congruence . or modular) representation of x. For sim-
plicity, we often write the residue representation of x as follows :
x
(x mod n 1 , x mod n2 , ' ' , x mod n k)
(3.5)
Theorem 3 .2 .1 . Let m 1 > 0,0)2 > 0 
nn 1. > 0. and gcd(7n, . 7n.~) = 1
with 0 < i < j < k . Then two integers .r and ar' have the same residu e
representation if and only if
x . x' (mod 31)
(3.7)
where 1I = m l m2 . . . 1111 .
So if we restrict 0 < x < lI = in 1 1n2 • ' - Ink . then different integers x will
have different residue representation moduli U 1 .7n, . - - - . in k .
Theorem 3.2.2. Let f : Z/nZ -* (Z/nZ)* be such that for any x E 7L/n7L ,
we have
f(x) =
(al, (2 ,
= (x mod n.1, x mod n 2 ,
, x IIInd k)
then f is a bijection (one-to-one and onto) .
Remark 3.2.1. Theorem 3.2.1 is just another form of the Chinese R,em a
der Theorem .
Example 3.2.3. Let in = 30, so that m 1 = 2, 7n2 = 3, 7n3 = 5 with
Example 3 .2 .1 . Let n 1 = 3, n 2 = 5, n3 = 7, then the residue representatio n
of the integer 103 will be
(Z/30Z)* = Z/2Z x Z/3Z x 7G/57L .
Then the residue representations for integers in Z/30Z will be :
103 E 1 (mod 3)
103 - 3 (mod 5)
0
(0,0,0)
1
(1,1,1)
103 - 5 (mod 7)
2
(0,2,2)
3
(1,0,3)
4
(0,1, 4)
5
(1 .2 .0)
That is
6
(0,0,1)
7 <--> (1,1,2)
103
(1,3,5) .
8(0,2,3)
9
(1, 0, 4)
10
. (0,1,0)
11 . (1,2,1)
Note that the residue representation of an
integer x
wit moduli
12= . (0,0,2)
13 — (1,1, 3 )
n 1 , n2 , • • • , n k is unique . However, the inverse is not true .
14(0.2,4)
15 .
(1, 0.0)
Example 3.2.2. Let again n l = 3. n2 = 5, n3 = 7. then all the numbers in
16
(0,1, 1)
17 f--> (1.2,2 )
18(0 .0.3)
19
(1,1, 4)
the form
20---> (0,2,,0)
21
(1,0,1 )
105t + 103 .
for t E N
22
(0,1, 2)
23(1.2 .3)
have the same residue representation (1, 3, 5) . That is,
24 <—> (0,0,4)
25 <=> (1,1,0)
26
(0, 2,1)
27
(1.0 .2)
105t+103
(1.3,5) .
28
(0,1, 3)
29 4—> (1, 2,4) .
Definition 3.2.2. Let (Z/nZ)* be the "direct-product" decomposition o f
Z/nZ. That is .
(Z/nZ)* = Z/n i Z x 76/n9Z x . . . x 7L/nkZ
(3.6)
where n, p('` for i = 1,2 
k is the prime decomposition of n .
Once the residue representatio n
(a1,a2,-
.ak) = (x mod ni . x mod n2 ,
mod n k)
of an integer x is given, then we can uniquely solve x by using the Chines e
Remainder Theorem (see the following example) .

308
3 . Applied Number Theory in Computing/Cryptogr :
3.2 Computer Systems Design
309
Example 3.2.4. Suppose we have the residue representations of x as follows :
= (:r mod 3, .r mod 5, x mod 7) = (1, 3 .5) .
Then we have
1 (mod 3) ,
3 (mod .5) .
5 (mod 7) .
By using the Chinese Remainder Theorem, we get :
= 103 .
On most computers the word size is a large power of 2 . with 232 a common
value. So to use residue arithmetic and the Chinese Remainder Theorem t o
do arithmetic, we need the moduli less than, say 232 , pairwise relatively prime
and multiplying together to give a large integer .
3.2.2 Fast Computations in Residue Number System s
In this subsection, we shall discuss fast arithmetic operations in residue num -
ber systems. More specifically, we shall discuss the fast arithmetic operation s
of addition +,, . subtraction –, a and multiplication .,, in (Z/nZ)* in terms of
the corresponding operations +,a,
in Z /n,Z, for i = 1, 2, - , k .
Definition 3.2.3. Let x = (ai, a2 .
. ak) and y = (br, b 2,
, bk) in Z/nZ .
Then
x + y = (al, a2, . . . ,ak) +„
(by .52i . . .
, bk)
= f(x)
+„ f(y)
= ((x mod nr) +„,, (g mod n j ).
(.r mod n 2 ) +„z (y mod n2 ) ,
mod n k ) +,a a
(y mod
x — p
=
(al, a2 , .
, ak) —n
(41. ; b2i . . .
b k )
= f(x)
— n f(y)
= ((x mod n.r)
(y mod nr) ,
(x Inod n2)
—,a„ (y mod n2) ,
O.! mod
k
(y mod ilk )).
y
("I :-2 7 . ' 1 , ak) •,
(bl,b_2 .
,bk )
= f(r)
f(y )
= ((.r mod n I ) ',,,
(y mod nl ) ,
(.r mod n. 2 )
(y mod n 2 ) ,
(x mod n k )
'„ .
(y mod ilk)) .
Definition 3 .2 .4. Given groups (g.*) and ('H,*), a function f
: g
7l is
called an isomorphisrn if the following conditions hold :
(1) f is one-to-one and onto .
(2) f(a*b)=f(a)*f(b) .foralla,bEG.
We say that (Q ._) is isomorphic to (7-1,*) and write (g,*) = (1,*) .
Example 3.2.5 . Show that the function f
:
(R, +) -i (R+ , .) defined by
f (x) = 2' is an isomorphism. First, we have :
(1) f is one-to-one, since f (x) = f (y) implies 2 r = 2r . which implies x = y .
Also f is onto, since for each r E Ig+ there is t E R such that 2' = t ,
namely s = loge t .
(2) Let a . b E R, then f (a + b) = 2"+b = 2" . 2 e = Pa)
. f (b) .
Therefore f is an isomorphism. That is
(R,+)
(RT , .)y
f(x) = 2''' .
Theorem 3 .2 .3 . Let f : Z/nZ –i (Z/nZ)* defined by
f (x) = (a: mod
be one-to-one and onto. Then
, x mod n 2
, x mod n k, )
(1) (Z/nZ. +.,)
((z /nZ) *. +,
) .
(2)
(Z/nZ. –„)
(3) (Z/nZ,
.,.,)
((Z /nZ) *,
((Z/nZ)*,
,)•
The above theorem tells us that the arithmetic operations +,a, –„ and
in Z/nZ can be done in (Z/n.Z)` by means of the corresponding operation s
+,,, . —,a, and in (Z/n,Z) * , for i = 1, 2 .
. . k . This is exactly what we
need. In what follows, we shall give two examples of adding and multiplyin g
two large integers in residue number systems . Later in the next subsection
we shall also discuss its hardware implementation .

310
3 . Applied Number Theory in Computing/Cryptography
3.2 Computer Systems Design
311
Example 3.2.6. Compute z = x + y = 123684 + 413456 on a computer of
word size 100. Firstly we have
33 (mod 99) . y = 32 (mod 99) .
8 (mod 98) . y = 92 (mod 98) .
x - 9 (mod 97) . y - 42 (mod 97) .
x - 89 (mod 95) . y =16 (mod 95) .
so that
z = x + y 65 (mod 99) ,
= x + y - 2 (mod 98) ,
z = x + y - 51 (mod 97) ,
z = x + y - 10 (mod 95) .
Now, we use the Chinese Remainder Theorem to find
.r+ymod(99x98x97x95) .
Note that, the solution to (3.9) is
3I, 11;=; (trod in),
:r + y - 2 zi1lillz (mod m)
i= 1
65x903070x37+2x912285x38+51x921690x24
+10 x 941094 x 4 (mod 89403930 )
3397886480 (mod 89403930 )
537140 (mod 89403930)
Since 0 < x + y = 537140 < 89403930 . we conclude that x + y = 537140 is
the correct answer .
Example 3 .2 .7 . Suppose now we want to multiply x = 123684 and y =
413456 on a computer of word size 100 . We then have
= 33 (mod 99) ,
x - 8 (mod 98) ,
x - 9 (mod 97) ,
xE89(mod 95) .
x E 63 (mod 89) .
xE 14 (mod 83),
y - 32 (mod 99) ,
y - 92 (mod 98) .
y = 42 (mod 97) .
y = 16 (mod 95) .
y - 51 (mod 89) .
y 33 (mod 83) .
i=1
so that
where
x • y = 66 (mod 99) ,
nt. = to.
nb277137n4,
x y-50(mod 98) ,
Ali = nn/m,
x•y=87(mod 97) ,
II,li; - 1 (mod m1,
x y - 94 (mod 95) ,
for
= 1.2 .3,4 . Now we have
x y- 9(mod 89),
: y - 47 (mod 83) .
3I = 99 x 98 x 97 x 95 = 89403930 .
and
Now using the Chinese Remainder Theorem to solve the above system of
congruences, we get.
171 = AI/99 = 903070 .
31> = 11/98 = 912285 .
r'y=51137891904 .
313 = 31/97 = 921690 .
Since
31 i = 11/95 = 941094 .
We need to find the inverse 11'. for i = 1 .2.3 .4 . To do this. we solve the
0 < a: • y = 51137891904 < 803651926770 = it n2 n3n.1n,ni
following four congruences
we conclude that :r y = 51137891904 is the correct answer .
903070111 - 9111 - 1 (mod 99) .
In what follows, we shall present a general algorithm for residue arithmetic
912285 .11.; - 331._ = 1 (mod 98) .
in (Z/nZ ) =. where n = n i ne . . . n k,, by means of the corresponding operations
92169011 ; = 93.11.3 = 1 (mod 97) .
in (Z/n,Z) = , for i = 1 .2,- - • . k . Readers note that there are three different
94109411 - 2411 = 1 (mod 95) .
types of arithmetic :
We find that
31i - 37 (mod 99) .
(1) Integer arithmetic : arithmetic in Z .
11_ = 38 (mod 98),
(2) Modular arithmetic : special integer arithmetic in Z/nZ .
11 = 24 (mod 97),
(3) Residue arithmetic: special modular arithmetic in (Z/u. )* .
_11, = 4 (mod 95) .
In this book, we are actually more interested in the last two types of arith-
Hence we get:
metic .

312
3. Applied Number Theory in Computing/Cryptography
3.2 Computer Systems Design
313
Algorithm 3.2.1 (Residue arithmetic) . This algorithm performs th e
residue arithmetic in (Z/nZ)*. where n. = n i 2
ni, :
[1] Convert integers to their residue representation : Represent integers, for ex-
ample, r and y as elements of the group (Z/nZ)*, where
(Z/nZ)` = Z/niZ x Z/n 2Z x
.
. . x Z/nkZ
by taking the congruence class of .r or y modulo each ni ; for example, th e
following is the residue representation of x and y modulo each ni :
Consequently, addition, subtraction and multiplication can be performed i n
residue computers" in less time than that needed in equivalent binary com-
puters .
The construction of residue computers is much easier than that of binar y
computers ; for example . to construct fast adders of a residue computer fo r
(Z/nZ)* = Z/n 1 Z x Z/n2Z x
. . . x Z/nkZ
it is sufficient to just construct some smaller adders for each Z/niZ, (i
1 .2	
k) (see Figure 3.1) . More generally, we can construct residue com-
(r
xi (mod
r
,
(mod n2),
. r
xi, (mod Ilk)).
(y = yi (mod n 1) . y = y2 (mod n2), -
. y = yk (mod il k)) .
[2] Perform the residue arithmetic for each Z/n,Z : For example, if * denote s
one of the three binary operations +, — and •, then we need to perform th e
following operations in Z/n 5Z :
(xi * yt (mod ni). -r2 * y2 (mod n2) .
. .
: /' k. * yk (mod ir k )) .
[3] Convert the residue representations back to integers : Use the Chinese Re-
mainder Theorem to convert the computation results for each Z/nZ into
their integer form in Z/nZ
r*y =AIi AI,z, (mod AI) ,
i=1.
where
AI = ni n, . . .nk ,
Ali = 17/ni.
AI'
ii
i (mod on .
zi sr=
* yi (mod ni) .
fori = 1, 2,
.k .
Fast adder
for Z/niZ
Fast adder
for Z//n 2Z
CRT r+ y
in Z/nZ
Fast adder
for Z/rakZ
r k.
fir
The above algorithm can be implemented entirely in special compute r
hardware, which is the subject matter of our next subsection .
3 .2 .3 Residue Computers
The conventional "binary computers" have a serious problem that restricts
the speed of performing arithmetic operations . caused by. for example. the
cam- propagation and time delay . Fortunately. the residue number syste m
(RNS) is not a fixed base number system, and all arithmetic operations (ex-
cept division) in RNS are inherently ca ry-free: that is, each digit in the com-
puted result is a function of only the corresponding digits of the operands .
Figure 3.1 . Fast adders for residue arithmeti c
puters performing fast additions, subtractions and multiplications as in Fig-
ure 3.2. Since n, is substantially less than n, computations in each Z/niZ will
certainly be much easier than those in Z/nZ. More importantly . additions ,
subtractions and multiplications in each Z/nzZ are carry-free. so residue com-
puters will be substantially faster than conventional binary computers inher-
ently with carry propagation. The idea of decomposing a large computation

314
3 . Applied Number Theory in Computing/Cryptography
3.2 Computer Systems Design
315
Parallel and fast computations in different arithmetic units
3.2.4 Complementary Arithmetic
arithmetic operations
for Z/n1 Z
xi + y i mod ni
x2 — Ill mod in
xi
. in mod nl
rithmetic operations
for 7G/n2Z
X2 + y2 mod n 2
x2
y2 mod 11 2
x 2
y2 mod n2
Final
computation
using CRT
for Z/n.Z
yk = If mod ng
2 :k y, . mod nk
(Residues for y )
Integers
Residues
Computations in RNS
Residues
Integers
Figure 3.2. A model of residue computer s
in Z/oZ into several smaller computations in the 7G/n,Z is exactly the idea
of "divide-and-conquer" used in algorithm design . Of course . the central idea
behind residue arithmetic and residue computers is the Chinese Remainder
Theorem which enables us to combine separate results in each iZ/n,Z to a fi-
nal result in Z/nZ . So, if Euclid's algorithm is regarded as the first nontrivial
algorithm, then the Chinese Remainder Theorem should he regarded as th e
first nontrivial divide-and-conquer algorithm .
Residue computers are a special type of high-speed computer_ that ha s
found many important applications in several central areas of computer sci-
ence and electrical engineering, particularly in image and digital signal pro-
cessing (Krishna, Krishna, Lin. and Sun [133]) .
The main memory of a computer is divided into a number of units of equal
size. called words. Each word consists of n = 2 11' bits, where n is typically 16 .
32, 64 or 128. Provided that a positive integer is not too large . it can then
be represented simply by its binary form in a single word of the compute r
memory. For example, a 16 hit word could hold the positive values from 0
to 61503 . The problem is then how to represent negative integers . There are
a number of was to do this: the most obvious way is the signed-magnitude
representation .
Definition 3.2.5. In the signed-magnitude representation . the first bit of
the in-bit word is used to denote the sign (0 for + and 1 for –) . called the
sign bit, and the remaining m – 1 bits are used to represent the size, or
magnitude of the number in binary form .
Example 3.2.8. Let 1n = 8. Then to represent the integers +117 and -12 7
in signed-magnitude representation, we have :
+117
—>
0
1110101
sign bit number magnitude
-127
1
111111 1
sign bit number magnitude .
In a computer with 16-hit words, using the signed-magnitude representation .
the largest integer that can be stored i s
0 111111111111111= 215 -1 = 32767
is ones
and the smallest
1 111111111111111= 1 -2r''=–32767 .
15 ones
Example 3.2.9. Let m = 8. To compute 117 + (–127) and 117 + 127 in the
signed-magnitude representation, we have :
01110101
+111010 1
+
11111111
-111111 1
0001010 
> 10001010 > -1 0
Xi = x mod nn
= X mod nk
(Residues for .r)
=xmod02
ithrnetic operation s
for 7G/na;7G
x i; + yx mod n 5
X
.. – y, mod nA
X+v mod n
x — ymod n
x ymod n
(n = njn2 . . . 17.

316
3 . Applied Number Theo ip in Computing/Cryptography
3.2 Computer Systems Design
317
01110101
+1110101
+
01111111
+111111 1
+1110100 
> 01110100 
> 116 .
Note that in the above computation the most significant bit is the sign
bit that does not take part in the computation itself: we need first to convert
the sign bit to either + or -, then perform the computation and convert th e
sign of the result into a sign bit . Note also that 117+127 = 116 # 244 ; this is
because the adder in a computer operates modulo n . Computers cannot dea l
with all integers but just a finite set of them, even using the multiple-precisio n
representation. When two binary strings a and b are added together, the adder
treats n = 2' 1 as if it were 0! The computer sum a b is not necessaril y
a+b, but a+bmodulo
Ifa+b>2'u-r . then a
b=a+b -
Since 2' 1 E 0 (mod 2 ,n-1 ), we have
a+b
aSs b (mod 2"z-1 )
(3.10)
Again in the above example . we have
117 + 127 = 224 = 116 (mod 2 8-1 ) .
While the signed-magnitude representation was used in several early com -
puters, modern computers usually use either the one's or two's complemen t
representation, rather than the signed-magnitude representation .
Definition 3.2.6. Let .r be a binary number . then the complement of r .
denoted by .r,', is obtained by replacing each 0 in .e by 1 and each 1 in x by 0 .
In the one's complement representation . a positive integer is represented as
in the signed-magnitude representation, whereas a negative integer is repre-
sented by the complement of the corresponding binary number . In the two's
complement representation, a. positive integer is represented as in the on e 's
representation . but a negative integer is represented by adding one to it s
one 's complement representation.
The range of a number (positive or negative) with
rn bits in one's con-
plement representation is given b y
1 - 2 „' -1 .1 - 2''-' + 1 
-1 . -0.0 .1 
2' 1 - 1 .
(3.11)
The range of a number with m bits in two's complement representation i s
given by
and the range of a number in two's complement is
-25-1
1 - 25-1 + 1 .
•'
.
-2.
-1 .
0 .
1 .
. .
2'-' - 1
-16.
-15 .
-2.
-1 .
0 .
1 .
.
15
One interesting observation about the twos complement representation i s
that it has only one representation for zero. whilst there are two zeros in . ei-
ther the one's complement representation . or the signed-magnitude represen-
tation . For example. let rn = 5. then in the one's complement representation ,
00000 represents 0 but 11111 represents -0, whilst in the signed-magnitude
representation ; 00000 represents 0 but 10000 represents -0 . Table 3.1 gives a
comparison of different representations of numbers . By using either the one' s
complement or two's complement, rather than the signed-magnitude repre-
sentation. the operation of subtraction is considerably simplified ; this is the
reason that modern computers use, either the one's complement, or two' s
complement. not the signed-magnitude representation .
Example 3 .2 .10 . Let a = 117 and b = -127, compute a + b in the one 's
complement representation. First note that in the signed-magnitude repre-
sentation.
a = 01110101
b = 1111111 1
thus in the one's complement representation .
a' = 01110101
b' = 00000000
therefore. a + b becomes
01110101
+ 00000000
01110101 
> 10001010
-10 .
3.2.5 Hash Functions
Hashing is a very important technique in algorithm and database design . as
well as in cryptography . In this subsection, we shall introduce an interestin g
application of number theory in hash function design .
Definition 3 .2 .7. Let k be the key of the file to be stored, and n be a
-2"'
-2,,,-1 + 1 . - . -2 . -1 . 0 . 1. .
.
- 1 .
(3.12)
positive integer. We define the hash function h(k) by
For example. let rn = 5 . then the range of a number in one 's complement is
b(k) - k
(mod n)
(3.13)
1-2' - '
1-2'-1 +1 .
-1 .
-0 .
0 .
1 .
2"-1 -1
where 0 < h(k) < n, so that b(k) is the least positive residue of k modulo n .
1
1
1
1
)
1
1
There are two fundamental problems here in the design a good hash func -
-15 .
-14,
-1 .
-0 .
0 .
1 .
,
15
tion :

318
3. Applied Number Theory in Computing/Cryptography
3.2 Computer Systems Design
319
Table 3.1. Comparison of different representations of numbers
Pure
Binary
Binary
Signed-
Magnitude
1's
Complement
2's
Complement
0
00000
0
0
0
1
00001
1
1
1
2
00010
2
2
2
3
00011
3
3
3
4
00100
4
4
4
5
00101
5
5
5
6
00110
6
6
6
7
00111
7
7
7
8
01000
8
8
8
9
01001
9
9
9
10
01010
10
10
10
11
01011
11
11
11
12
01100
12
12
12
13
01101
13
13
13
14
01110
14
14
14
15
01111
15
15
15
16
10000
-0
-15
-1 6
17
10001
-1
-14
- -15
18
10010
-2
-13
-1 4
19
10011
-3
-12
-1 3
20
10100
-4
-11
-12
21
10101
-5
-10
-1 1
22
10110
-6
-9
-1 0
23
'
10111
-7
-8
-9
24
11000
-8
-7
- 8
25
11001
-9
-6
- 7
26
11010
-10
-5
- 6
27
11011
-11
-4
-5
28
11100
-12
-3
-4
29
11101
-13
-2
-3
30
11110
-14
-1
-2
31
11111
-15
-0
-1
(1) How to intelligently choose the value of n ..
(2) How to avoid collisions .
The first problem can be solved (at least partially) by selecting n a prime
close to the size of the memory. For example, if the memory size is 5000, we
could pick n to be 4969, a prime close to 5000 .
To solve the second problem, we could use the so-called double hash tech-
nique. The first hash function is the same as (3 .13). defined previously, whilst
the second hash function is taken as follows :
q(k) k + 1 (mod n – 2)
(3 .14)
where 0 < g(k) < n – 1, is such that gcd(h(k) . n) = 1 . The probing sequence
is defined as follows :
h1 (k)
h(k) + j - g(k) (mod n)
(3 .15)
where 0 < h,(k) < n . Since gcd(h(k) .n) = 1 . as j runs through the integer s
1.2 .3. -
.n – 1 . all memory locations will be traced out . Since n is prime .
the ideal selection for the moduli n – 2 would be also prime . that is. n and
n – 2 are twin primes.
Example 3.2.11 . Suppose we wish to assign memory locations to files wit h
the following index numbers :
h(k t ) = 197654291 mod .5881 = 5643
h(k2) = 087365203 mod 5881 = 2948
h(k3) = 528972276 mod .5881 = 5643
h(k4) = 197354864 mod 5881 = 266
h(k5 ) = 873032731 mod 5881 = 4162
h(ko) = 732975102 mod .5881 = 2548
h(k7) = 216510386 mod 5881=1371
h(ks) = 921001.536 mod 5881 = 1650
h(ko) = 933185952 mod 5881 = 634
h(kio) = 109231931 mod 5881 = 416 2
h(kr t ) = 132489973 mod 5881 = 280 5
Since
h(kt ) - h(k3 ) - 5643 (mod 5881) .
h(k5)
h(k t o)
4162 (mod 5881) .
we then need to find new locations hr(k3 ) and h. 1 (kt o) for the 3rd and the
10th record by the formul a
ht (k) - h(k) + 1 . g(k) (mod n), with
g(k) k + 1 (mod n – 2 )
as follows:
g(k3) = 1 + k3 mod .5879 = 1 + 528972276 mod .5879 = 3373 .
9(ki o) = 1 + kw mod .5879 = 1 + 109231931 mod 5879 = 112 .
h i (k3)
= h(k3 ) + 1 . g(k3) mod .5881
= 5289 7 2276 + 1 . 3373 mod 5881 = 3222 .
hi (kio) = h (k lo) + 1 . g(ki o) mod 5881
= 109231931 + 1 . 112 mod 5881 = 4239 .
kt =
k j =
k5 =
k7 =
kq =
ktt = 132489973
We first choose n = .5881 . compute h(k,) = ka mod n, and get :
197654291
k2 = 087365203
528972276
= 197354864
873032731
ko = 732975102
216510386
ks = 921001536
9331859 .52
km = 109231931

320
3 . Applied Number Theory in Computing/Cryptography
3 .2 Computer Systems Design
32 1
So finally we ha
Index Number
h(k)
h i (k)
197654291
5643
087365203
2948
528972276
5643
3222
197354864
266
873032731
4162
732975102
2548
216510386
1371
921001536
1650
933185952
634
109231931
4162
4239
132489973
2805
Since we can repeatedly compute h(k),hi(k) .h2(k), .'', a suitable loca-
tion for a. record will be eventually found . However, by using the Chinese
Remainder Theorem, it is possible to construct a . collision free hash function .
Definition 3 .2 .8 . Let IV=Iwo, wi,• . .,w,,,_i}andI={0 .1 
(a—1) }
be sets with n > in . The hash function h :
TV -3 I is called a perfect. hash
function (PHF), if for all t,y E IF' and .r
y . h(x)
h(y) . In particular ,
if in = n . h is called a minimal perfect hash function (MPHF) . A minimal
perfect hash function is also called a minimal collision-free hash function .
The MPHF technique is better than any existing information retrieval
method, but the problem is that it is computationally intractable. Recent
research shows, however . that we can use the Chinese Remainder Theore m
to efficiently construct a MPHF . We describe in the following one such con-
struction, due to Jaeschke [113] .
Theorem 3.2 .4. For a. given finite set IV (without loss of generality . we
assume that IV is a finite set of positive integers) . there exist three constant s
C . D and E . such that the function h defined by
are pairwise relatively prime . so by the CRT there exists an integer C such
that
C
ao (mod (n — 1)(Dwo + E))
C - a l (mod (n — 1)(Dwi + E))
(3 .17)
C = a„_ 1 (mod (n — 1)(Dw„_i + E)).
Finally. we introduce another type of hash function, called one-way has h
function . also called message digest or fingerprint .
Definition 3 .2 .9. A one-way hash function maps a string (message) in of
arbitrary length to an integer d = H(m) with a fixed number of bits, calle d
digest of in . that satisfies the following conditions :
[1] Given In . d is easy to compute .
[2] Given d.. rn is computationally- infeasible to find .
A one-way hash function is said to be collision resistant if it is computa-
tionally infeasible to find two strings rni and n1 2 that have the same diges t
d .
Several one-way hash functions believed to be collision resistant ; the ones
used most in practice are MD5, which produces a 128-bit digest, and SHA-1 ,
which produces a 160-bit digest (MD stands for message digest and SH A
stands for secure hash algorithm) . The most important application of one -
way collision resistant hash functions is to speed up the construction of digital
signatures (we shall discuss digital signatures later), since we can sign th e
digest of' the message. d = H(m), rather than the message itself, ni . That is,
S = D(H(rn)),
(3.18)
where D is the digital signature algorithm .
3 .2 .6 Error Detection and Correction Methods
h(w)[C/(Dw+ E)] (mode
1) .
~TV
z—7
(3 .16 )
is a minimal perfect hash function .
The function is clearly a bijection from H ' onto the set I. The proof of
this theorem can be done by using a generalization of the Chinese Remainder
Theorem (CRT) for non-pairwise (i .e .. not necessarily pairwise) relatively
prime moduli. First note that for a given set TI' = , w„_i } of
positive integers there exist two integer constants D and E such that
Dino + E, Die, +
+ E
In this subsection. we shall discuss an interesting application of the theory o f
congruences in error detections and corrections .
It is evident that manipulating and transmitting bit strings can introduc e
errors. A simple error detection method . called parity check works in the
following way (suppose the bit string to be sent is xi .r;2 ' ' ' x„) :
[1] (Precomputation) Append to the bit string a parity check bit .r„ Li
s„+i = a i + Z', +
+ a„ (mod 2) .
(3.19)
so that

322
3. Applied Number Theory in Computing/Cryptography
3.2 Computer Systems Design
323
0 . if there is an even number of
IT+i
1 in x ix2 . . . x „
(3 .20)
otherwise .
The appended string x i x 2
. . :c9 x,,+i should satisfy the following congruence
xr+x2+
++x„+1 =0 (mod 2) .
(3.21)
[2] (Error Detection) Suppose now we send the string x = x i X2 • . .z:,,x„+ i an d
the string y = yr y2
is received . If x = y, then there are no errors ,
but if x
y, there will be errors. We check whether or not
yi + y2 +
+ g„ + y„+ i = 0 (mod 2)
(3 .22)
holds. If this congruence fails, at least one error is present ; but if it holds ,
errors may still exist . Clearly, we can detect an odd number of errors, bu t
not an even number of errors .
The above method can be easily extended to checking for errors in string s
of digits . rather than just bits. The use of check digits with identification
numbers for error detection is now a standard practice. Notable examples
include social security numbers, telephone numbers, serial numbers on cur-
rency predate computers. Universal Product Codes (UPC) on grocery items .
and International Standard Book Numbers (ISBN) on published books . In
what follows, we shall introduce a modulus 11 error correction and detection
scheme for ISBN numbers .
Every recently published book has a 10-digit codeword called its Inter -
national Standard Book Number (ISBN) . This is a sequence of nine dig-
its .x:nx2 •
. . x9 . where each xi E {0, 1, 2, . . . ,9L together with a check digit
xio E {0. 1, 2, . . , 9, X} (we use the single letter X to represent the two digi t
number 10) . This last digit x lo is included so as to give a check that the
previous nine digits have been correctly transcribed ;3i o can be obtained by
xno
~i:n~ (mod 11) .
(3.23)
Note that if we arrange the ten digit ISBN number in the order o f
xior9 "'x2x1, then the check digit x i is determined by
ri = 11 — > ixi (mod 11) .
(3.24)
1=1 0
The whole 10-digit member satisfies the following so-called check congruence
Example 3 .2 .12 . The first nine digits of the ISBN number of the book b y
Ireland and Rosen [Ill] are as follows :
0-387-97329.
Find the check digit of this ISBN number . We first let
0
3
8
7
9
7
3
2
9
;7!1
.V2
3'3
:F:n
ii: :g
:It6
.r;
:Eg
:r 9
Then
So the complete ISBN number of the book is
0-387-97329-X .
Generally speaking, the coefficients a i , for i = 1 ; 2,
,n (or i =
no n. —
1, • . . ,1) could be any numbers as long as the n digits satisfies the check
congruence :
ai aa + a2x 2 + . +
0 (mod m) .
Example 3 .2 .13 . The ISBN number of the present book i s
, (mod 11)
i=l
[1 . 0+2 . 3+3-8+4 . 7+5 . 9 +
6 . 7+7 . 3+8 . 2+9 . 9] (mod 11)
=
10= X
0
3
8
xro
a'£
3
2
9
a ; x3
X 2
If we let
11 —
ixi (mod 11 )
t=n o
11—[10 . 0+9 . 3+8 . 8+7 . 7 +
6 . 9+5 . 7+4 . 3+3 . 2+2 . 9] (modll)
=
10= X
Then
ioE
- 0 (mod 11) .
3-540-65472-0
(3 .25)

9
a = [1-3+2-5+3 . 4+1 .0+5 . 6+6-5+7 . 4+8 . 7+9-2]( mod 11) = 0 .
Example 3 .2 .14. Suppose a book whose ISBN number is as follow s
9-810-:;3422-8
where x is an unknown digit. What is x'? To find he value for x, we perform
the following computation :
[1 . 9+2-8+3 . 1+4 . 0+5r+6-3+7 . 4 8 . 2+9 . 2+10 . 8] (mod 11) = 1.
So. we have
(since
5r - 9 (mod 11 )
2 (mod 11) .
Thus, x = 2 .
Exercise 3.2.1 . Find the value of r in each of the following ISBN numbers :
0-201-07981-x ,
0-8053-x340-2 .
0-19-8x3171-0 .
The ISBN code can detect
(1) 100% of all single digit errors .
(2) 100`7x, of double errors created by the transposition of two digits .
The detection process is as follows . Let x =
; ' - - - .r
- .rio be the original
io
codeword sent, y = ?li?/z . . .?ho the received string, and S =
Eiy, . If
S = 0 (mod 11), then y is the legitimate codeword and we assume it i s
correct, whereas if S 0 (mod 11), then we have detected error(s) :
3.2 Computer Systems Design
325
(1) Suppose the received strin Y = ?/Os
. . ?/ta is the same as x
=
•r't •rz . . . •r to except that the = :a A + a with 1 < k < 10 and a  .
Then
S =
ixi + ka A 0 (mod 11) ,
since k and a are all non zero elements in Z/11Z .
(2) Suppose the received string y = 111112 . . . mg is the same as x = xi . 1 .9
i o
except that V1 and .f A have been transposed . Then
ro
ut
S
=
t?rr =
+(k—+(,j—k)xA.
i= i
=
(k—j)( .r9 —xt )A0 (mod 11) .
ifk~jand r
Note that since Z/11Z is a field . the product of two non-zero elements i s
also non-zero but this does not hold in 7G/10a which is only a ring (say, fo r
example, 2 . 5 = 0 (mod 10)): this is why we work with modulo 11 rathe r
than modulo 10 . Note also that the ISBN code cannot he used to correc t
errors unless we know that
,just one digit is in error . Interested readers are
suggested to consult Gallian [77] and Hill [104] for more information abou t
error detection and correction codes .
We now move to the introduction of another interesting error detectio n
technique for programs (Brent [38]) . The Galileo spacecraft is somewhere nea r
Jupiter, but its main radio antenna is not. working. so communication with it
is slow. Suppose we want to check that a critical program in Galileo's mem-
ory is correct. How can we do this without transmitting the whole progra m
from/to Galileo'? The following is a method (possibly the simplest method )
for checking out Galileo's program based on some simple number theoreti c
ideas; the method was first proposed by Michael Rabin :
Let P9 be the program in Galileo and P, the program on Earth, each repre-
sented as an integer . Assuming P, is correct, this algorithm will try to determin e
whether or not Pi, is correct :
[1] Choose a prime number 10`' < p < 2 ' 109 and transmit p (p has no mor e
than 32 bits) to Galileo and ask it to compute ra t— P9 mod p and send th e
remainder rg back to Earth (r 4 has no more than 32 bits) .
[2] On Earth, we compute r, A Pi mod p, and check if ry = re .
[3] If ra  r e , we conclude that P9 0 P . That is, Galileo's program has bee n
corrupted !
[4] If i'
= r„ we conclude that P9 is probably correct. That is, if P9 is not
correct, there is only a small probability of < 10 — `r that
1-9 = c
. If this error
probability is too large to accept for the quality-assurance team, just goto
step [1] to start the process all over again, else terminate the algorithm b y
saying that P r is "almost surely" correct! It is clear that if we repeat th e
Computing/Cr ptography
324
3 . Applied Number Theory
satisfies its check congruence
[1. 3+2 . 5+3 . 4+4 . 0+5 . 6+6 . 5+7 . 4+8-7+9 . 2+10-0] (mod 11).
Suppose the first nine digits of the ISB N
to find the check digit .ri o, then we have
umber are given and we are aske d
an(
ro
r=r
1+5x-0(mod 11) .
To solve this linear congruence, we get
1 (mod 11 )
E
-9 (mod 11)

326
3 . Applied Number Theory in Computing/Cryptography
3 .2 Computer Systems Desig)
327
process, for example, ten times on ten different random primes, then th e
error probability will be less than 10-°0 , an extremely small number .
Clearly the idea underlying the method for program testing is exactly- th e
same as that of the probabilistic method for primality testing.
3 .2 .7 Random Number Generatio n
Anyone who considers arithmetic methods of producing random digits is ,
of course. in a state of sin .
JOHN VON NEUMANN (1903--1957 )
"Random" numbers have a great many uses in. e.g., numerical simulations .
sampling, numerical analysis, testing computer chips for defects . decision
making, coding and cryptography, and programming slot machines, etc . They
are a valuable resource : in some cases, they can speed up computations . they
can improve the rate of communication of partial information between tw o
users, and they can also be used to solve problems in asynchronous dis-
tributed computation that is impossible to sol ve by deterministic means . A
sequence of numbers is random if each number in the sequence is indepen-
dent of the preceding numbers: there are no patterns to help us to predic t
any number of the sequence . Of course. truly random numbers are hard to
come by, or even impossible to get. Thus, the so-called random numbers are
actually pseudorandom numbers . Since the invention of the first electronic
computer, researchers have been trying to find efficient ways to generate
random numbers on a computer . We have . in fact, already seen some appli-
cations of random numbers in this book; for example, Pollards p-method .
introduced in Chapter 2, uses random numbers in finding prime factorization
of large integers. In this subsection, we shall briefly introduce some method s
for generating random numbers based on linear congruences .
Firstly. let us introduce an arithmetic method, called the middle-square
method, suggested by John von Neumann= in 1946. The algorithmic descrip-
tion of the method is as follows :
John von Neumann (1903 1957) was born in Budapest, Hungary.
but lived in the L.S.A. from 1930 onwards. He is one of the leg -
endary figures of 20th century mathematics . He made important
contributions to logic, quantum physics . optimization theory an d
game theory . His lifelong interest in mechanical devices led to hi s
being involved crucially in the initial development of the modern
electronic computer and the important concept of the stored pro-
gram . He was also involved in the development of the first atomi c
bomb .
Algorithm 3 .2 .2 (Von Neumann's middle-square method) . This al-
gorithm uses the so-called middle-square method to generate random numbers :
[1] Let in be the number of random numbers we wish to generate (all with, fo r
example. 10 digits), and set i t— 0 .
[2] Randomly choose a starting 10-digit number n0 .
[3] Square n, to get an intermediate number H . with 20 or less digits .
[4]Set i = i+1 and take the middle ten digits of M as the new random numbe r
10 .
[5] If i < rn then goto step [3] to generate a new random number, else stop th e
generating process .
Example 3 .2 .15 . Let no = 9524101765, and m = 10. Then by Algorithm
3 .2 .2 we have
9524101765' = 90708514430076115225 
> i = 514430076 1
.5144300761 2 = 26463830319625179121 
>
n2 = 830319625 1
8303196251 2 = 68943067982620455001 
> n.3 = 0679826204
06798262042 = 462163667645049616
—>
n0 = 6366764504
6366764504 2 = 40535690249394366016 
> n; = 6902493943
6902493943 2 = 47644422633151687249 
>
no = 4226331516
4226331516 2 = 17861878083134858256 —>
n7 = 8780831348
87808313482 = 77102999162019497104 
> n.s = 9991620194
9991620194' = 99832474101148 .597636 
> c 9 = 474101148 5
47410114852 = 22477189900901905225 
>
n 1 ° = 1899009019 .
A serious problem with the middle-square method is that for many choices
of the initial integer, the method produces the same small set of numbers ove r
and over. For example, working with numbers that have four digits. staring
from 4100, we obtain the sequenc e
810(1,6100,2100 .4100,8100.6100.2100. . .
In what follows . we shall introduce some methods based on congruence the-
ory. which can generate a sequence of numbers that appear to be essentiall y
random .
Congruence theory is useful in generating a list of random numbers . At
present, the most popular random number generators in use are special case s
of the so-called linear congruential generator (LCG for short), introduced
first by D . H. Lehmer in 1949. In the linear congruential method, we firs t
choose four "magic" numbers as follows :
no
the modulus :
ii > 0
r0 :
the seed :
0 < :r;0 5 n
a :
the multiplier ;
0 < a < n
le
the increment ;
0 < b < ra

328
3 . Applied Number Theory in Computing/Cryptography
then the sequence of random numbers is defined recursively by :
xX - axi a l + b (mod n).
j > O .
(3.26)
for 1 < j < 1 . where/ E N is the least value such that xill - x i (mod n) for
some j <
1 . We call
1 the period length of the LCG generator. Clearly. the
maximum length of distinct random numbers generated by the LCG is th e
modulus n. The best random number generator is . of course, the one that ha s
the maximum length of distinct random numbers. Knuth gives a necessar y
and sufficient condition for a LCG to have maximum length :
Theorem 3 .2.5 (Knuth [123]) . A LCG has period length 1 = n if and
only if gcd(b, n) = 1, a - 1 (mod p) for all primes p
n and a - 1 (mod 4 )
if41Xa.
Note that. the parameter a is sometimes set to be 1: in that case, the LC G
is just a "plain" linear congruential generator. When a is set to be greater
than 1 . it is sometimes called a multiplicative linear congruential generator .
Nov we are in a position to give an algorithm for a LCG .
Algorithm 3 .2 .3 (Linear Congruential Generator) . This algorithm wil l
generate a sequence of random numbers {xl , x 2 . . • •
[1] [Initialization] Input xo, a, b, n and k (here k is just the number of random
numbers the user wishes to generate ; we can simply set k = n) . Set j +- 1 .
[2] [Random Number Generation] Compute
— (axi a l
+ b) (prod n), and
print xi
[3] [Increase j] j
1 . If j > k, then goto Step [4], else goto Step [2] .
[4] [Exit] Terminate the algorithm .
Example 3 .2 .16 .Let.xo=5.a=11.b= 73 . n= 1399 and k= 10. Then
by Algorithm 3 .2.3 we have :
xo = 5
axo + b (mod n)	
	
>
xi = 128
ax[ + b (mod n)
x2 = 82
axe + b (mod n)	
	
>
.ri = 975
ax 3 + b (mod n)  
>
x 1 = 1005
axI + b (mod n)
xs = 133 5
ax ;; + b (mod n)
—>
.r 11 = 768
taro + b (mod n)	 	
>
x7 = 127
ax7 + b (mod n)  
>
xs = 71
ax8 + b (mod n)	
>
x9 = 854
ax9 + b (mod n)
-->
xro = 1073
'-1'230 + b (mod n)
.x231 = 1149
3.2 Computer Systems Design
32 9
x 23 2
=
((x231 + b (mod n)
>
x232 = 121
(11232 + b ( plod n) 	
>
1233 = 5
r234 -
a .r233 + b (mod n)
— >
.r23 4 = 128 .
So the length of this random number sequenc e
(.rl,x2
x3 .x1, 1
4,1 : 1 5
x8 :
1i0 . .
. x ?,I
X 232, 1233 )
= (128 .82.975,1005.1335 . 768,12 7. 71, 854, 1073, . . . .1149 .121, 5)
generated by the LC G
xo 5 (mod 1399) ,
xj - 11 .
+ 73 (mod 1399) .
j =
2
is 233, i.e . . l = 233 .
Normally, we could set n = 2". a = 2' + 1 with
a, < r, and b = 1 . Thus ,
Equation (3.26) becomes
xy - (2r + l):rj_ l + 1 (mod 2r),
j = 1 .2, - • . (3.27)
To make a. LCG a good random number generator, it is necessary to find goo d
values for all the four magic numbers (not just the modulus n) that define th e
linear congruential sequence . Interested readers are invited to consult [123 ]
for a thorough discussion about the choice of the parameters . There are many
congruential generators based on the linear congruential generator :
(1) Power generator :
xy = (:ry_r)a (mod rt),
j = 1
(3 .28)
where (d, n) are parameters describing the generator and to is the seed .
There are two important special cases of the power generator, both oc-
curring when a = pq is a product of two distinct odd primes .
(i) The RSA3 Generator: This case occurs when gcd(d . 0(n)) = 1, where
0(n) is Euler's o-function . The map x t-* r 1 (mod n) is one-to-one on
(7G/aN)`, and this operation is the encryption operation of the RS A
public-key cryptosystem, where the pair (d .'n) is publicly known .
This special case of the power generator is called the RSA generator .
For example . let p = 13 .
q
= 23 and d = 17, so that n = 299 .
0(299) = 264 and gcd(299.17) = 1 . Let also xo = 6 . Then by the
RSA generator
ao = 6 ,
= x~~ r (mod 299),
j = 1 .2 ,
3 RSA stands for three computer scientists Rivest. Shamir and Adleman [209] ,
who invented the widely used RSA public-key cr}ptosystem in the 1970s, which
will be studied in the next section . The RSA generator has essentially the sam e
idea as the RSA cry ptosystem .
r, 3
x .1
r
r c
x 7
fro

330
3. Applied Number Theory in Computing /Cryptography
3 .2 Computer Systems Design
33 1
lave the following random sequence :
r t
r0
'
(mod 299)  
>
1 7
X2
r
(mod 299)  
>
xg
Xl:,
(mod 299)  
>
xr
jt
(mod 299)  
>
X
:1,1 7
(mod 299)  
>
(mod 299)  
>
1 7
x7
(mod 299) -3
:rs
a.; .
(mod 299)  
>
xi)
(mod 299 )
-c10
(mod 299) 
—>
17
x11
x10
(mod 299) 
—>
Thus, the length of this random number sequence generated by th e
RSA generator is 10 . That is 1 = 10 .
(ii) The square generator: This case occurs when d = 2 and n = pq
with p = q = 3 (mod 4) ; we call this the square generator. In this
case, the mapping xi H (aj_ 1 )2 (mod n) is four-to-one on (Z/nZ)* .
An even more special case of the square generator is the quadratic
residues generator:
y = x2
(mod n)
(3.29)
for some x .
(2) Discrete exponential generator :
g 7 '
(mod n), j = 1, 2, . . .
(3 .30)
where (g,n) are parameters describing the generator and xo the seed .
A special case of the discrete exponential generator is that when n is
an odd prime p. and g is a primitive root modulo p ; then the problem
of recovering xj_1 given by (.r 1 .q .n) is the well-known hard discrete
logarithms problem.
Note that simpler sequences of random numbers can be combined to pro -
duce complicated ones by using hashg and composition functions . For more
information on this topic . see Lagarias [136] and the references therein.
In some cases, for example, in stream-cipher cryptography (Zang [263]) .
a stream of random bits rather than a sequence of random digits (numbers )
will be needed. We list in the following some of the widely used random
bit generators (more random bit generators can be found . for example. in
Lagarias [136]) :
(1) RSA bit generator: Given k > 2 and in > 1, select odd primes p and q
uniformly from the range 2 k  p . q < 2r+1 and form n = pq . Select e
uniformly from [1 .n] subject to gcd(e . 0(n)) = 1 . Set
x i = (a•J_i) l
(mod n) . j = 1,2 . . . .
(3.31 )
and let the bit z be given by
zl = ail
(mod 2) .
f = 1 . 2 . . .
Then {z
: 1 L < k'" + in are the random bits generated by the seed
a`0 of the length 2k bits .
(2) Rabin's modified bit generator : Let k > 2 . and select odd primes p and
q uniformly from primes in the range 2 1` < p, q < 2k+1 and form n = pq,
such that p = q = 3 (mod 4) (this assumption is used to guarantee tha t
-1 is a quadratic nonresidue for both p and q) . Let,
(a 1_1 )2
(mod n),
if it lies in [0 . n/2) ,
z•i =
n
(x_1)2
(mod n), otherwise .
so that 0 < xj < n/2 . and the bit zj be given by
zj = xj
(mod 2), j = 1, 2, . ' . (3.34)
Then {zj : 1 < j < k"` + m} are the random bits generated by the seed
ao of the length 2k bits .
(3) Discrete exponential bit generator Let k > 2 and rn > 1. and select
an odd prime p uniformly from primes in the range [2 k . 2 11+1 , provided
with a complete factorization of p — 1 and a primitive root g . Set
a: 1 = 9 '
(mod p),
j = 1.2, -
(3.35)
and let the bit zl be the most significant bit
(mod 2) .
(3 .36)
Then {zj
:
1 L <
+ m} are the random bits generated by the see d
.ro .
(4) Elliptic curve hit generator: Elliptic curves. as we have already seen . have
applications in primality testing and integer factorization . It is interesting
to note that elliptic curves can also be used to generate random bits :
interested readers are referred to Kaliski [116] for more information .
x 1 = 617 = 288 (mod 299)
x2 = 288 17 = 32 (mod 299 )
x3 = 3217 = 210 (mod 299)
1 .3 = 210 17 = 292 (mod 299)
x0 = 292 17 = 119 (mod 299)
xe = 11917 = 71 (mod 299 )
x7 7 7117 = 41 (mod 299 )
xs = 41 17 7 123 (mod 299 )
eq 123 17 7 197 (mod 299)
x10 - 197i7 = 6 (mod 299 )
x11
617 = 288 (mod 299) .
(3 .32)
(3.33)

332
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
333
3.3 Cryptography and Information Security
Modern cryptography depends heavily on number theory ; with primality
testing, factoring, discrete logarithms (indices), and elliptic curves being
perhaps the most prominent subject areas .
MARTIN HELL\IA N
Foreword to the present boo k
Cryptography was concerned initially with providing secrecy for written mes-
sages. Its principles apply equally well to securing data flow between comput-
ers . to digitized speech, and to encrypting facsimile and television signals. For
example, most satellites routinely encrypt the data flow to and from groun d
stations to provide both privacy and security for their subscribers . In this sec-
tion. we shall introduce some basic concepts and techniques of cryptograph y
and discuss their applications to computer-based information security .
3.3.1 Introduction
Cryptography (from the Greek Kryptos, "hidden", and grophein.
to write" )
is the study of the principles and techniques by which information can b e
concealed in ciphertexts and later revealed by legitimate users employing th e
secret key, but in which it is either impossible or computationally infeasibl e
for an unauthorized person to do so . Cryptanalysis (from the Greek Kryptos
and analyein, "to loosen") is the science (and art) of recovering information
from ciphertexts without knowledge of the key. Both terms are subordinate
to the more general term cryptology (from the Greek Kryptos and logos.
`word") . That is.
Cryptology `i=r Cryptography + Cryptanalysis .
and
Cryptography tf Encryption + Decryption .
Modern cryptography. however. is the study of "mathematical" systems for
solving the following two main types of security problems :
(1) privacy .
(2) authentication .
A privacy system prevents t he extraction of information by unauthorize d
parties from messages transmitted over a. public and often insecure chan-
nel. thus assuring the sender of a message that it will only be read by the
intended receiver . An authentication system prevents the unauthorized injec-
tion of messages into a public channel, assuring the receiver of a message of
the legitimacy of its sender. It is interesting to note that the computationa l
engine, designed and built by a British group led by Alan Turing at Bletch-
1ey Park, Milton Keynes to crack the German E\IGMA code is considere d
to be among the very first real electronic computers ; thus one could argu e
that modern cryptography is the mother (or at least the midwife) of modern
computer science .
There are essentially two different types of cryptographic systems (cryp-
tosystems) :
(1) Secret-key cryptographic systems (also called symmetric cr_yptosystsms) ,
(2) Public key cryptographic systems (also called asymmetric cryptosys-
tems) .
Before discussing these two types of different cryptosystems . we present some
notation :
(1) Message space M : a set of strings (plaintext messages) over some alpha-
bet. that needs to be encrypted .
(2) Ciphertext space C : a set of strings (ciphertexts) over some alphabet ,
that has been encrypted .
(3) Key space IC : a set of strings (keys) over some alphabet, which include s
(i) The encryption key ct .
(ii) The decryption key d f; .
(4) The encryption process (algorithm) E: Eer (M) = C .
(5) The decryption process (algorithm) D : Da, (C) = M .
The algorithms E and D must have the property that
DdA. (C) = D (Il (EFk (M)) = M.
3.3.2 Secret-Key Cryptography
The legend that every cipher is breakable is of course absurd, though stil l
widespread among people who should know better .
.1 E . LITrl ewoo D
Mathematics with Minimum 'Ran Material' [144]
In a conventional secret-key cryptosystern (see Figure 3 .3), the same key
(i .e . . ex. = = k E IC) . called the secret key . is used in both encryption an d
decryption. By same key we mean that someone who has enough informatio n
to encrypt messages automatically has enough information to decrypt mes-
sages as well. This is why we call it secret-key cryptosy stem, or symmetric

334
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
33 5
Public and also insecure
channel
Cryptanalyst/Enemy
11~
Key source (Secret key)
Pseudorandom
Bit Generator
Key K
Pseudorandom
Bit Generator ]
Key K
Plaintext
Ciphertext
1I 
~+ 
C
Encryption
Figure 3.4 . A stream cipher
Plaintext
,1I
Decryptio n
\lessage
M
Encryption
C=E ti.(4I)
lI = Dk (C)
Message
1I
Decryption
T
Secure channel
AI
Key source
1
(Secret key)
Figure 3.3 . Conventional secret key cryptosystems
cry ptosystem. The sender uses an invertible transformation f defined by
f :
M1d
C .
(3 .37 )
to produce the cipher tex t
C=Ek (_l ),
1IEMandCEC .
(3 .38 )
and transmits it over the public insecure channel to the receiver. The key k
should also be transmitted to the legitimate receiver for decryption but via a
secure channel. Since the legitimate receiver knows the key k . he can decrypt
C by a transformation f –I defined by
k
(3 .39)
and obtain
Dk(C) = Dk(Ek(:11)) = M. C E C and lI E M .
(3.40)
the original plain-text message . There are many different types of secret-ke y
cryptographic systems. hr what follows. we shall introduce some of these sys -
tems . (Note that the terms cryptographic systems . cryptographic schemes . or
ciphers are essentially the same concepts . and we shall use them interchange -
ably in this chapter .)
(I) Stream (Bit) Ciphers. In stream ciphers. the message units are bits,
and the key is usually produced by a random bit generator (see Figure 3 .4) .
The plaintext is encrypted on a bit-by-bit basis :
0
1
1
0
0
0
1
1
1
1
1
1
1
0
1
0
1
0-- -
K
1
0
0
1
1
0
0
1
0
0
0
1
0
1
1
1
0
1
.
C
1
1
1
1
1
0
1
0
1
1
1
0
1
1
0
1
1
1-- -
The key is fed into the random bit generator to create a long sequence o f
binary signals. This key-stream ` K is then mixed with the plaintext stream
M . usually by a bit-wise XOR (Exclusive-OR. or modulo-2 addition) to pro -
duce the ciphertext stream C . The decryption is done by XORing with the
same key stream, using the same random bit generator and seed :
C
1
1
1
1
1
0
1
0
1
1
1
0
1
1
0
1
1
1
K
1
0
0
1
1
0
0
1
0
0
0
1
0
1
1
1
0
1
17
0
1
1
0
0
0
1
1
1
1
1
1
1
0
1
0
1
0
(II) Monographic (Character) Ciphers. Earlier ciphers (cryptosystems )
were based on transforming each letter of the plaintext into a different letter
to produce the Ciphertext . Such ciphers are called character, substitution or
monographic ciphers, since each letter is shifted individually to another lette r
by a substitution. First of all, let us define the numerical equivalents, as i n
Table 3.2. of the 26 English capital letters, since our operations will be o n
Table 3 .2 . Numerical equivalents of English capital letter s
A
B
C
D
E
F
G
H
I
I
K
L
5 1
0
1
2
3
4
.5
6
7
8
9
10
11
12
N
0
P
<~
R
S
T
l
V
\V
X
V
Z
13
14
15
16
17
18
19
20
21
22
23
24
2 5

336
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
33 7
the numerical equivalents of letters, rather than the letters themselves. The
following are some typical character ciphers .
(1) Caesar' cipher : A simple Caesar cipher uses the following substitutio n
transformation :
f3 = E3 (na) E rn. + 3 (m( d 26) . 0 < in E M < 25.
(3.41 )
and
f3
= D3 (c) E c — 3 (mod 26) . 0 < c C C < 25,
(3.42)
where 3 is the key for both encryption and decryption. Clearly. the corre-
sponding letters of the Caesar cipher will be obtained from those in Table
3.2 by moving three letters forward, as described in Table 3 .3. Mathe-
matically, in encryption we just perform a mapping rn. H m + 3 mod 26
on the plaintext . whereas in decryption a mapping c i c — 3'nod 26 on
the ciphertext .
Table 3 .3 . The corresponding letters of the Caesar cipher
F
C
H
I
J
K
L
M
8
9
10
11
12
13
14
15
I
I
2
2
S
I
I
I
4
K
L
M
N
0
P
S
T
U
V
W
X
Y
Z
2
I
I
2
2
2
2
21
22
23
24
25
0
1
2
x
2
2
2
2
x
V
\\'
X
Y
Z
A
B
C
(2) Shift transformations : Slightly more general transformations are the fol-
lowing so-called shift transformations :
ft = Et. (rn) E rn + k (mod 26), 0 < k, in < 25,
(3 .43 )
and
fj, r = D ti. (c) E c — k (mod 26),
0 < Lc < 25 .
(3 .44)
(3) Affine transformations: More general transformations are the followin g
so-called affine transformations :
fi,,.b) = E(, l,) (ni) E am + b (mod 26),
(3 .4.5 )
with a . b E Z the key. 0 < a. b. cn < 26 and gcd(a, 26) = 1. together with
f(a1At = D(a,b) (c) E a
t (c — b) (mod 26),
(3 .46)
where a—r is the multiplicative inverse of a modulo 26 (even more gener-
ally. the modulus 26 could be any number greater than 26 . but normally
chosen to be a prime number) .
Example 3.3.1 . In character ciphers, we hav e
E3 (IBM) = LEP ,
E , (NIST) = QLVW .
E7 (ENCRYPTION) = LUJXFWAPYU .
D .t (YWHEBKN.JEW) = CALIFORNIA .
D,(ZIBGVIY) = ENGLAND .
D6 (XYWLSJNCIH) = DECRYPTION .
Exercise 3.3.1. Decrypt the following character ciphertexts :
D7 (VHFFNGBVTMBHG) .
Ds (JVTLIZKP) .
Example 3.3.2. Use the following affine transformation s
47,21) -7m+21 (mod 26 )
M A
B C D
E
Shift
3
4
5
6
7
12
I
I
I
C D E F C
H
M
N O P Q
R
2
I
I
Shift 16 17 18 19 20
I
t
I
.
S
C Q R S T U
and
= 7—1 (c — 21) (mod 26)
to encrypt the message SECURITY and decrypt the message VLXIJH. To
encrypt the message . we have
Julius Caesar (100 44 BC) was a celebrated Roman general .
statesman. orator and reformer. The Caesar cipher . involving in
replacing each letter of the alphabet with the letter standing three
places further down the alphabet . was apparently used by Caesar
(he used the cipher in both his domestic and military efforts) ,
but he was also supposed to have invented the cipher himself .
Although the Caesar cipher was a simple cipher and particularl y
simple to crack, it is a useful vehicle for explaining cryptographi c
principles. (Photo by courtesy of Dr . Singh .)
S=18 .
7 •18+21 mod 26=17,
SR .
E=4.
7 . 4+21 mod26=23 .
E
.V .
C=2 .
7'2+21nrod26=9,
C
.J .
i%=20,
720+21mod26=5,
UF .
R=17,
7 . 17+21mod26=10 .
RK .
I=8 .
7'8+21mod26=25 .
IZ ,
T = 19,
7 . 19+21mod26=24,
TY.
Y=24,
7'24+21mod26=7,
Y~H .

338
3. Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
339
Thus, E ( 7.21 )(SECURITY) = RXJFKZYH. Similarly. to decrypt the message
VLXI.JH . we have
V = 21.
7—1 '(21—21)mod 26=0 .
i_4
L = 11 .
7—1 -(11—21)mod26=6 .
LG .
A=23 .
7—1
. (13—21)mod26=4 .
AE ,
I=8 .
7—1
. (8—21)mod26=13 .
N.
I=9.
7
1 . (9—21)mod26=2 .
.IzC ,
H=7.
7—1 . (7—21)mod26=24 .
HY.
Thus. Di?21) (VLXIJH) = AGENCY .
Exercise 3.3.2. Use the affine transformatio n
,f(11 .231 = llm + 23 (mod 26 )
to encrypt the message THE NATIONAL SECURITY AGENCY . Use also
the inverse transformation
f~li .23) = 11 —I (c — 23) (mod 26 )
to verify our result .
(III) Polygraphic (Block) Ciphers. Monographic ciphers can be made
more secure by splitting the plaintext into groups of letters (lather than a
single letter) and then performing the encryption and decryption on these
groups of letters . This block technique is called block ciphering . Block cipher
is also called a polygraphic cipher . Block ciphers may be described as follows :
(1) Split the message Al into blocks of n-letters (when n. = 2 it is called a
digraphic cipher) M, . 412. . •'
. 1 : each block Li, for 1 < i < j is a block
consisting of n letters .
(2) Translate the letters into their numerical equivalents and form the ci-
phertext :
C; = AM; + B (mod N),
= 1, 2, - '
..j
(3.47)
where (A, B) is the key, A is an invertible n x n
matrix wit h
gcd(det(A),A') = 1, B
(Big B2, .
, B„) r , Ci = (el ;c9 . . . . 'CO 7 and
M; = (nil , m2 ,
. m„) 1 . For simplicity, we just consider
C ; - AM; (mod 26) .
(3 .48)
(3) For decryption . we perform
M ; - A—1 (C ; — B) (mod N),
(3.49)
where A—1 is the inverse matrix of A. Again, for simplicity, we just
consider
M, A—I C ; (mod 26) .
(3.50)
Example 3 .3 .3 . Let
1I = YOUR PIN NO IS FOUR ONE TWO SIX
be the plaintext and n = 3. Let also the encryption matrix b e
/ 11 2 19
A = 5 23 25
\ 20 7 1 7
Then the encryption and decryption of the message can be described as fol-
lows :
(1) Split the message Al into blocks of 3-letters and translate these letter s
into their numerical equivalents :
Y
O
U
B.
PI
N
N
0
I
S
F
t
24
14
20
17
15
8
13
13
14
8
18
5
O
U
R .
0
N
E
T W
0
S
I
X
14
20
t
17
14
13
4
19
22
14
18
8
23
(2) Encrypt these nine blocks in the following way :
~24 \
22
X 17 \
/ 5 \
C,=A
14
6
C2 —A
15
=
6
\ 20 /
\
8 /
\
8 /
9 /
I 13 \
19
A
/ 8
11 \
C :3 = A
13
=
12
C4 = A
18
=
7
\ 14 /
\ 17 )
5 /
7
14 \
23 \
14 \
f 22 \
C5 = A
20
19
Cc=A
13
=
1
\
1
/
\
7 )
4 /
\ 23 1
(19
A
25 \
/18\
(
1 \
C 7 =A
22
15
Cs=A
8
17
14
\
)
\ 18
1
)
\ 23/
\
/

340
3. Applied _Number Theory in Computing/Cryptograph y
(3) Translating these into letters, we get the ciphertext C :
22 6
8
5
6
9
19 12 17
11
x
\V G I
F G J
T M R
L H
H
23 19 7
22 1 23
25 15 18
1
17
1
X T H
\\~ B X
Z P S
B B .
B
(4) To recover the message ill from C, we first compute _4 -i modulo 26 :
11 2 19
1
/ 10 23 7 \
A '
S 23 25
15 9 22
\ 20 7
17j
V 5 9 21
3 .3 Cryptography and Information Security
341
24
14
20
17
15
8
13
13
14
8
18
5
Y
0
U
R
P
I
N
N
0
I
S
F
14
20
17
14
13
4
19
22
14
18
8
23
0
U
H.
0
N
E
T
\V
0
S
I
X
which is the original message .
Exercise 3.3.3. Let
/ 3 13 21 9 \
15 10 6 25
10 17 4
8
\ 1 237 2 /
Use the block transformation
C Z - All, + B (mod 26 )
to encrypt the following message
PLEASE SEND ME THE BOOK, MY CREDIT CARD NO I S
SIX ONE TWO ONE THREE EIGHT SIX ZERO
ONE SIX EIGHT FOUR NINE SEVEN ZERO TWO .
Use
ill;
(C, - B) (mod 26 )
to verify your result. where
/ 2613205 \
0 10 11 0
9 111522
\ 9 22 6 25 /
(IV) Exponentiation Ciphers . The exponentiation cipher. invented by
Pohlig and Hellman in 1976. may be described as follows . Let p be a prime
number, Al the numerical equivalent of the plaintext . where each letter o f
the plaintext is replaced by its two digit equivalent . as defined in Table 3 .4 .
Subdivide II into blocks 111, such that 0 <.ill, < p. Let k be an integer with
0 < k < p and gcd(k :. p-1) = 1. Then the encryption transformation for 3I;
is defined by
C = E# (Ah)
Alf (mod p),
(3.51 )
and then perform C i = A -t C 1 as follows :
/ 22 \
/ 24 \
M t = A-1
6 = 14
2 = A
\
8 /
\ 20 /
/ 19 \
M3 =A ` 1 2
\ 17 j
/ 2 5 v
1 1 9 A
/ 1 \
/ 18 \
M7 = A-1 15
22
Ms = A-1
17 =
8
18)
\ 14/
\ l /
\ 23 /
So. we hav(
M4 = A-r
7
= 1 8
\
7 /
\ `' /
/ 23 \
/ 14 \
M5 = A-r 19 = 20
\ 1' /
/ 22 \
M6 = A-1
1
\ 23/
( 14
13
4 /
A=
and B =

342
3 . Applied Number Theory in Computing/Cryptog'aphy r
3.3 Cryptography and hrformation Security
34 3
Table 3.4. Two digit equivalents of letters
2174 4468 7889 6582 0924 5460 7868 7319 0726 2890 711 4
5463 .5000 0438 2300 0001 1607 3509 7143 .5648 3937 5064 .
To decrypt the ciphertext C back to the plaintext 11 . since the secret key k =
91 and the prime modulus p = 79,51 are known . we compute the multiplicative
inverse k-' of k modulo p - 1 as follows :
k-1
k (mod p - 1) E 91 (mod 7950) - 961 (mo( 7950) .
Thus. we hav e
u
A
B C D E F G H I 1 I{ L
M
1
2
S
I
S
S
1
2
2
I
S
S
00 01 02 03 04 05
06
07
08 09
10 11 12 13
N 0
P
Q R. S
T
U
V
R' X Y
Z
I
I
x
S
I
2
I
T
I
T
T
2
S
14 15 16
17
18 19 20 21
22 23
24
25 26
Al) = 2174 961 mod 7951 = 014
113 = 7889961 mod 7951 = 251 6
A15 = 924961. mod 79,51 = 151 4
MI7 = 7868961 mod 7951 = 507
111 = 726 96 ' mod 7 951 = 120
1111 = 7114961 mod 79.51 = 140 0
1113 = 5000161 mod 7951 = 220,5
AI15 = 2300961 mod 7951 = 201 5
1117 = 1607961 mod 7951 = 19
MI10 = 7143961 mod 7951 = 160 0
112 , = 3937961 mod 7951 = 1519
AI> = 4468961 mod 7951 = 318
11, = 6582 16 ' mod 7951 = 200 9
MI6 = 546096' rood 79.51 = 18
M8 = 7319961 mod 79.51 = 211 2
Milo = 2890961 mod 79.51 = 91 5
1112 = 5463961 mod 7951 = 131 5
4111 = 438961 mod 7951 = 1900
,1116 = 1%1 mod 7951 = 1
Ales = 3509961 mod 79.51 = 200 5
1120 = 5648961 mod 7951 = 31 2
11129 = 4736961 rood 7 951 = 518 .
and the decryption transformation b y
MI, = DR-, (C,) EC!'
(M.')k
111, (mod p),
(3.52)
where k . k-'
1 (mod p
1) .
Example 3 .3.4. Let p = 79.51 and k = 91 such that gcd(7951 - 1,91) = 1 .
Suppose we wish to encrypt the messag e
AI = ENCRYPTION REGULATION MOVES TO A STEP CLOSE R
using the exponentiation cipher . Firstly, we convert all the letters in th e
message to their numerical equivalents via Table 3 .4
0.5 14 03 18 2.5 16 20 09 15 14 00 18 05 07 21 12 01 20 09 15 14 0 0
13 15 22 05 19 00 20 15 00 01 00 19 20 05 16 00 03 12 15 19 05 1 8
and group them into blocks with four digit s
0514 0318 2516 2009 1 .5514 0018 0507 2112 0120 0915 1400
1315 2205 1900 201,5 0001 0019 200 .5 1600 0312 1519 0518
Then we perform the following computation
Therefore, we have recovered the original message .
Exercise 3 .3 .4 . Let. p = 9137 and k = 73 so that gcd(p - 1 . k) = 1 and
k-1 mod (p-1) = 7.50. Use the exponentiation transformation C = 4 1k' mod
p to encrypt the following message :
THE CESG IS THE UK NATIONAL TECHNICAL AUTHORIT Y
ON INFORMATION SECURITY .
THE NSA IS THE OFFICIAL INTELLIGENCE-GATHERIN G
ORGANIZATION OF THE UNITED STATES .
C1., =1900 91 mod 795 1
C16 = 0001 91 mod 7951
C'18 = 2005`31 mod 795 1
C'20 = 031291 mod 795 1
C'22 = 0518 91 mod 79 .5 1
C, = 0514 97 mod 7951 = 217 4
C3 = 251691 mod 7951 = 788 9
C3 = 151411 mod 79,51 = 92 4
C7 = 0507` 11 mod 7951 = 786 8
C,, = 0120 J1 mod 7951 = 726
C,, = 140091 mod 7951 7114
C'13 = 220591 mod 79.51 = 5000
C,, = 201591 mod 7951 = 2300
C17 = 0019 531 mod 79.1 = 160 7
C19 = 160091 mod 7951 = 7143
C2 1 = 1519J1 mod 7951 = 393 7
So . the ciphertext of AI is
Use also 11 =
mod p to verify your result.
Exercise 3 .3 .5 (A challenge problem) . The following cryptogram wa s
presented by Edouard Lucas at the 1891 meeting of the French Associatio n
for Advancement of Science (see Williams . [257]) : it has never been decrypted .
and hence is suitable as a challenge to the interested reader .
= 438
XSJOD
PEFOC
XCXFM
R.DZME
= 1
JZCOA
YUMTZ
LTDNJ
HBUSQ
= 3509
XTFLK
XCBDY
GYJKK
QBSAH
= 56-18
= 4736 .
QHXPE
TP\IUK
DBMLI
XGHIV
ZOYVQ
ARLAH
PRETL
SPGGP
C2 = 0318 91 mod 7951 = 446 8
C4 = 2009`31 mod 79.51 = 6,582
C6 = 0018`31 mod 79,51 = 546 0
C8 =2112" mod 7951=7319
Cm = 91591. mod 79,51 = 2890
= 131591 prod 77951 = 5463
2

344
3. Applied Number Theory in Computing/Cryptography
3.3 Cryptography
dl o ation
rmSecurity
345
VBQYH
TVJYJ
NXFFX
BVLCZ
LEFXF
VDMUB
QBIJV
ZGGAI
TRYQB
AIDEZ
EZEDX
KS
3.3.3 Data/Advanced Encryption Standard (DES/AES )
The most popular secret-key cryptographic scheme in use (by both govern-
ments and private companies) is the Data Encryption Standard (DES )
DES was designed at IBM and approved in 1977 as a standard by the U .S .
National Bureau of Standards (NBS), now called the National Institute o f
Standards and Technology (NIST) . This standard, first issued in 1977 (FIP S
46 Federal Information Processing Standard 46), is reviewed every fiv e
years. It is currently specified in FIPS 46-2 . NIST is proposing to replace
FIPS 46-2 with FIPS 46-3 to provide for the use of Triple DES (TDES) a s
specified in the American National Standards Institute (ANSI) X9 .52 stan-
dard. Comments were sought from industry, government agencies. and the
public on the draft of FIPS 46-3 before 15 April 15, 1999 .
The standard (algorithm) uses a product transformation of transpositions .
substitutions. and non-linear operations. They are applied for 16 iteration s
to each block of a message :: the message is split into 64 bit message blocks .
The key used is composed of 56 bits taken from a 64-bit key which includes 8
parity bits. The algorithm is used in reverse to decrypt each ciphertext bloc k
and the same key is used for both encryption and decryption . The algorithm
itself is shown schematically in Figure 3 .5. where the = is the "exclusive
or" (XOR) operator. The DES algorithm takes as input a 64-bit messag e
(plaintext) M and a 56-bit. key K . and produces a. 64-bit ciphertext C. DES
first applies an initial fixed bit-permutation (IP) to M to obtain M' . This
permutation has no apparent cryptographic significance . Second. DES divides
11' into a 32-bit left half Lo and 32-bit right half Ro . Third, DES execute s
the following operations for i = 1, 2, ' '
.16 (there are 16 `"rounds") :
Li = R,
1•
l
(3.53)
Ri =
f(Ri-1 .
)
where f is a function that takes a 32-bit right half and a 48-bit "round key "
and produces a 32-bit output . Each round key Ii i contains a different subset
of the 56-bit key bits. Finally. the pre-ciphertext C ' = (R IG
. L, 6 ) is permuted
according to IP_
n to obtain the final ciphertext C. To decrypt, the algo-
rithm is run in reverse : a permutation . 16 XOR rounds using the round ke y
in reverse order, and a. final permutation that recovers the plaintext. All of
this extensive bit manipulations can be incorporated into the logic of a single
Input - Plaintext (64 bits )
 I
Lr5 = R 1 .1
Rr5 = Li9 + f (Rr4y Kr5)
Rrs = L15 + f (R 1 .,, Krs)
L1c R 1
Figure 3 .5 . The Data Enc p on Standard (DES) algorithm
Initial permutatio n
Permuted
input
Preoutput
 
W	
l
Inverse initial permutation
Output - Ciphertext (64 bits)
Ki s

346
3. Applied Number Theory in Computing/Cryptography
3 .3 Cryptography and Information Security
347
special-purpose microchip, so DES can be implemented very efficiently . How-
ever. the DES cracking project being undertaken by the Electronic Frontie r
Foundation is able to break the encryption for .56 bit DES in about 22 hours .
As a result. NIST has recommended that businesses use Triple DES° (TDES) .
which involves three different DES encryption and decryption operations . Let
Eh (AI) and DK (C) represent the DES encryption and decryption of 3I an d
C using DES key K . respectively. Each IDES encryption/decryption opera-
tion (as specified in ANSI X9 .52) is a compound operation of DES encryption
and decryption operations. The following operations are used in IDES :
(1) TDES encryption operation: the transformation of a 64-bit block 9I
into a 64-bit block C is defined as follows :
C = E1 3 (DK.,( EK, (31))) .
(3 .54 )
(2) TDES decryption operation : the transformation of a 64-bit block C
into a 64-bit block 11 is defined as follows :
4I = DK, (EK, (D K, (C))) .
(3.55 )
There are three options for the IDES key bundle (K t , K2 . K3 ) :
(1) K 1 , K2, and K3 are independent keys .
(2) Kr, 119 are independent keys and K3 = K t .
(3) Kt = K2 = K3 .
For example, if option 2 is chosen, then the 'DES encryption and decryptio n
are as follows :
C = Ex,
( DK (EK, (31))) .
(3.56)
M = D 1 - , (EK> (D K, (C)))
(3.57)
Interested readers are suggested to consult the current NIST report FIPS
46-3 [173] for the new standard of the IDES .
It is interesting to note that some experts say DES is still secure when used
properly. However. Edward Roback at the NIST said that the DES, whic h
uses 56-bit en cryption keys, is no longer sufficiently difficult to decrypt. For
example. in February 1998, a team of engineers used a distributed "brut e
force decryption program to break a 56-bit DES key in 39 days, about thre e
Triple DES is a type of multiple encryption. Multiple encryption is a combinatio n
technique aimed to improve the security of a block algorithm. It uses an algo-
rithm to encrypt the same plaintext block multiple times with multiple keys .
The simplest multiple encryption is the so-called double encryption ill which an
algorithm is used to encrypt a block twice with two different keys — first encryp t
a block with the first key, and then encrypt the resulting ciphertext with th e
second key : C = EA, (Er, (DI)) . The decryption is just the reverse process of th e
encryption : AI = Dc , (D;,;. (C)) .
times faster than it took another team just the year before, and more recently .
the team cracked DES in just over 22 hours earlier this year .
The U.S . Department of Commerce's NIST had issued a formal call on 12
September 1997 for companies. universities . and other organizations to sub-
mit algorithm proposals for a new generation encryption standard for protect-
ing sensitive data well into the 21st century. This new Advanced Encryptio n
Standard (AES) will replace the DES and support encryption key size up to
2.56 bits and must be available royalty free throughout the world. On 20 Au-
gust 1998 at the First AES Candidate Conference (AES1) . NIST announced
fifteen (15) official AES candidate algorithms submitted by researchers fro m
twelve (12) different countries, including the United States . Australia, France .
Germany. Japan, Norway and the United Kingdom . Since then . cryptogra-
phers have tried to find ways to attack the different algorithms, looking for
weaknesses that would compromise the encrypted information . Shortly af-
ter the Second AES Candidate Conference (AES2) on 22 23 March 1999 i n
Rome, Italy, NIST announced on 9 August 1999 that the following five (5 )
contenders had been chosen as finalist for the AES, all are block ciphers :
(1) MARS: Developed by International Business Machines (IBM) Corpo-
ration of Armonk, New York . USA.
(2) RC6: Developed by RSA Laboratories of Bedford. Massachusetts, USA .
(3) Rijndael: Developed by Joan Damien and Vincent Rijmen of Belgium .
(4) Serpent: Developed by Ross Anderson. Eli Biham and Lars Knudse n
of the United Kingdom. Israel and Norway, respectively .
(5) Twofish: Developed by Bruce Schneier, John Kelsey, Doug Whiting ,
David Wagner Chris Hall and Niels Ferguson . of Counterpane Systems ,
Minneapolis . USA .
These five finalist algorithms had received further analysis during a second ,
more in-depth review period (August 1999 May 2000) in the selection o f
the final algorithm for the FIPS (Federal hrformation Processing Standard)
AES . On 2 October 2000 . the algorithm Rijndael. developed by Joan Dae-
men (Proton World International. Belgium) and Vincent Rijmen (Katholieke
Universiteit Leuven . Belgium) was finally chosen to be the AES . The stron g
points of Rijndael are a simple and elegant design, efficient and fast on moder n
processors . but also compact in hardware and on smartcards. These features
make Rijndael suitable for a wide range of applications . It will be used to
protect sensitive but 'unclassified' electronic information of the US govern-
ment . During the last year, a large number of products and applications has
been AES-enabled. Therefore. it is very likely to become a worldwide de fact o
standard in numerous other applications such as Internet security. hank cards
and ATMs .

348
3. Applied Number Theory in Computing/Cryptograph}
3.3 Cryptography and Information Security
349
3.3 .4 Public-Key Cryptography
An obvious requirement of a
,good cryptographic system is that secret mes-
sages should be easy to encrypt and decrypt for legitimate users, and thes e
processes (or, at least, decryption) should be hard for everyone else . Num-
ber Theory has turned out to be an excellent source of computational prob-
lems that have both easy and (apparently) hard aspects and that can be used
as the backbone of several cryptographic systems .
CARL POMERANC E
Cryptology and Computational Number Theory [191 ]
In their seminal paper 'New Directions in Cryptography" [66] . Diffie°
and Hellman'', both in the Department of Electrical Engineering at Stanford
University at the time . first proposed the idea and the concept. of public-key
Whitfield Diffie (1944 ), a Distinguished Engineer at Sun Mi-
crosystems in Palo Alto, California . is perhaps best known for
his 1975 discovery of the concept of public key cryptography, for
which he was awarded a Doctorate in Technical Sciences (Hon-
oris Causa) by the Swiss Federal Institute of Technology in 1992 .
He received a BSc degree in mathematics from the Massachusett s
Institute of Technology in 1965. Prior to becoming interested in
cryptography. he worked on the development of the l\-lathlab sym -
bolic manipulation system
sponsored jointly at. Mitre and the
MIT Artificial Intelligence Laboratory and later on proof of correctness of com-
puter programs at Stanford University. Diffie was the recipient of the IEEE Infor-
mation Theory Society Best Paper Award 1979 for the paper
New Directions in
Cryptography [66], the IEEE Donald E. Fink award 1981 for expository writing fo r
the paper Privacy and Authentication [67] (both papers co-authored with Martin
Hellman), and the National Computer Systems Security Award for 1996 . (Photo
by courtesy of Dr . Simon Singh .)
Martin E. Hellman (1945 ), the father of modern (public key )
cryptography . received his BEng from New York University i n
1966, and his MSc and PhD from Stanford University in 1967 an d
1969. respectively, all in Electrical Engineering . Hellman was on
the research staff at IBM's Watson Research Center from 1968-6 9
and on the faculty of Electrical Engineering at MIT from 1969-71 .
He returned to Stanford as a faculty member in 1971, where h e
served on the regular faculty until becoming Professor Emeritu s
in 1996 . He has authored over 60 technical papers, five U.S. and
a number of foreign patents. His work, particularly the in vention of public key
cryptography-. has been covered in the popular media including Scientific American
and Time magazine. He was the recipient of an IEEE Centennial Medal (1984) .
Notice that Diffie. Hellman and Merkle are the three joint inventors of public-
key cryptography. with Diffie and Merkle as Hellnrans research assistant and Ph D
student. (Photo by courtesy of Prof. Hellman .)
cryptography as well as digital signatures ; they also proposed in the sam e
time a key-exchange protocol . based on the hard discrete logarithm problem .
for two parties to form a common private key over the insecure channel (se e
Subsection 3.3.2) .
Figure 3.6. The DHM crypt() years : (Left to right) Merkle, Hellman and Diffie
(Photo by courtesy of Dr . Simon Singh)
It should be noted that Ralph Merkle s , deserves equal credit with Diffie
and Hellman for the invention of public key cryptography . Although his paper
Secure Communication Over Insecure Channels [158] was published in 1978 .
Ralph C. Merkle (1952 ) studied Computer Science at the Uni-
versity of California at Berkeley with a B .A. in 1974 and a M .S .
in 1977, and obtained his PhD in Electrical Engineering at Stan -
ford University in 1979 with the thesis entitled Secrecy . Authen-
tication . and Public Key Systems . with Prof. Martin Hellman as
his thesis advisor . Merkle co-invented public-key cryptography .
received the 1997 ACM Kanellakis Award (along with Leonard
Adleman. Whitfield Diffie. Martin Hellman . Ronald Rivest an d
Adi Shamir), the 1998 Feynman Prize in Nanoteehnology for the -
ory, the 1999 IEEE Kobayashi Award . and the 2000 RSA Award in :Mathematics .
He is currently a Principal Fellow- at Zyvex, working on molecular manufacturin g
also known as nanotechnology) . (Photo by courtesy of Dr . Merkle.)

350
3. Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
351
two years later than Diffie and Hellman's paper New Directions in Cryptog-
raphy, it was submitted in August 1975 . Also, his conception of public key
distribution occurred in the Fall of 1974. again before Diffie and Hellman
conceived of public key cryptosyste.ms .
Remarkably enough. just about one or two years later, three MIT com-
puter scientists, Rivest . Shamir. and Adleman, proposed in 1978 a practical
public-key cryptosystem based on primality testing and integer factorization .
now widely known as RSA cryptosystem (see Subsection 3 .3.6) . More specif-
ically, they based on their encryption and decryption on mod-n arithmetic .
where n is the product. of two large prime numbers p and q . A special cas e
based on mod-p arithmetic with p prime, now known as exponential cipher,
had already been studied by Pohlig and Hellman in 1978 [176] .
It is interesting to note that in December 1997 the Communication-
Electronics Security Group (CESG) of the British Government Communi-
cations Headquarters (GCHQ) . claimed that public-key cryptography was
conceived by Ellis 9 in 1970 and implemented by two of his colleagues Cocks1 0
James H. Ellis (1924 1997) was conceived in Britain but was
born in Australia . While still a bab y_ . he returned to and grew
up in London . He studied Physics at Imperial College, Lon-
don and worked in the Post Office Research Station at Dol-
lis Hill. In 1965, Ellis. together with the cryptographic divi-
sion at Dollis Hill, moved to Cheltenham to join the newl y
formed Communication Electronics Security Group (CESG), a
special section of the GCHQ, devoted to ensuring the securit y
of British communications . Ellis was unpredictable, introverted
and a rather quirky worker, he was never put in charge of an y
of the important CESG research groups. and he even didn't really fit into the
clay-to-day business of CESG . Nevertheless, he was a foremost British governmen t
cryptographer. Ellis had a good reputation as a cryptoguru, and if other researchers
found themselves with impossible problems. they would knock his door in the hope
that his vast knowledge and originality would provide a solution . It was probabl y
because of this reputation that the British military asked him in the beginning of
1969 to investigate the key distribution problem . that led him to have the idea o f
the non-secret encryption .
Clifford C. Cocks studied mathematics . specialized in number the-
ory . at the University of Cambridge and joined the CESG i n
September 1973 . While as a school stadent in Manchester Gram -
mar School. he represented Britain at the International Mathemat-
ical Olympiad in Moscow in 1968 and won a Silver prize . Before
joining CESG he knew very little about encryption and its inti-
mate connection with military- and diplomatic connnunications ;
so his mentor. Nick Patterson at CESG told hirer Ellis 's idea for
public-key cryptography . "Because I had been working in number
theory. it was natural to think about one-way functions . something you could d o
but not undo. Prime numbers and factoring was a natural candidate ." explained by
Cocks . It did not take him too long to formulate a special case of the RSA publi c
key cryptography.
and Williamson" between 1973 and 1976 in CESG, by releasing the followin g
five papers:
[1]James H . Ellis. The Possibility of Non-Secret Encryption . January 1970 .
9 pages .
[2]Clifford C. Cocks, A Note on Non Secret Encryption . 20 November 1973 .
2 pages .
[3]Malcolm J . Williamson . Non-Secret Encryption Using a Finite Field, 21
January 1974 . 2 pages .
[4] Malcolm Williamson . Thoughts on Cheaper Non-Secret Encryption. 10
August 1976 . 3 pages .
[5] .James Ellis. The Story ofNon-Secret Encryption . 1987. 9 pages .
The US Government's National Secu rity Agency (NSA) also made a similar
claim that they had public-key cryptography a decade earlier. It must be
pointed out that there are apparently two parallel universes in cryptogra-
phy, the public and the secret worlds . The CESG and even the NSA peopl e
certainly deserve some kind of credit . but according to the `"first to pub-
lish, not first to keep secret" rule. the full credit. of the invention of public -
key cryptography goes to Diffie . Hellman and Merkle (along with Rivest ,
Shamir and Adleman for their first practical implementation) . It. must also
be pointed out that Diffie and Hellman [66] in the same time also propose d
the marvelous idea of digital signatures, and in implementing their RSA cryp-
tosystem. Rivest . Shrnire and Adleman also implemented the idea of digita l
signatures, whereas none of the CESG released papers showed any evidenc e
that they had any thought of digital signatures. which is half of the Diffie-
Hellman-Merkle public-key cryptography invention !
In a public-key (non secret key) cryptosystern (see Figure 3 .7) . the encryp-
tion key ek. and decryption key d k. are different . that is .
e k.
d k (this is why
we call public-key cry ptosystems a,syrnmetric key cryptosysterns) . Since t', is
Malcolm J. Williamson also attended the Manchester Gram-
mar School and studied mathematics at the University o f
Cambridge. but joined the CESG in September 1974 . Same as
Clifford Cocks, Malcolm Williamson also represented Britain
at the International Mathematical Olympiad in Moscow i n
1968 but won a Gold prize . When Cocks first explained hi s
work on public-key cryptography to Williamson . Williamson
really didn ' t believe it and tried to prove that Cocks ha d
made a mistake and that public-key cryptography (lid no t
really exist. Remarkably- enough, 'Williamson failed to find a mistake, instead h e
found another solution to the problem of key distribution . at roughly the same time
that Prof. Martin Hellman discovered it . (Photos of Ellis. Cocks and Williamso n
by courtesy of Dr. Simon Singh .)

352
3. Applied Number Theory in Computing/Cryptography
3 .3 Cryptography and nforma on Security
3 .53
Public and also insecure
channel
Cryptanal5-st/Enemy-
t
Decryption
Message
_11=D,t,,(C')h 
11
Message
11
Encryption
C = E, (31)
Key kource 1
Key source 2
Encryption key
Decryption ke y
(Public key)
(Private key )
Figure 3 .7. Modern public-key cryptosystems (e
dk)
only used for encryption, it can be made public ; only dk. must he kept a se-
cret for decryption . To distinguish public: key cryptosystems from secret-ke y
cryptosystems, ek is called the public key, and dk the private key ; only the key
used in secret-key cryptosystems is called the secret key. The implementation
of public-key cryptosystems is based on trapdoor one-way functions .
Definition 3.3.1 . Let S and T be finite sets. A one-way function
f
: S-4T
(3 .58)
is an invertible function satisfyin g
(1) f is easy to compute, that is, given x E S . y f (x) is easy to compute .
(2) f -' . the inverse function of f , is difficult to compute. that is, given
y E T. x = f -1 (y) is difficult to compute .
(3) f is easy to compute when a trapdoor (i.e .. a secret string of infor-
mation associated with the function) becomes available .
A function f satisfying only the first two conditions is also called a one-to -
one one-way function. If f satisfies further the third condition . it is called a
trapdoor one-way function .
Example 3.3.5. The following functions are one-way functions :
(1) f : pq * n is a one-way function. where p and q are prime numbers. The
function f is easy to compute since the multiplication of p and q can be
done in polynomial time. However, the computation of f- ' . the inverse of
f is an extremely difficult problem (this is the well-known difficult integer
factorization problem) : there is no efficient algorithm to determine p and
q from t heir product pq. in fact . the fastest factoring algorithm NFS run s
un subetponential time.
(2) f5 .y
:
x
g r mod N is a one-way- function . The function f is easy to
compute since the modular exponentiation g` mod N can be performed
in polynomial time. But the computation of f- ' . the inverse of f is
an extremely difficult problem (this is the well-known difficult discrete
logarithm problem) : there is no efficient method to determine x from the
knowledge of ,g' mod N and g and N .
(3) fk ._ x
xk mod AN is a trapdoor one-way function, where _N = pq
with p and q primes, and kk' - 1 (mod o(Aa)) . It is obvious that f
is easy to compute since the modular exponentiation .rk mod N can be
done in polynomial time, but f-i , the inverse off (i.e .. the kth root of x,
modulo N) is difficult to compute . However, if k' . the trapdoor is given .
f can he easily inverted . since (x k)k = x .
Remark 3.3.1. The discrete logarithm problem and the integer factoriza-
tion problem are the most important difficult number-theoretic problems o n
which to build one-way functions in practice. Of' course . there night exis t
some other problems which can be used to build one-way functions. One
such problem is the so-called Quadratic Residuosity Problem (QRP), that
can be simply stated as follows (recall that an integer a is a quadratic residu e
modulo n if gcd(a,a) = 1 and if there exists a solution x to the congruenc e
x' = a (mod n)) :
Given integers a and n, decide if a is a quadratic residue modulo n.
If n = p is an odd prime, then by Euler's criterion (Theorem 1.6.26), a is a
quadratic residue of' p if and only if atv- ')/2
1 (mod p) . What about if n
is an odd composite? In this case, we know that a is a quadratic residue o f
n if' and only if it is quadratic residue modulo every prime dividing n . It is
evident that if ( a ) = -1, then (a ) = -1 for some i. and a is a quadrati c
Pi
nonresidue modulo n . On the other hand, even if (
o, ) = 1, it may be possibl e
for a to be a quadratic nonresidue modulo n . This is precisely the case that
is regarded by some researchers as an intractable problem . since the only
method we know for determining quadratic residuosity in this case require s
that we first factor n . Because of' our inability to solve the quadratic resid-
uosity problem without factoring, several researchers have proposed cryp-
tosystems whose security is based on the difficulty of determining quadrati c
residuosity. Whether it is in fact intractable (or at least equivalent to factorin g
in some sense) remains a very interesting question (McCurley [151]) . We shall
introduce an encryption scheme based the QRP in Section 3 .3.7. There are
also some analogues such as elliptic curve analogues of discrete logarithms ,
which can be used to build one-way functions in public key cryptosystems :
we shall introduce these analogues and their cryptosystems in later section s
of this chapter .

354
3 . Applied Number Theory in Computing/Cryptography
3 .3 Cryptography and Information Security
355
Remark 3.3.2 . Public key cryptosystems have some important advantages
over secret-key cryptosystems in the distribution of the keys . However, when
a large amount of information has to be communicated, it may be that the us e
of public-key cryptography would be too slow, whereas the use of secret-ke y
cryptography could be impossible for the lack of a shared secret key. In prac-
tice. it is better to combine the secret-key and public-key cryptography int o
a single cryptosystem for secure communications . Such a combined system is
often called a hybrid cryptosystem. A hybrid cryptosystem uses a public-ke y
cryptosystem once at the beginning of the communication to share a shor t
piece of information that is then used as the key for encryption and decryp-
tion by means of a `"conventional" secret key cryptosystem in later stages .
Such a cryptosystem is essentially a secret key cryptosystem but still enjoy s
the advantages of the public-key cryptosystems .
3.3.5 Discrete Logarithm Based Cryptosystems
The Diffie-Hellman-Merkle scheme, the first public-key cryptographic . scheme ,
is based on the intractable discrete logarithm problem, which can be describe d
as follows :
Input
:
Cl . b, 72 E N
Output
:
x E N with a` 
b (mod TO
if such a x exists
The Diffie-Hellman-Merkle scheme has found widespread use in practica l
cryptosystems. as for example in the optional security features of the NFS
file system of SunOS operating system. In this subsection. we shall introduce
some discrete logarithm based cryptosystems .
(I) The Diffie-Hellman-Merkle Key-Exchange Protocol . Diffie and
Hellman [66] in 1976 proposed for the first time a public key cryptographi c
scheme based on the difficult discrete logarithm problem . Their scheme was
not a public key cryptographic system (first proposed in [66]), but rather a
public key distribution system as proposed by Merkle [158] . Such a public key
distribution scheme does not send secret messages directly- . but rather allows
the two parties to agree on a common private key over public networks t o
be used later in exchanging messages through conventional cryptography .
Thus, the Diffie-Hellman-Merkle scheme has the nice property that a very
fast scheme such as DES or AES can be used for actual encryption . yet it
still enjoys one of the main advantages of public-key cryptography . The Diffie-
Hellman-Merkle key-exchange protocol works in the following way (see als o
Figure 3.8) :
(1) A prime q and a generator g are made public (assume all users hav e
agreed upon a finite group over a fixed finite field IF q ),
(2) Alice chooses a random number a e {1, 2, .
.q -1} and sends g" mod q
to Bob ,
(3) Bob chooses a random number b E
to .Vice .
{1 .2 .
.q -1} and sends gb mod q
(4) Alice and Bob both compute g ab mod q and use this as a private key fo r
future communications .
Clearly, an eavesdropper has g . q, g" mod q and g b mod q, so if he can
take discrete logarithms. he can calculate g" b mod q and understand commu-
nications. That is. if the eavesdropper can use his knowledge of g . q, g" mod q
and g b mod q to recover the integer a, then he can easily break the Diffie -
HelhnanMerkle system. So. the security of the Diffie-Hellman-Merkle syste m
is based on the following assumption :
Diffie-Hellman-Merkle Assumption : It is computationally infea-
sible to compute g" b from g" and fi b .
In theory. there could be a way to use knowledge of g" and g b to find g ab .
But at present we simply cannot imagine a way to go from g" and g b to g a b
without essentially solving the discrete logarithm problem .
Example 3.3.6. The following example, taken from McCurley [150], show s
how the Diffie-Hellman-Merkle scheme works in a real situation :
Alice chooses a.
Bob chooses b
Alice Computes :
(g h mod q)" = g ab mod q
Bob Computes:
(ga mod q) b = gab mod q
Figure 3.8. The Diffie-HellmanAlerkel key-exchange schem e

356
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Securit
357
(1) Let q = (7 149 – 1)/6 and p = 2 . 739 - q + 1 . (It can he shown that both
p and q are primes . )
(2) Alice chooses a random number residue x modulo p . computes 7 r (mod
p) . and sends the result to Bob . keeping x secret .
(3) B receives
7` = 12740218011997394682426924433432284974938204258693162165
4557735290322914679095998681860978813046595166455458144 2
8058807676603378 1
(4) Bob chooses a. random number residue ,y modulo p. computes 7Y (rno
p) . and sends the result to Alice, keeping y secret .
(5) Alice receives
7 = 18016228528745310244478283483679989501596704669 .3466973 1
302.5121734059953772058475958176910625380692101651848662 3
62137934026803049
(6) Now both Alice and Bob can compute the private key 7".' (mod p) .
McCurlev offered a prize of $100 in 1989 to the first person to find the private
key constructed from the above communication .
Remark 3.3.3 . blcCurlev's 129-digit discrete logarithm challenge was actu-
ally solved on 25 January 1998 using the NFS method, by two German com-
puter scientists, Damian Weber at the Institut ff r Techno -und Wirtschafts-
mathematik in Kaiserslautern and Thomas F . Denny at the Debis IT Securit y
Services in Bonn .
As we have already mentioned earlier the Diffie-Hellman-Merkle schem e
is not intended to be used for actual secure communications . but for key -
exchanges. There are, however several other cryptosystc ms based on discret e
logarithms, that can be used for secure message transmissions .
(II) The ElGamal Cryptosystem for Secure Communications. In
1985, ElGamal proposed a public key cryptosystem based on discrete loga-
rithms :
(1) A prime q and a generator g E a are made public .
(2) Alice chooses a private integer a = a,r E 1E2, '
.
. q – 1 }. This a is the
private decryption key. The public encryption key is g "
,/
(3) Suppose now Bob wishes to send a message to Alice . He chooses a
random number b E {1, 2, -' .
. q
1} and sends Alice the following pair
of elements of IF,r :
(gl' . Mg" )
where \I is the message .
(4) Since Alice knows the private decryption livy a . she can recover \I from
this pair by computing g° U (mod q) and dividing this result into the
second element, i .e . . lilg"e
Remark 3.3.4. Someone who can solve the discrete logarithm problem in
iFq breaks the cryptosystem by finding the secret decryption key a from the
public encryption key g° . In theory, there could be a way to use knowledge o f
g" and ge to find g" v and hence break the cipher without solving the discrete
logarithm problem . But as we have already seen in the Diffie-Hellman scheme .
there is no known way to go from g" and g 1' to gae without essentially solvin g
the discrete logarithm problem . So, the ElGamal cryptosystem is equivalen t
to the Diffie–Hellman key-exchange system.
(III) The Massey–Omura Cryptosystem for Message Transmis-
sions. This is another popular cryptosystem based on discrete logarithms ;
it works in the following way :
(1) All the users have agreed upon a finite group over a fixed finite field 1F9
with q a prime power .
(2) Each user secretly selects a random integer e between 0 and q – 1 such
that gcd(e, q – 1) = 1, and computes d = e–r mod (q – 1) by using the
extended Euclidean algorithm .
(3) Now suppose that user Alice wishes to send a secure message _lI to use r
Bob, then they follow the following procedure :
(i) Alice first sends M'i-' to Bob.
(ii) On receiving Alice's message, Bob sends Al"'" back to Alice (not e
that at this point . Bob cannot read Alice's message Al).
(iii) Alice sends 11I P "
1J"' to Bob .
(iv) Bob then computes _l7aQea =111, and hence recovers Alice's original
message H .

358
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
359
3 .3 .6 RSA Public-Key Cryptosystetn
In 1978. just shortly after Diffie and Hellman proposed the first public-ke y
exchange protocol at Stanford, three MIT researchers Rivest i'-. Shamir" an d
Adlemani1 proposed the first practical public-key cryptosysteui . now widely
known as the RSA public-key cryptosystem. The RSA crvptosystem is base d
on the following assumption :
RSA Assumption: It is not so difficult to find two large prime
numbers, but it is very difficult to factor a large composite into it s
prime factorization form .
(2
Ronald L. Rivest (1948 ) is currently the 'Webster Professor of
Electrical Engineering and Computer Science in the Department
of Electrical Engineering and Computer Science (SECS) at th e
Massachusetts Institute of Technology (MIT) . an Associate Direc-
tor of the MIT's Laboratory for Computer Science, and a leader o f
the lab's Cryptography and Informnation Security Group . He ob-
tained a B .A. in Mathematics from Yale University in 1969 . and
a Ph.D. in Computer Science from Stanford University in 1974 .
Professor Rivest is an inventor of the RSA public-key crvptosys -
tent, and a founder of R.SA Data Security (now a subsidiary of Security Dynamics) .
He has worked extensively in the areas of cryptography, computer algorithms . ma-
chine learning and VLSI design . (Photo by courtesy of Prof. Rivest .)
Adi Shamir (Born 1952) is currently Professor in the Depart-
ment of Applied Mathematics and Computer Science at th e
1Weizmann Institute of Science . Israel. He obtained his Ph D
in Computer Science from the AWeizmann Institute of Scienc e
in 1977, with Prof. Zohar Manna on "Fixedpoints of Recur-
sive Programs" . and did his postdoc with Prof. Mike Pater-
son for a year in Computer Science at Warwick Universit y
England. He participated in developing the RSA public-key
crvptosystern, the Fiat-Shamir identification scheme, poly-
nomial secret sharing schemes, visual cryptosystens. lattice attacks on knapsac k
cryptosystenrs. differential cryptanalvsis, fault attacks on smart cards, algebrai c
attacks on multivariate cryptosystems and numerous other cryptographic scheme s
and techniques. (Photo by courtesy of Prof. Shamir .)
Leonard Adleman (Born 1940 ) received his BSc in mathematic s
and PhD in computer science both from the University of Cali-
fornia at Berkeley in 1972 and 1976. respectively. He is currently
Professor in the Department of Computer Science at the Uni-
ersrty of Southern California . His main research activities are
in theoretical computer science with particular emphasis on th e
complexity of number theoretic problems . Recently he has also
been involved in the development of DNA biological computers .
(Photo by courtesy of Prof. Adleman.)
The system works as follows :
C
11' (rood -l-)
31- C'' (mod A' )
where
(1) .1I is the plaintext .
(2) C is the ciphertext .
(3)
V = pq is the modulus, with p and q large and distinct primes .
(4) e is the public encryption exponent (key) and
d the private decryption
exponent (key) , with ed 1 ( mod o(N)). (N, e) should be made public ,
but d (as well as O(N)) should be kept secret .
Figure 3.9. The RSA civpto years : (Left to right) Shamir . Rivest and Adleman
(Photo by courtesy of Prof. Adleman)
Clearly, the function f : 31 -i C is a one-way trap-door function . since
it is easy to compute by the fast exponentiation method . but its inverse
f -' : C - 11 is difficult to compute, because for those who do not know th e
private decryption key (the trap-door information) d . they will have to factor
a. and to compute 0(n) in order to find d . However, for those who know d,
then the computation of f-i is as easy as of' f. This exactly the idea of RS A
cryptography.
Suppose now the sender, say, for example, Alice wants to send a message
Al to the receiver, say, for example. Bob. Bob will have already chosen a.
(3 .59)

360
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
361
one-way trapdoor function f described above. and published his public-key
(e. N), so we can assume that both Alice and any potential adversary know
(e. N) . Alice splits the message M into blocks of [log Nj bits or less (padde d
on the right with zeros for the last block), and treats each block as an intege r
E 10 .1 .2 . •
-1} . Alice computes
y - .c (mod N )
and transmits y to Bob. Bob, who knows the private key d, computes
.r
y d (mod N)
where ed - 1 ( prod ()(N)) . An adversary who intercepts the encrypted mes-
sage should be unable to decrypt it without knowledge of d . There is no
known way of cracking the RSA system without essentially factoring N . so
it is clear that the security of the RSA system depends on the difficulty of
factoring N. Some authors. for example, Woll [259] observed that finding the
RSA decryption key d is random polynomial-time equivalent to factorization .
More recently. Pinch [184] showed that an algorithm A(N, e) for obtaining it
given N and e can be turned into an algorithm which obtains p and q with
positive probability.
Example 3 .3 .7 . Suppose the message to be encrypted is "Please wait for
me" . Let N = 5515596313 = 71593 - 77041 . Let also e = 1757316971
with gcd(e, N) = 1. Then d
1/1757316971E 2674607171 (mod (71593 —
1) (77041— 1)) . To encrypt the message, we first translate the message into its
numerical equivalent by the letter-digit encoding scheme described in Tabl e
3.4 as follows :
Al = 1612050119050023010920061518001305 .
Then we split it into 4 blocks, each with 10 digits, padded on the right wit h
zeros for the last block:
AI (11th , Al-, .,X13, Al4) = (1612050119 0500230109 2000061518 0013050000) .
Now . we have
CI - 1 6 1 2050119 17 073 1 697 1 E 763222127 (mod 5515596313 )
6, E 05002301091 >7316s71 _ 1991534528 (mod 5515596313 )
C3 = 20000615181757316971 E 74882553 (mod 5515596313 )
C4 = 00130500001 757316971 - 3895624854 (mod 5 .515596313)
To decrypt the cipher text, we perform :
lI 1 - 7632221272674607171 E 1612050119 (mod 5515596313)
AI, = 1991534528 2674607171 = 500230109 (mod 5515596313 )
113 = 748825532674607 ' 71 = 2000061518 (mod 551;5596313 )
AI4 E 389562485426746071n _ 13050000 (mod 5515596313)
By padding the necessary zeros on the left of some blocks . we get
Al = (M I , _112 .
13 , Alt ) = (1612050119 0.500230109 2000061518 0013050000 )
which is ""Please wait for me", the original plaintext message .
Example 3.3.8. We now give a reasonably large RSA example . In one of
his series of Mathematical Games . Martin Gardner [78] reported an RSA
challenge with US$100 to decrypt the following message C :
96869613754622061477140922254355882905759991124 .57_
4319874695120930816298225145708356931476622883989 _
628013391990551829945157815154 .
The public key consists of a pair of integers (e . N) . where e = 9007 and N is
a "random" 129-digit number (called RSA-129) :
1143816257578888676692357799761466120102182967212 _
4236256256184293570693524573389783059712356395870 _
5058989075147599290026879543541 .
The RSA-129 was factored by Derek Atkins, Michael Graff, Arkin K. Lenstra ,
Paul Leyland et al . on 2 April 1994 to win the $100 prize offered by RSA in
1977. Its two prime factors are as follows :
3490529510847650949147849619903898133417764638493 _
387843990820577 .
3276913299326670954996198819083446141317764296799 _
2942539798288533 .
They used the double large prime variation of the Multiple Polynomia l
Quadratic Sieve (MPQS) factoring method . The sieving step took approx-
imately 5000 nips years, and was carried out in 8 months by about 60 0
volunteers from more than 20 countries. on all continents except Antarctica .
As we have explained in the previous example . to encrypt an RSA encrypte d
message. we only need to use the public key (N . c) to compute
y/ (mod N) .
But decrypting an RSA message requires factorization of N if one does not
know the secret decryption key. This means that if we can factor N. then we
can compute the secret key d, and get back the original message by calculating
(3.60 )
(3.61)
That is
C = (C l C,, C3 , C:1) = (763222127,1991534528,74882553 .3895624854) .

362
3 . Applied Number Theory in Computing/Cryptography
3 .3 Cryptography and Information Security
363
_ (mod N) .
Since now we know the prime factorization of N . it is trivial to compute the
secret key d
1/e mod o(N), which in fact i s
1066986143685780244428687713289201547807099066339 _
3786280122622449663106312591177447087334016859746 _
2306553968544513277109053606095 .
So we shall be able to compute
- _lI (mod N )
without any problem. To use the fast exponential method to compute
C' mod N . we first write d in its binary form d i d2 • • . d s,,0 (where size is
the number of the bits of d) as follows :
d = dr d .2
. . . d-i2s =
100111011001111110010100110010001000001000001110100111100100110 _
010011110100111000000000000011111110100001101010110001011101111 _
010100001111101100000010000011101101010101111010101001111110110 _
110100001111110100000011110100110001011001011001101001010001100 _
100111010110000101110100101011010000011100000001110001110101010 _
011011101000111101001110001101011010101010010011101010001001111 _
00000010011101001100011011111010110010001100111 1
and perform the following computation :
AIt– 1
for i from 1 to 426 do
M P mod N
if di = 1 then Al
AI . 0 mod N
print lI
which gives the plaintext M :
2008050013010709030023151804190001180500191721050 _
1130919080015191909061801070 5
and hence the original message :
THE MAGIC WORDS ARE SQUEAMISH OSSIFRAG E
via the encoding alphabet U = 00. .4 = 01, B = 02,
. .
. Z = 26. Of course, by
the public encryption key e = 9007 . we can compute ill' - C ( mod N) : first
write e in the binary forme e 1 e2 . . e~ .1 = 10001100101111 . then perform
the following procedure :
C
1
for i from 1 to 14 do
CC.'2 mod
if e,=lthen C –C-11Imod N
print C
which gives the encrypted text C at the beginning of this example :
9686961375462206147714092225435588290575999112457 _
1319874695120930816298225145708356931476622883989 _
628013391990.55182994515 77815154 .
Remark 3 .3 .5 . In fact, anyone who can factor the integer RSA-129 can
decrypt the message . Thus. decrypting the message is essentially factoring
the 129-digit integer . The factorization of RSA-129 implies that it is possible
to factor a random 129-digit integer . It should be also noted that on 10 April
1996. Arjen Lenstra et al. also factored the following RSA-130:
1807082088687404805951656164405905566278102516769 _
4013491701270214500566625402440483873411275908123 _
0337178188796656318201321488055 7
which has the following two prime factors :
3968599945959745429016112616288378606757644911281 _
0064832555157243 .
4553449864673597218840368689727440886435630126320 _
5069600999044599 .
This factorization was found using the Number Field Sieve (NFS) factoring
algorithm . and beats the above mentioned 129-digit record by the Quadratic
Sieve (QS) factoring algorithm. The amount of computer time spent on this
130-digit NFS record is only a fraction of what was spent on the old 129-digit
QS-record. More recently a. group led by Peter Montgomery and Herman to
Riele found in February 1999 that the RSA-140:
2129024631825875754749788201627151749780670396327 _
7216278233383215381949984056495911366573853021918 _
31678310738799531723088956923087344193647 1
can he written as the product of two 70-digit primes :
3398717423028438554530123627613875835633986495969 _
597423490929302771479 .
626420018740128509615165494826444221f302037178623 _
509019111660653946049 .
This factorization was found using the Number Field Sieve (NFS) factoring
algorithm. and beats the 130-digit record that was set in April 1996. also with
the help of NFS . The amount of computer time spent on this new 140-digit
NFS-record is prudently estimated to be equivalent to 2000 mips years . For
the old 130-digit NFS-record . this effort is estimated to be 1000 mips years
(To Riele [205]) . Even more recently (August 26 . 1999), Herman to Riele and
Stefania Cavallar et. al. successfully factored (again using NFS) the RSA-155 .
a number with 155 digits and 512 bits_ which can be written as the product
of two 78-digit primes :

364
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
365
1026395928297411057720541965739916759007165678080 _
38066803341933521790711307779,
11 a = C` ,, mod NB.
(3 .63)
10660348838016845482092722036001287867920795857598 _
9291522270608237193062808643 .
So. it follows from the above factorization results that
Corollary 3.3.1 . The composite number (i .e . . the modulus) N used in the
RSA cryptosystem should have more than 155 decimal digits .
Exercise 3 .3 .6 . Below is an encrypted message (consisting of two blocks Cr
arid C2):
4660 4906 4350 6009 6392 3911 2238 7112
0237 3603 9163 4700 8276 8243 4103 8329
6685 0734 6202 7217 9820 0029 7925 0670
8833 7283 5678 0453 2383 8911 4071 9579
6506 4096 9385 1106 9741 5283 1334 2475
3966 4897 8551 7358 1383 6777 9635 0373
8147 2092 8779 3861 7878 7818 9741 5743
9185 7183 6081 9612 4160 0934 3883 0158
The public key used to encrypt the message is (e, N), where e = 9137 and N
is the following RSA-129 :
1143816257578888676692357799761466120102182967212 _
4236256256184293570693524573389783059712356395870 _
5058989075147599290026879543541 .
Decrypt the message. (Note that in the encryption process if gcd( ,, N)
1
for i = 1, 2, some dummy letter may be added to the end of M, to mak e
gcd(AL,, A) = 1 . )
Let us now consider a more general and more realistic case of secur e
communications in a computer network with n nodes . It is apparent that
there are
2
= rr(n — 1)/ 2
ways of communicating between two nodes in the network. Suppose one of the
nodes (users). say. Alice (A) . wants to send a secure message M to another
node, say. Bob (B), or vice versa.. Then A uses B's encryption key e B to
encrypt her message _ll, r
C a
MYB mod NB
(3.62)
and sends the encrypted message C to B ; on receiving A's message MA , B
uses his own decryption key dB to decrypt A 's message C :
Since only B has the decryption key
dB . only B (at least from a theoretica l
point of view) can recover the original message. B can of course send a secur e
message M to A in a similar way . Figure 3 .10 shows diagrammatically the
idea of secure communication between any two parties . say, for example, Alice
and Bob .
Public and insecure
channel
A better example of a trap-door one-way function of the form used in th e
RSA cryptosystem would use Carmichael's A-function rather than Euler' s
6-function . and is as follows :
y = f (x) - x~ (mod N)
(3 .64)
MB = Cif,' mod NA
= ill'L'
AA
B's Message M B
Alice (e .u, NA , d ;r, e n
Decryption
B's Message M B
Bob (CB, NB, dB, eA, N A )
Message AI B
A's Message MA
A's Message M A
= 1I`(B rued N B
=C B mod AB
Public and insecure
channe l
Figure 3 .10. The RSA secure communications between two partie s
mess
Encryption

366
3. Applied Number Theory in Computing/Cryptography
where
N = pq
(v and q are two large primes) ,
k > 1, gcd(k,A) = 1 .
(3.65)
A(A)=lcm(p-1 . q
1.)=g'd(1 11(gqi l).
We assume that k and N are publicly known but p,q and .A(N) are not. The
inverse function of f (.r) is defined by
x = f -' (y) - Jk' (mod N) with
kk' = 1 (mod A) .
(3 .66)
To show it works. we see
r -
yk = (x t )k - xkk.
X(N)+r
(2.A(A))'
= 1 n' . :r (by Carmichael's theorem)
It should be easy to compute f-r (y) = yk' (mod N) if k 	 is known, provided
that f-1 (y) exists (note that
,f -1 (y) may not exist) . The assumption un-
derlying the RSA cryptosystem is that it is hard to compute f- ' (y) without
knowing k'. However, the knowledge of p . q or A(N) makes it easy to compute
k	 .
Example 3 .3 .9 . Suppose we wish to encrypt the plaintext messag e
NATURAL NUMBERS ARE MADE BY GOD .
We first translate all the letters in the message into their numerical equiv-
alents as in Table 3 .4. Then we split the message into, for example . four
message blocks, each with 15 digits as follows :
(140020211801120. 014211302051800. 011805001301040. 500022500071504) .
and perform the following computation steps :
(1) Select two primes p and q, compute N = pq and A(N) :
p = 440334654777631 .
q = 14529.514355811 1
= pq = 6397848687952714385883141504 1
A(N) = 710872076439183980322589770 .
(2) Determine the keys / and k' : we try to factorize m .y(_l") + 1 for rn. =
1.2.3 . - - - until we find a 'good' factorization that can be used to obtai n
suitable k- and k 	 :
3.3 Crvptograp
id Information Security
367
A(N) + 1 = 1193 . 2990957 . 209791523
17107 . 5551 1
2A(N) + 1 = 47 - 131 . 199 . 3322357 . 1716499 . 203474209
3A(N) + 1 = 674683 - 1696366781 . 297801601 •625 7
4A(N) + 1 = 17
53 - 5605331 . 56302203521157535 1
5A(V) + 1 = 17450633
6A(N) + 1 = 12610.58128567 . 49864411 . 2293 . 29.581
7.\(N) + 1 = 19 . 261900238688120413803059389
8A(N) + 1 = 15037114930441 . 37819599290292 1
9A(N) + 1 = 11 . 13200581 . 8097845885549501 . 5441
10A(N) + 1 = 710872076439183980322.5897701
11A(N) + 1 = 2131418173 . 7417510211 . 49460365 7
12A(N) + 1 = 4425033337657 . 192777415814611 3
13A(N) + 1 = 23 . 6796296973884340591 5912002 7
14A(N) + 1 = 14785772846857861 67309359972 1
15A(N) + 1 = 500807 . 647357777401277 . 17579 . 1871 .
Suppose now we wish to use the 15th factorization 15A(N) + 1 to obtai n
(k,k') = (17579 ; 606580644324919489438469)
such that kk' = 1+ 15A(N) .
(3) Encrypt the message x
xk, mod N = p (using the fast modular expo-
nentiation method. for example. Algorithm 2 .1.1) :
140020211801120' 579 mod N = 6037953736664750882604272617 7
014211302051800 '7579 mod N = 4721546406798 749743356849848 5
011805001301040 1709 mod0 2099932757339755014893508551 6
500022500071504 17379 mod 0 377469630386397.59803119392704.
(4) Decrypt the message y H yk' mod N =
xk'1 . mod N = x (again using ,
for example. Algorithm 2.1.1) :
60379537366647508826042726177 k' mod N = 140020211801120
47215464067987497433568498485 1' mod N = 014211302051800
20999327573397550148935085516 1' mod N = 01180.5001301040
37746963038639759803119392704 1" mod N = 500022500071504
where k ' = 606580644324919489438469 .
Remark 3.3.6. Compared with the conventional cryptosystens such as th e
Data Encryption Standard (DES), the RSA system is very slow . For exam-
ple . the DES . when implemented with special-purpose chips . can be run at
speeds of tens of millions of bits per second . and even in software on modes t
size machines can encrypt on the order of 10' bits per second, whereas th e
RSA system. when implemented with the best possible special purpose chips ,
can only encrypt at the rate of 10' or 2 . 101 bits per second, and software
implementations are limited to something on the order of 10 2 bits per second .
Thus, the RSA system is about 100 to 1000 times slower than conventiona l
cryptosystems .

368
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
369
Now we are in a position to give a brief discussion of the existence of th e
inverse function f'1 (y) defined in (3.66) for all y . Let us first introduce a
useful result (Riesel [207]) :
Theorem 3.3.1. If N is a product of distinct primes, then for all a .
= a (mod N) .
(3.67)
Note that if N contains multiple prime factors, then (3.67) need no longer
be true : say, for example, let N = 12 = 22 - 3 . then 9'0-2)+1 = 93 - 9 (mod
12), but 10ar12)+r = 103 = 4 $ 10 (mod 12). Now, let k and N have been
chosen suitably as follows :
N = pq,
with p . q distinct primes
(3.68)
a"' = a (mod N), for all a .
(3.69)
Then, by Theorem 3.3.1 . the inverse function f (y) . defined in (3.66) . exists
for all y . It follows immediately from (3 .67) that
ea(N)±1 = a (mod N)
(3.70)
which is exactly the form needed in a RSA c ryptosystem . For an arbitrar y
integer N and m > 1, a necessary and sufficient condition for (3.70) to have
a solution a is that (private communications with William Freeman )
gcd(a2 . N) ( a,
(3.71)
or equivalently.
gcd(a, N/d) = 1,
where d = gcd(a, N). (3.72)
More generally (private communications with Peter Pleasants and Car l
(3.73)
(3.74 )
or equivalently,
gcd(a . N/d) = 1 .
where d = gcd(at', N) .
(3.75 )
The proof for the more general case is as follows: Let p be prime and p"
1 N .
Let 3 be such that tip
( a. We assume that p
N, that is a > O . There are
three cases :
(1) ;3 = 0 : we have a"za(N)+a, - a x (mod p"), by Eider 's theorem .
(2) 0 < k3 < a: we have a c
ak (mod p") for all t > k . obviously.
(3) k;3 > a : we have a c - a d (mod pa ) for all t > k . obviously .
We conclude that a "'''
- ak (mod N) if and only if we are never in th e
second case for all primes p ( N. Never being in the second case is equivalen t
to the condition gcd(ak+' . N)
ak
Now let us return to the construction of a good trapdoor function (Brent
[37]) used in RSA :
Algorithm 3 .3 .1 (Construction of trapdoor functions) . This algo-
rithm constructs the trapdoor function and generates both the public and th e
secret keys suitable for RSA cryptography :
[1] Use Algorithm 3 .3 .3 or Algorithm 3 .3.2 to find two large primes p and q ,
each with at least 100 digits such that :
[1-1]
1p — ql is large ;
[1-2] p - -1 (mod 12), q - -1 (mod 12) ;
[1-3] The following values of 1 , p" , q' and q" are all primes :
p'=(p—1)/2 ,
p" = (p + 1)/12 ,
q' = (q — 1)/2 ,
q" = (q + 1)/12 .
[2] Compute N = pq and A = 2p'q' .
[3] Choose a random integer k relatively prime to A such that k — 1 is not a
multiple of p' or q' .
[4] Apply the extended Euclidean algorithm to k and A to find k' and A' such
that 0 < k' < A and
kk' + AA' = 1 .
[5] Destroy all evidence of p, q, A and A ' .
[6] Make (k, N) public but keep k' secret .
It is clear that the most important task in the construction of RSA cryp-
tosystelns is to find two large primes . say each with at least 100 digits . An
algorithm for finding two 100 digit primes can be described as follows :
Algorithm 3.3 .2 (Large prime generation) . This algorithm generates
prime numbers with 100 digits ; it can be modified to generate any length of
the required prime numbers :
[1] (Initialization) Randomly generate an odd integer n with say, for example ,
100 digits ;
Pomerance). a necessary and sufficient condition for
a"aacN)+z ak (mod N)
gcd(ati+' , N)
a k

370
3. Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
371
[2] (Primality Testing – Probabilistic Method) Use a combination of the Miller –
Rabin test and a Lucas test to determine if a is a probable prime . If it is ,
goto Step [3], else goto Step [1] to get another 100-digit odd integer .
[3] (Primality Proving – Elliptic Curve Method) Use the elliptic curve metho d
to verify whether or not a is indeed a prime . If it is, then report that a is
prime, and save it for later use ; or otherwise, goto Step [1] to get anothe r
100-digit odd integer .
[4] (done?) If you need more primes, goto Step [1], else terminate the algorithm .
How many primes with 100 digits do we have? By C hebyshev's inequalit y
(1.167), if N is large, then
r
0.92129 
< 70 1) < 1 .1056X  
(3.76)
In \`
In N
Hence
99
9 9
0 .92129 
10 
< 7r(10 99) < 1 .1056 10'
1n 1099
1n 1090 '
10ioo
10 10 0
0 .92129 
< 7r(10 100 ) < 1 .1056 
In 10 100
1n10 ioo
The difference 7r(10 100) - 7r(1099 ) will give the number of primes with exactly
100 digits, we have
3 .596958942 . 1017 <
( 10 100 ) –
(1090) < 4.076949099 . 10 97
The above algorithm for large prime generation depends on primality- test-
ing and proving. However, there are methods which do not rely on primalit y
testing and proving. One such method is based on Pocklington's theore m
(Theorem 2.2 .19), that can automatically lead to primes_ say with 100 dig-
its (Ribenboim [199]) . We re-state the theorem in a slightly different way as
follows :
Theorem 3.3.2. Let p be an odd prime, k a natural number such that p
does not divide k and 1 <
k < 2(p + 1) and let N = 2kp + 1 . Then the
following conditions are equivalent :
(1) N is prime .
(2) There exists a natural number a. 2 < a < \", such that
akP - -1 (mod N), and
(3.77 )
gcd(a± + 1 . N) = 1 .
(3.78)
Algorithm 3 .3 .3 (Large prime number generation) . This algorithm ,
based on Theorem 3.3.2, generates large prime numbers without the use o f
primality testing :
[1]Choose, for example, a prime p i with d t = 5 digits. Find k l < 2(p i +1) such
that p2 = 2k 1 p i + 1 has d2 = 2d1 = 10 digits or d 2 = 2d 1 – 1 = 9 digits
and there exists a t < P2 satisfying the conditions a' 1" _ -1 (mod p 2) and
gcd(ai" + 1,12 2 ) = 1 . By Pocklington's Theorem, p2 is prime .
[2] Repeat the same procedure starting from p2 to obtain the primes p3 , pa . •
In order to produce a prime with 100 digits, the process must be iterate d
five times. In the last step, k, should be chosen so that 2k ;p ;; + 1 has 100
digits .
As pointed out in IIibenbohn [199], for all practical purposes, the abov e
algorithm for producing primes of a given size will run in polynomial time .
even though this has not yet been supported by a proof .
According to the Prime Number Theorem, the probability that a ran-
domly chosen integer in [1 . N] is prime is ' 1/1n N . Thus, the expected
number of random trials required to find p (or p' , or p" ; assume that p,
p', and p" are independent) is conjectured to he 0 ((log N) 3) . Based on this
assumption. the expected time required to construct the above one-way trap-
door function is 0 ((log \') e ) .
Finally, in this subsection . we shall give a brief account of some possible
attacks on the RSA cryptosystem . We restrict ourselves to the simplified
version of RSA system . Let N, the RSA modulus, be the product of two
primes p and q . Let also e and d be two positive integers satisfying ed
1 (mod 6(N)) . where d(N) = (p – 1) (q – 1) is the order of the multiplicativ e
group (/Z/NZ)* . Recall that the RSA system works as follows :
C AP I (mod N)
M Cd (mod N)
where (N. e) is the public key for encryption, and (N, d) the private key
for decryption. From an cryptanalytic point of view we would like to know
that given the triple (N, e, C), how hard (or how many ways) an enem y
cryptanalyst can break the RSA system . In what follows, we shall presen t
some possible ways of cracking the RSA scheme .
(1) Factoring N. The most obvious way of breaking the RSA system is t o
factor N . since if an enemy cryptanalyst could factor N . then he could
determine 6(N) (p – 1)(q – 1) and hence the private key d . But this
is not easy. since integer factorization is a computationally intractable
problem .
(2) Computing o(N) without factoring _N . It is also obvious that if an enem y
cryptanalyst could compute o(N) then he could break the system b y
computing d as the multiplicative inverse of e modulo o(N) . However .
the knowledge of 6(N) can lead to an easy way of factoring N, since

372
3 . Applied Number Theory in Colnputing~Crvptograph~
3.3 Cryptography and Information Security
373
_as_
p+q=n–b(_'V)+1.
(p – q)2 = (p + q) 2 – 4n ,
1
p= 2 [(p+q)+(p–q)] .
1
q = 2 [(p + q) – (p– q)] .
Thus, breaking the RSA system by computing o(N) is no easier than
breaking the system by factoring N .
(3) Determining d without factoring n or computing cp(N) . If N is large and
d is chosen from a large set . then a cryptanalyst should not be able to
determine d any easier than he can factor N . Again, a knowledge of d
enables N to be factored, since once d is known, ed – 1 (a multiple of
O(N)) can be calculated : N can be factored using any multiple of 6(N) .
(4) Computing the et ' root of C modulo N . Clearly, the RSA decryption
process is just the computation of the ect' root of C modulo N. That is .
the decryption problem is just the root finding problem . It is evident that
in the following congruence
C - M' (mod N) ,
once (N, e, C) is given, we could try substituting M = 0, 1, 2, - . until a
correct M is found. In theory, it is possible to enumerate all elements o f
(Z/NZ)*, since (Z/NZ)* is a finite set. but in practice, it is impossibl e
when N is large. However, if ¢(N) is known, then we can compute th e
eh root of C modulo N fairly easily (see Algorithm 2 .4.8 in Chapter 2) .
So, all the above obvious methods of breaking the RSA system are closel y
related to the integer factorization problem. In fact, Rivest . Shamir and Adle-
man [209] conjectured that
Conjecture 3.3.1 (RSA conjecture) . Any method of breaking the RS A
crvptosystem must be as difficult as factoring .
There are some other possible attacks on the RSA crvptosystem whic h
include:
(1) Wiener's attack [253] on the short RSA private-key . It is important tha t
the private-key d should be large (nearly as many bits as the modulu s
'fir) ; otherwise. there is an attack due to Wiener and based on propertie s
of continued fractions, that can find the private-key d in time polynomial
in the length of the modulus N . and hence decrypt the message .
(2) Iterated encryption or fixed-point attack (Meijer [154] and Pinch [184]) :
Suppose c has order r in the multiplicative group modulo .A(N) . Then
e' - 1 (mod .N(\`)), so 1I° ' _ .lI (mod N). This is just the rth iterate
of the encryption of M . So we must ensure that r is large .
It is interesting to note that the attacks discovered so far mainly illustrate
the pitfalls to be avoided when implementing RSA . RSA will be still secure if
the parameters such as p . q. e . and d are properly chosen. Readers who wis h
to know more information about the attacks on the RSA cryptosystem are
suggested to consult Boneh's recent paper Twenty Years of Attacks on th e
RSA Cryptosystern" [30]. as well as an earlier paper by Rivest [208] .
3.3.7 Quadratic Residuosity Cryptosystems
The RSA crvptosystem discussed in the previous subsection is deterministic
in the sense that under a fixed public-key, a particular plaintext 11 is alway s
encrypted to the same ciphertext C . Some of the drawbacks of a deterministi c
scheme are :
(1) It is not secure for all probability distributions of the message space . For
example, in RSA encryption, the messages 0 and 1 always get encrypted
to themselves. and hence are easy to detect .
(2) It is easy to obtain some partial information of the secret key (p, q)
from the public modulus n (assume that n = pq) . For example. when
the least-significant digit of n, is 3, then it is easy to obtain the partia l
information that the least-significant digits of p and q are either 1 and 3
or 7 and 9, as indicated as follows :
183=3 . 61
253=1123
203=7 . 29
303=3 . 101
213=3 . 71
323=1719 .
(3) It is sometimes easy to compute partial information about the plaintex t
M from the ciphertext C. For example, given (C, e. n), the Jacobi symbol
of 1I over n can be easily deduced from C :
( a )
( la )~ n i
(4) It is easy to detect when the same message is sent twice .
Probabilistic encryption, or randomized encryption. however. utilizes ran-
domness to attain a strong level of security, namely . the polynomial security
and semantic security . defined as follows :
Definition 3 .3.2 . A public-key encryption scheme is said to be polynomially
secure if no passive adversary can. in expected polynomial time . select two
plaintexts Mr and M2 and then correctly distinguish between encryptions o f
Dh and Al2 with probability significantly greater that 1/2.

374
3 . Applied Number Theory iu Computing/Cryptography
3.3 Cryptography and Information Security
375
Definition 3 .3 .3 . A public-key encryption scheme is said to be semantically
secure if. for all probability distributions over the message space, whatever a
passive adversary can compute in expected polynomial time about the plain -
text given the ciphertext, it can also be computed in expected polynomia l
time without the ciphertext .
Intuitively, a public-key encryption scheme is sernantically secure if the ci-
phertext does not leak any partial information whatsoever about the plaintex t
that can be computed in expected polynomial time . That is. given (C . e, n), it
should be intractable to recover any information about H . Clearly. a public-
key encryption scheme is semantically secure if and only if it is polynomiall y
secure .
In this subsection. we shall introduce a semantically secure cryptosys-
tem based on the quadratic residnosity problem . Recall that an integer a is
a. quadratic residue modulo to denoted by a E
if gcd(a. n) =
1 and
there exists a solution .r to the congruence :r,'-
E a (mod n) . otherwise a
is a quadratic nonresidue modulo
no denoted by a E Q,r. The Quadrati c
Residuosity Problem may be stated as :
Given positive integers a and ii, decide whether or not a E
It is believed that solving QRP is equivalent to computing the prime factor-
ization of a. so it is computationally infeasible . We have seen in Subsection
1 .6.6 of Chapter 1 that if n is prime then
a E Q„
(
a
) = 1 .
(3.79)
n
and if n is composite. then
a E (2,, 
>
( a ) = 1
(3.80)
but
a
a E
= 1 .
however
a
aEQ "
<
— =
1 .
(3.82)
n
Let. J,x = {a E (Z/nZ)" : ~ nl = 1}, then Q,, = J„ — Q,, . Thus, Q„ is
the set. of all pseudosquares modulo n : it contains those elements of .7„ that
do not belong to Q,,, . Readers may wish to compare this result to Fermat ' s
little theorem discussed in Subsection 1 .6.3 of Chapter 1 namely (assuming
gcd(a . n) = 1).
(3.83)
n is prime
a"-I
(mod n) .
(3.84)
n is composite < 
a -n $ 1 (mod n) .
(3.85)
The Quadratic Residuosity Problem can then be further restricted to :
Given a composite n and an integer a E •I,,, decide whether or not
a E
For example . when n = 21. we have J>>
{1 ..4.5.16.17 .20} and Qyi =
{1.4.16}, thus Qai = {5,17.20) . So . the QRP problem for n = 21 is actu-
ally to distinguish squares {L4 .161 from pseudosquares {5 . 17.20} . The only
method we know for distinguishing squares from pseudosquares is to facto r
n : since integer factorization is computationally infeasible, the QRP problem
is computationally infeasible . In what follows, we shall present a cryptosys-
tem whose security is based on the infeasibility of the Quadratic Residuosit y
Problem : it was first proposed by Goldwasser and Micah [88] in 1984, unde r
the term probabilistic encryption .
Algorithm 3.3.4 (Quadratic residuosity based cryptography) . This
algorithm uses the randomized method to encrypt messages and is based on th e
quadratic residuosity problem (QRP) . The algorithm divides into three parts :
key generation, message encryption and decryption .
[1] Key generation : Both Alice and Bob should do the following to generat e
their public and secret keys :
[1-1] Select two large distinct primes p and q, each with roughly the sam e
size, say, each with 3 bits .
[1-2] Compute n = pq .
[1-3] Select a y E Z/nZ, such that y E Q„ and (1J ~ = 1 . (y is thus a
n
pseudosquare modulo n.) .
[1-4] Make (n, y) public, but keep (p, q) secret .
[2] Encryption : To send a message to Alice, Bob should do the following :
[2-1] Obtain Alice's public-key (n, y) .
[2-2] Represent the message in as a binary string m. = m> mz . . - n7>,, of
length k .
[2-3] For z from 1 to k d o
[i] Choose at random an x E (Z/nZy and call it :r7> .
[ii]Compute e, :
nod to
if ma, = 0 ,
mod n . if m> = 1 .
where r.s . and r.p.s. represent random square and random pseu-
dosquare, respectively.
(3 .8
n is prime 
>
a"'
1 (mod a) .
but
a
y.r
(r
(r
(3.86)
5.) ,
however

376
3. Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
377
[iii] Send the k-tuple c (cl . C2, • •
.0 k) to Alice . (Note first that each
c, is in integer with 1 < c, < n . Note also that since
11 is a 23-bit
integer, it is clear that the ciphertext c is a much longer string tha n
the original plaintext m .)
[3] Decryption : To decrypt Bob's message, Alice should do the following :
[3-1] For i from 1 to k d o
[i] Evaluate the Legendre symbols :
[1-2] Alice keeps the prime factorization (3,7) of 21 as a secret: since
(3.7) will be used a private decryption key. (Of course. here we just
show an example ; in practice . the prime factors p and q should be at
last 100 digits . )
[2] Decryption :
[2-1] Bob converts his plaintext HELP ME to the binary stream M =
fi.[ 1n2
. . . 17235 :
00111 00100 01011 01111 11010 01100 00100
c
"I)
(3.87)
e;' =— (`i )
q
[ii] Compute m
J 0,
if
= 1
rz =
(3.88)
1,
if otherwise .
That is,
112, = 0 if c, E Q,,, otherwise . n2, = 1 . otherwise, set
m, = 1 .
[3-2] Finally, get the decrypted message m = rn 1 m2 • • • mp, .
Remark 3 .3 .7 . The above encryption scheme has the following interesting
features :
(1) The encryption is random in the sense that the same bit is transformed
into different strings depending on the choice of the random number x .
For this reason, it is called probabilistic (or randomized) encryption .
(2) Each bit is encrypted as an integer modulo n, and hence is transforme d
into a 23-bit string .
(3) It is semantically secure against any threat from a poly nomially bounde d
attacker, provided that the QRP is hard .
Exercise 3.3.7. Show that Algorithm 3 .3.4 takes Q(3. ) time to encrypt
each bit and ()(33) time to decrypt each bit .
Example 3.3.10 . In what follows we shall give an example of how Bo b
can send the message "HELP ME" to Alice using the above cryptographi c
method . We use the binary equivalents of letters as defined in Table 3 .5 . Now
both Alice and Bob proceed as follows:
[1] Key Generation :
[1-1] Alice chooses (n . y) = (21 . 17) as a public key, where n = 21 = 3 . 7
is a composite. and y = 17 E ('22i (since 17 E J21 but 17 V Q21 ) . so
that Bob can use the public key to encrypt his message and send i t
to Alice.
(To save space, we only consider how to encrypt and decrypt 1n? = 0
and m3 = 1: readers are suggested to encrypt and decrypt the whole
binary stream) .
[2-2] Bob randomly chooses integers x, E (Z/217G)*. Suppose he chooses
xz = 10 and x 3 = 19 which are elements of (7Z/21Z)* .
[2-3] Bob computes the encrypted message C = cr C2 . . . f2 from the
plaintext DI
mrm 2 --mx using Equation (3 .86). To get, for ex-
ample, cz and c3, Bob performs:
cz = x mod 21 = 102 mod 21 = 16,
since mz = O .
c3 =y•x]mod21=17-19 2 mod21=5 .
since m 3 =1 .
(Note that each c, is an integer reduced to 21, i .e., m, is a bit, but
its corresponding c, is not a bit but an integer, which is a string o f
bits, determined by Table 3.5 . )
[2-4] Bob then sends c2 and c3 along with all other c,'s to Alice .
[3] Decryption: To decrypt Bob's message, Alice evaluates the Legendr e
symbols I — and I
q
I . Since Alice knows the prime factorization (p . q)
P
of n, it should be easy for her to evaluate these Legendre symbols . For
example, for c2 and c 3 , Alice performs :
Table 3 .5 . The binary equivalents of letter s
Letter
Binary Code
Letter
Binary Code
Letter
Binar
Code
A
00000
B
00001
C
00010
D
00011
E
00100
F
0010 1
G
00110
H
00111
I
01000
J
01001
K
01010
L
0101 1
M
01100
N
01101
O
01110
P
01111
Q
10000
B
10001
S
10010
T
10011
II
10100
V
10101
W
10110
X
10111
Y
11000
Z
11001
U
11010

378
3 . Applied Number Theory in Computing/Cryptography
3 .3 Cryptography and Information Secu
379
[3-1] Evaluates the Legendre
i s
3.3.8 Elliptic Curve Public-Key Cryptosystems
=(3)—(3)—1
.
= ( 5) = ( 2
= —l.
3
3
c,
symbols
4
4)
(16) =
C c ~ =
(- ) =-1 .
q
[3-3] Further by Equation (3 .88) . Alice gets
rn 2 = 0,
since
= e .'; = 1 .
m3 = 1,
since 63 = _ -1 .
Remark 3.3.8. The scheme introduced above is a good extension of the
public-key idea, but encrypts messages bit by bit . It is completely secur e
with respect to semantic security as well as bit security'' . However. a major
disadvantage of the scheme is the message expansion by a factor of log n bit .
To improve the efficiency of the scheme ; Blum and Goldwasser [28] propose d
another randomized encryption scheme. in which the ciphertext is only longe r
than the plainext by a constant number of bits : this scheme is comparable t o
the RSA scheme . both in terms of speed and message expansion .
Exercise 3.3.8. RSA encryption scheme is deterministic and not semanti-
cally secure, but it can be made semantically secure by adding randomness t o
the encryption process (Bellare and Rogayyay. [22]) . Develop an RSA based
probabilistic (randomized) encryption scheme that is semantically secure .
Several other cryptographic schemes . including digital signature scheme s
and authentication encryption schemes are based on the quadratic residuosit y
problem (QRP): interested readers are referred to . for example, Chen [47] and
Nrang [175] for some recent developments and applications of the quadrati c
residuosity based cryptosystems .
'' Bit. security is a special case of semantic security- . Informally. bit security is
concerned with not only that the whole message is not recoverable but also tha t
individual bits of the message are not recoverable. The main drawback of th e
scheme is that the encrypted message is much longer than its original plaintext .
We have discussed some novel applications of elliptic curves in primality test-
ing and integer factorization in Chapter 2. In this subsection . we shall intro-
duce one more novel application of elliptic curves in public Key cryptography .
More specifically. we shall introduce elliptic curve analogues of several well-
known public key ct y ptosystems . including the Diffie- Hellman key exchange
system and the RSA cryptos}stem .
(I) Brief History of Elliptic Curve Cryptography . Elliptic curves hav e
been extensively studied by number theorists for more than one hundre d
years, only for their mathematical beauty, not for their applications . However ,
in the late 1980s and early 1990s many important applications of ellipti c
curves in both mathematics and computer science were discovered, notably
applications of ellipticcurves in primality testing (see Kilian [120] and Atkin
and Morain [12]) and integer factorization (see Lenstra [1 .40]), both discusse d
in Chapter 2 . Applications of elliptic curves in cryptography were not found
until the following two seminal papers were published :
(1) Victor Miller, "Uses of Elliptic Curves in Cryptography" , 1986. (See
[163] . )
(2) Neal Koblitz°, "Elliptic Curve Cryptosystems" . 1987. (See [126] . )
Since then, elliptic curves have been studied extensively for the purpose o f
cryptography, and many practically more secure encryption and digital sig-
nature schemes have been developed based on elliptic curves . Now ellipti c
curve cryptography (ECC) is a standard term in the field and there is a text -
book by Menezes [155] that is solely devoted to elliptic curve cryptography .
There is even a computer company in Canada, called Certicom . which is a
leading provider of cryptographic technology based on elliptic curves . In the
subsections that follow, we shall discuss the basic ideas and computationa l
methods of elliptic curve cryptography.
Neal Noblitz received his BSc degree in mathematics from Harvard
University in 1969 . and his PhD in arithmetic algebraic geometr y
from Princeton in 1974 . From 1979 to the present, he has been a t
the University of Washington in Seattle. where he is now a pro-
fessor in mathematics. In recent years ins research interests hav e
been centered around the applications of number theory- in cryp -
tography=. He has published a. couple of books in related to number
theory and cryptography. two of there are as follows : A Course
in \umber Theory and Cryptography [128], and Algebraic Aspects of Cryptogra-
phv [129] . His other interests include pre university math education . mathematical
development in the Third World, and snorkeling. (Photo by courtesy of Springer-
Verlag . )
[3-2] Evaluates the Legends

380
3 . Appl ied Number Theory in Computing/Cryptography
3 .3 Cryptography and Information Security
381
(II) Precomputations of Elliptic Curve Cryptography. To implement
elliptic curve cryptography, we need to do the following precomputations :
[1] Embed Messages on Elliptic Curves: Our aim here is to do cryptography
with elliptic curve groups in place of Fq . More specifically, we wish to
embed plaintext messages as points on an elliptic curve defined over a
finite field Fq , with q = pr and p E Primes. Let our message units m be
integers 0 < m < M . let also K be a large enough integer for us to be
satisfied with an error probability of 2 –^ when we attempt to embed a
plaintext message in . In practice, 30 < k, < 50 . Now let us take K = 30
and an elliptic curve E
:
,y'- = :r 3 + ax + b over Fq . Given a message
number rn, we compute a set of values for x :
{mK + j, j = O. 1.2. - } = {30m .. 30m + 1, 30m + 2,
. . . } (3 .89)
until we find 1;-3 + ax + b is a square modulo p . giving us a. point
(x . 3x3 + ax + b) on E . To convert a point (x . y) on E hack to a mes-
sage number m, we just compute m = [x/30J . Since x 3 + ax + b is a
square for approximately 50% of all x. there is only about a. 2–" prob-
ability that this method will fail to produce a point on E over Fq . In
what follows, we shall give a simple example of how to embed a . mes-
sage number by a point on an elliptic curve . Let E be y 2 = x3 + 3x ,
nr = 2174 and p = 4177 (in practice, we select p > 30m,) . Then we calcu -
late x = {30 . 2174 + j. j = 0, 1, 2, . . . } until x 3  3x is a square modul o
4177. We find that when j = 15 :
x =
302174+15
= 65235
x 3 +3x = (30 . 2174+15) 3 +3(302174+ 15)
= 277614407048580
1444 mod 4177
382
So we get the message point for rn = 2174 :
(x. V.r 3 + ax + b) = (65235.38) .
To convert the message point (65235.38) on E back to its original message
number m. we just compute
n = [65235/30J = [2174 .5] = 2174 .
[2]Multiply Points on Elliptic Curves over Fq : We have discussed the calcu-
lation of kP E E over Z/NZ . In elliptic curve public-key cryptography.
we are now interested in the calculation of kP E E over F,, . which can b e
done in 0(logk(logq) 3 ) bit operations by the repeated doubling method.
If we happen to know N, the number of points on our elliptic curve E
and if k > N, then the coordinates of AT on E can he computed in
0(log q) 1 bit operations [128] : recall that the number ~T of points on E
satisfies N < q+ 1+ 214 = 0(q) and can be computed by Rene Schoof s
algorithm in 0(logq) 8 bit operations .
[3] Compute Discrete Logarithms on Elliptic Curves : Let E be an elliptic
curve over Fq . and B a point on E . Then the discrete logarithm on E is the
problem: given a point P E E . find an integer x E 7L such that .rB = P if
such an integer x exists . It is likely that the discrete logarithm proble m
on elliptic curves over Fq is more intractable than the discrete logarith m
problem in Fq . It is this feature that makes cryptographic systems based
on elliptic curves even more secure than that based on the discrete log-
arithm problem. In the rest of this subsection, we shall discuss ellipti c
curve analogues for some of the important public key cryptosystems .
(III) Elliptic Curve Analogues of Some Public-Key Cryptosystems .
In what follows. we shall introduce elliptic curve analogues of four widely used
public-key cryptosystems, namely the Diffie–Hellman key exchange system .
the Massey Omura, the ElGamal and the RSA public-key cryptosystems .
(1) Analogue of the Difie–Hellman Key Exchange System :
[1]Alice and Bob publicly choose a finite field Fq with q = pr and p E Primes .
an elliptic curve E over Fq . and a random base point P E E such that P
generates a large subgroup of E, preferably of the same size as that of E
itself .
[2]To agree on a secret key, Alice and Bob choose two secret random integers
a and b . Alice computes aP E E and sends aP to Bob: Bob computes
bP E E and sends bP to Alice. Both aP and bP are. of course, public
but. a and b are not .
[3]Now both Alice and Bob compute the secret key abP E E .. and use it for
further secure communications .
There is no known fast way to compute abP if one only knows P . aP and
bP – this is the discrete logarithm problem on E .
(2) Analogue of the Massey–Omura Cryptosystem :
[1] Alice and Bob publicly choose an elliptic curve E over Fq with q large ,
and we suppose also that the number of points (denoted by fi) is publicl y
known.
[2]Alice chooses a secret pair of numbers (e i . (1n) such that daen = 1 ( mod
N). Similarly, Bob chooses ((ra, dn) .

382
3 . Applied Number Theory in Computing/Cryptography
3.3 Crvptogra
ry and Information Security
383
[3] If Alice wants to send a secret message-point P E E to Bob, the procedure
is as follows :
[3-1] Alice sends e;1P to Bob .
[3-2] Bob sends e Be4 P to Alice .
[3-3] Alice sends dae Be,4 P = eB P to Bob .
[3-4] Bob computes dBfB P = P .
Note that an eavesdropper would know e
1 P . eB e ,aP . and e BP. So if
he could sol ve the discrete logarithm problem on E, he could determine
C B
from the first two points and then compute dB = ef] 1 mod V and hence get
P = dB (eB P) .
(3) Analogue of the ElGamal Cryptosystem :
[1] Alice and Bob publicly choose an elliptic curve E over Fq with q = p'
and p E Primes, and a random base point P E E .
[2]Alice chooses a. random integer r,, and computes
1 .0P; Bob also choose s
a random integer rb and computes r b P .
[3] To send a message-point M to Bob . Alice chooses a random integer k
and sends the pair of points (kP, 3I + k(rtP)) .
[4] To read 1d. Bob computes
i + k(r 1 P) - re (kP) =
(3.90)
An eavesdropper who can solve the discrete logarithm problem on E can .
of course . determine rb from the publicly known information P and riP . But
as everybody knows . there is no efficient way to compute discrete logarithms ,
so the system is secure .
(4) Analogue of the RSA Cryptosystem :
R.SA, the most popular cry ptosystem in use, also has the following ellipti c
curve analogue :
[1] 'G = pq is a public key which is the product of the tR o large secret prime s
p and q .
[2] Choose two random integers a and b such that E
:
= .r'; + ax + b
defines an elliptic curve both mod p and mod q .
[3] To encrypt a message-point P, just perform eP mod V where e is the
public (encryption) key. To decrypt, one needs to know the number of
points on E modulo both p and q .
The above are some elliptic curve analogues of certain public key crvp-
tosv steins. It should be noted that almost every public-key crvptosystem ha s
an elliptic. curve analogue; it is of course possible to develop new elliptic curv e
cryptosystems which do not. rely on the existing cryptosystems .
Exercise 3 .3 .9 . Work back from the descriptions of the elliptic curve ana-
logues of the ElGamal and the Massey–Omura cryptosystems discusse d
above . to give complete algorithmic descriptions of the original ElGamal an d
the original Massey–Omura public-key cryptosystems .
(IV) Menezes-Vanstone Elliptic Curve
Cryptosystem. A serious
problem with the above mentioned elliptic curve cryptosystems is that, th e
plaintext message units in lie on the elliptic curve E . and there is no conve-
nient method known of deterministically generating such points on E. Fortu-
nately. Menezes17 and Vanstoneis had discovered a more efficient variation
[156] : in this variation which we shall describe below . the elliptic curve is
used for `"masking", and the plaintext and ciphertext pairs are allowed to b e
in 1F„ x s rather than on the elliptic curve .
[1] Preparation: Alice and Bob publicly choose an elliptic curve E over F,, ,
with p > 3 is prime and a random base point P E E(FI,) such that P
generates a large subgroup H of E(Fp ), preferably of the same size a s
that of E(Fp ) itself. Assume that randomly chosen k E ZIBI and a E N
are secret .
[2] Encryption : Suppose now Alice wants to sent messag e
m = (m i ,m 2) E (Z/pZ)* x (Z/p7Z)*
(3.91 )
to Bob. then she does the following :
[2-1] 3 = aP . where P and 3 are public .
17
Alfred .J. Menezes is a professor of mathematics in the Department
of' Cmnbinatorics and Optimization at the University of Water -
loo, where he teaches courses in cryptography, coding theory, finit e
fields. and discrete mathematics. He is actively involved in crypto -
graphic research, and consults on a regular basis for Certicom Corp . .
He completed the Bachelor of Mathematics and M .Math degrees in
1987 and 1989 respectively, and a Ph .D. in Mathematics from th e
University of Waterloo (Canada) in 1992 .
Scott A . Vanstone is one of the founders of Certicom . the first com -
pany to develop elliptic curve cryptography commercially . He devotes
mrch of his research to the efficient nnplementation of the ellipti c
curve cryptography for the provision of information security services
in hand-held computers. smart cards . wireless device s ; and integrated
circuits. A'anstone has published more than 150 research papers and
several hooks on topics such as cryptography, coding theory, finit e
fields, finite geometry; and combinatorial designs . Recently, he wa s
elected a Fellow of the Royal Society of Canada . t "anstone received a Ph.D . in
mathematics from the University of Waterloo in 1974 .

384
3 . Applied \lumber Theory in Comp
1g/Cryptography
3.3 Cryptography and Information Security
385
[2-2] (T ' Y2) = k3
[2-3] co = kP .
[2-4] cj _ yi n?) (mod p) for j = 1, 2 .
[2-5] Alice sends the encrypted message c of m to Bob :
c = (co .ci,(.z) .
(3.92)
[3] Decryption : Upon receiving Alice's encrypted message c, Bob calculate s
the following to recover rn :
[3-1] aco = (T ; tY2) .
[3-1] rn = (cr'.p a (mod p), c2y.,
(mod p)) .
Example 3.3.11 . The following is a nice example of Menezes Vanston e
crvptosystem, taken from [16 .5] .
[1] Key generation : Let E be the elliptic curve given by y 2 = a;3 + 4x + 4
over ]F13 , and P = (1 .3) be a point on E . Choose E(Fr 3 ) = H which is
cyclic of order 15, generated by P. Let also the private keys k = .5 and
a = 2. and the plaintext rn = (12 .7) = (mr, m2) .
[2]Encryption : Alice computes :
= aP = 2(1 .3) = (12.8)
(yr, y2) = k/3 = 5(12,8) = (10,11)
co = kP = .5(1 .3) = (10,2)
cr - yrmr = 10 . 2 E 3 (mod 13 )
c2= y2m2= 11 7- 12 (mod 13) .
Then Alice sends
c = (co, cr, c2 ) = ((10, 2).3, 12)
to Bob .
[3]Decryption: Upon receiving Alice's message, Bob computes :
aco = 2(10 .2) = (10.11) = (yr, y2)
rnu = cry[ r = 12 (mod 13)
in, = c2yz u = 7 (mod 13) .
Thus. Bob recovers the message in = (12. 7) .
We have introduced so far the most popular public-key cryptosystems ,
such as Diffie-Hellman-Merkle, RSA. Elliptic curve and probabilistic cryp-
tosystems. There are, of course. many other types of public-key crtiptosys-
tenis in use, such as Rabin . -11cEliece and Knapsack cryptosystems . Readers
who are interested in the cryptosystems which are not covered in this book
are suggested to consult Menezes et al . [157] .
3 .3 .9 Digital Signatures
The idea of public-key cryptography (suppose we are using the RSA public -
key scheme) can also be used to obtain digital signatures . Recall that in
public-key cryptography. we perform
C=E,„(11) .
where 111 is the message to be encrypted, for message encryption, an d
11=D,1,(C),
where C is the encrypted message needed to be decrypted .. for decryption. In
digital signatures. we perform the operations in exactly the opposite direction .
That is, we perform (see also Figure 3 .11)
S = Dd (31),
(3.95)
where ill is the message to be signed, for signature generation ,
M = Eek. (S),
(3.96)
where S is the signed message needed to be verified, for signature verification .
Suppose now Alice wishes to send Bob a. secure message as well as a digita l
Cryptanalyst/Enemy
Al'
Figure 3 .11. Digital signatures
signature. Alice first uses Bob 's public key to encrypt her message . and then ,
she uses her private key to encrypt her signature, and finally sends out her
(3.93)
(3 .94)
Public and also insecure
channel
Key source 1
Decryption key
(Private key)
Key- source 2
Encryption key
(Public key )
Signing
S=Dd,, (31)
lessage
Message
M
Al = E, ..( S)
Verificatio n

386
3 . Applied Number Theory in Computing/Crti ptogral
3.3 Cryptography and Information Security
387
Decryption of SB
Public and insecur e
channe l
SB = Ill" mod NB
TT "B = SI/' mod NB
Decryption of MB
Encryption of Su
TIB = CH { mod :1 , 1
B's Message RIB
and Signature SB
B's Message MB
j and Signature S B
-yB 
j1')i ' mod '.
Encryption of RIB
<
\Ie,sage
B 0 /Sign atm  
B
Alice (e .i .NA ,dA,C .N3
Bob (eB . NB,dB . co . NA )
Figure 3.12. Sending encrypted messages and signatures using the RSA sche n
(the encrypted message and the signature are two different texts)
A's Message AlA
and Signature SA
Encryption of RIA
A's Message 17,1
and Signature SA
Decryption of Rh
4 = S,A mod N a
Sa = 1I7,'' mod A A
Public and insecur e
channel
Decryptio
message and signature to Bob . At the other end. Bob first uses Alice's public
key to decrypt Alice's signature, and then uses his private key to decryp t
Alice's message . Figure 3.12 shows how A (Alice) and B (Bob) can send
secure message/signature to each other over the insecure channel .
Example 3.3.12 (Digital Signature) . To verify that the $100 offer in Ex-
ample 3 .3.8 actually carne from RSA, the following signature was added :
S = 167178611503808442460152713891683982454369010323583112178 _
350384469290626554487922371144905095786086556624965779748 _
40004057020373 .
It was encrypted by S = 11 .0 ( mod N) . where d is the secret key, as in Exam-
ple 3.3 .8. To decrypt the signature, we use ll7 = Si (mod N) by performing
the following procedure (also the same as in Example 3 .3.8) :
C
1
e = (10001100101111) 2
for i from 1 to 14 do
C C 2 mod N
ife[i]=0then C-C*xllmod N
print C
which gives the following decrypted text :
6091819200019151222051800230914190015140500082114 _
041805040004151212011819.
It translates to
FIRST SOLVER WINS ONE HUNDRED DOLLARS
Since this signature was encrypted by RSA's secret key, it cannot be forged
by an eavesdropper or even by R.SA people themselves .
In Example 3 .3 .12 . the signature is a different text from the message . and
usually is appended to the encrypted message . We can. of course directly sig n
the signature on the message. This can be done in the following way . Suppose
A (Alice) wants to send B (Bob) a signed message . Suppose also tha t
[1] Alice (A) has her own public and secret keys (e,.1 , NA; d 1) as well as B' s
public' key eB and NB from a public domain ;
[2] Bob (B) has his own public and secret keys (eB .NB ;dB) as well as A' s
public key- ea and N4 from a public domain .
To send a signed message from A to B :
[1] Alice uses B 's public key
CB and NB to encrypt her message 11 1 :
C .1 = 11 `,x" mod NB .
(3 .97)

388
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
389
[2] Alice signs the message using her own secret key
dA directly on the
encrypted message :
S4 = C `a a mod N 1 .
(3 .98)
and sends this signed message to B over the network.
Upon receiving As signed message.
[1] B uses A's public key c 1 to decrypt As signature :
C4 = S`,'{' mod N4 .
(3 .99)
[2] B further uses his own secret key dB to decrypt AS encrypted message:
11 4 = C ` " mod _\'B .
(3.100)
In this way. Bob can make sure that the message he has just received indee d
comes from A. since the signature of A's message is encrypted by A's ow n
secret key, which is only known to A . Once the message is sent out . A canno t
deny the message. Similarly. Bob can send a signed message to Alice . The
above process is shown in Figure 3.13 .
Example 3 .3 .13 (Digital Signature) . Suppose now Alice wants to send
Bob the signed message "Number Theory is the Queen of Mathematics" . The
process can be as follows :
[1] Suppose Alice has the following information at hand :
MA = 1421130205180020080515182500091900200805001721050514001 _
506001301200805130120090319
NA = 1807082088687404805951656164405905566278102516769401349_
1701270214500566625402440483873411275908123033717818879 _
66563182013214880557 (130 digits )
3968599945959745429016112616288378606757644911281006483 _
2555157243 . 45534498646735972188403686897274408864356301 _
26320506960099904459 9
c t = 261 7
dA = 9646517683975179648125577614348681987353875490740747744 _
710230985275797178884880163.711139144032242624779107574_
09230.50236448593109
and suppose Bob has the following information at hand :
NB = 1143816257578888676692357799761466120102182967212423625 _
6256184293570693524573389783059712356395870505898907514 _
7599290026879543 .541 (129 digits )
= 3490529510847650949147849619903898133417764638493387843 _
990820577 . 327691329932667095499619881908344614131776429 _
67992942539798288533
Public and insecur e
Decrypt signature
channe l
4 {
Signed Message
B
 V
Alice (CA,1VA,dA,eB,NB)
Bob (eB, dB, ea, NA)
A
B
Signed Message
As Message MA
I A's Message 1114
Encryption
A 's message 11A
I 
CA = 11i," mod NB
4 = C ` " mod NB
Sign atu e
Decryption
=
'A
mod NA
Public and insecure
channe l
Figure 3.13. Sending encrypted and signed messages using the RSA scheme (th e
signatures are directly made on the encrypted message )
MB = CB' mod NA
	
l
Ws Message MB
CB = 5l mod
1,
Encryption
B's Message AIB
B's message MB
CH = SB mod NB
SB = C
mod NB
Decsvptio
Signature
= Sa mod A'4
Decrypt signature

390
3. Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
391
CB= 9007
dB = 1066986143685780244428687713289201547807099066339378628 _
0122622449663106312591177447087334016859746230655396854 _
451327710905360609 5
[2] Alice first encrypts the message M4 using eB and
3
o get
Remark 3 .3 .9 . Suppose Bob is sending an encrypted message to Alice . Nor-
mally. the encrypted message consists of a number of blocks: one of the blocks
is Bob's signature. Alice can easily identify which block is the signature block.
since the ordinary decryption procedure for that block yields gibberish. In
practice. there are two ways for constructing Bob's encrypted signature (Den -
son [60]), depending on the values of the moduli n B and nA :
(1) If nA < nB, then
CA = MA" mod NB
n the following process :
SB = Ol d ' mod n 3)e,t mod ii A,
11B = (Sd=' mod nA)e" mod nB .
CA1
The inequality 71A < 17B ensures that the expression in the parentheses
is not too large to be encrypted by Alice's encryption key .
CB
(10001100101111) 2
for
from 1 to 14 do
(2) If nA < nB, then
CAC
modN13
if eB [i] = 1 then C4 +- CA
1114 mod NB
Save CA
[3]Alice then signs the message C1 using dA and NA to get S,t
C, `1
mod
NA via. the following process :
SA f
1
dA <— (10110010 - . .11010101) 2
for i from 1 to 429 do
SA
SA mod _y",r
if dA [1,i] = 1 then SA f- SA • Ca mod NA
Send SA
[4]Upon receiving Alice 's message, Bob first decrypts Alice 's signature usin g
CA and N .3 to get CA = Sir mod NA via the following process :
CA f
1
cA
(101000111001) 2
for i from 1 to 12 d o
Ca
CA mod NA
if eA[i] = 1 then CA f- CA
. SA mod NA
Save CA
[5] Bob then decrypts Alice's message using dB and NB to get 1la =
Cag mod NB via the following process :
17,a<- 1
dB := (1001110110 . -1001110 2
for i from 1 to 426 d o
114
;ll mod NB
if dB[i] = 0 then MA
1dA
. CA mod NH
print :11;1
SB = (11mod nA) d" mod nB ,
MB = (S" mod n B )d' mod it 4 .
The inequality nA > n B ensures that the expression in the parenthese s
is not too large to be encrypted by Bob's decryption key.
The above mentioned signature scheme is based on RSA cryptosystem .
Of course. a signature scheme can be based on other cryptosystem. In what
follows, we shall introduce a very influential signature scheme based of E1Ga-
mars cryptosystem [69] ; the security of such a signature scheme depends o n
the intractability of discrete logarithms over a finite field .
Algorithm 3.3.5 (ElGamal Signature Scheme) . This algorithm tries t o
generate digital signature S = (a . b) for message rn . Suppose that Alice wishes
to send a signed message to Bob .
[1] [ElGamal key generation] Alice does the following :
[1-1] Choose a prime p and two random integers g and x, such that bot h
g and J. are less than p .
[1-2] Compute y = g` (mod p) .
[1-3] Make (y.g.p) public (both g and p can be shared among a group of
users), but keep J. as a secret .
[2] [ElGamal signature generation] Alice does the following :
[2-1] Choose at random an integers k such that gcd(k, p — 1) = 1 .
[2-2] Compute
a =
(mod p),
(3.101 )
b k—r (in
xa) (mod (p — 1)).

392
3 . Applied Number Theory in Computing/Cryptograph
3.3 Cryptography and Information Security
393
Now Alice has generated the signature (a . b) . She must keep the random
integer, k, as secret .
[3] [ElGamal signature verification] To verify Alice's signature, Bob confirm s
that
°' (mod p) .
(3.102)
3 .3 .10 Digital Signature Standard (DSS)
In August 1991, the L .S. government's National Institute of Standards an d
Technology (KIST) proposed an algorithm for digital Signatures. The al-
gorithm is known as DSA . for Digital Signature Algorithm . The DSA has
become the L .S. Federal Information Processing Standard 186 (FIPS 186) .
It is called the Digital Signature Standard (DSS), and is the first digital
signature scheme recognized by any government . The role of DSA/DSS is ex-
pected to be analogous to that of the Data Encryption Standard (DES) . The
DSA/DSS is similar to a signature scheme proposed by Schnorr [220] ; it is
also similar to a signature scheme of ElGamal [69] . The DSA is intended fo r
use in electronic mail, electronic funds transfer, electronic data interchange .
software distribution, data storage, and other applications winch require dat a
integrity assurance and data authentication. The DSA/DSS consists of two
main processes :
(1) Signature generation (using the private key) ,
(2) Signature verification (using the public key) .
A one-way hash function is used in the signature generation process to obtain
a condensed version of data, called a message digest . The message digest is
then signed . The digital signature is sent to the intended receiver along with
the signed data (often called the message) . The receiver of the message and
the signature verifies the signature by using the sender's public key . The same
hash function must also be used in the verification process . In what follows ,
we shall give the formal specifications of the DSA/DSS .
Algorithm 3 .3 .6 (Digital Signature Algorithm. DSA) . This is a vari-
ation of ElGamal signature scheme . It generates a signature .9 = (r,$) for the
message rn .
[1] [DSA key generation] To generate the DSA key, the sender performs th e
following :
[1-1] Find a 512-bit prime p (which will be public) .
[1-2] Find a 160-bit prime q dividing evenly into p—1 (which will be public) .
[1-3] Generate an element g E
/pZ whose multiplicative order is q, i .e . ,
y9 - 1 (mod p) .
[1-4] Find a one-way function H mapping messages into 160-bit values .
[1-5] Choose a secret key x, with 0 < .r < q ,
[1-6] Choose a public key y, where y
fi t (mod p) .
Clearly, the secret :r is the discrete logarithm of y, modulo p, to the base y .
[2] [DSA Signature Generation] To sign the message rn, the sender produces hi s
signature as (r, s), by selecting a random integer k E 7L/qZ and computing
r = (yr (niod p)) (mod q),
(3 .103)
s - k
r (H(m) + xr) (mod q) .
[3] [DSA Signature Verification] To verify the signature (r .$) for the message
rn from the sender, the receiver first computes :
t - s—' (mod q),
(3.104)
and then accepts the signature as valid if the following congruence holds :
r
(gxlmhy''c (mod p))
(mod q) .
(3.105)
If the congruence (3 .105) does not hold, then the message either may hav e
been incorrectly signed, or may have been signed by an impostor . In thi s
case, the message is considered to be invalid .
There are, however . many responses solicited by the (US) Associatio n
of Computing Machinery (ACM) [45] . positive and negative, to the NIST' s
DSA . Some positive aspects of the DSA include :
(1) The U .S. government has finally recognized the utility and the useful-
ness of public-key cryptography. In fact, the DSA is the only signature
algorithm that has been publicly proposed by any government .
(2) The DSA is based on reasonable familiar number-theoretic concepts . and
it is especially useful to the financial services industry .
(3) Signatures in DSA are relatively short (only 320 bits), and the key
generation process can be performed very efficiently.
(4) When signing. the computation of r can be done even before the messag e
rn is available, in a "precolnputation " step .
Whilst some negative aspects of the DSA include :
(1) The DSA does not. include key exchanges. and cannot be used for key
distribution and encryption .

394
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
395
(2) The key size in DSA is too short : it is restricted to a 512-bit modulus
or key size . which is too short and should be increased to at least 102 4
bits.
(3) The DSA is not compatible with existing international standards : for
example, the international standards organizations such as ISO . CCITT
and SWIFT all have accepted the RSA as a standard .
Nevertheless, the DSA is the only one publicly known government digita l
signature standard.
\\e have already noted that almost every public key cryptosystem has a n
elliptic curve analogue . It should also be noted that digital signature scheme s
can also be represented by elliptic curves over
IF,, with q a prime power o r
over Z /nZ with n = pq and p, q E Primes. In exactly the same way as that fo r
public-key cryptography, several elliptic curve analogues of digital signatur e
schemes have already been proposed (see . for example, Meyer and Miiller
[160]). In what follows we shall describe an elliptic curve analogue of the
DSA/DSS. called ECDSA.
Algorithm 3.3.7 (Elliptic Curve Digital Signature Algorithm) . Let
E be an elliptic curve over F,, with p prime, and let P be a point of prime order
q (note that the q here is just a prime number, not a prime power) in E(IFp ) .
Suppose Alice wishes to send a signed message to Bob .
[1] [ECDSA key generation] Alice does the following :
[1-1] select a random integer
E [1 . q
1] ,
[1-2] compute Q = .rP ,
[1-3] make (2 public, but keep .r as a secret .
Now Alice has generated the public key Q and the private key r .
[2] [ECDSA signature generation] To sign a message rn, Alice does the following :
[2-1] select a random integer k E [1 . q
1] ,
[2-2] compute AT = (ri ,yjr), and r - rr (mod q) . If r = 0, go to ste p
[2-1] .
[2-3] compute k-t mod q .
[2-4] compute .s
k-r (H(nc) + xr) (mod q), where H(m) is the hash
value of the message. If s = 0, go to step [2-1] .
The signature for the message in is the pair of integers (r, s) .
[3] [ECDSA signature verification] To verify Alice's signature (ins) of the mes-
sage in, Bob should do the following :
[3-1] obtain an authenticated copy of Alice's public key (2 :
[3-2] verify that (r, s) are integers in the interval [1 .
q
1], computes
kP = (r i .yr), and r
xi (mod q) .
[3-3] compute in = s-r (mod q) and H(rn) .
[3-4] compute ur = H(m)w (mod q) and
112 = rzc (mod q) .
[3-5] compute u 1P + u2Q = (xo . yo) and v - r0 (mod q) .
[3-6] accept the signature if and only if m = r
Exercise 3.3.10 . Try to develop an elliptic curve analogue of an existin g
signature scheme that you are familiar with for obtaining and checking digita l
signatures .
3 .3 .11 Database Security
Databases pose a special challenge to the designer of secure information sys-
tems . Databases are meant to be shared . The sharing is often complex. In
many organizations, there are many "rules" concerning the access to different
fields (or parts) of a database . For example, the payroll department may hav e
access to the name, address and salary fields . while the insurance office may
have access to the health field of an individual . In this subsection. we shall
introduce a method for database protection: it encrypts the entire databas e
but the individual fields may be decrypted and read without affecting the
security of other fields in the database .
Let
D = (F1 . F2 
F)
(3.106)
where D is the database and each Fa is an individual file (or record) . As in
R.SA encryption, each file in D can be regarded as an integer . To encrypt
D . we first select n distinct primes m 1 .11 1 2 . . .
where m., >
for
i = 1, 2 
n. Then by solving the following system of congruences :
C Fr (mod rn i ) .
C
F, (mod m2).
(3.107)
C = F„ (mod m„), j
we get C. the encrypted text of D . According to the Chinese Remainder
Theorem, such a C always exists and can be found . Let
lI = 117170 2
31-[ = .ld/rn;,
(3.108)
e; = 7h4 [11I; 1 mod m.

396
3. Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
397
for i =
2, -
. , n. Then C can be obtained as follows :
Part I1 : Database Decryption . At this stage, the database user L-, is suppose d
to have access to the encrypted database C as well as to have the read-ke y
m,, so he performs the following operation :
C =
e .F (mod 11) .
0 < C < H .
(3.109)
The integers e1 .e2,''--e,, are used as the write-keys . To retrieve the i-th
file F, from the encrypted text C of D . we simply perform the following
operation :
F, - C (mod m;), 0 < F, < m, .
(3.110 )
The moduli mi , m2 .
.m,, are called the read-keys. Only people knowing
the read-key rn, can read file F . but. not other files. To read other files, for
example, F,+2, it is necessary to know a read-key other than m i . We present
in the following an algorithm for database encryption and decryption .
Algorithm 3 .3.8 (Database protection) . Given D = (Fr,F2, . . . ,F,,) ,
this algorithm will first encrypt the database D into its encrypted text C . To
retrieve information from the encrypted database C, the user uses the appropri -
ate read-key m, to read file F, :
Part I : Database Encryption . The database administrators (DBA) perform th e
following operations to encrypt the database D :
[1]
Select n distinct primes mt , rn2 , • - - , mn with m, > F,, for i
=
1, 2, .
.n .
[2] Use the Chinese Remainder Theorem to solve the following system of
congruences :
C
Fr (mod mr) ,
C
F2 (mod m2) .
(3.111)
C
F,, (mod m„) .
and get
C =
ej Fj (mod 17),
0 < C < M
(3.112)
where
nd = mtm2 . . .
_1I, = M/mi .
e=AI,[11 ' mod rn
fori=1 .2, .'
.rz .
[3] Distribute the read-key rn, to the appropriate database user C, .
F, - C (mod rig),
0 < F, < rn, .
(3.113)
The required file F, should be now readable by user C, .
Example 3.3.14 (Database Encryption and Decryption) . Let
D =
(F1 . F2 i F3 . F4, F5 )
= (198753.217926,357918,377761 .391028) .
Choose five prunes rnr, m2 . m3 . m4 and rn, as follows :
mr = 350377
m2 = 36442 3
1173 = 376127
m 4 = 38921 9
m 5 = 391939
> Fr = 198753 ,
> F2 = 217926 .
> F2 = 357918 ,
> F4 = 377761 ,
> F5 = 391028 -
According to (3 .111), we have :
C = Fi (mod m,r)	 	
> C - 198753 (mod 350377)
C
F2 (mod m2)	 	
> C ° 217926 (mod 364423 )
C
F3 (mod
1173 )	 	
> C
357918 (mod 376127 )
C
F4 (mod m4)	 	
> C
377761 (mod 389219)
C
F5 (mod m 5)	 	
> C
391028 (mod 391939) .
Using the Chinese Remainder Theorem to solve the above system of congru-
ences, we get
C = 5826262707691801601352277219 .
Since 0 < C < Al with
111 = 350377-364423W376127 . 389219 39193 9
= 7326362302832726883024522697 ,
C is the required encrypted text of D . Now suppose user Lr2 has the read-key
1712 = 364423 . Then he can simply perform the following computation an d
get F2 :
F> C (mod m,) .
Now
C (mod m2) =
5826262707691801601352277219 mod 36442 3
= 217926
= F, .

398
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Security
399
which is exactly what the user U9 wanted. Similarly, a user can read F5 if he
knows rn5 , since
C (mod in,) = 5826262707691801601352277219 mod 39193 9
391028
F5
Remark 3.3.10 . In Example 3.3.14. we have not explicitly given the com-
puting processes for the write keys et and the encrypted text C : we give now
the detailed computing processes as follows :
ei = 1llr • (AMr-i mod rni )
= 20909940729079611056161•(2090994072907961105616 1 -1 mod 350377 )
= 304057721123765348250953949 3
C2 = Ah
(Al i mod 7rt2 )
= 20104006341072673467439•(2010400634107267346743 9-1 mod 364423)
= 2830382740740598479460334493 c 3 = M3 (WI mod rn3)
= 19478426975018349873911•(1947842697501834987391 1 -i mod 376127)
= 199188342089235147645601277 1
e 4 = 1yI3
(Al
l mod 77x4 )
= 18823239109171769320163•(1882323910917176932016 3—1 mod 389219 )
= 6068028768384594103971626147
e5 = AI5
mod 705 )
= 18692608550903908217923 . (18692608550903908217923-i mod 391939 )
= 721852464410256223651532491 .
So
C
(eiFi + e2 F7 + e3 F3 + e4F4 + e5 F5 ) mod AI
(3040577211237653482509539493 . 198753
+ 2830382740740598479460334493 - 21792 6
+ 19918834208923.51476456012771 - 357918
+ 6068028768384594103971626147- 37776 1
+ 721852464410256223651532491 . 391028 )
mod 7326362302832726883024522697
rrti = 9901 > F l = 9853 ,
m2 = 7937 > F7 = 6792 .
m3 = 5279>F3 =3761 ..
rn4 = 6997 > Fi = 5102 .
(1) What are the four write keys e I .
C2 . C and e4 used in the encryption
process?
(2) What is the encrypted text C corresponding to D?
(3) If F] is changed from FI = 9853 to Fr = 9123, what is the new value of
the encrypted text C ?
To protect a database, we can encrypt it by using encryption keys . To
protect encryption keys, however, we will need some different methods . In the
next subsection, we shall introduce a method for protecting the cryptographi c
keys .
3.3.12 Secret Sharing
Liu [145] considers the following problem : eleven scientists are working on a
secret project. They wish to lock up the documents in a cabinet such that th e
cabinet can be opened if and only if six or more of the scientists are present .
What is the smallest number of locks needed? What is the smallest numbe r
of keys to the locks each scientist must carry? The minimal solution uses 46 2
locks and 252 keys . It. is clear that these numbers are impractical, and the y
become exponentially worse when the number of scientists increases . In this
section, we shall introduce an interesting method to solve similar problems.
It is called secret sharing and was first proposed by Shamir in 1979 (se e
Mignotte [161] and Shamir [225]) . The method can be very useful in the
management of cryptographic keys and the keys for accessing the passwor d
file in a computer system .
Definition 3.3.4. A (k,71)-threshold scheme is a. method for n people (or
parties) P, . Pz i . . • ,P,, to share a secret S in such a way that the followin g
properties hold :
(1) k < 7t .
5826262707691801601352277219 .
Exercise 3.3 .11. Let the database D be
(2) each P, has some information I„
(3) knowledge of any k of the IF ,12 , • • '
; I„ } enables one to find S easily.
D =
(Fi .F2 .F3 .Fl
(4) knowledge of less than k of the {11 .12 .'' . , I, } does not enable one t o
find S easily .
=
(9853, 6792.3761 .5102) .
Of course, there might be several ways to construct such a threshold
scheme . but perhaps the simplest is the one based on congruence theory
and the Chinese Remainder Theorem. It can be shown (Krana [134]) by th e
Chinese Remainder Theorem that :
and the four read keys be

400
3. Applied Number Theory in Computing/Cryptography
Theorem 3.3.3. For all 2 < k < n, there exists a (k, n)-threshold scheme .
In what follows_ we shall introduce an algorithm for constructing a (k, n) -
threshold scheme .
Algorithm 3.3.9 (Secret sharing) . This algorithm is divided into two parts :
the first part aims to construct a secret set {11 .12 . . . . 1,z }, whereas the secon d
part aims to find out the secret S by any A. of the {1 1 .72 , . . . . I,,} . Throughout
the algorithm, S denotes the secret .
Part I: Construction of the secret set {I4,12 ,
[1] Let the threshold sequence rnt ,m2 , • • • , m„ be positive integers >
1
such that gcd(m, inj ) = 1 for i j an d
mrn2 . . . 0 k
m,z–x+2 .
(3.114)
[2] Determine the secret S in such a way tha t
max(k – 1) < S < min(k)
(3.115)
where
[4] Compute M = m i me - m„ .
[5] Send I, and (m,, M) to each P; .
Part II: Recovering S from any k of these 11 ,12 . -
. I„ : Suppose now partie s
{Pi, .Pr 2 , . ,} want to combine their knowledge {I„,I,, .---,1,,_} to
find out S . (Each P,,, j = 1 .2	
n has the triple (I,,, m,, , 1I) at hand) .
[1] Each P,,, j = 1, 2, - - - .k computes his own secret recovering key Si ,
as follows :
Al
= Al/m,.
1> _ _ll
1 (mod
S,
= 1,,A1,,1\',
_ .
3.3 Cryptography and Information Security
401
[2] Combine all the
to get the secret S :
S = E Si,
k
mod
m,,
,)
.
(3.119)
3=1
1
(By the Chinese Remainder Theorem, this computed S will be the re-
quired secret) .
Example 3 .3 .15 . Suppose we wish to construct a (k, n)-threshold scheme
with A. = 3 and n = 5 . The scheme administrator of a security agency first
defines the following threshold sequence m, :
mt = 97 ,
m2 = 98 ,
m3 = 99 ,
m4 = 101 .
nt5
103 ,
and computes :
M = m 1m2m3m4rn5 = 9790200882
min(k) = m 1m2m,3 = 941094
max(k – 1) = m4m5 = 10403 .
He then defines the secret S to be in the range
10403 < S = 671875 < 941094
and calculates each I for each P, :
S-I1 (mod mi )	
> 11 =53
S - 12 (mod m2 ) 
> 12 = 85
S- 13 (mod m3 )--> 13 = 6
S E 14 (mod m4 )
14 = 23
5-I5 (mod m;5)–>15=6 .
Finally he distributes each I, as well as mi and Al to each P,, so that each
P; who shares the secret S has the triple (I, . rn„ AI) .
Suppose now P1 , P2 and P3 want to combine their knowledge {I1,12 .13 }
to find out, S. They first individually compute :
171 = M/rn t = 100929906
AI2 = A1/m2 = 99900009
AI3 = M/m3 = 98890918
and
\'1 - 'lli 1 (mod rrr t ) 
> 1"1 = 95
N-
_11.;-1 (mod m 2) 
> N2 =13
E-E
N3 = A13-I (mod rn3)
N = 31 .
(3.116)
(3.117)
min(k) = MI m9
• . .Mk ,
max(k – 1) = m„m„– 1
[3] Compute {11,12	
1„,} in the following way :
S
(mod rni ),
S - 12 (mod m2),
S - (mod m„) .
(3
18)

402
3 . Applied Number Theory in Computing/Cryptography
3 .3 Cryptography and Information Security
403
Hence, they get
S
Ir -
I
- N3 +12
112 -N2 +I3
_13 ti3 (modnil
2
m3)
53 100929906 - 95 + 85 - 99900009 . 13 + 61 - 98890918 31
(mod 97 - 98 . 99)
805574312593 (mod 941094 )
671875 .
Suppose. alternatively. P,P and P5 wish to combine their knowledge
{I 3 .I I . I } to find out S . They do the similar computations as follows :
lIr = 11/m l = 10092990 6
lIt = .lI/rn4 = 96932682
115 = AI/rn5 = 95050494
and
"i = lIi r (mod
mI) 
NI 9'5
N4= .lJ
t (mod en 3 ) 
>
4=6 1
_N5
) 11;,
(mod m5) 
> N5 = 100.
Therefore .
S
Ir•IIr-Nr+Ir•i11,-N 1 +15 -415 -N5 (mod rn 3 •m4 -m5 )
53 - 10092990 6 . 95 + 23 - 96932682 . 61 + 6 . 95050494 . 100
(mod 97 • 101 - 103)
70120892.59.56 (mod 1009091)
671875 .
However, knowledge of less than 3 of these Ir , I2 ,
,I4 .I5 is insufficient t o
find out S . For example, you cannot expect to find out S just by combinin g
Il and I4 :
S' = II
. AIt •Nr+74-_llr•N4
(mod ntr
. m4)
53 • 100929906 . 95 + 23 . 96932682 . 61 (mod 97 - 101)
644178629556 (mod 9791)
5679 .
Clearly, this is not the correct value of S . Of course, you can find out S by
any 3 or more of the It .12 .13 .14 .15 .
Exercise 3.3.12. In the above context, find out S if Pi . P3 . P4 . P; wish to
combine their knowledge {1r .13 .14 . I5} to find out S .
Exercise 3.3.13 . Suppose a security agency defines a (5, 7)-threshol d
scheme and sends each triple (I„ rn„ AI) defined as follows to each person
P , for i = 1, 2, - - - , 7. who shares the secret S :
(I,,tnr) = (824,1501)
(12i m>) = (1242.1617)
(13 . rn3) = (1602,1931)
(1r,m4) = (1417,5573)
(I5 , ni . ) = (3090, 6191 )
(I6 .m.6 ) = (281,7537)
(17 ,rn7 ) = (6261,9513)
11 =1501 . 1617 . 1917 . 3533 . 9657 . 10361 . 5311 3
= 1159414813752079260508694 1
Now suppose parties P . P3 . P,. P6, P
wish to combine their knowledg e
{Ir .I3-15,16 .17} to find out S. What is the S? Suppose also parties
P . P3 , Pt . P3 , P6 wish to combine their knowledge {12 ,15 , 14 .15.16
to find
out S. What is the S then? (The two S's should be the same .)
3 .3 .13 Internet/Web Security and Electronic Commerce
It is easy to run a secure computer system . You merely have to disconnect
all dial-up connections and permit only direct-wired terminals, put th e
machine and its terminals in a shielded room, and post a guard at th e
door .
C*R.AMMPP AND MORRI S
UNIX Operating System Security [91]
The security mentioned in the above quotation is unfortunately not what we
need, though it is easy to achieve : an isolated and disconnected compute r
system is essentially a useless system in modern days. We would like such a
(local network) system which is fully connected to the Internet but still be a s
secure as a disconnected system . How can we achieve such a goal? The first
method to secure the local system is to introduce a firewall (security gateway )
to protect a local system against intrusion from outside sources. An Internet
firewall serves the same purpose as firewalls in buildings : to protect a certain
area from the spread of fire and a potentially catastrophic explosion. It is
used to examine the Internet addresses on packets or ports requested on
incoming connections to decide what traffic is allowed into the local network .
The simplest form of a firewall is the packer filter. as shown in Figure 3 .14 .
It basically keeps a record of allowable sources and destination IP addresse s
and deletes all packets which do not have these addresses . Unfortunately, thi s
firewalling technique suffers from the fact that IP addresses19 can be easily
forged . For example, a "hacker" might determine the list of good sourc e
addresses and then acid one of these addresses to any packets which ar e
addressed into the local network . Although some extra layers of security can
19 An Internet Protocol address (IP address), or just Internet address, is a uniqu e
32-bit binary number assigned to a host and used for all commmnication wit h
the host .

404
3 . Applied Number Theory in Computing/Cryptography
3 .3 Cryptography and Information Security
405
Allowable outgoing
IP addresse s
Firewall
Internet
Local
Loca l
network
network
Router with
Encryption
and
Decryption
Local
Loca l
networ k
network
Allowable Incomin g
1P addresses
Router with
•
•
Loca l
network
Local
network
Encryption
and
Decryption
Local
network
•
•
•
Local
network
Figure 3.14. Packet filter firewalls
be added into a firewall, it is generally still not powerful enough to protect a
local system against intrusion from outside unfriendly users in the Internet .
It is worthwhile pointing out that all networked systems have holes in the m
by which someone else can slip into . For example, recently the U .S. Federal
Bureau of Investigation (FBI) estimated that $7 .5 billion are lost annually to
electronic attack and the U.S . Department of Defence (DOD) says that in 96 %
of the cases where the crackers got in, they went undetected . The best method
of protection for a local network system is to encrypt all the informatio n
stored in the local system and to decrypt it whenever an authorized use r
wants to use the information. This method has an an important application
in secure communications – to encrypt the data leaving the local network an d
then to decrypt it on the remote site ; only friendly sites will have the required
encryption/decryption key to receive or to send data, and only the router s
which connect to the Internet require to encrypt/decrypt . This technique is
known as the cryptographic tunnels (see Figure 3.15), which has the extra
advantage 1 hat data cannot be easily tapped-into (Buchanan [42]) . A further
Figure 3 .15. Cryptographic tunnels
development of the cryptographic tunnels is the Virtual Private Network s
technologies [264], which use tunneling to create a private network so as t o
keep communication private .
Cryptographic tunnels have important applications in secure communica-
tions and digital payments . or more generally . the electronic commerce ove r
the insecure Internet/World Wide Web . For example. if Bob wants to order
a book from Alice's bookshop (see Figure 3 .16), he uses the secure tunnel t o
send Alice his credit card number : on receiving Bob's credit card number ..
Alice sends Bob the required book . It is worthwhile pointing out that a grea t
deal of effort has been put into commercial cryptographic-based Internet/We b
security in recent years. Generally speaking. there are two categories of com-
mercial cryptographic systems used for securing the Internet/Web communi-
cations. The first group are programs and protocols that are used for encryp-
tion of e-mail messages. These programs take a plaintext message, encryp t
it and either store the encrypted message on a local machine or transmit it

406
3 . Applied Number Theory in Computing/Cry ptography
3.3 Cryptography and Information Security
407
Ciphertext for "Mv credit card numbe s . . .
Eavesdropper Ev e
"What did they say??? "
Figure 3.16. Electronic book ordering
to another user over the Internet. Some popular systems that fall into this
category include the following :
(1) Pretty Good Privacy (PGP) : PGP is a program created by Philip Zim-
mermann to encrypt e-mails using public-key cryptography. PGP was
electronically published as free software in 1991 . It has now become the
worldwide de facto standard for e-mail encryption .
(2) Secure/Multipurpose Internet Mail Extensions (S/MIME): S/MIME is
a security enhancement to the MIME Internet e-mail format standard .
based on technology from RSA Data, Security. Although both PGP and
S/MIME are on an IETF (Internet Engineering Task Force) standards
track, it appears likely that S/MIME will emerge as the industry standard
for commercial and organizational use. while PGP will remain the choice
for personal e-mail security for niany users .
The second category of cryptographic systems are network protocols used fo r
providing confidentiality . authentication . integrity. and nonrepudiation in a
networked environment. These systems require real-time interplay between a
client and a server to work properly . Listed below are some systems falling
into this category :
(1) Secure Sockets Layer protocol (SSL) : SSL is developed by Netscape
Communications. and supported by Netscape and Microsoft browsers . It
provides a secure channel between client and server which ensures privacy
of data, authentication of the session partners and message integrity.
(2) Private Communication Technology protocol (PCT) : PCT, proposed by
Microsoft, is a slightly modified version of SSL . The Internet Engineering
Task Force (IETF) is in the process of creating a Transport Secure Laye r
(TSL) to merge the SSL and PCT .
(3) Secure HyperText Transport Protocol (S-HTTP) : S-HTTP is developed
by Enterprise Integration Technologies (EIT) . It uses a. modified version
of HTTP clients and the server to allow negotiation of privacy, authen-
tication and integrity characteristics .
(4) Secure Transaction Technology Protocol (STT) : STT is a standard devel-
oped jointly by Microsoft and Visa International to enable secure credi t
card payment and authorisation over the web .
(5) Secure Electronic Payment Protocol (SEPP) : SEPP is another electroni c
payments scheme, sponsored by MasterCard and developed in associa-
tion with IBM, Netscape, CyberCash and GTE . Both STT and SEPP
have been superseded by SET (Secure Electronic Transactions) . proposed
jointly by MasterCard and Visa .
Exercise 3 .3 .14. Try to order a. copy of a book, e.g., the present book, fro m
Springer-Verlag by using your SSL-aware web browser to create an encrypte d
connection to the Springer-Verlag web server :
https ://www .springer .de
Now we are in a position to discuss a real-world commercial cryptographi c
protocol, the SET protocol for secure credit card payment over the insecure
Internet. It is a simplified version of the SET, based on a description give n
in [87) .
Algorithm 3.3.10 (SET protocol) . This algorithm describes a crypto-
graphic protocol for credit card payment over the Internet . Suppose that Alic e
wants to purchase a book from Bob (an Internet bookshop) using the credi t
card issued by Lisa (a bank), but Alice does not want Bob to see her credit car d
number, however she wants Bob to send her the book and Lisa to send Bo b
the payment . And of course, Alice also wants that the communications betwee n
Bob, Lisa and herself is kept confidential even if someone is eavesdropping over
the Internet .
[11 Alice first prepares two documents: a purchase order O stating she want s
to order a book from Bob, and a payment slip P, providing Lisa the car d
number to be used in the transaction, and the amount to be charged. Then
she computes the digests :
o = H(0)
p = H(P )
and produces a digital signature S for the digest of the concatenation of o
and p:
S = P.a( H( o
II p)) = H r(H(H ( 0)
II H(P)))
(3 .121)
In me
Alice's Booksho p
(Encryption/Decryptio n
Key)
Ciphretcxt for "Your b,6ok was mailed to yo u
Bo b
(Encryption/Decryptio n
Key
(3.120)

408
3 . Applied Number Theory in Computing/Cryptography
3.3 Cryptography and Information Seen
409
where D,t is the function used by Alice to sign, based on her private key .
Alice encrypts the concatenation of o, P and S with Lisa's public key, whic h
yields the ciphertext :
CL=EL(oII P
11 S) .
(3.122)
She also encrypts with Bob's public key the concatenation of 0, p and S
and gets the ciphertext :
CB = EB (O
11 p II S) .
(3.123)
She then sends CL and CB to Bob .
[2] Bob retrieves 0, p and S by decrypting CB with his private key . He verifie s
the authenticity of the purchase order 0 with Alice's public key by checking
that
Ea(S) = H(H(O p))
(3.124)
and forwards CL to Lisa .
[3] Lisa retrieves o, P and S by decrypting CL with private key. She verifies th e
authenticity of the payment slip P with Alice's public key by checking tha t
E4(S) = H(o II H(P))
(3.125 )
and verifies that P indicates a payment to Bob . She then creates an au-
thorization message Ill that consists of a transaction number, Alice's name ,
and the amount she agreed to pay. Lisa computes the signature T of Al ,
encrypts the pair (AI,T) with Bob's public key to get the ciphertext :
C AI = Et3(M T)
(3.126 )
and sends it to Bob .
[4] Bob retrieves Al and T by decrypting C t.1 and verifies the authenticity o f
the authorization message Ill with Lisa's public key, by checking tha t
EL (T)
ll .
(3.127)
He verifies that the name in AI is Alice's, and that the amount is the cor-
rect price of the book. He fulfills the order by sending the book to Alice
and requests the payment from Lisa by sending her the transaction numbe r
encrypted with Lisa's public key.
[5] Lisa pays Bob and charges Alice's credit card account .
3 .3 .14 Steganography
Cryptography means `"secret writing
A closely related area to cryptograph y
is steganography, which literally means covered writing as derived from Greek
and deals with the hiding of messages so that the potential monitors do not
even know that a message is being sent . It is different from cryptography
where they know that a secret message is being sent . Figure 3.17 shows a
schematic diagram of a typical steganography system . Generally, the sender
Public and Insecure Channel
Stegoanalyst
Stego-key
Stego-key
Stego-Message
Cover-messag e
Cover-message
(non-secret)
(non-secret )
Figure 3.17. A steganographic system
performs the following operations :
(1) write a non-secret cover-message,
(2) produce a stego-message by concealing a secret embedded message o n
the cover message by using a stego-key ,
(3) send the stego-message over the insecure channel to the receiver .
At the other end . on receiving the stego-message, the intended receiver ex -
tracts the secret embedded message from the stego-message by using a pre -
agreed stego-key (often the same key as used in the message concealing) .
Historical tricks include invisible inks . tiny pin punctures on selected char-
acters. minute differences between handwritten characters, etc . For example .
Kahn tells of a classical Chinese practice of embedding a code ideogram a t
a prearranged place in a dispatch (Kahn [117]) . More recently, people have
hidden secret messages in graphic images by replacing the least significan t
bits of the image with a secret message (Schneier [218]) .
Embedded-Message
Embedded Message
(secret)
(secret)
Message
Concealing
Message
Extracting

410
3 . Applied Number Theory in Computing/Cryptography
3.4 Bibliographic Notes and Further Reading
41 1
Note that the procedures of message concealing and message extractin g
in steganography are more or less the same as the message encryption an d
message decryption in cryptography. It is this reason that steganography is
often used together with cryptography . For example, an encrypted message
may be written using invisible ink . Note also that a steganographic system
can either be secret or public. In a public key steganographic system. different
keys are used for message concealing and message extracting . Readers inter-
ested in steganography are suggested to consult the workshop proceedings on
Information Hiding (Anderson [9] and Aucsmith [13]) .
3.3.15 Quantum Cryptography
In Chapter 2 . we introduced some quantum algorithms for factoring large
integers and computing discrete logarithms . It is evident that. if a quantum
computer is available, then all the public key cryptographic systems based o n
the difficulty of integer factorization and discrete logarithms will he insecure .
However, the cryptographic systems based on quantum mechanics will stil l
be secure even if a quantum computer is available . To make this hook as
complete as possible . we shall introduce in this subsection some basic idea s
of quantum cryptography . More specifically, we shall introduce a quantu m
analog of the Diffie-Hellman key exchange/distribution system, proposed b y
Bennett and Brassard in 1984 .
First let us define four polarizations as follows :
{0°. 45°, 90° . 135°} `ref
T,
I .
(3.128)
The quantum system consists of a . transmitter, a receiver, and a quantu m
channel through which polarized photons can be sent [25] . By the law of
quantum mechanics, the receiver can either distinguish between the rectilin-
ear polarizations {-s,
or reconfigure to discriminate between the diagona l
polarizations {/, v}. but in any case, he cannot distinguish both types .
The system works in the following way :
[1] Alice uses the transmitter to send Bob a sequence of photons. each of
them should be in one of the four polarizations {—z,
(/, T. N} . For
instance. Alice could choose . at random. the following photon s
to be sent to Bob .
[2] Bob then uses the receiver to measure the polarizations . For each pho-
ton received from :Vice. Bob chooses, at random, the following type o f
measurements {+, x} :
+
+
x
x
+
x
x
x
+
[3]Bob records the result of his measurements but keeps it secret :
[4] Bob publicly announces the type of measurements he made. and Alice
tells him which measurements were of correct type :
[5] Alice and Bob keep all cases in which Bob measured the correct type .
These cases are then translated into hits {0,1} and thereby become the
key:
t
-4
/
t
1
0
0
[6]Using this secret key formed by the quantum channel . Bob and Alice can
now encrypt and send their ordinary messages via the classic public-key
channel .
An eavesdropper is free to try to measure the photons in the quantu m
channel, but, according to the law of quantum mechanics, he cannot in general
do this without disturbing them, and hence, the key formed by the quantu m
channel is secure .
3 .4 Bibliographic Notes and Further Reading
We interpret applied number theory in this book as the application of num-
ber theory to computing and information technology, and thus this chapte r
is mainly concerned with these applications of number theory. Even with thi s
restriction, we argue that it is impossible to discuss all the computing relate d
applications of number theory in a single book . We have, in fact only dis-
cussed the applications of number theory to the design of computer system s
and cryptosystems .
Our first application of nnmiber theory in computing is the design of com -
puter systems: these include residue number systems and residue computers .
complementary arithmetic and fast adders, error detections and corrections .
the construction of hash functions (particularly minimal perfect hash func-
tions). and the generation of random numbers/bits . Our- aim was to show
the applicability of number theory in computer systems design rather than
the actual design of the computer (hardware or software) systems . There are

412
3 . Applied Number Theory in Computing/Cryptography
3.4 Bibliographic Notes and Further Reading
41 3
plenty of books available on computer arithmetic (including residue number
systems and complementary arithmetic) and fast computer architectures, bu t
those by Koren [132], McClellan and Radar [149] . Soderstrand et al . [243] ,
and Szabo and Tanaka [247] are highly recommended . A standard referenc e
that contains many applications of number theory in computer arithmetic .
random number generation and hash functions (and many more) is Knuth' s
three volumes of The Art of Computer Programming [122], [123], and [124] .
For error detection and correction codes, see . for example, Gallian [77] . Hill
[104], and Welsh [252] .
Cryptography, particularly public-key cryptography, is an area that heav-
ily depends on ideas and methods from number theory ; of course, number the-
ory is also useful in information systems security, including communicatio n
network security . In this chapter . we have provided a mathematical foun-
dation for cryptography and information security. Those who desire a more
detailed exposition in the field are invited to consult Bauer [20], Koblit z
[128] and [129] . and Pinch [184]; for elliptic curve public-key cryptography,
see Menezes [155] . Readers may also find the following books useful in cryp-
tography and computer security: Jackson [112], Kaufman et al . [118], Pfleeger
[182], Salomaa [215], Smith [242], Stinson [246] and Welsh [252] . The books
edited by Pomerance [190] and [44] contain a number of excellent survey
papers on cryptology and random number generation .
The series of conferences proceedings entitled Advances in Cryptology
published in Lecture Notes in Computer Science by Springer-Verlag is a n
important source for new developments in cryptography and information se-
curity.
There is a special section on computer and network security in the Scien-
tific American, 279, 4(1998), 69 89 ; it contains the following articles :
[1] C. P. Meinel. "How Hackers Break in . . . and How They Are Caught" . pp
70-77 .
[2] "How Computer Security Works" ,
[i]W. Cheswick and S . M. Bellovin. "Firewalls", pp 78-79 .
[ii] W. Ford, "Digital Certificates", page 80 .
[iii] J. Gosling, "The Java Sandbox" . page 81 .
[3] P. R. Zimmermann, "Cryptography for the Internet", pp 82-87 .
[4] R. L. Rivest. "The Case Against Regulating Encryption Technolog ,P P
88 89 .
An issue of the IEEE journal Computer, 31 . 9(1998) . also has a special report
on computer and network security . which contains the following six papers :
[1]P. W. Dowd and J. T . McHenry . "Network Security: It 's Time to Take
It Seriously" . pp 24- 28 .
[2] B. Schneier, "Cryptographic Design Vulnerabilities " , pp 29-33 .
[3] A. D . Rubin and D . E. Geer Jr . "A Survey on Web Security . pp 34-42 .
[4]R. Oppliger, "Security at the Internet Layer" , pp 43-47 .
[5]W. A . Arbaugh. et al ., "Security for Virtual Private Intranets" . pp 48 -56 .
[6] T. D . Tarman, et al .. "Algorithm-Agile Encryption in ATM Networks" .
PP 57 64 .
Note that the paper by Rubin and Geer [213] also discussed some interestin g
issues in mobile code security. All the above mentioned papers are easy to
read and hence suitable for beginners in the field .
As by-products to cryptography, we have also introduced some basic con-
cepts of steganography and quantum cryptography. There has been an in-
creasing number of references in these two fields in recent years ; interested
readers are referred to . for example, Anderson [9], Aucsmith [13] . Hughes
[106], Inamori [110] and Lo [146] . and the references therein .
In addition to computing and cryptography, number theory has also bee n
successfully applied to many other areas such as physics, chemistry . acous-
tics, biology, engineering, dynamical systems . digital communications, digital
signal processing, graphics design, self-similarity, and even music . For more
information about these applications, readers are invited to consult Burr [44] ,
Schroeder [222] and Waldschmidt, Moussa, Luck and Itzykson [250] .

Bibliography
1. L. M . Adleman, "A Subexponential Algorithmic for the Discrete Logarith m
Problem with Applications to Cryptography", Proceedings of the 20th Annual
IEEE Symposium on Foundations of Computer Science, IEEE Press, 1979, 5 5
60.
2. L. M. Adleman, "Algorithmic Number Theory The Complexity Contribution" ,
Proceedings of the 35th Annual IEEE Symposium on Foundations ofComputer
Science, IEEE Press, 1994. 88-113.
3. L. M. Adleman, C. Pomerance, and R. S. Rumely. "On Distinguishing Prime
Numbers from Composite Numbers" . Annals of Mathematics . 117 (1983), 17 3
206 .
4. L. M . Adleman and M . D. A. Huang . Primality Testing and Abelian Varieties
over Finite Fields . Lecture Notes in Mathematics 1512, Springer-Verlag, 1992 .
5. A. V. Aho, J. E . Hoperoft and J. D. Ullman, The Design and Analysis of
Computer Algorithms, Addison-Wesley, 1974 .
6. W. Alford . G. Granville and C . Pomerance, "There Are Infinitely Man y
Carmichael Numbers" . Annals of Mathematics, 140 (1994), 703-722 .
7. R Alter, "Computations and Generalizations of a Remark of Ramanujan" ,
Analytic Number Theory. Proceedings, Lecture Notes in Mathematics 899 .
Springer-Verlag, 1981 . 183-196.
8. J . A. Anderson and J . M. Bell, Number Theory with Applications. Prentice -
Hall, 1997 .
9. R . Anderson (editor) . Information Hiding, First International Workshop ; Pro-
ceedings. Lecture Notes in Computer Science 1174 . Springer-Verlag, 1996.
10. G . E. Andrews . Number Theory. W . B. Sayders Company, 1971 . Also Dover
Publications. 1994 .
11 T. M. Apostol, Introduction to Analytic Number Theory, Corrected 5th Print-
ing, Undergraduate Texts in Mathematics, Springer-Verlag . 1998 .
12 A. O. L. Atkin and F. Morain . "Elliptic Curves and Primaiity Proving", Math-
ematics of Computation. 61 (1993), 29 68 .
13. D. Aucsmith (editor), Information Hiding, Second International Workshop ,
Proceedings. Lecture Notes in Computer Science 1525 . Springer-Verlag . 1998 .
14. E. Bach . M. Giesbrecht and J. McInnes, The Complexity of Number Theoret-
ical Algorithms. Technical Report 247/91 . Department of Computer Science .
University of Toronto . 1991 .
15. E. Bach. G . Miller and J. Shallit, "Sums of Divisors . Perfect Numbers and
Factoring" , SIAM Journal on Computing, 15 (1989), 1143 1154 .

416
Bibliography
Bibliography
11 7
16. E. Bach and J. Shallit, Algorithmic Number Theory I Efficient Algorithms .
MIT Press, 1996 .
17. A . Backer, A Concise Introduction to the Theory of Numbers . Cambridge Uni-
versity Press. 1984 .
18. R. J. Baillie and S . S. Wagstaff. Jr .. "Lucas Pseudoprimeti" . Mathematics of
Computation. 35 (1980) . 13911417 .
19. S. Battiato and W. Borho. "Bleeding Amicable Numbers in Abundance II " ,
Mathematics of Computation . 70 (2001), 1329-1333 .
20. F . L. Bauer, Decrypted Secrets Methods and Maxims of Ciyptology, 2n d
Edition, Springer-Verlag. 2000 .
21. B. Beckett, Introduction to Crvptology and PC Security, McGraw-Hill, 1997 .
22. M. Bellare and P. Gogaway,
"Optimal Asymmetric Encryption" . Advances in
Cryptography, CRYPTO '94, Proceedings. Lecture Notes in Computer Science
950. Springer-Verlag, 1995, 92111 .
23. P. Benioff, `"The Computer as a Physical System A Microscopic Quantu m
Mechanical Hamiltonian Model of Computers as Represented by Turing Ma-
chines", Journal of Statistical Physics, 22 (1980), 563-591 .
24. C. H. Bennett, "Quantum Information and Computation" . Physics Today, Oc-
tober 1995, 24-30 .
25. C. H. Bennett . G. Brassard and A . K . Ekert, "Quantum Cryptography", Sci-
entific American, October 1992, 26 33 .
26. C . H. Bennett, "Strengths and Weakness of Quantum Computing", SIAM Jour-
nal on Computing, 26 (5)1997, 1510 1523 .
27. E. Bernstein and U . Vazirani, "Quantum Complexity Theory", SIAM Journal
on Computing, 26 5(1997), 14111473 .
28. M. Blinn and S. Goldwasser, "An Efficient Probabilistic Public-key Encryp-
tion Scheme that Hides all Partial Information", Advances in Cryptography.
CRYPTO '84, Proceedings, Lecture Notes in Computer Science 196, Springer-
Verlag 1985, 289 302 .
Boll:1986 B. Bollobds (editor) . Littlewood's Miscellany, Cambridge University
Press, 1986 .
29. E. Bombieri, Problems of the Millennium : The Riemann Hypothesis . Institute
for Advanced Study . Princeton, 2000 .
30. D . Boneh. "Twenty Years of Attacks on the RSA Cryptos}stem' . Notices of
the AMTS . 46 2(1999), 203-213 .
31. NV. Borho, "Uber die Fixpunkte der k-fach iterierten Teilersummenfunktio n
Mitt . Math . Gesellsch . Hamburg, 9 5(1969) . 34 48 .
32. NV. Borho and H . Hoffmann, "Breeding Amicable Numbers in Abundance' .
Mathematics of Computation, 46 (1986), 281-293 .
33. G . Brassard, "A Quantum Jump in Computer Science", Computer Science
Today
Recent Trends and Development. Lecture Notes in Computer Scienc e
1000, Springer-Verlag, 1995. 1-14.
34. R. P. Brent,
"Irregularities in the Distribution of Primes and Twin Prunes " .
Mathematics of Computation. 29 (1975) . 43 56 .
35. R. P. Brent, "An Improved Monte Carlo Factorization Algorithm
BIT, 20
(1980), 176-184 .
36. R. P. Brent, "Some Integer Factorization Algorithms using Elliptic Curves" .
Australian Computer Science Communications. 8 (1986), 149-163 .
37. R. P. Brent, "Primality Testing and Integer Factorization", Proceedings of_lus-
tralian Academy of Science Annual General Meeting Symposium on the Role
of Mathematics in Science. Canberra. 1991. 14 26 .
38. R . P. Brent, "Uses of Randomness in Computation, Report TR-CS-94-06 .
Computer Sciences Laboratory, Australian National University, 1994.
39. R. P. Brent, G. L. Cohen and H. J . .I to Riele. Improved Techniques for Lowe r
Bounds for Odd Perfect Numbers", Mathematics of Computation, 57 (1991).
857 868 .
40. D. M. Bressoud, Factorization and Prirnalitr Testing, Undergraduate Texts i n
Mathematics, Springer-Verlag, 1989 .
41. E. F . Brickell, D. M. Gordon and K. S. McCurley, "Fast Exponentiation with
Precomputation" (Extended Abstract), Advances in Cryptography, EURO-
CRYPT '92, Proceedings, Lecture Notes in Computer Science 658, Springer-
Verlag, 1992, 200-207 .
42. W. Buchanan, Mastering the Internet . Macmillan, 1997 .
43. J. P. Buhler (editor), Algorithmic Number Theory . Third International Sym-
posium, ANTS-III, Proceedings, Lecture Notes in Computer Science 1423 ,
Springer-Verlag, 1998 .
44. S. A. Burr (editor), The Unreasonable Effectiveness of Number Theory, Pro-
ceedings of Symposia in Applied Mathematics 46, American Mathematical So-
ciety, 1992 .
45. CACM. "The Digital Signature Standard Proposed by NIST and Responses t o
NIST's Proposal", Communications of the ACM. 35, 7(1992), 36 54 .
46. J. R. Chen, "On the Representation of a Large Even Integer as the Sum of a
Prime and the Product of at most Two Primes" . Scientia Sinica, XVI, 2(1973) ,
157-176 .
47. K . Chen . "Authenticated Encryption Scheme Based on Quadratic Residue" ,
Electronics Letters, 34, 22(1998), 2115-2116 .
48. S. S. Coern. "Mathematics in the 21st Century" . Advances in Mathematics
(China), 21, 4(1992), 385-387 .
49. L. Childs, A Concrete Introduction to Higher Algebra, Undergraduate Text s
in Mathematics . Springer-Verlag, 1979 .
50. H. Cohen. A Course in Computational Algebraic Number Theory, Graduate
Texts in Mathematics 138, Springer-Verlag . 1993 .
51. J . H. Conway and R. K. Guy. The Book of Numbers. Springer-Verlag, 1996 .
52. S. Cook . The P versus NP Problem, University of Toronto. April, 2000 .
(Manuscript prepared for the Clay Mathematics Institute for the Millenniu m
Prize Problems; revised in November 2000 .)
53. J. W. Cooley and J. \V. Tukey, "An Algorithm for the ALachine Calculation of
Complex Fourier Series" , Mathematics of Computation . 19 (1965), 297301 .
.54. 'F. H. Cormen_ C. E. Ceiserson and R. L. Rivest. Introduction to Algorithms .
MIT Press, 1990 .
55. R. Crandall, J. Doenias, C . Norrie and J. Young . "The Twenty-Second Fermat
Number is Composite " , Mathematics of Computation, 64 (1995) . 863 869 .
56. R. Crandall and C. Pomerance . Prime Numbers A Computational Perspec-
tive, Springer-Verlag, 2001 .

418
Bibliograpl
Bibliography
57. I . Damgard (editor), Lectures in Data Security . Lecture Notes in Computer
Science 1561 . Springer-Verlag. 1999 .
58. H. Davenport, The Higher Arithmetic. 7th Edition, Cambridge University
Press. 1999 .
59. M. Deleglise and J . Rivat. "Computing ir(r) the Meissel . Lehmer, Lagarias ,
Miller. Odlvzko Method" . Mathematics of Computation . 65 (1996) . 235-245 .
60. D. C. Denson, The Moment of Proof Mathematical Epiphanies, Oxford Uni-
versity Press, 1997 .
61. J. M. Deshouillers . G . Effinger, H. J. J. te Riele and D . Zinoviev. "A Complete
Vinogradov 3-Prime Theorem under the Riemann Hypothesis" . Electronic Re -
search Announcements of the AMS, 3 (1997), 99-104 .
62. J. M. Deshouillers, H . ,4 . .I . to Riele and Y. Saouter, New Experimental Results
Concerning the Goldbach Conjecture . Technical Report M-1AS-R.9804, Centre for
Mathematics and Computer Science (CWI), Amsterdam, 1998 .
63. D. Deutsch, "Quantum Theory, the Church—Turing Principle and the Universa l
Quantum Computer" . Proceedings of the Royal Society of London, Series A .
400 (1985), 96 117 .
64. K . Devlin. Mathematics : The Science of Patterns, Scientific American Library ,
1997 .
65. L. E. Dickson, History of the Theory- of Numbers I Divisibility and Primality ,
G. E. Stechert Sr:. Co., New York, 1934 .
66. W . Diffie and E . Hellman, "New Directions in Cryptography" . IEEE Transac-
tions on Information Theory, 22, 5(1976), 644-654 .
67. W. Diffie and E. Hellman, "Privacy and Authentication: An Introduction to
Cryptography", Proceedings of the IEEE, 67, 3(1979), 393 427 .
68. P. G. L. Dirichlet, Lecturers on Number Theory.-. Supplements by R. Dedekind,
American Mathematics Society and London Mathematics Society, 1999 .
69. T. ElGama1, "A Public Key Crvptos}stem and a. Signature Scheme based on
Discrete Logarithms", IEEE Transactions on Information Theory, 31 (1985),
496-472 .
70. G. Ellis, Rings and Fields . Oxford University Press, 1992 .
71. S. S . Epp . Discrete Mathematics with Applications. 2nd Edition, PWS Pub-
lishing Company. Boston. 1995 .
72. Euclid, The Thirteen Books of Euclid's Elements, Translated by T . L. Heath.
Great Books of the TT estern World 11 . edited by R. M. Hutchins, Willia m
Benton Publishers. 1952 .
73. Euclid . The Thirteen Books of Euclid's Elements . Second Edition. Translated
by Thomas L. Heath. Dover Publications, 1956 .
74. R. P. Fe<vrmran . "Simulating Physics with Computers'' . International Journal
of Theoretical Physics . 21 (1982) . 467-488 .
75. R. P. Fevnman. Fevnman Lectures on Computation . Edited by A . .I. G . Hey
and R. W. Allen. Addison-Wesley. 1996 .
76. J . B. Fraleigh, .A First Course in Abstract algebra ; 5th Edition. Addison-
Wesley. 1994 .
77. J . A. Gallian,
"Error Detection Methods" . ACM Computing- Surveys, 28 ,
3(1996) . 503-517 .
78. M. Gardner, `"Mathematical Games A New Kind of Cipher that Would Talc,.
Millions of Years to Break" . Scientific American, 237. 2(1977) . 120 124 .
79. M. R. Garen and D . S. Johnson, Computers and Intractability
A Guide to
the Theory of NP-Completeness. W. H . Freeman and Company. 1979 .
80. S . Garfinkel, Web Security and Commerce, O 'Reilly. 1997 .
81. P. Garrett . Making . Breaking Codes: An Introduction to Cryptology . Prentice-
Hall, 2001 .
82. C . F . Gauss, Disquisitiones Arithmeticae . G . Fleischer, Leipzig, 1801 . English
translation by A . A . Clarke, Yale University Press, 1966 . Revised English trans-
lation by W. C. Waterhouse, Springer-Verlag, 1975 .
83. P. Giblin, Primes and Programming - An Introduction to Number Theory with
Computing, Cambridge University Press . 1993 .
84. S. Goldwasser, "The Search for Provably Secure Cryptosystems", Cryptology
and Computational Number Theory, edited by C. Pomerance, Proceedings o f
Symposia in Applied Mathematics 42, American Mathematical Society, 1990 .
85. S. Goldwasser and J . Kilian . "Almost All Primes Can be Quickly Certified" ,
Proceedings of the 18th ACM Symposium on Theory of Computing . Berkeley.
1986, 316-329 .
86. S. Goldwasser and J . Kilian . "Primality Testing Using Elliptic Curves", Journal
of ACM. 46, 4(1999), 450-472 .
87 M. T. Goodrich and R. Tamassia, Algorithm Design: Foundations . Analysis .
and Internet Examples . John Wiley & Sons. 2001 .
88. S . Goldwasser and S . Micah, 'Probabilistic Encryption", Journal of Computer
and System Sciences, 28 (1984) . 270 299 .
89. D . M. Gordon and K. S. McCurle "Massively Parallel Computation of Dis-
crete Logarithms" . Advances in Cryptography. Crypto '92, Proceedings, Lec-
ture Notes in Computer Science 740, Springer Verlag, 1992, 312 323 .
90. D. M. Gordon, "Discrete Logarithms in GF(p) using the Number Field Sieve" .
SIAM Journal on Discrete Mathematics, 6, 1(1993), 124-138 .
91. F. T. Grampp and R . H . Morris, "UNIX Operating System Security" . AT& T
Bell Laboratories Technical Journal, 63 (1984), 1649 1672 .
92. A . Granville, J. van de Lune and H. J. J. te Riele, `"Checking the Goldbach
Conjecture on a Vector Computer", Number Theory and Applications . edited
by R. A. Mollin, Kluwer Academic Publishers . 1989 . 423-433 .
93. D. Cries and F. B. Schneider, A Logical Approach to Discrete Math . Texts and
Monographs in Computer Science, Springer-Verlag. 1993 .
94. R.. K . Guy, Unsolved Problems in Number Theory. 2nd Edition .. Springer-
Verlag, 1994 .
95. D. Guedj, Numbers The Universal Language . Thames and Hudson . 1997 .
96. F. Guterl, "Suddenly. Number Theory Makes Sense to Industry" . International
Business Week, 20 June 1994, pp . 62-64 .
97. H . Halberstam and H. E . Richert, Sieve Methods . Academic Press . 1974 .
98. G . H. Hardy. A Mathematician 's Apology-, Cambridge University Press . 1979 .
99. G . H. Hardy and J. E. Littlewood . "Some Problems of 'Partitio Numerorum ' .
III: On the Express of a Number as a Sum of Primes" , _lcta lathematica . 44
(1923), 1- 70 .

420
Bibliography
Bibliography
421
100. G. H. Hardy and E. M. Wright, An Introduction to Theory of Numbers, 5th
Edition, Oxford University Press . 1979 .
101. D. R. Heath-Brown, "Odd Perfect Numbers" . Mathematical Proceedings of
Cambridge Philosophy Society, 115, 1(1994), 191-196 .
102. A. Heck, Introduction to Maple, 2nd Edition, Springer-Verlag, 1996 .
103. I. N. Herstein, Topics in Algebra, 2nd Edition. Wiley. 1975 .
104. R. Hill. A First Course in Coding Theory. Oxford University Press, 1991 .
105. L. Hua . Introduction to Number Theory. English Translation from Chinese
by P. Shiu, Springer-Verlag, 1980 .
R9511, Centre for Mathematics and Computer Science (CWI), Amsterdam ,
1995 .
108. T . W. Hungerford, Abstract Algebra An Introduction. Saunders College
Publishing, 1990 .
109. D. Husemoller, Elliptic Curves, Graduate Texts in Mathematics 111, Springer -
Verlag, 1987 .
110. H. Inamori. A Minimal Introduction to Quantum Key Distribution, Centr e
for Quantum Computation, Clarendon Laboratory, Oxford University, 1999 .
111. K . Ireland and M. Rosen, A Classical Introduction to Modern Number Theory,
2nd Edition. Graduate Texts in Mathematics 84. Springer-Verlag, 1990 .
112. T. H. Jackson, From Number Theory to Secret Codes, A Computer Illustrated
Text, Adam Hilger . Bristol, 1987 .
113. G . Jaeschke, "Reciprocal Hashing: A Method for Generating Minimal Perfect
Hashing Functions", Communications of the ACM, 24, 12(1981), 829-833 .
114. D. S . Johnson. "A Catalog of Complexity Classes " . Handbook of Theoretical
Computer Science, edited by J. van Leeuwen. MIT Press . 1990 . 69-161 .
115. R. Jozsa, "Quantum Factoring, Discrete Logarithms, and the Hidden Sub -
group Problem" . Computing in Science and Engineering, March/April 2001 ,
34 43 .
116. B . S. Kaliski . "A Pseudo-Random Bit Generator Based on Elliptic Curv e
Logarithms" . Advances in Cryptography. CRYPTO '86. Proceedings, Lecture
Notes in Computer Science 263, Springer-Verlag, 1986, 84103 .
1.17. D. Kahn. The Codebreakers . Macmillan. 1967 .
118. C. Kaufman. R. Perlman and M . Speciner . Network Security - Private Com-
munication in a Public World . Prentice-Hall . 1995 .
119. A. Ya. Khinchin. Continued Fractions. English translation from Russian .
Chicago University Press, 1964 .
120. J. Kilian. Uses of Randomness in Algorithms and Protocols . MIT Press . 1990 .
121. D. E. Knuth . "Computer Science and its Relation to Mathematics" . American
Mathematical Monthly. 81, 4(1974), 323 343 .
122. D. E. Knuth, The Art ofComputer Programming I
Fundamental Algorithms .
3rd Edition. Addison Wesley, 1997.
123. D. E. Knuth, The Art of Computer Programming II
Seminumerical Algo-
ritlmrs, 3rd Edition, Addison-Wesley. 1998 .
124. D. E. Knuth . The Art of Computer Programming III
Sorting and Searching,
2nd Edition, Addison-Wesley. 1998 .
125. C. Ko and Q. Sun . Lecture Notes in Number Theory (In Chinese), Higher
Education Press; Beijing. 1984 .
126. N. Koblitz, "Elliptic Curve Cryptography" . Mathematics of Computation ; 48
(1987) . 203-209 .
127. N. Koblitz, Introduction to Elliptic Curves and Modular Forms, 2nd Edition .
Graduate Texts in Mathematics 97, Springer-Verlag. 1993 .
128. N. Koblitz . A Course in Number Theory and Cryptography, 2nd Edition .
Graduate Texts in Mathematics 114. Springer-Verlag. 1994 .
N. Koblitz, Algebraic Aspects of Cryptography, Algorithms and Computatio n
n Mathematics 3, Springer-Verlag, 1998 .
N. Koblitz. Cryptography, in : Mathematics Unlimited — 2001 and Be-
yond, Edited by B. Enguist and W. Schmid . Springer-Verlag, 2001. 749- 769 .
131. S . Koncagin and C. Pomerance, "On Primes Recognizable in Deterministi c
Polynomial Time", The Mathematics of Paul Erdds, edited by R . L . Graham
and J. Nesetril, Algorithms and Combinatorias 1.3, Springer-Verlag, 1997, 17 6
198 .
132. I. Koren. Computer Arithmetic Algorithms, Prentice-Hall, 1993 .
133. H . Krishna. B . Krishna, K. Y. Lin, and J . D. Sun. Computational Number
Theory and Digital Signal Processing, CRC Press, 1994 .
134. E. Kranakis . Primality and Cryptography, John Wiley & Sons, 1986 .
135. R. Kumanduri and C. Ronero, Number Theory with Computer Applications .
Prentice-Hall, 1998 .
136. J . C. Lagarias, "Pseudorandom Number Generators " , Cryptology and Com-
putational Number Theory, edited by C . Pomerance, Proceedings of Symposi a
in Applied Mathematics 42, American Mathematical Society, 1990, pp 115 143 .
137. S. Lang, Elliptic Functions, 2nd Edition, Springer-Verlag . 1987 .
138. J . can Leeuwen (editor), Handbook of Theoretical Computer Science . MIT
Press, 1990 .
139. R. S. Lehman. "Factoring Large Integers" . Mathematics of Computation, 2 8
(1974) . pp 637-646 .
140. H. W . Lenstra. Jr., "Factoring Integers with Elliptic Curves" , Annals of Math-
ematics. 126 (1987), 649-673 .
141. A . K. Lenstra and H . W. Lenstra, Jr .. The Development of the Number Field
Sieve. Lecture Notes in Mathematics 1554. Springer Verlag, 1993 .
142. H. R. Lewis and C. H . Papadimitriou. Elements of the Theory of Computation ,
2nd Edition. Prentice-Hall. 1998 .
143. P. Linz, An Introduction to Formal Languages and Automata. 2nd Edi on .
Jones and Bartlett Publishers. 1997 .
144 .
.1. E . Littlewood, A Mathematician's Miscellany. Methuen & Co. Ltd. London ;
1953 . (This book later became Littlewood's Miscellany . edited by B . Bollobas
and published by Cambridge University Press in 1986 .)
145. C L. Liu. Introduction to Combinatorial Mathematics, McGraw-Hill, 1968 .
146. H . K. Lo . "Quantum Cryptography" , Introduction to Quantum Computation
and Information. edited by H. K. Lo, S. Popescu and T . Spiller. World Scientific .
1998 . 76 119 .
106. R. J. Hughes, "Cryptography, Quantum Computation and Trapped Ions" ,
Philosophic Transactions of the Royal Society London. Series A, 356 (1998) .
129 .
1853 1868 .
107. R. M . Huizing. An Implementation of the Number Field Sieve. Note NM -
130 .

422
Bibliography
Bibliography
423
147. J. van de Lune, H. J. J . to Riche and D. T. Winter. "On the Zeros of the
Riemann Zata Function in the Critical Strip IV" . Mathematics of Computation ,
46 (1986) . 667 681 .
148. R . S . Macgregor . A . Aresi and A. Siegert, WW W'.Security
How to Build a
Secure World Wide Web Connection . Prentice-Hall, 1996 .
149. J. H. McClellan and C. M . Radar, Number Theory in Digital Signal Process-
ing, Prentice-Hall, 1979 .
150. K . S. McCurley. "The Discrete Logarithm Problem" . Cryptology and Com-
putational Number Theory, edited by C. Pomerance, Proceedings of Symposi a
in Applied Mathematics 42 . American Mathematics Society. 1990. pp 49 74 .
151. K. S. Mr-Curley. "Odds and Ends from Cryptology and Computational Num-
ber Theory", edited by C. Pomerance . Proceedings of Symposia in Applied
Mathematics 42, American Mathematics Society . 1990, pp 49—74.
152. R. J. McEliece, Finite Fields for Computer Scientists and Engineers, Kluwer
Academic Publishers, 1987 .
153. H. McKean and V. Moll, Elliptic Curves Function Theory, Geometry, Arith-
metic, Cambridge University Press ; 1997 .
154. A. R . Meijer, "Groups, Factoring, and Cryptography" Mathematics Magazine .
69. 2(1996), 103 109 .
155. V. J. Menezes. Elliptic Curve Public Key Crrptosystems, Kluwer Academic
Publishers, 1993 .
156. A. Menezes and S . A. Vanstone, "Elliptic curve cryptosystems and their im-
plementation " , Journal of Cryptology, 6 (1993), 209-224 .
1.57. A. Menezes. P. C . van Oorschot and S . A. Vanstone. Handbook of Applied
Crvptosysterns. CRC Press. 1996 .
158. R. C. Merkle. "Secure Communications over Insecure Channels" Communica-
tions of the ACM, 21 (1978) . 294—299. (Submitted in 1975 .)
159. J. F. Mestre, "Formules Explicites et Minoration de Conducteurs de Varietes
algebriques" Compositio Mathematica, 58 (1986), 209 232 .
160. B. Meyer and and V . Muller. "A Public Key- Cryptosystem Based on Ellipti c
Curves over Z/nZ Equivalent to Factoring" , Advancers in Cryptology, EURO-
CRYPT '96. Proceedings. Lecture Notes in Computer Science 1070 . Springer -
V'erlag. 1996, 49 59 .
161. M. Mignotte, "How to Share a Secret " . Cryptography, Workshop Proceedings ,
Lecture Notes in Computer Science 149, Springer-Verlag . 1983. 371–375 .
162. G Miller. "Riemann's Hypothesis and Tests for Pr'imality", Journal of System s
and Computer Science . 13 (1976). 300 317 .
163. V . Miller_ "Uses of Elliptic Curves in Cryptography ", Advances in Cryptology.
CRYPTO '85. Proceedings. Lecture Notes in Computer Science 218 . Springer-
Verlag, 1986 . 417 426 .
164. R . A . Mollin, Fundamental Number Theory with _Applications . CRC' Press.
1998.
165. R . A. Mollin . An Introduction to Cryptography, Chapman k Hall/CRC, 2001 .
166. P. L. Montgomery. "Speeding Pollards and Elliptic Curve Methods of Fac-
torization' Mathematics of Computation. 48 (1987), 243264.
167. P. L. Montgomery. "A Survey of Modern Integer Factorization Algorithms " ,
CWI Quarterly. 7. 4(1.994) . 337 394 .
168. F. Morain . Courbes Elhptiques et
Tests de Pr'imalite, Universite Claude
Bernard. Lyon I. 1990 .
169. M. A. Morrison and J . Brillhart. -A Method of Factoring and the Factorizatio n
of F," . Mathematics of Computation, 29 (1975) . 183 205 .
170. R. Mottvani and P . Raghavan . Randomized Algorithms. Cambridge University
Press, 1995 .
171. C. J. Mozzochi, "A Simple Proof of the Chinese Remainder Theorem" . Amer-
ican Mathematical Monthly. 74 (1967) . 998 .
172. M. B. Nathanson, Elementally Methods in Number Theoriy . Springer-V erlag,
2000 .
173. KIST, "Data Encryption Standard' . Federal Information Processing Stan-
dards Publication 46-3. National Institute of Standards and Technology, U .S .
Department of Commerce, 1999 .
174. I. Niven. H. S. Zuckerman and H. L. Montgomery, An Introduction to th e
Theory of ' Numbers_ 5th Edition, John Wiley k Sons . 1991 .
175. D. H. Nyang and J. S. Song .. "Fast Digital Signature Scheme Based oil the
Quadratic Residue Problem" . Electronics Letters, 33 . 3(1997) . 205 206 .
176. S. Pohlig and M . Hellman. "An Improved Algorithm for Computing Loga-
rithms over GF(p) and its Cryptographic Significance", IEEE Transactions on
Information Theory, 24 (1978), pp 106 110 .
177. J . O'Connor and E. Robertson. The MacTutor History of Mathematics
Archive, http ://www.groups.dcs.st-and.ac.uk/history/VMathematicians .
178. A. M. Odlyzko, "Discrete Logarithms in Finite Fields and their Cryptographi c
Significance", Advances in Cryptography . EUROCRYPT '84, Proceedings, Lec-
ture Notes in Computer Science 209 . Springer-Verlag, 1984 . 225—314 .
179. T. Okamoto and K. Ohta, "Universal Electronic Cash", Advances in Cryp-
tography, CRYPTO '91, Proceedings . Lecture Notes in Computer Science 576 .
Springer-Verlag, 1991. 324337 .
180. Open University Course Team . Number Theory. Complex Analysis Unit 15 ,
Open University Press, 1974 .
181. O . Ore. Number Theory and its History. Dover Publications. 1988 .
182. C. P. Pfleeger. Security in Computing. Prentice-Hall . 1997.
183. R.G.E.Pinch, "Some PrimalityTesting Algorithms
Notices of the American
Mathematical Society. 40. 9(1993), 1203 1210 .
184. R. G . E . Pinch . Mathematics for Cryptography, Queen's College . University
of Cambridge, 1997 .
185. R . G . E. Pinch. The Carmichael umbers up to 10
. Queen's College . Uni-
versity of Cambridge, 1997.
186. S. C . Pohlig and M . Helhnan . "An Improved Algorithm for Computing Loga-
rithms over GF(p) and its Cryptographic Significance " . IEEE Transactions o n
Information Theory, 24 (1978) . 106 110 .
187. J . M. Pollard . "A Monte Carlo Method for Factorization" . BIT. 15 (197.5),
331 3.32 .
188. J. M . Pollard .
"Monte Carlo Methods for Index Computation (mod p) ' ,
Mathematics of Computation . 32 (1980). 918—924 .
189. C. Pomerance. "Very Short Primality Proofs " . Mathematics of Computation ,
48 (1987), 315-322 .

424
Bibliography
Bibliography
425
190. C . Pomerance (editor), Cryptology and Computational Number Theory. Pro-
ceedings of Symposia in Applied Mathematics 42. American Mathematical So-
ciety. 1990 .
191. C . Pomerance, "Cryptology and Computational Number Theory - An Intro-
duction " , Cryptology and Computational Number Theory . edited by C. Pomer-
ance, Proceedings of Symposia in Applied Mathematics 42. American Mathe-
matical Society, 1990, 1 12 .
192. C . Pomerance, J. L . Selfridge and S . S . Wagstaff. Jr ., "The Pseudoprimes t o
25 . 109" , Mathematics of Computation, 35 (1980), 1003-1026 .
193. V. R. Pratt "Every Prince Has a Succinct Certificate" . SIAM Journal on
Computing. 4 (1975), 214-220 .
194. W. H. Press and Teukolskv et al ., Numerical Recipes in C
The Art of
Scientific Computing, 2nd Edition, Cambridge University Press, 1992 .
195. M. O. Rabin . "Probabilistic Algorithms for Testing Primality " , Journal of
Number Theory . 12 (1980). 128138 .
196. E. D. Reilly and F. D. Federighi, P_ASCALGORITHMS
A Pascal-Based
Introduction to Computer Science, Houghton Mifflin, Boston, 1989 .
197. D. Redmond, Number Theory: An Introduction . Marcel Dekker, New York.
1996 .
198. P. Ribenboim, The Little Book on Big Primes, Springer-Verlag, 1991 .
199. P. Ribenboim,
"Selling Primes", Mathematics Magazine, 68, 3(1995), 175-
182 .
200. P. Ribenboim, The New Book of Prime Number Records, Springer-Verlag ,
1996 .
201. J . Richstein, "Goldbach's Conjecture up to 4 . 1e" , Mathematics of Compu-
tation, 70, (2001). 1745-1749 .
202. E. Rieffel and W. Polak, "An Introduction to Quantum Computing for Non -
Physicists", ACM Computing Surveys . 32, 3(2000), 300 335 .
203. H. J. J . te Riele, "New Very Large Amicable Pairs" , Number Theory. Noord-
wijkerhout 1983, Proceedings, Lecture Notes in Mathematics 1068, Springer -
Verlag, 1984. 210-215
204. H. J. J . te Riele, "A New Method for Finding Amicable Numbers", Reprin t
from Mathematics of Computation 19-13-1993, A Half-century of Computational
_Mathematics. Vancouver, 9-13 August 1993 .
205. H. J. J . te Riele. "Factorization of RSA-140 using the Number Field Sieve" .
http ://www .crypto-world .com/announcements/RSA140 .txt,4 February 1999 .
206. H. J. J. te Riele, "Factorization of a 512-bits RSA Key using the Number
Field Sieve" , http ://www .crypto-world .com/announcements/RS11155 .txt, 26
August 1999 .
207. H. Riesel .
Prime
Numbers and
Computer
Methods for Factorization .
Birkhauser, Boston. 1990 .
208. R. L. Rivest. "Remarks on a Proposed Cryptanalytic Attack on the M .I.T .
Public-key Crvptosystem" . Crtiptologia., 2, 1(1978) . 62 65 .
209. R. L. Invest, A . Shamir and L. Adleman, A Method for Obtaining Digita l
Signatures and Public Kev Crvptosysterns . Communications of the ACM, 21 .
2(1978) . 120 126 .
210. H. E. Rose, A Course in Number Theory. 2nd Edition, Oxford U
Press, 1994 .
211. K. Rosen, Elementary Number Theory and its Applications. 4th Edi
Addison Wesley, 2000 .
212. J. J . Rotman An Introduction to the Theory of Groups, Springer Verlag, 1994 .
213. A . D. Rubin and D . E. Geer. Jr .. Mobile Code Security, IEEE Internet Com-
puting, 2, 6(1998). 30 34 .
214. G. Rozenberg and A. Salomaa, Cornerstones of Undecidabilitc, Prentice-Hall ,
1994 .
215. A. Salomaa . Public-Key Cryptography. 2nd Edition. Springer Verlag, 1996 .
216. Y. Saouter, Vinogradov's Theorem is True up to 1020 , Publication Interne No .
977. IRISA, 1995 .
217. V. Scarani. "Quantum Computing" , American ,Journal of Physics, 66 ,
11(1998) . 956 960 .
218. B. Schneier, Applied Cryptography Protocols, Algorithms, and Source Code
in C, 2nd Edition, John Wiley & Sons. 1996 .
219. B. Schneier, John Kelsey, Doug Whiting, David Wagner, Chris Hall and Niel s
Ferguson, The Twofish Encryption Algorithm . . John Wiley Sr. Sons, 1999 .
220. C. P. Schnorr, "Efficient Identification and Signatures for Smart Cards", Ad-
vances in Cryptography, CRYPTO '89, Proceedings, Lecture Notes in Computer
Science 435, Springer-Verlag, 1990, 239-252 .
221. R . Schoof, "Elliptic Curves over Finite Fields and the Computation of Squar e
Roots mod p", Mathematics of Computation, 44 (1985), 483 494 .
222. M . R. Schroeder, Number Theory in Science and Communication, 3rd Edition .
Springer Series in Information Sciences 7, Springer-Verlag, 1997 .
223. W. Schwarz and J. Wolfgang, "Some Remarks on the History of' the Prime
Number Theorem from 1896 to 1960" Development of Mathematics 1900 1950,
edited by J.-P. Pier. Birkhauser. 1994.
224. A. Shamir, "Factoring Numbers in O(logn) Arithmetic Steps" , Information
Processing Letters, 8, 1(1979), 28-31 .
225. A. Shamir, "How to Share a Secret", Communications of the ACM, 22 .
11(1979), 612 613 .
226. P. Shor . "Algorithms for Quantum Computation : Discrete Logarithms and
Factoring" . Proceedings of 35th Annual Symposium on Foundations of' Com-
puter Science. IEEE Computer Society Press, 1994. 124-134.
227. P. Shor. "Polynomial-Time Algorithms for Prime Factorization and Discrete
Logarithms on a Quantum Computer", SIAM Journal on Computing, 26 ,
5(1997), 1484 1509 .
228. J. H. Silverman and J. Tate, Rational Points on Elliptic Curves. Undergrad-
uate Texts in Mathematics, Springer-Verlag . 1992 .
229. J. H. Silverman . The Arithmetic of Elliptic Curves. Graduate Texts in Math-
ematics 106 . Springer-Verlag, 1994 .
230. J. H. Silverman; A Friendly Introduction to Number Theory, Second Edition ,
Prentice-Hall . 2001 .
231. J. H. Silverman .
"The Xedni Calculus and the Elliptic Curve Discrete Loga-
rithm Problem" , Dept of Mathematics. Brown University. 10 February 1999 .
in,

426
Bibliograph
Bibliography
42 7
232. J. H. Silverman and J . Suzuki. "Elliptic- Curve Discrete Logarithms and th e
Index Calculus, Advances in Cryptology ASIACR PT '98. Springer Lecture
Notes in Computer Science 1514, 1998 . 110-125 .
233. R. D. Silverman. 'The Multiple Polynomial Quadratic Sieve" . Mathematics of
Computation. 48 (1987) . 329 339 .
234. R. D. Silverman, "A Perspective on Computational Number Theory Notice s
of the American Mathematical Society. 38, 6(1991). 562 568 .
235. R. D . Silverman, "Massively Distributed Computing and Factoring Large In-
tegers", Communications of the ACM. 34. 11(1991) . 95-103 .
236. D. R . Simon, "On the Power of Quantum Computation" . Proceedings of the
35th Annual IEEE Symposium on Foundations of Computer Science, IEEE
Press, 1994. 116 123 .
237. S Singh . The Code Book
The Science of Secrecy from Ancient Egypt to
Quantum Cryptography, Fourth Estate, London, 1999 .
238. S. Singh. The Science of Secrecy
The Histroy of Codes and Codebreakrng ,
Fourth Estate, London, 2000 .
239. Al. K. Sinisalo, "Checking the Goldhach Conjecture up to 4 10 11" . Mathe-
matics of Computation . 61 (1993) . 931934 .
240. M . Sipser, Introduction to the Theory of Computation, PW'S Publishing Com-
pany, Boston, 1997 .
241. D. Slowinski . "Searching for the 27th Mersenne Prime" . Journal of Recre-
ational Mathematics, 11 . 4(1978-79), 258-261 .
242. R. E. Smith . Internet Cryptography . Kluwer Academic Publishers, 1997 .
243. M . A. Soderstrand, W. K. Jenkins, G. A. Jullien and F . J. Taylor, Residu e
Number System Arithmetic, Modern Applications in Digital Signal Processing,
IEEE Press. 1986 .
244. R. Solovay and Y. Strassen, "A Fast Monte-Carlo Test for Primality", SIA M
Journal on Computing, 6, 1(1977) . 84 85. "Erratum: A Fast Monte-Carlo Test
for Primality- " . SIAM Journal on Computing. 7 . 1(1978), 118 .
245. I. Stewart . "Geometry Finds Factor Faster", Nature . 325. 15 January 1987 .
199 .
246. D. R. Stinson, Cryptography: Theory and Practice. CRC Press. 1995 .
247. N. S. Szabo and R. I. Tanaka, Residue Arithmetic and its Applications to
Computer Technology . McGraw-Hill, 1967 .
248. H. C. A. van Tilborg. An Introduction to Cryptography, Kluwer Academic
Publishers . 1988 .
249. I. A ardi, Computational Recreations in Mathematica . Addison-Wesley, 1991 .
250. M. VV'aldschmidt . P. Moussa. .1. M . Luck and C. Itzykson. From Number The-
ory to Physics . Springer-Verlag, 1.992 .
251. S Wagon . "Primality Testing", The Mathematical Intelligencer. 8 . 3(1986) .
58-61 .
252. D . Welsh . Codes and Cryptography . Oxford University Press. 1989 .
253. H . Wiener. °Crvptanalvsis of Short RSA Secret Exponents, IEEE Transac-
tions on Information Theory. 36. 3(1990) 553558 .
254. A . Wiles, 'Modular Elliptic Curves and Fermat 's Last Theorem " . Annals of
Mathematics . 141 (1995). 443-551 .
255. H. C. Williams. "The Influence of Computers in the Development of Number
Theory- . Computers & Mathematics with Applications, 8 . 2(1982) . 75-93 .
256. H. C . Williams .
"Factoring on a Compute{, Mathematical Intelligencer . 6 ,
3(1984), 29 36 .
257. H. C . Williams . Edouard Lucas and Primalitc Testing. John Wiley & Sons .
1998 .
258. C. P. Williams and S. H. Clearwater. Explorations in Quantum Computation .
The Electronic Library of Science (TELOS) . Springer-Verlag, 1998 .
259. H . VV'oll. "Reductions Among Number Theoretic Problems" . Information an d
Computation . 72 (1987) . 167-179 .
260. S . Y. Yan. "Primality Testing of Large Numbers
Mathematics with Applications, 29 . 12(1995) . 18 .
261. S . Y. Yan, Perfect, Amicable and Sociable Numbers A Computational Ap-
proach, World Scientific, 1996 .
262. S . Y. Yan, An Introduction to Formal Languages and _Machine Computation.
World Scientific, 1998 .
263. J. Young. "Large Primes and Fermat Factors" . Mathematics of' Computation,
67 (1998) . 1735 1738 .
264. R. Yuan and W . T. Strayer. Virtual Private Networks
Technologies an d
Solutions, Addison-Wesley. 2001.
265. K. C. Zeng, C. H . Yang. D . Y. Wei and T. R . N. Rao, "Pseudorandom Bit
Generators in Stream-Cipher Cryptography", Computer, 24, 2(1991) . 8-17 .
n Maple' . Computers &

Index
(k. n)-threshold scheme, 39 9
R(x), 103
EXP. 182
A'P. 182
.VP-complete, 18 7
A-P-hard. 187
P, 18 2
.1(n) . 92
),(n), 81
µ(n), 82
0(n), 79
x, 17 6
7(x), 86
712(x) . 106
7ru(x), 36
ri(x), 92
o(n), 66
T(n), 66
9(x), 90
c(s), 95
b-sequence, 20 9
kth (higher) power nonresidue, 15 7
kth (higher) power residue, 157
kth power nonresidue, 135
kth power residue, 13 5
nth prime. 105
s(n), 66
.VP-SPACE, 18 4
P-SPACE. 184
Li(x). 94
Abel, N . H . . 16
adder . 31 6
additive group. 16
additive identity. 19
additive inverse, 19
additivitv. 6
Adleman. L . . 358
Advanced Encryption Standard (AES) ,
347
affine transformation. 337
Al-Khwarizmi, 17 7
algebraic computation law . 164
algebraic equation . 54
algebraic numbers. 1 5
algorithm. 23. 177
aliquot k-cycle, 71
alphabet ; 183
amicable k-tuple, 7 1
amicable pair, 71 . 176, 292
amicable triple, 71
APR test, 22 6
APRCL test, 226
arithmetic function. 63
arithmetic mean, 70
arithmetic progression of primes, 110 ,
176
associativity, 16
asymmetric cryptosystems, 33 3
asymmetric key crvptosystem, 35 1
Atkin, A. O. L ., 223
authentication . 332
base-2 pseudoprimality test, 20 8
basis vector, 274
Bernoulli's number. 96
binary computers . 312
binary Goldbach conjecture . 8, 295
binary operation . 15
bit operation, 191
block cipher. 338
Brent. R. P., 248
Bruns constant . 108
Caesar cipher . 336
Caesar. J.. 336
Carmichael number. 20 7
Carmichael 's A-function. 81 . 127
Carmichael 's theorem, 127
Carmichael. R. D., 81
CFRAC factoring algorithm, 239
CFRAC method . 237

Index
430
Chin Chiu-Shan . 112. 130
character cipher . 335
Chebvshev's function, 9 0
Chebyshev. P. L . . 90
check digit . 322
Chen, J . R., 9, 109
Chinese Remainder Theorem (CRT) ,
130, 395. 399
Chinese test . 208
Church, A .. 180
Church-Turing thesis. 180
ciphertext space, 33 3
closure, 15
Cocks, C. C., 350
coin tossing states . 179
collision resistant . 321
combined test, 218
common multiple . 31
commutative group. 16
commutative ring, 1 8
commutativity. 16
complement. 183
complete quotients. 51
complete system of residues . 115
completely multiplicative function . 64
complex numbers, 1 5
complex zeros. 98
complexity classes . 183
composite Fermat numbers. 36
composite number, 24
computable. 178
computation. 180
computationally intractable (or
infeasible) . 185
computationally tractable (or feasible) ,
185
congruence. 111
congruence classes . 113
congruent. 112
consecutive pairs of quadratic residues ,
136
consecutive triples of quadratic
residues . 137
continued fraction, 44
Continued FRACtion (CFRAC )
method. 230
convergent. 45
convergents, 5 5
Converse of Fermat 's little theorem _
126
Converse of Wilson's theorem. 128
Cook. S., 186
Cook Karp Thesis, 186
Index
covered writing, 409
cryptanalysis. 332
cryptographic tunnels . 404
cryptography. 332
cryptology. 332
cubic Diophantine equation . 160
cyclic group, 17
Data Encryption Standard (DES) . 344 .
367
database decryption . 39 7
database encryption, 39 6
database security . 395
De la Vallee Poussin, C. J .. 91
decidable, 178
decision problem, 18 3
decryption key, 33 3
decryption process (algorithm), 33 3
deterministic encryption . 373
Deutsch. D . . 273
Dickson. L. E., 303
Diffie . W ., 348
Diffie-Hellman-Merkle key-exchange ,
354
Digital Signature Algorithm (DSA) ,
392
Digital Signature Standard (DSS) . 392
digital signatures. 385
Diophantme equation, 53
Diophantus, 5 2
Dirac. P. A. M . . 274
Dirichlet characters, 10 2
Dirichlet L-fimctions, 10 2
Dirichlet series. 102
Dirichlet, J. P. G . L., 101
discrete exponential bit generator, 33 1
discrete exponential generator, 33 0
discrete logarithm . 156
discrete logarithm problem. 254. 35 3
Disquisitiones Arithmeticae . 11 1
dividend . 23
divisibility. 21
division algorithm, 23
division ring . 1 8
divisor, 21
domain. 63
double encryption . 346
double hash . 31 8
ECPP (Elliptic Curve Primality
Proving), 22 3
ECPP Algorithm, 22 4
effective procedure. 177
efficient (good) algorithm, 18 4
electronic commerce. 405
ElGatnal crvptosystem, 35 6
elliptic curve, 160 . 379
elliptic curve analogue of Diffie –
Hellman. 381
elliptic curve analogue of ElGamal. 382
elliptic curve analogue of Massey–
Omura. 381
elliptic curve analogue of R.SA, 382
elliptic curve bit generator, 33 1
elliptic curve cryptography (ECC), 37 9
Elliptic Curve Digital Signature
Algorithm (ECDSA) . 394
elliptic curve discrete logarith m
problem (ECDLP), 266
elliptic curve test . 222
elliptic function . 162
elliptic integral, 16 2
Ellis. J . H . . 350
embedded message, 40 9
embedding messages on elliptic curves .
380
encryption key, 333
encryption process (algorithm), 33 3
ENIGMA code . 333
equivalence classes, 113
equivalence relation . 11 3
Eratosthenes of Cvrene . 26
Eras, P., 93
error detection and correction . 321
Euclid . 2, 24
Euclid's algorithm . 40, 41
Euclid 's Elements, 42
Euclid Euler Theorem, 7 2
Eisler probable prime, 21 4
Euler pseudoprirne, 214
Eider ' s (totient) d-function, 7 9
Elder's criterion . 139
Euler's pseudoprimality test. 214
Eider's rule for amicable pairs, 7 7
Euler's theorem . 126
Euler. L . . 77
even number . 24
exclusive or (XOR) . 344
exponential complexity. 193
exponentially bounded . 182
exponentially solvable. 182
extended Euclid's algorithm . 12 2
factor. 21
factoring by trial divisions, 232
fast group operations. 199
fast modular exponentiations, 19 6
fast point additions. 199
Federal Information Processing
Standard. 344
Fermat numbers, 36, 17 5
Fermat probable prime, 20 6
Fermat pseudoprime . 206
Fermat 's factoring algorithm . 234
Fermat's Last Theorem (FLT) . 12
Fermat's little theorem_ 12 5
Fermat's pseudoprimality test. 206
Fermat. P. . 12
Fevnman, R. P. . 273
Fibonacci numbers, 21 6
Fibonacci. L . P .. 216
field. 1 8
finite fields. 20
finite group, 1 6
finite order of a point on an ellipti c
curve. 168
finite simple continued fraction . 46
FIPS 186, 39 2
FIPS 46, 344
FIPS 46-2. 344
FIPS 46-3. 344
firewall, 40 3
fixed-base number systems . 305
fixed-point attack, 37 2
Fundamental Theorem of arithmetic ,
28, 30 5
Galileo spacecraft, 32 5
Galois field. 20
Galois . E, 20
Gauss's lemma, 14 1
Gauss. C. F. 89
Generalized Riemann Hypothesis, 102
generating function . 102
geometric composition law. 164
geometric mean . 68
Goldbach partition . 1 0
Goldbach's conjecture . 6. 176 . 295
Goldwasser. S .. 222
greatest common divisor (gcd) . 29
group, 15
group laws on elliptic curves, 16 8
Hadanrard . .J .. 91
halting problem, 18 1
Hardy, G. H .. 8
Hardy Rarnanujan taxi number . 10
harmonic mean, 7 0
hash function, 317

430
Index
Index
431
Ch'in Chiu-Shao . 112. 130
character cipher, 33 5
Chebvshev's function. 90
Chebvshev. P. L . . 90
check digit . 322
Chen, J. R .. 9. 109
Chinese Remainder Theorem (CRT) .
130. 395. 399
Chinese test. 208
Church. A .. 180
Church-Turing thesis, 18 0
ciphertext space, 33 3
closure. 1 5
Cocks. C. C., 350
coin tossing states . 179
collision resistant, 321
combined test, 218
common multiple, 3 1
commutative group . 1 6
commutative ring, 1 8
commutativity, 16
complement, 18 3
complete quotients. 51
complete system of residues, 11 5
completely multiplicative function, 6 4
complex numbers, 15
complex zeros. 98
complexity classes . 183
composite Fermat numbers . 36
composite number. 24
computable. 178
computation, 18 0
computationally- intractable (or
infeasible), 18 5
computationally tractable (or feasible) ,
18 .5
congruence. 111
congruence classes, 11 3
congruent. 112
consecutive pairs of quadratic residues .
136
consecutive triples of quadratic
residues. 137
continued fraction . 44
Continued FR ACtion ((FR AC)
method . 230
convergent. 45
convergents. 55
Converse of Fermat 's little theorem.
12 6
Converse of \Vilson ' s theorem. 128
Cook. S .. 186
Cook-Karp Thesis, 186
covered writing. 409
c ryptanalvsis, 33 2
cryptographic tunnels .. 404
cryptography. 332
cryptology, 332
cubic Diophantine equation. 160
cyclic group. 17
Data Encryption Standard (DES), 344 .
367
database decryption . 397
database encryption . 396
database security. 395
De la Vallee-Poussin . C. J., 9 1
decidable, 17 8
decision problem . 183
decryption key. 333
decryption process (algorithm) 333
deterministic encryption . 373
Deutsch, D . . 273
Dickson . L. E . . 303
Diffie . AV .. 348
Diffie-Hellman-Slerkle key-exchange,
354
Digital Signature Algorithm (DSA) .
392
Digital Signature Standard (DSS). 392
digital signatures . 385
Diophantine equation. 53
Diophantus, 5 2
Dirac, P. A. M .. 274
Dirichlet characters, 10 2
Dirichlet L-functions, 10 2
Dirichlet series. 102
Dirichlet, J. P. G . L .. 101
discrete exponential bit generator . 331
discrete exponential generator, 33 0
discrete logarithm . 156
discrete logarithm problem . 254, 353
Disquisitiones Arithmeticae . 111
dividend. 23
divisibility, 21
division algorithm . 23
division ring. 1 8
divisor, 21
domain 6 3
double encryption . 346
double hash. 31 8
ECPP (Elliptic Curve Pr
Proving) . 223
ECPP Algorithm, 22 4
effective procedure, 177
efficient (good) algorithm, 18 4
electronic commerce, 40 5
ElGamal cryptosystem, 35 6
elliptic curve. 160 . 379
elliptic curve analogue of Diffie–
Hellman, 381
elliptic curve analogue of ElGamal . 382
elliptic curve analogue of Masse y
Omura, 381
elliptic curve analogue of RSA. 382
elliptic curve bit generator . 331
elliptic curve cryptography (ECC) . 379
Elliptic Curve Digital Signature
Algorithm (ECDSA). 394
elliptic curve discrete logarithm
problem (ECDLP) . 266
elliptic curve test, 22 2
elliptic function . 16 2
elliptic integral. 162
Ellis. J . H . . 3 .50
embedded message, 40 9
embedding messages on elliptic curves ,
380
encryption key, 33 3
encryption process (algorithm) . 333
ENIGMA code, 333
equivalence classes. 113
equivalence relation. 113
Eratosthenes of Cyrene_26
Erdos. P .. 93
error detection and correction, 32 1
Euclid, 2 . 24
Euclid's algorithm . 40, 41
Euclid's Elements, 42
Euclid–Euler Theorem. 72
Euler probable prime . 214
Euler pseudoprime . 214
Euler's (totient) q function, 7 9
Eukr's criterion, 13 9
Euler's pseudoprimality test. 214
Euler's rule for amicable pairs, 77
Euler's theorem . 126
Eviler, L .. 77
even number. 24
exclusive or (NOR), 34 4
exponential complexity, 19 3
exponentially bounded, 182
exponentially solvable, 182
extended Euclid 's algorithm . 122
factor. 21
factoring by trial divisions . 232
fast group operations, 199
fast modular exponentiatfons . 196
fast point additions, 199
Federal Information Processing
Standard. 344
Fermat numbers. 36. 175
Fermat probable prime . 206
Fermat pseudoprime . 206
Fermat's factoring algorithm, 234
Fermat 's Last Theorem (FLT), 1 2
Fermat's little theorem, 12 .5
Fermat's pseudoprimality test. 206
Fermat, P .. 12
Feynman. R. P .. 273
Fibonacci numbers. 216
Fibonacci. L. P., 216
field, 18
finite fields, 20
finite group. 16
finite order of a point on an ellipti c
curve. 168
finite simple continued fraction . 46
FIPS 186. 392
FIPS 46, 344
FIPS 46-2 . 344
FIPS 46-3, 344
fnewall . 403
fixed base number systems, 30 0
fixed-point attack. 372
Fundamental Theorem of Arithmetic ,
28. 305
Galileo spacecraft, 32 0
Gatos field, 20
Galois . E . 20
Gauss 's lemma. 141
Gauss. C. F .. 89
Generalized Riemann Hypothesis . 102
generating function. 102
geometric composition lax, 164
geometric mean . 68
Goldbach partition . 10
Goldbach's conjecture. 6. 176. 295
Goldwasser. S . . 222
greatest common divisor (gcd). 29
group. 1 5
group laws on elliptic curves. 168
Hadamard. J . . 91
halting problem, 18 1
Hardy. G . H . . 8
Hardy Ramanujan taxi number. 10
harmonic mean . 70
hash function, 317

432
Index
Index
43
Hasse. H. 169
height of a point, 16 6
Hellman, M. E . . 348
high-order congruence. 133
Hilbert space. 274
hybrid cryptosystem, 35 4
identity, 1 6
incongruent . 11 2
index calculus. 262
index of a to the base q . 156
index of an integer modulo n . 155
inefficient (bad) algorithm) . 184
infinite fields, 2 0
infinite group, 1 6
infinite order of a point on an ellipti c
curve. 168
infinite simple continued fraction . 48
instantaneous description (ID), 18 0
Integer, 14
integer factorization problem, 228, 35 2
integral domain, 18
International Standard Book Number
(ISBN), 32 2
Internet, 403
inverse, 1 6
invertible function, 35 2
irrational number . 15
irrational numbers, 48
isomorphic, 30 9
isomorphism, 30 9
Jacobi symbol, 14 7
Jacobi, C. G .. 147
Karp. R., 186
key bundle. 346
key space, 333
Kilian, J., 222
Knuth . D . E . . 229
Koblitz, N. 379
Kronecker. L . . 14
Lagarias, J. C .. 288
Landau. E . . 8
language. 183
least (nonnegative) residue of z modul o
n . 11 4
least common multiple (lcm) . 31
least nonnegative residue. 112
least residue. 141
Legendre symbol. 139
Legend re's congruence, 234
Legendre. A . _M .. 89. 139
Lehman's method. 229
Lehner, D . H . . 218
Lenstra's Elliptic Curve Metho d
(ECM), 230, 25 1
Lenstra, H. W. Jr_. 251
linear congruence. 123
linear Congruential generator, 32 7
linear Diophantine equation. 54
Littlewood, J. E . . 8
logarithm . 189
logarithmic integral, 94
Lucas numbers, 21 6
Lucas probable prime. 21 7
Lucas pseudoprimality test, 21 8
Lucas pseudoprinre. 217
Lucas sequences, 21 5
Lucas test, 217
Lucas theorem, 21 7
Lucas. F. E . . 21 5
Lucas -Lehmer test, 21 8
Lucas-Lehner theorem, 21 9
Lucas-Lehmer test for Mersenn e
primes, 22 0
Mobius p.-function, 82
Mobius inversion formula, 83
Mobius. A. F., 82
magnitude, 31 5
Massey-Omura crJ ptosystem, 357
Meissel, D. F. E .. 287
Menezes, A . J .. 383
Merkle, R. C .. 349
Mersenne number . 33
Mersenne primes. 34. 175
Mersenne, M ., 33
Mertens's conjecture . 78
message concealing, 41 0
message digest . 321 . 392
message extracting . 410
message space . 333
middle-square method, 326
Miller, G .. 21 0
Miller-Rabin test . 210
minimal perfect hash function . 32 0
minimal collision-free hash function .
320
mixed-base number systems. 305
modular arithmetic in Z/nZZ, 118
modular exponentiation. 195
modular inverse . 12 0
modulus. 112
monographic cipher, :335
inonoid, 16
Morain . F .. 223
Mordell, L. J ., 170
multiple, 21
multiple encryption, 346
Multiple Polynomial Quadratic Sieve
(MPQS) . 230
multiplicative function. 64
multiplicative generator, 32 8
multiplicative group, 1 6
multiplicative identity. 1 9
multiplicative inverse, 19 . 120
multiplicativity. 5
National firstitute of Standards an d
Technology (KIST), 344
natural numbers, 1 4
non secret cover-message, 409
non-secret encryption, 35 1
non-zero field element, 1 9
noncomputable, 17 8
nonnegative integers, 14
nonpositional number systems. 305
nontrivial divisor. 22
nontrivial square root of 1, 209
nontrivial zeros, 9 8
nonrritness, 213
Number Field Sieve (NFS), 5 . 230, 242 ,
265
number systems, 30 5
odd number, 2 4
odd perfect numbers, 17 5
Odlyzko, A. M . . 78, 288
one's complement representation, 31 6
one-way function. 35 2
one-way hash function . 321
order of a modulo n . 15 1
order of a field, 20
order of a group, 1 7
order of a point on an elliptic curve .
168
packer filter . 403
parity. 2
parity check . 3. 32 1
parity check bit . 32 1
partial quotients. 45
Pell 's equation . .5 7
perfect hash function, 32 0
perfect number, 7 1
period. 50
periodic simple continued fraction, 5 0
Pocklington's theorem, 222, 370
point at infinity, 161
polarization, 41 0
Pollard's p factoring algorithm, 24 8
Pollard's p-method. 230, 244
Pollard's "p - 1" factoring algorithm .
250
Pollard's "p - 1 " method. 250
Pollard, J. M., 244
polygraphic cipher, 338
polynomial bounded, 18 2
polynomial complexity . 193
polynomial congruence . 133
polynomial congruential equation, 133
polynomial security. 373
polynomially solvable, 182
Pomerance, C .. 240
positional number systems. 305
positive integers, 14
power generator. 329
practically feasible computation, 18 2
practically tractable computation, 18 2
primality, 4
primality testing problem, 20 2
prime counting function, 86
prime distribution function, 8 6
prime factor, 27
prime factorization, 5
prime Fermat numbers, 3 6
prime number. 24
Prime Number Theorem, 8 8
prime numbers, 85
prime power, 20
prime power decomposition, 2 8
prime triples . 4
primitive root of n. 152
principle of superposition, 275
privacy. 332
private key. 352
probabilistic encryption. 373. 375
probabilistic Turing machine (PTM) ,
179
probable prime, 206
proper divisor. 21
pseudoprime, 206
pseudorandom numbers . 326
public key. 352
public-key cryptography. 333
public. key cryptosystem. 354
purely periodic simple continued
fraction, 50
Pythagoras, 7 6
quadratic congruence, 13 4
quadratic Diophantine equation, 57

Index
434
quadratic irrational . 50
quadratic nonresidue, 13 5
quadratic nonresidue modulo n, 353
Quadratic reciprocity law, 14 4
quadratic residue, 13 5
quadratic residue modulo n. 353
quadratic residues generator, 33 0
Quadratic Residuosity Problem (QRP) ,
353 . 374
Quadratic Sieve (QS) . 240
quantum algorithm for discrete
logarithms, 28 5
quantum algorithm for intege r
factorization, 28 2
quantum bit, 274
quantum computer . 274. 276
quantum cryptography, 41 0
quantum operation. 277
quantum register, 276 . 282
quantum state. 274
quantum Turing machine (QTM) . 278
qubit, 278
quotient . 23
Rabin's modified bit generator, 33 1
Rabin. M. O . . 210
Ramanujan, S., 10
random number generation, 326
random numbers. 326
randomized encryption. 373
rank of an elliptic curve . 171
rational numbers. 15. 46
read-keys, 39 6
real number . 50
real numbers, 1 5
real zeros, 98
real-valued function . 63
realbase logarithm, 155
rectilinear polarization, 410
reduced system of residues modulo n .
117
reflexive, 113
relatively prime. 30
remainder. 23
repeated doubling and addition, 19 9
repeated doubling method, 380
repeated multiplication, 195
repeated squaring, 19 5
repeated squaring and multiplication ,
195
residue, 11 2
residue arithmetic in (TG/nZ)` , 311
residue class . 113
Index
residue classes . 113
residue classes modulo rz. 1 5
residue computers . 313
residue number systems. 305 . 312
residue of .r modulo n, 113
residue representation of a number. 306
Riemann (-function, 95
Riemann function. 103
Riemann Hypothesis (RH) . 98, 176
Riemann, G. F. B, 91, 95
ring, 17
ring with identity, 1 8
Rivest. R. L., 358
root finding problem. 271, 372
RSA Assumption, 358
RSA bit generator, 33 1
RSA cryptosystem, 35 8
RSA generator, 329
running time, 18 2
secret key. 333. 352
secret sharing. 399
secret-key cryptography, 33 3
secret-key cryptosystem, 35 4
Selberg's estimate, 92
Selberg, A .. 92
Selfridge, J. L .. 210
semantic security. 373
semigroup, 16
seminumerical method, 29 3
Shamir, A., 358
Shanks' baby-step giant-step method
for discrete logarithms . 256
Shanks ' class group method, 22 9
Shanks' SQUFOF method, 22 9
Shanks, D., 255
Shannon bits, 274
Shannon. C. E .. 190
shift transformation. 337
Shot, P., 281
Sieve of Eratosthenes. 26
sign bit . 315
signature generation, 392
signature verification, 39 2
signed-magnitude representation, 31 5
Silver-PohligHellman algorithm, 25 8
simple continued fraction, 4 5
sociable group . 71
Solovay, R .. 226
Solovay-Strassen test . 214
solvable. 178
square generator, 33 0
square root method . 258
standard prime factorization, 2 8
steganographic system, 41 0
steganography, 409
stego-key-, 40 9
stego-message, 409
Strassen, V . . 226
strong probable prime, 210
strong pseudoprimality test, 208, 21 0
strong pseudoprime. 210
strong test, 208
subexponential complexity, 231
subgroup . 17
substitution cipher, 33 5
sunrmatory function of .1(n). 92
Sun Zi, 130
superposition, 277
symmetric, 11 3
symmetric cryptosystems, 333
Taylor. R .. . 12
te Riele 's rule, 78
te Riele. H . J. J . . 78
ternary Goldbach conjecture, 8, 29 5
Thabit ibn Qurra, 74
Thabit's rule for amicable pairs, 7 5
time complexity function, 18 2
torsion subgroup, 171
transcendental numbers . 15
transitive . 113
trapdoor, 35 2
trapdoor one-way function, 35 2
trial division. 230
Triple DES (TDES) . 346
trivial divisor. 22
trivial zeros . 98
Tukey, J. W., 282
Turing machine, 178
Turing. A . M .. 178
Twin Prime Conjecture . 109
twin primes, 4, 8 5
two's complement representation, 31 6
U.S . National Institute of Standard s
and Technology (NIST), 39 2
undecidable. 178
unsolvable. 178
Vanstone, S. A ., 383
\- inogradov. I. M . . 9
Virtual Private Networks, 405
von Mangoldt function, 9 2
von Neumann, .J., 326
Waring's problem, 176
Wiener's attack, 37 2
Wiles. A. J., 11. 12
Williamson, M. J ., 351
Wilson's theorem . 128
Wilson, J., 128
witness, 213
words. 315
write-keys, 39 6
xedni calculus. 267

